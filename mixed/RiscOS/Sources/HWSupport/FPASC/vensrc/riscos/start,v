head	4.11;
access;
symbols
	FPASC-4_36:4.11
	FPASC-4_35:4.11
	FPASC-4_34:4.11
	FPASC-4_33-1:4.11
	FPASC-4_33:4.11
	FPASC-4_32:4.11
	FPASC-4_31:4.10
	FPASC-4_30:4.10
	FPASC-4_29:4.10
	FPASC-4_28-2:4.9
	FPASC-4_28:4.9
	FPASC-4_27:4.9
	FPASC-4_26:4.9
	FPASC-4_25:4.9
	FPASC-4_24:4.9
	FPASC-4_23:4.9
	RO_5_07:4.9
	FPASC-4_22:4.9
	FPASC-4_21:4.9
	FPASC-4_20:4.9
	FPASC-4_19:4.9
	FPASC-4_18:4.9
	FPASC-4_17:4.9
	FPASC-4_16:4.7
	FPASC-4_15:4.7
	FPASC-4_14:4.7
	dellis_autobuild_BaseSW:4.6
	FPASC-4_13:4.6
	FPASC-4_12:4.6
	FPASC-4_10-4_3_2_2:4.4.2.2
	sbrodie_sedwards_16Mar2000:4.5
	kbracey_32bit_merge:4.4.2.1
	FPASC-4_11:4.5
	FPASC-4_10-4_3_2_1:4.4.2.1
	kbracey_32bit:4.4.0.2
	dcotton_autobuild_BaseSW:4.9
	FPASC-4_10:4.4
	Ursula_merge:4.2.2.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.1
	Ursula_RiscPC:4.2.2.1.0.2
	nicke_FPASC-4_05:4.1.7.1
	FPASC-4_09:4.3
	rthornb_UrsulaBuild-19Aug1998:4.2.2.1
	UrsulaBuild_FinalSoftload:4.2.2.1
	rthornb_UrsulaBuild-12Aug1998:4.2.2.1
	aglover_UrsulaBuild-05Aug1998:4.2.2.1
	rthornb_UrsulaBuild-29Jul1998:4.2.2.1
	rthornb_UrsulaBuild-22Jul1998:4.2.2.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.1
	rthornb_UrsulaBuild-07Jul1998:4.2.2.1
	rthornb_UrsulaBuild-17Jun1998:4.2.2.1
	rthornb_UrsulaBuild-03Jun1998:4.2.2.1
	rthornb_UrsulaBuild-27May1998:4.2.2.1
	rthornb_UrsulaBuild-21May1998:4.2.2.1
	rthornb_UrsulaBuild_01May1998:4.2.2.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.2
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.11
date	2013.05.31.19.00.21;	author jlee;	state Exp;
branches;
next	4.10;
commitid	MkHF99Q2X6ELDORw;

4.10
date	2011.08.06.20.20.22;	author jlee;	state Exp;
branches;
next	4.9;
commitid	RGwDCySu9G6uquuv;

4.9
date	2001.08.31.13.51.14;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	2001.08.31.11.06.07;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	2000.10.02.16.02.01;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2000.03.24.10.53.17;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.11.26.14.37.36;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	99.08.03.17.57.03;	author kbracey;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	98.09.21.12.36.58;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.02.09.52.12;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.35.56;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.4.2.1
date	99.11.23.17.19.17;	author kbracey;	state Exp;
branches;
next	;

4.2.2.1
date	98.03.27.10.35.21;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.35.56;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.25.17;	author nturton;	state Exp;
branches
	4.1.3.1.2.1;
next	4.1.3.2;

4.1.3.2
date	97.05.01.14.36.00;	author kbracey;	state Exp;
branches;
next	;

4.1.3.1.2.1
date	97.04.30.12.28.20;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.52.06;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.46.50;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.11
log
@Fix interaction with undefined instruction environment handler in pre-RISC OS 3.5 builds
Detail:
  Code restructuring performed in FPASC-4_12 resulted in an unintentional change in behaviour on ARM2/ARM3 systems when FPEmulator attempts to pass on an abort to the next claimant of the undefined instruction vector.
  Specifically, FPEmulator's startup code was making a note of the address of the current undef environment handler, instead of the address of the pointer to the current handler. This meant that if OS_ChangeEnvironment was used to change the handler once FPEmulator had been loaded, the new handler would never get called - only the old handler would get called.
  On later systems this bug didn't occur as (a) the kernel has a veneer around the undef environment handler (instead of branching straight to the current claimant from the undef vector), and (b) OS_ClaimProcessorVector tells FPEmulator directly where to go next instead of the module having to try and guess for itself.
  File changes:
  - vensrc/riscos/start: Adjust handling of "LDR PC,xxx" undef vector so that the address being loaded from is cached instead of the contents of the address. Construct special code to use when the FPEmulator context is disabled and we want to immediately pass along the abort.
  - vensrc/riscos/globalws: Reserve workspace for storing the passalong code
Admin:
  Tested on RISC OS 3.1 under ArcEm
  ARM3 detection routines which rely on the undef environment handler now work correctly instead of failing with undefined instruction errors
  No impact on builds targeting RISC OS 3.5+ as all changes are wrapped in [ :LNOT: Arm600 ]


Version 4.32. Tagged as 'FPASC-4_32'
@
text
@; >riscos.start
;
; Copyright (c) 1993 Acorn Computers Ltd., Cambridge, England.
;
; Assembler source for FPA support code and emulator
; ==================================================
; RISCOS veneer code assembled before the core routines
;

;
; character constants
;
NULL            *       &00
TAB             *       &09
LF              *       &0a
CR              *       &0d

;
; base of module SWI chunk
;
FPESWIBase      *       &40480

;
; **********************************************************************
;
; Module Header
;
        AREA    |!!!Module$Header|, CODE, READONLY

        ENTRY

Module_BaseAddr

        ASSERT  (. - Module_BaseAddr) = 0

        DCD     0                               ; Start code (there isn't any)
        DCD     FPEInit - Module_BaseAddr       ; Initialisation code
        DCD     FPEFinal - Module_BaseAddr      ; Finalisation code
        DCD     FPEServ - Module_BaseAddr       ; Service Call handler
        DCD     FPETitle - Module_BaseAddr      ; Title string
        DCD     FPEHelp - Module_BaseAddr       ; Help string
        DCD     0                               ; *commands (there aren't any)
        DCD     FPESWIBase                      ; SWI chunk base number
        DCD     FPESWI - Module_BaseAddr        ; SWI handler code
        DCD     FPESTable - Module_BaseAddr     ; SWI decoding table
        DCD     0                               ; SWI decoding code
        DCD     0                               ; Message file
 [ Arm600 :LAND: {CONFIG}=32
        DCD     FPEFlags - Module_BaseAddr
 ]

;
; Header is complete, dump miscellaneous strings and tables
;

;
; Title string is shared with start of SWI decoding table
;
FPETitle
FPESTable
        DCB     "FPEmulator", 0
        DCB     "Version", 0
        DCB     "DeactivateContext", 0
        DCB     "ActivateContext", 0
        DCB     "ChangeContext", 0
        DCB     "ContextLength", 0
        DCB     "InitContext", 0
        DCB     "ExceptionDump", 0
        DCB     "Abort", 0
        DCB     "LoadContext", 0
        DCB     "SaveContext", 0
        DCB     0
        ALIGN

BadSWIToken
        DCD     &1E6
        DCB     "BadSWI", 0
        ALIGN

 [ Arm600 :LAND: {CONFIG}=32
FPEFlags
        DCD     1                               ; 32-bit compatible
 ]

 [ FPEAnchorType = "Local"
FPEAnchor
        DCD     0
 ]

;
; Despite what the current issue of the PRMs claims, ALL versions of
; the FPEmulator, whether hardware only, hardware/software, or
; software only, must have a version number greater than 4.00.  This
; allows software to easily test whether the additions to the floating
; point instruction set introduced with the FPA are available on a
; particular machine (by using RMEnsure FPEmulator 4.00).
;
        ASSERT  Module_Version >= 400

;
; **********************************************************************
;
; FPESWI - R10 to R12 may be corrupted
;
; The core routines called here will expect to be called in SVC32 mode
; if we're using the 32-bit core (ie if {CONFIG} = 32)
;
FPESWI          ROUT
        CMP     r11, #(EndOfSWIJumpTable - SWIJumpTable) / 4
        ADDLO   pc, pc, r11, LSL #2
        B       UnknownSWIError
SWIJumpTable
        B       FPESWI_Version
        B       FPESWI_DeactivateContext
        B       FPESWI_ActivateContext
        [ MultipleContexts
        B       FPESWI_ChangeContext
        B       FPESWI_ContextLength
        B       FPESWI_InitContext
        |
        B       UnknownSWIError
        B       UnknownSWIError
        B       UnknownSWIError
        ]
        B       FPESWI_ExceptionDump
        B       FPESWI_Abort
        B       FPESWI_LoadContext
        B       FPESWI_SaveContext
EndOfSWIJumpTable

UnknownSWIError
        STMFD   sp!,{r0-r2,r4,lr}
        ADR     r0, BadSWIToken
        MOV     r1, #0
        MOV     r2, #0
        ADR     r4, FPETitle
        SWI     XMessageTrans_ErrorLookup
        LDMFD   sp!,{r0-r2,r4,pc}

FPESWI_Version
        LDR     r0, =Module_Version
      [ Arm600
        MRS     r11, CPSR
        TST     r11, #2_11100
        MOVNE   pc, lr                  ; 32-bit return
      ]
        MOVS    pc, lr

        ASSERT  Rwp = r10

FPESWI_DeactivateContext
      [ MultipleContexts
        LDR     Rwp, [r12]
        ADR     r11, DefaultContext
      |
        LDR     r11, [r12]
      ]

        MOV     r12, lr
        BL      core_deactivatecontext
        TEQ     r0, r11
        MOVEQ   r0, #-1                 ; check for default context
 [ Arm600
        MRS     r11, CPSR
        TST     r11, #2_11100
        MOVNE   pc, r12                 ; 32-bit return
 ]
        MOVS    pc, r12                 ; 26-bit return

FPESWI_ActivateContext
        CMP     r0, #-1                 ; handle "default context"
        LDREQ   r10, [r12]
      [ MultipleContexts
        ADREQ   r10, DefaultContext
      ]
        MOVNE   r10, r0                 ; r10 -> context
        MOV     r12, lr
        BL      core_activatecontext
 [ Arm600
        MRS     r11, CPSR
        TST     r11, #2_11100
        MOVNE   pc, r12                 ; 32-bit return
 ]
        MOVS    pc, r12                 ; 26-bit return

    [ MultipleContexts
FPESWI_ChangeContext
        CMP     r0, #-1
        LDR     r11, [r12]
        ADDEQ   r10, r11, #:INDEX:DefaultContext
        MOVNE   r10, r0

        MOV     r12, lr
        BL      core_changecontext

        ADD     lr, r11, #:INDEX:DefaultContext
        TEQ     r0, lr
        MOVEQ   r0, #-1
 [ Arm600
        MRS     r11, CPSR
        TST     r11, #2_11100
        MOVNE   pc, r12                 ; 32-bit return
 ]
        MOVS    pc, r12                 ; 26-bit return

FPESWI_ContextLength
        MOV     r0, #ContextLength
 [ Arm600
        MRS     r11, CPSR
        TST     r11, #2_11100
        MOVNE   pc, lr                  ; 32-bit return
 ]
        MOVS    pc, lr                  ; 26-bit return

FPESWI_InitContext
        CMP     r0, #-1
      [ MultipleContexts
        LDREQ   Rwp, [r12]
        ADREQ   r0, DefaultContext
      |
        LDREQ   r0, [r12]
      ]

        MOV     r12, lr
        MOV     r10, r0
        BL      core_initcontext
      [ Arm600
        MRS     r11, CPSR
        TST     r11, #2_11100
        MOVNE   pc, r12                 ; 32-bit return
      ]
        MOVS    pc, r12                 ; 26-bit return

    ]

FPESWI_Abort
        STMFD   sp!, {r1-r7,lr}
        LDR     r12, [r12]
        MOV     r10, r0
        CMP     r10, #-1
      [ MultipleContexts
        ADDEQ   r10, r12, #:INDEX:DefaultContext
      |
        MOVEQ   r10, r12
      ]
        CMP     r10, #-2
        LDREQ   r10, [r12, #:INDEX:CurrentContext]
        MOV     r0, r1
        MOV     r1, r2
        BL      core_abort
        LDR     r1, [sp, #4]
      [ {CONFIG}=26
        BIC     r1, r1, #PSR_mask
      ]
        ADRL    r2, FP_UndefHandlers_Start
        ADRL    r3, FP_UndefHandlers_End-4
        CMP     r1, r2
        CMPHS   r3, r1
        MOVLO   r0, #0
        ADDS    r0, r0, #0              ; clear V
        LDMFD   sp!, {r1-r7,pc}

FPESWI_SaveContext
        STMFD   sp!, {r1,lr}
        LDR     r12, [r12]
        MOV     r10, r0
        CMP     r10, #-1
      [ MultipleContexts
        ADDEQ   r10, r12, #:INDEX:DefaultContext
      |
        MOVEQ   r10, r12
      ]
        CMP     r10, #-2
        LDREQ   r10, [r12, #:INDEX:CurrentContext]
        MOV     r0, r1
        MOV     r1, r2
        BL      core_savecontext
        CMP     r0, #0                  ; clear V
        LDMFD   sp!, {r1,pc}

FPESWI_LoadContext
        STMFD   sp!, {r0,lr}
        LDR     r12, [r12]
        MOV     r10, r0
        CMP     r10, #-1
      [ MultipleContexts
        ADDEQ   r10, r12, #:INDEX:DefaultContext
      |
        MOVEQ   r10, r12
      ]
        CMP     r10, #-2
        LDREQ   r10, [r12, #:INDEX:CurrentContext]
        MOV     r0, r1
        BL      core_loadcontext
        ADDS    r0, r0, #0              ; clear V
        LDMFD   sp!, {r0,pc}

FPESWI_ExceptionDump
        LDR     Rwp, [r12]
        ADR     r0, FPExceptionDump
        MOV     pc, lr

;
; **********************************************************************
;
; FPEInit - Initialisation Code
;
FPEInit         ROUT
        STMFD   sp!, {r10, lr}

;
; check whether workspace already allocated
;
        LDR     r2, [r12]
        TEQ     r2, #0
        BNE     %F5

;
; no workspace allocated - claim some
;
        MOV     r0, #ModHandReason_Claim
        LDR     r3, =WorkspaceLength
        SWI     XOS_Module

;
; return error if SWI failed
;
        LDMVSFD sp!, {r10, pc}

;
; workspace claim succeeded: zero it and save it in private word
;
        STR     r2, [r12]
5       MOV     r10, r2

;
; workspace pointer claimed if necessary, save it away in our
; private piece of page 0, ready for retrieval during traps.
;
    [ FPEAnchorType = "Local"
        STR     r10, FPEAnchor
    |
        LDR     r0, =FPEAnchor
        STR     r10, [r0]
    ]
        MOV     r0, #0

        STR     r0, OldVector
        STR     r0, CoreVector

    [ Arm600
        MOV     r0, #6
        MOV     r1, #0
        MOV     r2, #OSRSI6_SVCSTK
        SWI     XOS_ReadSysInfo
        LDRVS   r2, =SVCSTK
    |
        LDR     r2, =SVCSTK
    ]
        STR     r2, SVCStack

;
; Open the messages file
;
        BL      open_message_file

    [ Arm600
        MRS     r0, CPSR
        AND     r0, r0, #2_11100
        STRB    r0, SysIs32bit
    |
        STRB    r0, SysIs32bit
    ]

;
; create our handler (LDR PC,CoreVector - in RAM)
;
        LDR     r0, LDRPCInstr
        STR     r0, UIHandler
    [ Arm600
        MOV     r0, #1
        ADR     r1, UIHandler
        ADR     r2, UIHandler
        SWI     XOS_SynchroniseCodeAreas
    ]

;
; and install it (it will just pass on until the core
; wants it).
;
    [ Arm600
        MRS     r3, CPSR                ; interrupts off until
        ORR     r0, r3, #I32_bit        ; our handler is valid
        MSR     CPSR_c, r0

        MOV     r0, #1
        ORR     r0, r0, #&100
        ADR     r1, UIHandler
        SWI     XOS_ClaimProcessorVector
        STR     r1, CoreVector
        STR     r1, OldVector
     [ {CONFIG}=26
        ADRL    r1, UI_veneer
        STR     r1, VeneerVector
        ADRL    r1, PassAlong_veneer
        STR     r1, VeneerOutVector
        ADR     r1, VeneerOutVector
     |
        ADR     r1, OldVector
     ]

        MSR     CPSR_c, r3              ; interrupts back on
    |
;
; load the current undefined instruction vector, and ascertain
; what flavour it is (i.e. B    <addr> or LDR pc, <addr>)
;
        MOV     r0, #Undef_vector
        LDR     r0, [r0]

        STR     r0, OldUIInstr

        MOV     r1, r0, LSR #24
        CMP     r1, #&ea                ; 0xea?????? -> B <addr>
        BEQ     %F10

;
; vector is not B <addr>, assume it must be LDR pc, <addr> - get
; offset from bottom 12 bits of instruction
;
        MOV     r1, r0, LSL #20
        MOV     r1, r1, LSR #20

;
; now adjust for a PC relative load from vector address
;
        ADD     r1, r1, #12
      [ debug > 1
        DREG    r1, "Current vector is LDR pc, "
      ]
;
; Pre-RO 3.5, a PC relative load generally indicates that it's loading the
; current undefined instruction environment handler. We must remember the
; address which is being loaded from, so that if the environment handler
; changes in future we'll pass along to the right place
;

        STR     r1, LDRPassalongDest

;
; However PC relative loads cause problems when we want to temporarily
; disable our vector. We could write the original instruction back to
; Undef_vector, but that would clobber any handler which anyone else has
; installed. So instead we'll construct a small section of passalong
; code in our workspace and use that whenever our vector is disabled.
;
        Push    "r0-r5"
        ADR     r5, LDRPassalongCode
        ASSERT  ?LDRPassalong = 20
        LDMIA   r5, {r0-r4}
        ADR     r5, LDRPassalong
        STMIA   r5, {r0-r4}
        STR     r5, CoreVector
        STR     r5, OldVector
        Pull    "r0-r5"

        ; Use current r1 value for core_initws


      [ debug > 9
        ;
        ; set r0 for debugs down below
        ;
        MOV     r0, #0
      ]
        B       %F15

;
; undefined instruction vector is of the form B <addr> - get offset
; from bottom 24 bits of instruction
;
10

;
; convert from word to byte offset, then adjust for vector address
; and instruction pipelining
;
        MOV     r0, r0, ASL #8
        MOV     r0, r0, ASR #6
        ADD     r1, r0, #Undef_vector + 8
        BIC     r1, r1, #&FC000003

     [  debug > 1
        DREG    r1, "Current vector is B "
     ]
        STR     r1, CoreVector
        STR     r1, OldVector
        
        ADR     r1, OldVector

15
;
; fill in our vector (as a branch)
;
        ADR     r0, UIHandler
        SUB     r0, r0, #Undef_vector + 8
        MOV     r0, r0, LSL #6
        MOV     r0, r0, LSR #8
        ORR     r0, r0, #&EA000000
        MOV     r14, #Undef_vector
        STR     r0, [r14]
    ] ; Arm600

;
; at this point r1 contains the address to be loaded into NextHandler,
; which is exactly what core_initws is expecting - load other registers
; and make the call
;
    [   debug > 5
        DREG    r1, "Calling core_initws with r1 = ", cc
        DREG    r10, ", r10 = "
    ]

        BL      core_initws

    [ Flavour = "HardOnly"
     [  debug > 1
        DREG    r0, "SysId from core_initws = 0x"
     ]

;
; if the module only supports FPA based systems, then the absence
; of an FPA is a handicap that is best not to try to overcome
;
        CMP     r0, #SysID_FPA
        BEQ     %F20

;
; load message token. NOTE:  this is a new message, that does not
; appear in the default resources file in the RISC OS 3 ROMs, so
; it needs a default message to supply to MsgTrans.
;
        ADR     r0, NoHWMesg
        MOV     r1, #0                          ; no %0 substitution
        BL      copy_error_one

;
; return *without* restoring PSR (need to return V set)
;
        LDMFD   sp!, {r10, pc}

NoHWMesg
        DCD     ErrorBase_FloatingPoint + 6
        DCB     "NoHW:Initialisation failed: FPA not present", 0
        ALIGN
    ]

20
;
; if using multiple-context version of core, initialise our default
; context
;
    [   MultipleContexts
        ADR     r10, DefaultContext
        BL      core_initcontext
    ]
;
; Either way, start up the context
;
        BL      core_activatecontext
;
; Store the initial context into the exception save dump.
;
    [   MultipleContexts
        AdrWS   r10
    ]
        ADR     r0, FPExceptionDump
        MOV     r1, pc
    [   MultipleContexts
        LDR     r10, CurrentContext
    ]
        BL      core_savecontext

;
; that's all folks
;
        CMP     r0, #0                  ; clear V
        LDMFD   sp!, {r10, pc}

LDRPCInstr
        LDR     pc, {PC}+4

 [ :LNOT: Arm600
LDRPassalongCode
        STR     r14, [r13,#-8]!
        LDR     r14, LDRPassalongCode+(LDRPassalongDest-LDRPassalong)
        LDR     r14, [r14]
        STR     r14, [r13,#4]
        LDMFD   r13!,{r14-r15}
        ASSERT  .-LDRPassalongCode = ?LDRPassalong
 ]

;
; **********************************************************************
;
; FPEFinal - Finalisation code
;
; all we need to do is call core_shutdown
;
FPEFinal        ROUT
        STMFD   sp!,{r0-r7,r10,lr}
        AdrWS   r10
        BL      core_shutdown
  [ Arm600
        MOV     r0, #1
        LDR     r1, OldVector
        ADR     r2, UIHandler
        SWI     XOS_ClaimProcessorVector
        BLVC    close_message_file
  |
        MOV     r0, #Undef_vector
        LDR     r1, OldUIInstr
        STR     r1, [r0]
        BL      close_message_file
  ]
        STRVS   r0, [sp]
        LDMFD   sp!,{r0-r7,r10,pc}

;
; **********************************************************************
;
; FPEServ - Service Call Handler
;
; this routine needs to check for Service_PreReset, and Service_Reset.
; on a Service_PreReset it should mimic the finalisation code (i.e.
; branch to core_shutdown); on a ServiceReset it should re-initialise the
; system if a soft-reset has just occured.
;

;mjs Updated to support Ursula format, with service table
;

        ASSERT Service_Reset < Service_PreReset
FPEServTab
        DCD     0                            ;flags word
        DCD     FPEServUrs - Module_BaseAddr ;offset to handler (skipping pre-rejection code)
        DCD     Service_Reset                ;service 1
        DCD     Service_PreReset             ;service 2
        DCD     0                            ;terminator
        DCD     FPEServTab - Module_BaseAddr ;anchor for table (precedes magic instruction)
FPEServ         ROUT
        MOV     r0, r0                       ;magic instruction to identify Ursula format
        TEQ     r1, #Service_PreReset
        TEQNE   r1, #Service_Reset
        MOVNE   pc, lr
FPEServUrs
        TEQ     r1, #Service_PreReset
    [   {CONFIG}=32
        BEQ     FPEFinal
    |
        BEQ     core_shutdown
    ]

;
; Service_Reset: read last reset type, ignore if not soft-reset
;
        STMFD   sp!, {r0-r3, lr}
        MOV     r0, #253
        MOV     r1, #0
        MOV     r2, #255

        SWI     XOS_Byte

        CMP     r1, #0
        LDMNEFD sp!, {r0-r3, pc}

;
; there has just been a soft-reset, get workspace pointer in r12
; and call initialisation routine
;
        BL      FPEInit

;
; finished
;
        LDMFD   sp!, {r0-r3, pc}

;
; **********************************************************************
;

        END

;
; EOF riscos.start
;
@


4.10
log
@Update to work with zero page relocation
Detail:
  Unlike most modules which can just store the zero page pointers in their workspace, FPEmulator is a bit trickier since the zero page pointers are needed from within abort handlers and other places where the module workspace pointer is hard to come by (in fact, FPEmulator uses FPEAnchor to store the module workspace pointer)
  So rather than break/rework lots of perfectly good code, there are now three different FPEmulator builds available, selected via the new FPEAnchorType option:
  * FPEAnchorType=Low will select a build suitable for machines with FPEAnchor at its original location in zero page. This is the default for ROM builds.
  * FPEAnchorType=High will select a build suitable for the FPEAnchor location (&ffff0ff4) that's used with zero page relocation. Machines with relocated zero page must specify this option in their components file.
  * FPEAnchorType=Local will select a build suitable for softloading. Rather than rely on using a zero page location for storing the workspace pointer, the module just stores it within itself. This option is selected automatically for RAM builds and can't be overriden via the components file.
  File changes:
  riscos/Makefile - Reworked makefile to support the new options
  riscos/FPEMacros - Updated AdrWS macro to work with FPEAnchorType=Local
  riscos/options - For non-local builds, declare the appropriate value for FPEAnchor
  riscos/start - Use appropriate FPEAnchor initialisation code
Admin:
  All 3 configs tested (ROM builds on BB-xM, RAM softload on Iyonix)


Version 4.29. Tagged as 'FPASC-4_29'
@
text
@d441 28
a468 1
        LDR     r1, [r1]
a495 1
15
d498 4
d510 2
a511 4
        MOV     r1, #Undef_vector
        STR     r0, [r1]

        ADR     r1, OldVector
d593 10
@


4.9
log
@Adjusted to ensure correctness of 32-bit flag with various build options.
@
text
@d85 5
d340 6
a346 1
        STR     r10, [r0, #FPEAnchor]
d354 1
a354 1
        MOV     r2, #16
@


4.8
log
@FPEmulator_LoadContext didn't work due to a slight register muddle.

Version 4.17. Tagged as 'FPASC-4_17'
@
text
@d48 1
a48 1
 [ Arm600
a49 3

FPEFlags
        DCD     1                               ; 32-bit compatible
d79 5
@


4.7
log
@* Fixes to allow correct builds for 26-bit systems (RISC OS 3.1) and 32-bit
  systems using the 32-bit core (RISC OS 3.5-3.7).

Version 4.14. Tagged as 'FPASC-4_14'
@
text
@d275 1
a275 1
        STMFD   sp!, {lr}
d286 1
d289 1
a289 1
        LDMFD   sp!, {pc}
@


4.6
log
@  Multiple context version of FP emulator and FPA support code - FP in
  callbacks and interrupts can now be yours.

  Exception dumps now available (integer and FP).

Detail:
* Changed to multiple-context version of the core. This will allow floating-
  point to be used safely in callbacks and interrupt routines (as long as
  you call the appropriate context changing SWIs). This activates the
  dormant SWIs FPEmulator_ChangeContext, FPEmulator_ContextLength and
  FPEmulator_InitContext. FPEmulator_DeactivateContext and
  FPEmulator_ActivateContext now have full functionality.

* Added new SWI interfaces to core: FPEmulator_Abort, FPEmulator_LoadContext
  and FPEmulator_SaveContext.

* On FP exceptions, integer registers are copied into the exception dump area.
  (TO DO: registers are USR mode ones - should take pains to figure out
  SVC or IRQ ones as required).

* The FPEmulator now has an exception dump area for floating point registers -
  a suitable version of Debugger will show these with *ShowFPRegs.

* FPEmulator_ChangeContext and FPEmulator_DeactivateContext now return -1
  for the default context.

* Run time detection of SVC stack position added.

* No longer creates a MessageTrans descriptor on the stack.

* Removed broken STM^ fudge from the FPA veneer, as the only StrongARMs that
  need it can't use the FPA.

* Fixed a typo in core_abort.

* Stopped continuous emulation runs crossing 4K page boundaries, with a view
  to improving abort handling.

* Use of DREG debugging macros fixed (line endings were being inserted in the
  wrong place).

* Prototype code to catch aborts inside the emulator and change the registers
  to make it look like the emulated instruction aborted. This is cute, but
  causes problems with anything like Ursula's lazy task-swapping. Really this
  needs to be done only on fatal aborts. Compiled out for now.

Version 4.12. Tagged as 'FPASC-4_12'
@
text
@d231 1
a231 1
        LDR     r10, [r12]
d245 3
d338 1
d344 3
d367 1
d372 1
d380 1
a380 1
        ORR     r0, r3, #I32_bit        ; our handler is invalid
a384 3
     [ {CONFIG}=26
        ADR     r1, UI_veneer           ; 26-bit munge veneer
     |
a385 1
     ]
d389 10
d469 2
a472 1
        ADR     r1, OldVector
d572 1
a572 1
        STR     r1, [r2]
d575 1
@


4.5
log
@  Merge of FPEmulator which uses the new macros in HdrSrc 0.63
Detail:
  Now 32-bit module compatible.
Admin:
  Tested the 26-bit build in the Customer F5 build.
  32-bit build tested on prototype 32-bit RISC OS.


Version 4.11. Tagged as 'FPASC-4_11'
@
text
@a37 1
        [ {CONFIG}=32
a38 3
        |
        DCD     core_shutdown - Module_BaseAddr ; Finalisation code
        ]
d46 8
a67 1
        [ MultipleContexts
d71 4
a74 1
        ]
a106 1
        [ {CONFIG} = 32
a107 3
        |
        B       core_deactivatecontext
        ]
d113 4
d118 4
d135 1
a135 1
        MOV     r11, #0
d138 5
a142 2
        MOVEQS  pc, lr                  ; 26-bit return
        MOV     pc, lr                  ; 32-bit return
a143 1
        [ {CONFIG} = 32
d145 7
d153 4
a157 4
        ORR     lr, r11, #&10
        MSR     CPSR_c, lr              ; Switch up to SVC32 mode
        BL      core_deactivatecontext
        MSR     CPSR_cf, r11            ; clear V
d159 3
a161 5
        MOVEQS  pc, r12                 ; 26-bit return
        MOV     pc, r12                 ; 32-bit return
        ]

        ASSERT  Rwp = r10
d164 2
a165 1
        CMP     r0, #-1
d167 1
a167 4
        LDREQ   Rwp, [r12]
        ADREQ   r0, DefaultContext
      |
        LDREQ   r0, [r12]
d169 1
a169 1

d171 2
a172 1
        MOV     r11, #0
a173 9
        [ {CONFIG} = 32
        ORR     lr, r11, #&10
        MSR     CPSR_c, lr              ; Switch to SVC32 mode
        ]
        MOV     r10, r0
        BL      core_activatecontext
        [ {CONFIG} =32
        MSR     CPSR_cf, r11            ; clear V
        ]
d175 3
a177 2
        MOVEQS  pc, r12                 ; 26-bit return
        MOV     pc, r12                 ; 32-bit return
d182 3
a184 6
      [ MultipleContexts
        LDREQ   Rwp, [r12]
        ADREQ   r0, DefaultContext
      |
        LDREQ   r0, [r12]
      ]
d187 6
a192 1
        MOV     r11, #0
a193 10
        [ {CONFIG} = 32
        ORR     lr, r11, #&10
        MSR     CPSR_c, lr              ; Switch to SVC32 mode
        ]
        MOV     r10, r0
        BL      core_deactivatecontext
        BL      core_activatecontext
        [ {CONFIG} =32
        MSR     CPSR_cf, r11            ; clear V
        ]
d195 3
a197 2
        MOVEQS  pc, r12                 ; 26-bit return
        MOV     pc, r12                 ; 32-bit return
d201 1
a201 1
        MOV     r11, #0
d204 3
a206 2
        MOVEQS  pc, lr                  ; 26-bit return
        MOV     pc, lr                  ; 32-bit return
a217 6
        MOV     r11, #0
        MRS     r11, CPSR
        [ {CONFIG} = 32
        ORR     lr, r11, #&10
        MSR     CPSR_c, lr              ; Switch to SVC32 mode
        ]
d220 2
a221 3
        [ {CONFIG} = 32
        MSR     CPSR_cf, r11            ; clear V
        ]
d223 3
a225 2
        MOVEQS  pc, r12                 ; 26-bit return
        MOV     pc, r12                 ; 32-bit return
d229 62
d323 1
a323 1
5       MOV     r10, r2         ; r2 must be preserved from here on, so r10 can be reset later
d332 14
a345 1
        STRB    r0, OnVector
d348 17
d366 7
a372 8
; on an Arm600 based system, control must not be passed straight along
; to the next handler, but must pass through some veneer code that is
; entered in svc26 mode and passes the call along in undef32 mode as
; if this module did not exist
;
; here we pass to the core the address of a location pointing
; to the passalong veneer (which won't actually be used until we
; get to veneer_newhandlers)
d374 11
a384 7
      [ {CONFIG}=32
        ADR     r1, UIVector
      |
        ADR     r1, UnwantedAddr
        ADRL    r0, PassAlong_veneer
        STR     r0, [r1]
      ]
d393 2
d413 1
d427 1
a427 1
10      AND     r0, r0, #&ff000000
d433 4
a436 2
        MOV     r0, r0, LSL #2
        ADD     r0, r0, #12
d438 6
d445 1
a445 1
; save this branch target in module workspace
d447 8
a454 6
        STR     r0, UIBranchDest

     [  debug > 1
        DREG    r0, "Current vector is B "
     ]
    ]
d456 1
a461 1
15
a466 9
    [   {CONFIG}=32
;
; Up into SVC32 mode to call all the core routines
;
        MRS     r3, CPSR
        ORR     r0, r3, #&10
        MSR     CPSR_c, r0
    ]

a480 4
     [ {CONFIG} = 32
        MSR     CPSR_c, r3      ; back to SVC26 mode to exit
     ]

a509 1

d511 5
a515 2
; Workspace is initialised, now activate the context.  Whether multiple
; contexts or not, address is already in r10.
d517 7
a523 5
        BL      core_changecontext

    [   {CONFIG} = 32
; back down to SVC26 mode
        MSR     CPSR_c, r3
d525 1
d530 1
a530 1
        CMP     r0, r0                  ; clear V
d533 3
a535 1
     [  {CONFIG}=32
a542 3
; mjs 18-Feb-98 fix for Ursula (now uses FPE in 32-bit flavour)
; must not corrupt r0,r3 in service call handler (used to just push lr)
;
d544 2
a545 4
        STMFD   sp!,{r0,r3,lr}
        MRS     r3, CPSR
        ORR     r0, r3, #&10
        MSR     CPSR_c, r0              ; Into SVC32 mode
d547 13
a559 3
        MSR     CPSR_cf, r3             ; clears V too
        LDMFD   sp!,{r0,r3,pc}
     ]
@


4.4
log
@Ursula branch merged. This contains:
  Use of UMULL (compiled out).
  Service call table.
  Runs in UND32 mode (requires latest Kernel), giving a speed boost.

Version 4.10. Tagged as 'FPASC-4_10'
@
text
@d125 5
a129 1
        MOVS    pc, lr
d136 1
a136 1
        MSR     CPSR_all, lr            ; Switch up to SVC32 mode
d138 4
a141 2
        MSR     CPSR_all, r11
        MOVS    pc, r12
d156 2
a158 1
        MRS     r11, CPSR
d160 1
a160 1
        MSR     CPSR_all, lr            ; Switch to SVC32 mode
d165 1
a165 1
        MSR     CPSR_all, r11
d167 3
a169 1
        MOVS    pc, r12
d182 2
a184 1
        MRS     r11, CPSR
d186 1
a186 1
        MSR     CPSR_all, lr            ; Switch to SVC32 mode
d192 1
a192 1
        MSR     CPSR_all, r11
d194 3
a196 1
        MOVS    pc, r12
d200 5
a204 1
        MOVS    pc, lr
d216 2
a218 1
        MRS     r11, CPSR
d220 1
a220 1
        MSR     CPSR_all, lr            ; Switch to SVC32 mode
d224 2
a225 2
        [ {CONFIG} =32
        MSR     CPSR_all, r11
d227 3
a229 1
        MOVS    pc, r12
d369 1
a369 1
        MSR     CPSR_all, r0
d387 1
a387 1
        MSR     CPSR_ctl, r3    ; back to SVC26 mode to exit
d428 1
a428 1
        MSR     CPSR_ctl, r3
d434 2
a435 1
        LDMFD   sp!, {r10, pc}^
d452 1
a452 1
        MSR     CPSR_all, r0            ; Into SVC32 mode
d454 2
a455 2
        MSR     CPSR_all, r3
        LDMFD   sp!,{r0,r3,pc}^
d483 2
a484 2
        TEQNES  r1, #Service_Reset
        MOVNES  pc, lr
d504 1
a504 1
        LDMNEFD sp!, {r0-r3, pc}^
d515 1
a515 1
        LDMFD   sp!, {r0-r3, pc}^
@


4.4.2.1
log
@ObjASM 3.12 syntax warning fixes.
32-bit compatible, hopefully.
Requires HdrSrc.

Version 4.10, 4.3.2.1. Tagged as 'FPASC-4_10-4_3_2_1'
@
text
@d125 1
a125 5
        MOV     r11, #0
        MRS     r11, CPSR
        TST     r11, #2_11100
        MOVEQS  pc, lr                  ; 26-bit return
        MOV     pc, lr                  ; 32-bit return
d132 1
a132 1
        MSR     CPSR_c, lr              ; Switch up to SVC32 mode
d134 2
a135 4
        MSR     CPSR_cf, r11            ; clear V
        TST     r11, #2_11100
        MOVEQS  pc, r12                 ; 26-bit return
        MOV     pc, r12                 ; 32-bit return
d150 1
a150 1
        MOV     r11, #0
a151 1
        [ {CONFIG} = 32
d153 1
a153 1
        MSR     CPSR_c, lr              ; Switch to SVC32 mode
d158 1
a158 1
        MSR     CPSR_cf, r11            ; clear V
d160 1
a160 3
        TST     r11, #2_11100
        MOVEQS  pc, r12                 ; 26-bit return
        MOV     pc, r12                 ; 32-bit return
d173 1
a173 1
        MOV     r11, #0
a174 1
        [ {CONFIG} = 32
d176 1
a176 1
        MSR     CPSR_c, lr              ; Switch to SVC32 mode
d182 1
a182 1
        MSR     CPSR_cf, r11            ; clear V
d184 1
a184 3
        TST     r11, #2_11100
        MOVEQS  pc, r12                 ; 26-bit return
        MOV     pc, r12                 ; 32-bit return
d188 1
a188 5
        MOV     r11, #0
        MRS     r11, CPSR
        TST     r11, #2_11100
        MOVEQS  pc, lr                  ; 26-bit return
        MOV     pc, lr                  ; 32-bit return
d200 1
a200 1
        MOV     r11, #0
a201 1
        [ {CONFIG} = 32
d203 1
a203 1
        MSR     CPSR_c, lr              ; Switch to SVC32 mode
d207 2
a208 2
        [ {CONFIG} = 32
        MSR     CPSR_cf, r11            ; clear V
d210 1
a210 3
        TST     r11, #2_11100
        MOVEQS  pc, r12                 ; 26-bit return
        MOV     pc, r12                 ; 32-bit return
d350 1
a350 1
        MSR     CPSR_c, r0
d368 1
a368 1
        MSR     CPSR_c, r3      ; back to SVC26 mode to exit
d409 1
a409 1
        MSR     CPSR_c, r3
d415 1
a415 2
        CMP     r0, r0                  ; clear V
        LDMFD   sp!, {r10, pc}
d432 1
a432 1
        MSR     CPSR_c, r0              ; Into SVC32 mode
d434 2
a435 2
        MSR     CPSR_cf, r3             ; clears V too
        LDMFD   sp!,{r0,r3,pc}
d463 2
a464 2
        TEQNE   r1, #Service_Reset
        MOVNE   pc, lr
d484 1
a484 1
        LDMNEFD sp!, {r0-r3, pc}
d495 1
a495 1
        LDMFD   sp!, {r0-r3, pc}
@


4.3
log
@Makefile modified to use LocalRes$Path.
Changed to use srccommit.
German resources added.

Version 4.09. Tagged as 'FPASC-4_09'
@
text
@d34 1
a34 1
        ASSERT  (. - Module_BaseAddr) = 0       
d38 1
d40 3
d64 5
d72 1
a72 1
BadSWItoken
d90 4
a93 1
; FPESWI
d96 1
a96 1
        CMP     r11,#(FPESWIJumpTableEnd - FPESWIJumpTable) /4
d98 2
a99 2
        B       BadSWI
FPESWIJumpTable
d101 1
d103 3
d107 10
a116 5
FPESWIJumpTableEnd

BadSWI
        STMFD   sp!, {r1,r2,r4,lr}
        ADR     r0, BadSWItoken
d121 1
a121 1
        LDMFD   sp!, {r1,r2,r4,pc}
d127 1
d129 4
a132 1
        STMFD   sp!, {lr}
d134 5
a138 1
        LDMFD   sp!, {pc}^
d141 14
a154 1
        STMFD   sp!, {r10, lr}
d157 57
a213 1
        LDMFD   sp!, {r10, pc}^
d221 1
a221 1
        STR     lr, [sp, #-4]!
d227 1
a227 1
        CMP     r2, #0
d240 1
a240 2
        LDRVS   lr, [sp], #4
        ORRVSS  pc, lr, #V_bit
a244 1
        BL      MemClear
d246 1
a246 1
5       MOV     r12, r2
d252 4
a255 2
        LDR     r0, =FPEAnchor
        STR     r12, [r0]
d268 4
a271 2
        AdrWS   r0
        ADD     r1, r0, #:INDEX:UnwantedAddr
d274 1
d326 1
a326 2
        ADD     r1, r12, #:INDEX:UIBranchDest
        STR     r0, [r1]
d338 1
a338 2
15      MOV     r10, r12

d344 9
d367 4
d383 1
a383 1
        LDMFD   sp!, {pc}
d391 1
d393 2
a394 2
; workspace is initialised, now activate the context.  the context is at
; the base of the claimed workspace, address is already in r10.
d396 15
a410 1
20      BL      core_activatecontext
d415 1
a415 1
        LDMFD   sp!, {pc}^
d417 1
d423 4
a426 2
; all we need to do is call core_shutdown,
; do not bother coming back here
d429 8
a436 1
        B       core_shutdown
a447 1
FPEServ         ROUT
d449 2
a450 2
        CMP     r1, #Service_PreReset
        BEQ     core_shutdown
d452 12
a463 1
        CMP     r1, #Service_Reset
d465 7
d481 1
a481 1
	SWI	XOS_Byte
a489 1
        AdrWS   r12
a495 55

;
; **********************************************************************
;
; MemClear - clear (word aligned) memory claimed via OS_Module 6
;
; On entry: r2 = pointer to claimed block, r3 = byte count
;
MemClear        ROUT
        STMFD   sp!, {r0-r9, lr}

        MOV     r3, r3, LSR #2                          ; bytes -> words

;
; most fills are done 8 words at a time: clear up residual first
;
        ANDS    r1, r3, #7
        MOV     r0, #0
        BEQ     %F1

;
; fill residual 1 byte at a time
;
0       STR     r0, [r2], #4
        SUBS    r1, r1, #1
        BNE     %B0

;
; filling 8-words at a time, adjust count
;
1       MOVS    r3, r3, LSR #3
        LDMEQFD sp!, {r0-r9, pc}^

;
; initialise all registers
;
        MOV     r1, r0
        MOV     r4, r0
        MOV     r5, r0
        MOV     r6, r0
        MOV     r7, r0
        MOV     r8, r0
        MOV     r9, r0

;
; now fill rest of the block
;
2       STMIA   r2!, {r0-r1, r4-r9}
        SUBS    r3, r3, #1
        BNE     %B2

;
; finished
;
        LDMIA   sp!, {r0-r9, pc}^
@


4.2
log
@Version RO_3_71 merged
@
text
@d76 1
a76 1
        ASSERT  Verno >= 400
d103 1
a103 1
        LDR     r0, =Verno
@


4.2.2.1
log
@incorporate KBracey changes:
  Use long multiply (assumes long multiply; won't work on ARM 610,710)
  Compile with 32-bit APCS for better efficiency (requires Ursula kernel)
  Also compile for soft FP only (suit SA110)
update module format to Ursula service handler table
@
text
@d34 1
a34 1
        ASSERT  (. - Module_BaseAddr) = 0
a37 1
        [ {CONFIG}=32
a38 3
        |
        DCD     core_shutdown - Module_BaseAddr ; Finalisation code
        ]
a59 5
        [ MultipleContexts
        DCB     "ChangeContext", 0
        DCB     "ContextLength", 0
        DCB     "InitContext", 0
        ]
d63 1
a63 1
BadSWIToken
d81 1
a81 4
; FPESWI - R10 to R12 may be corrupted
;
; The core routines called here will expect to be called in SVC32 mode
; if we're using the 32-bit core (ie if {CONFIG} = 32)
d84 1
a84 1
        CMP     r11, #(EndOfSWIJumpTable - SWIJumpTable) / 4
d86 2
a87 2
        B       UnknownSWIError
SWIJumpTable
a88 1
        [ {CONFIG} = 32
a89 3
        |
        B       core_deactivatecontext
        ]
d91 5
a95 10
        [ MultipleContexts
        B       FPESWI_ChangeContext
        B       FPESWI_ContextLength
        B       FPESWI_InitContext
        ]
EndOfSWIJumpTable

UnknownSWIError
        STMFD   sp!,{r0-r2,r4,lr}
        ADR     r0, BadSWIToken
d100 1
a100 1
        LDMFD   sp!,{r0-r2,r4,pc}
a105 1
        [ {CONFIG} = 32
d107 1
a107 4
        MOV     r12, lr
        MRS     r11, CPSR
        ORR     lr, r11, #&10
        MSR     CPSR_all, lr            ; Switch up to SVC32 mode
d109 1
a109 5
        MSR     CPSR_all, r11
        MOVS    pc, r12
        ]

        ASSERT  Rwp = r10
d112 1
a112 14
        CMP     r0, #-1
      [ MultipleContexts
        LDREQ   Rwp, [r12]
        ADREQ   r0, DefaultContext
      |
        LDREQ   r0, [r12]
      ]

        MOV     r12, lr
        [ {CONFIG} = 32
        MRS     r11, CPSR
        ORR     lr, r11, #&10
        MSR     CPSR_all, lr            ; Switch to SVC32 mode
        ]
d115 1
a115 57
        [ {CONFIG} =32
        MSR     CPSR_all, r11
        ]
        MOVS    pc, r12

    [ MultipleContexts
FPESWI_ChangeContext
        CMP     r0, #-1
      [ MultipleContexts
        LDREQ   Rwp, [r12]
        ADREQ   r0, DefaultContext
      |
        LDREQ   r0, [r12]
      ]

        MOV     r12, lr
        [ {CONFIG} = 32
        MRS     r11, CPSR
        ORR     lr, r11, #&10
        MSR     CPSR_all, lr            ; Switch to SVC32 mode
        ]
        MOV     r10, r0
        BL      core_deactivatecontext
        BL      core_activatecontext
        [ {CONFIG} =32
        MSR     CPSR_all, r11
        ]
        MOVS    pc, r12

FPESWI_ContextLength
        MOV     r0, #ContextLength
        MOVS    pc, lr

FPESWI_InitContext
        CMP     r0, #-1
      [ MultipleContexts
        LDREQ   Rwp, [r12]
        ADREQ   r0, DefaultContext
      |
        LDREQ   r0, [r12]
      ]

        MOV     r12, lr
        [ {CONFIG} = 32
        MRS     r11, CPSR
        ORR     lr, r11, #&10
        MSR     CPSR_all, lr            ; Switch to SVC32 mode
        ]
        MOV     r10, r0
        BL      core_initcontext
        [ {CONFIG} =32
        MSR     CPSR_all, r11
        ]
        MOVS    pc, r12

    ]

d123 1
a123 1
        STMFD   sp!, {r10, lr}
d129 1
a129 1
        TEQ     r2, #0
d142 2
a143 1
        LDMVSFD sp!, {r10, pc}
d148 1
d150 1
a150 1
5       MOV     r10, r2         ; r2 must be preserved from here on, so r10 can be reset later
d156 2
a157 4
        MOV     r0, #0
        STR     r10, [r0, #FPEAnchor]

        STRB    r0, OnVector
d170 2
a171 4
      [ {CONFIG}=32
        ADR     r1, UIVector
      |
        ADR     r1, UnwantedAddr
a173 1
      ]
d225 2
a226 1
        STR     r0, UIBranchDest
d238 2
a239 1
15
a244 9
    [   {CONFIG}=32
;
; Up into SVC32 mode to call all the core routines
;
        MRS     r3, CPSR
        ORR     r0, r3, #&10
        MSR     CPSR_all, r0
    ]

a258 4
     [ {CONFIG} = 32
        MSR     CPSR_ctl, r3    ; back to SVC26 mode to exit
     ]

d271 1
a271 1
        LDMFD   sp!, {r10, pc}
a278 1
20
d280 2
a281 2
; if using multiple-context version of core, initialise our default
; context
d283 1
a283 15
    [   MultipleContexts
        ADR     r10, DefaultContext
        BL      core_initcontext
    ]

;
; Workspace is initialised, now activate the context.  Whether multiple
; contexts or not, address is already in r10.
;
        BL      core_changecontext

    [   {CONFIG} = 32
; back down to SVC26 mode
        MSR     CPSR_ctl, r3
    ]
d288 1
a288 1
        LDMFD   sp!, {r10, pc}^
a289 1
     [  {CONFIG}=32
d295 2
a296 4
; all we need to do is call core_shutdown
;
; mjs 18-Feb-98 fix for Ursula (now uses FPE in 32-bit flavour)
; must not corrupt r0,r3 in service call handler (used to just push lr)
d299 1
a299 8
        STMFD   sp!,{r0,r3,lr}
        MRS     r3, CPSR
        ORR     r0, r3, #&10
        MSR     CPSR_all, r0            ; Into SVC32 mode
        BL      core_shutdown
        MSR     CPSR_all, r3
        LDMFD   sp!,{r0,r3,pc}^
     ]
d311 1
d313 2
a314 2
;mjs Updated to support Ursula format, with service table
;
d316 1
a316 12
        ASSERT Service_Reset < Service_PreReset
FPEServTab
        DCD     0                            ;flags word
        DCD     FPEServUrs - Module_BaseAddr ;offset to handler (skipping pre-rejection code)
        DCD     Service_Reset                ;service 1
        DCD     Service_PreReset             ;service 2
        DCD     0                            ;terminator
        DCD     FPEServTab - Module_BaseAddr ;anchor for table (precedes magic instruction)
FPEServ         ROUT
        MOV     r0, r0                       ;magic instruction to identify Ursula format
        TEQ     r1, #Service_PreReset
        TEQNES  r1, #Service_Reset
a317 7
FPEServUrs
        TEQ     r1, #Service_PreReset
    [   {CONFIG}=32
        BEQ     FPEFinal
    |
        BEQ     core_shutdown
    ]
d327 1
a327 1
        SWI     XOS_Byte
d336 1
d343 55
@


4.1
log
@Initial revision
@
text
@d56 10
a65 3
        DCB     "FPEmulator", NULL
        DCB     "Version", NULL
        DCB     NULL
d81 1
a81 2
; FPESWI - the current emulator does not decode the SWI at all, therefore
;          this replacement module should not do so either.
d84 19
d105 11
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.3.2
log
@Version RO_3_71 taken
@
text
@d56 3
a58 10
        DCB     "FPEmulator", 0
        DCB     "Version", 0
        DCB     "DeactivateContext", 0
        DCB     "ActivateContext", 0
        DCB     0
        ALIGN

BadSWItoken
        DCD     &1E6
        DCB     "BadSWI", 0
d74 2
a75 1
; FPESWI
a77 19
        CMP     r11,#(FPESWIJumpTableEnd - FPESWIJumpTable) /4
        ADDLO   pc, pc, r11, LSL #2
        B       BadSWI
FPESWIJumpTable
        B       FPESWI_Version
        B       FPESWI_DeactivateContext
        B       FPESWI_ActivateContext
FPESWIJumpTableEnd

BadSWI
        STMFD   sp!, {r1,r2,r4,lr}
        ADR     r0, BadSWItoken
        MOV     r1, #0
        MOV     r2, #0
        ADR     r4, FPETitle
        SWI     XMessageTrans_ErrorLookup
        LDMFD   sp!, {r1,r2,r4,pc}

FPESWI_Version
a79 11

FPESWI_DeactivateContext
        STMFD   sp!, {lr}
        BL      core_deactivatecontext
        LDMFD   sp!, {pc}^

FPESWI_ActivateContext
        STMFD   sp!, {r10, lr}
        MOV     r10, r0
        BL      core_activatecontext
        LDMFD   sp!, {r10, pc}^
@


4.1.3.1.2.1
log
@Merged from 3.71 CD
@
text
@d56 3
a58 10
        DCB     "FPEmulator", 0
        DCB     "Version", 0
        DCB     "DeactivateContext", 0
        DCB     "ActivateContext", 0
        DCB     0
        ALIGN

BadSWItoken
        DCD     &1E6
        DCB     "BadSWI", 0
d74 2
a75 1
; FPESWI
a77 19
        CMP     r11,#(FPESWIJumpTableEnd - FPESWIJumpTable) /4
        ADDLO   pc, pc, r11, LSL #2
        B       BadSWI
FPESWIJumpTable
        B       FPESWI_Version
        B       FPESWI_DeactivateContext
        B       FPESWI_ActivateContext
FPESWIJumpTableEnd

BadSWI
        STMFD   sp!, {r1,r2,r4,lr}
        ADR     r0, BadSWItoken
        MOV     r1, #0
        MOV     r2, #0
        ADR     r4, FPETitle
        SWI     XMessageTrans_ErrorLookup
        LDMFD   sp!, {r1,r2,r4,pc}

FPESWI_Version
a79 11

FPESWI_DeactivateContext
        STMFD   sp!, {lr}
        BL      core_deactivatecontext
        LDMFD   sp!, {pc}^

FPESWI_ActivateContext
        STMFD   sp!, {r10, lr}
        MOV     r10, r0
        BL      core_activatecontext
        LDMFD   sp!, {r10, pc}^
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.8;
access;
symbols
	FPASC-4_36:4.8
	FPASC-4_35:4.8
	FPASC-4_34:4.8
	FPASC-4_33-1:4.8
	FPASC-4_33:4.8
	FPASC-4_32:4.8
	FPASC-4_31:4.8
	FPASC-4_30:4.8
	FPASC-4_29:4.8
	FPASC-4_28-2:4.8
	FPASC-4_28:4.8
	FPASC-4_27:4.8
	FPASC-4_26:4.8
	FPASC-4_25:4.8
	FPASC-4_24:4.8
	FPASC-4_23:4.8
	RO_5_07:4.8
	FPASC-4_22:4.8
	FPASC-4_21:4.8
	FPASC-4_20:4.8
	FPASC-4_19:4.8
	FPASC-4_18:4.8
	FPASC-4_17:4.8
	FPASC-4_16:4.8
	FPASC-4_15:4.8
	FPASC-4_14:4.8
	dellis_autobuild_BaseSW:4.7
	FPASC-4_13:4.7
	FPASC-4_12:4.7
	FPASC-4_10-4_3_2_2:4.5.2.2
	sbrodie_sedwards_16Mar2000:4.6
	kbracey_32bit_merge:4.5.2.1
	FPASC-4_11:4.6
	FPASC-4_10-4_3_2_1:4.5.2.1
	kbracey_32bit:4.5.0.2
	dcotton_autobuild_BaseSW:4.8
	FPASC-4_10:4.5
	Ursula_merge:4.3.2.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3.2.1
	Ursula_RiscPC:4.3.2.1.0.2
	nicke_FPASC-4_05:4.1.7.1
	FPASC-4_09:4.4
	rthornb_UrsulaBuild-19Aug1998:4.3.2.1
	UrsulaBuild_FinalSoftload:4.3.2.1
	rthornb_UrsulaBuild-12Aug1998:4.3.2.1
	aglover_UrsulaBuild-05Aug1998:4.3.2.1
	rthornb_UrsulaBuild-29Jul1998:4.3.2.1
	rthornb_UrsulaBuild-22Jul1998:4.3.2.1
	rthornb_UrsulaBuild-15Jul1998:4.3.2.1
	rthornb_UrsulaBuild-07Jul1998:4.3.2.1
	rthornb_UrsulaBuild-17Jun1998:4.3.2.1
	rthornb_UrsulaBuild-03Jun1998:4.3.2.1
	rthornb_UrsulaBuild-27May1998:4.3.2.1
	rthornb_UrsulaBuild-21May1998:4.3.2.1
	rthornb_UrsulaBuild_01May1998:4.3.2.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.3.0.4
	Daytona_bp:4.3
	Ursula:4.3.0.2
	Ursula_bp:4.3
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.2
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2000.10.02.16.02.01;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	2000.03.24.10.53.17;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.11.26.14.37.35;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	99.08.03.17.57.01;	author kbracey;	state Exp;
branches
	4.5.2.1;
next	4.4;

4.4
date	98.09.21.12.36.56;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	97.05.02.09.52.09;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.01.21.16.24.46;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.35.55;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.5.2.1
date	99.11.23.17.19.17;	author kbracey;	state Exp;
branches;
next	;

4.3.2.1
date	98.03.27.10.35.18;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.35.55;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.25.07;	author nturton;	state Exp;
branches
	4.1.3.1.2.1;
next	4.1.3.2;

4.1.3.2
date	97.05.01.14.35.56;	author kbracey;	state Exp;
branches;
next	;

4.1.3.1.2.1
date	97.04.30.12.28.17;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.51.55;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.46.46;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.8
log
@* Fixes to allow correct builds for 26-bit systems (RISC OS 3.1) and 32-bit
  systems using the 32-bit core (RISC OS 3.5-3.7).

Version 4.14. Tagged as 'FPASC-4_14'
@
text
@; >riscos.end
;
; Copyright (c) 1993 Acorn Computers Ltd., Cambridge, England.
;
; Assembler source for FPA support code and emulator
; ==================================================
; RISCOS veneer code assembled after the core routines
;

;
; **********************************************************************
;
; declare help string from module header here as $CoreVersion has been
; declared and initialised by now.
;
FPEHelp
        DCB     "FPEmulator", TAB, "$Module_MajorVersion ($Module_Date) ($CoreVersion)",NULL
        ALIGN

;
; **********************************************************************
;
; veneer_newhandlers - install routine on undefined instruction vector
;
; On entry: r1 = new undefined instruction handler
; On exit:  All registers preserved
;
veneer_newhandlers      ROUT
        STR     lr, [sp, #-4]!
        AdrWS   lr

        STR     r1, [lr, #:INDEX: CoreVector]
  [ Arm600 :LAND: {CONFIG}=26
        ADR     r1, UI_veneer
        STR     r1, [lr, #:INDEX: VeneerVector] ; put our veneer in chain
        LDR     r1, [lr, #:INDEX: CoreVector]   ; restore R1
  ]

        LDR     pc, [sp], #4

;
; **********************************************************************
;
; veneer_restorehandlers - replace original undefined instruction vector
;
; On entry: (nothing)
; On exit:  All registers preserved
;
veneer_restorehandlers  ROUT
        STMFD   sp!, {r10, lr}
        AdrWS   r10

        LDR     lr, OldVector
  [ Arm600 :LAND: {CONFIG}=26
        STR     lr, VeneerVector                ; remove veneer
  |
        STR     lr, CoreVector
  ]

        LDMFD   sp!, {r10, pc}

;
; **********************************************************************
;
; veneer_coredisabled - cope with undefined instructions following a
;                       core_disabled call.  this should never happen
;                       under RISC OS, but be prepared in any case.
;
; On entry: r12 = pointer to stack frame containing user registers
; On exit:  all user registers reloaded and faulting instruction restarted
;
veneer_coredisabled     ROUT

;
; recover user registers from stack
;
   [ {CONFIG}=32
        LDR     r0, [r12, #-8]
        MSR     SPSR_cxsf, r0
   ]
        MOV     sp, r12
        LDMFD   sp, {r0-r14}^
        NOP                              ; NOP after banked reg. access

;
; move stack pointer past user registers and restart instruction
;
        ADD     sp, sp, #15 * 4
        LDMFD   sp!, {pc}^

;
; **********************************************************************
;
; exception trap handlers: all the different flavours of exception trap
; are grouped according to exception type and then raise OS_GenerateError
; with an internationalised error message according to the type.
;

;
; Invalid operation
;
veneer_invalidop        ROUT
veneer_invalidop1_single
veneer_invalidop2_single
veneer_invalidop1_double
veneer_invalidop2_double
veneer_invalidop1_extended
veneer_invalidop2_extended
veneer_invalidop1_integer
veneer_invalidop2_integer
veneer_invalidop1_packed
veneer_invalidop2_packed
veneer_invalidop1_xpacked
veneer_invalidop2_xpacked
veneer_invalidop1_ldfp
veneer_invalidop1_ldfpx
        ADR     r0, ivo_error
        B       handle_exception

veneer_zerodivide       ROUT
veneer_zerodivide1_single
veneer_zerodivide2_single
veneer_zerodivide1_double
veneer_zerodivide2_double
veneer_zerodivide1_extended
veneer_zerodivide2_extended
        ADR     r0, dvz_error
        B       handle_exception

veneer_overflow         ROUT
veneer_overflow_single
veneer_overflow_double
veneer_overflow_extended
        ADR     r0, ofl_error
        B       handle_exception

veneer_underflow        ROUT
veneer_underflow_single
veneer_underflow_double
veneer_underflow_extended
        ADR     r0, ufl_error
        B       handle_exception

veneer_inexact          ROUT
veneer_inexact_single
veneer_inexact_double
veneer_inexact_extended
veneer_inexact_integer
veneer_inexact_packed
veneer_inexact_xpacked
        ADR     r0, inx_error
        B       handle_exception

inx_error
        DCD     ErrorBase_FloatingPoint + 4
        DCB     "Inexact", NULL
        ALIGN

ufl_error
        DCD     ErrorBase_FloatingPoint + 3
        DCB     "UFlow", NULL
        ALIGN

dvz_error
        DCD     ErrorBase_FloatingPoint + 2
        DCB     "DivZero", NULL
        ALIGN

ofl_error
        DCD     ErrorBase_FloatingPoint + 1
        DCB     "OFlow", NULL
        ALIGN

ivo_error
        DCD     ErrorBase_FloatingPoint + 0
        DCB     "InvalOp", NULL
        ALIGN

;
; **********************************************************************
;
; handle_exception - common routine for dealing with floating point
;                    exceptions.  note that this routine raises
;                    OS_GenerateError, and does not return
;
; On entry: r0 points to error block with message tag
;           r12 points to stack frame containg user-mode register dump
; On exit:  (There is no exit)
;
handle_exception        ROUT

        MOV     r11, r0
        AdrWS   r10
  [ {CONFIG}=32
        MSR     CPSR_c, #I32_bit+SVC32_mode ; into SVC mode for SWI
  ]
        MOV     r0, #ExceptionDumpArea  ; lets be nice and put the
        MOV     r1, #0                  ; integer registers into the
        MOV     r2, #0                  ; exception dump
        MOV     r3, #0
        SWI     XOS_ChangeEnvironment
  [ {CONFIG}=32
        MSR     CPSR_c, #I32_bit+UND32_mode
  ]
        BVS     no_integer_exception_dump
        MOV     r0, r12
        LDMIA   r0!, {r2-r9}            ; copy R0-R7
        STMIA   r1!, {r2-r9}
        LDMIA   r0!, {r2-r9}            ; copy R8-R15
        STMIA   r1!, {r2-r9}

  [ {CONFIG}=32
        LDR     r0, [r12,#-8]           ; get PSR
        LDRB    r5, SysIs32bit          ; 32-bit exception dump?
        TEQ     r5, #0
        STRNE   r0, [r1]                ; put PSR in 17th word
        ANDEQ   r0, r0, #&FC000003      ; or merge it into 16th
        BICEQ   r9, r9, #&FC000003
        ORREQ   r0, r9, r0
        STREQ   r0, [r1, #-4]
  ]

no_integer_exception_dump
        ADR     r0, FPExceptionDump     ; Dump the FP registers
  [ MultipleContexts
        LDR     r10, CurrentContext
  ]
        LDR     r1, [r12,#60]
        BL      core_savecontext

        MOV     r0, r11
;
; wind back the stack using frame pointer, then recover user's
; registers
;
        ADD     sp, r12, #8                     ; lose r0, r1
        LDMFD   sp!, {r2-r12}
        ADD     sp, sp, #8                      ; lose r13, r14
        LDMFD   sp!, {r1}                       ; really r14_und

; flatten Supervisor stack

    [   {CONFIG}=32
; Change into SVC32. If on a 26-bit system we will fall back to SVC26
; on the next SWI. Sneaky huh?
        MSR     CPSR_c, #I32_bit+SVC32_mode
    ]
        AdrWS   r14
        LDR     sp, [r14, #:INDEX:SVCStack]

;
; (I think because we are raising the SWI in SVC mode) OS_GenerateError
; expects a certain pattern of registers at the top of the SVC stack, so
; generate this pattern
;
        STMFD   sp!, {r1, r10-r12}

;
; read the error message from the tags file, there
; is no %0 argument, so clear r1.
;
        MOV     r1, #0
        BL      copy_error_one

;
; error block is filled in, raise the error
;
        SWI     OS_GenerateError

;
; **********************************************************************
;
; veneer_corefaulty - called when core detects a hardware failure; will
;                     address an appropriate error block and branch to
;                     the same common routine used by exception trap
;                     handlers.  this routine will never come back.
;
; On entry: r12 points to stack frame containg user-mode register dump
; On exit:  (There is no exit)
;
veneer_corefaulty       ROUT
        ADR     r0, fpc_sick
        B       handle_exception

fpc_sick
        DCD     ErrorBase_FloatingPoint + 5
        DCB     "BadFPC", NULL
        ALIGN

;
; **********************************************************************
;
; copy_error_one - lookup message token in msgtrans file
;
; In:   r0 -> Error block containing the token
;       r1 -> %0 parameter to substitute
;
; Out:  r0 -> Translated error block or another error (token no found etc.)
;       All other registers preserved, V always set, other flags undefined

copy_error_one
        STMFD   sp!, {r2-r7,lr}
        MOV     r4, r1
        AdrWS   r1
        ADD     r1, r1, #:INDEX:MessageBlock
        MOV     r2, #0                          ; Use MessageTrans buffer
        MOV     r5, #0                          ; No %1
        MOV     r6, #0                          ; No %2
        MOV     r7, #0                          ; No %3
        SWI     XMessageTrans_ErrorLookup       ; Always sets the V flag

        MOV     r1, r4                          ; Preserve input r1
        LDMFD   sp!, {r2-r7,pc}

;
; **********************************************************************
;

message_filename
        DCB     "Resources:$.Resources.FPEmulator.Messages", 0
        ALIGN

;
; open_message_file -
;
; Open the Messages file.
; Trashes R0-R3.
; R10 must be workspace pointer.

open_message_file ROUT
        MOV     r3, lr                  ; Save LR

        ADR     r0, MessageBlock
        ADR     r1, message_filename    ; Filename
        MOV     r2, #0                  ; Direct access/buffer in RMA
        SWI     XMessageTrans_OpenFile  ; Open the file

        MOV     pc, r3                  ; Return

;
; **********************************************************************
;
; close_message_file -
;
; Close the message file block.
; Preserves R0 (error block). Trashes R6 and R7, V-bit
; R10 must be workspace pointer.

close_message_file ROUT
        MOV     r7, lr                  ; Save LR
        MOV     r6, r0                  ; Save translated error block

        ADR     r0, MessageBlock
        SWI     XMessageTrans_CloseFile ; Close the file (ignore error)

        MOV     r0, r6                  ; Restore translated error
        MOV     pc, r7                  ; Return

;
; **********************************************************************
;
;
; The following routines are only used on an Arm600 based system
;
    [   Arm600

     [  {CONFIG}=26
;
; **********************************************************************
;
; UI_veneer - entry point for Undefined Instruction handler, entered
;             in undef32 mode, call passed along to core handlers in
;             svc26 mode.
;
UI_veneer       ROUT

        STR     r10, [sp, #-4]!         ; STR faster than STM of one register on many ARMs
        AdrWS   r10

        STR     lr_undef, SavedLR
        MRS     lr_undef, SPSR
        STR     lr_undef, SavedPSR

        LDR     r10, [sp], #4            ; restore sp_undef before mode change

        MRS     lr_undef, CPSR
        BIC     lr_undef, lr_undef, #2_11100     ; switch from UND32 to SVC26
        MSR     CPSR_c, lr_undef

;
; build svc26 mode lr from saved components of undef32 state and pass
; the call along to the core handlers
;
        SUB     sp, sp, #4
        STMFD   sp!, {r1-r2, r10}

        AdrWS   r10
        LDR     lr, SavedLR
        LDR     r1, SavedPSR
        AND     r2, r1, #&f0000003      ; get saved NZCV and 26 bit mode bits
        ORR     lr, lr, r2              ; and merge with lr
        AND     r2, r1, #I32_bit + F32_bit      ; extract I & F from new place
        ORR     lr, lr, r2, LSL #IF32_26Shift   ; and merge with lr, in
                                                ; old place

        LDR     r1, CoreVector
        STR     r1, [sp, #3*4]
        LDMFD   sp!, {r1-r2, r10, pc}

;
; **********************************************************************
;
; PassAlong_veneer - Pass along undefined instruction to next handler in
;                    the chain.  The next handler should be entered as
;                    if the current one did not exist, i.e. revert from
;                    svc26 to undef32 mode, taking care to preserve all
;                    registers.
;
PassAlong_veneer        ROUT

;
; Disable IRQs - this guarantees the safety of the registers
; dumped on the r13_svc stack.
;
        TEQP    pc, #SVC26_mode :OR: I_bit
        NOP

        STMDB   sp, {r1-r4, r10, lr, pc}     ; XXX no writeback
        SUB     r3, sp, #7 * 4          ; r3 -> base of register dump

;
; load address of next handler
;
        AdrWS   r10
        LDR     r2, OldVector

;
; calculate value for lr_undef
;
        BIC     r1, lr, #&fc000003

;
; switch mode (keeping IRQs disabled)
;
        MRS     r4, CPSR
        ORR     r4, r4, #UND32_mode     ; Go from SVC26 to UND32 mode
        MSR     CPSR_c, r4

;
; place values for lr and pc onto stack
;
        ADD     r4, r3, #5 * 4
        STMIA   r4, {r1, r2}

;
; pop registers and pass call along to next handler
;
        LDMIA   r3, {r1-r4, r10, lr, pc}
     ]

 [ {FALSE}

; KJB - actually doing this is neat, but it's a can of worms. Need to integrate with
; the kernel. (Problem is we only want to do it on real aborts, not ones that cause
; page shuffling).

;
; **********************************************************************
;
; DA_handler - on a Data Abort, check to see if an abort was inside the
;              FPASC, and if so set up the registers from its stack frame
;              to make it look like the actual FP instruction aborted.

DA_handler ROUT
;
  [ UseAbortStack
; Assume we're running on a 32-bit system with an ABT stack. This makes
; life a lot neater, as we can run in ABT mode. When we pass it along, all
; registers will be preserved, and we never have to touch the FIQ status.
  |
; ABT mode doesn't have a stack on 26-bit systems (grrr). So we just do all the
; work in UND mode instead. When we pass it along, SPSR_und will be trashed,
; and CPSR will be forced to ABT32, IRQs off.
  ]
;
; If it was in the FPASC, R0-R14_usr, F0-F7,FPSR, R14_abt and SPSR_abt will be
; restored from the stack frame. Otherwise, all other registers preserved.
;
  [ UseAbortStack
        STMFD   sp!, {r0-r12,r14}
        MOV     r8, r14
        MRS     r11, CPSR
        MRS     r9, SPSR
  |
        MSR     CPSR_c, #I_bit + F_bit + Mode_UND32 ; FIQs off (just in case)
        STMFD   sp, {r0-r14}                    ; all IRQs off, so safe
        SUB     sp, sp, #15 * 4
        MSR     CPSR_c, #I_bit + F_bit + Mode_ABT32 ; back to get r14_abt
        MRS     r11, CPSR                       ; R11:= entry CPSR (bottom 8 bits frobbed)
        MOV     r8, r14                         ; R8:= abort address (R14_abt)
        MRS     r9, SPSR                        ; R9:= abort PSR (SPSR_abt)
        TST     r9, #F32_bit                    ; reenable FIQs?
        MSREQ   CPSR_c, #I_bit + Mode_UND32     ; back into UND mode
        MSRNE   CPSR_c, #I_bit + F_bit + Mode_UND32
  ]

        AdrWS   r10

        ADRL    r2,FP_UndefHandlers_Start
        ADRL    r3,FP_UndefHandlers_End-4
        CMP     r8,r2
        CMPHS   r3,r8
        BLO     PassOnDA                        ; Not in FPASC

; Note - we only call core_abort if the abort was inside the FPA.
;
; core_abort will cancel any pending FP operations and exceptions - this would
; be fatal if the process were to be returned to by someone further down the
; DA handler chain, for example any sort of virtual memory system.
;
; However, if the abort is in the FPA, we know it's handling an FP instruction
; somewhere. We assume that the abort must either be due to an emulated LD/ST
; instruction, or must be really fatal (in which case calling core_abort will be
; the least of our problems). In the former case, we should be able to safely call
; core_abort, as long as we fake the environment well enough - anyone attempting
; to return to the process will reexecute the instruction that was being emulated.
;
; Note that any virtual memory system *should* know how to deal with LDC and
; STC instructions - this will just make emulated LDC/STC instructions look exactly
; as they do an a system with a real FPA. The Fault Address Register in the MMU
; should still be correct too.

  [ MultipleContexts
        LDR     r10, CurrentContext             ; R10:=context pointer
  ]
        MOV     r0, r12                         ; R0:=frame pointer (if in FPASC)
        MOV     r1, r8                          ; R1:=abort PC
        BL      core_abort

; it was in the FPASC. reload user registers from the stack frame
        MOV     r12, r0
        MOV     r6, r12
        MOV     r7, r13

        LDMIA   r6!,{r0-r5}                     ; R0-R5
        STMIA   r7!,{r0-r5}
        LDMIA   r6!,{r0-r5}                     ; R6-R11
        STMIA   r7!,{r0-r5}
        LDMIA   r6,{r0,r13,r14}^                ; R12, R13_usr, R14_usr
        STR     r0,[r7]

; get original SPSR_und and R14_und from FPASC stack frame
; and transfer into SPSR_abt and R14_abt (adjusting R14 so it points
; 8 past the instruction).
  [ UseAbortStack
        LDR     r8, [r12,#60]                   ; R14_undef
        LDR     r9, [r12,#-8]                   ; SPSR_undef
        ADD     r8, r8, #4                      ; change from +4 to +8
  |
        LDR     r3, [r12,#60]                   ; R14_undef
        LDR     r0, [r12,#-8]                   ; SPSR_undef
        MRS     r1, CPSR
        BIC     r2, r1, #Mode_mask
        ORR     r2, r2, #Mode_ABT32
        MSR     CPSR_c, r2                      ; into ABT mode
        MSR     SPSR_cxsf, r0                   ; set up SPSR_abt
        ADD     r14, r3, #4                     ; change from +4 to +8
        MSR     CPSR_c, r1                      ; back to UND mode
  ]

; we should also arrange for the undefined stack pointer
; to go back up
  [ UseAbortStack
        BIC     r0, r11, #Mode_mask
        ORR     r0, r0, #Mode_UND32
        MSR     CPSR_c, r0
        ADD     r13, r12, #64
        MSR     CPSR_c, r11
  |
        ADD     r0, r12, #64
        STR     r0, [sp, #r13*4]
  ]
  [ MultipleContexts
        AdrWS   r10
  ]

PassOnDA
  [ UseAbortStack
        LDR     r0, DAVector                    ; get next DA handler address
        STR     r0, [sp, #13*4]                 ; put it into stack
        MSR     CPSR_cxsf, r11                  ; put CPSR back as it was on entry
        MSR     SPSR_cxsf, r9                   ; set up SPSR (possibly from FP frame)
        MOV     r14, r8                         ; set up SPSR (possibly from FP frame)
        LDMFD   sp!, {r0-r12,pc}                ; and pass on to next handler
  |
        BIC     r0, r11, #&FF                   ; set up SPSR_und to be correct CPSR
        ORR     r0, r0, #I32_bit + ABT32_mode   ; for data abort entry (xsf fields
        TST     r9, #F32_bit                    ; and F bit as they were on entry,
        ORRNE   r0, r0, #F32_bit                ; I set, T clear, ABT32 mode)
        MSR     SPSR_cxsf, r0
        LDR     r14, [sp, #r14*4]               ; restore r14_und
        LDR     r1, DAVector                    ; get next DA handler address
        STR     r1, [sp, #r14*4]                ; put it into stack
        LDMFD   sp, {r0-r13,pc}^                ; and jump to that handler in ABT mode
  ]

;
; **********************************************************************
;
 ] ; {FALSE}

    ] ; Arm600

    [   debug > 0
        InsertDebugRoutines
    ]

        END

;
; EOF riscos.end
;
@


4.7
log
@  Multiple context version of FP emulator and FPA support code - FP in
  callbacks and interrupts can now be yours.

  Exception dumps now available (integer and FP).

Detail:
* Changed to multiple-context version of the core. This will allow floating-
  point to be used safely in callbacks and interrupt routines (as long as
  you call the appropriate context changing SWIs). This activates the
  dormant SWIs FPEmulator_ChangeContext, FPEmulator_ContextLength and
  FPEmulator_InitContext. FPEmulator_DeactivateContext and
  FPEmulator_ActivateContext now have full functionality.

* Added new SWI interfaces to core: FPEmulator_Abort, FPEmulator_LoadContext
  and FPEmulator_SaveContext.

* On FP exceptions, integer registers are copied into the exception dump area.
  (TO DO: registers are USR mode ones - should take pains to figure out
  SVC or IRQ ones as required).

* The FPEmulator now has an exception dump area for floating point registers -
  a suitable version of Debugger will show these with *ShowFPRegs.

* FPEmulator_ChangeContext and FPEmulator_DeactivateContext now return -1
  for the default context.

* Run time detection of SVC stack position added.

* No longer creates a MessageTrans descriptor on the stack.

* Removed broken STM^ fudge from the FPA veneer, as the only StrongARMs that
  need it can't use the FPA.

* Fixed a typo in core_abort.

* Stopped continuous emulation runs crossing 4K page boundaries, with a view
  to improving abort handling.

* Use of DREG debugging macros fixed (line endings were being inserted in the
  wrong place).

* Prototype code to catch aborts inside the emulator and change the registers
  to make it look like the emulated instruction aborted. This is cute, but
  causes problems with anything like Ursula's lazy task-swapping. Really this
  needs to be done only on fatal aborts. Compiled out for now.

Version 4.12. Tagged as 'FPASC-4_12'
@
text
@d33 5
d54 3
d58 1
a408 1
    ]
a409 1
    [   {CONFIG}=26
d435 1
a435 1
        LDR     r2, UIVector
@


4.6
log
@  Merge of FPEmulator which uses the new macros in HdrSrc 0.63
Detail:
  Now 32-bit module compatible.
Admin:
  Tested the 26-bit build in the Customer F5 build.
  32-bit build tested on prototype 32-bit RISC OS.


Version 4.11. Tagged as 'FPASC-4_11'
@
text
@d29 2
a30 1
  [   Arm600
d32 1
a32 81
; In the case of a 32-bit handler, we don't support the core attempting
; to change the handler dynamically. Version 1.07 won't ever do this (we hope).
;
        STMFD   sp!, {r10, lr}

        ASSERT  Rwp = r10
        AdrWS   r10

;
; Make sure the veneer is only installed on the vector once. (This case will be the common
; one hit on almost every context switch.)
;
        [ {CONFIG}=26
        ;
        ; save the address of the true handler for the veneer to use
        ;
        STR     r1, CoreVector
        ]

        LDRB    lr, OnVector
        TEQ     lr, #0
        LDMNEFD sp!, {r10, pc}

        [ {CONFIG}=32
        STMFD   sp!, {r0-r2}
        |
        STMFD   sp!, {r0-r1}
        ]

        [ {CONFIG}=32
        ;
        ; Save the address of the handler so we can use OS_ClaimProcessorVector to remove it
        ;
        STR     r1, CoreVector
        ]

;
; the new 32-bit PC machines now have a SWI for installing
; a vector - use it to install the veneer
;
    [   {CONFIG}=32
        ; Install directly
        MRS     r2, CPSR        ; calling SWI will probably chuck us into SVC26 (we were entered
                                ; in SVC32), so save the CPSR
    |
        ; Install our pre-veneer
        ADR     r1, UI_veneer
    ]

        MOV     r0, #1
        ORR     r0, r0, #1 :SHL: 8      ; claiming undef. instr. vector

        SWI     XOS_ClaimProcessorVector


    [   {CONFIG}=32
        MSR     CPSR_c, r2              ; back into original mode
    ]

;
; save old vector in module workspace
;
        STR     r1, UIVector

;
; mark veneer as installed upon system vector.
;
        MOV     lr, #1
        STRB    lr, OnVector

;
; finished
;
    [   {CONFIG}=32
        LDMFD   sp!, {r0-r2, r10, pc}
    |
        LDMFD   sp!, {r0-r1, r10, pc}
    ]

  | ; Arm600
        STMFD   sp!, {r0-r2, r10, lr}
d34 1
a34 35
        ASSERT  Rwp = r10
        AdrWS   r10

        LDRB    r2, OnVector

;
; convert from address to branch instruction
;
        SUB     r1, r1, #12             ; allow for pipelining & instr. address
        MOV     r1, r1, LSR #2          ; byte offset -> word offset
        ORR     r1, r1, #&ea000000      ; add opcode for branch

        MOV     r0, #Undef_vector
        LDR     lr, [r0]
        STR     r1, [r0]

;
; be careful not to install the vector twice, thereby
; losing the true value of the old vector.
;
        TEQ     r2, #0
        LDMNEFD sp!, {r0-r2, r10, pc}^

        STRB    r0, OnVector            ; r0 != at this point

;
; save old vector in module workspace
;
        STR     lr, UIVector

;
; finished
;
        LDMFD   sp!, {r0-r2, r10, pc}^
  ] ; Arm600
d45 1
a45 10
  [  Arm600
        [ {CONFIG} = 32
        STMFD   sp!, {r0-r3, r10, lr}
        |
        STMFD   sp!, {r0-r2, r10, lr}
        ]

;
; load old vector from module workspace...
;
a46 1
        LDR     r1, UIVector
d48 2
a49 10
;
; fetch flags word and check that we are installed on the system vector
;
        LDRB    lr, OnVector
        TEQ     lr, #0
     [ {CONFIG}=32
        LDMEQFD sp!, {r0-r3, r10, pc}
     |
        LDMEQFD sp!, {r0-r2, r10, pc}
     ]
d51 1
a51 62
     [ {CONFIG}=32
        MRS     r3, CPSR                ; Calling SWI will probably chuck us into SVC26
        LDR     r2, CoreVector
     |
        ADR     r2, UI_veneer
     ]
        MOV     r0, #1
        SWI     XOS_ClaimProcessorVector

;
; mark module as off the undef. instr. vector if the SWI succeeded.
;
     [ {CONFIG}=32
        MSR     CPSR_c, r3              ; Back into SVC32
     ]

;
; done - save new flags away and return
;
        MOV     r0, #0
        STRB    r0, OnVector

     [ {CONFIG}=32
        LDMFD   sp!, {r0-r3, r10, pc}
     |
        LDMFD   sp!, {r0-r2, r10, pc}
     ]

  | ; Arm600

        STMFD   sp!, {r0, r10, lr}

        AdrWS   r10
;
; fetch flags word and check that we are installed on the system vector
;
        LDRB    lr, OnVector
        TEQ     lr, #0
        LDMEQFD sp!, {r0, r10, pc}^

;
; load old vector from module workspace...
;
        LDR     r0, UIVector

;
; ... and put it back
;
        MOV     lr, #Undef_vector
        STR     r0, [lr]

;
; mark the module as being off the undef. instr. vector
;
        MOV     r0, #0
        STRB    r0, OnVector

;
; done - return
;
        LDMFD   sp!, {r0, r10, pc}^
  ]
d69 1
a69 1
        LDR     r0, [r12, #-4]
d183 40
d237 1
a237 2
        SetMode SVC32_mode, r14
        LDR     sp, =SVCSTK
d239 2
d294 3
a296 5
        MOV     r4, r1                          ; Move input %0
        BL      open_message_file_stack         ; Open the file
        LDMVSFD sp!, {r2-r7,pc}                 ; Return the error

        MOV     r1, sp                          ; Messages file handl on stack
a303 3
        BL      close_message_file_stack        ; Close the file
        MOV     r2, #0
        CMP     r2, #&80000000                  ; set V
d315 1
a315 1
; open_message_file_stack -
d317 3
a319 3
; Carve the message file block off the stack, open the Messages file,
; and exit with the open file block on the stack unless there was an error.
; Preserves r0 (token to be looked up) unless error. Trashes R1, R2, R6, R7.
d321 2
a322 4
open_message_file_stack ROUT
        MOV     r7, lr                  ; Save LR
        MOV     r6, r0                  ; Save token/error block
        SUB     sp, sp, #16             ; Carve message file handle off stack
d324 1
a324 1
        MOV     r0, sp                  ; File handle on stack
d329 1
a329 3
        ADDVS   sp, sp, #16             ; Error - put stack back
        MOVVC   r0, r6                  ; Not error - restore token block
        MOV     pc, r7                  ; Return
d334 1
a334 1
; close_message_file_stack -
d336 1
a336 1
; Close the message file block on the stack, restore the stack, and return.
d338 1
d340 1
a340 1
close_message_file_stack ROUT
d344 1
a344 1
        MOV     r0, sp                  ; Message file block is on stack
a346 1
        ADD     sp, sp, #16             ; Put stack back
d453 146
a598 1
    ]
d603 3
@


4.5
log
@Ursula branch merged. This contains:
  Use of UMULL (compiled out).
  Service call table.
  Runs in UND32 mode (requires latest Kernel), giving a speed boost.

Version 4.10. Tagged as 'FPASC-4_10'
@
text
@d87 1
a87 1
        MSR     CPSR_all, r2            ; back into original mode
d195 1
a195 1
        MSR     CPSR_all, r3            ; Back into SVC32
d262 1
a262 1
        MSR     SPSR_all, r0
d387 3
a389 1
        SetMode SVC26_mode, r14
d430 1
d443 2
a444 1
copy_error_one Entry "r2-r7"
d447 1
a447 1
        EXIT    VS                              ; Return the error
d458 3
a460 1
        EXIT
d497 1
a497 1
; Preserves R0 (error block) and V bit. Trashes R6 and R7.
d500 1
a500 1
        MOV     r7, lr                  ; Save LR (and V bit)
d508 1
a508 1
        MOVS    pc, r7                  ; Return and preserve V bit
d539 1
a539 1
        MSR     CPSR_all, lr_undef
d598 1
a598 1
        MRS     r4, CPSR_all
d600 1
a600 1
        MSR     CPSR_all, r4
@


4.5.2.1
log
@ObjASM 3.12 syntax warning fixes.
32-bit compatible, hopefully.
Requires HdrSrc.

Version 4.10, 4.3.2.1. Tagged as 'FPASC-4_10-4_3_2_1'
@
text
@d87 1
a87 1
        MSR     CPSR_c, r2              ; back into original mode
d195 1
a195 1
        MSR     CPSR_c, r3              ; Back into SVC32
d262 1
a262 1
        MSR     SPSR_cxsf, r0
d387 1
a387 3
; Change into SVC32. If on a 26-bit system we will fall back to SVC26
; on the next SWI. Sneaky huh?
        SetMode SVC32_mode, r14
a427 1
        ALIGN
d440 1
a440 2
copy_error_one
        STMFD   sp!, {r2-r7,lr}
d443 1
a443 1
        LDMVSFD sp!, {r2-r7,pc}                 ; Return the error
d454 1
a454 3
        MOV     r2, #0
        CMP     r2, #&80000000                  ; set V
        LDMFD   sp!, {r2-r7,pc}
d491 1
a491 1
; Preserves R0 (error block). Trashes R6 and R7, V-bit
d494 1
a494 1
        MOV     r7, lr                  ; Save LR
d502 1
a502 1
        MOV     pc, r7                  ; Return
d533 1
a533 1
        MSR     CPSR_c, lr_undef
d592 1
a592 1
        MRS     r4, CPSR
d594 1
a594 1
        MSR     CPSR_c, r4
@


4.4
log
@Makefile modified to use LocalRes$Path.
Changed to use srccommit.
German resources added.

Version 4.09. Tagged as 'FPASC-4_09'
@
text
@d29 1
a29 1
        STMFD   sp!, {r0-r4, lr}
d31 7
a37 2
        AdrWS   r0
	LDR	r4, [r0, #:INDEX:FPAFlags]
a38 1
    [   Arm600
d40 2
a41 1
; save the address of the true handler for the veneer to use
d43 10
a52 1
        STR     r1, [r0, #:INDEX:CoreVector]
d54 12
a65 6
;
; have recorded the core's new handler, make sure that the
; veneer is only installed upon the system vector once.
;
	TST	r4, #OnVector
	BNE	%F55
d71 6
d78 2
d84 10
a93 1
        MOV     r2, r1
d98 14
a111 1
	ORRVC	r4, r4, #OnVector
d113 4
a116 1
        AdrWS   r0
a117 1
    |
d125 3
a127 3
        MOV     r3, #Undef_vector
        LDR     r2, [r3]
        STR     r1, [r3]
d133 2
a134 2
	TST	r4, #OnVector
	BNE	%F55
d136 1
a136 2
	ORR	r4, r4, #OnVector
    ]
d141 1
a141 6
        STR     r2, [r0, #:INDEX:UIVector]

;
; save new flags word back
;
	STR	r4, [r0, #:INDEX:FPAFlags]
d146 2
a147 1
55      LDMFD   sp!, {r0-r4, pc}^
d158 6
a163 1
        STMFD   sp!, {r0-r4, lr}
d168 2
a169 2
        AdrWS   r3
        LDR     r1, [r3, #:INDEX:UIVector]
d174 14
a187 5
	LDR	r4, [r3, #:INDEX:FPAFlags]
	TST	r4, #OnVector
	BEQ	%F55

    [ Arm600
a188 1
        ADR     r2, UI_veneer
d194 33
a226 2
	BICVC	r4, r4, #OnVector
    |
d230 2
a231 2
        MOV     r0, #Undef_vector
        STR     r1, [r0]
d236 2
a237 2
	BIC	r4, r4, #OnVector
    ]
d240 1
a240 1
; done - save new flags away and return
d242 2
a243 2
	STR	r4, [r3, #:INDEX:FPAFlags]
55      LDMFD   sp!, {r0-r4, pc}^
d260 4
d266 1
a266 1
        AND     r0, r0, r0                      ; NOP after banked reg. access
d380 1
a380 1
        LDMIA   sp!, {r2-r12}
d382 8
a389 1
        LDMIA   sp!, {lr}
d396 1
a396 2
        STMDB   sp!, {r10-r12}
        STMDB   sp!, {lr}
d401 1
a401 1
;       
d427 1
a427 1
        DCB     "BadFPC", NULL 
d443 1
a443 1
        EXIT    VS                              ; Return the error 
d512 1
d522 2
a523 2
        STMFD   sp!, {r0}
        AdrWS   r0
d525 9
a533 6
        STR     lr_undef, [r0, #:INDEX:SavedLR]
        MRS     lr_undef, SPSR_all
        STR     lr_undef, [r0, #:INDEX:SavedPSR]

        LDMFD   sp!, {r0}               ; restore sp_undef before mode change
        SetMode SVC26_mode, lr_undef
d540 1
a540 1
        STMFD   sp!, {r0-r2}
d542 3
a544 3
        AdrWS   r0
        LDR     lr, [r0, #:INDEX:SavedLR]
        LDR     r1, [r0, #:INDEX:SavedPSR]      
d551 1
a551 1
        LDR     r1, [r0, #:INDEX:CoreVector]
d553 2
a554 1
        LDMFD   sp!, {r0-r2, pc}
d556 1
d573 1
a573 1
        MOV     r0, r0                  ; NOP
d575 1
a575 1
        STMDB   sp, {r0-r4, lr, pc}     ; XXX no writeback
d581 2
a582 2
        AdrWS   r0
        LDR     r2, [r0, #:INDEX:UIVector]
d593 1
a593 2
        BIC     r4, r4, #&1f
        ORR     r4, r4, #UND32_mode
d597 1
a597 1
; place values for sp, lr and pc onto stack
d599 2
a600 2
        ADD     r0, r3, #5 * 4
        STMIA   r0, {r1, r2}
d605 2
a606 2
        LDMIA   r3, {r0-r4, lr, pc}

@


4.3
log
@Version RO_3_71 merged
@
text
@d17 1
a17 1
        DCB     "FPEmulator", TAB, "$VersionString ($Date) ($CoreVersion)",NULL
@


4.3.2.1
log
@incorporate KBracey changes:
  Use long multiply (assumes long multiply; won't work on ARM 610,710)
  Compile with 32-bit APCS for better efficiency (requires Ursula kernel)
  Also compile for soft FP only (suit SA110)
update module format to Ursula service handler table
@
text
@d29 1
a29 1
  [   Arm600
d31 4
a34 2
; In the case of a 32-bit handler, we don't support the core attempting
; to change the handler dynamically. Version 1.07 won't ever do this (we hope).
d36 3
a38 4
        STMFD   sp!, {r10, lr}

        ASSERT  Rwp = r10
        AdrWS   r10
d41 2
a42 2
; Make sure the veneer is only installed on the vector once. (This case will be the common
; one hit on almost every context switch.)
d44 2
a45 23
        [ {CONFIG}=26
        ;
        ; save the address of the true handler for the veneer to use
        ;
        STR     r1, CoreVector
        ]

        LDRB    lr, OnVector
        TEQ     lr, #0
        LDMNEFD sp!, {r10, pc}

        [ {CONFIG}=32
        STMFD   sp!, {r0-r2}
        |
        STMFD   sp!, {r0-r1}
        ]

        [ {CONFIG}=32
        ;
        ; Save the address of the handler so we can use OS_ClaimProcessorVector to remove it
        ;
        STR     r1, CoreVector
        ]
a50 6
    [   {CONFIG}=32
        ; Install directly
        MRS     r2, CPSR        ; calling SWI will probably chuck us into SVC26 (we were entered
                                ; in SVC32), so save the CPSR
    |
        ; Install our pre-veneer
a51 2
    ]

d56 1
a56 5


    [   {CONFIG}=32
        MSR     CPSR_all, r2            ; back into original mode
    ]
d59 1
a59 1
; save old vector in module workspace
d61 1
a61 1
        STR     r1, UIVector
d63 1
a63 5
;
; mark veneer as installed upon system vector.
;
        MOV     lr, #1
        STRB    lr, OnVector
a64 5
;
; finished
;
    [   {CONFIG}=32
        LDMFD   sp!, {r0-r2, r10, pc}
a65 11
        LDMFD   sp!, {r0-r1, r10, pc}
    ]

  | ; Arm600
        STMFD   sp!, {r0-r2, r10, lr}

        ASSERT  Rwp = r10
        AdrWS   r10

        LDRB    r2, OnVector

d73 3
a75 3
        MOV     r0, #Undef_vector
        LDR     lr, [r0]
        STR     r1, [r0]
d81 2
a82 2
        TEQ     r2, #0
        LDMNEFD sp!, {r0-r2, r10, pc}^
d84 2
a85 1
        STRB    r0, OnVector            ; r0 != at this point
d90 6
a95 1
        STR     lr, UIVector
d100 1
a100 2
        LDMFD   sp!, {r0-r2, r10, pc}^
  ] ; Arm600
d111 1
a111 6
  [  Arm600
        [ {CONFIG} = 32
        STMFD   sp!, {r0-r3, r10, lr}
        |
        STMFD   sp!, {r0-r2, r10, lr}
        ]
d116 2
a117 2
        AdrWS   r10
        LDR     r1, UIVector
d122 6
a127 12
        LDRB    lr, OnVector
        TEQ     lr, #0
     [ {CONFIG}=32
        LDMEQFD sp!, {r0-r3, r10, pc}
     |
        LDMEQFD sp!, {r0-r2, r10, pc}
     ]

     [ {CONFIG}=32
        MRS     r3, CPSR                ; Calling SWI will probably chuck us into SVC26
        LDR     r2, CoreVector
     |
a128 2
     ]
        MOV     r0, #1
d134 2
a135 33
     [ {CONFIG}=32
        MSR     CPSR_all, r3            ; Back into SVC32
     ]

;
; done - save new flags away and return
;
        MOV     r0, #0
        STRB    r0, OnVector

     [ {CONFIG}=32
        LDMFD   sp!, {r0-r3, r10, pc}
     |
        LDMFD   sp!, {r0-r2, r10, pc}
     ]

  | ; Arm600

        STMFD   sp!, {r0, r10, lr}

        AdrWS   r10
;
; fetch flags word and check that we are installed on the system vector
;
        LDRB    lr, OnVector
        TEQ     lr, #0
        LDMEQFD sp!, {r0, r10, pc}^

;
; load old vector from module workspace...
;
        LDR     r0, UIVector

d139 2
a140 2
        MOV     lr, #Undef_vector
        STR     r0, [lr]
d145 2
a146 2
        MOV     r0, #0
        STRB    r0, OnVector
d149 1
a149 1
; done - return
d151 2
a152 2
        LDMFD   sp!, {r0, r10, pc}^
  ]
a168 4
   [ {CONFIG}=32
        LDR     r0, [r12, #-4]
        MSR     SPSR_all, r0
   ]
d171 1
a171 1
        NOP                              ; NOP after banked reg. access
d285 1
a285 1
        LDMFD   sp!, {r2-r12}
d287 1
a287 8
        LDMFD   sp!, {r1}                       ; really r14_und

; flatten Supervisor stack

    [   {CONFIG}=32
        SetMode SVC26_mode, r14
        LDR     sp, =SVCSTK
    ]
d294 2
a295 1
        STMFD   sp!, {r1, r10-r12}
d300 1
a300 1
;
d326 1
a326 1
        DCB     "BadFPC", NULL
d342 1
a342 1
        EXIT    VS                              ; Return the error
a410 1
     [  {CONFIG}=26
d420 2
a421 2
        STR     r10, [sp, #-4]!         ; STR faster than STM of one register on many ARMs
        AdrWS   r10
d423 6
a428 9
        STR     lr_undef, SavedLR
        MRS     lr_undef, SPSR
        STR     lr_undef, SavedPSR

        LDR     r10, [sp], #4            ; restore sp_undef before mode change

        MRS     lr_undef, CPSR
        BIC     lr_undef, lr_undef, #2_11100     ; switch from UND32 to SVC26
        MSR     CPSR_all, lr_undef
d435 1
a435 1
        STMFD   sp!, {r1-r2, r10}
d437 3
a439 3
        AdrWS   r10
        LDR     lr, SavedLR
        LDR     r1, SavedPSR
d446 1
a446 1
        LDR     r1, CoreVector
d448 1
a448 2
        LDMFD   sp!, {r1-r2, r10, pc}
    ]
a449 1
    [   {CONFIG}=26
d466 1
a466 1
        NOP
d468 1
a468 1
        STMDB   sp, {r1-r4, r10, lr, pc}     ; XXX no writeback
d474 2
a475 2
        AdrWS   r10
        LDR     r2, UIVector
d486 2
a487 1
        ORR     r4, r4, #UND32_mode     ; Go from SVC26 to UND32 mode
d491 1
a491 1
; place values for lr and pc onto stack
d493 2
a494 2
        ADD     r4, r3, #5 * 4
        STMIA   r4, {r1, r2}
d499 2
a500 2
        LDMIA   r3, {r1-r4, r10, lr, pc}
     ]
@


4.2
log
@Version RO_3_70 taken
@
text
@a171 3
  [ SAnaffsilicon
    NOP
  ]
@


4.1
log
@Initial revision
@
text
@d172 3
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a171 3
  [ SAnaffsilicon
    NOP
  ]
@


4.1.3.2
log
@Version RO_3_71 taken
@
text
@d172 3
@


4.1.3.1.2.1
log
@Merged from 3.71 CD
@
text
@d172 3
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	1.17;
access;
symbols
	SCSISoftUSB-0_25-1:1.17
	SCSISoftUSB-0_25:1.17
	SCSISoftUSB-0_24:1.16
	SCSISoftUSB-0_23:1.16
	SCSISoftUSB-0_22:1.16
	SCSISoftUSB-0_21:1.16
	SCSISoftUSB-0_20:1.15
	SCSISoftUSB-0_19:1.15
	SCSISoftUSB-0_18:1.15
	SCSISoftUSB-0_17:1.14
	SCSISoftUSB-0_16:1.14
	SCSISoftUSB-0_15:1.13
	SCSISoftUSB-0_14:1.12
	SCSISoftUSB-0_13:1.11
	SCSISoftUSB-0_12:1.11
	SCSISoftUSB-0_11:1.10
	SCSISoftUSB-0_10:1.9
	SCSISoftUSB-0_09:1.8
	SCSISoftUSB-0_08:1.7
	SCSISoftUSB-0_07:1.6
	SCSISoftUSB-0_06:1.5
	SCSISoftUSB-0_05:1.4
	SCSISoftUSB-0_04:1.4
	SCSISoftUSB-0_03:1.3
	SCSISoftUSB-0_02:1.2
	SCSISoftUSB-0_01:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.17
date	2018.07.13.22.31.12;	author jballance;	state Exp;
branches;
next	1.16;
commitid	sXRoV4QbdosnJ1KA;

1.16
date	2016.03.10.18.32.10;	author rsprowson;	state Exp;
branches;
next	1.15;
commitid	9jlTGWa4XBWgT7Yy;

1.15
date	2013.07.13.17.24.41;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	pN6JUCoe2amgJkXw;

1.14
date	2012.06.03.14.25.56;	author jlee;	state Exp;
branches;
next	1.13;
commitid	tugyl8mcBbH3Lg7w;

1.13
date	2011.11.27.18.16.08;	author jlee;	state Exp;
branches;
next	1.12;
commitid	x66KzEa2j2aH60Jv;

1.12
date	2011.07.24.22.09.31;	author jlee;	state Exp;
branches;
next	1.11;
commitid	hW9XzNMbX8MQrPsv;

1.11
date	2010.04.22.20.25.18;	author jlee;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.22.01.19.57;	author jlee;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.20.12.06.57;	author jballance;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.10.23.22.50;	author jballance;	state Exp;
branches;
next	1.7;

1.7
date	2005.06.27.21.27.45;	author jballance;	state Exp;
branches;
next	1.6;

1.6
date	2005.06.24.21.03.12;	author jballance;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.05.00.44.42;	author jballance;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.13.12.37.37;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.03.10.46.37;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.23.18.37.55;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.14.16.49.27;	author bavison;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.05.14.16.49.27;	author bavison;	state Exp;
branches;
next	;


desc
@@


1.17
log
@  Resolved a couple of obscure null pointer errors
Detail:
  A misbehaving USB SDcard adaptor caused unexpected duplication of some
  structure free calls. Ensured this is protected
Admin:
  tested on iMx6

Version 0.25. Tagged as 'SCSISoftUSB-0_25'
@
text
@/* Copyright 2003 Tematic Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*****************************************************************************
* $Id: module,v 1.16 2016/03/10 18:32:10 rsprowson Exp $
* $Name: HEAD $
*
* Author(s):  Ben Avison
* Project(s): 
*
* ----------------------------------------------------------------------------
* Purpose: Main relocatable module entry points
*
* ----------------------------------------------------------------------------
* History: See source control system log
*
*****************************************************************************/


/*****************************************************************************
* Include header files
*****************************************************************************/
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include "kernel.h"
#include "swis.h"

#include "Global/Services.h"
#include "Global/RISCOS.h"
#include "Interface/SCSIErr.h"
#include "Interface/RTSupport.h"
#include "DebugLib/DebugLib.h"
#include "USB/USBDevFS.h"

#include "global.h"
#include "glue.h"                           
#include "modhdr.h"
#include "resmess.h"


/*****************************************************************************
* MACROS
*****************************************************************************/


/*****************************************************************************
* New type definitions
*****************************************************************************/


/*****************************************************************************
* Constants
*****************************************************************************/


/*****************************************************************************
* File scope Global variables
*****************************************************************************/
static bool Registering;
static bool No_New_Stuff;
/*****************************************************************************
* Function prototypes - Private to this file
*****************************************************************************/
static uint32_t RegisterSCSIDevice(void *device);
//static void DeregisterSCSIDevice(void *device, uint32_t scsi_driver_handle);
static _kernel_oserror *SearchForDevices(void);
static _kernel_oserror *CheckConnectedDevice(const USBServiceCall *service_call_block);
static _kernel_oserror *CheckDisconnectedDevice(const char *device_name);
static _kernel_oserror *RemoveAllDevices(void);

/*****************************************************************************
* Functions
*****************************************************************************/

/*****************************************************************************
* module_Init
*
* Initialisation code
*
* Assumptions
*  NONE
*
* Inputs
*  cmd_tail:    points to the string of arguments with which the module is invoked
*               (may be "", and is control-terminated, not zero terminated)
*  podule_base: 0              => first invocation, not from a podule
*               1 - 0x02FFFFFF => reincarnation number
*               >0x03000000    => first invocation, from a podule based at this address
*  pw:          the 'R12' value established by module initialisation
*
* Outputs
*  NONE
*
* Returns
*  NULL if initialisation succeeds; otherwise pointer to error block
*****************************************************************************/
_kernel_oserror *module_Init(const char *cmd_tail, int podule_base, void *pw)
{
  _kernel_oserror *e = NULL;
#ifdef STANDALONE
  bool FileRegistered = false;
#endif
  bool MessagesOpen = false;
  bool OnUpCallV = false;
  bool CallbackSet = false;
  No_New_Stuff = false;
  IGNORE(cmd_tail);
  IGNORE(podule_base);

  Registering = false;
  
  debug_initialise("SCSISoftUSB", "null:", 0);
//  debug_set_taskname_prefix(true);
//  debug_set_area_level_prefix(true);
//  debug_set_area_pad_limit(0);
    debug_set_unbuffered_files (TRUE);
//    debug_set_stamp_debug (TRUE);
    debug_set_device(    DADEBUG_OUTPUT);
//    debug_set_device(    PRINTF_OUTPUT);
//  debug_set_raw_device(  DEBUGIT_OUTPUT);
//  debug_set_trace_device(DEBUGIT_OUTPUT);
//  debug_set_device(NULL_OUTPUT);
//  debug_set_raw_device(NULL_OUTPUT);
//  debug_set_trace_device(NULL_OUTPUT);
  
  global_PrivateWord = pw;
  
  if (!e)
  {
#ifdef STANDALONE
    e = _swix(ResourceFS_RegisterFiles, _IN(0),
              resmess_ResourcesFiles());
  }
  if (!e)
  {
    FileRegistered = true;
#endif
    
    e = _swix(MessageTrans_OpenFile, _INR(0,2),
              &global_MessageFD,
              Module_MessagesFile,
              0);
  }
  if (!e)
  {
    MessagesOpen = true;
  }
  if (!e)
  {
    
    e = _swix(OS_Claim, _INR(0,2),
              UpCallV,
              module_upcallv_handler,
              global_PrivateWord);
  }
  if (!e)
  {
    OnUpCallV = true;
    
    e = _swix(OS_AddCallBack, _INR(0,1),
              module_callback_from_init,
              global_PrivateWord);
  }
  if (!e)
  {
    CallbackSet = true;

    /* Detection of RTSupport module
       We require at least version 0.05, because previous versions had some rather nasty bugs that are too much hassle to work around for the benefit of the two people who have old versions of RTSupport on their machine and are unable to upgrade to newer versions */
    char **mod_code;
    if(!_swix(OS_Module,_INR(0,1) | _OUT(3),18,"RTSupport",&mod_code))
    {
      /* Find and decode version number, similar to RMEnsure.
         We really need a SWI for this! */
      char *help_str = mod_code[5]+(uint32_t)mod_code;
      while(*help_str && !isdigit(*help_str))
        help_str++;
      int version=0;
      while(isdigit(*help_str))
      {
        version = (version<<4) | (*help_str-'0');
        help_str++;
      }
      int zeros=4;
      if(*help_str == '.')
      {
        help_str++;
        while(isdigit(*help_str) && zeros)
        {
          version = (version<<4) | (*help_str-'0');
          help_str++;
          zeros--;
        }
      }
      version = version<<(zeros*4);
      if(version >= 0x0500)
      {
        global_UseRTSupport = true;
      }
    }
    if(!global_UseRTSupport)
      global_RTSupportPollword = 1; /* Force pollword nonzero so we avoid pointless calls to glue_BufferThreshouldCheck */
    
  }
  if (e && CallbackSet) _swix(OS_RemoveCallBack, _INR(0,1),
                              module_callback_from_init,
                              global_PrivateWord);
  if (e && OnUpCallV) _swix(OS_Release, _INR(0,2),
                            UpCallV,
                            module_upcallv_handler,
                            global_PrivateWord);
  if (e) RemoveAllDevices();
  if (e && MessagesOpen) _swix(MessageTrans_CloseFile, _IN(0),
                               &global_MessageFD);
#ifdef STANDALONE
  if (e && FileRegistered) _swix(ResourceFS_DeregisterFiles, _IN(0),
                                 resmess_ResourcesFiles());
#endif
  return e;
}

/*****************************************************************************
* module_CallbackFromInit
*
* Callback handler for callback set in module initialisation
*
* Assumptions
*  NONE
*
* Inputs
*  r:          register block
*  pw:         the 'R12' value
*
* Outputs
*  NONE
*
* Returns
*  NULL if successful; otherwise pointer to error block
*****************************************************************************/
_kernel_oserror *module_CallbackFromInit(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  /* lets see what is there .. */
  if(!No_New_Stuff)SearchForDevices();
  return NULL;
}

/*****************************************************************************
* module_Final
*
* Finalisation code
*
* Assumptions
*  NONE
*
* Inputs
*  fatal, podule, pw: the values of R10, R11 and R12 (respectively) on entry
*                     to the finalisation code
*
* Outputs
*  NONE
*
* Returns
*  NULL if finalisation succeeds; otherwise pointer to error block
*****************************************************************************/
_kernel_oserror *module_Final(int fatal, int podule, void *pw)
{
  IGNORE(fatal);
  IGNORE(podule);
  IGNORE(pw);
  /* For safety, ensure we're no longer on TickerV */
  _kernel_irqs_off();
  No_New_Stuff=true;

  RemoveAllDevices();
  _swix(OS_RemoveTickerEvent, _INR(0,1),
        module_scsiregister_handler,
        global_PrivateWord);
  _swix(OS_RemoveCallBack, _INR(0,1),
        module_scsiregister_cb_handler,
        global_PrivateWord);
  _swix(OS_RemoveCallBack, _INR(0,1),
        module_callback_from_init,
        global_PrivateWord);
  global_TickerList=NULL;
  if(global_CallbackType == callback_TickerV)
    _swix(OS_Release, _INR(0,2),
          TickerV,
          module_tickerv_handler,
          global_PrivateWord);
  else if(global_CallbackType == callback_RTSupport)
    _swix(RT_Deregister, _INR(0,1),
          0,
          global_RTSupportHandle);
  _swix(OS_Release, _INR(0,2),
        UpCallV,
        module_upcallv_handler,
        global_PrivateWord);
  _swix(MessageTrans_CloseFile, _IN(0),
        &global_MessageFD);
#ifdef STANDALONE
  _swix(ResourceFS_DeregisterFiles, _IN(0),
        resmess_ResourcesFiles());
#endif
  _kernel_irqs_on();
  return NULL;
}

/*****************************************************************************
* module_Service
*
* Service call handler
*
* Assumptions
*  NONE
*
* Inputs
*  service_number: service call number
*  r:              pointer to registers on entry
*  pw:             the 'R12' value
*
* Outputs
*  r:              updated or not, as appropriate
*
* Returns
*  NOTHING
*****************************************************************************/
void module_Service(int service_number, _kernel_swi_regs *r, void *pw)
{
  IGNORE(pw);
  if (No_New_Stuff)return;
  switch (service_number)
  {
    case Service_MessageFileClosed:
      /* We might want to use our message file descriptor from the background, */
      /* so re-open message file now, when filing system re-entrancy isn't an issue */
      _swix(MessageTrans_OpenFile, _INR(0,2),
            &global_MessageFD,
            Module_MessagesFile,
            0);
      break;
      
    case Service_ModulePostInit:
      if (strcmp((const char *)r->r[2], "SCSIDriver") == 0)
      {
        _swix(OS_RemoveTickerEvent, _INR(0,1),
           module_scsiregister_handler,
           global_PrivateWord);
        for (my_usb_device_t *device = global_DeviceList; device != NULL; device = device->next)
        {
          device->registered = false;
        }
        _swix(OS_CallAfter, _INR(0,2),
           1, /* No point using a long delay if SCSIDriver has only just started */
           module_scsiregister_handler,
           global_PrivateWord);

      }
      break;
      
    case Service_PreReset:
      No_New_Stuff=true;
      break;
      
    case Service_USB:
      switch (r->r[0])
      {
        case Service_USB_Attach:
          CheckConnectedDevice((const USBServiceCall *)r->r[2]);
          break;
          
        case Service_USB_USBDriverStarting:
          /* SearchForDevices(); unnecessary */
          break;
          
        case Service_USB_USBDriverDying:
          /* RemoveAllDevices(); unnecessary */
          break;
      }
      break;
      
    case Service_DeviceDead:
    {
      const char *devicename = (const char *)r->r[3];
      if (devicename && devicename[0]=='U' && devicename[1]=='S' && devicename[2]=='B')
      {
        CheckDisconnectedDevice(devicename);
      }
      break;
    }
      
    default:
      assert(false /* unserviced service call */);
      break;
  }
  return;
}

/*  module_SCSIRegister
 *  register any unregistered devices on the list from a callback
 */ 
_kernel_oserror *module_SCSIRegister(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);                         
  IGNORE(pw);
  if(Registering)   /* come back later for another pass */
  {
    _swix(OS_CallAfter, _INR(0,2),
          10,
          module_scsiregister_handler,
          global_PrivateWord);
    return NULL;
  }
  /* Instead of registering the devices directly from this ticker event, register them from a callback. This ensures SCSIDriver's malloc()s can enlarge the RMA if needed. */
  Registering = true;
  _swix(OS_AddCallBack, _INR(0,1),
        module_scsiregister_cb_handler,
        global_PrivateWord);
  return NULL;
}

/*  module_SCSIRegister_cb
 *  register any unregistered devices on the list from a callback
 */ 
_kernel_oserror *module_SCSIRegister_cb(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);                         
  IGNORE(pw);
  for (my_usb_device_t *device = global_DeviceList; device != NULL; device = device->next)
  {
    if(!device->registered)
    {
      dprintf(("","Registering scsi device for %p \n",device));
      device->scsi_driver_handle =RegisterSCSIDevice(device);
      device->registered = true;
    }  
  }
  Registering = false;
  return NULL;
}


/*****************************************************************************
* module_Commands
*
* Command handler
*
* Assumptions
*  NONE
*
* Inputs
*  arg_string: command tail
*  argc:       number of parameters
*  cmd_no:     index into cmhg's list of commands
*  pw:         the 'R12' value
*
* Outputs
*  NONE
*
* Returns
*  NULL if successful; otherwise pointer to error block
*****************************************************************************/
_kernel_oserror *module_Commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
  _kernel_oserror *e = NULL;
  IGNORE(arg_string);
  IGNORE(argc);
  IGNORE(pw);
  switch (cmd_no)
  {
    case CMD_SCSISoftUSB_PopUpDelay:
      if(argc)
      {
        uint32_t delay;
        /* Use something that will generate an error if the user got it wrong! */
        e = _swix(OS_ReadUnsigned,_INR(0,1)|_OUT(2),10,arg_string,&delay);
        if(e)
          return e;
        global_PopUpDelay = delay;
      }
      else
      {        
        const char *msg;
        e = _swix(MessageTrans_Lookup,_INR(0,2)|_OUT(2),&global_MessageFD,"CDELAY",NULL,&msg);
        if(e)
          return e;
        printf(msg,global_PopUpDelay,'\n'); /* What would be worse - using two fixed-size buffers to prepare the message string, or this atrocity? */
      }
      break;
  }
  return e;
}

/*****************************************************************************
* RegisterSCSIDevice
*
* Tries to register a device with SCSIDriver
*
* Assumptions
*  NONE
*
* Inputs
*  device: our private handle for this device
*
* Outputs
*  NONE
*
* Returns
*  the handle required to deregister the device (actually device/bus ID)
*****************************************************************************/
static uint32_t RegisterSCSIDevice(void *device)
{
  uint32_t scsi_driver_handle = -1; /* invalid value for error case */
  _swix(SCSI_Register, _INR(0,3)|_OUT(0),
        0, /* register device, not bus */
        module_scsi_handler,
        global_PrivateWord,
        device,
        &scsi_driver_handle);
  dprintf(("","Got scsi device handle %x maxlun %d\n",scsi_driver_handle,((my_usb_device_t*)device)->maxlun));
  return scsi_driver_handle;
}

/*****************************************************************************
* DeregisterSCSIDevice
*
* Tries to deregister a device with SCSIDriver
*
* Assumptions
*  NONE
*
* Inputs
*  device:             our private handle for this device
*  scsi_driver_handle: SCSIDriver's handle for this device (actually device/bus ID)
*
* Outputs
*  NONE
*
* Returns
*  NOTHING
*****************************************************************************/
static void DeregisterSCSIDevice(void *device, uint32_t scsi_driver_handle)
{
  dprintf(("","DeRegister scsi handle %x \n",scsi_driver_handle));
  _swix(SCSI_Deregister, _INR(0,3),
        scsi_driver_handle,
        module_scsi_handler,
        global_PrivateWord,
        device);
  return;
}

/*****************************************************************************
* SearchForDevices
*
* Scans the USB buses for devices of mass storage class and SCSI sub-class,
* creates devices for them on our fake SCSI bus, and informs SCSIDriver
*
* Assumptions
*  NONE
*
* Inputs
*  NONE
*
* Outputs
*  NONE
*
* Returns
*  NULL if successful; otherwise pointer to error block
*****************************************************************************/
static _kernel_oserror *SearchForDevices(void)
{
  USBServiceAnswer *item;
  RETURN_ERROR(_swix(OS_ServiceCall, _INR(0,2)|_OUT(2),
                     Service_USB_Connected,
                     Service_USB,
                     NULL,
                     &item));
  _kernel_oserror *e = NULL;
  while (item)
  {
    if (!e) e = CheckConnectedDevice(&item->svc);
    USBServiceAnswer *nextitem = item->link;
    free(item);
    item = nextitem;
  }
  return e;
}

/*****************************************************************************
* CheckConnectedDevice
*
* Vets a device for being of mass storage class and SCSI sub-class,
* and if so, creates a device for it on our fake SCSI bus, and informs SCSIDriver
*
* Assumptions
*  NONE
*
* Inputs
*  NONE
*
* Outputs
*  NONE
*
* Returns
*  NULL 
*****************************************************************************/
static _kernel_oserror *CheckConnectedDevice(const USBServiceCall *service_call_block)
{
  const char *ptr = (const char *) &service_call_block->ddesc;
  uint32_t bytes_left = service_call_block->sclen - (size_t) &((USBServiceCall *)0)->ddesc;
  uint32_t bytes_in_this_descriptor;
  uint16_t vendor = 0;
  uint16_t product = 0;
  while (bytes_left >= 2 &&
         (bytes_in_this_descriptor = ((usb_descriptor_t *)ptr)->bLength) != 0 &&
         bytes_left >= bytes_in_this_descriptor)
  {
    if (((usb_descriptor_t *)ptr)->bDescriptorType == UDESC_DEVICE)
    {
      const usb_device_descriptor_t *device = (const usb_device_descriptor_t *) ptr;
      vendor = device->idVendor;
      product = device->idProduct;
    }
    else if (((usb_descriptor_t *)ptr)->bDescriptorType == UDESC_INTERFACE)
    {
      const usb_interface_descriptor_t *interface = (const usb_interface_descriptor_t *) ptr;
      if (interface->bInterfaceClass == 8          /* mass storage class */
#ifdef LIMITED_SCOPE      
      && (interface->bInterfaceSubClass == 6        /* SCSI  */
          || interface->bInterfaceSubClass == 5     /* floppy */
         ) 
      && (interface->bInterfaceProtocol == 0       /* control/bulk/interrupt with command completion interrupt */
          || interface->bInterfaceProtocol == 1    /* control/bulk/interrupt without command completion interrupt  */
          || interface->bInterfaceProtocol == 0x50 /* bulk-only */
          )
#endif
         )
      {
        my_usb_device_t *device = (my_usb_device_t *)((char *) calloc(1, sizeof *device) - 4);
        if (device != NULL)
        {
          device->interface = interface->bInterfaceNumber;
          device->alternate = interface->bAlternateSetting;
          device->subclass = interface->bInterfaceSubClass;
          device->protocol = interface->bInterfaceProtocol;
          device->bulk_in_endpoint = 0xFF;
          device->bulk_out_endpoint = 0xFF;
          device->interrupt_endpoint = 0xFF;
          device->vendor = vendor;
          device->product = product;
          strcpy(device->devicefs_name, service_call_block->devname);
          ptr += bytes_in_this_descriptor;
          bytes_left -= bytes_in_this_descriptor;
          while (bytes_left >= 2 &&
                 (bytes_in_this_descriptor = ((usb_descriptor_t *)ptr)->bLength) != 0 &&
                 bytes_left >= bytes_in_this_descriptor &&
                 ((usb_descriptor_t *)ptr)->bDescriptorType >= UDESC_ENDPOINT)
          {
            if (((usb_descriptor_t *)ptr)->bDescriptorType == UDESC_ENDPOINT)
            {
              usb_endpoint_descriptor_t *endpoint = (usb_endpoint_descriptor_t *) ptr;
              if ((endpoint->bmAttributes & 3) == 2 /* bulk endpoint */)
              {
                if ((endpoint->bEndpointAddress & 0x80) != 0 /* in */)
                {
                  if (device->bulk_in_endpoint == 0xFF)
                  {
                    device->bulk_in_endpoint = endpoint->bEndpointAddress;
                    device->bulk_in_maxpacketsize = endpoint->wMaxPacketSize;
                  }
                }
                else /* out */
                {
                  if (device->bulk_out_endpoint == 0xFF)
                  {
                    device->bulk_out_endpoint = endpoint->bEndpointAddress;
                    device->bulk_out_maxpacketsize = endpoint->wMaxPacketSize;
                  }
                }
              }
              else if ((endpoint->bmAttributes & 3) == 3 /* interrupt endpoint */ &&
                       (endpoint->bEndpointAddress & 0x80) != 0 /* in */)
              {
                if (device->interrupt_endpoint == 0xFF)
                {
                  device->interrupt_endpoint = endpoint->bEndpointAddress;
                  device->interrupt_maxpacketsize = endpoint->wMaxPacketSize;
                }
              }
            }
            ptr += bytes_in_this_descriptor;
            bytes_left -= bytes_in_this_descriptor;
          }
          if (device->bulk_in_endpoint == 0xFF ||
              device->bulk_out_endpoint == 0xFF ||
             (device->interrupt_endpoint == 0xFF && interface->bInterfaceProtocol == 0))
          {
            /* Cannot find required endpoint(s) */
            free((char *)device + 4);
            return NULL;
          }
          else
          {
            if (glue_AttachDevice(device, &device->maxlun))
            {
              /* Add to end of device list, so we maintain the USB device number order */
              device->next = NULL;
              for (my_usb_device_t *prev = global_DeviceList; true; prev = prev->next)
              {
                if (prev && !prev->next)
                {
                  prev->next = device;
                  break;
                }
                else if (!prev)
                {
                  global_DeviceList = device;
                  break;
                }
              }
//              glue_ResetDevice(device, 0);
              _swix(OS_RemoveTickerEvent, _INR(0,1),
                    module_scsiregister_handler,
                    global_PrivateWord);
              device->registered = false;
              char *state = getenv("Wimp$State");
              uint32_t delay = global_PopUpDelay;
              if(!delay || !state || strcmp(state,"desktop"))
                 delay = 1; /* Use shortest possible delay when outside the desktop (or if user specified delay of 0!) */
              _swix(OS_CallAfter, _INR(0,2),
                    delay,
                    module_scsiregister_handler,
                    global_PrivateWord);
            }
            else
            {
              /* Error during attach */
              free((char *)device + 4);
            }
            return NULL;
          }
        }
        else
        {
          /* Memory allocation error */
          return NULL;
        }
      }
    }
    ptr += bytes_in_this_descriptor;
    bytes_left -= bytes_in_this_descriptor;
  }
  return NULL; /* not a mass storage device (that we understand) */
}

/*****************************************************************************
* CheckDisconnectedDevice
*
* Vets a device for being one we were using, and if so marks our fake device
* as removed, and informs SCSIDriver
*
* Assumptions
*  NONE
*
* Inputs
*  NONE
*
* Outputs
*  NONE
*
* Returns
*  NULL if successful; otherwise pointer to error block
*****************************************************************************/
static _kernel_oserror *CheckDisconnectedDevice(const char *device_name)
{
  my_usb_device_t *prev = NULL;
  my_usb_device_t *next;
  for (my_usb_device_t *device = global_DeviceList; device != NULL; device = next)
  {
    next = device->next;
    if (strcmp(device->devicefs_name, device_name) == 0)
    {
      device->dying = true; /* no more commands can be started */
      glue_DetachDevice(device);
      DeregisterSCSIDevice(device, device->scsi_driver_handle);
      if (prev == NULL)
      {
        global_DeviceList = next;
      }
      else
      {
        prev->next = next;
      }
      free((char *)device + 4);
    }
    else
    {
      prev = device;
    }
  }
  return NULL;
}

/*****************************************************************************
* RemoveAllDevices
*
* Marks all our fake device as removed, and informs SCSIDriver
*
* Assumptions
*  NONE
*
* Inputs
*  NONE
*
* Outputs
*  NONE
*
* Returns
*  NULL if successful; otherwise pointer to error block
*****************************************************************************/
static _kernel_oserror *RemoveAllDevices(void)
{
  for (my_usb_device_t *device = global_DeviceList; device != NULL; device = global_DeviceList)
  {
    
    device->dying = true;
    glue_DetachDevice(device);
    DeregisterSCSIDevice(device, device->scsi_driver_handle);
    global_DeviceList = device->next;
    char buf[32]; /* *USBReset + sizeof(my_usb_device.devicefs_name) */
    char *p=device->devicefs_name;
    int i;
    for(i=0;i<32;i++)
    {
      if(isalpha(*p))
      {
        buf[i]=*(p++);
      }
      else
      {
        buf[i] = 0;
        break;
      }
    }
    strcat(buf,"Reset ");strcat(buf,p);
    dprintf(("",buf));
    _kernel_oscli(buf);
    free((char *)device + 4);
  }
  return NULL;
}

/*****************************************************************************
* module_SCSIHandler
*
* Entry point from SCSIDriver module
*
* Assumptions
*  NONE
*
* Inputs
*  r:          register block (cmhg actually provides r0-r11)
*  pw:         the 'R12' value
*
* Outputs
*  NONE
*
* Returns
*  NULL if successful; otherwise pointer to error block (or SCSI error number)
*****************************************************************************/
_kernel_oserror *module_SCSIHandler(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror *e = NULL;
  IGNORE(pw);
  switch ( ((int *)r)[11] )
  {
    case 0: /* Features */
      r->r[1] = (1<<1) | (1<<5); /* supports background ops and scatter lists */
      break;
      
    case 1: /* Reset bus */
      e = (_kernel_oserror *)(ErrorNumber_SCSI_SWIunkn & 0xFF); /* shouldn't happen */
      break;
      
    case 2: /* Reset device */
    case 3: /* Abort */
      glue_ResetDevice((my_usb_device_t *)r->r[8], 0);
      break;
      
    case 4: /* Foreground op */
      e = (_kernel_oserror *)(ErrorNumber_SCSI_SWIunkn & 0xFF); /* shouldn't happen */
      break;
      
    case 5: /* Background op */
    {
      my_usb_device_t *device = (my_usb_device_t *)r->r[8];
//      uint32_t lun = (r->r[0] >> 10) & 0x3F;
      uint32_t lun = (r->r[0] >> 5) & 0x7;
      if (lun > device->maxlun)
      {
        e = (_kernel_oserror *)(ErrorNumber_SCSI_NoDevice & 0xFF);
      }
      else
      {
        e = glue_DoCommand(device,
                           lun,
                           r->r[0] & (3 << 24),
                           (char *) r->r[2],
                           r->r[1],
                           (scatter_entry_t *) r->r[3],
                           r->r[4],
                           (void (*)(void)) r->r[6],
                           (void *) r->r[5],
                           (void *) r->r[7]);
        r->r[0] = -1; /* operation still in progress */
      }
      break;
    }
      
    case 6: /* Cancel background operation */
      glue_ResetDevice((my_usb_device_t *)r->r[8], r->r[0] & (1<<11) ? 0 : r->r[0] & (1<<12) ? 1 : 2);
      break;
      
    default: /* Unknown reason code */
      e = (_kernel_oserror *)(ErrorNumber_SCSI_SWIunkn & 0xFF);
      break;
  }
  return e;
}

/*****************************************************************************
* module_TickerVHandler
*
* TickerV/RTSupport handler and callback processor
*
* Assumptions
*  NONE
*
* Inputs
*  r:          register block
*  pw:         the 'R12' value
*
* Outputs
*  NONE
*
* Returns
*  NULL
*****************************************************************************/
_kernel_oserror *module_TickerVHandler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  static bool semaphore = false;
  if (semaphore)
    return NULL;
  semaphore = true;
  my_usb_device_t *device = global_TickerList;
  if(global_CallbackType == callback_RTSupport) /* If we're using TickerV, the RTSupport pollword is kept at 1 so we skip calling glue_BufferThresholdCheck */
    global_RTSupportPollword = 0;
  while (device != NULL)
  {
    my_usb_device_t *next = device->next_ticker; /* read now in case it delinks itself */
    glue_Tick(device);
    device = next;
  }
  semaphore = false;
  return NULL;
}
/*****************************************************************************
* module_UpCallVHandler
*
* UpCallV handler
*
* Assumptions
*  NONE
*
* Inputs
*  r:          register block
*  pw:         the 'R12' value
*
* Outputs
*  NONE
*
* Returns
*  NULL
*****************************************************************************/
_kernel_oserror *module_UpCallVHandler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(pw);
  if (((r->r[0] == 8) || (r->r[0] == 9) /* Buffer filling/emptying */ ) && global_TickerList && !global_RTSupportPollword) glue_BufferThresholdCheck(r->r[1],r->r[0]==8);
  if (!No_New_Stuff && (r->r[0] == 11 /* stream closed */)) glue_ReopenStream(r->r[3]);
  return NULL;
}


/*****************************************************************************
* END OF FILE
*****************************************************************************/
@


1.16
log
@Correct case sensitive compare never matching
In the module post init service call handler SCSIdriver -> SCSIDriver. While a caseless compare would also solve this, the only disc loading copy in RO5x0Hook loads the disc based SCSIDriver first anyway, so there's always a matched set there (as in ROM). Remove unused module post final service call handler too.
module.c: adjust case, remove unused code
modhdr.cmhg: remove unused service call table entry
glue.c: adjust case (of debug/comments)
Makefile: simplified given recent shared makefile improvements, notably the debug flags are now picked up from CDFLAGS/CMHGDFLAGS based on the target
!MkDebug/!MkRam: pass in the target for which the obey file relates rather than 'all'

Version 0.21. Tagged as 'SCSISoftUSB-0_21'
@
text
@d16 2
a17 2
* $Id: module,v 1.15 2013/07/13 17:24:41 rsprowson Exp $
* $Name:  $
d450 1
a450 1
      dprintf(("","Registering scsi device for %x \n",device));
d537 1
a537 1
  dprintf(("","Got scsi device handle %x \n",scsi_driver_handle));
@


1.15
log
@Open and finish fixes
Reorder the open pipe special fields to match those in the USB driver to side step the DeviceFS parsing problem prior to DeviceFS-0_69
Make the upcall handler robust to device streams being shut, see
  http://www.riscosopen.org/forum/forums/3/topics/1970
for the gritty details.

Version 0.18. Tagged as 'SCSISoftUSB-0_18'
@
text
@d16 1
a16 1
* $Id: module,v 1.14 2012/06/03 14:25:56 jlee Exp $
d361 1
a361 1
      if (strcmp((const char *)r->r[2], "SCSIdriver") == 0)
d371 1
a371 1
           1, /* No point using a long delay if SCSIdriver has only just started */
a377 6
    case Service_ModulePostFinal:
      if (strcmp((const char *)r->r[2], "SCSIdriver") == 0)
      {
      }
      break;
      
d431 1
a431 1
  /* Instead of registering the devices directly from this ticker event, register them from a callback. This ensures SCSIdriver's malloc()s can enlarge the RMA if needed. */
@


1.14
log
@Fix temporary RMA corruption while inside RTSupport routine
Detail:
  Previously the RTSupport routine would execute in SYS mode, and use assembler veneers to make direct calls to the buffer manager.
  Despite being against the buffer manager spec (only IRQ or SVC should be used, according to PRM 5a), the buffer manager was coping with SYS mode calls fine. However the buffer manager would call DeviceFS, and DeviceFS would then call USBDriver, entering the module via one of CMHG's generic veneers.
  These veneers attempt to switch to SVC mode on entry, but they do so by only interacting with the bottom two bits of the PSR - so the CPU was remaining in SYS mode.
  Although this isn't a problem in and of itself, immediately after the mode change comes some code to set up the static relocation offsets at the SVC stack limit.
  This is done by aligning the stack pointer to a MB boundary. If we were in SVC mode this would be fine, but since we're still in SYS mode we're using a stack that was allocated by SCSISoftUSB and isn't aligned to a boundary at all; thus resulting in two words of RMA being swapped out with something completely different while the USBDriver code executes.
  With RTSupport in ROM this will most likely end up being the first two words of the heap - which is enough to stop OS_Module from manipulating the heap (the heap manager will see it as corrupt), but without causing any lasting damage.
  To solve this issue we now run the entire routine in SVC mode, using the MB-aligned SVC stack that RTSupport provides for us.
  File changes:
  c/global, c/cmodule, h/global - Get rid of the SYS mode stack since we no longer need it
  c/glue, h/glue - Extern RTSupportWrapper so it can be called from the assembler veneer. Tweak RT_Register parameters to pass in the relocation offsets (and no SYS stack)
  s/asm, h/asm - Added asm_RTSupportWrapper to get us into and out of SVC mode around the call to RTSupportWrapper. Also sets up our stack limit & relocation offsets within the SVC stack.
Admin:
  Tested in BCM2835 ROM


Version 0.16. Tagged as 'SCSISoftUSB-0_16'
@
text
@d16 2
a17 2
* $Id: module,v 1.13 2011/11/27 18:16:08 jlee Exp $
* $Name: HEAD $
d1015 1
a1015 1
  if (r->r[0] == 11 /* stream closed */) glue_ReopenStream(r->r[3]);
@


1.13
log
@Tidy source a bit
Detail:
  Makefile, !MkDebug,fd7 - Rewritten to use makefile fragments
  c/svcprint, h/debug - Removed obsolete svcprint code
  c/module - Collapse MESSAGES option. Use STANDALONE #define instead of ROM_MODULE to decide whether resources are embedded or not.
Admin:
  Tested in softload on Iyonix


Version 0.15. Tagged as 'SCSISoftUSB-0_15'
@
text
@d16 1
a16 1
* $Id: module,v 1.12 2011/07/24 22:09:31 jlee Exp $
d214 1
a214 8
        global_RTSupportStack = calloc(1, RTSTACK_SIZE);
        if(global_RTSupportStack)
        {
          global_UseRTSupport = true;
          global_RTSupportStack->sc_mark = 0xF60690FF;
          global_RTSupportStack->sc_size = RTSTACK_SIZE;
          memcpy(global_RTSupportStack+1,_kernel_current_stack_chunk()+1,28);
        }
a311 2
  if(global_RTSupportStack)
    free(global_RTSupportStack);
@


1.12
log
@Fix null pointer access
Detail:
  c/glue - Not all operations make use of device->current_pipe, but glue_DoCommand was accessing the pipe pointer regardless of whether the maxpacket value was needed or not. This causes the code to fail if zero page is relocated.
  c/global, c/glue, c/module, c/umass, c/umass_quirks, cmhg/modhdr, h/asm, h/global, h/glue, h/resmess, h/umass_quirks, h/umassvar, s/asm - CVS has decided to update all the $Name$ tags. Not entirely sure why, but it probably won't hurt.
Admin:
  Tested on rev C2 BB.


Version 0.14. Tagged as 'SCSISoftUSB-0_14'
@
text
@d16 1
a16 1
* $Id: module,v 1.11 2010/04/22 20:25:18 jlee Exp $
d60 1
a60 1
#define MESSAGES
a86 1

d116 1
a116 2
#ifdef MESSAGES
#ifndef ROM_MODULE
a119 1
#endif
d146 1
a146 3
    
#ifdef MESSAGES
#ifndef ROM_MODULE
a162 1
#endif
a235 1
#ifdef MESSAGES
d238 1
a238 1
#ifndef ROM_MODULE
a241 1
#endif
a324 1
#ifdef MESSAGES
d327 1
a327 1
#ifndef ROM_MODULE
a330 1
#endif
a360 1
#ifdef MESSAGES
a366 1
#endif
@


1.11
log
@Make SCSISoftUSB's 'PopUpDelay' configurable, improve robustness of device registration
Detail:
  c/global, c/module, cmhg/header, h/global - The new command *SCSISoftUSB_PopUpDelay can now be used to control the popup delay value. Additionally, no delay is used if outside the desktop.
  Makefile, Resources/UK/Messages - Added resources file containing text for the new * command
  c/module, cmhg/header - Devices are now registered with SCSISwitch from a callback instead of from a ticker event. This ensures the registration won't fail due to insufficient RMA space (e.g. as is often the case for devices detected during OMAP ROM initialisation)
Admin:
  Tested in ROM on rev C2 beagleboard, and in RAM on Iyonix.
  Messages file needs translating!


Version 0.12. Tagged as 'SCSISoftUSB-0_12'
@
text
@d16 1
a16 1
* $Id: module,v 1.10 2009/10/22 01:19:57 jlee Exp $
@


1.10
log
@Update SCSISoftUSB to use RTSupport where possible, for much better USB performance
Detail:
  On initialisation SCSISoftUSB now checks if a suitable version of the RTSupport module is loaded (0.05 or above), and if so, will use RTSupport in preference to TickerV to schedule USB transfers. When combined with tweaked DeviceFS buffer thresholds and some extra code to listen out for buffer filling/emptying upcalls, this allows for significant performance improvements for USB 2.0 devices.
  If at any point RTSupport becomes unavailable or the RT_Register SWI fails (or if a suitable version of RTSupport is not present) the code will (potentially temporarily) fall back to using TickerV to ensure the filesystem remains functional.
Admin:
  Tested on RISC OS 5.15 rev C2 beagleboard & RISC OS 5.12 Iyonix with & without RTSupport 0.05.


Version 0.11. Tagged as 'SCSISoftUSB-0_11'
@
text
@d16 1
a16 1
* $Id: module,v 1.9 2005/09/20 12:06:57 jballance Exp $
d60 1
a60 5
#undef MESSAGES /* don't need any at the moment */

/* delay after arrival of mass storage device before we tell the scsi system */
/* delay increased to 4 secs from 2 secs in response to beta feedback */
#define PopUpDelay 4*100
d312 1
a312 1
        module_scsiregister_handler,
d392 1
a392 1
           PopUpDelay,                      /* wait n secs */
d442 1
d452 2
a453 1
    _swix(OS_AddCallBack, _INR(0,1),
d458 1
d460 13
a486 1
#if 0
d515 2
a516 2
    case 0:
      for (my_usb_device_t *device = global_DeviceList; device != NULL; device = device->next)
d518 14
a531 13
        printf("%s interface %d alternate %d endpoints %02X %02X %02X using %s protocol"
               " has %d LUN%s and is attached to SCSI handle %p\n",
               device->devicefs_name,
               device->interface,
               device->alternate,
               device->bulk_in_endpoint,
               device->bulk_out_endpoint,
               device->interrupt_endpoint,
               device->protocol == 0x50 ? "bulk-only" :
               device->protocol == 0 ? "CBI (with interrupt)" : "CBI (with no interrupt)",
               device->maxlun + 1,
               device->maxlun == 0 ? "" : "s",
               device);
a532 5
      e = NULL;
      break;
      
    default:
      assert(false /* unserviced star command */);
a536 1
#endif
d770 5
a774 1
              device->registered = false;      
d776 1
a776 1
                    PopUpDelay,                      /* wait n secs */
@


1.9
log
@	tidy up of happenings around pre-reset and shutdown.
Detail:
        some combinations of card readers were causing an abort late in the
	shutdown sequence. this cleans things up
Admin:
        Tested at Castle .. Castle added IP


Version 0.10. Tagged as 'SCSISoftUSB-0_10'
@
text
@d16 2
a17 2
* $Id: module,v 1.8 2005/08/10 23:22:50 jballance Exp $
* $Name:  $
d47 1
d140 2
a141 2
    debug_set_stamp_debug (TRUE);
    debug_set_device(    DEBUGIT_OUTPUT);
d193 43
d322 11
a332 4
  _swix(OS_Release, _INR(0,2),
        TickerV,                                    
        module_tickerv_handler,
        global_PrivateWord);
d969 1
a969 1
* TickerV handler and callback processor
d989 2
a990 1
  if (semaphore) return NULL;
d993 2
d1025 1
@


1.8
log
@	Added Service_PreReset action to ensure module 'silenced'
Detail:
Admin: in test at CTL


Version 0.09. Tagged as 'SCSISoftUSB-0_09'
@
text
@d16 1
a16 1
* $Id: module,v 1.7 2005/06/27 21:27:45 jballance Exp $
d79 1
a79 1

d128 1
d236 1
a236 1
  SearchForDevices();
a259 1
  _kernel_oserror *e = NULL;
a262 1
  
d265 1
d267 10
d279 1
a279 1
        TickerV,
d282 4
a285 18
  _kernel_irqs_on();

  if (!e)
  {
    _swix(OS_RemoveTickerEvent, _INR(0,1),
          module_scsiregister_handler,
          global_PrivateWord);
    _swix(OS_RemoveCallBack, _INR(0,1),
          module_scsiregister_handler,
          global_PrivateWord);
    _swix(OS_RemoveCallBack, _INR(0,1),
          module_callback_from_init,
          global_PrivateWord);
    _swix(OS_Release, _INR(0,2),
          UpCallV,
          module_upcallv_handler,
          global_PrivateWord);
    RemoveAllDevices();
d287 2
a288 2
    _swix(MessageTrans_CloseFile, _IN(0),
          &global_MessageFD);
d290 2
a291 2
    _swix(ResourceFS_DeregisterFiles, _IN(0),
          resmess_ResourcesFiles());
d294 2
a295 2
  }
  return e;
d320 1
d359 1
a359 1
      module_Final(0, 0, pw);
@


1.7
log
@	increase delay prior to scsi register from 2 secs to 4 secs
	as a result of beta site feedback.. certain devices not appearing
	if connected at reboot. (was seen occasionally in local test too).
Detail:
Admin:


Version 0.08. Tagged as 'SCSISoftUSB-0_08'
@
text
@d16 1
a16 1
* $Id: module,v 1.6 2005/06/24 21:03:12 jballance Exp $
d361 4
@


1.6
log
@	Extend device coverage and better startup
Detail:
	now checks any mass storage device for usability .. nolonger
	restricts to types 8-5 and 8-6
	delays scsi registration for 2 seconds beyond point where
	module has finished initialising (overcomes issue seen with some
	devices that fail an inquiry command if sent immediately after
	device is enabled)
Admin:
	castle added IP. tested locally. now a release candidate to
	be checked via the beta software site.


Version 0.07. Tagged as 'SCSISoftUSB-0_07'
@
text
@d16 2
a17 2
* $Id: module,v 1.5 2005/03/05 00:44:42 jballance Exp $
* $Name: SCSISoftUSB-0_06 $
d62 2
a63 1
#define PopUpDelay 2*100
@


1.5
log
@   	Numerous updates to improve working.
	Re-synced with NetBSD mass storage
	Added part sector fill/ignore needed by SCSIFS

Detail:
Admin:  tested at castle.. to go to beta site.. Castle added IP


Version 0.06. Tagged as 'SCSISoftUSB-0_06'
@
text
@d16 2
a17 2
* $Id: module,v 1.4 2003/06/13 12:37:37 bavison Exp $
* $Name: SCSISoftUSB-0_05 $
d61 2
d77 1
a77 1

d129 2
d275 6
d339 3
d344 1
a344 1
          device->scsi_driver_handle = RegisterSCSIDevice(device);
d346 5
d393 28
d505 1
d529 1
d614 1
d622 1
d707 9
a715 2
              glue_ResetDevice(device, 0);
              device->scsi_driver_handle = RegisterSCSIDevice(device);
@


1.4
log
@Added a missing break that was leading to aborts when Service_USB was issued.

Version 0.04. Tagged as 'SCSISoftUSB-0_04'
@
text
@d16 2
a17 2
* $Id: module,v 1.3 2003/06/03 10:46:37 bavison Exp $
* $Name:  $
d34 2
d51 1
a51 1
#include "glue.h"
d81 1
a81 1
static void DeregisterSCSIDevice(void *device, uint32_t scsi_driver_handle);
d128 13
a140 8
  debug_initialise("SCSISoftUSB", "null:", "");
  debug_atexit();
  debug_set_taskname_prefix(false);
  debug_set_area_level_prefix(true);
  debug_set_area_pad_limit(0);
  debug_set_device(NULL_OUTPUT);
  debug_set_raw_device(NULL_OUTPUT);
  debug_set_trace_device(NULL_OUTPUT);
a165 2
    
    e = SearchForDevices();
d229 2
d261 6
a266 7
  for (my_usb_device_t *device = global_TickerList; device != NULL; device = device->next_ticker)
  {
    _swix(OS_Release, _INR(0,2),
          TickerV,
          module_tickerv_handler,
          global_PrivateWord);
  }
d543 1
a543 1
*  NULL if successful; otherwise pointer to error block
d565 9
a573 5
      if (interface->bInterfaceClass == 8 /* mass storage class */ &&
          interface->bInterfaceSubClass == 6 /* SCSI */ &&
         (interface->bInterfaceProtocol == 0 /* control/bulk/interrupt with command completion interrupt */ ||
          interface->bInterfaceProtocol == 1 /* control/bulk/interrupt without command completion interrupt */ ||
          interface->bInterfaceProtocol == 0x50 /* bulk-only */))
d750 1
d755 18
d859 1
a859 1
* TickerV handler
a890 1

@


1.3
log
@  Brought into line with latest version of SCSISoft spec.
Detail:
  * Returns separate error numbers for the different "cancel background
    operation" reasons
  * Reports that it supports scatter lists
  * Debugging output is LF-CR terminated, not CR-LF
Admin:
  Tested briefly.

Version 0.03. Tagged as 'SCSISoftUSB-0_03'
@
text
@d16 1
a16 1
* $Id: module,v 1.2 2003/05/23 18:37:55 bavison Exp $
d351 1
@


1.2
log
@  Various changes to get it up to a releasable standard.
Detail:
  * Unplugging of devices is now reliable.
  * Stall handling now works (requires USBDriver 0.17).
  * We now do max LUN checking, since devices don't seem to do it reliably
    themselves.
  * Unknown SCSI driver handler reason codes now return an error.
  * Scatter list handling improvements - eg individual transfers can now be
    bigger than the DeviceFS buffer size (accounting for the last.
Admin:
  Tested with various mass storage devices.

Version 0.02. Tagged as 'SCSISoftUSB-0_02'
@
text
@d16 1
a16 1
* $Id: module,v 1.1.1.1 2003/05/14 16:49:27 bavison Exp $
d646 1
a646 1
              glue_ResetDevice(device);
d773 1
a773 1
      r->r[1] = 2; /* supports background ops, not foreground ops */
d782 1
a782 1
      glue_ResetDevice((my_usb_device_t *)r->r[8]);
d816 1
a816 1
      glue_ResetDevice((my_usb_device_t *)r->r[8]);
@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
* $Id:  $
d44 1
d691 2
a692 1
  for (my_usb_device_t *device = global_DeviceList; device != NULL; device = device->next)
d694 1
d697 2
d702 1
a702 1
        global_DeviceList = device->next;
d706 1
a706 1
        prev->next = device->next;
a707 1
      glue_DetachDevice(device);
d710 4
a713 1
    prev = device;
d739 2
a742 1
    glue_DetachDevice(device);
d777 1
a777 1
      assert(false /* shouldn't happen */);
d786 1
a786 1
      assert(false /* shouldn't happen */);
d790 22
a811 11
      e = glue_DoCommand((my_usb_device_t *)r->r[8],
                         (r->r[0] >> 10) & 0x3F,
                         r->r[0] & (3 << 24),
                         (char *) r->r[2],
                         r->r[1],
                         (scatter_entry_t *) r->r[3],
                         r->r[4],
                         (void (*)(void)) r->r[6],
                         (void *) r->r[5],
                         (void *) r->r[7]);
      r->r[0] = -1; /* operation still in progress */
d813 1
d817 4
@


1.1.1.1
log
@Initial import of SCSISoftUSB, a driver for USB mass storage devices that
use a SCSI command set over bulk-only or control-bulk-interrupt protocols.
@
text
@@

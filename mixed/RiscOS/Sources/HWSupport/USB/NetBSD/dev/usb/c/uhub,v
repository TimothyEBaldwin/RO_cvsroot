head	1.14;
access;
symbols
	NetBSD-1_19:1.14
	NetBSD-1_18:1.14
	NetBSD-1_17:1.14
	NetBSD-1_16:1.14
	NetBSD-1_15:1.14
	NetBSD-1_14:1.14
	NetBSD-1_13:1.14
	NetBSD-1_12:1.14
	NetBSD-1_09-1:1.14
	NetBSD-1_11:1.14
	NetBSD-1_10:1.14
	NetBSD-1_09:1.14
	NetBSD-1_08:1.14
	NetBSD-1_07:1.14
	NetBSD-1_06:1.14
	NetBSD-1_05:1.14
	NetBSD-1_04:1.14
	NetBSD-1_03:1.14
	NetBSD-1_02:1.14
	NetBSD-1_01:1.14
	NetBSD-1_00:1.14
	NetBSD-0_99:1.14
	NetBSD-0_98:1.14
	NetBSD-0_97:1.14
	NetBSD-0_96:1.14
	NetBSD-0_95:1.14
	NetBSD-0_94:1.14
	NetBSD-0_93:1.14
	NetBSD-0_92:1.14
	NetBSD-0_91:1.14
	NetBSD-0_90:1.14
	NetBSD-0_89:1.14
	NetBSD-0_88:1.14
	NetBSD-0_87:1.14
	NetBSD-0_86:1.14
	NetBSD-0_85:1.14
	NetBSD-0_84:1.14
	NetBSD-0_83:1.14
	NetBSD-0_82:1.14
	NetBSD-0_81:1.14
	NetBSD-0_80:1.14
	NetBSD-0_79:1.14
	NetBSD-0_78:1.14
	NetBSD-0_77:1.14
	NetBSD-0_76:1.14
	NetBSD-0_75:1.14
	NetBSD-0_74:1.14
	NetBSD-0_73:1.14
	NetBSD-0_72:1.14
	NetBSD-0_71:1.14
	NetBSD-0_70:1.13
	NetBSD-0_69:1.13
	NetBSD-0_68:1.13
	NetBSD-0_67:1.13
	NetBSD-0_66:1.13
	NetBSD-0_65:1.13
	NetBSD-0_64:1.13
	NetBSD-0_63:1.13
	NetBSD-0_62:1.13
	NetBSD-0_61:1.13
	NetBSD-0_60:1.13
	NetBSD-0_59:1.13
	NetBSD-0_58:1.12
	NetBSD-0_57:1.12
	NetBSD-0_56:1.12
	NetBSD-0_55:1.12
	NetBSD-0_54:1.12
	NetBSD-0_53:1.12
	NetBSD-0_52:1.12
	NetBSD-0_51:1.12
	NetBSD-0_50:1.12
	NetBSD-0_49:1.12
	NetBSD-0_48:1.12
	NetBSD-0_47:1.12
	NetBSD-0_46:1.12
	NetBSD-0_45:1.12
	NetBSD-0_44:1.12
	NetBSD-0_43:1.12
	NetBSD-0_42:1.12
	NetBSD-0_41:1.12
	NetBSD-0_40:1.12
	NetBSD-0_39:1.12
	NetBSD-0_38:1.11
	NetBSD-0_37:1.11
	NetBSD-0_36:1.11
	NetBSD-0_35:1.11
	NetBSD-0_34:1.10
	NetBSD-0_33:1.10
	NetBSD-0_32:1.9
	NetBSD-0_31:1.9
	NetBSD-0_30:1.8
	NetBSD-0_29:1.8
	RO_5_07:1.8
	NetBSD-0_28:1.8
	NetBSD-0_27:1.7
	NetBSD-0_26:1.7
	NetBSD-0_25:1.6
	NetBSD-0_24:1.5
	NetBSD-0_23:1.5
	NetBSD-0_21-1_22_2_1:1.4
	NetBSD-0_22:1.5
	USB1:1.4.0.2
	NetBSD-0_21:1.4
	NetBSD-0_20:1.4
	NetBSD-0_19:1.4
	NetBSD-0_18:1.4
	NetBSD-0_17:1.4
	NetBSD-0_16:1.3
	NetBSD-0_15:1.2
	NetBSD-0_14:1.2
	NetBSD-0_13:1.2
	NetBSD-0_12:1.2
	NetBSD-0_11:1.1
	NetBSD-0_10:1.1
	NetBSD-0_09:1.1
	NetBSD-0_08:1.1
	NetBSD-0_07:1.1
	NetBSD-0_06:1.1
	NetBSD-0_05:1.1
	NetBSD-0_04:1.1
	NetBSD-0_03:1.1
	NetBSD-0_02:1.1
	NetBSD-0_01:1.1;
locks; strict;
comment	@# @;


1.14
date	2012.06.07.00.11.14;	author jlee;	state Exp;
branches;
next	1.13;
commitid	LkYeKFZjKWlNTH7w;

1.13
date	2011.05.22.20.22.42;	author jlee;	state Exp;
branches;
next	1.12;
commitid	Ye1jVWDlKivFSIkv;

1.12
date	2005.04.24.23.13.53;	author jballance;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.18.00.35.56;	author jballance;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.21.22.30.19;	author jballance;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.30.02.34.20;	author jballance;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.12.14.47.41;	author jballance;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.30.14.50.37;	author kbracey;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.06.15.50.23;	author bavison;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.21.20.49.19;	author bavison;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.23.18.20.46;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.14.16.43.50;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.11.09.17.44;	author rsprowson;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.28.09.55.17;	author dellis;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Make RHENIUM build switch go away. Misc housekeeping
Detail:
  build/Makefile, build/!MkDebug,fd7 - Debug versions of the modules can now be built just by passing "DEBUG=TRUE" to amu
  build/!MkRhenium,fd7 - Deleted obsolete file
  build/Version - Increased version numbers
  build/c/ehcihal, build/c/ehcimodule, build/c/ohcimodule - Only accept USB controllers if HAL_USBControllerInfo says the struct size is an exact match with what we expect. Rework USB controller enumeration to allow modules to properly support both PCI and HAL controllers being available on the same machine, and without RHENIUM switch (module sources only).
  build/c/ehcimodule - Get rid of remaining RHENIUM bits; RHENIUM flag no longer needed for 32bit wide register reads/writes to be supported
  build/c/ohcimodule, build/cmhg/ohcimodhead, dev/usb/c/ohci - Get rid of remaining RHENIUM bits; RHENIUM flag no longer needed for HAL port power controls to be supported.
  build/c/usbhal, build/c/usbmodule, dev/usb/c/uhub, dev/usb/h/usb_port - Get rid of empty riscos_failed_device function
  build/s/call_veneer, build/s/triggercbs - Use Entry/EXIT macros to avoid single-reg LDM/STM performance warnings. Convert tabs to spaces.
  dev/usb/h/usb - Get rid of RHENIUM switch on USB_PORT_RESET_DELAY. Now always uses non-RHENIUM value of 100ms.
Admin:
  Tested on rev A2 BB-xM, Iyonix, Raspberry Pi


Version 0.71. Tagged as 'NetBSD-0_71'
@
text
@/*      $NetBSD: uhub.c,v 1.74 2005/03/02 11:37:27 mycroft Exp $        */
/*	$FreeBSD: src/sys/dev/usb/uhub.c,v 1.18 1999/11/17 22:33:43 n_hibma Exp $	*/

/*
 * Copyright (c) 1998, 2004 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * USB spec: http://www.usb.org/developers/docs/usbspec.zip
 */

#ifdef __riscos
#include <dev/usb/usbhal.h>
#endif
#include <sys/cdefs.h>
//__KERNEL_RCSID(0, "$NetBSD: uhub.c,v 1.74 2005/03/02 11:37:27 mycroft Exp $");

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#if defined(__NetBSD__) || defined(__OpenBSD__)
#include <sys/device.h>
#include <sys/proc.h>
#elif defined(__FreeBSD__)
#include <sys/module.h>
#include <sys/bus.h>
#include "bus_if.h"
#endif

#include <machine/bus.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdivar.h>

#define UHUB_INTR_INTERVAL 255	/* ms */

#ifdef UHUB_DEBUG
#define DPRINTF(x)	if (uhubdebug) logprintf x
#define DPRINTFN(n,x)	if (uhubdebug>(n)) logprintf x
int	uhubdebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x);
#endif

#ifdef __riscos
#define printf logprintf
#endif

struct uhub_softc {
	USBBASEDEVICE		sc_dev;		/* base device */
	usbd_device_handle	sc_hub;		/* USB device */
	usbd_pipe_handle	sc_ipipe;	/* interrupt pipe */
	u_int8_t		sc_status[1];	/* XXX more ports */
	u_char			sc_running;
};
#define UHUB_PROTO(sc) ((sc)->sc_hub->ddesc.bDeviceProtocol)
#define UHUB_IS_HIGH_SPEED(sc) (UHUB_PROTO(sc) != UDPROTO_FSHUB)
#define UHUB_IS_SINGLE_TT(sc) (UHUB_PROTO(sc) == UDPROTO_HSHUBSTT)

Static usbd_status uhub_explore(usbd_device_handle hub);
Static void uhub_intr(usbd_xfer_handle, usbd_private_handle,usbd_status);

#if defined(__FreeBSD__)
Static bus_child_detached_t uhub_child_detached;
#endif


/*
 * We need two attachment points:
 * hub to usb and hub to hub
 * Every other driver only connects to hubs
 */

#if defined(__NetBSD__) || defined(__OpenBSD__)  || defined(__riscos)
USB_DECLARE_DRIVER(uhub);
#if defined __riscos
/* Create the driver instance for the hub connected to hub case */
halconst struct cfattach uhub_uhub_ca = {
        sizeof(struct uhub_softc), uhub_match, uhub_attach,
        uhub_detach, uhub_activate
};
#else
/* Create the driver instance for the hub connected to hub case */
CFATTACH_DECL(uhub_uhub, sizeof(struct uhub_softc),
    uhub_match, uhub_attach, uhub_detach, uhub_activate);
#endif
#elif defined(__FreeBSD__)
USB_DECLARE_DRIVER_INIT(uhub,
			DEVMETHOD(bus_child_detached, uhub_child_detached));

/* Create the driver instance for the hub connected to usb case. */
devclass_t uhubroot_devclass;

Static device_method_t uhubroot_methods[] = {
	DEVMETHOD(device_probe, uhub_match),
	DEVMETHOD(device_attach, uhub_attach),

	/* detach is not allowed for a root hub */
	{0,0}
};

Static	driver_t uhubroot_driver = {
	"uhub",
	uhubroot_methods,
	sizeof(struct uhub_softc)
};

#endif

USB_MATCH(uhub)
{
	USB_MATCH_START(uhub, uaa);
	usb_device_descriptor_t *dd = usbd_get_device_descriptor(uaa->device);

	DPRINTFN(5,("uhub_match, dd=%p\n", dd));
	/*
	 * The subclass for hubs seems to be 0 for some and 1 for others,
	 * so we just ignore the subclass.
	 */
	if (uaa->iface == NULL && dd->bDeviceClass == UDCLASS_HUB)
		return (UMATCH_DEVCLASS_DEVSUBCLASS);
	return (UMATCH_NONE);
}

USB_ATTACH(uhub)
{
	USB_ATTACH_START(uhub, sc, uaa);
	usbd_device_handle dev = uaa->device;
#if !defined(__riscos) || defined(USB_DEBUG)
	char devinfo[1024];
#endif
	usbd_status err;
        struct usbd_hub *hub = NULL;
	usb_device_request_t req;
	usb_hub_descriptor_t hubdesc;
	int p, port, nports, nremov, pwrdly;
	usbd_interface_handle iface;
	usb_endpoint_descriptor_t *ed;
        struct usbd_tt *tts = NULL;

	DPRINTFN(1,("uhub_attach\n"));
	sc->sc_hub = dev;
#if !defined(__riscos) || defined(USB_DEBUG)
        usbd_devinfo(dev, 1, devinfo, sizeof(devinfo));
	USB_ATTACH_SETUP;
        printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);

        if (UHUB_IS_HIGH_SPEED(sc)) {
                printf("%s: %s transaction translator%s\n",
                    USBDEVNAME(sc->sc_dev),
                    UHUB_IS_SINGLE_TT(sc) ? "single" : "multiple",
                       UHUB_IS_SINGLE_TT(sc) ? "" : "s");
        }
#endif
	err = usbd_set_config_index(dev, 0, 1);
	if (err) {
		DPRINTF(("%s: configuration failed, error=%s\n",
			 USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
		USB_ATTACH_ERROR_RETURN;
	}

	if (dev->depth > USB_HUB_MAX_DEPTH) {
                printf("%s: hub depth (%d) exceeded, hub ignored\n",
		       USBDEVNAME(sc->sc_dev), USB_HUB_MAX_DEPTH);
		USB_ATTACH_ERROR_RETURN;
	}

	/* Get hub descriptor. */
	req.bmRequestType = UT_READ_CLASS_DEVICE;
	req.bRequest = UR_GET_DESCRIPTOR;
        USETW2(req.wValue, UDESC_HUB, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, USB_HUB_DESCRIPTOR_SIZE);
	DPRINTFN(1,("usb_init_hub: getting hub descriptor\n"));
#ifdef __riscos
	err = usbd_do_request(dev, &req, (void *)&hubdesc);
#else
	err = usbd_do_request(dev, &req, &hubdesc);
#endif
	nports = hubdesc.bNbrPorts;
	if (!err && nports > 7) {
		USETW(req.wLength, USB_HUB_DESCRIPTOR_SIZE + (nports+1) / 8);
#ifdef __riscos
		err = usbd_do_request(dev, &req, (void *)&hubdesc);
#else
		err = usbd_do_request(dev, &req, &hubdesc);
#endif
	}
	if (err) {
		DPRINTF(("%s: getting hub descriptor failed, error=%s\n",
			 USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
		USB_ATTACH_ERROR_RETURN;
	}

	for (nremov = 0, port = 1; port <= nports; port++)
		if (!UHD_NOT_REMOV(&hubdesc, port))
			nremov++;
        printf("%s: %d port%s with %d removable, %s powered\n",
	       USBDEVNAME(sc->sc_dev), nports, nports != 1 ? "s" : "",
	       nremov, dev->self_powered ? "self" : "bus");

        if (nports == 0) {
                printf("%s: no ports, hub ignored\n", USBDEVNAME(sc->sc_dev));
                goto bad;
        }
	hub = malloc(sizeof(*hub) + (nports-1) * sizeof(struct usbd_port),
		     M_USBDEV, M_NOWAIT);
	if (hub == NULL)
		USB_ATTACH_ERROR_RETURN;
	dev->hub = hub;
	dev->hub->hubsoftc = sc;
	hub->explore = uhub_explore;
	hub->hubdesc = hubdesc;

	DPRINTFN(1,("usbhub_init_hub: selfpowered=%d, parent=%p, "
		    "parent->selfpowered=%d\n",
		 dev->self_powered, dev->powersrc->parent,
		 dev->powersrc->parent ?
		 dev->powersrc->parent->self_powered : 0));

#ifndef __riscos
	if (!dev->self_powered && dev->powersrc->parent != NULL &&
	    !dev->powersrc->parent->self_powered) {
                printf("%s: bus powered hub connected to bus powered hub, "
		       "ignored\n", USBDEVNAME(sc->sc_dev));
		goto bad;
        }
#endif
	/* Set up interrupt pipe. */
	err = usbd_device2interface_handle(dev, 0, &iface);
	if (err) {
                printf("%s: no interface handle\n", USBDEVNAME(sc->sc_dev));
		goto bad;
	}
	ed = usbd_interface2endpoint_descriptor(iface, 0);
	if (ed == NULL) {
                printf("%s: no endpoint descriptor\n", USBDEVNAME(sc->sc_dev));
		goto bad;
	}
	if ((ed->bmAttributes & UE_XFERTYPE) != UE_INTERRUPT) {
                printf("%s: bad interrupt endpoint\n", USBDEVNAME(sc->sc_dev));
		goto bad;
	}

	err = usbd_open_pipe_intr(iface, ed->bEndpointAddress,
		  USBD_SHORT_XFER_OK, &sc->sc_ipipe, sc, sc->sc_status,
		  sizeof(sc->sc_status), uhub_intr, UHUB_INTR_INTERVAL);
	if (err) {
                printf("%s: cannot open interrupt pipe\n",
		       USBDEVNAME(sc->sc_dev));
#ifdef __riscos
                sc->sc_ipipe = NULL;
#endif
                goto bad;
	}

	/* Wait with power off for a while. */
#ifndef __riscos
	usbd_delay_ms(dev, USB_POWER_DOWN_TIME);
#else
        QueryDelay(dev, "USB$PowerDownTime", USB_POWER_DOWN_TIME);
#endif
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, dev, USBDEV(sc->sc_dev));

	/*
	 * To have the best chance of success we do things in the exact same
	 * order as Windoze98.  This should not be necessary, but some
	 * devices do not follow the USB specs to the letter.
	 *
	 * These are the events on the bus when a hub is attached:
	 *  Get device and config descriptors (see attach code)
	 *  Get hub descriptor (see above)
	 *  For all ports
	 *     turn on power
	 *     wait for power to become stable
	 *     then trigger a port explore explicitly
	 * (all below happens in explore code)
	 *  For all ports
	 *     clear C_PORT_CONNECTION
	 *  For all ports
	 *     get port status
	 *     if device connected
	 *        wait 100 ms
	 *        turn on reset
	 *        wait
	 *        clear C_PORT_RESET
	 *        get port status
	 *        proceed with device attachment
	 */

        if (UHUB_IS_HIGH_SPEED(sc)) {
                tts = malloc((UHUB_IS_SINGLE_TT(sc) ? 1 : nports) *
                             sizeof (struct usbd_tt), M_USBDEV, M_NOWAIT);
                if (!tts)
                        goto bad;
        }
	/* Set up data structures */
	for (p = 0; p < nports; p++) {
		struct usbd_port *up = &hub->ports[p];
                up->device = NULL;
		up->parent = dev;
		up->portno = p+1;
		if (dev->self_powered)
			/* Self powered hub, give ports maximum current. */
			up->power = USB_MAX_POWER;
		else
			up->power = USB_MIN_POWER;
                up->restartcnt = 0;
                up->reattach = 0;
                if (UHUB_IS_HIGH_SPEED(sc)) {
                        up->tt = &tts[UHUB_IS_SINGLE_TT(sc) ? 0 : p];
                        up->tt->hub = hub;
                } else {
                        up->tt = NULL;
                }
	}

	/* XXX should check for none, individual, or ganged power? */

	pwrdly = dev->hub->hubdesc.bPwrOn2PwrGood * UHD_PWRON_FACTOR
	    + USB_EXTRA_POWER_UP_TIME;
	for (port = 1; port <= nports; port++) {
		/* Turn the power on. */
		err = usbd_set_port_feature(dev, port, UHF_PORT_POWER);
		if (err)
                        printf("%s: port %d power on failed, %s\n",
			       USBDEVNAME(sc->sc_dev), port,
			       usbd_errstr(err));
		DPRINTF(("usb_init_port: turn on port %d power\n", port));
#ifdef __riscos
	}
#else
	/* Wait for stable power. */
         /* do we really need this?  nothing's going to happen
            until the power is ready anyway, so what's the point in
            waiting? .. think we do ..JB*/
		DPRINTF(("usbhub_init_hub: waiting %dms for port power stable\n", pwrdly));
		usbd_delay_ms(dev, pwrdly);
        }
#endif
        /* The usual exploration will finish the setup. */

        sc->sc_running = 1;

//#ifdef __riscos
//        /* hub now ready for use .. make sure it gets explored */
//	DPRINTF(("usbhub_init_hub: power good: triggering hub explore..\n"));
//	usb_needs_explore(sc->sc_hub);
//#endif
	USB_ATTACH_SUCCESS_RETURN;

 bad:
        if (hub)
	free(hub, M_USBDEV);
        dev->hub = NULL;
	USB_ATTACH_ERROR_RETURN;
}

usbd_status
uhub_explore(usbd_device_handle dev)
{
	usb_hub_descriptor_t *hd = &dev->hub->hubdesc;
	struct uhub_softc *sc = dev->hub->hubsoftc;
	struct usbd_port *up;
	usbd_status err;
	int speed;
	int port;
        int change, status, reconnect;

	DPRINTFN(10, ("uhub_explore dev=%p addr=%d\n", dev, dev->address));

	if (!sc->sc_running)
		return (USBD_NOT_STARTED);

	/* Ignore hubs that are too deep. */
	if (dev->depth > USB_HUB_MAX_DEPTH)
		return (USBD_TOO_DEEP);

	for(port = 1; port <= hd->bNbrPorts; port++) {
		up = &dev->hub->ports[port-1];
		err = usbd_get_port_status(dev, port, &up->status);
		if (err) {
			DPRINTF(("uhub_explore: get port status failed, "
				 "error=%s\n", usbd_errstr(err)));
			continue;
		}
		status = UGETW(up->status.wPortStatus);
		change = UGETW(up->status.wPortChange);
                reconnect = up->reattach;
                up->reattach = 0;
                DPRINTFN(3,("uhub_explore: %s port %d status 0x%04x 0x%04x\n",
			    USBDEVNAME(sc->sc_dev), port, status, change));
		if (change & UPS_C_PORT_ENABLED) {
                        DPRINTF(("uhub_explore: C_PORT_ENABLED\n"));
			usbd_clear_port_feature(dev, port, UHF_C_PORT_ENABLE);
                        if (change & UPS_C_CONNECT_STATUS) {
                                /* Ignore the port error if the device
                                   vanished. */
                        } else if (status & UPS_PORT_ENABLED) {
                                printf("%s: illegal enable change, port %d\n",
				       USBDEVNAME(sc->sc_dev), port);
			} else {
				/* Port error condition. */
				if (up->restartcnt) /* no message first time */
                                        printf("%s: port error, restarting "
					       "port %d\n",
					       USBDEVNAME(sc->sc_dev), port);

				if (up->restartcnt++ < USBD_RESTART_MAX)
					goto disco;
				else
#ifdef __riscos
				{
					logprintf("%s: port error, giving up "
					       "port %d\n",
					       USBDEVNAME(sc->sc_dev), port);
					usbd_clear_port_feature(dev, port, UHF_PORT_POWER);
					logprintf("%s: port error: power down "
					       "port %d\n",
					       USBDEVNAME(sc->sc_dev), port);
					usbd_delay_ms(dev, USB_PORT_POWER_DOWN_TIME);
					usbd_set_port_feature(dev, port, UHF_PORT_POWER);
					logprintf("%s: port error: power up "
					       "port %d\n",
					       USBDEVNAME(sc->sc_dev), port);
					int pwrdly = dev->hub->hubdesc.bPwrOn2PwrGood
					             * UHD_PWRON_FACTOR
					    + USB_EXTRA_POWER_UP_TIME;
					logprintf("%s: port error: delay %d ms on  "
					       "port %d\n",
					        USBDEVNAME(sc->sc_dev),
					        pwrdly,
					        port);
					usbd_delay_ms(dev, pwrdly);
						return (USBD_NORMAL_COMPLETION);
				}
#else
                                        printf("%s: port error, giving up "
					       "port %d\n",
					       USBDEVNAME(sc->sc_dev), port);
#endif
			}
		}
                if (!reconnect && !(change & UPS_C_CONNECT_STATUS)) {
			DPRINTFN(3,("uhub_explore: port=%d !C_CONNECT_"
				    "STATUS\n", port));
			/* No status change, just do recursive explore. */
			if (up->device != NULL && up->device->hub != NULL)
				up->device->hub->explore(up->device);
#if 0 && defined(DIAGNOSTIC)
			if (up->device == NULL &&
			    (status & UPS_CURRENT_CONNECT_STATUS))
                                printf("%s: connected, no device\n",
				       USBDEVNAME(sc->sc_dev));
#endif
			continue;
		}

		/* We have a connect status change, handle it. */

                DPRINTF(("uhub_explore: status change hub=%d port=%d\n",
                         dev->address, port));
		usbd_clear_port_feature(dev, port, UHF_C_PORT_CONNECTION);
		/*usbd_clear_port_feature(dev, port, UHF_C_PORT_ENABLE);*/
		/*
		 * If there is already a device on the port the change status
		 * must mean that is has disconnected.  Looking at the
		 * current connect status is not enough to figure this out
		 * since a new unit may have been connected before we handle
		 * the disconnect.
		 */
	disco:
		if (up->device != NULL) {
			/* Disconnected */
                        DPRINTF(("uhub_explore: device addr=%d disappeared "
				 "on port %d\n", up->device->address, port));
			usb_disconnect_port(up, USBDEV(sc->sc_dev));
			usbd_clear_port_feature(dev, port,
						UHF_C_PORT_CONNECTION);
		}
		if (!(status & UPS_CURRENT_CONNECT_STATUS)) {
			/* Nothing connected, just ignore it. */
			DPRINTFN(3,("uhub_explore: port=%d !CURRENT_CONNECT"
				    "_STATUS\n", port));
			continue;
		}

		/* Connected */

		if (!(status & UPS_PORT_POWER))
                        printf("%s: strange, connected port %d has no power\n",
			       USBDEVNAME(sc->sc_dev), port);

		/* Wait for maximum device power up time. */
		#ifndef __riscos
		usbd_delay_ms(dev,USB_PORT_POWERUP_DELAY); 
		#else
                QueryDelay(dev, "USB$PortPowerUpDelay", USB_PORT_POWERUP_DELAY);
                #endif
                
		/* Reset port, which implies enabling it. */
		if (usbd_reset_port(dev, port, &up->status)) {
                        printf("%s: port %d reset failed\n",
			       USBDEVNAME(sc->sc_dev), port);
			continue;
		}
		/* Get port status again, it might have changed during reset */
		err = usbd_get_port_status(dev, port, &up->status);
		if (err) {
			DPRINTF(("uhub_explore: get port status failed, "
				 "error=%s\n", usbd_errstr(err)));
			continue;
		}
		status = UGETW(up->status.wPortStatus);
		change = UGETW(up->status.wPortChange);
		if (!(status & UPS_CURRENT_CONNECT_STATUS)) {
			/* Nothing connected, just ignore it. */
#ifdef DIAGNOSTIC
                        printf("%s: port %d, device disappeared after reset\n",
			       USBDEVNAME(sc->sc_dev), port);
#endif
			continue;
		}

#if 0
                if (UHUB_IS_HIGH_SPEED(sc) && !(status & UPS_HIGH_SPEED)) {
                        printf("%s: port %d, transaction translation not "
                            "implemented, low/full speed device ignored\n",
                               USBDEVNAME(sc->sc_dev), port);
                        continue;
                }
#endif


#ifdef __riscos
                /* experiencing trouble getting first descriptor, give a bit
                   of a delay for device to settle */
                QueryDelay(dev, "USB$PortStartupDelay", USB_PORT_STARTUP_DELAY);
#endif

		/* Figure out device speed */
		if (status & UPS_HIGH_SPEED)
			speed = USB_SPEED_HIGH;
		else if (status & UPS_LOW_SPEED)
			speed = USB_SPEED_LOW;
		else
			speed = USB_SPEED_FULL;
		/* Get device info and set its address. */
		err = usbd_new_device(USBDEV(sc->sc_dev), dev->bus,
			  dev->depth + 1, speed, port, up);
		/* XXX retry a few times? */
		if (err) {
			DPRINTFN(-1,("uhub_explore: usb_new_device failed, "
				     "error=%s\n", usbd_errstr(err)));
			/* Avoid addressing problems by disabling. */
			/* usbd_reset_port(dev, port, &up->status); */

			/*
			 * The unit refused to accept a new address, or had
			 * some other serious problem.  Since we cannot leave
			 * at 0 we have to disable the port instead.
			 */
                        printf("%s: device problem, disabling port %d\n",
			       USBDEVNAME(sc->sc_dev), port);
			usbd_clear_port_feature(dev, port, UHF_PORT_ENABLE);
		} else {
			/* The port set up succeeded, reset error count. */
			up->restartcnt = 0;

			if (up->device->hub)
				up->device->hub->explore(up->device);
		}
	}
	return (USBD_NORMAL_COMPLETION);
}
#ifndef __riscos
#if defined(__NetBSD__) || defined(__OpenBSD__) 
int
uhub_activate(device_ptr_t self, enum devact act)
{
	struct uhub_softc *sc = (struct uhub_softc *)self;
	struct usbd_hub *hub = sc->sc_hub->hub;
	usbd_device_handle dev;
	int nports, port, i;

	switch (act) {
	case DVACT_ACTIVATE:
		return (EOPNOTSUPP);

	case DVACT_DEACTIVATE:
		if (hub == NULL) /* malfunctioning hub */
			break;
		nports = hub->hubdesc.bNbrPorts;
		for(port = 0; port < nports; port++) {
			dev = hub->ports[port].device;
			if (dev != NULL && dev->subdevs != NULL) {
				for (i = 0; dev->subdevs[i] != NULL; i++)
					config_deactivate(dev->subdevs[i]);
			}
		}
		break;
	}
	return (0);
}
#endif
#endif

/*
 * Called from process context when the hub is gone.
 * Detach all devices on active ports.
 */
USB_DETACH(uhub)
{
	USB_DETACH_START(uhub, sc);
	struct usbd_hub *hub = sc->sc_hub->hub;
	struct usbd_port *rup;
	int port, nports;

#if defined(__NetBSD__) || defined(__OpenBSD__)
	DPRINTF(("uhub_detach: sc=%p flags=%d\n", sc, flags));
#elif defined(__FreeBSD__)
	DPRINTF(("uhub_detach: sc=%port\n", sc));
#endif

        if (hub == NULL)                /* Must be partially working */
		return (0);

#ifdef __riscos
        if (sc->sc_ipipe)
        {
#endif
	usbd_abort_pipe(sc->sc_ipipe);
	usbd_close_pipe(sc->sc_ipipe);
#ifdef __riscos
        }
#endif

	nports = hub->hubdesc.bNbrPorts;
	for(port = 0; port < nports; port++) {
		rup = &hub->ports[port];
		if (rup->device)
			usb_disconnect_port(rup, self);
	}

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_hub,
			   USBDEV(sc->sc_dev));

        if (hub->ports[0].tt)
                free(hub->ports[0].tt, M_USBDEV);
	free(hub, M_USBDEV);
	sc->sc_hub->hub = NULL;

	return (0);
}

#if defined(__FreeBSD__)
/* Called when a device has been detached from it */
Static void
uhub_child_detached(device_t self, device_t child)
{
       struct uhub_softc *sc = device_get_softc(self);
	usbd_device_handle devhub = sc->sc_hub;
	usbd_device_handle dev;
	int nports;
	int port;
	int i;

       if (!devhub->hub)
               /* should never happen; children are only created after init */
               panic("hub not fully initialised, but child deleted?");

	nports = devhub->hub->hubdesc.bNbrPorts;
	for (port = 0; port < nports; port++) {
		dev = devhub->hub->ports[port].device;
		if (dev && dev->subdevs) {
			for (i = 0; dev->subdevs[i]; i++) {
				if (dev->subdevs[i] == child) {
                                       dev->subdevs[i] = NULL;
                                       return;
			}
		}
	}
	}
}
#endif



/*
 * Hub interrupt.
 * This an indication that some port has changed status.
 * Notify the bus event handler thread that we need
 * to be explored again.
 */
void
uhub_intr(usbd_xfer_handle xfer, usbd_private_handle addr, usbd_status status)
{
	struct uhub_softc *sc = addr;

	DPRINTFN(5,("uhub_intr: sc=%p\n", sc));
	if (status == USBD_STALLED)
		usbd_clear_endpoint_stall_async(sc->sc_ipipe);
	else if (status == USBD_NORMAL_COMPLETION)
		usb_needs_explore(sc->sc_hub);
}

#if defined(__FreeBSD__)
DRIVER_MODULE(uhub, usb, uhubroot_driver, uhubroot_devclass, 0, 0);
DRIVER_MODULE(uhub, uhub, uhub_driver, uhub_devclass, usbd_driver_load, 0);
#endif
@


1.13
log
@Add the ability to build the USB drivers as HAL-compatible static libraries
Detail:
  build/Makefile, build/OBJEHCIDriver, build/OBJOHCIDriver, build/OBJUSBDriver - Modified makefiles to build the HAL libs during the export libs phase
  build/!MkHAL,fd7 - Handy script for building the HAL libs
  build/Hdr/usbhal - Header containing definitions for the assembler code. Also gets exported so that HALs know how much workspace to reserve.
  build/c/usbhal - HAL version of usbmodule.c & port.c. Also contains the keyboard scan code, adapted from the code in the Tungsten HAL.
  build/s/porthal - Assembler versions of some port.c routines that were easier to do in assembler than C
  build/s/halheap - OS_Heap code that's been adapted for use in the HAL. Could easily be changed into a standalone library instead of being part of the HAL USB libs. Supports memory-efficient allocation of aligned blocks.
  build/c/ehcihal - HAL version of ehcimodule.c. Currently only supports EHCI controllers exposed via HAL_USBControllerInfo (i.e. no PCI support)
  build/c/ehcimodule, build/c/ohcimodule, build/c/port - Moved riscos_irq_clear into port.c. Removed unused microtime() function.
  build/c/usbmouse - Strip out some debug-related code in non-debug builds
  build/Version - Updated version numbers
  dev/usb/c/ehci, dev/usb/h/ehcivar - Adapted to add support for the HAL build. Apart from the base changes, the code has also been tweaked to significantly reduce the amount of memory used at runtime by the HAL version of the driver.
  dev/usb/c/hid, dev/usb/c/uhub, dev/usb/c/usb, dev/usb/c/usb_quirks, dev/usb/c/usb_subr, dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/c/usbroothub_subr - Changes to support HAL builds. Mainly disabling bits that won't work in the HAL or disabling bits for RISC OS in general if they weren't being used in the first place.
  dev/usb/c/ohci, dev/usb/h/ohcivar - Basic changes to support HAL builds. However HAL OHCI support is still incomplete.
  dev/usb/h/usb_port - Added support for the HAL build. Also tweaked logprintf definition to get rid of logprintf calls entirely in non-debug builds.
  dev/usb/h/usbdivar - Added support for the HAL build.
  dev/usb/h/usbhal - New header used by the HAL build. Gets included by every C file to ensure the compiler doesn't use sb, and contains structs/macros to allow access to the shared workspace.
Admin:
  HAL & non-HAL builds tested on rev C2 BB, rev A2 BB-xM, rev C1 TouchBook.
  Non-HAL builds tested with Iyonix ROM softload.
  Needs latest Kernel source for OSEntries.h export.


Version 0.59. Tagged as 'NetBSD-0_59'
@
text
@a602 3
#ifdef __riscos
			riscos_failed_device (&sc->sc_dev);
#endif
@


1.12
log
@	Update of NetBSD elements (except c.ohci) to track NetBSD current
	from mid April 2005.
	Inclusion of Mods to c.ehci (from Dan) to correctly handle low
	speed interrupt devices beyond USB2 hubs (i.e. keyboards and mice).
	Mod to EHCI resetting in service call handler to better cope with
	USBDriver being restarted 'underneath' it.
Detail:
Admin:
	Castle, Dan Ellis, NetBSD added IP. Tested at Castle. Will be
	beta tested at this revision level before full release.


Version 0.39. Tagged as 'NetBSD-0_39'
@
text
@d45 3
d115 1
a115 1
struct cfattach uhub_uhub_ca = {
d166 1
d168 1
d180 1
d191 1
@


1.11
log
@         changes and bug fixes that came to light following USB2 launch.
Detail:
         - VarVal launching.. string length was incorrectly calculated.
         - USB VarVals now correctly cleared if device failed during
           enumeration, after first SetVarVal call.
         - Triggercbs() modified to check interrupt context and be
           refuse (quietly) to trigger callbacks if interrupts threaded
           (result of possible issue .. but perhaps wise)
         - Added third QueryDelay variable, and an Info file to describe
           what does what.
Admin:
         checked at Castle.. due for extended check via beta test site
         before formal release.

         Castle + D Ellis added IP


Version 0.35. Tagged as 'NetBSD-0_35'
@
text
@d1 1
a1 1
/*      $NetBSD: uhub.c,v 1.71 2004/10/26 05:00:59 augustss Exp $       */
d5 1
a5 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
d46 1
a46 1
//__KERNEL_RCSID(0, "$NetBSD: uhub.c,v 1.71 2004/10/26 05:00:59 augustss Exp $");
d339 1
d398 1
a398 1
	int change, status;
d419 2
d474 1
a474 1
		if (!(change & UPS_C_CONNECT_STATUS)) {
@


1.10
log
@        Stack brought up to date with NetBSD sources as at 20050121.
        USB2 further debugged.
Detail:
        Check in prior to second beta release. Improvements also to
        softloading of replacement modules.
Admin:
        Checked with JB .. further crosschecking is still needed for rhenium.
        Castle/D Ellis added ip from NetBSD sources


Version 0.33. Tagged as 'NetBSD-0_33'
@
text
@d360 2
a361 3
        }
#endif

d366 2
a367 3
	DPRINTF(("usbhub_init_hub: waiting %dms for port power stable\n", pwrdly));
        usbd_delay_ms(dev, pwrdly);
#ifndef __riscos
d374 5
a378 5
#ifdef __riscos
        /* hub now ready for use .. make sure it gets explored */
	DPRINTF(("usbhub_init_hub: power good: triggering hub explore..\n"));
	usb_needs_explore(sc->sc_hub);
#endif
d565 1
a565 1
                usbd_delay_ms (dev, 100);
@


1.9
log
@        Update of EHCIDriver to current NetBSD, together with needed changes
        in both OHCIDriver and USBDriver.


Detail:
        Code may change before formal release .. will be beta released
        ... Entered to CVS to get new version numbers, and for
        the record.
Admin:
        Castle/netbsd added IP .. will be tested more fully before
        formal release. Still to be verified on Rhenium.


Version 0.31. Tagged as 'NetBSD-0_31'
@
text
@d76 5
a80 1
#define DPRINTFN(n,x)
d177 1
a177 1
	logprintf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);
d180 1
a180 1
                DPRINTF(("%s: %s transaction translator%s\n",
d183 1
a183 1
                       UHUB_IS_SINGLE_TT(sc) ? "" : "s"));
d193 1
a193 1
		logprintf("%s: hub depth (%d) exceeded, hub ignored\n",
d228 1
a228 1
	logprintf("%s: %d port%s with %d removable, %s powered\n",
d233 1
a233 1
                DPRINTF(("%s: no ports, hub ignored\n", USBDEVNAME(sc->sc_dev)));
d254 1
a254 1
		logprintf("%s: bus powered hub connected to bus powered hub, "
d262 1
a262 1
		logprintf("%s: no interface handle\n", USBDEVNAME(sc->sc_dev));
d267 1
a267 1
		logprintf("%s: no endpoint descriptor\n", USBDEVNAME(sc->sc_dev));
d271 1
a271 1
		logprintf("%s: bad interrupt endpoint\n", USBDEVNAME(sc->sc_dev));
d279 1
a279 1
		logprintf("%s: cannot open interrupt pipe\n",
d355 1
a355 1
			logprintf("%s: port %d power on failed, %s\n",
d429 1
a429 1
                                logprintf("%s: illegal enable change, port %d\n",
d434 1
a434 1
					logprintf("%s: port error, restarting "
d482 1
a482 1
				logprintf("%s: connected, no device\n",
d490 2
a491 2
                DPRINTFN(-1,("uhub_explore: status change hub=%d port=%d status=%x:%x\n",
                         dev->address, port,up->status, usbd_get_port_status(dev, port, &up->status)));
d520 1
a520 1
			logprintf("%s: strange, connected port %d has no power\n",
d532 1
a532 1
			logprintf("%s: port %d reset failed\n",
d548 1
a548 1
			logprintf("%s: port %d, device disappeared after reset\n",
d556 1
a556 1
                        DPRINTF(("%s: port %d, transaction translation not "
d558 1
a558 1
                            USBDEVNAME(sc->sc_dev), port));
d592 1
a592 1
			logprintf("%s: device problem, disabling port %d\n",
@


1.8
log
@  Extensive changes and bug fixes to usb and ohci ..
  'blocked' several holes that could cause freezes with awkward
  usb devices.  Added latest changes from Dan Ellis too , especially for USB2
Detail:
 many
Admin:
 Tested in ROM at Castle, and beta tested with users


Version 0.28. Tagged as 'NetBSD-0_28'
@
text
@d1 1
a1 1
/*	$NetBSD: uhub.c,v 1.62 2002/10/02 16:53:16 thorpej Exp $	*/
d42 1
a42 1
 * USB spec: http://www.usb.org/developers/data/usbspec.zip
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: uhub.c,v 1.62 2002/10/02 16:53:16 thorpej Exp $");
d86 3
d104 1
a104 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d106 7
a112 1

d116 1
a136 2
#elif defined(__riscos)
USB_DECLARE_DRIVER(uhub);
a137 5
/* Create the driver instance for the hub connected to hub case */
struct cfattach uhub_uhub_ca = {
        sizeof(struct uhub_softc), uhub_match, uhub_attach,
        uhub_detach, uhub_activate
};
d161 1
a161 1
	struct usbd_hub *hub;
d167 1
d175 6
d201 1
d203 3
d209 1
d211 3
d228 4
d253 1
a254 1

d277 1
d279 1
d284 1
a284 1
	#ifndef __riscos
d286 1
a286 1
	#else
d288 1
a288 1
        #endif
d317 6
d326 1
a326 1
		up->device = 0;
d335 6
d355 1
d357 2
a358 1
	
d365 3
d372 1
d376 1
a376 1

d380 1
d382 1
a382 1
	dev->hub = 0;
d421 5
a425 2
			if (status & UPS_PORT_ENABLED) {
				logprintf("%s: illegal enable change, port %d\n",
d436 3
a438 1
				else{
d455 4
a458 2
					       "port %d\n", pwrdly,
					       USBDEVNAME(sc->sc_dev), port);
d462 5
a468 4
#ifdef __riscos0
                /* respond to resets as well */
		if (!(change & (UPS_C_CONNECT_STATUS | UPS_C_PORT_RESET))) {
#else
a469 1
#endif
d550 10
d591 1
d593 1
d604 2
a605 2

#if defined(__NetBSD__) || defined(__OpenBSD__)
d634 1
d656 1
d659 1
d662 1
d664 1
d676 2
d690 5
a694 5
       usbd_device_handle devhub = sc->sc_hub;
       usbd_device_handle dev;
       int nports;
       int port;
       int i;
d700 6
a705 6
       nports = devhub->hub->hubdesc.bNbrPorts;
       for (port = 0; port < nports; port++) {
               dev = devhub->hub->ports[port].device;
               if (dev && dev->subdevs) {
                       for (i = 0; dev->subdevs[i]; i++) {
                               if (dev->subdevs[i] == child) {
d708 4
a711 4
                               }
                       }
               }
       }
d714 1
@


1.7
log
@Latest stuff from John - mainly Rhenium improvements.

Version 0.26. Tagged as 'NetBSD-0_26'
@
text
@d167 1
a167 1
	usbd_devinfo(dev, 1, devinfo);
d255 2
a256 1
		goto bad;
d260 1
d262 3
a264 1

d278 1
d304 1
d319 15
a333 12
		/* Wait for stable power. */
#ifndef __riscos
                /* do we really need this?  nothing's going to happen
                   until the power is ready anyway, so what's the point in
                   waiting? */
		usbd_delay_ms(dev, pwrdly);
#endif
	}

	/* The usual exploration will finish the setup. */

	sc->sc_running = 1;
d373 1
a373 1
		DPRINTFN(3,("uhub_explore: %s port %d status 0x%04x 0x%04x\n",
d376 1
a376 1
			DPRINTF(("uhub_explore: C_PORT_ENABLED\n"));
d390 1
a390 1
				else
d394 18
d436 2
a437 2
		DPRINTF(("uhub_explore: status change hub=%d port=%d\n",
			 dev->address, port));
d450 1
a450 1
			DPRINTF(("uhub_explore: device addr=%d disappeared "
d470 6
a475 2
		usbd_delay_ms(dev, USB_PORT_POWERUP_DELAY);

d590 1
a590 1
	if (hub == NULL || !sc->sc_ipipe)	/* Must be partially working */
d593 2
d597 1
@


1.6
log
@  New versions from John.
Detail:
  * All modules will now rmkill/rmload more reliably
  * Keyboard driver disables kernel debounce on new enough kernels, needed
    for many PS2-USB adaptors, bar code scanners etc
  * Mouse driver will scroll wheel scroll any windows that do respond to
    scroll events, otherwise it issues PointerReason_WheelChange (9) to an
    external WimpScroll module
  * Several bugs and an interrupt hole resolved
Admin:
  Tested at Framlingham.

Version 0.25. Tagged as 'NetBSD-0_25'
@
text
@d559 1
a559 1
	if (hub == NULL)		/* Must be partially working */
@


1.5
log
@Merge of Dan Ellis's USB2 sources.

Version 0.22. Tagged as 'NetBSD-0_22'
@
text
@d187 1
a187 1
	USETW(req.wValue, 0);
d500 1
@


1.4
log
@Added new CallDevice reason code (&80000005) to clear a stall condition on
a pipe with a given FileSwitch handle
New usbdevs and usbdevs_data from NetBSD
Rewrote power source detection to skirt round dodgy devices which say
they're self powered,set MaxPower=0,and don't respond to a getstatus()
Copes better with devices being unplugged while a transfer using them is active

Version 0.17. Tagged as 'NetBSD-0_17'
@
text
@d1 1
a1 1
/*	$NetBSD: uhub.c,v 1.45 2000/06/01 14:29:00 augustss Exp $	*/
d42 1
a42 1
 * USB spec: http://www.usb.org/developers/docs.htm
d45 3
d101 1
a101 1
#if defined(__NetBSD__) || defined(__OpenBSD__) || defined(__riscos)
d105 2
a106 4
struct cfattach uhub_uhub_ca = {
	sizeof(struct uhub_softc), uhub_match, uhub_attach,
	uhub_detach, uhub_activate
};
d127 2
a128 1
#endif
d130 5
a134 4
#if defined(__riscos) && defined(HUB_VENEER)
/* we need an entry point for the interrupt */
extern void uhub_intr_entry(usbd_xfer_handle, usbd_private_handle,
			      usbd_status);
d169 1
a169 1
	DPRINTF(("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo));
d179 2
a180 2
		DPRINTF(("%s: hub depth (%d) exceeded, hub ignored\n",
		       USBDEVNAME(sc->sc_dev), USB_HUB_MAX_DEPTH));
d206 1
a206 1
	DPRINTF(("%s: %d port%s with %d removable, %s powered\n",
d208 1
a208 1
	       nremov, dev->self_powered ? "self" : "bus"));
d225 1
a225 2
/* allow RISC OS to chain self powered hubs */
#if !defined(__riscos)
d228 2
a229 2
		DPRINTF(("%s: bus powered hub connected to bus powered hub, "
		       "ignored\n", USBDEVNAME(sc->sc_dev)));
a230 1
	}
d236 1
a236 1
		DPRINTF(("%s: no interface handle\n", USBDEVNAME(sc->sc_dev)));
d241 1
a241 1
		DPRINTF(("%s: no endpoint descriptor\n", USBDEVNAME(sc->sc_dev)));
d245 1
a245 1
		DPRINTF(("%s: bad interrupt endpoint\n", USBDEVNAME(sc->sc_dev)));
a248 5
#if defined(__riscos) && defined(HUB_VENEER)
	err = usbd_open_pipe_intr(iface, ed->bEndpointAddress,
		  USBD_SHORT_XFER_OK, &sc->sc_ipipe, sc, sc->sc_status,
		  sizeof(sc->sc_status), uhub_intr_entry, UHUB_INTR_INTERVAL);
#else
a251 1
#endif
d253 2
a254 2
		DPRINTF(("%s: cannot open interrupt pipe\n",
		       USBDEVNAME(sc->sc_dev)));
d280 1
d309 1
a309 1
			DPRINTF(("%s: port %d power on failed, %s\n",
d311 1
a311 1
			       usbd_errstr(err)));
d341 1
d364 2
a365 2
		DPRINTFN(3,("uhub_explore: port %d status 0x%04x 0x%04x\n",
			    port, status, change));
d370 2
a371 2
				DPRINTF(("%s: illegal enable change, port %d\n",
				       USBDEVNAME(sc->sc_dev), port));
d375 1
a375 1
					DPRINTF(("%s: port error, restarting "
d377 1
a377 1
					       USBDEVNAME(sc->sc_dev), port));
d382 1
a382 1
					DPRINTF(("%s: port error, giving up "
d384 1
a384 1
					       USBDEVNAME(sc->sc_dev), port));
d387 1
a387 1
#ifdef __riscos
d398 6
a410 4
#ifdef __riscos
		usbd_clear_port_feature(dev, port, UHF_C_PORT_CONNECTION);
		usbd_clear_port_feature(dev, port, UHF_C_PORT_RESET);
#else
a411 1
#endif
d439 2
a440 8
			DPRINTF(("%s: strange, connected port %d has no power\n",
			       USBDEVNAME(sc->sc_dev), port));

#ifdef __riscos
		if (--up->restartcnt < 0) up->restartcnt = 0;
#else
		up->restartcnt = 0;
#endif
d447 2
a448 2
			DPRINTF(("%s: port %d reset failed\n",
			       USBDEVNAME(sc->sc_dev), port));
d463 2
a464 2
			DPRINTF(("%s: port %d, device disappeared after reset\n",
			       USBDEVNAME(sc->sc_dev), port));
d475 7
d484 1
a484 2
			  dev->depth + 1, status & UPS_LOW_SPEED,
			  port, up);
d497 2
a498 2
			DPRINTF(("%s: device problem, disabling port %d\n",
			       USBDEVNAME(sc->sc_dev), port));
a499 6
			/* Make sure we don't try to restart it infinitely. */
#ifdef __riscos
			up->restartcnt++;
#else
			up->restartcnt = USBD_RESTART_MAX;
#endif
d501 3
a522 1
		break;
d533 2
a534 1
			}		}
d627 1
a627 1
		usb_needs_explore(sc->sc_hub->bus);
@


1.3
log
@  Support for SCSISoftUSB, and some tidying up.
Detail:
  * Errors now use the allocated error number base, &819000, instead of a
    base in the private range, &50000000. "USB transfer failed" errors now
    have use a sub-range of error numbers from &819020; the original BSD
    error number can be retrieved from the bottom 5 bits of the RISC OS
    error number.
  * Service_USB 1 now returns the list in the order in which the devices,
    rather than in the reverse order as previous versions of the module did.
  * A little tweaking of h/usb_port to reduce compiler warnings.
  * Some compiler-satisfying changes to allow use of packed structures.
    (However, the compiler doesn't seem to work correctly yet, so this is
    currently switched out using -DDISABLE_PACKED on the command line.)
  * Added full stops to end of star command help strings for consistency
    with rest of OS.
  * New exports: USBDevFS (moved here from ^.h) and a few files in dev/usb/h
    and sys/h.
Admin:
  Error number overhaul and new exports are both required by SCSISoftUSB.

Version 0.16. Tagged as 'NetBSD-0_16'
@
text
@d480 1
a480 1
//                usbd_delay_ms (dev, 100);
@


1.2
log
@Nicked a few hub related fixes from later NetBSD versions.
Added stuff to delete the DeviceFS$USB*$Options variables when the module is
RMkilled.

Version 0.12. Tagged as 'NetBSD-0_12'
@
text
@d188 1
a188 1
	err = usbd_do_request(dev, &req, &hubdesc);
d192 1
a192 1
		err = usbd_do_request(dev, &req, &hubdesc);
@


1.1
log
@Import of USB driver suitable for generic PCI based OHCI controllers.
Correction of spelling of busses to buses (noun plural).
OHCIdriver only responds to PCI service call to lookup vendor name when
the device is of class OHCI controller.

Version 0.01. Tagged as 'NetBSD-0_01'
@
text
@d70 1
a70 1
int	uhubdebug;
d377 1
a377 1
				if (up->restartcnt++ < USBD_RESTART_MAX) {
d381 2
d384 1
a384 1
				} else {
a387 1
				}
d399 1
a399 1
			if (up->device && up->device->hub)
d455 19
a473 2
			DPRINTF(("uhub_explore: port=%d reset failed\n",
				 port));
d536 2
a537 2
			if (dev != NULL) {
				for (i = 0; dev->subdevs[i]; i++)
d539 1
a539 2
			}
		}
d629 1
a629 1
	if (status != USBD_NORMAL_COMPLETION)
d631 2
a632 2

	usb_needs_explore(sc->sc_hub->bus);
@


head	1.26;
access;
symbols
	NetBSD-1_19:1.26
	NetBSD-1_18:1.26
	NetBSD-1_17:1.26
	NetBSD-1_16:1.26
	NetBSD-1_15:1.26
	NetBSD-1_14:1.26
	NetBSD-1_13:1.26
	NetBSD-1_12:1.26
	NetBSD-1_09-1:1.26
	NetBSD-1_11:1.25
	NetBSD-1_10:1.25
	NetBSD-1_09:1.24
	NetBSD-1_08:1.24
	NetBSD-1_07:1.23
	NetBSD-1_06:1.23
	NetBSD-1_05:1.23
	NetBSD-1_04:1.23
	NetBSD-1_03:1.23
	NetBSD-1_02:1.23
	NetBSD-1_01:1.23
	NetBSD-1_00:1.23
	NetBSD-0_99:1.23
	NetBSD-0_98:1.23
	NetBSD-0_97:1.23
	NetBSD-0_96:1.23
	NetBSD-0_95:1.23
	NetBSD-0_94:1.23
	NetBSD-0_93:1.23
	NetBSD-0_92:1.23
	NetBSD-0_91:1.23
	NetBSD-0_90:1.23
	NetBSD-0_89:1.23
	NetBSD-0_88:1.22
	NetBSD-0_87:1.22
	NetBSD-0_86:1.22
	NetBSD-0_85:1.22
	NetBSD-0_84:1.22
	NetBSD-0_83:1.22
	NetBSD-0_82:1.22
	NetBSD-0_81:1.22
	NetBSD-0_80:1.22
	NetBSD-0_79:1.22
	NetBSD-0_78:1.22
	NetBSD-0_77:1.22
	NetBSD-0_76:1.22
	NetBSD-0_75:1.22
	NetBSD-0_74:1.22
	NetBSD-0_73:1.22
	NetBSD-0_72:1.22
	NetBSD-0_71:1.22
	NetBSD-0_70:1.21
	NetBSD-0_69:1.21
	NetBSD-0_68:1.21
	NetBSD-0_67:1.21
	NetBSD-0_66:1.21
	NetBSD-0_65:1.21
	NetBSD-0_64:1.21
	NetBSD-0_63:1.21
	NetBSD-0_62:1.20
	NetBSD-0_61:1.19
	NetBSD-0_60:1.19
	NetBSD-0_59:1.19
	NetBSD-0_58:1.18
	NetBSD-0_57:1.18
	NetBSD-0_56:1.18
	NetBSD-0_55:1.18
	NetBSD-0_54:1.18
	NetBSD-0_53:1.18
	NetBSD-0_52:1.18
	NetBSD-0_51:1.18
	NetBSD-0_50:1.18
	NetBSD-0_49:1.18
	NetBSD-0_48:1.18
	NetBSD-0_47:1.18
	NetBSD-0_46:1.17
	NetBSD-0_45:1.17
	NetBSD-0_44:1.16
	NetBSD-0_43:1.16
	NetBSD-0_42:1.15
	NetBSD-0_41:1.15
	NetBSD-0_40:1.15
	NetBSD-0_39:1.14
	NetBSD-0_38:1.13
	NetBSD-0_37:1.13
	NetBSD-0_36:1.13
	NetBSD-0_35:1.13
	NetBSD-0_34:1.13
	NetBSD-0_33:1.13
	NetBSD-0_32:1.12
	NetBSD-0_31:1.12
	NetBSD-0_30:1.11
	NetBSD-0_29:1.11
	RO_5_07:1.11
	NetBSD-0_28:1.11
	NetBSD-0_27:1.10
	NetBSD-0_26:1.10
	NetBSD-0_25:1.9
	NetBSD-0_24:1.8
	NetBSD-0_23:1.8
	NetBSD-0_21-1_22_2_1:1.6.2.1
	NetBSD-0_22:1.7
	USB1:1.6.0.2
	NetBSD-0_21:1.6
	NetBSD-0_20:1.5
	NetBSD-0_19:1.5
	NetBSD-0_18:1.5
	NetBSD-0_17:1.4
	NetBSD-0_16:1.4
	NetBSD-0_15:1.3
	NetBSD-0_14:1.3
	NetBSD-0_13:1.2
	NetBSD-0_12:1.2
	NetBSD-0_11:1.1
	NetBSD-0_10:1.1
	NetBSD-0_09:1.1
	NetBSD-0_08:1.1
	NetBSD-0_07:1.1
	NetBSD-0_06:1.1
	NetBSD-0_05:1.1
	NetBSD-0_04:1.1
	NetBSD-0_03:1.1
	NetBSD-0_02:1.1
	NetBSD-0_01:1.1;
locks; strict;
comment	@# @;


1.26
date	2016.03.04.20.54.42;	author rool;	state Exp;
branches;
next	1.25;
commitid	MvG9A9da0K4NQmXy;

1.25
date	2016.03.04.01.30.11;	author jballance;	state Exp;
branches;
next	1.24;
commitid	NFICmxi3aahBqgXy;

1.24
date	2015.11.15.09.50.45;	author rool;	state Exp;
branches;
next	1.23;
commitid	TgSd07Pyi9PAJaJy;

1.23
date	2014.10.25.18.43.42;	author rsprowson;	state Exp;
branches;
next	1.22;
commitid	SYXBVhhWAW5D5CVx;

1.22
date	2012.06.07.00.11.14;	author jlee;	state Exp;
branches;
next	1.21;
commitid	LkYeKFZjKWlNTH7w;

1.21
date	2011.12.04.19.22.44;	author jlee;	state Exp;
branches;
next	1.20;
commitid	zwyAy3p02v2AfUJv;

1.20
date	2011.08.22.22.38.20;	author jlee;	state Exp;
branches;
next	1.19;
commitid	DX6w1a2oIxQTFywv;

1.19
date	2011.05.22.20.22.42;	author jlee;	state Exp;
branches;
next	1.18;
commitid	Ye1jVWDlKivFSIkv;

1.18
date	2009.05.09.19.32.48;	author jlee;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.05.12.43.04;	author jballance;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.30.22.39.55;	author dellis;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.18.11.54.03;	author jballance;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.24.23.13.53;	author jballance;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.21.22.30.19;	author jballance;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.30.02.34.20;	author jballance;	state Exp;
branches;
next	1.11;

1.11
date	2004.08.12.14.47.40;	author jballance;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.30.14.50.37;	author kbracey;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.06.15.50.22;	author bavison;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.16.15.43.50;	author kbracey;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.21.20.49.19;	author bavison;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.21.15.23.23;	author bavison;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2003.06.03.10.38.14;	author bavison;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.14.16.43.50;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.15.12.22.16;	author rsprowson;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.11.09.17.44;	author rsprowson;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.28.09.55.17;	author dellis;	state Exp;
branches;
next	;

1.6.2.1
date	2004.02.16.15.38.43;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Revert accidental commits
Admin:
  These changes are currently subject to rework via the normal submissions channel.
@
text
@/*      $NetBSD: ohci.c,v 1.154 2004/12/22 19:36:13 joff Exp $  */
/*	$FreeBSD: src/sys/dev/usb/ohci.c,v 1.22 1999/11/17 22:33:40 n_hibma Exp $	*/

/* note version 1.157 exists in NetBSD sources at 20050416, but this file
 * has not been updated to track that as the code has changed significantly
 * and so far an appropriate match hasnt been achieved
 * JWB 17 April 2005
 */
 
/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * USB Open Host Controller driver.
 *
 * OHCI spec: http://www.compaq.com/productinfo/development/openhci.html
 * USB spec: http://www.usb.org/developers/docs/usbspec.zip
 */

#ifdef __riscos
#include <dev/usb/usbhal.h>
#endif
#include <sys/cdefs.h>
//__KERNEL_RCSID(0, "$NetBSD: ohci.c,v 1.154 2004/12/22 19:36:13 joff Exp $");

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#if defined(__NetBSD__) || defined(__OpenBSD__)
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/select.h>
#include <uvm/uvm_extern.h>
#elif defined(__FreeBSD__)
#include <sys/module.h>
#include <sys/bus.h>
#include <machine/bus_pio.h>
#include <machine/bus_memio.h>
#if defined(DIAGNOSTIC) && defined(__i386__) && defined(__FreeBSD__)
#include <machine/cpu.h>
#endif
#endif
#include <sys/proc.h>
#include <sys/queue.h>

#include <machine/bus.h>
#include <machine/endian.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usb_mem.h>
#include <dev/usb/usb_quirks.h>

#include <dev/usb/ohcireg.h>
#include <dev/usb/ohcivar.h>

#if defined(__FreeBSD__)
#include <machine/clock.h>

#define delay(d)                DELAY(d)
#endif

#if defined(__OpenBSD__)
struct cfdriver ohci_cd = {
	NULL, "ohci", DV_DULL
};
#endif

#ifdef OHCI_DEBUG
#define DPRINTF(x)	if (ohcidebug) logprintf x
#define DPRINTFN(n,x)	if (ohcidebug>(n)) logprintf x
int ohcidebug = 0;
#ifndef __NetBSD__
#define bitmask_snprintf(q,f,b,l) snprintf((b), (l), "%b", (q), (f))
#endif
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif
#ifdef __riscos
#define printf logprintf
#endif

/*
 * The OHCI controller is little endian, so on big endian machines
 * the data strored in memory needs to be swapped.
 */
#if defined(__FreeBSD__) || defined(__OpenBSD__)
#if BYTE_ORDER == BIG_ENDIAN
#define htole32(x) (bswap32(x))
#define le32toh(x) (bswap32(x))
#else
#define htole32(x) (x)
#define le32toh(x) (x)
#endif
#endif

struct ohci_pipe;

Static ohci_soft_ed_t  *ohci_alloc_sed(ohci_softc_t *);
Static void		ohci_free_sed(ohci_softc_t *, ohci_soft_ed_t *);

Static ohci_soft_td_t  *ohci_alloc_std(ohci_softc_t *);
Static void		ohci_free_std(ohci_softc_t *, ohci_soft_td_t *);

Static ohci_soft_itd_t *ohci_alloc_sitd(ohci_softc_t *);
Static void		ohci_free_sitd(ohci_softc_t *,ohci_soft_itd_t *);

#if 0
Static void		ohci_free_std_chain(ohci_softc_t *, ohci_soft_td_t *,
					    ohci_soft_td_t *);
#endif
Static usbd_status	ohci_alloc_std_chain(struct ohci_pipe *,
			    ohci_softc_t *, int, int, usbd_xfer_handle,
			    ohci_soft_td_t *, ohci_soft_td_t **);

Static void		ohci_shutdown(void *v);
Static void		ohci_power(int, void *);
#ifdef __riscos
extern void (*ohci_ppower)(int port, int state);
#endif /*__riscos*/
Static usbd_status	ohci_open(usbd_pipe_handle);
Static void		ohci_poll(struct usbd_bus *);
Static void		ohci_softintr(void *);
Static void		ohci_waitintr(ohci_softc_t *, usbd_xfer_handle);
Static void		ohci_add_done(ohci_softc_t *, ohci_physaddr_t);
Static void		ohci_rhsc(ohci_softc_t *, usbd_xfer_handle);

Static usbd_status	ohci_device_request(usbd_xfer_handle xfer);
Static void		ohci_add_ed(ohci_soft_ed_t *, ohci_soft_ed_t *);
Static void		ohci_rem_ed(ohci_soft_ed_t *, ohci_soft_ed_t *);
Static void		ohci_hash_add_td(ohci_softc_t *, ohci_soft_td_t *);
Static void		ohci_hash_rem_td(ohci_softc_t *, ohci_soft_td_t *);
Static ohci_soft_td_t  *ohci_hash_find_td(ohci_softc_t *, ohci_physaddr_t);
Static void		ohci_hash_add_itd(ohci_softc_t *, ohci_soft_itd_t *);
Static void		ohci_hash_rem_itd(ohci_softc_t *, ohci_soft_itd_t *);
Static ohci_soft_itd_t  *ohci_hash_find_itd(ohci_softc_t *, ohci_physaddr_t);

Static usbd_status	ohci_setup_isoc(usbd_pipe_handle pipe);
Static void		ohci_device_isoc_enter(usbd_xfer_handle);

Static usbd_status	ohci_allocm(struct usbd_bus *, usb_dma_t *, u_int32_t);
Static void		ohci_freem(struct usbd_bus *, usb_dma_t *);

Static usbd_xfer_handle	ohci_allocx(struct usbd_bus *);
Static void		ohci_freex(struct usbd_bus *, usbd_xfer_handle);

Static usbd_status	ohci_root_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	ohci_root_ctrl_start(usbd_xfer_handle);
Static void		ohci_root_ctrl_abort(usbd_xfer_handle);
Static void		ohci_root_ctrl_close(usbd_pipe_handle);
Static void		ohci_root_ctrl_done(usbd_xfer_handle);

Static usbd_status	ohci_root_intr_transfer(usbd_xfer_handle);
Static usbd_status	ohci_root_intr_start(usbd_xfer_handle);
Static void		ohci_root_intr_abort(usbd_xfer_handle);
Static void		ohci_root_intr_close(usbd_pipe_handle);
Static void		ohci_root_intr_done(usbd_xfer_handle);

Static usbd_status	ohci_device_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	ohci_device_ctrl_start(usbd_xfer_handle);
Static void		ohci_device_ctrl_abort(usbd_xfer_handle);
Static void		ohci_device_ctrl_close(usbd_pipe_handle);
Static void		ohci_device_ctrl_done(usbd_xfer_handle);

Static usbd_status	ohci_device_bulk_transfer(usbd_xfer_handle);
Static usbd_status	ohci_device_bulk_start(usbd_xfer_handle);
Static void		ohci_device_bulk_abort(usbd_xfer_handle);
Static void		ohci_device_bulk_close(usbd_pipe_handle);
Static void		ohci_device_bulk_done(usbd_xfer_handle);

Static usbd_status	ohci_device_intr_transfer(usbd_xfer_handle);
Static usbd_status	ohci_device_intr_start(usbd_xfer_handle);
Static void		ohci_device_intr_abort(usbd_xfer_handle);
Static void		ohci_device_intr_close(usbd_pipe_handle);
Static void		ohci_device_intr_done(usbd_xfer_handle);

Static usbd_status	ohci_device_isoc_transfer(usbd_xfer_handle);
Static usbd_status	ohci_device_isoc_start(usbd_xfer_handle);
Static void		ohci_device_isoc_abort(usbd_xfer_handle);
Static void		ohci_device_isoc_close(usbd_pipe_handle);
Static void		ohci_device_isoc_done(usbd_xfer_handle);

Static usbd_status	ohci_device_setintr(ohci_softc_t *sc,
			    struct ohci_pipe *pipe, int ival);

Static int		ohci_str(usb_string_descriptor_t *, int, const char *);

Static void		ohci_timeout(void *);
Static void		ohci_timeout_task(void *);
Static void		ohci_rhsc_able(ohci_softc_t *, int);
Static void		ohci_rhsc_enable(void *);

Static void		ohci_close_pipe(usbd_pipe_handle, ohci_soft_ed_t *);
Static void		ohci_abort_xfer(usbd_xfer_handle, usbd_status);

Static void		ohci_device_clear_toggle(usbd_pipe_handle pipe);
Static void		ohci_noop(usbd_pipe_handle pipe);

#ifdef OHCI_DEBUG
Static void		ohci_dumpregs(ohci_softc_t *);
Static void		ohci_dump_tds(ohci_soft_td_t *);
Static void		ohci_dump_td(ohci_soft_td_t *);
Static void		ohci_dump_ed(ohci_soft_ed_t *);
Static void		ohci_dump_itd(ohci_soft_itd_t *);
Static void		ohci_dump_itds(ohci_soft_itd_t *);
#endif

#define OBARR(sc) bus_space_barrier((sc)->iot, (sc)->ioh, 0, (sc)->sc_size, \
			BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE)
#define OWRITE1(sc, r, x) \
 do { OBARR(sc); bus_space_write_1((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
#define OWRITE2(sc, r, x) \
 do { OBARR(sc); bus_space_write_2((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
#define OWRITE4(sc, r, x) \
 do { OBARR(sc); bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
#define OREAD1(sc, r) (OBARR(sc), bus_space_read_1((sc)->iot, (sc)->ioh, (r)))
#define OREAD2(sc, r) (OBARR(sc), bus_space_read_2((sc)->iot, (sc)->ioh, (r)))
#define OREAD4(sc, r) (OBARR(sc), bus_space_read_4((sc)->iot, (sc)->ioh, (r)))

/* Reverse the bits in a value 0 .. 31 */
Static u_int8_t revbits[OHCI_NO_INTRS] =
  { 0x00, 0x10, 0x08, 0x18, 0x04, 0x14, 0x0c, 0x1c,
    0x02, 0x12, 0x0a, 0x1a, 0x06, 0x16, 0x0e, 0x1e,
    0x01, 0x11, 0x09, 0x19, 0x05, 0x15, 0x0d, 0x1d,
    0x03, 0x13, 0x0b, 0x1b, 0x07, 0x17, 0x0f, 0x1f };

struct ohci_pipe {
	struct usbd_pipe pipe;
	ohci_soft_ed_t *sed;
	union {
		ohci_soft_td_t *td;
		ohci_soft_itd_t *itd;
	} tail;
	/* Info needed for different pipe kinds. */
	union {
		/* Control pipe */
		struct {
			usb_dma_t reqdma;
			u_int length;
			ohci_soft_td_t *setup, *data, *stat;
		} ctl;
		/* Interrupt pipe */
		struct {
			int nslots;
			int pos;
		} intr;
		/* Bulk pipe */
		struct {
			u_int length;
			int isread;
		} bulk;
		/* Iso pipe */
		struct iso {
			int next, inuse;
		} iso;
	} u;
};

#define OHCI_INTR_ENDPT 1

#ifdef USBHAL
extern int usbhal_ohci_do_intr(struct usbd_bus *,int irqdevno);
extern void usbhal_ohci_shutdown(struct usbd_bus *);
#endif

Static struct usbd_bus_methods ohci_bus_methods = {
	ohci_open,
	ohci_softintr,
	ohci_poll,
	ohci_allocm,
	ohci_freem,
	ohci_allocx,
	ohci_freex,
	NULL, NULL, NULL, NULL, /* 4x unused HC overrides */
#ifdef USBHAL
	usbhal_ohci_do_intr,
	usbhal_ohci_shutdown,
#endif
};

Static struct usbd_pipe_methods ohci_root_ctrl_methods = {
	ohci_root_ctrl_transfer,
	ohci_root_ctrl_start,
	ohci_root_ctrl_abort,
	ohci_root_ctrl_close,
	ohci_noop,
	ohci_root_ctrl_done,
};

Static struct usbd_pipe_methods ohci_root_intr_methods = {
	ohci_root_intr_transfer,
	ohci_root_intr_start,
	ohci_root_intr_abort,
	ohci_root_intr_close,
	ohci_noop,
	ohci_root_intr_done,
};

Static struct usbd_pipe_methods ohci_device_ctrl_methods = {
	ohci_device_ctrl_transfer,
	ohci_device_ctrl_start,
	ohci_device_ctrl_abort,
	ohci_device_ctrl_close,
	ohci_noop,
	ohci_device_ctrl_done,
};

Static struct usbd_pipe_methods ohci_device_intr_methods = {
	ohci_device_intr_transfer,
	ohci_device_intr_start,
	ohci_device_intr_abort,
	ohci_device_intr_close,
	ohci_device_clear_toggle,
	ohci_device_intr_done,
};

Static struct usbd_pipe_methods ohci_device_bulk_methods = {
	ohci_device_bulk_transfer,
	ohci_device_bulk_start,
	ohci_device_bulk_abort,
	ohci_device_bulk_close,
	ohci_device_clear_toggle,
	ohci_device_bulk_done,
};

Static struct usbd_pipe_methods ohci_device_isoc_methods = {
	ohci_device_isoc_transfer,
	ohci_device_isoc_start,
	ohci_device_isoc_abort,
	ohci_device_isoc_close,
	ohci_noop,
	ohci_device_isoc_done,
};

#ifdef USBHAL
/* TODO - Move elsewhere */
static void abort_pipe(void *v)
{
	splbio(); /* Code in cmodule runs with interrupts enabled(!) */
	ohci_abort_xfer((usbd_xfer_handle) v,USBD_TIMEOUT);
}

static void riscos_abort_pipe(void *v)
{
	USBHAL_AddCallback(abort_pipe,v);
}
#endif

#if defined (__riscos) && !defined(USBHAL)
static int veneers_built = 0;
void build_veneer (void* vn, void* st, size_t sz);
static struct {
    struct usbd_bus_methods methods;
    struct {
        int load;
        int branch;
    } veneer[sizeof (struct usbd_bus_methods) / sizeof (void*)];
} ohci_bus_methods_entry;

static struct {
    struct usbd_pipe_methods methods;
    struct {
        int load;
        int branch;
    } veneer[sizeof (struct usbd_pipe_methods) / sizeof (void*)];
} ohci_root_ctrl_methods_entry,
  ohci_root_intr_methods_entry,
  ohci_device_ctrl_methods_entry,
  ohci_device_intr_methods_entry,
  ohci_device_bulk_methods_entry,
  ohci_device_isoc_methods_entry;
#endif

#if defined(__NetBSD__) || defined(__OpenBSD__)
int
ohci_activate(device_ptr_t self, enum devact act)
{
	struct ohci_softc *sc = (struct ohci_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_ACTIVATE:
		return (EOPNOTSUPP);

	case DVACT_DEACTIVATE:
		if (sc->sc_child != NULL)
			rv = config_deactivate(sc->sc_child);
		sc->sc_dying = 1;
		break;
	}
	return (rv);
}

int
ohci_detach(struct ohci_softc *sc, int flags)
{
	int rv = 0;

	if (sc->sc_child != NULL)
		rv = config_detach(sc->sc_child, flags);

	if (rv != 0)
		return (rv);

	usb_uncallout(sc->sc_tmo_rhsc, ohci_rhsc_enable, sc);

#if defined(__NetBSD__) || defined(__OpenBSD__)
	powerhook_disestablish(sc->sc_powerhook);
	shutdownhook_disestablish(sc->sc_shutdownhook);
#endif

	usb_delay_ms(&sc->sc_bus, 300); /* XXX let stray task complete */

	/* free data structures XXX */

	return (rv);
}
#endif

ohci_soft_ed_t *
ohci_alloc_sed(ohci_softc_t *sc)
{
	ohci_soft_ed_t *sed;
	usbd_status err;
	int i, offs;
	usb_dma_t dma;

	if (sc->sc_freeeds == NULL) {
		DPRINTFN(2, ("ohci_alloc_sed: allocating chunk\n"));
		err = usb_allocmem(&sc->sc_bus, OHCI_SED_SIZE * OHCI_SED_CHUNK,
			  OHCI_ED_ALIGN, &dma);
		if (err)
			return (0);
		for(i = 0; i < OHCI_SED_CHUNK; i++) {
			offs = i * OHCI_SED_SIZE;
			sed = KERNADDR(&dma, offs);
			sed->physaddr = DMAADDR(&dma, offs);
			sed->next = sc->sc_freeeds;
			sc->sc_freeeds = sed;
		}
	}
	sed = sc->sc_freeeds;
	sc->sc_freeeds = sed->next;
	memset(&sed->ed, 0, sizeof(ohci_ed_t));
	sed->next = 0;
	return (sed);
}

void
ohci_free_sed(ohci_softc_t *sc, ohci_soft_ed_t *sed)
{
	sed->next = sc->sc_freeeds;
	sc->sc_freeeds = sed;
}

ohci_soft_td_t *
ohci_alloc_std(ohci_softc_t *sc)
{
	ohci_soft_td_t *std;
	usbd_status err;
	int i, offs;
	usb_dma_t dma;
	int s;

	if (sc->sc_freetds == NULL) {
		DPRINTFN(2, ("ohci_alloc_std: allocating chunk\n"));
		err = usb_allocmem(&sc->sc_bus, OHCI_STD_SIZE * OHCI_STD_CHUNK,
			  OHCI_TD_ALIGN, &dma);
		if (err)
			return (NULL);
		s = splusb();
		for(i = 0; i < OHCI_STD_CHUNK; i++) {
			offs = i * OHCI_STD_SIZE;
			std = KERNADDR(&dma, offs);
			std->physaddr = DMAADDR(&dma, offs);
			std->nexttd = sc->sc_freetds;
			sc->sc_freetds = std;
		}
		splx(s);
	}

	s = splusb();
	std = sc->sc_freetds;
	sc->sc_freetds = std->nexttd;
	memset(&std->td, 0, sizeof(ohci_td_t));
	std->nexttd = NULL;
	std->xfer = NULL;
	ohci_hash_add_td(sc, std);
	splx(s);

	return (std);
}

void
ohci_free_std(ohci_softc_t *sc, ohci_soft_td_t *std)
{
	int s;

	s = splusb();
	ohci_hash_rem_td(sc, std);
	std->nexttd = sc->sc_freetds;
	sc->sc_freetds = std;
	splx(s);
}

usbd_status
ohci_alloc_std_chain(struct ohci_pipe *opipe, ohci_softc_t *sc,
		     int alen, int rd, usbd_xfer_handle xfer,
		     ohci_soft_td_t *sp, ohci_soft_td_t **ep)
{
	ohci_soft_td_t *next, *cur;
	ohci_physaddr_t dataphys, dataphysend;
	u_int32_t tdflags;
	int len, curlen;
	usb_dma_t *dma = &xfer->dmabuf;
	u_int16_t flags = xfer->flags;

	DPRINTFN(alen < 4096,("ohci_alloc_std_chain: start len=%d\n", alen));

	len = alen;
	cur = sp;
	dataphys = DMAADDR(dma, 0);
	dataphysend = OHCI_PAGE(dataphys + len - 1);
	tdflags = htole32(
	    (rd ? OHCI_TD_IN : OHCI_TD_OUT) |
            (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |
	    OHCI_TD_NOCC | OHCI_TD_TOGGLE_CARRY | OHCI_TD_NOINTR);

	for (;;) {
		next = ohci_alloc_std(sc);
		if (next == NULL)
			goto nomem;

		/* The OHCI hardware can handle at most one page crossing. */
		if (OHCI_PAGE(dataphys) == dataphysend ||
		    OHCI_PAGE(dataphys) + OHCI_PAGE_SIZE == dataphysend) {
			/* we can handle it in this TD */
			curlen = len;
		} else {
			/* must use multiple TDs, fill as much as possible. */
			curlen = 2 * OHCI_PAGE_SIZE -
				 (dataphys & (OHCI_PAGE_SIZE-1));
			/* the length must be a multiple of the max size */
			curlen -= curlen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize);
#ifdef DIAGNOSTIC
			if (curlen == 0)
				panic("ohci_alloc_std: curlen == 0");
#endif
		}
		DPRINTFN(4,("ohci_alloc_std_chain: dataphys=0x%08x "
			    "dataphysend=0x%08x len=%d curlen=%d\n",
			    dataphys, dataphysend,
			    len, curlen));
		len -= curlen;

		cur->td.td_flags = tdflags;
		cur->td.td_cbp = htole32(dataphys);
		cur->nexttd = next;
		cur->td.td_nexttd = htole32(next->physaddr);
		cur->td.td_be = htole32(dataphys + curlen - 1);
		cur->len = curlen;
		cur->flags = OHCI_ADD_LEN;
		cur->xfer = xfer;
		DPRINTFN(10,("ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\n",
			    dataphys, dataphys + curlen - 1));
		if (len == 0)
			break;
		DPRINTFN(10,("ohci_alloc_std_chain: extend chain\n"));
		dataphys += curlen;
		cur = next;
	}
	if ((flags & USBD_FORCE_SHORT_XFER) &&
	    alen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize) == 0) {
		/* Force a 0 length transfer at the end. */

		cur = next;
		next = ohci_alloc_std(sc);
		if (next == NULL)
			goto nomem;

		cur->td.td_flags = tdflags;
		cur->td.td_cbp = 0; /* indicate 0 length packet */
		cur->nexttd = next;
		cur->td.td_nexttd = htole32(next->physaddr);
		cur->td.td_be = ~0;
		cur->len = 0;
		cur->flags = 0;
		cur->xfer = xfer;
		DPRINTFN(2,("ohci_alloc_std_chain: add 0 xfer\n"));
	}
	*ep = cur;

	return (USBD_NORMAL_COMPLETION);

 nomem:
	/* XXX free chain */
	return (USBD_NOMEM);
}

#if 0
Static void
ohci_free_std_chain(ohci_softc_t *sc, ohci_soft_td_t *std,
		    ohci_soft_td_t *stdend)
{
	ohci_soft_td_t *p;

	for (; std != stdend; std = p) {
		p = std->nexttd;
		ohci_free_std(sc, std);
	}
}
#endif

ohci_soft_itd_t *
ohci_alloc_sitd(ohci_softc_t *sc)
{
	ohci_soft_itd_t *sitd;
	usbd_status err;
	int i, s, offs;
	usb_dma_t dma;

	if (sc->sc_freeitds == NULL) {
		DPRINTFN(2, ("ohci_alloc_sitd: allocating chunk\n"));
		err = usb_allocmem(&sc->sc_bus, OHCI_SITD_SIZE * OHCI_SITD_CHUNK,
			  OHCI_ITD_ALIGN, &dma);
		if (err)
			return (NULL);
		s = splusb();
		for(i = 0; i < OHCI_SITD_CHUNK; i++) {
			offs = i * OHCI_SITD_SIZE;
			sitd = KERNADDR(&dma, offs);
			sitd->physaddr = DMAADDR(&dma, offs);
			sitd->nextitd = sc->sc_freeitds;
			sc->sc_freeitds = sitd;
		}
		splx(s);
	}

	s = splusb();
	sitd = sc->sc_freeitds;
	sc->sc_freeitds = sitd->nextitd;
	memset(&sitd->itd, 0, sizeof(ohci_itd_t));
	sitd->nextitd = NULL;
	sitd->xfer = NULL;
	ohci_hash_add_itd(sc, sitd);
	splx(s);

#ifdef DIAGNOSTIC
	sitd->isdone = 0;
#endif

	return (sitd);
}

void
ohci_free_sitd(ohci_softc_t *sc, ohci_soft_itd_t *sitd)
{
	int s;

	DPRINTFN(10,("ohci_free_sitd: sitd=%p\n", sitd));

#ifdef DIAGNOSTIC
	if (!sitd->isdone) {
		panic("ohci_free_sitd: sitd=%p not done", sitd);
		return;
	}
	/* Warn double free */
	sitd->isdone = 0;
#endif

	s = splusb();
	ohci_hash_rem_itd(sc, sitd);
	sitd->nextitd = sc->sc_freeitds;
	sc->sc_freeitds = sitd;
	splx(s);
}

usbd_status
ohci_init(ohci_softc_t *sc)
{
	ohci_soft_ed_t *sed, *psed;
	usbd_status err;
	int i;
	u_int32_t s, ctl, ival, hcr, fm, per, rev, desca;

#if defined (__riscos) && !defined(USBHAL)
        if (!veneers_built)
        {
            build_veneer(&ohci_bus_methods_entry,
                &ohci_bus_methods,
                sizeof ohci_bus_methods);
            build_veneer(&ohci_root_ctrl_methods_entry,
                &ohci_root_ctrl_methods,
                sizeof ohci_root_ctrl_methods);
            build_veneer(&ohci_root_intr_methods_entry,
                &ohci_root_intr_methods,
                sizeof ohci_root_intr_methods);
            build_veneer(&ohci_device_ctrl_methods_entry,
                &ohci_device_ctrl_methods,
                sizeof ohci_device_ctrl_methods);
            build_veneer(&ohci_device_intr_methods_entry,
                &ohci_device_intr_methods,
                sizeof ohci_device_intr_methods);
            build_veneer(&ohci_device_bulk_methods_entry,
                &ohci_device_bulk_methods,
                sizeof ohci_device_bulk_methods);
            build_veneer(&ohci_device_isoc_methods_entry,
                &ohci_device_isoc_methods,
                sizeof ohci_device_isoc_methods);
            veneers_built = 1;
        }
#endif
	DPRINTF(("ohci_init: start\n"));
#if defined(__OpenBSD__)
        printf(",");
#else
        printf("%s:", USBDEVNAME(sc->sc_bus.bdev));
#endif
	rev = OREAD4(sc, OHCI_REVISION);
        printf(" OHCI version %d.%d%s\n", OHCI_REV_HI(rev), OHCI_REV_LO(rev),
	       OHCI_REV_LEGACY(rev) ? ", legacy support" : "");

	if (OHCI_REV_HI(rev) != 1 || OHCI_REV_LO(rev) != 0) {
                printf("%s: unsupported OHCI revision\n",
		       USBDEVNAME(sc->sc_bus.bdev));
		sc->sc_bus.usbrev = USBREV_UNKNOWN;
		return (USBD_INVAL);
	}
	sc->sc_bus.usbrev = USBREV_1_0;

	for (i = 0; i < OHCI_HASH_SIZE; i++)
		LIST_INIT(&sc->sc_hash_tds[i]);
	for (i = 0; i < OHCI_HASH_SIZE; i++)
		LIST_INIT(&sc->sc_hash_itds[i]);

	SIMPLEQ_INIT(&sc->sc_free_xfers);

#ifdef __NetBSD__
        usb_setup_reserve(sc, &sc->sc_dma_reserve, sc->sc_bus.dmatag,
            USB_MEM_RESERVE);
#endif

	/* XXX determine alignment by R/W */
	/* Allocate the HCCA area. */
	err = usb_allocmem(&sc->sc_bus, OHCI_HCCA_SIZE,
			 OHCI_HCCA_ALIGN, &sc->sc_hccadma);
	if (err)
		return (err);
	sc->sc_hcca = KERNADDR(&sc->sc_hccadma, 0);
	memset(sc->sc_hcca, 0, OHCI_HCCA_SIZE);

	sc->sc_eintrs = OHCI_NORMAL_INTRS;

	/* Allocate dummy ED that starts the control list. */
	sc->sc_ctrl_head = ohci_alloc_sed(sc);
	if (sc->sc_ctrl_head == NULL) {
		err = USBD_NOMEM;
		goto bad1;
	}
	sc->sc_ctrl_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);

	/* Allocate dummy ED that starts the bulk list. */
	sc->sc_bulk_head = ohci_alloc_sed(sc);
	if (sc->sc_bulk_head == NULL) {
		err = USBD_NOMEM;
		goto bad2;
	}
	sc->sc_bulk_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);

	/* Allocate dummy ED that starts the isochronous list. */
	sc->sc_isoc_head = ohci_alloc_sed(sc);
	if (sc->sc_isoc_head == NULL) {
		err = USBD_NOMEM;
		goto bad3;
	}
	sc->sc_isoc_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);

	/* Allocate all the dummy EDs that make up the interrupt tree. */
	for (i = 0; i < OHCI_NO_EDS; i++) {
		sed = ohci_alloc_sed(sc);
		if (sed == NULL) {
			while (--i >= 0)
				ohci_free_sed(sc, sc->sc_eds[i]);
			err = USBD_NOMEM;
			goto bad4;
		}
		/* All ED fields are set to 0. */
		sc->sc_eds[i] = sed;
		sed->ed.ed_flags |= htole32(OHCI_ED_SKIP);
		if (i != 0)
			psed = sc->sc_eds[(i-1) / 2];
		else
			psed= sc->sc_isoc_head;
		sed->next = psed;
		sed->ed.ed_nexted = htole32(psed->physaddr);
	}
	/*
	 * Fill HCCA interrupt table.  The bit reversal is to get
	 * the tree set up properly to spread the interrupts.
	 */
	for (i = 0; i < OHCI_NO_INTRS; i++)
		sc->sc_hcca->hcca_interrupt_table[revbits[i]] =
		    htole32(sc->sc_eds[OHCI_NO_EDS-OHCI_NO_INTRS+i]->physaddr);

#ifdef OHCI_DEBUG
	if (ohcidebug > 15) {
		for (i = 0; i < OHCI_NO_EDS; i++) {
                        printf("ed#%d ", i);
			ohci_dump_ed(sc->sc_eds[i]);
		}
                printf("iso ");
		ohci_dump_ed(sc->sc_isoc_head);
	}
#endif

	/* Determine in what context we are running. */
	ctl = OREAD4(sc, OHCI_CONTROL);
	if (ctl & OHCI_IR) {
		/* SMM active, request change */
		DPRINTF(("ohci_init: SMM active, request owner change\n"));
		s = OREAD4(sc, OHCI_COMMAND_STATUS);
		OWRITE4(sc, OHCI_COMMAND_STATUS, s | OHCI_OCR);
		for (i = 0; i < 100 && (ctl & OHCI_IR); i++) {
			usb_delay_ms(&sc->sc_bus, 1);
			ctl = OREAD4(sc, OHCI_CONTROL);
		}
		if ((ctl & OHCI_IR) == 0) {
                        printf("%s: SMM does not respond, resetting\n",
			       USBDEVNAME(sc->sc_bus.bdev));
			OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);
			goto reset;
		}
#if 0
/* Don't bother trying to reuse the BIOS init, we'll reset it anyway. */
	} else if ((ctl & OHCI_HCFS_MASK) != OHCI_HCFS_RESET) {
		/* BIOS started controller. */
		DPRINTF(("ohci_init: BIOS active\n"));
		if ((ctl & OHCI_HCFS_MASK) != OHCI_HCFS_OPERATIONAL) {
			OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_OPERATIONAL);
			usb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY);
		}
#endif
	} else {
		DPRINTF(("ohci_init: cold started\n"));
	reset:
		/* Controller was cold started. */
		usb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY);
	}

	/*
	 * This reset should not be necessary according to the OHCI spec, but
	 * without it some controllers do not start.
	 */
	DPRINTF(("%s: resetting\n", USBDEVNAME(sc->sc_bus.bdev)));
	OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);
	usb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY);

	/* We now own the host controller and the bus has been reset. */
	ival = OHCI_GET_IVAL(OREAD4(sc, OHCI_FM_INTERVAL));

	OWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_HCR); /* Reset HC */
	/* Nominal time for a reset is 10 us. */
	for (i = 0; i < 10; i++) {
		delay(10);
		hcr = OREAD4(sc, OHCI_COMMAND_STATUS) & OHCI_HCR;
		if (!hcr)
			break;
	}
	if (hcr) {
                printf("%s: reset timeout\n", USBDEVNAME(sc->sc_bus.bdev));
		err = USBD_IOERROR;
		goto bad5;
	}
#ifdef OHCI_DEBUG
	if (ohcidebug > 15)
		ohci_dumpregs(sc);
#endif

	/* The controller is now in SUSPEND state, we have 2ms to finish. */

	/* Set up HC registers. */
	OWRITE4(sc, OHCI_HCCA, DMAADDR(&sc->sc_hccadma, 0));
	OWRITE4(sc, OHCI_CONTROL_HEAD_ED, sc->sc_ctrl_head->physaddr);
	OWRITE4(sc, OHCI_BULK_HEAD_ED, sc->sc_bulk_head->physaddr);
	/* disable all interrupts and then switch on all desired interrupts */
	OWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);
	OWRITE4(sc, OHCI_INTERRUPT_ENABLE, sc->sc_eintrs | OHCI_MIE);
	/* switch on desired functional features */
	ctl = OREAD4(sc, OHCI_CONTROL);
	ctl &= ~(OHCI_CBSR_MASK | OHCI_LES | OHCI_HCFS_MASK | OHCI_IR);
	ctl |= OHCI_PLE | OHCI_IE | OHCI_CLE | OHCI_BLE |
		OHCI_RATIO_1_4 | OHCI_HCFS_OPERATIONAL;
	/* And finally start it! */
	OWRITE4(sc, OHCI_CONTROL, ctl);

	/*
	 * The controller is now OPERATIONAL.  Set a some final
	 * registers that should be set earlier, but that the
	 * controller ignores when in the SUSPEND state.
	 */
	fm = (OREAD4(sc, OHCI_FM_INTERVAL) & OHCI_FIT) ^ OHCI_FIT;
	fm |= OHCI_FSMPS(ival) | ival;
	OWRITE4(sc, OHCI_FM_INTERVAL, fm);
#ifdef __riscos
        /* fix broken Tungsen board */
        OWRITE4(sc, OHCI_DONE_HEAD, 0);
#endif
	per = OHCI_PERIODIC(ival); /* 90% periodic */
	OWRITE4(sc, OHCI_PERIODIC_START, per);

	/* Fiddle the No OverCurrent Protection bit to avoid chip bug. */
	desca = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);
	OWRITE4(sc, OHCI_RH_DESCRIPTOR_A, desca | OHCI_NOCP);
	OWRITE4(sc, OHCI_RH_STATUS, OHCI_LPSC); /* Enable port power */
#ifdef __riscos
	for (i = 1; i <= OHCI_GET_NDP(desca); i++)
		(*ohci_ppower)(i, 1); /* Port power on */
#endif /*__riscos*/
	usb_delay_ms(&sc->sc_bus, OHCI_ENABLE_POWER_DELAY);
	OWRITE4(sc, OHCI_RH_DESCRIPTOR_A, desca);

	/*
	 * The AMD756 requires a delay before re-reading the register,
	 * otherwise it will occasionally report 0 ports.
	 */
        sc->sc_noport = 0;
        for (i = 0; i < 10 && sc->sc_noport == 0; i++) {
	usb_delay_ms(&sc->sc_bus, OHCI_READ_DESC_DELAY);
	sc->sc_noport = OHCI_GET_NDP(OREAD4(sc, OHCI_RH_DESCRIPTOR_A));
        }

#ifdef OHCI_DEBUG
	if (ohcidebug > 5)
		ohci_dumpregs(sc);
#endif

	/* Set up the bus struct. */
	sc->sc_bus.methods = &ohci_bus_methods;
	sc->sc_bus.pipe_size = sizeof(struct ohci_pipe);

#if defined(__NetBSD__) || defined(__OpenBSD__)
	sc->sc_control = sc->sc_intre = 0;
	sc->sc_powerhook = powerhook_establish(ohci_power, sc);
	sc->sc_shutdownhook = shutdownhook_establish(ohci_shutdown, sc);
#endif

	usb_callout_init(sc->sc_tmo_rhsc);
	DPRINTF(("ohci_init: done\n"));

	return (USBD_NORMAL_COMPLETION);

 bad5:
	for (i = 0; i < OHCI_NO_EDS; i++)
		ohci_free_sed(sc, sc->sc_eds[i]);
 bad4:
	ohci_free_sed(sc, sc->sc_isoc_head);
 bad3:
	ohci_free_sed(sc, sc->sc_bulk_head);
 bad2:
        ohci_free_sed(sc, sc->sc_ctrl_head);
 bad1:
	usb_freemem(&sc->sc_bus, &sc->sc_hccadma);
	return (err);
}

usbd_status
ohci_allocm(struct usbd_bus *bus, usb_dma_t *dma, u_int32_t size)
{
#if defined(__NetBSD__) || defined(__OpenBSD__)
	struct ohci_softc *sc = (struct ohci_softc *)bus;
#endif
        usbd_status status;

        status = usb_allocmem(&sc->sc_bus, size, 0, dma);
#ifdef __NetBSD__
        if (status == USBD_NOMEM)
                status = usb_reserve_allocm(&sc->sc_dma_reserve, dma, size);
#endif
        return status;
}

void
ohci_freem(struct usbd_bus *bus, usb_dma_t *dma)
{
#if defined(__NetBSD__) || defined(__OpenBSD__)
	struct ohci_softc *sc = (struct ohci_softc *)bus;
#endif
#ifdef __NetBSD__
        if (dma->block->flags & USB_DMA_RESERVE) {
                usb_reserve_freem(&((struct ohci_softc *)bus)->sc_dma_reserve,
                    dma);
                return;
        }
#endif
	usb_freemem(&sc->sc_bus, dma);
}

usbd_xfer_handle
ohci_allocx(struct usbd_bus *bus)
{
	struct ohci_softc *sc = (struct ohci_softc *)bus;
	usbd_xfer_handle xfer;

	xfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);
	if (xfer != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, next);
#ifdef DIAGNOSTIC
		if (xfer->busy_free != XFER_FREE) {
                        printf("ohci_allocx: xfer=%p not free, 0x%08x\n", xfer,
			       xfer->busy_free);
		}
#endif
	} else {
		xfer = malloc(sizeof(struct ohci_xfer), M_USB, M_NOWAIT);
	}
	if (xfer != NULL) {
		memset(xfer, 0, sizeof (struct ohci_xfer));
#ifdef DIAGNOSTIC
		xfer->busy_free = XFER_BUSY;
#endif
	}
	return (xfer);
}

void
ohci_freex(struct usbd_bus *bus, usbd_xfer_handle xfer)
{
	struct ohci_softc *sc = (struct ohci_softc *)bus;

#ifdef DIAGNOSTIC
	if (xfer->busy_free != XFER_BUSY) {
                printf("ohci_freex: xfer=%p not busy, 0x%08x\n", xfer,
		       xfer->busy_free);
		return;
	}
	xfer->busy_free = XFER_FREE;
#endif
	SIMPLEQ_INSERT_HEAD(&sc->sc_free_xfers, xfer, next);
}

/*
 * Shut down the controller when the system is going down.
 */
void
ohci_shutdown(void *v)
{
	ohci_softc_t *sc = v;

	DPRINTF(("ohci_shutdown: stopping the HC\n"));
	OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);
}

/*
 * Handle suspend/resume.
 *
 * We need to switch to polling mode here, because this routine is
 * called from an intterupt context.  This is all right since we
 * are almost suspended anyway.
 */
void
ohci_power(int why, void *v)
{
#ifndef __riscos
	ohci_softc_t *sc = v;
	u_int32_t ctl;
	int s;

#ifdef OHCI_DEBUG
	DPRINTF(("ohci_power: sc=%p, why=%d\n", sc, why));
	ohci_dumpregs(sc);
#endif

	s = splhardusb();
	switch (why) {
	case PWR_SUSPEND:
	case PWR_STANDBY:
		sc->sc_bus.use_polling++;
		ctl = OREAD4(sc, OHCI_CONTROL) & ~OHCI_HCFS_MASK;
		if (sc->sc_control == 0) {
			/*
			 * Preserve register values, in case that APM BIOS
			 * does not recover them.
			 */
			sc->sc_control = ctl;
			sc->sc_intre = OREAD4(sc, OHCI_INTERRUPT_ENABLE);
		}
		ctl |= OHCI_HCFS_SUSPEND;
		OWRITE4(sc, OHCI_CONTROL, ctl);
		usb_delay_ms(&sc->sc_bus, USB_RESUME_WAIT);
		sc->sc_bus.use_polling--;
		break;
	case PWR_RESUME:
		sc->sc_bus.use_polling++;
		/* Some broken BIOSes do not recover these values */
		OWRITE4(sc, OHCI_HCCA, DMAADDR(&sc->sc_hccadma, 0));
		OWRITE4(sc, OHCI_CONTROL_HEAD_ED, sc->sc_ctrl_head->physaddr);
		OWRITE4(sc, OHCI_BULK_HEAD_ED, sc->sc_bulk_head->physaddr);
		if (sc->sc_intre)
			OWRITE4(sc, OHCI_INTERRUPT_ENABLE,
				sc->sc_intre & (OHCI_ALL_INTRS | OHCI_MIE));
		if (sc->sc_control)
			ctl = sc->sc_control;
		else
			ctl = OREAD4(sc, OHCI_CONTROL);
		ctl |= OHCI_HCFS_RESUME;
		OWRITE4(sc, OHCI_CONTROL, ctl);
		usb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY);
		ctl = (ctl & ~OHCI_HCFS_MASK) | OHCI_HCFS_OPERATIONAL;
		OWRITE4(sc, OHCI_CONTROL, ctl);
		usb_delay_ms(&sc->sc_bus, USB_RESUME_RECOVERY);
		sc->sc_control = sc->sc_intre = 0;
		sc->sc_bus.use_polling--;
		break;
	case PWR_SOFTSUSPEND:
	case PWR_SOFTSTANDBY:
	case PWR_SOFTRESUME:
		break;
	}
	splx(s);
#endif
}

#ifdef OHCI_DEBUG
void
ohci_dumpregs(ohci_softc_t *sc)
{
	DPRINTF(("ohci_dumpregs: rev=0x%08x control=0x%08x command=0x%08x\n",
		 OREAD4(sc, OHCI_REVISION),
		 OREAD4(sc, OHCI_CONTROL),
		 OREAD4(sc, OHCI_COMMAND_STATUS)));
	DPRINTF(("               intrstat=0x%08x intre=0x%08x intrd=0x%08x\n",
		 OREAD4(sc, OHCI_INTERRUPT_STATUS),
		 OREAD4(sc, OHCI_INTERRUPT_ENABLE),
		 OREAD4(sc, OHCI_INTERRUPT_DISABLE)));
	DPRINTF(("               hcca=0x%08x percur=0x%08x ctrlhd=0x%08x\n",
		 OREAD4(sc, OHCI_HCCA),
		 OREAD4(sc, OHCI_PERIOD_CURRENT_ED),
		 OREAD4(sc, OHCI_CONTROL_HEAD_ED)));
	DPRINTF(("               ctrlcur=0x%08x bulkhd=0x%08x bulkcur=0x%08x\n",
		 OREAD4(sc, OHCI_CONTROL_CURRENT_ED),
		 OREAD4(sc, OHCI_BULK_HEAD_ED),
		 OREAD4(sc, OHCI_BULK_CURRENT_ED)));
	DPRINTF(("               done=0x%08x fmival=0x%08x fmrem=0x%08x\n",
		 OREAD4(sc, OHCI_DONE_HEAD),
		 OREAD4(sc, OHCI_FM_INTERVAL),
		 OREAD4(sc, OHCI_FM_REMAINING)));
	DPRINTF(("               fmnum=0x%08x perst=0x%08x lsthrs=0x%08x\n",
		 OREAD4(sc, OHCI_FM_NUMBER),
		 OREAD4(sc, OHCI_PERIODIC_START),
		 OREAD4(sc, OHCI_LS_THRESHOLD)));
	DPRINTF(("               desca=0x%08x descb=0x%08x stat=0x%08x\n",
		 OREAD4(sc, OHCI_RH_DESCRIPTOR_A),
		 OREAD4(sc, OHCI_RH_DESCRIPTOR_B),
		 OREAD4(sc, OHCI_RH_STATUS)));
	DPRINTF(("               port1=0x%08x port2=0x%08x\n",
		 OREAD4(sc, OHCI_RH_PORT_STATUS(1)),
		 OREAD4(sc, OHCI_RH_PORT_STATUS(2))));
	DPRINTF(("         HCCA: frame_number=0x%04x done_head=0x%08x\n",
		 le32toh(sc->sc_hcca->hcca_frame_number),
		 le32toh(sc->sc_hcca->hcca_done_head)));
}
#endif

Static int ohci_intr1(ohci_softc_t *);

int
ohci_intr(void *p)
{
	ohci_softc_t *sc = p;

	if (sc == NULL || sc->sc_dying)
		return (0);

	/* If we get an interrupt while polling, then just ignore it. */
	if (sc->sc_bus.use_polling) {
#ifdef DIAGNOSTIC
                DPRINTFN(16, ("ohci_intr: ignored interrupt while polling\n"));
#endif
                /* for level triggered intrs, should do something to ack */
                OWRITE4(sc, OHCI_INTERRUPT_STATUS,
                OREAD4(sc, OHCI_INTERRUPT_STATUS));
#ifdef __riscos
                riscos_irqclear(sc->sc_irqdevno);
#endif

		return (0);
	}

	return (ohci_intr1(sc));
}

Static int
ohci_intr1(ohci_softc_t *sc)
{
	u_int32_t intrs, eintrs;
	ohci_physaddr_t done;
#if defined(__riscos) && defined(OHCI_DEBUG)
        int temp_debug;
#endif

        DPRINTFN(14,("ohci_intr1: enter\n"));

	/* In case the interrupt occurs before initialization has completed. */
	if (sc == NULL || sc->sc_hcca == NULL) {
#ifdef DIAGNOSTIC
                printf("ohci_intr: sc->sc_hcca == NULL\n");
#endif
		return (0);
	}

        intrs = 0;
	done = le32toh(sc->sc_hcca->hcca_done_head);
	if (done != 0) {
		if (done & ~OHCI_DONE_INTRS)
			intrs = OHCI_WDH;
		if (done & OHCI_DONE_INTRS)
                {
#if defined(__riscos) && defined (OHCI_DEBUG)
                /* turn of debugging while clearing shared interrupt */
                temp_debug = ohcidebug;
                ohcidebug = 0;
#endif
			intrs |= OREAD4(sc, OHCI_INTERRUPT_STATUS);
#if defined(__riscos) && defined (OHCI_DEBUG)
                ohcidebug = temp_debug;
#endif
                }
		sc->sc_hcca->hcca_done_head = 0;
	} else {
#if defined(__riscos) && defined (OHCI_DEBUG)
                /* turn of debugging while clearing shared interrupt */
                temp_debug = ohcidebug;
                ohcidebug = 0;
#endif
		intrs = OREAD4(sc, OHCI_INTERRUPT_STATUS);
#if defined(__riscos) && defined (OHCI_DEBUG)
		ohcidebug = temp_debug;
#endif
		/*
		 * in case we were on a shared interrupt, and the PCI write
		 * hadn't come through from the controller, the read will
		 * have flushed it
		 */
                if (intrs & OHCI_WDH) {
                        DPRINTF(("ohci_intr: rereading donehead\n"));
                        done = sc->sc_hcca->hcca_done_head;
	                sc->sc_hcca->hcca_done_head = 0;
                }
	}

	if (!intrs)
		return (0);

	intrs &= ~OHCI_MIE;
#ifndef __riscos
	/*
	 * there's no need to acknowledge disabled interrupts, and in any case
	 * if this was a shared interrupt, the write is totally pointless
         */
	OWRITE4(sc, OHCI_INTERRUPT_STATUS, intrs); /* Acknowledge */
	riscos_irqclear();
#endif
	eintrs = intrs & sc->sc_eintrs;
	if (!eintrs)
		return (0);

#ifdef __riscos
	OWRITE4(sc, OHCI_INTERRUPT_STATUS, intrs); /* Acknowledge */
#endif

	sc->sc_bus.intr_context++;
	sc->sc_bus.no_intrs++;
        DPRINTFN(7, ("ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n",
		     sc, (u_int)intrs, OREAD4(sc, OHCI_INTERRUPT_STATUS),
		     (u_int)eintrs));

	if (eintrs & OHCI_SO) {
		sc->sc_overrun_cnt++;
#ifndef __riscos
		if (usbd_ratecheck(&sc->sc_overrun_ntc)) {
                        printf("%s: %u scheduling overruns\n",
			    USBDEVNAME(sc->sc_bus.bdev), sc->sc_overrun_cnt);
			sc->sc_overrun_cnt = 0;
		}
#endif
		/* XXX do what */
		eintrs &= ~OHCI_SO;
	}
	if (eintrs & OHCI_WDH) {
		ohci_add_done(sc, done &~ OHCI_DONE_INTRS);
#if defined(__riscos) && !defined(USB_USE_SOFTINTR)
		ohci_softintr(&sc->sc_bus);
#else
                usb_schedsoftintr(&sc->sc_bus);
#endif
		eintrs &= ~OHCI_WDH;
	}
	if (eintrs & OHCI_RD) {
                printf("%s: resume detect\n", USBDEVNAME(sc->sc_bus.bdev));
		/* XXX process resume detect */
	}
	if (eintrs & OHCI_UE) {
                printf("%s: unrecoverable error, controller halted\n",
		       USBDEVNAME(sc->sc_bus.bdev));
		OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);
		/* XXX what else */
	}
	if (eintrs & OHCI_RHSC) {
		/*
		 * Disable RHSC interrupt for now, because it will be
		 * on until the port has been reset.
		 */
//#ifdef __riscos
//              ohci_rhsc_able(sc, 0);   // moved here to ensure irqs off over rhsc
//#endif
		ohci_rhsc(sc, sc->sc_intrxfer);
//#ifndef __riscos
		ohci_rhsc_able(sc, 0);
//#endif
		/* Do not allow RHSC interrupts > 1 per second */
                usb_callout(sc->sc_tmo_rhsc, hz, ohci_rhsc_enable, sc);
		eintrs &= ~OHCI_RHSC;
	}
#ifdef __riscos
        /*
         * free up anything on the reclaim list, and zero the current head
         * pointers
         */
        if ((eintrs & OHCI_SF) && sc->sc_reclaimeds != NULL) {
                ohci_soft_ed_t* sed = sc->sc_reclaimeds;
                ohci_soft_ed_t* osed;
                ohci_physaddr_t ctrl_crnt = OREAD4(sc, OHCI_CONTROL_CURRENT_ED);
                ohci_physaddr_t bulk_crnt = OREAD4(sc, OHCI_BULK_CURRENT_ED);
                DPRINTF(("ohci_intr: reclaiming endpoints %p\n",sed));
                while (sed != NULL) {
                        if (sed->physaddr == ctrl_crnt)
                                OWRITE4(sc, OHCI_CONTROL_CURRENT_ED,
                                        ctrl_crnt = sed->ed.ed_nexted);
                        if (sed->physaddr == bulk_crnt)
                                OWRITE4(sc, OHCI_BULK_CURRENT_ED,
                                        bulk_crnt = sed->ed.ed_nexted);
                        /* maybe cancel outstanding tds here? */
                        osed = sed;
                        sed = sed->next;
                        ohci_free_sed (sc, osed);
                }
                sc->sc_reclaimeds = NULL;

                OWRITE4(sc, OHCI_CONTROL,
                    OREAD4(sc, OHCI_CONTROL) | (OHCI_CLE | OHCI_BLE));

                /* let OHCI_SF be disabled down below */
        }
#endif

	sc->sc_bus.intr_context--;

	if (eintrs != 0) {
		/* Block unprocessed interrupts. XXX */
		OWRITE4(sc, OHCI_INTERRUPT_DISABLE, eintrs);
		sc->sc_eintrs &= ~eintrs;
                printf("%s: blocking intrs 0x%x\n",
		       USBDEVNAME(sc->sc_bus.bdev), eintrs);
	}

#ifdef __riscos
        /*
         * make a read to process any outstanding posted writes.  Without this,
         * interrupts may not have actually been acknowledged, this will
         * flush through the status ackowledge as well
         */
        (void) OREAD4(sc, OHCI_INTERRUPT_DISABLE);
#endif

        return (1);
}

void
ohci_rhsc_able(ohci_softc_t *sc, int on)
{
	DPRINTFN(-1, ("ohci_rhsc_able: on=%d\n", on));
	if (on) {
		sc->sc_eintrs |= OHCI_RHSC;
		OWRITE4(sc, OHCI_INTERRUPT_ENABLE, OHCI_RHSC);
	} else {
		sc->sc_eintrs &= ~OHCI_RHSC;
		OWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_RHSC);
	}
#ifdef __riscos
        OREAD4(sc, OHCI_INTERRUPT_DISABLE);
#endif
}

void
ohci_rhsc_enable(void *v_sc)
{
	ohci_softc_t *sc = v_sc;
	int s;

	s = splhardusb();
	ohci_rhsc_able(sc, 1);
	splx(s);
}

#ifdef OHCI_DEBUG
char *ohci_cc_strs[] = {
	"NO_ERROR",
	"CRC",
	"BIT_STUFFING",
	"DATA_TOGGLE_MISMATCH",
	"STALL",
	"DEVICE_NOT_RESPONDING",
	"PID_CHECK_FAILURE",
	"UNEXPECTED_PID",
	"DATA_OVERRUN",
	"DATA_UNDERRUN",
	"BUFFER_OVERRUN",
	"BUFFER_UNDERRUN",
	"reserved",
	"reserved",
	"NOT_ACCESSED",
	"NOT_ACCESSED",
};
#endif

void
ohci_add_done(ohci_softc_t *sc, ohci_physaddr_t done)
{
	ohci_soft_itd_t *sitd, *sidone, **ip;
	ohci_soft_td_t  *std,  *sdone,  **p;

	/* Reverse the done list. */
	for (sdone = NULL, sidone = NULL; done != 0; ) {
		std = ohci_hash_find_td(sc, done);
		if (std != NULL) {
			std->dnext = sdone;
			done = le32toh(std->td.td_nexttd);
			sdone = std;
			DPRINTFN(10,("add TD %p\n", std));
			continue;
		}
		sitd = ohci_hash_find_itd(sc, done);
		if (sitd != NULL) {
			sitd->dnext = sidone;
			done = le32toh(sitd->itd.itd_nextitd);
			sidone = sitd;
			DPRINTFN(5,("add ITD %p\n", sitd));
			continue;
		}
                panic("ohci_add_done: panic: addr 0x%08lx not found", (u_long)done);
                done=NULL; // did it go earlier? jb 20040729
	}

	/* sdone & sidone now hold the done lists. */
	/* Put them on the already processed lists. */
	for (p = &sc->sc_sdone; *p != NULL; p = &(*p)->dnext)
		;
	*p = sdone;
	for (ip = &sc->sc_sidone; *ip != NULL; ip = &(*ip)->dnext)
		;
	*ip = sidone;
}

void
ohci_softintr(void *v)
{
	ohci_softc_t *sc = v;
	ohci_soft_itd_t *sitd, *sidone, *sitdnext;
	ohci_soft_td_t  *std,  *sdone,  *stdnext;
	usbd_xfer_handle xfer;
	struct ohci_pipe *opipe;
	int len, cc, s;
	int i, j, actlen, iframes, uedir;

	DPRINTFN(10,("ohci_softintr: enter\n"));

	sc->sc_bus.intr_context++;

	s = splhardusb();
	sdone = sc->sc_sdone;
	sc->sc_sdone = NULL;
	sidone = sc->sc_sidone;
	sc->sc_sidone = NULL;
	splx(s);

	DPRINTFN(10,("ohci_softintr: sdone=%p sidone=%p\n", sdone, sidone));

#ifdef OHCI_DEBUG
	if (ohcidebug > 10) {
		DPRINTF(("ohci_process_done: TD done:\n"));
		ohci_dump_tds(sdone);
	}
#endif

	for (std = sdone; std; std = stdnext) {
		xfer = std->xfer;
		stdnext = std->dnext;
		DPRINTFN(8, ("ohci_process_done: std=%p xfer=%p hcpriv=%p ",
				std, xfer, xfer ? xfer->hcpriv : 0));
		DPRINTFN(8, ("bus:%s addr:%d ",  /*ep:%d if:%d*/
				USBDEVNAME(sc->sc_bus.bdev),
				xfer->pipe->device->address));
		if (xfer == NULL) {
			/*
			 * xfer == NULL: There seems to be no xfer associated
			 * with this TD. It is tailp that happened to end up on
			 * the done queue.
			 * Shouldn't happen, but some chips are broken(?).
			 */
			continue;
		}
		if (xfer->status == USBD_CANCELLED ||
		    xfer->status == USBD_TIMEOUT) {
			DPRINTF(("ohci_process_done: cancel/timeout %p\n",
				 xfer));
			/* Handled by abort routine. */
			continue;
		}
		cc = OHCI_TD_GET_CC(le32toh(std->td.td_flags));
		DPRINTFN(8, ("ohci_process_done: cc=%x\n",cc));
		if (cc == OHCI_CC_NO_ERROR) {
			len = std->len;
			if (std->td.td_cbp != 0)
				len -= le32toh(std->td.td_be) -
				       le32toh(std->td.td_cbp) + 1;
			DPRINTFN(8, ("ohci_process_done: len=%d, flags=0x%x\n",
				      len, std->flags));
			if (std->flags & OHCI_ADD_LEN)
				xfer->actlen += len;
			if (std->flags & OHCI_CALL_DONE) {
				xfer->status = USBD_NORMAL_COMPLETION;
                                usb_uncallout(xfer->timeout_handle,
                                    ohci_timeout, xfer);
				s = splusb();
				usb_transfer_complete(xfer);
				splx(s);
			}
			if (std->flags & OHCI_CALL_DONE)
				usb_uncallout(xfer->timeout_handle,
				               ohci_timeout, xfer);
			ohci_free_std(sc, std);
		} else {
			/*
			 * Endpoint is halted.  First unlink all the TDs
			 * belonging to the failed transfer, and then restart
			 * the endpoint.
			 */
			ohci_soft_td_t *p, *n;
			opipe = (struct ohci_pipe *)xfer->pipe;
                        if (cc == OHCI_CC_DATA_OVERRUN)
                        {
                            logprintf("data overrun, len = %d\n", std->len);
                        }
                        if (cc == OHCI_CC_DATA_UNDERRUN)
                        {
                            logprintf("data underrun, len = %d, actlen = %d\n",
                                       std->len, xfer->actlen);
                        }

			DPRINTFN(8,("ohci_process_done: error cc=%d (%s) pipe=%p\n",
			  OHCI_TD_GET_CC(le32toh(std->td.td_flags)),
                          ohci_cc_strs[OHCI_TD_GET_CC(le32toh(std->td.td_flags))],opipe));

                        usb_uncallout(xfer->timeout_handle,
                            ohci_timeout, xfer);
			/* remove TDs */
			for (p = std; p->xfer == xfer; p = n) {
				n = p->nexttd;
				ohci_free_std(sc, p);
			}

			/* clear halt */
			opipe->sed->ed.ed_headp = htole32(p->physaddr);
			OWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_CLF);

			if (cc == OHCI_CC_STALL)
				xfer->status = USBD_STALLED;
			else
			{
				xfer->status = USBD_IOERROR;
				logprintf("Bus:%s addr:%d endpoint:%d halted but not stalled: error cc=%d\n",
				 USBDEVNAME(sc->sc_bus.bdev),
				 xfer->pipe->device->address,
				 xfer->pipe->endpoint->edesc->bEndpointAddress & 15,cc);
			}
			s = splusb();
			usb_transfer_complete(xfer);
			splx(s);
			usb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);
		}
	}

#ifdef OHCI_DEBUG
	if (ohcidebug > 10) {
		DPRINTF(("ohci_softintr: ITD done:\n"));
		ohci_dump_itds(sidone);
	}
#endif

	for (sitd = sidone; sitd != NULL; sitd = sitdnext) {
		xfer = sitd->xfer;
		sitdnext = sitd->dnext;
		DPRINTFN(1, ("ohci_process_done: sitd=%p xfer=%p hcpriv=%p\n",
			     sitd, xfer, xfer ? xfer->hcpriv : 0));
		if (xfer == NULL)
			continue;
#ifdef __riscos
		if (xfer->hcpriv == NULL)
		{
		        logprintf ("hcpriv = NULL\n");
			continue;
		}
#endif
		if (xfer->status == USBD_CANCELLED ||
		    xfer->status == USBD_TIMEOUT) {
			DPRINTF(("ohci_process_done: cancel/timeout %p\n",
				 xfer));
			/* Handled by abort routine. */
			continue;
		}
#ifdef DIAGNOSTIC
		if (sitd->isdone)
                        printf("ohci_softintr: sitd=%p is done\n", sitd);
		sitd->isdone = 1;
#endif
		if (sitd->flags & OHCI_CALL_DONE) {
			ohci_soft_itd_t *next;

			opipe = (struct ohci_pipe *)xfer->pipe;
			opipe->u.iso.inuse -= xfer->nframes;
			uedir = UE_GET_DIR(xfer->pipe->endpoint->edesc->
			    bEndpointAddress);
			xfer->status = USBD_NORMAL_COMPLETION;
			actlen = 0;
			for (i = 0, sitd = xfer->hcpriv;;
			    sitd = next) {
				next = sitd->nextitd;
				if (OHCI_ITD_GET_CC(le32toh(sitd->
				    itd.itd_flags)) != OHCI_CC_NO_ERROR)
                                {
					xfer->status = USBD_IOERROR;
					logprintf ("IOERROR: OHCI %d\n",
					    OHCI_ITD_GET_CC(le32toh(sitd->
				                itd.itd_flags)));
                                }
				/* For input, update frlengths with actual */
				/* XXX anything necessary for output? */
				if (uedir == UE_DIR_IN &&
				    xfer->status == USBD_NORMAL_COMPLETION) {
					iframes = OHCI_ITD_GET_FC(le32toh(
					    sitd->itd.itd_flags));
					for (j = 0; j < iframes; i++, j++) {
						len = le16toh(sitd->
						    itd.itd_offset[j]);
						len =
						    (OHCI_ITD_PSW_GET_CC(len) ==
						    OHCI_CC_NOT_ACCESSED) ? 0 :
						    OHCI_ITD_PSW_LENGTH(len);
						DPRINTFN(5,
						    ("frame %d, len %d\n",
						        j, len));
						xfer->frlengths[i] = len;
						actlen += len;
					}
				}
				if (sitd->flags & OHCI_CALL_DONE)
					break;
				ohci_free_sitd(sc, sitd);
			}
			ohci_free_sitd(sc, sitd);
			if (uedir == UE_DIR_IN &&
			    xfer->status == USBD_NORMAL_COMPLETION)
				xfer->actlen = actlen;
                        xfer->hcpriv = NULL;

			s = splusb();
			usb_transfer_complete(xfer);
			splx(s);
		}
	}

#ifdef USB_USE_SOFTINTR
	if (sc->sc_softwake) {
		sc->sc_softwake = 0;
		wakeup(&sc->sc_softwake);
	}
#endif /* USB_USE_SOFTINTR */

	sc->sc_bus.intr_context--;
	DPRINTFN(10,("ohci_softintr: done:\n"));
}

void
ohci_device_ctrl_done(usbd_xfer_handle xfer)
{
	DPRINTFN(10,("ohci_ctrl_done: xfer=%p\n", xfer));

#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & URQ_REQUEST)) {
                panic("ohci_device_ctrl_done: not a request");
	}
#endif
	xfer->hcpriv = NULL;
}

void
ohci_device_intr_done(usbd_xfer_handle xfer)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
	ohci_soft_ed_t *sed = opipe->sed;
	ohci_soft_td_t *data, *tail;


	DPRINTFN(10,("ohci_intr_done: xfer=%p, actlen=%d\n",
		     xfer, xfer->actlen));

	xfer->hcpriv = NULL;

	if (xfer->pipe->repeat) {
		data = opipe->tail.td;
		tail = ohci_alloc_std(sc); /* XXX should reuse TD */
		if (tail == NULL) {
			xfer->status = USBD_NOMEM;
			return;
		}
		tail->xfer = NULL;

		data->td.td_flags = htole32(
			OHCI_TD_IN | OHCI_TD_NOCC |
			OHCI_TD_SET_DI(1) | OHCI_TD_TOGGLE_CARRY);
		if (xfer->flags & USBD_SHORT_XFER_OK)
			data->td.td_flags |= htole32(OHCI_TD_R);
		data->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf, 0));
		data->nexttd = tail;
		data->td.td_nexttd = htole32(tail->physaddr);
		data->td.td_be = htole32(le32toh(data->td.td_cbp) +
			xfer->length - 1);
		data->len = xfer->length;
		data->xfer = xfer;
		data->flags = OHCI_CALL_DONE | OHCI_ADD_LEN;
		xfer->hcpriv = data;
		xfer->actlen = 0;

		sed->ed.ed_tailp = htole32(tail->physaddr);
		opipe->tail.td = tail;
	}
}

void
ohci_device_bulk_done(usbd_xfer_handle xfer)
{
	DPRINTFN(10,("ohci_bulk_done: xfer=%p, actlen=%d\n",
		     xfer, xfer->actlen));

	xfer->hcpriv = NULL;
}

void
ohci_rhsc(ohci_softc_t *sc, usbd_xfer_handle xfer)
{
	usbd_pipe_handle pipe;
	struct ohci_pipe *opipe;
	u_char *p;
	int i, m;
	int hstatus;

	hstatus = OREAD4(sc, OHCI_RH_STATUS);
	DPRINTF(("ohci_rhsc: sc=%p xfer=%p rhstatus=0x%08x\n",
		 sc, xfer, hstatus));

	if (xfer == NULL) {
		/* Just ignore the change. */
		return;
	}

	pipe = xfer->pipe;
	opipe = (struct ohci_pipe *)pipe;

	p = KERNADDR(&xfer->dmabuf, 0);
	m = min(sc->sc_noport, xfer->length * 8 - 1);
	memset(p, 0, xfer->length);
	for (i = 1; i <= m; i++) {
		/* Pick out CHANGE bits from the status reg. */
		if (OREAD4(sc, OHCI_RH_PORT_STATUS(i)) >> 16)
			p[i/8] |= 1 << (i%8);
	}
	DPRINTF(("ohci_rhsc: change=0x%02x\n", *p));
	xfer->actlen = xfer->length;
	xfer->status = USBD_NORMAL_COMPLETION;

	usb_transfer_complete(xfer);
}

void
ohci_root_intr_done(usbd_xfer_handle xfer)
{
	xfer->hcpriv = NULL;
}

void
ohci_root_ctrl_done(usbd_xfer_handle xfer)
{
	xfer->hcpriv = NULL;
}

/*
 * Wait here until controller claims to have an interrupt.
 * Then call ohci_intr and return.  Use timeout to avoid waiting
 * too long.
 */
void
ohci_waitintr(ohci_softc_t *sc, usbd_xfer_handle xfer)
{
	int timo = xfer->timeout;
	int usecs;
	u_int32_t intrs;

	xfer->status = USBD_IN_PROGRESS;
	for (usecs = timo * 1000000 / hz; usecs > 0; usecs -= 1000) {
		usb_delay_ms(&sc->sc_bus, 1);
		if (sc->sc_dying)
			break;
		intrs = OREAD4(sc, OHCI_INTERRUPT_STATUS) & sc->sc_eintrs;
		DPRINTFN(15,("ohci_waitintr: 0x%04x\n", intrs));
#ifdef OHCI_DEBUG
		if (ohcidebug > 15)
			ohci_dumpregs(sc);
#endif
		if (intrs) {
			ohci_intr1(sc);
			if (xfer->status != USBD_IN_PROGRESS)
				return;
		}
	}

	/* Timeout */
	DPRINTF(("ohci_waitintr: timeout\n"));
	xfer->status = USBD_TIMEOUT;
	usb_transfer_complete(xfer);
	/* XXX should free TD */
}

void
ohci_poll(struct usbd_bus *bus)
{
	ohci_softc_t *sc = (ohci_softc_t *)bus;
#ifdef OHCI_DEBUG
	static int last;
	int new;
	new = OREAD4(sc, OHCI_INTERRUPT_STATUS);
	if (new != last) {
		DPRINTFN(10,("ohci_poll: intrs=0x%04x\n", new));
		last = new;
	}
#endif

	if (OREAD4(sc, OHCI_INTERRUPT_STATUS) & sc->sc_eintrs)
		ohci_intr1(sc);
}

usbd_status
ohci_device_request(usbd_xfer_handle xfer)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	usb_device_request_t *req = &xfer->request;
	usbd_device_handle dev = opipe->pipe.device;
	ohci_softc_t *sc = (ohci_softc_t *)dev->bus;
	int addr = dev->address;
	ohci_soft_td_t *setup, *stat, *next, *tail;
	ohci_soft_ed_t *sed;
	int isread;
	int len;
	usbd_status err;
	int s;

	isread = req->bmRequestType & UT_READ;
	len = UGETW(req->wLength);

	DPRINTFN(3,("ohci_device_control type=0x%02x, request=0x%02x, "
                    "wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d"
                    "timeo=%d\n",
		    req->bmRequestType, req->bRequest, UGETW(req->wValue),
		    UGETW(req->wIndex), len, addr,
                    opipe->pipe.endpoint->edesc->bEndpointAddress,
                    xfer->timeout));

	setup = opipe->tail.td;
	stat = ohci_alloc_std(sc);
	if (stat == NULL) {
		err = USBD_NOMEM;
		goto bad1;
	}
	tail = ohci_alloc_std(sc);
	if (tail == NULL) {
		err = USBD_NOMEM;
		goto bad2;
	}
	tail->xfer = NULL;

	sed = opipe->sed;
	opipe->u.ctl.length = len;

	/* Update device address and length since they may have changed. */
	/* XXX This only needs to be done once, but it's too early in open. */
	/* XXXX Should not touch ED here! */
	sed->ed.ed_flags = htole32(
	 (le32toh(sed->ed.ed_flags) & ~(OHCI_ED_ADDRMASK | OHCI_ED_MAXPMASK)) |
	 OHCI_ED_SET_FA(addr) |
	 OHCI_ED_SET_MAXP(UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize)));

	next = stat;

	/* Set up data transaction */
	if (len != 0) {
		ohci_soft_td_t *std = stat;

		err = ohci_alloc_std_chain(opipe, sc, len, isread, xfer,
			  std, &stat);
		stat = stat->nexttd; /* point at free TD */
		if (err)
			goto bad3;
		/* Start toggle at 1 and then use the carried toggle. */
		std->td.td_flags &= htole32(~OHCI_TD_TOGGLE_MASK);
		std->td.td_flags |= htole32(OHCI_TD_TOGGLE_1);
	}

	memcpy(KERNADDR(&opipe->u.ctl.reqdma, 0), (void *)req, sizeof *req);

	setup->td.td_flags = htole32(OHCI_TD_SETUP | OHCI_TD_NOCC |
				     OHCI_TD_TOGGLE_0 | OHCI_TD_NOINTR);
	setup->td.td_cbp = htole32(DMAADDR(&opipe->u.ctl.reqdma, 0));
	setup->nexttd = next;
	setup->td.td_nexttd = htole32(next->physaddr);
	setup->td.td_be = htole32(le32toh(setup->td.td_cbp) + sizeof *req - 1);
	setup->len = 0;
	setup->xfer = xfer;
	setup->flags = 0;
	xfer->hcpriv = setup;

#ifdef __riscos
	stat->td.td_flags = htole32(
		((isread && len != 0) ? OHCI_TD_OUT : OHCI_TD_IN) |
		OHCI_TD_NOCC | OHCI_TD_TOGGLE_1 | OHCI_TD_SET_DI(1));
#else
	stat->td.td_flags = htole32(
		(isread ? OHCI_TD_OUT : OHCI_TD_IN) |
		OHCI_TD_NOCC | OHCI_TD_TOGGLE_1 | OHCI_TD_SET_DI(1));
#endif
	stat->td.td_cbp = 0;
	stat->nexttd = tail;
	stat->td.td_nexttd = htole32(tail->physaddr);
	stat->td.td_be = 0;
	stat->flags = OHCI_CALL_DONE;
	stat->len = 0;
	stat->xfer = xfer;

#ifdef OHCI_DEBUG
	if (ohcidebug > 5) {
		DPRINTF(("ohci_device_request:\n"));
		ohci_dump_ed(sed);
		ohci_dump_tds(setup);
	}
#endif

	/* Insert ED in schedule */
	s = splusb();
	sed->ed.ed_tailp = htole32(tail->physaddr);
	opipe->tail.td = tail;
	OWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_CLF);
#ifdef __riscos
        int status;
	status = OREAD4(sc, OHCI_COMMAND_STATUS);
#endif
	if (xfer->timeout && !sc->sc_bus.use_polling) {
                usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
			    ohci_timeout, xfer);
	}
        else
        {
            DPRINTF(("not setting callout\n"));
        }
	splx(s);

#ifdef OHCI_DEBUG
	if (ohcidebug > 20) {
		delay(10000);
		DPRINTF(("ohci_device_request: status=%x\n",
			 OREAD4(sc, OHCI_COMMAND_STATUS)));
		ohci_dumpregs(sc);
                printf("ctrl head:\n");
		ohci_dump_ed(sc->sc_ctrl_head);
                printf("sed:\n");
		ohci_dump_ed(sed);
		ohci_dump_tds(setup);
	}
#endif

	return (USBD_NORMAL_COMPLETION);

 bad3:
	ohci_free_std(sc, tail);
 bad2:
	ohci_free_std(sc, stat);
 bad1:
	return (err);
}

/*
 * Add an ED to the schedule.  Called at splusb().
 */
void
ohci_add_ed(ohci_soft_ed_t *sed, ohci_soft_ed_t *head)
{
	DPRINTFN(8,("ohci_add_ed: sed=%p head=%p\n", sed, head));

	SPLUSBCHECK;
	sed->next = head->next;
	sed->ed.ed_nexted = head->ed.ed_nexted;
	head->next = sed;
	head->ed.ed_nexted = htole32(sed->physaddr);
}

/*
 * Remove an ED from the schedule.  Called at splusb().
 */
void
ohci_rem_ed(ohci_soft_ed_t *sed, ohci_soft_ed_t *head)
{
	ohci_soft_ed_t *p;

	SPLUSBCHECK;

	/* XXX */
	for (p = head; p != NULL && p->next != sed; p = p->next)
		;
	if (p == NULL)
		panic("ohci_rem_ed: ED not found");
	p->next = sed->next;
	p->ed.ed_nexted = sed->ed.ed_nexted;
}

/*
 * When a transfer is completed the TD is added to the done queue by
 * the host controller.  This queue is the processed by software.
 * Unfortunately the queue contains the physical address of the TD
 * and we have no simple way to translate this back to a kernel address.
 * To make the translation possible (and fast) we use a hash table of
 * TDs currently in the schedule.  The physical address is used as the
 * hash value.
 */

#define HASH(a) (((a) >> 4) % OHCI_HASH_SIZE)
/* Called at splusb() */
void
ohci_hash_add_td(ohci_softc_t *sc, ohci_soft_td_t *std)
{
	int h = HASH(std->physaddr);

	SPLUSBCHECK;

	LIST_INSERT_HEAD(&sc->sc_hash_tds[h], std, hnext);
}

/* Called at splusb() */
void
ohci_hash_rem_td(ohci_softc_t *sc, ohci_soft_td_t *std)
{
	SPLUSBCHECK;

	LIST_REMOVE(std, hnext);
}

ohci_soft_td_t *
ohci_hash_find_td(ohci_softc_t *sc, ohci_physaddr_t a)
{
	int h = HASH(a);
	ohci_soft_td_t *std;

	for (std = LIST_FIRST(&sc->sc_hash_tds[h]);
	     std != NULL;
	     std = LIST_NEXT(std, hnext))
		if (std->physaddr == a)
			return (std);
	return (NULL);
}

/* Called at splusb() */
void
ohci_hash_add_itd(ohci_softc_t *sc, ohci_soft_itd_t *sitd)
{
	int h = HASH(sitd->physaddr);

	SPLUSBCHECK;

	DPRINTFN(10,("ohci_hash_add_itd: sitd=%p physaddr=0x%08lx\n",
		    sitd, (u_long)sitd->physaddr));

	LIST_INSERT_HEAD(&sc->sc_hash_itds[h], sitd, hnext);
}

/* Called at splusb() */
void
ohci_hash_rem_itd(ohci_softc_t *sc, ohci_soft_itd_t *sitd)
{
	SPLUSBCHECK;

	DPRINTFN(10,("ohci_hash_rem_itd: sitd=%p physaddr=0x%08lx\n",
		    sitd, (u_long)sitd->physaddr));

	LIST_REMOVE(sitd, hnext);
}

ohci_soft_itd_t *
ohci_hash_find_itd(ohci_softc_t *sc, ohci_physaddr_t a)
{
	int h = HASH(a);
	ohci_soft_itd_t *sitd;

	for (sitd = LIST_FIRST(&sc->sc_hash_itds[h]);
	     sitd != NULL;
	     sitd = LIST_NEXT(sitd, hnext))
		if (sitd->physaddr == a)
			return (sitd);
	return (NULL);
}

void
ohci_timeout(void *addr)
{
	struct ohci_xfer *oxfer = addr;
	struct ohci_pipe *opipe = (struct ohci_pipe *)oxfer->xfer.pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;

	DPRINTF(("ohci_timeout: oxfer=%p\n", oxfer));

	if (sc->sc_dying) {
		ohci_abort_xfer(&oxfer->xfer, USBD_TIMEOUT);
		return;
	}

	/* Execute the abort in a process context. */
#ifdef __riscos
        riscos_abort_pipe (addr);
#else
	usb_init_task(&oxfer->abort_task, ohci_timeout_task, addr);
	usb_add_task(oxfer->xfer.pipe->device, &oxfer->abort_task);
#endif
}

void
ohci_timeout_task(void *addr)
{
	usbd_xfer_handle xfer = addr;
	int s;

	DPRINTF(("ohci_timeout_task: xfer=%p\n", xfer));

	s = splusb();
	ohci_abort_xfer(xfer, USBD_TIMEOUT);
	splx(s);
}

#ifdef OHCI_DEBUG
void
ohci_dump_tds(ohci_soft_td_t *std)
{
	for (; std; std = std->nexttd)
		ohci_dump_td(std);
}

void
ohci_dump_td(ohci_soft_td_t *std)
{
	char sbuf[128];

#if defined(__riscos)
        unsigned int tdf = (int)le32toh(std->td.td_flags);
        sprintf (sbuf, "%s%s%s",
            (tdf & OHCI_TD_R)? "R ": "",
            (tdf & OHCI_TD_DP_MASK) == OHCI_TD_OUT? "OUT ":
	    (tdf & OHCI_TD_DP_MASK) == OHCI_TD_IN? "IN ":
	    (tdf & OHCI_TD_DP_MASK)? "RESERVEDD ": "SETUP ",
	    (tdf & OHCI_TD_TOGGLE_MASK) == OHCI_TD_TOGGLE_0? "TOG0 ":
	    (tdf & OHCI_TD_TOGGLE_MASK) == OHCI_TD_TOGGLE_1? "TOG1 ":
	    (tdf & OHCI_TD_TOGGLE_MASK)? "RESERVEDT ": "CARRY ");
#else
	bitmask_snprintf((u_int32_t)le32toh(std->td.td_flags),
			 "\20\23R\24OUT\25IN\31TOG1\32SETTOGGLE",
			 sbuf, sizeof(sbuf));
#endif

        printf("TD(%p) at %08lx: %s delay=%d ec=%d cc=%d\ncbp=0x%08lx "
	       "nexttd=0x%08lx be=0x%08lx\n",
	       std, (u_long)std->physaddr, sbuf,
	       OHCI_TD_GET_DI(le32toh(std->td.td_flags)),
	       OHCI_TD_GET_EC(le32toh(std->td.td_flags)),
	       OHCI_TD_GET_CC(le32toh(std->td.td_flags)),
	       (u_long)le32toh(std->td.td_cbp),
	       (u_long)le32toh(std->td.td_nexttd),
	       (u_long)le32toh(std->td.td_be));
}

void
ohci_dump_itd(ohci_soft_itd_t *sitd)
{
	int i;

        printf("ITD(%p) at %08lx: sf=%d di=%d fc=%d cc=%d\n"
	       "bp0=0x%08lx next=0x%08lx be=0x%08lx\n",
	       sitd, (u_long)sitd->physaddr,
	       OHCI_ITD_GET_SF(le32toh(sitd->itd.itd_flags)),
	       OHCI_ITD_GET_DI(le32toh(sitd->itd.itd_flags)),
	       OHCI_ITD_GET_FC(le32toh(sitd->itd.itd_flags)),
	       OHCI_ITD_GET_CC(le32toh(sitd->itd.itd_flags)),
	       (u_long)le32toh(sitd->itd.itd_bp0),
	       (u_long)le32toh(sitd->itd.itd_nextitd),
	       (u_long)le32toh(sitd->itd.itd_be));
	for (i = 0; i < OHCI_ITD_NOFFSET; i++)
                printf("offs[%d]=0x%04x ", i,
		       (u_int)le16toh(sitd->itd.itd_offset[i]));
        printf("\n");
}

void
ohci_dump_itds(ohci_soft_itd_t *sitd)
{
	for (; sitd; sitd = sitd->nextitd)
		ohci_dump_itd(sitd);
}

void
ohci_dump_ed(ohci_soft_ed_t *sed)
{
#if defined(__riscos)
	DPRINTF(("ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %x\ntailp=0x%08lx "
		 "headp=0x%08lx nexted=0x%08lx\n",
		 sed, (u_long)sed->physaddr,
		 OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),
		 OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),
		 OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)),
		 (int)le32toh(sed->ed.ed_flags),
		 (u_long)le32toh(sed->ed.ed_tailp),
		 (u_long)le32toh(sed->ed.ed_headp),
		 (u_long)le32toh(sed->ed.ed_nexted)));
#else
	char sbuf[128], sbuf2[128];

	bitmask_snprintf((u_int32_t)le32toh(sed->ed.ed_flags),
			 "\20\14OUT\15IN\16LOWSPEED\17SKIP\20ISO",
			 sbuf, sizeof(sbuf));
	bitmask_snprintf((u_int32_t)le32toh(sed->ed.ed_headp),
			 "\20\1HALT\2CARRY", sbuf2, sizeof(sbuf2));

        printf("ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d flags=%s\ntailp=0x%08lx "
		 "headflags=%s headp=0x%08lx nexted=0x%08lx\n",
		 sed, (u_long)sed->physaddr,
		 OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),
		 OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),
		 OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)), sbuf,
		 (u_long)le32toh(sed->ed.ed_tailp), sbuf2,
		 (u_long)le32toh(sed->ed.ed_headp),
		 (u_long)le32toh(sed->ed.ed_nexted));
#endif
}
#endif

usbd_status
ohci_open(usbd_pipe_handle pipe)
{
	usbd_device_handle dev = pipe->device;
	ohci_softc_t *sc = (ohci_softc_t *)dev->bus;
	usb_endpoint_descriptor_t *ed = pipe->endpoint->edesc;
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
	u_int8_t addr = dev->address;
	u_int8_t xfertype = ed->bmAttributes & UE_XFERTYPE;
	ohci_soft_ed_t *sed;
	ohci_soft_td_t *std;
	ohci_soft_itd_t *sitd;
	ohci_physaddr_t tdphys;
	u_int32_t fmt;
	usbd_status err;
	int s;
	int ival;

	DPRINTFN(1, ("ohci_open: pipe=%p, addr=%d, endpt=%d (%d)\n",
		     pipe, addr, ed->bEndpointAddress, sc->sc_addr));

	if (sc->sc_dying)
		return (USBD_IOERROR);

	std = NULL;
	sed = NULL;

	if (addr == sc->sc_addr) {
		switch (ed->bEndpointAddress) {
		case USB_CONTROL_ENDPOINT:
			pipe->methods = &ohci_root_ctrl_methods;
			break;
		case UE_DIR_IN | OHCI_INTR_ENDPT:
			pipe->methods = &ohci_root_intr_methods;
			break;
		default:
			return (USBD_INVAL);
		}
	} else {
		sed = ohci_alloc_sed(sc);
		if (sed == NULL)
			goto bad0;
		opipe->sed = sed;
		if (xfertype == UE_ISOCHRONOUS) {
			sitd = ohci_alloc_sitd(sc);
			if (sitd == NULL)
				goto bad1;
			opipe->tail.itd = sitd;
			tdphys = sitd->physaddr;
			fmt = OHCI_ED_FORMAT_ISO;
			if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN)
				fmt |= OHCI_ED_DIR_IN;
			else
				fmt |= OHCI_ED_DIR_OUT;
		} else {
			std = ohci_alloc_std(sc);
			if (std == NULL)
				goto bad1;
			opipe->tail.td = std;
			tdphys = std->physaddr;
			fmt = OHCI_ED_FORMAT_GEN | OHCI_ED_DIR_TD;
		}
		sed->ed.ed_flags = htole32(
			OHCI_ED_SET_FA(addr) |
                        OHCI_ED_SET_EN(UE_GET_ADDR(ed->bEndpointAddress)) |
			(dev->speed == USB_SPEED_LOW ? OHCI_ED_SPEED : 0) |
			fmt |
			OHCI_ED_SET_MAXP(UGETW(ed->wMaxPacketSize)));
		sed->ed.ed_headp = sed->ed.ed_tailp = htole32(tdphys);

		switch (xfertype) {
		case UE_CONTROL:
			pipe->methods = &ohci_device_ctrl_methods;
			err = usb_allocmem(&sc->sc_bus,
				  sizeof(usb_device_request_t),
				  0, &opipe->u.ctl.reqdma);
			if (err)
				goto bad;
			s = splusb();
			ohci_add_ed(sed, sc->sc_ctrl_head);
			splx(s);
			break;
		case UE_INTERRUPT:
			pipe->methods = &ohci_device_intr_methods;
			ival = pipe->interval;
			if (ival == USBD_DEFAULT_INTERVAL)
				ival = ed->bInterval;
			return (ohci_device_setintr(sc, opipe, ival));
		case UE_ISOCHRONOUS:
			pipe->methods = &ohci_device_isoc_methods;
			return (ohci_setup_isoc(pipe));
		case UE_BULK:
			pipe->methods = &ohci_device_bulk_methods;
			s = splusb();
			ohci_add_ed(sed, sc->sc_bulk_head);
			splx(s);
			break;
		}
	}
	return (USBD_NORMAL_COMPLETION);

 bad:
	if (std != NULL)
		ohci_free_std(sc, std);
 bad1:
	if (sed != NULL)
		ohci_free_sed(sc, sed);
 bad0:
	return (USBD_NOMEM);

}

/*
 * Close a reqular pipe.
 * Assumes that there are no pending transactions.
 */
void
ohci_close_pipe(usbd_pipe_handle pipe, ohci_soft_ed_t *head)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;
	ohci_soft_ed_t *sed = opipe->sed;
	int s, w;

	s = splusb();
#ifdef __riscos
        /* always do this */
	sed->ed.ed_flags |= htole32(OHCI_ED_SKIP);
#endif
#ifdef DIAGNOSTIC
#ifndef __riscos
	sed->ed.ed_flags |= htole32(OHCI_ED_SKIP);
#endif
	if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
	    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK)) {
		ohci_soft_td_t *std;
		std = ohci_hash_find_td(sc, le32toh(sed->ed.ed_headp));
                printf("ohci_close_pipe: pipe not empty sed=%p hd=0x%x "
		       "tl=0x%x pipe=%p, std=%p\n", sed,
		       (int)le32toh(sed->ed.ed_headp),
		       (int)le32toh(sed->ed.ed_tailp),
		       pipe, std);
#ifdef USB_DEBUG
#ifndef __riscos
		usbd_dump_pipe(&opipe->pipe);
#endif
#endif
#ifdef OHCI_DEBUG
		ohci_dump_ed(sed);
		if (std)
			ohci_dump_td(std);
#endif
		usb_delay_ms(&sc->sc_bus, 2);
		if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
		    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK))
                        printf("ohci_close_pipe: pipe still not empty\n");
	}
#endif
	ohci_rem_ed(sed, head);
#ifndef __riscos
	splx(s);
#endif
#ifdef __riscos
        /* put the endpoint on the reclaim list, and process it on the next
           SOF, disabling list processing before then (should really only
           deactivate appropriate list) */
        sed->next = sc->sc_reclaimeds;
        sc->sc_reclaimeds = sed;
        DPRINTF(("ohci_close_pipe: adding %p to reclaim list\n", sed));
        OWRITE4(sc, OHCI_INTERRUPT_ENABLE, OHCI_SF);
        OWRITE4(sc, OHCI_INTERRUPT_STATUS, OHCI_SF);
        sc->sc_eintrs |= OHCI_SF;
        OWRITE4(sc, OHCI_CONTROL,
                OREAD4(sc, OHCI_CONTROL) & ~(OHCI_CLE | OHCI_BLE));

        /* read again to flush it */
        w = OREAD4(sc, OHCI_CONTROL);
        splx(s);
#else
	/* Make sure the host controller is not touching this ED */
	usb_delay_ms(&sc->sc_bus, 1);
	splx(s);
	ohci_free_sed(sc, opipe->sed);
#endif
}

/*
 * Abort a device request.
 * If this routine is called at splusb() it guarantees that the request
 * will be removed from the hardware scheduling and that the callback
 * for it will be called with USBD_CANCELLED status.
 * It's impossible to guarantee that the requested transfer will not
 * have happened since the hardware runs concurrently.
 * If the transaction has already happened we rely on the ordinary
 * interrupt processing to process it.
 */
void
ohci_abort_xfer(usbd_xfer_handle xfer, usbd_status status)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
	ohci_soft_ed_t *sed = opipe->sed;
	ohci_soft_td_t *p, *n;
	ohci_physaddr_t headp;
	int s, hit;

	DPRINTF(("ohci_abort_xfer: xfer=%p pipe=%p sed=%p\n", xfer, opipe,sed));

	if (sc->sc_dying) {
		/* If we're dying, just do the software part. */
		s = splusb();
		xfer->status = status;	/* make software ignore it */
		usb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);
		usb_transfer_complete(xfer);
		splx(s);
	}

#ifndef __riscos
	if (xfer->device->bus->intr_context || !curproc)
		panic("ohci_abort_xfer: not in process context");
#endif

	/*
	 * Step 1: Make interrupt routine and hardware ignore xfer.
	 */
	s = splusb();
	xfer->status = status;	/* make software ignore it */
	usb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);
	splx(s);
	DPRINTFN(1,("ohci_abort_xfer: stop ed=%p\n", sed));
	sed->ed.ed_flags |= htole32(OHCI_ED_SKIP); /* force hardware skip */

	/*
	 * Step 2: Wait until we know hardware has finished any possible
	 * use of the xfer.  Also make sure the soft interrupt routine
	 * has run.
	 */
	usb_delay_ms(opipe->pipe.device->bus, 20); /* Hardware finishes in 1ms */
	s = splusb();
#ifdef USB_USE_SOFTINTR
	sc->sc_softwake = 1;
#endif /* USB_USE_SOFTINTR */
#if defined(__riscos) && !defined(USB_USE_SOFTINTR)
        ohci_softintr(&sc->sc_bus);
#else
	usb_schedsoftintr(&sc->sc_bus);
#endif
#ifdef USB_USE_SOFTINTR
#ifdef __riscos
	tsleep(&sc->sc_softwake, PZERO, "ohciab", 0, 1);
#else
	tsleep(&sc->sc_softwake, PZERO, "ohciab", 0);
#endif
#endif /* USB_USE_SOFTINTR */
	splx(s);

	/*
	 * Step 3: Remove any vestiges of the xfer from the hardware.
	 * The complication here is that the hardware may have executed
	 * beyond the xfer we're trying to abort.  So as we're scanning
	 * the TDs of this xfer we check if the hardware points to
	 * any of them.
	 */
	s = splusb();		/* XXX why? */
	p = xfer->hcpriv;
#ifdef DIAGNOSTIC
	if (p == NULL) {
		splx(s);
                printf("ohci_abort_xfer: hcpriv is NULL\n");
		return;
	}
#endif
#ifdef OHCI_DEBUG
	if (ohcidebug > 1) {
		DPRINTF(("ohci_abort_xfer: sed=\n"));
		ohci_dump_ed(sed);
		ohci_dump_tds(p);
	}
#endif
	headp = le32toh(sed->ed.ed_headp) & OHCI_HEADMASK;
	hit = 0;
	for (; p->xfer == xfer; p = n) {
		hit |= headp == p->physaddr;
		n = p->nexttd;
                if(OHCI_TD_GET_CC(le32toh(p->td.td_flags))==OHCI_CC_NOT_ACCESSED )
		ohci_free_std(sc, p);
	}
	/* Zap headp register if hardware pointed inside the xfer. */
	if (hit) {
                DPRINTFN(1,("ohci_abort_xfer: set hd=0x%08x, tl=0x%08x\n",
			    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));
		sed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */
	} else {
		DPRINTFN(1,("ohci_abort_xfer: no hit\n"));
	}

	/*
	 * Step 4: Turn on hardware again.
	 */
	sed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */

	/*
	 * Step 5: Execute callback.
	 */
	logprintf("before complete: %p\n", SIMPLEQ_FIRST(&xfer->pipe->queue));

	usb_transfer_complete(xfer);
	logprintf("after complete: %p\n", SIMPLEQ_FIRST(&xfer->pipe->queue));

	splx(s);
}

/*
 * Data structures and routines to emulate the root hub.
 */
Static const usb_device_descriptor_t ohci_devd = {
	USB_DEVICE_DESCRIPTOR_SIZE,
	UDESC_DEVICE,		/* type */
	{0x00, 0x01},		/* USB version */
	UDCLASS_HUB,		/* class */
	UDSUBCLASS_HUB,		/* subclass */
	UDPROTO_FSHUB,
	64,			/* max packet */
	{0},{0},{0x00,0x01},	/* device id */
	1,2,0,			/* string indicies */
	1			/* # of configurations */
};

Static const usb_config_descriptor_t ohci_confd = {
	USB_CONFIG_DESCRIPTOR_SIZE,
	UDESC_CONFIG,
	{USB_CONFIG_DESCRIPTOR_SIZE +
	 USB_INTERFACE_DESCRIPTOR_SIZE +
	 USB_ENDPOINT_DESCRIPTOR_SIZE},
	1,
	1,
	0,
	UC_SELF_POWERED,
	0			/* max power */
};

Static const usb_interface_descriptor_t ohci_ifcd = {
	USB_INTERFACE_DESCRIPTOR_SIZE,
	UDESC_INTERFACE,
	0,
	0,
	1,
	UICLASS_HUB,
	UISUBCLASS_HUB,
	UIPROTO_FSHUB,
	0
};

Static const usb_endpoint_descriptor_t ohci_endpd = {
	USB_ENDPOINT_DESCRIPTOR_SIZE,
	UDESC_ENDPOINT,
	UE_DIR_IN | OHCI_INTR_ENDPT,
	UE_INTERRUPT,
	{8, 0},			/* max packet */
	255
};

Static const usb_hub_descriptor_t ohci_hubd = {
	USB_HUB_DESCRIPTOR_SIZE,
	UDESC_HUB,
	0,
	{0,0},
	0,
	0,
	{0},
};

Static int
ohci_str(usb_string_descriptor_t *p, int l, const char *s)
{
	int i;

	if (l == 0)
		return (0);
	p->bLength = 2 * strlen(s) + 2;
	if (l == 1)
		return (1);
	p->bDescriptorType = UDESC_STRING;
	l -= 2;
	for (i = 0; s[i] && l > 1; i++, l -= 2)
		USETW2(p->bString[i], 0, s[i]);
	return (2*i+2);
}

/*
 * Simulate a hardware hub by handling all the necessary requests.
 */
Static usbd_status
ohci_root_ctrl_transfer(usbd_xfer_handle xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ohci_root_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

Static usbd_status
ohci_root_ctrl_start(usbd_xfer_handle xfer)
{
	ohci_softc_t *sc = (ohci_softc_t *)xfer->pipe->device->bus;
	usb_device_request_t *req;
	void *buf = NULL;
	int port, i;
	int s, len, value, index, l, totlen = 0;
	usb_port_status_t ps;
	usb_hub_descriptor_t hubd;
	usb_device_descriptor_t devd;
	usbd_status err;
	u_int32_t v;

	if (sc->sc_dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & URQ_REQUEST))
		/* XXX panic */
		return (USBD_INVAL);
#endif
	req = &xfer->request;

        DPRINTFN(4,("ohci_root_ctrl_control type=0x%02x request=%02x\n",
		    req->bmRequestType, req->bRequest));

	len = UGETW(req->wLength);
	value = UGETW(req->wValue);
	index = UGETW(req->wIndex);
	DPRINTFN(4, ("value=0x%04x\n", value));

	if (len != 0)
		buf = KERNADDR(&xfer->dmabuf, 0);

#define C(x,y) ((x) | ((y) << 8))
	switch(C(req->bRequest, req->bmRequestType)) {
	case C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):
	case C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):
	case C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):
		/*
		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops
		 * for the integrated root hub.
		 */
		break;
	case C(UR_GET_CONFIG, UT_READ_DEVICE):
		if (len > 0) {
			*(u_int8_t *)buf = sc->sc_conf;
			totlen = 1;
		}
		break;
	case C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):
		DPRINTFN(8,("ohci_root_ctrl_control wValue=0x%04x\n", value));
		switch(value >> 8) {
		case UDESC_DEVICE:
			if ((value & 0xff) != 0) {
				err = USBD_IOERROR;
				goto ret;
			}
			devd = ohci_devd;
			USETW(devd.idVendor, sc->sc_id_vendor);
			totlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);
			memcpy(buf, (void *)&devd, l);
			break;
		case UDESC_CONFIG:
			if ((value & 0xff) != 0) {
				err = USBD_IOERROR;
				goto ret;
			}
			totlen = l = min(len, USB_CONFIG_DESCRIPTOR_SIZE);
			memcpy(buf, (void *)&ohci_confd, l);
			buf = (char *)buf + l;
			len -= l;
			l = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);
			totlen += l;
			memcpy(buf, (void *)&ohci_ifcd, l);
			buf = (char *)buf + l;
			len -= l;
			l = min(len, USB_ENDPOINT_DESCRIPTOR_SIZE);
			totlen += l;
			memcpy(buf, (void *)&ohci_endpd, l);
			break;
		case UDESC_STRING:
			if (len == 0)
				break;
			*(u_int8_t *)buf = 0;
			totlen = 1;
			switch (value & 0xff) {
                        case 0: /* Language table */
                                totlen = ohci_str(buf, len, "\001");
                                break;
			case 1: /* Vendor */
				totlen = ohci_str(buf, len, sc->sc_vendor);
				break;
			case 2: /* Product */
				totlen = ohci_str(buf, len, "OHCI Root Hub");
				break;
			}
			break;
		default:
			err = USBD_IOERROR;
			goto ret;
		}
		break;
	case C(UR_GET_INTERFACE, UT_READ_INTERFACE):
		if (len > 0) {
			*(u_int8_t *)buf = 0;
			totlen = 1;
		}
		break;
	case C(UR_GET_STATUS, UT_READ_DEVICE):
		if (len > 1) {
			USETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);
			totlen = 2;
		}
		break;
	case C(UR_GET_STATUS, UT_READ_INTERFACE):
	case C(UR_GET_STATUS, UT_READ_ENDPOINT):
		if (len > 1) {
			USETW(((usb_status_t *)buf)->wStatus, 0);
			totlen = 2;
		}
		break;
	case C(UR_SET_ADDRESS, UT_WRITE_DEVICE):
		if (value >= USB_MAX_DEVICES) {
			err = USBD_IOERROR;
			goto ret;
		}
		sc->sc_addr = value;
		break;
	case C(UR_SET_CONFIG, UT_WRITE_DEVICE):
		if (value != 0 && value != 1) {
			err = USBD_IOERROR;
			goto ret;
		}
		sc->sc_conf = value;
		break;
	case C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):
		break;
	case C(UR_SET_FEATURE, UT_WRITE_DEVICE):
	case C(UR_SET_FEATURE, UT_WRITE_INTERFACE):
	case C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):
		err = USBD_IOERROR;
		goto ret;
	case C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):
		break;
	case C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):
		break;
	/* Hub requests */
	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_DEVICE):
		break;
	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_OTHER):
		DPRINTFN(8, ("ohci_root_ctrl_control: UR_CLEAR_PORT_FEATURE "
			     "port=%d feature=%d\n",
			     index, value));
		if (index < 1 || index > sc->sc_noport) {
			err = USBD_IOERROR;
			goto ret;
		}
		port = OHCI_RH_PORT_STATUS(index);
		switch(value) {
		case UHF_PORT_ENABLE:
			OWRITE4(sc, port, UPS_CURRENT_CONNECT_STATUS);
			break;
		case UHF_PORT_SUSPEND:
			OWRITE4(sc, port, UPS_OVERCURRENT_INDICATOR);
			break;
		case UHF_PORT_POWER:
			/* Yes, writing to the LOW_SPEED bit clears power. */
			OWRITE4(sc, port, UPS_LOW_SPEED);
#ifdef __riscos
			(*ohci_ppower)(index, 0); /* Port power off */
#endif /*__riscos*/
			break;
		case UHF_C_PORT_CONNECTION:
			OWRITE4(sc, port, UPS_C_CONNECT_STATUS << 16);
			break;
		case UHF_C_PORT_ENABLE:
			OWRITE4(sc, port, UPS_C_PORT_ENABLED << 16);
			break;
		case UHF_C_PORT_SUSPEND:
			OWRITE4(sc, port, UPS_C_SUSPEND << 16);
			break;
		case UHF_C_PORT_OVER_CURRENT:
			OWRITE4(sc, port, UPS_C_OVERCURRENT_INDICATOR << 16);
			break;
		case UHF_C_PORT_RESET:
			OWRITE4(sc, port, UPS_C_PORT_RESET << 16);
			break;
		default:
			err = USBD_IOERROR;
			goto ret;
		}
		switch(value) {
		case UHF_C_PORT_CONNECTION:
		case UHF_C_PORT_ENABLE:
		case UHF_C_PORT_SUSPEND:
		case UHF_C_PORT_OVER_CURRENT:
                case UHF_C_PORT_RESET:
			/* Enable RHSC interrupt if condition is cleared. */
			if ((OREAD4(sc, port) >> 16) == 0)
				ohci_rhsc_able(sc, 1);
			break;
		default:
			break;
		}
		break;
	case C(UR_GET_DESCRIPTOR, UT_READ_CLASS_DEVICE):
                if ((value & 0xff) != 0) {
			err = USBD_IOERROR;
			goto ret;
		}
		v = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);
		hubd = ohci_hubd;
		hubd.bNbrPorts = sc->sc_noport;
		USETW(hubd.wHubCharacteristics,
		      (v & OHCI_NPS ? UHD_PWR_NO_SWITCH :
		       v & OHCI_PSM ? UHD_PWR_GANGED : UHD_PWR_INDIVIDUAL)
		      /* XXX overcurrent */
		      );
		hubd.bPwrOn2PwrGood = OHCI_GET_POTPGT(v);
		v = OREAD4(sc, OHCI_RH_DESCRIPTOR_B);
		for (i = 0, l = sc->sc_noport; l > 0; i++, l -= 8, v >>= 8)
			hubd.DeviceRemovable[i++] = (u_int8_t)v;
		hubd.bDescLength = USB_HUB_DESCRIPTOR_SIZE + i;
		l = min(len, hubd.bDescLength);
		totlen = l;
		memcpy(buf, (void *)&hubd, l);
		break;
	case C(UR_GET_STATUS, UT_READ_CLASS_DEVICE):
		if (len != 4) {
			err = USBD_IOERROR;
			goto ret;
		}
		memset(buf, 0, len); /* ? XXX */
		totlen = len;
		break;
	case C(UR_GET_STATUS, UT_READ_CLASS_OTHER):
		DPRINTFN(8,("ohci_root_ctrl_transfer: get port status i=%d\n",
			    index));
		if (index < 1 || index > sc->sc_noport) {
			err = USBD_IOERROR;
			goto ret;
		}
		if (len != 4) {
			err = USBD_IOERROR;
			goto ret;
		}
		v = OREAD4(sc, OHCI_RH_PORT_STATUS(index));
		DPRINTFN(8,("ohci_root_ctrl_transfer: port status=0x%04x\n",
			    v));
		USETW(ps.wPortStatus, v);
		USETW(ps.wPortChange, v >> 16);
		l = min(len, sizeof ps);
		memcpy(buf, (void *)&ps, l);
		totlen = l;
		break;
	case C(UR_SET_DESCRIPTOR, UT_WRITE_CLASS_DEVICE):
		err = USBD_IOERROR;
		goto ret;
	case C(UR_SET_FEATURE, UT_WRITE_CLASS_DEVICE):
		break;
	case C(UR_SET_FEATURE, UT_WRITE_CLASS_OTHER):
		if (index < 1 || index > sc->sc_noport) {
			err = USBD_IOERROR;
			goto ret;
		}
		port = OHCI_RH_PORT_STATUS(index);
		switch(value) {
		case UHF_PORT_ENABLE:
			OWRITE4(sc, port, UPS_PORT_ENABLED);
			break;
		case UHF_PORT_SUSPEND:
			OWRITE4(sc, port, UPS_SUSPEND);
			break;
		case UHF_PORT_RESET:
			DPRINTFN(5,("ohci_root_ctrl_transfer: reset port %d\n",
				    index));
			OWRITE4(sc, port, UPS_RESET);
			for (i = 0; i < 5; i++) {
				if ((OREAD4(sc, port) & UPS_RESET) == 0)
					break;
				usb_delay_ms(&sc->sc_bus,
					     USB_PORT_ROOT_RESET_DELAY);
				if (sc->sc_dying) {
					err = USBD_IOERROR;
					goto ret;
				}
                                if ((OREAD4(sc, port) & UPS_RESET) == 0)
                                        break;
			}
			DPRINTFN(8,("ohci port %d reset, status = 0x%04x\n",
				    index, OREAD4(sc, port)));
			break;
		case UHF_PORT_POWER:
			DPRINTFN(2,("ohci_root_ctrl_transfer: set port power "
				    "%d\n", index));
#ifdef __riscos
			(*ohci_ppower)(index, 1); /* Port power on */
#endif /*__riscos*/
			OWRITE4(sc, port, UPS_PORT_POWER);
			break;
		default:
			err = USBD_IOERROR;
			goto ret;
		}
		break;
	default:
		err = USBD_IOERROR;
		goto ret;
	}
	xfer->actlen = totlen;
	err = USBD_NORMAL_COMPLETION;
 ret:
	xfer->status = err;
	s = splusb();
	usb_transfer_complete(xfer);
	splx(s);
	return (USBD_IN_PROGRESS);
}

/* Abort a root control request. */
Static void
ohci_root_ctrl_abort(usbd_xfer_handle xfer)
{
	/* Nothing to do, all transfers are synchronous. */
}

/* Close the root pipe. */
Static void
ohci_root_ctrl_close(usbd_pipe_handle pipe)
{
	DPRINTF(("ohci_root_ctrl_close\n"));
	/* Nothing to do. */
}

Static usbd_status
ohci_root_intr_transfer(usbd_xfer_handle xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ohci_root_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

Static usbd_status
ohci_root_intr_start(usbd_xfer_handle xfer)
{
	usbd_pipe_handle pipe = xfer->pipe;
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;

	if (sc->sc_dying)
		return (USBD_IOERROR);

	sc->sc_intrxfer = xfer;

	return (USBD_IN_PROGRESS);
}

/* Abort a root interrupt request. */
Static void
ohci_root_intr_abort(usbd_xfer_handle xfer)
{
	int s;

	if (xfer->pipe->intrxfer == xfer) {
		DPRINTF(("ohci_root_intr_abort: remove\n"));
		xfer->pipe->intrxfer = NULL;
	}
	xfer->status = USBD_CANCELLED;
	s = splusb();
	usb_transfer_complete(xfer);
	splx(s);
}

/* Close the root pipe. */
Static void
ohci_root_intr_close(usbd_pipe_handle pipe)
{
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;

	DPRINTF(("ohci_root_intr_close\n"));

	sc->sc_intrxfer = NULL;
}

/************************/

Static usbd_status
ohci_device_ctrl_transfer(usbd_xfer_handle xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ohci_device_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

Static usbd_status
ohci_device_ctrl_start(usbd_xfer_handle xfer)
{
	ohci_softc_t *sc = (ohci_softc_t *)xfer->pipe->device->bus;
	usbd_status err;

	if (sc->sc_dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & URQ_REQUEST)) {
		/* XXX panic */
                printf("ohci_device_ctrl_transfer: not a request\n");
		return (USBD_INVAL);
	}
#endif

	err = ohci_device_request(xfer);
	if (err)
		return (err);

	if (sc->sc_bus.use_polling)
		ohci_waitintr(sc, xfer);
	return (USBD_IN_PROGRESS);
}

/* Abort a device control request. */
Static void
ohci_device_ctrl_abort(usbd_xfer_handle xfer)
{
	DPRINTF(("ohci_device_ctrl_abort: xfer=%p\n", xfer));
	ohci_abort_xfer(xfer, USBD_CANCELLED);
}

/* Close a device control pipe. */
Static void
ohci_device_ctrl_close(usbd_pipe_handle pipe)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;

	DPRINTF(("ohci_device_ctrl_close: pipe=%p\n", pipe));
	ohci_close_pipe(pipe, sc->sc_ctrl_head);
	ohci_free_std(sc, opipe->tail.td);
}

/************************/

Static void
ohci_device_clear_toggle(usbd_pipe_handle pipe)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;

	opipe->sed->ed.ed_headp &= htole32(~OHCI_TOGGLECARRY);
}

Static void
ohci_noop(usbd_pipe_handle pipe)
{
}

Static usbd_status
ohci_device_bulk_transfer(usbd_xfer_handle xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ohci_device_bulk_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

Static usbd_status
ohci_device_bulk_start(usbd_xfer_handle xfer)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	usbd_device_handle dev = opipe->pipe.device;
	ohci_softc_t *sc = (ohci_softc_t *)dev->bus;
	int addr = dev->address;
	ohci_soft_td_t *data, *tail, *tdp;
	ohci_soft_ed_t *sed;
	int s, len, isread, endpt;
	usbd_status err;

	if (sc->sc_dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (xfer->rqflags & URQ_REQUEST) {
		/* XXX panic */
                printf("ohci_device_bulk_start: a request\n");
		return (USBD_INVAL);
	}
#endif

	len = xfer->length;
	endpt = xfer->pipe->endpoint->edesc->bEndpointAddress;
	isread = UE_GET_DIR(endpt) == UE_DIR_IN;
	sed = opipe->sed;

	DPRINTFN(4,("ohci_device_bulk_start: xfer=%p len=%d isread=%d "
		    "flags=%d endpt=%d\n", xfer, len, isread, xfer->flags,
		    endpt));

	opipe->u.bulk.isread = isread;
	opipe->u.bulk.length = len;

	/* Update device address */
	sed->ed.ed_flags = htole32(
		(le32toh(sed->ed.ed_flags) & ~OHCI_ED_ADDRMASK) |
		OHCI_ED_SET_FA(addr));

	/* Allocate a chain of new TDs (including a new tail). */
	data = opipe->tail.td;
	err = ohci_alloc_std_chain(opipe, sc, len, isread, xfer,
		  data, &tail);
	/* We want interrupt at the end of the transfer. */
	tail->td.td_flags &= htole32(~OHCI_TD_INTR_MASK);
	tail->td.td_flags |= htole32(OHCI_TD_SET_DI(1));
	tail->flags |= OHCI_CALL_DONE;
	tail = tail->nexttd;	/* point at sentinel */
	if (err)
		return (err);

	tail->xfer = NULL;
	xfer->hcpriv = data;

	DPRINTFN(4,("ohci_device_bulk_start: ed_flags=0x%08x td_flags=0x%08x "
		    "td_cbp=0x%08x td_be=0x%08x\n",
		    (int)le32toh(sed->ed.ed_flags),
		    (int)le32toh(data->td.td_flags),
		    (int)le32toh(data->td.td_cbp),
		    (int)le32toh(data->td.td_be)));

#ifdef OHCI_DEBUG
	if (ohcidebug > 5) {
		ohci_dump_ed(sed);
		ohci_dump_tds(data);
	}
#endif

	/* Insert ED in schedule */
	s = splusb();
	for (tdp = data; tdp != tail; tdp = tdp->nexttd) {
		tdp->xfer = xfer;
	}
	sed->ed.ed_tailp = htole32(tail->physaddr);
	opipe->tail.td = tail;
	sed->ed.ed_flags &= htole32(~OHCI_ED_SKIP);
	OWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_BLF);
#ifdef __riscos
        /* flush posted write */
	OREAD4(sc, OHCI_COMMAND_STATUS);
#endif
	if (xfer->timeout && !sc->sc_bus.use_polling) {
                usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
			    ohci_timeout, xfer);
	}

#if 0
/* This goes wrong if we are too slow. */
	if (ohcidebug > 10) {
		delay(10000);
		DPRINTF(("ohci_device_intr_transfer: status=%x\n",
			 OREAD4(sc, OHCI_COMMAND_STATUS)));
		ohci_dump_ed(sed);
		ohci_dump_tds(data);
	}
#endif

	splx(s);

	return (USBD_IN_PROGRESS);
}

Static void
ohci_device_bulk_abort(usbd_xfer_handle xfer)
{
	DPRINTF(("ohci_device_bulk_abort: xfer=%p\n", xfer));
	ohci_abort_xfer(xfer, USBD_CANCELLED);
}

/*
 * Close a device bulk pipe.
 */
Static void
ohci_device_bulk_close(usbd_pipe_handle pipe)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;

	DPRINTF(("ohci_device_bulk_close: pipe=%p\n", pipe));
	ohci_close_pipe(pipe, sc->sc_bulk_head);
	ohci_free_std(sc, opipe->tail.td);
}

/************************/

Static usbd_status
ohci_device_intr_transfer(usbd_xfer_handle xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ohci_device_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

Static usbd_status
ohci_device_intr_start(usbd_xfer_handle xfer)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	usbd_device_handle dev = opipe->pipe.device;
	ohci_softc_t *sc = (ohci_softc_t *)dev->bus;
	ohci_soft_ed_t *sed = opipe->sed;
	ohci_soft_td_t *data, *tail;
	int len, isread, endpt;
	int s;

	if (sc->sc_dying)
		return (USBD_IOERROR);

	DPRINTFN(3, ("ohci_device_intr_transfer: xfer=%p len=%d "
		     "flags=%d priv=%p\n",
		     xfer, xfer->length, xfer->flags, xfer->priv));

#ifdef DIAGNOSTIC
	if (xfer->rqflags & URQ_REQUEST)
		panic("ohci_device_intr_transfer: a request");
#endif

	len = xfer->length;
	endpt = xfer->pipe->endpoint->edesc->bEndpointAddress;
	isread = UE_GET_DIR(endpt) == UE_DIR_IN;

	data = opipe->tail.td;
	tail = ohci_alloc_std(sc);
	if (tail == NULL)
		return (USBD_NOMEM);
	tail->xfer = NULL;

	data->td.td_flags = htole32(
		(isread ? OHCI_TD_IN : OHCI_TD_OUT) | OHCI_TD_NOCC |
		OHCI_TD_SET_DI(1) | OHCI_TD_TOGGLE_CARRY);
	if (xfer->flags & USBD_SHORT_XFER_OK)
		data->td.td_flags |= htole32(OHCI_TD_R);
	data->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf, 0));
	data->nexttd = tail;
	data->td.td_nexttd = htole32(tail->physaddr);
	data->td.td_be = htole32(le32toh(data->td.td_cbp) + len - 1);
	data->len = len;
	data->xfer = xfer;
	data->flags = OHCI_CALL_DONE | OHCI_ADD_LEN;
	xfer->hcpriv = data;

#ifdef OHCI_DEBUG
	if (ohcidebug > 5) {
		DPRINTF(("ohci_device_intr_transfer:\n"));
		ohci_dump_ed(sed);
		ohci_dump_tds(data);
	}
#endif

	/* Insert ED in schedule */
	s = splusb();
	sed->ed.ed_tailp = htole32(tail->physaddr);
	opipe->tail.td = tail;
	sed->ed.ed_flags &= htole32(~OHCI_ED_SKIP);

#if 0
/*
 * This goes horribly wrong, printing thousands of descriptors,
 * because false references are followed due to the fact that the
 * TD is gone.
 */
	if (ohcidebug > 5) {
		usb_delay_ms(&sc->sc_bus, 5);
		DPRINTF(("ohci_device_intr_transfer: status=%x\n",
			 OREAD4(sc, OHCI_COMMAND_STATUS)));
		ohci_dump_ed(sed);
		ohci_dump_tds(data);
	}
#endif
	splx(s);

	return (USBD_IN_PROGRESS);
}

/* Abort a device control request. */
Static void
ohci_device_intr_abort(usbd_xfer_handle xfer)
{
	if (xfer->pipe->intrxfer == xfer) {
		DPRINTF(("ohci_device_intr_abort: remove\n"));
		xfer->pipe->intrxfer = NULL;
	}
	/* DRE Sun 15th February 2004 */
	/* turn off repeat, so that xfer is dequeued */
	xfer->pipe->repeat = 0;
	ohci_abort_xfer(xfer, USBD_CANCELLED);
	logprintf("first now: %p\n", SIMPLEQ_FIRST(&xfer->pipe->queue));
}

/* Close a device interrupt pipe. */
Static void
ohci_device_intr_close(usbd_pipe_handle pipe)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;
	int nslots = opipe->u.intr.nslots;
	int pos = opipe->u.intr.pos;
	int j;
	ohci_soft_ed_t *p, *sed = opipe->sed;
	int s;

	DPRINTFN(1,("ohci_device_intr_close: pipe=%p nslots=%d pos=%d\n",
		    pipe, nslots, pos));
	s = splusb();
	sed->ed.ed_flags |= htole32(OHCI_ED_SKIP);
	if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
	    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK))
		usb_delay_ms(&sc->sc_bus, 2);

	for (p = sc->sc_eds[pos]; p && p->next != sed; p = p->next)
		;
#ifdef DIAGNOSTIC
	if (p == NULL)
		panic("ohci_device_intr_close: ED not found");
#endif
	p->next = sed->next;
	p->ed.ed_nexted = sed->ed.ed_nexted;
	splx(s);

	for (j = 0; j < nslots; j++)
		--sc->sc_bws[(pos * nslots + j) % OHCI_NO_INTRS];

	ohci_free_std(sc, opipe->tail.td);
	ohci_free_sed(sc, opipe->sed);
}

Static usbd_status
ohci_device_setintr(ohci_softc_t *sc, struct ohci_pipe *opipe, int ival)
{
	int i, j, s, best;
	u_int npoll, slow, shigh, nslots;
	u_int bestbw, bw;
	ohci_soft_ed_t *hsed, *sed = opipe->sed;

	DPRINTFN(2, ("ohci_setintr: pipe=%p\n", opipe));
	if (ival == 0) {
                printf("ohci_setintr: 0 interval\n");
		return (USBD_INVAL);
	}

	npoll = OHCI_NO_INTRS;
	while (npoll > ival)
		npoll /= 2;
	DPRINTFN(2, ("ohci_setintr: ival=%d npoll=%d\n", ival, npoll));

	/*
	 * We now know which level in the tree the ED must go into.
	 * Figure out which slot has most bandwidth left over.
	 * Slots to examine:
	 * npoll
	 * 1	0
	 * 2	1 2
	 * 4	3 4 5 6
	 * 8	7 8 9 10 11 12 13 14
	 * N    (N-1) .. (N-1+N-1)
	 */
	slow = npoll-1;
	shigh = slow + npoll;
	nslots = OHCI_NO_INTRS / npoll;
	for (best = i = slow, bestbw = ~0; i < shigh; i++) {
		bw = 0;
		for (j = 0; j < nslots; j++)
			bw += sc->sc_bws[(i * nslots + j) % OHCI_NO_INTRS];
		if (bw < bestbw) {
			best = i;
			bestbw = bw;
		}
	}
	DPRINTFN(2, ("ohci_setintr: best=%d(%d..%d) bestbw=%d\n",
		     best, slow, shigh, bestbw));

	s = splusb();
	hsed = sc->sc_eds[best];
	sed->next = hsed->next;
	sed->ed.ed_nexted = hsed->ed.ed_nexted;
	hsed->next = sed;
	hsed->ed.ed_nexted = htole32(sed->physaddr);
	splx(s);

	for (j = 0; j < nslots; j++)
		++sc->sc_bws[(best * nslots + j) % OHCI_NO_INTRS];
	opipe->u.intr.nslots = nslots;
	opipe->u.intr.pos = best;

	DPRINTFN(5, ("ohci_setintr: returns %p\n", opipe));
	return (USBD_NORMAL_COMPLETION);
}

/***********************/

usbd_status
ohci_device_isoc_transfer(usbd_xfer_handle xfer)
{
	usbd_status err;

	DPRINTFN(5,("ohci_device_isoc_transfer: xfer=%p\n", xfer));

	/* Put it on our queue, */
	err = usb_insert_transfer(xfer);

	/* bail out on error, */
	if (err && err != USBD_IN_PROGRESS)
		return (err);

	/* XXX should check inuse here */

	/* insert into schedule, */
	ohci_device_isoc_enter(xfer);

	/* and start if the pipe wasn't running */
	if (!err)
		ohci_device_isoc_start(SIMPLEQ_FIRST(&xfer->pipe->queue));

	return (err);
}

void
ohci_device_isoc_enter(usbd_xfer_handle xfer)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	usbd_device_handle dev = opipe->pipe.device;
	ohci_softc_t *sc = (ohci_softc_t *)dev->bus;
	ohci_soft_ed_t *sed = opipe->sed;
	struct iso *iso = &opipe->u.iso;
	ohci_soft_itd_t *sitd, *nsitd;
	ohci_physaddr_t buf, offs, noffs, bp0;
	int i, ncur, nframes;
	int s;

	DPRINTFN(1,("ohci_device_isoc_enter: used=%d next=%d xfer=%p "
		    "nframes=%d\n",
		    iso->inuse, iso->next, xfer, xfer->nframes));

	if (sc->sc_dying)
		return;

	if (iso->next == -1) {
		/* Not in use yet, schedule it a few frames ahead. */
		iso->next = le32toh(sc->sc_hcca->hcca_frame_number) + 5;
		DPRINTFN(2,("ohci_device_isoc_enter: start next=%d\n",
			    iso->next));
	}

	/* DRE test */
	if (iso->next < le32toh(sc->sc_hcca->hcca_frame_number) + 1)
	{
	    iso->next = le32toh(sc->sc_hcca->hcca_frame_number) + 1;
	}

	sitd = opipe->tail.itd;
	buf = DMAADDR(&xfer->dmabuf, 0);
	bp0 = OHCI_PAGE(buf);
	offs = OHCI_PAGE_OFFSET(buf);
	nframes = xfer->nframes;
	xfer->hcpriv = sitd;
	logprintf ("hcpriv = %p\n", sitd);
	for (i = ncur = 0; i < nframes; i++, ncur++) {
		noffs = offs + xfer->frlengths[i];
		if (ncur == OHCI_ITD_NOFFSET ||	/* all offsets used */
		    OHCI_PAGE(buf + noffs) > bp0 + OHCI_PAGE_SIZE) { /* too many page crossings */

			/* Allocate next ITD */
			nsitd = ohci_alloc_sitd(sc);
			if (nsitd == NULL) {
				/* XXX what now? */
                                printf("%s: isoc TD alloc failed\n",
				       USBDEVNAME(sc->sc_bus.bdev));
				return;
			}

			/* Fill current ITD */
			sitd->itd.itd_flags = htole32(
				OHCI_ITD_NOCC |
				OHCI_ITD_SET_SF(iso->next) |
				OHCI_ITD_SET_DI(6) | /* delay intr a little */
				OHCI_ITD_SET_FC(ncur));
			sitd->itd.itd_bp0 = htole32(bp0);
			sitd->nextitd = nsitd;
			sitd->itd.itd_nextitd = htole32(nsitd->physaddr);
			sitd->itd.itd_be = htole32(bp0 + offs - 1);
			sitd->xfer = xfer;
			sitd->flags = 0;

			sitd = nsitd;
			iso->next = iso->next + ncur;
			bp0 = OHCI_PAGE(buf + offs);
			ncur = 0;
		}
		sitd->itd.itd_offset[ncur] = htole16(OHCI_ITD_MK_OFFS(offs));
		offs = noffs;
	}
	nsitd = ohci_alloc_sitd(sc);
	if (nsitd == NULL) {
		/* XXX what now? */
                printf("%s: isoc TD alloc failed\n",
		       USBDEVNAME(sc->sc_bus.bdev));
		return;
	}
	/* Fixup last used ITD */
	sitd->itd.itd_flags = htole32(
		OHCI_ITD_NOCC |
		OHCI_ITD_SET_SF(iso->next) |
		OHCI_ITD_SET_DI(0) |
		OHCI_ITD_SET_FC(ncur));
	sitd->itd.itd_bp0 = htole32(bp0);
	sitd->nextitd = nsitd;
	sitd->itd.itd_nextitd = htole32(nsitd->physaddr);
	sitd->itd.itd_be = htole32(bp0 + offs - 1);
	sitd->xfer = xfer;
	sitd->flags = OHCI_CALL_DONE;

	iso->next = iso->next + ncur;
	 /* DRE test */
	/*
	iso->next = le32toh(sc->sc_hcca->hcca_frame_number) + 2;
	iso->next = -1; */
	iso->inuse += nframes;

	xfer->actlen = offs;	/* XXX pretend we did it all */
	xfer->actlen = 0; /* what on earth is this meant to do? DRE */
	DPRINTFN(5, ("actlen set to %d\n", xfer->actlen));

	xfer->status = USBD_IN_PROGRESS;

#ifdef OHCI_DEBUG
	if (ohcidebug > 5) {
		DPRINTF(("ohci_device_isoc_enter: frame=%d\n",
			 le32toh(sc->sc_hcca->hcca_frame_number)));
		ohci_dump_itds(xfer->hcpriv);
		ohci_dump_ed(sed);
	}
#endif

	s = splusb();
        sed->ed.ed_tailp = htole32(nsitd->physaddr);
	opipe->tail.itd = nsitd;
	sed->ed.ed_flags &= htole32(~OHCI_ED_SKIP);
	splx(s);

#ifdef OHCI_DEBUG
	if (ohcidebug > 5) {
		delay(150000);
		DPRINTF(("ohci_device_isoc_enter: after frame=%d\n",
			 le32toh(sc->sc_hcca->hcca_frame_number)));
		ohci_dump_itds(xfer->hcpriv);
		ohci_dump_ed(sed);
	}
#endif
}

usbd_status
ohci_device_isoc_start(usbd_xfer_handle xfer)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;

	DPRINTFN(5,("ohci_device_isoc_start: xfer=%p\n", xfer));

	if (sc->sc_dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (xfer->status != USBD_IN_PROGRESS)
                printf("ohci_device_isoc_start: not in progress %p\n", xfer);
#endif

	/* XXX anything to do? */

	return (USBD_IN_PROGRESS);
}

void
ohci_device_isoc_abort(usbd_xfer_handle xfer)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
	ohci_soft_ed_t *sed;
	ohci_soft_itd_t *sitd;
	int s;

	s = splusb();

	DPRINTFN(1,("ohci_device_isoc_abort: xfer=%p\n", xfer));

	/* Transfer is already done. */
	if (xfer->status != USBD_NOT_STARTED &&
	    xfer->status != USBD_IN_PROGRESS) {
		splx(s);
                printf("ohci_device_isoc_abort: early return\n");
		return;
	}

	/* Give xfer the requested abort code. */
	xfer->status = USBD_CANCELLED;

	sed = opipe->sed;
	sed->ed.ed_flags |= htole32(OHCI_ED_SKIP); /* force hardware skip */

	sitd = xfer->hcpriv;
#ifdef DIAGNOSTIC
	if (sitd == NULL) {
		splx(s);
                printf("ohci_device_isoc_abort: hcpriv==0\n");
		return;
	}
#endif
	for (; sitd->xfer == xfer; sitd = sitd->nextitd) {
#ifdef DIAGNOSTIC
		DPRINTFN(1,("abort sets done sitd=%p\n", sitd));
		sitd->isdone = 1;
#endif
	}

	splx(s);

	usb_delay_ms(&sc->sc_bus, OHCI_ITD_NOFFSET);

	s = splusb();

	/* Run callback. */
	usb_transfer_complete(xfer);

	sed->ed.ed_headp = htole32(sitd->physaddr); /* unlink TDs */
	sed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */

	splx(s);
}

void
ohci_device_isoc_done(usbd_xfer_handle xfer)
{

	DPRINTFN(1,("ohci_device_isoc_done: xfer=%p\n", xfer));

//	xfer->hcpriv = NULL;
}

usbd_status
ohci_setup_isoc(usbd_pipe_handle pipe)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;
	struct iso *iso = &opipe->u.iso;
	int s;

	iso->next = -1;
	iso->inuse = 0;

	s = splusb();
	ohci_add_ed(opipe->sed, sc->sc_isoc_head);
	splx(s);

	return (USBD_NORMAL_COMPLETION);
}

void
ohci_device_isoc_close(usbd_pipe_handle pipe)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;

	DPRINTF(("ohci_device_isoc_close: pipe=%p\n", pipe));
	ohci_close_pipe(pipe, sc->sc_isoc_head);
#ifdef DIAGNOSTIC
	opipe->tail.itd->isdone = 1;
#endif
	ohci_free_sitd(sc, opipe->tail.itd);
}
@


1.25
log
@  Fixes for Isochronous data transfer
Detail:
Frontend
========

NetBSD.build.c.usbmodule
	frontend isochronous changes
	forces reads to always be multiple of maxpacket
NetBSD.dev.usb.c.usb_subr
	datatoggle fix
	panic fix
NetBSD.dev.usb.c.usbdi
	usbd_transfer changed so that bufrem is passed the xfer pointer instead of the buffer pointer
	fixed missing braces in usbd_clear_endpoint_stall

EHCI
====

The HS (USB2) isochronous as been rewritten and isochronous split transactions - FS (USB1) over a HS Connection - has been added

NetBSD.dev.usb.c.ehci
NetBSD.dev.usb.h.ehcireg
NetBSD.dev.usb.h.ehcivar

OHCI
====

Changes to the NetBSD backend to get isochronous transfers working on a OHCI device. While it did have isochronous support it wasn't working properly.

NetBSD.dev.usb.c.ohci

Admin:
  Submitted by Colin Granville
Tested in iMx6

Version 1.10. Tagged as 'NetBSD-1_10'
@
text
@a2073 1
	{
a2074 2
		return;
	}
d3554 2
a3555 15
/* fixes xfer with large nframes value */

static inline int frnumber_wrap(unsigned int a)
{
	return a & 0xffff;
}

static inline int frnumber_sub(unsigned int a, unsigned int b)
{
	a = frnumber_wrap(a);
	b = frnumber_wrap(b);
	return 0x8000 - frnumber_wrap(0x8000 - a + b);
}

void ohci_device_isoc_enter(usbd_xfer_handle xfer)
d3560 1
d3562 8
d3575 10
a3584 3
		iso->next = frnumber_wrap(le32toh(sc->sc_hcca->hcca_frame_number) + 16);
	} else if (frnumber_sub(iso->next, le32toh(sc->sc_hcca->hcca_frame_number)) <= 0) {
		iso->next = frnumber_wrap(le32toh(sc->sc_hcca->hcca_frame_number) + 1);
d3587 5
a3591 2
	ohci_soft_itd_t* sitd = opipe->tail.itd;
	ohci_soft_itd_t* nsitd = NULL;
d3593 14
d3608 40
a3647 2
	int nframes = xfer->nframes;
	if (nframes == 0) return;
d3649 6
a3654 1
	ohci_physaddr_t buf = DMAADDR(&xfer->dmabuf, 0);
d3656 3
a3658 40
	int quit = 0;
	int i = 0;
	while (!quit) {
		nsitd = ohci_alloc_sitd(sc);
		if (nsitd == NULL) {
			/* XXX what now? */
			return;
		}

		int offs = OHCI_PAGE_OFFSET(buf);
		int noffs = offs;
		/* Note: filling of offsets requires first offset to have bit 13 = 0 */
		for (int ncur = 0; ncur <= OHCI_ITD_NOFFSET; ncur++, i++) {
			if (noffs >= (OHCI_PAGE_SIZE * 2) ||
			    ncur == OHCI_ITD_NOFFSET ||
			    i == nframes) {
				ohci_physaddr_t bp0 = OHCI_PAGE(buf);
				buf = bp0;
				if (noffs > (OHCI_PAGE_SIZE * 2)) {
					/* couldn't fit last itd offset
					   so roll it back */
					buf += offs;
					i--;
					ncur--;
					/* error if ncur == 0 */
				} else
					buf += noffs;

				/* Fill current ITD */
				sitd->itd.itd_flags = htole32(
					OHCI_ITD_NOCC |
					OHCI_ITD_SET_SF(iso->next) |
					OHCI_ITD_SET_DI(0) | /* was 6 delay intr a little */
					OHCI_ITD_SET_FC(ncur));
				sitd->itd.itd_bp0 = htole32(bp0);
				sitd->nextitd = nsitd;
				sitd->itd.itd_nextitd = htole32(nsitd->physaddr);
				sitd->itd.itd_be = htole32(buf - 1);
				sitd->xfer = xfer;
				sitd->flags = (i == nframes) ? OHCI_CALL_DONE : 0;
a3659 15
				iso->next += ncur;
				sitd = nsitd;

				if (i == nframes) quit = 1;

				break;
			}
			offs = noffs;
			noffs = offs + xfer->frlengths[i];
			sitd->itd.itd_offset[ncur] = htole16(OHCI_ITD_MK_OFFS(offs));
		}
	}

	iso->inuse += nframes;
	xfer->actlen = 0; /* no bytes transferred yet */
a3661 2
	ohci_soft_ed_t *sed = opipe->sed;

d3665 1
a3665 1
			le32toh(sc->sc_hcca->hcca_frame_number)));
d3671 2
a3672 2
	int s = splusb();
	sed->ed.ed_tailp = htole32(nsitd->physaddr);
d3681 1
a3681 1
			le32toh(sc->sc_hcca->hcca_frame_number)));
a3685 1

@


1.24
log
@Init structures for OHCI & EHCI unused members
Detail:
  Play safe, put NULLs in for the unused HC overrides.

Version 1.08. Not tagged
@
text
@d2074 1
d2076 2
d3557 15
a3571 2
void
ohci_device_isoc_enter(usbd_xfer_handle xfer)
a3575 1
	ohci_soft_ed_t *sed = opipe->sed;
a3576 8
	ohci_soft_itd_t *sitd, *nsitd;
	ohci_physaddr_t buf, offs, noffs, bp0;
	int i, ncur, nframes;
	int s;

	DPRINTFN(1,("ohci_device_isoc_enter: used=%d next=%d xfer=%p "
		    "nframes=%d\n",
		    iso->inuse, iso->next, xfer, xfer->nframes));
d3582 3
a3584 4
		/* Not in use yet, schedule it a few frames ahead. */
		iso->next = le32toh(sc->sc_hcca->hcca_frame_number) + 5;
		DPRINTFN(2,("ohci_device_isoc_enter: start next=%d\n",
			    iso->next));
d3587 54
a3640 5
	/* DRE test */
	if (iso->next < le32toh(sc->sc_hcca->hcca_frame_number) + 1)
	{
	    iso->next = le32toh(sc->sc_hcca->hcca_frame_number) + 1;
	}
d3642 1
a3642 19
	sitd = opipe->tail.itd;
	buf = DMAADDR(&xfer->dmabuf, 0);
	bp0 = OHCI_PAGE(buf);
	offs = OHCI_PAGE_OFFSET(buf);
	nframes = xfer->nframes;
	xfer->hcpriv = sitd;
	logprintf ("hcpriv = %p\n", sitd);
	for (i = ncur = 0; i < nframes; i++, ncur++) {
		noffs = offs + xfer->frlengths[i];
		if (ncur == OHCI_ITD_NOFFSET ||	/* all offsets used */
		    OHCI_PAGE(buf + noffs) > bp0 + OHCI_PAGE_SIZE) { /* too many page crossings */

			/* Allocate next ITD */
			nsitd = ohci_alloc_sitd(sc);
			if (nsitd == NULL) {
				/* XXX what now? */
                                printf("%s: isoc TD alloc failed\n",
				       USBDEVNAME(sc->sc_bus.bdev));
				return;
d3644 4
a3647 28

			/* Fill current ITD */
			sitd->itd.itd_flags = htole32(
				OHCI_ITD_NOCC |
				OHCI_ITD_SET_SF(iso->next) |
				OHCI_ITD_SET_DI(6) | /* delay intr a little */
				OHCI_ITD_SET_FC(ncur));
			sitd->itd.itd_bp0 = htole32(bp0);
			sitd->nextitd = nsitd;
			sitd->itd.itd_nextitd = htole32(nsitd->physaddr);
			sitd->itd.itd_be = htole32(bp0 + offs - 1);
			sitd->xfer = xfer;
			sitd->flags = 0;

			sitd = nsitd;
			iso->next = iso->next + ncur;
			bp0 = OHCI_PAGE(buf + offs);
			ncur = 0;
		}
		sitd->itd.itd_offset[ncur] = htole16(OHCI_ITD_MK_OFFS(offs));
		offs = noffs;
	}
	nsitd = ohci_alloc_sitd(sc);
	if (nsitd == NULL) {
		/* XXX what now? */
                printf("%s: isoc TD alloc failed\n",
		       USBDEVNAME(sc->sc_bus.bdev));
		return;
a3648 12
	/* Fixup last used ITD */
	sitd->itd.itd_flags = htole32(
		OHCI_ITD_NOCC |
		OHCI_ITD_SET_SF(iso->next) |
		OHCI_ITD_SET_DI(0) |
		OHCI_ITD_SET_FC(ncur));
	sitd->itd.itd_bp0 = htole32(bp0);
	sitd->nextitd = nsitd;
	sitd->itd.itd_nextitd = htole32(nsitd->physaddr);
	sitd->itd.itd_be = htole32(bp0 + offs - 1);
	sitd->xfer = xfer;
	sitd->flags = OHCI_CALL_DONE;
a3649 5
	iso->next = iso->next + ncur;
	 /* DRE test */
	/*
	iso->next = le32toh(sc->sc_hcca->hcca_frame_number) + 2;
	iso->next = -1; */
d3651 2
d3654 1
a3654 5
	xfer->actlen = offs;	/* XXX pretend we did it all */
	xfer->actlen = 0; /* what on earth is this meant to do? DRE */
	DPRINTFN(5, ("actlen set to %d\n", xfer->actlen));

	xfer->status = USBD_IN_PROGRESS;
d3659 1
a3659 1
			 le32toh(sc->sc_hcca->hcca_frame_number)));
d3665 2
a3666 2
	s = splusb();
        sed->ed.ed_tailp = htole32(nsitd->physaddr);
d3675 1
a3675 1
			 le32toh(sc->sc_hcca->hcca_frame_number)));
d3680 1
@


1.23
log
@Update to use rationalised power and overcurrent API
OHCIDriver (only) had sketchy support for a HAL based scheme for controlling the port power and monitor overcurrent. However the implementation was limited to supporting the single port required for an embedded product (aka Rhenium in the CVS history). The change makes it follow a model much more akin to the HAL_TimerDevice/HAL_TimerIRQStatus/HAL_TimerIRQClear set of functions.
Version:
  Bumped OHCIDriver and USBDriver version numbers.
ohcimodule.c:
  Use some defines from OsBytes.h.
  Group the debug variables within the OHCI_DEBUG define so they go away in the release case.
  Allow for up to 15 ports to be controlled via the revised HAL API, and pass something other than a hardwired controller of 0 when controlling/monitoring power.
  Enumerate the device numbers for overcurrent monitoring on startup.
  Deal with the possibility of one (or more) of the device numbers being shared interrupts.
  Squash a few trivial compiler warnings.
ohcimodhead.cmhg:
  rename the handler/entry to reflect their use for overcurrent
ohci.c:
  Allow for up to 15 ports to be controlled by passing in the port index where needed.
usb_subr.c/usbdivar.h:
  Remove a RISC OS-ism in datatoggle, to converge with NetBSD a bit.
ehcivar.h/usb_port.h:
  Relocate the overrides for mutex_ functions here since this is the only controller using them. Previously when in "usb_port.h" they would indirectly get dragged in ia the nested include in "usb.h". The could in fact now be implemented using SyncLib, an exercise left to the reader.
usb.h
  Merge some of the device classes and other allocations from NetBSD.

While it's not been possible to test the revised API, due to not having sight of the original platform on which it was implemented, none of the actively maintained HALs currently use the HAL based power and overcurrent scheme anyway, so the new code never gets called. In that respect, it's no more broken then the previous single port-single controller version.

Version 0.89. Tagged as 'NetBSD-0_89'
@
text
@d310 1
@


1.22
log
@Make RHENIUM build switch go away. Misc housekeeping
Detail:
  build/Makefile, build/!MkDebug,fd7 - Debug versions of the modules can now be built just by passing "DEBUG=TRUE" to amu
  build/!MkRhenium,fd7 - Deleted obsolete file
  build/Version - Increased version numbers
  build/c/ehcihal, build/c/ehcimodule, build/c/ohcimodule - Only accept USB controllers if HAL_USBControllerInfo says the struct size is an exact match with what we expect. Rework USB controller enumeration to allow modules to properly support both PCI and HAL controllers being available on the same machine, and without RHENIUM switch (module sources only).
  build/c/ehcimodule - Get rid of remaining RHENIUM bits; RHENIUM flag no longer needed for 32bit wide register reads/writes to be supported
  build/c/ohcimodule, build/cmhg/ohcimodhead, dev/usb/c/ohci - Get rid of remaining RHENIUM bits; RHENIUM flag no longer needed for HAL port power controls to be supported.
  build/c/usbhal, build/c/usbmodule, dev/usb/c/uhub, dev/usb/h/usb_port - Get rid of empty riscos_failed_device function
  build/s/call_veneer, build/s/triggercbs - Use Entry/EXIT macros to avoid single-reg LDM/STM performance warnings. Convert tabs to spaces.
  dev/usb/h/usb - Get rid of RHENIUM switch on USB_PORT_RESET_DELAY. Now always uses non-RHENIUM value of 100ms.
Admin:
  Tested on rev A2 BB-xM, Iyonix, Raspberry Pi


Version 0.71. Tagged as 'NetBSD-0_71'
@
text
@d951 2
a952 1
	(*ohci_ppower)(1, 1); // port power on
d2880 1
a2880 1
			(*ohci_ppower)(1, 0); // port power off
d3007 1
a3007 1
			(*ohci_ppower)(1, 1); // port power on
@


1.21
log
@Fix memory overwrites in root hub emulation
Detail:
  dev/usb/c/ehci, dev/usb/c/ohci - Fixed device descriptor and config descriptor reads writing outside the destination buffer if the buffer was small enough.
  build/Version - Incremented EHCI & OHCI version numbers & dates
Admin:
  Tested in OMAP3 ROM & Iyonix ROM softload


Version 0.63. Tagged as 'NetBSD-0_63'
@
text
@d154 3
a156 4
#ifdef RHENIUM
extern void (*ohci_ppower)(int port, int state);  //(used with rhenium)
extern int  (*ohci_error)(int port);              //(used with rhenium)
#endif /*RHENIUM*/
d950 1
a950 1
	#ifdef RHENIUM
d952 1
a952 1
	#endif /*RHENIUM*/
d2878 1
a2878 1
			#ifdef RHENIUM
d2880 1
a2880 1
			#endif /*RHENIUM*/
d3005 1
a3005 1
			#ifdef RHENIUM
d3007 1
a3007 1
			#endif /*RHENIUM*/
a3175 29
#ifdef RHENIUM_NO_BULK         /* Bulk transfers dis-allowed */
Static usbd_status
ohci_device_bulk_transfer(usbd_xfer_handle xfer)
{
		return (USBD_IOERROR);
}

Static usbd_status
ohci_device_bulk_start(usbd_xfer_handle xfer)
{
		return (USBD_IOERROR);
}

Static void
ohci_device_bulk_abort(usbd_xfer_handle xfer)
{
}

/*
 * Close a device bulk pipe.
 */
Static void
ohci_device_bulk_close(usbd_pipe_handle pipe)
{
}

#else   /*RHENIUM_NO_BULK*/


a3312 1
#endif   /*RHENIUM_NO_BULK*/
a3525 43
#ifdef RHENIUM_NO_ISOC
usbd_status
ohci_device_isoc_transfer(usbd_xfer_handle xfer)
{
	return (USBD_IOERROR);
}

void
ohci_device_isoc_enter(usbd_xfer_handle xfer)
{
}

usbd_status
ohci_device_isoc_start(usbd_xfer_handle xfer)
{
	return (USBD_IOERROR);
}

void
ohci_device_isoc_abort(usbd_xfer_handle xfer)
{
}

void
ohci_device_isoc_done(usbd_xfer_handle xfer)
{

	DPRINTFN(1,("ohci_device_isoc_done: xfer=%p\n", xfer));

//	xfer->hcpriv = NULL;
}

usbd_status
ohci_setup_isoc(usbd_pipe_handle pipe)
{
	return (USBD_IOERROR);
}

void
ohci_device_isoc_close(usbd_pipe_handle pipe)
{
}
#else  /*RHENIUM_NO_ISOC*/
a3803 1
#endif  /*RHENIUM_NO_ISOC*/
@


1.20
log
@Update HAL USB code for new HAL_KbdScanInterrupt behaviour. Fix data aborts during keyboard scanning.
Detail:
  build/c/usbhal, build/h/usbhal - Updated USBHAL_KbdScanInterrupt to behave the same way HAL_KbdScanInterrupt is now expected to behave.
  build/c/ehci, build/c/ohci - Fixed some root hub emulation code which was writing to a global structure before copying it into the destination buffer. Although this works fine in ROM modules it was causing data aborts in the USB HAL libraries due to lack of automatic RW data relocation by the compiler.
  build/Version - Updated version numbers
Admin:
  Tested on rev C2 BB.


Version 0.62. Tagged as 'NetBSD-0_62'
@
text
@d2719 1
d2768 2
d2771 1
a2771 2
			memcpy(buf, (void *)&ohci_devd, l);
			USETW(((usb_device_descriptor_t *) buf)->idVendor, sc->sc_id_vendor);
@


1.19
log
@Add the ability to build the USB drivers as HAL-compatible static libraries
Detail:
  build/Makefile, build/OBJEHCIDriver, build/OBJOHCIDriver, build/OBJUSBDriver - Modified makefiles to build the HAL libs during the export libs phase
  build/!MkHAL,fd7 - Handy script for building the HAL libs
  build/Hdr/usbhal - Header containing definitions for the assembler code. Also gets exported so that HALs know how much workspace to reserve.
  build/c/usbhal - HAL version of usbmodule.c & port.c. Also contains the keyboard scan code, adapted from the code in the Tungsten HAL.
  build/s/porthal - Assembler versions of some port.c routines that were easier to do in assembler than C
  build/s/halheap - OS_Heap code that's been adapted for use in the HAL. Could easily be changed into a standalone library instead of being part of the HAL USB libs. Supports memory-efficient allocation of aligned blocks.
  build/c/ehcihal - HAL version of ehcimodule.c. Currently only supports EHCI controllers exposed via HAL_USBControllerInfo (i.e. no PCI support)
  build/c/ehcimodule, build/c/ohcimodule, build/c/port - Moved riscos_irq_clear into port.c. Removed unused microtime() function.
  build/c/usbmouse - Strip out some debug-related code in non-debug builds
  build/Version - Updated version numbers
  dev/usb/c/ehci, dev/usb/h/ehcivar - Adapted to add support for the HAL build. Apart from the base changes, the code has also been tweaked to significantly reduce the amount of memory used at runtime by the HAL version of the driver.
  dev/usb/c/hid, dev/usb/c/uhub, dev/usb/c/usb, dev/usb/c/usb_quirks, dev/usb/c/usb_subr, dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/c/usbroothub_subr - Changes to support HAL builds. Mainly disabling bits that won't work in the HAL or disabling bits for RISC OS in general if they weren't being used in the first place.
  dev/usb/c/ohci, dev/usb/h/ohcivar - Basic changes to support HAL builds. However HAL OHCI support is still incomplete.
  dev/usb/h/usb_port - Added support for the HAL build. Also tweaked logprintf definition to get rid of logprintf calls entirely in non-debug builds.
  dev/usb/h/usbdivar - Added support for the HAL build.
  dev/usb/h/usbhal - New header used by the HAL build. Gets included by every C file to ensure the compiler doesn't use sb, and contains structs/macros to allow access to the shared workspace.
Admin:
  HAL & non-HAL builds tested on rev C2 BB, rev A2 BB-xM, rev C1 TouchBook.
  Non-HAL builds tested with Iyonix ROM softload.
  Needs latest Kernel source for OSEntries.h export.


Version 0.59. Tagged as 'NetBSD-0_59'
@
text
@d2618 1
a2618 1
Static usb_device_descriptor_t ohci_devd = {
d2631 1
a2631 1
Static usb_config_descriptor_t ohci_confd = {
d2644 1
a2644 1
Static usb_interface_descriptor_t ohci_ifcd = {
d2656 1
a2656 1
Static usb_endpoint_descriptor_t ohci_endpd = {
d2665 1
a2665 1
Static usb_hub_descriptor_t ohci_hubd = {
a2767 1
			USETW(ohci_devd.idVendor, sc->sc_id_vendor);
d2769 1
@


1.18
log
@Add support for HAL enumerated USB EHCI controllers, use HAL_IRQClear when clearing EHCI/OHCI controller interrupts
Detail:
  * HAL enumeration of EHCI controllers is performed in the same manner as for OHCI, and protected by #ifdef RHENIUM. HAL_USBControllerInfo must return with the usbinfo type field set to 1 to indicate EHCI.
  * HAL_IRQClear is now called by the EHCI & OHCI modules after clearing the interrupt flag in the USB controller, to allow the HAL to reset the interrupt controller if required (e.g. for OMAP3)
  * EHCI module (for HAL EHCI controllers) now has the option of forcing all EHCI register access to be 32bit size & alignment (requirement is indicated in OMAP3 TRM, although USB did seem to function fine without)
  build/c/ehcimodule - Add enumeration of HAL USB controllers. Add support for forcing all EHCI register access to be 32bit size & alignment. Add riscos_irqclear() implementation. Guard against unexpected behaviour if PCI module isn't present.
  build/c/ohcimodule - Add riscos_irqclear() implementation. Guard against unexpected behaviour if PCI module isn't present.
  dev/usb/c/ehci, dev/usb/c/ohci - call riscos_irqclear() when appropriate
  dev/usb/h/usb_port - riscos_irqclear() prototype
Admin:
  Tested on rev C2 beagleboard. Untested on Iyonix, but should be fine.


Version 0.47. Tagged as 'NetBSD-0_47'
@
text
@d54 3
d298 5
d311 4
d371 15
a385 1
#if defined (__riscos)
d722 1
a722 1
#if defined (__riscos)
d1218 1
a1218 1
                riscos_irqclear();
@


1.17
log
@	re-merged some items missed by Dan, and corrected usbmodule for
	1 item missed earlier.. interrupt out endpoints noe demonstrated
	working
Detail:
Admin:  jb  Castle added IP


Version 0.45. Tagged as 'NetBSD-0_45'
@
text
@d1190 4
a1193 1
                        OREAD4(sc, OHCI_INTERRUPT_STATUS));
d1270 1
@


1.16
log
@  Now handles interrupt out transfers

Detail:
  There were many places where this was broken: the devicefs
interface was always starting off a read regardless of
whether it was an IN or OUT transfer, usbdi.c was setting
OUT interrupt transfers as repeating, which doesn't make sense,
and ohci.c was always making interrupt transfers OUT (this is
fixed in the latest BSD sources). Also the code which
unhalts endpoints at start of day has been removed, as this is
no longer in the BSD sources having been removed after it was
seend to have caused problems.

Admin:
  Tested with a CATC analyzer on an AverMedia FM radio. If now
operates properly with the code from Dave Higton.

Version 0.43. Tagged as 'NetBSD-0_43'
@
text
@d4 6
@


1.15
log
@	several changes and nullpointer bug fixes
Detail:
	Includes several bug fixes and null pointer traps.
	Rhenium version reviewed and reset should be improved.
Admin:
	Tested in rhenium desktop build and iyonix build at castle
   	Castle added IP


Version 0.40. Tagged as 'NetBSD-0_40'
@
text
@a3 6
/* note version 1.157 exists in NetBSD sources at 20050416, but this file
 * has not been updated to track that as the code has changed significantly
 * and so far an appropriate match hasnt been achieved
 * JWB 17 April 2005
 */
 
d909 1
a909 1
        /* fix broken Tungsten board */
d1183 1
a1183 1
                OWRITE4(sc, OHCI_INTERRUPT_STATUS, 
d1185 1
a1185 1
                
d1286 1
a1286 1
		eintrs &= ~OHCI_SO;                 
d1317 1
a1317 1
		ohci_rhsc_able(sc, 0);   
a2839 2
			DPRINTFN(2,("ohci_root_ctrl_transfer: clear port power "
				    "%d\n", index));
d3331 1
a3331 1
	int len;
d3347 2
d3357 1
a3357 1
		OHCI_TD_IN | OHCI_TD_NOCC |
@


1.14
log
@	Update of NetBSD elements (except c.ohci) to track NetBSD current
	from mid April 2005.
	Inclusion of Mods to c.ehci (from Dan) to correctly handle low
	speed interrupt devices beyond USB2 hubs (i.e. keyboards and mice).
	Mod to EHCI resetting in service call handler to better cope with
	USBDriver being restarted 'underneath' it.
Detail:
Admin:
	Castle, Dan Ellis, NetBSD added IP. Tested at Castle. Will be
	beta tested at this revision level before full release.


Version 0.39. Tagged as 'NetBSD-0_39'
@
text
@d2846 2
@


1.13
log
@        Stack brought up to date with NetBSD sources as at 20050121.
        USB2 further debugged.
Detail:
        Check in prior to second beta release. Improvements also to
        softloading of replacement modules.
Admin:
        Checked with JB .. further crosschecking is still needed for rhenium.
        Castle/D Ellis added ip from NetBSD sources


Version 0.33. Tagged as 'NetBSD-0_33'
@
text
@d4 6
d915 1
a915 1
        /* fix broken Tungsen board */
@


1.12
log
@        Update of EHCIDriver to current NetBSD, together with needed changes
        in both OHCIDriver and USBDriver.


Detail:
        Code may change before formal release .. will be beta released
        ... Entered to CVS to get new version numbers, and for
        the record.
Admin:
        Castle/netbsd added IP .. will be tested more fully before
        formal release. Still to be verified on Rhenium.


Version 0.31. Tagged as 'NetBSD-0_31'
@
text
@d1 1
a1 1
/*      $NetBSD: ohci.c,v 1.152 2004/10/26 20:46:16 augustss Exp $      */
d49 1
a49 1
//__KERNEL_RCSID(0, "$NetBSD: ohci.c,v 1.152 2004/10/26 20:46:16 augustss Exp $");
d58 1
d106 3
d112 1
a112 1
 * the data stored in memory needs to be swapped.
d530 1
a530 4
//          (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |
            /* quick test - does it work better if we always allow short
               transfers? */
            OHCI_TD_R |
d719 1
a719 1
	logprintf(",");
d721 1
a721 1
	logprintf("%s:", USBDEVNAME(sc->sc_bus.bdev));
d724 1
a724 1
	logprintf(" OHCI version %d.%d%s\n", OHCI_REV_HI(rev), OHCI_REV_LO(rev),
d728 1
a728 1
		logprintf("%s: unsupported OHCI revision\n",
d742 5
d812 1
a812 1
			logprintf("ed#%d ", i);
d815 1
a815 1
		logprintf("iso ");
d832 1
a832 1
			logprintf("%s: SMM does not respond, resetting\n",
d874 1
a874 1
		logprintf("%s: reset timeout\n", USBDEVNAME(sc->sc_bus.bdev));
d929 2
d933 1
d975 1
d977 6
a982 1
	return (usb_allocmem(&sc->sc_bus, size, 0, dma));
d991 7
a997 1

d1012 1
a1012 1
			logprintf("ohci_allocx: xfer=%p not free, 0x%08x\n", xfer,
d1035 1
a1035 1
		logprintf("ohci_freex: xfer=%p not busy, 0x%08x\n", xfer,
d1180 1
a1180 1
		logprintf("ohci_intr: ignored interrupt while polling\n");
d1182 4
d1201 1
a1201 1
	DPRINTFN(10,("ohci_intr1: enter\n"));
d1206 1
a1206 1
		logprintf("ohci_intr: sc->sc_hcca == NULL\n");
d1272 1
a1272 1
	DPRINTFN(10, ("ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n",
d1280 1
a1280 1
			logprintf("%s: %u scheduling overruns\n",
d1298 1
a1298 1
		logprintf("%s: resume detect\n", USBDEVNAME(sc->sc_bus.bdev));
d1302 1
a1302 1
		logprintf("%s: unrecoverable error, controller halted\n",
d1361 1
a1361 1
		logprintf("%s: blocking intrs 0x%x\n",
d1622 1
a1622 1
			logprintf("ohci_softintr: sitd=%p is done\n", sitd);
d1673 1
d1699 1
a1699 1
		panic("ohci_ctrl_done: not a request");
d1990 1
a1990 1
		logprintf("ctrl head:\n");
d1992 1
a1992 1
		logprintf("sed:\n");
d2192 1
a2192 1
	logprintf("TD(%p) at %08lx: %s delay=%d ec=%d cc=%d\ncbp=0x%08lx "
d2208 1
a2208 1
	logprintf("ITD(%p) at %08lx: sf=%d di=%d fc=%d cc=%d\n"
d2219 1
a2219 1
		logprintf("offs[%d]=0x%04x ", i,
d2221 1
a2221 1
	logprintf("\n");
d2254 1
a2254 1
	logprintf("ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d flags=%s\ntailp=0x%08lx "
d2404 1
a2404 1
		logprintf("ohci_close_pipe: pipe not empty sed=%p hd=0x%x "
d2422 1
a2422 1
			logprintf("ohci_close_pipe: pipe still not empty\n");
d2535 1
a2535 1
		logprintf("ohci_abort_xfer: hcpriv is NULL\n");
d2556 1
a2556 1
		DPRINTFN(1,("ohci_abort_xfer: set hd=0x08%x, tl=0x%08x\n",
d2696 1
a2696 1
	DPRINTFN(4,("ohci_root_ctrl_control type=0x%02x request=0x%02x\n",
d2759 3
d3090 1
a3090 1
		logprintf("ohci_device_ctrl_transfer: not a request\n");
d3200 1
a3200 1
		logprintf("ohci_device_bulk_start: a request\n");
d3463 1
a3463 1
		logprintf("ohci_setintr: 0 interval\n");
d3635 1
a3635 1
				logprintf("%s: isoc TD alloc failed\n",
d3664 1
a3664 1
		logprintf("%s: isoc TD alloc failed\n",
d3704 1
a3706 1
	sed->ed.ed_tailp = htole32(nsitd->physaddr);
d3733 1
a3733 1
		logprintf("ohci_device_isoc_start: not in progress %p\n", xfer);
d3758 1
a3758 1
		logprintf("ohci_device_isoc_abort: early return\n");
d3772 1
a3772 1
		logprintf("ohci_device_isoc_abort: hcpriv==0\n");
@


1.11
log
@  Extensive changes and bug fixes to usb and ohci ..
  'blocked' several holes that could cause freezes with awkward
  usb devices.  Added latest changes from Dan Ellis too , especially for USB2
Detail:
 many
Admin:
 Tested in ROM at Castle, and beta tested with users


Version 0.28. Tagged as 'NetBSD-0_28'
@
text
@d1 1
a1 1
/*	$NetBSD: ohci.c,v 1.135 2002/12/10 14:07:37 toshii Exp $	*/
d45 1
a45 1
 * USB spec: http://www.usb.org/developers/data/usbspec.zip
d49 1
a49 1
//__KERNEL_RCSID(0, "$NetBSD: ohci.c,v 1.135 2002/12/10 14:07:37 toshii Exp $");
a383 1
		break;
d952 1
a952 1
	ohci_free_sed(sc, sc->sc_ctrl_head);
d954 1
a954 1
	ohci_free_sed(sc, sc->sc_bulk_head);
d1534 1
a1534 1
			DPRINTFN(8,("ohci_process_done: error cc=%d (%s) pipe=%x\n",
@


1.10
log
@Latest stuff from John - mainly Rhenium improvements.

Version 0.26. Tagged as 'NetBSD-0_26'
@
text
@d108 1
a108 1
 * the data strored in memory needs to be swapped.
d527 4
a530 1
	    (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |
d943 1
d1248 1
a1248 1
	DPRINTFN(7, ("ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n",
d1262 1
a1262 1
		eintrs &= ~OHCI_SO;
a1283 1
		ohci_rhsc(sc, sc->sc_intrxfer);
d1288 7
a1294 1
		ohci_rhsc_able(sc, 0);
d1309 1
a1309 1
                DPRINTF(("ohci_intr: reclaiming endpoints\n"));
d1356 1
a1356 1
	DPRINTFN(4, ("ohci_rhsc_able: on=%d\n", on));
d1425 2
a1426 1
		panic("ohci_add_done: addr 0x%08lx not found", (u_long)done);
d1473 1
a1473 1
		DPRINTFN(10, ("ohci_process_done: std=%p xfer=%p hcpriv=%p\n",
d1475 3
d1495 1
d1501 1
a1501 1
			DPRINTFN(10, ("ohci_process_done: len=%d, flags=0x%x\n",
d1507 2
d1525 9
d1535 1
a1535 1
			DPRINTFN(15,("ohci_process_done: error cc=%d (%s)\n",
d1537 1
a1537 1
			  ohci_cc_strs[OHCI_TD_GET_CC(le32toh(std->td.td_flags))]));
d1539 2
d1556 4
a1559 1
				logprintf("endpoint halted but not stalled: error cc=%d\n", cc);
d1743 1
a1743 1
	DPRINTF(("ohci_rhsc: sc=%p xfer=%p hstatus=0x%08x\n",
d1855 2
a1856 1
		    "wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\n",
d1859 2
a1860 1
		    opipe->pipe.endpoint->edesc->bEndpointAddress));
d1953 4
a2151 1
        char flags[32];
d2153 1
a2153 1
        sprintf (flags, "%s%s%s",
d2306 1
a2306 1
			OHCI_ED_SET_EN(ed->bEndpointAddress) |
d2526 1
d2841 1
a2841 1
		case UHF_C_PORT_RESET:
d2851 1
a2851 1
		if (value & 0xff != 0) {
d2923 2
d2931 2
a2932 2
				if ((OREAD4(sc, port) & UPS_RESET) == 0)
					break;
@


1.9
log
@  New versions from John.
Detail:
  * All modules will now rmkill/rmload more reliably
  * Keyboard driver disables kernel debounce on new enough kernels, needed
    for many PS2-USB adaptors, bar code scanners etc
  * Mouse driver will scroll wheel scroll any windows that do respond to
    scroll events, otherwise it issues PointerReason_WheelChange (9) to an
    external WimpScroll module
  * Several bugs and an interrupt hole resolved
Admin:
  Tested at Framlingham.

Version 0.25. Tagged as 'NetBSD-0_25'
@
text
@d141 4
d911 3
d1173 1
a1173 1
	DPRINTFN(14,("ohci_intr1: enter\n"));
d2777 3
d2902 3
d3073 29
d3239 1
d3451 43
d3772 1
@


1.8
log
@Fixes from John Ballance:

Version 0.23. Tagged as 'NetBSD-0_23'
@
text
@d1002 8
a1009 8
//#ifdef DIAGNOSTIC
//	if (xfer->busy_free != XFER_BUSY) {
//		logprintf("ohci_freex: xfer=%p not busy, 0x%08x\n", xfer,
//		       xfer->busy_free);
//		return;
//	}
//	xfer->busy_free = XFER_FREE;
//#endif
d1182 6
d1189 4
a1473 1
		usb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);
d1490 3
d1527 1
d2503 2
d2506 1
d2628 1
a2628 1
	DPRINTFN(4,("ohci_root_ctrl_control type=0x%02x request=%02x\n",
d2634 1
d2805 1
a2805 1
		if (value != 0) {
d3300 3
d3304 1
@


1.7
log
@Merge of Dan Ellis's USB2 sources.

Version 0.22. Tagged as 'NetBSD-0_22'
@
text
@d1002 8
a1009 8
#ifdef DIAGNOSTIC
	if (xfer->busy_free != XFER_BUSY) {
		logprintf("ohci_freex: xfer=%p not busy, 0x%08x\n", xfer,
		       xfer->busy_free);
		return;
	}
	xfer->busy_free = XFER_FREE;
#endif
@


1.6
log
@  Changes to work with TCPIPLibs 5.47.
Detail:
  NetBSD/FreeBSD differences in the naming of certain macros are now resolved
  in TCPIPLibs instead of locally. Also some reordering in the !Mk files in
  order to work with current versions of Zap.
Admin:
  Builds against TCPIPLibs 5.47. Note that this version of the USB sources
  also now requires TCPIPLibs 5.47.

Version 0.21. Tagged as 'NetBSD-0_21'
@
text
@d1 1
a1 1
/*	$NetBSD: ohci.c,v 1.91 2000/06/01 14:28:58 augustss Exp $	*/
d44 2
a45 2
 * OHCI spec: ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a.exe
 * USB spec: http://www.usb.org/developers/data/usb11.pdf
d48 3
d98 3
d110 1
a110 1
#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined (__riscos)
d143 1
a143 1
Static void		ohci_softintr(struct usbd_bus *);
d206 1
a206 1
Static int		ohci_str(usb_string_descriptor_t *, int, char *);
d209 1
a214 1
Static void		ohci_abort_xfer_end(void *);
a280 1

d409 2
a423 2
	char *kernaddr;
	int dmaaddr;
a430 2
		kernaddr = (char*) KERNADDR(&dma);
		dmaaddr = DMAADDR(&dma);
d433 2
a434 2
			sed = (ohci_soft_ed_t *)(kernaddr +offs);
			sed->physaddr = dmaaddr + offs;
a460 1
	int dmaaddr;
a468 1
		dmaaddr = DMAADDR(&dma);
d471 2
a472 2
			std = (ohci_soft_td_t *)((char *)KERNADDR(&dma) +offs);
			std->physaddr = dmaaddr + offs;
d519 1
a519 1
	dataphys = DMAADDR(dma);
d544 1
a544 1
				panic("ohci_alloc_std: curlen == 0\n");
d625 1
d628 2
a629 2
			sitd = (ohci_soft_itd_t *)((char*)KERNADDR(&dma)+offs);
			sitd->physaddr = DMAADDR(&dma) + offs;
d633 1
d661 1
a661 1
		panic("ohci_free_sitd: sitd=%p not done\n", sitd);
d664 2
d712 1
a712 1
	DPRINTF((","));
d714 1
a714 1
	DPRINTF(("%s:", USBDEVNAME(sc->sc_bus.bdev)));
d717 2
a718 2
	DPRINTF((" OHCI version %d.%d%s\n", OHCI_REV_HI(rev), OHCI_REV_LO(rev),
	       OHCI_REV_LEGACY(rev) ? ", legacy support" : ""));
d741 1
a741 1
	sc->sc_hcca = (struct ohci_hcca *)KERNADDR(&sc->sc_hccadma);
d800 1
a800 1
			DPRINTF(("ed#%d ", i));
d803 1
a803 1
	        DPRINTF(("iso "));
d825 2
d834 1
d862 1
a862 1
		DPRINTF(("%s: reset timeout\n", USBDEVNAME(sc->sc_bus.bdev)));
d874 1
a874 1
	OWRITE4(sc, OHCI_HCCA, DMAADDR(&sc->sc_hccadma));
d921 1
a921 1
        DPRINTF(("About to set methods\n"));
a923 1
        DPRINTF(("About to set pipe size\n"));
d927 1
d977 1
a977 1
	if (xfer != NULL)
d979 15
a993 4
	else
		xfer = malloc(sizeof(*xfer), M_USB, M_NOWAIT);
	if (xfer != NULL)
		memset(xfer, 0, sizeof *xfer);
d1002 8
d1035 1
a1035 1
#ifdef OHCI_DEBUG
d1037 2
d1040 1
a1041 1
	/* XXX should suspend/resume */
d1044 49
d1143 3
d1149 1
a1149 1
		DPRINTF(("ohci_intr: ignored interrupt while polling\n"));
d1166 2
d1171 1
a1171 1
		DPRINTF(("ohci_intr: sc->sc_hcca == NULL\n"));
a1178 1
                DPRINTF(("ohci_intr: donehead nonzero\n"));
d1183 1
a1183 1
	        sc->sc_hcca->hcca_done_head = 0;
d1232 8
a1239 1
		DPRINTF(("%s: scheduling overrun\n",USBDEVNAME(sc->sc_bus.bdev)));
d1245 1
a1245 1
#if defined(__riscos)
d1253 1
a1253 1
		DPRINTF(("%s: resume detect\n", USBDEVNAME(sc->sc_bus.bdev)));
a1254 1
		eintrs &= ~OHCI_RD;
d1257 2
a1258 2
		DPRINTF(("%s: unrecoverable error, controller halted\n",
		       USBDEVNAME(sc->sc_bus.bdev)));
a1260 1
		eintrs &= ~OHCI_UE;
d1311 2
a1312 2
		DPRINTF(("%s: blocking intrs 0x%x\n",
		       USBDEVNAME(sc->sc_bus.bdev), eintrs));
a1323 1

d1344 1
a1344 1
ohci_rhsc_enable (void* v_sc)
d1399 1
a1399 1
		panic("ohci_add_done: addr 0x%08lx not found\n", (u_long)done);
d1413 1
a1413 1
ohci_softintr(struct usbd_bus *bus)
d1415 1
a1415 1
	ohci_softc_t *sc = (ohci_softc_t *)bus;
d1419 1
d1421 3
d1434 1
a1434 1
	DPRINTFN(10,("ohci_process_done: sdone=%p sidone=%p\n", sdone, sidone));
d1449 2
a1450 1
			/* xfer == NULL: There seems to be no xfer associated
d1453 1
d1489 1
a1489 2
			struct ohci_pipe *opipe =
				(struct ohci_pipe *)xfer->pipe;
d1520 1
a1520 1
		DPRINTF(("ohci_process_done: ITD done:\n"));
d1532 7
d1548 1
a1548 1
			DPRINTF(("ohci_softintr: sitd=%p is done\n", sitd));
d1551 43
a1593 10
		cc = OHCI_ITD_GET_CC(le32toh(sitd->itd.itd_flags));
		if (cc == OHCI_CC_NO_ERROR) {
			/* XXX compute length for input */
			struct ohci_pipe *opipe =
				(struct ohci_pipe *)xfer->pipe;
			if (sitd->flags & OHCI_CALL_DONE) {
				opipe->u.iso.inuse -= xfer->nframes;
				/* XXX xfer->actlen = actlen; */
				xfer->status = USBD_NORMAL_COMPLETION;
				usb_transfer_complete(xfer);
d1595 6
a1600 3
		} else {
			/* XXX Do more */
			xfer->status = USBD_IOERROR;
d1602 1
d1606 7
d1614 1
d1624 1
a1624 1
		panic("ohci_ctrl_done: not a request\n");
d1658 1
a1658 1
		data->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf));
d1704 1
a1704 1
	p = KERNADDR(&xfer->dmabuf);
d1746 2
d1772 9
d1850 1
a1850 1
	memcpy(KERNADDR(&opipe->u.ctl.reqdma), (void *)req, sizeof *req);
d1854 1
a1854 1
	setup->td.td_cbp = htole32(DMAADDR(&opipe->u.ctl.reqdma));
d1903 2
a1904 2
#if 0
	if (ohcidebug > 10) {
d1908 4
d1933 2
d1956 1
a1956 1
		panic("ohci_rem_ed: ED not found\n");
d2049 23
d2075 1
a2075 1
	DPRINTF(("ohci_timeout: xfer=%p\n", xfer));
a2077 1
	xfer->device->bus->intr_context++;
a2078 1
	xfer->device->bus->intr_context--;
d2093 2
a2105 12

//		 "\20\23R\24OUT\25IN\31TOG1\32SETTOGGLE",
	DPRINTF(("TD(%p) at %08lx: %s delay=%d ec=%d cc=%d\ncbp=0x%08lx "
		 "nexttd=0x%08lx be=0x%08lx\n",
		 std, (u_long)std->physaddr,
		 flags,
		 OHCI_TD_GET_DI(le32toh(std->td.td_flags)),
		 OHCI_TD_GET_EC(le32toh(std->td.td_flags)),
		 OHCI_TD_GET_CC(le32toh(std->td.td_flags)),
		 (u_long)le32toh(std->td.td_cbp),
		 (u_long)le32toh(std->td.td_nexttd),
		 (u_long)le32toh(std->td.td_be)));
d2107 3
a2109 11
	DPRINTF(("TD(%p) at %08lx: %b delay=%d ec=%d cc=%d\ncbp=0x%08lx "
		 "nexttd=0x%08lx be=0x%08lx\n",
		 std, (u_long)std->physaddr,
		 (int)le32toh(std->td.td_flags),
		 "\20\23R\24OUT\25IN\31TOG1\32SETTOGGLE",
		 OHCI_TD_GET_DI(le32toh(std->td.td_flags)),
		 OHCI_TD_GET_EC(le32toh(std->td.td_flags)),
		 OHCI_TD_GET_CC(le32toh(std->td.td_flags)),
		 (u_long)le32toh(std->td.td_cbp),
		 (u_long)le32toh(std->td.td_nexttd),
		 (u_long)le32toh(std->td.td_be)));
d2111 10
d2128 10
a2137 10
	DPRINTF(("ITD(%p) at %08lx: sf=%d di=%d fc=%d cc=%d\n"
		 "bp0=0x%08lx next=0x%08lx be=0x%08lx\n",
		 sitd, (u_long)sitd->physaddr,
		 OHCI_ITD_GET_SF(le32toh(sitd->itd.itd_flags)),
		 OHCI_ITD_GET_DI(le32toh(sitd->itd.itd_flags)),
		 OHCI_ITD_GET_FC(le32toh(sitd->itd.itd_flags)),
		 OHCI_ITD_GET_CC(le32toh(sitd->itd.itd_flags)),
		 (u_long)le32toh(sitd->itd.itd_bp0),
		 (u_long)le32toh(sitd->itd.itd_nextitd),
		 (u_long)le32toh(sitd->itd.itd_be)));
d2139 3
a2141 3
		DPRINTF(("offs[%d]=0x%04x ", i,
			 (u_int)le16toh(sitd->itd.itd_offset[i])));
	DPRINTF(("\n"));
d2166 10
a2175 2
        DPRINTF(("ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %b\ntailp=0x%08lx "
		 "headflags=%b headp=0x%08lx nexted=0x%08lx\n",
d2179 2
a2180 6
		 OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)),
		 (int)le32toh(sed->ed.ed_flags),
		 "\20\14OUT\15IN\16LOWSPEED\17SKIP\20ISO",
		 (u_long)le32toh(sed->ed.ed_tailp),
		 (u_long)le32toh(sed->ed.ed_headp),
		 "\20\1HALT\2CARRY",
d2182 1
a2182 1
		 (u_long)le32toh(sed->ed.ed_nexted)));
a2184 1

d2208 3
d2252 2
a2253 1
			(dev->lowspeed ? OHCI_ED_SPEED : 0) | fmt |
a2321 1
		ohci_physaddr_t td = le32toh(sed->ed.ed_headp);
d2323 1
a2323 5
		for (std = LIST_FIRST(&sc->sc_hash_tds[HASH(td)]);
		     std != NULL;
		     std = LIST_NEXT(std, hnext))
		    if (std->physaddr == td)
			break;
d2329 10
d2342 1
a2342 1
			DPRINTF(("ohci_close_pipe: pipe still not empty\n"));
d2366 3
d2387 7
a2393 1
	ohci_soft_ed_t *sed;
d2395 8
a2402 1
	DPRINTF(("ohci_abort_xfer: xfer=%p pipe=%p\n", xfer, opipe));
d2404 4
a2407 1
	xfer->status = status;
d2409 5
d2415 1
a2415 2

	sed = opipe->sed;
d2418 13
a2430 19
#ifdef __riscos0 /* XXX not sure about this yet */
        if (sed->flags & OHCI_PAUSED)
                return; /* already paused */

        if (!(sed->ed.ed_headp & OHCI_HALTED)) {
                int s;
                s = splusb();
                /* endpoint is active, wait for next SOF befor processing */
                sed->flags |= OHCI_PAUSED;
                OWRITE4(sc, OHCI_INTERRUPT_STATUS, OHCI_SF);
                sed->next = sc->sc_pausededs;
                sc->sc_pausededs = sed;
                OWRITE4(sc, OHCI_INTERRUPT_ENABLE, OHCI_SF);

                /* read again to flush it */
                w = OREAD4(sc, OHCI_CONTROL);
                splx(s);
                return;
        }
d2432 1
a2432 9
#if 1
	if (xfer->device->bus->intr_context) {
		/* We have no process context, so we can't use tsleep(). */
		usb_callout(xfer->pipe->abort_handle,
		    hz / USB_FRAMES_PER_SECOND, ohci_abort_xfer_end, xfer);
	} else {
#if defined(DIAGNOSTIC) && defined(__i386__) && defined(__FreeBSD__)
		KASSERT(intr_nesting_level == 0,
	        	("ohci_abort_req in interrupt context"));
d2434 3
a2436 3
		usb_delay_ms(opipe->pipe.device->bus, 1);
		ohci_abort_xfer_end(xfer);
	}
d2438 1
a2438 2
	delay(1000);
	ohci_abort_xfer_end(xfer);
d2440 2
a2441 14
#endif
}

void
ohci_abort_xfer_end(void *v)
{
	usbd_xfer_handle xfer = v;
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
	ohci_soft_ed_t *sed;
	ohci_soft_td_t *p, *n;
	int s;

	s = splusb();
d2443 8
d2454 2
a2455 1
		DPRINTF(("ohci_abort_xfer: hcpriv==0\n"));
d2459 9
d2469 1
d2473 8
d2482 3
a2484 10
	sed = opipe->sed;
	DPRINTFN(2,("ohci_abort_xfer: set hd=%x, tl=%x\n",
		    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));
#ifdef __riscos  /* XXX not sure about this yet */
        /* remember to set toggle bit correctly */
	sed->ed.ed_headp = /* unlink TDs */
	        htole32(p->physaddr) | sed->ed.ed_headp & OHCI_TOGGLECARRY;
#else
	sed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */
#endif
d2487 3
d2504 1
a2504 1
	0,			/* protocol */
d2532 1
a2532 1
	0,
d2556 1
a2556 4
ohci_str(p, l, s)
	usb_string_descriptor_t *p;
	int l;
	char *s;
d2620 1
a2620 1
		buf = KERNADDR(&xfer->dmabuf);
d2675 1
a2675 3
				totlen = ohci_str(
				    (usb_string_descriptor_t *)buf,
				    len, sc->sc_vendor);
d2678 1
a2678 3
				totlen = ohci_str(
				    (usb_string_descriptor_t *)buf,
				    len, "OHCI root hub");
d2860 6
a2865 1
				usb_delay_ms(&sc->sc_bus, USB_PORT_ROOT_RESET_DELAY);
d2994 1
a2994 1
		DPRINTF(("ohci_device_ctrl_transfer: not a request\n"));
d3075 1
a3075 1
		DPRINTF(("ohci_device_bulk_start: a request\n"));
d3217 1
a3217 1
		panic("ohci_device_intr_transfer: a request\n");
d3233 1
a3233 1
	data->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf));
d3310 1
a3310 1
		panic("ohci_device_intr_close: ED not found\n");
d3333 1
a3333 1
		DPRINTF(("ohci_setintr: 0 interval\n"));
d3440 6
d3447 1
a3447 1
	buf = DMAADDR(&xfer->dmabuf);
d3452 1
d3509 4
d3516 2
d3532 1
d3560 1
a3560 1
		DPRINTF(("uhci_device_isoc_start: not in progress %p\n", xfer));
d3585 1
a3585 1
		DPRINTF(("ohci_device_isoc_abort: early return\n"));
d3598 2
a3599 1
		DPRINTF(("ohci_device_isoc_abort: hcpriv==0\n"));
a3627 3
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
	ohci_soft_itd_t *sitd, *nsitd;
d3631 1
a3631 9
	for (sitd = xfer->hcpriv;
	     !(sitd->flags & OHCI_CALL_DONE);
	     sitd = nsitd) {
		nsitd = sitd->nextitd;
		DPRINTFN(1,("ohci_device_isoc_done: free sitd=%p\n", sitd));
		ohci_free_sitd(sc, sitd);
	}
	ohci_free_sitd(sc, sitd);
	xfer->hcpriv = NULL;
a3656 1
	int s;
a3658 4

	s = splusb();
	ohci_rem_ed(opipe->sed, sc->sc_isoc_head);
	splx(s);
@


1.6.2.1
log
@Added support for HAL USB devices.
Attempted interrupt hole fix.

Version 0.21, 1.22.2.1. Tagged as 'NetBSD-0_21-1_22_2_1'
@
text
@a870 2
#ifndef __riscos
/* KJB fix */
a871 1
#endif
a1246 4
#ifdef __riscos
/* KJB fix */
                if (sc->sc_intrxfer)
#endif
a2733 5
#ifdef __riscos
/* KJB fix */
	OWRITE4(sc, OHCI_INTERRUPT_ENABLE, sc->sc_eintrs | OHCI_MIE);
#endif

a2760 4
#ifdef __riscos
/* KJB fix */
	OWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);
#endif
@


1.5
log
@USB transfer failed reason strings in the messages files were incorrectly
being tokenised. Also added a couple of bits of debug.

Version 0.18. Tagged as 'NetBSD-0_18'
@
text
@d970 1
a970 1
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, xfer, next);
d2053 1
a2053 1
			if (sitd == NULL) 
d2064 1
a2064 1
			if (std == NULL) 
@


1.4
log
@  Support for SCSISoftUSB, and some tidying up.
Detail:
  * Errors now use the allocated error number base, &819000, instead of a
    base in the private range, &50000000. "USB transfer failed" errors now
    have use a sub-range of error numbers from &819020; the original BSD
    error number can be retrieved from the bottom 5 bits of the RISC OS
    error number.
  * Service_USB 1 now returns the list in the order in which the devices,
    rather than in the reverse order as previous versions of the module did.
  * A little tweaking of h/usb_port to reduce compiler warnings.
  * Some compiler-satisfying changes to allow use of packed structures.
    (However, the compiler doesn't seem to work correctly yet, so this is
    currently switched out using -DDISABLE_PACKED on the command line.)
  * Added full stops to end of star command help strings for consistency
    with rest of OS.
  * New exports: USBDevFS (moved here from ^.h) and a few files in dev/usb/h
    and sys/h.
Admin:
  Error number overhaul and new exports are both required by SCSISoftUSB.

Version 0.16. Tagged as 'NetBSD-0_16'
@
text
@d1417 1
d1419 2
@


1.3
log
@Removed a debugging delay from dev.c.ohci which was breaking everything.
Null vendor names no longer say oflaofla.

Version 0.14. Tagged as 'NetBSD-0_14'
@
text
@d1693 1
a1693 1
	memcpy(KERNADDR(&opipe->u.ctl.reqdma), req, sizeof *req);
d2444 1
a2444 1
			memcpy(buf, &ohci_devd, l);
d2452 1
a2452 1
			memcpy(buf, &ohci_confd, l);
d2457 1
a2457 1
			memcpy(buf, &ohci_ifcd, l);
d2462 1
a2462 1
			memcpy(buf, &ohci_endpd, l);
d2607 1
a2607 1
		memcpy(buf, &hubd, l);
d2634 1
a2634 1
		memcpy(buf, &ps, l);
@


1.2
log
@Nicked a few hub related fixes from later NetBSD versions.
Added stuff to delete the DeviceFS$USB*$Options variables when the module is
RMkilled.

Version 0.12. Tagged as 'NetBSD-0_12'
@
text
@a2157 1
	usb_delay_ms(&sc->sc_bus, 1);
@


1.1
log
@Import of USB driver suitable for generic PCI based OHCI controllers.
Correction of spelling of busses to buses (noun plural).
OHCIdriver only responds to PCI service call to lookup vendor name when
the device is of class OHCI controller.

Version 0.01. Tagged as 'NetBSD-0_01'
@
text
@d1385 1
d1387 1
d1418 1
d1420 1
d2050 1
a2050 2
			if (sitd == NULL) {
				ohci_free_sitd(sc, sitd);
a2051 1
			}
d2061 1
a2061 2
			if (std == NULL) {
				ohci_free_std(sc, std);
a2062 1
			}
d2158 1
d2660 2
a2661 2
			for (i = 0; i < 10; i++) {
				usb_delay_ms(&sc->sc_bus, 10);
@


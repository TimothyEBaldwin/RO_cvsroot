head	1.21;
access;
symbols
	NetBSD-1_19:1.21
	NetBSD-1_18:1.21
	NetBSD-1_17:1.21
	NetBSD-1_16:1.21
	NetBSD-1_15:1.21
	NetBSD-1_14:1.21
	NetBSD-1_13:1.21
	NetBSD-1_12:1.21
	NetBSD-1_09-1:1.21
	NetBSD-1_11:1.20
	NetBSD-1_10:1.20
	NetBSD-1_09:1.19
	NetBSD-1_08:1.19
	NetBSD-1_07:1.19
	NetBSD-1_06:1.19
	NetBSD-1_05:1.19
	NetBSD-1_04:1.19
	NetBSD-1_03:1.19
	NetBSD-1_02:1.19
	NetBSD-1_01:1.19
	NetBSD-1_00:1.19
	NetBSD-0_99:1.19
	NetBSD-0_98:1.19
	NetBSD-0_97:1.19
	NetBSD-0_96:1.19
	NetBSD-0_95:1.19
	NetBSD-0_94:1.19
	NetBSD-0_93:1.19
	NetBSD-0_92:1.19
	NetBSD-0_91:1.19
	NetBSD-0_90:1.19
	NetBSD-0_89:1.19
	NetBSD-0_88:1.19
	NetBSD-0_87:1.19
	NetBSD-0_86:1.19
	NetBSD-0_85:1.19
	NetBSD-0_84:1.19
	NetBSD-0_83:1.19
	NetBSD-0_82:1.19
	NetBSD-0_81:1.19
	NetBSD-0_80:1.18
	NetBSD-0_79:1.18
	NetBSD-0_78:1.18
	NetBSD-0_77:1.18
	NetBSD-0_76:1.18
	NetBSD-0_75:1.18
	NetBSD-0_74:1.18
	NetBSD-0_73:1.18
	NetBSD-0_72:1.18
	NetBSD-0_71:1.18
	NetBSD-0_70:1.18
	NetBSD-0_69:1.18
	NetBSD-0_68:1.18
	NetBSD-0_67:1.18
	NetBSD-0_66:1.18
	NetBSD-0_65:1.18
	NetBSD-0_64:1.18
	NetBSD-0_63:1.18
	NetBSD-0_62:1.18
	NetBSD-0_61:1.18
	NetBSD-0_60:1.18
	NetBSD-0_59:1.18
	NetBSD-0_58:1.17
	NetBSD-0_57:1.17
	NetBSD-0_56:1.17
	NetBSD-0_55:1.16
	NetBSD-0_54:1.16
	NetBSD-0_53:1.16
	NetBSD-0_52:1.16
	NetBSD-0_51:1.16
	NetBSD-0_50:1.16
	NetBSD-0_49:1.16
	NetBSD-0_48:1.16
	NetBSD-0_47:1.15
	NetBSD-0_46:1.15
	NetBSD-0_45:1.15
	NetBSD-0_44:1.14
	NetBSD-0_43:1.14
	NetBSD-0_42:1.13
	NetBSD-0_41:1.13
	NetBSD-0_40:1.13
	NetBSD-0_39:1.12
	NetBSD-0_38:1.12
	NetBSD-0_37:1.12
	NetBSD-0_36:1.12
	NetBSD-0_35:1.12
	NetBSD-0_34:1.12
	NetBSD-0_33:1.11
	NetBSD-0_32:1.10
	NetBSD-0_31:1.10
	NetBSD-0_30:1.9
	NetBSD-0_29:1.9
	RO_5_07:1.9
	NetBSD-0_28:1.9
	NetBSD-0_27:1.8
	NetBSD-0_26:1.7
	NetBSD-0_25:1.6
	NetBSD-0_24:1.5
	NetBSD-0_23:1.5
	NetBSD-0_21-1_22_2_1:1.4
	NetBSD-0_22:1.5
	USB1:1.4.0.2
	NetBSD-0_21:1.4
	NetBSD-0_20:1.3
	NetBSD-0_19:1.3
	NetBSD-0_18:1.3
	NetBSD-0_17:1.3
	NetBSD-0_16:1.2
	NetBSD-0_15:1.1
	NetBSD-0_14:1.1
	NetBSD-0_13:1.1
	NetBSD-0_12:1.1
	NetBSD-0_11:1.1
	NetBSD-0_10:1.1
	NetBSD-0_09:1.1
	NetBSD-0_08:1.1
	NetBSD-0_07:1.1
	NetBSD-0_06:1.1
	NetBSD-0_05:1.1
	NetBSD-0_04:1.1
	NetBSD-0_03:1.1
	NetBSD-0_02:1.1
	NetBSD-0_01:1.1;
locks; strict;
comment	@# @;


1.21
date	2016.03.04.20.54.42;	author rool;	state Exp;
branches;
next	1.20;
commitid	MvG9A9da0K4NQmXy;

1.20
date	2016.03.04.01.30.11;	author jballance;	state Exp;
branches;
next	1.19;
commitid	NFICmxi3aahBqgXy;

1.19
date	2013.07.13.17.33.27;	author rsprowson;	state Exp;
branches;
next	1.18;
commitid	vMk6UMBwDXCfMkXw;

1.18
date	2011.05.22.20.22.42;	author jlee;	state Exp;
branches;
next	1.17;
commitid	Ye1jVWDlKivFSIkv;

1.17
date	2010.11.23.22.59.34;	author jlee;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.06.20.44.07;	author jlee;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.05.12.43.04;	author jballance;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.30.22.39.55;	author dellis;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.18.11.54.03;	author jballance;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.31.13.45.35;	author jballance;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.21.22.30.19;	author jballance;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.30.02.34.20;	author jballance;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.12.14.47.41;	author jballance;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.01.18.10.37;	author kbracey;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.30.14.50.37;	author kbracey;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.06.15.50.23;	author bavison;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.21.20.49.19;	author bavison;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.21.15.23.23;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.23.18.20.46;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.14.16.43.50;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.28.09.55.17;	author dellis;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Revert accidental commits
Admin:
  These changes are currently subject to rework via the normal submissions channel.
@
text
@/*      $NetBSD: usbdi.c,v 1.106 2004/10/24 12:52:40 augustss Exp $     */
/*	$FreeBSD: src/sys/dev/usb/usbdi.c,v 1.28 1999/11/17 22:33:49 n_hibma Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifdef __riscos
#include <dev/usb/usbhal.h>
#endif
#include <sys/cdefs.h>
//__KERNEL_RCSID(0, "$NetBSD: usbdi.c,v 1.106 2004/10/24 12:52:40 augustss Exp $");

#include <sys/param.h>
#include <sys/systm.h>
#if defined(__NetBSD__) || defined(__OpenBSD__)
#include <sys/kernel.h>
#include <sys/device.h>
#elif defined(__FreeBSD__)
#include <sys/module.h>
#include <sys/bus.h>
#include <sys/conf.h>
#include "usb_if.h"
#if defined(DIAGNOSTIC) && defined(__i386__)
#include <machine/cpu.h>
#endif
#endif
#include <sys/malloc.h>
#include <sys/proc.h>

#include <machine/bus.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usb_mem.h>
#include <dev/usb/usb_quirks.h>

#if defined(__FreeBSD__)
#include "usb_if.h"
#endif

#ifdef USB_DEBUG
#define DPRINTF(x)	if (usbdebug) logprintf x
#define DPRINTFN(n,x)	if (usbdebug>(n)) logprintf x
extern int usbdebug;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#ifdef __riscos
#define printf logprintf
#endif

Static usbd_status usbd_ar_pipe(usbd_pipe_handle pipe);
Static void usbd_do_request_async_cb
	(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void usbd_start_next(usbd_pipe_handle pipe);
Static usbd_status usbd_open_pipe_ival
	(usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int);

#ifndef __riscos
Static int usbd_nbuses = 0;

void
usbd_init(void)
{
	usbd_nbuses++;
}

void
usbd_finish(void)
{
	--usbd_nbuses;
}
#else
void usbd_init(void) {}
void usbd_finish(void) {}
#endif

static __inline int
usbd_xfer_isread(usbd_xfer_handle xfer)
{
	if (xfer->rqflags & URQ_REQUEST)
		return (xfer->request.bmRequestType & UT_READ);
	else
		return (xfer->pipe->endpoint->edesc->bEndpointAddress &
			UE_DIR_IN);
}

#ifdef USB_DEBUG
void
usbd_dump_iface(struct usbd_interface *iface)
{
        printf("usbd_dump_iface: iface=%p\n", iface);
	if (iface == NULL)
		return;
        printf(" device=%p idesc=%p index=%d altindex=%d priv=%p\n",
	       iface->device, iface->idesc, iface->index, iface->altindex,
	       iface->priv);
}

void
usbd_dump_device(struct usbd_device *dev)
{
        printf("usbd_dump_device: dev=%p\n", dev);
	if (dev == NULL)
		return;
        printf(" bus=%p default_pipe=%p\n", dev->bus, dev->default_pipe);
        printf(" address=%d config=%d depth=%d speed=%d self_powered=%d "
	       "power=%d langid=%d\n",
	       dev->address, dev->config, dev->depth, dev->speed,
	       dev->self_powered, dev->power, dev->langid);
}

void
usbd_dump_endpoint(struct usbd_endpoint *endp)
{
        printf("usbd_dump_endpoint: endp=%p\n", endp);
	if (endp == NULL)
		return;
        printf(" edesc=%p refcnt=%d\n", endp->edesc, endp->refcnt);
	if (endp->edesc)
                printf(" bEndpointAddress=0x%02x\n",
		       endp->edesc->bEndpointAddress);
}

void
usbd_dump_queue(usbd_pipe_handle pipe)
{
	usbd_xfer_handle xfer;

        printf("usbd_dump_queue: pipe=%p\n", pipe);
#ifdef __riscos
	if(pipe)
#endif
	SIMPLEQ_FOREACH(xfer, &pipe->queue, next) {
                printf("  xfer=%p\n", xfer);
	}
	}

void
usbd_dump_pipe(usbd_pipe_handle pipe)
{
        printf("usbd_dump_pipe: pipe=%p\n", pipe);
	if (pipe == NULL)
		return;
	usbd_dump_iface(pipe->iface);
	usbd_dump_device(pipe->device);
	usbd_dump_endpoint(pipe->endpoint);
        printf(" (usbd_dump_pipe:)\n refcnt=%d running=%d aborting=%d\n",
	       pipe->refcnt, pipe->running, pipe->aborting);
        printf(" intrxfer=%p, repeat=%d, interval=%d\n",
	       pipe->intrxfer, pipe->repeat, pipe->interval);
}
#endif

usbd_status
usbd_open_pipe(usbd_interface_handle iface, u_int8_t address,
	       u_int8_t flags, usbd_pipe_handle *pipe)
{
	return (usbd_open_pipe_ival(iface, address, flags, pipe,
				    USBD_DEFAULT_INTERVAL));
}

usbd_status
usbd_open_pipe_ival(usbd_interface_handle iface, u_int8_t address,
		    u_int8_t flags, usbd_pipe_handle *pipe, int ival)
{
	usbd_pipe_handle p;
	struct usbd_endpoint *ep;
	usbd_status err;
	int i;

	DPRINTFN(3,("usbd_open_pipe: iface=%p address=0x%x flags=0x%x\n",
		    iface, address, flags));

	for (i = 0; i < iface->idesc->bNumEndpoints; i++) {
		ep = &iface->endpoints[i];
		if (ep->edesc == NULL)
			return (USBD_IOERROR);
		if (ep->edesc->bEndpointAddress == address)
			goto found;
	}
	return (USBD_BAD_ADDRESS);
 found:
	if ((flags & USBD_EXCLUSIVE_USE) && ep->refcnt != 0)
		return (USBD_IN_USE);
	err = usbd_setup_pipe(iface->device, iface, ep, ival, &p);
	if (err)
		return (err);
	LIST_INSERT_HEAD(&iface->pipes, p, next);
	*pipe = p;
	return (USBD_NORMAL_COMPLETION);
}

usbd_status
usbd_open_pipe_intr(usbd_interface_handle iface, u_int8_t address,
		    u_int8_t flags, usbd_pipe_handle *pipe,
		    usbd_private_handle priv, void *buffer, u_int32_t len,
		    usbd_callback cb, int ival)
{
	usbd_status err;
	usbd_xfer_handle xfer;
	usbd_pipe_handle ipipe;

	DPRINTFN(3,("usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\n",
		    address, flags, len));

	err = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE,
				  &ipipe, ival);
	if (err)
		return (err);
	xfer = usbd_alloc_xfer(iface->device);
	if (xfer == NULL) {
		err = USBD_NOMEM;
		goto bad1;
	}
	usbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,
	    USBD_NO_TIMEOUT, cb);
	ipipe->intrxfer = xfer;

	/* only IN endpoints should repeat */
	ipipe->repeat = UE_GET_DIR(ipipe->endpoint->edesc->bEndpointAddress)
	                == UE_DIR_IN;
	err = usbd_transfer(xfer);
	*pipe = ipipe;
	if (err != USBD_IN_PROGRESS)
		goto bad2;
	return (USBD_NORMAL_COMPLETION);

 bad2:
	ipipe->intrxfer = NULL;
	ipipe->repeat = 0;
	usbd_free_xfer(xfer);
 bad1:
	usbd_close_pipe(ipipe);
	return (err);
}

usbd_status
usbd_close_pipe(usbd_pipe_handle pipe)
{
#ifdef DIAGNOSTIC
	if (pipe == NULL) {
                printf("usbd_close_pipe: pipe==NULL\n");
		return (USBD_NORMAL_COMPLETION);
	}
#endif
#ifdef __riscos
        if(pipe)
        {
#endif
	if (--pipe->refcnt != 0)
		return (USBD_NORMAL_COMPLETION);
	if (! SIMPLEQ_EMPTY(&pipe->queue))
		return (USBD_PENDING_REQUESTS);
	LIST_REMOVE(pipe, next);
	pipe->endpoint->refcnt--;
	pipe->methods->close(pipe);
	if (pipe->intrxfer != NULL)
		usbd_free_xfer(pipe->intrxfer);
	free(pipe, M_USB);
#ifdef __riscos
        }
#endif
	return (USBD_NORMAL_COMPLETION);
}

usbd_status
usbd_transfer(usbd_xfer_handle xfer)
{
	usbd_pipe_handle pipe = xfer->pipe;
	usb_dma_t *dmap = &xfer->dmabuf;
	usbd_status err;
	u_int size;
	int s;


#ifdef __riscos
	DPRINTFN(5,("usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\n",
                    xfer, xfer->flags, pipe, pipe?pipe->running:0));
#else
	DPRINTFN(5,("usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\n",
                    xfer, xfer->flags, pipe, pipe->running));
#endif
#ifdef USB_DEBUG
	if (usbdebug > 5)
		usbd_dump_queue(pipe);
#endif
	xfer->done = 0;

	if (pipe->aborting)
		return (USBD_CANCELLED);

	size = xfer->length;
	/* If there is no buffer, allocate one. */
	if (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {
		struct usbd_bus *bus = pipe->device->bus;

#ifdef DIAGNOSTIC
		if (xfer->rqflags & URQ_AUTO_DMABUF)
                        printf("usbd_transfer: has old buffer!\n");
#endif
		err = bus->methods->allocm(bus, dmap, size);
		if (err)
			return (err);
		xfer->rqflags |= URQ_AUTO_DMABUF;
	}

	/* Copy data if going out. */
	if (!(xfer->flags & USBD_NO_COPY) && size != 0 &&
	    !usbd_xfer_isread(xfer))
#if defined(__riscos) && !defined(USBHAL)
        {
            /* the buffer pointer is actually a buffermanager private ID */
            if (xfer->rqflags & URQ_RISCOS_BUF)
                bufrem (KERNADDR(dmap, 0), xfer->buffer, size);
            else
#endif
		memcpy(KERNADDR(dmap, 0), xfer->buffer, size);
#if defined(__riscos) && !defined(USBHAL)
        }
#endif

	err = pipe->methods->transfer(xfer);

	if (err != USBD_IN_PROGRESS && err) {
	        logprintf ("usbd_transfer: error starting transfer\n");
		/* The transfer has not been queued, so free buffer. */
		if (xfer->rqflags & URQ_AUTO_DMABUF) {
			struct usbd_bus *bus = pipe->device->bus;

			bus->methods->freem(bus, &xfer->dmabuf);
			xfer->rqflags &= ~URQ_AUTO_DMABUF;
		}
	}

	if (!(xfer->flags & USBD_SYNCHRONOUS))
		return (err);

//        logprintf ("synch transfer\n");
	/* Sync transfer, wait for completion. */
	if (err != USBD_IN_PROGRESS)
		return (err);
	s = splusb();
	if (!xfer->done) {
		if (pipe->device->bus->use_polling)
			panic("usbd_transfer: not done");
#ifdef __riscos
		tsleep(xfer, PRIBIO, "usbsyn", 0, 1);
#else
		tsleep(xfer, PRIBIO, "usbsyn", 0);
#endif
	}
	splx(s);
	return (xfer->status);
}

/* Like usbd_transfer(), but waits for completion. */
usbd_status
usbd_sync_transfer(usbd_xfer_handle xfer)
{
	xfer->flags |= USBD_SYNCHRONOUS;
	return (usbd_transfer(xfer));
}

void *
usbd_alloc_buffer(usbd_xfer_handle xfer, u_int32_t size)
{
	struct usbd_bus *bus = xfer->device->bus;
	usbd_status err;

#ifdef DIAGNOSTIC
	if (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))
                printf("usbd_alloc_buffer: xfer already has a buffer\n");
#endif
	err = bus->methods->allocm(bus, &xfer->dmabuf, size);
	if (err)
		return (NULL);
	xfer->rqflags |= URQ_DEV_DMABUF;
	return (KERNADDR(&xfer->dmabuf, 0));
}

void
usbd_free_buffer(usbd_xfer_handle xfer)
{
#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))) {
                printf("usbd_free_buffer: no buffer\n");
		return;
	}
#endif
	xfer->rqflags &= ~(URQ_DEV_DMABUF | URQ_AUTO_DMABUF);
	xfer->device->bus->methods->freem(xfer->device->bus, &xfer->dmabuf);
}

void *
usbd_get_buffer(usbd_xfer_handle xfer)
{
	if (!(xfer->rqflags & URQ_DEV_DMABUF))
		return (0);
	return (KERNADDR(&xfer->dmabuf, 0));
}

usbd_xfer_handle
usbd_alloc_xfer(usbd_device_handle dev)
{

#ifndef __riscos
	usbd_xfer_handle xfer;
#else
	usbd_xfer_handle xfer=NULL;
        /* 20050517 check for null dev->bus->methods since it has cropped up */
        /* 20040723 check for null dev->bus since it has cropped up */
        /* 20050131 check for null dev since it has cropped up */
        if(dev && dev->bus && dev->bus->methods)
#endif
	xfer = dev->bus->methods->allocx(dev->bus);
	if (xfer == NULL)
		return (NULL);
	xfer->device = dev;
	usb_callout_init(xfer->timeout_handle);
	DPRINTFN(5,("usbd_alloc_xfer() = %p\n", xfer));
	return (xfer);
}

usbd_status
usbd_free_xfer(usbd_xfer_handle xfer)
{
	DPRINTFN(5,("usbd_free_xfer: %p\n", xfer));
	if (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))
		usbd_free_buffer(xfer);
#if defined(__NetBSD__) && defined(DIAGNOSTIC)
	if (callout_pending(&xfer->timeout_handle)) {
		callout_stop(&xfer->timeout_handle);
                printf("usbd_free_xfer: timout_handle pending");
	}
#else
#ifdef __riscos
	callout_stop(&xfer->timeout_handle);   /* to make sure!! */
#endif
#endif
#ifdef __riscos
	if (xfer->device->bus && xfer->device->bus->methods)
#endif
		xfer->device->bus->methods->freex(xfer->device->bus, xfer);
	return (USBD_NORMAL_COMPLETION);
}

void
usbd_setup_xfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
		usbd_private_handle priv, void *buffer, u_int32_t length,
		u_int16_t flags, u_int32_t timeout,
		usbd_callback callback)
{
        DPRINTF(("xfer %p threaded onto pipe %p\n", xfer, pipe));
	xfer->pipe = pipe;
	xfer->priv = priv;
	xfer->buffer = buffer;
	xfer->length = length;
	xfer->actlen = 0;
	xfer->flags = flags;
	xfer->timeout = timeout;
	xfer->status = USBD_NOT_STARTED;
	xfer->callback = callback;
	xfer->rqflags &= ~URQ_REQUEST;
	xfer->nframes = 0;
}

void
usbd_setup_default_xfer(usbd_xfer_handle xfer, usbd_device_handle dev,
			usbd_private_handle priv, u_int32_t timeout,
			usb_device_request_t *req, void *buffer,
			u_int32_t length, u_int16_t flags,
			usbd_callback callback)
{
	xfer->pipe = dev->default_pipe;
	xfer->priv = priv;
	xfer->buffer = buffer;
	xfer->length = length;
	xfer->actlen = 0;
	xfer->flags = flags;
	xfer->timeout = timeout;
	xfer->status = USBD_NOT_STARTED;
	xfer->callback = callback;
	xfer->request = *req;
	xfer->rqflags |= URQ_REQUEST;
	xfer->nframes = 0;
}

void
usbd_setup_isoc_xfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
		     usbd_private_handle priv, u_int16_t *frlengths,
		     u_int32_t nframes, u_int16_t flags, usbd_callback callback)
{
	xfer->pipe = pipe;
	xfer->priv = priv;
	xfer->buffer = 0;
	xfer->length = 0;
	xfer->actlen = 0;
	xfer->flags = flags;
	xfer->timeout = USBD_NO_TIMEOUT;
	xfer->status = USBD_NOT_STARTED;
	xfer->callback = callback;
	xfer->rqflags &= ~URQ_REQUEST;
	xfer->frlengths = frlengths;
	xfer->nframes = nframes;
}

void
usbd_get_xfer_status(usbd_xfer_handle xfer, usbd_private_handle *priv,
		     void **buffer, u_int32_t *count, usbd_status *status)
{
	if (priv != NULL)
		*priv = xfer->priv;
	if (buffer != NULL)
		*buffer = xfer->buffer;
	if (count != NULL)
		*count = xfer->actlen;
	if (status != NULL)
		*status = xfer->status;
}

usb_config_descriptor_t *
usbd_get_config_descriptor(usbd_device_handle dev)
{
#ifdef DIAGNOSTIC
	if (dev == NULL) {
                printf("usbd_get_config_descriptor: dev == NULL\n");
		return (NULL);
	}
#endif
	return (dev->cdesc);
}

usb_interface_descriptor_t *
usbd_get_interface_descriptor(usbd_interface_handle iface)
{
#ifdef DIAGNOSTIC
	if (iface == NULL) {
                printf("usbd_get_interface_descriptor: dev == NULL\n");
		return (NULL);
	}
#endif
	return (iface->idesc);
}

usb_device_descriptor_t *
usbd_get_device_descriptor(usbd_device_handle dev)
{
	return (&dev->ddesc);
}

usb_endpoint_descriptor_t *
usbd_interface2endpoint_descriptor(usbd_interface_handle iface, u_int8_t index)
{
	if (index >= iface->idesc->bNumEndpoints)
		return (0);
	return (iface->endpoints[index].edesc);
}

usbd_status
usbd_abort_pipe(usbd_pipe_handle pipe)
{
	usbd_status err;
	int s;

#ifdef DIAGNOSTIC
	if (pipe == NULL) {
                printf("usbd_close_pipe: pipe==NULL\n");
		return (USBD_NORMAL_COMPLETION);
	}
#endif
	s = splusb();
	err = usbd_ar_pipe(pipe);
	splx(s);
	return (err);
}

usbd_status
usbd_clear_endpoint_stall(usbd_pipe_handle pipe)
{
#ifndef __riscos
	usbd_device_handle dev = pipe->device;
#endif
	usb_device_request_t req;
	usbd_status err = USBD_NORMAL_COMPLETION;

	DPRINTFN(8, ("usbd_clear_endpoint_stall\n"));

	/*
	 * Clearing en endpoint stall resets the endpoint toggle, so
	 * do the same to the HC toggle.
	 */
#ifdef __riscos
        usbd_device_handle dev ;
        if(pipe && (dev=pipe->device))
        {
#endif
	pipe->methods->cleartoggle(pipe);

	req.bmRequestType = UT_WRITE_ENDPOINT;
	req.bRequest = UR_CLEAR_FEATURE;
	USETW(req.wValue, UF_ENDPOINT_HALT);
	USETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);
	USETW(req.wLength, 0);
	err = usbd_do_request(dev, &req, 0);
#if 0
XXX should we do this?
	if (!err) {
		pipe->state = USBD_PIPE_ACTIVE;
		/* XXX activate pipe */
	}
#endif
#ifdef __riscos
        }
#endif
	return (err);
}

usbd_status
usbd_clear_endpoint_stall_async(usbd_pipe_handle pipe)
{
#ifdef __riscos
	usb_device_request_t req;
	usbd_status err = USBD_NORMAL_COMPLETION;
        if(pipe && pipe->device)
        {
	usbd_device_handle dev = pipe->device;
#else
	usbd_device_handle dev = pipe->device;
	usb_device_request_t req;
	usbd_status err;
#endif
#ifdef __riscos
        if(pipe->methods)
          if(pipe->methods->cleartoggle)
#else
	pipe->methods->cleartoggle(pipe);
#endif
#ifdef __riscos
        if(pipe->endpoint)
#endif

	req.bmRequestType = UT_WRITE_ENDPOINT;
	req.bRequest = UR_CLEAR_FEATURE;
	USETW(req.wValue, UF_ENDPOINT_HALT);
	USETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);
	USETW(req.wLength, 0);
	err = usbd_do_request_async(dev, &req, 0);
#ifdef __riscos
        }
#endif
	return (err);
}

void
usbd_clear_endpoint_toggle(usbd_pipe_handle pipe)
{
	pipe->methods->cleartoggle(pipe);
}

usbd_status
usbd_endpoint_count(usbd_interface_handle iface, u_int8_t *count)
{
#ifdef DIAGNOSTIC
	if (iface == NULL || iface->idesc == NULL) {
                printf("usbd_endpoint_count: NULL pointer\n");
		return (USBD_INVAL);
	}
#endif
	*count = iface->idesc->bNumEndpoints;
	return (USBD_NORMAL_COMPLETION);
}

usbd_status
usbd_interface_count(usbd_device_handle dev, u_int8_t *count)
{
	if (dev->cdesc == NULL)
		return (USBD_NOT_CONFIGURED);
	*count = dev->cdesc->bNumInterface;
	return (USBD_NORMAL_COMPLETION);
}

void
usbd_interface2device_handle(usbd_interface_handle iface,
			     usbd_device_handle *dev)
{
	*dev = iface->device;
}

usbd_status
usbd_device2interface_handle(usbd_device_handle dev,
			     u_int8_t ifaceno, usbd_interface_handle *iface)
{
	if (dev->cdesc == NULL)
		return (USBD_NOT_CONFIGURED);
	if (ifaceno >= dev->cdesc->bNumInterface)
		return (USBD_INVAL);
	*iface = &dev->ifaces[ifaceno];
	return (USBD_NORMAL_COMPLETION);
}

usbd_device_handle
usbd_pipe2device_handle(usbd_pipe_handle pipe)
{
	return (pipe->device);
}

/* XXXX use altno */
usbd_status
usbd_set_interface(usbd_interface_handle iface, int altidx)
{
	usb_device_request_t req;
	usbd_status err;
	void *endpoints;

	if (LIST_FIRST(&iface->pipes) != 0)
		return (USBD_IN_USE);

	endpoints = iface->endpoints;
	err = usbd_fill_iface_data(iface->device, iface->index, altidx);
	if (err)
		return (err);

	/* new setting works, we can free old endpoints */
	if (endpoints != NULL)
		free(endpoints, M_USB);

#ifdef DIAGNOSTIC
	if (iface->idesc == NULL) {
                printf("usbd_set_interface: NULL pointer\n");
		return (USBD_INVAL);
	}
#endif

	req.bmRequestType = UT_WRITE_INTERFACE;
	req.bRequest = UR_SET_INTERFACE;
	USETW(req.wValue, iface->idesc->bAlternateSetting);
	USETW(req.wIndex, iface->idesc->bInterfaceNumber);
	USETW(req.wLength, 0);
	return (usbd_do_request(iface->device, &req, 0));
}

int
usbd_get_no_alts(usb_config_descriptor_t *cdesc, int ifaceno)
{
	char *p = (char *)cdesc;
	char *end = p + UGETW(cdesc->wTotalLength);
	usb_interface_descriptor_t *d;
	int n;

	for (n = 0; p < end; p += d->bLength) {
		d = (usb_interface_descriptor_t *)p;
		if (p + d->bLength <= end &&
		    d->bDescriptorType == UDESC_INTERFACE &&
		    d->bInterfaceNumber == ifaceno)
			n++;
	}
	return (n);
}

int
usbd_get_interface_altindex(usbd_interface_handle iface)
{
	return (iface->altindex);
}

usbd_status
usbd_get_interface(usbd_interface_handle iface, u_int8_t *aiface)
{
	usb_device_request_t req;

	req.bmRequestType = UT_READ_INTERFACE;
	req.bRequest = UR_GET_INTERFACE;
	USETW(req.wValue, 0);
	USETW(req.wIndex, iface->idesc->bInterfaceNumber);
	USETW(req.wLength, 1);
	return (usbd_do_request(iface->device, &req, aiface));
}

/*** Internal routines ***/

/* Dequeue all pipe operations, called at splusb(). */
Static usbd_status
usbd_ar_pipe(usbd_pipe_handle pipe)
{
#ifdef __riscos
	usbd_xfer_handle xfer, oxfer = NULL;
#else
	usbd_xfer_handle xfer;
#endif

	SPLUSBCHECK;

	DPRINTFN(2,("usbd_ar_pipe: pipe=%p\n", pipe));
#ifdef __riscos
	if(!pipe)
	{
	  return (USBD_NORMAL_COMPLETION);
	}
#endif

#ifdef USB_DEBUG
	if (usbdebug > 5)
		usbd_dump_queue(pipe);
#endif
#ifdef __riscos
        if (pipe)
        {
#endif
	pipe->repeat = 0;
	pipe->aborting = 1;
	while ((xfer = SIMPLEQ_FIRST(&pipe->queue)) != NULL) {
		DPRINTFN(2,("usbd_ar_pipe: pipe=%p xfer=%p (methods=%p)\n",
			    pipe, xfer, pipe->methods));
#ifdef __riscos
		if (xfer == oxfer)
		{
		  DPRINTF(("xfer hasn't changed: %p\n", SIMPLEQ_FIRST(&pipe->queue)));
		  break;
		}
	        oxfer = xfer;
//	        usbdebug = 10;
#endif
		/* Make the HC abort it (and invoke the callback). */
		pipe->methods->abort(xfer);
#ifdef __riscos
		DPRINTF(("first now: %p\n", SIMPLEQ_FIRST(&pipe->queue)));
//		usbdebug = 5;
#endif
		/* XXX only for non-0 usbd_clear_endpoint_stall(pipe); */
	}
	pipe->aborting = 0;
#ifdef __riscos
        }
#endif
	return (USBD_NORMAL_COMPLETION);
}

/* Called at splusb() */
void
usb_transfer_complete(usbd_xfer_handle xfer)
{
	usbd_pipe_handle pipe = xfer->pipe;
	usb_dma_t *dmap = &xfer->dmabuf;
	int sync = xfer->flags & USBD_SYNCHRONOUS;
	int erred = xfer->status == USBD_CANCELLED ||
	    xfer->status == USBD_TIMEOUT;
	int polling = pipe->device->bus->use_polling;
	int repeat;

	SPLUSBCHECK;

	DPRINTFN(5, ("usb_transfer_complete: pipe=%p xfer=%p status=%d "
		     "actlen=%d\n", pipe, xfer, xfer->status, xfer->actlen));

#ifdef DIAGNOSTIC
	KASSERT(polling || pipe->device->bus->lock == NULL ||
	    mutex_owned(pipe->device->bus->lock));

	if (xfer->busy_free != XFER_ONQU) {
		printf("usb_transfer_complete: xfer=%p not queued 0x%08x\n",
		       xfer, xfer->busy_free);
	}
#endif

#ifdef DIAGNOSTIC
	if (pipe == NULL) {
		printf("usb_transfer_complete: pipe==0, xfer=%p\n", xfer);
		return;
	}
#endif
	repeat = pipe->repeat;
	/* XXXX */
	if (polling)
		pipe->running = 0;

	if (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&
	    usbd_xfer_isread(xfer)) {
#ifdef DIAGNOSTIC
		if (xfer->actlen > xfer->length) {
			printf("%s: actlen (%d) > len (%d)\n", __func__,
			       xfer->actlen, xfer->length);
			xfer->actlen = xfer->length;
		}
#endif
#if defined(__riscos) && !defined(USBHAL)
		/* the buffer pointer is actually a buffermanager private ID,
		   but this is sorted out in the code */
		if (xfer->rqflags & URQ_RISCOS_BUF)
			bufins(KERNADDR(dmap, 0), xfer);
		else
#endif
		memcpy(xfer->buffer, KERNADDR(dmap, 0), xfer->actlen);
	}

	/* if we allocated the buffer in usbd_transfer() we free it here. */
	if (xfer->rqflags & URQ_AUTO_DMABUF) {
		if (!repeat) {
			struct usbd_bus *bus = pipe->device->bus;
#ifdef __riscos
			/* Null pointer test below inserted because it was seen jb 20040723  */
			if(bus->methods)
#endif
			bus->methods->freem(bus, dmap);
			xfer->rqflags &= ~URQ_AUTO_DMABUF;
		}
	}

	if (!repeat) {
		/* Remove request from queue. */
#ifdef DIAGNOSTIC
		if (xfer != SIMPLEQ_FIRST(&pipe->queue))
			printf("%s: bad dequeue %p != %p\n", __func__,
			       xfer, SIMPLEQ_FIRST(&pipe->queue));
		xfer->busy_free = XFER_BUSY;
#endif
		SIMPLEQ_REMOVE_HEAD(&pipe->queue, next);
	}
	DPRINTFN(5,("usb_transfer_complete: repeat=%d new head=%p\n",
		    repeat, SIMPLEQ_FIRST(&pipe->queue)));

	/* Count completed transfers. */
	++pipe->device->bus->stats.uds_requests
		[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];

	xfer->done = 1;
	if (!xfer->status && xfer->actlen < xfer->length &&
	    !(xfer->flags & USBD_SHORT_XFER_OK)) {
		DPRINTFN(-1,("usb_transfer_complete: short transfer %d<%d\n",
			     xfer->actlen, xfer->length));
		xfer->status = USBD_SHORT_XFER;
	}

	if (repeat) {
		if (xfer->callback) {
#ifndef __riscos
			if (pipe->device->bus->lock && !polling)
				mutex_exit(pipe->device->bus->lock);

			if (!(pipe->flags & USBD_MPSAFE))
				KERNEL_LOCK(1, curlwp);
#endif
			xfer->callback(xfer, xfer->priv, xfer->status);
#ifndef __riscos
			if (!(pipe->flags & USBD_MPSAFE))
				KERNEL_UNLOCK_ONE(curlwp);

			if (pipe->device->bus->lock && !polling)
				mutex_enter(pipe->device->bus->lock);
#endif
		}
		pipe->methods->done(xfer);
	} else {
		pipe->methods->done(xfer);
		if (xfer->callback) {
#ifndef __riscos
			if (pipe->device->bus->lock && !polling)
				mutex_exit(pipe->device->bus->lock);

			if (!(pipe->flags & USBD_MPSAFE))
				KERNEL_LOCK(1, curlwp);
#endif
			xfer->callback(xfer, xfer->priv, xfer->status);
#ifndef __riscos
			if (!(pipe->flags & USBD_MPSAFE))
				KERNEL_UNLOCK_ONE(curlwp);

			if (pipe->device->bus->lock && !polling)
				mutex_enter(pipe->device->bus->lock);
#endif
		}
	}

	if (sync && !polling) {
#ifndef __riscos
		if (pipe->device->bus->lock)
			cv_broadcast(&xfer->cv);
		else
#endif
			wakeup(xfer);	/* XXXSMP ok */
	}

	if (!repeat) {
		/* XXX should we stop the queue on all errors? */
		if (erred && pipe->iface != NULL)	/* not control pipe */
			pipe->running = 0;
		else
			usbd_start_next(pipe);
	}
}

usbd_status
usb_insert_transfer(usbd_xfer_handle xfer)
{
	usbd_pipe_handle pipe = xfer->pipe;
	usbd_status err;
	int s;

	DPRINTFN(5,("usb_insert_transfer: pipe=%p running=%d timeout=%d\n",
		    pipe, pipe->running, xfer->timeout));
#ifdef DIAGNOSTIC
	if (xfer->busy_free != XFER_BUSY) {
                printf("usb_insert_transfer: xfer=%p not busy 0x%08x\n",
		       xfer, xfer->busy_free);
		return (USBD_INVAL);
	}
	xfer->busy_free = XFER_ONQU;
#endif
	s = splusb();
	SIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);
	if (pipe->running)
		err = USBD_IN_PROGRESS;
	else {
		pipe->running = 1;
		err = USBD_NORMAL_COMPLETION;
	}
	splx(s);
	return (err);
}

/* Called at splusb() */
void
usbd_start_next(usbd_pipe_handle pipe)
{
	usbd_xfer_handle xfer;
	usbd_status err;

	SPLUSBCHECK;

#ifdef DIAGNOSTIC
	if (pipe == NULL) {
                printf("usbd_start_next: pipe == NULL\n");
		return;
	}
	if (pipe->methods == NULL || pipe->methods->start == NULL) {
                printf("usbd_start_next: pipe=%p no start method\n", pipe);
		return;
	}
#endif

	/* Get next request in queue. */
	xfer = SIMPLEQ_FIRST(&pipe->queue);
	DPRINTFN(5, ("usbd_start_next: pipe=%p, xfer=%p\n", pipe, xfer));
	if (xfer == NULL) {
		pipe->running = 0;
	} else {
		err = pipe->methods->start(xfer);
		if (err != USBD_IN_PROGRESS) {
                        printf("usbd_start_next: error=%d\n", err);
			pipe->running = 0;
			/* XXX do what? */
		}
	}
}

usbd_status
usbd_do_request(usbd_device_handle dev, usb_device_request_t *req, void *data)
{
#ifdef __riscos
        /* set flags to allow a short transfer, since some devices require
           this */
	return (usbd_do_request_flags(dev, req, data, USBD_SHORT_XFER_OK /*0*/, 0,
#else
        return (usbd_do_request_flags(dev, req, data, 0, 0,
#endif

				      USBD_DEFAULT_TIMEOUT));
}

usbd_status
usbd_do_request_flags(usbd_device_handle dev, usb_device_request_t *req,
		      void *data, u_int16_t flags, int *actlen, u_int32_t timo)
{
	return (usbd_do_request_flags_pipe(dev, dev->default_pipe, req,
					   data, flags, actlen, timo));
}

usbd_status
usbd_do_request_flags_pipe(usbd_device_handle dev, usbd_pipe_handle pipe,
	usb_device_request_t *req, void *data, u_int16_t flags, int *actlen,
	u_int32_t timeout)
{
	usbd_xfer_handle xfer;
	usbd_status err;

#ifdef DIAGNOSTIC
#if defined(__i386__) && defined(__FreeBSD__)
	KASSERT(intr_nesting_level == 0,
	       	("usbd_do_request: in interrupt context"));
#endif
	if (dev->bus->intr_context) {
                printf("usbd_do_request: not in process context\n");
		return (USBD_INVAL);
	}
#endif

	xfer = usbd_alloc_xfer(dev);
	if (xfer == NULL)
		return (USBD_NOMEM);
	usbd_setup_default_xfer(xfer, dev, 0, timeout, req,
				data, UGETW(req->wLength), flags, 0);
	xfer->pipe = pipe;
	err = usbd_sync_transfer(xfer);
#if defined(USB_DEBUG) || defined(DIAGNOSTIC)
	if (xfer->actlen > xfer->length)
		DPRINTF(("usbd_do_request: overrun addr=%d type=0x%02x req=0x"
			 "%02x val=%d index=%d rlen=%d length=%d actlen=%d\n",
			 dev->address, xfer->request.bmRequestType,
			 xfer->request.bRequest, UGETW(xfer->request.wValue),
			 UGETW(xfer->request.wIndex),
			 UGETW(xfer->request.wLength),
			 xfer->length, xfer->actlen));
#endif
	if (actlen != NULL)
		*actlen = xfer->actlen;
	if (err == USBD_STALLED) {
		/*
		 * The control endpoint has stalled.  Control endpoints
		 * should not halt, but some may do so anyway so clear
		 * any halt condition.
		 */
		usb_device_request_t treq;
		usb_status_t status;
		u_int16_t s;
		usbd_status nerr;

		treq.bmRequestType = UT_READ_ENDPOINT;
		treq.bRequest = UR_GET_STATUS;
		USETW(treq.wValue, 0);
		USETW(treq.wIndex, 0);
		USETW(treq.wLength, USB_STATUS_SIZE);
		usbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,
#ifdef __riscos
					   &treq, (void *)&status,USB_STATUS_SIZE,
#else
					   &treq, &status,USB_STATUS_SIZE,
#endif
					   0, 0);
		nerr = usbd_sync_transfer(xfer);
		if (nerr)
			goto bad;
		s = UGETW(status.wStatus);
		DPRINTF(("usbd_do_request: status = 0x%04x\n", s));
		if (!(s & UES_HALT))
			goto bad;
		treq.bmRequestType = UT_WRITE_ENDPOINT;
		treq.bRequest = UR_CLEAR_FEATURE;
		USETW(treq.wValue, UF_ENDPOINT_HALT);
		USETW(treq.wIndex, 0);
		USETW(treq.wLength, 0);
		usbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,
#ifdef __riscos
					   &treq, (void *)&status, 0, 0, 0);
#else
                                           &treq, &status, 0, 0, 0);
#endif
		nerr = usbd_sync_transfer(xfer);
		if (nerr)
			goto bad;
	}

 bad:
	usbd_free_xfer(xfer);
	return (err);
}

void
usbd_do_request_async_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
			 usbd_status status)
{
#if defined(USB_DEBUG) || defined(DIAGNOSTIC)
	if (xfer->actlen > xfer->length)
		DPRINTF(("usbd_do_request: overrun addr=%d type=0x%02x req=0x"
			 "%02x val=%d index=%d rlen=%d length=%d actlen=%d\n",
			 xfer->pipe->device->address,
			 xfer->request.bmRequestType,
			 xfer->request.bRequest, UGETW(xfer->request.wValue),
			 UGETW(xfer->request.wIndex),
			 UGETW(xfer->request.wLength),
			 xfer->length, xfer->actlen));
#endif
	usbd_free_xfer(xfer);
}

/*
 * Execute a request without waiting for completion.
 * Can be used from interrupt context.
 */
usbd_status
usbd_do_request_async(usbd_device_handle dev, usb_device_request_t *req,
		      void *data)
{
	usbd_xfer_handle xfer;
	usbd_status err;

	xfer = usbd_alloc_xfer(dev);
	if (xfer == NULL)
		return (USBD_NOMEM);
	usbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,
	    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);
	err = usbd_transfer(xfer);
	if (err != USBD_IN_PROGRESS) {
		usbd_free_xfer(xfer);
		return (err);
	}
	return (USBD_NORMAL_COMPLETION);
}

const struct usbd_quirks *
usbd_get_quirks(usbd_device_handle dev)
{
#ifdef DIAGNOSTIC
	if (dev == NULL) {
                printf("usbd_get_quirks: dev == NULL\n");
		return 0;
	}
#endif
	return (dev->quirks);
}

/* XXX do periodic free() of free list */

/*
 * Called from keyboard driver when in polling mode.
 */
void
usbd_dopoll(usbd_interface_handle iface)
{
	iface->device->bus->methods->do_poll(iface->device->bus);
}

void
usbd_set_polling(usbd_device_handle dev, int on)
{
	if (on)
		dev->bus->use_polling++;
	else
		dev->bus->use_polling--;
	/* When polling we need to make sure there is nothing pending to do. */
	if (dev->bus->use_polling)
		dev->bus->methods->soft_intr(dev->bus);
}


usb_endpoint_descriptor_t *
usbd_get_endpoint_descriptor(usbd_interface_handle iface, u_int8_t address)
{
	struct usbd_endpoint *ep;
	int i;

	for (i = 0; i < iface->idesc->bNumEndpoints; i++) {
		ep = &iface->endpoints[i];
		if (ep->edesc->bEndpointAddress == address)
			return (iface->endpoints[i].edesc);
	}
	return (0);
}

/*
 * usbd_ratecheck() can limit the number of error messages that occurs.
 * When a device is unplugged it may take up to 0.25s for the hub driver
 * to notice it.  If the driver continuosly tries to do I/O operations
 * this can generate a large number of messages.
 */
int
usbd_ratecheck(struct timeval *last)
{
	static struct timeval errinterval = { 0, 250000 }; /* 0.25 s*/

	return (ratecheck(last, &errinterval));
}

/*
 * Search for a vendor/product pair in an array.  The item size is
 * given as an argument.
 */
const struct usb_devno *
usb_match_device(const struct usb_devno *tbl, u_int nentries, u_int sz,
		 u_int16_t vendor, u_int16_t product)
{
	while (nentries-- > 0) {
		u_int16_t tproduct = tbl->ud_product;
		if (tbl->ud_vendor == vendor &&
		    (tproduct == product || tproduct == USB_PRODUCT_ANY))
			return (tbl);
		tbl = (const struct usb_devno *)((const char *)tbl + sz);
	}
	return (NULL);
}

#ifndef __riscos
void
usb_desc_iter_init(usbd_device_handle dev, usbd_desc_iter_t *iter)
{
        const usb_config_descriptor_t *cd = usbd_get_config_descriptor(dev);

        iter->cur = (uByte *)cd;
        iter->end = (uByte *)cd + UGETW(cd->wTotalLength);
}

const usb_descriptor_t *
usb_desc_iter_next(usbd_desc_iter_t *iter)
{
        const usb_descriptor_t *desc;

        if (iter->cur + sizeof(usb_descriptor_t) >= iter->end) {
                if (iter->cur != iter->end)
                        printf("usb_desc_iter_next: bad descriptor\n");
                return NULL;
        }
        desc = (usb_descriptor_t *)iter->cur;
        if (desc->bLength == 0) {
                printf("usb_desc_iter_next: descriptor length = 0\n");
                return NULL;
        }
        iter->cur += desc->bLength;
        if (iter->cur > iter->end) {
                printf("usb_desc_iter_next: descriptor length too large\n");
                return NULL;
        }
        return desc;
}

usbd_status
usbd_get_string(usbd_device_handle dev, int si, char *buf)
{
        int swap = dev->quirks->uq_flags & UQ_SWAP_UNICODE;
        usb_string_descriptor_t us;
        char *s;
        int i, n;
        u_int16_t c;
        usbd_status err;
        int size;

        buf[0] = '\0';
        if (si == 0)
                return (USBD_INVAL);
        if (dev->quirks->uq_flags & UQ_NO_STRINGS)
                return (USBD_STALLED);
        if (dev->langid == USBD_NOLANG) {
                /* Set up default language */
                err = usbd_get_string_desc(dev, USB_LANGUAGE_TABLE, 0, &us,
                    &size);
                if (err || size < 4) {
                        DPRINTFN(-1,("usbd_get_string: getting lang failed, using 0\n"));
                        dev->langid = 0; /* Well, just pick something then */
                } else {
                        /* Pick the first language as the default. */
                        dev->langid = UGETW(us.bString[0]);
                }
        }
        err = usbd_get_string_desc(dev, si, dev->langid, &us, &size);
        if (err)
                return (err);
        s = buf;
        n = size / 2 - 1;
        for (i = 0; i < n; i++) {
                c = UGETW(us.bString[i]);
                /* Convert from Unicode, handle buggy strings. */
                if ((c & 0xff00) == 0)
                        *s++ = c;
                else if ((c & 0x00ff) == 0 && swap)
                        *s++ = c >> 8;
                else
                        *s++ = '?';
        }
        *s++ = 0;
        return (USBD_NORMAL_COMPLETION);
}
#endif
#if defined(__FreeBSD__)
int
usbd_driver_load(module_t mod, int what, void *arg)
{
	/* XXX should implement something like a function that removes all generic devices */

 	return (0);
}

#endif
@


1.20
log
@  Fixes for Isochronous data transfer
Detail:
Frontend
========

NetBSD.build.c.usbmodule
	frontend isochronous changes
	forces reads to always be multiple of maxpacket
NetBSD.dev.usb.c.usb_subr
	datatoggle fix
	panic fix
NetBSD.dev.usb.c.usbdi
	usbd_transfer changed so that bufrem is passed the xfer pointer instead of the buffer pointer
	fixed missing braces in usbd_clear_endpoint_stall

EHCI
====

The HS (USB2) isochronous as been rewritten and isochronous split transactions - FS (USB1) over a HS Connection - has been added

NetBSD.dev.usb.c.ehci
NetBSD.dev.usb.h.ehcireg
NetBSD.dev.usb.h.ehcivar

OHCI
====

Changes to the NetBSD backend to get isochronous transfers working on a OHCI device. While it did have isochronous support it wasn't working properly.

NetBSD.dev.usb.c.ohci

Admin:
  Submitted by Colin Granville
Tested in iMx6

Version 1.10. Tagged as 'NetBSD-1_10'
@
text
@d353 1
a353 5
		/*
		 * xfer passed instead of xfer->buffer so that the
		 * transfer type can be found by bufrem.
		 */
		bufrem (KERNADDR(dmap, 0), xfer, size);
a678 1
        {
a688 1
        }
@


1.19
log
@Ensure state consistent for restarting a transfer within a callback
Merge of code change from revision 1.152 of usbdi.c from NetBSD, function usb_transfer_complete - this just swaps the ordering around to ensure the callback & done are in the right order.
Built, but not tested.

Version 0.81. Tagged as 'NetBSD-0_81'
@
text
@d353 5
a357 1
                bufrem (KERNADDR(dmap, 0), xfer->buffer, size);
d683 1
d694 1
@


1.18
log
@Add the ability to build the USB drivers as HAL-compatible static libraries
Detail:
  build/Makefile, build/OBJEHCIDriver, build/OBJOHCIDriver, build/OBJUSBDriver - Modified makefiles to build the HAL libs during the export libs phase
  build/!MkHAL,fd7 - Handy script for building the HAL libs
  build/Hdr/usbhal - Header containing definitions for the assembler code. Also gets exported so that HALs know how much workspace to reserve.
  build/c/usbhal - HAL version of usbmodule.c & port.c. Also contains the keyboard scan code, adapted from the code in the Tungsten HAL.
  build/s/porthal - Assembler versions of some port.c routines that were easier to do in assembler than C
  build/s/halheap - OS_Heap code that's been adapted for use in the HAL. Could easily be changed into a standalone library instead of being part of the HAL USB libs. Supports memory-efficient allocation of aligned blocks.
  build/c/ehcihal - HAL version of ehcimodule.c. Currently only supports EHCI controllers exposed via HAL_USBControllerInfo (i.e. no PCI support)
  build/c/ehcimodule, build/c/ohcimodule, build/c/port - Moved riscos_irq_clear into port.c. Removed unused microtime() function.
  build/c/usbmouse - Strip out some debug-related code in non-debug builds
  build/Version - Updated version numbers
  dev/usb/c/ehci, dev/usb/h/ehcivar - Adapted to add support for the HAL build. Apart from the base changes, the code has also been tweaked to significantly reduce the amount of memory used at runtime by the HAL version of the driver.
  dev/usb/c/hid, dev/usb/c/uhub, dev/usb/c/usb, dev/usb/c/usb_quirks, dev/usb/c/usb_subr, dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/c/usbroothub_subr - Changes to support HAL builds. Mainly disabling bits that won't work in the HAL or disabling bits for RISC OS in general if they weren't being used in the first place.
  dev/usb/c/ohci, dev/usb/h/ohcivar - Basic changes to support HAL builds. However HAL OHCI support is still incomplete.
  dev/usb/h/usb_port - Added support for the HAL build. Also tweaked logprintf definition to get rid of logprintf calls entirely in non-debug builds.
  dev/usb/h/usbdivar - Added support for the HAL build.
  dev/usb/h/usbhal - New header used by the HAL build. Gets included by every C file to ensure the compiler doesn't use sb, and contains structs/macros to allow access to the shared workspace.
Admin:
  HAL & non-HAL builds tested on rev C2 BB, rev A2 BB-xM, rev C1 TouchBook.
  Non-HAL builds tested with Iyonix ROM softload.
  Needs latest Kernel source for OSEntries.h export.


Version 0.59. Tagged as 'NetBSD-0_59'
@
text
@d883 5
a887 5
        int sync = xfer->flags & USBD_SYNCHRONOUS;
        int erred = xfer->status == USBD_CANCELLED ||
            xfer->status == USBD_TIMEOUT;
	int repeat = pipe->repeat;
	int polling;
d893 1
d895 3
d899 1
a899 1
                printf("usb_transfer_complete: xfer=%p not busy 0x%08x\n",
a900 1
		return;
d906 1
a906 1
                printf("usbd_transfer_cb: pipe==0, xfer=%p\n", xfer);
d910 1
a910 1
	polling = pipe->device->bus->use_polling;
d919 1
a919 1
                        printf("usb_transfer_complete: actlen > len %d > %d\n",
d925 5
a929 6
            /* the buffer pointer is actually a buffermanager private ID,
               but this is sorted out in the code */
            if (xfer->rqflags & URQ_RISCOS_BUF)
                bufins (KERNADDR(dmap, 0), xfer);
            else

d951 1
a951 1
                        printf("usb_transfer_complete: bad dequeue %p != %p\n",
d965 3
a967 3
        if (!xfer->status && xfer->actlen < xfer->length &&
            !(xfer->flags & USBD_SHORT_XFER_OK)) {
		DPRINTFN(-1,("usbd_transfer_cb: short transfer %d<%d\n",
d972 13
a984 2
	if (xfer->callback)
		xfer->callback(xfer, xfer->priv, xfer->status);
d986 6
a991 2
#ifdef DIAGNOSTIC
	if (pipe->methods->done != NULL)
d993 7
a999 4
	else
                printf("usb_transfer_complete: pipe->methods->done == NULL\n");
#else
	pipe->methods->done(xfer);
d1001 4
d1006 14
a1019 2
        if (sync && !polling)
		wakeup(xfer);
d1023 1
a1023 1
                if (erred && pipe->iface != NULL)       /* not control pipe */
@


1.17
log
@Fix a few USBDriver bugs
Detail:
  build/c/usbdi - Fix compiler warning in usbd_clear_endpoint_stall()
  build/c/usbmodule - Fix detach_device() to deregister any pending attach callback for the detaching device. Fixes crash seen when inserting 16GB USB stick into EHCI port of rev C2 beagleboard (a current surge or something causes the stick to immediately disconnect then reconnect, but the disconnect occurs before the initial attach callback)
  build/c/usbmodule - Fix device_initialise() to use a timeout of 0 if no timeout was specified in the DeviceFS special field
  build/c/usbmodule - Fix the new read_cb() buffer padding logic to only pad up to totalcount instead of filling the entire buffer
Admin:
  Tested on rev C2 beagleboard.
  This seems to fix the problems that were preventing Steffen Huber's USB CD code from working properly.


Version 0.56. Tagged as 'NetBSD-0_56'
@
text
@d41 3
d97 1
d111 4
d349 1
a349 1
#ifdef __riscos
d357 1
a357 1
#ifdef __riscos
d921 1
a921 1
#ifdef __riscos
@


1.16
log
@Add workaround for incorrect sizeof(usb_status_t), disable debug_set_stamp_debug(TRUE) to fix interrupt issue
Detail:
  build/c/ehcimodule, build/c/ohcimodule, build/c/usbmodule - Make sure that timestamped debug messages aren't used, as they appear to cause interrupts to be briefly enabled, which causes all kinds of problems in sensitive bits of the code.
  dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/h/usb - Because DISABLE_PACKED is being used to compile the USB drivers, sizeof(usb_status_t) was being calculated as 4 bytes instead of 2. Somehow this works fine with the EHCI driver (and presumably the OHCI driver), but it was causing problems with the MUSBDriver, so a hardcoded size of 2 is now used.
Admin:
  Tested on rev C2 beagleboard.


Version 0.48. Tagged as 'NetBSD-0_48'
@
text
@d615 1
a615 1
	usbd_status err;
@


1.15
log
@	re-merged some items missed by Dan, and corrected usbmodule for
	1 item missed earlier.. interrupt out endpoints noe demonstrated
	working
Detail:
Admin:  jb  Castle added IP


Version 0.45. Tagged as 'NetBSD-0_45'
@
text
@d1125 1
a1125 1
		USETW(treq.wLength, sizeof(usb_status_t));
d1128 1
a1128 1
					   &treq, (void *)&status,sizeof(usb_status_t),
d1130 1
a1130 1
					   &treq, &status,sizeof(usb_status_t),
@


1.14
log
@  Now handles interrupt out transfers

Detail:
  There were many places where this was broken: the devicefs
interface was always starting off a read regardless of
whether it was an IN or OUT transfer, usbdi.c was setting
OUT interrupt transfers as repeating, which doesn't make sense,
and ohci.c was always making interrupt transfers OUT (this is
fixed in the latest BSD sources). Also the code which
unhalts endpoints at start of day has been removed, as this is
no longer in the BSD sources having been removed after it was
seend to have caused problems.

Admin:
  Tested with a CATC analyzer on an AverMedia FM radio. If now
operates properly with the code from Dave Higton.

Version 0.43. Tagged as 'NetBSD-0_43'
@
text
@d441 1
d444 1
a444 1
	if(dev && dev->bus)
d611 1
d613 1
d623 5
d643 3
d655 1
a655 1
        if(pipe->device)
@


1.13
log
@	several changes and nullpointer bug fixes
Detail:
	Includes several bug fixes and null pointer traps.
	Rhenium version reviewed and reset should be improved.
Admin:
	Tested in rhenium desktop build and iyonix build at castle
   	Castle added IP


Version 0.40. Tagged as 'NetBSD-0_40'
@
text
@d249 4
a252 1
	ipipe->repeat = 1;
a440 1
        /* 20050517 check for null dev->bus->methods since it has cropped up */
d443 1
a443 1
	if(dev && dev->bus && dev->bus->methods)
a609 1
#ifndef __riscos
a610 1
#endif
d615 1
a619 5
#ifdef __riscos
	usbd_device_handle dev ;
        if(pipe && (dev=pipe->device))
        {
#endif
a634 3
#ifdef __riscos
	}
#endif
d644 1
a644 1
        if(pipe && pipe->device)
d647 1
a647 1
#else                
d670 1
a670 1
#endif                
@


1.12
log
@Summary:  Minor tweaks to USBDriver and EHCI prior to USB2 release
          resulting from beta testing
Detail:
Admin:    castle and d ellis added IP beyond that in NetBSD sources


Version 0.34. Tagged as 'NetBSD-0_34'
@
text
@d438 1
d441 1
a441 1
	if(dev && dev->bus)
d608 1
d610 1
a614 1

d619 5
d639 3
d651 1
a651 1
        if(pipe->device)
@


1.11
log
@        Stack brought up to date with NetBSD sources as at 20050121.
        USB2 further debugged.
Detail:
        Check in prior to second beta release. Improvements also to
        softloading of replacement modules.
Admin:
        Checked with JB .. further crosschecking is still needed for rhenium.
        Castle/D Ellis added ip from NetBSD sources


Version 0.33. Tagged as 'NetBSD-0_33'
@
text
@d439 2
a440 1
	if(dev->bus)
@


1.10
log
@        Update of EHCIDriver to current NetBSD, together with needed changes
        in both OHCIDriver and USBDriver.


Detail:
        Code may change before formal release .. will be beta released
        ... Entered to CVS to get new version numbers, and for
        the record.
Admin:
        Castle/netbsd added IP .. will be tested more fully before
        formal release. Still to be verified on Rhenium.


Version 0.31. Tagged as 'NetBSD-0_31'
@
text
@d83 4
d122 1
a122 1
	logprintf("usbd_dump_iface: iface=%p\n", iface);
d125 1
a125 1
	logprintf(" device=%p idesc=%p index=%d altindex=%d priv=%p\n",
d133 1
a133 1
	logprintf("usbd_dump_device: dev=%p\n", dev);
d136 2
a137 2
	logprintf(" bus=%p default_pipe=%p\n", dev->bus, dev->default_pipe);
	logprintf(" address=%d config=%d depth=%d speed=%d self_powered=%d "
d146 1
a146 1
	logprintf("usbd_dump_endpoint: endp=%p\n", endp);
d149 1
a149 1
	logprintf(" edesc=%p refcnt=%d\n", endp->edesc, endp->refcnt);
d151 1
a151 1
		logprintf(" bEndpointAddress=0x%02x\n",
d160 1
a160 1
	logprintf("usbd_dump_queue: pipe=%p\n", pipe);
d165 1
a165 1
		logprintf("  xfer=%p\n", xfer);
d172 1
a172 1
	logprintf("usbd_dump_pipe: pipe=%p\n", pipe);
d178 1
a178 1
	logprintf(" (usbd_dump_pipe:)\n refcnt=%d running=%d aborting=%d\n",
d180 1
a180 1
	logprintf(" intrxfer=%p, repeat=%d, interval=%d\n",
d270 1
a270 1
		logprintf("usbd_close_pipe: pipe==NULL\n");
d327 1
a327 1
			logprintf("usbd_transfer: has old buffer!\n");
d400 1
a400 1
		logprintf("usbd_alloc_buffer: xfer already has a buffer\n");
d414 1
a414 1
		logprintf("usbd_free_buffer: no buffer\n");
d459 1
a459 1
		logprintf("usbd_free_xfer: timout_handle pending");
d461 4
d552 1
a552 1
		logprintf("usbd_get_config_descriptor: dev == NULL\n");
d564 1
a564 1
		logprintf("usbd_get_interface_descriptor: dev == NULL\n");
d593 1
a593 1
		logprintf("usbd_close_pipe: pipe==NULL\n");
d651 2
a653 1
	pipe->methods->cleartoggle(pipe);
d681 1
a681 1
		logprintf("usbd_endpoint_count: NULL pointer\n");
d745 1
a745 1
		logprintf("usbd_set_interface: NULL pointer\n");
d872 1
a872 1
		logprintf("usb_transfer_complete: xfer=%p not busy 0x%08x\n",
d880 1
a880 1
		logprintf("usbd_transfer_cb: pipe==0, xfer=%p\n", xfer);
d893 1
a893 1
			logprintf("usb_transfer_complete: actlen > len %d > %d\n",
d926 1
a926 1
			logprintf("usb_transfer_complete: bad dequeue %p != %p\n",
d954 1
a954 1
		logprintf("usb_transfer_complete: pipe->methods->done == NULL\n");
d982 1
a982 1
		logprintf("usb_insert_transfer: xfer=%p not busy 0x%08x\n",
d1011 1
a1011 1
		logprintf("usbd_start_next: pipe == NULL\n");
d1015 1
a1015 1
		logprintf("usbd_start_next: pipe=%p no start method\n", pipe);
d1028 1
a1028 1
			logprintf("usbd_start_next: error=%d\n", err);
d1071 1
a1071 1
		logprintf("usbd_do_request: not in process context\n");
d1193 1
a1193 1
		logprintf("usbd_get_quirks: dev == NULL\n");
@


1.9
log
@  Extensive changes and bug fixes to usb and ohci ..
  'blocked' several holes that could cause freezes with awkward
  usb devices.  Added latest changes from Dan Ellis too , especially for USB2
Detail:
 many
Admin:
 Tested in ROM at Castle, and beta tested with users


Version 0.28. Tagged as 'NetBSD-0_28'
@
text
@d1 1
a1 1
/*	$NetBSD: usbdi.c,v 1.103 2002/09/27 15:37:38 provos Exp $	*/
d42 1
a42 1
__KERNEL_RCSID(0, "$NetBSD: usbdi.c,v 1.103 2002/09/27 15:37:38 provos Exp $");
d68 1
d157 1
d159 1
d270 1
d273 1
d284 1
d286 1
d299 2
d303 4
d429 4
d435 3
a437 1
	if(dev->bus)xfer = dev->bus->methods->allocx(dev->bus);
d458 1
d460 1
d629 7
d639 5
a643 1

d645 3
d655 3
d792 1
d794 3
d801 1
d806 1
d812 1
d815 1
d821 1
d829 1
d832 1
d835 1
d839 1
d841 1
d851 3
d904 1
d906 3
a908 1
			if(bus->methods)bus->methods->freem(bus, dmap);
d931 2
a932 3
	if (!xfer->status && xfer->actlen < xfer->length
	                  && !(xfer->flags & USBD_SHORT_XFER_OK))
	{
d950 1
a950 1
	if ((xfer->flags & USBD_SYNCHRONOUS) && !polling)
d955 1
a955 3
		if ((xfer->status == USBD_CANCELLED ||
		     xfer->status == USBD_TIMEOUT) &&
		    pipe->iface != NULL)		/* not control pipe */
d1029 1
d1033 4
d1103 1
d1105 3
d1122 1
d1124 3
d1261 80
@


1.8
log
@More John fixes.

Version 0.27. Tagged as 'NetBSD-0_27'
@
text
@a156 1
	{
a160 1
}
d267 2
a268 1

d279 1
d293 1
a293 1
		    xfer, xfer->flags, pipe, pipe->running));
d416 3
a418 3
	usbd_xfer_handle xfer;

	xfer = dev->bus->methods->allocx(dev->bus);
d768 2
d789 1
d849 2
a850 1
			bus->methods->freem(bus, dmap);
d974 1
a974 1
        /* set flags to allow a short transfer, since some devices requires
@


1.7
log
@Latest stuff from John - mainly Rhenium improvements.

Version 0.26. Tagged as 'NetBSD-0_26'
@
text
@d869 3
a871 3
	if (!xfer->status && xfer->actlen < xfer->length)
	{ 
	   if (!(xfer->flags & USBD_SHORT_XFER_OK)) {
a874 3
	}
	else
	  xfer->status = USBD_SHORT_XFER_DONE;
@


1.6
log
@  New versions from John.
Detail:
  * All modules will now rmkill/rmload more reliably
  * Keyboard driver disables kernel debounce on new enough kernels, needed
    for many PS2-USB adaptors, bar code scanners etc
  * Mouse driver will scroll wheel scroll any windows that do respond to
    scroll events, otherwise it issues PointerReason_WheelChange (9) to an
    external WimpScroll module
  * Several bugs and an interrupt hole resolved
Admin:
  Tested at Framlingham.

Version 0.25. Tagged as 'NetBSD-0_25'
@
text
@d154 1
d156 5
a160 5
        if(pipe)
        {
	  SIMPLEQ_FOREACH(xfer, &pipe->queue, next) {
	  	logprintf("  xfer=%p\n", xfer);
	  }
d269 11
a279 13
        if(pipe)
        {
	  if (--pipe->refcnt != 0)
	  	return (USBD_NORMAL_COMPLETION);
	  if (! SIMPLEQ_EMPTY(&pipe->queue))
	  	return (USBD_PENDING_REQUESTS);
	  LIST_REMOVE(pipe, next);
	  pipe->endpoint->refcnt--;
	  pipe->methods->close(pipe);
	  if (pipe->intrxfer != NULL)
	  	usbd_free_xfer(pipe->intrxfer);
	  free(pipe, M_USB);
	}
d293 1
a293 1
		    xfer, xfer->flags, pipe, pipe?pipe->running:0));
d759 5
d768 19
a786 23
        if (pipe)
        {
	  pipe->repeat = 0;
	  pipe->aborting = 1;
	  while ((xfer = SIMPLEQ_FIRST(&pipe->queue)) != NULL) {
	  	DPRINTFN(2,("usbd_ar_pipe: pipe=%p xfer=%p (methods=%p)\n",
	  		    pipe, xfer, 0/*pipe->methods*/));
	  	if (xfer == oxfer)
	  	{
	  	  DPRINTF(("xfer hasn't changed: %p\n", SIMPLEQ_FIRST(&pipe->queue)));
	  	  break;
	  	}
	          oxfer = xfer;
//	          usbdebug = 10;
	  	/* Make the HC abort it (and invoke the callback). */
	  	DPRINTF(("pipe %p\n", pipe));
	  	pipe->methods->abort(xfer);
	  	DPRINTF(("first now: %p\n", SIMPLEQ_FIRST(&pipe->queue)));
//	  	usbdebug = 5;
	  	/* XXX only for non-0 usbd_clear_endpoint_stall(pipe); */
	  }
	  pipe->aborting = 0;
	}  
d869 3
a871 2
	if (!xfer->status && xfer->actlen < xfer->length &&
	    !(xfer->flags & USBD_SHORT_XFER_OK)) {
d876 3
d973 3
a975 1
	return (usbd_do_request_flags(dev, req, data, 0, 0,
@


1.5
log
@Merge of Dan Ellis's USB2 sources.

Version 0.22. Tagged as 'NetBSD-0_22'
@
text
@a153 1

d155 5
a159 2
	SIMPLEQ_FOREACH(xfer, &pipe->queue, next) {
		logprintf("  xfer=%p\n", xfer);
d268 13
a280 11

	if (--pipe->refcnt != 0)
		return (USBD_NORMAL_COMPLETION);
	if (! SIMPLEQ_EMPTY(&pipe->queue))
		return (USBD_PENDING_REQUESTS);
	LIST_REMOVE(pipe, next);
	pipe->endpoint->refcnt--;
	pipe->methods->close(pipe);
	if (pipe->intrxfer != NULL)
		usbd_free_xfer(pipe->intrxfer);
	free(pipe, M_USB);
d294 1
a294 1
		    xfer, xfer->flags, pipe, pipe->running));
d350 1
a350 1
        logprintf ("synch transfer\n");
d451 1
d755 1
a755 1
	usbd_xfer_handle xfer;
d764 23
a786 10
	pipe->repeat = 0;
	pipe->aborting = 1;
	while ((xfer = SIMPLEQ_FIRST(&pipe->queue)) != NULL) {
		DPRINTFN(2,("usbd_ar_pipe: pipe=%p xfer=%p (methods=%p)\n",
			    pipe, xfer, pipe->methods));
		/* Make the HC abort it (and invoke the callback). */
		pipe->methods->abort(xfer);
		/* XXX only for non-0 usbd_clear_endpoint_stall(pipe); */
	}
	pipe->aborting = 0;
@


1.4
log
@  Changes to work with TCPIPLibs 5.47.
Detail:
  NetBSD/FreeBSD differences in the naming of certain macros are now resolved
  in TCPIPLibs instead of locally. Also some reordering in the !Mk files in
  order to work with current versions of Zap.
Admin:
  Builds against TCPIPLibs 5.47. Note that this version of the USB sources
  also now requires TCPIPLibs 5.47.

Version 0.21. Tagged as 'NetBSD-0_21'
@
text
@d1 1
a1 1
/*	$NetBSD: usbdi.c,v 1.76 2000/06/06 11:36:21 augustss Exp $	*/
d41 3
d84 1
a84 1
(usbd_xfer_handle, usbd_private_handle, usbd_status);
d87 1
a87 1
(usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int);
d114 36
a149 1
void usbd_dump_queue(usbd_pipe_handle pipe);
d155 3
a157 5
	DPRINTF(("usbd_dump_queue: pipe=%p\n", pipe));
	for (xfer = SIMPLEQ_FIRST(&pipe->queue);
	     xfer;
	     xfer = SIMPLEQ_NEXT(xfer, next)) {
		DPRINTF(("  xfer=%p\n", xfer));
d160 15
d262 1
a262 1
		DPRINTF(("usbd_close_pipe: pipe==NULL\n"));
d269 1
a269 1
	if (SIMPLEQ_FIRST(&pipe->queue) != 0)
a273 6
#if defined(__NetBSD__) && defined(DIAGNOSTIC)
	if (callout_pending(&pipe->abort_handle)) {
		callout_stop(&pipe->abort_handle);
		DPRINTF(("usbd_close_pipe: abort_handle pending"));
	}
#endif
d307 1
a307 1
			DPRINTF(("usbd_transfer: has old buffer!\n"));
a310 2
		{
		        DPRINTF(("usbd_transfer: failed allocm\n"));
a311 1
		}
d315 1
d322 1
a322 1
                bufrem (KERNADDR(dmap), xfer->buffer, size);
d325 1
a325 1
		memcpy(KERNADDR(dmap), xfer->buffer, size);
d333 1
d346 1
d353 1
a353 19
			panic("usbd_transfer: not done\n");
		/* XXX Temporary hack XXX */
		if (xfer->flags & USBD_NO_TSLEEP) {
			int i;
			usbd_bus_handle bus = pipe->device->bus;
			int to = xfer->timeout * 1000;
			for (i = 0; i < to; i += 10) {
				delay(10);
				bus->methods->do_poll(bus);
				if (xfer->done)
					break;
			}
			/* XXX Is this right, what about the HC timeout? */
			if (!xfer->done) {
				pipe->methods->abort(xfer);
				xfer->status = USBD_TIMEOUT;
			}
		} else
		/* XXX End hack XXX */
d355 1
a355 2
                        /* TODO supply meaningful noblock parameter */
			tsleep(xfer, PRIBIO, "usbsyn", 0, 0);
d357 1
a357 1
			tsleep(xfer, PRIBIO, "usbsyn", 0);
a367 4
#if defined(__riscos) && 0
        /* RISC OS has no threads, so cannot sleep */
	xfer->flags |= USBD_SYNCHRONOUS | USBD_NO_TSLEEP;
#else
a368 1
#endif
d378 4
d384 1
a384 1
		return (0);
d386 1
a386 1
	return (KERNADDR(&xfer->dmabuf));
d394 1
a394 1
		DPRINTF(("usbd_free_buffer: no buffer\n"));
d407 1
a407 1
	return (KERNADDR(&xfer->dmabuf));
d433 1
a433 1
		DPRINTF(("usbd_free_xfer: timout_handle pending"));
a455 1
	DPRINTF(("usb_setup_xfer: callback set to %p\n", callback));
d519 1
a519 1
		DPRINTF(("usbd_get_config_descriptor: dev == NULL\n"));
d531 1
a531 1
		DPRINTF(("usbd_get_interface_descriptor: dev == NULL\n"));
d560 1
a560 1
		DPRINTF(("usbd_close_pipe: pipe==NULL\n"));
d580 1
a580 1
	 * Clearing en endpoint stall resets the enpoint toggle, so
a618 1
void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe); /* XXXXX */
d630 1
a630 1
		DPRINTF(("usbd_endpoint_count: NULL pointer\n"));
d647 1
a647 1
usbd_status
a651 1
	return (USBD_NORMAL_COMPLETION);
d694 1
a694 1
		DPRINTF(("usbd_set_interface: NULL pointer\n"));
d785 7
d795 1
a795 1
		DPRINTF(("usbd_transfer_cb: pipe==0, xfer=%p\n", xfer));
d817 1
a817 1
                bufins (KERNADDR(dmap), xfer);
d821 1
a821 1
		memcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);
d839 1
d847 1
a847 1
	++pipe->device->bus->stats.requests
d865 1
a865 1
		DPRINTF(("usb_transfer_complete: pipe->methods->done == NULL\n"));
d893 8
d924 1
a924 1
		DPRINTF(("usbd_start_next: pipe == NULL\n"));
d928 1
a928 1
		DPRINTF(("usbd_start_next: pipe=%p no start method\n", pipe));
d941 1
a941 1
			DPRINTF(("usbd_start_next: error=%d\n", err));
d951 2
a952 1
	return (usbd_do_request_flags(dev, req, data, 0, 0));
d957 10
a966 1
		      void *data, u_int16_t flags, int *actlen)
d977 1
a977 3
		DPRINTF(("usbd_do_request: not in process context (%d),"
		          "device = %p\n",
		    dev->bus->intr_context, dev));
d985 3
a987 2
	usbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,
				   data, UGETW(req->wLength), flags, 0);
d1086 1
a1086 1
struct usbd_quirks *
d1089 6
d1116 3
d1148 18
@


1.3
log
@Added new CallDevice reason code (&80000005) to clear a stall condition on
a pipe with a given FileSwitch handle
New usbdevs and usbdevs_data from NetBSD
Rewrote power source detection to skirt round dodgy devices which say
they're self powered,set MaxPower=0,and don't respond to a getstatus()
Copes better with devices being unplugged while a transfer using them is active

Version 0.17. Tagged as 'NetBSD-0_17'
@
text
@d811 1
a811 1
		SIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);
@


1.2
log
@  Support for SCSISoftUSB, and some tidying up.
Detail:
  * Errors now use the allocated error number base, &819000, instead of a
    base in the private range, &50000000. "USB transfer failed" errors now
    have use a sub-range of error numbers from &819020; the original BSD
    error number can be retrieved from the bottom 5 bits of the RISC OS
    error number.
  * Service_USB 1 now returns the list in the order in which the devices,
    rather than in the reverse order as previous versions of the module did.
  * A little tweaking of h/usb_port to reduce compiler warnings.
  * Some compiler-satisfying changes to allow use of packed structures.
    (However, the compiler doesn't seem to work correctly yet, so this is
    currently switched out using -DDISABLE_PACKED on the command line.)
  * Added full stops to end of star command help strings for consistency
    with rest of OS.
  * New exports: USBDevFS (moved here from ^.h) and a few files in dev/usb/h
    and sys/h.
Admin:
  Error number overhaul and new exports are both required by SCSISoftUSB.

Version 0.16. Tagged as 'NetBSD-0_16'
@
text
@d411 2
a412 1
	xfer->device->bus->methods->freex(xfer->device->bus, xfer);
@


1.1
log
@Import of USB driver suitable for generic PCI based OHCI controllers.
Correction of spelling of busses to buses (noun plural).
OHCIdriver only responds to PCI service call to lookup vendor name when
the device is of class OHCI controller.

Version 0.01. Tagged as 'NetBSD-0_01'
@
text
@d970 1
a970 1
					   &treq, &status,sizeof(usb_status_t),
d985 1
a985 1
					   &treq, &status, 0, 0, 0);
@


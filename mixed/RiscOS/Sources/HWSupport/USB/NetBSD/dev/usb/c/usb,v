head	1.12;
access;
symbols
	NetBSD-1_19:1.12
	NetBSD-1_18:1.12
	NetBSD-1_17:1.12
	NetBSD-1_16:1.12
	NetBSD-1_15:1.12
	NetBSD-1_14:1.12
	NetBSD-1_13:1.12
	NetBSD-1_12:1.12
	NetBSD-1_09-1:1.12
	NetBSD-1_11:1.12
	NetBSD-1_10:1.12
	NetBSD-1_09:1.12
	NetBSD-1_08:1.12
	NetBSD-1_07:1.11
	NetBSD-1_06:1.10
	NetBSD-1_05:1.10
	NetBSD-1_04:1.10
	NetBSD-1_03:1.10
	NetBSD-1_02:1.10
	NetBSD-1_01:1.10
	NetBSD-1_00:1.10
	NetBSD-0_99:1.10
	NetBSD-0_98:1.10
	NetBSD-0_97:1.10
	NetBSD-0_96:1.10
	NetBSD-0_95:1.10
	NetBSD-0_94:1.10
	NetBSD-0_93:1.10
	NetBSD-0_92:1.10
	NetBSD-0_91:1.10
	NetBSD-0_90:1.10
	NetBSD-0_89:1.10
	NetBSD-0_88:1.10
	NetBSD-0_87:1.10
	NetBSD-0_86:1.10
	NetBSD-0_85:1.10
	NetBSD-0_84:1.10
	NetBSD-0_83:1.10
	NetBSD-0_82:1.10
	NetBSD-0_81:1.10
	NetBSD-0_80:1.10
	NetBSD-0_79:1.10
	NetBSD-0_78:1.10
	NetBSD-0_77:1.10
	NetBSD-0_76:1.10
	NetBSD-0_75:1.10
	NetBSD-0_74:1.10
	NetBSD-0_73:1.10
	NetBSD-0_72:1.10
	NetBSD-0_71:1.10
	NetBSD-0_70:1.10
	NetBSD-0_69:1.10
	NetBSD-0_68:1.10
	NetBSD-0_67:1.10
	NetBSD-0_66:1.10
	NetBSD-0_65:1.10
	NetBSD-0_64:1.10
	NetBSD-0_63:1.10
	NetBSD-0_62:1.10
	NetBSD-0_61:1.10
	NetBSD-0_60:1.10
	NetBSD-0_59:1.10
	NetBSD-0_58:1.9
	NetBSD-0_57:1.9
	NetBSD-0_56:1.9
	NetBSD-0_55:1.9
	NetBSD-0_54:1.9
	NetBSD-0_53:1.9
	NetBSD-0_52:1.9
	NetBSD-0_51:1.9
	NetBSD-0_50:1.9
	NetBSD-0_49:1.9
	NetBSD-0_48:1.9
	NetBSD-0_47:1.9
	NetBSD-0_46:1.9
	NetBSD-0_45:1.9
	NetBSD-0_44:1.9
	NetBSD-0_43:1.9
	NetBSD-0_42:1.9
	NetBSD-0_41:1.9
	NetBSD-0_40:1.9
	NetBSD-0_39:1.9
	NetBSD-0_38:1.8
	NetBSD-0_37:1.8
	NetBSD-0_36:1.7
	NetBSD-0_35:1.7
	NetBSD-0_34:1.7
	NetBSD-0_33:1.7
	NetBSD-0_32:1.6
	NetBSD-0_31:1.6
	NetBSD-0_30:1.5
	NetBSD-0_29:1.5
	RO_5_07:1.5
	NetBSD-0_28:1.5
	NetBSD-0_27:1.4
	NetBSD-0_26:1.4
	NetBSD-0_25:1.4
	NetBSD-0_24:1.3
	NetBSD-0_23:1.3
	NetBSD-0_21-1_22_2_1:1.2
	NetBSD-0_22:1.3
	USB1:1.2.0.2
	NetBSD-0_21:1.2
	NetBSD-0_20:1.1
	NetBSD-0_19:1.1
	NetBSD-0_18:1.1
	NetBSD-0_17:1.1
	NetBSD-0_16:1.1
	NetBSD-0_15:1.1
	NetBSD-0_14:1.1
	NetBSD-0_13:1.1
	NetBSD-0_12:1.1
	NetBSD-0_11:1.1
	NetBSD-0_10:1.1
	NetBSD-0_09:1.1
	NetBSD-0_08:1.1
	NetBSD-0_07:1.1
	NetBSD-0_06:1.1
	NetBSD-0_05:1.1
	NetBSD-0_04:1.1
	NetBSD-0_03:1.1
	NetBSD-0_02:1.1
	NetBSD-0_01:1.1;
locks; strict;
comment	@# @;


1.12
date	2015.11.15.09.42.44;	author rool;	state Exp;
branches;
next	1.11;
commitid	QBgP4ciWEprNGaJy;

1.11
date	2015.11.12.22.28.40;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	xXLLfyXXvY7x1RIy;

1.10
date	2011.05.22.20.22.42;	author jlee;	state Exp;
branches;
next	1.9;
commitid	Ye1jVWDlKivFSIkv;

1.9
date	2005.04.24.23.13.53;	author jballance;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.24.14.02.56;	author jballance;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.21.22.30.19;	author jballance;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.30.02.34.20;	author jballance;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.12.14.47.41;	author jballance;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.06.15.50.23;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.21.20.49.19;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.21.15.23.23;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.28.09.55.17;	author dellis;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Add support for HC with hardware enumerate phase
Detail:
  Support controllers such as the XHCI which perform some steps of enumeration themselves in hardware, thereby needing some steps of the software enumeration to be bypassed.
  usb.c:
    Internally permit addr of 0, to represent the root hub, since the controller is responsible for allocating 1+. Merged from NetBSD 1.144.
  usb_subr.c:
    Test pointers against NULL not 0. Merged from NetBSD 1.191.
    Add 4 new bus methods, for prior to enumeration, address assignment phase, post enumeration fixup, and device removal.
  usbdivar.h:
    Prototypes of 4 new bus methods.
Admin:
  HC API version number bumped.
  Submission from Elesar.

Version 1.08. Tagged as 'NetBSD-1_08'
@
text
@/*      $NetBSD: usb.c,v 1.81 2005/01/24 01:30:38 joff Exp $    */

/*
 * Copyright (c) 1998, 2002 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * USB specifications and other documentation can be found at
 * http://www.usb.org/developers/docs/ and
 * http://www.usb.org/developers/devclass_docs/
 */

#ifdef __riscos
#include <dev/usb/usbhal.h>
#endif
#include <sys/cdefs.h>
//__KERNEL_RCSID(0, "$NetBSD: usb.c,v 1.81 2005/01/24 01:30:38 joff Exp $");
//#include "ohci.h"
//#include "uhci.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#ifndef __riscos
#include <sys/kthread.h>
#endif
#include <sys/proc.h>
#include <sys/conf.h>
#include <sys/fcntl.h>
#include <sys/poll.h>
#include <sys/select.h>
#include <sys/vnode.h>
#include <sys/signalvar.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>

#define USB_DEV_MINOR 255

#include <machine/bus.h>

#include <dev/usb/usbdivar.h>
#include <dev/usb/usb_quirks.h>

#ifdef USB_DEBUG
#define DPRINTF(x)	if (usbdebug) logprintf x
#define DPRINTFN(n,x)	if (usbdebug>(n)) logprintf x
int	usbdebug = 0;
#ifdef UHCI_DEBUG
int	uhcidebug;
#endif
#ifdef OHCI_DEBUG
int	ohcidebug;
#endif


/*
 * 0  - do usual exploration
 * 1  - do not use timeout exploration
 * >1 - do no exploration
 */
int	usb_noexplore = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#ifdef __riscos
#define printf logprintf 
#endif

struct usb_softc {
	USBBASEDEVICE	sc_dev;		/* base device */
	usbd_bus_handle sc_bus;		/* USB controller */
	struct usbd_port sc_port;	/* dummy port for root hub */

	struct proc	*sc_event_thread;

	char		sc_dying;
};

#ifndef __riscos
TAILQ_HEAD(, usb_task) usb_all_tasks;

dev_type_open(usbopen);
dev_type_close(usbclose);
dev_type_read(usbread);
dev_type_ioctl(usbioctl);
dev_type_poll(usbpoll);
dev_type_kqfilter(usbkqfilter);

const struct cdevsw usb_cdevsw = {
	usbopen, usbclose, usbread, nowrite, usbioctl,
	nostop, notty, usbpoll, nommap, usbkqfilter,
};
#endif

Static void	usb_discover(void *);
#ifndef __riscos
Static void	usb_create_event_thread(void *);
Static void	usb_event_thread(void *);
Static void	usb_task_thread(void *);
Static struct proc *usb_task_thread_proc = NULL;

#define USB_MAX_EVENTS 100
struct usb_event_q {
	struct usb_event ue;
	SIMPLEQ_ENTRY(usb_event_q) next;
};
Static SIMPLEQ_HEAD(, usb_event_q) usb_events =
	SIMPLEQ_HEAD_INITIALIZER(usb_events);
Static int usb_nevents = 0;
Static struct selinfo usb_selevent;
Static usb_proc_ptr usb_async_proc;  /* process that wants USB SIGIO */
Static int usb_dev_open = 0;
#endif
Static void usb_add_event(int, struct usb_event *);

Static int usb_get_next_event(struct usb_event *);

Static const char *usbrev_str[] = USBREV_STR;

USB_DECLARE_DRIVER(usb);

USB_MATCH(usb)
{
	DPRINTF(("usbd_match\n"));
	return (UMATCH_GENERIC);
}

USB_ATTACH(usb)
{
	struct usb_softc *sc = (struct usb_softc *)self;
	usbd_device_handle dev;
	usbd_status err;
	int usbrev;
	int speed;
	struct usb_event ue;

	DPRINTF(("usbd_attach\n"));

	usbd_init();
	sc->sc_bus = aux;
	sc->sc_bus->usbctl = sc;
	sc->sc_port.power = USB_MAX_POWER;

	usbrev = sc->sc_bus->usbrev;
        printf(": USB revision %s", usbrev_str[usbrev]);
	switch (usbrev) {
	case USBREV_1_0:
	case USBREV_1_1:
		speed = USB_SPEED_FULL;
		break;
	case USBREV_2_0:
		speed = USB_SPEED_HIGH;
		break;
	default:
                printf(", not supported\n");
		sc->sc_dying = 1;
		USB_ATTACH_ERROR_RETURN;
	}
        printf("\n");

	/* Make sure not to use tsleep() if we are cold booting. */
	if (cold)
		sc->sc_bus->use_polling++;

	ue.u.ue_ctrlr.ue_bus = USBDEVUNIT(sc->sc_dev);
	usb_add_event(USB_EVENT_CTRLR_ATTACH, &ue);

#ifdef USB_USE_SOFTINTR
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	/* XXX we should have our own level */
	sc->sc_bus->soft = softintr_establish(IPL_SOFTNET,
	    sc->sc_bus->methods->soft_intr, sc->sc_bus);
	if (sc->sc_bus->soft == NULL) {
                printf("%s: can't register softintr\n", USBDEVNAME(sc->sc_dev));
		sc->sc_dying = 1;
		USB_ATTACH_ERROR_RETURN;
	}
#else
	usb_callout_init(sc->sc_bus->softi);
#endif
#endif

	err = usbd_new_device(USBDEV(sc->sc_dev), sc->sc_bus, 0, speed, 0,
		  &sc->sc_port);
	if (!err) {
		dev = sc->sc_port.device;
		if (dev->hub == NULL) {
			sc->sc_dying = 1;
                        printf("%s: root device is not a hub\n",
			       USBDEVNAME(sc->sc_dev));
			USB_ATTACH_ERROR_RETURN;
		}
		sc->sc_bus->root_hub = dev;
#if 1
		/*
		 * Turning this code off will delay attachment of USB devices
		 * until the USB event thread is running, which means that
		 * the keyboard will not work until after cold boot.
		 */
		if (cold && (sc->sc_dev.dv_cfdata->cf_flags & 1))
			dev->hub->explore(sc->sc_bus->root_hub);
#endif
	} else {
                printf("%s: root hub problem, error=%d\n",
		       USBDEVNAME(sc->sc_dev), err);
		sc->sc_dying = 1;
	}
	if (cold)
		sc->sc_bus->use_polling--;

	config_pending_incr();
#ifdef __riscos
	/* set the explore flag here since threads don't do anything */
	sc->sc_bus->needs_explore = 1;
	usb_needs_explore_callback(sc->sc_bus);
#else
	usb_kthread_create(usb_create_event_thread, sc);
#endif

	USB_ATTACH_SUCCESS_RETURN;
}

#if defined(__NetBSD__) || defined(__OpenBSD__)
void
usb_create_event_thread(void *arg)
{
	struct usb_softc *sc = arg;
	static int created = 0;

	if (usb_kthread_create1(usb_event_thread, sc, &sc->sc_event_thread,
			   "%s", sc->sc_dev.dv_xname)) {
                printf("%s: unable to create event thread for\n",
		       sc->sc_dev.dv_xname);
		panic("usb_create_event_thread");
	}
	if (!created) {
		created = 1;
		TAILQ_INIT(&usb_all_tasks);
		if (usb_kthread_create1(usb_task_thread, NULL,
					&usb_task_thread_proc, "usbtask")) {
                        printf("unable to create task thread\n");
			panic("usb_create_event_thread task");
		}
	}
}

/*
 * Add a task to be performed by the task thread.  This function can be
 * called from any context and the task will be executed in a process
 * context ASAP.
 */
void
usb_add_task(usbd_device_handle dev, struct usb_task *task)
{
	int s;

	s = splusb();
	if (!task->onqueue) {
		DPRINTFN(2,("usb_add_task: task=%p\n", task));
		TAILQ_INSERT_TAIL(&usb_all_tasks, task, next);
		task->onqueue = 1;
	} else {
		DPRINTFN(3,("usb_add_task: task=%p on q\n", task));
	}
	wakeup(&usb_all_tasks);
	splx(s);
}

void
usb_rem_task(usbd_device_handle dev, struct usb_task *task)
{
	int s;

	s = splusb();
	if (task->onqueue) {
		TAILQ_REMOVE(&usb_all_tasks, task, next);
		task->onqueue = 0;
	}
	splx(s);
}

void
usb_event_thread(void *arg)
{
	struct usb_softc *sc = arg;

	DPRINTF(("usb_event_thread: start\n"));

	/*
	 * In case this controller is a companion controller to an
	 * EHCI controller we need to wait until the EHCI controller
	 * has grabbed the port.
	 * XXX It would be nicer to do this with a tsleep(), but I don't
	 * know how to synchronize the creation of the threads so it
	 * will work.
	 */
	usb_delay_ms(sc->sc_bus, 500);    

	/* Make sure first discover does something. */
	sc->sc_bus->needs_explore = 1;
	usb_discover(sc);
	config_pending_decr();

	while (!sc->sc_dying) {
#ifdef USB_DEBUG
		if (usb_noexplore < 2)
#endif
		usb_discover(sc);
#ifdef USB_DEBUG
		(void)tsleep(&sc->sc_bus->needs_explore, PWAIT, "usbevt",
		    usb_noexplore ? 0 : hz * 60);
#else
		(void)tsleep(&sc->sc_bus->needs_explore, PWAIT, "usbevt",
		    hz * 60);
#endif
		DPRINTFN(2,("usb_event_thread: woke up\n"));
	}
	sc->sc_event_thread = NULL;

	/* In case parent is waiting for us to exit. */
	wakeup(sc);

	DPRINTF(("usb_event_thread: exit\n"));
	kthread_exit(0);
}

void
usb_task_thread(void *arg)
{
	struct usb_task *task;
	int s;

	DPRINTF(("usb_task_thread: start\n"));

	s = splusb();
	for (;;) {
		task = TAILQ_FIRST(&usb_all_tasks);
		if (task == NULL) {
			tsleep(&usb_all_tasks, PWAIT, "usbtsk", 0);
			task = TAILQ_FIRST(&usb_all_tasks);
		}
		DPRINTFN(2,("usb_task_thread: woke up task=%p\n", task));
		if (task != NULL) {
			TAILQ_REMOVE(&usb_all_tasks, task, next);
			task->onqueue = 0;
			splx(s);
			task->fun(task->arg);
			s = splusb();
		}
	}
}

int
usbctlprint(void *aux, const char *pnp)
{
	/* only "usb"es can attach to host controllers */
	if (pnp)
		logprintf("usb at %s", pnp);

	return (UNCONF);
}
#elif defined(__riscos)
/* Dummy versions for RISC OS
   TODO - Check that nothing relies on the task/event code working */
void usb_create_event_thread(void *arg)
{
}

void usb_add_task(usbd_device_handle dev, struct usb_task *task)
{
}

void usb_rem_task(usbd_device_handle dev, struct usb_task *task)
{
}

int
usbctlprint(void *aux, const char *pnp)
{
	/* only "usb"es can attach to host controllers */
	if (pnp)
		logprintf("usb at %s", pnp);

	return (UNCONF);
}
#endif

#ifndef __riscos
int
usbopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
{
	int unit = minor(dev);
	struct usb_softc *sc;

	if (unit == USB_DEV_MINOR) {
		if (usb_dev_open)
			return (EBUSY);
		usb_dev_open = 1;
		usb_async_proc = 0;
		return (0);
	}

	USB_GET_SC_OPEN(usb, unit, sc);

	if (sc->sc_dying)
		return (EIO);

	return (0);
}

int
usbread(dev_t dev, struct uio *uio, int flag)
{
	struct usb_event ue;
	int s, error, n;

	if (minor(dev) != USB_DEV_MINOR)
		return (ENXIO);

	if (uio->uio_resid != sizeof(struct usb_event))
		return (EINVAL);

	error = 0;
	s = splusb();
	for (;;) {
		n = usb_get_next_event(&ue);
		if (n != 0)
			break;
		if (flag & IO_NDELAY) {
			error = EWOULDBLOCK;
			break;
		}
#ifdef __riscos
		error = tsleep(&usb_events, PZERO | PCATCH, "usbrea", 0, 1);
#else
		error = tsleep(&usb_events, PZERO | PCATCH, "usbrea", 0);
#endif
		if (error)
			break;
	}
	splx(s);
	if (!error)
		error = uiomove((void *)&ue, uio->uio_resid, uio);

	return (error);
}

int
usbclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
{
	int unit = minor(dev);

	if (unit == USB_DEV_MINOR) {
		usb_async_proc = 0;
		usb_dev_open = 0;
	}

	return (0);
}
#endif

int
usbioctl(dev_t devt, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
{
	struct usb_softc *sc;
	int unit = minor(devt);

	if (unit == USB_DEV_MINOR) {
		switch (cmd) {
		case FIONBIO:
			/* All handled in the upper FS layer. */
			return (0);

		case FIOASYNC:
#ifndef __riscos
			if (*(int *)data)
				usb_async_proc = p;
			else
				usb_async_proc = 0;
#endif
			return (0);

		default:
			return (EINVAL);
		}
	}

	USB_GET_SC(usb, unit, sc);

	if (sc->sc_dying)
		return (EIO);

	switch (cmd) {
#ifdef USB_DEBUG
	case USB_SETDEBUG:
		if (!(flag & FWRITE))
			return (EBADF);
		usbdebug  = ((*(int *)data) & 0x000000ff);
#ifdef UHCI_DEBUG
		uhcidebug = ((*(int *)data) & 0x0000ff00) >> 8;
#endif
#ifdef OHCI_DEBUG
		ohcidebug = ((*(int *)data) & 0x00ff0000) >> 16;
#endif
		break;
#endif /* USB_DEBUG */
#ifdef __riscos
	case USB_DISCOVER:
		sc->sc_bus->needs_explore = 1;
		usb_needs_explore_callback(sc->sc_bus);
		break;
#endif
	case USB_REQUEST:
	{
		struct usb_ctl_request *ur = (void *)data;
		int len = UGETW(ur->ucr_request.wLength);
		struct iovec iov;
		struct uio uio;
		void *ptr = 0;
		int addr = ur->ucr_addr;
		usbd_status err;
		int error = 0;

		if (!(flag & FWRITE))
			return (EBADF);

		DPRINTF(("usbioctl: USB_REQUEST addr=%d len=%d\n", addr, len));
		if (len < 0 || len > 32768)
			return (EINVAL);
		if (addr < 0 || addr >= USB_MAX_DEVICES ||
		    sc->sc_bus->devices[addr] == NULL)
			return (EINVAL);
		if (len != 0) {
			iov.iov_base = (caddr_t)ur->ucr_data;
			iov.iov_len = len;
			uio.uio_iov = &iov;
			uio.uio_iovcnt = 1;
			uio.uio_resid = len;
			uio.uio_offset = 0;
			uio.uio_segflg = UIO_USERSPACE;
			uio.uio_rw =
				ur->ucr_request.bmRequestType & UT_READ ?
				UIO_READ : UIO_WRITE;
			uio.uio_procp = p;
			ptr = malloc(len, M_TEMP, M_WAITOK);
			if (uio.uio_rw == UIO_WRITE) {
				error = uiomove(ptr, len, &uio);
				if (error)
					goto ret;
			}
		}
		err = usbd_do_request_flags(sc->sc_bus->devices[addr],
			  &ur->ucr_request, ptr, ur->ucr_flags, &ur->ucr_actlen,
			  USBD_DEFAULT_TIMEOUT);
		if (err) {
			error = EIO;
			goto ret;
		}
		if (len != 0) {
			if (uio.uio_rw == UIO_READ) {
				error = uiomove(ptr, len, &uio);
				if (error)
					goto ret;
			}
		}
	ret:
		if (ptr)
			free(ptr, M_TEMP);
		return (error);
	}

	case USB_DEVICEINFO:
	{
		usbd_device_handle dev;
		struct usb_device_info *di = (void *)data;
		int addr = di->udi_addr;

		if (addr < 0 || addr >= USB_MAX_DEVICES)
			return (EINVAL);
		if ((dev = sc->sc_bus->devices[addr]) == NULL)
			return ENXIO;
		usbd_fill_deviceinfo(dev, di, 1);
		break;
	}

	case USB_DEVICESTATS:
		*(struct usb_device_stats *)data = sc->sc_bus->stats;
		break;

	default:
		return (EINVAL);
	}
	return (0);
}

#ifndef __riscos
int
usbpoll(dev_t dev, int events, usb_proc_ptr p)
{
	int revents, mask, s;

	if (minor(dev) == USB_DEV_MINOR) {
		revents = 0;
		mask = POLLIN | POLLRDNORM;

		s = splusb();
		if (events & mask && usb_nevents > 0)
			revents |= events & mask;
		if (revents == 0 && events & mask)
			selrecord(p, &usb_selevent);
		splx(s);

		return (revents);
	} else {
		return (ENXIO);
	}
}

static void
filt_usbrdetach(struct knote *kn)
{
	int s;

	s = splusb();
	SLIST_REMOVE(&usb_selevent.sel_klist, kn, knote, kn_selnext);
	splx(s);
}

static int
filt_usbread(struct knote *kn, long hint)
{

	if (usb_nevents == 0)
		return (0);

	kn->kn_data = sizeof(struct usb_event);
	return (1);
}

static const struct filterops usbread_filtops =
	{ 1, NULL, filt_usbrdetach, filt_usbread };

int
usbkqfilter(dev_t dev, struct knote *kn)
{
	struct klist *klist;
	int s;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		if (minor(dev) != USB_DEV_MINOR)
			return (1);
		klist = &usb_selevent.sel_klist;
		kn->kn_fop = &usbread_filtops;
		break;

	default:
		return (1);
	}

	kn->kn_hook = NULL;

	s = splusb();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}
#endif

/* Explore device tree from the root. */
Static void
usb_discover(void *v)
{
	struct usb_softc *sc = v;

	DPRINTFN(2,("usb_discover %p\n",v));
#ifdef USB_DEBUG
	if (usb_noexplore > 1)
		return;
#endif
	/*
	 * We need mutual exclusion while traversing the device tree,
	 * but this is guaranteed since this function is only called
	 * from the event thread for the controller.
	 */
	while (sc->sc_bus->needs_explore && !sc->sc_dying) {
		sc->sc_bus->needs_explore = 0;
#ifdef __riscos
        /* this can, in riscos, be called during root hub initialisation
         *  so we must ensure it has a valid root hub pointer before using it
        */ 
                if(sc->sc_bus->root_hub)  // ensure root hub is initialised
#endif
                  sc->sc_bus->root_hub->hub->explore(sc->sc_bus->root_hub);
	}
	DPRINTFN(2,("usb_discover-done %p\n",v));
}

void
usb_needs_explore(usbd_device_handle dev)
{
	DPRINTFN(2,("usb_needs_explore\n"));
	dev->bus->needs_explore = 1;
#if defined(__riscos)
        usb_needs_explore_callback(dev->bus);
#else
	wakeup(&dev->bus->needs_explore);
#endif
}

void
usb_needs_reattach(usbd_device_handle dev)
{
        DPRINTFN(2,("usb_needs_reattach\n"));
        dev->powersrc->reattach = 1;
        dev->bus->needs_explore = 1;
        wakeup(&dev->bus->needs_explore);
}

#ifndef __riscos
/* Called at splusb() */
int
usb_get_next_event(struct usb_event *ue)
{
	struct usb_event_q *ueq;

	if (usb_nevents <= 0)
		return (0);
	ueq = SIMPLEQ_FIRST(&usb_events);
#ifdef DIAGNOSTIC
	if (ueq == NULL) {
                printf("usb: usb_nevents got out of sync! %d\n", usb_nevents);
		usb_nevents = 0;
		return (0);
	}
#endif
	*ue = ueq->ue;
	SIMPLEQ_REMOVE_HEAD(&usb_events, next);
	free(ueq, M_USBDEV);
	usb_nevents--;
	return (1);
}

void
usbd_add_dev_event(int type, usbd_device_handle udev)
{
	struct usb_event ue;

	usbd_fill_deviceinfo(udev, &ue.u.ue_device, USB_EVENT_IS_ATTACH(type));
	usb_add_event(type, &ue);
}

void
usbd_add_drv_event(int type, usbd_device_handle udev, device_ptr_t dev)
{
	struct usb_event ue;

	ue.u.ue_driver.ue_cookie = udev->cookie;
	strncpy(ue.u.ue_driver.ue_devname, USBDEVPTRNAME(dev),
	    sizeof ue.u.ue_driver.ue_devname);
	usb_add_event(type, &ue);
}

Static void
usb_add_event(int type, struct usb_event *uep)
{
	struct usb_event_q *ueq;
	struct usb_event ue;
	struct timeval thetime;
	int s;

	microtime(&thetime);
	/* Don't want to wait here inside splusb() */
	ueq = malloc(sizeof *ueq, M_USBDEV, M_WAITOK);
	ueq->ue = *uep;
	ueq->ue.ue_type = type;
	TIMEVAL_TO_TIMESPEC(&thetime, &ueq->ue.ue_time);

	s = splusb();
	if (++usb_nevents >= USB_MAX_EVENTS) {
		/* Too many queued events, drop an old one. */
		DPRINTFN(-1,("usb: event dropped\n"));
		(void)usb_get_next_event(&ue);
	}
	SIMPLEQ_INSERT_TAIL(&usb_events, ueq, next);
	wakeup(&usb_events);
#ifndef __riscos
	selnotify(&usb_selevent, 0);
#endif
	if (usb_async_proc != NULL)
		psignal(usb_async_proc, SIGIO);
	splx(s);
}
#else
/* The event stuff has never done anything (useful) under RISC OS */
void
usbd_add_dev_event(int type, usbd_device_handle udev)
{
}

void
usbd_add_drv_event(int type, usbd_device_handle udev, device_ptr_t dev)
{
}

void
usb_add_event(int type, struct usb_event *uep)
{
}
#endif

void
usb_schedsoftintr(usbd_bus_handle bus)
{
	DPRINTFN(10,("usb_schedsoftintr: polling=%d\n", bus->use_polling));
#ifdef USB_USE_SOFTINTR
	if (bus->use_polling) {
		bus->methods->soft_intr(bus);
	} else {
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
		softintr_schedule(bus->soft);
#else
		if (!callout_pending(&bus->softi))
			callout_reset(&bus->softi, 0, bus->methods->soft_intr,
			    bus);
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
	}
#else
	bus->methods->soft_intr(bus);
#endif /* USB_USE_SOFTINTR */
}

int
usb_activate(device_ptr_t self, enum devact act)
{
	struct usb_softc *sc = (struct usb_softc *)self;
	usbd_device_handle dev = sc->sc_port.device;
	int i, rv = 0;

	switch (act) {
	case DVACT_ACTIVATE:
		return (EOPNOTSUPP);

	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		if (dev != NULL && dev->cdesc != NULL && dev->subdevs != NULL) {
			for (i = 0; dev->subdevs[i]; i++)
				rv |= config_deactivate(dev->subdevs[i]);
		}
		break;
	}
	return (rv);
}

int
usb_detach(device_ptr_t self, int flags)
{
	struct usb_softc *sc = (struct usb_softc *)self;
	struct usb_event ue;

	DPRINTF(("usb_detach: start\n"));

	sc->sc_dying = 1;

	/* Make all devices disconnect. */
	if (sc->sc_port.device != NULL)
		usb_disconnect_port(&sc->sc_port, self);

	/* Kill off event thread. */
	if (sc->sc_event_thread != NULL) {
		wakeup(&sc->sc_bus->needs_explore);
#ifdef __riscos
		if (tsleep(sc, PWAIT, "usbdet", hz * 60, 1))
#else
		if (tsleep(sc, PWAIT, "usbdet", hz * 60))
#endif
			printf("%s: event thread didn't die\n",
			       USBDEVNAME(sc->sc_dev));
		DPRINTF(("usb_detach: event thread dead\n"));
	}

	usbd_finish();

#ifdef USB_USE_SOFTINTR
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	if (sc->sc_bus->soft != NULL) {
		softintr_disestablish(sc->sc_bus->soft);
		sc->sc_bus->soft = NULL;
	}
#else
	callout_stop(&sc->sc_bus->softi);
#endif
#endif

	ue.u.ue_ctrlr.ue_bus = USBDEVUNIT(sc->sc_dev);
	usb_add_event(USB_EVENT_CTRLR_DETACH, &ue);

	return (0);
}

#ifdef USBHAL
struct usbd_bus *usb_getbus(device_ptr_t self)
{
	struct usb_softc *sc = (struct usb_softc *)self;
	return sc->sc_bus;
}
#endif
@


1.11
log
@Resolve porting mistake on initial bus registration
On first registering a new bus in the the NetBSD build of the code usb_kthread_create(usb_create_event_thread, sc) is called which in turn creates the main event thread ("usb_event_thread").
The first thing usb_event_thread() does is set
  sc->sc_bus->needs_explore = 1;
  usb_discover(sc);
however in the RISC OS version of the code (usb.c around line 254) only the first action is performed, no discover happens.
This change schedules a callback via usb_needs_explore_callback() which in turn calls discover_callback() when the OS is next free, which calls usb_discover() for each bus in an equivalent way to NetBSD's event thread. There's then no longer any need for the special one-shot 11s rediscover callback, only the repeating 30s rediscover is needed.

For reference, the places that set needs_explore in this version are all in usb.c
  Line 254: set, but doesn't schedule a callback, as noted above
  Line 339: code not compiled for __riscos
  Line 548: set, does schedule a callback
  Line 727: cleared, in usb_discover()
  Line 743: set, does schedule a callback
  Line 756: code not called in RISC OS

NetBSD uses 500ms initial delay before discover, then 60s between discovers (or until requested by a hub, whichever is sooner).
RISC OS has a periodic callback of 30s (in usbmodule.c) and an initial discover of however long it is from the bus being registered until callbacks next fire usb_event_thread(), assumed ~500ms.

Version 1.07. Tagged as 'NetBSD-1_07'
@
text
@d613 1
a615 1
		usbd_device_handle dev;
d617 1
a617 1
		if (addr < 1 || addr >= USB_MAX_DEVICES)
d619 2
a620 3
		dev = sc->sc_bus->devices[addr];
		if (dev == NULL)
			return (ENXIO);
@


1.10
log
@Add the ability to build the USB drivers as HAL-compatible static libraries
Detail:
  build/Makefile, build/OBJEHCIDriver, build/OBJOHCIDriver, build/OBJUSBDriver - Modified makefiles to build the HAL libs during the export libs phase
  build/!MkHAL,fd7 - Handy script for building the HAL libs
  build/Hdr/usbhal - Header containing definitions for the assembler code. Also gets exported so that HALs know how much workspace to reserve.
  build/c/usbhal - HAL version of usbmodule.c & port.c. Also contains the keyboard scan code, adapted from the code in the Tungsten HAL.
  build/s/porthal - Assembler versions of some port.c routines that were easier to do in assembler than C
  build/s/halheap - OS_Heap code that's been adapted for use in the HAL. Could easily be changed into a standalone library instead of being part of the HAL USB libs. Supports memory-efficient allocation of aligned blocks.
  build/c/ehcihal - HAL version of ehcimodule.c. Currently only supports EHCI controllers exposed via HAL_USBControllerInfo (i.e. no PCI support)
  build/c/ehcimodule, build/c/ohcimodule, build/c/port - Moved riscos_irq_clear into port.c. Removed unused microtime() function.
  build/c/usbmouse - Strip out some debug-related code in non-debug builds
  build/Version - Updated version numbers
  dev/usb/c/ehci, dev/usb/h/ehcivar - Adapted to add support for the HAL build. Apart from the base changes, the code has also been tweaked to significantly reduce the amount of memory used at runtime by the HAL version of the driver.
  dev/usb/c/hid, dev/usb/c/uhub, dev/usb/c/usb, dev/usb/c/usb_quirks, dev/usb/c/usb_subr, dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/c/usbroothub_subr - Changes to support HAL builds. Mainly disabling bits that won't work in the HAL or disabling bits for RISC OS in general if they weren't being used in the first place.
  dev/usb/c/ohci, dev/usb/h/ohcivar - Basic changes to support HAL builds. However HAL OHCI support is still incomplete.
  dev/usb/h/usb_port - Added support for the HAL build. Also tweaked logprintf definition to get rid of logprintf calls entirely in non-debug builds.
  dev/usb/h/usbdivar - Added support for the HAL build.
  dev/usb/h/usbhal - New header used by the HAL build. Gets included by every C file to ensure the compiler doesn't use sb, and contains structs/macros to allow access to the shared workspace.
Admin:
  HAL & non-HAL builds tested on rev C2 BB, rev A2 BB-xM, rev C1 TouchBook.
  Non-HAL builds tested with Iyonix ROM softload.
  Needs latest Kernel source for OSEntries.h export.


Version 0.59. Tagged as 'NetBSD-0_59'
@
text
@d252 1
a252 1
        /* set the explore flag here since threads don't do anything */
d254 1
d547 4
a550 5
        case USB_DISCOVER:
                sc->sc_bus->needs_explore = 1;
                usb_needs_explore_callback (sc->sc_bus);
//                usb_discover(sc);
                break;
d570 1
a570 1
		    sc->sc_bus->devices[addr] == 0)
@


1.9
log
@	Update of NetBSD elements (except c.ohci) to track NetBSD current
	from mid April 2005.
	Inclusion of Mods to c.ehci (from Dan) to correctly handle low
	speed interrupt devices beyond USB2 hubs (i.e. keyboards and mice).
	Mod to EHCI resetting in service call handler to better cope with
	USBDriver being restarted 'underneath' it.
Detail:
Admin:
	Castle, Dan Ellis, NetBSD added IP. Tested at Castle. Will be
	beta tested at this revision level before full release.


Version 0.39. Tagged as 'NetBSD-0_39'
@
text
@d46 3
d118 1
a120 1
#ifndef __riscos
d135 1
d152 1
d254 2
a256 1
	usb_kthread_create(usb_create_event_thread, sc);
d261 1
a261 1
#if defined(__NetBSD__) || defined(__OpenBSD__) || defined(__riscos)
d266 1
a266 3
#ifndef __riscos
        static int created = 0;
#endif
a273 1
#ifndef __riscos
a282 1
#endif
a347 1
#ifdef __riscos
a348 4
		    usb_noexplore ? 0 : hz * 60, 1);
#else

                (void)tsleep(&sc->sc_bus->needs_explore, PWAIT, "usbevt",
a349 5
#endif
#else
#ifdef __riscos
		(void)tsleep(&sc->sc_bus->needs_explore, PWAIT, "usbevt",
		    hz * 60, 1);
a353 1
#endif
a376 3
#ifdef __riscos
			tsleep(&usb_all_tasks, PWAIT, "usbtsk", 0, 1);
#else
a377 1
#endif
d400 14
a413 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d416 12
d498 1
d513 1
d518 1
d636 1
a658 1
#ifndef __riscos
d761 1
d835 17
d941 8
@


1.8
log
@        2 specific changes to USBDriver module
        Added (and fixed code underlying) to give periodic
        explore of USB busses (cf NetBSD).
        Added USBDisover command to let user provoke this too.
        Reworked USB device number allocation to roll
        around at 999 to avoid field overflow in
        a number of places.
Detail:
Admin:  castle added IP. to be beta tested on beta test site


Version 0.37. Tagged as 'NetBSD-0_37'
@
text
@d1 1
a1 1
/*      $NetBSD: usb.c,v 1.80 2003/11/07 17:03:25 wiz Exp $     */
d47 1
a47 1
//__KERNEL_RCSID(0, "$NetBSD: usb.c,v 1.80 2003/11/07 17:03:25 wiz Exp $");
d737 9
@


1.7
log
@        Stack brought up to date with NetBSD sources as at 20050121.
        USB2 further debugged.
Detail:
        Check in prior to second beta release. Improvements also to
        softloading of replacement modules.
Admin:
        Checked with JB .. further crosschecking is still needed for rhenium.
        Castle/D Ellis added ip from NetBSD sources


Version 0.33. Tagged as 'NetBSD-0_33'
@
text
@d333 1
a333 1
	usb_delay_ms(sc->sc_bus, 500);
d533 2
a534 1
                usb_discover(sc);
d702 1
a702 1
	DPRINTFN(2,("usb_discover\n"));
d722 1
@


1.6
log
@        Update of EHCIDriver to current NetBSD, together with needed changes
        in both OHCIDriver and USBDriver.


Detail:
        Code may change before formal release .. will be beta released
        ... Entered to CVS to get new version numbers, and for
        the record.
Admin:
        Castle/netbsd added IP .. will be tested more fully before
        formal release. Still to be verified on Rhenium.


Version 0.31. Tagged as 'NetBSD-0_31'
@
text
@d48 2
d88 2
d101 4
d179 1
a179 1
	logprintf(": USB revision %s", usbrev_str[usbrev]);
d189 1
a189 1
		logprintf(", not supported\n");
d193 1
a193 1
	logprintf("\n");
d208 1
a208 1
		logprintf("%s: can't register softintr\n", USBDEVNAME(sc->sc_dev));
d223 1
a223 1
			logprintf("%s: root device is not a hub\n",
d238 1
a238 1
		logprintf("%s: root hub problem, error=%d\n",
d266 1
a266 1
		logprintf("%s: unable to create event thread for\n",
d276 1
a276 1
			logprintf("unable to create task thread\n");
d746 1
a746 1
		logprintf("usb: usb_nevents got out of sync! %d\n", usb_nevents);
d874 1
a874 1
			logprintf("%s: event thread didn't die\n",
@


1.5
log
@  Extensive changes and bug fixes to usb and ohci ..
  'blocked' several holes that could cause freezes with awkward
  usb devices.  Added latest changes from Dan Ellis too , especially for USB2
Detail:
 many
Admin:
 Tested in ROM at Castle, and beta tested with users


Version 0.28. Tagged as 'NetBSD-0_28'
@
text
@d1 1
a1 1
/*	$NetBSD: usb.c,v 1.75 2002/11/26 18:49:49 christos Exp $	*/
d42 2
a43 2
 * http://www.usb.org/developers/data/ and
 * http://www.usb.org/developers/index.html .
d47 1
a47 1
__KERNEL_RCSID(0, "$NetBSD: usb.c,v 1.75 2002/11/26 18:49:49 christos Exp $");
d252 3
a254 1
	static int created = 0;
d522 1
d527 1
d703 3
a708 2
	while (sc->sc_bus->needs_explore && !sc->sc_dying) {
		sc->sc_bus->needs_explore = 0;
d710 1
@


1.4
log
@  New versions from John.
Detail:
  * All modules will now rmkill/rmload more reliably
  * Keyboard driver disables kernel debounce on new enough kernels, needed
    for many PS2-USB adaptors, bar code scanners etc
  * Mouse driver will scroll wheel scroll any windows that do respond to
    scroll events, otherwise it issues PointerReason_WheelChange (9) to an
    external WimpScroll module
  * Several bugs and an interrupt hole resolved
Admin:
  Tested at Framlingham.

Version 0.25. Tagged as 'NetBSD-0_25'
@
text
@d521 1
d699 3
d704 2
a705 1
		sc->sc_bus->root_hub->hub->explore(sc->sc_bus->root_hub);
@


1.3
log
@Merge of Dan Ellis's USB2 sources.

Version 0.22. Tagged as 'NetBSD-0_22'
@
text
@d520 3
@


1.2
log
@  Changes to work with TCPIPLibs 5.47.
Detail:
  NetBSD/FreeBSD differences in the naming of certain macros are now resolved
  in TCPIPLibs instead of locally. Also some reordering in the !Mk files in
  order to work with current versions of Zap.
Admin:
  Builds against TCPIPLibs 5.47. Note that this version of the USB sources
  also now requires TCPIPLibs 5.47.

Version 0.21. Tagged as 'NetBSD-0_21'
@
text
@d1 1
a1 2
/*	$NetBSD: usb.c,v 1.46 2000/06/07 00:33:51 thorpej Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usb.c,v 1.20 1999/11/17 22:33:46 n_hibma Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
d46 3
a52 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d54 1
d56 1
a57 8
#elif defined(__FreeBSD__)
#include <sys/module.h>
#include <sys/bus.h>
#include <sys/filio.h>
#include <sys/uio.h>
#elif defined(__riscos)
#include <sys/proc.h>
#endif
d59 1
a61 3
#if defined(__riscos)
#include <sys/uio.h>
#endif
a70 8
#if defined(__FreeBSD__)
MALLOC_DEFINE(M_USB, "USB", "USB");
MALLOC_DEFINE(M_USBDEV, "USBdev", "USB device");
MALLOC_DEFINE(M_USBHC, "USBHC", "USB host controller");

#include "usb_if.h"
#endif /* defined(__FreeBSD__) */

d102 1
a102 6
#if defined(__FreeBSD__)
	/* This part should be deleted when kthreads is available */
	struct selinfo	sc_consel;	/* waiting for connect change */
#else
	struct proc    *sc_event_thread;
#endif
d107 13
a119 24
#if defined(__NetBSD__) || defined(__OpenBSD__)
cdev_decl(usb);
#elif defined(__FreeBSD__)
d_open_t  usbopen;
d_close_t usbclose;
d_read_t usbread;
d_ioctl_t usbioctl;
int usbpoll(dev_t, int, struct proc *);

struct cdevsw usb_cdevsw = {
	/* open */      usbopen,
	/* close */     usbclose,
	/* read */      noread,
	/* write */     nowrite,
	/* ioctl */     usbioctl,
	/* poll */      usbpoll,
	/* mmap */      nommap,
	/* strategy */  nostrategy,
	/* name */      "usb",
	/* maj */       USB_CDEV_MAJOR,
	/* dump */      nodump,
	/* psize */     nopsize,
	/* flags */     0,
	/* bmaj */      -1
d123 1
a123 1
Static usbd_status usb_discover(struct usb_softc *);
d126 2
d138 1
a138 1
Static struct proc *usb_async_proc;  /* process who wants USB SIGIO */
a143 5
#if defined(__NetBSD__) || defined(__OpenBSD__)
/* Flag to see if we are in the cold boot process. */
extern int cold;
#endif

a155 1
#if defined(__NetBSD__) || defined(__OpenBSD__) || defined(__riscos)
a156 4
#elif defined(__FreeBSD__)
	struct usb_softc *sc = device_get_softc(self);
	void *aux = device_get_ivars(self);
#endif
d160 1
a162 5
#if defined(__FreeBSD__)
	DPRINTF(("%s", USBDEVNAME(sc->sc_dev)));
	sc->sc_dev = self;
#endif

d171 12
a182 3
	DPRINTF((": USB revision %s", usbrev_str[usbrev]));
	if (usbrev != USBREV_1_0 && usbrev != USBREV_1_1) {
		DPRINTF((", not supported\n"));
d185 1
a185 1
	DPRINTF(("\n"));
d194 16
a209 1
	err = usbd_new_device(USBDEV(sc->sc_dev), sc->sc_bus, 0, 0, 0,
d220 1
a220 1
#if 0
a240 1
//	usb_needs_explore_callback (sc->sc_bus);
a243 5
#if defined(__FreeBSD__)
	make_dev(&usb_cdevsw, device_get_unit(self), UID_ROOT, GID_OPERATOR,
		 0644, "usb%d", device_get_unit(self));
#endif

d252 1
d260 46
a311 1
	int first = 1;
d315 10
d327 2
a334 4
		if (first) {
			config_pending_decr();
			first = 0;
		}
d355 1
a355 1
	sc->sc_event_thread = 0;
d364 30
d399 1
a399 1
		DPRINTF(("usb at %s", pnp));
d406 1
a406 1
usbopen(dev_t dev, int flag, int mode, struct proc *p)
d465 1
a465 1
usbclose(dev_t dev, int flag, int mode, struct proc *p)
d478 1
a478 1
usbioctl(dev_t devt, u_long cmd, caddr_t data, int flag, struct proc *p)
a506 7
#if defined(__FreeBSD__) || defined(__riscos)
	/* This part should be deleted when kthreads is available */
  	case USB_DISCOVER:
		sc->sc_bus->needs_explore = 1;
  		usb_discover(sc);
  		break;
#endif
d509 2
d519 1
a519 1
#endif
d523 1
a523 1
		int len = UGETW(ur->request.wLength);
d527 1
a527 1
		int addr = ur->addr;
d531 3
d541 1
a541 1
			iov.iov_base = (caddr_t)ur->data;
d549 1
a549 1
				ur->request.bmRequestType & UT_READ ?
d560 2
a561 1
			  &ur->request, ptr, ur->flags, &ur->actlen);
d582 1
a582 1
		int addr = di->addr;
d590 1
a590 1
		usbd_fill_deviceinfo(dev, di);
d605 1
a605 1
usbpoll(dev_t dev, int events, struct proc *p)
d622 3
a624 4
#if defined(__FreeBSD__)
		/* This part should be deleted when kthreads is available */
		struct usb_softc *sc;
		int unit = minor(dev);
d626 5
a630 1
		USB_GET_SC(usb, unit, sc);
d632 24
a655 2
		revents = 0;
		mask = POLLOUT | POLLRDNORM;
d657 7
a663 6
		s = splusb();
		if (events & mask && sc->sc_bus->needs_explore)
			revents |= events & mask;
		if (revents == 0 && events & mask)
			selrecord(p, &sc->sc_consel);
		splx(s);
d665 2
a666 4
		return (revents);
#else
		return (ENXIO);
#endif
d668 8
d677 1
d680 2
a681 2
usbd_status
usb_discover(struct usb_softc *sc)
d683 6
a688 3
#if defined(__FreeBSD__)
	/* The splxxx parts should be deleted when kthreads is available */
	int s;
a689 1

d695 1
a695 5
#if defined(__FreeBSD__)
	s = splusb();
#endif
	while (sc->sc_bus->needs_explore && !sc->sc_dying &&
	        sc->sc_bus->root_hub != NULL) {
a696 3
#if defined(__FreeBSD__)
		splx(s);
#endif
a697 3
#if defined(__FreeBSD__)
		s = splusb();
#endif
a698 5
#if defined(__FreeBSD__)
	splx(s);
#endif

	return (USBD_NORMAL_COMPLETION);
d702 1
a702 1
usb_needs_explore(usbd_bus_handle bus)
d704 2
a705 1
	bus->needs_explore = 1;
d707 1
a707 1
        usb_needs_explore_callback(bus);
d709 1
a709 5
#if defined(__FreeBSD__)
	/* This part should be deleted when kthreads is available */
	selwakeup(&bus->usbctl->sc_consel);
#endif
	wakeup(&bus->needs_explore);
d722 7
a738 1
#ifndef __riscos
d741 1
a741 1
	usbd_fill_deviceinfo(udev, &ue.u.ue_device);
a742 1
#endif
a747 1
#ifndef __riscos
a753 1
#endif
d779 3
a781 1
	selwakeup(&usb_selevent);
d786 1
d788 1
a788 1
usb_schedsoftintr(struct usbd_bus *bus)
d790 14
d805 1
a807 1
#if defined(__NetBSD__) || defined(__OpenBSD__) || defined(__riscos)
a817 1
		break;
d821 1
a821 1
		if (dev && dev->cdesc && dev->subdevs) {
d841 1
a841 1
	if (sc->sc_port.device)
d845 1
a845 1
	if (sc->sc_event_thread) {
d859 11
a874 15
#elif defined(__FreeBSD__)
int
usb_detach(device_t self)
{
	DPRINTF(("%s: unload, prevented\n", USBDEVNAME(self)));

	return (EINVAL);
}
#endif


#if defined(__FreeBSD__)
DRIVER_MODULE(usb, ohci, usb_driver, usb_devclass, 0, 0);
DRIVER_MODULE(usb, uhci, usb_driver, usb_devclass, 0, 0);
#endif
@


1.1
log
@Import of USB driver suitable for generic PCI based OHCI controllers.
Correction of spelling of busses to buses (noun plural).
OHCIdriver only responds to PCI service call to lookup vendor name when
the device is of class OHCI controller.

Version 0.01. Tagged as 'NetBSD-0_01'
@
text
@d648 1
a648 1
	SIMPLEQ_REMOVE_HEAD(&usb_events, ueq, next);
@


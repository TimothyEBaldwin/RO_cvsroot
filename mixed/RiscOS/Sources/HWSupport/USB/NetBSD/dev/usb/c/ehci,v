head	1.20;
access;
symbols
	NetBSD-1_19:1.20
	NetBSD-1_18:1.20
	NetBSD-1_17:1.20
	NetBSD-1_16:1.20
	NetBSD-1_15:1.20
	NetBSD-1_14:1.20
	NetBSD-1_13:1.20
	NetBSD-1_12:1.20
	NetBSD-1_09-1:1.20
	NetBSD-1_11:1.19
	NetBSD-1_10:1.19
	NetBSD-1_09:1.18
	NetBSD-1_08:1.18
	NetBSD-1_07:1.17
	NetBSD-1_06:1.17
	NetBSD-1_05:1.17
	NetBSD-1_04:1.17
	NetBSD-1_03:1.17
	NetBSD-1_02:1.17
	NetBSD-1_01:1.17
	NetBSD-1_00:1.17
	NetBSD-0_99:1.17
	NetBSD-0_98:1.17
	NetBSD-0_97:1.17
	NetBSD-0_96:1.17
	NetBSD-0_95:1.17
	NetBSD-0_94:1.17
	NetBSD-0_93:1.17
	NetBSD-0_92:1.17
	NetBSD-0_91:1.17
	NetBSD-0_90:1.17
	NetBSD-0_89:1.17
	NetBSD-0_88:1.17
	NetBSD-0_87:1.16
	NetBSD-0_86:1.16
	NetBSD-0_85:1.16
	NetBSD-0_84:1.16
	NetBSD-0_83:1.16
	NetBSD-0_82:1.16
	NetBSD-0_81:1.16
	NetBSD-0_80:1.16
	NetBSD-0_79:1.16
	NetBSD-0_78:1.16
	NetBSD-0_77:1.16
	NetBSD-0_76:1.16
	NetBSD-0_75:1.16
	NetBSD-0_74:1.16
	NetBSD-0_73:1.16
	NetBSD-0_72:1.16
	NetBSD-0_71:1.16
	NetBSD-0_70:1.16
	NetBSD-0_69:1.16
	NetBSD-0_68:1.16
	NetBSD-0_67:1.16
	NetBSD-0_66:1.16
	NetBSD-0_65:1.16
	NetBSD-0_64:1.15
	NetBSD-0_63:1.15
	NetBSD-0_62:1.14
	NetBSD-0_61:1.13
	NetBSD-0_60:1.13
	NetBSD-0_59:1.13
	NetBSD-0_58:1.12
	NetBSD-0_57:1.12
	NetBSD-0_56:1.12
	NetBSD-0_55:1.12
	NetBSD-0_54:1.12
	NetBSD-0_53:1.12
	NetBSD-0_52:1.12
	NetBSD-0_51:1.11
	NetBSD-0_50:1.11
	NetBSD-0_49:1.11
	NetBSD-0_48:1.11
	NetBSD-0_47:1.11
	NetBSD-0_46:1.10
	NetBSD-0_45:1.10
	NetBSD-0_44:1.10
	NetBSD-0_43:1.10
	NetBSD-0_42:1.10
	NetBSD-0_41:1.10
	NetBSD-0_40:1.10
	NetBSD-0_39:1.10
	NetBSD-0_38:1.9
	NetBSD-0_37:1.9
	NetBSD-0_36:1.9
	NetBSD-0_35:1.9
	NetBSD-0_34:1.8
	NetBSD-0_33:1.7
	NetBSD-0_32:1.6
	NetBSD-0_31:1.5
	NetBSD-0_30:1.4
	NetBSD-0_29:1.4
	RO_5_07:1.4
	NetBSD-0_28:1.4
	NetBSD-0_27:1.3
	NetBSD-0_26:1.3
	NetBSD-0_25:1.2
	NetBSD-0_24:1.1
	NetBSD-0_23:1.1
	NetBSD-0_22:1.1;
locks; strict;
comment	@# @;


1.20
date	2016.03.04.20.54.42;	author rool;	state Exp;
branches;
next	1.19;
commitid	MvG9A9da0K4NQmXy;

1.19
date	2016.03.04.01.30.11;	author jballance;	state Exp;
branches;
next	1.18;
commitid	NFICmxi3aahBqgXy;

1.18
date	2015.11.15.09.50.45;	author rool;	state Exp;
branches;
next	1.17;
commitid	TgSd07Pyi9PAJaJy;

1.17
date	2014.08.29.19.26.19;	author jlee;	state Exp;
branches;
next	1.16;
commitid	f6ArfsGGibMS9iOx;

1.16
date	2011.12.18.18.13.58;	author jlee;	state Exp;
branches;
next	1.15;
commitid	FTilKIPWIS83qHLv;

1.15
date	2011.12.04.19.22.44;	author jlee;	state Exp;
branches;
next	1.14;
commitid	zwyAy3p02v2AfUJv;

1.14
date	2011.08.22.22.38.20;	author jlee;	state Exp;
branches;
next	1.13;
commitid	DX6w1a2oIxQTFywv;

1.13
date	2011.05.22.20.22.41;	author jlee;	state Exp;
branches;
next	1.12;
commitid	Ye1jVWDlKivFSIkv;

1.12
date	2010.07.21.23.57.19;	author jlee;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.09.19.32.47;	author jlee;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.24.23.13.53;	author jballance;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.18.00.35.56;	author jballance;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.31.13.45.35;	author jballance;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.21.22.30.19;	author jballance;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.03.01.50.02;	author jballance;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.30.02.34.20;	author jballance;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.12.14.47.40;	author jballance;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.30.14.50.36;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.06.15.50.22;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.21.20.49.19;	author bavison;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Revert accidental commits
Admin:
  These changes are currently subject to rework via the normal submissions channel.
@
text
@/*	$NetBSD: ehci.c,v 1.169 2010/07/07 03:55:01 msaitoh Exp $ */

/*
 * Copyright (c) 2004-2008 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net), Charles M. Hannum and
 * Jeremy Morse (jeremy.morse@@gmail.com).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * USB Enhanced Host Controller Driver, a.k.a. USB 2.0 controller.
 *
 * The EHCI 1.0 spec can be found at
 * http://www.intel.com/technology/usb/spec.htm
 * and the USB 2.0 spec at
 * http://www.usb.org/developers/docs/
 *
 */

/*
 * TODO:
 * 1) hold off explorations by companion controllers until ehci has started.
 *
 * 2) The hub driver needs to handle and schedule the transaction translator,
 *    to assign place in frame where different devices get to go. See chapter
 *    on hubs in USB 2.0 for details.
 *
 * 3) Command failures are not recovered correctly.
 */

#ifdef __riscos
#include <dev/usb/usbhal.h>
#endif
#include <sys/cdefs.h>
//__KERNEL_RCSID(0, "$NetBSD: ehci.c,v 1.91 2005/02/27 00:27:51 perry Exp $");

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/select.h>
#include <sys/proc.h>
#include <sys/queue.h>
#ifndef __riscos
#include <sys/mutex.h>
#include <sys/bus.h>
#else
#include <machine/bus.h>
#endif

#include <machine/endian.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usb_mem.h>
#include <dev/usb/usb_quirks.h>

#include <dev/usb/ehcireg.h>
#include <dev/usb/ehcivar.h>
#include <dev/usb/usbroothub_subr.h>

#ifdef __riscos
#define printf logprintf
#define aprint_verbose logprintf
#define aprint_normal logprintf
#define __BITS(HI,LO) ((1<<((HI)+1))-(1<<(LO)))
#define __SHIFTOUT(VAL, MASK) (((VAL) & (MASK))/((MASK) & ~((MASK)<<1)))
#endif

#ifdef EHCI_DEBUG
#define DPRINTF(x)	do { if (ehcidebug) printf x; } while(0)
#define DPRINTFN(n,x)	do { if (ehcidebug>(n)) printf x; } while (0)
int ehcidebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

struct ehci_pipe {
	struct usbd_pipe pipe;
	int nexttoggle;

	ehci_soft_qh_t *sqh;
	union {
		ehci_soft_qtd_t *qtd;
		/* ehci_soft_itd_t *itd; */
	} tail;
	union {
		/* Control pipe */
		struct {
			usb_dma_t reqdma;
			u_int length;
		} ctl;
		/* Interrupt pipe */
		struct {
			u_int length;
		} intr;
		/* Bulk pipe */
		struct {
			u_int length;
		} bulk;
		/* Iso pipe */
		struct {
			u_int next_frame;
			u_int cur_xfers;
		} isoc;
	} u;
};

Static usbd_status	ehci_open(usbd_pipe_handle);
Static void		ehci_poll(struct usbd_bus *);
Static void		ehci_softintr(void *);
Static int		ehci_intr1(ehci_softc_t *);
Static void		ehci_waitintr(ehci_softc_t *, usbd_xfer_handle);
Static void		ehci_check_intr(ehci_softc_t *, struct ehci_xfer *);
Static void		ehci_check_qh_intr(ehci_softc_t *, struct ehci_xfer *);
Static void		ehci_check_itd_intr(ehci_softc_t *, struct ehci_xfer *);
Static void		ehci_idone(struct ehci_xfer *);
Static void		ehci_timeout(void *);
Static void		ehci_timeout_task(void *);
Static void		ehci_intrlist_timeout(void *);

Static usbd_status	ehci_allocm(struct usbd_bus *, usb_dma_t *, u_int32_t);
Static void		ehci_freem(struct usbd_bus *, usb_dma_t *);

Static usbd_xfer_handle	ehci_allocx(struct usbd_bus *);
Static void		ehci_freex(struct usbd_bus *, usbd_xfer_handle);

Static usbd_status	ehci_root_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	ehci_root_ctrl_start(usbd_xfer_handle);
Static void		ehci_root_ctrl_abort(usbd_xfer_handle);
Static void		ehci_root_ctrl_close(usbd_pipe_handle);
Static void		ehci_root_ctrl_done(usbd_xfer_handle);

Static usbd_status	ehci_root_intr_transfer(usbd_xfer_handle);
Static usbd_status	ehci_root_intr_start(usbd_xfer_handle);
Static void		ehci_root_intr_abort(usbd_xfer_handle);
Static void		ehci_root_intr_close(usbd_pipe_handle);
Static void		ehci_root_intr_done(usbd_xfer_handle);

Static usbd_status	ehci_device_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	ehci_device_ctrl_start(usbd_xfer_handle);
Static void		ehci_device_ctrl_abort(usbd_xfer_handle);
Static void		ehci_device_ctrl_close(usbd_pipe_handle);
Static void		ehci_device_ctrl_done(usbd_xfer_handle);

Static usbd_status	ehci_device_bulk_transfer(usbd_xfer_handle);
Static usbd_status	ehci_device_bulk_start(usbd_xfer_handle);
Static void		ehci_device_bulk_abort(usbd_xfer_handle);
Static void		ehci_device_bulk_close(usbd_pipe_handle);
Static void		ehci_device_bulk_done(usbd_xfer_handle);

Static usbd_status	ehci_device_intr_transfer(usbd_xfer_handle);
Static usbd_status	ehci_device_intr_start(usbd_xfer_handle);
Static void		ehci_device_intr_abort(usbd_xfer_handle);
Static void		ehci_device_intr_close(usbd_pipe_handle);
Static void		ehci_device_intr_done(usbd_xfer_handle);

Static usbd_status	ehci_device_isoc_transfer(usbd_xfer_handle);
Static usbd_status	ehci_device_isoc_start(usbd_xfer_handle);
Static void		ehci_device_isoc_abort(usbd_xfer_handle);
Static void		ehci_device_isoc_close(usbd_pipe_handle);
Static void		ehci_device_isoc_done(usbd_xfer_handle);

Static void		ehci_device_clear_toggle(usbd_pipe_handle pipe);
Static void		ehci_noop(usbd_pipe_handle pipe);

Static void		ehci_pcd(ehci_softc_t *, usbd_xfer_handle);
Static void		ehci_disown(ehci_softc_t *, int, int);

Static ehci_soft_qh_t  *ehci_alloc_sqh(ehci_softc_t *);
Static void		ehci_free_sqh(ehci_softc_t *, ehci_soft_qh_t *);

Static ehci_soft_qtd_t  *ehci_alloc_sqtd(ehci_softc_t *);
Static void		ehci_free_sqtd(ehci_softc_t *, ehci_soft_qtd_t *);
Static usbd_status	ehci_alloc_sqtd_chain(struct ehci_pipe *,
			    ehci_softc_t *, int, int, usbd_xfer_handle,
			    ehci_soft_qtd_t **, ehci_soft_qtd_t **);
Static void		ehci_free_sqtd_chain(ehci_softc_t *, ehci_soft_qtd_t *,
					    ehci_soft_qtd_t *);

Static ehci_soft_itd_t	*ehci_alloc_itd(ehci_softc_t *sc);
Static void		ehci_free_itd(ehci_softc_t *sc, ehci_soft_itd_t *itd);
Static void 		ehci_rem_free_itd_chain(ehci_softc_t *sc,
						struct ehci_xfer *exfer);
Static void 		ehci_abort_isoc_xfer(usbd_xfer_handle xfer,
						usbd_status status);

Static usbd_status	ehci_device_request(usbd_xfer_handle xfer);

Static usbd_status	ehci_device_setintr(ehci_softc_t *, ehci_soft_qh_t *,
			    int ival);

Static void		ehci_add_qh(ehci_soft_qh_t *, ehci_soft_qh_t *);
Static void		ehci_rem_qh(ehci_softc_t *, ehci_soft_qh_t *,
				    ehci_soft_qh_t *);
Static void		ehci_set_qh_qtd(ehci_soft_qh_t *, ehci_soft_qtd_t *);
Static void		ehci_sync_hc(ehci_softc_t *);

Static void		ehci_close_pipe(usbd_pipe_handle, ehci_soft_qh_t *);
Static void		ehci_abort_xfer(usbd_xfer_handle, usbd_status);

#ifdef EHCI_DEBUG
Static void		ehci_dump_regs(ehci_softc_t *);
void			ehci_dump(void);
Static ehci_softc_t 	*theehci;
Static void		ehci_dump_link(ehci_link_t, int);
Static void		ehci_dump_sqtds(ehci_soft_qtd_t *);
Static void		ehci_dump_sqtd(ehci_soft_qtd_t *);
Static void		ehci_dump_qtd(ehci_qtd_t *);
Static void		ehci_dump_sqh(ehci_soft_qh_t *);
#if notyet
Static void		ehci_dump_sitd(struct ehci_soft_itd *itd);
Static void		ehci_dump_itd(struct ehci_soft_itd *);
#endif
#ifdef DIAGNOSTIC
Static void		ehci_dump_exfer(struct ehci_xfer *);
#endif
#endif

#define EHCI_NULL htole32(EHCI_LINK_TERMINATE)

#define EHCI_INTR_ENDPT 1

#define ehci_add_intr_list(sc, ex) \
	TAILQ_INSERT_TAIL(&(sc)->sc_intrhead, (ex), inext);
#define ehci_del_intr_list(sc, ex) \
	do { \
		TAILQ_REMOVE(&sc->sc_intrhead, (ex), inext); \
		(ex)->inext.tqe_prev = NULL; \
	} while (0)
#define ehci_active_intr_list(ex) ((ex)->inext.tqe_prev != NULL)

#ifdef USBHAL
extern int usbhal_ehci_do_intr(struct usbd_bus *,int irqdevno);
extern void usbhal_ehci_shutdown(struct usbd_bus *);
#endif

Static struct usbd_bus_methods ehci_bus_methods = {
	ehci_open,
	ehci_softintr,
	ehci_poll,
	ehci_allocm,
	ehci_freem,
	ehci_allocx,
	ehci_freex,
	NULL, NULL, NULL, NULL, /* 4x unused HC overrides */
#ifdef USBHAL
	usbhal_ehci_do_intr,
	usbhal_ehci_shutdown,
#endif
};

Static struct usbd_pipe_methods ehci_root_ctrl_methods = {
	ehci_root_ctrl_transfer,
	ehci_root_ctrl_start,
	ehci_root_ctrl_abort,
	ehci_root_ctrl_close,
	ehci_noop,
	ehci_root_ctrl_done,
};

Static struct usbd_pipe_methods ehci_root_intr_methods = {
	ehci_root_intr_transfer,
	ehci_root_intr_start,
	ehci_root_intr_abort,
	ehci_root_intr_close,
	ehci_noop,
	ehci_root_intr_done,
};

Static struct usbd_pipe_methods ehci_device_ctrl_methods = {
	ehci_device_ctrl_transfer,
	ehci_device_ctrl_start,
	ehci_device_ctrl_abort,
	ehci_device_ctrl_close,
	ehci_noop,
	ehci_device_ctrl_done,
};

Static struct usbd_pipe_methods ehci_device_intr_methods = {
	ehci_device_intr_transfer,
	ehci_device_intr_start,
	ehci_device_intr_abort,
	ehci_device_intr_close,
	ehci_device_clear_toggle,
	ehci_device_intr_done,
};

Static struct usbd_pipe_methods ehci_device_bulk_methods = {
	ehci_device_bulk_transfer,
	ehci_device_bulk_start,
	ehci_device_bulk_abort,
	ehci_device_bulk_close,
	ehci_device_clear_toggle,
	ehci_device_bulk_done,
};

Static struct usbd_pipe_methods ehci_device_isoc_methods = {
	ehci_device_isoc_transfer,
	ehci_device_isoc_start,
	ehci_device_isoc_abort,
	ehci_device_isoc_close,
	ehci_noop,
	ehci_device_isoc_done,
};

#ifdef USBHAL
static const uint8_t revbits[EHCI_MAX_POLLRATE] = {0x00,0x02,0x01,0x03};
#else
static const uint8_t revbits[EHCI_MAX_POLLRATE] = {
0x00,0x40,0x20,0x60,0x10,0x50,0x30,0x70,0x08,0x48,0x28,0x68,0x18,0x58,0x38,0x78,
0x04,0x44,0x24,0x64,0x14,0x54,0x34,0x74,0x0c,0x4c,0x2c,0x6c,0x1c,0x5c,0x3c,0x7c,
0x02,0x42,0x22,0x62,0x12,0x52,0x32,0x72,0x0a,0x4a,0x2a,0x6a,0x1a,0x5a,0x3a,0x7a,
0x06,0x46,0x26,0x66,0x16,0x56,0x36,0x76,0x0e,0x4e,0x2e,0x6e,0x1e,0x5e,0x3e,0x7e,
0x01,0x41,0x21,0x61,0x11,0x51,0x31,0x71,0x09,0x49,0x29,0x69,0x19,0x59,0x39,0x79,
0x05,0x45,0x25,0x65,0x15,0x55,0x35,0x75,0x0d,0x4d,0x2d,0x6d,0x1d,0x5d,0x3d,0x7d,
0x03,0x43,0x23,0x63,0x13,0x53,0x33,0x73,0x0b,0x4b,0x2b,0x6b,0x1b,0x5b,0x3b,0x7b,
0x07,0x47,0x27,0x67,0x17,0x57,0x37,0x77,0x0f,0x4f,0x2f,0x6f,0x1f,0x5f,0x3f,0x7f,
};
#endif

#ifdef USBHAL
/* TODO - Move elsewhere */
static void abort_pipe(void *v)
{
	splbio(); /* Code in cmodule runs with interrupts enabled(!) */
	ehci_abort_xfer((usbd_xfer_handle) v,USBD_TIMEOUT);
}

static void riscos_abort_pipe(void *v)
{
	USBHAL_AddCallback(abort_pipe,v);
}
#endif

#if defined (__riscos) && !defined(USBHAL)
static int veneers_built = 0;
void build_veneer (void* vn, void* st, size_t sz);
static struct {
    struct usbd_bus_methods methods;
    struct {
        int load;
        int branch;
    } veneer[sizeof (struct usbd_bus_methods) / sizeof (void*)];
} ehci_bus_methods_entry;

static struct {
    struct usbd_pipe_methods methods;
    struct {
        int load;
        int branch;
    } veneer[sizeof (struct usbd_pipe_methods) / sizeof (void*)];
} ehci_root_ctrl_methods_entry,
  ehci_root_intr_methods_entry,
  ehci_device_ctrl_methods_entry,
  ehci_device_intr_methods_entry,
  ehci_device_bulk_methods_entry,
  ehci_device_isoc_methods_entry;
#endif

usbd_status
ehci_init(ehci_softc_t *sc)
{
	u_int32_t vers, sparams, cparams, hcr;
	u_int i;
	usbd_status err;
	ehci_soft_qh_t *sqh;
	u_int ncomp;

	DPRINTF(("ehci_init: start\n"));
#if defined (__riscos) && !defined(USBHAL)
        if (!veneers_built)
        {
            build_veneer(&ehci_bus_methods_entry,
                &ehci_bus_methods,
                sizeof ehci_bus_methods);
            build_veneer(&ehci_root_ctrl_methods_entry,
                &ehci_root_ctrl_methods,
                sizeof ehci_root_ctrl_methods);
            build_veneer(&ehci_root_intr_methods_entry,
                &ehci_root_intr_methods,
                sizeof ehci_root_intr_methods);
            build_veneer(&ehci_device_ctrl_methods_entry,
                &ehci_device_ctrl_methods,
                sizeof ehci_device_ctrl_methods);
            build_veneer(&ehci_device_intr_methods_entry,
                &ehci_device_intr_methods,
                sizeof ehci_device_intr_methods);
            build_veneer(&ehci_device_bulk_methods_entry,
                &ehci_device_bulk_methods,
                sizeof ehci_device_bulk_methods);
            build_veneer(&ehci_device_isoc_methods_entry,
                &ehci_device_isoc_methods,
                sizeof ehci_device_isoc_methods);
            veneers_built = 1;
        }
#endif
#ifdef EHCI_DEBUG
	theehci = sc;
#endif

	sc->sc_offs = EREAD1(sc, EHCI_CAPLENGTH);

	vers = EREAD2(sc, EHCI_HCIVERSION);
	aprint_verbose("%s: EHCI version %x.%x\n", USBDEVNAME(sc->sc_bus.bdev),
	       vers >> 8, vers & 0xff);

	sparams = EREAD4(sc, EHCI_HCSPARAMS);
	DPRINTF(("ehci_init: sparams=0x%x\n", sparams));
	sc->sc_npcomp = EHCI_HCS_N_PCC(sparams);
	ncomp = EHCI_HCS_N_CC(sparams);
	if (ncomp != sc->sc_ncomp) {
		aprint_verbose("%s: wrong number of companions (%d != %d)\n",
		       USBDEVNAME(sc->sc_bus.bdev), ncomp, sc->sc_ncomp);
#ifdef __riscos0
		return (USBD_IOERROR);
#endif
		if (ncomp < sc->sc_ncomp)
			sc->sc_ncomp = ncomp;
	}
	if (sc->sc_ncomp > 0) {
#ifndef __riscos
		KASSERT(!(sc->sc_flags & EHCIF_ETTF));
#endif
		aprint_normal("%s: companion controller%s, %d port%s each:",
		    USBDEVNAME(sc->sc_bus.bdev), sc->sc_ncomp!=1 ? "s" : "",
		    EHCI_HCS_N_PCC(sparams),
		    EHCI_HCS_N_PCC(sparams)!=1 ? "s" : "");
#ifndef __riscos
                /* we aren't filling in companions at the moment */
		for (i = 0; i < sc->sc_ncomp; i++)
			aprint_normal(" %s", USBDEVNAME(sc->sc_comps[i]->bdev));
#endif
		aprint_normal("\n");
	}
	sc->sc_noport = EHCI_HCS_N_PORTS(sparams);
	cparams = EREAD4(sc, EHCI_HCCPARAMS);
	DPRINTF(("ehci_init: cparams=0x%x\n", cparams));
	sc->sc_hasppc = EHCI_HCS_PPC(sparams);

	if (EHCI_HCC_64BIT(cparams)) {
		/* MUST clear segment register if 64 bit capable. */
		EWRITE4(sc, EHCI_CTRLDSSEGMENT, 0);
	}

	sc->sc_bus.usbrev = USBREV_2_0;
#ifndef __riscos
	usb_setup_reserve(sc->sc_dev, &sc->sc_dma_reserve, sc->sc_bus.dmatag,
	    USB_MEM_RESERVE);
#endif
	/* Reset the controller */
	DPRINTF(("%s: resetting\n", USBDEVNAME(sc->sc_bus.bdev)));
	EOWRITE4(sc, EHCI_USBCMD, 0);	/* Halt controller */
#ifdef __riscos
        EOREAD4(sc, EHCI_USBCMD);
#endif	
	usb_delay_ms(&sc->sc_bus, 1);
	EOWRITE4(sc, EHCI_USBCMD, EHCI_CMD_HCRESET);
	for (i = 0; i < 100; i++) {
		usb_delay_ms(&sc->sc_bus, 1);
		hcr = EOREAD4(sc, EHCI_USBCMD) & EHCI_CMD_HCRESET;
		if (!hcr)
			break;
	}
	if (hcr) {
		logprintf("%s: reset timeout\n", USBDEVNAME(sc->sc_bus.bdev));
		return (USBD_IOERROR);
	}

	/*
	 * If we are doing embedded transaction translation function, force
	 * the controller to host mode.
	 */
	if (sc->sc_flags & EHCIF_ETTF) {
		uint32_t usbmode = EREAD4(sc, EHCI_USBMODE);
		usbmode &= ~EHCI_USBMODE_CM;
		usbmode |= EHCI_USBMODE_CM_HOST;
		EWRITE4(sc, EHCI_USBMODE, usbmode);
	}

	/* XXX need proper intr scheduling */
	sc->sc_rand = 96;

#ifdef USBHAL
	/* A full frame list takes up a lot of memory. Try shrinking it to minimum. */
	if(EHCI_HCC_PFLF(cparams))
		EOWRITE4(sc, EHCI_USBCMD, (EOREAD4(sc, EHCI_USBCMD) & ~EHCI_CMD_FLS_M) | (2<<2));
#endif

	/* frame list size at default, read back what we got and use that */
	switch (EHCI_CMD_FLS(EOREAD4(sc, EHCI_USBCMD))) {
	case 0: sc->sc_flsize = 1024; break;
	case 1: sc->sc_flsize = 512; break;
	case 2: sc->sc_flsize = 256; break;
	case 3: return (USBD_IOERROR);
	}
	err = usb_allocmem(&sc->sc_bus, sc->sc_flsize * sizeof(ehci_link_t),
	    EHCI_FLALIGN_ALIGN, &sc->sc_fldma);
	if (err)
		return (err);
	DPRINTF(("%s: flsize=%d\n", USBDEVNAME(sc->sc_bus.bdev),sc->sc_flsize));
        sc->sc_flist = KERNADDR(&sc->sc_fldma, 0);

	for (i = 0; i < sc->sc_flsize; i++) {
		sc->sc_flist[i] = EHCI_NULL;
	}

	EOWRITE4(sc, EHCI_PERIODICLISTBASE, DMAADDR(&sc->sc_fldma, 0));

	sc->sc_softitds = malloc(sc->sc_flsize * sizeof(ehci_soft_itd_t *),
					M_USB, M_NOWAIT | M_ZERO);
	if (sc->sc_softitds == NULL)
		return ENOMEM;
#ifdef __riscos
	memset(sc->sc_softitds, 0, sc->sc_flsize * sizeof(ehci_soft_itd_t *)); /* No M_ZERO on RISC OS :( */
#endif
	LIST_INIT(&sc->sc_freeitds);
	TAILQ_INIT(&sc->sc_intrhead);
	mutex_init(&sc->sc_intrhead_lock, MUTEX_DEFAULT, IPL_USB);

	/* Set up the bus struct. */
	sc->sc_bus.methods = &ehci_bus_methods;
	sc->sc_bus.pipe_size = sizeof(struct ehci_pipe);

	sc->sc_eintrs = EHCI_NORMAL_INTRS;

	/*
	 * Allocate the interrupt dummy QHs. These are arranged to give poll
	 * intervals that are powers of 2 times 1ms.
	 */
	for (i = 0; i < EHCI_INTRQHS; i++) {
		sqh = ehci_alloc_sqh(sc);
		if (sqh == NULL) {
			err = USBD_NOMEM;
			goto bad1;
		}
		sc->sc_islots[i].sqh = sqh;
	}
	for (i = 0; i < EHCI_INTRQHS; i++) {
		sqh = sc->sc_islots[i].sqh;
		if (i == 0) {
			/* The last (1ms) QH terminates. */
			sqh->qh.qh_link = EHCI_NULL;
			sqh->next = NULL;
		} else {
			/* Otherwise the next QH has half the poll interval */
			sqh->next = sc->sc_islots[(i + 1) / 2 - 1].sqh;
			sqh->qh.qh_link = htole32(sqh->next->physaddr |
			    EHCI_LINK_QH);
		}
		sqh->qh.qh_endp = htole32(EHCI_QH_SET_EPS(EHCI_QH_SPEED_HIGH));
		sqh->qh.qh_curqtd = EHCI_NULL;
		sqh->next = NULL;
		sqh->qh.qh_qtd.qtd_next = EHCI_NULL;
		sqh->qh.qh_qtd.qtd_altnext = EHCI_NULL;
		sqh->qh.qh_qtd.qtd_status = htole32(EHCI_QTD_HALTED);
		sqh->sqtd = NULL;
		usb_syncmem(&sqh->dma, sqh->offs, sizeof(sqh->qh),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	/* Point the frame list at the last level (128ms). */
	for (i = 0; i < sc->sc_flsize; i++) {
		int j;

		j = (i & ~(EHCI_MAX_POLLRATE-1)) |
		    revbits[i & (EHCI_MAX_POLLRATE-1)];
		sc->sc_flist[j] = htole32(EHCI_LINK_QH |
		    sc->sc_islots[EHCI_IQHIDX(EHCI_IPOLLRATES - 1,
		    i)].sqh->physaddr);
	}
	usb_syncmem(&sc->sc_fldma, 0, sc->sc_flsize * sizeof(ehci_link_t),
	    BUS_DMASYNC_PREWRITE);

	/* Allocate dummy QH that starts the async list. */
	sqh = ehci_alloc_sqh(sc);
	if (sqh == NULL) {
		err = USBD_NOMEM;
		goto bad1;
	}
	/* Fill the QH */
	sqh->qh.qh_endp =
	    htole32(EHCI_QH_SET_EPS(EHCI_QH_SPEED_HIGH) | EHCI_QH_HRECL);
	sqh->qh.qh_link =
	    htole32(sqh->physaddr | EHCI_LINK_QH);
	sqh->qh.qh_curqtd = EHCI_NULL;
	sqh->next = NULL;
	/* Fill the overlay qTD */
	sqh->qh.qh_qtd.qtd_next = EHCI_NULL;
	sqh->qh.qh_qtd.qtd_altnext = EHCI_NULL;
	sqh->qh.qh_qtd.qtd_status = htole32(EHCI_QTD_HALTED);
	sqh->sqtd = NULL;
	usb_syncmem(&sqh->dma, sqh->offs, sizeof(sqh->qh),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
#ifdef EHCI_DEBUG
	if (ehcidebug) {
		ehci_dump_sqh(sqh);
	}
#endif

	/* Point to async list */
	sc->sc_async_head = sqh;
	EOWRITE4(sc, EHCI_ASYNCLISTADDR, sqh->physaddr | EHCI_LINK_QH);

	callout_init(&(sc->sc_tmo_intrlist), 0);

	mutex_init(&sc->sc_doorbell_lock, MUTEX_DEFAULT, IPL_NONE);

	/* Turn on controller */
	EOWRITE4(sc, EHCI_USBCMD,
		 EHCI_CMD_ITC_2 | /* 2 microframes interrupt delay */
		 (EOREAD4(sc, EHCI_USBCMD) & EHCI_CMD_FLS_M) |
		 EHCI_CMD_ASE |
		 EHCI_CMD_PSE |
		 EHCI_CMD_RS);

	/* Take over port ownership */
	EOWRITE4(sc, EHCI_CONFIGFLAG, EHCI_CONF_CF);

	for (i = 0; i < 100; i++) {
		usb_delay_ms(&sc->sc_bus, 1);
		hcr = EOREAD4(sc, EHCI_USBSTS) & EHCI_STS_HCH;
		if (!hcr)
			break;
	}
	if (hcr) {
		logprintf("%s: run timeout\n", USBDEVNAME(sc->sc_bus.bdev));
		return (USBD_IOERROR);
	}

	/* Enable interrupts */
	DPRINTFN(1,("ehci_init: enabling\n"));
	EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);

	return (USBD_NORMAL_COMPLETION);

#if 0
 bad2:
	ehci_free_sqh(sc, sc->sc_async_head);
#endif
 bad1:
	usb_freemem(&sc->sc_bus, &sc->sc_fldma);
	return (err);
}

int
ehci_intr(void *v)
{
	ehci_softc_t *sc = v;

	if (sc == NULL || sc->sc_dying || !device_has_power(sc->sc_dev))
		return (0);

	/* If we get an interrupt while polling, then just ignore it. */
	if (sc->sc_bus.use_polling) {
		u_int32_t intrs = EHCI_STS_INTRS(EOREAD4(sc, EHCI_USBSTS));

		if (intrs)
			EOWRITE4(sc, EHCI_USBSTS, intrs); /* Acknowledge */
#ifdef DIAGNOSTIC
		DPRINTFN(16, ("ehci_intr: ignored interrupt while polling\n"));
#endif
#ifdef __riscos
			EOREAD4(sc, EHCI_USBINTR);
			riscos_irqclear(sc->sc_irqdevno);
#endif
		return (0);
	}

	return (ehci_intr1(sc));
}

Static int
ehci_intr1(ehci_softc_t *sc)
{
	u_int32_t intrs, eintrs;

	DPRINTFN(20,("ehci_intr1: enter\n"));

	/* In case the interrupt occurs before initialization has completed. */
	if (sc == NULL) {
#ifdef DIAGNOSTIC
		printf("ehci_intr1: sc == NULL\n");
#endif
		return (0);
	}

	intrs = EHCI_STS_INTRS(EOREAD4(sc, EHCI_USBSTS));
	if (!intrs)
		return (0);

	eintrs = intrs & sc->sc_eintrs;
	DPRINTFN(7, ("ehci_intr1: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n",
		     sc, (u_int)intrs, EOREAD4(sc, EHCI_USBSTS),
		     (u_int)eintrs));
	if (!eintrs)
		return (0);

	EOWRITE4(sc, EHCI_USBSTS, intrs); /* Acknowledge */
#ifdef __riscos
        /* make sure it gets there */
        EOREAD4(sc, EHCI_USBSTS);
        riscos_irqclear(sc->sc_irqdevno);
#endif
	sc->sc_bus.intr_context++;
	sc->sc_bus.no_intrs++;
	if (eintrs & EHCI_STS_IAA) {
		DPRINTF(("ehci_intr1: door bell\n"));
		wakeup(&sc->sc_async_head);
		eintrs &= ~EHCI_STS_IAA;
	}
	if (eintrs & (EHCI_STS_INT | EHCI_STS_ERRINT)) {
		DPRINTFN(5,("ehci_intr1: %s %s\n",
			    eintrs & EHCI_STS_INT ? "INT" : "",
			    eintrs & EHCI_STS_ERRINT ? "ERRINT" : ""));
#if defined(__riscos) && !defined(USB_USE_SOFTINTR)
                ehci_softintr(&sc->sc_bus);
#else
		usb_schedsoftintr(&sc->sc_bus);
#endif
		eintrs &= ~(EHCI_STS_INT | EHCI_STS_ERRINT);
	}
	if (eintrs & EHCI_STS_HSE) {
		printf("%s: unrecoverable error, controller halted\n",
		       USBDEVNAME(sc->sc_bus.bdev));
		/* XXX what else */
	}
	if (eintrs & EHCI_STS_PCD) {
		ehci_pcd(sc, sc->sc_intrxfer);
		eintrs &= ~EHCI_STS_PCD;
	}

	sc->sc_bus.intr_context--;

	if (eintrs != 0) {
		/* Block unprocessed interrupts. */
		sc->sc_eintrs &= ~eintrs;
		EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);
		printf("%s: blocking intrs 0x%x\n",
		       USBDEVNAME(sc->sc_bus.bdev), eintrs);
	}

#ifdef __riscos
        (void) EOREAD4(sc, EHCI_USBSTS); /* Acknowledge */
#endif

	return (1);
}


Static void
ehci_pcd(ehci_softc_t *sc, usbd_xfer_handle xfer)
{
	usbd_pipe_handle pipe;
	u_char *p;
	int i, m;

	if (xfer == NULL) {
		/* Just ignore the change. */
		return;
	}

	pipe = xfer->pipe;

	p = KERNADDR(&xfer->dmabuf, 0);
	m = min(sc->sc_noport, xfer->length * 8 - 1);
	memset(p, 0, xfer->length);
	for (i = 1; i <= m; i++) {
		/* Pick out CHANGE bits from the status reg. */
		if (EOREAD4(sc, EHCI_PORTSC(i)) & EHCI_PS_CLEAR)
			p[i/8] |= 1 << (i%8);
	}
	DPRINTF(("ehci_pcd: change=0x%02x\n", *p));
	xfer->actlen = xfer->length;
	xfer->status = USBD_NORMAL_COMPLETION;

	usb_transfer_complete(xfer);
}

Static void
ehci_softintr(void *v)
{
	ehci_softc_t *sc = v;
	struct ehci_xfer *ex, *nextex;

	DPRINTFN(10,("%s: ehci_softintr (%d)\n", USBDEVNAME(sc->sc_bus.bdev),
		     sc->sc_bus.intr_context));

	sc->sc_bus.intr_context++;

	/*
	 * The only explanation I can think of for why EHCI is as brain dead
	 * as UHCI interrupt-wise is that Intel was involved in both.
	 * An interrupt just tells us that something is done, we have no
	 * clue what, so we need to scan through all active transfers. :-(
	 */
	for (ex = TAILQ_FIRST(&sc->sc_intrhead); ex; ex = nextex) {
		nextex = TAILQ_NEXT(ex, inext);
		ehci_check_intr(sc, ex);
	}

	/* Schedule a callout to catch any dropped transactions. */
	if ((sc->sc_flags & EHCIF_DROPPED_INTR_WORKAROUND) &&
	    !TAILQ_EMPTY(&sc->sc_intrhead))
		callout_reset(&(sc->sc_tmo_intrlist),
		    (hz), (ehci_intrlist_timeout), (sc));

#ifdef USB_USE_SOFTINTR
	if (sc->sc_softwake) {
		sc->sc_softwake = 0;
		wakeup(&sc->sc_softwake);
	}
#endif /* USB_USE_SOFTINTR */

	sc->sc_bus.intr_context--;
}

/* Check for an interrupt. */
Static void
ehci_check_intr(ehci_softc_t *sc, struct ehci_xfer *ex)
{
	int attr;

	DPRINTFN(/*15*/2, ("ehci_check_intr: ex=%p\n", ex));

	attr = ex->xfer.pipe->endpoint->edesc->bmAttributes;
	if (UE_GET_XFERTYPE(attr) == UE_ISOCHRONOUS)
		ehci_check_itd_intr(sc, ex);
	else
		ehci_check_qh_intr(sc, ex);

	return;
}

Static void
ehci_check_qh_intr(ehci_softc_t *sc, struct ehci_xfer *ex)
{
	ehci_soft_qtd_t *sqtd, *lsqtd;
	uint32_t status;

	if (ex->sqtdstart == NULL) {
		printf("ehci_check_qh_intr: not valid sqtd\n");
		return;
	}

	lsqtd = ex->sqtdend;
#ifdef DIAGNOSTIC
	if (lsqtd == NULL) {
		printf("ehci_check_qh_intr: lsqtd==0\n");
		return;
	}
#endif
	/*
	 * If the last TD is still active we need to check whether there
	 * is a an error somewhere in the middle, or whether there was a
	 * short packet (SPD and not ACTIVE).
	 */
	usb_syncmem(&lsqtd->dma,
	    lsqtd->offs + offsetof(ehci_qtd_t, qtd_status),
	    sizeof(lsqtd->qtd.qtd_status),
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
	if (le32toh(lsqtd->qtd.qtd_status) & EHCI_QTD_ACTIVE) {
		DPRINTFN(12, ("ehci_check_intr: active ex=%p\n", ex));
		for (sqtd = ex->sqtdstart; sqtd != lsqtd; sqtd=sqtd->nextqtd) {
			usb_syncmem(&sqtd->dma,
			    sqtd->offs + offsetof(ehci_qtd_t, qtd_status),
			    sizeof(sqtd->qtd.qtd_status),
			    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
			status = le32toh(sqtd->qtd.qtd_status);
			usb_syncmem(&sqtd->dma,
			    sqtd->offs + offsetof(ehci_qtd_t, qtd_status),
			    sizeof(sqtd->qtd.qtd_status), BUS_DMASYNC_PREREAD);
			/* If there's an active QTD the xfer isn't done. */
			if (status & EHCI_QTD_ACTIVE)
				break;
			/* Any kind of error makes the xfer done. */
			if (status & EHCI_QTD_HALTED)
				goto done;
			/* We want short packets, and it is short: it's done */
			if (EHCI_QTD_GET_BYTES(status) != 0)
				goto done;
		}
		DPRINTFN(12, ("ehci_check_intr: ex=%p std=%p still active\n",
			      ex, ex->sqtdstart));
		usb_syncmem(&lsqtd->dma,
		    lsqtd->offs + offsetof(ehci_qtd_t, qtd_status),
		    sizeof(lsqtd->qtd.qtd_status), BUS_DMASYNC_PREREAD);
		return;
	}
 done:
	DPRINTFN(12, ("ehci_check_intr: ex=%p done\n", ex));
	callout_stop(&(ex->xfer.timeout_handle));
	ehci_idone(ex);
}

Static void
ehci_check_itd_intr(ehci_softc_t *sc, struct ehci_xfer *ex) {
	ehci_soft_itd_t *itd;
	int i;

	if (&ex->xfer != SIMPLEQ_FIRST(&ex->xfer.pipe->queue))
		return;

	if (ex->itdstart == NULL) {
		printf("ehci_check_itd_intr: not valid itd\n");
		return;
	}

	itd = ex->itdend;
#ifdef DIAGNOSTIC
	if (itd == NULL) {
		printf("ehci_check_itd_intr: itdend == 0\n");
		return;
	}
#endif

	/*
	 * check no active transfers in last itd, meaning we're finished
	 */

	usb_syncmem(&itd->dma, itd->offs + offsetof(ehci_itd_t, itd_ctl),
		    sizeof(itd->itd.itd_ctl), BUS_DMASYNC_POSTWRITE |
		    BUS_DMASYNC_POSTREAD);

	for (i = 0; i < EHCI_ITD_NUFRAMES; i++) {
		if (le32toh(itd->itd.itd_ctl[i]) & EHCI_ITD_ACTIVE)
			break;
	}

	if (i == EHCI_ITD_NUFRAMES) {
		goto done; /* All 8 descriptors inactive, it's done */
	}

	DPRINTFN(12, ("ehci_check_itd_intr: ex %p itd %p still active\n", ex,
			ex->itdstart));
	return;
done:
	DPRINTFN(12, ("ehci_check_itd_intr: ex=%p done\n", ex));
	callout_stop(&(ex->xfer.timeout_handle));
	ehci_idone(ex);
}

Static void
ehci_idone(struct ehci_xfer *ex)
{
	usbd_xfer_handle xfer = &ex->xfer;
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
	ehci_soft_qtd_t *sqtd, *lsqtd;
	u_int32_t status = 0, nstatus = 0;
	int actlen;

	DPRINTFN(/*12*/2, ("ehci_idone: ex=%p\n", ex));
#ifdef DIAGNOSTIC
	{
		int s = splhigh();
		if (ex->isdone) {
			splx(s);
#ifdef EHCI_DEBUG
			printf("ehci_idone: ex is done!\n   ");
			ehci_dump_exfer(ex);
#else
			printf("ehci_idone: ex=%p is done!\n", ex);
#endif
			return;
		}
		ex->isdone = 1;
		splx(s);
	}
#endif
	if (xfer->status == USBD_CANCELLED ||
	    xfer->status == USBD_TIMEOUT) {
		DPRINTF(("ehci_idone: aborted xfer=%p\n", xfer));
		return;
	}

#ifdef EHCI_DEBUG
	DPRINTFN(/*10*/2, ("ehci_idone: xfer=%p, pipe=%p ready\n", xfer, epipe));
	if (ehcidebug > 10)
		ehci_dump_sqtds(ex->sqtdstart);
#endif

	/* The transfer is done, compute actual length and status. */

	if (UE_GET_XFERTYPE(xfer->pipe->endpoint->edesc->bmAttributes)
				== UE_ISOCHRONOUS) {
		/* Isoc transfer */
		struct ehci_soft_itd *itd;
		int i, nframes, len, uframes;

		nframes = 0;
		actlen = 0;

		i = xfer->pipe->endpoint->edesc->bInterval;
		uframes = min(1 << (i - 1), USB_UFRAMES_PER_FRAME);

		for (itd = ex->itdstart; itd != NULL; itd = itd->xfer_next) {
			usb_syncmem(&itd->dma,itd->offs + offsetof(ehci_itd_t,itd_ctl),
			    sizeof(itd->itd.itd_ctl), BUS_DMASYNC_POSTWRITE |
			    BUS_DMASYNC_POSTREAD);

			for (i = 0; i < EHCI_ITD_NUFRAMES; i += uframes) {
				/* XXX - driver didn't fill in the frame full
				 *   of uframes. This leads to scheduling
				 *   inefficiencies, but working around
				 *   this doubles complexity of tracking
				 *   an xfer.
				 */
				if (nframes >= xfer->nframes)
					break;

				status = le32toh(itd->itd.itd_ctl[i]);
				len = EHCI_ITD_GET_LEN(status);
				if (EHCI_ITD_GET_STATUS(status) != 0)
					len = 0; /*No valid data on error*/

				xfer->frlengths[nframes++] = len;
				actlen += len;
			}

			if (nframes >= xfer->nframes)
				break;
	    	}

		xfer->actlen = actlen;
		xfer->status = USBD_NORMAL_COMPLETION;
		goto end;
	}

	/* Continue processing xfers using queue heads */

	lsqtd = ex->sqtdend;
	actlen = 0;
	for (sqtd = ex->sqtdstart; sqtd != lsqtd->nextqtd; sqtd = sqtd->nextqtd) {
		usb_syncmem(&sqtd->dma, sqtd->offs, sizeof(sqtd->qtd),
		    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
		nstatus = le32toh(sqtd->qtd.qtd_status);
		if (nstatus & EHCI_QTD_ACTIVE)
			break;

		status = nstatus;
		if (EHCI_QTD_GET_PID(status) != EHCI_QTD_PID_SETUP)
			actlen += sqtd->len - EHCI_QTD_GET_BYTES(status);
	}


	/*
	 * If there are left over TDs we need to update the toggle.
	 * The default pipe doesn't need it since control transfers
	 * start the toggle at 0 every time.
	 * For a short transfer we need to update the toggle for the missing
	 * packets within the qTD.
	 */
	if ((sqtd != lsqtd->nextqtd || EHCI_QTD_GET_BYTES(status)) &&
	    xfer->pipe->device->default_pipe != xfer->pipe) {
		DPRINTFN(2, ("ehci_idone: need toggle update "
			     "status=%08x nstatus=%08x\n", status, nstatus));
#if 0
		ehci_dump_sqh(epipe->sqh);
		ehci_dump_sqtds(ex->sqtdstart);
#endif
		epipe->nexttoggle = EHCI_QTD_GET_TOGGLE(nstatus);
	}

	DPRINTFN(/*10*/2, ("ehci_idone: len=%d, actlen=%d, status=0x%x\n",
			   xfer->length, actlen, status));
	xfer->actlen = actlen;
	if (status & EHCI_QTD_HALTED) {
#ifdef EHCI_DEBUG
		char sbuf[128];

#ifndef __riscos
		snprintb(sbuf, sizeof(sbuf),
		    "\20\7HALTED\6BUFERR\5BABBLE\4XACTERR\3MISSED\1PINGSTATE",
		    (u_int32_t)status);
#else
        sprintf (sbuf, "%s%s%s%s%s%s%s%s",
            (status&0x80)?" active":"",
            (status&0x40)?" halted":"",
            (status&0x20)?" buferr":"",
            (status&0x10)?" babble":"",
            (status&0x08)?" xacterr":"",
            (status&0x10004)?" missedmicro":"",
            (status&0x4)?" missedmicro":"",
            (status&0x02)?" splitxstate":"",
            (status&0x01)?" pingstate":"");
#endif

		DPRINTFN(2, ("ehci_idone: error, addr=%d, endpt=0x%02x, "
			  "status 0x%s\n",
			  xfer->pipe->device->address,
			  xfer->pipe->endpoint->edesc->bEndpointAddress,
			  sbuf));
		if (ehcidebug > 2) {
			ehci_dump_sqh(epipe->sqh);
			ehci_dump_sqtds(ex->sqtdstart);
		}
#endif
		/* low&full speed has an extra error flag */
		if (EHCI_QH_GET_EPS(epipe->sqh->qh.qh_endp) !=
		    EHCI_QH_SPEED_HIGH)
			status &= EHCI_QTD_STATERRS | EHCI_QTD_PINGSTATE;
		else
			status &= EHCI_QTD_STATERRS;
		if (status == 0) /* no other errors means a stall */ {
			xfer->status = USBD_STALLED;
		} else {
			xfer->status = USBD_IOERROR; /* more info XXX */
		}
		/* XXX need to reset TT on missed microframe */
		if (status & EHCI_QTD_MISSEDMICRO) {
			ehci_softc_t *sc = (ehci_softc_t *)
			    xfer->pipe->device->bus;

			printf("%s: missed microframe, TT reset not "
			    "implemented, hub might be inoperational\n",
			    USBDEVNAME(sc->sc_bus.bdev));
		}
	} else {
		xfer->status = USBD_NORMAL_COMPLETION;
	}

    end:
	/* XXX transfer_complete memcpys out transfer data (for in endpoints)
	 * during this call, before methods->done is called: dma sync required
	 * beforehand? */
	usb_transfer_complete(xfer);
	DPRINTFN(/*12*/2, ("ehci_idone: ex=%p done\n", ex));
}

/*
 * Wait here until controller claims to have an interrupt.
 * Then call ehci_intr and return.  Use timeout to avoid waiting
 * too long.
 */
Static void
ehci_waitintr(ehci_softc_t *sc, usbd_xfer_handle xfer)
{
	int timo;
	u_int32_t intrs;

	xfer->status = USBD_IN_PROGRESS;
	for (timo = xfer->timeout; timo >= 0; timo--) {
		usb_delay_ms(&sc->sc_bus, 1);
		if (sc->sc_dying)
			break;
		intrs = EHCI_STS_INTRS(EOREAD4(sc, EHCI_USBSTS)) &
			sc->sc_eintrs;
		DPRINTFN(15,("ehci_waitintr: 0x%04x\n", intrs));
#ifdef EHCI_DEBUG
		if (ehcidebug > 15)
			ehci_dump_regs(sc);
#endif
		if (intrs) {
			ehci_intr1(sc);
			if (xfer->status != USBD_IN_PROGRESS)
				return;
		}
	}

	/* Timeout */
	DPRINTF(("ehci_waitintr: timeout\n"));
	xfer->status = USBD_TIMEOUT;
	usb_transfer_complete(xfer);
	/* XXX should free TD */
}

Static void
ehci_poll(struct usbd_bus *bus)
{
	ehci_softc_t *sc = (ehci_softc_t *)bus;
#ifdef EHCI_DEBUG
	static int last;
	int new;
	new = EHCI_STS_INTRS(EOREAD4(sc, EHCI_USBSTS));
	if (new != last) {
		DPRINTFN(10,("ehci_poll: intrs=0x%04x\n", new));
		last = new;
	}
#endif

	if (EOREAD4(sc, EHCI_USBSTS) & sc->sc_eintrs)
		ehci_intr1(sc);
}

#ifndef __riscos /* Not used yet */
void
ehci_childdet(device_t self, device_t child)
{
	struct ehci_softc *sc = device_private(self);

	KASSERT(sc->sc_child == child);
	sc->sc_child = NULL;
}
#endif

int
ehci_detach(struct ehci_softc *sc, int flags)
{
	int rv = 0;

#ifndef __riscos
	if (sc->sc_child != NULL)
		rv = config_detach(sc->sc_child, flags);
#endif

	if (rv != 0)
		return (rv);

	callout_stop(&(sc->sc_tmo_intrlist));

	usb_delay_ms(&sc->sc_bus, 300); /* XXX let stray task complete */

	/* XXX free other data structures XXX */
	mutex_destroy(&sc->sc_doorbell_lock);
	mutex_destroy(&sc->sc_intrhead_lock);

	EOWRITE4(sc, EHCI_CONFIGFLAG, 0);

	return (rv);
}


#ifndef __riscos /* These aren't used yet */
int
ehci_activate(device_t self, enum devact act)
{
	struct ehci_softc *sc = device_private(self);

	switch (act) {
	case DVACT_DEACTIVATE:
#ifndef __riscos
		sc->sc_dying = 1;
#endif
		return 0;
	default:
		return EOPNOTSUPP;
	}
}

/*
 * Handle suspend/resume.
 *
 * We need to switch to polling mode here, because this routine is
 * called from an interrupt context.  This is all right since we
 * are almost suspended anyway.
 *
 * Note that this power handler isn't to be registered directly; the
 * bus glue needs to call out to it.
 */
bool
ehci_suspend(device_t dv, const pmf_qual_t *qual)
{
	ehci_softc_t *sc = device_private(dv);
	int i, s;
	uint32_t cmd, hcr;

	s = splhardusb();

	sc->sc_bus.use_polling++;

	for (i = 1; i <= sc->sc_noport; i++) {
		cmd = EOREAD4(sc, EHCI_PORTSC(i)) & ~EHCI_PS_CLEAR;
		if ((cmd & EHCI_PS_PO) == 0 && (cmd & EHCI_PS_PE) == EHCI_PS_PE)
			EOWRITE4(sc, EHCI_PORTSC(i), cmd | EHCI_PS_SUSP);
	}

	sc->sc_cmd = EOREAD4(sc, EHCI_USBCMD);

	cmd = sc->sc_cmd & ~(EHCI_CMD_ASE | EHCI_CMD_PSE);
	EOWRITE4(sc, EHCI_USBCMD, cmd);

	for (i = 0; i < 100; i++) {
		hcr = EOREAD4(sc, EHCI_USBSTS) & (EHCI_STS_ASS | EHCI_STS_PSS);
		if (hcr == 0)
			break;

		usb_delay_ms(&sc->sc_bus, 1);
	}
	if (hcr != 0)
		printf("%s: reset timeout\n", device_xname(dv));

	cmd &= ~EHCI_CMD_RS;
	EOWRITE4(sc, EHCI_USBCMD, cmd);

	for (i = 0; i < 100; i++) {
		hcr = EOREAD4(sc, EHCI_USBSTS) & EHCI_STS_HCH;
		if (hcr == EHCI_STS_HCH)
			break;

		usb_delay_ms(&sc->sc_bus, 1);
	}
	if (hcr != EHCI_STS_HCH)
		printf("%s: config timeout\n", device_xname(dv));

	sc->sc_bus.use_polling--;
	splx(s);

	return true;
}

bool
ehci_resume(device_t dv, const pmf_qual_t *qual)
{
	ehci_softc_t *sc = device_private(dv);
	int i;
	uint32_t cmd, hcr;

	/* restore things in case the bios sucks */
	EOWRITE4(sc, EHCI_CTRLDSSEGMENT, 0);
	EOWRITE4(sc, EHCI_PERIODICLISTBASE, DMAADDR(&sc->sc_fldma, 0));
	EOWRITE4(sc, EHCI_ASYNCLISTADDR,
	    sc->sc_async_head->physaddr | EHCI_LINK_QH);

	EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs & ~EHCI_INTR_PCIE);

	EOWRITE4(sc, EHCI_USBCMD, sc->sc_cmd);

	hcr = 0;
	for (i = 1; i <= sc->sc_noport; i++) {
		cmd = EOREAD4(sc, EHCI_PORTSC(i)) & ~EHCI_PS_CLEAR;
		if ((cmd & EHCI_PS_PO) == 0 &&
		    (cmd & EHCI_PS_SUSP) == EHCI_PS_SUSP) {
			EOWRITE4(sc, EHCI_PORTSC(i), cmd | EHCI_PS_FPR);
			hcr = 1;
		}
	}

	if (hcr) {
		usb_delay_ms(&sc->sc_bus, USB_RESUME_WAIT);

		for (i = 1; i <= sc->sc_noport; i++) {
			cmd = EOREAD4(sc, EHCI_PORTSC(i)) & ~EHCI_PS_CLEAR;
			if ((cmd & EHCI_PS_PO) == 0 &&
			    (cmd & EHCI_PS_SUSP) == EHCI_PS_SUSP)
				EOWRITE4(sc, EHCI_PORTSC(i),
				    cmd & ~EHCI_PS_FPR);
		}
	}

	EOWRITE4(sc, EHCI_USBCMD, sc->sc_cmd);
	EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);

	for (i = 0; i < 100; i++) {
		hcr = EOREAD4(sc, EHCI_USBSTS) & EHCI_STS_HCH;
		if (hcr != EHCI_STS_HCH)
			break;

		usb_delay_ms(&sc->sc_bus, 1);
	}
	if (hcr == EHCI_STS_HCH)
		printf("%s: config timeout\n", device_xname(dv));

	return true;
}
#endif

/*
 * Shut down the controller when the system is going down.
 */
bool
#ifdef __riscos
ehci_shutdown(void *v)
{
	ehci_softc_t *sc = v;
#else
ehci_shutdown(device_t self, int flags)
{
	ehci_softc_t *sc = device_private(self);
#endif

	DPRINTF(("ehci_shutdown: stopping the HC\n"));
	EOWRITE4(sc, EHCI_USBCMD, 0);	/* Halt controller */
	EOWRITE4(sc, EHCI_USBCMD, EHCI_CMD_HCRESET);
#ifdef __riscos
	EOREAD4(sc, EHCI_USBCMD );     /* flush command */
#endif
	return true;
}

Static usbd_status
ehci_allocm(struct usbd_bus *bus, usb_dma_t *dma, u_int32_t size)
{
	struct ehci_softc *sc = (struct ehci_softc *)bus;
	usbd_status err;

	/* The EHCI controller in the DM37x seems to have difficulty if the last packet of a bulk transfer is a short packet that crosses a page boundary. It looks like the second half of the packet doesn't get written to memory, or gets written to completely the wrong place.
	   This problem is easiest to reproduce using the USB ethernet on the BB-xM
	   As a simple workaround, force all EHCI buffers to be 512 byte aligned */
	err = usb_allocmem(&sc->sc_bus, size, 512, dma);
#ifndef __riscos
	if (err == USBD_NOMEM)
		err = usb_reserve_allocm(&sc->sc_dma_reserve, dma, size);
#endif
#ifdef EHCI_DEBUG
	if (err)
		printf("ehci_allocm: usb_allocmem()=%d\n", err);
#endif
	return (err);
}

Static void
ehci_freem(struct usbd_bus *bus, usb_dma_t *dma)
{
	struct ehci_softc *sc = (struct ehci_softc *)bus;
	(void) sc;
#ifndef __riscos
	if (dma->block->flags & USB_DMA_RESERVE) {
		usb_reserve_freem(&sc->sc_dma_reserve,
		    dma);
		return;
	}
#endif
	usb_freemem(&sc->sc_bus, dma);
}

Static usbd_xfer_handle
ehci_allocx(struct usbd_bus *bus)
{
	struct ehci_softc *sc = (struct ehci_softc *)bus;
	usbd_xfer_handle xfer;

	xfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);
	if (xfer != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, next);
#ifdef DIAGNOSTIC
		if (xfer->busy_free != XFER_FREE) {
			printf("ehci_allocx: xfer=%p not free, 0x%08x\n", xfer,
			       xfer->busy_free);
		}
#endif
	} else {
		xfer = malloc(sizeof(struct ehci_xfer), M_USB, M_NOWAIT);
	}
	if (xfer != NULL) {
		memset(xfer, 0, sizeof(struct ehci_xfer));
#ifdef DIAGNOSTIC
		EXFER(xfer)->isdone = 1;
		xfer->busy_free = XFER_BUSY;
#endif
	}
	return (xfer);
}

Static void
ehci_freex(struct usbd_bus *bus, usbd_xfer_handle xfer)
{
	struct ehci_softc *sc = (struct ehci_softc *)bus;

#ifdef DIAGNOSTIC
	if (xfer->busy_free != XFER_BUSY) {
		printf("ehci_freex: xfer=%p not busy, 0x%08x\n", xfer,
		       xfer->busy_free);
	}
	xfer->busy_free = XFER_FREE;
	if (!EXFER(xfer)->isdone) {
		printf("ehci_freex: !isdone\n");
	}
#endif
	SIMPLEQ_INSERT_HEAD(&sc->sc_free_xfers, xfer, next);
}

Static void
ehci_device_clear_toggle(usbd_pipe_handle pipe)
{
	struct ehci_pipe *epipe = (struct ehci_pipe *)pipe;

	DPRINTF(("ehci_device_clear_toggle: epipe=%p status=0x%x\n",
		 epipe, epipe->sqh->qh.qh_qtd.qtd_status));
#ifdef EHCI_DEBUG
#ifndef __riscos
	if (ehcidebug)
		usbd_dump_pipe(pipe);
#endif
#endif
	epipe->nexttoggle = 0;
}

Static void
ehci_noop(usbd_pipe_handle pipe)
{
}

#ifdef EHCI_DEBUG
Static void
ehci_dump_regs(ehci_softc_t *sc)
{
	int i;
	printf("cmd=0x%08x, sts=0x%08x, ien=0x%08x\n",
	       EOREAD4(sc, EHCI_USBCMD),
	       EOREAD4(sc, EHCI_USBSTS),
	       EOREAD4(sc, EHCI_USBINTR));
	printf("frindex=0x%08x ctrdsegm=0x%08x periodic=0x%08x async=0x%08x\n",
	       EOREAD4(sc, EHCI_FRINDEX),
	       EOREAD4(sc, EHCI_CTRLDSSEGMENT),
	       EOREAD4(sc, EHCI_PERIODICLISTBASE),
	       EOREAD4(sc, EHCI_ASYNCLISTADDR));
	for (i = 1; i <= sc->sc_noport; i++)
		printf("port %d status=0x%08x\n", i,
		       EOREAD4(sc, EHCI_PORTSC(i)));
}

/*
 * Unused function - this is meant to be called from a kernel
 * debugger.
 */
void
ehci_dump(void)
{
	ehci_dump_regs(theehci);
}

Static void
ehci_dump_link(ehci_link_t link, int type)
{
	link = le32toh(link);
	printf("0x%08x", link);
	if (link & EHCI_LINK_TERMINATE)
		printf("<T>");
	else {
		printf("<");
		if (type) {
			switch (EHCI_LINK_TYPE(link)) {
			case EHCI_LINK_ITD: printf("ITD"); break;
			case EHCI_LINK_QH: printf("QH"); break;
			case EHCI_LINK_SITD: printf("SITD"); break;
			case EHCI_LINK_FSTN: printf("FSTN"); break;
			}
		}
		printf(">");
	}
}

Static void
ehci_dump_sqtds(ehci_soft_qtd_t *sqtd)
{
	int i;
	u_int32_t stop;

	stop = 0;
	for (i = 0; sqtd && i < 20 && !stop; sqtd = sqtd->nextqtd, i++) {
		ehci_dump_sqtd(sqtd);
		usb_syncmem(&sqtd->dma,
		    sqtd->offs + offsetof(ehci_qtd_t, qtd_next), 
		    sizeof(sqtd->qtd),
		    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
		stop = sqtd->qtd.qtd_next & htole32(EHCI_LINK_TERMINATE);
		usb_syncmem(&sqtd->dma,
		    sqtd->offs + offsetof(ehci_qtd_t, qtd_next), 
		    sizeof(sqtd->qtd), BUS_DMASYNC_PREREAD);
	}
	if (sqtd)
		printf("dump aborted, too many TDs\n");
}

Static void
ehci_dump_sqtd(ehci_soft_qtd_t *sqtd)
{
	usb_syncmem(&sqtd->dma, sqtd->offs, 
	    sizeof(sqtd->qtd), BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
	printf("QTD(%p) at 0x%08x:\n", sqtd, sqtd->physaddr);
	ehci_dump_qtd(&sqtd->qtd);
	usb_syncmem(&sqtd->dma, sqtd->offs, 
	    sizeof(sqtd->qtd), BUS_DMASYNC_PREREAD);
}

Static void
ehci_dump_qtd(ehci_qtd_t *qtd)
{
	u_int32_t s;
	char sbuf[128];

	printf("  next="); ehci_dump_link(qtd->qtd_next, 0);
	printf(" altnext="); ehci_dump_link(qtd->qtd_altnext, 0);
	printf("\n");
	s = le32toh(qtd->qtd_status);
#ifndef __riscos
	snprintb(sbuf, sizeof(sbuf),
	    "\20\10ACTIVE\7HALTED\6BUFERR\5BABBLE\4XACTERR"
	    "\3MISSED\2SPLIT\1PING", EHCI_QTD_GET_STATUS(s));
#else
        sprintf (sbuf, "%s%s%s%s%s%s%s%s",
            (s&0x80)?" active":"",
            (s&0x40)?" halted":"",
            (s&0x20)?" buferr":"",
            (s&0x10)?" babble":"",
            (s&0x08)?" xacterr":"",
            (s&0x04)?" missedmicro":"",
            (s&0x02)?" splitxstate":"",
            (s&0x01)?" pingstate":"");
#endif
	printf("  status=0x%08x: toggle=%d bytes=0x%x ioc=%d c_page=0x%x\n",
	       s, EHCI_QTD_GET_TOGGLE(s), EHCI_QTD_GET_BYTES(s),
	       EHCI_QTD_GET_IOC(s), EHCI_QTD_GET_C_PAGE(s));
	printf("    cerr=%d pid=%d stat=0x%s\n", EHCI_QTD_GET_CERR(s),
	       EHCI_QTD_GET_PID(s), sbuf);
	for (s = 0; s < 5; s++)
		printf("  buffer[%d]=0x%08x\n", s, le32toh(qtd->qtd_buffer[s]));
}

Static void
ehci_dump_sqh(ehci_soft_qh_t *sqh)
{
	ehci_qh_t *qh = &sqh->qh;
	u_int32_t endp, endphub;

	usb_syncmem(&sqh->dma, sqh->offs, 
	    sizeof(sqh->qh), BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
	printf("QH(%p) at 0x%08x:\n", sqh, sqh->physaddr);
	printf("  link="); ehci_dump_link(qh->qh_link, 1); printf("\n");
	endp = le32toh(qh->qh_endp);
	printf("  endp=0x%08x\n", endp);
	printf("    addr=0x%02x inact=%d endpt=%d eps=%d dtc=%d hrecl=%d\n",
	       EHCI_QH_GET_ADDR(endp), EHCI_QH_GET_INACT(endp),
	       EHCI_QH_GET_ENDPT(endp),  EHCI_QH_GET_EPS(endp),
	       EHCI_QH_GET_DTC(endp), EHCI_QH_GET_HRECL(endp));
	printf("    mpl=0x%x ctl=%d nrl=%d\n",
	       EHCI_QH_GET_MPL(endp), EHCI_QH_GET_CTL(endp),
	       EHCI_QH_GET_NRL(endp));
	endphub = le32toh(qh->qh_endphub);
	printf("  endphub=0x%08x\n", endphub);
	printf("    smask=0x%02x cmask=0x%02x huba=0x%02x port=%d mult=%d\n",
	       EHCI_QH_GET_SMASK(endphub), EHCI_QH_GET_CMASK(endphub),
	       EHCI_QH_GET_HUBA(endphub), EHCI_QH_GET_PORT(endphub),
	       EHCI_QH_GET_MULT(endphub));
	printf("  curqtd="); ehci_dump_link(qh->qh_curqtd, 0); printf("\n");
	printf("Overlay qTD:\n");
	ehci_dump_qtd(&qh->qh_qtd);
	usb_syncmem(&sqh->dma, sqh->offs, 
	    sizeof(sqh->qh), BUS_DMASYNC_PREREAD);
}

#if notyet
Static void
ehci_dump_itd(struct ehci_soft_itd *itd)
{
	ehci_isoc_trans_t t;
	ehci_isoc_bufr_ptr_t b, b2, b3;
	int i;

	printf("ITD: next phys=%X\n", itd->itd.itd_next);

	for (i = 0; i < EHCI_ITD_NUFRAMES; i++) {
		t = le32toh(itd->itd.itd_ctl[i]);
		printf("ITDctl %d: stat=%X len=%X ioc=%X pg=%X offs=%X\n", i,
		    EHCI_ITD_GET_STATUS(t), EHCI_ITD_GET_LEN(t),
		    EHCI_ITD_GET_IOC(t), EHCI_ITD_GET_PG(t),
		    EHCI_ITD_GET_OFFS(t));
	}
	printf("ITDbufr: ");
	for (i = 0; i < EHCI_ITD_NBUFFERS; i++)
		printf("%X,", EHCI_ITD_GET_BPTR(le32toh(itd->itd.itd_bufr[i])));

	b = le32toh(itd->itd.itd_bufr[0]);
	b2 = le32toh(itd->itd.itd_bufr[1]);
	b3 = le32toh(itd->itd.itd_bufr[2]);
	printf("\nep=%X daddr=%X dir=%d maxpkt=%X multi=%X\n",
	    EHCI_ITD_GET_EP(b), EHCI_ITD_GET_DADDR(b), EHCI_ITD_GET_DIR(b2),
	    EHCI_ITD_GET_MAXPKT(b2), EHCI_ITD_GET_MULTI(b3));
}

Static void
ehci_dump_sitd(struct ehci_soft_itd *itd)
{
	printf("SITD %p next=%p prev=%p xfernext=%p physaddr=%X slot=%d\n",
			itd, itd->u.frame_list.next, itd->u.frame_list.prev,
			itd->xfer_next, itd->physaddr, itd->slot);
}
#endif

#ifdef DIAGNOSTIC
Static void
ehci_dump_exfer(struct ehci_xfer *ex)
{
	printf("ehci_dump_exfer: ex=%p sqtdstart=%p end=%p itdstart=%p end=%p isdone=%d\n", ex, ex->sqtdstart, ex->sqtdend, ex->itdstart, ex->itdend, ex->isdone);
}
#endif
#endif

Static usbd_status
ehci_open(usbd_pipe_handle pipe)
{
	usbd_device_handle dev = pipe->device;
	ehci_softc_t *sc = (ehci_softc_t *)dev->bus;
	usb_endpoint_descriptor_t *ed = pipe->endpoint->edesc;
	u_int8_t addr = dev->address;
	u_int8_t xfertype = ed->bmAttributes & UE_XFERTYPE;
	struct ehci_pipe *epipe = (struct ehci_pipe *)pipe;
	ehci_soft_qh_t *sqh;
	usbd_status err;
	int s;
	int ival, speed, naks;
	int hshubaddr, hshubport;

	DPRINTFN(1, ("ehci_open: pipe=%p, addr=%d, endpt=%d (%d)\n",
		     pipe, addr, ed->bEndpointAddress, sc->sc_addr));

	if (dev->myhsport) {
		/*
		 * When directly attached FS/LS device while doing embedded
		 * transaction translations and we are the hub, set the hub
		 * adddress to 0 (us).
		 */
		if (!(sc->sc_flags & EHCIF_ETTF)
		    || (dev->myhsport->parent->address != sc->sc_addr)) {
			hshubaddr = dev->myhsport->parent->address;
		} else {
			hshubaddr = 0;
		}
		hshubport = dev->myhsport->portno;
	} else {
		hshubaddr = 0;
		hshubport = 0;
	}

	if (sc->sc_dying)
		return (USBD_IOERROR);

	epipe->nexttoggle = 0;

	if (addr == sc->sc_addr) {
		switch (ed->bEndpointAddress) {
		case USB_CONTROL_ENDPOINT:
			pipe->methods = &ehci_root_ctrl_methods;
			break;
		case UE_DIR_IN | EHCI_INTR_ENDPT:
			pipe->methods = &ehci_root_intr_methods;
			break;
		default:
			DPRINTF(("ehci_open: bad bEndpointAddress 0x%02x\n",
			    ed->bEndpointAddress));
			return (USBD_INVAL);
		}
		return (USBD_NORMAL_COMPLETION);
	}

	/* XXX All this stuff is only valid for async. */
	switch (dev->speed) {
	case USB_SPEED_LOW:  speed = EHCI_QH_SPEED_LOW;  break;
	case USB_SPEED_FULL: speed = EHCI_QH_SPEED_FULL; break;
	case USB_SPEED_HIGH: speed = EHCI_QH_SPEED_HIGH; break;
	default: panic("ehci_open: bad device speed %d", dev->speed);
	}
	if (speed != EHCI_QH_SPEED_HIGH && xfertype == UE_ISOCHRONOUS) {
#ifndef __riscos
		aprint_error_dev(sc->sc_dev, "error opening low/full speed "
		    "isoc endpoint.\n");
		aprint_normal_dev(sc->sc_dev, "a low/full speed device is "
		    "attached to a USB2 hub, and transaction translations are "
		    "not yet supported.\n");
		aprint_normal_dev(sc->sc_dev, "reattach the device to the "
		    "root hub instead.\n");
#endif
		DPRINTFN(1,("ehci_open: hshubaddr=%d hshubport=%d\n",
			    hshubaddr, hshubport));
		return USBD_INVAL;
	}

	/*
	 * For interrupt transfer, nak throttling must be disabled, but for
	 * the other transfer type, nak throttling should be enabled from the
	 * veiwpoint that avoids the memory thrashing.
	 */
	naks = (xfertype == UE_INTERRUPT) ? 0
	    : ((speed == EHCI_QH_SPEED_HIGH) ? 4 : 0);

	/* Allocate sqh for everything, save isoc xfers */
	if (xfertype != UE_ISOCHRONOUS) {
		sqh = ehci_alloc_sqh(sc);
		if (sqh == NULL)
			return (USBD_NOMEM);
		/* qh_link filled when the QH is added */
		sqh->qh.qh_endp = htole32(
		    EHCI_QH_SET_ADDR(addr) |
		    EHCI_QH_SET_ENDPT(UE_GET_ADDR(ed->bEndpointAddress)) |
		    EHCI_QH_SET_EPS(speed) |
		    EHCI_QH_DTC |
		    EHCI_QH_SET_MPL(UGETW(ed->wMaxPacketSize)) |
		    (speed != EHCI_QH_SPEED_HIGH && xfertype == UE_CONTROL ?
		     EHCI_QH_CTL : 0) |
		    EHCI_QH_SET_NRL(naks)
		    );
		sqh->qh.qh_endphub = htole32(
		    EHCI_QH_SET_MULT(1) |
		    EHCI_QH_SET_SMASK(xfertype == UE_INTERRUPT ? 0x02 : 0)
		    );
		if (speed != EHCI_QH_SPEED_HIGH)
			sqh->qh.qh_endphub |= htole32(
			    EHCI_QH_SET_PORT(hshubport) |
			    EHCI_QH_SET_HUBA(hshubaddr) |
			    EHCI_QH_SET_CMASK(0x08) /* XXX */
			);
		sqh->qh.qh_curqtd = EHCI_NULL;
		/* Fill the overlay qTD */
		sqh->qh.qh_qtd.qtd_next = EHCI_NULL;
		sqh->qh.qh_qtd.qtd_altnext = EHCI_NULL;
		sqh->qh.qh_qtd.qtd_status = htole32(0);

		usb_syncmem(&sqh->dma, sqh->offs, sizeof(sqh->qh),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
		epipe->sqh = sqh;
	} else {
		sqh = NULL;
	} /*xfertype == UE_ISOC*/

	switch (xfertype) {
	case UE_CONTROL:
		err = usb_allocmem(&sc->sc_bus, sizeof(usb_device_request_t),
				   0, &epipe->u.ctl.reqdma);
#ifdef EHCI_DEBUG
		if (err)
			printf("ehci_open: usb_allocmem()=%d\n", err);
#endif
		if (err)
			goto bad;
		pipe->methods = &ehci_device_ctrl_methods;
		s = splusb();
		ehci_add_qh(sqh, sc->sc_async_head);
		splx(s);
		break;
	case UE_BULK:
		pipe->methods = &ehci_device_bulk_methods;
		s = splusb();
		ehci_add_qh(sqh, sc->sc_async_head);
		splx(s);
		break;
	case UE_INTERRUPT:
		pipe->methods = &ehci_device_intr_methods;
		ival = pipe->interval;
		if (ival == USBD_DEFAULT_INTERVAL) {
			if (speed == EHCI_QH_SPEED_HIGH) {
				if (ed->bInterval > 16) {
					/*
					 * illegal with high-speed, but there
					 * were documentation bugs in the spec,
					 * so be generous
					 */
					ival = 256;
				} else
					ival = (1 << (ed->bInterval - 1)) / 8;
			} else
				ival = ed->bInterval;
		}
		err = ehci_device_setintr(sc, sqh, ival);
		if (err)
			goto bad;
		break;
	case UE_ISOCHRONOUS:
		pipe->methods = &ehci_device_isoc_methods;
		if (ed->bInterval == 0 || ed->bInterval > 16) {
			printf("ehci: opening pipe with invalid bInterval\n");
			err = USBD_INVAL;
			goto bad;
		}
		if (UGETW(ed->wMaxPacketSize) == 0) {
			printf("ehci: zero length endpoint open request\n");
			err = USBD_INVAL;
			goto bad;
		}
		epipe->u.isoc.next_frame = 0;
		epipe->u.isoc.cur_xfers = 0;
		break;
	default:
		DPRINTF(("ehci: bad xfer type %d\n", xfertype));
		err = USBD_INVAL;
		goto bad;
	}
	return (USBD_NORMAL_COMPLETION);

 bad:
	if (sqh != NULL)
		ehci_free_sqh(sc, sqh);
	return (err);
}

/*
 * Add an ED to the schedule.  Called at splusb().
 */
Static void
ehci_add_qh(ehci_soft_qh_t *sqh, ehci_soft_qh_t *head)
{
	SPLUSBCHECK;

	usb_syncmem(&head->dma, head->offs + offsetof(ehci_qh_t, qh_link),
	    sizeof(head->qh.qh_link), BUS_DMASYNC_POSTWRITE);
	sqh->next = head->next;
	sqh->qh.qh_link = head->qh.qh_link;
	usb_syncmem(&sqh->dma, sqh->offs + offsetof(ehci_qh_t, qh_link),
	    sizeof(sqh->qh.qh_link), BUS_DMASYNC_PREWRITE);
	head->next = sqh;
	head->qh.qh_link = htole32(sqh->physaddr | EHCI_LINK_QH);
	usb_syncmem(&head->dma, head->offs + offsetof(ehci_qh_t, qh_link),
	    sizeof(head->qh.qh_link), BUS_DMASYNC_PREWRITE);

#ifdef EHCI_DEBUG
	if (ehcidebug > 5) {
		printf("ehci_add_qh:\n");
		ehci_dump_sqh(sqh);
	}
#endif
}

/*
 * Remove an ED from the schedule.  Called at splusb().
 */
Static void
ehci_rem_qh(ehci_softc_t *sc, ehci_soft_qh_t *sqh, ehci_soft_qh_t *head)
{
	ehci_soft_qh_t *p;

	SPLUSBCHECK;
	/* XXX */
	for (p = head; p != NULL && p->next != sqh; p = p->next)
		;
	if (p == NULL)
		panic("ehci_rem_qh: ED not found");
	usb_syncmem(&sqh->dma, sqh->offs + offsetof(ehci_qh_t, qh_link),
	    sizeof(sqh->qh.qh_link), BUS_DMASYNC_POSTWRITE);
	p->next = sqh->next;
	p->qh.qh_link = sqh->qh.qh_link;
	usb_syncmem(&p->dma, p->offs + offsetof(ehci_qh_t, qh_link),
	    sizeof(p->qh.qh_link), BUS_DMASYNC_PREWRITE);

	ehci_sync_hc(sc);
}

Static void
ehci_set_qh_qtd(ehci_soft_qh_t *sqh, ehci_soft_qtd_t *sqtd)
{
	int i;
	u_int32_t status;

	/* Save toggle bit and ping status. */
	usb_syncmem(&sqh->dma, sqh->offs, sizeof(sqh->qh),
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
	status = sqh->qh.qh_qtd.qtd_status &
	    htole32(EHCI_QTD_TOGGLE_MASK |
		    EHCI_QTD_SET_STATUS(EHCI_QTD_PINGSTATE));
	/* Set HALTED to make hw leave it alone. */
	sqh->qh.qh_qtd.qtd_status =
	    htole32(EHCI_QTD_SET_STATUS(EHCI_QTD_HALTED));
	usb_syncmem(&sqh->dma,
	    sqh->offs + offsetof(ehci_qh_t, qh_qtd.qtd_status),
	    sizeof(sqh->qh.qh_qtd.qtd_status),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	sqh->qh.qh_curqtd = 0;
	sqh->qh.qh_qtd.qtd_next = htole32(sqtd->physaddr);
	sqh->qh.qh_qtd.qtd_altnext = EHCI_NULL;
	for (i = 0; i < EHCI_QTD_NBUFFERS; i++)
		sqh->qh.qh_qtd.qtd_buffer[i] = 0;
	sqh->sqtd = sqtd;
	usb_syncmem(&sqh->dma, sqh->offs, sizeof(sqh->qh),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	/* Set !HALTED && !ACTIVE to start execution, preserve some fields */
	sqh->qh.qh_qtd.qtd_status = status;
	usb_syncmem(&sqh->dma,
	    sqh->offs + offsetof(ehci_qh_t, qh_qtd.qtd_status),
	    sizeof(sqh->qh.qh_qtd.qtd_status),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
}

/*
 * Ensure that the HC has released all references to the QH.  We do this
 * by asking for a Async Advance Doorbell interrupt and then we wait for
 * the interrupt.
 * To make this easier we first obtain exclusive use of the doorbell.
 */
Static void
ehci_sync_hc(ehci_softc_t *sc)
{
	int s, error;

	if (sc->sc_dying) {
		DPRINTFN(2,("ehci_sync_hc: dying\n"));
		return;
	}
	DPRINTFN(2,("ehci_sync_hc: enter\n"));
	mutex_enter(&sc->sc_doorbell_lock);	/* get doorbell */
	s = splhardusb();
	/* ask for doorbell */
	EOWRITE4(sc, EHCI_USBCMD, EOREAD4(sc, EHCI_USBCMD) | EHCI_CMD_IAAD);
	DPRINTFN(1,("ehci_sync_hc: cmd=0x%08x sts=0x%08x\n",
		    EOREAD4(sc, EHCI_USBCMD), EOREAD4(sc, EHCI_USBSTS)));
#ifdef __riscos
	error = tsleep(&sc->sc_async_head, PZERO, "ehcidi", hz, 1); /* bell wait */
#else
	error = tsleep(&sc->sc_async_head, PZERO, "ehcidi", hz); /* bell wait */
#endif
	DPRINTFN(1,("ehci_sync_hc: cmd=0x%08x sts=0x%08x\n",
		    EOREAD4(sc, EHCI_USBCMD), EOREAD4(sc, EHCI_USBSTS)));
	splx(s);
	mutex_exit(&sc->sc_doorbell_lock);	/* release doorbell */
#ifdef DIAGNOSTIC
	if (error)
		printf("ehci_sync_hc: tsleep() = %d\n", error);
#endif
	DPRINTFN(2,("ehci_sync_hc: exit\n"));
}

/*Call at splusb*/
Static void
ehci_rem_free_itd_chain(ehci_softc_t *sc, struct ehci_xfer *exfer)
{
	struct ehci_soft_itd *itd, *prev;

	prev = NULL;

	if (exfer->itdstart == NULL || exfer->itdend == NULL)
		panic("ehci isoc xfer being freed, but with no itd chain\n");

	for (itd = exfer->itdstart; itd != NULL; itd = itd->xfer_next) {
		prev = itd->u.frame_list.prev;
		/* Unlink itd from hardware chain, or frame array */
		if (prev == NULL) { /* We're at the table head */
			sc->sc_softitds[itd->slot] = itd->u.frame_list.next;
			sc->sc_flist[itd->slot] = itd->itd.itd_next;
			usb_syncmem(&sc->sc_fldma,
			    sizeof(ehci_link_t) * itd->slot,
                	    sizeof(ehci_link_t),
			    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

			if (itd->u.frame_list.next != NULL)
				itd->u.frame_list.next->u.frame_list.prev = NULL;
		} else {
			/* XXX this part is untested... */
			prev->itd.itd_next = itd->itd.itd_next;
			usb_syncmem(&itd->dma,
			    itd->offs + offsetof(ehci_itd_t, itd_next),
                	    sizeof(itd->itd.itd_next), BUS_DMASYNC_PREWRITE);

			prev->u.frame_list.next = itd->u.frame_list.next;
			if (itd->u.frame_list.next != NULL)
				itd->u.frame_list.next->u.frame_list.prev = prev;
		}
	}

	prev = NULL;
	for (itd = exfer->itdstart; itd != NULL; itd = itd->xfer_next) {
		if (prev != NULL)
			ehci_free_itd(sc, prev);
		prev = itd;
	}
	if (prev)
		ehci_free_itd(sc, prev);
	exfer->itdstart = NULL;
	exfer->itdend = NULL;
}

/***********/

/*
 * Data structures and routines to emulate the root hub.
 */
Static const usb_device_descriptor_t ehci_devd = {
	USB_DEVICE_DESCRIPTOR_SIZE,
	UDESC_DEVICE,		/* type */
	{0x00, 0x02},		/* USB version */
	UDCLASS_HUB,		/* class */
	UDSUBCLASS_HUB,		/* subclass */
	UDPROTO_HSHUBSTT,	/* protocol */
	64,			/* max packet */
	{0},{0},{0x00,0x01},	/* device id */
	1,2,0,			/* string indicies */
	1			/* # of configurations */
};

Static const usb_device_qualifier_t ehci_odevd = {
	USB_DEVICE_DESCRIPTOR_SIZE,
	UDESC_DEVICE_QUALIFIER,	/* type */
	{0x00, 0x02},		/* USB version */
	UDCLASS_HUB,		/* class */
	UDSUBCLASS_HUB,		/* subclass */
	UDPROTO_FSHUB,		/* protocol */
	64,			/* max packet */
	1,			/* # of configurations */
	0
};

Static const usb_config_descriptor_t ehci_confd = {
	USB_CONFIG_DESCRIPTOR_SIZE,
	UDESC_CONFIG,
	{USB_CONFIG_DESCRIPTOR_SIZE +
	 USB_INTERFACE_DESCRIPTOR_SIZE +
	 USB_ENDPOINT_DESCRIPTOR_SIZE},
	1,
	1,
	0,
	UC_ATTR_MBO | UC_SELF_POWERED,
	0			/* max power */
};

Static const usb_interface_descriptor_t ehci_ifcd = {
	USB_INTERFACE_DESCRIPTOR_SIZE,
	UDESC_INTERFACE,
	0,
	0,
	1,
	UICLASS_HUB,
	UISUBCLASS_HUB,
	UIPROTO_HSHUBSTT,
	0
};

Static const usb_endpoint_descriptor_t ehci_endpd = {
	USB_ENDPOINT_DESCRIPTOR_SIZE,
	UDESC_ENDPOINT,
	UE_DIR_IN | EHCI_INTR_ENDPT,
	UE_INTERRUPT,
	{8, 0},			/* max packet */
	12
};

Static const usb_hub_descriptor_t ehci_hubd = {
	USB_HUB_DESCRIPTOR_SIZE,
	UDESC_HUB,
	0,
	{0,0},
	0,
	0,
	{""},
	{""},
};

/*
 * Simulate a hardware hub by handling all the necessary requests.
 */
Static usbd_status
ehci_root_ctrl_transfer(usbd_xfer_handle xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ehci_root_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

Static usbd_status
ehci_root_ctrl_start(usbd_xfer_handle xfer)
{
	ehci_softc_t *sc = (ehci_softc_t *)xfer->pipe->device->bus;
	usb_device_request_t *req;
	void *buf = NULL;
	int port, i;
	int s, len, value, index, l, totlen = 0;
	usb_port_status_t ps;
	usb_hub_descriptor_t hubd;
	usb_device_descriptor_t devd;
	usb_config_descriptor_t confd;
	usbd_status err;
	u_int32_t v;

	if (sc->sc_dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & URQ_REQUEST))
		/* XXX panic */
		return (USBD_INVAL);
#endif
	req = &xfer->request;

	DPRINTFN(4,("ehci_root_ctrl_start: type=0x%02x request=%02x\n",
		    req->bmRequestType, req->bRequest));

	len = UGETW(req->wLength);
	value = UGETW(req->wValue);
	index = UGETW(req->wIndex);

	if (len != 0)
		buf = KERNADDR(&xfer->dmabuf, 0);

#define C(x,y) ((x) | ((y) << 8))
	switch(C(req->bRequest, req->bmRequestType)) {
	case C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):
	case C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):
	case C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):
		/*
		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops
		 * for the integrated root hub.
		 */
		break;
	case C(UR_GET_CONFIG, UT_READ_DEVICE):
		if (len > 0) {
			*(u_int8_t *)buf = sc->sc_conf;
			totlen = 1;
		}
		break;
	case C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):
		DPRINTFN(8,("ehci_root_ctrl_start: wValue=0x%04x\n", value));
		if (len == 0)
			break;
		switch(value >> 8) {
		case UDESC_DEVICE:
			if ((value & 0xff) != 0) {
				err = USBD_IOERROR;
				goto ret;
			}
			devd = ehci_devd;
			USETW(devd.idVendor, sc->sc_id_vendor);
			totlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
			memcpy(buf, (void*) &devd, l);
#else
			memcpy(buf, &devd, l);
#endif
			break;
		/*
		 * We can't really operate at another speed, but the spec says
		 * we need this descriptor.
		 */
		case UDESC_DEVICE_QUALIFIER:
			if ((value & 0xff) != 0) {
				err = USBD_IOERROR;
				goto ret;
			}
			totlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
			memcpy(buf, (void*) &ehci_odevd, l);
#else
			memcpy(buf, &ehci_odevd, l);
#endif
			break;
		/*
		 * We can't really operate at another speed, but the spec says
		 * we need this descriptor.
		 */
		case UDESC_OTHER_SPEED_CONFIGURATION:
		case UDESC_CONFIG:
			if ((value & 0xff) != 0) {
				err = USBD_IOERROR;
				goto ret;
			}
			confd = ehci_confd;
			confd.bDescriptorType = value >> 8;
			totlen = l = min(len, USB_CONFIG_DESCRIPTOR_SIZE);
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
			memcpy(buf, (void*) &confd, l);
#else
			memcpy(buf, &confd, l);
#endif
			buf = (char *)buf + l;
			len -= l;
			l = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);
			totlen += l;
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
			memcpy(buf, (void*) &ehci_ifcd, l);
#else
			memcpy(buf, &ehci_ifcd, l);
#endif
			buf = (char *)buf + l;
			len -= l;
			l = min(len, USB_ENDPOINT_DESCRIPTOR_SIZE);
			totlen += l;
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
			memcpy(buf, (void*)&ehci_endpd, l);
#else
			memcpy(buf, &ehci_endpd, l);
#endif
			break;
		case UDESC_STRING:
#define sd ((usb_string_descriptor_t *)buf)
			switch (value & 0xff) {
			case 0: /* Language table */
				totlen = usb_makelangtbl(sd, len);
				break;
			case 1: /* Vendor */
				totlen = usb_makestrdesc(sd, len,
							 sc->sc_vendor);
				break;
			case 2: /* Product */
				totlen = usb_makestrdesc(sd, len,
							 "EHCI root hub");
				break;
			}
#undef sd
			break;
		default:
			err = USBD_IOERROR;
			goto ret;
		}
		break;
	case C(UR_GET_INTERFACE, UT_READ_INTERFACE):
		if (len > 0) {
			*(u_int8_t *)buf = 0;
			totlen = 1;
		}
		break;
	case C(UR_GET_STATUS, UT_READ_DEVICE):
		if (len > 1) {
			USETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);
			totlen = 2;
		}
		break;
	case C(UR_GET_STATUS, UT_READ_INTERFACE):
	case C(UR_GET_STATUS, UT_READ_ENDPOINT):
		if (len > 1) {
			USETW(((usb_status_t *)buf)->wStatus, 0);
			totlen = 2;
		}
		break;
	case C(UR_SET_ADDRESS, UT_WRITE_DEVICE):
		if (value >= USB_MAX_DEVICES) {
			err = USBD_IOERROR;
			goto ret;
		}
		sc->sc_addr = value;
		break;
	case C(UR_SET_CONFIG, UT_WRITE_DEVICE):
		if (value != 0 && value != 1) {
			err = USBD_IOERROR;
			goto ret;
		}
		sc->sc_conf = value;
		break;
	case C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):
		break;
	case C(UR_SET_FEATURE, UT_WRITE_DEVICE):
	case C(UR_SET_FEATURE, UT_WRITE_INTERFACE):
	case C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):
		err = USBD_IOERROR;
		goto ret;
	case C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):
		break;
	case C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):
		break;
	/* Hub requests */
	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_DEVICE):
		break;
	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_OTHER):
		DPRINTFN(4, ("ehci_root_ctrl_start: UR_CLEAR_PORT_FEATURE "
			     "port=%d feature=%d\n",
			     index, value));
		if (index < 1 || index > sc->sc_noport) {
			err = USBD_IOERROR;
			goto ret;
		}
		port = EHCI_PORTSC(index);
		v = EOREAD4(sc, port);
		DPRINTFN(4, ("ehci_root_ctrl_start: portsc=0x%08x\n", v));
		v &= ~EHCI_PS_CLEAR;
		switch(value) {
		case UHF_PORT_ENABLE:
			EOWRITE4(sc, port, v &~ EHCI_PS_PE);
			break;
		case UHF_PORT_SUSPEND:
			if (!(v & EHCI_PS_SUSP)) /* not suspended */
				break;
			v &= ~EHCI_PS_SUSP;
			EOWRITE4(sc, port, v | EHCI_PS_FPR);
			/* see USB2 spec ch. 7.1.7.7 */
			usb_delay_ms(&sc->sc_bus, 20);
			EOWRITE4(sc, port, v);
			usb_delay_ms(&sc->sc_bus, 2);
#ifdef DEBUG
			v = EOREAD4(sc, port);
			if (v & (EHCI_PS_FPR | EHCI_PS_SUSP))
				printf("ehci: resume failed: %x\n", v);
#endif
			break;
		case UHF_PORT_POWER:
			if (sc->sc_hasppc)
				EOWRITE4(sc, port, v &~ EHCI_PS_PP);
			break;
		case UHF_PORT_TEST:
			DPRINTFN(2,("ehci_root_ctrl_start: clear port test "
				    "%d\n", index));
			break;
		case UHF_PORT_INDICATOR:
			DPRINTFN(2,("ehci_root_ctrl_start: clear port ind "
				    "%d\n", index));
			EOWRITE4(sc, port, v &~ EHCI_PS_PIC);
			break;
		case UHF_C_PORT_CONNECTION:
			EOWRITE4(sc, port, v | EHCI_PS_CSC);
			break;
		case UHF_C_PORT_ENABLE:
			EOWRITE4(sc, port, v | EHCI_PS_PEC);
			break;
		case UHF_C_PORT_SUSPEND:
			/* how? */
			break;
		case UHF_C_PORT_OVER_CURRENT:
			EOWRITE4(sc, port, v | EHCI_PS_OCC);
			break;
		case UHF_C_PORT_RESET:
			sc->sc_isreset[index] = 0;
			break;
		default:
			err = USBD_IOERROR;
			goto ret;
		}
#if 0
		switch(value) {
		case UHF_C_PORT_CONNECTION:
		case UHF_C_PORT_ENABLE:
		case UHF_C_PORT_SUSPEND:
		case UHF_C_PORT_OVER_CURRENT:
		case UHF_C_PORT_RESET:
		default:
			break;
		}
#endif
		break;
	case C(UR_GET_DESCRIPTOR, UT_READ_CLASS_DEVICE):
		if (len == 0)
			break;
		if ((value & 0xff) != 0) {
			err = USBD_IOERROR;
			goto ret;
		}
		hubd = ehci_hubd;
		hubd.bNbrPorts = sc->sc_noport;
		v = EOREAD4(sc, EHCI_HCSPARAMS);
		USETW(hubd.wHubCharacteristics,
		    EHCI_HCS_PPC(v) ? UHD_PWR_INDIVIDUAL : UHD_PWR_NO_SWITCH |
		    EHCI_HCS_P_INDICATOR(EREAD4(sc, EHCI_HCSPARAMS))
			? UHD_PORT_IND : 0);
		hubd.bPwrOn2PwrGood = 200; /* XXX can't find out? */
		for (i = 0, l = sc->sc_noport; l > 0; i++, l -= 8, v >>= 8)
			hubd.DeviceRemovable[i++] = 0; /* XXX can't find out? */
		hubd.bDescLength = USB_HUB_DESCRIPTOR_SIZE + i;
		l = min(len, hubd.bDescLength);
		totlen = l;
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
		memcpy(buf, (void*) &hubd, l);
#else
		memcpy(buf, &hubd, l);
#endif
		break;
	case C(UR_GET_STATUS, UT_READ_CLASS_DEVICE):
		if (len != 4) {
			err = USBD_IOERROR;
			goto ret;
		}
		memset(buf, 0, len); /* ? XXX */
		totlen = len;
		break;
	case C(UR_GET_STATUS, UT_READ_CLASS_OTHER):
		DPRINTFN(8,("ehci_root_ctrl_start: get port status i=%d\n",
			    index));
		if (index < 1 || index > sc->sc_noport) {
			err = USBD_IOERROR;
			goto ret;
		}
		if (len != 4) {
			err = USBD_IOERROR;
			goto ret;
		}
		v = EOREAD4(sc, EHCI_PORTSC(index));
		DPRINTFN(8,("ehci_root_ctrl_start: port status=0x%04x\n", v));

		i = UPS_HIGH_SPEED;
		if (sc->sc_flags & EHCIF_ETTF) {
			/*
			 * If we are doing embedded transaction translation,
			 * then directly attached LS/FS devices are reset by
			 * the EHCI controller itself.  PSPD is encoded
			 * the same way as in USBSTATUS. 
			 */
			i = __SHIFTOUT(v, EHCI_PS_PSPD) * UPS_LOW_SPEED;
		}
		if (v & EHCI_PS_CS)	i |= UPS_CURRENT_CONNECT_STATUS;
		if (v & EHCI_PS_PE)	i |= UPS_PORT_ENABLED;
		if (v & EHCI_PS_SUSP)	i |= UPS_SUSPEND;
		if (v & EHCI_PS_OCA)	i |= UPS_OVERCURRENT_INDICATOR;
		if (v & EHCI_PS_PR)	i |= UPS_RESET;
		if (v & EHCI_PS_PP)	i |= UPS_PORT_POWER;
		USETW(ps.wPortStatus, i);
		i = 0;
		if (v & EHCI_PS_CSC)	i |= UPS_C_CONNECT_STATUS;
		if (v & EHCI_PS_PEC)	i |= UPS_C_PORT_ENABLED;
		if (v & EHCI_PS_OCC)	i |= UPS_C_OVERCURRENT_INDICATOR;
		if (sc->sc_isreset[index]) i |= UPS_C_PORT_RESET;
		USETW(ps.wPortChange, i);
		l = min(len, sizeof ps);
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
		memcpy(buf, (void*) &ps, l);
#else
		memcpy(buf, &ps, l);
#endif
		totlen = l;
		break;
	case C(UR_SET_DESCRIPTOR, UT_WRITE_CLASS_DEVICE):
		err = USBD_IOERROR;
		goto ret;
	case C(UR_SET_FEATURE, UT_WRITE_CLASS_DEVICE):
		break;
	case C(UR_SET_FEATURE, UT_WRITE_CLASS_OTHER):
		if (index < 1 || index > sc->sc_noport) {
			err = USBD_IOERROR;
			goto ret;
		}
		port = EHCI_PORTSC(index);
		v = EOREAD4(sc, port);
		DPRINTFN(4, ("ehci_root_ctrl_start: portsc=0x%08x\n", v));
		v &= ~EHCI_PS_CLEAR;
		switch(value) {
		case UHF_PORT_ENABLE:
			EOWRITE4(sc, port, v | EHCI_PS_PE);
			break;
		case UHF_PORT_SUSPEND:
			EOWRITE4(sc, port, v | EHCI_PS_SUSP);
			break;
		case UHF_PORT_RESET:
			DPRINTFN(5,("ehci_root_ctrl_start: reset port %d\n",
				    index));
			if (EHCI_PS_IS_LOWSPEED(v)
			    && sc->sc_ncomp > 0
			    && !(sc->sc_flags & EHCIF_ETTF)) {
				/*
				 * Low speed device on non-ETTF controller or
				 * unaccompanied controller, give up ownership.
				 */
				ehci_disown(sc, index, 1);
				break;
			}
			/* Start reset sequence. */
			v &= ~ (EHCI_PS_PE | EHCI_PS_PR);
			EOWRITE4(sc, port, v | EHCI_PS_PR);
			/* Wait for reset to complete. */
#ifdef __riscos
			/* Use the original BSD delay of 250ms if we have an embedded TT - 50ms doesn't seem to be enough */
			usb_delay_ms(&sc->sc_bus, (sc->sc_flags & EHCIF_ETTF)?250:USB_PORT_ROOT_RESET_DELAY);
#else
			usb_delay_ms(&sc->sc_bus, USB_PORT_ROOT_RESET_DELAY);
#endif
			if (sc->sc_dying) {
				err = USBD_IOERROR;
				goto ret;
			}
			/*
			 * An embedded transaction translater will automatically
			 * terminate the reset sequence so there's no need to
			 * it.
			 */
			v = EOREAD4(sc, port);
			if (v & EHCI_PS_PR) {
				/* Terminate reset sequence. */
				EOWRITE4(sc, port, v & ~EHCI_PS_PR);
				/* Wait for HC to complete reset. */
				usb_delay_ms(&sc->sc_bus,
				    EHCI_PORT_RESET_COMPLETE);
				if (sc->sc_dying) {
					err = USBD_IOERROR;
					goto ret;
				}
			}

			v = EOREAD4(sc, port);
			DPRINTF(("ehci after reset, status=0x%08x\n", v));
			if (v & EHCI_PS_PR) {
				printf("%s: port reset timeout\n",
				       USBDEVNAME(sc->sc_bus.bdev));
				return (USBD_TIMEOUT);
			}
			if (!(v & EHCI_PS_PE)) {
				/* Not a high speed device, give up ownership.*/
				ehci_disown(sc, index, 0);
				break;
			}
			sc->sc_isreset[index] = 1;
			DPRINTF(("ehci port %d reset, status = 0x%08x\n",
				 index, v));
			break;
		case UHF_PORT_POWER:
			DPRINTFN(2,("ehci_root_ctrl_start: set port power "
				    "%d (has PPC = %d)\n", index,
				    sc->sc_hasppc));
			if (sc->sc_hasppc)
				EOWRITE4(sc, port, v | EHCI_PS_PP);
			break;
		case UHF_PORT_TEST:
			DPRINTFN(2,("ehci_root_ctrl_start: set port test "
				    "%d\n", index));
			break;
		case UHF_PORT_INDICATOR:
			DPRINTFN(2,("ehci_root_ctrl_start: set port ind "
				    "%d\n", index));
			EOWRITE4(sc, port, v | EHCI_PS_PIC);
			break;
		default:
			err = USBD_IOERROR;
			goto ret;
		}
		break;
	case C(UR_CLEAR_TT_BUFFER, UT_WRITE_CLASS_OTHER):
	case C(UR_RESET_TT, UT_WRITE_CLASS_OTHER):
	case C(UR_GET_TT_STATE, UT_READ_CLASS_OTHER):
	case C(UR_STOP_TT, UT_WRITE_CLASS_OTHER):
		break;
	default:
		err = USBD_IOERROR;
		goto ret;
	}
	xfer->actlen = totlen;
	err = USBD_NORMAL_COMPLETION;
 ret:
	xfer->status = err;
	s = splusb();
	usb_transfer_complete(xfer);
	splx(s);
	return (USBD_IN_PROGRESS);
}

Static void
ehci_disown(ehci_softc_t *sc, int index, int lowspeed)
{
	int port;
	u_int32_t v;

	DPRINTF(("ehci_disown: index=%d lowspeed=%d\n", index, lowspeed));
#ifdef DIAGNOSTIC
	if (sc->sc_npcomp != 0) {
		int i = (index-1) / sc->sc_npcomp;
		if (i >= sc->sc_ncomp)
			printf("%s: strange port\n",
			       USBDEVNAME(sc->sc_bus.bdev));
		else
#ifdef __riscos
			printf("%s: handing over %s speed device on "
			       "port %d to %d\n",
			       USBDEVNAME(sc->sc_bus.bdev),
			       lowspeed ? "low" : "full",
			       index, i);
#else
			printf("%s: handing over %s speed device on "
			       "port %d to %s\n",
			       device_xname(sc->sc_dev),
			       lowspeed ? "low" : "full",
			       index, device_xname(sc->sc_comps[i]));
#endif
	} else {
		printf("%s: npcomp == 0\n", USBDEVNAME(sc->sc_bus.bdev));
	}
#endif
	port = EHCI_PORTSC(index);
	v = EOREAD4(sc, port) &~ EHCI_PS_CLEAR;
	EOWRITE4(sc, port, v | EHCI_PS_PO);
}

/* Abort a root control request. */
Static void
ehci_root_ctrl_abort(usbd_xfer_handle xfer)
{
	/* Nothing to do, all transfers are synchronous. */
}

/* Close the root pipe. */
Static void
ehci_root_ctrl_close(usbd_pipe_handle pipe)
{
	DPRINTF(("ehci_root_ctrl_close\n"));
	/* Nothing to do. */
}

Static void
ehci_root_intr_done(usbd_xfer_handle xfer)
{
	xfer->hcpriv = NULL;
}

Static usbd_status
ehci_root_intr_transfer(usbd_xfer_handle xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ehci_root_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

Static usbd_status
ehci_root_intr_start(usbd_xfer_handle xfer)
{
	usbd_pipe_handle pipe = xfer->pipe;
	ehci_softc_t *sc = (ehci_softc_t *)pipe->device->bus;

	if (sc->sc_dying)
		return (USBD_IOERROR);

	sc->sc_intrxfer = xfer;

	return (USBD_IN_PROGRESS);
}

/* Abort a root interrupt request. */
Static void
ehci_root_intr_abort(usbd_xfer_handle xfer)
{
	int s;

	if (xfer->pipe->intrxfer == xfer) {
		DPRINTF(("ehci_root_intr_abort: remove\n"));
		xfer->pipe->intrxfer = NULL;
	}
	xfer->status = USBD_CANCELLED;
	s = splusb();
	usb_transfer_complete(xfer);
	splx(s);
}

/* Close the root pipe. */
Static void
ehci_root_intr_close(usbd_pipe_handle pipe)
{
	ehci_softc_t *sc = (ehci_softc_t *)pipe->device->bus;

	DPRINTF(("ehci_root_intr_close\n"));

	sc->sc_intrxfer = NULL;
}

Static void
ehci_root_ctrl_done(usbd_xfer_handle xfer)
{
	xfer->hcpriv = NULL;
}

/************************/

Static ehci_soft_qh_t *
ehci_alloc_sqh(ehci_softc_t *sc)
{
	ehci_soft_qh_t *sqh;
	usbd_status err;
	int i, offs;
	usb_dma_t dma;

	if (sc->sc_freeqhs == NULL) {
		DPRINTFN(2, ("ehci_alloc_sqh: allocating chunk\n"));
		err = usb_allocmem(&sc->sc_bus, EHCI_SQH_SIZE * EHCI_SQH_CHUNK,
			  EHCI_SMALL_PAGE_SIZE, &dma);
#ifdef EHCI_DEBUG
		if (err)
			printf("ehci_alloc_sqh: usb_allocmem()=%d\n", err);
#endif
		if (err)
			return (NULL);
		for(i = 0; i < EHCI_SQH_CHUNK; i++) {
			offs = i * EHCI_SQH_SIZE;
			sqh = KERNADDR(&dma, offs);
			sqh->physaddr = DMAADDR(&dma, offs);
			sqh->dma = dma;
			sqh->offs = offs;
			sqh->next = sc->sc_freeqhs;
			sc->sc_freeqhs = sqh;
		}
	}
	sqh = sc->sc_freeqhs;
	sc->sc_freeqhs = sqh->next;
	memset(&sqh->qh, 0, sizeof(ehci_qh_t));
	sqh->next = NULL;
	return (sqh);
}

Static void
ehci_free_sqh(ehci_softc_t *sc, ehci_soft_qh_t *sqh)
{
	sqh->next = sc->sc_freeqhs;
	sc->sc_freeqhs = sqh;
}

Static ehci_soft_qtd_t *
ehci_alloc_sqtd(ehci_softc_t *sc)
{
	ehci_soft_qtd_t *sqtd;
	usbd_status err;
	int i, offs;
	usb_dma_t dma;
	int s;

	if (sc->sc_freeqtds == NULL) {
		DPRINTFN(2, ("ehci_alloc_sqtd: allocating chunk\n"));
		err = usb_allocmem(&sc->sc_bus, EHCI_SQTD_SIZE*EHCI_SQTD_CHUNK,
			  EHCI_SMALL_PAGE_SIZE, &dma);
#ifdef EHCI_DEBUG
		if (err)
			printf("ehci_alloc_sqtd: usb_allocmem()=%d\n", err);
#endif
		if (err)
			return (NULL);
		s = splusb();
		for(i = 0; i < EHCI_SQTD_CHUNK; i++) {
			offs = i * EHCI_SQTD_SIZE;
			sqtd = KERNADDR(&dma, offs);
			sqtd->physaddr = DMAADDR(&dma, offs);
			sqtd->dma = dma;
			sqtd->offs = offs;
			sqtd->nextqtd = sc->sc_freeqtds;
			sc->sc_freeqtds = sqtd;
		}
		splx(s);
	}

	s = splusb();
	sqtd = sc->sc_freeqtds;
	sc->sc_freeqtds = sqtd->nextqtd;
	memset(&sqtd->qtd, 0, sizeof(ehci_qtd_t));
	sqtd->nextqtd = NULL;
	sqtd->xfer = NULL;
	splx(s);

	return (sqtd);
}

Static void
ehci_free_sqtd(ehci_softc_t *sc, ehci_soft_qtd_t *sqtd)
{
	int s;

	s = splusb();
	sqtd->nextqtd = sc->sc_freeqtds;
	sc->sc_freeqtds = sqtd;
	splx(s);
}

Static usbd_status
ehci_alloc_sqtd_chain(struct ehci_pipe *epipe, ehci_softc_t *sc,
		     int alen, int rd, usbd_xfer_handle xfer,
		     ehci_soft_qtd_t **sp, ehci_soft_qtd_t **ep)
{
	ehci_soft_qtd_t *next, *cur;
	ehci_physaddr_t dataphys, dataphyspage, dataphyslastpage, nextphys;
	u_int32_t qtdstatus;
	int len, curlen, mps;
	int i, tog;
	usb_dma_t *dma = &xfer->dmabuf;
	u_int16_t flags = xfer->flags;

	DPRINTFN(alen<4*4096,("ehci_alloc_sqtd_chain: start len=%d\n", alen));

	len = alen;
	dataphys = DMAADDR(dma, 0);
	dataphyslastpage = EHCI_PAGE(dataphys + len - 1);
	qtdstatus = EHCI_QTD_ACTIVE |
	    EHCI_QTD_SET_PID(rd ? EHCI_QTD_PID_IN : EHCI_QTD_PID_OUT) |
	    EHCI_QTD_SET_CERR(3)
	    /* IOC set below */
	    /* BYTES set below */
	    ;
	mps = UGETW(epipe->pipe.endpoint->edesc->wMaxPacketSize);
	tog = epipe->nexttoggle;
	qtdstatus |= EHCI_QTD_SET_TOGGLE(tog);

	cur = ehci_alloc_sqtd(sc);
	*sp = cur;
	if (cur == NULL)
		goto nomem;

	usb_syncmem(dma, 0, alen,
	    rd ? BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
	for (;;) {
		dataphyspage = EHCI_PAGE(dataphys);
		/* The EHCI hardware can handle at most 5 pages. */
		if (dataphyslastpage - dataphyspage <
		    EHCI_QTD_NBUFFERS * EHCI_PAGE_SIZE) {
			/* we can handle it in this QTD */
			curlen = len;
		} else {
			/* must use multiple TDs, fill as much as possible. */
			curlen = EHCI_QTD_NBUFFERS * EHCI_PAGE_SIZE -
				 EHCI_PAGE_OFFSET(dataphys);
#ifdef DIAGNOSTIC
			if (curlen > len) {
				printf("ehci_alloc_sqtd_chain: curlen=0x%x "
				       "len=0x%x offs=0x%x\n", curlen, len,
				       EHCI_PAGE_OFFSET(dataphys));
				printf("lastpage=0x%x page=0x%x phys=0x%x\n",
				       dataphyslastpage, dataphyspage,
				       dataphys);
				curlen = len;
			}
#endif
			/* the length must be a multiple of the max size */
			curlen -= curlen % mps;
			DPRINTFN(1,("ehci_alloc_sqtd_chain: multiple QTDs, "
				    "curlen=%d\n", curlen));
#ifdef DIAGNOSTIC
			if (curlen == 0)
				panic("ehci_alloc_sqtd_chain: curlen == 0");
#endif
		}
		DPRINTFN(4,("ehci_alloc_sqtd_chain: dataphys=0x%08x "
			    "dataphyslastpage=0x%08x len=%d curlen=%d\n",
			    dataphys, dataphyslastpage,
			    len, curlen));
		len -= curlen;

		/*
		 * Allocate another transfer if there's more data left,
		 * or if force last short transfer flag is set and we're
		 * allocating a multiple of the max packet size.
		 */
		if (len != 0 ||
		    ((curlen % mps) == 0 && !rd && curlen != 0 &&
		     (flags & USBD_FORCE_SHORT_XFER))) {
			next = ehci_alloc_sqtd(sc);
			if (next == NULL)
				goto nomem;
			nextphys = htole32(next->physaddr);
		} else {
			next = NULL;
			nextphys = EHCI_NULL;
		}

		for (i = 0; i * EHCI_PAGE_SIZE <
		            curlen + EHCI_PAGE_OFFSET(dataphys); i++) {
			ehci_physaddr_t a = dataphys + i * EHCI_PAGE_SIZE;
			if (i != 0) /* use offset only in first buffer */
				a = EHCI_PAGE(a);
			cur->qtd.qtd_buffer[i] = htole32(a);
			cur->qtd.qtd_buffer_hi[i] = 0;
#ifdef DIAGNOSTIC
			if (i >= EHCI_QTD_NBUFFERS) {
				printf("ehci_alloc_sqtd_chain: i=%d\n", i);
				goto nomem;
			}
#endif
		}
		cur->nextqtd = next;
		cur->qtd.qtd_next = cur->qtd.qtd_altnext = nextphys;
		cur->qtd.qtd_status =
		    htole32(qtdstatus | EHCI_QTD_SET_BYTES(curlen));
		cur->xfer = xfer;
		cur->len = curlen;

		DPRINTFN(10,("ehci_alloc_sqtd_chain: cbp=0x%08x end=0x%08x\n",
			    dataphys, dataphys + curlen));
		/* adjust the toggle based on the number of packets in this
		   qtd */
		if (((curlen + mps - 1) / mps) & 1) {
			tog ^= 1;
			qtdstatus ^= EHCI_QTD_TOGGLE_MASK;
		}
		if (next == NULL)
			break;
		usb_syncmem(&cur->dma, cur->offs, sizeof(cur->qtd),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
		DPRINTFN(10,("ehci_alloc_sqtd_chain: extend chain\n"));
		if (len)
			dataphys += curlen;
		cur = next;
	}
	cur->qtd.qtd_status |= htole32(EHCI_QTD_IOC);
	usb_syncmem(&cur->dma, cur->offs, sizeof(cur->qtd),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	*ep = cur;
	epipe->nexttoggle = tog;

	DPRINTFN(10,("ehci_alloc_sqtd_chain: return sqtd=%p sqtdend=%p\n",
		     *sp, *ep));

	return (USBD_NORMAL_COMPLETION);

 nomem:
	/* XXX free chain */
	DPRINTFN(-1,("ehci_alloc_sqtd_chain: no memory\n"));
	return (USBD_NOMEM);
}

Static void
ehci_free_sqtd_chain(ehci_softc_t *sc, ehci_soft_qtd_t *sqtd,
		    ehci_soft_qtd_t *sqtdend)
{
	ehci_soft_qtd_t *p;
	int i;

	DPRINTFN(10,("ehci_free_sqtd_chain: sqtd=%p sqtdend=%p\n",
		     sqtd, sqtdend));

	for (i = 0; sqtd != sqtdend; sqtd = p, i++) {
		p = sqtd->nextqtd;
		ehci_free_sqtd(sc, sqtd);
	}
}

Static ehci_soft_itd_t *
ehci_alloc_itd(ehci_softc_t *sc)
{
	struct ehci_soft_itd *itd, *freeitd;
	usbd_status err;
	int i, s, offs, frindex, previndex;
	usb_dma_t dma;

	s = splusb();

	/* Find an itd that wasn't freed this frame or last frame. This can
	 * discard itds that were freed before frindex wrapped around
	 * XXX - can this lead to thrashing? Could fix by enabling wrap-around
	 *       interrupt and fiddling with list when that happens */
	frindex = (EOREAD4(sc, EHCI_FRINDEX) + 1) >> 3;
	previndex = (frindex != 0) ? frindex - 1 : sc->sc_flsize;

	freeitd = NULL;
	LIST_FOREACH(itd, &sc->sc_freeitds, u.free_list) {
		if (itd == NULL)
			break;
		if (itd->slot != frindex && itd->slot != previndex) {
			freeitd = itd;
			break;
		}
	}

	if (freeitd == NULL) {
		DPRINTFN(2, ("ehci_alloc_itd allocating chunk\n"));
		err = usb_allocmem(&sc->sc_bus, EHCI_ITD_SIZE * EHCI_ITD_CHUNK,
				EHCI_SMALL_PAGE_SIZE, &dma);

		if (err) {
			DPRINTF(("ehci_alloc_itd, alloc returned %d\n", err));
			return NULL;
		}

		for (i = 0; i < EHCI_ITD_CHUNK; i++) {
			offs = i * EHCI_ITD_SIZE;
			itd = KERNADDR(&dma, offs);
			itd->physaddr = DMAADDR(&dma, offs);
	 		itd->dma = dma;
			itd->offs = offs;
			LIST_INSERT_HEAD(&sc->sc_freeitds, itd, u.free_list);
		}
		freeitd = LIST_FIRST(&sc->sc_freeitds);
	}

	itd = freeitd;
	LIST_REMOVE(itd, u.free_list);
	memset(&itd->itd, 0, sizeof(ehci_itd_t));
	usb_syncmem(&itd->dma, itd->offs + offsetof(ehci_itd_t, itd_next),
                    sizeof(itd->itd.itd_next), BUS_DMASYNC_PREWRITE |
                    BUS_DMASYNC_PREREAD);

	itd->u.frame_list.next = NULL;
	itd->u.frame_list.prev = NULL;
	itd->xfer_next = NULL;
	itd->slot = 0;
	splx(s);

	return itd;
}

Static void
ehci_free_itd(ehci_softc_t *sc, ehci_soft_itd_t *itd)
{
	int s;

	s = splusb();
	LIST_INSERT_HEAD(&sc->sc_freeitds, itd, u.free_list);
	splx(s);
}

/****************/

/*
 * Close a reqular pipe.
 * Assumes that there are no pending transactions.
 */
Static void
ehci_close_pipe(usbd_pipe_handle pipe, ehci_soft_qh_t *head)
{
	struct ehci_pipe *epipe = (struct ehci_pipe *)pipe;
	ehci_softc_t *sc = (ehci_softc_t *)pipe->device->bus;
	ehci_soft_qh_t *sqh = epipe->sqh;
	int s;

	s = splusb();
	ehci_rem_qh(sc, sqh, head);
	splx(s);
	ehci_free_sqh(sc, epipe->sqh);
}

/*
 * Abort a device request.
 * If this routine is called at splusb() it guarantees that the request
 * will be removed from the hardware scheduling and that the callback
 * for it will be called with USBD_CANCELLED status.
 * It's impossible to guarantee that the requested transfer will not
 * have happened since the hardware runs concurrently.
 * If the transaction has already happened we rely on the ordinary
 * interrupt processing to process it.
 * XXX This is most probably wrong.
 */
Static void
ehci_abort_xfer(usbd_xfer_handle xfer, usbd_status status)
{
#define exfer EXFER(xfer)
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
	ehci_softc_t *sc = (ehci_softc_t *)epipe->pipe.device->bus;
	ehci_soft_qh_t *sqh = epipe->sqh;
	ehci_soft_qtd_t *sqtd;
	ehci_physaddr_t cur;
	u_int32_t qhstatus;
	int s;
	int hit;
	int wake;

	DPRINTF(("ehci_abort_xfer: xfer=%p pipe=%p\n", xfer, epipe));

	if (sc->sc_dying) {
		/* If we're dying, just do the software part. */
		s = splusb();
		xfer->status = status;	/* make software ignore it */
		callout_stop(&(xfer->timeout_handle));
		usb_transfer_complete(xfer);
		splx(s);
		return;
	}

#ifndef __riscos
	if (xfer->device->bus->intr_context)
		panic("ehci_abort_xfer: not in process context");
#endif

	/*
	 * If an abort is already in progress then just wait for it to
	 * complete and return.
	 */
	if (xfer->hcflags & UXFER_ABORTING) {
		DPRINTFN(2, ("ehci_abort_xfer: already aborting\n"));
#ifdef DIAGNOSTIC
		if (status == USBD_TIMEOUT)
			printf("ehci_abort_xfer: TIMEOUT while aborting\n");
#endif
		/* Override the status which might be USBD_TIMEOUT. */
		xfer->status = status;
		DPRINTFN(2, ("ehci_abort_xfer: waiting for abort to finish\n"));
		xfer->hcflags |= UXFER_ABORTWAIT;
		while (xfer->hcflags & UXFER_ABORTING)
#ifdef __riscos
			tsleep(&xfer->hcflags, PZERO, "ehciaw", 0, 1);
#else
			tsleep(&xfer->hcflags, PZERO, "ehciaw", 0);
#endif
		return;
	}
	xfer->hcflags |= UXFER_ABORTING;

	/*
	 * Step 1: Make interrupt routine and hardware ignore xfer.
	 */
	s = splusb();
	xfer->status = status;	/* make software ignore it */
	callout_stop(&(xfer->timeout_handle));

	usb_syncmem(&sqh->dma,
	    sqh->offs + offsetof(ehci_qh_t, qh_qtd.qtd_status),
	    sizeof(sqh->qh.qh_qtd.qtd_status),
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
	qhstatus = sqh->qh.qh_qtd.qtd_status;
	sqh->qh.qh_qtd.qtd_status = qhstatus | htole32(EHCI_QTD_HALTED);
	usb_syncmem(&sqh->dma,
	    sqh->offs + offsetof(ehci_qh_t, qh_qtd.qtd_status),
	    sizeof(sqh->qh.qh_qtd.qtd_status),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	for (sqtd = exfer->sqtdstart; 
#ifdef __riscos
	sqtd
#endif
	; sqtd = sqtd->nextqtd) {
		usb_syncmem(&sqtd->dma,
		    sqtd->offs + offsetof(ehci_qtd_t, qtd_status),
		    sizeof(sqtd->qtd.qtd_status),
		    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
		sqtd->qtd.qtd_status |= htole32(EHCI_QTD_HALTED);
		usb_syncmem(&sqtd->dma,
		    sqtd->offs + offsetof(ehci_qtd_t, qtd_status),
		    sizeof(sqtd->qtd.qtd_status),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
		if (sqtd == exfer->sqtdend)
			break;
	}
	splx(s);

	/*
	 * Step 2: Wait until we know hardware has finished any possible
	 * use of the xfer.  Also make sure the soft interrupt routine
	 * has run.
	 */
	ehci_sync_hc(sc);
	s = splusb();
#ifdef USB_USE_SOFTINTR
	sc->sc_softwake = 1;
#endif /* USB_USE_SOFTINTR */
#if defined (__riscos) && !defined(USB_USE_SOFTINTR)
        ehci_softintr(&sc->sc_bus);
//      tsleep(&sc->sc_softwake, PZERO, "ehciab", 0, 1);
#else
	usb_schedsoftintr(&sc->sc_bus);
#endif
#ifdef USB_USE_SOFTINTR
#ifdef __riscos
	tsleep(&sc->sc_softwake, PZERO, "ehciab", 0, 1);
#else
	tsleep(&sc->sc_softwake, PZERO, "ehciab", 0);
#endif
#endif /* USB_USE_SOFTINTR */
	splx(s);

	/*
	 * Step 3: Remove any vestiges of the xfer from the hardware.
	 * The complication here is that the hardware may have executed
	 * beyond the xfer we're trying to abort.  So as we're scanning
	 * the TDs of this xfer we check if the hardware points to
	 * any of them.
	 */
	s = splusb();		/* XXX why? */

	usb_syncmem(&sqh->dma,
	    sqh->offs + offsetof(ehci_qh_t, qh_curqtd),
	    sizeof(sqh->qh.qh_curqtd),
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
	cur = EHCI_LINK_ADDR(le32toh(sqh->qh.qh_curqtd));
	hit = 0;
	for (sqtd = exfer->sqtdstart; ; sqtd = sqtd->nextqtd) {
		hit |= cur == sqtd->physaddr;
		if (sqtd == exfer->sqtdend)
			break;
	}
	sqtd = sqtd->nextqtd;
	/* Zap curqtd register if hardware pointed inside the xfer. */
	if (hit && sqtd != NULL) {
		DPRINTFN(1,("ehci_abort_xfer: cur=0x%08x\n", sqtd->physaddr));
		sqh->qh.qh_curqtd = htole32(sqtd->physaddr); /* unlink qTDs */
		usb_syncmem(&sqh->dma,
		    sqh->offs + offsetof(ehci_qh_t, qh_curqtd),
		    sizeof(sqh->qh.qh_curqtd),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
		sqh->qh.qh_qtd.qtd_status = qhstatus;
		usb_syncmem(&sqh->dma,
		    sqh->offs + offsetof(ehci_qh_t, qh_qtd.qtd_status),
		    sizeof(sqh->qh.qh_qtd.qtd_status),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	} else {
		DPRINTFN(1,("ehci_abort_xfer: no hit\n"));
	}

	/*
	 * Step 4: Execute callback.
	 */
#ifdef DIAGNOSTIC
	exfer->isdone = 1;
#endif
	wake = xfer->hcflags & UXFER_ABORTWAIT;
	xfer->hcflags &= ~(UXFER_ABORTING | UXFER_ABORTWAIT);
	usb_transfer_complete(xfer);
	if (wake)
		wakeup(&xfer->hcflags);

	splx(s);
#undef exfer
}

Static void
ehci_abort_isoc_xfer(usbd_xfer_handle xfer, usbd_status status)
{
	ehci_isoc_trans_t trans_status;
	struct ehci_pipe *epipe;
	struct ehci_xfer *exfer;
	ehci_softc_t *sc;
	struct ehci_soft_itd *itd;
	int s, i, wake;

	epipe = (struct ehci_pipe *) xfer->pipe;
	exfer = EXFER(xfer);
	sc = (ehci_softc_t *)epipe->pipe.device->bus;

	DPRINTF(("ehci_abort_isoc_xfer: xfer %p pipe %p\n", xfer, epipe));

	if (sc->sc_dying) {
		s = splusb();
		xfer->status = status;
		callout_stop(&(xfer->timeout_handle));
		usb_transfer_complete(xfer);
		splx(s);
		return;
	}

	if (xfer->hcflags & UXFER_ABORTING) {
		DPRINTFN(2, ("ehci_abort_isoc_xfer: already aborting\n"));

#ifdef DIAGNOSTIC
		if (status == USBD_TIMEOUT)
			printf("ehci_abort_xfer: TIMEOUT while aborting\n");
#endif

		xfer->status = status;
		DPRINTFN(2, ("ehci_abort_xfer: waiting for abort to finish\n"));
		xfer->hcflags |= UXFER_ABORTWAIT;
		while (xfer->hcflags & UXFER_ABORTING)
#ifdef __riscos
			tsleep(&xfer->hcflags, PZERO, "ehciiaw", 0, 1);
#else
			tsleep(&xfer->hcflags, PZERO, "ehciiaw", 0);
#endif
		return;
	}
	xfer->hcflags |= UXFER_ABORTING;

	xfer->status = status;
	callout_stop(&(xfer->timeout_handle));

	s = splusb();
	for (itd = exfer->itdstart; itd != NULL; itd = itd->xfer_next) {
		usb_syncmem(&itd->dma,
		    itd->offs + offsetof(ehci_itd_t, itd_ctl),
		    sizeof(itd->itd.itd_ctl),
		    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);

		for (i = 0; i < 8; i++) {
			trans_status = le32toh(itd->itd.itd_ctl[i]);
			trans_status &= ~EHCI_ITD_ACTIVE;
			itd->itd.itd_ctl[i] = htole32(trans_status);
		}

		usb_syncmem(&itd->dma,
		    itd->offs + offsetof(ehci_itd_t, itd_ctl),
		    sizeof(itd->itd.itd_ctl),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	splx(s);

        s = splusb();
#ifdef USB_USE_SOFTINTR
        sc->sc_softwake = 1;
#endif /* USB_USE_SOFTINTR */
        usb_schedsoftintr(&sc->sc_bus);
#ifdef USB_USE_SOFTINTR
#ifdef __riscos
        tsleep(&sc->sc_softwake, PZERO, "ehciab", 0, 1);
#else
        tsleep(&sc->sc_softwake, PZERO, "ehciab", 0);
#endif
#endif /* USB_USE_SOFTINTR */
        splx(s);

#ifdef DIAGNOSTIC
	exfer->isdone = 1;
#endif
	wake = xfer->hcflags & UXFER_ABORTWAIT;
	xfer->hcflags &= ~(UXFER_ABORTING | UXFER_ABORTWAIT);
	usb_transfer_complete(xfer);
	if (wake)
		wakeup(&xfer->hcflags);

	return;
}

Static void
ehci_timeout(void *addr)
{
	struct ehci_xfer *exfer = addr;
	struct ehci_pipe *epipe = (struct ehci_pipe *)exfer->xfer.pipe;
	ehci_softc_t *sc = (ehci_softc_t *)epipe->pipe.device->bus;

	DPRINTF(("ehci_timeout: exfer=%p\n", exfer));
#if defined(EHCI_DEBUG) && !defined(__riscos)
	if (ehcidebug > 1)
		usbd_dump_pipe(exfer->xfer.pipe);
#endif

	if (sc->sc_dying) {
		ehci_abort_xfer(&exfer->xfer, USBD_TIMEOUT);
		return;
	}

	/* Execute the abort in a process context. */
#ifdef __riscos
        riscos_abort_pipe (addr);
#else
	usb_init_task(&exfer->abort_task, ehci_timeout_task, addr);
	usb_add_task(exfer->xfer.pipe->device, &exfer->abort_task,
	    USB_TASKQ_HC);
#endif
}

Static void
ehci_timeout_task(void *addr)
{
	usbd_xfer_handle xfer = addr;
	int s;

	DPRINTF(("ehci_timeout_task: xfer=%p\n", xfer));

	s = splusb();
	ehci_abort_xfer(xfer, USBD_TIMEOUT);
	splx(s);
}

/************************/

Static usbd_status
ehci_device_ctrl_transfer(usbd_xfer_handle xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ehci_device_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

Static usbd_status
ehci_device_ctrl_start(usbd_xfer_handle xfer)
{
	ehci_softc_t *sc = (ehci_softc_t *)xfer->pipe->device->bus;
	usbd_status err;

	if (sc->sc_dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & URQ_REQUEST)) {
		/* XXX panic */
		printf("ehci_device_ctrl_transfer: not a request\n");
		return (USBD_INVAL);
	}
#endif

	err = ehci_device_request(xfer);
	if (err)
		return (err);

	if (sc->sc_bus.use_polling)
		ehci_waitintr(sc, xfer);
	return (USBD_IN_PROGRESS);
}

Static void
ehci_device_ctrl_done(usbd_xfer_handle xfer)
{
	struct ehci_xfer *ex = EXFER(xfer);
	ehci_softc_t *sc = (ehci_softc_t *)xfer->pipe->device->bus;
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
	usb_device_request_t *req = &xfer->request;
	int len = UGETW(req->wLength);
	int rd = req->bmRequestType & UT_READ;

	DPRINTFN(10,("ehci_ctrl_done: xfer=%p\n", xfer));

#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & URQ_REQUEST)) {
		panic("ehci_ctrl_done: not a request");
	}
#endif

	mutex_enter(&sc->sc_intrhead_lock);
#ifdef __riscos
	int s = splusb(); /* No mutexes, so just disable IRQs */
#endif
	if (xfer->status != USBD_NOMEM && ehci_active_intr_list(ex)) {
		ehci_del_intr_list(sc, ex);	/* remove from active list */
		ehci_free_sqtd_chain(sc, ex->sqtdstart, NULL);
		usb_syncmem(&epipe->u.ctl.reqdma, 0, sizeof *req,
		    BUS_DMASYNC_POSTWRITE);
		if (len)
			usb_syncmem(&xfer->dmabuf, 0, len,
			    rd ? BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
	}
	mutex_exit(&sc->sc_intrhead_lock);
#ifdef __riscos
	splx(s);
#endif

	DPRINTFN(5, ("ehci_ctrl_done: length=%d\n", xfer->actlen));
}

/* Abort a device control request. */
Static void
ehci_device_ctrl_abort(usbd_xfer_handle xfer)
{
	DPRINTF(("ehci_device_ctrl_abort: xfer=%p\n", xfer));
	ehci_abort_xfer(xfer, USBD_CANCELLED);
}

/* Close a device control pipe. */
Static void
ehci_device_ctrl_close(usbd_pipe_handle pipe)
{
	ehci_softc_t *sc = (ehci_softc_t *)pipe->device->bus;
	/*struct ehci_pipe *epipe = (struct ehci_pipe *)pipe;*/

	DPRINTF(("ehci_device_ctrl_close: pipe=%p\n", pipe));
	ehci_close_pipe(pipe, sc->sc_async_head);
}

Static usbd_status
ehci_device_request(usbd_xfer_handle xfer)
{
#define exfer EXFER(xfer)
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
	usb_device_request_t *req = &xfer->request;
	usbd_device_handle dev = epipe->pipe.device;
	ehci_softc_t *sc = (ehci_softc_t *)dev->bus;
	int addr = dev->address;
	ehci_soft_qtd_t *setup, *stat, *next;
	ehci_soft_qh_t *sqh;
	int isread;
	int len;
	usbd_status err;
	int s;

	isread = req->bmRequestType & UT_READ;
	len = UGETW(req->wLength);

	DPRINTFN(3,("ehci_device_request: type=0x%02x, request=0x%02x, "
		    "wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\n",
		    req->bmRequestType, req->bRequest, UGETW(req->wValue),
		    UGETW(req->wIndex), len, addr,
		    epipe->pipe.endpoint->edesc->bEndpointAddress));

	setup = ehci_alloc_sqtd(sc);
	if (setup == NULL) {
		err = USBD_NOMEM;
		goto bad1;
	}
	stat = ehci_alloc_sqtd(sc);
	if (stat == NULL) {
		err = USBD_NOMEM;
		goto bad2;
	}

	sqh = epipe->sqh;
	epipe->u.ctl.length = len;

	/* Update device address and length since they may have changed
	   during the setup of the control pipe in usbd_new_device(). */
	/* XXX This only needs to be done once, but it's too early in open. */
	/* XXXX Should not touch ED here! */
	sqh->qh.qh_endp =
	    (sqh->qh.qh_endp & htole32(~(EHCI_QH_ADDRMASK | EHCI_QH_MPLMASK))) |
	    htole32(
	     EHCI_QH_SET_ADDR(addr) |
	     EHCI_QH_SET_MPL(UGETW(epipe->pipe.endpoint->edesc->wMaxPacketSize))
	    );

	/* Set up data transaction */
	if (len != 0) {
		ehci_soft_qtd_t *end;

		/* Start toggle at 1. */
		epipe->nexttoggle = 1;
		err = ehci_alloc_sqtd_chain(epipe, sc, len, isread, xfer,
			  &next, &end);
		if (err)
			goto bad3;
		end->qtd.qtd_status &= htole32(~EHCI_QTD_IOC);
		end->nextqtd = stat;
		end->qtd.qtd_next =
		end->qtd.qtd_altnext = htole32(stat->physaddr);
		usb_syncmem(&end->dma, end->offs, sizeof(end->qtd),
		   BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	} else {
		next = stat;
	}

#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
	memcpy(KERNADDR(&epipe->u.ctl.reqdma, 0), (void*) req, sizeof *req);
#else
	memcpy(KERNADDR(&epipe->u.ctl.reqdma, 0), req, sizeof *req);
#endif
	usb_syncmem(&epipe->u.ctl.reqdma, 0, sizeof *req, BUS_DMASYNC_PREWRITE);

	/* Clear toggle */
	setup->qtd.qtd_status = htole32(
	    EHCI_QTD_ACTIVE |
	    EHCI_QTD_SET_PID(EHCI_QTD_PID_SETUP) |
	    EHCI_QTD_SET_CERR(3) |
	    EHCI_QTD_SET_TOGGLE(0) |
	    EHCI_QTD_SET_BYTES(sizeof *req)
	    );
	setup->qtd.qtd_buffer[0] = htole32(DMAADDR(&epipe->u.ctl.reqdma, 0));
	setup->qtd.qtd_buffer_hi[0] = 0;
	setup->nextqtd = next;
	setup->qtd.qtd_next = setup->qtd.qtd_altnext = htole32(next->physaddr);
	setup->xfer = xfer;
	setup->len = sizeof *req;
	usb_syncmem(&setup->dma, setup->offs, sizeof(setup->qtd),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	stat->qtd.qtd_status = htole32(
	    EHCI_QTD_ACTIVE |
	    EHCI_QTD_SET_PID(isread ? EHCI_QTD_PID_OUT : EHCI_QTD_PID_IN) |
	    EHCI_QTD_SET_CERR(3) |
	    EHCI_QTD_SET_TOGGLE(1) |
	    EHCI_QTD_IOC
	    );
	stat->qtd.qtd_buffer[0] = 0; /* XXX not needed? */
	stat->qtd.qtd_buffer_hi[0] = 0; /* XXX not needed? */
	stat->nextqtd = NULL;
	stat->qtd.qtd_next = stat->qtd.qtd_altnext = EHCI_NULL;
	stat->xfer = xfer;
	stat->len = 0;
	usb_syncmem(&stat->dma, stat->offs, sizeof(stat->qtd),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

#ifdef EHCI_DEBUG
	if (ehcidebug > 5) {
		DPRINTF(("ehci_device_request:\n"));
		ehci_dump_sqh(sqh);
		ehci_dump_sqtds(setup);
	}
#endif

	exfer->sqtdstart = setup;
	exfer->sqtdend = stat;
#ifdef DIAGNOSTIC
	if (!exfer->isdone) {
		printf("ehci_device_request: not done, exfer=%p\n", exfer);
	}
	exfer->isdone = 0;
#endif

	/* Insert qTD in QH list. */
	s = splusb();
	ehci_set_qh_qtd(sqh, setup); /* also does usb_syncmem(sqh) */
	if (xfer->timeout && !sc->sc_bus.use_polling) {
#ifdef __riscos
		callout_reset(&(xfer->timeout_handle), (MS_TO_TICKS(xfer->timeout)),
		    (ehci_timeout), (xfer));
#else
		callout_reset(&(xfer->timeout_handle), (mstohz(xfer->timeout)),
		    (ehci_timeout), (xfer));
#endif
	}
	mutex_enter(&sc->sc_intrhead_lock);
	ehci_add_intr_list(sc, exfer);
	mutex_exit(&sc->sc_intrhead_lock);
	xfer->status = USBD_IN_PROGRESS;
	splx(s);

#ifdef EHCI_DEBUG
	if (ehcidebug > 10) {
		DPRINTF(("ehci_device_request: status=%x\n",
			 EOREAD4(sc, EHCI_USBSTS)));
		delay(10000);
		ehci_dump_regs(sc);
		ehci_dump_sqh(sc->sc_async_head);
		ehci_dump_sqh(sqh);
		ehci_dump_sqtds(setup);
	}
#endif

	return (USBD_NORMAL_COMPLETION);

 bad3:
	ehci_free_sqtd(sc, stat);
 bad2:
	ehci_free_sqtd(sc, setup);
 bad1:
	DPRINTFN(-1,("ehci_device_request: no memory\n"));
	xfer->status = err;
	usb_transfer_complete(xfer);
	return (err);
#undef exfer
}

/*
 * Some EHCI chips from VIA seem to trigger interrupts before writing back the
 * qTD status, or miss signalling occasionally under heavy load.  If the host
 * machine is too fast, we we can miss transaction completion - when we scan
 * the active list the transaction still seems to be active.  This generally
 * exhibits itself as a umass stall that never recovers.
 *
 * We work around this behaviour by setting up this callback after any softintr
 * that completes with transactions still pending, giving us another chance to
 * check for completion after the writeback has taken place.
 */
Static void
ehci_intrlist_timeout(void *arg)
{
	ehci_softc_t *sc = arg;
	int s = splusb();

	DPRINTF(("ehci_intrlist_timeout\n"));
	usb_schedsoftintr(&sc->sc_bus);

	splx(s);
}

/************************/

Static usbd_status
ehci_device_bulk_transfer(usbd_xfer_handle xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ehci_device_bulk_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

Static usbd_status
ehci_device_bulk_start(usbd_xfer_handle xfer)
{
#define exfer EXFER(xfer)
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
	usbd_device_handle dev = epipe->pipe.device;
	ehci_softc_t *sc = (ehci_softc_t *)dev->bus;
	ehci_soft_qtd_t *data, *dataend;
	ehci_soft_qh_t *sqh;
	usbd_status err;
	int len, isread, endpt;
	int s;

	DPRINTFN(2, ("ehci_device_bulk_start: xfer=%p len=%d flags=%d\n",
		     xfer, xfer->length, xfer->flags));

	if (sc->sc_dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (xfer->rqflags & URQ_REQUEST)
		panic("ehci_device_bulk_start: a request");
#endif

	len = xfer->length;
	endpt = epipe->pipe.endpoint->edesc->bEndpointAddress;
	isread = UE_GET_DIR(endpt) == UE_DIR_IN;
	sqh = epipe->sqh;

	epipe->u.bulk.length = len;

	err = ehci_alloc_sqtd_chain(epipe, sc, len, isread, xfer, &data,
				   &dataend);
	if (err) {
		DPRINTFN(-1,("ehci_device_bulk_transfer: no memory\n"));
		xfer->status = err;
		usb_transfer_complete(xfer);
		return (err);
	}

#ifdef EHCI_DEBUG
	if (ehcidebug > 5) {
		DPRINTF(("ehci_device_bulk_start: data(1)\n"));
		ehci_dump_sqh(sqh);
		ehci_dump_sqtds(data);
	}
#endif

	/* Set up interrupt info. */
	exfer->sqtdstart = data;
	exfer->sqtdend = dataend;
#ifdef DIAGNOSTIC
	if (!exfer->isdone) {
		printf("ehci_device_bulk_start: not done, ex=%p\n", exfer);
	}
	exfer->isdone = 0;
#endif

	s = splusb();
	ehci_set_qh_qtd(sqh, data); /* also does usb_syncmem(sqh) */
	if (xfer->timeout && !sc->sc_bus.use_polling) {
#ifdef __riscos
		callout_reset(&(xfer->timeout_handle), (MS_TO_TICKS(xfer->timeout)),
		    (ehci_timeout), (xfer));
#else
		callout_reset(&(xfer->timeout_handle), (mstohz(xfer->timeout)),
		    (ehci_timeout), (xfer));
#endif
	}
	mutex_enter(&sc->sc_intrhead_lock);
	ehci_add_intr_list(sc, exfer);
	mutex_exit(&sc->sc_intrhead_lock);
	xfer->status = USBD_IN_PROGRESS;
	splx(s);

#ifdef EHCI_DEBUG
	if (ehcidebug > 10) {
		DPRINTF(("ehci_device_bulk_start: data(2)\n"));
		delay(10000);
		DPRINTF(("ehci_device_bulk_start: data(3)\n"));
		ehci_dump_regs(sc);
#if 0
		printf("async_head:\n");
		ehci_dump_sqh(sc->sc_async_head);
#endif
		printf("sqh:\n");
		ehci_dump_sqh(sqh);
		ehci_dump_sqtds(data);
	}
#endif

	if (sc->sc_bus.use_polling)
		ehci_waitintr(sc, xfer);

	return (USBD_IN_PROGRESS);
#undef exfer
}

Static void
ehci_device_bulk_abort(usbd_xfer_handle xfer)
{
	DPRINTF(("ehci_device_bulk_abort: xfer=%p\n", xfer));
	ehci_abort_xfer(xfer, USBD_CANCELLED);
}

/*
 * Close a device bulk pipe.
 */
Static void
ehci_device_bulk_close(usbd_pipe_handle pipe)
{
	ehci_softc_t *sc = (ehci_softc_t *)pipe->device->bus;

	DPRINTF(("ehci_device_bulk_close: pipe=%p\n", pipe));
	ehci_close_pipe(pipe, sc->sc_async_head);
}

Static void
ehci_device_bulk_done(usbd_xfer_handle xfer)
{
	struct ehci_xfer *ex = EXFER(xfer);
	ehci_softc_t *sc = (ehci_softc_t *)xfer->pipe->device->bus;
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
	int endpt = epipe->pipe.endpoint->edesc->bEndpointAddress;
	int rd = UE_GET_DIR(endpt) == UE_DIR_IN;

	DPRINTFN(10,("ehci_bulk_done: xfer=%p, actlen=%d\n",
		     xfer, xfer->actlen));

#ifdef __riscos
	int s = splusb(); /* No mutexes, so just disable IRQs */
#endif
	mutex_enter(&sc->sc_intrhead_lock);
	if (xfer->status != USBD_NOMEM && ehci_active_intr_list(ex)) {
		ehci_del_intr_list(sc, ex);	/* remove from active list */
		ehci_free_sqtd_chain(sc, ex->sqtdstart, NULL);
		usb_syncmem(&xfer->dmabuf, 0, xfer->length,
		    rd ? BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
	}
	mutex_exit(&sc->sc_intrhead_lock);
#ifdef __riscos
	splx(s);
#endif

	DPRINTFN(5, ("ehci_bulk_done: length=%d\n", xfer->actlen));
}

/************************/

Static usbd_status
ehci_device_setintr(ehci_softc_t *sc, ehci_soft_qh_t *sqh, int ival)
{
	struct ehci_soft_islot *isp;
	int islot, lev;

	/* Find a poll rate that is large enough. */
	for (lev = EHCI_IPOLLRATES - 1; lev > 0; lev--)
		if (EHCI_ILEV_IVAL(lev) <= ival)
			break;

	/* Pick an interrupt slot at the right level. */
	/* XXX could do better than picking at random */
	sc->sc_rand = (sc->sc_rand + 191) % sc->sc_flsize;
	islot = EHCI_IQHIDX(lev, sc->sc_rand);

	sqh->islot = islot;
	isp = &sc->sc_islots[islot];
	ehci_add_qh(sqh, isp->sqh);

	return (USBD_NORMAL_COMPLETION);
}

Static usbd_status
ehci_device_intr_transfer(usbd_xfer_handle xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/*
	 * Pipe isn't running (otherwise err would be USBD_INPROG),
	 * so start it first.
	 */
	return (ehci_device_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

Static usbd_status
ehci_device_intr_start(usbd_xfer_handle xfer)
{
#define exfer EXFER(xfer)
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
	usbd_device_handle dev = xfer->pipe->device;
	ehci_softc_t *sc = (ehci_softc_t *)dev->bus;
	ehci_soft_qtd_t *data, *dataend;
	ehci_soft_qh_t *sqh;
	usbd_status err;
	int len, isread, endpt;
	int s;

	DPRINTFN(2, ("ehci_device_intr_start: xfer=%p len=%d flags=%d\n",
	    xfer, xfer->length, xfer->flags));

	if (sc->sc_dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (xfer->rqflags & URQ_REQUEST)
		panic("ehci_device_intr_start: a request");
#endif

	len = xfer->length;
	endpt = epipe->pipe.endpoint->edesc->bEndpointAddress;
	isread = UE_GET_DIR(endpt) == UE_DIR_IN;
	sqh = epipe->sqh;

	epipe->u.intr.length = len;

	err = ehci_alloc_sqtd_chain(epipe, sc, len, isread, xfer, &data,
	    &dataend);
	if (err) {
		DPRINTFN(-1, ("ehci_device_intr_start: no memory\n"));
		xfer->status = err;
		usb_transfer_complete(xfer);
		return (err);
	}

#ifdef EHCI_DEBUG
	if (ehcidebug > 5) {
		DPRINTF(("ehci_device_intr_start: data(1)\n"));
		ehci_dump_sqh(sqh);
		ehci_dump_sqtds(data);
	}
#endif

	/* Set up interrupt info. */
	exfer->sqtdstart = data;
	exfer->sqtdend = dataend;
#ifdef DIAGNOSTIC
	if (!exfer->isdone) {
		printf("ehci_device_intr_start: not done, ex=%p\n", exfer);
	}
	exfer->isdone = 0;
#endif

	s = splusb();
	ehci_set_qh_qtd(sqh, data); /* also does usb_syncmem(sqh) */
	if (xfer->timeout && !sc->sc_bus.use_polling) {
#ifdef __riscos
		callout_reset(&(xfer->timeout_handle), (MS_TO_TICKS(xfer->timeout)),
		    (ehci_timeout), (xfer));
#else
		callout_reset(&(xfer->timeout_handle), (mstohz(xfer->timeout)),
		    (ehci_timeout), (xfer));
#endif
	}
	mutex_enter(&sc->sc_intrhead_lock);
	ehci_add_intr_list(sc, exfer);
	mutex_exit(&sc->sc_intrhead_lock);
	xfer->status = USBD_IN_PROGRESS;
	splx(s);

#ifdef EHCI_DEBUG
	if (ehcidebug > 10) {
		DPRINTF(("ehci_device_intr_start: data(2)\n"));
		delay(10000);
		DPRINTF(("ehci_device_intr_start: data(3)\n"));
		ehci_dump_regs(sc);
		printf("sqh:\n");
		ehci_dump_sqh(sqh);
		ehci_dump_sqtds(data);
	}
#endif

	if (sc->sc_bus.use_polling)
		ehci_waitintr(sc, xfer);

	return (USBD_IN_PROGRESS);
#undef exfer
}

Static void
ehci_device_intr_abort(usbd_xfer_handle xfer)
{
	DPRINTFN(1, ("ehci_device_intr_abort: xfer=%p\n", xfer));
	if (xfer->pipe->intrxfer == xfer) {
		DPRINTFN(1, ("echi_device_intr_abort: remove\n"));
		xfer->pipe->intrxfer = NULL;
	}
	/*
	 * XXX - abort_xfer uses ehci_sync_hc, which syncs via the advance
	 *       async doorbell. That's dependant on the async list, wheras
	 *       intr xfers are periodic, should not use this?
	 */
	ehci_abort_xfer(xfer, USBD_CANCELLED);
}

Static void
ehci_device_intr_close(usbd_pipe_handle pipe)
{
        ehci_softc_t *sc = (ehci_softc_t *)pipe->device->bus;
	struct ehci_pipe *epipe = (struct ehci_pipe *)pipe;
	struct ehci_soft_islot *isp;

	isp = &sc->sc_islots[epipe->sqh->islot];
	ehci_close_pipe(pipe, isp->sqh);
}

Static void
ehci_device_intr_done(usbd_xfer_handle xfer)
{
#define exfer EXFER(xfer)
	struct ehci_xfer *ex = EXFER(xfer);
        ehci_softc_t *sc = (ehci_softc_t *)xfer->pipe->device->bus;
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
	ehci_soft_qtd_t *data, *dataend;
	ehci_soft_qh_t *sqh;
	usbd_status err;
	int len, isread, endpt, s;

	DPRINTFN(10, ("ehci_device_intr_done: xfer=%p, actlen=%d\n",
	    xfer, xfer->actlen));

#ifdef __riscos
	s = splusb(); /* No mutexes, so just disable IRQs */
#endif
	mutex_enter(&sc->sc_intrhead_lock);
	if (xfer->pipe->repeat) {
		ehci_free_sqtd_chain(sc, ex->sqtdstart, NULL);

		len = epipe->u.intr.length;
		xfer->length = len;
		endpt = epipe->pipe.endpoint->edesc->bEndpointAddress;
		isread = UE_GET_DIR(endpt) == UE_DIR_IN;
		usb_syncmem(&xfer->dmabuf, 0, len,
		    isread ? BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
		sqh = epipe->sqh;

		err = ehci_alloc_sqtd_chain(epipe, sc, len, isread, xfer,
		    &data, &dataend);
		if (err) {
			DPRINTFN(-1, ("ehci_device_intr_done: no memory\n"));
			xfer->status = err;
			mutex_exit(&sc->sc_intrhead_lock);
#ifdef __riscos
			splx(s);
#endif
			return;
		}

		/* Set up interrupt info. */
		exfer->sqtdstart = data;
		exfer->sqtdend = dataend;
#ifdef DIAGNOSTIC
		if (!exfer->isdone) {
			printf("ehci_device_intr_done: not done, ex=%p\n",
			    exfer);
		}
		exfer->isdone = 0;
#endif

#ifndef __riscos /* Already done */
		s = splusb();
#endif
		ehci_set_qh_qtd(sqh, data); /* also does usb_syncmem(sqh) */
		if (xfer->timeout && !sc->sc_bus.use_polling) {
#ifdef __riscos
			callout_reset(&(xfer->timeout_handle),
			    (MS_TO_TICKS(xfer->timeout)), (ehci_timeout), (xfer));
#else
			callout_reset(&(xfer->timeout_handle),
			    (mstohz(xfer->timeout)), (ehci_timeout), (xfer));
#endif
		}
#ifndef __riscos
		splx(s);
#endif

		xfer->status = USBD_IN_PROGRESS;
	} else if (xfer->status != USBD_NOMEM && ehci_active_intr_list(ex)) {
		ehci_del_intr_list(sc, ex); /* remove from active list */
		ehci_free_sqtd_chain(sc, ex->sqtdstart, NULL);
		endpt = epipe->pipe.endpoint->edesc->bEndpointAddress;
		isread = UE_GET_DIR(endpt) == UE_DIR_IN;
		usb_syncmem(&xfer->dmabuf, 0, xfer->length,
		    isread ? BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
	}
	mutex_exit(&sc->sc_intrhead_lock);
#ifdef __riscos
	splx(s);
#endif
#undef exfer
}

/************************/

Static usbd_status
ehci_device_isoc_transfer(usbd_xfer_handle xfer)
{
	usbd_status err;

	err = usb_insert_transfer(xfer);
	if (err && err != USBD_IN_PROGRESS)
		return err;

	return ehci_device_isoc_start(xfer);
}

Static usbd_status
ehci_device_isoc_start(usbd_xfer_handle xfer)
{
	struct ehci_pipe *epipe;
	usbd_device_handle dev;
	ehci_softc_t *sc;
	struct ehci_xfer *exfer;
	ehci_soft_itd_t *itd, *prev, *start, *stop;
	usb_dma_t *dma_buf;
	int i, j, k, frames, uframes, ufrperframe;
	int s, trans_count, offs, total_length;
	int frindex;

	start = NULL;
	prev = NULL;
	itd = NULL;
	trans_count = 0;
	total_length = 0;
	exfer = (struct ehci_xfer *) xfer;
	sc = (ehci_softc_t *)xfer->pipe->device->bus;
	dev = xfer->pipe->device;
	epipe = (struct ehci_pipe *)xfer->pipe;

	/*
	 * To allow continuous transfers, above we start all transfers
	 * immediately. However, we're still going to get usbd_start_next call
	 * this when another xfer completes. So, check if this is already
	 * in progress or not
	 */

	if (exfer->itdstart != NULL)
		return USBD_IN_PROGRESS;

	DPRINTFN(2, ("ehci_device_isoc_start: xfer %p len %d flags %d\n",
			xfer, xfer->length, xfer->flags));

	if (sc->sc_dying)
		return USBD_IOERROR;

	/*
	 * To avoid complication, don't allow a request right now that'll span
	 * the entire frame table. To within 4 frames, to allow some leeway
	 * on either side of where the hc currently is.
	 */
	if ((1 << (epipe->pipe.endpoint->edesc->bInterval)) *
			xfer->nframes >= (sc->sc_flsize - 4) * 8) {
		printf("ehci: isoc descriptor requested that spans the entire frametable, too many frames\n");
		return USBD_INVAL;
	}

#ifdef DIAGNOSTIC
	if (xfer->rqflags & URQ_REQUEST)
		panic("ehci_device_isoc_start: request\n");

	if (!exfer->isdone)
		printf("ehci_device_isoc_start: not done, ex = %p\n", exfer);
	exfer->isdone = 0;
#endif

	/*
	 * Step 1: Allocate and initialize itds, how many do we need?
	 * One per transfer if interval >= 8 microframes, fewer if we use
	 * multiple microframes per frame.
	 */

	i = epipe->pipe.endpoint->edesc->bInterval;
	if (i > 16 || i == 0) {
		/* Spec page 271 says intervals > 16 are invalid */
		DPRINTF(("ehci_device_isoc_start: bInvertal %d invalid\n", i));
		return USBD_INVAL;
	}

	ufrperframe = max(1, USB_UFRAMES_PER_FRAME / (1 << (i - 1)));
	frames = (xfer->nframes + (ufrperframe - 1)) / ufrperframe;
	uframes = USB_UFRAMES_PER_FRAME / ufrperframe;

	if (frames == 0) {
		DPRINTF(("ehci_device_isoc_start: frames == 0\n"));
		return USBD_INVAL;
	}

	dma_buf = &xfer->dmabuf;
	offs = 0;

	for (i = 0; i < frames; i++) {
		int froffs = offs;
		itd = ehci_alloc_itd(sc);

		if (prev != NULL) {
			prev->itd.itd_next =
			    htole32(itd->physaddr | EHCI_LINK_ITD);
			usb_syncmem(&itd->dma,
			    itd->offs + offsetof(ehci_itd_t, itd_next),
                	    sizeof(itd->itd.itd_next), BUS_DMASYNC_POSTWRITE);

			prev->xfer_next = itd;
	    	} else {
			start = itd;
		}

		/*
		 * Step 1.5, initialize uframes
		 */
		for (j = 0; j < EHCI_ITD_NUFRAMES; j += uframes) {
			/* Calculate which page in the list this starts in */
			int addr = DMAADDR(dma_buf, froffs);
			addr = EHCI_PAGE_OFFSET(addr);
			addr += (offs - froffs);
			addr = EHCI_PAGE(addr);
			addr /= EHCI_PAGE_SIZE;

			/* This gets the initial offset into the first page,
			 * looks how far further along the current uframe
			 * offset is. Works out how many pages that is.
			 */

			itd->itd.itd_ctl[j] = htole32 ( EHCI_ITD_ACTIVE |
			    EHCI_ITD_SET_LEN(xfer->frlengths[trans_count]) | 
			    EHCI_ITD_SET_PG(addr) |
			    EHCI_ITD_SET_OFFS(EHCI_PAGE_OFFSET(DMAADDR(dma_buf,offs))));

			total_length += xfer->frlengths[trans_count];
			offs += xfer->frlengths[trans_count];
			trans_count++;

			if (trans_count >= xfer->nframes) { /*Set IOC*/
				itd->itd.itd_ctl[j] |= htole32(EHCI_ITD_IOC);
				break;
			}
		}	

		/* Step 1.75, set buffer pointers. To simplify matters, all
		 * pointers are filled out for the next 7 hardware pages in
		 * the dma block, so no need to worry what pages to cover
		 * and what to not.
		 */

		for (j = 0; j < EHCI_ITD_NBUFFERS; j++) {
			/*
			 * Don't try to lookup a page that's past the end
			 * of buffer
			 */
			int page_offs = EHCI_PAGE(froffs + (EHCI_PAGE_SIZE * j));
#ifdef __riscos
			if (page_offs >= xfer->length) /* I think this is correct! */
#else
			if (page_offs >= dma_buf->block->size)
#endif
				break;

			long long page = DMAADDR(dma_buf, page_offs);
			page = EHCI_PAGE(page);
			itd->itd.itd_bufr[j] =
			    htole32(EHCI_ITD_SET_BPTR(page));
			itd->itd.itd_bufr_hi[j] =
			    htole32(page >> 32);
		}

		/*
		 * Other special values
		 */

		k = epipe->pipe.endpoint->edesc->bEndpointAddress;
		itd->itd.itd_bufr[0] |= htole32(EHCI_ITD_SET_EP(UE_GET_ADDR(k)) |
		    EHCI_ITD_SET_DADDR(epipe->pipe.device->address));

		k = (UE_GET_DIR(epipe->pipe.endpoint->edesc->bEndpointAddress))
		    ? 1 : 0;
		j = UGETW(epipe->pipe.endpoint->edesc->wMaxPacketSize);
		itd->itd.itd_bufr[1] |= htole32(EHCI_ITD_SET_DIR(k) |
		    EHCI_ITD_SET_MAXPKT(UE_GET_SIZE(j)));

		/* FIXME: handle invalid trans */
		itd->itd.itd_bufr[2] |= 
		    htole32(EHCI_ITD_SET_MULTI(UE_GET_TRANS(j)+1));

		usb_syncmem(&itd->dma,
		    itd->offs + offsetof(ehci_itd_t, itd_next),
                    sizeof(ehci_itd_t),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

		prev = itd;
	} /* End of frame */

	stop = itd;
	stop->xfer_next = NULL;
	exfer->isoc_len = total_length;

	usb_syncmem(&exfer->xfer.dmabuf, 0, total_length,
		BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	/*
	 * Part 2: Transfer descriptors have now been set up, now they must
	 * be scheduled into the period frame list. Erk. Not wanting to
	 * complicate matters, transfer is denied if the transfer spans
	 * more than the period frame list.
	 */

	s = splusb();

	/* Start inserting frames */
	if (epipe->u.isoc.cur_xfers > 0) {
		frindex = epipe->u.isoc.next_frame;
	} else {
		frindex = EOREAD4(sc, EHCI_FRINDEX);
		frindex = frindex >> 3; /* Erase microframe index */
		frindex += 2;
	}

	if (frindex >= sc->sc_flsize)
		frindex &= (sc->sc_flsize - 1);

	/* What's the frame interval? */
	i = (1 << (epipe->pipe.endpoint->edesc->bInterval - 1));
	if (i / USB_UFRAMES_PER_FRAME == 0)
		i = 1;
	else
		i /= USB_UFRAMES_PER_FRAME;

	itd = start;
	for (j = 0; j < frames; j++) {
		if (itd == NULL)
			panic("ehci: unexpectedly ran out of isoc itds, isoc_start\n");

		itd->itd.itd_next = sc->sc_flist[frindex];
		if (itd->itd.itd_next == 0)
			/* FIXME: frindex table gets initialized to NULL
			 * or EHCI_NULL? */
			itd->itd.itd_next = EHCI_NULL;

		usb_syncmem(&itd->dma,
		    itd->offs + offsetof(ehci_itd_t, itd_next),
                    sizeof(itd->itd.itd_next),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

		sc->sc_flist[frindex] = htole32(EHCI_LINK_ITD | itd->physaddr);

		usb_syncmem(&sc->sc_fldma,
		    sizeof(ehci_link_t) * frindex,
                    sizeof(ehci_link_t),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

		itd->u.frame_list.next = sc->sc_softitds[frindex];
		sc->sc_softitds[frindex] = itd;
		if (itd->u.frame_list.next != NULL)
			itd->u.frame_list.next->u.frame_list.prev = itd;
		itd->slot = frindex;
		itd->u.frame_list.prev = NULL;

		frindex += i;
		if (frindex >= sc->sc_flsize)
			frindex -= sc->sc_flsize;

		itd = itd->xfer_next;
	}

	epipe->u.isoc.cur_xfers++;
	epipe->u.isoc.next_frame = frindex;

	exfer->itdstart = start;
	exfer->itdend = stop;
	exfer->sqtdstart = NULL;
	exfer->sqtdstart = NULL;

	mutex_enter(&sc->sc_intrhead_lock);
	ehci_add_intr_list(sc, exfer);
	mutex_exit(&sc->sc_intrhead_lock);
	xfer->status = USBD_IN_PROGRESS;
	xfer->done = 0;
	splx(s);

	if (sc->sc_bus.use_polling) {
		printf("Starting ehci isoc xfer with polling. Bad idea?\n");
		ehci_waitintr(sc, xfer);
	}

	return USBD_IN_PROGRESS;
}

Static void
ehci_device_isoc_abort(usbd_xfer_handle xfer)
{
	DPRINTFN(1, ("ehci_device_isoc_abort: xfer = %p\n", xfer));
	ehci_abort_isoc_xfer(xfer, USBD_CANCELLED);
}

Static void
ehci_device_isoc_close(usbd_pipe_handle pipe)
{
	DPRINTFN(1, ("ehci_device_isoc_close: nothing in the pipe to free?\n"));
}

Static void
ehci_device_isoc_done(usbd_xfer_handle xfer)
{
	struct ehci_xfer *exfer;
	ehci_softc_t *sc;
	struct ehci_pipe *epipe;
	int s;

	exfer = EXFER(xfer);
	sc = (ehci_softc_t *)xfer->pipe->device->bus;
	epipe = (struct ehci_pipe *) xfer->pipe;

	s = splusb();
	epipe->u.isoc.cur_xfers--;
	mutex_enter(&sc->sc_intrhead_lock);
	if (xfer->status != USBD_NOMEM && ehci_active_intr_list(exfer)) {
		ehci_del_intr_list(sc, exfer);
		ehci_rem_free_itd_chain(sc, exfer);
	}
	mutex_exit(&sc->sc_intrhead_lock);
	splx(s);

	usb_syncmem(&xfer->dmabuf, 0, xfer->length, BUS_DMASYNC_POSTWRITE |
                    BUS_DMASYNC_POSTREAD);

}
@


1.19
log
@  Fixes for Isochronous data transfer
Detail:
Frontend
========

NetBSD.build.c.usbmodule
	frontend isochronous changes
	forces reads to always be multiple of maxpacket
NetBSD.dev.usb.c.usb_subr
	datatoggle fix
	panic fix
NetBSD.dev.usb.c.usbdi
	usbd_transfer changed so that bufrem is passed the xfer pointer instead of the buffer pointer
	fixed missing braces in usbd_clear_endpoint_stall

EHCI
====

The HS (USB2) isochronous as been rewritten and isochronous split transactions - FS (USB1) over a HS Connection - has been added

NetBSD.dev.usb.c.ehci
NetBSD.dev.usb.h.ehcireg
NetBSD.dev.usb.h.ehcivar

OHCI
====

Changes to the NetBSD backend to get isochronous transfers working on a OHCI device. While it did have isochronous support it wasn't working properly.

NetBSD.dev.usb.c.ohci

Admin:
  Submitted by Colin Granville
Tested in iMx6

Version 1.10. Tagged as 'NetBSD-1_10'
@
text
@a59 5
 

#ifdef EHCI_DEBUG
#define notyet 1==1
#endif
a93 10
static inline int frindex_wrap(const ehci_softc_t* sc, unsigned int a) {
	return a & (sc->sc_flsize - 1);
}

static inline int frindex_sub(const ehci_softc_t* sc, unsigned int a, unsigned int b) {
	a = frindex_wrap(sc, a);
	b = frindex_wrap(sc, b);
	return (sc->sc_flsize / 2) - frindex_wrap(sc, (sc->sc_flsize / 2) - a + b);
}

a110 11
#ifdef EHCI_DEBUG
#define dprintf_here(...) \
	do\
	{\
		printf("%s(%d)- 0x%x: ",__func__,__LINE__,EOREAD4(sc, EHCI_FRINDEX));\
		printf(__VA_ARGS__);\
        } while (0)
#else
#define dprintf_here(...) do {} while (0)
#endif

a483 1

a490 1

d502 1
d641 1
a641 2
    /* Turn on controller */
#if 0 /* change this line from */	
a647 8
#else /* to */
	EOWRITE4(sc, EHCI_USBCMD,
		 EHCI_CMD_ITC_2 | /* 2 microframes interrupt delay */
		 (EOREAD4(sc, EHCI_USBCMD) & (EHCI_CMD_FLS_M | EHCI_CMD_ASPME | EHCI_CMD_ASPMC)) |
		 EHCI_CMD_ASE |
		 EHCI_CMD_PSE |
		 EHCI_CMD_RS);
#endif
a662 18
#if 1 /*  IMX6 ISOCHRONOUS CRACKLE FIX */
	/*
	 * Fixes buffer underrun errors which result in glitches in 
	 * Isochronous transfers and retries in other transfer modes.
	 * Changing TXFIFOTHRES in EHCI_TXFILLTUNING to 4 fixes this.
	 * See imx6 errata pdf ERR006308. 
	 * Default value of TXFIFOTHRES was 2
	 * Bits 8-12 of EHCI_TXFillTuning contain a health check counter 
	 * for the scheduler. Setting bits 0-7 to 2 stops health check counts
	 * occuring
	 */
#define EHCI_TXFILLTUNING (EHCI_USBCMD	+ 0x164 - 0x140)

	i = EOREAD4(sc, EHCI_TXFILLTUNING) & ~0x3f00FF;
	EOWRITE4(sc, EHCI_TXFILLTUNING, (i | 0x40002));
	
#endif /* IMX6 ISOCHRONOUS CRACKLE FIX */

d932 1
d953 3
a955 1
	sc = sc;
d957 3
a959 4
	if (ex->xfer.device->speed != USB_SPEED_HIGH) {
		if ((EHCI_SITD_GET_STATUS(itd->td.sitd.sitd_status) & EHCI_SITD_ACTIVE) == 0)
			goto done;
		return;
d962 2
a963 7
	for (i = 0; i < EHCI_ITD_NUFRAMES; i++) {
		u_int32_t s = le32toh(itd->td.itd.itd_ctl[i]);
                
		if (s & EHCI_ITD_IOC) {
			if (s &  EHCI_ITD_ACTIVE) return;
			goto done;
		}
d966 2
a968 1

a1028 19
			if (xfer->device->speed != USB_SPEED_HIGH) {
#ifdef EHCI_DEBUG
				if (ehcidebug > 1) ehci_dump_sitd(itd);
#endif  /* EHCI_DEBUG */              
				status = le32toh(itd->td.sitd.sitd_status);
				len    = EHCI_ITD_GET_LEN(status);
				if (EHCI_SITD_GET_STATUS(status) & EHCI_SITD_STATERRS)
					len = 0; /*No valid data on error*/
				else {
					if (len >  xfer->frlengths[nframes]) len = 0;
					len = xfer->frlengths[nframes] - len;
				}
				xfer->frlengths[nframes++] = len;
				actlen += len;
			} else {
#ifdef EHCI_DEBUG
				if (ehcidebug > 1) ehci_dump_itd(itd);
#endif                

d1043 1
a1043 1
				status = le32toh(itd->td.itd.itd_ctl[i]);
a1051 1
			}
a1507 1
	pipe->endpoint->datatoggle = 0;
d1668 5
a1672 1
	printf("ITD: itd_next=");ehci_dump_link(itd->td.itd.itd_next,1);printf("\n");
a1673 1
	u_int32_t i;
d1675 5
a1679 13
		u_int32_t t = le32toh(itd->td.itd.itd_ctl[i]);
		printf("    itd_ctl[%d]: stat=%X (%s%s%s%s) len=%d ioc=%d pg=%d offs=%X\n",
			i,
			EHCI_ITD_GET_STATUS(t),
			(t & EHCI_ITD_ACTIVE ? "active " : ""),
			(t & EHCI_ITD_BUF_ERR ? "buf_err " : ""),
			(t & EHCI_ITD_BABBLE ? "babble " : ""),
			(t & EHCI_ITD_ERROR ? "error " : ""),
			EHCI_ITD_GET_LEN(t),
			EHCI_ITD_GET_IOC(t), 
			EHCI_ITD_GET_PG(t),
			EHCI_ITD_GET_OFFS(t)
			);
d1681 1
a1681 1
	printf("    itd_bufr[] ");
d1683 1
a1683 1
	printf("%X,", EHCI_ITD_GET_BPTR(le32toh(itd->td.itd.itd_bufr[i])));
d1685 6
a1690 10
	u_int32_t b = le32toh(itd->td.itd.itd_bufr[0]);
	u_int32_t b2 = le32toh(itd->td.itd.itd_bufr[1]);
	u_int32_t b3 = le32toh(itd->td.itd.itd_bufr[2]);
	printf("\n    ep=%X daddr=%X dir=%d maxpkt=%d multi=%d\n",
			EHCI_ITD_GET_EP(b), 
			EHCI_ITD_GET_DADDR(b), 
			EHCI_ITD_GET_DIR(b2),
			EHCI_ITD_GET_MAXPKT(b2), 
			EHCI_ITD_GET_MULTI(b3)
			);
d1696 3
a1698 42
	printf("SITD: itd_next=");ehci_dump_link(itd->td.sitd.sitd_next,1);printf("\n");

	u_int32_t i = le32toh(itd->td.sitd.sitd_endp);
	printf("    sitd_endp addr=%d ep=%d haddr=%d hport=%d io=%d\n",
		EHCI_SITD_GET_ADDR(i),
		EHCI_SITD_GET_ENDPT(i),
		EHCI_SITD_GET_HUBA(i),
		EHCI_SITD_GET_PORT(i),
		EHCI_SITD_GET_IO(i)
		);
	i = le32toh(itd->td.sitd.sitd_mask);
	printf("    sitd_mask smask=0x%x cmask=0x%x\n",
		EHCI_SITD_GET_SMASK(i),
		EHCI_SITD_GET_CMASK(i)
		);
	i = le32toh(itd->td.sitd.sitd_status);
	printf("    sitd_status status=0x%x (%s%s%s%s%s%s%s) cpmask=0x%x len=%d psel=%d ioc=%d\n",
		EHCI_SITD_GET_STATUS(i),
		(i & EHCI_SITD_ACTIVE ? "active " : ""),
		(i & EHCI_SITD_ERR ? "err " : ""),
		(i & EHCI_SITD_BUFERR ? "buferr " : ""),
		(i & EHCI_SITD_BABBLE ? "babble " : ""),
		(i & EHCI_SITD_XACTERR? "xacterr " : ""),
		(i & EHCI_SITD_MISSEDMICRO ? "missedmicro " : ""),
		(i & EHCI_SITD_SPLITXSTATE ? "doCompleteSplit " : ""),
		EHCI_SITD_GET_CPMASK(i),
		EHCI_SITD_GET_LEN(i),
		EHCI_SITD_GET_PSEL(i),
		EHCI_SITD_GET_IOC(i)
		);
	i = le32toh(itd->td.sitd.sitd_buffer[1]);
	printf("    sitd_buffer[0]=0x%08X sitd_buffer[1]=0x%08X tpos=%d tcnt=%d\n",
		le32toh(itd->td.sitd.sitd_buffer[0]),
		(i & ~31),
		EHCI_SITD_GET_TPOS(i),
		EHCI_SITD_GET_TCNT(i)
		);
	printf("    sitd_back=0x%08x sitd_buffer_hi[]= 0x%x 0x%x\n",
		le32toh(itd->td.sitd.sitd_back),
		le32toh(itd->td.sitd.sitd_buffer_hi[0]),
		le32toh(itd->td.sitd.sitd_buffer_hi[1])
		);
d1750 1
a1750 2
	/* toggle state needed for bulk endpoints */
	epipe->nexttoggle = pipe->endpoint->datatoggle;
d1775 14
d1814 10
a1823 30
		if (xfertype == UE_INTERRUPT) {
			if (speed == EHCI_QH_SPEED_HIGH) {
				unsigned int smask = ed->bInterval;
				if (smask == 0) smask = 1;
				if (smask > 4) smask = 4;
				smask = "\xff\xaa\x11\x01"[smask - 1];
				sqh->qh.qh_endphub = htole32(
				EHCI_QH_SET_MULT(1) |
				EHCI_QH_SET_SMASK(smask));
			} else {
				unsigned int cmask = (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN ? 0x1c : 0);
				sqh->qh.qh_endphub = htole32(
				EHCI_QH_SET_MULT(1) |
					EHCI_QH_SET_SMASK(1) |
					EHCI_QH_SET_PORT(hshubport) |
					EHCI_QH_SET_HUBA(hshubaddr) |
					EHCI_QH_SET_CMASK(cmask));
			}
		} else {
			if (speed == EHCI_QH_SPEED_HIGH) {
				sqh->qh.qh_endphub = htole32(
					EHCI_QH_SET_MULT(1));
			} else {
				sqh->qh.qh_endphub = htole32(
				EHCI_QH_SET_MULT(1) |
				EHCI_QH_SET_PORT(hshubport) |
				EHCI_QH_SET_HUBA(hshubaddr));
			}
		}

d1891 1
a1891 2
		/* next frame needs to start with an invalid value */
		epipe->u.isoc.next_frame = -1;
a1946 1
	{
a1947 3
		return;
	}

a2039 1
	{
a2040 2
		return;
	}
d2047 1
a2047 1
			sc->sc_flist[itd->slot] = itd->td.itd.itd_next;
d2057 1
a2057 1
			prev->td.itd.itd_next = itd->td.itd.itd_next;
d2060 2
a2061 1
			    sizeof(itd->td.itd.itd_next), BUS_DMASYNC_PREWRITE);
d3030 2
a3031 8
	 
	/* 
	 * While the existing method worked on an Iyonix it didn't work properly
	 * on Beagleboard and Pandaboard. These controllers must keep the internal
	 * copies of ITD's a bit longer. The code below ensures that an ITD isn't 
	 * reused soon after it's been freed.
	 */ 
	frindex = frindex_wrap(sc,(EOREAD4(sc, EHCI_FRINDEX) >> 3) + 1);
d3037 1
a3037 2
		int diff = frindex_sub(sc, itd->slot, frindex);
		if (diff < -3 || diff > 0) {
a3058 6

			/* 
			 * itd->slot needs to be an invalid value 
			 * otherwise it won't be allocated when same as frindex
			 */
			itd->slot = -1;
d3066 1
a3066 1
	memset(&itd->td.itd, 0, sizeof(ehci_itd_t));
d3068 3
a3070 2
		    sizeof(itd->td.itd.itd_next), BUS_DMASYNC_PREWRITE |
		    BUS_DMASYNC_PREREAD);
d3074 1
a3074 1
	itd->slot = -1;
d3084 1
a3084 1
        if (itd == NULL) return;
d3344 1
a3344 1
		    sizeof(itd->td.itd.itd_ctl),
d3348 1
a3348 1
			trans_status = le32toh(itd->td.itd.itd_ctl[i]);
d3350 1
a3350 1
			itd->td.itd.itd_ctl[i] = htole32(trans_status);
d3355 1
a3355 1
		    sizeof(itd->td.itd.itd_ctl),
a3848 1
	struct ehci_pipe *epipe = (struct ehci_pipe *)pipe;
a3850 1
	pipe->endpoint->datatoggle = epipe->nexttoggle;     
d4039 1
a4039 1
	ehci_softc_t *sc = (ehci_softc_t *)pipe->device->bus;
a4042 1
	pipe->endpoint->datatoggle = epipe->nexttoggle;
d4147 2
a4148 2
Static void
ehci_device_isoc_abort(usbd_xfer_handle xfer)
d4150 26
a4175 3
	DPRINTFN(1, ("ehci_device_isoc_abort: xfer = %p\n", xfer));
	ehci_abort_isoc_xfer(xfer, USBD_CANCELLED);
}
d4177 2
a4178 5
Static void
ehci_device_isoc_close(usbd_pipe_handle pipe)
{
	DPRINTFN(1, ("ehci_device_isoc_close: nothing in the pipe to free?\n"));
}
d4180 2
a4181 7
Static void
ehci_device_isoc_done(usbd_xfer_handle xfer)
{
	struct ehci_xfer *exfer;
	ehci_softc_t *sc;
	struct ehci_pipe *epipe;
	int s;
d4183 2
a4184 3
	exfer = EXFER(xfer);
	sc = (ehci_softc_t *)xfer->pipe->device->bus;
	epipe = (struct ehci_pipe *) xfer->pipe;
d4186 9
a4194 6
	s = splusb();
	epipe->u.isoc.cur_xfers--;
	mutex_enter(&sc->sc_intrhead_lock);
	if (xfer->status != USBD_NOMEM && ehci_active_intr_list(exfer)) {
		ehci_del_intr_list(sc, exfer);
		ehci_rem_free_itd_chain(sc, exfer);
a4195 2
	mutex_exit(&sc->sc_intrhead_lock);
	splx(s);
d4197 21
a4217 2
	usb_syncmem(&xfer->dmabuf, 0, xfer->length, BUS_DMASYNC_POSTWRITE |
                    BUS_DMASYNC_POSTREAD);
d4219 3
a4221 1
}
d4223 3
a4225 6
static usbd_status alloc_itd_failed(ehci_softc_t *sc, ehci_soft_itd_t* start)
{
	ehci_soft_itd_t* next;
	for (; start != NULL;start = next) {
		next = start->xfer_next;
		ehci_free_itd(sc, start);
a4226 2
	return USBD_NOMEM;
}
d4228 109
a4336 5
static usbd_status ehci_insert_itds_in_framelist(struct ehci_xfer* exfer, ehci_soft_itd_t* start, 
							unsigned int interval, unsigned int itd_type)
{
	struct ehci_pipe* epipe = (struct ehci_pipe*) exfer->xfer.pipe ;
	ehci_softc_t* sc = (ehci_softc_t*) exfer->xfer.pipe->device->bus;
d4338 6
a4343 8
	/* index in frames - not microframes */
	unsigned int frindex = (EOREAD4(sc, EHCI_FRINDEX) >> 3);
	if (epipe->u.isoc.next_frame == -1)
		frindex = frindex_wrap(sc,frindex + 16);
	else if (frindex_sub(sc, frindex, epipe->u.isoc.next_frame) >= 0)
		frindex = frindex_wrap(sc, frindex + 1);
	else
		frindex = epipe->u.isoc.next_frame;
d4345 1
a4345 1
	int s = splusb();
d4347 8
a4354 3
	ehci_soft_itd_t* stop = start;
	for (ehci_soft_itd_t* itd = start; itd; itd = itd->xfer_next) {
		stop = itd;
d4356 9
a4364 1
		/* insert into physical frame list */
d4366 4
a4369 1
		itd->td.itd.itd_next = sc->sc_flist[frindex];
d4371 5
a4375 3
		/* if this happens then something else has gone wrong */
		if (itd->td.itd.itd_next == 0)
			itd->td.itd.itd_next = EHCI_NULL;
d4377 4
a4380 1
		sc->sc_flist[frindex] = htole32(itd_type | itd->physaddr);
d4382 1
d4384 4
a4387 1
		/* insert into logical frame list */
d4396 3
d4400 1
a4400 1
		frindex = frindex_wrap(sc, frindex + interval);
d4402 1
d4409 1
a4409 1
	exfer->sqtdend = NULL
d4414 3
a4417 5
	exfer->xfer.status = USBD_IN_PROGRESS;
	exfer->xfer.done = 0;

	splx(s);
        
d4420 1
a4420 1
		ehci_waitintr(sc, &exfer->xfer);
d4426 6
a4431 5
static usbd_status ehci_device_split_isoc_start(usbd_xfer_handle xfer)
{               
	struct ehci_xfer* exfer = (struct ehci_xfer *) xfer;
	ehci_softc_t *sc = (ehci_softc_t *) xfer->pipe->device->bus;
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
d4433 4
a4436 93
	if (exfer->itdstart != NULL)
		return USBD_IN_PROGRESS;

	unsigned int interval = epipe->pipe.endpoint->edesc->bInterval - 1;

	if (interval > 15)
		return USBD_INVAL;

	interval = (1 << interval); /* interval in frames */

	/* Can't cope with insertions into frame list >= (sc->sc_flsize / 2) */
	if (interval * xfer->nframes >= (sc->sc_flsize / 2))
		return USBD_INVAL;


	/* Create a list of sitd blocks for the xfer */
        
	ehci_soft_itd_t* itd = NULL;
	ehci_soft_itd_t* start = NULL;
	ehci_physaddr_t buf = DMAADDR(&xfer->dmabuf, 0);
	exfer->isoc_len = 0;
	for (int ncur = 0;ncur < xfer->nframes;) {
		ehci_soft_itd_t* prev = itd;
		itd = ehci_alloc_itd(sc);
		if (itd == NULL) return  alloc_itd_failed(sc,start);

		if (prev != NULL) 
			prev->xfer_next = itd;
		else 
			start = itd;

		u_int32_t ep = epipe->pipe.endpoint->edesc->bEndpointAddress;
		u_int32_t dir = (UE_GET_DIR(ep)) ? 1 : 0;
		ep = UE_GET_ADDR(ep);

		itd->td.sitd.sitd_endp = htole32(
		EHCI_SITD_SET_ADDR(xfer->pipe->device->address) |
			EHCI_SITD_SET_ENDPT(ep) |
			EHCI_SITD_SET_IO(dir)   |
			EHCI_SITD_SET_HUBA(xfer->pipe->device->myhsport->parent->address) |
			EHCI_SITD_SET_PORT(xfer->pipe->device->myhsport->portno));

		int len = xfer->frlengths[ncur++];

		int splitcount = 1;
		for (int i = 188; i < len; i += 188) splitcount++; 

		/* 
		 * Poor mans split transaction scheduling.
		 * Would be better to schedule when the pipe opens
		 * taking into account other open FS/LS endpoints on the
		 * same transaction translator.
		 */
		if (dir == 1) { /* IN */
			u_int32_t mask;
			/* In transfers schedule 2 extra complete splits */
			splitcount += 2;
			if (splitcount >= 6) 
				mask = 0xbf;
			else
				mask = (0xff >> (8 - splitcount)) << 2;

			itd->td.sitd.sitd_mask = htole32(
				EHCI_SITD_SET_SMASK(1) |
				EHCI_SITD_SET_CMASK(mask));
		} else {
			/* lump small transfers together in microframe 0 */
			itd->td.sitd.sitd_mask = htole32(
			EHCI_SITD_SET_SMASK((0xff >> (8 - splitcount))  << (len>16 ? 1 :0)));
		}

		itd->td.sitd.sitd_status = htole32(
			EHCI_SITD_SET_STATUS(EHCI_SITD_ACTIVE) |
			EHCI_SITD_SET_LEN(len) |
			EHCI_SITD_SET_IOC(ncur == xfer->nframes ? 1 : 0));

		itd->td.sitd.sitd_buffer[0] = htole32(buf);
		itd->td.sitd.sitd_buffer[1] = htole32(          
			EHCI_PAGE(buf + EHCI_PAGE_SIZE) |
			EHCI_SITD_SET_TPOS((len <= 188 || dir == 1) ? 
				EHCI_SITD_TPOS_ALL : EHCI_SITD_TPOS_BEGIN) |
			EHCI_SITD_GET_TCNT(dir == 1 ? 1 : splitcount));

		itd->td.sitd.sitd_back = EHCI_NULL; 

		itd->td.sitd.sitd_buffer_hi[0] = 0;
		itd->td.sitd.sitd_buffer_hi[1] = 0;

		exfer->isoc_len += len;
		buf += len;
	}
        
	return ehci_insert_itds_in_framelist(exfer, start, interval, EHCI_LINK_SITD);
d4439 2
a4440 1
Static usbd_status ehci_device_isoc_start(usbd_xfer_handle xfer)
d4442 4
a4445 2
	if (xfer->device->speed != USB_SPEED_HIGH)
		return ehci_device_split_isoc_start(xfer);
d4447 3
a4449 3
	struct ehci_xfer* exfer = (struct ehci_xfer *) xfer;
	ehci_softc_t *sc = (ehci_softc_t *) xfer->pipe->device->bus;
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
d4451 6
a4456 75
	if (exfer->itdstart != NULL)
		return USBD_IN_PROGRESS;

	unsigned int interval = epipe->pipe.endpoint->edesc->bInterval - 1;

	if (interval > 15)
		return USBD_INVAL;
        
	/* don't accept insertions into frame list >= (sc->sc_flsize / 2) */
	if ( ( ((interval <= 3) ? 1 :(1 << (interval - 3))) * xfer->nframes) >= (sc->sc_flsize / 2))
		return USBD_INVAL;

	/* Create a list of itd blocks for the xfer */

	interval = (1 << interval); /* interval in microframes */

	ehci_soft_itd_t* itd = NULL;
	ehci_soft_itd_t* start = NULL;
	ehci_physaddr_t buf = DMAADDR(&xfer->dmabuf, 0);
	exfer->isoc_len = 0;
	int quit = 0;
	int ncur = 0;
	int offs = 0;
	while (!quit) {
		ehci_soft_itd_t* prev = itd;
		itd = ehci_alloc_itd(sc);
		if (itd == NULL) return  alloc_itd_failed(sc,start);

		if (prev != NULL) 
			prev->xfer_next = itd;
		else 
			start = itd;

		buf += offs;    
		offs = EHCI_PAGE_OFFSET(buf);
		buf = EHCI_PAGE(buf);
		for (int i = 0;; i += interval) {
			int pg = offs / EHCI_PAGE_SIZE;
			itd->td.itd.itd_bufr[pg] = htole32(
				EHCI_ITD_SET_BPTR(EHCI_PAGE(buf+offs)));
			itd->td.itd.itd_bufr_hi[pg] = 0;

			if (ncur == xfer->nframes || i >= EHCI_ITD_NUFRAMES) {
				unsigned int ep = epipe->pipe.endpoint->edesc->bEndpointAddress;
				itd->td.itd.itd_bufr[0] |= htole32(
					EHCI_ITD_SET_EP(UE_GET_ADDR(ep)) |
					EHCI_ITD_SET_DADDR(epipe->pipe.device->address));

				unsigned int mp =  UGETW(epipe->pipe.endpoint->edesc->wMaxPacketSize);

				itd->td.itd.itd_bufr[1] |= htole32(
					EHCI_ITD_SET_DIR(UE_GET_DIR(ep) ? 1 : 0) |
					EHCI_ITD_SET_MAXPKT(UE_GET_SIZE(mp)));

				itd->td.itd.itd_bufr[2] |= htole32(
					EHCI_ITD_SET_MULTI(UE_GET_TRANS(mp) + 1));

				if (ncur == xfer->nframes) {
					itd->td.itd.itd_ctl[i - interval] |= htole32(
						EHCI_ITD_IOC);
					quit = 1;
				}
				break;
			}

			int len = xfer->frlengths[ncur++];

			itd->td.itd.itd_ctl[i] = htole32( 
				EHCI_ITD_ACTIVE |
				EHCI_ITD_SET_LEN(len) |
				offs);

			exfer->isoc_len += len;
			offs += len;
		}
d4458 2
d4461 2
a4462 3
	interval >>= 3; 
	if (interval == 0) interval = 1;
	/* interval now in frames */
a4463 1
	return ehci_insert_itds_in_framelist(exfer, start, interval, EHCI_LINK_ITD);
@


1.18
log
@Init structures for OHCI & EHCI unused members
Detail:
  Play safe, put NULLs in for the unused HC overrides.

Version 1.08. Not tagged
@
text
@d60 5
d99 10
d126 11
d510 1
d518 1
a529 1

d668 2
a669 1
	/* Turn on controller */
d676 8
d699 18
a985 1

d1006 1
a1006 3
	usb_syncmem(&itd->dma, itd->offs + offsetof(ehci_itd_t, itd_ctl),
		    sizeof(itd->itd.itd_ctl), BUS_DMASYNC_POSTWRITE |
		    BUS_DMASYNC_POSTREAD);
d1008 4
a1011 3
	for (i = 0; i < EHCI_ITD_NUFRAMES; i++) {
		if (le32toh(itd->itd.itd_ctl[i]) & EHCI_ITD_ACTIVE)
			break;
d1014 7
a1020 2
	if (i == EHCI_ITD_NUFRAMES) {
		goto done; /* All 8 descriptors inactive, it's done */
a1022 2
	DPRINTFN(12, ("ehci_check_itd_intr: ex %p itd %p still active\n", ex,
			ex->itdstart));
d1024 1
d1085 19
d1118 1
a1118 1
				status = le32toh(itd->itd.itd_ctl[i]);
d1127 1
d1584 1
d1745 1
a1745 5
	ehci_isoc_trans_t t;
	ehci_isoc_bufr_ptr_t b, b2, b3;
	int i;

	printf("ITD: next phys=%X\n", itd->itd.itd_next);
d1747 1
d1749 13
a1761 5
		t = le32toh(itd->itd.itd_ctl[i]);
		printf("ITDctl %d: stat=%X len=%X ioc=%X pg=%X offs=%X\n", i,
		    EHCI_ITD_GET_STATUS(t), EHCI_ITD_GET_LEN(t),
		    EHCI_ITD_GET_IOC(t), EHCI_ITD_GET_PG(t),
		    EHCI_ITD_GET_OFFS(t));
d1763 1
a1763 1
	printf("ITDbufr: ");
d1765 1
a1765 1
		printf("%X,", EHCI_ITD_GET_BPTR(le32toh(itd->itd.itd_bufr[i])));
d1767 10
a1776 6
	b = le32toh(itd->itd.itd_bufr[0]);
	b2 = le32toh(itd->itd.itd_bufr[1]);
	b3 = le32toh(itd->itd.itd_bufr[2]);
	printf("\nep=%X daddr=%X dir=%d maxpkt=%X multi=%X\n",
	    EHCI_ITD_GET_EP(b), EHCI_ITD_GET_DADDR(b), EHCI_ITD_GET_DIR(b2),
	    EHCI_ITD_GET_MAXPKT(b2), EHCI_ITD_GET_MULTI(b3));
d1782 42
a1823 3
	printf("SITD %p next=%p prev=%p xfernext=%p physaddr=%X slot=%d\n",
			itd, itd->u.frame_list.next, itd->u.frame_list.prev,
			itd->xfer_next, itd->physaddr, itd->slot);
d1875 2
a1876 1
	epipe->nexttoggle = 0;
a1900 14
	if (speed != EHCI_QH_SPEED_HIGH && xfertype == UE_ISOCHRONOUS) {
#ifndef __riscos
		aprint_error_dev(sc->sc_dev, "error opening low/full speed "
		    "isoc endpoint.\n");
		aprint_normal_dev(sc->sc_dev, "a low/full speed device is "
		    "attached to a USB2 hub, and transaction translations are "
		    "not yet supported.\n");
		aprint_normal_dev(sc->sc_dev, "reattach the device to the "
		    "root hub instead.\n");
#endif
		DPRINTFN(1,("ehci_open: hshubaddr=%d hshubport=%d\n",
			    hshubaddr, hshubport));
		return USBD_INVAL;
	}
d1926 30
a1955 10
		sqh->qh.qh_endphub = htole32(
		    EHCI_QH_SET_MULT(1) |
		    EHCI_QH_SET_SMASK(xfertype == UE_INTERRUPT ? 0x02 : 0)
		    );
		if (speed != EHCI_QH_SPEED_HIGH)
			sqh->qh.qh_endphub |= htole32(
			    EHCI_QH_SET_PORT(hshubport) |
			    EHCI_QH_SET_HUBA(hshubaddr) |
			    EHCI_QH_SET_CMASK(0x08) /* XXX */
			);
d2023 2
a2024 1
		epipe->u.isoc.next_frame = 0;
d2080 1
d2082 3
d2177 1
d2179 2
d2187 1
a2187 1
			sc->sc_flist[itd->slot] = itd->itd.itd_next;
d2197 1
a2197 1
			prev->itd.itd_next = itd->itd.itd_next;
d2200 1
a2200 2
                	    sizeof(itd->itd.itd_next), BUS_DMASYNC_PREWRITE);

d3169 8
a3176 2
	frindex = (EOREAD4(sc, EHCI_FRINDEX) + 1) >> 3;
	previndex = (frindex != 0) ? frindex - 1 : sc->sc_flsize;
d3182 2
a3183 1
		if (itd->slot != frindex && itd->slot != previndex) {
d3205 6
d3218 1
a3218 1
	memset(&itd->itd, 0, sizeof(ehci_itd_t));
d3220 2
a3221 3
                    sizeof(itd->itd.itd_next), BUS_DMASYNC_PREWRITE |
                    BUS_DMASYNC_PREREAD);

d3225 1
a3225 1
	itd->slot = 0;
d3235 1
a3235 1

d3495 1
a3495 1
		    sizeof(itd->itd.itd_ctl),
d3499 1
a3499 1
			trans_status = le32toh(itd->itd.itd_ctl[i]);
d3501 1
a3501 1
			itd->itd.itd_ctl[i] = htole32(trans_status);
d3506 1
a3506 1
		    sizeof(itd->itd.itd_ctl),
d4000 1
d4003 1
d4192 1
a4192 1
        ehci_softc_t *sc = (ehci_softc_t *)pipe->device->bus;
d4196 1
d4301 15
a4315 2
Static usbd_status
ehci_device_isoc_start(usbd_xfer_handle xfer)
d4317 2
d4320 1
a4320 8
	usbd_device_handle dev;
	ehci_softc_t *sc;
	struct ehci_xfer *exfer;
	ehci_soft_itd_t *itd, *prev, *start, *stop;
	usb_dma_t *dma_buf;
	int i, j, k, frames, uframes, ufrperframe;
	int s, trans_count, offs, total_length;
	int frindex;
d4322 1
a4322 6
	start = NULL;
	prev = NULL;
	itd = NULL;
	trans_count = 0;
	total_length = 0;
	exfer = (struct ehci_xfer *) xfer;
d4324 1
a4324 2
	dev = xfer->pipe->device;
	epipe = (struct ehci_pipe *)xfer->pipe;
d4326 6
a4331 25
	/*
	 * To allow continuous transfers, above we start all transfers
	 * immediately. However, we're still going to get usbd_start_next call
	 * this when another xfer completes. So, check if this is already
	 * in progress or not
	 */

	if (exfer->itdstart != NULL)
		return USBD_IN_PROGRESS;

	DPRINTFN(2, ("ehci_device_isoc_start: xfer %p len %d flags %d\n",
			xfer, xfer->length, xfer->flags));

	if (sc->sc_dying)
		return USBD_IOERROR;

	/*
	 * To avoid complication, don't allow a request right now that'll span
	 * the entire frame table. To within 4 frames, to allow some leeway
	 * on either side of where the hc currently is.
	 */
	if ((1 << (epipe->pipe.endpoint->edesc->bInterval)) *
			xfer->nframes >= (sc->sc_flsize - 4) * 8) {
		printf("ehci: isoc descriptor requested that spans the entire frametable, too many frames\n");
		return USBD_INVAL;
d4333 2
d4336 2
a4337 3
#ifdef DIAGNOSTIC
	if (xfer->rqflags & URQ_REQUEST)
		panic("ehci_device_isoc_start: request\n");
d4339 1
a4339 4
	if (!exfer->isdone)
		printf("ehci_device_isoc_start: not done, ex = %p\n", exfer);
	exfer->isdone = 0;
#endif
d4341 6
a4346 11
	/*
	 * Step 1: Allocate and initialize itds, how many do we need?
	 * One per transfer if interval >= 8 microframes, fewer if we use
	 * multiple microframes per frame.
	 */

	i = epipe->pipe.endpoint->edesc->bInterval;
	if (i > 16 || i == 0) {
		/* Spec page 271 says intervals > 16 are invalid */
		DPRINTF(("ehci_device_isoc_start: bInvertal %d invalid\n", i));
		return USBD_INVAL;
d4348 2
d4351 5
a4355 3
	ufrperframe = max(1, USB_UFRAMES_PER_FRAME / (1 << (i - 1)));
	frames = (xfer->nframes + (ufrperframe - 1)) / ufrperframe;
	uframes = USB_UFRAMES_PER_FRAME / ufrperframe;
d4357 8
a4364 4
	if (frames == 0) {
		DPRINTF(("ehci_device_isoc_start: frames == 0\n"));
		return USBD_INVAL;
	}
d4366 1
a4366 2
	dma_buf = &xfer->dmabuf;
	offs = 0;
d4368 3
a4370 96
	for (i = 0; i < frames; i++) {
		int froffs = offs;
		itd = ehci_alloc_itd(sc);

		if (prev != NULL) {
			prev->itd.itd_next =
			    htole32(itd->physaddr | EHCI_LINK_ITD);
			usb_syncmem(&itd->dma,
			    itd->offs + offsetof(ehci_itd_t, itd_next),
                	    sizeof(itd->itd.itd_next), BUS_DMASYNC_POSTWRITE);

			prev->xfer_next = itd;
	    	} else {
			start = itd;
		}

		/*
		 * Step 1.5, initialize uframes
		 */
		for (j = 0; j < EHCI_ITD_NUFRAMES; j += uframes) {
			/* Calculate which page in the list this starts in */
			int addr = DMAADDR(dma_buf, froffs);
			addr = EHCI_PAGE_OFFSET(addr);
			addr += (offs - froffs);
			addr = EHCI_PAGE(addr);
			addr /= EHCI_PAGE_SIZE;

			/* This gets the initial offset into the first page,
			 * looks how far further along the current uframe
			 * offset is. Works out how many pages that is.
			 */

			itd->itd.itd_ctl[j] = htole32 ( EHCI_ITD_ACTIVE |
			    EHCI_ITD_SET_LEN(xfer->frlengths[trans_count]) | 
			    EHCI_ITD_SET_PG(addr) |
			    EHCI_ITD_SET_OFFS(EHCI_PAGE_OFFSET(DMAADDR(dma_buf,offs))));

			total_length += xfer->frlengths[trans_count];
			offs += xfer->frlengths[trans_count];
			trans_count++;

			if (trans_count >= xfer->nframes) { /*Set IOC*/
				itd->itd.itd_ctl[j] |= htole32(EHCI_ITD_IOC);
				break;
			}
		}	

		/* Step 1.75, set buffer pointers. To simplify matters, all
		 * pointers are filled out for the next 7 hardware pages in
		 * the dma block, so no need to worry what pages to cover
		 * and what to not.
		 */

		for (j = 0; j < EHCI_ITD_NBUFFERS; j++) {
			/*
			 * Don't try to lookup a page that's past the end
			 * of buffer
			 */
			int page_offs = EHCI_PAGE(froffs + (EHCI_PAGE_SIZE * j));
#ifdef __riscos
			if (page_offs >= xfer->length) /* I think this is correct! */
#else
			if (page_offs >= dma_buf->block->size)
#endif
				break;

			long long page = DMAADDR(dma_buf, page_offs);
			page = EHCI_PAGE(page);
			itd->itd.itd_bufr[j] =
			    htole32(EHCI_ITD_SET_BPTR(page));
			itd->itd.itd_bufr_hi[j] =
			    htole32(page >> 32);
		}

		/*
		 * Other special values
		 */

		k = epipe->pipe.endpoint->edesc->bEndpointAddress;
		itd->itd.itd_bufr[0] |= htole32(EHCI_ITD_SET_EP(UE_GET_ADDR(k)) |
		    EHCI_ITD_SET_DADDR(epipe->pipe.device->address));

		k = (UE_GET_DIR(epipe->pipe.endpoint->edesc->bEndpointAddress))
		    ? 1 : 0;
		j = UGETW(epipe->pipe.endpoint->edesc->wMaxPacketSize);
		itd->itd.itd_bufr[1] |= htole32(EHCI_ITD_SET_DIR(k) |
		    EHCI_ITD_SET_MAXPKT(UE_GET_SIZE(j)));

		/* FIXME: handle invalid trans */
		itd->itd.itd_bufr[2] |= 
		    htole32(EHCI_ITD_SET_MULTI(UE_GET_TRANS(j)+1));

		usb_syncmem(&itd->dma,
		    itd->offs + offsetof(ehci_itd_t, itd_next),
                    sizeof(ehci_itd_t),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
d4372 1
a4372 2
		prev = itd;
	} /* End of frame */
d4374 1
a4374 3
	stop = itd;
	stop->xfer_next = NULL;
	exfer->isoc_len = total_length;
d4376 3
a4378 2
	usb_syncmem(&exfer->xfer.dmabuf, 0, total_length,
		BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d4380 1
a4380 43
	/*
	 * Part 2: Transfer descriptors have now been set up, now they must
	 * be scheduled into the period frame list. Erk. Not wanting to
	 * complicate matters, transfer is denied if the transfer spans
	 * more than the period frame list.
	 */

	s = splusb();

	/* Start inserting frames */
	if (epipe->u.isoc.cur_xfers > 0) {
		frindex = epipe->u.isoc.next_frame;
	} else {
		frindex = EOREAD4(sc, EHCI_FRINDEX);
		frindex = frindex >> 3; /* Erase microframe index */
		frindex += 2;
	}

	if (frindex >= sc->sc_flsize)
		frindex &= (sc->sc_flsize - 1);

	/* What's the frame interval? */
	i = (1 << (epipe->pipe.endpoint->edesc->bInterval - 1));
	if (i / USB_UFRAMES_PER_FRAME == 0)
		i = 1;
	else
		i /= USB_UFRAMES_PER_FRAME;

	itd = start;
	for (j = 0; j < frames; j++) {
		if (itd == NULL)
			panic("ehci: unexpectedly ran out of isoc itds, isoc_start\n");

		itd->itd.itd_next = sc->sc_flist[frindex];
		if (itd->itd.itd_next == 0)
			/* FIXME: frindex table gets initialized to NULL
			 * or EHCI_NULL? */
			itd->itd.itd_next = EHCI_NULL;

		usb_syncmem(&itd->dma,
		    itd->offs + offsetof(ehci_itd_t, itd_next),
                    sizeof(itd->itd.itd_next),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
a4381 1
		sc->sc_flist[frindex] = htole32(EHCI_LINK_ITD | itd->physaddr);
d4383 1
a4383 4
		usb_syncmem(&sc->sc_fldma,
		    sizeof(ehci_link_t) * frindex,
                    sizeof(ehci_link_t),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
a4391 3
		frindex += i;
		if (frindex >= sc->sc_flsize)
			frindex -= sc->sc_flsize;
d4393 1
a4393 1
		itd = itd->xfer_next;
a4394 1

d4401 1
a4401 1
	exfer->sqtdstart = NULL;
d4406 4
a4409 2
	xfer->status = USBD_IN_PROGRESS;
	xfer->done = 0;
d4411 1
a4411 1

d4414 1
a4414 1
		ehci_waitintr(sc, xfer);
d4420 99
a4518 5
Static void
ehci_device_isoc_abort(usbd_xfer_handle xfer)
{
	DPRINTFN(1, ("ehci_device_isoc_abort: xfer = %p\n", xfer));
	ehci_abort_isoc_xfer(xfer, USBD_CANCELLED);
d4521 1
a4521 2
Static void
ehci_device_isoc_close(usbd_pipe_handle pipe)
d4523 71
a4593 2
	DPRINTFN(1, ("ehci_device_isoc_close: nothing in the pipe to free?\n"));
}
d4595 1
a4595 7
Static void
ehci_device_isoc_done(usbd_xfer_handle xfer)
{
	struct ehci_xfer *exfer;
	ehci_softc_t *sc;
	struct ehci_pipe *epipe;
	int s;
d4597 4
a4600 3
	exfer = EXFER(xfer);
	sc = (ehci_softc_t *)xfer->pipe->device->bus;
	epipe = (struct ehci_pipe *) xfer->pipe;
d4602 3
a4604 6
	s = splusb();
	epipe->u.isoc.cur_xfers--;
	mutex_enter(&sc->sc_intrhead_lock);
	if (xfer->status != USBD_NOMEM && ehci_active_intr_list(exfer)) {
		ehci_del_intr_list(sc, exfer);
		ehci_rem_free_itd_chain(sc, exfer);
a4605 2
	mutex_exit(&sc->sc_intrhead_lock);
	splx(s);
d4607 3
a4609 2
	usb_syncmem(&xfer->dmabuf, 0, xfer->length, BUS_DMASYNC_POSTWRITE |
                    BUS_DMASYNC_POSTREAD);
d4611 1
@


1.17
log
@Merge in some EHCI fixes from NetBSD. Other minor changes.
Detail:
  build/Version - Bump EHCIDriver version number
  build/c/ehcihal, build/c/ehcimodule, build/c/ohcimodule - Use the HAL USB controller type & flag definitions from Hdr:HALEntries instead of using magic numbers
  build/c/ehcimodule - Avoid double-read of hardware register in debug version of bus_space_read_4(); ensures that we report the value that's actually returned to the driver
  dev/usb/c/ehci - Merge in the following revisions from NetBSD:
  - 1.172, 1.173, 1.178, 1.193 - Support for controllers with embedded transaction translators
  - 1.174 - alloc_sqtd_chain() fix for short packets that end on page boundaries
  - 1.179 - ehci_set_qh_qtd() fixed to terminate alternate next qTD pointer with EHCI_NULL, not 0
  dev/usb/h/ehcireg - Updated to latest NetBSD version (1.34)
  dev/usb/h/ehcivar - Merge in revision 1.38 (ETTF support)
Admin:
  Tested on BB-xM


Version 0.88. Tagged as 'NetBSD-0_88'
@
text
@d279 1
@


1.16
log
@Add workaround for what looks like a bug in the DM37x EHCI controller
Detail:
  dev/usb/c/ehci - Force all EHCI data buffers to be 512 byte aligned.
  This is a workaround for what I believe is a bug in the DM37x EHCI controller - It looks like if the last packet of a bulk in transfer is a short packet, and that packet crosses a page boundary, then the second half of the packet doesn't seem to be written out to the correct address in memory.
  Version - increased EHCI module version number
Admin:
  Tested on rev A2 BB-xM
  Fixes issue reported on forums with unreliable USB ethernet:
  http://www.riscosopen.org/forum/fourms/5/topics/828#posts-9691


Version 0.65. Tagged as 'NetBSD-0_65'
@
text
@d98 2
d454 3
d502 11
d1729 11
a1739 1
		hshubaddr = dev->myhsport->parent->address;
d1978 1
a1978 1
	sqh->qh.qh_qtd.qtd_altnext = 0;
d2484 2
a2485 2
		DPRINTFN(8,("ehci_root_ctrl_start: port status=0x%04x\n",
			    v));
d2487 9
d2541 7
a2547 2
			if (EHCI_PS_IS_LOWSPEED(v)) {
				/* Low speed device, give up ownership. */
d2555 4
d2560 1
d2565 16
a2580 7
			/* Terminate reset sequence. */
			EOWRITE4(sc, port, v);
			/* Wait for HC to complete reset. */
			usb_delay_ms(&sc->sc_bus, EHCI_PORT_RESET_COMPLETE);
			if (sc->sc_dying) {
				err = USBD_IOERROR;
				goto ret;
d2582 1
d2978 2
a2979 1
		dataphys += curlen;
@


1.15
log
@Fix memory overwrites in root hub emulation
Detail:
  dev/usb/c/ehci, dev/usb/c/ohci - Fixed device descriptor and config descriptor reads writing outside the destination buffer if the buffer was small enough.
  build/Version - Incremented EHCI & OHCI version numbers & dates
Admin:
  Tested in OMAP3 ROM & Iyonix ROM softload


Version 0.63. Tagged as 'NetBSD-0_63'
@
text
@d1401 4
a1404 1
	err = usb_allocmem(&sc->sc_bus, size, 0, dma);
@


1.14
log
@Update HAL USB code for new HAL_KbdScanInterrupt behaviour. Fix data aborts during keyboard scanning.
Detail:
  build/c/usbhal, build/h/usbhal - Updated USBHAL_KbdScanInterrupt to behave the same way HAL_KbdScanInterrupt is now expected to behave.
  build/c/ehci, build/c/ohci - Fixed some root hub emulation code which was writing to a global structure before copying it into the destination buffer. Although this works fine in ROM modules it was causing data aborts in the USB HAL libraries due to lack of automatic RW data relocation by the compiler.
  build/Version - Updated version numbers
Admin:
  Tested on rev C2 BB.


Version 0.62. Tagged as 'NetBSD-0_62'
@
text
@d2152 2
d2203 2
d2207 1
a2207 1
			memcpy(buf, (void*) &ehci_devd, l);
d2209 1
a2209 1
			memcpy(buf, &ehci_devd, l);
a2210 1
			USETW(((usb_device_descriptor_t *) buf)->idVendor, sc->sc_id_vendor);
d2238 2
d2242 1
a2242 1
			memcpy(buf, (void*) &ehci_confd, l);
d2244 1
a2244 1
			memcpy(buf, &ehci_confd, l);
a2245 2
			((usb_config_descriptor_t *)buf)->bDescriptorType =
				value >> 8;
@


1.13
log
@Add the ability to build the USB drivers as HAL-compatible static libraries
Detail:
  build/Makefile, build/OBJEHCIDriver, build/OBJOHCIDriver, build/OBJUSBDriver - Modified makefiles to build the HAL libs during the export libs phase
  build/!MkHAL,fd7 - Handy script for building the HAL libs
  build/Hdr/usbhal - Header containing definitions for the assembler code. Also gets exported so that HALs know how much workspace to reserve.
  build/c/usbhal - HAL version of usbmodule.c & port.c. Also contains the keyboard scan code, adapted from the code in the Tungsten HAL.
  build/s/porthal - Assembler versions of some port.c routines that were easier to do in assembler than C
  build/s/halheap - OS_Heap code that's been adapted for use in the HAL. Could easily be changed into a standalone library instead of being part of the HAL USB libs. Supports memory-efficient allocation of aligned blocks.
  build/c/ehcihal - HAL version of ehcimodule.c. Currently only supports EHCI controllers exposed via HAL_USBControllerInfo (i.e. no PCI support)
  build/c/ehcimodule, build/c/ohcimodule, build/c/port - Moved riscos_irq_clear into port.c. Removed unused microtime() function.
  build/c/usbmouse - Strip out some debug-related code in non-debug builds
  build/Version - Updated version numbers
  dev/usb/c/ehci, dev/usb/h/ehcivar - Adapted to add support for the HAL build. Apart from the base changes, the code has also been tweaked to significantly reduce the amount of memory used at runtime by the HAL version of the driver.
  dev/usb/c/hid, dev/usb/c/uhub, dev/usb/c/usb, dev/usb/c/usb_quirks, dev/usb/c/usb_subr, dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/c/usbroothub_subr - Changes to support HAL builds. Mainly disabling bits that won't work in the HAL or disabling bits for RISC OS in general if they weren't being used in the first place.
  dev/usb/c/ohci, dev/usb/h/ohcivar - Basic changes to support HAL builds. However HAL OHCI support is still incomplete.
  dev/usb/h/usb_port - Added support for the HAL build. Also tweaked logprintf definition to get rid of logprintf calls entirely in non-debug builds.
  dev/usb/h/usbdivar - Added support for the HAL build.
  dev/usb/h/usbhal - New header used by the HAL build. Gets included by every C file to ensure the compiler doesn't use sb, and contains structs/macros to allow access to the shared workspace.
Admin:
  HAL & non-HAL builds tested on rev C2 BB, rev A2 BB-xM, rev C1 TouchBook.
  Non-HAL builds tested with Iyonix ROM softload.
  Needs latest Kernel source for OSEntries.h export.


Version 0.59. Tagged as 'NetBSD-0_59'
@
text
@d2055 1
a2055 1
Static usb_device_descriptor_t ehci_devd = {
a2201 1
			USETW(ehci_devd.idVendor, sc->sc_id_vendor);
d2207 1
@


1.12
log
@Update EHCI driver to NetBSD latest (as of 10/07/2010), improve DeviceFS interface
Detail:
  EHCI driver update:
    dev/usb/c/ehci - Updated to latest NetBSD version, except for revisions 1.134 and 1.135 which are too invasive to merge in without updating the rest of the USB stack. This new version brings lots of bug fixes, and adds (untested on RISC OS) support for EHCI isochronous transfers.
    dev/usb/h/ehcivar - Updated to latest NetBSD version, except for the sc_bus splitting that was held back from the ehci.c update
    dev/usb/h/usb, dev/usb/h/usbdi, dev/usb/usbdivar - partial update to latest as required/possible
    dev/usb/c/usb_quirks, dev/usb/h/ehcireg, dev/usb/h/usb_mem, dev/usb/h/usb_quirks, dev/usb/h/usbhid, dev/usb/usbdevs, dev/usb/devlist2h.awk, dev/wscons/h/wsconsio, dev/wscons/h/wsmousevar - Updated to latest NetBSD versions
    dev/usb/c/usbroothub_subr, dev/usb/h/usbroothub_subr - New files brought in from NetBSD sources for use with new EHCI driver
    build/objehcidriver - Added usbroorhub_subr to EHCI driver
    dev/usb/h/usb_port - Added extra dummy functions as required by new EHCI driver
    dev/build/c/port - Added extra parameter to callout_init as required by new EHCI driver
  DeviceFS improvements:
    build/c/usbmodule - Added DeviceFSCallDevice_GetHandles2 as a replacement for Thomas Milius's backwards-incompatible GetHandles changes. Added DeviceFSCallDevice_GetSetOptions call to control RX padding and TX force-short-xfer features. These features can also be controlled at endpoint creation time by new fields in the filename. Also fixed packet padding to not fill the buffer with garbage or potentially crash when the padded area is more than one packet in length.
  New bus registration API:
    Changes made to the data structures that are shared between the modules means that new checks are needed to ensure USB modules with incompatible APIs are not used with one another.
    build/h/usbdivar - Since this seems to be the file containing the main structures that are shared, it now has a #define at the top indicating the first version of the USBDriver module that implemented the data structures within. This version number is used to check that the driver modules are compatible.
    build/cmhg/usbmodhead, build/h/usbdriver, build/c/usbmodule - Add a new SWI, USBDriver_Version, to return the version number of the USBDriver module. Used for both intra-stack API version checks and can be useful for external code that wants to query DeviceFS feature availability.
    build/c/usbmodule, build/c/ehcimodule, build/c/ohcimodule - Updated USBDriver_RegisterBus SWI and the code that calls it to pass the API version number (as defined in usbdivar.h) to USBDriver when attempting to reigster the bus. USBDriver then ensures the version matches that of itself, and if not refuses to allow the bus to register. EHCI & OHCI modules also check that USBDriver is new enough to implement this behaviour via the USBDriver_Version SWI.
  And finally:
    build/version - Incremented module version numbers.
    build/doc/usb - Updated with details of new features
Admin:
  Tested in ROM softload on Iyonix & beagleboard. Beagleboard hub issues seem to be resolved, and there are no new bugs that I can see.


Version 0.52. Tagged as 'NetBSD-0_52'
@
text
@d61 3
d264 4
d277 4
d337 3
d350 1
d352 15
a366 1
#if defined (__riscos)
d401 1
a401 1
#if defined (__riscos)
d500 6
d680 1
a680 1
			riscos_irqclear();
d718 1
a718 1
        riscos_irqclear();
d2709 1
a2709 1
			  EHCI_PAGE_SIZE, &dma);
d2752 1
a2752 1
			  EHCI_PAGE_SIZE, &dma);
d2983 1
a2983 1
				EHCI_PAGE_SIZE, &dma);
@


1.11
log
@Add support for HAL enumerated USB EHCI controllers, use HAL_IRQClear when clearing EHCI/OHCI controller interrupts
Detail:
  * HAL enumeration of EHCI controllers is performed in the same manner as for OHCI, and protected by #ifdef RHENIUM. HAL_USBControllerInfo must return with the usbinfo type field set to 1 to indicate EHCI.
  * HAL_IRQClear is now called by the EHCI & OHCI modules after clearing the interrupt flag in the USB controller, to allow the HAL to reset the interrupt controller if required (e.g. for OMAP3)
  * EHCI module (for HAL EHCI controllers) now has the option of forcing all EHCI register access to be 32bit size & alignment (requirement is indicated in OMAP3 TRM, although USB did seem to function fine without)
  build/c/ehcimodule - Add enumeration of HAL USB controllers. Add support for forcing all EHCI register access to be 32bit size & alignment. Add riscos_irqclear() implementation. Guard against unexpected behaviour if PCI module isn't present.
  build/c/ohcimodule - Add riscos_irqclear() implementation. Guard against unexpected behaviour if PCI module isn't present.
  dev/usb/c/ehci, dev/usb/c/ohci - call riscos_irqclear() when appropriate
  dev/usb/h/usb_port - riscos_irqclear() prototype
Admin:
  Tested on rev C2 beagleboard. Untested on Iyonix, but should be fine.


Version 0.47. Tagged as 'NetBSD-0_47'
@
text
@d1 1
a1 1
/*      $NetBSD: ehci.c,v 1.91 2005/02/27 00:27:51 perry Exp $ */
d4 1
a4 1
 * Copyright (c) 2004 The NetBSD Foundation, Inc.
d8 2
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) and by Charles M. Hannum.
d44 1
a44 1
 * http://developer.intel.com/technology/usb/download/ehci-r10.pdf
d46 1
a46 1
 * http://www.usb.org/developers/docs/usb_20.zip
d54 2
a55 9
 * 2) The EHCI driver lacks support for interrupt isochronous transfers, so
 *    devices using them don't work.
 *    Interrupt transfers are not difficult, it's just not done.
 *
 * 3) The meaty part to implement is the support for USB 2.0 hubs.
 *    They are quite complicated since the need to be able to do
 *    "transaction translation", i.e., converting to/from USB 2 and USB 1.
 *    So the hub driver needs to handle and schedule these things, to
 *    assign place in frame where different devices get to go. See chapter
d58 1
a58 1
 * 4) command failures are not recovered correctly
d72 6
a78 1
#include <machine/bus.h>
d89 1
d91 5
a95 2


d98 2
a99 2
#define DPRINTF(x)     if (ehcidebug) logprintf x
#define DPRINTFN(n,x)  if (ehcidebug>(n)) logprintf x
a100 3
#ifndef __NetBSD__
#define bitmask_snprintf(q,f,b,l) snprintf((b), (l), "%b", (q), (f))
#endif
a104 9
#ifdef __riscos
#define printf logprintf
#endif


#ifdef __riscos
#define MS_TO_TICKS(ms) ((ms) * hz / 1000)
#endif

d108 2
a109 1
        int nexttoggle;
a119 1
			/*ehci_soft_qtd_t *setup, *data, *stat;*/
d122 3
a124 3
                struct {
                        u_int length;
                } intr;
d130 4
a133 1
		/* XXX */
a136 4

Static void		ehci_shutdown(void *);
Static void		ehci_power(int, void *);

d143 2
d148 1
a194 1
Static int		ehci_str(usb_string_descriptor_t *, int, char *);
a195 2
Static void		ehci_pcd_able(ehci_softc_t *, int);
Static void		ehci_pcd_enable(void *);
d209 7
d218 2
a219 2
Static usbd_status      ehci_device_setintr(ehci_softc_t *, ehci_soft_qh_t *,
                            int ival);
d232 1
a232 1
Static void		ehci_dump(void);
d239 4
d253 7
a259 7
	LIST_INSERT_HEAD(&(sc)->sc_intrhead, (ex), inext);
#define ehci_del_intr_list(ex) \
        do { \
                LIST_REMOVE((ex), inext); \
                (ex)->inext.le_prev = NULL; \
        } while (0)
#define ehci_active_intr_list(ex) ((ex)->inext.le_prev != NULL)
d326 11
d365 1
a365 1
	u_int32_t version, sparams, cparams, hcr;
d370 1
a370 1
	
d405 3
a407 3
	version = EREAD2(sc, EHCI_HCIVERSION);
	logprintf("%s: EHCI version %x.%x\n", USBDEVNAME(sc->sc_bus.bdev),
	       version >> 8, version & 0xff);
d412 4
a415 5
        ncomp = EHCI_HCS_N_CC(sparams);
        if (ncomp != sc->sc_ncomp) {
                logprintf("%s: wrong number of companions (%d != %d)\n",
		       USBDEVNAME(sc->sc_bus.bdev),
                       ncomp, sc->sc_ncomp);
d419 2
a420 2
                if (ncomp < sc->sc_ncomp)
                        sc->sc_ncomp = ncomp;
d423 1
a423 1
		logprintf("%s: companion controller%s, %d port%s each:",
d430 1
a430 1
			logprintf(" %s", USBDEVNAME(sc->sc_comps[i]->bdev));
d432 1
a432 1
		logprintf("\n");
d437 1
d446 2
a447 2
        usb_setup_reserve(sc, &sc->sc_dma_reserve, sc->sc_bus.dmatag,
            USB_MEM_RESERVE);
d468 3
a470 2
        /* XXX need proper intr scheduling */
        sc->sc_rand = 96;
d473 3
a475 3
        case 0: sc->sc_flsize = 1024; break;
        case 1: sc->sc_flsize = 512; break;
        case 2: sc->sc_flsize = 256; break;
d478 2
a479 2
        err = usb_allocmem(&sc->sc_bus, sc->sc_flsize * sizeof(ehci_link_t),
			   EHCI_FLALIGN_ALIGN, &sc->sc_fldma);
d484 17
a500 1
        EOWRITE4(sc, EHCI_PERIODICLISTBASE, DMAADDR(&sc->sc_fldma, 0));
a505 5
#ifndef __riscos
	sc->sc_powerhook = powerhook_establish(ehci_power, sc);
	sc->sc_shutdownhook = shutdownhook_establish(ehci_shutdown, sc);
#endif

d508 46
a553 41
        /*
         * Allocate the interrupt dummy QHs. These are arranged to give poll
         * intervals that are powers of 2 times 1ms.
         */
        for (i = 0; i < EHCI_INTRQHS; i++) {
                sqh = ehci_alloc_sqh(sc);
                if (sqh == NULL) {
                        err = USBD_NOMEM;
                        goto bad1;
                }
                sc->sc_islots[i].sqh = sqh;
        }
        for (i = 0; i < EHCI_INTRQHS; i++) {
                sqh = sc->sc_islots[i].sqh;
                if (i == 0) {
                        /* The last (1ms) QH terminates. */
                        sqh->qh.qh_link = EHCI_NULL;
                        sqh->next = NULL;
                } else {
                        int val = i + 1, b = 0, v2 = val;
                        while (v2 >>= 1) b++;
                        val = ((val & ~(1<<b)) | (1<<(b - 1)))-1;
                        /* Otherwise the next QH has half the poll interval */
                        sqh->next = sc->sc_islots[val].sqh;
                        sqh->qh.qh_link = htole32(sqh->next->physaddr |
                            EHCI_LINK_QH);
                }
                sqh->qh.qh_endp = htole32(EHCI_QH_SET_EPS(EHCI_QH_SPEED_HIGH));
                sqh->qh.qh_curqtd = EHCI_NULL;
                sqh->next = NULL;
                sqh->qh.qh_qtd.qtd_next = EHCI_NULL;
                sqh->qh.qh_qtd.qtd_altnext = EHCI_NULL;
                sqh->qh.qh_qtd.qtd_status = htole32(EHCI_QTD_HALTED);
                sqh->sqtd = NULL;
        }
        /* Point the frame list at the last level (128ms). */
        for (i = 0; i < sc->sc_flsize; i++) {
                sc->sc_flist[i] = htole32(EHCI_LINK_QH |
                    sc->sc_islots[EHCI_IQHIDX(EHCI_IPOLLRATES - 1,
                    i)].sqh->physaddr);
        }
d573 2
d585 1
a585 1
	usb_callout_init(sc->sc_tmo_pcd);
d587 1
a587 4
	lockinit(&sc->sc_doorbell_lock, PZERO, "ehcidb", 0, 0);

	/* Enable interrupts */
	EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);
d591 1
a591 1
                 EHCI_CMD_ITC_2 | /* 2 microframes interrupt delay */
d594 1
a594 1
                 EHCI_CMD_PSE |
d611 4
d631 1
a631 1
	if (sc == NULL || sc->sc_dying)
d636 1
a636 1
                u_int32_t intrs = EHCI_STS_INTRS(EOREAD4(sc, EHCI_USBSTS));
d638 2
a639 2
                if (intrs)
                        EOWRITE4(sc, EHCI_USBSTS, intrs); /* Acknowledge */
d641 1
a641 1
		logprintf("ehci_intr: ignored interrupt while polling\n");
d663 1
a663 1
                printf("ehci_intr1: sc == NULL\n");
a668 1

d673 1
a673 1
        DPRINTFN(7, ("ehci_intr1: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n",
d679 1
a679 1
        EOWRITE4(sc, EHCI_USBSTS, intrs); /* Acknowledge */
d693 3
a695 3
		DPRINTF(("ehci_intr1: %s %s\n",
			 eintrs & EHCI_STS_INT ? "INT" : "",
			 eintrs & EHCI_STS_ERRINT ? "ERRINT" : ""));
d704 1
a704 1
                printf("%s: unrecoverable error, controller halted\n",
a709 7
		/*
		 * Disable PCD interrupt for now, because it will be
		 * on until the port has been reset.
		 */
		ehci_pcd_able(sc, 0);
		/* Do not allow RHSC interrupts > 1 per second */
                usb_callout(sc->sc_tmo_pcd, hz, ehci_pcd_enable, sc);
d719 1
a719 1
                printf("%s: blocking intrs 0x%x\n",
d721 1
a721 1
        }
a729 21
void
ehci_pcd_able(ehci_softc_t *sc, int on)
{
	DPRINTF( ("ehci_pcd_able: on=%d\n", on));
	if (on)
		sc->sc_eintrs |= EHCI_STS_PCD;
	else
		sc->sc_eintrs &= ~EHCI_STS_PCD;
	EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);
#ifdef __riscos
	EOREAD4(sc, EHCI_USBINTR); /* Acknowledge */
#endif
}

void
ehci_pcd_enable(void *v_sc)
{
	ehci_softc_t *sc = v_sc;

	ehci_pcd_able(sc, 1);
}
d731 1
a731 1
void
d760 1
a760 1
void
d764 1
a764 1
        struct ehci_xfer *ex, *nextex;
d777 2
a778 2
        for (ex = LIST_FIRST(&sc->sc_intrhead); ex; ex = nextex) {
                nextex = LIST_NEXT(ex, inext);
d780 7
a786 1
        }
d799 1
a799 1
void
d802 1
a802 2
	ehci_soft_qtd_t *sqtd, *lsqtd;
	u_int32_t status;
d806 15
d822 1
a822 1
                printf("ehci_check_intr: sqtdstart=NULL\n");
d825 1
d829 1
a829 1
                printf("ehci_check_intr: lsqtd==0\n");
d838 4
d845 4
d850 3
d860 1
a860 1
                        if (EHCI_QTD_GET_BYTES(status) != 0)
d865 3
d872 48
a919 1
	usb_uncallout(ex->xfer.timeout_handle, ehci_timeout, ex);
d923 1
a923 1
void
d928 2
a929 2
        ehci_soft_qtd_t *sqtd, *lsqtd;
        u_int32_t status = 0, nstatus = 0;
a930 1
        uint pkts_left;
d939 1
a939 1
                        printf("ehci_idone: ex is done!\n   ");
d942 1
a942 1
                        printf("ehci_idone: ex=%p is done!\n", ex);
a949 1

d963 49
a1011 1
        lsqtd = ex->sqtdend;
d1013 3
a1015 1
        for (sqtd = ex->sqtdstart; sqtd != lsqtd->nextqtd; sqtd=sqtd->nextqtd) {
d1021 1
a1021 5
                /* halt is ok if descriptor is last, and complete */
                if (sqtd->qtd.qtd_next == EHCI_NULL &&
                    EHCI_QTD_GET_BYTES(status) == 0)
                        status &= ~EHCI_QTD_HALTED;
		if (EHCI_QTD_GET_PID(status) !=	EHCI_QTD_PID_SETUP)
d1025 12
a1036 8
        /* 
         * If there are left over TDs we need to update the toggle.
         * The default pipe doesn't need it since control transfers
         * start the toggle at 0 every time.
         */
        if (sqtd != lsqtd->nextqtd && 
            xfer->pipe->device->default_pipe != xfer->pipe) {
                printf("ehci_idone: need toggle update status=%08x nstatus=%08x\n", status, nstatus);
d1038 2
a1039 2
                ehci_dump_sqh(epipe->sqh);
                ehci_dump_sqtds(ex->sqtdstart);
d1041 1
a1041 1
                epipe->nexttoggle = EHCI_QTD_GET_TOGGLE(nstatus);
a1043 9
        /* 
         * For a short transfer we need to update the toggle for the missing
         * packets within the qTD.
         */
        pkts_left = EHCI_QTD_GET_BYTES(status) /
            UGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize);
        epipe->nexttoggle ^= pkts_left % 2;

	status &= EHCI_QTD_STATERRS;
d1047 1
a1047 1
        if (status & EHCI_QTD_HALTED) {
d1052 3
a1054 3
		bitmask_snprintf((u_int32_t)status,
                                 "\20\7HALTED\6BUFERR\5BABBLE\4XACTERR"
                                 "\3MISSED", sbuf, sizeof(sbuf));
d1068 1
a1068 2
                DPRINTFN((status == EHCI_QTD_HALTED) ? 2 : 0,
			 ("ehci_idone: error, addr=%d, endpt=0x%02x, "
d1078 7
a1084 1
		if (status == EHCI_QTD_HALTED)
d1086 1
a1086 1
		else
d1088 10
d1102 4
d1115 1
a1115 1
void
d1118 1
a1118 2
	int timo = xfer->timeout;
	int usecs;
d1122 1
a1122 1
	for (usecs = timo * 1000000 / hz; usecs > 0; usecs -= 1000) {
d1147 1
a1147 1
void
d1165 11
d1189 1
a1189 8
	usb_uncallout(sc->sc_tmo_pcd, ehci_pcd_enable, sc);

#ifndef __riscos
	if (sc->sc_powerhook != NULL)
		powerhook_disestablish(sc->sc_powerhook);
	if (sc->sc_shutdownhook != NULL)
		shutdownhook_disestablish(sc->sc_shutdownhook);
#endif
d1194 4
d1203 1
d1205 1
a1205 1
ehci_activate(device_ptr_t self, enum devact act)
d1207 1
a1207 4
#ifndef __riscos
	struct ehci_softc *sc = (struct ehci_softc *)self;
#endif
	int rv = 0;
a1209 4
	case DVACT_ACTIVATE:
		return (EOPNOTSUPP);
                break;

a1211 2
		if (sc->sc_child != NULL)
			rv = config_deactivate(sc->sc_child);
d1214 3
a1216 1
		break;
a1217 1
	return (rv);
d1226 3
d1230 2
a1231 2
void
ehci_power(int why, void *v)
d1233 31
a1263 4
#ifndef __riscos
	ehci_softc_t *sc = v;
        u_int32_t cmd, hcr;
        int s, i;
d1265 4
a1268 5
#ifdef EHCI_DEBUG
	DPRINTF(("ehci_power: sc=%p, why=%d\n", sc, why));
        if (ehcidebug > 0)
	ehci_dump_regs(sc);
#endif
d1270 1
a1270 73
	s = splhardusb();
	switch (why) {
	case PWR_SUSPEND:
	case PWR_STANDBY:
		sc->sc_bus.use_polling++;

                sc->sc_cmd = EOREAD4(sc, EHCI_USBCMD);

                cmd = sc->sc_cmd & ~(EHCI_CMD_ASE | EHCI_CMD_PSE);
                EOWRITE4(sc, EHCI_USBCMD, cmd);

                for (i = 0; i < 100; i++) {
                        hcr = EOREAD4(sc, EHCI_USBSTS) &
                            (EHCI_STS_ASS | EHCI_STS_PSS);
                        if (hcr == 0)
                                break;

                        usb_delay_ms(&sc->sc_bus, 1);
		}
                if (hcr != 0) {
                        printf("%s: reset timeout\n",
                            USBDEVNAME(sc->sc_bus.bdev));
                }

                cmd &= ~EHCI_CMD_RS;
                EOWRITE4(sc, EHCI_USBCMD, cmd);

                for (i = 0; i < 100; i++) {
                        hcr = EOREAD4(sc, EHCI_USBSTS) & EHCI_STS_HCH;
                        if (hcr == EHCI_STS_HCH)
                                break;

                        usb_delay_ms(&sc->sc_bus, 1);
                }
                if (hcr != EHCI_STS_HCH) {
                        printf("%s: config timeout\n",
                            USBDEVNAME(sc->sc_bus.bdev));
                }

		sc->sc_bus.use_polling--;
		break;
	case PWR_RESUME:
		sc->sc_bus.use_polling++;

                /* restore things in case the bios sucks */
                EOWRITE4(sc, EHCI_CTRLDSSEGMENT, 0);
                EOWRITE4(sc, EHCI_PERIODICLISTBASE, DMAADDR(&sc->sc_fldma, 0));
                EOWRITE4(sc, EHCI_ASYNCLISTADDR,
                    sc->sc_async_head->physaddr | EHCI_LINK_QH);
                EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);

                EOWRITE4(sc, EHCI_USBCMD, sc->sc_cmd);

                for (i = 0; i < 100; i++) {
                        hcr = EOREAD4(sc, EHCI_USBSTS) & EHCI_STS_HCH;
                        if (hcr != EHCI_STS_HCH)
                                break;

                        usb_delay_ms(&sc->sc_bus, 1);
                }
                if (hcr == EHCI_STS_HCH) {
                        printf("%s: config timeout\n",
                            USBDEVNAME(sc->sc_bus.bdev));
                }

                usb_delay_ms(&sc->sc_bus, USB_RESUME_WAIT);

		sc->sc_bus.use_polling--;
		break;
	case PWR_SOFTSUSPEND:
	case PWR_SOFTSTANDBY:
	case PWR_SOFTRESUME:
		break;
d1272 4
d1277 58
a1335 1
}
d1340 2
a1341 1
void
d1345 5
a1351 1

d1357 1
d1360 1
a1360 1
usbd_status
d1368 2
a1369 2
        if (err == USBD_NOMEM)
                err = usb_reserve_allocm(&sc->sc_dma_reserve, dma, size);
d1373 1
a1373 1
                printf("ehci_allocm: usb_allocmem()=%d\n", err);
d1378 1
a1378 1
void
d1384 5
a1388 5
        if (dma->block->flags & USB_DMA_RESERVE) {
                usb_reserve_freem(&((struct ehci_softc *)bus)->sc_dma_reserve,
                    dma);
                return;
        }
d1393 1
a1393 1
usbd_xfer_handle
d1404 1
a1404 1
                        printf("ehci_allocx: xfer=%p not free, 0x%08x\n", xfer,
d1412 1
a1412 1
		memset(xfer, 0, sizeof (struct ehci_xfer));
d1421 1
a1421 1
void
d1428 1
a1428 1
                printf("ehci_freex: xfer=%p not busy, 0x%08x\n", xfer,
a1429 1
		return;
d1433 1
a1433 2
                printf("ehci_freex: !isdone\n");
		return;
d1446 1
a1446 1
#ifdef USB_DEBUG
d1452 1
a1452 1
        epipe->nexttoggle = 0;
d1461 1
a1461 1
void
d1465 1
a1465 1
        printf("cmd=0x%08x, sts=0x%08x, ien=0x%08x\n",
d1469 1
a1469 1
        printf("frindex=0x%08x ctrdsegm=0x%08x periodic=0x%08x async=0x%08x\n",
d1475 1
a1475 1
                printf("port %d status=0x%08x\n", i,
d1489 1
a1489 1
void
d1493 1
a1493 1
        printf("0x%08x", link);
d1495 1
a1495 1
                printf("<T>");
d1497 1
a1497 1
                printf("<");
d1500 4
a1503 4
                        case EHCI_LINK_ITD: printf("ITD"); break;
                        case EHCI_LINK_QH: printf("QH"); break;
                        case EHCI_LINK_SITD: printf("SITD"); break;
                        case EHCI_LINK_FSTN: printf("FSTN"); break;
d1506 1
a1506 1
                printf(">");
d1510 1
a1510 1
void
d1519 8
a1526 1
                stop = sqtd->qtd.qtd_next & htole32(EHCI_LINK_TERMINATE);
d1529 1
a1529 1
                printf("dump aborted, too many TDs\n");
d1532 1
a1532 1
void
d1535 3
a1537 1
        printf("QTD(%p) at 0x%08x:\n", sqtd, sqtd->physaddr);
d1539 2
d1543 1
a1543 1
void
d1549 3
a1551 3
        printf("  next="); ehci_dump_link(qtd->qtd_next, 0);
        printf(" altnext="); ehci_dump_link(qtd->qtd_altnext, 0);
        printf("\n");
d1554 3
a1556 3
	bitmask_snprintf(EHCI_QTD_GET_STATUS(s),
			 "\20\10ACTIVE\7HALTED\6BUFERR\5BABBLE\4XACTERR"
			 "\3MISSED\2SPLIT\1PING", sbuf, sizeof(sbuf));
d1568 1
a1568 1
	logprintf("  status=0x%08x: toggle=%d bytes=0x%x ioc=%d c_page=0x%x\n",
d1571 1
a1571 1
        printf("    cerr=%d pid=%d stat=0x%s\n", EHCI_QTD_GET_CERR(s),
d1574 1
a1574 1
                printf("  buffer[%d]=0x%08x\n", s, le32toh(qtd->qtd_buffer[s]));
d1577 1
a1577 1
void
d1583 4
a1586 2
        printf("QH(%p) at 0x%08x:\n", sqh, sqh->physaddr);
        printf("  link="); ehci_dump_link(qh->qh_link, 1); printf("\n");
d1588 2
a1589 2
        printf("  endp=0x%08x\n", endp);
        printf("    addr=0x%02x inact=%d endpt=%d eps=%d dtc=%d hrecl=%d\n",
d1593 1
a1593 1
        printf("    mpl=0x%x ctl=%d nrl=%d\n",
d1597 2
a1598 2
        printf("  endphub=0x%08x\n", endphub);
        printf("    smask=0x%02x cmask=0x%02x huba=0x%02x port=%d mult=%d\n",
d1602 2
a1603 2
        printf("  curqtd="); ehci_dump_link(qh->qh_curqtd, 0); printf("\n");
        printf("Overlay qTD:\n");
d1605 2
d1609 1
a1609 1
#ifdef DIAGNOSTIC
d1611 1
a1611 1
ehci_dump_exfer(struct ehci_xfer *ex)
d1613 23
a1635 1
        printf("ehci_dump_exfer: ex=%p\n", ex);
a1636 2
#endif
#endif
d1638 19
a1656 1
usbd_status
d1668 2
a1669 2
        int ival, speed, naks;
        int hshubaddr, hshubport;
d1674 7
a1680 7
        if (dev->myhsport) {
                hshubaddr = dev->myhsport->parent->address;
                hshubport = dev->myhsport->portno;
        } else {
                hshubaddr = 0;
                hshubport = 0;
        }
d1685 2
a1686 1
        epipe->nexttoggle = 0;
d1696 2
d1710 14
a1723 27
	naks = 8;		/* XXX */
	sqh = ehci_alloc_sqh(sc);
	if (sqh == NULL)
		goto bad0;
	/* qh_link filled when the QH is added */
	sqh->qh.qh_endp = htole32(
		EHCI_QH_SET_ADDR(addr) |
                EHCI_QH_SET_ENDPT(UE_GET_ADDR(ed->bEndpointAddress)) |
                EHCI_QH_SET_EPS(speed) |
                EHCI_QH_DTC |
		EHCI_QH_SET_MPL(UGETW(ed->wMaxPacketSize)) |
		(speed != EHCI_QH_SPEED_HIGH && xfertype == UE_CONTROL ?
		 EHCI_QH_CTL : 0) |
		EHCI_QH_SET_NRL(naks)
		);
	sqh->qh.qh_endphub = htole32(
                EHCI_QH_SET_MULT(1) |
                EHCI_QH_SET_HUBA(hshubaddr) |
                EHCI_QH_SET_PORT(hshubport) |
                EHCI_QH_SET_CMASK(0x08) | /* XXX */
                EHCI_QH_SET_SMASK(xfertype == UE_INTERRUPT ? 0x02 : 0)
		);
	sqh->qh.qh_curqtd = EHCI_NULL;
	/* Fill the overlay qTD */
	sqh->qh.qh_qtd.qtd_next = EHCI_NULL;
	sqh->qh.qh_qtd.qtd_altnext = EHCI_NULL;
	sqh->qh.qh_qtd.qtd_status = htole32(0);
d1725 46
a1770 1
	epipe->sqh = sqh;
d1778 1
a1778 1
                        printf("ehci_open: usb_allocmem()=%d\n", err);
d1781 1
a1781 1
			goto bad1;
d1795 19
a1813 4
                ival = pipe->interval;
                if (ival == USBD_DEFAULT_INTERVAL)
                        ival = ed->bInterval;
                return (ehci_device_setintr(sc, sqh, ival));
d1816 13
a1828 1
		return (USBD_INVAL);
d1830 3
a1832 1
		return (USBD_INVAL);
d1836 4
a1839 4
 bad1:
	ehci_free_sqh(sc, sqh);
 bad0:
	return (USBD_NOMEM);
d1845 1
a1845 1
void
d1850 2
d1854 2
d1858 2
d1863 1
a1863 1
                printf("ehci_add_qh:\n");
d1872 1
a1872 1
void
d1883 2
d1887 2
d1893 1
a1893 1
void
d1896 2
a1897 2
        int i;
        u_int32_t status;
d1899 13
a1911 7
        /* Save toggle bit and ping status. */
        status = sqh->qh.qh_qtd.qtd_status &
            htole32(EHCI_QTD_TOGGLE_MASK |
                    EHCI_QTD_SET_STATUS(EHCI_QTD_PINGSTATE));
        /* Set HALTED to make hw leave it alone. */
        sqh->qh.qh_qtd.qtd_status =
            htole32(EHCI_QTD_SET_STATUS(EHCI_QTD_HALTED));
d1914 3
a1916 3
        sqh->qh.qh_qtd.qtd_altnext = 0;
        for (i = 0; i < EHCI_QTD_NBUFFERS; i++)
                sqh->qh.qh_qtd.qtd_buffer[i] = 0;
d1918 8
a1925 2
        /* Set !HALTED && !ACTIVE to start execution, preserve some fields */
        sqh->qh.qh_qtd.qtd_status = status;
d1934 1
a1934 1
void
d1944 1
a1944 1
	lockmgr(&sc->sc_doorbell_lock, LK_EXCLUSIVE, NULL); /* get doorbell */
d1958 1
a1958 1
	lockmgr(&sc->sc_doorbell_lock, LK_RELEASE, NULL); /* release doorbell */
d1961 1
a1961 1
                printf("ehci_sync_hc: tsleep() = %d\n", error);
d1966 49
d2033 1
a2033 1
Static usb_device_qualifier_t ehci_odevd = {
d2045 1
a2045 1
Static usb_config_descriptor_t ehci_confd = {
d2054 1
a2054 1
	UC_SELF_POWERED,
d2058 1
a2058 1
Static usb_interface_descriptor_t ehci_ifcd = {
d2070 1
a2070 1
Static usb_endpoint_descriptor_t ehci_endpd = {
d2076 1
a2076 1
	255
d2079 1
a2079 1
Static usb_hub_descriptor_t ehci_hubd = {
d2086 2
a2087 1
	{0},
a2089 17
Static int
ehci_str(usb_string_descriptor_t* p, int l, char *s)
{
	int i;

	if (l == 0)
		return (0);
	p->bLength = 2 * strlen(s) + 2;
	if (l == 1)
		return (1);
	p->bDescriptorType = UDESC_STRING;
	l -= 2;
	for (i = 0; s[i] && l > 1; i++, l -= 2)
		USETW2(p->bString[i], 0, s[i]);
	return (2*i+2);
}

d2130 1
a2130 1
        DPRINTFN(4,("ehci_root_ctrl_start: type=0x%02x request=%02x\n",
d2157 3
a2159 1
                DPRINTFN(8,("ehci_root_ctrl_start: wValue=0x%04x\n", value));
d2228 4
a2231 1
			if (len == 0)
a2232 6
			*(u_int8_t *)buf = 0;
			totlen = 1;
			switch (value & 0xff) {
                        case 0: /* Language table */
                                totlen = ehci_str(buf, len, "\001");
                                break;
d2234 2
a2235 1
				totlen = ehci_str(buf, len, sc->sc_vendor);
d2238 2
a2239 1
				totlen = ehci_str(buf, len, "EHCI root hub");
d2242 1
d2297 1
a2297 1
                DPRINTFN(8, ("ehci_root_ctrl_start: UR_CLEAR_PORT_FEATURE "
d2305 3
a2307 1
		v = EOREAD4(sc, port) &~ EHCI_PS_CLEAR;
d2313 13
a2325 1
			EOWRITE4(sc, port, v &~ EHCI_PS_SUSP);
d2328 2
a2329 1
			EOWRITE4(sc, port, v &~ EHCI_PS_PP);
d2332 1
a2332 1
                        DPRINTFN(2,("ehci_root_ctrl_start: clear port test "
d2336 1
a2336 1
                        DPRINTFN(2,("ehci_root_ctrl_start: clear port ind "
d2353 1
a2353 1
			sc->sc_isreset = 0;
a2365 4
			/* Enable RHSC interrupt if condition is cleared. */
			if ((OREAD4(sc, port) >> 16) == 0)
				ehci_pcd_able(sc, 1);
			break;
d2372 3
a2374 1
                if ((value & 0xff) != 0) {
d2384 1
a2384 1
		        ? UHD_PORT_IND : 0);
d2406 1
a2406 1
                DPRINTFN(8,("ehci_root_ctrl_start: get port status i=%d\n",
d2417 1
a2417 1
                DPRINTFN(8,("ehci_root_ctrl_start: port status=0x%04x\n",
d2431 1
a2431 1
		if (sc->sc_isreset)	i |= UPS_C_PORT_RESET;
d2452 3
a2454 1
		v = EOREAD4(sc, port) &~ EHCI_PS_CLEAR;
d2463 1
a2463 1
                        DPRINTFN(5,("ehci_root_ctrl_start: reset port %d\n",
d2490 1
a2490 1
                                printf("%s: port reset timeout\n",
d2499 1
a2499 1
			sc->sc_isreset = 1;
d2504 5
a2508 3
                        DPRINTFN(2,("ehci_root_ctrl_start: set port power "
				    "%d\n", index));
			EOWRITE4(sc, port, v | EHCI_PS_PP);
d2511 1
a2511 1
                        DPRINTFN(2,("ehci_root_ctrl_start: set port test "
d2515 1
a2515 1
                        DPRINTFN(2,("ehci_root_ctrl_start: set port ind "
d2543 1
a2543 1
void
d2554 1
a2554 1
                        printf("%s: strange port\n",
d2558 1
a2558 1
			logprintf("%s: handing over %s speed device on "
d2564 1
a2564 1
			logprintf("%s: handing over %s speed device on "
d2566 1
a2566 1
			       USBDEVNAME(sc->sc_bus.bdev),
d2568 1
a2568 1
			       index, USBDEVNAME(sc->sc_comps[i]->bdev));
d2571 1
a2571 1
                printf("%s: npcomp == 0\n", USBDEVNAME(sc->sc_bus.bdev));
d2594 1
a2594 1
void
d2655 1
a2655 1
void
d2663 1
a2663 1
ehci_soft_qh_t *
d2677 1
a2677 1
                        printf("ehci_alloc_sqh: usb_allocmem()=%d\n", err);
d2685 2
d2698 1
a2698 1
void
d2705 1
a2705 1
ehci_soft_qtd_t *
d2720 1
a2720 1
                        printf("ehci_alloc_sqtd: usb_allocmem()=%d\n", err);
d2729 2
d2748 1
a2748 1
void
d2759 1
a2759 1
usbd_status
d2767 2
a2768 2
        int len, curlen, mps;
        int i, tog;
d2770 2
a2771 2
        int flags = xfer->flags;
        
d2777 1
a2777 1
        qtdstatus = EHCI_QTD_ACTIVE |
d2783 3
a2785 3
        mps = UGETW(epipe->pipe.endpoint->edesc->wMaxPacketSize);
        tog = epipe->nexttoggle;
        qtdstatus |= EHCI_QTD_SET_TOGGLE(tog);
d2791 3
d2807 1
a2807 1
                                printf("ehci_alloc_sqtd_chain: curlen=0x%x "
d2810 1
a2810 1
                                printf("lastpage=0x%x page=0x%x phys=0x%x\n",
a2815 1

d2817 1
a2817 1
                        curlen -= curlen % mps;
d2822 1
a2822 1
				panic("ehci_alloc_std: curlen == 0");
d2825 1
a2825 1
                DPRINTFN(4,("ehci_alloc_sqtd_chain: dataphys=0x%08x "
d2830 9
a2838 10
		
// Dan addition.. force new NULL length qtd if its an exact write of modulo mps
// this now matches what is in OHCI .. needed for ethernet deviced e.g.
		if (len != 0
		    || (flags & USBD_FORCE_SHORT_XFER
		         && curlen
		         && (curlen % mps) == 0
		         && !rd)) {
// this is what EHCI came with		         
//		if (len != 0) {
d2842 1
a2842 1
                        nextphys = htole32(next->physaddr);
d2848 2
a2849 3
                for (i = 0;
                    i * EHCI_PAGE_SIZE < curlen + EHCI_PAGE_OFFSET(dataphys);
                    i++) {
d2854 1
a2854 1
                        cur->qtd.qtd_buffer_hi[i] = 0;
d2857 1
a2857 1
                                printf("ehci_alloc_sqtd_chain: i=%d\n", i);
d2863 1
a2863 1
                cur->qtd.qtd_next = cur->qtd.qtd_altnext = nextphys;
d2865 1
a2865 1
                    htole32(qtdstatus | EHCI_QTD_SET_BYTES(curlen));
d2868 1
d2871 7
a2877 11
                /* adjust the toggle based on the number of packets in this
                   qtd */
                if (((curlen + mps - 1) / mps) & 1) {
                        tog ^= 1;
                        qtdstatus ^= EHCI_QTD_TOGGLE_MASK;
                }
// Dan addition.. to match OHCI 
// JB simplify ..it'll be NULL once end is reached
		if (next==NULL)    
// ehci original
//		if (len == 0)
d2879 2
d2886 2
d2889 1
a2889 1
        epipe->nexttoggle = tog;
d2918 74
d2998 1
a2998 1
void
d3023 1
a3023 1
void
d3035 1
d3043 1
a3043 1
		usb_uncallout(xfer->timeout_handle, ehci_timeout, xfer);
d3050 1
a3050 1
	if (xfer->device->bus->intr_context || !curproc)
d3055 24
d3083 6
a3088 1
	usb_uncallout(xfer->timeout_handle, ehci_timeout, xfer);
d3091 5
a3095 1
        for (sqtd = exfer->sqtdstart;  
d3097 1
a3097 1
        sqtd
d3099 5
a3103 1
        ; sqtd = sqtd->nextqtd) {
d3105 4
d3147 5
d3164 4
d3169 4
d3183 2
d3186 2
d3193 96
a3288 1
void
d3296 1
a3296 1
#if defined(USB_DEBUG) && !defined(__riscos)
d3311 2
a3312 1
	usb_add_task(exfer->xfer.pipe->device, &exfer->abort_task);
d3316 1
a3316 1
void
d3357 1
a3357 1
                printf("ehci_device_ctrl_transfer: not a request\n");
d3371 1
a3371 1
void
d3376 4
a3379 1
	/*struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;*/
d3389 6
a3394 2
        if (xfer->status != USBD_NOMEM && ehci_active_intr_list(ex)) {
		ehci_del_intr_list(ex);	/* remove from active list */
d3396 5
d3402 4
d3429 1
a3429 1
usbd_status
d3448 1
a3448 1
        DPRINTFN(3,("ehci_device_request: type=0x%02x, request=0x%02x, "
d3468 2
a3469 2
        /* Update device address and length since they may have changed
           during the setup of the control pipe in usbd_new_device(). */
d3473 1
a3473 1
            (sqh->qh.qh_endp & htole32(~(EHCI_QH_ADDRMASK | EHCI_QH_MPLMASK))) |
d3483 2
a3484 2
                /* Start toggle at 1. */
                epipe->nexttoggle = 1;
d3489 1
a3489 1
                end->qtd.qtd_status &= htole32(~EHCI_QTD_IOC);
d3493 2
d3504 1
d3506 1
a3506 1
        /* Clear toggle */
d3511 1
a3511 1
            EHCI_QTD_SET_TOGGLE(0) |
d3515 1
a3515 1
        setup->qtd.qtd_buffer_hi[0] = 0;
d3520 2
d3527 1
a3527 1
            EHCI_QTD_SET_TOGGLE(1) |
d3531 1
a3531 1
        stat->qtd.qtd_buffer_hi[0] = 0; /* XXX not needed? */
d3536 2
d3551 1
a3551 1
                printf("ehci_device_request: not done, exfer=%p\n", exfer);
d3558 1
a3558 1
	ehci_set_qh_qtd(sqh, setup);
d3561 2
a3562 2
                usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
			    ehci_timeout, xfer);
d3564 2
a3565 2
                usb_callout(xfer->timeout_handle, mstohz(xfer->timeout),
			    ehci_timeout, xfer);
d3568 1
d3570 1
d3600 23
d3639 1
a3639 1
usbd_status
d3652 1
a3652 1
        DPRINTFN(2, ("ehci_device_bulk_start: xfer=%p len=%d flags=%d\n",
d3660 1
a3660 1
                panic("ehci_device_bulk_start: a request");
d3681 1
a3681 1
                DPRINTF(("ehci_device_bulk_start: data(1)\n"));
d3692 1
a3692 1
                printf("ehci_device_bulk_start: not done, ex=%p\n", exfer);
d3698 1
a3698 1
	ehci_set_qh_qtd(sqh, data);
d3701 2
a3702 2
		usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
			    ehci_timeout, xfer);
d3704 2
a3705 2
                usb_callout(xfer->timeout_handle, mstohz(xfer->timeout),
			    ehci_timeout, xfer);
d3708 1
d3710 1
d3716 1
a3716 1
                DPRINTF(("ehci_device_bulk_start: data(2)\n"));
d3718 1
a3718 1
                DPRINTF(("ehci_device_bulk_start: data(3)\n"));
d3721 1
a3721 1
                printf("async_head:\n");
d3724 1
a3724 1
                printf("sqh:\n");
d3756 1
a3756 1
void
d3761 3
a3763 1
	/*struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;*/
d3768 9
a3776 3
        if (xfer->status != USBD_NOMEM && ehci_active_intr_list(ex)) {
		ehci_del_intr_list(ex);	/* remove from active list */
                ehci_free_sqtd_chain(sc, ex->sqtdstart, NULL);
d3778 4
d3791 7
a3797 2
        struct ehci_soft_islot *isp;
        int islot, lev;
d3799 8
a3806 13
        /* Find a poll rate that is large enough. */
        for (lev = EHCI_IPOLLRATES - 1; lev > 0; lev--)
                if (EHCI_ILEV_IVAL(lev) <= ival)
                        break;

        /* Pick an interrupt slot at the right level. */
        /* XXX could do better than picking at random */
        sc->sc_rand = (sc->sc_rand + 191) % sc->sc_flsize;
        islot = EHCI_IQHIDX(lev, sc->sc_rand);

        sqh->islot = islot;
        isp = &sc->sc_islots[islot];
        ehci_add_qh(sqh, isp->sqh);
d3808 1
a3808 1
        return (USBD_NORMAL_COMPLETION);
d3814 6
a3819 1
        usbd_status err;
d3821 5
a3825 10
        /* Insert last in queue. */
        err = usb_insert_transfer(xfer);
        if (err)
                return (err);

        /*
         * Pipe isn't running (otherwise err would be USBD_INPROG),
         * so start it first.
         */
        return (ehci_device_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
d3832 35
a3866 35
        struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
        usbd_device_handle dev = xfer->pipe->device;
        ehci_softc_t *sc = (ehci_softc_t *)dev->bus;
        ehci_soft_qtd_t *data, *dataend;
        ehci_soft_qh_t *sqh;
        usbd_status err;
        int len, isread, endpt;
        int s;

        DPRINTFN(2, ("ehci_device_intr_start: xfer=%p len=%d flags=%d\n",
            xfer, xfer->length, xfer->flags));

        if (sc->sc_dying)
                return (USBD_IOERROR);

#ifdef DIAGNOSTIC
        if (xfer->rqflags & URQ_REQUEST)
                panic("ehci_device_intr_start: a request");
#endif

        len = xfer->length;
        endpt = epipe->pipe.endpoint->edesc->bEndpointAddress;
        isread = UE_GET_DIR(endpt) == UE_DIR_IN;
        sqh = epipe->sqh;

        epipe->u.intr.length = len;

        err = ehci_alloc_sqtd_chain(epipe, sc, len, isread, xfer, &data,
            &dataend);
        if (err) {
                DPRINTFN(-1, ("ehci_device_intr_start: no memory\n"));
                xfer->status = err;
                usb_transfer_complete(xfer);
                return (err);
        }
d3869 5
a3873 5
        if (ehcidebug > 5) {
                DPRINTF(("ehci_device_intr_start: data(1)\n"));
                ehci_dump_sqh(sqh);
                ehci_dump_sqtds(data);
        }
d3876 3
a3878 3
        /* Set up interrupt info. */
        exfer->sqtdstart = data;
        exfer->sqtdend = dataend;
d3880 4
a3883 4
        if (!exfer->isdone) {
                printf("ehci_device_intr_start: not done, ex=%p\n", exfer);
        }
        exfer->isdone = 0;
d3886 3
a3888 3
        s = splusb();
        ehci_set_qh_qtd(sqh, data);
        if (xfer->timeout && !sc->sc_bus.use_polling) {
d3890 2
a3891 2
                usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
			    ehci_timeout, xfer);
d3893 2
a3894 2
                usb_callout(xfer->timeout_handle, mstohz(xfer->timeout),
			    ehci_timeout, xfer);
d3896 6
a3901 4
        }
        ehci_add_intr_list(sc, exfer);
        xfer->status = USBD_IN_PROGRESS;
        splx(s);
d3904 9
a3912 9
        if (ehcidebug > 10) {
                DPRINTF(("ehci_device_intr_start: data(2)\n"));
                delay(10000);
                DPRINTF(("ehci_device_intr_start: data(3)\n"));
                ehci_dump_regs(sc);
                printf("sqh:\n");
                ehci_dump_sqh(sqh);
                ehci_dump_sqtds(data);
        }
d3915 2
a3916 2
        if (sc->sc_bus.use_polling)
                ehci_waitintr(sc, xfer);
d3918 1
a3918 1
        return (USBD_IN_PROGRESS);
d3925 11
a3935 6
        DPRINTFN(1, ("ehci_device_intr_abort: xfer=%p\n", xfer));
        if (xfer->pipe->intrxfer == xfer) {
                DPRINTFN(1, ("echi_device_intr_abort: remove\n"));
                xfer->pipe->intrxfer = NULL;
        }
        ehci_abort_xfer(xfer, USBD_CANCELLED);
d3942 2
a3943 2
        struct ehci_pipe *epipe = (struct ehci_pipe *)pipe;
        struct ehci_soft_islot *isp;
d3945 2
a3946 3
        isp = &sc->sc_islots[epipe->sqh->islot];
	DPRINTF(("ehci_device_intr_close: pipe=%p\n", pipe));
        ehci_close_pipe(pipe, isp->sqh);
d3953 1
a3953 1
        struct ehci_xfer *ex = EXFER(xfer);
d3955 77
a4031 55
        struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
        ehci_soft_qtd_t *data, *dataend;
        ehci_soft_qh_t *sqh;
        usbd_status err;
        int len, isread, endpt, s;

        DPRINTFN(10, ("ehci_device_intr_done: xfer=%p, actlen=%d\n",
            xfer, xfer->actlen));

        if (xfer->pipe->repeat) {
                ehci_free_sqtd_chain(sc, ex->sqtdstart, NULL);

                len = epipe->u.intr.length;
                xfer->length = len;
                endpt = epipe->pipe.endpoint->edesc->bEndpointAddress;
                isread = UE_GET_DIR(endpt) == UE_DIR_IN;
                sqh = epipe->sqh;

                err = ehci_alloc_sqtd_chain(epipe, sc, len, isread, xfer,
                    &data, &dataend);
                if (err) {
                        DPRINTFN(-1, ("ehci_device_intr_done: no memory\n"));
                        xfer->status = err;
                        return;
                }

                /* Set up interrupt info. */
                exfer->sqtdstart = data;
                exfer->sqtdend = dataend;
#ifdef DIAGNOSTIC
                if (!exfer->isdone) {
                        printf("ehci_device_intr_done: not done, ex=%p\n",
                            exfer);
                }
                exfer->isdone = 0;
#endif

                s = splusb();
                ehci_set_qh_qtd(sqh, data);
                if (xfer->timeout && !sc->sc_bus.use_polling) {
#ifdef __riscos
		usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
			    ehci_timeout, xfer);
#else
                usb_callout(xfer->timeout_handle, mstohz(xfer->timeout),
			    ehci_timeout, xfer);
#endif
                }
                splx(s);

                xfer->status = USBD_IN_PROGRESS;
        } else if (xfer->status != USBD_NOMEM && ehci_active_intr_list(ex)) {
                ehci_del_intr_list(ex); /* remove from active list */
                ehci_free_sqtd_chain(sc, ex->sqtdstart, NULL);
        }
d4037 330
a4366 5
Static usbd_status	ehci_device_isoc_transfer(usbd_xfer_handle xfer) { return USBD_IOERROR; }
Static usbd_status	ehci_device_isoc_start(usbd_xfer_handle xfer) { return USBD_IOERROR; }
Static void		ehci_device_isoc_abort(usbd_xfer_handle xfer) { }
Static void		ehci_device_isoc_close(usbd_pipe_handle pipe) { }
Static void		ehci_device_isoc_done(usbd_xfer_handle xfer) { }
@


1.10
log
@	Update of NetBSD elements (except c.ohci) to track NetBSD current
	from mid April 2005.
	Inclusion of Mods to c.ehci (from Dan) to correctly handle low
	speed interrupt devices beyond USB2 hubs (i.e. keyboards and mice).
	Mod to EHCI resetting in service call handler to better cope with
	USBDriver being restarted 'underneath' it.
Detail:
Admin:
	Castle, Dan Ellis, NetBSD added IP. Tested at Castle. Will be
	beta tested at this revision level before full release.


Version 0.39. Tagged as 'NetBSD-0_39'
@
text
@d613 2
a614 1
#endif	
d647 1
a647 1
		
d652 1
d2707 1
a2707 1
#ifdef USB_DEBUG
a2708 1
#ifndef __riscos
a2710 1
#endif
@


1.9
log
@         changes and bug fixes that came to light following USB2 launch.
Detail:
         - VarVal launching.. string length was incorrectly calculated.
         - USB VarVals now correctly cleared if device failed during
           enumeration, after first SetVarVal call.
         - Triggercbs() modified to check interrupt context and be
           refuse (quietly) to trigger callbacks if interrupts threaded
           (result of possible issue .. but perhaps wise)
         - Added third QueryDelay variable, and an Info file to describe
           what does what.
Admin:
         checked at Castle.. due for extended check via beta test site
         before formal release.

         Castle + D Ellis added IP


Version 0.35. Tagged as 'NetBSD-0_35'
@
text
@d1 1
a1 1
/*      $NetBSD: ehci.c,v 1.90 2004/12/21 16:41:24 fvdl Exp $ */
d68 1
a68 1
//__KERNEL_RCSID(0, "$NetBSD: ehci.c,v 1.90 2004/12/21 16:41:24 fvdl Exp $");
d357 2
a358 1

d400 3
a402 2
        if (EHCI_HCS_N_CC(sparams) != sc->sc_ncomp) {
		logprintf("%s: wrong number of companions (%d != %d)\n",
d404 1
a404 1
                       EHCI_HCS_N_CC(sparams), sc->sc_ncomp);
d408 2
d503 3
d507 1
a507 1
                        sqh->next = sc->sc_islots[(i + 1) / 2 - 1].sqh;
a511 1
                sqh->qh.qh_link = EHCI_NULL;
d650 1
a650 1
        EOREAD4(sc, EHCI_USBINTR);
d698 1
a698 1
	EOREAD4(sc, EHCI_USBINTR); /* Acknowledge */
d722 1
a722 5
//#ifdef __riscos
//	int s;
//	s = splhardusb();
	DPRINTF( ("ehci_pcd_enable\n"));
//#endif
a723 3
//#ifdef __riscos
//	splx(s);
//#endif
d921 1
a921 1
	if (status != 0) {
a1486 10
        if (speed != EHCI_QH_SPEED_HIGH) {
                printf("%s: *** WARNING: opening low/full speed device, this "
                       "does not work yet.\n",
                       USBDEVNAME(sc->sc_bus.bdev));
                DPRINTFN(1,("ehci_open: hshubaddr=%d hshubport=%d\n",
                            hshubaddr, hshubport));
                if (xfertype != UE_CONTROL && xfertype != UE_BULK)
                        return USBD_INVAL;
        }

d1506 2
a1507 2
                EHCI_QH_SET_CMASK(0xf0) | /* XXX */
                EHCI_QH_SET_SMASK(xfertype == UE_INTERRUPT ? 0x01 : 0)
d2624 1
a2624 1
	for (sqtd = exfer->sqtdstart;  
d2626 1
a2626 1
	sqtd
d2628 1
a2628 1
	; sqtd = sqtd->nextqtd) {
@


1.8
log
@Summary:  Minor tweaks to USBDriver and EHCI prior to USB2 release
          resulting from beta testing
Detail:
Admin:    castle and d ellis added IP beyond that in NetBSD sources


Version 0.34. Tagged as 'NetBSD-0_34'
@
text
@d95 2
a96 2
#define DPRINTF(x)	if (ehcidebug) logprintf x
#define DPRINTFN(n,x)	if (ehcidebug>(n)) logprintf x
d436 3
d605 3
d644 1
a644 1
        EOREAD4(sc, EHCI_USBSTS);
d692 1
a692 1
	(void) EOREAD4(sc, EHCI_USBSTS); /* Acknowledge */
d701 1
a701 1
	DPRINTFN(4, ("ehci_pcd_able: on=%d\n", on));
d707 3
d716 5
a720 1

d722 3
d2635 5
a2639 1
	for (sqtd = exfer->sqtdstart; ; sqtd = sqtd->nextqtd) {
d3298 1
@


1.7
log
@        Stack brought up to date with NetBSD sources as at 20050121.
        USB2 further debugged.
Detail:
        Check in prior to second beta release. Improvements also to
        softloading of replacement modules.
Admin:
        Checked with JB .. further crosschecking is still needed for rhenium.
        Castle/D Ellis added ip from NetBSD sources


Version 0.33. Tagged as 'NetBSD-0_33'
@
text
@d651 3
d655 1
d685 1
a685 1
#ifdef __riscos0
d2403 2
a2404 1

d2461 10
a2470 1
		if (len != 0) {
d2509 5
a2513 1
		if (len == 0)
d2636 4
a2639 1

d2641 1
a2641 1

@


1.6
log
@       improved module startup sequence independance, and added
       service-prereset to
       the ehcimodule. modules in beta test in field
Detail:
Admin:
       castle added ip.  still to be tested on rhenium


Version 0.32. Tagged as 'NetBSD-0_32'
@
text
@d1 1
a1 1
/*      $NetBSD: ehci.c,v 1.89 2004/12/03 08:51:31 augustss Exp $ */
d68 1
a68 1
//__KERNEL_RCSID(0, "$NetBSD: ehci.c,v 1.89 2004/12/03 08:51:31 augustss Exp $");
d91 3
d105 9
d143 1
a246 4
#ifdef __riscos
#define MS_TO_TICKS(ms) ((ms) * hz / 1000)
#endif

d260 1
a356 1
        u_int ncomp;
d399 1
a399 3
        ncomp = EHCI_HCS_N_CC(sparams);
        if (ncomp != sc->sc_ncomp) {

d402 1
a402 1
                       ncomp, sc->sc_ncomp);
a405 2
                if (ncomp < sc->sc_ncomp)
                        sc->sc_ncomp = ncomp;
d413 1
d429 4
a432 1

d618 1
a618 1
		logprintf("ehci_intr: sc == NULL\n");
d629 1
a629 1
	DPRINTFN(7, ("ehci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n",
d634 2
a635 2

	EOWRITE4(sc, EHCI_USBSTS, intrs); /* Acknowledge */
a650 3
#if defined(__riscos) && !defined(USB_USE_SOFTINTR)
                ehci_softintr(&sc->sc_bus);
#else
a651 1
#endif
d655 1
a655 1
		logprintf("%s: unrecoverable error, controller halted\n",
d677 1
a677 1
		logprintf("%s: blocking intrs 0x%x\n",
d679 1
a679 1
	}
d758 1
a758 1
//#ifdef USB_USE_SOFTINTR
d763 1
a763 1
//#endif /* USB_USE_SOFTINTR */
d778 1
a778 1
		logprintf("ehci_check_intr: sqtdstart=NULL\n");
d784 1
a784 1
		logprintf("ehci_check_intr: sqtd==0\n");
d834 1
a834 1
			logprintf("ehci_idone: ex is done!\n   ");
d837 1
a837 1
			logprintf("ehci_idone: ex=%p is done!\n", ex);
d908 2
a909 3
				 "\20\3MISSEDMICRO\4XACT\5BABBLE\6BABBLE"
				 "\7HALTED",
				 sbuf, sizeof(sbuf));
d923 1
a923 1
		DPRINTFN((status == EHCI_QTD_HALTED)*/*10*/2,
d1043 1
d1141 3
a1151 5
#ifdef EHCI_DEBUG
        DPRINTF(("ehci_power: sc=%p\n", sc));
        if (ehcidebug > 0)
                ehci_dump_regs(sc);
#endif
a1177 6
#ifdef __riscos
        (void) sc;
        /* try always allocating on a page boundary, to fix
           bulk transfer problems of more than one maxpacket */
	err = usb_allocmem(&sc->sc_bus, size, EHCI_PAGE_SIZE, dma);
#else
d1179 3
d1185 1
a1185 1
		logprintf("ehci_allocm: usb_allocmem()=%d\n", err);
d1195 7
a1201 1

d1216 1
a1216 1
			logprintf("uhci_allocx: xfer=%p not free, 0x%08x\n", xfer,
d1240 1
a1240 1
		logprintf("ehci_freex: xfer=%p not busy, 0x%08x\n", xfer,
d1246 1
a1246 1
		logprintf("ehci_freex: !isdone\n");
d1279 1
a1279 1
	logprintf("cmd=0x%08x, sts=0x%08x, ien=0x%08x\n",
d1283 1
a1283 1
	logprintf("frindex=0x%08x ctrdsegm=0x%08x periodic=0x%08x async=0x%08x\n",
d1289 1
a1289 1
		logprintf("port %d status=0x%08x\n", i,
d1298 1
a1298 1
ehci_dump()
d1307 1
a1307 1
	logprintf("0x%08x", link);
d1309 1
a1309 1
		logprintf("<T>");
d1311 1
a1311 1
		logprintf("<");
d1314 4
a1317 4
			case EHCI_LINK_ITD: logprintf("ITD"); break;
			case EHCI_LINK_QH: logprintf("QH"); break;
			case EHCI_LINK_SITD: logprintf("SITD"); break;
			case EHCI_LINK_FSTN: logprintf("FSTN"); break;
d1320 1
a1320 1
		logprintf(">");
d1336 1
a1336 1
		logprintf("dump aborted, too many TDs\n");
d1342 1
a1342 1
	logprintf("QTD(%p) at 0x%08x:\n", sqtd, sqtd->physaddr);
d1352 3
a1354 3
	logprintf("  next="); ehci_dump_link(qtd->qtd_next, 0);
	logprintf(" altnext="); ehci_dump_link(qtd->qtd_altnext, 0);
	logprintf("\n");
d1374 1
a1374 1
	logprintf("    cerr=%d pid=%d stat=0x%s\n", EHCI_QTD_GET_CERR(s),
d1377 1
a1377 1
		logprintf("  buffer[%d]=0x%08x\n", s, le32toh(qtd->qtd_buffer[s]));
d1386 2
a1387 2
	logprintf("QH(%p) at 0x%08x:\n", sqh, sqh->physaddr);
	logprintf("  link="); ehci_dump_link(qh->qh_link, 1); logprintf("\n");
d1389 2
a1390 2
	logprintf("  endp=0x%08x\n", endp);
	logprintf("    addr=0x%02x inact=%d endpt=%d eps=%d dtc=%d hrecl=%d\n",
d1394 1
a1394 1
	logprintf("    mpl=0x%x ctl=%d nrl=%d\n",
d1398 2
a1399 2
	logprintf("  endphub=0x%08x\n", endphub);
	logprintf("    smask=0x%02x cmask=0x%02x huba=0x%02x port=%d mult=%d\n",
d1403 2
a1404 2
	logprintf("  curqtd="); ehci_dump_link(qh->qh_curqtd, 0); logprintf("\n");
	logprintf("Overlay qTD:\n");
d1412 1
a1412 1
	logprintf("ehci_dump_exfer: ex=%p\n", ex);
d1469 1
a1469 1
               logprintf("%s: *** WARNING: opening low/full speed device, this "
d1474 1
a1474 1
                if (xfertype != UE_CONTROL || xfertype != UE_BULK)
d1514 1
a1514 1
			logprintf("ehci_open: usb_allocmem()=%d\n", err);
d1564 1
a1564 1
		logprintf("ehci_add_qh:\n");
d1646 1
a1646 1
		logprintf("ehci_sync_hc: tsleep() = %d\n", error);
d1782 1
a1782 1
	DPRINTFN(4,("ehci_root_ctrl_control type=0x%02x request=%02x\n",
d1809 1
a1809 1
		DPRINTFN(8,("ehci_root_ctrl_control wValue=0x%04x\n", value));
d1947 1
a1947 1
		DPRINTFN(8, ("ehci_root_ctrl_control: UR_CLEAR_PORT_FEATURE "
d1967 1
a1967 1
			DPRINTFN(2,("ehci_root_ctrl_transfer: clear port test "
d1971 1
a1971 1
			DPRINTFN(2,("ehci_root_ctrl_transfer: clear port ind "
d2043 1
a2043 1
		DPRINTFN(8,("ehci_root_ctrl_transfer: get port status i=%d\n",
d2054 1
a2054 1
		DPRINTFN(8,("ehci_root_ctrl_transfer: port status=0x%04x\n",
d2098 1
a2098 1
			DPRINTFN(5,("ehci_root_ctrl_transfer: reset port %d\n",
d2125 1
a2125 1
				logprintf("%s: port reset timeout\n",
d2139 1
a2139 1
			DPRINTFN(2,("ehci_root_ctrl_transfer: set port power "
d2144 1
a2144 1
			DPRINTFN(2,("ehci_root_ctrl_transfer: set port test "
d2148 1
a2148 1
			DPRINTFN(2,("ehci_root_ctrl_transfer: set port ind "
d2187 1
a2187 1
			logprintf("%s: strange port\n",
d2204 1
a2204 1
		logprintf("%s: npcomp == 0\n", USBDEVNAME(sc->sc_bus.bdev));
d2310 1
a2310 1
			logprintf("ehci_alloc_sqh: usb_allocmem()=%d\n", err);
d2351 1
a2351 1
			logprintf("ehci_alloc_sqtd: usb_allocmem()=%d\n", err);
d2432 1
a2432 1
				logprintf("ehci_alloc_sqtd_chain: curlen=0x%x "
d2435 1
a2435 1
				logprintf("lastpage=0x%x page=0x%x phys=0x%x\n",
d2451 1
a2451 1
		DPRINTFN(3,("ehci_alloc_sqtd_chain: dataphys=0x%08x "
a2455 1

d2466 3
a2468 1
                for (i = 0; i * EHCI_PAGE_SIZE < curlen; i++) {
d2476 1
a2476 1
				logprintf("ehci_alloc_sqtd_chain: i=%d\n", i);
d2615 1
a2615 1
//#ifdef USB_USE_SOFTINTR
d2617 2
a2618 4
//#endif /* USB_USE_SOFTINTR */
#if defined (__riscos) && !defined(USB_USE_SOFTINTR)
        ehci_softintr(&sc->sc_bus);
#else
d2620 2
a2621 1
//#ifdef USB_USE_SOFTINTR
d2627 1
a2627 2
//#endif /* USB_USE_SOFTINTR */
#endif
d2737 1
a2737 1
		logprintf("ehci_device_ctrl_transfer: not a request\n");
d2812 1
a2812 1
	DPRINTFN(3,("ehci_device_control type=0x%02x, request=0x%02x, "
d2908 1
a2908 1
		logprintf("ehci_device_request: not done, exfer=%p\n", exfer);
d2984 1
a2984 1
	DPRINTFN(2, ("ehci_device_bulk_transfer: xfer=%p len=%d flags=%d\n",
d2992 1
a2992 1
		panic("ehci_device_bulk_transfer: a request");
d3013 1
a3013 1
		DPRINTF(("ehci_device_bulk_transfer: data(1)\n"));
d3024 1
a3024 1
		logprintf("ehci_device_bulk_transfer: not done, ex=%p\n", exfer);
d3046 1
a3046 1
		DPRINTF(("ehci_device_bulk_transfer: data(2)\n"));
d3048 1
a3048 1
		DPRINTF(("ehci_device_bulk_transfer: data(3)\n"));
d3051 1
a3051 1
		logprintf("async_head:\n");
d3054 1
a3054 1
		logprintf("sqh:\n");
@


1.5
log
@        Update of EHCIDriver to current NetBSD, together with needed changes
        in both OHCIDriver and USBDriver.


Detail:
        Code may change before formal release .. will be beta released
        ... Entered to CVS to get new version numbers, and for
        the record.
Admin:
        Castle/netbsd added IP .. will be tested more fully before
        formal release. Still to be verified on Rhenium.


Version 0.31. Tagged as 'NetBSD-0_31'
@
text
@d407 1
d410 1
d1161 1
d1164 3
@


1.4
log
@  Extensive changes and bug fixes to usb and ohci ..
  'blocked' several holes that could cause freezes with awkward
  usb devices.  Added latest changes from Dan Ellis too , especially for USB2
Detail:
 many
Admin:
 Tested in ROM at Castle, and beta tested with users


Version 0.28. Tagged as 'NetBSD-0_28'
@
text
@d1 1
a1 1
/*      $NetBSD: ehci.c,v 1.68 2004/07/09 05:07:06 mycroft Exp $        */
d58 1
a58 1
 *    They are quite compolicated since the need to be able to do
d68 1
a68 1
__KERNEL_RCSID(0, "$NetBSD: ehci.c,v 1.68 2004/07/09 05:07:06 mycroft Exp $");
d119 3
a121 1
		/* XXX */
d208 3
d234 1
d236 1
d347 1
d390 3
a392 1
	if (EHCI_HCS_N_CC(sparams) != sc->sc_ncomp) {
d395 2
a396 1
		       EHCI_HCS_N_CC(sparams), sc->sc_ncomp);
d398 3
a406 2
#ifndef __riscos
                /* we aren't filling in companions at the moment */
a408 1
#endif
d438 2
d442 3
a444 3
	case 0: sc->sc_flsize = 1024*4; break;
	case 1: sc->sc_flsize = 512*4; break;
	case 2: sc->sc_flsize = 256*4; break;
d447 1
a447 1
	err = usb_allocmem(&sc->sc_bus, sc->sc_flsize,
d452 2
d466 40
d543 1
a543 1
		 EHCI_CMD_ITC_8 | /* 8 microframes */
d546 1
a546 1
		 /* EHCI_CMD_PSE | */
d584 4
a616 5
	EOWRITE4(sc, EHCI_USBSTS, intrs); /* Acknowledge */
#ifdef __riscos
        /* make sure it gets there */
        EOREAD4(sc, EHCI_USBSTS);
#endif
d624 5
d674 1
a674 1
#ifdef __riscos
d751 1
d756 1
d815 2
a816 2
	ehci_soft_qtd_t *sqtd;
	u_int32_t status = 0, nstatus;
d818 1
d852 1
d854 1
a854 1
	for (sqtd = ex->sqtdstart; sqtd != NULL; sqtd = sqtd->nextqtd) {
d868 8
a875 4
	/* If there are left over TDs we need to update the toggle. */
	if (sqtd != NULL) {
		if (!(xfer->rqflags & URQ_REQUEST))
			logprintf("ehci_idone: need toggle update\n");
d877 2
a878 1
		epipe->nexttoggle = EHCI_TD_GET_DT(le32toh(std->td.td_token));
d883 8
d905 10
a914 1
                sbuf[0] = '\0';
d960 1
a960 1
#ifdef OHCI_DEBUG
a1036 1
		break;
d1053 1
a1053 1
 * called from an intterupt context.  This is all right since we
d1061 2
a1062 2
	//u_int32_t ctl;
	int s;
d1066 1
d1075 34
a1108 15
#if 0
OOO
		ctl = OREAD4(sc, EHCI_CONTROL) & ~EHCI_HCFS_MASK;
		if (sc->sc_control == 0) {
			/*
			 * Preserve register values, in case that APM BIOS
			 * does not recover them.
			 */
			sc->sc_control = ctl;
			sc->sc_intre = OREAD4(sc, EHCI_INTERRUPT_ENABLE);
		}
		ctl |= EHCI_HCFS_SUSPEND;
		OWRITE4(sc, EHCI_CONTROL, ctl);
#endif
		usb_delay_ms(&sc->sc_bus, USB_RESUME_WAIT);
d1113 21
a1133 21
#if 0
OOO
		/* Some broken BIOSes do not recover these values */
		OWRITE4(sc, EHCI_HCCA, DMAADDR(&sc->sc_hccadma, 0));
		OWRITE4(sc, EHCI_CONTROL_HEAD_ED, sc->sc_ctrl_head->physaddr);
		OWRITE4(sc, EHCI_BULK_HEAD_ED, sc->sc_bulk_head->physaddr);
		if (sc->sc_intre)
			OWRITE4(sc, EHCI_INTERRUPT_ENABLE,
				sc->sc_intre & (EHCI_ALL_INTRS | EHCI_MIE));
		if (sc->sc_control)
			ctl = sc->sc_control;
		else
			ctl = OREAD4(sc, EHCI_CONTROL);
		ctl |= EHCI_HCFS_RESUME;
		OWRITE4(sc, EHCI_CONTROL, ctl);
		usb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY);
		ctl = (ctl & ~EHCI_HCFS_MASK) | EHCI_HCFS_OPERATIONAL;
		OWRITE4(sc, EHCI_CONTROL, ctl);
		usb_delay_ms(&sc->sc_bus, USB_RESUME_RECOVERY);
		sc->sc_control = sc->sc_intre = 0;
#endif
d1142 5
d1321 1
a1321 1
		stop = sqtd->qtd.qtd_next & EHCI_LINK_TERMINATE;
d1417 2
a1418 1
	int speed, naks;
d1423 8
d1456 10
d1482 5
a1486 3
		EHCI_QH_SET_MULT(1)
		/* XXX TT stuff */
		/* XXX interrupt mask */
d1519 4
a1522 1
		return (USBD_INVAL);
a1567 2
#ifdef __riscos
        /* surely this is correct! */
a1568 3
#else
	for (p = head; p == NULL && p->next != sqh; p = p->next)
#endif
d1581 10
a1590 2
	/* Halt while we are messing. */
	sqh->qh.qh_qtd.qtd_status |= htole32(EHCI_QTD_HALTED);
d1593 3
d1597 2
a1598 2
        /* Clear halt */
        sqh->qh.qh_qtd.qtd_status &= htole32(~EHCI_QTD_HALTED);
d1714 1
a1714 4
ehci_str(p, l, s)
	usb_string_descriptor_t *p;
	int l;
	char *s;
d1871 3
d2008 1
a2008 1
		    EHCI_HCS_P_INCICATOR(EREAD4(sc, EHCI_HCSPARAMS))
d2455 1
a2455 3
                for (i = 0;
                    i * EHCI_PAGE_SIZE < curlen + (dataphys % PAGE_SIZE);
                    i++) {
d2602 1
d2604 1
a2606 1
	tsleep(&sc->sc_softwake, PZERO, "ehciab", 0, 1);
d2609 1
d2615 1
d2842 1
d2906 1
d2909 4
d3021 1
d3024 4
d3095 217
a3311 5
Static usbd_status	ehci_device_intr_transfer(usbd_xfer_handle xfer) { return USBD_IOERROR; }
Static usbd_status	ehci_device_intr_start(usbd_xfer_handle xfer) { return USBD_IOERROR; }
Static void		ehci_device_intr_abort(usbd_xfer_handle xfer) { }
Static void		ehci_device_intr_close(usbd_pipe_handle pipe) { }
Static void		ehci_device_intr_done(usbd_xfer_handle xfer) { }
@


1.3
log
@Latest stuff from John - mainly Rhenium improvements.

Version 0.26. Tagged as 'NetBSD-0_26'
@
text
@d1 1
a1 1
/*      $NetBSD: ehci.c,v 1.54 2004/01/17 13:15:05 jdolecek Exp $       */
d4 1
a4 1
 * Copyright (c) 2001 The NetBSD Foundation, Inc.
d8 1
a8 1
 * by Lennart Augustsson (lennart@@augustsson.net).
d45 4
a48 1
 * http://www.usb.org/developers/data/usb_20.zip
d55 1
a55 1
 *    Interrupt transfers are not difficult, it's just not done. 
d57 1
a57 5
 * 3) There might also be some issues with the data toggle, it was not
 *    completely tested to work properly under all condistions. If wrong
 *    toggle would be sent/recvd, bulk data transfers would stop working.
 *
 * 4) The meaty part to implement is the support for USB 2.0 hubs.
d62 1
a62 1
 *    on hubs in USB 2.0 for details. 
d64 1
a64 1
 * 5) command failures are not recovered correctly
d68 1
a68 2
__KERNEL_RCSID(0, "$NetBSD: ehci.c,v 1.54 2004/01/17 13:15:05 jdolecek Exp $");

d105 1
a644 1
	struct ehci_pipe *epipe;
a653 1
	epipe = (struct ehci_pipe *)pipe;
d736 1
a736 1
			if (EHCI_QTD_SET_BYTES(status) != 0)
a752 1
#ifdef EHCI_DEBUG
a753 1
#endif
d812 1
d944 1
d946 1
d1061 1
d1079 1
d1140 1
a1141 1
#ifndef __riscos
d1145 1
a1145 1
	epipe->sqh->qh.qh_qtd.qtd_status &= htole32(~EHCI_QTD_TOGGLE);
d1316 1
d1345 3
a1347 3
		EHCI_QH_SET_ENDPT(ed->bEndpointAddress) |
		EHCI_QH_SET_EPS(speed) | /* XXX */
		/* XXX EHCI_QH_DTC ? */
d1458 2
a1459 2
	/* Keep toggle, clear the rest, including length. */
	sqh->qh.qh_qtd.qtd_status &= htole32(EHCI_QTD_TOGGLE);
d2245 2
a2246 2
	int len, curlen;
	int i;
d2254 1
a2254 2
	qtdstatus = htole32(
	    EHCI_QTD_ACTIVE |
d2259 4
a2262 2
	    /* XXX Data toggle */
	    );
a2290 1
			/* XXX true for EHCI? */
d2292 1
a2292 1
			curlen -= curlen % UGETW(epipe->pipe.endpoint->edesc->wMaxPacketSize);
d2310 1
a2310 1
			nextphys = next->physaddr;
d2316 3
a2318 1
		for (i = 0; i * EHCI_PAGE_SIZE < curlen; i++) {
d2332 1
a2332 1
		cur->qtd.qtd_next = cur->qtd.qtd_altnext = htole32(nextphys);
d2334 1
a2334 1
		    qtdstatus | htole32(EHCI_QTD_SET_BYTES(curlen));
d2339 6
d2353 1
d2681 2
a2682 15
	/* XXX
	 * Since we're messing with the QH we must know the HC is in sync.
	 * This needs to go away since it slows down control transfers.
	 * Removing it entails:
	 *  - fill the QH only once with addr & wMaxPacketSize
	 *  - put the correct data toggles in the qtds and set DTC
	 */
#ifdef __riscos0
        /* this seems to prevent problems with not being to able to read
           strings, although it's not necessarily correct */
	ehci_sync_hc(sc);
#else
	/* ehci_sync_hc(sc); */
#endif
	/* Update device address and length since they may have changed. */
d2686 1
a2686 1
	    (sqh->qh.qh_endp & htole32(~(EHCI_QH_ADDRMASK | EHCI_QG_MPLMASK))) |
a2688 1
	     /* EHCI_QH_DTC | */
a2690 2
	/* Clear toggle */
	sqh->qh.qh_qtd.qtd_status &= htole32(~EHCI_QTD_TOGGLE);
d2696 2
a2704 2
		/* Start toggle at 1. */
		/*next->qtd.td_flags |= htole32(EHCI_QTD_TOGGLE);*/
d2715 1
d2720 1
d2734 1
@


1.2
log
@  New versions from John.
Detail:
  * All modules will now rmkill/rmload more reliably
  * Keyboard driver disables kernel debounce on new enough kernels, needed
    for many PS2-USB adaptors, bar code scanners etc
  * Mouse driver will scroll wheel scroll any windows that do respond to
    scroll events, otherwise it issues PointerReason_WheelChange (9) to an
    external WimpScroll module
  * Several bugs and an interrupt hole resolved
Admin:
  Tested at Framlingham.

Version 0.25. Tagged as 'NetBSD-0_25'
@
text
@d1 1
a1 6
/*	$NetBSD: ehci.c,v 1.40 2002/11/19 19:18:09 martin Exp $	*/

/*
 * TODO
 *  hold off explorations by companion controllers until ehci has started.
 */
d46 7
d54 12
d69 2
a70 1
__KERNEL_RCSID(0, "$NetBSD: ehci.c,v 1.40 2002/11/19 19:18:09 martin Exp $");
d239 5
a243 1
	LIST_REMOVE((ex), inext)
d677 1
a677 1
	struct ehci_xfer *ex;
d690 2
a691 1
	for (ex = LIST_FIRST(&sc->sc_intrhead); ex; ex = LIST_NEXT(ex, inext))
d693 1
d802 4
d1859 1
a1859 1
		if (value & 0xff != 0) {
d2320 1
d2605 1
a2605 1
	if (xfer->status != USBD_NOMEM) {
d2728 1
d2741 1
d2937 1
a2937 1
	if (xfer->status != USBD_NOMEM) {
d2939 1
a2939 1
		ehci_free_sqtd_chain(sc, ex->sqtdstart, 0);
@


1.1
log
@Merge of Dan Ellis's USB2 sources.

Version 0.22. Tagged as 'NetBSD-0_22'
@
text
@d1644 3
d1648 1
d1660 3
d1664 1
d1677 3
d1681 1
d1688 3
d1692 1
d1697 3
d1701 1
d1834 1
a1834 1
		if (value != 0) {
d1851 3
d1855 1
d1894 3
d1898 1
d2689 3
d2693 1
@


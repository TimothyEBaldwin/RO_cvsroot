head	1.9;
access;
symbols
	NetBSD-1_19:1.9
	NetBSD-1_18:1.9
	NetBSD-1_17:1.9
	NetBSD-1_16:1.9
	NetBSD-1_15:1.9
	NetBSD-1_14:1.9
	NetBSD-1_13:1.9
	NetBSD-1_12:1.9
	NetBSD-1_09-1:1.9
	NetBSD-1_11:1.9
	NetBSD-1_10:1.9
	NetBSD-1_09:1.9
	NetBSD-1_08:1.9
	NetBSD-1_07:1.9
	NetBSD-1_06:1.9
	NetBSD-1_05:1.9
	NetBSD-1_04:1.9
	NetBSD-1_03:1.9
	NetBSD-1_02:1.9
	NetBSD-1_01:1.9
	NetBSD-1_00:1.9
	NetBSD-0_99:1.9
	NetBSD-0_98:1.9
	NetBSD-0_97:1.9
	NetBSD-0_96:1.9
	NetBSD-0_95:1.9
	NetBSD-0_94:1.9
	NetBSD-0_93:1.9
	NetBSD-0_92:1.9
	NetBSD-0_91:1.9
	NetBSD-0_90:1.9
	NetBSD-0_89:1.9
	NetBSD-0_88:1.9
	NetBSD-0_87:1.9
	NetBSD-0_86:1.9
	NetBSD-0_85:1.9
	NetBSD-0_84:1.9
	NetBSD-0_83:1.9
	NetBSD-0_82:1.9
	NetBSD-0_81:1.9
	NetBSD-0_80:1.9
	NetBSD-0_79:1.9
	NetBSD-0_78:1.9
	NetBSD-0_77:1.9
	NetBSD-0_76:1.9
	NetBSD-0_75:1.8
	NetBSD-0_74:1.8
	NetBSD-0_73:1.8
	NetBSD-0_72:1.8
	NetBSD-0_71:1.8
	NetBSD-0_70:1.8
	NetBSD-0_69:1.8
	NetBSD-0_68:1.8
	NetBSD-0_67:1.7
	NetBSD-0_66:1.7
	NetBSD-0_65:1.7
	NetBSD-0_64:1.7
	NetBSD-0_63:1.7
	NetBSD-0_62:1.7
	NetBSD-0_61:1.7
	NetBSD-0_60:1.7
	NetBSD-0_59:1.7
	NetBSD-0_58:1.7
	NetBSD-0_57:1.7
	NetBSD-0_56:1.7
	NetBSD-0_55:1.7
	NetBSD-0_54:1.7
	NetBSD-0_53:1.7
	NetBSD-0_52:1.7
	NetBSD-0_51:1.7
	NetBSD-0_50:1.7
	NetBSD-0_49:1.7
	NetBSD-0_48:1.7
	NetBSD-0_47:1.7
	NetBSD-0_46:1.7
	NetBSD-0_45:1.7
	NetBSD-0_44:1.7
	NetBSD-0_43:1.7
	NetBSD-0_42:1.7
	NetBSD-0_41:1.7
	NetBSD-0_40:1.7
	NetBSD-0_39:1.7
	NetBSD-0_38:1.7
	NetBSD-0_37:1.7
	NetBSD-0_36:1.7
	NetBSD-0_35:1.6
	NetBSD-0_34:1.6
	NetBSD-0_33:1.6
	NetBSD-0_32:1.6
	NetBSD-0_31:1.6
	NetBSD-0_30:1.6
	NetBSD-0_29:1.6
	RO_5_07:1.5
	NetBSD-0_28:1.5
	NetBSD-0_27:1.5
	NetBSD-0_26:1.5
	NetBSD-0_25:1.4
	NetBSD-0_24:1.3
	NetBSD-0_23:1.3
	NetBSD-0_21-1_22_2_1:1.2
	NetBSD-0_22:1.3
	USB1:1.2.0.2
	NetBSD-0_21:1.2
	NetBSD-0_20:1.2
	NetBSD-0_19:1.2
	NetBSD-0_18:1.2
	NetBSD-0_17:1.2
	NetBSD-0_16:1.2
	NetBSD-0_15:1.2
	NetBSD-0_14:1.2
	NetBSD-0_13:1.2
	NetBSD-0_12:1.2
	NetBSD-0_11:1.2
	NetBSD-0_10:1.1
	NetBSD-0_09:1.1
	NetBSD-0_08:1.1
	NetBSD-0_07:1.1
	NetBSD-0_06:1.1
	NetBSD-0_05:1.1
	NetBSD-0_04:1.1
	NetBSD-0_03:1.1
	NetBSD-0_02:1.1
	NetBSD-0_01:1.1;
locks; strict;
comment	@# @;


1.9
date	2012.12.05.01.59.20;	author jlee;	state Exp;
branches;
next	1.8;
commitid	QiGLK99lNineGYuw;

1.8
date	2012.02.18.15.36.17;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	tTFWWR62eUupyETv;

1.7
date	2005.02.23.00.01.58;	author jballance;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.12.13.04.15;	author kbracey;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.30.14.50.35;	author kbracey;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.06.15.50.22;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.21.20.49.15;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.10.14.07.18;	author kbracey;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.28.09.55.14;	author dellis;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Let other keyboard drivers know when the last USB keyboard is disconnected
Detail:
  build/c/usbkboard - detach_keyboard() now issues KeyV_KeyboardRemoved when the last keyboard is removed, to provide a hint to other keyboard drivers (e.g. PandoraKey) that they can reclaim KeyV.
  build/Version - Increased USBDriver version number
Admin:
  Tested on Pandora


Version 0.76. Tagged as 'NetBSD-0_76'
@
text
@/* Copyright 2003 Tematic Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* mouse interface */
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#include "Global/RISCOS.h"
#include "Global/Keyboard.h"
#include "Global/Pointer.h"
#include "callx/callx.h"

#include "usbmodhead.h"
#include "swis.h"
#include "debuglib/debuglib.h"

#include <sys/callout.h>
#include <sys/ioctl.h>

#include "dev/usb/usb.h"
#include "dev/usb/usbdi.h"
#include "dev/usb/usbdi_util.h"
#include "dev/usb/usbdivar.h"
#include "dev/usb/usbhid.h"

#include "usbkboard.h"

#include "wimplib.h"

#define MagicNoDebounce 0x4e6f4b64

#define NUM_LOCK 0x01
#define CAPS_LOCK 0x02
#define SCROLL_LOCK 0x04

#define RSVD 0xFF     /* Reserved keys that have no mapping */
#define NEQV 0xFF     /* Keys in USB that have no RISC OS equivalent */
#define UDEF 0xFF     /* Keys that are undefined */

#define NKEYCODE 6

extern void* private_word;

void ukbd_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);

struct ukbd_data {
    uint8_t modifiers;
    uint8_t reserved;
    uint8_t keycode[NKEYCODE];
};

struct ukbd_softc {
    USBBASEDEVICE           sc_dev;
    usbd_device_handle      sc_udev;
    usbd_interface_handle   sc_iface;       /* interface */
    usbd_pipe_handle        sc_intrpipe;    /* interrupt pipe */
    int                     sc_ep_addr;

    /* bits to keep track of keys currently depressed */
    uint32_t                status[8];

    struct ukbd_data        data, odata;

    /* LEDS */
    uint8_t                 res;

    /* list of ukbd softcs */
    TAILQ_ENTRY(ukbd_softc) link_kb;
};

TAILQ_HEAD(ukbdlist, ukbd_softc) allukbds = TAILQ_HEAD_INITIALIZER(allukbds);

/* Mapping table from USB keycodes to low-level internal key numbers - see PRM
 * 1-156.  The index into the table is the USB keycode, as defined in the HID
 * Usage tables.  The array starts off a-z, 1-0.
 */
static unsigned char mapping_table[256] = {
RSVD,               RSVD,            RSVD,             RSVD,             /*0*/
KeyNo_LetterA,      KeyNo_LetterB,   KeyNo_LetterC,    KeyNo_LetterD,
KeyNo_LetterE,      KeyNo_LetterF,   KeyNo_LetterG,    KeyNo_LetterH,
KeyNo_LetterI,      KeyNo_LetterJ,   KeyNo_LetterK,    KeyNo_LetterL,
KeyNo_LetterM,      KeyNo_LetterN,   KeyNo_LetterO,    KeyNo_LetterP,    /*1*/
KeyNo_LetterQ,      KeyNo_LetterR,   KeyNo_LetterS,    KeyNo_LetterT,
KeyNo_LetterU,      KeyNo_LetterV,   KeyNo_LetterW,    KeyNo_LetterX,
KeyNo_LetterY,      KeyNo_LetterZ,   KeyNo_Digit1,     KeyNo_Digit2,
KeyNo_Digit3,       KeyNo_Digit4,    KeyNo_Digit5,     KeyNo_Digit6,     /*2*/
KeyNo_Digit7,       KeyNo_Digit8,    KeyNo_Digit9,     KeyNo_Digit0,
KeyNo_Return,       KeyNo_Escape,    KeyNo_BackSpace,  KeyNo_Tab,
KeyNo_Space,        KeyNo_Minus,     KeyNo_Equals,     KeyNo_OpenSquare,
KeyNo_CloseSquare,  KeyNo_BackSlash, KeyNo_BackSlash,  KeyNo_SemiColon,  /*3*/
KeyNo_Tick,         KeyNo_BackTick,  KeyNo_Comma,      KeyNo_Dot,
KeyNo_Slash,        KeyNo_CapsLock,  KeyNo_Function1,  KeyNo_Function2,
KeyNo_Function3,    KeyNo_Function4, KeyNo_Function5,  KeyNo_Function6,
KeyNo_Function7,    KeyNo_Function8, KeyNo_Function9,  KeyNo_Function10, /*4*/
KeyNo_Function11,   KeyNo_Function12,KeyNo_Print,      KeyNo_ScrollLock,
KeyNo_Break,        KeyNo_Insert,    KeyNo_Home,       KeyNo_PageUp,
KeyNo_Delete,       KeyNo_Copy,      KeyNo_PageDown,   KeyNo_CursorRight,
KeyNo_CursorLeft,   KeyNo_CursorDown,KeyNo_CursorUp,   KeyNo_NumLock,    /*5*/
KeyNo_NumPadSlash,  KeyNo_NumPadStar,KeyNo_NumPadMinus,KeyNo_NumPadPlus,
KeyNo_NumPadEnter,  KeyNo_NumPad1,   KeyNo_NumPad2,    KeyNo_NumPad3,
KeyNo_NumPad4,      KeyNo_NumPad5,   KeyNo_NumPad6,    KeyNo_NumPad7,
KeyNo_NumPad8,      KeyNo_NumPad9,   KeyNo_NumPad0,    KeyNo_NumPadDot,  /*6*/
KeyNo_NotFittedLeft,KeyNo_Menu,      NEQV,             KeyNo_NumPadHash,
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,             /*7*/
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,             /*8*/
NEQV,               NEQV,            NEQV,             KeyNo_NotFittedRight,
KeyNo_Kana,         KeyNo_Pound,     KeyNo_Convert,    KeyNo_NoConvert,
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,             /*9*/
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,             /*a*/
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,             /*b*/
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,             /*c*/
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,             /*d*/
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
KeyNo_CtrlLeft,     KeyNo_ShiftLeft, KeyNo_AltLeft,    KeyNo_AcornLeft,  /*e*/
KeyNo_CtrlRight,    KeyNo_ShiftRight,KeyNo_AltRight,   KeyNo_AcornRight,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,             /*f*/
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD
};

extern void remove_all_keyboards (void)
{
    struct ukbd_softc* sc;
    TAILQ_FOREACH(sc, &allukbds, link_kb)
    {
        detach_keyboard ((struct device*) sc);
    }
}

struct device* attach_keyboard (struct device* parent, void* aux)
{
    struct ukbd_softc* softc;
    struct usb_attach_arg *uaa = aux;
    usb_interface_descriptor_t *id;
    usb_endpoint_descriptor_t *ed;

    dprintf (("", "Trying match on usb keyboard\n"));

    /* First see if we match */
    /* Check that this is a keyboard that speaks the boot protocol. */
    if (uaa->iface == NULL)
    {
       dprintf (("", "Failed to match\n"));
       return (UMATCH_NONE);
    }
    id = usbd_get_interface_descriptor(uaa->iface);
    if (id == NULL ||
        id->bInterfaceClass != UICLASS_HID ||
        id->bInterfaceSubClass != UISUBCLASS_BOOT ||
        id->bInterfaceProtocol != UIPROTO_BOOT_KEYBOARD)
    {
       dprintf (("", "Failed to match\n"));
       return (UMATCH_NONE);
    }

    /* If so, allocate memory for the device and attach ourselves. */
    softc = calloc (sizeof *softc, 1);
    if (softc == NULL) {
        dprintf (("", "Couldn't allocate memory for keyboard device\n"));
        return NULL;
    }
    strcpy (softc->sc_dev.dv_xname, "USBK"Module_VersionString);
    softc->sc_dev.dv_cfdata = (void*) 4; // keyboard

    softc->sc_udev = uaa->device;
    softc->sc_iface = uaa->iface;

    ed = usbd_interface2endpoint_descriptor(uaa->iface, 0);
    if (ed == NULL) {
        dprintf(("", "Could not read endpoint descriptor\n"));
        return NULL;
    }

    if (usbd_set_protocol(uaa->iface, 0)) {
        dprintf(("", "Set protocol failed\n"));
        return NULL;
    }

    softc->sc_ep_addr = ed->bEndpointAddress;


    if (TAILQ_EMPTY(&allukbds))
        _swix (OS_Claim, _INR(0,2), KEYV, keyv_entry, private_word);

    TAILQ_INSERT_TAIL (&allukbds, softc, link_kb);

    _swix (OS_CallAVector, _INR(0, 2) | _IN(9),
        KeyV_KeyboardPresent, KeyboardID_PC , MagicNoDebounce, KEYV);
    dprintf (("", "USB keyboard enabled\n"));

    /* set idle rate to 0 */
    usbd_set_idle (softc->sc_iface, 0, 0);

    /* Set up interrupt pipe. */
    usbd_open_pipe_intr(softc->sc_iface, softc->sc_ep_addr,
        USBD_SHORT_XFER_OK, &softc->sc_intrpipe, softc,
        &softc->data, sizeof(softc->data), ukbd_intr,
        USBD_DEFAULT_INTERVAL);

    return (struct device*) softc;
}

int detach_keyboard (struct device* kb)
{
    struct ukbd_softc* sc = (struct ukbd_softc*) kb;
    if(!sc || !sc->sc_intrpipe)
    {
      dprintf (("", "attempt to detach a NULL keyboard 'sc'\n"));
      return 0;
    }

    uint32_t * status = sc->status;
    /* release any keys held down */
    for (int w = 0; w < sizeof sc->status / sizeof (int); ++w)
    {
        if (status[w] == 0) continue;
        int key = w * 32;
        for (uint32_t ww = status[w]; ww; ww >>= 1, key++)
        {
            if ((ww & 1) == 0) continue;

            _swix (OS_CallAVector,

                _INR(0,1) | _IN(9),

                KeyV_KeyUp,
                key,
                KEYV
            );
        }
    }

    usbd_abort_pipe(sc->sc_intrpipe);
    usbd_close_pipe(sc->sc_intrpipe);
    TAILQ_REMOVE (&allukbds, sc, link_kb);
    if (TAILQ_EMPTY(&allukbds))
    {
        _swix (OS_Release, _INR(0,2), KEYV, keyv_entry, private_word);
        /* Notify any other drivers (e.g. PandoraKey) that there (probably) aren't any PC keyboards connected anymore */
        _swix (OS_CallAVector, _INR(0,1)|_IN(9), KeyV_KeyboardRemoved, KeyboardID_PC, KEYV);
    }
    free (kb);
    return 0;
}

int keyv (_kernel_swi_regs* r, void* pw)
{
    (void) pw;

    struct ukbd_softc* sc;
    TAILQ_FOREACH(sc, &allukbds, link_kb)
    {
        uint8_t * res = &sc->res;

        switch (r->r[0]) {
        case KeyV_EnableDrivers:
            memset (&sc->status[0], 0, sizeof sc->status);
            break;
        case KeyV_NotifyLEDState:
            *res = 0;
            if (r->r[1] & KeyV_LED_ScrollLock) *res |= SCROLL_LOCK;
            if (r->r[1] & KeyV_LED_NumLock) *res |= NUM_LOCK;
            if (r->r[1] & KeyV_LED_CapsLock) *res |= CAPS_LOCK;
            usbd_set_report_async(sc->sc_iface, UHID_OUTPUT_REPORT,
                0, res, 1);
            break;
        }
    }

    return 1;
}

#ifdef PS2KLUDGE
_kernel_oserror* keyup (_kernel_swi_regs* r, void* pw, void* k)
{
    (void) r;
    (void) pw;

//    dprintf (("", "Key Up: %x\n", (int) k));
    return _swix (OS_CallAVector,

        _INR(0,1) | _IN(9),

        KeyV_KeyUp,
        k,
        KEYV
    );
}
#endif

void ukbd_intr
(
    usbd_xfer_handle    xfer,
    usbd_private_handle addr,
    usbd_status         ustatus
)
{
    struct ukbd_softc *sc = addr;
    struct ukbd_data * data = &sc->data;
    struct ukbd_data * odata = &sc->odata;
    uint32_t * status = sc->status;
    int i;
    int key;
    int bit;
    uint8_t mods;
    uint8_t omods = odata->modifiers;
    uint8_t moddiff;
    uint32_t newstatus[8];

//    if (ustatus == USBD_CANCELLED)
//        return;

    if (ustatus) {
        dprintf(("", "ukbd_intr: status=%d\n", ustatus));
        if (ustatus != USBD_CANCELLED)
        {
            usbd_clear_endpoint_stall_async(sc->sc_intrpipe);
        }
        return;
    }

    mods = data->modifiers;

    /* check for error condition */
    if (data->keycode[0] == 1) return;

//    dprintf (("", "%02x %02x %02x %02x %02x %02x %02x %02x\n",
//        data->modifiers,
//        data->reserved,
//        data->keycode[0],
//        data->keycode[1],
//        data->keycode[2],
//        data->keycode[3],
//        data->keycode[4],
//        data->keycode[5]));

    memset (&newstatus[0], 0, sizeof newstatus);

    /* check each bit of the modifier field, if it's changed state,
       report the new state */
    moddiff = mods ^ omods;
    for (i = 0; i < 8; ++i) {
        if (moddiff & (1 << i)) {
            _swix (OS_CallAVector,

                _INR(0,1) | _IN(9),

                (mods & (1 << i))? KeyV_KeyDown: KeyV_KeyUp,
                mapping_table[0xe0 + i],
                KEYV
            );
        }
    }

    /* Scan new keys for key down event.  We have to construct the
    newstatus before we can check for key down. */
    for (i = 0; i < NKEYCODE; ++i) {
        key = mapping_table[data->keycode[i]];
        if (key != RSVD && key != NEQV) {
            bit = 1 << (key % 32);
            newstatus[key / 32] |= bit;
            if ((status[key / 32] & bit) == 0)
            {
                _swix (OS_CallAVector,

                    _INR(0,1) | _IN(9),

                    KeyV_KeyDown,
                    key,
                    KEYV
                );
//                dprintf (("", "Key Down: %x\n", key));
            }
        }
    }

    /* Scan old keys for key up event */
    for (i = 0; i < NKEYCODE; ++i) {
        key = mapping_table[odata->keycode[i]];
        if (key != RSVD && key != NEQV) {
            bit = 1 << (key % 32);
            if ((newstatus[key / 32] & bit) == 0)
            {
#ifdef PS2KLUDGE
                callx_add_callafter (2, keyup, (void*) key);
#else
                _swix (OS_CallAVector,

                    _INR(0,1) | _IN(9),

                    KeyV_KeyUp,
                    key,
                    KEYV
                );
//                dprintf (("", "Key Up: %x\n", key));
#endif
            }
        }
    }

    memcpy (sc->status, newstatus, sizeof sc->status);
    sc->odata = *data;
}
@


1.8
log
@Add some more usbdevs from the NetBSD sources.
In particular, the SMSC ethernet controller and hub on the Beagleboard
xm.
Changed pointer assignments & comparisons with 0 to be NULL for clarity.
Implement a left trim function for any printed out strings obtained from
the device (to mirror usbd_trim_spaces) so that when dopey manufacturers
use a space instead of their company name everything lines up still.

Version 0.68. Tagged as 'NetBSD-0_68'
@
text
@d272 1
d274 3
@


1.7
log
@        An increased delay caused havoc with chicony keyboards in the field
Detail:
        USB_PORT_RESET_DELAY had been increased from 100 to 200ms in previous
        version. This was OK for most devices, and beneficial for some, BUT
        killed the Chicony keyboards shipped with many iyonix.. Delay has
        been reverted to 100ms, and is now run time alterable via the
        USB$PortResetDelay sysvar. This problem did not show up in beta testing!

Admin:  tested by JB with chicony.. delays up to around 160ms work with
        the chicony.
        Castle added IP

Version 0.36. Tagged as 'NetBSD-0_36'
@
text
@d193 1
a193 1
    if (softc == 0) {
@


1.6
log
@Added 5 extra keycodes for Japanese keyboards to usbkboard.c

Version 0.29. Tagged as 'NetBSD-0_29'
@
text
@d341 2
a342 2
    if (ustatus == USBD_CANCELLED)
        return;
@


1.5
log
@Latest stuff from John - mainly Rhenium improvements.

Version 0.26. Tagged as 'NetBSD-0_26'
@
text
@d123 2
a124 2
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,
@


1.4
log
@  New versions from John.
Detail:
  * All modules will now rmkill/rmload more reliably
  * Keyboard driver disables kernel debounce on new enough kernels, needed
    for many PS2-USB adaptors, bar code scanners etc
  * Mouse driver will scroll wheel scroll any windows that do respond to
    scroll events, otherwise it issues PointerReason_WheelChange (9) to an
    external WimpScroll module
  * Several bugs and an interrupt hole resolved
Admin:
  Tested at Framlingham.

Version 0.25. Tagged as 'NetBSD-0_25'
@
text
@d241 6
@


1.3
log
@Merge of Dan Ellis's USB2 sources.

Version 0.22. Tagged as 'NetBSD-0_22'
@
text
@d42 2
d222 2
a223 2
    _swix (OS_CallAVector, _INR(0, 1) | _IN(9),
        KeyV_KeyboardPresent, KeyboardID_PC, KEYV);
@


1.2
log
@Fix for erratic behaviour after having unplugged hubs: TAILQ was
being given an entry which wasn't on its list, and the behaviour was to
break the list and poke a zero into the reset vector!
Also, some extra IFDEF's so that debug builds will work again.
A few typos/spelling errors changed.

Version 0.11. Tagged as 'NetBSD-0_11'
@
text
@d38 2
d154 9
d224 2
d296 18
d386 1
d395 2
d406 4
d418 3
@


1.1
log
@Import of USB driver suitable for generic PCI based OHCI controllers.
Correction of spelling of busses to buses (noun plural).
OHCIdriver only responds to PCI service call to lookup vendor name when
the device is of class OHCI controller.

Version 0.01. Tagged as 'NetBSD-0_01'
@
text
@d164 4
a167 1
        return (UMATCH_NONE);
d173 4
a176 2
    	return (UMATCH_NONE);

d192 1
a192 1
        dprintf(("", "could not read endpoint descriptor\n"));
d197 1
a197 1
        dprintf(("", "set protocol failed\n"));
@


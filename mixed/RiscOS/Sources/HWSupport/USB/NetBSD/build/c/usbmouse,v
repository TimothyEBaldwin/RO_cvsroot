head	1.17;
access;
symbols
	NetBSD-1_19:1.17
	NetBSD-1_18:1.17
	NetBSD-1_17:1.16
	NetBSD-1_16:1.16
	NetBSD-1_15:1.15
	NetBSD-1_14:1.15
	NetBSD-1_13:1.15
	NetBSD-1_12:1.15
	NetBSD-1_09-1:1.15
	NetBSD-1_11:1.15
	NetBSD-1_10:1.15
	NetBSD-1_09:1.15
	NetBSD-1_08:1.15
	NetBSD-1_07:1.15
	NetBSD-1_06:1.15
	NetBSD-1_05:1.15
	NetBSD-1_04:1.15
	NetBSD-1_03:1.15
	NetBSD-1_02:1.15
	NetBSD-1_01:1.15
	NetBSD-1_00:1.15
	NetBSD-0_99:1.15
	NetBSD-0_98:1.15
	NetBSD-0_97:1.15
	NetBSD-0_96:1.15
	NetBSD-0_95:1.15
	NetBSD-0_94:1.15
	NetBSD-0_93:1.14
	NetBSD-0_92:1.14
	NetBSD-0_91:1.14
	NetBSD-0_90:1.14
	NetBSD-0_89:1.14
	NetBSD-0_88:1.14
	NetBSD-0_87:1.14
	NetBSD-0_86:1.14
	NetBSD-0_85:1.14
	NetBSD-0_84:1.14
	NetBSD-0_83:1.14
	NetBSD-0_82:1.14
	NetBSD-0_81:1.14
	NetBSD-0_80:1.14
	NetBSD-0_79:1.14
	NetBSD-0_78:1.14
	NetBSD-0_77:1.14
	NetBSD-0_76:1.14
	NetBSD-0_75:1.14
	NetBSD-0_74:1.14
	NetBSD-0_73:1.14
	NetBSD-0_72:1.14
	NetBSD-0_71:1.14
	NetBSD-0_70:1.14
	NetBSD-0_69:1.14
	NetBSD-0_68:1.14
	NetBSD-0_67:1.13
	NetBSD-0_66:1.13
	NetBSD-0_65:1.13
	NetBSD-0_64:1.13
	NetBSD-0_63:1.12
	NetBSD-0_62:1.12
	NetBSD-0_61:1.12
	NetBSD-0_60:1.12
	NetBSD-0_59:1.12
	NetBSD-0_58:1.11
	NetBSD-0_57:1.11
	NetBSD-0_56:1.11
	NetBSD-0_55:1.11
	NetBSD-0_54:1.11
	NetBSD-0_53:1.11
	NetBSD-0_52:1.10
	NetBSD-0_51:1.10
	NetBSD-0_50:1.10
	NetBSD-0_49:1.9
	NetBSD-0_48:1.9
	NetBSD-0_47:1.9
	NetBSD-0_46:1.9
	NetBSD-0_45:1.9
	NetBSD-0_44:1.9
	NetBSD-0_43:1.9
	NetBSD-0_42:1.9
	NetBSD-0_41:1.9
	NetBSD-0_40:1.9
	NetBSD-0_39:1.9
	NetBSD-0_38:1.9
	NetBSD-0_37:1.9
	NetBSD-0_36:1.9
	NetBSD-0_35:1.9
	NetBSD-0_34:1.9
	NetBSD-0_33:1.9
	NetBSD-0_32:1.9
	NetBSD-0_31:1.9
	NetBSD-0_30:1.8
	NetBSD-0_29:1.8
	RO_5_07:1.8
	NetBSD-0_28:1.8
	NetBSD-0_27:1.7
	NetBSD-0_26:1.7
	NetBSD-0_25:1.6
	NetBSD-0_24:1.5
	NetBSD-0_23:1.5
	NetBSD-0_21-1_22_2_1:1.3
	NetBSD-0_22:1.4
	USB1:1.3.0.2
	NetBSD-0_21:1.3
	NetBSD-0_20:1.3
	NetBSD-0_19:1.3
	NetBSD-0_18:1.3
	NetBSD-0_17:1.3
	NetBSD-0_16:1.3
	NetBSD-0_15:1.3
	NetBSD-0_14:1.3
	NetBSD-0_13:1.3
	NetBSD-0_12:1.3
	NetBSD-0_11:1.3
	NetBSD-0_10:1.2
	NetBSD-0_09:1.2
	NetBSD-0_08:1.2
	NetBSD-0_07:1.1
	NetBSD-0_06:1.1
	NetBSD-0_05:1.1
	NetBSD-0_04:1.1
	NetBSD-0_03:1.1
	NetBSD-0_02:1.1
	NetBSD-0_01:1.1;
locks; strict;
comment	@# @;


1.17
date	2016.12.17.10.12.57;	author rool;	state Exp;
branches;
next	1.16;
commitid	yws6HYEy6os04kyz;

1.16
date	2016.06.21.22.04.05;	author jlee;	state Exp;
branches;
next	1.15;
commitid	kareoT4McyRIKnbz;

1.15
date	2015.06.29.19.34.51;	author jlee;	state Exp;
branches;
next	1.14;
commitid	xm6CArfSWPrXqmry;

1.14
date	2012.02.18.15.36.18;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	tTFWWR62eUupyETv;

1.13
date	2011.12.10.21.42.21;	author jlee;	state Exp;
branches;
next	1.12;
commitid	KVm6UAsJ6mTvPGKv;

1.12
date	2011.05.22.20.22.34;	author jlee;	state Exp;
branches;
next	1.11;
commitid	Ye1jVWDlKivFSIkv;

1.11
date	2010.09.14.21.07.37;	author jlee;	state Exp;
branches;
next	1.10;

1.10
date	2010.02.28.15.57.31;	author jlee;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.30.02.34.17;	author jballance;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.12.14.47.39;	author jballance;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.30.14.50.35;	author kbracey;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.06.15.50.22;	author bavison;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.16.15.43.50;	author kbracey;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.21.20.49.15;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.10.14.07.18;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.02.17.05.51;	author rsprowson;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.28.09.55.14;	author dellis;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Messages fixes, internationalisation, minor clean ups
Detail:
  USBDriver was performing unnecessary messages file reopening on Service_ResourceFSStarted (MessageTrans does this itself), remove this.
  Internationalised USBDriver, in particular its *Commands.
  Fixed standalone builds to output the messages file objects in the right place (Makefile mistake).
  Changed OHCIDriver and EHCIDriver to use allocated error bases rather than 0.
  Sync'd, where possible, the OHCIDriver and EHCIDriver sources which share a common heritage. Tentative shared interrupt support fixes for non-PCI attached controllers. Comment blocks & indentation improved.
  Export min() macro in usb_port.h.
  CMHG updated to not listen for unwanted services.
Admin:
  Submission for USB bounty.
  Tested on Pandaboard and Pi 2. OHCIDriver untested but low risk.

Version 1.18. Tagged as 'NetBSD-1_18'
@
text
@/* Copyright 2003 Tematic Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/* mouse interface */
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#include "Global/RISCOS.h"
#include "Global/Keyboard.h"
#include "Global/Pointer.h"
#include "Global/VduExt.h"

#include "usbmodhead.h"
#include "swis.h"
#include "debuglib/debuglib.h"
#include "callx/callx.h"

#include <sys/callout.h>
#include <sys/ioctl.h>

#include "dev/usb/usb.h"
#include "dev/usb/usbhid.h"

#include "dev/usb/usbdi.h"
#include "dev/usb/usbdi_util.h"
#include "dev/usb/usbdivar.h"
#include <dev/usb/usbdevs.h>
#include <dev/usb/usb_quirks.h>
#include <dev/usb/hid.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsmousevar.h>

#include "usbmouse.h"

#include "wimplib.h"

#ifdef __riscos
#define printf logprintf
#define aprint_verbose logprintf
#define aprint_normal logprintf
#define aprint_error logprintf
#endif

#ifdef USB_DEBUG
#define DPRINTF(x)	if (umsdebug) logprintf x
#define DPRINTFN(n,x)	if (umsdebug>(n)) logprintf x
int	umsdebug = 10;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#ifdef __riscos
#define UMS_BUT(i) (i)
#else
#define UMS_BUT(i) ((i) == 1 || (i) == 2 ? 3 - (i) : i)
#endif

extern void ums_enable (void*);
extern void ums_disable (void*);

extern struct messages mod_messages;

extern struct cfattach ums_ca;

static int relx = 0, rely = 0, relz = 0, relw = 0, morebuttons = 0;
static bool enabled = false;

void ums_intr (usbd_xfer_handle xfer, usbd_private_handle addr, usbd_status status);

static int uhidev_maxrepid(void *buf, int len);

#define MAX_BUTTONS	31	/* must not exceed size of sc_buttons */

struct tsscale {
	int minx, maxx;
	int miny, maxy;
};

struct ums_softc {
	USBBASEDEVICE sc_dev;		/* base device */
	usbd_device_handle sc_udev;
	usbd_interface_handle sc_iface; /* interface */
	usbd_pipe_handle sc_intrpipe;	/* interrupt pipe */
	int sc_ep_addr;

	u_char *sc_ibuf;
	u_int8_t sc_iid;
	int sc_isize;
	struct hid_location sc_loc_x, sc_loc_y, sc_loc_z, sc_loc_w;
	struct hid_location *sc_loc_btn;
	struct tsscale sc_tsscale;

	int sc_enabled;

	int flags;		/* device configuration */
#define UMS_Z		0x01	/* z direction available */
#define UMS_SPUR_BUT_UP	0x02	/* spurious button up events */
#define UMS_REVZ	0x04	/* Z-axis is reversed */
#define UMS_W		0x08	/* w direction/tilt available */
#define UMS_ABS		0x10	/* absolute position, touchpanel */

	int nbuttons;

	u_int32_t sc_buttons;	/* mouse button status */

	char			sc_dying;

	/* list of ukbd softcs */
	TAILQ_ENTRY(ums_softc) link_ms;
};

#define MOUSE_FLAGS_MASK (HIO_CONST|HIO_RELATIVE)

TAILQ_HEAD(umslist, ums_softc) allums = TAILQ_HEAD_INITIALIZER(allums);

extern void remove_all_mice (void)
{
	struct ums_softc* sc;
	TAILQ_FOREACH(sc, &allums, link_ms)
	{
		detach_mouse ((struct device*) sc);
	}
}

static int match_mouse (struct usb_attach_arg *uaa)
{
	usb_interface_descriptor_t *id;
	int size, ret, nrepid, repid;
	void *desc;
	usbd_status err;

	dprintf (("", "Trying ums attach\n"));
	if (uaa->iface == NULL)
		return (UMATCH_NONE);
	id = usbd_get_interface_descriptor(uaa->iface);
	if (id == NULL || id->bInterfaceClass != UICLASS_HID)
	{
		dprintf (("", "failed class match: id == %p\n", id));
		return (UMATCH_NONE);
	}

	/*
	 * Some (older) Griffin PowerMate knobs may masquerade as a
	 * mouse, avoid treating them as such, they have only one axis.
	 */
	if (uaa->vendor == USB_VENDOR_GRIFFIN &&
	    uaa->product == USB_PRODUCT_GRIFFIN_POWERMATE)
		return (UMATCH_NONE);

	err = usbd_read_report_desc(uaa->iface, &desc, &size, M_USBDEV);
	if (err)
	{
		dprintf (("", "failed to get report\n"));
		return (UMATCH_NONE);
	}

	nrepid = uhidev_maxrepid(desc, size);
	

	ret = UMATCH_NONE;
	for (repid = 0; repid <= nrepid; repid++)
	{
		if ((hid_is_collection(desc, size, repid,
			HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_MOUSE)))
		 || (hid_is_collection(desc, size, repid,
			HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_POINTER))))
		{
			ret = UMATCH_IFACECLASS;
		}
	}


	free(desc);
	dprintf (("", "ums attach returning: %d\n", ret));
	return (ret);
}

/* Report descriptor for a mouse in boot protocol mode, from the USB HID spec */
static const char boot_descriptor[] =
{
	0x05, 0x01,
	0x09, 0x02,
	0xa1, 0x01,
	0x09, 0x01,
	0xa1, 0x00,
	0x05, 0x09,
	0x19, 0x01,
	0x29, 0x03,
	0x15, 0x00,
	0x25, 0x01,
	0x95, 0x03,
	0x75, 0x01,
	0x81, 0x02,
	0x95, 0x01,
	0x75, 0x05,
	0x81, 0x01,
	0x05, 0x01,
	0x09, 0x30,
	0x09, 0x31,
	0x15, 0x81,
	0x25, 0x7f,
	0x75, 0x08,
	0x95, 0x02,
	0x81, 0x06,
	0xc0,
	0xc0
};

static void do_attach_mouse (struct ums_softc* sc, struct usb_attach_arg *uaa)
{
	usbd_interface_handle iface = uaa->iface;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	int size;
	void *desc;
	usbd_status err;
#ifdef USB_DEBUG
	char devinfo[1024];
#endif
	u_int32_t flags, quirks;
	int i, repid, nrepid;
	int hl;
	struct hid_location *zloc;
	struct hid_location loc_btn;

	sc->sc_udev = uaa->device;
	sc->sc_iface = iface;
	id = usbd_get_interface_descriptor(iface);
#ifdef USB_DEBUG
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
	USB_ATTACH_SETUP;
	dprintf(("%s: %s, iclass %d/%d\n", USBDEVNAME(sc->sc_dev),
	       devinfo, id->bInterfaceClass, id->bInterfaceSubClass));
#endif
	ed = usbd_interface2endpoint_descriptor(iface, 0);
	if (ed == NULL) {
		logprintf("%s: could not read endpoint descriptor\n",
		       USBDEVNAME(sc->sc_dev));
		USB_ATTACH_ERROR_RETURN;
	}

	dprintf(("", "ums_attach: bLength=%d bDescriptorType=%d "
		     "bEndpointAddress=%d-%s bmAttributes=%d wMaxPacketSize=%d"
		     " bInterval=%d\n",
		     ed->bLength, ed->bDescriptorType,
		     ed->bEndpointAddress & UE_ADDR,
		     UE_GET_DIR(ed->bEndpointAddress)==UE_DIR_IN? "in" : "out",
		     ed->bmAttributes & UE_XFERTYPE,
		     UGETW(ed->wMaxPacketSize), ed->bInterval));

	if (UE_GET_DIR(ed->bEndpointAddress) != UE_DIR_IN ||
	    (ed->bmAttributes & UE_XFERTYPE) != UE_INTERRUPT) {
		logprintf("%s: unexpected endpoint\n",
		       USBDEVNAME(sc->sc_dev));
		USB_ATTACH_ERROR_RETURN;
	}

	quirks = usbd_get_quirks(uaa->device)->uq_flags;
	if (quirks & UQ_MS_REVZ)
		sc->flags |= UMS_REVZ;
	if (quirks & UQ_SPUR_BUT_UP)
		sc->flags |= UMS_SPUR_BUT_UP;

	/*
	 * Deal with the broken behaviour of the touchpad of the TouchBook
	 * keyboard. Despite sending out a report descriptor containing
	 * multiple report IDs, the device only sends out data in a form that's
	 * consistent with the Boot report protocol. This is despite the fact
	 * that we explicitly switch devices into report protocol mode as part
	 * of our initialisation sequence (and the device happily accepts the
	 * command; in fact, sending a command to switch the device into Boot
	 * mode will fail). 
	 * So to cope with this we pretend the device returns a descriptor
	 * which is consistent with a boot mode mouse.
	 */
	if((uaa->vendor == USB_VENDOR_ALWAYSINNOVATING) &&
	   (uaa->product == USB_PRODUCT_ALWAYSINNOVATING_USBKBDTPAD)) {
		desc = (void *) boot_descriptor;
		size = sizeof(boot_descriptor);
	} else {
		err = usbd_read_report_desc(uaa->iface, &desc, &size, M_USBDEV);
		if (err)
			USB_ATTACH_ERROR_RETURN;
	}

	nrepid = uhidev_maxrepid(desc, size);

	for (repid = 0; repid <= nrepid; repid++)
	{
		if ((hid_is_collection(desc, size, repid,
			HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_MOUSE)))
		 || (hid_is_collection(desc, size, repid,
				HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_POINTER))))
		{
			sc->sc_iid = repid;
		}
	}

	if (!hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_X),
		       sc->sc_iid, hid_input, &sc->sc_loc_x, &flags)) {
		aprint_error("\n%s: mouse has no X report\n",
		       USBDEVNAME(sc->sc_dev));
		USB_ATTACH_ERROR_RETURN;
	}
	switch (flags & MOUSE_FLAGS_MASK) {
	case 0:
		sc->flags |= UMS_ABS;
		break;
	case HIO_RELATIVE:
		break;
	default:
		aprint_error("\n%s: X report 0x%04x not supported\n",
		       USBDEVNAME(sc->sc_dev), flags);
		USB_ATTACH_ERROR_RETURN;
	}

	if (!hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_Y),
		       sc->sc_iid, hid_input, &sc->sc_loc_y, &flags)) {
		aprint_error("\n%s: mouse has no Y report\n",
		       USBDEVNAME(sc->sc_dev));
		USB_ATTACH_ERROR_RETURN;
	}
	switch (flags & MOUSE_FLAGS_MASK) {
	case 0:
		sc->flags |= UMS_ABS;
		break;
	case HIO_RELATIVE:
		break;
	default:
		aprint_error("\n%s: Y report 0x%04x not supported\n",
		       USBDEVNAME(sc->sc_dev), flags);
		USB_ATTACH_ERROR_RETURN;
	}

	/* Try the wheel first as the Z activator since it's tradition. */
	hl = hid_locate(desc, 
			size, 
			HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_WHEEL), 
			sc->sc_iid, 
			hid_input, 
			&sc->sc_loc_z, 
			&flags);

	zloc = &sc->sc_loc_z;
	if (hl) {
		if ((flags & MOUSE_FLAGS_MASK) != HIO_RELATIVE) {
			aprint_verbose("\n%s: Wheel report 0x%04x not "
			    "supported\n", USBDEVNAME(sc->sc_dev),
			    flags);
			sc->sc_loc_z.size = 0;	/* Bad Z coord, ignore it */
		} else {
			sc->flags |= UMS_Z;
			/* Wheels need the Z axis reversed. */
			sc->flags ^= UMS_REVZ;
			/* Put Z on the W coordinate */
			zloc = &sc->sc_loc_w;
		}
	}

	hl = hid_locate(desc, 
			size, 
			HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_Z),
			sc->sc_iid,
			hid_input,
			zloc,
			&flags);

	/*
	 * The horizontal component of the scrollball can also be given by
	 * Application Control Pan in the Consumer page, so if we didnt see
	 * any Z then check that.
	 */
	if (!hl) {
		hl = hid_locate(desc, 
				size, 
				HID_USAGE2(HUP_CONSUMER, HUC_AC_PAN), 
				sc->sc_iid,
				hid_input,
				zloc,
				&flags);
	}

	if (hl) {
		if ((flags & MOUSE_FLAGS_MASK) != HIO_RELATIVE) {
			aprint_verbose("\n%s: Z report 0x%04x not supported\n",
			       USBDEVNAME(sc->sc_dev), flags);
			zloc->size = 0;	/* Bad Z coord, ignore it */
		} else {
			if (sc->flags & UMS_Z)
				sc->flags |= UMS_W;
			else
				sc->flags |= UMS_Z;
		}
	}

	/*
	 * The Microsoft Wireless Laser Mouse 6000 v2.0 reports a bad
	 * position for the wheel and wheel tilt controls -- should be
	 * in bytes 3 & 4 of the report.  Fix this if necessary.
	 */
	if (uaa->vendor == USB_VENDOR_MICROSOFT &&
	    (uaa->product == USB_PRODUCT_MICROSOFT_24GHZ_XCVR10 ||
	     uaa->product == USB_PRODUCT_MICROSOFT_24GHZ_XCVR20)) {
		if ((sc->flags & UMS_Z) && sc->sc_loc_z.pos == 0)
			sc->sc_loc_z.pos = 24;
		if ((sc->flags & UMS_W) && sc->sc_loc_w.pos == 0)
			sc->sc_loc_w.pos = sc->sc_loc_z.pos + 8;
	}

	/* Get coordinate range information for absolute pointing devices */
	if (sc->flags & UMS_ABS) {
		struct hid_item h;
		struct hid_data *d;
		d = hid_start_parse(desc, size, hid_input);
		while(hid_get_item(d, &h))
		{
			if ((h.kind != hid_input) || (HID_GET_USAGE_PAGE(h.usage) != HUP_GENERIC_DESKTOP)) {
				continue;
			}
			switch(HID_GET_USAGE(h.usage)) {
			case HUG_X:
				sc->sc_tsscale.minx = h.logical_minimum;
				sc->sc_tsscale.maxx = h.logical_maximum;
				break;
			case HUG_Y:
				sc->sc_tsscale.miny = h.logical_minimum;
				sc->sc_tsscale.maxy = h.logical_maximum;
				break;
			}
		}
		hid_end_parse(d);
		if ((sc->sc_tsscale.minx == sc->sc_tsscale.maxx) || (sc->sc_tsscale.miny == sc->sc_tsscale.maxy)) {
			aprint_verbose("\n%s: Invalid or incomplete min/max bounds\n", USBDEVNAME(sc->sc_dev));
			USB_ATTACH_ERROR_RETURN;
		}
	}

	/* figure out the number of buttons */
	for (i = 1; i <= MAX_BUTTONS; i++)
		if (!hid_locate(desc, size, HID_USAGE2(HUP_BUTTON, i),
				sc->sc_iid, hid_input, &loc_btn, 0))
			break;
	sc->nbuttons = i - 1;
	sc->sc_loc_btn = malloc(sizeof(struct hid_location)*sc->nbuttons);
	if (!sc->sc_loc_btn) {
		logprintf("%s: no memory\n", USBDEVNAME(sc->sc_dev));
		USB_ATTACH_ERROR_RETURN;
	}

	aprint_normal(": %d button%s%s%s%s\n",
	    sc->nbuttons, sc->nbuttons == 1 ? "" : "s",
	    sc->flags & UMS_W ? ", W" : "",
	    sc->flags & UMS_Z ? " and Z dir" : "",
	    sc->flags & UMS_W ? "s" : "");

	for (i = 1; i <= sc->nbuttons; i++)
		hid_locate(desc, size, HID_USAGE2(HUP_BUTTON, i),
			   sc->sc_iid, hid_input,
			   &sc->sc_loc_btn[i-1], 0);

	sc->sc_isize = hid_report_size(desc, size, hid_input, sc->sc_iid);

	sc->sc_isize += (nrepid != 0);
	sc->sc_ibuf = malloc(sc->sc_isize);
	if (sc->sc_ibuf == NULL) {
		logprintf("%s: no memory\n", USBDEVNAME(sc->sc_dev));
		free(sc->sc_loc_btn);
		USB_ATTACH_ERROR_RETURN;
	}

	sc->sc_ep_addr = ed->bEndpointAddress;
	if (desc != boot_descriptor) {
		free(desc);
	}
#ifdef USB_DEBUG
	DPRINTF(("ums_attach: sc=%p flags=%x\n", sc, sc->flags));
	DPRINTF(("ums_attach: X\t%d/%d\n",
		 sc->sc_loc_x.pos, sc->sc_loc_x.size));
	DPRINTF(("ums_attach: Y\t%d/%d\n",
		 sc->sc_loc_y.pos, sc->sc_loc_y.size));
	if (sc->flags & UMS_Z)
		DPRINTF(("ums_attach: Z\t%d/%d\n",
			 sc->sc_loc_z.pos, sc->sc_loc_z.size));
	if (sc->flags & UMS_W)
		DPRINTF(("ums_attach: W\t%d/%d\n",
			 sc->sc_loc_w.pos, sc->sc_loc_w.size));
	for (i = 1; i <= sc->nbuttons; i++) {
		DPRINTF(("ums_attach: B%d\t%d/%d\n",
			 i, sc->sc_loc_btn[i-1].pos,sc->sc_loc_btn[i-1].size));
	}
	DPRINTF(("ums_attach: size=%d, id=%d\n", sc->sc_isize, sc->sc_iid));
#endif

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

	USB_ATTACH_SUCCESS_RETURN;
}

struct device* attach_mouse (struct device* parent, void* aux)
{
	struct device* softc;
	struct ums_softc* sc;

	dprintf (("", "Trying match on usb mouse\n"));

	/* First see if we match */
	if (match_mouse (aux) == UMATCH_NONE)
	{
		dprintf (("", "Failed to match\n"));
		return NULL;
	}

	/* If so, allocate memory for the device and attach ourselves. */
	softc = malloc (sizeof *sc);
	if (softc == NULL) {
		dprintf (("", "Couldn't allocate memory for mouse device\n"));
		return NULL;
	}
	memset (softc, 0, sizeof *sc);
	strcpy (softc->dv_xname, "USBMouse"Module_VersionString);
	softc->dv_cfdata = (void*) 3; // mouse

	/* enable */
	sc = (struct ums_softc*) softc;

	do_attach_mouse (sc, aux);
	dprintf (("", "Matched mouse\n"));


	sc->sc_enabled = 1;
	sc->sc_buttons = 0;

	/* set idle rate to 0 */
	usbd_set_idle (sc->sc_iface, 0, 0);

	/* make sure we're using the report protocol */
	if(usbd_set_protocol(sc->sc_iface, 1)) {
		dprintf(("", "Set protocol failed\n"));
		return NULL;
	}

	int err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr,
		  USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc,
		  sc->sc_ibuf, sc->sc_isize, ums_intr, USBD_DEFAULT_INTERVAL);

	if (err) {
			dprintf(("", "ums_enable: usbd_open_pipe_intr failed, error=%d\n",
					 err));
			sc->sc_enabled = 0;
	}
	else
		_swix (OS_Pointer, _INR(0,1), 1, PointerDevice_USB);

	TAILQ_INSERT_TAIL (&allums, sc, link_ms);

	return softc;
}

int detach_mouse (struct device* ms)
{
	struct ums_softc* sc= (struct ums_softc*) ms;
	if(!sc || !sc->sc_intrpipe)
	{
	  dprintf (("", "attempt to detach a NULL mouse 'sc'\n"));
	  return 0;
	}
	dprintf (("", "detaching mouse, buttons = %x\n", sc->sc_buttons));
	usbd_abort_pipe(sc->sc_intrpipe);
	usbd_close_pipe(sc->sc_intrpipe);
	dprintf (("", "aborted pipe\n"));


	if (sc->sc_buttons & 1) {
		dprintf (("", "releaseing 1\n"));
		_swix (OS_CallAVector, _INR(0,1) | _IN(9),
			KeyV_KeyUp, KeyNo_LeftMouse, KEYV);
	}
	if (sc->sc_buttons & 2)
	{
		dprintf (("", "releaseing 2\n"));
		_swix (OS_CallAVector, _INR(0,1) | _IN(9),
		KeyV_KeyUp, KeyNo_RightMouse, KEYV);
	}
	if (sc->sc_buttons & 4)
	{
		dprintf (("", "releaseing 4\n"));
		_swix (OS_CallAVector, _INR(0,1) | _IN(9),
			KeyV_KeyUp, KeyNo_CentreMouse, KEYV);
	}

	TAILQ_REMOVE (&allums, sc, link_ms);

	free(sc->sc_loc_btn);
	free(sc->sc_ibuf);
	free (ms);
	dprintf (("", "mouse detached\n"));
	return 0;
}

int pointerv (_kernel_swi_regs* r, void* pw)
{
	_kernel_oserror* e;
	(void) pw;

	switch (r->r[0]) {
	case PointerReason_Request:
		if (r->r[1] == PointerDevice_USB) {
			/* Turn off interrupts while updating */
			int irqs = _kernel_irqs_disabled();
			if(!irqs)
				_kernel_irqs_off ();
			r->r[2] = relx;
			r->r[3] = rely;
			relx = rely = 0;
			if(!irqs)
				_kernel_irqs_on ();
			return 0; /* PRM says we should intercept */
			}
		break;

	case PointerReason_Identify:
	{
		struct pointer_device {
			struct pointer_device *next;
			uint32_t flags;
			char typenname[32];
		} *p;
		e = _swix (OS_Module, _IN(0) | _IN(3) | _OUT(2), 6,
			sizeof *p, &p);

		if (!e) {
			p->next = (struct pointer_device *) r->r[1];
			p->flags = 0;
			p->typenname[0] = PointerDevice_USB;

			_swix (MessageTrans_Lookup, _INR(0,3),
				   &mod_messages, "Mouse:USB mouse", &p->typenname[1], 31);
			r->r[1] = (int) p;
		}
		break;
	}

	case PointerReason_Selected:
		if (r->r[1] == PointerDevice_USB) {
			relx = 0;	/* ensure the pointer doesnt jump */
			rely = 0;
			relz = 0;
			relw = 0;
			dprintf (("", "USB mouse enabled\n"));
			enabled = true;
		} else {
			dprintf (("", "USB mouse disabled\n"));
			enabled = false;
		}
		break;
	}

	return 1;
}

static _kernel_oserror *zscroll_handler(_kernel_swi_regs *r, void *pw, void *h)
{
	int b[10];

	(void) r;
	(void) pw;
	(void) h;

	_swix (Wimp_GetPointerInfo, _IN(1), b);
	b[0] = b[3];
	if((relz || relw) && (b[0] != -1) && !_swix (Wimp_GetWindowState, _IN(1), b)) // valid window handle
	{
		/* does it do scroll requests? */
		if (b[8] & ((1<<8)|(1<<9)))
		{
			/* Only scroll if scrollbars are present */
			if(b[8] & (1<<31))
			{
				/* New format window flags word */
				if(!(b[8] & (1<<28)))
					relz = 0;
				if(!(b[8] & (1<<30)))
					relw = 0;
			}
			else
			{
				/* Old format window flags word */
				if(!(b[8] & (1<<2)))
					relz = 0;
				if(!(b[8] & (1<<3)))
					relw = 0;
			}
			relz*=5; // a bit more movement...
			relw*=5;
			while(relz || relw)
			{
				b[8] = (relw?(relw > 0? -1: 1):0);
				b[9] = (relz?(relz > 0? -1: 1):0);
				relw += b[8];
				relz += b[9];
				_swix (Wimp_SendMessage, _INR(0,2), 10, b, b[0]);
			}
		}
		else
		{     // give it to a wimpscroll module
#define PointerReason_WheelChange 9
			_swix (OS_CallAVector, _INR(0,3) | _IN(9),
				PointerReason_WheelChange,	// wheel change reason
				relz,				// main wheel value
				morebuttons,			// any additional buttons
				relw,				// extra wheel
				PointerV);
			relz=0;
			relw=0;
		}
	}
	return NULL;
}

void ums_intr
(
    usbd_xfer_handle	xfer,
    usbd_private_handle addr,
    usbd_status		status
)
{
	struct ums_softc *sc = addr;
	u_char *ibuf = sc->sc_ibuf;
	int dx, dy, dz, dw;
	u_int32_t buttons = 0;
	int i;
	uint8_t change;

	if (status == USBD_CANCELLED)
		return;

	if (status) {
		dprintf(("", "ums_intr: status=%d\n", status));
		usbd_clear_endpoint_stall_async(sc->sc_intrpipe);
		return;
	}

	/* only respond to our report, and skip the report number */
	if (sc->sc_iid && *ibuf++ != sc->sc_iid)
		return;

	dx =  hid_get_data(ibuf, &sc->sc_loc_x);
	if (sc->flags & UMS_ABS) {
		dy = hid_get_data(ibuf, &sc->sc_loc_y);
	} else {
		dy = -hid_get_data(ibuf, &sc->sc_loc_y);
	}
	dz =  hid_get_data(ibuf, &sc->sc_loc_z);
	dw =  hid_get_data(ibuf, &sc->sc_loc_w);

	if (sc->flags & UMS_REVZ)
		dz = -dz;
	for (i = 0; i < sc->nbuttons; i++)
		if (hid_get_data(ibuf, &sc->sc_loc_btn[i]))
			buttons |= (1 << UMS_BUT(i));

	relx += dx;
	rely += dy;
	relz += dz;
	relw += dw;

	if (enabled)
	{
		if(sc->flags & UMS_ABS)
		{
			static int oldx, oldy;
			if((dx != oldx) || (dy != oldy))
			{
				oldx = dx;
				oldy = dy;
				static const int vduin[5] = {
					VduExt_XEigFactor,
					VduExt_YEigFactor,
					VduExt_XWindLimit,
					VduExt_YWindLimit,
					-1
				};
				int vduout[5];
				_swix(OS_ReadVduVariables, _INR(0,1), vduin, vduout);
				int width = (vduout[2] + 1) << vduout[0];
				int height = (vduout[3] + 1) << vduout[1];
				dx = ((dx - sc->sc_tsscale.minx) * width) / (sc->sc_tsscale.maxx - sc->sc_tsscale.minx);
				dy = height - (((dy - sc->sc_tsscale.miny) * height) / (sc->sc_tsscale.maxy - sc->sc_tsscale.miny));
				_swix(OS_CallAVector, _INR(0,4) | _IN(9), PointerReason_Report, PointerDevice_USB, dx, dy, 0x6f736241 /* "Abso" */, PointerV);
			}
		}
		else if(dx || dy)
		{
			_swix(OS_CallAVector, _INR(0,4) | _IN(9),
				PointerReason_Report, PointerDevice_USB,
				dx, dy, 0,
				PointerV);
		}
		if (relz || relw)
		{
			morebuttons = buttons>>3;
			callx_add_callback (zscroll_handler, 0);
		}
	}


#ifdef USB_DEBUG
	if (umsdebug > 5) dprintf(("",
		"data.relx = %d, data.rely = %d, relx = %d, rely = %d, buttons = %x\n",
		dx, dy, relx, rely, buttons));
#endif
	if ((change = sc->sc_buttons ^ buttons) != 0) {
		sc->sc_buttons = buttons;
#ifdef USB_DEBUG
		if (umsdebug > 5) dprintf (("", "change = %x, enabled = %d\n", change,
			enabled));
#endif
		if (enabled) {
			if (change & 1) _swix (OS_CallAVector, _INR(0,1) | _IN(9),
				(buttons & 1)? KeyV_KeyDown: KeyV_KeyUp, KeyNo_LeftMouse, KEYV);

			if (change & 2) _swix (OS_CallAVector, _INR(0,1) | _IN(9),
				(buttons & 2)? KeyV_KeyDown: KeyV_KeyUp, KeyNo_RightMouse, KEYV);

			if (change & 4) _swix (OS_CallAVector, _INR(0,1) | _IN(9),
				(buttons & 4)? KeyV_KeyDown: KeyV_KeyUp, KeyNo_CentreMouse, KEYV);

			/* make the next button replicate menu */
			if (change & 8) _swix (OS_CallAVector, _INR(0,1) | _IN(9),
				(buttons & 8)? KeyV_KeyDown: KeyV_KeyUp, KeyNo_CentreMouse, KEYV);
		}
	}
}

int wsmousedevprint (void * v, const char * c)
{
	(void) v;
	(void) c;
	return 0;
}

int
uhidev_maxrepid(void *buf, int len)
{
	struct hid_data *d;
	struct hid_item h;
	int maxid;

	maxid = -1;
	h.report_ID = 0;
	for (d = hid_start_parse(buf, len, hid_none); hid_get_item(d, &h); )
	{
		if (h.report_ID > maxid)
			maxid = h.report_ID;
	}
	hid_end_parse(d);
	return (maxid);
}
@


1.16
log
@Revise TouchBook touchpad fix
Detail:
  build/c/usbmouse - Because the touchpad sends data that's consistent with a Boot protocol mouse, the data it sends is shorter than the expected size. This can result in bogus scroll wheel data being read from off the end of the buffer. Fix this by completely ignoring the report descriptor that the device returns and instead using a descriptor that's consistent with a Boot protocol mouse.
  build/Version - Increase USBDriver version number
Admin:
  Tested on TouchBook
  Fixes issue seen where garbage data at the end of the buffer would result in windows scrolling for every mouse interrupt


Version 1.16. Tagged as 'NetBSD-1_16'
@
text
@a666 1
#define RECORD "\x0\x0\x0\x0\x0\x0\x0\x0\x7USB Mouse"
@


1.15
log
@Handle absolute pointing devices in a more sensible manner
Detail:
  build/c/usbmouse - For absolute pointing devices, use the PointerV_Report "Abso" call to report absolute positions instead of relative
  build/Version - Bump USBDriver version number
Admin:
  Based on code supplied by Chris Mahoney; allows USB touchscreens such as the Adafruit AR1100 to work under RISC OS
  Tested locally in an Iyonix ROM build (with regular mouse)


Version 0.94. Tagged as 'NetBSD-0_94'
@
text
@a145 1
#define UMS_NO_REPID	0x20	/* broken device that doesn't prefix the report ID */
d223 31
d309 21
a329 3
	err = usbd_read_report_desc(uaa->iface, &desc, &size, M_USBDEV);
	if (err)
		USB_ATTACH_ERROR_RETURN;
d517 3
a519 15
	free(desc);

	/*
	 * Deal with the broken behaviour of the touchpad of the TouchBook
	 * keyboard. Despite sending out a report descriptor containing
	 * multiple report IDs, the device fails to prepend the report ID to
	 * the reports it sends out for touchpad events. Furthermore the device
	 * refuses to switch to the Boot report protocol, for which the data it
	 * sends would actually be valid. So just flag that it's broken and
	 * that we shouldn't bother looking for a report ID.
	 */
	if((uaa->vendor == USB_VENDOR_ALWAYSINNOVATING) &&
	   (uaa->product == USB_PRODUCT_ALWAYSINNOVATING_USBKBDTPAD))
		sc->flags |= UMS_NO_REPID;

d791 1
a791 1
	if (sc->sc_iid && !(sc->flags & UMS_NO_REPID) && *ibuf++ != sc->sc_iid)
@


1.14
log
@Add some more usbdevs from the NetBSD sources.
In particular, the SMSC ethernet controller and hub on the Beagleboard
xm.
Changed pointer assignments & comparisons with 0 to be NULL for clarity.
Implement a left trim function for any printed out strings obtained from
the device (to mirror usbd_trim_spaces) so that when dopey manufacturers
use a space instead of their company name everything lines up still.

Version 0.68. Tagged as 'NetBSD-0_68'
@
text
@d54 1
d119 5
d136 1
d407 28
d742 1
a742 1
	int i, flags;
a744 2
	flags = WSMOUSE_INPUT_DELTA;	/* equals 0 */

a759 1
		flags |= (WSMOUSE_INPUT_ABSOLUTE_X | WSMOUSE_INPUT_ABSOLUTE_Y);
d761 1
a761 1
	} else
d763 1
d780 24
a803 1
		if(dx || dy)
d805 1
a805 1
			_swix(OS_CallAVector, _INR(0,3) | _IN(9),
d807 1
a807 1
				dx, dy,
@


1.13
log
@Improve scrollwheel handling
Detail:
  build/c/usbmouse - Scrollwheel code now only sends scroll requests in a given direction if the window has an appropriate scroll bar.
  build/Version - Incremented USBDriver version number
Admin:
  Tested in OMAP3 ROM
  Fixes issue reported on forums where it was possible to scroll filer windows horizontally if you used a mouse with a 'w' axis


Version 0.64. Tagged as 'NetBSD-0_64'
@
text
@d490 1
a490 1
	if (softc == 0) {
@


1.12
log
@Add the ability to build the USB drivers as HAL-compatible static libraries
Detail:
  build/Makefile, build/OBJEHCIDriver, build/OBJOHCIDriver, build/OBJUSBDriver - Modified makefiles to build the HAL libs during the export libs phase
  build/!MkHAL,fd7 - Handy script for building the HAL libs
  build/Hdr/usbhal - Header containing definitions for the assembler code. Also gets exported so that HALs know how much workspace to reserve.
  build/c/usbhal - HAL version of usbmodule.c & port.c. Also contains the keyboard scan code, adapted from the code in the Tungsten HAL.
  build/s/porthal - Assembler versions of some port.c routines that were easier to do in assembler than C
  build/s/halheap - OS_Heap code that's been adapted for use in the HAL. Could easily be changed into a standalone library instead of being part of the HAL USB libs. Supports memory-efficient allocation of aligned blocks.
  build/c/ehcihal - HAL version of ehcimodule.c. Currently only supports EHCI controllers exposed via HAL_USBControllerInfo (i.e. no PCI support)
  build/c/ehcimodule, build/c/ohcimodule, build/c/port - Moved riscos_irq_clear into port.c. Removed unused microtime() function.
  build/c/usbmouse - Strip out some debug-related code in non-debug builds
  build/Version - Updated version numbers
  dev/usb/c/ehci, dev/usb/h/ehcivar - Adapted to add support for the HAL build. Apart from the base changes, the code has also been tweaked to significantly reduce the amount of memory used at runtime by the HAL version of the driver.
  dev/usb/c/hid, dev/usb/c/uhub, dev/usb/c/usb, dev/usb/c/usb_quirks, dev/usb/c/usb_subr, dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/c/usbroothub_subr - Changes to support HAL builds. Mainly disabling bits that won't work in the HAL or disabling bits for RISC OS in general if they weren't being used in the first place.
  dev/usb/c/ohci, dev/usb/h/ohcivar - Basic changes to support HAL builds. However HAL OHCI support is still incomplete.
  dev/usb/h/usb_port - Added support for the HAL build. Also tweaked logprintf definition to get rid of logprintf calls entirely in non-debug builds.
  dev/usb/h/usbdivar - Added support for the HAL build.
  dev/usb/h/usbhal - New header used by the HAL build. Gets included by every C file to ensure the compiler doesn't use sb, and contains structs/macros to allow access to the shared workspace.
Admin:
  HAL & non-HAL builds tested on rev C2 BB, rev A2 BB-xM, rev C1 TouchBook.
  Non-HAL builds tested with Iyonix ROM softload.
  Needs latest Kernel source for OSEntries.h export.


Version 0.59. Tagged as 'NetBSD-0_59'
@
text
@d639 1
a639 1
	int b[64];
d647 1
a647 1
	if((relz || relw) && !_swix (Wimp_GetWindowState, _IN(1), b)) // valid window handle
d652 17
@


1.11
log
@Update hid.c, ums.c to latest (ish), update usbmouse.c, add TouchBook touchpad fix
Detail:
  dev/usb/c/hid, dev/usb/h/hid, dev/usb/c/ums - Updated to latest NetBSD versions (actually the version that was used for the recent core/EHCI update, so not 100% latest)
  build/c/usbmouse, dev/wscons/h/wsmousevar - Updated RISC OS USB mouse driver to be similar to the new NetBSD version. Also reformatted file to use tab char instead of inconsistent numbers of spaces for indentation.
  build/c/usbmouse, dev/usb/usbdevs - Added fix for broken TouchBook touchpad behaviour.
Admin:
  Tested with various mice on a beagleboard, and with the TouchBook touchpad.
  We should now have support for the W axis of mice, but that code is untested since I don't have any suitable mice to hand.


Version 0.53. Tagged as 'NetBSD-0_53'
@
text
@d225 1
d227 1
d237 1
d242 1
@


1.10
log
@Fix USBDriver's handling of PointerV. Increase module version numbers/dates.
Detail:
  build/c/usbmouse - USBDriver's PointerReason_Request handler now correctly restores the IRQ state to that of the caller, instead of unconditionally enabling IRQs. It also correctly intercepts the vector instead of passing it on to other claimants.
  build/Version - This fake VersionNum file hasn't been touched in a long time, leading to some newer versions of the USB modules being released with version numbers identical to their predecessors. This has now been fixed, so that each module has had its version increased by 0.01 and date increased to that of the last (functional) change.
Admin:
  Tested on rev C2 beagleboard


Version 0.50. Tagged as 'NetBSD-0_50'
@
text
@d15 31
d73 3
d80 22
a104 2
extern int umsdebug = 0;

d109 1
a109 1
static int relx = 0, rely = 0, relz = 0, morebuttons = 0;
a111 3
#define MOUSE_FLAGS_MASK (HIO_CONST|HIO_RELATIVE)
#define MOUSE_FLAGS (HIO_RELATIVE)

d116 2
d119 21
a139 21
        USBBASEDEVICE sc_dev;           /* base device */
        usbd_device_handle sc_udev;
        usbd_interface_handle sc_iface; /* interface */
        usbd_pipe_handle sc_intrpipe;   /* interrupt pipe */
        int sc_ep_addr;

        u_char *sc_ibuf;
        u_int8_t sc_iid;
        int sc_isize;
        struct hid_location sc_loc_x, sc_loc_y, sc_loc_z;
        struct hid_location *sc_loc_btn;

        int sc_enabled;

        int flags;              /* device configuration */
#define UMS_Z           0x01    /* z direction available */
#define UMS_SPUR_BUT_UP 0x02    /* spurious button up events */
#define UMS_REVZ        0x04    /* Z-axis is reversed */

        int nbuttons;
#define MAX_BUTTONS     31      /* chosen because sc_buttons is u_int32_t */
d141 1
a141 1
        u_int32_t sc_buttons;   /* mouse button status */
d143 1
a143 1
        char                    sc_dying;
d145 4
a148 2
        /* list of ukbd softcs */
        TAILQ_ENTRY(ums_softc) link_ms;
d151 2
d157 5
a161 5
    struct ums_softc* sc;
    TAILQ_FOREACH(sc, &allums, link_ms)
    {
        detach_mouse ((struct device*) sc);
    }
d166 49
a214 39
        usb_interface_descriptor_t *id;
        int size, ret, nrepid, repid;
        void *desc;
        usbd_status err;

        dprintf (("", "Trying ums attach\n"));
        if (uaa->iface == NULL)
                return (UMATCH_NONE);
        id = usbd_get_interface_descriptor(uaa->iface);
        if (id == NULL || id->bInterfaceClass != UICLASS_HID)
        {
                dprintf (("", "failed class match: id == %p\n", id));
                return (UMATCH_NONE);
        }

        err = usbd_read_report_desc(uaa->iface, &desc, &size, M_USBDEV);
        if (err)
        {
                dprintf (("", "failed to get report\n"));
                return (UMATCH_NONE);
        }

        nrepid = uhidev_maxrepid(desc, size);
        

        ret = UMATCH_NONE;
        for (repid = 0; repid <= nrepid; repid++)
        {
            if (hid_is_collection(desc, size, repid,
                              HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_MOUSE)))
            {
                ret = UMATCH_IFACECLASS;
            }
        }


        free(desc);
        dprintf (("", "ums attach returning: %d\n", ret));
        return (ret);
d219 225
a443 132
        usbd_interface_handle iface = uaa->iface;
        usb_interface_descriptor_t *id;
        usb_endpoint_descriptor_t *ed;
        int size;
        void *desc;
        usbd_status err;
        char devinfo[1024];
        u_int32_t flags, quirks;
        int i, wheel, repid, nrepid;
        struct hid_location loc_btn;

        sc->sc_udev = uaa->device;
        sc->sc_iface = iface;
        id = usbd_get_interface_descriptor(iface);
        usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
        USB_ATTACH_SETUP;
        dprintf(("%s: %s, iclass %d/%d\n", USBDEVNAME(sc->sc_dev),
               devinfo, id->bInterfaceClass, id->bInterfaceSubClass));
        ed = usbd_interface2endpoint_descriptor(iface, 0);
        if (ed == NULL) {
                logprintf("%s: could not read endpoint descriptor\n",
                       USBDEVNAME(sc->sc_dev));
                USB_ATTACH_ERROR_RETURN;
        }

        dprintf(("", "ums_attach: bLength=%d bDescriptorType=%d "
                     "bEndpointAddress=%d-%s bmAttributes=%d wMaxPacketSize=%d"
                     " bInterval=%d\n",
                     ed->bLength, ed->bDescriptorType,
                     ed->bEndpointAddress & UE_ADDR,
                     UE_GET_DIR(ed->bEndpointAddress)==UE_DIR_IN? "in" : "out",
                     ed->bmAttributes & UE_XFERTYPE,
                     UGETW(ed->wMaxPacketSize), ed->bInterval));

        if (UE_GET_DIR(ed->bEndpointAddress) != UE_DIR_IN ||
            (ed->bmAttributes & UE_XFERTYPE) != UE_INTERRUPT) {
                logprintf("%s: unexpected endpoint\n",
                       USBDEVNAME(sc->sc_dev));
                USB_ATTACH_ERROR_RETURN;
        }

        quirks = usbd_get_quirks(uaa->device)->uq_flags;
        if (quirks & UQ_MS_REVZ)
                sc->flags |= UMS_REVZ;
        if (quirks & UQ_SPUR_BUT_UP)
                sc->flags |= UMS_SPUR_BUT_UP;

        err = usbd_read_report_desc(uaa->iface, &desc, &size, M_USBDEV);
        if (err)
                USB_ATTACH_ERROR_RETURN;

        nrepid = uhidev_maxrepid(desc, size);
        
        for (repid = 0; repid <= nrepid; repid++)
        {
            if (hid_is_collection(desc, size, repid,
                              HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_MOUSE)))
            {
              sc->sc_iid = repid;
            }
        }

        if (!hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_X),
                       sc->sc_iid, hid_input, &sc->sc_loc_x, &flags)) {
                logprintf("%s: mouse has no X report\n", USBDEVNAME(sc->sc_dev));
                USB_ATTACH_ERROR_RETURN;
        }
        if ((flags & MOUSE_FLAGS_MASK) != MOUSE_FLAGS) {
                logprintf("%s: X report 0x%04x not supported\n",
                       USBDEVNAME(sc->sc_dev), flags);
                USB_ATTACH_ERROR_RETURN;
        }

        if (!hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_Y),
                       sc->sc_iid, hid_input, &sc->sc_loc_y, &flags)) {
                logprintf("%s: mouse has no Y report\n", USBDEVNAME(sc->sc_dev));
                USB_ATTACH_ERROR_RETURN;
        }
        if ((flags & MOUSE_FLAGS_MASK) != MOUSE_FLAGS) {
                logprintf("%s: Y report 0x%04x not supported\n",
                       USBDEVNAME(sc->sc_dev), flags);
                USB_ATTACH_ERROR_RETURN;
        }

        /* Try to guess the Z activator: first check Z, then WHEEL. */
        wheel = 0;
        if (hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_Z),
                       sc->sc_iid, hid_input, &sc->sc_loc_z, &flags) ||
            (wheel = hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP,
                                                       HUG_WHEEL),
                       sc->sc_iid, hid_input, &sc->sc_loc_z, &flags)) != 0) {
                if ((flags & MOUSE_FLAGS_MASK) != MOUSE_FLAGS) {
                        sc->sc_loc_z.size = 0;  /* Bad Z coord, ignore it */
                } else {
                        sc->flags |= UMS_Z;
                        /* Wheels need the Z axis reversed. */
                        if (wheel)
                                sc->flags ^= UMS_REVZ;
                }
        }

        /* figure out the number of buttons */
        for (i = 1; i <= MAX_BUTTONS; i++)
                if (!hid_locate(desc, size, HID_USAGE2(HUP_BUTTON, i),
                                sc->sc_iid, hid_input, &loc_btn, 0))
                        break;
        sc->nbuttons = i - 1;
        sc->sc_loc_btn = malloc(sizeof(struct hid_location)*sc->nbuttons);
        if (!sc->sc_loc_btn) {
                logprintf("%s: no memory\n", USBDEVNAME(sc->sc_dev));
                USB_ATTACH_ERROR_RETURN;
        }

        dprintf(("", "%s: %d buttons%s\n", USBDEVNAME(sc->sc_dev),
               sc->nbuttons, sc->flags & UMS_Z ? " and Z dir." : ""));

        for (i = 1; i <= sc->nbuttons; i++)
                hid_locate(desc, size, HID_USAGE2(HUP_BUTTON, i),
                                sc->sc_iid, hid_input, &sc->sc_loc_btn[i-1], 0);

        sc->sc_isize = hid_report_size(desc, size, hid_input, sc->sc_iid);

        sc->sc_isize += (nrepid != 0);
        sc->sc_ibuf = malloc(sc->sc_isize);
        if (sc->sc_ibuf == NULL) {
                logprintf("%s: no memory\n", USBDEVNAME(sc->sc_dev));
                free(sc->sc_loc_btn);
                USB_ATTACH_ERROR_RETURN;
        }

        sc->sc_ep_addr = ed->bEndpointAddress;
        free(desc);
d446 16
a461 13
        dprintf(("", "ums_attach: sc=%p\n", sc));
        dprintf(("", "ums_attach: X\t%d/%d\n",
                 sc->sc_loc_x.pos, sc->sc_loc_x.size));
        dprintf(("", "ums_attach: Y\t%d/%d\n",
                 sc->sc_loc_x.pos, sc->sc_loc_x.size));
        if (sc->flags & UMS_Z)
                dprintf(("", "ums_attach: Z\t%d/%d\n",
                         sc->sc_loc_z.pos, sc->sc_loc_z.size));
        for (i = 1; i <= sc->nbuttons; i++) {
                dprintf(("", "ums_attach: B%d\t%d/%d\n",
                         i, sc->sc_loc_btn[i-1].pos,sc->sc_loc_btn[i-1].size));
        }
        dprintf(("", "ums_attach: size=%d, id=%d\n", sc->sc_isize, sc->sc_iid));
d464 2
a465 2
        usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
                           USBDEV(sc->sc_dev));
d467 1
a467 1
        USB_ATTACH_SUCCESS_RETURN;
d472 2
a473 28
    struct device* softc;
    struct ums_softc* sc;

    dprintf (("", "Trying match on usb mouse\n"));

    /* First see if we match */
    if (match_mouse (aux) == UMATCH_NONE)
    {
        dprintf (("", "Failed to match\n"));
        return NULL;
    }

    /* If so, allocate memory for the device and attach ourselves. */
    softc = malloc (sizeof *sc);
    if (softc == 0) {
        dprintf (("", "Couldn't allocate memory for mouse device\n"));
        return NULL;
    }
    memset (softc, 0, sizeof *sc);
    strcpy (softc->dv_xname, "USBMouse"Module_VersionString);
    softc->dv_cfdata = (void*) 3; // mouse

    /* enable */
    sc = (struct ums_softc*) softc;

    do_attach_mouse (sc, aux);
    dprintf (("", "Matched mouse\n"));

d475 1
a475 2
    sc->sc_enabled = 1;
    sc->sc_buttons = 0;
d477 47
a523 2
    /* set idle rate to 0 */
    usbd_set_idle (sc->sc_iface, 0, 0);
d525 1
a525 2
    /* make sure we're using the report protocol */
    usbd_set_protocol(sc->sc_iface, 1);
d527 1
a527 17


    int err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr,
          USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc,
          sc->sc_ibuf, sc->sc_isize, ums_intr, USBD_DEFAULT_INTERVAL);

    if (err) {
            dprintf(("", "ums_enable: usbd_open_pipe_intr failed, error=%d\n",
                     err));
            sc->sc_enabled = 0;
    }
    else
        _swix (OS_Pointer, _INR(0,1), 1, PointerDevice_USB);

    TAILQ_INSERT_TAIL (&allums, sc, link_ms);

    return softc;
d532 37
a568 37
    struct ums_softc* sc= (struct ums_softc*) ms;
    if(!sc || !sc->sc_intrpipe)
    {
      dprintf (("", "attempt to detach a NULL mouse 'sc'\n"));
      return 0;
    }
    dprintf (("", "detaching mouse, buttons = %x\n", sc->sc_buttons));
    usbd_abort_pipe(sc->sc_intrpipe);
    usbd_close_pipe(sc->sc_intrpipe);
    dprintf (("", "aborted pipe\n"));


    if (sc->sc_buttons & 1) {
        dprintf (("", "releaseing 1\n"));
        _swix (OS_CallAVector, _INR(0,1) | _IN(9),
            KeyV_KeyUp, KeyNo_LeftMouse, KEYV);
    }
    if (sc->sc_buttons & 2)
    {
        dprintf (("", "releaseing 2\n"));
        _swix (OS_CallAVector, _INR(0,1) | _IN(9),
        KeyV_KeyUp, KeyNo_RightMouse, KEYV);
    }
    if (sc->sc_buttons & 4)
    {
        dprintf (("", "releaseing 4\n"));
        _swix (OS_CallAVector, _INR(0,1) | _IN(9),
            KeyV_KeyUp, KeyNo_CentreMouse, KEYV);
    }

    TAILQ_REMOVE (&allums, sc, link_ms);

    free(sc->sc_loc_btn);
    free(sc->sc_ibuf);
    free (ms);
    dprintf (("", "mouse detached\n"));
    return 0;
d573 2
a574 2
    _kernel_oserror* e;
    (void) pw;
d576 15
a590 15
    switch (r->r[0]) {
    case PointerReason_Request:
        if (r->r[1] == PointerDevice_USB) {
            /* Turn off interrupts while updating */
            int irqs = _kernel_irqs_disabled();
            if(!irqs)
              _kernel_irqs_off ();
            r->r[2] = relx;
            r->r[3] = rely;
            relx = rely = 0;
            if(!irqs)
              _kernel_irqs_on ();
            return 0; /* PRM says we should intercept */             
            }
        break;
d593 36
a628 35
    case PointerReason_Identify:
    {
        struct pointer_device {
            struct pointer_device *next;
            uint32_t               flags;
            char                   typenname[32];
        } *p;
        e = _swix (OS_Module, _IN(0) | _IN(3) | _OUT(2), 6,
            sizeof *p, &p);

        if (!e) {
            p->next = (struct pointer_device *) r->r[1];
            p->flags = 0;
            p->typenname[0] = PointerDevice_USB;

            _swix (MessageTrans_Lookup, _INR(0,3),
                   &mod_messages, "Mouse:USB mouse", &p->typenname[1], 31);
            r->r[1] = (int) p;
        }
        break;
    }

    case PointerReason_Selected:
        if (r->r[1] == PointerDevice_USB) {
            relx = 0;    /* ensure the pointer doesnt jump */
            rely = 0;
            relz = 0;
            dprintf (("", "USB mouse enabled\n"));
            enabled = true;
        } else {
            dprintf (("", "USB mouse disabled\n"));
            enabled = false;
        }
        break;
    }
d630 1
a630 1
    return 1;
d633 1
a633 6
static _kernel_oserror *zscroll_handler
(
    _kernel_swi_regs *  r,
    void *              pw,
    void *              h
)
d635 1
a635 1
    int b[64];
d637 24
a660 22
    (void) r;
    (void) pw;
    (void) h;

    _swix (Wimp_GetPointerInfo, _IN(1), b);
    b[0] = b[3];
    if(relz && !_swix (Wimp_GetWindowState, _IN(1), b)) // valid window handle
    {
      /* does it do scroll requests? */
      if (b[8] & ((1<<8)|(1<<9)))
      {
          b[8] = 0;
          b[9] = relz > 0? -1: 1;
          relz*=5; // a bit more movement...
          while (relz != 0)
          {
              relz += relz > 0? -1: 1;
              _swix (Wimp_SendMessage, _INR(0,2), 10, b, b[0]);
          }
      }
      else
      {     // give it to a wimpscroll module
d662 11
a672 10
         _swix (OS_CallAVector, _INR(0,3) | _IN(9),
                 PointerReason_WheelChange,    // wheel change reason
                 relz,                         // main wheel value
                 morebuttons,                  // any additional buttons
                 0,                            // extra wheel (not supp yet)
                 PointerV);
         relz=0;
      }
    }
    return NULL;
d677 1
a677 1
    usbd_xfer_handle    xfer,
d679 1
a679 1
    usbd_status         status
d682 57
a738 42
    struct ums_softc *sc = addr;
    u_char *ibuf = sc->sc_ibuf;
    int dx, dy, dz, i, b = 0;
    uint8_t change;

    if (status == USBD_CANCELLED)
        return;

    if (status) {
        dprintf(("", "ums_intr: status=%d\n", status));
        usbd_clear_endpoint_stall_async(sc->sc_intrpipe);
        return;
    }

    /* only respond to our report, and skip the report number */
    if (sc->sc_iid && *ibuf++ != sc->sc_iid)
      return;

    dx =  (u_int) hid_get_data(ibuf, &sc->sc_loc_x);
    dy = -(u_int) hid_get_data(ibuf, &sc->sc_loc_y);
    dz =  (u_int) hid_get_data(ibuf, &sc->sc_loc_z);
    if (sc->flags & UMS_REVZ)
        dz = -dz;
    relx += dx;
    rely += dy;
    relz += dz; 
    for (i = 0; i < sc->nbuttons; i++)
        if (hid_get_data(ibuf, &sc->sc_loc_btn[i]))
            b |= (1 << i);
            
    if (enabled)
    {
        _swix(OS_CallAVector, _INR(0,3) | _IN(9),
                          PointerReason_Report, PointerDevice_USB,
                          dx, dy,
                          PointerV);
        if (relz != 0)
        {
            morebuttons = b>>3;
            callx_add_callback (zscroll_handler, 0);
        }
    }
d742 3
a744 3
    if (umsdebug > 5) dprintf(("",
    "data.relx = %d, data.rely = %d, relx = %d, rely = %d, buttons = %x\n",
        dx, dy, relx, rely, b));
d746 2
a747 2
    if ((change = sc->sc_buttons ^ b) != 0) {
        sc->sc_buttons = b;
d749 2
a750 2
        if (umsdebug > 5) dprintf (("", "change = %x, enabled = %d\n", change,
            enabled));
d752 15
a766 15
        if (enabled) {
            if (change & 1) _swix (OS_CallAVector, _INR(0,1) | _IN(9),
                (b & 1)? KeyV_KeyDown: KeyV_KeyUp, KeyNo_LeftMouse, KEYV);

            if (change & 2) _swix (OS_CallAVector, _INR(0,1) | _IN(9),
                (b & 2)? KeyV_KeyDown: KeyV_KeyUp, KeyNo_RightMouse, KEYV);

            if (change & 4) _swix (OS_CallAVector, _INR(0,1) | _IN(9),
                (b & 4)? KeyV_KeyDown: KeyV_KeyUp, KeyNo_CentreMouse, KEYV);

            /* make the next button replicate menu */
            if (change & 8) _swix (OS_CallAVector, _INR(0,1) | _IN(9),
                (b & 8)? KeyV_KeyDown: KeyV_KeyUp, KeyNo_CentreMouse, KEYV);
        }
    }
d771 3
a773 3
    (void) v;
    (void) c;
    return 0;
d786 1
d789 1
@


1.9
log
@        Update of EHCIDriver to current NetBSD, together with needed changes
        in both OHCIDriver and USBDriver.


Detail:
        Code may change before formal release .. will be beta released
        ... Entered to CVS to get new version numbers, and for
        the record.
Admin:
        Castle/netbsd added IP .. will be tested more fully before
        formal release. Still to be verified on Rhenium.


Version 0.31. Tagged as 'NetBSD-0_31'
@
text
@d416 3
a418 1
            _kernel_irqs_off ();
d422 3
a424 1
            _kernel_irqs_on ();
@


1.8
log
@  Extensive changes and bug fixes to usb and ohci ..
  'blocked' several holes that could cause freezes with awkward
  usb devices.  Added latest changes from Dan Ellis too , especially for USB2
Detail:
 many
Admin:
 Tested in ROM at Castle, and beta tested with users


Version 0.28. Tagged as 'NetBSD-0_28'
@
text
@d533 3
a535 3
    dx = (u_long) hid_get_data(ibuf, &sc->sc_loc_x);
    dy = -(u_long) hid_get_data(ibuf, &sc->sc_loc_y);
    dz = (u_long) hid_get_data(ibuf, &sc->sc_loc_z);
@


1.7
log
@Latest stuff from John - mainly Rhenium improvements.

Version 0.26. Tagged as 'NetBSD-0_26'
@
text
@d166 1
a166 1
        usbd_devinfo(uaa->device, 0, devinfo);
d242 1
a242 1
                       sc->sc_iid, hid_input, &sc->sc_loc_z, &flags))) {
d449 3
d533 3
a535 3
    dx = hid_get_data(ibuf, &sc->sc_loc_x);
    dy = -hid_get_data(ibuf, &sc->sc_loc_y);
    dz =  hid_get_data(ibuf, &sc->sc_loc_z);
@


1.6
log
@  New versions from John.
Detail:
  * All modules will now rmkill/rmload more reliably
  * Keyboard driver disables kernel debounce on new enough kernels, needed
    for many PS2-USB adaptors, bar code scanners etc
  * Mouse driver will scroll wheel scroll any windows that do respond to
    scroll events, otherwise it issues PointerReason_WheelChange (9) to an
    external WimpScroll module
  * Several bugs and an interrupt hole resolved
Admin:
  Tested at Framlingham.

Version 0.25. Tagged as 'NetBSD-0_25'
@
text
@d132 1
d204 1
d273 2
d344 5
d369 5
@


1.5
log
@Fixes from John Ballance:

Version 0.23. Tagged as 'NetBSD-0_23'
@
text
@d55 1
a55 1
static int relx = 0, rely = 0, relz = 0;
d63 2
d110 1
a110 1
        int size, ret;
d131 6
a136 1
        if (hid_is_collection(desc, size, 0,
d138 1
d140 3
a142 2
        else
                ret = UMATCH_NONE;
d159 1
a159 1
        int i, wheel;
d202 10
d213 1
a213 1
                       0, hid_input, &sc->sc_loc_x, &flags)) {
d224 1
a224 1
                       0, hid_input, &sc->sc_loc_y, &flags)) {
d237 1
a237 1
                       0, hid_input, &sc->sc_loc_z, &flags) ||
d240 1
a240 1
                       0, hid_input, &sc->sc_loc_z, &flags))) {
d254 1
a254 1
                                0, hid_input, &loc_btn, 0))
d268 1
a268 1
                                0, hid_input, &sc->sc_loc_btn[i-1], 0);
d270 1
a270 1
        sc->sc_isize = hid_report_size(desc, size, hid_input, 0);
d360 1
a360 1
    int rv;
d363 1
a364 1
    dprintf (("", "detaching mouse, buttons = %x", sc->sc_buttons));
d386 2
a387 4
    if (rv == 0) {
        free(sc->sc_loc_btn);
        free(sc->sc_ibuf);
    }
d389 1
d454 2
d460 3
a462 1
    while (relz != 0)
d464 23
a486 8
        int b[64];
        _swix (Wimp_GetPointerInfo, _IN(1), b);
        b[0] = b[3];
        _swix (Wimp_GetWindowState, _IN(1), b);
        b[8] = 0;
        b[9] = relz > 0? -1: 1;
        relz += relz > 0? -1: 1;
        _swix (Wimp_SendMessage, _INR(0,2), 10, b, b[0]);
a487 1

d512 4
d523 5
a527 1
    relz += 5 * dz; /* 5 makes things move a bit faster */
d536 1
a540 3
    for (i = 0; i < sc->nbuttons; i++)
        if (hid_get_data(ibuf, &sc->sc_loc_btn[i]))
            b |= (1 << i);
d562 4
d575 16
@


1.4
log
@Merge of Dan Ellis's USB2 sources.

Version 0.22. Tagged as 'NetBSD-0_22'
@
text
@d49 1
a49 1
extern int umsdebug;
a86 1
        struct device *sc_wsmousedev;
a366 3
    /* No need to do reference counting of ums, wsmouse has all the goo. */
    if (sc->sc_wsmousedev != NULL)
        rv = config_detach(sc->sc_wsmousedev, 1);
d503 1
a503 1
        x, y, relx, rely, b));
@


1.3
log
@Fix for erratic behaviour after having unplugged hubs: TAILQ was
being given an entry which wasn't on its list, and the behaviour was to
break the list and poke a zero into the reset vector!
Also, some extra IFDEF's so that debug builds will work again.
A few typos/spelling errors changed.

Version 0.11. Tagged as 'NetBSD-0_11'
@
text
@d27 1
d33 2
d38 5
a42 1
#include "dev/usb/usbhid.h"
d55 1
a55 2
static int relx = 0, rely = 0;
static uint8_t buttons;
d58 227
d288 1
d293 1
a293 1
    if ((*ums_ca.ca_match) (0, 0, aux) == UMATCH_NONE)
d300 1
a300 1
    softc = malloc (ums_ca.ca_devsize);
d305 1
a305 1
    memset (softc, 0, ums_ca.ca_devsize);
d309 4
a312 1
    (*ums_ca.ca_attach) (parent, softc, aux);
d315 21
a335 2
    ums_enable (softc);
    _swix (OS_Pointer, _INR(0,1), 1, PointerDevice_USB);
d341 34
a374 2
    ums_disable (ms);
    (*ums_ca.ca_detach) (ms, 0);
d396 1
d433 6
a438 1
void wsmouse_input (struct device* dev, uint32_t b, int x, int y, int z, uint32_t flags)
d440 29
d470 18
a487 2
    relx += x;
    rely -= y;
d492 1
a492 1
                          x, y,
d494 9
a503 1
    }
d509 2
a510 2
    if ((change = buttons ^ b) != 0) {
        buttons = b;
d517 1
a517 1
                1 + ((buttons & 1) == 1), KeyNo_LeftMouse, KEYV);
d520 1
a520 1
                1 + ((buttons & 2) == 2), KeyNo_RightMouse, KEYV);
d523 1
a523 5
                1 + ((buttons & 4) == 4), KeyNo_CentreMouse, KEYV);

            /* make the next button replicate menu */
            if (change & 8) _swix (OS_CallAVector, _INR(0,1) | _IN(9),
                1 + ((buttons & 8) == 8), KeyNo_CentreMouse, KEYV);
@


1.2
log
@Found a "busses" lingering in the messages file,also removed a \n which
must have been copied from a printf somewhere.
Old service call detail removed from c.port as it's defined in another
file differently!
USBDiscover is now only available for debugging purposes.
Internationalised the mouse name (default is still "USB mouse").

Version 0.08. Tagged as 'NetBSD-0_08'
@
text
@d157 1
d161 1
d164 1
d167 1
@


1.1
log
@Import of USB driver suitable for generic PCI based OHCI controllers.
Correction of spelling of busses to buses (noun plural).
OHCIdriver only responds to PCI service call to lookup vendor name when
the device is of class OHCI controller.

Version 0.01. Tagged as 'NetBSD-0_01'
@
text
@d44 2
d122 3
a124 1
            strcpy(&p->typenname[1], "USB mouse"); /* should be internationalised */
@


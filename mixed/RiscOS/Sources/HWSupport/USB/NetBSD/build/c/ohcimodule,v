head	1.29;
access;
symbols
	NetBSD-1_19:1.29
	NetBSD-1_18:1.29
	NetBSD-1_17:1.28
	NetBSD-1_16:1.27
	NetBSD-1_15:1.27
	NetBSD-1_14:1.27
	NetBSD-1_13:1.27
	NetBSD-1_12:1.27
	NetBSD-1_09-1:1.27
	NetBSD-1_11:1.27
	NetBSD-1_10:1.27
	NetBSD-1_09:1.27
	NetBSD-1_08:1.26
	NetBSD-1_07:1.26
	NetBSD-1_06:1.26
	NetBSD-1_05:1.26
	NetBSD-1_04:1.26
	NetBSD-1_03:1.26
	NetBSD-1_02:1.26
	NetBSD-1_01:1.26
	NetBSD-1_00:1.26
	NetBSD-0_99:1.26
	NetBSD-0_98:1.26
	NetBSD-0_97:1.25
	NetBSD-0_96:1.25
	NetBSD-0_95:1.25
	NetBSD-0_94:1.24
	NetBSD-0_93:1.24
	NetBSD-0_92:1.23
	NetBSD-0_91:1.22
	NetBSD-0_90:1.22
	NetBSD-0_89:1.22
	NetBSD-0_88:1.21
	NetBSD-0_87:1.20
	NetBSD-0_86:1.20
	NetBSD-0_85:1.20
	NetBSD-0_84:1.19
	NetBSD-0_83:1.19
	NetBSD-0_82:1.19
	NetBSD-0_81:1.19
	NetBSD-0_80:1.19
	NetBSD-0_79:1.19
	NetBSD-0_78:1.19
	NetBSD-0_77:1.19
	NetBSD-0_76:1.18
	NetBSD-0_75:1.18
	NetBSD-0_74:1.18
	NetBSD-0_73:1.18
	NetBSD-0_72:1.18
	NetBSD-0_71:1.17
	NetBSD-0_70:1.16
	NetBSD-0_69:1.16
	NetBSD-0_68:1.16
	NetBSD-0_67:1.16
	NetBSD-0_66:1.16
	NetBSD-0_65:1.16
	NetBSD-0_64:1.16
	NetBSD-0_63:1.16
	NetBSD-0_62:1.16
	NetBSD-0_61:1.16
	NetBSD-0_60:1.15
	NetBSD-0_59:1.15
	NetBSD-0_58:1.14
	NetBSD-0_57:1.14
	NetBSD-0_56:1.14
	NetBSD-0_55:1.14
	NetBSD-0_54:1.14
	NetBSD-0_53:1.14
	NetBSD-0_52:1.14
	NetBSD-0_51:1.13
	NetBSD-0_50:1.13
	NetBSD-0_49:1.13
	NetBSD-0_48:1.13
	NetBSD-0_47:1.12
	NetBSD-0_46:1.11
	NetBSD-0_45:1.11
	NetBSD-0_44:1.11
	NetBSD-0_43:1.11
	NetBSD-0_42:1.11
	NetBSD-0_41:1.11
	NetBSD-0_40:1.11
	NetBSD-0_39:1.10
	NetBSD-0_38:1.10
	NetBSD-0_37:1.10
	NetBSD-0_36:1.10
	NetBSD-0_35:1.10
	NetBSD-0_34:1.10
	NetBSD-0_33:1.10
	NetBSD-0_32:1.10
	NetBSD-0_31:1.9
	NetBSD-0_30:1.9
	NetBSD-0_29:1.8
	RO_5_07:1.8
	NetBSD-0_28:1.8
	NetBSD-0_27:1.7
	NetBSD-0_26:1.7
	NetBSD-0_25:1.6
	NetBSD-0_24:1.5
	NetBSD-0_23:1.4
	NetBSD-0_21-1_22_2_1:1.3.2.1
	NetBSD-0_22:1.4
	USB1:1.3.0.2
	NetBSD-0_21:1.3
	NetBSD-0_20:1.3
	NetBSD-0_19:1.3
	NetBSD-0_18:1.3
	NetBSD-0_17:1.3
	NetBSD-0_16:1.3
	NetBSD-0_15:1.3
	NetBSD-0_14:1.3
	NetBSD-0_13:1.2
	NetBSD-0_12:1.2
	NetBSD-0_11:1.2
	NetBSD-0_10:1.2
	NetBSD-0_09:1.2
	NetBSD-0_08:1.2
	NetBSD-0_07:1.2
	NetBSD-0_06:1.1
	NetBSD-0_05:1.1
	NetBSD-0_04:1.1
	NetBSD-0_03:1.1
	NetBSD-0_02:1.1
	NetBSD-0_01:1.1;
locks; strict;
comment	@# @;


1.29
date	2016.12.17.10.12.57;	author rool;	state Exp;
branches;
next	1.28;
commitid	yws6HYEy6os04kyz;

1.28
date	2016.12.10.12.54.24;	author rool;	state Exp;
branches;
next	1.27;
commitid	zPShgPr6RkVlbrxz;

1.27
date	2015.11.17.08.54.38;	author rsprowson;	state Exp;
branches;
next	1.26;
commitid	aGTTwPGVohbkmqJy;

1.26
date	2015.08.21.19.59.48;	author rsprowson;	state Exp;
branches;
next	1.25;
commitid	lkGgBHyZsFbSRayy;

1.25
date	2015.07.04.08.39.00;	author rsprowson;	state Exp;
branches;
next	1.24;
commitid	83feWxHUYZB0EWry;

1.24
date	2015.01.06.00.04.46;	author jlee;	state Exp;
branches;
next	1.23;
commitid	tl9yMvzfmT5kyT4y;

1.23
date	2015.01.02.16.25.51;	author jballance;	state Exp;
branches;
next	1.22;
commitid	d826RZCxCbRS6t4y;

1.22
date	2014.10.25.18.43.36;	author rsprowson;	state Exp;
branches;
next	1.21;
commitid	SYXBVhhWAW5D5CVx;

1.21
date	2014.08.29.19.26.16;	author jlee;	state Exp;
branches;
next	1.20;
commitid	f6ArfsGGibMS9iOx;

1.20
date	2014.06.01.13.51.40;	author jlee;	state Exp;
branches;
next	1.19;
commitid	Vazl1SQGmZpsaPCx;

1.19
date	2013.03.30.23.46.26;	author jlee;	state Exp;
branches;
next	1.18;
commitid	QOU0ipH7csEsdSJw;

1.18
date	2012.06.24.21.55.29;	author jlee;	state Exp;
branches;
next	1.17;
commitid	4v309enDleTpz0aw;

1.17
date	2012.06.07.00.11.04;	author jlee;	state Exp;
branches;
next	1.16;
commitid	LkYeKFZjKWlNTH7w;

1.16
date	2011.08.08.21.17.17;	author jlee;	state Exp;
branches;
next	1.15;
commitid	Hr33MiiPstM1GKuv;

1.15
date	2011.05.22.20.22.34;	author jlee;	state Exp;
branches;
next	1.14;
commitid	Ye1jVWDlKivFSIkv;

1.14
date	2010.07.21.23.57.10;	author jlee;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.06.20.44.06;	author jlee;	state Exp;
branches;
next	1.12;

1.12
date	2009.05.09.19.32.46;	author jlee;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.18.11.54.03;	author jballance;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.03.01.50.01;	author jballance;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.25.00.54.52;	author jballance;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.12.14.47.39;	author jballance;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.30.14.50.35;	author kbracey;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.06.15.50.22;	author bavison;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.22.15.04.00;	author kbracey;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.21.20.49.15;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.15.12.22.15;	author rsprowson;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2003.02.22.11.38.36;	author kbracey;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.28.09.55.14;	author dellis;	state Exp;
branches;
next	;

1.3.2.1
date	2004.02.16.15.38.42;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Messages fixes, internationalisation, minor clean ups
Detail:
  USBDriver was performing unnecessary messages file reopening on Service_ResourceFSStarted (MessageTrans does this itself), remove this.
  Internationalised USBDriver, in particular its *Commands.
  Fixed standalone builds to output the messages file objects in the right place (Makefile mistake).
  Changed OHCIDriver and EHCIDriver to use allocated error bases rather than 0.
  Sync'd, where possible, the OHCIDriver and EHCIDriver sources which share a common heritage. Tentative shared interrupt support fixes for non-PCI attached controllers. Comment blocks & indentation improved.
  Export min() macro in usb_port.h.
  CMHG updated to not listen for unwanted services.
Admin:
  Submission for USB bounty.
  Tested on Pandaboard and Pi 2. OHCIDriver untested but low risk.

Version 1.18. Tagged as 'NetBSD-1_18'
@
text
@/* Copyright 2003 Tematic Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <machine/bus.h>
#include "swis.h"

#include <sys/queue.h>
#include <sys/types.h>
#include <sys/systm.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/ohcireg.h>
#include <dev/usb/ohcivar.h>

#include "Global/RISCOS.h"
#include "Global/Services.h"
#include "Global/HALEntries.h"
#include "Global/OsBytes.h"
#include "Interface/PCI.h"
#include "Interface/USBDriver.h"
#include "callx/callx.h"
#include "toolbox.h"

/* Have to avoid including stdio as there's a clash with the BSD stuff */
#define __stdio_h

#include "ohcimodhead.h"
#include "DebugLib/DebugLib.h"
#include "USBDevFS.h"

#define ErrorBase_OHCIDriver 0x820A00
#define ErrorBlock_OHCI_NoReinit    { (ErrorBase_OHCIDriver+0), "NumParm" }
#define ErrorBlock_OHCI_NoOHCI      { (ErrorBase_OHCIDriver+1), "E01"     }
#define ErrorBlock_OHCI_ClaimVeneer { (ErrorBase_OHCIDriver+2), "E02"     }
#define ErrorBlock_OHCI_USBTooOld   { (ErrorBase_OHCIDriver+3), "E03"     }
typedef struct
{
    int  errnum;
    char errtok[8];
} _kernel_tokerror;

/* for debugging */
#ifdef OHCI_DEBUG
extern int ohcidebug;
extern int usbdebug = 0;

/* debug for phase locking with vsync */
static int fm = 0;
static int target_fm = 11840;
static int vsync_count = 0;
static int print_fm = 0;
static int fm_interval = 11999;

char debugname[16];

int unhandled_irqs;
int irqs;
unsigned int irq_min = INT_MAX, irq_max = 0;
unsigned long long irq_tot;
#endif

extern int * init_veneer (void);
extern void* resource_files (void);
#ifdef OHCI_DEBUG
extern void ohci_dumpregs (ohci_softc_t *);
extern void ohci_dump_ed (ohci_soft_ed_t*);
#endif
extern void ohci_abort_xfer (void*, int);

void* private_word;
MessagesFD mod_messages;
volatile int* ohci_base;
ohci_softc_t ohci_soft;
struct device * usb_soft=NULL;

extern char panic_string[255];

int* magic = NULL;

int pci_device = -1;
int hal_device = -1;
int instance = 0;
int device_number;
static bool registering=false; /* True/false for whether we're in the middle of registering. Avoids nested registration attempt during ROM init. */

/*---------------------------------------------------------------------------*/
/* Port power controls - only used by HAL devices                            */
/*---------------------------------------------------------------------------*/
void (*ohci_ppower)(int port, int state);
int  (*ohci_error)(int port); /* Never gets used? */
void (*ohci_pirqclear)(int port);
static _kernel_oserror *ppower_statemachine(_kernel_swi_regs *, void *, void *);
static int hal_oc_device[15]; /* One over current device per port, max for OHCI is 15 */
static bool hal_oc_device_claimed[15];
typedef struct p_err_chk
{
    int unit;
    enum
    {
        P_none,
        P_on,
        P_off,
        P_going_on,
        P_going_on2,
        P_ready,
        P_retry
    } state;
} p_err_chk;
static p_err_chk pchk;

/* Read overcurrent state of port (1's based numbering).
 * Returns 0 if OK, non-0 if overcurrent
 */
static int do_hal_perror(int port)
{
    int r;
    _swix(OS_Hardware, _INR(0,1)|_INR(8,9)|_OUT(0),
                       hal_device, port - 1,
                       OSHW_CallHAL, EntryNo_HAL_USBPortIRQStatus,
                       &r);

    return r;
}

static int do_ohci_perror(int port)
{
    return ohci_base[OHCI_RH_PORT_STATUS(port)/4] & UPS_OVERCURRENT_INDICATOR
             ? 1 : 0;
}                           

/* Clear the overcurrent interrupt for the port (1's based numbering) */
static void do_hal_pirqclear(int port)
{
    _swix(OS_Hardware, _INR(0,1)|_INR(8,9),
                       hal_device, port - 1,
                       OSHW_CallHAL, EntryNo_HAL_USBPortIRQClear);
}

static void do_ohci_pirqclear(int port)
{
    /* Not implemented */
}

/* Turn on power to port (1's based numbering) */
static void do_hal_ppower(int port, int state)
{
    dprintf(("", "HAL port %d power state %d\n", port - 1, state));
    _swix(OS_Hardware, _INR(0,2)|_INR(8,9), hal_device, port - 1, state,
                                            OSHW_CallHAL, EntryNo_HAL_USBPortPower);
  
    /* Only allowed to monitor overcurrent status if port is on */
    if (hal_oc_device[port - 1] != -1)
    {
        if (state && !hal_oc_device_claimed[port - 1])
        {
            pchk.state = P_going_on;
            pchk.unit = port;
            /* Give it a little turn on time before grumbling */
            callx_add_callafter(USB_PORT_RESET_DELAY/10, ppower_statemachine, (void *)&pchk);
        }
        else
        {
            if (!state)
            {
                pchk.state = P_retry;
                pchk.unit = port;
                /* Try again after a delay of a second or so */  
                callx_add_callafter(100, ppower_statemachine, (void *)&pchk);
                if (hal_oc_device_claimed[port - 1])
                {
                    do_hal_pirqclear(port);
                    _swix(OS_ReleaseDeviceVector, _INR(0,2),
                                           hal_oc_device[port - 1],
                                           usb_overcurrent_entry, private_word);
                    hal_oc_device_claimed[port - 1] = false;
                }
            }
        }
    }
}

static void do_ohci_ppower(int port, int state)
{
    dprintf (("", "OHCI port %d power state %d\n", port, state));
    ohci_base[OHCI_RH_PORT_STATUS(port)/4] =
        state ? UPS_PORT_POWER : UPS_LOW_SPEED;
}

static void do_dummy_ppower(int port, int state)
{
    /* Do nothing for PCI devices */
}

static _kernel_oserror *ppower_statemachine(_kernel_swi_regs *r, void *pw, void *v)
{
    p_err_chk *p = (p_err_chk *)v;
    switch(p->state)
    {
        case P_going_on:
            if (do_hal_perror(p->unit))
            {
                /* Power is not yet good, wait a little longer */
                p->state = P_going_on2;
                callx_add_callafter(USB_PORT_RESET_DELAY/10, ppower_statemachine, v);
                break;
            }
            /* Else fall through */
        case P_going_on2:
            if (do_hal_perror(p->unit))
            {
                /* Power is still not good, turn it off */
                p->state = P_off;
                do_hal_ppower(p->unit, 0);
                break;
            }
            /* Else fall through */
        case P_ready:
            /* Power on, and not overcurrent yet, monitor it normally */
            do_hal_pirqclear(p->unit);
            _swix(OS_ClaimDeviceVector, _INR(0,2),
                  hal_oc_device[p->unit - 1], usb_overcurrent_entry, private_word);
            _swix(OS_Hardware, _IN(0) | _INR(8,9), hal_oc_device[p->unit - 1],
                               OSHW_CallHAL, EntryNo_HAL_IRQEnable);
            hal_oc_device_claimed[p->unit - 1] = true;
            p->state = P_on;
            break;
        case P_retry:
            /* Try turning on again */ 
            do_hal_ppower(p->unit, 1);
            break;         
    }
    return NULL;
}

int usb_overcurrent_handler(_kernel_swi_regs *r, void *pw)
{
    size_t i;
    int    test, devno = r->r[0] & 0xFFFFFF; /* Knock out ClaimDeviceVector flags */

    /* This single handler is registered for all the port overcurrents, so
     * we need to match up the device number with a port in our table. Note,
     * the device numbers might be shared, in which case only the first hit
     * claims (any subsequent ones will come back here anyway).
     */
    for (i = 0; i < (sizeof(hal_oc_device) / sizeof(hal_oc_device[0])); i++)
    {
        test = hal_oc_device[i] & 0xFFFFFF; 
        if ((devno == test) && do_hal_perror(i + 1))
        {
            /* Claim this one, it's one of ours, and is interrupting */
            do_hal_pirqclear(i + 1);
            _swix(OS_Hardware, _IN(0)|_INR(8,9), test,
                                                 OSHW_CallHAL, EntryNo_HAL_IRQClear);
            do_hal_ppower(i + 1, 0); /* Power off please */
            return 0;
        }
    }
    return 1;
}

/*---------------------------------------------------------------------------*/
/* Driver instance creation                                                  */
/*---------------------------------------------------------------------------*/
void build_veneer (int* vn, int* st, size_t sz)
{
    int i;
    dprintf (("", "writing veneer from %p at %p\n", st, vn));
    int* entry_table = vn + sz / sizeof (void*);
    for (i = 0; i < sz / sizeof (void*); ++i) {
        int* entry = entry_table + 2 * i;

        /* if the method isn't implemented, don't veneer it */
        if (st[i] == NULL) continue;

        /* copy function pointer into veneer */
        vn[i] = st[i];

        /* copy new pointer into structure */
        st[i] = (int) entry;

        /* LDR ip, function[i] */
        entry[0] = 0xe51fC000       /* LDR ip, [pc, #-0] */
                  + 8               /* go back to current instruction */
                  + i * 8           /* go back to beginning of veneers */
                  + sz              /* go back to beginning of struct */
                  - i * 4;          /* go to func pointer */

        /* B common */
        entry[1] = 0xea000000       /* B here + 8 */
                  | ((magic - entry - 1) & 0x00ffffff);
                                    /* branch to diff */
    }
    _swix(OS_SynchroniseCodeAreas, _INR(0,2), 1,
                                   entry_table,
                                   entry_table + 2 * (sz / sizeof (void*)) - 1);
}

_kernel_oserror* register_bus(void *in,struct device **out)
{
    *out = NULL;
    /* Check USBDriver is new enough */
    int version;
    _kernel_oserror *e = _swix(USBDriver_Version,_OUT(0),&version);
    if(e)
        return e;
    if(version < RISCOS_USBDRIVER_API_VERSION)
    {
        static const _kernel_tokerror err_usbtooold = ErrorBlock_OHCI_USBTooOld;
    
        return _swix (MessageTrans_ErrorLookup, _INR(0,2),
                      &err_usbtooold, &mod_messages, 0 /* Internal buffer */);
    }

    /* Now attempt to register */
    registering = true;
    e = _swix(USBDriver_RegisterBus, _INR(0,1)|_OUT(0),in,RISCOS_USBDRIVER_API_VERSION,out);
    if(e) *out = NULL;
    registering = false;
    return e;
}

static void name_root_hub(int pcidevice)
{
    if (pci_device == -1)
    {
        _kernel_oserror *e;

        e = _swix (MessageTrans_Lookup, _INR(0,3),
                   &mod_messages, "UkRoot", ohci_soft.sc_vendor, sizeof(ohci_soft.sc_vendor));
        if (e) strcpy(ohci_soft.sc_vendor, " ");
    }
    else
    {
        char *v = NULL;
    
        _swix (PCI_ReadInfo, _INR(0,3), PCI_ReadInfo_Vendor, &v, sizeof(v), pci_device);
        if (v == NULL) v = " ";
        strncpy (ohci_soft.sc_vendor, v, sizeof ohci_soft.sc_vendor-1);
    }
}

_kernel_oserror* new_instance (_kernel_swi_regs* r, void* pw, void* h)
{
    _kernel_oserror * e;

    (void) r;
    (void) pw;
    (void) h;

    /* fill in the device name in the callback so that our service call handler
       is threaded and there to respond to PCI calls */
    name_root_hub(pci_device);

    /* register with the usbdriver module if it's already resident */
    dprintf (("", "Registering with USB driver\n"));
    e = register_bus(&ohci_soft, &usb_soft);
    if (e)
    {
        dprintf (("", "Failed to register: %s\n", e->errmess));
    }
    else
    {
        dprintf (("", "Init-Registering with USB driver-done\n"));
    }

    /* allow enough space for name, % and number, then space, device type,
       and another number */
    char name[sizeof Module_Title + 1 + 12 + 1 + 1 + 12];
    sprintf (name, Module_Title"%%%d %c%d", instance + 1, (pci_device>=0?'P':'H'), (pci_device>=0?pci_device:hal_device));
    dprintf (("", "Trying to start %s\n", name));
    e = _swix (OS_Module, _INR(0,1), 14, name);

    if (e)
    {
        dprintf (("", "Failed to start %s: %s\n", name, e->errmess));
    }
    return NULL;
}

/*---------------------------------------------------------------------------*/
/* CMHG module initialisation                                                */
/*---------------------------------------------------------------------------*/
_kernel_oserror *module_init(const char *cmd_tail, int podule_base, void *pw) {
    size_t i;
    _kernel_oserror *e;
    struct
    {
        int type;
        int flags;
        void *hw;
        int devno;
    } usbinfo;

    *panic_string = '\0';

    callx_init (pw);

    /* set up debugging */
#ifdef OHCI_DEBUG
    sprintf(debugname,"OHCIDrv-%d",podule_base);
#endif
    debug_initialise (debugname, 0, 0);
    debug_set_device(DEBUGIT_OUTPUT);
    debug_set_unbuffered_files (TRUE);
    /* Can't set debug_set_stamp_debug(TRUE) - causes interrupts to be briefly enabled during debug output, which breaks all kinds of stuff */
/*    debug_set_stamp_debug (TRUE); */

    dprintf (("Main_0", "Starting driver\n"));

    /* simulate having one OHCI device attached.  This section has to
    communicate with HAL or podule manager to find out where it can read/write    to some OHCI registers */

    /* assume podule_base is actually instantiation number - how to do this
       in a HAL world?  If we're the first instance, then search for devices
       on the PCI bus */

    instance = podule_base;


    /* if we're the first instance, then start searching from device # 0,
       otherwise the device to start searching from was passed as a string
       in the command tail */

    if (podule_base != 0)
    {
        const char* endptr = cmd_tail;
        while(*endptr == ' ')
            endptr++;
        if(*endptr == 'P')
            pci_device = (int) strtol (endptr+1, NULL, 0);
        else if(*endptr == 'H')
            hal_device = (int) strtol (endptr+1, NULL, 0);
        else
        {
            static const _kernel_tokerror err_noreinit = ErrorBlock_OHCI_NoReinit;

            return _swix (MessageTrans_ErrorLookup, _INR(0,2),
                          &err_noreinit, 0 /* Global messages */, 0 /* Internal buffer */);
        }
    }
    else
    {
        pci_device = 0;
#ifdef STANDALONE
        /* Only first instance registers the messages in ResourceFS */
        e = _swix (ResourceFS_RegisterFiles, _IN (0), resource_files ());
        if (e != NULL) return e;
#endif
    }

    e = _swix (MessageTrans_OpenFile, _INR(0,2),
        &mod_messages,
        Module_MessagesFile,
        0);
    if (e) goto error_dereg;

    /* find the next possible controller */
    if(pci_device >= 0)
    {
        /* Looking for PCI device */
        e = _swix(PCI_FindByClass, _INR(0,1)|_IN(3)|_OUT(3),
            0x0C0310,
            0xFFFFFF,
            pci_device,
            &pci_device);
        if(!e)
        {
             dprintf (("", "Found OHCI controller on PCI device %d\n", pci_device));
            e = _swix(PCI_ReadInfo, _INR(0,3),
                PCI_ReadInfo_IntDeviceVector,
                &device_number,
                sizeof device_number,
                pci_device);
            if (e) goto error;
        
            e = _swix(PCI_HardwareAddress, _INR(0,1)|_IN(3)|_OUT(4),
                0, 0, pci_device, &ohci_base);
            if (e) goto error;
        
            ohci_ppower = do_dummy_ppower;
        }
        else
        {
            /* Reached end of list */
            pci_device = -1;
        }
    }
    if(pci_device == -1)
    {
        size_t usbinfolen;

        /* Looking for HAL device */
        do {
            hal_device++;

            e = _swix(OS_Hardware, _INR(0,2)|_INR(8,9)|_OUT(0),
                                   hal_device, &usbinfo, sizeof usbinfo,
                                   OSHW_CallHAL, EntryNo_HAL_USBControllerInfo,
                                   &usbinfolen);
            if (!e && (usbinfolen == sizeof(usbinfo)) && (usbinfo.type == HALUSBControllerType_OHCI))
            {
                dprintf (("", "Found OHCI controller on HAL device %d\n", hal_device));
                device_number = usbinfo.devno;
                ohci_base = usbinfo.hw;
                
                if (usbinfo.flags & HALUSBControllerFlag_HAL_Port_Power)
                {
                    ohci_ppower = do_hal_ppower;
                }
                else
                {
                    ohci_ppower = do_ohci_ppower;
                }
                if (usbinfo.flags & HALUSBControllerFlag_HAL_Over_Current)
                {
                    ohci_error = do_hal_perror;
                    ohci_pirqclear = do_hal_pirqclear;
                }
                else
                {
                    ohci_error = do_ohci_perror;
                    ohci_pirqclear = do_ohci_pirqclear;
                }
                break;
            }
            else if(e || !usbinfolen)
            {
                /* Reached end of list */
                static const _kernel_tokerror err_noohci = ErrorBlock_OHCI_NoOHCI;
            
                e = _swix (MessageTrans_ErrorLookup, _INR(0,2),
                           &err_noohci, &mod_messages, 0 /* Internal buffer */);
                goto error;
            }
        } while(1);
    }

    dprintf (("Main_0", "interrupt device %d\n", device_number));
    dprintf (("Main_0", "hardware address %p\n", ohci_base));

    /* Build a table of port overcurrent device numbers to ports */
    for (i = 0; i < (sizeof(hal_oc_device) / sizeof(hal_oc_device[0])); i++)
    {
        if (usbinfo.flags & HALUSBControllerFlag_HAL_Over_Current)
        {
            _swix(OS_Hardware, _INR(0,1)|_INR(8,9)|_OUT(0),
                               hal_device, i,
                               OSHW_CallHAL, EntryNo_HAL_USBPortDevice,
                               &hal_oc_device[i]);
            if (hal_oc_device[i] != -1)
            {
                dprintf(("", "HAL port %d is overcurrent device %d\n", i, hal_oc_device[i])); 
            }
        }
        else
        {
            hal_oc_device[i] = -1; /* Not used */
        }
        hal_oc_device_claimed[i] = false;
    }

    memset (&ohci_soft, 0, sizeof ohci_soft);

    sprintf (ohci_soft.sc_bus.bdev.dv_xname, "OHCI%d", instance);
    ohci_soft.sc_irqdevno = device_number;
    dprintf (("Main_0", "interrupt device %d\n", device_number));
    dprintf (("Main_0", "hardware address %p\n", ohci_base));

    private_word = pw;

#ifdef OHCI_DEBUG
    const char *c = getenv("ohcidebug");
    usbdebug = ohcidebug = (c?atoi(c):0);
#endif

    if ((magic = init_veneer ()) == NULL)
    {
        static const _kernel_tokerror err_claimveneer = ErrorBlock_OHCI_ClaimVeneer;
    
        e = _swix (MessageTrans_ErrorLookup, _INR(0,2),
                   &err_claimveneer, &mod_messages, 0 /* Internal buffer */);
        goto error;
    }
    dprintf (("", "magic at %p", magic));

    _swix (OS_ClaimDeviceVector, _INR(0,2),
        device_number | ((pci_device == -1)?0:(1u<<31)),
        usb_irq_entry, pw);
    _swix (OS_Hardware, _IN(0) | _INR(8,9),
        device_number, OSHW_CallHAL, EntryNo_HAL_IRQEnable);

    /* for the L7205, clocks need to be started */
    /* in BSD this is called from sys/pci/ohci_pci.c */
    ohci_init (&ohci_soft);

    dprintf (("", "Finished module initialisation\n"));

#ifdef OHCI_DEBUG
    /* if we're sharing an interrupt with the video card */
    if (device_number == 62 && getenv("vsync"))
    {
        vsync_count++;
        _swix (OS_Claim, _INR(0, 2), EventV, vsync_entry, pw);
        _kernel_osbyte (OsByte_EnableEvent, Event_VSync, 0);
    }
#endif

    /* try and start a new instance to catch any more controllers on the bus,
       done in a callback so that this instance is threaded and the instance
       count goes up */
    /* also register with the usbdriver module if it's already resident */

    callx_add_callback (new_instance, 0);

    return NULL;

error:
    dprintf (("Failed initialisation: %s\n", e->errmess));
    _swix (MessageTrans_CloseFile, _IN(0), &mod_messages);
error_dereg:
#ifdef STANDALONE
    if (podule_base == 0) _swix (ResourceFS_DeregisterFiles, _IN(0), resource_files ());
#endif
    return e;
}

/*---------------------------------------------------------------------------*/
/* CMHG module finalisation                                                  */
/*---------------------------------------------------------------------------*/
_kernel_oserror *module_final(int fatal, int podule, void *pw)
{
    int v;
    volatile int* ob = ohci_base;

    dprintf (("", "OHCIDriver finalising\n"));

    if (usb_soft != NULL)
    {
        _swix (USBDriver_DeregisterBus, _IN(0), usb_soft);
        usb_soft=NULL;
    }

#ifdef OHCI_DEBUG
    module_commands (0, 0, CMD_OHCIEDS, pw);
#endif

    dprintf (("", "Bus deregistered\n"));

    /* reset the controller */
    ob[OHCI_COMMAND_STATUS / 4] = OHCI_HCR;
    v = ob[OHCI_COMMAND_STATUS]; // flush the write
    while (ob[OHCI_COMMAND_STATUS / 4] & OHCI_HCR);
    ob[OHCI_CONTROL / 4] = OHCI_HCFS_RESET;

    v = ob[OHCI_CONTROL / 4]; // flush the write

    callx_remove_all_callbacks ();
    callx_remove_all_callafters ();
    callx_remove_all_calleverys ();

    /* don't disable the interrupt since it is shared, the OS will disable it
       when noone is left responding */

    _swix (OS_ReleaseDeviceVector, _INR(0,2),
        device_number | ((pci_device == -1)?0:(1u<<31)),
        usb_irq_entry, pw);

    for (v = 0; v < (sizeof(hal_oc_device) / sizeof(hal_oc_device[0])); v++)
    {
        if (hal_oc_device_claimed[v] && (hal_oc_device[v] != -1))
        {
            _swix(OS_ReleaseDeviceVector, _INR(0,2),
                  hal_oc_device[v], usb_overcurrent_entry, private_word);
        }
    }                         

    if (magic) _swix (OS_Module, _IN(0)|_IN(2), 7, magic);

#ifdef OHCI_DEBUG
    /* if we're sharing an interrupt with th video card */
    if (device_number == 62 && vsync_count)
    {
        _kernel_osbyte (OsByte_DisableEvent, Event_VSync, 0);
        _swix (OS_Release, _INR(0, 2), EventV, vsync_entry, pw);
    }
#endif

    _swix (MessageTrans_CloseFile, _IN(0), &mod_messages);

#ifdef STANDALONE
    /* only remove files for last instantiation */
    if (podule == 0)
    {
        _swix (ResourceFS_DeregisterFiles, _IN (0), resource_files ());
    }
#endif

// need to do something here eventually
//    ohci_detach (&ohci_soft, 0);


    return NULL;
}

/*---------------------------------------------------------------------------*/
/* CMHG module service calls                                                 */
/*---------------------------------------------------------------------------*/
static void service_pci (_kernel_swi_regs* r)
{
    dprintf (("", "Service PCI, r0 = %x, r1 = %x, r2 = %x\n",
        r->r[0], r->r[1], r->r[2]));
    char tok[8];
    unsigned int p;
    switch (r->r[2])
    {
    case 0:
        _swix (PCI_ReadInfo, _INR(0,3),
            PCI_ReadInfo_DeviceID,
            &p,
            sizeof p,
            r->r[3]);
        sprintf (tok, "D%04X%04X", p & 0xffff, p >> 16);
        break;
    case 1:
        sprintf (tok, "V%04X", r->r[0]);
        break;
    default:
        return;
    }

    /* claim service call if lookup was successful */
    if (NULL == _swix (MessageTrans_Lookup, _INR(0,2)|_OUT(2),
        &mod_messages,
        tok,
        0,
        r->r + 2))
    {
        r->r[1] = 0;
    }
    else
    {
        dprintf (("", "Couldn't find token %s\n", tok));
    }
}

void module_services(int service_number, _kernel_swi_regs *r, void *pw)
{
    switch (service_number) {
    case Service_PCI:
        service_pci (r);
        break;
    case Service_PreReset:
        /* reset the controller */
        ohci_base[OHCI_COMMAND_STATUS / 4] = OHCI_HCR;
        magic = (int*) ohci_base[OHCI_COMMAND_STATUS]; // flush the write
        while (ohci_base[OHCI_COMMAND_STATUS / 4] & OHCI_HCR);
        ohci_base[OHCI_CONTROL / 4] = OHCI_HCFS_RESET;

        magic = (int*) ohci_base[OHCI_CONTROL]; // flush the write
        callx_remove_all_callbacks ();
        callx_remove_all_callafters ();
        callx_remove_all_calleverys ();
        _swix (OS_ReleaseDeviceVector, _INR(0,2),
            device_number | ((pci_device == -1)?0:(1u<<31)),
            usb_irq_entry, pw);
    
        for (int i = 0; i < (sizeof(hal_oc_device) / sizeof(hal_oc_device[0])); i++)
        {
            if (hal_oc_device_claimed[i] && (hal_oc_device[i] != -1))
            {
                _swix(OS_ReleaseDeviceVector, _INR(0,2),
                      hal_oc_device[i], usb_overcurrent_entry, private_word);
            }
        }                         
        break;
    case Service_USB:
        switch (r->r[0]) {
        case Service_USB_USBDriverStarting:
            if ((usb_soft == NULL) && !registering)
            {
                dprintf (("", "Registering with USB driver from svcecall\n"));
                _kernel_oserror *e = register_bus(&ohci_soft,&usb_soft);
                if(e)
                {
                    dprintf (("", "Failed to register: %s\n", e->errmess));
                }
                else
                {
                    dprintf (("", "Registering with USB driver from svcecall-done\n"));
                }
            }
            break;
        case Service_USB_USBDriverDying:
            dprintf (("", "Deregistering with USB driver\n"));
            /* USBDriver will do the deregistering at this point, since
               it's SWIs are not active anymore */
            usb_soft = NULL;
            memset (&ohci_soft, 0, sizeof ohci_soft);
            sprintf (ohci_soft.sc_bus.bdev.dv_xname, "OHCI%d", instance);
            name_root_hub (pci_device);
            ohci_init (&ohci_soft);
            break;
        }
        break;
#ifdef STANDALONE
    case Service_ResourceFSStarting:
        /* Re-register the messages */
        (*(void (*)(void *, void *, void *, void *))r->r[2]) (resource_files (), 0, 0, (void *)r->r[3]);
        break;
#endif
    }
}

#ifdef OHCI_DEBUG
/*---------------------------------------------------------------------------*/
/* CMHG module commands - only used for debugging                            */
/*---------------------------------------------------------------------------*/
_kernel_oserror *module_commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
#define OREAD(o) ohci_base[o/4]

    switch (cmd_no) {
    case CMD_OHCIRegs:
        printf
        (
            "PCI device                %8d\n"
            "All IRQs                  %8d\n"
            "Unhandled IRQs            %8d\n"
            "(Handled IRQs)            %8d\n"
            "Min IRQ time              %8d\n"
            "Max IRQ time              %8d\n"
            "Ave IRQ time              %8d\n"
            "VSyncs                    %8d\n"
            "Registers at              %8X\n"
            "%2X Revision               %8.8X\n"
            "%2X Control                %8.8X\n"
            "%2X Command                %8.8X\n"
            "%2X IRQ status             %8.8X\n"
            "%2X IRQ enable             %8.8X\n"
            "%2X HCCA                   %8.8X\n"
            "%2X Periodic Current ED    %8.8X\n"
            "%2X Control Head           %8.8X\n"
            "%2X Control Current        %8.8X\n"
            "%2X Bulk Head              %8.8X\n"
            "%2X Bulk Current           %8.8X\n"
            "%2X OHCI done head         %8.8X\n"
            "%2X FM Interval            %8.8X\n"
            "%2X FM Remaining           %8.8X\n"
            "%2X FM Number              %8.8X\n"
            "%2X Periodic start         %8.8X\n"
            "%2X LS Threshold           %8.8X\n"
            "%2X RH descriptorA         %8.8X\n"
            "%2X RH descriptorB         %8.8X\n"
            "%2X Status                 %8.8X\n"
            "%2X Port 1                 %8.8X\n"
            "%2X Port 2                 %8.8X\n"
            "%2X (Port 3)               %8.8X\n"
            "Errors: %s\n",
            pci_device,
            irqs,
            unhandled_irqs,
            irqs - unhandled_irqs,
            irq_min,
            irq_max,
            (irqs - unhandled_irqs)?
                (unsigned int) (irq_tot / (irqs - unhandled_irqs)): 0,
            vsync_count,
            ohci_base,
            OHCI_REVISION, OREAD(OHCI_REVISION),
            OHCI_CONTROL, OREAD(OHCI_CONTROL),
            OHCI_COMMAND_STATUS, OREAD(OHCI_COMMAND_STATUS),
            OHCI_INTERRUPT_STATUS, OREAD(OHCI_INTERRUPT_STATUS),
            OHCI_INTERRUPT_ENABLE, OREAD(OHCI_INTERRUPT_ENABLE),
            OHCI_HCCA, OREAD(OHCI_HCCA),
            OHCI_PERIOD_CURRENT_ED, OREAD(OHCI_PERIOD_CURRENT_ED),
            OHCI_CONTROL_HEAD_ED, OREAD(OHCI_CONTROL_HEAD_ED),
            OHCI_CONTROL_CURRENT_ED, OREAD(OHCI_CONTROL_CURRENT_ED),
            OHCI_BULK_HEAD_ED, OREAD(OHCI_BULK_HEAD_ED),
            OHCI_BULK_CURRENT_ED, OREAD(OHCI_BULK_CURRENT_ED),
            OHCI_DONE_HEAD, OREAD(OHCI_DONE_HEAD),
            OHCI_FM_INTERVAL, OREAD(OHCI_FM_INTERVAL),
            OHCI_FM_REMAINING, OREAD(OHCI_FM_REMAINING),
            OHCI_FM_NUMBER, OREAD(OHCI_FM_NUMBER),
            OHCI_PERIODIC_START, OREAD(OHCI_PERIODIC_START),
            OHCI_LS_THRESHOLD, OREAD(OHCI_LS_THRESHOLD),
            OHCI_RH_DESCRIPTOR_A, OREAD(OHCI_RH_DESCRIPTOR_A),
            OHCI_RH_DESCRIPTOR_B, OREAD(OHCI_RH_DESCRIPTOR_B),
            OHCI_RH_STATUS, OREAD(OHCI_RH_STATUS),
            OHCI_RH_PORT_STATUS(1), OREAD(OHCI_RH_PORT_STATUS(1)),
            OHCI_RH_PORT_STATUS(2), OREAD(OHCI_RH_PORT_STATUS(2)),
            OHCI_RH_PORT_STATUS(3), OREAD(OHCI_RH_PORT_STATUS(3)),
            panic_string
        );
        panic_string[0] = '\0';

        ohci_dumpregs (&ohci_soft);
        break;
    case CMD_OHCIEDS:
        {
            ohci_soft_ed_t* sed;
            sed = ohci_soft.sc_isoc_head;
            dprintf (("", "Isochronous endpoints\n"));
            while (sed != NULL) {
                ohci_dump_ed(sed);
                sed = sed->next;
            }
            sed = ohci_soft.sc_ctrl_head;
            dprintf (("", "\n\nControl endpoints\n"));
            while (sed != NULL) {

                ohci_dump_ed(sed);
                sed = sed->next;
            }
            sed = ohci_soft.sc_bulk_head;
            dprintf (("", "\n\nBulk endpoints\n"));
            while (sed != NULL) {
                ohci_dump_ed(sed);
                sed = sed->next;
            }
            break;
        }
    case CMD_OHCIWrite:
        {
        int a, b;
        char* ptr;
        a = (int) strtoul (arg_string, &ptr, 16);
        b = (int) strtoul (ptr, 0, 16);
        printf ("writing %x to %x\n", b, a);
        ohci_base[a / 4] = b;
        }
        break;
    case CMD_OHCIDebug:
        {
        char* ptr;
        ohcidebug = (int) strtoul (arg_string, &ptr, 0);
        if (ptr) usbdebug = (int) strtoul (ptr, &ptr, 0);
        }
        break;
    case CMD_TargetFM:
        target_fm = (int) strtol (arg_string, NULL, 10);
        break;
    default:
        break;
    }

    return 0;
}
#endif

#ifdef OHCI_DEBUG
int vsync(_kernel_swi_regs *r, void *pw)
{
    vsync_count++;
//    if (print_fm == 0) return 1;
//    print_fm = 0;

    /* fm is the amount of ticks left in this frame.  we'd like it to be zero,
       so that we're hitting the vsync exactly.  to this end, if it's greater
       than half the intervale, we subtract it from the interval to make give us
       a negative value which is ticks since the last frame */
    fm = ohci_base[OHCI_FM_REMAINING/4] & ~OHCI_FIT;

    /* the pattern of vsyncs repeats every 3 */
    static int n = 1;
    if (++n == 4) n = 1;

    int f = (fm + 12000 - target_fm) % 4000;
    if (f > 2000) f = f - 4000;

    /* if fm was positive, then our frames aren't long enough, if fm was
       negative, then the frames too long */
    fm_interval = 11999;
    if (f < 0) fm_interval = 12000;
    if (f > 0) fm_interval = 11998;

    int ival = ohci_base[OHCI_FM_INTERVAL / 4];
    ohci_base[OHCI_FM_INTERVAL/4] =
        ((ival & OHCI_FIT) ^ OHCI_FIT) | OHCI_FSMPS(fm_interval) | fm_interval;

//    if (print_fm)
//        dprintf (("", "%08d, %08d, fm = %05d, fm_interval = %05d\n",
//            irqs, vsync_count, fm, fm_interval));
    print_fm = 0;

    return 1;
}
#endif

/*---------------------------------------------------------------------------*/
/* CMHG interrupt veneer handler                                             */
/*---------------------------------------------------------------------------*/
int usb_irq_handler(_kernel_swi_regs *r, void *pw)
{
    int ret;
#ifdef OHCI_DEBUG
    int u2s, u2s1;
    _swix (OS_Hardware, _INR(8,9)|_OUT(0),
        OSHW_CallHAL, EntryNo_HAL_CounterRead, &u2s);
    irqs++;
#endif


    // ohci_intr returns 0 for failure, 1 for success, the inverse of what
    // we're expected to return

    /* interrupts must be left off for the duration of this call, otherwise
       it hangs */
      ret = !ohci_intr (&ohci_soft);
      // the chip requires its interrupts cleared
      if (pci_device == -1)
         _swix(OS_Hardware, _IN(0)|_INR(8,9), device_number,
                                           OSHW_CallHAL, EntryNo_HAL_IRQClear);

#ifdef OHCI_DEBUG
    if (ret)
    {
        unhandled_irqs++;
    }
    else
    {
        _swix (OS_Hardware, _INR(8,9)|_OUT(0),
            OSHW_CallHAL, EntryNo_HAL_CounterRead, &u2s1);
        int t = (u2s - u2s1) * 5;
        if (t < 0) t += 10000000; /* it wrapped */
//        if (ohcidebug > 1) dprintf(("", "irq for: %d nsecs\n", t));
        irq_tot += t;
        if (t < irq_min) irq_min = t;
        if (t > irq_max) irq_max = t;
    }
#endif


    return ret;
}

/*---------------------------------------------------------------------------*/
/* Leaf functions                                                            */
/*---------------------------------------------------------------------------*/
void bus_space_write_4 (bus_space_tag_t iot, bus_space_handle_t ioh, int o, int x)
{
#ifdef OHCI_DEBUG
    if (ohcidebug > 10)
        dprintf  (("", "write %x to %p\n", x, ohci_base + o/4));
#endif
    ohci_base[o/4] = x;
}

int bus_space_read_4 (bus_space_tag_t iot, bus_space_handle_t ioh, int o)
{
    int ret = ohci_base[o/4];
#ifdef OHCI_DEBUG
    if (ohcidebug > 15)
         dprintf  (("", "read %x from %p\n", ret, ohci_base + o/4));
#endif
    return ret;
}

void timeout(timeout_func_t f, void * h, int t)
{
    dprintf (("Main_0", "timeout %p %d\n", h, t));
}

void untimeout(timeout_func_t f, void * h)
{
    dprintf (("Main_0", "untimeout %p\n", h));
}

/* declare here to avoid clash with sys/types.h */
int	tsleep(void *chan, int pri, char *wmesg, int timo, int noblock);
void usb_delay_ms(usbd_bus_handle h, u_int d)
{
    tsleep (&d, 0, "usbdly", d, 0);
}

usbd_status
usb_insert_transfer(usbd_xfer_handle xfer)
{
    usbd_status status;
    _swix (USBDriver_InsertTransfer, _IN (0) | _OUT (0), xfer, &status);
    return status;
}

void
usb_transfer_complete(usbd_xfer_handle xfer)
{
    _swix (USBDriver_TransferComplete, _IN (0), xfer);
}

static _kernel_oserror*
_riscos_abort_pipe (_kernel_swi_regs * r, void* pw, void* v)
{
    ohci_abort_xfer (v, USBD_TIMEOUT);
    return NULL;
}

void
riscos_abort_pipe (void* v)
{
    callx_add_callback (_riscos_abort_pipe, v);
}

void
usb_schedsoftintr (struct usbd_bus* sc)
{
//    dprintf (("", "Scheduling soft interrupt\n"));
//    *(void**) sc->soft = (void*) softintr_entry;
    _swix (USBDriver_ScheduleSoftInterrupt, _IN(0), sc);
}

int
softintr (_kernel_swi_regs* r, void* pw)
{
    ohci_softintr ((void*) r->r[0]);
    return 0;
}
@


1.28
log
@Case change to match documentation
Detail:
  DeRegisterBus->DeregisterBus. Since clients calling this SWI are compiled C or assembler, this doesn't affect existing modules which remain binary compatible.
Admin:
  Submission for USB bounty.

Version 1.17. Tagged as 'NetBSD-1_17'
@
text
@d47 10
a56 7
#define OHCIEmulator_GetRegisters 0x54a80
#define OHCIEmulator_ClaimDeviceVector  0x054a81
#define OHCIEmulator_ReleaseDeviceVector  0x054a82
#define OHCIEmulator_ReadWord           0x054a83
#define OHCIEmulator_WriteWord          0x054a84

#define OHCIVendorUnknownRootName       "Built-in"
d102 3
a104 1
/* Port power controls - only used by HAL devices */
a126 34
void build_veneer (int* vn, int* st, size_t sz)
{
    int i;
    dprintf (("", "writing veneer from %p at %p\n", st, vn));
    int* entry_table = vn + sz / sizeof (void*);
    for (i = 0; i < sz / sizeof (void*); ++i) {
        int* entry = entry_table + 2 * i;

        /* if the method isn't implemented, don't veneer it */
        if (st[i] == NULL) continue;

        /* copy function pointer into veneer */
        vn[i] = st[i];

        /* copy new pointer into structure */
        st[i] = (int) entry;

        /* LDR ip, function[i] */
        entry[0] = 0xe51fC000       /* LDR ip, [pc, #-0] */
                  + 8               /* go back to current instruction */
                  + i * 8           /* go back to beginning of veneers */
                  + sz              /* go back to beginning of struct */
                  - i * 4;          /* go to func pointer */

        /* B common */
        entry[1] = 0xea000000       /* B here + 8 */
                  | ((magic - entry - 1) & 0x00ffffff);
                                    /* branch to diff */
    }
    _swix(OS_SynchroniseCodeAreas, _INR(0,2), 1,
                                   entry_table,
                                   entry_table + 2 * (sz / sizeof (void*)) - 1);
}

d277 37
d323 7
a329 1
        return (_kernel_oserror*)"\0\0\0\0USBDriver too old";
d338 20
a360 1
    char* v=NULL;
d368 4
a371 12
    if (pci_device == -1)
    {
        strncpy (ohci_soft.sc_vendor, OHCIVendorUnknownRootName, sizeof ohci_soft.sc_vendor-1);
    }
    else
    {
        _swix (PCI_ReadInfo, _INR(0,3), (1<<16), &v, 4, pci_device);
        if (v == 0) v = (char *)" ";
        strncpy (ohci_soft.sc_vendor, v, sizeof ohci_soft.sc_vendor-1);
    }
    /* now we know the root hub info, register it with USBDriver */
    dprintf (("", "Init-Registering with USB driver\n"));
d396 3
a398 3



d451 4
a454 2
            return (_kernel_oserror*)
                "\1\0\0\0"Module_Title" can't be reinitialised";
d461 1
d471 1
a471 3
    if (e) return e;

    /* see if there are any more USB OHCI controllers */
d473 1
d540 1
d544 6
a549 1
                return (_kernel_oserror*) "\0\0\0\0No OHCI devices found";
d582 2
a583 15


    if (pci_device == -1)
    {
        strncpy(ohci_soft.sc_vendor, OHCIVendorUnknownRootName, sizeof ohci_soft.sc_vendor-1);
    }
    else
    {
        char *v = NULL;

        _swix (PCI_ReadInfo, _INR(0,3), PCI_ReadInfo_Vendor, &v, sizeof(v), pci_device);
        if (v == NULL) v = (char *)" ";
        strncpy (ohci_soft.sc_vendor, v, sizeof ohci_soft.sc_vendor-1);
    }

d591 11
a607 6
    if ((magic = init_veneer ()) == NULL)
    {
        return (_kernel_oserror*) "\0\0\0\0Couldn't claim magic";
    }
    dprintf (("", "magic at %p", magic));

a610 1
    ohci_soft.sc_vendor[0]='\0'; // flag no svce_PCI yet
d631 1
a631 1
    return 0;
d635 5
d643 3
a645 1

d654 1
d656 2
d721 3
a763 1
    char* v = "";
d797 9
a805 12
                if(ohci_soft.sc_vendor[0]!='\0') // (means svce_PCI has happened)
                {   /* we're here in callback.. so foo we go */
                    dprintf (("", "Registering with USB driver from svcecall\n"));
                    _kernel_oserror *e = register_bus(&ohci_soft,&usb_soft);
                    if(e)
                    {
                        dprintf (("", "Failed to register: %s\n", e->errmess));
                    }
                    else
                    {
                        dprintf (("", "Registering with USB driver from svcecall-done\n"));
                    }
d816 1
a816 8
            if (pci_device == -1)
                strncpy(ohci_soft.sc_vendor, OHCIVendorUnknownRootName, sizeof ohci_soft.sc_vendor-1);
            else
            {
                _swix (PCI_ReadInfo, _INR(0,3), (1<<16), &v, 4, pci_device);
                if (v == 0) v = (char *)" ";
                strncpy (ohci_soft.sc_vendor, v, sizeof ohci_soft.sc_vendor-1);
            }
d821 6
a829 2
#define OREAD(o) ohci_base[o/4]

d831 3
d836 2
d1005 3
d1052 3
@


1.27
log
@Don't build a veneer that points to nothing
The safety struct fillers added in OHCIDriver 0.44 and EHCIDriver 0.30 respectively were being carefully replaced by veneers to nothing. Skip veneer generation is the method isn't implemented.

Version 1.09. Tagged as 'NetBSD-1_09'
@
text
@d623 1
a623 1
        _swix (USBDriver_DeRegisterBus, _IN(0), usb_soft);
@


1.26
log
@Export USBDriver definitions to normal location
USBDriver was not exporting its SWI (and other) definitions to the export directory like other modules do, meaning the host controller drivers all have to reach into this component to get their hands on it.
Makefile:
  Export an assembler header, conversion to C, and SWI definitions from CMHG.
  Rationalise the dev/usb/h/* headers which are exported in addition to those that are pertinent to host controllers (was missing usbdivar, and was exporting unused usbdi_util).
  Export machine/h/bus too.
  As it's unusual for a CModule to output both a library and module and headers, the EXPDIR has been divided into EXPLIBDIR for those things in C:USB, and EXPDIR for the others.
ehcimodule.c/ohcimodule.c:
  Use the exported USBDriver.h

Version 0.98. Tagged as 'NetBSD-0_98'
@
text
@d130 3
@


1.25
log
@Fix to system variable launch & debug build
ohcimodule.c:
 Variable renamed so it builds with debug enabled.
usbmodule.c:
 Tighten up the logic deciding when to launch a USB$<thing> variable, previously it would be launched both for the initial device attach and then again for each interface.
 Remove local <stdlib.h> function prototypes.
 Reindent to 4 spaces to match the rest of the file.
 Fix confusion of ->dv_unit being an int not a pointer.
Submission from Colin Granville. Built, but not tested.

Version 0.95. Tagged as 'NetBSD-0_95'
@
text
@d36 1
a43 1
#include "USBDriver.h"
@


1.24
log
@Deregister IRQ handlers in Service_PreReset
Detail:
  build/c/ehcimodule, build/c/ohcimodule - Deregister IRQ handlers in Service_PreReset. Fixes a hang during reset on OMAP4.
  build/Version - Bump module version numbers for recent changes.
Admin:
  Tested on Pandaboard, Iyonix


Version 0.93. Tagged as 'NetBSD-0_93'
@
text
@d532 1
a532 1
                dprintf(("", "HAL port %d is overcurrent device %d\n", port, hal_oc_device[i])); 
@


1.23
log
@  Revisit Service_PreReset activity
Detail:
  Recent investigations in stalling of OS_Reset showed that with multiple
  driver modules it was possible for the monotonic timer to be turned off
  before the usb system had shut down. Service_PreReset needs a rapid finite
  response to silence the relevant module's hardware and ensure it cannot
  intiiate something that could stall the reset process.
  As a result USBDriver module no longer issues Service_USB_DriverDying in
  its Service_PreReset response; it merely silences itself and removes itself
  from any vectors. This EHCIDriver and OHCIDriver modules now only need to
  silence themselves when receiving Service_PreReset.
Admin:
  tested in iMx6 and iyonix


Version 0.92. Tagged as 'NetBSD-0_92'
@
text
@d740 12
@


1.22
log
@Update to use rationalised power and overcurrent API
OHCIDriver (only) had sketchy support for a HAL based scheme for controlling the port power and monitor overcurrent. However the implementation was limited to supporting the single port required for an embedded product (aka Rhenium in the CVS history). The change makes it follow a model much more akin to the HAL_TimerDevice/HAL_TimerIRQStatus/HAL_TimerIRQClear set of functions.
Version:
  Bumped OHCIDriver and USBDriver version numbers.
ohcimodule.c:
  Use some defines from OsBytes.h.
  Group the debug variables within the OHCI_DEBUG define so they go away in the release case.
  Allow for up to 15 ports to be controlled via the revised HAL API, and pass something other than a hardwired controller of 0 when controlling/monitoring power.
  Enumerate the device numbers for overcurrent monitoring on startup.
  Deal with the possibility of one (or more) of the device numbers being shared interrupts.
  Squash a few trivial compiler warnings.
ohcimodhead.cmhg:
  rename the handler/entry to reflect their use for overcurrent
ohci.c:
  Allow for up to 15 ports to be controlled by passing in the port index where needed.
usb_subr.c/usbdivar.h:
  Remove a RISC OS-ism in datatoggle, to converge with NetBSD a bit.
ehcivar.h/usb_port.h:
  Relocate the overrides for mutex_ functions here since this is the only controller using them. Previously when in "usb_port.h" they would indirectly get dragged in ia the nested include in "usb.h". The could in fact now be implemented using SyncLib, an exercise left to the reader.
usb.h
  Merge some of the device classes and other allocations from NetBSD.

While it's not been possible to test the revised API, due to not having sight of the original platform on which it was implemented, none of the actively maintained HALs currently use the HAL based power and overcurrent scheme anyway, so the new code never gets called. In that respect, it's no more broken then the previous single port-single controller version.

Version 0.89. Tagged as 'NetBSD-0_89'
@
text
@d737 3
@


1.21
log
@Merge in some EHCI fixes from NetBSD. Other minor changes.
Detail:
  build/Version - Bump EHCIDriver version number
  build/c/ehcihal, build/c/ehcimodule, build/c/ohcimodule - Use the HAL USB controller type & flag definitions from Hdr:HALEntries instead of using magic numbers
  build/c/ehcimodule - Avoid double-read of hardware register in debug version of bus_space_read_4(); ensures that we report the value that's actually returned to the driver
  dev/usb/c/ehci - Merge in the following revisions from NetBSD:
  - 1.172, 1.173, 1.178, 1.193 - Support for controllers with embedded transaction translators
  - 1.174 - alloc_sqtd_chain() fix for short packets that end on page boundaries
  - 1.179 - ehci_set_qh_qtd() fixed to terminate alternate next qTD pointer with EHCI_NULL, not 0
  dev/usb/h/ehcireg - Updated to latest NetBSD version (1.34)
  dev/usb/h/ehcivar - Merge in revision 1.38 (ETTF support)
Admin:
  Tested on BB-xM


Version 0.88. Tagged as 'NetBSD-0_88'
@
text
@a14 3
#include "ohcimodhead.h"
#include "USBDriver.h"
#include "swis.h"
d17 1
d19 1
a19 1
#include <limits.h>
d34 1
d42 2
a46 3
#define Event_Disable               0xd
#define Event_Enable                0xe

a54 2
MessagesFD mod_messages;

d68 5
a74 6
void* private_word;

volatile int* ohci_base;

ohci_softc_t ohci_soft;
struct device * usb_soft=NULL;
d83 6
d93 29
d153 3
a155 25
int pci_device = -1;
int hal_device = -1;
int instance = 0;
int device_number;
int unhandled_irqs;
int irqs;
unsigned int irq_min = INT_MAX, irq_max = 0;
unsigned long long irq_tot;
static bool registering=false; /* True/false for whether we're in the middle of registering. Avoids nested registration attempt during ROM init. */

/* Port power controls - only used by HAL devices */

void (*ohci_ppower)(int port, int state);
int  (*ohci_error)(int port); /* Never gets used? */
int  (*ohci_pirq)(int port, int mode);
int hal_pirq_device=-1;                       // device to use for power IRQ, or -1
int hal_error_irq_claimed=0;
typedef enum {P_none,P_on,P_off,P_going_on,P_going_on2,P_ready,P_retry}P_Phase;
typedef struct p_err_chk{
int unit;
P_Phase state;
}p_err_chk;
p_err_chk pchk;

// 0 if OK, 1 if overcurrent
d160 2
a161 2
                       0, port-1,
                       0, EntryNo_HAL_USBPortStatus,
d163 1
d167 1
a167 4
// mode=0 .. turn off irq .. report irq device number
// mode=1 .. turn irq source on and acknowledge the IRQ
// mode=2 .. read irq status and acknowledge the IRQ
static int do_hal_pirq (int port, int mode)
d169 10
a178 7
    int r=0;
    
    _swix(OS_Hardware, _INR(0,1)|_INR(8,9)|_OUT(0),
                       port-1,mode,
                       0, EntryNo_HAL_USBPortIRQ,
                       &r);          
    return r;
d181 1
a181 4
static void do_hal_ppower(int port, int state);

//_kernel_oserror * _hal_powercheck (_kernel_swi_regs * r, void* pw, void* v);
static _kernel_oserror * _hal_powercheck (_kernel_swi_regs * r, void* pw, void* v)
d183 1
a183 32
   p_err_chk *p = (p_err_chk*)v;
   switch(p->state)
   {
      case P_going_on:
               if(do_hal_perror(1))      // power is not yet good
               {
                 p->state=P_going_on2;   // wait a little longer
                 callx_add_callafter(USB_PORT_RESET_DELAY/10, _hal_powercheck, p);
                 break;
               }                         // else fall through
      case P_going_on2:
               if(do_hal_perror(1))      // power is still not good
               {
                 p->state=P_off;
                 do_hal_ppower(p->unit,0);
                 break;
               }                         // else fall through
      case P_ready:
               {
                 _swix (OS_ClaimDeviceVector, _INR(0,4),
                             hal_pirq_device | (1u<<31),
                             usb_irq_port_error_entry, private_word, 0, 0);
                 hal_error_irq_claimed = 1;
                 p->state=P_on;
                 do_hal_pirq(1,1);       // force the irq source on again
               }
               break;
      case P_retry:
               do_hal_ppower(p->unit,1); // try turning on again
               break;         
   }
   return NULL;  
d186 1
a186 1
/* Note OHCI numbers ports from 1, the HAL from 0 */
d189 6
a194 15
  dprintf (("", "HAL port %d power state %d\n", port, state));
  _swix(OS_Hardware, _INR(0,2)|_INR(8,9), 0, port-1, state,
                                        0, EntryNo_HAL_USBPortPower);
  // only allowed to monitor overcurrent status if port is on
  if(hal_pirq_device!=-1)
  {
    if (state && !hal_error_irq_claimed)
    {
      pchk.state=P_going_on;
      pchk.unit = port;
      /* give it a little turn on time before grumbling */
      callx_add_callafter(USB_PORT_RESET_DELAY/10,_hal_powercheck,(void*)&pchk);    // delay monitoring
    }
    else
    if (!state )
d196 25
a220 11
      do_hal_pirq(1,0);
      pchk.state=P_retry;
      pchk.unit = port;
      /* try again after a delay of a second or so */  
      callx_add_callafter(10*(USB_PORT_STARTUP_DELAY/10),
                          _hal_powercheck,(void*)&pchk); // try again 
      if(hal_error_irq_claimed)
      _swix (OS_ReleaseDeviceVector, _INR(0,4),
                             hal_pirq_device | (1u<<31),
                             usb_irq_port_error_entry, private_word, 0, 0);
      hal_error_irq_claimed = 0;
a221 1
  }
d224 1
a224 2
// designed to turn off root port power if overcurrent detected
int usb_irq_port_error_handler(_kernel_swi_regs *r, void *pw)
d226 3
a228 8
    int ret;
    ret=do_hal_pirq(1,2);    // my IRQ?
    if(ret)
    {
     do_hal_pirq(1,0);       // else ack the irq and force irq off..back on
     do_hal_ppower(1,0);     // if irq .. power off please
    }                                       
    return ret?0:1;          // claim.. or pass on
d231 1
a231 3


static int do_ohci_pirq (int port, int mode)
d233 2
a234 2
  return !mode?-1:0;       // not implemented..
}  
d236 1
a236 1
static void do_ohci_ppower(int port, int state)
d238 37
a274 3
  dprintf (("", "OHCI port %d power state %d\n", port, state));
    ohci_base[OHCI_RH_PORT_STATUS(port)/4] =
        state ? UPS_PORT_POWER : UPS_LOW_SPEED;
d277 1
a277 1
static int do_ohci_perror(int port)
d279 2
a280 3
    return ohci_base[OHCI_RH_PORT_STATUS(port)/4] & UPS_OVERCURRENT_INDICATOR
             ? 1 : 0;
}                           
d282 19
a300 3
static void do_dummy_ppower(int port, int state)
{
    /* Do nothing for PCI devices */
a302 1

d372 10
a381 2
    char* v = "";
    _kernel_oserror* e = 0;
d383 1
a383 1
    
d476 2
a480 8
            struct
            {
                int type;
                int flags;
                void *hw;
                int devno;
            } usbinfo;
            size_t usbinfolen;
d484 1
a484 1
                                   0, EntryNo_HAL_USBControllerInfo,
d492 1
a492 1
                if(usbinfo.flags & HALUSBControllerFlag_HAL_USBPortPower)
d494 1
a494 1
                  ohci_ppower = do_hal_ppower;
d498 1
a498 1
                  ohci_ppower = do_ohci_ppower;
d500 1
a500 1
                if(usbinfo.flags & HALUSBControllerFlag_HAL_USBPortStatus)
d502 2
a503 1
                  ohci_error = do_hal_perror;
d507 2
a508 1
                  ohci_error = do_ohci_perror;
a509 12
                if(usbinfo.flags & HALUSBControllerFlag_HAL_USBPortIRQ)
                {
                  ohci_pirq = do_hal_pirq;
                  hal_pirq_device=(ohci_pirq)(1,0); // irq off .. read devicenum
                  hal_error_irq_claimed=0;
                }
                else
                {
                  ohci_pirq = do_ohci_pirq;
                  hal_pirq_device=-1; // not implemented
                }
                (ohci_ppower)(1,0);  // ensure port power off
d521 21
d549 1
d551 1
d554 4
a557 2
        _swix (PCI_ReadInfo, _INR(0,3), (1<<16), &v, 4, pci_device);
        if (v == 0) v = (char *)" ";
d568 1
a568 1
    _swix (OS_ClaimDeviceVector, _INR(0,4),
d570 1
a570 1
        usb_irq_entry, pw, 0, 0);
d572 1
a572 1
        device_number, 0, EntryNo_HAL_IRQEnable);
d584 1
a584 1
    
d593 1
a593 1
        _kernel_osbyte (Event_Enable, Event_VSync, 0);
a635 9
    if(hal_error_irq_claimed)
    {
      (ohci_pirq)(1,0);
      _swix (OS_ReleaseDeviceVector, _INR(0,4),
                             hal_pirq_device | (1u<<31),
                             usb_irq_port_error_entry, private_word, 0, 0);
    }                         


d643 1
a643 1
    _swix (OS_ReleaseDeviceVector, _INR(0,4),
d645 10
a654 1
        usb_irq_entry, pw, 0, 0);
d662 1
a662 1
        _kernel_osbyte (Event_Disable, Event_VSync, 0);
d782 1
a785 1
#ifdef OHCI_DEBUG
a904 1
#endif
d911 1
d958 1
a958 1
        0, EntryNo_HAL_CounterRead, &u2s);
d972 1
a972 1
                                           0, EntryNo_HAL_IRQClear);
d982 1
a982 1
            0, EntryNo_HAL_CounterRead, &u2s1);
d1046 1
a1046 1
_kernel_oserror*
@


1.20
log
@Tidy up exported USBDevFS.h
Detail:
  build/h/USBDevFS - Added extra #ifdef guard to allow USBDevFS.h to be safely included by software that uses the BSD USB headers. Add the DeviceFS_CallDevice codes that USBDriver uses.
  build/h/service - Removed redundant secondary definition of the service call structures which the drivers were using internally
  build/c/ehcihal - Removed redundant #includes
  build/c/ehcidriver, build/c/ohcidriver - Use USBDevFS.h instead of service.h
  build/c/usbmodule - Use USBDevFS.h instead of service.h. Get rid of local DeviceCall definitions and use the ones which are now in USBDevFS.h. Also switched over to using Interface/DevicsFS.h for the main DevicsFS call reason codes, to match the naming convention used by USBDevFS.h (as opposed to the OSLib naming convention that was used previously). Stripped the unused OBSOLETE_SERVICE_CALLS code.
  build/Makefile - Add usbdi_util.h to the header exports
Admin:
  Tested with building OMAP3, Tungsten & BCM2835 ROMs
  Builds to binary-identical modules as previous version.


Version 0.85. Tagged as 'NetBSD-0_85'
@
text
@d465 1
a465 1
            if (!e && (usbinfolen == sizeof(usbinfo)) && usbinfo.type == 0)
d471 1
a471 1
                if(usbinfo.flags & 1)
d479 1
a479 1
                if(usbinfo.flags & 2)
d487 1
a487 1
                if(usbinfo.flags & 4)
@


1.19
log
@Add re-entrancy check to USBDriver registration
Detail:
  build/c/ehcimodule, build/c/ohcimodule - Added a re-entrancy check to USBDriver registration, to avoid shenanigans if we receive "USBDriver has started" service calls while in the middle of registering
  build/Version - Bump EHCIDriver & OHCIDriver versions & dates
Admin:
  Tested on BB-xM
  Doesn't fix any known EHCIDriver/OHCIDriver-related issues, but is the same fix as was made to DWCDriver after the above-mentioned problem was found to be the cause of a hang on boot in recent Pi ROMs


Version 0.77. Tagged as 'NetBSD-0_77'
@
text
@d44 1
a44 1
#include "service.h"
d704 1
a704 1
        case Service_USBDriver_Starting:
d722 1
a722 1
        case Service_USBDriver_Dying:
@


1.18
log
@Fix null pointer dereferences. Add protection against DeviceFS xfers being multiply inserted into their pipes xfer queue.
Detail:
  build/Version - Increased version numbers
  build/c/ehcimodule, build/c/ohcimodule - Fixed null pointer dereferences in debug code
  build/c/port, build/s/triggercbs - Fix debug code in tsleep() using hardcoded IRQsema ptr. Now requests the right pointer from build/s/triggercbs.
  build/c/usbmodule - Fix null pointer deferences in debug code and MonitorTX/MonitorRX handlers. Add xfer_busy and delayed_read flags to devstream struct in order to track whether the xfer associated with the stream is busy or not. Previously if the TxWakeUp/RxWakeUp device calls were made on a stream which already had an active xfer, the xfer would end up being inserted in the USB pipes xfer queue twice, creating a circular reference, resulting in (at the least) infinite loops in usbd_dump_queue() when debugging is enabled. Now, in the case of reads, a second read will automatically be issued once the first completes, while in the case of writes, the write request will simply be ignored. This isn't a proper fix for all the shortcomings of the DeviceFS interface, but at least the code is now a little bit safer.
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.72. Tagged as 'NetBSD-0_72'
@
text
@d131 1
d295 1
d298 1
d705 1
a705 1
            if (usb_soft == NULL)
@


1.17
log
@Make RHENIUM build switch go away. Misc housekeeping
Detail:
  build/Makefile, build/!MkDebug,fd7 - Debug versions of the modules can now be built just by passing "DEBUG=TRUE" to amu
  build/!MkRhenium,fd7 - Deleted obsolete file
  build/Version - Increased version numbers
  build/c/ehcihal, build/c/ehcimodule, build/c/ohcimodule - Only accept USB controllers if HAL_USBControllerInfo says the struct size is an exact match with what we expect. Rework USB controller enumeration to allow modules to properly support both PCI and HAL controllers being available on the same machine, and without RHENIUM switch (module sources only).
  build/c/ehcimodule - Get rid of remaining RHENIUM bits; RHENIUM flag no longer needed for 32bit wide register reads/writes to be supported
  build/c/ohcimodule, build/cmhg/ohcimodhead, dev/usb/c/ohci - Get rid of remaining RHENIUM bits; RHENIUM flag no longer needed for HAL port power controls to be supported.
  build/c/usbhal, build/c/usbmodule, dev/usb/c/uhub, dev/usb/h/usb_port - Get rid of empty riscos_failed_device function
  build/s/call_veneer, build/s/triggercbs - Use Entry/EXIT macros to avoid single-reg LDM/STM performance warnings. Convert tabs to spaces.
  dev/usb/h/usb - Get rid of RHENIUM switch on USB_PORT_RESET_DELAY. Now always uses non-RHENIUM value of 100ms.
Admin:
  Tested on rev A2 BB-xM, Iyonix, Raspberry Pi


Version 0.71. Tagged as 'NetBSD-0_71'
@
text
@d526 2
a527 1
    usbdebug = ohcidebug = atoi (getenv ("ohcidebug"));
@


1.16
log
@Fix null pointer access in OHCIDriver
Detail:
  build/c/ohcimodule - Not all PCI_ReadInfo calls were checking for null pointers afterwards, leading to strncpy being called with a null source
  build/Version - Updated OCHIDriver version number
Admin:
  Tested in Iyonix ROM softload


Version 0.61. Tagged as 'NetBSD-0_61'
@
text
@d123 2
a124 1
int pci_device = 0;
d132 7
a138 6
#ifdef RHENIUM
void (*ohci_ppower)(int port, int state);  //(used with rhenium)
int  (*ohci_error)(int port);              //(used with rhenium)
int  (*ohci_pirq)(int port, int mode);     //(used with rhenium)
int hal_pirq_device;                       // device to use for power IRQ, or -1
int hal_error_irq_claimed;
d147 1
a147 1
int do_hal_perror(int port)
d160 1
a160 1
int do_hal_pirq (int port, int mode)
d171 1
a171 1
void do_hal_ppower(int port, int state);
d174 1
a174 1
_kernel_oserror * _hal_powercheck (_kernel_swi_regs * r, void* pw, void* v)
d211 1
a211 1
void do_hal_ppower(int port, int state)
d259 1
a259 1
int do_ohci_pirq (int port, int mode)
d264 1
a264 1
void do_ohci_ppower(int port, int state)
d271 1
a271 1
int do_ohci_perror(int port)
d277 4
a281 1
#endif        /* RHENIUM */
a309 1
#ifdef RHENIUM
a312 1
//        return NULL;
a315 1
#endif  /* RHENIUM */
a318 2
//            [sizeof ohci_soft.sc_vendor - 1] = '\0';
#ifdef RHENIUM
a319 1
#endif  /* RHENIUM */
d332 4
a335 4
    /* allow enough space for name, % and number, then space, and
       another number */
    char name[sizeof Module_Title + 1 + 12 + 1 + 12];
    sprintf (name, Module_Title"%%%d %d", instance + 1, pci_device);
a352 1
//    char tmp[16];
d384 8
a391 3
        char* endptr;
        pci_device = (int) strtol (cmd_tail, &endptr, 0);
        if (endptr == cmd_tail)
a396 1
#ifdef STANDALONE
d399 2
d403 1
a404 1
#endif
d414 3
a416 1
    do {
d422 27
a448 3
#ifdef RHENIUM
       if (e || pci_device == 0)
       {
d459 1
a459 1
                                   instance, &usbinfo, sizeof usbinfo,
d462 1
a462 1
            if (!e && (usbinfolen >= sizeof(usbinfo)) && usbinfo.type == 0)
d464 1
a494 1
                pci_device = -1;
d497 5
a501 15
            else
                pci_device = 0; // Explicitly set pci_device to the fail state else we'll start infinite instantiations if the PCI module isn't present
        }
#endif  /* RHENIUM */
        if (e) goto error;
    } while (0);//pci_device == 2 || pci_device == 3);


    /* if there were no more OHCI controllers, then return an error.  This
       will be thrown away by the callback above */

    if (pci_device == 0)
    {
        e = (_kernel_oserror*) "\0\0\0\0No OHCI devices found";
        goto error;
d504 2
a505 4
    dprintf (("", "Found OHCI controller on device %d\n", pci_device));


#ifdef   RHENIUM
a506 23
    if (pci_device != -1)
    {
#endif  /* RHENIUM */

        /* now establish our interrupt and address */

        e = _swix(PCI_ReadInfo, _INR(0,3),
            PCI_ReadInfo_IntDeviceVector,
            &device_number,
            sizeof device_number,
            pci_device);
        if (e) goto error;

        dprintf (("Main_0", "interrupt device %d\n", device_number));

        e = _swix(PCI_HardwareAddress, _INR(0,1)|_IN(3)|_OUT(4),
            0, 0, pci_device, &ohci_base);
        if (e) goto error;

        dprintf (("Main_0", "hardware address %p\n", ohci_base));
#ifdef   RHENIUM
     }
#endif  /* RHENIUM */
a512 1
#ifdef   RHENIUM
a516 1
#endif  /* RHENIUM */
a519 2
//            [sizeof ohci_soft.sc_vendor - 1] = '\0';
#ifdef   RHENIUM
a520 1
#endif  /* RHENIUM */
a532 3
#ifdef   RHENIUM
    
#endif  /* RHENIUM */
a595 1
#ifdef RHENIUM
a602 1
#endif /*RHENIUM*/
a724 1
#ifdef   RHENIUM
a728 1
#endif  /* RHENIUM */
a731 2
//                    [sizeof ohci_soft.sc_vendor - 1] = '\0';
#ifdef   RHENIUM
a732 1
#endif  /* RHENIUM */
a928 1
#ifdef   RHENIUM
a932 1
#endif  /* RHENIUM */
a961 1
//    _swix (OS_ReadC, 0);
a972 2
//    dprintf (("", "about to read from %x\n", ohci_base + o/4));
//    return 0;
@


1.15
log
@Add the ability to build the USB drivers as HAL-compatible static libraries
Detail:
  build/Makefile, build/OBJEHCIDriver, build/OBJOHCIDriver, build/OBJUSBDriver - Modified makefiles to build the HAL libs during the export libs phase
  build/!MkHAL,fd7 - Handy script for building the HAL libs
  build/Hdr/usbhal - Header containing definitions for the assembler code. Also gets exported so that HALs know how much workspace to reserve.
  build/c/usbhal - HAL version of usbmodule.c & port.c. Also contains the keyboard scan code, adapted from the code in the Tungsten HAL.
  build/s/porthal - Assembler versions of some port.c routines that were easier to do in assembler than C
  build/s/halheap - OS_Heap code that's been adapted for use in the HAL. Could easily be changed into a standalone library instead of being part of the HAL USB libs. Supports memory-efficient allocation of aligned blocks.
  build/c/ehcihal - HAL version of ehcimodule.c. Currently only supports EHCI controllers exposed via HAL_USBControllerInfo (i.e. no PCI support)
  build/c/ehcimodule, build/c/ohcimodule, build/c/port - Moved riscos_irq_clear into port.c. Removed unused microtime() function.
  build/c/usbmouse - Strip out some debug-related code in non-debug builds
  build/Version - Updated version numbers
  dev/usb/c/ehci, dev/usb/h/ehcivar - Adapted to add support for the HAL build. Apart from the base changes, the code has also been tweaked to significantly reduce the amount of memory used at runtime by the HAL version of the driver.
  dev/usb/c/hid, dev/usb/c/uhub, dev/usb/c/usb, dev/usb/c/usb_quirks, dev/usb/c/usb_subr, dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/c/usbroothub_subr - Changes to support HAL builds. Mainly disabling bits that won't work in the HAL or disabling bits for RISC OS in general if they weren't being used in the first place.
  dev/usb/c/ohci, dev/usb/h/ohcivar - Basic changes to support HAL builds. However HAL OHCI support is still incomplete.
  dev/usb/h/usb_port - Added support for the HAL build. Also tweaked logprintf definition to get rid of logprintf calls entirely in non-debug builds.
  dev/usb/h/usbdivar - Added support for the HAL build.
  dev/usb/h/usbhal - New header used by the HAL build. Gets included by every C file to ensure the compiler doesn't use sb, and contains structs/macros to allow access to the shared workspace.
Admin:
  HAL & non-HAL builds tested on rev C2 BB, rev A2 BB-xM, rev C1 TouchBook.
  Non-HAL builds tested with Iyonix ROM softload.
  Needs latest Kernel source for OSEntries.h export.


Version 0.59. Tagged as 'NetBSD-0_59'
@
text
@d297 1
a297 1
    char* v;
d525 1
d747 1
@


1.14
log
@Update EHCI driver to NetBSD latest (as of 10/07/2010), improve DeviceFS interface
Detail:
  EHCI driver update:
    dev/usb/c/ehci - Updated to latest NetBSD version, except for revisions 1.134 and 1.135 which are too invasive to merge in without updating the rest of the USB stack. This new version brings lots of bug fixes, and adds (untested on RISC OS) support for EHCI isochronous transfers.
    dev/usb/h/ehcivar - Updated to latest NetBSD version, except for the sc_bus splitting that was held back from the ehci.c update
    dev/usb/h/usb, dev/usb/h/usbdi, dev/usb/usbdivar - partial update to latest as required/possible
    dev/usb/c/usb_quirks, dev/usb/h/ehcireg, dev/usb/h/usb_mem, dev/usb/h/usb_quirks, dev/usb/h/usbhid, dev/usb/usbdevs, dev/usb/devlist2h.awk, dev/wscons/h/wsconsio, dev/wscons/h/wsmousevar - Updated to latest NetBSD versions
    dev/usb/c/usbroothub_subr, dev/usb/h/usbroothub_subr - New files brought in from NetBSD sources for use with new EHCI driver
    build/objehcidriver - Added usbroorhub_subr to EHCI driver
    dev/usb/h/usb_port - Added extra dummy functions as required by new EHCI driver
    dev/build/c/port - Added extra parameter to callout_init as required by new EHCI driver
  DeviceFS improvements:
    build/c/usbmodule - Added DeviceFSCallDevice_GetHandles2 as a replacement for Thomas Milius's backwards-incompatible GetHandles changes. Added DeviceFSCallDevice_GetSetOptions call to control RX padding and TX force-short-xfer features. These features can also be controlled at endpoint creation time by new fields in the filename. Also fixed packet padding to not fill the buffer with garbage or potentially crash when the padded area is more than one packet in length.
  New bus registration API:
    Changes made to the data structures that are shared between the modules means that new checks are needed to ensure USB modules with incompatible APIs are not used with one another.
    build/h/usbdivar - Since this seems to be the file containing the main structures that are shared, it now has a #define at the top indicating the first version of the USBDriver module that implemented the data structures within. This version number is used to check that the driver modules are compatible.
    build/cmhg/usbmodhead, build/h/usbdriver, build/c/usbmodule - Add a new SWI, USBDriver_Version, to return the version number of the USBDriver module. Used for both intra-stack API version checks and can be useful for external code that wants to query DeviceFS feature availability.
    build/c/usbmodule, build/c/ehcimodule, build/c/ohcimodule - Updated USBDriver_RegisterBus SWI and the code that calls it to pass the API version number (as defined in usbdivar.h) to USBDriver when attempting to reigster the bus. USBDriver then ensures the version matches that of itself, and if not refuses to allow the bus to register. EHCI & OHCI modules also check that USBDriver is new enough to implement this behaviour via the USBDriver_Version SWI.
  And finally:
    build/version - Incremented module version numbers.
    build/doc/usb - Updated with details of new features
Admin:
  Tested in ROM softload on Iyonix & beagleboard. Beagleboard hub issues seem to be resolved, and there are no new bugs that I can see.


Version 0.52. Tagged as 'NetBSD-0_52'
@
text
@d515 1
a1055 5

void riscos_irqclear()
{
    _swix(OS_Hardware, _IN(0)|_INR(8,9), device_number, 0, EntryNo_HAL_IRQClear);
}
@


1.13
log
@Add workaround for incorrect sizeof(usb_status_t), disable debug_set_stamp_debug(TRUE) to fix interrupt issue
Detail:
  build/c/ehcimodule, build/c/ohcimodule, build/c/usbmodule - Make sure that timestamped debug messages aren't used, as they appear to cause interrupts to be briefly enabled, which causes all kinds of problems in sensitive bits of the code.
  dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/h/usb - Because DISABLE_PACKED is being used to compile the USB drivers, sizeof(usb_status_t) was being calculated as 4 bytes instead of 2. Somehow this works fine with the EHCI driver (and presumably the OHCI driver), but it was causing problems with the MUSBDriver, so a hardcoded size of 2 is now used.
Admin:
  Tested on rev C2 beagleboard.


Version 0.48. Tagged as 'NetBSD-0_48'
@
text
@d79 1
a79 1
struct device * usb_soft;
d278 16
a293 11
//_kernel_oserror* bus_register (_kernel_swi_regs* r, void* pw, void* h)
//{
//    /* register with the usbdriver module if it's already resident */
//    dprintf (("", "Registering with USB driver\n"));
//    _swix (USBDriver_RegisterBus, _IN(0)|_OUT(0),
//            &ohci_soft, &usb_soft);
//    dprintf (("", "Registering with USB driver-done\n"));
//
//    return NULL;
//}
//
d323 9
a331 3
    _swix (USBDriver_RegisterBus, _IN(0)|_OUT(0),
            &ohci_soft, &usb_soft);
    dprintf (("", "Init-Registering with USB driver-done\n"));
d718 10
a727 4
             dprintf (("", "Registering with USB driver from svcecall \n"));
                   _swix (USBDriver_RegisterBus, _IN(0)|_OUT(0),
                           &ohci_soft, &usb_soft);
             dprintf (("", "Registering with USB driver from svcecall-done\n"));
@


1.12
log
@Add support for HAL enumerated USB EHCI controllers, use HAL_IRQClear when clearing EHCI/OHCI controller interrupts
Detail:
  * HAL enumeration of EHCI controllers is performed in the same manner as for OHCI, and protected by #ifdef RHENIUM. HAL_USBControllerInfo must return with the usbinfo type field set to 1 to indicate EHCI.
  * HAL_IRQClear is now called by the EHCI & OHCI modules after clearing the interrupt flag in the USB controller, to allow the HAL to reset the interrupt controller if required (e.g. for OMAP3)
  * EHCI module (for HAL EHCI controllers) now has the option of forcing all EHCI register access to be 32bit size & alignment (requirement is indicated in OMAP3 TRM, although USB did seem to function fine without)
  build/c/ehcimodule - Add enumeration of HAL USB controllers. Add support for forcing all EHCI register access to be 32bit size & alignment. Add riscos_irqclear() implementation. Guard against unexpected behaviour if PCI module isn't present.
  build/c/ohcimodule - Add riscos_irqclear() implementation. Guard against unexpected behaviour if PCI module isn't present.
  dev/usb/c/ehci, dev/usb/c/ohci - call riscos_irqclear() when appropriate
  dev/usb/h/usb_port - riscos_irqclear() prototype
Admin:
  Tested on rev C2 beagleboard. Untested on Iyonix, but should be fine.


Version 0.47. Tagged as 'NetBSD-0_47'
@
text
@d354 2
a355 1
    debug_set_stamp_debug (TRUE);
@


1.11
log
@	several changes and nullpointer bug fixes
Detail:
	Includes several bug fixes and null pointer traps.
	Rhenium version reviewed and reset should be improved.
Admin:
	Tested in rhenium desktop build and iyonix build at castle
   	Castle added IP


Version 0.40. Tagged as 'NetBSD-0_40'
@
text
@d455 2
d1037 5
@


1.10
log
@       improved module startup sequence independance, and added
       service-prereset to
       the ehcimodule. modules in beta test in field
Detail:
Admin:
       castle added ip.  still to be tested on rhenium


Version 0.32. Tagged as 'NetBSD-0_32'
@
text
@a131 1
#define REPOWER_DELAY               10
d181 1
a181 1
                 callx_add_callafter(2, _hal_powercheck, p);
d211 1
d221 2
a222 1
      callx_add_callafter(2,_hal_powercheck,(void*)&pchk);    // delay monitoring
d230 2
a231 1
      callx_add_callafter(100*REPOWER_DELAY,
d264 1
@


1.9
log
@       change to OHCIModule to pay heed to number of OHCI i/f reported
       by HAL (in Rhenium).. various other small adjustments to improve
       softloadability, both in OHCI and EHCI drivers.
Detail:
Admin:
    tested on iyonix and on rhenium
    castle added IP


Version 0.30. Tagged as 'NetBSD-0_30'
@
text
@d275 11
a285 11

_kernel_oserror* bus_register (_kernel_swi_regs* r, void* pw, void* h)
{
    /* register with the usbdriver module if it's already resident */
    dprintf (("Main_0", "Registering with USB driver\n"));
    _swix (USBDriver_RegisterBus, _IN(0)|_OUT(0),
            &ohci_soft, &usb_soft);

    return NULL;
}

d314 4
a317 1
    bus_register(NULL,NULL,NULL);
d323 1
a323 1
    dprintf (("Main_0", "Trying to start %s\n", name));
d467 1
a467 1
    dprintf (("Main_0", "Found OHCI controller on device %d\n", pci_device));
d685 9
d700 5
a704 3
                {
                dprintf (("Main_0", "Registering with USB driver from svcecall \n"));
                    callx_add_callback (bus_register, 0);
a729 9
        break;
    case Service_PreReset:
        /* reset the controller */
        ohci_base[OHCI_COMMAND_STATUS / 4] = OHCI_HCR;
        magic = (int*) ohci_base[OHCI_COMMAND_STATUS]; // flush the write
        while (ohci_base[OHCI_COMMAND_STATUS / 4] & OHCI_HCR);
        ohci_base[OHCI_CONTROL / 4] = OHCI_HCFS_RESET;

        magic = (int*) ohci_base[OHCI_CONTROL]; // flush the write
@


1.8
log
@  Extensive changes and bug fixes to usb and ohci ..
  'blocked' several holes that could cause freezes with awkward
  usb devices.  Added latest changes from Dan Ellis too , especially for USB2
Detail:
 many
Admin:
 Tested in ROM at Castle, and beta tested with users


Version 0.28. Tagged as 'NetBSD-0_28'
@
text
@d300 1
a300 1
        strcpy (ohci_soft.sc_vendor, OHCIVendorUnknownRootName);
d308 2
a309 2
        strncpy (ohci_soft.sc_vendor, v, sizeof ohci_soft.sc_vendor)
            [sizeof ohci_soft.sc_vendor - 1] = '\0';
d337 1
a337 1
    char tmp[16];
d411 1
a411 1
                                   0, &usbinfo, sizeof usbinfo,
d499 1
a499 1
        strcpy(ohci_soft.sc_vendor, OHCIVendorUnknownRootName);
d504 2
a505 2
        strncpy (ohci_soft.sc_vendor, v, sizeof ohci_soft.sc_vendor)
            [sizeof ohci_soft.sc_vendor - 1] = '\0';
d703 1
a703 1
                strcpy(ohci_soft.sc_vendor, OHCIVendorUnknownRootName);
d708 2
a709 2
                strncpy (ohci_soft.sc_vendor, v, sizeof ohci_soft.sc_vendor)
                    [sizeof ohci_soft.sc_vendor - 1] = '\0';
@


1.7
log
@Latest stuff from John - mainly Rhenium improvements.

Version 0.26. Tagged as 'NetBSD-0_26'
@
text
@d70 2
d275 11
d301 1
a301 1
        return NULL;
d307 1
a307 1
        if (v == 0) v = (char *)"";
d313 2
a326 1

d330 3
d337 2
a338 1

d342 4
a345 1
    debug_initialise ("OHCIDriver", 0, 0);
d534 2
a535 7


    /* register with the usbdriver module if it's already resident */
    dprintf (("Main_0", "Registering with USB driver\n"));
    _swix (USBDriver_RegisterBus, _IN(0)|_OUT(0),
            &ohci_soft, &usb_soft);

d551 1
d687 5
a691 3
                dprintf (("Main_0", "Registering with USB driver\n"));
                _swix (USBDriver_RegisterBus, _IN(0)|_OUT(0),
                    &ohci_soft, &usb_soft);
@


1.6
log
@  New versions from John.
Detail:
  * All modules will now rmkill/rmload more reliably
  * Keyboard driver disables kernel debounce on new enough kernels, needed
    for many PS2-USB adaptors, bar code scanners etc
  * Mouse driver will scroll wheel scroll any windows that do respond to
    scroll events, otherwise it issues PointerReason_WheelChange (9) to an
    external WimpScroll module
  * Several bugs and an interrupt hole resolved
Admin:
  Tested at Framlingham.

Version 0.25. Tagged as 'NetBSD-0_25'
@
text
@d55 2
d129 144
d284 16
a299 4
    _swix (PCI_ReadInfo, _INR(0,3), (1<<16), &v, 4, pci_device);
    if (v == 0) v = (char *)"";
    strncpy (ohci_soft.sc_vendor, v, sizeof ohci_soft.sc_vendor)
        [sizeof ohci_soft.sc_vendor - 1] = '\0';
d377 53
d446 1
a446 1
    /* now establish our interrupt and address */
d448 3
a450 12
    e = _swix(PCI_ReadInfo, _INR(0,3),
        PCI_ReadInfo_IntDeviceVector,
        &device_number,
        sizeof device_number,
        pci_device);
    if (e) goto error;

    dprintf (("Main_0", "interrupt device %d\n", device_number));

    e = _swix(PCI_HardwareAddress, _INR(0,1)|_IN(3)|_OUT(4),
        0, 0, pci_device, &ohci_base);
    if (e) goto error;
d452 1
a452 1
    dprintf (("Main_0", "hardware address %p\n", ohci_base));
d454 17
a473 3
    _swix (PCI_ReadInfo, _INR(0,3), (1<<16), &v, 4, pci_device);
    strncpy (ohci_soft.sc_vendor, v, sizeof ohci_soft.sc_vendor)
        [sizeof ohci_soft.sc_vendor - 1] = '\0';
d475 9
a483 2
    _swix (PCI_ReadInfo, _INR(0,3), (1<<16), &v, 4, pci_device);
    strncpy (ohci_soft.sc_vendor, v, sizeof ohci_soft.sc_vendor)
d485 4
a494 1

d496 2
a497 1
        device_number| (1u<<31), usb_irq_entry, pw, 0, 0);
d500 3
d520 1
a520 1
    dprintf (("Main_0", "Finished module initialisation\n"));
d570 11
d589 2
a590 1
        device_number | (1u<<31), usb_irq_entry, pw, 0, 0);
d682 12
a693 3
            _swix (PCI_ReadInfo, _INR(0,3), (1<<16), &v, 4, pci_device);
            strncpy (ohci_soft.sc_vendor, v, sizeof ohci_soft.sc_vendor)
                [sizeof ohci_soft.sc_vendor - 1] = '\0';
d898 7
a904 1
    ret = !ohci_intr (&ohci_soft);
@


1.5
log
@Selects per-port power control for all ports before starting BSD code.
Fix suggested by Dan Ellis.

Version 0.24. Tagged as 'NetBSD-0_24'
@
text
@d167 1
a167 1
    debug_set_device(TML_OUTPUT);
a279 3
    /* enable per-port power control on all ports */
    ohci_base[OHCI_RH_DESCRIPTOR_B / 4] = 0xFFFF0000;

d435 2
a436 1
            _swix (USBDriver_DeRegisterBus, _IN(0), usb_soft);
d660 1
a660 1
        if (ohcidebug > 1) dprintf(("", "irq for: %d nsecs\n", t));
@


1.4
log
@Merge of Dan Ellis's USB2 sources.

Version 0.22. Tagged as 'NetBSD-0_22'
@
text
@d280 3
@


1.3
log
@Removed a debugging delay from dev.c.ohci which was breaking everything.
Null vendor names no longer say oflaofla.

Version 0.14. Tagged as 'NetBSD-0_14'
@
text
@d82 1
d255 3
a392 10

        /* claim service call if lookup was successful */
        if (NULL == _swix (MessageTrans_Lookup, _INR(0,2)|_OUT(2),
            &mod_messages,
            tok,
            0,
            r->r + 2))
            {
            r->r[1] = 0;
            }
a393 1

d395 1
a395 20
        _swix (PCI_ReadInfo, _INR(0,3),
        PCI_ReadInfo_ClassCode,
        &p,
        sizeof p,
        r->r[3]);
        if (p == 0x0C0310)
           {
           /* Only lookup a vendor id if it's an OHCI controller */
           sprintf (tok, "V%04X", r->r[0]);

           /* claim service call if lookup was successful */
           if (NULL == _swix (MessageTrans_Lookup, _INR(0,2)|_OUT(2),
               &mod_messages,
               tok,
               0,
               r->r + 2))
               {
               r->r[1] = 0;
               }
           }
a396 1

d400 14
d659 1
a659 1
        if (ohcidebug > 15) dprintf(("", "irq for: %d nsecs", t));
d721 28
@


1.3.2.1
log
@Added support for HAL USB devices.
Attempted interrupt hole fix.

Version 0.21, 1.22.2.1. Tagged as 'NetBSD-0_21-1_22_2_1'
@
text
@d137 4
a140 12
    if (pci_device == -1)
    {
        strcpy (ohci_soft.sc_vendor, "Unknown");
        return NULL;
    }
    else
    {
        _swix (PCI_ReadInfo, _INR(0,3), (1<<16), &v, 4, pci_device);
        if (v == 0) v = (char *)"";
        strncpy (ohci_soft.sc_vendor, v, sizeof ohci_soft.sc_vendor)
            [sizeof ohci_soft.sc_vendor - 1] = '\0';
    }
a217 20
        if (e || pci_device == 0) {
            struct
            {
                int type;
                int flags;
                void *hw;
                int devno;
            } usbinfo;
            size_t usbinfolen;

            e = _swix(OS_Hardware, _INR(0,2)|_INR(8,9)|_OUT(0),
                                   0, &usbinfo, sizeof usbinfo,
                                   0, EntryNo_HAL_USBControllerInfo,
                                   &usbinfolen);
            if (!e && usbinfolen >= sizeof usbinfo) {
                device_number = usbinfo.devno;
                ohci_base = usbinfo.hw;
                pci_device = -1;
            }
        }
d234 1
a234 12
    if (pci_device != -1)
    {
        /* now establish our interrupt and address */

        e = _swix(PCI_ReadInfo, _INR(0,3),
            PCI_ReadInfo_IntDeviceVector,
            &device_number,
            sizeof device_number,
            pci_device);
        if (e) goto error;

        dprintf (("Main_0", "interrupt device %d\n", device_number));
d236 12
a247 3
        e = _swix(PCI_HardwareAddress, _INR(0,1)|_IN(3)|_OUT(4),
            0, 0, pci_device, &ohci_base);
        if (e) goto error;
d249 1
a249 2
        dprintf (("Main_0", "hardware address %p\n", ohci_base));
    }
d255 3
a257 8
    if (pci_device == -1)
        strcpy(ohci_soft.sc_vendor, "Unknown");
    else
    {
        _swix (PCI_ReadInfo, _INR(0,3), (1<<16), &v, 4, pci_device);
        strncpy (ohci_soft.sc_vendor, v, sizeof ohci_soft.sc_vendor)
                [sizeof ohci_soft.sc_vendor - 1] = '\0';
    }
d452 3
a454 8
            if (pci_device == -1)
                strcpy(ohci_soft.sc_vendor, "Unknown");
            else
            {
                _swix (PCI_ReadInfo, _INR(0,3), (1<<16), &v, 4, pci_device);
                strncpy (ohci_soft.sc_vendor, v, sizeof ohci_soft.sc_vendor)
                    [sizeof ohci_soft.sc_vendor - 1] = '\0';
            }
a659 4

    // the chip requires its interrupts cleared
    _swix(OS_Hardware, _IN(0)|_INR(8,9), device_number,
                                         0, EntryNo_HAL_IRQClear);
@


1.2
log
@Fix to extern char * thingy which was causing hardware vector 0 to be
scrambled.
Makefile now zaps the linked directory too.

Version 0.07. Tagged as 'NetBSD-0_07'
@
text
@d138 1
d142 2
a143 2
    // allow enough space for name, % and number, then space, and
    // another number
d166 1
a166 1
    debug_set_device(DEBUGIT_OUTPUT);
d257 1
a257 1
        [sizeof ohci_soft.sc_vendor - 1] = '\0';
@


1.1
log
@Import of USB driver suitable for generic PCI based OHCI controllers.
Correction of spelling of busses to buses (noun plural).
OHCIdriver only responds to PCI service call to lookup vendor name when
the device is of class OHCI controller.

Version 0.01. Tagged as 'NetBSD-0_01'
@
text
@d83 1
a83 1
extern char* panic_string;
@


head	1.62;
access;
symbols
	NetBSD-1_19:1.62
	NetBSD-1_18:1.61
	NetBSD-1_17:1.60
	NetBSD-1_16:1.59
	NetBSD-1_15:1.59
	NetBSD-1_14:1.59
	NetBSD-1_13:1.59
	NetBSD-1_12:1.59
	NetBSD-1_09-1:1.59
	NetBSD-1_11:1.58
	NetBSD-1_10:1.58
	NetBSD-1_09:1.57
	NetBSD-1_08:1.57
	NetBSD-1_07:1.57
	NetBSD-1_06:1.56
	NetBSD-1_05:1.56
	NetBSD-1_04:1.56
	NetBSD-1_03:1.55
	NetBSD-1_02:1.54
	NetBSD-1_01:1.54
	NetBSD-1_00:1.53
	NetBSD-0_99:1.52
	NetBSD-0_98:1.51
	NetBSD-0_97:1.51
	NetBSD-0_96:1.51
	NetBSD-0_95:1.51
	NetBSD-0_94:1.50
	NetBSD-0_93:1.50
	NetBSD-0_92:1.50
	NetBSD-0_91:1.49
	NetBSD-0_90:1.49
	NetBSD-0_89:1.49
	NetBSD-0_88:1.49
	NetBSD-0_87:1.49
	NetBSD-0_86:1.48
	NetBSD-0_85:1.48
	NetBSD-0_84:1.47
	NetBSD-0_83:1.47
	NetBSD-0_82:1.47
	NetBSD-0_81:1.47
	NetBSD-0_80:1.47
	NetBSD-0_79:1.46
	NetBSD-0_78:1.45
	NetBSD-0_77:1.44
	NetBSD-0_76:1.44
	NetBSD-0_75:1.44
	NetBSD-0_74:1.43
	NetBSD-0_73:1.42
	NetBSD-0_72:1.41
	NetBSD-0_71:1.40
	NetBSD-0_70:1.39
	NetBSD-0_69:1.39
	NetBSD-0_68:1.38
	NetBSD-0_67:1.37
	NetBSD-0_66:1.37
	NetBSD-0_65:1.37
	NetBSD-0_64:1.37
	NetBSD-0_63:1.37
	NetBSD-0_62:1.37
	NetBSD-0_61:1.37
	NetBSD-0_60:1.37
	NetBSD-0_59:1.37
	NetBSD-0_58:1.37
	NetBSD-0_57:1.37
	NetBSD-0_56:1.36
	NetBSD-0_55:1.35
	NetBSD-0_54:1.34
	NetBSD-0_53:1.33
	NetBSD-0_52:1.33
	NetBSD-0_51:1.32
	NetBSD-0_50:1.31
	NetBSD-0_49:1.31
	NetBSD-0_48:1.31
	NetBSD-0_47:1.30
	NetBSD-0_46:1.30
	NetBSD-0_45:1.30
	NetBSD-0_44:1.29
	NetBSD-0_43:1.28
	NetBSD-0_42:1.27
	NetBSD-0_41:1.26
	NetBSD-0_40:1.25
	NetBSD-0_39:1.24
	NetBSD-0_38:1.24
	NetBSD-0_37:1.24
	NetBSD-0_36:1.23
	NetBSD-0_35:1.23
	NetBSD-0_34:1.22
	NetBSD-0_33:1.22
	NetBSD-0_32:1.21
	NetBSD-0_31:1.21
	NetBSD-0_30:1.20
	NetBSD-0_29:1.20
	RO_5_07:1.20
	NetBSD-0_28:1.20
	NetBSD-0_27:1.19
	NetBSD-0_26:1.18
	NetBSD-0_25:1.17
	NetBSD-0_24:1.16
	NetBSD-0_23:1.16
	NetBSD-0_21-1_22_2_1:1.14.2.1
	NetBSD-0_22:1.15
	USB1:1.14.0.2
	NetBSD-0_21:1.14
	NetBSD-0_20:1.14
	NetBSD-0_19:1.13
	NetBSD-0_18:1.13
	NetBSD-0_17:1.12
	NetBSD-0_16:1.11
	NetBSD-0_15:1.10
	NetBSD-0_14:1.10
	NetBSD-0_13:1.9
	NetBSD-0_12:1.9
	NetBSD-0_11:1.8
	NetBSD-0_10:1.7
	NetBSD-0_09:1.6
	NetBSD-0_08:1.5
	NetBSD-0_07:1.4
	NetBSD-0_06:1.4
	NetBSD-0_05:1.4
	NetBSD-0_04:1.3
	NetBSD-0_03:1.2
	NetBSD-0_02:1.1
	NetBSD-0_01:1.1;
locks; strict;
comment	@# @;


1.62
date	2017.03.18.09.16.15;	author rool;	state Exp;
branches;
next	1.61;
commitid	2l0r7Njg1TXdP0Kz;

1.61
date	2016.12.17.10.12.57;	author rool;	state Exp;
branches;
next	1.60;
commitid	yws6HYEy6os04kyz;

1.60
date	2016.12.10.12.54.24;	author rool;	state Exp;
branches;
next	1.59;
commitid	zPShgPr6RkVlbrxz;

1.59
date	2016.03.04.20.54.39;	author rool;	state Exp;
branches;
next	1.58;
commitid	MvG9A9da0K4NQmXy;

1.58
date	2016.03.04.01.30.07;	author jballance;	state Exp;
branches;
next	1.57;
commitid	NFICmxi3aahBqgXy;

1.57
date	2015.11.12.22.28.37;	author rsprowson;	state Exp;
branches;
next	1.56;
commitid	xXLLfyXXvY7x1RIy;

1.56
date	2015.09.28.19.53.46;	author rsprowson;	state Exp;
branches;
next	1.55;
commitid	uzkkBixTPwO3C3Dy;

1.55
date	2015.09.17.16.03.46;	author rool;	state Exp;
branches;
next	1.54;
commitid	bTEnXVoCvWq6HCBy;

1.54
date	2015.08.22.09.21.59;	author rool;	state Exp;
branches;
next	1.53;
commitid	IRTjPoQFcMG6jfyy;

1.53
date	2015.08.22.08.58.50;	author rsprowson;	state Exp;
branches;
next	1.52;
commitid	Gxk8mCJ5kQ38bfyy;

1.52
date	2015.08.22.08.45.50;	author rool;	state Exp;
branches;
next	1.51;
commitid	dUK1sdsZhCgG6fyy;

1.51
date	2015.07.04.08.39.01;	author rsprowson;	state Exp;
branches;
next	1.50;
commitid	83feWxHUYZB0EWry;

1.50
date	2015.01.02.16.25.52;	author jballance;	state Exp;
branches;
next	1.49;
commitid	d826RZCxCbRS6t4y;

1.49
date	2014.08.12.19.02.11;	author jlee;	state Exp;
branches;
next	1.48;
commitid	FNxPAvpghRgvz6Mx;

1.48
date	2014.06.01.13.51.40;	author jlee;	state Exp;
branches;
next	1.47;
commitid	Vazl1SQGmZpsaPCx;

1.47
date	2013.05.27.11.01.19;	author rsprowson;	state Exp;
branches;
next	1.46;
commitid	oiMiL7Z7wETo7gRw;

1.46
date	2013.05.25.22.16.41;	author rsprowson;	state Exp;
branches;
next	1.45;
commitid	CIRNQ3209zG4V3Rw;

1.45
date	2013.05.10.06.59.41;	author rsprowson;	state Exp;
branches;
next	1.44;
commitid	vl8blyfCfPxnk3Pw;

1.44
date	2012.09.19.16.04.00;	author jlee;	state Exp;
branches;
next	1.43;
commitid	dVW4qyWuIG6sP9lw;

1.43
date	2012.07.13.00.50.10;	author jlee;	state Exp;
branches;
next	1.42;
commitid	BcPnmDDFsvatXkcw;

1.42
date	2012.07.09.22.22.43;	author jlee;	state Exp;
branches;
next	1.41;
commitid	Y0MPgi404HAReWbw;

1.41
date	2012.06.24.21.55.29;	author jlee;	state Exp;
branches;
next	1.40;
commitid	4v309enDleTpz0aw;

1.40
date	2012.06.07.00.11.05;	author jlee;	state Exp;
branches;
next	1.39;
commitid	LkYeKFZjKWlNTH7w;

1.39
date	2012.02.20.20.57.08;	author rsprowson;	state Exp;
branches;
next	1.38;
commitid	SAJJ0xbfbjtvgWTv;

1.38
date	2012.02.18.15.36.17;	author rsprowson;	state Exp;
branches;
next	1.37;
commitid	tTFWWR62eUupyETv;

1.37
date	2011.02.01.22.26.55;	author jlee;	state Exp;
branches;
next	1.36;

1.36
date	2010.11.23.22.59.30;	author jlee;	state Exp;
branches;
next	1.35;

1.35
date	2010.10.20.18.34.37;	author srevill;	state Exp;
branches;
next	1.34;

1.34
date	2010.10.20.17.52.18;	author srevill;	state Exp;
branches;
next	1.33;

1.33
date	2010.07.21.23.57.10;	author jlee;	state Exp;
branches;
next	1.32;

1.32
date	2010.04.19.11.35.08;	author bavison;	state Exp;
branches;
next	1.31;

1.31
date	2009.09.06.20.44.06;	author jlee;	state Exp;
branches;
next	1.30;

1.30
date	2006.01.05.12.43.04;	author jballance;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.30.23.23.08;	author dellis;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.30.22.39.55;	author dellis;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.05.16.02.38;	author jballance;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.05.22.08.59;	author jballance;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.18.11.54.03;	author jballance;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.24.14.02.55;	author jballance;	state Exp;
branches;
next	1.23;

1.23
date	2005.02.18.00.35.56;	author jballance;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.21.22.30.19;	author jballance;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.30.02.34.17;	author jballance;	state Exp;
branches;
next	1.20;

1.20
date	2004.08.12.14.47.39;	author jballance;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.01.18.10.36;	author kbracey;	state Exp;
branches;
next	1.18;

1.18
date	2004.06.30.14.50.35;	author kbracey;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.06.15.50.22;	author bavison;	state Exp;
branches;
next	1.16;

1.16
date	2004.02.16.15.43.50;	author kbracey;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.21.20.49.15;	author bavison;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.07.13.43.17;	author bavison;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2003.06.03.10.38.14;	author bavison;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.23.18.20.45;	author bavison;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.14.16.43.48;	author bavison;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.15.12.22.15;	author rsprowson;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.11.09.17.43;	author rsprowson;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.10.14.07.18;	author kbracey;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.08.21.31.13;	author rsprowson;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.08.13.06.17;	author rsprowson;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.02.17.05.51;	author rsprowson;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.07.22.29.45;	author dellis;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.31.12.38.56;	author dellis;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.29.10.55.55;	author dellis;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.28.09.55.14;	author dellis;	state Exp;
branches;
next	;

1.14.2.1
date	2004.02.16.15.38.42;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.62
log
@Missing newline from device info printout
Detail:
  During internationalisation, the last line lost its newline.
Admin:
  Submission from Colin Granville.

Version 1.19. Tagged as 'NetBSD-1_19'
@
text
@/* Copyright 2003 Tematic Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Changed 17.02.2010 TM DeviceCall_USB_TransferInfo and notation of padded bytes. */
#include "usbmodhead.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>
#include <stddef.h>

#include "Global/RISCOS.h"
#include "Global/Services.h"
#include "Global/UpCall.h"
#include "Global/FSNumbers.h"
#include "Interface/DeviceFS.h"
#include "Interface/USBDriver.h"

#include "sys/callout.h"
#include "sys/ioctl.h"
#include "sys/time.h"

#include "dev/usb/usb.h"
#include "dev/usb/usbdi.h"
#include "dev/usb/usbdi_util.h"
#include "dev/usb/usbdivar.h"
#include "dev/usb/usbhid.h"
#include "dev/usb/usb_quirks.h"

#include "swis.h"
#include "debuglib/debuglib.h"
#include "callx/callx.h"
#include "oslib/devicefs.h"
#ifndef BOOL
#define BOOL
#endif
#include "toolbox.h"

#include "bufman.h"
#include "usbmouse.h"
#include "usbkboard.h"
#include "USBDevFS.h"


/*---------------------------------------------------------------------------*/
/* structure definitions                                                     */
/*---------------------------------------------------------------------------*/

struct ugen_softc;

#define UAUDIO_NFRAMES 4

struct isoc_buffer {
    usbd_xfer_handle xfer;
    uint16_t sizes[UAUDIO_NFRAMES];
    uint16_t offsets[UAUDIO_NFRAMES];
    int size;
};

typedef enum {
    ReadStatus_Idle, /* Initial state, doing nothing */
    ReadStatus_Busy, /* Read is in progress. Note xfer may be idle if buffer has become full. */
    ReadStatus_Complete, /* Read has completed */
} ReadStatus;

struct devstream {
    /* HID needs to know the ugen */
    struct ugen_softc* ugen;

    int ep;
    int fs_stream;
    usbd_pipe_handle pipe;
    usbd_interface_handle iface;
    char* buf;
    int buffer;
    int buffer_id;
    usbd_xfer_handle xfer;
    int report;

    /* hid devices are all hung off the same endpoint, the chain is searched
       until the one with the correct report is found */
    struct devstream* next_hid;
    int count;
    int totalcount; /* transfer finishes when count it reaches totalcount */
    int timeout;
    int size;
    int bandwidth; /* isochronous bandwidth */
    int residue;
    int dying;
    int padded_bytes; /* only greater 0 in case of short packages */
    int flags; /* Flags altered by the GetSetOptions call */
#define FLAG_NOPAD 1
#define FLAG_SHORT 2
#define FLAG_VALIDMASK 3 /* Which bits can be modified */
    struct isoc_buffer * isoc;
    bool xfer_busy;
    bool delayed_read; /* Gets set if a read has been queued by RxWakeUp but hasn't actually been started yet (e.g. due to previous read still being in progress) */
    int nextcount; /* How long the next (i.e. delayed) read should be */
    ReadStatus read_status;
};

struct dev_struct {
    devicefs_device dev;
    int null;
    char name[32];
};

struct ugen_softc {
    USBBASEDEVICE sc_dev;               /* base device */
    usbd_device_handle sc_udev;
    struct dev_struct mydev;
    devicefs_device* sc_devfs;
    struct devstream* str[32];
};

/* used for generically matching keyboards and mice, and throwing them off */
struct iface_softc {
    USBBASEDEVICE sc_dev;
    usbd_device_handle sc_udev;
    usbd_interface_handle sc_iface;
};


/*---------------------------------------------------------------------------*/
/* variables definitions                                                     */
/*---------------------------------------------------------------------------*/

#define E_NoMem         "\x00\x90\x81\x00" "NoMem"
#define E_NoDevice      "\x01\x90\x81\x00" "NoDevice"
#define E_NoInterface   "\x02\x90\x81\x00" "NoInterface"
#define E_NoEndpoint    "\x03\x90\x81\x00" "NoEndpoint"
#define E_EndpointUsed  "\x04\x90\x81\x00" "EndpointUsed"
#define E_BadPipe       "\x05\x90\x81\x00" "BadPipe"
#define E_BadXfer       "\x06\x90\x81\x00" "BadXfer"
#define E_NoStream      "\x07\x90\x81\x00" "NoStream"
#define E_BadRequest    "\x08\x90\x81\x00" "BadRequest"
#define E_NotRootP      "\x09\x90\x81\x00" "NotRootP"
#define E_BadDevice     "\x0A\x90\x81\x00" "BadDevice"
#define E_MismatchVers  "\x0B\x90\x81\x00" "IncVers"
#define E_QuirkCmd      "\x0C\x90\x81\x00" "QuirkCmd"
#define E_NoSuchQuirk   "\x0D\x90\x81\x80" "NoSuchQuirk"
#define E_QuirkSlot     "\x0E\x90\x81\x80" "QuirkSlot"
#define E_XferFailed    "\x20\x90\x81\x00" "XferFailed"

#define USBDEV_MESSAGES "Resources:$.Resources.USBDriver.USBDevs"

MessagesFD mod_messages;
MessagesFD usbdev_messages;

_kernel_oserror* uerror (char* e)
{
    return _swix (MessageTrans_ErrorLookup, _INR(0,2), e, &mod_messages, 0);
}

/* this is defined in usb.c by the macro USB_DECLARE_DRIVER */
extern struct cfattach usb_ca;

extern struct cfattach uhub_uhub_ca;


/* for debugging */
#ifdef USB_DEBUG
extern int usbdebug, uhubdebug, uhidevdebug;
extern int total_sleep;
#endif
#ifdef DEBUGLIB
char* ccodes []= {
        "NORMAL_COMPLETION",
        "IN_PROGRESS",
        "PENDING_REQUESTS",
        "NOT_STARTED",
        "INVAL",
        "NOMEM",
        "CANCELLED",
        "BAD_ADDRESS",
        "IN_USE",
        "NO_ADDR",
        "SET_ADDR_FAILED",
        "NO_POWER",
        "TOO_DEEP",
        "IOERROR",
        "NOT_CONFIGURED",
        "TIMEOUT",
        "SHORT_XFER",
        "STALLED",
        "INTERRUPTED"};
#endif

extern int cold;
void* private_word = 0;

struct sysvar_callback {
    struct sysvar_callback* next;
    char com[];
}* sysvar_head = NULL;

static int usbbus_no = 1;       /* next number to use  */
static int usbdev_no = 1;       /* next number to use  */
static int maxdev_no = 0;       /* highest number found*/


struct devicelist allbuses = TAILQ_HEAD_INITIALIZER(allbuses);
struct devicelist allusbdevs = TAILQ_HEAD_INITIALIZER(allusbdevs);

/*---------------------------------------------------------------------------*/
/* static function declarations                                              */
/*---------------------------------------------------------------------------*/

struct device* attach_hub (struct device* parent, void* aux);
int detach_hub (struct device* hub);
struct device* attach_device (struct device* parent, struct usb_attach_arg* aux, int n);
int detach_device (struct device* dev, int);
bool sysvar_attach;
static int launch_system_variable (struct usb_attach_arg* aux, int unit);
void kill_system_variable (int unit);

extern int ugenioctl(int devt, int cmd, void* addr, int flag, void* p);
extern int usbioctl(int devt, u_long cmd, void* data, int flag, void *p);

struct device* get_usbdev (int unit);

extern char* usbd_get_string (usbd_device_handle, size_t, char*);
extern void microtime (struct timeval* tv);
extern void triggercbs(void);
extern uint32_t clock (void); // avoid header clash with sys/types.h

bool announce_attach;
static char* service_call (usbd_device_handle dev, int unit, int link);
_kernel_oserror* announce_device (_kernel_swi_regs* r, void* pw, void* sc);

extern void* resource_files (void);

/*---------------------------------------------------------------------------*/
/* functions       declarations                                              */
/*---------------------------------------------------------------------------*/
static _kernel_oserror *re_discover(_kernel_swi_regs *r, void *pw, void* h);

static _kernel_oserror *init_handler(_kernel_swi_regs *r, void *pw, void* h)
{
    /* issue a service call to request any latent HCDs to report themselves */
    _swix (OS_ServiceCall, _INR (0, 1),
        Service_USB_USBDriverStarting,
        Service_USB);
    return NULL;
}

_kernel_oserror *module_init(const char *cmd_tail, int podule_base, void *pw)
{
    _kernel_oserror* e;
    private_word = pw;
    /* set up debugging */
    debug_initialise ("USBDriver", "$.dbUSBD", 0);
//    debug_set_device(FILE_OUTPUT);
    debug_set_device(DADEBUG_OUTPUT);
//    debug_set_device(PRINTF_OUTPUT);
    debug_set_unbuffered_files (TRUE);
    /* Can't set debug_set_stamp_debug(TRUE) - Causes interrupts to be briefly enabled during debug output, which breaks all kinds of stuff */
/*    debug_set_stamp_debug (TRUE); */

    callx_init (pw);

#ifdef STANDALONE
    e = _swix (ResourceFS_RegisterFiles, _IN (0), resource_files ());
    if (e != NULL) return e;
#endif
    e = _swix (MessageTrans_OpenFile, _INR(0,2), &mod_messages, Module_MessagesFile, 0);
    if (e) goto error_dereg;
    e = _swix (MessageTrans_OpenFile, _INR(0,2), &usbdev_messages, USBDEV_MESSAGES, 0);
    if (e) goto error;

#ifdef USB_DEBUG
    const char *c;
    c = getenv("usbdebug"); usbdebug = (c?atoi(c):0);
    c = getenv("uhubdebug"); uhubdebug = (c?atoi(c):0);
    c = getenv("uhidevdebug"); uhidevdebug = (c?atoi(c):0);
#endif

    usbbus_no = 1;
    usbdev_no = 1;
    maxdev_no = 0;
    extra_quirks = NULL;

    /* do this in a callback so that clients can call our SWIs */
    callx_add_callback (init_handler, 0);

    /* set up a periodic call to re-discover anything lurking */
    callx_add_callevery(3000,re_discover,NULL);

    _swix (OS_Claim, _INR(0,2), PointerV, pointerv_entry, pw);

    return NULL;
    
error:
    _swix (MessageTrans_CloseFile, _IN(0), &mod_messages);
error_dereg:
#ifdef STANDALONE
    _swix (ResourceFS_DeregisterFiles, _IN(0), resource_files ());
#endif
    return e;
}

/*---------------------------------------------------------------------------*/

struct cfattach ugen_ca = {
    sizeof (struct ugen_softc), NULL, NULL, detach_device, NULL
};

_kernel_oserror *module_final(int fatal, int podule, void *pw)
{

    /* issue a service call to request any running HCDs can object */
    /* do this first in case other things still need to happen     */
    _swix (OS_ServiceCall, _INR (0, 1),
        Service_USB_USBDriverDying, Service_USB);


    _swix (OS_Release, _INR(0,2), PointerV, pointerv_entry, pw);
    _swix (OS_Release, _INR(0,2), KEYV, keyv_entry, pw);

    /* devices will all get removed as buses remove themselves from the
       above service call */
    struct device* dev;
    TAILQ_FOREACH(dev, &allbuses, dv_list)
    {
        (*usb_ca.ca_detach)(dev, 0);
        free (dev);
    }


    /* get rid of the system variables */
    while (_swix (OS_SetVarVal, _INR(0,4), "USB$Device_*", 0, -1, 0, 0) == NULL)
    {
        /* do nothing */
    }

    callx_remove_all_calleverys ();
    callx_remove_all_callafters ();
    callx_remove_all_callbacks ();

    _swix (MessageTrans_CloseFile, _IN(0), &mod_messages);
    _swix (MessageTrans_CloseFile, _IN(0), &usbdev_messages);
    if(extra_quirks) free(extra_quirks);

#ifdef STANDALONE
    _swix (ResourceFS_DeregisterFiles, _IN (0), resource_files ());
#endif

    return NULL;
}

/*---------------------------------------------------------------------------*/

static const char *ltrim(const char *string)
{
    if (string == NULL) return "";
    while (*string == ' ')
    {
        string++;
    }
    return string;
}

/*---------------------------------------------------------------------------*/

static const char *lookupmsg(const char *token, const char *arg0)
{
    static char buffer[128];
    _kernel_oserror *e;

    e = _swix (MessageTrans_Lookup, _INR(0,4),
               &mod_messages, token, buffer, sizeof(buffer), arg0);
    if (e) return "?";
    return buffer;
}

/*---------------------------------------------------------------------------*/

static void formatpair(const char *token, size_t width, const char *value)
{
    char fmt[16];

    sprintf (fmt, "%%-%ds : %%s", width);
    printf (fmt, lookupmsg (token, NULL), value);
}

/*---------------------------------------------------------------------------*/

static _kernel_oserror* RegisterNewDevice(struct ugen_softc * softc,int no)
{
    struct dev_struct * dev = &softc->mydev;
    sprintf (dev->name, "USB%d", no);
    strncpy (softc->sc_dev.dv_xname, dev->name,
        sizeof softc->sc_dev.dv_xname - 1)
            [sizeof softc->sc_dev.dv_xname - 1] = '\0';

    dev->dev.name_offset = dev->name - (char*) dev;
    dev->dev.flags = 3;
    dev->dev.tx_flags = 0x8;
    dev->dev.tx_buffer_size = 8192;
    dev->dev.rx_flags = 0x8;
    dev->dev.rx_buffer_size = 1024;

    _kernel_oserror* e = _swix (DeviceFS_Register, _INR (0, 7) | _OUT(0),
        6,
        dev,
        driver_entry,
        softc,
        private_word,
        "endpoint/Ninterface/Nalternate/Nreport/Ncontrol,isochronous,bulk,interrupt/Susbtimeout/Nsize/Nnopad/Sshort/S",
#ifdef DEVICEFSISBROKEN
        INT_MAX, // should be -1, but that doesn't seem to work
        INT_MAX,
#else
        -1,
        -1,
#endif
        &softc->sc_devfs);
    return e;
}

/*---------------------------------------------------------------------------*/

void module_services(int service_number, _kernel_swi_regs *r, void *pw)
{
    dprintf(("", "Service call reason %d\n", service_number));
    switch (service_number)
    {
#ifdef STANDALONE
    case Service_ResourceFSStarting:
        /* Re-register the messages */
        (*(void (*) (void*,void*,void*,void*)) r->r[2])
            (resource_files (), 0, 0, (void*) r->r[3]);
        break;
#endif
    case Service_DeviceFSStarting:/*attempt to register what we know about*/
        {
          usbdev_no = 1;
          maxdev_no = 0;
          struct device* dev;
          TAILQ_FOREACH(dev, &allusbdevs, dv_list)
          {
              if (dev)
              {
                  dev->dv_unit = maxdev_no = usbdev_no++;

                  dprintf(("","registering %d \n",dev->dv_unit));
                  RegisterNewDevice( ((struct ugen_softc*) dev),dev->dv_unit);
               }
           }
           break;
        }
    case Service_DeviceFSDying:   /*ensure we've forgotten any linkage*/
        {
          usbdev_no = 1;
          maxdev_no = 0;
          struct device* dev;
          TAILQ_FOREACH(dev, &allusbdevs, dv_list)
          {
              if (dev)
              {
                  dprintf(("","forgetting %d \n",dev->dv_unit));
                  dev->dv_unit = 0;
              }
          }
          break;
        }
    case Service_USB:
        switch (r->r[0]) {
        case Service_USB_Connected:
        {
            struct device* dev;
            USBServiceAnswer* serv;
            // to link to existing list
            USBServiceAnswer* lastserv = (USBServiceAnswer*) r->r[2];
            while (lastserv != NULL && lastserv->link != NULL)
            {
                lastserv = lastserv->link;
            }
            TAILQ_FOREACH(dev, &allusbdevs, dv_list)
            {
                struct ugen_softc * udev = (struct ugen_softc*) dev;
                serv = (USBServiceAnswer*)
                    service_call (udev->sc_udev, dev->dv_unit, 1);
                serv->link = NULL;
                if (lastserv == NULL)
                {
                    r->r[2] = (int) serv;
                }
                else
                {
                    lastserv->link = serv;
                }
                lastserv = serv;
            }
        }
            break;
        case Service_USB_Attach:
            break;
        case Service_USB_Detach:
            break;
        }
        break;
    case Service_PreReset:
      {
        /* Machine is about to be reset. We do not have time to shut the */
        /* system down cleanly. We MUST make sure our chip is 'muted'    */
//    /* issue a service call to request any running HCDs can object */
//    /* do this first in case other things still need to happen     */
//    _swix (OS_ServiceCall, _INR (0, 1),
//        Service_USB_USBDriverDying, Service_USB);
            callx_remove_all_calleverys ();
            callx_remove_all_callafters ();
            callx_remove_all_callbacks ();
            break;
        }
    }
}

/*---------------------------------------------------------------------------*/

static _kernel_oserror* command_enumerate_devices (void)
{
    size_t i, width;
    char   fmt[40], hdr[80], colfmt[20];
    const char *heading, *column;
    struct usb_device_info di;

    heading = lookupmsg ("DevHdr", NULL);
    *fmt = *hdr = '\0';
    for (i = 0; i < 5; i++)
    {
        column = strtok ((i == 0) ? (char *)heading : NULL, "_");
        width = strlen (column);
        strcat (hdr, column);
        switch (i)
        {
            /* eg. No. Bus Dev Class Description
             *       0   1   2     3 4
             *     123 123 123  8/FF Vend Prod
             */
            case 0: case 1: case 2:
                sprintf (colfmt, "%%%dd ", max (width, 3));
                strcat (fmt, colfmt);
                do { strcat (hdr, " "); width++; } while (width < 4);
                break;
            case 3:
                sprintf (colfmt, "%%%dX/%%2X ", max (width, 5) - 3);
                strcat (fmt, colfmt);
                do { strcat (hdr, " "); width++; } while (width < 6);
                break;
            case 4:
                strcat (fmt, "%s%s%s\n");
                break;
        }
    }
    printf ("%s\n", hdr);
    for (i = 1; i <= maxdev_no; ++i)
    {
        struct device* dev = get_usbdev (i);
        if (dev != NULL)
        {
            usbd_device_handle udev = ((struct ugen_softc*) dev)->sc_udev;
            usbd_fill_deviceinfo (udev, &di, 1);
            /* in case the vendor string is null, don't print a leading space */
            printf (fmt,
                i,
                di.udi_bus,
                di.udi_addr,
                di.udi_class,
                di.udi_subclass,
                di.udi_vendor,
                *di.udi_vendor ? " " : "",
                di.udi_product);
        }
    }
#ifdef USB_DEBUG
    printf ("usbdebug %d\n", usbdebug);
    printf ("uhidevdebug %d\n", uhidevdebug);
    printf ("uhubdebug %d\n", uhubdebug);
#endif
    return NULL;
}

/*---------------------------------------------------------------------------*/

static _kernel_oserror* command_enumerate_buses (void)
{
    size_t i, width;
    char   fmt[40], hdr[80], colfmt[20];
    const char *heading, *column;
    struct usb_device_stats stats;

    sprintf (hdr, "%d", usbbus_no-1);
    printf ("%s:\n", lookupmsg ("BusTxf", hdr));

    heading = lookupmsg ("BusHdr", NULL);
    *fmt = *hdr = '\0';
    for (i = 0; i < 5; i++)
    {
        column = strtok ((i == 0) ? (char *)heading : NULL, "_");
        width = strlen (column);
        switch (i)
        {
            /* eg. Bus    Control Isochronous       Bulk  Interrupt
             *       0          1           2          3          4
             *     123 2999888777  2999888777 2999888777 2999888777
             */
            case 0:
                sprintf (colfmt, "%%%dd ", max (width, 3));
                strcat (fmt, colfmt);
                strcat (hdr, column);
                do { strcat (hdr, " "); width++; } while (width < 4);
                break;
            case 1: case 2: case 3: case 4:
                sprintf (colfmt, "%%%dlu ", max (width, 10));
                strcat (fmt, colfmt);
                while (width < 10) { strcat (hdr, " "); width++; }
                strcat (hdr, column); strcat (hdr, " ");
                break;
        }
    }
    strcat (fmt, "\n");
    printf ("%s\n", hdr);
    for (i = 1; i < usbbus_no; ++i)
    {
        if (get_softc (i << 16) == NULL ||
            usbioctl (i << 16, USB_DEVICESTATS, &stats, 0, 0))
        {
            continue;
        }

        printf (fmt,
            i,
            stats.uds_requests[UE_CONTROL],
            stats.uds_requests[UE_ISOCHRONOUS],
            stats.uds_requests[UE_BULK],
            stats.uds_requests[UE_INTERRUPT]);
    }
    return 0;
}

/*---------------------------------------------------------------------------*/
static _kernel_oserror* command_discover (void)
{
#ifdef USB_DEBUG
    total_sleep = 0;
    dprintf (("", "discovering max of %d busses\n", usbbus_no-1));
#endif
    for (int i = 1; i < usbbus_no; i++)
    {
        if (get_softc (i << 16) != NULL)
            usbioctl (i << 16, USB_DISCOVER, 0, 0, 0);
    }
#ifdef USB_DEBUG
    dprintf (("", "total sleep = %d\n", total_sleep));
#endif
    return NULL;
}


/*---------------------------------------------------------------------------*/

static _kernel_oserror* command_reset (int n)
{
    struct device* dev = get_usbdev (n);
    if (dev == NULL)
    {
        return uerror (E_NoDevice);
    }

    /* pretend it's a ugen to get the udev */
    usbd_device_handle udev = ((struct ugen_softc*) dev)->sc_udev;
    struct usbd_port * port = udev->powersrc;
    usbd_device_handle parent = port?port->parent:NULL;
    if (parent == NULL)   // its a root hub..
    {
        return uerror (E_NotRootP);
    }

    usb_disconnect_port (port, (device_ptr_t) parent->hub);
    usbd_clear_port_feature(parent, port->portno, UHF_PORT_POWER);
    usbd_delay_ms(parent, /*USB_PORT_RESET_DELAY*/ USB_PORT_POWER_DOWN_TIME);
    usbd_set_port_feature(parent, port->portno, UHF_PORT_POWER);
    int pwrdly = parent->hub->hubdesc.bPwrOn2PwrGood
                                                     * UHD_PWRON_FACTOR
                                            + USB_EXTRA_POWER_UP_TIME;
                                        usbd_delay_ms(parent, pwrdly);
    return NULL;
}

/*---------------------------------------------------------------------------*/

static _kernel_oserror* command_dev_info (int n)
{
    char   string[USB_MAX_STRING_LEN], speed[8];
    struct device *dev = get_usbdev (n);
    size_t width;

    if (dev == NULL)
    {
        return uerror (E_NoDevice);
    }

    /* pretend it's a ugen to get the udev */
    usbd_device_handle udev = ((struct ugen_softc*) dev)->sc_udev;
    usb_device_descriptor_t * ddesc = &udev->ddesc;

    width = strlen (lookupmsg ("DILen", NULL));
    sprintf (string, "%04X\n", UGETW(ddesc->bcdUSB));     formatpair ("DIRel", width, string);
    sprintf (string, "%02X\n", ddesc->bDeviceClass);      formatpair ("DICls", width, string);
    sprintf (string, "%02X\n", ddesc->bDeviceSubClass);   formatpair ("DISub", width, string);
    sprintf (string, "%02X\n", ddesc->bDeviceProtocol);   formatpair ("DIPrt", width, string);
    sprintf (string, "%02X\n", ddesc->bMaxPacketSize);    formatpair ("DIMxP", width, string);
    sprintf (string, "%04X\n", UGETW(ddesc->idVendor));   formatpair ("DIVid", width, string);
    sprintf (string, "%04X\n", UGETW(ddesc->idProduct));  formatpair ("DIPid", width, string);
    sprintf (string, "%04X\n", UGETW(ddesc->bcdDevice));  formatpair ("DIDid", width, string);
    sprintf (string, "%d\n", ddesc->bNumConfigurations);  formatpair ("DICfg", width, string);

    *string = '\0';
    usbd_get_string (udev, ddesc->iManufacturer, string); formatpair ("DIMfg", width, "");
    printf ("'%s'\n", ltrim (string));

    *string = '\0';
    usbd_get_string (udev, ddesc->iProduct, string);      formatpair ("DIPrd", width, "");
    printf ("'%s'\n", ltrim (string));

    *string = '\0';
    usbd_get_string (udev, ddesc->iSerialNumber, string); formatpair ("DISer", width, "");
    printf ("'%s'\n", ltrim (string));

    sprintf (speed, "Spd%d", udev->speed);
    sprintf (string, "%s\n", lookupmsg (speed, NULL));    formatpair ("DISpd", width, string);

    return NULL;
}

/*---------------------------------------------------------------------------*/

static _kernel_oserror* command_conf_info (int n)
{
    char   string[USB_MAX_STRING_LEN], pad[8];
    struct device* dev = get_usbdev (n);
    size_t width;
    int    i;
    bool   indent;

    if (dev == NULL)
    {
        return uerror (E_NoDevice);
    }

    usbd_device_handle udev = ((struct ugen_softc*) dev)->sc_udev;
    usb_config_descriptor_t * cdesc = udev->cdesc;

    width = strlen (lookupmsg ("CILen", NULL));
    sprintf (string, "%d\n", udev->config);
    formatpair ("CICur", width, string);
    if (udev->config == 0 || cdesc == NULL)
    {
        return NULL;
    }
    sprintf (string, "%d\n", cdesc->bNumInterface);
    formatpair ("CIQty", width, string);
    sprintf (string, "%d\n", cdesc->bConfigurationValue);
    formatpair ("CICfg", width, string);

    *string = '\0';
    usbd_get_string (udev, cdesc->iConfiguration, string);
    formatpair ("CINom", width, "");
    printf ("'%s'\n", ltrim (string));

    /* Attributes */
    indent = false;
    formatpair ("CIAtt", width, "");
    if (cdesc->bmAttributes & UC_BUS_POWERED)
    {
        printf ("%s\n", lookupmsg ("Att80", NULL));
        indent = true;
    }
    if (cdesc->bmAttributes & UC_SELF_POWERED)
    {
        if (indent) for (i = width + 3; i > 0; i--) putchar (' ');
        printf ("%s\n", lookupmsg ("Att40", NULL));
        indent = true;
    }
    if (cdesc->bmAttributes & UC_REMOTE_WAKEUP)
    {
        if (indent) for (i = width + 3; i > 0; i--) putchar (' ');
        printf ("%s\n", lookupmsg ("Att20", NULL));
        indent = true;
    }
    if (!(cdesc->bmAttributes & (UC_BUS_POWERED | UC_SELF_POWERED | UC_REMOTE_WAKEUP)))
    {
        puts ("\n");
    }

    /* Max power */
    sprintf (string, "%dmA\n", cdesc->bMaxPower * UC_POWER_FACTOR);
    formatpair ("CIPwr", width, string);

    /* Now list descriptor details */
    char* ptr = (char*) cdesc, *ptr_end = ptr + UGETW(cdesc->wTotalLength);
    ptr += cdesc->bLength;

    while (ptr < ptr_end)
    {
        const char *token;

        switch (ptr[1])
        {
            case UDESC_INTERFACE:
            {
                usb_interface_descriptor_t * d = (usb_interface_descriptor_t *) ptr;
    
                *string = '\0'; usbd_get_string (udev, d->iInterface, string);
                printf ("\n%s %d.%d ",
                    lookupmsg ("IFace", NULL),
                    d->bInterfaceNumber,
                    d->bAlternateSetting);
                printf ("%s %d.%d:%d '%s'\n",
                    lookupmsg ("UCls", NULL),
                    d->bInterfaceClass,
                    d->bInterfaceSubClass,
                    d->bInterfaceProtocol,
                    ltrim (string));
                break;
            }
            case UDESC_ENDPOINT:
            {
                usb_endpoint_descriptor_t * d = (usb_endpoint_descriptor_t *) ptr;
                printf ("%s %d, ", lookupmsg("IEndp", NULL),
                                   UE_GET_ADDR(d->bEndpointAddress));
                switch (d->bmAttributes & UE_XFERTYPE)
                {
                    case UE_CONTROL:
                        token = "ECtrl";
                        break;
                    case UE_ISOCHRONOUS:
                        switch (UE_GET_ISO_TYPE(d->bmAttributes))
                        {
                            case UE_ISO_ASYNC:
                                token = "EIsoY";
                                break;
                            case UE_ISO_ADAPT:
                                token = "EIsoA";
                                break;
                            case UE_ISO_SYNC:
                                token = "EIsoS";
                                break;
                        }
                        break;
                    case UE_BULK:
                        token = "EBulk";
                        break;
                    case UE_INTERRUPT:
                        token = "EIntr";
                        break;
                }
                printf ("%s %s, ", lookupmsg(token, NULL),
                                   UE_GET_DIR(d->bEndpointAddress) == UE_DIR_IN? "IN":"OUT");
                printf ("%d %s ", UGETW(d->wMaxPacketSize), lookupmsg("UByt", NULL));
                printf ("%d %s\n", d->bInterval, lookupmsg("UFrm", NULL));
                break;
            }
            case UDESC_HID:
            {
                usb_hid_descriptor_t * d = (usb_hid_descriptor_t *) ptr;
                ddumpbuf("", (void*) d, d->bLength, 0);
                ddumpbuf("", (void*) d, sizeof *d, 0);
                printf ("%s, HID%X.%02X, ", lookupmsg ("IHidd", NULL),
                                            UGETW(d->bcdHID) >> 8,
                                            UGETW(d->bcdHID) & 0xFF);
                printf ("%s %d\n", lookupmsg ("UCcd", NULL), d->bCountryCode);
                for (i = 0; i < d->bNumDescriptors; ++i)
                {
                    printf ("  %s %d, ", lookupmsg ("UDsc", NULL), i + 1);
#if defined(__CC_NORCROFT) && defined(DISABLE_PACKED)
                    /* Handle in a rather horrible way */
                    printf ("%s %X, ", lookupmsg ("UHTy", NULL),
                                       d->bHIDDescriptorType);
                    printf ("%s %d\n", lookupmsg ("ULen", NULL),
                                       UGETW (d->wDescriptorLength));
                    d = (usb_hid_descriptor_t *) (((char*) d) + 3);
#else
                    printf ("%s %X, ", lookupmsg ("UHTy", NULL),
                                       d->descrs[i].bHIDDescriptorType);
                    printf ("%s %d\n", lookupmsg ("ULen", NULL),
                                       UGETW (d->descrs[i].wDescriptorLength));
#endif
                }
                break;
            }
        }
        ptr += *ptr;
    }

    return NULL;
}

/*---------------------------------------------------------------------------*/

static _kernel_oserror* command_set_config (int device, int config)
{
    struct device* dev = get_usbdev (device);
    if (dev == NULL)
    {
        return uerror (E_NoDevice);
    }

    usbd_device_handle udev = ((struct ugen_softc*) dev)->sc_udev;

    usbd_set_config_no(udev, config, 0);
    return NULL;
}

/*---------------------------------------------------------------------------*/

static _kernel_oserror* command_set_interface (int device, int ifcn, int alt)
{
    struct device* dev = get_usbdev (device);
    if (dev == NULL)
    {
        return uerror (E_NoDevice);
    }

    usbd_device_handle udev = ((struct ugen_softc*) dev)->sc_udev;

    usbd_interface_handle ifc;
    int err = usbd_device2interface_handle (udev, ifcn, &ifc);
    if (err)
    {
        return uerror (E_NoInterface);
    }

    usbd_set_interface(ifc, alt);
    return NULL;
}

/*---------------------------------------------------------------------------*/

static _kernel_oserror* command_ListQuirks(void)
{
    size_t i, width;
    char   fmt[40], hdr[80], colfmt[20];
    const char *heading, *column;
    usbd_quirk_entry *t;

    heading = lookupmsg ("QrkHdr", NULL);
    *fmt = *hdr = '\0';
    for (i = 0; i < 4; i++)
    {
        column = strtok ((i == 0) ? (char *)heading : NULL, "_");
        width = strlen (column);
        strcat (hdr, column);
        switch (i)
        {
            /* eg. Vendor Product Device Flags
             *          0       1      2 3
             *       ABCD    ABCD   ABCD 1234ABCD
             */
            case 0: case 1: case 2:
                sprintf (colfmt, "%%%dx ", max (width, 4));
                strcat (fmt, colfmt);
                do { strcat (hdr, " "); width++; } while (width < 5);
                break;
            case 3:
                sprintf (colfmt, "%%0%dx\n", max (width, 8));
                strcat (fmt, colfmt);
                do { strcat (hdr, " "); width++; } while (width < 9);
                break;
        }
    }
    printf ("%s\n", hdr);
    if (extra_quirks != NULL)
    {
        for (i = 0, t = extra_quirks; i < MAX_EXTRA_QUIRKS; i++,t++)
        {
            if (t->idVendor)
                printf(fmt, t->idVendor, t->idProduct, t->bcdDevice, t->quirks.uq_flags);
        }
    }
    return NULL;
}

static _kernel_oserror* command_RemoveQuirk(unsigned vendor, unsigned product, unsigned device)
{
    int i;
    usbd_quirk_entry *t;
    
    if (extra_quirks)
    {
        for (i = 0, t = extra_quirks; i < MAX_EXTRA_QUIRKS; i++,t++)
        {
            if (t->idVendor  == vendor &&
                t->idProduct == product&&
                t->bcdDevice == device)
            {
                t->idVendor  = 0;
                t->idProduct = 0;
                t->bcdDevice = 0;
                t->quirks.uq_flags = 0;
                return NULL;
            }
        }
    }
    return uerror (E_NoSuchQuirk);
}

static _kernel_oserror* command_AddQuirk(unsigned vendor, unsigned product, unsigned device, unsigned quirk)
{
    int i;
    usbd_quirk_entry *t;

    if (extra_quirks == NULL) extra_quirks = calloc (MAX_EXTRA_QUIRKS, sizeof(usbd_quirk_entry));
    if (extra_quirks == NULL) return uerror (E_NoMem);
    for (i = 0, t = extra_quirks; i < MAX_EXTRA_QUIRKS; i++,t++)  /* existing? */
    {
        if (t->idVendor  == vendor &&
            t->idProduct == product&&
            t->bcdDevice == device)
        {
            t->quirks.uq_flags = quirk;
            return NULL;
        }
    }
    for (i = 0, t = extra_quirks; i < MAX_EXTRA_QUIRKS; i++,t++)  /* new */
    {
        if (!t->idVendor)
        {
            t->idVendor  = vendor ;
            t->idProduct = product;
            t->bcdDevice = device;
            t->quirks.uq_flags = quirk;
            return NULL;
        }
    }
    return uerror (E_QuirkSlot);
}


/*---------------------------------------------------------------------------*/

int tsleep (void* ident, int priority, const char* wmesg, int timo, int noblock);
void wakeup (void* ident);
_kernel_oserror *module_commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
    switch (cmd_no) {
#ifdef USB_DEBUG
    case CMD_USBDebug:
        {
        char* ptr;
        usbdebug = (int) strtoul (arg_string, &ptr, 0);
        uhidevdebug = usbdebug;
        if (ptr) uhubdebug = (int) strtoul (ptr, &ptr, 0);
        }
        break;
#endif
    case CMD_USBDevices:
        return command_enumerate_devices ();
    case CMD_USBBuses:
        return command_enumerate_buses ();
    case CMD_USBDevInfo:
        return command_dev_info (atoi (arg_string));
    case CMD_USBConfInfo:
        return command_conf_info (atoi (arg_string));
    case CMD_USBSetConfig:
        {
            int d, c;
            char* p;
            d = (int) strtoul (arg_string, &p, 10);
            c = (int) strtoul (p, &p, 10);
            return command_set_config (d, c);
        }
        break;
    case CMD_USBSetInterface:
        {
            int b, c, d;
            char* p;
            b = (int) strtoul (arg_string, &p, 10);
            c = (int) strtoul (p, &p, 10);
            d = (int) strtoul (p, &p, 10);
            return command_set_interface (b, c, d);
        }
        break;

#ifdef USB_DEBUG
    case CMD_USBDiscover:
        return command_discover ();
#endif

    case CMD_USBReset:
        return command_reset ((int) strtoul (arg_string, 0, 10));

    case CMD_USBQuirk:
        {
            char *p, cmd = (*arg_string) & 0xDF; /* Cheap toupper() */
            unsigned long vendor, product = 0, device = 0, quirk = 0;

            if (cmd=='L') return command_ListQuirks ();
            vendor = (unsigned)strtoul (arg_string+1, &p, 16);
            if (p) product = (unsigned)strtoul (p, &p, 16);
            if (p) device  = (unsigned)strtoul (p, &p, 16);
            if (p) quirk   = (unsigned)strtoul (p, &p, 16);
            if (cmd=='R')
                 return command_RemoveQuirk (vendor,product,device);
            if (cmd=='A')
                 return command_AddQuirk (vendor,product,device,quirk);
            return uerror (E_QuirkCmd);
        }
    }

    return NULL;
}

/*---------------------------------------------------------------------------*/

static device_ptr_t register_bus (device_ptr_t bus)
{
    device_ptr_t softc;
    /* initialise device structure */
    softc = calloc (usb_ca.ca_devsize, 1);
    if (softc == NULL) return NULL;
    TAILQ_INSERT_TAIL (&allbuses, softc, dv_list);
    dprintf (("", "adding bus %p using %p size %x\n", bus,softc,usb_ca.ca_devsize));

    /* abuse the device structure a bit */
    bus->dv_unit = softc->dv_unit = (usbbus_no++);

    /* set the flag to make it explore immediately */
    softc->dv_cfdata = &(struct cfdata) { .cf_flags = 1 };;

    strncpy (softc->dv_xname, "USBDriver"Module_VersionString,
        sizeof softc->dv_xname - 1)[sizeof softc->dv_xname - 1] = '\0';
#ifdef USB_DEBUG
        total_sleep = 0;
#endif

    (*usb_ca.ca_attach)(0, softc, bus);
#ifdef USB_DEBUG
    dprintf (("", "total sleep = %d\n", total_sleep));
#endif

    return softc;
}

static void deregister_bus (device_ptr_t bus)
{
    dprintf (("", "removing bus %p\n", bus));
    (*usb_ca.ca_detach)(bus, 0);
    dprintf (("", "finished removing bus %p\n", bus));
    TAILQ_REMOVE (&allbuses, (device_ptr_t) bus, dv_list);
    free (bus);
}

_kernel_oserror *module_swis(int swi_offset, _kernel_swi_regs *r, void *pw)
{
    switch (swi_offset) {
    case USBDriver_RegisterBus - USBDriver_00:
        /* R1 now contains internal API version number
           This check should be made more permissive when appropriate */
        if(r->r[1] != RISCOS_USBDRIVER_API_VERSION)
            return uerror (E_MismatchVers);
        r->r[0] = (int) register_bus ((device_ptr_t) r->r[0]);
        break;

    case USBDriver_DeregisterBus - USBDriver_00:
        deregister_bus ((device_ptr_t) r->r[0]);
        break;
    case USBDriver_InsertTransfer - USBDriver_00:
        r->r[0] = usb_insert_transfer ((usbd_xfer_handle) r->r[0]);
        break;
    case USBDriver_TransferComplete - USBDriver_00:
        usb_transfer_complete ((usbd_xfer_handle) r->r[0]);
        break;
    case USBDriver_ScheduleSoftInterrupt - USBDriver_00:
        if (r->r[0] > usbbus_no)
            usb_schedsoftintr ((struct usbd_bus*) r->r[0]);
        else
        {
            struct device* bus = get_softc (r->r[0] << 16);
            if (bus != NULL)
                /* discustingly hacky */
                usb_schedsoftintr (*(void**) (bus + 1));
        }
        break;
    case USBDriver_Version - USBDriver_00:
        r->r[0] = Module_VersionNumber;
        break;
    default:
        return error_BAD_SWI;
    }

    return 0;
}

/*---------------------------------------------------------------------------*/

struct device* get_softc (int unit)
{
    struct device* dev;
    TAILQ_FOREACH(dev, &allbuses, dv_list)
    {
        if (dev->dv_unit == ((unit >> 16) & 0xff))
            return dev;
    }

    dprintf (("", "couldn't find unit %x\n", unit));
    return NULL;
}

/*---------------------------------------------------------------------------*/

struct device* get_usbdev (int unit)
{
    struct device* dev;
    TAILQ_FOREACH(dev, &allusbdevs, dv_list)
    {
        if (dev->dv_unit == unit)
        {
            return dev;
        }
    }
    dprintf (("", "couldn't find unit %x\n", unit));

    return NULL;
}

/*---------------------------------------------------------------------------*/
static _kernel_oserror *re_discover(_kernel_swi_regs *r, void *pw, void* h)
{
    static bool rd_active = false;

    if (rd_active) return NULL;
    rd_active = true;
    for (int i = 1; i < usbbus_no; i++)
    {
        if (get_softc (i << 16) != NULL)
        {
            dprintf(("","rediscover bus %d\n",i));
            usbioctl (i << 16, USB_DISCOVER, 0, 0, 0);
        }
    }
    rd_active = false;
    return NULL;
}

/*---------------------------------------------------------------------------*/
struct device* riscos_usb_attach
(
    void* dev,
    struct device*  parent,
    void* aux
) {
    struct device* ret;

    /* This function is called with:
     * 1. aux->usegeneric == 0 && aux->configno == UHUB_UNK_CONFIGURATION
     * 2. aux->usegeneric == 0 && aux->configno != UHUB_UNK_CONFIGURATION
     *    this is repeated for each device interface
     * 3. aux->usegeneric == 1 && aux->configno == UHUB_UNK_CONFIGURATION
     *    the device is registered and announced now
     *
     * Alias running only occurs when sysvar_attach == false.
     * Check specifically for case (1) so that only the first matching alias is run
     * and not repeatedly for each interface.
     */
    if ((((struct usb_attach_arg*) aux)->usegeneric == 0) &&
        (((struct usb_attach_arg*) aux)->configno == UHUB_UNK_CONFIGURATION))
    {
        sysvar_attach = false;
        announce_attach = false;
    }

    char str[sizeof "USB$Ignore_VVVV_PPPP"];
    sprintf (str, "USB$Ignore_%04X_%04X", ((struct usb_attach_arg*)aux)->vendor,
                                          ((struct usb_attach_arg*)aux)->product);
    const char *env = getenv(str);
    dprintf (("", "Check for '%s' got '%s'\n", str, (env ? env : "NULL")));
    if (!env)
    {
        /* No ignore variable, so try to look for it */
        typedef device_ptr_t pf (device_ptr_t, void*);
        pf* funcs[] = { attach_hub, attach_mouse, attach_keyboard, NULL };
        for (pf** f = funcs; *f != NULL; ++f)
        {
            if ((ret = (*f) (parent, aux)) != NULL)
            {
                return ret;
            }
        }
    }

    /* get a number.. dev->dvunit will be 0 if this is the first time through */
    if (((usbd_device_handle)dev)->dv_unit == 0)
    {
        int startnum = usbdev_no;
reloop:
        if (usbdev_no > 999) usbdev_no = 1;   /* cycle around mod 1000 */
        if (usbdev_no > maxdev_no) maxdev_no = usbdev_no;
        if (get_usbdev (usbdev_no) != NULL)
        {
            if (usbdev_no != startnum)
            {
                usbdev_no++;
                goto reloop;                  /* not looped yet .. try again */
            }
        }
        ((usbd_device_handle)dev)->dv_unit = usbdev_no++;
    }
    ret = attach_device (parent, aux, ((usbd_device_handle)dev)->dv_unit);
    if (ret != NULL)
    {
        ret->dv_unit = ((usbd_device_handle)dev)->dv_unit;
        dprintf (("", "first = %p, last = %p\n",
            allusbdevs.tqh_first, allusbdevs.tqh_last));
        /* insert at head, so that iteration starts with last added */
        TAILQ_INSERT_TAIL (&allusbdevs, ret, dv_list);

        /* now execute any * commands queued */
        struct sysvar_callback * sc = sysvar_head;
        _kernel_oserror* e;
        while (sc)
        {
            dprintf (("", "executing: %s\n", sc->com));
            if (NULL != (e = _swix (OS_CLI, _IN(0), sc->com)))
                dprintf (("", "error: %s\n", e->errmess));
            sc = sysvar_head->next;
            free (sysvar_head);
            sysvar_head = sc;
        }
    }

    return ret;
}

/*---------------------------------------------------------------------------*/

/* dummy - we don't do attachment like this */
void* (config_found) (struct device* dev, void* h, int (*f) (void*, const char*))
{
    (void) f;
    (void) dev;
    (void) h;
    return (void*) 1;
}

/*---------------------------------------------------------------------------*/

int config_detach (struct device* dev, int n)
{
    dprintf (("", "config detach %p, %d, type %d\n",
        dev, n, (int) dev->dv_cfdata));
    /* catch case of config_detach called from config_found above */
    if (dev == (void*) 1)
    {
        return 0;
    }

    /* only remove if a generic device or hub, others match as generic as well
        */
    switch ((int) (dev->dv_cfdata))
    {
    case 1:
    case 2:
        if (dev->dv_list.tqe_prev == NULL)
            dprintf (("", "not removing %p\n", dev));
        else
        {
            dprintf (("", "removing %p (prev=%p, next=%p)\n",
                          dev, dev->dv_list.tqe_prev, dev->dv_list.tqe_next));
            TAILQ_REMOVE (&allusbdevs, dev, dv_list);
            /* memory is free'd at the detach point later */
        }

        /* remove any system variables attached to this device and since we
           don't reuse numbers nuke the devicefs options variable too */
       kill_system_variable(dev->dv_unit);

    }

    switch ((int) (dev->dv_cfdata))
    {
    case 1: return detach_hub (dev);
    case 2: return detach_device (dev, n);
    case 3: return detach_mouse (dev);
    case 4: return detach_keyboard (dev);
    }

//    free (dev);
    return 0;
}

/*---------------------------------------------------------------------------*/

struct device* attach_hub (struct device* parent, void* aux)
{
    struct device* softc;
    struct usb_attach_arg* uaa = aux;

    /* don't match generic */
    if (uaa->usegeneric) return NULL;

    dprintf (("", "Trying match on usb hub\n"));

    /* First see if we match */
    if ((*uhub_uhub_ca.ca_match) (0, 0, aux) == UMATCH_NONE)
    {
       dprintf (("", "Failed to match\n"));
       return NULL;
    }

    /* If so, allocate memory for the device and attach ourselves. */
    softc = malloc (uhub_uhub_ca.ca_devsize);
    if (softc == NULL) {
        dprintf (("", "Couldn't allocate memory for hub device\n"));
        return NULL;
    }
    memset (softc, 0, uhub_uhub_ca.ca_devsize);
    strncpy (softc->dv_xname,
        "USBHub"Module_VersionString,
        sizeof softc->dv_xname - 1)[sizeof softc->dv_xname - 1] = '\0';
    softc->dv_cfdata = (void*) 1; // hub

    (*uhub_uhub_ca.ca_attach) (parent, softc, aux);

    dprintf (("", "Matched hub\n"));

    return softc;
}

/*---------------------------------------------------------------------------*/

int detach_hub (struct device* hub)
{
    (*uhub_uhub_ca.ca_detach) (hub, 0);
    free (hub);
    return 0;
}

/*---------------------------------------------------------------------------*/

/* returns non-zero if not handed */
char* service_call (usbd_device_handle dev, int unit, int link)
{
    size_t size =
        (link? sizeof (USBServiceCall*): 0) +
        sizeof (USBServiceCall) +
        UGETW(dev->cdesc->wTotalLength);

    char* real_serv = malloc (size);
    USBServiceCall* serv = (USBServiceCall*) (link? real_serv + sizeof (USBServiceCall*): real_serv);

    if (real_serv == NULL)
    {
        return 0;
    }
    memset (real_serv, 0, size);

    serv->sclen = size - (link? sizeof (USBServiceCall*): 0);
    serv->descoff = offsetof (USBServiceCall, ddesc);
    snprintf (serv->devname, sizeof serv->devname, "USB%d", unit);
    serv->bus = dev->bus->bdev.dv_unit;
    serv->devaddr = dev->address;
    serv->hostaddr = dev->powersrc->parent? dev->powersrc->parent->address: 0;
    serv->hostport = dev->powersrc->portno;
    serv->speed = dev->speed;

    memcpy ((void *)&serv->ddesc, (void *)&dev->ddesc, sizeof serv->ddesc);
    memcpy ((char*)(serv + 1) - 2, (void *)dev->cdesc, UGETW(dev->cdesc->wTotalLength));

    return real_serv;
}

/*---------------------------------------------------------------------------*/

#define USBALIAS "Alias$@@USBDevice_"

static int launch_system_variable (struct usb_attach_arg* aux, int unit)
{
    usbd_interface_handle ifc = NULL;
    int class       = aux->iface?   aux->iface->idesc->bInterfaceClass:
                                    aux->device->ddesc.bDeviceClass;
    int subclass    = aux->iface?   aux->iface->idesc->bInterfaceSubClass:
                                    aux->device->ddesc.bDeviceSubClass;
    int protocol    = aux->iface?   aux->iface->idesc->bInterfaceProtocol:
                                    aux->device->ddesc.bDeviceProtocol;
    int vendor      = aux->vendor;
    int product     = aux->product;
    int config      = aux->configno;
    int interface   = aux->ifaceno;
    int release     = aux->release;
    const char* alias = USBALIAS;
    int len         = 0;
    char* name      = NULL;

    char str[sizeof "Alias$@@USBDevice_LL_SS_TT_VVVV_PPPP_CC_II_RRRR_USBnnnnnn"];


    /* always set a usb$device variable */
    sprintf (str, "USB$Device_%02X_%02X_%02X_%04X_%04X_%02d_%02d_%04X_USB%d",
        class, subclass, protocol, vendor, product, config, interface, release,
        unit);

    if (aux->ifaceno != UHUB_UNK_INTERFACE)
    {
        usbd_device2interface_handle (aux->device, aux->ifaceno, &ifc);
    }

    char val[13];
    if (ifc)
    {
        sprintf (val, "%d %d %d", unit, aux->ifaceno, ifc->altindex);
    }
    else
    {
        sprintf (val, "%d", unit);
    }
    _kernel_setenv (str, val);

    if (sysvar_attach) return 0;

    for (int i = 0; i < 6; ++i)
    {
        if (aux->ifaceno == UHUB_UNK_INTERFACE)
        {
            switch (i)
            {
                case 0:
                    sprintf (str, "%s*_*_*_%04X_%04X___%04X_*",
                        alias, vendor, product, release);
                    break;
                case 1:
                    sprintf (str, "%s*_*_*_%04X_%04X___*_*",
                        alias, vendor, product);
                    break;
                case 2:
                    sprintf (str, "%s%02X_%02X_%02X_%04X_*___*_*",
                        alias, class, subclass, protocol, vendor);
                    break;
                case 3:
                    sprintf (str, "%s%02X_%02X_*_%04X_*___*_*",
                        alias, class, subclass, vendor);
                    break;
                case 4:
                    sprintf (str, "%s%02X_%02X_%02X_*_*___*_*",
                        alias, class, subclass, protocol);
                    break;
                case 5:
                    sprintf (str, "%s%02X_%02X_*_*_*___*_*",
                        alias, class, subclass);
                    break;
            }
        }
        else
        {
            switch (i)
            {
                case 0:
                    sprintf (str, "%s*_*_*_%04X_%04X_%02d_%02d_%04X_*",
                        alias, vendor, product, config, interface, release);
                    break;
                case 1:
                    sprintf (str, "%s*_*_*_%04X_%04X_%02d_%02d_*_*",
                        alias, vendor, product, interface, release);
                    break;
                case 2:
                    sprintf (str, "%s%02X_%02X_%02X_%04X_*_*_*_*_*",
                        alias, class, subclass, protocol, vendor);
                    break;
                case 3:
                    sprintf (str, "%s%02X_%02X_*_%04X_*_*_*_*_*",
                        alias, class, subclass, vendor);
                    break;
                case 4:
                    sprintf (str, "%s%02X_%02X_%02X_*_*_*_*_*_*",
                        alias, class, subclass, protocol);
                    break;
                case 5:
                    sprintf (str, "%s%02X_%02X_*_*_*_*_*_*_*",
                        alias, class, subclass);
                    break;
            }
        }
        _kernel_swi_regs r = {{ (int) str, 0, -1, 0, 0 }};
        _kernel_swi (OS_ReadVarVal, &r, &r);
        name = (char*) r.r[3];
        if (r.r[2]) goto match;
        dprintf (("", "Failed to match %s\n", str));
    }

    /* no match */
    return 0;

match:
    if (aux->ifaceno == UHUB_UNK_INTERFACE)
        sysvar_attach = true;

    len = strlen (name);

    dprintf (("", "Found match for %s\n", name));

    struct sysvar_callback* sc =
        malloc (sizeof *sc + len + strlen (val));

    sprintf (sc->com, "%.*s %s",
        len,
        name + sizeof "Alias$" - 1,
        val);

    sc->next = sysvar_head;
    sysvar_head = sc;

    return 0;
}

// remove any sysvars that are linked to this device
void kill_system_variable (int unit)
{
  char str[sizeof "DeviceFS$USBnnnnnn$Options   "];

  sprintf (str,"USB$Device_*_USB%d",unit);
  while (_swix (OS_SetVarVal, _INR(0,4), str, 0, -1, 0, 0) == NULL)
  {
      /* do nothing */
  }
  sprintf (str,"DeviceFS$USB%d$Options",unit);
  while (_swix (OS_SetVarVal, _INR(0,4), str, 0, -1, 0, 0) == NULL)
  {
      /* do nothing */
  }

}

/*---------------------------------------------------------------------------*/

_kernel_oserror* announce_device (_kernel_swi_regs* r, void* pw, void* sc)
{
    /* make sure we only announce once per device */
    if (announce_attach) return NULL;
    announce_attach = true;

    struct ugen_softc* softc = sc;
    char* serv = service_call (softc->sc_udev, softc->sc_dev.dv_unit, 0);
    if (serv == NULL) return NULL;
    dprintf (("", "Send USBDriver_Attach service call\n"));
    _swix (OS_ServiceCall, _INR(0,2),
        Service_USB_Attach,
        Service_USB,
        serv);
    free (serv);

    return NULL;
}

/*---------------------------------------------------------------------------*/

struct device* attach_device (struct device* parent, struct usb_attach_arg* aux, int no)
{
    _kernel_oserror* e = NULL;
    struct ugen_softc * softc;

    launch_system_variable (aux, no);

    /* only latch onto generic device */
    if (aux->usegeneric == 0) return NULL;

    /* If so, allocate memory for the device and attach ourselves. */
    softc = calloc (sizeof *softc, 1);
    if (softc == NULL) {
        dprintf (("", "Couldn't allocate memory for device\n"));
        return NULL;
    }
    softc->sc_dev.dv_cfdata = (void*) 2; // device

    softc->sc_udev = ((struct usb_attach_arg*)aux)->device;

    e= RegisterNewDevice( softc,no);

    if (e != NULL)
    {
        dprintf (("", "failed to register: %s\n", e->errmess));
        free (softc);
        return NULL;
    }

    dprintf (("", "registered driver %p\n", softc->sc_devfs));


    callx_add_callback (announce_device, softc);

    return (struct device*) softc;
}

/*---------------------------------------------------------------------------*/

int detach_device (struct device* dev, int d)
{
    struct ugen_softc * udev = (struct ugen_softc*) dev;

    if (udev->sc_devfs)
    {
        _swix (DeviceFS_Deregister, _IN(0), udev->sc_devfs);
    dprintf (("", "deregistered driver %p\n", udev->sc_devfs));
    }
   /* Cancel any pending callbacks attached to this device */
   callx_remove_callback(announce_device,udev);
   free (udev);
   return 0;
}

/*---------------------------------------------------------------------------*/

void uhub_activate (void)
{}

/*---------------------------------------------------------------------------*/

extern void usb_discover (void*);

_kernel_oserror* discover_callback (_kernel_swi_regs* r, void* pw, void* sc)
{
    struct usbd_bus* bus = sc;
    struct device* dev;
    dprintf (("", "bus discover %p\n",bus));
    TAILQ_FOREACH(dev, &allbuses, dv_list)
    {
        /* XXX this is dodgy, because in the case where the OHCIDriver module
           has removed its memory, 'bus' is no longer a valid pointer, and
           could either cause an abort or accidentally contain a valid usbctl */
     dprintf(("","dev:%p uctl:%p \n",dev,bus->usbctl));
        if (dev == (struct device*) bus->usbctl)
            goto valid;
    }

    dprintf (("", "bus %p has been removed\n",bus));
    if(bus) bus->callbacks=0;
    return NULL;

valid:
#ifdef STANDALONE
    _swix (Hourglass_On, 0);
    _swix (Hourglass_LEDs, _INR(0,1), 1, 0);
#endif
    dprintf (("", "discovering %p\n",dev));
    do {
        usb_discover (bus->usbctl);
#ifdef STANDALONE
        _swix (Hourglass_LEDs, _INR(0,1), 3, 3);
#endif
    } while (--bus->callbacks);
    #ifdef USB_DEBUG
    dprintf (("", "finished callbacks, total sleep = %d\n", total_sleep));
    #else
    dprintf (("", "finished callbacks\n"));
    #endif
#ifdef STANDALONE
    _swix (Hourglass_Off, 0);
#endif
    return NULL;
}

/*---------------------------------------------------------------------------*/

void usb_needs_explore_callback (void* h) {
    struct usbd_bus* bus = h;
#ifdef USB_DEBUG
    total_sleep = 0;
#endif
    if (bus->callbacks>9) bus->callbacks=9;
    if (bus->callbacks++ == 0)
    {
        dprintf (("", "Adding explore callback on bus %p\n",h));
        callx_add_callback (discover_callback, h);
    }
    else
        dprintf (("", "deferring callback on bus %p - %d callbacks queued\n",bus, bus->callbacks));
}

/*---------------------------------------------------------------------------*/

void bufrem (void* dma, void* priv_id, int size)
{
    if (priv_id == NULL)
    {
        dprintf (("", "Stream has been closed\n"));
        return;
    }

    _kernel_swi_regs r;
    r.r[0] = BM_ExamineBlock;
    r.r[1] = (int) priv_id;
    r.r[2] = (int) dma;
    r.r[3] = size;
    CallBufMan (&r);
}

/*---------------------------------------------------------------------------*/

void bufins (void* dma, void* x)
{
    usbd_xfer_handle xfer = x;
    struct devstream* str = xfer->priv;
    int actlen = xfer->actlen;

    if (str->fs_stream == 0)
    {
        dprintf (("", "Stream has been closed\n"));
        return;
    }

    /* if we have a report setting, then search for the appropriate stream */
    if (str->report != 0xdeaddead)
    {
        /* buffer insert is always going to be an IN endpoint, so we always
           need to add 16 */
        int index = UE_GET_ADDR(str->ep) + 16;
        str = str->ugen->str[index];
        while (str->report != *(char*) dma)
        {
            str = str->next_hid;
            if (str == NULL)
            {
                dprintf (("", "*** run out of chained hids"));
                return;
            }
        }
        dma = ((char*) dma) + 1;
        actlen--;
    }

    str->count += actlen;
//    dprintf (("", "inserting %d bytes, total %d\n",
//        actlen, str->count));

    _kernel_swi_regs r;
    r.r[0] = BM_InsertBlock;
    r.r[1] = (int) str->buffer_id;
    r.r[2] = (int) dma;
    r.r[3] = actlen;
    CallBufMan (&r);
}

void usbd_devinfo_vp(usbd_device_handle dev, char* v, size_t vl, char* p, size_t pl, int usedev)
{
    _kernel_oserror* e = NULL;
    usb_device_descriptor_t *udd = &dev->ddesc;
    char *vendor = NULL, *product = NULL;

    if (dev == NULL) {
        v[0] = p[0] = '\0';
        return;
    }

    dprintf (("", "Looking up v = %x, p = %x\n",
        UGETW(udd->idVendor), UGETW(udd->idProduct)));

    if (usedev)
    {
        char string[USB_MAX_STRING_LEN];

        vendor = usbd_get_string(dev, udd->iManufacturer, string);
        strncpy(v, ltrim(string), vl);
        product = usbd_get_string(dev, udd->iProduct, string);
        strncpy(p, ltrim(string), pl);
    }

    if (vendor == NULL) {
        char str[10];
        sprintf (str, "V%04X",
            UGETW(udd->idVendor));
        e = _swix (MessageTrans_Lookup, _INR(0,3)|_OUT(2),
            &usbdev_messages,
            str,
            v,
            vl,
            &vendor);
        dprintf (("", "lookup '%s' returned '%s' e = %s\n",
            str, vendor? vendor: "(null)", e? e->errmess: "NULL"));
    }

    if (product == NULL) {
        char str[10];
        sprintf (str, "P%04X%04X",
            UGETW(udd->idVendor),
            UGETW(udd->idProduct));
        e = _swix (MessageTrans_Lookup, _INR(0,3)|_OUT(2),
            &usbdev_messages,
            str,
            p,
            pl,
            &product);
        dprintf (("", "lookup '%s' returned '%s' e = %s\n",
            str, product? product: "(null)", e? e->errmess: "NULL"));
    }

    if (vendor == NULL) {
        char id[5];
        sprintf(id, "%04X", UGETW(udd->idVendor));
        _swix (MessageTrans_Lookup, _INR(0,4), &mod_messages,
               "DefVID", v, vl, id);
    }

    if (product == NULL) {
        char id[5];
        sprintf(id, "%04X", UGETW(udd->idProduct));
        _swix (MessageTrans_Lookup, _INR(0,4), &mod_messages,
               "DefPID", p, pl, id);
    }
}

void softintr_schedule (void* p)
{
    *(void**)p = (void*) softintr_entry;
}

int softintr (_kernel_swi_regs* r, void* pw)
{
    static volatile int reentry = 0;

//    dprintf (("", "entering soft interrupt %d\n", reentry));
    _kernel_irqs_off ();
    if (reentry++ == 0)
        while (reentry > 0)
        {
            reentry--;
//            dprintf (("", "reentry now %d\n", reentry));
            _kernel_irqs_on ();
            struct usbd_bus* sc = (struct usbd_bus*) r->r[0];
            sc->methods->soft_intr (sc);
            _kernel_irqs_off ();
        }

    _kernel_irqs_on ();
//    dprintf (("", "leaving soft interrupt %d\n", reentry));

    return 0;
}

/*--------------------------------------------------------------------------*/

/* devicefs interface */

typedef struct device_valid {
    uint32_t    endpoint;
    uint32_t    interface;
    uint32_t    alternate;
    uint32_t    report;
    uint32_t    ep_type;
    uint32_t    timeout;
    uint32_t    size;
    uint32_t    nopad;
    uint32_t    shortflag;
} device_valid;

static void find_interface_and_endpoint
(
    usbd_device_handle  dev,
    device_valid *      valid,
    uint32_t            dir,
    int*                iface_return,
    int*                alternate_return,
    int*                endpoint_return
)
{
    int                             i, j;
    usb_interface_descriptor_t *    d;
    usb_endpoint_descriptor_t *     b;

   /* if neither the ep_type nor the endpoint number were given in the special
      fields, try to find first bulk endpoint */
    if ((valid->ep_type == 0xdeaddead) && (valid->endpoint == 0xdeaddead))
    {
        valid->ep_type = UE_BULK;
    }

    dprintf (("", "looking for %x, iface %d, alt %d, type %x, dir %x\n",
        valid->endpoint, valid->interface, valid->alternate,
        valid->ep_type, dir));

    usb_config_descriptor_t * cdesc = dev->cdesc;
    char* ptr = (char*) cdesc, *ptr_end = ptr + UGETW(cdesc->wTotalLength);
    ptr += cdesc->bLength;
    i = j = -1;
    while (ptr < ptr_end)
    {
        switch (ptr[1])
        {
        case UDESC_INTERFACE:
            d = (usb_interface_descriptor_t*) ptr;
            i = d->bInterfaceNumber;
            j = d->bAlternateSetting;
            dprintf (("", "interface %d\n", i));
            break;
        case UDESC_ENDPOINT:
            if (i == -1) break;
            b = (usb_endpoint_descriptor_t *) ptr;
            dprintf (("", "endpoint %x\n", b->bEndpointAddress));
            dprintf (("", "attributes %x\n", UE_GET_XFERTYPE(b->bmAttributes)));

            /* try to match as many of the fields that have been supplied as possible,
               but the direction flag must always be correct */
            if ((valid->interface == i || valid->interface == 0xdeaddead) &&
                (valid->alternate == j || valid->alternate == 0xdeaddead) &&
                (valid->endpoint == UE_GET_ADDR(b->bEndpointAddress) || valid->endpoint == 0xdeaddead) &&
                (valid->ep_type == UE_GET_XFERTYPE(b->bmAttributes) || valid->ep_type == 0xdeaddead) &&
                /* bit is set for TX, whereas USB is set for IN */
                (((dir & 1) << 7) != UE_GET_DIR(b->bEndpointAddress)))
            {
                *iface_return = i;
                *alternate_return = j;
                *endpoint_return = b->bEndpointAddress;
                valid->ep_type = UE_GET_XFERTYPE(b->bmAttributes);
                return;
            }
            break;
        }
        ptr += ptr[0];
    }
    dprintf (("", "couldn't find an endpoint\n"));
    *iface_return = (int) 0xdeaddead;
    *alternate_return = (int) 0xdeaddead;
    *endpoint_return = (int) 0xdeaddead;
    return;
}

/*---------------------------------------------------------------------------*/

static _kernel_oserror* device_initialise
(
    int                 devicefs_handle,
    uint32_t            flags,
    device_valid *      valid,
    struct ugen_softc * ugen,
    struct devstream ** stream_handle
)
{
    int ep;
    int err;
    int iface;
    int alt = 0;
    int index = -1;
    _kernel_oserror* e = NULL;
    dprintf (("", "device_initialise: flags = %x, fs_stream = %x\n",
        flags, devicefs_handle));

    struct devstream* str = malloc (sizeof *str);
    if (str == NULL)
    {
        return uerror (E_NoMem);
    }
    memset (str, 0, sizeof *str);
    str->size = valid->size;

    str->ugen = ugen;

    /* XXX we should validate the report at this point */
    str->report = valid->report;

    /* usb timeout, used for transfers */
    str->timeout = (valid->timeout==0xdeaddead?0:valid->timeout);

    /* New flags to work around deficencies in the DeviceFS interface */
    str->flags = (valid->nopad?0:FLAG_NOPAD)|(valid->shortflag?0:FLAG_SHORT);

    str->read_status = ReadStatus_Idle;

    /* The supplied endpoint may include the direction, but mask it off internally */
    if (valid->endpoint != 0xdeaddead) valid->endpoint = UE_GET_ADDR(valid->endpoint);

    /* see if an interface was specified, if not then look for the interface
       with the endpoint specified */
    find_interface_and_endpoint
    (
        ugen->sc_udev,
        valid,
        flags,
        &iface,
        &alt,
        &ep
    );
    dprintf (("", "init_dev: found interface %x, endpoint %x\n", iface, ep));

    if (iface == 0xdeaddead)
    {
        e = uerror (E_NoEndpoint);
        goto error;
    }

    err = usbd_device2interface_handle (ugen->sc_udev, iface, &str->iface);
    if (err)
    {
        e = uerror (E_NoInterface);
        goto error;
    }

    /* force an interface alternate */
    if (alt != 0)
        usbd_set_interface(str->iface, alt);


    str->ep = ep;


    /* remove an internally connected device to this interface */
    for (int n = 0; ugen->sc_udev->subdevs[n]; ++n)
    {
        struct iface_softc* ifc;
        /* throw off mice or keyboards */

        switch ((int) (ugen->sc_udev->subdevs[n]->dv_cfdata))
        {
        case 3:
        case 4:
            ifc = (struct iface_softc*) ugen->sc_udev->subdevs[n];
            if (ifc->sc_iface->index == iface)
            {
                dprintf (("", "throwing off subdevice %d\n", n));
                /* compact the list first  */
                do
                {
                    ugen->sc_udev->subdevs[n] = ugen->sc_udev->subdevs[n + 1];
                    n++;
                }
                while (ugen->sc_udev->subdevs[n] != 0);
                config_detach ((struct device*)ifc, 0);
                goto detach_done;
            }
            break;
        }

    }
detach_done:

    index = UE_GET_ADDR(ep) + (UE_GET_DIR(ep)? 16: 0);

    /* if the stream is already used, it might have been left open,
       we're opening a HID report descriptor, or it's a mistake */
    if (ugen->str[index] != NULL && ugen->str[index]->fs_stream != 0)
    {
        if (valid->report == 0xdeaddead)
        {
            dprintf (("", "Endpoint in use, fs_stream = %x\n",
                ugen->str[index]->fs_stream));
            e = uerror (E_EndpointUsed);
            goto error;
        }

        /* it's a HID report, so link to the chain, and don't bother opening
           the pipe - we need to remember to unlink properly when we close */
        str->next_hid = ugen->str[index];
        ugen->str[index] = str;
        str->fs_stream = devicefs_handle;
        str->pipe = str->next_hid->pipe; // record pipe so that we find endpoint description
        *stream_handle = str;
        return NULL;
    }
    else if (ugen->str[index] != NULL)
    {
        /* it is a previously used endpoint left open */
        str->pipe = ugen->str[index]->pipe;
        str->xfer = ugen->str[index]->xfer;
    }


    if (str->pipe == NULL) err = usbd_open_pipe(str->iface, ep, 0, &str->pipe);
    if (err)
    {
        dprintf (("", "Couldn't open pipe, err = %d", err));
        str->pipe = NULL;
        e = uerror (E_BadPipe);
        goto error;
    }

    if (str->xfer == NULL)
    {
        if ((str->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) == UE_ISOCHRONOUS)
        {
            str->isoc = calloc (sizeof *str->isoc, 2);
            str->isoc[0].xfer = usbd_alloc_xfer (ugen->sc_udev);
            str->isoc[1].xfer = usbd_alloc_xfer (ugen->sc_udev);
            str->xfer = str->isoc[0].xfer;
        }
        else
        {
            str->xfer = usbd_alloc_xfer (ugen->sc_udev);
        }
    }

    dprintf(("","Got xfer %08x\n",str->xfer));

    if (str->xfer == NULL)
    {
        e = uerror (E_BadXfer);
        goto error;
    }

    if ((str->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) == UE_INTERRUPT)
    {
        str->pipe->repeat = (UE_GET_DIR(str->ep) == UE_DIR_IN)?1:0;
    }

    str->fs_stream = devicefs_handle;
    *stream_handle = str;
    ugen->str[index] = str;
    return NULL;
error:
    if (str->pipe)
        usbd_close_pipe (str->pipe);
    if (str->xfer)
        usbd_free_xfer (str->xfer);
    if (str->isoc != NULL)
    {
        if (str->isoc[1].xfer)
        {
            usbd_free_xfer (str->isoc[1].xfer);
        }
        free (str->isoc);
    }
    free (str);
    return e;
}

/*---------------------------------------------------------------------------*/

void start_write (struct devstream* str);
void start_read (struct devstream* str);

static void write_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
                      usbd_status status)
{
    struct devstream* str = priv;

    dprintf(("","%08x write_cb, status=%d, actlen=%d\n",xfer,status,xfer->actlen));

    str->xfer_busy = (status == USBD_IN_PROGRESS);

    if (status != USBD_NORMAL_COMPLETION)
    {
        dprintf (("", "Bad completion code: %d (%s), %d bytes written\n", status, ccodes[status], xfer->actlen));
        return;
    }

    if (str->fs_stream == 0)
    {
        dprintf (("", "Stream has been closed\n"));
        return;
    }

#ifndef DMA_FROM_BUFFER
    _kernel_swi_regs r;
    r.r[0] = BM_NextFilledBlock;
    r.r[1] = (int) str->buffer_id;
    r.r[3] = xfer->actlen;
    CallBufMan(&r);
#endif
    start_write (str);
}

/*---------------------------------------------------------------------------*/

void start_write (struct devstream* str)
{
    int s = _kernel_irqs_disabled ();
    _kernel_irqs_off ();

    dprintf(("","%08x start_write\n",str->xfer));

    if (str->xfer == NULL)
    {
        dprintf (("", "Non-head HID stream\n"));
        goto end;
    }

    if (str->xfer_busy)
    {
        dprintf (("", "Can't start, xfer still busy\n"));
        goto end;
    }

    if (str->xfer->status != USBD_NORMAL_COMPLETION)
    {
        dprintf (("", "Can't start, status = %d (%s)\n",
            str->xfer->status, ccodes[str->xfer->status]));
        goto end;
    }

    str->xfer_busy = true;

#ifdef DMA_FROM_BUFFER
    _kernel_swi_regs r;
    r.r[0] = BM_NextFilledBlock;
    r.r[1] = str->buffer_id;
    r.r[3] = str->xfer->actlen;
    CallBufMan(&r);
#else
    _kernel_swi_regs r;
    r.r[0] = BM_UsedSpace;
    r.r[1] = str->buffer_id;
    CallBufMan(&r);
#endif
    if (r.r[2] != 0)
    {
#ifdef DMA_FROM_BUFFER
        usbd_setup_xfer(str->xfer, str->pipe, str,
            (void*) r.r[2], r.r[3], USBD_NO_COPY | (str->flags & FLAG_SHORT?USBD_FORCE_SHORT_XFER:0), 500, write_cb);
#else
        usbd_setup_xfer(
            str->xfer,
            str->pipe,
            str,
            (void*) str->buffer_id,
            r.r[2],
            (str->flags & FLAG_SHORT?USBD_FORCE_SHORT_XFER:0),
            str->timeout,
            write_cb);

        str->xfer->rqflags |= URQ_RISCOS_BUF;
        dprintf (("", "transferring %d bytes\n", r.r[2]));
#endif
        str->xfer->status = usbd_transfer (str->xfer);

        str->xfer_busy = (str->xfer->status == USBD_IN_PROGRESS);

        /* this can either return in progress, or normal completion (if
           the pipe wasn't already running) */
        if (str->xfer->status != USBD_IN_PROGRESS &&
            str->xfer->status != USBD_NORMAL_COMPLETION)
        {
            dprintf (("", "Failed to insert transfer, status = %d (%s)\n",
                str->xfer->status, ccodes[str->xfer->status]));
        }
    }
    else
    {
        str->xfer->actlen = 0;
        str->xfer_busy = false;
        dprintf (("", "no more data to write\n"));
    }

end:
    if (s == 0) _kernel_irqs_on ();
}

/*---------------------------------------------------------------------------*/

static void read_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
                      usbd_status status)
{
    struct devstream* str = priv;
    bool delayed_read = str->delayed_read && !xfer->pipe->repeat;

    dprintf(("","%08x read_cb, status=%d, actlen=%d, delayed_read=%d, read_status=%d\n",xfer,status,xfer->actlen,delayed_read,str->read_status));

    str->xfer_busy = false;

    if (status != USBD_NORMAL_COMPLETION)
    {
        dprintf (("", "Bad completion code: %d (%s) %d bytes read\n",
            status, ccodes[status], xfer->actlen));
        str->delayed_read = false;
        str->read_status = ReadStatus_Complete;
        return;
    }

    if (str->fs_stream == 0)
    {
        dprintf (("", "Stream has been closed\n"));
        str->delayed_read = false;
        str->read_status = ReadStatus_Complete;
        return;
    }

    if((str->flags & FLAG_NOPAD) || (str->count == str->totalcount))
    {
        str->read_status = ReadStatus_Complete;
        /* Handle any delayed read */
        if(delayed_read)
        {
            dprintf(("", "Starting delayed read from callback\n"));
            start_read(str);
        }
        return;
    }
    /* only start another transfer if we haven't finished the transfer and
       this is not a interrupt endpoint (the BSD framework restarts
       repeating transfers) */
    /* if we've got a number of bytes including a part packet, then
       transfer must have ended.. else.. try more */
    if (xfer->actlen % UGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize))
    {
        str->read_status = ReadStatus_Complete;

        /* required due to DeviceFS concept. */
        char zero[ UGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize)];

        /* Note difference for later correction by application */
        int remain = str->padded_bytes = str->totalcount - str->count;
        memset (zero, 0, sizeof zero);
        /* fill up the rest of the request with garbage! */
        _kernel_swi_regs r;
        r.r[0] = BM_InsertBlock;
        r.r[1] = (int) str->buffer_id;
        while(remain > 0)
        {
            r.r[2] = (int) zero;
            r.r[3] = min(remain,UGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize));
            remain -= r.r[3];
            CallBufMan (&r);
            if(r.r[3])
                break; /* Buffer was full - what do we do here? Try and insert the extra padding as more space becomes available? For now, just do what the old code did and give up */
        }
        /* Handle any delayed read */
        if(delayed_read)
        {
            dprintf(("", "Starting delayed read from callback\n"));
            start_read(str);
        }
    }
    else if (!xfer->pipe->repeat)
    {
        dprintf (("", "Starting read from callback\n"));
        start_read (str);
    }
}

/*---------------------------------------------------------------------------*/

void fill_isoc_xfer (struct devstream* str, int maxpacket)
{
    str->size = maxpacket;
    str->xfer->actlen = 0;
    usbd_setup_isoc_xfer(
        str->xfer,
        str->pipe,
        str,
        (u_int16_t*) &str->size,         /* sizes */
        1,                  /* n frames */
        USBD_SHORT_XFER_OK,
        read_cb);
    str->xfer->buffer = (void*) str->buffer_id;
    str->xfer->length = maxpacket;
}

void start_read (struct devstream* str)
{
    int s = _kernel_irqs_disabled ();
    _kernel_irqs_off ();

    dprintf(("","%08x start_read busy %d delayed %d read_status %d\n",str->xfer,str->xfer_busy,str->delayed_read,str->read_status));
    if (str->xfer == NULL)
    {
        dprintf (("", "Non-head HID stream\n"));
        goto end;
    }

    if (str->xfer_busy)
    {
        dprintf (("", "Can't start, xfer still busy\n"));
        goto end;
    }

    if (str->xfer->status != USBD_NORMAL_COMPLETION)
    {
        dprintf (("", "Can't start, status = %d (%s)\n",
            str->xfer->status, ccodes[str->xfer->status]));
        goto end;
    }

    if ((str->read_status == ReadStatus_Busy) && (str->count >= str->totalcount) && !str->xfer->pipe->repeat)
    {
        dprintf (("", "Finished reading %d bytes\n", str->totalcount));
        str->read_status = ReadStatus_Complete;
        if(!str->delayed_read)
            goto end;
        dprintf (("", "Falling through to start delayed read\n"));
    }


    if(!str->pipe->repeat)
    {
        /* Only use this logic for non-repeating xfers (i.e. only for bulk) */
        if(str->read_status != ReadStatus_Busy)
        {
            /* Starting a new transfer queued by RxWakeUp */
            if(!str->delayed_read)
            {
                dprintf(("","Can't start, no wakeup reads queued\n"));
                goto end;
            }
            dprintf(("","Starting new read of %d bytes\n",str->nextcount));
            str->delayed_read = false;
            str->totalcount = str->nextcount;
            str->count = 0;
            str->padded_bytes = 0;
            str->read_status = ReadStatus_Busy;
        }
        else
        {
            dprintf(("","Continuing read of %d bytes\n",str->totalcount));
        }
    }
    str->xfer_busy = true;

#ifdef DMA_FROM_BUFFER
    // XXX this was copied from write probably wrong for read
    _kernel_swi_regs r;
    r.r[0] = BM_NextFilledBlock;
    r.r[1] = str->buffer_id;
    r.r[3] = str->xfer->actlen;
    CallBufMan(&r);
#else
    _kernel_swi_regs r;
    r.r[0] = BM_FreeSpace;
    r.r[1] = str->buffer_id;
    CallBufMan(&r);
#endif
    int actlen = r.r[2];
    int maxpacket = UGETW(str->pipe->endpoint->edesc->wMaxPacketSize);
    if (actlen >= maxpacket)
    {
        switch (str->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE)
        {
        case UE_INTERRUPT:
        case UE_ISOCHRONOUS:
            /* if an interrupt endpoint, ask for exactly max packet */
            actlen = maxpacket;
            break;

        case UE_BULK:
            /* only ask for multiple of maxpacket if bulk */
            actlen -= actlen % maxpacket;

            /* truncate at length requested */
            if (str->totalcount && actlen > str->totalcount - str->count)
                actlen = str->totalcount - str->count;
            if (actlen <= 0)
            {
                str->xfer_busy = false;
                goto end;
            }
            break;
        }

#ifdef DMA_FROM_BUFFER
        /* this almost definitely doesn't work any more */
        usbd_setup_xfer(
            str->xfer,
            str->pipe,
            str,
            (void*) r.r[2],
            r.r[3],
            USBD_NO_COPY|USBD_SHORT_XFER_OK,
            500,
            read_cb);
#else
        switch (str->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) {
        case UE_BULK:
        case UE_INTERRUPT:
            usbd_setup_xfer(
                str->xfer,
                str->pipe,
                str,
                (void*) str->buffer_id,
                actlen,
                USBD_SHORT_XFER_OK,
                str->timeout,
                read_cb);
            dprintf (("", "starting (bulk/interrupt) transfer of %d bytes\n",
                actlen));
            break;
        case UE_ISOCHRONOUS:
            fill_isoc_xfer (str, maxpacket);
            dprintf (("", "starting (isoc) transfer of %d bytes\n", str->size));
            break;
        }

        str->xfer->rqflags |= URQ_RISCOS_BUF;
#endif
        str->xfer->status = usbd_transfer (str->xfer);

        str->xfer_busy = (str->xfer->status == USBD_IN_PROGRESS);

        /* this can either return in progress, or normal completion (if
           the pipe wasn't already running) */
        if (str->xfer->status != USBD_IN_PROGRESS &&
            str->xfer->status != USBD_NORMAL_COMPLETION)
        {
            dprintf (("", "Failed to insert transfer, status = %d (%s)\n",
                str->xfer->status, ccodes[str->xfer->status]));
        }
    }
    else
    {
        str->xfer_busy = false;
    }
end:
    if (s == 0) _kernel_irqs_on ();
}

/*---------------------------------------------------------------------------*/

void terminate_stream (struct ugen_softc* ugen, struct devstream * str, int kill)
{
    dprintf (("", "terminate stream %p, ep %x, kill = %d\n",
        str, str?str->ep:0, kill));

    if (str == NULL)
    {
        return;
    }

    int index = UE_GET_ADDR(str->ep) + (UE_GET_DIR(str->ep)? 16: 0);

    /* don't remove stream twice! */
    if (ugen->str[index] == NULL)
    {
      return;
    }

    /* in case we were a multiply linked HID reporter, don't close the pipe */
    if (ugen->str[index]->next_hid == NULL)
    {
        if (kill)
        {
            int status;
            if (str->dying || !str->pipe) return;
            str->dying = 1;
            /* only close these when the device is removed */
            status = usbd_abort_pipe(str->pipe);
            dprintf (("", "status1: %s\n", ccodes[status]));
            status = usbd_close_pipe(str->pipe);
            dprintf (("", "status2: %s\n", ccodes[status]));
//            usbd_free_buffer (str->xfer);    /* done in usbd_free_xfer
            status = usbd_free_xfer(str->xfer);
            dprintf (("", "status3: %s\n", ccodes[status]));
            ugen->str[index] = NULL;
        }
        else
        {
            /* normally just null these entries, so the same endpoint gets
               used next time and toggling carries on */
            str->fs_stream = 0;
            str->buffer = 0;
            str->buffer_id = 0;
            str->report = 0;
            dprintf (("", "fs_stream now 0\n"));

            /* return early so we don't free the stream */
            return;
        }
    }
    else
    {
        /* otherwise, make sure we don't lose the handles, and keep the chain
           going.   */
        dprintf (("", "delinking HID stream, ep=%x\n", str->ep));
        struct devstream* s = ugen->str[index];
        if (s != str)
        {
            while (s->next_hid != str)
            {
                s = s->next_hid;
                if (s == NULL)
                {
                    dprintf (("", "*** couldn't find HID stream"));
                    return;
                }
            }

            s->next_hid = str->next_hid;
        }
        else
        {
            /* special case replacing the head */
            s = ugen->str[index] = str->next_hid;
        }
        if (str->pipe)
        {
            s->pipe = str->pipe;
            s->xfer = str->xfer;
        }
    }
    free (str);
}

/*---------------------------------------------------------------------------*/

_kernel_oserror* create_buffer
(
    struct devstream*   str,
    uint32_t            *flags,
    size_t              *size,
    uint32_t            *handle,
    size_t              *thresh
)
{
    _kernel_oserror* e = NULL;
    char* p;

    /* if we are a multiple HID device, this just return */
    if (str->xfer == NULL)
    {
        dprintf (("", "multiple HID device: str->xfer == NULL\n"));
        return NULL;
    }

    if (str->size != 0xdeaddead)
        *size = str->size;

    if ((str->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) == UE_ISOCHRONOUS)
    {
        p = usbd_alloc_buffer (str->isoc[0].xfer, *size / 2);
        if (p == NULL) return uerror (E_NoMem);
        p = usbd_alloc_buffer (str->isoc[1].xfer, *size / 2);
        if (p == NULL) return uerror (E_NoMem);
    }
    else
    {
        p = usbd_alloc_buffer (str->xfer, *size);
        if (p == NULL) return uerror (E_NoMem);
#ifdef DMA_FROM_BUFFER
        e = _swix (Buffer_Register, _INR(0,3)|_OUT(0),
            *flags,
            p,
            p + *size,
            -1,
            handle);
#endif
    }
    *thresh = *size - UGETW(str->pipe->endpoint->edesc->wMaxPacketSize);
    return e;
}

/*---------------------------------------------------------------------------*/

_kernel_oserror* get_buffer_space
(
    struct ugen_softc*  udev,
    int                 fs,
    int*                size,
    int*                free
)
{
    int devfs;
    _kernel_oserror* e =
        _swix (OS_FSControl, _INR(0,1)|_OUT(1), 21, fs, &devfs);
    if (e) return e;

    for (int i = 0; i < sizeof (udev->str) / sizeof (udev->str[0]); ++i)
    {
        if (udev->str[i] && udev->str[i]->fs_stream == devfs)
        {
            int f;
            _kernel_swi_regs r;
            r.r[0] = BM_FreeSpace;
            r.r[1] = udev->str[i]->buffer_id;
            CallBufMan(&r);
            f = r.r[2];
            if (free) *free = f;

            r.r[0] = BM_UsedSpace;
            CallBufMan(&r);
            if (size) *size = *free + r.r[2];
            return NULL;
        }
    }

    return uerror (E_NoStream);
}

/*---------------------------------------------------------------------------*/

_kernel_oserror* get_handles
(
    struct ugen_softc*  udev,
    int                 fs,
    int*                buf,
    int*                dvfs,
    struct devstream ** str,
    devicefs_device**   sc_devfs
)
{
    int devfs;
    _kernel_oserror* e =
        _swix (OS_FSControl, _INR(0,1)|_OUT(1), 21, fs, &devfs);
    if (e) return e;

    for (int i = 0; i < sizeof (udev->str) / sizeof (udev->str[0]); ++i)
    {
        if (udev->str[i] && udev->str[i]->fs_stream == devfs)
        {
            if (dvfs) *dvfs = devfs;
            if (buf) *buf = udev->str[i]->buffer;
            if (str) *str=udev->str[i];
            if (sc_devfs) *sc_devfs=udev->sc_devfs;
            return NULL;
        }
    }

    return uerror (E_NoStream);
}

_kernel_oserror* get_location
(
    struct ugen_softc*  udev,
    char*               location
)
{
    if (location == NULL) return NULL;

    usbd_device_handle dev = udev->sc_udev;
    memset (location, 0, 6);
    while (dev->depth > 0) {
        dprintf (("main", "%d, %d\n", dev->powersrc->portno, dev->depth));
        location[dev->depth] = dev->powersrc->portno;
        dev = dev->powersrc->parent;
    };
    location[0] = dev->bus->bdev.dv_unit;

    return NULL;
}

_kernel_oserror* clear_endpoint_stall
(
    struct ugen_softc*  udev,
    int                 fs
)
{
    int devfs;
    _kernel_oserror* e =
        _swix (OS_FSControl, _INR(0,1)|_OUT(1), 21, fs, &devfs);
    if (e) return e;

    for (int i = 0; i < sizeof (udev->str) / sizeof (udev->str[0]); ++i)
    {
        if (udev->str[i] && udev->str[i]->fs_stream == devfs)
        {
            int err = usbd_clear_endpoint_stall (udev->str[i]->pipe);
#if 1
            if (err != 0) return uerror (E_BadRequest);
#else
            if (err != 0)
            {
                static _kernel_oserror e;
                char cc[5], *cp;
                sprintf (cc, "CC%02d", err);
                _swix (MessageTrans_Lookup, _INR(0,2)|_OUT(2),
                    &mod_messages, cc, 0, &cp);
                return _swix (MessageTrans_ErrorLookup, _INR(0,4),
                    E_BadRequest, &mod_messages, &e, sizeof e, cp);
            }
#endif

            udev->str[i]->xfer->status = USBD_NORMAL_COMPLETION;
            return NULL;
        }
    }

    return uerror (E_NoStream);
}

_kernel_oserror* get_transfer_info
(
    struct devstream*  str,
    int*               count,
    int*               totalcount,
    int*               status,
    int*               padded_buffer_bytes
)
{
    if (!str) {
      return uerror (E_NoStream);
      }
    *count=str->count;
    *totalcount=str->totalcount;
    switch(str->xfer->status) {
      case USBD_NORMAL_COMPLETION: {
        /* If we've got a delayed xfer, claim we're still running
           Matches old behaviour before the delayed xfer code was introduced */
        *status=(str->delayed_read?0:1);
        }
      break;
      case USBD_IN_PROGRESS: {
        *status=0;
        }
      break;
      default: {
        *status=-1;
        }
      }
    *padded_buffer_bytes=str->padded_bytes;
    return NULL;
}

_kernel_oserror* getset_options
(
    struct devstream*  str,
    int*               eor,
    int*               and
)
{
    if (!str) {
      return uerror (E_NoStream);
      }
    int new = ((str->flags & *and) ^ *eor) & FLAG_VALIDMASK;
    *eor = str->flags;
    str->flags = *and = new;
    return NULL;
}

/*---------------------------------------------------------------------------*/

_kernel_oserror* driver (_kernel_swi_regs* r, void* pw)
{
//    _kernel_oserror* e = NULL;
    struct ugen_softc* udev = (struct ugen_softc*) r->r[8];
//    int32_t ep;
    struct devstream * str = (struct devstream*) r->r[2];
    int s;

    (void) pw;

//    if (r->r[0] != 12) dprintf (("", "devfs driver reason %d, dev %p, str %p\n",
//        r->r[0], udev, str));
    switch ((uint32_t) r->r[0])
    {
    case DeviceCall_Initialise:
        return device_initialise
        (
            r->r[2],
            r->r[3],
            (device_valid *) r->r[6],
            udev,
            (struct devstream **) (r->r + 2)
        );
        break;

    case DeviceCall_Finalise:
        if (str == NULL)
        {
            for (struct devstream** str = udev->str;
                str < udev->str + sizeof udev->str / sizeof udev->str[0];
                ++str)
            {
                terminate_stream (udev, *str, 1);
            }
        }
        else
        {
            terminate_stream (udev, str, 1);
        }
        break;

    case DeviceCall_WakeUpTX:
        s = _kernel_irqs_disabled ();
        _kernel_irqs_off ();
        str->count = 0;
        dprintf (("main", "%08x wakeup write, resetting count to %d\n",
            str->xfer, str->count));
        start_write (str);
        if(s == 0) _kernel_irqs_on();
        break;
    case DeviceCall_WakeUpRX:
        if(!str->pipe->repeat && r->r[3])
        {
            s = _kernel_irqs_disabled ();
            _kernel_irqs_off ();
            /* Even if the read starts immediately, we still set the delayed_read flag, because that's what start_read checks for */
            str->delayed_read = true;
            /* total length has always been passed in R3, although not documented */
            str->nextcount = r->r[3];
            dprintf (("main", "%08x wakeup read, read_status %d, resetting nextcount to %d\n",
                str->xfer, str->read_status, str->nextcount));
            start_read (str);
            if(s == 0) _kernel_irqs_on();
        }
        break;
    case DeviceCall_SleepRX:
        break;
    case DeviceCall_EnumDir:
        break;
    case DeviceCall_CreateBufferTX:
    case DeviceCall_CreateBufferRX:
        return create_buffer (
            (struct devstream*) r->r[2],
            (uint32_t*)r->r + 3,
            (size_t*)r->r + 4,
            (uint32_t*)r->r + 5,
            (size_t*)r->r + 6);
        break;
    case DeviceCall_Halt:
        break;
    case DeviceCall_Resume:
        dprintf (("main", "%08x resume ep = %x\n", str->xfer, str->ep));
        /* if the top bit is set, this is an IN endpoint */
        if (UE_GET_DIR(str->ep) == UE_DIR_IN)
        {
            if (!str->pipe->repeat)
                start_read (str);
        }
        else start_write (str);
        break;
    case DeviceCall_EndOfData:
        /* this was to try and make bulk transfers finish neatly, but doesn't
           seem to achieve the desired effect */
        if (str->xfer->status == USBD_IN_PROGRESS)
            r->r[3] = 0;
        break;
    case DeviceCall_StreamCreated:
        str->buffer = r->r[3];
        _swix (Buffer_InternalInfo, _IN(0)|_OUTR(0,2),

            r->r[3],

            &str->buffer_id,
            &BuffManService,
            &BuffManWS);
        if (
            (str->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) ==
                UE_INTERRUPT ||
            (str->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) ==
                UE_ISOCHRONOUS
        )
        {
            /* obviously only do this if we're an in endpoint */
            if (UE_GET_DIR(str->ep) == UE_DIR_IN)
            {
              dprintf(("","%08x start_read from StreamCreated\n",str->xfer));
              start_read(str);
            }
        }
        break;
    case DeviceCall_MonitorTX:
    case DeviceCall_MonitorRX:
        {
            /* the xfer is NULL for case of HID not owning the xfer */
            if (str->xfer == NULL)
                return NULL;

            int status = str->xfer->status;
/* normal completion occurs when a transfer has finished */
            if (status == USBD_NORMAL_COMPLETION ||
                status == USBD_IN_PROGRESS)
                return NULL;


            _kernel_swi_regs r;

            /* empty the buffer so that we return */
            r.r[0] = BM_PurgeBuffer;
            r.r[1] = str->buffer_id;
            CallBufMan (&r);

            static _kernel_oserror err;
            char errtoken[sizeof E_XferFailed] = E_XferFailed, cc[5], *cp;
            ((_kernel_oserror *)errtoken)->errnum += status;
            sprintf (cc, "CC%02d", status);
            _swix (MessageTrans_Lookup, _INR(0,2)|_OUT(2),
                &mod_messages, cc, 0, &cp);
            return _swix (MessageTrans_ErrorLookup, _INR(0,4),
                errtoken, &mod_messages, &err, sizeof err, cp);
        }
        break;
    case DeviceCall_USB_USBRequest:
        {
            struct req { int a, b; } rq = (struct req) { r->r[3], r->r[4] };
            int err = usbd_do_request (udev->sc_udev, (void*) &rq, (char*)r->r[5]);
#if 1
            if (err != 0) return uerror (E_BadRequest);
#else
            if (err != 0)
            {
                static _kernel_oserror e;
                char cc[5], *cp;
                sprintf (cc, "CC%02d", err);
                _swix (MessageTrans_Lookup, _INR(0,2)|_OUT(2),
                    &mod_messages, cc, 0, &cp);
                return _swix (MessageTrans_ErrorLookup, _INR(0,4),
                    E_BadRequest, &mod_messages, &e, sizeof e, cp);
            }
#endif

            break;
        }
    case DeviceCall_USB_BufferSpace:
        return get_buffer_space (udev, r->r[2], r->r + 3, r->r + 4);
        break;
    case DeviceCall_USB_GetHandles:
        return get_handles (udev, r->r[2], r->r + 3, r->r + 4, NULL, NULL);
        break;
    case DeviceCall_USB_GetLocation:
        return get_location (udev, (char*) r->r[3]);
        break;
    case DeviceCall_USB_ClearStall:
        return clear_endpoint_stall (udev, r->r[2]);
        break;
    case DeviceCall_USB_TransferInfo:
        return get_transfer_info (str, r->r + 0, r->r + 1, r->r + 3, r->r + 4);
        break;
    case DeviceCall_USB_GetHandles2:
        return get_handles (udev, r->r[2], r->r + 3, r->r + 4, (struct devstream **) ((int *) r->r + 5), (devicefs_device**) ((int *) r->r + 6));
        break;
    case DeviceCall_USB_GetSetOptions:
        return getset_options (str, r->r + 3, r->r + 4);
        break;
    }

    return NULL;
}

/*--------------------------------------------------------------------------*/
@


1.61
log
@Messages fixes, internationalisation, minor clean ups
Detail:
  USBDriver was performing unnecessary messages file reopening on Service_ResourceFSStarted (MessageTrans does this itself), remove this.
  Internationalised USBDriver, in particular its *Commands.
  Fixed standalone builds to output the messages file objects in the right place (Makefile mistake).
  Changed OHCIDriver and EHCIDriver to use allocated error bases rather than 0.
  Sync'd, where possible, the OHCIDriver and EHCIDriver sources which share a common heritage. Tentative shared interrupt support fixes for non-PCI attached controllers. Comment blocks & indentation improved.
  Export min() macro in usb_port.h.
  CMHG updated to not listen for unwanted services.
Admin:
  Submission for USB bounty.
  Tested on Pandaboard and Pi 2. OHCIDriver untested but low risk.

Version 1.18. Tagged as 'NetBSD-1_18'
@
text
@d744 1
a744 1
    strcpy (string, lookupmsg (speed, NULL));             formatpair ("DISpd", width, string);
@


1.60
log
@Case change to match documentation
Detail:
  DeRegisterBus->DeregisterBus. Since clients calling this SWI are compiled C or assembler, this doesn't affect existing modules which remain binary compatible.
Admin:
  Submission for USB bounty.

Version 1.17. Tagged as 'NetBSD-1_17'
@
text
@a22 1
#include "bufman.h"
d31 2
a32 2
#include <sys/callout.h>
#include <sys/ioctl.h>
d51 1
d152 3
d159 2
a160 8
typedef struct messages {
    MessagesFD  fd;
    int         handle;
    bool        isopen;
    const char* filename;
} messages;
messages mod_messages = { .filename = Module_MessagesFile };
messages usbdev_messages = { .filename = USBDEV_MESSAGES };
d164 1
a164 34
    return _swix (MessageTrans_ErrorLookup, _INR(0,2), e, &mod_messages.fd, 0);
}

_kernel_oserror* messages_update (messages* mess)
{
    dprintf (("main", "loading message file: %s\n", mess->filename));
    int fh, h;
    _kernel_oserror* e = NULL;

    e = _swix (OS_Find, _INR(0,1)|_OUT(0), 0x4f, mess->filename, &fh);
    if (e) return e;

    /* we must always close the file */
    e = _swix (OS_FSControl, _INR(0,1)|_OUT(1), 21, fh, &h);

    _swix (OS_Find, _INR(0,1), 0, fh);
    if (e || h == mess->handle) return e;

    mess->handle = h;

    if (mess->isopen)
    {
        _swix (MessageTrans_CloseFile, _IN(0), &mess->fd);
    }

    e = _swix (MessageTrans_OpenFile, _INR(0,2),
        &mess->fd,
        mess->filename,
        0);
    if (e) return e;

    mess->isopen = true;

    return e;
d277 4
a280 5
#else
    /* if standalone then this happens in the service call handler */
    e = messages_update (&mod_messages);
    if (e) return e;
    e = messages_update (&usbdev_messages);
a281 1
#endif
d303 2
a304 2
    return 0;
#ifndef STANDALONE
d307 4
a311 1
#endif
d377 23
d440 1
a440 4
    case Service_ResourceFSStarted:
        messages_update (&mod_messages);
        messages_update (&usbdev_messages);
        break;
d442 1
a442 1
#ifdef STANDALONE
d445 1
a446 1
        break;
d533 1
a533 1
_kernel_oserror* command_enumerate_devices (void)
d535 3
d539 31
a569 2
    puts("No. Bus Dev Class Description");
    for (int i = 1; i <= maxdev_no; ++i)
d577 1
a577 1
            printf ("%3d %3d %3d %2X/%2X %s%s%s\n",
d593 1
a593 1
    return 0;
d598 1
a598 1
_kernel_oserror* command_enumerate_buses (void)
d600 3
d604 33
a636 4
    printf ("Transfers (%d buses):\n", usbbus_no-1);
//         012345678901234567890123456789012345678901234567890
    puts ("Bus   Control Isochronous    Bulk Interrupt");
    for (int i = 1; i < usbbus_no; ++i)
d644 1
a644 1
        printf ("%3d %9lu %9lu %9lu %9lu\n",
d655 1
a655 1
_kernel_oserror* command_discover (void)
d675 1
a675 1
_kernel_oserror* command_reset (int n)
d705 1
a705 1
_kernel_oserror* command_dev_info (int n)
d707 1
a707 1
    char   string[USB_MAX_STRING_LEN];
d709 1
d720 25
a744 14
    printf ("USB release     : %04X\n", UGETW(ddesc->bcdUSB));
    printf ("Device class    : %02X\n", ddesc->bDeviceClass);
    printf ("Device subclass : %02X\n", ddesc->bDeviceSubClass);
    printf ("Device protocol : %02X\n", ddesc->bDeviceProtocol);
    printf ("Max packet size : %02X\n", ddesc->bMaxPacketSize);
    printf ("Vendor ID       : %04X\n", UGETW(ddesc->idVendor));
    printf ("Product ID      : %04X\n", UGETW(ddesc->idProduct));
    printf ("Device ID       : %04X\n", UGETW(ddesc->bcdDevice));
    printf ("# of configs    : %d\n", ddesc->bNumConfigurations);
    printf ("Manufacturer    : '%s'\n", ltrim (usbd_get_string (udev, ddesc->iManufacturer, string)));
    printf ("Product         : '%s'\n", ltrim (usbd_get_string (udev, ddesc->iProduct, string)));
    printf ("Serial number   : '%s'\n", ltrim (usbd_get_string (udev, ddesc->iSerialNumber, string)));
    static const char *speeds[] = {"???","Low","Full","High"};
    printf ("Speed           : %s\n", speeds[udev->speed>USB_SPEED_HIGH?0:udev->speed]);
d751 1
a751 1
_kernel_oserror* command_conf_info (int n)
d753 1
a753 1
    char   string[USB_MAX_STRING_LEN];
d755 3
d767 3
a769 1
    printf ("Current config  : %d\n\n", udev->config);
d774 13
a786 6
    printf ("# of interfaces : %d\n", cdesc->bNumInterface);
    printf ("Config value    : %d\n", cdesc->bConfigurationValue);
    printf ("Name            : '%s'\n", ltrim (usbd_get_string (udev, cdesc->iConfiguration, string)));

    printf ("Attributes      : ");
    int f = 0;
d789 2
a790 2
        printf ("Bus powered\n");
        f = 1;
d794 3
a796 2
        printf ("%sSelf powered\n", f?"                  ": "");
        f = 1;
d800 7
a806 2
        printf ("%sRemote Wakeup\n", f?"                  ": "");
        f = 1;
a807 1
    if (cdesc->bmAttributes == 0) puts ("");
d809 3
a811 1
    printf ("Maximum power   : %dmA\n", cdesc->bMaxPower * UC_POWER_FACTOR);
d813 1
d819 2
d823 1
a823 20
        case UDESC_INTERFACE:
        {
            usb_interface_descriptor_t * d = (usb_interface_descriptor_t *) ptr;

            printf ("\nInterface %d.%d class %d.%d:%d '%s'\n",
                d->bInterfaceNumber,
                d->bAlternateSetting,
                d->bInterfaceClass,
                d->bInterfaceSubClass,
                d->bInterfaceProtocol,
                ltrim (usbd_get_string (udev, d->iInterface, string)));
            break;
        }
        case UDESC_ENDPOINT:
        {
            usb_endpoint_descriptor_t * d = (usb_endpoint_descriptor_t *) ptr;
            printf ("%2d %s ",
                UE_GET_ADDR(d->bEndpointAddress),
                UE_GET_DIR(d->bEndpointAddress) == UE_DIR_IN? "IN ":"OUT");
            switch (d->bmAttributes & UE_XFERTYPE)
d825 13
a837 2
            case UE_CONTROL:
                printf ("Control ");
d839 7
a845 3
            case UE_ISOCHRONOUS:
                printf ("Isochronous ");
                switch (UE_GET_ISO_TYPE(d->bmAttributes))
d847 23
a869 9
                case UE_ISO_ASYNC:
                    printf ("asynchronous ");
                    break;
                case UE_ISO_ADAPT:
                    printf ("adaptive ");
                    break;
                case UE_ISO_SYNC:
                    printf ("synchronous ");
                    break;
d871 4
a874 6
                break;
            case UE_BULK:
                printf ("Bulk ");
                break;
            case UE_INTERRUPT:
                printf ("Interrupt ");
d877 12
a888 13

            printf ("%d bytes %d frames\n",
                UGETW(d->wMaxPacketSize), d->bInterval);

            break;
        }
        case UDESC_HID:
        {
            usb_hid_descriptor_t * d = (usb_hid_descriptor_t *) ptr;
            ddumpbuf("", (void*) d, d->bLength, 0);
            ddumpbuf("", (void*) d, sizeof *d, 0);
            printf ("%d HID%X descriptors,  Country %X\n",
                d->bNumDescriptors, UGETW(d->bcdHID), d->bCountryCode);
d890 6
a895 8
            /* handle in a rather horrible way */
            for (int i = 0; i < d->bNumDescriptors; ++i)
            {
                printf ("    Type %X, length %d\n",
                    d->bHIDDescriptorType,
                    UGETW (d->wDescriptorLength));
                d = (usb_hid_descriptor_t *) (((char*) d) + 3);
            }
d897 7
a903 5
            for (int i = 0; i < d->bNumDescriptors; ++i)
            {
                printf ("    Type %X, length %d\n",
                    d->descrs[i].bDescriptorType,
                    UGETW (d->descrs[i].wDescriptorLength));
a904 3
#endif
            break;
        }
a951 7
///* format of a quirk .. keep synchronised with entry in dev.usb.usb_quirks */
//typedef struct usbd_quirk_entry {
//      u_int16_t idVendor;
//      u_int16_t idProduct;
//      u_int16_t bcdDevice;
//      u_int32_t quirks;
//} usbd_quirk_entry;
d955 32
a986 7
  int i;
  usbd_quirk_entry *t;
  printf("Vendor Product Device Flags\n");

  if(extra_quirks)
  {
    for(i=0,t=extra_quirks;i<MAX_EXTRA_QUIRKS;i++,t++)
d988 5
a992 3
      if(t->idVendor)
        printf("%04x   %04x    %04x   %08x\n",t->idVendor,t->idProduct,t->bcdDevice,t->quirks.uq_flags);

d994 1
a994 2
  }
  return NULL;
d999 18
a1016 16
  int i;
  usbd_quirk_entry *t;
  if(extra_quirks)
  {
    for(i=0,t=extra_quirks;i<MAX_EXTRA_QUIRKS;i++,t++)
    {
      if (t->idVendor  == vendor &&
          t->idProduct == product&&
          t->bcdDevice == device)
      {
        t->idVendor  = 0;
        t->idProduct = 0;
        t->bcdDevice = 0;
        t->quirks.uq_flags = 0;
        return NULL;
      }
d1018 1
a1018 2
  }
  return NULL;
d1020 1
d1023 14
a1036 11
  int i;
  usbd_quirk_entry *t;
  if(!(extra_quirks)) extra_quirks = calloc(MAX_EXTRA_QUIRKS+1,sizeof(usbd_quirk_entry));
  for(i=0,t=extra_quirks;i<MAX_EXTRA_QUIRKS;i++,t++)  /* existing? */
  {
    if (t->idVendor  == vendor &&
        t->idProduct == product&&
        t->bcdDevice == device)
    {
      t->quirks.uq_flags = quirk;
      return NULL;
d1038 1
a1038 4
  }
  for(i=0,t=extra_quirks;i<MAX_EXTRA_QUIRKS;i++,t++)  /* new */
  {
    if(!t->idVendor)
d1040 8
a1047 5
      t->idVendor  = vendor ;
      t->idProduct = product;
      t->bcdDevice = device;
      t->quirks.uq_flags = quirk;
      return NULL;
d1049 1
a1049 2
  }
  return NULL;
d1108 13
a1120 12
          char* p,cmd;
          unsigned vendor,product,device,quirk=NULL;
          cmd= *arg_string;
          if(cmd=='L' || cmd=='l') return command_ListQuirks();
          vendor =   (unsigned) strtoul (arg_string+1, &p, 16);
          if(p) product = (unsigned) strtoul (p, &p, 16);
          if(p) device  = (unsigned) strtoul (p, &p, 16);
          if(p) quirk   = (unsigned) strtoul (p, &p, 16);
          if(cmd=='R' || cmd=='r')
               return command_RemoveQuirk(vendor,product,device);
          if(cmd=='A' || cmd=='a')
               return command_AddQuirk(vendor,product,device,quirk);
d1124 1
a1124 1
    return 0;
a1880 1
        int len;
d1883 2
a1884 2
        e = _swix (MessageTrans_Lookup, _INR(0,3)|_OUTR(2,3),
            &usbdev_messages.fd,
d1888 1
a1888 1
            &vendor, &len);
a1890 1
        if (!e) v[len] = '\0';
a1894 1
        int len;
d1898 2
a1899 2
        e = _swix (MessageTrans_Lookup, _INR(0,3)|_OUTR(2,3),
            &usbdev_messages.fd,
d1903 1
a1903 1
            &product, &len);
a1905 1
        if (!e) p[len] = '\0';
d1908 13
a1920 4
    if (vendor == NULL)
        snprintf(v, vl, "Vendor ID %04X", UGETW(udd->idVendor));
    if (product == NULL)
        snprintf(p, pl, "Product ID %04X", UGETW(udd->idProduct));
@


1.59
log
@Revert accidental commits
Admin:
  These changes are currently subject to rework via the normal submissions channel.
@
text
@d1067 1
a1067 1
    case USBDriver_DeRegisterBus - USBDriver_00:
@


1.58
log
@  Fixes for Isochronous data transfer
Detail:
Frontend
========

NetBSD.build.c.usbmodule
	frontend isochronous changes
	forces reads to always be multiple of maxpacket
NetBSD.dev.usb.c.usb_subr
	datatoggle fix
	panic fix
NetBSD.dev.usb.c.usbdi
	usbd_transfer changed so that bufrem is passed the xfer pointer instead of the buffer pointer
	fixed missing braces in usbd_clear_endpoint_stall

EHCI
====

The HS (USB2) isochronous as been rewritten and isochronous split transactions - FS (USB1) over a HS Connection - has been added

NetBSD.dev.usb.c.ehci
NetBSD.dev.usb.h.ehcireg
NetBSD.dev.usb.h.ehcivar

OHCI
====

Changes to the NetBSD backend to get isochronous transfers working on a OHCI device. While it did have isochronous support it wasn't working properly.

NetBSD.dev.usb.c.ohci

Admin:
  Submitted by Colin Granville
Tested in iMx6

Version 1.10. Tagged as 'NetBSD-1_10'
@
text
@a55 23
/* UISOC_MAXNFRAMES  must be multiple of 8 */
#define UISOC_MAXNFRAMES        16
#define UISOC_NUM_XFERS         4
#define UISOC_XFER_MS           2
#define UISOC_NUM_XFERS_FB      4
#define UISOC_XFER_FB_MS        1

static unsigned int isoc_get_nframes(usbd_pipe_handle pipe, unsigned int ms) 
{
    if (pipe->endpoint->edesc->bInterval == 0) return 1;
    
    unsigned int nframes = 2 * 8 * ms;
    if (pipe->device->speed < 3) nframes /= 8;
    nframes >>= pipe->endpoint->edesc->bInterval;
    if (nframes > UISOC_MAXNFRAMES) nframes = UISOC_MAXNFRAMES;
    return (nframes == 0) ? 1 : nframes;
}

static inline unsigned int isoc_get_maxfrlength(usbd_pipe_handle pipe)
{
    unsigned int maxpacket = UGETW(pipe->endpoint->edesc->wMaxPacketSize);
    return (maxpacket & 0x7ff) * ((maxpacket >> 11) + 1);
}
d63 2
d66 4
a69 2
    usbd_xfer_handle xfer;                 
    uint16_t         frlengths[UISOC_MAXNFRAMES];
a107 8
    int                  isoc_count;        /* number of isoc_buffers */
    struct {
        uint32_t          samples_per_frame;  /* Samples per frame 16.16 fixed point format */                              
        uint32_t          samplesize;         /* size of audio frame eg PCM 2 channel 16bit = 4 */
        uint32_t          error;              /* accumulation of fractional error */
        usbd_pipe_handle  feedback_pipe;
        struct isoc_buffer feedback[UISOC_NUM_XFERS_FB];
    } isoc_data;
d433 1
a433 1
        "endpoint/Ninterface/Nalternate/Nreport/Ncontrol,isochronous,bulk,interrupt/Susbtimeout/Nsize/Nnopad/Sshort/Ssamplerate/Nsamplesize/N",
d1682 1
a1682 3
/* bufrem is now passes a usbd_xfer_handle in x */

void bufrem (void* dma, void* x, int size)
d1684 1
a1684 3
    usbd_xfer_handle xfer = x;

    if (x == NULL || xfer->buffer == 0)
a1689 20
    if ((xfer->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) == UE_ISOCHRONOUS)
    {   
        _kernel_swi_regs r;
        r.r[0] = BM_RemoveBlock;
        r.r[1] = (int) xfer->buffer;
        r.r[2] = (int) dma;
        r.r[3] = size;
        CallBufMan (&r);
        int sz = r.r[3];
        if (sz != 0 && sz <= size)
        {
            /*
             * required to produce silence
             * when the buffer is empty.
             */
            memset((void*)r.r[2],0,sz);
        }
        return;
    }  

d1692 1
a1692 1
    r.r[1] = (int) xfer->buffer;
a1732 20

    if ((str->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) == UE_ISOCHRONOUS)
    {         
        unsigned int maxfrlength = isoc_get_maxfrlength(str->pipe);
        unsigned char* mem  = dma;
        for (int i = 0 ; i < xfer->nframes; i++, mem += maxfrlength)
        {
            if (xfer->frlengths[i] != 0)
            {
                _kernel_swi_regs r;
                r.r[0] = BM_InsertBlock;
                r.r[1] = (int) str->buffer_id;
                r.r[2] = (int) mem;
                r.r[3] = xfer->frlengths[i];
                CallBufMan (&r);
            }
        }
        return;
    }

a1848 2
    uint32_t    samplerate;
    uint32_t    samplesize;
a1923 304
static void write_cb(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status);
static void read_cb(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status);

static void Isoc_in_feedback_cb(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
{
    struct devstream* str = (struct devstream*) priv;

    if (status != USBD_NORMAL_COMPLETION)
    {
        return;
    }
    uint8_t* buf = KERNADDR(&xfer->dmabuf, 0);
    uint32_t maxfrlength = isoc_get_maxfrlength(xfer->pipe);
    for (int i = 0; i < xfer->nframes; i++)
    {
        if (xfer->frlengths[i] == maxfrlength)
        {
            uint32_t samples_per_frame = 0;
            switch (maxfrlength)
            {
                case 3: /* USB 1 */
                        samples_per_frame = ((buf[0] + (buf[1] << 8) + (buf[2] << 16)) << 2);
                        break;
                case 4:
                        samples_per_frame = *(uint32_t*)buf;
                        break;
            }
            
            if (samples_per_frame > str->isoc_data.samples_per_frame - 0x20000 && 
                samples_per_frame < str->isoc_data.samples_per_frame + 0x20000)
                str->isoc_data.samples_per_frame = samples_per_frame;
        }
        xfer->frlengths[i] = maxfrlength;
        buf += maxfrlength;
    }

    xfer->actlen = 0;
    status = usbd_transfer(xfer);
}

/*---------------------------------------------------------------------------*/

static void Isoc_destroy(struct devstream* str)
{
    if (str == NULL) return;

    if (str->isoc != NULL)
    {
        /* 
         * str->xfer just used as a current pointer
         */
        for (int i = 0; i < str->isoc_count; i++)
        {
            if (str->isoc[i].xfer != NULL) usbd_free_xfer(str->isoc[i].xfer);// buffer destroyed with xfer
            str->isoc[i].xfer = NULL;
        }
        free(str->isoc);
        str->isoc = NULL;
        str->xfer = NULL;
    }

    if (str->isoc_data.feedback_pipe != NULL )
    {
        usbd_status s = usbd_abort_pipe(str->isoc_data.feedback_pipe);
        s = usbd_close_pipe(str->isoc_data.feedback_pipe);        
        str->isoc_data.feedback_pipe = NULL;
    }

    for (int i = 0; i < UISOC_NUM_XFERS_FB; i++)
    {
        if (str->isoc_data.feedback[i].xfer != NULL) usbd_free_xfer(str->isoc_data.feedback[i].xfer);
        str->isoc_data.feedback[i].xfer = NULL;
    }
}

/*---------------------------------------------------------------------------*/

static _kernel_oserror* Isoc_construct(struct devstream* str, device_valid* valid)
{
    dprintf(("","Isoc_construct\n"));
    
    usb_endpoint_descriptor_t* ed = usbd_get_endpoint_descriptor(str->iface,str->ep);
    if (ed == NULL || ed->bInterval == 0) return uerror(E_BadXfer);
    
    if (valid->samplerate == 0xdeaddead || 
        valid->samplerate < 1 ||
        valid->samplesize == 0xdeaddead ||
        valid->samplesize < 1 ) return uerror(E_BadXfer);
        
    memset(&str->isoc_data,0,sizeof(str->isoc_data));
    str->isoc_data.samplesize   = valid->samplesize;
    uint32_t samples_per_frame  = valid->samplerate;
    

    unsigned int base = str->pipe->device->speed >= USB_SPEED_HIGH  ? 8000 : 1000;
    base = (base * 2) >> ed->bInterval;
    if (base == 0) return uerror(E_BadXfer);
    
    samples_per_frame    = ((samples_per_frame / base) << 16) +
                                   (((samples_per_frame % base) << 16) / base);


    str->isoc_data.samples_per_frame    = samples_per_frame;
    str->isoc_count = UISOC_NUM_XFERS;


    if (((str->isoc_data.samples_per_frame + 0xFFFF) >> 16) * str->isoc_data.samplesize >
        isoc_get_maxfrlength(str->pipe)) return uerror(E_BadXfer);

    str->isoc = calloc (sizeof *str->isoc, str->isoc_count);
    if (str->isoc == NULL) return uerror(E_NoMem);
    for (int i = 0; i < str->isoc_count; i++)
    {
        str->isoc[i].xfer = usbd_alloc_xfer (str->ugen->sc_udev);
        if (str->isoc[i].xfer == NULL) return uerror(E_BadXfer);
    }
    str->xfer = str->isoc[0].xfer;

    if (UE_GET_ISO_TYPE(ed->bmAttributes) == UE_ISO_ASYNC &&
        UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
        str->iface->idesc->bNumEndpoints == 2)
        
    {
        /* default feedback endpoint to same endpoint number in opposite direction */
        uint8_t feed_ep = str->ep ^ UE_DIR_IN;
        if (ed->bLength == 9 &&
            str->iface->idesc->bInterfaceClass == 1 &&  /* Audio Class */
            str->iface->idesc->bInterfaceSubClass == 2)    /* Audio Streaming */
        {
            feed_ep = ((uint8_t*)ed)[8]; /* ed->bSynchAddress */
            /* fix for bSynchAddress not setting direction */ feed_ep |= 0x80;
            
            dprintf(("","Audio Class "));
        }
        ed = usbd_get_endpoint_descriptor(str->iface,feed_ep);

        if (ed == NULL || UE_GET_XFERTYPE(ed->bmAttributes) != UE_ISOCHRONOUS) return 0;
        
        usbd_status status = usbd_open_pipe(str->iface, ed->bEndpointAddress, 0, &str->isoc_data.feedback_pipe);

        if (status != USBD_NORMAL_COMPLETION) return uerror(E_BadPipe);
        
        for (int i = 0; i < UISOC_NUM_XFERS_FB; i++)
        {
            struct isoc_buffer* feedback = &str->isoc_data.feedback[i];
            feedback->xfer = usbd_alloc_xfer (str->ugen->sc_udev);
            if (feedback->xfer == NULL) return uerror(E_BadXfer);
            feedback->xfer->nframes = isoc_get_nframes(str->isoc_data.feedback_pipe, UISOC_XFER_FB_MS);

            usbd_setup_isoc_xfer
            (
                feedback->xfer,
                str->isoc_data.feedback_pipe,
                str,
                &feedback->frlengths[0],
                feedback->xfer->nframes,
                USBD_NO_COPY | USBD_SHORT_XFER_OK,      /* flags */
                Isoc_in_feedback_cb
            );
            
            feedback->xfer->length = feedback->xfer->nframes * isoc_get_maxfrlength(str->isoc_data.feedback_pipe);
            
            if (usbd_alloc_buffer(feedback->xfer, feedback->xfer->length) == NULL)
            {
                return uerror(E_BadXfer);
            }
            
            /*
             * set frlengths to 0. Set by calling callback.
             * Setting to 0 avoids them being read initially.
             */
            for (int j = 0; j < feedback->xfer->nframes; j++)
                feedback->frlengths[j] = 0;
        }
    }

    return NULL;
}

/*---------------------------------------------------------------------------*/

static void Isoc_fill_xfer_write(struct devstream* str, usbd_xfer_handle xfer)
{
    str->xfer = xfer;
    struct isoc_buffer* buf = NULL;
    
    for (int i = 0; i <str->isoc_count; i++)
    {
        if (str->xfer == str->isoc[i].xfer) {buf = &str->isoc[i]; break;}
    }
    
    if (buf == NULL) return;
    
    int length = 0;
    for (int i = 0; i < buf->xfer->nframes; i++)
    {
        str->isoc_data.error += (str->isoc_data.samples_per_frame & 0xffff);
        uint32_t size         = (str->isoc_data.samples_per_frame >> 16) +
                                (str->isoc_data.error >> 16);
        str->isoc_data.error &= ~0x10000;

        size                 *=  str->isoc_data.samplesize;
        buf->frlengths[i]     = size;
        length               += size;
    }
   
    usbd_setup_isoc_xfer(
            buf->xfer,
            str->pipe,
            str,
            &buf->frlengths[0],     /* sizes */
            buf->xfer->nframes,     /* n frames */
            USBD_SHORT_XFER_OK | (str->flags & FLAG_SHORT?USBD_FORCE_SHORT_XFER:0),
            write_cb);

    buf->xfer->buffer   = (void*) str->buffer_id;
    buf->xfer->length   = length;
    buf->xfer->rqflags |= URQ_RISCOS_BUF;
}

/*---------------------------------------------------------------------------*/

static void Isoc_start_write(struct devstream* str)
{
    if (str == NULL) return;

    if (str->isoc_data.feedback_pipe != NULL)
    {
        for (int i = 0; i < UISOC_NUM_XFERS_FB; i++)
        {
            Isoc_in_feedback_cb(str->isoc_data.feedback[i].xfer,str,USBD_NORMAL_COMPLETION);
        }
    }
    
    /*
     * Don't care what is in the buffer were starting the transfer
     * if you haven't put in enough bytes tough.
     */
     

    str->xfer_busy = true;
    
    for (int i = 0; i < str->isoc_count; i++)
    { 
        Isoc_fill_xfer_write(str, str->isoc[i].xfer);
        str->xfer->status = usbd_transfer(str->xfer);    
        
    }
}

/*---------------------------------------------------------------------------*/

static void Isoc_fill_xfer_read(struct devstream* str, usbd_xfer_handle xfer)
{
    str->xfer = xfer; 
    struct isoc_buffer* buf = NULL;
    for (int i = 0; i <str->isoc_count; i++)
    {
        if (str->xfer == str->isoc[i].xfer) {buf = &str->isoc[i]; break;}
    }
    if (buf == NULL) return;
    
    uint16_t frlength = isoc_get_maxfrlength(str->pipe);

    for (int i = 0; i < buf->xfer->nframes; i++)
    {
        /*
         * frlengths will be changed by controller driver
         */
        buf->frlengths[i]  = frlength;
    }

    usbd_setup_isoc_xfer(
            buf->xfer,
            str->pipe,
            str,
            &buf->frlengths[0],     /* sizes */
            buf->xfer->nframes,     /* n frames */
            USBD_SHORT_XFER_OK,
            read_cb);

    buf->xfer->buffer   = (void*) str->buffer_id;
    buf->xfer->length   = frlength * buf->xfer->nframes;
    buf->xfer->rqflags |= URQ_RISCOS_BUF;
}

static  void free_xfer(struct devstream* str)
{
    if (str == NULL) return;

    if (str->isoc != NULL)
    {
        Isoc_destroy(str);
    }
    else
    {
        if (str->xfer != NULL) usbd_free_xfer(str->xfer);
        str->xfer = NULL;
    }
    dprintf(("","free_xfer: xfer data freed\n"));
}

/*---------------------------------------------------------------------------*/

d2074 4
a2077 2
            e = Isoc_construct(str,valid);
            if (e) goto error;
d2103 12
a2114 1
    free_xfer(str);
a2144 13
    if ((str->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) == UE_ISOCHRONOUS)
    {
        str->xfer_busy = true;      /* isochronous always busy */

        /*
         * Start next send regardless of what is in buffer.
         * Keep one xfer filling while the other is transfering
         */
        Isoc_fill_xfer_write(str, xfer);
        xfer->status = usbd_transfer(str->xfer);        
        return;
    }

a2184 6
    if ((str->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) == UE_ISOCHRONOUS)
    {
        Isoc_start_write(str);
        goto end;
    }

a2268 10
    if ((str->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) == UE_ISOCHRONOUS)
    {
        /*
         *  Always ReadStatus_busy
         */
        Isoc_fill_xfer_read(str, xfer);
        xfer->status = usbd_transfer(str->xfer);
        return;
    }
    
d2324 16
a2414 5
    
    /* for high speed isochronous devices wMaxPacketSize != max size of packet */
    if ((str->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) == UE_ISOCHRONOUS)
            maxpacket = isoc_get_maxfrlength(str->pipe);                          

d2431 1
a2431 9
            {
                /*
                 * Force fetches of multiple of maxpacket even if remainder is < maxpacket.
                 * This stops IOERRORs (Overflow) on short fetches.
                 */
                actlen = str->totalcount - str->count + maxpacket - 1;
                actlen -= actlen % maxpacket;
            }

d2468 1
d2475 1
a2476 15
        if ((str->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) == UE_ISOCHRONOUS)
        {
             /*
              * Isochronous starts by starting multiple transfers so that one can
              * be processed while the other waits for more data.
              */
             for (int i = 0; i < str->isoc_count; i++)
             {
                Isoc_fill_xfer_read (str, str->isoc[i].xfer);
                str->isoc[i].xfer->status = usbd_transfer(str->isoc[i].xfer);
             }
        }
        else
            str->xfer->status = usbd_transfer (str->xfer);
            
d2529 3
a2531 6

            /*
             * Note usbd_abort_pipe causes any outstanding transfer callbacks to
             * happen before we reach here.
             */
            free_xfer(str);
d2608 4
a2611 8
        unsigned int nframes = isoc_get_nframes(str->pipe, UISOC_XFER_MS);
        unsigned int bufsize = nframes * isoc_get_maxfrlength(str->pipe);
        for (int i = 0; i < str->isoc_count; i++)
        {
            p = usbd_alloc_buffer(str->isoc[i].xfer, bufsize); 
            if (p == NULL) return uerror(E_NoMem);
            str->isoc[i].xfer->nframes = nframes;
        }
a2899 15
        if (((str->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) == UE_ISOCHRONOUS) &&
            (UE_GET_DIR(str->ep) == UE_DIR_OUT))
        {
           /*
            * Isochronous is always busy so the choice is 1) return EOF if the
            * buffer is empty or 2) always return EOF.
            * option 1 causes Close to block until the buffer is empty
            * option 2 causes Close to abort the transfer and close.
            * Use option 2 for now.
            * 
            * always signify EOF - do nothing
            */
           break;
        }
        
@


1.57
log
@Resolve porting mistake on initial bus registration
On first registering a new bus in the the NetBSD build of the code usb_kthread_create(usb_create_event_thread, sc) is called which in turn creates the main event thread ("usb_event_thread").
The first thing usb_event_thread() does is set
  sc->sc_bus->needs_explore = 1;
  usb_discover(sc);
however in the RISC OS version of the code (usb.c around line 254) only the first action is performed, no discover happens.
This change schedules a callback via usb_needs_explore_callback() which in turn calls discover_callback() when the OS is next free, which calls usb_discover() for each bus in an equivalent way to NetBSD's event thread. There's then no longer any need for the special one-shot 11s rediscover callback, only the repeating 30s rediscover is needed.

For reference, the places that set needs_explore in this version are all in usb.c
  Line 254: set, but doesn't schedule a callback, as noted above
  Line 339: code not compiled for __riscos
  Line 548: set, does schedule a callback
  Line 727: cleared, in usb_discover()
  Line 743: set, does schedule a callback
  Line 756: code not called in RISC OS

NetBSD uses 500ms initial delay before discover, then 60s between discovers (or until requested by a hub, whichever is sooner).
RISC OS has a periodic callback of 30s (in usbmodule.c) and an initial discover of however long it is from the bus being registered until callbacks next fire usb_event_thread(), assumed ~500ms.

Version 1.07. Tagged as 'NetBSD-1_07'
@
text
@d56 23
a85 2
#define UAUDIO_NFRAMES 4

d87 2
a88 4
    usbd_xfer_handle xfer;
    uint16_t sizes[UAUDIO_NFRAMES];
    uint16_t offsets[UAUDIO_NFRAMES];
    int size;
d127 8
d460 1
a460 1
        "endpoint/Ninterface/Nalternate/Nreport/Ncontrol,isochronous,bulk,interrupt/Susbtimeout/Nsize/Nnopad/Sshort/S",
d1709 3
a1711 1
void bufrem (void* dma, void* priv_id, int size)
d1713 3
a1715 1
    if (priv_id == NULL)
d1721 20
d1743 1
a1743 1
    r.r[1] = (int) priv_id;
d1784 20
d1920 2
d1997 304
d2451 2
a2452 4
            str->isoc = calloc (sizeof *str->isoc, 2);
            str->isoc[0].xfer = usbd_alloc_xfer (ugen->sc_udev);
            str->isoc[1].xfer = usbd_alloc_xfer (ugen->sc_udev);
            str->xfer = str->isoc[0].xfer;
d2478 1
a2478 12
    if (str->pipe)
        usbd_close_pipe (str->pipe);
    if (str->xfer)
        usbd_free_xfer (str->xfer);
    if (str->isoc != NULL)
    {
        if (str->isoc[1].xfer)
        {
            usbd_free_xfer (str->isoc[1].xfer);
        }
        free (str->isoc);
    }
d2509 13
d2562 6
d2652 10
a2716 16
void fill_isoc_xfer (struct devstream* str, int maxpacket)
{
    str->size = maxpacket;
    str->xfer->actlen = 0;
    usbd_setup_isoc_xfer(
        str->xfer,
        str->pipe,
        str,
        (u_int16_t*) &str->size,         /* sizes */
        1,                  /* n frames */
        USBD_SHORT_XFER_OK,
        read_cb);
    str->xfer->buffer = (void*) str->buffer_id;
    str->xfer->length = maxpacket;
}

d2792 5
d2813 9
a2821 1
                actlen = str->totalcount - str->count;
a2857 1
            fill_isoc_xfer (str, maxpacket);
a2863 1
        str->xfer->status = usbd_transfer (str->xfer);
d2865 15
d2932 6
a2937 3
//            usbd_free_buffer (str->xfer);    /* done in usbd_free_xfer
            status = usbd_free_xfer(str->xfer);
            dprintf (("", "status3: %s\n", ccodes[status]));
d3014 8
a3021 4
        p = usbd_alloc_buffer (str->isoc[0].xfer, *size / 2);
        if (p == NULL) return uerror (E_NoMem);
        p = usbd_alloc_buffer (str->isoc[1].xfer, *size / 2);
        if (p == NULL) return uerror (E_NoMem);
d3310 15
@


1.56
log
@Internationalisation, help, and syntax improvments
Assign a proper error number and translate "Incompatible USBDriver version".
Don't bother internationalising the *commands which are for debug builds only.
Rephrase the help for USBQuirk so it makes sense, and trim the unmatched '<' from the syntax example.
Bracket the USBDiscover help with the same switch that governs the code, which has been disabled for over a decade.

Version 1.04. Tagged as 'NetBSD-1_04'
@
text
@a291 4
    /* set up a periodic call to re-discover anything lurking */
    callx_add_callevery(3000,re_discover,NULL);
    /* set up a one off call to re-discover anything lurking early */
    callx_add_callafter(1200,re_discover,NULL);
d336 3
a1129 1
static int rd_active = 0;
d1132 4
a1135 3
//    struct device* dev;
    if(rd_active) return NULL;
    rd_active++;
d1144 1
a1144 1
    rd_active=0;
@


1.55
log
@Update table of device quirks
Detail:
  From NetBSD usb_quirks.c revision 1.81.
  usbmodule: NULL is for pointer types, not ints.
  usb_quirks: Group the RISC OS specific ones together, disable the non applicable UQ_APPLE_ISO ones, UQ_LOST_CS_DESC doesn't apply either but is only used for USB modem drivers not ported here. Untangle ifdefs around usbd_find_quirk().
Admin:
  Removed unused source file ums.c

Version 1.03. Tagged as 'NetBSD-1_03'
@
text
@d151 1
d878 1
a878 1
  printf("\n USB Extra Quirk listing:\nVendor Product Device Quirk\n");
d1064 1
a1064 1
            return (_kernel_oserror *)"\0\0\0\0Incompatible USBDriver version";
d1240 1
a1240 1
/* dummy - we don't do attachement like this */
@


1.54
log
@Allow the endpoint validation string to include a direction flag
However, internally we get that info from the descriptor, so mask it off.
Submission from Colin Granville.

No version number bump, it's already been incremented today.

Version 1.01. Tagged as 'NetBSD-1_01'
@
text
@d903 4
a906 4
        t->idVendor  = NULL;
        t->idProduct = NULL;
        t->bcdDevice = NULL;
        t->quirks.uq_flags    = NULL;
@


1.53
log
@Add some missing struct members
From NetBSD dev/usb/usbdivar.h 1.109.
As these extra members change the struct layout, bump the API version number too. Having carefully analysed which headers are actually required by host controllers (in NetBSD-0_98) also be explicit about them in Hdr/USBDriver rather than the former vague comment in h/usbdivar.

Hdr/USBDriver:
  Relocate API define here.
usbmodule.c:
  Include USBDriver.h to get the API define.
usbdivar.h:
  Add struct members from recent NetBSD.

Version 1.00. Tagged as 'NetBSD-1_00'
@
text
@d1963 3
@


1.52
log
@Fix to interface matching function
Use -1 as the invalid mark, so that an accidental match on interface=0 alternate=0 is no longer possible.
Submission from Colin Granville.

Version 0.99. Tagged as 'NetBSD-0_99'
@
text
@d30 1
@


1.51
log
@Fix to system variable launch & debug build
ohcimodule.c:
 Variable renamed so it builds with debug enabled.
usbmodule.c:
 Tighten up the logic deciding when to launch a USB$<thing> variable, previously it would be launched both for the initial device attach and then again for each interface.
 Remove local <stdlib.h> function prototypes.
 Reindent to 4 spaces to match the rest of the file.
 Fix confusion of ->dv_unit being an int not a pointer.
Submission from Colin Granville. Built, but not tested.

Version 0.95. Tagged as 'NetBSD-0_95'
@
text
@d1878 1
a1878 1
    i = j = 0;
d1890 1
@


1.50
log
@  Revisit Service_PreReset activity
Detail:
  Recent investigations in stalling of OS_Reset showed that with multiple
  driver modules it was possible for the monotonic timer to be turned off
  before the usb system had shut down. Service_PreReset needs a rapid finite
  response to silence the relevant module's hardware and ensure it cannot
  intiiate something that could stall the reset process.
  As a result USBDriver module no longer issues Service_USB_DriverDying in
  its Service_PreReset response; it merely silences itself and removes itself
  from any vectors. This EHCIDriver and OHCIDriver modules now only need to
  silence themselves when receiving Service_PreReset.
Admin:
  tested in iMx6 and iyonix


Version 0.92. Tagged as 'NetBSD-0_92'
@
text
@d1156 13
a1168 2
    /* reset these variables to false upon requesting attachment of a device */
    if (((struct usb_attach_arg*) aux)->configno == UHUB_UNK_CONFIGURATION)
d1173 1
d1175 2
a1176 4
    char* getenv (const char*);
    int atoi (const char*);
    dprintf (("", "Trying match on ignore device\n"));
    sprintf (str, "USB$Ignore_%04X_%04X", ((struct usb_attach_arg*)aux)->vendor, ((struct usb_attach_arg*)aux)->product);
d1178 2
a1179 3
    dprintf (("", "look for %s.. got \"%s\"\n",str,(env?env:"")));

    if(!env)    /* check if we are allowed to handle it */
d1181 10
a1190 9
      typedef device_ptr_t pf (device_ptr_t, void*);
      pf* funcs[] = { attach_hub, attach_mouse, attach_keyboard, NULL };
      for (pf** f = funcs; *f != NULL; ++f)
      {
          if ((ret = (*f) (parent, aux)) != NULL)
          {
            return ret;
          }
      }
d1192 1
d1194 1
a1194 1
    if(((usbd_device_handle)dev)->dv_unit == NULL)
d1196 1
a1196 1
      int startnum = usbdev_no;
d1198 11
a1208 11
      if (usbdev_no > 999) usbdev_no=1;     /* cycle around mod 1000 */
      if (usbdev_no > maxdev_no) maxdev_no = usbdev_no;
      if (get_usbdev (usbdev_no)!=NULL)
      {
          if( usbdev_no != startnum)
          {
            usbdev_no++;
            goto reloop;                    /* not looped yet .. try again */
          }
      }
      ((usbd_device_handle)dev)->dv_unit = usbdev_no++;
a1224 2
//            if (_kernel_oscli (sc->com))
//                dprintf (("", "error: %s\n", _kernel_last_oserror ()->errmess));
@


1.49
log
@Include device speed in *USBDevInfo output. Corrections to header export.
Detail:
  build/c/usbmodule - Improve *USBDevInfo to display the devices connection speed
  build/h/USBDevFS - Correct device speed listing to match reality
  build/Version - Bump USBDriver version number
Admin:
  Tested on Raspberry Pi


Version 0.87. Tagged as 'NetBSD-0_87'
@
text
@d530 7
a536 5
        {
    /* issue a service call to request any running HCDs can object */
    /* do this first in case other things still need to happen     */
    _swix (OS_ServiceCall, _INR (0, 1),
        Service_USB_USBDriverDying, Service_USB);
@


1.48
log
@Tidy up exported USBDevFS.h
Detail:
  build/h/USBDevFS - Added extra #ifdef guard to allow USBDevFS.h to be safely included by software that uses the BSD USB headers. Add the DeviceFS_CallDevice codes that USBDriver uses.
  build/h/service - Removed redundant secondary definition of the service call structures which the drivers were using internally
  build/c/ehcihal - Removed redundant #includes
  build/c/ehcidriver, build/c/ohcidriver - Use USBDevFS.h instead of service.h
  build/c/usbmodule - Use USBDevFS.h instead of service.h. Get rid of local DeviceCall definitions and use the ones which are now in USBDevFS.h. Also switched over to using Interface/DevicsFS.h for the main DevicsFS call reason codes, to match the naming convention used by USBDevFS.h (as opposed to the OSLib naming convention that was used previously). Stripped the unused OBSOLETE_SERVICE_CALLS code.
  build/Makefile - Add usbdi_util.h to the header exports
Admin:
  Tested with building OMAP3, Tungsten & BCM2835 ROMs
  Builds to binary-identical modules as previous version.


Version 0.85. Tagged as 'NetBSD-0_85'
@
text
@d679 2
@


1.47
log
@Improvements to interface/alternate matching from partially specified special strings
Previously, if an endpoint was specified the endpoint type would be matched as type BULK even if that wasn't the case for the given endpoint number.
Also, the find_interface_and_endpoint could exit without assigning the alternate.

Line 2001: only search for BULK when neither the type nor endpoint were given
Line 2028: take the first match on any fields that were given, assign all 3 return values
Line 2094: remove some dead code, 'ep' is not read by find_interface_and_endpoint, so no need to initialise it

Test case
  OPENIN "devicefs#endpoint1;size8:USB1"
now gets the actual endpoint_type of the device, rather than BULK all the time.

Changes from Colin, ref http://www.riscosopen.org/forum/forums/3/topics/1895


Version 0.80. Tagged as 'NetBSD-0_80'
@
text
@d15 1
a15 1
/* Changed 17.02.2010 TM DeviceFSCallDevice_TransferInfo and notation of padded bytes. */
d29 1
d53 1
a53 1
#include "service.h"
a59 28
/* for interfacing with ioctl */
#define FWRITE          0x0002

#define DeviceFSCallDevice_MonitorTX        12
#define DeviceFSCallDevice_MonitorRX        13

#define DeviceFSCallDevice_USBRequest       0x80000000
#define DeviceFSCallDevice_BufferSpace      0x80000002
#define DeviceFSCallDevice_GetHandles       0x80000003
#define DeviceFSCallDevice_GetLocation      0x80000004
#define DeviceFSCallDevice_ClearStall       0x80000005
#define DeviceFSCallDevice_TransferInfo     0x80000006
#define DeviceFSCallDevice_GetHandles2      0x80000007
#define DeviceFSCallDevice_GetSetOptions    0x80000008

/* Was this used by the Castle podule at some time? - JL
#define DeviceFSCallDevice_GetConfig        0x80000001
#define DeviceFSCallDevice_SetConfig        0x80000002
#define DeviceFSCallDevice_GetAltInterface  0x80000003
#define DeviceFSCallDevice_SetAltInterface  0x80000004
#define DeviceFSCallDevice_GetNoAlt         0x80000005
#define DeviceFSCallDevice_GetDeviceDesc    0x80000006
#define DeviceFSCallDevice_GetConfigDesc    0x80000007
#define DeviceFSCallDevice_GetInterfaceDesc 0x80000008
#define DeviceFSCallDevice_GetEndpointDesc  0x80000009
#define DeviceFSCallDevice_GetString        0x8000000a
*/

d288 2
a289 2
        Service_USBDriver_Starting,
        Service_USBDriver);
d360 1
a360 1
        Service_USBDriver_Dying, Service_USBDriver);
d495 1
a495 1
        case Service_USBDriver_Connected:
d523 1
a523 1
        case Service_USBDriver_Attach:
d525 1
a525 1
        case Service_USBDriver_Detach:
d534 1
a534 1
        Service_USBDriver_Dying, Service_USBDriver);
a1328 105
#ifdef OBSOLETE_SERVICE_CALLS
/* returns non-zero if not handed */
char* service_call (usbd_device_handle dev, int unit, int link)
{
    char name[3 + 11 + 1];
    int nifs = dev->cdesc->bNumInterface;
    int epn, iface;
    for (epn = 0, iface = 0; iface < nifs; ++iface)
    {
        epn += dev->ifaces[iface].idesc->bNumEndpoints;
    }
    sprintf (name, "USB%d", unit);

    size_t size =
        (link? sizeof (USBServiceCall*): 0) +
        sizeof (USBServiceCall) +
        epn * sizeof (USBDevFSEndpoint) +
        epn * sizeof (USBDevFSEndpoint*) +
        nifs * sizeof (usb_interface_descriptor_t) +
        nifs * sizeof (usb_interface_descriptor_t*) + 20;

    char* real_serv = malloc (size);
    USBServiceCall* serv = (USBServiceCall*) (link? real_serv + sizeof (USBServiceCall*): real_serv);

    char* srv = (char*) serv;
    if (real_serv == NULL)
    {
        return 0;
    }
    memset (serv, 0, size);

    USBDevFSEndpoint* ep = (USBDevFSEndpoint*)
        (srv +
        sizeof (USBServiceCall));

    USBDevFSEndpoint** eps = (USBDevFSEndpoint**)
        (srv +
        sizeof (USBServiceCall) +
        epn * sizeof (USBDevFSEndpoint));
    for (int i = 0; i < epn; ++i)
        eps[i] = ep + i;

    usb_interface_descriptor_t* idesc = (usb_interface_descriptor_t*)
        (srv +
        sizeof (USBServiceCall) +
        epn * sizeof (USBDevFSEndpoint) +
        epn * sizeof (USBDevFSEndpoint*));

    usb_interface_descriptor_t** idescs = (usb_interface_descriptor_t**)
        (srv +
        sizeof (USBServiceCall) +
        epn * sizeof (USBDevFSEndpoint) +
        epn * sizeof (USBDevFSEndpoint*) +
        nifs * sizeof (usb_interface_descriptor_t));
    for (int i = 0; i < epn; ++i)
        idescs[i] = idesc + i;

    serv->dev.address = dev->address;
    serv->dev.port_status = dev->powersrc->status;
    serv->dev.dev = dev->ddesc;

    /* only the device pointer and the name need filling in here - the rest
       are zero */
    serv->dev.ep_default.dev = &serv->dev;
    strncpy (serv->dev.ep_default.device_name, name, 19)[19] = '\0';

    serv->dev.config = dev->cdesc;
    serv->dev.eps = eps;
    strncpy(serv->dev.name, name, 19)[19] = '\0';

    serv->ep = ep;
    serv->epd = NULL;  // not filling this in
    serv->ifc = NULL;  // not filling this in
    serv->neps = epn;
    serv->nifs = nifs;
    serv->hostaddr = dev->powersrc->parent? dev->powersrc->parent->address: 0;
    serv->hostport = dev->powersrc->portno;
    serv->bus = dev->bus->bdev.dv_unit;

    serv->dev.ifcs = idescs;

    for (epn = 0, iface = 0; iface < nifs; ++iface)
    {
        int ifcepn = dev->ifaces[iface].idesc->bNumEndpoints;
        dprintf(("", "iface %d, num endpoints = %d, at %p\n", iface, ifcepn, idescs[iface]));
        memcpy (idescs[iface], dev->ifaces[iface].idesc,
            USB_INTERFACE_DESCRIPTOR_SIZE);
        struct usbd_interface * ifc = &dev->ifaces[iface];

        for (int n = 0; n < ifcepn; ++n, ++epn)
        {
            ep[epn].dev = &serv->dev;
            ep[epn].ifc = ifc->index;
            ep[epn].altifc = ifc->altindex;
            ep[epn].ep = ifc->endpoints[n].edesc;
            strncpy(ep[epn].device_name, name, 19)[19] = '\0';
        }
    }

    dprintf (("", "%s\n", name));
//    ddumpbuf ("", serv, size, (int) serv);

    return real_serv;
}
#else
a1359 1
#endif
d1534 2
a1535 2
        Service_USBDriver_Attach,
        Service_USBDriver,
a1586 14

#ifdef OBSOLETE_SERVICE_CALLS
    /* inform the world that the device has gone */
    char* serv = service_call (udev->sc_udev, udev->sc_dev.dv_unit, 0);
    int nothandled;
    _swix (OS_ServiceCall, _INR(0,2)|_OUT(1),
        Service_USBDriver_Detach,
        Service_USBDriver,
        serv,
        &nothandled);
    free (serv);
#endif


d2805 1
a2805 1
    case DeviceFSCallDevice_Initialise:
d2816 1
a2816 1
    case DeviceFSCallDevice_Terminate:
d2832 1
a2832 1
    case DeviceFSCallDevice_TxWakeUp:
d2841 1
a2841 1
    case DeviceFSCallDevice_RxWakeUp:
d2856 1
a2856 1
    case DeviceFSCallDevice_RxSleep:
d2858 1
a2858 1
    case DeviceFSCallDevice_EnumDir:
d2860 2
a2861 2
    case DeviceFSCallDevice_TxCreateBuffer:
    case DeviceFSCallDevice_RxCreateBuffer:
d2869 1
a2869 1
    case DeviceFSCallDevice_Halt:
d2871 1
a2871 1
    case DeviceFSCallDevice_Resume:
d2881 1
a2881 1
    case DeviceFSCallDevice_EndOfData:
d2887 1
a2887 1
    case DeviceFSCallDevice_StreamCreated:
d2911 2
a2912 2
    case DeviceFSCallDevice_MonitorTX:
    case DeviceFSCallDevice_MonitorRX:
d2942 1
a2942 1
    case DeviceFSCallDevice_USBRequest:
d2963 1
a2963 1
    case DeviceFSCallDevice_BufferSpace:
d2966 1
a2966 1
    case DeviceFSCallDevice_GetHandles:
d2969 1
a2969 1
    case DeviceFSCallDevice_GetLocation:
d2972 1
a2972 1
    case DeviceFSCallDevice_ClearStall:
d2975 1
a2975 1
    case DeviceFSCallDevice_TransferInfo:
d2978 1
a2978 1
    case DeviceFSCallDevice_GetHandles2:
d2981 1
a2981 1
    case DeviceFSCallDevice_GetSetOptions:
@


1.46
log
@Fix for out-by-1 error on incoming transfer
No transfer occurred if maxpacketsize exactly equalled the free space in the buffer.
Changes from Colin, ref http://www.riscosopen.org/forum/forums/3/topics/1895
Module version number bumped.

Version 0.79. Tagged as 'NetBSD-0_79'
@
text
@d1998 3
a2000 1
    if (valid->ep_type == 0xdeaddead)
d2012 1
d2026 1
a2026 1
            dprintf (("", "attributes %x\n", UE_GET_XFERTYPE (b->bmAttributes)));
d2028 6
a2033 15
            /* if we've found the requested endpoint, return the interface */
            if (UE_GET_ADDR(b->bEndpointAddress) == valid->endpoint &&
                ((dir & 1) << 7) != UE_GET_DIR(b->bEndpointAddress))
            {
                *iface_return = i;
                *endpoint_return = b->bEndpointAddress;
                return;
            }

            /* if no endpoint was requested, see if the type matches (if given)
               and the direction and the interface (if given) */
            else if (
                (valid->interface == i || valid->interface == 0xdeaddead) &&
                (valid->endpoint == 0xdeaddead) &&
                (valid->ep_type == UE_GET_XFERTYPE (b->bmAttributes)) &&
d2035 1
a2035 3
                (((dir & 1) << 7) != UE_GET_DIR(b->bEndpointAddress)) &&
                (valid->alternate == j || valid->alternate == 0xdeaddead)
            )
d2040 1
a2083 7
    /* flags bit one is the transmit bit, if set we're open for TX, i.e. an
       OUT endpoint */
    if (valid->endpoint != 0xdeaddead)
    {
        ep = valid->endpoint + ((flags & 1)? 0: 1 << 7);
    }

@


1.45
log
@Fix for potential NULL pointer dereference
Spotted by Colin http://www.riscosopen.org/forum/forums/4/topics/1874
Built, but not tested.

Version 0.78. Tagged as 'NetBSD-0_78'
@
text
@d2558 1
a2558 1
    if (actlen > maxpacket)
@


1.44
log
@Fix one read at the filesystem level turning into two transfers at the USB level
Detail:
  build/c/usbmodule - The introduction of the delayed_read flag brought with it a bug, whereby performing one read at the filing system level would result in two transfers at the USB level: One transfer triggered by the RxWakeUp device call, and a second read triggered by the Resume device call once the devices buffer becomes empty.
  To counter this a new read_status variable is used to track the state of the filesystem-level transfer; idle, busy, or complete. Only start_read calls triggered by RxWakeUp are able to start new filesystem-level transfers, while Resume is only able to continue transfers which had been paused due to lack of buffer space.
  Additionally if a RxWakeUp call is received before the previous transfer had finished, the read amount is now buffered correctly, and the read count/padding count will only be reset once the new read actually starts.
  Also made DeviceFS-level debug output more verbose and useful; most read/write debug output now lists the associated usbd_xfer_handle, making it easier to track transfers once they enter the NetBSD layer.
  build/Version - Increase USBDriver version number
Admin:
  Tested on BB-xM
  FTDIDriver now apears to work correctly again


Version 0.75. Tagged as 'NetBSD-0_75'
@
text
@d1378 1
a1378 1
    USBServiceCall* serv = (USBServiceCall*) (link? real_serv + 4: real_serv);
d1381 1
a1381 1
    if (serv == NULL)
d1470 1
a1470 1
    USBServiceCall* serv = (USBServiceCall*) (link? real_serv + 4: real_serv);
d1472 1
a1472 1
    if (serv == NULL)
@


1.43
log
@Make delayed_read handling more robust
Detail:
  build/c/usbmodule - read_cb() now explicitly clears the delayed_read flag, and only issues a delayed read if the pipe isn't a repeating type
  build/Version - Increased USBDriver version number
Admin:
  Tested on BB-xM


Version 0.74. Tagged as 'NetBSD-0_74'
@
text
@d98 6
d135 3
a137 1
    bool delayed_read;
d2107 2
d2228 2
d2272 2
d2302 5
d2310 1
a2310 1
        return;
d2316 1
a2316 1
        return;
d2323 1
a2323 1
        return;
a2325 3
    int s = _kernel_irqs_disabled ();
    _kernel_irqs_off ();

d2379 1
d2391 2
a2393 1
    str->delayed_read = false;
d2399 2
d2407 2
d2414 1
d2430 2
d2485 4
d2492 1
a2492 1
        return;
d2498 1
a2498 2
        str->delayed_read = true; /* Flag that we want to start another read after the current one finishes. This may result in some confusion over how much data is being requested and when padding should be applied, but it's better than having no checks at all and creating circular references in the pipes xfer queue. */
        return;
d2505 1
a2505 1
        return;
d2508 1
a2508 1
    if (str->count >= str->totalcount && !str->xfer->pipe->repeat)
d2511 4
a2514 1
        return;
a2516 2
    int s = _kernel_irqs_disabled ();
    _kernel_irqs_off ();
d2518 23
a2541 1
    str->delayed_read = false;
d2958 1
d2994 2
d2997 2
a2998 2
        dprintf (("main", "wakeup write, resetting count to %d\n",
            str->count));
d3000 1
d3003 10
a3012 7
        str->count = 0;
        str->padded_bytes=0;
        /* total length has always been passed in R3, although not documented */
        str->totalcount = r->r[3];
        dprintf (("main", "wakeup read, resetting count to %d, totalcount to %d\n",
            str->count, str->totalcount));
        if (!str->pipe->repeat)
d3014 2
d3033 1
a3033 1
        dprintf (("main", "resume ep = %x\n", str->ep));
d3067 1
@


1.42
log
@Make get_transfer_info() take into account any delayed xfer
Detail:
  build/c/usbmodule - If there's a read xfer which has been delayed due to RxWakeup being called before the previous xfer had finished (e.g. while inside a buffer filling upcall), report the transfer as having not finished yet. Should match the old behaviour before the delayed reads were introduced.
  build/Version - Increment USBDriver version number
Admin:
  Tested briefly on BB-xM


Version 0.73. Tagged as 'NetBSD-0_73'
@
text
@d2372 1
d2374 2
a2375 1
    str->xfer_busy = (status == USBD_IN_PROGRESS);
d2393 1
a2393 1
        if(str->delayed_read)
d2427 1
a2427 1
        if(str->delayed_read)
@


1.41
log
@Fix null pointer dereferences. Add protection against DeviceFS xfers being multiply inserted into their pipes xfer queue.
Detail:
  build/Version - Increased version numbers
  build/c/ehcimodule, build/c/ohcimodule - Fixed null pointer dereferences in debug code
  build/c/port, build/s/triggercbs - Fix debug code in tsleep() using hardcoded IRQsema ptr. Now requests the right pointer from build/s/triggercbs.
  build/c/usbmodule - Fix null pointer deferences in debug code and MonitorTX/MonitorRX handlers. Add xfer_busy and delayed_read flags to devstream struct in order to track whether the xfer associated with the stream is busy or not. Previously if the TxWakeUp/RxWakeUp device calls were made on a stream which already had an active xfer, the xfer would end up being inserted in the USB pipes xfer queue twice, creating a circular reference, resulting in (at the least) infinite loops in usbd_dump_queue() when debugging is enabled. Now, in the case of reads, a second read will automatically be issued once the first completes, while in the case of writes, the write request will simply be ignored. This isn't a proper fix for all the shortcomings of the DeviceFS interface, but at least the code is now a little bit safer.
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.72. Tagged as 'NetBSD-0_72'
@
text
@d2864 3
a2866 1
        *status=1;
@


1.40
log
@Make RHENIUM build switch go away. Misc housekeeping
Detail:
  build/Makefile, build/!MkDebug,fd7 - Debug versions of the modules can now be built just by passing "DEBUG=TRUE" to amu
  build/!MkRhenium,fd7 - Deleted obsolete file
  build/Version - Increased version numbers
  build/c/ehcihal, build/c/ehcimodule, build/c/ohcimodule - Only accept USB controllers if HAL_USBControllerInfo says the struct size is an exact match with what we expect. Rework USB controller enumeration to allow modules to properly support both PCI and HAL controllers being available on the same machine, and without RHENIUM switch (module sources only).
  build/c/ehcimodule - Get rid of remaining RHENIUM bits; RHENIUM flag no longer needed for 32bit wide register reads/writes to be supported
  build/c/ohcimodule, build/cmhg/ohcimodhead, dev/usb/c/ohci - Get rid of remaining RHENIUM bits; RHENIUM flag no longer needed for HAL port power controls to be supported.
  build/c/usbhal, build/c/usbmodule, dev/usb/c/uhub, dev/usb/h/usb_port - Get rid of empty riscos_failed_device function
  build/s/call_veneer, build/s/triggercbs - Use Entry/EXIT macros to avoid single-reg LDM/STM performance warnings. Convert tabs to spaces.
  dev/usb/h/usb - Get rid of RHENIUM switch on USB_PORT_RESET_DELAY. Now always uses non-RHENIUM value of 100ms.
Admin:
  Tested on rev A2 BB-xM, Iyonix, Raspberry Pi


Version 0.71. Tagged as 'NetBSD-0_71'
@
text
@d128 2
d343 4
a346 3
    usbdebug = atoi(getenv("usbdebug"));
    uhubdebug = atoi(getenv("uhubdebug"));
    uhidevdebug = atoi(getenv("uhidevdebug"));
a1180 3
    char* getenv (const char*);
    int atoi (const char*);
    char* del ;
d1182 2
a1183 1
    dprintf (("", "look for %s.. got x%sx\n",str,getenv (str)));
d1185 1
a1185 1
    if(!getenv (str) )    /* check if we are allowed to handle it */
d2260 2
a2287 1
    static int reentry = 0;
d2294 6
a2305 6
    if (reentry != 0)
    {
        dprintf (("", "!! start_write reentered !!\n"));
        return;
    }
    reentry = 1;
d2310 2
d2345 2
d2359 1
a2363 1
    reentry = 0;
d2373 2
d2390 7
a2396 2
       /* Whatever happened, we're finished */
       return;
d2424 6
a2457 1
    static int reentry = 0;
d2464 7
a2483 6
    if (reentry != 0)
    {
        dprintf (("", "!! start_read reentered !!\n"));
        return;
    }

d2486 3
a2488 1
    reentry = 1;
d2522 5
a2526 1
            if (actlen <= 0) goto end;
d2566 3
d2578 4
a2582 1
    reentry = 0;
d3010 4
a3014 2
            /* the xfer is NULL for case of HID not owning the xfer */
            if (str->xfer == NULL||
d3016 1
a3016 1
                status == USBD_NORMAL_COMPLETION ||
@


1.39
log
@Use the passed buffer limit rather than 255.
Avoids potential buffer overrun, since the actual buffers are 128 at the moment.

Version 0.69. Tagged as 'NetBSD-0_69'
@
text
@a184 13
void riscos_failed_device (void* p)
{
//#ifdef STANDALONE
#ifndef RHENIUM
//    _kernel_oserror* e;
    (void) p;
//    e = uerror (E_BadDevice);
//    _swix (OS_UpCall, _INR(0,6), UpCall_MediaNotPresent, fsnumber_DeviceFS,
//        -1, -1, 0, 0x7f/*ffffff*/, e->errmess);
#endif /*RHENIUM*/
//#endif /*STANDALONE*/
}

@


1.38
log
@Add some more usbdevs from the NetBSD sources.
In particular, the SMSC ethernet controller and hub on the Beagleboard
xm.
Changed pointer assignments & comparisons with 0 to be NULL for clarity.
Implement a left trim function for any printed out strings obtained from
the device (to mirror usbd_trim_spaces) so that when dopey manufacturers
use a space instead of their company name everything lines up still.

Version 0.68. Tagged as 'NetBSD-0_68'
@
text
@d1914 1
a1914 1
            255,
d1931 1
a1931 1
            255,
@


1.37
log
@Fix modules so resources don't get included twice in ROM builds
Detail:
  A couple of the USB modules were including their resources both in the Messages module and within themselves, leading to wasted ROM space
  build/OBJOHCIDriver, build/OBJUSBDriver - Tweaked makefiles so that ohcimsgs.o and usbmsgs.o only get built/linked for RAM builds
  build/c/usbmodule - Fix erroneous attempt to free non-registered resource files in ROM builds
  Version - Increased OHCIDriver & USBDriver version numbers
Admin:
  Tested with Iyonix ROM softload. Saves approx 48k of ROM space.
  Fixes bug #265


Version 0.57. Tagged as 'NetBSD-0_57'
@
text
@d428 9
d438 3
a440 1
_kernel_oserror* RegisterNewDevice(struct ugen_softc * softc,int no)
d473 1
d501 1
a501 1
dprintf(("","registering %d \n",dev->dv_unit));
d516 1
a516 1
dprintf(("","forgetting %d \n",dev->dv_unit));
d684 3
a686 2
    char string[127];
    struct device* dev = get_usbdev (n);
a703 6
    printf ("Manufacturer    : '%s'\n",
        usbd_get_string (udev, ddesc->iManufacturer, string)? string: "");
    printf ("Product         : '%s'\n",
        usbd_get_string (udev, ddesc->iProduct, string)? string: "");
    printf ("Serial number   : '%s'\n",
        usbd_get_string (udev, ddesc->iSerialNumber, string)? string: "");
d705 3
d716 1
a716 1
    char string[127];
d718 1
d734 2
a735 2
    printf ("Name            : '%s'\n",
        usbd_get_string (udev, cdesc->iConfiguration, string)? string: "");
d767 1
d774 1
a774 1
                usbd_get_string (udev, d->iInterface, string)? string: "");
d1332 1
a1332 1
    if (softc == 0) {
d1693 1
a1693 1
    if (softc == 0) {
d1821 1
a1821 1
    if (priv_id == 0)
d1885 1
a1885 1
    char *vendor = 0, *product = 0;
d1897 6
a1902 2
        vendor = usbd_get_string(dev, udd->iManufacturer, v);
        product = usbd_get_string(dev, udd->iProduct, p);
d2681 1
a2681 1
        if (p == 0) return uerror (E_NoMem);
d2683 1
a2683 1
        if (p == 0) return uerror (E_NoMem);
d2688 1
a2688 1
        if (p == 0) return uerror (E_NoMem);
@


1.36
log
@Fix a few USBDriver bugs
Detail:
  build/c/usbdi - Fix compiler warning in usbd_clear_endpoint_stall()
  build/c/usbmodule - Fix detach_device() to deregister any pending attach callback for the detaching device. Fixes crash seen when inserting 16GB USB stick into EHCI port of rev C2 beagleboard (a current surge or something causes the stick to immediately disconnect then reconnect, but the disconnect occurs before the initial attach callback)
  build/c/usbmodule - Fix device_initialise() to use a timeout of 0 if no timeout was specified in the DeviceFS special field
  build/c/usbmodule - Fix the new read_cb() buffer padding logic to only pad up to totalcount instead of filling the entire buffer
Admin:
  Tested on rev C2 beagleboard.
  This seems to fix the problems that were preventing Steffen Huber's USB CD code from working properly.


Version 0.56. Tagged as 'NetBSD-0_56'
@
text
@d348 1
a348 1
    if (e) goto error0;
d350 1
a350 1
    if (e) goto error1;
d371 1
a371 1
error1:
d373 1
a373 2
error0:
    _swix (ResourceFS_DeregisterFiles, _IN (0), resource_files ());
a374 1
    return e;
@


1.35
log
@Revert previous commit as it has already been superceded.

Version 0.55. Tagged as 'NetBSD-0_55'
@
text
@d1733 2
d2092 1
a2092 1
    str->timeout = valid->timeout;
d2405 1
@


1.34
log
@Minor bugfix and documentation improvements.
Detail:
  I have done some minor changes to the USB documenation in a few points
  and corrected a smaller bug inside the USB alias handling (used release
  instead interface).
Author:
  Thomas Milius

Version 0.54. Tagged as 'NetBSD-0_54'
@
text
@d15 1
a15 3
/* Changed 17.02.2010 TM DeviceFSCallDevice_TransferInfo and notation of padded bytes.
   Changed 07.10.2010 TM launch_system_variable case 1 for known interface is config/interface and
                         not interface/release */
d1578 1
a1578 1
                        alias, vendor, product, config, interface);
@


1.33
log
@Update EHCI driver to NetBSD latest (as of 10/07/2010), improve DeviceFS interface
Detail:
  EHCI driver update:
    dev/usb/c/ehci - Updated to latest NetBSD version, except for revisions 1.134 and 1.135 which are too invasive to merge in without updating the rest of the USB stack. This new version brings lots of bug fixes, and adds (untested on RISC OS) support for EHCI isochronous transfers.
    dev/usb/h/ehcivar - Updated to latest NetBSD version, except for the sc_bus splitting that was held back from the ehci.c update
    dev/usb/h/usb, dev/usb/h/usbdi, dev/usb/usbdivar - partial update to latest as required/possible
    dev/usb/c/usb_quirks, dev/usb/h/ehcireg, dev/usb/h/usb_mem, dev/usb/h/usb_quirks, dev/usb/h/usbhid, dev/usb/usbdevs, dev/usb/devlist2h.awk, dev/wscons/h/wsconsio, dev/wscons/h/wsmousevar - Updated to latest NetBSD versions
    dev/usb/c/usbroothub_subr, dev/usb/h/usbroothub_subr - New files brought in from NetBSD sources for use with new EHCI driver
    build/objehcidriver - Added usbroorhub_subr to EHCI driver
    dev/usb/h/usb_port - Added extra dummy functions as required by new EHCI driver
    dev/build/c/port - Added extra parameter to callout_init as required by new EHCI driver
  DeviceFS improvements:
    build/c/usbmodule - Added DeviceFSCallDevice_GetHandles2 as a replacement for Thomas Milius's backwards-incompatible GetHandles changes. Added DeviceFSCallDevice_GetSetOptions call to control RX padding and TX force-short-xfer features. These features can also be controlled at endpoint creation time by new fields in the filename. Also fixed packet padding to not fill the buffer with garbage or potentially crash when the padded area is more than one packet in length.
  New bus registration API:
    Changes made to the data structures that are shared between the modules means that new checks are needed to ensure USB modules with incompatible APIs are not used with one another.
    build/h/usbdivar - Since this seems to be the file containing the main structures that are shared, it now has a #define at the top indicating the first version of the USBDriver module that implemented the data structures within. This version number is used to check that the driver modules are compatible.
    build/cmhg/usbmodhead, build/h/usbdriver, build/c/usbmodule - Add a new SWI, USBDriver_Version, to return the version number of the USBDriver module. Used for both intra-stack API version checks and can be useful for external code that wants to query DeviceFS feature availability.
    build/c/usbmodule, build/c/ehcimodule, build/c/ohcimodule - Updated USBDriver_RegisterBus SWI and the code that calls it to pass the API version number (as defined in usbdivar.h) to USBDriver when attempting to reigster the bus. USBDriver then ensures the version matches that of itself, and if not refuses to allow the bus to register. EHCI & OHCI modules also check that USBDriver is new enough to implement this behaviour via the USBDriver_Version SWI.
  And finally:
    build/version - Incremented module version numbers.
    build/doc/usb - Updated with details of new features
Admin:
  Tested in ROM softload on Iyonix & beagleboard. Beagleboard hub issues seem to be resolved, and there are no new bugs that I can see.


Version 0.52. Tagged as 'NetBSD-0_52'
@
text
@d15 3
a17 1
/* Changed 17.02.2010 TM DeviceFSCallDevice_TransferInfo and notation of padded bytes. */
d1580 1
a1580 1
                        alias, vendor, product, interface, release);
@


1.32
log
@  Support for USB short packages
Detail:
  * DeviceFSCallDevice_TransferInfo and notation of padded bytes
  * Added (updated) documentation
Admin:
  Provided by Thomas Milius

Version 0.51. Tagged as 'NetBSD-0_51'
@
text
@d71 2
d74 1
a74 1

d85 1
d123 4
d452 1
a452 1
        "endpoint/Ninterface/Nalternate/Nreport/Ncontrol,isochronous,bulk,interrupt/Susbtimeout/Nsize/N",
a1072 4
//    case USBDriver_Register:
//        break;
//    case USBDriver_DeRegister:
//        break;
d1074 4
d1101 3
d1968 2
d2092 3
d2321 1
a2321 1
            (void*) r.r[2], r.r[3], USBD_NO_COPY, 500, write_cb);
d2329 1
a2329 1
            0,
d2377 5
d2387 1
a2387 20
//    if(!xfer->pipe->repeat)
//    {
//      if(xfer->actlen < xfer->length)
//      {
//          char zero[ UGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize)];
//          memset (zero, 0, sizeof zero);
//          /* fill up the rest of the request with garbage! */
//          _kernel_swi_regs r;
//          r.r[0] = BM_InsertBlock;
//          r.r[1] = (int) str->buffer_id;
//          r.r[2] = (int) zero;
//          r.r[3] = str->totalcount - str->count;
//          dprintf (("", "Fill insert %x bytes\n",r.r[3]));
//          CallBufMan (&r);
//      }
//      else if (str->count != str->totalcount)
//      {
//          dprintf (("", "Starting read from callback\n")UGUGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize);
    if ((xfer->actlen % UGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize))
        && str->count != str->totalcount)
d2393 1
a2393 1
        str->padded_bytes=str->totalcount - str->count;
d2399 8
a2406 3
        r.r[2] = (int) zero;
        r.r[3] = str->totalcount - str->count;
        CallBufMan (&r);
d2408 1
a2408 1
    else if (str->count != str->totalcount && !xfer->pipe->repeat)
d2844 16
d3026 1
a3026 1
        return get_handles (udev, r->r[2], r->r + 3, r->r + 4, (struct devstream **) ((int *) r->r + 5), (devicefs_device**) ((int *) r->r + 6));
d3037 6
@


1.31
log
@Add workaround for incorrect sizeof(usb_status_t), disable debug_set_stamp_debug(TRUE) to fix interrupt issue
Detail:
  build/c/ehcimodule, build/c/ohcimodule, build/c/usbmodule - Make sure that timestamped debug messages aren't used, as they appear to cause interrupts to be briefly enabled, which causes all kinds of problems in sensitive bits of the code.
  dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/h/usb - Because DISABLE_PACKED is being used to compile the USB drivers, sizeof(usb_status_t) was being calculated as 4 bytes instead of 2. Somehow this works fine with the EHCI driver (and presumably the OHCI driver), but it was causing problems with the MUSBDriver, so a hardcoded size of 2 is now used.
Admin:
  Tested on rev C2 beagleboard.


Version 0.48. Tagged as 'NetBSD-0_48'
@
text
@d15 1
d70 1
d119 1
a1339 1

d2384 1
a2384 5
//          dprintf (("", "Starting read from callback\n"));
//          start_read (str);
//      }
//    }

d2388 1
d2390 3
d2723 3
a2725 1
    int*                dvfs
d2739 2
d2807 31
d2888 1
d3004 1
a3004 1
        return get_handles (udev, r->r[2], r->r + 3, r->r + 4);
d3012 3
a3020 1

@


1.30
log
@	re-merged some items missed by Dan, and corrected usbmodule for
	1 item missed earlier.. interrupt out endpoints noe demonstrated
	working
Detail:
Admin:  jb  Castle added IP


Version 0.45. Tagged as 'NetBSD-0_45'
@
text
@d324 1
a324 1
    debug_set_device(DEBUGIT_OUTPUT);
d327 2
a328 1
    debug_set_stamp_debug (TRUE);
@


1.29
log
@Committed incorrect file previously
@
text
@d2204 1
a2204 1
        str->pipe->repeat = 1;
@


1.28
log
@  Now handles interrupt out transfers

Detail:
  There were many places where this was broken: the devicefs
interface was always starting off a read regardless of
whether it was an IN or OUT transfer, usbdi.c was setting
OUT interrupt transfers as repeating, which doesn't make sense,
and ohci.c was always making interrupt transfers OUT (this is
fixed in the latest BSD sources). Also the code which
unhalts endpoints at start of day has been removed, as this is
no longer in the BSD sources having been removed after it was
seend to have caused problems.

Admin:
  Tested with a CATC analyzer on an AverMedia FM radio. If now
operates properly with the code from Dave Higton.

Version 0.43. Tagged as 'NetBSD-0_43'
@
text
@a32 2
/* avoid redefinition of printf */
#define no_printf 1
a37 3
<<<<<<< usbmodule
#undef no_printf
=======
a38 1
>>>>>>> 1.26
d59 1
a59 1
#define	FWRITE		0x0002
d127 1
a127 1
    USBBASEDEVICE sc_dev;		/* base device */
d234 19
a252 19
	"NORMAL_COMPLETION",
	"IN_PROGRESS",
	"PENDING_REQUESTS",
	"NOT_STARTED",
	"INVAL",
	"NOMEM",
	"CANCELLED",
	"BAD_ADDRESS",
	"IN_USE",
	"NO_ADDR",
	"SET_ADDR_FAILED",
	"NO_POWER",
	"TOO_DEEP",
	"IOERROR",
	"NOT_CONFIGURED",
	"TIMEOUT",
	"SHORT_XFER",
	"STALLED",
	"INTERRUPTED"};
d288 1
d409 1
a409 1
    
d451 1
a451 1
}    
d478 2
a479 2
                  dev->dv_unit = maxdev_no = usbdev_no++; 
                  
d591 1
a591 1
    puts ("Bus   Control Isochronous    Bulk Interrupt  Errors");
d600 1
a600 1
        printf ("%3d %9lu %9lu %9lu %9lu %9lu\n",
d605 1
a605 2
            stats.uds_requests[UE_INTERRUPT],
            stats.uds_errors);
a610 2
<<<<<<< usbmodule

a611 3
=======
_kernel_oserror* command_discover (void)
>>>>>>> 1.26
d630 1
d638 1
d645 1
a645 13
        struct usbd_hub* hub = udev->hub;
        int nports = hub->hubdesc.bNbrPorts, p;
        for(p = 0; p < nports; p++)
        {
            if (hub->ports[p].device)
            {
                usb_disconnect_port (hub->ports + p, hub->hubsoftc);
                usbd_clear_port_feature(udev, p, UHF_PORT_POWER);
                usbd_delay_ms(udev, USB_PORT_RESET_DELAY);
                usbd_set_port_feature(udev, p, UHF_PORT_POWER);
            }
        }
        return NULL;
d648 1
a648 1
    usb_disconnect_port (port, parent->myhub->hub->hubsoftc);
d653 3
a655 3
					             * UHD_PWRON_FACTOR
					    + USB_EXTRA_POWER_UP_TIME;
					usbd_delay_ms(parent, pwrdly);
a658 1

d870 4
a873 4
//	u_int16_t idVendor;
//	u_int16_t idProduct;
//	u_int16_t bcdDevice;
//	u_int32_t quirks;
d881 1
a881 1
  
d888 1
a888 1
      
d926 1
a926 1
    {    
d930 1
a930 1
  }      
d958 1
a958 1
//        uhidevdebug = usbdebug;
d1136 1
a1136 1
    for (int i = 1; i < usbbus_no; i++)             
d1164 2
a1165 2
    char* getenv (const char*); 
    int atoi (const char*);     
d1167 3
a1169 3
    char* getenv (const char*); 
    int atoi (const char*);     
    char* del ;   
d1195 1
a1195 1
          { 
d1198 1
a1198 1
          }  
d1599 1
a1599 2
<<<<<<< usbmodule
    dprintf (("", "Found match for %s = %s\n", str, name));
a1600 4
    len = strlen (name);
=======
    len = strlen (name);
    
a1601 1
>>>>>>> 1.26
d1621 1
a1621 1
  
a1752 5
    if (bus->root_hub == NULL)
    {
       dprintf (("", "discover called before root hub established\n"));
       return NULL;
    }
a1855 19
<<<<<<< usbmodule
static void
usbd_trim_spaces(char *p)
{
	char *q, *e;

	if (p == NULL)
		return;
	q = e = p;
	while (*q == ' ')	/* skip leading spaces */
		q++;
	while ((*p = *q++))	/* copy string */
		if (*p++ != ' ') /* remember last non-space */
			e = p;
	*e = 0;			/* kill trailing spaces */
}

void usbd_devinfo_vp(usbd_device_handle dev, char* v, size_t vl, char* p, size_t pl, int usedev)
=======
a1856 1
>>>>>>> 1.26
d1872 2
a1873 17
                if (usbd_get_string(dev, udd->iManufacturer, v))
                        vendor = NULL;
                else
                        vendor = v;
		usbd_trim_spaces(vendor);
                if (usbd_get_string(dev, udd->iProduct, p))
                        product = NULL;
                else
                        product = p;
		usbd_trim_spaces(product);
		if (vendor && !*vendor)
			vendor = NULL;
	if (product && !*product)
	    product = NULL;
    } else {
	vendor = NULL;
	product = NULL;
d1976 1
a1976 1
    dprintf (("", "looking for %x, iface %x, alt %d, type %x, dir %x\n",
d2116 1
a2116 1
        
d2122 1
a2122 1
            if (ifc->sc_iface->index == iface)     
d2234 1
a2234 1
		      usbd_status status)
d2240 1
a2240 1
        dprintf (("", "Bad completion code: %d (%s), %d bytes read\n", status, ccodes[status], xfer->actlen));
d2315 2
a2316 2
	str->xfer->rqflags |= URQ_RISCOS_BUF;
	dprintf (("", "transferring %d bytes\n", r.r[2]));
d2318 1
a2318 1
	str->xfer->status = usbd_transfer (str->xfer);
d2320 8
a2327 8
	/* this can either return in progress, or normal completion (if
	   the pipe wasn't already running) */
	if (str->xfer->status != USBD_IN_PROGRESS &&
	    str->xfer->status != USBD_NORMAL_COMPLETION)
	{
	    dprintf (("", "Failed to insert transfer, status = %d (%s)\n",
	        str->xfer->status, ccodes[str->xfer->status]));
	}
d2342 1
a2342 1
		      usbd_status status)
a2361 16
<<<<<<< usbmodule
    if ((xfer->actlen % UGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize)) &&
      str->count != str->totalcount && !xfer->pipe->repeat)
    {
        char zero[ UGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize)];
        memset (zero, 0, sizeof zero);
        /* fill up the rest of the request with garbage! */
        _kernel_swi_regs r;
        r.r[0] = BM_InsertBlock;
        r.r[1] = (int) str->buffer_id;
        r.r[2] = (int) zero;
        r.r[3] = str->totalcount - str->count;
        CallBufMan (&r);
    }
    else if (str->count != str->totalcount && !xfer->pipe->repeat)
=======
d2379 1
a2379 1
//      else if (str->count != str->totalcount) 
a2399 1
>>>>>>> 1.26
d2516 2
a2517 2
	    dprintf (("", "starting (bulk/interrupt) transfer of %d bytes\n",
	        actlen));
d2521 1
a2521 1
	    dprintf (("", "starting (isoc) transfer of %d bytes\n", str->size));
d2525 1
a2525 1
	str->xfer->rqflags |= URQ_RISCOS_BUF;
d2527 9
a2535 9
	str->xfer->status = usbd_transfer (str->xfer);
	/* this can either return in progress, or normal completion (if
	   the pipe wasn't already running) */
	if (str->xfer->status != USBD_IN_PROGRESS &&
	    str->xfer->status != USBD_NORMAL_COMPLETION)
	{
	    dprintf (("", "Failed to insert transfer, status = %d (%s)\n",
	        str->xfer->status, ccodes[str->xfer->status]));
	}
d2547 1
a2547 1
        str, str->ep, kill));
d2904 5
a2908 13
            start_read (str);
//            dprintf (("", "inserting interrupt transfer\n"));
//            usbd_setup_xfer(
//                str->xfer,
//                str->pipe,
//                str,
//                (void*) str->buffer_id,
//                UGETW(str->pipe->endpoint->edesc->wMaxPacketSize),
//                USBD_SHORT_XFER_OK,
//                str->timeout,
//                read_cb);
//
//            str->xfer->status = usbd_transfer (str->xfer);
@


1.27
log
@	Added USB$Ignore_VVVV_PPPP variable.. if it exists
	then the internal hub/kbd/mouse checks are not done.
	it is left ONLY to external programs
Detail:
Admin:


Version 0.42. Tagged as 'NetBSD-0_42'
@
text
@d33 2
d40 3
d44 1
a293 1
extern char* usbd_get_string (usbd_device_handle, size_t, char*);
d596 1
a596 1
    puts ("Bus   Control Isochronous    Bulk Interrupt");
d605 1
a605 1
        printf ("%3d %9lu %9lu %9lu %9lu\n",
d610 2
a611 1
            stats.uds_requests[UE_INTERRUPT]);
d617 4
d622 1
a640 1

a647 1

d654 13
a666 1
        return uerror (E_NotRootP);
d669 1
a669 1
    usb_disconnect_port (port, (device_ptr_t) parent->hub);
d680 1
d980 1
a980 1
        uhidevdebug = usbdebug;
d1621 5
d1629 1
d1781 5
d1889 19
d1909 1
d1925 17
a1941 2
        vendor = usbd_get_string(dev, udd->iManufacturer, v);
        product = usbd_get_string(dev, udd->iProduct, p);
d2044 1
a2044 1
    dprintf (("", "looking for %x, iface %d, alt %d, type %x, dir %x\n",
d2430 16
d2484 1
d2632 1
a2632 1
        str, str?str->ep:0, kill));
@


1.26
log
@	Fixed abort seen with some KVMs and ps2 adaptors in relation
	to !HID
Detail:
	Devices with HID kbd and mouse in separate interfaces were
	not being correctly 'forgotten' when the device was claimed
	by a 3rd party App (!HID). This was because a re-entrancy issue
	led to the second claimed i/f being removed before the first
	was fully removed.
	This led to a muddle in the dev->subdevs array. Solution was to
	unlink it from the subdevs array before 'detaching' it,
	instead of after.
Admin:
	Castle added IP. Tested at Castle. Will be initially released via
	the beta test site.


Version 0.41. Tagged as 'NetBSD-0_41'
@
text
@d1163 21
a1183 9

    typedef device_ptr_t pf (device_ptr_t, void*);
    pf* funcs[] = { attach_hub, attach_mouse, attach_keyboard, NULL };
    for (pf** f = funcs; *f != NULL; ++f)
    {
        if ((ret = (*f) (parent, aux)) != NULL)
        {
          return ret;
        }
@


1.25
log
@	several changes and nullpointer bug fixes
Detail:
	Includes several bug fixes and null pointer traps.
	Rhenium version reviewed and reset should be improved.
Admin:
	Tested in rhenium desktop build and iyonix build at castle
   	Castle added IP


Version 0.40. Tagged as 'NetBSD-0_40'
@
text
@d2113 1
a2113 2
                config_detach (ugen->sc_udev->subdevs[n], 0);
                /* compact the list */
d2120 1
@


1.24
log
@        2 specific changes to USBDriver module
        Added (and fixed code underlying) to give periodic
        explore of USB busses (cf NetBSD).
        Added USBDisover command to let user provoke this too.
        Reworked USB device number allocation to roll
        around at 999 to avoid field overflow in
        a number of places.
Detail:
Admin:  castle added IP. to be beta tested on beta test site


Version 0.37. Tagged as 'NetBSD-0_37'
@
text
@d263 3
a265 3
static int usbbus_no = 1;
static int usbdev_no = 1;
static int maxdev_no = 1;
d350 1
a350 1
    maxdev_no = 1;
a376 7
    struct device* dev;
    TAILQ_FOREACH(dev, &allbuses, dv_list)
    {
        (*usb_ca.ca_detach)(dev, 0);
        free (dev);
    }

d378 1
d388 7
d472 1
a472 1
          maxdev_no = 1;
d489 1
a489 1
          maxdev_no = 1;
d536 12
d615 1
d617 1
a617 1
    for (int i = 1; i <= usbbus_no; ++i)
a642 1

d650 1
a650 1
    usbd_delay_ms(parent, USB_PORT_RESET_DELAY);
d652 4
a655 1

d1136 1
a1136 1
    for (int i = 1; i <= usbbus_no; ++i)
a1143 5
//    TAILQ_FOREACH(dev, &allbuses, dv_list)
//    {
// dprintf(("","rediscover bus %p, %p \n",dev,&dev->dv_list));
//        usb_needs_explore_callback (&dev->dv_list);
//    }
a1177 1
      usbdev_no++;
d1182 3
a1184 1
          if( usbdev_no != startnum) 
d1186 1
d1188 1
a1188 1
      ((usbd_device_handle)dev)->dv_unit = usbdev_no;
@


1.23
log
@         changes and bug fixes that came to light following USB2 launch.
Detail:
         - VarVal launching.. string length was incorrectly calculated.
         - USB VarVals now correctly cleared if device failed during
           enumeration, after first SetVarVal call.
         - Triggercbs() modified to check interrupt context and be
           refuse (quietly) to trigger callbacks if interrupts threaded
           (result of possible issue .. but perhaps wise)
         - Added third QueryDelay variable, and an Info file to describe
           what does what.
Admin:
         checked at Castle.. due for extended check via beta test site
         before formal release.

         Castle + D Ellis added IP


Version 0.35. Tagged as 'NetBSD-0_35'
@
text
@d265 1
d302 1
d310 4
a313 1

d350 1
d401 2
a403 2
    callx_remove_all_callafters ();
    callx_remove_all_calleverys ();
d471 1
d477 2
a478 1
                  dev->dv_unit = usbdev_no++;
d480 1
a480 1
                   RegisterNewDevice( ((struct ugen_softc*) dev),dev->dv_unit);
d488 1
d544 1
a544 1
    for (int i = 1; i < usbdev_no; ++i)
a597 1

d603 1
a603 2

    for (int i = 1; i < usbbus_no; ++i)
a610 1

d614 1
d1012 1
a1012 1
    dprintf (("", "adding bus %p\n", bus));
d1114 24
d1163 14
a1176 1
    if(!((usbd_device_handle)dev)->dv_unit) ((usbd_device_handle)dev)->dv_unit = usbdev_no++;
d1716 1
a1716 1
           has removed its memory, 'bus' us no longer a valid pointer, and
d1718 1
d1723 2
a1724 1
    dprintf (("", "bus has been removed\n"));
d1757 1
d1760 1
a1760 2
        dprintf (("", "Adding explore callback\n"));
        if(bus->callbacks>10) bus->callbacks=10;
d1764 1
a1764 1
        dprintf (("", "deferring callback - %d callbacks queued\n", bus->callbacks));
@


1.22
log
@        Stack brought up to date with NetBSD sources as at 20050121.
        USB2 further debugged.
Detail:
        Check in prior to second beta release. Improvements also to
        softloading of replacement modules.
Admin:
        Checked with JB .. further crosschecking is still needed for rhenium.
        Castle/D Ellis added ip from NetBSD sources


Version 0.33. Tagged as 'NetBSD-0_33'
@
text
@d190 1
a190 1
    dprintf (("", "loading message file: %s\n", mess->filename));
d280 1
d926 1
a926 1

a1106 1

d1109 1
d1131 3
a1133 2

    ret = attach_device (parent, aux, usbdev_no);
d1136 1
a1136 1
        ret->dv_unit = usbdev_no++;
d1202 2
a1203 12
        char var[sizeof "DeviceFS$USBnnn$Options"];
        /*          and "USB$Device_*USBnnn" */
        sprintf (var, "USB$Device_*USB%d", dev->dv_unit);
        while (_swix (OS_SetVarVal, _INR(0,4), var, 0, -1, 0, 0) == NULL)
        {
            /* do nothing */
        }
        sprintf (var, "DeviceFS$USB%d$Options", dev->dv_unit);
        while (_swix (OS_SetVarVal, _INR(0,4), var, 0, -1, 0, 0) == NULL)
        {
            /* do nothing */
        }
d1428 1
a1428 1
    char str[sizeof "Alias$@@USBDevice_LL_SS_TT_VVVV_PPPP_CC_II_RRRR_USBnnn"];
a1517 1
        len = r.r[2];
d1519 2
a1520 1
        if (len) goto match;
d1530 2
d1535 1
a1535 1
        malloc (sizeof *sc + ~len + 12 /*unit*/ + 12/*ifc*/);
d1537 2
a1538 2
    sprintf (sc->com, "%.*s %d %d",
        ~len,
d1540 1
a1540 2
        unit,
        aux->ifaceno);
d1548 18
d1632 1
d2681 1
a2681 1
        dprintf (("", "%d, %d\n", dev->powersrc->portno, dev->depth));
d2773 1
a2773 1
        dprintf (("", "wakeup write, resetting count to %d\n",
d2781 1
a2781 1
        dprintf (("", "wakeup read, resetting count to %d, totalcount to %d\n",
d2802 1
a2802 1
        dprintf (("", "resume ep = %x\n", str->ep));
@


1.21
log
@        Update of EHCIDriver to current NetBSD, together with needed changes
        in both OHCIDriver and USBDriver.


Detail:
        Code may change before formal release .. will be beta released
        ... Entered to CVS to get new version numbers, and for
        the record.
Admin:
        Castle/netbsd added IP .. will be tested more fully before
        formal release. Still to be verified on Rhenium.


Version 0.31. Tagged as 'NetBSD-0_31'
@
text
@d319 1
d2033 1
d2039 1
a2039 1
            if (ifc->sc_iface->index == iface)
d2281 36
a2316 1
    if(!xfer->pipe->repeat)
d2318 2
a2319 18
      if(xfer->actlen < xfer->length)
      {
          char zero[ UGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize)];
          memset (zero, 0, sizeof zero);
          /* fill up the rest of the request with garbage! */
          _kernel_swi_regs r;
          r.r[0] = BM_InsertBlock;
          r.r[1] = (int) str->buffer_id;
          r.r[2] = (int) zero;
          r.r[3] = str->totalcount - str->count;
          dprintf (("", "Fill insert %x bytes\n",r.r[3]));
          CallBufMan (&r);
      }
      else if (str->count != str->totalcount) 
      {
          dprintf (("", "Starting read from callback\n"));
          start_read (str);
      }
d2489 1
a2489 1
            dprintf (("", "status: %s\n", ccodes[status]));
d2491 2
a2492 2
            dprintf (("", "status: %s\n", ccodes[status]));
            usbd_free_buffer (str->xfer);
d2494 1
a2494 1
            dprintf (("", "status: %s\n", ccodes[status]));
@


1.20
log
@  Extensive changes and bug fixes to usb and ohci ..
  'blocked' several holes that could cause freezes with awkward
  usb devices.  Added latest changes from Dan Ellis too , especially for USB2
Detail:
 many
Admin:
 Tested in ROM at Castle, and beta tested with users


Version 0.28. Tagged as 'NetBSD-0_28'
@
text
@d38 1
d179 1
a179 1
    _kernel_oserror* e;
a265 2
#define MAX_EXTRA_QUIRKS 30
void * extra_quirks = NULL;
d316 2
a317 1
    debug_initialise ("USBDriver", "", 0);
a367 1
    clock_t t;
d562 1
a562 1
_kernel_oserror* command_enumerate_buses ()
d588 1
a588 1
_kernel_oserror* command_discover ()
d843 7
a849 17
/* format of a quirk .. keep synchronised with entry in dev.usb.usb_quirks */
typedef struct usbd_quirk_entry {
	u_int16_t idVendor;
	u_int16_t idProduct;
	u_int16_t bcdDevice;
	u_int32_t quirks;
} usbd_quirk_entry;

extern const struct usbd_quirks * usbd_find_builtin_quirk(usb_device_descriptor_t *d, void *t);


const struct usbd_quirks * usbd_find_quirk(usb_device_descriptor_t *d)
{
  const struct usbd_quirks * q;
  if(extra_quirks) if(q=usbd_find_builtin_quirk(d,extra_quirks),q) return q;
  return usbd_find_builtin_quirk(d,NULL);  // try as a builtin one
}
d862 1
a862 1
        printf("%04x   %04x    %04x   %08x\n",t->idVendor,t->idProduct,t->bcdDevice,t->quirks);
d884 1
a884 1
        t->quirks    = NULL;
d902 1
a902 1
      t->quirks = quirk;
d913 1
a913 1
      t->quirks    = quirk;
@


1.19
log
@More John fixes.

Version 0.27. Tagged as 'NetBSD-0_27'
@
text
@d119 6
d128 1
d180 3
a182 3
    e = uerror (E_BadDevice);
    _swix (OS_UpCall, _INR(0,6), UpCall_MediaNotPresent, fsnumber_DeviceFS,
        -1, -1, 0, 0x7f/*ffffff*/, e->errmess);
d265 2
d343 1
d400 2
a401 1

d410 35
a444 1
extern int Image__RO_Base;
d461 29
d620 1
a620 1
    usbd_device_handle parent = port->parent;
d622 1
a622 1
    if (parent == NULL)
d844 89
d984 16
a1284 5
struct dev_struct {
    devicefs_device dev;
    int null;
    char name[32];
};
d1608 1
a1608 28
    struct dev_struct * dev = calloc (sizeof *dev, 1);
    sprintf (dev->name, "USB%d", no);
    strncpy (softc->sc_dev.dv_xname, dev->name,
        sizeof softc->sc_dev.dv_xname - 1)
            [sizeof softc->sc_dev.dv_xname - 1] = '\0';

    dev->dev.name_offset = dev->name - (char*) dev;
    dev->dev.flags = 3;
    dev->dev.tx_flags = 0x8;
    dev->dev.tx_buffer_size = 8192;
    dev->dev.rx_flags = 0x8;
    dev->dev.rx_buffer_size = 1024;

    e = _swix (DeviceFS_Register, _INR (0, 7) | _OUT(0),
        6,
        dev,
        driver_entry,
        softc,
        private_word,
        "endpoint/Ninterface/Nalternate/Nreport/Ncontrol,isochronous,bulk,interrupt/Susbtimeout/Nsize/N",
#ifdef DEVICEFSISBROKEN
        INT_MAX, // should be -1, but that doesn't seem to work
        INT_MAX,
#else
        -1,
        -1,
#endif
        &softc->sc_devfs);
a1612 2
#if 0
        free (dev);
a1614 3
#else
        softc->sc_devfs = 0;
#endif
d1645 1
d1648 1
d1666 1
d1684 1
d1712 1
d1783 1
a1783 1
void usbd_devinfo_vp(usbd_device_handle dev, char* v, char* p, int usedev)
d1837 1
a1837 1
        sprintf(v, "Vendor ID %04X", UGETW(udd->idVendor));
d1839 1
a1839 1
        sprintf(p, "Product ID %04X", UGETW(udd->idProduct));
d2015 1
a2015 1
    dprintf (("", "found interface %x, endpoint %x\n", iface, ep));
d2272 1
a2272 1
    if (  (status != USBD_NORMAL_COMPLETION))
d2290 1
a2290 15
//    if (!(xfer->actlen/UGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize))  &&
//      str->count != str->totalcount)
    if(xfer->actlen < xfer->length)
    {
        char zero[ UGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize)];
        memset (zero, 0, sizeof zero);
        // fill up the rest of the request with garbage!
        _kernel_swi_regs r;
        r.r[0] = BM_InsertBlock;
        r.r[1] = (int) str->buffer_id;
        r.r[2] = (int) zero;
        r.r[3] = str->totalcount - str->count;
        CallBufMan (&r);
    }
    else if (str->count != str->totalcount && !xfer->pipe->repeat)
d2292 18
a2309 2
        dprintf (("", "Starting read from callback\n"));
        start_read (str);
d2853 1
a2853 1
return NULL;        }
@


1.18
log
@Latest stuff from John - mainly Rhenium improvements.

Version 0.26. Tagged as 'NetBSD-0_26'
@
text
@d170 1
a170 1
#ifndef RHENIUM 
d1089 1
a1089 1
      
d1194 1
a1194 1
    {                      
d1466 1
d1470 3
d1502 2
a1503 1
    _swix (DeviceFS_Deregister, _IN(0), udev->sc_devfs);
d2125 1
a2125 2
    if (  (status != USBD_NORMAL_COMPLETION)
        &&(status != USBD_SHORT_XFER_DONE))
d2142 1
a2142 1
       transfer must have ended.. else.. try more */   
d2145 1
a2145 1
    if(status == USBD_SHORT_XFER_DONE)
d2149 1
a2149 1
        // fill up the rest of the request with garbage! 
@


1.17
log
@  New versions from John.
Detail:
  * All modules will now rmkill/rmload more reliably
  * Keyboard driver disables kernel debounce on new enough kernels, needed
    for many PS2-USB adaptors, bar code scanners etc
  * Mouse driver will scroll wheel scroll any windows that do respond to
    scroll events, otherwise it issues PointerReason_WheelChange (9) to an
    external WimpScroll module
  * Several bugs and an interrupt hole resolved
Admin:
  Tested at Framlingham.

Version 0.25. Tagged as 'NetBSD-0_25'
@
text
@d52 1
d169 2
d175 3
a177 1
        -1, -1, 0, 0x7fffffff, e->errmess);
d399 1
d1089 1
d1194 1
a1194 1
    {
d2120 2
a2121 1
    if (status != USBD_NORMAL_COMPLETION)
d2137 17
a2153 1
    if (str->count != str->totalcount && !xfer->pipe->repeat)
d2322 1
a2322 1
            if (str->dying) return;
d2700 1
a2700 1
        }
@


1.16
log
@Fixes from John Ballance:

Version 0.23. Tagged as 'NetBSD-0_23'
@
text
@d26 2
d113 2
a114 1
    int resiude;
d147 1
d166 9
d216 1
a216 1
extern int usbdebug, uhubdebug;
a243 1
//int mouseactive = 0;
d324 1
a334 3
//    /* turn on the hourglass until the mouse is active */
//    _swix (Hourglass_On, 0);

d353 9
d366 1
d370 2
a371 7
    /* tell the devices to remove themselves */
    struct device* dev;
    char var[sizeof "DeviceFS$USBnnn$Options"];
    TAILQ_FOREACH(dev, &allusbdevs, dv_list)
    {
        config_detach (dev, 0 /* number doesn't matter */);
    }
d473 5
d694 7
a700 7
            ddumpbuf("", d, d->bLength, 0);
            ddumpbuf("", d, sizeof *d, 0);
            printf ("HID%X descriptors,  Country %X\n",
                UGETW(d->bcdHID), d->bCountryCode);
#ifdef __riscos
            /* RISC OS can't handle packed structures, so we only cope
               with one report */
d705 1
d775 1
a951 5
//          if (!mouseactive)
//          {
//             mouseactive = 1;
//             _swix (Hourglass_Off, 0);
//          }
d962 1
d1354 1
a1354 1
        _kernel_oserror* e = _kernel_swi (OS_ReadVarVal, &r, &r);
d1523 4
a1526 1
//    _swix (Hourglass_On, 0);
a1527 1
//        _swix (Hourglass_LEDs, _INR(0,1), 1, 0);
d1529 3
a1531 1
//        _swix (Hourglass_LEDs, _INR(0,1), 2, 0);
d1538 3
a1540 1
//    _swix (Hourglass_Off, 0);
d1728 1
a1728 3
    uint32_t            endpoint,
    uint32_t            iface,
    uint32_t            type,
d1731 1
d1735 1
a1735 1
    int                             i;
d1739 1
a1739 1
    if (type == 0xdeaddead)
d1741 1
a1741 1
        type = UE_BULK;
d1744 3
a1746 2
    dprintf (("", "looking for %x, iface %x, type %x, dir %x\n",
        endpoint, iface, type, dir));
d1758 1
d1767 1
a1767 1
            if (UE_GET_ADDR(b->bEndpointAddress) == endpoint &&
d1778 3
a1780 3
                (iface == i || iface == 0xdeaddead) &&
                (endpoint == 0xdeaddead) &&
                (type == UE_GET_XFERTYPE (b->bmAttributes)) &&
d1782 2
a1783 1
                (((dir & 1) << 7) != UE_GET_DIR(b->bEndpointAddress))
d1787 1
d1797 1
d1816 1
a1844 4
    /* force an interface alternate */
    if (valid->alternate != 0xdeaddead)
        usbd_set_interface(str->iface, valid->alternate);

d1850 1
a1850 3
        valid->endpoint,
        valid->interface,
        valid->ep_type,
d1853 1
d1871 4
d1927 1
a2139 1
    int size;
d2276 2
a2277 6
    static int reentry = 0;
    dprintf (("", "terminate stream %p, ep %x, kill = %d, reentry = %d\n",
        str, str->ep, kill, reentry));
    if (reentry)
      return;
    reentry = 1;
a2280 1
        reentry = 0;
a2288 1
      reentry = 0;
d2298 2
a2320 1
            reentry = 0;
a2337 1
                    reentry = 0;
a2355 1
    reentry = 0;
@


1.15
log
@Merge of Dan Ellis's USB2 sources.

Version 0.22. Tagged as 'NetBSD-0_22'
@
text
@d143 1
d203 1
a203 1
extern int usbdebug, uhubdebug, umsdebug;
d231 1
a231 1
int mouseactive = 0;
d292 1
a292 1
    debug_set_device(TML_OUTPUT);
d322 2
a323 2
    /* turn on the hourglass until the mouse is active */
    _swix (Hourglass_On, 0);
d522 5
d528 4
a531 2
    usbd_set_port_feature(parent, port->portno, UHF_PORT_RESET);
    command_discover ();
d930 5
a934 5
          if (!mouseactive)
          {
             mouseactive = 1;
             _swix (Hourglass_Off, 0);
          }
d1505 1
a1505 1
    _swix (Hourglass_On, 0);
d1507 1
a1507 1
        _swix (Hourglass_LEDs, _INR(0,1), 1, 0);
d1509 1
a1509 1
        _swix (Hourglass_LEDs, _INR(0,1), 2, 0);
d1516 1
a1516 1
    _swix (Hourglass_Off, 0);
d1589 2
a1590 2
    dprintf (("", "inserting %d bytes, total %d\n",
        actlen, str->count));
d1632 1
a1632 1
            str, vendor, e? e->errmess: "NULL"));
d1649 1
a1649 1
            str, vendor, e? e->errmess: "NULL"));
d1816 4
a1846 3
    /* force an interface alternate */
    if (valid->alternate != 0xdeaddead)
        usbd_set_interface(str->iface, valid->alternate);
d1921 1
a1921 1
        if (valid->ep_type == UE_ISOCHRONOUS)
d1940 1
a1940 1
    if (valid->ep_type == UE_INTERRUPT)
d2248 7
a2254 2
    //dprintf (("", "terminate stream %p, ep %x, kill = %d\n",
    //    str, str->ep, kill));
d2256 2
d2259 1
d2263 7
d2275 1
d2277 4
a2280 2
            usbd_abort_pipe(str->pipe);
            usbd_close_pipe(str->pipe);
d2282 2
a2283 1
            usbd_free_xfer(str->xfer);
d2297 1
d2315 1
d2334 1
@


1.14
log
@Update from John:
> Reduce root port reset delay to 50ms from 250ms to work with Chicony
> keyboards (again).  Comment out duplicate free(udev) at end of
> usbmodule:config_detach.

Version 0.20. Tagged as 'NetBSD-0_20'
@
text
@d80 9
d110 3
d199 1
d230 1
a310 1
    umsdebug = atoi(getenv("umsdebug"));
d321 3
d349 1
a349 6

    callx_remove_all_callbacks ();
    callx_remove_all_callafters ();
    callx_remove_all_calleverys ();

    /* get rid of anything in devicefs */
d354 1
a354 12
        if (2 == (int) dev->dv_cfdata)
        {
            struct ugen_softc * udev = (struct ugen_softc*) dev;
            _swix (DeviceFS_Deregister, _IN(0), udev->sc_devfs);
        }

        /* since we don't reuse numbers nuke the devicefs options variable too */
        sprintf (var, "DeviceFS$USB%d$Options", dev->dv_unit);
        while (_swix (OS_SetVarVal, _INR(0,4), var, 0, -1, 0, 0) == NULL)
        {
            /* do nothing */
        }
d363 4
d444 1
a444 1
            usbd_fill_deviceinfo (udev, &di);
d448 7
a454 7
                di.bus,
                di.addr,
                di.class,
                di.subclass,
                di.vendor,
                *di.vendor ? " " : "",
                di.product);
d478 4
a481 4
            stats.requests[UE_CONTROL],
            stats.requests[UE_ISOCHRONOUS],
            stats.requests[UE_BULK],
            stats.requests[UE_INTERRUPT]);
a746 1
        if (ptr) umsdebug = (int) strtoul (ptr, &ptr, 0);
d850 11
d920 9
a928 1
        if ((ret = (*f) (parent, aux)) != NULL) return ret;
d941 1
d945 4
a948 2
            if (_kernel_oscli (sc->com))
                dprintf (("", "error: %s\n", _kernel_last_oserror ()->errmess));
d960 2
a961 2
/* dummy - we don't do attachment like this */
void* config_found (struct device* dev, void* h, int (*f) (void*, const char*))
d973 2
a995 1
    }
d997 14
a1010 13
    /* remove any system variables attached to this device and since we don't reuse numbers
       nuke the devicefs options variable too */
    char var[sizeof "DeviceFS$USBnnn$Options"];
    /*          and "USB$Device_*USBnnn" */
    sprintf (var, "USB$Device_*USB%d", dev->dv_unit);
    while (_swix (OS_SetVarVal, _INR(0,4), var, 0, -1, 0, 0) == NULL)
    {
        /* do nothing */
    }
    sprintf (var, "DeviceFS$USB%d$Options", dev->dv_unit);
    while (_swix (OS_SetVarVal, _INR(0,4), var, 0, -1, 0, 0) == NULL)
    {
        /* do nothing */
d1208 1
a1208 1
    serv->speed = dev->lowspeed? 0: 1;
d1341 2
d1344 1
a1344 1
        malloc (sizeof *sc + ~len + 12 /*unit*/ + 12 /*ifc*/);
d1346 1
a1346 1
    sprintf (sc->com, "%.*s %lu %lu",
d1440 1
d1497 1
d1499 1
d1501 1
d1508 1
d1592 1
a1592 1
void usbd_devinfo_vp(usbd_device_handle dev, char* v, char* p)
d1606 5
a1610 2
    vendor = usbd_get_string(dev, udd->iManufacturer, v);
    product = usbd_get_string(dev, udd->iProduct, p);
d1651 28
d1836 2
a1837 1
    if (valid->alternate != 0xdeaddead) usbd_set_interface(str->iface, valid->alternate);
d1900 1
d1904 1
d1910 15
a1924 1
    if (str->xfer == NULL) str->xfer = usbd_alloc_xfer (ugen->sc_udev);
d1945 8
d2048 5
a2052 1
	if (str->xfer->status != USBD_IN_PROGRESS)
d2088 4
a2091 4
    /* only start another transfer if we haven't finished the transfer or
       this is an interrupt endpoint (i.e. repeat is set) */
    if ((xfer->actlen == xfer->length && str->count != str->totalcount) ||
        xfer->pipe->repeat == 1)
d2093 1
d2100 17
d2133 6
a2143 1
    reentry = 1;
d2147 1
d2169 1
d2197 20
a2216 9
        usbd_setup_xfer(
            str->xfer,
            str->pipe,
            str,
            (void*) str->buffer_id,
            actlen,
            USBD_SHORT_XFER_OK,
            str->timeout,
            read_cb);
a2218 1
	dprintf (("", "starting transfer of %d bytes\n", actlen));
d2221 4
a2224 1
	if (str->xfer->status != USBD_IN_PROGRESS)
d2231 1
a2232 1
    reentry = 0;
d2330 11
a2340 2
    p = usbd_alloc_buffer (str->xfer, *size);
    if (p == 0) return uerror (E_NoMem);
d2342 6
a2347 6
    e = _swix (Buffer_Register, _INR(0,3)|_OUT(0),
        *flags,
        p,
        p + *size,
        -1,
        handle);
d2349 1
d2469 1
a2469 1
            
d2474 1
a2474 1
    
d2530 1
a2530 1
        dprintf (("", "wakeup read, resetting count to %d, totalcoun to %d\n",
d2532 2
a2533 1
        start_read (str);
d2553 5
a2557 1
        if (UE_GET_DIR(str->ep) == UE_DIR_IN) start_read (str);
d2575 21
@


1.14.2.1
log
@Added support for HAL USB devices.
Attempted interrupt hole fix.

Version 0.21, 1.22.2.1. Tagged as 'NetBSD-0_21-1_22_2_1'
@
text
@d2327 1
a2327 1

d2332 1
a2332 1

d2460 1
a2460 1
            struct req { int a, b; } rq = { r->r[3], r->r[4] };
@


1.13
log
@USB transfer failed reason strings in the messages files were incorrectly
being tokenised. Also added a couple of bits of debug.

Version 0.18. Tagged as 'NetBSD-0_18'
@
text
@d994 1
a994 1
    free (dev);
@


1.12
log
@Added new CallDevice reason code (&80000005) to clear a stall condition on
a pipe with a given FileSwitch handle
New usbdevs and usbdevs_data from NetBSD
Rewrote power source detection to skirt round dodgy devices which say
they're self powered,set MaxPower=0,and don't respond to a getstatus()
Copes better with devices being unplugged while a transfer using them is active

Version 0.17. Tagged as 'NetBSD-0_17'
@
text
@d2313 1
d2315 12
d2462 1
d2464 12
@


1.11
log
@  Support for SCSISoftUSB, and some tidying up.
Detail:
  * Errors now use the allocated error number base, &819000, instead of a
    base in the private range, &50000000. "USB transfer failed" errors now
    have use a sub-range of error numbers from &819020; the original BSD
    error number can be retrieved from the bottom 5 bits of the RISC OS
    error number.
  * Service_USB 1 now returns the list in the order in which the devices,
    rather than in the reverse order as previous versions of the module did.
  * A little tweaking of h/usb_port to reduce compiler warnings.
  * Some compiler-satisfying changes to allow use of packed structures.
    (However, the compiler doesn't seem to work correctly yet, so this is
    currently switched out using -DDISABLE_PACKED on the command line.)
  * Added full stops to end of star command help strings for consistency
    with rest of OS.
  * New exports: USBDevFS (moved here from ^.h) and a few files in dev/usb/h
    and sys/h.
Admin:
  Error number overhaul and new exports are both required by SCSISoftUSB.

Version 0.16. Tagged as 'NetBSD-0_16'
@
text
@d64 1
d935 1
a935 1
/* dummy - we don't do attachement like this */
d2297 26
d2461 3
@


1.10
log
@Removed a debugging delay from dev.c.ohci which was breaking everything.
Null vendor names no longer say oflaofla.

Version 0.14. Tagged as 'NetBSD-0_14'
@
text
@d121 10
a130 10
#define E_NoMem         "\x00\x00\x00\x50" "NoMem"
#define E_NoDevice      "\x01\x00\x00\x50" "NoDevice"
#define E_NoInterface   "\x02\x00\x00\x50" "NoInterface"
#define E_NoEndpoint    "\x03\x00\x00\x50" "NoEndpoint"
#define E_EndpointUsed  "\x04\x00\x00\x50" "EndpointUsed"
#define E_BadPipe       "\x05\x00\x00\x50" "BadPipe"
#define E_BadXfer       "\x06\x00\x00\x50" "BadXfer"
#define E_NoStream      "\x07\x00\x00\x50" "NoStream"
#define E_BadRequest    "\x08\x00\x00\x50" "BadRequest"
#define E_XferFailed    "\x09\x00\x00\x50" "XferFailed"
d394 1
a394 2
            // in case there are no devices
            USBServiceAnswer* serv = (USBServiceAnswer*) r->r[2];
d397 4
d406 9
a414 1
                serv->link = lastserv;
a416 1
            r->r[2] = (int) serv;
d1182 2
a1183 2
    memcpy (&serv->ddesc, &dev->ddesc, sizeof serv->ddesc);
    memcpy ((char*)(serv + 1) - 2, dev->cdesc, UGETW(dev->cdesc->wTotalLength));
d2409 2
a2410 1
            char cc[5], *cp;
d2415 1
a2415 1
                E_XferFailed, &mod_messages, &err, sizeof err, cp);
@


1.9
log
@Nicked a few hub related fixes from later NetBSD versions.
Added stuff to delete the DeviceFS$USB*$Options variables when the module is
RMkilled.

Version 0.12. Tagged as 'NetBSD-0_12'
@
text
@d276 1
a276 1
    debug_set_device(DEBUGIT_OUTPUT);
d376 1
d431 1
a431 1
            printf ("%3d %3d %3d %2X/%2X %s %s\n",
d438 1
d1329 1
a1333 1
    dprintf (("", "Sent USBDriver_Attach service call\n"));
@


1.8
log
@Fix for erratic behaviour after having unplugged hubs: TAILQ was
being given an entry which wasn't on its list, and the behaviour was to
break the list and poke a zero into the reset vector!
Also, some extra IFDEF's so that debug builds will work again.
A few typos/spelling errors changed.

Version 0.11. Tagged as 'NetBSD-0_11'
@
text
@d339 1
d346 7
@


1.7
log
@Before I forget,unset the DeviceFS$USBnnn$Options variable due to not
reusing numbers and DeviceFS not deleting them - is there such thing as
variable leaks?

Version 0.10. Tagged as 'NetBSD-0_10'
@
text
@d190 2
d474 1
d476 1
d790 1
d792 1
d933 1
a933 1
    /* only remove if a generic device of hub, others match as generic as well
d939 9
a947 1
        TAILQ_REMOVE (&allusbdevs, dev, dv_list);
d973 1
d987 2
d991 4
a994 1
        return NULL;
d1323 1
d1449 1
d1451 3
d1751 1
a1751 1
    
@


1.6
log
@Added the ability to specify an alternate interface in the deviceFS
special string.

Version 0.09. Tagged as 'NetBSD-0_09'
@
text
@d936 4
a939 2
    /* remove any system variables attached to this device */
    char var[sizeof "USB$Device_*USBnnn"];
d941 5
@


1.5
log
@Found a "busses" lingering in the messages file,also removed a \n which
must have been copied from a printf somewhere.
Old service call detail removed from c.port as it's defined in another
file differently!
USBDiscover is now only available for debugging purposes.
Internationalised the mouse name (default is still "USB mouse").

Version 0.08. Tagged as 'NetBSD-0_08'
@
text
@d1342 3
a1344 2
        "endpoint/Ninterface/Nreport/Ncontrol,isochronous,bulk,interrupt/Susbtimeout/Nsize/N",
        INT_MAX, // XXX should be -1, but that doesn't seem to work
d1346 4
d1568 1
d1717 3
@


1.4
log
@Another fix to the previous buffer overrun fix,such that this time the
command aliases actually get executed now.
Timing code changed to work round HAL call not returning the right value
so temporarily wired to 2000000.
Change to Makefile so ROM builds don't have annoying throwback windows
popping up,this is now in the !Mk file.Also "-ff" function names away.

Version 0.05. Tagged as 'NetBSD-0_05'
@
text
@d750 1
d753 1
@


1.3
log
@Fix for nasty bug where system variable assignment would trample over
random bits of the RMA

Version 0.04. Tagged as 'NetBSD-0_04'
@
text
@d419 1
d1254 1
a1254 2
        if (!e && len) goto match;
        else dprintf (("", "%s\n", e->errmess));
d1265 1
a1265 1
        malloc (sizeof *sc + -len + 12 /*unit*/ + 12 /*ifc*/);
d1268 1
a1268 1
        -len,
@


1.2
log
@Minor bug fix,the system variable was getting run before the device
was fully established in DeviceFS - which could cause printing problems.

Version 0.03. Tagged as 'NetBSD-0_03'
@
text
@a1144 1
    _kernel_swi_regs r;
d1158 2
d1249 6
a1254 3
        r = (_kernel_swi_regs) {{ (int) str, 0, -1, 0, 0 }};
        _kernel_swi (OS_ReadVarVal, &r, &r);
        if (r.r[2]) goto match;
d1265 1
a1265 1
        malloc (sizeof *sc + -r.r[2] + 4 /*unit*/ + 4 /*ifc*/);
d1267 3
a1269 3
    sprintf (sc->com, "%.*s %d %d %d",
        -r.r[2],
        ((char*) r.r[3]) + sizeof "Alias$" - 1,
d1271 1
a1271 2
        aux->ifaceno,
        ifc->altindex);
@


1.1
log
@Import of USB driver suitable for generic PCI based OHCI controllers.
Correction of spelling of busses to buses (noun plural).
OHCIdriver only responds to PCI service call to lookup vendor name when
the device is of class OHCI controller.

Version 0.01. Tagged as 'NetBSD-0_01'
@
text
@d215 5
d224 1
a224 1
struct devicelist allbusses = TAILQ_HEAD_INITIALIZER(allbusses);
d434 1
a434 1
_kernel_oserror* command_enumerate_busses ()
d724 1
a724 1
        return command_enumerate_busses ();
d767 1
a767 1
    TAILQ_INSERT_TAIL (&allbusses, softc, dv_list);
d793 1
a793 1
    TAILQ_REMOVE (&allbusses, (device_ptr_t) bus, dv_list);
d829 1
a829 1
    TAILQ_FOREACH(dev, &allbusses, dv_list)
d886 12
d1260 2
a1261 5
    char com[
        -r.r[2] +
        4 + /* unit number < 999 + space */
        4   /* iface number < 256 + NULL */
        ];
d1263 1
a1263 1
    sprintf (com, "%.*s %d %d %d",
d1270 2
a1271 2
    dprintf (("", "executing: %s\n", com));
    _kernel_oscli (com);
d1395 1
a1395 1
    TAILQ_FOREACH(dev, &allbusses, dv_list)
d1546 1
a1546 1
       sprintf(v, "Vendor ID %04X", UGETW(udd->idVendor));
d1548 1
a1548 2
       sprintf(p, "Product ID %04X", UGETW(udd->idProduct));

d1602 1
@


head	1.29;
access;
symbols
	USBDriver-1_22:1.28
	USBDriver-1_21:1.28
	USBDriver-1_20:1.28
	USBDriver-1_19:1.28
	NetBSD-1_19:1.28
	NetBSD-1_18:1.28
	NetBSD-1_17:1.27
	NetBSD-1_16:1.26
	NetBSD-1_15:1.26
	NetBSD-1_14:1.26
	NetBSD-1_13:1.26
	NetBSD-1_12:1.26
	NetBSD-1_09-1:1.26
	NetBSD-1_11:1.26
	NetBSD-1_10:1.26
	NetBSD-1_09:1.26
	NetBSD-1_08:1.25
	NetBSD-1_07:1.25
	NetBSD-1_06:1.25
	NetBSD-1_05:1.25
	NetBSD-1_04:1.24
	NetBSD-1_03:1.24
	NetBSD-1_02:1.24
	NetBSD-1_01:1.24
	NetBSD-1_00:1.24
	NetBSD-0_99:1.24
	NetBSD-0_98:1.24
	NetBSD-0_97:1.23
	NetBSD-0_96:1.23
	NetBSD-0_95:1.23
	NetBSD-0_94:1.23
	NetBSD-0_93:1.23
	NetBSD-0_92:1.22
	NetBSD-0_91:1.21
	NetBSD-0_90:1.21
	NetBSD-0_89:1.21
	NetBSD-0_88:1.21
	NetBSD-0_87:1.20
	NetBSD-0_86:1.20
	NetBSD-0_85:1.20
	NetBSD-0_84:1.19
	NetBSD-0_83:1.19
	NetBSD-0_82:1.19
	NetBSD-0_81:1.19
	NetBSD-0_80:1.19
	NetBSD-0_79:1.19
	NetBSD-0_78:1.19
	NetBSD-0_77:1.19
	NetBSD-0_76:1.18
	NetBSD-0_75:1.18
	NetBSD-0_74:1.18
	NetBSD-0_73:1.18
	NetBSD-0_72:1.18
	NetBSD-0_71:1.17
	NetBSD-0_70:1.16
	NetBSD-0_69:1.16
	NetBSD-0_68:1.16
	NetBSD-0_67:1.16
	NetBSD-0_66:1.16
	NetBSD-0_65:1.16
	NetBSD-0_64:1.16
	NetBSD-0_63:1.16
	NetBSD-0_62:1.16
	NetBSD-0_61:1.16
	NetBSD-0_60:1.16
	NetBSD-0_59:1.16
	NetBSD-0_58:1.15
	NetBSD-0_57:1.15
	NetBSD-0_56:1.15
	NetBSD-0_55:1.15
	NetBSD-0_54:1.15
	NetBSD-0_53:1.15
	NetBSD-0_52:1.15
	NetBSD-0_51:1.14
	NetBSD-0_50:1.14
	NetBSD-0_49:1.14
	NetBSD-0_48:1.13
	NetBSD-0_47:1.12
	NetBSD-0_46:1.11
	NetBSD-0_45:1.11
	NetBSD-0_44:1.11
	NetBSD-0_43:1.11
	NetBSD-0_42:1.11
	NetBSD-0_41:1.11
	NetBSD-0_40:1.11
	NetBSD-0_39:1.11
	NetBSD-0_38:1.10
	NetBSD-0_37:1.10
	NetBSD-0_36:1.10
	NetBSD-0_35:1.9
	NetBSD-0_34:1.8
	NetBSD-0_33:1.7
	NetBSD-0_32:1.6
	NetBSD-0_31:1.5
	NetBSD-0_30:1.4
	NetBSD-0_29:1.3
	RO_5_07:1.3
	NetBSD-0_28:1.3
	NetBSD-0_27:1.2
	NetBSD-0_26:1.2
	NetBSD-0_25:1.2
	NetBSD-0_24:1.1
	NetBSD-0_23:1.1
	NetBSD-0_22:1.1;
locks; strict;
comment	@# @;


1.29
date	2017.10.07.09.08.41;	author rool;	state dead;
branches;
next	1.28;
commitid	Qzw5gnXY6CB2g6aA;

1.28
date	2016.12.17.10.12.57;	author rool;	state Exp;
branches;
next	1.27;
commitid	yws6HYEy6os04kyz;

1.27
date	2016.12.10.12.54.24;	author rool;	state Exp;
branches;
next	1.26;
commitid	zPShgPr6RkVlbrxz;

1.26
date	2015.11.17.08.54.38;	author rsprowson;	state Exp;
branches;
next	1.25;
commitid	aGTTwPGVohbkmqJy;

1.25
date	2015.11.04.22.20.03;	author rool;	state Exp;
branches;
next	1.24;
commitid	HzbqOzFGVg8xePHy;

1.24
date	2015.08.21.19.59.47;	author rsprowson;	state Exp;
branches;
next	1.23;
commitid	lkGgBHyZsFbSRayy;

1.23
date	2015.01.06.00.04.46;	author jlee;	state Exp;
branches;
next	1.22;
commitid	tl9yMvzfmT5kyT4y;

1.22
date	2015.01.02.16.25.51;	author jballance;	state Exp;
branches;
next	1.21;
commitid	d826RZCxCbRS6t4y;

1.21
date	2014.08.29.19.26.16;	author jlee;	state Exp;
branches;
next	1.20;
commitid	f6ArfsGGibMS9iOx;

1.20
date	2014.06.01.13.51.40;	author jlee;	state Exp;
branches;
next	1.19;
commitid	Vazl1SQGmZpsaPCx;

1.19
date	2013.03.30.23.46.26;	author jlee;	state Exp;
branches;
next	1.18;
commitid	QOU0ipH7csEsdSJw;

1.18
date	2012.06.24.21.55.29;	author jlee;	state Exp;
branches;
next	1.17;
commitid	4v309enDleTpz0aw;

1.17
date	2012.06.07.00.11.04;	author jlee;	state Exp;
branches;
next	1.16;
commitid	LkYeKFZjKWlNTH7w;

1.16
date	2011.05.22.20.22.34;	author jlee;	state Exp;
branches;
next	1.15;
commitid	Ye1jVWDlKivFSIkv;

1.15
date	2010.07.21.23.57.10;	author jlee;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.02.20.59.01;	author jlee;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.06.20.44.06;	author jlee;	state Exp;
branches;
next	1.12;

1.12
date	2009.05.09.19.32.46;	author jlee;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.24.23.13.53;	author jballance;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.23.00.01.58;	author jballance;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.18.00.35.56;	author jballance;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.31.13.45.35;	author jballance;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.21.22.30.19;	author jballance;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.03.01.50.01;	author jballance;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.30.02.34.17;	author jballance;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.25.00.54.52;	author jballance;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.12.14.47.39;	author jballance;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.06.15.50.22;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.21.20.49.15;	author bavison;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Clear up duplicate/unused OHCI/EHCI source files
Detail:
  Remove the (now) unused sources from when this component produced multiple targets. See Controllers/OHCIDriver & Controllers/EHCIDriver for the live copies.
  Remove unset USBHAL defines.
  Simplify the Makefile and !Mk* scripts.
  No longer export usbroothub_subr.h.
  Add a porting type "device_t" to usb_port.h.
Admin:
  Submission for USB bounty.

Version 1.23. Tagged as 'USBDriver-1_23'
@
text
@/* Copyright 2004 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <machine/bus.h>
#include "swis.h"

#include <sys/queue.h>
#include <sys/types.h>
#include <sys/systm.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/ehcireg.h>
#include <dev/usb/ehcivar.h>

#include "Global/RISCOS.h"
#include "Global/Services.h"
#include "Global/HALEntries.h"
#include "Interface/PCI.h"
#include "Interface/USBDriver.h"
#include "callx/callx.h"
#include "toolbox.h"

/* Have to avoid including stdio as there's a clash with the BSD stuff */
#define __stdio_h

#include "ehcimodhead.h"
#include "DebugLib/DebugLib.h"
#include "USBDevFS.h"

#define ErrorBase_EHCIDriver 0x820A40
#define ErrorBlock_EHCI_NoReinit    { (ErrorBase_EHCIDriver+0), "NumParm" }
#define ErrorBlock_EHCI_NoEHCI      { (ErrorBase_EHCIDriver+1), "E01"     }
#define ErrorBlock_EHCI_ClaimVeneer { (ErrorBase_EHCIDriver+2), "E02"     }
#define ErrorBlock_EHCI_USBTooOld   { (ErrorBase_EHCIDriver+3), "E03"     }
typedef struct
{
    int  errnum;
    char errtok[8];
} _kernel_tokerror;

/* for debugging */
#ifdef EHCI_DEBUG
extern int ehcidebug;
int usbdebug;

uint32_t irq0;
int irq_device;
char debugname[16];
#endif

extern int * init_veneer (void);
extern void* resource_files (void);
#ifdef EHCI_DEBUG
extern uint64_t gettime (void);
extern void ehci_dump_regs (ehci_softc_t *);
//extern void ehci_dump_ed (ehci_soft_ed_t*);
#endif
extern void ehci_abort_xfer (void*, int);

void* private_word;
MessagesFD mod_messages;
volatile int* ehci_base;
ehci_softc_t ehci_soft;
struct device * usb_soft = NULL;

int* magic = NULL;
int pci_device = -1;
int hal_device = -1;
int instance = 0;
int device_number;
int unhandled_irqs;
int registers_32bit=0;
static bool registering=false; /* True/false for whether we're in the middle of registering. Avoids nested registration attempt during ROM init. */
static bool hal_portpower = false; /* Whether to use HAL_PortPower to control the port */

/*---------------------------------------------------------------------------*/
/* Driver instance creation                                                  */
/*---------------------------------------------------------------------------*/
void build_veneer (int* vn, int* st, size_t sz)
{
    int i;
    dprintf (("", "writing veneer from %p at %p\n", st, vn));
    int* entry_table = vn + sz / sizeof (void*);
    for (i = 0; i < sz / sizeof (void*); ++i) {
        int* entry = entry_table + 2 * i;

        /* if the method isn't implemented, don't veneer it */
        if (st[i] == NULL) continue;

        /* copy function pointer into veneer */
        vn[i] = st[i];

        /* copy new pointer into structure */
        st[i] = (int) entry;

        /* LDR ip, function[i] */
        entry[0] = 0xe51fC000       /* LDR ip, [pc, #-0] */
                  + 8               /* go back to current instruction */
                  + i * 8           /* go back to beginning of veneers */
                  + sz              /* go back to beginning of struct */
                  - i * 4;          /* go to func pointer */

        /* B common */
        entry[1] = 0xea000000       /* B here + 8 */
                  | ((magic - entry - 1) & 0x00ffffff);
                                    /* branch to diff */
    }
    _swix(OS_SynchroniseCodeAreas, _INR(0,2), 1,
                                   entry_table,
                                   entry_table + 2 * (sz / sizeof (void*)) - 1);
}

_kernel_oserror* register_bus(void *in,struct device **out)
{
    *out = NULL;
    /* Check USBDriver is new enough */
    int version;
    _kernel_oserror *e = _swix(USBDriver_Version,_OUT(0),&version);
    if(e)
        return e;
    if(version < RISCOS_USBDRIVER_API_VERSION)
    {
        static const _kernel_tokerror err_usbtooold = ErrorBlock_EHCI_USBTooOld;
    
        return _swix (MessageTrans_ErrorLookup, _INR(0,2),
                      &err_usbtooold, &mod_messages, 0 /* Internal buffer */);
    }

    /* Now attempt to register */
    registering = true;
    e = _swix(USBDriver_RegisterBus, _INR(0,1)|_OUT(0),in,RISCOS_USBDRIVER_API_VERSION,out);
    if(e) *out = NULL;
    registering = false;
    return e;
}

static void name_root_hub(int pcidevice)
{
    if (pci_device == -1)
    {
        _kernel_oserror *e;

        e = _swix (MessageTrans_Lookup, _INR(0,3),
                   &mod_messages, "UkRoot", ehci_soft.sc_vendor, sizeof(ehci_soft.sc_vendor));
        if (e) strcpy(ehci_soft.sc_vendor, " ");
    }
    else
    {
        char *v = NULL;
    
        _swix (PCI_ReadInfo, _INR(0,3), PCI_ReadInfo_Vendor, &v, sizeof(v), pci_device);
        if (v == NULL) v = " ";
        strncpy (ehci_soft.sc_vendor, v, sizeof ehci_soft.sc_vendor-1);
    }
}

_kernel_oserror* new_instance (_kernel_swi_regs* r, void* pw, void* h)
{
    _kernel_oserror * e;

    (void) r;
    (void) pw;
    
    /* fill in the device name in the callback so that our service call handler
       is threaded and there to respond to PCI calls */
    name_root_hub(pci_device);

    /* register with the usbdriver module if it's already resident */
    dprintf (("", "Registering with USB driver\n"));
    e = register_bus(&ehci_soft, &usb_soft);
    if (e)
    {
        dprintf (("", "Failed to register: %s\n", e->errmess));
    }
    else
    {
        if (hal_portpower)
        {
            for (int i = 0; i < ehci_soft.sc_noport; i++)
            {
                _swix(OS_Hardware, _INR(0,2) | _INR(8,9),
                      hal_device, i, 1, OSHW_CallHAL, EntryNo_HAL_USBPortPower);
            }
        }
        dprintf (("", "Registering with USB driver-done\n"));
    }


    // allow enough space for name, % and number, then space, device type,
    // and another number
    char name[sizeof Module_Title + 1 + 12 + 1 + 1 + 12];
    sprintf (name, Module_Title"%%%d %c%d", instance + 1, (pci_device>=0?'P':'H'), (pci_device>=0?pci_device:hal_device));
    dprintf (("", "Trying to start %s\n", name));
    e = _swix (OS_Module, _INR(0,1), 14, name);

    if (e)
    {
        dprintf (("", "Failed to start %s: %s\n", name, e->errmess));
    }

    return NULL;
}

/*---------------------------------------------------------------------------*/
/* CMHG module initialisation                                                */
/*---------------------------------------------------------------------------*/
_kernel_oserror *module_init(const char *cmd_tail, int podule_base, void *pw) {
    _kernel_oserror* e = 0;
    bool ettf = false;

    callx_init (pw);

    /* set up debugging */
#ifdef EHCI_DEBUG
    sprintf(debugname,"EHCIDrv-%d",podule_base);
#endif    
    debug_initialise (debugname, 0, 0);
//    debug_set_device(DEBUGIT_OUTPUT);
//    debug_set_device(PRINTF_OUTPUT);
    debug_set_device(DADEBUG_OUTPUT);
    debug_set_unbuffered_files (TRUE);
    /* cannot debug_set_stamp_debug (TRUE).. get stack overflow!!!
       Plus it causes interrupts to be briefly enabled during debug output, breaking all kinds of stuff  */
/*    debug_set_stamp_debug (TRUE);*/

    dprintf (("Main_0", "Starting driver\n"));

    /* simulate having one EHCI device attached.  This section has to
    communicate with HAL or podule manager to find out where it can read/write    to some EHCI registers */

    /* assume podule_base is actually instantiation number - how to do this
       in a HAL world?  If we're the first instance, then search for devices
       on the PCI bus */

    instance = podule_base;


    /* if we're the first instance, then start searching from device # 0,
       otherwise the device to start searching from was passed as a string
       in the command tail */

    if (podule_base != 0)
    {
        const char* endptr = cmd_tail;
        while(*endptr == ' ')
            endptr++;
        if(*endptr == 'P')
            pci_device = (int) strtol (endptr+1, NULL, 0);
        else if(*endptr == 'H')
            hal_device = (int) strtol (endptr+1, NULL, 0);
        else
        {
            static const _kernel_tokerror err_noreinit = ErrorBlock_EHCI_NoReinit;

            return _swix (MessageTrans_ErrorLookup, _INR(0,2),
                          &err_noreinit, 0 /* Global messages */, 0 /* Internal buffer */);
        }
    }
    else
    {
        pci_device = 0;
#ifdef STANDALONE
        /* Only first instance registers the messages in ResourceFS */
        e = _swix (ResourceFS_RegisterFiles, _IN (0), resource_files ());
        if (e != NULL) return e;
#endif
    }

    e = _swix (MessageTrans_OpenFile, _INR(0,2),
        &mod_messages,
        Module_MessagesFile,
        0);
    if (e) goto error_dereg;

    /* find the next possible controller */
    if(pci_device >= 0)
    {
        /* Looking for PCI device */
        e = _swix(PCI_FindByClass, _INR(0,1)|_IN(3)|_OUT(3),
            0x0C0320,
            0xFFFFFF,
            pci_device,
            &pci_device);
        if(!e && pci_device)
        {
             dprintf (("", "Found EHCI controller on PCI device %d\n", pci_device));
            e = _swix(PCI_ReadInfo, _INR(0,3),
                PCI_ReadInfo_IntDeviceVector,
                &device_number,
                sizeof device_number,
                pci_device);
            if (e) goto error;
        
        
            e = _swix(PCI_HardwareAddress, _INR(0,1)|_IN(3)|_OUT(4),
                0, 0, pci_device, &ehci_base);
            if (e) goto error;
        

            registers_32bit = 0;
        }
        else
        {
            /* Reached end of list */
            pci_device = -1;
            e = NULL;
        }
    }
    if(pci_device == -1)
    {
        /* Looking for HAL device */
        do {
            hal_device++;
            struct
            {
                int type;
                int flags;
                void *hw;
                int devno;
            } usbinfo;
            size_t usbinfolen;
    
            e = _swix(OS_Hardware, _INR(0,2)|_INR(8,9)|_OUT(0),
                                   hal_device, &usbinfo, sizeof usbinfo,
                                   OSHW_CallHAL, EntryNo_HAL_USBControllerInfo,
                                   &usbinfolen);
            if (!e && (usbinfolen == sizeof(usbinfo)) && (usbinfo.type == HALUSBControllerType_EHCI))
            {
                dprintf (("", "Found EHCI controller on HAL device %d\n", hal_device));
                device_number = usbinfo.devno;
                ehci_base = usbinfo.hw;
                if(usbinfo.flags & HALUSBControllerFlag_32bit_Regs)
                    registers_32bit = 1;
                if(usbinfo.flags & HALUSBControllerFlag_EHCI_ETTF)
                    ettf = true;
                if(usbinfo.flags & HALUSBControllerFlag_HAL_Port_Power)
                    hal_portpower = true;
                break;
            }
            else if(e || !usbinfolen)
            {
                /* Reached end of list */
                static const _kernel_tokerror err_noehci = ErrorBlock_EHCI_NoEHCI;
            
                e = _swix (MessageTrans_ErrorLookup, _INR(0,2),
                           &err_noehci, &mod_messages, 0 /* Internal buffer */);
                goto error;
            }
        } while(1);
    }

    memset (&ehci_soft, 0, sizeof ehci_soft);

    sprintf (ehci_soft.sc_bus.bdev.dv_xname, "EHCI%d", instance);
    ehci_soft.sc_irqdevno = device_number;
    dprintf (("Main_0", "interrupt device %d\n", device_number));
    dprintf (("Main_0", "hardware address %p\n", ehci_base));

    private_word = pw;

#ifdef EHCI_DEBUG
    const char *c = getenv("ehcidebug");
    usbdebug = ehcidebug = (c?atoi(c):0);
    irq0 = gettime () / 1000;
#endif

    if ((magic = init_veneer ()) == NULL)
    {
        static const _kernel_tokerror err_claimveneer = ErrorBlock_EHCI_ClaimVeneer;
    
        e = _swix (MessageTrans_ErrorLookup, _INR(0,2),
                   &err_claimveneer, &mod_messages, 0 /* Internal buffer */);
        goto error;
    }
    dprintf (("", "magic at %p", magic));

    _swix (OS_ClaimDeviceVector, _INR(0,2),
        device_number | ((pci_device == -1)?0:(1u<<31)),
        usb_irq_entry, pw);
    _swix (OS_Hardware, _IN(0) | _INR(8,9),
        device_number, OSHW_CallHAL, EntryNo_HAL_IRQEnable);

    if (ettf)
    {
        ehci_soft.sc_flags |= EHCIF_ETTF;
    }

    /* fix n companions */
    ehci_soft.sc_ncomp = 2;

    /* in BSD this is called from sys/pci/ehci_pci.c */
    ehci_init (&ehci_soft);

    dprintf (("", "Finished module initialisation\n"));

    /* try and start a new instance to catch any more controllers on the bus,
       done in a callback so that this instance is threaded and the instance
       count goes up */
    /* also register with the usbdriver module if it's already resident */

    callx_add_callback (new_instance, 0);

    return NULL;

error:
    dprintf (("","Failed initialisation: %s\n", e->errmess));
    _swix (MessageTrans_CloseFile, _IN(0), &mod_messages);
error_dereg:
#ifdef STANDALONE
    if (podule_base == 0) _swix (ResourceFS_DeregisterFiles, _IN(0), resource_files ());
#endif
    return e;
}

/*---------------------------------------------------------------------------*/
/* CMHG module finalisation                                                  */
/*---------------------------------------------------------------------------*/
_kernel_oserror *module_final(int fatal, int podule, void *pw)
{

    if (usb_soft != NULL)
    {
        _swix (USBDriver_DeregisterBus, _IN(0), usb_soft);
        usb_soft=NULL;
    }
// need to stop the controller
    EOWRITE4(&ehci_soft, EHCI_USBCMD, 0);
    EOWRITE4(&ehci_soft, EHCI_USBCMD, EHCI_CMD_HCRESET);
    EOREAD4(&ehci_soft, EHCI_USBCMD);/* flush the command */

    /* don't disable the interrupt since it is shared, the OS will disable it
       when noone is left responding */
//    _swix (OS_Hardware, _IN(0) | _INR(8,9),
//        device_number, OSHW_CallHAL, EntryNo_HAL_IRQDisable);
    callx_remove_all_callbacks ();
    callx_remove_all_callafters ();
    callx_remove_all_calleverys ();
    _swix (OS_ReleaseDeviceVector, _INR(0,2),
        device_number | ((pci_device == -1)?0:(1u<<31)),
        usb_irq_entry, pw);

    if (magic) _swix (OS_Module, _IN(0)|_IN(2), 7, magic);

    _swix (MessageTrans_CloseFile, _IN(0), &mod_messages);

#ifdef STANDALONE
    /* only remove files for last instantiation */
    if (podule == 0)
    {
        _swix (ResourceFS_DeregisterFiles, _IN (0), resource_files ());
    }
#endif

    return NULL;
}

/*---------------------------------------------------------------------------*/
/* CMHG module service calls                                                 */
/*---------------------------------------------------------------------------*/
void module_services(int service_number, _kernel_swi_regs *r, void *pw)
{
    dprintf (("", "svce %x reason %x\n",service_number,r->r[0]));
    switch (service_number)
    {
      case Service_USB:
        switch (r->r[0])
        {
           case Service_USB_USBDriverStarting:
             if ((usb_soft == NULL) && !registering)
             {
                 dprintf (("", "Registering with USB driver from svcecall\n"));
                 _kernel_oserror *e = register_bus(&ehci_soft,&usb_soft);
                 if(e)
                 {
                     dprintf (("", "Failed to register: %s\n", e->errmess));
                 }
                 else
                 {
                     dprintf (("", "Registering with USB driver from svcecall-done\n"));
                 }
             }
             break;
           case Service_USB_USBDriverDying:
             dprintf (("", "Deregistering with USB driver\n"));
             /* USBDriver will do the deregistering at this point, since
                its SWIs are not active anymore */
             ehci_detach(&ehci_soft,0);
             ehci_shutdown(&ehci_soft);
             usb_soft = NULL;
             memset (&ehci_soft, 0, sizeof ehci_soft);
             sprintf (ehci_soft.sc_bus.bdev.dv_xname, "EHCI%d", instance);
             name_root_hub (pci_device);
             ehci_init (&ehci_soft);
             break;
           default:break;
         }
        break;
      case Service_PreReset:
        dprintf (("", "Svce prereset %x %x\n",Service_PreReset,service_number));
        /* reset the controller */
        EOWRITE4(&ehci_soft, EHCI_USBCMD, 0);
        EOWRITE4(&ehci_soft, EHCI_USBCMD, EHCI_CMD_HCRESET);
        EOREAD4(&ehci_soft, EHCI_USBCMD);/* flush the command */
        callx_remove_all_callbacks ();
        callx_remove_all_callafters ();
        callx_remove_all_calleverys ();
        _swix (OS_ReleaseDeviceVector, _INR(0,2),
            device_number | ((pci_device == -1)?0:(1u<<31)),
            usb_irq_entry, pw);
        break;
#ifdef STANDALONE
      case Service_ResourceFSStarting:
        /* Re-register the messages */
        (*(void (*)(void *, void *, void *, void *))r->r[2]) (resource_files (), 0, 0, (void *)r->r[3]);
        break;
#endif
    }
}

#ifdef EHCI_DEBUG
/*---------------------------------------------------------------------------*/
/* CMHG module commands - only used for debugging                            */
/*---------------------------------------------------------------------------*/
_kernel_oserror *module_commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
    ehci_softc_t* sc = &ehci_soft;



   switch (cmd_no) {
    case CMD_EHCIRegs:
        printf
        (
            "   PCI device             %8d\n"
            "   Unhandled IRQs         %8d\n"
            "%2X USB Command            %8.8X\n"
            "%2X USB Status             %8.8X\n"
            "%2X USB Interrupt Enable   %8.8X\n"
            "%2X USB Frame Index        %8.8X\n"
            "%2X 4G Segment Selector    %8.8X\n"
            "%2X Frame List Base Addres %8.8X\n"
            "%2X Next Asynch List       %8.8X\n"
//            "%2X Config flag            %8.8X\n"
            "%2X Port1                  %8.8X\n"
            "%2X Port2                  %8.8X\n"
            "%2X Port3                  %8.8X\n"
            "%2X Port4                  %8.8X\n"
            "%2X Port5                  %8.8X\n"
            "%2X Port6                  %8.8X\n",
               pci_device,
               unhandled_irqs,
	       EHCI_USBCMD, EOREAD4(sc, EHCI_USBCMD),
	       EHCI_USBSTS, EOREAD4(sc, EHCI_USBSTS),
	       EHCI_USBINTR, EOREAD4(sc, EHCI_USBINTR),
	       EHCI_FRINDEX, EOREAD4(sc, EHCI_FRINDEX),
	       EHCI_CTRLDSSEGMENT, EOREAD4(sc, EHCI_CTRLDSSEGMENT),
	       EHCI_PERIODICLISTBASE, EOREAD4(sc, EHCI_PERIODICLISTBASE),
	       EHCI_ASYNCLISTADDR, EOREAD4(sc, EHCI_ASYNCLISTADDR),
               EHCI_PORTSC(1), EOREAD4(sc, EHCI_PORTSC(1)),
               EHCI_PORTSC(2), EOREAD4(sc, EHCI_PORTSC(2)),
               EHCI_PORTSC(3), EOREAD4(sc, EHCI_PORTSC(3)),
               EHCI_PORTSC(4), EOREAD4(sc, EHCI_PORTSC(4)),
               EHCI_PORTSC(5), EOREAD4(sc, EHCI_PORTSC(5)),
               EHCI_PORTSC(6), EOREAD4(sc, EHCI_PORTSC(6))
        );

#ifdef EHCI_DEBUG
        ehci_dump_regs (&ehci_soft);
        break;
    case CMD_EHCIDebug:
        {
        char* ptr;
        ehcidebug = (int) strtoul (arg_string, &ptr, 0);
        if (ptr) usbdebug = (int) strtoul (ptr, &ptr, 0);
        }
#endif
        break;
//    case CMD_OHCIEDS:
//        {
//#ifdef EHCI_DEBUG
//            ehci_soft_ed_t* sed;
//            sed = ehci_soft.sc_isoc_head;
//            while (sed != NULL) {
//                ehci_dump_ed(sed);
//                sed = sed->next;
//            }
//            sed = ehci_soft.sc_ctrl_head;
//            while (sed != NULL) {
//
//                ehci_dump_ed(sed);
//                sed = sed->next;
//            }
//            sed = ehci_soft.sc_bulk_head;
//            while (sed != NULL) {
//                ehci_dump_ed(sed);
//                sed = sed->next;
//            }
//#endif
//            break;
//        }
//    case CMD_OHCIWrite:
//        {
//        int a, b;
//        char* ptr;
//        a = (int) strtoul (arg_string, &ptr, 16);
//        b = (int) strtoul (ptr, 0, 16);
//        printf ("writing %x to %x\n", b, a);
//        ehci_base[a / 4] = b;
//        }
//        break;
//    default:
//        break;
    }

    return 0;
}
#endif

/*---------------------------------------------------------------------------*/
/* CMHG interrupt veneer handler                                             */
/*---------------------------------------------------------------------------*/
int usb_irq_handler(_kernel_swi_regs *r, void *pw)
{
    int ret;
    // ehci_intr returns 0 for failure, 1 for success, the inverse of what
    // we're expected to return

#ifdef EHCI_DEBUG
    int u2s, u2s1;
    _swix (OS_Hardware, _INR(8,9)|_OUT(0),
        OSHW_CallHAL, EntryNo_HAL_CounterRead, &u2s);
//    irqs++;
//    ehci_softc_t* sc = &ehci_soft;
//    if (ehcidebug > 1) dprintf (("", "Frame index: %x\n",
//            EOREAD4(sc, EHCI_FRINDEX)));
#endif

    ret = !ehci_intr (&ehci_soft);

#ifdef EHCI_DEBUG
    if (ret)
    {
        unhandled_irqs++;
    }
    else
    {
        _swix (OS_Hardware, _INR(8,9)|_OUT(0),
            OSHW_CallHAL, EntryNo_HAL_CounterRead, &u2s1);
        int t = (u2s - u2s1) * 5;
        if (t < 0) t += 10000000; /* it wrapped */
        if (ehcidebug > 1) dprintf(("", "irq for: %d nsecs\n", t));
    }
#endif

    return ret;
}

/*---------------------------------------------------------------------------*/
/* Leaf functions                                                            */
/*---------------------------------------------------------------------------*/
void bus_space_write_4 (bus_space_tag_t iot, bus_space_handle_t ioh, int o, int x)
{
#ifdef EHCI_DEBUG0
    if (ehcidebug > 10)
        dprintf  (("", "write %x to %p\n", x, ehci_base + o/4));
#endif
    ehci_base[o>>2] = x;
}

int bus_space_read_4 (bus_space_tag_t iot, bus_space_handle_t ioh, int o)
{
    int val = ehci_base[o>>2];
#ifdef EHCI_DEBUG0
    if (ehcidebug > 15)
         dprintf  (("", "read %x from %p\n", val, ehci_base + o/4));
#endif
    return val;
}

void bus_space_write_2 (bus_space_tag_t iot, bus_space_handle_t ioh, int o, int x)
{
#ifdef EHCI_DEBUG0
    if (ehcidebug > 10)
        dprintf  (("", "write %x to %p\n", x, ((uint16_t*) ehci_base) + o/2));
#endif
    if (registers_32bit)
    {
      x &= 0xFFFF;
      if (o&2)
        ehci_base[o>>2]=(ehci_base[o>>2]&0xFFFF)|(x<<16);
      else
        ehci_base[o>>2]=(ehci_base[o>>2]&0xFFFF0000)|x;
    }
    else
      ((uint16_t*) ehci_base)[o>>1] = x;
}

int bus_space_read_2 (bus_space_tag_t iot, bus_space_handle_t ioh, int o)
{
    uint32_t value;
    if (registers_32bit)
    {
      if (o&2)
        value = ((uint32_t*)ehci_base)[o>>2]>>16;
      else
        value = ((uint32_t*)ehci_base)[o>>2]&0xFFFF;
    }
    else
      value = ((uint16_t*) ehci_base)[o>>1];
#ifdef EHCI_DEBUG0
    if (ehcidebug > 15)
    {
       dprintf(("", "read %x from %p\n",value,((uint16_t*)ehci_base) + o/2));
   }
#endif
   return value;
}

void bus_space_write_1 (bus_space_tag_t iot, bus_space_handle_t ioh, int o, int x)
{
#ifdef EHCI_DEBUG0
    if (ehcidebug > 10)
        dprintf  (("", "write %x to %p\n", x, ((uint8_t*) ehci_base) + o));
#endif
    if (registers_32bit)
    {
      x &= 0xFF;
      int t = ehci_base[o>>2];
      t &= ~(0xFF<<((o&3)*8));
      t |= x<<((o&3)*8);
      ehci_base[o>>2] = t;
    }
    else
      ((uint8_t*) ehci_base)[o] = x;
}

int bus_space_read_1 (bus_space_tag_t iot, bus_space_handle_t ioh, int o)
{
    uint32_t value;
    if (registers_32bit)
      value = (((uint32_t*)ehci_base)[o/4]>>((o&3)*8))&0xff;
    else
      value = ((uint8_t*) ehci_base)[o];
#ifdef EHCI_DEBUG0
    if (ehcidebug > 15)
    {
         dprintf  (("", "read %x from %p\n",
            value, ehci_base + o));
    }
#endif
    return value;
}


void timeout(timeout_func_t f, void * h, int t)
{
    dprintf (("Main_0", "timeout %p %d\n", h, t));
}

void untimeout(timeout_func_t f, void * h)
{
    dprintf (("Main_0", "untimeout %p\n", h));
}

/* declare here to avoid clash with sys/types.h */
int	tsleep(void *chan, int pri, char *wmesg, int timo, int noblock);
void usb_delay_ms(usbd_bus_handle h, u_int d)
{
    tsleep (&d, 0, "usbdly", d, 0);
}

usbd_status
usb_insert_transfer(usbd_xfer_handle xfer)
{
    usbd_status status;
    _swix (USBDriver_InsertTransfer, _IN (0) | _OUT (0), xfer, &status);
    return status;
}

void
usb_transfer_complete(usbd_xfer_handle xfer)
{
    _swix (USBDriver_TransferComplete, _IN (0), xfer);
}

_kernel_oserror*
_riscos_abort_pipe (_kernel_swi_regs * r, void* pw, void* v)
{
    ehci_abort_xfer (v, USBD_TIMEOUT);
    return NULL;
}

void
riscos_abort_pipe (void* v)
{
    callx_add_callback (_riscos_abort_pipe, v);
}

void
usb_schedsoftintr (struct usbd_bus* sc)
{
//    dprintf (("", "Scheduling soft interrupt\n"));
//    *(void**) sc->soft = (void*) softintr_entry;
    _swix (USBDriver_ScheduleSoftInterrupt, _IN(0), sc);
}

int
softintr (_kernel_swi_regs* r, void* pw)
{
    ehci_softintr ((void*) r->r[0]);
    return 1;
}
@


1.28
log
@Messages fixes, internationalisation, minor clean ups
Detail:
  USBDriver was performing unnecessary messages file reopening on Service_ResourceFSStarted (MessageTrans does this itself), remove this.
  Internationalised USBDriver, in particular its *Commands.
  Fixed standalone builds to output the messages file objects in the right place (Makefile mistake).
  Changed OHCIDriver and EHCIDriver to use allocated error bases rather than 0.
  Sync'd, where possible, the OHCIDriver and EHCIDriver sources which share a common heritage. Tentative shared interrupt support fixes for non-PCI attached controllers. Comment blocks & indentation improved.
  Export min() macro in usb_port.h.
  CMHG updated to not listen for unwanted services.
Admin:
  Submission for USB bounty.
  Tested on Pandaboard and Pi 2. OHCIDriver untested but low risk.

Version 1.18. Tagged as 'NetBSD-1_18'
@
text
@@


1.27
log
@Case change to match documentation
Detail:
  DeRegisterBus->DeregisterBus. Since clients calling this SWI are compiled C or assembler, this doesn't affect existing modules which remain binary compatible.
Admin:
  Submission for USB bounty.

Version 1.17. Tagged as 'NetBSD-1_17'
@
text
@a14 2
#include "ehcimodhead.h"
#include "swis.h"
d19 1
d37 1
d42 1
d46 10
a56 5




extern uint64_t gettime (void);
a66 6
void* private_word;

volatile int* ehci_base;

ehci_softc_t ehci_soft;
struct device * usb_soft = NULL;
d68 1
a68 1
//extern void* resource_files (void);
d70 1
d76 5
a80 25

























d83 8
d92 3
a128 9
int pci_device = -1;
int hal_device = -1;
int instance = 0;
int device_number;
int unhandled_irqs;
int registers_32bit=0;
static bool registering=false; /* True/false for whether we're in the middle of registering. Avoids nested registration attempt during ROM init. */
static bool hal_portpower = false; /* Whether to use HAL_PortPower to control the port */

d138 7
a144 1
        return (_kernel_oserror*)"\0\0\0\0USBDriver too old";
d153 20
d180 3
a182 2


d220 3
a222 2


d267 1
a267 1
        else if(*endptr > 32)
d269 4
a272 2
            return (_kernel_oserror*)
                "\1\0\0\0"Module_Title" can't be reinitialised";
a273 2
        else
            pci_device = 0;
d278 5
d285 6
d359 5
a363 1
                return (_kernel_oserror*) "\0\0\0\0No EHCI devices found";
d368 4
a382 5
    _swix (OS_ClaimDeviceVector, _INR(0,4),
        device_number| (1u<<31), usb_irq_entry, pw, 0, 0);
    _swix (OS_Hardware, _IN(0) | _INR(8,9),
        device_number, OSHW_CallHAL, EntryNo_HAL_IRQEnable);

d385 5
a389 1
        return (_kernel_oserror*) "\0\0\0\0Couldn't claim magic";
d393 5
a397 4
    memset (&ehci_soft, 0, sizeof ehci_soft);

    sprintf (ehci_soft.sc_bus.bdev.dv_xname, "EHCI%d", instance);
    ehci_soft.sc_irqdevno = device_number;
a409 2


d412 4
a415 1
    /* try and start a new instance to catch any more controllers on the bus */
d417 1
a417 1
     callx_add_callback (new_instance, 0);
d419 1
a419 1
    return 0;
d423 5
d431 3
a433 1

d454 3
a456 2
    _swix (OS_ReleaseDeviceVector, _INR(0,4),
        device_number | (1u<<31), usb_irq_entry, pw, 0, 0);
d460 10
d473 3
d502 1
a502 1
                it's SWIs are not active anymore */
d507 2
d523 3
a525 2
        _swix (OS_ReleaseDeviceVector, _INR(0,4),
            device_number | (1u<<31), usb_irq_entry, pw, 0, 0);
d527 6
a532 1
      default:break;
a535 2
#define OREAD(o) ehci_base[o/4]

d537 3
d635 3
a637 10










d674 3
a814 29





























@


1.26
log
@Don't build a veneer that points to nothing
The safety struct fillers added in OHCIDriver 0.44 and EHCIDriver 0.30 respectively were being carefully replaced by veneers to nothing. Skip veneer generation is the method isn't implemented.

Version 1.09. Tagged as 'NetBSD-1_09'
@
text
@d401 1
a401 1
        _swix (USBDriver_DeRegisterBus, _IN(0), usb_soft);
@


1.25
log
@Add support for HAL_USBPortPower to EHCI host controller
Detail:
  When signalled as a feature of the HAL device, call HAL_USBPortPower to turn on the port.
Admin:
  Submission from Willi Theiss.

Version 1.05. Tagged as 'NetBSD-1_05'
@
text
@d111 3
@


1.24
log
@Export USBDriver definitions to normal location
USBDriver was not exporting its SWI (and other) definitions to the export directory like other modules do, meaning the host controller drivers all have to reach into this component to get their hands on it.
Makefile:
  Export an assembler header, conversion to C, and SWI definitions from CMHG.
  Rationalise the dev/usb/h/* headers which are exported in addition to those that are pertinent to host controllers (was missing usbdivar, and was exporting unused usbdi_util).
  Export machine/h/bus too.
  As it's unusual for a CModule to output both a library and module and headers, the EXPDIR has been divided into EXPLIBDIR for those things in C:USB, and EXPDIR for the others.
ehcimodule.c/ohcimodule.c:
  Use the exported USBDriver.h

Version 0.98. Tagged as 'NetBSD-0_98'
@
text
@d141 1
d180 8
d316 1
a316 1
                                   0, EntryNo_HAL_USBControllerInfo,
d327 2
d353 1
a353 1
        device_number, 0, EntryNo_HAL_IRQEnable);
d409 1
a409 1
//        device_number, 0, EntryNo_HAL_IRQDisable);
d590 1
a590 1
        0, EntryNo_HAL_CounterRead, &u2s);
d607 1
a607 1
            0, EntryNo_HAL_CounterRead, &u2s1);
@


1.23
log
@Deregister IRQ handlers in Service_PreReset
Detail:
  build/c/ehcimodule, build/c/ohcimodule - Deregister IRQ handlers in Service_PreReset. Fixes a hang during reset on OMAP4.
  build/Version - Bump module version numbers for recent changes.
Admin:
  Tested on Pandaboard, Iyonix


Version 0.93. Tagged as 'NetBSD-0_93'
@
text
@a15 1
#include "USBDriver.h"
d36 1
@


1.22
log
@  Revisit Service_PreReset activity
Detail:
  Recent investigations in stalling of OS_Reset showed that with multiple
  driver modules it was possible for the monotonic timer to be turned off
  before the usb system had shut down. Service_PreReset needs a rapid finite
  response to silence the relevant module's hardware and ensure it cannot
  intiiate something that could stall the reset process.
  As a result USBDriver module no longer issues Service_USB_DriverDying in
  its Service_PreReset response; it merely silences itself and removes itself
  from any vectors. This EHCIDriver and OHCIDriver modules now only need to
  silence themselves when receiving Service_PreReset.
Admin:
  tested in iMx6 and iyonix


Version 0.92. Tagged as 'NetBSD-0_92'
@
text
@d455 2
@


1.21
log
@Merge in some EHCI fixes from NetBSD. Other minor changes.
Detail:
  build/Version - Bump EHCIDriver version number
  build/c/ehcihal, build/c/ehcimodule, build/c/ohcimodule - Use the HAL USB controller type & flag definitions from Hdr:HALEntries instead of using magic numbers
  build/c/ehcimodule - Avoid double-read of hardware register in debug version of bus_space_read_4(); ensures that we report the value that's actually returned to the driver
  dev/usb/c/ehci - Merge in the following revisions from NetBSD:
  - 1.172, 1.173, 1.178, 1.193 - Support for controllers with embedded transaction translators
  - 1.174 - alloc_sqtd_chain() fix for short packets that end on page boundaries
  - 1.179 - ehci_set_qh_qtd() fixed to terminate alternate next qTD pointer with EHCI_NULL, not 0
  dev/usb/h/ehcireg - Updated to latest NetBSD version (1.34)
  dev/usb/h/ehcivar - Merge in revision 1.38 (ETTF support)
Admin:
  Tested on BB-xM


Version 0.88. Tagged as 'NetBSD-0_88'
@
text
@d452 3
@


1.20
log
@Tidy up exported USBDevFS.h
Detail:
  build/h/USBDevFS - Added extra #ifdef guard to allow USBDevFS.h to be safely included by software that uses the BSD USB headers. Add the DeviceFS_CallDevice codes that USBDriver uses.
  build/h/service - Removed redundant secondary definition of the service call structures which the drivers were using internally
  build/c/ehcihal - Removed redundant #includes
  build/c/ehcidriver, build/c/ohcidriver - Use USBDevFS.h instead of service.h
  build/c/usbmodule - Use USBDevFS.h instead of service.h. Get rid of local DeviceCall definitions and use the ones which are now in USBDevFS.h. Also switched over to using Interface/DevicsFS.h for the main DevicsFS call reason codes, to match the naming convention used by USBDevFS.h (as opposed to the OSLib naming convention that was used previously). Stripped the unused OBSOLETE_SERVICE_CALLS code.
  build/Makefile - Add usbdi_util.h to the header exports
Admin:
  Tested with building OMAP3, Tungsten & BCM2835 ROMs
  Builds to binary-identical modules as previous version.


Version 0.85. Tagged as 'NetBSD-0_85'
@
text
@d202 1
d309 1
a309 1
            if (!e && (usbinfolen == sizeof(usbinfo)) && usbinfo.type == 1)
d314 1
a314 2
                /* The only flag we support ATM is for 32bit register access */
                if(usbinfo.flags & 8)
d316 2
d355 5
d612 1
d615 1
a615 1
         dprintf  (("", "read %x from %p\n", ehci_base[o/4], ehci_base + o/4));
d617 1
a617 1
    return ehci_base[o>>2];
@


1.19
log
@Add re-entrancy check to USBDriver registration
Detail:
  build/c/ehcimodule, build/c/ohcimodule - Added a re-entrancy check to USBDriver registration, to avoid shenanigans if we receive "USBDriver has started" service calls while in the middle of registering
  build/Version - Bump EHCIDriver & OHCIDriver versions & dates
Admin:
  Tested on BB-xM
  Doesn't fix any known EHCIDriver/OHCIDriver-related issues, but is the same fix as was made to DWCDriver after the above-mentioned problem was found to be the cause of a hang on boot in recent Pi ROMs


Version 0.77. Tagged as 'NetBSD-0_77'
@
text
@d43 1
a43 2
#include "service.h"
#include "oslib/devicefs.h"
d411 1
a411 1
           case Service_USBDriver_Starting:
d426 1
a426 1
           case Service_USBDriver_Dying:
@


1.18
log
@Fix null pointer dereferences. Add protection against DeviceFS xfers being multiply inserted into their pipes xfer queue.
Detail:
  build/Version - Increased version numbers
  build/c/ehcimodule, build/c/ohcimodule - Fixed null pointer dereferences in debug code
  build/c/port, build/s/triggercbs - Fix debug code in tsleep() using hardcoded IRQsema ptr. Now requests the right pointer from build/s/triggercbs.
  build/c/usbmodule - Fix null pointer deferences in debug code and MonitorTX/MonitorRX handlers. Add xfer_busy and delayed_read flags to devstream struct in order to track whether the xfer associated with the stream is busy or not. Previously if the TxWakeUp/RxWakeUp device calls were made on a stream which already had an active xfer, the xfer would end up being inserted in the USB pipes xfer queue twice, creating a circular reference, resulting in (at the least) infinite loops in usbd_dump_queue() when debugging is enabled. Now, in the case of reads, a second read will automatically be issued once the first completes, while in the case of writes, the write request will simply be ignored. This isn't a proper fix for all the shortcomings of the DeviceFS interface, but at least the code is now a little bit safer.
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.72. Tagged as 'NetBSD-0_72'
@
text
@d141 1
d154 1
d157 1
d413 1
a413 1
             if (usb_soft == NULL)
@


1.17
log
@Make RHENIUM build switch go away. Misc housekeeping
Detail:
  build/Makefile, build/!MkDebug,fd7 - Debug versions of the modules can now be built just by passing "DEBUG=TRUE" to amu
  build/!MkRhenium,fd7 - Deleted obsolete file
  build/Version - Increased version numbers
  build/c/ehcihal, build/c/ehcimodule, build/c/ohcimodule - Only accept USB controllers if HAL_USBControllerInfo says the struct size is an exact match with what we expect. Rework USB controller enumeration to allow modules to properly support both PCI and HAL controllers being available on the same machine, and without RHENIUM switch (module sources only).
  build/c/ehcimodule - Get rid of remaining RHENIUM bits; RHENIUM flag no longer needed for 32bit wide register reads/writes to be supported
  build/c/ohcimodule, build/cmhg/ohcimodhead, dev/usb/c/ohci - Get rid of remaining RHENIUM bits; RHENIUM flag no longer needed for HAL port power controls to be supported.
  build/c/usbhal, build/c/usbmodule, dev/usb/c/uhub, dev/usb/h/usb_port - Get rid of empty riscos_failed_device function
  build/s/call_veneer, build/s/triggercbs - Use Entry/EXIT macros to avoid single-reg LDM/STM performance warnings. Convert tabs to spaces.
  dev/usb/h/usb - Get rid of RHENIUM switch on USB_PORT_RESET_DELAY. Now always uses non-RHENIUM value of 100ms.
Admin:
  Tested on rev A2 BB-xM, Iyonix, Raspberry Pi


Version 0.71. Tagged as 'NetBSD-0_71'
@
text
@d330 2
a331 1
    usbdebug = ehcidebug = atoi (getenv ("ehcidebug"));
@


1.16
log
@Add the ability to build the USB drivers as HAL-compatible static libraries
Detail:
  build/Makefile, build/OBJEHCIDriver, build/OBJOHCIDriver, build/OBJUSBDriver - Modified makefiles to build the HAL libs during the export libs phase
  build/!MkHAL,fd7 - Handy script for building the HAL libs
  build/Hdr/usbhal - Header containing definitions for the assembler code. Also gets exported so that HALs know how much workspace to reserve.
  build/c/usbhal - HAL version of usbmodule.c & port.c. Also contains the keyboard scan code, adapted from the code in the Tungsten HAL.
  build/s/porthal - Assembler versions of some port.c routines that were easier to do in assembler than C
  build/s/halheap - OS_Heap code that's been adapted for use in the HAL. Could easily be changed into a standalone library instead of being part of the HAL USB libs. Supports memory-efficient allocation of aligned blocks.
  build/c/ehcihal - HAL version of ehcimodule.c. Currently only supports EHCI controllers exposed via HAL_USBControllerInfo (i.e. no PCI support)
  build/c/ehcimodule, build/c/ohcimodule, build/c/port - Moved riscos_irq_clear into port.c. Removed unused microtime() function.
  build/c/usbmouse - Strip out some debug-related code in non-debug builds
  build/Version - Updated version numbers
  dev/usb/c/ehci, dev/usb/h/ehcivar - Adapted to add support for the HAL build. Apart from the base changes, the code has also been tweaked to significantly reduce the amount of memory used at runtime by the HAL version of the driver.
  dev/usb/c/hid, dev/usb/c/uhub, dev/usb/c/usb, dev/usb/c/usb_quirks, dev/usb/c/usb_subr, dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/c/usbroothub_subr - Changes to support HAL builds. Mainly disabling bits that won't work in the HAL or disabling bits for RISC OS in general if they weren't being used in the first place.
  dev/usb/c/ohci, dev/usb/h/ohcivar - Basic changes to support HAL builds. However HAL OHCI support is still incomplete.
  dev/usb/h/usb_port - Added support for the HAL build. Also tweaked logprintf definition to get rid of logprintf calls entirely in non-debug builds.
  dev/usb/h/usbdivar - Added support for the HAL build.
  dev/usb/h/usbhal - New header used by the HAL build. Gets included by every C file to ensure the compiler doesn't use sb, and contains structs/macros to allow access to the shared workspace.
Admin:
  HAL & non-HAL builds tested on rev C2 BB, rev A2 BB-xM, rev C1 TouchBook.
  Non-HAL builds tested with Iyonix ROM softload.
  Needs latest Kernel source for OSEntries.h export.


Version 0.59. Tagged as 'NetBSD-0_59'
@
text
@a58 1
//int irq_buf;
d135 2
a136 1
int pci_device = 0;
d140 1
a140 4

#ifdef RHENIUM
int registers_32bit=0;                    //(used with rhenium)
#endif        /* RHENIUM */
d181 4
a184 4
    // allow enough space for name, % and number, then space, and
    // another number
    char name[sizeof Module_Title + 1 + 12 + 1 + 12];
    sprintf (name, Module_Title"%%%d %d", instance + 1, pci_device);
d234 8
a241 3
        char* endptr;
        pci_device = (int) strtol (cmd_tail, &endptr, 0);
        if (endptr == cmd_tail)
d246 6
a252 7
//#ifdef STANDALONE
//    else
//    {
//        e = _swix (ResourceFS_RegisterFiles, _IN (0), resource_files ());
//        if (e != NULL) return e;
//    }
//#endif
d254 24
d279 14
a292 10
    // find the next possible controller
    do {
    e = _swix(PCI_FindByClass, _INR(0,1)|_IN(3)|_OUT(3),
        0x0C0320,
        0xFFFFFF,
        pci_device,
        &pci_device);
#ifdef RHENIUM
       if (e || pci_device == 0)
       {
d301 1
a301 1

d303 1
a303 1
                                   instance, &usbinfo, sizeof usbinfo,
d306 1
a306 1
            if (!e && (usbinfolen >= sizeof(usbinfo)) && usbinfo.type == 1)
d308 1
d311 1
a311 1
                // The only flag we support ATM is for 32bit register access
d313 7
a319 2
                  registers_32bit = 1;
                pci_device = -1;
d321 1
a321 13
            else
                pci_device = 0; // Explicitly set pci_device to the fail state else we'll start infinite instantiations if the PCI module isn't present
        }
#endif  /* RHENIUM */
    if (e) return e;
    } while (0);

    /* if there were no more EHCI controllers, then return an error.  This
       will be thrown away by the callback above */

    if (pci_device == 0)
    {
        return (_kernel_oserror*) "\0\0\0\0No EHCI devices found";
d324 2
a325 28
    dprintf (("", "Found EHCI controller on device %d\n", pci_device));

#ifdef   RHENIUM

    if (pci_device != -1)
    {
#endif  /* RHENIUM */
    
        /* now establish our interrupt and address */
    
        e = _swix(PCI_ReadInfo, _INR(0,3),
            PCI_ReadInfo_IntDeviceVector,
            &device_number,
            sizeof device_number,
            pci_device);
        if (e) goto error;
    
        dprintf (("Main_0", "interrupt device %d\n", device_number));
    
        e = _swix(PCI_HardwareAddress, _INR(0,1)|_IN(3)|_OUT(4),
            0, 0, pci_device, &ehci_base);
        if (e) goto error;
    
        dprintf (("Main_0", "hardware address %p\n", ehci_base));
#ifdef   RHENIUM
     }
#endif  /* RHENIUM */

a362 1
//   _swix (OS_AddCallBack, _INR(0,1), new_entry, pw);
a396 7
//#ifdef STANDALONE
//    /* only remove files for last instantiation */
//    if (podule == 0)
//    {
//        _swix (ResourceFS_DeregisterFiles, _IN (0), resource_files ());
//    }
//#endif
a584 11
//        if (irq_buf)
//        {
//            _swix (OS_CallAVector, _INR(1,3)|_IN(9),
//                irq_buf | (1<<31),
//                (int [2]) { gettime () / 1000 - irq0, t},
//                8,
//                20);
//        }
//        irq_tot += t;
//        if (t < irq_min) irq_min = t;
//        if (t > irq_max) irq_max = t;
a614 1
#ifdef RHENIUM
a623 1
#endif
d629 1
a629 13
#ifdef EHCI_DEBUG0
    if (ehcidebug > 15)
    {
#ifdef RHENIUM
       if (registers_32bit)
         dprintf(("", "read %x from %p\n",ehci_base[o>>2],((uint16_t*)ehci_base) + o/2));
       else
#endif
         dprintf  (("", "read %x from %p\n",
            ((uint16_t*)ehci_base)[o>>1], ((uint16_t*)ehci_base) + o/2));
   }
#endif
#ifdef RHENIUM
d633 1
a633 1
        return ((uint32_t*)ehci_base)[o>>2]>>16;
d635 1
a635 1
        return ((uint32_t*)ehci_base)[o>>2]&0xFFFF;
d637 7
d645 1
a645 1
    return ((uint16_t*) ehci_base)[o>>1];
a653 1
#ifdef RHENIUM
a662 1
#endif
d668 5
a675 5
#ifdef RHENIUM
       if (registers_32bit)
         dprintf  (("", "read %x from %p\n", ehci_base[o/4], ((uint8_t*)ehci_base)+o));
       else
#endif
d677 1
a677 1
            ((uint8_t*) ehci_base)[o], ehci_base + o));
d680 1
a680 5
#ifdef RHENIUM
    if (registers_32bit)
      return (((uint32_t*)ehci_base)[o/4]>>((o&3)*8))&0xff;
#endif
    return ((uint8_t*) ehci_base)[o];
a770 20

/*---------------------------------------------------------------------------*/
//#ifdef EHCI_DEBUG
//
//_kernel_oserror* driver (_kernel_swi_regs* r, void* pw)
//{
//    switch (r->r[0])
//    {
//    case DeviceFSCallDevice_Terminate:
//        irq_buf = 0;
//        break;
//    case DeviceFSCallDevice_StreamCreated:
//        irq_buf = r->r[3];
//        break;
//    }
//
//    return NULL;
//}
//
//#endif
@


1.15
log
@Update EHCI driver to NetBSD latest (as of 10/07/2010), improve DeviceFS interface
Detail:
  EHCI driver update:
    dev/usb/c/ehci - Updated to latest NetBSD version, except for revisions 1.134 and 1.135 which are too invasive to merge in without updating the rest of the USB stack. This new version brings lots of bug fixes, and adds (untested on RISC OS) support for EHCI isochronous transfers.
    dev/usb/h/ehcivar - Updated to latest NetBSD version, except for the sc_bus splitting that was held back from the ehci.c update
    dev/usb/h/usb, dev/usb/h/usbdi, dev/usb/usbdivar - partial update to latest as required/possible
    dev/usb/c/usb_quirks, dev/usb/h/ehcireg, dev/usb/h/usb_mem, dev/usb/h/usb_quirks, dev/usb/h/usbhid, dev/usb/usbdevs, dev/usb/devlist2h.awk, dev/wscons/h/wsconsio, dev/wscons/h/wsmousevar - Updated to latest NetBSD versions
    dev/usb/c/usbroothub_subr, dev/usb/h/usbroothub_subr - New files brought in from NetBSD sources for use with new EHCI driver
    build/objehcidriver - Added usbroorhub_subr to EHCI driver
    dev/usb/h/usb_port - Added extra dummy functions as required by new EHCI driver
    dev/build/c/port - Added extra parameter to callout_init as required by new EHCI driver
  DeviceFS improvements:
    build/c/usbmodule - Added DeviceFSCallDevice_GetHandles2 as a replacement for Thomas Milius's backwards-incompatible GetHandles changes. Added DeviceFSCallDevice_GetSetOptions call to control RX padding and TX force-short-xfer features. These features can also be controlled at endpoint creation time by new fields in the filename. Also fixed packet padding to not fill the buffer with garbage or potentially crash when the padded area is more than one packet in length.
  New bus registration API:
    Changes made to the data structures that are shared between the modules means that new checks are needed to ensure USB modules with incompatible APIs are not used with one another.
    build/h/usbdivar - Since this seems to be the file containing the main structures that are shared, it now has a #define at the top indicating the first version of the USBDriver module that implemented the data structures within. This version number is used to check that the driver modules are compatible.
    build/cmhg/usbmodhead, build/h/usbdriver, build/c/usbmodule - Add a new SWI, USBDriver_Version, to return the version number of the USBDriver module. Used for both intra-stack API version checks and can be useful for external code that wants to query DeviceFS feature availability.
    build/c/usbmodule, build/c/ehcimodule, build/c/ohcimodule - Updated USBDriver_RegisterBus SWI and the code that calls it to pass the API version number (as defined in usbdivar.h) to USBDriver when attempting to reigster the bus. USBDriver then ensures the version matches that of itself, and if not refuses to allow the bus to register. EHCI & OHCI modules also check that USBDriver is new enough to implement this behaviour via the USBDriver_Version SWI.
  And finally:
    build/version - Incremented module version numbers.
    build/doc/usb - Updated with details of new features
Admin:
  Tested in ROM softload on Iyonix & beagleboard. Beagleboard hub issues seem to be resolved, and there are no new bugs that I can see.


Version 0.52. Tagged as 'NetBSD-0_52'
@
text
@d351 1
a806 5
void riscos_irqclear()
{
    _swix(OS_Hardware, _IN(0)|_INR(8,9), device_number, 0, EntryNo_HAL_IRQClear);
}

@


1.14
log
@Fix EHCIDriver & OHCIDriver to sync the caches properly when setting up assembler veneers
Detail:
  init_veneer and build_veneer weren't calling OS_SynchroniseCodeAreas to properly sync the I+D caches after writing the assembler veneers to RMA. In some cases this was causing random crashes on boot. This should now be fixed.
Admin:
  Tested on rev C2 beagleboard


Version 0.49. Tagged as 'NetBSD-0_49'
@
text
@d68 1
a68 1
struct device * usb_soft;
d145 15
a159 17

//_kernel_oserror* bus_register (_kernel_swi_regs* r, void* pw, void* h)
//{
//    /* register with the usbdriver module if it's already resident */
//    dprintf (("", "Registering with USB driver\n"));
//
//    memset (&ehci_soft, 0, sizeof ehci_soft);
//    sprintf (ehci_soft.sc_bus.bdev.dv_xname, "EHCI%d", instance);
//    /* fix n companions */
//    ehci_soft.sc_ncomp = 2;
//    ehci_init (&ehci_soft);
//
//    _swix (USBDriver_RegisterBus, _IN(0)|_OUT(0),
//            &ehci_soft, &usb_soft);
//
//    return NULL;
//}
d173 9
a181 10

//    memset (&ehci_soft, 0, sizeof ehci_soft);
//    sprintf (ehci_soft.sc_bus.bdev.dv_xname, "EHCI%d", instance);
//    /* fix n companions */
//    ehci_soft.sc_ncomp = 2;
//    ehci_init (&ehci_soft);

    _swix (USBDriver_RegisterBus, _IN(0)|_OUT(0),
            &ehci_soft, &usb_soft);
    dprintf (("", "Registering with USB driver-done\n"));
a202 13
#ifdef EHCI_DEBUG
//    struct dev_struct {
//        devicefs_device dev;
//        int null;
//        char name[32];
//    }* dev = NULL;
#endif    






a334 21

//    dev = calloc (sizeof *dev, 1);
//    strcpy (dev->name, ehci_soft.sc_bus.bdev.dv_xname);
//
//    dev->dev.name_offset = dev->name - (char*) dev;
//    dev->dev.flags = 3;
//    dev->dev.tx_flags = 0x8;
//    dev->dev.tx_buffer_size = 0;
//    dev->dev.rx_flags = 0x8;
//    dev->dev.rx_buffer_size = 1024;
//
//    e = _swix (DeviceFS_Register, _INR (0, 7) | _OUT(0),
//        4,
//        dev,
//        driver_entry,
//        NULL,
//        pw,
//        NULL,
//        INT_MAX, // XXX should be -1, but that doesn't seem to work
//        INT_MAX,
//        &irq_device);
d421 10
a430 11




             dprintf (("", "Registering with USB driver from svcecall\n"));
                    _swix (USBDriver_RegisterBus, _IN(0)|_OUT(0),
                             &ehci_soft, &usb_soft);
             dprintf (("", "Registering with USB driver from svcecall-done\n"));



@


1.13
log
@Add workaround for incorrect sizeof(usb_status_t), disable debug_set_stamp_debug(TRUE) to fix interrupt issue
Detail:
  build/c/ehcimodule, build/c/ohcimodule, build/c/usbmodule - Make sure that timestamped debug messages aren't used, as they appear to cause interrupts to be briefly enabled, which causes all kinds of problems in sensitive bits of the code.
  dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/h/usb - Because DISABLE_PACKED is being used to compile the USB drivers, sizeof(usb_status_t) was being calculated as 4 bytes instead of 2. Somehow this works fine with the EHCI driver (and presumably the OHCI driver), but it was causing problems with the MUSBDriver, so a hardcoded size of 2 is now used.
Admin:
  Tested on rev C2 beagleboard.


Version 0.48. Tagged as 'NetBSD-0_48'
@
text
@d131 3
@


1.12
log
@Add support for HAL enumerated USB EHCI controllers, use HAL_IRQClear when clearing EHCI/OHCI controller interrupts
Detail:
  * HAL enumeration of EHCI controllers is performed in the same manner as for OHCI, and protected by #ifdef RHENIUM. HAL_USBControllerInfo must return with the usbinfo type field set to 1 to indicate EHCI.
  * HAL_IRQClear is now called by the EHCI & OHCI modules after clearing the interrupt flag in the USB controller, to allow the HAL to reset the interrupt controller if required (e.g. for OMAP3)
  * EHCI module (for HAL EHCI controllers) now has the option of forcing all EHCI register access to be 32bit size & alignment (requirement is indicated in OMAP3 TRM, although USB did seem to function fine without)
  build/c/ehcimodule - Add enumeration of HAL USB controllers. Add support for forcing all EHCI register access to be 32bit size & alignment. Add riscos_irqclear() implementation. Guard against unexpected behaviour if PCI module isn't present.
  build/c/ohcimodule - Add riscos_irqclear() implementation. Guard against unexpected behaviour if PCI module isn't present.
  dev/usb/c/ehci, dev/usb/c/ohci - call riscos_irqclear() when appropriate
  dev/usb/h/usb_port - riscos_irqclear() prototype
Admin:
  Tested on rev C2 beagleboard. Untested on Iyonix, but should be fine.


Version 0.47. Tagged as 'NetBSD-0_47'
@
text
@d225 2
a226 1
    debug_set_device(PRINTF_OUTPUT);
d228 2
a229 1
    /* cannot debug_set_stamp_debug (TRUE).. get stack overflow!!!  */
@


1.11
log
@	Update of NetBSD elements (except c.ohci) to track NetBSD current
	from mid April 2005.
	Inclusion of Mods to c.ehci (from Dan) to correctly handle low
	speed interrupt devices beyond USB2 hubs (i.e. keyboards and mice).
	Mod to EHCI resetting in service call handler to better cope with
	USBDriver being restarted 'underneath' it.
Detail:
Admin:
	Castle, Dan Ellis, NetBSD added IP. Tested at Castle. Will be
	beta tested at this revision level before full release.


Version 0.39. Tagged as 'NetBSD-0_39'
@
text
@d138 5
d224 2
a225 2
    debug_set_device(DEBUGIT_OUTPUT);
//    debug_set_device(PRINTF_OUTPUT);
d272 29
d314 1
d316 23
a338 16
    /* now establish our interrupt and address */

    e = _swix(PCI_ReadInfo, _INR(0,3),
        PCI_ReadInfo_IntDeviceVector,
        &device_number,
        sizeof device_number,
        pci_device);
    if (e) goto error;

    dprintf (("Main_0", "interrupt device %d\n", device_number));

    e = _swix(PCI_HardwareAddress, _INR(0,1)|_IN(3)|_OUT(4),
        0, 0, pci_device, &ehci_base);
    if (e) goto error;

    dprintf (("Main_0", "hardware address %p\n", ehci_base));
d523 1
a523 1
	       EHCI_USBSTS, EOREAD4(sc, EHCI_USBINTR),
d651 1
a651 1
    ehci_base[o/4] = x;
d660 1
a660 1
    return ehci_base[o/4];
d669 12
a680 1
    ((uint16_t*) ehci_base)[o/2] = x;
d687 6
d694 11
a704 1
            ((uint16_t*)ehci_base)[o/2], ((uint16_t*)ehci_base) + o/2));
d706 1
a706 1
    return ehci_base[o/4];
d715 12
a726 1
    ((uint8_t*) ehci_base)[o] = x;
d733 6
d741 5
d839 4
@


1.10
log
@        An increased delay caused havoc with chicony keyboards in the field
Detail:
        USB_PORT_RESET_DELAY had been increased from 100 to 200ms in previous
        version. This was OK for most devices, and beneficial for some, BUT
        killed the Chicony keyboards shipped with many iyonix.. Delay has
        been reverted to 100ms, and is now run time alterable via the
        USB$PortResetDelay sysvar. This problem did not show up in beta testing!

Admin:  tested by JB with chicony.. delays up to around 160ms work with
        the chicony.
        Castle added IP

Version 0.36. Tagged as 'NetBSD-0_36'
@
text
@d431 2
@


1.9
log
@         changes and bug fixes that came to light following USB2 launch.
Detail:
         - VarVal launching.. string length was incorrectly calculated.
         - USB VarVals now correctly cleared if device failed during
           enumeration, after first SetVarVal call.
         - Triggercbs() modified to check interrupt context and be
           refuse (quietly) to trigger callbacks if interrupts threaded
           (result of possible issue .. but perhaps wise)
         - Added third QueryDelay variable, and an Info file to describe
           what does what.
Admin:
         checked at Castle.. due for extended check via beta test site
         before formal release.

         Castle + D Ellis added IP


Version 0.35. Tagged as 'NetBSD-0_35'
@
text
@d59 1
a59 1
int irq_buf;
d584 8
a591 8
        if (irq_buf)
        {
            _swix (OS_CallAVector, _INR(1,3)|_IN(9),
                irq_buf | (1<<31),
                (int [2]) { gettime () / 1000 - irq0, t},
                8,
                20);
        }
@


1.8
log
@Summary:  Minor tweaks to USBDriver and EHCI prior to USB2 release
          resulting from beta testing
Detail:
Admin:    castle and d ellis added IP beyond that in NetBSD sources


Version 0.34. Tagged as 'NetBSD-0_34'
@
text
@d168 5
a172 5
    memset (&ehci_soft, 0, sizeof ehci_soft);
    sprintf (ehci_soft.sc_bus.bdev.dv_xname, "EHCI%d", instance);
    /* fix n companions */
    ehci_soft.sc_ncomp = 2;
    ehci_init (&ehci_soft);
a297 3
    memset (&ehci_soft, 0, sizeof ehci_soft);

    sprintf (ehci_soft.sc_bus.bdev.dv_xname, "EHCI%d", instance);
d338 4
d603 1
a603 1
#ifdef EHCI_DEBUG
d612 1
a612 1
#ifdef EHCI_DEBUG
d621 1
a621 1
#ifdef EHCI_DEBUG
d630 1
a630 1
#ifdef EHCI_DEBUG
d640 1
a640 1
#ifdef EHCI_DEBUG
d649 1
a649 1
#ifdef EHCI_DEBUG
@


1.7
log
@        Stack brought up to date with NetBSD sources as at 20050121.
        USB2 further debugged.
Detail:
        Check in prior to second beta release. Improvements also to
        softloading of replacement modules.
Admin:
        Checked with JB .. further crosschecking is still needed for rhenium.
        Castle/D Ellis added ip from NetBSD sources


Version 0.33. Tagged as 'NetBSD-0_33'
@
text
@d199 5
a203 5
    struct dev_struct {
        devicefs_device dev;
        int null;
        char name[32];
    }* dev = NULL;
d447 1
d541 1
a541 1

@


1.6
log
@       improved module startup sequence independance, and added
       service-prereset to
       the ehcimodule. modules in beta test in field
Detail:
Admin:
       castle added ip.  still to be tested on rhenium


Version 0.32. Tagged as 'NetBSD-0_32'
@
text
@d155 1
a155 1
_kernel_oserror* new_instance (_kernel_swi_regs* r, void* pw)
d161 1
d220 1
d222 2
d243 7
a249 1
        pci_device = atoi (cmd_tail);
d260 1
a260 6
//    /* quick bodge */
//    if (pci_device == 10)
//    {
//        pci_device = 13;
//    }
//    else
d262 7
a268 8
        e = _swix(PCI_FindByClass, _INR(0,1)|_IN(3)|_OUT(3),
            0x0C0320,
            0xFFFFFF,
            pci_device,
            &pci_device);
        if (e) return e;
    } while (0);//pci_device == 2 || pci_device == 3);

d278 1
a278 1
    dprintf (("Main_0", "Found EHCI controller on device %d\n", pci_device));
d308 20
a327 20
    dev = calloc (sizeof *dev, 1);
    strcpy (dev->name, ehci_soft.sc_bus.bdev.dv_xname);

    dev->dev.name_offset = dev->name - (char*) dev;
    dev->dev.flags = 3;
    dev->dev.tx_flags = 0x8;
    dev->dev.tx_buffer_size = 0;
    dev->dev.rx_flags = 0x8;
    dev->dev.rx_buffer_size = 1024;

    e = _swix (DeviceFS_Register, _INR (0, 7) | _OUT(0),
        4,
        dev,
        driver_entry,
        NULL,
        pw,
        NULL,
        INT_MAX, // XXX should be -1, but that doesn't seem to work
        INT_MAX,
        &irq_device);
d353 2
a354 1
    _swix (OS_AddCallBack, _INR(0,1), new_entry, pw);
d368 1
d370 2
a371 5


    if (usb_soft != NULL)
        _swix (USBDriver_DeRegisterBus, _IN(0), usb_soft);

d373 3
a375 2
     EOWRITE4(&ehci_soft, EHCI_USBCMD, EHCI_CMD_HCRESET);
     EOREAD4(&ehci_soft, EHCI_USBCMD);/* flush the command */
d422 1
a422 1
             return;
d430 4
a433 3
             return;
           default:return;
         }  
d437 1
d440 2
a441 2
        return;
      default:return;
d699 1
d746 18
a763 18
#ifdef EHCI_DEBUG

_kernel_oserror* driver (_kernel_swi_regs* r, void* pw)
{
    switch (r->r[0])
    {
    case DeviceFSCallDevice_Terminate:
        irq_buf = 0;
        break;
    case DeviceFSCallDevice_StreamCreated:
        irq_buf = r->r[3];
        break;
    }

    return NULL;
}

#endif
@


1.5
log
@        Update of EHCIDriver to current NetBSD, together with needed changes
        in both OHCIDriver and USBDriver.


Detail:
        Code may change before formal release .. will be beta released
        ... Entered to CVS to get new version numbers, and for
        the record.
Admin:
        Castle/netbsd added IP .. will be tested more fully before
        formal release. Still to be verified on Rhenium.


Version 0.31. Tagged as 'NetBSD-0_31'
@
text
@d34 1
d70 1
d138 16
a153 17
_kernel_oserror* bus_register (_kernel_swi_regs* r, void* pw, void* h)
{
    /* register with the usbdriver module if it's already resident */
    dprintf (("Main_0", "Registering with USB driver\n"));

        memset (&ehci_soft, 0, sizeof ehci_soft);
        sprintf (ehci_soft.sc_bus.bdev.dv_xname, "EHCI%d", instance);
        /* fix n companions */
        ehci_soft.sc_ncomp = 2;
        ehci_init (&ehci_soft);


    _swix (USBDriver_RegisterBus, _IN(0)|_OUT(0),
            &ehci_soft, &usb_soft);

    return NULL;
}
d165 12
a176 1
    bus_register(NULL,NULL,NULL);
d182 1
a182 1
    dprintf (("Main_0", "Trying to start %s\n", name));
d241 7
d250 6
a255 6
    /* quick bodge */
    if (pci_device == 10)
    {
        pci_device = 13;
    }
    else
d345 1
a345 1
    dprintf (("Main_0", "Finished module initialisation\n"));
d354 1
a354 1
    dprintf (("Failed initialisation: %s\n", e->errmess));
d361 4
a364 6
    volatile int* eb = ehci_base;
    int v;
    _swix (OS_Hardware, _IN(0) | _INR(8,9),
        device_number, 0, EntryNo_HAL_IRQDisable);
    _swix (OS_ReleaseDeviceVector, _INR(0,4),
        device_number | (1u<<31), usb_irq_entry, pw, 0, 0);
d370 2
a371 3
     eb[EHCI_USBCMD/4]= 0;	/* Halt controller */
     eb[EHCI_USBCMD/4]= EHCI_CMD_HCRESET;
     v=eb[EHCI_USBCMD/4];       /* flush the command */
d373 4
d380 3
d385 7
d397 5
a401 3
    switch (r->r[0]) {
    case Service_USBDriver_Starting:
        if (usb_soft == NULL)
d403 3
a405 1
            dprintf (("Main_0", "Registering with USB driver from svcecall\n"));
d407 2
a408 1

d410 26
a435 11
              callx_add_callback (bus_register, 0);
        }
        break;
    case Service_USBDriver_Dying:
        dprintf (("", "Deregistering with USB driver\n"));
        /* USBDriver will do the deregistering at this point, since
           it's SWIs are not active anymore */
        ehci_detach(&ehci_soft,0);
        ehci_shutdown(&ehci_soft);
        usb_soft = NULL;
        break;
d557 1
a557 1
    ehci_softc_t* sc = &ehci_soft;
@


1.4
log
@       change to OHCIModule to pay heed to number of OHCI i/f reported
       by HAL (in Rhenium).. various other small adjustments to improve
       softloadability, both in OHCI and EHCI drivers.
Detail:
Admin:
    tested on iyonix and on rhenium
    castle added IP


Version 0.30. Tagged as 'NetBSD-0_30'
@
text
@d45 5
d75 25
d160 3
d181 2
d185 14
a198 1

d285 1
a285 5
    struct dev_struct {
        devicefs_device dev;
        int null;
        char name[32];
    }* dev = calloc (sizeof *dev, 1);
d342 2
a343 2
    if (magic) _swix (OS_Module, _IN(0)|_IN(2), 7, magic);

d352 5
d360 1
d372 3
d394 4
a397 1
    switch (cmd_no) {
d485 11
d643 28
d686 1
@


1.3
log
@  Extensive changes and bug fixes to usb and ohci ..
  'blocked' several holes that could cause freezes with awkward
  usb devices.  Added latest changes from Dan Ellis too , especially for USB2
Detail:
 many
Admin:
 Tested in ROM at Castle, and beta tested with users


Version 0.28. Tagged as 'NetBSD-0_28'
@
text
@d110 8
d163 2
a164 2
    /* simulate having one OHCI device attached.  This section has to
    communicate with HAL or podule manager to find out where it can read/write    to some OHCI registers */
d199 1
a199 1
    /* if there were no more OHCI controllers, then return an error.  This
d329 2
a331 3
        memset (&ehci_soft, 0, sizeof ehci_soft);
        sprintf (ehci_soft.sc_bus.bdev.dv_xname, "OHCI%d", instance);
        ehci_init (&ehci_soft);
@


1.2
log
@  New versions from John.
Detail:
  * All modules will now rmkill/rmload more reliably
  * Keyboard driver disables kernel debounce on new enough kernels, needed
    for many PS2-USB adaptors, bar code scanners etc
  * Mouse driver will scroll wheel scroll any windows that do respond to
    scroll events, otherwise it issues PointerReason_WheelChange (9) to an
    external WimpScroll module
  * Several bugs and an interrupt hole resolved
Admin:
  Tested at Framlingham.

Version 0.25. Tagged as 'NetBSD-0_25'
@
text
@d54 1
d106 10
d122 2
d146 4
a149 1
    debug_initialise ("EHCIDriver", 0, 0);
a272 4
    /* register with the usbdriver module if it's already resident */
    dprintf (("Main_0", "Registering with USB driver\n"));
    _swix (USBDriver_RegisterBus, _IN(0)|_OUT(0),
            &ehci_soft, &usb_soft);
d313 2
a314 3
            dprintf (("Main_0", "Registering with USB driver\n"));
            _swix (USBDriver_RegisterBus, _IN(0)|_OUT(0),
                &ehci_soft, &usb_soft);
@


1.1
log
@Merge of Dan Ellis's USB2 sources.

Version 0.22. Tagged as 'NetBSD-0_22'
@
text
@d308 2
a309 1
        _swix (USBDriver_DeRegisterBus, _IN(0), usb_soft);
@


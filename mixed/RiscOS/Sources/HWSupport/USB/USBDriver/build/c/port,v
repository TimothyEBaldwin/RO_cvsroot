head	1.24;
access;
symbols
	USBDriver-1_29:1.24
	USBDriver-1_28:1.24
	USBDriver-1_27:1.24
	USBDriver-1_26:1.24
	USBDriver-1_25:1.24
	USBDriver-1_24:1.24
	USBDriver-1_23:1.24
	USBDriver-1_22:1.23
	USBDriver-1_21:1.23
	USBDriver-1_20:1.23
	USBDriver-1_19:1.22
	NetBSD-1_19:1.22
	NetBSD-1_18:1.22
	NetBSD-1_17:1.21
	NetBSD-1_16:1.21
	NetBSD-1_15:1.21
	NetBSD-1_14:1.21
	NetBSD-1_13:1.21
	NetBSD-1_12:1.20
	NetBSD-1_09-1:1.19
	NetBSD-1_11:1.19
	NetBSD-1_10:1.19
	NetBSD-1_09:1.19
	NetBSD-1_08:1.19
	NetBSD-1_07:1.19
	NetBSD-1_06:1.19
	NetBSD-1_05:1.19
	NetBSD-1_04:1.19
	NetBSD-1_03:1.19
	NetBSD-1_02:1.19
	NetBSD-1_01:1.19
	NetBSD-1_00:1.19
	NetBSD-0_99:1.19
	NetBSD-0_98:1.19
	NetBSD-0_97:1.19
	NetBSD-0_96:1.18
	NetBSD-0_95:1.18
	NetBSD-0_94:1.18
	NetBSD-0_93:1.18
	NetBSD-0_92:1.18
	NetBSD-0_91:1.18
	NetBSD-0_90:1.18
	NetBSD-0_89:1.18
	NetBSD-0_88:1.18
	NetBSD-0_87:1.18
	NetBSD-0_86:1.18
	NetBSD-0_85:1.18
	NetBSD-0_84:1.18
	NetBSD-0_83:1.18
	NetBSD-0_82:1.17
	NetBSD-0_81:1.17
	NetBSD-0_80:1.17
	NetBSD-0_79:1.17
	NetBSD-0_78:1.17
	NetBSD-0_77:1.17
	NetBSD-0_76:1.17
	NetBSD-0_75:1.17
	NetBSD-0_74:1.17
	NetBSD-0_73:1.17
	NetBSD-0_72:1.17
	NetBSD-0_71:1.16
	NetBSD-0_70:1.16
	NetBSD-0_69:1.16
	NetBSD-0_68:1.16
	NetBSD-0_67:1.16
	NetBSD-0_66:1.16
	NetBSD-0_65:1.16
	NetBSD-0_64:1.16
	NetBSD-0_63:1.16
	NetBSD-0_62:1.16
	NetBSD-0_61:1.16
	NetBSD-0_60:1.16
	NetBSD-0_59:1.15
	NetBSD-0_58:1.14
	NetBSD-0_57:1.14
	NetBSD-0_56:1.14
	NetBSD-0_55:1.14
	NetBSD-0_54:1.14
	NetBSD-0_53:1.14
	NetBSD-0_52:1.14
	NetBSD-0_51:1.13
	NetBSD-0_50:1.13
	NetBSD-0_49:1.13
	NetBSD-0_48:1.13
	NetBSD-0_47:1.13
	NetBSD-0_46:1.13
	NetBSD-0_45:1.13
	NetBSD-0_44:1.13
	NetBSD-0_43:1.13
	NetBSD-0_42:1.13
	NetBSD-0_41:1.13
	NetBSD-0_40:1.13
	NetBSD-0_39:1.13
	NetBSD-0_38:1.13
	NetBSD-0_37:1.13
	NetBSD-0_36:1.13
	NetBSD-0_35:1.13
	NetBSD-0_34:1.12
	NetBSD-0_33:1.11
	NetBSD-0_32:1.10
	NetBSD-0_31:1.10
	NetBSD-0_30:1.9
	NetBSD-0_29:1.8
	RO_5_07:1.8
	NetBSD-0_28:1.8
	NetBSD-0_27:1.7
	NetBSD-0_26:1.7
	NetBSD-0_25:1.6
	NetBSD-0_24:1.5
	NetBSD-0_23:1.5
	NetBSD-0_21-1_22_2_1:1.4.2.1
	NetBSD-0_22:1.5
	USB1:1.4.0.2
	NetBSD-0_21:1.4
	NetBSD-0_20:1.4
	NetBSD-0_19:1.4
	NetBSD-0_18:1.4
	NetBSD-0_17:1.4
	NetBSD-0_16:1.4
	NetBSD-0_15:1.4
	NetBSD-0_14:1.4
	NetBSD-0_13:1.4
	NetBSD-0_12:1.4
	NetBSD-0_11:1.4
	NetBSD-0_10:1.4
	NetBSD-0_09:1.4
	NetBSD-0_08:1.4
	NetBSD-0_07:1.3
	NetBSD-0_06:1.3
	NetBSD-0_05:1.3
	NetBSD-0_04:1.2
	NetBSD-0_03:1.2
	NetBSD-0_02:1.2
	NetBSD-0_01:1.1;
locks; strict;
comment	@# @;


1.24
date	2017.10.07.09.08.41;	author rool;	state Exp;
branches;
next	1.23;
commitid	Qzw5gnXY6CB2g6aA;

1.23
date	2017.07.30.11.37.13;	author rool;	state Exp;
branches;
next	1.22;
commitid	0fHS8wSWQgNvif1A;

1.22
date	2016.12.17.10.12.57;	author rool;	state Exp;
branches;
next	1.21;
commitid	yws6HYEy6os04kyz;

1.21
date	2016.05.02.19.14.51;	author rsprowson;	state Exp;
branches;
next	1.20;
commitid	Yalf9VtEPIFjqW4z;

1.20
date	2016.03.26.23.15.27;	author jlee;	state Exp;
branches;
next	1.19;
commitid	ec4yF5CmJMfyWc0z;

1.19
date	2015.08.14.22.22.23;	author jlee;	state Exp;
branches;
next	1.18;
commitid	NGdbu548pV9NShxy;

1.18
date	2014.05.06.20.37.21;	author rsprowson;	state Exp;
branches;
next	1.17;
commitid	mvJ8HKiFqZQsfwzx;

1.17
date	2012.06.24.21.55.29;	author jlee;	state Exp;
branches;
next	1.16;
commitid	4v309enDleTpz0aw;

1.16
date	2011.08.05.00.10.42;	author jlee;	state Exp;
branches;
next	1.15;
commitid	jZdApF1uaRruLfuv;

1.15
date	2011.05.22.20.22.34;	author jlee;	state Exp;
branches;
next	1.14;
commitid	Ye1jVWDlKivFSIkv;

1.14
date	2010.07.21.23.57.10;	author jlee;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.18.00.35.56;	author jballance;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.31.13.45.35;	author jballance;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.21.22.30.19;	author jballance;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.30.02.34.17;	author jballance;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.25.00.54.52;	author jballance;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.12.14.47.39;	author jballance;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.30.14.50.35;	author kbracey;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.06.15.50.22;	author bavison;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.21.20.49.15;	author bavison;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.02.17.05.51;	author rsprowson;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2003.02.07.22.29.45;	author dellis;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.28.10.25.50;	author dellis;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.28.09.55.14;	author dellis;	state Exp;
branches;
next	;

1.4.2.1
date	2004.02.16.15.38.42;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Clear up duplicate/unused OHCI/EHCI source files
Detail:
  Remove the (now) unused sources from when this component produced multiple targets. See Controllers/OHCIDriver & Controllers/EHCIDriver for the live copies.
  Remove unset USBHAL defines.
  Simplify the Makefile and !Mk* scripts.
  No longer export usbroothub_subr.h.
  Add a porting type "device_t" to usb_port.h.
Admin:
  Submission for USB bounty.

Version 1.23. Tagged as 'USBDriver-1_23'
@
text
@/* Copyright 2003 Tematic Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stddef.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdarg.h>

#include "DebugLib/DebugLib.h"
#include "callx/callx.h"
#include "swis.h"
#include "sys/callout.h"
#include "sys/time.h"
#include "Global/HALEntries.h"
#include "Global/OSMisc.h"
#include <sys/types.h>
#include "dev/usb/usb_port.h"

#ifdef USB_DEBUG
extern int usbdebug;
int total_sleep;
#endif


extern void detach_hub (struct device*);
extern void detach_device (struct device*);

extern uint32_t hal_veneer2(uint32_t (*)(void), void*, ...);
extern uint64_t gettime (void);

uint64_t gettime (void)
{
    uint32_t cs;
    static uint32_t (*readcode) (void);
    static void* ws;
    static uint32_t ns_factor;
    static uint32_t max_count;
    if (readcode == NULL)
    {
        _swix (OS_Hardware, _INR(8,9)|_OUTR(0,1),
            1, EntryNo_HAL_CounterRead,
            &readcode, &ws);

        _swix (OS_Hardware, _INR(8,9)| _OUT(0),
            0, EntryNo_HAL_CounterPeriod,
            &max_count);

#if 0 // fixed in RISC OS 5.03
        /* bug here - force 2000000 */
        max_count = 2000000;
#endif

        /* conversion to ns, assume counter is for 1 cs */
        ns_factor = 10000000 / max_count;
    }

    _swix (OS_ReadMonotonicTime, _OUT(0), &cs);
    return (uint64_t) (max_count - hal_veneer2(readcode,ws)) * ns_factor +
        ((uint64_t) cs) * 10000000 /* 1e7 */;
}

/* turn off cold starting */
int cold = 0;

int hz = 1000;

/* disable interrupt for input */
int spltty (void)
{
    return _kernel_irqs_disabled ();
}

void splx (int s)
{
    if (s == 0) _kernel_irqs_on ();
//    dprintf (("", "int on\n"));
}

int splbio (void)
{
    int s = _kernel_irqs_disabled ();
    _kernel_irqs_off ();
//    dprintf (("", "int off\n"));
    return s;
}


char panic_string[255];

void panic (const char* str, ...)
{
    va_list p;
    va_start (p, str);
    /* aargh! */
    dprintf (("Port", "panicking:"));
    dvprintf (("Port", str, p));
    vsnprintf(panic_string, sizeof panic_string, str, p);
    va_end (p);
}

void
delay (int d)
{
#ifdef USB_DEBUG0
    if (usbdebug > 19)
    {
        time_t t;
        time (&t);
        dprintf (("Port", "wait for %dus at %s", d, ctime(&t)));
    }
#endif
    _swix (OS_Hardware, _IN(0)|_INR(8,9), d, 0, EntryNo_HAL_CounterDelay);
}

void
selrecord(struct proc *selector, struct selinfo *selinfo)
{
    dprintf (("Port", "selecting record\n"));
}

void
selwakeup(struct selinfo *selinfo)
{
    dprintf (("Port", "selwakeup called\n"));
}

typedef int devclass_t;

void*
devclass_get_softc (devclass_t dc, int unit)
{
    return 0; /* TODO make this return something that won't make it crash.. */
}

int
config_deactivate (struct device* dev)
{
    dprintf (("Port", "deactivating device\n"));
    return 0;
}

struct uio;

int
uiomove(caddr_t poo, int wobble, struct uio * fred)
{
    dprintf (("Port", "uiomove\n"));
    return 0;
}

void
psignal(unsigned sig, const char *s) {
    dprintf (("Port", "wow - we've received signal %d: %s\n", sig, s));
}

/*
 * Callouts
 */
extern int private_word;

void
callout_init (struct callout* c,int ignored)
{
    (void)ignored;
#ifdef USB_DEBUG0
    if (usbdebug > 15) dprintf (("Port", "callout init %p\n", c));
#endif
    memset (c, 0, sizeof (*c));
}

_kernel_oserror*
callout_handler (_kernel_swi_regs* r, void* pw, void* _c) {
    struct callout* c = _c;
#ifdef USB_DEBUG0
    if (usbdebug > 15) dprintf (("Port", "callout2 %p called\n", c));
#endif
    if(c->c_func)c->c_func (c->c_arg);
    return NULL;
}

void
callout_stop (struct callout *c) {
#ifdef USB_DEBUG0
    if (usbdebug > 15) dprintf (("Port", "callout stop %p\n", c));
#endif
    callx_remove_callafter (callout_handler, c);
}

void
callout_reset (struct callout *c, int i, void (*f)(void *), void *v) {
    if (i <= 0) i = 1;
    c->c_arg = v;
    c->c_func = f;
#ifdef USB_DEBUG0
    if (usbdebug > 15) dprintf (("Port", "callout %p reset %dms\n", c, i));
#endif
    callx_add_callafter ((i + 9) / 10, callout_handler, c);
}

int kthread_create (void (f) (void*), void* h) {
    (void) f;
    (void) h;
//    dprintf (("Port", "creating thread\n"));

    return 0;
}

int kthread_create1 (void (f) (void*), void* a, void* b, char* c, char* d)
{
    (void) f;
    (void) a;
    (void) b;
    (void) c;
    (void) d;

    return 0;
}

void* t_handles[100];
int t_locks[100];
int nhandles = 0;

extern void triggercbs (void);
extern int *get_ptr_IRQsema(void);

int tsleep (void* ident, int priority, const char* wmesg, int timo, int noblock)
{
    int i;
    int s = _kernel_irqs_disabled ();
    uint64_t t0, t1, t2;

    _kernel_irqs_off ();                       // lets play safe

    t1 = t0 = gettime();
    t1 += ((uint64_t) timo) * 1000000;
#ifdef USB_DEBUG

    int sema = *get_ptr_IRQsema();
    char bbf[32];strncpy( bbf, wmesg, 31);bbf[31]=0;
    dprintf(("","enter sleep:%s                  irqstate:%d\n",bbf,sema));
#endif

#ifdef USB_DEBUG0
    int cs0, cs1;
    _swix (OS_ReadMonotonicTime, _OUT(0), &cs0);
    if (usbdebug > 19)
        dprintf (("Port", "%s sleeping on %p at priority %d for %dms\n"
                      "from %lu.%.09lu\n"
                      "til  %lu.%.09lu\n",
            wmesg, ident, priority, timo,
            (uint32_t) (t0 / 1000000000), (uint32_t) (t0 % 1000000000),
            (uint32_t) (t1 / 1000000000), (uint32_t) (t1 % 1000000000)));
#endif

    for (i = 0; i < nhandles && t_handles[i] && t_handles[i] != ident; ++i);

    if (i == nhandles) {
        nhandles = i + 1;
        if (nhandles >= sizeof t_handles / sizeof *t_handles)
        {
            if (s == 0) _kernel_irqs_on ();
            panic ("run out of thread handles...");
            return 1;
        }
    }

    t_handles[i] = ident;
    t_locks[i] = 0;

    /* wait until the lock is free */
    _kernel_irqs_on ();

    if (timo) {
        do {
            triggercbs ();
            t2 = gettime ();
        }
        while ((t_locks[i] == 0) && (t2 < t1));
    }
    else
    {
        while (t_locks[i] == 0)
        {
            triggercbs ();
        }
#ifdef USB_DEBUG0
        t2 = gettime ();
#endif
    }
    _kernel_irqs_off ();

    t_handles[i] = 0;

#ifdef USB_DEBUG0
    if (usbdebug > 19)
      dprintf (("", "now  %lu.%09lu\n",
        (uint32_t) (t2 / 100000000), (uint32_t) (t2 % 1000000000)));
    t2 -= t0;
    _swix (OS_ReadMonotonicTime, _OUT(0), &cs1);
    total_sleep += cs1 - cs0;
    if (usbdebug > 10)
        dprintf (("", "slept for %lu.%.09lu seconds (timo = %dms), %d cs\n",
            (uint32_t) (t2 / 100000000), (uint32_t) (t2 % 1000000000),
            timo, cs1 - cs0));
#endif
#ifdef USB_DEBUG
    dprintf(("","leave sleep:%s                  irqstate:%d\n",bbf,sema));
#endif

    if (s == 0) _kernel_irqs_on ();

    return 0;
}

int wakeup (void* ident) {
    int i;
#ifdef USB_DEBUG0
    if (usbdebug > 10) dprintf (("", "waking up %p\n", ident));
#endif

    /* Find the index of the handle passed */
    for (i = 0; i < nhandles && t_handles[i] != ident; ++i);

    /* unlock it */
    if (t_handles[i] == ident)
    {
      t_locks[i] = 1;
      t_handles[i] =NULL;
    }  
    return 0;
}

int kthread_exit (int status) {
//    dprintf (("Port", "exit thread\n"));
    return 0;
}

void device_probe_and_attach (void) {
//    dprintf (("Port", "probing device\n"));
}

/*
 * usbd_ratecheck() can limit the number of error messages that occurs.
 * When a device is unplugged it may take up to 0.25s for the hub driver
 * to notice it.  If the driver continuosly tries to do I/O operations
 * this can generate a large number of messages.
 */
int
ratecheck (void* a, void* b)
{
    return 0;
}

void* usbd_print;

int vtophys (void* v)
{
#ifndef EMULATE
    struct {
        int     page;
        void*   logical;
        int     physical;
    } block;
    block.logical = v;
    _swix (OS_Memory, _INR (0, 2), (1<<9) + (1<<13), &block, 1);

    return block.physical;
#else
//    dprintf (("Port", "Converting physical address %p\n", *v));
    return v; // return actual address for the moment
#endif
}

void* malloc_contig(int len, int alignment)
{
    void* p;
    _kernel_oserror* e;

    e = _swix(PCI_RAMAlloc, _INR(0,2)|_OUT(0), len, alignment, 0, &p);
    if (e || !p)
    {
        dprintf (("", "failed to allocate %d bytes at %d alignment err = '%s'\n",
            len, alignment, e?e->errmess:""));

        return NULL;
    }

    memset(p, 0, len);

    return p;
}

void free_contig (void **mem)
{
    _swix(PCI_RAMFree, _IN(0), *mem);
}

char*
device_get_nameunit (void)
{
    return "Root device";
}

#ifdef logprintf
#undef logprintf
#endif
void logprintf (char* format, ...)
{
    va_list p;
    va_start (p, format);
    dvprintf (("Log", format, p));
    va_end (p);
}

#ifdef USB_USE_SOFTINTR
void* softintr_establish(int pri, void (*f) (void*), void* h)
{
    void** p = malloc (3 * sizeof *p);
    if (p == NULL) return p;

    p[0] = 0;
    p[1] = h;
    p[2] = (void*) f;

    _swix (CBAI_RegisterPollWord, _INR(0, 2), p, pri, private_word);
    return p;
}

//void softintr_schedule (void** p)
//{
//    dprintf (("", "Setting pollword to %p\n", p[2]));
//    p[0] = p[2];
//}

void softintr_disestablish (void* p)
{
    _swix (CBAI_DeregisterPollWord, _IN(0), p);
    free (p);
}
#endif

void riscos_irqclear(int devno)
{
    _swix(OS_Hardware, _IN(0)|_INR(8,9), devno, 0, EntryNo_HAL_IRQClear);
}

static void barriers_init(void);

barrier_func barriers[3] =
{
    barriers_init, /* Lazy approach to initialisation! */
    barriers_init,
    barriers_init,
};

static void barriers_null(void)
{
}

void barriers_init(void)
{
    /* Get the appropriate barrier ARMops */
    if (_swix(OS_MMUControl, _IN(0)|_OUT(0), MMUCReason_GetARMop + (ARMop_DMB_ReadWrite<<8), &barriers[BARRIER_READ+BARRIER_WRITE-1])
     || _swix(OS_MMUControl, _IN(0)|_OUT(0), MMUCReason_GetARMop + (ARMop_DMB_Write<<8), &barriers[BARRIER_WRITE-1])
     || _swix(OS_MMUControl, _IN(0)|_OUT(0), MMUCReason_GetARMop + (ARMop_DMB_Read<<8), &barriers[BARRIER_READ-1]))
    {
        /* Assume any error means we're running on an old OS version, where
           synchronisation isn't necessary */
        barriers[0] = barriers[1] = barriers[2] = barriers_null;
    }
    else
    {
        /* Make sure the initial call actually acts as a sync */
        (barriers[BARRIER_READ+BARRIER_WRITE-1])();
    }
}

@


1.23
log
@Remove OHCIDriver & EHCIDriver as targets
Detail:
  Makefile and !Mk* updated, and corresponding unused files put in the attic.
  Add an interim OHCIHALLib and EHCIHALLib target so that the HAL library variant still builds.
  Split messages into CmdHelp and Messages per a normal C component.
  Remove unused wsconsio/wsmousevar porting headers, no longer used.
Admin:
  Submission for USB bounty.
  Note, the version number of the resulting module will jump to match the top level VersionNum file.

Version 1.20. Tagged as 'USBDriver-1_20'
@
text
@a14 5

/* This is the module version of port.c
   For the HAL version, see usbhal.c and porthal.s
*/

@


1.22
log
@Messages fixes, internationalisation, minor clean ups
Detail:
  USBDriver was performing unnecessary messages file reopening on Service_ResourceFSStarted (MessageTrans does this itself), remove this.
  Internationalised USBDriver, in particular its *Commands.
  Fixed standalone builds to output the messages file objects in the right place (Makefile mistake).
  Changed OHCIDriver and EHCIDriver to use allocated error bases rather than 0.
  Sync'd, where possible, the OHCIDriver and EHCIDriver sources which share a common heritage. Tentative shared interrupt support fixes for non-PCI attached controllers. Comment blocks & indentation improved.
  Export min() macro in usb_port.h.
  CMHG updated to not listen for unwanted services.
Admin:
  Submission for USB bounty.
  Tested on Pandaboard and Pi 2. OHCIDriver untested but low risk.

Version 1.18. Tagged as 'NetBSD-1_18'
@
text
@a177 1
extern void callout_veneer (void);
a211 1
    c->c_next = (void*) private_word; /* hacky thing to get handler to work */
@


1.21
log
@Fix for too short a memset
Found by pattern matching, this is the same change as DWCDriver-0_27.

Version 1.13. Tagged as 'NetBSD-1_13'
@
text
@d421 1
a421 7
    return "OHCI USB device";
}

int min (int a, int b)
{
    if (a < b) return a;
    return b;
@


1.20
log
@Don't pretend to mess with cacheability of pages
Detail:
  build/c/port - Fix vtophys requesting that pages are made uncacheable. They're already uncacheable (all allocated via PCI_RAMAlloc), and once we're done with the pages we never do a 'make cacheable' call to balance it out
  build/Version - Bump version numbers of modules which use vtophys
Admin:
  Untested


Version 1.10. Tagged as 'NetBSD-1_10'
@
text
@d187 1
a187 1
    memset (c, 0, sizeof c);
@


1.19
log
@Add memory barriers
Detail:
  dev/usb/h/usb_port - Implement usb_syncmem to call the appropriate memory barrier function. Required for when PCI_RAMAlloc starts returning Normal, non-cacheable memory rather than Device (although technically these barriers have always been needed for ARMv6+)
  build/c/port - Memory barrier implementation; uses the appropriate OS routine if available, otherwise uses a null op.
  build/Version - Bump EHCIDriver version number (the only module that uses these barriers so far)
Admin:
  Tested on BB-xM, PandaBoard


Version 0.97. Tagged as 'NetBSD-0_97'
@
text
@d385 1
a385 1
    _swix (OS_Memory, _INR (0, 2), (1<<9) + (1<<13) + (2<<14), &block, 1);
@


1.18
log
@Missing va_end()'s added

Version 0.83. Tagged as 'NetBSD-0_83'
@
text
@a22 1
#include <time.h>
d33 3
a145 1
typedef int caddr_t;
d228 1
a228 1
int kthread_create1 (int (f) (void*), void* a, void* b, char* c, char* d)
d353 1
a353 1
void kthread_exit (void) {
d355 1
d376 1
a376 1
void* vtophys (void** v)
d380 1
a380 1
        void*   page;
d382 1
a382 1
        void*   physical;
d430 3
d472 32
@


1.17
log
@Fix null pointer dereferences. Add protection against DeviceFS xfers being multiply inserted into their pipes xfer queue.
Detail:
  build/Version - Increased version numbers
  build/c/ehcimodule, build/c/ohcimodule - Fixed null pointer dereferences in debug code
  build/c/port, build/s/triggercbs - Fix debug code in tsleep() using hardcoded IRQsema ptr. Now requests the right pointer from build/s/triggercbs.
  build/c/usbmodule - Fix null pointer deferences in debug code and MonitorTX/MonitorRX handlers. Add xfer_busy and delayed_read flags to devstream struct in order to track whether the xfer associated with the stream is busy or not. Previously if the TxWakeUp/RxWakeUp device calls were made on a stream which already had an active xfer, the xfer would end up being inserted in the USB pipes xfer queue twice, creating a circular reference, resulting in (at the least) infinite loops in usbd_dump_queue() when debugging is enabled. Now, in the case of reads, a second read will automatically be issued once the first completes, while in the case of writes, the write request will simply be ignored. This isn't a proper fix for all the shortcomings of the DeviceFS interface, but at least the code is now a little bit safer.
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.72. Tagged as 'NetBSD-0_72'
@
text
@d114 1
d433 1
@


1.16
log
@Update to work with zero page relocation. Remove ability to cancel transfers by pressing escape
Detail:
  build/c/port - Removed ability to cancel transfers by pressing escape. Too dangerous for things like mass storage devices, and the code won't work anyway for the common case of being in the wimp
  build/s/triggercbs - Try using OS_ReadSysInfo 6 to get IRQsema ptr before falling back on legacy address
  build/Version - Updated version numbers
Admin:
  Tested on rev A2 BB-xM


Version 0.60. Tagged as 'NetBSD-0_60'
@
text
@d242 1
d256 1
a256 1
    int sema = *(int*)(0x108);
@


1.15
log
@Add the ability to build the USB drivers as HAL-compatible static libraries
Detail:
  build/Makefile, build/OBJEHCIDriver, build/OBJOHCIDriver, build/OBJUSBDriver - Modified makefiles to build the HAL libs during the export libs phase
  build/!MkHAL,fd7 - Handy script for building the HAL libs
  build/Hdr/usbhal - Header containing definitions for the assembler code. Also gets exported so that HALs know how much workspace to reserve.
  build/c/usbhal - HAL version of usbmodule.c & port.c. Also contains the keyboard scan code, adapted from the code in the Tungsten HAL.
  build/s/porthal - Assembler versions of some port.c routines that were easier to do in assembler than C
  build/s/halheap - OS_Heap code that's been adapted for use in the HAL. Could easily be changed into a standalone library instead of being part of the HAL USB libs. Supports memory-efficient allocation of aligned blocks.
  build/c/ehcihal - HAL version of ehcimodule.c. Currently only supports EHCI controllers exposed via HAL_USBControllerInfo (i.e. no PCI support)
  build/c/ehcimodule, build/c/ohcimodule, build/c/port - Moved riscos_irq_clear into port.c. Removed unused microtime() function.
  build/c/usbmouse - Strip out some debug-related code in non-debug builds
  build/Version - Updated version numbers
  dev/usb/c/ehci, dev/usb/h/ehcivar - Adapted to add support for the HAL build. Apart from the base changes, the code has also been tweaked to significantly reduce the amount of memory used at runtime by the HAL version of the driver.
  dev/usb/c/hid, dev/usb/c/uhub, dev/usb/c/usb, dev/usb/c/usb_quirks, dev/usb/c/usb_subr, dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/c/usbroothub_subr - Changes to support HAL builds. Mainly disabling bits that won't work in the HAL or disabling bits for RISC OS in general if they weren't being used in the first place.
  dev/usb/c/ohci, dev/usb/h/ohcivar - Basic changes to support HAL builds. However HAL OHCI support is still incomplete.
  dev/usb/h/usb_port - Added support for the HAL build. Also tweaked logprintf definition to get rid of logprintf calls entirely in non-debug builds.
  dev/usb/h/usbdivar - Added support for the HAL build.
  dev/usb/h/usbhal - New header used by the HAL build. Gets included by every C file to ensure the compiler doesn't use sb, and contains structs/macros to allow access to the shared workspace.
Admin:
  HAL & non-HAL builds tested on rev C2 BB, rev A2 BB-xM, rev C1 TouchBook.
  Non-HAL builds tested with Iyonix ROM softload.
  Needs latest Kernel source for OSEntries.h export.


Version 0.59. Tagged as 'NetBSD-0_59'
@
text
@d288 1
a288 1
    int flags = 0;
a289 1
    _kernel_irqs_on ();
a293 1
            _swix (OS_ReadEscapeState, _OUT(_FLAGS), &flags);
d295 1
a295 1
        while ((t_locks[i] == 0) && (t2 < t1) && ((flags & _C) == 0));
d299 1
a299 1
        while (t_locks[i] == 0 && (flags & _C) == 0)
a300 3
            /* allow foreground process to function while we're waiting */
/*            if (noblock) _swix (OS_UpCall, _INR(0,1), 6, &t_locks[i]);*/
/*//            _swix (OS_UpCall, _INR(0,1), 6, &t_locks[i]);*/
a301 1
            _swix (OS_ReadEscapeState, _OUT(_FLAGS), &flags);
a308 5
    if (flags & _C)
    {
        _kernel_osbyte (126, 0, 0);
    }

@


1.14
log
@Update EHCI driver to NetBSD latest (as of 10/07/2010), improve DeviceFS interface
Detail:
  EHCI driver update:
    dev/usb/c/ehci - Updated to latest NetBSD version, except for revisions 1.134 and 1.135 which are too invasive to merge in without updating the rest of the USB stack. This new version brings lots of bug fixes, and adds (untested on RISC OS) support for EHCI isochronous transfers.
    dev/usb/h/ehcivar - Updated to latest NetBSD version, except for the sc_bus splitting that was held back from the ehci.c update
    dev/usb/h/usb, dev/usb/h/usbdi, dev/usb/usbdivar - partial update to latest as required/possible
    dev/usb/c/usb_quirks, dev/usb/h/ehcireg, dev/usb/h/usb_mem, dev/usb/h/usb_quirks, dev/usb/h/usbhid, dev/usb/usbdevs, dev/usb/devlist2h.awk, dev/wscons/h/wsconsio, dev/wscons/h/wsmousevar - Updated to latest NetBSD versions
    dev/usb/c/usbroothub_subr, dev/usb/h/usbroothub_subr - New files brought in from NetBSD sources for use with new EHCI driver
    build/objehcidriver - Added usbroorhub_subr to EHCI driver
    dev/usb/h/usb_port - Added extra dummy functions as required by new EHCI driver
    dev/build/c/port - Added extra parameter to callout_init as required by new EHCI driver
  DeviceFS improvements:
    build/c/usbmodule - Added DeviceFSCallDevice_GetHandles2 as a replacement for Thomas Milius's backwards-incompatible GetHandles changes. Added DeviceFSCallDevice_GetSetOptions call to control RX padding and TX force-short-xfer features. These features can also be controlled at endpoint creation time by new fields in the filename. Also fixed packet padding to not fill the buffer with garbage or potentially crash when the padded area is more than one packet in length.
  New bus registration API:
    Changes made to the data structures that are shared between the modules means that new checks are needed to ensure USB modules with incompatible APIs are not used with one another.
    build/h/usbdivar - Since this seems to be the file containing the main structures that are shared, it now has a #define at the top indicating the first version of the USBDriver module that implemented the data structures within. This version number is used to check that the driver modules are compatible.
    build/cmhg/usbmodhead, build/h/usbdriver, build/c/usbmodule - Add a new SWI, USBDriver_Version, to return the version number of the USBDriver module. Used for both intra-stack API version checks and can be useful for external code that wants to query DeviceFS feature availability.
    build/c/usbmodule, build/c/ehcimodule, build/c/ohcimodule - Updated USBDriver_RegisterBus SWI and the code that calls it to pass the API version number (as defined in usbdivar.h) to USBDriver when attempting to reigster the bus. USBDriver then ensures the version matches that of itself, and if not refuses to allow the bus to register. EHCI & OHCI modules also check that USBDriver is new enough to implement this behaviour via the USBDriver_Version SWI.
  And finally:
    build/version - Incremented module version numbers.
    build/doc/usb - Updated with details of new features
Admin:
  Tested in ROM softload on Iyonix & beagleboard. Beagleboard hub issues seem to be resolved, and there are no new bugs that I can see.


Version 0.52. Tagged as 'NetBSD-0_52'
@
text
@d15 5
a130 8
microtime(struct timeval *thetime)
{
    uint64_t t = gettime ();
    thetime->tv_sec = (unsigned long) (t / 1000000000);
    thetime->tv_usec = (unsigned long) ((t / 1000) % 1000000);
}

void
d470 5
@


1.13
log
@         changes and bug fixes that came to light following USB2 launch.
Detail:
         - VarVal launching.. string length was incorrectly calculated.
         - USB VarVals now correctly cleared if device failed during
           enumeration, after first SetVarVal call.
         - Triggercbs() modified to check interrupt context and be
           refuse (quietly) to trigger callbacks if interrupts threaded
           (result of possible issue .. but perhaps wise)
         - Added third QueryDelay variable, and an Info file to describe
           what does what.
Admin:
         checked at Castle.. due for extended check via beta test site
         before formal release.

         Castle + D Ellis added IP


Version 0.35. Tagged as 'NetBSD-0_35'
@
text
@d182 1
a182 1
callout_init (struct callout* c)
d184 1
@


1.12
log
@Summary:  Minor tweaks to USBDriver and EHCI prior to USB2 release
          resulting from beta testing
Detail:
Admin:    castle and d ellis added IP beyond that in NetBSD sources


Version 0.34. Tagged as 'NetBSD-0_34'
@
text
@d114 1
a114 1
#ifdef USB_DEBUG
d184 1
a184 1
#ifdef USB_DEBUG
d193 2
a194 2
#ifdef USB_DEBUG
    if (usbdebug > 15) dprintf (("Port", "callout %p called\n", c));
d196 1
a196 1
    c->c_func (c->c_arg);
d202 1
a202 1
#ifdef USB_DEBUG
d214 1
a214 1
#ifdef USB_DEBUG
d223 1
a223 1
    dprintf (("Port", "creating thread\n"));
d255 6
d262 1
a262 1
#ifdef USB_DEBUG
d311 1
a311 1
#ifdef USB_DEBUG
d324 1
a324 1
#ifdef USB_DEBUG
d336 3
d347 1
a347 1
#ifdef USB_DEBUG
d364 1
a364 1
    dprintf (("Port", "exit thread\n"));
d368 1
a368 1
    dprintf (("Port", "probing device\n"));
d398 1
a398 1
    dprintf (("Port", "Converting physical address %p\n", *v));
@


1.11
log
@        Stack brought up to date with NetBSD sources as at 20050121.
        USB2 further debugged.
Detail:
        Check in prior to second beta release. Improvements also to
        softloading of replacement modules.
Admin:
        Checked with JB .. further crosschecking is still needed for rhenium.
        Castle/D Ellis added ip from NetBSD sources


Version 0.33. Tagged as 'NetBSD-0_33'
@
text
@d73 1
a73 1
/* cold starting */
@


1.10
log
@        Update of EHCIDriver to current NetBSD, together with needed changes
        in both OHCIDriver and USBDriver.


Detail:
        Code may change before formal release .. will be beta released
        ... Entered to CVS to get new version numbers, and for
        the record.
Admin:
        Castle/netbsd added IP .. will be tested more fully before
        formal release. Still to be verified on Rhenium.


Version 0.31. Tagged as 'NetBSD-0_31'
@
text
@d300 2
a301 2
/*//            if (noblock) _swix (OS_UpCall, _INR(0,1), 6, t_locks + i);*/
/*//            _swix (OS_UpCall, _INR(0,1), 6, t_locks + i);*/
d305 1
d307 1
d316 1
a316 1
    t_handles[i] = NULL;
d339 1
a339 1
    if (usbdebug > 10) dprintf (("Port", "waking up %p\n", ident));
@


1.9
log
@       change to OHCIModule to pay heed to number of OHCI i/f reported
       by HAL (in Rhenium).. various other small adjustments to improve
       softloadability, both in OHCI and EHCI drivers.
Detail:
Admin:
    tested on iyonix and on rhenium
    castle added IP


Version 0.30. Tagged as 'NetBSD-0_30'
@
text
@d352 1
a352 1
void kthread_exit () {
d356 1
a356 1
void device_probe_and_attach () {
@


1.8
log
@  Extensive changes and bug fixes to usb and ohci ..
  'blocked' several holes that could cause freezes with awkward
  usb devices.  Added latest changes from Dan Ellis too , especially for USB2
Detail:
 many
Admin:
 Tested in ROM at Castle, and beta tested with users


Version 0.28. Tagged as 'NetBSD-0_28'
@
text
@d39 1
d69 1
a69 1
    return (uint64_t) (max_count - (readcode) ()) * ns_factor +
@


1.7
log
@Latest stuff from John - mainly Rhenium improvements.

Version 0.26. Tagged as 'NetBSD-0_26'
@
text
@a38 2
extern uint32_t hal_veneer2(uint32_t (*)(void), void*, ...);

d68 1
a68 1
    return (uint64_t) (max_count - hal_veneer2(readcode,ws)) * ns_factor +
d299 2
a300 2
//            if (noblock) _swix (OS_UpCall, _INR(0,1), 6, t_locks + i);
//            _swix (OS_UpCall, _INR(0,1), 6, t_locks + i);
d313 1
a313 1
    t_handles[i] = 0;
@


1.6
log
@  New versions from John.
Detail:
  * All modules will now rmkill/rmload more reliably
  * Keyboard driver disables kernel debounce on new enough kernels, needed
    for many PS2-USB adaptors, bar code scanners etc
  * Mouse driver will scroll wheel scroll any windows that do respond to
    scroll events, otherwise it issues PointerReason_WheelChange (9) to an
    external WimpScroll module
  * Several bugs and an interrupt hole resolved
Admin:
  Tested at Framlingham.

Version 0.25. Tagged as 'NetBSD-0_25'
@
text
@d39 2
d70 1
a70 1
    return (uint64_t) (max_count - (readcode) ()) * ns_factor +
@


1.5
log
@Merge of Dan Ellis's USB2 sources.

Version 0.22. Tagged as 'NetBSD-0_22'
@
text
@d248 1
a248 1
    _kernel_irqs_on ();
d250 1
a251 1
    uint64_t t0, t1, t2;
d284 2
d292 1
a292 1
        while (t_locks[i] == 0 && t2 < t1 && (flags & _C) == 0);
d306 1
d343 5
a347 2
    if (t_handles[i] == ident) t_locks[i] = 1;

@


1.4
log
@Found a "busses" lingering in the messages file,also removed a \n which
must have been copied from a printf somewhere.
Old service call detail removed from c.port as it's defined in another
file differently!
USBDiscover is now only available for debugging purposes.
Internationalised the mouse name (default is still "USB mouse").

Version 0.08. Tagged as 'NetBSD-0_08'
@
text
@d39 3
a41 1
static uint64_t gettime (void)
d58 1
d61 1
d86 1
d93 1
d263 2
a264 2
            (uint32_t) t0 / 1000000000, (uint32_t) t0 % 1000000000,
            (uint32_t) t1 / 1000000000, (uint32_t) t1 % 1000000000));
d315 1
a315 1
        (uint32_t) t2 / 100000000, (uint32_t) t2 % 1000000000));
d320 2
a321 2
        dprintf (("", "slept for %lu.%.06lu seconds (timo = %dms), %d cs\n",
            (uint32_t) t2 / 100000000, (uint32_t) t2 % 1000000000,
d427 27
@


1.4.2.1
log
@Added support for HAL USB devices.
Attempted interrupt hole fix.

Version 0.21, 1.22.2.1. Tagged as 'NetBSD-0_21-1_22_2_1'
@
text
@a38 2
extern uint32_t hal_veneer2(uint32_t (*)(void), void*, ...);

d64 1
a64 1
    return (uint64_t) (max_count - hal_veneer2(readcode,ws)) * ns_factor +
@


1.3
log
@Another fix to the previous buffer overrun fix,such that this time the
command aliases actually get executed now.
Timing code changed to work round HAL call not returning the right value
so temporarily wired to 2000000.
Change to Makefile so ROM builds don't have annoying throwback windows
popping up,this is now in the !Mk file.Also "-ff" function names away.

Version 0.05. Tagged as 'NetBSD-0_05'
@
text
@a29 6
#define Service_USBDriver 0xD2
#define Service_USBDriver_Starting 0x0
#define Service_USBDriver_Dying    0x1
#define Service_USBDriver_Attach    0x02
#define Service_USBDriver_Dettach   0x03

@


1.2
log
@Fix to interrupt hole in mouse driver.
Version number now got from Version file,not hand tweaked CMHG file.
Timer was a factor 10 out in previous version due to typo.

Version 0.02. Tagged as 'NetBSD-0_02'
@
text
@d47 22
a68 1
    uint32_t cs, u2s;
d70 2
a71 3
    _swix (OS_Hardware, _INR(8,9)|_OUT(0),
        0, EntryNo_HAL_CounterRead, &u2s);
    return (uint64_t) (u2s) * 5 + ((uint64_t) cs) * 10000000 /* 1e7 */;
@


1.1
log
@Import of USB driver suitable for generic PCI based OHCI controllers.
Correction of spelling of busses to buses (noun plural).
OHCIdriver only responds to PCI service call to lookup vendor name when
the device is of class OHCI controller.

Version 0.01. Tagged as 'NetBSD-0_01'
@
text
@d20 3
a24 1
#include "stdarg.h"
d45 1
a45 1
static void gettime (struct timeval * tv)
d47 1
a47 1
    int cs, u2s;
a48 1
    tv->tv_sec = cs / 100;
d51 1
a51 1
    tv->tv_usec = (cs % 100) * 10000 + (2000000 - u2s) / 200;
d62 1
a62 1
    return 0;
a89 2
extern int gettimeofday(struct timeval *, struct timezone *);

d107 3
a109 1
    gettime (thetime);
a226 3

    int cs0, cs1;

a229 1
    _swix (OS_ReadMonotonicTime, _OUT(0), &cs0);
d231 3
a233 9
    struct timeval tv0, tv1, tv2;
    gettime(&tv1);
    tv0 = tv1;
    tv1.tv_usec += (unsigned long) (timo) * 1000;
    while (tv1.tv_usec > 999999)
    {
        tv1.tv_usec -= 1000000;
        tv1.tv_sec += 1;
    }
d236 2
d240 2
a241 2
                      "from %lu.%.06lu\n"
                      "til  %lu.%.06lu\n",
d243 2
a244 2
            tv0.tv_sec, tv0.tv_usec,
            tv1.tv_sec, tv1.tv_usec));
a265 1
            gettime (&tv2);
d267 1
d270 1
a270 3
        while (t_locks[i] == 0 && (tv2.tv_sec < tv1.tv_sec ||
            tv2.tv_sec == tv1.tv_sec && tv2.tv_usec < tv1.tv_usec) &&
            (flags & _C) == 0);
d282 1
a282 1
        gettime (&tv2);
d294 3
a296 9
      dprintf (("", "now  %lu.%06lu\n", tv2.tv_sec, tv2.tv_usec));
#endif
    tv2.tv_sec -= tv0.tv_sec;
    if ((tv2.tv_usec -= tv0.tv_usec) < 0)
    {
        tv2.tv_sec -= 1;
        tv2.tv_usec += 1000000;
    }
#ifdef USB_DEBUG
d301 2
a302 1
            tv2.tv_sec, tv2.tv_usec, timo, cs1 - cs0));
@


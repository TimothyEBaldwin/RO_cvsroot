head	1.11;
access;
symbols
	USBDriver-1_29:1.11
	USBDriver-1_28:1.11
	USBDriver-1_27:1.11
	USBDriver-1_26:1.11
	USBDriver-1_25:1.11
	USBDriver-1_24:1.11
	USBDriver-1_23:1.11
	USBDriver-1_22:1.10
	USBDriver-1_21:1.10
	USBDriver-1_20:1.10
	USBDriver-1_19:1.10
	NetBSD-1_19:1.10
	NetBSD-1_18:1.10
	NetBSD-1_17:1.10
	NetBSD-1_16:1.10
	NetBSD-1_15:1.10
	NetBSD-1_14:1.10
	NetBSD-1_13:1.10
	NetBSD-1_12:1.10
	NetBSD-1_09-1:1.10
	NetBSD-1_11:1.10
	NetBSD-1_10:1.10
	NetBSD-1_09:1.10
	NetBSD-1_08:1.10
	NetBSD-1_07:1.10
	NetBSD-1_06:1.10
	NetBSD-1_05:1.10
	NetBSD-1_04:1.10
	NetBSD-1_03:1.10
	NetBSD-1_02:1.10
	NetBSD-1_01:1.10
	NetBSD-1_00:1.10
	NetBSD-0_99:1.10
	NetBSD-0_98:1.10
	NetBSD-0_97:1.10
	NetBSD-0_96:1.10
	NetBSD-0_95:1.10
	NetBSD-0_94:1.10
	NetBSD-0_93:1.10
	NetBSD-0_92:1.10
	NetBSD-0_91:1.10
	NetBSD-0_90:1.10
	NetBSD-0_89:1.10
	NetBSD-0_88:1.10
	NetBSD-0_87:1.10
	NetBSD-0_86:1.10
	NetBSD-0_85:1.10
	NetBSD-0_84:1.10
	NetBSD-0_83:1.10
	NetBSD-0_82:1.10
	NetBSD-0_81:1.10
	NetBSD-0_80:1.10
	NetBSD-0_79:1.10
	NetBSD-0_78:1.10
	NetBSD-0_77:1.10
	NetBSD-0_76:1.10
	NetBSD-0_75:1.10
	NetBSD-0_74:1.10
	NetBSD-0_73:1.10
	NetBSD-0_72:1.10
	NetBSD-0_71:1.10
	NetBSD-0_70:1.10
	NetBSD-0_69:1.10
	NetBSD-0_68:1.10
	NetBSD-0_67:1.10
	NetBSD-0_66:1.10
	NetBSD-0_65:1.10
	NetBSD-0_64:1.10
	NetBSD-0_63:1.10
	NetBSD-0_62:1.10
	NetBSD-0_61:1.10
	NetBSD-0_60:1.10
	NetBSD-0_59:1.10
	NetBSD-0_58:1.9
	NetBSD-0_57:1.9
	NetBSD-0_56:1.9
	NetBSD-0_55:1.9
	NetBSD-0_54:1.9
	NetBSD-0_53:1.9
	NetBSD-0_52:1.9
	NetBSD-0_51:1.9
	NetBSD-0_50:1.9
	NetBSD-0_49:1.9
	NetBSD-0_48:1.9
	NetBSD-0_47:1.8
	NetBSD-0_46:1.8
	NetBSD-0_45:1.8
	NetBSD-0_44:1.8
	NetBSD-0_43:1.8
	NetBSD-0_42:1.8
	NetBSD-0_41:1.8
	NetBSD-0_40:1.8
	NetBSD-0_39:1.8
	NetBSD-0_38:1.7
	NetBSD-0_37:1.7
	NetBSD-0_36:1.7
	NetBSD-0_35:1.7
	NetBSD-0_34:1.7
	NetBSD-0_33:1.7
	NetBSD-0_32:1.6
	NetBSD-0_31:1.6
	NetBSD-0_30:1.5
	NetBSD-0_29:1.5
	RO_5_07:1.5
	NetBSD-0_28:1.5
	NetBSD-0_27:1.5
	NetBSD-0_26:1.5
	NetBSD-0_25:1.5
	NetBSD-0_24:1.4
	NetBSD-0_23:1.4
	NetBSD-0_21-1_22_2_1:1.3
	NetBSD-0_22:1.4
	USB1:1.3.0.2
	NetBSD-0_21:1.3
	NetBSD-0_20:1.3
	NetBSD-0_19:1.3
	NetBSD-0_18:1.3
	NetBSD-0_17:1.3
	NetBSD-0_16:1.3
	NetBSD-0_15:1.2
	NetBSD-0_14:1.2
	NetBSD-0_13:1.2
	NetBSD-0_12:1.2
	NetBSD-0_11:1.1
	NetBSD-0_10:1.1
	NetBSD-0_09:1.1
	NetBSD-0_08:1.1
	NetBSD-0_07:1.1
	NetBSD-0_06:1.1
	NetBSD-0_05:1.1
	NetBSD-0_04:1.1
	NetBSD-0_03:1.1
	NetBSD-0_02:1.1
	NetBSD-0_01:1.1;
locks; strict;
comment	@# @;


1.11
date	2017.10.07.09.08.47;	author rool;	state Exp;
branches;
next	1.10;
commitid	Qzw5gnXY6CB2g6aA;

1.10
date	2011.05.22.20.22.42;	author jlee;	state Exp;
branches;
next	1.9;
commitid	Ye1jVWDlKivFSIkv;

1.9
date	2009.09.06.20.44.07;	author jlee;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.24.23.13.54;	author jballance;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.21.22.30.19;	author jballance;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.30.02.34.21;	author jballance;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.06.15.50.23;	author bavison;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.21.20.49.19;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.14.16.43.50;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.11.09.17.44;	author rsprowson;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.28.09.55.17;	author dellis;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Clear up duplicate/unused OHCI/EHCI source files
Detail:
  Remove the (now) unused sources from when this component produced multiple targets. See Controllers/OHCIDriver & Controllers/EHCIDriver for the live copies.
  Remove unset USBHAL defines.
  Simplify the Makefile and !Mk* scripts.
  No longer export usbroothub_subr.h.
  Add a porting type "device_t" to usb_port.h.
Admin:
  Submission for USB bounty.

Version 1.23. Tagged as 'USBDriver-1_23'
@
text
@/*      $NetBSD: usbdi_util.c,v 1.43 2005/04/12 13:10:14 itohy Exp $    */

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/cdefs.h>
//__KERNEL_RCSID(0, "$NetBSD: usbdi_util.c,v 1.43 2005/04/12 13:10:14 itohy Exp $");

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#if defined(__NetBSD__) || defined(__OpenBSD__) || defined(__riscos)
#include <sys/proc.h>
#include <sys/device.h>
#elif defined(__FreeBSD__)
#include <sys/bus.h>
#endif

#include <dev/usb/usb.h>
#include <dev/usb/usbhid.h>

#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>

#ifdef USB_DEBUG
#define DPRINTF(x)	if (usbdebug) logprintf x
#define DPRINTFN(n,x)	if (usbdebug>(n)) logprintf x
extern int usbdebug;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x) 
#endif


#ifdef __riscos
#define printf logprintf
#endif

usbd_status
usbd_get_desc(usbd_device_handle dev, int type, int index, int len, void *desc)
{
	usb_device_request_t req;

	DPRINTFN(3,("usbd_get_desc: type=%d, index=%d, len=%d\n",
		    type, index, len));

	req.bmRequestType = UT_READ_DEVICE;
	req.bRequest = UR_GET_DESCRIPTOR;
	USETW2(req.wValue, type, index);
	USETW(req.wIndex, 0);
	USETW(req.wLength, len);
	return (usbd_do_request(dev, &req, desc));
}

usbd_status
usbd_get_config_desc(usbd_device_handle dev, int confidx,
		     usb_config_descriptor_t *d)
{
	usbd_status err;

	DPRINTFN(3,("usbd_get_config_desc: confidx=%d\n", confidx));
	err = usbd_get_desc(dev, UDESC_CONFIG, confidx,
			    USB_CONFIG_DESCRIPTOR_SIZE, (void *)d);
	if (err)
		return (err);
	if (d->bDescriptorType != UDESC_CONFIG) {
		DPRINTFN(-1,("usbd_get_config_desc: confidx=%d, bad desc "
			     "len=%d type=%d\n",
			     confidx, d->bLength, d->bDescriptorType));
		return (USBD_INVAL);
	}
	return (USBD_NORMAL_COMPLETION);
}

usbd_status
usbd_get_config_desc_full(usbd_device_handle dev, int conf, void *d, int size)
{
	DPRINTFN(3,("usbd_get_config_desc_full: conf=%d\n", conf));
	return (usbd_get_desc(dev, UDESC_CONFIG, conf, size, d));
}

usbd_status
usbd_get_device_desc(usbd_device_handle dev, usb_device_descriptor_t *d)
{
	DPRINTFN(3,("usbd_get_device_desc:\n"));
	return (usbd_get_desc(dev, UDESC_DEVICE,
			     0, USB_DEVICE_DESCRIPTOR_SIZE, (void *)d));
}

usbd_status
usbd_get_device_status(usbd_device_handle dev, usb_status_t *st)
{
	usb_device_request_t req;

	req.bmRequestType = UT_READ_DEVICE;
	req.bRequest = UR_GET_STATUS;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, USB_STATUS_SIZE);
        return (usbd_do_request(dev, &req, st));
}

usbd_status
usbd_get_hub_status(usbd_device_handle dev, usb_hub_status_t *st)
{
	usb_device_request_t req;

	req.bmRequestType = UT_READ_CLASS_DEVICE;
	req.bRequest = UR_GET_STATUS;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, sizeof(usb_hub_status_t));
        return (usbd_do_request(dev, &req, st));
}

usbd_status
usbd_set_address(usbd_device_handle dev, int addr)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_DEVICE;
	req.bRequest = UR_SET_ADDRESS;
	USETW(req.wValue, addr);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);
	return usbd_do_request(dev, &req, 0);
}

usbd_status
usbd_get_port_status(usbd_device_handle dev, int port, usb_port_status_t *ps)
{
	usb_device_request_t req;

	req.bmRequestType = UT_READ_CLASS_OTHER;
	req.bRequest = UR_GET_STATUS;
	USETW(req.wValue, 0);
	USETW(req.wIndex, port);
	USETW(req.wLength, sizeof *ps);
        return (usbd_do_request(dev, &req, ps));
}

usbd_status
usbd_clear_hub_feature(usbd_device_handle dev, int sel)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_CLASS_DEVICE;
	req.bRequest = UR_CLEAR_FEATURE;
	USETW(req.wValue, sel);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);
	return (usbd_do_request(dev, &req, 0));
}

usbd_status
usbd_set_hub_feature(usbd_device_handle dev, int sel)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_CLASS_DEVICE;
	req.bRequest = UR_SET_FEATURE;
	USETW(req.wValue, sel);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);
	return (usbd_do_request(dev, &req, 0));
}

usbd_status
usbd_clear_port_feature(usbd_device_handle dev, int port, int sel)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_CLASS_OTHER;
	req.bRequest = UR_CLEAR_FEATURE;
	USETW(req.wValue, sel);
	USETW(req.wIndex, port);
	USETW(req.wLength, 0);
	return (usbd_do_request(dev, &req, 0));
}

usbd_status
usbd_set_port_feature(usbd_device_handle dev, int port, int sel)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_CLASS_OTHER;
	req.bRequest = UR_SET_FEATURE;
	USETW(req.wValue, sel);
	USETW(req.wIndex, port);
	USETW(req.wLength, 0);
	return (usbd_do_request(dev, &req, 0));
}

usbd_status
usbd_get_protocol(usbd_interface_handle iface, u_int8_t *report)
{
	usb_interface_descriptor_t *id = usbd_get_interface_descriptor(iface);
	usbd_device_handle dev;
	usb_device_request_t req;

	DPRINTFN(4, ("usbd_get_protocol: iface=%p, endpt=%d\n",
		     iface, id->bInterfaceNumber));
	if (id == NULL)
		return (USBD_IOERROR);
	usbd_interface2device_handle(iface, &dev);
	req.bmRequestType = UT_READ_CLASS_INTERFACE;
	req.bRequest = UR_GET_PROTOCOL;
	USETW(req.wValue, 0);
	USETW(req.wIndex, id->bInterfaceNumber);
	USETW(req.wLength, 1);
	return (usbd_do_request(dev, &req, report));
}

usbd_status
usbd_set_protocol(usbd_interface_handle iface, int report)
{
	usb_interface_descriptor_t *id = usbd_get_interface_descriptor(iface);
	usbd_device_handle dev;
	usb_device_request_t req;

	DPRINTFN(4, ("usbd_set_protocol: iface=%p, report=%d, endpt=%d\n",
		     iface, report, id->bInterfaceNumber));
	if (id == NULL)
		return (USBD_IOERROR);
	usbd_interface2device_handle(iface, &dev);
	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UR_SET_PROTOCOL;
	USETW(req.wValue, report);
	USETW(req.wIndex, id->bInterfaceNumber);
	USETW(req.wLength, 0);
	return (usbd_do_request(dev, &req, 0));
}

usbd_status
usbd_set_report(usbd_interface_handle iface, int type, int id, void *data,
		int len)
{
	usb_interface_descriptor_t *ifd = usbd_get_interface_descriptor(iface);
	usbd_device_handle dev;
	usb_device_request_t req;

	DPRINTFN(4, ("usbd_set_report: len=%d\n", len));
	if (ifd == NULL)
		return (USBD_IOERROR);
	usbd_interface2device_handle(iface, &dev);
	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UR_SET_REPORT;
	USETW2(req.wValue, type, id);
	USETW(req.wIndex, ifd->bInterfaceNumber);
	USETW(req.wLength, len);
	return (usbd_do_request(dev, &req, data));
}

usbd_status
usbd_set_report_async(usbd_interface_handle iface, int type, int id, void *data,
		      int len)
{
	usb_interface_descriptor_t *ifd = usbd_get_interface_descriptor(iface);
	usbd_device_handle dev;
	usb_device_request_t req;

	DPRINTFN(4, ("usbd_set_report_async: len=%d\n", len));
	if (ifd == NULL)
		return (USBD_IOERROR);
	usbd_interface2device_handle(iface, &dev);
	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UR_SET_REPORT;
	USETW2(req.wValue, type, id);
	USETW(req.wIndex, ifd->bInterfaceNumber);
	USETW(req.wLength, len);
	return (usbd_do_request_async(dev, &req, data));
}

usbd_status
usbd_get_report(usbd_interface_handle iface, int type, int id, void *data,
		int len)
{
	usb_interface_descriptor_t *ifd = usbd_get_interface_descriptor(iface);
	usbd_device_handle dev;
	usb_device_request_t req;

	DPRINTFN(4, ("usbd_get_report: len=%d\n", len));
	if (ifd == NULL)
		return (USBD_IOERROR);
	usbd_interface2device_handle(iface, &dev);
	req.bmRequestType = UT_READ_CLASS_INTERFACE;
	req.bRequest = UR_GET_REPORT;
	USETW2(req.wValue, type, id);
	USETW(req.wIndex, ifd->bInterfaceNumber);
	USETW(req.wLength, len);
	return (usbd_do_request(dev, &req, data));
}

usbd_status
usbd_set_idle(usbd_interface_handle iface, int duration, int id)
{
	usb_interface_descriptor_t *ifd = usbd_get_interface_descriptor(iface);
	usbd_device_handle dev;
	usb_device_request_t req;

	DPRINTFN(4, ("usbd_set_idle: %d %d\n", duration, id));
	if (ifd == NULL)
		return (USBD_IOERROR);
	usbd_interface2device_handle(iface, &dev);
	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UR_SET_IDLE;
	USETW2(req.wValue, duration, id);
	USETW(req.wIndex, ifd->bInterfaceNumber);
	USETW(req.wLength, 0);
	return (usbd_do_request(dev, &req, 0));
}

usbd_status
usbd_get_report_descriptor(usbd_device_handle dev, int ifcno,
			   int size, void *d)
{
	usb_device_request_t req;

	req.bmRequestType = UT_READ_INTERFACE;
	req.bRequest = UR_GET_DESCRIPTOR;
	USETW2(req.wValue, UDESC_REPORT, 0); /* report id should be 0 */
	USETW(req.wIndex, ifcno);
	USETW(req.wLength, size);
	return (usbd_do_request(dev, &req, d));
}

usb_hid_descriptor_t *
usbd_get_hid_descriptor(usbd_interface_handle ifc)
{
	usb_interface_descriptor_t *idesc = usbd_get_interface_descriptor(ifc);
	usbd_device_handle dev;
	usb_config_descriptor_t *cdesc;
	usb_hid_descriptor_t *hd;
	char *p, *end;

	if (idesc == NULL)
                return (NULL);
	 usbd_interface2device_handle(ifc, &dev);
	cdesc = usbd_get_config_descriptor(dev);

	p = (char *)idesc + idesc->bLength;
	end = (char *)cdesc + UGETW(cdesc->wTotalLength);

	for (; p < end; p += hd->bLength) {
		hd = (usb_hid_descriptor_t *)p;
		if (p + hd->bLength <= end && hd->bDescriptorType == UDESC_HID)
			return (hd);
		if (hd->bDescriptorType == UDESC_INTERFACE)
			break;
	}
        return (NULL);
}

usbd_status
usbd_read_report_desc(usbd_interface_handle ifc, void **descp, int *sizep,
		       usb_malloc_type mem)
{
	usb_interface_descriptor_t *id;
	usb_hid_descriptor_t *hid;
	usbd_device_handle dev;
	usbd_status err;

	usbd_interface2device_handle(ifc, &dev);
	id = usbd_get_interface_descriptor(ifc);
	if (id == NULL)
		return (USBD_INVAL);
	hid = usbd_get_hid_descriptor(ifc);
	if (hid == NULL)
		return (USBD_IOERROR);
#if defined(__CC_NORCROFT) && defined(DISABLE_PACKED)
        /* RISC OS can't handle packed structures, in any case this code
           always assumes that the report is in report 0, so there's no real
           problem */
	*sizep = UGETW(hid->wDescriptorLength);
#else
	*sizep = UGETW(hid->descrs[0].wDescriptorLength);
#endif
	*descp = malloc(*sizep, mem, M_NOWAIT);
	if (*descp == NULL)
		return (USBD_NOMEM);
	err = usbd_get_report_descriptor(dev, id->bInterfaceNumber,
					 *sizep, *descp);
	if (err) {
		free(*descp, mem);
		*descp = NULL;
		return (err);
	}
	return (USBD_NORMAL_COMPLETION);
}

usbd_status
usbd_get_config(usbd_device_handle dev, u_int8_t *conf)
{
	usb_device_request_t req;

	req.bmRequestType = UT_READ_DEVICE;
	req.bRequest = UR_GET_CONFIG;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 1);
	return (usbd_do_request(dev, &req, conf));
}

Static void usbd_bulk_transfer_cb(usbd_xfer_handle xfer,
				  usbd_private_handle priv, usbd_status status);
Static void
usbd_bulk_transfer_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
		      usbd_status status)
{
	wakeup(xfer);
}

usbd_status
usbd_bulk_transfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
		   u_int16_t flags, u_int32_t timeout, void *buf,
		   u_int32_t *size, char *lbl)
{
	usbd_status err;
	int s, error;

	usbd_setup_xfer(xfer, pipe, 0, buf, *size,
			flags, timeout, usbd_bulk_transfer_cb);
	DPRINTFN(1, ("usbd_bulk_transfer: start transfer %d bytes\n", *size));
	s = splusb();		/* don't want callback until tsleep() */
	err = usbd_transfer(xfer);
	if (err != USBD_IN_PROGRESS) {
		splx(s);
		return (err);
	}
#ifdef __riscos
	error = tsleep((caddr_t)xfer, PZERO | PCATCH, lbl, 0, 1);
#else
	error = tsleep((caddr_t)xfer, PZERO | PCATCH, lbl, 0);
#endif
	splx(s);
	if (error) {
		DPRINTF(("usbd_bulk_transfer: tsleep=%d\n", error));
		usbd_abort_pipe(pipe);
		return (USBD_INTERRUPTED);
	}
	usbd_get_xfer_status(xfer, NULL, NULL, size, &err);
	DPRINTFN(1,("usbd_bulk_transfer: transferred %d\n", *size));
	if (err) {
		DPRINTF(("usbd_bulk_transfer: error=%d\n", err));
		usbd_clear_endpoint_stall(pipe);
	}
	return (err);
}
Static void usbd_intr_transfer_cb(usbd_xfer_handle xfer,
                                  usbd_private_handle priv, usbd_status status);
Static void
usbd_intr_transfer_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
                      usbd_status status)
{
        wakeup(xfer);
}

usbd_status
usbd_intr_transfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
                   u_int16_t flags, u_int32_t timeout, void *buf,
                   u_int32_t *size, char *lbl)
{
        usbd_status err;
        int s, error;

        usbd_setup_xfer(xfer, pipe, 0, buf, *size,
                        flags, timeout, usbd_intr_transfer_cb);
        DPRINTFN(1, ("usbd_intr_transfer: start transfer %d bytes\n", *size));
        s = splusb();           /* don't want callback until tsleep() */
        err = usbd_transfer(xfer);
        if (err != USBD_IN_PROGRESS) {
                splx(s);
                return (err);
        }
#ifdef __riscos
        error = tsleep(xfer, PZERO | PCATCH, lbl, 0, 1);
#else
        error = tsleep(xfer, PZERO | PCATCH, lbl, 0);
#endif
        splx(s);
        if (error) {
                DPRINTF(("usbd_intr_transfer: tsleep=%d\n", error));
                usbd_abort_pipe(pipe);
                return (USBD_INTERRUPTED);
        }
        usbd_get_xfer_status(xfer, NULL, NULL, size, &err);
        DPRINTFN(1,("usbd_intr_transfer: transferred %d\n", *size));
        if (err) {
                DPRINTF(("usbd_intr_transfer: error=%d\n", err));
                usbd_clear_endpoint_stall(pipe);
        }
        return (err);
}

void
usb_detach_wait(device_ptr_t dv)
{
	DPRINTF(("usb_detach_wait: waiting for %s\n", USBDEVPTRNAME(dv)));
#ifdef __riscos
        if (tsleep(dv, PZERO, "usbdet", hz * 60, 1))
#else
        if (tsleep(dv, PZERO, "usbdet", hz * 60))
#endif
		printf("usb_detach_wait: %s didn't detach\n",
		        USBDEVPTRNAME(dv));
	DPRINTF(("usb_detach_wait: %s done\n", USBDEVPTRNAME(dv)));
}

void
usb_detach_wakeup(device_ptr_t dv)
{
	DPRINTF(("usb_detach_wakeup: for %s\n", USBDEVPTRNAME(dv)));
	wakeup(dv);
}

usb_descriptor_t *
usb_find_desc(usbd_device_handle dev, int type)
{
	usb_descriptor_t *desc;
	usb_config_descriptor_t *cd = usbd_get_config_descriptor(dev);
        uByte *p = (uByte *)cd;
        uByte *end = p + UGETW(cd->wTotalLength);

	while (p < end) {
		desc = (usb_descriptor_t *)p;
		if (desc->bDescriptorType == type)
			return (desc);
		p += desc->bLength;
	}

	return (NULL);
}
@


1.10
log
@Add the ability to build the USB drivers as HAL-compatible static libraries
Detail:
  build/Makefile, build/OBJEHCIDriver, build/OBJOHCIDriver, build/OBJUSBDriver - Modified makefiles to build the HAL libs during the export libs phase
  build/!MkHAL,fd7 - Handy script for building the HAL libs
  build/Hdr/usbhal - Header containing definitions for the assembler code. Also gets exported so that HALs know how much workspace to reserve.
  build/c/usbhal - HAL version of usbmodule.c & port.c. Also contains the keyboard scan code, adapted from the code in the Tungsten HAL.
  build/s/porthal - Assembler versions of some port.c routines that were easier to do in assembler than C
  build/s/halheap - OS_Heap code that's been adapted for use in the HAL. Could easily be changed into a standalone library instead of being part of the HAL USB libs. Supports memory-efficient allocation of aligned blocks.
  build/c/ehcihal - HAL version of ehcimodule.c. Currently only supports EHCI controllers exposed via HAL_USBControllerInfo (i.e. no PCI support)
  build/c/ehcimodule, build/c/ohcimodule, build/c/port - Moved riscos_irq_clear into port.c. Removed unused microtime() function.
  build/c/usbmouse - Strip out some debug-related code in non-debug builds
  build/Version - Updated version numbers
  dev/usb/c/ehci, dev/usb/h/ehcivar - Adapted to add support for the HAL build. Apart from the base changes, the code has also been tweaked to significantly reduce the amount of memory used at runtime by the HAL version of the driver.
  dev/usb/c/hid, dev/usb/c/uhub, dev/usb/c/usb, dev/usb/c/usb_quirks, dev/usb/c/usb_subr, dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/c/usbroothub_subr - Changes to support HAL builds. Mainly disabling bits that won't work in the HAL or disabling bits for RISC OS in general if they weren't being used in the first place.
  dev/usb/c/ohci, dev/usb/h/ohcivar - Basic changes to support HAL builds. However HAL OHCI support is still incomplete.
  dev/usb/h/usb_port - Added support for the HAL build. Also tweaked logprintf definition to get rid of logprintf calls entirely in non-debug builds.
  dev/usb/h/usbdivar - Added support for the HAL build.
  dev/usb/h/usbhal - New header used by the HAL build. Gets included by every C file to ensure the compiler doesn't use sb, and contains structs/macros to allow access to the shared workspace.
Admin:
  HAL & non-HAL builds tested on rev C2 BB, rev A2 BB-xM, rev C1 TouchBook.
  Non-HAL builds tested with Iyonix ROM softload.
  Needs latest Kernel source for OSEntries.h export.


Version 0.59. Tagged as 'NetBSD-0_59'
@
text
@a39 3
#ifdef __riscos
#include <dev/usb/usbhal.h>
#endif
@


1.9
log
@Add workaround for incorrect sizeof(usb_status_t), disable debug_set_stamp_debug(TRUE) to fix interrupt issue
Detail:
  build/c/ehcimodule, build/c/ohcimodule, build/c/usbmodule - Make sure that timestamped debug messages aren't used, as they appear to cause interrupts to be briefly enabled, which causes all kinds of problems in sensitive bits of the code.
  dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/h/usb - Because DISABLE_PACKED is being used to compile the USB drivers, sizeof(usb_status_t) was being calculated as 4 bytes instead of 2. Somehow this works fine with the EHCI driver (and presumably the OHCI driver), but it was causing problems with the MUSBDriver, so a hardcoded size of 2 is now used.
Admin:
  Tested on rev C2 beagleboard.


Version 0.48. Tagged as 'NetBSD-0_48'
@
text
@d40 3
@


1.8
log
@	Update of NetBSD elements (except c.ohci) to track NetBSD current
	from mid April 2005.
	Inclusion of Mods to c.ehci (from Dan) to correctly handle low
	speed interrupt devices beyond USB2 hubs (i.e. keyboards and mice).
	Mod to EHCI resetting in service call handler to better cope with
	USBDriver being restarted 'underneath' it.
Detail:
Admin:
	Castle, Dan Ellis, NetBSD added IP. Tested at Castle. Will be
	beta tested at this revision level before full release.


Version 0.39. Tagged as 'NetBSD-0_39'
@
text
@d134 1
a134 1
	USETW(req.wLength, sizeof(usb_status_t));
@


1.7
log
@        Stack brought up to date with NetBSD sources as at 20050121.
        USB2 further debugged.
Detail:
        Check in prior to second beta release. Improvements also to
        softloading of replacement modules.
Admin:
        Checked with JB .. further crosschecking is still needed for rhenium.
        Castle/D Ellis added ip from NetBSD sources


Version 0.33. Tagged as 'NetBSD-0_33'
@
text
@d1 1
a1 1
/*      $NetBSD: usbdi_util.c,v 1.42 2004/12/03 08:53:40 augustss Exp $ */
d41 1
a41 1
//__KERNEL_RCSID(0, "$NetBSD: usbdi_util.c,v 1.42 2004/12/03 08:53:40 augustss Exp $");
@


1.6
log
@        Update of EHCIDriver to current NetBSD, together with needed changes
        in both OHCIDriver and USBDriver.


Detail:
        Code may change before formal release .. will be beta released
        ... Entered to CVS to get new version numbers, and for
        the record.
Admin:
        Castle/netbsd added IP .. will be tested more fully before
        formal release. Still to be verified on Rhenium.


Version 0.31. Tagged as 'NetBSD-0_31'
@
text
@d66 6
a71 1
#define DPRINTFN(n,x)
a134 1
#ifdef __riscos
a135 3
#else
	return (usbd_do_request(dev, &req, (void *)st));
#endif
a147 1
#ifdef __riscos
a148 3
#else
	return (usbd_do_request(dev, &req, (void *)st));
#endif
a173 1
#ifdef __riscos
a174 3
#else
	return (usbd_do_request(dev, &req, (void *)ps));
#endif
d539 1
a539 1
		logprintf("usb_detach_wait: %s didn't detach\n",
@


1.5
log
@  New versions from John.
Detail:
  * All modules will now rmkill/rmload more reliably
  * Keyboard driver disables kernel debounce on new enough kernels, needed
    for many PS2-USB adaptors, bar code scanners etc
  * Mouse driver will scroll wheel scroll any windows that do respond to
    scroll events, otherwise it issues PointerReason_WheelChange (9) to an
    external WimpScroll module
  * Several bugs and an interrupt hole resolved
Admin:
  Tested at Framlingham.

Version 0.25. Tagged as 'NetBSD-0_25'
@
text
@d1 1
a1 2
/*	$NetBSD: usbdi_util.c,v 1.40 2002/07/11 21:14:36 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usbdi_util.c,v 1.14 1999/11/17 22:33:50 n_hibma Exp $	*/
d41 1
a41 1
//__KERNEL_RCSID(0, "$NetBSD: usbdi_util.c,v 1.40 2002/07/11 21:14:36 augustss Exp $");
d130 3
d134 1
d147 3
d151 1
d177 3
d181 1
d379 1
a379 1
		return (0);
d393 1
a393 1
	return (0);
d490 45
@


1.4
log
@Merge of Dan Ellis's USB2 sources.

Version 0.22. Tagged as 'NetBSD-0_22'
@
text
@d401 1
a401 1
#ifdef __riscos
@


1.3
log
@  Support for SCSISoftUSB, and some tidying up.
Detail:
  * Errors now use the allocated error number base, &819000, instead of a
    base in the private range, &50000000. "USB transfer failed" errors now
    have use a sub-range of error numbers from &819020; the original BSD
    error number can be retrieved from the bottom 5 bits of the RISC OS
    error number.
  * Service_USB 1 now returns the list in the order in which the devices,
    rather than in the reverse order as previous versions of the module did.
  * A little tweaking of h/usb_port to reduce compiler warnings.
  * Some compiler-satisfying changes to allow use of packed structures.
    (However, the compiler doesn't seem to work correctly yet, so this is
    currently switched out using -DDISABLE_PACKED on the command line.)
  * Added full stops to end of star command help strings for consistency
    with rest of OS.
  * New exports: USBDevFS (moved here from ^.h) and a few files in dev/usb/h
    and sys/h.
Admin:
  Error number overhaul and new exports are both required by SCSISoftUSB.

Version 0.16. Tagged as 'NetBSD-0_16'
@
text
@d1 1
a1 1
/*	$NetBSD: usbdi_util.c,v 1.33 2000/06/01 15:51:27 augustss Exp $	*/
d41 3
d225 19
a250 1
	usbd_status err;
d256 1
a256 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
a271 1
	usbd_status err;
d276 1
a276 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
a291 1
	usbd_status err;
d296 1
a296 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
a311 1
	usbd_status err;
d316 1
a316 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
a330 1
	usbd_status err;
d335 1
a335 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
d345 1
a345 1
usbd_get_report_descriptor(usbd_device_handle dev, int ifcno, int repid,
d352 1
a352 1
	USETW2(req.wValue, UDESC_REPORT, repid);
a365 1
	usbd_status err;
d369 1
a369 3
	err = usbd_interface2device_handle(ifc, &dev);
	if (err)
		return (0);
d386 1
a386 1
usbd_alloc_report_desc(usbd_interface_handle ifc, void **descp, int *sizep,
d394 1
a394 3
	err = usbd_interface2device_handle(ifc, &dev);
	if (err)
		return (err);
d412 2
a413 3
	/* XXX should not use 0 Report ID */
	err = usbd_get_report_descriptor(dev, id->bInterfaceNumber, 0,
				       *sizep, *descp);
d486 1
a486 1
	if (tsleep(dv, PZERO, "usbdet", hz * 60, 1))
d500 18
@


1.2
log
@Nicked a few hub related fixes from later NetBSD versions.
Added stuff to delete the DeviceFS$USB*$Options variables when the module is
RMkilled.

Version 0.12. Tagged as 'NetBSD-0_12'
@
text
@d91 1
a91 1
			    USB_CONFIG_DESCRIPTOR_SIZE, d);
d115 1
a115 1
			     0, USB_DEVICE_DESCRIPTOR_SIZE, d));
d128 1
a128 1
	return (usbd_do_request(dev, &req, st));
d141 1
a141 1
	return (usbd_do_request(dev, &req, st));
d167 1
a167 1
	return (usbd_do_request(dev, &req, ps));
@


1.1
log
@Import of USB driver suitable for generic PCI based OHCI controllers.
Correction of spelling of busses to buses (noun plural).
OHCIdriver only responds to PCI service call to lookup vendor name when
the device is of class OHCI controller.

Version 0.01. Tagged as 'NetBSD-0_01'
@
text
@d415 1
@


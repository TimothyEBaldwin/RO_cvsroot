head	1.14;
access;
symbols
	USBDriver-1_29:1.14
	USBDriver-1_28:1.14
	USBDriver-1_27:1.14
	USBDriver-1_26:1.14
	USBDriver-1_25:1.14
	USBDriver-1_24:1.14
	USBDriver-1_23:1.14
	USBDriver-1_22:1.14
	USBDriver-1_21:1.14
	USBDriver-1_20:1.14
	USBDriver-1_19:1.14
	NetBSD-1_19:1.14
	NetBSD-1_18:1.14
	NetBSD-1_17:1.14
	NetBSD-1_16:1.14
	NetBSD-1_15:1.14
	NetBSD-1_14:1.14
	NetBSD-1_13:1.14
	NetBSD-1_12:1.14
	NetBSD-1_09-1:1.14
	NetBSD-1_11:1.14
	NetBSD-1_10:1.14
	NetBSD-1_09:1.14
	NetBSD-1_08:1.14
	NetBSD-1_07:1.14
	NetBSD-1_06:1.14
	NetBSD-1_05:1.14
	NetBSD-1_04:1.14
	NetBSD-1_03:1.14
	NetBSD-1_02:1.14
	NetBSD-1_01:1.14
	NetBSD-1_00:1.14
	NetBSD-0_99:1.14
	NetBSD-0_98:1.14
	NetBSD-0_97:1.14
	NetBSD-0_96:1.14
	NetBSD-0_95:1.14
	NetBSD-0_94:1.14
	NetBSD-0_93:1.14
	NetBSD-0_92:1.14
	NetBSD-0_91:1.14
	NetBSD-0_90:1.14
	NetBSD-0_89:1.14
	NetBSD-0_88:1.13
	NetBSD-0_87:1.13
	NetBSD-0_86:1.13
	NetBSD-0_85:1.13
	NetBSD-0_84:1.13
	NetBSD-0_83:1.13
	NetBSD-0_82:1.13
	NetBSD-0_81:1.13
	NetBSD-0_80:1.13
	NetBSD-0_79:1.13
	NetBSD-0_78:1.13
	NetBSD-0_77:1.13
	NetBSD-0_76:1.13
	NetBSD-0_75:1.13
	NetBSD-0_74:1.13
	NetBSD-0_73:1.13
	NetBSD-0_72:1.13
	NetBSD-0_71:1.13
	NetBSD-0_70:1.12
	NetBSD-0_69:1.12
	NetBSD-0_68:1.12
	NetBSD-0_67:1.12
	NetBSD-0_66:1.12
	NetBSD-0_65:1.12
	NetBSD-0_64:1.12
	NetBSD-0_63:1.12
	NetBSD-0_62:1.12
	NetBSD-0_61:1.12
	NetBSD-0_60:1.12
	NetBSD-0_59:1.12
	NetBSD-0_58:1.12
	NetBSD-0_57:1.12
	NetBSD-0_56:1.12
	NetBSD-0_55:1.12
	NetBSD-0_54:1.12
	NetBSD-0_53:1.12
	NetBSD-0_52:1.12
	NetBSD-0_51:1.11
	NetBSD-0_50:1.11
	NetBSD-0_49:1.11
	NetBSD-0_48:1.11
	NetBSD-0_47:1.10
	NetBSD-0_46:1.10
	NetBSD-0_45:1.10
	NetBSD-0_44:1.10
	NetBSD-0_43:1.10
	NetBSD-0_42:1.10
	NetBSD-0_41:1.10
	NetBSD-0_40:1.10
	NetBSD-0_39:1.10
	NetBSD-0_38:1.10
	NetBSD-0_37:1.10
	NetBSD-0_36:1.10
	NetBSD-0_35:1.9
	NetBSD-0_34:1.8
	NetBSD-0_33:1.8
	NetBSD-0_32:1.8
	NetBSD-0_31:1.8
	NetBSD-0_30:1.7
	NetBSD-0_29:1.7
	RO_5_07:1.7
	NetBSD-0_28:1.7
	NetBSD-0_27:1.7
	NetBSD-0_26:1.7
	NetBSD-0_25:1.6
	NetBSD-0_24:1.6
	NetBSD-0_23:1.6
	NetBSD-0_21-1_22_2_1:1.5
	NetBSD-0_22:1.6
	USB1:1.5.0.2
	NetBSD-0_21:1.5
	NetBSD-0_20:1.5
	NetBSD-0_19:1.4
	NetBSD-0_18:1.4
	NetBSD-0_17:1.4
	NetBSD-0_16:1.4
	NetBSD-0_15:1.3
	NetBSD-0_14:1.2
	NetBSD-0_13:1.2
	NetBSD-0_12:1.2
	NetBSD-0_11:1.1
	NetBSD-0_10:1.1
	NetBSD-0_09:1.1
	NetBSD-0_08:1.1
	NetBSD-0_07:1.1
	NetBSD-0_06:1.1
	NetBSD-0_05:1.1
	NetBSD-0_04:1.1
	NetBSD-0_03:1.1
	NetBSD-0_02:1.1
	NetBSD-0_01:1.1;
locks; strict;
comment	@# @;


1.14
date	2014.10.25.18.43.45;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	SYXBVhhWAW5D5CVx;

1.13
date	2012.06.07.00.11.17;	author jlee;	state Exp;
branches;
next	1.12;
commitid	LkYeKFZjKWlNTH7w;

1.12
date	2010.07.21.23.57.21;	author jlee;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.06.20.44.08;	author jlee;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.23.00.01.59;	author jballance;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.18.00.35.56;	author jballance;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.30.02.34.21;	author jballance;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.30.14.50.37;	author kbracey;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.21.20.49.20;	author bavison;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.07.13.43.18;	author bavison;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.14.16.43.52;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.23.14.10.13;	author rsprowson;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.11.09.17.44;	author rsprowson;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.28.09.55.18;	author dellis;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update to use rationalised power and overcurrent API
OHCIDriver (only) had sketchy support for a HAL based scheme for controlling the port power and monitor overcurrent. However the implementation was limited to supporting the single port required for an embedded product (aka Rhenium in the CVS history). The change makes it follow a model much more akin to the HAL_TimerDevice/HAL_TimerIRQStatus/HAL_TimerIRQClear set of functions.
Version:
  Bumped OHCIDriver and USBDriver version numbers.
ohcimodule.c:
  Use some defines from OsBytes.h.
  Group the debug variables within the OHCI_DEBUG define so they go away in the release case.
  Allow for up to 15 ports to be controlled via the revised HAL API, and pass something other than a hardwired controller of 0 when controlling/monitoring power.
  Enumerate the device numbers for overcurrent monitoring on startup.
  Deal with the possibility of one (or more) of the device numbers being shared interrupts.
  Squash a few trivial compiler warnings.
ohcimodhead.cmhg:
  rename the handler/entry to reflect their use for overcurrent
ohci.c:
  Allow for up to 15 ports to be controlled by passing in the port index where needed.
usb_subr.c/usbdivar.h:
  Remove a RISC OS-ism in datatoggle, to converge with NetBSD a bit.
ehcivar.h/usb_port.h:
  Relocate the overrides for mutex_ functions here since this is the only controller using them. Previously when in "usb_port.h" they would indirectly get dragged in ia the nested include in "usb.h". The could in fact now be implemented using SyncLib, an exercise left to the reader.
usb.h
  Merge some of the device classes and other allocations from NetBSD.

While it's not been possible to test the revised API, due to not having sight of the original platform on which it was implemented, none of the actively maintained HALs currently use the HAL based power and overcurrent scheme anyway, so the new code never gets called. In that respect, it's no more broken then the previous single port-single controller version.

Version 0.89. Tagged as 'NetBSD-0_89'
@
text
@/*      $NetBSD: usb.h,v 1.71 2004/06/23 06:27:54 mycroft Exp $ */
/*	$FreeBSD: src/sys/dev/usb/usb.h,v 1.14 1999/11/17 22:33:46 n_hibma Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


#ifndef _USB_H_
#define _USB_H_

#include <sys/types.h>
#include <sys/time.h>

#if defined(__NetBSD__) || defined(__OpenBSD__)
#include <sys/ioctl.h>
#endif
#if defined(__FreeBSD__)
/* These two defines are used by usbd to autoload the usb kld */
#define USB_KLD		"usb"           /* name of usb module */
#define USB_UHUB	"usb/uhub"      /* root hub */
#endif

#if defined(_KERNEL)
#include <dev/usb/usb_port.h>
#endif /* _KERNEL */

#define USB_STACK_VERSION 2

#define USB_MAX_DEVICES 128
#define USB_START_ADDR 0

#define USB_CONTROL_ENDPOINT 0
#define USB_MAX_ENDPOINTS 16

#define USB_FRAMES_PER_SECOND 1000
#define USB_UFRAMES_PER_FRAME 8

/*
 * The USB records contain some unaligned little-endian word
 * components.  The U[SG]ETW macros take care of both the alignment
 * and endian problem and should always be used to access non-byte
 * values.
 */
typedef u_int8_t uByte;
typedef u_int8_t uWord[2];
typedef u_int8_t uDWord[4];

#define USETW2(w,h,l) ((w)[0] = (u_int8_t)(l), (w)[1] = (u_int8_t)(h))

#ifdef DISABLE_PACKED
#define UGETW(w) ((w)[0] | ((w)[1] << 8))
#define USETW(w,v) ((w)[0] = (u_int8_t)(v), (w)[1] = (u_int8_t)((v) >> 8))
#define UGETDW(w) ((w)[0] | ((w)[1] << 8) | ((w)[2] << 16) | ((w)[3] << 24))
#define USETDW(w,v) ((w)[0] = (u_int8_t)(v), \
		     (w)[1] = (u_int8_t)((v) >> 8), \
		     (w)[2] = (u_int8_t)((v) >> 16), \
		     (w)[3] = (u_int8_t)((v) >> 24))
#else
/*
 * On little-endian machines that can handle unanliged accesses
 * (e.g. i386) these macros can be replaced by the following.
 */
#ifdef __CC_NORCROFT
#define UGETW(w) (*(__packed u_int16_t *)(w))
#define USETW(w,v) (*(__packed u_int16_t *)(w) = (v))
#define UGETDW(w) (*(__packed u_int32_t *)(w))
#define USETDW(w,v) (*(__packed u_int32_t *)(w) = (v))
#else
#define UGETW(w) (*(u_int16_t *)(w))
#define USETW(w,v) (*(u_int16_t *)(w) = (v))
#define UGETDW(w) (*(u_int32_t *)(w))
#define USETDW(w,v) (*(u_int32_t *)(w) = (v))
#endif
#endif

#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
#define UPACKED __packed
#else
#define UPACKED __attribute__((__packed__))
#endif

typedef struct {
	uByte		bmRequestType;
	uByte		bRequest;
	uWord		wValue;
	uWord		wIndex;
	uWord		wLength;
} UPACKED usb_device_request_t;

#define UT_GET_DIR(a) ((a) & 0x80)
#define UT_WRITE		0x00
#define UT_READ			0x80

#define UT_GET_TYPE(a) ((a) & 0x60)
#define UT_STANDARD		0x00
#define UT_CLASS		0x20
#define UT_VENDOR		0x40

#define UT_GET_RECIPIENT(a) ((a) & 0x1f)
#define UT_DEVICE		0x00
#define UT_INTERFACE		0x01
#define UT_ENDPOINT		0x02
#define UT_OTHER		0x03

#define UT_READ_DEVICE		(UT_READ  | UT_STANDARD | UT_DEVICE)
#define UT_READ_INTERFACE	(UT_READ  | UT_STANDARD | UT_INTERFACE)
#define UT_READ_ENDPOINT	(UT_READ  | UT_STANDARD | UT_ENDPOINT)
#define UT_WRITE_DEVICE		(UT_WRITE | UT_STANDARD | UT_DEVICE)
#define UT_WRITE_INTERFACE	(UT_WRITE | UT_STANDARD | UT_INTERFACE)
#define UT_WRITE_ENDPOINT	(UT_WRITE | UT_STANDARD | UT_ENDPOINT)
#define UT_READ_CLASS_DEVICE	(UT_READ  | UT_CLASS | UT_DEVICE)
#define UT_READ_CLASS_INTERFACE	(UT_READ  | UT_CLASS | UT_INTERFACE)
#define UT_READ_CLASS_OTHER	(UT_READ  | UT_CLASS | UT_OTHER)
#define UT_READ_CLASS_ENDPOINT	(UT_READ  | UT_CLASS | UT_ENDPOINT)
#define UT_WRITE_CLASS_DEVICE	(UT_WRITE | UT_CLASS | UT_DEVICE)
#define UT_WRITE_CLASS_INTERFACE (UT_WRITE | UT_CLASS | UT_INTERFACE)
#define UT_WRITE_CLASS_OTHER	(UT_WRITE | UT_CLASS | UT_OTHER)
#define UT_WRITE_CLASS_ENDPOINT	(UT_WRITE | UT_CLASS | UT_ENDPOINT)
#define UT_READ_VENDOR_DEVICE	(UT_READ  | UT_VENDOR | UT_DEVICE)
#define UT_READ_VENDOR_INTERFACE (UT_READ  | UT_VENDOR | UT_INTERFACE)
#define UT_READ_VENDOR_OTHER	(UT_READ  | UT_VENDOR | UT_OTHER)
#define UT_READ_VENDOR_ENDPOINT	(UT_READ  | UT_VENDOR | UT_ENDPOINT)
#define UT_WRITE_VENDOR_DEVICE	(UT_WRITE | UT_VENDOR | UT_DEVICE)
#define UT_WRITE_VENDOR_INTERFACE (UT_WRITE | UT_VENDOR | UT_INTERFACE)
#define UT_WRITE_VENDOR_OTHER	(UT_WRITE | UT_VENDOR | UT_OTHER)
#define UT_WRITE_VENDOR_ENDPOINT (UT_WRITE | UT_VENDOR | UT_ENDPOINT)

/* Standard Requests Codes from the USB 2.0 spec, table 9-4 */
#define UR_GET_STATUS		0x00
#define UR_CLEAR_FEATURE	0x01
#define UR_SET_FEATURE		0x03
#define UR_SET_ADDRESS		0x05
#define UR_GET_DESCRIPTOR	0x06
#define  UDESC_DEVICE		0x01
#define  UDESC_CONFIG		0x02
#define  UDESC_STRING		0x03
#define  UDESC_INTERFACE	0x04
#define  UDESC_ENDPOINT		0x05
#define  UDESC_DEVICE_QUALIFIER	0x06
#define  UDESC_OTHER_SPEED_CONFIGURATION 0x07
#define  UDESC_INTERFACE_POWER	0x08
#define  UDESC_OTG		0x09
#define  UDESC_DEBUG		0x0a
#define  UDESC_INTERFACE_ASSOC	0x0b
#define  UDESC_CS_DEVICE	0x21	/* class specific */
#define  UDESC_CS_CONFIG	0x22
#define  UDESC_CS_STRING	0x23
#define  UDESC_CS_INTERFACE	0x24
#define  UDESC_CS_ENDPOINT	0x25
#define  UDESC_HUB		0x29
#define  UDESC_SSHUB		0x2a
#define UR_SET_DESCRIPTOR	0x07
#define UR_GET_CONFIG		0x08
#define UR_SET_CONFIG		0x09
#define UR_GET_INTERFACE	0x0a
#define UR_SET_INTERFACE	0x0b
#define UR_SYNCH_FRAME		0x0c

/*
 * Feature selectors. USB 2.0 spec, table 9-6 and OTG and EH suppliment,
 * table 6-2
 */
#define UF_ENDPOINT_HALT	0
#define UF_DEVICE_REMOTE_WAKEUP	1
#define UF_TEST_MODE		2
#define UF_DEVICE_B_HNP_ENABLE	3
#define UF_DEVICE_A_HNP_SUPPORT	4
#define UF_DEVICE_A_ALT_HNP_SUPPORT 5

#define USB_MAX_IPACKET		8 /* maximum size of the initial packet */

#define USB_2_MAX_CTRL_PACKET	64
#define USB_2_MAX_BULK_PACKET	512

#define USB_3_MAX_CTRL_PACKET	512

typedef struct {
	uByte		bLength;
	uByte		bDescriptorType;
	uByte		bDescriptorSubtype;
} UPACKED usb_descriptor_t;

typedef struct {
	uByte		bLength;
	uByte		bDescriptorType;
	uWord		bcdUSB;
#define UD_USB_2_0		0x0200
#define UD_IS_USB2(d) (UGETW((d)->bcdUSB) >= UD_USB_2_0)
	uByte		bDeviceClass;
	uByte		bDeviceSubClass;
	uByte		bDeviceProtocol;
	uByte		bMaxPacketSize;
	/* The fields below are not part of the initial descriptor. */
	uWord		idVendor;
	uWord		idProduct;
	uWord		bcdDevice;
	uByte		iManufacturer;
	uByte		iProduct;
	uByte		iSerialNumber;
	uByte		bNumConfigurations;
} UPACKED usb_device_descriptor_t;
#define USB_DEVICE_DESCRIPTOR_SIZE 18

typedef struct {
	uByte		bLength;
	uByte		bDescriptorType;
	uWord		wTotalLength;
	uByte		bNumInterface;
	uByte		bConfigurationValue;
	uByte		iConfiguration;
	uByte		bmAttributes;
#define UC_ATTR_MBO		0x80
#ifdef __riscos
#define UC_BUS_POWERED		UC_ATTR_MBO /* TODO - remove */
#endif
#define UC_SELF_POWERED		0x40
#define UC_REMOTE_WAKEUP	0x20
	uByte		bMaxPower; /* max current in 2 mA units */
#define UC_POWER_FACTOR 2
} UPACKED usb_config_descriptor_t;
#define USB_CONFIG_DESCRIPTOR_SIZE 9

typedef struct {
	uByte		bLength;
	uByte		bDescriptorType;
	uByte		bInterfaceNumber;
	uByte		bAlternateSetting;
	uByte		bNumEndpoints;
	uByte		bInterfaceClass;
	uByte		bInterfaceSubClass;
	uByte		bInterfaceProtocol;
	uByte		iInterface;
} UPACKED usb_interface_descriptor_t;
#define USB_INTERFACE_DESCRIPTOR_SIZE 9

typedef struct {
	uByte		bLength;
	uByte		bDescriptorType;
	uByte		bEndpointAddress;
#define UE_GET_DIR(a)	((a) & 0x80)
#define UE_SET_DIR(a,d)	((a) | (((d)&1) << 7))
#define UE_DIR_IN	0x80
#define UE_DIR_OUT	0x00
#define UE_ADDR		0x0f
#define UE_GET_ADDR(a)	((a) & UE_ADDR)
	uByte		bmAttributes;
#define UE_XFERTYPE	0x03
#define  UE_CONTROL	0x00
#define  UE_ISOCHRONOUS	0x01
#define  UE_BULK	0x02
#define  UE_INTERRUPT	0x03
#define UE_GET_XFERTYPE(a)	((a) & UE_XFERTYPE)
#define UE_ISO_TYPE	0x0c
#define  UE_ISO_ASYNC	0x04
#define  UE_ISO_ADAPT	0x08
#define  UE_ISO_SYNC	0x0c
#define UE_GET_ISO_TYPE(a)	((a) & UE_ISO_TYPE)
	uWord		wMaxPacketSize;
#define UE_GET_TRANS(a)		(((a) >> 11) & 0x3)
#define UE_GET_SIZE(a)		((a) & 0x7ff)
	uByte		bInterval;
} UPACKED usb_endpoint_descriptor_t;
#define USB_ENDPOINT_DESCRIPTOR_SIZE 7

typedef struct {
	uByte		bLength;
	uByte		bDescriptorType;
	uWord		bString[127];
} UPACKED usb_string_descriptor_t;
#define USB_MAX_STRING_LEN 128
#define USB_LANGUAGE_TABLE 0	/* # of the string language id table */

/* Hub specific request */
#define UR_GET_BUS_STATE	0x02
#define UR_CLEAR_TT_BUFFER	0x08
#define UR_RESET_TT		0x09
#define UR_GET_TT_STATE		0x0a
#define UR_STOP_TT		0x0b

/*
 * Hub features from USB 2.0 spec, table 11-17 and updated by the
 * LPM ECN table 4-7.
 */
#define UHF_C_HUB_LOCAL_POWER	0
#define UHF_C_HUB_OVER_CURRENT	1
#define UHF_PORT_CONNECTION	0
#define UHF_PORT_ENABLE		1
#define UHF_PORT_SUSPEND	2
#define UHF_PORT_OVER_CURRENT	3
#define UHF_PORT_RESET		4
#define UHF_PORT_POWER		8
#define UHF_PORT_LOW_SPEED	9
#define UHF_PORT_L1		10
#define UHF_C_PORT_CONNECTION	16
#define UHF_C_PORT_ENABLE	17
#define UHF_C_PORT_SUSPEND	18
#define UHF_C_PORT_OVER_CURRENT	19
#define UHF_C_PORT_RESET	20
#define UHF_PORT_TEST		21
#define UHF_PORT_INDICATOR	22
#define UHF_C_PORT_L1		23

typedef struct {
	uByte		bDescLength;
	uByte		bDescriptorType;
	uByte		bNbrPorts;
	uWord		wHubCharacteristics;
#define UHD_PWR			0x0003
#define  UHD_PWR_GANGED		0x0000
#define  UHD_PWR_INDIVIDUAL	0x0001
#define  UHD_PWR_NO_SWITCH	0x0002
#define UHD_COMPOUND		0x0004
#define UHD_OC			0x0018
#define  UHD_OC_GLOBAL		0x0000
#define  UHD_OC_INDIVIDUAL	0x0008
#define  UHD_OC_NONE		0x0010
#define UHD_TT_THINK		0x0060
#define  UHD_TT_THINK_8		0x0000
#define  UHD_TT_THINK_16	0x0020
#define  UHD_TT_THINK_24	0x0040
#define  UHD_TT_THINK_32	0x0060
#define UHD_PORT_IND		0x0080
	uByte		bPwrOn2PwrGood;	/* delay in 2 ms units */
#define UHD_PWRON_FACTOR 2
	uByte		bHubContrCurrent;
	uByte		DeviceRemovable[32]; /* max 255 ports */
#define UHD_NOT_REMOV(desc, i) \
    (((desc)->DeviceRemovable[(i)/8] >> ((i) % 8)) & 1)
	/* deprecated */ uByte		PortPowerCtrlMask[1];
} UPACKED usb_hub_descriptor_t;
#define USB_HUB_DESCRIPTOR_SIZE 9 /* includes deprecated PortPowerCtrlMask */

typedef struct {
	uByte		bLength;
	uByte		bDescriptorType;
	uWord		bcdUSB;
	uByte		bDeviceClass;
	uByte		bDeviceSubClass;
	uByte		bDeviceProtocol;
	uByte		bMaxPacketSize0;
	uByte		bNumConfigurations;
	uByte		bReserved;
} UPACKED usb_device_qualifier_t;
#define USB_DEVICE_QUALIFIER_SIZE 10

typedef struct {
	uByte		bLength;
	uByte		bDescriptorType;
	uByte		bmAttributes;
#define UOTG_SRP	0x01
#define UOTG_HNP	0x02
} UPACKED usb_otg_descriptor_t;

/* OTG feature selectors */
#define UOTG_B_HNP_ENABLE	3
#define UOTG_A_HNP_SUPPORT	4
#define UOTG_A_ALT_HNP_SUPPORT	5

typedef struct {
	uWord		wStatus;
/* Device status flags */
#define UDS_SELF_POWERED		0x0001
#define UDS_REMOTE_WAKEUP		0x0002
/* Endpoint status flags */
#define UES_HALT			0x0001
} UPACKED usb_status_t;
#if defined(__CC_NORCROFT) && defined(DISABLE_PACKED)
#define USB_STATUS_SIZE 2 /* Someone should really fix __packed! */
#else
#define USB_STATUS_SIZE sizeof(usb_status_t)
#endif

typedef struct {
	uWord		wHubStatus;
#define UHS_LOCAL_POWER			0x0001
#define UHS_OVER_CURRENT		0x0002
	uWord		wHubChange;
} UPACKED usb_hub_status_t;

typedef struct {
	uWord		wPortStatus;
#define UPS_CURRENT_CONNECT_STATUS	0x0001
#define UPS_PORT_ENABLED		0x0002
#define UPS_SUSPEND			0x0004
#define UPS_OVERCURRENT_INDICATOR	0x0008
#define UPS_RESET			0x0010
#define UPS_PORT_L1			0x0020
#define UPS_PORT_POWER			0x0100
#define UPS_FULL_SPEED			0x0000	/* for completeness */
#define UPS_LOW_SPEED			0x0200
#define UPS_HIGH_SPEED			0x0400
#define UPS_SUPER_SPEED			0x0600
#define UPS_PORT_TEST			0x0800
#define UPS_PORT_INDICATOR		0x1000
	uWord		wPortChange;
#define UPS_C_CONNECT_STATUS		0x0001
#define UPS_C_PORT_ENABLED		0x0002
#define UPS_C_SUSPEND			0x0004
#define UPS_C_OVERCURRENT_INDICATOR	0x0008
#define UPS_C_PORT_RESET		0x0010
#define UPS_C_PORT_L1			0x0020
} UPACKED usb_port_status_t;

/* Device class codes */
#define UDCLASS_IN_INTERFACE	0x00
#define UDCLASS_COMM		0x02
#define UDCLASS_HUB		0x09
#define  UDSUBCLASS_HUB		0x00
#define  UDPROTO_FSHUB		0x00
#define  UDPROTO_HSHUBSTT	0x01
#define  UDPROTO_HSHUBMTT	0x02
#define  UDPROTO_SSHUB		0x03
#define UDCLASS_DIAGNOSTIC	0xdc
#define UDCLASS_WIRELESS	0xe0
#define  UDSUBCLASS_RF		0x01
#define   UDPROTO_BLUETOOTH	0x01
#define UDCLASS_VENDOR		0xff

/* Interface class codes */
#define UICLASS_UNSPEC		0x00

#define UICLASS_AUDIO		0x01
#define  UISUBCLASS_AUDIOCONTROL	1
#define  UISUBCLASS_AUDIOSTREAM		2
#define  UISUBCLASS_MIDISTREAM		3

#define UICLASS_VIDEO		0x0E
#define  UISUBCLASS_VIDEOCONTROL	1
#define  UISUBCLASS_VIDEOSTREAMING	2
#define  UISUBCLASS_VIDEOCOLLECTION	3

#define UICLASS_CDC		0x02 /* communication */
#define	 UISUBCLASS_DIRECT_LINE_CONTROL_MODEL	1
#define  UISUBCLASS_ABSTRACT_CONTROL_MODEL	2
#define	 UISUBCLASS_TELEPHONE_CONTROL_MODEL	3
#define	 UISUBCLASS_MULTICHANNEL_CONTROL_MODEL	4
#define	 UISUBCLASS_CAPI_CONTROLMODEL		5
#define	 UISUBCLASS_ETHERNET_NETWORKING_CONTROL_MODEL 6
#define	 UISUBCLASS_ATM_NETWORKING_CONTROL_MODEL 7
#define	  UIPROTO_CDC_NOCLASS			0 /* no class specific
						     protocol required */
#define   UIPROTO_CDC_AT			1

#define UICLASS_HID		0x03
#define  UISUBCLASS_BOOT	1
#define  UIPROTO_BOOT_KEYBOARD	1
#define  UIPROTO_MOUSE		2

#define UICLASS_PHYSICAL	0x05

#define UICLASS_IMAGE		0x06

#define UICLASS_PRINTER		0x07
#define  UISUBCLASS_PRINTER	1
#define  UIPROTO_PRINTER_UNI	1
#define  UIPROTO_PRINTER_BI	2
#define  UIPROTO_PRINTER_1284	3

#define UICLASS_MASS		0x08
#define  UISUBCLASS_RBC		1
#define  UISUBCLASS_SFF8020I	2
#define  UISUBCLASS_QIC157	3
#define  UISUBCLASS_UFI		4
#define  UISUBCLASS_SFF8070I	5
#define  UISUBCLASS_SCSI	6
#define  UIPROTO_MASS_CBI_I	0
#define  UIPROTO_MASS_CBI	1
#define  UIPROTO_MASS_BBB_OLD	2	/* Not in the spec anymore */
#define  UIPROTO_MASS_BBB	80	/* 'P' for the Iomega Zip drive */

#define UICLASS_HUB		0x09
#define  UISUBCLASS_HUB		0
#define  UIPROTO_FSHUB		0
#define  UIPROTO_HSHUBSTT	0 /* Yes, same as previous */
#define  UIPROTO_HSHUBMTT	1

#define UICLASS_CDC_DATA	0x0a
#define  UISUBCLASS_DATA		0
#define   UIPROTO_DATA_ISDNBRI		0x30    /* Physical iface */
#define   UIPROTO_DATA_HDLC		0x31    /* HDLC */
#define   UIPROTO_DATA_TRANSPARENT	0x32    /* Transparent */
#define   UIPROTO_DATA_Q921M		0x50    /* Management for Q921 */
#define   UIPROTO_DATA_Q921		0x51    /* Data for Q921 */
#define   UIPROTO_DATA_Q921TM		0x52    /* TEI multiplexer for Q921 */
#define   UIPROTO_DATA_V42BIS		0x90    /* Data compression */
#define   UIPROTO_DATA_Q931		0x91    /* Euro-ISDN */
#define   UIPROTO_DATA_V120		0x92    /* V.24 rate adaption */
#define   UIPROTO_DATA_CAPI		0x93    /* CAPI 2.0 commands */
#define   UIPROTO_DATA_HOST_BASED	0xfd    /* Host based driver */
#define   UIPROTO_DATA_PUF		0xfe    /* see Prot. Unit Func. Desc.*/
#define   UIPROTO_DATA_VENDOR		0xff    /* Vendor specific */

#define UICLASS_SMARTCARD	0x0b

/*#define UICLASS_FIRM_UPD	0x0c*/

#define UICLASS_SECURITY	0x0d

#define UICLASS_DIAGNOSTIC	0xdc

#define UICLASS_WIRELESS	0xe0
#define  UISUBCLASS_RF			0x01
#define   UIPROTO_BLUETOOTH		0x01
#define   UIPROTO_RNDIS			0x03

#define UICLASS_APPL_SPEC	0xfe
#define  UISUBCLASS_FIRMWARE_DOWNLOAD	1
#define  UISUBCLASS_IRDA		2
#define  UIPROTO_IRDA			0

#define UICLASS_VENDOR		0xff


#define USB_HUB_MAX_DEPTH 5

/*
 * Minimum time a device needs to be powered down to go through
 * a power cycle.  XXX Are these time in the spec?
 */
#define USB_POWER_DOWN_TIME	200 /* ms */
#define USB_PORT_POWER_DOWN_TIME	100 /* ms */

#if 0
/* These are the values from the spec. */
#define USB_PORT_RESET_DELAY	10  /* ms */
#define USB_PORT_ROOT_RESET_DELAY 50  /* ms */
#define USB_PORT_RESET_RECOVERY	10  /* ms */
#define USB_PORT_POWERUP_DELAY	100 /* ms */
#define USB_SET_ADDRESS_SETTLE	2   /* ms */
#define USB_RESUME_DELAY	(20*5)  /* ms */
#define USB_RESUME_WAIT		10  /* ms */
#define USB_RESUME_RECOVERY	10  /* ms */
#define USB_EXTRA_POWER_UP_TIME	0   /* ms */
#else
/* Allow for marginal (i.e. non-conforming) devices. */
#ifndef __riscos
#define USB_PORT_RESET_DELAY    50  /* ms */
#define USB_PORT_ROOT_RESET_DELAY 250  /* ms */
#define USB_PORT_RESET_RECOVERY 250  /* ms */
#else
/* MUST allow sufficient time for power to really die! */
#define USB_PORT_RESET_DELAY	100  /* 100 ms */  /* 200ms kills chicony kbd */
#define USB_PORT_ROOT_RESET_DELAY	50 /* 50 ms */
#define USB_PORT_RESET_RECOVERY	50 /* 50 ms */
#define USB_PORT_STARTUP_DELAY	100 /* 100 ms */
#endif
#define USB_PORT_POWERUP_DELAY	300 /* 300 ms */
#define USB_SET_ADDRESS_SETTLE	10  /* ms */
#define USB_RESUME_DELAY	(50*5)  /* ms */
#define USB_RESUME_WAIT		50  /* ms */
#define USB_RESUME_RECOVERY	50  /* ms */
#define USB_EXTRA_POWER_UP_TIME	20  /* ms */
#endif

#define USB_MIN_POWER		100 /* mA */
#define USB_MAX_POWER		500 /* mA */

#define USB_BUS_RESET_DELAY	100 /* ms XXX?*/


#define USB_UNCONFIG_NO 0
#define USB_UNCONFIG_INDEX (-1)

/*** ioctl() related stuff ***/

struct usb_ctl_request {
	int	ucr_addr;
	usb_device_request_t ucr_request;
	void	*ucr_data;
	int	ucr_flags;
#define USBD_SHORT_XFER_OK	0x04	/* allow short reads */
	int	ucr_actlen;		/* actual length transferred */
};

struct usb_alt_interface {
	int	uai_config_index;
	int	uai_interface_index;
	int	uai_alt_no;
};

#define USB_CURRENT_CONFIG_INDEX (-1)
#define USB_CURRENT_ALT_INDEX (-1)

struct usb_config_desc {
	int	ucd_config_index;
	usb_config_descriptor_t ucd_desc;
};

struct usb_interface_desc {
	int	uid_config_index;
	int	uid_interface_index;
	int	uid_alt_index;
	usb_interface_descriptor_t uid_desc;
};

struct usb_endpoint_desc {
	int	ued_config_index;
	int	ued_interface_index;
	int	ued_alt_index;
	int	ued_endpoint_index;
	usb_endpoint_descriptor_t ued_desc;
};

struct usb_full_desc {
	int	ufd_config_index;
	u_int	ufd_size;
	u_char	*ufd_data;
};

struct usb_string_desc {
	int	usd_string_index;
	int	usd_language_id;
	usb_string_descriptor_t usd_desc;
};

struct usb_ctl_report_desc {
	int	ucrd_size;
	u_char	ucrd_data[1024];	/* filled data size will vary */
};

typedef struct { u_int32_t cookie; } usb_event_cookie_t;

#define USB_MAX_DEVNAMES 4
#define USB_MAX_DEVNAMELEN 16
struct usb_device_info {
	u_int8_t	udi_bus;
	u_int8_t	udi_addr;	/* device address */
	usb_event_cookie_t udi_cookie;
	char		udi_product[USB_MAX_STRING_LEN];
	char		udi_vendor[USB_MAX_STRING_LEN];
	char		udi_release[8];
	u_int16_t	udi_productNo;
	u_int16_t	udi_vendorNo;
	u_int16_t	udi_releaseNo;
	u_int8_t	udi_class;
	u_int8_t	udi_subclass;
	u_int8_t	udi_protocol;
	u_int8_t	udi_config;
	u_int8_t	udi_speed;
#define USB_SPEED_LOW  1
#define USB_SPEED_FULL 2
#define USB_SPEED_HIGH 3
#define USB_SPEED_SUPER 4
	int		udi_power;	/* power consumption in mA, 0 if selfpowered */
	int		udi_nports;
	char		udi_devnames[USB_MAX_DEVNAMES][USB_MAX_DEVNAMELEN];
	u_int8_t	udi_ports[16];/* hub only: addresses of devices on ports */
#define USB_PORT_ENABLED 0xff
#define USB_PORT_SUSPENDED 0xfe
#define USB_PORT_POWERED 0xfd
#define USB_PORT_DISABLED 0xfc
};

struct usb_ctl_report {
	int	ucr_report;
	u_char	ucr_data[1024];	/* filled data size will vary */
};

struct usb_device_stats {
	u_long	uds_requests[4];	/* indexed by transfer type UE_* */
};

/* Events that can be read from /dev/usb */
struct usb_event {
	int			ue_type;
#define USB_EVENT_CTRLR_ATTACH 1
#define USB_EVENT_CTRLR_DETACH 2
#define USB_EVENT_DEVICE_ATTACH 3
#define USB_EVENT_DEVICE_DETACH 4
#define USB_EVENT_DRIVER_ATTACH 5
#define USB_EVENT_DRIVER_DETACH 6
#define USB_EVENT_IS_ATTACH(n) ((n) == USB_EVENT_CTRLR_ATTACH || (n) == USB_EVENT_DEVICE_ATTACH || (n) == USB_EVENT_DRIVER_ATTACH)
#define USB_EVENT_IS_DETACH(n) ((n) == USB_EVENT_CTRLR_DETACH || (n) == USB_EVENT_DEVICE_DETACH || (n) == USB_EVENT_DRIVER_DETACH)
	struct timespec		ue_time;
	union {
		struct {
			int			ue_bus;
		} ue_ctrlr;
		struct usb_device_info		ue_device;
		struct {
			usb_event_cookie_t	ue_cookie;
			char			ue_devname[16];
		} ue_driver;
	} u;
};

/* USB controller */
#define USB_REQUEST		_IOWR('U', 1, struct usb_ctl_request)
#define USB_SETDEBUG		_IOW ('U', 2, int)
#define USB_DISCOVER		_IO  ('U', 3)
#define USB_DEVICEINFO		_IOWR('U', 4, struct usb_device_info)
#define USB_DEVICESTATS		_IOR ('U', 5, struct usb_device_stats)

/* Generic HID device */
#define USB_GET_REPORT_DESC	_IOR ('U', 21, struct usb_ctl_report_desc)
#define USB_SET_IMMED		_IOW ('U', 22, int)
#define USB_GET_REPORT		_IOWR('U', 23, struct usb_ctl_report)
#define USB_SET_REPORT		_IOW ('U', 24, struct usb_ctl_report)
#define USB_GET_REPORT_ID	_IOR ('U', 25, int)

/* Generic USB device */
#define USB_GET_CONFIG		_IOR ('U', 100, int)
#define USB_SET_CONFIG		_IOW ('U', 101, int)
#define USB_GET_ALTINTERFACE	_IOWR('U', 102, struct usb_alt_interface)
#define USB_SET_ALTINTERFACE	_IOWR('U', 103, struct usb_alt_interface)
#define USB_GET_NO_ALT		_IOWR('U', 104, struct usb_alt_interface)
#define USB_GET_DEVICE_DESC	_IOR ('U', 105, usb_device_descriptor_t)
#define USB_GET_CONFIG_DESC	_IOWR('U', 106, struct usb_config_desc)
#define USB_GET_INTERFACE_DESC	_IOWR('U', 107, struct usb_interface_desc)
#define USB_GET_ENDPOINT_DESC	_IOWR('U', 108, struct usb_endpoint_desc)
#define USB_GET_FULL_DESC	_IOWR('U', 109, struct usb_full_desc)
#define USB_GET_STRING_DESC	_IOWR('U', 110, struct usb_string_desc)
#define USB_DO_REQUEST		_IOWR('U', 111, struct usb_ctl_request)
#define USB_GET_DEVICEINFO	_IOR ('U', 112, struct usb_device_info)
#define USB_SET_SHORT_XFER	_IOW ('U', 113, int)
#define USB_SET_TIMEOUT		_IOW ('U', 114, int)

/* Modem device */
#define USB_GET_CM_OVER_DATA	_IOR ('U', 130, int)
#define USB_SET_CM_OVER_DATA	_IOW ('U', 131, int)

#endif /* _USB_H_ */
@


1.13
log
@Make RHENIUM build switch go away. Misc housekeeping
Detail:
  build/Makefile, build/!MkDebug,fd7 - Debug versions of the modules can now be built just by passing "DEBUG=TRUE" to amu
  build/!MkRhenium,fd7 - Deleted obsolete file
  build/Version - Increased version numbers
  build/c/ehcihal, build/c/ehcimodule, build/c/ohcimodule - Only accept USB controllers if HAL_USBControllerInfo says the struct size is an exact match with what we expect. Rework USB controller enumeration to allow modules to properly support both PCI and HAL controllers being available on the same machine, and without RHENIUM switch (module sources only).
  build/c/ehcimodule - Get rid of remaining RHENIUM bits; RHENIUM flag no longer needed for 32bit wide register reads/writes to be supported
  build/c/ohcimodule, build/cmhg/ohcimodhead, dev/usb/c/ohci - Get rid of remaining RHENIUM bits; RHENIUM flag no longer needed for HAL port power controls to be supported.
  build/c/usbhal, build/c/usbmodule, dev/usb/c/uhub, dev/usb/h/usb_port - Get rid of empty riscos_failed_device function
  build/s/call_veneer, build/s/triggercbs - Use Entry/EXIT macros to avoid single-reg LDM/STM performance warnings. Convert tabs to spaces.
  dev/usb/h/usb - Get rid of RHENIUM switch on USB_PORT_RESET_DELAY. Now always uses non-RHENIUM value of 100ms.
Admin:
  Tested on rev A2 BB-xM, Iyonix, Raspberry Pi


Version 0.71. Tagged as 'NetBSD-0_71'
@
text
@d124 1
d127 2
d132 2
d162 1
a162 1
/* Requests */
d177 2
d185 1
d193 4
a196 1
/* Feature numbers */
d200 3
d209 2
d314 4
a317 1
/* Hub features */
d327 1
d335 1
d421 1
d423 1
d426 1
d435 1
d446 1
d461 5
d474 2
d481 1
d538 1
d560 1
a560 1
#define USB_PORT_ROOT_RESET_DELAY	50  /* ms */
d677 1
@


1.12
log
@Update EHCI driver to NetBSD latest (as of 10/07/2010), improve DeviceFS interface
Detail:
  EHCI driver update:
    dev/usb/c/ehci - Updated to latest NetBSD version, except for revisions 1.134 and 1.135 which are too invasive to merge in without updating the rest of the USB stack. This new version brings lots of bug fixes, and adds (untested on RISC OS) support for EHCI isochronous transfers.
    dev/usb/h/ehcivar - Updated to latest NetBSD version, except for the sc_bus splitting that was held back from the ehci.c update
    dev/usb/h/usb, dev/usb/h/usbdi, dev/usb/usbdivar - partial update to latest as required/possible
    dev/usb/c/usb_quirks, dev/usb/h/ehcireg, dev/usb/h/usb_mem, dev/usb/h/usb_quirks, dev/usb/h/usbhid, dev/usb/usbdevs, dev/usb/devlist2h.awk, dev/wscons/h/wsconsio, dev/wscons/h/wsmousevar - Updated to latest NetBSD versions
    dev/usb/c/usbroothub_subr, dev/usb/h/usbroothub_subr - New files brought in from NetBSD sources for use with new EHCI driver
    build/objehcidriver - Added usbroorhub_subr to EHCI driver
    dev/usb/h/usb_port - Added extra dummy functions as required by new EHCI driver
    dev/build/c/port - Added extra parameter to callout_init as required by new EHCI driver
  DeviceFS improvements:
    build/c/usbmodule - Added DeviceFSCallDevice_GetHandles2 as a replacement for Thomas Milius's backwards-incompatible GetHandles changes. Added DeviceFSCallDevice_GetSetOptions call to control RX padding and TX force-short-xfer features. These features can also be controlled at endpoint creation time by new fields in the filename. Also fixed packet padding to not fill the buffer with garbage or potentially crash when the padded area is more than one packet in length.
  New bus registration API:
    Changes made to the data structures that are shared between the modules means that new checks are needed to ensure USB modules with incompatible APIs are not used with one another.
    build/h/usbdivar - Since this seems to be the file containing the main structures that are shared, it now has a #define at the top indicating the first version of the USBDriver module that implemented the data structures within. This version number is used to check that the driver modules are compatible.
    build/cmhg/usbmodhead, build/h/usbdriver, build/c/usbmodule - Add a new SWI, USBDriver_Version, to return the version number of the USBDriver module. Used for both intra-stack API version checks and can be useful for external code that wants to query DeviceFS feature availability.
    build/c/usbmodule, build/c/ehcimodule, build/c/ohcimodule - Updated USBDriver_RegisterBus SWI and the code that calls it to pass the API version number (as defined in usbdivar.h) to USBDriver when attempting to reigster the bus. USBDriver then ensures the version matches that of itself, and if not refuses to allow the bus to register. EHCI & OHCI modules also check that USBDriver is new enough to implement this behaviour via the USBDriver_Version SWI.
  And finally:
    build/version - Incremented module version numbers.
    build/doc/usb - Updated with details of new features
Admin:
  Tested in ROM softload on Iyonix & beagleboard. Beagleboard hub issues seem to be resolved, and there are no new bugs that I can see.


Version 0.52. Tagged as 'NetBSD-0_52'
@
text
@a540 3
#ifdef RHENIUM
#define USB_PORT_RESET_DELAY	200  /* ms */
#else  /*RHENIUM*/
a541 1
#endif /*RHENIUM*/
@


1.11
log
@Add workaround for incorrect sizeof(usb_status_t), disable debug_set_stamp_debug(TRUE) to fix interrupt issue
Detail:
  build/c/ehcimodule, build/c/ohcimodule, build/c/usbmodule - Make sure that timestamped debug messages aren't used, as they appear to cause interrupts to be briefly enabled, which causes all kinds of problems in sensitive bits of the code.
  dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/h/usb - Because DISABLE_PACKED is being used to compile the USB drivers, sizeof(usb_status_t) was being calculated as 4 bytes instead of 2. Somehow this works fine with the EHCI driver (and presumably the OHCI driver), but it was causing problems with the MUSBDriver, so a hardcoded size of 2 is now used.
Admin:
  Tested on rev C2 beagleboard.


Version 0.48. Tagged as 'NetBSD-0_48'
@
text
@d70 1
a70 1

d230 4
a233 1
#define UC_BUS_POWERED		0x80
d277 2
@


1.10
log
@        An increased delay caused havoc with chicony keyboards in the field
Detail:
        USB_PORT_RESET_DELAY had been increased from 100 to 200ms in previous
        version. This was OK for most devices, and beneficial for some, BUT
        killed the Chicony keyboards shipped with many iyonix.. Delay has
        been reverted to 100ms, and is now run time alterable via the
        USB$PortResetDelay sysvar. This problem did not show up in beta testing!

Admin:  tested by JB with chicony.. delays up to around 160ms work with
        the chicony.
        Castle added IP

Version 0.36. Tagged as 'NetBSD-0_36'
@
text
@d375 5
@


1.9
log
@         changes and bug fixes that came to light following USB2 launch.
Detail:
         - VarVal launching.. string length was incorrectly calculated.
         - USB VarVals now correctly cleared if device failed during
           enumeration, after first SetVarVal call.
         - Triggercbs() modified to check interrupt context and be
           refuse (quietly) to trigger callbacks if interrupts threaded
           (result of possible issue .. but perhaps wise)
         - Added third QueryDelay variable, and an Info file to describe
           what does what.
Admin:
         checked at Castle.. due for extended check via beta test site
         before formal release.

         Castle + D Ellis added IP


Version 0.35. Tagged as 'NetBSD-0_35'
@
text
@d534 1
a534 1
#define USB_PORT_RESET_DELAY	200  /* 100 ms */
@


1.8
log
@        Update of EHCIDriver to current NetBSD, together with needed changes
        in both OHCIDriver and USBDriver.


Detail:
        Code may change before formal release .. will be beta released
        ... Entered to CVS to get new version numbers, and for
        the record.
Admin:
        Castle/netbsd added IP .. will be tested more fully before
        formal release. Still to be verified on Rhenium.


Version 0.31. Tagged as 'NetBSD-0_31'
@
text
@d534 1
a534 1
#define USB_PORT_RESET_DELAY	100  /* ms */
d536 3
a538 2
#define USB_PORT_ROOT_RESET_DELAY	50 /* ms */
#define USB_PORT_RESET_RECOVERY	50 /* ms */
d540 1
a540 1
#define USB_PORT_POWERUP_DELAY	300 /* ms */
@


1.7
log
@Latest stuff from John - mainly Rhenium improvements.

Version 0.26. Tagged as 'NetBSD-0_26'
@
text
@d1 1
a1 1
/*	$NetBSD: usb.h,v 1.69 2002/09/22 23:20:50 augustss Exp $	*/
d525 5
d538 1
@


1.6
log
@Merge of Dan Ellis's USB2 sources.

Version 0.22. Tagged as 'NetBSD-0_22'
@
text
@d525 6
a530 1
#define USB_PORT_RESET_DELAY	50  /* ms */
@


1.5
log
@Update from John:
> Reduce root port reset delay to 50ms from 250ms to work with Chicony
> keyboards (again).  Comment out duplicate free(udev) at end of
> usbmodule:config_detach.

Version 0.20. Tagged as 'NetBSD-0_20'
@
text
@d1 1
a1 1
/*	$NetBSD: usb.h,v 1.50 2000/06/01 15:43:32 augustss Exp $	*/
d50 6
d61 1
a61 15
#elif defined(__FreeBSD__)
#if defined(KERNEL)
#include <sys/malloc.h>

MALLOC_DECLARE(M_USB);
MALLOC_DECLARE(M_USBDEV);
MALLOC_DECLARE(M_USBHC);

#include <dev/usb/usb_port.h>
#endif /* KERNEL */
#endif /* __FreeBSD__ */
#ifdef __riscos
#include <dev/usb/usb_port.h>
#endif

d168 4
d188 1
d192 3
d205 2
d288 4
d308 2
d316 15
a330 9
#define UHD_PWR			0x03
#define UHD_PWR_GANGED		0x00
#define UHD_PWR_INDIVIDUAL	0x01
#define UHD_PWR_NO_SWITCH	0x02
#define UHD_COMPOUND		0x04
#define UHD_OC			0x18
#define UHD_OC_GLOBAL		0x00
#define UHD_OC_INDIVIDUAL	0x08
#define UHD_OC_NONE		0x10
d342 26
d392 3
d404 1
a404 1
#define UDCLASS_AUDIO		0x00
a405 1
#define UDCLASS_HID		0x00
d407 9
a415 2
#define  UDSUBCLASS_HUB		0
#define UDCLASS_MASS		0x00
d441 2
d447 1
d458 2
a459 2
#define  UIPROTO_MASS_BBB	2
#define  UIPROTO_MASS_BBB_P	80	/* 'P' for the Iomega Zip drive */
d463 3
d483 11
a493 1
#define UICLASS_FIRM_UPD	0x0c
d496 4
d516 1
a516 1
#define USB_PORT_RESET_SETTLE	10  /* ms */
d548 4
a551 4
	int	addr;
	usb_device_request_t request;
	void	*data;
	int	flags;
d553 1
a553 1
	int	actlen;		/* actual length transferred */
d557 3
a559 3
	int	config_index;
	int	interface_index;
	int	alt_no;
d566 2
a567 2
	int	config_index;
	usb_config_descriptor_t desc;
d571 4
a574 4
	int	config_index;
	int	interface_index;
	int	alt_index;
	usb_interface_descriptor_t desc;
d578 5
a582 5
	int	config_index;
	int	interface_index;
	int	alt_index;
	int	endpoint_index;
	usb_endpoint_descriptor_t desc;
d586 3
a588 3
	int	config_index;
	u_int	size;
	u_char	*data;
d592 3
a594 3
	int	string_index;
	int	language_id;
	usb_string_descriptor_t desc;
d598 2
a599 2
	int	size;
	u_char	data[1024];	/* filled data size will vary */
d607 21
a627 18
	u_int8_t	bus;
	u_int8_t	addr;	/* device address */
	usb_event_cookie_t cookie;
	char		product[USB_MAX_STRING_LEN];
	char		vendor[USB_MAX_STRING_LEN];
	char		release[8];
	u_int16_t	productNo;
	u_int16_t	vendorNo;
	u_int16_t	releaseNo;
	u_int8_t	class;
	u_int8_t	subclass;
	u_int8_t	protocol;
	u_int8_t	config;
	u_int8_t	lowspeed;
	int		power;	/* power consumption in mA, 0 if selfpowered */
	int		nports;
	char		devnames[USB_MAX_DEVNAMES][USB_MAX_DEVNAMELEN];
	u_int8_t	ports[16];/* hub only: addresses of devices on ports */
d635 2
a636 2
	int	report;
	u_char	data[1024];	/* filled data size will vary */
d640 1
a640 1
	u_long	requests[4];	/* indexed by transfer type UE_* */
d652 2
d679 1
@


1.4
log
@  Support for SCSISoftUSB, and some tidying up.
Detail:
  * Errors now use the allocated error number base, &819000, instead of a
    base in the private range, &50000000. "USB transfer failed" errors now
    have use a sub-range of error numbers from &819020; the original BSD
    error number can be retrieved from the bottom 5 bits of the RISC OS
    error number.
  * Service_USB 1 now returns the list in the order in which the devices,
    rather than in the reverse order as previous versions of the module did.
  * A little tweaking of h/usb_port to reduce compiler warnings.
  * Some compiler-satisfying changes to allow use of packed structures.
    (However, the compiler doesn't seem to work correctly yet, so this is
    currently switched out using -DDISABLE_PACKED on the command line.)
  * Added full stops to end of star command help strings for consistency
    with rest of OS.
  * New exports: USBDevFS (moved here from ^.h) and a few files in dev/usb/h
    and sys/h.
Admin:
  Error number overhaul and new exports are both required by SCSISoftUSB.

Version 0.16. Tagged as 'NetBSD-0_16'
@
text
@d457 1
a457 1
#define USB_PORT_ROOT_RESET_DELAY	250 /* ms */
@


1.3
log
@Put the port reset delay back to 50ms.Not sure why NetBSD decided to change
that but it broke the Chicony keyboard supplied in Castle's Iyonix.

Version 0.15. Tagged as 'NetBSD-0_15'
@
text
@d79 1
d92 1
a92 1
#if 1
d105 6
d116 1
d118 3
d122 1
@


1.2
log
@Nicked a few hub related fixes from later NetBSD versions.
Added stuff to delete the DeviceFS$USB*$Options variables when the module is
RMkilled.

Version 0.12. Tagged as 'NetBSD-0_12'
@
text
@d446 1
a446 1
#define USB_PORT_RESET_RECOVERY	250 /* ms */
@


1.1
log
@Import of USB driver suitable for generic PCI based OHCI controllers.
Correction of spelling of busses to buses (noun plural).
OHCIdriver only responds to PCI service call to lookup vendor name when
the device is of class OHCI controller.

Version 0.01. Tagged as 'NetBSD-0_01'
@
text
@d434 1
d445 3
a447 2
#define USB_PORT_RESET_RECOVERY	50  /* ms */
#define USB_PORT_POWERUP_DELAY	200 /* ms */
@


head	1.16;
access;
symbols
	USBDriver-1_29:1.16
	USBDriver-1_28:1.16
	USBDriver-1_27:1.16
	USBDriver-1_26:1.16
	USBDriver-1_25:1.16
	USBDriver-1_24:1.15
	USBDriver-1_23:1.15
	USBDriver-1_22:1.14
	USBDriver-1_21:1.14
	USBDriver-1_20:1.13
	USBDriver-1_19:1.13
	NetBSD-1_19:1.13
	NetBSD-1_18:1.13
	NetBSD-1_17:1.12
	NetBSD-1_16:1.12
	NetBSD-1_15:1.12
	NetBSD-1_14:1.12
	NetBSD-1_13:1.12
	NetBSD-1_12:1.12
	NetBSD-1_09-1:1.12
	NetBSD-1_11:1.12
	NetBSD-1_10:1.12
	NetBSD-1_09:1.12
	NetBSD-1_08:1.12
	NetBSD-1_07:1.12
	NetBSD-1_06:1.12
	NetBSD-1_05:1.12
	NetBSD-1_04:1.12
	NetBSD-1_03:1.12
	NetBSD-1_02:1.12
	NetBSD-1_01:1.12
	NetBSD-1_00:1.12
	NetBSD-0_99:1.12
	NetBSD-0_98:1.12
	NetBSD-0_97:1.12
	NetBSD-0_96:1.11
	NetBSD-0_95:1.11
	NetBSD-0_94:1.11
	NetBSD-0_93:1.11
	NetBSD-0_92:1.11
	NetBSD-0_91:1.11
	NetBSD-0_90:1.11
	NetBSD-0_89:1.11
	NetBSD-0_88:1.10
	NetBSD-0_87:1.10
	NetBSD-0_86:1.10
	NetBSD-0_85:1.10
	NetBSD-0_84:1.10
	NetBSD-0_83:1.10
	NetBSD-0_82:1.10
	NetBSD-0_81:1.10
	NetBSD-0_80:1.10
	NetBSD-0_79:1.10
	NetBSD-0_78:1.10
	NetBSD-0_77:1.10
	NetBSD-0_76:1.10
	NetBSD-0_75:1.10
	NetBSD-0_74:1.10
	NetBSD-0_73:1.10
	NetBSD-0_72:1.10
	NetBSD-0_71:1.10
	NetBSD-0_70:1.9
	NetBSD-0_69:1.9
	NetBSD-0_68:1.9
	NetBSD-0_67:1.9
	NetBSD-0_66:1.9
	NetBSD-0_65:1.9
	NetBSD-0_64:1.9
	NetBSD-0_63:1.9
	NetBSD-0_62:1.9
	NetBSD-0_61:1.9
	NetBSD-0_60:1.9
	NetBSD-0_59:1.9
	NetBSD-0_58:1.8
	NetBSD-0_57:1.8
	NetBSD-0_56:1.8
	NetBSD-0_55:1.8
	NetBSD-0_54:1.8
	NetBSD-0_53:1.8
	NetBSD-0_52:1.8
	NetBSD-0_51:1.7
	NetBSD-0_50:1.7
	NetBSD-0_49:1.7
	NetBSD-0_48:1.7
	NetBSD-0_47:1.7
	NetBSD-0_46:1.6
	NetBSD-0_45:1.6
	NetBSD-0_44:1.6
	NetBSD-0_43:1.6
	NetBSD-0_42:1.6
	NetBSD-0_41:1.6
	NetBSD-0_40:1.6
	NetBSD-0_39:1.6
	NetBSD-0_38:1.6
	NetBSD-0_37:1.6
	NetBSD-0_36:1.6
	NetBSD-0_35:1.6
	NetBSD-0_34:1.5
	NetBSD-0_33:1.5
	NetBSD-0_32:1.5
	NetBSD-0_31:1.5
	NetBSD-0_30:1.5
	NetBSD-0_29:1.5
	RO_5_07:1.5
	NetBSD-0_28:1.5
	NetBSD-0_27:1.5
	NetBSD-0_26:1.5
	NetBSD-0_25:1.5
	NetBSD-0_24:1.4
	NetBSD-0_23:1.4
	NetBSD-0_21-1_22_2_1:1.3
	NetBSD-0_22:1.4
	USB1:1.3.0.2
	NetBSD-0_21:1.3
	NetBSD-0_20:1.2
	NetBSD-0_19:1.2
	NetBSD-0_18:1.2
	NetBSD-0_17:1.2
	NetBSD-0_16:1.2
	NetBSD-0_15:1.1
	NetBSD-0_14:1.1
	NetBSD-0_13:1.1
	NetBSD-0_12:1.1
	NetBSD-0_11:1.1
	NetBSD-0_10:1.1
	NetBSD-0_09:1.1
	NetBSD-0_08:1.1
	NetBSD-0_07:1.1
	NetBSD-0_06:1.1
	NetBSD-0_05:1.1
	NetBSD-0_04:1.1
	NetBSD-0_03:1.1
	NetBSD-0_02:1.1
	NetBSD-0_01:1.1;
locks; strict;
comment	@# @;


1.16
date	2017.11.18.10.23.36;	author rool;	state Exp;
branches;
next	1.15;
commitid	PT1DhjogFGE4kvfA;

1.15
date	2017.10.07.09.08.50;	author rool;	state Exp;
branches;
next	1.14;
commitid	Qzw5gnXY6CB2g6aA;

1.14
date	2017.08.19.14.39.28;	author rool;	state Exp;
branches;
next	1.13;
commitid	N0fa5xCfC1haFP3A;

1.13
date	2016.12.17.10.13.02;	author rool;	state Exp;
branches;
next	1.12;
commitid	yws6HYEy6os04kyz;

1.12
date	2015.08.14.22.22.25;	author jlee;	state Exp;
branches;
next	1.11;
commitid	NGdbu548pV9NShxy;

1.11
date	2014.10.25.18.43.45;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	SYXBVhhWAW5D5CVx;

1.10
date	2012.06.07.00.11.17;	author jlee;	state Exp;
branches;
next	1.9;
commitid	LkYeKFZjKWlNTH7w;

1.9
date	2011.05.22.20.22.46;	author jlee;	state Exp;
branches;
next	1.8;
commitid	Ye1jVWDlKivFSIkv;

1.8
date	2010.07.21.23.57.21;	author jlee;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.09.19.32.49;	author jlee;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.18.00.35.56;	author jballance;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.06.15.50.23;	author bavison;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.21.20.49.20;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.21.15.23.24;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.14.16.43.52;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.28.09.55.18;	author dellis;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Remove duplicate define
Detail:
  OHCI_DEBUG shouldn't be set here.
Admin:
  Submission for USB bounty.

Version 1.25. Tagged as 'USBDriver-1_25'
@
text
@/* Copyright 2003 Tematic Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*	RISC OS port options
 */

#include "sys/device.h"
#include "errno.h"
#include <sys/ioccom.h>
#include <string.h>
#include <stdbool.h>

#ifdef USB_DEBUG
#define UHID_DEBUG 1
#define UHIDEV_DEBUG 1
#define UGEN_DEBUG 1
#define UHCI_DEBUG 1
#define UHUB_DEBUG 1
#define ULPT_DEBUG 1
#define UCOM_DEBUG 1
#define UMODEM_DEBUG 1
#define UAUDIO_DEBUG 1
#define AUE_DEBUG 1
#define CUE_DEBUG 1
#define KUE_DEBUG 1
#define UMASS_DEBUG 1
#define UPL_DEBUG 1
#define UZCOM_DEBUG 1
#define URIO_DEBUG 1
#define UFTDI_DEBUG 1
#endif

/* always define the functions as global because we access them from RISC OS
   module */
#define Static


/* make these do nothing for RISC OS */
#define	config_pending_incr()
#define	config_pending_decr()
#define le16toh(a) a
#define htole16(a) a
#define le32toh(a) (a)
#define htole32(a) (a)

/* XXX don't know what to do about locks yet */
#define lockinit(a,b,c,d,e)
#define lockmgr(a,b,c)
struct lock { int a; };

#define device_has_power(a) (true)

/* Module builds use bufferable memory and so may need synchronisation
   However, we only need to synchronise in some situations - use the BUS_DMASYNC
   hints to decide when. In many cases the if() will be optimised out.
 */
typedef void (*barrier_func)(void);
extern barrier_func barriers[3];
#define BARRIER_WRITE 1
#define BARRIER_READ 2
#define BUS_DMASYNC_PREREAD 0 /* Device is about to write to memory (e.g. about to read a packet from USB). Technically we need a write barrier here to ensure any buffered write to the area completes before the USB overwrites it, but there should be enough barriers elsewhere that we can get away without it (and having one here will really kill performance)  */
#define BUS_DMASYNC_PREWRITE BARRIER_WRITE /* Device is about to read from memory (e.g. about to write a packet to USB). */
#define BUS_DMASYNC_POSTREAD BARRIER_READ /* Device has finished writing to memory */
#define BUS_DMASYNC_POSTWRITE 0 /* Device has finished reading from memory */
#define usb_syncmem(a,b,c,d) do { int barrier = d; if (barrier) barriers[barrier-1](); } while(0)

extern int hz;

#define splhigh splbio
#define splsoftnet splbio
extern int splbio (void);
extern int spltty (void);
extern void splx (int);
extern int vtophys (void*);
extern void delay (int);
extern struct device* get_softc (int unit);
extern void callout_init (struct callout* c,int ignored);
extern void callout_stop (struct callout *c);
extern void callout_reset (struct callout *c, int i, void (*f)(void *), void *v);
extern int min (int a, int b);
extern struct device* riscos_usb_attach(void*, struct device*, void*);
extern void usb_needs_explore_callback (void*);
extern int config_detach (struct device*, int);
extern void* (config_found) (struct device*, void*, int (*) (void*, const char*));
extern void kill_system_variable (int unit);
extern void riscos_abort_pipe (void*);
extern void riscos_irqclear (int device);

extern int kthread_create (void (*) (void*), void*);
extern int kthread_create1 (void (*) (void*), void*, void*, char*, char*);
extern int kthread_exit (int);

/* copy data using private handle b into memory dma */
extern void bufrem (void* dma, void* b, int size);
extern void bufins (void* dma, void* xfer);

extern void* malloc_contig (int size, int alignment);
#define		usb_allocmem(t,s,a,p)	(*(p) = malloc_contig(s, a), (*(p) == NULL? USBD_NOMEM: USBD_NORMAL_COMPLETION))
extern void free_contig(void **mem);
#define usb_freemem(p, m) free_contig (m)
#define DMAADDR(dma, o)	(vtophys((void*) (((char*) *(dma)) + o)))
#define KERNADDR(dma, o)	((void*) (((char *) *(dma)) + (o)))

int ratecheck (void*, void*);

int config_deactivate (struct device* dev);

#ifdef USB_USE_SOFTINTR
#define __HAVE_GENERIC_SOFT_INTERRUPTS
#define IPL_SOFTNET 0
void* softintr_establish(int, void (*) (void*), void*);
void softintr_schedule (void*);
void softintr_disestablish (void*);
#endif

typedef struct proc *usb_proc_ptr;

typedef struct device *device_ptr_t;
typedef struct device *device_t;
#define USBBASEDEVICE struct device
#define USBDEV(bdev) (&(bdev))
#define USBDEVNAME(bdev) ((bdev).dv_xname)
#define USBDEVUNIT(bdev) ((bdev).dv_unit)
#define USBDEVPTRNAME(bdevptr) ((bdevptr)->dv_xname)
#define USBGETSOFTC(d) ((void *)(d))


typedef struct callout usb_callout_t;
#define usb_callout_init(h)	callout_init(&(h), 0)
#define	usb_callout(h, t, f, d)	callout_reset(&(h), (t), (f), (d))
#define	usb_uncallout(h, f, d)	callout_stop(&(h))

#define clalloc(p, s, x) (clist_alloc_cblocks((p), (s), (s)), 0)
#define clfree(p) clist_free_cblocks((p))

#define usb_kthread_create1	kthread_create1
#define usb_kthread_create	kthread_create

typedef int usb_malloc_type;

#define Ether_ifattach ether_ifattach
#define IF_INPUT(ifp, m) (*(ifp)->if_input)((ifp), (m))

#ifdef USB_DEBUG
#pragma -v1
extern void logprintf(char* format, ...);
#else
#define logprintf(...) 0
#endif

#define USB_DECLARE_DRIVER(dname)  \
int __CONCAT(dname,_match)(struct device *, struct cfdata *, void *); \
void __CONCAT(dname,_attach)(struct device *, struct device *, void *); \
int __CONCAT(dname,_detach)(struct device *, int); \
int __CONCAT(dname,_activate)(struct device *, enum devact); \
\
extern struct cfdriver __CONCAT(dname,_cd); \
\
struct cfattach __CONCAT(dname,_ca) = { \
	sizeof(struct __CONCAT(dname,_softc)), \
	__CONCAT(dname,_match), \
	__CONCAT(dname,_attach), \
	__CONCAT(dname,_detach), \
	__CONCAT(dname,_activate), \
}; \
Static int __CONCAT(dname,_devclass)

#define USB_MATCH(dname) \
int __CONCAT(dname,_match)(struct device *parent, struct cfdata *match, void *aux)

#define USB_MATCH_START(dname, uaa) \
	struct usb_attach_arg *uaa = aux

#define USB_ATTACH(dname) \
void __CONCAT(dname,_attach)(struct device *parent, struct device *self, void *aux)

#define USB_ATTACH_START(dname, sc, uaa) \
	struct __CONCAT(dname,_softc) *sc = \
		(struct __CONCAT(dname,_softc) *)self; \
	struct usb_attach_arg *uaa = aux

/* Returns from attach */
#define USB_ATTACH_ERROR_RETURN	return
#define USB_ATTACH_SUCCESS_RETURN	return

#define USB_ATTACH_SETUP logprintf("Attach setup\n")

#define USB_DETACH(dname) \
int __CONCAT(dname,_detach)(struct device *self, int flags)

#define USB_DETACH_START(dname, sc) \
	struct __CONCAT(dname,_softc) *sc = \
		(struct __CONCAT(dname,_softc) *)self

#define USB_GET_SC_OPEN(dname, unit, sc) \
	sc = (void *) get_softc(unit); \
	if (!sc) \
		return (ENXIO)

#define USB_GET_SC(dname, unit, sc) \
	sc = (void *) get_softc(unit)

#define USB_DO_ATTACH(dev, bdev, parent, args, print, sub) \
        riscos_usb_attach (dev, parent, args)

/* so we don't have to worry about memory allocation types */
#define M_USB 0
#define M_USBDEV 0
#define M_ZERO 0

/* ioctl types */
#ifndef FIONBIO
#define FIONBIO 0
#define FIOASYNC 1
#endif


#ifndef max
#define max(a,b) ((a)>(b)?(a):(b))
#endif
#ifndef min
#define min(a,b) ((a)<(b)?(a):(b))
#endif
@


1.15
log
@Clear up duplicate/unused OHCI/EHCI source files
Detail:
  Remove the (now) unused sources from when this component produced multiple targets. See Controllers/OHCIDriver & Controllers/EHCIDriver for the live copies.
  Remove unset USBHAL defines.
  Simplify the Makefile and !Mk* scripts.
  No longer export usbroothub_subr.h.
  Add a porting type "device_t" to usb_port.h.
Admin:
  Submission for USB bounty.

Version 1.23. Tagged as 'USBDriver-1_23'
@
text
@a26 1
#define OHCI_DEBUG 1
a234 3


//#define UMATCH_GENERIC 1
@


1.14
log
@Changes to header exports
Detail:
  Export usbroothub_subr.h, for those HC's that might need it.
  Export C version of usbhal.h, in addition to the assembler Hdr version, for MUSBDriver.
  Eliminate the dependency on opt_usbverbose.h - an empty header file - by merging the change from usb_subr.c revision 1.186 from NetBSD which guards it with internal _KERNEL_OPT (unset).
Admin:
  Submission for USB bounty.

Version 1.21. Tagged as 'USBDriver-1_21'
@
text
@a64 4
#ifdef USBHAL
/* Dummy macro should be all that we need for now */
#define usb_syncmem(a,b,c,d) {}
#else
a77 1
#endif
a97 2

#ifndef USBHAL
a99 1
#endif
d131 1
a162 6
#ifdef USBHAL
#define halconst const
#else
#define halconst
#endif

d169 1
a169 1
extern halconst struct cfdriver __CONCAT(dname,_cd); \
d171 1
a171 1
halconst struct cfattach __CONCAT(dname,_ca) = { \
@


1.13
log
@Messages fixes, internationalisation, minor clean ups
Detail:
  USBDriver was performing unnecessary messages file reopening on Service_ResourceFSStarted (MessageTrans does this itself), remove this.
  Internationalised USBDriver, in particular its *Commands.
  Fixed standalone builds to output the messages file objects in the right place (Makefile mistake).
  Changed OHCIDriver and EHCIDriver to use allocated error bases rather than 0.
  Sync'd, where possible, the OHCIDriver and EHCIDriver sources which share a common heritage. Tentative shared interrupt support fixes for non-PCI attached controllers. Comment blocks & indentation improved.
  Export min() macro in usb_port.h.
  CMHG updated to not listen for unwanted services.
Admin:
  Submission for USB bounty.
  Tested on Pandaboard and Pi 2. OHCIDriver untested but low risk.

Version 1.18. Tagged as 'NetBSD-1_18'
@
text
@a17 1
#include "opt_usbverbose.h"
@


1.12
log
@Add memory barriers
Detail:
  dev/usb/h/usb_port - Implement usb_syncmem to call the appropriate memory barrier function. Required for when PCI_RAMAlloc starts returning Normal, non-cacheable memory rather than Device (although technically these barriers have always been needed for ARMv6+)
  build/c/port - Memory barrier implementation; uses the appropriate OS routine if available, otherwise uses a null op.
  build/Version - Bump EHCIDriver version number (the only module that uses these barriers so far)
Admin:
  Tested on BB-xM, PandaBoard


Version 0.97. Tagged as 'NetBSD-0_97'
@
text
@d247 3
@


1.11
log
@Update to use rationalised power and overcurrent API
OHCIDriver (only) had sketchy support for a HAL based scheme for controlling the port power and monitor overcurrent. However the implementation was limited to supporting the single port required for an embedded product (aka Rhenium in the CVS history). The change makes it follow a model much more akin to the HAL_TimerDevice/HAL_TimerIRQStatus/HAL_TimerIRQClear set of functions.
Version:
  Bumped OHCIDriver and USBDriver version numbers.
ohcimodule.c:
  Use some defines from OsBytes.h.
  Group the debug variables within the OHCI_DEBUG define so they go away in the release case.
  Allow for up to 15 ports to be controlled via the revised HAL API, and pass something other than a hardwired controller of 0 when controlling/monitoring power.
  Enumerate the device numbers for overcurrent monitoring on startup.
  Deal with the possibility of one (or more) of the device numbers being shared interrupts.
  Squash a few trivial compiler warnings.
ohcimodhead.cmhg:
  rename the handler/entry to reflect their use for overcurrent
ohci.c:
  Allow for up to 15 ports to be controlled by passing in the port index where needed.
usb_subr.c/usbdivar.h:
  Remove a RISC OS-ism in datatoggle, to converge with NetBSD a bit.
ehcivar.h/usb_port.h:
  Relocate the overrides for mutex_ functions here since this is the only controller using them. Previously when in "usb_port.h" they would indirectly get dragged in ia the nested include in "usb.h". The could in fact now be implemented using SyncLib, an exercise left to the reader.
usb.h
  Merge some of the device classes and other allocations from NetBSD.

While it's not been possible to test the revised API, due to not having sight of the original platform on which it was implemented, none of the actively maintained HALs currently use the HAL based power and overcurrent scheme anyway, so the new code never gets called. In that respect, it's no more broken then the previous single port-single controller version.

Version 0.89. Tagged as 'NetBSD-0_89'
@
text
@d66 1
d69 15
@


1.10
log
@Make RHENIUM build switch go away. Misc housekeeping
Detail:
  build/Makefile, build/!MkDebug,fd7 - Debug versions of the modules can now be built just by passing "DEBUG=TRUE" to amu
  build/!MkRhenium,fd7 - Deleted obsolete file
  build/Version - Increased version numbers
  build/c/ehcihal, build/c/ehcimodule, build/c/ohcimodule - Only accept USB controllers if HAL_USBControllerInfo says the struct size is an exact match with what we expect. Rework USB controller enumeration to allow modules to properly support both PCI and HAL controllers being available on the same machine, and without RHENIUM switch (module sources only).
  build/c/ehcimodule - Get rid of remaining RHENIUM bits; RHENIUM flag no longer needed for 32bit wide register reads/writes to be supported
  build/c/ohcimodule, build/cmhg/ohcimodhead, dev/usb/c/ohci - Get rid of remaining RHENIUM bits; RHENIUM flag no longer needed for HAL port power controls to be supported.
  build/c/usbhal, build/c/usbmodule, dev/usb/c/uhub, dev/usb/h/usb_port - Get rid of empty riscos_failed_device function
  build/s/call_veneer, build/s/triggercbs - Use Entry/EXIT macros to avoid single-reg LDM/STM performance warnings. Convert tabs to spaces.
  dev/usb/h/usb - Get rid of RHENIUM switch on USB_PORT_RESET_DELAY. Now always uses non-RHENIUM value of 100ms.
Admin:
  Tested on rev A2 BB-xM, Iyonix, Raspberry Pi


Version 0.71. Tagged as 'NetBSD-0_71'
@
text
@a62 6
/* XXX now we have to worry about our lack of support for mutexes too */
#define mutex_init(a,b,c)
#define mutex_destroy(a)
#define mutex_enter(a)
#define mutex_exit(a)
typedef struct { int a; } kmutex_t;
@


1.9
log
@Add the ability to build the USB drivers as HAL-compatible static libraries
Detail:
  build/Makefile, build/OBJEHCIDriver, build/OBJOHCIDriver, build/OBJUSBDriver - Modified makefiles to build the HAL libs during the export libs phase
  build/!MkHAL,fd7 - Handy script for building the HAL libs
  build/Hdr/usbhal - Header containing definitions for the assembler code. Also gets exported so that HALs know how much workspace to reserve.
  build/c/usbhal - HAL version of usbmodule.c & port.c. Also contains the keyboard scan code, adapted from the code in the Tungsten HAL.
  build/s/porthal - Assembler versions of some port.c routines that were easier to do in assembler than C
  build/s/halheap - OS_Heap code that's been adapted for use in the HAL. Could easily be changed into a standalone library instead of being part of the HAL USB libs. Supports memory-efficient allocation of aligned blocks.
  build/c/ehcihal - HAL version of ehcimodule.c. Currently only supports EHCI controllers exposed via HAL_USBControllerInfo (i.e. no PCI support)
  build/c/ehcimodule, build/c/ohcimodule, build/c/port - Moved riscos_irq_clear into port.c. Removed unused microtime() function.
  build/c/usbmouse - Strip out some debug-related code in non-debug builds
  build/Version - Updated version numbers
  dev/usb/c/ehci, dev/usb/h/ehcivar - Adapted to add support for the HAL build. Apart from the base changes, the code has also been tweaked to significantly reduce the amount of memory used at runtime by the HAL version of the driver.
  dev/usb/c/hid, dev/usb/c/uhub, dev/usb/c/usb, dev/usb/c/usb_quirks, dev/usb/c/usb_subr, dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/c/usbroothub_subr - Changes to support HAL builds. Mainly disabling bits that won't work in the HAL or disabling bits for RISC OS in general if they weren't being used in the first place.
  dev/usb/c/ohci, dev/usb/h/ohcivar - Basic changes to support HAL builds. However HAL OHCI support is still incomplete.
  dev/usb/h/usb_port - Added support for the HAL build. Also tweaked logprintf definition to get rid of logprintf calls entirely in non-debug builds.
  dev/usb/h/usbdivar - Added support for the HAL build.
  dev/usb/h/usbhal - New header used by the HAL build. Gets included by every C file to ensure the compiler doesn't use sb, and contains structs/macros to allow access to the shared workspace.
Admin:
  HAL & non-HAL builds tested on rev C2 BB, rev A2 BB-xM, rev C1 TouchBook.
  Non-HAL builds tested with Iyonix ROM softload.
  Needs latest Kernel source for OSEntries.h export.


Version 0.59. Tagged as 'NetBSD-0_59'
@
text
@a98 1
extern void riscos_failed_device (void*);
@


1.8
log
@Update EHCI driver to NetBSD latest (as of 10/07/2010), improve DeviceFS interface
Detail:
  EHCI driver update:
    dev/usb/c/ehci - Updated to latest NetBSD version, except for revisions 1.134 and 1.135 which are too invasive to merge in without updating the rest of the USB stack. This new version brings lots of bug fixes, and adds (untested on RISC OS) support for EHCI isochronous transfers.
    dev/usb/h/ehcivar - Updated to latest NetBSD version, except for the sc_bus splitting that was held back from the ehci.c update
    dev/usb/h/usb, dev/usb/h/usbdi, dev/usb/usbdivar - partial update to latest as required/possible
    dev/usb/c/usb_quirks, dev/usb/h/ehcireg, dev/usb/h/usb_mem, dev/usb/h/usb_quirks, dev/usb/h/usbhid, dev/usb/usbdevs, dev/usb/devlist2h.awk, dev/wscons/h/wsconsio, dev/wscons/h/wsmousevar - Updated to latest NetBSD versions
    dev/usb/c/usbroothub_subr, dev/usb/h/usbroothub_subr - New files brought in from NetBSD sources for use with new EHCI driver
    build/objehcidriver - Added usbroorhub_subr to EHCI driver
    dev/usb/h/usb_port - Added extra dummy functions as required by new EHCI driver
    dev/build/c/port - Added extra parameter to callout_init as required by new EHCI driver
  DeviceFS improvements:
    build/c/usbmodule - Added DeviceFSCallDevice_GetHandles2 as a replacement for Thomas Milius's backwards-incompatible GetHandles changes. Added DeviceFSCallDevice_GetSetOptions call to control RX padding and TX force-short-xfer features. These features can also be controlled at endpoint creation time by new fields in the filename. Also fixed packet padding to not fill the buffer with garbage or potentially crash when the padded area is more than one packet in length.
  New bus registration API:
    Changes made to the data structures that are shared between the modules means that new checks are needed to ensure USB modules with incompatible APIs are not used with one another.
    build/h/usbdivar - Since this seems to be the file containing the main structures that are shared, it now has a #define at the top indicating the first version of the USBDriver module that implemented the data structures within. This version number is used to check that the driver modules are compatible.
    build/cmhg/usbmodhead, build/h/usbdriver, build/c/usbmodule - Add a new SWI, USBDriver_Version, to return the version number of the USBDriver module. Used for both intra-stack API version checks and can be useful for external code that wants to query DeviceFS feature availability.
    build/c/usbmodule, build/c/ehcimodule, build/c/ohcimodule - Updated USBDriver_RegisterBus SWI and the code that calls it to pass the API version number (as defined in usbdivar.h) to USBDriver when attempting to reigster the bus. USBDriver then ensures the version matches that of itself, and if not refuses to allow the bus to register. EHCI & OHCI modules also check that USBDriver is new enough to implement this behaviour via the USBDriver_Version SWI.
  And finally:
    build/version - Incremented module version numbers.
    build/doc/usb - Updated with details of new features
Admin:
  Tested in ROM softload on Iyonix & beagleboard. Beagleboard hub issues seem to be resolved, and there are no new bugs that I can see.


Version 0.52. Tagged as 'NetBSD-0_52'
@
text
@d85 3
a87 3
extern int callout_init (void*,int);
extern int callout_stop (void*);
extern void callout_reset (void*, int, void (*f)(void *), void *v);
d95 1
d97 2
a99 1
extern void riscos_irqclear (void);
d155 1
d158 9
d174 1
a174 1
extern struct cfdriver __CONCAT(dname,_cd); \
d176 1
a176 1
struct cfattach __CONCAT(dname,_ca) = { \
@


1.7
log
@Add support for HAL enumerated USB EHCI controllers, use HAL_IRQClear when clearing EHCI/OHCI controller interrupts
Detail:
  * HAL enumeration of EHCI controllers is performed in the same manner as for OHCI, and protected by #ifdef RHENIUM. HAL_USBControllerInfo must return with the usbinfo type field set to 1 to indicate EHCI.
  * HAL_IRQClear is now called by the EHCI & OHCI modules after clearing the interrupt flag in the USB controller, to allow the HAL to reset the interrupt controller if required (e.g. for OMAP3)
  * EHCI module (for HAL EHCI controllers) now has the option of forcing all EHCI register access to be 32bit size & alignment (requirement is indicated in OMAP3 TRM, although USB did seem to function fine without)
  build/c/ehcimodule - Add enumeration of HAL USB controllers. Add support for forcing all EHCI register access to be 32bit size & alignment. Add riscos_irqclear() implementation. Guard against unexpected behaviour if PCI module isn't present.
  build/c/ohcimodule - Add riscos_irqclear() implementation. Guard against unexpected behaviour if PCI module isn't present.
  dev/usb/c/ehci, dev/usb/c/ohci - call riscos_irqclear() when appropriate
  dev/usb/h/usb_port - riscos_irqclear() prototype
Admin:
  Tested on rev C2 beagleboard. Untested on Iyonix, but should be fine.


Version 0.47. Tagged as 'NetBSD-0_47'
@
text
@d23 1
d63 11
d85 1
a85 1
extern int callout_init (void*);
a135 2
#define DECLARE_USB_DMA_T typedef void * usb_dma_t

d138 1
a138 1
#define usb_callout_init(h)	callout_init(&(h))
d223 3
a225 2


@


1.6
log
@         changes and bug fixes that came to light following USB2 launch.
Detail:
         - VarVal launching.. string length was incorrectly calculated.
         - USB VarVals now correctly cleared if device failed during
           enumeration, after first SetVarVal call.
         - Triggercbs() modified to check interrupt context and be
           refuse (quietly) to trigger callbacks if interrupts threaded
           (result of possible issue .. but perhaps wise)
         - Added third QueryDelay variable, and an Info file to describe
           what does what.
Admin:
         checked at Castle.. due for extended check via beta test site
         before formal release.

         Castle + D Ellis added IP


Version 0.35. Tagged as 'NetBSD-0_35'
@
text
@d85 1
@


1.5
log
@  New versions from John.
Detail:
  * All modules will now rmkill/rmload more reliably
  * Keyboard driver disables kernel debounce on new enough kernels, needed
    for many PS2-USB adaptors, bar code scanners etc
  * Mouse driver will scroll wheel scroll any windows that do respond to
    scroll events, otherwise it issues PointerReason_WheelChange (9) to an
    external WimpScroll module
  * Several bugs and an interrupt hole resolved
Admin:
  Tested at Framlingham.

Version 0.25. Tagged as 'NetBSD-0_25'
@
text
@d77 1
a77 1
extern struct device* riscos_usb_attach(struct device*, void*);
d81 1
d198 1
a198 1
        riscos_usb_attach (parent, args)
@


1.4
log
@Merge of Dan Ellis's USB2 sources.

Version 0.22. Tagged as 'NetBSD-0_22'
@
text
@d26 1
d83 1
@


1.3
log
@  Changes to work with TCPIPLibs 5.47.
Detail:
  NetBSD/FreeBSD differences in the naming of certain macros are now resolved
  in TCPIPLibs instead of locally. Also some reordering in the !Mk files in
  order to work with current versions of Zap.
Admin:
  Builds against TCPIPLibs 5.47. Note that this version of the USB sources
  also now requires TCPIPLibs 5.47.

Version 0.21. Tagged as 'NetBSD-0_21'
@
text
@d54 7
d64 2
d79 3
a81 1
extern void* config_found (struct device*, void*, int (*) (void*, const char*));
d95 2
a96 2
#define DMAADDR(dma)	(vtophys(*(dma)))
#define KERNADDR(dma)	((void *) *(dma))
d102 10
d160 1
a160 5
int \
__CONCAT(dname,_match)( \
	struct device *parent, \
	struct cfdata *match, \
	void *aux)
d166 1
a166 5
void \
__CONCAT(dname,_attach)( \
	struct device *parent, \
	struct device *self, \
	void *aux)
d180 1
a180 4
int \
__CONCAT(dname,_detach)( \
	struct device *self, \
	int flags)
d200 1
@


1.2
log
@  Support for SCSISoftUSB, and some tidying up.
Detail:
  * Errors now use the allocated error number base, &819000, instead of a
    base in the private range, &50000000. "USB transfer failed" errors now
    have use a sub-range of error numbers from &819020; the original BSD
    error number can be retrieved from the bottom 5 bits of the RISC OS
    error number.
  * Service_USB 1 now returns the list in the order in which the devices,
    rather than in the reverse order as previous versions of the module did.
  * A little tweaking of h/usb_port to reduce compiler warnings.
  * Some compiler-satisfying changes to allow use of packed structures.
    (However, the compiler doesn't seem to work correctly yet, so this is
    currently switched out using -DDISABLE_PACKED on the command line.)
  * Added full stops to end of star command help strings for consistency
    with rest of OS.
  * New exports: USBDevFS (moved here from ^.h) and a few files in dev/usb/h
    and sys/h.
Admin:
  Error number overhaul and new exports are both required by SCSISoftUSB.

Version 0.16. Tagged as 'NetBSD-0_16'
@
text
@a186 14
#define SIMPLEQ_REMOVE_HEAD(h, e, f)	do {				\
		if ( (e) != SIMPLEQ_FIRST((h)) )			\
			panic("Removing other than first element");	\
		STAILQ_REMOVE_HEAD(h, f);				\
} while (0)
#define SIMPLEQ_INSERT_HEAD	STAILQ_INSERT_HEAD
#define SIMPLEQ_INSERT_TAIL	STAILQ_INSERT_TAIL
#define SIMPLEQ_NEXT		STAILQ_NEXT
#define SIMPLEQ_FIRST		STAILQ_FIRST
#define SIMPLEQ_HEAD		STAILQ_HEAD
#define SIMPLEQ_INIT		STAILQ_INIT
#define SIMPLEQ_HEAD_INITIALIZER	STAILQ_HEAD_INITIALIZER
#define SIMPLEQ_ENTRY		STAILQ_ENTRY

@


1.1
log
@Import of USB driver suitable for generic PCI based OHCI controllers.
Correction of spelling of busses to buses (noun plural).
OHCIdriver only responds to PCI service call to lookup vendor name when
the device is of class OHCI controller.

Version 0.01. Tagged as 'NetBSD-0_01'
@
text
@d140 4
a143 4
__CONCAT(dname,_match)(parent, match, aux) \
	struct device *parent; \
	struct cfdata *match; \
	void *aux;
d150 4
a153 4
__CONCAT(dname,_attach)(parent, self, aux) \
	struct device *parent; \
	struct device *self; \
	void *aux;
d168 3
a170 3
__CONCAT(dname,_detach)(self, flags) \
	struct device *self; \
	int flags;
d216 1
a216 1
#define UMATCH_GENERIC 1
@


head	1.26;
access;
symbols
	USBDriver-1_29:1.26
	USBDriver-1_28:1.26
	USBDriver-1_27:1.26
	USBDriver-1_26:1.26
	USBDriver-1_25:1.26
	USBDriver-1_24:1.26
	USBDriver-1_23:1.26
	USBDriver-1_22:1.25
	USBDriver-1_21:1.25
	USBDriver-1_20:1.24
	USBDriver-1_19:1.24
	NetBSD-1_19:1.24
	NetBSD-1_18:1.24
	NetBSD-1_17:1.24
	NetBSD-1_16:1.24
	NetBSD-1_15:1.24
	NetBSD-1_14:1.23
	NetBSD-1_13:1.23
	NetBSD-1_12:1.23
	NetBSD-1_09-1:1.23
	NetBSD-1_11:1.22
	NetBSD-1_10:1.22
	NetBSD-1_09:1.21
	NetBSD-1_08:1.21
	NetBSD-1_07:1.20
	NetBSD-1_06:1.20
	NetBSD-1_05:1.20
	NetBSD-1_04:1.20
	NetBSD-1_03:1.20
	NetBSD-1_02:1.20
	NetBSD-1_01:1.20
	NetBSD-1_00:1.20
	NetBSD-0_99:1.20
	NetBSD-0_98:1.20
	NetBSD-0_97:1.20
	NetBSD-0_96:1.20
	NetBSD-0_95:1.20
	NetBSD-0_94:1.20
	NetBSD-0_93:1.20
	NetBSD-0_92:1.20
	NetBSD-0_91:1.20
	NetBSD-0_90:1.20
	NetBSD-0_89:1.20
	NetBSD-0_88:1.19
	NetBSD-0_87:1.19
	NetBSD-0_86:1.19
	NetBSD-0_85:1.19
	NetBSD-0_84:1.19
	NetBSD-0_83:1.19
	NetBSD-0_82:1.19
	NetBSD-0_81:1.18
	NetBSD-0_80:1.18
	NetBSD-0_79:1.18
	NetBSD-0_78:1.18
	NetBSD-0_77:1.18
	NetBSD-0_76:1.18
	NetBSD-0_75:1.18
	NetBSD-0_74:1.18
	NetBSD-0_73:1.18
	NetBSD-0_72:1.18
	NetBSD-0_71:1.18
	NetBSD-0_70:1.18
	NetBSD-0_69:1.18
	NetBSD-0_68:1.18
	NetBSD-0_67:1.18
	NetBSD-0_66:1.18
	NetBSD-0_65:1.18
	NetBSD-0_64:1.18
	NetBSD-0_63:1.18
	NetBSD-0_62:1.18
	NetBSD-0_61:1.18
	NetBSD-0_60:1.18
	NetBSD-0_59:1.18
	NetBSD-0_58:1.17
	NetBSD-0_57:1.17
	NetBSD-0_56:1.17
	NetBSD-0_55:1.17
	NetBSD-0_54:1.17
	NetBSD-0_53:1.17
	NetBSD-0_52:1.17
	NetBSD-0_51:1.17
	NetBSD-0_50:1.17
	NetBSD-0_49:1.17
	NetBSD-0_48:1.17
	NetBSD-0_47:1.17
	NetBSD-0_46:1.17
	NetBSD-0_45:1.16
	NetBSD-0_44:1.15
	NetBSD-0_43:1.15
	NetBSD-0_42:1.14
	NetBSD-0_41:1.14
	NetBSD-0_40:1.14
	NetBSD-0_39:1.14
	NetBSD-0_38:1.13
	NetBSD-0_37:1.12
	NetBSD-0_36:1.12
	NetBSD-0_35:1.11
	NetBSD-0_34:1.10
	NetBSD-0_33:1.10
	NetBSD-0_32:1.9
	NetBSD-0_31:1.9
	NetBSD-0_30:1.8
	NetBSD-0_29:1.8
	RO_5_07:1.8
	NetBSD-0_28:1.8
	NetBSD-0_27:1.7
	NetBSD-0_26:1.7
	NetBSD-0_25:1.7
	NetBSD-0_24:1.6
	NetBSD-0_23:1.6
	NetBSD-0_21-1_22_2_1:1.4
	NetBSD-0_22:1.5
	USB1:1.4.0.2
	NetBSD-0_21:1.4
	NetBSD-0_20:1.4
	NetBSD-0_19:1.4
	NetBSD-0_18:1.4
	NetBSD-0_17:1.4
	NetBSD-0_16:1.3
	NetBSD-0_15:1.2
	NetBSD-0_14:1.2
	NetBSD-0_13:1.2
	NetBSD-0_12:1.2
	NetBSD-0_11:1.1
	NetBSD-0_10:1.1
	NetBSD-0_09:1.1
	NetBSD-0_08:1.1
	NetBSD-0_07:1.1
	NetBSD-0_06:1.1
	NetBSD-0_05:1.1
	NetBSD-0_04:1.1
	NetBSD-0_03:1.1
	NetBSD-0_02:1.1
	NetBSD-0_01:1.1;
locks; strict;
comment	@# @;


1.26
date	2017.10.07.09.08.47;	author rool;	state Exp;
branches;
next	1.25;
commitid	Qzw5gnXY6CB2g6aA;

1.25
date	2017.08.19.14.39.26;	author rool;	state Exp;
branches;
next	1.24;
commitid	N0fa5xCfC1haFP3A;

1.24
date	2016.06.02.21.01.16;	author rsprowson;	state Exp;
branches;
next	1.23;
commitid	Lesq5d7XLhs21W8z;

1.23
date	2016.03.04.20.54.42;	author rool;	state Exp;
branches;
next	1.22;
commitid	MvG9A9da0K4NQmXy;

1.22
date	2016.03.04.01.30.11;	author jballance;	state Exp;
branches;
next	1.21;
commitid	NFICmxi3aahBqgXy;

1.21
date	2015.11.15.09.42.44;	author rool;	state Exp;
branches;
next	1.20;
commitid	QBgP4ciWEprNGaJy;

1.20
date	2014.10.25.18.43.42;	author rsprowson;	state Exp;
branches;
next	1.19;
commitid	SYXBVhhWAW5D5CVx;

1.19
date	2014.04.26.11.34.13;	author jlee;	state Exp;
branches;
next	1.18;
commitid	nal1f0Yk6B22zbyx;

1.18
date	2011.05.22.20.22.42;	author jlee;	state Exp;
branches;
next	1.17;
commitid	Ye1jVWDlKivFSIkv;

1.17
date	2006.02.22.09.24.35;	author jballance;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.05.12.43.04;	author jballance;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.30.22.39.55;	author dellis;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.24.23.13.54;	author jballance;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.05.00.24.12;	author jballance;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.23.00.01.59;	author jballance;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.18.00.35.56;	author jballance;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.21.22.30.19;	author jballance;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.30.02.34.20;	author jballance;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.12.14.47.41;	author jballance;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.06.15.50.23;	author bavison;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.16.15.43.50;	author kbracey;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.21.20.49.19;	author bavison;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.23.18.20.46;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.14.16.43.50;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.11.09.17.44;	author rsprowson;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.28.09.55.17;	author dellis;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Clear up duplicate/unused OHCI/EHCI source files
Detail:
  Remove the (now) unused sources from when this component produced multiple targets. See Controllers/OHCIDriver & Controllers/EHCIDriver for the live copies.
  Remove unset USBHAL defines.
  Simplify the Makefile and !Mk* scripts.
  No longer export usbroothub_subr.h.
  Add a porting type "device_t" to usb_port.h.
Admin:
  Submission for USB bounty.

Version 1.23. Tagged as 'USBDriver-1_23'
@
text
@/*      $NetBSD: usb_subr.c,v 1.122 2005/03/04 05:03:19 mycroft Exp $   */
/*	$FreeBSD: src/sys/dev/usb/usb_subr.c,v 1.18 1999/11/17 22:33:47 n_hibma Exp $	*/

/*
 * Copyright (c) 1998, 2004 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/cdefs.h>
//__KERNEL_RCSID(0, "$NetBSD: usb_subr.c,v 1.122 2005/03/04 05:03:19 mycroft Exp $");

#ifdef _KERNEL_OPT
#include "opt_compat_netbsd.h"
#include "opt_usbverbose.h"
#include "opt_usb.h"
#endif

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#if defined(__NetBSD__) || defined(__OpenBSD__)
#include <sys/device.h>
#include <sys/select.h>
#elif defined(__FreeBSD__)
#include <sys/module.h>
#include <sys/bus.h>
#endif
#include <sys/proc.h>

#include <machine/bus.h>

#include <dev/usb/usb.h>

#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/usb_quirks.h>

#if defined(__FreeBSD__)
#include <machine/clock.h>
#define delay(d)         DELAY(d)
#endif

#if defined (__riscos)
#include <stdio.h>
#endif
#ifdef USB_DEBUG
#define DPRINTF(x)	if (usbdebug) logprintf x
#define DPRINTFN(n,x)	if (usbdebug>(n)) logprintf x
extern int usbdebug;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#ifdef __riscos
#define printf  logprintf
#endif

Static usbd_status usbd_set_config(usbd_device_handle, int);
Static void usbd_devinfo_vp(usbd_device_handle, char *, size_t, char *,
        size_t, int);
#ifdef __riscos
Static char *usbd_get_string(usbd_device_handle, int, char *);
#endif
Static int usbd_getnewaddr(usbd_bus_handle bus);
#if defined(__NetBSD__)
Static int usbd_print(void *, const char *);
Static int usbd_submatch(device_ptr_t, struct cfdata *,
                         const locdesc_t *, void *);
#elif defined(__OpenBSD__)
Static int usbd_print(void *aux, const char *pnp);
Static int usbd_submatch(device_ptr_t, void *, void *);
#endif
Static void usbd_free_iface_data(usbd_device_handle dev, int ifcno);
Static void usbd_kill_pipe(usbd_pipe_handle);
Static usbd_status usbd_probe_and_attach(device_ptr_t parent,
				 usbd_device_handle dev, int port, int addr);

#ifndef __riscos
Static u_int32_t usb_cookie_no = 0;
#endif

#ifdef USBVERBOSE
typedef u_int16_t usb_vendor_id_t;
typedef u_int16_t usb_product_id_t;

/*
 * Descriptions of of known vendors and devices ("products").
 */
struct usb_vendor {
        usb_vendor_id_t         vendor;
        char                    *vendorname;
};
struct usb_product {
	usb_vendor_id_t		vendor;
	usb_product_id_t	product;
        char                    *productname;
};

#include <dev/usb/usbdevs_data.h>
#endif /* USBVERBOSE */

Static const char * const usbd_error_strs[] = {
	"NORMAL_COMPLETION",
	"IN_PROGRESS",
	"PENDING_REQUESTS",
	"NOT_STARTED",
	"INVAL",
	"NOMEM",
	"CANCELLED",
	"BAD_ADDRESS",
	"IN_USE",
	"NO_ADDR",
	"SET_ADDR_FAILED",
	"NO_POWER",
	"TOO_DEEP",
	"IOERROR",
	"NOT_CONFIGURED",
	"TIMEOUT",
	"SHORT_XFER",
	"STALLED",
	"INTERRUPTED",
	"XXX",
};

const char *
usbd_errstr(usbd_status err)
{
	static char buffer[5];

	if (err < USBD_ERROR_MAX) {
		return usbd_error_strs[err];
	} else {
		snprintf(buffer, sizeof buffer, "%d", err);
		return buffer;
	}
}

usbd_status
usbd_get_string_desc(usbd_device_handle dev, int sindex, int langid,
                     usb_string_descriptor_t *sdesc, int *sizep)
{
	usb_device_request_t req;
	usbd_status err;
	int actlen;

	req.bmRequestType = UT_READ_DEVICE;
	req.bRequest = UR_GET_DESCRIPTOR;
	USETW2(req.wValue, UDESC_STRING, sindex);
	USETW(req.wIndex, langid);
	USETW(req.wLength, 2);	/* only size byte first */
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
        err = usbd_do_request_flags(dev, &req, (void*)sdesc, USBD_SHORT_XFER_OK,
                &actlen, USBD_DEFAULT_TIMEOUT);
#else
	err = usbd_do_request_flags(dev, &req, sdesc, USBD_SHORT_XFER_OK,
		&actlen, USBD_DEFAULT_TIMEOUT);
#endif
	if (err)
		return (err);

        if (actlen < 2)
		return (USBD_SHORT_XFER);

	USETW(req.wLength, sdesc->bLength);	/* the whole string */
        err = usbd_do_request_flags(dev, &req, sdesc, USBD_SHORT_XFER_OK,
                &actlen, USBD_DEFAULT_TIMEOUT);
        if (err)
                return (err);

        if (actlen != sdesc->bLength) {
                DPRINTFN(-1, ("usbd_get_string_desc: expected %d, got %d\n",
                    sdesc->bLength, actlen));
        }

        *sizep = actlen;
        return (USBD_NORMAL_COMPLETION);
}

#ifdef __riscos
char *
usbd_get_string(usbd_device_handle dev, int si, char *buf)
{
	int swap = dev->quirks->uq_flags & UQ_SWAP_UNICODE;
	usb_string_descriptor_t us;
	char *s;
	int i, n;
	u_int16_t c;
	usbd_status err;
        int size;

	if (si == 0)
		return (0);
	if (dev->quirks->uq_flags & UQ_NO_STRINGS)
		return (0);
	if (dev->langid == USBD_NOLANG) {
		/* Set up default language */
                err = usbd_get_string_desc(dev, USB_LANGUAGE_TABLE, 0, &us,
                    &size);
                if (err || size < 4) {
			dev->langid = 0; /* Well, just pick something then */
		} else {
			/* Pick the first language as the default. */
			dev->langid = UGETW(us.bString[0]);
		}
	}
        err = usbd_get_string_desc(dev, si, dev->langid, &us, &size);
	if (err)
		return (0);
	s = buf;
        n = size / 2 - 1;
	for (i = 0; i < n; i++) {
		c = UGETW(us.bString[i]);
		/* Convert from Unicode, handle buggy strings. */
		if ((c & 0xff00) == 0)
			*s++ = c;
		else if ((c & 0x00ff) == 0 && swap)
			*s++ = c >> 8;
		else
			*s++ = '?';
	}
	*s++ = 0;
	return (buf);
}

#endif
#ifndef __riscos
static void
usbd_trim_spaces(char *p)
{
	char *q, *e;

	if (p == NULL)
		return;
	q = e = p;
	while (*q == ' ')	/* skip leading spaces */
		q++;
	while ((*p = *q++))	/* copy string */
		if (*p++ != ' ') /* remember last non-space */
			e = p;
	*e = 0;			/* kill trailing spaces */
}

void
usbd_devinfo_vp(usbd_device_handle dev, char *v, size_t lv, char *p, size_t lp,
        int usedev)
{
	usb_device_descriptor_t *udd = &dev->ddesc;
	char *vendor = NULL, *product = NULL;
#ifdef USBVERBOSE
        int n;
#endif

	if (dev == NULL) {
		v[0] = p[0] = '\0';
		return;
	}

	if (usedev) {
                if (usbd_get_string(dev, udd->iManufacturer, v))
                        vendor = NULL;
                else
                        vendor = v;
		usbd_trim_spaces(vendor);
                if (usbd_get_string(dev, udd->iProduct, p))
                        product = NULL;
                else
                        product = p;
		usbd_trim_spaces(product);
		if (vendor && !*vendor)
			vendor = NULL;
		if (product && !*product)
			product = NULL;
	} else {
		vendor = NULL;
		product = NULL;
	}
#ifdef USBVERBOSE
        if (vendor == NULL) {
                for (n = 0; n < usb_nvendors; n++)
                        if (usb_vendors[n].vendor == UGETW(udd->idVendor))
                                vendor = usb_vendors[n].vendorname;
        }
        if (product == NULL) {
                for (n = 0; n < usb_nproducts; n++)
                        if (usb_products[n].vendor == UGETW(udd->idVendor) &&
                            usb_products[n].product == UGETW(udd->idProduct))
                                product = usb_products[n].productname;
	}
#endif
	if (vendor != NULL && *vendor)
                strlcpy(v, vendor, lv);
	else
                snprintf(v, lv, "vendor 0x%04x", UGETW(udd->idVendor));
	if (product != NULL && *product)
                strlcpy(p, product, lp);
	else
                snprintf(p, lp, "product 0x%04x", UGETW(udd->idProduct));
}
#endif

int
usbd_printBCD(char *cp, size_t l, int bcd)
{
        return (snprintf(cp, l, "%x.%02x", bcd >> 8, bcd & 0xff));
}

#if !defined(__riscos) || defined(USB_DEBUG)
void
usbd_devinfo(usbd_device_handle dev, int showclass, char *cp, size_t l)
{
	usb_device_descriptor_t *udd = &dev->ddesc;
	char vendor[USB_MAX_STRING_LEN];
	char product[USB_MAX_STRING_LEN];
	int bcdDevice, bcdUSB;
        char *ep;

        ep = cp + l;

        usbd_devinfo_vp(dev, vendor, sizeof(vendor), product,
            sizeof(product), 1);
        cp += snprintf(cp, ep - cp, "%s %s", vendor, product);
	if (showclass)
                cp += snprintf(cp, ep - cp, ", class %d/%d",
			      udd->bDeviceClass, udd->bDeviceSubClass);
	bcdUSB = UGETW(udd->bcdUSB);
	bcdDevice = UGETW(udd->bcdDevice);
        cp += snprintf(cp, ep - cp, ", rev ");
        cp += usbd_printBCD(cp, ep - cp, bcdUSB);
	*cp++ = '/';
        cp += usbd_printBCD(cp, ep - cp, bcdDevice);
        cp += snprintf(cp, ep - cp, ", addr %d", dev->address);
	*cp = 0;
}
#endif

/* Delay for a certain number of ms */
void
usb_delay_ms(usbd_bus_handle bus, u_int ms)
{
	/* Wait at least two clock ticks so we know the time has passed. */
	if (bus->use_polling || cold)
		delay((ms+1) * 1000);
	else
#ifdef __riscos
                /* TODO put in proper parameter for no block */
                tsleep(&ms, PRIBIO, "usbdly", (ms*hz+999)/1000 + 1, 1);
#else
		tsleep(&ms, PRIBIO, "usbdly", (ms*hz+999)/1000 + 1);
#endif
}

/* Delay given a device handle. */
void
usbd_delay_ms(usbd_device_handle dev, u_int ms)
{
	usb_delay_ms(dev->bus, ms);
}

usbd_status
usbd_reset_port(usbd_device_handle dev, int port, usb_port_status_t *ps)
{
	usb_device_request_t req;
	usbd_status err;
	int n;

	req.bmRequestType = UT_WRITE_CLASS_OTHER;
	req.bRequest = UR_SET_FEATURE;
	USETW(req.wValue, UHF_PORT_RESET);
	USETW(req.wIndex, port);
	USETW(req.wLength, 0);
	err = usbd_do_request(dev, &req, 0);
	DPRINTFN(1,("usbd_reset_port: port %d reset done, error=%s\n",
		    port, usbd_errstr(err)));
	if (err)
		return (err);
	n = 10;
	do {
		/* Wait for device to recover from reset. */
#ifdef __riscos
                QueryDelay(dev, "USB$PortResetDelay",USB_PORT_RESET_DELAY);
#else
		usbd_delay_ms(dev, USB_PORT_RESET_DELAY);
#endif
		err = usbd_get_port_status(dev, port, ps);
		if (err) {
			DPRINTF(("usbd_reset_port: get status failed %d\n",
				 err));
			return (err);
		}
		/* If the device disappeared, just give up. */
		if (!(UGETW(ps->wPortStatus) & UPS_CURRENT_CONNECT_STATUS))
			return (USBD_NORMAL_COMPLETION);
	} while ((UGETW(ps->wPortChange) & UPS_C_PORT_RESET) == 0 && --n > 0);
	if (n == 0)
		return (USBD_TIMEOUT);
	err = usbd_clear_port_feature(dev, port, UHF_C_PORT_RESET);
#ifdef USB_DEBUG
	if (err)
		DPRINTF(("usbd_reset_port: clear port feature failed %d\n",
			 err));
#endif

	/* Wait for the device to recover from reset. */
#ifdef __riscos
        QueryDelay(dev, "USB$PortResetRecovery",USB_PORT_RESET_RECOVERY);
#else
	usbd_delay_ms(dev, USB_PORT_RESET_RECOVERY);
#endif
	return (err);
}

usb_interface_descriptor_t *
usbd_find_idesc(usb_config_descriptor_t *cd, int ifaceidx, int altidx)
{
	char *p = (char *)cd;
	char *end = p + UGETW(cd->wTotalLength);
	usb_interface_descriptor_t *d;
	int curidx, lastidx, curaidx = 0;

	for (curidx = lastidx = -1; p < end; ) {
		d = (usb_interface_descriptor_t *)p;
		DPRINTFN(4,("usbd_find_idesc: idx=%d(%d) altidx=%d(%d) len=%d "
			    "type=%d\n",
			    ifaceidx, curidx, altidx, curaidx,
			    d->bLength, d->bDescriptorType));
		if (d->bLength == 0) /* bad descriptor */
			break;
		p += d->bLength;
		if (p <= end && d->bDescriptorType == UDESC_INTERFACE) {
			if (d->bInterfaceNumber != lastidx) {
				lastidx = d->bInterfaceNumber;
				curidx++;
				curaidx = 0;
			} else
				curaidx++;
			if (ifaceidx == curidx && altidx == curaidx)
				return (d);
		}
	}
	return (NULL);
}

usb_endpoint_descriptor_t *
usbd_find_edesc(usb_config_descriptor_t *cd, int ifaceidx, int altidx,
		int endptidx)
{
	char *p = (char *)cd;
	char *end = p + UGETW(cd->wTotalLength);
	usb_interface_descriptor_t *d;
	usb_endpoint_descriptor_t *e;
	int curidx;

	d = usbd_find_idesc(cd, ifaceidx, altidx);
	if (d == NULL)
		return (NULL);
	if (endptidx >= d->bNumEndpoints) /* quick exit */
		return (NULL);

	curidx = -1;
	for (p = (char *)d + d->bLength; p < end; ) {
		e = (usb_endpoint_descriptor_t *)p;
		if (e->bLength == 0) /* bad descriptor */
			break;
		p += e->bLength;
		if (p <= end && e->bDescriptorType == UDESC_INTERFACE)
			return (NULL);
		if (p <= end && e->bDescriptorType == UDESC_ENDPOINT) {
			curidx++;
			if (curidx == endptidx)
				return (e);
		}
	}
	return (NULL);
}

usbd_status
usbd_fill_iface_data(usbd_device_handle dev, int ifaceidx, int altidx)
{
	usbd_interface_handle ifc = &dev->ifaces[ifaceidx];
	usb_interface_descriptor_t *idesc;
	char *p, *end;
	int endpt, nendpt;

	DPRINTFN(4,("usbd_fill_iface_data: ifaceidx=%d altidx=%d\n",
		    ifaceidx, altidx));
	idesc = usbd_find_idesc(dev->cdesc, ifaceidx, altidx);
	if (idesc == NULL)
		return (USBD_INVAL);
	ifc->device = dev;
	ifc->idesc = idesc;
	ifc->index = ifaceidx;
	ifc->altindex = altidx;
	nendpt = ifc->idesc->bNumEndpoints;
	DPRINTFN(4,("usbd_fill_iface_data: found idesc nendpt=%d\n", nendpt));
	if (nendpt != 0) {
                ifc->endpoints = malloc(nendpt * sizeof(struct usbd_endpoint),
                                        M_USB, M_NOWAIT);
		if (ifc->endpoints == NULL)
			return (USBD_NOMEM);
	} else
		ifc->endpoints = NULL;
	ifc->priv = NULL;
	p = (char *)ifc->idesc + ifc->idesc->bLength;
	end = (char *)dev->cdesc + UGETW(dev->cdesc->wTotalLength);
#define ed ((usb_endpoint_descriptor_t *)p)
	for (endpt = 0; endpt < nendpt; endpt++) {
		DPRINTFN(10,("usbd_fill_iface_data: endpt=%d\n", endpt));
		for (; p < end; p += ed->bLength) {
			DPRINTFN(10,("usbd_fill_iface_data: p=%p end=%p "
				     "len=%d type=%d\n",
				 p, end, ed->bLength, ed->bDescriptorType));
			if (p + ed->bLength <= end && ed->bLength != 0 &&
			    ed->bDescriptorType == UDESC_ENDPOINT)
				goto found;
			if (ed->bLength == 0 ||
			    ed->bDescriptorType == UDESC_INTERFACE)
				break;
		}
		/* passed end, or bad desc */
                printf("usbd_fill_iface_data: bad descriptor(s): %s\n",
		       ed->bLength == 0 ? "0 length" :
		       ed->bDescriptorType == UDESC_INTERFACE ? "iface desc":
		       "out of data");
		goto bad;
	found:
		ifc->endpoints[endpt].edesc = ed;
		if (dev->speed == USB_SPEED_HIGH) {
			u_int mps;
			/* Control and bulk endpoints have max packet limits. */
			switch (UE_GET_XFERTYPE(ed->bmAttributes)) {
			case UE_CONTROL:
				mps = USB_2_MAX_CTRL_PACKET;
				goto check;
			case UE_BULK:
				mps = USB_2_MAX_BULK_PACKET;
			check:
				if (UGETW(ed->wMaxPacketSize) != mps) {
					USETW(ed->wMaxPacketSize, mps);
#ifdef DIAGNOSTIC
                                        printf("usbd_fill_iface_data: bad max "
					       "packet size\n");
#endif
				}
				break;
			default:
				break;
			}
		}
		ifc->endpoints[endpt].refcnt = 0;
		p += ed->bLength;
	}
#undef ed
	LIST_INIT(&ifc->pipes);
	return (USBD_NORMAL_COMPLETION);

 bad:
	if (ifc->endpoints != NULL) {
		free(ifc->endpoints, M_USB);
		ifc->endpoints = NULL;
	}
	return (USBD_INVAL);
}

void
usbd_free_iface_data(usbd_device_handle dev, int ifcno)
{
	usbd_interface_handle ifc = &dev->ifaces[ifcno];
	if (ifc->endpoints)
		free(ifc->endpoints, M_USB);
}

Static usbd_status
usbd_set_config(usbd_device_handle dev, int conf)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_DEVICE;
	req.bRequest = UR_SET_CONFIG;
	USETW(req.wValue, conf);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);
	return (usbd_do_request(dev, &req, 0));
}

usbd_status
usbd_set_config_no(usbd_device_handle dev, int no, int msg)
{
	int index;
	usb_config_descriptor_t cd;
	usbd_status err;

	if (no == USB_UNCONFIG_NO)
		return (usbd_set_config_index(dev, USB_UNCONFIG_INDEX, msg));

	DPRINTFN(5,("usbd_set_config_no: %d\n", no));
	/* Figure out what config index to use. */
	for (index = 0; index < dev->ddesc.bNumConfigurations; index++) {
		err = usbd_get_config_desc(dev, index, &cd);
		if (err)
			return (err);
		if (cd.bConfigurationValue == no)
			return (usbd_set_config_index(dev, index, msg));
	}
	return (USBD_INVAL);
}

usbd_status
usbd_set_config_index(usbd_device_handle dev, int index, int msg)
{
	usb_status_t ds;
	usb_config_descriptor_t cd, *cdp;
	usbd_status err;
	int i, ifcidx, nifc, len, selfpowered, power;

        DPRINTFN(5,("usbd_set_config_index: dev=%p index=%d\n", dev, index));

	/* XXX check that all interfaces are idle */
	if (dev->config != USB_UNCONFIG_NO) {
                DPRINTF(("usbd_set_config_index: free old config\n"));
		/* Free all configuration data structures. */
		nifc = dev->cdesc->bNumInterface;
		for (ifcidx = 0; ifcidx < nifc; ifcidx++)
			usbd_free_iface_data(dev, ifcidx);
		free(dev->ifaces, M_USB);
                free((void *)dev->cdesc, M_USB);
		dev->ifaces = NULL;
		dev->cdesc = NULL;
		dev->config = USB_UNCONFIG_NO;
	}

	if (index == USB_UNCONFIG_INDEX) {
		/* We are unconfiguring the device, so leave unallocated. */
                DPRINTF(("usbd_set_config_index: set config 0\n"));
		err = usbd_set_config(dev, USB_UNCONFIG_NO);
		if (err)
			DPRINTF(("usbd_set_config_index: setting config=0 "
				 "failed, error=%s\n", usbd_errstr(err)));
		return (err);
	}

	/* Get the short descriptor. */
	err = usbd_get_config_desc(dev, index, &cd);
	if (err)
		return (err);
	len = UGETW(cd.wTotalLength);
	cdp = malloc(len, M_USB, M_NOWAIT);
	if (cdp == NULL)
		return (USBD_NOMEM);

	/* Get the full descriptor.  Try a few times for slow devices. */
	for (i = 0; i < 3; i++) {
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
                err = usbd_get_desc(dev, UDESC_CONFIG, index, len, (void*) cdp);
#else
		err = usbd_get_desc(dev, UDESC_CONFIG, index, len, cdp);
#endif
		if (!err)
			break;
		usbd_delay_ms(dev, 200);
	}
	if (err)
		goto bad;

	if (cdp->bDescriptorType != UDESC_CONFIG) {
		DPRINTFN(-1,("usbd_set_config_index: bad desc %d\n",
			     cdp->bDescriptorType));
		err = USBD_INVAL;
		goto bad;
	}

	/* Figure out if the device is self or bus powered. */
	selfpowered = 0;
	if (!(dev->quirks->uq_flags & UQ_BUS_POWERED) &&
	    (cdp->bmAttributes & UC_SELF_POWERED)) {
		/* May be self powered. */
		if (cdp->bmAttributes & UC_BUS_POWERED) {
			/* Must ask device. */
			if (dev->quirks->uq_flags & UQ_POWER_CLAIM) {
				/*
				 * Hub claims to be self powered, but isn't.
				 * It seems that the power status can be
				 * determined by the hub characteristics.
				 */
				usb_hub_descriptor_t hd;
				usb_device_request_t req;
				req.bmRequestType = UT_READ_CLASS_DEVICE;
				req.bRequest = UR_GET_DESCRIPTOR;
				USETW(req.wValue, 0);
				USETW(req.wIndex, 0);
				USETW(req.wLength, USB_HUB_DESCRIPTOR_SIZE);
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
                                err = usbd_do_request(dev, &req, (void*)&hd);
#else
				err = usbd_do_request(dev, &req, &hd);
#endif
				if (!err &&
				    (UGETW(hd.wHubCharacteristics) &
				     UHD_PWR_INDIVIDUAL))
					selfpowered = 1;
				DPRINTF(("usbd_set_config_index: charac=0x%04x"
				    ", error=%s\n",
				    UGETW(hd.wHubCharacteristics),
				    usbd_errstr(err)));
			} else {
				err = usbd_get_device_status(dev, &ds);
				if (!err &&
				    (UGETW(ds.wStatus) & UDS_SELF_POWERED))
					selfpowered = 1;
				DPRINTF(("usbd_set_config_index: status=0x%04x"
				    ", error=%s\n",
				    UGETW(ds.wStatus), usbd_errstr(err)));
			}
		} else
			selfpowered = 1;
	}
	DPRINTF(("usbd_set_config_index: (addr %d) cno=%d attr=0x%02x, "
		 "selfpowered=%d, power=%d\n",
		 cdp->bConfigurationValue, dev->address, cdp->bmAttributes,
		 selfpowered, cdp->bMaxPower * 2));

	/* Check if we have enough power. */
#ifdef USB_DEBUG
	if (dev->powersrc == NULL) {
		DPRINTF(("usbd_set_config_index: No power source?\n"));
		return (USBD_IOERROR);
	}
#endif
	power = cdp->bMaxPower * 2;
	if (power > dev->powersrc->power) {
		DPRINTF(("power exceeded %d %d\n", power,dev->powersrc->power));
		/* XXX print nicer message. */
		if (msg)
                        printf("%s: device addr %d (config %d) exceeds power "
				 "budget, %d mA > %d mA\n",
			       USBDEVNAME(dev->bus->bdev), dev->address,
			       cdp->bConfigurationValue,
			       power, dev->powersrc->power);
		err = USBD_NO_POWER;
		goto bad;
	}
	dev->power = power;
	dev->self_powered = selfpowered;

	/* Set the actual configuration value. */
	DPRINTF(("usbd_set_config_index: set config %d\n",
		 cdp->bConfigurationValue));
	err = usbd_set_config(dev, cdp->bConfigurationValue);
	if (err) {
		DPRINTF(("usbd_set_config_index: setting config=%d failed, "
			 "error=%s\n",
			 cdp->bConfigurationValue, usbd_errstr(err)));
		goto bad;
	}

	/* Allocate and fill interface data. */
	nifc = cdp->bNumInterface;
	dev->ifaces = malloc(nifc * sizeof(struct usbd_interface),
			     M_USB, M_NOWAIT);
	if (dev->ifaces == NULL) {
		err = USBD_NOMEM;
		goto bad;
	}
	DPRINTFN(5,("usbd_set_config_index: dev=%p cdesc=%p\n", dev, cdp));
	dev->cdesc = cdp;
	dev->config = cdp->bConfigurationValue;
	for (ifcidx = 0; ifcidx < nifc; ifcidx++) {
		err = usbd_fill_iface_data(dev, ifcidx, 0);
		if (err) {
			while (--ifcidx >= 0)
				usbd_free_iface_data(dev, ifcidx);
			goto bad;
		}
	}

	return (USBD_NORMAL_COMPLETION);

 bad:
        free((void *)cdp, M_USB);
	return (err);
}

/* XXX add function for alternate settings */

usbd_status
usbd_setup_pipe(usbd_device_handle dev, usbd_interface_handle iface,
		struct usbd_endpoint *ep, int ival, usbd_pipe_handle *pipe)
{
	usbd_pipe_handle p;
	usbd_status err;

	DPRINTFN(1,("usbd_setup_pipe: dev=%p iface=%p ep=%p pipe=%p\n",
		    dev, iface, ep, pipe));
	p = malloc(dev->bus->pipe_size, M_USB, M_NOWAIT);
	if (p == NULL)
		return (USBD_NOMEM);
	p->device = dev;
	p->iface = iface;
	p->endpoint = ep;
	ep->refcnt++;
	p->refcnt = 1;
	p->intrxfer = 0;
	p->running = 0;
	p->aborting = 0;
	p->repeat = 0;
	p->interval = ival;
	SIMPLEQ_INIT(&p->queue);
	err = dev->bus->methods->open_pipe(p);
	if (err) {
		DPRINTFN(-1,("usbd_setup_pipe: endpoint=0x%x failed, error="
			 "%s\n",
			 ep->edesc->bEndpointAddress, usbd_errstr(err)));
		free(p, M_USB);
		return (err);
	}
        /* Clear any stall and make sure DATA0 toggle will be used next. */
        /* JB 20060221 leave this in or epson 1660 cannot do repeated scans*/
        if (UE_GET_ADDR(ep->edesc->bEndpointAddress) != USB_CONTROL_ENDPOINT) {
                err = usbd_clear_endpoint_stall(p);
#ifdef __riscos
                /* Some devices reject this command, so ignore a STALL. */
                /* On RiscOS, I've found devices giving IOERROR here too */
                if (err && err != USBD_STALLED && err != USBD_IOERROR) {
#else
                /* Some devices reject this command, so ignore a STALL. */
                if (err && err != USBD_STALLED) {
#endif
                        printf("usbd_setup_pipe: failed to start endpoint, %s\n", usbd_errstr(err));
                        DPRINTFN(-1,("usbd_setup_pipe: endpoint=0x%x failed to clear toggle, error="
                         "%s\n",
                         ep->edesc->bEndpointAddress, usbd_errstr(err)));
                p->methods->close(p);
                free(p, M_USB);
                return (err);
                }
        }
	*pipe = p;
	return (USBD_NORMAL_COMPLETION);
}

/* Abort the device control pipe. */
void
usbd_kill_pipe(usbd_pipe_handle pipe)
{
	usbd_abort_pipe(pipe);
	pipe->methods->close(pipe);
	pipe->endpoint->refcnt--;
	free(pipe, M_USB);
}

int
usbd_getnewaddr(usbd_bus_handle bus)
{
	int addr;

	for (addr = 1; addr < USB_MAX_DEVICES; addr++)
		if (bus->devices[addr] == NULL)
			return (addr);
	return (-1);
}


usbd_status
usbd_probe_and_attach(device_ptr_t parent, usbd_device_handle dev,
		      int port, int addr)
{
	struct usb_attach_arg uaa;
	usb_device_descriptor_t *dd = &dev->ddesc;
        int found=0, i, confi, nifaces;
	usbd_status err;
	device_ptr_t dv;
	usbd_interface_handle ifaces[256]; /* 256 is the absolute max */

#if defined(__FreeBSD__)
	/*
	 * XXX uaa is a static var. Not a problem as it _should_ be used only
	 * during probe and attach. Should be changed however.
	 */
	device_t bdev;
	bdev = device_add_child(parent, NULL, -1, &uaa);
	if (!bdev) {
            printf("%s: Device creation failed\n", USBDEVNAME(dev->bus->bdev));
	    return (USBD_INVAL);
	}
	device_quiet(bdev);
#endif

	uaa.device = dev;
	uaa.iface = NULL;
	uaa.ifaces = NULL;
	uaa.nifaces = 0;
	uaa.usegeneric = 0;
	uaa.port = port;
	uaa.configno = UHUB_UNK_CONFIGURATION;
	uaa.ifaceno = UHUB_UNK_INTERFACE;
	uaa.vendor = UGETW(dd->idVendor);
	uaa.product = UGETW(dd->idProduct);
	uaa.release = UGETW(dd->bcdDevice);

	/* First try with device specific drivers. */
	DPRINTF(("usbd_probe_and_attach: trying device specific drivers\n"));
	dv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print, usbd_submatch);
	if (dv) {
#ifdef __riscos
                dev->subdevs = malloc(3 * sizeof dv, M_USB, M_NOWAIT);
                found = 1;
#else
		dev->subdevs = malloc(2 * sizeof dv, M_USB, M_NOWAIT);
#endif
		if (dev->subdevs == NULL)
			return (USBD_NOMEM);
		dev->subdevs[0] = dv;
		dev->subdevs[1] = 0;
#ifdef __riscos
                /* always let RISC OS match on generic */
                goto generic;
#else
		return (USBD_NORMAL_COMPLETION);
#endif
	}

	DPRINTF(("usbd_probe_and_attach: no device specific driver found\n"));

	DPRINTF(("usbd_probe_and_attach: looping over %d configurations\n",
		 dd->bNumConfigurations));
	/* Next try with interface drivers. */
	for (confi = 0; confi < dd->bNumConfigurations; confi++) {
		DPRINTFN(1,("usbd_probe_and_attach: trying config idx=%d\n",
			    confi));
		err = usbd_set_config_index(dev, confi, 1);
		if (err) {
#ifdef USB_DEBUG
			DPRINTF(("%s: port %d, set config at addr %d failed, "
				 "error=%s\n", USBDEVPTRNAME(parent), port,
				 addr, usbd_errstr(err)));
#else
                        printf("%s: port %d, set config at addr %d failed\n",
			       USBDEVPTRNAME(parent), port, addr);
#endif
#if defined(__FreeBSD__)
			device_delete_child(parent, bdev);
#endif

 			return (err);
		}
		nifaces = dev->cdesc->bNumInterface;
		uaa.configno = dev->cdesc->bConfigurationValue;
		for (i = 0; i < nifaces; i++)
			ifaces[i] = &dev->ifaces[i];
		uaa.ifaces = ifaces;
		uaa.nifaces = nifaces;
#ifdef __riscos
                /* add an extra one for RISC OS to always have a generic */
                dev->subdevs = malloc((nifaces+2) * sizeof dv, M_USB,M_NOWAIT);
#else
		dev->subdevs = malloc((nifaces+1) * sizeof dv, M_USB,M_NOWAIT);
#endif
		if (dev->subdevs == NULL) {
#if defined(__FreeBSD__)
			device_delete_child(parent, bdev);
#endif
			return (USBD_NOMEM);
		}

		found = 0;
		for (i = 0; i < nifaces; i++) {
			if (ifaces[i] == NULL)
				continue; /* interface already claimed */
			uaa.iface = ifaces[i];
			uaa.ifaceno = ifaces[i]->idesc->bInterfaceNumber;
			dv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print,
					   usbd_submatch);
			if (dv != NULL) {
				dev->subdevs[found++] = dv;
				dev->subdevs[found] = 0;
				ifaces[i] = 0; /* consumed */

#if defined(__FreeBSD__)
				/* create another child for the next iface */
				bdev = device_add_child(parent, NULL, -1,&uaa);
				if (!bdev) {
                                        printf("%s: Device creation failed\n",
					USBDEVNAME(dev->bus->bdev));
					return (USBD_NORMAL_COMPLETION);
				}
				device_quiet(bdev);
#endif
			}
		}
		if (found != 0) {
#ifdef __riscos
                        /* for RISC OS we always want to match the generic
                           driver */
                        break;
#endif
#if defined(__FreeBSD__)
			/* remove the last created child again; it is unused */
			device_delete_child(parent, bdev);
#endif
			return (USBD_NORMAL_COMPLETION);
		}
		free(dev->subdevs, M_USB);
		dev->subdevs = 0;
	}
	/* No interfaces were attached in any of the configurations. */

	if (dd->bNumConfigurations > 1) /* don't change if only 1 config */
		usbd_set_config_index(dev, 0, 0);

	DPRINTF(("usbd_probe_and_attach: no interface drivers found\n"));

#ifdef __riscos
generic:
#endif
	/* Finally try the generic driver. */
	uaa.iface = NULL;
	uaa.usegeneric = 1;
	uaa.configno = UHUB_UNK_CONFIGURATION;
	uaa.ifaceno = UHUB_UNK_INTERFACE;
	dv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print, usbd_submatch);
	if (dv != NULL) {
#ifdef __riscos
                if (!dev->subdevs)
#endif
		dev->subdevs = malloc(2 * sizeof dv, M_USB, M_NOWAIT);
		if (dev->subdevs == 0)
			return (USBD_NOMEM);
#ifdef __riscos
                dev->subdevs[found++] = dv;
                dev->subdevs[found] = 0;
#else
		dev->subdevs[0] = dv;
		dev->subdevs[1] = 0;
#endif
		return (USBD_NORMAL_COMPLETION);
	}

	/*
	 * The generic attach failed, but leave the device as it is.
	 * We just did not find any drivers, that's all.  The device is
	 * fully operational and not harming anyone.
	 */
	DPRINTF(("usbd_probe_and_attach: generic attach failed\n"));
#if defined(__FreeBSD__)
	device_delete_child(parent, bdev);
#endif
 	return (USBD_NORMAL_COMPLETION);
}


/*
 * Get the first 8 bytes of the device descriptor.
 * Do as Windows does: try to read 64 bytes -- there are devices which
 * recognize the initial descriptor fetch (before the control endpoint's
 * MaxPacketSize is known by the host) by exactly this length.
 */
usbd_status
usbd_get_initial_ddesc(usbd_device_handle dev, usb_device_descriptor_t *desc)
{
	usb_device_request_t req;
	char buf[64];
	int res, actlen;

	req.bmRequestType = UT_READ_DEVICE;
	req.bRequest = UR_GET_DESCRIPTOR;
	USETW2(req.wValue, UDESC_DEVICE, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 64);
	res = usbd_do_request_flags(dev, &req, buf, USBD_SHORT_XFER_OK,
		&actlen, USBD_DEFAULT_TIMEOUT);
	if (res)
		return res;
	if (actlen < 8)
		return USBD_SHORT_XFER;
	memcpy(desc, buf, 8);
	return USBD_NORMAL_COMPLETION;
}

/*
 * Called when a new device has been put in the powered state,
 * but not yet in the addressed state.
 * Get initial descriptor, set the address, get full descriptor,
 * and attach a driver.
 */
usbd_status
usbd_new_device(device_ptr_t parent, usbd_bus_handle bus, int depth,
		int speed, int port, struct usbd_port *up)
{
	usbd_device_handle dev, adev;
	struct usbd_device *hub;
	usb_device_descriptor_t *dd;
	usb_port_status_t ps;
	usbd_status err;
	int addr;
	int i;
	int p;

	DPRINTF(("usbd_new_device bus=%p port=%d depth=%d speed=%d\n",
		 bus, port, depth, speed));

	dev = malloc(sizeof *dev, M_USB, M_NOWAIT|M_ZERO);
	if (dev == NULL)
		return (USBD_NOMEM);
#ifdef __riscos
	/* M_ZERO does nothing on RISC OS, so we do it explicitly here */
	memset(dev, 0, sizeof(*dev));
#endif

	dev->bus = bus;

	/* Set up default endpoint handle. */
	dev->def_ep.edesc = &dev->def_ep_desc;

	/* Set up default endpoint descriptor. */
	dev->def_ep_desc.bLength = USB_ENDPOINT_DESCRIPTOR_SIZE;
	dev->def_ep_desc.bDescriptorType = UDESC_ENDPOINT;
	dev->def_ep_desc.bEndpointAddress = USB_CONTROL_ENDPOINT;
	dev->def_ep_desc.bmAttributes = UE_CONTROL;
	/*
	 * temporary, will be fixed after first descriptor fetch
	 * (which uses 64 bytes so it shouldn't be less),
	 * highspeed devices must support 64 byte packets anyway
	 */
	if (speed == USB_SPEED_HIGH || speed == USB_SPEED_FULL)
		USETW(dev->def_ep_desc.wMaxPacketSize, 64);
	else
		USETW(dev->def_ep_desc.wMaxPacketSize, USB_MAX_IPACKET);

	dev->def_ep_desc.bInterval = 0;

	/* doesn't matter, just don't leave it uninitialized */
	dev->def_ep.datatoggle = 0;

	dev->quirks = &usbd_no_quirk;
	dev->address = USB_START_ADDR;
	dev->ddesc.bMaxPacketSize = 0;
	dev->depth = depth;
	dev->powersrc = up;
	dev->myhub = up->parent;

	up->device = dev;

	/* Locate port on upstream high speed hub */
	for (adev = dev, hub = up->parent;
	     hub != NULL && hub->speed != USB_SPEED_HIGH;
	     adev = hub, hub = hub->myhub)
		;
	if (hub) {
		for (p = 0; p < hub->hub->hubdesc.bNbrPorts; p++) {
			if (hub->hub->ports[p].device == adev) {
				dev->myhsport = &hub->hub->ports[p];
				goto found;
			}
		}
		panic("usbd_new_device: cannot find HS port\n");
	found:
		DPRINTFN(1,("usbd_new_device: high speed port %d\n", p));
	} else {
		dev->myhsport = NULL;
	}
	dev->speed = speed;
	dev->langid = USBD_NOLANG;
#ifndef __riscos
	dev->cookie.cookie = ++usb_cookie_no;
#endif

	/* Establish the default pipe. */
#ifdef __riscos
	err = usbd_setup_pipe(dev, 0, &dev->def_ep, USBD_DEFAULT_INTERVAL,
			      &dev->default_pipe);
#else
	err = usbd_setup_pipe_flags(dev, 0, &dev->def_ep, USBD_DEFAULT_INTERVAL,
			      &dev->default_pipe, USBD_MPSAFE);
#endif
	if (err) {
		usbd_remove_device(dev, up);
		return (err);
	}

	/* Do any bus specific preparation */
	if (bus->methods->new_device_pre != NULL) {
		err = bus->methods->new_device_pre(dev);
		if (err) {
			usbd_remove_device(dev, up);
			return (err);
		}
	}

	dd = &dev->ddesc;
	/* Try a few times in case the device is slow (i.e. outside specs.) */
	for (i = 0; i < 10; i++) {
		/* Get the first 8 bytes of the device descriptor. */
		err = usbd_get_initial_ddesc(dev, dd);
		if (!err)
			break;
		usbd_delay_ms(dev, 200);
		if ((i & 3) == 3)
			usbd_reset_port(up->parent, port, &ps);
	}
	if (err) {
		DPRINTFN(-1, ("usbd_new_device: addr=%d, getting first desc "
			      "failed: %d\n", addr, err));
		usbd_remove_device(dev, up);
		return (err);
	}

	/* Windows resets the port here to work around problematic LS & FS
	 * devices that get upset by the initial device descriptor read
	 * followed by another one once addressed, do likewise.
	 */
	if (up->parent)
		usbd_reset_port(up->parent, port, &ps);

	if (speed == USB_SPEED_HIGH) {
		/* Max packet size must be 64 (sec 5.5.3). */
		if (dd->bMaxPacketSize != USB_2_MAX_CTRL_PACKET) {
#ifdef DIAGNOSTIC
			printf("usbd_new_device: addr=%d bad max packet "
			    "size=%d. adjusting to %d.\n",
			    addr, dd->bMaxPacketSize, USB_2_MAX_CTRL_PACKET);
#endif
			dd->bMaxPacketSize = USB_2_MAX_CTRL_PACKET;
		}
	}

	DPRINTF(("usbd_new_device: adding unit addr=%d, rev=%02x, class=%d, "
		 "subclass=%d, protocol=%d, maxpacket=%d, len=%d, speed=%d\n",
		 addr,UGETW(dd->bcdUSB), dd->bDeviceClass, dd->bDeviceSubClass,
		 dd->bDeviceProtocol, dd->bMaxPacketSize, dd->bLength,
		 dev->speed));

	if (dd->bDescriptorType != UDESC_DEVICE) {
		/* Illegal device descriptor */
		DPRINTFN(-1,("usbd_new_device: illegal descriptor %d\n",
			     dd->bDescriptorType));
		usbd_remove_device(dev, up);
		return (USBD_INVAL);
	}

	if (dd->bLength < USB_DEVICE_DESCRIPTOR_SIZE) {
		DPRINTFN(-1,("usbd_new_device: bad length %d\n", dd->bLength));
		usbd_remove_device(dev, up);
		return (USBD_INVAL);
	}

	/* 4.8.2.1 */
	if (speed == USB_SPEED_SUPER)
		USETW(dev->def_ep_desc.wMaxPacketSize, (1 << dd->bMaxPacketSize));
	else
		USETW(dev->def_ep_desc.wMaxPacketSize, dd->bMaxPacketSize);
	DPRINTFN(5, ("bMaxPacketSize %u", dd->bMaxPacketSize));
	USETW(dev->def_ep_desc.wMaxPacketSize, dd->bMaxPacketSize);

	/* Pick a free address on this bus segment */
	if (bus->methods->new_device_addr != NULL)
		addr = bus->methods->new_device_addr(dev); /* Also sets MPS for EP0 */
	else
		addr = usbd_getnewaddr(bus);
	if (addr < 0) {
		printf("%s: No free USB addresses, new device ignored.\n",
		       USBDEVNAME(bus->bdev));
		usbd_remove_device(dev, up);
		return (USBD_NO_ADDR);
	}

	/* Re-establish the default pipe with the new MPS. */
	usbd_kill_pipe(dev->default_pipe);
#ifdef __riscos /* No USBD_MPSAFE */
	err = usbd_setup_pipe(dev, 0, &dev->def_ep, USBD_DEFAULT_INTERVAL,
	    &dev->default_pipe);
#else
	err = usbd_setup_pipe_flags(dev, 0, &dev->def_ep, USBD_DEFAULT_INTERVAL,
	    &dev->default_pipe, USBD_MPSAFE);
#endif
	if (err) {
		DPRINTFN(-1, ("usbd_new_device: setup default pipe failed\n"));
		usbd_remove_device(dev, up);
		return err;
	}

	/* Set the address */
	DPRINTFN(5, ("usbd_new_device: setting device address=%d\n", addr));
	if (bus->methods->new_device_addr != NULL)
		err = USBD_NORMAL_COMPLETION; /* Set earlier */
	else
		err = usbd_set_address(dev, addr);
	if (err) {
		DPRINTFN(-1, ("usbd_new_device: set address %d failed\n", addr));
		err = USBD_SET_ADDR_FAILED;
		usbd_remove_device(dev, up);
		return err;
	}

	/* Allow device time to set new address */
	usbd_delay_ms(dev, USB_SET_ADDRESS_SETTLE);
	dev->address = addr;	/* new device address now */
	bus->devices[addr] = dev;

	/* Re-establish the default pipe with the new address. */
	usbd_kill_pipe(dev->default_pipe);
#ifdef __riscos /* No USBD_MPSAFE */
	err = usbd_setup_pipe(dev, 0, &dev->def_ep, USBD_DEFAULT_INTERVAL,
	    &dev->default_pipe);
#else
	err = usbd_setup_pipe_flags(dev, 0, &dev->def_ep, USBD_DEFAULT_INTERVAL,
	    &dev->default_pipe, USBD_MPSAFE);
#endif
	if (err) {
		DPRINTFN(-1, ("usbd_new_device: setup default pipe failed\n"));
		usbd_remove_device(dev, up);
		return err;
	}

	err = usbd_reload_device_desc(dev);
	if (err) {
		DPRINTFN(-1, ("usbd_new_device: addr=%d, getting full desc "
			      "failed\n", addr));
		usbd_remove_device(dev, up);
		return (err);
	}

	/* Assume 100mA bus powered for now. Changed when configured. */
	dev->power = USB_MIN_POWER;
	dev->self_powered = 0;

	DPRINTF(("usbd_new_device: new dev (addr %d), dev=%p, parent=%p\n",
		 addr, dev, parent));

	usbd_add_dev_event(USB_EVENT_DEVICE_ATTACH, dev);

	err = usbd_probe_and_attach(parent, dev, port, addr);
	if (err) {
#ifdef __riscos
		usb_disconnect_port(up, parent);
#else
		usbd_remove_device(dev, up);
#endif
		return (err);
	}

	/* Do any bus specific tidying now everything is known */
	if (bus->methods->new_device_post != NULL) {
		err = bus->methods->new_device_post(dev);
		if (err) {
			usbd_remove_device(dev, up);
			return (err);
		}
	}

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
usbd_reload_device_desc(usbd_device_handle dev)
{
	usbd_status err;

	/* Get the full device descriptor. */
	err = usbd_get_device_desc(dev, &dev->ddesc);
	if (err)
		return (err);

	/* Figure out what's wrong with this device. */
	dev->quirks = usbd_find_quirk(&dev->ddesc);

	return (USBD_NORMAL_COMPLETION);
}

void
usbd_remove_device(usbd_device_handle dev, struct usbd_port *up)
{
	DPRINTF(("usbd_remove_device: %p\n", dev));

	if (dev->default_pipe != NULL)
		usbd_kill_pipe(dev->default_pipe);
        up->device = NULL;
        if (dev->bus->methods->remove_device != NULL)
          dev->bus->methods->remove_device(dev);
        dev->bus->devices[dev->address] = NULL;

	free(dev, M_USB);
}

#if defined(__NetBSD__) || defined(__OpenBSD__)
int
usbd_print(void *aux, const char *pnp)
{
	struct usb_attach_arg *uaa = aux;
	char devinfo[1024];

	DPRINTFN(15, ("usbd_print dev=%p\n", uaa->device));
	if (pnp) {
		if (!uaa->usegeneric)
			return (QUIET);
                usbd_devinfo(uaa->device, 1, devinfo, sizeof(devinfo));
                logprintf("%s, %s", devinfo, pnp);
	}
	if (uaa->port != 0)
                logprintf(" port %d", uaa->port);
	if (uaa->configno != UHUB_UNK_CONFIGURATION)
                logprintf(" configuration %d", uaa->configno);
	if (uaa->ifaceno != UHUB_UNK_INTERFACE)
                logprintf(" interface %d", uaa->ifaceno);
#if 0
	/*
	 * It gets very crowded with these locators on the attach line.
	 * They are not really needed since they are printed in the clear
	 * by each driver.
	 */
	if (uaa->vendor != UHUB_UNK_VENDOR)
                logprintf(" vendor 0x%04x", uaa->vendor);
	if (uaa->product != UHUB_UNK_PRODUCT)
                logprintf(" product 0x%04x", uaa->product);
	if (uaa->release != UHUB_UNK_RELEASE)
                logprintf(" release 0x%04x", uaa->release);
#endif
	return (UNCONF);
}

#if defined(__NetBSD__)
int
usbd_submatch(struct device *parent, struct cfdata *cf,
              const locdesc_t *ldesc, void *aux)
{
#elif defined(__OpenBSD__)
int
usbd_submatch(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
#endif
	struct usb_attach_arg *uaa = aux;

	DPRINTFN(5,("usbd_submatch port=%d,%d configno=%d,%d "
	    "ifaceno=%d,%d vendor=%d,%d product=%d,%d release=%d,%d\n",
	    uaa->port, cf->uhubcf_port,
	    uaa->configno, cf->uhubcf_configuration,
	    uaa->ifaceno, cf->uhubcf_interface,
	    uaa->vendor, cf->uhubcf_vendor,
	    uaa->product, cf->uhubcf_product,
	    uaa->release, cf->uhubcf_release));
	if (uaa->port != 0 &&	/* root hub has port 0, it should match */
            ((cf->uhubcf_port != UHUB_UNK_PORT &&
	      cf->uhubcf_port != uaa->port) ||
	     (uaa->configno != UHUB_UNK_CONFIGURATION &&
	      cf->uhubcf_configuration != UHUB_UNK_CONFIGURATION &&
	      cf->uhubcf_configuration != uaa->configno) ||
	     (uaa->ifaceno != UHUB_UNK_INTERFACE &&
	      cf->uhubcf_interface != UHUB_UNK_INTERFACE &&
	      cf->uhubcf_interface != uaa->ifaceno) ||
	     (uaa->vendor != UHUB_UNK_VENDOR &&
	      cf->uhubcf_vendor != UHUB_UNK_VENDOR &&
	      cf->uhubcf_vendor != uaa->vendor) ||
	     (uaa->product != UHUB_UNK_PRODUCT &&
	      cf->uhubcf_product != UHUB_UNK_PRODUCT &&
	      cf->uhubcf_product != uaa->product) ||
	     (uaa->release != UHUB_UNK_RELEASE &&
	      cf->uhubcf_release != UHUB_UNK_RELEASE &&
	      cf->uhubcf_release != uaa->release)
	     )
	   )
		return 0;
	if (cf->uhubcf_vendor != UHUB_UNK_VENDOR &&
	    cf->uhubcf_vendor == uaa->vendor &&
	    cf->uhubcf_product != UHUB_UNK_PRODUCT &&
	    cf->uhubcf_product == uaa->product) {
		/* We have a vendor&product locator match */
		if (cf->uhubcf_release != UHUB_UNK_RELEASE &&
		    cf->uhubcf_release == uaa->release)
			uaa->matchlvl = UMATCH_VENDOR_PRODUCT_REV;
		else
			uaa->matchlvl = UMATCH_VENDOR_PRODUCT;
	} else
		uaa->matchlvl = 0;
	return (config_match(parent, cf, aux));
}

#endif

void
usbd_fill_deviceinfo(usbd_device_handle dev, struct usb_device_info *di,
		     int usedev)
{
	struct usbd_port *p;
	int i, err, s;

	di->udi_bus = USBDEVUNIT(dev->bus->bdev);
	di->udi_addr = dev->address;
	di->udi_cookie = dev->cookie;
        usbd_devinfo_vp(dev, di->udi_vendor, sizeof(di->udi_vendor),
            di->udi_product, sizeof(di->udi_product), usedev);
        usbd_printBCD(di->udi_release, sizeof(di->udi_release),
            UGETW(dev->ddesc.bcdDevice));
	di->udi_vendorNo = UGETW(dev->ddesc.idVendor);
	di->udi_productNo = UGETW(dev->ddesc.idProduct);
	di->udi_releaseNo = UGETW(dev->ddesc.bcdDevice);
	di->udi_class = dev->ddesc.bDeviceClass;
	di->udi_subclass = dev->ddesc.bDeviceSubClass;
	di->udi_protocol = dev->ddesc.bDeviceProtocol;
	di->udi_config = dev->config;
	di->udi_power = dev->self_powered ? 0 : dev->power;
	di->udi_speed = dev->speed;

	if (dev->subdevs != NULL) {
		for (i = 0; dev->subdevs[i] &&
			     i < USB_MAX_DEVNAMES; i++) {
			strncpy(di->udi_devnames[i], USBDEVPTRNAME(dev->subdevs[i]),
				USB_MAX_DEVNAMELEN);
			di->udi_devnames[i][USB_MAX_DEVNAMELEN-1] = '\0';
                }
        } else {
                i = 0;
        }
        for (/*i is set */; i < USB_MAX_DEVNAMES; i++)
                di->udi_devnames[i][0] = 0;                 /* empty */

	if (dev->hub) {
		for (i = 0;
		     i < sizeof(di->udi_ports) / sizeof(di->udi_ports[0]) &&
			     i < dev->hub->hubdesc.bNbrPorts;
		     i++) {
			p = &dev->hub->ports[i];
			if (p->device)
				err = p->device->address;
			else {
				s = UGETW(p->status.wPortStatus);
				if (s & UPS_PORT_ENABLED)
					err = USB_PORT_ENABLED;
				else if (s & UPS_SUSPEND)
					err = USB_PORT_SUSPENDED;
				else if (s & UPS_PORT_POWER)
					err = USB_PORT_POWERED;
				else
					err = USB_PORT_DISABLED;
			}
			di->udi_ports[i] = err;
		}
		di->udi_nports = dev->hub->hubdesc.bNbrPorts;
	} else
		di->udi_nports = 0;
}

void
usb_free_device(usbd_device_handle dev)
{
	int ifcidx, nifc;
#ifdef __riscos
	if (dev->dv_unit)
		kill_system_variable(dev->dv_unit);
#endif
	if (dev->default_pipe != NULL)
		usbd_kill_pipe(dev->default_pipe);
	if (dev->ifaces != NULL) {
		nifc = dev->cdesc->bNumInterface;
		for (ifcidx = 0; ifcidx < nifc; ifcidx++)
			usbd_free_iface_data(dev, ifcidx);
		free(dev->ifaces, M_USB);
	}
	if (dev->cdesc != NULL)
                free((void *)dev->cdesc, M_USB);
	if (dev->subdevs != NULL)
		free(dev->subdevs, M_USB);
	free(dev, M_USB);
}

/*
 * The general mechanism for detaching drivers works as follows: Each
 * driver is responsible for maintaining a reference count on the
 * number of outstanding references to its softc (e.g.  from
 * processing hanging in a read or write).  The detach method of the
 * driver decrements this counter and flags in the softc that the
 * driver is dying and then wakes any sleepers.  It then sleeps on the
 * softc.  Each place that can sleep must maintain the reference
 * count.  When the reference count drops to -1 (0 is the normal value
 * of the reference count) the a wakeup on the softc is performed
 * signaling to the detach waiter that all references are gone.
 */

/*
 * Called from process context when we discover that a port has
 * been disconnected.
 */
void
usb_disconnect_port(struct usbd_port *up, device_ptr_t parent)
{
	usbd_device_handle dev = up->device;
	char *hubname = USBDEVPTRNAME(parent);
	int i;

	DPRINTFN(3,("uhub_disconnect: up=%p dev=%p port=%d\n",
		    up, dev, up->portno));

#ifdef DIAGNOSTIC
	if (dev == NULL) {
                printf("usb_disconnect_port: no device\n");
		return;
	}
#endif

	if (dev->subdevs != NULL) {
		DPRINTFN(3,("usb_disconnect_port: disconnect subdevs\n"));
		for (i = 0; dev->subdevs[i]; i++) {
                        printf("%s: at %s", USBDEVPTRNAME(dev->subdevs[i]),
			       hubname);
			if (up->portno != 0)
                                printf(" port %d", up->portno);
                        printf(" (addr %d) disconnected\n", dev->address);
			config_detach(dev->subdevs[i], DETACH_FORCE);
			dev->subdevs[i] = 0;
		}
	}

	usbd_add_dev_event(USB_EVENT_DEVICE_DETACH, dev);
	if (dev->bus->methods->remove_device != NULL)
		dev->bus->methods->remove_device(dev);
	dev->bus->devices[dev->address] = NULL;
	up->device = NULL;
	usb_free_device(dev);
}

#ifdef __OpenBSD__
void *usb_realloc(void *p, u_int size, int pool, int flags)
{
	void *q;

	q = malloc(size, pool, flags);
	if (q == NULL)
		return (NULL);
	bcopy(p, q, size);
	free(p, pool);
	return (q);
}
#endif
@


1.25
log
@Changes to header exports
Detail:
  Export usbroothub_subr.h, for those HC's that might need it.
  Export C version of usbhal.h, in addition to the assembler Hdr version, for MUSBDriver.
  Eliminate the dependency on opt_usbverbose.h - an empty header file - by merging the change from usb_subr.c revision 1.186 from NetBSD which guards it with internal _KERNEL_OPT (unset).
Admin:
  Submission for USB bounty.

Version 1.21. Tagged as 'USBDriver-1_21'
@
text
@a40 3
#ifdef __riscos
#include <dev/usb/usbhal.h>
#endif
a137 1
#ifndef USBHAL
a172 8
#else
const char *
usbd_errstr(usbd_status err)
{
	/* TODO - Make a suitable version for debug HAL builds */
	return "XXX";
}
#endif
d1581 3
a1583 2
#if defined(__riscos) && !defined(USBHAL)
        if(dev->dv_unit)kill_system_variable(dev->dv_unit);
@


1.24
log
@Fix for uninitialised wMaxPacketSize causing enumeration FS failure
The order of the new device enumeration means we have the initial device descriptor (hence bMaxPacketSize) but don't compute wMaxPacketSize until after addressing.
The XHCI HC needs this value by the addressing stage in order to setup the control endpoint context (other HC don't need it until later) so the specific case of a full speed device whose endpoint 0 has a non default max packet size would be set up using the default (of 64), then when the full device descriptor is requested the packet looks like a short transfer and the transaction ends having only collected (eg) 8 bytes. This would then appear as vendor &0000 product &0000 and not get any further.
Tested on Titanium.

Version 1.15. Tagged as 'NetBSD-1_15'
@
text
@d47 2
d50 2
@


1.23
log
@Revert accidental commits
Admin:
  These changes are currently subject to rework via the normal submissions channel.
@
text
@a1256 12
	/* Pick a free address on this bus segment */
	if (bus->methods->new_device_addr != NULL)
		addr = bus->methods->new_device_addr(dev); /* Also sets MPS for EP0 */
	else
		addr = usbd_getnewaddr(bus);
	if (addr < 0) {
		printf("%s: No free USB addresses, new device ignored.\n",
		       USBDEVNAME(bus->bdev));
		usbd_remove_device(dev, up);
		return (USBD_NO_ADDR);
	}

d1297 12
@


1.22
log
@  Fixes for Isochronous data transfer
Detail:
Frontend
========

NetBSD.build.c.usbmodule
	frontend isochronous changes
	forces reads to always be multiple of maxpacket
NetBSD.dev.usb.c.usb_subr
	datatoggle fix
	panic fix
NetBSD.dev.usb.c.usbdi
	usbd_transfer changed so that bufrem is passed the xfer pointer instead of the buffer pointer
	fixed missing braces in usbd_clear_endpoint_stall

EHCI
====

The HS (USB2) isochronous as been rewritten and isochronous split transactions - FS (USB1) over a HS Connection - has been added

NetBSD.dev.usb.c.ehci
NetBSD.dev.usb.h.ehcireg
NetBSD.dev.usb.h.ehcivar

OHCI
====

Changes to the NetBSD backend to get isochronous transfers working on a OHCI device. While it did have isochronous support it wasn't working properly.

NetBSD.dev.usb.c.ohci

Admin:
  Submitted by Colin Granville
Tested in iMx6

Version 1.10. Tagged as 'NetBSD-1_10'
@
text
@a437 1

a439 1

a593 1
		ifc->endpoints[endpt].datatoggle = 0;
a1198 1
		dev->myhsport = NULL;
@


1.21
log
@Add support for HC with hardware enumerate phase
Detail:
  Support controllers such as the XHCI which perform some steps of enumeration themselves in hardware, thereby needing some steps of the software enumeration to be bypassed.
  usb.c:
    Internally permit addr of 0, to represent the root hub, since the controller is responsible for allocating 1+. Merged from NetBSD 1.144.
  usb_subr.c:
    Test pointers against NULL not 0. Merged from NetBSD 1.191.
    Add 4 new bus methods, for prior to enumeration, address assignment phase, post enumeration fixup, and device removal.
  usbdivar.h:
    Prototypes of 4 new bus methods.
Admin:
  HC API version number bumped.
  Submission from Elesar.

Version 1.08. Tagged as 'NetBSD-1_08'
@
text
@d438 1
d441 1
d596 1
d1202 1
@


1.20
log
@Update to use rationalised power and overcurrent API
OHCIDriver (only) had sketchy support for a HAL based scheme for controlling the port power and monitor overcurrent. However the implementation was limited to supporting the single port required for an embedded product (aka Rhenium in the CVS history). The change makes it follow a model much more akin to the HAL_TimerDevice/HAL_TimerIRQStatus/HAL_TimerIRQClear set of functions.
Version:
  Bumped OHCIDriver and USBDriver version numbers.
ohcimodule.c:
  Use some defines from OsBytes.h.
  Group the debug variables within the OHCI_DEBUG define so they go away in the release case.
  Allow for up to 15 ports to be controlled via the revised HAL API, and pass something other than a hardwired controller of 0 when controlling/monitoring power.
  Enumerate the device numbers for overcurrent monitoring on startup.
  Deal with the possibility of one (or more) of the device numbers being shared interrupts.
  Squash a few trivial compiler warnings.
ohcimodhead.cmhg:
  rename the handler/entry to reflect their use for overcurrent
ohci.c:
  Allow for up to 15 ports to be controlled by passing in the port index where needed.
usb_subr.c/usbdivar.h:
  Remove a RISC OS-ism in datatoggle, to converge with NetBSD a bit.
ehcivar.h/usb_port.h:
  Relocate the overrides for mutex_ functions here since this is the only controller using them. Previously when in "usb_port.h" they would indirectly get dragged in ia the nested include in "usb.h". The could in fact now be implemented using SyncLib, an exercise left to the reader.
usb.h
  Merge some of the device classes and other allocations from NetBSD.

While it's not been possible to test the revised API, due to not having sight of the original platform on which it was implemented, none of the actively maintained HALs currently use the HAL based power and overcurrent scheme anyway, so the new code never gets called. In that respect, it's no more broken then the previous single port-single controller version.

Version 0.89. Tagged as 'NetBSD-0_89'
@
text
@d900 1
a900 1
		if (bus->devices[addr] == 0)
a1142 6
	addr = usbd_getnewaddr(bus);
	if (addr < 0) {
		printf("%s: No free USB addresses, new device ignored.\n",
		       USBDEVNAME(bus->bdev));
		return (USBD_NO_ADDR);
	}
d1174 1
a1174 1
	/* doesn't matter, just don't let it uninitialized */
d1223 9
d1250 4
a1253 1
	/* Windows resets the port here, do likewise */
d1257 12
d1301 6
d1326 4
a1329 1
	err = usbd_set_address(dev, addr);
d1384 9
d1420 2
d1655 2
@


1.19
log
@Merge in latest usbd_new_device() changes from NetBSD
Detail:
  dev/usb/c/usb_subr - Merge in latest usbd_new_device() changes from NetBSD (rev 1.196). This primarily changes around the order of the SET_ADDRESS and descriptor get calls, as well as changing the descriptor get to request 64 bytes of data instead of 8.
  build/Version - Bump USBDriver version number
Admin:
  Tested on BB-xM, Raspberry Pi, Iyonix ROM softload
  Fixes issue reported on forums with Raspberry Pi Model A not initialising correctly when connected as a device. Previously it was getting stuck fetching the descriptors after setting the address.
  http://www.riscosopen.org/forum/forums/5/topics/2534


Version 0.82. Tagged as 'NetBSD-0_82'
@
text
@a1179 1
#ifndef __riscos /* No datatoggle member (and we memset dev to zero anyway!) */
a1181 1
#endif
@


1.18
log
@Add the ability to build the USB drivers as HAL-compatible static libraries
Detail:
  build/Makefile, build/OBJEHCIDriver, build/OBJOHCIDriver, build/OBJUSBDriver - Modified makefiles to build the HAL libs during the export libs phase
  build/!MkHAL,fd7 - Handy script for building the HAL libs
  build/Hdr/usbhal - Header containing definitions for the assembler code. Also gets exported so that HALs know how much workspace to reserve.
  build/c/usbhal - HAL version of usbmodule.c & port.c. Also contains the keyboard scan code, adapted from the code in the Tungsten HAL.
  build/s/porthal - Assembler versions of some port.c routines that were easier to do in assembler than C
  build/s/halheap - OS_Heap code that's been adapted for use in the HAL. Could easily be changed into a standalone library instead of being part of the HAL USB libs. Supports memory-efficient allocation of aligned blocks.
  build/c/ehcihal - HAL version of ehcimodule.c. Currently only supports EHCI controllers exposed via HAL_USBControllerInfo (i.e. no PCI support)
  build/c/ehcimodule, build/c/ohcimodule, build/c/port - Moved riscos_irq_clear into port.c. Removed unused microtime() function.
  build/c/usbmouse - Strip out some debug-related code in non-debug builds
  build/Version - Updated version numbers
  dev/usb/c/ehci, dev/usb/h/ehcivar - Adapted to add support for the HAL build. Apart from the base changes, the code has also been tweaked to significantly reduce the amount of memory used at runtime by the HAL version of the driver.
  dev/usb/c/hid, dev/usb/c/uhub, dev/usb/c/usb, dev/usb/c/usb_quirks, dev/usb/c/usb_subr, dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/c/usbroothub_subr - Changes to support HAL builds. Mainly disabling bits that won't work in the HAL or disabling bits for RISC OS in general if they weren't being used in the first place.
  dev/usb/c/ohci, dev/usb/h/ohcivar - Basic changes to support HAL builds. However HAL OHCI support is still incomplete.
  dev/usb/h/usb_port - Added support for the HAL build. Also tweaked logprintf definition to get rid of logprintf calls entirely in non-debug builds.
  dev/usb/h/usbdivar - Added support for the HAL build.
  dev/usb/h/usbhal - New header used by the HAL build. Gets included by every C file to ensure the compiler doesn't use sb, and contains structs/macros to allow access to the shared workspace.
Admin:
  HAL & non-HAL builds tested on rev C2 BB, rev A2 BB-xM, rev C1 TouchBook.
  Non-HAL builds tested with Iyonix ROM softload.
  Needs latest Kernel source for OSEntries.h export.


Version 0.59. Tagged as 'NetBSD-0_59'
@
text
@d1095 28
d1145 1
a1145 1
                printf("%s: No free USB addresses, new device ignored.\n",
d1154 2
a1155 2
        /* M_ZERO does nothing on RISC OS, so we do it explicitly here */
        memset(dev, 0, sizeof(*dev));
d1168 10
a1177 1
	USETW(dev->def_ep_desc.wMaxPacketSize, USB_MAX_IPACKET);
d1180 5
d1219 1
d1222 4
d1231 3
a1233 17
	/* Set the address.  Do this early; some devices need that. */
	err = usbd_set_address(dev, addr);
        DPRINTFN(5,("usbd_new_device: setting device address=%d\n", addr));
        if (err) {
                DPRINTFN(-1,("usb_new_device: set address %d failed\n", addr));
                err = USBD_SET_ADDR_FAILED;
                usbd_remove_device(dev, up);
                return (err);
        }
	/* Allow device time to set new address */
	usbd_delay_ms(dev, USB_SET_ADDRESS_SETTLE);
	dev->address = addr;	/* New device address now */
	bus->devices[addr] = dev;

        dd = &dev->ddesc;
        /* Try a few times in case the device is slow (i.e. outside specs.) */
        for (i = 0; i < 10; i++) {
d1235 1
a1235 1
		err = usbd_get_desc(dev, UDESC_DEVICE, 0, USB_MAX_IPACKET, dd);
d1240 1
a1240 1
                        usbd_reset_port(up->parent, port, &ps);
d1244 1
a1244 1
			      "failed\n", addr));
d1249 4
d1257 3
a1259 2
			printf("usbd_new_device: addr=%d bad max packet size\n",
			       addr);
d1287 45
d1352 1
a1352 1
                usb_disconnect_port(up, parent);
d1357 1
a1357 1
  	}
d1359 1
a1359 1
  	return (USBD_NORMAL_COMPLETION);
@


1.17
log
@	Replaced ep resync mechanism in usb_subr
Detail:
	in recent work endpoint resync mechanism in usb_subr
	was removed to re-align better with current NetBSD
	sources.. however without the mechanism Epson
	scanners fail to do repeat scans/
Admin:	Castle added IP


Version 0.46. Tagged as 'NetBSD-0_46'
@
text
@d41 3
d113 1
d115 1
d137 1
d173 8
a302 1
#ifndef __riscos
a306 3
#else
		vendor = usbd_get_string(dev, udd->iManufacturer, v);
#endif
a307 1
#ifndef __riscos
a311 3
#else
		product = usbd_get_string(dev, udd->iProduct, p);
#endif
d351 1
d378 1
d1172 1
d1174 1
d1470 1
a1470 1
#ifdef __riscos
@


1.16
log
@	re-merged some items missed by Dan, and corrected usbmodule for
	1 item missed earlier.. interrupt out endpoints noe demonstrated
	working
Detail:
Admin:  jb  Castle added IP


Version 0.45. Tagged as 'NetBSD-0_45'
@
text
@d851 21
a871 20
//        /* Clear any stall and make sure DATA0 toggle will be used next. */
//        if (UE_GET_ADDR(ep->edesc->bEndpointAddress) != USB_CONTROL_ENDPOINT) {
//                err = usbd_clear_endpoint_stall(p);
//#ifdef __riscos
//                /* Some devices reject this command, so ignore a STALL. */
//                /* On RiscOS, I've found devices giving IOERROR here too */
//                if (err && err != USBD_STALLED && err != USBD_IOERROR) {
//#else
//                /* Some devices reject this command, so ignore a STALL. */
//                if (err && err != USBD_STALLED) {
//#endif
//                        printf("usbd_setup_pipe: failed to start endpoint, %s\n", usbd_errstr(err));
//                        DPRINTFN(-1,("usbd_setup_pipe: endpoint=0x%x failed to clear toggle, error="
//                         "%s\n",
//                         ep->edesc->bEndpointAddress, usbd_errstr(err)));
//                p->methods->close(p);
//                free(p, M_USB);
//                return (err);
//                }
//        }
@


1.15
log
@  Now handles interrupt out transfers

Detail:
  There were many places where this was broken: the devicefs
interface was always starting off a read regardless of
whether it was an IN or OUT transfer, usbdi.c was setting
OUT interrupt transfers as repeating, which doesn't make sense,
and ohci.c was always making interrupt transfers OUT (this is
fixed in the latest BSD sources). Also the code which
unhalts endpoints at start of day has been removed, as this is
no longer in the BSD sources having been removed after it was
seend to have caused problems.

Admin:
  Tested with a CATC analyzer on an AverMedia FM radio. If now
operates properly with the code from Dave Higton.

Version 0.43. Tagged as 'NetBSD-0_43'
@
text
@d1 1
a1 1
/*      $NetBSD: usb_subr.c,v 1.120 2004/10/23 16:17:56 augustss Exp $  */
d5 1
a5 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
d42 1
a42 1
//__KERNEL_RCSID(0, "$NetBSD: usb_subr.c,v 1.120 2004/10/23 16:17:56 augustss Exp $");
d119 5
a123 1
struct usb_knowndev {
d126 1
a126 2
	int			flags;
	char			*vendorname, *productname;
a127 1
#define	USB_KNOWNDEV_NOPROD	0x01		/* match on vendor only */
d280 1
a280 1
	const struct usb_knowndev *kdp;
d316 10
a325 16
	if (vendor == NULL || product == NULL) {
		for(kdp = usb_knowndevs;
		    kdp->vendorname != NULL;
		    kdp++) {
			if (kdp->vendor == UGETW(udd->idVendor) &&
			    (kdp->product == UGETW(udd->idProduct) ||
			     (kdp->flags & USB_KNOWNDEV_NOPROD) != 0))
				break;
		}
		if (kdp->vendorname != NULL) {
			if (vendor == NULL)
			    vendor = kdp->vendorname;
			if (product == NULL)
			    product = (kdp->flags & USB_KNOWNDEV_NOPROD) == 0 ?
				kdp->productname : NULL;
		}
d415 3
d419 1
d851 20
d1257 3
d1261 1
d1459 3
a1461 1

@


1.14
log
@	Update of NetBSD elements (except c.ohci) to track NetBSD current
	from mid April 2005.
	Inclusion of Mods to c.ehci (from Dan) to correctly handle low
	speed interrupt devices beyond USB2 hubs (i.e. keyboards and mice).
	Mod to EHCI resetting in service call handler to better cope with
	USBDriver being restarted 'underneath' it.
Detail:
Admin:
	Castle, Dan Ellis, NetBSD added IP. Tested at Castle. Will be
	beta tested at this revision level before full release.


Version 0.39. Tagged as 'NetBSD-0_39'
@
text
@d1 1
a1 1
/*      $NetBSD: usb_subr.c,v 1.122 2005/03/04 05:03:19 mycroft Exp $   */
d5 1
a5 1
 * Copyright (c) 1998, 2004 The NetBSD Foundation, Inc.
d42 1
a42 1
//__KERNEL_RCSID(0, "$NetBSD: usb_subr.c,v 1.122 2005/03/04 05:03:19 mycroft Exp $");
d93 1
a93 1
#ifdef __riscos        
d119 1
a119 5
struct usb_vendor {
        usb_vendor_id_t         vendor;
        char                    *vendorname;
};
struct usb_product {
d122 2
a123 1
        char                    *productname;
d125 1
d278 1
a278 1
        int n;
d314 16
a329 10
        if (vendor == NULL) {
                for (n = 0; n < usb_nvendors; n++)
                        if (usb_vendors[n].vendor == UGETW(udd->idVendor))
                                vendor = usb_vendors[n].vendorname;
        }
        if (product == NULL) {
                for (n = 0; n < usb_nproducts; n++)
                        if (usb_products[n].vendor == UGETW(udd->idVendor) &&
                            usb_products[n].product == UGETW(udd->idProduct))
                                product = usb_products[n].productname;
a418 3
#ifdef __riscos
		QueryDelay(dev, "USB$PortResetDelay",USB_PORT_RESET_DELAY);
#else
a419 1
#endif
a850 20
	/* Clear any stall and make sure DATA0 toggle will be used next. */
        if (UE_GET_ADDR(ep->edesc->bEndpointAddress) != USB_CONTROL_ENDPOINT) {
		err = usbd_clear_endpoint_stall(p);
#ifdef __riscos
                /* Some devices reject this command, so ignore a STALL. */
                /* On RiscOS, I've found devices giving IOERROR here too */
                if (err && err != USBD_STALLED && err != USBD_IOERROR) {
#else
                /* Some devices reject this command, so ignore a STALL. */
                if (err && err != USBD_STALLED) {
#endif
                        printf("usbd_setup_pipe: failed to start endpoint, %s\n", usbd_errstr(err));
                        DPRINTFN(-1,("usbd_setup_pipe: endpoint=0x%x failed to clear toggle, error="
                         "%s\n",
                         ep->edesc->bEndpointAddress, usbd_errstr(err)));
                p->methods->close(p);
                free(p, M_USB);
	        return (err);
		}
        }
d972 1
a972 1
                if (dev->subdevs == NULL) {
d1040 1
a1040 1
                if (dev->subdevs == 0)
a1236 3
#ifdef __riscos
		usb_disconnect_port(up, parent);
#else
a1237 1
#endif
d1264 1
d1435 1
a1435 3
#ifdef __riscos
	if(dev->dv_unit)kill_system_variable(dev->dv_unit);
#endif
@


1.13
log
@         small change at start of pipe open process to accomodate
         error return provided by some mass storage devices.
Detail:
Admin:   tested at castle.. castle added ip


Version 0.38. Tagged as 'NetBSD-0_38'
@
text
@d1 1
a1 1
/*      $NetBSD: usb_subr.c,v 1.120 2004/10/23 16:17:56 augustss Exp $  */
d5 1
a5 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
d42 1
a42 1
//__KERNEL_RCSID(0, "$NetBSD: usb_subr.c,v 1.120 2004/10/23 16:17:56 augustss Exp $");
d119 5
a123 1
struct usb_knowndev {
d126 1
a126 2
	int			flags;
	char			*vendorname, *productname;
a127 1
#define	USB_KNOWNDEV_NOPROD	0x01		/* match on vendor only */
d280 1
a280 1
	const struct usb_knowndev *kdp;
d316 10
a325 16
	if (vendor == NULL || product == NULL) {
		for(kdp = usb_knowndevs;
		    kdp->vendorname != NULL;
		    kdp++) {
			if (kdp->vendor == UGETW(udd->idVendor) &&
			    (kdp->product == UGETW(udd->idProduct) ||
			     (kdp->flags & USB_KNOWNDEV_NOPROD) != 0))
				break;
		}
		if (kdp->vendorname != NULL) {
			if (vendor == NULL)
			    vendor = kdp->vendorname;
			if (product == NULL)
			    product = (kdp->flags & USB_KNOWNDEV_NOPROD) == 0 ?
				kdp->productname : NULL;
		}
@


1.12
log
@        An increased delay caused havoc with chicony keyboards in the field
Detail:
        USB_PORT_RESET_DELAY had been increased from 100 to 200ms in previous
        version. This was OK for most devices, and beneficial for some, BUT
        killed the Chicony keyboards shipped with many iyonix.. Delay has
        been reverted to 100ms, and is now run time alterable via the
        USB$PortResetDelay sysvar. This problem did not show up in beta testing!

Admin:  tested by JB with chicony.. delays up to around 160ms work with
        the chicony.
        Castle added IP

Version 0.36. Tagged as 'NetBSD-0_36'
@
text
@d858 5
d865 1
@


1.11
log
@         changes and bug fixes that came to light following USB2 launch.
Detail:
         - VarVal launching.. string length was incorrectly calculated.
         - USB VarVals now correctly cleared if device failed during
           enumeration, after first SetVarVal call.
         - Triggercbs() modified to check interrupt context and be
           refuse (quietly) to trigger callbacks if interrupts threaded
           (result of possible issue .. but perhaps wise)
         - Added third QueryDelay variable, and an Info file to describe
           what does what.
Admin:
         checked at Castle.. due for extended check via beta test site
         before formal release.

         Castle + D Ellis added IP


Version 0.35. Tagged as 'NetBSD-0_35'
@
text
@d419 3
d423 1
@


1.10
log
@        Stack brought up to date with NetBSD sources as at 20050121.
        USB2 further debugged.
Detail:
        Check in prior to second beta release. Improvements also to
        softloading of replacement modules.
Admin:
        Checked with JB .. further crosschecking is still needed for rhenium.
        Castle/D Ellis added ip from NetBSD sources


Version 0.33. Tagged as 'NetBSD-0_33'
@
text
@d986 1
a986 1
		if (dev->subdevs == NULL) {
d1054 1
a1054 1
		if (dev->subdevs == 0)
d1251 3
d1255 1
a1281 1

d1452 3
a1454 1

@


1.9
log
@        Update of EHCIDriver to current NetBSD, together with needed changes
        in both OHCIDriver and USBDriver.


Detail:
        Code may change before formal release .. will be beta released
        ... Entered to CVS to get new version numbers, and for
        the record.
Admin:
        Castle/netbsd added IP .. will be tested more fully before
        formal release. Still to be verified on Rhenium.


Version 0.31. Tagged as 'NetBSD-0_31'
@
text
@d86 4
d93 1
d95 1
d98 3
a100 2
Static int usbd_print(void *aux, const char *pnp);
Static int usbd_submatch(device_ptr_t, struct cfdata *cf, void *);
d207 1
d253 1
a253 1

d556 1
a556 1
                logprintf("usbd_fill_iface_data: bad descriptor(s): %s\n",
d576 1
a576 1
                                        logprintf("usbd_fill_iface_data: bad max "
d769 1
a769 1
                        logprintf("%s: device addr %d (config %d) exceeds power "
d856 1
a856 1
                        DPRINTF(("usbd_setup_pipe: failed to start endpoint, %s\n", usbd_errstr(err)));
d910 1
a910 1
            logprintf("%s: Device creation failed\n", USBDEVNAME(dev->bus->bdev));
d965 1
a965 1
                        logprintf("%s: port %d, set config at addr %d failed\n",
d1010 1
a1010 1
                                        logprintf("%s: Device creation failed\n",
d1102 1
a1102 1
                logprintf("%s: No free USB addresses, new device ignored.\n",
d1494 1
a1494 1
                logprintf("usb_disconnect_port: no device\n");
d1502 1
a1502 1
                        logprintf("%s: at %s", USBDEVPTRNAME(dev->subdevs[i]),
d1505 2
a1506 2
                                logprintf(" port %d", up->portno);
                        logprintf(" (addr %d) disconnected\n", dev->address);
@


1.8
log
@  Extensive changes and bug fixes to usb and ohci ..
  'blocked' several holes that could cause freezes with awkward
  usb devices.  Added latest changes from Dan Ellis too , especially for USB2
Detail:
 many
Admin:
 Tested in ROM at Castle, and beta tested with users


Version 0.28. Tagged as 'NetBSD-0_28'
@
text
@d1 1
a1 1
/*      $NetBSD: usb_subr.c,v 1.116 2004/06/23 06:27:54 mycroft Exp $   */
d42 1
a42 1
__KERNEL_RCSID(0, "$NetBSD: usb_subr.c,v 1.116 2004/06/23 06:27:54 mycroft Exp $");
d245 2
a262 1
#ifndef __riscos
d279 6
d286 1
d288 6
d295 1
d524 2
a525 2
                int epsz = nendpt * sizeof(struct usbd_endpoint);
                ifc->endpoints = malloc(epsz, M_USB, M_NOWAIT);
a527 1
                memset (ifc->endpoints, 0, epsz);
d844 1
a844 1
        if (UE_GET_ADDR(ep->edesc->bEndpointAddress) != USB_CONTROL_ENDPOINT)
d846 4
a849 2
        if (err) {
                DPRINTFN(-1,("usbd_setup_pipe: endpoint=0x%x failed to clear toggle, error="
d855 2
a856 1
	}
d1081 1
a1081 1
	usbd_device_handle dev;
d1088 1
d1126 5
a1130 1
	for (hub = up->parent;
d1132 1
a1132 1
	     hub = hub->myhub)
d1134 13
a1146 1
	dev->myhighhub = hub;
a1158 7
	up->device = dev;

        dd = &dev->ddesc;
        /* Try a few times in case the device is slow (i.e. outside specs.) */
        for (i = 0; i < 10; i++) {
                err=NULL;
                if((i&3)==0){
d1161 7
a1167 1
                        DPRINTFN(-1,("usbd_new_device: setting device address=%d loop=%d\n", addr,i));
a1171 1
                }
d1173 3
a1176 1
                if(!err)
d1182 1
a1182 1
                        err = usbd_reset_port(up->parent, port, &ps); 
d1273 2
a1274 2
	up->device = 0;
	dev->bus->devices[dev->address] = 0;
d1317 2
a1318 1
usbd_submatch(struct device *parent, struct cfdata *cf, void *aux)
d1337 1
a1337 2
	    ((uaa->port != 0 &&
	      cf->uhubcf_port != UHUB_UNK_PORT &&
@


1.7
log
@  New versions from John.
Detail:
  * All modules will now rmkill/rmload more reliably
  * Keyboard driver disables kernel debounce on new enough kernels, needed
    for many PS2-USB adaptors, bar code scanners etc
  * Mouse driver will scroll wheel scroll any windows that do respond to
    scroll events, otherwise it issues PointerReason_WheelChange (9) to an
    external WimpScroll module
  * Several bugs and an interrupt hole resolved
Admin:
  Tested at Framlingham.

Version 0.25. Tagged as 'NetBSD-0_25'
@
text
@d1 1
a1 1
/*	$NetBSD: usb_subr.c,v 1.111 2004/03/15 10:35:04 augustss Exp $	*/
d42 1
a42 1
__KERNEL_RCSID(0, "$NetBSD: usb_subr.c,v 1.111 2004/03/15 10:35:04 augustss Exp $");
d87 2
a88 1
Static void usbd_devinfo_vp(usbd_device_handle, char *, char *, int);
d161 1
a161 1
		     usb_string_descriptor_t *sdesc)
d182 1
a182 1
	if (actlen < 1)
d186 12
a197 5
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
        return (usbd_do_request(dev, &req, (void*) sdesc));
#else
	return (usbd_do_request(dev, &req, sdesc));
#endif
d209 1
d217 3
a219 2
		err = usbd_get_string_desc(dev, USB_LANGUAGE_TABLE, 0, &us);
		if (err || us.bLength < 4) {
d226 1
a226 1
	err = usbd_get_string_desc(dev, si, dev->langid, &us);
d230 1
a230 1
	n = us.bLength / 2 - 1;
d263 2
a264 1
usbd_devinfo_vp(usbd_device_handle dev, char *v, char *p, int usedev)
d310 1
a310 1
		strcpy(v, vendor);
d312 1
a312 1
		sprintf(v, "vendor 0x%04x", UGETW(udd->idVendor));
d314 1
a314 1
		strcpy(p, product);
d316 1
a316 1
		sprintf(p, "product 0x%04x", UGETW(udd->idProduct));
d321 1
a321 1
usbd_printBCD(char *cp, int bcd)
d323 1
a323 1
	return (sprintf(cp, "%x.%02x", bcd >> 8, bcd & 0xff));
d327 1
a327 1
usbd_devinfo(usbd_device_handle dev, int showclass, char *cp)
d333 3
d337 3
a339 2
	usbd_devinfo_vp(dev, vendor, product, 1);
	cp += sprintf(cp, "%s %s", vendor, product);
d341 1
a341 1
		cp += sprintf(cp, ", class %d/%d",
d345 2
a346 2
	cp += sprintf(cp, ", rev ");
	cp += usbd_printBCD(cp, bcdUSB);
d348 2
a349 2
	cp += usbd_printBCD(cp, bcdDevice);
	cp += sprintf(cp, ", addr %d", dev->address);
d417 3
d421 1
d629 1
a629 1
	DPRINTFN(5,("usbd_set_config_index: dev=%p index=%d\n", dev, index));
d633 1
a633 1
		DPRINTF(("usbd_set_config_index: free old config\n"));
d647 1
a647 1
		DPRINTF(("usbd_set_config_index: set config 0\n"));
d872 1
a872 1
	int found, i, confi, nifaces;
d1127 5
d1134 1
a1134 7
	DPRINTFN(5,("usbd_new_device: setting device address=%d\n", addr));
	if (err) {
		DPRINTFN(-1,("usb_new_device: set address %d failed\n", addr));
		err = USBD_SET_ADDR_FAILED;
		usbd_remove_device(dev, up);
		return (err);
	}
d1139 1
a1140 3
	dd = &dev->ddesc;
	/* Try a few times in case the device is slow (i.e. outside specs.) */
	for (i = 0; i < 10; i++) {
d1142 1
d1148 1
a1148 1
			usbd_reset_port(up->parent, port, &ps);
d1256 1
a1256 1
		usbd_devinfo(uaa->device, 1, devinfo);
d1350 4
a1353 2
	usbd_devinfo_vp(dev, di->udi_vendor, di->udi_product, usedev);
	usbd_printBCD(di->udi_release, UGETW(dev->ddesc.bcdDevice));
@


1.6
log
@Fixes from John Ballance:

Version 0.23. Tagged as 'NetBSD-0_23'
@
text
@d1 1
a1 1
/*	$NetBSD: usb_subr.c,v 1.100 2002/09/27 03:18:22 thorpej Exp $	*/
d42 3
a44 1
//__KERNEL_RCSID(0, "$NetBSD: usb_subr.c,v 1.100 2002/09/27 03:18:22 thorpej Exp $");
a76 1

d164 1
d170 8
a177 2
	USETW(req.wLength, 1);	/* only size byte first */
	err = usbd_do_request(dev, &req, (void *)sdesc);
d180 4
d185 5
a189 1
	return (usbd_do_request(dev, &req, (void *)sdesc));
d256 1
a256 1
	char *vendor = 0, *product = 0;
d271 4
d348 1
a348 1
		tsleep(&ms, PRIBIO, "usbdly", (ms*hz+999)/1000 + 1, 1);
d490 2
a491 2
	        int epsz = nendpt * sizeof(struct usbd_endpoint);
		ifc->endpoints = malloc(epsz, M_USB, M_NOWAIT);
d494 1
a494 1
		memset (ifc->endpoints, 0, epsz);
d515 1
a515 1
		logprintf("usbd_fill_iface_data: bad descriptor(s): %s\n",
d535 1
a535 1
					logprintf("usbd_fill_iface_data: bad max "
d608 1
a608 1
	int ifcidx, nifc, len, selfpowered, power;
d620 1
a620 1
		free((void *)dev->cdesc, M_USB);
d644 12
a655 2
	/* Get the full descriptor. */
	err = usbd_get_desc(dev, UDESC_CONFIG, index, len, (void *)cdp);
d658 1
d668 4
a671 6
	if (!(dev->quirks->uq_flags & UQ_BUS_POWERED)) {
		switch (cdp->bmAttributes & (UC_BUS_POWERED | UC_SELF_POWERED))
		{
		    case UC_SELF_POWERED: selfpowered = 1; break;
		    case UC_BUS_POWERED: break;
		    default:
d686 3
d690 1
a699 1
			    if (cdp->bMaxPower > 0) {
a706 1
			    }
d708 2
a709 1
		}
d728 1
a728 1
			logprintf("%s: device addr %d (config %d) exceeds power "
d773 1
a773 1
	free((void *)cdp, M_USB);
d811 1
a811 1
	if (UE_GET_ADDR(ep->edesc->bEndpointAddress) != USB_CONTROL_ENDPOINT)
d813 7
a819 7
	if (err) {
		DPRINTFN(-1,("usbd_setup_pipe: endpoint=0x%x failed to clear toggle, error="
			 "%s\n",
			 ep->edesc->bEndpointAddress, usbd_errstr(err)));
		p->methods->close(p);
		free(p, M_USB);
		return (err);
d866 1
a866 1
	    logprintf("%s: Device creation failed\n", USBDEVNAME(dev->bus->bdev));
d889 2
a890 2
		dev->subdevs = malloc(3 * sizeof dv, M_USB, M_NOWAIT);
		found = 1;
d921 1
a921 1
			logprintf("%s: port %d, set config at addr %d failed\n",
d938 1
a938 1
		dev->subdevs = malloc((nifaces+2) * sizeof dv, M_USB,M_NOWAIT);
d966 1
a966 1
					logprintf("%s: Device creation failed\n",
d1007 1
a1007 1
		if (!dev->subdevs)
d1014 1
a1014 1
		dev->subdevs[found] = 0;
d1048 1
d1057 1
a1057 1
		logprintf("%s: No free USB addresses, new device ignored.\n",
d1067 1
a1067 1
	memset(dev, 0, sizeof(*dev));
d1107 15
d1124 1
a1124 1
	for (i = 0; i < 3; i++) {
d1126 1
a1126 1
		err = usbd_get_desc(dev, UDESC_DEVICE, 0, USB_MAX_IPACKET, (void *)dd);
d1130 2
d1144 1
a1144 1
			logprintf("usbd_new_device: addr=%d bad max packet size\n",
a1180 15
	/* Set the address */
	err = usbd_set_address(dev, addr);
	DPRINTFN(5,("usbd_new_device: setting device address=%d\n", addr));
	if (err) {
		DPRINTFN(-1,("usb_new_device: set address %d failed\n", addr));
		err = USBD_SET_ADDR_FAILED;
		usbd_remove_device(dev, up);
		return (err);
	}
	/* Allow device time to set new address */
	usbd_delay_ms(dev, USB_SET_ADDRESS_SETTLE);

	dev->address = addr;	/* New device address now */
	bus->devices[addr] = dev;

d1240 1
a1240 1
		logprintf("%s, %s", devinfo, pnp);
d1243 1
a1243 1
		logprintf(" port %d", uaa->port);
d1245 1
a1245 1
		logprintf(" configuration %d", uaa->configno);
d1247 1
a1247 1
		logprintf(" interface %d", uaa->ifaceno);
d1255 1
a1255 1
		logprintf(" vendor 0x%04x", uaa->vendor);
d1257 1
a1257 1
		logprintf(" product 0x%04x", uaa->product);
d1259 1
a1259 1
		logprintf(" release 0x%04x", uaa->release);
d1398 1
a1398 1
		free((void *)dev->cdesc, M_USB);
d1433 1
a1433 1
		logprintf("usb_disconnect_port: no device\n");
d1441 1
a1441 1
			logprintf("%s: at %s", USBDEVPTRNAME(dev->subdevs[i]),
d1444 2
a1445 2
				logprintf(" port %d", up->portno);
			logprintf(" (addr %d) disconnected\n", dev->address);
d1447 1
@


1.5
log
@Merge of Dan Ellis's USB2 sources.

Version 0.22. Tagged as 'NetBSD-0_22'
@
text
@d470 2
a471 2
		ifc->endpoints = malloc(nendpt * sizeof(struct usbd_endpoint),
					M_USB, M_NOWAIT);
d474 1
@


1.4
log
@Added new CallDevice reason code (&80000005) to clear a stall condition on
a pipe with a given FileSwitch handle
New usbdevs and usbdevs_data from NetBSD
Rewrote power source detection to skirt round dodgy devices which say
they're self powered,set MaxPower=0,and don't respond to a getstatus()
Copes better with devices being unplugged while a transfer using them is active

Version 0.17. Tagged as 'NetBSD-0_17'
@
text
@d1 1
a1 1
/*	$NetBSD: usb_subr.c,v 1.79 2000/06/01 14:37:51 augustss Exp $	*/
d41 3
d85 2
a86 1
Static usbd_status	usbd_set_config(usbd_device_handle, int);
d121 1
a121 1
Static const char *usbd_error_strs[] = {
a151 3
#ifdef __riscos
	        snprintf(buffer, sizeof buffer, "%.4d", err);
#else
a152 1
#endif
d194 1
a194 1
			dev->langid = 0; /* Well, just pick English then */
a204 1

d219 16
a235 1
/* handle this function entirely in RISC OS */
d237 1
a237 1
usbd_devinfo_vp(usbd_device_handle dev, char *v, char *p)
d250 9
a258 2
	vendor = usbd_get_string(dev, udd->iManufacturer, v);
	product = usbd_get_string(dev, udd->iProduct, p);
d270 1
a270 1
			if (!vendor)
d272 1
a272 1
			if (!product)
d281 1
a281 1
	    sprintf(v, "vendor 0x%04x", UGETW(udd->idVendor));
d285 1
a285 1
	    sprintf(p, "product 0x%04x", UGETW(udd->idProduct));
d303 1
a303 1
	usbd_devinfo_vp(dev, vendor, product);
d330 1
a330 1
        	tsleep(&ms, PRIBIO, "usbdly", (ms*hz+999)/1000 + 1);
d358 1
a358 1
	n = 100;
a362 2
		DPRINTFN(1, ("usbd_reset_port: %3d port change = %x\n",
		    n, UGETW(ps->wPortChange)));
d368 1
a368 1
		/* If the device disappeared, just give up */
d479 1
a479 1
//#define ed ((__packed usb_endpoint_descriptor_t *)p)
a480 1
                usb_endpoint_descriptor_t *ed;
a482 1
			ed = (usb_endpoint_descriptor_t *)p;
d494 4
a497 4
		DPRINTF(("usbd_fill_iface_data: bad descriptor(s): %s\n",
			 ed->bLength == 0 ? "0 length" :
			 ed->bDescriptorType == UDESC_INTERFACE ? "iface desc":
			 "out of data"));
d501 22
d634 1
d636 31
a666 11
	/* Figure out if the device is self or bus powered. */
	if (! (((cdp->bmAttributes & (UC_SELF_POWERED | UC_BUS_POWERED)) == UC_BUS_POWERED) ||
	    /* Reports as being exclusively bus powered */
	    (dev->quirks->uq_flags & UQ_BUS_POWERED)) ) {
	    /* Or a buggy device known to lie and is bus powered really */
		if ((cdp->bmAttributes & (UC_BUS_POWERED | UC_SELF_POWERED)) == UC_SELF_POWERED) {
		    /* Reports as being exclusively self powered */
			selfpowered = 1;
		} else {
			if (cdp->bMaxPower > 0) {
			   /* Supports both bus and self powered plus nonzero MaxPower - must ask */
d668 7
a674 6
				if (!err && (UGETW(ds.wStatus) & UDS_SELF_POWERED)) {
					selfpowered = 1; /* Status says self powering at present */
					DPRINTF(("usbd_set_config_index: status=0x%04x, "
						 "error=%s\n",
						 UGETW(ds.wStatus), usbd_errstr(err)));
				}
d678 1
a678 1
	DPRINTF(("usbd_set_config_index: (addr %d) attr=0x%02x, "
d680 1
a680 1
		 dev->address, cdp->bmAttributes,
d692 1
d753 2
a754 2
	DPRINTFN(1,("usbd_setup_pipe: dev=%p iface=%p ep=%p pipe=%p &pipe_handle= %p\n",
		    dev, iface, ep, pipe, &p));
a768 1
	usb_callout_init(p->abort_handle);
d833 1
a833 1
	    DPRINTF(("%s: Device creation failed\n", USBDEVNAME(dev->bus->bdev)));
d853 1
a853 1
	dv = (device_ptr_t) USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print, usbd_submatch);
a908 1

d922 1
a922 1
			dv = (device_ptr_t) USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print,
d971 1
a971 1
	dv = (device_ptr_t) USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print, usbd_submatch);
d1010 1
a1010 1
		int lowspeed, int port, struct usbd_port *up)
d1013 1
d1019 2
a1020 2
	DPRINTF(("usbd_new_device bus=%p port=%d depth=%d lowspeed=%d\n",
		 bus, port, depth, lowspeed));
d1028 1
a1028 1
	dev = malloc(sizeof *dev, M_USB, M_NOWAIT);
d1031 2
d1034 1
a1051 1
	dev->lowspeed = lowspeed != 0;
d1054 7
d1088 11
a1098 1
	DPRINTF(("usb_new_device: succeeded after %d attempts\n", i));
d1101 1
a1101 1
		 "subclass=%d, protocol=%d, maxpacket=%d, len=%d, ls=%d\n",
d1104 1
a1104 1
		 dev->lowspeed));
d1204 1
a1204 1
		DPRINTF(("%s, %s", devinfo, pnp));
d1207 1
a1207 1
		DPRINTF((" port %d", uaa->port));
d1209 1
a1209 1
		DPRINTF((" configuration %d", uaa->configno));
d1211 1
a1211 1
		DPRINTF((" interface %d", uaa->ifaceno));
d1219 1
a1219 1
		DPRINTF((" vendor 0x%04x", uaa->vendor));
d1221 1
a1221 1
		DPRINTF((" product 0x%04x", uaa->product));
d1223 1
a1223 1
		DPRINTF((" release 0x%04x", uaa->release));
d1270 13
a1282 1
	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
d1288 2
a1289 1
usbd_fill_deviceinfo(usbd_device_handle dev, struct usb_device_info *di)
d1294 14
a1307 14
	di->bus = USBDEVUNIT(dev->bus->bdev);
	di->addr = dev->address;
	di->cookie = dev->cookie;
	usbd_devinfo_vp(dev, di->vendor, di->product);
	usbd_printBCD(di->release, UGETW(dev->ddesc.bcdDevice));
	di->vendorNo = UGETW(dev->ddesc.idVendor);
	di->productNo = UGETW(dev->ddesc.idProduct);
	di->releaseNo = UGETW(dev->ddesc.bcdDevice);
	di->class = dev->ddesc.bDeviceClass;
	di->subclass = dev->ddesc.bDeviceSubClass;
	di->protocol = dev->ddesc.bDeviceProtocol;
	di->config = dev->config;
	di->power = dev->self_powered ? 0 : dev->power;
	di->lowspeed = dev->lowspeed;
d1312 1
a1312 1
			strncpy(di->devnames[i], USBDEVPTRNAME(dev->subdevs[i]),
d1314 1
a1314 1
			di->devnames[i][USB_MAX_DEVNAMELEN-1] = '\0';
d1320 1
a1320 1
                di->devnames[i][0] = 0;                 /* empty */
d1324 1
a1324 1
		     i < sizeof(di->ports) / sizeof(di->ports[0]) &&
d1341 1
a1341 1
			di->ports[i] = err;
d1343 1
a1343 1
		di->nports = dev->hub->hubdesc.bNbrPorts;
d1345 1
a1345 1
		di->nports = 0;
d1397 1
a1397 1
		DPRINTF(("usb_disconnect_port: no device\n"));
d1405 2
a1406 2
			DPRINTF(("%s: at %s", USBDEVPTRNAME(dev->subdevs[i]),
			       hubname));
d1408 2
a1409 3
				DPRINTF((" port %d", up->portno));
			DPRINTF((" (addr %d) disconnected\n", dev->address));
#if defined(__NetBSD__) || defined(__OpenBSD__) || defined(__riscos)
a1410 5
#elif defined(__FreeBSD__)
                        device_delete_child(device_get_parent(dev->subdevs[i]),
					    dev->subdevs[i]);
#endif

@


1.3
log
@  Support for SCSISoftUSB, and some tidying up.
Detail:
  * Errors now use the allocated error number base, &819000, instead of a
    base in the private range, &50000000. "USB transfer failed" errors now
    have use a sub-range of error numbers from &819020; the original BSD
    error number can be retrieved from the bottom 5 bits of the RISC OS
    error number.
  * Service_USB 1 now returns the list in the order in which the devices,
    rather than in the reverse order as previous versions of the module did.
  * A little tweaking of h/usb_port to reduce compiler warnings.
  * Some compiler-satisfying changes to allow use of packed structures.
    (However, the compiler doesn't seem to work correctly yet, so this is
    currently switched out using -DDISABLE_PACKED on the command line.)
  * Added full stops to end of star command help strings for consistency
    with rest of OS.
  * New exports: USBDevFS (moved here from ^.h) and a few files in dev/usb/h
    and sys/h.
Admin:
  Error number overhaul and new exports are both required by SCSISoftUSB.

Version 0.16. Tagged as 'NetBSD-0_16'
@
text
@d595 1
d597 6
a602 13
	selfpowered = 0;
	if (!(dev->quirks->uq_flags & UQ_BUS_POWERED) &&
	    (cdp->bmAttributes & UC_SELF_POWERED)) {
		/* May be self powered. */
		if (cdp->bmAttributes & UC_BUS_POWERED) {
			/* Must ask device. */
			err = usbd_get_device_status(dev, &ds);
			if (!err && (UGETW(ds.wStatus) & UDS_SELF_POWERED))
				selfpowered = 1;
			DPRINTF(("usbd_set_config_index: status=0x%04x, "
				 "error=%s\n",
				 UGETW(ds.wStatus), usbd_errstr(err)));
		} else
d604 12
@


1.2
log
@Nicked a few hub related fixes from later NetBSD versions.
Added stuff to delete the DeviceFS$USB*$Options variables when the module is
RMkilled.

Version 0.12. Tagged as 'NetBSD-0_12'
@
text
@d169 1
a169 1
	err = usbd_do_request(dev, &req, sdesc);
d173 1
a173 1
	return (usbd_do_request(dev, &req, sdesc));
d560 1
a560 1
		free(dev->cdesc, M_USB);
d585 1
a585 1
	err = usbd_get_desc(dev, UDESC_CONFIG, index, len, cdp);
d672 1
a672 1
	free(cdp, M_USB);
d1001 1
a1001 1
		err = usbd_get_desc(dev, UDESC_DEVICE, 0, USB_MAX_IPACKET, dd);
d1263 1
a1263 1
		free(dev->cdesc, M_USB);
@


1.1
log
@Import of USB driver suitable for generic PCI based OHCI controllers.
Correction of spelling of busses to buses (noun plural).
OHCIdriver only responds to PCI service call to lookup vendor name when
the device is of class OHCI controller.

Version 0.01. Tagged as 'NetBSD-0_01'
@
text
@d257 1
a257 1
	if (vendor != NULL)
d261 1
a261 1
	if (product != NULL)
d349 3
d729 1
@


head	1.16;
access;
symbols
	USBDriver-1_29:1.16
	USBDriver-1_28:1.16
	USBDriver-1_27:1.16
	USBDriver-1_26:1.16
	USBDriver-1_25:1.16
	USBDriver-1_24:1.16
	USBDriver-1_23:1.16
	USBDriver-1_22:1.15
	USBDriver-1_21:1.15
	USBDriver-1_20:1.15
	USBDriver-1_19:1.15
	NetBSD-1_19:1.15
	NetBSD-1_18:1.15
	NetBSD-1_17:1.15
	NetBSD-1_16:1.15
	NetBSD-1_15:1.15
	NetBSD-1_14:1.15
	NetBSD-1_13:1.15
	NetBSD-1_12:1.15
	NetBSD-1_09-1:1.15
	NetBSD-1_11:1.15
	NetBSD-1_10:1.15
	NetBSD-1_09:1.15
	NetBSD-1_08:1.15
	NetBSD-1_07:1.14
	NetBSD-1_06:1.14
	NetBSD-1_05:1.14
	NetBSD-1_04:1.14
	NetBSD-1_03:1.14
	NetBSD-1_02:1.14
	NetBSD-1_01:1.14
	NetBSD-1_00:1.14
	NetBSD-0_99:1.13
	NetBSD-0_98:1.13
	NetBSD-0_97:1.13
	NetBSD-0_96:1.13
	NetBSD-0_95:1.13
	NetBSD-0_94:1.13
	NetBSD-0_93:1.13
	NetBSD-0_92:1.13
	NetBSD-0_91:1.13
	NetBSD-0_90:1.13
	NetBSD-0_89:1.13
	NetBSD-0_88:1.12
	NetBSD-0_87:1.12
	NetBSD-0_86:1.12
	NetBSD-0_85:1.12
	NetBSD-0_84:1.12
	NetBSD-0_83:1.12
	NetBSD-0_82:1.12
	NetBSD-0_81:1.12
	NetBSD-0_80:1.12
	NetBSD-0_79:1.12
	NetBSD-0_78:1.12
	NetBSD-0_77:1.12
	NetBSD-0_76:1.12
	NetBSD-0_75:1.12
	NetBSD-0_74:1.12
	NetBSD-0_73:1.12
	NetBSD-0_72:1.12
	NetBSD-0_71:1.12
	NetBSD-0_70:1.12
	NetBSD-0_69:1.12
	NetBSD-0_68:1.12
	NetBSD-0_67:1.12
	NetBSD-0_66:1.12
	NetBSD-0_65:1.12
	NetBSD-0_64:1.12
	NetBSD-0_63:1.12
	NetBSD-0_62:1.12
	NetBSD-0_61:1.12
	NetBSD-0_60:1.12
	NetBSD-0_59:1.12
	NetBSD-0_58:1.11
	NetBSD-0_57:1.11
	NetBSD-0_56:1.11
	NetBSD-0_55:1.11
	NetBSD-0_54:1.11
	NetBSD-0_53:1.11
	NetBSD-0_52:1.11
	NetBSD-0_51:1.10
	NetBSD-0_50:1.10
	NetBSD-0_49:1.10
	NetBSD-0_48:1.10
	NetBSD-0_47:1.10
	NetBSD-0_46:1.10
	NetBSD-0_45:1.10
	NetBSD-0_44:1.10
	NetBSD-0_43:1.10
	NetBSD-0_42:1.10
	NetBSD-0_41:1.10
	NetBSD-0_40:1.10
	NetBSD-0_39:1.10
	NetBSD-0_38:1.9
	NetBSD-0_37:1.9
	NetBSD-0_36:1.8
	NetBSD-0_35:1.8
	NetBSD-0_34:1.7
	NetBSD-0_33:1.7
	NetBSD-0_32:1.6
	NetBSD-0_31:1.6
	NetBSD-0_30:1.5
	NetBSD-0_29:1.5
	RO_5_07:1.5
	NetBSD-0_28:1.5
	NetBSD-0_27:1.4
	NetBSD-0_26:1.4
	NetBSD-0_25:1.4
	NetBSD-0_24:1.3
	NetBSD-0_23:1.3
	NetBSD-0_21-1_22_2_1:1.1
	NetBSD-0_22:1.2
	USB1:1.1.0.2
	NetBSD-0_21:1.1
	NetBSD-0_20:1.1
	NetBSD-0_19:1.1
	NetBSD-0_18:1.1
	NetBSD-0_17:1.1
	NetBSD-0_16:1.1
	NetBSD-0_15:1.1
	NetBSD-0_14:1.1
	NetBSD-0_13:1.1
	NetBSD-0_12:1.1
	NetBSD-0_11:1.1
	NetBSD-0_10:1.1
	NetBSD-0_09:1.1
	NetBSD-0_08:1.1
	NetBSD-0_07:1.1
	NetBSD-0_06:1.1
	NetBSD-0_05:1.1
	NetBSD-0_04:1.1
	NetBSD-0_03:1.1
	NetBSD-0_02:1.1
	NetBSD-0_01:1.1;
locks; strict;
comment	@# @;


1.16
date	2017.10.07.09.08.50;	author rool;	state Exp;
branches;
next	1.15;
commitid	Qzw5gnXY6CB2g6aA;

1.15
date	2015.11.15.09.42.46;	author rool;	state Exp;
branches;
next	1.14;
commitid	QBgP4ciWEprNGaJy;

1.14
date	2015.08.22.08.58.53;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	Gxk8mCJ5kQ38bfyy;

1.13
date	2014.10.25.18.43.45;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	SYXBVhhWAW5D5CVx;

1.12
date	2011.05.22.20.22.46;	author jlee;	state Exp;
branches;
next	1.11;
commitid	Ye1jVWDlKivFSIkv;

1.11
date	2010.07.21.23.57.21;	author jlee;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.24.23.13.54;	author jballance;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.24.14.02.56;	author jballance;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.18.00.35.56;	author jballance;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.21.22.30.19;	author jballance;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.30.02.34.22;	author jballance;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.12.14.47.42;	author jballance;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.06.15.50.23;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.16.15.43.51;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.21.20.49.20;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.28.09.55.18;	author dellis;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Clear up duplicate/unused OHCI/EHCI source files
Detail:
  Remove the (now) unused sources from when this component produced multiple targets. See Controllers/OHCIDriver & Controllers/EHCIDriver for the live copies.
  Remove unset USBHAL defines.
  Simplify the Makefile and !Mk* scripts.
  No longer export usbroothub_subr.h.
  Add a porting type "device_t" to usb_port.h.
Admin:
  Submission for USB bounty.

Version 1.23. Tagged as 'USBDriver-1_23'
@
text
@/*      $NetBSD: usbdivar.h,v 1.73 2005/01/24 01:30:38 joff Exp $       */
/*	$FreeBSD: src/sys/dev/usb/usbdivar.h,v 1.11 1999/11/17 22:33:51 n_hibma Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#if defined(__NetBSD__)
#include <sys/callout.h>
#include <sys/mutex.h>
#include <sys/bus.h>
#endif

#ifdef __riscos
typedef void * usb_dma_t;
#else
/* From usb_mem.h */
struct usb_dma_block;
typedef struct {
	struct usb_dma_block *block;
	u_int offs;
} usb_dma_t;
#endif

struct usbd_xfer;
struct usbd_pipe;
struct usbd_port;

struct usbd_endpoint {
	usb_endpoint_descriptor_t *edesc;
	int			refcnt;
	int datatoggle;
};

struct usbd_bus_methods {
	usbd_status	      (*open_pipe)(struct usbd_pipe *pipe);
	void		      (*soft_intr)(void *);
	void		      (*do_poll)(struct usbd_bus *);
	usbd_status	      (*allocm)(struct usbd_bus *, usb_dma_t *,
					u_int32_t bufsize);
	void		      (*freem)(struct usbd_bus *, usb_dma_t *);
	struct usbd_xfer *    (*allocx)(struct usbd_bus *);
	void		      (*freex)(struct usbd_bus *, struct usbd_xfer *);
	usbd_status	      (*new_device_pre)(usbd_device_handle);
	int		      (*new_device_addr)(usbd_device_handle);
	usbd_status	      (*new_device_post)(usbd_device_handle);
	void		      (*remove_device)(usbd_device_handle);
};

struct usbd_pipe_methods {
	usbd_status	      (*transfer)(usbd_xfer_handle xfer);
	usbd_status	      (*start)(usbd_xfer_handle xfer);
	void		      (*abort)(usbd_xfer_handle xfer);
	void		      (*close)(usbd_pipe_handle pipe);
	void		      (*cleartoggle)(usbd_pipe_handle pipe);
	void		      (*done)(usbd_xfer_handle xfer);
};

struct usbd_tt {
	struct usbd_hub	       *hub;
};

struct usbd_port {
	usb_port_status_t	status;
	u_int16_t		power;	/* mA of current on port */
	u_int8_t		portno;
	u_int8_t		restartcnt;
#define USBD_RESTART_MAX 5
	u_int8_t		reattach;
	struct usbd_device     *device;	/* Connected device */
	struct usbd_device     *parent;	/* The ports hub */
	struct usbd_tt	       *tt; /* Transaction translator (if any) */
};

struct usbd_hub {
	usbd_status	      (*explore)(usbd_device_handle hub);
	void		       *hubsoftc;
	usb_hub_descriptor_t	hubdesc;
	struct usbd_port        ports[1];
};

struct usb_softc;

/*****/

struct usbd_bus {
	/* Filled by HC driver */
	USBBASEDEVICE		bdev; /* base device, host adapter */
	void			*hci_private;
	const struct usbd_bus_methods	*methods;
	u_int32_t		pipe_size; /* size of a pipe struct */
	/* Filled by usb driver */
	struct usbd_device     *root_hub;
	usbd_device_handle	devices[USB_MAX_DEVICES];
	char			needs_explore;/* a hub a signalled a change */
	char			use_polling;
	struct usb_softc       *usbctl;
	struct usb_device_stats	stats;
	int 			intr_context;
	u_int			no_intrs;
#ifdef __riscos
        unsigned int            callbacks;
#endif
	int			usbrev;	/* USB revision */
#define USBREV_UNKNOWN	0
#define USBREV_PRE_1_0	1
#define USBREV_1_0	2
#define USBREV_1_1	3
#define USBREV_2_0	4
#define USBREV_STR { "unknown", "pre 1.0", "1.0", "1.1", "2.0" }

#ifdef USB_USE_SOFTINTR
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	void		       *soft; /* soft interrupt cookie */
#else
	struct callout		softi;
#endif
#endif

#ifndef __riscos
	bus_dma_tag_t		dmatag;	/* DMA tag */
#endif
};

struct usbd_device {
	struct usbd_bus	       *bus;           /* our controller */
	struct usbd_pipe       *default_pipe;  /* pipe 0 */
	u_int8_t		address;       /* device addess */
	u_int8_t		config;	       /* current configuration # */
	u_int8_t		depth;         /* distance from root hub */
	u_int8_t		speed;         /* low/full/high speed */
	u_int8_t		self_powered;  /* flag for self powered */
	u_int16_t		power;         /* mA the device uses */
	int16_t			langid;	       /* language for strings */
#define USBD_NOLANG (-1)
	usb_event_cookie_t	cookie;	       /* unique connection id */
	struct usbd_port       *powersrc;      /* upstream hub port, or 0 */
	struct usbd_device     *myhub; 	       /* upstream hub */
	struct usbd_port       *myhsport;      /* closest high speed port */
	struct usbd_endpoint	def_ep;	       /* for pipe 0 */
	usb_endpoint_descriptor_t def_ep_desc; /* for pipe 0 */
	struct usbd_interface  *ifaces;        /* array of all interfaces */
	usb_device_descriptor_t ddesc;         /* device descriptor */
	usb_config_descriptor_t *cdesc;	       /* full config descr */
	const struct usbd_quirks     *quirks;  /* device quirks, always set */
	struct usbd_hub	       *hub;           /* only if this is a hub */
	int			subdevlen;     /* array length of following */
	device_ptr_t	       *subdevs;       /* sub-devices, 0 terminated */
	int			nifaces_claimed; /* number of ifaces in use */
	void		       *hci_private;
#ifdef __riscos
	int			dv_unit;       /* underlying RISCOS device num */
#endif
};

struct usbd_interface {
	struct usbd_device     *device;
	usb_interface_descriptor_t *idesc;
	int			index;
	int			altindex;
	struct usbd_endpoint   *endpoints;
	void		       *priv;
	LIST_HEAD(, usbd_pipe)	pipes;
};

struct usbd_pipe {
	struct usbd_interface  *iface;
	struct usbd_device     *device;
	struct usbd_endpoint   *endpoint;
	int			refcnt;
	char			running;
	char			aborting;
	SIMPLEQ_HEAD(, usbd_xfer) queue;
	LIST_ENTRY(usbd_pipe)	next;

	usbd_xfer_handle	intrxfer; /* used for repeating requests */
	char			repeat;
	int			interval;

	/* Filled by HC driver. */
	const struct usbd_pipe_methods *methods;
};

struct usbd_xfer {
	struct usbd_pipe       *pipe;
	void		       *priv;
	void		       *buffer;
	u_int32_t		length;
	u_int32_t		actlen;
	u_int16_t		flags;
	u_int32_t		timeout;
	usbd_status		status;
	usbd_callback		callback;
	volatile u_int8_t	done;
	u_int8_t		busy_free;	/* used for DIAGNOSTIC */
#define XFER_FREE 0x46
#define XFER_BUSY 0x55
#define XFER_ONQU 0x9e

	/* For control pipe */
	usb_device_request_t	request;

	/* For isoc */
	u_int16_t		*frlengths;
	int			nframes;

	/* For memory allocation */
	struct usbd_device     *device;
	usb_dma_t		dmabuf;

	u_int8_t		rqflags;
#define URQ_REQUEST	0x01
#define URQ_AUTO_DMABUF	0x10
#define URQ_DEV_DMABUF	0x20
#ifdef __riscos
#define URQ_RISCOS_BUF	0x80
#endif

	SIMPLEQ_ENTRY(usbd_xfer) next;

	void		       *hcpriv; /* private use by the HC driver */
	u_int8_t		hcflags; /* private use by the HC driver */
#define UXFER_ABORTING	0x01	/* xfer is aborting. */
#define UXFER_ABORTWAIT	0x02	/* abort completion is being awaited. */

        struct callout timeout_handle;
};

void usbd_init(void);
void usbd_finish(void);

#ifdef USB_DEBUG
void usbd_dump_iface(struct usbd_interface *iface);
void usbd_dump_device(struct usbd_device *dev);
void usbd_dump_endpoint(struct usbd_endpoint *endp);
void usbd_dump_queue(usbd_pipe_handle pipe);
void usbd_dump_pipe(usbd_pipe_handle pipe);
#endif

/* Routines from usb_subr.c */
int		usbctlprint(void *, const char *);
void		usb_delay_ms(usbd_bus_handle, u_int);
usbd_status	usbd_reset_port(usbd_device_handle, int, usb_port_status_t *);
usbd_status	usbd_setup_pipe(usbd_device_handle dev,
				usbd_interface_handle iface,
				struct usbd_endpoint *, int,
				usbd_pipe_handle *pipe);
usbd_status	usbd_new_device(device_ptr_t, usbd_bus_handle, int, int, int,
                                struct usbd_port *);
void		usbd_remove_device(usbd_device_handle, struct usbd_port *);
int		usbd_printBCD(char *, size_t, int);
usbd_status	usbd_fill_iface_data(usbd_device_handle, int, int);
void		usb_free_device(usbd_device_handle);

usbd_status	usb_insert_transfer(usbd_xfer_handle);
void		usb_transfer_complete(usbd_xfer_handle);
void            usb_disconnect_port(struct usbd_port *, device_ptr_t);

/* Routines from usb.c */
void		usb_needs_explore(usbd_device_handle);
void		usb_schedsoftintr(struct usbd_bus *);

/* useful macros */
#ifdef __riscos
/* delay on a device for delay  read from a sysvar (else delay for default) */
#define QueryDelay(dev, var, default)                              \
                {                                                  \
                    char* getenv (const char*);                    \
                    int atoi (const char*);                        \
                    char* del = getenv (var);                      \
                    usbd_delay_ms(dev, del? atoi (del):            \
                        default);                                  \
                }                                                  
#endif

/*
 * XXX This check is extremely bogus. Bad Bad Bad.
 */
#if defined(DIAGNOSTIC) && 0
#define SPLUSBCHECK \
	do { int _s = splusb(), _su = splusb(); \
             if (!cold && _s != _su) printf("SPLUSBCHECK failed 0x%x!=0x%x, %s:%d\n", \
				   _s, _su, __FILE__, __LINE__); \
	     splx(_s); \
        } while (0)
#else
#define SPLUSBCHECK
#endif

/* Locator stuff. */

#if defined(__NetBSD__)
#include "locators.h"
#elif defined(__FreeBSD__) || defined(__OpenBSD__) || defined (__riscos)
/* XXX these values are used to statically bind some elements in the USB tree
 * to specific driver instances. This should be somehow emulated in FreeBSD
 * but can be done later on.
 * The values are copied from the files.usb file in the NetBSD sources.
 */
#define UHUBCF_PORT_DEFAULT -1
#define UHUBCF_CONFIGURATION_DEFAULT -1
#define UHUBCF_INTERFACE_DEFAULT -1
#define UHUBCF_VENDOR_DEFAULT -1
#define UHUBCF_PRODUCT_DEFAULT -1
#define UHUBCF_RELEASE_DEFAULT -1
#endif

#if defined (__OpenBSD__)
#define	UHUBCF_PORT		0
#define	UHUBCF_CONFIGURATION	1
#define	UHUBCF_INTERFACE	2
#define	UHUBCF_VENDOR		3
#define	UHUBCF_PRODUCT		4
#define	UHUBCF_RELEASE		5
#endif

#define	uhubcf_port		cf_loc[UHUBCF_PORT]
#define	uhubcf_configuration	cf_loc[UHUBCF_CONFIGURATION]
#define	uhubcf_interface	cf_loc[UHUBCF_INTERFACE]
#define	uhubcf_vendor		cf_loc[UHUBCF_VENDOR]
#define	uhubcf_product		cf_loc[UHUBCF_PRODUCT]
#define	uhubcf_release		cf_loc[UHUBCF_RELEASE]
#define	UHUB_UNK_PORT		UHUBCF_PORT_DEFAULT /* wildcarded 'port' */
#define	UHUB_UNK_CONFIGURATION	UHUBCF_CONFIGURATION_DEFAULT /* wildcarded 'configuration' */
#define	UHUB_UNK_INTERFACE	UHUBCF_INTERFACE_DEFAULT /* wildcarded 'interface' */
#define	UHUB_UNK_VENDOR		UHUBCF_VENDOR_DEFAULT /* wildcarded 'vendor' */
#define	UHUB_UNK_PRODUCT	UHUBCF_PRODUCT_DEFAULT /* wildcarded 'product' */
#define	UHUB_UNK_RELEASE	UHUBCF_RELEASE_DEFAULT /* wildcarded 'release' */

@


1.15
log
@Add support for HC with hardware enumerate phase
Detail:
  Support controllers such as the XHCI which perform some steps of enumeration themselves in hardware, thereby needing some steps of the software enumeration to be bypassed.
  usb.c:
    Internally permit addr of 0, to represent the root hub, since the controller is responsible for allocating 1+. Merged from NetBSD 1.144.
  usb_subr.c:
    Test pointers against NULL not 0. Merged from NetBSD 1.191.
    Add 4 new bus methods, for prior to enumeration, address assignment phase, post enumeration fixup, and device removal.
  usbdivar.h:
    Prototypes of 4 new bus methods.
Admin:
  HC API version number bumped.
  Submission from Elesar.

Version 1.08. Tagged as 'NetBSD-1_08'
@
text
@a80 4
#ifdef USBHAL
	int		      (*do_intr)(struct usbd_bus *,int irqdevno);
	void		      (*shutdown)(struct usbd_bus *);
#endif
d184 1
a184 1
#if defined(__riscos) && !defined(USBHAL)
d248 2
a249 2
#if defined(__riscos) && !defined(USBHAL)
#define URQ_RISCOS_BUF  0x80
a298 3
#ifdef USBHAL
#define QueryDelay(dev, var, default) usbd_delay_ms(dev, default)
#else
a307 1
#endif
@


1.14
log
@Add some missing struct members
From NetBSD dev/usb/usbdivar.h 1.109.
As these extra members change the struct layout, bump the API version number too. Having carefully analysed which headers are actually required by host controllers (in NetBSD-0_98) also be explicit about them in Hdr/USBDriver rather than the former vague comment in h/usbdivar.

Hdr/USBDriver:
  Relocate API define here.
usbmodule.c:
  Include USBDriver.h to get the API define.
usbdivar.h:
  Add struct members from recent NetBSD.

Version 1.00. Tagged as 'NetBSD-1_00'
@
text
@d77 4
@


1.13
log
@Update to use rationalised power and overcurrent API
OHCIDriver (only) had sketchy support for a HAL based scheme for controlling the port power and monitor overcurrent. However the implementation was limited to supporting the single port required for an embedded product (aka Rhenium in the CVS history). The change makes it follow a model much more akin to the HAL_TimerDevice/HAL_TimerIRQStatus/HAL_TimerIRQClear set of functions.
Version:
  Bumped OHCIDriver and USBDriver version numbers.
ohcimodule.c:
  Use some defines from OsBytes.h.
  Group the debug variables within the OHCI_DEBUG define so they go away in the release case.
  Allow for up to 15 ports to be controlled via the revised HAL API, and pass something other than a hardwired controller of 0 when controlling/monitoring power.
  Enumerate the device numbers for overcurrent monitoring on startup.
  Deal with the possibility of one (or more) of the device numbers being shared interrupts.
  Squash a few trivial compiler warnings.
ohcimodhead.cmhg:
  rename the handler/entry to reflect their use for overcurrent
ohci.c:
  Allow for up to 15 ports to be controlled by passing in the port index where needed.
usb_subr.c/usbdivar.h:
  Remove a RISC OS-ism in datatoggle, to converge with NetBSD a bit.
ehcivar.h/usb_port.h:
  Relocate the overrides for mutex_ functions here since this is the only controller using them. Previously when in "usb_port.h" they would indirectly get dragged in ia the nested include in "usb.h". The could in fact now be implemented using SyncLib, an exercise left to the reader.
usb.h
  Merge some of the device classes and other allocations from NetBSD.

While it's not been possible to test the revised API, due to not having sight of the original platform on which it was implemented, none of the actively maintained HALs currently use the HAL based power and overcurrent scheme anyway, so the new code never gets called. In that respect, it's no more broken then the previous single port-single controller version.

Version 0.89. Tagged as 'NetBSD-0_89'
@
text
@d43 2
a44 14
#endif

#ifdef __riscos
/* The structures in this file (and a few other files?) are used by the USB HC
   drivers to communicate with the main USBDriver module. Thus, we need to make
   sure that HC driver modules only register themselves with USBDriver if both
   modules use compatible structure definitions.
   So whenever you make a backwards-incompatible change to these shared
   structures, make sure you update this #define to the version of the USBDriver
   module that first implemented those changes (as defined in
   NetBSD.build.Version, not the dummy NetBSD.VersionNum file!). This #define
   is used by both USBDriver and the HC modules to check that both parties are
   using the same API. */
#define RISCOS_USBDRIVER_API_VERSION 49
d60 1
d122 2
a123 1
	struct usbd_bus_methods	*methods;
d180 1
d182 2
@


1.12
log
@Add the ability to build the USB drivers as HAL-compatible static libraries
Detail:
  build/Makefile, build/OBJEHCIDriver, build/OBJOHCIDriver, build/OBJUSBDriver - Modified makefiles to build the HAL libs during the export libs phase
  build/!MkHAL,fd7 - Handy script for building the HAL libs
  build/Hdr/usbhal - Header containing definitions for the assembler code. Also gets exported so that HALs know how much workspace to reserve.
  build/c/usbhal - HAL version of usbmodule.c & port.c. Also contains the keyboard scan code, adapted from the code in the Tungsten HAL.
  build/s/porthal - Assembler versions of some port.c routines that were easier to do in assembler than C
  build/s/halheap - OS_Heap code that's been adapted for use in the HAL. Could easily be changed into a standalone library instead of being part of the HAL USB libs. Supports memory-efficient allocation of aligned blocks.
  build/c/ehcihal - HAL version of ehcimodule.c. Currently only supports EHCI controllers exposed via HAL_USBControllerInfo (i.e. no PCI support)
  build/c/ehcimodule, build/c/ohcimodule, build/c/port - Moved riscos_irq_clear into port.c. Removed unused microtime() function.
  build/c/usbmouse - Strip out some debug-related code in non-debug builds
  build/Version - Updated version numbers
  dev/usb/c/ehci, dev/usb/h/ehcivar - Adapted to add support for the HAL build. Apart from the base changes, the code has also been tweaked to significantly reduce the amount of memory used at runtime by the HAL version of the driver.
  dev/usb/c/hid, dev/usb/c/uhub, dev/usb/c/usb, dev/usb/c/usb_quirks, dev/usb/c/usb_subr, dev/usb/c/usbdi, dev/usb/c/usbdi_util, dev/usb/c/usbroothub_subr - Changes to support HAL builds. Mainly disabling bits that won't work in the HAL or disabling bits for RISC OS in general if they weren't being used in the first place.
  dev/usb/c/ohci, dev/usb/h/ohcivar - Basic changes to support HAL builds. However HAL OHCI support is still incomplete.
  dev/usb/h/usb_port - Added support for the HAL build. Also tweaked logprintf definition to get rid of logprintf calls entirely in non-debug builds.
  dev/usb/h/usbdivar - Added support for the HAL build.
  dev/usb/h/usbhal - New header used by the HAL build. Gets included by every C file to ensure the compiler doesn't use sb, and contains structs/macros to allow access to the shared workspace.
Admin:
  HAL & non-HAL builds tested on rev C2 BB, rev A2 BB-xM, rev C1 TouchBook.
  Non-HAL builds tested with Iyonix ROM softload.
  Needs latest Kernel source for OSEntries.h export.


Version 0.59. Tagged as 'NetBSD-0_59'
@
text
@d76 1
@


1.11
log
@Update EHCI driver to NetBSD latest (as of 10/07/2010), improve DeviceFS interface
Detail:
  EHCI driver update:
    dev/usb/c/ehci - Updated to latest NetBSD version, except for revisions 1.134 and 1.135 which are too invasive to merge in without updating the rest of the USB stack. This new version brings lots of bug fixes, and adds (untested on RISC OS) support for EHCI isochronous transfers.
    dev/usb/h/ehcivar - Updated to latest NetBSD version, except for the sc_bus splitting that was held back from the ehci.c update
    dev/usb/h/usb, dev/usb/h/usbdi, dev/usb/usbdivar - partial update to latest as required/possible
    dev/usb/c/usb_quirks, dev/usb/h/ehcireg, dev/usb/h/usb_mem, dev/usb/h/usb_quirks, dev/usb/h/usbhid, dev/usb/usbdevs, dev/usb/devlist2h.awk, dev/wscons/h/wsconsio, dev/wscons/h/wsmousevar - Updated to latest NetBSD versions
    dev/usb/c/usbroothub_subr, dev/usb/h/usbroothub_subr - New files brought in from NetBSD sources for use with new EHCI driver
    build/objehcidriver - Added usbroorhub_subr to EHCI driver
    dev/usb/h/usb_port - Added extra dummy functions as required by new EHCI driver
    dev/build/c/port - Added extra parameter to callout_init as required by new EHCI driver
  DeviceFS improvements:
    build/c/usbmodule - Added DeviceFSCallDevice_GetHandles2 as a replacement for Thomas Milius's backwards-incompatible GetHandles changes. Added DeviceFSCallDevice_GetSetOptions call to control RX padding and TX force-short-xfer features. These features can also be controlled at endpoint creation time by new fields in the filename. Also fixed packet padding to not fill the buffer with garbage or potentially crash when the padded area is more than one packet in length.
  New bus registration API:
    Changes made to the data structures that are shared between the modules means that new checks are needed to ensure USB modules with incompatible APIs are not used with one another.
    build/h/usbdivar - Since this seems to be the file containing the main structures that are shared, it now has a #define at the top indicating the first version of the USBDriver module that implemented the data structures within. This version number is used to check that the driver modules are compatible.
    build/cmhg/usbmodhead, build/h/usbdriver, build/c/usbmodule - Add a new SWI, USBDriver_Version, to return the version number of the USBDriver module. Used for both intra-stack API version checks and can be useful for external code that wants to query DeviceFS feature availability.
    build/c/usbmodule, build/c/ehcimodule, build/c/ohcimodule - Updated USBDriver_RegisterBus SWI and the code that calls it to pass the API version number (as defined in usbdivar.h) to USBDriver when attempting to reigster the bus. USBDriver then ensures the version matches that of itself, and if not refuses to allow the bus to register. EHCI & OHCI modules also check that USBDriver is new enough to implement this behaviour via the USBDriver_Version SWI.
  And finally:
    build/version - Incremented module version numbers.
    build/doc/usb - Updated with details of new features
Admin:
  Tested in ROM softload on Iyonix & beagleboard. Beagleboard hub issues seem to be resolved, and there are no new bugs that I can see.


Version 0.52. Tagged as 'NetBSD-0_52'
@
text
@d87 4
d190 1
a190 1
#ifdef __riscos
d254 1
a254 1
#ifdef  __riscos
d305 3
d317 1
@


1.10
log
@	Update of NetBSD elements (except c.ohci) to track NetBSD current
	from mid April 2005.
	Inclusion of Mods to c.ehci (from Dan) to correctly handle low
	speed interrupt devices beyond USB2 hubs (i.e. keyboards and mice).
	Mod to EHCI resetting in service call handler to better cope with
	USBDriver being restarted 'underneath' it.
Detail:
Admin:
	Castle, Dan Ellis, NetBSD added IP. Tested at Castle. Will be
	beta tested at this revision level before full release.


Version 0.39. Tagged as 'NetBSD-0_39'
@
text
@d45 17
d63 6
a68 1
DECLARE_USB_DMA_T;
d99 1
a99 1
        struct usbd_hub        *hub;
d101 1
d108 1
a108 1
        u_int8_t                reattach;
d111 1
a111 1
        struct usbd_tt         *tt; /* Transaction translator (if any) */
d158 1
a158 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d216 1
a216 1
	struct usbd_pipe_methods *methods;
d229 5
a233 7
	__volatile char		done;
#ifdef DIAGNOSTIC
	u_int32_t		busy_free;
#define XFER_FREE 0x46524545
#define XFER_BUSY 0x42555359
#define XFER_ONQU 0x4f4e5155
#endif
d246 1
a246 1
	int			rqflags;
d251 1
a251 1
#define URQ_RISCOS_BUF  0x100
d257 3
d261 1
a261 1
	usb_callout_t		timeout_handle;
d278 1
a278 1
usbd_status     usbd_reset_port(usbd_device_handle, int, usb_port_status_t *);
d283 2
a284 2
usbd_status     usbd_new_device(device_ptr_t, usbd_bus_handle, int, int, int,
				struct usbd_port *);
d286 2
a287 2
int             usbd_printBCD(char *, size_t, int);
usbd_status     usbd_fill_iface_data(usbd_device_handle, int, int);
d290 2
a291 2
usbd_status     usb_insert_transfer(usbd_xfer_handle);
void            usb_transfer_complete(usbd_xfer_handle);
@


1.9
log
@        2 specific changes to USBDriver module
        Added (and fixed code underlying) to give periodic
        explore of USB busses (cf NetBSD).
        Added USBDisover command to let user provoke this too.
        Reworked USB device number allocation to roll
        around at 999 to avoid field overflow in
        a number of places.
Detail:
Admin:  castle added IP. to be beta tested on beta test site


Version 0.37. Tagged as 'NetBSD-0_37'
@
text
@d1 1
a1 1
/*      $NetBSD: usbdivar.h,v 1.72 2004/10/23 16:17:56 augustss Exp $   */
d85 1
@


1.8
log
@         changes and bug fixes that came to light following USB2 launch.
Detail:
         - VarVal launching.. string length was incorrectly calculated.
         - USB VarVals now correctly cleared if device failed during
           enumeration, after first SetVarVal call.
         - Triggercbs() modified to check interrupt context and be
           refuse (quietly) to trigger callbacks if interrupts threaded
           (result of possible issue .. but perhaps wise)
         - Added third QueryDelay variable, and an Info file to describe
           what does what.
Admin:
         checked at Castle.. due for extended check via beta test site
         before formal release.

         Castle + D Ellis added IP


Version 0.35. Tagged as 'NetBSD-0_35'
@
text
@d116 1
a116 1
        int                     callbacks;
@


1.7
log
@        Stack brought up to date with NetBSD sources as at 20050121.
        USB2 further debugged.
Detail:
        Check in prior to second beta release. Improvements also to
        softloading of replacement modules.
Admin:
        Checked with JB .. further crosschecking is still needed for rhenium.
        Castle/D Ellis added ip from NetBSD sources


Version 0.33. Tagged as 'NetBSD-0_33'
@
text
@d162 3
@


1.6
log
@        Update of EHCIDriver to current NetBSD, together with needed changes
        in both OHCIDriver and USBDriver.


Detail:
        Code may change before formal release .. will be beta released
        ... Entered to CVS to get new version numbers, and for
        the record.
Admin:
        Castle/netbsd added IP .. will be tested more fully before
        formal release. Still to be verified on Rhenium.


Version 0.31. Tagged as 'NetBSD-0_31'
@
text
@d250 1
a250 2
usbd_status	usbd_reset_port(usbd_device_handle dev,
				int port, usb_port_status_t *ps);
d255 1
a255 3
usbd_status	usbd_new_device(device_ptr_t parent,
				usbd_bus_handle bus, int depth,
				int lowspeed, int port,
d258 2
a259 2
int		usbd_printBCD(char *cp, size_t l, int bcd);
usbd_status	usbd_fill_iface_data(usbd_device_handle dev, int i, int a);
d262 3
a264 3
usbd_status	usb_insert_transfer(usbd_xfer_handle xfer);
void		usb_transfer_complete(usbd_xfer_handle xfer);
void		usb_disconnect_port(struct usbd_port *up, device_ptr_t);
@


1.5
log
@  Extensive changes and bug fixes to usb and ohci ..
  'blocked' several holes that could cause freezes with awkward
  usb devices.  Added latest changes from Dan Ellis too , especially for USB2
Detail:
 many
Admin:
 Tested in ROM at Castle, and beta tested with users


Version 0.28. Tagged as 'NetBSD-0_28'
@
text
@d1 1
a1 1
/*	$NetBSD: usbdivar.h,v 1.70 2002/07/11 21:14:36 augustss Exp $	*/
d76 3
d87 1
d153 1
a153 1
	struct usbd_device     *myhighhub;     /* closest high speed hub */
@


1.4
log
@  New versions from John.
Detail:
  * All modules will now rmkill/rmload more reliably
  * Keyboard driver disables kernel debounce on new enough kernels, needed
    for many PS2-USB adaptors, bar code scanners etc
  * Mouse driver will scroll wheel scroll any windows that do respond to
    scroll events, otherwise it issues PointerReason_WheelChange (9) to an
    external WimpScroll module
  * Several bugs and an interrupt hole resolved
Admin:
  Tested at Framlingham.

Version 0.25. Tagged as 'NetBSD-0_25'
@
text
@d257 1
a257 1
int		usbd_printBCD(char *cp, int bcd);
d268 13
@


1.3
log
@Fixes from John Ballance:

Version 0.23. Tagged as 'NetBSD-0_23'
@
text
@d199 1
a199 1
//#ifdef DIAGNOSTIC
d204 1
a204 3
//#else
//	u_int32_t		busy_freespare;
//#endif
@


1.2
log
@Merge of Dan Ellis's USB2 sources.

Version 0.22. Tagged as 'NetBSD-0_22'
@
text
@d199 1
a199 1
#ifdef DIAGNOSTIC
d204 3
a206 1
#endif
@


1.1
log
@Import of USB driver suitable for generic PCI based OHCI controllers.
Correction of spelling of busses to buses (noun plural).
OHCIdriver only responds to PCI service call to lookup vendor name when
the device is of class OHCI controller.

Version 0.01. Tagged as 'NetBSD-0_01'
@
text
@d1 1
a1 1
/*	$NetBSD: usbdivar.h,v 1.57.2.1 2000/06/27 19:28:19 thorpej Exp $	*/
d58 1
a58 1
	void		      (*soft_intr)(struct usbd_bus *);
d82 1
a82 1
	struct usbd_device     *device;
a110 1
	int			usbrev;	/* USB revision */
d114 1
d119 10
a128 1
#define USBREV_STR { "unknown", "pre 1.0", "1.0", "1.1" }
d141 1
a141 1
	u_int8_t		lowspeed;      /* lowspeed flag */
d148 2
d155 1
a155 1
	struct usbd_quirks     *quirks;        /* device quirks, always set */
a183 2
	usb_callout_t		abort_handle;

d202 2
a203 1
#define XFER_BUSY 0x42555357
d235 8
a245 1
void		usbd_devinfo_vp(usbd_device_handle, char *, char *);
d266 1
a266 1
void		usb_needs_explore(usbd_bus_handle);
@


head	1.2;
access;
symbols
	DWCDriver-0_08:1.1
	DWCDriver-0_07:1.1
	DWCDriver-0_06:1.1
	DWCDriver-0_05:1.1
	DWCDriver-0_04:1.1
	DWCDriver-0_03:1.1
	DWCDriver-0_02:1.1
	DWCDriver-0_01:1.1;
locks; strict;
comment	@# @;


1.2
date	2012.09.17.16.33.21;	author jlee;	state dead;
branches;
next	1.1;
commitid	DXVFy2WJjyak3Ukw;

1.1
date	2012.06.03.15.13.25;	author jlee;	state Exp;
branches;
next	;
commitid	ZZ9X1FvMWAU11h7w;


desc
@@


1.2
log
@Update to version 3.00 of DWC_otg
Detail:
  This big batch of changes brings us in line with rev 70428950df of the Raspberry Pi Linux github.
  Briefly:
  * Deleted HTML docs as they're a waste of space
  * Dropped the SOF fix (which we never used anyway)
  * Dropped our implementation of the microframe scheduling patch, in favour of their implementation
  * Updated to version 3.00 of the DWC sources. Hard to tell what useful changes this brings, due to API tweaks resulting in pretty much every file being littered with changes.
Admin:
  Tested on Raspberry Pi with high processor vectors
  This new version seems like it might be a bit more sensitive to insufficient power supplies. Beware!


Version 0.09. Tagged as 'DWCDriver-0_09'
@
text
@<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DesignWare USB 2.0 OTG Controller (DWC_otg) Device Driver: dwc_otg_pcd.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>dwc_otg_pcd.h File Reference</h1>This file contains the structures, constants, and interfaces for the Perpherial Contoller Driver (PCD). <a href="#_details">More...</a>
<p>
<code>#include &quot;usb.h&quot;</code><br>
<code>#include &quot;<a class="el" href="dwc__otg__cil_8h-source.html">dwc_otg_cil.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="dwc__otg__pcd__if_8h-source.html">dwc_otg_pcd_if.h</a>&quot;</code><br>

<p>
<a href="dwc__otg__pcd_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdwc__otg__pcd__request.html">dwc_otg_pcd_request</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DWC_otg request structure.  <a href="structdwc__otg__pcd__request.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdwc__otg__pcd__ep.html">dwc_otg_pcd_ep</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PCD EP structure.  <a href="structdwc__otg__pcd__ep.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdwc__otg__pcd.html">dwc_otg_pcd</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DWC_otg PCD Structure.  <a href="structdwc__otg__pcd.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ed26bb67f5785dc6e70289976637a310"></a><!-- doxytag: member="dwc_otg_pcd.h::__DWC_PCD_H__" ref="ed26bb67f5785dc6e70289976637a310" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dwc__otg__pcd_8h.html#ed26bb67f5785dc6e70289976637a310">__DWC_PCD_H__</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6dad4d4462e9819753acfc601889faec"></a><!-- doxytag: member="dwc_otg_pcd.h::DDMA_MAX_TRANSFER_SIZE" ref="6dad4d4462e9819753acfc601889faec" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dwc__otg__pcd_8h.html#6dad4d4462e9819753acfc601889faec">DDMA_MAX_TRANSFER_SIZE</a>&nbsp;&nbsp;&nbsp;65535</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Max Transfer size for any EP. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a1c5dc8973b5c039fd77b1e250ce29e2"></a><!-- doxytag: member="dwc_otg_pcd.h::MAX_DMA_DESC_CNT" ref="a1c5dc8973b5c039fd77b1e250ce29e2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dwc__otg__pcd_8h.html#a1c5dc8973b5c039fd77b1e250ce29e2">MAX_DMA_DESC_CNT</a>&nbsp;&nbsp;&nbsp;64</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Max DMA Descriptor count for any EP. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="464549f9f4484651efe25b1a03692d72"></a><!-- doxytag: member="dwc_otg_pcd.h::GET_CORE_IF" ref="464549f9f4484651efe25b1a03692d72" args="(_pcd)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dwc__otg__pcd_8h.html#464549f9f4484651efe25b1a03692d72">GET_CORE_IF</a>(_pcd)&nbsp;&nbsp;&nbsp;(_pcd-&gt;core_if)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the pointer to the core_if from the pcd pointer. <br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="70fcb6a989e5871e16f4c1c96ffe394a"></a><!-- doxytag: member="dwc_otg_pcd.h::ep0state_e" ref="70fcb6a989e5871e16f4c1c96ffe394a" args="" -->
typedef enum <a class="el" href="dwc__otg__pcd_8h.html#f286abbd9be76db05fee7aebfeb61865">ep0_state</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dwc__otg__pcd_8h.html#70fcb6a989e5871e16f4c1c96ffe394a">ep0state_e</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">States of EP0. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="050b65dd6f6dfd9d8527f94bdf88a937"></a><!-- doxytag: member="dwc_otg_pcd.h::dwc_otg_pcd_iso_request_t" ref="050b65dd6f6dfd9d8527f94bdf88a937" args="" -->
typedef usb_iso_request&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dwc__otg__pcd_8h.html#050b65dd6f6dfd9d8527f94bdf88a937">dwc_otg_pcd_iso_request_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DWC_otg iso request structure. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structdwc__otg__pcd__request.html">dwc_otg_pcd_request</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dwc__otg__pcd_8h.html#1253ddf26039ef0a68df3eb5423f65da">dwc_otg_pcd_request_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DWC_otg request structure.  <a href="#1253ddf26039ef0a68df3eb5423f65da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structdwc__otg__pcd__ep.html">dwc_otg_pcd_ep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dwc__otg__pcd_8h.html#fa97bfbab3706fa510ecff969ce39756">dwc_otg_pcd_ep_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PCD EP structure.  <a href="#fa97bfbab3706fa510ecff969ce39756"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dwc__otg__pcd_8h.html#f286abbd9be76db05fee7aebfeb61865">ep0_state</a> { <br>
&nbsp;&nbsp;<b>EP0_DISCONNECT</b>, 
<b>EP0_IDLE</b>, 
<b>EP0_IN_DATA_PHASE</b>, 
<b>EP0_OUT_DATA_PHASE</b>, 
<br>
&nbsp;&nbsp;<b>EP0_IN_STATUS_PHASE</b>, 
<b>EP0_OUT_STATUS_PHASE</b>, 
<b>EP0_STALL</b>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">States of EP0. <br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="649f0875764e42b69accb4ad46a45694"></a><!-- doxytag: member="dwc_otg_pcd.h::DWC_CIRCLEQ_HEAD" ref="649f0875764e42b69accb4ad46a45694" args="(req_list, dwc_otg_pcd_request)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>DWC_CIRCLEQ_HEAD</b> (req_list, <a class="el" href="structdwc__otg__pcd__request.html">dwc_otg_pcd_request</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e8ef6f3d831b89a753d93489827949d3"></a><!-- doxytag: member="dwc_otg_pcd.h::dwc_otg_request_nuke" ref="e8ef6f3d831b89a753d93489827949d3" args="(dwc_otg_pcd_ep_t *ep)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dwc__otg__pcd_8h.html#e8ef6f3d831b89a753d93489827949d3">dwc_otg_request_nuke</a> (<a class="el" href="structdwc__otg__pcd__ep.html">dwc_otg_pcd_ep_t</a> *ep)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function terminates all the requsts in the EP request queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dwc__otg__pcd_8h.html#5c9b20abc81e0f860a8f23c90b10b59e">dwc_otg_request_done</a> (<a class="el" href="structdwc__otg__pcd__ep.html">dwc_otg_pcd_ep_t</a> *ep, <a class="el" href="structdwc__otg__pcd__request.html">dwc_otg_pcd_request_t</a> *req, int32_t status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function completes a request.  <a href="#5c9b20abc81e0f860a8f23c90b10b59e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dwc__otg__pcd_8h.html#b4e2c352426923d4bd519cf18b68206d">dwc_otg_iso_buffer_done</a> (<a class="el" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> *pcd, <a class="el" href="structdwc__otg__pcd__ep.html">dwc_otg_pcd_ep_t</a> *ep, void *req_handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used for perodical data exchnage between PCD and gadget drivers.  <a href="#b4e2c352426923d4bd519cf18b68206d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dwc__otg__pcd_8h.html#9d6d6e24faab6478aef9e2217c9b5ab9">do_test_mode</a> (void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is called when the SET_FEATURE TEST_MODE Setup packet is sent from the host.  <a href="#9d6d6e24faab6478aef9e2217c9b5ab9"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This file contains the structures, constants, and interfaces for the Perpherial Contoller Driver (PCD). 
<p>
The Peripheral Controller Driver (PCD) for Linux will implement the Gadget API, so that the existing Gadget drivers can be used. For the Mass Storage Function driver the File-backed USB Storage Gadget (FBS) driver will be used. The FBS driver supports the Control-Bulk (CB), Control-Bulk-Interrupt (CBI), and Bulk-Only transports. 
<p>
Definition in file <a class="el" href="dwc__otg__pcd_8h-source.html">dwc_otg_pcd.h</a>.<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="1253ddf26039ef0a68df3eb5423f65da"></a><!-- doxytag: member="dwc_otg_pcd.h::dwc_otg_pcd_request_t" ref="1253ddf26039ef0a68df3eb5423f65da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structdwc__otg__pcd__request.html">dwc_otg_pcd_request</a>  <a class="el" href="structdwc__otg__pcd__request.html">dwc_otg_pcd_request_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
DWC_otg request structure. 
<p>
This structure is a list of requests. 
</div>
</div><p>
<a class="anchor" name="fa97bfbab3706fa510ecff969ce39756"></a><!-- doxytag: member="dwc_otg_pcd.h::dwc_otg_pcd_ep_t" ref="fa97bfbab3706fa510ecff969ce39756" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structdwc__otg__pcd__ep.html">dwc_otg_pcd_ep</a>  <a class="el" href="structdwc__otg__pcd__ep.html">dwc_otg_pcd_ep_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
PCD EP structure. 
<p>
This structure describes an EP, there is an array of EPs in the PCD structure. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="5c9b20abc81e0f860a8f23c90b10b59e"></a><!-- doxytag: member="dwc_otg_pcd.h::dwc_otg_request_done" ref="5c9b20abc81e0f860a8f23c90b10b59e" args="(dwc_otg_pcd_ep_t *ep, dwc_otg_pcd_request_t *req, int32_t status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dwc_otg_request_done           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdwc__otg__pcd__ep.html">dwc_otg_pcd_ep_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdwc__otg__pcd__request.html">dwc_otg_pcd_request_t</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function completes a request. 
<p>
It call's the request call back. 
<p>
Definition at line <a class="el" href="dwc__otg__pcd_8c-source.html#l00078">78</a> of file <a class="el" href="dwc__otg__pcd_8c-source.html">dwc_otg_pcd.c</a>.
</div>
</div><p>
<a class="anchor" name="b4e2c352426923d4bd519cf18b68206d"></a><!-- doxytag: member="dwc_otg_pcd.h::dwc_otg_iso_buffer_done" ref="b4e2c352426923d4bd519cf18b68206d" args="(dwc_otg_pcd_t *pcd, dwc_otg_pcd_ep_t *ep, void *req_handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dwc_otg_iso_buffer_done           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdwc__otg__pcd__ep.html">dwc_otg_pcd_ep_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>req_handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used for perodical data exchnage between PCD and gadget drivers. 
<p>
for Isochronous EPs<p>
<ul>
<li>Every time a sync period completes this function is called to perform data exchange between PCD and gadget </li></ul>

<p>
Definition at line <a class="el" href="dwc__otg__pcd_8c-source.html#l00830">830</a> of file <a class="el" href="dwc__otg__pcd_8c-source.html">dwc_otg_pcd.c</a>.
</div>
</div><p>
<a class="anchor" name="9d6d6e24faab6478aef9e2217c9b5ab9"></a><!-- doxytag: member="dwc_otg_pcd.h::do_test_mode" ref="9d6d6e24faab6478aef9e2217c9b5ab9" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void do_test_mode           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is called when the SET_FEATURE TEST_MODE Setup packet is sent from the host. 
<p>
The Device Control register is written with the Test Mode bits set to the specified Test Mode. This is done as a tasklet so that the "Status" phase of the control transfer completes before transmitting the TEST packets.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000033">Todo:</a></b></dt><dd>This has not been tested since the tasklet struct was put into the PCD struct!</dd></dl>

<p>
Definition at line <a class="el" href="dwc__otg__pcd__intr_8c-source.html#l01284">1284</a> of file <a class="el" href="dwc__otg__pcd__intr_8c-source.html">dwc_otg_pcd_intr.c</a>.
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Tue May 5 02:22:49 2009 for DesignWare USB 2.0 OTG Controller (DWC_otg) Device Driver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
@


1.1
log
@Add initial version of DWCDriver - USB driver for Synopsys DWC OTG controllers
Detail:
  A fairly simple wrapper for Synopsys's open source "DWC_otg" Linux driver, based around a GPL-free version of the DWC_otg 2.90a sources received from the Raspberry Pi foundation.
  Instead of interfacing with the Linux USB stack a new host interface layer has been implemented to allow it to talk to the standard BSD-derived RISC OS stack.
  RTSupport is used to provide the threading functionality that the DWC driver relies upon.
  Interesting files:
  - c/cmodule, h/cmodule - Main module frontend
  - c/dwc_common_riscos, h/dwc_common_riscos - Implementation of the OS support layer required by the DWC driver
  - c/dwc_otg_riscos, h/dwc_otg_riscos - Core code for the BSD driver implementation, driver init/shutdown, and for handling calls from the DWC host driver to us
  - c/port - Some support functions required by BSD-style code inherited from the other USB drivers
  - c/softc_device - Code to handle requests from the BSD layer to attached USB devices
  - c/softc_root - Code to handle requests from the BSD layer to the controller root hub
  - dwc/doc/* - Original Synopsys release notes & user guide pdfs
  - dwc/driver/*, dwc/dwc_common_port/* - Synopsys code and documentation. A few tweaks were required to allow it to compile under Norcroft, but otherwise it's functionally equivalent to the original sources.
Admin:
  Tested in BCM2835 ROM
  There are a few loose ends still to tidy up (search for "DWCTODO"), mainly regarding implementation of Isochronous support, but otherwise the driver seems stable enough for daily use.


Version 0.01. Tagged as 'DWCDriver-0_01'
@
text
@@


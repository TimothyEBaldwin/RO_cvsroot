head	1.15;
access;
symbols
	DWCDriver-0_35:1.15
	DWCDriver-0_34:1.14
	DWCDriver-0_33:1.14
	DWCDriver-0_32:1.14
	DWCDriver-0_31:1.13
	DWCDriver-0_30:1.13
	DWCDriver-0_29:1.13
	DWCDriver-0_28:1.12
	DWCDriver-0_27:1.12
	DWCDriver-0_26:1.12
	DWCDriver-0_24-1:1.12
	DWCDriver-0_25:1.11
	DWCDriver-0_24:1.10
	DWCDriver-0_23:1.10
	DWCDriver-0_22:1.10
	DWCDriver-0_21:1.9
	DWCDriver-0_20:1.8
	DWCDriver-0_19:1.8
	DWCDriver-0_18:1.8
	DWCDriver-0_17:1.8
	DWCDriver-0_16:1.7
	DWCDriver-0_15:1.6
	DWCDriver-0_14:1.5
	DWCDriver-0_13:1.5
	DWCDriver-0_12:1.5
	DWCDriver-0_11:1.5
	DWCDriver-0_10:1.4
	DWCDriver-0_09:1.4
	DWCDriver-0_08:1.3
	DWCDriver-0_07:1.2
	DWCDriver-0_06:1.2
	DWCDriver-0_05:1.2
	DWCDriver-0_04:1.2
	DWCDriver-0_03:1.2
	DWCDriver-0_02:1.2
	DWCDriver-0_01:1.1;
locks; strict;
comment	@# @;


1.15
date	2018.06.02.12.03.11;	author rool;	state Exp;
branches;
next	1.14;
commitid	aN4UymGTnkYCzHEA;

1.14
date	2017.09.19.20.28.40;	author rool;	state Exp;
branches;
next	1.13;
commitid	wjT6lLDJh1HeBQ7A;

1.13
date	2016.12.17.10.22.16;	author rool;	state Exp;
branches;
next	1.12;
commitid	cEIxPCqCTT2e7kyz;

1.12
date	2016.03.04.20.54.27;	author rool;	state Exp;
branches;
next	1.11;
commitid	MvG9A9da0K4NQmXy;

1.11
date	2016.03.04.01.33.39;	author jballance;	state Exp;
branches;
next	1.10;
commitid	WvfwatlEQwEQrgXy;

1.10
date	2015.11.15.10.05.58;	author rool;	state Exp;
branches;
next	1.9;
commitid	7p3alkDZr6jPOaJy;

1.9
date	2015.10.07.20.59.49;	author jlee;	state Exp;
branches;
next	1.8;
commitid	qck3WWYzKpNMGdEy;

1.8
date	2014.10.18.19.32.27;	author jlee;	state Exp;
branches;
next	1.7;
commitid	f21NzmxAoXunAIUx;

1.7
date	2014.07.08.22.17.35;	author jlee;	state Exp;
branches;
next	1.6;
commitid	Dy0m80d21vUhMCHx;

1.6
date	2014.06.19.21.31.02;	author jlee;	state Exp;
branches;
next	1.5;
commitid	Q5Tr8KszgORb8bFx;

1.5
date	2014.04.26.18.17.59;	author jlee;	state Exp;
branches;
next	1.4;
commitid	3PdzN60cJJ3zNdyx;

1.4
date	2012.09.17.16.32.53;	author jlee;	state Exp;
branches;
next	1.3;
commitid	DXVFy2WJjyak3Ukw;

1.3
date	2012.08.04.14.31.23;	author jlee;	state Exp;
branches;
next	1.2;
commitid	znlbEiHiIsNmNefw;

1.2
date	2012.06.06.23.46.48;	author jlee;	state Exp;
branches;
next	1.1;
commitid	BGSuwmc37QAuLH7w;

1.1
date	2012.06.03.15.12.53;	author jlee;	state Exp;
branches;
next	;
commitid	ZZ9X1FvMWAU11h7w;


desc
@@


1.15
log
@Enable split interrupt transactions
Detail:
  Reflects change made here
    https://github.com/raspberrypi/linux/commit/7956536a3d78ba0ef8ec990651b315664ed70f90
  after wider testing by the Linux community.
Admin:
  Submission from Colin Granville.

Version 0.35. Tagged as 'DWCDriver-0_35'
@
text
@/*
 * Copyright (c) 2012, RISC OS Open Ltd
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met: 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of RISC OS Open Ltd nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#include <stdarg.h>
#include <stdlib.h>
#include <stdbool.h>
#include "kernel.h"
#include "swis.h"
#include "cmodule.h"
#include "tboxlibint/messages.h"
#include "modhead.h"
#include "Global/HALEntries.h"
#include "Global/Services.h"
#include "callx/callx.h"

#include <sys/callout.h>
#include <sys/queue.h>

#include <machine/bus.h>
#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>

#include "dwc_os.h"
#include "dwc_otg_riscos.h"
#include "dwc_common_riscos.h"

#include "dwc/driver/dwc_otg_hcd_if.h"
#include "dwc/driver/dwc_otg_dbg.h"
#include "dwc/driver/dwc_otg_driver.h"
#include "dwc/driver/dwc_otg_regs.h"
#include "dwc/driver/dwc_otg_fiq_fsm.h"

/* CIL & HCD interface for RISC OS */

struct dwc_otg_driver_module_params {
	int32_t opt;
	int32_t otg_cap;
	int32_t dma_enable;
	int32_t dma_desc_enable;
	int32_t dma_burst_size;
	int32_t speed;
	int32_t host_support_fs_ls_low_power;
	int32_t host_ls_low_power_phy_clk;
	int32_t enable_dynamic_fifo;
	int32_t data_fifo_size;
	int32_t dev_rx_fifo_size;
	int32_t dev_nperio_tx_fifo_size;
	uint32_t dev_perio_tx_fifo_size[MAX_PERIO_FIFOS];
	int32_t host_rx_fifo_size;
	int32_t host_nperio_tx_fifo_size;
	int32_t host_perio_tx_fifo_size;
	int32_t max_transfer_size;
	int32_t max_packet_count;
	int32_t host_channels;
	int32_t dev_endpoints;
	int32_t phy_type;
	int32_t phy_utmi_width;
	int32_t phy_ulpi_ddr;
	int32_t phy_ulpi_ext_vbus;
	int32_t i2c_enable;
	int32_t ulpi_fs_ls;
	int32_t ts_dline;
	int32_t en_multiple_tx_fifo;
	uint32_t dev_tx_fifo_size[MAX_TX_FIFOS];
	uint32_t thr_ctl;
	uint32_t tx_thr_length;
	uint32_t rx_thr_length;
	int32_t pti_enable;
	int32_t mpi_enable;
	int32_t lpm_enable;
	int32_t ic_usb_cap;
	int32_t ahb_thr_ratio;
	int32_t power_down;
	int32_t reload_ctl;
	int32_t dev_out_nak;
	int32_t cont_on_bna;
	int32_t ahb_single;
	int32_t otg_ver;
	int32_t adp_enable;
};

static const bool use_fiq_fix = true; /* True if we're allowed to use the FIQ fix */
static const bool use_fiq_fsm = true; /* True if we're allowed to use the full FIQ FSM */
bool reclaim_fiq_vector = false; /* True if we should attempt to claim FIQs (i.e. driver is initialised and use_fiq_fix) */
bool own_fiq_vector = false; /* True if we currently own the FIQ vector */

static uint32_t fiq_stack[512];

/* Support for downgrading to IRQ when FIQ is claimed by someone else is incomplete */
//#define DOWNGRADE_TO_IRQ

#ifdef RISCOS_FIQ_DOWNGRADE
fiq_downgrade_t fiq_downgrade;
#endif

bool fiq_enable = false;
bool fiq_fsm_enable = false;
uint16_t nak_holdoff = 8;
unsigned short fiq_fsm_mask = 0x0F;


/*

			Misc

*/

static _kernel_oserror *softc_root_intr_ticker(_kernel_swi_regs *r,void *pw,void *handle)
{
	dwc_softc_t *sc = (dwc_softc_t *) handle;
	usbd_xfer_handle xfer = sc->sc_intrxfer;
	if(!xfer || !xfer->length)
		return NULL;
	if(dwc_otg_hcd_is_status_changed(sc->dwc_dev.hcd,sc->port) <= 0)
		return NULL;
	u_char *p = KERNADDR(&xfer->dmabuf, 0);
	memset(p,0,xfer->length);
	*p = 2;
	xfer->actlen = xfer->length;
	xfer->status = USBD_NORMAL_COMPLETION;
	usb_transfer_complete(xfer);
	return NULL;
}

/*

			Calls from USBDriver to us

*/

static usbd_status softc_allocm(struct usbd_bus *bus, usb_dma_t *dma, u_int32_t size);
static void softc_freem(struct usbd_bus *bus, usb_dma_t *dma);
static usbd_xfer_handle softc_allocx(struct usbd_bus *bus);
static void softc_freex(struct usbd_bus *bus, usbd_xfer_handle xfer);
static usbd_status softc_open(usbd_pipe_handle pipe);
static void softc_poll(struct usbd_bus *bus);
static void softc_softintr(void *v);
static void softc_noop(usbd_pipe_handle pipe);

static struct usbd_pipe_methods softc_root_ctrl_methods = {
	softc_root_ctrl_transfer,
	softc_root_ctrl_start,
	softc_root_ctrl_abort,
	softc_root_ctrl_close,
	softc_noop,
	softc_root_ctrl_done,
};

static struct usbd_pipe_methods softc_root_intr_methods = {
	softc_root_intr_transfer,
	softc_root_intr_start,
	softc_root_intr_abort,
	softc_root_intr_close,
	softc_noop,
	softc_root_intr_done,
};

static struct usbd_pipe_methods softc_device_methods = {
	softc_device_transfer,
	softc_device_start,
	softc_device_abort,
	softc_device_close,
	softc_device_clear_toggle,
	softc_device_done,
};

static struct usbd_bus_methods softc_bus_methods = {
	softc_open,
	softc_softintr,
	softc_poll,
	softc_allocm,
	softc_freem,
	softc_allocx,
	softc_freex,
	NULL, NULL, NULL, NULL, /* 4x unused HC overrides */
};

usbd_status softc_allocm(struct usbd_bus *bus, usb_dma_t *dma, u_int32_t size)
{
	usbd_status err;
	(void) bus;
	/* For IN transfers, dwc_otg_hc_start_transfer will round the request size up to a whole number of packets when it programs it into the controller.
	   This means we must also round up the buffer size, otherwise a device which sends a longer packet than expected will overflow the buffer
	   Unfortunately at this point we don't know the direction of the transfer or the max packet size of the device, so the best we can do is round all buffers to a multiple of 512 bytes */
	size = (size+511) & ~511;
	*dma = malloc_contig(size,0);
	if(*dma)
		err = USBD_NORMAL_COMPLETION;
	else
		err = USBD_NOMEM;
	return err;
}

void softc_freem(struct usbd_bus *bus, usb_dma_t *dma)
{
	(void) bus;
	free_contig((void **) dma);
	*dma = 0;
}

usbd_xfer_handle softc_allocx(struct usbd_bus *bus)
{
	struct dwc_softc *sc = (struct dwc_softc *)bus;
	usbd_xfer_handle xfer;

	xfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);
	if (xfer != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, next);
	} else {
		xfer = malloc(sizeof(struct dwc_softc_xfer));
	}
	if (xfer != NULL) {
		memset(xfer, 0, sizeof (struct dwc_softc_xfer));
	}
	return xfer;
}

void softc_freex(struct usbd_bus *bus, usbd_xfer_handle xfer)
{
	struct dwc_softc *sc = (struct dwc_softc *)bus;

	SIMPLEQ_INSERT_HEAD(&sc->sc_free_xfers, xfer, next);
}

usbd_status softc_open(usbd_pipe_handle pipe)
{
	usbd_device_handle dev = pipe->device;
	dwc_softc_t *sc = (dwc_softc_t *)dev->bus;
	usb_endpoint_descriptor_t *ed = pipe->endpoint->edesc;
	u_int8_t addr = dev->address;
	u_int8_t xfertype = ed->bmAttributes & UE_XFERTYPE;
	struct dwc_softc_pipe *epipe = (struct dwc_softc_pipe *)pipe;

	DPRINTFN(1, ("softc_open: pipe=%p addr=%d endpt=%d type=%d\n",epipe,addr,ed->bEndpointAddress,xfertype));

	epipe->dwc_priv = NULL;

	if(addr == sc->sc_addr) {
		switch(ed->bEndpointAddress) {
		case USB_CONTROL_ENDPOINT:
			epipe->pipe.methods = &softc_root_ctrl_methods;
			break;
		case UE_DIR_IN | DWC_SOFTC_INTR_ENDPT:
			epipe->pipe.methods = &softc_root_intr_methods;
			break;
		default:
			return USBD_INVAL;
		}
		return USBD_NORMAL_COMPLETION;
	}

	/* DWCTODO - ISOC needs extra stuff in softc_device_start for urb  setup */
	if(xfertype == UE_ISOCHRONOUS)
		return USBD_INVAL;

	epipe->pipe.methods = &softc_device_methods;

	/* Allocate URB */
	epipe->urb = dwc_otg_hcd_urb_alloc(sc->dwc_dev.hcd,0,0); /* DWCTODO - ISOC */
	if(!epipe->urb)
		return USBD_NOMEM;

	if(xfertype == UE_CONTROL)
	{
		/* Allocate DMA buffer for request packet */
		epipe->request = dwc_dma_alloc(NULL,sizeof(usb_device_request_t),&epipe->dma_req);
		if(!epipe->request)
		{
			dwc_free(NULL,epipe->urb);
			return USBD_NOMEM;
		}
	}
	else
	{
		/* Set urb pipe info
		   Note that control transfers do this on a per-xfer basis, as
		   direction and max packet size is changeable */
		dwc_otg_hcd_urb_set_pipeinfo(epipe->urb,dev->address,UE_GET_ADDR(ed->bEndpointAddress),xfertype,UE_GET_DIR(ed->bEndpointAddress),UE_GET_SIZE(UGETW(ed->wMaxPacketSize)));

		epipe->request = NULL;
		epipe->dma_req = 0;
	}

	epipe->xfer = NULL;

	return USBD_NORMAL_COMPLETION;
}

void softc_poll(struct usbd_bus *bus)
{
	/* We don't support polling for interrupts */
	(void) bus;
}

void softc_softintr(void *v)
{
	/* We don't use soft interrupts */
	(void) v;
}

void softc_noop(usbd_pipe_handle pipe)
{
	(void) pipe;
}

/*

			Calls from DWC to us

*/

static int hcd_op_start(dwc_otg_hcd_t *hcd)
{
	dprintf(("","hcd_op_start\n"));
	return 0;
}

static int hcd_op_disconnect(dwc_otg_hcd_t *hcd)
{
	dprintf(("","hcd_op_disconnect\n"));
	return 0;
}

static int hcd_op_hub_info(dwc_otg_hcd_t *hcd,void *urb_handle,uint32_t *hub_addr,uint32_t *port_addr)
{
	struct dwc_softc_xfer *ex = (struct dwc_softc_xfer *) urb_handle;
	struct dwc_softc_pipe *epipe = (struct dwc_softc_pipe *) ex->xfer.pipe;
	struct usbd_device *dev = epipe->pipe.device;
	struct usbd_port *hsport = dev->myhsport;
//	dprintf(("","hcd_op_hub_info xfer %08x\n",ex));
	if(hsport)
	{
		*hub_addr = hsport->parent->address;
		*port_addr = hsport->portno;
	}
	else
	{
		dprintf(("","!!! no hsport !!!\n"));
		*hub_addr = 0;
		*port_addr = 0;
	}
	return 0;
}

static int hcd_op_speed(dwc_otg_hcd_t *hcd,void *urb_handle)
{
	struct dwc_softc_xfer *ex = (struct dwc_softc_xfer *) urb_handle;
	struct dwc_softc_pipe *epipe = (struct dwc_softc_pipe *) ex->xfer.pipe;
	struct usbd_device *dev = epipe->pipe.device;
	dprintf(("","hcd_op_speed xfer %08x\n",ex));
	return dev->speed;
}

static int hcd_op_complete(dwc_otg_hcd_t *hcd,void *urb_handle,dwc_otg_hcd_urb_t *dwc_otg_urb,int32_t status)
{
	struct dwc_softc_xfer *ex = (struct dwc_softc_xfer *) urb_handle;
	struct dwc_softc_pipe *epipe = (struct dwc_softc_pipe *) ex->xfer.pipe;
	struct usbd_device *dev = epipe->pipe.device;
	dprintf(("","hcd_op_complete xfer %08x DWC status %d\n",ex,status));

	dwc_assert(epipe->xfer,"Pipe is idle!");
	dwc_assert(epipe->xfer == ex,"Wrong xfer!");

	/* Set xfer length, status */
	ex->xfer.actlen = dwc_otg_hcd_urb_get_actual_length(dwc_otg_urb);
	switch(status)
	{
	case -DWC_E_PROTOCOL:
		ex->xfer.status = USBD_IOERROR;
		break;
	case -DWC_E_IN_PROGRESS: /* DWCTODO - How can this happen? */
		ex->xfer.status = USBD_IN_PROGRESS;
		break;
	case -DWC_E_PIPE:
		ex->xfer.status = USBD_STALLED;
		break;
	case -DWC_E_IO:
		ex->xfer.status = USBD_IOERROR;
		break;
	case -DWC_E_TIMEOUT:
		ex->xfer.status = USBD_TIMEOUT;
		break;
	case -DWC_E_OVERFLOW:
		ex->xfer.status = USBD_IOERROR;
		break;
	case -DWC_E_SHUTDOWN:
		ex->xfer.status = USBD_CANCELLED;
		break;
	case 0:
		ex->xfer.status = USBD_NORMAL_COMPLETION;
		break;
	default:
		ex->xfer.status = USBD_IOERROR;
		break;
	}

	/* DWCTODO - Extra isoc stuff */

	/* Disable the endpoint after each control transfer

	   This seems to be necessary as the DWC driver caches the max packet
	   size in a dwc_hc_t struct associated with the endpoint. But the BSD
	   layer changes the max packet size that it uses without reopening the
	   pipe (when a device is first connected, a max packet size of 8 is
	   used until the real max size can be read from the device descriptor)

	   However, we can't disable the endpoint from within this callback, as
	   this transfer is still contained within its transfer list. So instead
	   we'll do it from within a callback, which should guarantee that the
	   transfer list is empty.
	   */
	if(epipe->request)
	{
		register_endpoint_disable_cb(epipe->dwc_priv);
		epipe->dwc_priv = 0;
	}

	/* Mark pipe as idle */
	epipe->xfer = NULL;

	int s = splusb();

	/* Cancel any timeout */
	callout_stop(&(ex->xfer.timeout_handle));
	/* And cancel the associated callback */
	riscos_cancel_abort_pipe(&ex->xfer);

	/* Tell USBDriver */
	usb_transfer_complete(&ex->xfer);

	splx(s);

	return 0;
}

static int hcd_op_get_b_hnp_enable(dwc_otg_hcd_t *hcd)
{
	dprintf(("","hcd_op_get_b_hnp_enable\n"));
	/* No HNP for us */
	return 0;
}

static struct dwc_otg_hcd_function_ops hcd_ops = {
	hcd_op_start,
	hcd_op_disconnect,
	hcd_op_hub_info,
	hcd_op_speed,
	hcd_op_complete,
	hcd_op_get_b_hnp_enable,
};

/*

			Initialisation

*/

static bool veneers_built = false;
static struct {
    struct usbd_bus_methods methods;
    struct {
        int load;
        int branch;
    } veneer[sizeof (struct usbd_bus_methods) / sizeof (void*)];
} softc_bus_methods_entry;

static struct {
    struct usbd_pipe_methods methods;
    struct {
        int load;
        int branch;
    } veneer[sizeof (struct usbd_pipe_methods) / sizeof (void*)];
} softc_root_ctrl_methods_entry,
  softc_root_intr_methods_entry,
  softc_device_methods_entry;

_kernel_oserror *dwc_otg_riscos_init(const uint32_t *hw_base,const uint8_t *mphi_base,int usb_device_number,int mphi_device_number,dwc_softc_t *softc)
{
	/* Initialise veneers */
#ifdef __riscos
	if (!veneers_built)
	{
		build_veneer((int*)&softc_bus_methods_entry, (int*)&softc_bus_methods, sizeof(softc_bus_methods));
		build_veneer((int*)&softc_root_ctrl_methods_entry, (int*)&softc_root_ctrl_methods, sizeof(softc_root_ctrl_methods));
		build_veneer((int*)&softc_root_intr_methods_entry, (int*)&softc_root_intr_methods, sizeof(softc_root_intr_methods));
		build_veneer((int*)&softc_device_methods_entry, (int*)&softc_device_methods, sizeof(softc_device_methods));
		veneers_built = true;
	}
#endif

	/* Set up softc members */
	memset(softc,0,sizeof(dwc_softc_t));
	softc->sc_bus.usbrev = USBREV_2_0;
	softc->sc_bus.methods = &softc_bus_methods;
	softc->sc_bus.pipe_size = sizeof(struct dwc_softc_pipe);

	softc->usb_device_number = softc->device_number = usb_device_number;
	softc->mphi_device_number = mphi_device_number;
	SIMPLEQ_INIT(&softc->sc_free_xfers);

#ifndef FALLBACK_TO_IRQ
	/* FIQ FSM enable flags must be set to correct values prior to init */
	fiq_enable = use_fiq_fix;
	fiq_fsm_enable = use_fiq_fsm;
#endif

	/* Initialise the common interface layer */
	dprintf(("","dwc_otg_cil_init\n"));
	softc->dwc_dev.core_if = dwc_otg_cil_init(hw_base);

	/* DWCTODO - params should come from HAL */
	struct dwc_otg_driver_module_params s_params;
	memset(&s_params,-1,sizeof(s_params));
	s_params.lpm_enable = 0; /* From dwc_otg_driver.c */
	struct dwc_otg_driver_module_params *params = &s_params;


	int ret = 0;

	/* Set device parameters */
	dprintf(("","Setting device parameters\n"));
#define SETPARAM(X) \
	if(params->X != -1) \
		ret += dwc_otg_set_param_ ## X(softc->dwc_dev.core_if,params->X);
	SETPARAM(otg_cap)
	SETPARAM(dma_enable)
	SETPARAM(dma_desc_enable)
	SETPARAM(opt)
	SETPARAM(dma_burst_size)
	SETPARAM(host_support_fs_ls_low_power)
	SETPARAM(enable_dynamic_fifo)
	SETPARAM(data_fifo_size)
	SETPARAM(dev_rx_fifo_size)
	SETPARAM(dev_nperio_tx_fifo_size)
	SETPARAM(host_rx_fifo_size)
	SETPARAM(host_nperio_tx_fifo_size)
	SETPARAM(host_perio_tx_fifo_size)
	SETPARAM(max_transfer_size)
	SETPARAM(max_packet_count)
	SETPARAM(host_channels)
	SETPARAM(dev_endpoints)
	SETPARAM(phy_type)
	SETPARAM(speed)
	SETPARAM(host_ls_low_power_phy_clk)
	SETPARAM(phy_ulpi_ddr)
	SETPARAM(phy_ulpi_ext_vbus)
	SETPARAM(phy_utmi_width)
	SETPARAM(ulpi_fs_ls)
	SETPARAM(ts_dline)
	SETPARAM(i2c_enable)
	SETPARAM(en_multiple_tx_fifo)
	for(int i=0;i<15;i++)
	{
		if(params->dev_perio_tx_fifo_size[i] != -1)
			ret += dwc_otg_set_param_dev_perio_tx_fifo_size(softc->dwc_dev.core_if,params->dev_perio_tx_fifo_size[i],i);
		if(params->dev_tx_fifo_size[i] != -1)
			ret += dwc_otg_set_param_dev_tx_fifo_size(softc->dwc_dev.core_if,params->dev_tx_fifo_size[i],i);
	}
	SETPARAM(thr_ctl)
	SETPARAM(mpi_enable)
	SETPARAM(pti_enable)
	SETPARAM(lpm_enable)
	SETPARAM(ic_usb_cap)
	SETPARAM(tx_thr_length)
	SETPARAM(rx_thr_length)
	SETPARAM(ahb_thr_ratio)
	SETPARAM(power_down)
	SETPARAM(reload_ctl)
	SETPARAM(dev_out_nak)
	SETPARAM(cont_on_bna)
	SETPARAM(ahb_single)
	SETPARAM(otg_ver)
	SETPARAM(adp_enable)

	if(ret)
	{
		dwc_otg_cil_remove(softc->dwc_dev.core_if);
		return make_error(ErrorNumber_DWC_BadDevParms, 0);
	}

	/* Disable global interrupts */
	dprintf(("","Setting up IRQs\n"));
	dwc_otg_disable_global_interrupts(softc->dwc_dev.core_if);

	/* Claim IRQ */
#ifndef FALLBACK_TO_IRQ
	if (use_fiq_fix)
	{
		_swix (OS_ClaimDeviceVector, _INR(0,4), softc->mphi_device_number, usb_irq_entry, private_word, 0, 0);
		softc->device_number = softc->mphi_device_number;
	}
	else
#endif
	{
		_swix (OS_ClaimDeviceVector, _INR(0,4), softc->usb_device_number, usb_irq_entry, private_word, 0, 0);
		_swix (OS_Hardware, _IN(0) | _INR(8,9), softc->usb_device_number, 0, EntryNo_HAL_IRQEnable);
	}

	/* Initialise CIL */
	dprintf(("","dwc_otg_core_init\n"));
	dwc_otg_core_init(softc->dwc_dev.core_if);

	/* Create HCD instance */
	dprintf(("","dwc_otg_hcd_alloc_hcd\n"));
	softc->dwc_dev.hcd = dwc_otg_hcd_alloc_hcd();

	/* Initialise */
	dprintf(("","dwc_otg_hcd_init\n"));
	ret = dwc_otg_hcd_init(softc->dwc_dev.hcd, softc->dwc_dev.core_if);
	if(ret)
	{
		/* DWCTODO - Tidy up properly */
		return make_error(ErrorNumber_DWC_FailInitHCD, 0);
	}

	/* Get port number */
	softc->port = dwc_otg_hcd_otg_port(softc->dwc_dev.hcd);

	/* Set up variables needed by the FIQ code */
	dprintf(("","Registers at %08x %08x\n",hw_base,mphi_base));
	if (use_fiq_fix)
	{
		softc->dwc_dev.hcd->fiq_state->mphi_regs.base    = (volatile void *) (mphi_base);
		softc->dwc_dev.hcd->fiq_state->mphi_regs.ctrl    = (volatile void *) (mphi_base + 0x4c);
		softc->dwc_dev.hcd->fiq_state->mphi_regs.outdda  = (volatile void *) (mphi_base + 0x28);
		softc->dwc_dev.hcd->fiq_state->mphi_regs.outddb  = (volatile void *) (mphi_base + 0x2c);
		softc->dwc_dev.hcd->fiq_state->mphi_regs.intstat = (volatile void *) (mphi_base + 0x50);
		softc->dwc_dev.hcd->fiq_state->dwc_regs_base = (uint8_t *) hw_base;
	
		/* Enable MPHI peripheral */
		DWC_WRITE_REG32(softc->dwc_dev.hcd->fiq_state->mphi_regs.ctrl,0x80000000);

#ifdef RISCOS_FIQ_DOWNGRADE
		fiq_downgrade.fiq_downgrade_device = mphi_device_number;

		/* Get the MPHI generating an interrupt now */
		FIQ_WRITE( softc->dwc_dev.hcd->fiq_state->mphi_regs.outdda, (int) softc->dwc_dev.hcd->fiq_state->dummy_send);
		FIQ_WRITE( softc->dwc_dev.hcd->fiq_state->mphi_regs.outddb, (1 << 29));

		_swix(OS_Hardware,_INR(8,9)|_OUTR(0,1),1,EntryNo_HAL_IRQEnable,&fiq_downgrade.hal_irqenable,&fiq_downgrade.hal_sb);
		_swix(OS_Hardware,_INR(8,9)|_OUT(0),1,EntryNo_HAL_IRQDisable,&fiq_downgrade.hal_irqdisable);
#endif
	}

	/* Enable IRQs */
	dprintf(("","dwc_otg_enable_global_interrupts\n"));
	dwc_otg_enable_global_interrupts(softc->dwc_dev.core_if);

	/* Start HCD */
	dprintf(("","dwc_otg_hcd_start\n"));
	softc->hcd_on = true;
	ret = dwc_otg_hcd_start(softc->dwc_dev.hcd, &hcd_ops);
	if(ret)
	{
		/* DWCTODO - Tidy up properly */
		return make_error(ErrorNumber_DWC_FailStartHCD, 0);
	}

	if (use_fiq_fix)
	{
		/* Try using FIQs - must occur after hcd_start to avoid issues with FIQ FSM generating HCD IRQs before hcd_intr is able to deal with them */
		dwc_otg_riscos_try_use_fiqs(softc,true);
	}

	/* We don't get any notification from the DWC layer when the root hub status changes. For now, just use a ticker event that will poll the driver at regular intervals. */
	callx_add_callevery(10,softc_root_intr_ticker,softc);

	dprintf(("","done!\n"));

	return NULL;
}

void dwc_otg_riscos_shutdown(dwc_softc_t *softc)
{
	if(softc->hcd_on)
	{
		callx_remove_callevery(softc_root_intr_ticker,softc);

		dwc_otg_hcd_stop(softc->dwc_dev.hcd);
		softc->hcd_on = false;
	}

	if(softc->dwc_dev.hcd)
	{
		dwc_otg_hcd_remove(softc->dwc_dev.hcd);
		softc->dwc_dev.hcd = NULL;
	}

	/* Release FIQ */
	if(own_fiq_vector)
	{
		/* Prevent automatically reclaiming the vector when we try to release it */
		reclaim_fiq_vector = false;
		dwc_otg_riscos_release_fiq(softc);
		_swix(OS_ServiceCall,_IN(1),Service_ReleaseFIQ);
	}

	/* Release IRQ */
	_swix (OS_ReleaseDeviceVector, _INR(0,4), softc->device_number, usb_irq_entry, private_word, 0, 0);

	if(softc->dwc_dev.core_if)
	{
		dwc_otg_cil_remove(softc->dwc_dev.core_if);
		softc->dwc_dev.core_if = NULL;
	}

	/* Free remaining memory */
	usbd_xfer_handle xfer;
	while((xfer = SIMPLEQ_FIRST(&softc->sc_free_xfers)) != NULL)
	{
		SIMPLEQ_REMOVE_HEAD(&softc->sc_free_xfers, next);
		free(xfer);
	}
}

int dwc_otg_riscos_irq(dwc_softc_t *softc)
{
	/* Return 0 for success, 1 for failure */
	int ret = 0;

	if(softc->hcd_on)
	{
		/* Check HCD interrupt first, likely to be more common */
		ret = dwc_otg_hcd_handle_intr(softc->dwc_dev.hcd);
	}

	/* Check CIL */
	ret |= dwc_otg_handle_common_intr(&softc->dwc_dev);
	if(ret)
	{
		return 0;
	}

	/* Unhandled (spurious?) IRQs may happen every so often when using the FIQ fix. Try not to worry about it! */
	return (use_fiq_fix?0:1);
}

extern void install_fiq(uint32_t *stack,uint32_t stacksize,void *param1,int param2,void *func);

void dwc_otg_riscos_try_use_fiqs(dwc_softc_t *softc, bool need_to_claim)
{
	if(!use_fiq_fix)
	{
		reclaim_fiq_vector = false;
		return;
	}

	dprintf(("","Claiming FIQ vector\n"));

	if(need_to_claim)
	{
		/* Claim FIQs (from foreground, guaranteed to succeed) */
		_swix(OS_ServiceCall,_IN(1),Service_ClaimFIQ);
	}

	/* Ensure any previous interrupts are disabled */
	_swix (OS_Hardware, _INR(8,9), 0, EntryNo_HAL_FIQDisableAll);

	/* Install FIQ handler */
	install_fiq(fiq_stack,sizeof(fiq_stack),softc->dwc_dev.hcd->fiq_state,softc->dwc_dev.core_if->core_params->host_channels,(use_fiq_fsm?(void *)dwc_otg_fiq_fsm:(void *)dwc_otg_fiq_nop));

	/* Disable IRQs+FIQs while we switch state */
	int flags;
	local_irq_save(flags);
	local_fiq_disable();

#ifdef FALLBACK_TO_IRQ
	/* Switch the IRQ handler from USB to MPHI */
	_swix (OS_ReleaseDeviceVector, _INR(0,4), softc->usb_device_number, usb_irq_entry, private_word, 0, 0);
	_swix (OS_ClaimDeviceVector, _INR(0,4), softc->mphi_device_number, usb_irq_entry, private_word, 0, 0);
	softc->device_number = softc->mphi_device_number;
#endif

#if defined(RISCOS_FIQ_DOWNGRADE)
	/* Ensure the FIQ routine will enable the interrupt */
	fiq_downgrade.irq_masked = false;
	fiq_downgrade.fiq_trigger = false;
#else
	/* Enable MPHI IRQ */
	_swix (OS_Hardware, _IN(0) | _INR(8,9), softc->mphi_device_number, 0, EntryNo_HAL_IRQEnable);
#endif

	/* Enable FIQ interrupt from USB */
	_swix (OS_Hardware, _IN(0) | _INR(8,9), softc->usb_device_number, 0, EntryNo_HAL_FIQEnable);

	/* Flag to DWC that the FIQ code is enabled */
	fiq_enable = use_fiq_fix;

	/* Also enable the fiq FSM */
	fiq_fsm_enable = use_fiq_fsm;

	/* Flag that we own the vector, and should reclaim it if we lose it */
	own_fiq_vector = reclaim_fiq_vector = true;

	local_irq_restore(flags);
}

void dwc_otg_riscos_release_fiq(dwc_softc_t *softc)
{
	dprintf(("","Releasing FIQ vector\n"));

	int flags;

#ifdef FALLBACK_TO_IRQ
	TODO: Shutdown FIQ FSM
#endif

	/* Release our claim on the FIQ vector */
	local_irq_save(flags);
	local_fiq_disable();

	/* Disable the interrupt */
	_swix (OS_Hardware, _INR(8,9), 0, EntryNo_HAL_FIQDisableAll);

	/* Flag that we no longer own the vector */
	own_fiq_vector = false;

#ifdef FALLBACK_TO_IRQ
	/* Switch the IRQ handler from MPHI to USB */
	_swix (OS_ReleaseDeviceVector, _INR(0,4), softc->mphi_device_number, usb_irq_entry, private_word, 0, 0);
	_swix (OS_ClaimDeviceVector, _INR(0,4), softc->usb_device_number, usb_irq_entry, private_word, 0, 0);
	softc->device_number = softc->usb_device_number;

	/* Enable USB IRQ */
	_swix (OS_Hardware, _IN(0) | _INR(8,9), softc->usb_device_number, 0, EntryNo_HAL_IRQEnable);
#endif

	local_irq_restore(flags);
}
@


1.14
log
@Remove some part finished HAL support
Detail:
  A few sections of code guarded by USBHAL defines carried over from MUSBDriver, but were never finished due to the complexity of DWCDriver.
  These are no longer needed now the kernel scans for keys, so remove them.
Admin:
  Couple of warnings in cmodule.c also attended to.
  Submission for USB bounty.

Version 0.32. Tagged as 'DWCDriver-0_32'
@
text
@d124 1
a124 1
unsigned short fiq_fsm_mask = 0x07;
@


1.13
log
@Internationalised
Detail:
  Add support for standalone messages registration, and actually use the messages rather than just exporting them in ROM builds.
  Changed to use allocated error bases rather than 0.
  Sync controller hunting loop with other HC for ease of comparison.
Admin:
  Submission for USB bounty.
  Tested on a Pi 2.

Version 0.29. Tagged as 'DWCDriver-0_29'
@
text
@d505 1
a505 1
#if defined (__riscos) && !defined(USBHAL)
@


1.12
log
@Revert accidental commits
Admin:
  These changes are currently subject to rework via the normal submissions channel.
@
text
@d34 1
d603 1
a603 1
		return (_kernel_oserror *) "\0\0\0\0Incorrect device parameters";
d638 1
a638 1
		return (_kernel_oserror *) "\0\0\0\0Failed to init HCD";
d681 1
a681 1
		return (_kernel_oserror *) "\0\0\0\0Failed to start HCD";
@


1.11
log
@ Fixes to get isochronous transfer in DWCDriver (Raspberry Pi)`
Detail:

Changes to the RISC OS part of the DWCDriver (Raspberry Pi) necessary to get isochronous transfers working on a pi.

DWCDriver.c.cmodule
DWCDriver.c.dwc_otg_riscos
DWCDriver.c.softc_device
DWCDriver.h.dwc_otg_riscos

Admin:
submitted by Colin Granville
tested on pi

Version 0.25. Tagged as 'DWCDriver-0_25'
@
text
@a245 3
	struct dwc_softc_xfer* ex = (struct dwc_softc_xfer*) xfer;
	DWC_FREE(ex->urb);

d276 4
d281 9
a289 2
        
	if(xfertype == UE_CONTROL) {
d291 13
a303 2
		if(!epipe->request) return USBD_NOMEM;
	} else {
d308 2
d385 3
d421 1
a421 10
	int i;
	/* For non isochronous transfers xfer.nframes = 0 */
	if (ex->xfer.nframes > 0) {
		int actlen = 0;
		for (i = 0; i < ex->xfer.nframes; i++) {
			ex->xfer.frlengths[i] = dwc_otg_hcd_urb_get_iso_desc_actual_length(ex->urb,i);
			actlen += ex->xfer.frlengths[i];
		}
		ex->xfer.actlen = actlen;
	}
d442 3
@


1.10
log
@Init structures for DWCDriver unused members
Detail:
  Play safe, put NULLs in for the unused HC overrides


Version 0.22. Tagged as 'DWCDriver-0_22'
@
text
@d246 3
a278 4
	/* DWCTODO - ISOC needs extra stuff in softc_device_start for urb  setup */
	if(xfertype == UE_ISOCHRONOUS)
		return USBD_INVAL;

d280 2
a281 9

	/* Allocate URB */
	epipe->urb = dwc_otg_hcd_urb_alloc(sc->dwc_dev.hcd,0,0); /* DWCTODO - ISOC */
	if(!epipe->urb)
		return USBD_NOMEM;

	if(xfertype == UE_CONTROL)
	{
		/* Allocate DMA buffer for request packet */
d283 2
a284 13
		if(!epipe->request)
		{
			dwc_free(NULL,epipe->urb);
			return USBD_NOMEM;
		}
	}
	else
	{
		/* Set urb pipe info
		   Note that control transfers do this on a per-xfer basis, as
		   direction and max packet size is changeable */
		dwc_otg_hcd_urb_set_pipeinfo(epipe->urb,dev->address,UE_GET_ADDR(ed->bEndpointAddress),xfertype,UE_GET_DIR(ed->bEndpointAddress),UE_GET_SIZE(UGETW(ed->wMaxPacketSize)));

a288 2
	epipe->xfer = NULL;

a363 3
	dwc_assert(epipe->xfer,"Pipe is idle!");
	dwc_assert(epipe->xfer == ex,"Wrong xfer!");

d397 10
a406 1
	/* DWCTODO - Extra isoc stuff */
a426 3
	/* Mark pipe as idle */
	epipe->xfer = NULL;

@


1.9
log
@Update to 'FIQ FSM' USB driver
Detail:
  Makefile, dwc/* - Updated to latest-ish code from Raspberry Pi github (rev c8baa9702c). Includes the 'FIQ FSM' USB driver, which replaces the older 'FIQ fix'. Note that many files appear to have no functional changes - just trailing whitespace removal to keep things in sync with github.
  Makefile - add DEBUGLIBS back into the debug libs listing to fix debug builds
  c/cmodule - Update to work with new FIQ FSM flags
  c/dwc_otg_riscos - Update to work with new FIQ FSM flags. Update initialisation procedure. Change IRQ handling to try both the HCD & CIL interrupt handlers (HCD can claim interrupt is handled when there's still a CIL interrupt pending). Disable support for falling back to IRQ if the FIQ vector is claimed by someone else - will need new implementation to cope with starting & stopping the FIQ FSM.
  s/regaccess - Update FIQ veneer & install routine to allow operation with either the dwc_otg_fiq_fsm or dwc_otg_fiq_nop functions.
Admin:
  Tested on Raspberry Pi 1 & 2


Version 0.21. Tagged as 'DWCDriver-0_21'
@
text
@d199 1
@


1.8
log
@Fix memory corruption caused by longer than expected IN packets
Detail:
  c/dwc_otg_riscos - Round all IO buffers out to a multiple of 512 bytes. This is a workaround for the way dwc_otg_hc_start_transfer rounds IN transfer request sizes up to a multiple of the max packet size (due to hardware limitations?). Without this workaround, we can easily get memory corruption if a device sends a short packet which is longer than we're expecting.
Admin:
  Tested on Raspberry Pi
  Believed to fix crashes seen when using some keyboards/mice:
  https://www.riscosopen.org/forum/forums/4/topics/2383?page=3#posts-33881


Version 0.17. Tagged as 'DWCDriver-0_17'
@
text
@d55 1
a55 1
#include "dwc/driver/dwc_otg_mphi_fix.h"
d107 1
a107 1
static const bool use_fiq_split_fix = true; /* True if we're allowed to use the FIQ split xfer fix */
d111 1
a111 5
extern bool fiq_fix_enable,fiq_split_enable,fiq_split_schedule_enable;
extern volatile uint8_t *dwc_regs_base;
extern mphi_regs_t c_mphi_regs;
extern void *dummy_send;
extern int complete_sched[MAX_EPS_CHANNELS];
d113 2
a114 1
static uint32_t fiq_stack[512];
d120 6
d524 6
a603 24
	/* Set up variables needed by the FIQ code */
	dprintf(("","Registers at %08x %08x\n",hw_base,mphi_base));
	dwc_regs_base = (volatile uint8_t *) hw_base;
	c_mphi_regs.base    = (volatile void *) (mphi_base);
	c_mphi_regs.ctrl    = (volatile void *) (mphi_base + 0x4c);
	c_mphi_regs.outdda  = (volatile void *) (mphi_base + 0x28);
	c_mphi_regs.outddb  = (volatile void *) (mphi_base + 0x2c);
	c_mphi_regs.intstat = (volatile void *) (mphi_base + 0x50);
	dummy_send = malloc(16);

	/* Enable MPHI peripheral */
	DWC_WRITE_REG32(c_mphi_regs.ctrl,0x80000000);

#ifdef RISCOS_FIQ_DOWNGRADE
	fiq_downgrade.fiq_downgrade_device = mphi_device_number;

	/* Get the MPHI generating an interrupt now */
	FIQ_WRITE( c_mphi_regs.outdda, (int) dummy_send);
	FIQ_WRITE( c_mphi_regs.outddb, (1 << 29));

	_swix(OS_Hardware,_INR(8,9)|_OUTR(0,1),1,EntryNo_HAL_IRQEnable,&fiq_downgrade.hal_irqenable,&fiq_downgrade.hal_sb);
	_swix(OS_Hardware,_INR(8,9)|_OUT(0),1,EntryNo_HAL_IRQDisable,&fiq_downgrade.hal_irqdisable);
#endif

d609 12
a620 5
	_swix (OS_ClaimDeviceVector, _INR(0,4), softc->usb_device_number, usb_irq_entry, private_word, 0, 0);
	_swix (OS_Hardware, _IN(0) | _INR(8,9), softc->usb_device_number, 0, EntryNo_HAL_IRQEnable);

	/* Try using FIQs */
	dwc_otg_riscos_try_use_fiqs(softc,true);
d642 26
d682 6
a711 6
	if(softc->dwc_dev.core_if)
	{
		dwc_otg_cil_remove(softc->dwc_dev.core_if);
		softc->dwc_dev.core_if = NULL;
	}

d720 5
a724 1
	if(dummy_send)
d726 2
a727 2
		free(dummy_send);
		dummy_send = NULL;
a729 3
	/* Release IRQ */
	_swix (OS_ReleaseDeviceVector, _INR(0,4), softc->usb_device_number, usb_irq_entry, private_word, 0, 0);

d742 1
a742 1
	int ret;
a747 2
		if(ret)
			return 0;
d751 1
a751 1
	ret = dwc_otg_handle_common_intr(&softc->dwc_dev);
d753 1
d755 1
d761 1
a761 1
extern void install_fiq(uint32_t *stack,uint32_t stacksize);
d783 1
a783 1
	install_fiq(fiq_stack,sizeof(fiq_stack));
d790 1
d795 1
d810 1
a810 1
	fiq_fix_enable = use_fiq_fix;
d812 2
a813 2
	/* Also enable the split xfer fix */
	fiq_split_enable = fiq_split_schedule_enable = use_fiq_split_fix;
d827 3
a829 14
	/* If the split FIQ fix is enabled then we must do a staged release to
	   allow it to gracefully terminate its state machine */
	if(fiq_split_enable)
	{
		/* Prevent new split xfers from being scheduled for completion by the FIQ handler. The IRQ handler will handle them instead. */
		fiq_split_schedule_enable = false;
		/* Wait for existing xfers to leave the FIQ schedule */
		for(int i=0;i<MAX_EPS_CHANNELS;i++)
			while(complete_sched[i] != -1)
			{
				dprintf(("","Waiting for complete_sched[%d]...\n",i));
			}
		dprintf(("","complete_sched is clear\n"));
	}
a837 3
	/* Flag to DWC that the FIQ code is no longer active */
	fiq_fix_enable = fiq_split_enable = false;

d841 1
d849 1
@


1.7
log
@Enable part two of the FIQ fix
Detail:
  This enables support for the code which handles split transactions in the FIQ handler. This requires some extra logic to allow the FIQ handler to gracefully terminate its state machine when we need to release our hold on the FIQ vector.
  c/dwc_otg_riscos - Update FIQ claim/release functions to initialise and terminate fiq_split_enable. Make FIQ usage bools static const as nothing needs to change them at runtime.
  h/dwc_otg_riscos - Remove unused use_fiq_fix extern
  dwc/driver/c/dwc_otg_hcd_intr - Modify fiq_hcintr_handle() to allow for graceful termination - when terminating, suppress adding new xfers to the schedule and instead force the IRQ handler to deal with them
Admin:
  Tested on Raspberry Pi
  Thrashing Service_ClaimFIQ/Service_ReleaseFIQ didn't result in any obvious problems while split xfers were occuring


Version 0.16. Tagged as 'DWCDriver-0_16'
@
text
@d202 4
@


1.6
log
@Enable part one of the FIQ fix
Detail:
  This change enables the basic 'FIQ fix', where SOF interrupts are handled by a FIQ handler and all other interrupts are delegated to IRQ.
  During testing it was observed that when the FIQ fix was enabled, what appears to be the host-side VCHIQ process would randomly die. It could take anywhere from several seconds (including during ROM init) or several hours for this to happen.
  After much investigation it looks like the cause was the use of the MPHI peripheral as a mechanism to trigger an IRQ from the FIQ handler. Changing the code in dwc_otg_hcd_handle_intr() so that it 'flushes' MPHI more often (after every interrupt instead of after every 60) seemed to reduce the problem, while changing the IRQ generation mechanism to use a different IRQ source (e.g. timer) made the crash go away entirely
  In the end I've settled on the compromise of using the MPHI peripheral, but in a way in which we only need to poke it once on startup, instead of once for every desired IRQ. Once we have it generating an IRQ we then rely on masking/unmasking the IRQ in the interrupt controller to get the desired effect of downgrading FIQs to IRQs. See the RISCOS_FIQ_DOWNGRADE #define.
  Changed files:
  - c/cmodule - Use symbolic constant for the USB controller ID instead of a magic number. Get the MPHI details from HAL_USBControllerInfo. Pay attention to Service_ClaimFIQ/Service_ReleaseFIQ and enable/disable the FIQ fix as appropriate.
  - c/dwc_common_riscos - Disable some debug functions which were accidentally left in non-debug builds. Change work queue/tasklet thread initialisation to fix a deadlock issue seen on reboot.
  - c/dwc_otg_riscos - Set up the MPHI and enable/disable the FIQ handler as required
  - cmhg/modhead - Pay attention to Service_ClaimFIQ/Service_ReleaseFIQ
  - dwc/driver/c/dwc_otg_hcd_intr, dwc/driver/h/dwc_otg_mphi_fix - RISCOS_FIQ_DOWNGRADE code
  - dwc/dwc_common_port/h/dwc_os - Make sure __DWC_WARN, __DWC_ERROR, DWC_EXCEPTION are compiled out in non-debug builds
  - h/dwc_otg_riscos - declare extra functions/variables related to FIQ fix
  - s/regaccess - Routine to install the FIQ handler on the FIQ vector, and simple HAL call wrapper
Admin:
  Tested on Raspberry Pi
  Requires Kernel-5_35-4_79_2_227, BCM2835-0_34


Version 0.15. Tagged as 'DWCDriver-0_15'
@
text
@d106 2
a107 1
bool use_fiq_fix = true; /* True if we're allowed to use the FIQ fix */
d111 1
a111 1
extern bool fiq_fix_enable;
d115 1
d787 3
d800 17
a817 1
	int flags;
d825 1
a825 1
	fiq_fix_enable = false;
@


1.5
log
@Update to latest code from Raspberry Pi github
Detail:
  Makefile, dwc/* - Updated to latest code from Raspberry Pi github (rev e0001dd59d). Includes the fabled 'FIQ fix' code, although the code isn't yet enabled in the RISC OS version of the driver.
  c/cmodule - Add extra flags for controlling driver behaviour, as required by the new core code
  c/dwc_otg_riscos - Add some missing driver parameters (although we leave them at default). Handle DWC_E_SHUTDOWN xfer errors, which will now be produced when the driver is shutting down
  c/softc_device - Disable interrupts around dwc_otg_hcd_urb_enqueue, to mirror behaviour of Linux code (previously, it was the responsibility of the DWC code to disable interrupts for the appropriate part of the operation)
  s/regaccess - Add some extra IRQ/memory barrier functions required by the new code (mainly the FIQ fix). Make DWC_MODIFY_REG32 operate atomicly (mirrors change in Linux version)
Admin:
  Tested on Raspberry Pi


Version 0.11. Tagged as 'DWCDriver-0_11'
@
text
@d36 1
d54 2
d106 15
d491 1
a491 1
_kernel_oserror *dwc_otg_riscos_init(const uint32_t *hw_base,int device_number,dwc_softc_t *softc)
d511 2
a512 1
	softc->device_number = device_number;
d589 24
d618 5
a622 2
	_swix (OS_ClaimDeviceVector, _INR(0,4), softc->device_number, usb_irq_entry, private_word, 0, 0);
	_swix (OS_Hardware, _IN(0) | _INR(8,9), softc->device_number, 0, EntryNo_HAL_IRQEnable);
d688 16
a703 2
	/* Relase IRQ */
	_swix (OS_ReleaseDeviceVector, _INR(0,4), softc->device_number, usb_irq_entry, private_word, 0, 0);
d732 86
a817 1
	return 1;
@


1.4
log
@Update to version 3.00 of DWC_otg
Detail:
  This big batch of changes brings us in line with rev 70428950df of the Raspberry Pi Linux github.
  Briefly:
  * Deleted HTML docs as they're a waste of space
  * Dropped the SOF fix (which we never used anyway)
  * Dropped our implementation of the microframe scheduling patch, in favour of their implementation
  * Updated to version 3.00 of the DWC sources. Hard to tell what useful changes this brings, due to API tweaks resulting in pretty much every file being littered with changes.
Admin:
  Tested on Raspberry Pi with high processor vectors
  This new version seems like it might be a bit more sensitive to insufficient power supplies. Beware!


Version 0.09. Tagged as 'DWCDriver-0_09'
@
text
@d94 7
d382 3
d503 1
a503 1
	s_params.lpm_enable = 0; /* Specified via kernel boot args in R-Pi linux */
d556 7
@


1.3
log
@Fix aborts on reset/*rmkill USBDriver
Detail:
  c/cmodule, cmhg/modhead - Don't shutdown DWC layer during Service_USBDriver_Dying. Instead, only do it during Service_ModulePostFinal/Service_PreReset(/module finialisation). Also during Service_PreReset, deregister with USBDriver. This ensures we're deregistered with USBDriver before we shut down the DWC layer, and so don't have to worry about receiving events from USBDriver after the DWC layer is shut down.
  c/dwc_common_riscos, c/dwc_otg_riscos, h/dwc_common_riscos - Improve handling of DWC endpoint disable callbacks. The memory block for the endpoint now has a flag set in its header when a callback is pending, allowing us to avoid double-free situations if both ourselves and the DWC layer decide to free the endpoint.
  c/softc_root - Correct some debug messages
  dwc/driver/c/dwc_otg_hcd - Fix qh_list_free to use DWC_LIST_FOREACH_SAFE (as dwc_otg_hcd_qh_remove_and_free will remove entries from the list) - fixes potential double-free if a non-empty list is being freed
  dwc/driver/c/dwc_otg_hcd_intr - Fix building of debug builds
Admin:
  Tested in Pi ROM with high processor vectors
  Resets and killing/reiniting USBDriver now works properly


Version 0.08. Tagged as 'DWCDriver-0_08'
@
text
@d108 1
a108 1
	if(dwc_otg_hcd_is_status_changed(sc->hcd,sc->port) <= 0)
d248 1
a248 1
	epipe->urb = dwc_otg_hcd_urb_alloc(sc->hcd,0,0); /* DWCTODO - ISOC */
d255 1
a255 1
		epipe->request = dwc_dma_alloc(sizeof(usb_device_request_t),&epipe->dma_req);
d258 1
a258 1
			dwc_free(epipe->urb);
d488 1
a488 1
	softc->core_if = dwc_otg_cil_init(hw_base);
d503 1
a503 1
		ret += dwc_otg_set_param_ ## X(softc->core_if,params->X);
d534 1
a534 1
			ret += dwc_otg_set_param_dev_perio_tx_fifo_size(softc->core_if,params->dev_perio_tx_fifo_size[i],i);
d536 1
a536 1
			ret += dwc_otg_set_param_dev_tx_fifo_size(softc->core_if,params->dev_tx_fifo_size[i],i);
d549 1
a549 1
		dwc_otg_cil_remove(softc->core_if);
d555 1
a555 1
	dwc_otg_disable_global_interrupts(softc->core_if);
d563 1
a563 5
	dwc_otg_core_init(softc->core_if);

	/* Enable IRQs */
	dprintf(("","dwc_otg_enable_global_interrupts\n"));
	dwc_otg_enable_global_interrupts(softc->core_if);
d567 1
a567 1
	softc->hcd = dwc_otg_hcd_alloc_hcd();
d571 1
a571 1
	ret = dwc_otg_hcd_init(softc->hcd, softc->core_if);
d579 5
a583 1
	softc->port = dwc_otg_hcd_otg_port(softc->hcd);
d588 1
a588 1
	ret = dwc_otg_hcd_start(softc->hcd, &hcd_ops);
d609 1
a609 1
		dwc_otg_hcd_stop(softc->hcd);
d613 1
a613 1
	if(softc->hcd)
d615 2
a616 2
		dwc_otg_hcd_remove(softc->hcd);
		softc->hcd = NULL;
d619 1
a619 1
	if(softc->core_if)
d621 2
a622 2
		dwc_otg_cil_remove(softc->core_if);
		softc->core_if = NULL;
d645 1
a645 1
		ret = dwc_otg_hcd_handle_intr(softc->hcd);
d651 1
a651 1
	ret = dwc_otg_handle_common_intr(softc->core_if);
@


1.2
log
@Misc housekeeping
Detail:
  Makefile, !MkDebug,fd7 - Debug version of module can now be built just be passing "DEBUG=TRUE" to amu
  c/cmodule - Only accept USB controllers if HAL_USBControllerInfo says the struct size is an exact match with what we expect
  c/dwc_otg_riscos - Remove incorrect comment; both dwc_dma_alloc and malloc_contig zero memory
  s/bufman - Delete unused file
  s/call_veneer, s/triggercbs - Use Entry/EXIT macros to avoid single-reg LDM/STM performance warnings. Convert tabs to spaces.
Admin:
  Tested in BCM2835 ROM


Version 0.02. Tagged as 'DWCDriver-0_02'
@
text
@d48 1
d400 1
a400 1
		callx_add_callback(endpoint_disable_cb,epipe->dwc_priv);
@


1.1
log
@Add initial version of DWCDriver - USB driver for Synopsys DWC OTG controllers
Detail:
  A fairly simple wrapper for Synopsys's open source "DWC_otg" Linux driver, based around a GPL-free version of the DWC_otg 2.90a sources received from the Raspberry Pi foundation.
  Instead of interfacing with the Linux USB stack a new host interface layer has been implemented to allow it to talk to the standard BSD-derived RISC OS stack.
  RTSupport is used to provide the threading functionality that the DWC driver relies upon.
  Interesting files:
  - c/cmodule, h/cmodule - Main module frontend
  - c/dwc_common_riscos, h/dwc_common_riscos - Implementation of the OS support layer required by the DWC driver
  - c/dwc_otg_riscos, h/dwc_otg_riscos - Core code for the BSD driver implementation, driver init/shutdown, and for handling calls from the DWC host driver to us
  - c/port - Some support functions required by BSD-style code inherited from the other USB drivers
  - c/softc_device - Code to handle requests from the BSD layer to attached USB devices
  - c/softc_root - Code to handle requests from the BSD layer to the controller root hub
  - dwc/doc/* - Original Synopsys release notes & user guide pdfs
  - dwc/driver/*, dwc/dwc_common_port/* - Synopsys code and documentation. A few tweaks were required to allow it to compile under Norcroft, but otherwise it's functionally equivalent to the original sources.
Admin:
  Tested in BCM2835 ROM
  There are a few loose ends still to tidy up (search for "DWCTODO"), mainly regarding implementation of Isochronous support, but otherwise the driver seems stable enough for daily use.


Version 0.01. Tagged as 'DWCDriver-0_01'
@
text
@a173 2
	/* We could use DWC-style dwc_dma_alloc here, but that unnecessarily zeros the memory
	   Use BSD-style malloc_contig instead */
@


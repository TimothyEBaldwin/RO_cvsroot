head	1.18;
access;
symbols
	MUSBDriver-0_35:1.18
	MUSBDriver-0_34:1.18
	MUSBDriver-0_33:1.18
	MUSBDriver-0_32:1.18
	MUSBDriver-0_31:1.16
	MUSBDriver-0_30:1.16
	MUSBDriver-0_29:1.16
	MUSBDriver-0_28:1.16
	MUSBDriver-0_27:1.14
	MUSBDriver-0_26:1.14
	MUSBDriver-0_25:1.14
	MUSBDriver-0_24:1.13
	MUSBDriver-0_23:1.13
	MUSBDriver-0_22:1.12
	MUSBDriver-0_21:1.11
	MUSBDriver-0_20:1.10
	MUSBDriver-0_19:1.10
	MUSBDriver-0_18:1.9
	MUSBDriver-0_17:1.9
	MUSBDriver-0_16:1.8
	MUSBDriver-0_15:1.8
	MUSBDriver-0_14:1.8
	MUSBDriver-0_13:1.7
	MUSBDriver-0_12:1.7
	MUSBDriver-0_11:1.6
	MUSBDriver-0_10:1.5
	MUSBDriver-0_09:1.5
	MUSBDriver-0_08:1.5
	MUSBDriver-0_07:1.4
	MUSBDriver-0_06:1.3
	MUSBDriver-0_05:1.3
	MUSBDriver-0_04:1.3
	MUSBDriver-0_03:1.3
	MUSBDriver-0_02:1.2;
locks; strict;
comment	@# @;


1.18
date	2017.09.23.09.01.54;	author rool;	state Exp;
branches;
next	1.17;
commitid	6rXidvVzktBEFi8A;

1.17
date	2017.09.23.08.54.56;	author rool;	state Exp;
branches;
next	1.16;
commitid	qcGeJbCDtonLCi8A;

1.16
date	2016.12.17.10.42.20;	author rool;	state Exp;
branches;
next	1.15;
commitid	CYGmihDmIHN6ekyz;

1.15
date	2016.12.10.12.59.00;	author rool;	state Exp;
branches;
next	1.14;
commitid	Z4aKvGTXdtkJcrxz;

1.14
date	2015.11.18.22.44.49;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	aBgIXq3khxmbVCJy;

1.13
date	2015.08.21.20.09.37;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	AR6BOUEtVfUgVayy;

1.12
date	2014.06.01.13.58.15;	author jlee;	state Exp;
branches;
next	1.11;
commitid	8OjtcW0RnvIJcPCx;

1.11
date	2014.05.27.19.19.39;	author jlee;	state Exp;
branches;
next	1.10;
commitid	WoQoyE1NXx3X8dCx;

1.10
date	2013.03.30.23.42.36;	author jlee;	state Exp;
branches;
next	1.9;
commitid	KYekipBHsUiacSJw;

1.9
date	2012.06.06.23.53.33;	author jlee;	state Exp;
branches;
next	1.8;
commitid	CFvOhB5lkQSNNH7w;

1.8
date	2011.08.05.00.06.14;	author jlee;	state Exp;
branches;
next	1.7;
commitid	XLVfaQiiOY4ZJfuv;

1.7
date	2011.05.22.20.32.28;	author jlee;	state Exp;
branches;
next	1.6;
commitid	ojDCXEOv6C57WIkv;

1.6
date	2011.04.11.23.25.35;	author jlee;	state Exp;
branches;
next	1.5;
commitid	6pcEoJPvdLzddtfv;

1.5
date	2010.08.14.21.41.51;	author jlee;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.22.00.00.01;	author jlee;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.02.20.55.12;	author jlee;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.20.51.02;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2009.07.02.20.15.46;	author jlee;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Remove HAL library variant
Detail:
  Simplify the makefile by not building a HAL variant.
  cmodule.c: 2 fewer warnings
  musb.c/musb_debug.c/musb_peri.c/musb_root.c/musb_util.c/tps.c: remove usbhal.h include
  cmodule.h/musb_usb.c: USBHAL is no longer defined
  CMHG file changed to make Makefile
Admin:
  Submission for USB bounty.

Version 0.32. Tagged as 'MUSBDriver-0_32'
@
text
@/* Copyright 2009 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "modhead.h"
#include "swis.h"
#include <stdlib.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <stddef.h>
#include <machine/bus.h>

#include <sys/queue.h>
#include <sys/types.h>
#include <sys/systm.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>

#include "Global/RISCOS.h"
#include "Global/Services.h"
#include "Global/HALEntries.h"
#include "Interface/USBDriver.h"
#include "callx/callx.h"
#include "cmodule.h"
#include "tboxlibint/messages.h"

/* Have to avoid including stdio as there's a clash with the BSD stuff */
#define __stdio_h

#include "DebugLib/DebugLib.h"
#include "USB/USBDevFS.h"

#include "musb.h"
#include "tps.h"
#include "musb_usb.h"

/*****************************************************************************
* Function prototypes - Private to this file
*****************************************************************************/

/* this function is generated by resgen from the resource files */
extern void* resource_files (void);

/*****************************************************************************
* Module management
*****************************************************************************/

static int* magic = NULL;
static int hal_device = -1;
static int instance = 0;
static int device_number;

void* private_word;

extern musb_softc_t musb_soft; /* Keep compiler happy (extern only used by debug code for simplicity) */
musb_softc_t musb_soft;
static struct device * usb_soft=NULL;
static volatile musb_regs *musb_base;
static bool driver_init=false;
static bool registering=false; /* True/false for whether we're in the middle of registering. Avoids nested registration attempt during ROM init. */

extern int * init_veneer (void);

static _kernel_oserror* register_bus(void *in,struct device **out)
{
    *out = NULL;
    /* Check USBDriver is new enough */
    int version;
    _kernel_oserror *e = _swix(USBDriver_Version,_OUT(0),&version);
    if(e)
        return e;
    if(version < RISCOS_USBDRIVER_API_VERSION)
    {
        return make_error (ErrorNumber_MUSB_USBTooOld, 0);
    }

    /* Now attempt to register */
    registering = true;
    e = _swix(USBDriver_RegisterBus, _INR(0,1)|_OUT(0),in,RISCOS_USBDRIVER_API_VERSION,out);
    if(e) *out = NULL;
    registering = false;
    return e;
}

void build_veneer (int* vn, int* st, size_t sz)
{
    int i;
    dprintf (("", "writing veneer from %p at %p\n", st, vn));
    int* entry_table = vn + sz / sizeof (void*);
    for (i = 0; i < sz / sizeof (void*); ++i) {
        int* entry = entry_table + 2 * i;

        /* if the method isn't implemented, don't veneer it */
        if (st[i] == NULL) continue;

        /* copy function pointer into veneer */
        vn[i] = st[i];

        /* copy new pointer into structure */
        st[i] = (int) entry;

        /* LDR ip, function[i] */
        entry[0] = 0xe51fC000       /* LDR ip, [pc, #-0] */
                  + 8               /* go back to current instruction */
                  + i * 8           /* go back to beginning of veneers */
                  + sz              /* go back to beginning of struct */
                  - i * 4;          /* go to func pointer */

        /* B common */
        entry[1] = 0xea000000       /* B here + 8 */
                  | ((magic - entry - 1) & 0x00ffffff);
                                    /* branch to diff */
    }
    _swix(OS_SynchroniseCodeAreas, _INR(0,2), 1,
                                   entry_table,
                                   entry_table + 2 * (sz / sizeof (void*)) - 1);
}

static _kernel_oserror* new_instance (_kernel_swi_regs* r, void* pw, void* h)
{
    _kernel_oserror * e;

    (void) r;
    (void) pw;
    (void) h;



    /* register with the usbdriver module if it's already resident */
    dprintf (("", "Registering with USB driver\n"));
    e = register_bus(&musb_soft, &usb_soft);
    if (e)
    {
        dprintf (("", "Failed to register: %s\n", e->errmess));
    }
    else
    {
        dprintf (("", "Registering with USB driver-done\n"));
    }


    // allow enough space for name, % and number, then space, and
    // another number
    char name[sizeof Module_Title + 1 + 12 + 1 + 12];
    sprintf (name, Module_Title"%%%d %d", instance + 1, hal_device+1);
    dprintf (("", "Trying to start %s\n", name));
    e = _swix (OS_Module, _INR(0,1), 14, name);

    if (e)
    {
        dprintf (("", "Failed to start %s: %s\n", name, e->errmess));
    }

    return NULL;
}

static void init_driver(void)
{
    if(driver_init)
        return;

    memset (&musb_soft, 0, sizeof musb_soft);
    sprintf (musb_soft.sc_bus.bdev.dv_xname, "MUSB%d", instance);
    musb_soft.musb_base = musb_base;
    musb_soft.devno = device_number;

    /* todo - HAL should tell us the device that controls the PHY */
    tps_init(&musb_soft.tps,&musb_soft);

    musb_init (&musb_soft);

    _swix (OS_ClaimDeviceVector, _INR(0,4),
        device_number| (1u<<31), usb_irq_entry, private_word, 0, 0);
    _swix (OS_Hardware, _IN(0) | _INR(8,9),
        device_number, 0, EntryNo_HAL_IRQEnable);

    driver_init = true;
}

static void shutdown_driver(void)
{
    if(!driver_init)
        return;

    /* don't disable the interrupt since it is shared, the OS will disable it
       when noone is left responding */
//    _swix (OS_Hardware, _IN(0) | _INR(8,9),
//        device_number, 0, EntryNo_HAL_IRQDisable);
    callx_remove_all_callbacks ();
    callx_remove_all_callafters ();
    callx_remove_all_calleverys ();
    _swix (OS_ReleaseDeviceVector, _INR(0,4),
        device_number | (1u<<31), usb_irq_entry, private_word, 0, 0);

    tps_shutdown(&musb_soft.tps);

    /* Reset controller */
    musb_soft.musb_base->otg_sysconfig = OTG_SYSCONFIG_SOFTRESET;

    driver_init = false;
}

_kernel_oserror* module_init (const char *cmd_tail, int podule_base, void *pw)
{
    _kernel_oserror* e = NULL;

    callx_init (pw);

    /* set up debugging */
    debug_initialise (Module_Title, "", "");
    debug_set_device(DADEBUG_OUTPUT);
//    debug_set_device(PRINTF_OUTPUT);
    debug_set_unbuffered_files (TRUE);

#ifdef MUSB_DEBUG
    const char *c = getenv("musbdebug");
    musbdebug = (c?atoi(c):0);
//    musbdebug = 11;
#endif


    private_word = pw;
    instance = podule_base;


    /* if we're the first instance, then start searching from device # 0,
       otherwise the device to start searching from was passed as a string
       in the command tail */

    if (podule_base != 0)
    {
        char* endptr;
        hal_device = (int) strtol (cmd_tail, &endptr, 0);
        if (endptr == cmd_tail)
        {
            struct
            {
                int errnum;
                char errtok[8];
            } err_noreinit = { ErrorNumber_MUSB_NoReinit, "NumParm" };

            return _swix (MessageTrans_ErrorLookup, _INR(0,2),
                          &err_noreinit, 0 /* Global messages */, 0 /* Internal buffer */);
        }
    }
    else
    {
#ifndef ROM
        /* Only first instance registers the messages in ResourceFS */
        e = _swix (ResourceFS_RegisterFiles, _IN (0), resource_files ());
        if (e != NULL) return e;
#endif
    }

    e = messages_file_open (Module_MessagesFile);
    if (e) goto error_dereg;
    
    /* find the next possible controller */
    do {
        struct
        {
            int type;
            int flags;
            void *hw;
            int devno;
        } usbinfo;
        size_t usbinfolen;

        hal_device++;

        e = _swix(OS_Hardware, _INR(0,2)|_INR(8,9)|_OUT(0),
                               hal_device, &usbinfo, sizeof usbinfo,
                               0, EntryNo_HAL_USBControllerInfo,
                               &usbinfolen);
        if (!e && (usbinfolen == sizeof(usbinfo)) && (usbinfo.type == HALUSBControllerType_MUSBMHDRC))
        {
            device_number = usbinfo.devno;
            musb_base = usbinfo.hw;
            break;
        }
        if(e || !usbinfolen)
        {
            /* Reached end of list */
            e = make_error (ErrorNumber_MUSB_NoMUSB, 0);
            goto error;
        }
    } while (1);

    dprintf (("", "Found MUSB controller on device %d\n", hal_device));

    if ((magic = init_veneer ()) == NULL)
    {
        e = make_error (ErrorNumber_MUSB_ClaimVeneer, 0);
        goto error;
    }
    dprintf (("", "magic at %p", magic));

    init_driver();

    dprintf (("", "Finished module initialisation\n"));

    /* try and start a new instance to catch any more controllers on the bus */

    callx_add_callback (new_instance, 0);

    return NULL;

error:
    dprintf (("", "Failed initialisation: %s\n", e->errmess));
    messages_file_close ();
error_dereg:
#ifndef ROM
    if (podule_base == 0) _swix (ResourceFS_DeregisterFiles, _IN(0), resource_files ());
#endif
    return e;    
}

_kernel_oserror *module_final(int fatal, int podule, void *pw)
{
    NOTUSED(podule);
    NOTUSED(fatal);
    NOTUSED(pw);
    
    if (usb_soft != NULL)
    {
        _swix (USBDriver_DeregisterBus, _IN(0), usb_soft);
        usb_soft=NULL;
    }

    shutdown_driver();

    if (magic) _swix (OS_Module, _IN(0)|_IN(2), 7, magic);

    messages_file_close ();

#ifndef ROM
    /* only remove files for last instantiation */
    if (podule == 0)
    {
        _swix (ResourceFS_DeregisterFiles, _IN(0), resource_files ());
    }
#endif
    return NULL;
}

void module_services(int service_number, _kernel_swi_regs *r, void *pw)
{
    dprintf (("", "svce %x reason %x\n",service_number,r->r[0]));
    NOTUSED(pw);
    switch (service_number)
    {
      case Service_USB:
        switch (r->r[0])
        {
           case Service_USB_USBDriverStarting:
             if ((usb_soft == NULL) && !registering)
             {
                 init_driver();
                 dprintf (("", "Registering with USB driver from svcecall\n"));
                 _kernel_oserror *e = register_bus(&musb_soft,&usb_soft);
                 if(e)
                 {
                     dprintf (("", "Failed to register: %s\n", e->errmess));
                 }
                 else
                 {
                     dprintf (("", "Registering with USB driver from svcecall-done\n"));
                 }
             }
             break;
           case Service_USB_USBDriverDying:
             dprintf (("", "Deregistering with USB driver\n"));
             /* USBDriver will do the deregistering at this point, since
                it's SWIs are not active anymore */
//             ehci_detach(&ehci_soft,0);
//             ehci_shutdown(&ehci_soft);
             usb_soft = NULL;
             shutdown_driver(); /* TODO - Would be nice if this didn't kill peripheral mode support */
             break;
           default:break;
         }
        break;
      case Service_PreReset:
        dprintf (("", "Svce prereset %x %x\n",Service_PreReset,service_number));
        shutdown_driver(); /* Should be safe to do this without deregistering the bus */
        break;
#ifndef ROM
      case Service_ResourceFSStarting:
        /* Re-register the messages */
        (*(void (*)(void *, void *, void *, void *))r->r[2]) (resource_files (), 0, 0, (void *)r->r[3]);
        break;
#endif
    }
}

#ifdef MUSB_DEBUG
_kernel_oserror *module_commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
    switch (cmd_no) {
    case CMD_MUSBRegs:
        {
        /* Disable interrupts and dump everything to a buffer */
        char* buf = malloc(4096);
        int s = _kernel_irqs_disabled();
        _kernel_irqs_off();
        musb_dump_regs(buf);
        if(s==0)
        	_kernel_irqs_on();
        printf("%s",buf);
        free(buf);
        break;
        }
    case CMD_MUSBDebug:
        {
        char* ptr;
        musbdebug = (int) strtoul (arg_string, &ptr, 0);
        }
        break;
    case CMD_MUSBWrite:
        {
        int a, b;
        char* ptr;
        a = (int) strtoul (arg_string, &ptr, 16);
        b = (int) strtoul (ptr, 0, 16);
        printf ("writing %x to %x\n", b, a);
        ((char *)musb_soft.musb_base)[a] = b;
        }
        break;
    case CMD_MUSBState:
        {
        /* Disable interrupts and dump everything to a buffer */
        char* buf = malloc(32768);
        int s = _kernel_irqs_disabled();
        _kernel_irqs_off();
        musb_dump_state(buf);
        if(s==0)
        	_kernel_irqs_on();
        printf("%s",buf);
        free(buf);
        }        
    }

    return 0;

    NOTUSED(pw);
    NOTUSED(argc);
}
#endif


int usb_irq_handler(_kernel_swi_regs *r, void *pw)
{
    int ret;

    /* Prevent recursion by masking the IRQ while we handle the interrupt */
    _swix(OS_Hardware, _IN(0)|_INR(8,9), device_number, 0, EntryNo_HAL_IRQDisable);

    ret = musb_intr(&musb_soft);

    _swix(OS_Hardware, _IN(0)|_INR(8,9), device_number, 0, EntryNo_HAL_IRQEnable);

    NOTUSED(r);
    NOTUSED(pw);

    return ret;
}

/*---------------------------------------------------------------------------*/
/* RISC OS specific leaf functions                                           */
/*---------------------------------------------------------------------------*/
void riscos_irqclear(int devno)
{
    _swix(OS_Hardware, _IN(0)|_INR(8,9), devno, 0, EntryNo_HAL_IRQClear);
}

static _kernel_oserror*_riscos_abort_pipe (_kernel_swi_regs * r, void* pw, void* v)
{
    NOTUSED(r);
    NOTUSED(pw);
    musb_abort_xfer (v, USBD_TIMEOUT);
    return NULL;
}

void
riscos_abort_pipe (void* v)
{
    callx_add_callback_irqsoff (_riscos_abort_pipe, v);
}

void
riscos_cancel_abort_pipe (void* v)
{
    callx_remove_callback (_riscos_abort_pipe, v);
}

int do_iicop(iic_transfer *tran,int count)
{
    return (_swix(OS_IICOp,_INR(0,1),tran,count) == 0);
}
@


1.17
log
@Common up NetBSD supporting functions
Detail:
  port.c -> bsd_fns.c, and use the copy from EHCI/OHCI driver, minus the bus access functions not needed here.
Admin:
  Submission for USB bounty.
  Not tagged, part 2 follows shortly.
@
text
@d170 1
a170 1
static void init_driver()
d193 1
a193 1
static void shutdown_driver()
@


1.16
log
@Internationalised
Detail:
  Add support for standalone messages registration, and actually use the messages rather than just exporting them in ROM builds.
  Changed to use allocated error bases rather than 0.
  Sync with other HC for ease of comparison where possible.
Admin:
  Submission for USB bounty.
  Tested on a BBxM.

Version 0.28. Tagged as 'MUSBDriver-0_28'
@
text
@d481 4
a484 10
/*****************************************************************************/

usbd_status usb_insert_transfer(usbd_xfer_handle xfer)
{
    usbd_status status;
    _swix (USBDriver_InsertTransfer, _IN (0) | _OUT (0), xfer, &status);
    return status;
}

void usb_transfer_complete(usbd_xfer_handle xfer)
d486 1
a486 1
    _swix (USBDriver_TransferComplete, _IN (0), xfer);
@


1.15
log
@Build fix
Admin:
  Requires NetBSD-1_17
@
text
@d62 1
a62 1
static int hal_device = 0;
d86 4
a89 1
        return (_kernel_oserror*)"\0\0\0\0USBDriver too old";
d218 1
a218 1
    _kernel_oserror* e = 0;
d249 8
a256 2
            return (_kernel_oserror*)
                "\1\0\0\0"Module_Title" can't be reinitialised";
d259 8
d268 4
a271 2

    // find the next possible controller
d282 2
d288 7
a294 1
        if (!e && (usbinfolen == sizeof(usbinfo)) && usbinfo.type == 2)
d296 4
a299 9
		device_number = usbinfo.devno;
		musb_base = usbinfo.hw;
		break;
	}
	else
		hal_device++;
        if(e) return e;
        if(!usbinfolen)
        	return (_kernel_oserror*) "\0\0\0\0No MUSB devices found";
d306 2
a307 1
        return (_kernel_oserror*) "\0\0\0\0Couldn't claim magic";
d317 3
a319 1
     callx_add_callback (new_instance, 0);
d321 8
a328 1
    return 0;
d347 9
a355 7
//#ifdef STANDALONE
//    /* only remove files for last instantiation */
//    if (podule == 0)
//    {
//        _swix (ResourceFS_DeregisterFiles, _IN (0), resource_files ());
//    }
//#endif
d400 6
a405 1
      default:break;
@


1.14
log
@Don't build a veneer that points to nothing
Copy of the change in NetBSD-1_09.

Version 0.25. Tagged as 'MUSBDriver-0_25'
@
text
@d307 1
a307 1
        _swix (USBDriver_DeRegisterBus, _IN(0), usb_soft);
@


1.13
log
@Don't reach into USBDriver's back pocket
cmodule.c:
  Use USBDriver.h from interface exports
Makefile:
  Remove duplicated libs from debug build
  Remove relative reference to NetBSD component from VPATH
!MkDebug:
  Select debug target so the right compiler switches are used
musb.c/musb_debug.c/musb_peri.c/musb_root.c/musb_usb.c/musb_util.c/tps.c:
  Unused reference to USBDriver.h removed
Built, but not tested.

Version 0.23. Tagged as 'MUSBDriver-0_23'
@
text
@d103 3
@


1.12
log
@Fix to allow building against NetBSD-0_85
Detail:
  c/cmodule - Don't use NetBSD/build/service.h, it no longer exists. Use the exported USB/USBDevFS.h instead. Fix service call reason codes to use USBDevFS names.
  c/musb, c/musb_debug, c/musb_hal, c/musb_peri, c/musb_root, c/musb_usb, c/musb_util, c/tps - Strip redundant #includes
Admin:
  Tested in OMAP3 ROM build
  Build output is binary-identical to previous version
  Requires NetBSD-0_85


Version 0.22. Tagged as 'MUSBDriver-0_22'
@
text
@a15 1
#include "../../NetBSD/build/USBDriver.h"
d35 1
@


1.11
log
@Fix handling of short control transfers
Detail:
  c/musb - Updated musb_ep0_host() to treat a short control packet as the end of the transfer, as mandated by the USB spec. Also updated a few other pieces of code to ensure the transfer length is reported correctly if an error occurs.
  c/cmodule - Fix potential null pointer dereference when debugging enabled
  Makefile - Fix lack of DPRINTF() debug output in debug builds due to USB_DEBUG not being defined
Admin:
  Tested on BB-xM with high processor vectors
  Fixes 99% of connected devices failing to initialise following the change to the device initialisation logic made to USBDriver in NetBSD-0_82 (initial device descriptor requests now request more data than is likely to be available, triggering a short packet/xfer response)


Version 0.21. Tagged as 'MUSBDriver-0_21'
@
text
@d44 1
a44 2
#include "../../NetBSD/build/service.h"
#include "oslib/devicefs.h"
d331 1
a331 1
           case Service_USBDriver_Starting:
d347 1
a347 1
           case Service_USBDriver_Dying:
@


1.10
log
@Add re-entrancy check to USBDriver registration
Detail:
  c/cmodule - Added a re-entrancy check to USBDriver registration, to avoid any shenanigans if we receive "USBDriver has started" service calls while in the middle of registering
Admin:
  Tested on BB-xM
  Doesn't fix any known MUSBDriver-related issue, but is the same fix as was made to DWCDriver after the above-mentioned problem was found to be the cause of a hang on boot in recent Pi ROMs


Version 0.19. Tagged as 'MUSBDriver-0_19'
@
text
@d224 2
a225 1
    musbdebug = atoi(getenv("musbdebug"));
@


1.9
log
@Misc housekeeping
Detail:
  Makefile, !MkDebug,fd7 - Debug version of module can now be built just by passing "DEBUG=TRUE" to amu
  c/cmodule, c/musb_hal - Only accept USB controllers if HAL_USBControllerInfo says the struct size is an exact match with what we expect
  s/bufman - Delete unused file
  s/call_veneer, s/triggercbs - Use Entry/EXIT macros to avoid single-reg LDM/STM performance warnings. Convert tabs to spaces.
Admin:
  Tested on rev A2 BB-xM


Version 0.17. Tagged as 'MUSBDriver-0_17'
@
text
@d74 1
d89 1
d92 1
d332 1
a332 1
             if (usb_soft == NULL)
@


1.8
log
@Update to work with zero page relocation. Remove ability to cancel transfers by pressing escape
Detail:
  c/cmodule - Rework driver init/shutdown code to avoid null pointer dereference during Service_PreReset/USBDriver_Dying
  c/port - Removed ability to cancel transfers by pressing escape. Too dangerous for things like mass storage devices, and the code won't work anyway for the common case of being in the wimp
  s/triggercbs - Try using OS_ReadSysInfo 6 to get IRQsema ptr before falling back on legacy address
Admin:
  Tested on rev A2 BB-xM


Version 0.14. Tagged as 'MUSBDriver-0_14'
@
text
@d261 1
a261 1
        if (!e && (usbinfolen >= sizeof(usbinfo)) && usbinfo.type == 2)
@


1.7
log
@Add support for HAL builds of MUSBDriver
Detail:
  Makefile - Now builds a HAL-compatible static library during the export libs phase
  !MkHAL,fd7 - Handy script for building the HAL lib
  c/musb_hal - HAL version of cmodule.c
  c/musb, c/musb_debug, c/musb_peri, c/musb_root, c/musb_usb, c/musb_util, c/tps, h/cmodule, h/musb, h/musb_util, h/tps - Changed to support the HAL build. Biggest change was getting rid of all global vars; everything is now done via the bus ptr instead.
  c/port - Removed microtime and moved riscos_irq_clear here, to match change made in main USB drivers
Admin:
  HAL & non-HAL versions tested on rev C2 BB, rev A2 BB-xM, rev C1 TouchBook
  Needs latest Kernel & NetBSD USB drivers


Version 0.12. Tagged as 'MUSBDriver-0_12'
@
text
@d72 3
d162 46
d226 1
a246 1
    volatile musb_regs *musb_base;
a275 2
    private_word = pw;

d282 1
a282 16
    memset (&musb_soft, 0, sizeof musb_soft);
    sprintf (musb_soft.sc_bus.bdev.dv_xname, "MUSB%d", instance);
    musb_soft.musb_base = musb_base;
    musb_soft.devno = device_number;

    /* todo - HAL should tell us the device that controls the PHY */
    tps_init(&musb_soft.tps,&musb_soft);

    musb_init (&musb_soft);

    _swix (OS_ClaimDeviceVector, _INR(0,4),
        device_number| (1u<<31), usb_irq_entry, pw, 0, 0);
    _swix (OS_Hardware, _IN(0) | _INR(8,9),
        device_number, 0, EntryNo_HAL_IRQEnable);


a303 11
// TODO - stop the controller

    /* don't disable the interrupt since it is shared, the OS will disable it
       when noone is left responding */
//    _swix (OS_Hardware, _IN(0) | _INR(8,9),
//        device_number, 0, EntryNo_HAL_IRQDisable);
    callx_remove_all_callbacks ();
    callx_remove_all_callafters ();
    callx_remove_all_calleverys ();
    _swix (OS_ReleaseDeviceVector, _INR(0,4),
        device_number | (1u<<31), usb_irq_entry, pw, 0, 0);
d305 1
a305 1
    tps_shutdown(&musb_soft.tps);
d331 1
d351 1
a351 2
             memset (&musb_soft, 0, sizeof musb_soft);
             musb_init (&musb_soft);
d358 1
a358 6
        /* reset the controller */
#if 0
        EOWRITE4(&ehci_soft, EHCI_USBCMD, 0);
        EOWRITE4(&ehci_soft, EHCI_USBCMD, EHCI_CMD_HCRESET);
        EOREAD4(&ehci_soft, EHCI_USBCMD);/* flush the command */
#endif
@


1.6
log
@Restructure MUSBDriver source code, rework host mode endpoint handling, plus other misc changes
Detail:
  c/musb_debug - New file containing debug code.
  c/musb_peri - Contains the code for handling peripheral mode, taken from c/musb
  c/musb_root - Contains the code for handling the USBDriver-required 'soft' hub, taken from c/musb
  c/musb_usb - Contains initialisation code and other misc USBDriver-related code, mostly taken from c/musb
  c/musb_util - Misc utility functions from c/musb
  h/musb_util, h/musb_usb - A couple of new header files to help with breaking things up. Might make sense to break h/musb_usb down further (or just consolidate everything back into h/musb)
  c/musb - Stripped out pretty much everything except code related to host-mode endpoint and interrupt handling. Instances of the new musb_multiplexer struct are used to handle endpoint allocation, and allocation is now performed on a per-usbd_xfer basis instead of on a per-pipe basis. This should allow the code to cope better with situations where the number of pipes is greater than the number of physical endpoints, although much work is still required.
  c/cmodule, c/port, c/tps, h/cmodule, h/musb - Misc tweaks and changes
Admin:
  Tested on rev A2 BB-xM.


Version 0.11. Tagged as 'MUSBDriver-0_11'
@
text
@d69 1
a69 2
volatile musb_regs* musb_base=0;

d197 1
a228 3
    /* todo - HAL should tell us the device that controls the PHY */
    tps_init(pw);

d236 3
d240 2
a241 1
    sprintf (musb_soft.sc_bus.bdev.dv_xname, "MUSB%d", instance);
a242 1
    /* in BSD this is called from sys/pci/ehci_pci.c */
a256 1
//   _swix (OS_AddCallBack, _INR(0,1), new_entry, pw);
a258 4

//error:
//    dprintf (("","Failed initialisation: %s\n", e->errmess));
//    return e;
a259 38
    

#if 0
    e = _swix (ResourceFS_RegisterFiles, _IN (0), resource_files ());
    if (e) goto fin_callx;

    e = messages_file_open (Module_MessagesFile);
    if (e) goto fin_resources;

//    e = initialise_memory (&hcca, pw);
//    if (e) goto fin_messages;
//
//    e = initialise_controller (hcca, pw);
//    if (e) goto fin_memory;
//
//    e = usbd_initialise (pw);
//    if (e) goto fin_controller;

    return 0;

finalise:
//    usbd_finalise (pw);
//fin_controller:
//    controller_finalise (pw);
//fin_memory:
//    finalise_memory ();
//fin_messages:
//    messages_file_close ();
fin_resources:
    _swix (ResourceFS_DeregisterFiles, _IN (0), resource_files ());
fin_callx:
    callx_remove_all_callbacks ();

    return e;

    NOTUSED(podule_base);
}
#endif
d272 1
a272 6
// need to stop the controller
#if 0
    EOWRITE4(&ehci_soft, EHCI_USBCMD, 0);
    EOWRITE4(&ehci_soft, EHCI_USBCMD, EHCI_CMD_HCRESET);
    EOREAD4(&ehci_soft, EHCI_USBCMD);/* flush the command */
#endif
d284 1
a284 1
    tps_shutdown(pw);
d378 1
a378 1
        ((char *)musb_base)[a] = b;
a433 5
void riscos_irqclear(void)
{
    _swix(OS_Hardware, _IN(0)|_INR(8,9), device_number, 0, EntryNo_HAL_IRQClear);
}

d453 5
@


1.5
log
@Add timeout handling to MUSBDriver, tidy code a bit
Detail:
  Makefile - rewritten to use CModule fragment instead of deprecated RAMCModule & ROMCModule fragments. Link stage also outputs symbol table to aid in debugging.
  c/cmodule, c/musb, h/musb - Add code to handle transfer timeouts
  c/musb - Fix a couple of compiler warnings, including a bug in root hub handling
Admin:
  Tested on rev C2 beagleboard.
  Machine no longer hangs on boot with hub + keyboard connected to OTG port, but keyboard often fails to initialise and needs to be *USBReset or re-plugged.


Version 0.08. Tagged as 'MUSBDriver-0_08'
@
text
@d49 1
d62 4
a65 4
int* magic = NULL;
int hal_device = 0;
int instance = 0;
int device_number;
d72 1
a72 1
struct device * usb_soft=NULL;
d75 1
a75 1
_kernel_oserror* register_bus(void *in,struct device **out)
d122 1
a122 1
_kernel_oserror* new_instance (_kernel_swi_regs* r, void* pw, void* h)
d128 1
a128 1
    
a231 5
    _swix (OS_ClaimDeviceVector, _INR(0,4),
        device_number| (1u<<31), usb_irq_entry, pw, 0, 0);
    _swix (OS_Hardware, _IN(0) | _INR(8,9),
        device_number, 0, EntryNo_HAL_IRQEnable);

a241 3
    /* fix n companions */
//    ehci_soft.sc_ncomp = 2;

d245 5
d306 4
a309 1

d349 1
a396 1
extern int retry_counter;
d401 10
a410 19
	printf("FADDR: %02x\n",musb_base->common.faddr);
	printf("POWER: %02x\n",musb_base->common.power);
//	printf("INTRUSB: %02x\n",musb_base->common.intrusb);
	printf("FRAME: %04x\n",musb_base->common.frame);
	printf("INDEX: %02x\n",musb_base->common.index);
	printf("TESTMODE: %02x\n",musb_base->common.testmode);
	printf("DEVCTL: %02x\n",musb_base->devctl);
	printf("ULPIVBUSCONTROL: %02x\n",musb_base->ulpivbuscontrol);
	printf("ULPIUTMICONTROL: %02x\n",musb_base->ulpiutmicontrol);
	printf("ULPIINTMASK: %02x\n",musb_base->ulpiintmask);
	printf("ULPIINTSRC: %02x\n",musb_base->ulpiintsrc);
	printf("OTG_REVISION: %08x\n",musb_base->otg_revision);
	printf("OTG_SYSCONFIG: %08x\n",musb_base->otg_sysconfig);
	printf("OTG_SYSSTATUS: %08x\n",musb_base->otg_sysstatus);
	printf("OTG_INTERFSEL: %08x\n",musb_base->otg_interfsel);
	printf("OTG_FORCESTDBY: %08x\n",musb_base->otg_forcestdby);
	printf("EP TXMAXP TXCSR TXTYPE TXINTERVAL RXMAXP RXCSR RXCOUNT RXTYPE RXINTERVAL\n");
	for(int i=0;i<16;i++)
        	printf("%2d %04x   %04x  %02x     %02x         %04x   %04x  %04x    %02x     %02x\n",i,musb_base->csr.host_ep[i].txmaxp,musb_base->csr.host_ep[i].host_txcsr,musb_base->csr.host_ep[i].host_txtype,musb_base->csr.host_ep[i].host_txinterval,musb_base->csr.host_ep[i].rxmaxp,musb_base->csr.host_ep[i].host_rxcsr,musb_base->csr.host_ep[i].rxcount,musb_base->csr.host_ep[i].host_rxtype,musb_base->csr.host_ep[i].host_rxinterval);
d412 1
d432 1
a432 1
        char* buf = malloc(4096);
a433 1
        char *bufpos=buf;
d435 1
a435 65
        int devctl = musb_base->devctl;
	int isbdevice = devctl & DEVCTL_BDEVICE;
	int ishost = devctl & DEVCTL_HOSTMODE;
        bufpos += sprintf(bufpos,"DEVCTL: %02x (%c %s)\n",devctl,(isbdevice?'B':'A'),(ishost?"Host":"Peripheral"));
        bufpos += sprintf(bufpos,"Port status: %04x change %04x (Speed: %s)\n\n",musb_soft.port_status&0xffff,musb_soft.port_status>>16,(musb_soft.port_status&UPS_HIGH_SPEED?"High":(musb_soft.port_status&UPS_LOW_SPEED?"Low":"Full")));
        bufpos += sprintf(bufpos,"Peripheral mode:\nState %d\nAddress %02x%s\n\n",musb_soft.peri_ep0_state,musb_soft.peri_addr,(musb_soft.peri_addr_pending?" (pending)":""));
        bufpos += sprintf(bufpos,"Host mode:\nEP TX pipe      State RX pipe      State\n");
        for(int i=0;i<16;i++)
        {
        	bufpos += sprintf(bufpos,"%2d ",i);
        	char *type;
        	if(musb_soft.host_tx[i].pipe)
        	{
        		switch(musb_soft.host_tx[i].pipe->pipe.endpoint->edesc->bmAttributes & UE_XFERTYPE)
        		{
        		case UE_CONTROL:
        			type = "CTL";
        			break;
        		case UE_BULK:
        			type = "BLK";
        			break;
        		case UE_INTERRUPT:
        			type = "INT";
        			break;
        		case UE_ISOCHRONOUS:
        			type = "ISO";
        			break;
        		default:
        			type = "???";
        			break;
        		}
        	}
        	else if(musb_soft.host_tx[i].state)
        		type = "ABT";
        	else
        		type = "---";
        	bufpos += sprintf(bufpos,"%08x %s %d     ",musb_soft.host_tx[i].pipe,type,musb_soft.host_tx[i].state);
        	if(musb_soft.host_rx[i].pipe)
        	{
        		switch(musb_soft.host_rx[i].pipe->pipe.endpoint->edesc->bmAttributes & UE_XFERTYPE)
        		{
        		case UE_CONTROL:
        			type = "CTL";
        			break;
        		case UE_BULK:
        			type = "BLK";
        			break;
        		case UE_INTERRUPT:
        			type = "INT";
        			break;
        		case UE_ISOCHRONOUS:
        			type = "ISO";
        			break;
        		default:
        			type = "???";
        			break;
        		}
        	}
        	else if(musb_soft.host_rx[i].state)
        		type = "ABT";
        	else
        		type = "---";
        	bufpos += sprintf(bufpos,"%08x %s %d\n",musb_soft.host_rx[i].pipe,type,musb_soft.host_rx[i].state);
        }
        /* Finished! */
d441 1
a441 1
   }
a446 1
    NOTUSED(arg_string);
d455 1
a455 3
    /* todo - Something in printf seems to be enabling interrupts; for now prevent recusrion by masking the IRQ during musb_intr() */

//    _swix(OS_Hardware, _IN(0)|_INR(8,9), '#', 0, EntryNo_HAL_DebugTX);
d462 3
d470 1
a470 2
usbd_status
usb_insert_transfer(usbd_xfer_handle xfer)
d477 1
a477 2
void
usb_transfer_complete(usbd_xfer_handle xfer)
d482 1
a482 1
void riscos_irqclear()
d487 1
a487 2
_kernel_oserror*
_riscos_abort_pipe (_kernel_swi_regs * r, void* pw, void* v)
d489 2
d498 7
a504 1
    callx_add_callback (_riscos_abort_pipe, v);
@


1.4
log
@Update to use new bus registration API introduced in USBDriver 0.49
Detail:
  c/cmodule - Now uses USBDriver_Version to check USBDriver version number, and passes API version to USBDriver when calling USBDriver_RegisterBus to allow USBDriver to perform its side of the checks
Admin:
  Tested on rev C2 beagleboard


Version 0.07. Tagged as 'MUSBDriver-0_07'
@
text
@d173 1
a173 1
    musbdebug = 11;
d561 12
@


1.3
log
@Fix MUSBDriver so compiled module has correct date + version, fix assembler veneer setup code to sync the caches properly
Detail:
  cmhg/modhead - Now corrected so that the module is built with the correct version number & date, taken from the VersionNum file
  c/cmodule, s/call_veneer - init_veneer and build_veneer fixed to call OS_SyncrhoniseCodeAreas after creating the veneers
Admin:
  Tested on rev C2 beagleboard


Version 0.03. Tagged as 'MUSBDriver-0_03'
@
text
@d71 1
a71 1
struct device * usb_soft;
d74 16
d133 9
a141 4

    _swix (USBDriver_RegisterBus, _IN(0)|_OUT(0),
            &musb_soft, &usb_soft);
    dprintf (("", "Registering with USB driver-done\n"));
d356 10
a365 11




             dprintf (("", "Registering with USB driver from svcecall\n"));
                    _swix (USBDriver_RegisterBus, _IN(0)|_OUT(0),
                             &musb_soft, &usb_soft);
             dprintf (("", "Registering with USB driver from svcecall-done\n"));



@


1.2
log
@Initial version of USB host support for MUSBDriver
Detail:
  c/tps, h/tps, Makefile - Some rather rough code to wake up the MUSB controller and cause it to enter host mode when the OTG cable is detected. Needs some tidying up and improvement to deal with any other drivers that need to interact with the TWL/TPS.
  c/musb, h/musb - Initial host-mode support for MUSBDriver. Control, bulk & interrupt endpoints are implemented. Isochronous is not. Lots of bits need improving, but it's stable enough for owners of rev B beagleboards to make use of.
  cmhg/modhead, c/cmodule - Improved debugging code
Admin:
  Tested on rev C2 beagleboard


Version 0.02. Tagged as 'MUSBDriver-0_02'
@
text
@d100 3
@


1.1
log
@Add initial version of MUSBDriver module

- Interfaces with main USBDriver module and implements software part of root hub
- Interfaces with Mentor MUSBMHDRC USB OTG controller, providing basic peripheral-mode support
@
text
@d48 1
d68 1
a68 1
volatile musb_regs* musb_base;
d144 1
d149 1
d204 3
d307 2
d372 1
d392 4
a395 1
	printf("OTG_FORCESTDBY: %08x\n",musb_base->otg_forcestdby);       
d413 77
@


head	1.15;
access;
symbols
	MUSBDriver-0_35:1.15
	MUSBDriver-0_34:1.15
	MUSBDriver-0_33:1.15
	MUSBDriver-0_32:1.15
	MUSBDriver-0_31:1.14
	MUSBDriver-0_30:1.14
	MUSBDriver-0_29:1.14
	MUSBDriver-0_28:1.14
	MUSBDriver-0_27:1.13
	MUSBDriver-0_26:1.13
	MUSBDriver-0_25:1.13
	MUSBDriver-0_24:1.13
	MUSBDriver-0_23:1.13
	MUSBDriver-0_22:1.12
	MUSBDriver-0_21:1.11
	MUSBDriver-0_20:1.10
	MUSBDriver-0_19:1.10
	MUSBDriver-0_18:1.10
	MUSBDriver-0_17:1.10
	MUSBDriver-0_16:1.10
	MUSBDriver-0_15:1.10
	MUSBDriver-0_14:1.9
	MUSBDriver-0_13:1.9
	MUSBDriver-0_12:1.8
	MUSBDriver-0_11:1.7
	MUSBDriver-0_10:1.6
	MUSBDriver-0_09:1.6
	MUSBDriver-0_08:1.6
	MUSBDriver-0_07:1.5
	MUSBDriver-0_06:1.5
	MUSBDriver-0_05:1.4
	MUSBDriver-0_04:1.3
	MUSBDriver-0_03:1.2
	MUSBDriver-0_02:1.2;
locks; strict;
comment	@# @;


1.15
date	2017.09.23.09.01.54;	author rool;	state Exp;
branches;
next	1.14;
commitid	6rXidvVzktBEFi8A;

1.14
date	2016.12.17.10.40.24;	author rool;	state Exp;
branches;
next	1.13;
commitid	RYu6RVCw6APddkyz;

1.13
date	2015.08.21.20.09.38;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	AR6BOUEtVfUgVayy;

1.12
date	2014.06.01.13.58.15;	author jlee;	state Exp;
branches;
next	1.11;
commitid	8OjtcW0RnvIJcPCx;

1.11
date	2014.05.27.19.19.39;	author jlee;	state Exp;
branches;
next	1.10;
commitid	WoQoyE1NXx3X8dCx;

1.10
date	2011.08.22.22.43.50;	author jlee;	state Exp;
branches;
next	1.9;
commitid	XF0NP2x7l03QHywv;

1.9
date	2011.07.11.20.15.55;	author jlee;	state Exp;
branches;
next	1.8;
commitid	Bnjdl5h4idKMe9rv;

1.8
date	2011.05.22.20.32.28;	author jlee;	state Exp;
branches;
next	1.7;
commitid	ojDCXEOv6C57WIkv;

1.7
date	2011.04.11.23.25.35;	author jlee;	state Exp;
branches;
next	1.6;
commitid	6pcEoJPvdLzddtfv;

1.6
date	2010.08.14.21.41.51;	author jlee;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.28.21.12.38;	author jlee;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.20.22.25.46;	author jlee;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.19.23.18.30;	author jlee;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.20.51.04;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2009.07.02.20.15.46;	author jlee;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Remove HAL library variant
Detail:
  Simplify the makefile by not building a HAL variant.
  cmodule.c: 2 fewer warnings
  musb.c/musb_debug.c/musb_peri.c/musb_root.c/musb_util.c/tps.c: remove usbhal.h include
  cmodule.h/musb_usb.c: USBHAL is no longer defined
  CMHG file changed to make Makefile
Admin:
  Submission for USB bounty.

Version 0.32. Tagged as 'MUSBDriver-0_32'
@
text
@/*
 * Copyright (c) 2004, 2009 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net), Charles M. Hannum, and
 * Jeffrey Lee (me@@phlamethrower.co.uk)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "modhead.h"
#include "swis.h"
#include "callx/callx.h"
#include <limits.h>
#include <machine/bus.h>

#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/types.h>
#include <sys/systm.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>

#include "Global/RISCOS.h"
#include "Global/HALEntries.h"
#include "cmodule.h"

/* Have to avoid including stdio as there's a clash with the BSD stuff */
#define __stdio_h

#include "musb.h"
#include "musb_util.h"
#include "musb_usb.h"

extern void musb_ep0_peri(musb_softc_t *sc);
static void musb_mp_schedule(struct musb_pipe *epipe);
static void musb_mp_stop(struct musb_pipe *epipe);
static void musb_pipe_run(struct musb_pipe *epipe,int ep);
static void musb_mp_completed(musb_softc_t *sc,struct musb_xfer *ex,int ep);

/*

			MISC FUNCTIONS

*/

static void musb_timeout(void *addr)
{
	DPRINTFN(10,("musb_timeout: %p\n",addr));
	DASSERT(_kernel_irqs_disabled());
	riscos_abort_pipe(addr);
}

static void musb_pcd(usbd_xfer_handle xfer)
{
	usbd_pipe_handle pipe;
	u_char *p;
	if(xfer == NULL)
		return;
	pipe = xfer->pipe;
	p = KERNADDR(&xfer->dmabuf,0);
	memset(p,0,xfer->length);
	*p = 2; /* we only have one port */
	DPRINTF(("musb_pcd: Notfifying USB driver of port change\n"));
	xfer->actlen = xfer->length;
	xfer->status = USBD_NORMAL_COMPLETION;
	usb_transfer_complete(xfer);
}

void musb_abort_xfer(usbd_xfer_handle xfer,usbd_status status)
{
	/* Interrupts should already be disabled, otherwise it's unpredictable whether this function will work or not */
	DASSERT(_kernel_irqs_disabled());
	struct musb_pipe *epipe = (struct musb_pipe *) xfer->pipe;
	DPRINTFN(10,("musb_abort_xfer: xfer %p status %d\n",xfer,status));
	DASSERT(xfer);

	if(xfer == SIMPLEQ_FIRST(&xfer->pipe->queue))
	{
		/* Stop the pipe */
		musb_mp_stop(epipe);
	}
	else
	{
		/* Does this xfer actually exist? */
#ifdef MUSB_DEBUG
		DASSERT(SIMPLEQ_FIRST(&xfer->pipe->queue));
		bool in = false;
		usbd_xfer_handle xfer2;
		SIMPLEQ_FOREACH(xfer2,&epipe->pipe.queue,next)
		{
			if(xfer2 == xfer)
			{
				in = true;
				break;
			}
		}
		DASSERT(in);
#endif
	}

	/* Set status */
	xfer->status = status;

	/* Cancel any timeout */
	callout_stop(&(xfer->timeout_handle));
	/* And cancel the associated callback */
	riscos_cancel_abort_pipe(xfer);

	/* Tell USBDriver */
	usb_transfer_complete(xfer);
}

/*

			USBDRIVER INTERFACE

*/

usbd_status musb_device_transfer(usbd_xfer_handle xfer)
{
	usbd_status err;

	DPRINTFN(10,("musb_device_transfer: xfer=%p pipe=%p\n",xfer,xfer->pipe));

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* If we're still here, the pipe shouldn't be running */
	/* TODO - drop musb_pipe.running and just use usbd_pipe.running? */
	DASSERT(!((struct musb_pipe *)xfer->pipe)->running);

	/* Pipe isn't running, start first xfer */
	return (musb_device_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}


usbd_status musb_device_start(usbd_xfer_handle xfer)
{
	struct musb_xfer *ex = (struct musb_xfer *) xfer;
	struct musb_pipe *epipe = (struct musb_pipe *)xfer->pipe;
	usb_endpoint_descriptor_t *ed = epipe->pipe.endpoint->edesc;

	DPRINTFN(10,("musb_device_start: xfer=%p pipe=%p\n",xfer,xfer->pipe));

	/* Pipe shouldn't be running */
	DASSERT(!epipe->running);
	DASSERT(xfer == SIMPLEQ_FIRST(&xfer->pipe->queue));

	/* Prepare this pipe for the new xfer */
	if((ed->bmAttributes & UE_XFERTYPE) == UE_CONTROL)
	{
		epipe->remain = UGETW(ex->xfer.request.wLength);
	}
	else
	{
		epipe->null_packet = (ex->xfer.flags & USBD_FORCE_SHORT_XFER) && !(ex->xfer.length % UGETW(ed->wMaxPacketSize));
		epipe->remain = ex->xfer.length;
	}
	epipe->buf = KERNADDR(&ex->xfer.dmabuf,0);

	/* Schedule the pipe with the multiplexer */
	musb_mp_schedule(epipe);

	return USBD_IN_PROGRESS;
}


void musb_device_abort(usbd_xfer_handle xfer)
{
	DPRINTF(("musb_device_abort: xfer=%p\n",xfer));
	musb_abort_xfer(xfer,USBD_CANCELLED);
}


void musb_device_close(usbd_pipe_handle pipe)
{
	DPRINTF(("musb_device_close: pipe=%p\n",pipe));

	/* Pipe shouldn't be running */
	DASSERT(!((struct musb_pipe *)pipe)->running);
	NOTUSED(pipe);
}


void musb_device_clear_toggle(usbd_pipe_handle pipe)
{
	struct musb_pipe *epipe = (struct musb_pipe *)pipe;

	DPRINTF(("musb_device_clear_toggle: epipe=%p\n",
		 epipe));

	epipe->toggle = false;
}


void musb_device_done(usbd_xfer_handle xfer)
{
	DPRINTFN(10,("musb_device_done: xfer=%p, length=%d\n", xfer,xfer->actlen));
	/* This pipe is no longer running */
	musb_mp_stop((struct musb_pipe *) xfer->pipe);
	/* If it's a repeating one, we put it back on the list */
	if(xfer->pipe->repeat)
		musb_device_start(xfer);
}

/*

			MULTIPLEXER CODE

*/

void musb_mp_schedule(struct musb_pipe *epipe)
{
	struct musb_multiplexer *mp = epipe->multiplexer;
	DPRINTFN(10,("musb_mp_schedule: mp=%p pipe=%p\n",mp,epipe));
	DASSERT(mp);
	DASSERT(!epipe->running);
	/* IRQs off for atomic mp update */
	int s = splusb();
	DASSERT(!SIMPLEQ_FIRST(&mp->waitq) || !mp->idle_mask); /* If idle mask is nonzero, wait queue must be empty */
	epipe->running = true;
	if(!mp->idle_mask)
	{
		/* Queue it */
		SIMPLEQ_INSERT_TAIL(&mp->waitq,epipe,multiq);
		splx(s);
		DPRINTFN(10,("-> queued\n"));
	}
	else
	{
		/* Run it */
		int ep;
		u32 mask = mp->idle_mask;
		__asm
		{
		CLZ	ep,mask;
		}
		ep = 31-ep;
		mp->idle_mask = mask-(1<<ep);
		splx(s);
		musb_softc_t *sc = (musb_softc_t *)epipe->pipe.device->bus;
		DASSERT(!(mp->tx?sc->host_tx[ep]:sc->host_rx[ep]));
		NOTUSED(sc);
		DPRINTFN(10,("-> assigned ep %d\n",ep));
		musb_pipe_run(epipe,ep);
	}
}

void musb_mp_stop(struct musb_pipe *epipe)
{
	struct musb_multiplexer *mp = epipe->multiplexer;
	musb_softc_t *sc = (musb_softc_t *)epipe->pipe.device->bus;
	volatile musb_regs *musb_base = sc->musb_base;
	DPRINTFN(10,("musb_mp_stop: mp=%p pipe=%p\n",mp,epipe));
	DASSERT(mp);
	/* Make sure this pipe isn't running */
	if(!epipe->running)
		return;
	int s = splusb();
	epipe->running = false;
	int ep = epipe->ep;
	if(ep == -1)
	{
		/* Not active; just unqueue it */
		DASSERT(SIMPLEQ_FIRST(&mp->waitq));
		SIMPLEQ_REMOVE(&mp->waitq,epipe,musb_pipe,multiq);
		splx(s);
		DPRINTFN(10,("-> unqeued\n"));
	}
	else
	{
		/* Active; teardown the endpoint */
		DASSERT((mp->tx?sc->host_tx[ep]:sc->host_rx[ep]) == epipe);
		if(!ep)
		{
			DPRINTFN(10,("-> teardown ep0 state %d\n",sc->host_ep0_state));
			/* Mark ep0 state machine as idle */
			sc->host_ep0_state = HOST_EP0_STATE_IDLE;
			/* Also try a teardown procedure */
			musb_base->csr.host_ep0.host_csr0 = (musb_base->csr.host_ep0.host_csr0 | HOST_CSR0_FLUSHFIFO) & ~HOST_CSR0_REQPKT;
			WAITON(musb_base->csr.host_ep0.host_csr0 & (HOST_CSR0_RXPKTRDY | HOST_CSR0_TXPKTRDY));
			musb_base->csr.host_ep0.host_csr0 &= ~(HOST_CSR0_FLUSHFIFO | HOST_CSR0_SETUPPKT);
			sc->host_tx[0] = NULL;
		}
		else if(mp->tx)
		{
			DPRINTFN(10,("-> teardown tx ep%d\n",ep));
			musb_base->csr.host_ep[ep].host_txcsr = (musb_base->csr.host_ep[ep].host_txcsr | HOST_TXCSR_FLUSHFIFO) & ~HOST_TXCSR_TXPKTRDY;
			WAITON(musb_base->csr.host_ep[ep].host_txcsr & HOST_TXCSR_FIFONOTEMPTY);
			musb_base->csr.host_ep[ep].host_txcsr &= ~HOST_TXCSR_FLUSHFIFO;
			sc->host_tx[ep] = NULL;
		}
		else
		{
			DPRINTFN(10,("-> teardown rx ep%d\n",ep));
			musb_base->csr.host_ep[ep].host_rxcsr = (musb_base->csr.host_ep[ep].host_rxcsr | HOST_RXCSR_FLUSHFIFO) & ~HOST_RXCSR_REQPKT;
			WAITON(musb_base->csr.host_ep[ep].host_rxcsr & HOST_RXCSR_RXPKTRDY);
			musb_base->csr.host_ep[ep].host_rxcsr &= ~HOST_RXCSR_FLUSHFIFO;
			sc->host_rx[ep] = NULL;
		}
		
		epipe->ep = -1;
		/* Run next pipe if necessary */
		struct musb_pipe *next = SIMPLEQ_FIRST(&mp->waitq);
		if(next)
		{
			SIMPLEQ_REMOVE_HEAD(&mp->waitq,multiq);
			splx(s);
			DPRINTFN(10,("-> start next pipe %p\n",next));
			musb_pipe_run(next,ep);
		}
		else
		{
			mp->idle_mask |= 1<<ep;
			splx(s);
		}
	}
}

void musb_pipe_run(struct musb_pipe *epipe,int ep)
{
	struct musb_multiplexer *mp = epipe->multiplexer;
	struct usbd_device *dev = epipe->pipe.device;
	musb_softc_t *sc = (musb_softc_t *)dev->bus;
	volatile musb_regs *musb_base = sc->musb_base;
	struct musb_xfer *ex = (struct musb_xfer *) SIMPLEQ_FIRST(&epipe->pipe.queue);
	usb_endpoint_descriptor_t *ed = epipe->pipe.endpoint->edesc;
	DPRINTFN(10,("musb_pipe_run: mp=%p pipe=%p xfer=%p ep=%d tx=%d\n",mp,epipe,ex,ep,mp->tx));
	/* Should be running */
	DASSERT(epipe->running);
	DASSERT(ex);
	epipe->ep = ep;
	SIMPLEQ_NEXT(epipe,multiq) = NULL;
	/* Program the address registers */
	int addr = dev->address & TXFUNCADDR_FUNCADDR;
	int hubaddr = 0;
	int hubport = 0;
	struct usbd_port *hsport = dev->myhsport;
	if(hsport && (dev->speed != USB_SPEED_HIGH))
	{
		hubaddr = hsport->parent->address & TXHUBADDR_HUBADDR;
		hubport = hsport->portno & TXHUBPORT_HUBPORT;
		if(hsport->tt && hsport->parent->ddesc.bDeviceProtocol == UDPROTO_HSHUBMTT)
			hubaddr |= TXHUBADDR_MULT_TRANS;
	}
	if(mp->tx)
	{
		musb_base->ep_host[ep].txfuncaddr = addr;
		musb_base->ep_host[ep].txhubaddr = hubaddr;
		musb_base->ep_host[ep].txhubport = hubport;
	}
	else
	{
		musb_base->ep_host[ep].rxfuncaddr = addr;
		musb_base->ep_host[ep].rxhubaddr = hubaddr;
		musb_base->ep_host[ep].rxhubport = hubport;
	}
	/* Other endpoint registers */
	/* HOST_TYPE0/HOST_TXTYPE/HOST_RXTYPE */
	int i;
	i = UE_GET_ADDR(ed->bEndpointAddress) & HOST_TXTYPE_TENDPN;
	switch(dev->speed)
	{
	case USB_SPEED_LOW: i |= HOST_TXTYPE_SPEED_LOW; break;
	case USB_SPEED_FULL: i |= HOST_TXTYPE_SPEED_FULL; break;
	case USB_SPEED_HIGH: i |= HOST_TXTYPE_SPEED_HIGH; break;
	}
	int s;
	if(!ep)
	{
		sc->host_ep0_state = HOST_EP0_STATE_SETUP;
		/* HOST_TYPE0 */
		musb_base->csr.host_ep0.host_type0 = i;
		/* Flush any stale data */
		musb_base->csr.host_ep0.host_csr0 |= HOST_CSR0_FLUSHFIFO;
		WAITON(musb_base->csr.host_ep0.host_csr0 & (HOST_CSR0_RXPKTRDY | HOST_CSR0_TXPKTRDY));
		musb_base->csr.host_ep0.host_csr0 &= ~HOST_CSR0_FLUSHFIFO;
		/* Load setup packet */
		musb_fifowrite(musb_base,0,&ex->xfer.request,8);
		/* Start endpoint */
		s = splusb();
		sc->host_tx[ep] = epipe;
		musb_base->csr.host_ep0.host_csr0 = HOST_CSR0_SETUPPKT | HOST_CSR0_TXPKTRDY;
	}
	else if(mp->tx)
	{
		/* HOST_TXTYPE */
		if((ed->bmAttributes & UE_XFERTYPE) == UE_INTERRUPT)
			i |= HOST_TXTYPE_PROT_INTERRUPT;
		else
			i |= HOST_TXTYPE_PROT_BULK;
		musb_base->csr.host_ep[ep].host_txtype = i;
		DPRINTFN(15,("musb_pipe_run: TXTYPE %02x wMaxPacketSize %d interval %d xfer.length %d toggle %d\n",i,UGETW(ed->wMaxPacketSize),ed->bInterval,ex->xfer.length,epipe->toggle));
		/* TXMAXP */
		musb_base->csr.host_ep[ep].txmaxp = UGETW(ed->wMaxPacketSize) & TXMAXP_MAXPAYLOAD; /* TODO - M field */
		/* HOST_TXINTERVAL */
#ifdef MUSB_USE_NAKTIMEOUT
		musb_base->csr.host_ep[ep].host_txinterval = ed->bInterval;
#else
		musb_base->csr.host_ep[ep].host_txinterval = 0;
#endif
		/* Flush FIFO */
		if(musb_base->csr.host_ep[ep].host_txcsr & HOST_TXCSR_TXPKTRDY)
		{
			musb_base->csr.host_ep[ep].host_txcsr |= HOST_TXCSR_FLUSHFIFO;
			WAITON(musb_base->csr.host_ep[ep].host_txcsr & HOST_TXCSR_TXPKTRDY);
		}
		/* HOST_TXCSR */
		musb_base->csr.host_ep[ep].host_txcsr = (epipe->toggle?HOST_TXCSR_DATATOG:0) | HOST_TXCSR_DATATOGWREN;
		/* Load first packet */
		int count = min(epipe->remain,UGETW(ed->wMaxPacketSize));
		epipe->remain -= count;
		epipe->buf = musb_fifowrite(musb_base,ep,epipe->buf,count);
		epipe->last_write = count;
		epipe->toggle = !epipe->toggle;
		/* Start endpoint */
		s = splusb();
		sc->host_tx[ep] = epipe;
		musb_base->csr.host_ep[ep].host_txcsr = HOST_TXCSR_TXPKTRDY;
	}
	else
	{
		/* HOST_RXTYPE */
		if((ed->bmAttributes & UE_XFERTYPE) == UE_INTERRUPT)
			i |= HOST_RXTYPE_PROT_INTERRUPT;
		else
			i |= HOST_RXTYPE_PROT_BULK;
		musb_base->csr.host_ep[ep].host_rxtype = i;
		DPRINTFN(15,("musb_pipe_run: RXTYPE %02x wMaxPacketSize %d interval %d xfer.length %d toggle %d\n",i,UGETW(ed->wMaxPacketSize),ed->bInterval,ex->xfer.length,epipe->toggle));
		/* RXMAXP */
		musb_base->csr.host_ep[ep].rxmaxp = UGETW(ed->wMaxPacketSize) & RXMAXP_MAXPAYLOAD; /* TODO - set 'M' according to the bit on page 271 of the USB spec */
		/* HOST_RXINTERVAL */
#ifdef MUSB_USE_NAKTIMEOUT
		musb_base->csr.host_ep[ep].host_rxinterval = ed->bInterval;
#else
		musb_base->csr.host_ep[ep].host_rxinterval = 0;
#endif
		/* Flush FIFO */
		if(musb_base->csr.host_ep[ep].host_rxcsr & HOST_RXCSR_RXPKTRDY)
		{
			musb_base->csr.host_ep[ep].host_rxcsr |= HOST_RXCSR_FLUSHFIFO;
			WAITON(musb_base->csr.host_ep[ep].host_rxcsr & HOST_RXCSR_RXPKTRDY);
		}
		/* HOST_RXCSR */
		musb_base->csr.host_ep[ep].host_rxcsr = (epipe->toggle?HOST_RXCSR_DATATOG:0) | HOST_RXCSR_DATATOGWREN; 
		/* Start endpoint */
		s = splusb();
		sc->host_rx[ep] = epipe;
		musb_base->csr.host_ep[ep].host_rxcsr = HOST_RXCSR_REQPKT;
	}
	/* Register timeout */
	if(ex->xfer.timeout && !sc->sc_bus.use_polling) {
		DPRINTFN(10,("-> set timeout %d on %x\n",ex->xfer.timeout,ex));
		callout_reset(&(ex->xfer.timeout_handle), (MS_TO_TICKS(ex->xfer.timeout)), (musb_timeout), (ex));
	}
	splx(s);
}

void musb_mp_completed(musb_softc_t *sc,struct musb_xfer *ex,int ep)
{
	int s = splusb();
	DASSERT(ex);
	struct musb_pipe *epipe = (struct musb_pipe *) ex->xfer.pipe;
	DASSERT(epipe && epipe->running);
	DASSERT(epipe->ep == ep);
	struct musb_multiplexer *mp = epipe->multiplexer;
	DPRINTFN(10,("musb_mp_completed: xfer %p is complete on ep %d pipe %p mp %p\n",ex,ep,epipe,mp));

	/* Cancel any timeout */
	callout_stop(&(ex->xfer.timeout_handle));
	/* And cancel the associated callback */
	riscos_cancel_abort_pipe(ex);

	/* Stop pipe */
	epipe->running = false;
	epipe->ep = -1;
	if(mp->tx)
		sc->host_tx[ep] = NULL;
	else
		sc->host_rx[ep] = NULL;

	/* Start next xfer for this multiplexer */
	struct musb_pipe *next = SIMPLEQ_FIRST(&mp->waitq);
	if(next)
	{
		DPRINTFN(10,("-> start next pipe %p\n",next));
		DASSERT(!mp->idle_mask);
		SIMPLEQ_REMOVE_HEAD(&mp->waitq,multiq);
		splx(s);
		musb_pipe_run(next,ep);
	}
	else
	{
		mp->idle_mask |= 1<<ep;
		splx(s);
	}

	/* Tell USBDriver */
	usb_transfer_complete(&ex->xfer);
}

/*

			HOST INTERRUPT ROUTINES

*/

#define CSR_SET(X) csro = csro | (X)
#define CSR_CLEAR(X) csro = csro & ~(X)

static void musb_ep0_host(musb_softc_t *sc)
{
	/* Process ep0 related interrupt when acting as a host */
	volatile musb_regs *musb_base = sc->musb_base;
	int csr = musb_base->csr.host_ep0.host_csr0;
	int updated=0;
	int csro=csr;
	int complete=0;
	struct musb_pipe *epipe = sc->host_tx[0];
	struct musb_xfer *ex = (struct musb_xfer *) (epipe?SIMPLEQ_FIRST(&epipe->pipe.queue):0);
	DPRINTFN(15,("musb_ep0_host: csr %04x count0 %2x state %d pipe %08x\n",csr,musb_base->csr.host_ep0.count0,sc->host_ep0_state,epipe));
	if(!ex)
	{
		DPRINTFN(10,("musb_ep0_host: Panic! interrupt received while no pipe/xfer assigned\n"));
		switch(sc->host_ep0_state)
		{
		case HOST_EP0_STATE_SETUP:
		case HOST_EP0_STATE_OUT_DATA:
		case HOST_EP0_STATE_OUT_STATUS:
			/* Abort by flushing the FIFO */
			csro = csr | HOST_CSR0_FLUSHFIFO;
			/* Wait for completion (should complete immediately for IN_DATA, etc.) */
			musb_base->csr.host_ep0.host_csr0 = csro;
			WAITON(musb_base->csr.host_ep0.host_csr0 & HOST_CSR0_TXPKTRDY);
			csro = 0;
			updated=1;
			break;
		default:
		case HOST_EP0_STATE_IN_DATA:
		case HOST_EP0_STATE_IN_STATUS:
			/* Abort by clearing REQPKT (and STATUSPKT for IN_STATUS) */
			csro = 0;
			musb_base->csr.host_ep0.host_csr0 = csro;
			WAITON(musb_base->csr.host_ep0.host_csr0 & (HOST_CSR0_REQPKT | HOST_CSR0_STATUSPKT));
			updated=1;
			break;
		}
		updated=1;
		goto end;
	}
	/* NAK_TIMEOUT just needs us to clear the bit and try again. We could use this for yielding to other transfers, but FIFO flushing seems to be broken? */
	if(csr & HOST_CSR0_NAK_TIMEOUT)
	{
		csro &= ~HOST_CSR0_NAK_TIMEOUT;
		updated = 1;
		goto end;
	}
	/* RXSTALL and ERROR are terminal error conditons that are handled the same for each host_ep[0].state */
	if(csr & (HOST_CSR0_RXSTALL | HOST_CSR0_ERROR))
	{
		if(csr & HOST_CSR0_RXSTALL)
			ex->xfer.status = USBD_STALLED;
		else /* HOST_CSR0_ERROR */
			ex->xfer.status = USBD_IOERROR;

		/* Ensure we correctly report any partial transfer */
		ex->xfer.actlen = ex->xfer.length-epipe->remain;

		complete=1;
		csro = 0;
		updated=1;
		goto end;
	}
	/* Else whatever we did completed successfully
	   So work out what to do next */
	switch(sc->host_ep0_state)
	{
	case HOST_EP0_STATE_SETUP:
	{
		/* Setup phase completed; move to next */
		if(UGETW(ex->xfer.request.wLength))
		{
			if(ex->xfer.request.bmRequestType & UT_READ)
			{
				/* Transition to IN_DATA */
				sc->host_ep0_state = HOST_EP0_STATE_IN_DATA;
				/* Fall through... */
				goto state_in_data;
			}
			else
			{
				/* Transition to OUT_DATA */
				sc->host_ep0_state = HOST_EP0_STATE_OUT_DATA;
				/* Fall through... */
				goto state_out_data;
			}
		}
		else
		{
			/* Transition to IN_STATUS */
			sc->host_ep0_state = HOST_EP0_STATE_IN_STATUS;
			CSR_SET(HOST_CSR0_STATUSPKT | HOST_CSR0_REQPKT);
			updated=1;
			goto end;
		}
	}
	case HOST_EP0_STATE_IN_DATA: state_in_data:
	{
		/* If RXPKTRDY is set, we have a packet to read */
		if(csr & HOST_CSR0_RXPKTRDY)
		{
			int count = musb_base->csr.host_ep0.count0 & COUNT0_EP0RXCOUNT;
			if(count > epipe->remain)
			{
				DPRINTFN(10,("musb_ep0_host: Panic! Device sent too much data\n"));
				ex->xfer.status = USBD_IOERROR;
				/* Flush FIFO */
				musb_base->csr.host_ep0.host_csr0 = csro | HOST_CSR0_FLUSHFIFO;
				WAITON(musb_base->csr.host_ep0.host_csr0 & HOST_CSR0_RXPKTRDY);
				csro = musb_base->csr.host_ep0.host_csr0;
				updated=0;
				complete=1;
				goto end;
			}
			else
			{
				/* Grab the data */
				epipe->remain -= count;
				epipe->buf = musb_fiforead(musb_base,0,epipe->buf,count);
				CSR_CLEAR(HOST_CSR0_RXPKTRDY);
				updated=1;

				/* If it was a short packet (not max packet size) then we're done. */
				usb_endpoint_descriptor_t *ed = epipe->pipe.endpoint->edesc;
				if(count != UGETW(ed->wMaxPacketSize))
				{
					/* Transition to OUT_STATUS */
					sc->host_ep0_state = HOST_EP0_STATE_OUT_STATUS;
					CSR_SET(HOST_CSR0_STATUSPKT | HOST_CSR0_TXPKTRDY);
					updated=1;
					goto end;
				}
			}
		}
		/* Do we need more data? */
		if(epipe->remain)
		{
			CSR_SET(HOST_CSR0_REQPKT);
			updated=1;
			goto end;
		}
		else
		{
			/* Transition to OUT_STATUS */
			sc->host_ep0_state = HOST_EP0_STATE_OUT_STATUS;
			CSR_SET(HOST_CSR0_STATUSPKT | HOST_CSR0_TXPKTRDY);
			updated=1;
			goto end;
		}
	}
	case HOST_EP0_STATE_OUT_DATA: state_out_data:
	{
		/* No error flags were set, so we should send data */
		if(epipe->remain)
		{
			int count = min(epipe->remain,HOST_EP0_MAXP);
			epipe->remain -= count;
			epipe->buf = musb_fifowrite(musb_base,0,epipe->buf,count);
			epipe->last_write = count;
			CSR_SET(HOST_CSR0_TXPKTRDY);
			updated=1;
			goto end;
		}
		else
		{
			/* Transition to IN_STATUS */
			sc->host_ep0_state = HOST_EP0_STATE_IN_STATUS;
			CSR_SET(HOST_CSR0_STATUSPKT | HOST_CSR0_REQPKT);
			updated=1;
			goto end;
		}
	}
	case HOST_EP0_STATE_IN_STATUS:
	{
		/* If RXPKTRDY set, clear it
		   And irregardless of RXPKTRDY, if we've reached this point the transfer was successful? */
		if(csr & HOST_CSR0_RXPKTRDY)
		{
			CSR_CLEAR(HOST_CSR0_RXPKTRDY);
			updated=1;
		}
		/* Also clear STATUSPKT so we don't request another? */
		if(updated && (csro & HOST_CSR0_STATUSPKT))
			CSR_CLEAR(HOST_CSR0_STATUSPKT);
		/* Fall through... */
	}
	case HOST_EP0_STATE_OUT_STATUS:
	{
		/* We're good! */
		ex->xfer.status = USBD_NORMAL_COMPLETION;
		ex->xfer.actlen = ex->xfer.length-epipe->remain;
		complete=1;
		goto end;
	}
	default:
	case HOST_EP0_STATE_IDLE:
	{
		DPRINTFN(10,("musb_ep0_host: Panic! interrupt received while in state %d\n",sc->host_ep0_state));
		/* Attempt to flush FIFO */
		csro = csr | HOST_CSR0_FLUSHFIFO;
		musb_base->csr.host_ep0.host_csr0 = csro;
		WAITON(musb_base->csr.host_ep0.host_csr0 & HOST_CSR0_TXPKTRDY);
		csro = 0;
		updated=1;
		sc->host_ep0_state = HOST_EP0_STATE_IDLE;
		goto end;
	}
	}
end:
	DPRINTFN(15,("musb_ep0_host: new csr %04x(%d) new state %d\n",csro,updated,(complete?HOST_EP0_STATE_IDLE:sc->host_ep0_state)));
	if(updated)
		musb_base->csr.host_ep0.host_csr0 = csro;
	if(complete)
	{
		sc->host_ep0_state = HOST_EP0_STATE_IDLE;
		musb_mp_completed(sc,ex,0);
	}
}

static void musb_receive_host(musb_softc_t *sc,int ep)
{
	/* Process endpoint receive interrupt when acting as a host */
	volatile musb_regs *musb_base = sc->musb_base;
	int csr = musb_base->csr.host_ep[ep].host_rxcsr;
	int updated=0;
	int csro=csr;
	int complete=0;
	struct musb_pipe *epipe = sc->host_rx[ep];
	struct musb_xfer *ex = (struct musb_xfer *) (epipe?SIMPLEQ_FIRST(&epipe->pipe.queue):0);
	DPRINTFN(15,("musb_receive_host: ep %d csr %04x rxcount %2x pipe %08x\n",ep,csr,musb_base->csr.host_ep[ep].rxcount,epipe));
	/* Pretty much the same error handling as for control transfers... */
	if(!ex)
	{
		DPRINTFN(10,("musb_receive_host: Panic! interrupt received while no pipe/xfer assigned\n"));
		CSR_CLEAR(csr);
		updated=1;
		goto end;
	}
	/* RXSTALL and ERROR are terminal error conditons */
	if(csr & (HOST_RXCSR_RXSTALL | HOST_RXCSR_ERROR))
	{
		if(csr & HOST_RXCSR_RXSTALL)
			ex->xfer.status = USBD_STALLED;
		else /* HOST_RXCSR_ERROR */
			ex->xfer.status = USBD_IOERROR;

		/* Ensure we correctly report any partial transfer */
		ex->xfer.actlen = ex->xfer.length-epipe->remain;

		complete=1;
		csro = 0; /* Clear all of RXCSR so any offending flags (e.g. REQPKT) don't cause another error when the transfer fails for the second time */
		updated=1;
		goto end;
	}
	/* Else we should have some data to read */
	if(csr & HOST_RXCSR_RXPKTRDY)
	{
		epipe->toggle = !epipe->toggle;
		int count = musb_base->csr.host_ep[ep].rxcount & RXCOUNT_EPRXCOUNT;
		if(count > epipe->remain)
		{
			DPRINTFN(10,("musb_receive_host: Panic! Device sent too much data\n"));
			ex->xfer.status = USBD_IOERROR;
			/* Flush FIFO */
			musb_base->csr.host_ep[ep].host_rxcsr = csro | HOST_RXCSR_FLUSHFIFO;
			WAITON(musb_base->csr.host_ep[ep].host_rxcsr & HOST_RXCSR_RXPKTRDY);
			csro = musb_base->csr.host_ep[ep].host_rxcsr;
			updated=0;
			complete=1;
			goto end;
		}
		else
		{
			/* Grab the data */
			epipe->remain -= count;
			epipe->buf = musb_fiforead(musb_base,ep,epipe->buf,count);
			CSR_CLEAR(HOST_RXCSR_RXPKTRDY);
			updated=1;
			/* If it was a short packet (not max packet size) then we're done. Else we assume that more data is coming (unless we've received all we're interested in, which we check for below) */
			usb_endpoint_descriptor_t *ed = epipe->pipe.endpoint->edesc;
			if(count != UGETW(ed->wMaxPacketSize))
			{
				ex->xfer.status = USBD_NORMAL_COMPLETION;
				ex->xfer.actlen = ex->xfer.length-epipe->remain;
				complete=1;
				goto end;
			}
			/* Fall through... */
		}
	}
	else
	{
#ifdef MUSB_USE_NAKTIMEOUT
		/* Receive NAK timeouts seem to be more broken than host timeouts. The only time the bit will clear is by (a) clearing the RXPKTRDY bit (or emptying the fifo?) after data has been received, or (b) flushing the FIFO (after data has been received)
		   So for now, treat NAKTIMEOUT as the lowest priority (instead of the highest priority, like the manual suggests it should be?)
		   This will allow us to deal with the initial timeout (by clearing RXINTERVAL and allowing the controller to resume), making the next interrupt we receive a regular one (even though the DATAERR_NAKTIMEOUT bit will still be set) */
		if(csr & HOST_RXCSR_DATAERR_NAKTIMEOUT)
		{
#if 1
			csro &= ~HOST_RXCSR_DATAERR_NAKTIMEOUT;
			updated = 1;
			musb_base->csr.host_ep[ep].host_rxinterval = 0;
			goto end;
#else
			DPRINTFN(10,("*** timeout for ep %d @@ %08x (%08x) ***\n",ep,&musb_base->csr.host_ep[ep].host_rxcsr,((int)&musb_base->csr.host_ep[ep].host_rxcsr)-(int)musb_base));
			musb_base->common.intrrxe &= ~(1<<ep);
			*((char *)-1) = 0;
#endif
		}
		else
#endif
		{
			DPRINTFN(10,("musb_receive_host: Interrupt with no cause?\n"));
		}
	}
	/* Do we need more data? */
	if(epipe->remain)
	{
		CSR_SET(HOST_RXCSR_REQPKT);
		updated=1;
		goto end;
	}
	else
	{
		/* We're done! */
		ex->xfer.status = USBD_NORMAL_COMPLETION;
		ex->xfer.actlen = ex->xfer.length;
		complete=1;
		goto end;
	}
end:
	DPRINTFN(15,("musb_receive_host: new csr %04x(%d) complete %d\n",csro,updated,complete));
	if(updated)
		musb_base->csr.host_ep[ep].host_rxcsr = csro;
	if(complete)
		musb_mp_completed(sc,ex,ep);
}

static void musb_transmit_host(musb_softc_t *sc,int ep)
{
	/* Process endpoint transmit interrupt when acting as a host */
	volatile musb_regs *musb_base = sc->musb_base;
	int csr = musb_base->csr.host_ep[ep].host_txcsr;
	int updated=0;
	int csro=csr;
	int complete=0;
	struct musb_pipe *epipe = sc->host_tx[ep];
	struct musb_xfer *ex = (struct musb_xfer *) (epipe?SIMPLEQ_FIRST(&epipe->pipe.queue):0);
	DPRINTFN(15,("musb_transmit_host: ep %d csr %04x pipe %08x\n",ep,csr,epipe));
	/* Pretty much the same error handling as for control transfers... */
	if(!ex)
	{
		DPRINTFN(10,("musb_transmit_host: Panic! interrupt received while no pipe/xfer assigned\n"));
		/* Abort by flushing the FIFO */
		csro = csr | HOST_TXCSR_FLUSHFIFO;
		musb_base->csr.host_ep[ep].host_txcsr = csro;
		WAITON(musb_base->csr.host_ep[ep].host_txcsr & HOST_TXCSR_TXPKTRDY);
		csro = 0;
		updated=1;
		goto end;
	}
#ifdef MUSB_USE_NAKTIMEOUT
	/* NAK_TIMEOUT handling seems to be a bit broken compared to what the manual (and what the Linux sources!) say.
	   It looks like the only way to clear the condition is to set the txinterval register to 0, which will then cause the controller to immediately start retrying the transfer. However we don't really want this, because we want to set the timeout value back to its original value before the transfer starts up again.
	   Also, we want to use nak timeouts as a method of yielding to other transfers. So what we'll do is flush the fifo, reset txinterval, clear the nak timeout flag, and then look for another transfer to queue */
	if(csr & HOST_TXCSR_NAK_TIMEOUT)
	{
#if 1
		/* Blah */
		csro &= ~HOST_TXCSR_NAK_TIMEOUT;
		updated = 1;
		musb_base->csr.host_ep[ep].host_txinterval = 0;
		goto end;
#elif 1
		/* Flush FIFO */
		csro = csr | HOST_TXCSR_FLUSHFIFO;
		musb_base->csr.host_ep[ep].host_txcsr = csro;
		WAITON(musb_base->csr.host_ep[ep].host_txcsr & HOST_TXCSR_TXPKTRDY);
		/* Clear txinterval */
		musb_base->csr.host_ep[ep].host_txinterval = 0;
		/* Clear NAK_TIMEOUT error */
		csro = 0;
		musb_base->csr.host_ep[ep].host_txcsr = csro;
		/* Rewind the buffer pointers */
		DPRINTFN(10,("Rewinding buffer by %d bytes\n",epipe->last_write));
		epipe->remain += epipe->last_write;
		epipe->buf -= epipe->last_write;
		epipe->toggle = !epipe->toggle;
		epipe->last_write = 0;
		/* Look for another transfer */
		struct musb_multiplexer *mp = epipe->multiplexer;
		struct musb_pipe *next = SIMPLEQ_FIRST(&mp->waitq);
		if(next)
		{
			DPRINTFN(10,("-> yield to next pipe %p\n",next));

			/* Finish pausing this one: */
			/* Cancel any timeout */
			callout_stop(&(ex->xfer.timeout_handle));
			/* And cancel the associated callback */
			riscos_cancel_abort_pipe(ex);
			/* Stop pipe */
			epipe->running = false;
			epipe->ep = -1;
			if(mp->tx)
				sc->host_tx[ep] = NULL;
			else
				sc->host_rx[ep] = NULL;
			/* Insert at back of queue */
			SIMPLEQ_INSERT_TAIL(&mp->waitq,epipe,multiq);
			/* Now run the new entry */
			SIMPLEQ_REMOVE_HEAD(&mp->waitq,multiq);
			musb_pipe_run(next,ep);
		}
		else
		{
			DPRINTFN(10,("-> retrying\n"));
			musb_pipe_run(epipe,ep);
		}
		goto end;
#else
		DPRINTFN(10,("*** timeout for ep %d @@ %08x (%08x) ***\n",ep,&musb_base->csr.host_ep[ep].host_txcsr,((int)&musb_base->csr.host_ep[ep].host_txcsr)-(int)musb_base));
		musb_base->common.intrtxe &= ~(1<<ep);
		*((char *)-1) = 0;
#endif
		goto end;
	}
#endif
	/* RXSTALL and ERROR are terminal error conditons */
	if(csr & (HOST_TXCSR_RXSTALL | HOST_TXCSR_ERROR))
	{
		if(csr & HOST_TXCSR_RXSTALL)
			ex->xfer.status = USBD_STALLED;
		else /* HOST_TXCSR_ERROR */
			ex->xfer.status = USBD_IOERROR;

		/* Ensure we correctly report any partial transfer */
		ex->xfer.actlen = ex->xfer.length-epipe->remain;

		complete=1;
		/* Abort by flushing the FIFO */
		csro = csr | HOST_TXCSR_FLUSHFIFO;
		musb_base->csr.host_ep[ep].host_txcsr = csro;
		WAITON(musb_base->csr.host_ep[ep].host_txcsr & HOST_TXCSR_TXPKTRDY);
		/* Also need to clear txinterval? */
		musb_base->csr.host_ep[ep].host_txinterval = 0;
		csro = 0;
		updated=1;
		goto end;
	}
	/* Else we should be able to send some more data */
	if(epipe->remain)
	{
		usb_endpoint_descriptor_t *ed = epipe->pipe.endpoint->edesc;
		int count = min(epipe->remain,UGETW(ed->wMaxPacketSize));
		epipe->remain -= count;
		epipe->buf = musb_fifowrite(musb_base,ep,epipe->buf,count);
		epipe->last_write = count;
		epipe->toggle = !epipe->toggle;
		CSR_SET(HOST_TXCSR_TXPKTRDY);
		updated=1;
		goto end;
	}
	else if(epipe->null_packet)
	{
		/* End of data, but we need to send a null packet */
		epipe->null_packet = false;
		epipe->toggle = !epipe->toggle;
		CSR_SET(HOST_TXCSR_TXPKTRDY);
		updated=1;
		goto end;
	}
	else
	{
		/* We're done! */
		ex->xfer.status = USBD_NORMAL_COMPLETION;
		ex->xfer.actlen = ex->xfer.length;
		complete=1;
		goto end;
	}
end:
	DPRINTFN(15,("musb_transmit_host: new csr %04x(%d) complete %d\n",csro,updated,complete));
	if(updated)
		musb_base->csr.host_ep[ep].host_txcsr = csro;
	if(complete)
		musb_mp_completed(sc,ex,ep);
}

/*

			MAIN INTERRUPT ROUTINE

*/


int musb_intr(musb_softc_t *sc)
{
	/* return 0 for success, 1 for failure */

	/* Read IRQ state and process according to flowchart (figure 23-5 spruf98b, page 3078) */
	volatile musb_regs *musb_base = sc->musb_base;
	int intrusb = musb_base->common.intrusb;
	int devctl = musb_base->devctl;
	int isbdevice = devctl & DEVCTL_BDEVICE;
	int ishost = devctl & DEVCTL_HOSTMODE;
	unsigned int ep_tx = musb_base->common.intrtx;
	unsigned int ep_rx = musb_base->common.intrrx;
	riscos_irqclear(sc->devno);
	DPRINTFN(10,("irq %02x devctl %02x (%c %s) rx %04x tx %04x\n",intrusb,devctl,(isbdevice?'B':'A'),(ishost?"Host":"Peripheral"),ep_rx,ep_tx));
	if(intrusb & INTRUSB_RESUME)
	{
		DPRINTFN(11,("INTRUSB_RESUME\n"));
	}
	if(!isbdevice)
	{
		if(intrusb & INTRUSB_SESSREQ)
		{
			DPRINTFN(11,("INTRUSB_SESSREQ\n"));
		}
	}
	if(intrusb & INTRUSB_VBUSERR)
	{
		DPRINTFN(11,("INTRUSB_VBUSERR\n"));
		if(sc->tps.retry_counter)
		{
			sc->tps.retry_counter--;
			DPRINTFN(10,("%d VBUS retries left\n",sc->tps.retry_counter));
			musb_base->devctl = musb_base->devctl | DEVCTL_SESSION;
		} 
	}
	if(ishost)
	{
		if(intrusb & INTRUSB_CONN)
		{
			DPRINTFN(11,("INTRUSB_CONN\n"));
		}
		if(intrusb & INTRUSB_RESET_BABBLE)
		{
			DPRINTFN(11,("INTRUSB_RESET_BABBLE\n"));
		}
		if(ep_tx & 1)
		{
			musb_ep0_host(sc);
		}
		ep_rx &= ~1;
		while(ep_rx)
		{
			int i;
			__asm {
			CLZ	i,ep_rx;
			}
			i=31-i;
			musb_receive_host(sc,i);
			ep_rx &= ~(1<<i);
		}
		ep_tx &= ~1;
		while(ep_tx)
		{
			int i;
			__asm {
			CLZ	i,ep_tx;
			}
			i=31-i;
			musb_transmit_host(sc,i);
			ep_tx &= ~(1<<i);
		}
	}
	else
	{
		/* todo - surely we need to monitor INTRUSB_RESET_BABBLE here, to detect resets? */
		if(ep_tx & 1)
		{
			musb_ep0_peri(sc);
		}
#if 0
		int i=0;
		ep_rx = ep_rx>>1;
		do {
			i++;
			if(ep_rx & 1)
				DPRINTFN(12,("EP%d peri RX\n",i));
			ep_rx = ep_rx>>1;
		} while(ep_rx);
		ep_tx = ep_tx>>1;
		i=0;
		do {
			i++;
			if(ep_tx & 1)
				DPRINTFN(12,("EP%d peri TX\n",i));
			ep_tx = ep_tx>>1;
		} while(ep_tx);
#endif
	}
	if(intrusb & INTRUSB_SOF)
	{
		DPRINTFN(11,("INTRUSB_SOF\n"));
	}
	if(intrusb & INTRUSB_DISCON)
	{
		DPRINTFN(11,("INTRUSB_DISCON\n"));
		/* todo - this is probably a pretty good indicator that we should reset all our state vars, and cancel any pending xfers... */
	}
	if(intrusb & INTRUSB_SUSPEND)
	{
		DPRINTFN(11,("INTRUSB_SUSPEND\n"));
	}
	/* Check if the interrupt caused a port status change */
	u32 port_status = musb_calc_port_status(musb_base->devctl,musb_base->common.power,sc->port_status);
	if(port_status != sc->port_status)
	{
		DPRINTFN(10,("intr detected PCD, new status %04x change %04x\n",port_status&0xffff,port_status>>16));
		sc->port_status = port_status;
		musb_pcd(sc->sc_intrxfer);
	}
	/* Just claim we've done it all */
	return 0;
}
@


1.14
log
@Remove unused include
Admin:
  Fewer depends. Not tagged.
@
text
@a37 3
#ifdef USBHAL
#include <dev/usb/usbhal.h>
#else
a40 1
#endif
a53 1
#include "Global/Services.h"
@


1.13
log
@Don't reach into USBDriver's back pocket
cmodule.c:
  Use USBDriver.h from interface exports
Makefile:
  Remove duplicated libs from debug build
  Remove relative reference to NetBSD component from VPATH
!MkDebug:
  Select debug target so the right compiler switches are used
musb.c/musb_debug.c/musb_peri.c/musb_root.c/musb_usb.c/musb_util.c/tps.c:
  Unused reference to USBDriver.h removed
Built, but not tested.

Version 0.23. Tagged as 'MUSBDriver-0_23'
@
text
@a60 1
#include "tboxlibint/messages.h"
@


1.12
log
@Fix to allow building against NetBSD-0_85
Detail:
  c/cmodule - Don't use NetBSD/build/service.h, it no longer exists. Use the exported USB/USBDevFS.h instead. Fix service call reason codes to use USBDevFS names.
  c/musb, c/musb_debug, c/musb_hal, c/musb_peri, c/musb_root, c/musb_usb, c/musb_util, c/tps - Strip redundant #includes
Admin:
  Tested in OMAP3 ROM build
  Build output is binary-identical to previous version
  Requires NetBSD-0_85


Version 0.22. Tagged as 'MUSBDriver-0_22'
@
text
@a44 1
#include "../../NetBSD/build/USBDriver.h"
@


1.11
log
@Fix handling of short control transfers
Detail:
  c/musb - Updated musb_ep0_host() to treat a short control packet as the end of the transfer, as mandated by the USB spec. Also updated a few other pieces of code to ensure the transfer length is reported correctly if an error occurs.
  c/cmodule - Fix potential null pointer dereference when debugging enabled
  Makefile - Fix lack of DPRINTF() debug output in debug builds due to USB_DEBUG not being defined
Admin:
  Tested on BB-xM with high processor vectors
  Fixes 99% of connected devices failing to initialise following the change to the device initialisation logic made to USBDriver in NetBSD-0_82 (initial device descriptor requests now request more data than is likely to be available, triggering a short packet/xfer response)


Version 0.21. Tagged as 'MUSBDriver-0_21'
@
text
@a66 3
#include "../../NetBSD/build/service.h"
#include "oslib/devicefs.h"

@


1.10
log
@Fix data aborts in HAL build
Detail:
  c/musb_peri, c/musb_root - Fixed some code in the root hub emulation that was writing to a global struct before copying it into the destination buffer. Although this works fine in ROM modules, it was causing data aborts in the HAL build due to lack of automatic RW data relocation by the compiler.
  c/musb - Removed reference to an old extern variable
Admin:
  Tested on rev C2 BB


Version 0.15. Tagged as 'MUSBDriver-0_15'
@
text
@d607 4
d674 11
d743 1
a743 1
		ex->xfer.actlen = ex->xfer.length;
d798 4
d988 4
@


1.9
log
@Fix NAK timeout handling
Detail:
  c/musb, c/musb_debug, h/musb - Fixed NAK timeouts to not be treated as errors. Attempted to make use of NAK timeouts for yielding to other pending transfers, but ran into difficulties getting the timeout condition to clear properly. Disabling NAK intervals/timeouts entirely seems to be the safest option for now.
Admin:
  Tested on rev C2 BB, rev A2 BB-xM


Version 0.13. Tagged as 'MUSBDriver-0_13'
@
text
@a78 1
extern int retry_counter;
@


1.8
log
@Add support for HAL builds of MUSBDriver
Detail:
  Makefile - Now builds a HAL-compatible static library during the export libs phase
  !MkHAL,fd7 - Handy script for building the HAL lib
  c/musb_hal - HAL version of cmodule.c
  c/musb, c/musb_debug, c/musb_peri, c/musb_root, c/musb_usb, c/musb_util, c/tps, h/cmodule, h/musb, h/musb_util, h/tps - Changed to support the HAL build. Biggest change was getting rid of all global vars; everything is now done via the bus ptr instead.
  c/port - Removed microtime and moved riscos_irq_clear here, to match change made in main USB drivers
Admin:
  HAL & non-HAL versions tested on rev C2 BB, rev A2 BB-xM, rev C1 TouchBook
  Needs latest Kernel & NetBSD USB drivers


Version 0.12. Tagged as 'MUSBDriver-0_12'
@
text
@a202 1
	epipe->nakremain = 0;
d440 1
d442 3
d457 1
d476 1
d478 3
d574 1
a574 1
			csro = HOST_CSR0_FLUSHFIFO;
d594 9
a602 2
	/* RXSTALL, ERROR and NAK_TIMEOUT are terminal error conditons that are handled the same for each host_ep[0].state */
	if(csr & (HOST_CSR0_RXSTALL | HOST_CSR0_ERROR | HOST_CSR0_NAK_TIMEOUT))
d606 1
a606 1
		else if(csr & HOST_CSR0_ERROR)
a607 27
		else /* HOST_CSR0_NAK_TIMEOUT */
			ex->xfer.status = USBD_TIMEOUT;
		if(csr & HOST_CSR0_NAK_TIMEOUT)
		{
			switch(sc->host_ep0_state)
			{
			case HOST_EP0_STATE_SETUP:
			case HOST_EP0_STATE_OUT_DATA:
			case HOST_EP0_STATE_OUT_STATUS:
				/* Abort by flushing the FIFO */
				csro = HOST_CSR0_FLUSHFIFO;
				/* Wait for completion (should complete immediately for IN_DATA, etc.) */
				musb_base->csr.host_ep0.host_csr0 = csro;
				WAITON(musb_base->csr.host_ep0.host_csr0 & HOST_CSR0_TXPKTRDY);
				csro = 0;
				updated=1;
				break;
			case HOST_EP0_STATE_IN_DATA:
			case HOST_EP0_STATE_IN_STATUS:
				/* Abort by clearing REQPKT (and STATUSPKT for IN_STATUS) */
				csro = 0;
				musb_base->csr.host_ep0.host_csr0 = csro;
				WAITON(musb_base->csr.host_ep0.host_csr0 & (HOST_CSR0_REQPKT | HOST_CSR0_STATUSPKT));
				updated=1;
				break;
			}
		}
d697 1
d738 1
a738 1
		csro = HOST_CSR0_FLUSHFIFO;
d777 2
a778 2
	/* RXSTALL, ERROR and NAK_TIMEOUT are terminal error conditons */
	if(csr & (HOST_RXCSR_RXSTALL | HOST_RXCSR_ERROR | HOST_RXCSR_DATAERR_NAKTIMEOUT))
d782 1
a782 1
		else if(csr & HOST_RXCSR_ERROR)
a783 9
		else /* HOST_RXCSR_DATAERR_NAKTIMEOUT */
			ex->xfer.status = USBD_TIMEOUT;
		if(csr & HOST_RXCSR_DATAERR_NAKTIMEOUT)
		{
			/* Abort by clearing REQPKT */
			CSR_CLEAR(HOST_RXCSR_REQPKT);
			musb_base->csr.host_ep[ep].host_rxcsr = csro;
			WAITON(musb_base->csr.host_ep[ep].host_rxcsr & HOST_RXCSR_REQPKT);
		}
d827 22
a848 1
		DPRINTFN(10,("musb_receive_host: Interrupt with no cause?\n"));
d887 1
a887 1
		DPRINTFN(10,("musb_receive_host: Panic! interrupt received while no pipe/xfer assigned\n"));
d889 1
a889 1
		csro = HOST_TXCSR_FLUSHFIFO;
d896 69
a964 2
	/* TXSTALL, ERROR and NAK_TIMEOUT are terminal error conditons */
	if(csr & (HOST_TXCSR_RXSTALL | HOST_TXCSR_ERROR | HOST_TXCSR_NAK_TIMEOUT))
d968 1
a968 1
		else if(csr & HOST_TXCSR_ERROR)
a969 2
		else /* HOST_TXCSR_NAK_TIMEOUT */
			ex->xfer.status = USBD_TIMEOUT;
d972 1
a972 1
		csro = HOST_TXCSR_FLUSHFIFO;
d975 2
d988 1
@


1.7
log
@Restructure MUSBDriver source code, rework host mode endpoint handling, plus other misc changes
Detail:
  c/musb_debug - New file containing debug code.
  c/musb_peri - Contains the code for handling peripheral mode, taken from c/musb
  c/musb_root - Contains the code for handling the USBDriver-required 'soft' hub, taken from c/musb
  c/musb_usb - Contains initialisation code and other misc USBDriver-related code, mostly taken from c/musb
  c/musb_util - Misc utility functions from c/musb
  h/musb_util, h/musb_usb - A couple of new header files to help with breaking things up. Might make sense to break h/musb_usb down further (or just consolidate everything back into h/musb)
  c/musb - Stripped out pretty much everything except code related to host-mode endpoint and interrupt handling. Instances of the new musb_multiplexer struct are used to handle endpoint allocation, and allocation is now performed on a per-usbd_xfer basis instead of on a per-pipe basis. This should allow the code to cope better with situations where the number of pipes is greater than the number of physical endpoints, although much work is still required.
  c/cmodule, c/port, c/tps, h/cmodule, h/musb - Misc tweaks and changes
Admin:
  Tested on rev A2 BB-xM.


Version 0.11. Tagged as 'MUSBDriver-0_11'
@
text
@d37 4
d42 3
a45 1
#include "swis.h"
a60 1
#include "callx/callx.h"
d297 1
d369 1
d423 1
a423 1
		musb_fifowrite(0,&ex->xfer.request,8);
d453 1
a453 1
		epipe->buf = musb_fifowrite(ep,epipe->buf,count);
d549 1
d680 1
a680 1
				epipe->buf = musb_fiforead(0,epipe->buf,count);
d708 1
a708 1
			epipe->buf = musb_fifowrite(0,epipe->buf,count);
d772 1
d830 1
a830 1
			epipe->buf = musb_fiforead(ep,epipe->buf,count);
d875 1
d919 1
a919 1
		epipe->buf = musb_fifowrite(ep,epipe->buf,count);
a956 2
int retry_counter = 3;

d962 1
d969 1
a969 1
	riscos_irqclear();
d985 1
a985 1
		if(retry_counter)
d987 2
a988 2
			retry_counter--;
			DPRINTFN(10,("%d VBUS retries left\n",retry_counter));
@


1.6
log
@Add timeout handling to MUSBDriver, tidy code a bit
Detail:
  Makefile - rewritten to use CModule fragment instead of deprecated RAMCModule & ROMCModule fragments. Link stage also outputs symbol table to aid in debugging.
  c/cmodule, c/musb, h/musb - Add code to handle transfer timeouts
  c/musb - Fix a couple of compiler warnings, including a bug in root hub handling
Admin:
  Tested on rev C2 beagleboard.
  Machine no longer hangs on boot with hub + keyboard connected to OTG port, but keyboard often fails to initialise and needs to be *USBReset or re-plugged.


Version 0.08. Tagged as 'MUSBDriver-0_08'
@
text
@a39 3
//#include <stdlib.h>
//#include <string.h>
//#include <stdlib.h>
d66 2
d69 6
a74 1324
#ifdef MUSB_DEBUG
#define DPRINTF(X) if(musbdebug) logprintf X
#define DPRINTFN(A,X) if(musbdebug>(A)) logprintf X
#else
#define DPRINTF(X)
#define DPRINTFN(A,X)
#endif

#define MUSB_NUM_ENDPOINTS 16

#define WAITON(x) \
{\
	int timeout=128*1024;\
	while(x)\
	{\
		if(!(timeout--))\
		{\
			DPRINTF(("WAITON timeout! Line %d Event %s (%08x)\n",__LINE__,#x,x));\
			break;\
		}\
	}\
}

#define MS_TO_TICKS(ms) ((ms) * hz / 1000)

Static void		musb_shutdown(void *);
Static void		musb_power(int, void *);

Static usbd_status	musb_open(usbd_pipe_handle);
Static void		musb_poll(struct usbd_bus *);
Static void		musb_softintr(void *);
//Static int		musb_intr1(musb_softc_t *);
//Static void		musb_waitintr(musb_softc_t *, usbd_xfer_handle);
//Static void		musb_check_intr(musb_softc_t *, struct musb_xfer *);
//Static void		musb_idone(struct musb_xfer *);
//Static void		musb_timeout(void *);
//Static void		musb_timeout_task(void *);

Static usbd_status	musb_allocm(struct usbd_bus *, usb_dma_t *, u_int32_t);
Static void		musb_freem(struct usbd_bus *, usb_dma_t *);

Static usbd_xfer_handle	musb_allocx(struct usbd_bus *);
Static void		musb_freex(struct usbd_bus *, usbd_xfer_handle);

Static usbd_status	musb_root_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	musb_root_ctrl_start(usbd_xfer_handle);
Static void		musb_root_ctrl_abort(usbd_xfer_handle);
Static void		musb_root_ctrl_close(usbd_pipe_handle);
Static void		musb_root_ctrl_done(usbd_xfer_handle);

Static usbd_status	musb_root_intr_transfer(usbd_xfer_handle);
Static usbd_status	musb_root_intr_start(usbd_xfer_handle);
Static void		musb_root_intr_abort(usbd_xfer_handle);
Static void		musb_root_intr_close(usbd_pipe_handle);
Static void		musb_root_intr_done(usbd_xfer_handle);

Static usbd_status	musb_device_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	musb_device_ctrl_start(usbd_xfer_handle);
Static void		musb_device_ctrl_abort(usbd_xfer_handle);
Static void		musb_device_ctrl_close(usbd_pipe_handle);
Static void		musb_device_ctrl_done(usbd_xfer_handle);

Static usbd_status	musb_device_bulk_transfer(usbd_xfer_handle);
Static usbd_status	musb_device_bulk_start(usbd_xfer_handle);
Static void		musb_device_bulk_abort(usbd_xfer_handle);
Static void		musb_device_bulk_close(usbd_pipe_handle);
Static void		musb_device_bulk_done(usbd_xfer_handle);

Static usbd_status	musb_device_intr_transfer(usbd_xfer_handle);
Static usbd_status	musb_device_intr_start(usbd_xfer_handle);
Static void		musb_device_intr_abort(usbd_xfer_handle);
Static void		musb_device_intr_close(usbd_pipe_handle);
Static void		musb_device_intr_done(usbd_xfer_handle);

Static usbd_status	musb_device_isoc_transfer(usbd_xfer_handle);
Static usbd_status	musb_device_isoc_start(usbd_xfer_handle);
Static void		musb_device_isoc_abort(usbd_xfer_handle);
Static void		musb_device_isoc_close(usbd_pipe_handle);
Static void		musb_device_isoc_done(usbd_xfer_handle);

Static void		musb_device_clear_toggle(usbd_pipe_handle pipe);
Static void		musb_noop(usbd_pipe_handle pipe);

Static void *		musb_fiforead(int ep,void *dest,int bytes);
Static void *		musb_fifowrite(int ep,void *src,int bytes);

Static void		musb_ep0_peri(musb_softc_t *sc);

Static void		musb_ep0_host(musb_softc_t *sc);
Static void		musb_receive_host(musb_softc_t *sc,int ep);
Static void		musb_transmit_host(musb_softc_t *sc,int ep);
Static void		musb_start_control(musb_softc_t *sc,struct musb_xfer *ex);

Static struct usbd_bus_methods musb_bus_methods = {
	musb_open,
	/* Open pipe to pipe->device->address:pipe->endpoint->edesc->bEndpointAddress.
	   If dest addr == hub address (pipe->device->bus->sc_addr), bEndpointAddress will be USB_CTRONOL_ENDPOINT or UE_DIR_IN|EHCI_INTR_ENDPOINT.
	   pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE gives pipe type
	   pipe->device->speed gives pipe speed
	   On exit:
	   - pipe->methods should be set to function ptrs
	   - private members of 'pipe' can be set appropriately
	     - musb_init() must set musb_softc.sc_bus.pipe_size to size of private pipe struct!!
	     - and must set all other appropriate members of sc_bus (e.g. pointer to these funcs)
	*/
	musb_softintr,
	/* Check for any interrupts and handle them? */
	musb_poll,
	/* Check for any interrupts and handle them? */
	musb_allocm,
	/* Alloc memory */
	musb_freem,
	/* Free memory */
	musb_allocx,
	/* Alloc usbd_xfer for the given bus struct; alloc size would be that requires for internal usbd_xfer struct */
	musb_freex,
	/* Free usbd_xfer (just add to free list?) */
};

Static struct usbd_pipe_methods musb_root_ctrl_methods = {
	musb_root_ctrl_transfer,
	musb_root_ctrl_start,
	musb_root_ctrl_abort,
	musb_root_ctrl_close,
	musb_noop,
	musb_root_ctrl_done,
};

/* Root hub interrupt transfers are used to flag port status changes - see sc_intrxfer */
Static struct usbd_pipe_methods musb_root_intr_methods = {
	musb_root_intr_transfer,
	musb_root_intr_start,
	musb_root_intr_abort,
	musb_root_intr_close,
	musb_noop,
	musb_root_intr_done,
};

Static struct usbd_pipe_methods musb_device_ctrl_methods = {
	musb_device_ctrl_transfer,
	/* Start a control transfer; xfer->pipe->queue is cross-implementation queue struct used to track pending transfers.
	- just need to add it to the queue then start the queue processing? (which will either start the transfer if controller is idle or leave it queued
	- if xfer->pipe->device->bus.sc_bus.use_polling, need to wait for transfer to finish
	  - but always return USBD_IN_PROGRESS? */
	musb_device_ctrl_start,
	/* This is called by musb_device_ctrl_transfer. No idea why, but if identical structure to other implementations is followed everything should be OK? */
	musb_device_ctrl_abort,
	/* Abort the given transfer, sets the xfer status to USBD_CANCELLED, performs callbacks, etc. */
	musb_device_ctrl_close,
	/* Closes pipe */
	musb_noop,
	/* Clear toggle flag - noop for both ehci & ohci */
	musb_device_ctrl_done,
	/* Called from usbdriver when a transfer is done. Always gets called just before the xfer is deleted? */
};

Static struct usbd_pipe_methods musb_device_intr_methods = {
	musb_device_intr_transfer,
	musb_device_intr_start,
	musb_device_intr_abort,
	musb_device_intr_close,
	musb_device_clear_toggle,
	musb_device_intr_done,
};

Static struct usbd_pipe_methods musb_device_bulk_methods = {
	musb_device_bulk_transfer,
	musb_device_bulk_start,
	musb_device_bulk_abort,
	musb_device_bulk_close,
	musb_device_clear_toggle,
	musb_device_bulk_done,
};

Static struct usbd_pipe_methods musb_device_isoc_methods = {
	musb_device_isoc_transfer,
	musb_device_isoc_start,
	musb_device_isoc_abort,
	musb_device_isoc_close,
	musb_noop,
	musb_device_isoc_done,
};

int musbdebug=0;

#if defined (__riscos)
static int veneers_built = 0;
void build_veneer (void* vn, void* st, size_t sz);
static struct {
    struct usbd_bus_methods methods;
    struct {
        int load;
        int branch;
    } veneer[sizeof (struct usbd_bus_methods) / sizeof (void*)];
} musb_bus_methods_entry;

static struct {
    struct usbd_pipe_methods methods;
    struct {
        int load;
        int branch;
    } veneer[sizeof (struct usbd_pipe_methods) / sizeof (void*)];
} musb_root_ctrl_methods_entry,
  musb_root_intr_methods_entry,
  musb_device_ctrl_methods_entry,
  musb_device_intr_methods_entry,
  musb_device_bulk_methods_entry,
  musb_device_isoc_methods_entry;
#endif

usbd_status
musb_init(musb_softc_t *sc)
{
//	u_int32_t version, sparams, cparams, hcr;
	u_int i;
//	usbd_status err;
//	musb_soft_qh_t *sqh;
//	u_int ncomp;
	
	DPRINTF(("musb_init: start\n"));
#if defined (__riscos)
        if (!veneers_built)
        {
            build_veneer(&musb_bus_methods_entry,
                &musb_bus_methods,
                sizeof musb_bus_methods);
            build_veneer(&musb_root_ctrl_methods_entry,
                &musb_root_ctrl_methods,
                sizeof musb_root_ctrl_methods);
            build_veneer(&musb_root_intr_methods_entry,
                &musb_root_intr_methods,
                sizeof musb_root_intr_methods);
            build_veneer(&musb_device_ctrl_methods_entry,
                &musb_device_ctrl_methods,
                sizeof musb_device_ctrl_methods);
            build_veneer(&musb_device_intr_methods_entry,
                &musb_device_intr_methods,
                sizeof musb_device_intr_methods);
            build_veneer(&musb_device_bulk_methods_entry,
                &musb_device_bulk_methods,
                sizeof musb_device_bulk_methods);
            build_veneer(&musb_device_isoc_methods_entry,
                &musb_device_isoc_methods,
                sizeof musb_device_isoc_methods);
            veneers_built = 1;
        }
#endif

	SIMPLEQ_INIT(&sc->sc_free_xfers);
	SIMPLEQ_INIT(&sc->host_ep0_queue);

	/* Set up the bus struct. */
	sc->sc_bus.usbrev = USBREV_2_0;
	sc->sc_bus.methods = &musb_bus_methods;
	sc->sc_bus.pipe_size = sizeof(struct musb_pipe);

	sc->peri_ep0_state = PERI_EP0_STATE_IDLE;

	/* Set up the controller */
	/* First, reset */
	musb_base->otg_sysconfig = OTG_SYSCONFIG_SOFTRESET;
	for(i=0;i<100;i++)
	{
		delay(1000);
		if(musb_base->otg_sysstatus & OTG_SYSSTATUS_RESETDONE)
			break;
	}
	if(!(musb_base->otg_sysstatus & OTG_SYSSTATUS_RESETDONE))
	{
		DPRINTF(("musb_init: timeout in hardware reset\n"));
		return (USBD_IOERROR);
	}
	/* Set power settings */
	musb_base->otg_forcestdby = 0;
	musb_base->otg_sysconfig = OTG_SYSCONFIG_SIDLEMODE_SMART | OTG_SYSCONFIG_MIDLEMODE_SMART;
	musb_base->otg_sysconfig = OTG_SYSCONFIG_AUTOIDLE | OTG_SYSCONFIG_SIDLEMODE_SMART | OTG_SYSCONFIG_MIDLEMODE_SMART;
	musb_base->otg_interfsel = OTG_INTERFSEL_PHYSEL;
	/* FIFO setup - very simplistic for the moment, give each endpoint individual RX & TX FIFOs, assuming 16K of FIFO RAM is available, and ep0 has a fixed FIFO that occupies the lowest 64 bytes. */
	int fifoaddr = 64;
	for(i=1;i<16;i++)
	{
		musb_base->common.index = i;
		musb_base->txfifosz = 6; /* (2^(6+3))*30+64 = 15424 bytes used total */
		musb_base->rxfifosz = 6;
		musb_base->txfifoaddr = fifoaddr/8;
		fifoaddr += 512;
		musb_base->rxfifoaddr = fifoaddr/8;
		fifoaddr += 512;
	}
	/* Set a default NAK limit */
	musb_base->csr.host_ep0.host_naklimit0 = 10; /* 2^(10-1) */
	/* Enable interrupts */
	musb_base->common.intrtxe = 0xffff;
	musb_base->common.intrrxe = 0xfffe;
	musb_base->common.intrusbe = 0xf7;
	/* Set basic config */
	musb_base->common.testmode = 0;
	musb_base->common.power = POWER_ISOUPDATE | POWER_SOFTCONN | POWER_HSEN;
	/* Host mode session start */
	musb_base->devctl = DEVCTL_SESSION; 

	return (USBD_NORMAL_COMPLETION);
}

/*
 * Shut down the controller when the system is going down.
 */
void
musb_shutdown(void *v)
{
	musb_softc_t *sc = v;

	DPRINTF(("musb_shutdown: stopping the HC\n"));
}

usbd_status
musb_allocm(struct usbd_bus *bus, usb_dma_t *dma, u_int32_t size)
{
	usbd_status err;
#if 1
	/* We aren't using DMA yet, so we can just use malloc() here and avoid the speed penalties associated with noncacheable memory */
	*dma = malloc(size,M_DEVBUF,M_NOWAIT); /* ??? */
	if(*dma)
		err = USBD_NORMAL_COMPLETION;
	else
		err = USBD_NOMEM;
#else
	struct musb_softc *sc = (struct musb_softc *)bus;
	err = usb_allocmem(&sc->sc_bus, size, 0, dma);
#endif
	return (err);
}

void
musb_freem(struct usbd_bus *bus, usb_dma_t *dma)
{
#if 1
	free(*dma,M_DEVBUF);
	*dma = 0;
#else
	struct musb_softc *sc = (struct musb_softc *)bus;
	usb_freemem(&sc->sc_bus, dma);
#endif
}

usbd_xfer_handle
musb_allocx(struct usbd_bus *bus)
{
	struct musb_softc *sc = (struct musb_softc *)bus;
	usbd_xfer_handle xfer;

	xfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);
	if (xfer != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, next);
	} else {
		xfer = malloc(sizeof(struct musb_xfer), M_USB, M_NOWAIT);
	}
	if (xfer != NULL) {
		memset(xfer, 0, sizeof (struct musb_xfer));
	}
	return (xfer);
}

void
musb_freex(struct usbd_bus *bus, usbd_xfer_handle xfer)
{
	struct musb_softc *sc = (struct musb_softc *)bus;

	SIMPLEQ_INSERT_HEAD(&sc->sc_free_xfers, xfer, next);
}

/*

				Utility functions

*/

Static void
musb_device_clear_toggle(usbd_pipe_handle pipe)
{
	struct musb_pipe *epipe = (struct musb_pipe *)pipe;

	DPRINTF(("musb_device_clear_toggle: epipe=%p\n",
		 epipe));

	epipe->clear_toggle = true;
}

Static void
musb_noop(usbd_pipe_handle pipe)
{
}

Static u32 musb_calc_port_status(int devctl,int power,u32 port_status)
{
	/* Calculate new port_status flags */
	int i=0;
	if(devctl & DEVCTL_HOSTMODE)
	{
		i |= UPS_CURRENT_CONNECT_STATUS; /* Always connected when in host mode? */
		i |= UPS_PORT_ENABLED; /* Always enabled? */
		if(power & POWER_SUSPENDM)
			i |= UPS_SUSPEND;
		/* todo: overcurrent */
		if(power & POWER_RESET)
			i |= UPS_RESET;
		i |= UPS_PORT_POWER; /* Always powered in host mode? */
		if(power & POWER_HSMODE)
			i |= UPS_HIGH_SPEED;
		else if(devctl & DEVCTL_LSDEV)
			i |= UPS_LOW_SPEED;
	}
	/* Update wPortStatus */
	if((i & UPS_CURRENT_CONNECT_STATUS) != (port_status & UPS_CURRENT_CONNECT_STATUS))
		i |= UPS_C_CONNECT_STATUS<<16;
	if(!(i & UPS_PORT_ENABLED) && (port_status & UPS_PORT_ENABLED))
		i |= UPS_C_PORT_ENABLED<<16;
	if((i & UPS_OVERCURRENT_INDICATOR) != (port_status & UPS_OVERCURRENT_INDICATOR))
		i |= UPS_C_OVERCURRENT_INDICATOR<<16;
	if((i & UPS_RESET) && !(port_status & UPS_RESET))
		i |= UPS_C_PORT_RESET<<16;
	return (port_status & 0xffff0000) | i;
}

Static void musb_abort_xfer(usbd_xfer_handle xfer,usbd_status status)
{
	struct musb_xfer *ex = MXFER(xfer);
	musb_softc_t *sc = (musb_softc_t *)xfer->pipe->device->bus;
	struct musb_pipe *p = (struct musb_pipe *) xfer->pipe;
	int s = splusb();
	/* If the pipe has an endpoint assigned, the transfer may be in progress */
	if(p->ep != -1)
	{
		/* If this is the head item in the queue (currently, it always is) then it means the transfer is probably in progress */
		if(SIMPLEQ_FIRST(&p->pipe.queue) == xfer)
		{
			/* This transfer is (probably) active. If the allocated endpoint is active, and pointing to this pipe, abort the transfer and mark the endpoint as free */
			if(p->tx && sc->host_tx[p->ep].state && (sc->host_tx[p->ep].pipe == p))
			{
				sc->host_tx[p->ep].pipe = 0;
				/* If this was a control transfer, we need to start the next */
				if(UE_GET_ADDR(xfer->pipe->endpoint->edesc->bEndpointAddress) == 0)
				{
					/* Must also set EP state to idle otherwise next transfer won't start */
					sc->host_tx[0].state = HOST_EP0_STATE_IDLE;
					/* Also try a teardown procedure */
					musb_base->csr.host_ep0.host_csr0 = (musb_base->csr.host_ep0.host_csr0 | HOST_CSR0_FLUSHFIFO) & ~HOST_CSR0_REQPKT;
					WAITON(musb_base->csr.host_ep0.host_csr0 & (HOST_CSR0_RXPKTRDY | HOST_CSR0_TXPKTRDY));
					musb_base->csr.host_ep0.host_csr0 &= ~(HOST_CSR0_FLUSHFIFO | HOST_CSR0_SETUPPKT);
					struct musb_xfer *ex2 = SIMPLEQ_FIRST(&sc->host_ep0_queue);
					if(ex2)
					{
						DPRINTFN(10,("musb_abort_xfer: Starting control xfer=%p\n",ex2));
						SIMPLEQ_REMOVE_HEAD(&sc->host_ep0_queue,next);
						musb_start_control(sc,ex2);
					}
				}
				else
				{
					/* Also try a teardown procedure */
					musb_base->csr.host_ep[p->ep].host_txcsr = (musb_base->csr.host_ep[p->ep].host_txcsr | HOST_TXCSR_FLUSHFIFO) & ~HOST_TXCSR_TXPKTRDY;
					WAITON(musb_base->csr.host_ep[p->ep].host_txcsr & HOST_TXCSR_FIFONOTEMPTY);
					musb_base->csr.host_ep[p->ep].host_txcsr &= ~HOST_TXCSR_FLUSHFIFO;
				}
				p->ep = -1;
			}
			else if(!p->tx && sc->host_rx[p->ep].state && (sc->host_rx[p->ep].pipe == p))
			{
				sc->host_rx[p->ep].pipe = 0;
				/* Also try a teardown procedure */
				musb_base->csr.host_ep[p->ep].host_rxcsr = (musb_base->csr.host_ep[p->ep].host_rxcsr | HOST_RXCSR_FLUSHFIFO) & ~HOST_RXCSR_REQPKT;
				WAITON(musb_base->csr.host_ep[p->ep].host_rxcsr & HOST_RXCSR_RXPKTRDY);
				musb_base->csr.host_ep[p->ep].host_rxcsr &= ~HOST_RXCSR_FLUSHFIFO;
				p->ep = -1;
			}
		}
	}
	/* If this is a control transfer, it may be in the ep0 queue */
	if(UE_GET_ADDR(xfer->pipe->endpoint->edesc->bEndpointAddress) == 0)
	{
		bool in = false;
		struct musb_xfer *ex2;
		SIMPLEQ_FOREACH(ex2,&sc->host_ep0_queue,next) /* LAME */
		{
			if(ex2 == ex)
			{
				in = true;
				break;
			}
		}
		if(in)
			SIMPLEQ_REMOVE(&sc->host_ep0_queue,ex,musb_xfer,next);
	}
	/* Now set status and let the driver know */
	xfer->status = status;
	callout_stop(&(xfer->timeout_handle));
	usb_transfer_complete(xfer);
	splx(s);
}

Static void musb_timeout(void *addr)
{
	/* Let's see if this works! */
	DPRINTFN(10,("musb_timeout: %p\n",addr));
	riscos_abort_pipe(addr);
}

Static void musb_program_tx_address(musb_softc_t *sc,struct musb_xfer *ex,int ep)
{
	/* Transaction translation stuff */
	int addr = ex->xfer.pipe->device->address & TXFUNCADDR_FUNCADDR;
	int hubaddr = 0;
	int hubport = 0;
	if(ex->xfer.pipe->device->myhsport && (ex->xfer.pipe->device->speed != USB_SPEED_HIGH))
	{
		hubaddr = ex->xfer.pipe->device->myhsport->parent->address & TXHUBADDR_HUBADDR;
		hubport = ex->xfer.pipe->device->myhsport->portno & TXHUBPORT_HUBPORT;
		if(ex->xfer.pipe->device->myhsport->tt && ex->xfer.pipe->device->myhsport->parent->ddesc.bDeviceProtocol == UDPROTO_HSHUBMTT) /* Is this the correct thing we're checking? argh! */
			hubaddr |= TXHUBADDR_MULT_TRANS;
	}
	DPRINTFN(10,("musb_program_tx_address: ep %d addr %02x hubaddr %02x hubport %02x\n",ep,addr,hubaddr,hubport));
	/* Even though the manual says these registers only exist for endpoints 0-4, Linux makes no attempt to avoid programming them for the other endpoints (and if they're not programmed, how the hell does the controller know where to send the data?)
	   So we'll just assume that the manual is wrong and that the RX/TX address registers exist for all endpoints */
	musb_base->ep_host[ep].txfuncaddr = addr;
	musb_base->ep_host[ep].txhubaddr = hubaddr;
	musb_base->ep_host[ep].txhubport = hubport;
}

Static void musb_program_rx_address(musb_softc_t *sc,struct musb_xfer *ex,int ep)
{
	/* Transaction translation stuff */
	int addr = ex->xfer.pipe->device->address & RXFUNCADDR_FUNCADDR;
	int hubaddr = 0;
	int hubport = 0;
	if(ex->xfer.pipe->device->myhsport && (ex->xfer.pipe->device->speed != USB_SPEED_HIGH))
	{
		hubaddr = ex->xfer.pipe->device->myhsport->parent->address & RXHUBADDR_HUBADDR;
		hubport = ex->xfer.pipe->device->myhsport->portno & RXHUBPORT_HUBPORT;
		if(ex->xfer.pipe->device->myhsport->tt && ex->xfer.pipe->device->myhsport->parent->ddesc.bDeviceProtocol == UDPROTO_HSHUBMTT) /* Is this the correct thing we're checking? argh! */
			hubaddr |= RXHUBADDR_MULT_TRANS;
	}
	DPRINTFN(10,("musb_program_rx_address: ep %d addr %02x hubaddr %02x hubport %02x\n",ep,addr,hubaddr,hubport));
	/* Even though the manual says these registers only exist for endpoints 0-4, Linux makes no attempt to avoid programming them for the other endpoints (and if they're not programmed, how the hell does the controller know where to send the data?)
	   So we'll just assume that the manual is wrong and that the RX/TX address registers exist for all endpoints */
	musb_base->ep_host[ep].rxfuncaddr = addr;
	musb_base->ep_host[ep].rxhubaddr = hubaddr;
	musb_base->ep_host[ep].rxhubport = hubport;
}

Static void musb_start_control(musb_softc_t *sc,struct musb_xfer *ex)
{
	struct musb_pipe *epipe = (struct musb_pipe *)ex->xfer.pipe;
	/* Start the given control xfer */
	sc->host_tx[0].pipe = epipe;
	epipe->ep = 0;
	epipe->tx = true;
	sc->host_tx[0].state = HOST_EP0_STATE_SETUP;
	sc->host_tx[0].remain = UGETW(ex->xfer.request.wLength);
	sc->host_tx[0].buf = KERNADDR(&ex->xfer.dmabuf,0);
	/* Control transfers use the TX address, it seems */
	musb_program_tx_address(sc,ex,0);
	/* Setting the speed is usually a good idea. Which is why the manual makes no mention of it! */
	switch(ex->xfer.pipe->device->speed)
	{
	case USB_SPEED_LOW: musb_base->csr.host_ep0.host_type0 = HOST_TYPE0_SPEED_LOW; break;
	case USB_SPEED_FULL: musb_base->csr.host_ep0.host_type0 = HOST_TYPE0_SPEED_FULL; break;
	case USB_SPEED_HIGH: musb_base->csr.host_ep0.host_type0 = HOST_TYPE0_SPEED_HIGH; break;
	}
	DPRINTFN(10,("musb_start_control: Set speed to %02x\n",musb_base->csr.host_ep0.host_type0));
	/* Flush any stale data */
	musb_base->csr.host_ep0.host_csr0 |= HOST_CSR0_FLUSHFIFO;
	WAITON(musb_base->csr.host_ep0.host_csr0 & (HOST_CSR0_RXPKTRDY | HOST_CSR0_TXPKTRDY));
	musb_base->csr.host_ep0.host_csr0 &= ~HOST_CSR0_FLUSHFIFO;
	musb_fifowrite(0,&ex->xfer.request,8);
	musb_base->csr.host_ep0.host_csr0 |= HOST_CSR0_SETUPPKT | HOST_CSR0_TXPKTRDY;
	if(ex->xfer.timeout && !sc->sc_bus.use_polling) {
		callout_reset(&(ex->xfer.timeout_handle), (MS_TO_TICKS(ex->xfer.timeout)), (musb_timeout), (ex));
	}
	/* done; interrupt routine will handle the rest */
}

Static void musb_start_bulkinterrupt(musb_softc_t *sc,struct musb_xfer *ex,int ep)
{
	usb_endpoint_descriptor_t *ed = ex->xfer.pipe->endpoint->edesc;
	struct usbd_device *dev = ex->xfer.pipe->device;
	struct musb_pipe *epipe = (struct musb_pipe *)ex->xfer.pipe;
	int endpt = ed->bEndpointAddress;
	int i;
	/* Starts the given interrupt xfer, on the given endpoint */
	/* Is this IN or OUT? */
	if(UE_GET_DIR(endpt) == UE_DIR_IN)
	{
		sc->host_rx[ep].pipe = epipe;
		epipe->tx = false;
		epipe->ep = ep;
		sc->host_rx[ep].state = HOST_EP_STATE_IN;
		sc->host_rx[ep].remain = ex->xfer.length;
		sc->host_rx[ep].buf = KERNADDR(&ex->xfer.dmabuf, 0);
		musb_program_rx_address(sc,ex,ep);
		/* HOST_RXTYPE */
		i = UE_GET_ADDR(endpt) & HOST_RXTYPE_RENDPN;
		switch(dev->speed)
		{
		case USB_SPEED_LOW: i |= HOST_RXTYPE_SPEED_LOW; break;
		case USB_SPEED_FULL: i |= HOST_RXTYPE_SPEED_FULL; break;
		case USB_SPEED_HIGH: i |= HOST_RXTYPE_SPEED_HIGH; break;
		}
		int interval;
		if((ed->bmAttributes & UE_XFERTYPE) == UE_INTERRUPT)
		{
			i |= HOST_RXTYPE_PROT_INTERRUPT;
			interval = ed->bInterval;
		}
		else
		{
			i |= HOST_RXTYPE_PROT_BULK;
			interval = ed->bInterval;
		}
		DPRINTFN(15,("musb_start_bulkinterrupt: RXTYPE %02x wMaxPacketSize %d interval %d xfer.length %d clear_toggle %d\n",i,UGETW(ed->wMaxPacketSize),interval,ex->xfer.length,epipe->clear_toggle));
		musb_base->csr.host_ep[ep].host_rxtype = i;
		/* RXMAXP */
		musb_base->csr.host_ep[ep].rxmaxp = UGETW(ed->wMaxPacketSize) & RXMAXP_MAXPAYLOAD; /* TODO - set 'M' according to the bit on page 271 of the USB spec */
		/* HOST_RXINTERVAL */
		musb_base->csr.host_ep[ep].host_rxinterval = interval;
		/* INTRRXE */
		musb_base->common.intrrxe |= (1<<ep);
		/* HOST_RXCSR
		   - No DMA
		   - Normal PING flow control
		   - Clear the data toggle
		   - Flush the FIFO
		     - We do this first, just to make sure it doesn't try anything silly
		*/
		if(musb_base->csr.host_ep[ep].host_rxcsr & HOST_RXCSR_RXPKTRDY)
		{
			musb_base->csr.host_ep[ep].host_rxcsr |= HOST_RXCSR_FLUSHFIFO;
			WAITON(musb_base->csr.host_ep[ep].host_rxcsr & HOST_RXCSR_RXPKTRDY);
		}
		musb_base->csr.host_ep[ep].host_rxcsr = (musb_base->csr.host_ep[ep].host_rxcsr | (epipe->clear_toggle?HOST_RXCSR_CLRDATATOG:0) | HOST_RXCSR_REQPKT) & ~(HOST_RXCSR_DMAEN | HOST_RXCSR_DSINYET | HOST_RXCSR_DMAMODE | HOST_RXCSR_FLUSHFIFO);
		epipe->clear_toggle = false;
		/* Done? */
	}
	else
	{
		sc->host_tx[ep].pipe = epipe;
		epipe->tx = true;
		epipe->ep = ep;
		sc->host_tx[ep].state = HOST_EP_STATE_OUT;
		sc->host_tx[ep].remain = ex->xfer.length;
		sc->host_tx[ep].buf = KERNADDR(&ex->xfer.dmabuf, 0);
		sc->host_tx[ep].null_packet = (ex->xfer.flags & USBD_FORCE_SHORT_XFER) && !(ex->xfer.length % UGETW(ed->wMaxPacketSize));
		musb_program_tx_address(sc,ex,ep);
		/* HOST_TXTYPE */
		i = UE_GET_ADDR(endpt) & HOST_TXTYPE_TENDPN;
		switch(dev->speed)
		{
		case USB_SPEED_LOW: i |= HOST_TXTYPE_SPEED_LOW; break;
		case USB_SPEED_FULL: i |= HOST_TXTYPE_SPEED_FULL; break;
		case USB_SPEED_HIGH: i |= HOST_TXTYPE_SPEED_HIGH; break;
		}
		int interval;
		if((ed->bmAttributes & UE_XFERTYPE) == UE_INTERRUPT)
		{
			i |= HOST_TXTYPE_PROT_INTERRUPT;
			interval = ed->bInterval;
		}
		else
		{
			i |= HOST_TXTYPE_PROT_BULK;
			interval = ed->bInterval;
		}
		DPRINTFN(15,("musb_start_bulkinterrupt: TXTYPE %02x wMaxPacketSize %d interval %d xfer.length %d clear_toggle %d\n",i,UGETW(ed->wMaxPacketSize),interval,ex->xfer.length,epipe->clear_toggle));
		musb_base->csr.host_ep[ep].host_txtype = i;
		/* TXMAXP */
		musb_base->csr.host_ep[ep].txmaxp = UGETW(ed->wMaxPacketSize) & TXMAXP_MAXPAYLOAD; /* TODO - What do we do with the 'M' field? Manual makes no mention, and Linux seems to ignore it... */
		/* HOST_TXINTERVAL */
		musb_base->csr.host_ep[ep].host_txinterval = interval;
		/* INTRTXE */
		musb_base->common.intrtxe |= (1<<ep);
		/* HOST_TXCSR
		   - No DMA
		   - Normal PING flow control
		   - Clear the data toggle
		   - Flush the FIFO
		     - We do this first, just to make sure it doesn't try anything silly
		*/
		if(musb_base->csr.host_ep[ep].host_txcsr & HOST_TXCSR_TXPKTRDY)
		{
			musb_base->csr.host_ep[ep].host_txcsr |= HOST_TXCSR_FLUSHFIFO;
			WAITON(musb_base->csr.host_ep[ep].host_txcsr & HOST_TXCSR_TXPKTRDY);
		}
		musb_base->csr.host_ep[ep].host_txcsr = (musb_base->csr.host_ep[ep].host_txcsr | (epipe->clear_toggle?HOST_TXCSR_CLRDATATOG:0)) & ~(HOST_TXCSR_DMAEN | HOST_TXCSR_FRCDATATOG | HOST_TXCSR_DMAMODE | HOST_TXCSR_FLUSHFIFO);
		epipe->clear_toggle = false;
		/* Load first packet (wMaxPacketSize?) */
		int count = min(sc->host_tx[ep].remain,UGETW(ed->wMaxPacketSize));
		sc->host_tx[ep].remain -= count;
		sc->host_tx[ep].buf = musb_fifowrite(ep,sc->host_tx[ep].buf,count);
		musb_base->csr.host_ep[ep].host_txcsr |= HOST_TXCSR_TXPKTRDY;
		/* Done? */
	}
	if(ex->xfer.timeout && !sc->sc_bus.use_polling) {
		callout_reset(&(ex->xfer.timeout_handle), (MS_TO_TICKS(ex->xfer.timeout)), (musb_timeout), (ex));
	}
}

Static void musb_pcd(musb_softc_t *sc,usbd_xfer_handle xfer)
{
	usbd_pipe_handle pipe;
	u_char *p;
	if(xfer == NULL)
		return;
	pipe = xfer->pipe;
	p = KERNADDR(&xfer->dmabuf,0);
	memset(p,0,xfer->length);
	*p = 2; /* we only have one port */
	DPRINTF(("musb_pcd: Notfifying USB driver of port change\n"));
	xfer->actlen = xfer->length;
	xfer->status = USBD_NORMAL_COMPLETION;
	usb_transfer_complete(xfer);
}


/*

				Main interrupt routine

*/

int retry_counter = 3;

int musb_intr(musb_softc_t *sc)
{
	/* return 0 for success, 1 for failure */

	/* Read IRQ state and process according to flowchart (figure 23-5 spruf98b, page 3078) */
	/* todo - more structured approach like musb_interrupt in the linux driver? could make transmit/receive interrupt processing a bit faster */
	/* todo - protect against early irqs before everything is set up */
	int intrusb = musb_base->common.intrusb;
	int devctl = musb_base->devctl;
	int isbdevice = devctl & DEVCTL_BDEVICE;
	int ishost = devctl & DEVCTL_HOSTMODE;
	unsigned int ep_tx = musb_base->common.intrtx;
	unsigned int ep_rx = musb_base->common.intrrx;
	riscos_irqclear(); /* todo - verify the above regs are clear-on-read */
	DPRINTFN(10,("irq %02x devctl %02x (%c %s)\n",intrusb,devctl,(isbdevice?'B':'A'),(ishost?"Host":"Peripheral")));
	if(intrusb & INTRUSB_RESUME)
	{
		DPRINTFN(11,("INTRUSB_RESUME\n"));
	}
	if(!isbdevice)
	{
		if(intrusb & INTRUSB_SESSREQ)
		{
			DPRINTFN(11,("INTRUSB_SESSREQ\n"));
		}
	}
	if(intrusb & INTRUSB_VBUSERR)
	{
		DPRINTFN(11,("INTRUSB_VBUSERR\n"));
		if(retry_counter)
		{
			retry_counter--;
			DPRINTFN(10,("%d VBUS retries left\n",retry_counter));
			musb_base->devctl = musb_base->devctl | DEVCTL_SESSION;
		} 
	}
	if(ishost)
	{
		if(intrusb & INTRUSB_CONN)
		{
			DPRINTFN(11,("INTRUSB_CONN\n"));
		}
		if(intrusb & INTRUSB_RESET_BABBLE)
		{
			DPRINTFN(11,("INTRUSB_RESET_BABBLE\n"));
		}
		if(ep_tx & 1)
		{
			//DPRINTFN(12,("EP0 host IRQ\n"));
			musb_ep0_host(sc);
		}
		int i=0;
		ep_rx = ep_rx>>1;
		do {
			i++;
			if(ep_rx & 1)
			{
				//DPRINTFN(12,("EP%d host RX\n",i));
				musb_receive_host(sc,i);
			}
			ep_rx = ep_rx>>1;
		} while(ep_rx);
		ep_tx = ep_tx>>1;
		i=0;
		do {
			i++;
			if(ep_tx & 1)
			{
				//DPRINTFN(12,("EP%d host TX\n",i));
				musb_transmit_host(sc,i);
			}
			ep_tx = ep_tx>>1;
		} while(ep_tx);
	}
	else
	{
		/* todo - surely we need to monitor INTRUSB_RESET_BABBLE here, to detect resets? */
		if(ep_tx & 1)
		{
			//DPRINTFN(12,("EP0 peri IRQ\n"));
			musb_ep0_peri(sc);
		}
		int i=0;
		ep_rx = ep_rx>>1;
		do {
			i++;
			if(ep_rx & 1)
				DPRINTFN(12,("EP%d peri RX\n",i));
			ep_rx = ep_rx>>1;
		} while(ep_rx);
		ep_tx = ep_tx>>1;
		i=0;
		do {
			i++;
			if(ep_tx & 1)
				DPRINTFN(12,("EP%d peri TX\n",i));
			ep_tx = ep_tx>>1;
		} while(ep_tx);
	}
	if(intrusb & INTRUSB_SOF)
	{
		DPRINTFN(11,("INTRUSB_SOF\n"));
	}
	if(intrusb & INTRUSB_DISCON)
	{
		DPRINTFN(11,("INTRUSB_DISCON\n"));
		/* todo - this is probably a pretty good indicator that we should reset all our state vars, and cancel any pending xfers... */
	}
	if(intrusb & INTRUSB_SUSPEND)
	{
		DPRINTFN(11,("INTRUSB_SUSPEND\n"));
	}
	/* Check if the interrupt caused a port status change */
	u32 port_status = musb_calc_port_status(musb_base->devctl,musb_base->common.power,sc->port_status);
	if(port_status != sc->port_status)
	{
		DPRINTFN(10,("intr detected PCD, new status %04x change %04x\n",port_status&0xffff,port_status>>16));
		sc->port_status = port_status;
		musb_pcd(sc,sc->sc_intrxfer);
	}
	/* Just claim we've done it all */
	return 0;
}

/*

				Software root hub

*/

Static usb_device_descriptor_t musb_devd = {
	USB_DEVICE_DESCRIPTOR_SIZE,
	UDESC_DEVICE,		/* type */
	{0x00, 0x02},		/* USB version */
	UDCLASS_HUB,		/* class */
	UDSUBCLASS_HUB,		/* subclass */
	UDPROTO_HSHUBSTT,	/* protocol */
	64,			/* max packet */
	{0},{0},{0x00,0x01},	/* device id */
	1,2,0,			/* string indicies */
	1			/* # of configurations */
};

Static usb_device_qualifier_t musb_odevd = {
	USB_DEVICE_DESCRIPTOR_SIZE,
	UDESC_DEVICE_QUALIFIER,	/* type */
	{0x00, 0x02},		/* USB version */
	UDCLASS_HUB,		/* class */
	UDSUBCLASS_HUB,		/* subclass */
	UDPROTO_FSHUB,		/* protocol */
	64,			/* max packet */
	1,			/* # of configurations */
	0
};

Static usb_config_descriptor_t musb_confd = {
	USB_CONFIG_DESCRIPTOR_SIZE,
	UDESC_CONFIG,
	{USB_CONFIG_DESCRIPTOR_SIZE +
	 USB_INTERFACE_DESCRIPTOR_SIZE +
	 USB_ENDPOINT_DESCRIPTOR_SIZE},
	1,
	1,
	0,
	UC_SELF_POWERED,
	0			/* max power */
};

Static usb_interface_descriptor_t musb_ifcd = {
	USB_INTERFACE_DESCRIPTOR_SIZE,
	UDESC_INTERFACE,
	0,
	0,
	1,
	UICLASS_HUB,
	UISUBCLASS_HUB,
	UIPROTO_HSHUBSTT,
	0
};

#define MUSB_INTR_ENDPT 1

Static usb_endpoint_descriptor_t musb_endpd = {
	USB_ENDPOINT_DESCRIPTOR_SIZE,
	UDESC_ENDPOINT,
	UE_DIR_IN | MUSB_INTR_ENDPT,
	UE_INTERRUPT,
	{8, 0},			/* max packet */
	255
};

Static usb_hub_descriptor_t musb_hubd = {
	USB_HUB_DESCRIPTOR_SIZE,
	UDESC_HUB,
	0,
	{0,0},
	0,
	0,
	{0},
};

Static int
musb_str(usb_string_descriptor_t* p, int l, char *s)
{
	int i;

	if (l == 0)
		return (0);
	p->bLength = 2 * strlen(s) + 2;
	if (l == 1)
		return (1);
	p->bDescriptorType = UDESC_STRING;
	l -= 2;
	for (i = 0; s[i] && l > 1; i++, l -= 2)
		USETW2(p->bString[i], 0, s[i]);
	return (2*i+2);
}

Static usbd_status
musb_root_ctrl_transfer(usbd_xfer_handle xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (musb_root_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

Static usbd_status
musb_root_ctrl_start(usbd_xfer_handle xfer)
{
	musb_softc_t *sc = (musb_softc_t *)xfer->pipe->device->bus;
	usb_device_request_t *req;
	void *buf = NULL;
	int port;
	int s, len, value, index, l, totlen = 0;
	usb_port_status_t ps;
	usb_hub_descriptor_t hubd;
	usbd_status err;
	u_int32_t v;
	int devctl,power;

	if (sc->sc_dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & URQ_REQUEST))
		/* XXX panic */
		return (USBD_INVAL);
#endif
	req = &xfer->request;

        DPRINTFN(4,("musb_root_ctrl_start: type=0x%02x request=%02x\n",
		    req->bmRequestType, req->bRequest));

	len = UGETW(req->wLength);
	value = UGETW(req->wValue);
	index = UGETW(req->wIndex);

	if (len != 0)
		buf = KERNADDR(&xfer->dmabuf, 0);

#define C(x,y) ((x) | ((y) << 8))
	switch(C(req->bRequest, req->bmRequestType)) {
	case C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):
	case C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):
	case C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):
		/*
		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops
		 * for the integrated root hub.
		 */
		break;
	case C(UR_GET_CONFIG, UT_READ_DEVICE):
		if (len > 0) {
			*(u_int8_t *)buf = sc->sc_conf;
			totlen = 1;
		}
		break;
	case C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):
                DPRINTFN(8,("musb_root_ctrl_start: wValue=0x%04x\n", value));
		switch(value >> 8) {
		case UDESC_DEVICE:
			if ((value & 0xff) != 0) {
				err = USBD_IOERROR;
				goto ret;
			}
			totlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);
			USETW(musb_devd.idVendor, sc->sc_id_vendor);
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
			memcpy(buf, (void*) &musb_devd, l);
#else
			memcpy(buf, &musb_devd, l);
#endif
			break;
		/*
		 * We can't really operate at another speed, but the spec says
		 * we need this descriptor.
		 */
		case UDESC_DEVICE_QUALIFIER:
			if ((value & 0xff) != 0) {
				err = USBD_IOERROR;
				goto ret;
			}
			totlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
			memcpy(buf, (void*) &musb_odevd, l);
#else
			memcpy(buf, &musb_odevd, l);
#endif
			break;
		/*
		 * We can't really operate at another speed, but the spec says
		 * we need this descriptor.
		 */
		case UDESC_OTHER_SPEED_CONFIGURATION:
		case UDESC_CONFIG:
			if ((value & 0xff) != 0) {
				err = USBD_IOERROR;
				goto ret;
			}
			totlen = l = min(len, USB_CONFIG_DESCRIPTOR_SIZE);
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
			memcpy(buf, (void*) &musb_confd, l);
#else
			memcpy(buf, &musb_confd, l);
#endif
			((usb_config_descriptor_t *)buf)->bDescriptorType =
				value >> 8;
			buf = (char *)buf + l;
			len -= l;
			l = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);
			totlen += l;
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
			memcpy(buf, (void*) &musb_ifcd, l);
#else
			memcpy(buf, &musb_ifcd, l);
#endif
			buf = (char *)buf + l;
			len -= l;
			l = min(len, USB_ENDPOINT_DESCRIPTOR_SIZE);
			totlen += l;
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
			memcpy(buf, (void*)&musb_endpd, l);
#else
			memcpy(buf, &musb_endpd, l);
#endif
			break;
		case UDESC_STRING:
			if (len == 0)
				break;
			*(u_int8_t *)buf = 0;
			totlen = 1;
			switch (value & 0xff) {
                        case 0: /* Language table */
                                totlen = musb_str(buf, len, "\001");
                                break;
			case 1: /* Vendor */
				totlen = musb_str(buf, len, sc->sc_vendor);
				break;
			case 2: /* Product */
				totlen = musb_str(buf, len, "MUSBMHDRC root hub");
				break;
			}
			break;
		default:
			err = USBD_IOERROR;
			goto ret;
		}
		break;
	case C(UR_GET_INTERFACE, UT_READ_INTERFACE):
		if (len > 0) {
			*(u_int8_t *)buf = 0;
			totlen = 1;
		}
		break;
	case C(UR_GET_STATUS, UT_READ_DEVICE):
		if (len > 1) {
			USETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);
			totlen = 2;
		}
		break;
	case C(UR_GET_STATUS, UT_READ_INTERFACE):
	case C(UR_GET_STATUS, UT_READ_ENDPOINT):
		if (len > 1) {
			USETW(((usb_status_t *)buf)->wStatus, 0);
			totlen = 2;
		}
		break;
	case C(UR_SET_ADDRESS, UT_WRITE_DEVICE):
		if (value >= USB_MAX_DEVICES) {
			err = USBD_IOERROR;
			goto ret;
		}
		sc->sc_addr = value;
		break;
	case C(UR_SET_CONFIG, UT_WRITE_DEVICE):
		if (value != 0 && value != 1) {
			err = USBD_IOERROR;
			goto ret;
		}
		sc->sc_conf = value;
		break;
	case C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):
		break;
	case C(UR_SET_FEATURE, UT_WRITE_DEVICE):
	case C(UR_SET_FEATURE, UT_WRITE_INTERFACE):
	case C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):
		err = USBD_IOERROR;
		goto ret;
	case C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):
		break;
	case C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):
		break;
	/* Hub requests */
	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_DEVICE):
		break;
	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_OTHER):
                DPRINTFN(8, ("musb_root_ctrl_start: UR_CLEAR_PORT_FEATURE "
			     "port=%d feature=%d\n",
			     index, value));
		if (index != 1) {
			err = USBD_IOERROR;
			goto ret;
		}
		switch(value) {
		case UHF_PORT_ENABLE:
			break;
		case UHF_PORT_SUSPEND:
			// todo
			break;
		case UHF_PORT_POWER:
			// todo
			break;
		case UHF_PORT_TEST:
                        DPRINTFN(2,("musb_root_ctrl_start: clear port test "
				    "%d\n", index));
			break;
		case UHF_PORT_INDICATOR:
                        DPRINTFN(2,("musb_root_ctrl_start: clear port ind "
				    "%d\n", index));
			break;
		case UHF_C_PORT_CONNECTION:
			break;
		case UHF_C_PORT_ENABLE:
			break;
		case UHF_C_PORT_SUSPEND:
			/* how? */
			break;
		case UHF_C_PORT_OVER_CURRENT:
			break;
		case UHF_C_PORT_RESET:
			break;
		default:
			err = USBD_IOERROR;
			goto ret;
		}
		sc->port_status &= ~(1 << value);
		break;
	case C(UR_GET_DESCRIPTOR, UT_READ_CLASS_DEVICE):
                if ((value & 0xff) != 0) {
			err = USBD_IOERROR;
			goto ret;
		}
		hubd = musb_hubd;
		hubd.bNbrPorts = 1;
		USETW(hubd.wHubCharacteristics,UHD_PWR_INDIVIDUAL | UHD_OC_NONE);
		hubd.bPwrOn2PwrGood = 5;
		hubd.DeviceRemovable[0] = 0;
		hubd.bDescLength = USB_HUB_DESCRIPTOR_SIZE + 1;
		l = min(len, hubd.bDescLength);
		totlen = l;
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
		memcpy(buf, (void*) &hubd, l);
#else
		memcpy(buf, &hubd, l);
#endif
		break;
	case C(UR_GET_STATUS, UT_READ_CLASS_DEVICE):
		if (len != 4) {
			err = USBD_IOERROR;
			goto ret;
		}
		memset(buf, 0, len); /* ? XXX */
		totlen = len;
		break;
	case C(UR_GET_STATUS, UT_READ_CLASS_OTHER):
                DPRINTFN(8,("musb_root_ctrl_start: get port status i=%d\n",
			    index));
		if (index != 1) {
			err = USBD_IOERROR;
			goto ret;
		}
		if (len != 4) {
			err = USBD_IOERROR;
			goto ret;
		}
		/* Deduce the port status */
		devctl = musb_base->devctl;
		power = musb_base->common.power;
		sc->port_status = musb_calc_port_status(devctl,power,sc->port_status);
		DPRINTFN(8,("musb_root_ctrl_start: Status %04x change %04x\n",sc->port_status&0xffff,sc->port_status>>16));
		USETW(ps.wPortStatus, sc->port_status);
		USETW(ps.wPortChange, sc->port_status>>16);
		l = min(len, sizeof ps);
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
		memcpy(buf, (void*) &ps, l);
#else
		memcpy(buf, &ps, l);
#endif
		totlen = l;
		break;
	case C(UR_SET_DESCRIPTOR, UT_WRITE_CLASS_DEVICE):
		err = USBD_IOERROR;
		goto ret;
	case C(UR_SET_FEATURE, UT_WRITE_CLASS_DEVICE):
		break;
	case C(UR_SET_FEATURE, UT_WRITE_CLASS_OTHER):
		if (index != 1) {
			err = USBD_IOERROR;
			goto ret;
		}
//		port = EHCI_PORTSC(index);
//		v = EOREAD4(sc, port) &~ EHCI_PS_CLEAR;
		switch(value) {
		case UHF_PORT_ENABLE:
//			EOWRITE4(sc, port, v | EHCI_PS_PE);
			break;
		case UHF_PORT_SUSPEND:
//			EOWRITE4(sc, port, v | EHCI_PS_SUSP);
			break;
		case UHF_PORT_RESET:
                        DPRINTFN(5,("musb_root_ctrl_start: reset port %d\n",
				    index));
			/* Begin reset signalling */
			if(musb_base->devctl & DEVCTL_HOSTMODE)
			{
				musb_base->common.power |= POWER_RESET | POWER_HSEN; /* todo - should usb driver control HSEN? */
				/* Wait 20ms for reset to occur */
				delay(20000);
				/* Now clear the reset bit, and all should be good */
				musb_base->common.power &= ~POWER_RESET;
				DPRINTF(("musb port %d reset\n", index));
				sc->port_status |= 1 << UHF_C_PORT_RESET;
			}
			else
			{
				DPRINTF(("musb port %d reset ignored - not in host mode!\n", index));
				err = USBD_IOERROR;
				goto ret;
			}
			break;
		case UHF_PORT_POWER:
                        DPRINTFN(2,("musb_root_ctrl_start: set port power "
				    "%d\n", index));
//			EOWRITE4(sc, port, v | EHCI_PS_PP);
			break;
		case UHF_PORT_TEST:
                        DPRINTFN(2,("musb_root_ctrl_start: set port test "
				    "%d\n", index));
			break;
		case UHF_PORT_INDICATOR:
                        DPRINTFN(2,("musb_root_ctrl_start: set port ind "
				    "%d\n", index));
//			EOWRITE4(sc, port, v | EHCI_PS_PIC);
			break;
		default:
			err = USBD_IOERROR;
			goto ret;
		}
//		sc->port_status |= (1 << value);
		break;
	case C(UR_CLEAR_TT_BUFFER, UT_WRITE_CLASS_OTHER):
	case C(UR_RESET_TT, UT_WRITE_CLASS_OTHER):
	case C(UR_GET_TT_STATE, UT_READ_CLASS_OTHER):
	case C(UR_STOP_TT, UT_WRITE_CLASS_OTHER):
		break;
	default:
		err = USBD_IOERROR;
		goto ret;
	}
	xfer->actlen = totlen;
	err = USBD_NORMAL_COMPLETION;
 ret:
	xfer->status = err;
	s = splusb();
	usb_transfer_complete(xfer);
	splx(s);
	return (USBD_IN_PROGRESS);
}
#undef C
d76 1
a76 6
/* Abort a root control request. */
Static void
musb_root_ctrl_abort(usbd_xfer_handle xfer)
{
	/* Nothing to do, all transfers are synchronous. */
}
d78 1
a78 7
/* Close the root pipe. */
Static void
musb_root_ctrl_close(usbd_pipe_handle pipe)
{
	DPRINTF(("musb_root_ctrl_close\n"));
	/* Nothing to do. */
}
d80 1
a80 5
void
musb_root_intr_done(usbd_xfer_handle xfer)
{
	xfer->hcpriv = NULL;
}
d82 1
a82 2
Static usbd_status
musb_root_intr_transfer(usbd_xfer_handle xfer)
d84 3
a86 9
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (musb_root_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
d89 1
a89 2
Static usbd_status
musb_root_intr_start(usbd_xfer_handle xfer)
d91 12
a102 9
	usbd_pipe_handle pipe = xfer->pipe;
	musb_softc_t *sc = (musb_softc_t *)pipe->device->bus;

	if (sc->sc_dying)
		return (USBD_IOERROR);

	sc->sc_intrxfer = xfer;

	return (USBD_IN_PROGRESS);
d105 1
a105 3
/* Abort a root interrupt request. */
Static void
musb_root_intr_abort(usbd_xfer_handle xfer)
d107 5
a111 1
	int s;
d113 4
a116 3
	if (xfer->pipe->intrxfer == xfer) {
		DPRINTF(("musb_root_intr_abort: remove\n"));
		xfer->pipe->intrxfer = NULL;
d118 14
a131 51
	xfer->status = USBD_CANCELLED;
	s = splusb();
	usb_transfer_complete(xfer);
	splx(s);
}

/* Close the root pipe. */
Static void
musb_root_intr_close(usbd_pipe_handle pipe)
{
	musb_softc_t *sc = (musb_softc_t *)pipe->device->bus;

	DPRINTF(("musb_root_intr_close\n"));

	sc->sc_intrxfer = NULL;
}

void
musb_root_ctrl_done(usbd_xfer_handle xfer)
{
	xfer->hcpriv = NULL;
}

/************************/

usbd_status
musb_open(usbd_pipe_handle pipe)
{
	usbd_device_handle dev = pipe->device;
	musb_softc_t *sc = (musb_softc_t *)dev->bus;
	usb_endpoint_descriptor_t *ed = pipe->endpoint->edesc;
	u_int8_t addr = dev->address;
	u_int8_t xfertype = ed->bmAttributes & UE_XFERTYPE;
	struct musb_pipe *epipe = (struct musb_pipe *)pipe;

	DPRINTFN(1, ("musb_open: pipe=%p, addr=%d, endpt=%d (%d)\n",
		     pipe, addr, ed->bEndpointAddress, sc->sc_addr));

	epipe->clear_toggle = true;
	epipe->ep = -1;

	if (addr == sc->sc_addr) {
		switch (ed->bEndpointAddress) {
		case USB_CONTROL_ENDPOINT:
			pipe->methods = &musb_root_ctrl_methods;
			break;
		case UE_DIR_IN | MUSB_INTR_ENDPT:
			pipe->methods = &musb_root_intr_methods;
			break;
		default:
			return (USBD_INVAL);
d133 2
a134 1
		return (USBD_NORMAL_COMPLETION);
d137 2
a138 22
	/* Check that the max packet size isn't larger than our FIFO sizes... */
	if(UGETW(ed->wMaxPacketSize) > 512)
		return (USBD_INVAL);

	switch(xfertype) {
	case UE_CONTROL:
		pipe->methods = &musb_device_ctrl_methods;
		break;
	case UE_INTERRUPT:
		pipe->methods = &musb_device_intr_methods;
		break;
	case UE_BULK:
		pipe->methods = &musb_device_bulk_methods;
		break;
	case UE_ISOCHRONOUS:
		pipe->methods = &musb_device_isoc_methods;
		return (USBD_INVAL);
	default:
		return (USBD_INVAL);
	}
	return (USBD_NORMAL_COMPLETION);
}
d140 4
a143 4
void
musb_softintr(void *v)
{
}
d145 2
a146 3
void
musb_poll(struct usbd_bus *bus)
{
d151 1
a151 1
				Ctrl funcs
d155 1
a155 2
Static usbd_status
musb_device_ctrl_transfer(usbd_xfer_handle xfer)
d159 2
d166 3
a168 43
	/* Pipe isn't running, start first */
	return (musb_device_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

Static usbd_status
musb_device_ctrl_start(usbd_xfer_handle xfer)
{
	musb_softc_t *sc = (musb_softc_t *)xfer->pipe->device->bus;
	struct musb_xfer *ex = MXFER(xfer);
	int s = splusb();
	if(sc->host_tx[0].state != HOST_EP0_STATE_IDLE)
	{
		DPRINTFN(10,("musb_device_ctrl_start: Queueing xfer=%p\n",xfer));
		/* Queue it */
		SIMPLEQ_INSERT_TAIL(&sc->host_ep0_queue,ex,next);
		((struct musb_pipe *) ex->xfer.pipe)->ep = -1;
	}
	else
	{
		DPRINTFN(10,("musb_device_ctrl_start: Starting xfer=%p\n",xfer));
		/* Start it */
		musb_start_control(sc,ex);
	}
	splx(s);
	return (USBD_IN_PROGRESS);
}

void
musb_device_ctrl_done(usbd_xfer_handle xfer)
{
	struct musb_xfer *ex = MXFER(xfer);
	musb_softc_t *sc = (musb_softc_t *)xfer->pipe->device->bus;
	DPRINTFN(10,("musb_ctrl_done: xfer=%p, length=%d\n", xfer, xfer->actlen));
	/* Nothing to do? */
}

/* Abort a device control request. */
Static void
musb_device_ctrl_abort(usbd_xfer_handle xfer)
{
	DPRINTF(("musb_device_ctrl_abort: xfer=%p\n",xfer));
	musb_abort_xfer(xfer,USBD_CANCELLED);
}
d170 2
a171 15
/* Close a device control pipe. */
Static void
musb_device_ctrl_close(usbd_pipe_handle pipe)
{
	int ep = ((struct musb_pipe *) pipe)->ep;
	DPRINTF(("musb_device_ctrl_close: pipe=%p ep=%d\n",pipe,ep));
	/* Deallocate endpoint if we own it */
	musb_softc_t *sc = (musb_softc_t *)pipe->device->bus;
	if(ep != -1)
	{
		int s = splusb();
		if(sc->host_tx[ep].pipe == (struct musb_pipe *) pipe)
			sc->host_tx[ep].pipe = 0;
		splx(s);
	}
a173 5
/*

				Bulk funcs

*/
d175 1
a175 2
Static usbd_status
musb_device_bulk_transfer(usbd_xfer_handle xfer)
d177 3
a179 1
	usbd_status err;
d181 1
a181 4
	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);
d183 3
a185 3
	/* Pipe isn't running, start first */
	return (musb_device_bulk_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}
d187 2
a188 8
usbd_status
musb_device_bulk_start(usbd_xfer_handle xfer)
{
	musb_softc_t *sc = (musb_softc_t *)xfer->pipe->device->bus;
	struct musb_xfer *ex = MXFER(xfer);
	struct musb_pipe *epipe = (struct musb_pipe *)xfer->pipe;
	int s = splusb();
	if(epipe->ep != -1)
d190 1
a190 4
		DPRINTFN(10,("musb_device_bulk_start: Starting xfer=%p on existing ep=%d\n",xfer,epipe->ep));
		musb_start_bulkinterrupt(sc,ex,epipe->ep);
		splx(s);
		return (USBD_IN_PROGRESS);
d192 1
a192 3
	usb_endpoint_descriptor_t *ed = xfer->pipe->endpoint->edesc;
	int endpt = ed->bEndpointAddress;
	for(int i=1;i<MUSB_NUM_ENDPOINTS;i++)
d194 2
a195 23
		/* Is this IN or OUT? */
		if(UE_GET_DIR(endpt) == UE_DIR_IN)
		{
			if((sc->host_rx[i].state == HOST_EP_STATE_IDLE) && !(sc->host_rx[i].pipe))
			{
				/* Start it */
				DPRINTFN(10,("musb_device_bulk_start: Starting xfer=%p on ep=%d\n",xfer,i));
				musb_start_bulkinterrupt(sc,ex,i);
				splx(s);
				return (USBD_IN_PROGRESS);
			}
		}
		else
		{
			if((sc->host_tx[i].state == HOST_EP_STATE_IDLE) && !(sc->host_tx[i].pipe))
			{
				/* Start it */
				DPRINTFN(10,("musb_device_bulk_start: Starting xfer=%p on ep=%d\n",xfer,i));
				musb_start_bulkinterrupt(sc,ex,i);
				splx(s);
				return (USBD_IN_PROGRESS);
			}
		}
d197 7
a203 4
	/* No free endpoint! */
	DPRINTF(("musb_device_bulk_start: No endpoints!\n"));
	splx(s);
	return (USBD_IOERROR);
d206 2
a207 2
Static void
musb_device_bulk_abort(usbd_xfer_handle xfer)
d209 1
a209 1
	DPRINTF(("musb_device_bulk_abort: xfer=%p\n",xfer));
d213 2
a214 2
Static void
musb_device_bulk_close(usbd_pipe_handle pipe)
d216 1
a216 14
	int ep = ((struct musb_pipe *) pipe)->ep;
	DPRINTF(("musb_device_bulk_close: pipe=%p ep=%d\n",pipe,ep));
	/* Deallocate endpoint if we own it */
	musb_softc_t *sc = (musb_softc_t *)pipe->device->bus;
	if(ep != -1)
	{
		int s = splusb();
		if(sc->host_tx[ep].pipe == (struct musb_pipe *) pipe)
			sc->host_tx[ep].pipe = 0;
		if(sc->host_rx[ep].pipe == (struct musb_pipe *) pipe)
			sc->host_rx[ep].pipe = 0;
		splx(s);
	}
}
d218 3
a220 6
void
musb_device_bulk_done(usbd_xfer_handle xfer)
{
	struct musb_xfer *ex = MXFER(xfer);
	musb_softc_t *sc = (musb_softc_t *)xfer->pipe->device->bus;
	DPRINTFN(10,("musb_device_bulk_done: xfer=%p, length=%d\n", xfer,xfer->actlen));
a222 5
/*

				Interrupt funcs

*/
d224 1
a224 2
Static usbd_status
musb_device_intr_transfer(usbd_xfer_handle xfer)
d226 1
a226 1
	usbd_status err;
d228 2
a229 56
	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (musb_device_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

Static usbd_status
musb_device_intr_start(usbd_xfer_handle xfer)
{
	musb_softc_t *sc = (musb_softc_t *)xfer->pipe->device->bus;
	struct musb_xfer *ex = MXFER(xfer);
	struct musb_pipe *epipe = (struct musb_pipe *)xfer->pipe;
	int s = splusb();
	if(epipe->ep != -1)
	{
		DPRINTFN(10,("musb_device_intr_start: Starting xfer=%p on existing ep=%d\n",xfer,epipe->ep));
		musb_start_bulkinterrupt(sc,ex,epipe->ep);
		splx(s);
		return (USBD_IN_PROGRESS);
	}
	usb_endpoint_descriptor_t *ed = xfer->pipe->endpoint->edesc;
	int endpt = ed->bEndpointAddress;
	for(int i=1;i<MUSB_NUM_ENDPOINTS;i++)
	{
		/* Is this IN or OUT? */
		if(UE_GET_DIR(endpt) == UE_DIR_IN)
		{
			if((sc->host_rx[i].state == HOST_EP_STATE_IDLE) && !(sc->host_rx[i].pipe))
			{
				/* Start it */
				DPRINTFN(10,("musb_device_intr_start: Starting xfer=%p on ep=%d\n",xfer,i));
				musb_start_bulkinterrupt(sc,ex,i);
				splx(s);
				return (USBD_IN_PROGRESS);
			}
		}
		else
		{
			if((sc->host_tx[i].state == HOST_EP_STATE_IDLE) && !(sc->host_tx[i].pipe))
			{
				/* Start it */
				DPRINTFN(10,("musb_device_intr_start: Starting xfer=%p on ep=%d\n",xfer,i));
				musb_start_bulkinterrupt(sc,ex,i);
				splx(s);
				return (USBD_IN_PROGRESS);
			}
		}
	}
	/* No free endpoint! */
	DPRINTF(("musb_device_intr_start: No endpoints!\n"));
	splx(s);
	return (USBD_IOERROR);
}
d231 1
a231 5
Static void
musb_device_intr_abort(usbd_xfer_handle xfer)
{
	DPRINTF(("musb_device_intr_abort: xfer=%p\n",xfer));
	musb_abort_xfer(xfer,USBD_CANCELLED);
a233 17
Static void
musb_device_intr_close(usbd_pipe_handle pipe)
{
	int ep = ((struct musb_pipe *) pipe)->ep;
	DPRINTF(("musb_device_intr_close: pipe=%p ep=%d\n",pipe,ep));
	/* Deallocate endpoint if we own it */
	musb_softc_t *sc = (musb_softc_t *)pipe->device->bus;
	if(ep != -1)
	{
		int s = splusb();
		if(sc->host_tx[ep].pipe == (struct musb_pipe *) pipe)
			sc->host_tx[ep].pipe = 0;
		if(sc->host_rx[ep].pipe == (struct musb_pipe *) pipe)
			sc->host_rx[ep].pipe = 0;
		splx(s);
	}
}
d235 1
a235 2
Static void
musb_device_intr_done(usbd_xfer_handle xfer)
d237 3
a239 3
	struct musb_xfer *ex = MXFER(xfer);
	musb_softc_t *sc = (musb_softc_t *)xfer->pipe->device->bus;
	DPRINTFN(10,("musb_device_intr_done: xfer=%p, length=%d\n", xfer,xfer->actlen));
d242 1
a242 1
		musb_device_intr_start(xfer);
d247 1
a247 13
				Isoc funcs

*/

Static usbd_status	musb_device_isoc_transfer(usbd_xfer_handle xfer) { return USBD_IOERROR; }
Static usbd_status	musb_device_isoc_start(usbd_xfer_handle xfer) { return USBD_IOERROR; }
Static void		musb_device_isoc_abort(usbd_xfer_handle xfer) { }
Static void		musb_device_isoc_close(usbd_pipe_handle pipe) { }
Static void		musb_device_isoc_done(usbd_xfer_handle xfer) { }

/*

				FIFO funcs
d251 1
a251 1
Static void *musb_fiforead(int ep,void *dest,int bytes)
d253 9
a261 3
	DPRINTFN(20,("musb_fiforead: %d: ",bytes));
	volatile musb_fifo *fifo = &(musb_base->fifo[ep]);
	if(!(((u32)dest)&3))
d263 4
a266 8
		u32 *d = (u32 *) dest;
		while(bytes>=4)
		{
			*d++ = fifo->_u32;
			DPRINTFN(20,("%08x ",d[-1]));
			bytes -= 4;
		}
		dest = (void *) d;
d268 1
a268 1
	if(!(((u32)dest)&1))
d270 4
a273 2
		u16 *d = (u16 *) dest;
		while(bytes>=2)
d275 1
a275 3
			*d++ = fifo->_u16;
			DPRINTFN(20,("%04x ",d[-1]));
			bytes -= 2;
d277 8
a284 1
		dest = (void *) d;
a285 8
	char *c = (char *) dest;
	while(bytes--)
	{
		*c++ = fifo->_u8;
		DPRINTFN(20,("%02x ",c[-1]));
	}
	DPRINTFN(20,("\n"));
	return (void *) c;
d288 19
a306 349
Static void *musb_fifowrite(int ep,void *src,int bytes)
{
	DPRINTFN(20,("musb_fifowrite: %d: ",bytes));
	volatile musb_fifo *fifo = &(musb_base->fifo[ep]);
	if(!(((u32)src)&3))
	{
		u32 *d = (u32 *) src;
		while(bytes>=4)
		{
			fifo->_u32 = *d++;
			DPRINTFN(20,("%08x ",d[-1]));
			bytes -= 4;
		}
		src = (void *) d;
	}
	if(!(((u32)src)&1))
	{
		u16 *d = (u16 *) src;
		while(bytes>=2)
		{
			fifo->_u16 = *d++;
			DPRINTFN(20,("%04x ",d[-1]));
			bytes -= 2;
		}
		src = (void *) d;
	}
	char *c = (char *) src;
	while(bytes--)
	{
		fifo->_u8 = *c++;
		DPRINTFN(20,("%02x ",c[-1]));
	}
	DPRINTFN(20,("\n"));
	return (void *) c;
}

/*

			Peripheral mode functions

*/
Static usb_device_descriptor_t musb_peri_devd = {
	USB_DEVICE_DESCRIPTOR_SIZE,
	UDESC_DEVICE,		/* type */
	{0x00, 0x02},		/* USB version */
	UDCLASS_VENDOR,		/* class */
	0xFF,		/* subclass */
	0,	/* protocol */
	64,			/* max packet */
	{0},{0},{0x00,0x01},	/* device id */
	1,2,0,			/* string indicies */
	1			/* # of configurations */
};

Static usb_device_qualifier_t musb_peri_odevd = {
	USB_DEVICE_DESCRIPTOR_SIZE,
	UDESC_DEVICE_QUALIFIER,	/* type */
	{0x00, 0x02},		/* USB version */
	UDCLASS_VENDOR,		/* class */
	0xFF,		/* subclass */
	0,		/* protocol */
	64,			/* max packet */
	1,			/* # of configurations */
	0
};

Static usb_config_descriptor_t musb_peri_confd = {
	USB_CONFIG_DESCRIPTOR_SIZE,
	UDESC_CONFIG,
	{USB_CONFIG_DESCRIPTOR_SIZE +
	 USB_INTERFACE_DESCRIPTOR_SIZE},
	1, /* num interfaces */
	1, /* config value */
	0, /* string index */
	UC_SELF_POWERED+UC_BUS_POWERED, /* Bus powered bit is 'reserved' and should always be set according to spec? */
	0			/* max power */
};

Static usb_interface_descriptor_t musb_peri_ifcd = {
	USB_INTERFACE_DESCRIPTOR_SIZE,
	UDESC_INTERFACE,
	0, /* interface # */
	0,
	0, /* num endpoints */
	UICLASS_VENDOR, /* interface class */
	0, /* subclass */
	0, /* protocol */
	0 /* string index */
};

Static int musb_ep0_peri_handle(musb_softc_t *sc)
{
	/* Handle a request on EP0, 0 on success, 1 on failure */
	usb_device_request_t *req = &sc->peri_ep0_req;
	int len = UGETW(req->wLength);
	int value = UGETW(req->wValue);
	int index = UGETW(req->wIndex);

	void *buf = sc->peri_ep0_rxbuf;
	int l;

#define C(x,y) ((x) | ((y) << 8))
	switch(C(req->bRequest, req->bmRequestType)) {
	case C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):
	case C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):
	case C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):
		/*
		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops
		 * for the integrated root hub.
		 */
		return 0;
	case C(UR_GET_CONFIG, UT_READ_DEVICE):
		if (len > 0) {
			sc->peri_ep0_txbuf = (void *) &sc->peri_conf;
			sc->peri_ep0_txremain = 1;
			return 0;
		}
		return 1;
	case C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):
                DPRINTFN(8,("musb_ep0_peri_handle: UR_GET_DESCRIPTOR: wValue=0x%04x\n", value));
		switch(value >> 8) {
		case UDESC_DEVICE:
			if ((value & 0xff) != 0) {
				return 1;
			}
			sc->peri_ep0_txremain = min(len, USB_DEVICE_DESCRIPTOR_SIZE);
			sc->peri_ep0_txbuf = (void *) &musb_peri_devd;
			return 0;
		case UDESC_DEVICE_QUALIFIER:
			if ((value & 0xff) != 0) {
				return 1;
			}
			sc->peri_ep0_txremain = min(len, USB_DEVICE_DESCRIPTOR_SIZE);
			sc->peri_ep0_txbuf = (void *) &musb_peri_odevd;
			return 0;
		case UDESC_OTHER_SPEED_CONFIGURATION:
		case UDESC_CONFIG:
			if ((value & 0xff) != 0) {
				return 1;
			}
			/* todo - overflow checks */
			l = sc->peri_ep0_txremain = min(len, USB_CONFIG_DESCRIPTOR_SIZE);
			sc->peri_ep0_txbuf = buf;
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
			memcpy(buf, (void*) &musb_peri_confd, l);
#else
			memcpy(buf, &musb_peri_confd, l);
#endif
			((usb_config_descriptor_t *)buf)->bDescriptorType =
				value >> 8;
			buf = (char *)buf + l;
			len -= l;
			l = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);
			sc->peri_ep0_txremain += l;
#if defined(__CC_NORCROFT) && !defined(DISABLE_PACKED)
			memcpy(buf, (void*) &musb_peri_ifcd, l);
#else
			memcpy(buf, &musb_peri_ifcd, l);
#endif

			return 0;
		case UDESC_STRING:
			if (len == 0)
				break;
			*(u_int8_t *)buf = 0;
			sc->peri_ep0_txbuf = buf;
			sc->peri_ep0_txremain = 1;
			switch (value & 0xff) {
                        case 0: /* Language table */
                                sc->peri_ep0_txremain = musb_str(buf, len, "\001");
                                break;
			case 1: /* Vendor */
				sc->peri_ep0_txremain = musb_str(buf, len, sc->peri_vendor);
				break;
			case 2: /* Product */
				sc->peri_ep0_txremain = musb_str(buf, len, "RISC OS computer");
				break;
			}
			return 0;
		default:
			return 1;
		}
		break;
	case C(UR_GET_INTERFACE, UT_READ_INTERFACE):
		if (len > 0) {
			*(u_int8_t *)buf = 0;
			sc->peri_ep0_txbuf = buf;
			sc->peri_ep0_txremain = 1;
			return 0;
		}
		return 1;
	case C(UR_GET_STATUS, UT_READ_DEVICE):
		if (len > 1) {
			USETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED); /* todo - fix this, surely? */
			sc->peri_ep0_txbuf = buf;
			sc->peri_ep0_txremain = 2;
			return 0;
		}
		return 1;
	case C(UR_GET_STATUS, UT_READ_INTERFACE):
	case C(UR_GET_STATUS, UT_READ_ENDPOINT):
		if (len > 1) {
			USETW(((usb_status_t *)buf)->wStatus, 0);
			sc->peri_ep0_txbuf = buf;
			sc->peri_ep0_txremain = 2;
			return 0;
		}
		return 1;
	case C(UR_SET_ADDRESS, UT_WRITE_DEVICE):
		if (value >= USB_MAX_DEVICES) {
			return 1;
		}
		DPRINTFN(8,("musb_ep0_peri_handle: Logging pending address %02x\n",value));
		sc->peri_addr = value;
		sc->peri_addr_pending = 1;
		return 0;
	case C(UR_SET_CONFIG, UT_WRITE_DEVICE):
		if (value != 0 && value != 1) {
			return 1;
		}
		sc->peri_conf = value;
		return 0;
	case C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):
		return 0; /* ignored? */
	case C(UR_SET_FEATURE, UT_WRITE_DEVICE):
	case C(UR_SET_FEATURE, UT_WRITE_INTERFACE):
	case C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):
		return 1;
	case C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):
		return 0;
	case C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):
		return 0;
	default:
		DPRINTFN(4,("musb_ep0_peri_handle: Unknown request %04x\n",C(req->bRequest, req->bmRequestType)));
		return 1;
	}
	return 1;
}

Static int musb_ep0_peri_validrx(musb_softc_t *sc)
{
	/* Return nonzero if sc->peri_ep0_req is a valid rx request */
	int len = UGETW(sc->peri_ep0_req.wLength);
	if(len > sizeof(sc->peri_ep0_rxbuf))
		return 0;
	switch(C(sc->peri_ep0_req.bRequest, sc->peri_ep0_req.bmRequestType))
	{
	case C(UR_SET_DESCRIPTOR,UT_WRITE_DEVICE):
		return 1;
	case C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):
		if(len != 2)
			return 0;
		return 1;
	default:
		return 0;
	}
}

#define CSR_SET(X) csro = csro | (X)
#define CSR_CLEAR(X) csro = csro & ~(X)

Static void musb_ep0_peri(musb_softc_t *sc)
{
	/* Process ep0 related interrupt when acting as a peripheral */
	/* Flow based around section 23.1.3.1.1.5 of spruf98b */
	/* Making sense of all the nonsense:
	 - When in idle state, ep0 interrupt with RXPKTRDY implies a setup packet has been received
	   -> ep0 fifo should contain (at least?) 8 bytes of data
	 - For zero data requests
	   - read 8 byte packet from fifo
	   - set SERV_RXPKTRDY & DATAEND
	     - before the second interrupt?
	   - wait for second interrupt indicating host has moved to status stage
	     - this is the right time to apply SET_ADDRESS commands
	   - if the packet cannot be executed, need to set SERV_RXPKTRDY & SENDSTALL before host moves onto status stage
	 - For write requests ((bmRequestType & UT_READ) == 0)
	   - read 8 byte packet from fifo
	   - set SERV_RXPKTRDY
	   - on receipt of second interrupt
	     - RXPKTRDY should be set, indicating more data is available
	     - in which case read the data from the FIFO
	       - set SERV_RXPKTRDY after reading (and DATAEND if no more data expected)
	   - a final interrupt should then occur as the host moves to the status stage
	   - if the packet cannot be executed, need to set SERV_RXPKTRDY & SENDSTALL (before host moves onto data stage?)
	 - For read requests ((bmRequestType & UT_READ) != 0)
	   - read 8 byte packet from fifo
	   - set SERV_RXPKTRDY
	   - write response data to fifo
	   - set TXPKTRDY (and DATAEND if last packet has been loaded)
	   - subsequent interrupts will allow more data to be sent
	   - a final interrupt should then occur as the host moves to the status stage
	   - if the packet cannot be executed, need to set SERV_RXPKTRDY & SENDSTALL (before starting to transmit data?)
	 - Thus, the interrupt routine needs to handle several states:
	   - Idle
	     - Goes to Status if Zero Data request received
	     - Fall-through to TX if read request received
	     - Goes to RX if write request received
	     - Goes to Error if any packet cannot be processed
	     - Acknowledges SENTSTALL & SETUPEND but no state transition
	   - TX
	     - Fills transmit buffer & goes to Status if end of data
	   - RX
	     - Reads receive buffer
	     - At end of data, processes request & goes to Status/Error as appropriate?
	   - Status
	     - Goes to idle
	     - Applies FADDR if appropriate
	     - If an error condition is received, abort?
	   - Error
	     - Expects SENTSTALL to be set
	     - Goes to idle
	 - Is it possible to transition from Status/Error to somewhere new immediately? Or from Idle to RX immediately?
	*/
	/* todo - tidy all this stuff */
	int csr = musb_base->csr.peri_ep0.peri_csr0;
	int handled=0;
	int updated=0;
	int csro=0; /* TODO - Surely this is bad for CSR_CLEAR? */
	DPRINTFN(15,("musb_ep0_peri: csr %04x count0 %2x state %d\n",csr,musb_base->csr.peri_ep0.count0,sc->peri_ep0_state));
	/* No matter what we're doing, an error condition sends us to idle state */
	if(csr & (PERI_CSR0_SENTSTALL | PERI_CSR0_SETUPEND))
	{
		if(sc->peri_ep0_state == PERI_EP0_STATE_ERROR)
		{
			DPRINTFN(15,("musb_ep0_peri: Error state received as expected\n"));
		}
		else
		{
			DPRINTFN(15,("musb_ep0_peri: Unexpected error state!\n"));
		}
		CSR_CLEAR(PERI_CSR0_SENTSTALL | PERI_CSR0_SETUPEND);
		sc->peri_ep0_state = PERI_EP0_STATE_IDLE;
		sc->peri_addr_pending = 0; /* Cancel pending address change */
		//return; - flowchart suggests we should do multiple things?
		handled++;
		updated=1;
	}
	/* If we're in the status state, handle it appropriately */
	if(sc->peri_ep0_state == PERI_EP0_STATE_STATUS)
	{
		if(sc->peri_addr_pending)
		{
			/* This should be the status interrupt marking the end of the transfer; update our address */
			DPRINTFN(15,("musb_ep0_peri: Applying address %02x\n",sc->peri_addr));
			musb_base->common.faddr = sc->peri_addr & FADDR_FUNCADDR;
			sc->peri_addr_pending = 0;
		}
		sc->peri_ep0_state = PERI_EP0_STATE_IDLE;
		handled++;
d308 1
a308 2
	/* If we are idle, look for a packet */
	if(sc->peri_ep0_state == PERI_EP0_STATE_IDLE)
d310 20
a329 7
		if(!(csr & PERI_CSR0_RXPKTRDY))
		{
			if(!handled)
			{
				DPRINTFN(15,("musb_ep0_peri: IDLE: RXPKTRDY not set. csr=%04x\n",csr)); // only complain if we haven't done anything yet
			}
			goto end;
d331 1
a331 2
		/* Read the 8 byte packet from the FIFO */
		if((musb_base->csr.peri_ep0.count0 & COUNT0_EP0RXCOUNT) < 8)
d333 5
a337 5
			DPRINTFN(15,("musb_ep0_peri: IDLE: FIFO only contains %d bytes\n",musb_base->csr.peri_ep0.count0 & COUNT0_EP0RXCOUNT));
			CSR_SET(PERI_CSR0_SENDSTALL);
			sc->peri_ep0_state = PERI_EP0_STATE_ERROR;
			updated=1;
			goto end;
d339 10
a348 44
		musb_fiforead(0,&sc->peri_ep0_req,8);
		handled++;
		/* If we expect data, we must wait for it to be received */
		if(UGETW(sc->peri_ep0_req.wLength))
		{
			if(sc->peri_ep0_req.bmRequestType & UT_READ)
			{
				sc->peri_ep0_txremain = 0;
				if(!musb_ep0_peri_handle(sc)) /* Load the requested data into the transmit buffer */
				{
					sc->peri_ep0_state = PERI_EP0_STATE_TX;
					CSR_SET(PERI_CSR0_SERV_RXPKTRDY);
					updated=1;
					/* Wait for controller to enter TX mode */
					musb_base->csr.peri_ep0.peri_csr0 = csro;
					WAITON(musb_base->csr.peri_ep0.peri_csr0 & PERI_CSR0_RXPKTRDY);
					csro = 0;
					updated=0;
				}
				else
				{
					sc->peri_ep0_state = PERI_EP0_STATE_ERROR;
					CSR_SET(PERI_CSR0_SERV_RXPKTRDY | PERI_CSR0_SENDSTALL);
					updated=1;
				}
			}
			else
			{
				/* Wait for receive before we can handle the request */
				if(musb_ep0_peri_validrx(sc))
				{
					sc->peri_ep0_state = PERI_EP0_STATE_RX;
					sc->peri_ep0_rxbufpos = 0;
					CSR_SET(PERI_CSR0_SERV_RXPKTRDY);
					updated=1;
					goto end; /* RXPKTRDY will still be set in csr soft-copy; skip attempting to read from the empty FIFO */
				}
				else
				{
					sc->peri_ep0_state = PERI_EP0_STATE_ERROR;
					CSR_SET(PERI_CSR0_SERV_RXPKTRDY | PERI_CSR0_SENDSTALL);
					updated=1;
				}
			}
d352 2
a353 12
			if(!musb_ep0_peri_handle(sc))
			{
				sc->peri_ep0_state = PERI_EP0_STATE_STATUS;
				CSR_SET(PERI_CSR0_SERV_RXPKTRDY | PERI_CSR0_DATAEND);
				updated=1;
			}
			else
			{
				sc->peri_ep0_state = PERI_EP0_STATE_ERROR;
				CSR_SET(PERI_CSR0_SERV_RXPKTRDY | PERI_CSR0_SENDSTALL);
				updated=1;
			}
d356 28
a383 1
	if(sc->peri_ep0_state == PERI_EP0_STATE_TX)
d385 52
a436 2
		int count=min(sc->peri_ep0_txremain,PERI_EP0_MAXP);
		if(!count)
d438 2
a439 5
			DPRINTFN(15,("musb_ep0_peri: TX: No data left!\n"));
			CSR_SET(PERI_CSR0_SENDSTALL);
			sc->peri_ep0_state = PERI_EP0_STATE_ERROR;
			updated=1;
			goto end;
d441 11
a451 10
		sc->peri_ep0_txbuf = musb_fifowrite(0,sc->peri_ep0_txbuf,count);
		sc->peri_ep0_txremain -= count;
		if(!sc->peri_ep0_txremain)
		{
			CSR_SET(PERI_CSR0_DATAEND);
			sc->peri_ep0_state = PERI_EP0_STATE_STATUS;
		}
		CSR_SET(PERI_CSR0_TXPKTRDY);
		handled++;
		updated=1;
d453 1
a453 1
	if(sc->peri_ep0_state == PERI_EP0_STATE_RX)
d455 13
a467 2
		int count = musb_base->csr.peri_ep0.count0 & COUNT0_EP0RXCOUNT;
		if(!(csr & PERI_CSR0_RXPKTRDY))
d469 2
a470 3
			if(!handled)
				DPRINTFN(15,("musb_ep0_peri: RX: RXKPKTRDY not set. csr=%04x\n",csr));
			goto end;
d472 11
a482 32
		if(count+sc->peri_ep0_rxbufpos > sizeof(sc->peri_ep0_rxbuf))
		{
			DPRINTFN(15,("musb_ep0_peri: RX: Buffer overflow!\n"));
			CSR_SET(PERI_CSR0_SENDSTALL);
			sc->peri_ep0_state = PERI_EP0_STATE_ERROR;
			updated=1;
			goto end;
		}
		musb_fiforead(0,&sc->peri_ep0_rxbuf[sc->peri_ep0_rxbufpos],count);
		sc->peri_ep0_rxbufpos += count;
		if(count < PERI_EP0_MAXP)
		{
			/* All data received */
			if(sc->peri_ep0_rxbufpos != UGETW(sc->peri_ep0_req.wLength))
			{
				DPRINTFN(15,("Only read %d bytes; expected %d\n",sc->peri_ep0_rxbufpos,UGETW(sc->peri_ep0_req.wLength)));
				CSR_SET(PERI_CSR0_SENDSTALL);
				sc->peri_ep0_state = PERI_EP0_STATE_ERROR;
				updated=1;
				goto end;
			}
			CSR_SET(PERI_CSR0_DATAEND);
			sc->peri_ep0_state = PERI_EP0_STATE_IDLE;
			if(musb_ep0_peri_handle(sc))
			{
				CSR_SET(PERI_CSR0_SENDSTALL);
				sc->peri_ep0_state = PERI_EP0_STATE_ERROR;
			}
		}
		CSR_SET(PERI_CSR0_SERV_RXPKTRDY);
		updated=1;
		handled++;
d484 1
a484 4
end:
	DPRINTFN(15,("musb_ep0_peri: handled %d new csr %04x(%d) new state %d\n",handled,csro,updated,sc->peri_ep0_state));
	if(updated)
		musb_base->csr.peri_ep0.peri_csr0 = csro;
d487 14
a500 1
/*
d502 7
a508 1
			Host mode endpoint interrupt handlers
d510 9
a518 23
*/

Static void musb_ep0_completed(musb_softc_t *sc,struct musb_xfer *ex)
{
	struct musb_xfer *ex2;
	/* First clear our endpoint state
	   Note that musb_ep0_host relies on this! */
	sc->host_tx[0].state = HOST_EP0_STATE_IDLE;
	sc->host_tx[0].pipe = 0;
	if(ex)
		((struct musb_pipe *) ex->xfer.pipe)->ep = -1;
	/* If we have something waiting for ep0, start it */
	ex2 = SIMPLEQ_FIRST(&sc->host_ep0_queue);
	DPRINTFN(10,("musb_ep0_completed: xfer %p is complete\n",ex));
	if(ex)
	{
		DPRINTFN(10,("musb_ep0_completed: xfer status=%d, len=%d/%d\n",ex->xfer.status,ex->xfer.actlen,ex->xfer.length));
	}
	if(ex2)
	{
		DPRINTFN(10,("musb_ep0_completed: Starting control xfer=%p\n",ex2));
		SIMPLEQ_REMOVE_HEAD(&sc->host_ep0_queue,next);
		musb_start_control(sc,ex2);
d522 2
a523 8
		DPRINTFN(10,("musb_ep0_completed: No next xfer\n"));
	}
	/* todo - if ep remains unused, we should disable interrupts for it? */
	/* Now tell the driver about the xfer we just completed */
	if(ex)
	{
		callout_stop(&(ex->xfer.timeout_handle));
		usb_transfer_complete(&ex->xfer);
d525 3
d530 5
a534 18
Static void musb_rx_completed(musb_softc_t *sc,struct musb_xfer *ex,int ep)
{
	/* First clear our endpoint state
	   Note that musb_receive_host relies on this! */
	sc->host_rx[ep].state = HOST_EP_STATE_IDLE;
	DPRINTFN(10,("musb_rx_completed: xfer %p on ep %d is complete\n",ex,ep));
	if(ex)
	{
		DPRINTFN(10,("musb_rx_completed: xfer status=%d, len=%d/%d\n",ex->xfer.status,ex->xfer.actlen,ex->xfer.length));
	}
	/* todo - if ep remains unused, we should disable interrupts for it? */
	/* Now tell the driver about the xfer we just completed */
	if(ex)
	{
		callout_stop(&(ex->xfer.timeout_handle));
		usb_transfer_complete(&ex->xfer);
	}
}
d536 2
a537 18
Static void musb_tx_completed(musb_softc_t *sc,struct musb_xfer *ex,int ep)
{
	/* First clear our endpoint state
	   Note that musb_transmit_host relies on this! */
	sc->host_tx[ep].state = HOST_EP_STATE_IDLE;
	DPRINTFN(10,("musb_tx_completed: xfer %p on ep %d is complete\n",ex,ep));
	if(ex)
	{
		DPRINTFN(10,("musb_tx_completed: xfer status=%d, len=%d/%d\n",ex->xfer.status,ex->xfer.actlen,ex->xfer.length));
	}
	/* todo - if ep remains unused, we should disable interrupts for it? */
	/* Now tell the driver about the xfer we just completed */
	if(ex)
	{
		callout_stop(&(ex->xfer.timeout_handle));
		usb_transfer_complete(&ex->xfer);
	}
}
d539 1
a539 1
Static void musb_ep0_host(musb_softc_t *sc)
d546 32
a577 2
	struct musb_xfer *ex = (struct musb_xfer *) (sc->host_tx[0].pipe?SIMPLEQ_FIRST(&sc->host_tx[0].pipe->pipe.queue):0);
	DPRINTFN(15,("musb_ep0_host: csr %04x count0 %2x state %d pipe %08x\n",csr,musb_base->csr.host_ep0.count0,sc->host_tx[0].state,sc->host_tx[0].pipe));
d581 6
a586 9
		if(ex)
		{
			if(csr & HOST_CSR0_RXSTALL)
				ex->xfer.status = USBD_STALLED;
			else if(csr & HOST_CSR0_ERROR)
				ex->xfer.status = USBD_IOERROR;
			else /* HOST_CSR0_NAK_TIMEOUT */
				ex->xfer.status = USBD_TIMEOUT;
		}
d589 1
a589 2
			/* Todo - allow for retries? How do we tell how many NAKs we should allow? */
			switch(sc->host_tx[0].state)
d619 1
a619 1
	switch(sc->host_tx[0].state)
d624 1
a624 1
		if(ex && UGETW(ex->xfer.request.wLength))
d629 1
a629 1
				sc->host_tx[0].state = HOST_EP0_STATE_IN_DATA;
d636 1
a636 1
				sc->host_tx[0].state = HOST_EP0_STATE_OUT_DATA;
d644 1
a644 1
			sc->host_tx[0].state = HOST_EP0_STATE_IN_STATUS;
d656 1
a656 1
			if(!ex || (count > sc->host_tx[0].remain))
d658 2
a659 5
				if(ex)
				{
					DPRINTFN(10,("musb_ep0_host: Panic! Device sent too much data\n"));
					ex->xfer.status = USBD_IOERROR;
				}
d671 2
a672 2
				sc->host_tx[0].remain -= count;
				sc->host_tx[0].buf = musb_fiforead(0,sc->host_tx[0].buf,count);
d678 1
a678 1
		if(sc->host_tx[0].remain)
d687 1
a687 1
			sc->host_tx[0].state = HOST_EP0_STATE_OUT_STATUS;
d696 1
a696 2
		int count = min(sc->host_tx[0].remain,HOST_EP0_MAXP);
		if(count && ex)
d698 3
a700 2
			sc->host_tx[0].remain -= count;
			sc->host_tx[0].buf = musb_fifowrite(0,sc->host_tx[0].buf,count);
d708 1
a708 1
			sc->host_tx[0].state = HOST_EP0_STATE_IN_STATUS;
d731 2
a732 5
		if(ex)
		{
			ex->xfer.status = USBD_NORMAL_COMPLETION;
			ex->xfer.actlen = ex->xfer.length; /* yes? */
		}
d739 1
a739 1
		DPRINTFN(10,("musb_ep0_host: Panic! interrupt received while in state %d\n",sc->host_tx[0].state));
d746 1
a746 1
		sc->host_tx[0].state = HOST_EP0_STATE_IDLE;
d751 1
a751 1
	DPRINTFN(15,("musb_ep0_host: new csr %04x(%d) new state %d\n",csro,updated,(complete?HOST_EP0_STATE_IDLE:sc->host_tx[0].state)));
d755 4
a758 1
		musb_ep0_completed(sc,ex);
d761 1
a761 1
Static void musb_receive_host(musb_softc_t *sc,int ep)
d768 3
a770 2
	struct musb_xfer *ex = (struct musb_xfer *) (sc->host_rx[ep].pipe?SIMPLEQ_FIRST(&sc->host_rx[ep].pipe->pipe.queue):0);
	DPRINTFN(15,("musb_receive_host: ep %d csr %04x rxcount %2x state %d pipe %08x\n",ep,csr,musb_base->csr.host_ep[ep].rxcount,sc->host_rx[ep].state,sc->host_rx[ep].pipe));
d772 1
a772 1
	if(sc->host_rx[ep].state != HOST_EP_STATE_IN)
d774 1
a774 1
		DPRINTFN(10,("musb_receive_host: Panic! interrupt received while not in STATE_IN\n"));
d782 6
a787 9
		if(ex)
		{
			if(csr & HOST_RXCSR_RXSTALL)
				ex->xfer.status = USBD_STALLED;
			else if(csr & HOST_RXCSR_ERROR)
				ex->xfer.status = USBD_IOERROR;
			else /* HOST_RXCSR_DATAERR_NAKTIMEOUT */
				ex->xfer.status = USBD_TIMEOUT;
		}
a789 1
			/* Todo - allow for retries? How do we tell how many NAKs we should allow? */
d803 1
d805 1
a805 1
		if(!ex || (count > sc->host_rx[ep].remain))
d807 2
a808 5
			if(ex)
			{
				DPRINTFN(10,("musb_receive_host: Panic! Device sent too much data\n"));
				ex->xfer.status = USBD_IOERROR;
			}
d820 2
a821 2
			sc->host_rx[ep].remain -= count;
			sc->host_rx[ep].buf = musb_fiforead(ep,sc->host_rx[ep].buf,count);
d825 1
a825 1
			usb_endpoint_descriptor_t *ed = ex->xfer.pipe->endpoint->edesc;
d829 1
a829 1
				ex->xfer.actlen = ex->xfer.length-sc->host_rx[ep].remain;
a838 1
		/* todo - should we treat this as a short packet and complete the transfer? */
d841 1
a841 1
	if(sc->host_rx[ep].remain)
d850 2
a851 5
		if(ex)
		{
			ex->xfer.status = USBD_NORMAL_COMPLETION;
			ex->xfer.actlen = ex->xfer.length; /* yes? */
		}
d856 1
a856 1
	DPRINTFN(15,("musb_receive_host: new csr %04x(%d) new state %d\n",csro,updated,(complete?0:sc->host_rx[ep].state)));
d860 1
a860 1
		musb_rx_completed(sc,ex,ep);
d863 1
a863 1
Static void musb_transmit_host(musb_softc_t *sc,int ep)
d870 3
a872 2
	struct musb_xfer *ex = (struct musb_xfer *) (sc->host_tx[ep].pipe?SIMPLEQ_FIRST(&sc->host_tx[ep].pipe->pipe.queue):0);
	DPRINTFN(15,("musb_transmit_host: ep %d csr %04x state %d pipe %08x\n",ep,csr,sc->host_tx[ep].state,sc->host_tx[ep].pipe));
d874 1
a874 1
	if(sc->host_tx[ep].state != HOST_EP_STATE_OUT)
d876 1
a876 1
		DPRINTFN(10,("musb_receive_host: Panic! interrupt received while not in STATE_OUT\n"));
d885 1
a885 1
	/* RXSTALL, ERROR and NAK_TIMEOUT are terminal error conditons */
d888 6
a893 10
		/* Todo - allow for retries on NAK_TIMEOUT? How do we tell how many NAKs we should allow? */
		if(ex)
		{
			if(csr & HOST_TXCSR_RXSTALL)
				ex->xfer.status = USBD_STALLED;
			else if(csr & HOST_TXCSR_ERROR)
				ex->xfer.status = USBD_IOERROR;
			else /* HOST_TXCSR_NAK_TIMEOUT */
				ex->xfer.status = USBD_TIMEOUT;
		}
d904 1
a904 1
	if(ex && sc->host_tx[ep].remain)
d906 5
a910 4
		usb_endpoint_descriptor_t *ed = ex->xfer.pipe->endpoint->edesc;
		int count = min(sc->host_tx[ep].remain,UGETW(ed->wMaxPacketSize));
		sc->host_tx[ep].remain -= count;
		sc->host_tx[ep].buf = musb_fifowrite(ep,sc->host_tx[ep].buf,count);
d915 1
a915 1
	else if(ex && sc->host_tx[ep].null_packet)
d918 2
a919 1
		sc->host_tx[ep].null_packet = false;
d927 2
a928 5
		if(ex)
		{
			ex->xfer.status = USBD_NORMAL_COMPLETION;
			ex->xfer.actlen = ex->xfer.length; /* yes? */
		}
d933 1
a933 1
	DPRINTFN(15,("musb_transmit_host: new csr %04x(%d) new state %d\n",csro,updated,(complete?0:sc->host_tx[ep].state)));
d937 132
a1068 1
		musb_tx_completed(sc,ex,ep);
@


1.5
log
@Improve reliability of OTG cable detection, add support for USBD_FORCE_SHORT_XFER, tidy code a bit
Detail:
  c/musb, h/musb - Added support for USBD_FORCE_SHORT_XFER flag. Also tidied the source a bit to use bools instead of ints for storing flags.
  c/tps, cmhg/modhead - Made OTG cable detection 100% reliable by getting rid of the USB_PRES interrupt code and instead using a ticker event to poll the STS_HW_CONDITIONS.STS_USB bit at regular intervals
Admin:
  Tested on rev C2 beagleboard


Version 0.06. Tagged as 'MUSBDriver-0_06'
@
text
@a79 2
#define MXFER(xfer) ((struct musb_xfer *)(xfer))

d93 1
d161 1
d506 1
a506 1
			/* This transfer is (probably) active. If the allocated endpoint is active, and pointing to this pipe, deallocate the endpoint and leave the interrupt routine to fixup the rest */
d510 24
d539 4
d549 14
a562 1
		SIMPLEQ_REMOVE(&sc->host_ep0_queue,ex,musb_xfer,next);
d565 1
d570 7
d645 3
d770 3
d1038 1
a1038 1
	int port, i;
d1272 1
a1272 1
		hubd.bDescLength = USB_HUB_DESCRIPTOR_SIZE + i;
d1393 1
d2114 1
d2414 2
d2417 1
d2433 2
d2436 1
d2452 2
d2455 1
@


1.4
log
@Fix a couple of nasty bugs in MUSBDriver
Detail:
  Allocation of bulk/interrupt endpoints has now been fixed so that two pipes won't end up claiming the same endpoint if the endpoint is idle at the time the second pipe searches for a free endpoint. Connecting multiple devices which rely on bulk endpoints (e.g. a mass storage device and a USB-LAN adaptor) now works properly.
  musb_receive_host() has also been fixed to deal with short packets properly, so devices which rely on them (e.g. USB-LAN adaptors) should now work properly.
Admin:
  Tested on rev C2 beagleboard.


Version 0.05. Tagged as 'MUSBDriver-0_05'
@
text
@d455 1
a455 1
	epipe->clear_toggle = 1;
d576 1
a576 1
	epipe->tx = 1;
d611 1
a611 1
		epipe->tx = 0;
d657 1
a657 1
		epipe->clear_toggle = 0;
d663 1
a663 1
		epipe->tx = 1;
d668 1
d710 1
a710 1
		epipe->clear_toggle = 0;
d1436 1
a1436 1
	epipe->clear_toggle = 1;
d2756 8
@


1.3
log
@Fix queueing of control transfers in MUSBDriver
Detail:
  The host_ep0_queue structure wasn't being initialised properly, leading to the driver failing to properly queue USB control transactions when acting in host mode. This fix should fix a number of serious soft-lock issues that can occur when using the driver (seen so far with USB mass storage devices)
Admin:
  Tested on rev C2 beagleboard


Version 0.04. Tagged as 'MUSBDriver-0_04'
@
text
@d1549 2
a1550 1
	DPRINTF(("musb_device_ctrl_close: pipe=%p\n",pipe));
a1551 1
	int ep = ((struct musb_pipe *) pipe)->ep;
d1603 1
a1603 1
			if(sc->host_rx[i].state == HOST_EP_STATE_IDLE)
d1614 1
a1614 1
			if(sc->host_tx[i].state == HOST_EP_STATE_IDLE)
d1640 2
a1641 1
	DPRINTF(("musb_device_bulk_close: pipe=%p\n",pipe));
a1642 1
	int ep = ((struct musb_pipe *) pipe)->ep;
d1704 1
a1704 1
			if(sc->host_rx[i].state == HOST_EP_STATE_IDLE)
d1715 1
a1715 1
			if(sc->host_tx[i].state == HOST_EP_STATE_IDLE)
d1741 2
a1742 1
	DPRINTF(("musb_device_intr_close: pipe=%p\n",pipe));
a1743 1
	int ep = ((struct musb_pipe *) pipe)->ep;
d2658 9
d2673 1
@


1.2
log
@Initial version of USB host support for MUSBDriver
Detail:
  c/tps, h/tps, Makefile - Some rather rough code to wake up the MUSB controller and cause it to enter host mode when the OTG cable is detected. Needs some tidying up and improvement to deal with any other drivers that need to interact with the TWL/TPS.
  c/musb, h/musb - Initial host-mode support for MUSBDriver. Control, bulk & interrupt endpoints are implemented. Isochronous is not. Lots of bits need improving, but it's stable enough for owners of rev B beagleboards to make use of.
  cmhg/modhead, c/cmodule - Improved debugging code
Admin:
  Tested on rev C2 beagleboard


Version 0.02. Tagged as 'MUSBDriver-0_02'
@
text
@d319 1
@


1.1
log
@Add initial version of MUSBDriver module

- Interfaces with main USBDriver module and implements software part of root hub
- Interfaces with Mentor MUSBMHDRC USB OTG controller, providing basic peripheral-mode support
@
text
@d78 1
d80 14
a93 3
struct musb_pipe {
	struct usbd_pipe pipe;
};
d159 4
d223 1
a223 1
	/* Called from usbdriver when a transfer is done */
d346 14
a366 2
	/* Force host mode */
//	musb_base->common.testmode = TESTMODE_FORCE_HOST;
d387 9
a396 2
	usbd_status err;

d398 1
d405 4
d411 1
d440 6
d453 2
d462 281
d768 5
a772 1
		if(intrusb & INTRUSB_VBUSERR)
d774 4
a777 2
			DPRINTFN(11,("INTRUSB_VBUSERR\n"));
		}
d791 2
a792 1
			DPRINTFN(12,("EP0 host IRQ\n"));
d800 2
a801 1
				DPRINTFN(12,("EP%d host RX\n",i));
d811 2
a812 1
				DPRINTFN(12,("EP%d host TX\n",i));
d822 1
a822 1
			//printf("EP0 peri IRQ\n");
d849 1
d855 8
d867 5
a871 1
/***********/
a872 3
/*
 * Data structures and routines to emulate the root hub.
 */
a960 3
/*
 * Simulate a hardware hub by handling all the necessary requests.
 */
d987 1
d1243 7
a1249 2
		USETW(ps.wPortStatus, 0); /*todo - this seems wrong but is actually right? check how linux calculates it (during 'get talking to hw' phase?)*/
		USETW(ps.wPortChange, sc->port_status);
d1280 10
a1289 9
#if 0
			/* Start reset sequence. */
			v &= ~ (EHCI_PS_PE | EHCI_PS_PR);
			EOWRITE4(sc, port, v | EHCI_PS_PR);
			/* Wait for reset to complete. */
			usb_delay_ms(&sc->sc_bus, USB_PORT_ROOT_RESET_DELAY);
			if (sc->sc_dying) {
				err = USBD_IOERROR;
				goto ret;
d1291 3
a1293 5
			/* Terminate reset sequence. */
			EOWRITE4(sc, port, v);
			/* Wait for HC to complete reset. */
			usb_delay_ms(&sc->sc_bus, EHCI_PORT_RESET_COMPLETE);
			if (sc->sc_dying) {
a1296 11
			v = EOREAD4(sc, port);
			DPRINTF(("musb after reset, status=0x%08x\n", v));
			if (v & EHCI_PS_PR) {
                                printf("%s: port reset timeout\n",
				       USBDEVNAME(sc->sc_bus.bdev));
				return (USBD_TIMEOUT);
			}
			sc->sc_isreset = 1;
#endif
			DPRINTF(("musb port %d reset, status = 0x%08x\n",
				 index, v));
d1316 1
a1316 1
		sc->port_status |= (1 << value);
d1428 2
d1434 3
d1451 3
a1453 1
	/* todo - comms with attached devices */
d1455 17
a1471 1
	return (USBD_IOERROR);
d1484 5
a1488 1
/************************/
d1493 9
a1501 1
	return USBD_IOERROR;
d1507 18
a1524 1
	return USBD_IOERROR;
d1530 4
d1540 2
d1548 11
d1561 5
a1565 1
/************************/
d1570 9
a1578 1
	return USBD_IOERROR;
d1584 43
a1626 1
	return USBD_IOERROR;
d1632 2
a1635 3
/*
 * Close a device bulk pipe.
 */
d1639 13
d1657 3
d1662 5
a1666 1
/************************/
d1671 9
a1679 1
	return USBD_IOERROR;
d1685 43
a1727 1
	return USBD_IOERROR;
d1733 2
d1740 13
d1758 6
d1766 5
a1770 1
/************************/
d1786 24
a1809 1
	// todo - check FIFO contains the required number of bytes?
a1810 1
	DPRINTFN(20,("musb_fiforead: %d: ",bytes));
d1813 1
a1813 1
		*c++ = musb_base->fifo[ep]._u8;
d1822 24
a1846 1
	DPRINTFN(20,("musb_fifowrite: %d: ",bytes));
d1849 1
a1849 1
		musb_base->fifo[ep]._u8 = *c++;
d2136 1
a2136 1
	int csro=0;
d2204 1
a2204 2
					while(musb_base->csr.peri_ep0.peri_csr0 & PERI_CSR0_RXPKTRDY)
					{ /* wibble */ };
d2319 443
@


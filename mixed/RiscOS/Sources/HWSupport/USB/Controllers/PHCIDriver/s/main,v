head	1.6;
access;
symbols
	PHCIDriver-0_11:1.6
	PHCIDriver-0_10:1.5
	PHCIDriver-0_09:1.4
	PHCIDriver-0_08:1.4
	PHCIDriver-0_07:1.4
	PHCIDriver-0_06:1.3
	PHCIDriver-0_05:1.3
	PHCIDriver-0_04:1.2
	PHCIDriver-0_03:1.1;
locks; strict;
comment	@# @;


1.6
date	2002.05.01.09.08.54;	author mboura;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.28.16.29.23;	author srevill;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.13.11.18.19;	author dellis;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.22.17.06.53;	author dellis;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.19.17.54.37;	author dellis;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.14.14.47.35;	author dellis;	state Exp;
branches;
next	;


desc
@@


1.6
log
@  Now dies if it doesn't find the hardware
Detail:
  Correct flag now checked.
  Cleans up correctly if hardware_claim fails
  Returns BadHard = "Hardware not supported" error.
Admin:
  Multiple RMLoad works as expected with and without the hardware check succedding. Tested on STB.

Version 0.11. Tagged as 'PHCIDriver-0_11'
@
text
@; Copyright 2001 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; Philips 1161 controller

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; module workspace
                        ^ 0, wp
Flags			# 4
BaseAddress             # 4
BuffManWkSpace          # 4	; buffer manager workspace
BuffManService          # 4     ; address of buffer manager routine
MessagesWorkspace       # 16    ; needed for messages routines
DeviceFSBlock		# 4	; address of devicefs registration block
DeviceHandle		# 4	; handle returned from DeviceFS_Register
RHInterrupt             # 4     ; root hub interrupt stream
RHControlIn             # 4     ; root hub control in  stream
RHControlOut            # 4     ; root hub control out stream
RHAddress               # 1     ; address of root hub
RHConfig                # 1     ; root hub config value
                        # 2     ; alignhash 4
EPHead                  # 0
EPHeadControl           # 4     ; head endpoint structure
EPHeadIsochronous       # 4     ; head endpoint structure
EPHeadBulk              # 4     ; head endpoint structure
EPHeadInterrupt         # 4     ; head endpoint structure
EPATLHead               # 4     ; head endpoint from last fill of ATL buffer
 [ USBDevice
DevEPHead               # 4     ; head of device endpoint structures
 ]
ClkReadyCount           # 4     ; |
HCSuspendedCount        # 4     ; |
OPR_RegCount            # 4     ; |--- counts for each type of IRQ
AllEOTIntCount          # 4     ; |
ATLIntCount             # 4     ; |
SOFITLIntCount          # 4     ; |
ErrorCount              # 4     ; |
ATLSize                 # 4     ; size of ATL buffer
ATLUsed                 # 4     ; amount of ATL buffer currently used
ITLSize                 # 4     ; size of ITL buffers
ITL0Used                # 4     ; amount of ITL buffer 0 used
ITL1Used                # 4     ; amount of ITL buffer 1 used
ATLBufferSize           # 4     ; amount of data written to ATL buffer
SoftATLBuffer           # &1000 ; soft copy of ATL buffer
workspace               * :INDEX: @@

;
; bit definitions for Flags
;
flag_OwnIRQ             * 1:SHL:2  ; set => IRQ owned for device
flag_HaveMessages	* 1:SHL:3  ; set => opened messages file
flag_Registered         * 1:SHL:4  ; set => registered device
flag_ATLBufferFilled    * 1:SHL:5  ; set => there is data in the ATL buffer
flag_ATLBufferPending   * 1:SHL:6  ; set => an endpoint requires the ATL buffer
flag_Testing            * 1:SHL:7  ; set => in test mode - don't process ATL buffer in interrupts

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; standard module declarations
                AREA  |PHCI$$Code|, CODE, READONLY, PIC

                ENTRY   ; for debug aif
Module_BaseAddr
module          & 0
                & init    -module               ; => initalise routine
                & final   -module               ; => finalise routine
                & service -module               ; => service trap

                & title -module                 ; => title string
                & help  -module                 ; => help string
                & command_table-module		; => command table

                & &80000
;                & swi_handler-module
                & 0
                & swi_table-module
 [ :LNOT: No32bitCode
                & 0
                & 0
                & moduleflags - module          ; => module flags
 ]

swi_table
title           = "PHCIDriver", 0
                = "Request", 0, 0

help            = "PHCIDriver", 9, 9, "$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
                = " $Module_MinorVersion"
 ]
 [ debug
                = " (Debug on)", 0
 ]
                = 0

                ALIGN
command_table
 [ test
                Command PHCIRegs,       0, 0, 0
                Command PHCIWrite,      2, 2, 0
                Command PHCIRead,       1, 1, 0
                Command PHCITest,       2, 0, 0
                Command PHCIReadATL,    1, 0, 0
                Command PDCIWrite,      2, 2, 0
                Command PDCIRead,       1, 1, 0
                Command PHCIDevDesc,    1, 0, 0
                Command PHCIReset,      0, 0, 0
                Command PHCITestBuild,  0, 0, 0
                Command PHCIList,       0, 0, 0
 ]
                DCB 0

		ALIGN

 [ :LNOT: No32bitCode
moduleflags     DCD ModuleFlag_32bit
 ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Globals

resource_file = "Resources:$.Resources.PHCI.Messages", 0

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Error declarations

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; This code handles the startup of the module, the routine must claim the
; required workspace and then initialise the driver.
;
init            Entry	"r7-r11"

                Debug   module, "Initialising PHCIDriver"

                MOV     r0, #ModHandReason_Claim
                LDR     r3, =workspace          ; r3  = amount of workspace

                SWI     XOS_Module
                EXIT    VS                      ; return if didn't work

                STR     r2, [wp]		; wp = r2
                MOV     wp, r2                  ; wp -> workspace

; zero the workspace
                MOV     r0, #0
10
                STR     r0, [r2], #4
                SUBS    r3, r3, #4
                BGT     %b10

 [ standalonemessages
                ADRL    r0, resource_file_block
                SWI     XResourceFS_RegisterFiles
                EXIT    VS
 ]

30
; claim the device vector
		BL 	hardware_claim
                BLVC    register_device
                EXIT    VC
; free workspace up before exit
40
;		BL	hardware_release
 [ standalonemessages
                MOV     r6, r0
                ADRL    r0, resource_file_block
                SWI     XResourceFS_DeregisterFiles
                MOV     r0, r6
 ]
                SETV
                EXIT

bad_hardware
        ADR     r0, ErrorBlock_BadHard
        MOV     r1, #0                          ;only use global message file
        MOV     r2, #0                          ;use MessageTrans buffer
        MOV     r4, #0                          ;don't substitute anything
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        B       %BT40

        MakeErrorBlock  BadHard

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		LTORG
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle module close down.
;

final           Entry	"r0-r1,r11"

                LDR     wp, [r12]               ; wp -> workspace
		BL	hardware_release
                BL      deregister_device

 [ standalonemessages
                ADRL    R0, resource_file_block
                SWI     XResourceFS_DeregisterFiles
 ]
                CLRV
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle service calls received by the module.
;
; Quickly test to see if they are of interest to use and pass on.

                ASSERT  Service_ResourceFSStarting < Service_DeviceFSStarting
                ASSERT  Service_DeviceFSStarting < Service_DeviceFSDying
servicetable    DCD     0
                DCD     serviceentry -module
 [ standalonemessages
                DCD     Service_ResourceFSStarting      ; &60
 ]
                DCD     Service_DeviceFSStarting        ; &70
                DCD     Service_DeviceFSDying           ; &71
                DCD     0

                DCD     servicetable -module
service         ROUT
                MOV     r0, r0
                TEQ     r1, #Service_DeviceFSStarting
                TEQNE   r1, #Service_DeviceFSDying
 [ standalonemessages
                TEQNE   r1, #Service_ResourceFSStarting
 ]
                MOVNE   pc, lr

serviceentry    LDR     wp, [r12]

20
 [ standalonemessages
                TEQ     r1, #Service_ResourceFSStarting
                BNE     %FT30					; no so continue
                Push    "r0-r3,lr"
                ADRL    r0, resource_file_block
                MOV     lr, pc
                MOV     pc, r2
                Pull    "r0-r3,pc"				; and exit
30
 ]
                TEQ     r1, #Service_DeviceFSDying
                BNE     %f40
                LDR     r0, Flags
		BIC	r0, r0, #flag_Registered
		STR	r0, Flags

                MOV     pc, lr

40
                TEQ     r1, #Service_DeviceFSStarting
                BNE     %f50
                B       register_device
50
99
                MOV  	pc, lr

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ test
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; handle the command *PHCIRegs
;
;
hc_32bit_registers
                DCD     HcRevision
                = "HcRevision           : ", 0
                DCD     HcControl
                = "HcControl            : ", 0
                DCD     HcCommandStatus
                = "HcCommandStatus      : ", 0
                DCD     HcInterruptStatus
                = "HcInterruptStatus    : ", 0
                DCD     HcInterruptEnable
                = "HcInterruptEnable    : ", 0
                DCD     HcInterruptDisable
                = "HcInterruptDisable   : ", 0
                DCD     HcFmInterval
                = "HcFmInterval         : ", 0
                DCD     HcFmRemaining
                = "HcFmRemaining        : ", 0
                DCD     HcFmNumber
                = "HcFmNumber           : ", 0
                DCD     HcLSThreshold
                = "HcLSThreshold        : ", 0
                DCD     HcRhDescriptorA
                = "HcRhDescriptorA      : ", 0
                DCD     HcRhDescriptorB
                = "HcRhDescriptorB      : ", 0
                DCD     HcRhStatus
                = "HcRhStatus           : ", 0
                DCD     HcRhPortStatus1
                = "HcRhPortStatus1      : ", 0
                DCD     HcRhPortStatus2
                = "HcRhPortStatus2      : ", 0

hc_16bit_registers
                DCD     HcHardwareConfiguration
                = "HcHardwareConfig     : ", 0
                DCD     HcDMAConfiguration
                = "HcDMAConfig          : ", 0
                DCD     HcTransferCounter
                = "HcTransferCounter    : ", 0
                DCD     HcuPInterrupt
                = "HcuPInterrupt        : ", 0
                DCD     HcuPInterruptEnable
                = "HcuPInterruptEnable  : ", 0
                DCD     HcChipID
                = "HcChipID             : ", 0
                DCD     HcScratch
                = "HcScratch            : ", 0
                DCD     HcITLBufferLength
                = "HcITLBufferLength    : ", 0
                DCD     HcATLBufferLength
                = "HcATLBufferLength    : ", 0
                DCD     HcBufferStatus
                = "HcBufferStatus       : ", 0
hc_reg_end

PHCIRegs_Help   = "*PHCIRegs reads the ISP1161s registers", 0
PHCIRegs_Syntax = "Syntax: *PHCIRegs", 0
                ALIGN
PHCIRegs_Code Entry "r1-r5"

                LDR     r12, [r12]
                LDR     r11, BaseAddress

                ADRL    r4, hc_32bit_registers
                ADRL    r3, hc_16bit_registers
                PHPSEI  r5
10
                LDR     r0, [r4], #4
                BL      show_hex2
                MOV     r1, r0
                MOV     R0, #' '
                SWI     XOS_WriteC
                MOV     r0, r4
                SWI     XOS_Write0
                MOV     r4, r0
                MOV     r0, r1
                HCLDR   r0, r0, r2
                Debug   module, "", r0
                BL      show_hex8
                SWI     XOS_NewLine
                CMP     r4, r3
                BLO     %BT10

                ADRL    r3, hc_reg_end
20
                LDR     r0, [r4], #4
                BL      show_hex2
                MOV     r1, r0
                MOV     R0, #' '
                SWI     XOS_WriteC
                MOV     r0, r4
                SWI     XOS_Write0
                MOV     r4, r0
                MOV     r0, r1
                HCLDRH  r0, r0
                BL      show_hex4
                SWI     XOS_NewLine
                CMP     r4, r3
                BLO     %BT20

                PLP     r5

                MACRO
                WRTIRQ  $irq
                SWI     XOS_WriteS
                =       "$irq : ",0
                LDR     R0, $irq.Count
                BL      show_integer
                SWI     XOS_NewLine
                MEND

                WRTIRQ  ClkReady
                WRTIRQ  HCSuspended
                WRTIRQ  OPR_Reg
                WRTIRQ  AllEOTInt
                WRTIRQ  ATLInt
                WRTIRQ  SOFITLInt
                WRTIRQ  Error

		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PHCIWrite
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PHCIWrite_Help      = "Write to a register in the ISP1161 host", 13
PHCIWrite_Syntax    = "Syntax: *PHCIWrite <register> <value>", 0
                ALIGN
PHCIWrite_Code Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress
                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                EXIT    VS
                MOV     r3, r2
10
                LDRB    r0, [r1, #1]!
                TEQ     r0, #" "
                BEQ     %BT10

                MOV     r0, #&10
                SWI     XOS_ReadUnsigned
                EXIT    VS

                CMP     r3, #&20                ; use the call appropriate to the register
                BLHS    %FT20
                HCSTR   r2, r3
                EXIT
20
                HCSTRH  r2, r3
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PHCIRead
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PHCIRead_Help      = "Read a register from the ISP1161 host", 13
PHCIRead_Syntax    = "Syntax: *PHCIRead <register>", 0
                ALIGN
PHCIRead_Code Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress
                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                EXIT    VS
10
                CMP     r2, #&20                ; use the call appropriate to the register
                BLHS    %FT20
                HCLDR   r0, r2
                BL      show_hex8
                SWI     XOS_NewLine
                EXIT
20
                HCLDRH  r0, r2
                BL      show_hex4
                SWI     XOS_NewLine
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PDCIWrite
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PDCIWrite_Help      = "Write to a register in the ISP1161 device", 13
PDCIWrite_Syntax    = "Syntax: *PDCIWrite <register> <value>", 0
                ALIGN
PDCIWrite_Code Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress
                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                EXIT    VS
                MOV     r3, r2
10
                LDRB    r0, [r1, #1]!
                TEQ     r0, #" "
                BEQ     %BT10

                MOV     r0, #&10
                SWI     XOS_ReadUnsigned
                EXIT    VS

                DCSTRH  r2, r3
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PDCIRead
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PDCIRead_Help      = "Read a register in from the ISP1161 device", 13
PDCIRead_Syntax    = "Syntax: *PDCIRead <register>", 0
                ALIGN
PDCIRead_Code Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress
                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                EXIT    VS
                MOV     r3, r2

20
                HCLDRH  r0, r3
                BL      show_hex4
                SWI     XOS_NewLine

                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PHCITest
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PHCITest_Help       = "Send some test data on the bus from memory, by default the internal buffer", 13
PHCITest_Syntax     = "Syntax: *PHCITest [<memory> <size>]", 0
                ALIGN
PHCITest_Code   Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress

                BL      claim_test_semaphore
                EXIT    VS

                ; Clear the EOT and ATL interrupt bit
                MOV     r3, #HcuPInterrupt
                MOV     r4, #AllEOTInt
                HCSTRH  r4, r3

                ; Allocate all RAM to the ATL buffer
                MOV     r3, #HcATLBufferLength
                MOV     r4, #&1000
                HCSTRH  r4, r3

                ; If there are no parameters, then read the internal ones
                TEQ     r1, #0
                LDREQ   r2, ATLBufferSize
                ADREQ   r3, SoftATLBuffer
                BEQ     %f15

                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                BVS     %f99
                MOV     r3, r2
10
                LDRB    r0, [r1, #1]!
                TEQ     r0, #" "
                BEQ     %BT10

                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                BVS     %f99

                ; Allocate RAM to the ATL buffer
;                MOV     r0, #HcATLBufferLength
;                HCSTRH  r2, r0
15
                Debug   module, "about to write bytes (nbytes, from): ", r2, r3
                LDR     r5, ATLIntCount

                ; Setup the transfer length
                MOV     r0, #HcTransferCounter
                HCSTRH  r2, r0

                ; Start the transfer
                MOV     r0, #HcATLBufferPort:OR:&80
                STR     r0, HCCommand

                ; Write all the data
                Push    "r2, r3"
20
                LDR     r0, [r3], #2
                STR     r0, HCData
                SUBS    r2, r2, #2
                BHI     %BT20

                ; Are interrupts enabled?
                MOV     r0, #HcuPInterruptEnable
                HCLDRH  r1, r0
                TEQ     r1, #0
                BNE     %f25

                ; If not then poll status bit after ackowledging any outstanding interrupts
                MOV     r3, #HcuPInterrupt
                MOV     r0, #&ff
                HCSTRH  r0, r3
                SWI     XOS_ReadMonotonicTime
                ADD     r2, r0, #100
                MOV     r1, #0                  ; taskwindow yield
23
                HCLDRH  r0, r3
                TST     r0, #ATLInt
                BNE     %f40
                MOV     r1, #0
                MOV     r0, #6
                SWI     XOS_UpCall
                SWI     XOS_ReadMonotonicTime
                CMP     r0, r2
                BLT     %b23
                B       %f35
25
                ; Wait for the next interrupt
                MOV     r3, r5                  ; restore saved IRQ value
                SWI     XOS_ReadMonotonicTime
                ADD     R2, R0, #100
                MOV     R1, #0                  ; taskwindow yield
30
                LDR     R4, ATLIntCount
                TEQ     R3, R4
                BNE     %f40
                MOV     R0, #6
                SWI     XOS_UpCall
                SWI     XOS_ReadMonotonicTime
                CMP     R0, R2
                BLT     %b30
35
;                Pull    "r2, r3"
                SWI     OS_WriteS
                =       "Timeout waiting for device reply",10,13,0
                ALIGN
;                BL      release_test_semaphore
;                EXIT
40
                ; Read back the data
                Pull    "r2, r3"

                ; Setup the transfer length
                MOV     r0, #HcTransferCounter
                HCSTRH  r2, r0

                ; Start the transfer
                MOV     r0, #HcATLBufferPort
                STR     r0, HCCommand
50
                LDR     r0, HCData
                STRB    r0, [r3], #1
                MOV     r0, r0, LSR#8
                STRB    r0, [r3], #1
                SUBS    r2, r2, #2
                BHI     %BT50
99
                BL      release_test_semaphore
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PHCIDevDesc
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PHCIDevDesc_Help       = "Read the device descriptor of the connected device to the memory location specified", 13
PHCIDevDesc_Syntax     = "Syntax: *PHCIDevDesc <memory>", 0
                ALIGN
PHCIDevDesc_Code   Entry "r0-r1", &14
                LDR     r12, [r12]
                LDR     r11, BaseAddress

                ; Go into test mode
                BL      claim_test_semaphore
                STRVS   r0, [sp, #Proc_RegOffset]
                EXIT    VS

                ; Ramp up FSLargest packet so that we can read low speed devices !?!?!
                MOV     r3, #HcFmInterval
                HCLDR   r4, r3
                MOV     r4, r4, LSL#16
                MOV     r4, r4, LSR#16
                ORR     r4, r4, #&20000000
                HCSTR   r4, r3

                ; Clear the EOT and ATL interrupt bit
                MOV     r3, #HcuPInterrupt
                MOV     r4, #AllEOTInt
                HCSTRH  r4, r3

                ; Turn power on
                MOV     r3, #HcRhStatus
                MOV     r4, #OHCI_LPSC
                HCSTRH  r4, r3

                ; Allocate all RAM to the ATL buffer
                MOV     r3, #HcATLBufferLength
                MOV     r4, #&1000
                HCSTRH  r4, r3

                ; If there are no arguments, then print to the screen
                TEQ     r1, #0
                BNE     %f5
                MOV     r8, sp
                B       %f7
5
                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                BVS     %f99
                MOV     r8, r2                  ; save for later
7
                Debug   module, "Writing to address ", r8

                ; Wait for the next interrupt
                ADR     R1, SOFITLIntCount
                MOV     r0, #10
                BL      wait_for_interrupt
                BVS     %f99

                ; fill buffer
                ADR     r0, GetDevDesc
                MOV     r1, #16
                BL      write_atl_buffer

                ; Wait for the next interrupt
                ADR     R1, ATLIntCount
                MOV     r0, #10
                BL      wait_for_interrupt
                BVS     %f99
10
                ; fill buffer
                ADR     r0, read18
                MOV     r1, #26
                BL      write_atl_buffer

                ; Wait for interrupt
                ADR     R1, ATLIntCount
                MOV     r0, #10
                BL      wait_for_interrupt
                BVS     %f99

                ; Read header
                MOV     r0, #HcTransferCounter
                MOV     r2, #2
                HCSTRH  r2, r0

                ; Start the transfer
                PHPSEI  r6
                MOV     r0, #HcATLBufferPort
                STR     r0, HCCommand
                LDR     r0, HCData
                PLP     r6
                TST     r0, #1:SHL:11
                BNE     %b10

                ; Read back the data
                PHPSEI  r6

                ; Setup the transfer length
                MOV     r0, #HcTransferCounter
                MOV     r2, #26
                HCSTRH  r2, r0

                ; Start the transfer
                MOV     r0, #HcATLBufferPort
                STR     r0, HCCommand

                ; Read out header
                LDR     r0, HCData
                LDR     r0, HCData
                LDR     r0, HCData
                LDR     r0, HCData

                ; Read back data
                MOV     r3, r8
                MOV     r2, #18
10
                LDR     r0, HCData
                STRB    r0, [r3], #1
                MOV     r0, r0, LSR#8
                STRB    r0, [r3], #1
                SUBS    r2, r2, #2
                BHI     %BT10
                PLP     r6

                ; Acknowledge
                ADRL    r0, acknowledge
                MOV     r1, #8
                BL      write_atl_buffer

                ; Wait for interrupt
                ADRL    R1, ATLIntCount
                MOV     r0, #10
                BL      wait_for_interrupt

99
                BL      release_test_semaphore
                DebugIf VS, module, "exit with error"

                ; If there was no memory specified, write to screen
                LDR     r1, [sp, #Proc_RegOffset + 4]
                TEQ     r1, #0
                EXIT    NE

                SWI     XOS_WriteS
                =       "Contents of device descriptor:",10,13,10,13

                MOV     r4, sp

                SWI     XOS_WriteS
                =       "USB release     : ", 0
                LDR     r0, [r4], #4
                MOV     r0, r0, LSR#16
                BL      show_hex4
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Device class    : ", 0
                LDRB    r0, [r4], #1
                BL      show_hex2
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Device subclass : ", 0
                LDRB    r0, [r4], #1
                BL      show_hex2
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Device protocol : ", 0
                LDRB    r0, [r4], #1
                BL      show_hex2
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Max packet size : ", 0
                LDRB    r0, [r4], #1
                BL      show_hex2
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Vendor          : ", 0
                LDR     r0, [r4], #2
                MOV     r0, r0, LSL#16
                MOV     r0, r0, LSR#16
                BL      show_hex4
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Product         : ", 0
                LDR     r0, [r4], #2
                MOV     r0, r0, LSL#16
                MOV     r0, r0, LSR#16
                BL      show_hex4
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Release         : ", 0
                LDR     r0, [r4], #2
                MOV     r0, r0, LSL#16
                MOV     r0, r0, LSR#16
                BL      show_hex4
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Manufacturer    : ", 0
                LDRB    r0, [r4], #1
                BL      show_hex2
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Product         : ", 0
                LDRB    r0, [r4], #1
                BL      show_hex2
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Serial number   : ", 0
                LDRB    r0, [r4], #1
                BL      show_hex2
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "No. of configs  : ", 0
                LDRB    r0, [r4], #1
                BL      show_hex2
                SWI     OS_NewLine

                EXIT

GetDevDesc  = &00, &08, &08, &0C, &08, &00, &00, &00, &80, &06, &00, &01, &00, &00, &12, &00
read18      = &00, &0C, &08, &0C, &12, &08, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00
acknowledge = &00, &0C, &08, &0C, &00, &04, &00, &00

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PHCIReadATL
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PHCIReadATL_Help       = "Dump the contents of the ATL buffer", 13
PHCIReadATL_Syntax     = "Syntax: *PHCIReadATL [<nbytes>]", 0
                ALIGN
PHCIReadATL_Code
                Entry "r0-r7", 16 ; workspace for ConvertHex
                LDR     r12, [r12]
                LDR     r11, BaseAddress


                Debug   module, "n arguments ", r1
                Debug   module, "r0 => ", r0

                TEQ     r1, #0
                BEQ     %f10

                ; Read command line
                MOV     r1, sp
                MOV     r2, #16
                SWI     XOS_EvaluateExpression
                DebugIf VS, module, "Error evaluating"
                BVS     %f10
                TEQ     r1, #0
                Debug   module, "r1 = ", r1
                BNE     %f10

                MOV     r4, r2
                B       %f15
10
                ; Read ATL buffer size
                LDR     r4, ATLBufferSize
15
                MOV     r0, r4
                BL      show_integer
                SWI     XOS_NewLine

                PHPSEI  r6

                ; Setup the transfer length
                MOV     r0, #HcTransferCounter
                HCSTRH  r4, r0
                MOV     r5, r4

                ; Start the transfer
                MOV     r0, #HcATLBufferPort
                STR     r0, HCCommand

                ADR     R2, SoftATLBuffer
17
                LDR     R0, HCData
                STRB    R0, [R2], #1
                MOV     R0, R0, LSR#8
                STRB    R0, [R2], #1
                SUBS    R4, R4, #2
                BHI     %b17

                PLP     r6

                ; Read all the data, writing it to screen
                MOV     r4, r5
                ADR     r5, SoftATLBuffer
20
;                LDR     r0, [R5], #2
;                MOV     r0, r0, LSL#16
;                MOV     r0, r0, LSR#16
;                MOV     r1, r13
;                MOV     r2, #16
;                SWI     XOS_ConvertHex4
                LDR     r0, [R5], #4
                MOV     r1, r13
                MOV     r2, #16
                SWI     XOS_ConvertHex8
                SWIVC   XOS_Write0

                ; Put a space between each read, and a newline every 8
                SUBS    r4, r4, #4
                BLE     %FT30

                TST     r4, #&1f
                SWIEQ   XOS_NewLine
                BEQ     %BT20

                MOV     r0, #' '
                SWI     XOS_WriteC
                B       %BT20
30
                SWI     XOS_NewLine

                PLP     r6

                BL      parse_atl_buffer

                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Return status info
;

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handles the PHCIReset command
;
PHCIReset_Help      = "Reset the ISP1161 safely", 13
PHCIReset_Syntax    = "Syntax: PHCIReset", 0
                ALIGN
PHCIReset_Code
                Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress
                PHPSEI  r4
                MOV     r0, #HcSoftwareReset:OR:&80
                STR     r0, HCCommand

                MOV     r0, #HcHardwareConfiguration
                LDR     r1, =HcHardConfReserved:OR:EOTInputPolarity:OR:DataBusWidth:OR:InterruptOutputPolarity:OR:InterruptPinEnable
                HCSTRH  r1, r0

                MOV     r0, #HcFmInterval   ; set fs largest packet - needed for low speed as well
                LDR     r1, =&20002edf
                HCSTR   r1, r0

                ; Turn on power
                MOV     r0, #HcRhStatus
                MOV     r1, #&10000
                HCSTR   r1, r0

                ; Turn HC interrupts on
                MOV     R0, #HcuPInterruptEnable
                MOV     R1, #HCAllInts
                HCSTRH  R1, R0

                PLP     r4

                ; Start the controller
                MOV     R3, #HcControl
                SWI     OS_ReadMonotonicTime
                ADD     R2, R0, #100
20
                MOV     R1, #&80
                HCSTR   R1, R3
                SWI     OS_ReadMonotonicTime
                CMP     R0, R2
                BGT     %f30
                HCLDR   R1, R3
                TEQ     R1, #&80
                BNE     %b20
30
                EXIT

                LTORG
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handles the PHCITestBuild command
;
PHCITestBuild_Help      = "Test run of an ATL buffer fill", 13
PHCITestBuild_Syntax    = "Syntax: PHCITestBuild", 0
                ALIGN
PHCITestBuild_Code
                Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress

                BL      build_atl_buffer
                STR     r0, ATLBufferSize
                TEQ     r0, #0
                BNE     %f10
                SWI     XOS_WriteS
                =       "No data to write", 10, 13, 0
                EXIT
10
                MOV     r4, r0
                SWI     XOS_WriteS
                =       "Bytes Read: ", 0
                BL      show_integer
                SWI     XOS_NewLine

                ; Read all the data, writing it to screen
                SUB     sp, sp, #8
                ADR     r6, SoftATLBuffer
20
                LDR     r0, [r6], #2
                MOV     r1, r13
                MOV     r2, #8
                SWI     XOS_ConvertHex4
                SWIVC   XOS_Write0

                ; Put a space between each read, and a newline every 8
                SUBS    r4, r4, #2
                BEQ     %FT30

                TST     r4, #&1f
                SWIEQ   XOS_NewLine
                BEQ     %BT20

                MOV     r0, #' '
                SWI     XOS_WriteC
                B       %BT20
30
                ADD     sp, sp, #8
                SWI     XOS_NewLine

                EXIT
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handles *PHCIList
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
PHCIList_Help      = "List the current set of endpoints", 13
PHCIList_Syntax    = "Syntax: PHCIList", 0
                ALIGN
PHCIList_Code   Entry
                LDR     r12, [r12]

                MACRO
                LISTEP
10
                TEQ     r2, #0
                BEQ     %FT20
                Push    "r2"
                LDR     r0, ep_fileswitch
                BL      show_hex2
                SWI     XOS_WriteI+32
                LDR     r0, ep_ptd_header0
                BL      show_hex8
                SWI     XOS_WriteI+32
                LDR     r0, ep_ptd_header4
                BL      show_hex8
                SWI     XOS_NewLine
                Pull    "r2"
                LDR     r2, ep_next
                B       %BT10
20
                MEND

                SWI     XOS_WriteS
                =       "Control:",13,10,0
                ALIGN
                LDR     r2, EPHeadControl
                LISTEP
                SWI     XOS_WriteS
                =       "Bulk:",13,10,0
                ALIGN
                LDR     r2, EPHeadBulk
                LISTEP
                SWI     XOS_WriteS
                =       "Interrupt:",13,10,0
                ALIGN
                LDR     r2, EPHeadInterrupt
                LISTEP
                LDR     r0, [sp]
                BL      show_hex8
                SWI     XOS_NewLine
;                Debug   module, "return address: ", r0

                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Wait for an ATL interrupt
;
; in: -
; out:
;    V set if couldn't claim
claim_test_semaphore
                Entry   "r0,r1"
                Debuga  module, "Claiming test semaphore... "
                LDR     r0, Flags
                TST     r0, #flag_Testing
                BNE     %f10
                ORR     r0, r0, #flag_Testing
                STR     r0, Flags
                Debug   module, "OK"
                CLRV
                EXIT
10
                Debug   module, "Already claimed"
                ADR     R0, ErrorBlock_PHCI_TestSem
                BL      make_error
                STR     r0, [sp, #Proc_RegOffset]
                EXIT

                MakeErrorBlock  PHCI_TestSem

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Wait for an ATL interrupt
;
; in:  -
; out:
;    V set if already cleared

release_test_semaphore
                Entry   "r0"
                LDR     r0, Flags
                BIC     r0, r0, #flag_Testing
                STR     r0, Flags
                Debug   module, "semaphore released"
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Wait for an ATL interrupt
;
; in:
;    r0 - timeout
;    r1 - pollword (interrupt counter)
; out:
;    V set if timed out, and r0 points to error

wait_for_interrupt
                Entry   "R2,R3"
                MOV     R2, R0
                ; Wait for the next interrupt
                SWI     XOS_ReadMonotonicTime
                ADD     R2, R2, R0
                MOV     R0, #0
                STR     R0, [R1]
10
                LDR     R3, [R1]
                TEQ     R3, #0
                EXIT    NE
;                MOV     R0, #6
;                SWI     XOS_UpCall
                SWI     XOS_ReadEscapeState
                BCS     %f20
                SWI     XOS_ReadMonotonicTime
                CMP     R0, R2
                BLT     %b10

                Debug   module, "IRQ timeout"
                ADR     R0, ErrorBlock_PHCI_Timeout
                BL      make_error
                EXIT
20
                MOV     R0, #126
                SWI     XOS_Byte
                Debug   module, "IRQ Escape"
                ADR     R0, ErrorBlock_PHCI_Escape
                BL      make_error
                EXIT


                MakeErrorBlock  PHCI_Timeout
                MakeErrorBlock  PHCI_Escape

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Write a buffer to the ATL FIFO
;
; in:
;    r0 - pointer to buffer
;    r1 - number of bytes
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
write_atl_buffer
                Entry   "r0-r3"
                ; Setup the transfer length
                MOV     r2, #HcTransferCounter
                HCSTRH  r1, r2

                PHPSEI  r3

                ; Start the transfer
                MOV     r2, #HcATLBufferPort:OR:&80
                STR     r2, HCCommand
10
                LDR     r2, [r0], #2
                STR     r2, HCData
                SUBS    r1, r1, #2
                BHI     %b10

                PLP     r3

                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Writes an integer to the screen.
;
; in:
;    r0 - value to be displayed
show_integer	Entry "r1-r2"
        	SUB     r13, r13, #16
        	MOV     r1, r13
        	MOV     r2, #16
        	SWI     XOS_ConvertInteger4
        	SWIVC	OS_Write0
        	ADD     r13, r13, #16
        	EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 ] ; end if debug commands

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Routine to write a hex number to the screen
; in:
;    r0 - value to be displayed
        MACRO
$label  SHOW_HEX    $n
$label  Entry   "r0-r2", 16
        MOV     r1, r13
        MOV     r2, #16
        SWI     XOS_ConvertHex$n
        SWIVC	OS_Write0
        EXIT
        MEND

show_hex8 SHOW_HEX  8
show_hex4 SHOW_HEX  4
show_hex2 SHOW_HEX  2

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Generalised internationalisation routines, these ensure that messages files
; are correctly opened and then return the relevant data.
;
; Attempt to open the messages file.

open_messages   Entry   "r0-r3"
                LDRB    r3, Flags
                TST     r3, #flag_HaveMessages
                EXIT    NE

                ADR     r0, MessagesWorkspace
                ADRL    r1, resource_file     ; -> path to be opened
                MOV     r2, #0                ; allocate some wacky space in RMA
                SWI     XMessageTrans_OpenFile
                LDRVCB  r3, Flags
                ORRVC   r3, r3, #flag_HaveMessages
                STRVCB  r3, Flags
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Attempt to close the messages file.

close_messages  Entry   "r0"
                LDRB    r0, Flags
                TST     r0, #flag_HaveMessages
                EXIT    EQ

                ADR     r0, MessagesWorkspace
                SWI     XMessageTrans_CloseFile
                LDRVCB  r0, Flags
                BICVC   r0, r0, #flag_HaveMessages
                STRVCB  r0, Flags
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Generate an error based on the error token given.  Does not assume that
; the messages file is open.  Will attempt to open it, then look it up.
; if make_error_with_name is called, the module name is substituted in r4

make_error_with_name Entry "r1-r7"
		ADRL	r4, title
		B	make_error_entry

make_error      ALTENTRY
                MOV     r4, #0
make_error_entry
                LDRB    r1, Flags
                TST     r1, #flag_HaveMessages
                BLEQ    open_messages

                LDRB    r1, Flags
                TST     r1, #flag_HaveMessages
                BEQ     make_error_exit

                ADR     r1, MessagesWorkspace
                MOV     r2, #0
                MOV     r3, #0
                MOV     r5, #0
                MOV     r6, #0
                MOV     r7, #0
                SWI     XMessageTrans_ErrorLookup
                BL      close_messages

make_error_exit
                SETV
                EXIT                           ; return, r0 -> block, V set

make_error1     Entry   "r2-r7"
                MOV     r4, R1
                LDRB    r1, Flags
                TST     r1, #flag_HaveMessages
                BLEQ    open_messages

                LDRB    r1, Flags
                TST     r1, #flag_HaveMessages
                BEQ     make_error_exit1

                ADR     r1, MessagesWorkspace
                MOV     r2, #0
                MOV     r3, #0
                MOV     r5, #0
                MOV     r6, #0
                MOV     r7, #0
                SWI     XMessageTrans_ErrorLookup
                BL      close_messages

make_error_exit1
                SETV
                EXIT                           ; return, r0 -> block, V set

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; This bit of apparently harmless code will bind a messages file into the code
; in the case of a standalone module. The macro ResourceFile will create the
; stuff and the label resource_file is used to point to the block required by
; ResourceFS

 [ standalonemessages
resource_file_block
	ResourceFile $MergedMsgs, Resources.PHCI.Messages
 [ :DEF:HardwareTest
        ! 0, "Incorporating hardware test"
        ResourceFile Test.HardwareTest, !Boot.!Run
 ]
	DCD     0
 ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		END
@


1.5
log
@  Fixed module help string.
Detail:
  Contained two tabs which misaligned it against all of the other modules.
AdminL
  This has been bugging me for ages...  ;)

Version 0.10. Tagged as 'PHCIDriver-0_10'
@
text
@d101 1
a101 1
help            = "PHCIDriver", 9, "$Module_MajorVersion ($Module_Date)"
d180 1
a180 2
                EXIT

@


1.4
log
@  - Support added for overcurrent detection
  - Code added for supporting device side of controller
  - Better error detection and recovery

Detail:
  Analogue overcurrent detection has been switched on in the hardware
configuration.

  Code has been added to support the device side of the controller, although
this is by default switched out.  It hasn't been tested, but is included for
completeness.

  Error recovery is now much more robust and there is now an assembly option
to add a null packet to the end of the payload buffer.  This prevents
multiple transaction attempts on interrupt endpoints.

Admin:
  Tested extensively on a RiscPC.  The device controller code has been tested
at all (but isn't by default included).


Version 0.07. Tagged as 'PHCIDriver-0_07'
@
text
@d101 1
a101 1
help            = "PHCIDriver", 9, 9, "$Module_MajorVersion ($Module_Date)"
@


1.3
log
@  - Fix to control transfers
  - Clarification of root hub interrupts
  - Error returns from USB Requests

Detail:
  Control transfers weren't properly counting the data portion across
multiple frames.  This is now properly counted.

  Root hub interrupts were only being turned on during reads.  They are now
on for the duration of the stream being open.

  If a control transfer fails during device call &80000000 (USB Request) then
the completion code is returned with an error message.

Admin:
  Tested on a STB and RiscPC.  It has been impossible to find a setting
of FSLargestDataPacket which is mutually compatible for full speed and low
speed devices.  Most low speed devices work with the setting &800 but some
mice appear not to, and only start working if the setting is changed to
&2000, however then printing stops working.

Version 0.05. Tagged as 'PHCIDriver-0_05'
@
text
@d40 3
d49 1
a54 2
TransferList            # 4     ; list of transfers being processed
;OHCIRegs                # OHCI_regs_size
a69 23
;
; port specific workspace

                        ^ 0, r11
InputStream		# 4	; devicefs stream handle
OutputStream		# 4	; devicefs stream handle
InputFSHandle		# 4     ; file switch handle of input stream
OutputFSHandle		# 4     ; file switch handle of output stream
InputBuffer		# 4	; buffer manager handle
OutputBuffer		# 4	; buffer manager handle
InputBufferPrivId      	# 4	; buffer managers private buffer id
OutputBufferPrivId	# 4	; buffer managers private buffer id
InputBufferSize		# 4	; buffer size in bytes
OutputBufferSize	# 4	;
InputBufferThreshold	# 4	; buffer threshold point in bytes
OutputBufferThreshold	# 4	;
port_workspace		* :INDEX: @@

;
; bit definitions for ControlLines
;

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d123 1
a134 10
; debug options
 [ debug
Host_Debug  	SETL 	False
HostDebugViaTML	SETL 	False
Debug_Module	SETL	True
;Debug_File      SETS	"$.Debug"
 ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
a286 26
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; establish device
;
; in  : r9 address of devicefs registration block
;       r10 hardware base address
;
; out : r10 address if port is present, 0 otherwise
;       r11 port workspace pointer
;
establish_device Entry "r0-r3"

; we need some workspace
                MOV     r0, #ModHandReason_Claim
                LDR     r3, =port_workspace	; amount of workspace
                SWI     XOS_Module
                STRVS   r0, [sp]
                EXIT    VS                      ; return if didn't work

		MOV	r11, r2			; establish port workspace

		MOV	r0, #0
		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

d370 1
d410 1
d586 3
d631 1
a631 1
                LDR     R3, ATLIntCount
d645 1
a645 1
                Pull    "r2, r3"
d648 3
a650 1
                EXIT
d689 1
d921 1
a921 1
                Entry "r0-r6", 16 ; workspace for ConvertHex
d978 7
a984 3
                LDR     r0, [R5], #2
                MOV     r0, r0, LSL#16
                MOV     r0, r0, LSR#16
d987 1
a987 1
                SWI     XOS_ConvertHex4
d991 2
a992 2
                SUBS    r4, r4, #2
                BEQ     %FT30
d1123 53
a1175 1
 ] ; end if debug commands
d1198 1
d1313 2
d1319 3
a1321 12
show_hex8
        Push    "r1-r2, lr"
        SUB     r13, r13, #16
        MOV     r1, r13
        MOV     r2, #16
        SWI     XOS_ConvertHex8
        SWIVC	OS_Write0
        ADD     r13, r13, #16
        Pull    "r1-r2, pc"
show_hex4
        Push    "r1-r2, lr"
        SUB     r13, r13, #16
d1324 1
a1324 1
        SWI     XOS_ConvertHex4
d1326 2
a1327 11
        ADD     r13, r13, #16
        Pull    "r1-r2, pc"
show_hex2
        Push    "r0-r2, lr"
        SUB     r13, r13, #16
        MOV     r1, r13
        MOV     r2, #16
        SWI     XOS_ConvertHex2
        SWIVC	OS_Write0
        ADD     r13, r13, #16
        Pull    "r0-r2, pc"
d1329 3
d1439 4
a1442 1
;        ResourceFile Test.HardwareTest, !Boot.!Run
@


1.2
log
@  Much more functional driver.

Detail:
  The driver now implements a root hub, and can support interrupt, bulk and
control transfers.  Connections are made by opening the phci device in
devicefs with a special field specifying the endpoint number and type.

  DevDesc has been enhanced to print out on the command line if no address is
given.

Admin:
  Tested extensively on RiscPC and STB.  Still awaiting the writing of a
Spec.

Version 0.04. Tagged as 'PHCIDriver-0_04'
@
text
@d389 1
a389 1
                = "HcInterrupt          : ", 0
d391 1
a391 1
                = "HcInterruptEnable    : ", 0
d1407 23
@


1.1
log
@  Initial import of PHCIDriver

Detail:
  The driver is currently fairly limited.  It sets up the hardware, and
supplies some * commands.

  It has been commited primarily for TestTask to make use of

Admin:
  Tested with TestTask on a STB, and quite extensively on a RiscPC.  The
* command PHCIDevDesc has been observed to put the chip into a confused state
after something of the order of 1000 repeats.



Version 0.03. Tagged as 'PHCIDriver-0_03'
@
text
@d28 12
a39 3
RHInterruptBuffer       # 4     ; buffer for root hub events
RHControlBufferIn       # 4     ; buffer for root hub control in
RHControlBufferOut      # 4     ; buffer for root hub control out
d53 2
d63 3
d95 1
a95 1
                AREA  |DualSerial$$Code|, CODE, READONLY, PIC
d97 1
d108 4
a114 3
                & 0
                & 0
                & 0
d118 1
d120 1
d131 1
d133 1
d137 1
a137 1
                Command PHCITest,       2, 2, 0
d141 1
a141 1
                Command PHCIDevDesc,    1, 1, 0
d143 2
d270 1
a270 1
                DCD     Service_ResourceFSStarting
d272 2
a273 2
                DCD     Service_DeviceFSStarting
                DCD     Service_DeviceFSDying
d299 14
a316 13
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; free workspace
;
; in  : r11 port workspace pointer
;
free_workspace	Entry	"r0-r2"
		MOVS    r2, r11
		MOVNE	r0, #ModHandReason_Free
		SWINE	XOS_Module
		EXIT
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

d343 1
d406 1
d477 1
d512 1
d542 1
d572 1
d596 3
a598 2
PHCITest_Help       = "Send some test data on the bus from memory", 13
PHCITest_Syntax     = "Syntax: *PHCITest <memory> <size>", 0
d603 3
d616 6
d625 1
a625 1
                EXIT    VS
d634 1
a634 1
                EXIT    VS
d639 1
a639 1

d656 25
d685 1
a685 1
                ADR     R1, PHCITest_Code   ; somewhere non-zero
d695 1
d718 2
a719 1

d731 2
a732 1
PHCIDevDesc_Code   Entry
d736 12
d753 5
d763 6
d772 1
a772 1
                EXIT    VS
d774 2
d781 1
a781 1
                EXIT    VS
d792 2
a793 2
                EXIT    VS

d803 15
a817 1
                EXIT    VS
d820 1
d847 1
d850 1
a850 1
                ADR     r0, acknowledge
d855 1
a855 1
                ADR     R1, ATLIntCount
d859 93
d967 3
a969 1
PHCIReadATL_Code   Entry "r0-r5"
d973 6
a978 1
                PHPSEI  r5
d981 2
a982 2
                MOV     r1, #0
                MOV     r2, #0
d984 1
d987 1
d994 1
a994 2
                MOV     r3, #HcATLBufferLength
                HCLDRH  r4, r3
d996 6
d1005 1
d1011 11
d1023 2
a1024 1
                SUB     sp, sp, #8
d1026 3
a1028 1
                LDR     r0, HCData
d1030 1
a1030 1
                MOV     r2, #8
a1045 1
                ADD     sp, sp, #8
d1048 3
a1050 1
                PLP     r5
d1067 1
d1112 99
d1236 2
d1242 1
d1246 8
d1256 1
d1268 1
a1268 1
                Entry   "r0-r2"
d1273 2
d1283 3
d1419 2
a1420 1
	ResourceFile $MergedMsgs, Resources.Serial.Messages
@


head	1.41;
access;
symbols
	BCMVideo-0_53:1.41
	BCMVideo-0_52:1.41
	BCMVideo-0_51:1.41
	BCMVideo-0_50-1_50_2_1:1.40.2.1
	RPiFreeze:1.40.0.2
	BCMVideo-0_50:1.40
	BCMVideo-0_49:1.39
	BCMVideo-0_48:1.38
	BCMVideo-0_47:1.38
	BCMVideo-0_46:1.37
	BCMVideo-0_45:1.37
	BCMVideo-0_44:1.36
	BCMVideo-0_43:1.35
	BCMVideo-0_42:1.34
	BCMVideo-0_41:1.33
	BCMVideo-0_40:1.32
	BCMVideo-0_39:1.31
	BCMVideo-0_38:1.30
	BCMVideo-0_37:1.30
	BCMVideo-0_36:1.29
	BCMVideo-0_35:1.29
	BCMVideo-0_34:1.28
	BCMVideo-0_33:1.27
	BCMVideo-0_32:1.27
	BCMVideo-0_31:1.26
	BCMVideo-0_30:1.25
	BCMVideo-0_29:1.24
	BCMVideo-0_28:1.23
	BCMVideo-0_27:1.22
	BCMVideo-0_26:1.21
	BCMVideo-0_25:1.21
	BCMVideo-0_24:1.20
	BCMVideo-0_23:1.19
	BCMVideo-0_22:1.18
	BCMVideo-0_21:1.17
	BCMVideo-0_20:1.17
	BCMVideo-0_19:1.17
	BCMVideo-0_18:1.16
	BCMVideo-0_17:1.15
	BCMVideo-0_16:1.14
	BCMVideo-0_15:1.13
	BCMVideo-0_14:1.12
	BCMVideo-0_13:1.11
	BCMVideo-0_12:1.10
	BCMVideo-0_11:1.9
	BCMVideo-0_10:1.8
	BCMVideo-0_09:1.7
	BCMVideo-0_08:1.6
	BCMVideo-0_07:1.5
	BCMVideo-0_06:1.4
	BCMVideo-0_05:1.3
	BCMVideo-0_04:1.2
	BCMVideo-0_03:1.2
	BCMVideo-0_02:1.1.1.1
	BCMVideo-0_01:1.1.1.1
	Vendor:1.1.1;
locks; strict;
comment	@# @;


1.41
date	2018.07.01.12.32.40;	author jlee;	state Exp;
branches;
next	1.40;
commitid	SZDeyIEUJXdXNqIA;

1.40
date	2018.04.06.23.01.20;	author jlee;	state Exp;
branches
	1.40.2.1;
next	1.39;
commitid	SXoBJ1pI9Xh03rxA;

1.39
date	2018.02.02.20.37.39;	author jlee;	state Exp;
branches;
next	1.38;
commitid	aDAuPtQqF7MfhkpA;

1.38
date	2017.06.07.21.33.47;	author jlee;	state Exp;
branches;
next	1.37;
commitid	j2SoIQlTVE0PiuUz;

1.37
date	2017.04.13.20.32.19;	author jlee;	state Exp;
branches;
next	1.36;
commitid	qbk5tk8H0BClJpNz;

1.36
date	2017.02.21.08.42.49;	author rsprowson;	state Exp;
branches;
next	1.35;
commitid	MJJy3FseaofBrNGz;

1.35
date	2017.01.28.18.24.02;	author jlee;	state Exp;
branches;
next	1.34;
commitid	W7YZg72dWBjPqLDz;

1.34
date	2016.12.17.18.39.05;	author jlee;	state Exp;
branches;
next	1.33;
commitid	orkqjr7mp7qGRmyz;

1.33
date	2016.12.15.19.43.57;	author jlee;	state Exp;
branches;
next	1.32;
commitid	AAbMoLgplY7Vh7yz;

1.32
date	2016.12.10.17.01.54;	author jlee;	state Exp;
branches;
next	1.31;
commitid	zybtuuARus1hysxz;

1.31
date	2016.08.20.15.39.20;	author jlee;	state Exp;
branches;
next	1.30;
commitid	GMSaVWQj6G1aH3jz;

1.30
date	2016.03.25.20.15.23;	author jlee;	state Exp;
branches;
next	1.29;
commitid	65QlxlgxPV3NY30z;

1.29
date	2015.11.14.17.19.16;	author jlee;	state Exp;
branches;
next	1.28;
commitid	txd4YVNYLLqsf5Jy;

1.28
date	2015.08.05.22.07.15;	author jlee;	state Exp;
branches;
next	1.27;
commitid	fl8ky4krrFkw58wy;

1.27
date	2015.07.15.21.13.07;	author jlee;	state Exp;
branches;
next	1.26;
commitid	xe6OASzNiPkNsqty;

1.26
date	2015.07.10.20.33.44;	author jlee;	state Exp;
branches;
next	1.25;
commitid	gEvIKFBh5s2gpMsy;

1.25
date	2015.02.02.15.36.51;	author bavison;	state Exp;
branches;
next	1.24;
commitid	dsG4rJhYyVQhQr8y;

1.24
date	2014.11.02.17.24.55;	author jlee;	state Exp;
branches;
next	1.23;
commitid	ASl9I4vLOoLIoDWx;

1.23
date	2014.08.04.19.22.53;	author jlee;	state Exp;
branches;
next	1.22;
commitid	V4JFdZTE3n8yW4Lx;

1.22
date	2014.07.20.14.46.41;	author jlee;	state Exp;
branches;
next	1.21;
commitid	qYItZW3qfipHT7Jx;

1.21
date	2014.06.19.21.39.00;	author jlee;	state Exp;
branches;
next	1.20;
commitid	liIkzQDSHQtVabFx;

1.20
date	2014.05.03.08.19.22;	author rsprowson;	state Exp;
branches;
next	1.19;
commitid	Z1gL56lqEpOfg4zx;

1.19
date	2014.04.18.14.27.42;	author jlee;	state Exp;
branches;
next	1.18;
commitid	uRziBlqK8ezwMaxx;

1.18
date	2014.04.16.21.02.04;	author jlee;	state Exp;
branches;
next	1.17;
commitid	wYCRGB3p48VN1Xwx;

1.17
date	2014.02.19.21.25.34;	author jlee;	state Exp;
branches;
next	1.16;
commitid	VOdJLv4tprtsXKpx;

1.16
date	2014.01.19.18.50.36;	author jlee;	state Exp;
branches;
next	1.15;
commitid	U0h0iQgArKb56Llx;

1.15
date	2014.01.19.17.26.19;	author jlee;	state Exp;
branches;
next	1.14;
commitid	IgO3YUZfWktaDKlx;

1.14
date	2014.01.01.16.38.15;	author jlee;	state Exp;
branches;
next	1.13;
commitid	hv7JxPX2J7fxWqjx;

1.13
date	2013.12.19.22.49.23;	author jlee;	state Exp;
branches;
next	1.12;
commitid	t3YFuwm7k1CMpNhx;

1.12
date	2013.12.15.22.21.40;	author jlee;	state Exp;
branches;
next	1.11;
commitid	bwYuPhPuWChfohhx;

1.11
date	2013.04.14.14.39.32;	author jlee;	state Exp;
branches;
next	1.10;
commitid	a1V39UmGJTFXHKLw;

1.10
date	2013.03.03.20.26.48;	author jlee;	state Exp;
branches;
next	1.9;
commitid	JslUsC5BVloNYnGw;

1.9
date	2012.12.05.02.12.28;	author jlee;	state Exp;
branches;
next	1.8;
commitid	7zvxcLwjvUAJKYuw;

1.8
date	2012.11.25.22.29.58;	author jlee;	state Exp;
branches;
next	1.7;
commitid	KA5Rb3NW1StkONtw;

1.7
date	2012.10.16.23.46.55;	author jlee;	state Exp;
branches;
next	1.6;
commitid	oKsn0n3zdXitwFow;

1.6
date	2012.10.04.11.50.42;	author srevill;	state Exp;
branches;
next	1.5;
commitid	8zxYA76BRn8GW3nw;

1.5
date	2012.09.18.13.55.49;	author jlee;	state Exp;
branches;
next	1.4;
commitid	Apt88JppQEvt91lw;

1.4
date	2012.09.08.15.02.04;	author jlee;	state Exp;
branches;
next	1.3;
commitid	TZX98tKZGlo9QJjw;

1.3
date	2012.09.07.01.05.05;	author jlee;	state Exp;
branches;
next	1.2;
commitid	sA7cjtQbUOm0fxjw;

1.2
date	2012.09.02.20.13.32;	author jlee;	state Exp;
branches;
next	1.1;
commitid	Eobp7iVtciTWKZiw;

1.1
date	2012.07.22.13.15.48;	author jballance;	state Exp;
branches
	1.1.1.1;
next	;
commitid	CVhEuMVXjStaNydw;

1.40.2.1
date	2018.04.18.20.07.18;	author rsprowson;	state Exp;
branches;
next	;
commitid	0r2NY7C77CXnHXyA;

1.1.1.1
date	2012.07.22.13.15.48;	author jballance;	state Exp;
branches;
next	;
commitid	CVhEuMVXjStaNydw;


desc
@@


1.41
log
@Add support for the GraphicsV overlay API and alpha-blended screen modes. Allow gamma table use to be disabled via adding 'disable_gamma' to cmdline.txt
Detail:
  s/BCMVideo - Update workspace for the new features. On startup, check to see if 'disable_gamma' is included in the firmware-managed kernel command line (i.e. from cmdline.txt in the bootloader partition), and if so disable all use of the hardware gamma tables. Update mode vet & set to allow alpha-blending in 32bpp modes.
  s/Dispmanx, s/HWPointer - Move the dispmanx-related routines out of s/HWPointer and into their own file, for re-use by the GraphicsV overlay code
  s/GPUMode - Move the command line scanning code into s/BCMVideo so it's still available if the GPUMode build switch is disabled
  s/GenCmd - Tweak how GenCmd_GetConfigInt returns values so that zero-value variables can be distinguished from errors. Check the framebuffer_ignore_alpha variable to determine if the GPU will pay attention to the FBSetAlphaMode property tag.
  s/GraphicsV - Hook up the GraphicsV overlay entries. Fix determination of whether hardware pointer is fully supported to also check the screen height.
  s/GVOverlay - Initial support for the GraphicsV hardware overlay API. It's best used in 32bpp alpha-blended screen modes, so that the overlays can be placed behind the desktop. Rotated/flipped overlays aren't supported yet.
Admin:
  Tested on Raspberry Pi 1 & 3
  Requires BCMSupport-0_08
  disable_gamma should allow people who are frequently affected by https://www.riscosopen.org/forum/forums/11/topics/10346 to use their systems, pending a proper fix once the root cause has been determined.
  Note that options in cmdline.txt should be space-separated, so to disable both GPU mode changes & gamma table use you'll want 'disable_gamma disable_mode_changes'.


Version 0.51. Tagged as 'BCMVideo-0_51'
@
text
@; Copyright 2012 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;
        ; You'll often see these prefixed with Hdr: for historic reasons.
        ; This is no longer necessary, and in fact omitting them makes it
        ; possible to cross-compile your source code.
        GET     ListOpts
        GET     Macros
        GET     System
        GET     ModHand
        GET     Services
        GET     BCM2835Reg
        GET     ResourceFS
        GET     PCI
        GET     VersionASM
        GET     Proc
        GET     FSNumbers
        GET     NewErrors
        GET     DMA
        GET     VideoDevice
        GET     HALEntries
        GET     VduExt
        GET     VIDCList
        GET     BCMSupport
        GET     VCHIQ
        GET     RTSupport
        GET     Portable
        GET     OSMem

        GBLL    Debug
Debug   SETL    {FALSE}

        GBLL    Debug_DADebug
Debug_DADebug SETL Debug :LAND: {FALSE}

          GBLL  HWPointer ; Hardware pointer via VCHIQ/dispmanx
HWPointer SETL  {TRUE}

 [ :LNOT: :DEF: GenCmd
          GBLL  GenCmd ; vcgencmd via VCHIQ
GenCmd    SETL  {TRUE}
 ]

          GBLL  GPUMode ; Enable GPU mode changes
GPUMode   SETL  GenCmd :LAND: {TRUE}

          GBLL  BuiltinMDF ; Enable the builtin MDF
BuiltinMDF SETL :LNOT: GPUMode          

          GBLL  AemulorSupport ; Tweak things to allow Aemulor's low colour mode emulation to work with the new GraphicsV API
AemulorSupport SETL {TRUE}

          GBLL TimerDebug ; Update some workspace vars with timer debug values
TimerDebug SETL {FALSE}

          GBLL TimeDebug ; Use the timer to log the timing of various events and GraphicsV calls
TimeDebug SETL Debug :LAND: {FALSE}

          GBLL ControlRGB ; Do we allow control of RGB/BGR order? Firmware interface for this seems to be broken
ControlRGB SETL {FALSE}

          GBLL GammaDisable ; Allow 'disable_gamma' in cmdline.txt?
GammaDisable SETL {TRUE}

MaxOverlayBuffers *      8
MaxOverlays       *      8
NumHeads          *      1 ; Offset applied to overlay numbers

                          ^ 0
GVOverlayBuffer_Resource  # 4 ; dispmanx overlay resource, -1 if not created
GVOverlayBuffer_MemHandle # 4 ; memory handle
GVOverlayBuffer_Mapping   # 3*8 ; MapOverlayBuffer result, up to three planes
GVOverlayBuffer_Size      * :INDEX: @@

; GraphicsV overlay structure
                       ^ 0
GVOverlay_Format       # 4 ; Pointer to format info, null if slot is free
GVOverlay_Element      # 4 ; dispmanx element, zero if none
GVOverlay_InvXScale    # 4 ; size/scaled_size, in 16.16 format
GVOverlay_InvYScale    # 4
GVOverlay_Width        # 2
GVOverlay_Height       # 2
GVOverlay_XCoord       # 2
GVOverlay_YCoord       # 2
GVOverlay_ClipRectX0   # 2
GVOverlay_ClipRectY0   # 2
GVOverlay_ClipRectX1   # 2
GVOverlay_ClipRectY1   # 2
GVOverlay_ScaledWidth  # 2
GVOverlay_ScaledHeight # 2
GVOverlay_Mapped       # 1 ; bit map of which buffers have been mapped by MapOverlayBuffer
        ASSERT MaxOverlayBuffers <= 8
GVOverlay_DisplayBank  # 1 ; (desired) displayed bank number, 255 if none
GVOverlay_Depth        # 1 ; 0=frontmost, 255=backmost
GVOverlay_NumBuffers   # 1 ; num buffers requested by user
                       AlignSpace 4
GVOverlay_Buffers      # GVOverlayBuffer_Size * MaxOverlayBuffers
GVOverlay_Size         * :INDEX:@@

; workspace definition
                 ^       0,      wp                              ; Store
tagbuffer        #       4
tagbuffer_size   *       4096 ; allocated by PCI module to ensure noncacheable
tagbuffer_busy   #       4 ; Nonzero if tag buffer is currently in use

PeriBase         #       4              ; io base address

mbxres           #       4 ; Size of displayed area
mbyres           #       4
mbxvres          #       4 ; Size of buffer
mbyvres          #       4
mbpitch          #       4 ; byte pitch
mbbpp            #       4 ; 8/16/32
mbxoff           #       4 ; Offset of displayed area
mbyoff           #       4
mbbase           #       4 ; physical base of frame buffer
mbscrsz          #       4 ; size
mbovertop        #       4 ; overscan top
mboverbottom     #       4
mboverleft       #       4
mboverright      #       4
ModeFlags        #       4

 [ Debug_DADebug
dadebug_writec   #       4
 ]

UpdateNeeded     #       4 ; Whether merged message needs sending

TimerVal         #       4 ; The counter value at the last VSync
 [ TimerDebug
CounterDiff      #       4
TimerLoad        #       4
 ]

vdu_init         #       4 ; VDU init phys addr, for GV_Render

GVinstance       #       1 ; GraphicsV driver number
TimerScale       #       1 ; Shift factor to convert counter value to timer value, plus one (for scheduling hardware updates)
 [ AemulorSupport
OldAemulor       #       1 ; Nonzero if an old version of Aemulor is running
 ]
BlankState       #       1 ; 1 if blanked, 0 if not blanked
 [ GammaDisable
GammaDisabled    #       1
 ]
                 AlignSpace
DMA_CB           #       4 ; Logical addr of DMA control block for GV_Render
DMA_CB_phy       #       4 ; ARM Physical addr of DMA control block
DMA_Offset       #       4 ; Mapping from ARM to GPU physical address
DMA_Chan         #       4 ; DMA channel registers
DMA_BurstLength  #       1 ; Burst length to use with DMA transfers
GVRenderNotAvailable #   1 ; Whether GraphicsV_Render is available
VSyncAvailable   #       1 ; Nonzero if (fake) VSync is available
VSyncTestCount   #       1 ; Counter used during VSync detection test

IRQTrigger       #       4 ; IRQ trigger routine from OS_PlatformFeatures
HALDevice        #       4 ; Pointer to our HAL device (if found)

VCHIQInstance    #       4

 [ GenCmd
GenCmdService    #       4 ; vcgencmd VCHIQ service
GenCmdResponded  #       4 ; Nonzero if vcgencmd response received
 ]

 [ GPUMode
TVService        #       4 ; TV VCHIQ service
TVServiceResponded #     4 ; Nonzero if response received
TVNotifyService    #     4 ; TV notification VCHIQ service
TVNotifyRTHandle   #     4 ; RTSupport handle for routine which reads TV service notification messages
TVNotifyRTStack    #     16 ; SYS mode stack (all work done in SVC mode)
TVNotifyPollword   #     4 ; Pollword used to wake RT routine
TVNotifyRTKill     #     4 ; Gets set to zero to trigger RT routine death; goes non-zero again once it's dead
TVNotifyModeChangeComplete # 4 ; Nonzero if we've received a (HDMI) mode change complete event

GPUModeAvailable #       4 ; Nonzero if GPU mode changes available
ConfigHDMIGroup  #       4 ; Configured hdmi_group read via vcgencmd
 ]

MaxFBMemory      #       4 ; Our guess at the largest framebuffer size we can use
MaxFBWidth       #       4 ; Configured GPU limits read via vcgencmd
MaxFBHeight      #       4
MinPixelClock    #       4
MaxPixelClock    #       4
DisplayRotate    #       4 ; Display rotation read via vcgencmd
DisplayRotate_0   *      0
DisplayRotate_90  *      1
DisplayRotate_180 *      2
DisplayRotate_270 *      3
DisplayRotate_HFlip * &10000
DisplayRotate_VFlip * &20000
FramebufferIgnoreAlpha # 4 ; Nonzero if FBSetAlphaMode tag is ignored by GPU

GammaBase        #       4 ; Base address of gamma table to use (for SCALER_DISPGAMADR - not ARM address space)

CurPalette       #       4*4
DispManServiceC  #       4 ; dispmanx client service
DispManServiceN  #       4 ; dispmanx notify service
DispManFree      #       4 ; Nonzero if Dispmanx_Send is idle
DispManResponded #       4 ; Nonzero if message response received
DisplayWidth     #       4 ; Actual display width
DisplayHeight    #       4 ; Height
DisplayTrans     #       4 ; Transform
DisplayFormat    #       4 ; Format
XScale           #       4 ; RISC OS pixel -> actual pixel scale
YScale           #       4
XOffset          #       4 ; X & Y offsets of RISC OS desktop in actual pixels
YOffset          #       4
YInvScale        #       4
DispHandle       #       4 ; dispmanx display handle
 [ HWPointer
HWPActive        #       4 ; true/false for whether active/available
HWPImage         #       4 ; ptr to 32bpp cursor image in 'PCI' RAM
HWPXCoord        #       4 ; X pos of cursor
HWPYCoord        #       4 ; Y pos of cursor
HWPPalDirty      #       1 ; Nonzero if palette changed
HWPImgDirty      #       1 ; Nonzero if HWPImage updated
HWPVisible       #       1 ; Nonzero if should be visible
HWPIsVisible     #       1 ; Nonzero if actually visible (maintained by RTRoutine)
HWPResource      #       4 ; dispmanx overlay resource
HWPElement       #       4 ; dispmanx element
RTDead           #       4 ; Nonzero if RTSupport routine is dead
RTActive         #       4 ; Nonzero if RTSupport routine is performing work
RTHandle         #       4 ; RTSupport routine handle
RTStack          #       512 ; SYS mode stack
 ]



Palette          #       256*4

 [ GPUMode
GPUMode_BufLen * 256 ; hdmitimings command contains 17 numbers, so 256 bytes should be plenty of space
HDMITimings_Len * 12 ; Length of "hdmi_timings"
LastGPUMode      #       GPUMode_BufLen-HDMITimings_Len
 ]
 
GVOverlays       #       MaxOverlays*GVOverlay_Size
GVOverlaysExt    *       GVOverlays - (GVOverlay_Size*NumHeads)

; align to 4 byte boundary
                 #       (((:INDEX:@@)+3):AND::NOT:3)-(:INDEX:@@)
TotalRAMRequired *      :INDEX: @@


; Device-specific struct for the VDU device

                        ^ 0
VDUDevSpec_SizeField    # 4 ; Size field
VDUDevSpec_DMAChan      # 4 ; Pointer to DMA channel
VDUDevSpec_BurstLen     # 4 ; Burst length for use with DMA channel
VDUDevSpec_Size         # 0 ; Size value to write to size field

BaseDepth_ZOrder        * -192 ; Firmware places the desktop at -127
BaseDepth_Basic         * 1024
Depth_Pointer           * 2000

        MACRO
        DebugTime
      [ TimeDebug
        Push    "r0-r3,lr"
        MOV     r0, #64
        BL      DebugTX
        LDR     r0, PeriBase
        ADD     r0, r0, #ARM_Timer_Base
        DoMemBarrier lr
        LDR     r0, [r0, #ARMTimer_Counter]
        DoMemBarrier lr
        BL      DebugHexTX4
        Pull    "r0-r3,lr"
      ]
        MEND

        ; Assembler modules are conventionally, but not necessarily,
        ; position-independent code. Area name |!| is guaranteed to appear
        ; first in link order, whatever your other areas are named.
        AREA    |!|, CODE, READONLY, PIC

        ENTRY

Module_BaseAddr
        DCD     0 ; Start
        DCD     Init - |!|
        DCD     Final - |!|
        DCD     ServiceCall - |!|; Service call handler
        DCD     Title - |!|
        DCD     Help - |!|
      [ GenCmd
        DCD     CmdTable - |!|
      |
        DCD     0 ; Keyword table
      ]
        DCD     0 ; SWI chunk
        DCD     0 ; SWI handler
        DCD     0 ; SWI table
        DCD     0 ; SWI decoder
        DCD     Messages - |!|
        DCD     Flags - |!|

Messages =      "Resources:$.Resources.BCMVideo.Messages", 0
Title   =       Module_ComponentName, 0
Help    =       Module_ComponentName, 9, Module_HelpVersion, 0
      [ HWPointer
RTPriority
        =       "BCMVideo:32", 0 ; Note - it seems to be important for the priority of our thread to be below that of VCHIQ (128). I suspect there's some synchronisation missing from our VCHIQ port?
      ]
      [ GPUMode
TVNotifyPriority
        =       "BCMVideo:32", 0
      ]
Module_VCHIQ
        =       "VCHIQ", 0
      [ AemulorSupport
Module_Aemulor
        =       "Aemulor", 0
      ]
      [ BuiltinMDF
loadmodefilecommand
        DCB     "loadmodefile Resources:Resources.BCMVideo.RPIMon",0
      ]
        ALIGN
Flags   &       ModuleFlag_32bit

        ASSERT  Service_PostInit < Service_ModulePostInit
        ASSERT  Service_ModulePostInit < Service_ModulePostFinal
ServiceCallTable
        DCD     0
        DCD     ServiceCallEntry - Module_BaseAddr
        DCD     Service_PostInit
        DCD     Service_ModulePostInit
      [ AemulorSupport
        DCD     Service_ModulePostFinal
      ]
        DCD     0

        DCD     ServiceCallTable - Module_BaseAddr
ServiceCall     ROUT
        MOV     r0, r0
        TEQ     r1, #Service_PostInit
        TEQNE   r1, #Service_ModulePostInit
      [ AemulorSupport
        TEQNE   r1, #Service_ModulePostFinal
      ]
        MOVNE   pc, lr

ServiceCallEntry
    [ AemulorSupport
        ; Has Aemulor just started or stopped?
        TEQ      r1, #Service_ModulePostInit
        TEQNE    r1, #Service_ModulePostFinal
        BNE      %FT09
        Entry    "r0,r2-r3"
        ADRL     r0, Module_Aemulor
01
        LDRB     r3, [r0], #1
        LDRB     lr, [r2], #1
        TEQ      r3, lr
        BNE      %FT08
        TEQ      r3, #0
        BNE      %BT01
        LDR      r12, [r12]
        ; Our compatibility hacks are only needed with version 2.34 and below
        CMP      r4, #&23400
        CMPLE    r1, #Service_ModulePostInit
        MOVEQ    r0, #1
        MOVNE    r0, #0
        STRB     r0, OldAemulor
        EXIT
08
        PullEnv
        TEQ      r1, #Service_ModulePostFinal
        MOVEQ    pc, lr
        ; Fall through into VCHIQ check
09
    ]
        TEQ      r1, #Service_ModulePostInit
        BNE      %FT90
        Entry    "r0-r2"
        ; Has VCHIQ just started?
        ADRL     r0, Module_VCHIQ
10
        LDRB     r1, [r0], #1
        LDRB     lr, [r2], #1
        TEQ      r1, lr
        BNE      %FT80
        TEQ      r1, #0
        BNE      %BT10
        LDR      r12, [r12]
        ; Initialise anything which relies on VCHIQ
        ; (should also trigger initialisation of VCHIQ itself)
      [ GenCmd
        BL       GenCmd_Init
      ]
      [ HWPointer
        BL       HWP_Init
      ]
        BL       GVOverlay_Init
      [ GPUMode
        BL       TVService_Init
        BL       GPUMode_Init
      ]
80
        EXIT
90
      [ BuiltinMDF
        stmfd    sp!, {r0,lr}
        adrl     r0, loadmodefilecommand
        swi      XOS_CLI
        ldmfd    sp!, {r0,pc}
      |
        MOV      pc, lr
      ]

      [ BuiltinMDF
startupmode
        DCD 1
        DCD 1920
        DCD 1080
        DCD 5
        DCD -1
        DCD -1
      ]

Init    ROUT
        Push    "r8-r9,lr"
        MOV     r0, #ModHandReason_Claim
        LDR     r3, =TotalRAMRequired
        SWI     XOS_Module
        BVS     ExitInitModule

        STR     r2, [r12]
        mov     r12, r2
        MOV     r0, #0
01
        SUBS    r3, r3, #4
        STR     r0, [r2], #4
        BGT     %BT01
        MOV     r0, #1
        STRB    r0, GVRenderNotAvailable
        MOV     r0, #255
        STRB    r0, GVinstance
      [ Debug_DADebug
        SWI     &731C0                    ; XDADebug_GetWriteCAddress
        ADRVS   r0, NullFunc
        STR     r0, dadebug_writec
      ]

        MRC     p15, 0, r1, c0, c0, 0     ; read Main ID Register
        AND     r1, r1, #&FF00
        CMP     r1, #&C000                ; xxxxB76x for ARM1176, xxxxC07x for Cortex-A7
        MOVCC   r1, #&40000000            ; Pi 1: ARM physical address -> L2 cached GPU physical address
        MOVCS   r1, #&C0000000            ; Pi 2: ARM physical address -> uncached GPU physical address
        STR     r1, DMA_Offset
        MOV     r0, #13                   ; map in the IO space
        LDRCC   r1, =IO_Base_BCM2835
        LDRCS   r1, =IO_Base_BCM2836      ; to get the register address
        LDR     r2, =IO_Size
        swi     XOS_Memory
        BVS     ExitInitModule
        STR     r3, PeriBase              ; remember logical address

      [ HWPointer
        LDR     r0, =tagbuffer_size+DMACB_SIZE+32*32*4 ; tag buffer + DMA CB + HW cursor image in one block
      |
        LDR     r0, =tagbuffer_size+DMACB_SIZE
      ]
        ASSERT  DMACB_ALIGN >= 16 ; 16 alignment needed for tag buffer
        MOV     r1, #DMACB_ALIGN
        MOV     r2, #0
        SWI     XPCI_RAMAlloc
        BVS     ExitInitModule
        STR     r0, tagbuffer
        ADD     r0, r0, #tagbuffer_size
        ADD     r1, r1, #tagbuffer_size
        ASSERT  ?DMACB_RESERVED = 8
        ; Note r2=0
        STR     r2, [r0, #DMACB_RESERVED]
        STR     r2, [r0, #DMACB_RESERVED+4]
        STR     r0, DMA_CB
        STR     r1, DMA_CB_phy
      [ HWPointer
        ADD     r0, r0, #DMACB_SIZE
        STR     r0, HWPImage
      ]
        STR     r2, tagbuffer_busy

        ; Set default GPU limits
        MOV     r0, #1920
        STR     r0, MaxFBWidth
        MOV     r0, #1200
        STR     r0, MaxFBHeight
        LDR     r0, =25000000
        STR     r0, MinPixelClock
        LDR     r0, =162000000
        STR     r0, MaxPixelClock
        MOV     r0, #1
        STR     r0, FramebufferIgnoreAlpha

        ; Read how much GPU memory is available so we can guess at the largest
        ; framebuffer size we can safely use
        ADRL    r0, vcmemtags
        SUB     sp, sp, #vcmemtagslen
        MOV     r1, sp
        MOV     r2, #0
        SWI     XBCMSupport_SendTempPropertyBuffer
        LDRVC   r0, [r1, #VCsz-vcmemtags]
        ADD     sp, sp, #vcmemtagslen
        BVS     ExitInitModule
        ; With 32MB GPU memory, 1920x1200x32bpp * 2 (= ~17.5MB) is too much
        ; 1600x1200x32bpp * 2 (= ~14.6MB) is also too much
        ; However 1920x1200x16bpp * 2 (~8.8MB) is fine (and so would be
        ; 1920x1200x32bpp * 1)
        ; So let's say that the GPU needs 32MB-9MB = 23MB to operate
        ; n.b. default GPU memory size is 64MB for a 256MB Pi, so the limit
        ; we're calculating here is only likely to affect people who artifically
        ; limit the amount of memory the GPU gets.
        SUBS    r0, r0, #23<<20
        MOVLO   r0, #0
        STR     r0, MaxFBMemory

        ; Get IRQTrigger routine
        MOV     r0, #0
        SWI     XOS_PlatformFeatures
        MOVVS   r0, #0
        TST     r0, #2
        ADREQ   r1, NullFunc ; Just use NullFunc if no trigger needed
        STR     r1, IRQTrigger
        CLRV

        ADRL    R0,resourcefsfiles
        SWI     XResourceFS_RegisterFiles   ; ignore errors

      [ GammaDisable
        ADR     r6, disable_gamma_str
        BL      CheckCmdlineTxt
        MOVVS   r0, #1
        MOVVC   r0, #0
        STRB    r0, GammaDisabled
      ]

        ; Try and initialise anything which relies on VCHIQ
        ; (should also trigger initialisation of VCHIQ itself)
      [ GenCmd
        BL      GenCmd_Init
      ]
      [ HWPointer
        BL      HWP_Init
      ]
        BL      GVOverlay_Init
      [ GPUMode
        BL      TVService_Init
        BL      GPUMode_Init
      ]

        MOV     r0, #ScreenModeReason_RegisterDriver
        MOV     r1, #0
        ADR     r2, Title
        SWI     XOS_ScreenMode                          ; get a driver number
        BVS     ExitInitModule
        STRB    r0, GVinstance
        
      [ BuiltinMDF
        adrl    r0, loadmodefilecommand
        swi     XOS_CLI
      ]

        ; Search for a HAL device containing the DMA channel info
        LDR     r0, =HALDeviceType_Video + HALDeviceVideo_VDU
        MOV     r1, #0
        MOV     r8, #4
20
        SWI     XOS_Hardware
        BVS     %FT30
        CMP     r1, #-1
        BEQ     %FT30
        LDRH    r3,[r2,#HALDevice_ID]
        CMP     r3,#HALDeviceID_VDU_BCM2835
        BNE     %BT20
        LDR     lr, [r2, #HALDevice_VDUDeviceSpecificField]
        LDR     r0, [lr, #VDUDevSpec_DMAChan]
        LDR     r1, [lr, #VDUDevSpec_BurstLen]
        STR     r0, DMA_Chan
        STRB    r1, DMA_BurstLength
        STR     r2, HALDevice
30
        CLRV

        ; Check whether the fake VSync IRQ is working
        ; We require at least 3 interrupts in a 20cs period
        MOV     r0, #iDev_GPU_SMI
        ADRL    r1, VSync_Test
        MOV     r2, r12
        SWI     XOS_ClaimDeviceVector
        BVS     %FT40
        MOV     r0, #iDev_GPU_SMI
        MOV     r8, #0
        MOV     r9, #EntryNo_HAL_IRQEnable
        SWI     XOS_Hardware
        SWI     XOS_ReadMonotonicTime
        BVS     %FT32
        ADD     r1, r0, #20
31
        LDRB    r0, VSyncTestCount
        CMP     r0, #3
        BGT     %FT32
        SWI     XOS_ReadMonotonicTime
        SUBS    r0, r0, r1
        BLE     %BT31
32
        MOV     r0, #iDev_GPU_SMI
        ADRL    r1, VSync_Test
        MOV     r2, r12
        SWI     XOS_ReleaseDeviceVector
        LDRB    r0, VSyncTestCount
        CMP     r0, #3
        BLE     %FT40
        STRB    r0, VSyncAvailable
        ; Set up the ARM timer
        ; We use this to generate an IRQ roughly halfway inbetween successive
        ; VSync IRQs, so that we can send any pending messages to the GPU in
        ; plenty of time for it to process them during its VSync handler
        LDR     r0, PeriBase
        ADD     r0, r0, #ARM_Timer_Base
        DoMemBarrier lr
        LDR     r1, [r0, #ARMTimer_Control]
        BIC     r1, r1, #ARMTimer_Control_Enable ; Must stop before reconfiguring
        STR     r1, [r0, #ARMTimer_Control]
        ; Set the counter predivider to be the same as the timer predivider
        ; Note that the timer predivider is 10 bits, but the counter predivider
        ; is only 8 bits, so we have to be prepared to do some scaling. This
        ; scaling isn't entirely accurate, but it should be more than adequate
        ; considering that we're only interested in an IRQ that's roughly in
        ; the middle of two VSync IRQs.
        LDR     r2, [r0, #ARMTimer_Predivider]
        BIC     r1, r1, #ARMTimer_Control_PredividerMask
        CLZ     r3, r2
        RSBS    r3, r3, #24
        MOVGT   r2, r2, LSR r3
        MOVLT   r3, #0
        ADD     r3, r3, #1 ; Add 1 to the shift value to save an extra divide by two in the VSync handler
        STRB    r3, TimerScale
        ORR     r1, r1, r2, LSL #ARMTimer_Control_PredividerShift
        BIC     r1, r1, #ARMTimer_Control_IRQEnable+ARMTimer_Control_PrescaleMask
        ORR     r1, r1, #ARMTimer_Control_32bit
        STR     r1, [r0, #ARMTimer_Control] ; Reconfigure
        ORR     r1, r1, #ARMTimer_Control_CounterEnable+ARMTimer_Control_Enable
        STR     r1, [r0, #ARMTimer_Control] ; Go!
        LDR     r1, [r0, #ARMTimer_Counter]
        DoMemBarrier lr
        STR     r1, TimerVal        
        MOV     r0, #iDev_ARM_Timer
        ADRL    r1, Timer_Handler
        MOV     r2, r12
        SWI     XOS_ClaimDeviceVector
        BVS     %FT40
        MOV     r0, #iDev_ARM_Timer
        MOV     r8, #0
        MOV     r9, #EntryNo_HAL_IRQEnable
        SWI     XOS_Hardware
        ; Now set up the VSync handler
        MOV     r0, #iDev_GPU_SMI
        ADRL    r1, VSync_Handler
        MOV     r2, r12
        SWI     XOS_ClaimDeviceVector
        MOV     r0, #iDev_GPU_SMI
        MOV     r8, #0
        MOV     r9, #EntryNo_HAL_IRQEnable
        SWI     XOS_Hardware
        B       %FT90

40
        ; No VSync IRQ available
        ; Let the OS use its fake VSync
        ; However we also need our own fake VSync (synchronised with the OS's)
        ; in order to manage sending the merged message (we keep it in sync with
        ; the OS's message to try and ensure it behaves in a fairly consistent
        ; manner)
        ; Simply listening for the VSync event that the OS generates isn't
        ; sufficient because we might not be the default video driver!
        MOV     r0, #TickerV
        ADRL    r1, TickerV_Handler
        MOV     r2, r12
        SWI     XOS_Claim

90
        CLRV

        MOV     r0, #GraphicsV                          ; grab GraphicsV
        ADRL    r1, GraphicsV_Handler
        MOV     r2, r12
        SWI     XOS_Claim

        MOV     r0, #ScreenModeReason_StartDriver
        LDRB    r1, GVinstance
        SWI     XOS_ScreenMode                          ; let the OS know we're ready

        Pull    "r8-r9,pc"

ExitInitModule                            ; need to check for what is allocated
        Pull    "r8-r9,pc"

NullFunc
        MOV     pc, lr

Final   ROUT
        Push    "lr"
        LDR     r12, [r12]

        MOV     r0, #ScreenModeReason_StopDriver
        LDRB    r1, GVinstance
        SWI     XOS_ScreenMode                ; tell the OS we're leaving

        ; Shutdown VCHIQ + dependants
        BL      VCHIQFinalise

        LDRB    r0, VSyncAvailable
        CMP     r0, #0
        MOVEQ   r0, #TickerV
        ADREQL  r1, TickerV_Handler
        MOVEQ   r2, r12
        SWIEQ   XOS_Release
        ADRL    R0,resourcefsfiles
        SWI     XResourceFS_DeregisterFiles ; ignore errors
        MOV     r0, #GraphicsV
        ADRL    r1, GraphicsV_Handler
        MOV     r2, r12
        SWI     XOS_Release
        MOV     r0, #iDev_GPU_SMI
        ADRL    r1, VSync_Handler
        MOV     r2, r12
        SWI     XOS_ReleaseDeviceVector
        MOV     r0, #iDev_ARM_Timer
        ADRL    r1, Timer_Handler
        MOV     r2, r12
        SWI     XOS_ReleaseDeviceVector
        BL      GV_Render_Sync
        ; Ensure no pending async mailbox messages
        MOV     r0, #MBSync_OnR12
        MOV     r4, r12
        SWI     XBCMSupport_MBSync
        LDR     r0, tagbuffer
        SWI     XPCI_RAMFree
        MOV     r0, #ScreenModeReason_DeregisterDriver
        LDRB    r1, GVinstance
        SWI     XOS_ScreenMode
        CLRV
        Pull    "pc"

 [ GammaDisable
disable_gamma_str = "disable_gamma",0
        ALIGN
 ]

        LTORG

tagrel  DCD     tagrellen
        DCD     0
        DCD     ARM2VC_Tag_FBRelease
        DCD     0
        DCD     0
        DCD     ARM2VC_Tag_End
tagrellen *     . - tagrel

; series of VC side query tags.
;
tagb    DCD     tagslen
        DCD     0
tagdisplphyswh
        DCD     ARM2VC_Tag_FBSetPhysDimension
        DCD     8
        DCD     8
phyx    DCD     1920
phyy    DCD     1080
tagdisplvirtwh
        DCD     ARM2VC_Tag_FBSetVirtDimension
        DCD     8
        DCD     8
virtx   DCD     1920
virty   DCD     1080
tagdisplvirtoffset
        DCD     ARM2VC_Tag_FBSetVirtOffset
        DCD     8
        DCD     8
vxoff   DCD     0
vyoff   DCD     0
tagdispldepth
        DCD     ARM2VC_Tag_FBSetDepth
        DCD     4
        DCD     4
dispbpp DCD     32                 ; 32bit
tagdisplpixord
        DCD     ARM2VC_Tag_FBSetPixelOrder
        DCD     4
        DCD     4
disppixord DCD  1                  ; &BGR
tagdisplalpha
        DCD     ARM2VC_Tag_FBSetAlphaMode
        DCD     4
        DCD     4
dispalpha DCD   2                  ; 0='normal' alpha channel (0=opaque), 1='reverse' alpha channel (0=transparent), 2=ignored
taggetpitch
        DCD     ARM2VC_Tag_FBGetPitch
        DCD     4
        DCD     0
dispit  DCD     0
tagdisplalloc
        DCD     ARM2VC_Tag_FBAlloc
        DCD     8
        DCD     8
dispbs  DCD     0x100000            ; megabyte aligned
dispsz  DCD     0
        DCD     ARM2VC_Tag_FBGetOverscan
        DCD     16
        DCD     0
dispovertop     DCD 0
dispoverbottom  DCD 0
dispoverleft    DCD 0
dispoverright   DCD 0        
        DCD     ARM2VC_Tag_FBBlank
        DCD     4
        DCD     4
        DCD     0                   ; Unblank screen on any mode change
        DCD     ARM2VC_Tag_End
tagslen *       . - tagb


vettagb  DCD     vettagslen
         DCD     0
vtagdisplphyswh
         DCD     ARM2VC_Tag_FBTestPhysDimension
         DCD     8
         DCD     8
vphyx    DCD     1920
vphyy    DCD     1080
vtagdisplvirtwh
         DCD     ARM2VC_Tag_FBTestVirtDimension
         DCD     8
         DCD     8
vvirtx   DCD     1920
vvirty   DCD     1080
vtagdisplvirtoffset
         DCD     ARM2VC_Tag_FBTestVirtOffset
         DCD     8
         DCD     8
vvxoff   DCD     0
vvyoff   DCD     0
vtagdispldepth
         DCD     ARM2VC_Tag_FBTestDepth
         DCD     4
         DCD     4
vdispbpp DCD     32                 ; 32bit
         DCD     ARM2VC_Tag_End
vettagslen *       . - vettagb

vcmemtags DCD   vcmemtagslen
          DCD   0
tagvcmem
        DCD     ARM2VC_Tag_GetVCMemory
        DCD     8
        DCD     0
VCbs    DCD     0
VCsz    DCD     0
        DCD     ARM2VC_Tag_End
vcmemtagslen *  . - vcmemtags

edidtagb   DCD    edidtagslen
           DCD    0
           DCD    ARM2VC_Tag_GetEDID
           DCD    136
           DCD    4
edidblock  DCD    0
edidstatus DCD    0
edidbuffer %      128
           DCD    ARM2VC_Tag_End
edidtagslen *     . - edidtagb

mergetags      DCD   mergetagslen+256*4+4 ; total size
               DCD   0
               DCD   ARM2VC_Tag_FBBlank
               DCD   4
               DCD   4
mergeblank     DCD   0
               DCD   ARM2VC_Tag_FBSetVirtOffset
               DCD   8
               DCD   8
mergevxoff     DCD   0
mergevyoff     DCD   0
               DCD   ARM2VC_Tag_FBSetPalette
               DCD   8+256*4
               DCD   8+256*4
               DCD   0 ; first palette entry
               DCD   256 ; entry count
mergepaldata
               ; ... entries here ...
mergetagslen   *     . - mergetags

; r0->VIDCList3
; r12-> workspace
SetModeFromVIDCList     ROUT
      [ GPUMode
        ASSERT  tagslen <= GPUMode_BufLen
        Entry   "r0-r10", GPUMode_BufLen   ; Reserve space for vcgencmd buffer
      |
        Entry   "r0-r10", tagslen
      ]
        mov     r6, r0                     ; preserve the list pointer
 [ Debug
  bl DebugTXStrInline
  DCB "start SetMode",10,13,0
  ALIGN
 ]
        MOV     r3, sp
        
        ; Block GV_Render, and sync any current transfer for paranoia
        MOV     r0, #1
        STRB    r0, GVRenderNotAvailable
        BL      GV_Render_Sync

 [ Debug
        MOV     r5, r6
        ASSERT  (VIDCList3_ControlList :AND: 7) = 0
11      ldr     r0, [r5], #4
        bl      DebugHexTX4
        cmn     r0, #1
        beq     %ft12
        ldr     r0, [r5], #4
        bl      DebugHexTX4
        b       %bt11

12
        bl      DebugTXStrInline
        DCB     10,13,"modedefbuf printed",10,13,0
        ALIGN
 ]
        ; Release all hardware overlays
        BL      GVOverlay_Finalise

        ; Release current framebuffer before allocating new one - required to
        ; avoid problems in some situations (e.g. if the new mode is narrower
        ; than the old mode, we can end up with a stride that matches the old
        ; mode rather than one which matches the new mode, resulting in a
        ; corrupt display because we have no way of dictating the stride to the
        ; OS)
        ADRL    r0, tagrel
        ASSERT  tagrellen <= tagslen
        MOV     r1, sp
        MOV     r2, #0
        SWI     XBCMSupport_SendTempPropertyBuffer

      [ GPUMode
        MOV     r1, sp
        BL      SetGPUModeFromVIDCList
      ]

        adrl    r1, tagb                     ; buffer source
        ldr     r2, [r1]                     ; length
111     subs    r2, r2, #4                   ; initialise the tagbugffer
        ldrge   r4, [r1, r2]
        strge   r4, [r3, r2]
        bgt     %bt111

        LDR     r0, [r6, #VIDCList3_PixelDepth]
        CMP     r0, #4
        MOVLO   r0, #8
        MOVEQ   r0, #16
        MOVHI   r0, #32
        STR     r0, mbbpp
        str     r0, [r3, #dispbpp-tagb]

        ADD     r2, r6, #VIDCList3_ControlList
        MOV     r8, #0 ; Interlace flag
        MOV     r9, #0 ; ExtraBytes
        MOV     r10, #0 ; ModeFlags
20
        LDR     r1, [r2], #4
        CMP     r1, #-1
        BEQ     %FT30
        LDR     r14, [r2], #4
        CMP     r1, #ControlList_Interlaced
        MOVEQ   r8, r14
        CMP     r1, #ControlList_ExtraBytes
        MOVEQ   r9, r14
        CMP     r1, #ControlList_ModeFlags
        MOVEQ   r10, r14
        B       %BT20
30
        STR     r10, ModeFlags

        LDR     r1, [r6, #VIDCList3_HorizDisplaySize]
        LDR     r2, [r6, #VIDCList3_VertiDisplaySize]
        MOV     r2, r2, LSL r8
        BL      CalcScreenSize

        STR     r1, mbxres
        ; Add the ExtraBytes into the virtual width
        LDR     r0, [r6, #VIDCList3_PixelDepth]
        SUB     r0, r0, #3
        ADD     r9, r1, r9, LSR r0
        STR     r9, mbxvres
        str     r1, [r3, #phyx-tagb]
        str     r9, [r3, #virtx-tagb]
        STR     r2, mbyres
        STR     r4, mbyvres
        str     r2, [r3, #phyy-tagb]
        str     r4, [r3, #virty-tagb]

        ; Control RGB & alpha for 32bpp
        CMP     r0, #2
        BNE     %FT40
     [ ControlRGB
        TST     r10, #ModeFlag_DataFormatSub_RGB
        MOVNE   r0, #0
        STRNE   r0, [r3, #disppixord-tagb]
     ]
        TST     r10, #ModeFlag_DataFormatSub_Alpha
        MOVNE   r0, #1
        STRNE   r0, [r3, #dispalpha-tagb]
40
        MOV     r0, #0
        STR     r0, mbxoff
        STR     r0, mbyoff

        mov     r0, sp
        mov     r1, sp
        mov     r2, #0
 [ Debug
  bl DebugHexTX4
 ]
        SWI     XBCMSupport_SendTempPropertyBuffer
        ; TODO handle error
 [ Debug
  bl DebugTXStrInline
  DCB "done FB.. size .. physadd",10,13,0
  ALIGN
 ]
 [ {FALSE}
        ; GPU seems to return virtual buffer size instead of physical size?
        ; Calculate manually from pitch & height
        LDR     r0, [r3,#dispit-tagb]
        LDR     lr, [r3,#phyy-tagb]
        MUL     r0, lr, r0
 |
        ldr     r0, [r3,#dispsz-tagb]
 ]
        str     r0, mbscrsz
 [ Debug
  bl DebugHexTX4
 ]
        ldr     r0, [r3,#dispbs-tagb]

        ; Originally the GPU returned an ARM physical address, however this
        ; seems to have recently been classified as a bug and changed to return
        ; a GPU physical address:
        ; https://github.com/raspberrypi/linux/pull/1026#issuecomment-114263464
        ; We want an ARM address, so detect if it's out of range and apply the
        ; correct offset.
        ldr     lr, DMA_Offset
        CMP     r0, lr
        SUBHS   r0, r0, lr
        
        str     r0, mbbase
        STR     r0, vdu_init ; just in case GV_Render calls are received before RISC OS tells us the VDU address
 [ Debug
  bl DebugHexTX4
 ]

        ldr     r0, [r3,#dispit-tagb]
        str     r0, mbpitch
 [ Debug
  bl DebugHexTX4
 ]
        ldr     r0, [r3,#dispovertop-tagb]
        str     r0, mbovertop
 [ Debug
  bl DebugHexTX4
 ]
        ldr     r0, [r3,#dispoverbottom-tagb]
        str     r0, mboverbottom
 [ Debug
  bl DebugHexTX4
 ]
        ldr     r0, [r3,#dispoverleft-tagb]
        str     r0, mboverleft
 [ Debug
  bl DebugHexTX4
 ]
        ldr     r0, [r3,#dispoverright-tagb]
        str     r0, mboverright
 [ Debug
  bl DebugHexTX4
 ]


        ; Allow GV_Render, if DMA channel available
        LDR     r0, DMA_Chan
        TEQ     r0, #0
        MOVNE   r0, #0
        STRNEB  r0, GVRenderNotAvailable
        ; Re-init dispmanx / update display scale factor as appropriate
        LDR     r0, DispManServiceC
        CMP     r0, #0
        ADR     lr, %FT90
        BNE     Dispmanx_CalcDisplayScaleOffset
        BL      Dispmanx_Init
 [ HWPointer
        ; Re-init hardware pointer too
        BL      HWP_Init
 ]
90
      [ GammaDisable
        LDRB    r0, GammaDisabled
        CMP     r0, #0
        BNE     %FT92
      ]
        LDR     r0, mbbpp
        MOV     r1, #0
        CMP     r0, #8
        BEQ     %FT91
        ; There's no firmware interface for gamma control, but it looks like we
        ; can just poke the gamma tables directly without anything getting
        ; upset. Detect which scaler unit is in use, and make sure gamma is
        ; enabled for it.
        LDR     r0, PeriBase
        ADD     r0, r0, #SCALER
        DoMemBarrier lr
        LDR     r2, [r0, #SCALER_DISPCTRL0]!
        TST     r2, #&80000000
        ADDEQ   r1, r1, #256*3
        LDREQ   r2, [r0, #SCALER_DISPCTRL1-SCALER_DISPCTRL0]!
        TSTEQ   r2, #&80000000
        ADDEQ   r1, r1, #256*3
        LDREQ   r2, [r0, #SCALER_DISPCTRL2-SCALER_DISPCTRL1]!
        TSTEQ   r2, #&80000000
        ORRNE   r1, r1, #&80000000 ; Enable auto-increment for gamma addresses. Also used by us as a "gamma enabled" flag.
        LDRNE   r2, [r0, #SCALER_DISPBKGND0-SCALER_DISPCTRL0]
        ORRNE   r2, r2, #1<<29 ; Enable gamma LUT in scaler
        STRNE   r2, [r0, #SCALER_DISPBKGND0-SCALER_DISPCTRL0]
        DoMemBarrier lr
91
        LDR     r0, GammaBase
        STR     r1, GammaBase
        ; Reset both old & new gamma table, as necessary
        CMP     r1, #0
        BLMI    ResetGamma
        CMP     r0, r1
        MOVNES  r1, r0
        BLMI    ResetGamma
92
        ; Allow overlays to be created again
        BL      GVOverlay_Init
 [ Debug
  bl DebugTXStrInline
  DCB "done FB2",10,13,0
  ALIGN
 ]
        EXIT

; In:
; r0 = BPP (8,16,32)
; r1 = physical width
; r2 = physical height
; Out:
; r4 = virtual height
CalcScreenSize  ROUT
        Entry   "r3,r5"
        ; Work out how many screen buffers we can fit before hitting any limits.
        ;
        ; First of all, check our memory limit
        MUL     r5, r0, r1
        LDR     r3, MaxFBMemory
        MOV     r3, r3, LSL #3 ; Size in bits, not bytes
        MUL     r5, r2, r5
        DivRem  r4, r3, r5, lr
        ; The GPU limits the dimensions of the virtual framebuffer to being no
        ; larger than twice the maximum physical framebuffer size.
        ;
        ; So we have an additional limit of 2*MaxFBHeight/r2
        ; (or, if rotated, 2*MaxFBWidth/r2)
        ;
        ; N.B. Firmware versions prior to Jan 28 2017 contained a bug where the
        ; two limits were swapped.
        LDR     r3, DisplayRotate
        TST     r3, #DisplayRotate_90
        LDREQ   r3, MaxFBHeight
        LDRNE   r3, MaxFBWidth
        MOV     r3, r3, LSL #1
        DivRem  r5, r3, r2, lr
        ; Pick the lowest
        CMP     r5, r4
        MOVLT   r4, r5
        ; Make sure we allocate at least one buffer
        CMP     r4, #0
        MOVLE   r4, #1
        ; Calculate corresponding height
        MUL     r4, r2, r4
      [ Debug
        Push    "r0"
        BL      DebugHexTX
        MOV     R0, R1
        BL      DebugHexTX4
        MOV     R0, R2
        BL      DebugHexTX4
        MOV     R0, R4
        BL      DebugHexTX4
        BL      DebugTXStrInline
        DCB     "CalcScreenSize BPP W H -> VH",10,13,0
        ALIGN
        Pull    "R0"
      ]        
        EXIT

; In:
; r0 -> VIDCList3
; r12 -> workspace
; Out:
; r0 = GVVetMode2 flags
; r2 = suggested ExtraBytes value
VetModeFromVIDCList     ROUT
        Entry   "r1,r3-r9"
        mov     r6, r0                     ; preserve the list pointer

 [ Debug
        bl      DebugTXStrInline
        DCB     "start vmfv3",10,13,0
        ALIGN
        MOV     r5, r6
        ASSERT  (VIDCList3_ControlList :AND: 7) = 0
11      ldr     r0, [r5], #4
        bl      DebugHexTX4
        cmn     r0, #1
        beq     %ft12
        ldr     r0, [r5], #4
        bl      DebugHexTX4
        b       %bt11

12
        bl      DebugTXStrInline
        DCB     10,13,"modedefbuf printed",10,13,0
        ALIGN
 ]

        LDR     r0, [r6]
        CMP     r0, #3
        BNE     %FT999

        ; Vet the pixel depth
        LDR     r1, [r6, #VIDCList3_PixelDepth]
        CMP     r1,#3
        CMPNE   r1,#4
        CMPNE   r1,#5
        BNE     %FT999

        ; Convert pixel depth to expected NColour value
        MOV     r2,#1
        MOV     r1,r2,LSL r1 ; log2bpp -> bpp
        RSB     r1,r2,r2,LSL r1 ; bpp -> ncolour

        ; Vet the control list
        ADD     r2,r6,#VIDCList3_ControlList
        MOV     r8,#0 ; Interlace flag
        MOV     r9,#0 ; ExtraBytes
10        
        LDR     r3,[r2],#4
        CMP     r3,#-1
        BEQ     %FT40
        LDR     r14,[r2],#4
        TEQ     r3,#ControlList_ExtraBytes
        MOVEQ   r9,r14
        BEQ     %BT10
20
        TEQ     r3,#ControlList_NColour
        BNE     %FT30
        CMP     r14,r1
        BNE     %FT999
        B       %BT10
30
        TEQ     r3,#ControlList_ModeFlags
        BNE     %FT35
        ; Calculate the expected ModeFlags value
      [ ControlRGB
        MOV     r0,#ModeFlag_DataFormatSub_RGB
      |
        MOV     r0,#0
      ]
        LDR     r3,FramebufferIgnoreAlpha
        CMP     r3,#0
        ORREQ   r0,r0,#ModeFlag_DataFormatSub_Alpha
        TEQ     r1,#255 ; EQ -> 8bpp, NE -> 16bpp, MI -> 32bpp
        MOVEQ   r3,#ModeFlag_FullPalette
        LDRNE   r3,=ModeFlag_DataFormatSub_RGB+ModeFlag_64k
        MOVMI   r3,#0                   ; Must be after NE case
        BICMI   r14,r14,r0              ; r0 is mask of which RGB/alpha flags we support
        CMP     r3,r14
        BNE     %FT999
        B       %BT10
35
        TEQ     r3,#ControlList_Interlaced
        BNE     %BT10
        CMP     r14,#1
        MOV     r8,r14
        BHI     %FT999
        B       %BT10
40

        ; Calculate row pitch in bytes
        LDR     r0, [r6, #VIDCList3_HorizDisplaySize]
        LDR     r1, [r6, #VIDCList3_PixelDepth]
        SUB     r1, r1, #3
        ADD     r7, r9, r0, LSL r1
        ; Round up to a 32 byte multiple
        ADD     r7, r7, #31
        BIC     r7, r7, #31
        ; It looks like the width also needs to be a multiple of 16 pixels
        MOV     r7, r7, LSR r1
        ADD     r7, r7, #15
        BIC     r7, r7, #15

; Vet framebuffer width/height against configured GPU limits
        LDR     r0, DisplayRotate
        TST     r0, #DisplayRotate_90 ; 90 / 270 degree rotation effectively swaps the two limits
        LDREQ   r0, MaxFBWidth
        LDREQ   r2, MaxFBHeight
        LDRNE   r0, MaxFBHeight
        LDRNE   r2, MaxFBWidth
        CMP     r7, r0, LSL #1 ; Virtual framebuffer width can't be more than twice max physical framebuffer size
        LDRLS   r1, [r6, #VIDCList3_HorizDisplaySize]
        CMPLS   r1, r0 ; Physical framebuffer width needs checking too
        LDRLS   r1, [r6, #VIDCList3_VertiDisplaySize]
        MOVLS   r1, r1, LSL r8
        CMPLS   r1, r2
        BHI     %FT999

 [ GPUMode
        BL      GPUMode_Vet
        CMP     r0, #0
        BNE     %FT999
 ]

        ; The VC 'test' calls seem to be broken and just return the current FB settings
        ; So don't bother doing a full vet sequence
 [ {FALSE}
        SUB     sp, sp, #vettagslen
        MOV     r3, sp
        
        adrl    r1, vettagb                  ; buffer source
        ldr     r2, [r1]                     ; length
111     subs    r2, r2, #4                   ; initialise the tagbugffer
        ldrge   r4, [r1, r2]
        strge   r4, [r3, r2]
        bgt     %bt111


        LDR     r0, [r6, #VIDCList3_PixelDepth]
 [ Debug
  bl DebugHexTX4
 ]
        CMP     r0, #4
        MOVLO   r0, #8
        MOVEQ   r0, #16
        MOVHI   r0, #32
        str     r0, [r3, #vdispbpp-vettagb]
 [ Debug
  bl DebugHexTX4
 ]
        LDR     r0, [r6, #VIDCList3_HorizDisplaySize]
 ;       str     r0, [r3, #vphyx-vettagb]
        str     r0, [r3, #vvirtx-vettagb]
 [ Debug
  bl DebugHexTX4
 ]
        LDR     r0, [r6, #VIDCList3_VertiDisplaySize]
        MOV     r0, r0, LSL r8
 ;       str     r0, [r3, #vphyy-vettagb]
        str     r0, [r3, #vvirty-vettagb]
 [ Debug
  bl DebugHexTX4
 ]
        mov     r0, sp
        mov     r1, sp
        mov     r2, #0
 [ Debug
  bl DebugHexTX4
 ]
        SWI     XBCMSupport_SendTempPropertyBuffer
 [ Debug
  bl DebugTXStrInline
  DCB "done FB.. vet response",10,13,0
  ALIGN
 ]
        ; For the moment only vet virtual dimensions & bpp
        ldr     r1, [r3,#vvirtx-vettagb]
        ldr     r2, [r3,#vvirty-vettagb]
        ldr     r4, [r3,#vdispbpp-vettagb]
 [ Debug
  mov   r0, r4
  bl DebugHexTX4
  mov   r0, r1
  bl DebugHexTX4
  mov   r0, r2
  bl DebugHexTX4
 ]
        LDR     r0, [r6, #VIDCList3_HorizDisplaySize]
        CMP     r0, r1
        LDREQ   r0, [r6, #VIDCList3_VertiDisplaySize]
        MOVEQ   r0, r0, LSL r8
        CMPEQ   r0, r2
        BNE     %FT998
        LDR     r0, [r6, #VIDCList3_PixelDepth]
        CMP     r0, #4
        MOVLT   r0, #8
        MOVEQ   r0, #16
        MOVGT   r0, #32
        CMP     r0, r4
        BNE     %FT998
        ADD     sp, sp, #vettagslen
 ] ; {FALSE}
 [ Debug
  bl DebugTXStrInline
  DCB "done vFB2",10,13,0
  ALIGN
 ]

; Mode is good - recalculate ExtraBytes from r7
        LDR     r0, [r6, #VIDCList3_HorizDisplaySize]
        LDR     r1, [r6, #VIDCList3_PixelDepth]
        SUB     r1, r1, #3
        SUB     r2, r7, r0
        MOV     r2, r2, LSL r1
        MOV     r0, #GVVetMode2_Result_UnkFramestore
        ; Set the flag for if we've changed ExtraBytes
        CMP     r2, r9
        ORRNE   r0, r0, #GVVetMode2_ExtraBytes_Invalid
        EXIT
998
        ADD     sp, sp, #vettagslen
999
 [ Debug
  bl DebugTXStrInline
  DCB "done vFB2 - mode vet fail",10,13,0
  ALIGN
 ]
        MOV     r0, #GVVetMode2_Result_Unsupported
        EXIT

; in: R1 = requested Vinit
SetVinit        ROUT
        Entry   "r0-r4"
        ; Calculate corresponding Y offset to use
        LDR     r0, mbbase
        SUB     r0, r1, r0
        LDR     r1, mbpitch
        DivRem  r2, r0, r1, lr
        ; Clamp
        CMP     r2, #0
        MOVLT   r2, #0
        LDR     r0, mbyvres
        LDR     r1, mbyres
        SUB     r0, r0, r1
        CMP     r2, r0
        MOVLE   r0, r2
        ; Same as current?
        LDR     r2, mbyoff
        CMP     r0, r2
        EXIT    EQ
      [ Debug
        DebugTime
        BL      DebugHexTX4
        BL      DebugTXStrInline
        DCB     "SetVinit yoff",10,13,0
        ALIGN
      ]
        ; Set flag requesting update
        STR     r0, mbyoff
        STR     pc, UpdateNeeded
        EXIT

; in: r1 = pointer to palette entries
;     r2 = base
;     r3 = count
; Palette updates seem to be quite slow, not helped by the fact that RISC OS likes to update them one at a time. To counter this, we buffer the updates and perform them at a later date (on the ARM timer half-VSync interrupt)
SetPalette      ROUT
        Entry   "r0-r4"
      [ Debug
        DebugTime
        BL      DebugTXStrInline
        DCB     "SetPalette",10,13,0
        ALIGN
      ]
        ; Copy over new data
        ADRL    r0, Palette
        ADD     r0, r0, r2, LSL #2
        MOV     lr, #0
10
        SUBS    r3, r3, #1
        LDRGE   r4, [r1], #4
        LDRGE   r2, [r0]
        MOVGE   r4, r4, LSR #8
        EORGE   r2, r2, r4
        STRGE   r4, [r0], #4
        ORRGE   lr, lr, r2
        BGT     %BT10
        ; Request merged message send if necessary
        TEQ     lr, #0
        STRNE   lr, UpdateNeeded
        EXIT

; in: r1 = pointer to gamma table entries
;     r2 = base
;     r3 = count
SetGamma        ROUT
        Entry   "r0-r6"
      [ Debug :LAND: {FALSE}
        DebugTime
        BL      DebugTXStrInline
        DCB     "SetGamma",10,13,0
        ALIGN
      ]
        LDR     r4, PeriBase
        ADD     r4, r4, #SCALER
        LDR     r5, GammaBase
        ADDS    r5, r5, r2
        EXIT    PL ; Top bit of GammaBase should be set if gamma enabled
        ; At the hardware level the red, green and blue gamma ramps are stored
        ; separately from each other, so we must write the data for each
        ; channel one at a time.
        PHPSEI
        ; Write red channel
        ADD     r1, r1, #1
        STR     r5, [r4, #SCALER_DISPGAMADR]
10
        SUBS    r3, r3, #1
        LDRGEB  r6, [r1], #4
        STRGE   r6, [r4, #SCALER_DISPGAMDAT]
        BGT     %BT10
        ; Write green channel
        FRAMLDR r1
        FRAMLDR r3
        ADD     r1, r1, #2
        ADD     r5, r5, #256
        STR     r5, [r4, #SCALER_DISPGAMADR]
20
        SUBS    r3, r3, #1
        LDRGEB  r6, [r1], #4
        STRGE   r6, [r4, #SCALER_DISPGAMDAT]
        BGT     %BT20
        ; Write blue channel
        FRAMLDR r1
        FRAMLDR r3
        ADD     r1, r1, #3
        ADD     r5, r5, #256
        STR     r5, [r4, #SCALER_DISPGAMADR]
30
        SUBS    r3, r3, #1
        LDRGEB  r6, [r1], #4
        STRGE   r6, [r4, #SCALER_DISPGAMDAT]
        BGT     %BT30
        DoMemBarrier r6
        PLP
        EXIT

; in: r1 = gamma base address
; Reset to a linear gamma ramp
ResetGamma      ROUT
        Entry   "r0-r2"
        LDR     r0, PeriBase
        ADD     r0, r0, #SCALER
        PHPSEI
        STR     r1, [r0, #SCALER_DISPGAMADR]
        MOV     r2, #3
10
        MOV     r1, #0
20
        STRB    r1, [r0, #SCALER_DISPGAMDAT]
        ADD     r1, r1, #1
        TST     r1, #255
        BNE     %BT20
        SUBS    r2, r2, #1
        BNE     %BT10
        DoMemBarrier r0
        PLP
        EXIT

VSync_Test      ROUT
        Entry   "r0-r4,r8-r9"
        ; Drop into SVC mode for SWI calls
        MRS     r4, CPSR
        ORR     r0, r4, #SVC32_mode
        MSR     CPSR_c, r0
        Push    "lr"
        ; Clear IRQ in SMI
        LDR     r0, PeriBase
        ADD     r0, r0, #SMICS
        DoMemBarrier lr
        MOV     r1, #0
        STR     r1, [r0]
        DoMemBarrier lr
        ; Clear IRQ in controller
        MOV     r0, #iDev_GPU_SMI
        MOV     r8, #0
        MOV     r9, #EntryNo_HAL_IRQClear
        SWI     XOS_Hardware
        ; Increase VSync count
        LDRB    r0, VSyncTestCount
        CMP     r0, #255
        ADDLT   r0, r0, #1
        STRLTB  r0, VSyncTestCount
        Pull    "lr"
        MSR     CPSR_c, r4
        EXIT

VSync_Handler
        Entry   "r0-r5,r8-r9"
        ; Drop into SVC mode for SWI calls
        MRS     r5, CPSR
        ORR     r0, r5, #SVC32_mode
        MSR     CPSR_c, r0
        Push    "lr"
      [ TimeDebug
        DebugTime
        BL      DebugTXStrInline
        DCB     "VSync {",10,13,0
        ALIGN
      ]
        LDR     r0, PeriBase
        ADD     r2, r0, #ARM_Timer_Base
        ADD     r0, r0, #SMICS
        LDR     r3, TimerVal
        LDRB    r4, TimerScale
        DoMemBarrier lr
        ; Clear IRQ in SMI
        MOV     r1, #0
        STR     r1, [r0]
        DoMemBarrier lr
        ; Program timer for the half-sync interrupt
        LDR     r1, [r2, #ARMTimer_Counter]
        SUB     r3, r1, r3
        MOV     r3, r3, LSR r4 ; Adjusts for both 10 bit vs. 8 bit prescaler values and divides by two
        STR     r3, [r2, #ARMTimer_Load]
        ; Enable timer + IRQ
        LDR     r4, [r2, #ARMTimer_Control]
        ORR     r0, r4, #ARMTimer_Control_Enable+ARMTimer_Control_IRQEnable
        STR     r0, [r2, #ARMTimer_Control]
        DoMemBarrier lr
        STR     r1, TimerVal
        ; Clear SMI IRQ in controller
        MOV     r0, #iDev_GPU_SMI
        MOV     r8, #0
        MOV     r9, #EntryNo_HAL_IRQClear
        SWI     XOS_Hardware
        ; If the ARM timer was programmed incorrectly and didn't fire last time
        ; (i.e. it started off enabled), send any pending message now. This
        ; should avoid us getting stuck never sending any messages if the timer
        ; freaks out.
        TST     r4, #ARMTimer_Control_IRQEnable
        LDRNE   lr, UpdateNeeded
        CMPNE   lr, #0
        BLNE    MergeUpdate
        ; Trigger VSync in OS
        LDRB    r4, GVinstance
        MOV     r9, #GraphicsV
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_VSync
        SWI     XOS_CallAVector
      [ TimeDebug
        DebugTime
        BL      DebugTXStrInline
        DCB     "} VSync",10,13,0
        ALIGN
      ]
        Pull    "lr"
        MSR     CPSR_c, r5
        EXIT

MergeUpdate ROUT
        Entry   "r0-r6"
        ; Try and claim tag buffer
        ; Give up if it's currently in use
        PHPSEI  r1
        LDR     r0, tagbuffer_busy
        CMP     r0, #0
        BNE     %FT90
        STR     r0, UpdateNeeded
        STR     pc, tagbuffer_busy
        PLP     r1
        ; Copy message prototype
        LDR     r0, tagbuffer
        ADRL    r4, mergetags
        MOV     r5, #mergepaldata-mergetags
        MOV     r1, r0
10
        LDR     r6, [r4], #4
        STR     r6, [r1], #4
        SUBS    r5, r5, #4
        BNE     %BT10
        ; Set up blank state message
        LDRB    r6, BlankState
        STR     r6, [r0, #mergeblank-mergetags]
        ; Set up Y offset message
        LDR     r6, mbyoff
        STR     r6, [r0, #mergevyoff-mergetags]
        ; Set up palette entries
        MOV     r4, #256
        ADRL    r2, Palette
20
        LDMIA   r2!,{r3,r5-r6,lr}
        SUBS    r4, r4, #4
        STMIA   r1!,{r3,r5-r6,lr}
        BNE     %BT20
        ; Write end tag
        MOV     r5, #ARM2VC_Tag_End
        STR     r5, [r1]
        ; Send
        ; Should perhaps be non-blocking? We can always try again later
        MOV     r1, #SendMBMessage_Async
        MOV     r2, #0 ; Callback R0
        MOV     r3, r12
        ADR     r4, MBCallback
        SWI     XBCMSupport_SendPropertyBuffer
        STRVS   r2, tagbuffer_busy
        EXIT

90
        PLP     r1
        EXIT

MBCallback ROUT
        ; Callback from BCMSupport when an async message is processed
        ; We just need to flag the buffer as free
        STR     r0, tagbuffer_busy ; We were entered with R0=0
        MOV     pc, lr

TickerV_Handler ROUT
        Entry   "r0-r2"
        ; Drop into SVC mode for SWI calls
        MRS     r2, CPSR
        ORR     r0, r2, #SVC32_mode
        MSR     CPSR_c, r0
        Push    "lr"
        ; Check time
        ; OS generates its fake VSync if the low bit of the centisecond timer
        ; is set. But we want to send our merged message about halfway through
        ; the frame, to try and ensure it reaches the GPU before the next (real)
        ; VSync.
        SWI     XOS_ReadMonotonicTime
        LDR     r1, UpdateNeeded
        EOR     r0, r0, #1
        TST     r0, #1
        CMPNE   r1, #0
        BLNE    MergeUpdate
        Pull    "lr"
        MSR     CPSR_c, r2
        EXIT

Timer_Handler ROUT
        Entry   "r0-r4,r8-r9"
        ; Drop into SVC mode for SWI calls
        MRS     r4, CPSR
        ORR     r0, r4, #SVC32_mode
        MSR     CPSR_c, r0
        Push    "lr"
      [ TimeDebug
        DebugTime
        BL      DebugTXStrInline
        DCB     "Timer {",10,13,0
        ALIGN
      ]
        ; Stop the timer, we only want it to fire once
        LDR     r0, PeriBase
        ADD     r0, r0, #ARM_Timer_Base
        DoMemBarrier lr
        LDR     r1, [r0, #ARMTimer_Control]
        BIC     r1, r1, #ARMTimer_Control_Enable+ARMTimer_Control_IRQEnable
        STR     r1, [r0, #ARMTimer_Control]
      [ TimerDebug
        LDR     r1, [r0, #ARMTimer_Counter]
        LDR     r2, [r0, #ARMTimer_Load]
      ]
        ; Clear the IRQ states
        STR     pc, [r0, #ARMTimer_IRQClear] ; Any value will do
        DoMemBarrier lr
      [ TimerDebug
        LDR     r0, TimerVal
        SUB     r0, r1, r0
        STR     r0, CounterDiff ; How much counter time passed
        STR     r2, TimerLoad ; How much timer time passed
      [ TimeDebug
        BL      DebugHexTX4
        MOV     r0, r2
        BL      DebugHexTX4
        BL      DebugTXStrInline
        DCB     "times",10,13,0
        ALIGN
      ]
      ]
        MOV     r0, #iDev_ARM_Timer
        MOV     r8, #0
        MOV     r9, #EntryNo_HAL_IRQClear
        SWI     XOS_Hardware
        ; Now handle any merged update
        LDR     r0, UpdateNeeded
        CMP     r0, #0
        BLNE    MergeUpdate
      [ TimeDebug
        DebugTime
        BL      DebugTXStrInline
        DCB     "} Timer",10,13,0
        ALIGN
      ]
        Pull    "lr"
        MSR     CPSR_c, r4
        EXIT

VCHIQInit ROUT
        Entry   "r0-r2"
        LDR     r0, VCHIQInstance
        CMP     r0, #0
        EXIT    NE                      ; Already initialised
        ; Register with VCHIQ
        MOV     r0, r12
        SWI     XVCHIQ_Initialise
        FRAMSTR r0, VS
        EXIT    VS
        ; Connect to the GPU
        MOV     r2, r0
        MOV     r1, #0
        MOV     r0, #0
        SWI     XVCHIQ_Connect
        STRVC   r2, VCHIQInstance
        EXIT    VC
        FRAMSTR r0
        ; Disconnect + deregister
        MOV     r0, r2
        SWI     XVCHIQ_Disconnect
        SETV
        EXIT

VCHIQFinalise ROUT
        Entry   "r0"
        LDR     r0, VCHIQInstance
        CMP     r0, #0                  ; Clears V
        EXIT    EQ
        ; Shutdown all dependencies
        BLVC    GVOverlay_Finalise
      [ HWPointer
        BLVC    HWP_Finalise
      ]
        BLVC    Dispmanx_Finalise
      [ GPUMode
        BLVC    GPUMode_Finalise
        BLVC    TVService_Finalise
      ]
      [ GenCmd
        BLVC    GenCmd_Finalise
      ]
        ; Now shutdown VCHIQ instance
        MOVVC   lr, #0
        STRVC   lr, VCHIQInstance
        SWIVC   XVCHIQ_Disconnect
        FRAMSTR r0, VS
        EXIT

WaitForR1        
        ; Wait for pollword at r1 to become nonzero
        ; Assumes interrupts can be enabled!
        Entry   "r0,r2-r3"
        MRS     r3, CPSR
05
        ORR     r2, r3, #I32_bit
        MSR     CPSR_c, r2
        LDR     r0, [r1]
        CMP     r0, #0
        BNE     %FT10
        ; Block on mutex, with IRQs enabled. IRQs must be enabled to avoid deadlock, as RTSupport doesn't have any IRQ-enabled "idle" thread to drop into when all others are blocked.
        BIC     r2, r3, #I32_bit
        MSR     CPSR_c, r2
        SWI     XRT_Yield
        BVS     %FT10 ; Error typically means we're in an IRQ (which shouldn't happen for us). But to avoid problems just go ahead and claim the mutex anyway.
        ADR     lr, %BT05
        LDR     pc, IRQTrigger        
10        
        MSR     CPSR_c, r3
        EXIT

; in:
; r0 -> input buffer
; r1 = input length
; r2 -> response buffer, NULL if no response expected
; r3 = response buffer length
; r4 = VCHIQ service handle
; r5 -> response pollword (ignored if no response needed)
; out:
; r0 = response length (zero if none requested)
VCHIQSend ROUT
        Entry   "r0-r3"
        MOV     r0, r4
        SWI     XVCHIQ_ServiceUse
        FRAMSTR r0,VS
        EXIT    VS
        CMP     r2, #0
        MOVNE   r0, #0
        STRNE   r0, [r5]
        MOV     r0, r4
        FRAMLDR r1,,r0
        FRAMLDR r2,,r1
        MOV     r3, #VCHI_FLAGS_BLOCK_UNTIL_QUEUED
        SWI     XVCHIQ_MsgQueue
        BVS     %FT80
        ; Wait for response
        FRAMLDR r2
        CMP     r2, #0
        FRAMSTR r2,EQ,r0
        BEQ     %FT70
10
        MOV     r1, r5
        BL      WaitForR1
        MOV     r0, r4
        MOV     r1, r2
        FRAMLDR r2,,r3
        MOV     r3, #0
        SWI     XVCHIQ_MsgDequeue
        FRAMSTR r2,,r0
        BVS     %FT80
70
        MOV     r0, r4
        SWI     XVCHIQ_ServiceRelease
        CLRV
        EXIT
80
        FRAMSTR r1,,r0
        MOV     r0, r4
        SWI     XVCHIQ_ServiceRelease
        SETV
        EXIT

; In: R6 -> option to check for in cmdline.txt
; Out: VS if option was found        
CheckCmdlineTxt ROUT
        Entry   "r0-r5"
        ; Build up a mailbox message
        MOV     r5, sp
        MOV     r4, #ARM2VC_Tag_End
        Push    "r4"                    ; End tag
cmdlinelen * 1024 ; The firmware will put a bunch of stuff on the command line by default, so be cautious with the length
        SUB     sp, sp, #cmdlinelen     ; String buffer
        LDR     r0, =ARM2VC_Tag_GetConfig
        MOV     r1, #cmdlinelen
        MOV     r2, #0
        Push    "r0-r2"                 ; Command line tag
        SUB     r0, r5, sp
        ADD     r0, r0, #8
        MOV     r1, #0
        Push    "r0-r1"                 ; Tag block header
        MOV     r0, sp
        MOV     r1, sp
        MOV     r2, #0
        SWI     XBCMSupport_SendTempPropertyBuffer
        BVS     %FT90
        ; Check success
        LDR     r0, [sp, #4]
        CMP     r0, #&80000000
        BNE     %FT90
        LDR     r0, [sp, #16]!
        TST     r0, #&80000000
        BEQ     %FT90
        BIC     r0, r0, #&80000000
        CMP     r0, #cmdlinelen
        MOVHI   r0, #cmdlinelen
        ADD     sp, sp, #4
        MOV     r1, #0
        STRB    r1, [sp, r0] ; Ensure null terminated, to simplify logic
        ; Scan the string
        MOV     r1, sp
05
        MOV     r14, #0
10
        LDRB    r3, [r1, r14]
        LDRB    r4, [r6, r14]
        CMP     r4, #0
        BNE     %FT20
        ; Require space or null at end
        CMP     r3, #0
        CMPNE   r3, #' '
        BNE     %FT30
        SETV
        MOV     sp, r5
        EXIT
20
        CMP     r3, r4
        ADDEQ   r14, r14, #1
        BEQ     %BT10
30
        ; No match. Scan forwards until we find a space.
        LDRB    r3, [r1], #1
        CMP     r3, #' '
        BEQ     %BT05
        CMP     r3, #0
        BNE     %BT30
90
        ; Failed to find the string, exit V clear
        CLRV
        MOV     sp, r5
        EXIT

        LTORG

resourcefsfiles
      [ BuiltinMDF
        ResourceFile    Resources.RPIMon, Resources.BCMVideo.RPIMon
      ]
        DCD     0                   ; terminator

pollword_1
        DCD     1

        GET     GraphicsV.s
        GET     GVOverlay.s
        GET     Debug.s
        GET     Dispmanx.s
      [ HWPointer
        GET     HWPointer.s
      ]
      [ GenCmd
        GET     GenCmd.s
      ]
      [ GPUMode
        GET     TVService.s
        GET     GPUMode.s
      ]
        END
@


1.40
log
@Avoid redundant GPU mode changes
Detail:
  s/BCMVideo - Reserve some workspace for storing the last hdmi_timings command
  s/GPUMode - Avoid changing the GPU mode if the last hdmi_timings we configured are identical to the new ones. Push hardware pointer shutdown to later in the mode change sequence as well, to avoid situations where that could be redundantly shut down.
Admin:
  Tested on Raspberry Pi 1


Version 0.50. Tagged as 'BCMVideo-0_50'
@
text
@d40 1
d71 41
a119 1
mbram            #       0           ; structure needed for frame buffer descriptor
d134 1
d156 3
d205 1
d207 1
a207 1
GammaBase        #       4 ; Base address of gamma table to use
d210 14
a232 1
HWPDispHandle    #       4 ; dispmanx display handle
a234 12
DispManServiceC  #       4 ; dispmanx client service
DispManServiceN  #       4 ; dispmanx notify service
DispManResponded #       4 ; Nonzero if message response received
HWPDisplayWidth  #       4 ; Actual display width
HWPDisplayHeight #       4 ; Height
HWPDisplayTrans  #       4 ; Transform
HWPDisplayFormat #       4 ; Format
HWPXScale        #       4 ; RISC OS pixel -> actual pixel scale
HWPYScale        #       4
HWPXOffset       #       4 ; X & Y offsets of RISC OS desktop in actual pixels
HWPYOffset       #       4
HWPYInvScale     #       4
d250 3
d267 4
d410 1
d509 2
d546 8
d562 1
d762 5
d808 1
a808 1
        DCD     1                  ; RGB
d813 1
a813 1
        DCD     2                  ; channel 1=alpha reversed 2=ignore
d915 1
a915 1
        Entry   "r0-r9", GPUMode_BufLen    ; Reserve space for vcgencmd buffer
d917 1
a917 1
        Entry   "r0-r9", tagslen
d948 2
d986 1
d996 2
d1000 1
d1020 12
d1112 2
a1113 4
 [ HWPointer
        ; Recache hardware pointer display values/try re-initialising (GPU mode
        ; change may have disabled it)
        LDR     r0, HWPActive
d1116 6
a1121 2
        BNE     HWP_CalcDisplayScaleOffset
        BEQ     HWP_Init
d1123 5
a1127 1
 ]
d1161 3
d1293 8
d1305 1
d1525 1
a1525 1
      [ Debug
d1535 1
a1535 1
        EXIT    PL
d1856 1
d1860 1
d1948 69
d2029 1
d2031 1
@


1.40.2.1
log
@Take out gamma enable
While investigations continue on the trunk, simply disable it for now.

Version 0.50, 1.50.2.1. Tagged as 'BCMVideo-0_50-1_50_2_1'
@
text
@a1053 1
      [ {FALSE} ; See https://github.com/raspberrypi/firmware/issues/971
a1054 1
      ]
@


1.39
log
@Implement gamma support for true-colour modes
Detail:
  hdr/BCM2835reg - Add some HVS / scaler register addresses. Remove unused FlushDataCache macros.
  s/BCMVideo - Add code for programming the HVS gamma table
  s/GraphicsV - Hook up gamma programming to GraphicsV palette handlers
Admin:
  Tested on Raspberry Pi 1 & 3, TV & HDMI output


Version 0.49. Tagged as 'BCMVideo-0_49'
@
text
@d198 6
a842 1
GPUMode_BufLen * 512
@


1.38
log
@Implement GraphicsV_VetMode2 and proper support for the ExtraBytes control list item
Detail:
  s/BCMVideo - Update SetModeFromVIDCList to support the ExtraBytes control list item. Update VetModeFromVIDCList so that it will suggest a new ExtraBytes value if the original wasn't satisfactory. Also, adjust padding logic - it looks like the framebuffer will always get padded out to a multiple of 16 pixels (not just for rotated framebuffers)
  s/GraphicsV - Make both GraphicsV_VetMode and GraphicsV_VetMode2 rely on VetModeFromVIDCList, but translate the results to the appropriate form.
Admin:
  Tested on Raspberry Pi 3
  720-width modes (amongst others) now work in 8bpp, and 360-width modes now work in <32bpp and are no longer garbled in 32bpp (width is only a multiple of 8 pixels)
  Requires HdrSrc-2_71 to build, ScreenModes-0_65 + Kernel-5_82 to reap the rewards


Version 0.47. Tagged as 'BCMVideo-0_47'
@
text
@d161 2
d1028 33
d1408 76
@


1.37
log
@Fix GPU mode changes with hdmi_group=1
Detail:
  s/GPUMode - If config.txt specifies hdmi_group=1, the custom mode created via hdmi_timings will be added as group 1 mode 65 instead of the usual group 2 mode 87. Make sure we use the appropriate settings when selecting the mode.
  s/BCMVideo, s/GenCmd - Add hdmi_group to the list of settings to read during startup
Admin:
  Tested on Raspberry Pi 1
  Fixes hang on boot when GPU mode changes are enabled and hdmi_group=1 is specified in config.txt


Version 0.45. Tagged as 'BCMVideo-0_45'
@
text
@d837 1
a837 1
        Entry   "r0-r8", GPUMode_BufLen    ; Reserve space for vcgencmd buffer
d839 1
a839 1
        Entry   "r0-r8", tagslen
d904 2
a905 1
        MOV     r8, #0
d913 2
d924 5
a928 1
        STR     r1, mbxvres
d930 1
a930 1
        str     r1, [r3, #virtx-tagb]
d1087 6
a1092 2
; r0 = mode or->VIDCList3
; r12-> workspace
d1094 1
a1094 1
        Push    "r1-r8,lr"
d1121 1
a1121 6
        ; The VC 'test' calls seem to be broken and just return the current FB settings
        ; So don't bother doing a full vet sequence
        ; However experimentation suggests that the VC rounds up the display pitch to a multiple of 32 bytes
        ; So as a simple vet, make sure no padding is being introduced, as RISC OS won't expect it
        ; TODO - Should also pay attention to ExtraBytes control list entry
        LDR     r0, [r6, #VIDCList3_HorizDisplaySize]
a1122 11
        MOV     r2, r0, LSL r1
        TST     r2, #(32*8)-1
        BNE     %FT999

        ; If the display is rotated 90 / 270 degrees, it looks like the width needs to be a multiple of 16 pixels
        TST     r0, #15
        LDRNE   r2, DisplayRotate
        TSTNE   r2, #DisplayRotate_90
        BNE     %FT999

        ; Vet the pixel depth
d1135 2
a1136 1
        MOV     r8,#0
d1142 3
a1144 5
        TEQ     r3,#ControlList_ExtraBytes ; TODO could use this to cope with 32 byte row pitch. For now just require that it's zero.
        BNE     %FT20
        CMP     r14,#0
        BNE     %FT999
        B       %BT10
d1171 13
d1191 3
a1193 2
        LDR     r1, [r6, #VIDCList3_HorizDisplaySize]
        CMP     r1, r0
d1205 3
a1207 1
 [ {FALSE} ; Full VC vet sequence below
d1289 11
a1299 3
        mov     r0, #0
; exit r0=0 if we like the mode, else untouched
        Pull    "r1-r8,pc"
d1308 2
a1309 2
        MOV     r0, r6                   ; recover original r0
        Pull    "r1-r8,pc"
@


1.36
log
@Allow GenCmd to be overridden from Makefile
Also, change GETs to Unix style 'thing.s' instead of 's.thing'.

Version 0.44. Tagged as 'BCMVideo-0_44'
@
text
@d145 1
@


1.35
log
@Fix compatibility with latest firmware, and revise calculation for number of screen banks to allocate
Detail:
  Some recent discussion on the Raspberry Pi forums has revealed the logic that the firmware uses to limit the virtual framebuffer size (and in turn, the number of screen banks we can allocate):
  https://www.raspberrypi.org/forums/viewtopic.php?f=28&t=5851&start=475#p1105321
  So rip out the dodgy logic that we were using previously and replace it with the same basic logic the GPU uses
  (With the addition of a max memory limit, for setups where GPU memory has been artificially limited in config.txt)
  s/BCMVideo - Update CalcScreenSize to use new logic, as discussed above
Admin:
  Tested on Raspberry Pi 1 + 3 with latest firmware
  Required for correct operation with Jan 28 2017 firmware and newer (old screen bank logic only worked due to a firmware bug which has now been fixed)


Version 0.43. Tagged as 'BCMVideo-0_43'
@
text
@d50 1
d53 1
d1715 2
a1716 2
        GET     s.GraphicsV
        GET     s.Debug
d1718 1
a1718 1
        GET     s.HWPointer
d1721 1
a1721 1
        GET     s.GenCmd
d1724 2
a1725 2
        GET     s.TVService
        GET     s.GPUMode
@


1.34
log
@Disable hardware pointer if the display is rotated
Detail:
  s/HWPointer - The GPU seems to struggle when dealing with a rotated hardware pointer, and there seem to be a couple of bugs for if we supply the pointer at the correct rotation, so make things easier and just fall back to a software pointer if there's any rotation going on.
  s/BCMVideo - Initialise VCGenCmd prior to the hardware pointer so HWP_Init can detect rotated displays
Admin:
  Tested on Raspberry Pi


Version 0.42. Tagged as 'BCMVideo-0_42'
@
text
@a67 7
ScreenSizeMax   *  8*1024*1024 ; How much we'll willingly allocate - to avoid using too much in low GPU memory setups
ScreenHeightMax *  4095        ; How tall we'll willingly make the screen. 4096 seems to be too much?
; ScreenBankMax   *  15          ; 16 seems to be too many. I suspect the 4095 limit is a red herring, and it's actually this limit I was hitting during initial testing, but let's keep the 4095 limit for now and see how things go.
;ScreenBankMax   *  7           ; 15 was too many for teletext. Admit defeat and go for 7.
ScreenBankMax    *  6           ; 7 was too many for 720x576x16bpp
ScreenBankMaxRotated * 3       ; 90 / 270 degree rotation has trouble in some cases, limit the number of banks further

d145 1
d444 22
d786 11
d1031 3
a1033 2
        ; Work out how many screen buffers we can fit before hitting memory limit
        ; This assumes there won't be any row padding inserted by the GPU when we allocate the buffer
d1035 2
a1036 1
        LDR     r3, =ScreenSizeMax*8 ; Size in bits, not bytes
d1039 13
a1051 2
        ; Work out how many screen buffers we can fit before hitting our max height limit
        LDR     r3, =ScreenHeightMax
a1058 7
        ; Make sure we don't allocate too many
        LDR     r3, DisplayRotate
        TST     r3, #DisplayRotate_90
        MOVEQ   r3, #ScreenBankMax
        MOVNE   r3, #ScreenBankMaxRotated
        CMP     r4, r3
        MOVGT   r4, r3
@


1.33
log
@Allow GPU mode change support to be disabled via the 'kernel' command line
Detail:
  s/GPUMode - If there's a 'disable_mode_changes' string in the command line provided by the firmware (i.e. cmdline.txt file), disable GPU mode changes
  s/BCMVideo - Fix to GPUMode {FALSE} rejecting all screen modes. Reduce max screen bank count again, after seeing an issue with 720x576x16bpp.
Admin:
  Tested on Raspberry Pi
  Should give Pi-Top users a solution for GPU mode changes breaking things:
  https://www.riscosopen.org/forum/forums/4/topics/6792


Version 0.41. Tagged as 'BCMVideo-0_41'
@
text
@d345 3
a350 3
      [ GenCmd
        BL       GenCmd_Init
      ]
d464 3
a469 3
      [ GenCmd
        BL      GenCmd_Init
      ]
@


1.32
log
@Add support for GPU mode changes, vcgencmd implementation, and fix some issues with rotated displays
Detail:
  With recent firmware (~Aug 10th and newer) it's possible to issue a hdmi_timings command via vcgencmd to define custom mode timings on the fly. Make use of this feature (if available) to allow the OS to feed mode timings to the GPU instead of relying on the GPU to scale the framebuffer to the mode that was selected at boot.
  As an off-shoot of this we also get a vcgencmd *-command that's roughly equivalent to the vcgencmd command that's available under Linux
  File changes:
  - Makefile, Resources/UK/CmdHelp - *vcgencmd help text
  - s/BCMVideo - Add a few option switches to control the new behaviour. Add some generic code for interacting with VCHIQ services. Fix some issues with rotated displays (mainly 90 / 270 degree rotation)
  - s/Debug - Fix debug routines corrupting some registers
  - s/GraphicsV - Disable GraphicsV_StartupMode implementation if the builtin MDF is disabled (-> GPU mode changes are enabled)
  - s/HWPointer - Update to use the generic VCHIQ service code from s/BCMVideo
  - s/GenCmd - vcgencmd implementation. On initialisation, use it to read some of the GPU state & limits.
  - s/TVService - basic TV service implementation; enough to read the GPU state and perform mode changes
  - s/GPUMode - GPU mode change handling.
Admin:
  Tested on Raspberry Pi 1, 2, 3 with old & new firmware


Version 0.40. Tagged as 'BCMVideo-0_40'
@
text
@d71 2
a72 1
ScreenBankMax   *  7           ; 15 was too many for teletext. Admit defeat and go for 7.
a439 1
      [ GPUMode
a448 1
      ]
@


1.31
log
@Explicitly release old framebuffer when changing mode
Detail:
  s/BCMVideo - Explicitly release the old framebuffer when changing mode. This appears to fix some issues relating to situations where the old framebuffer is reused, e.g. screen corruption caused by the stride not matching what the OS is expecting
Admin:
  Tested on Raspberry Pi 3
  Fixes problems reported on forums with screen corruption when changing directly to 1360 wide mode at boot (i.e. from 1920 wide mode):
  https://www.riscosopen.org/forum/forums/4/topics/6400


Version 0.39. Tagged as 'BCMVideo-0_39'
@
text
@d37 3
d50 9
d72 1
d131 32
d176 3
a178 4
VCHIQInstance    #       4
VCHIQServiceC    #       4 ; dispmanx client service
VCHIQServiceN    #       4 ; dispmanx notify service
VCHIQResponded   #       4 ; Nonzero if message response received
d194 2
d241 3
d245 1
d250 1
a250 1
        DCD     0 ; Messages
d253 1
d259 5
a265 1
      ]
d269 2
a270 1
      ]      
d273 1
a282 1
      [ HWPointer :LOR: AemulorSupport
a283 1
      ]
a292 1
      [ HWPointer :LOR: AemulorSupport
a293 1
      ]
a320 1
      [ HWPointer
d326 1
a326 6
        ; Fall through into HWPointer VCHIQ check
      |
08
        ; If no HWPointer, we were the only bit interested in ModulePostInit/ModulePostFinal
        EXIT
      ]
a328 1
    [ HWPointer
d342 3
d346 8
d357 1
a357 1
    ]
d362 3
d366 1
d374 1
d392 2
d439 12
d463 2
d467 7
a473 1
        CLRV
d483 1
a483 1

d486 1
d634 3
a636 3
      [ HWPointer
        BL      HWP_Finalise
      ]
d805 5
d811 1
d854 5
d981 2
a982 1
        ; Recache display values
d985 4
a988 1
        BLNE    HWP_CalcDisplayScaleOffset
d1021 6
a1026 2
        CMP     r4, #ScreenBankMax
        MOVGT   r4, #ScreenBankMax
d1077 1
a1077 1
        ; However exerimentation suggests that the VC rounds up the display pitch to a multiple of 32 bytes
d1082 8
a1089 2
        MOV     r0, r0, LSL r1
        TST     r0, #(32*8)-1
d1142 20
d1550 120
d1673 1
d1675 1
d1678 3
d1686 7
@


1.30
log
@Use BCMSupport for mailbox access
Detail:
  hdr/BCM2835reg - Remove mailbox definitions which are now exported by BCMSupport in its header
  s/BCMVideo, s/GraphicsV - Remove manual mailbox access and replace with equivalent calls to BCMSupport. Some tag buffer definitons moved in order to allow Entry macro to reference their size.
Admin:
  Tested on Raspberry Pi 1B, 2B, 3B
  Requires BCMSupport 0.03


Version 0.37. Tagged as 'BCMVideo-0_37'
@
text
@d587 7
d751 12
@


1.29
log
@Unblank screen on mode change
Detail:
  s/BCMVideo - Adjust the set of tags used on mode change to specify that the screen should unblank (RISC OS assumes this is the case, although current docs don't mention it)
Admin:
  Tested on Raspberry Pi


Version 0.35. Tagged as 'BCMVideo-0_35'
@
text
@d36 1
a63 1
tagbuffer_phy    #       4
d65 1
a65 3
tagbuffer_ofs    #       4 ; tagbuffer-tagbuffer_phy
tagbuffer_lastsent #     4 ; log addr of end of last buffer sent
tagbuffer_lastret  #     4 ; log addr of end of last buffer received
d104 1
a114 2
MBResponseMsg    #       4 ; Value which was sent which is awaiting a response, -1 if none
MBResponse       #       4 ; Where to copy response, if necessary
a164 36

        MACRO
        MBClaim $tags, $response
        ADRL    r0, $tags
        LDR     r0, [r0]
      [ "$response" <> ""
        SUB     sp, sp, r0 ; Reserve stack space for response
        ADD     lr, sp, r0 ; Get original SP in lr
      |
        MOV     lr, sp
      ]
        Push    "lr" ; Push original SP for recovery later
        PHPSEI
        Push    "r1,lr"
        ; Wait until enough space is available in the mailbox
      [ "$response" <> ""
        MOV     r1, r0
      |
        MOV     r1, #0
      ]
        BL      MBWait
        Pull    "r1"
        ; Make note of response buffer
      [ "$response" <> ""
        ADD     lr, sp, #8
        STR     lr, MBResponse
      ]
        MEND

        MACRO
        MBFinish
        Pull    "lr"
        PLP
        LDR     sp, [sp] ; Free any stack buffer
        MEND

a360 5
        STR     r0, tagbuffer_lastsent
        STR     r0, tagbuffer_lastret
        STR     r1, tagbuffer_phy
        SUB     r3, r0, r1
        STR     r3, tagbuffer_ofs
d373 1
a373 2
        MVN     r0, #0
        STR     r0, MBResponseMsg
d573 4
d587 123
d713 1
a713 1
        Push    "r0-r8,lr"
d720 1
a720 2
        MBClaim tagb, 1
        MOV     r3, r0
d789 3
a791 1
        mov     r0, r3
d795 2
a796 2
        bl      SendMBMessage
        MOV     r3, r0
a864 1
        MBFinish
a870 1

d876 1
a876 2

        Pull    "r0-r8,pc"
d1014 2
a1015 2
        MBClaim vettagb, 1
        MOV     r3, r0
d1050 3
a1052 1
        mov     r0, r3
d1056 1
a1056 1
        bl      SendMBMessage
d1087 1
a1087 1
        MBFinish
d1099 1
a1099 1
        MBFinish
a1170 231
SetBlankState   ROUT
        Entry   "r0-r4"
        AND     r3, r0, #1
        MBClaim blanktags
        adrl    r1, blanktags                ; buffer source
        ldr     r2, [r1]                     ; length
111     subs    r2, r2, #4                   ; initialise the tagbugffer
        ldrge   lr, [r1, r2]
        strge   lr, [r0, r2]
        bgt     %bt111
        STR     r3, [r0, #blankstate-blanktags]
        BL      SendMBMessage
        MBFinish
        EXIT

; in: r0 = Message buffer logical address. 16 byte aligned
;     r12 -> module workspace
;     must be nothing on stack between this and MBClaim!
; out: r0 = response buffer
SendMBMessage   ROUT
        Entry   "r0-r3"
      [ Debug
        DebugTime
        BL      DebugHexTX4
      ]
        LDR     r1, [r0]
        ADD     r1, r1, #15
        BIC     r1, r1, #15
        ADD     r1, r1, r0
        STR     r1, tagbuffer_lastsent
        LDR     r1, tagbuffer_ofs
        SUB     r0, r0, r1
        ldr     r3, MBResponse
        ADD     r0,r0, #MB_Chan_ARM2VC
      [ Debug
        BL      DebugHexTX4
        BL      DebugTXStrInline
        DCB     "SendMBMessage log msg",10,13,0
        ALIGN
      ] 
        DoMemBarrier r2
        LDR     r2, PeriBase
        ADD     r2, r2, #MB_Base
; check we can send a message
001     LDR     r1,[r2, #MB_Sta]
        TST     r1, #MB_Sta_Full
        BNE     %BT001                ; write channel full
; send message
        STR     r0,[r2, #MB_ChWr]
        DoMemBarrier r2
        ; does r3 point to our buffer? i.e. are we waiting for response?
        SUB     r2, r3, sp
        CMP     r2, #5*4+8            ; 5 regs from here plus 2 from MBClaim
        EXIT    NE
      [ Debug
        BL      DebugTXStrInline
        DCB     "SendMBMessage wait",10,13,0
        ALIGN
      ] 
        ; Flag that we're waiting for a response... and then wait for it!
        STR     r0, MBResponseMsg
        MOV     r0, #0
        MOV     r1, #1
        BL      MBWait
        STR     r3, [sp]
        EXIT

MBWait  ROUT
        ; In:
        ; r0 = required space
        ; r1 = nonzero if response needed
        ; Out:
        ; r0 = buffer ptr
        Entry   "r2-r6"
      [ Debug
        BL      DebugHexTX4
        Push    "r0"
        MOV     r0, r1
        BL      DebugHexTX4
        LDR     r0, MBResponseMsg
        BL      DebugHexTX4
        Pull    "r0"
        BL      DebugTXStrInline
        DCB     "MBWait req resp MBResponseMsg",10,13,0
        ALIGN
      ] 
        ADD     r2, r0, #15
        BIC     r2, r2, #15 ; Round up to 16 bytes
        LDR     r3, PeriBase
        ADD     r3, r3, #MB_Base
10
        ; Pull all immediately available responses
        DoMemBarrier lr
20
        LDR     r4,[r3, #MB_Sta]
        TST     r4, #MB_Sta_Empty
        BNE     %FT30                 ; mailbox empty
        LDR     r4,[r3,#MB_ChRd]
        and     lr,r4,#&f
        CMP     lr,#MB_Chan_ARM2VC    ; check it is our channel
        BNE     %BT20                 ; not our reply
        ; Get end of this message
        DoMemBarrier lr
        BIC     lr, r4, #&f
        LDR     r5, tagbuffer_ofs
        ADD     r0, lr, r5
      [ Debug
        BL      DebugHexTX4
        Push    "r0"
        MOV     r0, r4
        BL      DebugHexTX4
        Pull    "r0"
        BL      DebugTXStrInline
        DCB     "got log msg",10,13,0
        ALIGN
      ]         
        LDR     r6, [r0]
        ADD     lr, r0, r6
        STR     lr, tagbuffer_lastret
        ; Were we waiting for this response?
        LDR     r5, MBResponseMsg
        CMP     r4, r5
        BNE     %BT10
        ; Copy to response buffer
        LDR     r5, MBResponse
      [ Debug
        Push    "r0"
        MOV     r0, r6
        BL      DebugHexTX4
        MOV     r0, r5
        BL      DebugHexTX4
        Pull    "r0"        
        BL      DebugTXStrInline
        DCB     "got resp! len buf",10,13,0
        ALIGN
      ]         
25
        LDR     lr, [r0], #4
        STR     lr, [r5], #4
        SUBS    r6, r6, #4
        BNE     %BT25
        MVN     r0, #0
        STR     r0, MBResponse
        STR     r0, MBResponseMsg
        B       %BT10
30
        DoMemBarrier lr
        ; Ran out of messages to pull. Work out if we need to wait some more:
        ; Is the send channel full? (avoid nasty irq-disabled wait in SendMBMessage)
        TST     r4, #MB_Sta_Full
        BNE     %FT40
        ; Does this message require a response, but we're still waiting for a previous response?
        LDR     r0, MBResponseMsg
        CMP     r0, #-1
        CMPNE   r1, #0
        BNE     %FT40
        ; Do we have enough space for this message?
        ; if lastsent > lastret:
        ; - have free space from lastsent to tagbufferend
        ; - and from tagbuffer to lastret
        ; if lastsent == lastret
        ; - entire buffer free
        ; if lastsent < lastret:
        ; - have free space from lastsent to lastret
        LDR     r4, tagbuffer
        LDR     r5, tagbuffer_lastsent
        LDR     r6, tagbuffer_lastret
      [ Debug
        MOV     r0, r4
        BL      DebugHexTX4
        MOV     r0, r5
        BL      DebugHexTX4
        MOV     r0, r6
        BL      DebugHexTX4
        BL      DebugTXStrInline
        DCB     "tagbuffer lastsent lastret",10,13,0
        ALIGN
      ]         
        CMP     r5, r6
        BGT     %FT50
        BEQ     %FT60
        SUB     lr, r6, r5
        CMP     lr, r1
        BLE     %FT40
        ; We have enough space available at lastsent, plus some spare (to avoid lastret==lastsent condition)
35
        MOV     r0, r5
      [ Debug
        DebugTime
        BL      DebugHexTX4
        BL      DebugTXStrInline
        DCB     "MBWait done",10,13,0
        ALIGN
      ]
        EXIT
50
        ; Any space at the end of the buffer?
        ADD     lr, r4, #tagbuffer_size
        SUB     lr, lr, r5
        CMP     lr, r1
        BGE     %BT35
        ; Any space at the beginning of the buffer?
        SUB     lr, r6, r4
        CMP     lr, r1
        BGE     %FT65
40
        ; We need to wait some more
        ; Enable IRQs for a bit and then loop back round
        MRS     r0, CPSR
        BIC     lr, r0, #I32_bit
        MSR     CPSR_c, lr
        MOV     lr, pc
        LDR     pc, IRQTrigger
        MSR     CPSR_c, r0
        B       %BT10         
60
        ; Entire buffer is free
        ; Set lastsent == lastret == tagbuffer
        STR     r4, tagbuffer_lastsent
        STR     r4, tagbuffer_lastret
65
        MOV     r0, r4
      [ Debug
        DebugTime
        BL      DebugHexTX4
        BL      DebugTXStrInline
        DCB     "MBWait done",10,13,0
        ALIGN
      ]
        EXIT

d1264 6
a1269 1
        MOV     r0, #0
d1271 2
a1272 1
        MBClaim mergetags
d1274 1
d1283 3
d1300 8
a1307 2
        BL      SendMBMessage
        MBFinish
d1310 10
a1400 129
; series of VC side query tags.
;
; CURRENT ASSIGNED SPACE 256 bytes.. BEWARE
;
tagb    DCD     tagslen
        DCD     0
tagdisplphyswh
        DCD     ARM2VC_Tag_FBSetPhysDimension
        DCD     8
        DCD     8
phyx    DCD     1920
phyy    DCD     1080
tagdisplvirtwh
        DCD     ARM2VC_Tag_FBSetVirtDimension
        DCD     8
        DCD     8
virtx   DCD     1920
virty   DCD     1080
tagdisplvirtoffset
        DCD     ARM2VC_Tag_FBSetVirtOffset
        DCD     8
        DCD     8
vxoff   DCD     0
vyoff   DCD     0
tagdispldepth
        DCD     ARM2VC_Tag_FBSetDepth
        DCD     4
        DCD     4
dispbpp DCD     32                 ; 32bit
tagdisplpixord
        DCD     ARM2VC_Tag_FBSetPixelOrder
        DCD     4
        DCD     4
        DCD     1                  ; RGB
tagdisplalpha
        DCD     ARM2VC_Tag_FBSetAlphaMode
        DCD     4
        DCD     4
        DCD     2                  ; channel 1=alpha reversed 2=ignore
taggetpitch
        DCD     ARM2VC_Tag_FBGetPitch
        DCD     4
        DCD     0
dispit  DCD     0
tagdisplalloc
        DCD     ARM2VC_Tag_FBAlloc
        DCD     8
        DCD     8
dispbs  DCD     0x100000            ; megabyte aligned
dispsz  DCD     0
        DCD     ARM2VC_Tag_FBGetOverscan
        DCD     16
        DCD     0
dispovertop     DCD 0
dispoverbottom  DCD 0
dispoverleft    DCD 0
dispoverright   DCD 0        
        DCD     ARM2VC_Tag_FBBlank
        DCD     4
        DCD     4
        DCD     0                   ; Unblank screen on any mode change
        DCD     ARM2VC_Tag_End
tagslen *       . - tagb


vettagb DCD     vettagslen
        DCD     0
vtagdisplphyswh
        DCD     ARM2VC_Tag_FBTestPhysDimension
        DCD     8
        DCD     8
vphyx   DCD     1920
vphyy   DCD     1080
vtagdisplvirtwh
        DCD     ARM2VC_Tag_FBTestVirtDimension
        DCD     8
        DCD     8
vvirtx  DCD     1920
vvirty  DCD     1080
vtagdisplvirtoffset
        DCD     ARM2VC_Tag_FBTestVirtOffset
        DCD     8
        DCD     8
vvxoff  DCD     0
vvyoff  DCD     0
vtagdispldepth
        DCD     ARM2VC_Tag_FBTestDepth
        DCD     4
        DCD     4
vdispbpp DCD     32                 ; 32bit
        DCD     ARM2VC_Tag_End
vettagslen *       . - vettagb

blanktags  DCD  blanktagslen
           DCD  0
           DCD  ARM2VC_Tag_FBBlank
           DCD  4
           DCD  4
blankstate DCD  0
           DCD  ARM2VC_Tag_End
blanktagslen    * . - blanktags

edidtagb   DCD    edidtagslen
           DCD    0
           DCD    ARM2VC_Tag_GetEDID
           DCD    136
           DCD    4
edidblock  DCD    0
edidstatus DCD    0
edidbuffer %      128
           DCD    ARM2VC_Tag_End
edidtagslen *     . - edidtagb

mergetags      DCD   mergetagslen+256*4+4 ; total size
               DCD   0
               DCD   ARM2VC_Tag_FBSetVirtOffset
               DCD   8
               DCD   8
mergevxoff     DCD   0
mergevyoff     DCD   0
               DCD   ARM2VC_Tag_FBSetPalette
               DCD   8+256*4
               DCD   8+256*4
               DCD   0 ; first palette entry
               DCD   256 ; entry count
mergepaldata
               ; ... entries here ...
mergetagslen   *     . - mergetags

@


1.28
log
@Don't map in VC memory
Detail:
  s/BCMVideo - Now that the kernel handles the software pointer for us, there's no need for us to manually map in any of the VC's memory
Admin:
  Tested on Raspberry Pi


Version 0.34. Tagged as 'BCMVideo-0_34'
@
text
@d1581 4
@


1.27
log
@Fix black display on recent firmware
Detail:
  s/BCMVideo - Apparently the long-standing behaviour of the mailbox property interface returning an ARM physical address for the framebuffer is a bug (https://github.com/raspberrypi/linux/pull/1026#issuecomment-114263464), and so recent firmwares have been changed to return a GPU address instead. We want an ARM address, so detect what type we're given and offset appropriately.
Admin:
  Tested on Raspberry Pi 1 & 2, on old (February) and new (today) firmware


Version 0.32. Tagged as 'BCMVideo-0_32'
@
text
@a90 4
VC_Base          #       4 ; physical base of VC mem
VC_Size          #       4
VC_Log           #       4 ; logical base of VC mem

a428 36
        MBClaim vcmemtags, 1
        Push    "r0"
        ADRL    r1, vcmemtags
        MOV     r2, #vcmemtagslen
02
        LDR     r3, [r1], #4
        STR     r3, [r0], #4
        SUBS    r2, r2, #4
        BGT     %BT02
        Pull    "r0"
        BL      SendMBMessage
        LDR     r1, [r0, #VCbs-vcmemtags]
        LDR     r2, [r0, #VCsz-vcmemtags]

        MBFinish
        
        ; Map in all of VC memory
        ; HAL should have already done it, but we need to do it again to get its log addr, for easy pointer updates
        STR     r1, VC_Base
        STR     r2, VC_Size
        MOV     r0, #13
        SWI     XOS_Memory
        BVS     ExitInitModule
        STR     r3, VC_Log
      [ Debug
  MOV r0, r1
  BL  DebugHexTX4
  MOV r0, r2
  BL  DebugHexTX4
  MOV r0, r3
  BL  DebugHexTX4
  bl DebugTXStrInline
  DCB "VC mem",10,13,0
  ALIGN
      ]

a1612 12

vcmemtags DCD   vcmemtagslen
          DCD   0
tagvcmem
        DCD     ARM2VC_Tag_GetVCMemory
        DCD     8
        DCD     0
VCbs    DCD     0
VCsz    DCD     0
        DCD     ARM2VC_Tag_End
vcmemtagslen *  . - vcmemtags

@


1.26
log
@Remove manual software pointer support. Fix hardware pointer vanishing at X >= 2048 by falling back to kernel software pointer.
Detail:
  s/BCMVideo, s/SWPointer, s/GraphicsV - Remove manual software pointer code. Update GraphicsV code to deal with indicating when kernel software pointer is/isn't needed.
  s/HWPointer - Turn off hardware pointer and return with GraphicsV_UpdatePointer unclaimed if the pointer GPU X coord is >= 2048
Admin:
  Tested on Raspberry Pi
  Fixes pointer vanishing at X >= 2048


Version 0.31. Tagged as 'BCMVideo-0_31'
@
text
@d773 11
@


1.25
log
@  Add Raspberry Pi 2 support
Detail:
  BCMVideo isn't a good citizen in the sense that it has hard-coded knowledge
  of the physical address space rather than asking the HAL, so equivalent
  checks for wether we're running on a Pi 1 or Pi 2 were needed here. There
  was also a significant bug in that BCMVideo wasn't translating ARM physical
  addresses to GPU physical addresses before programming the DMA controller.
  It seems we "got away with it" on Pi 1 at the expense of hammering the
  GPU's L1 cache, but with the different attachment of L2 caches on Pi 2
  due to the presence of the Cortex-A7 CPU, there were major cache coherency
  problems leading to failure to do tiled plots or block-moves.
Admin:
  Tested on Pi 1 and 2.

Version 0.30. Tagged as 'BCMVideo-0_30'
@
text
@a42 3
          GBLL  SWPointer ; Software pointer
SWPointer SETL  {FALSE}

a155 5
 [ SWPointer
SWPAddr          #       4 ; where to restore cursor image, or 0 for none, or 1 to disable pointer updates
SWPHeight        #       4
SWPUnder         #       32*4*32
 ]
a339 9
      [ SWPointer
        BVS      %FT80
        ; Hardware pointer now enabled, remove & disable software pointer
        LDR      r0, SWPAddr
        CMP      r0, #1
        BLHI     SWP_remove
        MOV      r0, #1
        STR      r0, SWPAddr
      ]
a372 3
      [ SWPointer
        STR     r0, SWPAddr
      ]
a684 4
   [ SWPointer
        ; Block pointer updates
        STR     r0, SWPAddr
   ]
a810 5
 [ SWPointer
        ; Allow pointer updates
        MOV     r0, #0
        STR     r0, SWPAddr
 ]
a1697 3
      [ SWPointer
        GET     s.SWPointer
      ]
@


1.24
log
@Prepare for new Aemulor version
Detail:
  s/BCMVideo, s/GraphicsV - Adjust the AemulorSupport code so that it only activates the compatibility hacks if it detects a version of Aemulor <= 2.34; the plan is for the next released version to contain proper support for the new GraphicsV calls
Admin:
  Tested on Raspberry Pi


Version 0.29. Tagged as 'BCMVideo-0_29'
@
text
@d115 2
a116 1
DMA_CB_phy       #       4 ; Physical addr of DMA control block
d399 6
d406 2
a407 1
        LDR     r1, =IO_Base              ; to get the register address
@


1.23
log
@Add GraphicsV_ReadInfo implementation
Detail:
  s/GraphicsV - Added GraphicsV_ReadInfo implementation.
  s/BCMVideo - Keep a pointer to the HAL device so that its name can be returned for GVReadInfo_HardwareName
Admin:
  Tested on Raspberry Pi


Version 0.28. Tagged as 'BCMVideo-0_28'
@
text
@d109 5
a113 2
TimerScale       #       1 ; Shift factor to convert counter value to timer value, plus one
                 #       2
d261 4
d271 1
d276 1
a276 1
      [ HWPointer
d279 3
d288 1
a288 1
      [ HWPointer
d291 3
d297 35
d361 1
a361 1
        adr      r0, loadmodefilecommand
@


1.22
log
@Handle interlace control list item
Detail:
  s/BCMVideo - Update mode set & vet to take into account the interlace control list item. When interlace is specified we must make sure to double VertiDisplaySize to get the required framebuffer height.
Admin:
  Tested on Raspberry Pi


Version 0.27. Tagged as 'BCMVideo-0_27'
@
text
@d122 1
d468 1
@


1.21
log
@Add missing memory barrier
Detail:
  s/BCMVideo - Update VSync_Test to perform a memory barrier before the first (and only) write to the SMI
Admin:
  Tested on Raspberry Pi


Version 0.25. Tagged as 'BCMVideo-0_25'
@
text
@d632 1
a632 1
        Push    "r0-r7,lr"
d683 12
d697 1
d795 1
a795 1
        Pull    "r0-r7,pc"
d844 1
a844 1
        Push    "r1-r7,lr"
d895 1
d914 1
a914 1
        BNE     %BT10
d923 7
d963 1
d994 1
d1014 1
a1014 1
        Pull    "r1-r7,pc"
d1024 1
a1024 1
        Pull    "r1-r7,pc"
@


1.20
log
@A tab too many
*HELP Modules didn't line up.

Version 0.24. Tagged as 'BCMVideo-0_24'
@
text
@d1346 1
@


1.19
log
@Remove CMOS check code from GraphicsV_StartupMode
Detail:
  s/BCMVideo, s/GraphicsV - Remove CMOS configured mode check code from GraphicsV_StartupMode. Kernel-5_35-4_79_2_220 now does this check for us.
Admin:
  Tested on Raspberry Pi


Version 0.23. Tagged as 'BCMVideo-0_23'
@
text
@d250 1
a250 1
Help    =       Module_ComponentName, 9, 9, Module_HelpVersion, 0
@


1.18
log
@Only override startup mode if configured mode is set to 'auto'
Detail:
  s/GraphicsV - Only override the startup mode if the CMOS configured mode is 'auto', to allow custom modes set in CMOS to be used
  s/BCMVideo - Remove unnecessary hardware mode change on startup
Admin:
  Tested on Raspberry Pi


Version 0.22. Tagged as 'BCMVideo-0_22'
@
text
@a35 2
        GET     OsBytes
        GET     CMOS
@


1.17
log
@Improve screen bank and palette handling
Detail:
  This change removes support for the BCMVideo$ScreenBanksEnabled system variable and replaces it with a new, single scheme for handling screen banks and palette updates
  Under the new scheme, screen bank and palette changes are deferred until somewhere halfway through the frame, at which point a single message sequence is sent to the GPU to update both the screen bank/display offset and the palette.
  Merging the screen bank and palette updates into one message sequence avoids the GPU taking two frames to process them (as it seems it has a habit of processing only one message sequence per frame), and sending the messages halfway through the frame ensures they're acted on before the start of the next frame (sending them when we receive a VSync interrupt is too late).
  The ARM timer is used to generate the interrupt that occurs halfway through the frame; this leaves HAL timer 1 free for other code. The required timer countdown value is recalculated each frame, so it should be mostly immune to any problems caused by the source clock frequency changing.
  File changes:
  - hdr/BCM2835reg - Added definitions for the ARM timer registers
  - s/BCMVideo - Remove ScreenBanksEnabled code. Disable the software pointer, as we're now guaranteed to have VCHIQ in ROM. Implement new screen bank & palette update code.
Admin:
  Tested on Raspberry Pi
  Test program shows palette updates are now in sync with screen bank changes, and if code follows the standard "wait for VSync, flip buffers" approach then there's only 1 frame of lag with no blocking, unlike the old code which could block and cut the system to half framerate or have 2+ frames of lag.


Version 0.19. Tagged as 'BCMVideo-0_19'
@
text
@d36 2
a316 22
; must specify interlace, as otherwise the kernel will attempt
; to write this.. it may not be in writable space
modedefv3
        DCD  3          ; type 3 list
        DCD  5          ; bpp
        DCD  0          ; h sync
        DCD  0          ; h back porch
        DCD  0          ; h left border
        DCD  1920       ; h pixels
        DCD  0          ; h right border
        DCD  0          ; h front porch
        DCD  0          ; v sync
        DCD  0          ; v back porch
        DCD  0          ; v left border
        DCD  1080       ; v pixels
        DCD  0          ; v right border
        DCD  0          ; v front porch
        DCD  0          ; pixel rate
        DCD  4          ; sync flags interlace speccd .. no interlace
        DCD  -1         ; list end
        DCD  -1         ; list end
modedefv3size     * .-modedefv3
a451 3
        adr     r0, modedefv3
        bl      SetModeFromVIDCList

@


1.16
log
@Fix potential for stack imbalance in palette set code
Detail:
  s/BCMVideo - Fix SetPalette to use BL to call PaletteTicker instead of B should the OS_CallAfter fail
Admin:
  Issue spotted by Jonathan Abbott


Version 0.18. Tagged as 'BCMVideo-0_18'
@
text
@d44 1
a44 1
SWPointer SETL  {TRUE}
d52 6
d98 7
a104 1
PaletteDirty     #       4 ; whether 8bpp palette dirty; also indicates whether ticker event is pending
d109 2
a110 1
                 #       3
a117 4
ScreenBanksEnabled #     4 ; Cached BCMVideo$ScreenBanksEnabled value:
                           ; ASCII 0 = disabled
                           ; ASCII 2 = enabled, don't wait for bank switch
                           ; any other value = enabled, wait for bank switch
d211 16
d305 1
a306 1
      ]
d525 43
d576 2
d579 14
d623 6
a628 3
        ADRL    r0, PaletteTicker
        MOV     r1, r12
        SWI     XOS_RemoveTickerEvent
d639 4
a834 2
        ; Check if screen banks are enabled
        BL      CheckScreenBanksEnabled
a852 33
; In:
; r4 = number of screen banks
; Out:
; r4 = 1 if screen banks disabled
CheckScreenBanksEnabled ROUT
        Entry   "r0-r4"
        ADR     r0, screenbankvarname
        ADR     r1, ScreenBanksEnabled
        ASSERT  ?ScreenBanksEnabled > 1
        MOV     r2, #?ScreenBanksEnabled
        MOV     r3, #0
        STR     r3, ScreenBanksEnabled ; Zap contents, OS_ReadVarVal doesn't place a terminator
        MOV     r4, #3
        SWI     XOS_ReadVarVal
        STRVS   pc, ScreenBanksEnabled ; Any value != '2' will do
        BVS     %FT10
        CMP     r2, #0
        BEQ     %FT10
        LDR     r2, ScreenBanksEnabled
        CMP     r2, #'0' ; 0 to disable, anything else to enable
        BEQ     %FT20
10
        CLRV
        EXIT
20
        PullEnv
        MOV     r4, #1
        MOV     pc, lr

screenbankvarname
        = "BCMVideo$ScreenBanksEnabled", 0
        ALIGN        

d1049 1
d1055 3
a1057 46
        ; Drop into SVC mode (Kernel calls us from IRQ for teletext!)
        MRS     r4, CPSR
        ORR     r3, r4, #SVC32_mode
        MSR     CPSR_c, r3
        Push    "r4, lr"
        MOV     r2, r0
      [ {TRUE}
        ; Check if we should wait for the GPU or not
        LDR     lr, ScreenBanksEnabled
        CMP     lr, #'2'
        ; If we were called from IRQ mode, use that as an indicator that we should skip the wait too (since we're likely to be inside the vsync IRQ handler, and don't really want to hold it up for an entire frame)
        ANDNE   r4, r4, #M32_bits
        TEQNE   r4, #IRQ32_mode
        BEQ     %FT10
        ; Wait
        ; We'll do this by claiming we want a result
        MBClaim offtagb, 1
        B       %FT20
10
        ; Don't wait
        MBClaim offtagb
20
      |
        MBClaim offtagb
      ]
        MOV     r3, r0
        ; Change to new offset
        adrl    r1, offtagb                  ; buffer source
        ldr     r0, [r1]                     ; length
111     subs    r0, r0, #4                   ; initialise the tagbugffer
        ldrge   lr, [r1, r0]
        strge   lr, [r3, r0]
        bgt     %bt111
        STR     r2, [r3, #offvyoff-offtagb]
        STR     r2, mbyoff
        MOV     r0, r3
        bl      SendMBMessage
        MBFinish
      [ Debug
        BL      DebugTXStrInline
        DCB     "SetVinit done",10,13,0
        ALIGN
      ]
80
        Pull    "r4, lr"
        MSR     CPSR_c, r4
d1063 1
a1063 1
; Palette updates seem to be quite slow, not helped by the fact that RISC OS likes to update them one at a time. To counter this, we buffer the updates and perform them on the next tick.
d1066 6
d1075 1
d1079 3
d1083 1
d1085 3
a1087 78
        ; Register ticker event
        PHPSEI
        LDR     r0, PaletteDirty
        MOV     r1, #1
        STR     r1, PaletteDirty
        PLP
        CMP     r0, #0
        EXIT    NE
        MOV     r0, #1
        ADR     r1, PaletteTicker
        MOV     r2, r12
        SWI     XOS_CallAfter
        ; If call failed, just do it immediately
        BLVS    PaletteTicker
        EXIT

PaletteTicker  ROUT
        Entry   "r0-r6"
        ; Drop into SVC mode so we can safely enable IRQs in SendMBMessage
        MRS     r6, CPSR
        ORR     r5, r6, #SVC32_mode
        MSR     CPSR_c, r5
        Push    "r6, lr"
        ; Update VC palette from our softcopy
        ; r1-r3 same params as SetPalette
        ADRL    r1, Palette
        MOV     r2, #0
        MOV     r3, #256
        ; Set up message buffer
        ADRL    r4, paltags
        MOV     r5, #paltagsdata-paltags
      [ Debug
        BL      DebugTXStrInline
        DCB     "PaletteTicker",10,13,0
        ALIGN
      ] 
        MBClaim paltags2
        Push    "r0"
10
        LDR     r6, [r4], #4
        STR     r6, [r0], #4
        SUBS    r5, r5, #4
        BNE     %BT10
        ; write entries
        MOV     r4, r3
20
        LDR     r5, [r1], #4
        MOV     r5, r5, LSR #8
        STR     r5, [r0], #4
        SUBS    r4, r4, #1
        BNE     %BT20
        ; Write end tag
        MOV     r5, #ARM2VC_Tag_End
        STR     r5, [r0]
        ; Fix up other fields
        Pull    "r0"
        LDR     r1, [r0]
        ADD     r1, r1, r3, LSL #2
        STR     r1, [r0]
        LDR     r1, [r0, #paltagsvbsize-paltags]
        ADD     r1, r1, r3, LSL #2
        STR     r1, [r0, #paltagsvbsize-paltags]
        LDR     r1, [r0, #paltagsvlsize-paltags]
        ADD     r1, r1, r3, LSL #2
        STR     r1, [r0, #paltagsvlsize-paltags]
        STR     r2, [r0, #paltagsfirst-paltags]
        STR     r3, [r0, #paltagscount-paltags]
        bl      SendMBMessage
        MOV     r0, #0
        STR     r0, PaletteDirty
        MBFinish
      [ Debug
        BL      DebugTXStrInline
        DCB     "PaletteTicker done",10,13,0
        ALIGN
      ] 
        Pull    "r6, lr"
        MSR     CPSR_c, r6
d1112 1
d1278 1
d1313 1
d1331 1
d1334 1
d1350 1
a1350 1
        Entry   "r0-r4,r8-r9"
d1352 2
a1353 2
        MRS     r4, CPSR
        ORR     r0, r4, #SVC32_mode
d1356 6
a1361 1
        ; Clear IRQ in SMI
d1363 1
d1365 4
d1371 12
a1382 1
        ; Clear IRQ in controller
d1387 8
a1395 1
        MOV     r3, r4
d1401 60
d1462 60
a1521 1
        MSR     CPSR_c, r3
a1624 14
paltags       DCD    paltagslen ; total size
              DCD    0
              DCD    ARM2VC_Tag_FBSetPalette
paltagsvbsize DCD    8 ; value buffer size
paltagsvlsize DCD    8 ; value length
paltagsfirst  DCD    0 ; first pal entry
paltagscount  DCD    0 ; entry count
paltagsdata
              ; ... entries here ...
              DCD    ARM2VC_Tag_End ; dummy end tag
paltagslen    *      . - paltags

paltags2      DCD    paltagslen+256*4

a1633 10
offtagb  DCD    offtagslen
         DCD    0
         DCD    ARM2VC_Tag_FBSetVirtOffset
         DCD    8
         DCD    8
offvxoff DCD    0
offvyoff DCD    0
         DCD    ARM2VC_Tag_End
offtagslen  *   . - offtagb

d1645 16
@


1.15
log
@Misc fixes
Detail:
  s/BCMVideo - Fix bad pointer being passed to SetModeFromVIDCList on startup, potentially causing a hang on startup. Add extra LTORG needed when debugging enabled, and strip some useless debug output.
  s/HWPointer - Fix potential crash when shutting down hardware pointer due to pointer being passed in wrong register
Admin:
  Tested on Raspberry Pi


Version 0.17. Tagged as 'BCMVideo-0_17'
@
text
@d1073 1
a1073 1
        BVS     PaletteTicker
@


1.14
log
@Add support for GraphicsV_IICOp (EDID reading only)
Detail:
  hdr/BCM2835reg, s/BCMVideo - Add definition for the EDID read messagebox tag
  s/GraphicsV - Add an implementation of GraphicsV_IICOp which uses the message box interface to request EDID blocks from the GPU as required
Admin:
  Tested on Raspberry Pi


Version 0.16. Tagged as 'BCMVideo-0_16'
@
text
@d447 1
a447 1
        adr     r1, modedefv3
d561 2
a662 4
  mov r0,r6
  bl DebugHexTX4
  mov r0,r7
  bl DebugHexTX4
@


1.13
log
@Add compatibility code for Aemulor's low colour mode emulation
Detail:
  s/BCMVideo, s/GraphicsV - Add a compatibility hack to detect if Aemulor is intercepting our GraphicsV calls, and if so, include 1-4bpp in the list of pixel formats we claim we support. This is enough to get the low colour mode emulation of existing Aemulor versions working again with the recent GraphicsV changes. The code can easily be disabled in the future once it's no longer needed.
Admin:
  Tested on Raspberry Pi with and without Aemulor Pro 2.34 loaded
  Some issues with mode changes still remain - e.g. switching to 1920x1080x8bpp then back to 1920x1080x32bpp causes screen to be offset and wrapped. Other mode change problems have also been observed without Aemulor loaded - to be investigated.


Version 0.15. Tagged as 'BCMVideo-0_15'
@
text
@d1558 11
@


1.12
log
@Update to use new GraphicsV registration process. Add 64K colour mode support.
Detail:
  s/BCMVideo - Remove unnecessary 'modedefbuf' in workspace. Use new GraphicsV driver registration process. Remove local defintion of VIDC list structure, use Hdr:VIDCList instead. Improve mode vetting to check list type, pixel format, and ExtraBytes control list entry.
  s/GraphicsV - Only respond to our driver number. Implement StartupMode call (previously in HAL). Implement PixelFormats call so that we can advertise support for 64K colour modes.
  s/SWPointer - Update 16bpp software pointer handling to assume 64K instead of 32K mode
Admin:
  Tested in BCM2835 ROM
  Requires HdrSrc-2_38 and Kernel-5_35-4_79_2_203


Version 0.14. Tagged as 'BCMVideo-0_14'
@
text
@d49 3
@


1.11
log
@Rewrite message box handling to allow multiple messages to be outstanding
Detail:
  s/BCMVideo - Rewritten message box handling. The buffer in which the messages are stored is now treated as a circular buffer, allowing multiple messages to be outstanding and awaiting processing by the GPU. This means the system only needs to block waiting for a response if the sender requires a response or the buffer becomes full. In practice, this means that setting BCMVideo$ScreenBanksEnabled to 2 to disable waiting for Vinit changes will allow software to use multiple screen banks and palette updates without any blocking occuring (assuming the software doesn't generate so many messages that the buffer overflows)
  s/Debug, s/BCMVideo - Added option for debug code to use DADebug instead of HAL_DebugTX
Admin:
  Tested on Raspberry Pi


Version 0.13. Tagged as 'BCMVideo-0_13'
@
text
@d34 2
d93 2
a147 2
modedefbuf       #       256

d433 8
a443 1
        adrl    r3, modedefbuf
a444 6
11      ldr     r0, [r1] , #4
        str     r0, [r3] , #4
        cmn     r0, #1
        bne     %bt11

        adrl    r0, modedefbuf
d513 3
a515 5
        ; Do a "MODE MODE" to allow VDU output to start working
        MOVVC   R0, #1
        SWIVC   XOS_ScreenMode
        MOVVC   R0, #0
        SWIVC   XOS_ScreenMode
d528 5
d552 3
d558 1
a558 52
;
; format of a VIDC list type 3
;
                                ^       4
VIDCList3_PixelDepth            #       4
VIDCList3_HorizSyncWidth        #       4
VIDCList3_HorizBackPorch        #       4
VIDCList3_HorizLeftBorder       #       4
VIDCList3_HorizDisplaySize      #       4
VIDCList3_HorizRightBorder      #       4
VIDCList3_HorizFrontPorch       #       4
VIDCList3_VertiSyncWidth        #       4
VIDCList3_VertiBackPorch        #       4
VIDCList3_VertiTopBorder        #       4
VIDCList3_VertiDisplaySize      #       4
VIDCList3_VertiBottomBorder     #       4
VIDCList3_VertiFrontPorch       #       4
VIDCList3_PixelRate             #       4
VIDCList3_SyncPol               #       4  ; sync polarity/flag bits
VIDCList3_ControlList           #       0  ; possibly empty list of pairs of
                                           ; index,value words
;
; and VIDCList3 is terminated by a -1 word
;
; Indices in VIDCList3_ControlList
;
                                ^       1
ControlList_LCDMode             #       1
ControlList_LCDDualPanelMode    #       1
ControlList_LCDOffset0          #       1
ControlList_LCDOffset1          #       1
ControlList_HiResMode           #       1
ControlList_DACControl          #       1
ControlList_RGBPedestals        #       1
ControlList_ExternalRegister    #       1
ControlList_HClockSelect        #       1
ControlList_RClockFrequency     #       1
ControlList_DPMSState           #       1
ControlList_Interlaced          #       1
ControlList_OutputFormat        #       1
ControlList_ExtraBytes          #       1
ControlList_InvalidReason       #       0

; bits/flags in VIDCList3_SyncPol word:
;
SyncPol_InvertHSync        *  1
SyncPol_InvertVSync        *  2
SyncPol_InterlaceSpecified *  4   ; if set, interlace bit has been specified, else filled in by kernel
SyncPol_Interlace          *  8   ; set=interlaced, either specified by service call claimant or filled in from *TV by kernel


; r0->VIDCList3   (writable!!)
d579 2
d582 3
a584 6
        adrl    r7,modedefbuf
11      ldr     r0, [r5] , #4
        str     r0, [r7] , #4
 [ Debug
  bl DebugHexTX4
 ]
d586 9
a594 6
        bne     %bt11

 [ Debug
  bl DebugTXStrInline
  DCB 10,13,"modedefbuf printed",10,13,0
  ALIGN
a603 24
;; now check the control_list
;        ADD     r3, r0, #VIDCList3_ControlList
;2       LDR     r1, [r3], #4
;        CMN     r1, #1
;        BEQ     %ft1
;        LDR     r6, [r3], #4
;
;; [ DebugModule
;;        DLINE   "CLPair: "
;;        DREG    r1, " "
;;        DREG    r6, ", "
;; ]
;        TEQ     r1, #ControlList_ExtraBytes
;        MOVEQ   r6, r6, lsl #21               ; effectively and &7ff
;        MOVEQ   r6, r6, lsr #21               ;
;        STREQ   r6, LineExtraBytes
;        TEQ     r1, #ControlList_Interlaced
;        BNE     %bt2
;        AND     r6,r6,#1
;        STRB    r6, Interlacestate              ; remember in R6 too
;;        STR     r6,CursordoubleScan
;        B       %bt2
;

d796 1
a796 1
; r0 = mode or->VIDCList3   (writable!!)
d799 1
a799 1
        Push    "r0-r7,lr"
d801 1
d803 7
a809 10
  bl DebugTXStrInline
  DCB "start vmfv3",10,13,0
  ALIGN
 ]
        adrl    r7,modedefbuf
11      ldr     r0, [r6] , #4
        str     r0, [r7] , #4
 [ Debug
  bl DebugHexTX4
 ]
d811 9
a819 6
        bne     %bt11
        Pull    "r6"                       ; recover the pointer
 [ Debug
  bl DebugTXStrInline
  DCB 10,13,"modedefbuf printed",10,13,0
  ALIGN
d822 4
d837 42
d1412 1
a1412 1
        MOV     r4, #GraphicsV_VSync
d1414 2
@


1.10
log
@Update to work with latest version of VCHIQ module
Detail:
  s/HWPointer - Specify dispmanx service version when connecting to it
  s/BCMVideo - Fixed compile error when hardware pointer disabled
Admin:
  Tested on Raspberry Pi
  Requires VCHIQ-0_05


Version 0.12. Tagged as 'BCMVideo-0_12'
@
text
@d38 3
d56 4
a59 1
tagbuffer_size   *       1024+256 ; allocated by PCI module to ensure noncacheable
d79 4
d98 4
a101 1
ScreenBanksEnabled #     4 ; Cached BCMVideo$ScreenBanksEnabled value
d103 1
a103 1
MBState          #       4 ; Zero = free, nonzero = awaiting response
d164 2
d167 2
a168 4
        ADRL    lr, $tags
        LDR     lr, [lr]
        SUB     sp, sp, lr ; Reserve stack space for response
        ADD     lr, sp, lr ; Get original SP in lr
d174 2
a175 7
        Push    "lr"
        ; Check current state of mailbox
        LDR     lr, MBState
        TEQ     lr, #0
        BLNE    MBWait
        ; Claim mailbox
        STR     pc, MBState
d177 1
a177 1
        ADD     lr, sp, #8
d179 1
a179 1
        MOV     lr, #0
d181 5
d187 1
a191 3
        ; Clear the flag, we may not have sent anything
        MOV     lr, #0
        STR     lr, MBState
d334 5
d358 2
d361 2
d375 2
d388 1
a388 2

        LDR     r0, tagbuffer
d396 1
d611 2
a612 1

a638 1
        ldr     r3, tagbuffer                ; tagbuffer address
d835 1
d897 3
a899 2
        MBClaim vettagb

a901 1
        ldr     r3, tagbuffer                ; tagbuffer address
d1019 1
a1019 12
        MBClaim offtagb
        ; Change to new offset
        adrl    r1, offtagb                  ; buffer source
        ldr     r2, [r1]                     ; length
        ldr     r3, tagbuffer                ; tagbuffer address
111     subs    r2, r2, #4                   ; initialise the tagbugffer
        ldrge   lr, [r1, r2]
        strge   lr, [r3, r2]
        bgt     %bt111
        STR     r0, [r3, #offvyoff-offtagb]
        STR     r0, mbyoff
        MOV     r0, r3
d1027 11
a1037 1
        BEQ     %FT90
d1039 11
d1052 5
a1061 22
 [ {TRUE}
90
        ; Inline SendMBMessage implementation to avoid waiting for result
        ldr     r0, tagbuffer_phy
        ldr     r3, MBResponse
        ADD     r0,r0, #MB_Chan_ARM2VC
        DoMemBarrier r2
        LDR     r2, PeriBase
        ADD     r2, r2, #MB_Base
; check we can send a message
001     LDR     r1,[r2, #MB_Sta]
        TST     r1, #MB_Sta_Full
        BNE     %BT001                ; write channel full
; send message
        STR     r0,[r2, #MB_ChWr]
        ; Exit without using MBFinish, as that will clear the 'need to wait' flag and cause us to go further out of sync with the GPU
        Pull    "lr"
        PLP
        LDR     sp,[sp]
        B       %BT80
 ]

a1104 1
        LDR     r0, tagbuffer
d1107 7
a1113 1
        MBClaim paltags
d1131 1
a1131 1
        LDR     r0, tagbuffer
d1147 5
d1158 1
a1161 1
        ldr     r3, tagbuffer                ; tagbuffer address
d1164 1
a1164 1
        strge   lr, [r3, r2]
d1166 1
a1166 3
        AND     r0, r0, #1
        STR     r0, [r3, #blankstate-blanktags]
        MOV     r0, r3
d1171 1
a1171 1
; in: r0 = Message buffer logical address. 16 byte aligned. assumed to be tagbuffer!
d1173 1
d1177 10
a1186 1
        ldr     r0, tagbuffer_phy
d1189 6
a1203 8
        AND     r0, r0, #&f           ; isolate channel bits
002     LDR     r1,[r2, #MB_Sta]
        TST     r1, #MB_Sta_Empty
        BNE     %FT010                ; still empty
        LDR     r1,[r2,#MB_ChRd]
        and     r1,r1,#&f
        CMP     r0, r1                ; check its is our channel
        BNE     %FT010                ; not our reply
d1205 14
a1218 3
        TEQ     r3, #0
        EXIT    EQ
        ; Copy response to buffer
a1219 7
        LDR     r0, tagbuffer
        LDR     r1, [r0]
005
        LDR     r2, [r0], #4
        SUBS    r1, r1, #4
        STR     r2, [r3], #4
        BNE     %BT005
d1222 142
a1363 5
010
        ; Enable IRQs while we wait for the response
        DoMemBarrier r1
        MRS     r1, CPSR
        BIC     lr, r1, #I32_bit
d1367 9
a1375 23
        MSR     CPSR_c, r1
        DoMemBarrier r1
        ; Were we preempted?
        LDR     r1, MBState
        TEQ     r1, #0
        BNE     %BT002 ; No, so go round again
        ; The routine that preempted us will have copied the result to the buffer, all we need to do is update the pointer
        TEQ     r3, #0
        STRNE   r3, [sp]
        EXIT

SendMBMessage_Alt
        ALTENTRY
        ; Wait for an interrupted message to complete
        LDR     r3, MBResponse
        LDR     r2, PeriBase
        ADD     r2, r2, #MB_Base
        MOV     r0, #MB_Chan_ARM2VC
        DoMemBarrier r1
        B       %BT002

MBWait  ROUT
        Entry   "r0"
d1377 1
d1379 1
a1379 1
        DCB     "MBWait",10,13,0
a1381 1
        BL      SendMBMessage_Alt
a1383 1

d1549 2
@


1.9
log
@Tweak the code to get mode 7 working. Add a way to disable the wait for the GPU when switching screen banks.
Detail:
  s/BCMVideo - Decreased ScreenBankMax to get mode 7 to display properly. Update SetVinit to cope with being called from IRQ mode (as happens in mode 7), and to skip waiting for the GPU response when (a) called from IRQ mode or (b) BCMVideo$ScreenBanksEnabled is '2'.
  Resources/RPIMon - Added a 640x500 mode definition, for mode 7.
Admin:
  Tested on Raspberry Pi
  Requires HdrSrc-2_21 for the kernel to use a compatible version of its mode 7 code.


Version 0.11. Tagged as 'BCMVideo-0_11'
@
text
@a498 1
  [ HWPointer
a500 1
  ]
@


1.8
log
@Add support for multiple screen banks. Improve mailbox handling to allow IRQs to be enabled while waiting for response.
Detail:
  s/BCMVideo:
  - Reworked mailbox handling to allow IRQs to be enabled while waiting for a response. If an attempt is made to send another message while still waiting for the first, the code will detect that a message is currently outstanding and will wait for the first to complete before claiming use of the shared message buffer. This has had a big impact on our IRQ latency, as it looks like the GPU waits until the end of each frame until processing framebuffer mailbox messages.
  - Added support for multiple screen banks. The GPU allows us to allocate a framebuffer which is larger than the area which is displayed on screen, and specify the X,Y offset of the displayed area. However because it works in texel coordinates instead of byte offsets, it means we're limited to vertical scrolling only, unlike the (potentially partial) horizontal scrolling support on other platforms. Several constraints are used to decide how many screen banks to try and allocate.
  - Added a BCMVideo$ScreenBanksEnabled system variable. If set to '0' it will disable screen banks on the next mode change. Any other value (including unset) enables them. This is a (potentially temporary) compatability option for use with old games; the fact that switching screen bank requires the driver to wait until the next VSync (while waiting for the GPU response) means that having screen banks enabled may have a significant framerate impact
  s/GraphicsV:
  - Screen bank support.
  - Allow GraphicsV_Render debug output to be turned off seperately of main debug switch.
  s/SWPointer:
  - Modified to work properly with screen banks.
Admin:
  Tested on Raspberry Pi
  Fixes flickering HUD in Star Fighter 3000
  Mailbox handling changes fix keyboard dying in Zool, however slow operation of screen bank switching means that you'll want screen banks disabled to be able to run at full frame rate.


Version 0.10. Tagged as 'BCMVideo-0_10'
@
text
@d46 2
a47 1
ScreenBankMax   *  15          ; 16 seems to be too many. I suspect the 4095 limit is a red herring, and it's actually this limit I was hitting during initial testing, but let's keep the 4095 limit for now and see how things go.
d88 1
d812 1
a812 1
        Entry   "r0-r4", 12
d814 2
a815 2
        MOV     r1, sp
        MOV     r2, #12
d817 1
d820 1
d824 1
a824 1
        LDRB    r2, [sp]
d993 5
d1004 2
a1005 2
        ldrge   r4, [r1, r2]
        strge   r4, [r3, r2]
d1010 9
d1021 3
d1026 21
@


1.7
log
@Adjust hardware pointer code to take into account overscan
Detail:
  s/BCMVideo, s/HWPointer - Hardware pointer code now takes into account overscan when calculating the scale and offset values required to convert RISC OS screen pixels to hardware/dispmanx pixels
Admin:
  Tested on Raspberry Pi


Version 0.09. Tagged as 'BCMVideo-0_09'
@
text
@d44 3
a46 2
          GBLL  NoIRQ ; Disable IRQs around message buffer code to prevent reentrancy issues
NoIRQ     SETL  {TRUE}
d57 1
a57 1
mbxres           #       4
d59 1
a59 1
mbxvres          #       4
d63 1
a63 1
mbxoff           #       4
d88 4
a120 1
IRQTrigger       #       4 ; IRQ trigger routine from OS_PlatformFeatures
a129 1
modedefbufref    #       256
d147 37
d354 11
a373 1
        LDR     r0, tagbuffer
d376 3
a402 7
        ; Get IRQTrigger routine
        MOV     r0, #0
        SWI     XOS_PlatformFeatures
        MOVVS   r0, #0
        TST     r0, #2
        ADREQ   r1, NullFunc ; Just use NullFunc if no trigger needed
        STR     r1, IRQTrigger
a410 1
        adrl    r4, modedefbufref
a413 1
        str     r0, [r4] , #4
d508 1
a508 1
        ADR     r0, PaletteTicker
d588 1
a588 4
      [ NoIRQ
        PHPSEI
        Push    "lr"
      ]
d598 1
d600 1
a600 1
11      ldr     r0, [r6] , #4
a606 5
      [ NoIRQ
        ldr     r6, [sp, #4]
      |
        ldr     r6, [sp]                   ; recover the pointer
      ]
a646 3
 [ Debug
  bl DebugHexTX4
 ]
d653 18
a670 19
 [ Debug
  bl DebugHexTX4
 ]
        LDR     r0, [r6, #VIDCList3_HorizDisplaySize]
        STR     r0, mbxres
        STR     r0, mbxvres
        str     r0, [r3, #phyx-tagb]
        str     r0, [r3, #virtx-tagb]
 [ Debug
  bl DebugHexTX4
 ]
        LDR     r0, [r6, #VIDCList3_VertiDisplaySize]
        STR     r0, mbyres
        STR     r0, mbyvres
        str     r0, [r3, #phyy-tagb]
        str     r0, [r3, #virty-tagb]
 [ Debug
  bl DebugHexTX4
 ]
d676 1
d682 7
d690 1
d743 1
a743 4
 [ NoIRQ
        Pull "lr"
        PLP
 ]
d759 45
d805 29
a859 5
 [ NoIRQ
        PHPSEI
        Push    "lr"
 ]

d872 2
d933 1
a933 1
        BNE     %FT999
d940 2
a941 1
        BNE     %FT999
a948 4
 [ NoIRQ
        Pull "lr"
        PLP
 ]
d952 2
a954 4
 [ NoIRQ
        Pull "lr"
        PLP
 ]
d961 1
a961 2
        Pull    "r1-r7"
        Pull    "pc"
d963 41
a1009 1
; TODO - If the updates are slow, it's probably a bad thing to be doing them with IRQs disabled, but at the moment that's the only way of ensuring the message buffer isn't in use already
d1038 5
d1050 1
a1050 1
        ADR     r4, paltags
d1052 1
a1052 2
        PHPSEI  ; IRQs should already be off if we're in the ticker, but not if we're in SetPalette
        Push    "lr"
d1082 1
a1082 1
        BL      SendMBMessage
d1085 3
a1087 2
        Pull "lr"
        PLP
d1092 1
a1092 3
      [ NoIRQ
        PHPSEI  r4
      ]
d1104 1
a1104 3
      [ NoIRQ
        PLP     r4
      ]
d1109 1
d1111 1
a1111 1
        Push    "r0-r2,lr"
d1113 1
d1127 1
a1127 1
        BNE     %BT002                ; still empty
d1131 1
a1131 1
        BNE     %BT002                ; not our reply
d1133 52
a1184 1
        Pull    "r0-r2,pc"
d1360 10
@


1.6
log
@Added a mode change to the initialisation sequence so we can get some VDU output.
This means we can see DebugROMInit and co in development ROMs again.

Version 0.08. Tagged as 'BCMVideo-0_08'
@
text
@d66 4
d108 2
a109 1
HWPScale         #       4 ; RISC OS pixel -> actual pixel scale
d112 1
a112 1
HWPInvScale      #       4 ; Inverse scale
d669 21
d1090 7
@


1.5
log
@Add GraphicsV_Render implementation. Allow utilisation of new fake_vsync_isr config.txt option for generating VSync interrupts.
Detail:
  hdr/DMA, s/BCMVideo, s/GraphicsV - Added GraphicsV_Render implementation. Uses one of the 2D-capable DMA channels to accelerate block copies/moves. Rectangle fill acceleration currently not supported.
  hdr/BCM2835reg, s/BCMVideo, s/GraphicsV - Add code to detect whether the new fake_vsync_isr firmware option (https://github.com/raspberrypi/firmware/issues/67) is enabled and if so, use it as our VSync IRQ source.
  s/HWPointer - Add toggle for hardware pointer debug to reduce debug spam
Admin:
  Tested on Raspberry Pi with high processor vectors & various firmware versions


Version 0.07. Tagged as 'BCMVideo-0_07'
@
text
@d42 1
a42 1
HWPointer SETL  {TRUE}          
d125 1
a125 1
; align to 4 byte boundary       
d146 1
a146 1
Module_BaseAddr        
d160 1
a160 1
        
d241 1
a241 1
        DCD  1080       ; v pixels     
d261 1
a261 1
        SWI     XOS_Module                                               
d358 1
a358 1
        
d424 1
a424 1
        SWI     XOS_ClaimDeviceVector        
d436 7
d451 1
a451 1
  ]  
d569 2
a570 2
  ALIGN      
 ]        
d579 1
a579 1
            
d626 2
a627 2
        STR     r0, mbyres  
        STR     r0, mbyvres 
d718 2
a719 2
  ALIGN      
 ]        
d745 1
a745 1
            
d827 1
a827 1
  ALIGN      
d1013 1
a1013 1
        
d1019 1
a1019 1
        DCD     0        
d1038 1
a1038 1
tagdispldepth           
d1043 1
a1043 1
tagdisplpixord           
d1048 1
a1048 1
tagdisplalpha           
d1053 1
a1053 1
taggetpitch           
d1058 1
a1058 1
tagdisplalloc           
d1063 1
a1063 1
dispsz  DCD     0           
d1069 1
a1069 1
        DCD     0        
d1088 1
a1088 1
vtagdispldepth           
d1102 1
a1102 1
        DCD     0        
d1129 1
a1129 1
        LTORG                          
d1142 1
a1142 1
      ]        
@


1.4
log
@Add support for GraphicsV_SetBlank
Detail:
  s/BCMVideo, s/GraphicsV - Added support for GraphicsV_SetBlank, via simple mailbox message
Admin:
  Tested on Raspberry Pi


Version 0.06. Tagged as 'BCMVideo-0_06'
@
text
@d31 3
d45 1
a45 1
NoIRQ     SETL  {TRUE}          
d73 10
d130 8
d258 1
a258 1
        Push    "r1-r4,lr"
d271 2
a273 1
        MOV     r0, #1
d285 1
a285 1
        MOV     r0, #tagbuffer_size+32*32*4 ; tag buffer + HW cursor image in one block
d287 1
a287 1
        MOV     r0, #tagbuffer_size
d289 2
a290 1
        MOV     r1, #16
d296 8
d305 1
a305 1
        ADD     r0, r0, #tagbuffer_size
d371 61
d436 1
a436 1
        Pull    "r1-r4,pc"
d439 1
a439 1
        Pull    "r1-r4,pc"
d461 5
d536 5
a540 1
      
a542 1
        MOV     r0, #1
d643 1
d658 5
d681 1
a681 1
  DCB "done FB2",10,13
d953 53
a1005 1
        Pull    "r0-r2,pc"     
@


1.3
log
@Add hardware pointer support
Detail:
  s/HWPointer, s/BCMVideo, s/GraphicsV - Added hardware pointer support, using VCHIQ to talk to the VC-side dispmanx service. Software pointer will automatically disable itself once the hardware pointer is activated by VCHIQ being loaded.
  s/SWPointer, s/BCMVideo - Renamed software pointer routines & variables to have 'SWP' prefix to more easily differentiate them from the 'HWP' hardware pointer routines/variables
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.05. Tagged as 'BCMVideo-0_05'
@
text
@d802 21
d955 9
@


1.2
log
@First working version of video driver
Detail:
  This version of the driver supports 8bpp & 32bpp screen modes, and uses a software mouse pointer.
  Startup mode is forced to 1080p, 32bpp (via code in the HAL). After that, RISC OS is free to do as it pleases.
  Makefile, s/BCMVideo - Added Castle licence text
  Resources/RPIMon - Simple MDF that gets loaded on startup. Contains simple 1080p & 720p mode definitions, plus copies of definitions for numbered modes from AKF50 MDF (to ensure RISC OS doesn't freak out due to not having any fallback modes available)
  s/BCMVideo - Main bulk of video driver
  s/Debug - Debug routines
  s/GraphicsV - GraphicsV handler
  s/SWPointer - Basic software mouse pointer implementation
Admin:
  Tested on Raspberry Pi with high processor vectors
  Still a few rough edges to iron out, but code seems stable enough


Version 0.03. Tagged as 'BCMVideo-0_03'
@
text
@d29 2
d38 3
a51 1
; following tag buffer, this requires 16 byte alignment too
d68 1
a68 1
PaletteDirty     #       4
d70 31
d102 3
a104 4
CurAddr          #       4 ; where to restore cursor image, or 0 for none, or 1 to disable pointer updates
CurHeight        #       4
CurPalette       #       4*4
CurUnder         #       32*4*32
d142 8
d153 1
d157 4
a160 1
        DCD     Service_PostInit                   ; &73
d167 3
d173 28
d252 1
a252 1
        STR     r0, CurAddr
d262 3
d266 1
d273 4
d308 1
a308 1
      ]        
d313 13
a325 1
        adr     r0, loadmodefilecommand
a345 1

d348 5
a352 3
loadmodefilecommand
        DCB     "loadmodefile Resources:Resources.BCMVideo.RPIMon",0
        ALIGN  
d357 3
d443 1
a443 1
        STR     r0, CurAddr
d560 1
a560 1
        STR     r0, CurAddr
d566 6
d944 3
@


1.1
log
@Initial revision
@
text
@d1 15
a15 1

d23 61
a83 1
        
d88 1
a88 1
        
d90 2
a91 1
        
d95 1
a95 1
        DCD     0; Service call handler
d106 2
a107 2
Title   =       "BCMVideo", 0
Help    =       "BCMVideo", 9, 9, "0.00 (01 Jan 2000)", 0
d110 120
d231 26
a256 1
Init    ROUT
d258 13
a270 1
;        SWI     XOS_WriteI+7
d272 448
d721 117
a837 3
Final   ROUT
        MOV     pc, lr
        
@


1.1.1.1
log
@Initial import of stub for BCMVideo module


@
text
@@

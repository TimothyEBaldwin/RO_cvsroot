head	1.22;
access;
symbols
	BCMVideo-0_53:1.22
	BCMVideo-0_52:1.22
	BCMVideo-0_51:1.22
	BCMVideo-0_50-1_50_2_1:1.21
	RPiFreeze:1.21.0.2
	BCMVideo-0_50:1.21
	BCMVideo-0_49:1.21
	BCMVideo-0_48:1.20
	BCMVideo-0_47:1.19
	BCMVideo-0_46:1.18
	BCMVideo-0_45:1.18
	BCMVideo-0_44:1.18
	BCMVideo-0_43:1.18
	BCMVideo-0_42:1.18
	BCMVideo-0_41:1.18
	BCMVideo-0_40:1.18
	BCMVideo-0_39:1.17
	BCMVideo-0_38:1.17
	BCMVideo-0_37:1.16
	BCMVideo-0_36:1.15
	BCMVideo-0_35:1.15
	BCMVideo-0_34:1.15
	BCMVideo-0_33:1.15
	BCMVideo-0_32:1.15
	BCMVideo-0_31:1.15
	BCMVideo-0_30:1.14
	BCMVideo-0_29:1.13
	BCMVideo-0_28:1.12
	BCMVideo-0_27:1.11
	BCMVideo-0_26:1.11
	BCMVideo-0_25:1.11
	BCMVideo-0_24:1.11
	BCMVideo-0_23:1.11
	BCMVideo-0_22:1.10
	BCMVideo-0_21:1.9
	BCMVideo-0_20:1.9
	BCMVideo-0_19:1.8
	BCMVideo-0_18:1.8
	BCMVideo-0_17:1.8
	BCMVideo-0_16:1.8
	BCMVideo-0_15:1.7
	BCMVideo-0_14:1.6
	BCMVideo-0_13:1.5
	BCMVideo-0_12:1.5
	BCMVideo-0_11:1.5
	BCMVideo-0_10:1.5
	BCMVideo-0_09:1.4
	BCMVideo-0_08:1.4
	BCMVideo-0_07:1.4
	BCMVideo-0_06:1.3
	BCMVideo-0_05:1.2
	BCMVideo-0_04:1.1
	BCMVideo-0_03:1.1;
locks; strict;
comment	@# @;


1.22
date	2018.07.01.12.32.41;	author jlee;	state Exp;
branches;
next	1.21;
commitid	SZDeyIEUJXdXNqIA;

1.21
date	2018.02.02.20.37.39;	author jlee;	state Exp;
branches;
next	1.20;
commitid	aDAuPtQqF7MfhkpA;

1.20
date	2017.07.11.20.38.24;	author jlee;	state Exp;
branches;
next	1.19;
commitid	b7YZJl5wsCF3UQYz;

1.19
date	2017.06.07.21.33.47;	author jlee;	state Exp;
branches;
next	1.18;
commitid	j2SoIQlTVE0PiuUz;

1.18
date	2016.12.10.17.01.54;	author jlee;	state Exp;
branches;
next	1.17;
commitid	zybtuuARus1hysxz;

1.17
date	2016.03.26.21.17.31;	author jlee;	state Exp;
branches;
next	1.16;
commitid	c5oBNUnis9z7ic0z;

1.16
date	2016.03.25.20.15.23;	author jlee;	state Exp;
branches;
next	1.15;
commitid	65QlxlgxPV3NY30z;

1.15
date	2015.07.10.20.33.44;	author jlee;	state Exp;
branches;
next	1.14;
commitid	gEvIKFBh5s2gpMsy;

1.14
date	2015.02.02.15.36.51;	author bavison;	state Exp;
branches;
next	1.13;
commitid	dsG4rJhYyVQhQr8y;

1.13
date	2014.11.02.17.24.55;	author jlee;	state Exp;
branches;
next	1.12;
commitid	ASl9I4vLOoLIoDWx;

1.12
date	2014.08.04.19.22.53;	author jlee;	state Exp;
branches;
next	1.11;
commitid	V4JFdZTE3n8yW4Lx;

1.11
date	2014.04.18.14.27.42;	author jlee;	state Exp;
branches;
next	1.10;
commitid	uRziBlqK8ezwMaxx;

1.10
date	2014.04.16.21.02.04;	author jlee;	state Exp;
branches;
next	1.9;
commitid	wYCRGB3p48VN1Xwx;

1.9
date	2014.03.09.17.52.01;	author jlee;	state Exp;
branches;
next	1.8;
commitid	VsKBoAR8ZORkc3sx;

1.8
date	2014.01.01.16.38.15;	author jlee;	state Exp;
branches;
next	1.7;
commitid	hv7JxPX2J7fxWqjx;

1.7
date	2013.12.19.22.49.23;	author jlee;	state Exp;
branches;
next	1.6;
commitid	t3YFuwm7k1CMpNhx;

1.6
date	2013.12.15.22.21.41;	author jlee;	state Exp;
branches;
next	1.5;
commitid	bwYuPhPuWChfohhx;

1.5
date	2012.11.25.22.29.59;	author jlee;	state Exp;
branches;
next	1.4;
commitid	KA5Rb3NW1StkONtw;

1.4
date	2012.09.18.13.55.49;	author jlee;	state Exp;
branches;
next	1.3;
commitid	Apt88JppQEvt91lw;

1.3
date	2012.09.08.15.02.04;	author jlee;	state Exp;
branches;
next	1.2;
commitid	TZX98tKZGlo9QJjw;

1.2
date	2012.09.07.01.05.06;	author jlee;	state Exp;
branches;
next	1.1;
commitid	sA7cjtQbUOm0fxjw;

1.1
date	2012.09.02.20.13.33;	author jlee;	state Exp;
branches;
next	;
commitid	Eobp7iVtciTWKZiw;


desc
@@


1.22
log
@Add support for the GraphicsV overlay API and alpha-blended screen modes. Allow gamma table use to be disabled via adding 'disable_gamma' to cmdline.txt
Detail:
  s/BCMVideo - Update workspace for the new features. On startup, check to see if 'disable_gamma' is included in the firmware-managed kernel command line (i.e. from cmdline.txt in the bootloader partition), and if so disable all use of the hardware gamma tables. Update mode vet & set to allow alpha-blending in 32bpp modes.
  s/Dispmanx, s/HWPointer - Move the dispmanx-related routines out of s/HWPointer and into their own file, for re-use by the GraphicsV overlay code
  s/GPUMode - Move the command line scanning code into s/BCMVideo so it's still available if the GPUMode build switch is disabled
  s/GenCmd - Tweak how GenCmd_GetConfigInt returns values so that zero-value variables can be distinguished from errors. Check the framebuffer_ignore_alpha variable to determine if the GPU will pay attention to the FBSetAlphaMode property tag.
  s/GraphicsV - Hook up the GraphicsV overlay entries. Fix determination of whether hardware pointer is fully supported to also check the screen height.
  s/GVOverlay - Initial support for the GraphicsV hardware overlay API. It's best used in 32bpp alpha-blended screen modes, so that the overlays can be placed behind the desktop. Rotated/flipped overlays aren't supported yet.
Admin:
  Tested on Raspberry Pi 1 & 3
  Requires BCMSupport-0_08
  disable_gamma should allow people who are frequently affected by https://www.riscosopen.org/forum/forums/11/topics/10346 to use their systems, pending a proper fix once the root cause has been determined.
  Note that options in cmdline.txt should be space-separated, so to disable both GPU mode changes & gamma table use you'll want 'disable_gamma disable_mode_changes'.


Version 0.51. Tagged as 'BCMVideo-0_51'
@
text
@; Copyright 2012 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        GET     GraphicsV

        GBLL    RenDebug
RenDebug SETL   Debug :LAND: {FALSE}        

        MACRO
        GVEntry $name
        ASSERT  . - GraphicsV_Table = GraphicsV_$name * 4
        B       GV_$name
        MEND

        MACRO
        RIEntry $name
        ASSERT  . - ReadInfo_Table = GVReadInfo_$name * 4
        B       RI_$name
        MEND

; Reason code is in R4 lower bytes. bits 31..24 = display number, default 0
GraphicsV_Handler
        Push    "lr"
        LDRB    lr, GVinstance       ; may need another if more than 1 graphics module
        EOR     lr, R4, lr, LSL #24  ; the below test will fail if this is the wrong driver
        BIC     lr, lr, #&ff0000     ; mask out head/overlay number
        CMP     lr, #(GraphicsV_TableEnd - GraphicsV_Table) / 4
        ADDLO   pc, pc, lr, LSL #2
        Pull    "pc"
GraphicsV_Table
        Pull    "pc"                 ;   
        Pull    "pc"                 ; GV_VSync irq occurred                    
        GVEntry SetMode              ; GV_SetMode                 
        Pull    "pc"                 ; GV_SetInterlace            
        GVEntry SetBlank             ; GV_SetBlank                
        GVEntry UpdatePointer        ; GV_UpdatePointer           
        GVEntry SetDMAAddress        ; GV_SetAddress              
        GVEntry VetMode              ; GV_VetMode                 
        GVEntry DisplayFeatures      ; GV_Features                
        GVEntry FramestoreAddress    ; GV_FramestoreAddress
        GVEntry WritePaletteEntry    ; GV_WritePaletteEntry       
        GVEntry WritePaletteEntries  ; GV_WritePaletteEntries     
        Pull    "pc"                 ; GV_ReadPaletteEntry
        GVEntry Render               ; GV_Render                  
        GVEntry IICOp                ; GV_IICOp                
        Pull    "pc"                 ; GV_SelectHead
      [ BuiltinMDF
        GVEntry StartupMode          ; GV_StartupMode
      |
        Pull    "pc"                 ; GV_StartupMode
      ]
        GVEntry PixelFormats         ; GV_PixelFormats
        GVEntry ReadInfo             ; GV_ReadInfo
        GVEntry VetMode2             ; GV_VetMode2
        GVEntry CreateOverlay
        GVEntry DestroyOverlay
        GVEntry SetOverlayPosition
        GVEntry MapOverlayBuffer
        GVEntry UnmapOverlayBuffer
        GVEntry DiscardOverlayBuffer
        GVEntry VetOverlay
        GVEntry SetOverlayTransform
        GVEntry SetOverlayZOrder
GraphicsV_TableEnd

GV_VetMode
        Push    "r2"
        BL      VetModeFromVIDCList
        ASSERT  GVVetMode2_Result_Unsupported = 0
        TST     r0, #GVVetMode2_ResultMask
        ANDNE   r0, r0, #GVVetMode2_ExtraBytes_Invalid
        MOVEQ   r0, #1
        MOV     r4, #0
        Pull    "r2,pc"

GV_VetMode2
        BL      VetModeFromVIDCList  ; Returns with r0, r2 correct
        ; Fill in the other registers
        MOV     r1, #32
        MOV     r4, #0
        Pull    "pc"

GV_SetMode
        Push    "r2"
        BL      SetModeFromVIDCList
        MOV     r4, #0
        Pull    "r2,pc"

GV_SetBlank
        ; Assume state is changing and always request a message send
        AND     r4, r0, #1
        STRB    r4, BlankState
        STR     lr, UpdateNeeded
        MOV     r4, #0
        Pull    "pc"

GV_SelectHead
;        BL      SelectHead
        MOV     r4, #0
        Pull    "pc"

GV_UpdatePointer
      [ HWPointer
        LDR     lr, HWPActive
        TEQ     lr, #0
        BNE     HWP_Update
      ]
        Pull    "pc"

GV_SetDMAAddress
      [ Debug
        Push    "r0"
        BL      DebugHexTX4
        MOV     r0, r1
        BL      DebugHexTX4
        BL      DebugTXStrInline
        DCB     "GV_SetDMAAddress",10,13,0
        ALIGN
        Pull    "r0"
      ]
        TEQ     r0, #3
        STREQ   r1, vdu_init
        TEQ     r0, #0
        BLEQ    SetVinit
        MOV     r4, #0
        Pull    "pc"

GV_DisplayFeatures
        MOV     r0, #GVDisplayFeature_InterlaceWithProgressiveFramestore+GVDisplayFeature_SeparateFramestore+GVDisplayFeature_VariableFramestore+GVDisplayFeature_CopyRectangleIsFast
      [ HWPointer
        ; Only claim hardware pointer if (a) it's available and (b) the screen
        ; is small enough to not hit the GPU coord limit
        LDR     r1, HWPActive
        TEQ     r1, #0
        ORRNE   r0, r0, #GVDisplayFeature_HardwarePointer
        LDR     r1, DisplayWidth
        CMP     r1, #2048
        LDRLE   r2, DisplayHeight
        CMPLE   r2, #2048
        BICGT   r0, r0, #GVDisplayFeature_HardwarePointer
      ]
        LDRB    r1, VSyncAvailable
        TEQ     r1, #0
        ORREQ   r0, r0, #GVDisplayFeature_NoVsyncIRQ
        MOV     r1, #2_101000           ; 8,32bpp supported. 16bpp is RGB565, i.e. 2_RRRRRGGGGGGBBBBB
      [ AemulorSupport
        ; We must claim we support the regular 32K colour mode in order for 64K
        ; colour modes to work correctly when old versions of Aemulor are loaded
        LDRB    lr, OldAemulor
        TEQ     lr, #0
        ORRNE   r1, r1, #2_010000
      ]
        MOV     r2, #32                 ; framestore must be 32 byte aligned?
        MOV     r4, #0
        Pull    "pc"

GV_FramestoreAddress
 [ Debug
 bl DebugTXStrInline
 DCB "GC_FSA size, base", 0
 ALIGN
 ]
        LDR     r1, mbscrsz
 [ Debug
 mov r0, r1
 bl DebugHexTX4
 ]
       LDR     r0, mbbase
 [ Debug
 bl DebugHexTX4
 ]
        MOV     r4, #0
 [ Debug
 bl DebugTXStrInline
 DCB 10,13, 0
 ALIGN
 ]
        Pull    "pc"

GV_WritePaletteEntry ROUT
        MOV     r4, #0
        CMP     r0, #1
        BGT     %FT50
        Pull    "pc", EQ ; Border colour not supported
        ; Standard palette entry
        LDR     lr, mbbpp
        CMP     lr, #8
        Push    "r1,r3"
        MOV     r3, #1
        MOV     r1, sp
        ADR     lr, %FT40
        BNE     SetGamma
        B       SetPalette
40
        Pull    "r1,r3,pc"

50
        ADR     lr, CurPalette
        STR     r1, [lr, r2, LSL #2]
      [ HWPointer
        STRB    r0, HWPPalDirty
      ]
        Pull    "pc" 

GV_WritePaletteEntries ROUT
        MOV     r4, #0
        CMP     r3, #0
        CMPNE   r0, #1
        BGT     %FT50
        Pull    "pc", EQ ; Zero palette entries, or border colour
        ; Standard palette entries
        LDR     lr, mbbpp
        CMP     lr, #8
        ADR     lr, %FT40
        BNE     SetGamma
        B       SetPalette
40
        Pull    "pc"

50
        Push    "r0,r3"
        ADR     lr, CurPalette
        ADD     lr, lr, r2, LSL #2
      [ HWPointer
        STRB    r0, HWPPalDirty
      ]
60
        LDR     r0, [r1], #4
        STR     r0, [lr], #4
        SUBS    r3, r3, #1
        BNE     %BT60
        Pull    "r0,r3,pc"

GV_IICOp ROUT
        ; => r0 = b0-15 offset to start at
        ;         b16-23 base address of IIC device
        ;    r1 = pointer to buffer
        ;    r2 = number of bytes to transfer
        ; <= r0 = 0 or error
        ;    r1 = advanced by number of bytes transferred
        ;    r2 = number of bytes not transferred
        AND     r4, r0, #&FF:SHL:16
        CMP     r4, #&A1:SHL:16         
        MOV     r4, #0
        MOVNE   r0, #IICStatus_NoACK
        Pull    "pc", NE                ; Only reads of EDID please
        Push    "r3-r8"
        UXTH    r3, r0
        SUB     sp, sp, #edidtagslen
10
        CMP     r2, #0
        BEQ     %FT40
        ; Try fetching a block
        MOV     r0, sp
        ADRL    r4, edidtagb
        MOV     r5, #edidtagslen
20
        LDR     lr, [r4], #4
        STR     lr, [r0], #4
        SUBS    r5, r5, #4
        BGT     %BT20
        MOV     r0, sp
        MOV     r4, r3, LSR #7
        STR     r4, [r0, #edidblock-edidtagb]
        Push    "r1,r2"
        MOV     r1, r0
        MOV     r2, #0
        SWI     XBCMSupport_SendTempPropertyBuffer
        Pull    "r1,r2"
        MOVVS   r0, #IICStatus_Error
        BVS     %FT90
        ; Non-zero status generally means NoACK condition (e.g. monitor disconnected)
        LDR     r4, [r0, #edidstatus-edidtagb]
        TEQ     r4, #0
        MOVNE   r0, #IICStatus_NoACK
        BNE     %FT90
        ; Transfer bytes from this block
        AND     r4, r3, #127
        ADD     r4, r4, #edidbuffer-edidtagb
        ADD     r4, r4, r0
30
        LDRB    lr, [r4], #1
        STRB    lr, [r1], #1
        SUBS    r2, r2, #1
        ADD     r3, r3, #1
        TSTNE   r3, #127
        BNE     %BT30
        B       %BT10
40
        MOV     r0, #IICStatus_Completed
90
        ADD     sp, sp, #edidtagslen
        Pull    "r3-r8,pc"        


GV_Render
        Push    "r0-r3"
        LDRB    r0, GVRenderNotAvailable
        TEQ     r0, #0
        BNE     GV_Render_NotDoing
      [ RenDebug
        LDR     r0, [sp]
        BL      DebugHexTX4
        MOV     r0, r1
        BL      DebugHexTX4
        BL      DebugTXStrInline
        DCB     "GV_Render",10,13,0
        ALIGN
      ]
        ; Only copies & NOPs are supported
        TEQ     r1, #GVRender_CopyRectangle
        BEQ     GV_Render_Copy
        TEQ     r1, #GVRender_NOP
        BEQ     GV_Render_Complete

GV_Render_NotComplete
        LDR     r0, [sp]
        TST     r0, #GVRender_SyncIfNotComplete
        BLNE    GV_Render_Sync
      [ RenDebug
        BL      DebugTXStrInline
        DCB     "NotComplete",10,13,0
        ALIGN
      ]
GV_Render_NotDoing        
        Pull    "r0-r3,pc"

GV_Render_Complete
        LDR     r0, [sp]
        TST     r0, #GVRender_SyncIfComplete
        BLNE    GV_Render_Sync
      [ RenDebug
        BL      DebugTXStrInline
        DCB     "Complete",10,13,0
        ALIGN
      ]
        MOV     r4, #0
        Pull    "r0-r3,pc"

                ^ 0, r2
copy_src_left   # 4
copy_src_bottom # 4
copy_dst_left   # 4
copy_dst_bottom # 4
copy_width      # 4
copy_height     # 4

GV_Render_Copy ROUT
        ; In: R2 parameters
        ; Out: exit via GV_Render_Complete or GV_Render_NotComplete
        ;      R0-R3, LR corrupt
        BL      GV_Render_Sync ; Just in case
        Push    "r4-r8"
        ; Calculate src & dest addresses, and rect width
        LDR     r0, mbbpp
        LDR     r1, copy_width
        LDR     r3, copy_src_left
        LDR     r4, copy_dst_left
        LDR     r8, DMA_Offset
        MOV     r0, r0, LSR #3 ; bits -> bytes
        ADD     r1, r1, #1
        LDR     r5, mbyres
        LDR     r6, copy_height
        ADD     r6, r6, #1
        SUB     r5, r5, r6
        LDR     r6, copy_src_bottom
        LDR     r7, copy_dst_bottom
        SUB     r6, r5, r6
        SUB     r7, r5, r7
        LDR     r5, vdu_init
        LDR     lr, mbpitch
        ADD     r5, r5, r8
        MLA     r6, lr, r6, r5
        MLA     r7, lr, r7, r5
        MUL     r1, r0, r1 ; r1 = rect width in bytes
        MLA     r3, r0, r3, r6 ; r3 = src top-left pixel
        MLA     r4, r0, r4, r7 ; r4 = dest top-left pixel
      [ RenDebug
        MOV     r0, r1
        BL      DebugHexTX4
        MOV     r0, r3
        BL      DebugHexTX4
        MOV     r0, r4
        BL      DebugHexTX4
        MOV     r0, r5
        BL      DebugHexTX4
        LDR     r0, mbpitch
        BL      DebugHexTX4
        BL      DebugTXStrInline
        DCB     "rect w,src,dst,vdu,pitch",10,13,0
        ALIGN
        LDR     lr, mbpitch
      ]
        CMP     r4, r3
        BHI     %FT10
        ; dst rect is before src rect in memory
        ; Copy in forwards direction, top row to bottom
        LDR     r5, copy_height
        ORR     r5, r1, r5, LSL #16
        SUB     r6, lr, r1 ; stride between each row
        MOV     r6, r6, LSL #16 ; 16 bit
        ORR     r6, r6, r6, LSR #16 ; duplicated for src & dest
04
        LDR     r1, =DMA_TI_TDMODE+DMA_TI_SRC_INC+DMA_TI_DEST_INC+DMA_TI_SRC_WIDTH+DMA_TI_DEST_WIDTH
        LDRB    r7, DMA_BurstLength
        ORR     r1, r1, r7, LSL #DMA_TI_BURST_LENGTH_SHIFT
        MOV     r7, #0
        ASSERT  DMACB_TI = 0
        ASSERT  DMACB_SOURCE_AD = 4
        ASSERT  DMACB_DEST_AD = 8
        ASSERT  DMACB_TXFR_LEN = 12
        ASSERT  DMACB_STRIDE = 16
        ASSERT  DMACB_NEXTCONBK = 20
        LDR     r0, DMA_CB
        STMIA   r0, {r1,r3,r4,r5,r6,r7}
        LDR     r0, DMA_CB_phy
        LDR     r1, DMA_Chan
        ADD     r0, r0, r8
        DoMemBarrier lr
        ; Reset channel
        MOV     lr, #DMA_CS_RESET
        STR     lr, [r1, #DMACH_CS]
05
        LDR     lr, [r1, #DMACH_CS]
        TST     lr, #DMA_CS_RESET
        BNE     %BT05
        ; Set list start
        STR     r0, [r1, #DMACH_CONBLK_AD]
        ; Go
        LDR     r0, =DMA_CS_WAIT_FOR_OUTSTANDING_WRITES+(4<<DMA_CS_PRIORITY_SHIFT)+(7<<DMA_CS_PANIC_PRIORITY_SHIFT)+DMA_CS_ACTIVE
        STR     r0, [r1, #DMACH_CS]
        DoMemBarrier lr
        Pull    "r4-r8"
        B       GV_Render_Complete
10
        ADD     r0, r3, r1
        CMP     r0, r4
        BHI     %FT20
        ; src rect is before dst rect in memory, but individual rows don't overlap
        ; Copy in forwards direction, bottom row to top
        LDR     r5, copy_height
        MLA     r3, r5, lr, r3
        MLA     r4, r5, lr, r4
        ORR     r5, r1, r5, LSL #16
        RSB     lr, lr, #0 ; Go up a row instead of down
        SUB     r6, lr, r1 ; stride between each row
        MOV     r6, r6, LSL #16 ; 16 bit
        ORR     r6, r6, r6, LSR #16 ; duplicated for src & dest
        B       %BT04
20
        ; src rect is before dst rect in memory, with overlapping rows
        ; To cope with this we'd need to be able to decrement the src & dest addrs after each byte/word, which is something the DMA controller doesn't support, or maybe split up into multiple transfers
        ; So for the moment just give up and let RISC OS do it in software
        Pull    "r4-r8"
        B       GV_Render_NotComplete

GV_Render_Sync  ROUT
        ; Out: All regs preserved
        Entry   "r0"
      [ RenDebug
        BL      DebugTXStrInline
        DCB     "GV_Render_Sync",10,13,0
        ALIGN
      ]
        ; We may get called even if there's no DMA channel
        LDR     r0, DMA_Chan
        CMP     r0, #0
        EXIT    EQ
        DoMemBarrier lr
10
        LDR     lr, [r0, #DMACH_CS]
        TST     lr, #DMA_CS_ACTIVE
        BNE     %BT10
        DoMemBarrier lr
      [ RenDebug
        BL      DebugTXStrInline
        DCB     "done",10,13,0
        ALIGN
      ]
        EXIT

      [ BuiltinMDF
GV_StartupMode
        ADRL    r0, startupmode
        MOV     r4, #0
        Pull    "pc"
      ]

GV_PixelFormats
 [ AemulorSupport
        ; Old versions of Aemulor don't know about the new GV_PixelFormats
        ; call, which stops their low colour mode emulation from working
        ; because they only override the BPP flags returned by
        ; GV_DisplayFeatures. If we detected that an old version is running,
        ; adjust the list of returned modes to include all the low colour ones
        LDRB    r1, OldAemulor
        TEQ     r1, #0
 ]
        ADR     r0, PixelFormats
        MOV     r1, #(PixelFormats_End-PixelFormats)/12
 [ AemulorSupport
        ADDNE   r1, r1, #3              ; Adjust list to include low colour modes
 ]
        MOV     r4, #0
        Pull    "pc"

PixelFormats
        DCD     255,ModeFlag_FullPalette,3
        DCD     65535,ModeFlag_64k+ModeFlag_DataFormatSub_RGB,4
        DCD     -1,0,5
        DCD     -1,ModeFlag_DataFormatSub_Alpha,5
      [ ControlRGB
        DCD     -1,ModeFlag_DataFormatSub_RGB,5
        DCD     -1,ModeFlag_DataFormatSub_RGB+ModeFlag_DataFormatSub_Alpha,5
      ]
        ; Overlay-only formats
        ; TODO: sub-formats
        DCD     &32315659,ModeFlag_DataFormatFamily_YCbCr,7
        DCD     &36315659,ModeFlag_DataFormatFamily_YCbCr,7
        DCD     &3231564e,ModeFlag_DataFormatFamily_YCbCr,7
PixelFormats_End
 [ AemulorSupport
        DCD     1,0,0
        DCD     3,0,1
        DCD     15,0,2
 ]

GV_ReadInfo ROUT
        Push    "r0-r4"
        CMP     r0, #(ReadInfo_TableEnd - ReadInfo_Table) / 4
        ADDLO   pc, pc, r0, LSL #2
        Pull    "r0-r4,pc"
ReadInfo_Table
        RIEntry Version
        RIEntry ModuleName
        RIEntry DriverName
        RIEntry HardwareName
        RIEntry ControlListItems
        RIEntry MaxOverlays
ReadInfo_TableEnd

        GBLA    VersionBCD
VersionBCD SETBCD Module_Version

VersionBCDVal DCD VersionBCD<<8

ControlListItems
        DCD     ControlList_Interlaced
        DCD     ControlList_ExtraBytes
        DCD     ControlList_NColour
        DCD     ControlList_ModeFlags
        DCD     ControlList_Terminator        
ControlListItems_End

RI_Version
        ADR     r3, VersionBCDVal
        MOV     r4, #4
        B       %FT10

RI_ModuleName
RI_DriverName
        ADRL    r3, Title
        B       %FT05

RI_HardwareName
        LDR     r3, HALDevice
        TEQ     r3, #0
        LDRNE   r3, [r3, #HALDevice_Description]
05
        MOV     r4, #0
        TEQ     r3, #0
06
        LDRNEB  r0, [r3, r4]
        ADDNE   r4, r4, #1
        TEQNE   r0, #0
        BNE     %BT06
        B       %FT10

RI_ControlListItems
        ADRL    r3, ControlListItems
        MOV     r4, #ControlListItems_End-ControlListItems
10
        TEQ     r4, #0
        Pull    "r0-r4,pc", EQ
        CMP     r4, r2
        SUB     lr, r2, r4
        MOVLT   r2, r4
        STR     lr, [sp, #8]
20
        SUBS    r2, r2, #1
        LDRGEB  r0, [r3], #1
        STRGEB  r0, [r1], #1
        BGT     %BT20
        MOV     r4, #0
        STR     r4, [sp, #16]
        Pull    "r0-r4,pc"

RI_MaxOverlays
        ADR     r3, MaxOverlaysWord
        MOV     r4, #4
        B       %BT10

MaxOverlaysWord
        DCD     MaxOverlays

        LTORG

        END
@


1.21
log
@Implement gamma support for true-colour modes
Detail:
  hdr/BCM2835reg - Add some HVS / scaler register addresses. Remove unused FlushDataCache macros.
  s/BCMVideo - Add code for programming the HVS gamma table
  s/GraphicsV - Hook up gamma programming to GraphicsV palette handlers
Admin:
  Tested on Raspberry Pi 1 & 3, TV & HDMI output


Version 0.49. Tagged as 'BCMVideo-0_49'
@
text
@d37 1
d66 9
d147 1
a147 1
        LDR     r1, HWPDisplayWidth
d149 2
d511 1
a511 1
        MOV     r1, #3
d522 11
d550 1
d609 8
@


1.20
log
@Make GraphicsV_IICOp more consistent with other drivers
Detail:
  s/GraphicsV - If an EDID read fails, return with IICStatus_NoACK. This ensures that any situation in which the return R2 value is non-zero, an error code is also reported in R0.
Admin:
  Tested on Raspberry Pi 3
  Reading EDID with a detached monitor now returns IICStatus_NoACK and all bytes not transferred, which is consistent with the NVidia/OMAPVideo/IMXVideo/UDLVideo drivers


Version 0.48. Tagged as 'BCMVideo-0_48'
@
text
@a186 1
        Pull    "pc", NE
d190 4
a193 1
        BL      SetPalette
d213 4
a216 2
        Pull    "pc", NE
        BL      SetPalette
@


1.19
log
@Implement GraphicsV_VetMode2 and proper support for the ExtraBytes control list item
Detail:
  s/BCMVideo - Update SetModeFromVIDCList to support the ExtraBytes control list item. Update VetModeFromVIDCList so that it will suggest a new ExtraBytes value if the original wasn't satisfactory. Also, adjust padding logic - it looks like the framebuffer will always get padded out to a multiple of 16 pixels (not just for rotated framebuffers)
  s/GraphicsV - Make both GraphicsV_VetMode and GraphicsV_VetMode2 rely on VetModeFromVIDCList, but translate the results to the appropriate form.
Admin:
  Tested on Raspberry Pi 3
  720-width modes (amongst others) now work in 8bpp, and 360-width modes now work in <32bpp and are no longer garbled in 32bpp (width is only a multiple of 8 pixels)
  Requires HdrSrc-2_71 to build, ScreenModes-0_65 + Kernel-5_82 to reap the rewards


Version 0.47. Tagged as 'BCMVideo-0_47'
@
text
@d267 1
d270 2
a271 1
        BNE     %FT40
@


1.18
log
@Add support for GPU mode changes, vcgencmd implementation, and fix some issues with rotated displays
Detail:
  With recent firmware (~Aug 10th and newer) it's possible to issue a hdmi_timings command via vcgencmd to define custom mode timings on the fly. Make use of this feature (if available) to allow the OS to feed mode timings to the GPU instead of relying on the GPU to scale the framebuffer to the mode that was selected at boot.
  As an off-shoot of this we also get a vcgencmd *-command that's roughly equivalent to the vcgencmd command that's available under Linux
  File changes:
  - Makefile, Resources/UK/CmdHelp - *vcgencmd help text
  - s/BCMVideo - Add a few option switches to control the new behaviour. Add some generic code for interacting with VCHIQ services. Fix some issues with rotated displays (mainly 90 / 270 degree rotation)
  - s/Debug - Fix debug routines corrupting some registers
  - s/GraphicsV - Disable GraphicsV_StartupMode implementation if the builtin MDF is disabled (-> GPU mode changes are enabled)
  - s/HWPointer - Update to use the generic VCHIQ service code from s/BCMVideo
  - s/GenCmd - vcgencmd implementation. On initialisation, use it to read some of the GPU state & limits.
  - s/TVService - basic TV service implementation; enough to read the GPU state and perform mode changes
  - s/GPUMode - GPU mode change handling.
Admin:
  Tested on Raspberry Pi 1, 2, 3 with old & new firmware


Version 0.40. Tagged as 'BCMVideo-0_40'
@
text
@d64 1
d70 4
d77 7
@


1.17
log
@Fix hang/crash if hardware pointer fails to initialise
Detail:
  s/GraphicsV - Fix bug that would cause GV_UpdatePointer to fall through to GV_SetDMAAddress if hardware pointer support is compiled in but the pointer code failed to initialise (e.g. VCHIQ or RTSupport unavailable)
Admin:
  Tested on Pi 3B


Version 0.38. Tagged as 'BCMVideo-0_38'
@
text
@d57 1
d59 3
d463 1
d468 1
d567 2
@


1.16
log
@Use BCMSupport for mailbox access
Detail:
  hdr/BCM2835reg - Remove mailbox definitions which are now exported by BCMSupport in its header
  s/BCMVideo, s/GraphicsV - Remove manual mailbox access and replace with equivalent calls to BCMSupport. Some tag buffer definitons moved in order to allow Entry macro to reference their size.
Admin:
  Tested on Raspberry Pi 1B, 2B, 3B
  Requires BCMSupport 0.03


Version 0.37. Tagged as 'BCMVideo-0_37'
@
text
@d92 1
a92 1
      |
a93 1
      ]
@


1.15
log
@Remove manual software pointer support. Fix hardware pointer vanishing at X >= 2048 by falling back to kernel software pointer.
Detail:
  s/BCMVideo, s/SWPointer, s/GraphicsV - Remove manual software pointer code. Update GraphicsV code to deal with indicating when kernel software pointer is/isn't needed.
  s/HWPointer - Turn off hardware pointer and return with GraphicsV_UpdatePointer unclaimed if the pointer GPU X coord is >= 2048
Admin:
  Tested on Raspberry Pi
  Fixes pointer vanishing at X >= 2048


Version 0.31. Tagged as 'BCMVideo-0_31'
@
text
@d75 4
a78 1
        BL      SetBlankState
d229 1
d232 1
a232 2
        MOVEQ   r0, #IICStatus_Completed
        Pull    "r3-r8,pc", EQ
d234 1
a234 2
        MBClaim edidtagb, 1
        Push    "r0"
d242 1
a242 1
        Pull    "r0"
d245 7
a251 1
        BL      SendMBMessage
a265 1
        MBFinish
a267 1
        MBFinish
d269 2
@


1.14
log
@  Add Raspberry Pi 2 support
Detail:
  BCMVideo isn't a good citizen in the sense that it has hard-coded knowledge
  of the physical address space rather than asking the HAL, so equivalent
  checks for wether we're running on a Pi 1 or Pi 2 were needed here. There
  was also a significant bug in that BCMVideo wasn't translating ARM physical
  addresses to GPU physical addresses before programming the DMA controller.
  It seems we "got away with it" on Pi 1 at the expense of hammering the
  GPU's L1 cache, but with the different attachment of L2 caches on Pi 2
  due to the presence of the Cortex-A7 CPU, there were major cache coherency
  problems leading to failure to do tiled plots or block-moves.
Admin:
  Tested on Pi 1 and 2.

Version 0.30. Tagged as 'BCMVideo-0_30'
@
text
@d86 2
a87 3
        LDR     r4, HWPActive
        TEQ     r4, #0
        MOV     r4, #0
a89 5
        MOV     r4, #0
      ]
      [ SWPointer
        B       SWP_Update
      |
d114 2
d119 3
a267 8
      [ SWPointer
        ; Remove pointer before any render op
        LDR     r0, SWPAddr
        CMP     r0, #1 ; cursor active?
        ASSERT  GVRender_NOP = 0 ; So HI test works
        CMPHI   r1, #GVRender_NOP ; and not no-op call?
        BLHI    SWP_remove
      ]
@


1.13
log
@Prepare for new Aemulor version
Detail:
  s/BCMVideo, s/GraphicsV - Adjust the AemulorSupport code so that it only activates the compatibility hacks if it detects a version of Aemulor <= 2.34; the plan is for the next released version to contain proper support for the new GraphicsV calls
Admin:
  Tested on Raspberry Pi


Version 0.29. Tagged as 'BCMVideo-0_29'
@
text
@d332 1
a332 1
        Push    "r4-r7"
d338 1
d351 1
d397 1
d412 1
a412 1
        Pull    "r4-r7"
d433 1
a433 1
        Pull    "r4-r7"
@


1.12
log
@Add GraphicsV_ReadInfo implementation
Detail:
  s/GraphicsV - Added GraphicsV_ReadInfo implementation.
  s/BCMVideo - Keep a pointer to the HAL device so that its name can be returned for GVReadInfo_HardwareName
Admin:
  Tested on Raspberry Pi


Version 0.28. Tagged as 'BCMVideo-0_28'
@
text
@d127 1
d130 4
a133 4
        ; colour modes to work correctly when Aemulor is loaded
        MOV     r1, #2_111000
      |
        MOV     r1, #2_101000           ; 8,32bpp supported. 16bpp is RGB565, i.e. 2_RRRRRGGGGGGBBBBB
d465 1
a465 1
        ; Current versions of Aemulor don't know about the new GV_PixelFormats
d468 4
a471 12
        ; GV_DisplayFeatures. To keep these old versions of Aemulor working,
        ; call GV_DisplayFeatures on ourselves to check if we're being
        ; intercepted. If we are, adjust the list of returned modes to include
        ; all the low colour ones
        Push    "r2,r9"
        LDR     r4, GVinstance
        MOV     r9, #GraphicsV
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_DisplayFeatures
        SWI     XOS_CallAVector
        TST     r1, #7                  ; Any of 1, 2, 4bpp supported?
        Pull    "r2,r9"
@


1.11
log
@Remove CMOS check code from GraphicsV_StartupMode
Detail:
  s/BCMVideo, s/GraphicsV - Remove CMOS configured mode check code from GraphicsV_StartupMode. Kernel-5_35-4_79_2_220 now does this check for us.
Admin:
  Tested on Raspberry Pi


Version 0.23. Tagged as 'BCMVideo-0_23'
@
text
@d26 6
d58 2
a59 1
        GVEntry PixelFormats         ; GV_PixelFormats       
d498 69
@


1.10
log
@Only override startup mode if configured mode is set to 'auto'
Detail:
  s/GraphicsV - Only override the startup mode if the CMOS configured mode is 'auto', to allow custom modes set in CMOS to be used
  s/BCMVideo - Remove unnecessary hardware mode change on startup
Admin:
  Tested on Raspberry Pi


Version 0.22. Tagged as 'BCMVideo-0_22'
@
text
@d451 3
a453 10
        Push    "r0-r2"
        ; Only override if the configured default is set to Auto
        MOV     r0, #OsByte_ReadCMOS
        MOV     r1, #Mode2CMOS
        SWI     XOS_Byte
        TST     r2, #WimpModeAutoBit
        Pull    "r0-r2,lr"
        ADRNEL  r0, startupmode
        MOVNE   r4, #0
        MOV     pc, lr
@


1.9
log
@Advertise GVRender_CopyRectangle as being fast
Detail:
  s/GraphicsV - Update GraphicsV_DisplayFeatures implementation to flag that CopyRectangle is fast, so that OS_SpriteOp 65 will prefer to use it over rendering all the sprite tiles manually
Admin:
  Untested, but will be soon
  Requires Kernel-5_35-4_79_2_210


Version 0.20. Tagged as 'BCMVideo-0_20'
@
text
@d451 10
a460 3
        ADRL    r0, startupmode
        MOV     r4, #0
        Pull    "pc"
@


1.8
log
@Add support for GraphicsV_IICOp (EDID reading only)
Detail:
  hdr/BCM2835reg, s/BCMVideo - Add definition for the EDID read messagebox tag
  s/GraphicsV - Add an implementation of GraphicsV_IICOp which uses the message box interface to request EDID blocks from the GPU as required
Admin:
  Tested on Raspberry Pi


Version 0.16. Tagged as 'BCMVideo-0_16'
@
text
@d111 1
a111 1
        MOV     r0, #GVDisplayFeature_InterlaceWithProgressiveFramestore+GVDisplayFeature_SeparateFramestore+GVDisplayFeature_VariableFramestore
@


1.7
log
@Add compatibility code for Aemulor's low colour mode emulation
Detail:
  s/BCMVideo, s/GraphicsV - Add a compatibility hack to detect if Aemulor is intercepting our GraphicsV calls, and if so, include 1-4bpp in the list of pixel formats we claim we support. This is enough to get the low colour mode emulation of existing Aemulor versions working again with the recent GraphicsV changes. The code can easily be disabled in the future once it's no longer needed.
Admin:
  Tested on Raspberry Pi with and without Aemulor Pro 2.34 loaded
  Some issues with mode changes still remain - e.g. switching to 1920x1080x8bpp then back to 1920x1080x32bpp causes screen to be offset and wrapped. Other mode change problems have also been observed without Aemulor loaded - to be investigated.


Version 0.15. Tagged as 'BCMVideo-0_15'
@
text
@d49 1
a49 1
        Pull    "pc"                 ; GV_IICOp                
d204 53
a256 5
; R0= 0(off)or 1(on)
GV_SetInterlace
;        BL      DoSetInterlace
;        MOV     r4, #0
        Pull    "pc"
a257 4
GV_IICOp
;        BL      DoI2COp
;        MOV     r4, #0
        Pull    "pc"
@


1.6
log
@Update to use new GraphicsV registration process. Add 64K colour mode support.
Detail:
  s/BCMVideo - Remove unnecessary 'modedefbuf' in workspace. Use new GraphicsV driver registration process. Remove local defintion of VIDC list structure, use Hdr:VIDCList instead. Improve mode vetting to check list type, pixel format, and ExtraBytes control list entry.
  s/GraphicsV - Only respond to our driver number. Implement StartupMode call (previously in HAL). Implement PixelFormats call so that we can advertise support for 64K colour modes.
  s/SWPointer - Update 16bpp software pointer handling to assume 64K instead of 32K mode
Admin:
  Tested in BCM2835 ROM
  Requires HdrSrc-2_38 and Kernel-5_35-4_79_2_203


Version 0.14. Tagged as 'BCMVideo-0_14'
@
text
@d120 5
d126 1
d412 17
d431 3
d441 5
@


1.5
log
@Add support for multiple screen banks. Improve mailbox handling to allow IRQs to be enabled while waiting for response.
Detail:
  s/BCMVideo:
  - Reworked mailbox handling to allow IRQs to be enabled while waiting for a response. If an attempt is made to send another message while still waiting for the first, the code will detect that a message is currently outstanding and will wait for the first to complete before claiming use of the shared message buffer. This has had a big impact on our IRQ latency, as it looks like the GPU waits until the end of each frame until processing framebuffer mailbox messages.
  - Added support for multiple screen banks. The GPU allows us to allocate a framebuffer which is larger than the area which is displayed on screen, and specify the X,Y offset of the displayed area. However because it works in texel coordinates instead of byte offsets, it means we're limited to vertical scrolling only, unlike the (potentially partial) horizontal scrolling support on other platforms. Several constraints are used to decide how many screen banks to try and allocate.
  - Added a BCMVideo$ScreenBanksEnabled system variable. If set to '0' it will disable screen banks on the next mode change. Any other value (including unset) enables them. This is a (potentially temporary) compatability option for use with old games; the fact that switching screen bank requires the driver to wait until the next VSync (while waiting for the GPU response) means that having screen banks enabled may have a significant framerate impact
  s/GraphicsV:
  - Screen bank support.
  - Allow GraphicsV_Render debug output to be turned off seperately of main debug switch.
  s/SWPointer:
  - Modified to work properly with screen banks.
Admin:
  Tested on Raspberry Pi
  Fixes flickering HUD in Star Fighter 3000
  Mailbox handling changes fix keyboard dying in Zool, however slow operation of screen bank switching means that you'll want screen banks disabled to be able to run at full frame rate.


Version 0.10. Tagged as 'BCMVideo-0_10'
@
text
@d29 4
a32 6
;        LDRB    lr, instance         ; may need another if more than 1 graphics module
;        TEQ     lr, R4, LSR #24      ; our display?
;        Pull    "pc", NE
        BIC     r4, r4, #&ff000000   ; clear display number
        CMP     r4, #(GraphicsV_TableEnd - GraphicsV_Table) / 4
        ADDLO   pc, pc, r4, LSL #2
d38 1
a38 1
       Pull    "pc";     GVEntry SetInterlace         ; GV_SetInterlace            
d47 1
a47 1
        Pull    "pc"                 ;                            
d49 4
a52 2
       Pull    "pc";      GVEntry IICOp                ; GV_IICOp                
       Pull    "pc";      GVEntry SelectHead           ; GV_SelectHead       
d111 1
a111 6
        MOV     r0, #2_101100           ; 100000 .. Framestore does Mem Alloc
                                        ; 010000 .. Doesn't generate VSync IRQ
                                        ; 001000 .. separate frame buffer
                                        ; 000100 .. interlace w progressive fb
                                        ; 000010 .. have hardware pointer
                                        ; 000001 .. hardware scroll
d115 1
a115 1
        ORRNE   r0, r0, #2_10
d119 1
a119 4
        ORREQ   r0, r0, #2_10000
  [ {FALSE}
        MOV     r1, #2_111000           ; 8,16,32bpp supported
  |
a120 1
  ]
d400 16
@


1.4
log
@Add GraphicsV_Render implementation. Allow utilisation of new fake_vsync_isr config.txt option for generating VSync interrupts.
Detail:
  hdr/DMA, s/BCMVideo, s/GraphicsV - Added GraphicsV_Render implementation. Uses one of the 2D-capable DMA channels to accelerate block copies/moves. Rectangle fill acceleration currently not supported.
  hdr/BCM2835reg, s/BCMVideo, s/GraphicsV - Add code to detect whether the new fake_vsync_isr firmware option (https://github.com/raspberrypi/firmware/issues/67) is enabled and if so, use it as our VSync IRQ source.
  s/HWPointer - Add toggle for hardware pointer debug to reduce debug spam
Admin:
  Tested on Raspberry Pi with high processor vectors & various firmware versions


Version 0.07. Tagged as 'BCMVideo-0_07'
@
text
@d17 2
d105 2
d231 1
a231 1
      [ Debug
d250 1
a250 1
      [ Debug
d262 1
a262 1
      [ Debug
d291 1
a291 1
        LDR     r5, mbyvres
d306 1
a306 1
      [ Debug
d387 1
a387 1
      [ Debug
d402 1
a402 1
      [ Debug
@


1.3
log
@Add support for GraphicsV_SetBlank
Detail:
  s/BCMVideo, s/GraphicsV - Added support for GraphicsV_SetBlank, via simple mailbox message
Admin:
  Tested on Raspberry Pi


Version 0.06. Tagged as 'BCMVideo-0_06'
@
text
@d41 1
a41 1
       Pull    "pc";     GVEntry SetDMAAddress        ; GV_SetAddress              
d91 13
d107 1
a107 1
        MOV     r0, #2_111100           ; 100000 .. Framestore does Mem Alloc
d118 3
d215 1
a217 1
        Push    "r0"
d220 2
a221 1
        CMPHI   r1, #0 ; and not no-op call?
a222 1
        Pull    "r0"
d224 41
a264 1
        Pull    "pc"
d266 138
@


1.2
log
@Add hardware pointer support
Detail:
  s/HWPointer, s/BCMVideo, s/GraphicsV - Added hardware pointer support, using VCHIQ to talk to the VC-side dispmanx service. Software pointer will automatically disable itself once the hardware pointer is activated by VCHIQ being loaded.
  s/SWPointer, s/BCMVideo - Renamed software pointer routines & variables to have 'SWP' prefix to more easily differentiate them from the 'HWP' hardware pointer routines/variables
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.05. Tagged as 'BCMVideo-0_05'
@
text
@d39 1
a39 1
       Pull    "pc";     GVEntry SetBlank             ; GV_SetBlank                
d66 1
a66 1
;        BL      SetBlankState
@


1.1
log
@First working version of video driver
Detail:
  This version of the driver supports 8bpp & 32bpp screen modes, and uses a software mouse pointer.
  Startup mode is forced to 1080p, 32bpp (via code in the HAL). After that, RISC OS is free to do as it pleases.
  Makefile, s/BCMVideo - Added Castle licence text
  Resources/RPIMon - Simple MDF that gets loaded on startup. Contains simple 1080p & 720p mode definitions, plus copies of definitions for numbered modes from AKF50 MDF (to ensure RISC OS doesn't freak out due to not having any fallback modes available)
  s/BCMVideo - Main bulk of video driver
  s/Debug - Debug routines
  s/GraphicsV - GraphicsV handler
  s/SWPointer - Basic software mouse pointer implementation
Admin:
  Tested on Raspberry Pi with high processor vectors
  Still a few rough edges to iron out, but code seems stable enough


Version 0.03. Tagged as 'BCMVideo-0_03'
@
text
@a74 1
 [ :LNOT: SWPointer
d76 3
d80 7
d88 1
a88 1
 ]
d100 5
d110 1
a110 1
        MOV     r2, #4                  ; framestore must be word aligned
a152 1
      [ SWPointer
d155 2
a173 1
      [ SWPointer
d177 3
d185 1
a185 3
        Pull    "r0,r3"
      ]
        Pull    "pc" 
d202 1
a202 1
        LDR     r0, CurAddr
d205 1
a205 1
        BLHI    cur_remove
@


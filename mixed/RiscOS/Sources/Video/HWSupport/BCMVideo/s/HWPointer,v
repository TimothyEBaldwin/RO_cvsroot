head	1.12;
access;
symbols
	BCMVideo-0_53:1.12
	BCMVideo-0_52:1.12
	BCMVideo-0_51:1.12
	BCMVideo-0_50-1_50_2_1:1.11
	RPiFreeze:1.11.0.2
	BCMVideo-0_50:1.11
	BCMVideo-0_49:1.11
	BCMVideo-0_48:1.11
	BCMVideo-0_47:1.11
	BCMVideo-0_46:1.11
	BCMVideo-0_45:1.11
	BCMVideo-0_44:1.11
	BCMVideo-0_43:1.11
	BCMVideo-0_42:1.11
	BCMVideo-0_41:1.10
	BCMVideo-0_40:1.10
	BCMVideo-0_39:1.9
	BCMVideo-0_38:1.9
	BCMVideo-0_37:1.9
	BCMVideo-0_36:1.9
	BCMVideo-0_35:1.8
	BCMVideo-0_34:1.8
	BCMVideo-0_33:1.8
	BCMVideo-0_32:1.8
	BCMVideo-0_31:1.8
	BCMVideo-0_30:1.7
	BCMVideo-0_29:1.7
	BCMVideo-0_28:1.7
	BCMVideo-0_27:1.7
	BCMVideo-0_26:1.7
	BCMVideo-0_25:1.6
	BCMVideo-0_24:1.6
	BCMVideo-0_23:1.6
	BCMVideo-0_22:1.6
	BCMVideo-0_21:1.6
	BCMVideo-0_20:1.5
	BCMVideo-0_19:1.5
	BCMVideo-0_18:1.5
	BCMVideo-0_17:1.5
	BCMVideo-0_16:1.4
	BCMVideo-0_15:1.4
	BCMVideo-0_14:1.4
	BCMVideo-0_13:1.4
	BCMVideo-0_12:1.4
	BCMVideo-0_11:1.3
	BCMVideo-0_10:1.3
	BCMVideo-0_09:1.3
	BCMVideo-0_08:1.2
	BCMVideo-0_07:1.2
	BCMVideo-0_06:1.1
	BCMVideo-0_05:1.1;
locks; strict;
comment	@# @;


1.12
date	2018.07.01.12.32.41;	author jlee;	state Exp;
branches;
next	1.11;
commitid	SZDeyIEUJXdXNqIA;

1.11
date	2016.12.17.18.39.05;	author jlee;	state Exp;
branches;
next	1.10;
commitid	orkqjr7mp7qGRmyz;

1.10
date	2016.12.10.17.01.54;	author jlee;	state Exp;
branches;
next	1.9;
commitid	zybtuuARus1hysxz;

1.9
date	2016.03.01.23.10.17;	author jlee;	state Exp;
branches;
next	1.8;
commitid	k7925edZelBCIZWy;

1.8
date	2015.07.10.20.33.44;	author jlee;	state Exp;
branches;
next	1.7;
commitid	gEvIKFBh5s2gpMsy;

1.7
date	2014.06.26.20.43.39;	author jlee;	state Exp;
branches;
next	1.6;
commitid	AAbshADtMl3ZD4Gx;

1.6
date	2014.04.07.20.52.01;	author jlee;	state Exp;
branches;
next	1.5;
commitid	8RkD9LAg1kJhgNvx;

1.5
date	2014.01.19.17.26.19;	author jlee;	state Exp;
branches;
next	1.4;
commitid	IgO3YUZfWktaDKlx;

1.4
date	2013.03.03.20.26.48;	author jlee;	state Exp;
branches;
next	1.3;
commitid	JslUsC5BVloNYnGw;

1.3
date	2012.10.16.23.46.55;	author jlee;	state Exp;
branches;
next	1.2;
commitid	oKsn0n3zdXitwFow;

1.2
date	2012.09.18.13.55.49;	author jlee;	state Exp;
branches;
next	1.1;
commitid	Apt88JppQEvt91lw;

1.1
date	2012.09.07.01.05.06;	author jlee;	state Exp;
branches;
next	;
commitid	sA7cjtQbUOm0fxjw;


desc
@@


1.12
log
@Add support for the GraphicsV overlay API and alpha-blended screen modes. Allow gamma table use to be disabled via adding 'disable_gamma' to cmdline.txt
Detail:
  s/BCMVideo - Update workspace for the new features. On startup, check to see if 'disable_gamma' is included in the firmware-managed kernel command line (i.e. from cmdline.txt in the bootloader partition), and if so disable all use of the hardware gamma tables. Update mode vet & set to allow alpha-blending in 32bpp modes.
  s/Dispmanx, s/HWPointer - Move the dispmanx-related routines out of s/HWPointer and into their own file, for re-use by the GraphicsV overlay code
  s/GPUMode - Move the command line scanning code into s/BCMVideo so it's still available if the GPUMode build switch is disabled
  s/GenCmd - Tweak how GenCmd_GetConfigInt returns values so that zero-value variables can be distinguished from errors. Check the framebuffer_ignore_alpha variable to determine if the GPU will pay attention to the FBSetAlphaMode property tag.
  s/GraphicsV - Hook up the GraphicsV overlay entries. Fix determination of whether hardware pointer is fully supported to also check the screen height.
  s/GVOverlay - Initial support for the GraphicsV hardware overlay API. It's best used in 32bpp alpha-blended screen modes, so that the overlays can be placed behind the desktop. Rotated/flipped overlays aren't supported yet.
Admin:
  Tested on Raspberry Pi 1 & 3
  Requires BCMSupport-0_08
  disable_gamma should allow people who are frequently affected by https://www.riscosopen.org/forum/forums/11/topics/10346 to use their systems, pending a proper fix once the root cause has been determined.
  Note that options in cmdline.txt should be space-separated, so to disable both GPU mode changes & gamma table use you'll want 'disable_gamma disable_mode_changes'.


Version 0.51. Tagged as 'BCMVideo-0_51'
@
text
@; Copyright 2012 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        GBLL    HWPDebug
HWPDebug SETL   Debug :LAND: {FALSE}

        GBLL    HiDebug
HiDebug SETL    Debug :LAND: {FALSE}        

HWP_Init    ROUT
        Entry   "r0-r7"
        ; Ensure dispmanx is initialised
        BL      Dispmanx_Init
        LDR     r0, DispManServiceC
        CMP     r0, #0
        EXIT    EQ
        ; Create resource
        MOV     r0, #EDispmanResourceCreate
        MOV     r1, #Format_ARGB8888
        MOV     r2, #32
        MOV     r3, #32
        STMDB   sp!, {r0-r3}
        MOV     r0, #16
        BL      Dispmanx_Send
        ADD     sp, sp, #16
        FRAMSTR r0,VS
        EXIT    VS
        STR     r0, HWPResource
      [ HWPDebug
        bl DebugTXStrInline
        DCB "HWP_Init OK",10,13,0
        ALIGN
      ]  
        ; Mark as available
        MOV     r0, #0
        STR     r0, RTActive
        MOV     r0, #1
        STRB    r0, HWPPalDirty ; Just to make sure initial image gets sent
        STR     pc, RTDead
        STR     pc, HWPActive
        CLRV
        EXIT

HWP_Finalise ROUT
        Entry   "r0-r7"
        LDR     r0, DispManServiceC
        CMP     r0, #0
        EXIT    EQ
      [ HWPDebug
        bl DebugTXStrInline
        DCB "HWP_Finalise",10,13,0
        ALIGN
      ]
        ; Disable pointer
        LDR     r0, HWPActive
        CMP     r0, #0
        MOV     r0, #0
        STRNE   r0, HWPActive
        BLNE    HWP_Remove
        ; Wait for RTSupport thread to terminate
        ADR     r1, RTDead
        BL      WaitForR1
        ; Release resources
        MOV     r0, #EDispmanResourceDelete
        LDR     r1, HWPResource
        STMDB   sp!, {r0-r1}
        MOV     r0, #8
        BL      Dispmanx_Send
        ADD     sp, sp, #8
        ; Done
      [ HWPDebug
        bl DebugTXStrInline
        DCB "HWP_Finalise OK",10,13,0
        ALIGN
      ]  
        EXIT

HWP_Update  ROUT
        ; Wrapper to make sure we're not in IRQ mode during SWI calls
        Push    "r5"
        MRS     r5, CPSR
        MSR     CPSR_c, #SVC32_mode + I32_bit
        Push    "lr"
        BL      %FT01
        Pull    "lr"
        MSR     CPSR_c, r5
        Pull    "r5,pc"
01
        TST     r0, #1
        MOVEQ   r4, #0 ; Claim GraphicsV call
        BEQ     HWP_Remove
        ; Enable/update cursor
        Entry   "r0-r7"
      [ HiDebug
        bl DebugHexTX4
        bl DebugTXStrInline
        DCB "HWP_Update",10,13,0
        ALIGN
      ]  
        ; Start by copying update data into workspace
        STR     r1, HWPXCoord
        STR     r2, HWPYCoord
        LDRB    r1, HWPPalDirty
        TST     r0, #2 ; Shape updated?
        TEQEQ   r1, #0 ; Palette changed?
        MOV     r0, #0
        STRB    r0, HWPPalDirty
        BEQ     %FT50
        LDR     r0, HWPImage
        ADR     r1, CurPalette
        LDRB    r2, [r3, #1] ; Get height
        ADD     r4, r0, #32*32*4
        TEQ     r2, #0
        BEQ     %FT30
        LDR     r3, [r3, #4] ; Get image
        ; To avoid fringing caused by alpha blending, we fill all transparent pixels with the value of the last non-transparent pixel (just with an alpha of 0 instead of 1)
        ; For the first block of pixels we merely use the first non-transparent palette entry, which is conveniently the light blue of the standard cursor image
        LDR     r7, [r1, #4]
        REV     r7, r7
10
        LDR     r5, =&88888888
        LDRB    r6, [r3], #1
20
        ANDS    lr, r6, #3
        LDRNE   r7, [r1, lr, LSL #2]
        REVNE   r7, r7
        ORRNE   r7, r7, #&ff000000
        BICEQ   r7, r7, #&ff000000
        STR     r7, [r0], #4
        MOV     r6, r6, LSR #2
        MOVS    r5, r5, LSR #1
        LDRHIB  r6, [r3], #1
        BNE     %BT20
        SUBS    r2, r2, #1
        BNE     %BT10
30
        BIC     r1, r7, #&ff000000
        BIC     r2, r7, #&ff000000
        BIC     r3, r7, #&ff000000
        BIC     r5, r7, #&ff000000
40
        TEQ     r0, r4
        STMNEIA r0!, {r1,r2,r3,r5}
        BNE     %BT40
        MOV     r0, #1
        STRB    r0, HWPImgDirty
50
        ; The pointer will fail to display if the GPU X coord is >= 2048
        ; If the pointer is outside the valid area, disable it and indicate to
        ; the OS that the software pointer should be used (by not claiming the
        ; GraphicsV call)
        LDR     r0, DisplayWidth
        CMP     r0, #2048
        BLE     %FT60 ; Mode not big enough to require software pointer
        SUB     sp, sp, #32
        MOV     r0, sp
        ADD     r1, sp, #16
        BL      HWP_CalcCursorPos ; Calculate GPU coords
        LDMIA   sp, {r0-r1}
        ADD     sp, sp, #32
        CMP     r0, #2048
        MOVGE   r0, #0
        BGE     %FT70
60
        ; Turn pointer on and claim the GraphicsV call
        MOV     r0, #0
        STR     r0, [sp, #4*4]
        MOV     r0, #1
70
        BL      HWP_KickRTSupport
      [ HiDebug
        bl DebugTXStrInline
        DCB "HWP_Update OK",10,13,0
        ALIGN
      ]  
        EXIT

HWP_Remove  ROUT
        Entry   "r0-r7"
      [ HiDebug
        bl DebugTXStrInline
        DCB "HWP_Remove",10,13,0
        ALIGN
      ]  
        ; Disable pointer & kill RTSupport
        MOV     r0, #0
        BL      HWP_KickRTSupport
        EXIT

HWP_KickRTSupport
        ; In: r0 = 1 if RTSupport should be alive (cursor visible), 0 for dead (cursor invisible)
        ; Out: r0-r7 corrupt
        Entry
      [ HiDebug
        bl DebugHexTX4
        bl DebugTXStrInline
        DCB "HWP_KickRTSupport",10,13,0
        ALIGN
      ]  
        MRS     r5, CPSR
        ORR     r4, r5, #I32_bit
        MSR     CPSR_c, r4
        STRB    r0, HWPVisible
        LDR     r1, RTDead
        CMP     r0, #0
        BEQ     %FT20
        CMP     r1, #0
        BNE     %FT10
        ; It's alive and we want it to be alive. Kick it if necessary.
05
      [ HiDebug
        bl DebugTXStrInline
        DCB "->kick",10,13,0
        ALIGN
      ]  
        LDR     r1, RTActive
        STR     pc, RTActive
        MSR     CPSR_c, r5
        CMP     r1, #0
        ADREQL  r1, pollword_1
        SWIEQ   XRT_Yield
        EXIT
10
        ; It's not alive. Create it.
      [ HiDebug
        bl DebugTXStrInline
        DCB "->create",10,13,0
        ALIGN
      ]  
        MOV     r0, #0
        ADR     r1, HWP_RTRoutine
        MOV     r2, #0
        MOV     r3, r12
        ADR     r4, RTActive
        ADRL    r6, RTStack+?RTStack
        ADRL    r7, RTPriority
        SWI     XRT_Register
        STRVC   r0, RTHandle
        STRVC   r2, RTDead
        MSR     CPSR_c, r5
        EXIT
20
        CMP     r1, #0
        BEQ     %BT05 ; It's alive and we want it to be dead. Kick it if necessary.
        ; It's dead and we want it to be dead
        MSR     CPSR_c, r5
        EXIT        

HWP_RTRoutine   ROUT
        Entry   , 128
        ; Disable IRQs while we work out what to do
        MRS     r9, CPSR
        ORR     r0, r9, #I32_bit
        MSR     CPSR_c, r0
01
        MOV     r0, #0
        STR     r0, RTActive
        LDRB    r1, HWPImgDirty
        STRB    r0, HWPImgDirty
        LDRB    r0, HWPVisible
        MSR     CPSR_c, r9
      [ HWPDebug
        Push "r0"
        bl DebugHexTX4
        MOV r0, r1
        bl DebugHexTX4
        Pull "r0"
        bl DebugTXStrInline
        DCB "HWP_RTRoutine",10,13,0
        ALIGN
      ]  
        CMP     r0, #0
        BEQ     %FT40
        ; Update image if necessary
        CMP     r1, #0
        BEQ     %FT10
        MOV     r0, #EDispmanBulkWrite + NoReply
        LDR     r1, HWPResource
        MOV     r2, #0
        MOV     r3, #32*32*4
        STMIA   sp, {r0-r3}
        MOV     r0, #16
        BL      Dispmanx_Send
        BVS     %FT10
        LDR     r0, DispManServiceC
        SWI     XVCHIQ_ServiceUse
        BVS     %FT10
        LDR     r0, DispManServiceC
        LDR     r1, HWPImage
        MOV     r2, #32*32*4
        MOV     r3, #VCHI_FLAGS_BLOCK_UNTIL_QUEUED ; VCHI_FLAGS_BLOCK_UNTIL_DATA_READ
        MOV     r4, #0
        SWI     XVCHIQ_BulkQueueTransmit
        LDR     r0, DispManServiceC
        SWI     XVCHIQ_ServiceRelease
10
        ; Set position by adding/updating element
        MOV     r0, #EDispmanUpdateStart
        MOV     r1, #10
        STMIA   sp, {r0-r1}
        MOV     r0, #8
        BL      Dispmanx_Send
        BVS     %FT30
        MOV     r8, r0
        LDRB    r0, HWPIsVisible
        CMP     r0, #0
        BNE     %FT20
        ; Add element
        MOV     r0, #EDispmanElementAdd
        MOV     r1, r8
        LDR     r2, DispHandle
        MOV     r3, #Depth_Pointer
        STMIA   sp, {r0-r3}
        LDR     r0, HWPResource
        STR     r0, [sp, #32]
        MOV     r1, #0
        STR     r1, [sp, #52] ; protection
        STR     r1, [sp, #56] ; src alpha
        STR     r1, [sp, #60] ; opacity
        STR     r1, [sp, #64] ; mask image
        STR     r1, [sp, #68] ; clamp mode
        STR     r1, [sp, #72] ; clamp key mask
        STR     r1, [sp, #76] ; yy_upper
        STR     r1, [sp, #80] ; yy_lower
        STR     r1, [sp, #84] ; cr_upper
        STR     r1, [sp, #88] ; cr_lower
        STR     r1, [sp, #92] ; cb_upper
        STR     r1, [sp, #96] ; cb_lower
        STR     r1, [sp, #100] ; replace_balue
        STR     r1, [sp, #104] ; transform
        ADD     r0, sp, #16 ; dest rect
        ADD     r1, sp, #36 ; src rect
        BL      HWP_CalcCursorPos
        MOV     r0, #108
        BLVC    Dispmanx_Send
        STRVC   r0, HWPElement
        MOVVC   r0, #1
        STRVCB  r0, HWPIsVisible
        B       %FT30
20
        ; Move existing element
        MOV     r0, #EDispmanElementChangeAttributes + NoReply
        MOV     r1, r8
        LDR     r2, HWPElement
        MOV     r3, #1<<2+(1<<3)
        MOV     r4, #0 ; layer
        MOV     r5, #0 ; opacity
        MOV     r6, #0 ; mask
        MOV     r7, #0 ; transform
        STMIA   sp, {r0-r7}
        ADD     r0, sp, #32 ; dest rect
        ADD     r1, sp, #48 ; src rect
        BL      HWP_CalcCursorPos
        BVS     %FT35
        MOV     r0, #64
        BL      Dispmanx_Send
30
        MOV     r0, #EDispmanUpdateSubmit
        MOV     r1, r8
        STMIA   sp, {r0-r1}
        MOV     r0, #8
        BL      Dispmanx_Send
        ; Done; go back to sleep
      [ HWPDebug
        bl DebugTXStrInline
        DCB "HWP_RTRoutine sleep",10,13,0
        ALIGN
      ]
        MOV     r0, #0  
        EXIT

35
        ; Invalid position: Remove image and go to sleep
        MOV     r0, #EDispmanElementRemove + NoReply
        MOV     r1, r8
        LDR     r2, HWPElement
        STMIA   sp, {r0-r2}
        MOV     r0, #12
        BL      Dispmanx_Send
        MOV     r0, #0
        STRB    r0, HWPIsVisible
        B       %BT30

40
        ; Remove image and kill ourselves
        LDRB    r0, HWPIsVisible
        CMP     r0, #0
        BEQ     %FT60
        MOV     r0, #EDispmanUpdateStart
        MOV     r1, #10
        STMIA   sp, {r0-r1}
        MOV     r0, #8
        BL      Dispmanx_Send
        BVS     %FT50
        MOV     r8, r0
        MOV     r0, #EDispmanElementRemove + NoReply
        MOV     r1, r8
        LDR     r2, HWPElement
        STMIA   sp, {r0-r2}
        MOV     r0, #12
        BL      Dispmanx_Send
50
        MOV     r0, #EDispmanUpdateSubmit
        MOV     r1, r8
        STMIA   sp, {r0-r1}
        MOV     r0, #8
        BL      Dispmanx_Send
        MOV     r0, #0
        STRB    r0, HWPIsVisible
60
        ; Foreground usually doesn't synchronise when it requests us to die
        ; This means the death message may have been cancelled
        ; So disable IRQs and double check that we're still meant to be dead
        ORR     r0, r9, #I32_bit
        MSR     CPSR_c, r0
        LDRB    r0, HWPVisible
        CMP     r0, #0
        BNE     %BT01 ; Yes, stay alive
        ; No, die
      [ HWPDebug
        bl DebugTXStrInline
        DCB "HWP_RTRoutine die",10,13,0
        ALIGN
      ]  
        STR     pc, RTDead
        MOV     r0, #0
        STR     r0, RTActive
        STR     r0, RTHandle
        SWI     XRT_ReadInfo ; Get our handle (although RTHandle should have been accurate?)
        MOV     r1, r0
        MOV     r0, #0
        SWI     XRT_Deregister
        ; If we're still alive, something is very wrong. Just crash horribly.
        UND     #0

HWP_CalcCursorPos ROUT
        ; In: r0 = dest rect ptr (x, y, w, h in pixels)
        ;     r1 = src rect ptr (x, y, w, h in 1/65536th pixels)
        ; Out: r0-r6 corrupt
        ;     V set if position invalid
        LDR     r2, HWPXCoord
        LDR     r3, XScale
        LDR     r4, XOffset
        ; Write out dest rect
        MUL     r2, r3, r2
        ADD     r4, r4, r2, ASR #16
        STR     r4, [r0, #0]
        MOV     r5, r3, LSR #16-5 ; 32 pixels
        STR     r5, [r0, #8]
        STR     r5, [r0, #12]
        ; Check if off right edge of screen
        LDR     r3, DisplayWidth
        CMP     r4, r3
        BGE     %FT90
        LDR     r5, HWPYCoord
        LDR     r3, YScale
        LDR     r4, YOffset
        MUL     r5, r3, r5
        ADD     r4, r4, r5, ASR #16
        STR     r4, [r0, #4]
        ; Check if off bottom of screen
        LDR     r2, DisplayHeight
        CMP     r4, r2
        BGE     %FT90
        ; Write out src rect
        ; TODO - use sub-pixel offsets to make sure the image lines up with the correct pixels below
        MOV     r2, #0
        MOV     r6, #32<<16
        STR     r2, [r1, #0]
        STR     r2, [r1, #4]
        STR     r6, [r1, #8]
        STR     r6, [r1, #12]
        ; Clamp Y coord to 0; negative Y causes the cursor to vanish completely. Negative X seems fine.
        CMP     r4, #0
        BGE     %FT10
        LDR     r3, [r0, #12]
        ADDS    r3, r3, r4
        BLE     %FT90 ; Don't do anything if it's fully off screen (if we clamp the height to <1, it'll just end up being displayed scaled up to fit the screen. doh!)
        LDR     r5, YInvScale
        RSB     r4, r4, #0
        MUL     r4, r5, r4
        SUBS    r6, r6, r4
        BLE     %FT90 ; Paranoia - Don't clamp if src height becomes <=0 either (not sure whether it's the src height or dest height that's the problem)
        STR     r2, [r0, #4] ; Clamp dest y
        STR     r3, [r0, #12] ; Reduce dest height
        STR     r4, [r1, #4] ; Offset src y
        STR     r6, [r1, #12] ; Reduce src height
10
        ; Check if completely off left edge of screen
        LDR     r2, [r0, #0]
        LDR     r3, [r0, #8]
        ADDS    r2, r2, r3
        BLE     %FT90
        CLRV
        MOV     pc, lr

90
        ; We've arrived here because the image is fully off-screen
        ; Avoid trying to display it, it can cause issues on some firmware
        ; (e.g. 30 Mar 2014 - large pointer filling screen if off left edge,
        ; or large square of colours if off top edge)
        SETV
        MOV     pc, lr

        LTORG

        END
@


1.11
log
@Disable hardware pointer if the display is rotated
Detail:
  s/HWPointer - The GPU seems to struggle when dealing with a rotated hardware pointer, and there seem to be a couple of bugs for if we supply the pointer at the correct rotation, so make things easier and just fall back to a software pointer if there's any rotation going on.
  s/BCMVideo - Initialise VCGenCmd prior to the hardware pointer so HWP_Init can detect rotated displays
Admin:
  Tested on Raspberry Pi


Version 0.42. Tagged as 'BCMVideo-0_42'
@
text
@a21 34
; Message IDs
EDispmanNoFunction              * 0
EDispmanGetDevices              * 1
EDispmanGetModes                * 2
EDispmanResourceCreate          * 3
EDispmanResourceCreateFromImage * 4
EDispmanResourceDelete          * 5
EDispmanResourceGetData         * 6
EDispmanResourceGetImage        * 7
EDispmanDisplayOpen             * 8
EDispmanDisplayOpenMode         * 9
EDispmanDisplayOpenOffscreen    * 10
EDispmanDisplayReconfigure      * 11
EDispmanDisplaySetDestination   * 12
EDispmanDisplaySetBackground    * 13
EDispmanDisplayGetInfo          * 14
EDispmanDisplayClose            * 15
EDispmanUpdateStart             * 16
EDispmanUpdateSubmit            * 17
EDispmanUpdateSubmitSync        * 18
EDispmanElementAdd              * 19
EDispmanElementModified         * 20
EDispmanElementRemove           * 21
EDispmanElementChangeSource     * 22
EDispmanElementChangeLayer      * 23
EDispmanElementChangeAttributes * 24
EDispmanResourceFill            * 25
EDispmanQueryImageFormats       * 26
EDispmanBulkWrite               * 27
EDispmanBulkRead                * 28
EDispmanDisplayOrientation      * 29
EDispmanSnapshot                * 30
NoReply                         * (1<<31)

d23 3
a25 1
        Entry   "r0-r7", VCHIQ_Service_Size
d28 1
a28 79
        ; The GPU can struggle with rotated displays. Apart from the extra load
        ; that the rotation places on it, there are also some problems with how
        ; dispmanx overlays are mapped.
        ; E.g. with 90 degree rotation if we use a standard hardware pointer
        ; then there'll often be screen corruption when moving the mouse to the
        ; bottom of the screen.
        ; If we pre-rotate the hardware pointer then it appears to display OK,
        ; but there appears to be an odd clipping rectangle which will cause
        ; the pointer to vanish near the top of the screen.
        ; So if we've got any rotation at all, play it safe and fall back to a
        ; software pointer.
        LDREQ   r0, DisplayRotate
        CMPEQ   r0, #0
        EXIT    NE
      [ HWPDebug
        bl DebugTXStrInline
        DCB "HWP_Init",10,13,0
        ALIGN
      ]
        ; Register with VCHIQ
        BL      VCHIQInit
        MOVVS   r7, r0
        BVS     %FT90
        ; Create services
        MOV     r0, #1
        STR     r0, [sp, #VCHIQ_Service_Version]
        STR     r0, [sp, #VCHIQ_Service_Version_Min]
        LDR     r0, =&44495350 ; 'DISP'
        STR     r0, [sp, #VCHIQ_Service_Id]
        MOV     r0, #0
        STR     r0, [sp, #VCHIQ_Service_Reserved]
        STR     r0, [sp, #VCHIQ_Service_RxFifoSize]
        STR     r0, [sp, #VCHIQ_Service_TxFifoSize]
        ADR     r1, HWP_ClientCallback
        STR     r1, [sp, #VCHIQ_Service_Callback]
        STR     r0, [sp, #VCHIQ_Service_CallbackParam]
        STR     r0, [sp, #VCHIQ_Service_WantUnalignedBulkRx]
        STR     r0, [sp, #VCHIQ_Service_WantUnalignedBulkTx]
        STR     r0, [sp, #VCHIQ_Service_WantCRC]
        LDR     r0, VCHIQInstance
        MOV     r1, sp
        SWI     XVCHIQ_ServiceOpen
        MOVVS   r7, r0
        BVS     %FT89
        STR     r0, DispManServiceC
        LDR     r0, =&55504448 ; 'UPDH'
        STR     r0, [sp, #VCHIQ_Service_Id]
        ADR     r0, HWP_NotifyCallback
        STR     r0, [sp, #VCHIQ_Service_Callback]
        LDR     r0, VCHIQInstance
        SWI     XVCHIQ_ServiceOpen
        MOVVS   r7, r0
        BVS     %FT88
        STR     r0, DispManServiceN
        ; Release services (message functions will 'use' them again)
        SWI     XVCHIQ_ServiceRelease
        LDR     r0, DispManServiceC
        SWI     XVCHIQ_ServiceRelease
        ; Open display
        MOV     r0, #EDispmanDisplayOpen
        MOV     r1, #0
        STMIA   sp, {r0-r1}
        MOV     r0, #8
        BL      HWP_Send
        MOVVS   r7, r0
        BVS     %FT87
        STR     r0, HWPDispHandle
        ; Read width/height
        MOV     r0, #EDispmanDisplayGetInfo
        LDR     r1, HWPDispHandle
        STMIA   sp, {r0-r1}
        MOV     r0, #8
        BL      HWP_Send
        MOVVS   r7, r0
        BVS     %FT86
        ; Recalc display width/height
        LDR     r0, mbxres ; Initial mode set yet?
        CMP     r0, #0
        BLNE    HWP_CalcDisplayScaleOffset
d31 1
a31 1
        MOV     r1, #43 ; ARGB8888
d34 1
a34 1
        STMIA   sp, {r0-r3}
d36 4
a39 3
        BL      HWP_Send
        MOVVS   r7, r0
        BVS     %FT86
a54 34
86
        MOV     r0, #EDispmanDisplayClose + NoReply
        LDR     r1, HWPDispHandle
        STMIA   sp, {r0-r1}
        MOV     r0, #8
        BL      HWP_Send
87
        LDR     r0, DispManServiceN
        SWI     XVCHIQ_ServiceUse
        LDR     r0, DispManServiceN
        SWI     XVCHIQ_ServiceClose
88
        LDR     r0, DispManServiceC
        SWI     XVCHIQ_ServiceUse
        LDR     r0, DispManServiceC
        SWI     XVCHIQ_ServiceClose
89
        MOV     r0, #0
        STR     r0, DispManServiceC        
        STR     r0, DispManServiceN        
90
        FRAMSTR r7,,r0
        SETV
        EXIT

HWP_ClientCallback
        ; Did we receive a message?
        CMP     r1, #VCHI_CALLBACK_MSG_AVAILABLE
        STREQ   r1, DispManResponded
        MOV     pc, lr

HWP_NotifyCallback
        ; Not needed
        MOV     pc, lr
d57 1
a57 1
        Entry   "r0-r7", 8
d78 1
a78 6
        STMIA   sp, {r0-r1}
        MOV     r0, #8
        BL      HWP_Send        
        MOV     r0, #EDispmanDisplayClose + NoReply
        LDR     r1, HWPDispHandle
        STMIA   sp, {r0-r1}
d80 2
a81 13
        BL      HWP_Send        
        ; Release services
        LDR     r0, DispManServiceN
        SWI     XVCHIQ_ServiceUse
        LDR     r0, DispManServiceC
        SWI     XVCHIQ_ServiceUse
        LDR     r0, DispManServiceN
        SWI     XVCHIQ_ServiceClose
        LDR     r0, DispManServiceC
        SWI     XVCHIQ_ServiceClose
        MOV     r0, #0
        STR     r0, DispManServiceN
        STR     r0, DispManServiceC
d164 1
a164 1
        LDR     r0, HWPDisplayWidth
d295 1
a295 1
        BL      HWP_Send
d314 1
a314 1
        BL      HWP_Send
d323 2
a324 2
        LDR     r2, HWPDispHandle
        MOV     r3, #2000
d347 1
a347 1
        BLVC    HWP_Send
d368 1
a368 1
        BL      HWP_Send
d370 1
a370 1
        MOV     r0, #EDispmanUpdateSubmitSync
d374 1
a374 1
        BL      HWP_Send
d391 1
a391 1
        BL      HWP_Send
d405 1
a405 1
        BL      HWP_Send
d413 1
a413 1
        BL      HWP_Send
d415 1
a415 1
        MOV     r0, #EDispmanUpdateSubmitSync
d419 1
a419 1
        BL      HWP_Send
a447 122
; in:
; r0 = length
; sp -> input buffer
; out:
; r0 = 1st word of response (corrupt if no response requested)
HWP_Send ROUT
        Entry   "r1-r5"
      [ HWPDebug
        bl DebugHexTX4
        bl DebugTXStrInline
        DCB "HWP_Send",10,13,0
        ALIGN
      ]
        MOV     r1, r0
        ADD     r0, sp, #6*4
        LDR     r2, [r0]
        TST     r2, #NoReply
        MOVNE   r2, #0
        BNE     %FT50
        ; Read response into DispManResponded
        ; Ordinarily response is 4 bytes, except for DisplayGetInfo
        ; WS vars arranged so that we can use same buffer address
        ASSERT  HWPDisplayWidth = DispManResponded+4
        ASSERT  HWPDisplayHeight = DispManResponded+8
        ASSERT  HWPDisplayTrans = DispManResponded+12
        ASSERT  HWPDisplayFormat = DispManResponded+16
        TEQ     r2, #EDispmanDisplayGetInfo
        MOVNE   r3, #4
        MOVEQ   r3, #20
        ADR     r2, DispManResponded
50
        LDR     r4, DispManServiceC
        ADR     r5, DispManResponded
        BL      VCHIQSend
        BVS     %FT80
        CMP     r0, #0
        BEQ     %FT90
        LDR     r0, DispManResponded
      [ HWPDebug
        bl DebugHexTX4
        bl DebugTXStrInline
        DCB "result",10,13,0
        ALIGN
        CLRV
      ]
        EXIT
80
      [ HWPDebug
        bl DebugHexTX4
        bl DebugTXStrInline
        DCB "err",10,13,0
        ALIGN
        SETV
      ]
        EXIT
90
      [ HWPDebug
        bl DebugTXStrInline
        DCB "no result",10,13,0
        ALIGN
        CLRV
      ]
        EXIT

HWP_CalcDisplayScaleOffset ROUT
        Entry   "r0-r9"
        ; Calculate the scale & offset values that translate from RISC OS desktop pixels to physical display pixels, and vice-versa
        ; This assumes that the videocore won't alter the aspect ratio of the desktop, and scales it up without cropping
        ; It also assumes no transform is in use
        LDR     r0, HWPDisplayWidth
        LDR     r1, HWPDisplayHeight
        LDR     r2, mbxres
        LDR     r3, mbyres
        LDR     r4, mboverleft
        LDR     r5, mboverright
        LDR     r6, mbovertop
        LDR     r7, mboverbottom
        ADD     r8, r4, r5
        ADD     r9, r6, r7
        ; Overscan is nominally measured in display pixels, so subtract the overscan amount from the display size
        SUB     r8, r0, r8
        SUB     r9, r1, r9
        ; Which has the higher aspect ratio?
        MUL     r4, r8, r3
        MUL     r5, r9, r2
        CMP     r4, r5 ; GT: physical screen wider, so Y scale will be limiting factor. LT: RISC OS screen wider, so X scale will be limiting factor.
        ; Scaling is calculated as follows:
        ; scale = (displaysize-overscan)/fbsize
        MOVGT   r4, r9
        MOVGT   r5, r3
        MOVLE   r4, r8
        MOVLE   r5, r2
        MOV     r4, r4, LSL #16
        DivRem  r7, r4, r5, lr
        STR     r7, HWPXScale
        STR     r7, HWPYScale
        MOV     r5, r7
        ; Calculate inverse scale required for clipping in Y axis
        ; Just take the easy route and calculate the reciprocal of r7
        MOV     r8, #&80000000
        MOV     r4, r7, LSR #1
        DivRem  r6, r8, r4, lr
        STR     r6, HWPYInvScale
        ; Now calculate offsets
        MUL     r2, r5, r2
        MUL     r3, r7, r3
        LDR     r4, mboverleft
        LDR     r5, mboverright
        LDR     r6, mbovertop
        LDR     r7, mboverbottom
        SUB     r0, r0, r2, LSR #16
        SUB     r1, r1, r3, LSR #16
        ADD     r5, r4, r5
        ADD     r7, r6, r7
        SUB     r0, r0, r5
        SUB     r1, r1, r7
        ADD     r0, r4, r0, ASR #1
        ADD     r1, r6, r1, ASR #1
        STR     r0, HWPXOffset
        STR     r1, HWPYOffset
        EXIT

d451 1
a451 1
        ; Out: r0-r7 corrupt
d454 2
a455 2
        LDR     r3, HWPXScale
        LDR     r4, HWPXOffset
d464 1
a464 1
        LDR     r3, HWPDisplayWidth
d468 2
a469 2
        LDR     r3, HWPYScale
        LDR     r4, HWPYOffset
d474 1
a474 1
        LDR     r2, HWPDisplayHeight
d478 1
a478 1
        ; TODO - use sub-pixel offsets to make sure the pointer image lines up with the correct pixels below
d491 1
a491 1
        LDR     r5, HWPYInvScale
@


1.10
log
@Add support for GPU mode changes, vcgencmd implementation, and fix some issues with rotated displays
Detail:
  With recent firmware (~Aug 10th and newer) it's possible to issue a hdmi_timings command via vcgencmd to define custom mode timings on the fly. Make use of this feature (if available) to allow the OS to feed mode timings to the GPU instead of relying on the GPU to scale the framebuffer to the mode that was selected at boot.
  As an off-shoot of this we also get a vcgencmd *-command that's roughly equivalent to the vcgencmd command that's available under Linux
  File changes:
  - Makefile, Resources/UK/CmdHelp - *vcgencmd help text
  - s/BCMVideo - Add a few option switches to control the new behaviour. Add some generic code for interacting with VCHIQ services. Fix some issues with rotated displays (mainly 90 / 270 degree rotation)
  - s/Debug - Fix debug routines corrupting some registers
  - s/GraphicsV - Disable GraphicsV_StartupMode implementation if the builtin MDF is disabled (-> GPU mode changes are enabled)
  - s/HWPointer - Update to use the generic VCHIQ service code from s/BCMVideo
  - s/GenCmd - vcgencmd implementation. On initialisation, use it to read some of the GPU state & limits.
  - s/TVService - basic TV service implementation; enough to read the GPU state and perform mode changes
  - s/GPUMode - GPU mode change handling.
Admin:
  Tested on Raspberry Pi 1, 2, 3 with old & new firmware


Version 0.40. Tagged as 'BCMVideo-0_40'
@
text
@d60 13
d78 1
a78 1
      ]  
@


1.9
log
@Fix pointer coordinate space scale calculation when overscan in use
Detail:
  s/HWPointer - Fix logic for calculating framebuffer <-> display coordinate transformation to match that which contemporary firmware appears to be using (Since an asymmetric overscan fix from 13th May 2015?)
Admin:
  Tested on Raspberry Pi 1 with assorted overscan settings
  Fixes pointer positioning when using overscan with firmware from the last ~12 months


Version 0.36. Tagged as 'BCMVideo-0_36'
@
text
@a14 2
        GET     VCHIQ
        GET     RTSupport
d58 3
d67 1
a67 2
        MOV     r0, r12
        SWI     XVCHIQ_Initialise
a69 7
        STR     r0, VCHIQInstance
        MOV     r2, r0
        MOV     r1, #0
        MOV     r0, #0
        SWI     XVCHIQ_Connect
        MOVVS   r7, r0
        BVS     %FT89        
d91 1
a91 1
        STR     r0, VCHIQServiceC
d100 1
a100 1
        STR     r0, VCHIQServiceN
d103 1
a103 1
        LDR     r0, VCHIQServiceC
d158 1
a158 1
        LDR     r0, VCHIQServiceN
d160 1
a160 1
        LDR     r0, VCHIQServiceN
d163 1
a163 1
        LDR     r0, VCHIQServiceC
d165 1
a165 1
        LDR     r0, VCHIQServiceC
a167 2
        LDR     r0, VCHIQInstance
        SWI     XVCHIQ_Disconnect
d169 2
a170 3
        STR     r0, VCHIQInstance
        STR     r0, VCHIQServiceC        
        STR     r0, VCHIQServiceN        
d172 1
a172 1
        STR     r7, [sp]
d179 1
a179 1
        STREQ   r1, VCHIQResponded
d188 3
d195 1
a195 1
      ]  
d204 1
a204 1
        BL      HWP_WaitFor
d217 1
a217 1
        LDR     r0, VCHIQServiceN
d219 1
a219 1
        LDR     r0, VCHIQServiceC
d221 1
a221 1
        LDR     r0, VCHIQServiceN
d223 1
a223 1
        LDR     r0, VCHIQServiceC
a224 3
        ; Deregister with VCHIQ
        LDR     r0, VCHIQInstance
        SWI     XVCHIQ_Disconnect
d226 2
a227 3
        STR     r0, VCHIQServiceN
        STR     r0, VCHIQServiceC
        STR     r0, VCHIQInstance
a347 34
HWP_WaitFor ROUT
        ; Wait for pollword at r1 to become nonzero
        ; Assumes interrupts can be enabled!
        Entry   "r0,r2-r3"
      [ HWPDebug
        MOV r0, r1
        bl DebugHexTX4
        bl DebugTXStrInline
        DCB "HWP_WaitFor",10,13,0
        ALIGN
      ]  
        MRS     r3, CPSR
05
        ORR     r2, r3, #I32_bit
        MSR     CPSR_c, r2
        LDR     r0, [r1]
        CMP     r0, #0
        BNE     %FT10
        ; Block on mutex, with IRQs enabled. IRQs must be enabled to avoid deadlock, as RTSupport doesn't have any IRQ-enabled "idle" thread to drop into when all others are blocked.
        BIC     r2, r3, #I32_bit
        MSR     CPSR_c, r2
        SWI     XRT_Yield
        BVS     %FT10 ; Error typically means we're in an IRQ (which shouldn't happen for us). But to avoid problems just go ahead and claim the mutex anyway.
        ADR     lr, %BT05
        LDR     pc, IRQTrigger        
10        
        MSR     CPSR_c, r3
      [ HWPDebug
        bl DebugTXStrInline
        DCB "HWP_WaitFor OK",10,13,0
        ALIGN
      ]  
        EXIT

d378 1
a378 1
        ADREQ   r1, pollword_1
d402 4
a405 6
        EXIT    NE ; It's dead and we want it to be dead
        ; It's alive and we want it to be dead. Kick it if necessary.
        B       %BT05

pollword_1
        DCD     1
d443 1
a443 1
        LDR     r0, VCHIQServiceC
d446 1
a446 1
        LDR     r0, VCHIQServiceC
d452 1
a452 1
        LDR     r0, VCHIQServiceC
d593 6
a598 1
        
d600 1
a600 2
        Entry   "r1-r3"
        MOV     r2, r0
d607 3
a609 12
        LDR     r0, VCHIQServiceC
        SWI     XVCHIQ_ServiceUse
        EXIT    VS
        MOV     r0, #0
        STR     r0, VCHIQResponded
        LDR     r0, VCHIQServiceC
        ADD     r1, sp, #16
        MOV     r3, #VCHI_FLAGS_BLOCK_UNTIL_QUEUED
        SWI     XVCHIQ_MsgQueue
        BVS     %FT80
        ; Response necessary?
        LDR     r2, [r1]
d611 3
a613 7
        BNE     %FT90
        ; Wait for response
10
        ADR     r1, VCHIQResponded
        BL      HWP_WaitFor
        LDR     r0, VCHIQServiceC
        ; Read response (into R1, i.e. VCHIQResponded)
d616 4
a619 4
        ASSERT  HWPDisplayWidth = VCHIQResponded+4
        ASSERT  HWPDisplayHeight = VCHIQResponded+8
        ASSERT  HWPDisplayTrans = VCHIQResponded+12
        ASSERT  HWPDisplayFormat = VCHIQResponded+16
d621 7
a627 4
        MOVNE   r2, #4
        MOVEQ   r2, #20
        MOV     r3, #0
        SWI     XVCHIQ_MsgDequeue
d629 3
a631 3
        LDR     r0, VCHIQServiceC
        SWI     XVCHIQ_ServiceUse
        LDR     r0, [r1]
d637 1
a638 1
        CLRV
a640 4
        MOV     r1, r0
        LDR     r0, VCHIQServiceC
        SWI     XVCHIQ_ServiceUse
        MOV     r0, r1
d646 1
a647 1
        SETV
a649 2
        LDR     r0, VCHIQServiceC
        SWI     XVCHIQ_ServiceUse
d654 1
a655 1
        CLRV
d785 2
@


1.8
log
@Remove manual software pointer support. Fix hardware pointer vanishing at X >= 2048 by falling back to kernel software pointer.
Detail:
  s/BCMVideo, s/SWPointer, s/GraphicsV - Remove manual software pointer code. Update GraphicsV code to deal with indicating when kernel software pointer is/isn't needed.
  s/HWPointer - Turn off hardware pointer and return with GraphicsV_UpdatePointer unclaimed if the pointer GPU X coord is >= 2048
Admin:
  Tested on Raspberry Pi
  Fixes pointer vanishing at X >= 2048


Version 0.31. Tagged as 'BCMVideo-0_31'
@
text
@d732 3
d736 2
a737 2
        MUL     r4, r0, r3
        MUL     r5, r1, r2
d739 3
a741 1
        MOVGT   r4, r1
d743 1
a743 1
        MOVLE   r4, r0
d745 3
a747 13
        MOV     r7, r4, LSL #16
        DivRem  r6, r7, r5, lr
        ; Adjust for overscan
        ; The equation used is:
        ; xscale = basescale-(xoverscan/fbwidth)
        ; yscale = basescale-(yoverscan/fbheight)
        MOV     r8, r8, LSL #16
        DivRem  r7, r8, r2, lr
        SUB     r5, r6, r7
        STR     r5, HWPXScale
        MOV     r9, r9, LSL #16
        DivRem  r7, r9, r3, lr
        SUB     r7, r6, r7
d749 1
@


1.7
log
@Fix calculation of cursor position when using off-center overscan settings
Detail:
  s/HWPointer - Corrected the logic in HWP_CalcDisplayScaleOffset for calculating the offset to be applied to the cursor position. The old code worked fine for regular overscan, but would get the offset wrong when dealing with off-center settings (e.g. different overscan_left and overscan_right values)
Admin:
  Tested on Raspberry Pi with latest firmware
  Should fix overscan issue reported on forums:
  https://www.riscosopen.org/forum/forums/9/topics/997?page=25#posts-33987


Version 0.26. Tagged as 'BCMVideo-0_26'
@
text
@d259 1
d317 20
d338 1
@


1.6
log
@Fix hardware pointer issues with latest firmware
Detail:
  s/HWPointer - Disable the cursor overlay if it's completely off-screen
Admin:
  Tested on Raspberry Pi
  Fixes bug/feature with latest firmware (around 30 Mar 2014) where cursor overlay will display incorrectly (large cursor filling screen or large square of colours) if moved completely off the top or left edge of the screen


Version 0.21. Tagged as 'BCMVideo-0_21'
@
text
@d747 4
a750 2
        SUB     r4, r5, r4
        SUB     r6, r7, r6
d754 1
a754 1
        STR     r1, HWPYOffset        
@


1.5
log
@Misc fixes
Detail:
  s/BCMVideo - Fix bad pointer being passed to SetModeFromVIDCList on startup, potentially causing a hang on startup. Add extra LTORG needed when debugging enabled, and strip some useless debug output.
  s/HWPointer - Fix potential crash when shutting down hardware pointer due to pointer being passed in wrong register
Admin:
  Tested on Raspberry Pi


Version 0.17. Tagged as 'BCMVideo-0_17'
@
text
@d518 1
a518 1
        BL      HWP_Send
d537 1
d554 13
d600 1
d759 1
d767 7
a773 3
        MOV     r4, r3, LSR #16-5 ; 32 pixels
        STR     r4, [r0, #8]
        STR     r4, [r0, #12]
d780 4
d794 1
a794 1
        MOVGE   pc, lr
d797 1
a797 1
        MOVLE   pc, lr ; Don't do anything if it's fully off screen (if we clamp the height to <1, it'll just end up being displayed scaled up to fit the screen. doh!)
d802 1
a802 1
        MOVLE   pc, lr ; Paranoia - Don't clamp if src height becomes <=0 either (not sure whether it's the src height or dest height that's the problem)
d807 15
@


1.4
log
@Update to work with latest version of VCHIQ module
Detail:
  s/HWPointer - Specify dispmanx service version when connecting to it
  s/BCMVideo - Fixed compile error when hardware pointer disabled
Admin:
  Tested on Raspberry Pi
  Requires VCHIQ-0_05


Version 0.12. Tagged as 'BCMVideo-0_12'
@
text
@d210 1
a210 1
        ADR     r0, RTDead
@


1.3
log
@Adjust hardware pointer code to take into account overscan
Detail:
  s/BCMVideo, s/HWPointer - Hardware pointer code now takes into account overscan when calculating the scale and offset values required to convert RISC OS screen pixels to hardware/dispmanx pixels
Admin:
  Tested on Raspberry Pi


Version 0.09. Tagged as 'BCMVideo-0_09'
@
text
@d78 3
@


1.2
log
@Add GraphicsV_Render implementation. Allow utilisation of new fake_vsync_isr config.txt option for generating VSync interrupts.
Detail:
  hdr/DMA, s/BCMVideo, s/GraphicsV - Added GraphicsV_Render implementation. Uses one of the 2D-capable DMA channels to accelerate block copies/moves. Rectangle fill acceleration currently not supported.
  hdr/BCM2835reg, s/BCMVideo, s/GraphicsV - Add code to detect whether the new fake_vsync_isr firmware option (https://github.com/raspberrypi/firmware/issues/67) is enabled and if so, use it as our VSync IRQ source.
  s/HWPointer - Add toggle for hardware pointer debug to reduce debug spam
Admin:
  Tested on Raspberry Pi with high processor vectors & various firmware versions


Version 0.07. Tagged as 'BCMVideo-0_07'
@
text
@d678 1
a678 1
        Entry   "r0-r7"
d686 6
d702 18
a719 4
        STR     r6, HWPScale
        MOV     r5, r5, LSL #16
        DivRem  r7, r5, r4, lr
        STR     r7, HWPInvScale
d721 6
a726 2
        MUL     r2, r6, r2
        MUL     r3, r6, r3
d729 4
a732 2
        MOV     r0, r0, ASR #1
        MOV     r1, r1, ASR #1
d742 1
a742 1
        LDR     r3, HWPScale
d752 1
d771 1
a771 1
        LDR     r5, HWPInvScale
@


1.1
log
@Add hardware pointer support
Detail:
  s/HWPointer, s/BCMVideo, s/GraphicsV - Added hardware pointer support, using VCHIQ to talk to the VC-side dispmanx service. Software pointer will automatically disable itself once the hardware pointer is activated by VCHIQ being loaded.
  s/SWPointer, s/BCMVideo - Renamed software pointer routines & variables to have 'SWP' prefix to more easily differentiate them from the 'HWP' hardware pointer routines/variables
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.05. Tagged as 'BCMVideo-0_05'
@
text
@d18 3
d22 1
a22 1
HiDebug SETL    {FALSE}        
d60 1
a60 1
      [ Debug
d141 1
a141 1
      [ Debug
d195 1
a195 1
      [ Debug
d237 1
a237 1
      [ Debug
d338 1
a338 1
      [ Debug
d361 1
a361 1
      [ Debug
d442 1
a442 1
      [ Debug
d543 1
a543 1
      [ Debug
d585 1
a585 1
      [ Debug
d604 1
a604 1
      [ Debug
d645 1
a645 1
      [ Debug
d658 1
a658 1
      [ Debug
d669 1
a669 1
      [ Debug
@


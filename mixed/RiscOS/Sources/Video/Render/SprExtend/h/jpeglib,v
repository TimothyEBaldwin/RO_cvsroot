head	4.6;
access;
symbols
	SprExtend-1_83:4.6
	SprExtend-1_82:4.6
	SprExtend-1_81:4.6
	SprExtend-1_80:4.6
	SprExtend-1_79:4.6
	SprExtend-1_78:4.6
	SprExtend-1_77:4.6
	SprExtend-1_76:4.6
	SprExtend-1_75:4.5
	SprExtend-1_74:4.5
	SprExtend-1_73:4.4
	SprExtend-1_72:4.4
	SprExtend-1_71-nocfsi:4.3
	SprExtend-1_71:4.3
	SprExtend-1_70-tracef:4.2
	SprExtend-1_70-headers:4.2
	SprExtend-1_70:4.1
	SprExtend-1_69:4.1
	SprExtend-1_68:4.1
	SprExtend-1_67:4.1
	SprExtend-1_66:4.1
	SprExtend-1_65:4.1
	SprExtend-1_64:4.1
	SprExtend-1_63:4.1
	SprExtend-1_62:4.1
	SprExtend-1_61:4.1
	SprExtend-1_60:4.1
	SprExtend-1_59:4.1
	SprExtend-1_58:4.1
	SprExtend-1_57:4.1
	SprExtend-1_56:4.1
	SprExtend-1_55:4.1
	SprExtend-1_54:4.1
	SprExtend-1_53:4.1
	SprExtend-1_52:4.1
	SprExtend-1_51:4.1
	SprExtend-1_50:4.1
	SprExtend-1_38-1_35_2_16:4.1.2.10
	SprExtend-1_49:4.1
	SprExtend-1_48:4.1
	SprExtend-1_47:4.1
	SprExtend-1_38-1_35_2_15:4.1.2.10
	SprExtend-1_46:4.1
	SprExtend-1_45:4.1
	SprExtend-1_44:4.1
	SprExtend-1_43:4.1
	SprExtend-1_42:4.1
	SprExtend-1_41:4.1
	SprExtend-1_38-1_35_2_14:4.1.2.10
	SprExtend-1_40:4.1
	SprExtend-1_38-1_35_2_13:4.1.2.9
	SprExtend-1_38-1_35_2_12:4.1.2.8
	SprExtend-1_38-1_35_2_11:4.1.2.7
	SprExtend-1_38-1_35_2_10:4.1.2.6
	SprExtend-1_38-1_35_2_9:4.1.2.5
	SprExtend-1_38-1_35_2_8:4.1.2.4
	SprExtend-1_39:4.1
	SprExtend-1_38-1_35_2_7:4.1.2.4
	SprExtend-1_38-1_35_2_6:4.1.2.4
	SprExtend-1_38-1_35_2_5:4.1.2.4
	SprExtend-1_38-1_35_2_4:4.1.2.4
	SprExtend-1_38-1_35_2_3:4.1.2.3
	SprExtend-1_38-1_35_2_2:4.1.2.2
	SprExtend-1_38-1_35_2_1:4.1.2.1
	MigrateIJG8b:4.1.0.2
	SprExtend-1_38:4.1
	SprExtend-1_37:4.1
	SprExtend-1_36:4.1
	SprExtend-1_35:4.1
	SprExtend-1_34:4.1
	SprExtend-1_33:4.1
	SprExtend-1_32:4.1
	SprExtend-1_31:4.1
	SprExtend-1_30:4.1
	SprExtend-1_29:4.1
	SprExtend-1_28:4.1
	SprExtend-1_27:4.1
	SprExtend-1_26:4.1
	SprExtend-1_25:4.1
	SprExtend-1_24:4.1
	SprExtend-1_23:4.1
	SprExtend-1_22:4.1
	SprExtend-1_21:4.1
	SprExtend-1_20:4.1
	SprExtend-1_19:4.1
	SprExtend-1_18:4.1
	SprExtend-1_17:4.1
	RO_5_07:4.1
	SprExtend-1_16:4.1
	SprExtend-1_15:4.1
	SprExtend-1_14:4.1
	SprExtend-1_13:4.1
	SprExtend-1_12:4.1
	SprExtend-1_11:4.1
	SprExtend-1_10:4.1
	SprExtend-1_09:4.1
	SprExtend-1_08:4.1
	dellis_autobuild_BaseSW:4.1
	SprExtend-1_07:4.1
	SprExtend-1_06:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	SprExtend-1_05:4.1
	Ursula_merge:4.1
	nturton_SprExtend-1_04:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2016.05.21.14.16.35;	author rool;	state Exp;
branches;
next	4.5;
commitid	xdjBCBYna4x7am7z;

4.5
date	2016.05.21.14.10.19;	author rool;	state Exp;
branches;
next	4.4;
commitid	RAjaHu2jGaPW7m7z;

4.4
date	2016.05.21.14.03.51;	author rool;	state Exp;
branches;
next	4.3;
commitid	4BquZHousteH5m7z;

4.3
date	2016.05.21.13.44.42;	author rool;	state Exp;
branches;
next	4.2;
commitid	ZDqmsyNiMhv6Zl7z;

4.2
date	2016.05.21.13.32.23;	author rool;	state Exp;
branches;
next	4.1;
commitid	yTqS85yKh7k8Ul7z;

4.1
date	96.11.05.09.45.08;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.2.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.45.08;	author nturton;	state Exp;
branches;
next	;

4.1.2.1
date	2011.01.04.20.52.07;	author rsprowson;	state Exp;
branches;
next	4.1.2.2;

4.1.2.2
date	2011.01.04.21.28.35;	author rsprowson;	state Exp;
branches;
next	4.1.2.3;

4.1.2.3
date	2011.01.04.21.37.04;	author rsprowson;	state Exp;
branches;
next	4.1.2.4;

4.1.2.4
date	2011.01.04.21.45.34;	author rsprowson;	state Exp;
branches;
next	4.1.2.5;

4.1.2.5
date	2011.01.22.17.58.34;	author rsprowson;	state Exp;
branches;
next	4.1.2.6;

4.1.2.6
date	2011.01.22.18.01.53;	author rsprowson;	state Exp;
branches;
next	4.1.2.7;

4.1.2.7
date	2011.01.29.10.03.43;	author rsprowson;	state Exp;
branches;
next	4.1.2.8;

4.1.2.8
date	2011.01.29.10.05.59;	author rsprowson;	state Exp;
branches;
next	4.1.2.9;

4.1.2.9
date	2011.02.05.09.56.58;	author rsprowson;	state Exp;
branches;
next	4.1.2.10;

4.1.2.10
date	2011.02.15.20.58.08;	author rsprowson;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.41.45;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.57.54;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.20.32;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Lazy MCU decoding
Detail:
  Only colour convert from the left clipping border (rounded down) to the right (rounding up).
  Only entropy decode the DC component for blocks likewise, skipping AC and IDCT steps.
Admin:
  Submission for the JPEG bounty.

Version 1.76. Tagged as 'SprExtend-1_76'
@
text
@/*
 * jpeglib.h
 *
 * Copyright (C) 1991-1998, Thomas G. Lane.
 * Modified 2002-2011 by Guido Vollbeding.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file defines the application interface for the JPEG library.
 * Most applications using the library need only include this file,
 * and perhaps jerror.h if they want to know the exact error codes.
 */

#ifndef JPEGLIB_H
#define JPEGLIB_H

/*
 * First we include the configuration files that record how this
 * installation of the JPEG library is set up.  jconfig.h can be
 * generated automatically for many systems.  jmorecfg.h contains
 * manual configuration options that most people need not worry about.
 */

#ifndef JCONFIG_INCLUDED	/* in case jinclude.h already did */
#include "jconfig.h"		/* widely used configuration options */
#endif
#include "jmorecfg.h"		/* seldom changed options */


#ifdef __cplusplus
#ifndef DONT_USE_EXTERN_C
extern "C" {
#endif
#endif

/* Version IDs for the JPEG library.
 * Might be useful for tests like "#if JPEG_LIB_VERSION >= 80".
 */

#define JPEG_LIB_VERSION        80	/* Compatibility version 8.0 */
#define JPEG_LIB_VERSION_MAJOR  8
#define JPEG_LIB_VERSION_MINOR  4


/* Various constants determining the sizes of things.
 * All of these are specified by the JPEG standard, so don't change them
 * if you want to be compatible.
 */

#define DCTSIZE		    8	/* The basic DCT block is 8x8 coefficients */
#define DCTSIZE2	    64	/* DCTSIZE squared; # of elements in a block */
#define NUM_QUANT_TBLS      4	/* Quantization tables are numbered 0..3 */
#define NUM_HUFF_TBLS       4	/* Huffman tables are numbered 0..3 */
#define NUM_ARITH_TBLS      16	/* Arith-coding tables are numbered 0..15 */
#define MAX_COMPS_IN_SCAN   4	/* JPEG limit on # of components in one scan */
#define MAX_SAMP_FACTOR     4	/* JPEG limit on sampling factors */
/* Unfortunately, some bozo at Adobe saw no reason to be bound by the standard;
 * the PostScript DCT filter can emit files with many more than 10 blocks/MCU.
 * If you happen to run across such a file, you can up D_MAX_BLOCKS_IN_MCU
 * to handle it.  We even let you do this from the jconfig.h file.  However,
 * we strongly discourage changing C_MAX_BLOCKS_IN_MCU; just because Adobe
 * sometimes emits noncompliant files doesn't mean you should too.
 */
#define C_MAX_BLOCKS_IN_MCU   10 /* compressor's limit on blocks per MCU */
#ifndef D_MAX_BLOCKS_IN_MCU
#define D_MAX_BLOCKS_IN_MCU   10 /* decompressor's limit on blocks per MCU */
#endif


/* Data structures for images (arrays of samples and of DCT coefficients).
 * On 80x86 machines, the image arrays are too big for near pointers,
 * but the pointer arrays can fit in near memory.
 */

typedef JSAMPLE FAR *JSAMPROW;	/* ptr to one image row of pixel samples. */
typedef JSAMPROW *JSAMPARRAY;	/* ptr to some rows (a 2-D sample array) */
typedef JSAMPARRAY *JSAMPIMAGE;	/* a 3-D sample array: top index is color */

typedef JCOEF JBLOCK[DCTSIZE2];	/* one block of coefficients */
typedef JBLOCK FAR *JBLOCKROW;	/* pointer to one row of coefficient blocks */
typedef JBLOCKROW *JBLOCKARRAY;		/* a 2-D array of coefficient blocks */
typedef JBLOCKARRAY *JBLOCKIMAGE;	/* a 3-D array of coefficient blocks */

typedef JCOEF FAR *JCOEFPTR;	/* useful in a couple of places */


/* Types for JPEG compression parameters and working tables. */


/* DCT coefficient quantization tables. */

typedef struct {
  /* This array gives the coefficient quantizers in natural array order
   * (not the zigzag order in which they are stored in a JPEG DQT marker).
   * CAUTION: IJG versions prior to v6a kept this array in zigzag order.
   */
  UINT16 quantval[DCTSIZE2];	/* quantization step for each coefficient */
  /* This field is used only during compression.  It's initialized FALSE when
   * the table is created, and set TRUE when it's been output to the file.
   * You could suppress output of a table by setting this to TRUE.
   * (See jpeg_suppress_tables for an example.)
   */
  boolean sent_table;		/* TRUE when table has been output */
} JQUANT_TBL;


/* Huffman coding tables. */

typedef struct {
  /* These two fields directly represent the contents of a JPEG DHT marker */
  UINT8 bits[17];		/* bits[k] = # of symbols with codes of */
				/* length k bits; bits[0] is unused */
  UINT8 huffval[256];		/* The symbols, in order of incr code length */
  /* This field is used only during compression.  It's initialized FALSE when
   * the table is created, and set TRUE when it's been output to the file.
   * You could suppress output of a table by setting this to TRUE.
   * (See jpeg_suppress_tables for an example.)
   */
  boolean sent_table;		/* TRUE when table has been output */
} JHUFF_TBL;


/* Basic info about one component (color channel). */

typedef struct {
  /* These values are fixed over the whole image. */
  /* For compression, they must be supplied by parameter setup; */
  /* for decompression, they are read from the SOF marker. */
  int component_id;		/* identifier for this component (0..255) */
  int component_index;		/* its index in SOF or cinfo->comp_info[] */
  int h_samp_factor;		/* horizontal sampling factor (1..4) */
  int v_samp_factor;		/* vertical sampling factor (1..4) */
  int quant_tbl_no;		/* quantization table selector (0..3) */
  /* These values may vary between scans. */
  /* For compression, they must be supplied by parameter setup; */
  /* for decompression, they are read from the SOS marker. */
  /* The decompressor output side may not use these variables. */
  int dc_tbl_no;		/* DC entropy table selector (0..3) */
  int ac_tbl_no;		/* AC entropy table selector (0..3) */
  
  /* Remaining fields should be treated as private by applications. */
  
  /* These values are computed during compression or decompression startup: */
  /* Component's size in DCT blocks.
   * Any dummy blocks added to complete an MCU are not counted; therefore
   * these values do not depend on whether a scan is interleaved or not.
   */
  JDIMENSION width_in_blocks;
  JDIMENSION height_in_blocks;
  /* Size of a DCT block in samples,
   * reflecting any scaling we choose to apply during the DCT step.
   * Values from 1 to 16 are supported.
   * Note that different components may receive different DCT scalings.
   */
  int DCT_h_scaled_size;
  int DCT_v_scaled_size;
  /* The downsampled dimensions are the component's actual, unpadded number
   * of samples at the main buffer (preprocessing/compression interface);
   * DCT scaling is included, so
   * downsampled_width = ceil(image_width * Hi/Hmax * DCT_h_scaled_size/DCTSIZE)
   * and similarly for height.
   */
  JDIMENSION downsampled_width;	 /* actual width in samples */
  JDIMENSION downsampled_height; /* actual height in samples */
  /* This flag is used only for decompression.  In cases where some of the
   * components will be ignored (eg grayscale output from YCbCr image),
   * we can skip most computations for the unused components.
   */
  boolean component_needed;	/* do we need the value of this component? */

  /* These values are computed before starting a scan of the component. */
  /* The decompressor output side may not use these variables. */
  int MCU_width;		/* number of blocks per MCU, horizontally */
  int MCU_height;		/* number of blocks per MCU, vertically */
  int MCU_blocks;		/* MCU_width * MCU_height */
  int MCU_sample_width;	/* MCU width in samples: MCU_width * DCT_h_scaled_size */
  int last_col_width;		/* # of non-dummy blocks across in last MCU */
  int last_row_height;		/* # of non-dummy blocks down in last MCU */

  /* Saved quantization table for component; NULL if none yet saved.
   * See jdinput.c comments about the need for this information.
   * This field is currently used only for decompression.
   */
  JQUANT_TBL * quant_table;

  /* Private per-component storage for DCT or IDCT subsystem. */
  void * dct_table;
} jpeg_component_info;


/* The script for encoding a multiple-scan file is an array of these: */

typedef struct {
  int comps_in_scan;		/* number of components encoded in this scan */
  int component_index[MAX_COMPS_IN_SCAN]; /* their SOF/comp_info[] indexes */
  int Ss, Se;			/* progressive JPEG spectral selection parms */
  int Ah, Al;			/* progressive JPEG successive approx. parms */
} jpeg_scan_info;

/* The decompressor can save APPn and COM markers in a list of these: */

typedef struct jpeg_marker_struct FAR * jpeg_saved_marker_ptr;

struct jpeg_marker_struct {
  jpeg_saved_marker_ptr next;	/* next in list, or NULL */
  UINT8 marker;			/* marker code: JPEG_COM, or JPEG_APP0+n */
  unsigned int original_length;	/* # bytes of data in the file */
  unsigned int data_length;	/* # bytes of data saved at data[] */
  JOCTET FAR * data;		/* the data contained in the marker */
  /* the marker length word is not counted in data_length or original_length */
};

/* Known color spaces. */

typedef enum {
	JCS_UNKNOWN,		/* error/unspecified */
	JCS_GRAYSCALE,		/* monochrome */
	JCS_RGB,		/* red/green/blue */
	JCS_YCbCr,		/* Y/Cb/Cr (also known as YUV) */
	JCS_CMYK,		/* C/M/Y/K */
	JCS_YCCK		/* Y/Cb/Cr/K */
} J_COLOR_SPACE;

/* DCT/IDCT algorithm options. */

typedef enum {
	JDCT_ISLOW,		/* slow but accurate integer algorithm */
	JDCT_IFAST,		/* faster, less accurate integer method */
	JDCT_FLOAT		/* floating-point: accurate, fast on fast HW */
} J_DCT_METHOD;

#ifndef JDCT_DEFAULT		/* may be overridden in jconfig.h */
#define JDCT_DEFAULT  JDCT_ISLOW
#endif
#ifndef JDCT_FASTEST		/* may be overridden in jconfig.h */
#define JDCT_FASTEST  JDCT_IFAST
#endif

/* Dithering options for decompression. */

typedef enum {
	JDITHER_NONE,		/* no dithering */
	JDITHER_ORDERED,	/* simple ordered dither */
	JDITHER_FS		/* Floyd-Steinberg error diffusion dither */
} J_DITHER_MODE;


/* Common fields between JPEG compression and decompression master structs. */

#define jpeg_common_fields \
  struct jpeg_error_mgr * err;	/* Error handler module */\
  struct jpeg_memory_mgr * mem;	/* Memory manager module */\
  struct jpeg_progress_mgr * progress; /* Progress monitor, or NULL if none */\
  void * client_data;		/* Available for use by application */\
  boolean is_decompressor;	/* So common code can tell which is which */\
  int global_state		/* For checking call sequence validity */

/* Routines that are to be used by both halves of the library are declared
 * to receive a pointer to this structure.  There are no actual instances of
 * jpeg_common_struct, only of jpeg_compress_struct and jpeg_decompress_struct.
 */
struct jpeg_common_struct {
  jpeg_common_fields;		/* Fields common to both master struct types */
  /* Additional fields follow in an actual jpeg_compress_struct or
   * jpeg_decompress_struct.  All three structs must agree on these
   * initial fields!  (This would be a lot cleaner in C++.)
   */
};

typedef struct jpeg_common_struct * j_common_ptr;
typedef struct jpeg_compress_struct * j_compress_ptr;
typedef struct jpeg_decompress_struct * j_decompress_ptr;


#ifdef RISCOS /* Module specifics */
/* Position independent code and data relocation */
void (*relocate_func(void (*)(void)))(void);
void *relocate_data(void *);
#define RELOCCODE(k) relocate_func((void(*)(void))(k))
#define RELOCDATA(k) relocate_data((void *)(k))

/* State to record a point in the Huffman stream, neatly packed in 20 bytes */
typedef struct
{
  INT32 get_buffer; /* Huffman bit buffer */
  const JOCTET *next_input_byte; /* State for data source */
  short last_dc_val[MAX_COMPS_IN_SCAN]; /* Huffman state */
  unsigned int restarts_to_go:16; /* 2 byte from M_DRI */
  unsigned int bits_left:5; /* Huffman bit position */
  unsigned int next_restart_num:3; /* Next expected M_RSTn */
  unsigned int unread_marker:8; /* May encounter markers mid Huffman stream */
} huff_pointer;
EXTERN(void) huff_pointer_save(j_decompress_ptr, huff_pointer *);
EXTERN(void) huff_pointer_restore(j_decompress_ptr, const huff_pointer *);
#else
#define RELOCCODE(k) k
#define RELOCDATA(k) k
#endif


/* Master record for a compression instance */

struct jpeg_compress_struct {
  jpeg_common_fields;		/* Fields shared with jpeg_decompress_struct */

  /* Destination for compressed data */
  struct jpeg_destination_mgr * dest;

  /* Description of source image --- these fields must be filled in by
   * outer application before starting compression.  in_color_space must
   * be correct before you can even call jpeg_set_defaults().
   */

  JDIMENSION image_width;	/* input image width */
  JDIMENSION image_height;	/* input image height */
  int input_components;		/* # of color components in input image */
  J_COLOR_SPACE in_color_space;	/* colorspace of input image */

  double input_gamma;		/* image gamma of input image */

  /* Compression parameters --- these fields must be set before calling
   * jpeg_start_compress().  We recommend calling jpeg_set_defaults() to
   * initialize everything to reasonable defaults, then changing anything
   * the application specifically wants to change.  That way you won't get
   * burnt when new parameters are added.  Also note that there are several
   * helper routines to simplify changing parameters.
   */

  unsigned int scale_num, scale_denom; /* fraction by which to scale image */

  JDIMENSION jpeg_width;	/* scaled JPEG image width */
  JDIMENSION jpeg_height;	/* scaled JPEG image height */
  /* Dimensions of actual JPEG image that will be written to file,
   * derived from input dimensions by scaling factors above.
   * These fields are computed by jpeg_start_compress().
   * You can also use jpeg_calc_jpeg_dimensions() to determine these values
   * in advance of calling jpeg_start_compress().
   */

  int data_precision;		/* bits of precision in image data */

  int num_components;		/* # of color components in JPEG image */
  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */

  jpeg_component_info * comp_info;
  /* comp_info[i] describes component that appears i'th in SOF */

  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
  int q_scale_factor[NUM_QUANT_TBLS];
  /* ptrs to coefficient quantization tables, or NULL if not defined,
   * and corresponding scale factors (percentage, initialized 100).
   */

  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
  /* ptrs to Huffman coding tables, or NULL if not defined */

  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */

  int num_scans;		/* # of entries in scan_info array */
  const jpeg_scan_info * scan_info; /* script for multi-scan file, or NULL */
  /* The default value of scan_info is NULL, which causes a single-scan
   * sequential JPEG file to be emitted.  To create a multi-scan file,
   * set num_scans and scan_info to point to an array of scan definitions.
   */

  boolean raw_data_in;		/* TRUE=caller supplies downsampled data */
  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
  boolean optimize_coding;	/* TRUE=optimize entropy encoding parms */
  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
  boolean do_fancy_downsampling; /* TRUE=apply fancy downsampling */
  int smoothing_factor;		/* 1..100, or 0 for no input smoothing */
  J_DCT_METHOD dct_method;	/* DCT algorithm selector */

  /* The restart interval can be specified in absolute MCUs by setting
   * restart_interval, or in MCU rows by setting restart_in_rows
   * (in which case the correct restart_interval will be figured
   * for each scan).
   */
  unsigned int restart_interval; /* MCUs per restart, or 0 for no restart */
  int restart_in_rows;		/* if > 0, MCU rows per restart interval */

  /* Parameters controlling emission of special markers. */

  boolean write_JFIF_header;	/* should a JFIF marker be written? */
  UINT8 JFIF_major_version;	/* What to write for the JFIF version number */
  UINT8 JFIF_minor_version;
  /* These three values are not used by the JPEG code, merely copied */
  /* into the JFIF APP0 marker.  density_unit can be 0 for unknown, */
  /* 1 for dots/inch, or 2 for dots/cm.  Note that the pixel aspect */
  /* ratio is defined by X_density/Y_density even when density_unit=0. */
  UINT8 density_unit;		/* JFIF code for pixel size units */
  UINT16 X_density;		/* Horizontal pixel density */
  UINT16 Y_density;		/* Vertical pixel density */
  boolean write_Adobe_marker;	/* should an Adobe marker be written? */
  
  /* State variable: index of next scanline to be written to
   * jpeg_write_scanlines().  Application may use this to control its
   * processing loop, e.g., "while (next_scanline < image_height)".
   */

  JDIMENSION next_scanline;	/* 0 .. image_height-1  */

  /* Remaining fields are known throughout compressor, but generally
   * should not be touched by a surrounding application.
   */

  /*
   * These fields are computed during compression startup
   */
  boolean progressive_mode;	/* TRUE if scan script uses progressive mode */
  int max_h_samp_factor;	/* largest h_samp_factor */
  int max_v_samp_factor;	/* largest v_samp_factor */

  int min_DCT_h_scaled_size;	/* smallest DCT_h_scaled_size of any component */
  int min_DCT_v_scaled_size;	/* smallest DCT_v_scaled_size of any component */

  JDIMENSION total_iMCU_rows;	/* # of iMCU rows to be input to coef ctlr */
  /* The coefficient controller receives data in units of MCU rows as defined
   * for fully interleaved scans (whether the JPEG file is interleaved or not).
   * There are v_samp_factor * DCTSIZE sample rows of each component in an
   * "iMCU" (interleaved MCU) row.
   */
  
  /*
   * These fields are valid during any one scan.
   * They describe the components and MCUs actually appearing in the scan.
   */
  int comps_in_scan;		/* # of JPEG components in this scan */
  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
  /* *cur_comp_info[i] describes component that appears i'th in SOS */
  
  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
  
  int blocks_in_MCU;		/* # of DCT blocks per MCU */
  int MCU_membership[C_MAX_BLOCKS_IN_MCU];
  /* MCU_membership[i] is index in cur_comp_info of component owning */
  /* i'th block in an MCU */

  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */

  int block_size;		/* the basic DCT block size: 1..16 */
#ifdef RISCOS /* More compact form */
  const char * natural_order;	/* natural-order position array */
#else
  const int * natural_order;	/* natural-order position array */
#endif
  int lim_Se;			/* min( Se, DCTSIZE2-1 ) */

  /*
   * Links to compression subobjects (methods and private variables of modules)
   */
  struct jpeg_comp_master * master;
  struct jpeg_c_main_controller * main;
  struct jpeg_c_prep_controller * prep;
  struct jpeg_c_coef_controller * coef;
  struct jpeg_marker_writer * marker;
  struct jpeg_color_converter * cconvert;
  struct jpeg_downsampler * downsample;
  struct jpeg_forward_dct * fdct;
  struct jpeg_entropy_encoder * entropy;
  jpeg_scan_info * script_space; /* workspace for jpeg_simple_progression */
  int script_space_size;
};


/* Master record for a decompression instance */

struct jpeg_decompress_struct {
  jpeg_common_fields;		/* Fields shared with jpeg_compress_struct */

  /* Source of compressed data */
  struct jpeg_source_mgr * src;

  /* Basic description of image --- filled in by jpeg_read_header(). */
  /* Application may inspect these values to decide how to process image. */

  JDIMENSION image_width;	/* nominal image width (from SOF marker) */
  JDIMENSION image_height;	/* nominal image height */
  int num_components;		/* # of color components in JPEG image */
  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */

  /* Decompression processing parameters --- these fields must be set before
   * calling jpeg_start_decompress().  Note that jpeg_read_header() initializes
   * them to default values.
   */

  J_COLOR_SPACE out_color_space; /* colorspace for output */

  unsigned int scale_num, scale_denom; /* fraction by which to scale image */

  double output_gamma;		/* image gamma wanted in output */

  boolean buffered_image;	/* TRUE=multiple output passes */
  boolean raw_data_out;		/* TRUE=downsampled data wanted */

  J_DCT_METHOD dct_method;	/* IDCT algorithm selector */
  boolean do_fancy_upsampling;	/* TRUE=apply fancy upsampling */
  boolean do_block_smoothing;	/* TRUE=apply interblock smoothing */

  boolean quantize_colors;	/* TRUE=colormapped output wanted */
  /* the following are ignored if not quantize_colors: */
  J_DITHER_MODE dither_mode;	/* type of color dithering to use */
  boolean two_pass_quantize;	/* TRUE=use two-pass color quantization */
  int desired_number_of_colors;	/* max # colors to use in created colormap */
  /* these are significant only in buffered-image mode: */
  boolean enable_1pass_quant;	/* enable future use of 1-pass quantizer */
  boolean enable_external_quant;/* enable future use of external colormap */
  boolean enable_2pass_quant;	/* enable future use of 2-pass quantizer */

  /* Description of actual output image that will be returned to application.
   * These fields are computed by jpeg_start_decompress().
   * You can also use jpeg_calc_output_dimensions() to determine these values
   * in advance of calling jpeg_start_decompress().
   */

  JDIMENSION output_width;	/* scaled image width */
  JDIMENSION output_height;	/* scaled image height */
  int out_color_components;	/* # of color components in out_color_space */
  int output_components;	/* # of color components returned */
  /* output_components is 1 (a colormap index) when quantizing colors;
   * otherwise it equals out_color_components.
   */
  int rec_outbuf_height;	/* min recommended height of scanline buffer */
  /* If the buffer passed to jpeg_read_scanlines() is less than this many rows
   * high, space and time will be wasted due to unnecessary data copying.
   * Usually rec_outbuf_height will be 1 or 2, at most 4.
   */

  /* When quantizing colors, the output colormap is described by these fields.
   * The application can supply a colormap by setting colormap non-NULL before
   * calling jpeg_start_decompress; otherwise a colormap is created during
   * jpeg_start_decompress or jpeg_start_output.
   * The map has out_color_components rows and actual_number_of_colors columns.
   */
  int actual_number_of_colors;	/* number of entries in use */
  JSAMPARRAY colormap;		/* The color map as a 2-D pixel array */

  /* State variables: these variables indicate the progress of decompression.
   * The application may examine these but must not modify them.
   */

  /* Row index of next scanline to be read from jpeg_read_scanlines().
   * Application may use this to control its processing loop, e.g.,
   * "while (output_scanline < output_height)".
   */
  JDIMENSION output_scanline;	/* 0 .. output_height-1  */

  /* Current input scan number and number of iMCU rows completed in scan.
   * These indicate the progress of the decompressor input side.
   */
  int input_scan_number;	/* Number of SOS markers seen so far */
  JDIMENSION input_iMCU_row;	/* Number of iMCU rows completed */

  /* The "output scan number" is the notional scan being displayed by the
   * output side.  The decompressor will not allow output scan/row number
   * to get ahead of input scan/row, but it can fall arbitrarily far behind.
   */
  int output_scan_number;	/* Nominal scan number being displayed */
  JDIMENSION output_iMCU_row;	/* Number of iMCU rows read */

  /* Current progression status.  coef_bits[c][i] indicates the precision
   * with which component c's DCT coefficient i (in zigzag order) is known.
   * It is -1 when no data has yet been received, otherwise it is the point
   * transform (shift) value for the most recent scan of the coefficient
   * (thus, 0 at completion of the progression).
   * This pointer is NULL when reading a non-progressive file.
   */
  int (*coef_bits)[DCTSIZE2];	/* -1 or current Al value for each coef */

  /* Internal JPEG parameters --- the application usually need not look at
   * these fields.  Note that the decompressor output side may not use
   * any parameters that can change between scans.
   */

  /* Quantization and Huffman tables are carried forward across input
   * datastreams when processing abbreviated JPEG datastreams.
   */

  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
  /* ptrs to coefficient quantization tables, or NULL if not defined */

  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
  /* ptrs to Huffman coding tables, or NULL if not defined */

  /* These parameters are never carried across datastreams, since they
   * are given in SOF/SOS markers or defined to be reset by SOI.
   */

  int data_precision;		/* bits of precision in image data */

  jpeg_component_info * comp_info;
  /* comp_info[i] describes component that appears i'th in SOF */

  boolean is_baseline;		/* TRUE if Baseline SOF0 encountered */
  boolean progressive_mode;	/* TRUE if SOFn specifies progressive mode */
  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */

  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */

  unsigned int restart_interval; /* MCUs per restart interval, or 0 for no restart */

  /* These fields record data obtained from optional markers recognized by
   * the JPEG library.
   */
  boolean saw_JFIF_marker;	/* TRUE iff a JFIF APP0 marker was found */
  /* Data copied from JFIF marker; only valid if saw_JFIF_marker is TRUE: */
  UINT8 JFIF_major_version;	/* JFIF version number */
  UINT8 JFIF_minor_version;
  UINT8 density_unit;		/* JFIF code for pixel size units */
  UINT16 X_density;		/* Horizontal pixel density */
  UINT16 Y_density;		/* Vertical pixel density */
  boolean saw_Adobe_marker;	/* TRUE iff an Adobe APP14 marker was found */
  UINT8 Adobe_transform;	/* Color transform code from Adobe marker */

  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */

  /* Aside from the specific data retained from APPn markers known to the
   * library, the uninterpreted contents of any or all APPn and COM markers
   * can be saved in a list for examination by the application.
   */
  jpeg_saved_marker_ptr marker_list; /* Head of list of saved markers */

  /* Remaining fields are known throughout decompressor, but generally
   * should not be touched by a surrounding application.
   */

  /*
   * These fields are computed during decompression startup
   */
  int max_h_samp_factor;	/* largest h_samp_factor */
  int max_v_samp_factor;	/* largest v_samp_factor */

  int min_DCT_h_scaled_size;	/* smallest DCT_h_scaled_size of any component */
  int min_DCT_v_scaled_size;	/* smallest DCT_v_scaled_size of any component */

  JDIMENSION total_iMCU_rows;	/* # of iMCU rows in image */
  /* The coefficient controller's input and output progress is measured in
   * units of "iMCU" (interleaved MCU) rows.  These are the same as MCU rows
   * in fully interleaved JPEG scans, but are used whether the scan is
   * interleaved or not.  We define an iMCU row as v_samp_factor DCT block
   * rows of each component.  Therefore, the IDCT output contains
   * v_samp_factor*DCT_v_scaled_size sample rows of a component per iMCU row.
   */

  JSAMPLE * sample_range_limit; /* table for fast range-limiting */

  /*
   * These fields are valid during any one scan.
   * They describe the components and MCUs actually appearing in the scan.
   * Note that the decompressor output side must not use these fields.
   */
  int comps_in_scan;		/* # of JPEG components in this scan */
  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
  /* *cur_comp_info[i] describes component that appears i'th in SOS */

  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */

  int blocks_in_MCU;		/* # of DCT blocks per MCU */
  int MCU_membership[D_MAX_BLOCKS_IN_MCU];
  /* MCU_membership[i] is index in cur_comp_info of component owning */
  /* i'th block in an MCU */

  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */

  /* These fields are derived from Se of first SOS marker.
   */
  int block_size;		/* the basic DCT block size: 1..16 */
#ifdef RISCOS /* More compact form */
  const char * natural_order; /* natural-order position array for entropy decode */
#else
  const int * natural_order; /* natural-order position array for entropy decode */
#endif
  int lim_Se;			/* min( Se, DCTSIZE2-1 ) for entropy decode */

  /* This field is shared between entropy decoder and marker parser.
   * It is either zero or the code of a JPEG marker that has been
   * read from the data source, but has not yet been processed.
   */
  int unread_marker;

  /*
   * Links to decompression subobjects (methods, private variables of modules)
   */
  struct jpeg_decomp_master * master;
  struct jpeg_d_main_controller * main;
  struct jpeg_d_coef_controller * coef;
  struct jpeg_d_post_controller * post;
  struct jpeg_input_controller * inputctl;
  struct jpeg_marker_reader * marker;
  struct jpeg_entropy_decoder * entropy;
  struct jpeg_inverse_dct * idct;
  struct jpeg_upsampler * upsample;
  struct jpeg_color_deconverter * cconvert;
  struct jpeg_color_quantizer * cquantize;

#ifdef RISCOS /* Extra state */
  /* Render options */
  int options;
  int orgoptions;
  int pixelformat;

  /* How big the dynamic area is */
  size_t workspace_size;

  /* Min and max x pixels required: clip as early as possible. */
  int xmin;
  int xmax;

  /* Avoid divides of MCU size in pixels */
  int l2_mcu_height;
  int l2_mcu_width;

  /* The 16bpp->8bpp 32K lookup table, if you need it */
  char *table32k;
  boolean table32k_unavailable; /* Set if we ever failed to get table32k */

  /* Cached pointer to the compact arithmetic table */
  const INT32 *jpeg_aritab;
  
  /* Random access within the Huffman stream */
  int current_huff_pointer;    /* Currently loaded band, or -1 if none. */
  huff_pointer *huff_pointers; /* For quick random access */
  boolean huff_pointer_pass;   /* Fast pass, to get the random access pointers */

  /* Buffer of size MCU height x image width */
  JSAMPARRAY band_buffer;  /* Pointers to the rows of output bands */
  size_t band_buffer_size; /* Band size (not inc. the overhead of JSAMPROW pointers) */

  /* The compressed JPEG buffer */
  const JOCTET *jpeg_buffer;      /* Location of the JPEG currently being plotted */
  size_t jpeg_buffer_size;        /* Buffer extent */
  const JOCTET *jpeg_user_buffer; /* Pointer the user passed in, before any transcoding */
  size_t jpeg_user_buffer_size;   /* Buffer extent */
  int check1, check2, check3;     /* Random check words to see if this is a JPEG we've seen before */

  /* Return values */
  int error_code;      /* Returned err code, 0 if no error */
  int error_argument;  /* Supplementary error data */

  /* Pool for alloc, at least large enough to hold jpeg_memory_mgr, must be last! */
  int small_pool[32];
  /* Don't add anything after small_pool as it'll get allocated over! */
#endif
};


/* "Object" declarations for JPEG modules that may be supplied or called
 * directly by the surrounding application.
 * As with all objects in the JPEG library, these structs only define the
 * publicly visible methods and state variables of a module.  Additional
 * private fields may exist after the public ones.
 */


/* Error handler object */

struct jpeg_error_mgr {
  /* Error exit handler: does not return to caller */
  JMETHOD(void, error_exit, (j_common_ptr cinfo));
  /* Conditionally emit a trace or warning message */
  JMETHOD(void, emit_message, (j_common_ptr cinfo, int msg_level));
  /* Routine that actually outputs a trace or error message */
  JMETHOD(void, output_message, (j_common_ptr cinfo));
  /* Format a message string for the most recent JPEG error or message */
  JMETHOD(void, format_message, (j_common_ptr cinfo, char * buffer));
#define JMSG_LENGTH_MAX  200	/* recommended size of format_message buffer */
  /* Reset error state variables at start of a new image */
  JMETHOD(void, reset_error_mgr, (j_common_ptr cinfo));
  
  /* The message ID code and any parameters are saved here.
   * A message can have one string parameter or up to 8 int parameters.
   */
  int msg_code;
#define JMSG_STR_PARM_MAX  80
  union {
    int i[8];
    char s[JMSG_STR_PARM_MAX];
  } msg_parm;
  
  /* Standard state variables for error facility */
  
  int trace_level;		/* max msg_level that will be displayed */
  
  /* For recoverable corrupt-data errors, we emit a warning message,
   * but keep going unless emit_message chooses to abort.  emit_message
   * should count warnings in num_warnings.  The surrounding application
   * can check for bad data by seeing if num_warnings is nonzero at the
   * end of processing.
   */
  long num_warnings;		/* number of corrupt-data warnings */

  /* These fields point to the table(s) of error message strings.
   * An application can change the table pointer to switch to a different
   * message list (typically, to change the language in which errors are
   * reported).  Some applications may wish to add additional error codes
   * that will be handled by the JPEG library error mechanism; the second
   * table pointer is used for this purpose.
   *
   * First table includes all errors generated by JPEG library itself.
   * Error code 0 is reserved for a "no such error string" message.
   */
  const char * const * jpeg_message_table; /* Library errors */
  int last_jpeg_message;    /* Table contains strings 0..last_jpeg_message */
  /* Second table can be added by application (see cjpeg/djpeg for example).
   * It contains strings numbered first_addon_message..last_addon_message.
   */
  const char * const * addon_message_table; /* Non-library errors */
  int first_addon_message;	/* code for first string in addon table */
  int last_addon_message;	/* code for last string in addon table */
};


/* Progress monitor object */

struct jpeg_progress_mgr {
  JMETHOD(void, progress_monitor, (j_common_ptr cinfo));

  long pass_counter;		/* work units completed in this pass */
  long pass_limit;		/* total number of work units in this pass */
  int completed_passes;		/* passes completed so far */
  int total_passes;		/* total number of passes expected */
};


/* Data destination object for compression */

struct jpeg_destination_mgr {
  JOCTET * next_output_byte;	/* => next byte to write in buffer */
  size_t free_in_buffer;	/* # of byte spaces remaining in buffer */

  JMETHOD(void, init_destination, (j_compress_ptr cinfo));
  JMETHOD(boolean, empty_output_buffer, (j_compress_ptr cinfo));
  JMETHOD(void, term_destination, (j_compress_ptr cinfo));
};


/* Data source object for decompression */

struct jpeg_source_mgr {
  const JOCTET * next_input_byte; /* => next byte to read from buffer */
  size_t bytes_in_buffer;	/* # of bytes remaining in buffer */

  JMETHOD(void, init_source, (j_decompress_ptr cinfo));
  JMETHOD(boolean, fill_input_buffer, (j_decompress_ptr cinfo));
  JMETHOD(void, skip_input_data, (j_decompress_ptr cinfo, long num_bytes));
  JMETHOD(boolean, resync_to_restart, (j_decompress_ptr cinfo, int desired));
  JMETHOD(void, term_source, (j_decompress_ptr cinfo));
};


/* Memory manager object.
 * Allocates "small" objects (a few K total), "large" objects (tens of K),
 * and "really big" objects (virtual arrays with backing store if needed).
 * The memory manager does not allow individual objects to be freed; rather,
 * each created object is assigned to a pool, and whole pools can be freed
 * at once.  This is faster and more convenient than remembering exactly what
 * to free, especially where malloc()/free() are not too speedy.
 * NB: alloc routines never return NULL.  They exit to error_exit if not
 * successful.
 */

#define JPOOL_PERMANENT	0	/* lasts until master record is destroyed */
#define JPOOL_IMAGE	1	/* lasts until done with image/datastream */
#define JPOOL_NUMPOOLS	2

typedef struct jvirt_sarray_control * jvirt_sarray_ptr;
typedef struct jvirt_barray_control * jvirt_barray_ptr;


struct jpeg_memory_mgr {
  /* Method pointers */
  JMETHOD(void *, alloc_small, (j_common_ptr cinfo, int pool_id,
				size_t sizeofobject));
  JMETHOD(void FAR *, alloc_large, (j_common_ptr cinfo, int pool_id,
				     size_t sizeofobject));
  JMETHOD(JSAMPARRAY, alloc_sarray, (j_common_ptr cinfo, int pool_id,
				     JDIMENSION samplesperrow,
				     JDIMENSION numrows));
  JMETHOD(JBLOCKARRAY, alloc_barray, (j_common_ptr cinfo, int pool_id,
				      JDIMENSION blocksperrow,
				      JDIMENSION numrows));
  JMETHOD(jvirt_sarray_ptr, request_virt_sarray, (j_common_ptr cinfo,
						  int pool_id,
						  boolean pre_zero,
						  JDIMENSION samplesperrow,
						  JDIMENSION numrows,
						  JDIMENSION maxaccess));
  JMETHOD(jvirt_barray_ptr, request_virt_barray, (j_common_ptr cinfo,
						  int pool_id,
						  boolean pre_zero,
						  JDIMENSION blocksperrow,
						  JDIMENSION numrows,
						  JDIMENSION maxaccess));
  JMETHOD(void, realize_virt_arrays, (j_common_ptr cinfo));
  JMETHOD(JSAMPARRAY, access_virt_sarray, (j_common_ptr cinfo,
					   jvirt_sarray_ptr ptr,
					   JDIMENSION start_row,
					   JDIMENSION num_rows,
					   boolean writable));
  JMETHOD(JBLOCKARRAY, access_virt_barray, (j_common_ptr cinfo,
					    jvirt_barray_ptr ptr,
					    JDIMENSION start_row,
					    JDIMENSION num_rows,
					    boolean writable));
  JMETHOD(void, free_pool, (j_common_ptr cinfo, int pool_id));
  JMETHOD(void, self_destruct, (j_common_ptr cinfo));

  /* Limit on memory allocation for this JPEG object.  (Note that this is
   * merely advisory, not a guaranteed maximum; it only affects the space
   * used for virtual-array buffers.)  May be changed by outer application
   * after creating the JPEG object.
   */
  long max_memory_to_use;

  /* Maximum allocation request accepted by alloc_large. */
  long max_alloc_chunk;
#ifdef RISCOS /* Extra state */ 
  jvirt_barray_ptr virt_barray_list;
  JOCTET *coef_buffer;
  size_t coef_buffer_size;
  size_t high_watermark;
  int * small_pool;
#endif    
};


/* Routine signature for application-supplied marker processing methods.
 * Need not pass marker code since it is stored in cinfo->unread_marker.
 */
typedef JMETHOD(boolean, jpeg_marker_parser_method, (j_decompress_ptr cinfo));


/* Declarations for routines called by application.
 * The JPP macro hides prototype parameters from compilers that can't cope.
 * Note JPP requires double parentheses.
 */

#ifdef HAVE_PROTOTYPES
#define JPP(arglist)	arglist
#else
#define JPP(arglist)	()
#endif


/* Short forms of external names for systems with brain-damaged linkers.
 * We shorten external names to be unique in the first six letters, which
 * is good enough for all known systems.
 * (If your compiler itself needs names to be unique in less than 15 
 * characters, you are out of luck.  Get a better compiler.)
 */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jpeg_std_error		jStdError
#define jpeg_CreateCompress	jCreaCompress
#define jpeg_CreateDecompress	jCreaDecompress
#define jpeg_destroy_compress	jDestCompress
#define jpeg_destroy_decompress	jDestDecompress
#define jpeg_stdio_dest		jStdDest
#define jpeg_stdio_src		jStdSrc
#define jpeg_mem_dest		jMemDest
#define jpeg_mem_src		jMemSrc
#define jpeg_set_defaults	jSetDefaults
#define jpeg_set_colorspace	jSetColorspace
#define jpeg_default_colorspace	jDefColorspace
#define jpeg_set_quality	jSetQuality
#define jpeg_set_linear_quality	jSetLQuality
#define jpeg_default_qtables	jDefQTables
#define jpeg_add_quant_table	jAddQuantTable
#define jpeg_quality_scaling	jQualityScaling
#define jpeg_simple_progression	jSimProgress
#define jpeg_suppress_tables	jSuppressTables
#define jpeg_alloc_quant_table	jAlcQTable
#define jpeg_alloc_huff_table	jAlcHTable
#define jpeg_start_compress	jStrtCompress
#define jpeg_write_scanlines	jWrtScanlines
#define jpeg_finish_compress	jFinCompress
#define jpeg_calc_jpeg_dimensions	jCjpegDimensions
#define jpeg_write_raw_data	jWrtRawData
#define jpeg_write_marker	jWrtMarker
#define jpeg_write_m_header	jWrtMHeader
#define jpeg_write_m_byte	jWrtMByte
#define jpeg_write_tables	jWrtTables
#define jpeg_read_header	jReadHeader
#define jpeg_start_decompress	jStrtDecompress
#define jpeg_read_scanlines	jReadScanlines
#define jpeg_finish_decompress	jFinDecompress
#define jpeg_read_raw_data	jReadRawData
#define jpeg_has_multiple_scans	jHasMultScn
#define jpeg_start_output	jStrtOutput
#define jpeg_finish_output	jFinOutput
#define jpeg_input_complete	jInComplete
#define jpeg_new_colormap	jNewCMap
#define jpeg_consume_input	jConsumeInput
#define jpeg_core_output_dimensions	jCoreDimensions
#define jpeg_calc_output_dimensions	jCalcDimensions
#define jpeg_save_markers	jSaveMarkers
#define jpeg_set_marker_processor	jSetMarker
#define jpeg_read_coefficients	jReadCoefs
#define jpeg_write_coefficients	jWrtCoefs
#define jpeg_copy_critical_parameters	jCopyCrit
#define jpeg_abort_compress	jAbrtCompress
#define jpeg_abort_decompress	jAbrtDecompress
#define jpeg_abort		jAbort
#define jpeg_destroy		jDestroy
#define jpeg_resync_to_restart	jResyncRestart
#endif /* NEED_SHORT_EXTERNAL_NAMES */


/* Default error-management setup */
EXTERN(struct jpeg_error_mgr *) jpeg_std_error
	JPP((struct jpeg_error_mgr * err));

/* Initialization of JPEG compression objects.
 * jpeg_create_compress() and jpeg_create_decompress() are the exported
 * names that applications should call.  These expand to calls on
 * jpeg_CreateCompress and jpeg_CreateDecompress with additional information
 * passed for version mismatch checking.
 * NB: you must set up the error-manager BEFORE calling jpeg_create_xxx.
 */
#define jpeg_create_compress(cinfo) \
    jpeg_CreateCompress((cinfo), JPEG_LIB_VERSION, \
			(size_t) sizeof(struct jpeg_compress_struct))
#define jpeg_create_decompress(cinfo) \
    jpeg_CreateDecompress((cinfo), JPEG_LIB_VERSION, \
			  (size_t) sizeof(struct jpeg_decompress_struct))
EXTERN(void) jpeg_CreateCompress JPP((j_compress_ptr cinfo,
				      int version, size_t structsize));
EXTERN(void) jpeg_CreateDecompress JPP((j_decompress_ptr cinfo,
					int version, size_t structsize));
/* Destruction of JPEG compression objects */
EXTERN(void) jpeg_destroy_compress JPP((j_compress_ptr cinfo));
EXTERN(void) jpeg_destroy_decompress JPP((j_decompress_ptr cinfo));

/* Standard data source and destination managers: stdio streams. */
/* Caller is responsible for opening the file before and closing after. */
EXTERN(void) jpeg_stdio_dest JPP((j_compress_ptr cinfo, FILE * outfile));
EXTERN(void) jpeg_stdio_src JPP((j_decompress_ptr cinfo, FILE * infile));

/* Data source and destination managers: memory buffers. */
EXTERN(void) jpeg_mem_dest JPP((j_compress_ptr cinfo,
			       unsigned char ** outbuffer,
			       unsigned long * outsize));
EXTERN(void) jpeg_mem_src JPP((j_decompress_ptr cinfo,
			      unsigned char * inbuffer,
			      unsigned long insize));

/* Default parameter setup for compression */
EXTERN(void) jpeg_set_defaults JPP((j_compress_ptr cinfo));
/* Compression parameter setup aids */
EXTERN(void) jpeg_set_colorspace JPP((j_compress_ptr cinfo,
				      J_COLOR_SPACE colorspace));
EXTERN(void) jpeg_default_colorspace JPP((j_compress_ptr cinfo));
EXTERN(void) jpeg_set_quality JPP((j_compress_ptr cinfo, int quality,
				   boolean force_baseline));
EXTERN(void) jpeg_set_linear_quality JPP((j_compress_ptr cinfo,
					  int scale_factor,
					  boolean force_baseline));
EXTERN(void) jpeg_default_qtables JPP((j_compress_ptr cinfo,
				       boolean force_baseline));
#ifdef RISCOS /* More compact form */
EXTERN(void) jpeg_add_quant_table JPP((j_compress_ptr cinfo, int which_tbl,
				       const unsigned char *basic_table,
				       int scale_factor,
				       boolean force_baseline));
#else
EXTERN(void) jpeg_add_quant_table JPP((j_compress_ptr cinfo, int which_tbl,
				       const unsigned int *basic_table,
				       int scale_factor,
				       boolean force_baseline));
#endif       
EXTERN(int) jpeg_quality_scaling JPP((int quality));
EXTERN(void) jpeg_simple_progression JPP((j_compress_ptr cinfo));
EXTERN(void) jpeg_suppress_tables JPP((j_compress_ptr cinfo,
				       boolean suppress));
EXTERN(JQUANT_TBL *) jpeg_alloc_quant_table JPP((j_common_ptr cinfo));
EXTERN(JHUFF_TBL *) jpeg_alloc_huff_table JPP((j_common_ptr cinfo));

/* Main entry points for compression */
EXTERN(void) jpeg_start_compress JPP((j_compress_ptr cinfo,
				      boolean write_all_tables));
EXTERN(JDIMENSION) jpeg_write_scanlines JPP((j_compress_ptr cinfo,
					     JSAMPARRAY scanlines,
					     JDIMENSION num_lines));
EXTERN(void) jpeg_finish_compress JPP((j_compress_ptr cinfo));

/* Precalculate JPEG dimensions for current compression parameters. */
EXTERN(void) jpeg_calc_jpeg_dimensions JPP((j_compress_ptr cinfo));

/* Replaces jpeg_write_scanlines when writing raw downsampled data. */
EXTERN(JDIMENSION) jpeg_write_raw_data JPP((j_compress_ptr cinfo,
					    JSAMPIMAGE data,
					    JDIMENSION num_lines));

/* Write a special marker.  See libjpeg.txt concerning safe usage. */
EXTERN(void) jpeg_write_marker
	JPP((j_compress_ptr cinfo, int marker,
	     const JOCTET * dataptr, unsigned int datalen));
/* Same, but piecemeal. */
EXTERN(void) jpeg_write_m_header
	JPP((j_compress_ptr cinfo, int marker, unsigned int datalen));
EXTERN(void) jpeg_write_m_byte
	JPP((j_compress_ptr cinfo, int val));

/* Alternate compression function: just write an abbreviated table file */
EXTERN(void) jpeg_write_tables JPP((j_compress_ptr cinfo));

/* Decompression startup: read start of JPEG datastream to see what's there */
EXTERN(int) jpeg_read_header JPP((j_decompress_ptr cinfo,
				  boolean require_image));
/* Return value is one of: */
#define JPEG_SUSPENDED		0 /* Suspended due to lack of input data */
#define JPEG_HEADER_OK		1 /* Found valid image datastream */
#define JPEG_HEADER_TABLES_ONLY	2 /* Found valid table-specs-only datastream */
/* If you pass require_image = TRUE (normal case), you need not check for
 * a TABLES_ONLY return code; an abbreviated file will cause an error exit.
 * JPEG_SUSPENDED is only possible if you use a data source module that can
 * give a suspension return (the stdio source module doesn't).
 */

/* Main entry points for decompression */
EXTERN(boolean) jpeg_start_decompress JPP((j_decompress_ptr cinfo));
EXTERN(JDIMENSION) jpeg_read_scanlines JPP((j_decompress_ptr cinfo,
					    JSAMPARRAY scanlines,
					    JDIMENSION max_lines));
EXTERN(boolean) jpeg_finish_decompress JPP((j_decompress_ptr cinfo));

/* Replaces jpeg_read_scanlines when reading raw downsampled data. */
EXTERN(JDIMENSION) jpeg_read_raw_data JPP((j_decompress_ptr cinfo,
					   JSAMPIMAGE data,
					   JDIMENSION max_lines));

/* Additional entry points for buffered-image mode. */
EXTERN(boolean) jpeg_has_multiple_scans JPP((j_decompress_ptr cinfo));
EXTERN(boolean) jpeg_start_output JPP((j_decompress_ptr cinfo,
				       int scan_number));
EXTERN(boolean) jpeg_finish_output JPP((j_decompress_ptr cinfo));
EXTERN(boolean) jpeg_input_complete JPP((j_decompress_ptr cinfo));
EXTERN(void) jpeg_new_colormap JPP((j_decompress_ptr cinfo));
EXTERN(int) jpeg_consume_input JPP((j_decompress_ptr cinfo));
/* Return value is one of: */
/* #define JPEG_SUSPENDED	0    Suspended due to lack of input data */
#define JPEG_REACHED_SOS	1 /* Reached start of new scan */
#define JPEG_REACHED_EOI	2 /* Reached end of image */
#define JPEG_ROW_COMPLETED	3 /* Completed one iMCU row */
#define JPEG_SCAN_COMPLETED	4 /* Completed last iMCU row of a scan */

/* Precalculate output dimensions for current decompression parameters. */
EXTERN(void) jpeg_core_output_dimensions JPP((j_decompress_ptr cinfo));
EXTERN(void) jpeg_calc_output_dimensions JPP((j_decompress_ptr cinfo));

/* Control saving of COM and APPn markers into marker_list. */
EXTERN(void) jpeg_save_markers
	JPP((j_decompress_ptr cinfo, int marker_code,
	     unsigned int length_limit));

/* Install a special processing method for COM or APPn markers. */
EXTERN(void) jpeg_set_marker_processor
	JPP((j_decompress_ptr cinfo, int marker_code,
	     jpeg_marker_parser_method routine));

/* Read or write raw DCT coefficients --- useful for lossless transcoding. */
EXTERN(jvirt_barray_ptr *) jpeg_read_coefficients JPP((j_decompress_ptr cinfo));
EXTERN(void) jpeg_write_coefficients JPP((j_compress_ptr cinfo,
					  jvirt_barray_ptr * coef_arrays));
EXTERN(void) jpeg_copy_critical_parameters JPP((j_decompress_ptr srcinfo,
						j_compress_ptr dstinfo));

/* If you choose to abort compression or decompression before completing
 * jpeg_finish_(de)compress, then you need to clean up to release memory,
 * temporary files, etc.  You can just call jpeg_destroy_(de)compress
 * if you're done with the JPEG object, but if you want to clean it up and
 * reuse it, call this:
 */
EXTERN(void) jpeg_abort_compress JPP((j_compress_ptr cinfo));
EXTERN(void) jpeg_abort_decompress JPP((j_decompress_ptr cinfo));

/* Generic versions of jpeg_abort and jpeg_destroy that work on either
 * flavor of JPEG object.  These may be more convenient in some places.
 */
EXTERN(void) jpeg_abort JPP((j_common_ptr cinfo));
EXTERN(void) jpeg_destroy JPP((j_common_ptr cinfo));

/* Default restart-marker-resync procedure for use by data source modules */
EXTERN(boolean) jpeg_resync_to_restart JPP((j_decompress_ptr cinfo,
					    int desired));


/* These marker codes are exported since applications and data source modules
 * are likely to want to use them.
 */

#define JPEG_RST0	0xD0	/* RST0 marker code */
#define JPEG_EOI	0xD9	/* EOI marker code */
#define JPEG_APP0	0xE0	/* APP0 marker code */
#define JPEG_COM	0xFE	/* COM marker code */


/* If we have a brain-damaged compiler that emits warnings (or worse, errors)
 * for structure definitions that are never filled in, keep it quiet by
 * supplying dummy definitions for the various substructures.
 */

#ifdef INCOMPLETE_TYPES_BROKEN
#ifndef JPEG_INTERNALS		/* will be defined in jpegint.h */
struct jvirt_sarray_control { long dummy; };
struct jvirt_barray_control { long dummy; };
struct jpeg_comp_master { long dummy; };
struct jpeg_c_main_controller { long dummy; };
struct jpeg_c_prep_controller { long dummy; };
struct jpeg_c_coef_controller { long dummy; };
struct jpeg_marker_writer { long dummy; };
struct jpeg_color_converter { long dummy; };
struct jpeg_downsampler { long dummy; };
struct jpeg_forward_dct { long dummy; };
struct jpeg_entropy_encoder { long dummy; };
struct jpeg_decomp_master { long dummy; };
struct jpeg_d_main_controller { long dummy; };
struct jpeg_d_coef_controller { long dummy; };
struct jpeg_d_post_controller { long dummy; };
struct jpeg_input_controller { long dummy; };
struct jpeg_marker_reader { long dummy; };
struct jpeg_entropy_decoder { long dummy; };
struct jpeg_inverse_dct { long dummy; };
struct jpeg_upsampler { long dummy; };
struct jpeg_color_deconverter { long dummy; };
struct jpeg_color_quantizer { long dummy; };
#endif /* JPEG_INTERNALS */
#endif /* INCOMPLETE_TYPES_BROKEN */


/*
 * The JPEG library modules define JPEG_INTERNALS before including this file.
 * The internal structure declarations are read only when that is true.
 * Applications using the library should not include jpegint.h, but may wish
 * to include jerror.h.
 */

#ifdef JPEG_INTERNALS
#include "jpegint.h"		/* fetch private declarations */
#include "jerror.h"		/* fetch error codes too */
#endif

#ifdef __cplusplus
#ifndef DONT_USE_EXTERN_C
}
#endif
#endif

#endif /* JPEGLIB_H */
@


4.5
log
@Bug fixes
Detail:
  Remove the unused gray (sic) output colour space support. Remove the patches to set output colour space to RGB, this can be overridden in code per the design intent of the library. Only decode luma for grey output.
  Fix bug rendering test image monorose2x4 - this was caused by the huffman pointer saving not decoding enough MCUs when the source image is monochrome hence an MCU outputs 8x8 rather than hsamp x vsamp pixels. Also removed the setting of insufficient_data in the entropy decoder, this meant that any error at the end of the image (eg. truncated) would cause the rest of the image to not render because JPEGs are stored top down but RISC OS plots them bottom up.
  Fix endless failure to match previously cached JPEG, especially at 16bpp, when the source JPEG doesn't meet the fast colour conversion criteria (eg. not 2x2 subsampling). The flags test was checking the requested flags against the filtered flags, which never matched (because the unmet options get cleared). Now, keep the original flags prior to filtering and compare those on the basis that the conversion decision will be consistent; simply ANDing out those modifiable flags doesn't help because then you can't spot when they genuinely change (eg. a mode change) as the filtered flags determine what format the blitter is expecting back.
  Fix bug causing aborts when the user manually resizes (down) the JPEG workspace DA. The calculation of new_size in jpeg_find_image_dims() had at some point lost the height multiplier on the band buffer, so when auto resizing back up again the buffer was too small to convert a whole band into.
Admin:
  Submission for the JPEG bounty.

Version 1.74. Tagged as 'SprExtend-1_74'
@
text
@d717 4
@


4.4
log
@Transcode arithmetics
Detail:
  Import of the raw coefficient Huffman entropy compressor elements of the IJG8d library.
  We don't need a full compressor (ala JCompMod) since there's never a need to go all the way through IDCT/upsampling/colour conversion only to reverse the whole process; it's sufficient only to collect up the raw coefficients and recompress them as a baseline JPEG.
  Two extra (temporary) dynamic areas are introduced, once to hold the raw coefficients and the other to act as a scratch file to make the JPEG in. See Doc/JPEGMmgr.
Admin:
  Submission for the JPEG bounty.

Version 1.72. Tagged as 'SprExtend-1_72'
@
text
@d707 1
d921 1
a921 1
#ifdef RISCOS
@


4.3
log
@Import of IJG8d library sources
Detail:
  Using the decoder in "example.c" as a starting point, we try to follow that sequence more closely even if in our embedded implementation some of the functions don't do much.
  Uses the default colour backend for 32bpp BGR output for most of the unusual cases.
  The most common 2x2 subsampling case uses a custom merged upsampler and colour converter, with colour output directly in RISC OS format for the respective screen mode.
Admin:
  Submission for the JPEG bounty.

Version 1.71. Tagged as 'SprExtend-1_71'
@
text
@d275 26
a469 24
#ifdef RISCOS /* Module specifics */
/* Position independent code and data relocation */
void (*relocate_func(void (*)(void)))(void);
void *relocate_data(void *);
#define RELOCCODE(k) relocate_func((void(*)(void))(k))
#define RELOCDATA(k) relocate_data((void *)(k))

/* State to record a point in the Huffman stream, neatly packed in 20 bytes */
typedef struct
{
  INT32 get_buffer; /* Huffman bit buffer */
  const JOCTET *next_input_byte; /* State for data source */
  short last_dc_val[MAX_COMPS_IN_SCAN]; /* Huffman state */
  unsigned int restarts_to_go:16; /* 2 byte from M_DRI */
  unsigned int bits_left:5; /* Huffman bit position */
  unsigned int next_restart_num:3; /* Next expected M_RSTn */
  unsigned int unread_marker:8; /* May encounter markers mid Huffman stream */
} huff_pointer;
EXTERN(void) huff_pointer_save(j_decompress_ptr, huff_pointer *);
EXTERN(void) huff_pointer_restore(j_decompress_ptr, const huff_pointer *);
#else
#define RELOCCODE(k) k
#define RELOCDATA(k) k
#endif
d733 5
a737 3
  const JOCTET *jpeg_buffer;  /* Start of buffer (private to input code) */
  size_t jpeg_buffer_size;    /* Buffer extent */
  int check1, check2, check3; /* Random check words to see if this is a JPEG we've seen before */
a884 1
#ifndef RISCOS /* No virtual memory */
a907 1
#endif
d921 3
d1063 6
d1073 1
@


4.2
log
@Update headers to stock copy
Detail:
  Added headers jerror, jmorecfg, jpegint from IJG8d. Removed jpegdata header.
  Bulk rename of structure members to match newer headers, some RISCOS-isms wrapped in #ifdef RISCOS, retained for the time being.
  Assembler code now gets cinfo member offsets from jhdr.s derived from the C header rather than keeping its own dangerous copy of the offsets.
Admin
  Note: this has broken CFSI-jpeg as it expects the error values to be at the top of cinfo.
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_70-headers.
@
text
@a96 3
#ifdef RISCOS
  int quantval[DCTSIZE2];
#else
a97 1
#endif
a113 6
#ifdef RISCOS
  /* These are private variables in jdhuff now, temporarily copied here */
  INT32 maxcode[18];
  int   valptr[17];
  int shortcut[256];
#endif
d420 3
d424 1
d444 8
a451 6
#ifdef RISCOS
/* Colour convert fn pointer */
typedef void (*convert_block_16_func)(JCOEF *yuv, short *outptr, int outoffset);
/* The buffer contains the entire file */
#define JGETC(cinfo) (int) ((cinfo)->next_input_byte >= &(cinfo)->jpeg_buffer[(cinfo)->jpeg_size] ? 255 : *(cinfo)->next_input_byte++)
/* State to record a point in the Huffman stream */
d454 7
a460 5
  int bit_pointer;   /* (next_input_byte-input_buffer)*32 + bits_left */
  int get_buffer;
  short int last_dc_val[MAX_COMPS_IN_SCAN]; /* NB NOT dequantised */
  short int restarts_to_go;
  short int next_restart_num;
d462 5
d674 3
d678 1
a680 55
#ifdef RISCOS
  /* Colour conversion function to use for 16bpp output */
  convert_block_16_func convert_block_16;

  /* Bit position in the Huffman stream */
  int get_buffer;
  int bits_left;
  const JOCTET * next_input_byte; /* => next byte to read from buffer */
  int current_huff_pointer; /* Currently loaded band, or -1 if none. */
  huff_pointer *huff_pointers; /* For quick random access */

  /* Restart marker handling */
  short int restarts_to_go;
  short int next_restart_num;

  /* Where the memory is */
  int workspace_size;

  /* Random check words to look for the same sprite over again */
  int check1;
  int check2;
  int check3;

  /* Min and max x pixels required: clip as early as possible. */
  int xmin;
  int xmax;

  /* Render options */
  int options;

  /* The 16bpp->8bpp 32K lookup table, if you need it */
  char *table32k;
  boolean table32k_unavailable; /* Set if we ever failed to get table32k */

  JBLOCK jblocks[7]; /* YYYYUV blocks, and one spare at the front */
  JCOEF last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each comp - NOT dequantized yet */

  int *band_buffer; /* Large buffer into which the colour data goes. */
                    /* We construct one strip, 8 or 16 pixels high, across the image. */
  int band_buffer_size; /* Must be a multiple of 16 */

  const JOCTET *jpeg_buffer; /* start of buffer (private to input code) */
  size_t jpeg_size;          /* buffer extent */

  /* Return values */
  int error_code;         /* Returned err code, 0 if no error */
  int error_argument1;    /* Supplementary error data */
  int error_argument2;    /* Supplementary error data */

  /* Statics to avoid needing a memory allocator */
  jpeg_component_info s_cur_comp_info[MAX_COMPS_IN_SCAN];
  JQUANT_TBL s_quant_tbl[NUM_QUANT_TBLS];
  JHUFF_TBL  s_dc_huff_tbl[NUM_HUFF_TBLS];
  JHUFF_TBL  s_ac_huff_tbl[NUM_HUFF_TBLS];
#else
d701 41
d881 1
d905 1
d918 4
@


4.1
log
@Initial revision
@
text
@d4 2
a5 1
 * Copyright (C) 1991-1994, Thomas G. Lane.
d14 3
d30 8
a37 2
/* Version ID for the JPEG library.
 * Might be useful for tests like "#if JPEG_LIB_VERSION >= 60".
d40 3
a42 1
#define JPEG_LIB_VERSION  50	/* Version 5.0 */
d50 1
a50 1
#define DCTSIZE		    8	/* The basic DCT block is 8x8 samples */
d57 6
a62 6
#define MAX_BLOCKS_IN_MCU   10	/* JPEG limit on # of blocks in an MCU */


/* This macro is used to declare a "method", that is, a function pointer.
 * We want to supply prototype parameters if the compiler can cope.
 * Note that the arglist parameter must be parenthesized!
d64 3
a66 5

#ifdef HAVE_PROTOTYPES
#define JMETHOD(type,methodname,arglist)  type (*methodname) arglist
#else
#define JMETHOD(type,methodname,arglist)  type (*methodname) ()
d93 3
a95 2
  /* This field directly represents the contents of a JPEG DQT marker.
   * Note: the values are always given in zigzag order.
d97 3
d101 1
d118 6
d147 1
d160 4
a163 5
  /* Size of a DCT block in samples.  Always DCTSIZE for compression.
   * For decompression this is the size of the output from one DCT block,
   * reflecting any scaling we choose to apply during the IDCT step.
   * Values of 1,2,4,8 are likely to be supported.  Note that different
   * components may receive different IDCT scalings.
d165 2
a166 1
  int DCT_scaled_size;
d168 4
a171 4
   * of samples at the main buffer (preprocessing/compression interface), thus
   * downsampled_width = ceil(image_width * Hi/Hmax)
   * and similarly for height.  For decompression, IDCT scaling is included, so
   * downsampled_width = ceil(image_width * Hi/Hmax * DCT_scaled_size/DCTSIZE)
d181 2
a182 1
  /* These values are computed before starting a scan of the component: */
d186 1
a186 1
  int MCU_sample_width;		/* MCU width in samples, MCU_width*DCT_scaled_size */
d190 6
d201 22
d264 3
a266 2
  boolean is_decompressor;	/* so common code can tell which is which */\
  int global_state		/* for checking call sequence validity */
d313 11
d331 1
a331 1
  
d333 5
a337 2
  /* ptrs to coefficient quantization tables, or NULL if not defined */
  
d341 1
a341 1
  
d346 7
a354 1
  boolean interleave;		/* TRUE=interleaved output, FALSE=not */
d357 1
d372 2
d397 1
d401 3
d423 1
a423 1
  int MCU_membership[MAX_BLOCKS_IN_MCU];
d427 6
d445 2
d450 15
d492 1
d495 4
d501 1
d503 5
a507 5
  J_DITHER_MODE dither_mode;	/* type of color dithering to use */
  int desired_number_of_colors;	/* max number of colors to use */

  J_DCT_METHOD dct_method;	/* DCT algorithm selector */
  boolean do_fancy_upsampling;	/* TRUE=apply fancy upsampling */
d531 1
a531 1
   * jpeg_start_decompress.
d537 2
a538 3
  /* State variable: index of next scaled scanline to be read from
   * jpeg_read_scanlines().  Application may use this to control its
   * processing loop, e.g., "while (output_scanline < output_height)".
d541 4
d547 22
d570 2
a571 1
   * these fields.
d594 4
a601 2
  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */

d608 3
a610 1
  /* Data copied from JFIF marker: */
d619 6
d635 2
a636 1
  int min_DCT_scaled_size;	/* smallest DCT_scaled_size of any component */
d638 7
a644 5
  JDIMENSION total_iMCU_rows;	/* # of iMCU rows to be output by coef ctlr */
  /* The coefficient controller outputs data in units of MCU rows as defined
   * for fully interleaved scans (whether the JPEG file is interleaved or not).
   * There are v_samp_factor * DCT_scaled_size sample rows of each component
   * in an "iMCU" (interleaved MCU) row.
d652 1
d662 1
a662 1
  int MCU_membership[MAX_BLOCKS_IN_MCU];
d666 63
d742 1
d749 1
d852 1
a852 1
  JMETHOD(boolean, resync_to_restart, (j_decompress_ptr cinfo));
d890 1
d893 1
a893 1
						  JDIMENSION unitheight));
d896 1
d899 1
a899 1
						  JDIMENSION unitheight));
d904 1
d909 1
d920 3
d953 2
a954 2
#define jpeg_create_compress	jCreaCompress
#define jpeg_create_decompress	jCreaDecompress
d959 2
d963 1
d966 1
d969 1
d976 1
d979 2
d987 7
d995 1
d997 3
d1009 2
a1010 1
EXTERN struct jpeg_error_mgr *jpeg_std_error JPP((struct jpeg_error_mgr *err));
d1012 20
a1031 6
/* Initialization and destruction of JPEG compression objects */
/* NB: you must set up the error-manager BEFORE calling jpeg_create_xxx */
EXTERN void jpeg_create_compress JPP((j_compress_ptr cinfo));
EXTERN void jpeg_create_decompress JPP((j_decompress_ptr cinfo));
EXTERN void jpeg_destroy_compress JPP((j_compress_ptr cinfo));
EXTERN void jpeg_destroy_decompress JPP((j_decompress_ptr cinfo));
d1035 10
a1044 2
EXTERN void jpeg_stdio_dest JPP((j_compress_ptr cinfo, FILE * outfile));
EXTERN void jpeg_stdio_src JPP((j_decompress_ptr cinfo, FILE * infile));
d1047 1
a1047 1
EXTERN void jpeg_set_defaults JPP((j_compress_ptr cinfo));
d1049 20
a1068 16
EXTERN void jpeg_set_colorspace JPP((j_compress_ptr cinfo,
				     J_COLOR_SPACE colorspace));
EXTERN void jpeg_set_quality JPP((j_compress_ptr cinfo, int quality,
				  boolean force_baseline));
EXTERN void jpeg_set_linear_quality JPP((j_compress_ptr cinfo,
					 int scale_factor,
					 boolean force_baseline));
EXTERN void jpeg_add_quant_table JPP((j_compress_ptr cinfo, int which_tbl,
				      const unsigned int *basic_table,
				      int scale_factor,
				      boolean force_baseline));
EXTERN int jpeg_quality_scaling JPP((int quality));
EXTERN void jpeg_suppress_tables JPP((j_compress_ptr cinfo,
				      boolean suppress));
EXTERN JQUANT_TBL * jpeg_alloc_quant_table JPP((j_common_ptr cinfo));
EXTERN JHUFF_TBL * jpeg_alloc_huff_table JPP((j_common_ptr cinfo));
d1071 9
a1079 6
EXTERN void jpeg_start_compress JPP((j_compress_ptr cinfo,
				     boolean write_all_tables));
EXTERN JDIMENSION jpeg_write_scanlines JPP((j_compress_ptr cinfo,
					    JSAMPARRAY scanlines,
					    JDIMENSION num_lines));
EXTERN void jpeg_finish_compress JPP((j_compress_ptr cinfo));
d1082 3
a1084 3
EXTERN JDIMENSION jpeg_write_raw_data JPP((j_compress_ptr cinfo,
					   JSAMPIMAGE data,
					   JDIMENSION num_lines));
d1086 9
a1094 3
/* Write a special marker.  See libjpeg.doc concerning safe usage. */
EXTERN void jpeg_write_marker JPP((j_compress_ptr cinfo, int marker,
				   const JOCTET *dataptr, unsigned int datalen));
d1097 1
a1097 1
EXTERN void jpeg_write_tables JPP((j_compress_ptr cinfo));
d1100 2
a1101 2
EXTERN int jpeg_read_header JPP((j_decompress_ptr cinfo,
				 boolean require_image));
d1103 3
a1105 3
#define JPEG_HEADER_OK		0 /* Found valid image datastream */
#define JPEG_HEADER_TABLES_ONLY	1 /* Found valid table-specs-only datastream */
#define JPEG_SUSPENDED		2 /* Had to suspend before end of headers */
d1113 9
a1121 3
EXTERN void jpeg_start_decompress JPP((j_decompress_ptr cinfo));
EXTERN JDIMENSION jpeg_read_scanlines JPP((j_decompress_ptr cinfo,
					   JSAMPARRAY scanlines,
a1122 1
EXTERN boolean jpeg_finish_decompress JPP((j_decompress_ptr cinfo));
d1124 14
a1137 4
/* Replaces jpeg_read_scanlines when reading raw downsampled data. */
EXTERN JDIMENSION jpeg_read_raw_data JPP((j_decompress_ptr cinfo,
					  JSAMPIMAGE data,
					  JDIMENSION max_lines));
d1140 7
a1146 1
EXTERN void jpeg_calc_output_dimensions JPP((j_decompress_ptr cinfo));
d1149 10
a1158 3
EXTERN void jpeg_set_marker_processor JPP((j_decompress_ptr cinfo,
					   int marker_code,
					   jpeg_marker_parser_method routine));
d1166 2
a1167 2
EXTERN void jpeg_abort_compress JPP((j_compress_ptr cinfo));
EXTERN void jpeg_abort_decompress JPP((j_decompress_ptr cinfo));
d1172 2
a1173 2
EXTERN void jpeg_abort JPP((j_common_ptr cinfo));
EXTERN void jpeg_destroy JPP((j_common_ptr cinfo));
d1176 2
a1177 1
EXTERN boolean jpeg_resync_to_restart JPP((j_decompress_ptr cinfo));
d1212 1
d1234 8
@


4.1.2.1
log
@Import of IJG 8b headers.
Note: this version will not compile, it's just here to serve as a basis
for diffs.
@
text
@d4 1
a4 2
 * Copyright (C) 1991-1998, Thomas G. Lane.
 * Modified 2002-2009 by Guido Vollbeding.
a12 3
#ifndef JPEGLIB_H
#define JPEGLIB_H

a25 6
#ifdef __cplusplus
#ifndef DONT_USE_EXTERN_C
extern "C" {
#endif
#endif

d27 1
a27 1
 * Might be useful for tests like "#if JPEG_LIB_VERSION >= 80".
d30 1
a30 1
#define JPEG_LIB_VERSION  80	/* Version 8.0 */
d45 6
a50 6
/* Unfortunately, some bozo at Adobe saw no reason to be bound by the standard;
 * the PostScript DCT filter can emit files with many more than 10 blocks/MCU.
 * If you happen to run across such a file, you can up D_MAX_BLOCKS_IN_MCU
 * to handle it.  We even let you do this from the jconfig.h file.  However,
 * we strongly discourage changing C_MAX_BLOCKS_IN_MCU; just because Adobe
 * sometimes emits noncompliant files doesn't mean you should too.
d52 5
a56 3
#define C_MAX_BLOCKS_IN_MCU   10 /* compressor's limit on blocks per MCU */
#ifndef D_MAX_BLOCKS_IN_MCU
#define D_MAX_BLOCKS_IN_MCU   10 /* decompressor's limit on blocks per MCU */
d83 2
a84 3
  /* This array gives the coefficient quantizers in natural array order
   * (not the zigzag order in which they are stored in a JPEG DQT marker).
   * CAUTION: IJG versions prior to v6a kept this array in zigzag order.
a125 1
  /* The decompressor output side may not use these variables. */
d138 5
a142 4
  /* Size of a DCT block in samples,
   * reflecting any scaling we choose to apply during the DCT step.
   * Values from 1 to 16 are supported.
   * Note that different components may receive different DCT scalings.
d144 1
a144 2
  int DCT_h_scaled_size;
  int DCT_v_scaled_size;
d146 4
a149 4
   * of samples at the main buffer (preprocessing/compression interface);
   * DCT scaling is included, so
   * downsampled_width = ceil(image_width * Hi/Hmax * DCT_h_scaled_size/DCTSIZE)
   * and similarly for height.
d159 1
a159 2
  /* These values are computed before starting a scan of the component. */
  /* The decompressor output side may not use these variables. */
d163 1
a163 1
  int MCU_sample_width;	/* MCU width in samples: MCU_width * DCT_h_scaled_size */
a166 6
  /* Saved quantization table for component; NULL if none yet saved.
   * See jdinput.c comments about the need for this information.
   * This field is currently used only for decompression.
   */
  JQUANT_TBL * quant_table;

a171 22
/* The script for encoding a multiple-scan file is an array of these: */

typedef struct {
  int comps_in_scan;		/* number of components encoded in this scan */
  int component_index[MAX_COMPS_IN_SCAN]; /* their SOF/comp_info[] indexes */
  int Ss, Se;			/* progressive JPEG spectral selection parms */
  int Ah, Al;			/* progressive JPEG successive approx. parms */
} jpeg_scan_info;

/* The decompressor can save APPn and COM markers in a list of these: */

typedef struct jpeg_marker_struct FAR * jpeg_saved_marker_ptr;

struct jpeg_marker_struct {
  jpeg_saved_marker_ptr next;	/* next in list, or NULL */
  UINT8 marker;			/* marker code: JPEG_COM, or JPEG_APP0+n */
  unsigned int original_length;	/* # bytes of data in the file */
  unsigned int data_length;	/* # bytes of data saved at data[] */
  JOCTET FAR * data;		/* the data contained in the marker */
  /* the marker length word is not counted in data_length or original_length */
};

d213 2
a214 3
  void * client_data;		/* Available for use by application */\
  boolean is_decompressor;	/* So common code can tell which is which */\
  int global_state		/* For checking call sequence validity */
a260 11
  unsigned int scale_num, scale_denom; /* fraction by which to scale image */

  JDIMENSION jpeg_width;	/* scaled JPEG image width */
  JDIMENSION jpeg_height;	/* scaled JPEG image height */
  /* Dimensions of actual JPEG image that will be written to file,
   * derived from input dimensions by scaling factors above.
   * These fields are computed by jpeg_start_compress().
   * You can also use jpeg_calc_jpeg_dimensions() to determine these values
   * in advance of calling jpeg_start_compress().
   */

d268 1
a268 1

d270 2
a271 5
  int q_scale_factor[NUM_QUANT_TBLS];
  /* ptrs to coefficient quantization tables, or NULL if not defined,
   * and corresponding scale factors (percentage, initialized 100).
   */

d275 1
a275 1

a279 7
  int num_scans;		/* # of entries in scan_info array */
  const jpeg_scan_info * scan_info; /* script for multi-scan file, or NULL */
  /* The default value of scan_info is NULL, which causes a single-scan
   * sequential JPEG file to be emitted.  To create a multi-scan file,
   * set num_scans and scan_info to point to an array of scan definitions.
   */

d282 1
a284 1
  boolean do_fancy_downsampling; /* TRUE=apply fancy downsampling */
a298 2
  UINT8 JFIF_major_version;	/* What to write for the JFIF version number */
  UINT8 JFIF_minor_version;
a321 1
  boolean progressive_mode;	/* TRUE if scan script uses progressive mode */
a324 3
  int min_DCT_h_scaled_size;	/* smallest DCT_h_scaled_size of any component */
  int min_DCT_v_scaled_size;	/* smallest DCT_v_scaled_size of any component */

d344 1
a344 1
  int MCU_membership[C_MAX_BLOCKS_IN_MCU];
a347 6
  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */

  int block_size;		/* the basic DCT block size: 1..16 */
  const int * natural_order;	/* natural-order position array */
  int lim_Se;			/* min( Se, DCTSIZE2-1 ) */

a359 2
  jpeg_scan_info * script_space; /* workspace for jpeg_simple_progression */
  int script_space_size;
a389 1
  boolean buffered_image;	/* TRUE=multiple output passes */
a391 4
  J_DCT_METHOD dct_method;	/* IDCT algorithm selector */
  boolean do_fancy_upsampling;	/* TRUE=apply fancy upsampling */
  boolean do_block_smoothing;	/* TRUE=apply interblock smoothing */

d394 1
d396 4
a399 6
  boolean two_pass_quantize;	/* TRUE=use two-pass color quantization */
  int desired_number_of_colors;	/* max # colors to use in created colormap */
  /* these are significant only in buffered-image mode: */
  boolean enable_1pass_quant;	/* enable future use of 1-pass quantizer */
  boolean enable_external_quant;/* enable future use of external colormap */
  boolean enable_2pass_quant;	/* enable future use of 2-pass quantizer */
d423 1
a423 1
   * jpeg_start_decompress or jpeg_start_output.
d429 3
a431 2
  /* State variables: these variables indicate the progress of decompression.
   * The application may examine these but must not modify them.
a433 4
  /* Row index of next scanline to be read from jpeg_read_scanlines().
   * Application may use this to control its processing loop, e.g.,
   * "while (output_scanline < output_height)".
   */
a435 22
  /* Current input scan number and number of iMCU rows completed in scan.
   * These indicate the progress of the decompressor input side.
   */
  int input_scan_number;	/* Number of SOS markers seen so far */
  JDIMENSION input_iMCU_row;	/* Number of iMCU rows completed */

  /* The "output scan number" is the notional scan being displayed by the
   * output side.  The decompressor will not allow output scan/row number
   * to get ahead of input scan/row, but it can fall arbitrarily far behind.
   */
  int output_scan_number;	/* Nominal scan number being displayed */
  JDIMENSION output_iMCU_row;	/* Number of iMCU rows read */

  /* Current progression status.  coef_bits[c][i] indicates the precision
   * with which component c's DCT coefficient i (in zigzag order) is known.
   * It is -1 when no data has yet been received, otherwise it is the point
   * transform (shift) value for the most recent scan of the coefficient
   * (thus, 0 at completion of the progression).
   * This pointer is NULL when reading a non-progressive file.
   */
  int (*coef_bits)[DCTSIZE2];	/* -1 or current Al value for each coef */

d437 1
a437 2
   * these fields.  Note that the decompressor output side may not use
   * any parameters that can change between scans.
a459 4
  boolean is_baseline;		/* TRUE if Baseline SOF0 encountered */
  boolean progressive_mode;	/* TRUE if SOFn specifies progressive mode */
  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */

d464 2
d472 1
a472 3
  /* Data copied from JFIF marker; only valid if saw_JFIF_marker is TRUE: */
  UINT8 JFIF_major_version;	/* JFIF version number */
  UINT8 JFIF_minor_version;
a480 6
  /* Aside from the specific data retained from APPn markers known to the
   * library, the uninterpreted contents of any or all APPn and COM markers
   * can be saved in a list for examination by the application.
   */
  jpeg_saved_marker_ptr marker_list; /* Head of list of saved markers */

d491 1
a491 2
  int min_DCT_h_scaled_size;	/* smallest DCT_h_scaled_size of any component */
  int min_DCT_v_scaled_size;	/* smallest DCT_v_scaled_size of any component */
d493 5
a497 7
  JDIMENSION total_iMCU_rows;	/* # of iMCU rows in image */
  /* The coefficient controller's input and output progress is measured in
   * units of "iMCU" (interleaved MCU) rows.  These are the same as MCU rows
   * in fully interleaved JPEG scans, but are used whether the scan is
   * interleaved or not.  We define an iMCU row as v_samp_factor DCT block
   * rows of each component.  Therefore, the IDCT output contains
   * v_samp_factor*DCT_v_scaled_size sample rows of a component per iMCU row.
a504 1
   * Note that the decompressor output side must not use these fields.
d514 1
a514 1
  int MCU_membership[D_MAX_BLOCKS_IN_MCU];
a517 8
  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */

  /* These fields are derived from Se of first SOS marker.
   */
  int block_size;		/* the basic DCT block size: 1..16 */
  const int * natural_order; /* natural-order position array for entropy decode */
  int lim_Se;			/* min( Se, DCTSIZE2-1 ) for entropy decode */

a530 1
  struct jpeg_input_controller * inputctl;
d639 1
a639 1
  JMETHOD(boolean, resync_to_restart, (j_decompress_ptr cinfo, int desired));
a676 1
						  boolean pre_zero,
d679 1
a679 1
						  JDIMENSION maxaccess));
a681 1
						  boolean pre_zero,
d684 1
a684 1
						  JDIMENSION maxaccess));
a688 1
					   JDIMENSION num_rows,
a692 1
					    JDIMENSION num_rows,
a702 3

  /* Maximum allocation request accepted by alloc_large. */
  long max_alloc_chunk;
d733 2
a734 2
#define jpeg_CreateCompress	jCreaCompress
#define jpeg_CreateDecompress	jCreaDecompress
a738 2
#define jpeg_mem_dest		jMemDest
#define jpeg_mem_src		jMemSrc
a740 1
#define jpeg_default_colorspace	jDefColorspace
a742 1
#define jpeg_default_qtables	jDefQTables
a744 1
#define jpeg_simple_progression	jSimProgress
a750 1
#define jpeg_calc_jpeg_dimensions	jCjpegDimensions
a752 2
#define jpeg_write_m_header	jWrtMHeader
#define jpeg_write_m_byte	jWrtMByte
a758 7
#define jpeg_has_multiple_scans	jHasMultScn
#define jpeg_start_output	jStrtOutput
#define jpeg_finish_output	jFinOutput
#define jpeg_input_complete	jInComplete
#define jpeg_new_colormap	jNewCMap
#define jpeg_consume_input	jConsumeInput
#define jpeg_core_output_dimensions	jCoreDimensions
a759 1
#define jpeg_save_markers	jSaveMarkers
a760 3
#define jpeg_read_coefficients	jReadCoefs
#define jpeg_write_coefficients	jWrtCoefs
#define jpeg_copy_critical_parameters	jCopyCrit
d770 1
a770 2
EXTERN(struct jpeg_error_mgr *) jpeg_std_error
	JPP((struct jpeg_error_mgr * err));
d772 6
a777 20
/* Initialization of JPEG compression objects.
 * jpeg_create_compress() and jpeg_create_decompress() are the exported
 * names that applications should call.  These expand to calls on
 * jpeg_CreateCompress and jpeg_CreateDecompress with additional information
 * passed for version mismatch checking.
 * NB: you must set up the error-manager BEFORE calling jpeg_create_xxx.
 */
#define jpeg_create_compress(cinfo) \
    jpeg_CreateCompress((cinfo), JPEG_LIB_VERSION, \
			(size_t) sizeof(struct jpeg_compress_struct))
#define jpeg_create_decompress(cinfo) \
    jpeg_CreateDecompress((cinfo), JPEG_LIB_VERSION, \
			  (size_t) sizeof(struct jpeg_decompress_struct))
EXTERN(void) jpeg_CreateCompress JPP((j_compress_ptr cinfo,
				      int version, size_t structsize));
EXTERN(void) jpeg_CreateDecompress JPP((j_decompress_ptr cinfo,
					int version, size_t structsize));
/* Destruction of JPEG compression objects */
EXTERN(void) jpeg_destroy_compress JPP((j_compress_ptr cinfo));
EXTERN(void) jpeg_destroy_decompress JPP((j_decompress_ptr cinfo));
d781 2
a782 10
EXTERN(void) jpeg_stdio_dest JPP((j_compress_ptr cinfo, FILE * outfile));
EXTERN(void) jpeg_stdio_src JPP((j_decompress_ptr cinfo, FILE * infile));

/* Data source and destination managers: memory buffers. */
EXTERN(void) jpeg_mem_dest JPP((j_compress_ptr cinfo,
			       unsigned char ** outbuffer,
			       unsigned long * outsize));
EXTERN(void) jpeg_mem_src JPP((j_decompress_ptr cinfo,
			      unsigned char * inbuffer,
			      unsigned long insize));
d785 1
a785 1
EXTERN(void) jpeg_set_defaults JPP((j_compress_ptr cinfo));
d787 16
a802 20
EXTERN(void) jpeg_set_colorspace JPP((j_compress_ptr cinfo,
				      J_COLOR_SPACE colorspace));
EXTERN(void) jpeg_default_colorspace JPP((j_compress_ptr cinfo));
EXTERN(void) jpeg_set_quality JPP((j_compress_ptr cinfo, int quality,
				   boolean force_baseline));
EXTERN(void) jpeg_set_linear_quality JPP((j_compress_ptr cinfo,
					  int scale_factor,
					  boolean force_baseline));
EXTERN(void) jpeg_default_qtables JPP((j_compress_ptr cinfo,
				       boolean force_baseline));
EXTERN(void) jpeg_add_quant_table JPP((j_compress_ptr cinfo, int which_tbl,
				       const unsigned int *basic_table,
				       int scale_factor,
				       boolean force_baseline));
EXTERN(int) jpeg_quality_scaling JPP((int quality));
EXTERN(void) jpeg_simple_progression JPP((j_compress_ptr cinfo));
EXTERN(void) jpeg_suppress_tables JPP((j_compress_ptr cinfo,
				       boolean suppress));
EXTERN(JQUANT_TBL *) jpeg_alloc_quant_table JPP((j_common_ptr cinfo));
EXTERN(JHUFF_TBL *) jpeg_alloc_huff_table JPP((j_common_ptr cinfo));
d805 6
a810 9
EXTERN(void) jpeg_start_compress JPP((j_compress_ptr cinfo,
				      boolean write_all_tables));
EXTERN(JDIMENSION) jpeg_write_scanlines JPP((j_compress_ptr cinfo,
					     JSAMPARRAY scanlines,
					     JDIMENSION num_lines));
EXTERN(void) jpeg_finish_compress JPP((j_compress_ptr cinfo));

/* Precalculate JPEG dimensions for current compression parameters. */
EXTERN(void) jpeg_calc_jpeg_dimensions JPP((j_compress_ptr cinfo));
d813 3
a815 3
EXTERN(JDIMENSION) jpeg_write_raw_data JPP((j_compress_ptr cinfo,
					    JSAMPIMAGE data,
					    JDIMENSION num_lines));
d817 3
a819 9
/* Write a special marker.  See libjpeg.txt concerning safe usage. */
EXTERN(void) jpeg_write_marker
	JPP((j_compress_ptr cinfo, int marker,
	     const JOCTET * dataptr, unsigned int datalen));
/* Same, but piecemeal. */
EXTERN(void) jpeg_write_m_header
	JPP((j_compress_ptr cinfo, int marker, unsigned int datalen));
EXTERN(void) jpeg_write_m_byte
	JPP((j_compress_ptr cinfo, int val));
d822 1
a822 1
EXTERN(void) jpeg_write_tables JPP((j_compress_ptr cinfo));
d825 2
a826 2
EXTERN(int) jpeg_read_header JPP((j_decompress_ptr cinfo,
				  boolean require_image));
d828 3
a830 3
#define JPEG_SUSPENDED		0 /* Suspended due to lack of input data */
#define JPEG_HEADER_OK		1 /* Found valid image datastream */
#define JPEG_HEADER_TABLES_ONLY	2 /* Found valid table-specs-only datastream */
d838 5
a842 5
EXTERN(boolean) jpeg_start_decompress JPP((j_decompress_ptr cinfo));
EXTERN(JDIMENSION) jpeg_read_scanlines JPP((j_decompress_ptr cinfo,
					    JSAMPARRAY scanlines,
					    JDIMENSION max_lines));
EXTERN(boolean) jpeg_finish_decompress JPP((j_decompress_ptr cinfo));
d845 3
a847 18
EXTERN(JDIMENSION) jpeg_read_raw_data JPP((j_decompress_ptr cinfo,
					   JSAMPIMAGE data,
					   JDIMENSION max_lines));

/* Additional entry points for buffered-image mode. */
EXTERN(boolean) jpeg_has_multiple_scans JPP((j_decompress_ptr cinfo));
EXTERN(boolean) jpeg_start_output JPP((j_decompress_ptr cinfo,
				       int scan_number));
EXTERN(boolean) jpeg_finish_output JPP((j_decompress_ptr cinfo));
EXTERN(boolean) jpeg_input_complete JPP((j_decompress_ptr cinfo));
EXTERN(void) jpeg_new_colormap JPP((j_decompress_ptr cinfo));
EXTERN(int) jpeg_consume_input JPP((j_decompress_ptr cinfo));
/* Return value is one of: */
/* #define JPEG_SUSPENDED	0    Suspended due to lack of input data */
#define JPEG_REACHED_SOS	1 /* Reached start of new scan */
#define JPEG_REACHED_EOI	2 /* Reached end of image */
#define JPEG_ROW_COMPLETED	3 /* Completed one iMCU row */
#define JPEG_SCAN_COMPLETED	4 /* Completed last iMCU row of a scan */
d850 1
a850 7
EXTERN(void) jpeg_core_output_dimensions JPP((j_decompress_ptr cinfo));
EXTERN(void) jpeg_calc_output_dimensions JPP((j_decompress_ptr cinfo));

/* Control saving of COM and APPn markers into marker_list. */
EXTERN(void) jpeg_save_markers
	JPP((j_decompress_ptr cinfo, int marker_code,
	     unsigned int length_limit));
d853 3
a855 10
EXTERN(void) jpeg_set_marker_processor
	JPP((j_decompress_ptr cinfo, int marker_code,
	     jpeg_marker_parser_method routine));

/* Read or write raw DCT coefficients --- useful for lossless transcoding. */
EXTERN(jvirt_barray_ptr *) jpeg_read_coefficients JPP((j_decompress_ptr cinfo));
EXTERN(void) jpeg_write_coefficients JPP((j_compress_ptr cinfo,
					  jvirt_barray_ptr * coef_arrays));
EXTERN(void) jpeg_copy_critical_parameters JPP((j_decompress_ptr srcinfo,
						j_compress_ptr dstinfo));
d863 2
a864 2
EXTERN(void) jpeg_abort_compress JPP((j_compress_ptr cinfo));
EXTERN(void) jpeg_abort_decompress JPP((j_decompress_ptr cinfo));
d869 2
a870 2
EXTERN(void) jpeg_abort JPP((j_common_ptr cinfo));
EXTERN(void) jpeg_destroy JPP((j_common_ptr cinfo));
d873 1
a873 2
EXTERN(boolean) jpeg_resync_to_restart JPP((j_decompress_ptr cinfo,
					    int desired));
a907 1
struct jpeg_input_controller { long dummy; };
a928 8

#ifdef __cplusplus
#ifndef DONT_USE_EXTERN_C
}
#endif
#endif

#endif /* JPEGLIB_H */
@


4.1.2.2
log
@Missed the header files out of the last commit. Try again.

Version 1.38, 1.35.2.2. Tagged as 'SprExtend-1_38-1_35_2_2'
@
text
@a94 4
#ifdef RISCOS
#pragma Review changing assembler to use 16 bit coefficients
  int quantval[DCTSIZE2];
#else
a95 1
#endif  
a116 6
#ifdef RISCOS
#pragma Review using port of C huffman instead
  INT32 maxcode[18];		/* Packing order important for assembler! */
  int valptr[17];
  int shortcut[256];
#endif
a244 16
#ifdef RISCOS
#pragma Review using port of C huffman instead
/* Remember a precise position in the huffman stream. */

typedef struct
{
  int bit_pointer;   /* (next_input_byte-input_buffer)*32 + bits_left */
  int get_buffer;
  short int last_dc_val0; /* NB NOT dequantised */
  short int last_dc_val1;
  short int last_dc_val2;
  short int last_dc_val3; /* in case we ever do CMYK */
  short int restarts_to_go;
  short int next_restart_num;
} huff_pointer;
#endif
a247 8
#ifdef RISCOS
#define jpeg_common_fields \
  int error_code;         /* Returned err code, 0 if no error */\
  int error_argument1;    /* Supplementary error data */\
  int error_argument2;    /* Supplementary error data */\
  char *workspace_UNUSED; /* Unused, but needed to retain CFSIjpeg spacing */\
  int workspace_size      /* Number of bytes */
#else
a254 1
#endif
a652 42
#ifdef RISCOS
#pragma Review duplicates & copy comments over
  int current_huff_pointer; /* Currently loaded band, or -1 if none. */
  int xmin;
  int xmax;                 /* Min and max x pixels required: clip as early
                            as possible. */
  int options;

  /* Statics moved in from the huffman decoding */
  int get_buffer;
  int bits_left;

  /* Random check words to look for the same sprite over again */
  int check1;
  int check2;
  int check3;

  JBLOCK jblocks[7]; /* YYYYUV blocks, and one spare at the front */

  huff_pointer *huff_pointers;

  char *table32k;
  BOOL table32k_unavailable;

  int *band_buffer; /* Large buffer into which the colour data goes. */
  int band_buffer_size; /* Must be a multiple of 16 */

  char * input_buffer;    /* start of buffer (private to input code) */
  char * next_input_byte; /* => next byte to read from buffer */
  char * buffer_end;      /* pointer to end of buffer */

  jpeg_component_info s_cur_comp_info[MAX_COMPS_IN_SCAN];
  JQUANT_TBL s_quant_tbl[NUM_QUANT_TBLS];
  JHUFF_TBL s_dc_huff_tbl[NUM_HUFF_TBLS];
  JHUFF_TBL s_ac_huff_tbl[NUM_HUFF_TBLS];

  JCOEF last_dc_val[MAX_COMPS_IN_SCAN];

  int restarts_to_go;
  int next_restart_num;
#endif

@


4.1.2.3
log
@Reinstate C code version of jdhuff.
In huff_decode_blocks the block pointer wasn't being incremented, as it was in the assembler.
Useful for speed comparisons.

Version 1.38, 1.35.2.3. Tagged as 'SprExtend-1_38-1_35_2_3'
@
text
@d716 3
a718 3
  char *input_buffer;    /* start of buffer (private to input code) */
  char *next_input_byte; /* => next byte to read from buffer */
  char *buffer_end;      /* pointer to end of buffer */
@


4.1.2.4
log
@Reinstate jrevdct4 option to use C code IDCT (switch "ASMIDCT").
Name inverse DCT to match IJG 8b integer fast implementation.
Remove -DEMBED option and collapse switches.
Useful for speed comparisons.

Version 1.38, 1.35.2.4. Tagged as 'SprExtend-1_38-1_35_2_4'
@
text
@d96 1
a96 1
#//Review changing assembler to use 16 bit coefficients
d123 1
a123 1
#//Review using port of C huffman instead
d257 1
a257 1
#//Review using port of C huffman instead
d690 1
a690 1
#//Review duplicates & copy comments over
@


4.1.2.5
log
@New jerror.h taken from IJG8b.
Swap to using JERR_ numbers, deleted E_ numbers.
Modify genjhdr to pass some defines to the assembler code, so jdcolor can clarify use of DCTSIZE and DCTSIZE2.
Added chart of possible subsampling ratios to documentation.

Version 1.38, 1.35.2.9. Tagged as 'SprExtend-1_38-1_35_2_9'
@
text
@d711 1
a711 1
  boolean table32k_unavailable;
a715 5
  JCOEF last_dc_val[MAX_COMPS_IN_SCAN];

  int restarts_to_go;
  int next_restart_num;

a719 1
  /* Static data to avoid needing malloc() */
d724 5
@


4.1.2.6
log
@Huffman decode adjusted to accept quantisation tables of 16 or 32 bit values (though use of LDAH macro).
IJG 8b uses UINT16 values now, but there's no measurable speed difference despite one/two extra instructions per AC component.

Version 1.38, 1.35.2.10. Tagged as 'SprExtend-1_38-1_35_2_10'
@
text
@d95 4
d100 1
d117 5
d125 1
a125 1
  int valoffset[17];
a127 5
  /* This field is used only during compression.  It's initialized FALSE when
   * the table is created, and set TRUE when it's been output to the file.
   * You could suppress output of a table by setting this to TRUE.
   * (See jpeg_suppress_tables for an example.)
   */
a131 11
/* Remember a precise position in the huffman stream. */

typedef struct {
  int   bit_pointer;  /* (next_input_byte-input_buffer)*32 + bits_left */
  int   get_buffer;
  short last_dc_val[MAX_COMPS_IN_SCAN]; /* NB NOT dequantised */
  short restarts_to_go;
  short next_restart_num;
} huff_pointer;


d256 16
a453 3
#ifdef RISCOS
  const char * natural_order;	/* natural-order position array */
#else
a454 1
#endif
a679 3
#ifdef RISCOS
  const char * natural_order; /* natural-order position array for entropy decode */
#else
a680 1
#endif  
d691 7
a697 1
  /* jdhuff */
d700 16
a715 1
  int current_huff_pointer;
d717 1
a717 1
  huff_pointer *huff_pointers;
a718 2

  /* jdmarker */
a720 1
  /* jdatasrc */
a724 15
  /* platform specific */
  int xmin;
  int xmax;              /* Min and max x pixels required: clip as early as possible. */
  int options;

  int check1;            /* Random check words to look for the same sprite over again */
  int check2;
  int check3;

  char *table32k;        /* Pointer to 16bpp translation table, if present */
  boolean table32k_unavailable;

  int *band_buffer;      /* Large buffer into which the colour data goes. */
  int band_buffer_size;  /* Must be a multiple of 16 */

a729 1
  JBLOCK s_jblocks[1 /* To write into */ + (2*2 /* YYYY */) + 2 /* UV */];
@


4.1.2.7
log
@Remap return results for CFSI-JPEG to match new cinfo structure.
Tested with a handful of JPEGs and !ChangeFSI.

Version 1.38, 1.35.2.11. Tagged as 'SprExtend-1_38-1_35_2_11'
@
text
@d265 8
d280 1
a705 5
  int error_code;        /* Returned err code, 0 if no error */
  int error_argument1;   /* Supplementary error data */
  int error_argument2;   /* Supplementary error data */
  int workspace_size;    /* Number of bytes */

@


4.1.2.8
log
@Migrate to jdmarker from IJG 8b.
ERREXIT's in jdhuff now use JERR_ numbers (missed earlier because it's switched out by default).

Version 1.38, 1.35.2.12. Tagged as 'SprExtend-1_38-1_35_2_12'
@
text
@d127 11
a289 24
#ifdef RISCOS
/* Remember a precise position in the huffman stream. */

typedef struct {
  int   bit_pointer;  /* (next_input_byte-input_buffer)*32 + bits_left */
  int   get_buffer;
  short last_dc_val[MAX_COMPS_IN_SCAN]; /* NB NOT dequantised */
  short restarts_to_go;
  short next_restart_num;
} huff_pointer;


/* Minimalist marker reader */

struct jpeg_marker_reader {
  boolean saw_SOI;
  boolean saw_SOF;
  short   next_restart_num;
  JMETHOD(boolean, read_restart_marker, (j_decompress_ptr));
  JMETHOD(int, read_markers, (j_decompress_ptr));
};
#endif


d435 3
d439 1
d678 2
a679 1
#//Push back into respective structs
d688 3
a690 1
#//Push back into respective structs
d696 1
a696 2
#ifdef RISCOS
  /* Platform specific */
a716 1
  struct jpeg_marker_reader s_marker_reader;
@


4.1.2.9
log
@Reorganise data input.
Fill in INPUT_VARS and INPUT_SYNC so it uses register variables.
Make use of data source manager (cinfo->src).
Calculate bytes_in_buffer when restoring the huffman position.
Swap process_restart() for the one now in jdmarker.

Version 1.38, 1.35.2.13. Tagged as 'SprExtend-1_38-1_35_2_13'
@
text
@d283 1
a283 1
  int   bit_pointer;  /* (next_input_byte-jpeg_buffer)*32 + bits_left */
a299 7

struct jpeg_source_mgr {
  const JOCTET *next_input_byte;
  size_t        bytes_in_buffer;
  JMETHOD(void, skip_input_data, (j_decompress_ptr cinfo, long num_bytes));
  JMETHOD(boolean, resync_to_restart, (j_decompress_ptr cinfo, int desired));
};
d696 6
d704 10
a713 12
  int error_code;            /* Returned err code, 0 if no error */
  int error_argument1;       /* Supplementary error data */
  int error_argument2;       /* Supplementary error data */
  int workspace_size;        /* Number of bytes */

  int xmin;                  /* Min and max x pixels required */
  int xmax;                  
  int options;               /* Derived processing options */

  const JOCTET *jpeg_buffer; /* Retain start/length/check words to look for the same JPEG again */
  size_t jpeg_size;
  int check1;
d717 1
a717 1
  char *table32k;            /* Pointer to 16bpp translation table, if present */
d720 2
a721 2
  int *band_buffer;          /* Large buffer into which the colour data goes */
  int band_buffer_size;      /* Must be a multiple of 16 */
d723 1
a723 1
  /* Static workspace to avoid needing malloc() */
a724 1
  struct jpeg_source_mgr s_source_mgr;
a838 1
#ifndef RISCOS
a850 1
#endif
@


4.1.2.10
log
@Abstract entropy decoding.
Currently still only support Huffman, but now agnostic, there are two functions 'decode_mcu()' which does the full DC+AC decode of a full MCU worth of data, and 'skip_mcu()' which just does DC and consumes but discards the AC coefficients.
Apply fix from 1.40 trunk version for monochrome output in a 8bpp greyscale mode.
Restore name of DCTFIX() macro to FIX(), no longer needed now the constituent parts are compiled seperately rather than #included.
Fix CFSIjpeg to assemble even though it doesn't have a module base (the recently added 'relocatefn()' was breaking it).

Version 1.38, 1.35.2.14. Tagged as 'SprExtend-1_38-1_35_2_14'
@
text
@d284 1
a284 1
  INT32 get_buffer;
d288 1
a288 1
} entropy_state;
d291 1
a291 1
/* Minimalist marker reader, source manager, entropy decoder */
a306 17

struct jpeg_entropy_decoder {
  int restarts_to_go;
  boolean insufficient_data;
  struct {
    INT32 get_buffer;
    int bits_left;
  } bitstate;
  struct {
    JCOEF last_dc_val[MAX_COMPS_IN_SCAN];
  } saved;
  JMETHOD(void, save_state, (j_decompress_ptr cinfo, entropy_state *state));
  JMETHOD(void, restore_state, (j_decompress_ptr cinfo, entropy_state *state));
  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
  JMETHOD(boolean, decode_mcu, (j_decompress_ptr cinfo, JBLOCKROW *row));
  JMETHOD(boolean, skip_mcu, (j_decompress_ptr cinfo, JBLOCKROW *row));
};
d694 8
a722 3
  entropy_state *bookmarks;  /* Large array of bookmarks into the entropy stream */
  int current_bookmark;

a728 1
  struct jpeg_entropy_decoder s_entropy_decoder;
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

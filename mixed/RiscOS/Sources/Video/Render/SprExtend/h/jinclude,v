head	4.10;
access;
symbols
	SprExtend-1_83:4.10
	SprExtend-1_82:4.10
	SprExtend-1_81:4.10
	SprExtend-1_80:4.10
	SprExtend-1_79:4.10
	SprExtend-1_78:4.10
	SprExtend-1_77:4.10
	SprExtend-1_76:4.10
	SprExtend-1_75:4.9
	SprExtend-1_74:4.9
	SprExtend-1_73:4.9
	SprExtend-1_72:4.9
	SprExtend-1_71-nocfsi:4.9
	SprExtend-1_71:4.9
	SprExtend-1_70-tracef:4.8
	SprExtend-1_70-headers:4.8
	SprExtend-1_70:4.7
	SprExtend-1_69:4.7
	SprExtend-1_68:4.7
	SprExtend-1_67:4.7
	SprExtend-1_66:4.7
	SprExtend-1_65:4.7
	SprExtend-1_64:4.7
	SprExtend-1_63:4.7
	SprExtend-1_62:4.7
	SprExtend-1_61:4.7
	SprExtend-1_60:4.7
	SprExtend-1_59:4.7
	SprExtend-1_58:4.7
	SprExtend-1_57:4.7
	SprExtend-1_56:4.7
	SprExtend-1_55:4.7
	SprExtend-1_54:4.7
	SprExtend-1_53:4.7
	SprExtend-1_52:4.7
	SprExtend-1_51:4.6
	SprExtend-1_50:4.6
	SprExtend-1_38-1_35_2_16:4.5.2.2
	SprExtend-1_49:4.5
	SprExtend-1_48:4.5
	SprExtend-1_47:4.5
	SprExtend-1_38-1_35_2_15:4.5.2.2
	SprExtend-1_46:4.5
	SprExtend-1_45:4.5
	SprExtend-1_44:4.5
	SprExtend-1_43:4.5
	SprExtend-1_42:4.5
	SprExtend-1_41:4.5
	SprExtend-1_38-1_35_2_14:4.5.2.2
	SprExtend-1_40:4.5
	SprExtend-1_38-1_35_2_13:4.5.2.2
	SprExtend-1_38-1_35_2_12:4.5.2.2
	SprExtend-1_38-1_35_2_11:4.5.2.2
	SprExtend-1_38-1_35_2_10:4.5.2.2
	SprExtend-1_38-1_35_2_9:4.5.2.2
	SprExtend-1_38-1_35_2_8:4.5.2.2
	SprExtend-1_39:4.5
	SprExtend-1_38-1_35_2_7:4.5.2.2
	SprExtend-1_38-1_35_2_6:4.5.2.2
	MigrateIJG8b:4.5.0.2
	SprExtend-1_38:4.5
	SprExtend-1_37:4.5
	SprExtend-1_36:4.4
	SprExtend-1_35:4.4
	SprExtend-1_34:4.4
	SprExtend-1_33:4.4
	SprExtend-1_32:4.4
	SprExtend-1_31:4.3
	SprExtend-1_30:4.3
	SprExtend-1_29:4.3
	SprExtend-1_28:4.3
	SprExtend-1_27:4.3
	SprExtend-1_26:4.3
	SprExtend-1_25:4.3
	SprExtend-1_24:4.3
	SprExtend-1_23:4.2
	SprExtend-1_22:4.2
	SprExtend-1_21:4.2
	SprExtend-1_20:4.2
	SprExtend-1_19:4.2
	SprExtend-1_18:4.2
	SprExtend-1_17:4.2
	RO_5_07:4.2
	SprExtend-1_16:4.2
	SprExtend-1_15:4.2
	SprExtend-1_14:4.2
	SprExtend-1_13:4.2
	SprExtend-1_12:4.2
	SprExtend-1_11:4.2
	SprExtend-1_10:4.2
	SprExtend-1_09:4.2
	SprExtend-1_08:4.2
	dellis_autobuild_BaseSW:4.2
	SprExtend-1_07:4.2
	SprExtend-1_06:4.2
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.2
	SprExtend-1_05:4.2
	Ursula_merge:4.2
	nturton_SprExtend-1_04:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.10
date	2016.05.21.14.16.35;	author rool;	state Exp;
branches;
next	4.9;
commitid	xdjBCBYna4x7am7z;

4.9
date	2016.05.21.13.44.42;	author rool;	state Exp;
branches;
next	4.8;
commitid	ZDqmsyNiMhv6Zl7z;

4.8
date	2016.05.21.13.32.23;	author rool;	state Exp;
branches;
next	4.7;
commitid	yTqS85yKh7k8Ul7z;

4.7
date	2013.08.06.23.16.26;	author jlee;	state Exp;
branches;
next	4.6;
commitid	z9XOph7zDZQ2Ur0x;

4.6
date	2012.07.28.15.23.44;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	b5jdybqzJ3Wdjlew;

4.5
date	2010.12.22.08.22.35;	author rsprowson;	state Exp;
branches
	4.5.2.1;
next	4.4;

4.4
date	2010.10.13.20.26.25;	author rsprowson;	state Exp;
branches;
next	4.3;

4.3
date	2010.09.01.20.48.56;	author rsprowson;	state Exp;
branches;
next	4.2;

4.2
date	97.01.22.16.15.11;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.45.08;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.5.2.1
date	2011.01.04.21.18.11;	author rsprowson;	state dead;
branches;
next	4.5.2.2;

4.5.2.2
date	2011.01.09.10.43.04;	author rsprowson;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.45.08;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.41.41;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.57.51;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.20.30;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Lazy MCU decoding
Detail:
  Only colour convert from the left clipping border (rounded down) to the right (rounding up).
  Only entropy decode the DC component for blocks likewise, skipping AC and IDCT steps.
Admin:
  Submission for the JPEG bounty.

Version 1.76. Tagged as 'SprExtend-1_76'
@
text
@/*
 * jinclude.h
 *
 * Copyright (C) 1991-1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file exists to provide a single place to fix any problems with
 * including the wrong system include files.  (Common problems are taken
 * care of by the standard jconfig symbols, but on really weird systems
 * you may have to edit this file.)
 *
 * NOTE: this file is NOT intended to be included by applications using the
 * JPEG library.  Most applications need only include jpeglib.h.
 */


#ifdef RISCOS /* Extra headers */
#include "kernel.h"     /* For _kernel_oserror */
#include "commondefs.h" /* For ERROR_ values and dprintf macros */
#endif

/* Include auto-config file to find out which system include files we need. */

#include "jconfig.h"		/* auto configuration options */
#define JCONFIG_INCLUDED	/* so that jpeglib.h doesn't do it again */

/*
 * We need the NULL macro and size_t typedef.
 * On an ANSI-conforming system it is sufficient to include <stddef.h>.
 * Otherwise, we get them from <stdlib.h> or <stdio.h>; we may have to
 * pull in <sys/types.h> as well.
 * Note that the core JPEG library does not require <stdio.h>;
 * only the default error handler and data source/destination modules do.
 * But we must pull it in because of the references to FILE in jpeglib.h.
 * You can remove those references if you want to compile without <stdio.h>.
 */

#ifdef HAVE_STDDEF_H
#include <stddef.h>
#endif

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#ifdef NEED_SYS_TYPES_H
#include <sys/types.h>
#endif

#include <stdio.h>

/*
 * We need memory copying and zeroing functions, plus strncpy().
 * ANSI and System V implementations declare these in <string.h>.
 * BSD doesn't have the mem() functions, but it does have bcopy()/bzero().
 * Some systems may declare memset and memcpy in <memory.h>.
 *
 * NOTE: we assume the size parameters to these functions are of type size_t.
 * Change the casts in these macros if not!
 */

#ifdef NEED_BSD_STRINGS

#include <strings.h>
#define MEMZERO(target,size)	bzero((void *)(target), (size_t)(size))
#define MEMCOPY(dest,src,size)	bcopy((const void *)(src), (void *)(dest), (size_t)(size))

#else /* not BSD, assume ANSI/SysV string lib */

#include <string.h>
#define MEMZERO(target,size)	memset((void *)(target), 0, (size_t)(size))
#define MEMCOPY(dest,src,size)	memcpy((void *)(dest), (const void *)(src), (size_t)(size))

#endif

/*
 * In ANSI C, and indeed any rational implementation, size_t is also the
 * type returned by sizeof().  However, it seems there are some irrational
 * implementations out there, in which sizeof() returns an int even though
 * size_t is defined as long or unsigned long.  To ensure consistent results
 * we always use this SIZEOF() macro in place of using sizeof() directly.
 */

#define SIZEOF(object)	((size_t) sizeof(object))

/*
 * The modules that use fread() and fwrite() always invoke them through
 * these macros.  On some systems you may need to twiddle the argument casts.
 * CAUTION: argument order is different from underlying functions!
 */

#define JFREAD(file,buf,sizeofbuf)  \
  ((size_t) fread((void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
#define JFWRITE(file,buf,sizeofbuf)  \
  ((size_t) fwrite((const void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
@


4.9
log
@Import of IJG8d library sources
Detail:
  Using the decoder in "example.c" as a starting point, we try to follow that sequence more closely even if in our embedded implementation some of the functions don't do much.
  Uses the default colour backend for 32bpp BGR output for most of the unusual cases.
  The most common 2x2 subsampling case uses a custom merged upsampler and colour converter, with colour output directly in RISC OS format for the respective screen mode.
Admin:
  Submission for the JPEG bounty.

Version 1.71. Tagged as 'SprExtend-1_71'
@
text
@a20 1
#define AVOID_TABLES    /* Shifting is cheap & avoids relocating const tables */
@


4.8
log
@Update headers to stock copy
Detail:
  Added headers jerror, jmorecfg, jpegint from IJG8d. Removed jpegdata header.
  Bulk rename of structure members to match newer headers, some RISCOS-isms wrapped in #ifdef RISCOS, retained for the time being.
  Assembler code now gets cinfo member offsets from jhdr.s derived from the C header rather than keeping its own dangerous copy of the offsets.
Admin
  Note: this has broken CFSI-jpeg as it expects the error values to be at the top of cinfo.
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_70-headers.
@
text
@d18 6
@


4.7
log
@Add support for new sprite types & screen modes
Detail:
  Makefile - Updated to fix a couple of dependency issues and to make c/asmcore the main C file, not c/putscaled
  Sources/PutScaled - Add a utility routine that's used by the C code to get information about pixel formats
  Sources/SprAdjSize - Add support for wide masks & RISC OS 5 style sprite mode words
  Sources/SprExtend - Tidy up workspace by removing lots of unused bits and moving other bits within sight of the C code. Add flag to control whether C or assembler version of SprTrans is used. Query kernel for ECFYOffset/ECHShift locations instead of using hardcoded values in putscaled code. Add fix for garbage debug strings in softloaded debug versions of the module.
  Sources/SprOp - Add support for wide masks & RISC OS 5 style sprite mode words. Update makepalette16bpp to cope with all the new 16bpp modes. Flag_* -> ModeFlag_* renaming. Move some translation table handling code into a new routine, 'preparettr'. Update checktrans/converttrans to deal with new pixel formats.
  Sources/SprTrans - If the C version of SprTrans is enabled, disable all of these assembler bits except for the outer loop which steps over each row of the screen
  Sources/jdcolor - Updated to deal with new pixel formats. 16bpp conversion code split off into new file, Sources/jdcolor16.
  Sources/jdcolor16 - New file containing the guts of the YUV -> 16bpp conversion code. Gets included multiple times with different options to generate the different conversion routines (code is too big for a macro).
  c/asmcore - New file containing lots of common code ripped out of c/PutScaled - e.g. workspace definition, main functions for register assignment & instruction generation, and code for pixel format conversion. Pixel format conversion code rewritten to cope with new pixel formats, and code buffer key word generation rewritten to fix a couple of bugs (e.g. some issues with dithering options were observed)
  c/PutScaled - Ripped out lots of code that's now in c/asmcore. Now just deals with things that are PutScaled-specific, e.g. main plotter loop containing pixel read/write code. Code extended to cope with new pixel formats
  c/rojpeg, h/jinclude, h/jpegdata - Code extended to cope with new 16bpp conversion routines
  c/sprtrans - New C implementation of the core per-row transformed sprite plotting code generator. Allows reuse of the extensive pixel conversion code in c/asmcore, and allows for better code generation than the assembler original.
  h/putscaled - Worksapce definition updated to match assembler version
Admin:
  Tested on BB-xM, plotting lots of different sprites in lots of different modes
  Plotting of wide mask sprites not supported yet
  C version of YUV -> 16bpp code currently only deals with traditional &BGR 555 pixel format - code is aware of this and will do conversion to desired format if applicable (although quality may be reduced)
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 1.52. Tagged as 'SprExtend-1_52'
@
text
@d4 1
a4 1
 * Copyright (C) 1991, 1992, Thomas G. Lane.
d8 7
a14 5
 * This is the central file that's #include'd by all the JPEG .c files.
 * Its purpose is to provide a single place to fix any problems with
 * including the wrong system include files.
 * You can edit these declarations if you use a system with nonstandard
 * system include files.
a16 3
/* RISCOS thing - only allow this file to be included once */
#ifndef jinclude__
#define jinclude__
d18 4
d24 8
a31 4
 * Normally the __STDC__ macro can be taken as indicating that the system
 * include files conform to the ANSI C standard.  However, if you are running
 * GCC on a machine with non-ANSI system include files, that is not the case.
 * In that case change the following, or add -DNONANSI_INCLUDES to your CFLAGS.
d34 6
a39 3
#ifdef __STDC__
#ifndef NONANSI_INCLUDES
#define INCLUDES_ARE_ANSI       /* this is what's tested before including */
d41 3
d46 2
d49 7
a55 4
 * We need the size_t typedef, which defines the parameter type of malloc().
 * In an ANSI-conforming implementation this is provided by <stdio.h>,
 * but on non-ANSI systems it's more likely to be in <sys/types.h>.
 * On some not-quite-ANSI systems you may find it in <stddef.h>.
d58 12
a69 5
#ifndef INCLUDES_ARE_ANSI       /* shouldn't need this if ANSI C */
#include <sys/types.h>
#endif
#ifdef __SASC                   /* Amiga SAS C provides it in stddef.h. */
#include <stddef.h>
d80 1
a80 2
#undef SIZEOF                   /* in case you included X11/xmd.h */
#define SIZEOF(object)  ((size_t) sizeof(object))
d83 3
a85 5
 * We need the memcpy() and strcmp() functions, plus memory zeroing.
 * ANSI and System V implementations declare these in <string.h>.
 * BSD doesn't have the mem() functions, but it does have bcopy()/bzero().
 * NOTE: we assume the size parameters to these functions are of type size_t.
 * Insert casts in these macros if not!
d88 4
a91 73
#ifdef INCLUDES_ARE_ANSI
  #include <string.h>
  #define MEMZERO(voidptr,size)   memset((voidptr), 0, (size))
#else /* not ANSI */
  #ifdef BSD
    #include <strings.h>
    #define MEMZERO(voidptr,size)   bzero((voidptr), (size))
    #define memcpy(dest,src,size)   bcopy((src), (dest), (size))
  #else /* not BSD, assume Sys V or compatible */
    #include <string.h>
    #define MEMZERO(voidptr,size)   memset((voidptr), 0, (size))
  #endif /* BSD */
#endif /* ANSI */


/* Now include the portable JPEG definition files. */
#include "jconfig.h"
#include "jpegdata.h"

/* For jdcolor */
int mono_convert_pixel(int pix);
void mono_convert_pixels(int *y);
void mono_convert_block(JBLOCK jblock, int *outptr, int outoffset);
void mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset);
void colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset,
                                  int wide, int high);
void colour_convert_pixels(int *y, int u, int v);
void colour_convert_block_8(JBLOCK jblock, char *outptr, int outoffset);
void colour_convert_block_16(JBLOCK jblock, short *outptr, int outoffset);
void colour_convert_block_32(JBLOCK jblock, int *outptr, int outoffset);

convert_block_16_func asm_get_convert_block_16_func(int ncolour,int modeflags);

#ifdef ASMIDCT
/* Optionally assembler coded IDCT stuff */
#define jpeg_idct_ifast(i,b,c)            asm_jpeg_idct_ifast(i,b,c)
void asm_jpeg_idct_ifast(decompress_info_ptr cinfo, JBLOCK block, int count);
#endif

#ifdef ASMHUFF
/* Optionally assembler coded Huffman stuff */
#define huff_decode_blocks(a,b,c,d,e,f,g) asm_huff_decode_blocks(a,b,c,d,e,f,g)
#define huff_skip_blocks(a,b,c,d,e,f,g)   asm_huff_skip_blocks(a,b,c,d,e,f,g)
void asm_huff_decode_blocks(decompress_info_ptr cinfo, JBLOCK block,
                            HUFF_TBL *dctbl, HUFF_TBL *actbl, QUANT_TBL_PTR quanttbl,
                            int *last_dc_val, int nblocks);
void asm_huff_skip_blocks(decompress_info_ptr cinfo, JBLOCK block,
                          HUFF_TBL *dctbl, HUFF_TBL *actbl, QUANT_TBL_PTR quanttbl,
                          int *last_dc_val, int nblocks);
#endif

#ifdef ASMCOLOR
/* Optionally assembler coded colour conversion stuff */
#define mono_convert_pixel(p)             asm_mono_convert_pixel(p)
#define mono_convert_pixels(y)            asm_mono_convert_pixels(y)
#define mono_convert_block(j,o,f)         asm_mono_convert_block(j,o,f)
#define mono_convert_block_8(j,o,f)       asm_mono_convert_block_8(j,o,f)
#define colour_convert_block_8(j,o,f)     asm_colour_convert_block_8(j,o,f)
#define colour_convert_block_32(j,o,f)    asm_colour_convert_block_32(j,o,f)
#define colour_convert_unusual_block(a,b,c,d,e) asm_colour_convert_unusual_block(a,b,c,d,e)
#define colour_convert_pixels(y,u,v)      asm_colour_convert_pixels(y,u,v)
int asm_mono_convert_pixel(int pix);
void asm_mono_convert_pixels(int *y);
void asm_mono_convert_block(JBLOCK jblock, int *outptr, int outoffset);
void asm_mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset);
void asm_colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset,
                                      int wide, int high);
void asm_colour_convert_pixels(int *y, int u, int v);
void asm_colour_convert_block_8(JBLOCK jblock, char *outptr, int outoffset);
void asm_colour_convert_block_32(JBLOCK jblock, int *outptr, int outoffset);
#endif

#endif
@


4.6
log
@Adopt colour conversions from MigrateIJG8b branch
Now for every colour conversion there is a corresponding C function, allowing swapping between them for test purposes.
Here, 'ASMCOLOR' is selected and the C functions not even referenced in the makefile, see branch for use.
Permits use of USAT, for a small 1.5% speedup and smaller code.
Some other typedefs and comment shuffling copied over - should be harmless.

Version 1.50. Tagged as 'SprExtend-1_50'
@
text
@d97 2
a123 1
#define colour_convert_block_16(j,o,f)    asm_colour_convert_block_16(j,o,f)  
a134 1
void asm_colour_convert_block_16(JBLOCK jblock, short *outptr, int outoffset);
@


4.5
log
@Reorganise rojpeg.
Aside from moving blocks around and adding comments, decisions about numcomponents use switch/case statements to allow CMYK support in the future.
Split out (some of the) Huffman decoding to allow arithmetic support in the future.
Moved memcpy() and memset() into CSupport.
Tested in all colour depths with 1x1; 1x2; 2x1; 2x2 sampling & ChangeFSI.
Tighten up check on cinfo being NULL (was previously only checked in the colour decoder, not the monochrome).

Version 1.37. Tagged as 'SprExtend-1_37'
@
text
@a81 1

d83 1
d85 17
a101 1
#include "jpegdata.h"
a102 1
/* Assembler coded stuff */
d104 9
a112 9
extern void
asm_huff_decode_blocks(decompress_info_ptr cinfo, JBLOCK block,
                   HUFF_TBL *dctbl, HUFF_TBL *actbl, QUANT_TBL_PTR quanttbl,
                   int *last_dc_val, int nblocks);

extern void
asm_huff_skip_blocks(decompress_info_ptr cinfo, JBLOCK block,
                 HUFF_TBL *dctbl, HUFF_TBL *actbl, QUANT_TBL_PTR quanttbl,
                 int *last_dc_val, int nblocks);
d115 21
a135 4
#ifdef STATS
#define asm_j_rev_dct(i,b,c) j_rev_dct(i,b,c) /* Substitute 'Sources.jrevdct' for 'c.jrevdct4' */
#else
extern void asm_j_rev_dct(decompress_info_ptr cinfo, JBLOCK block, int count);
a136 9
extern void asm_mono_convert_block(JBLOCK jblock, int *outptr, int outoffset);
extern void asm_mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset);
extern void asm_colour_convert_block(JBLOCK jblock, int *outptr, int outoffset);
extern void asm_colour_convert_block_16(JBLOCK jblock, short int *outptr, int outoffset);
extern void asm_colour_convert_block_8(JBLOCK jblock, char *outptr, int outoffset);
extern void asm_diffuse_to_8bpp(int *line, int linelength, char *output, char *table32k, int nlines, int linestep, int *palette_data);
extern char *asm_get_table32k(int *palette_data/*void*/);
extern void asm_convert_to_8bpp_grey(int *line, int linelength, char *output, int nlines, int linestep);
extern void asm_diffuse_to_24bpp(int *line, int linelength, int *output, char *table32k, int nlines, int linestep, int *palette_data);
@


4.5.2.1
log
@Push some redundant files into the attic.
@
text
@@


4.5.2.2
log
@Create assembler equivalents of C colour conversions, approx 10% speed up.
Add new switch ASMCOLOR to select which to use, C or assembler.
Remove FILE_ exit trace concept, just use __FILE__ instead in exit_erl.
Add some comments to exit_erl and friends.
A few bits of cinfo setup moved into start_pass_huff_decoder() or eliminated.
Bumped up the precision of SCALE_BITS in the C colour handling so FIX() uses more bits of an int.
Deleted the unused remenants of light dithering in the 8bpp colour converter - saves a few cycles.
colour_convert_8 and colour_convert_16 no longer save entry registers the C compiler doesn't care about.
Update genyuvtabs to EXPORT the table bases.
Split out the compilation of IJG files as separate objects in the make file, rather than including them from within rojpeg, which is itself included from putscaled.

Version 1.38, 1.35.2.6. Tagged as 'SprExtend-1_38-1_35_2_6'
@
text
@d4 1
a4 1
 * Copyright (C) 1991-1994, Thomas G. Lane.
d8 5
a12 7
 * This file exists to provide a single place to fix any problems with
 * including the wrong system include files.  (Common problems are taken
 * care of by the standard jconfig symbols, but on really weird systems
 * you may have to edit this file.)
 *
 * NOTE: this file is NOT intended to be included by applications using the
 * JPEG library.  Most applications need only include jpeglib.h.
d15 3
a18 4
/* Include auto-config file to find out which system include files we need. */

#include "jconfig.h"		/* auto configuration options */
#define JCONFIG_INCLUDED	/* so that jpeglib.h doesn't do it again */
d21 4
a24 8
 * We need the NULL macro and size_t typedef.
 * On an ANSI-conforming system it is sufficient to include <stddef.h>.
 * Otherwise, we get them from <stdlib.h> or <stdio.h>; we may have to
 * pull in <sys/types.h> as well.
 * Note that the core JPEG library does not require <stdio.h>;
 * only the default error handler and data source/destination modules do.
 * But we must pull it in because of the references to FILE in jpeglib.h.
 * You can remove those references if you want to compile without <stdio.h>.
d27 3
a29 2
#ifdef HAVE_STDDEF_H
#include <stddef.h>
a30 7

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#ifdef NEED_SYS_TYPES_H
#include <sys/types.h>
a32 2
#include <stdio.h>

d34 4
a37 7
 * We need memory copying and zeroing functions, plus strncpy().
 * ANSI and System V implementations declare these in <string.h>.
 * BSD doesn't have the mem() functions, but it does have bcopy()/bzero().
 * Some systems may declare memset and memcpy in <memory.h>.
 *
 * NOTE: we assume the size parameters to these functions are of type size_t.
 * Change the casts in these macros if not!
d40 5
a44 12
#ifdef NEED_BSD_STRINGS

#include <strings.h>
#define MEMZERO(target,size)	bzero((void *)(target), (size_t)(size))
#define MEMCOPY(dest,src,size)	bcopy((const void *)(src), (void *)(dest), (size_t)(size))

#else /* not BSD, assume ANSI/SysV string lib */

#include <string.h>
#define MEMZERO(target,size)	memset((void *)(target), 0, (size_t)(size))
#define MEMCOPY(dest,src,size)	memcpy((void *)(dest), (const void *)(src), (size_t)(size))

d55 2
a56 1
#define SIZEOF(object)	((size_t) sizeof(object))
d59 5
a63 3
 * The modules that use fread() and fwrite() always invoke them through
 * these macros.  On some systems you may need to twiddle the argument casts.
 * CAUTION: argument order is different from underlying functions!
d66 50
a115 4
#define JFREAD(file,buf,sizeofbuf)  \
  ((size_t) fread((void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
#define JFWRITE(file,buf,sizeofbuf)  \
  ((size_t) fwrite((const void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
@


4.4
log
@Paper and fill some JPEG cracks.
The exit_c function was repeatedly being called with the line number argument and error code the wrong way round and since only bits 0-2 of the error code are inspected on exit any fatal exits from the ported JPEG library code would either report the wrong error or fail silently (depending on the line number) - example a 12 bits per sample JPEG would be rendered without fault into a screen full of random memory garbage.
Assembling/compiling with the 'jpeg' switch off didn't work, fixed, and also now zeros out the SWI decode values in the module header.
Moved include of 'yuvtabs.s' into the colour conversion code.
Deleted panic_exit, it did nothing useful but trace a value then exit, so it now just calls exit() like everyone else.
Removed excess call to find_image_dims(), this was needed just to get the workspace requirements when the JPEG had already been sized up by asm_find_image_dims() earlier. Side effect of removing the pilot JPEG code earlier is that this call can now only get to the JPEG code from a JPEG_ SWI. Changed to just pass the workspace requirements into 'c.PutScaled' and save a duplicate scan.
Fatal exits from the assembler huffman decoder now report a sensible error.
Trimmed out all the JPEG assessment code from 'c.PutScaled' and moved it into 'c.rojpeg' so the put scaled is only concerned with putting things scaled.
Sanitised the #includes a bit.
Fixed on last check of wp->save_mode looking at the wrong bits for the mode number.
Resolved all the warning in the genhdr/genyuvtabs/genpalette utilities by casting a bit harder.[A[B
Added new more descriptive error messages to the messages file (not currently used), and made the 'not supported by' ones consistent so the tokeniser might crunch the file a bit more.
In looks_like_jpeg() changed a bitwise to logical or.
Fixed longstanding problem of not being able to render JPEGs at a scale of less than 1/6 in any greyscale mode, because, err, there was no code to do it - only the colour case was checked for. Implemented for 8bpp grey and 32bpp grey (which gets dithered for other lower modes) by just converting the luma channel into an equally weighted RGB value or replicating it for 256 greys.
Tested in all 8 colour depths on a Risc PC using sampling ratios of 1x1; 2x1; 1x2; 2x2 of the IJG test image scaled in !Draw by 0.16.

Version 1.32. Tagged as 'SprExtend-1_32'
@
text
@d100 3
d104 1
@


4.3
log
@Clean up pass.
Trim 200+ lines of changes dating back to 1987, combine with non duplicates in the 'BlackLog'.
Use 'offsetof' macro in genjhdr to avoid warnings about uninitialised variables, rename from makejhdr so all the utils are clearly demarked.
Add throwback to MkCFSI-j.
Replace reason codes passed to SWIs with textual equivalents from the respective header files.
Speed up SWI despatch a bit by making the first few debug instructions depend on 'debuggs'.
Qualify all of the debug switches with the global 'debug' one.
Eliminate single use of 'pullx' macro.
Make do_branch() take an unsigned opcode so 50% of the branches don't result in implied cast warnings.
Added an UNUSED() macro to reduce a few of the legitimate warnings (the remainder are either in the original JPEG code or ones that it is worth checking the logic of.
Unixify one last filename.

Version 1.24. Tagged as 'SprExtend-1_24'
@
text
@a97 2

extern void panic_exit(int i);
@


4.2
log
@Version RO_3_70 taken
@
text
@a107 1
extern void asm_diffuse_line_to_8bpp(int *line, int linelength, char *output, char *table32k);
@


4.1
log
@Initial revision
@
text
@d104 1
d110 3
a112 1
extern char *asm_get_table32k(void);
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a103 1
extern void asm_mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset);
d109 1
a109 3
extern char *asm_get_table32k(int *palette_data/*void*/);
extern void asm_convert_to_8bpp_grey(int *line, int linelength, char *output, int nlines, int linestep);
extern void asm_diffuse_to_24bpp(int *line, int linelength, int *output, char *table32k, int nlines, int linestep, int *palette_data);
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

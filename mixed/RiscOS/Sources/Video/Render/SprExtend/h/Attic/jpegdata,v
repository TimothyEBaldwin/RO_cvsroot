head	4.8;
access;
symbols
	SprExtend-1_70:4.7
	SprExtend-1_69:4.7
	SprExtend-1_68:4.7
	SprExtend-1_67:4.7
	SprExtend-1_66:4.7
	SprExtend-1_65:4.7
	SprExtend-1_64:4.7
	SprExtend-1_63:4.7
	SprExtend-1_62:4.7
	SprExtend-1_61:4.7
	SprExtend-1_60:4.7
	SprExtend-1_59:4.7
	SprExtend-1_58:4.7
	SprExtend-1_57:4.7
	SprExtend-1_56:4.7
	SprExtend-1_55:4.7
	SprExtend-1_54:4.7
	SprExtend-1_53:4.7
	SprExtend-1_52:4.7
	SprExtend-1_51:4.6
	SprExtend-1_50:4.6
	SprExtend-1_49:4.5
	SprExtend-1_48:4.5
	SprExtend-1_47:4.5
	SprExtend-1_46:4.5
	SprExtend-1_45:4.5
	SprExtend-1_44:4.5
	SprExtend-1_43:4.5
	SprExtend-1_42:4.5
	SprExtend-1_41:4.5
	SprExtend-1_40:4.5
	SprExtend-1_39:4.5
	MigrateIJG8b:4.5.0.2
	SprExtend-1_38:4.5
	SprExtend-1_37:4.5
	SprExtend-1_36:4.4
	SprExtend-1_35:4.4
	SprExtend-1_34:4.4
	SprExtend-1_33:4.4
	SprExtend-1_32:4.3
	SprExtend-1_31:4.2
	SprExtend-1_30:4.2
	SprExtend-1_29:4.1
	SprExtend-1_28:4.1
	SprExtend-1_27:4.1
	SprExtend-1_26:4.1
	SprExtend-1_25:4.1
	SprExtend-1_24:4.1
	SprExtend-1_23:4.1
	SprExtend-1_22:4.1
	SprExtend-1_21:4.1
	SprExtend-1_20:4.1
	SprExtend-1_19:4.1
	SprExtend-1_18:4.1
	SprExtend-1_17:4.1
	RO_5_07:4.1
	SprExtend-1_16:4.1
	SprExtend-1_15:4.1
	SprExtend-1_14:4.1
	SprExtend-1_13:4.1
	SprExtend-1_12:4.1
	SprExtend-1_11:4.1
	SprExtend-1_10:4.1
	SprExtend-1_09:4.1
	SprExtend-1_08:4.1
	dellis_autobuild_BaseSW:4.1
	SprExtend-1_07:4.1
	SprExtend-1_06:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	SprExtend-1_05:4.1
	Ursula_merge:4.1
	nturton_SprExtend-1_04:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2016.05.21.13.32.23;	author rool;	state dead;
branches;
next	4.7;
commitid	yTqS85yKh7k8Ul7z;

4.7
date	2013.08.06.23.16.26;	author jlee;	state Exp;
branches;
next	4.6;
commitid	z9XOph7zDZQ2Ur0x;

4.6
date	2012.07.28.15.23.44;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	b5jdybqzJ3Wdjlew;

4.5
date	2010.12.22.08.22.36;	author rsprowson;	state Exp;
branches
	4.5.2.1;
next	4.4;

4.4
date	2010.10.17.09.01.39;	author rsprowson;	state Exp;
branches;
next	4.3;

4.3
date	2010.10.13.20.26.25;	author rsprowson;	state Exp;
branches;
next	4.2;

4.2
date	2010.09.29.21.05.33;	author rsprowson;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.45.08;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.5.2.1
date	2011.01.04.21.18.11;	author rsprowson;	state dead;
branches;
next	;

4.1.1.1
date	96.11.05.09.45.08;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.41.43;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.57.52;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.20.31;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Update headers to stock copy
Detail:
  Added headers jerror, jmorecfg, jpegint from IJG8d. Removed jpegdata header.
  Bulk rename of structure members to match newer headers, some RISCOS-isms wrapped in #ifdef RISCOS, retained for the time being.
  Assembler code now gets cinfo member offsets from jhdr.s derived from the C header rather than keeping its own dangerous copy of the offsets.
Admin
  Note: this has broken CFSI-jpeg as it expects the error values to be at the top of cinfo.
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_70-headers.
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * jpegdata.h
 *
 * Copyright (C) 1991, 1992, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file defines shared data structures for the various JPEG modules.
 *
 * Seriously updated for use deep in RISCOS.
 */

#define METHODDEF static        /* a function called through method pointers */
#define LOCAL     static        /* a function used only in its module */
#define GLOBAL    static
#define EXTERN    static
#define FAR

#define METHOD(type,methodname,arglist)  type (*methodname) arglist

/* Data structures for images containing either samples or coefficients. */
/* Note that the topmost (leftmost) index is always color component. */

typedef JSAMPLE FAR *JSAMPROW;  /* ptr to one image row of pixel samples. */
typedef JSAMPROW *JSAMPARRAY;   /* ptr to some rows (a 2-D sample array) */
typedef JSAMPARRAY *JSAMPIMAGE; /* a 3-D sample array: top index is color */

#define DCTSIZE         8       /* The basic DCT block is 8x8 samples */
#define DCTSIZE2        64      /* DCTSIZE squared; # of elements in a block */

typedef JCOEF JBLOCK[DCTSIZE2]; /* one block of coefficients */
typedef JBLOCK FAR *JBLOCKROW;  /* pointer to one row of coefficient blocks */
typedef JBLOCKROW *JBLOCKARRAY;         /* a 2-D array of coefficient blocks */
typedef JBLOCKARRAY *JBLOCKIMAGE;       /* a 3-D array of coefficient blocks */

typedef JCOEF FAR *JCOEFPTR;    /* useful in a couple of places */

/* The input and output data of the DCT transform subroutines are of
 * the following type, which need not be the same as JCOEF.
 * For example, on a machine with fast floating point, it might make sense
 * to recode the DCT routines to use floating point; then DCTELEM would be
 * 'float' or 'double'.
 */

typedef JCOEF DCTELEM;
typedef DCTELEM DCTBLOCK[DCTSIZE2];

/* -------------------- Statistics on JPEG files ------------------------- */

#ifdef STATS
typedef struct
{
  int n_jblocks;                  /* JBLOCKs analysed */
  int n_nonzero_coeff[DCTSIZE2];  /* no of JBLOCKs with this many nonzero coeffs,
                                     given absolute DC value (not just delta). */

  int n_lines_thismany_nonzero_coeffs_pass1[DCTSIZE]; /* just ac coeffs */
  int n_lines_thismany_nonzero_coeffs_pass2[DCTSIZE];

  int n_pass1_ac_zero;
  int n_pass1_ac_dc_zero;
  int n_pass1_ac_nonzero;

  int n_pass1_even_zero; /* no of rows in pass 1 with even coeffs zero */
  int n_pass1_odd_zero;
  int n_pass1_odd_nonzero;

  int higher_coeff_all_zero[DCTSIZE]; /* higher coeffs than this are all zero, in pass 1 */

} stats_struct;
#define IFSTATS(a) a
#else
#define IFSTATS(a)
#endif

/* ----------- Types for JPEG compression parameters and working tables. ---------- */

typedef enum {                  /* defines known color spaces */
        CS_UNKNOWN,             /* error/unspecified */
        CS_GRAYSCALE,           /* monochrome (only 1 component) */
        CS_RGB,                 /* red/green/blue */
        CS_YCbCr,               /* Y/Cb/Cr (also known as YUV) */
        CS_YIQ,                 /* Y/I/Q */
        CS_CMYK                 /* C/M/Y/K */
} COLOR_SPACE;


typedef struct {                /* Basic info about one component */
  /* These values are fixed over the whole image */
  /* For compression, they must be supplied by the user interface; */
  /* for decompression, they are read from the SOF marker. */
        int /*short*/ component_id;     /* identifier for this component (0..255) */
        int /*short*/ component_index;  /* its index in SOF or cinfo->comp_info[] */
        int /*short*/ h_samp_factor;    /* horizontal sampling factor (1..4) */
        int /*short*/ v_samp_factor;    /* vertical sampling factor (1..4) */
        int /*short*/ quant_tbl_no;     /* quantization table selector (0..3) */
  /* These values may vary between scans */
  /* For compression, they must be supplied by the user interface; */
  /* for decompression, they are read from the SOS marker. */
        int /*short*/ dc_tbl_no;        /* DC entropy table selector (0..3) */
        int /*short*/ ac_tbl_no;        /* AC entropy table selector (0..3) */
  /* These values are computed during compression or decompression startup */
        long true_comp_width;   /* component's image width in samples */
        long true_comp_height;  /* component's image height in samples */
        /* the above are the logical dimensions of the subsampled image */
  /* These values are computed before starting a scan of the component */
        int /*short*/ MCU_width;        /* number of blocks per MCU, horizontally */
        int /*short*/ MCU_height;       /* number of blocks per MCU, vertically */
        int /*short*/ MCU_blocks;       /* MCU_width * MCU_height */
        long subsampled_width;  /* image width in samples, after expansion */
        long subsampled_height; /* image height in samples, after expansion */
        /* the above are the true_comp_xxx values rounded up to multiples of */
        /* the MCU dimensions; these are the working dimensions of the array */
        /* as it is passed through the DCT or IDCT step.  NOTE: these values */
        /* differ depending on whether the component is interleaved or not!! */
} jpeg_component_info;


/* DCT coefficient quantization tables.
 * For 8-bit precision, 'INT16' should be good enough for quantization values;
 * for more precision, we go for the full 16 bits.  'INT16' provides a useful
 * speedup on many machines (multiplication & division of JCOEFs by
 * quantization values is a significant chunk of the runtime).
 * Note: the values in a QUANT_TBL are always given in zigzag order.
 */
typedef int QUANT_VAL;
typedef QUANT_VAL QUANT_TBL[DCTSIZE2];  /* A quantization table */
typedef QUANT_VAL * QUANT_TBL_PTR;      /* pointer to same */


typedef struct {                /* A Huffman coding table */
  /* These two fields directly represent the contents of a JPEG DHT marker */

        UINT8 bits[17];         /* bits[k] = # of symbols with codes of */
                                /* length k bits; bits[0] is unused */
        UINT8 huffval[256];     /* The symbols, in order of incr code length */

  /* The remaining fields are computed from the above to allow more efficient
   * coding and decoding.  These fields should be considered private to the
   * Huffman compression & decompression modules.
   */
        /* decoding tables: (element [0] of each array is unused) */
#if 0
        UINT32 /*UINT16*/ mincode[17];     /* smallest code of length k */
#endif
        INT32 maxcode[18];      /* largest code of length k (-1 if none) */
        /* (maxcode[17] is a sentinel to ensure huff_DECODE terminates) */
        int /*short*/ valptr[17];       /* huffval[] index of 1st symbol of length k */
                                        /* with value of mincode[k] from above subtracted */

        int shortcut[256]; /* shortcuts the actual reading of huffman values - indexed
                              by the next 8 bits in the bit stream an entry tells you
                              how long the next entry is. This allows you to read
                              the vast majority of huffman codes at a single step. */
} HUFF_TBL;


#define NUM_QUANT_TBLS      4   /* quantization tables are numbered 0..3 */
#define NUM_HUFF_TBLS       4   /* Huffman tables are numbered 0..3 */
#define NUM_ARITH_TBLS      16  /* arith-coding tables are numbered 0..15 */
#define MAX_COMPS_IN_SCAN   4   /* JPEG limit on # of components in one scan */
#define MAX_SAMP_FACTOR     4   /* JPEG limit on sampling factors */
#define MAX_BLOCKS_IN_MCU   10  /* JPEG limit on # of blocks in an MCU */

/* ----------- Remember a precise position in the huffman stream. ------------------ */
typedef struct
{
  int bit_pointer;   /* (next_input_byte-input_buffer)*32 + bits_left */
  int get_buffer;
  short int last_dc_val0; /* NB NOT dequantised */
  short int last_dc_val1;
  short int last_dc_val2;
  short int last_dc_val3; /* in case we ever do CMYK */
  short int restarts_to_go;
  short int next_restart_num;
} huff_pointer;

/* ------------- Error codes for various forms of unacceptable JPEG file ------------- */
#define E_PRE_NOT_8         1            /* Unsupported - Data precision not 8 */
#define E_MULTI_SCAN        2            /* Unsupported - Multi scan file */
#define E_COMPONENTS        3            /* Unsupported - Bad number of components, only 1 or 3 allowed */
#define E_BAD_SAMPLE        4            /* Bad sample factor */
#define E_HEIGHT_DISAGREES  5            /* Height is not as specified */
#define E_WIDTH_DISAGREES   6            /* Width is not as specified */
#define E_COLOUR            7            /* Bad colour space, not grey or YUV */
#define E_TOO_WIDE          8            /* Image too wide based on number of MCUs */

/* ------------- Working data for decompression ---------------------------------- */

typedef void (*convert_block_16_func)(JCOEF *yuv,short *outptr,int outoffset);

struct decompress_info_struct {

        int error_code;         /* Returned err code, 0 if no error */
        int error_argument1;    /* Supplementary error data */
        int error_argument2;    /* Supplementary error data */

        char *workspace_UNUSED;        /* For band buffer and things. (no, implicitly at end of this space now) */
        int workspace_size;     /* number of bytes */
/* up to here appears in sources.SprExtend */

        int /*long*/ image_width;       /* overall image width */
        int /*long*/ image_height;      /* overall image height */
        COLOR_SPACE jpeg_color_space; /* colorspace of JPEG file */
/* up to here is replicated somewhat in CFSI-JPEG's interface */

        char *table32k; /* the 16bpp->8bpp 32K lookup table, if you need it. */
        BOOL table32k_unavailable; /* Set if we ever failed to get table32k.
                                   This means we're probably on an old OS, so the
                                   table will never be available. */
        convert_block_16_func convert_block_16; /* Colour conversion function to use for 16bpp output */

        int *band_buffer; /* Large buffer into which the colour data goes. */
                          /* We construct one strip, 8 or 16 pixels high, across the image. */
        int band_buffer_size; /* Must be a multiple of 16 */

        const JOCTET *jpeg_buffer; /* start of buffer (private to input code) */
        size_t jpeg_size;          /* buffer extent */
        const JOCTET *next_input_byte;    /* => next byte to read from buffer */

        int data_precision;   /* bits of precision in image data */

        /* These three values are not used by the JPEG code, merely copied */
        /* from the JFIF APP0 marker (if any). */
        UINT32 /*UINT8*/ density_unit;     /* JFIF code for pixel size units */
        UINT32 /*UINT16*/ X_density;       /* Horizontal pixel density */
        UINT32 /*UINT16*/ Y_density;       /* Vertical pixel density */

        int /*short*/ num_components;   /* # of color components in JPEG image */
        jpeg_component_info * comp_info;
        /* comp_info[i] describes component that appears i'th in SOF */

        QUANT_TBL_PTR quant_tbl_ptrs[NUM_QUANT_TBLS];
        /* ptrs to coefficient quantization tables, or NULL if not defined */

        HUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
        HUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
        /* ptrs to Huffman coding tables, or NULL if not defined */

        UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
        UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
        UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */

        boolean arith_code;     /* TRUE=arithmetic coding, FALSE=Huffman */
        boolean CCIR601_sampling; /* TRUE=first samples are cosited */

        UINT32 /*UINT16*/ restart_interval;/* MDUs per restart interval, or 0 for no restart */
        int restarts_to_go;
        int next_restart_num;

/*
 * These fields are valid during any one scan
 */
        int /*short*/ comps_in_scan;    /* # of JPEG components input this time */
        jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
        /* *cur_comp_info[i] describes component that appears i'th in SOS */

        long MCUs_per_row;      /* # of MCUs across the image */
        long MCU_rows_in_scan;  /* # of MCU rows in the image */

        /* these fields are private data for the entropy encoder */
        JCOEF last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each comp - NOT dequantized yet */

        int current_huff_pointer; /* Currently loaded band, or -1 if none. */
        int xmin;
        int xmax;                 /* Min and max x pixels required: clip as early
                                  as possible. */
        int options;

        /* Statics moved in from the huffman decoding */
        int get_buffer;
        int bits_left;

        /* Random check words to look for the same sprite over again */
        int check1;
        int check2;
        int check3;

        IFSTATS(stats_struct stats;)       /* Gathering statistics */

        JBLOCK jblocks[7]; /* YYYYUV blocks, and one spare at the front */

#define HPOINTERS 200 /* max picture depth 16*this for colour, 8*this for mono, in pixels */
        huff_pointer *huff_pointers;
                      /* An array of information every 16 pixel lines, which
                      allows us to start decoding the file at that point. This
                      allows reasonably quick random access to anywhere in the file. */

        /* Space always needed, and pointed at by some of the pointers above. */

        jpeg_component_info s_cur_comp_info[MAX_COMPS_IN_SCAN];
        QUANT_TBL s_quant_tbl[NUM_QUANT_TBLS];
        HUFF_TBL s_dc_huff_tbl[NUM_HUFF_TBLS];
        HUFF_TBL s_ac_huff_tbl[NUM_HUFF_TBLS];
};

typedef struct decompress_info_struct * decompress_info_ptr;


/* Macros for reading data from the decompression input buffer */

/* The buffer contains the entire file */
#define JGETC(cinfo) (int) ((cinfo)->next_input_byte >= &(cinfo)->jpeg_buffer[(cinfo)->jpeg_size] ? 255 : *(cinfo)->next_input_byte++)

/* Macros to simplify using the error and trace message stuff */
/* The first parameter is generally cinfo->emethods, left undisturbed in
   c.jrdjfif but not used here. */
#ifdef DEBUG
  #ifdef EMBED
    #define TRACEMS(emeth,lvl,msg) {do_sprintf(0, msg); newline();}
    #define TRACEMS1(emeth,lvl,msg,p1) {do_sprintf(0, msg,p1); newline();}
    #define TRACEMS2(emeth,lvl,msg,p1,p2) {do_sprintf(0, msg,p1,p2); newline();}
    #define TRACEMS3(emeth,lvl,msg,p1,p2,p3) {do_sprintf(0, msg,p1,p2,p3); newline();}
    #define TRACEMS4(emeth,lvl,msg,p1,p2,p3,p4) {do_sprintf(0, msg,p1,p2,p3,p4); newline();}
    #define TRACEMS8(emeth,lvl,msg,p1,p2,p3,p4,p5,p6,p7,p8) {do_sprintf(0, msg,p1,p2,p3,p4,p5,p6,p7,p8); newline();}
  #else
    #define TRACEMS(emeth,lvl,msg) {if (verbose) {printf(msg); printf("\n");}}
    #define TRACEMS1(emeth,lvl,msg,p1) {if (verbose) {printf(msg,p1); printf("\n");}}
    #define TRACEMS2(emeth,lvl,msg,p1,p2) {if (verbose) {printf(msg,p1,p2); printf("\n");}}
    #define TRACEMS3(emeth,lvl,msg,p1,p2,p3) {if (verbose) {printf(msg,p1,p2,p3); printf("\n");}}
    #define TRACEMS4(emeth,lvl,msg,p1,p2,p3,p4) {if (verbose) {printf(msg,p1,p2,p3,p4); printf("\n");}}
    #define TRACEMS8(emeth,lvl,msg,p1,p2,p3,p4,p5,p6,p7,p8) {if (verbose) {printf(msg,p1,p2,p3,p4,p5,p6,p7,p8); printf("\n");}}
  #endif
#else
  #define TRACEMS(emeth,lvl,msg)
  #define TRACEMS1(emeth,lvl,msg,p1)
  #define TRACEMS2(emeth,lvl,msg,p1,p2)
  #define TRACEMS3(emeth,lvl,msg,p1,p2,p3)
  #define TRACEMS4(emeth,lvl,msg,p1,p2,p3,p4)
  #define TRACEMS8(emeth,lvl,msg,p1,p2,p3,p4,p5,p6,p7,p8)
#endif

#ifdef EMBED
  #ifdef DEBUG
    /* The variable FILE_ is used to identify source files, smaller
     * than __FILE__ (a bit!) for non-debugging code.
     */
    #define EXIT exit_erl(ERROR_BAD_JPEG,FILE_+__LINE__);
  #else
    #define EXIT exit(ERROR_BAD_JPEG);
  #endif
  #define ERREXIT(emeth,msg) {tracef("Error:"); tracef(msg); newline(); EXIT}
  #define ERREXIT1(emeth,msg,p1) {tracef("Error:"); tracef(msg _ p1); newline(); EXIT}
  #define ERREXIT2(emeth,msg,p1,p2) {tracef("Error:"); tracef(msg _ p1 _ p2); newline(); EXIT}
  #define ERREXIT3(emeth,msg,p1,p2,p3) {tracef("Error:"); tracef(msg _ p1 _ p2 _ p3); newline(); EXIT}
  #define ERREXIT4(emeth,msg,p1,p2,p3,p4) {tracef("Error:"); tracef(msg _ p1 _ p2 _ p3 _ p4); newline(); EXIT}
#else
  #define ERREXIT(emeth,msg) {printf("Error:"); printf(msg); printf("\n"); exit(1);}
  #define ERREXIT1(emeth,msg,p1) {printf("Error:"); printf(msg,p1); printf("\n"); exit(1);}
  #define ERREXIT2(emeth,msg,p1,p2) {printf("Error:"); printf(msg,p1,p2); printf("\n"); exit(1);}
  #define ERREXIT3(emeth,msg,p1,p2,p3) {printf("Error:"); printf(msg,p1,p2,p3); printf("\n"); exit(1);}
  #define ERREXIT4(emeth,msg,p1,p2,p3,p4) {printf("Error:"); printf(msg,p1,p2,p3,p4); printf("\n"); exit(1);}
#endif

/* We assume that right shift corresponds to signed division by 2 with
 * rounding towards minus infinity.  This is correct for typical "arithmetic
 * shift" instructions that shift in copies of the sign bit.  But some
 * C compilers implement >> with an unsigned shift.  For these machines you
 * must define RIGHT_SHIFT_IS_UNSIGNED.
 * RIGHT_SHIFT provides a proper signed right shift of an INT32 quantity.
 * It is only applied with constant shift counts.  SHIFT_TEMPS must be
 * included in the variables of any routine using RIGHT_SHIFT.
 */

#ifdef RIGHT_SHIFT_IS_UNSIGNED
#define SHIFT_TEMPS     INT32 shift_temp;
#define RIGHT_SHIFT(x,shft)  \
        ((shift_temp = (x)) < 0 ? \
         (shift_temp >> (shft)) | ((~((INT32) 0)) << (32-(shft))) : \
         (shift_temp >> (shft)))
#else
#define SHIFT_TEMPS
#define RIGHT_SHIFT(x,shft)     ((x) >> (shft))
#endif


/* Miscellaneous useful macros */

#undef MAX
#define MAX(a,b)        ((a) > (b) ? (a) : (b))
#undef MIN
#define MIN(a,b)        ((a) < (b) ? (a) : (b))
@


4.7
log
@Add support for new sprite types & screen modes
Detail:
  Makefile - Updated to fix a couple of dependency issues and to make c/asmcore the main C file, not c/putscaled
  Sources/PutScaled - Add a utility routine that's used by the C code to get information about pixel formats
  Sources/SprAdjSize - Add support for wide masks & RISC OS 5 style sprite mode words
  Sources/SprExtend - Tidy up workspace by removing lots of unused bits and moving other bits within sight of the C code. Add flag to control whether C or assembler version of SprTrans is used. Query kernel for ECFYOffset/ECHShift locations instead of using hardcoded values in putscaled code. Add fix for garbage debug strings in softloaded debug versions of the module.
  Sources/SprOp - Add support for wide masks & RISC OS 5 style sprite mode words. Update makepalette16bpp to cope with all the new 16bpp modes. Flag_* -> ModeFlag_* renaming. Move some translation table handling code into a new routine, 'preparettr'. Update checktrans/converttrans to deal with new pixel formats.
  Sources/SprTrans - If the C version of SprTrans is enabled, disable all of these assembler bits except for the outer loop which steps over each row of the screen
  Sources/jdcolor - Updated to deal with new pixel formats. 16bpp conversion code split off into new file, Sources/jdcolor16.
  Sources/jdcolor16 - New file containing the guts of the YUV -> 16bpp conversion code. Gets included multiple times with different options to generate the different conversion routines (code is too big for a macro).
  c/asmcore - New file containing lots of common code ripped out of c/PutScaled - e.g. workspace definition, main functions for register assignment & instruction generation, and code for pixel format conversion. Pixel format conversion code rewritten to cope with new pixel formats, and code buffer key word generation rewritten to fix a couple of bugs (e.g. some issues with dithering options were observed)
  c/PutScaled - Ripped out lots of code that's now in c/asmcore. Now just deals with things that are PutScaled-specific, e.g. main plotter loop containing pixel read/write code. Code extended to cope with new pixel formats
  c/rojpeg, h/jinclude, h/jpegdata - Code extended to cope with new 16bpp conversion routines
  c/sprtrans - New C implementation of the core per-row transformed sprite plotting code generator. Allows reuse of the extensive pixel conversion code in c/asmcore, and allows for better code generation than the assembler original.
  h/putscaled - Worksapce definition updated to match assembler version
Admin:
  Tested on BB-xM, plotting lots of different sprites in lots of different modes
  Plotting of wide mask sprites not supported yet
  C version of YUV -> 16bpp code currently only deals with traditional &BGR 555 pixel format - code is aware of this and will do conversion to desired format if applicable (although quality may be reduced)
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 1.52. Tagged as 'SprExtend-1_52'
@
text
@@


4.6
log
@Adopt colour conversions from MigrateIJG8b branch
Now for every colour conversion there is a corresponding C function, allowing swapping between them for test purposes.
Here, 'ASMCOLOR' is selected and the C functions not even referenced in the makefile, see branch for use.
Permits use of USAT, for a small 1.5% speedup and smaller code.
Some other typedefs and comment shuffling copied over - should be harmless.

Version 1.50. Tagged as 'SprExtend-1_50'
@
text
@d204 2
d225 1
@


4.5
log
@Reorganise rojpeg.
Aside from moving blocks around and adding comments, decisions about numcomponents use switch/case statements to allow CMYK support in the future.
Split out (some of the) Huffman decoding to allow arithmetic support in the future.
Moved memcpy() and memset() into CSupport.
Tested in all colour depths with 1x1; 1x2; 2x1; 2x2 sampling & ChangeFSI.
Tighten up check on cinfo being NULL (was previously only checked in the colour decoder, not the monochrome).

Version 1.37. Tagged as 'SprExtend-1_37'
@
text
@d228 3
a230 3
        char * input_buffer;    /* start of buffer (private to input code) */
        char * next_input_byte; /* => next byte to read from buffer */
        char * buffer_end;      /* pointer to end of buffer */
d314 1
a314 1
#define JGETC(cinfo) (int) ((cinfo)->next_input_byte >= (cinfo)->buffer_end ? 255 : *(cinfo)->next_input_byte++)
@


4.5.2.1
log
@Push some redundant files into the attic.
@
text
@@


4.4
log
@Change memory management strategy.
There's no need for the C code to know which pool of memory it's using, so simplify it to just use malloc() and realloc(), the assembler implementation can then select whether the RMA or a dynamic area is in use based on the 'dynamicarea' switch.
Be more careful about area_number when it is zero, since we use that to denote the area is not yet set up but area zero is a valid dynamic area number!
Trim out some unused workspace.
Variable ccompiler_errptr had '# 0' bytes assigned, resulting in writes off the end of the workspace.
Retire DUMPVAL[N]() macro.
Remove M_SOF9 as one of the SOF markers accepted - this is allocated to arithmetic JPEGs which aren't currently supported.
Save a few words by: changing arbitrary constants (eg. safety margins) to be a power of two so they can be register immediates; numerous loads and stores of R12 relative variables changed to not use ADRL; jpeg_fetchroutine similarly simplified.

Version 1.33. Tagged as 'SprExtend-1_33'
@
text
@d193 8
a200 10
#define E_PRE_NOT_8         1            /* Data precision not 8 */
#define E_RESTART           2            /* Restart interval not 0 */
#define E_MULTI_SCAN        3            /* Multi-scan file */
#define E_TOO_HIGH          4            /* Image too high, max is %i pixels */
#define E_BAD_SAMPLE        5            /* Bad sample factor */
#define E_HEIGHT            6            /* Height is %i, not as specified */
#define E_WIDTH             7            /* Width is %i, not as specified */
#define E_COLOUR            8            /* Bad colour space (%i), not grey or YUV */
#define E_COMPONENTS        9            /* Bad number (%i) of components, only 1 or 3 allowed */
#define E_TOO_WIDE          10           /* Image too wide, max is %i pixels */
@


4.3
log
@Paper and fill some JPEG cracks.
The exit_c function was repeatedly being called with the line number argument and error code the wrong way round and since only bits 0-2 of the error code are inspected on exit any fatal exits from the ported JPEG library code would either report the wrong error or fail silently (depending on the line number) - example a 12 bits per sample JPEG would be rendered without fault into a screen full of random memory garbage.
Assembling/compiling with the 'jpeg' switch off didn't work, fixed, and also now zeros out the SWI decode values in the module header.
Moved include of 'yuvtabs.s' into the colour conversion code.
Deleted panic_exit, it did nothing useful but trace a value then exit, so it now just calls exit() like everyone else.
Removed excess call to find_image_dims(), this was needed just to get the workspace requirements when the JPEG had already been sized up by asm_find_image_dims() earlier. Side effect of removing the pilot JPEG code earlier is that this call can now only get to the JPEG code from a JPEG_ SWI. Changed to just pass the workspace requirements into 'c.PutScaled' and save a duplicate scan.
Fatal exits from the assembler huffman decoder now report a sensible error.
Trimmed out all the JPEG assessment code from 'c.PutScaled' and moved it into 'c.rojpeg' so the put scaled is only concerned with putting things scaled.
Sanitised the #includes a bit.
Fixed on last check of wp->save_mode looking at the wrong bits for the mode number.
Resolved all the warning in the genhdr/genyuvtabs/genpalette utilities by casting a bit harder.[A[B
Added new more descriptive error messages to the messages file (not currently used), and made the 'not supported by' ones consistent so the tokeniser might crunch the file a bit more.
In looks_like_jpeg() changed a bitwise to logical or.
Fixed longstanding problem of not being able to render JPEGs at a scale of less than 1/6 in any greyscale mode, because, err, there was no code to do it - only the colour case was checked for. Implemented for 8bpp grey and 32bpp grey (which gets dithered for other lower modes) by just converting the luma channel into an equally weighted RGB value or replicating it for 256 greys.
Tested in all 8 colour depths on a Risc PC using sampling ratios of 1x1; 2x1; 1x2; 2x2 of the IJG test image scaled in !Draw by 0.16.

Version 1.32. Tagged as 'SprExtend-1_32'
@
text
@a345 3
#define DUMPVAL(x) tracef(#x "=0x%x " _ (int)(x));
#define DUMPVALN(x) tracef(#x "=0x%x\n" _ (int)(x));

a395 3


#define RST0    0xD0            /* RST0 marker code */
@


4.2
log
@Remove pilot JPEG code.
During the original development (referred to in the docs as Sprite Extend 2) JPEG data was briefly wrapped inside a sprite file before the JPEG_ swis were introduced. Within SpriteExtend some code still remained to fake a mode 20 sprite header with the JPEG output sized adjusted as though it was 4bpp, then later undo the faking by checking for a mode 20 sprite with is_it_jpeg set.
This version removes all of the code looking out for pilot JPEGs, and rationalises the fake sprite header to just report the true X/Y size.
Fix bug where r4 would be corrupted on exit from JPEG_PlotScaled if an error occurred, and generally rationalised the exit cases a bit more sensibly.
Made the JPEG_ swi despatch a bit more simple to follow.
Corrected a comment in the NSM_bpptable.
Deleted unused 'ecfspace' from the workspace.
Hid the 'macroword' from the C code as it's now an assembler only value.
Cut the initial comments from c/putscaled and placed in Docs.
Cut the debug tracing code (a notable %age) from c/putscaled and placed in tracing support file.
Simplified the entry to putscaled_compiler() now we don't have to look out for pilot format JPEGs within sprites any more.
Sprinkled in some block comments to make navigating the c/putscaled file a bit easier.

Version 1.30. Tagged as 'SprExtend-1_30'
@
text
@a320 5

/* The variable FILE_ is used to identify source files, smaller than __FILE__ (a bit!) for
non-debugging code. */
#define EXIT exit(FILE_+__LINE__);

d350 8
@


4.1
log
@Initial revision
@
text
@d328 6
a333 6
    #define TRACEMS(emeth,lvl,msg) {sprintf(0, msg); newline();}
    #define TRACEMS1(emeth,lvl,msg,p1) {sprintf(0, msg,p1); newline();}
    #define TRACEMS2(emeth,lvl,msg,p1,p2) {sprintf(0, msg,p1,p2); newline();}
    #define TRACEMS3(emeth,lvl,msg,p1,p2,p3) {sprintf(0, msg,p1,p2,p3); newline();}
    #define TRACEMS4(emeth,lvl,msg,p1,p2,p3,p4) {sprintf(0, msg,p1,p2,p3,p4); newline();}
    #define TRACEMS8(emeth,lvl,msg,p1,p2,p3,p4,p5,p6,p7,p8) {sprintf(0, msg,p1,p2,p3,p4,p5,p6,p7,p8); newline();}
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

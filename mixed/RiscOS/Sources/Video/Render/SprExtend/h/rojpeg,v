head	4.13;
access;
symbols
	SprExtend-1_83:4.13
	SprExtend-1_82:4.13
	SprExtend-1_81:4.13
	SprExtend-1_80:4.13
	SprExtend-1_79:4.13
	SprExtend-1_78:4.13
	SprExtend-1_77:4.13
	SprExtend-1_76:4.13
	SprExtend-1_75:4.13
	SprExtend-1_74:4.13
	SprExtend-1_73:4.13
	SprExtend-1_72:4.13
	SprExtend-1_71-nocfsi:4.12
	SprExtend-1_71:4.12
	SprExtend-1_70-tracef:4.11
	SprExtend-1_70-headers:4.11
	SprExtend-1_70:4.10
	SprExtend-1_69:4.9
	SprExtend-1_68:4.9
	SprExtend-1_67:4.9
	SprExtend-1_66:4.9
	SprExtend-1_65:4.9
	SprExtend-1_64:4.9
	SprExtend-1_63:4.9
	SprExtend-1_62:4.9
	SprExtend-1_61:4.9
	SprExtend-1_60:4.9
	SprExtend-1_59:4.9
	SprExtend-1_58:4.9
	SprExtend-1_57:4.9
	SprExtend-1_56:4.9
	SprExtend-1_55:4.9
	SprExtend-1_54:4.9
	SprExtend-1_53:4.9
	SprExtend-1_52:4.9
	SprExtend-1_51:4.9
	SprExtend-1_50:4.9
	SprExtend-1_38-1_35_2_16:4.8.2.10
	SprExtend-1_49:4.8
	SprExtend-1_48:4.8
	SprExtend-1_47:4.8
	SprExtend-1_38-1_35_2_15:4.8.2.9
	SprExtend-1_46:4.8
	SprExtend-1_45:4.8
	SprExtend-1_44:4.8
	SprExtend-1_43:4.8
	SprExtend-1_42:4.8
	SprExtend-1_41:4.8
	SprExtend-1_38-1_35_2_14:4.8.2.9
	SprExtend-1_40:4.8
	SprExtend-1_38-1_35_2_13:4.8.2.8
	SprExtend-1_38-1_35_2_12:4.8.2.7
	SprExtend-1_38-1_35_2_11:4.8.2.6
	SprExtend-1_38-1_35_2_10:4.8.2.6
	SprExtend-1_38-1_35_2_9:4.8.2.6
	SprExtend-1_38-1_35_2_8:4.8.2.5
	SprExtend-1_39:4.8
	SprExtend-1_38-1_35_2_7:4.8.2.4
	SprExtend-1_38-1_35_2_6:4.8.2.4
	SprExtend-1_38-1_35_2_5:4.8.2.3
	SprExtend-1_38-1_35_2_4:4.8.2.3
	SprExtend-1_38-1_35_2_3:4.8.2.2
	SprExtend-1_38-1_35_2_2:4.8.2.1
	SprExtend-1_38-1_35_2_1:4.8
	MigrateIJG8b:4.8.0.2
	SprExtend-1_38:4.8
	SprExtend-1_37:4.8
	SprExtend-1_36:4.8
	SprExtend-1_35:4.8
	SprExtend-1_34:4.7
	SprExtend-1_33:4.7
	SprExtend-1_32:4.7
	SprExtend-1_31:4.6
	SprExtend-1_30:4.6
	SprExtend-1_29:4.5
	SprExtend-1_28:4.5
	SprExtend-1_27:4.4
	SprExtend-1_26:4.4
	SprExtend-1_25:4.4
	SprExtend-1_24:4.4
	SprExtend-1_23:4.3
	SprExtend-1_22:4.2
	SprExtend-1_21:4.2
	SprExtend-1_20:4.2
	SprExtend-1_19:4.2
	SprExtend-1_18:4.2
	SprExtend-1_17:4.2
	RO_5_07:4.2
	SprExtend-1_16:4.2
	SprExtend-1_15:4.2
	SprExtend-1_14:4.2
	SprExtend-1_13:4.2
	SprExtend-1_12:4.2
	SprExtend-1_11:4.2
	SprExtend-1_10:4.2
	SprExtend-1_09:4.2
	SprExtend-1_08:4.2
	dellis_autobuild_BaseSW:4.2
	SprExtend-1_07:4.2
	SprExtend-1_06:4.2
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.2
	SprExtend-1_05:4.2
	Ursula_merge:4.2
	nturton_SprExtend-1_04:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.13
date	2016.05.21.14.03.51;	author rool;	state Exp;
branches;
next	4.12;
commitid	4BquZHousteH5m7z;

4.12
date	2016.05.21.13.44.42;	author rool;	state Exp;
branches;
next	4.11;
commitid	ZDqmsyNiMhv6Zl7z;

4.11
date	2016.05.21.13.32.23;	author rool;	state Exp;
branches;
next	4.10;
commitid	yTqS85yKh7k8Ul7z;

4.10
date	2016.03.12.10.25.14;	author rool;	state Exp;
branches;
next	4.9;
commitid	cdOKhcORM5Eb8lYy;

4.9
date	2012.07.28.15.23.44;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	b5jdybqzJ3Wdjlew;

4.8
date	2010.11.14.10.42.41;	author rsprowson;	state Exp;
branches
	4.8.2.1;
next	4.7;

4.7
date	2010.10.13.20.26.25;	author rsprowson;	state Exp;
branches;
next	4.6;

4.6
date	2010.09.29.21.05.33;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2010.09.25.12.19.26;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2010.09.01.20.48.56;	author rsprowson;	state Exp;
branches;
next	4.3;

4.3
date	2010.08.29.08.36.11;	author rsprowson;	state Exp;
branches;
next	4.2;

4.2
date	97.01.22.16.15.11;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.45.09;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.8.2.1
date	2011.01.04.21.28.36;	author rsprowson;	state Exp;
branches;
next	4.8.2.2;

4.8.2.2
date	2011.01.04.21.37.04;	author rsprowson;	state Exp;
branches;
next	4.8.2.3;

4.8.2.3
date	2011.01.04.21.45.34;	author rsprowson;	state Exp;
branches;
next	4.8.2.4;

4.8.2.4
date	2011.01.09.10.43.04;	author rsprowson;	state Exp;
branches;
next	4.8.2.5;

4.8.2.5
date	2011.01.13.21.12.25;	author rsprowson;	state Exp;
branches;
next	4.8.2.6;

4.8.2.6
date	2011.01.22.17.58.34;	author rsprowson;	state Exp;
branches;
next	4.8.2.7;

4.8.2.7
date	2011.01.29.10.05.59;	author rsprowson;	state Exp;
branches;
next	4.8.2.8;

4.8.2.8
date	2011.02.05.09.56.58;	author rsprowson;	state Exp;
branches;
next	4.8.2.9;

4.8.2.9
date	2011.02.15.20.58.08;	author rsprowson;	state Exp;
branches;
next	4.8.2.10;

4.8.2.10
date	2012.07.28.14.42.51;	author rsprowson;	state Exp;
branches;
next	;
commitid	Ny6vV3CHXwee5lew;

4.1.1.1
date	96.11.05.09.45.09;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.41.49;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.57.56;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.20.35;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.13
log
@Transcode arithmetics
Detail:
  Import of the raw coefficient Huffman entropy compressor elements of the IJG8d library.
  We don't need a full compressor (ala JCompMod) since there's never a need to go all the way through IDCT/upsampling/colour conversion only to reverse the whole process; it's sufficient only to collect up the raw coefficients and recompress them as a baseline JPEG.
  Two extra (temporary) dynamic areas are introduced, once to hold the raw coefficients and the other to act as a scratch file to make the JPEG in. See Doc/JPEGMmgr.
Admin:
  Submission for the JPEG bounty.

Version 1.72. Tagged as 'SprExtend-1_72'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* h.rojpeg
   Interface between core code and SpriteExtend innards.
   started: 12 Sep 93 WRS
*/

#ifndef rojpeg_h_
#define rojpeg_h_

/* Error diffused dithering */
char *asm_get_table32k(const int *palette_data);
void asm_diffuse_to_8bpp(JSAMPARRAY, int count, JSAMPARRAY, char *table32k, int nlines, int xmin, const int *palette_data);
void asm_diffuse_to_24bpp(JSAMPARRAY, int count, JSAMPARRAY, char *table32k, int nlines, int xmin, const int *palette_data);

/* YUV <-> VIDC colour tables (not really functions!) */
const int *pixel_to_yuv_table(void);
const char *yuv_to_pixel_table(void);

/* Transcoder */
void jpegtrans_make_baseline(j_decompress_ptr, const JOCTET **, size_t *);

/* Used by SpriteExtend assembler code */
typedef struct
{
  int type; /* Bits   0-2: 1=monochrome, 3=YUV or RGB, 4=CMYK or YCCK
             *        3-6: unused
             *          7: image density was a ratio
             *       8-11: SOF type
             *      12-31: unused
             */
  int width;
  int height;
  int density;
} image_dims_info;
_kernel_oserror *jpeg_find_image_dims(const char *jdata, image_dims_info *image, int *ws_size);
#define jfid_OK          (_kernel_oserror *)0
#define jfid_NOT_JPEG    (_kernel_oserror *)1
#define jfid_CANT_RENDER (_kernel_oserror *)2

/* Return a pointer to the fully decompressed scan line of 32-bit pixels at the given y coordinate.
 * This might be in the already-decompressed band buffer, or it might require decompression
 * of a band. Only pixels between xmin and xmax in the original scan-file are assured of being correct.
 * 
 * If ycoord is outside the acceptable range (0..image_height-1) the result may well
 * be trash.
 */
int *jpeg_find_line(j_decompress_ptr cinfo, int ycoord, const int *palette_data);

/* Given a file image and all necessary workspace, scan the file image,
 * build an array of band pointers into it. file_image points to image_length
 * bytes, which should be a JFIF file. Only two forms of file are accepted - a
 * greyscale single-scan file, and an interlaced YUV (YCbCr) file.
 * 
 * A non-zero error code is returned if an error occurred. Reason code in
 *   cinfo->error_code           (same as returned result)
 *   cinfo->error_argument       (any additional argument)
 * Typical reasons include an unacceptable or badly formed JPEG file.
 *
 * cinfo must point to cinfo->workspace_size bytes of available workspace. This
 * should be about 50K for typical JPEG files, if it's not big enough then
 * cinfo->error_argument is set to what it needs to be - you are welcome to
 * allocate more space and call again.
 * 
 * If the file is at the same address as the previous call, and a sample of the
 * data is the same, then jpeg_scan_file guesses that it's the same data - it's hard to
 * do a random update to the data of a JPEG file.
 * 
 * width and height say how big the resulting image should be - complain if not
 * precisely correct. If double size and band buffer is big enough, interpolate
 * upwards If width==-1 the width test is omitted. If height==-1 the height
 * test is omitted.
 * 
 * (It would be wonderful to feed in scale factors too, so that strange combinations of
 * scaling, interpolation etc. made sensible decisions. Unfortunately this requires the
 * calling code to be prepared to accept an output of an unexpected size, say by a factor
 * of 2 or 8. Not this time.)
 * 
 * Interpolate in the X direction takes twice as much store, and will only be done if
 * it will fit. On return, if it was requested, cinfo->error_argument will have
 * jopt_INTERP_X set if the interpolation is enabled. jopt_OUTBPP_8DITHER and
 * jopt_OUTBPP_8YUV and jopt_OUTBPP_16 are similar, they constitute a request which will
 * only happen if the corresponding bits of cinfo->error_argument are set on exit.
 */
int jpeg_scan_file(j_decompress_ptr cinfo, const JOCTET *file_image, size_t image_length,
                   int xmin, int xmax, int width, int height, int options);

/* JFIF file parsing options */
#define jopt_GREY 1            /* Greyscale output is requested, choice of 24bpp/8bpp in OUTBPP_8GREY flag */
#define jopt_DC_ONLY 2         /* Do only the DC values of the tiles - faster, less accurate */
#define jopt_INTERP_X 4        /* Interpolate in the X direction */
#define jopt_DIFFUSE 8         /* Dithered output is requested, choice of 24bpp/8bpp in OUTBPP_8DITHER flag */
#define jopt_OUTBPP_16 16      /* Output 16bit pixels */
#define jopt_OUTBPP_8YUV 32    /* Output 8bit pixels directly using YUV<->VIDC reverse lookup table */
#define jopt_OUTBPP_8DITHER 64 /* Dither to 8bpp when set, else 24bpp */
#define jopt_OUTBPP_8GREY 128  /* Grey pixels at 8bpp when set, else 24bpp (assumes an ascending palette) */

#endif
@


4.12
log
@Import of IJG8d library sources
Detail:
  Using the decoder in "example.c" as a starting point, we try to follow that sequence more closely even if in our embedded implementation some of the functions don't do much.
  Uses the default colour backend for 32bpp BGR output for most of the unusual cases.
  The most common 2x2 subsampling case uses a custom merged upsampler and colour converter, with colour output directly in RISC OS format for the respective screen mode.
Admin:
  Submission for the JPEG bounty.

Version 1.71. Tagged as 'SprExtend-1_71'
@
text
@d32 2
a33 3
/* Dynamic area manipulation */
void *area_create(size_t);
size_t area_resize(size_t);
d35 1
a35 5
/* Entry points used by CFSI assembler code */
int do_jpeg_scan_file_32(char *space, int space_size, const JOCTET *file_image, int image_length);
int do_jpeg_scan_file_16(char *space, int space_size, const JOCTET *file_image, int image_length);

/* Used by both CFSI and SpriteExtend assembler code */
@


4.11
log
@Update headers to stock copy
Detail:
  Added headers jerror, jmorecfg, jpegint from IJG8d. Removed jpegdata header.
  Bulk rename of structure members to match newer headers, some RISCOS-isms wrapped in #ifdef RISCOS, retained for the time being.
  Assembler code now gets cinfo member offsets from jhdr.s derived from the C header rather than keeping its own dangerous copy of the offsets.
Admin
  Note: this has broken CFSI-jpeg as it expects the error values to be at the top of cinfo.
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_70-headers.
@
text
@d24 11
a34 6
char *asm_get_table32k(int *palette_data);
void asm_diffuse_to_8bpp(int *line, int linelength, char *output, char *table32k, int nlines, int linestep, int *palette_data);
void asm_diffuse_to_24bpp(int *line, int linelength, int *output, char *table32k, int nlines, int linestep, int *palette_data);

/* Called from the assembler code if something terrible went wrong */
void panic_trace(j_decompress_ptr cinfo, int *regblock, int code);
d65 1
a65 1
int *jpeg_find_line(j_decompress_ptr cinfo, int ycoord, int *palette_data);
d78 1
a78 2
 * should be about 50K for typical JPEG files, or 20K + 4*16*max width of JPEG
 * file you wish to work with. If it's not big enough then
d97 4
a100 4
 * it will fit. On return, if it was requested, cinfo->error_argument1 will have
 * jopt_INTERP_X set if the interpolation is enabled. jopt_OUTBPP_8 and jopt_OUTBPP_16
 * are similar, they constitute a request and they only happen if the corresponding
 * bits of cinfo->error_argument1 are set on exit.
d106 1
a106 1
#define jopt_GREY 1            /* Greyscale output is acceptable, even if the file is colour */
d109 1
a109 1
#define jopt_OUTBPP_8 8        /* Output 8bit pixels (assume standard palette) */
d111 3
a113 71
#define jopt_OUTBPP_8YUV 32    /* Output 8bit pixels - different method inside (assume std palette) */
#define jopt_DIFFUSE 64        /* Error diffuse data to palette entries */
#define jopt_OUTBPP_8GREY 128  /* Output 8bit grey pixels (assume need ascending grey palette) */
#define jopt_HUFF_ONLY 0x10000 /* For timing only - just do the huffman decoding */
#define jopt_DCT_ONLY  0x20000 /* For timing only - just do huffman and DCT, not colour transform */

/* Error codes for various forms of unacceptable JPEG file */
#define E_PRE_NOT_8         1            /* Unsupported - Data precision not 8 */
#define E_MULTI_SCAN        2            /* Unsupported - Multi scan file */
#define E_COMPONENTS        3            /* Unsupported - Bad number of components, only 1 or 3 allowed */
#define E_BAD_SAMPLE        4            /* Bad sample factor */
#define E_HEIGHT_DISAGREES  5            /* Height is not as specified */
#define E_WIDTH_DISAGREES   6            /* Width is not as specified */
#define E_COLOUR            7            /* Bad colour space, not grey or YUV */
#define E_TOO_WIDE          8            /* Image too wide based on number of MCUs */

/* Get from RGB=YYY word to 4 pixels of luma */
#define YYYTOYYYY(k) ((k) | ((k)<<8)) 

/* For jdcolor */
int mono_convert_pixel(int pix);
void mono_convert_pixels(int *y);
void mono_convert_block(JBLOCK jblock, int *outptr, int outoffset);
void mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset);
void colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset,
                                  int wide, int high);
void colour_convert_pixels(int *y, int u, int v);
void colour_convert_block_8(JBLOCK jblock, char *outptr, int outoffset);
void colour_convert_block_16(JBLOCK jblock, short *outptr, int outoffset);
void colour_convert_block_32(JBLOCK jblock, int *outptr, int outoffset);

convert_block_16_func asm_get_convert_block_16_func(int ncolour,int modeflags);

#ifdef ASMIDCT
/* Optionally assembler coded IDCT stuff */
#define jpeg_idct_ifast(i,b,c)            asm_jpeg_idct_ifast(i,b,c)
void asm_jpeg_idct_ifast(j_decompress_ptr cinfo, JBLOCK block, int count);
#endif

#ifdef ASMHUFF
/* Optionally assembler coded Huffman stuff */
#define huff_decode_blocks(a,b,c,d,e,f,g) asm_huff_decode_blocks(a,b,c,d,e,f,g)
#define huff_skip_blocks(a,b,c,d,e,f,g)   asm_huff_skip_blocks(a,b,c,d,e,f,g)
void asm_huff_decode_blocks(j_decompress_ptr cinfo, JBLOCK block,
                            JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JQUANT_TBL *quanttbl,
                            JCOEF *last_dc_val, int nblocks);
void asm_huff_skip_blocks(j_decompress_ptr cinfo, JBLOCK block,
                          JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JQUANT_TBL *quanttbl,
                          JCOEF *last_dc_val, int nblocks);
#endif

#ifdef ASMCOLOR
/* Optionally assembler coded colour conversion stuff */
#define mono_convert_pixel(p)             asm_mono_convert_pixel(p)
#define mono_convert_pixels(y)            asm_mono_convert_pixels(y)
#define mono_convert_block(j,o,f)         asm_mono_convert_block(j,o,f)
#define mono_convert_block_8(j,o,f)       asm_mono_convert_block_8(j,o,f)
#define colour_convert_block_8(j,o,f)     asm_colour_convert_block_8(j,o,f)
#define colour_convert_block_32(j,o,f)    asm_colour_convert_block_32(j,o,f)
#define colour_convert_unusual_block(a,b,c,d,e) asm_colour_convert_unusual_block(a,b,c,d,e)
#define colour_convert_pixels(y,u,v)      asm_colour_convert_pixels(y,u,v)
int asm_mono_convert_pixel(int pix);
void asm_mono_convert_pixels(int *y);
void asm_mono_convert_block(JBLOCK jblock, int *outptr, int outoffset);
void asm_mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset);
void asm_colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset,
                                      int wide, int high);
void asm_colour_convert_pixels(int *y, int u, int v);
void asm_colour_convert_block_8(JBLOCK jblock, char *outptr, int outoffset);
void asm_colour_convert_block_32(JBLOCK jblock, int *outptr, int outoffset);
#endif
@


4.10
log
@Rewrite of find_image_dims
Detail:
  Now handles 0xFF padding, previously acceptable encoded images including padding were incorrectly rejected.
  Calculate the workspace for greyscale images correctly, the itype flags included the density (and latterly the SOF) flags, but the workspace calculation assumed it only contained 1 or 3 (for colour components).
  Exit cases now made common and propagate file errors correctly.
  Minor changes to the assembler that uses find_image_dims to handle 4 colour component return (now a 3 bit return value).
  Merge the other M_THING enum from IJG8d so we don't need our own copy.
  Fix signed pointer comparison.
  Use symbolic defines from Global & Interface headers where possible.
  The jdata pointer arg is now treated as const.
Admin:
  Submission for the JPEG bounty.

Version 1.70. Tagged as 'SprExtend-1_70'
@
text
@d29 1
a29 1
void panic_trace(decompress_info_ptr cinfo, int *regblock, int code);
d60 1
a60 1
int *jpeg_find_line(decompress_info_ptr cinfo, int ycoord, int *palette_data);
d98 1
a98 1
int jpeg_scan_file(decompress_info_ptr cinfo, const JOCTET *file_image, size_t image_length,
d113 10
d126 53
@


4.9
log
@Adopt colour conversions from MigrateIJG8b branch
Now for every colour conversion there is a corresponding C function, allowing swapping between them for test purposes.
Here, 'ASMCOLOR' is selected and the C functions not even referenced in the makefile, see branch for use.
Permits use of USAT, for a small 1.5% speedup and smaller code.
Some other typedefs and comment shuffling copied over - should be harmless.

Version 1.50. Tagged as 'SprExtend-1_50'
@
text
@d38 2
a39 1
  int type; /* Bits 0 & 1: 1=monochrome, 3=colour
d42 1
d48 4
a51 1
int find_image_dims(char *jdata, image_dims_info *image, int *ws_size);
@


4.8
log
@API enhancement and space saving refactoring.
Setting bit 1 of r0 in JPEG_FileInfo and JPEG_Info will now return the SOF type of the JPEG in question in bits 3-6 of the info flags in r0 on exit.
Took this opportunity to refactor find_image_dims to take a structure pointer rather than lots of individual pointers (CFSI-JPEG ammended to match). Untangled the return codes a bit so it is only necessary to inspect r0 on exit from C to determine the outcome. Values of 1 & 2 are translated in the assembler code into more specific error messages than just "Incomplete or corrupt JPEG".
Fix bug where unknown density marker would leave the file open in JPEG_FileInfo.
Don't bother ADRL'ing r1 for error messages that don't have a %0 in them.
Added all the input & output flag definitions to the exported header file so other callers can use them too.
More functionality, fewer bugs, about 200 bytes smaller too.

Version 1.35. Tagged as 'SprExtend-1_35'
@
text
@d23 5
a27 1
void assembler_panic(decompress_info_ptr cinfo, int *regblock, int code);
d29 1
d31 3
a33 7
int do_jpeg_scan_file(char *space, int space_size, char *file_image, int image_length);
int do_jpeg_scan_file_16(char *space, int space_size, char *file_image, int image_length);
/* Used by CFSI assembler code */

void mono_convert_block(JBLOCK jblock, int *outptr, int outoffset);
void colour_convert_block(JCOEF *yuv, int *outptr, int outoffset);
/* Used by SpriteExtend assembler code */
d35 1
d46 1
d48 8
a55 2
int find_image_dims(char *jdata, image_dims_info *image, int *ws_size);
/* Used by both CFSI and SpriteExtend assembler code */                           
a56 2
int jpeg_scan_file(decompress_info_ptr cinfo, char *file_image, int image_length,
                          int xmin, int xmax, int width, int height, int options);
d58 49
a106 48
build an array of band pointers into it. file_image points to image_length
bytes, which should be a JFIF file. Only two forms of file are accepted - a
greyscale single-scan file, and an interlaced YUV (YCbCr) file.

A non-zero error code is returned if an error occurred. Reason code in
  cinfo->error_code           (same as returned result)
  cinfo->error_argument       (any additional argument)
Typical reasons include an unacceptable or badly formed JPEG file.

cinfo must point to cinfo->workspace_size bytes of available workspace. This
should be about 50K for typical JPEG files, or 20K + 4*16*max width of JPEG
file you wish to work with. If it's not big enough then
cinfo->error_argument is set to what it needs to be - you are welcome to
allocate more space and call again.

If the file is at the same address as the previous call, and a sample of the
data is the same, then jpeg_scan_file guesses that it's the same data - it's hard to
do a random update to the data of a JPEG file.

width and height say how big the resulting image should be - complain if not
precisely correct. If double size and band buffer is big enough, interpolate
upwards If width==-1 the width test is omitted. If height==-1 the height
test is omitted.

(It would be wonderful to feed in scale factors too, so that strange combinations of
scaling, interpolation etc. made sensible decisions. Unfortunately this requires the
calling code to be prepared to accept an output of an unexpected size, say by a factor
of 2 or 8. Not this time.)

Valid options to pass in 'options':
*/
#define jopt_GREY 1        /* greyscale output is acceptable, even if the file is colour */
#define jopt_DC_ONLY 2     /* Do only the DC values of the tiles - faster, less accurate */
#define jopt_INTERP_X 4    /* interpolate in the X direction */
#define jopt_OUTBPP_8 8    /* output 8bit pixels (assume standard palette) */
#define jopt_OUTBPP_16 16  /* output 16bit pixels */
#define jopt_OUTBPP_8YUV 32 /* output 8bit pixels - different method inside (assume std palette) */
#define jopt_DIFFUSE 64     /* error diffuse data to palette entries */
#define jopt_OUTBPP_8GREY 128 /* output 8bit grey pixels (assume need ascending grey palette) */

/* Interpolate in the X direction takes twice as much store, and will only be done if
it will fit. On return, if it was requested, cinfo->error_argument1 will have
jopt_INTERP_X set if the interpolation is enabled. jopt_OUTBPP_8 and jopt_OUTBPP_16
are similar, they constitute a request and they only happen if the corresponding
bits of cinfo->error_argument1 are set on exit. */

#define jopt_HUFF_ONLY 0x10000 /* for timing only - just do the huffman decoding */
#define jopt_DCT_ONLY  0x20000 /* for timing only - just do huffman and DCT, not colour transform */
a110 8
int *jpeg_find_line(decompress_info_ptr cinfo, int ycoord, int *palette_data);
/* Return a pointer to the fully decompressed scan line of 32-bit pixels at the given y coordinate.
This might be in the already-decompressed band buffer, or it might require decompression
of a band. Only pixels between xmin and xmax in the original scan-file are assured of being correct.

If ycoord is outside the acceptable range (0..image_height-1) the result may well
be trash. */

@


4.8.2.1
log
@Missed the header files out of the last commit. Try again.

Version 1.38, 1.35.2.2. Tagged as 'SprExtend-1_38-1_35_2_2'
@
text
@d23 1
a23 1
void assembler_panic(j_decompress_ptr cinfo, int *regblock, int code);
d48 1
a48 1
int jpeg_scan_file(j_decompress_ptr cinfo, char *file_image, int image_length,
d103 1
a103 1
int *jpeg_find_line(j_decompress_ptr cinfo, int ycoord, int *palette_data);
a110 95
/* The buffer contains the entire file */
#define JGETC(cinfo) (int) ((cinfo)->next_input_byte >= (cinfo)->buffer_end ? 255 : *(cinfo)->next_input_byte++)

/* Macros to simplify using the error and trace message stuff */
/* The first parameter is generally cinfo->emethods, left undisturbed in
   c.jrdjfif but not used here. */
#ifdef DEBUG
  #ifdef EMBED
    #define TRACEMS(emeth,lvl,msg) {do_sprintf(0, msg); newline();}
    #define TRACEMS1(emeth,lvl,msg,p1) {do_sprintf(0, msg,p1); newline();}
    #define TRACEMS2(emeth,lvl,msg,p1,p2) {do_sprintf(0, msg,p1,p2); newline();}
    #define TRACEMS3(emeth,lvl,msg,p1,p2,p3) {do_sprintf(0, msg,p1,p2,p3); newline();}
    #define TRACEMS4(emeth,lvl,msg,p1,p2,p3,p4) {do_sprintf(0, msg,p1,p2,p3,p4); newline();}
    #define TRACEMS8(emeth,lvl,msg,p1,p2,p3,p4,p5,p6,p7,p8) {do_sprintf(0, msg,p1,p2,p3,p4,p5,p6,p7,p8); newline();}
  #else
    #define TRACEMS(emeth,lvl,msg) {if (verbose) {printf(msg); printf("\n");}}
    #define TRACEMS1(emeth,lvl,msg,p1) {if (verbose) {printf(msg,p1); printf("\n");}}
    #define TRACEMS2(emeth,lvl,msg,p1,p2) {if (verbose) {printf(msg,p1,p2); printf("\n");}}
    #define TRACEMS3(emeth,lvl,msg,p1,p2,p3) {if (verbose) {printf(msg,p1,p2,p3); printf("\n");}}
    #define TRACEMS4(emeth,lvl,msg,p1,p2,p3,p4) {if (verbose) {printf(msg,p1,p2,p3,p4); printf("\n");}}
    #define TRACEMS8(emeth,lvl,msg,p1,p2,p3,p4,p5,p6,p7,p8) {if (verbose) {printf(msg,p1,p2,p3,p4,p5,p6,p7,p8); printf("\n");}}
  #endif
#else
  #define TRACEMS(emeth,lvl,msg)
  #define TRACEMS1(emeth,lvl,msg,p1)
  #define TRACEMS2(emeth,lvl,msg,p1,p2)
  #define TRACEMS3(emeth,lvl,msg,p1,p2,p3)
  #define TRACEMS4(emeth,lvl,msg,p1,p2,p3,p4)
  #define TRACEMS8(emeth,lvl,msg,p1,p2,p3,p4,p5,p6,p7,p8)
#endif

#ifdef EMBED
  #ifdef DEBUG
    /* The variable FILE_ is used to identify source files, smaller
     * than __FILE__ (a bit!) for non-debugging code.
     */
    #define EXIT exit_erl(ERROR_BAD_JPEG,FILE_+__LINE__);
  #else
    #define EXIT exit(ERROR_BAD_JPEG);
  #endif
  #define ERREXIT(emeth,msg) {tracef("Error:"); tracef(msg); newline(); EXIT}
  #define ERREXIT1(emeth,msg,p1) {tracef("Error:"); tracef(msg _ p1); newline(); EXIT}
  #define ERREXIT2(emeth,msg,p1,p2) {tracef("Error:"); tracef(msg _ p1 _ p2); newline(); EXIT}
  #define ERREXIT3(emeth,msg,p1,p2,p3) {tracef("Error:"); tracef(msg _ p1 _ p2 _ p3); newline(); EXIT}
  #define ERREXIT4(emeth,msg,p1,p2,p3,p4) {tracef("Error:"); tracef(msg _ p1 _ p2 _ p3 _ p4); newline(); EXIT}
#else
  #define ERREXIT(emeth,msg) {printf("Error:"); printf(msg); printf("\n"); exit(1);}
  #define ERREXIT1(emeth,msg,p1) {printf("Error:"); printf(msg,p1); printf("\n"); exit(1);}
  #define ERREXIT2(emeth,msg,p1,p2) {printf("Error:"); printf(msg,p1,p2); printf("\n"); exit(1);}
  #define ERREXIT3(emeth,msg,p1,p2,p3) {printf("Error:"); printf(msg,p1,p2,p3); printf("\n"); exit(1);}
  #define ERREXIT4(emeth,msg,p1,p2,p3,p4) {printf("Error:"); printf(msg,p1,p2,p3,p4); printf("\n"); exit(1);}
#endif

/* Porting macros */
#define MEMZERO(target,size)	memset((void *)(target), 0, (size_t)(size))
#define MEMCOPY(dest,src,size)	memcpy((void *)(dest), (const void *)(src), (size_t)(size))
#define SIZEOF(object)	((size_t) sizeof(object))

#define E_PRE_NOT_8         1            /* Unsupported - Data precision not 8 */
#define E_MULTI_SCAN        2            /* Unsupported - Multi scan file */
#define E_COMPONENTS        3            /* Unsupported - Bad number of components, only 1 or 3 allowed */
#define E_BAD_SAMPLE        4            /* Bad sample factor */
#define E_HEIGHT_DISAGREES  5            /* Height is not as specified */
#define E_WIDTH_DISAGREES   6            /* Width is not as specified */
#define E_COLOUR            7            /* Bad colour space, not grey or YUV */
#define E_TOO_WIDE          8            /* Image too wide based on number of MCUs */

/* Assembler coded stuff */
#ifdef ASMHUFF
extern void
asm_huff_decode_blocks(j_decompress_ptr cinfo, JBLOCK block,
                   JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JQUANT_TBL *quanttbl,
                   JCOEF *last_dc_val, int nblocks);

extern void
asm_huff_skip_blocks(j_decompress_ptr cinfo, JBLOCK block,
                 JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JQUANT_TBL *quanttbl,
                 JCOEF *last_dc_val, int nblocks);
#endif

#ifdef STATS
#define asm_j_rev_dct(i,b,c) j_rev_dct(i,b,c) /* Substitute 'Sources.jrevdct' for 'c.jrevdct4' */
#else
extern void asm_j_rev_dct(j_decompress_ptr cinfo, JBLOCK block, int count);
#endif
extern void asm_mono_convert_block(JBLOCK jblock, int *outptr, int outoffset);
extern void asm_mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset);
extern void asm_colour_convert_block(JBLOCK jblock, int *outptr, int outoffset);
extern void asm_colour_convert_block_16(JBLOCK jblock, short int *outptr, int outoffset);
extern void asm_colour_convert_block_8(JBLOCK jblock, char *outptr, int outoffset);
extern void asm_diffuse_to_8bpp(int *line, int linelength, char *output, char *table32k, int nlines, int linestep, int *palette_data);
extern char *asm_get_table32k(int *palette_data);
extern void asm_convert_to_8bpp_grey(int *line, int linelength, char *output, int nlines, int linestep);
extern void asm_diffuse_to_24bpp(int *line, int linelength, int *output, char *table32k, int nlines, int linestep, int *palette_data);

@


4.8.2.2
log
@Reinstate C code version of jdhuff.
In huff_decode_blocks the block pointer wasn't being incremented, as it was in the assembler.
Useful for speed comparisons.

Version 1.38, 1.35.2.3. Tagged as 'SprExtend-1_38-1_35_2_3'
@
text
@a179 2
#define huff_decode_blocks(a,b,c,d,e,f,g) asm_huff_decode_blocks(a,b,c,d,e,f,g)
#define huff_skip_blocks(a,b,c,d,e,f,g)   asm_huff_skip_blocks(a,b,c,d,e,f,g)
@


4.8.2.3
log
@Reinstate jrevdct4 option to use C code IDCT (switch "ASMIDCT").
Name inverse DCT to match IJG 8b integer fast implementation.
Remove -DEMBED option and collapse switches.
Useful for speed comparisons.

Version 1.38, 1.35.2.4. Tagged as 'SprExtend-1_38-1_35_2_4'
@
text
@d80 12
a91 1
Interpolate in the X direction takes twice as much store, and will only be done if
d95 1
a95 14
bits of cinfo->error_argument1 are set on exit.

Valid options to pass in 'options':
*/
#define jopt_GREY 1            /* Greyscale output is acceptable, even if the file is colour */
#define jopt_DC_ONLY 2         /* Do only the DC values of the tiles - faster, less accurate */
#define jopt_INTERP_X 4        /* Interpolate in the X direction */
#define jopt_OUTBPP_8 8        /* Output 8bit pixels (assume standard palette) */
#define jopt_OUTBPP_16 16      /* Output 16bit pixels */
#define jopt_OUTBPP_8YUV 32    /* Output 8bit pixels - different method inside (assume std palette) */
#define jopt_DIFFUSE 64        /* Error diffuse data to palette entries */
#define jopt_OUTBPP_8GREY 128  /* Output 8bit grey pixels (assume need ascending grey palette) */
#define jopt_HUFF_ONLY 0x10000 /* For timing only - just do the huffman decoding */
#define jopt_DCT_ONLY  0x20000 /* For timing only - just do huffman and DCT, not colour transform */
d97 2
a98 9
/* JFIF file parsing error returns */
#define E_PRE_NOT_8         1            /* Unsupported - Data precision not 8 */
#define E_MULTI_SCAN        2            /* Unsupported - Multi scan file */
#define E_COMPONENTS        3            /* Unsupported - Bad number of components, only 1 or 3 allowed */
#define E_BAD_SAMPLE        4            /* Bad sample factor */
#define E_HEIGHT_DISAGREES  5            /* Height is not as specified */
#define E_WIDTH_DISAGREES   6            /* Width is not as specified */
#define E_COLOUR            7            /* Bad colour space, not grey or YUV */
#define E_TOO_WIDE          8            /* Image too wide based on number of MCUs */
d118 15
a132 6
  #define TRACEMS(emeth,lvl,msg) {do_sprintf(0, msg); newline();}
  #define TRACEMS1(emeth,lvl,msg,p1) {do_sprintf(0, msg,p1); newline();}
  #define TRACEMS2(emeth,lvl,msg,p1,p2) {do_sprintf(0, msg,p1,p2); newline();}
  #define TRACEMS3(emeth,lvl,msg,p1,p2,p3) {do_sprintf(0, msg,p1,p2,p3); newline();}
  #define TRACEMS4(emeth,lvl,msg,p1,p2,p3,p4) {do_sprintf(0, msg,p1,p2,p3,p4); newline();}
  #define TRACEMS8(emeth,lvl,msg,p1,p2,p3,p4,p5,p6,p7,p8) {do_sprintf(0, msg,p1,p2,p3,p4,p5,p6,p7,p8); newline();}
d142 14
a155 5
#ifdef DEBUG
  /* The variable FILE_ is used to identify source files, smaller
   * than __FILE__ (a bit!) for non-debugging code.
   */
  #define EXIT exit_erl(ERROR_BAD_JPEG,FILE_+__LINE__);
d157 5
a161 1
  #define EXIT exit(ERROR_BAD_JPEG);
a162 5
#define ERREXIT(emeth,msg) {tracef("Error:"); tracef(msg); newline(); EXIT}
#define ERREXIT1(emeth,msg,p1) {tracef("Error:"); tracef(msg _ p1); newline(); EXIT}
#define ERREXIT2(emeth,msg,p1,p2) {tracef("Error:"); tracef(msg _ p1 _ p2); newline(); EXIT}
#define ERREXIT3(emeth,msg,p1,p2,p3) {tracef("Error:"); tracef(msg _ p1 _ p2 _ p3); newline(); EXIT}
#define ERREXIT4(emeth,msg,p1,p2,p3,p4) {tracef("Error:"); tracef(msg _ p1 _ p2 _ p3 _ p4); newline(); EXIT}
d169 8
a176 5
/* Optionally assembler coded stuff */
#ifdef ASMIDCT
#define j_rev_dct(i,b,c)                  asm_j_rev_dct(i,b,c)
extern void asm_j_rev_dct(j_decompress_ptr cinfo, JBLOCK block, int count);
#endif
d178 1
d182 2
a183 1
extern void asm_huff_decode_blocks(j_decompress_ptr cinfo, JBLOCK block,
d186 3
a188 1
extern void asm_huff_skip_blocks(j_decompress_ptr cinfo, JBLOCK block,
d193 5
a197 1
/* Colour conversions */
d201 1
a202 1
extern void asm_colour_convert_block_16(JBLOCK jblock, short int *outptr, int outoffset);
@


4.8.2.4
log
@Create assembler equivalents of C colour conversions, approx 10% speed up.
Add new switch ASMCOLOR to select which to use, C or assembler.
Remove FILE_ exit trace concept, just use __FILE__ instead in exit_erl.
Add some comments to exit_erl and friends.
A few bits of cinfo setup moved into start_pass_huff_decoder() or eliminated.
Bumped up the precision of SCALE_BITS in the C colour handling so FIX() uses more bits of an int.
Deleted the unused remenants of light dithering in the 8bpp colour converter - saves a few cycles.
colour_convert_8 and colour_convert_16 no longer save entry registers the C compiler doesn't care about.
Update genyuvtabs to EXPORT the table bases.
Split out the compilation of IJG files as separate objects in the make file, rather than including them from within rojpeg, which is itself included from putscaled.

Version 1.38, 1.35.2.6. Tagged as 'SprExtend-1_38-1_35_2_6'
@
text
@d23 1
a23 5
/* Error diffused dithering */
char *asm_get_table32k(int *palette_data);
void asm_diffuse_to_8bpp(int *line, int linelength, char *output, char *table32k, int nlines, int linestep, int *palette_data);
void asm_diffuse_to_24bpp(int *line, int linelength, int *output, char *table32k, int nlines, int linestep, int *palette_data);

a24 1
void panic_trace(j_decompress_ptr cinfo, int *regblock, int code);
a25 1
/* Entry points used by CFSI assembler code */
d28 5
a33 1
/* Used by both CFSI and SpriteExtend assembler code */                           
d44 1
d46 1
a47 45
/* Return a pointer to the fully decompressed scan line of 32-bit pixels at the given y coordinate.
 * This might be in the already-decompressed band buffer, or it might require decompression
 * of a band. Only pixels between xmin and xmax in the original scan-file are assured of being correct.
 * 
 * If ycoord is outside the acceptable range (0..image_height-1) the result may well
 * be trash.
 */
int *jpeg_find_line(j_decompress_ptr cinfo, int ycoord, int *palette_data);

/* Given a file image and all necessary workspace, scan the file image,
 * build an array of band pointers into it. file_image points to image_length
 * bytes, which should be a JFIF file. Only two forms of file are accepted - a
 * greyscale single-scan file, and an interlaced YUV (YCbCr) file.
 * 
 * A non-zero error code is returned if an error occurred. Reason code in
 *   cinfo->error_code           (same as returned result)
 *   cinfo->error_argument       (any additional argument)
 * Typical reasons include an unacceptable or badly formed JPEG file.
 *
 * cinfo must point to cinfo->workspace_size bytes of available workspace. This
 * should be about 50K for typical JPEG files, or 20K + 4*16*max width of JPEG
 * file you wish to work with. If it's not big enough then
 * cinfo->error_argument is set to what it needs to be - you are welcome to
 * allocate more space and call again.
 * 
 * If the file is at the same address as the previous call, and a sample of the
 * data is the same, then jpeg_scan_file guesses that it's the same data - it's hard to
 * do a random update to the data of a JPEG file.
 * 
 * width and height say how big the resulting image should be - complain if not
 * precisely correct. If double size and band buffer is big enough, interpolate
 * upwards If width==-1 the width test is omitted. If height==-1 the height
 * test is omitted.
 * 
 * (It would be wonderful to feed in scale factors too, so that strange combinations of
 * scaling, interpolation etc. made sensible decisions. Unfortunately this requires the
 * calling code to be prepared to accept an output of an unexpected size, say by a factor
 * of 2 or 8. Not this time.)
 * 
 * Interpolate in the X direction takes twice as much store, and will only be done if
 * it will fit. On return, if it was requested, cinfo->error_argument1 will have
 * jopt_INTERP_X set if the interpolation is enabled. jopt_OUTBPP_8 and jopt_OUTBPP_16
 * are similar, they constitute a request and they only happen if the corresponding
 * bits of cinfo->error_argument1 are set on exit.
 */
d50 35
d86 2
a87 1
/* JFIF file parsing options */
d112 48
a159 3
/* temp */
extern void asm_colour_convert_block_8(JBLOCK jblock, char *outptr, int outoffset);
extern void asm_colour_convert_block_16(JBLOCK jblock, short *outptr, int outoffset);
d161 1
a162 1
/* Optionally assembler coded IDCT stuff */
a167 1
/* Optionally assembler coded Huffman stuff */
d171 2
a172 2
                                   JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JQUANT_TBL *quanttbl,
                                   JCOEF *last_dc_val, int nblocks);
d174 2
a175 2
                                 JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JQUANT_TBL *quanttbl,
                                 JCOEF *last_dc_val, int nblocks);
d178 1
a178 16
#ifdef ASMCOLOR
/* Optionally assembler coded colour conversion stuff */
#define mono_convert_pixel(p)             asm_mono_convert_pixel(p)
#define mono_convert_pixels(y)            asm_mono_convert_pixels(y)
#define mono_convert_block(j,o,f)         asm_mono_convert_block(j,o,f)
#define mono_convert_block_8(j,o,f)       asm_mono_convert_block_8(j,o,f)
#define colour_convert_block(j,o,f)       asm_colour_convert_block(j,o,f)     
#define colour_convert_block_8(j,o,f)     asm_colour_convert_block_8(j,o,f)
#define colour_convert_block_16(j,o,f)    asm_colour_convert_block_16(j,o,f)  
#define colour_convert_unusual_block(a,b,c,d,e) asm_colour_convert_unusual_block(a,b,c,d,e)
#define colour_convert_pixels(y,u,v)      asm_colour_convert_pixels(y,u,v)
extern int asm_mono_convert_pixel(int pix);
extern void asm_mono_convert_pixels(int *y);
extern void asm_colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset,
                                             int wide, int high);
extern void asm_colour_convert_pixels(int *y, int u, int v);
d183 5
a187 2
extern void asm_colour_convert_block_16(JBLOCK jblock, short *outptr, int outoffset);
#endif
@


4.8.2.5
log
@Use USAT in 150 occurrences of colour clamping for ARMv6 and later.
Some IDCT renaming.
Shock addition of some documentation on how it all works.
Mirror fix from 1.39 on the trunk.
Debug
 Made DEBUG version compile again, earlier header shuffling was preventing it.
 Replaced the ' _ ' method of variadic macro emulation with more familiar double brackets for tracef().
 Eliminated IFDEBUG macro and just used #ifdef DEBUG/#endif or tracef() directly.
 Don't bother passing the line number and file name to exit() when in the non DEBUG case.

Version 1.38, 1.35.2.8. Tagged as 'SprExtend-1_38-1_35_2_8'
@
text
@d127 2
a128 2
#define jpeg_idct_ifast(i,b,c)            asm_jpeg_idct_ifast(i,b,c)
extern void asm_jpeg_idct_ifast(j_decompress_ptr cinfo, JBLOCK block, int count);
@


4.8.2.6
log
@New jerror.h taken from IJG8b.
Swap to using JERR_ numbers, deleted E_ numbers.
Modify genjhdr to pass some defines to the assembler code, so jdcolor can clarify use of DCTSIZE and DCTSIZE2.
Added chart of possible subsampling ratios to documentation.

Version 1.38, 1.35.2.9. Tagged as 'SprExtend-1_38-1_35_2_9'
@
text
@d108 10
d121 4
d149 1
a151 1
#define colour_convert_block_32(j,o,f)    asm_colour_convert_block_32(j,o,f)
a155 2
extern void asm_mono_convert_block(JBLOCK jblock, int *outptr, int outoffset);
extern void asm_mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset);
d159 3
a163 1
extern void asm_colour_convert_block_32(JBLOCK jblock, int *outptr, int outoffset);
@


4.8.2.7
log
@Migrate to jdmarker from IJG 8b.
ERREXIT's in jdhuff now use JERR_ numbers (missed earlier because it's switched out by default).

Version 1.38, 1.35.2.12. Tagged as 'SprExtend-1_38-1_35_2_12'
@
text
@d114 1
a114 1
void asm_jpeg_idct_ifast(j_decompress_ptr cinfo, JBLOCK block, int count);
d121 6
a126 6
void asm_huff_decode_blocks(j_decompress_ptr cinfo, JBLOCK block,
                            JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JQUANT_TBL *quanttbl,
                            JCOEF *last_dc_val, int nblocks);
void asm_huff_skip_blocks(j_decompress_ptr cinfo, JBLOCK block,
                          JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JQUANT_TBL *quanttbl,
                          JCOEF *last_dc_val, int nblocks);
d140 10
a149 10
int asm_mono_convert_pixel(int pix);
void asm_mono_convert_pixels(int *y);
void asm_mono_convert_block(JBLOCK jblock, int *outptr, int outoffset);
void asm_mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset);
void asm_colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset,
                                      int wide, int high);
void asm_colour_convert_pixels(int *y, int u, int v);
void asm_colour_convert_block_8(JBLOCK jblock, char *outptr, int outoffset);
void asm_colour_convert_block_16(JBLOCK jblock, short *outptr, int outoffset);
void asm_colour_convert_block_32(JBLOCK jblock, int *outptr, int outoffset);
@


4.8.2.8
log
@Reorganise data input.
Fill in INPUT_VARS and INPUT_SYNC so it uses register variables.
Make use of data source manager (cinfo->src).
Calculate bytes_in_buffer when restoring the huffman position.
Swap process_restart() for the one now in jdmarker.

Version 1.38, 1.35.2.13. Tagged as 'SprExtend-1_38-1_35_2_13'
@
text
@d93 2
a94 2
int jpeg_scan_file(j_decompress_ptr cinfo, const JOCTET *file_image, size_t image_length,
                   int xmin, int xmax, int width, int height, int options);
@


4.8.2.9
log
@Abstract entropy decoding.
Currently still only support Huffman, but now agnostic, there are two functions 'decode_mcu()' which does the full DC+AC decode of a full MCU worth of data, and 'skip_mcu()' which just does DC and consumes but discards the AC coefficients.
Apply fix from 1.40 trunk version for monochrome output in a 8bpp greyscale mode.
Restore name of DCTFIX() macro to FIX(), no longer needed now the constituent parts are compiled seperately rather than #included.
Fix CFSIjpeg to assemble even though it doesn't have a module base (the recently added 'relocatefn()' was breaking it).

Version 1.38, 1.35.2.14. Tagged as 'SprExtend-1_38-1_35_2_14'
@
text
@d32 2
a33 2
int do_jpeg_scan_file_32(char *space, int space_size, const JOCTET *file_image, int image_length);
int do_jpeg_scan_file_16(char *space, int space_size, const JOCTET *file_image, int image_length);
d111 41
@


4.8.2.10
log
@Sync with trunk
Sources/SprOp - revision 4.10 copied
Sources/SprTrans - revision 4.16 copied
Sources/jdhuff - revision 4.7 copied
Also:
 DCI changed to instruction mnemonic for objasm 4
 Makefile excess '-c' removed
 Util.mk double inclusion of rules removed

Version 1.38, 1.35.2.16. Tagged as 'SprExtend-1_38-1_35_2_16'
@
text
@d35 1
a35 1
/* Used by both CFSI and SpriteExtend assembler code */
@


4.7
log
@Paper and fill some JPEG cracks.
The exit_c function was repeatedly being called with the line number argument and error code the wrong way round and since only bits 0-2 of the error code are inspected on exit any fatal exits from the ported JPEG library code would either report the wrong error or fail silently (depending on the line number) - example a 12 bits per sample JPEG would be rendered without fault into a screen full of random memory garbage.
Assembling/compiling with the 'jpeg' switch off didn't work, fixed, and also now zeros out the SWI decode values in the module header.
Moved include of 'yuvtabs.s' into the colour conversion code.
Deleted panic_exit, it did nothing useful but trace a value then exit, so it now just calls exit() like everyone else.
Removed excess call to find_image_dims(), this was needed just to get the workspace requirements when the JPEG had already been sized up by asm_find_image_dims() earlier. Side effect of removing the pilot JPEG code earlier is that this call can now only get to the JPEG code from a JPEG_ SWI. Changed to just pass the workspace requirements into 'c.PutScaled' and save a duplicate scan.
Fatal exits from the assembler huffman decoder now report a sensible error.
Trimmed out all the JPEG assessment code from 'c.PutScaled' and moved it into 'c.rojpeg' so the put scaled is only concerned with putting things scaled.
Sanitised the #includes a bit.
Fixed on last check of wp->save_mode looking at the wrong bits for the mode number.
Resolved all the warning in the genhdr/genyuvtabs/genpalette utilities by casting a bit harder.[A[B
Added new more descriptive error messages to the messages file (not currently used), and made the 'not supported by' ones consistent so the tokeniser might crunch the file a bit more.
In looks_like_jpeg() changed a bitwise to logical or.
Fixed longstanding problem of not being able to render JPEGs at a scale of less than 1/6 in any greyscale mode, because, err, there was no code to do it - only the colour case was checked for. Implemented for 8bpp grey and 32bpp grey (which gets dithered for other lower modes) by just converting the luma channel into an equally weighted RGB value or replicating it for 256 greys.
Tested in all 8 colour depths on a Risc PC using sampling ratios of 1x1; 2x1; 1x2; 2x2 of the IJG test image scaled in !Draw by 0.16.

Version 1.32. Tagged as 'SprExtend-1_32'
@
text
@d34 12
a45 6
int find_image_dims(char *jdata, int *image_width, int *image_height,
                           int *image_type,
#ifndef CFSI
                           int *image_density,
#endif
                           int *ws_size, int *err);
@


4.6
log
@Remove pilot JPEG code.
During the original development (referred to in the docs as Sprite Extend 2) JPEG data was briefly wrapped inside a sprite file before the JPEG_ swis were introduced. Within SpriteExtend some code still remained to fake a mode 20 sprite header with the JPEG output sized adjusted as though it was 4bpp, then later undo the faking by checking for a mode 20 sprite with is_it_jpeg set.
This version removes all of the code looking out for pilot JPEGs, and rationalises the fake sprite header to just report the true X/Y size.
Fix bug where r4 would be corrupted on exit from JPEG_PlotScaled if an error occurred, and generally rationalised the exit cases a bit more sensibly.
Made the JPEG_ swi despatch a bit more simple to follow.
Corrected a comment in the NSM_bpptable.
Deleted unused 'ecfspace' from the workspace.
Hid the 'macroword' from the C code as it's now an assembler only value.
Cut the initial comments from c/putscaled and placed in Docs.
Cut the debug tracing code (a notable %age) from c/putscaled and placed in tracing support file.
Simplified the entry to putscaled_compiler() now we don't have to look out for pilot format JPEGs within sprites any more.
Sprinkled in some block comments to make navigating the c/putscaled file a bit easier.

Version 1.30. Tagged as 'SprExtend-1_30'
@
text
@a22 5
#include "jinclude.h"

#define UNUSED(k) (k)=(k)
/* When compiler warnings get in the way of quality */

d94 3
a104 5
/* errors for C to return to assembler */
#define ERROR_NO_MEMORY   1
#define ERROR_BAD_JPEG    2
#define ERROR_FATAL       4

@


4.5
log
@Remove postprocessing step of C code.
Since 2001 this module has been using objasm, but still using the C compiler to output (via -S) assembly code which is then passed through 'sed' and included via GET into the assembler code.
Changed to compile the C code into object files, and use the linker to patch up the unresolved references - this has required some reordering of the C code to make sure static functions now appear in the object file, and some reordering of the header files to ensure both the module and the CFSI version still compile without conflicts.
Minor fix to 'swiv2', the label was in the wrong place for _swi() though it's not used in this module so didn't affect the _swix() case.
Makefile cut down a bit. Unixify some path names.
Test code moved to 'Test/c' directory.
Tested in both debug and non debug cases via softloaded module. Oddly, it's 4 bytes longer than the previous version.

Version 1.28. Tagged as 'SprExtend-1_28'
@
text
@a30 3
extern int create_dynamic_area(int size);
/* Creates a dynamic area (done in assembler since the C code has no visibility of the message file) */

@


4.4
log
@Clean up pass.
Trim 200+ lines of changes dating back to 1987, combine with non duplicates in the 'BlackLog'.
Use 'offsetof' macro in genjhdr to avoid warnings about uninitialised variables, rename from makejhdr so all the utils are clearly demarked.
Add throwback to MkCFSI-j.
Replace reason codes passed to SWIs with textual equivalents from the respective header files.
Speed up SWI despatch a bit by making the first few debug instructions depend on 'debuggs'.
Qualify all of the debug switches with the global 'debug' one.
Eliminate single use of 'pullx' macro.
Make do_branch() take an unsigned opcode so 50% of the branches don't result in implied cast warnings.
Added an UNUSED() macro to reduce a few of the legitimate warnings (the remainder are either in the original JPEG code or ones that it is worth checking the logic of.
Unixify one last filename.

Version 1.24. Tagged as 'SprExtend-1_24'
@
text
@d34 17
a50 1
static int jpeg_scan_file(decompress_info_ptr cinfo, char *file_image, int image_length,
d102 1
a102 1
static int *jpeg_find_line(decompress_info_ptr cinfo, int ycoord, int *palette_data);
@


4.3
log
@A few small fixes.
Sources/PutScaled:
 Sync comment with C code.
Sources/SprExtend:
 Debug switch 'debuggs' had been left on, which left in some unnecessary code, but turning it off pulled in code with a stack imbalance. Now off.
 Ensured a terminator at the end of the RMEnsure.
 Colour translation tables passed to SetPointerShape that were in top bit set addresses were being interpreted as though no tt was supplied. Now tested against zero to match docs.
Sources/SprTrans:
 Switches pre 0.60 collapsed.
Sources/diffuse:
 The C code was corrupting r12 workspace pointer so the check of the flag 'ctrans_recent' sometimes failed leading to a duff table lookup.
 Small optimisation to checking of guard word.
c/PutScaled:
 Change paths to be Unix friendly.
rojpeg:
 Put assembler_panic in the header file to shut the compiler up.
3x unused files deleted.

Version 1.23. Tagged as 'SprExtend-1_23'
@
text
@d25 3
d31 3
@


4.2
log
@Version RO_3_70 taken
@
text
@d25 3
@


4.1
log
@Initial revision
@
text
@d65 2
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a64 2
#define jopt_DIFFUSE 64     /* error diffuse data to palette entries */
#define jopt_OUTBPP_8GREY 128 /* output 8bit grey pixels (assume need ascending grey palette) */
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

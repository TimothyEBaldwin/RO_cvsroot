head	4.23;
access;
symbols
	SprExtend-1_83:4.23
	SprExtend-1_82:4.23
	SprExtend-1_81:4.23
	SprExtend-1_80:4.23
	SprExtend-1_79:4.23
	SprExtend-1_78:4.23
	SprExtend-1_77:4.23
	SprExtend-1_76:4.23
	SprExtend-1_75:4.23
	SprExtend-1_74:4.23
	SprExtend-1_73:4.23
	SprExtend-1_72:4.23
	SprExtend-1_71-nocfsi:4.23
	SprExtend-1_71:4.23
	SprExtend-1_70-tracef:4.22
	SprExtend-1_70-headers:4.21
	SprExtend-1_70:4.20
	SprExtend-1_69:4.20
	SprExtend-1_68:4.20
	SprExtend-1_67:4.20
	SprExtend-1_66:4.20
	SprExtend-1_65:4.20
	SprExtend-1_64:4.20
	SprExtend-1_63:4.20
	SprExtend-1_62:4.19
	SprExtend-1_61:4.19
	SprExtend-1_60:4.17
	SprExtend-1_59:4.16
	SprExtend-1_58:4.15
	SprExtend-1_57:4.15
	SprExtend-1_56:4.15
	SprExtend-1_55:4.15
	SprExtend-1_54:4.14
	SprExtend-1_53:4.14
	SprExtend-1_52:4.14
	SprExtend-1_51:4.13
	SprExtend-1_50:4.13
	SprExtend-1_49:4.12
	SprExtend-1_48:4.12
	SprExtend-1_47:4.12
	SprExtend-1_46:4.12
	SprExtend-1_45:4.12
	SprExtend-1_44:4.12
	SprExtend-1_43:4.12
	SprExtend-1_42:4.12
	SprExtend-1_41:4.12
	SprExtend-1_40:4.12
	SprExtend-1_39:4.12
	MigrateIJG8b:4.12.0.2
	SprExtend-1_38:4.12
	SprExtend-1_37:4.12
	SprExtend-1_36:4.12
	SprExtend-1_35:4.12
	SprExtend-1_34:4.12
	SprExtend-1_33:4.12
	SprExtend-1_32:4.12
	SprExtend-1_31:4.11
	SprExtend-1_30:4.11
	SprExtend-1_29:4.10
	SprExtend-1_28:4.10
	SprExtend-1_27:4.9
	SprExtend-1_26:4.9
	SprExtend-1_25:4.9
	SprExtend-1_24:4.9
	SprExtend-1_23:4.8
	SprExtend-1_22:4.7
	SprExtend-1_21:4.6
	SprExtend-1_20:4.6
	SprExtend-1_19:4.6
	SprExtend-1_18:4.5
	SprExtend-1_17:4.5
	RO_5_07:4.5
	SprExtend-1_16:4.5
	SprExtend-1_15:4.5
	SprExtend-1_14:4.4
	SprExtend-1_13:4.4
	SprExtend-1_12:4.4
	SprExtend-1_11:4.4
	SprExtend-1_10:4.3
	SprExtend-1_09:4.3
	SprExtend-1_08:4.3
	dellis_autobuild_BaseSW:4.3
	SprExtend-1_07:4.3
	SprExtend-1_06:4.3
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.3
	SprExtend-1_05:4.2
	Ursula_merge:4.2
	nturton_SprExtend-1_04:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.23
date	2016.05.21.13.44.37;	author rool;	state Exp;
branches;
next	4.22;
commitid	ZDqmsyNiMhv6Zl7z;

4.22
date	2016.05.21.13.37.18;	author rool;	state Exp;
branches;
next	4.21;
commitid	TvdqzFBJfCe7Wl7z;

4.21
date	2016.05.21.13.32.20;	author rool;	state Exp;
branches;
next	4.20;
commitid	yTqS85yKh7k8Ul7z;

4.20
date	2014.03.28.00.02.17;	author jlee;	state Exp;
branches;
next	4.19;
commitid	XiGrdO28VnttFoux;

4.19
date	2014.03.04.20.45.06;	author jlee;	state Exp;
branches;
next	4.18;
commitid	6KWofF44yd1Fjqrx;

4.18
date	2013.11.05.09.33.44;	author rsprowson;	state Exp;
branches;
next	4.17;
commitid	KbMa4mXss9gsq4cx;

4.17
date	2013.10.25.20.31.34;	author jlee;	state Exp;
branches;
next	4.16;
commitid	cSPorALl6Vf2qIax;

4.16
date	2013.10.14.22.11.34;	author jlee;	state Exp;
branches;
next	4.15;
commitid	3gyTBoWfzDEkkj9x;

4.15
date	2013.10.07.00.39.09;	author jlee;	state Exp;
branches;
next	4.14;
commitid	HcUKy3PafwqToi8x;

4.14
date	2013.08.06.23.16.22;	author jlee;	state Exp;
branches;
next	4.13;
commitid	z9XOph7zDZQ2Ur0x;

4.13
date	2012.07.28.15.23.41;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	b5jdybqzJ3Wdjlew;

4.12
date	2010.10.13.20.26.21;	author rsprowson;	state Exp;
branches
	4.12.2.1;
next	4.11;

4.11
date	2010.09.29.21.05.30;	author rsprowson;	state Exp;
branches;
next	4.10;

4.10
date	2010.09.25.12.19.23;	author rsprowson;	state Exp;
branches;
next	4.9;

4.9
date	2010.09.01.20.48.54;	author rsprowson;	state Exp;
branches;
next	4.8;

4.8
date	2010.08.29.08.36.09;	author rsprowson;	state Exp;
branches;
next	4.7;

4.7
date	2010.08.26.07.46.52;	author rsprowson;	state Exp;
branches;
next	4.6;

4.6
date	2009.04.24.00.48.35;	author srevill;	state Exp;
branches;
next	4.5;

4.5
date	2003.04.08.21.19.09;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2002.11.06.13.20.30;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.12.12.59.08;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.17.51.07;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.45.04;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.12.2.1
date	2011.01.04.21.18.07;	author rsprowson;	state dead;
branches;
next	;

4.1.1.1
date	96.11.05.09.45.04;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.41.04;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.57.36;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.20.15;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.23
log
@Import of IJG8d library sources
Detail:
  Using the decoder in "example.c" as a starting point, we try to follow that sequence more closely even if in our embedded implementation some of the functions don't do much.
  Uses the default colour backend for 32bpp BGR output for most of the unusual cases.
  The most common 2x2 subsampling case uses a custom merged upsampler and colour converter, with colour output directly in RISC OS format for the respective screen mode.
Admin:
  Submission for the JPEG bounty.

Version 1.71. Tagged as 'SprExtend-1_71'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* c.PutScaled - the bitblit compiler for PutSpriteScaled/PlotMaskScaled */

/**************************************************************************
*                                                                         *
*    Bitblit: Evaluate conditions.                                        *
*                                                                         *
**************************************************************************/

static BOOL simple_x_scale(asm_workspace *wp, workspace *ws)
/* Return true if 1:1 along x */
{
  return (  wp->save_xadd - wp->save_xdiv == wp->save_xdiv
         && wp->save_xdiv <= wp->save_xcount
         && !PLOTMASK
         && ws->gcol == 0
         && !ws->odither /* CAN be done, but the code sequences get awfully big so let's cut it out for now. */
         && !wp->blending /* as above, blending is too big and slow, and needs more registers */
         && (wp->TTRType != TTRType_ColourMap) /* as above, too many pixel format conversions can overflow buffer) */
         ? TRUE : FALSE);
  /* Without the second test we MIGHT have to omit the first pixel, which the 1:1 code doesn't allow for. */
  /* The 2-at-a-time loop doesn't allow for PLOTMASK - not important enough. */
  /* The 2-at-a-time loop doesn't allow for any gcol but 0 - not important enough. */
}

static BOOL x_block_move(asm_workspace *wp, workspace *ws)
/* Returns true if the inner loop is the simple movement of a block of bits */
{
  return (  simple_x_scale(wp, ws)
         && wp->BPC == (1<<wp->save_inlog2bpc)
         && ws->gcol == 0
         && !SOURCE_MASK
         && !SOURCE_TABLE
         && wp->cal_table == 0
         && ws->in_pixelformat == ws->out_pixelformat
         && !wp->blending
         ? TRUE : FALSE);
}

static BOOL simple_y_scale(asm_workspace *wp, workspace *ws)
/* Return true if 1:1 along y */
{
  UNUSED(ws);
  return wp->save_yadd == wp->save_ydiv;
}

static int palette_is_grey(int *palette, int entries)
/* Scan a palette looking how they increment to deduce if it's just greyscale */
{
  int loop;
  int entry;
  int ascending = 1;

  for (loop=0;loop<entries;loop++)
  {
    entry = palette[loop];

    if (((entry ^ (entry>>8)) & 0xffff00) != 0)
      return 0;
    if ((entry & 0xff00)>>8 != loop)
      ascending = 0;
  }
  if (ascending)
   return 2;
  return 1;
}

/**************************************************************************
*                                                                         *
*    Bitblit: Register allocation.                                        *
*                                                                         *
**************************************************************************/

static void ptrs_rn(asm_workspace *wp, workspace *ws)
/* Declare the pointer registers, which must be visible in both the x-loop and the y-loop */
{
  /* r_pixel is always needed, and need not be saved between loops.
   * So, we put it in r14 to remove the need for the register allocator
   * to worry about r14.
   */
  int flags = REGFLAG_TEMPORARY+REGFLAG_XLOOP+REGFLAG_PERPIXEL;
  if(PLOTMASK)
    flags |= REGFLAG_YLOOP; /* For ECF handling */
  RN(r_pixel, 14, flags, "fetched and translated pixel")

  /* In most cases there are not enough registers, and the control of
   * the outer (y) loop requires swapping two 'banks' of registers.
   * inptr, outptr (and maskinptr if it exists) are always registers
   * r0, r1, r2, and they are visible when the y registers are swapped in.
   */
  RN(r_inptr, 0, REGFLAG_XLOOP+REGFLAG_YLOOP+REGFLAG_XLOOPVAR, PLOTMASK ? "ECF pattern pointer" : "input word pointer")
  RN(r_outptr, 1, REGFLAG_XLOOP+REGFLAG_YLOOP+REGFLAG_XLOOPVAR, "word pointer to output")
  if (SOURCE_TRICKYMASK || PLOTMASK) RN(r_maskinptr, -1, REGFLAG_XLOOP+REGFLAG_YLOOP+REGFLAG_XLOOPVAR, "mask input word pointer")

  if (ws->odither) RN(r_oditheradd, -1, REGFLAG_XLOOP+REGFLAG_YLOOP+REGFLAG_PERPIXEL+REGFLAG_XLOOPVAR, "ordered dither offset value")
  /* The initial dither add value needs to be changed for every output line,
   * so it helps to have r_oditheradd visible in the y loop
   */
}

static void xloop_rn(asm_workspace *wp, workspace *ws)
/* Other variables for the x-loop */
{
  int need_temps = 0; /* set to 1 or 2 if temp1 and temp2 are needed */
  if (x_block_move(wp, ws))
  {
    /* X loop is very very simple, and communicates with machine-code block-shift routine. */
    RN(r_inshift, 2, REGFLAG_GLOBAL+REGFLAG_XLOOPVAR, "Number of (most sig) bits of first input word to transfer, in 1..32")
    RN(r_outshift, 3, REGFLAG_GLOBAL+REGFLAG_XLOOPVAR, "Number of (most sig) bits of first output word to fill, in 1..32")
    RN(r_xsize, 4, REGFLAG_GLOBAL+REGFLAG_XLOOPVAR, "Number of bits to transfer per row")
    RN(r_blockroutine, -1, REGFLAG_GLOBAL, "Block transfer routine")
    /* Those registers had better be the same ones as the assembler code is expecting! */
    assert(ws->regnames.r_inptr.regno == 0, ERROR_FATAL);
    assert(ws->regnames.r_outptr.regno == 1, ERROR_FATAL);
    assert(ws->regnames.r_inshift.regno == 2, ERROR_FATAL);
    assert(ws->regnames.r_outshift.regno == 3, ERROR_FATAL);
    assert(ws->regnames.r_xsize.regno == 4, ERROR_FATAL);
  }
  else
  {
    /* Normal case - declare whatever other registers are needed for fetching and translating pixels. */
    if (PLOTMASK)
      RN(r_inword, -1, REGFLAG_XLOOP, "ECF pattern input word")
    else if (!SOURCE_32_BIT) /* if not 32-bit source */
    {
      RN(r_inshift, -1, REGFLAG_XLOOP+REGFLAG_XLOOPVAR, "bit shift of current pixel LSL #27")
      RN(r_inword, -1, REGFLAG_XLOOP, "current input word")
    }
    if (SOURCE_MASK)
    {
      RN(r_maskinword, -1, REGFLAG_XLOOP, "current mask word")
      if (SOURCE_TRICKYMASK || PLOTMASK)
        RN(r_maskinshift, -1, REGFLAG_XLOOP+REGFLAG_XLOOPVAR, "bit shift of current mask pixel")
      else
        RN(r_masko, -1, REGFLAG_XLOOP+REGFLAG_XLOOPVAR, "offset of mask data from sprite data")
    }
    if (  need_temps == 0
       && (ws->gcol != 0)
       && DEST_32_BIT       /* use in save_pixel */
       )
       need_temps = 1;

    if (PLOTMASK)
    {
      RN(r_ecfindex, -1, REGFLAG_XLOOP+REGFLAG_XLOOPVAR, "index into ECF pattern")
      RN(r_bgcolour, -1, REGFLAG_XLOOP+REGFLAG_XLOOPVAR, "background plotting colour")
    }
    else
    {
      if (SOURCE_TABLE || wp->cal_table) RN(r_table, -1, REGFLAG_PERPIXEL+REGFLAG_CONSTANT, "translation table or palette")

      need_temps = translate_pixel_rn(wp,ws,need_temps);

      if ( need_temps == 0
        && (wp->save_xmag % wp->save_xdiv) == 0
        && (wp->save_xmag / wp->save_xdiv) > 4    /* used in optimised scale up */
         )
       need_temps = 1;
    }

    /* Declare whatever registers needed for saving the new pixel
     * into the current destination pixel.
     */
    if (!DEST_32_BIT)
    {
      RN(r_outword, -1, REGFLAG_XLOOP, "current output word")
      RN(r_outshift, -1, REGFLAG_XLOOP+REGFLAG_XLOOPVAR, "bit shift of current pixel in current output word LSL 27")
    }
    else if (wp->blending)
    {
      RN(r_outword, -1, REGFLAG_XLOOP+REGFLAG_PERPIXEL, "screen pixel to blend with") /* TODO REGFLAG_XLOOP unnecessary? */
    }

    if (wp->save_inlog2bpp <= 3 && simple_x_scale(wp, ws))
      /* going to use 2-at-a-time loop - if 16bpp or more, don't need this register. */
      RN(r_in_pixmask, -1, REGFLAG_XLOOP+REGFLAG_CONSTANT, "pixel mask for 2-at-a-time loop")

    /* Declare whatever registers are needed for control of
     * horizontal scaling. For some simple cases no scaling registers
     * are needed.
     */
    RN(r_xsize, -1, REGFLAG_XLOOP+REGFLAG_XLOOPVAR, "number of output pixels per row")
    if (!simple_x_scale(wp, ws)) /* not 1:1 scale */
      RN(r_xcount, -1, REGFLAG_XLOOP+REGFLAG_XLOOPVAR, "total for x scale")
      /* Adder and subractor values become constants in the code. */
  }

  blendimpl_rn(wp,ws);

  if (need_temps >= 1) RN(r_temp1, -1, REGFLAG_PERPIXEL+REGFLAG_TEMPORARY+REGFLAG_XLOOP, "temp1 for pixel transformation temporary values")
  if (need_temps >= 2) RN(r_temp2, -1, REGFLAG_PERPIXEL+REGFLAG_TEMPORARY, "temp2 for pixel transformation temporary values")
}

static void yloop_rn(asm_workspace *wp, workspace *ws)
/* Declare whatever registers are needed for control of
 * the vertical loop. These registers are part of a separate 'bank'
 * from those in the central loop.
 */
{
  RN(r_ysize, -1, REGFLAG_YLOOP, "number of output rows");
  if (!simple_y_scale(wp, ws)) /* not 1:1 scale */
    RN(r_ycount, -1, REGFLAG_YLOOP, "total for y scale")

  /* Adder and subractor values become constants in the code. */
  RN(r_inoffset, -1, REGFLAG_YLOOP+REGFLAG_CONSTANT, "byte offset between input rows.")
  if (SOURCE_TRICKYMASK || PLOTMASK) RN(r_maskinoffset, -1, REGFLAG_YLOOP+REGFLAG_CONSTANT, "byte offset between mask rows.")
  if (wp->is_it_jpeg)             RN(r_fetchroutine, -1, REGFLAG_XLOOP+REGFLAG_CONSTANT, "routine for getting row of decompressed JPEG data.")

  /* MAX POSSIBLE REQUIREMENT - 5 registers */
}

/**************************************************************************
*                                                                         *
*    Bitblit: Register initialisation.                                    *
*                                                                         *
**************************************************************************/

static void get_in_shift(asm_workspace *wp, workspace *ws)
/* Used within fetch_pixel_init, to load r_inshift. The complication is
 * that if this is JPEG data then the save_inshift value was not calculated,
 * because SpriteExtend assembler stuff thought this was 32bit data. This
 * only matters if JPEG is being made to produce 8bpp or 16bpp data.
 */
{
  if (wp->is_it_jpeg && wp->save_inlog2bpp != 5)
  {
    LDR_WP_C(r_inshift, in_x, "input x coord (JPEG input data)")
    if (wp->save_inlog2bpp == 4)
    {
      AND(R(r_inshift), R(r_inshift), S | IMM(1),              "ANDS    r_inshift,r_inshift,#1          ; halfword offset (0 or 1)");
      MOV(R(r_inshift), EQ | IMM(2),                           "MOVEQ   r_inshift,#2                    ; halfword offset (1 or 2)");
      MOV(R(r_inshift), OP2R(R(r_inshift)) | LSLI(4),          "MOV     r_inshift,r_inshift,LSL #4      ; 16/32 bit offset");
    }
    else /* wp->save_inlog2bpp == 3 */
    {
      AND(R(r_inshift), R(r_inshift), S | IMM(3),              "ANDS    r_inshift,r_inshift,#3          ; byte offset as 0/1/2/3");
      RSB(R(r_inshift), R(r_inshift), IMM(4),                  "RSB     r_inshift,r_inshift,#4          ; byte offset as 4/3/2/1");
      MOV(R(r_inshift), OP2R(R(r_inshift)) | LSLI(3),          "MOV     r_inshift,r_inshift,LSL #3      ; 8/16/24/32 bit offset");
    }
  }
  else
  {
    LDR_WP_C(r_inshift, save_inshift, "input initial shift")
    RSB(R(r_inshift), R(r_inshift), IMM(32),                 "RSB     r_inshift,r_inshift,#32         ; pixels of first word to transfer, in 1..32");
  }
}

static void fetch_pixel_init(asm_workspace *wp, workspace *ws)
/* Initialise whatever registers are needed for fetching pixels.
 */
{
  /* The input word pointer */
  if (PLOTMASK)
  {
    LDR_WP_C(r_inptr, save_ecflimit, "base of ECF pattern")
  }
  else if (wp->is_it_jpeg)
  {
    LDR_WP_C(r_inptr, in_y, "initial y coordinate (for JPEG data)")
  }
  else /* normal data source for PutSpriteScaled */
  {
    LDR_WP_C(r_inptr, save_inptr, "input word pointer")
  }

  /* all other registers re fetching input data */
  if (x_block_move(wp, ws))
  {
    /* Prepare for machine code core to inner loop */
    get_in_shift(wp, ws);
    LDR_WP(r_blockroutine, ccompiler_bitblockmove)
  }
  else
  {
    /* initialise r_inptr */
    if (PLOTMASK)
    {
      LDR_WP(r_inptr, save_ecfptr)
    }
    else
    {
      /* r_inword and r_inshift */
      if (!SOURCE_32_BIT) /* if not 32-bit source */
      {
        /* r_inword not initialised yet, done in inner loop */
        get_in_shift(wp, ws);
        MOV(R(r_inshift), OP2R(R(r_inshift)) | LSLI(27),     "MOV     r_inshift,r_inshift,LSL #27     ; keep up at top end of register");
      }
    }

    /* mask registers */
    if (SOURCE_MASK)
    {
      if (SOURCE_TRICKYMASK || PLOTMASK)
      {
        LDR_WP(r_maskinshift, save_maskinshift)
        if (SOURCE_TRICKYMASK)
        {
          LDR_WP(r_maskinptr, save_maskinptr)
        }
        else /* PLOTMASK and not BPPMASK */
        {
          LDR_WP_C(r_maskinptr, save_inptr, "mask pointer for PlotMaskScaled")
          LDR_WP(r_pixel, save_masko) /* temp use of r_pixel */
          ADD(R(r_maskinptr), R(r_maskinptr), OP2R(R(r_pixel)),"ADD     r_maskinptr,r_maskinptr,r_pixel ; mask pointer (for PlotMask)");
        }
        RSB(R(r_maskinshift), R(r_maskinshift), IMM(32),   "RSB     r_maskinshift,r_maskinshift,#32 ; pixels still to shift");
        MOV(R(r_maskinshift),
            OP2R(R(r_maskinshift)) | LSLI(27),             "MOV     r_maskinshift,r_maskinshift,LSL #27 ; keep up at top end of register");
      }
      else
        LDR_WP(r_masko, save_masko)
    }

    if (wp->save_inlog2bpp <= 3 && simple_x_scale(wp, ws))
      MOV(R(r_in_pixmask), IMM(ws->in_pixmask),           "MOV     r_in_pixmask,#in_pixmask        ; for use in 2-at-a-time loop");
  }
    
  newline();
}

static void per_pixel_init(asm_workspace *wp, workspace *ws)
/* Initialise whatever registers are needed for translating pixels.
 */
{
  if (!x_block_move(wp, ws))
  {
    /* translation registers */
    if (wp->cal_table) LDR_WP(r_table, cal_table)
    else if (wp->ColourTTR != 0) LDR_WP(r_table, ColourTTR)

    /* temp1 and temp2 need no initialisation. */

    dither_expansion_init(wp,ws);
  }
    
  newline();
}

static void save_pixel_init(asm_workspace *wp, workspace *ws)
/* Initialise whatever registers are needed for saving the new pixel
 * into the current destination pixel.
 */
{
  LDR_WP(r_outptr, save_outptr)

  if (x_block_move(wp, ws))
  {
    /* Very simple inner loop */
    LDR_WP_C(r_pixel, save_xcoord, "get initial output x coord in pixels") /* Measured in pixels */
    AND(R(r_outshift), R(r_pixel), IMM(ws->out_ppw-1),            "AND     r_outshift,r_pixel,#out_ppw-1   ; pix offset of start");
    MOV(R(r_outshift),OP2R(R(r_outshift)) | LSLI(wp->Log2bpc),  "MOV     r_outshift,r_outshift,LSL #out_l2bpc ; bit offset of start, in 0..31");
    RSB(R(r_outshift), R(r_outshift), IMM(32),                    "RSB     r_outshift,r_outshift,#32       ; pixels of space, in 1..32");
  }
  else
  {
    /* Normal cases */
    if (PLOTMASK || !DEST_32_BIT)
      LDR_WP_C(r_pixel, save_xcoord, "output x coord measured in pixels")

    if (PLOTMASK)
    {
      MOV(R(r_ecfindex), OP2R(IMM(0)),                          "MOV     r_ecfindex, #0               ; should always be 0 ?");
    }

    if (!DEST_32_BIT)
    {
      AND(R(r_outshift), R(r_pixel), IMM(ws->out_ppw-1),          "AND     r_outshift,r_pixel,#out_ppw-1 ; pixel offset of start");
      MOV(R(r_outshift),OP2R(R(r_outshift)) | LSLI(wp->Log2bpc),"MOV     r_outshift,r_outshift,LSL #out_l2bpc ; bit offset of start");
      RSB(R(r_outshift), R(r_outshift), IMM(32),                  "RSB     r_outshift,r_outshift,#32       ; pixels still to rotate");
      MOV(R(r_outshift), OP2R(R(r_outshift)) | LSLI(27),          "MOV     r_outshift,r_outshift,LSL #27   ; up at the top");
    }
  }
}

static void xloop_init(asm_workspace *wp, workspace *ws)
/* Initialise whatever registers are needed for control of
 * horizontal scaling. For some simple cases no scaling registers
 * are needed.
 */
{
  LDR_WP(r_xsize, save_xsize)
  if (!simple_x_scale(wp, ws)) /* not 1:1 scale */
  {
#if 0
    if ((ws->odither) && (SOURCE_16_BIT))
    {
      LDR_WP(r_pixel, save_xcount); /* Changed by (GPS) to fix register spill bug*/
    }
    else
#endif
    {
      LDR_WP(r_xcount, save_xcount);
    }
  }
  if (x_block_move(wp, ws))
    MOV(R(r_xsize), OP2R(R(r_xsize)) | LSLI(wp->Log2bpc),       "MOV     r_xsize,r_xsize,LSL #out_l2bpc  ; size in bits");
  if (wp->is_it_jpeg) LDR_WP_C(r_fetchroutine, fetchroutine, "routine to call to get JPEG data line")
}

static void yloop_init(asm_workspace *wp, workspace *ws)
/* Initialise whatever registers are needed for control of
 * the vertical loop. These registers are part of a separate 'bank'
 * from those in the central loop.
 */
{
  LDR_WP(r_ysize, save_ysize)
  if (!simple_y_scale(wp, ws)) /* not 1:1 scale */ LDR_WP(r_ycount, save_ycount)
  if (!PLOTMASK)
  {
    if (wp->is_it_jpeg)
      /* We could save this register, but there's not all that much point - simpler to code like this. */
      MOV(R(r_inoffset),IMM(1),                                   "MOV     r_inoffset,#1                   ; JPEG coord offset on input");
    else
      LDR_WP(r_inoffset, save_inoffset)
  }
  if (SOURCE_TRICKYMASK) LDR_WP(r_maskinoffset, save_maskinoffset)
  else if (PLOTMASK) LDR_WP(r_maskinoffset, save_inoffset)
}

/**************************************************************************
*                                                                         *
*    Bitblit: Pixel loading, translation, saving.                         *
*                                                                         *
**************************************************************************/

static void fetch_pixel_unmasked(asm_workspace *wp, workspace *ws)
/* Assuming no mask, get the next input pixel and put it in r_pixel. This is separated
 * from fetch_pixel for the case of scaling up an ordered dither, where the same input
 * pixel is repeatedly fetched and translated.
 */
{
  if (PLOTMASK)
  {
    comment(ws, "Fetch an ECF pixel");
    if (DEST_32_BIT)
    {
      ins(ws, LDR(R(r_inword), R(r_inptr))
             | INDEX(R(r_ecfindex), 0),                      "LDR     r_inword,[r_inptr,r_ecfindex] 2222");
      ADD(R(r_ecfindex), R(r_ecfindex),
            IMM(4),                                          "ADD     r_ecfindex,r_ecfindex,#4  5t453");
      ins(ws, LDR(R(r_bgcolour), R(r_inptr))
            | INDEX(R(r_ecfindex), 0),                       "LDR     r_bgcolour,[r_inptr,r_ecfindex]   ; load next EOR word of ECF222");
      SUB(R(r_ecfindex), R(r_ecfindex),
            IMM(4),                                          "SUB     r_ecfindex,r_ecfindex,#4 1212");
    }
    else
    {
      if (DEST_16_BIT)
      {
        if (wp->CPUFlags & CPUFlag_T2)
        {
          UBFX(R(r_pixel),R(r_inword),0,16,0,               "UBFX    r_pixel,r_inword,#0,#16         ; fetch 16 bit ECF pattern pixel");
        }
        else
        {
          MOV(R(r_pixel), OP2R(R(r_inword)) | LSLI(16),     "MOV     r_pixel,r_inword,LSL #16        ; fetch 16 bit ECF pattern pixel");
          MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(16),      "MOV     r_pixel,r_pixel,LSR #16");
        }
      }
    }
  }
  else
  {
    comment(ws, "Fetch a source pixel");
    if (SOURCE_32_BIT)
      ins(ws, LDR(R(r_pixel), R(r_inptr)) | OFFSET(0),    "LDR     r_pixel,[r_inptr]");
    else if (SOURCE_16_BIT)
    {
      if (wp->CPUFlags & CPUFlag_T2)
      {
        UBFX(R(r_pixel),R(r_inword),0,16,0,               "UBFX    r_pixel,r_inword,#0,#16         ; fetch 16 bit ECF pixel");
      }
      else
      {
        MOV(R(r_pixel), OP2R(R(r_inword)) | LSLI(16),     "MOV     r_pixel,r_inword,LSL #16        ; fetch 16 bit pixel");
        MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(16),      "MOV     r_pixel,r_pixel,LSR #16");
      }
      /* >>> Maybe we can leave it in the top 16 bits, and get by? Not yet. */
    }
    else
    {
      AND(R(r_pixel), R(r_inword), IMM(ws->in_pixmask), "AND     r_pixel,r_inword,#in_pixmask    ; fetch the pixel");
    }
  }
}

static BOOL fetch_pixel(asm_workspace *wp, workspace *ws, label *l_masked)
/* Check the mask, fetch the current pixel. If the current pixel is
 * transparent then branch out to l_masked. Return TRUE if the branch could be
 * taken, else FALSE.
 */
{
#ifdef DEBUG
  char a[256];
#endif
  if (SOURCE_MASK)
  {
    if (SOURCE_ALPHAMASK)
    {
      TST(R(r_maskinword), IMM(255),                    "TST     r_maskinword,#255");
    }
    else
    {
      TST(R(r_maskinword), IMM(1),                      "TST     r_maskinword,#1");
    }
    dsprintf((a,                                "BEQ     %s", l_masked->name));
    branch(ws, B | EQ, l_masked, a);
  }

  fetch_pixel_unmasked(wp, ws);

  return SOURCE_MASK;
}

static BOOL fetch_pixel2(asm_workspace *wp, workspace *ws, label *l_masked)
/* Check the mask, fetch the pixel after the current one. You are assured
 * that no word of input need be loaded between these two. If the pixel is
 * transparent then branch out to l_masked. Return TRUE if the branch could be
 * taken, else FALSE.
 */
{
#ifdef DEBUG
  char a[256];
#endif
  assert(!PLOTMASK, ERROR_FATAL); /* Doesn't do 2-at-a-time loop */

  if (SOURCE_MASK) /* Test the second pixel of mask */
  {
    if (SOURCE_TRICKYMASK) /* we may have reached the end of mask word if not doing an aligned plot */
    {
      MOV(R(r_maskinword), OP2R(R(r_maskinword))
                       | RORI(ws->mask_bpc),                   "MOV     r_maskinword,r_maskinword,ROR #mask_bpc");
      SUB(R(r_maskinshift),R(r_maskinshift),
                       S | IMM(ws->mask_bpc*2) | IMMROR(6),    "SUBS    r_maskinshift,r_maskinshift,#mask_bpc:SHL:27");
      ins(ws, LDR(R(r_maskinword), R(r_maskinptr))
          | EQ | WRITEBACK | OFFSET(4),                        "LDREQ   r_maskinword,[r_maskinptr,#4]!     ; load more mask pixels (inc2)");
      if (SOURCE_ALPHAMASK)
      {
        TST(R(r_maskinword), IMM(255),                         "TST     r_maskinword,#255");
      }
      else
      {
        TST(R(r_maskinword), IMM(1),                           "TST     r_maskinword,#1");
      }
    }
    else
    {
      TST(R(r_maskinword),
          ws->mask_bpc < 8
            ? IMM(1 << ws->mask_bpc)
            : IMM(1) | IMMROR(32 - ws->mask_bpc),       "TST     r_maskinword,#1:SHL:mask_bpc");
    }
    dsprintf((a,                                "BEQ     %s", l_masked->name));
    branch(ws, B | EQ, l_masked, a);
  }

  comment(ws, "Fetch the source pixel after the current one");
  if (SOURCE_32_BIT)
    ins(ws, LDR(R(r_pixel), R(r_inptr)) | OFFSET(4),  "LDR     r_pixel,[r_inptr,#4]");
  else if (SOURCE_16_BIT)
  {
    MOV(R(r_pixel), OP2R(R(r_inword)) | LSRI(16),     "MOV     r_pixel,r_inword,LSR #16");
    /* >>> Getting it into top 16bits harder in this case! */
  }
  else
    AND(R(r_pixel), R(r_in_pixmask),
        OP2R(R(r_inword)) | LSRI(ws->in_bpc),         "AND     r_pixel,r_in_pixmask,r_inword,LSR #in_bpc"
                                                      " ; fetch the next pixel");
  return SOURCE_MASK;
}

static void save_pixel(asm_workspace *wp, workspace *ws)
/* Save the new pixel into the current destination pixel. */
/* Recall GCOL actions:
 * 0 -> overwrite old pixel
 * 1 -> OR with old pixel
 * 2 -> AND with old pixel
 * 3 -> EOR with old pixel
 * 4 -> invert old pixel
 * 5 -> do nothing
 * 6 -> AND old pixel with NOT of new pixel
 * 7 -> OR old pixel with NOT of new pixel
 */
{
  comment(ws, "Put the pixel in the output stream.");
  if (PLOTMASK)
  {
    if (DEST_32_BIT)
    {
      ins(ws, LDR(R(r_pixel), R(r_outptr)) | OFFSET(0),              "LDR     r_pixel,[r_outptr] ;bkah");
      ORR(R(r_pixel), R(r_inword), OP2R(R(r_pixel)),                 "ORR     r_pixel,r_inword,r_pixel               ; 1OR gcol action");
      EOR(R(r_pixel), R(r_bgcolour), OP2R(R(r_pixel)),               "EOR     r_pixel,r_bgcolour,r_pixel            ; 1EOR gcol action");
      ins(ws, STR(R(r_pixel), R(r_outptr)) | OFFSET(0),              "STR     r_pixel,[r_outptr]                    ;blaq5h");
    }
    else
    {
      if (DEST_16_BIT)
      {
        if (wp->CPUFlags & CPUFlag_T2)
        {
          UBFX(R(r_pixel),R(r_inword),0,16,0,                     "UBFX    r_pixel,r_inword,#0,#16         ; fetch 16 bit ECF pattern pixel");
        }
        else
        {
          MOV(R(r_pixel), OP2R(R(r_inword)) | LSLI(16),           "MOV     r_pixel,r_inword,LSL #16        ; fetch 16 bit ECF pattern pixel44 99");
          MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(16),            "MOV     r_pixel,r_pixel,LSR #16         ; 4444444");
        }
        ORR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),         "ORR     r_outword,r_outword,r_pixel           ; ECF OR mask44 99");
        if (wp->CPUFlags & CPUFlag_T2)
        {
          UBFX(R(r_pixel),R(r_bgcolour),0,16,0,                   "UBFX    r_pixel,r_bgcolour,#0,#16         ; fetch 16 bit ECF pattern pixel");
        }
        else
        {
          MOV(R(r_pixel), OP2R(R(r_bgcolour)) | LSLI(16),         "MOV     r_pixel,r_bgcolour,LSL #16        ; fetch 16 bit ECF pattern pixel 4499");
          MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(16),            "MOV     r_pixel,r_pixel,LSR #16           ;449");
        }
        EOR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),         "EOR     r_outword,r_outword,r_pixel           ; ECF EOR mask 4499");
      }
      else
      {
        AND(R(r_pixel), R(r_inword), IMM(ws->out_pixmask),        "AND     r_pixel,r_inword,#out_pixmask  ; blah blah");
        ORR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),         "ORR     r_outword,r_outword,r_pixel           ; ECF OR mask");
        AND(R(r_pixel), R(r_bgcolour), IMM(ws->out_pixmask),      "AND     r_pixel,r_bgcolour,#out_pixmask    jthjg");
        EOR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),         "EOR     r_outword,r_outword,r_pixel           ; ECF EOR mask");
      }
    }
  }
  else
  {
    if (DEST_32_BIT)
    {
      if (ws->gcol != 0) /* Not just a simple store operation */
      {
        ins(ws, LDR(R(r_temp1), R(r_outptr)) | OFFSET(0),             "LDR     r_temp1,[r_outptr]");
        switch(ws->gcol)
        {
          case 7: MVN(R(r_pixel), OP2R(R(r_pixel)),                     "MVN     r_pixel,r_pixel                       ; OR with neg action");
          case 1: ORR(R(r_temp1), R(r_pixel), OP2R(R(r_temp1)),         "ORR     r_temp1,r_pixel,r_temp1               ; OR gcol action"); break;
          case 6: BIC(R(r_temp1), R(r_temp1), OP2R(R(r_pixel)),         "BIC     r_temp1,r_temp1,r_pixel               ; AND NOT gcol action"); break;
          case 2: AND(R(r_temp1), R(r_pixel), OP2R(R(r_temp1)),         "AND     r_temp1,r_pixel,r_temp1               ; AND gcol action"); break;
          case 3: EOR(R(r_temp1), R(r_pixel), OP2R(R(r_temp1)),         "EOR     r_temp1,r_pixel,r_temp1               ; EOR gcol action"); break;
          case 4: MVN(R(r_temp1), OP2R(R(r_temp1)),                     "MVN     r_temp1,r_temp1                       ; neg gcol action"); break;
          /* case 5: is a NOP */
        }
        ins(ws, STR(R(r_temp1), R(r_outptr)) | OFFSET(0),               "STR     r_temp1,[r_outptr]");
        if (ws->gcol == 7) /* put r_pixel back as we found it */
          MVN(R(r_pixel), OP2R(R(r_pixel)),                             "1MVN     r_pixel,r_pixel                       ; Put r_pixel back");
      }
      else
      {
        ins(ws, STR(R(r_pixel), R(r_outptr)) | OFFSET(0),             "STR     r_pixel,[r_outptr]");
      }
    }
    else
    {
      if (ws->gcol == 7) /* AND with NOT of incoming pixel */
      {
        if (DESTD_16_BIT)
        {
          EOR(R(r_pixel), R(r_pixel), IMM(255),                       "1EOR     r_pixel,r_pixel,#0x00ff               ; act with NOT of input pixel");
          EOR(R(r_pixel), R(r_pixel), IMM(255) | IMMROR(24),          "1EOR     r_pixel,r_pixel,#0xff00");
        }
        else
          EOR(R(r_pixel), R(r_pixel), IMM(ws->out_dpixmask),          "1EOR     r_pixel,r_pixel,#out_dpixmask         ; act with NOT of input pixel");
      }

      switch (ws->gcol)
      {
        case 0:
          if (SOURCE_MASK || wp->blending) /* if no mask, the pixels are clear already */
          {
            if (wp->CPUFlags & CPUFlag_T2)
            {
              BFC(R(r_outword), 0, wp->BPC, 0,                          "BFC     r_outword,#0,#out_bpc"); 
            }
            else if (DESTD_16_BIT)
            {
              BIC(R(r_outword), R(r_outword), IMM(255),                 "BIC     r_outword,r_outword,#0x00ff");
              BIC(R(r_outword), R(r_outword), IMM(255) | IMMROR(24),    "BIC     r_outword,r_outword,#0xff00");
            }
            else
              BIC(R(r_outword), R(r_outword), IMM(ws->out_dpixmask),    "BIC     r_outword,r_outword,#out_dpixmask");
          }
          /* fall through */
        case 7:
        case 1: ORR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),       "ORR     r_outword,r_outword,r_pixel           ; gcol action"); break;
        case 6: BIC(R(r_outword), R(r_outword), OP2R(R(r_pixel)),       "BIC     r_outword,r_outword,r_pixel           ; AND NOT gcol action"); break;
        case 2: AND(R(r_outword), R(r_outword), OP2R(R(r_pixel)),       "AND     r_outword,r_outword,r_pixel           ; AND gcol action"); break;
        case 3: EOR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),       "EOR     r_outword,r_outword,r_pixel           ; EOR gcol action"); break;
        case 4: if (DESTD_16_BIT)
                {
                  EOR(R(r_outword), R(r_outword), IMM(255),             "EOR     r_outword,r_outword,#0x00ff           ; negate existing pixel");
                  EOR(R(r_outword), R(r_outword), IMM(255) | IMMROR(24),"EOR     r_outword,r_outword,#0xff00");
                }
                else
                  EOR(R(r_outword), R(r_outword), IMM(ws->out_dpixmask),"EOR     r_outword,r_outword,#out_dpixmask     ; negate existing pixel");
                break;
        case 5: comment(ws, "no GCOL action"); break;
      }
      if (ws->gcol == 7) /* put r_pixel back as we found it in case scaling > 1:1! */
      {
        if (DESTD_16_BIT)
        {
          EOR(R(r_pixel), R(r_pixel), IMM(255),                       "EOR     r_pixel,r_pixel,#0x00ff               ; put r_pixel back as it was");
          EOR(R(r_pixel), R(r_pixel), IMM(255) | IMMROR(24),          "EOR     r_pixel,r_pixel,#0xff00               ; put r_pixel back as it was");
        }
        else
          EOR(R(r_pixel), R(r_pixel), IMM(ws->out_dpixmask),          "EOR     r_pixel,r_pixel,#out_dpixmask         ;  put r_pixel back as it was");
      }
    }
  }
}

static void save_pixel_opt(asm_workspace *wp, workspace *ws)
/* Save pixel for use by optimised >5 scaling code. */
{
  if (wp->CPUFlags & CPUFlag_T2)
  {
    BFI(R(r_outword), R(r_pixel), 0, wp->BPC, 0,                "BFI     r_outword,r_pixel,#0,#out_bpc     ; gcol action"); 
  }
  else
  {
    if (DESTD_16_BIT)
    {
      BIC(R(r_outword), R(r_outword), IMM(255),                 "BIC     r_outword,r_outword,#0x00ff");
      BIC(R(r_outword), R(r_outword), IMM(255) | IMMROR(24),    "BIC     r_outword,r_outword,#0xff00");
    }
    else
    {
      BIC(R(r_outword), R(r_outword), IMM(ws->out_dpixmask),    "BIC     r_outword,r_outword,#out_dpixmask");
    }
    ORR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),       "ORR     r_outword,r_outword,r_pixel           ; gcol action");
  }
}

static void save_pixel2(asm_workspace *wp, workspace *ws)
/* Save the new pixel into the pixel after the current destination pixel. */
{
  comment(ws, "Put the pixel in the output stream, one after the 'current' pixel.");

  /* Current limitation */
  assert(ws->gcol == 0, ERROR_FATAL);

  if (DEST_32_BIT)
  {
    ins(ws, STR(R(r_pixel), R(r_outptr)) | OFFSET(4),         "STR     r_pixel,[r_outptr,#4]");
  }
  else if (wp->CPUFlags & CPUFlag_T2)
  {
    BFI(R(r_outword), R(r_pixel), wp->BPC, wp->BPC, 0,        "BFI     r_outword,r_pixel,#out_bpc,#out_bpc");
  }
  else
  {
    if (SOURCE_MASK)
    {
      if (wp->BPC == 16) /* DEST_16_BIT but includes double-pixel 256-colour mode 10 too */
      {
        BIC(R(r_outword), R(r_outword), IMM(255) | IMMROR(16),"BIC     r_outword,r_outword,#0x00ff0000");
        BIC(R(r_outword), R(r_outword), IMM(255) | IMMROR(8), "BIC     r_outword,r_outword,#0xff000000");
      }
      else
        BIC(R(r_outword), R(r_outword),
            wp->BPC == 1
              ? IMM(2) /* IMMROR arg must be an even number */
              : IMM(ws->out_dpixmask) | IMMROR(32 - wp->BPC), "BIC     r_outword,r_outword,#out_dpixmask:SHL:out_bpc");
    }
    ORR(R(r_outword),R(r_outword),
        OP2R(R(r_pixel)) | LSLI(wp->BPC),                     "ORR     r_outword,r_outword,r_pixel,LSL #out_bpc");
  }
}

/**************************************************************************
*                                                                         *
*    Bitblit: Advancing the current pixel.                                *
*                                                                         *
**************************************************************************/

static void fetch_pixel_inc(asm_workspace *wp, workspace *ws)
/* Increment the pointer to the source pixel */
{
  comment(ws, "Advance source pointer");

  if (!PLOTMASK) /* The ECF pattern remains aligned to the destination */
  {
    if (SOURCE_32_BIT)
    {
      ADD(R(r_inptr), R(r_inptr), IMM(4),                      "ADD     r_inptr,r_inptr,#4");
    }
    else
    {
      MOV(R(r_inword), OP2R(R(r_inword)) | RORI(ws->in_bpc),   "MOV     r_inword,r_inword,ROR #in_bpc");
      if (SOURCE_OLDMASK)
      {
        MOV(R(r_maskinword), OP2R(R(r_maskinword)) |
                             RORI(ws->in_bpc),                 "MOV     r_maskinword,r_maskinword,ROR #in_bpc");
      }
      SUB(R(r_inshift), R(r_inshift),
          S | IMM(ws->in_bpc*2) | IMMROR(6),                   "SUBS    r_inshift,r_inshift,#in_bpc:SHL:27 ; auto-resets itself to 0");
      ins(ws, LDR(R(r_inword), R(r_inptr))
            | EQ | WRITEBACK | OFFSET(4),                      "LDREQ   r_inword,[r_inptr,#4]!");
    }
  }

  if (SOURCE_MASK)
  {
    if (SOURCE_TRICKYMASK || PLOTMASK)
    {
#ifdef ASMdoublepixel_bodge
      MOV(R(r_maskinword), OP2R(R(r_maskinword))
                         | RORI(ws->mask_bpp),               "MOV     r_maskinword,r_maskinword,ROR #mask_bpp");
      SUB(R(r_maskinshift),R(r_maskinshift),
                         S | IMM(ws->mask_bpp*2) | IMMROR(6),"SUBS    r_maskinshift,r_maskinshift,#mask_bpp:SHL:27 ; auto-resets itself to 0");
#else
      MOV(R(r_maskinword), OP2R(R(r_maskinword))
                         | RORI(ws->mask_bpc),               "MOV     r_maskinword,r_maskinword,ROR #mask_bpc");
      SUB(R(r_maskinshift),R(r_maskinshift),
                         S | IMM(ws->mask_bpc*2) | IMMROR(6),"SUBS    r_maskinshift,r_maskinshift,#mask_bpc:SHL:27 ; auto-resets itself to 0");
#endif
      ins(ws, LDR(R(r_maskinword), R(r_maskinptr))
            | EQ | WRITEBACK | OFFSET(4),                    "LDREQ   r_maskinword,[r_maskinptr,#4]!");
    }
    else
    {
      assert(!SOURCE_32_BIT, ERROR_FATAL);
      ins(ws, LDR(R(r_maskinword),
              R(r_inptr)) | EQ | INDEX(R(r_masko), 0),       "LDREQ   r_maskinword,[r_inptr,r_masko]");
    }
  }
}

static void fetch_pixel_inc2(asm_workspace *wp, workspace *ws)
/* Increment the pointer to the source pixel by two - only used in the 2-at-a-time
 * optimised loop
 */
{
  comment(ws, "Advance source pointer by two pixels");
  if (SOURCE_32_BIT)
  {
    ADD(R(r_inptr), R(r_inptr), IMM(8),                      "ADD     r_inptr,r_inptr,#8                ; past 2 32-bit pixels");
  }
  else if (SOURCED_16_BIT)
  {
    /* Two pixels per word - assured of loading a new word */
    ins(ws, LDR(R(r_inword), R(r_inptr))
          | WRITEBACK | OFFSET(4),                           "LDR     r_inword,[r_inptr,#4]!             ; past 2 16-bit pixels");
  }
  else
  {
    MOV(R(r_inword), OP2R(R(r_inword)) | RORI(ws->in_bpc*2), "MOV     r_inword,r_inword,ROR #in_bpc*2");
    if (SOURCE_OLDMASK)
    {
      MOV(R(r_maskinword), OP2R(R(r_maskinword)) |
                           RORI(ws->in_bpc*2),               "MOV     r_maskinword,r_maskinword,ROR #in_bpc*2 ; two more mask bits");
    }
    SUB(R(r_inshift), R(r_inshift),
        S | IMM(ws->in_bpc) | IMMROR(4),                     "SUBS    r_inshift,r_inshift,#in_bpc:SHL:27+1 ; auto-resets itself to 0");
    ins(ws, LDR(R(r_inword), R(r_inptr))
          | EQ | WRITEBACK | OFFSET(4),                      "LDREQ   r_inword,[r_inptr,#4]!             ; load more input pixels (inc2)");
  }

  if (SOURCE_MASK)
  {
    if (SOURCE_TRICKYMASK)
    {
      MOV(R(r_maskinword), OP2R(R(r_maskinword))
                         | RORI(ws->mask_bpc),               "MOV     r_maskinword,r_maskinword,ROR #mask_bpc");
      SUB(R(r_maskinshift),R(r_maskinshift),
                         S | IMM(ws->mask_bpc*2) | IMMROR(6),"SUBS    r_maskinshift,r_maskinshift,#mask_bpc:SHL:27");
      ins(ws, LDR(R(r_maskinword), R(r_maskinptr))
            | EQ | WRITEBACK | OFFSET(4),                    "LDREQ   r_maskinword,[r_maskinptr,#4]!     ; load more mask pixels (inc2)");
    }
    else
    {
      assert(!SOURCE_32_BIT, ERROR_FATAL);
      ins(ws, LDR(R(r_maskinword), R(r_inptr))
              | EQ | INDEX(R(r_masko), 0),                   "LDREQ   r_maskinword,[r_inptr,r_masko]      ; load more mask pixels (inc2)");
    }
  }
}

#if 1
static void skip_current_output_words(asm_workspace *wp, workspace *ws)
/* Skip over masked out words. r_xcount = output pixels to skip
 *                             r_temp1   = pixels left in current word.
 */
{
  comment(ws, "4Skipping masked words.");
  if (DEST_32_BIT)
  {
    ADD(R(r_outptr), R(r_outptr), R(r_xcount) | LSLI(2),          "ADD     r_outptr,r_outptr,r_xcount,LSL #2        ; skip 4*pixels bytes");
    MOV(R(r_xcount), IMM(0),                                      "MOV     r_xcount,#0");
  }
  else
  {
    SUB(R(r_xcount), R(r_xcount), OP2R(R(r_temp1)),               "SUB     r_xcount, r_xcount, r_temp1");
    MOV(R(r_temp1),  OP2R(R(r_temp1)) | LSLI(wp->Log2bpc),        "MOV     r_temp1, t_temp1, LSL #out_log2bpc");
    MOV(R(r_outword), OP2R(R(r_outword)) | RORR(R(r_temp1)),      "MOV     r_outword,r_outword,ROR r_temp1");
    ins(ws, STR(R(r_outword), R(r_outptr)) | POSTINC(4),          "STR     r_outword,[r_outptr],#4");
    MOV(R(r_outshift), IMM(0),                                    "MOV     r_outshift, #0");

    MOV(R(r_temp1), OP2R(R(r_xcount)) | S |LSRI(ws->out_l2ppw),   "MOVS    r_temp1,r_xcount,LSR #out_log2ppw            ; whole words to skip");
    ADD(R(r_outptr), R(r_outptr), NE | R(r_temp1) | LSLI(2),      "ADDNE   r_outptr,r_outptr,r_temp1,LSL #2             ; skip 4*pixels bytes");

    ins(ws, LDR(R(r_outword), R(r_outptr)) | OFFSET(0),           "LDR     r_outword,[r_outptr]");
    SUB(R(r_xcount), R(r_xcount),
                      OP2R(R(r_temp1)) | LSLI(ws->out_l2ppw),     "SUB     r_xcount, r_xcount, r_temp1 LSL #out_log2ppw ; pixels left to skip");
  }
}

static void skip_some_pixels(asm_workspace *wp, workspace *ws)
/* Adjust outword and outshift back to start */
{
    MOV(R(r_temp1),  OP2R(R(r_xcount)) | LSLI(wp->Log2bpc),       "MOV     r_temp1, r_xcount, LSL #out_log2bpc");
    MOV(R(r_outword), OP2R(R(r_outword)) | RORR(R(r_temp1)),      "MOV     r_outword,r_outword,ROR r_temp1");
    SUB(R(r_outshift), R(r_outshift),
        OP2R(R(r_temp1)) | LSLI(27),                              "SUB     r_outshift,r_outshift,r_temp1,SHL #27");
    MOV(R(r_xcount), IMM(0),                                      "MOV     r_xcount,#0");
    UNUSED(wp);
}
#endif

static void save_pixel_inc(asm_workspace *wp, workspace *ws)
/* Increment the pointer to the destination pixel */
{
  comment(ws, "Advance destination pointer");
  if (DEST_32_BIT)
  {
    ADD(R(r_outptr), R(r_outptr), IMM(4),                    "ADD     r_outptr,r_outptr,#4 323232");
  }
  else
  {
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),    "MOV     r_outword,r_outword,ROR #out_bpc    545454");
    if (PLOTMASK)
    {
      MOV(R(r_inword), OP2R(R(r_inword)) | RORI(wp->BPC),    "MOV     r_inword,r_inword,ROR #out_bpc         ; advance ECF pattern    5");
      MOV(R(r_bgcolour), OP2R(R(r_bgcolour)) | RORI(wp->BPC),    "MOV     r_bgcolour,r_bgcolour,ROR #out_bpc ; advance ECF eeyore pattern    5");
    }
    SUB(R(r_outshift), R(r_outshift),
        S | IMM(wp->BPC*2) | IMMROR(6),                      "SUBS    r_outshift,r_outshift,#out_bpc:SHL:27        5");
    ins(ws, STR(R(r_outword), R(r_outptr)) | EQ | POSTINC(4),"STREQ   r_outword,[r_outptr],#4        4");
    if (ws->gcol == 0 && !SOURCE_MASK && !PLOTMASK && !wp->blending)
      MOV(R(r_outword), EQ | IMM(0),                         "MOVEQ   r_outword,#0                    ; setting pixels and no mask      4");
    else
      ins(ws, LDR(R(r_outword), R(r_outptr)) | EQ | OFFSET(0), "LDREQ   r_outword,[r_outptr]        4");
  }
  odither_inc(wp, ws, 0);
}

static void save_pixel_inc2(asm_workspace *wp, workspace *ws)
/* Increment the pointer to the destination pixel by two. You are assured that
 * a word fetch won't be necessary after the first of these. Only used in the
 * optimised 2-at-a-time inner loop. You are assured that gcol==0.
 */
{
  comment(ws, "Advance destination pointer by two pixels");
  if (DEST_32_BIT)
    ADD(R(r_outptr), R(r_outptr), IMM(8),                    "ADD     r_outptr,r_outptr,#8");
  else if (DESTD_16_BIT)
  {
    /* Two pixels per word - assured of saving a word, assured that gcol==0 and !SOURCE_MASK*/
    ins(ws, STR(R(r_outword), R(r_outptr)) | POSTINC(4),     "STR     r_outword,[r_outptr],#4         ; store two pixels");
    if (!SOURCE_MASK)
      MOV(R(r_outword), IMM(0),                              "MOV     r_outword,#0                    ; setting pixels and no mask");
    else
      ins(ws, LDR(R(r_outword), R(r_outptr)) | OFFSET(0),    "LDR     r_outword,[r_outptr]            ; load dest data (in case of mask)");
  }
  else
  {
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC*2),  "MOV     r_outword,r_outword,ROR #out_bpc*2 ; two more done");
    SUB(R(r_outshift), R(r_outshift),
        S | IMM(wp->BPC) | IMMROR(4),                        "SUBS    r_outshift,r_outshift,#out_bpc:SHL:27+1");
    ins(ws, STR(R(r_outword), R(r_outptr)) | EQ | POSTINC(4),"STREQ   r_outword,[r_outptr],#4         ; store pixels (inc2)");
    if (!SOURCE_MASK)
      MOV(R(r_outword), EQ | IMM(0),                         "MOVEQ   r_outword,#0                    ; setting pixels and no mask (inc2)");
    else
      ins(ws, LDR(R(r_outword), R(r_outptr)) | EQ | OFFSET(0), "LDREQ   r_outword,[r_outptr]            ; get dest data (in case of mask)");
    /* If entirely replacing pixels, no need to fetch the old ones.
     * The last word has to be patched up carefully, see x_loop.
     */
  }
  odither_inc(wp, ws, 0); /* assume this has also been called once after the first pixel has been translated */
}

static void plot_current_output_words(asm_workspace *wp, workspace *ws, int scale)
/* plot multiple words of one pixel. r_xcount = output pixels to skip
 *                                   r_temp1   = pixels left in current word.
 *                                   r_pixel = pixel to output.
 */
{
  int loop;
  comment(ws, "2Optimised plotting of scaled sprite.");
  if (DEST_32_BIT)
  {
#if 1
    ins(ws, STR(R(r_pixel),  R(r_outptr)) | POSTINC(4),      "32STR     r_pixel,[r_outptr],#4");
    SUB(R(r_xcount), R(r_xcount),
        S | IMM(1),                                         "14SUBS    r_xcount,r_xcount,#1");
    if (scale < 21)
    {
      for (loop = 1;loop<scale;loop++)
      {
        ins(ws, STR(R(r_pixel), R(r_outptr)) | NE | POSTINC(4),      "32STRNE   r_pixel,[r_outptr],#4");
        SUB(R(r_xcount), R(r_xcount),
              S | NE | IMM(1),                                    "14SUBNES    r_xcount,r_xcount,#1");
      }
    }
    else
    {
      CMP(R(r_xcount), IMM(10),                                    "CMP     r_xcount, #10");
      branch(ws, B | LE, L(plot_loop1b),                           "BLE     plot_loop1b");
      DEFINE_LABEL(plot_loop1a, "loop for every ten pixels")
      for (loop = 0;loop<10;loop++)
      {
        ins(ws, STR(R(r_pixel), R(r_outptr)) | POSTINC(4),         "32STR   r_pixel,[r_outptr],#4");
      }
      SUB(R(r_xcount), R(r_xcount),
          IMM(10),                                                 "14SUB    r_xcount,r_xcount,#10");
      CMP(R(r_xcount), IMM(10),                                    "CMP     r_xcount, #10");
      branch(ws, B | GT, L(plot_loop1a),                           "BGT     plot_loop1a");
      DEFINE_LABEL(plot_loop1b, "branch here when LH side obscured")
      CMP(R(r_xcount), IMM(0),                                     "CMP     r_xcount, #0");
      for (loop = 0;loop<10;loop++)
      {
        ins(ws, STR(R(r_pixel), R(r_outptr)) | NE | POSTINC(4),      "4STRNE   r_pixel,[r_outptr],#4");
        SUB(R(r_xcount), R(r_xcount),
              S | NE | IMM(1),                                    "16SUBNES    r_xcount,r_xcount,#1");
      }
    }
#else
    for (loop = 0;loop<scale;loop++)
      ins(ws, STR(R(r_pixel), R(r_outptr)) | POSTINC(4),      "32STR   r_outword,[r_outptr],#4");
#endif
  }
  else
  {
    SUB(R(r_xcount), R(r_xcount), OP2R(R(r_temp1)),             "52SUB     r_xcount, r_xcount, r_temp1");

    DEFINE_LABEL(plot_loop1, "1???")
    save_pixel_opt(wp, ws);
    SUB(R(r_outshift), R(r_outshift),
        S | IMM(wp->BPC*2) | IMMROR(6),                         "SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "MOV     r_outword,r_outword,ROR #out_bpc");
    branch(ws, B | EQ, L(plot_loop1a),                          "BEQ     plot_loop1a");

    save_pixel_opt(wp, ws);
    SUB(R(r_outshift), R(r_outshift),
        S | IMM(wp->BPC*2) | IMMROR(6),                         "SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "MOV     r_outword,r_outword,ROR #out_bpc");
    branch(ws, B | EQ, L(plot_loop1b),                          "BEQ     plot_loop1b");

    save_pixel_opt(wp, ws);
    SUB(R(r_outshift), R(r_outshift),
        S | IMM(wp->BPC*2) | IMMROR(6),                         "SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "MOV     r_outword,r_outword,ROR #out_bpc");
    branch(ws, B | EQ, L(plot_loop1c),                          "BEQ     plot_loop1c");

    save_pixel_opt(wp, ws);
    SUB(R(r_outshift), R(r_outshift),
        S | IMM(wp->BPC*2) | IMMROR(6),                         "SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "MOV     r_outword,r_outword,ROR #out_bpc");

    branch(ws, B | NE, L(plot_loop1),                           "8BNE     plot_loop1");
    DEFINE_LABEL(plot_loop1a, "plot loop 1a - coz only one forward referance allowed")
    DEFINE_LABEL(plot_loop1b, "plot loop 1b - coz only one forward referance allowed")
    DEFINE_LABEL(plot_loop1c, "plot loop 1c - coz only one forward referance allowed")

    ins(ws, STR(R(r_outword), R(r_outptr)) | POSTINC(4),          "9STR     r_outword,[r_outptr],#4");

    MOV(R(r_temp1), OP2R(R(r_xcount)) | S |LSRI(ws->out_l2ppw),   "0MOVS    r_temp1,r_xcount,LSR #out_log2ppw            ; whole words to skip");

    branch(ws, B | EQ, L(plot_loop3),                             "1BEQ     plot_loop3");

    for (loop = wp->BPC;loop<32;loop*=2)
      ORR(R(r_pixel), R(r_pixel), OP2R(R(r_pixel)) | LSLI(loop),  "2ORR     r_pixel,r_pixel,r_pixel, LSL #somenumber");
    DEFINE_LABEL(plot_loop2, "2???")
    ins(ws, STR(R(r_pixel), R(r_outptr)) | POSTINC(4),            "3STR     r_pixel,[r_outptr],#4");
    SUB(R(r_temp1), R(r_temp1),
        S | IMM(1),                                               "5SUBS    r_temp1,r_temp1,#1");
    SUB(R(r_xcount), R(r_xcount),
        IMM(ws->out_ppw),                                         "4SUB     r_xcount,r_xcount,#out_ppw");
    branch(ws, B | NE, L(plot_loop2),                             "6BNE     plot_loop2");

    MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(32-wp->BPC),          "MOV     r_pixel,r_pixel,LSR #32-out_bpc");

    DEFINE_LABEL(plot_loop3, "3???")


    ins(ws, LDR(R(r_outword), R(r_outptr)) | OFFSET(0),           "0LDR     r_outword,[r_outptr]");
  }
}

static void plot_some_pixels(asm_workspace *wp, workspace *ws)
/* Non complete word pixel plot */
{
    DEFINE_LABEL(plot_loop4, "4???")
    save_pixel_opt(wp, ws);
    SUB(R(r_xcount), R(r_xcount),
        S | IMM(1),                                             "SUBS    r_xcount, r_xcount, #1");
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "MOV     r_outword,r_outword,ROR #out_bpc");
    SUB(R(r_outshift), R(r_outshift),
        IMM(wp->BPC*2) | IMMROR(6),                             "SUB     r_outshift,r_outshift,#out_bpc:SHL:27");
    branch(ws, B | EQ, L(plot_loop4a),                          "BEQ     plot_loop4a");

    save_pixel_opt(wp, ws);
    SUB(R(r_xcount), R(r_xcount),
        S | IMM(1),                                             "SUBS    r_xcount, r_xcount, #1");
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "MOV     r_outword,r_outword,ROR #out_bpc");
    SUB(R(r_outshift), R(r_outshift),
        IMM(wp->BPC*2) | IMMROR(6),                             "SUB     r_outshift,r_outshift,#out_bpc:SHL:27");
    branch(ws, B | EQ, L(plot_loop4b),                          "BEQ     plot_loop4b");

    save_pixel_opt(wp, ws);
    SUB(R(r_xcount), R(r_xcount),
        S | IMM(1),                                             "SUBS    r_xcount, r_xcount, #1");
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "MOV     r_outword,r_outword,ROR #out_bpc");
    SUB(R(r_outshift), R(r_outshift),
        IMM(wp->BPC*2) | IMMROR(6),                             "SUB     r_outshift,r_outshift,#out_bpc:SHL:27");
    branch(ws, B | EQ, L(plot_loop4c),                          "BEQ     plot_loop4c");

    save_pixel_opt(wp, ws);
    SUB(R(r_xcount), R(r_xcount),
        S | IMM(1),                                             "SUBS    r_xcount, r_xcount, #1");
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "MOV     r_outword,r_outword,ROR #out_bpc");
    SUB(R(r_outshift), R(r_outshift),
        IMM(wp->BPC*2) | IMMROR(6),                             "SUB     r_outshift,r_outshift,#out_bpc:SHL:27");

    branch(ws, B | NE, L(plot_loop4),                           "BNE     plot_loop4");
    DEFINE_LABEL(plot_loop4a, "plot loop 4a - coz only one forward referance allowed")
    DEFINE_LABEL(plot_loop4b, "plot loop 4b - coz only one forward referance allowed")
    DEFINE_LABEL(plot_loop4c, "plot loop 4c - coz only one forward referance allowed")
}

/**************************************************************************
*                                                                         *
*    Bitblit: Overall construction of the X loop.                         *
*                                                                         *
**************************************************************************/

static void init_word_registers(asm_workspace *wp, workspace *ws)
/* Initialise inword, outword, maskinword from their respective pointers
 * and shift values.
 */
{
  comment(ws, "Load initial values of word registers");

  /* Set up inword */
  if (!PLOTMASK) /* PLOTMASK case handled below, because helped by setting up r_outword */
  {
    if (!SOURCE_32_BIT)
    {
      ins(ws, LDR(R(r_inword), R(r_inptr)) | OFFSET(0),         "LDR     r_inword,[r_inptr]              ; fetch first input pixels");
      MOV(R(r_pixel), OP2R(R(r_inshift)) | LSRI(27),            "MOV     r_pixel,r_inshift,LSR #27       ; get real shift distance");
      RSB(R(r_pixel), R(r_pixel), IMM(32),                      "RSB     r_pixel,r_pixel,#32             ; temporary use of r_pixel");
      MOV(R(r_inword), OP2R(R(r_inword)) | RORR(R(r_pixel)),    "MOV     r_inword,r_inword,ROR r_pixel   "
                                                              "; current input pixel now in least sig bit[s]");
    }
  }

  if (SOURCE_MASK) /* Set up maskinword */
  {
    if (SOURCE_TRICKYMASK || PLOTMASK)
    {
      ins(ws, LDR(R(r_maskinword), R(r_maskinptr)) | OFFSET(0), "LDR     r_maskinword,[r_maskinptr]        ; fetch first mask word");
      MOV(R(r_pixel), OP2R(R(r_maskinshift)) | LSRI(27),      "MOV     r_pixel,r_maskinshift,LSR #27     ; get real shift distance");
      RSB(R(r_pixel), R(r_pixel), IMM(32),                    "RSB     r_pixel,r_pixel,#32         ; mask shift");
    }
    else
      ins(ws, LDR(R(r_maskinword),
              R(r_inptr)) | INDEX(R(r_masko), 0),             "LDR     r_maskinword,[r_inptr,r_masko]    ; fetch first mask word");
    MOV(R(r_maskinword), OP2R(R(r_maskinword)) | RORR(R(r_pixel)),"MOV     r_maskinword,r_maskinword,ROR r_pixel "
                                                              "; current mask pixel now in least sig bit[s]");
  }

  if (!DEST_32_BIT) /* Set up outword */
  {
    if (ws->gcol == 0 && !SOURCE_MASK && !PLOTMASK && !wp->blending)
    {
      /* Faster in the inner loop, but the unneeded pixels must be cleared out first */
      MOV(R(r_pixel), S | OP2R(R(r_outshift)) | LSRI(27),     "MOVS    r_pixel,r_outshift,LSR #27      ; get real shift distance");
      ins(ws, LDR(R(r_outword), R(r_outptr)) | NE | OFFSET(0),  "LDRNE   r_outword,[r_outptr]            ; load up output word");
      MOV(R(r_outword), NE | OP2R(R(r_outword))
                      | LSLR(R(r_pixel)),                     "MOVNE   r_outword,r_outword,LSL r_pixel "
                                                              "; set untouched pixels to correct places, clear the others");
      MOV(R(r_outword), EQ | IMM(0),                          "MOVEQ   r_outword,#0                    ; if r_pixel=0, make them all clear");
    }
    else
    {
      ins(ws, LDR(R(r_outword), R(r_outptr)) | OFFSET(0),     "LDR     r_outword,[r_outptr]            ; load up output word");
      MOV(R(r_pixel), OP2R(R(r_outshift)) | LSRI(27),         "MOV     r_pixel,r_outshift,LSR #27      ; get real shift distance");
      RSB(R(r_pixel), R(r_pixel), IMM(32),                    "RSB     r_pixel,r_pixel,#32             ; temp use of r_pixel");
      MOV(R(r_outword), OP2R(R(r_outword)) | RORR(R(r_pixel)),"MOV     r_outword,r_outword,ROR r_pixel "
                                                              "; current output pixel now in least sig bit[s]");
      /* Set up inword from ECF pattern - uses r_pixel value */
      if (PLOTMASK)
      {
        ins(ws, LDR(R(r_inword), R(r_inptr))
              | INDEX(R(r_ecfindex), 0),                      "LDR     r_inword,[r_inptr,r_ecfindex]   ; get ECF pattern word");
        MOV(R(r_inword), OP2R(R(r_inword)) | RORR(R(r_pixel)),"MOV     r_inword,r_inword,ROR r_pixel  1 "
                                                              "; current ECF pixel now in least sig bit[s]");
        ADD(R(r_ecfindex), R(r_ecfindex),
              IMM(4),                                           "ADD     r_ecfindex,r_ecfindex,#4        ; to load EOR word 1");
        ins(ws, LDR(R(r_bgcolour), R(r_inptr))
              | INDEX(R(r_ecfindex), 0),                        "LDR     r_bgcolour,[r_inptr,r_ecfindex]   ;fetch next EOR word of ECF1");
        SUB(R(r_ecfindex), R(r_ecfindex),
              IMM(4),                                           "SUB     r_ecfindex,r_ecfindex,#4        ;blah1");
        MOV(R(r_bgcolour), OP2R(R(r_bgcolour)) | RORR(R(r_pixel)),"MOV     r_bgcolour,r_bgcolour,ROR r_pixel  1 ");
      }
    }
  }
}

static void loop_x(asm_workspace *wp, workspace *ws)
/* The variables are set up - perform the inner loop that processes a
 * single line. Fall out of the bottom of the loop when complete.
 */
{
  BOOL mask_possible;

  comment(ws, "The inner loop: iterating along a row of pixels.");
  if (x_block_move(wp, ws))
  {
    comment(ws, "Very simple inner loop - we use an existing block-move primitive");
    if(wp->CPUFlags & CPUFlag_BLX)
    {
      BLX(R(r_blockroutine),                                   "BLX     r_blockroutine                  ; block move");
    }                 
    else
    {
      MOV(R(lr), OP2R(R(pc)),                                  "MOV     lr,pc                           ; remember return address");
      MOV(R(pc), OP2R(R(r_blockroutine)),                      "MOV     pc,r_blockroutine               ; block move");
    }
    /* It would be a little bit more efficient to do state saving here rather than inside the routine,
     * and so only save registers that need to be saved - not a big saving, and only per-line.
     */
  }
  else
  {
    init_word_registers(wp, ws);

    if (simple_x_scale(wp, ws)) /* 1:1 scaling */
    {
      comment(ws, "1:1 scaling along x, so each source pixel is painted once");

#if 0
      align16(wp, ws);
      DEFINE_LABEL(loop_x_repeat, "Loop around for each source/dest pixel")
      mask_possible = fetch_pixel(wp, ws, &ws->labels.l_masked);
      translate_pixel(wp, ws);
      save_pixel(wp, ws);
      if (mask_possible) DEFINE_LABEL(l_masked, "This pixel masked out")
      fetch_pixel_inc(wp, ws);
      save_pixel_inc(wp, ws);
      SUB(R(r_xsize), R(r_xsize), S | IMM(1),                    "SUBS    r_xsize,r_xsize,#1");
      branch(ws, B | NE, L(loop_x_repeat),                       "BNE     loop_x_repeat");
#else

      /* We generate a loop that does two pixels at a time, only advancing pointers, counts, shifts
       * etc. every two pixels. There are two versions of this loop, one where the in and out shifts
       * are 'in phase' (ie initially both even or both odd), one where they are out of phase. There
       * is also some initial stuff to get the outshift to be even if necessary when entering either
       * of these, and some final stuff to patch up the end.
       */
      comment(ws, "Optimised 2-at-a-time loop");
      if (!DEST_32_BIT)
      {
        TST(R(r_outshift), IMM(wp->BPC*2) | IMMROR(6),           "TST     r_outshift,#out_bpc:SHL:27      ; start at odd or even pixel shift?");
        branch(ws, B | EQ, L(x_evenstart),                       "BEQ     x_evenstart                     ; B if even");
        comment(ws, "r_outshift an odd number of pixels - process just one of these");
        mask_possible = fetch_pixel(wp, ws, &ws->labels.x_oddmask);
        translate_pixel(wp, ws);
        save_pixel(wp, ws);
        if (mask_possible) DEFINE_LABEL(x_oddmask, "This pixel masked out")
        fetch_pixel_inc(wp, ws);
        save_pixel_inc(wp, ws);
        SUB(R(r_xsize), R(r_xsize), S | IMM(1),                  "SUBS    r_xsize,r_xsize,#1              ; count towards overall width");
        branch(ws, B | EQ, L(loop_x_exit),                       "BEQ     loop_x_exit                     ; check for just one pixel wide");
        DEFINE_LABEL(x_evenstart, "r_outshift is an even number of pixels")
      }
      if (!SOURCE_32_BIT)
      {
        TST(R(r_inshift), IMM(ws->in_bpc*2) | IMMROR(6),         "TST     r_inshift,#in_bpc:SHL:27        ; input at odd or even pixel shift?");
        branch(ws, B | NE, L(x_misaligned),                      "BNE     x_misaligned                    ; B if odd");
      }
      branch(ws, B, L(x_aligned_enter),                          "B       x_aligned_enter                 ; else, in phase with output - start loop");
      newline();

      align16(wp, ws);
      DEFINE_LABEL(x_aligned_loop, "The 2-at-a-time inner loop, aligned case")
      mask_possible = fetch_pixel(wp, ws, &ws->labels.x_alignmask1);
      translate_pixel(wp, ws);
      save_pixel(wp, ws);
      if (mask_possible) DEFINE_LABEL(x_alignmask1, "First pixel masked out")
      odither_inc(wp, ws, 0);
      mask_possible = fetch_pixel2(wp, ws, &ws->labels.x_alignmask2);
      translate_pixel(wp, ws);
      save_pixel2(wp, ws);
      if (mask_possible) DEFINE_LABEL(x_alignmask2, "Second pixel masked out")
      fetch_pixel_inc2(wp, ws);
      save_pixel_inc2(wp, ws);
      DEFINE_LABEL(x_aligned_enter, "Entering the aligned 2-at-a-time inner loop")
      SUB(R(r_xsize), R(r_xsize), S | IMM(2),                    "SUBS    r_xsize,r_xsize,#2              ; done 2 pixels");
      branch(ws, B | GE, L(x_aligned_loop),                      "BGE     x_aligned_loop                  ; loop until 0 or 1 left");
      if (!SOURCE_32_BIT)
      {
        branch(ws, B, L(x_2atatime_exit),                        "B       x_2atatime_exit                 ; final patchup code");
        newline();

        DEFINE_LABEL(x_misaligned, "The 2-at-a-time inner loop, misaligned case, entry sequence")
        /* A bit delicate - we have to prepare the input stream for an inc2 call,
         * by effectively winding it back by a pixel. We know this won't go back a word,
         * however, because r_inshift is an odd number of pixels.
         */
        comment(ws, "Wind input stream back by a pixel");
        if (SOURCE_32_BIT)
          SUB(R(r_inptr), R(r_inptr), IMM(4),                    "SUB     r_inptr,r_inptr,#4              ; wind back a pixel");
        else
        {
#ifdef ASMdoublepixel_bodge
          MOV(R(r_inword), OP2R(R(r_inword)) | LSLI(ws->in_bpp), "MOV     r_inword,r_inword,LSL #in_bpp   ; wind back a pixel");
          ADD(R(r_inshift), R(r_inshift),
              IMM(ws->in_bpp*2) | IMMROR(6),                     "ADD     r_inshift,r_inshift,#in_bpp:SHL:27");
#else
          MOV(R(r_inword), OP2R(R(r_inword)) | LSLI(ws->in_bpc), "MOV     r_inword,r_inword,LSL #in_bpc   ; wind back a pixel");
          ADD(R(r_inshift), R(r_inshift),
              IMM(ws->in_bpc*2) | IMMROR(6),                     "ADD     r_inshift,r_inshift,#in_bpc:SHL:27");
#endif
        }
        if (SOURCE_MASK)
        {
#ifdef ASMdoublepixel_bodge
          MOV(R(r_maskinword), OP2R(R(r_maskinword))
                             | LSLI(ws->mask_bpp),               "MOV     r_maskinword,r_maskinword,LSL #mask_bpp");
          if (SOURCE_TRICKYMASK)
          {
            ADD(R(r_maskinshift), R(r_maskinshift),
                IMM(ws->mask_bpp*2) | IMMROR(6),                 "ADD     r_maskinshift,r_maskinshift,#mask_bpp:SHL:27");
          }
#else
          MOV(R(r_maskinword), OP2R(R(r_maskinword))
                             | LSLI(ws->mask_bpc),               "MOV     r_maskinword,r_maskinword,LSL #mask_bpc");
          if (SOURCE_TRICKYMASK)
          {
            ADD(R(r_maskinshift), R(r_maskinshift),
                IMM(ws->mask_bpc*2) | IMMROR(6),                 "ADD     r_maskinshift,r_maskinshift,#mask_bpc:SHL:27");
          }
#endif
        }
        branch(ws, B, L(x_misaligned_enter),                     "B       x_misaligned_enter              ; start misaligned loop");
        align16(wp, ws);
        DEFINE_LABEL(x_misaligned_loop, "The 2-at-a-time inner loop, misaligned case")
        mask_possible = fetch_pixel2(wp, ws, &ws->labels.x_misalignmask1);
        translate_pixel(wp, ws);
        save_pixel(wp, ws);
        if (mask_possible) DEFINE_LABEL(x_misalignmask1, "A pixel masked out")
        fetch_pixel_inc2(wp, ws);
        odither_inc(wp, ws, 0);
        mask_possible = fetch_pixel(wp, ws, &ws->labels.x_misalignmask2);
        translate_pixel(wp, ws);
        save_pixel2(wp, ws);
        if (mask_possible) DEFINE_LABEL(x_misalignmask2, "Another pixel masked out")
        save_pixel_inc2(wp, ws);
        DEFINE_LABEL(x_misaligned_enter, "Entering the misaligned 2-at-a-time inner loop")
        SUB(R(r_xsize), R(r_xsize), S | IMM(2),                  "SUBS    r_xsize,r_xsize,#2              ; count towards overall size");
        branch(ws, B | GE, L(x_misaligned_loop),                 "BGE     x_misaligned_loop               ; and loop until done");
        fetch_pixel_inc(wp, ws);
        newline();

        DEFINE_LABEL(x_2atatime_exit, "Final patchup for 2-at-a-time inner loop")
      }
      else
        newline();
      ADD(R(r_xsize), R(r_xsize), S | IMM(2),                    "ADDS    r_xsize,r_xsize,#2              ; up to 0 or 1");
      branch(ws, B | EQ, L(loop_x_exit1),                        "BEQ     loop_x_exit1                    ; No last pixel to be done\n");
      mask_possible = fetch_pixel(wp, ws, &ws->labels.x_lastmask);
      translate_pixel(wp, ws);
      save_pixel(wp, ws);
      if (mask_possible) DEFINE_LABEL(x_lastmask, "Last pixel masked out")
      fetch_pixel_inc(wp, ws);
      save_pixel_inc(wp, ws);

      DEFINE_LABEL(                                     loop_x_exit1, "End of input pixel line (1)")
#endif
    }
    else
    {
      comment(ws, "Control of scaling along x");
      if ((ws->odither || wp->blending) && wp->save_xadd - wp->save_xdiv > wp->save_xdiv)
      {
        /* If dithering/blending and scaling we have to be very careful about where we do fetch_pixel_inc, because when replicating
         * a pixel we must repeatedly fetch_pixel it.
         */
        SUB_A(r_xcount, wp->save_xadd)
        DEFINE_LABEL(                                       loop_x_repeat, "Loop around for each source pixel (ordered dither / blending)")
        ADD_A(r_xcount, wp->save_xadd)  /*(GPS)*/

        mask_possible = fetch_pixel(wp, ws, &ws->labels.l_masked);
        SUBS_A(r_xcount, wp->save_xdiv)  /* Stop dither from printing 1 too many pixels... (GPS) */
        DEFINE_LABEL(                                       loop_put_pixel_repeat, "Repeatedly paint and ordered-dither/blend a source pixel");
        translate_pixel(wp, ws);
        save_pixel(wp, ws);
        save_pixel_inc(wp, ws);
        SUB(R(r_xsize), R(r_xsize), S | IMM(1),                    "SUBS    r_xsize,r_xsize,#1              ; count output ordered dither / blended pixels");
        branch(ws, B | EQ, L(loop_x_exit),                         "BEQ     loop_x_exit                     ; painted enough pixels");
        /* We must not paint the same pixel repeatedly - we must reextract and retranslate it, otherwise
         * the dithering on scaled up pixels will not occur.
         */
        fetch_pixel_unmasked(wp, ws); /* reextract the pixel into r_pixel */
        SUBS_A(r_xcount, wp->save_xdiv)  /* Decrement count (GPS) */
        branch(ws, B | PL, L(loop_put_pixel_repeat),               "BPL     loop_put_pixel_repeat           ; recalculate and repaint");
        fetch_pixel_inc(wp, ws); /* moved by (GPS) */
        branch(ws, B, L(loop_x_repeat),                            "B       loop_x_repeat                   ; next input pixel");
      }
      else
      {
        if ( !PLOTMASK && (wp->save_xmag % wp->save_xdiv) == 0 && ((wp->save_xmag / wp->save_xdiv) > 4) && ws->gcol == 0 && !wp->blending)
                 /* do optimised code */
        {
          register int toskip = wp->save_xmag / wp->save_xdiv;

          dprintf(("", "in optimised scale\nxmag = %d, xdiv = %d, xmag mod xdiv = %d\n", wp->save_xmag, wp->save_xdiv, wp->save_xmag % wp->save_xdiv));
          SUB_A(r_xcount, toskip)
          DEFINE_LABEL(                                       loop_x_repeat, "3Loop around for each source pixel")
          TEQ(R(r_xsize), IMM(0),                                       "3TEQ     r_xsize, #0");
          DEFINE_LABEL(loop_x_exitskip,          "3Kludge to avoid multiple forward references");
          branch(ws, B | EQ, L(loop_x_exit),                      "3BEQ     loop_x_exit");
          ADD_A(r_xcount, toskip)
          mask_possible = fetch_pixel(wp, ws, &ws->labels.l_masked);
          translate_pixel(wp, ws); /* If we're about the discard the pixel this is in fact wasted work - we could reorganise
                                    * this whole loop to improve that situation, but it doesn't really seem worthwhile, the gain
                                    * is not enormous.
                                    */
          fetch_pixel_inc(wp, ws);

          comment(ws, "3calculating number of times to plot pixel 1");
          MOV(R(r_temp1), OP2R(R(r_xsize)),                            "3MOV     r_temp1, r_xsize               ; store r_xsize");
          SUB(R(r_xsize), R(r_xsize), S | OP2R(R(r_xcount)),            "3SUBS    r_xsize, r_xsize, r_xcount  ; count output pixels");
          MOV(R(r_xsize), MI | IMM(0),                                  "3MOVMI   r_xsize, #0                                          ");
          MOV(R(r_xcount), MI | OP2R(R(r_temp1)),                       "3MOVMI   r_xcount, r_temp1                                          ");

          if (!DEST_32_BIT)
          {
            MOV(R(r_temp1), S | OP2R(R(r_outshift)) | LSRI(27),           "3MOVS    r_temp1, r_outshift, LSR #27");
            MOV(R(r_temp1), EQ | IMM(32),                                 "3MOVEQ   r_temp1, #32                    ; 0 in r_outshift => 32 bits left");
            if (!DEST_1_BIT)
              MOV(R(r_temp1), OP2R(R(r_temp1)) | LSRI(wp->Log2bpc),       "3MOV     r_temp1, r_temp1, LSR #out_log2bpc");
            CMP(R(r_xcount), OP2R(R(r_temp1)),                            "3CMP     r_xcount, r_temp1");
            branch(ws, B + LT, L(loop2),                                  "3BLT     loop2                   ; end of this masked input pixel");
          }

          plot_current_output_words(wp, ws, toskip);

          if (DEST_32_BIT)
          {
            branch(ws, B, L(loop_x_repeat),                          "11B     loop_x_repeat                   ; end of this masked input pixel");
          }
          else
          {
            TEQ(R(r_xcount), IMM(0),                                      "1TEQ     r_xcount, #0");
            branch(ws, B + EQ, L(loop_x_repeat),                         "1BEQ     loop_x_repeat                   ; end of this masked input pixel");

            DEFINE_LABEL(loop2, "Last word to plot")
            plot_some_pixels(wp, ws);
            branch(ws, B, L(loop_x_repeat),                              "1B       loop_x_repeat                   ; end of this masked input pixel");
          }

        }
        else
        {
          /* >>> There's not all that much point in this being separate from the odither case - could really
           * abandon this one and use the dithering one all the time, with tiny variants. Not done.
           */
          SUB_A(r_xcount, wp->save_xadd)
          DEFINE_LABEL(                                       loop_x_repeat, "Loop around for each source pixel")
          ADD_A(r_xcount, wp->save_xadd)
          mask_possible = fetch_pixel(wp, ws, &ws->labels.l_masked);
          translate_pixel(wp, ws); /* If we're about the discard the pixel this is in fact wasted work - we could reorganise
                                    * this whole loop to improve that situation, but it doesn't really seem worthwhile, the gain
                                    * is not enormous.
                                    */
          fetch_pixel_inc(wp, ws);
          DEFINE_LABEL(loop_put_pixel_repeat, "Loop around to repeatedly paint a source pixel");
          SUBS_A(r_xcount, wp->save_xdiv)
          branch(ws, B | MI, L(loop_x_repeat),                       "BMI     loop_x_repeat                   ; discard this pixel");
          save_pixel(wp, ws);
          save_pixel_inc(wp, ws);
          SUB(R(r_xsize), R(r_xsize), S | IMM(1),                    "SUBS    r_xsize,r_xsize,#1              ; count for each output pixel");
          branch(ws, B | NE, L(loop_put_pixel_repeat),               "BNE     loop_put_pixel_repeat");
          branch(ws, B, L(loop_x_exit),                              "B       loop_x_exit              ; skip code for masked pixels");/* moved from next if (GPS) */
        }
      }
      if (mask_possible)
      {
        DEFINE_LABEL(l_masked, "This source pixel masked out")
        if (!PLOTMASK && (wp->save_xmag % wp->save_xdiv) == 0 && ((wp->save_xmag / wp->save_xdiv) > 4) && ws->gcol == 0 && !wp->blending)
        {
#if 1
          fetch_pixel_inc(wp, ws);

          comment(ws, "calculating number of times to plot pixel");
          MOV(R(r_temp1), OP2R(R(r_xsize)),                             "@@MOV     r_xtemp1, r_xsize               ; store r_xsize");
          SUB(R(r_xsize), R(r_xsize), S | OP2R(R(r_xcount)),             "@@SUBS    r_xsize, r_xsize, r_xcount  ; count output pixels");
          MOV(R(r_xsize), MI | IMM(0),                                  "@@MOVMI   r_xsize, #0                                          ");
          MOV(R(r_xcount), MI | OP2R(R(r_temp1)),                       "@@MOVMI   r_xcount, r_temp1                                          ");

          if (!DEST_32_BIT)
          {
            MOV(R(r_temp1), S | OP2R(R(r_outshift)) | LSRI(27),           "@@@@MOVS    r_temp1, r_outshift, LSR #27");
            MOV(R(r_temp1), EQ | IMM(32),                              "@@@@MOVEQ   r_temp1, #32                    ; 0 in r_outshift => 32 bits left");
            if (!DEST_1_BIT)
              MOV(R(r_temp1), OP2R(R(r_temp1)) | LSRI(wp->Log2bpc),       "@@@@MOV     r_temp1, r_temp1, LSR #log2bpc");
            CMP(R(r_xcount), OP2R(R(r_temp1)),                            "@@@@CMP     r_xcount, r_temp1");
            branch(ws, B + LT, L(loop1),                                  "@@@@BLT     loop1                   ; end of this masked input pixel");
          }

          skip_current_output_words(wp, ws);

          if (DEST_32_BIT)
          {
            branch(ws, B, L(loop_x_repeat),                         "1@@B     loop_x_repeat                   ; end of this masked input pixel");
          }
          else
          {
            TEQ(R(r_xcount), IMM(0),                                     "1@@TEQ     r_xcount, #0");
            branch(ws, B + EQ, L(loop_x_repeat),                        "1@@BEQ     loop_x_repeat                   ; end of this masked input pixel");
            DEFINE_LABEL(loop1, "Last word to skip")
            skip_some_pixels(wp, ws);

            branch(ws, B, L(loop_x_repeat),                            "1@@@@B       loop_x_repeat                   ; end of this masked input pixel");
          }
#else
          int loop;

          fetch_pixel_inc(wp, ws);
          for (loop = 0;loop < (wp->save_xmag / wp->save_xdiv);loop++)
          {
            save_pixel_inc(wp, ws);
            SUB(R(r_xsize), R(r_xsize), S | IMM(1),                    "SUBS    r_xsize,r_xsize,#1              ; count output pixels");
            branch(ws, B | EQ, L(loop_x_exitskip),              "BEQ     loop_x_exitskip");
          }
          branch(ws, B, L(loop_x_repeat),                       "B       loop_x_repeat                   ; end of this masked input pixel");
#endif
        }
        else
        {
          fetch_pixel_inc(wp, ws);
          DEFINE_LABEL(loop_put_masked_repeat, "Loop around to skip over dest pixels");
          SUBS_A(r_xcount, wp->save_xdiv)
          branch(ws, B | MI, L(loop_x_repeat),                       "BMI     loop_x_repeat                   ; end of this masked input pixel");
          save_pixel_inc(wp, ws);
          SUB(R(r_xsize), R(r_xsize), S | IMM(1),                    "SUBS    r_xsize,r_xsize,#1              ; count output pixels");
          branch(ws, B | NE, L(loop_put_masked_repeat),              "BNE     loop_put_masked_repeat");
        }
      }
    }
    DEFINE_LABEL(                                     loop_x_exit, "End of input pixel line")
    newline();

    if (!DEST_32_BIT)
    {
      comment(ws, "End of x loop - ensure any contents of r_outword are written out.");
      MOV(R(r_outshift), S | OP2R(R(r_outshift)) | LSRI(27),     "MOVS    r_outshift,r_outshift,LSR #27   ; get real output shift distance");
      MOV(R(r_outshift), EQ | IMM(32),                           "MOVEQ   r_outshift,#32                  "
                                                                 "; number of useful new bits in r_outword");
      if (ws->gcol == 0 && !SOURCE_MASK)
      {
        /* If setting pixels we must pick up the word we're about to
         * partially overwrite, and combine the new and old pixels.
         */
        comment(ws, "The top 32-r_outshift bits of r_outword are new pixels.");
        MOV(R(r_outword), OP2R(R(r_outword)) | LSRR(R(r_outshift)),"MOV     r_outword,r_outword,LSR r_outshift ; get new pixels in correct place");
        ins(ws, LDR(R(r_pixel), R(r_outptr)) | OFFSET(0),        "LDR     r_pixel,[r_outptr]              ; temporary use of r_pixel");
        RSB(R(r_outshift), R(r_outshift), IMM(32),               "RSB     r_outshift,r_outshift,#32");
        MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRR(R(r_outshift)),  "MOV     r_pixel,r_pixel,LSR r_outshift  ; shift to clear out old pixels");
        ORR(R(r_outword), R(r_outword),
              OP2R(R(r_pixel)) | LSLR(R(r_outshift)),            "ORR     r_outword,r_outword,r_pixel, LSL r_outshift ; combine old and new");
        ins(ws, STR(R(r_outword), R(r_outptr)) | OFFSET(0),      "STR     r_outword,[r_outptr]            ; store updated word");
      }
      else
      {
        MOV(R(r_outword), OP2R(R(r_outword)) | RORR(R(r_outshift)),"MOV     r_outword,r_outword,ROR r_outshift");
        ins(ws, STR(R(r_outword), R(r_outptr)) | OFFSET(0),        "STR     r_outword,[r_outptr]");
      }
    }
  }
}

/**************************************************************************
*                                                                         *
*    Bitblit: Overall construction of the Y loop.                         *
*                                                                         *
**************************************************************************/

static void loop_y(asm_workspace *wp, workspace *ws, j_decompress_ptr cinfo)
/* Overall control of the code and outer loop */
{
#ifdef DEBUG
  char a[256];
  char saveregs[256];
#endif

  init_useful_constants(wp, ws);

  /* Setting up ordered dither, if required */
  if (ws->odither)
  {
    dprintf(("", "in dither_truecolour = %x\n", wp->dither_truecolour));
    comment(ws, "Ordered dither being used");
    /* If not 0 then ws->odither is the number of bits - 1 being truncated from 8-bit source colour values */
    if(wp->Log2bpp > 3)
    {
      /* Use the number of blue bits in the output as our guide */
      ws->odither = 7-pixelformat_info(ws->out_pixelformat)->bits[0];
    }
    else
    {
      /* dithering down to 1/2/4/8 bit. */
      if (wp->Log2bpp == 3) /* 8bpp */
      {
        if (wp->is_it_jpeg && cinfo->jpeg_color_space == JCS_GRAYSCALE)
          ws->odither = 3; /* dither assuming 4 bits of grey represented */
        else
          ws->odither = 4; /* seems to work better for colour than 3, which is what you might expect if
                            * you were assuming 4 bits of colour per gun. In other words, the tint is NOT
                            * effective enough at representing the next two bits of colour output!
                            * If the source is known to be greyscale then 3 is a better value.
                            */
      }
      else
        ws->odither = 6 - wp->Log2bpp; /* 6, 5 or 4 for 2, 4, or 16 colour output (2, 4 or 8 grey level) */
    }
    dprintf(("", "%t20.odither_eorvalue * 1:SHL:(24+%i) %t68; value to EOR into r_oditheradd each pixel", ws->odither));
  }
    dprintf(("", "out dither_truecolour = %x\n", wp->dither_truecolour));

  newline();
  ins(ws, PUSH | 0x5fff,                                    "STMDB   sp!,{r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,lr} ; save entry registers");
  newline();

  comment(ws, "Register declarations");
  ptrs_rn(wp, ws);
  xloop_rn(wp, ws);
  yloop_rn(wp, ws);

  allocate_registers(wp, ws);
  reserve_regstackframe(wp, ws);
  newline();

  comment(ws, "Load up initial values of per-pixel variables");
  begin_init_bank(wp, ws, REGFLAG_PERPIXEL);
  blendimpl_init(wp, ws);
  if((ws->regnames.r_translucency.regno != -1) && (ws->regnames.r_translucency.regno != 12))
  {
    LDR_WP(r_translucency,trns_flags2);
    if(wp->CPUFlags & CPUFlag_T2)
    {
      UBFX(R(r_translucency),R(r_translucency),4,8,0,           "UBFX    r_translucency,r_translucency,#4,#8");
    }
    else
    {
      MOV(R(r_translucency),OP2R(R(r_translucency)) | LSRI(4),  "MOV     r_translucency,r_translucency,LSR #4");
      AND(R(r_translucency),R(r_translucency),IMM(255),         "AND     r_translucency,r_translucency,#255");
    }
    RSB(R(r_translucency),R(r_translucency),IMM(1) | IMMROR(24),"RSB     r_translucency,r_translucency,#256 ; Convert translucency to alpha");
  }
  per_pixel_init(wp, ws);
  end_init_bank(wp, ws, REGFLAG_PERPIXEL);
  newline();

  comment(ws, "Load up initial values of x-loop variables");
  begin_init_bank(wp, ws, REGFLAG_XLOOP);
  fetch_pixel_init(wp, ws);
  save_pixel_init(wp, ws);
  xloop_init(wp, ws);
  end_init_bank(wp, ws, REGFLAG_XLOOP);
  newline();

  comment(ws, "Load up initial values of y-loop variables");
  begin_init_bank(wp, ws, REGFLAG_YLOOP);
  yloop_init(wp, ws);
  end_init_bank(wp, ws, REGFLAG_YLOOP);

  if (!simple_y_scale(wp, ws)) /* If not simple scaling, might not paint the first row */
    branch(ws, B, L(y_loop_enter),                          "B       y_loop_enter                    ; enter the main loop");

  /* Top of the y-loop */
  newline();
  DEFINE_LABEL(y_loop,                        "Loop around for each row")

  switch_bank(wp, ws, REGFLAG_YLOOP,REGFLAG_XLOOP);
  newline();

  /* Preserve some loop regs */
  int save_mask = 0;
  regname *r;
  FOR_EACH_REGISTER_NAME(r)
  {
    if(r->flags & REGFLAG_XLOOPVAR)
    {
      assert((r->regno & 0xff) == r->regno, ERROR_FATAL);
      save_mask |= 1<<r->regno;
    }
  }
#ifdef DEBUG
  ldm_reg_list(ws, saveregs, save_mask, FALSE);
  dsprintf((a, "STMDB   sp!,{%s}",saveregs));
#endif  
  ins(ws, PUSH | save_mask, a);
  ws->regframeoffset += countbits(save_mask)<<2;

  if (wp->is_it_jpeg)
  {
    comment(ws, "r_inptr is the source y coord for JPEG data: convert to data pointer");
    comment(ws, "fetchroutine uses r_inptr(=r0), r12. On output r_inptr=source result pointer");
    if(wp->CPUFlags & CPUFlag_BLX)
    {
      BLX(R(r_fetchroutine),                                  "BLX     r_fetchroutine                  ; get source address");
    }
    else
    {
      MOV(R(lr), OP2R(R(pc)),                                 "MOV     lr,pc                           ; remember return address from fetchroutine");
      MOV(R(pc), OP2R(R(r_fetchroutine)),                     "MOV     pc,r_fetchroutine               ; get source address");
    }
    LDR_WP_C(lr, in_x, "returned value is for base of line - add initial offset")
    if (wp->save_inlog2bpp < 5)
    {
      if (wp->save_inlog2bpp == 3)
        ADD(R(r_inptr),R(r_inptr),OP2R(R(lr)),                "ADD     r_inptr,r_inptr,lr              ; add in_x as byte offset");
      else
        ADD(R(r_inptr),R(r_inptr),OP2R(R(lr)) | LSLI(1),      "ADD     r_inptr,r_inptr,lr,LSL#1        ; add in_x as halfword offset");
      BIC(R(r_inptr),R(r_inptr),IMM(3),                     "BIC     r_inptr,r_inptr,#3              ; r_inptr is a word pointer");
    }
    else
      ADD(R(r_inptr),R(r_inptr),OP2R(R(lr)) | LSLI(2),      "ADD     r_inptr,r_inptr,lr,LSL#2        ; add in_x as word offset");
  }

  /* Generate the inner loop. */
  loop_x(wp, ws);

  /* Restore regs */
  dsprintf((a, "LDMIA   sp!,{%s}",saveregs));
  ins(ws, POP | save_mask, a);
  ws->regframeoffset -= countbits(save_mask)<<2;

  /* Suitable register 'bank' swapping. */
  switch_bank(wp, ws, REGFLAG_XLOOP,REGFLAG_YLOOP);

  if (PLOTMASK)
  {
    comment(ws,                                      "Advance ECF pointer");
    LDR_WP(r_pixel, save_ecflimit);                        /*LDR     r_pixel,save_ecflimit*/
    CMP(R(r_inptr), OP2R(R(r_pixel)),                       "CMP     r_inptr,r_pixel                 ; check for bottom of ECF");
    ADD(R(r_inptr), R(r_inptr), EQ | IMM(64),               "ADDEQ   r_inptr,r_inptr,#64             ; and if reached, reset to top");
    SUB(R(r_inptr), R(r_inptr), IMM(8),                     "SUB     r_inptr,r_inptr,#8              ; points to base of current row of ECF");
  }

  /* Control of scaling in the y direction */
  if (simple_y_scale(wp, ws))
  {
    comment(ws,                                      "1:1 scaling in y direction - each source row appears once");
    if (!PLOTMASK)
    {
      if (wp->is_it_jpeg)
        ADD(R(r_inptr), R(r_inptr), IMM(1),                 "ADD     r_inptr,r_inptr,#1               ; inc y coord of input JPEG data");
      else
        SUB(R(r_inptr), R(r_inptr), OP2R(R(r_inoffset)),    "SUB     r_inptr,r_inptr,r_inoffset");
    }
    SUB_A(r_outptr,wp->save_outoffset)                     /*SUB     r_outptr,r_outptr,#outoffset*/
    odither_inc(wp, ws, 1); /* advance to next coord */
    odither_inc(wp, ws, 0); /* ensure X coord phase alternates on alternate lines */
    if (SOURCE_TRICKYMASK || PLOTMASK)
      SUB(R(r_maskinptr), R(r_maskinptr),
          OP2R(R(r_maskinoffset)),                          "SUB     r_maskinptr,r_maskinptr,r_maskinoffset");
    SUB(R(r_ysize), R(r_ysize), S | IMM(1),                 "SUBS    r_ysize,r_ysize,#1              ; decrement output pixel size");
    branch(ws, B | GT, L(y_loop),                           "BGT     y_loop");
  }
  else
  {
    SUB(R(r_ysize), R(r_ysize), S | IMM(1),                 "SUBS    r_ysize,r_ysize,#1");
    branch(ws, B | LE, L(y_loop_exit),                      "BLE     y_loop_exit");
    SUB_A(r_outptr,wp->save_outoffset)                     /*SUB     r_outptr,r_outptr,#outoffset*/
    odither_inc(wp, ws, 1);
    odither_inc(wp, ws, 0);

    comment(ws,                                      "Control of scaling in y direction");
    DEFINE_LABEL(                                    y_loop_enter,  "Initial entry into the loop")
    SUBS_A(r_ycount, wp->save_ydiv)                        /*SUBS    r_ycount,r_ycount,#ydiv*/
    branch(ws, B | PL, L(y_loop),                           "BPL     y_loop                          ; if count>=0 then B else next source row");
    if (!PLOTMASK)
    {
      if (wp->is_it_jpeg)
        ADD(R(r_inptr), R(r_inptr), IMM(1),                 "ADD     r_inptr,r_inptr,#1              ; inc y coord of source JPEG data");
      else
        SUB(R(r_inptr), R(r_inptr), OP2R(R(r_inoffset)),    "SUB     r_inptr,r_inptr,r_inoffset      ; next source row");
    }
    if (SOURCE_TRICKYMASK || PLOTMASK)
      SUB(R(r_maskinptr), R(r_maskinptr),
          OP2R(R(r_maskinoffset)),                          "SUB     r_maskinptr,r_maskinptr,r_maskinoffset ; advance input mask pointer");
    ADD_A(r_ycount, wp->save_ydiv + wp->save_yadd)         /*ADD     r_ycount,r_ycount,#(ydiv+yadd)*/
    branch(ws, B, L(y_loop_enter),                          "B       y_loop_enter                    ; reenter the main loop");
    DEFINE_LABEL(y_loop_exit,                  "Exit from y loop")
  }
  newline();
  comment(ws, "Discard workspace, restore registers, and exit");

  discard_regstackframe(wp, ws);

  ins(ws, POP | 0x5fff,                                     "LDMIA   sp!,{r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,lr} ; restore, exit");

  MOV(R(pc), OP2R(R(lr)),         "MOV   pc, lr");
}

/**************************************************************************
*                                                                         *
*    Bitblit: The main compiler entry points.                             *
*                                                                         *
**************************************************************************/

static blitter find_or_compile_code(asm_workspace *wp, workspace *ws, j_decompress_ptr cinfo)
/* Based on the workspace variables look through existing compiled buffers for an existing match */
{
  code_buffer *p;
  int key_word;

  key_word = get_key_word(wp,ws);

#ifdef ASMjpeg
  if (wp->is_it_jpeg) key_word |= 1<<27;
  if (wp->is_it_jpeg && cinfo->jpeg_color_space == JCS_GRAYSCALE) key_word |= 1<<28;
#endif
  assert(!wp->cal_table, ERROR_FATAL); /* Never set by assembler! */
#if 0
  if (wp->cal_table)
  {
    key_word |= 1<<27;
    if (ws->cal_table_simple) key_word |= 1<<26;
    if (wp->cal_table->tablecount == 3) key_word |= 1<<27;
  }
#endif
#ifdef ASMjpeg
  if (wp->is_it_jpeg && (wp->dither_truecolour & 1)) key_word |= 1<<29;
  if (wp->is_it_jpeg && (wp->dither_truecolour & 2)) key_word |= 1<<30;
#endif
  if (  !PLOTMASK                        /* if plotting sprite */
     && wp->save_inlog2bpp >= 4          /* from true colour source */
     && (wp->dither_truecolour & 1)      /* and dithering requested */
     && (
         (wp->Log2bpp < wp->save_inlog2bpp) /* and losing resolution */
         || ((wp->Log2bpp == wp->save_inlog2bpp) /* or same resolution */
             && wp->blending                     /* and blending */
             && (wp->Log2bpp < 5)                /* and not 32bpp output */
            )
        )
     && !(wp->is_it_jpeg && (wp->dither_truecolour & 2)) /* And not JPEG error diffused dither */
     )
  {
    ws->odither = 1; /* Flag that ordered dithering is required */
    key_word |= 1<<31; /* And flag this routine as containing dither code */
  }
  dprintf(("", "Searching for compiled code for key_word=%x, scale=%i:%i,%i:%i outoffset=%x.\n",
    key_word, wp->save_xadd - wp->save_xdiv, wp->save_xdiv, wp->save_yadd, wp->save_ydiv, wp->save_outoffset));
  dprintf(("", "simple_x_scale=%s x_block_move=%s jpeg=%s calibration table=0x%x dither_truecolour=%i\n"
       , whether(simple_x_scale(wp, ws))
       , whether(x_block_move(wp, ws))
       , whether(wp->is_it_jpeg)
       , wp->cal_table
       , wp->dither_truecolour));
  FOR_EACH_BUFFER(p)
    if (  p->key_word == key_word
       && p->xadd == wp->save_xadd
       && p->xdiv == wp->save_xdiv
       && p->yadd == wp->save_yadd
       && p->ydiv == wp->save_ydiv
       && p->outoffset == wp->save_outoffset
       )
     {
       dprintf(("", "Found existing compiled code in buffer %x.\n", p));

       return (blitter)p->code;
     }
  p = &ws->buffers[ws->build_buffer];
  p->key_word = -1; /* Not set unless we complete the compilation - see below */
  p->xadd = wp->save_xadd;
  p->xdiv = wp->save_xdiv;
  p->yadd = wp->save_yadd;
  p->ydiv = wp->save_ydiv;
  p->outoffset = wp->save_outoffset;
  dprintf(("", "Compiler initialised for buffer at %x.\n", p));
  compile_buffer_init(wp, ws);

  /* Now we actually do the compile */
  loop_y(wp, ws, cinfo);

  compile_buffer_done(ws);
  p->key_word = key_word;

  /* Just did some dynamic code generation so flush the I cache */
  _swix(OS_SynchroniseCodeAreas, _IN(0) | _IN(1) | _IN(2), 1,
        (int)ws->compile_base, (int)ws->compile_base + ((BUFSIZE - 1 /* Inclusive */) * sizeof(int)));

  return (blitter)ws->compile_base;
}

blitter putscaled_compiler(asm_workspace *wp, workspace *ws, workspace *ws_end, int gcol)
/* Main entrypoint from the assembler */
{
  j_decompress_ptr cinfo = NULL;
  int                 i, j;
  blitter             result;

  /* Check that the assembler has an adequate opinion of our workspace needs. */
  dprintf(("", "wp=%x ws=%x ws_end=%x.\n", wp, ws, ws_end));
  dprintf(("", "Size of assembler workspace: %i.\n", ((char*)ws) - ((char*)wp)));
  dprintf(("", "Size of C workspace: %i. (needed: %i.)\n", ((char*)ws_end) - ((char*)ws), sizeof(workspace)));
  assert(ws_end > ws, ERROR_FATAL);
  assert((((char*)ws_end)-((char*)ws)) >= sizeof(workspace), ERROR_FATAL);
  check_workspace(ws);
#ifdef DEBUG
  dump_asm_workspace(wp);
#endif  

  ws->gcol = gcol & 7;
  if(!(gcol & 8))
  {
    ws->masktype = MaskType_None;
  }
  else if(wp->save_mode & 0x80000000)
  {
    ws->masktype = MaskType_8bpp;
  }
  else if(wp->save_mode & (15<<27))
  {
    ws->masktype = MaskType_1bpp;
  }
  else
  {
    ws->masktype = MaskType_Old;
  }
  ws->odither = FALSE; /* Set more carefully later. */
  dprintf(("", "gcol=%i (& 7 = %i)       %t32. GCOL action - 0 for plot, 1..7 for various others.\n", gcol, gcol & 7));
  dprintf(("", "masktype=%i              %t32. Mask type - 0=none, 1=old, 2=1bpp, 3=8bpp alpha.\n", ws->masktype));

#ifdef ASMjpeg
  if (wp->is_it_jpeg)
  {
    sprite_header *s = wp->save_sprite;
    int  *compress_id_word = (int*)((char*) s + s->image); /* The first word of the sprite data */
    const JOCTET *jpeg_data;
    int   jpeg_data_size, jpeg_ws_size;
    int   opt, err, xmax;
    
    assert(compress_id_word[0] == -1, ERROR_BAD_JPEG);
    dprintf(("", "This JPEG sprite was constructed by PutJPEGScaled\n"));
    jpeg_data = (const JOCTET *)compress_id_word[1];
    jpeg_data_size = compress_id_word[2];
    jpeg_ws_size = compress_id_word[3];
    check_jpeg_workspace(wp, jpeg_ws_size);
    cinfo = wp->jpeg_info_ptr;

    assert(wp->save_inlog2bpp == 5, ERROR_FATAL);          /* 32bpp source */
    assert(!SOURCE_MASK, ERROR_FATAL);                     /* no mask */
    dprintf(("", "JPEG, initial source coords are %i,%i.\n", wp->in_x, wp->in_y));
    if (((wp->save_mode >> 27) == 0) && (wp->TTRType != TTRType_ColourMap))
    {
      /* Old-style mode - make sure no translation table present. */
      wp->ColourTTR = 0;                                   /* >>>> mainly for JPEG on RO3 */
      wp->TTRType = TTRType_None;                          /* >>>> mainly for JPEG on RO3 */
    }

    /* Deduce the decompression options */
    opt = jpeg_decompressor_opts(cinfo, wp);
    
    /* Reverse scaling calculation */ 
    xmax = wp->in_x + 2 + (wp->save_xsize * wp->save_xdiv) / (wp->save_xadd - wp->save_xdiv);
    if (xmax < 0) xmax = s->width; /* set safe xmax if reverse scale calculation overflowed */

    /* Initialise the decompressor */
    err = jpeg_scan_file(cinfo, jpeg_data, jpeg_data_size, wp->in_x, xmax, -1, -1, opt);
    assert(err == 0, ERROR_BAD_JPEG);

    /* Check the decompressor agreed with proposed output options */
    if (cinfo->error_argument & (jopt_OUTBPP_8DITHER | jopt_OUTBPP_8YUV | jopt_OUTBPP_8GREY)) /* we asked for it, and we got it - 8bpp output pixels */
    {
      dprintf(("", "actually doing new shiny 8BPP plotting technique\n"));
      assert(wp->TTRType != TTRType_ColourMap, ERROR_FATAL); /* Colour mapping should have asked for 32bpp output */
      wp->save_inlog2bpp = wp->save_inlog2bpc = 3;
      wp->ColourTTR = 0;
      wp->TTRType = TTRType_None;
    }
    else
    {
      if (cinfo->error_argument & jopt_OUTBPP_16) /* we asked for it, and we got it - 16bpp output pixels */
      {
        wp->save_inlog2bpp = wp->save_inlog2bpc = 4;
      }
    }

    /* If error diffusion isn't supported, clear the flag so that we'll fall back to ordered dither */
    if(!(cinfo->options & jopt_DIFFUSE))
      wp->dither_truecolour &= ~2;
  }
#endif

  ws->out_pixelformat = compute_pixelformat(wp->ncolour,wp->modeflags,wp->Log2bpp);

#ifdef ASMjpeg
  if (wp->is_it_jpeg)
  {
    /* Work out what format we're being given
       This is deduced by following the same logic in jpeg_find_line */
    if(cinfo->options & jopt_DIFFUSE)
    {
      /* Error diffusion means we should have data in either an 8bpp or 32bpp container, and that data will be 8bpp (or lower) palette indices matching the required output format */
      ws->in_pixelformat = ws->out_pixelformat;
    }
    else if(cinfo->options & jopt_OUTBPP_8GREY)
    {
      /* 8bpp greyscale values packed in 8 bits. Should only be possible if destination is 8bpp with 0=black, 255=white. */
      assert(ws->out_pixelformat == PixelFormat_8bpp, ERROR_FATAL);
      ws->in_pixelformat = PixelFormat_8bpp;
    }
    else if(cinfo->options & jopt_GREY)
    {
      /* 24bpp greyscale values packed in 32 bits */
      ws->in_pixelformat = PixelFormat_24bpp_Grey;
    }
    else if(cinfo->options & jopt_OUTBPP_16)
    {
      /* Merged upsampling version should produce exactly what we need */
      ws->in_pixelformat = ws->out_pixelformat;

      /* 16bpp output is only enabled when JPEG is handling the dithering */
      wp->dither_truecolour &= ~3; 
    }
    else if(cinfo->options & jopt_OUTBPP_8YUV)
    {
      /* 8bpp colour in VIDC1 format. This should match the output format (i.e. screen format). */
      ws->in_pixelformat = PixelFormat_8bpp;
    }
    else
    {
      /* 24bpp colour, &BGR */
      ws->in_pixelformat = PixelFormat_32bpp;
    }
  }
  else
#endif
  {
    /* Pull apart the sprite mode word to deduce our pixel format value */
    ws->in_pixelformat = compute_pixelformat(wp->save_inncolour,wp->save_inmodeflags,wp->save_inlog2bpp);
  }

  /* If input data >=32bpp (including JPEG), assume ColourTTR index values are 15bpp
     Else assume ColourTTR index values are same as source pixels, minus alpha
     The table format is validated by preparettr, so these assumptions should be valid */
  if(wp->TTRType != TTRType_None)
  {
    if((wp->TTRType & ~TTRType_Optional) == TTRType_ColourMap)
      ws->ColourTTRFormat = pick_colourmap_format(wp,ws,ws->in_pixelformat,ws->out_pixelformat);
    else if(wp->save_inlog2bpp >= 5)
      ws->ColourTTRFormat = PixelFormat_15bpp;
    else
      ws->ColourTTRFormat = (PixelFormat) (ws->in_pixelformat & ~PixelFormat_Alpha);
  }

  BOOL use_sprite_palette = FALSE;
  ws->blendimpl = compute_blendimpl(wp,ws,&use_sprite_palette);

  blendimpl_gettables(wp,ws,use_sprite_palette);
  dprintf(("", "blendimpl=%i             %t32. Blending implementation - 0=none, 1=blendtable, 2=inversetable, 3=true, 4=blendtables.\n", ws->blendimpl));

#ifdef DEBUG
  /* Additional mask tracing */
  if (PLOTMASK)
  {
    char *p;
    int  *ecf = (int*) wp->save_ecflimit;

    dprintf(("", "Sprite data:\n"));
    p = (char*) wp->save_inptr;
    for (i = 0; i < 16; i++)
    {
      dprintf(("", "%x", p));
      for (j = 0; j < 16; j++) dprintf(("", " %2x", p[j]));
      newline();
      p -= wp->save_inoffset; /* convert from byte offset to int offset */
    }

    dprintf(("", "Mask data:\n"));
    p = (char*) (SOURCE_TRICKYMASK ? wp->save_maskinptr : (int) wp->save_inptr + wp->save_masko);
    for (i = 0; i < 16; i++)
    {
      dprintf(("", "%x", p));
      for (j = 0; j < 16; j++) dprintf(("", " %2x", p[j]));
      newline();
      p -= wp->save_inoffset;
    }

    dprintf(("", "ECF pattern:\n"));
    for (i = 0; i <= 8; i++)
      dprintf(("", "%x: %c %x %x\n", ecf + 2*i, (ecf+2*i == (int*)wp->save_ecfptr ? '>' : ' '), ecf[2*i], ecf[2*i + 1]));
  }
#endif

  if (wp->cal_table)
  {
    calibration_table *t = wp->cal_table;

    ws->cal_table_simple = t->idealblack == 0 && t->idealwhite == 0xffffff00 && t->postprocessSWI == 0;
#ifdef DEBUG
    dprintf(("", "Calibration table at 0x%x: version=%i idealblack=0x%x idealwhite=0x%x postprocessSWI=0x%x tablecount=%i simple=%s.\n"
     , t->version, t->idealblack, t->idealwhite, t->postprocessSWI, t->tablecount, whether(ws->cal_table_simple)));
    for (i = 0; i < 256; i++) dprintf(("", " %i", t->redtable[i])); newline();
    if (t->tablecount == 3) for (i = 0; i < 256; i++) dprintf(("", " %i", t->greentable[i])); newline();
    if (t->tablecount == 3) for (i = 0; i < 256; i++) dprintf(("", " %i", t->bluetable[i])); newline();
#endif
    assert(wp->BPP == 32, ERROR_FATAL);              /* only to 32 bit dest */
    assert(wp->save_inlog2bpp >= 4, ERROR_FATAL);    /* only from 16 or 32 bit source */
    assert(!SOURCE_TABLE, ERROR_FATAL);              /* there isn't room for a calibration table and another table - they share r_table */
    assert(t->version == 0, ERROR_FATAL);            /* check version number of lookup table */
  }

  /* Simplify scale factors - >>> is this useful? Helps spot 1:1 scaling I guess? */
  assert(wp->save_xadd > 0, ERROR_FATAL);
  assert(wp->save_xdiv > 0, ERROR_FATAL);
  assert(wp->save_ydiv > 0, ERROR_FATAL);
  assert(wp->save_ydiv > 0, ERROR_FATAL);
  while ((wp->save_xadd & 1) == 0 &&
         (wp->save_xdiv & 1) == 0 &&
         (wp->save_xcount & 1) == 0 &&
         (wp->save_xmag & 1) == 0)
  {
    wp->save_xadd >>= 1; wp->save_xdiv >>= 1;
    wp->save_xcount >>= 1; wp->save_xmag >>=1;
  }
  while ((wp->save_yadd & 1) == 0 &&
         (wp->save_ydiv & 1) == 0 &&
         (wp->save_ycount & 1) == 0)
  {
    wp->save_yadd >>= 1; wp->save_ydiv >>= 1;
    wp->save_ycount >>= 1;
  }

#ifdef ASMdoublepixel_bodge
  /* Precise handling of double-pixel modes by the surrounding code is still unclear to me!
   * When it enters this code bpc!=bpp can still be the case, but it seems that the actual
   * value of bpc is best ignored, it has all been frigged into the scale factors. Avoid
   * this issue for now, but note that we must set the values back afterwards because they
   * can be reused on the next sprite plot, if the source sprite mode word is the same.
   */
  i = wp->BPC;
  j = wp->save_inlog2bpc;
  wp->BPC = wp->BPP;
  wp->save_inlog2bpc = wp->save_inlog2bpp;
  result = find_or_compile_code(wp, ws, cinfo);
  wp->BPC = i;
  wp->save_inlog2bpc = j;
#else
  result = find_or_compile_code(wp, ws, cinfo);
#endif

  return result;
}
@


4.22
log
@Replace tracef debug calls
Detail:
  Change tracef() to use the double brackets trick rather than _ for , substitution
Admin:
  Debug build built, but not tested. Non debug build functions as before.
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_70-tracef
@
text
@d1868 1
a1868 1
     && !(wp->is_it_jpeg && (wp->dither_truecolour & 2)) /* And not JPEG scaled error diffused dither */
d1996 1
a1996 1
    if (cinfo->error_argument1 & (jopt_OUTBPP_8 | jopt_OUTBPP_8YUV | jopt_OUTBPP_8GREY)) /* we asked for it, and we got it - 8bpp output pixels */
d2006 1
a2006 1
      if (cinfo->error_argument1 & jopt_OUTBPP_16) /* we asked for it, and we got it - 16bpp output pixels */
a2008 1
        cinfo->convert_block_16 = asm_get_convert_block_16_func(wp->ncolour,wp->modeflags);
d2024 1
a2024 1
       This is deduced by following the same logic in do_3_component_band and jpeg_find_line */
d2043 1
a2043 2
#ifdef ASMCOLOR
      /* Assembler version should produce exactly what we need */
d2045 1
a2045 4
#else
      /* Only 15bpp &BGR colour for C version */
      ws->in_pixelformat = PixelFormat_15bpp;
#endif
@


4.21
log
@Update headers to stock copy
Detail:
  Added headers jerror, jmorecfg, jpegint from IJG8d. Removed jpegdata header.
  Bulk rename of structure members to match newer headers, some RISCOS-isms wrapped in #ifdef RISCOS, retained for the time being.
  Assembler code now gets cinfo member offsets from jhdr.s derived from the C header rather than keeping its own dangerous copy of the offsets.
Admin
  Note: this has broken CFSI-jpeg as it expects the error values to be at the top of cinfo.
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_70-headers.
@
text
@d507 3
a509 2
  IFDEBUG(char a[256];)

d520 1
a520 1
    IFDEBUG(do_sprintf(a,                                "BEQ     %s", l_masked->name);)
d536 3
a538 2
  IFDEBUG(char a[256];)

d567 1
a567 1
    IFDEBUG(do_sprintf(a,                                "BEQ     %s", l_masked->name);)
d1435 1
a1435 1
          tracef("in optimised scale\nxmag = %d, xdiv = %d, xmag mod xdiv = %d\n" _ wp->save_xmag _ wp->save_xdiv _ wp->save_xmag % wp->save_xdiv);
d1621 1
a1621 1
    tracef("in dither_truecolour = %x\n" _ wp->dither_truecolour);
d1646 1
a1646 1
    tracef("%t20.odither_eorvalue * 1:SHL:(24+%i) %t68; value to EOR into r_oditheradd each pixel" _ ws->odither);
d1648 1
a1648 1
    tracef("out dither_truecolour = %x\n" _ wp->dither_truecolour);
d1718 4
a1721 2
  IFDEBUG(ldm_reg_list(ws, saveregs, save_mask, FALSE);)
  IFDEBUG(do_sprintf(a, "STMDB   sp!,{%s}",saveregs);)
d1755 1
a1755 1
  IFDEBUG(do_sprintf(a, "LDMIA   sp!,{%s}",saveregs);)
d1874 8
a1881 8
  tracef("Searching for compiled code for key_word=%x, scale=%i:%i,%i:%i outoffset=%x.\n" _
    key_word _ wp->save_xadd - wp->save_xdiv _ wp->save_xdiv _ wp->save_yadd _ wp->save_ydiv _ wp->save_outoffset);
  tracef("simple_x_scale=%s x_block_move=%s jpeg=%s calibration table=0x%x dither_truecolour=%i\n"
        _ whether(simple_x_scale(wp, ws))
        _ whether(x_block_move(wp, ws))
        _ whether(wp->is_it_jpeg)
        _ wp->cal_table
        _ wp->dither_truecolour);
d1891 1
a1891 1
       tracef("Found existing compiled code in buffer %x.\n" _ p);
d1902 1
a1902 1
  tracef("Compiler initialised for buffer at %x.\n" _ p);
d1926 3
a1928 3
  tracef("wp=%x ws=%x ws_end=%x.\n" _ wp _ ws _ ws_end);
  tracef("Size of assembler workspace: %i.\n" _ ((char*)ws) - ((char*)wp));
  tracef("Size of C workspace: %i. (needed: %i.)\n" _ ((char*)ws_end) - ((char*)ws) _ sizeof(workspace));
d1932 3
a1934 1
  IFDEBUG(dump_asm_workspace(wp);)
d1954 2
a1955 2
  tracef("gcol=%i (& 7 = %i)       %t32. GCOL action - 0 for plot, 1..7 for various others.\n" _ gcol _ gcol & 7);
  tracef("masktype=%i              %t32. Mask type - 0=none, 1=old, 2=1bpp, 3=8bpp alpha.\n" _ ws->masktype);
d1967 1
a1967 1
    tracef("This JPEG sprite was constructed by PutJPEGScaled\n");
d1976 1
a1976 1
    tracef("JPEG, initial source coords are %i,%i.\n" _ wp->in_x _ wp->in_y);
d1998 1
a1998 1
      tracef("actually doing new shiny 8BPP plotting technique\n");
d2089 1
a2089 1
  tracef("blendimpl=%i             %t32. Blending implementation - 0=none, 1=blendtable, 2=inversetable, 3=true, 4=blendtables.\n" _ ws->blendimpl);
d2098 1
a2098 1
    tracef("Sprite data:\n");
d2102 2
a2103 2
      tracef("%x" _ p);
      for (j = 0; j < 16; j++) tracef(" %2x" _ p[j]);
d2108 1
a2108 1
    tracef("Mask data:\n");
d2112 2
a2113 2
      tracef("%x" _ p);
      for (j = 0; j < 16; j++) tracef(" %2x" _ p[j]);
d2118 1
a2118 1
    tracef("ECF pattern:\n");
d2120 1
a2120 1
      tracef("%x: %c %x %x\n" _ ecf + 2*i _ (ecf+2*i == (int*)wp->save_ecfptr ? '>' : ' ') _ ecf[2*i] _ ecf[2*i + 1]);
d2130 5
a2134 5
    tracef("Calibration table at 0x%x: version=%i idealblack=0x%x idealwhite=0x%x postprocessSWI=0x%x tablecount=%i simple=%s.\n"
      _ t->version _ t->idealblack _ t->idealwhite _ t->postprocessSWI _ t->tablecount _ whether(ws->cal_table_simple));
    for (i = 0; i < 256; i++) tracef(" %i" _ t->redtable[i]); newline();
    if (t->tablecount == 3) for (i = 0; i < 256; i++) tracef(" %i" _ t->greentable[i]); newline();
    if (t->tablecount == 3) for (i = 0; i < 256; i++) tracef(" %i" _ t->bluetable[i]); newline();
@


4.20
log
@Fix a few long-standing mask ECF rendering bugs
Detail:
  c/PutScaled - Fix the tail end of loop_y() to update the ECF pointer when simple_y_scale() is true. Without this, unscaled sprites (which didn't fall through to the kernel routine) would have repeated the same ECF row over the whole image instead of displaying the pattern correctly
  Sources/SprOp, c/PutScaled - Rewrite calculation of initial ECF pointer, both to simplify the code and to fix the calculation of the offset to work with ECF patterns that are 8 rows tall (was previously masking off the top bit of the row number, restricting the pattern to within the first 4 rows). Also the resulting address was off by one row, so even if you had a pattern 4 rows tall then it would still be misaligned when compared to the kernel's vector graphics.
Admin:
  Tested on BB-xM
  OS_SpriteOp 49, 50, 55 and kernel vector graphics now all seem to be in agreement for how ECF patterns should be rendered, in a variety of modes


Version 1.63. Tagged as 'SprExtend-1_63'
@
text
@d1606 1
a1606 1
static void loop_y(asm_workspace *wp, workspace *ws, decompress_info_ptr cinfo)
d1632 1
a1632 1
        if (wp->is_it_jpeg && cinfo->jpeg_color_space == CS_GRAYSCALE)
d1829 1
a1829 1
static blitter find_or_compile_code(asm_workspace *wp, workspace *ws, decompress_info_ptr cinfo)
d1839 1
a1839 1
  if (wp->is_it_jpeg && cinfo->jpeg_color_space == CS_GRAYSCALE) key_word |= 1<<28;
d1917 1
a1917 1
  decompress_info_ptr cinfo = NULL;
@


4.19
log
@Update to work with new "32K+" colour translation tables
Detail:
  Sources/SWIs, Sources/SprExtend, Sources/SprOp, c/PutScaled, c/sprtrans, h/putscaled - Cache the sprite NColour value in the save_* workspace
  Sources/SprOp - Update preparettr to perform extra validation on 32K-style translation tables (old "32K." or new "32K+"). Although we could potentially accept any format table, to cut down on the number of plotter combinations we currently require that the table matches the format that ColourTrans will create when given the source sprite.
  c/PutScaled, c/sprtrans - Update comments relating to determining input format of TTRType_32K tables
Admin:
  Tested on BB-xM
  Requires Colours-1_89


Version 1.61. Tagged as 'SprExtend-1_61'
@
text
@d95 1
a95 1
  if(PLOTMASK && !simple_y_scale(wp,ws))
d291 1
a291 3
      LDR_WP(r_ecfindex, save_ecfptr) /* byte index into ECF pattern, not rounded */
      AND(R(r_pixel), R(r_ecfindex), IMM(0x18),              "AND     r_pixel,r_ecfindex,#&18         ; extract initial row offset in ECF");
      ADD(R(r_inptr), R(r_inptr), OP2R(R(r_pixel)),          "ADD     r_inptr,r_inptr,r_pixel         ; and add to initial ECF row address");
d1758 9
a1794 8
    if (PLOTMASK)
    {
      comment(ws,                                    "Advance ECF pointer");
      LDR_WP(r_pixel, save_ecflimit);                      /*LDR     r_pixel,save_ecflimit*/
      CMP(R(r_inptr), OP2R(R(r_pixel)),                     "CMP     r_inptr,r_pixel                 ; check for bottom of ECF");
      ADD(R(r_inptr), R(r_inptr), EQ | IMM(64),             "ADDEQ   r_inptr,r_inptr,#64             ; and if reached, reset to top");
      SUB(R(r_inptr), R(r_inptr), IMM(8),                   "SUB     r_inptr,r_inptr,#8              ; points to base of current row of ECF");
    }
@


4.18
log
@Clarify some comments
Not tagged.
@
text
@d2064 1
a2064 3
    int in_ncolour;
    _swix(OS_ReadModeVariable,_INR(0,1)|_OUT(2),wp->save_mode,VduExt_NColour,&in_ncolour);
    ws->in_pixelformat = compute_pixelformat(in_ncolour,wp->save_inmodeflags,wp->save_inlog2bpp);
d2067 1
a2067 1
  /* Fudge - if input data >=32bpp (including JPEG), assume ColourTTR index values are 15bpp
d2069 1
a2069 1
     Really the assembler code should tell us what format it is */
@


4.17
log
@Fix some sprite rendering issues. Add a new test app.
Detail:
  Bug fixes:
  - Sources/SprOp: Fixed a bug with PlotMask of old-format sprites not working correctly if the sprite is off the left edge of the screen. Fixed Log2bpp/Log2bpc confusion when plotting to double-pixel modes, caused by double pixel bodge being disabled.
  - Sources/SprTrans: Fixed transformed plotting of sprites with lefthand wastage drawing the sprite offset if a transformation matrix is used
  - c/PutScaled: Fixed another double pixel bodge related bug, when plotting double pixel sprites at certain offsets and with the two-at-a-time plotting code
  Test code:
  - Test/c/bigtest: A fairly comprehensive test app that generates lots of random sprites in every supported mode, and plots them using all APIs and options into all supported destination modes. Output is redirected to sprites (so the capabilities of the host video hardware are irrelevant), and checked against a model of what the expected output should look like. Also features some JPEG tests. A fast computer is recommended when running the tests!
  - Test/mkbigtest,fd7: Helper script to build bigtest
  - Test/bigtest2,ffb: Helper BASIC program to allow easy re-testing of failure cases
  - Test/JPEGs/*: Test JPEGs and reference sprites which are used by the JPEG test. JPEGs chosen to exercise all the output formats the JPEG code supports.
Admin:
  Tested on BB-xM


Version 1.60. Tagged as 'SprExtend-1_60'
@
text
@d441 1
d537 1
a537 3
#ifdef DEBUG
  char a[256];
#endif
d765 1
a765 1
    BFI(R(r_outword), R(r_pixel), wp->BPC, wp->BPC, 0,        "BFI     r_outword,r_outword,#out_bpc,#out_bpc");
d868 1
a868 1
                           RORI(ws->in_bpc*2),               "MOV     r_maskinword,r_maskinword,ROR #in_bpc*2");
d871 1
a871 1
        S | IMM(ws->in_bpc) | IMMROR(4),                     "SUBS    r_inshift,r_inshift,#in_bpc:SHL:28 ; auto-resets itself to 0");
d984 1
a984 1
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC*2),  "MOV     r_outword,r_outword,ROR #out_bpc*2");
d986 1
a986 1
        S | IMM(wp->BPC) | IMMROR(4),                        "SUBS    r_outshift,r_outshift,#out_bpc:SHL:28");
d1195 1
a1195 1
      ins(ws, NE | LDR(R(r_outword), R(r_outptr)) | OFFSET(0),  "LDRNE   r_outword,[r_outptr]            ; load up output word");
d1485 1
a1485 1
           * abandon this one and use the ditering one all the time, with tiny variants. Not done.
@


4.16
log
@Fix plots of Y-scaled masks
Detail:
  c/PutScaled - Update r_pixel so that it's available in the Y-loop bank if a Y-scaled mask is being drawn. In this case r_pixel is used as a temp register to help update the ECF pointer.
Admin:
  Tested on BB-xM
  Fixes issue reported on forums with !Wget application sprite not rendering when dragging-and-dropping it via the filer:
  https://www.riscosopen.org/forum/forums/4/topics/2141


Version 1.59. Tagged as 'SprExtend-1_59'
@
text
@d1334 1
d1338 5
@


4.15
log
@Add support for blended sprite & JPEG rendering - alpha masks, alpha channels, and translucency
Detail:
  This big set of changes adds support for the following user-facing APIs, as per ROL's specs:
  - OS_SpriteOp 52 (PutSpriteScaled) colour mapping, translucency blending, and alpha mask/alpha channel blending
  - OS_SpriteOp 56 (PutSpriteTransformed) colour mapping, translucency blending, and alpha mask/alpha channel blending
  - JPEG_Plot[File]Scaled colourmapping & translucency blending
  - JPEG_Plot[File]Transformed colourmapping & translucency blending
  Sources/CFSI-JPEG, Sources/PutScaled:
  - Added exit_oserror exit routine for use by C code.
  - For SpriteExtend this allows the C code to cause OS_SpriteOp to exit with a given OS error block.
  - For CFSI-JPEG the error block is returned and ERROR_FATAL is returned to ChangeFSI.
  Sources/CSupport:
  - Add definitions for some error codes (matches existing definitions from h/commondefs)
  Sources/PutScaled:
  - Stripped out code to look for identity translation tables; now handled by preparettr routine in Sources/SprOp
  Sources/SWIs, Hdr/SprExtend:
  - JPEG SWIs updated to add support for alpha-blended and colour mapped JPEG rendering, following ROL's APIs
  Sources/SprExtend:
  - Stripped out lots of old build flags which haven't been touched in years.
  - Strip out assembler SprTrans code generator.
  - Add new definitions needed for blending & colour mapping.
  Sources/SprOp:
  - Updated PutScaled frontend to deal with blending and colour mapping.
  - Disabled code which was bodging coordinates when dealing with double-pixel modes - it seems to cause a few issues, and the code generator mostly had proper double-pixel support anyway.
  - Translation table verification and fiddling code rewritten and consolidated into the preparettr routine. C code is now explicitly told what table type is in use and whether it can safely be ignored in favour of using the sprite palette.
  - Removed code from CheckSpriteArea which was deliberately throwing an error upon seeing alpha-masked sprites; I think the bug that was hiding has been fixed now
  Sources/SprTrans
  - Removed the assembler version of the code generator.
  - Updated to add support for blending and colour mapping
  c/PutScaled:
  - Old test code removed.
  - Updated to add support for blending & colour mapping
  - Assorted bugs fixed.
  - A few extra architecture-specific optimisations added.
  - Some workspace setup code moved to c/asmcore to allow sharing with SprTrans.
  c/asmcore:
  - Register allocation code rewritten. Instead of allocating on a first-come, first-served basis, the code now builds a list of which logical registers are needed (and which 'banks' they fall into) and then attempts to allocate them in a more intelligent manner. It still has some failings (e.g. reusing R12 as a general purpose register is currently impossible) but it's a lot more flexible and reliable than the old code.
  - Core pixel transformation code updated to add support for blending & colour mapping
  - Added some extra architecture-specific optimisations
  c/rojpeg:
  - JPEG option handling updated to avoid trashing any colour mapping descriptor that may have been passed in
  c/sprtrans:
  - Updated to add support for blending & colour mapping
  c/tracing:
  - Debug assert messages now show filename as well as line number
  h/commondefs:
  - Removed old #define's that related to old assembler switches.
  h/putscaled:
  - Workspace definition updated to match assembler version.
  - SprTrans stack workspace structure moved here from c/sprtrans
Admin:
  Tested on BB-xM plotting all major sprite & JPEG types into all modes with all major options


Version 1.55. Tagged as 'SprExtend-1_55'
@
text
@d94 4
a97 1
  RN(r_pixel, 14, REGFLAG_TEMPORARY+REGFLAG_XLOOP+REGFLAG_PERPIXEL, "fetched and translated pixel")
@


4.14
log
@Add support for new sprite types & screen modes
Detail:
  Makefile - Updated to fix a couple of dependency issues and to make c/asmcore the main C file, not c/putscaled
  Sources/PutScaled - Add a utility routine that's used by the C code to get information about pixel formats
  Sources/SprAdjSize - Add support for wide masks & RISC OS 5 style sprite mode words
  Sources/SprExtend - Tidy up workspace by removing lots of unused bits and moving other bits within sight of the C code. Add flag to control whether C or assembler version of SprTrans is used. Query kernel for ECFYOffset/ECHShift locations instead of using hardcoded values in putscaled code. Add fix for garbage debug strings in softloaded debug versions of the module.
  Sources/SprOp - Add support for wide masks & RISC OS 5 style sprite mode words. Update makepalette16bpp to cope with all the new 16bpp modes. Flag_* -> ModeFlag_* renaming. Move some translation table handling code into a new routine, 'preparettr'. Update checktrans/converttrans to deal with new pixel formats.
  Sources/SprTrans - If the C version of SprTrans is enabled, disable all of these assembler bits except for the outer loop which steps over each row of the screen
  Sources/jdcolor - Updated to deal with new pixel formats. 16bpp conversion code split off into new file, Sources/jdcolor16.
  Sources/jdcolor16 - New file containing the guts of the YUV -> 16bpp conversion code. Gets included multiple times with different options to generate the different conversion routines (code is too big for a macro).
  c/asmcore - New file containing lots of common code ripped out of c/PutScaled - e.g. workspace definition, main functions for register assignment & instruction generation, and code for pixel format conversion. Pixel format conversion code rewritten to cope with new pixel formats, and code buffer key word generation rewritten to fix a couple of bugs (e.g. some issues with dithering options were observed)
  c/PutScaled - Ripped out lots of code that's now in c/asmcore. Now just deals with things that are PutScaled-specific, e.g. main plotter loop containing pixel read/write code. Code extended to cope with new pixel formats
  c/rojpeg, h/jinclude, h/jpegdata - Code extended to cope with new 16bpp conversion routines
  c/sprtrans - New C implementation of the core per-row transformed sprite plotting code generator. Allows reuse of the extensive pixel conversion code in c/asmcore, and allows for better code generation than the assembler original.
  h/putscaled - Worksapce definition updated to match assembler version
Admin:
  Tested on BB-xM, plotting lots of different sprites in lots of different modes
  Plotting of wide mask sprites not supported yet
  C version of YUV -> 16bpp code currently only deals with traditional &BGR 555 pixel format - code is aware of this and will do conversion to desired format if applicable (although quality may be reduced)
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 1.52. Tagged as 'SprExtend-1_52'
@
text
@a18 79
*    Test main entry sequence, low level IO and code generation.          *
*                                                                         *
**************************************************************************/

#ifdef TESTDEBUG
blitter putscaled_compiler(asm_workspace *wp, workspace *ws, workspace *ws_end, int gcol)
{
  /* Test low-level output */
  writes(0, "Hello there!\nhi!\n");
  writech(0, 'X');
  writehex(0, 0x5732abcd, 8);
  writech(0, '_');
  tracef("Test tracef, esc:%%, string:'%s', char:'%c', int:'%i', hex:'%x'.\n",
    "hello", 'X', 1234567, 0x6789abcd);

  /* Check that the assembler has an adequate opinion of our workspace needs. */
  tracef("wp=%x ws=%x ws_end=%x.\n" _ wp _ ws _ ws_end);
  tracef("Size of assembler workspace: %i.\n" _ ((char*)ws) - ((char*)wp));
  tracef("Size of C workspace: %i.\n" _ ((char*)ws_end) - ((char*)ws));
  assert(ws_end > ws, ERROR_NO_MEMORY);
  check_workspace(ws);
  dump_workspace(ws);

  compile_buffer_init(wp, ws);

  /* Check compilation of all instruction forms. The resulting trace output can then
   * have its binary details stripped, be run through objasm, and the resulting listings
   * compared to check the bit patterns generated.
   */
  ADD(5, 6, GT | OP2R(7),                             "ADDGT   r5,r6,r7");
  branch(ws, B, L(loop_y_exit),                       "B       loop_y_exit");
  ORR(2, 3, S | IMM(23),                              "ORRS    r2,r3,#23");
  DEFINE_LABEL(test1, "test label")
  EOR(1, 2, EQ | IMM(255) | IMMROR(10),               "EOREQ   r1,r2,#(255:ROR:10)");
  comment(ws, "This is a comment");
  DEFINE_LABEL(test2, "test label")
  branch(ws, B + NE, L(loop_y_repeat),                "BNE     loop_y_repeat");
  branch(ws, BL + EQ, L(loop_y_repeat),               "BLEQ    loop_y_repeat");
  CMP(8, OP2R(9) | LSLI(12),                          "CMP     r8,r9,LSL #12");
  CMP(8, OP2R(9) | ASRR(6),                           "CMP     r8,r9,ASR r6");
  MOV(3, OP2R(4) | RORI(1),                           "MOV     r3,r4,ROR #1");
  MOV(R(pc)), OP2R(R(lr)),                            "MOV     pc,lr");

  ins(ws, LDR(8,3) | OFFSET(249),                     "LDR     r8,[r3,#249]");
  ins(ws, LDR(8,3) | OFFSET(0),                       "LDR     r8,[r3]");
  ins(ws, STR(1,2) | GT + NEGOFFSET(12),              "STRGT   r1,[r2,#-12]");
  ins(ws, LDRB(1,2) | PREINC(4),                      "LDRB    r1,[r2,#4]!");
  ins(ws, STRB(6,7) | POSTINC(4),                     "STRB    r6,[r7],#4");
  ins(ws, LDRB(1,2) | PREDEC(4),                      "LDRB    r1,[r2,#-4]!");
  ins(ws, STRB(6,7) | POSTDEC(4),                     "STRB    r6,[r7],#-4");
  ins(ws, LDRB(8,3) | INDEX(4,0),                     "LDRB    r8,[r3,r4]");
  ins(ws, LDR(8,3) | INDEX(4,2),                      "LDR     r8,[r3,r4,LSL #2]");

  ins(ws, PUSH | GT | (1<<4) | (1<<5) | (1<<6),       "STMGTDB sp!,{r4,r5,r6}");
  ins(ws, POP | (1<<4) | (1<<5) | (1<<6),             "LDMIA   sp!,{r4,r5,r6}");
  ins(ws, POP | (1<<4) | (1<<5) | (1<<6) | (1<<R(pc)),"LDMIA   sp!,{r4,r5,r6,pc}");

  {
    char a[256];
    char a2[256];
    int regmask = (1<<13) | (1<<15); /* pretty arbitrary silly one actually */

    ldm_reg_list(ws, a, regmask, FALSE);
    do_sprintf(a2, "LDMIA   lr,{%s}", a)
    ins(ws, LDMIA(lr) | regmask, a2);
    do_sprintf(a2, "STMIA   l4,{%s}", a)
    ins(ws, STMIA(lr) | regmask, a2);
  }

  branch(ws, BL + EQ, &ws->labels.loop_y_repeat,                        "BLEQ    loop_y_repeat");

  compile_buffer_done(ws);

  writes(0, "Exit.\n");
}
#else

/**************************************************************************
*                                                                         *
d31 2
d49 1
d94 1
a94 1
  RN(r_pixel, 14, "fetched and translated pixel")
d101 3
a103 3
  RN(r_inptr, -1, PLOTMASK ? "ECF pattern pointer" : "input word pointer")
  RN(r_outptr, -1, "word pointer to output")
  if (SOURCE_BPPMASK || PLOTMASK) RN(r_maskinptr, -1, "mask input word pointer")
d105 1
a105 1
  if (ws->odither) RN(r_oditheradd, -1, "ordered dither offset value")
d118 4
a121 4
    RN(r_inshift, -1, "Number of (most sig) bits of first input word to transfer, in 1..32")
    RN(r_outshift, -1, "Number of (most sig) bits of first output word to fill, in 1..32")
    RN(r_xsize, -1, "Number of bits to transfer per row")
    RN(r_blockroutine, -1, "Block transfer routine")
d133 1
a133 1
      RN(r_inword, -1, "ECF pattern input word")
d136 2
a137 2
      RN(r_inshift, -1, "bit shift of current pixel LSL #27")
      RN(r_inword, -1, "current input word")
d141 3
a143 3
      RN(r_maskinword, -1, "current mask word")
      if (SOURCE_BPPMASK || PLOTMASK)
        RN(r_maskinshift, -1, "bit shift of current mask pixel")
d145 1
a145 1
        RN(r_masko, -1, "offset of mask data from sprite data")
d155 2
a156 2
      RN(r_ecfindex, -1, "index into ECF pattern")
      RN(r_bgcolour, -1, "background plotting colour")
d160 1
a160 1
      if (SOURCE_TABLE || wp->cal_table) RN(r_table, -1, "translation table or palette")
d176 6
a181 2
      RN(r_outword, -1, "current output word")
      RN(r_outshift, -1, "bit shift of current pixel in current output word LSL 27")
d186 1
a186 1
      RN(r_in_pixmask, -1, "pixel mask for 2-at-a-time loop")
d192 1
a192 1
    RN(r_xsize, -1, "number of output pixels per row")
d194 1
a194 1
      RN(r_xcount, -1, "total for x scale")
d198 1
a198 13
  /* The temporaries are shuffled to the end, so that if r12 (the assembler wp) is used then
   * it does not get loaded before the y loop variables are initialised.
   */
  if (need_temps >= 1) RN(r_temp1, -1, "temp1 for pixel transformation temporary values")
  if (need_temps >= 2) RN(r_temp2, -1, "temp2 for pixel transformation temporary values")

  /* MAX POSSIBLE REQUIREMENT - 13, if vcount stuff not done.
   * It may appear 15, but temp1 and temp2 are only needed if one of src/dst
   * is 32bpp, in which case we save elsewhere.
   * >>> AH not so, they are also needed if a palette is used, in which case
   * the source can be fewer bpp. Ooops. Can we ever overflow? Not sure.
   */
}
d200 2
a201 8
static int yloop_rn_count(asm_workspace *wp, workspace *ws)
/* Say how many registers yloop_rn will declare */
{
  int result = 2;                                        /* r_ysize, r_inoffset */
  if (wp->save_yadd != wp->save_ydiv) result++;          /* r_ycount */
  if (SOURCE_BPPMASK || PLOTMASK) result++;              /* r_maskinoffset */
  if (wp->is_it_jpeg) result++;                          /* r_fetchroutine */
  return result;
d210 1
a210 1
  RN(r_ysize, -1, "number of output rows");
d212 1
a212 1
    RN(r_ycount, -1, "total for y scale")
d215 3
a217 3
  RN(r_inoffset, -1, "byte offset between input rows.")
  if (SOURCE_BPPMASK || PLOTMASK) RN(r_maskinoffset, -1, "byte offset between mask rows.")
  if (wp->is_it_jpeg)             RN(r_fetchroutine, -1, "routine for getting row of decompressed JPEG data.")
d259 1
a259 2
/* Initialise whatever registers are needed for fetching and translating
 * pixels.
d306 1
a306 1
      if (SOURCE_BPPMASK || PLOTMASK)
d309 1
a309 1
        if (SOURCE_BPPMASK)
d327 13
d342 1
a342 17
    else if (wp->trns_palette != 0) LDR_WP(r_table, trns_palette)
    else
    {
      if (wp->ColourTTR != 0)
      {
        LDR_WP(r_table, ColourTTR)
        if (  wp->BPP <= 8                  /* 256 colours or less on output */
           && wp->save_inlog2bpp >= 4       /* thousands or millions of input colours */
           )
        {
          ins(ws, LDR(R(r_table), R(r_table)) | OFFSET(4), "LDR     r_table,[r_table,#4]            ; load base of 32K table");
        }
      }
    }

    if (wp->save_inlog2bpp <= 3 && simple_x_scale(wp, ws))
      MOV(R(r_in_pixmask), IMM(ws->in_pixmask),           "MOV     r_in_pixmask,#in_pixmask        ; for use in 2-at-a-time loop");
d397 1
d403 1
d410 1
a418 1
  if (wp->is_it_jpeg) LDR_WP_C(r_fetchroutine, fetchroutine, "routine to call to get JPEG data line")
d429 1
a429 1
  if (SOURCE_BPPMASK) LDR_WP(r_maskinoffset, save_maskinoffset)
d462 6
d470 1
d481 9
a489 2
      MOV(R(r_pixel), OP2R(R(r_inword)) | LSLI(16),     "MOV     r_pixel,r_inword,LSL #16        ; fetch 16 bit pixel");
      MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(16),      "MOV     r_pixel,r_pixel,LSR #16");
d509 8
a516 1
    TST(R(r_maskinword), IMM(1),                      "TST     r_maskinword,#1");
d541 1
a541 1
    if (SOURCE_BPPMASK) /* we may have reached the end of mask word if not doing an aligned plot */
d544 1
a544 1
                       | RORI(ws->mask_bpp),                 "x"/*MOV     r_maskinword,r_maskinword,ROR #mask_bpp"*/);
d546 1
a546 1
                       S | IMM(ws->mask_bpp*2) | IMMROR(6),  "x"/*SUBS    r_maskinshift,r_maskinshift,#mask_bpp:SHL:27"*/);
d548 9
a556 2
          | EQ | WRITEBACK | OFFSET(4),                     "x"/* "LDREQ   r_maskinword,[r_maskinptr,#4]!     ; load more mask pixels (inc2)"*/);
      TST(R(r_maskinword), IMM(1),                           "TST     r_maskinword,#1");
a563 1
      IFDEBUG(do_sprintf(a,                                "BEQ     %s", l_masked->name);)
d565 1
d611 9
a619 2
        MOV(R(r_pixel), OP2R(R(r_inword)) | LSLI(16),             "MOV     r_pixel,r_inword,LSL #16        ; fetch 16 bit ECF pattern pixel44 99");
        MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(16),              "MOV     r_pixel,r_pixel,LSR #16         ; 4444444");
d621 9
a629 2
        MOV(R(r_pixel), OP2R(R(r_bgcolour)) | LSLI(16),           "MOV     r_pixel,r_bgcolour,LSL #16        ; fetch 16 bit ECF pattern pixel 4499");
        MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(16),              "MOV     r_pixel,r_pixel,LSR #16           ;449");
d634 4
a637 4
        AND(R(r_pixel), R(r_inword), IMM(ws->out_pixmask),       "1AND     r_pixel,r_inword,#out_pixmask  ; blah blah");
        ORR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),          "ORR     r_outword,r_outword,r_pixel           ; ECF OR mask");
        AND(R(r_pixel), R(r_bgcolour), IMM(ws->out_pixmask),       "1AND     r_pixel,r_bgcolour,#out_pixmask    jthjg");
        EOR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),       "EOR     r_outword,r_outword,r_pixel           ; ECF EOR mask");
d652 1
a652 1
          case 6: MVN(R(r_pixel), OP2R(R(r_pixel)),                     "MVN     r_pixel,r_pixel                       ; AND with neg action");
d658 3
a660 3
      ins(ws, STR(R(r_temp1), R(r_outptr)) | OFFSET(0),               "STR     r_temp1,[r_outptr]");
      if ((ws->gcol == 7) || (ws->gcol == 6)) /* put r_pixel back as we found it */
        MVN(R(r_pixel), OP2R(R(r_pixel)),                             "1MVN     r_pixel,r_pixel                       ; Put r_pixel back");
d669 1
a669 1
      if (ws->gcol == 6 || ws->gcol == 7) /* and/or with NOT of incoming pixel */
d683 1
a683 1
          if (SOURCE_MASK) /* if no mask, the pixels are clear already */
d685 5
a689 1
            if (DESTD_16_BIT)
d700 1
a700 1
        case 6:
d713 1
a713 1
      if (ws->gcol == 6 || ws->gcol == 7) /* put r_pixel back as we found it in case scaling > 1:1! */
d730 1
a730 1
  if (DESTD_16_BIT)
d732 1
a732 2
    BIC(R(r_outword), R(r_outword), IMM(255),                 "3BIC     r_outword,r_outword,#0x00ff");
    BIC(R(r_outword), R(r_outword), IMM(255) | IMMROR(24),    "4BIC     r_outword,r_outword,#0xff00");
d736 10
a745 1
    BIC(R(r_outword), R(r_outword), IMM(ws->out_dpixmask),    "5BIC     r_outword,r_outword,#out_dpixmask");
a746 1
    ORR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),       "6ORR     r_outword,r_outword,r_pixel           ; gcol action");
d761 4
d771 2
a772 2
        BIC(R(r_outword), R(r_outword), IMM(255) | IMMROR(16),  "BIC     r_outword,r_outword,#0x00ff0000");
        BIC(R(r_outword), R(r_outword), IMM(255) | IMMROR(8),   "BIC     r_outword,r_outword,#0xff000000");
d778 1
a778 1
              : IMM(ws->out_dpixmask) | IMMROR(32 - wp->BPC),   "BIC     r_outword,r_outword,#out_dpixmask:SHL:out_bpc");
d781 1
a781 1
        OP2R(R(r_pixel)) | LSLI(wp->BPC),                       "ORR     r_outword,r_outword,r_pixel,LSL #out_bpc");
d805 2
a806 1
      if (SOURCE_MASK & !(SOURCE_BPPMASK))
d809 1
d819 1
a819 1
    if (SOURCE_BPPMASK || PLOTMASK)
d821 1
d826 6
d863 2
a864 1
    if (SOURCE_MASK & !(SOURCE_BPPMASK))
d867 1
d876 1
a876 1
    if (SOURCE_BPPMASK)
d879 1
a879 1
                         | RORI(ws->mask_bpp),               "MOV     r_maskinword,r_maskinword,ROR #mask_bpp");
d881 1
a881 1
                         S | IMM(ws->mask_bpp*2) | IMMROR(6),"SUBS    r_maskinshift,r_maskinshift,#mask_bpp:SHL:27");
d903 2
a904 2
    ADD(R(r_outptr), R(r_outptr), R(r_xcount) | LSLI(2),          "4~ADD     r_outptr,r_outptr,r_xcount,LSL #2        ; skip 4*pixels bytes");
    MOV(R(r_xcount), IMM(0),                                      "41MOV     r_xcount,#0");
d908 5
a912 5
    SUB(R(r_xcount), R(r_xcount), OP2R(R(r_temp1)),               "4~SUB     r_xcount, r_xcount, r_temp1");
    MOV(R(r_temp1),  OP2R(R(r_temp1)) | LSLI(wp->Log2bpc),      "4~MOV     r_temp1, t_temp1, LSL #out_log2bpc");
    MOV(R(r_outword), OP2R(R(r_outword)) | RORR(R(r_temp1)),      "4~MOV     r_outword,r_outword,ROR r_temp1");
    ins(ws, STR(R(r_outword), R(r_outptr)) | POSTINC(4),          "4~STR     r_outword,[r_outptr],#4");
    MOV(R(r_outshift), IMM(0),                                    "4~MOV     r_outshift, #0");
d914 2
a915 2
    MOV(R(r_temp1), OP2R(R(r_xcount)) | S |LSRI(ws->out_l2ppw),   "4~~MOVS     r_temp1,r_xcount,LSR #out_log2ppw            ; whole words to skip");
    ADD(R(r_outptr), R(r_outptr), NE | R(r_temp1) | LSLI(2),      "4~ADDNE    r_outptr,r_outptr,r_temp1,LSL #2             ; skip 4*pixels bytes");
d917 1
a917 1
    ins(ws, LDR(R(r_outword), R(r_outptr)) | OFFSET(0),           "4~~LDR     r_outword,[r_outptr]");
d919 1
a919 1
                      OP2R(R(r_temp1)) | LSLI(ws->out_l2ppw),     "4~SUB     r_xcount, r_xcount, r_temp1 LSL #out_log2ppw ; pixels left to skip");
d926 2
a927 2
    MOV(R(r_temp1),  OP2R(R(r_xcount)) | LSLI(wp->Log2bpc),    "2~~MOV     r_temp1, r_xcount, LSL #out_log2bpc");
    MOV(R(r_outword), OP2R(R(r_outword)) | RORR(R(r_temp1)),     "2~MOV     r_outword,r_outword,ROR r_temp1");
d929 2
a930 2
        OP2R(R(r_temp1)) | LSLI(27),                                   "2~~SUB    r_outshift,r_outshift,r_temp1,SHL #27");
    MOV(R(r_xcount), IMM(0),                                      "31MOV     r_xcount,#0");
d954 1
a954 1
    if (ws->gcol == 0 && !SOURCE_MASK && !PLOTMASK)
a1052 1
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "015MOV     r_outword,r_outword,ROR #out_bpc");
d1054 3
a1056 2
        S | IMM(wp->BPC*2) | IMMROR(6),                         "7SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    branch(ws, B | EQ, L(plot_loop1a),                           "BEQ     plot_loop1a");
a1058 1
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "115MOV     r_outword,r_outword,ROR #out_bpc");
d1060 3
a1062 2
        S | IMM(wp->BPC*2) | IMMROR(6),                         "17SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    branch(ws, B | EQ, L(plot_loop1b),                           "BEQ     plot_loop1b");
a1064 1
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "215MOV     r_outword,r_outword,ROR #out_bpc");
d1066 3
a1068 2
        S | IMM(wp->BPC*2) | IMMROR(6),                         "27SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    branch(ws, B | EQ, L(plot_loop1c),                           "BEQ     plot_loop1c");
a1070 1
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "315MOV     r_outword,r_outword,ROR #out_bpc");
d1072 2
a1073 1
        S | IMM(wp->BPC*2) | IMMROR(6),                         "37SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
d1086 1
a1086 1
    for (loop = wp->BPP;loop<32;loop*=2)
d1090 2
a1093 2
    SUB(R(r_temp1), R(r_temp1),
        S | IMM(1),                                               "5SUBS    r_temp1,r_temp1,#1");
d1096 2
a1097 7
    if (DESTD_16_BIT)
    {
      MOV(R(r_pixel), OP2R(R(r_pixel)) | LSLI(16),                "7MOV     r_pixel, r_pixel, LSL #16            ; whole words to skip");
      MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(16),                "8MOV     r_pixel, r_pixel, LSR #16            ; whole words to skip");
    }
    else
      AND(R(r_pixel), R(r_pixel), IMM(ws->out_dpixmask),          "9AND     r_pixel,r_pixel,#dpix_mask");
d1110 3
a1112 1
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "14MOV     r_outword,r_outword,ROR #out_bpc");
d1114 2
a1115 4
        S | IMM(wp->BPC*2) | IMMROR(6),                          "15SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    SUB(R(r_xcount), R(r_xcount),
        S | IMM(1),                                             "16SUBS    r_xcount, r_xcount, #1");
    branch(ws, B | EQ, L(plot_loop4a),                          "17BEQ     plot_loop4a");
d1118 3
a1120 1
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "214MOV     r_outword,r_outword,ROR #out_bpc");
d1122 2
a1123 4
        S | IMM(wp->BPC*2) | IMMROR(6),                          "215SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    SUB(R(r_xcount), R(r_xcount),
        S | IMM(1),                                             "216SUBS    r_xcount, r_xcount, #1");
    branch(ws, B | EQ, L(plot_loop4b),                          "17BEQ     plot_loop4b");
d1126 3
a1128 1
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "314MOV     r_outword,r_outword,ROR #out_bpc");
d1130 2
a1131 4
        S | IMM(wp->BPC*2) | IMMROR(6),                          "315SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    SUB(R(r_xcount), R(r_xcount),
        S | IMM(1),                                             "316SUBS    r_xcount, r_xcount, #1");
    branch(ws, B | EQ, L(plot_loop4c),                          "17BEQ     plot_loop4c");
d1134 3
a1136 1
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "414MOV     r_outword,r_outword,ROR #out_bpc");
d1138 1
a1138 3
        S | IMM(wp->BPC*2) | IMMROR(6),                          "415SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    SUB(R(r_xcount), R(r_xcount),
        S | IMM(1),                                             "416SUBS    r_xcount, r_xcount, #1");
d1140 1
a1140 1
    branch(ws, B | NE, L(plot_loop4),                           "17BNE     plot_loop4");
d1174 1
a1174 1
    if (SOURCE_BPPMASK || PLOTMASK)
d1189 1
a1189 1
    if (ws->gcol == 0 && !SOURCE_MASK && !PLOTMASK)
d1337 1
d1340 2
a1341 1
          if (SOURCE_BPPMASK)
d1344 10
d1394 1
a1394 1
      if (ws->odither && wp->save_xadd - wp->save_xdiv > wp->save_xdiv)
d1396 1
a1396 1
        /* If dithering and scaling we have to be very careful about where we do fetch_pixel_inc, because when replicating
d1400 1
a1400 1
        DEFINE_LABEL(                                       loop_x_repeat, "Loop around for each source pixel (ordered dither)")
d1405 1
a1405 1
        DEFINE_LABEL(                                       loop_put_pixel_repeat, "Repeatedly paint and ordered-dither a source pixel");
d1409 1
a1409 1
        SUB(R(r_xsize), R(r_xsize), S | IMM(1),                    "SUBS    r_xsize,r_xsize,#1              ; count output ordered dither pixels");
d1422 1
a1422 1
        if ( !PLOTMASK && (wp->save_xmag % wp->save_xdiv) == 0 && ((wp->save_xmag / wp->save_xdiv) > 4) && ws->gcol == 0)
d1501 1
a1501 1
        if (!PLOTMASK && (wp->save_xmag % wp->save_xdiv) == 0 && ((wp->save_xmag / wp->save_xdiv) > 4) && ws->gcol == 0)
a1602 8
  /* Declare the registers */
  int yrn;
  int x_loop_save_mask;
  int y_loop_save_mask;
  int ptrs_save_mask;    /* r_inptr, r_outptr, and (if it exists) r_maskinptr */
  int x_loop_save_size;
  int ptrs_save_size;
  BOOL onebank; /* one bank of registers, or two */
a1603 3
  char xregs[256];
  char yregs[256];
  char ptrregs[256];
d1605 1
d1608 1
a1608 54
  /* Various useful constants not provided directly by wp. */
  newline();
  comment(ws, "Various useful constants");
  if (DPIXEL_INPUT)
    comment(ws, "Double-pixel input - pixels are not the same as double-pixels");
  else
    comment(ws, "Not double-pixel input - pixels are exactly the same as double-pixels");
  ws->in_bpp         = 1 << wp->save_inlog2bpp;
  ws->in_bpc         = 1 << wp->save_inlog2bpc;
  ws->in_pixmask     = (1 << ws->in_bpp) - 1;
  tracef("%t20.in_bpp  *       %i %t68; bits per input pixel\n" _ ws->in_bpp);
  tracef("%t20.in_bpc  *       %i %t68; bits per input double-pixel ('character')\n" _ ws->in_bpc);
  if (ws->in_bpp <= 8) tracef("%t20.in_pixmask *    %i %t68; input pixel mask\n" _ ws->in_pixmask);

  if (SOURCE_MASK)
  {
    if (SOURCE_BPPMASK) /* a bit mask */
    {
      ws->mask_bpp     = 1;
      ws->mask_bpc     = 1;
      ws->mask_pixmask = 1;
    }
    else
    {
      ws->mask_bpp     = ws->in_bpp;
      ws->mask_bpc     = ws->in_bpc;
      ws->mask_pixmask = ws->in_pixmask;
    }
    tracef("%t20.mask_bpp *      %i %t68; bits per mask pixel\n" _ ws->mask_bpp);
    tracef("%t20.mask_bpc *      %i %t68; bits per mask double-pixel\n" _ ws->mask_bpc);
    tracef("%t20.mask_pixmask *  %i %t68; mask pixel mask\n" _ ws->mask_pixmask);
  }
  else
    comment(ws, "No input mask");

  if (DPIXEL_OUTPUT)
    comment(ws, "Double-pixel output - pixels are not the same as double-pixels");
  else
    comment(ws, "Not double-pixel output - pixels are exactly the same as double-pixels");
  ws->out_l2ppw      = 5 - wp->Log2bpc;
  ws->out_ppw        = 1 << ws->out_l2ppw;
  ws->out_pixmask    = (1 << wp->BPP) - 1;
  ws->out_dpixmask   = (1 << wp->BPC) - 1;
  tracef("%t20.out_bpp *       %i %t68; bits per output pixel\n" _ wp->BPP);
  tracef("%t20.out_bpc *       %i %t68; bits per output double-pixel\n" _ wp->BPC);
  tracef("%t20.out_l2bpp *     %i %t68; log base 2 of bits per output pixel\n" _ wp->Log2bpp);
  tracef("%t20.out_l2bpc *     %i %t68; log base 2 of bits per output double-pixel\n" _ wp->Log2bpc);
  tracef("%t20.out_ppw *       %i %t68; double-pixels per output word\n" _ ws->out_ppw);
  tracef("%t20.out_l2ppw *     %i %t68; log base 2 of double-pixels per output word\n" _ ws->out_l2ppw);
  if (wp->BPC <= 8)
  {
    tracef("%t20.out_pixmask *   %i %t68; output pixel mask\n" _ ws->out_pixmask);
    tracef("%t20.out_dpixmask *  %i %t68; output double-pixel mask\n" _ ws->out_dpixmask);
  }
a1646 5
  if (wp->is_it_jpeg)
  {
    ws->leave_r12_alone = TRUE;
    comment(ws, "Leave r12 unallocated, it contains the assembler module workspace pointer");
  }
a1647 5
  ptrs_save_mask = (1<<ws->next_free_reg) - 1;
  IFDEBUG(ldm_reg_list(ws, ptrregs, ptrs_save_mask, FALSE);)
  ptrs_save_size = SOURCE_BPPMASK || PLOTMASK ? 12 : 8;
  if (ws->odither) ptrs_save_size += 4;

a1648 15
  x_loop_save_mask = ((1<<ws->next_free_reg) - 1) & ~ptrs_save_mask;
  x_loop_save_size = 4 * ws->next_free_reg - ptrs_save_size;      /* size in bytes, used right at the end */
  /* Of the x-loop variables, no need to save r_inword/outword/maskinword/temp1/temp2 - set up every time round */
  if (ws->regnames.r_inword.regno != -1) {x_loop_save_mask &= ~(1 << ws->regnames.r_inword.regno); x_loop_save_size -= 4;}
  if (ws->regnames.r_outword.regno != -1) {x_loop_save_mask &= ~(1 << ws->regnames.r_outword.regno); x_loop_save_size -= 4;}
  if (ws->regnames.r_maskinword.regno != -1) {x_loop_save_mask &= ~(1 << ws->regnames.r_maskinword.regno); x_loop_save_size -= 4;}
  if (ws->regnames.r_temp1.regno != -1) {x_loop_save_mask &= ~(1 << ws->regnames.r_temp1.regno); x_loop_save_size -= 4;}
  if (ws->regnames.r_temp2.regno != -1) {x_loop_save_mask &= ~(1 << ws->regnames.r_temp2.regno); x_loop_save_size -= 4;}
  IFDEBUG(ldm_reg_list(ws, xregs, x_loop_save_mask, FALSE);)

  yrn = yloop_rn_count(wp, ws);
  onebank = yrn + ws->next_free_reg + ws->leave_r12_alone <= 13;
  comment(ws, onebank ? "The y loop variables will fit in registers too"
                      : "The y loop variables are overlaid on the x ones");
  if (!onebank) ws->next_free_reg = 4; /* Overlay the x-loop register allocations - but not ptr registers */
d1650 9
a1658 1
  if (!onebank) /* If two banks, be prepared to do LDM/STM for the y-loop bank */
d1660 11
a1670 2
    y_loop_save_mask = ((1<<ws->next_free_reg) - 1) & 0xfffffff0; /* not regs 0..3 */
    IFDEBUG(ldm_reg_list(ws, yregs, y_loop_save_mask, TRUE);)
d1672 2
d1677 1
d1681 1
a1681 26

  tracef("%t20.x_loop_save_size * %t28%i %t68.; Bytes of stack for x-loop variables\n" _ x_loop_save_size);
  tracef("%t20.ptrs_save_size * %t28%i %t68.; Bytes of stack for ptr variables\n" _ ptrs_save_size);
  comment(ws, "Save x-loop and pointer variables on the stack");
  IFDEBUG(do_sprintf(a, "STMDB   sp!,{%s,%s}", ptrregs,xregs);)
  /* Added by (GPS) to get round spilled reg bug. */
  if(ws->odither && SOURCE_16_BIT)
  {
    tracef("x_loop_save_mask = %x\n" _ x_loop_save_mask);
    x_loop_save_mask &= ~(1<<(ws->regnames.r_xcount.regno));
    x_loop_save_mask |= (1<<(ws->regnames.r_pixel.regno));
    tracef("x_loop_save_mask = %x\n" _ x_loop_save_mask);
    ins(ws, PUSH | x_loop_save_mask | ptrs_save_mask, a);
    x_loop_save_mask |= (1<<(ws->regnames.r_xcount.regno));
    x_loop_save_mask &= ~(1<<(ws->regnames.r_pixel.regno));
    comment(ws, "r_pixel pushed instead of x-count");
#ifdef DEBUG
    tracef("x_loop_save_mask = %x\n" _ x_loop_save_mask);
#endif
  }
  else
  {
    ins(ws, PUSH | x_loop_save_mask | ptrs_save_mask, a);
  }
  /* end added code...*/

d1685 1
d1687 1
a1687 5

  if(ws->odither && SOURCE_16_BIT)
  {
    MOV(R(r_xcount), OP2R(R(r_pixel)),                              "MOV     r_xcount,r_pixel                           ; set r_xcount to correct value");
  }
d1696 7
a1702 1
  if (!simple_y_scale(wp, ws))
d1704 5
a1708 3
    comment(ws, "At this point the ptr registers have been updated but not saved");
    IFDEBUG(do_sprintf(a,                                      "STMIA   sp,{%s}", ptrregs);)
    ins(ws, STMIA(R(sp)) | ptrs_save_mask, a);
d1710 4
a1740 11
  if (!onebank)
  {
    /* the x-loop variables are already set up, with inptr/outptr/maskinptr saved at new values */
    ADD(R(lr), R(sp), IMM(ptrs_save_size),                  "ADD     lr,sp,#ptrs_save_size");
    IFDEBUG(do_sprintf(a,                                      "STMDB   sp!,{%s} %t40; push y-loop variables", yregs);)
    ins(ws, PUSH | y_loop_save_mask, a);
    IFDEBUG(do_sprintf(a,                                      "LDMIA   lr,{%s} %t40; load x-loop variables", xregs);)
    ins(ws, LDMIA(R(lr)) | x_loop_save_mask, a); /* Reload the x-loop variables */
  }
  newline();

d1744 5
d1750 1
a1750 14
  if (onebank)
  {
    IFDEBUG(do_sprintf(a,                                      "LDMIA   sp,{%s,%s} %t40; reload x-loop and ptr registers", ptrregs, xregs);)
    ins(ws, LDMIA(R(sp)) | x_loop_save_mask | ptrs_save_mask, a);
  }
  else
  {
    IFDEBUG(do_sprintf(a,                                      "LDMIA   sp!,{%s} %t40; pop y-loop variables", yregs);)
    ins(ws, POP | y_loop_save_mask, a);
    newline();
    comment(ws, "Reload pointers to the start of a row");
    IFDEBUG(do_sprintf(a,                                      "LDMIA   sp,{%s} %t40; reload ptr registers", ptrregs);)
    ins(ws, LDMIA(R(sp)) | ptrs_save_mask, a);
  }
d1766 1
a1766 1
    if (SOURCE_BPPMASK || PLOTMASK)
a1768 2
    IFDEBUG(do_sprintf(a,                                      "STMIA   sp,{%s} %t40.; Save updated ptr registers", ptrregs);)
    ins(ws, STMIA(R(sp)) | ptrs_save_mask, a);
d1799 1
a1799 1
    if (SOURCE_BPPMASK || PLOTMASK)
d1809 1
a1809 1
  ADD(R(sp), R(sp), IMM(x_loop_save_size+ptrs_save_size),   "ADD     sp,sp,#x_loop_save_size+ptrs_save_size ; discard saved x-loop variables");
d1831 2
a1832 2
  if (wp->is_it_jpeg) key_word |= 1<<23;
  if (wp->is_it_jpeg && cinfo->jpeg_color_space == CS_GRAYSCALE) key_word |= 1<<24;
d1834 2
d1838 1
a1838 1
    key_word |= 1<<25;
d1842 1
d1844 2
a1845 2
  if (wp->is_it_jpeg && (wp->dither_truecolour & 1)) key_word |= 1<<28;
  if (wp->is_it_jpeg && (wp->dither_truecolour & 2)) key_word |= 1<<29;
a1848 1
     && wp->Log2bpp < wp->save_inlog2bpp /* and losing resolution (note; dithering 16bpp down to 15/12bpp not supported, so checking these values instead of PixelFormat values is OK) */
d1850 7
d1861 1
a1861 1
    key_word |= 1<<30; /* And flag this routine as containing dither code */
d1917 1
a1917 1
  tracef("Size of C workspace: %i.\n" _ ((char*)ws_end) - ((char*)ws));
d1919 1
d1924 16
a1939 2
  ws->masked = (gcol & 8) != 0;/* || PLOTMASK;*/
  ws->mask1bpp = ws->masked & (((wp->save_mode) >> 27) != SpriteType_Old);
d1942 1
a1942 2
  tracef("masked=%s                %t32. whether to use mask.\n" _ whether(ws->masked));
  tracef("1bpp mask=%s             %t32. whether mask is new format.\n" _ whether(ws->mask1bpp));
d1964 1
a1964 1
    if ((wp->save_mode >> 27) == 0)
d1968 1
a1968 1
      wp->trns_palette = 0;                                /* >>>> mainly for JPEG on RO3 */
d1986 1
d1989 1
d1994 1
d1996 2
d2056 1
a2056 2
    int in_modeflags,in_ncolour;
    _swix(OS_ReadModeVariable,_INR(0,1)|_OUT(2),wp->save_mode,VduExt_ModeFlags,&in_modeflags);
d2058 1
a2058 1
    ws->in_pixelformat = compute_pixelformat(in_ncolour,in_modeflags,wp->save_inlog2bpp);
d2064 1
a2064 1
  if(wp->ColourTTR != 0)
d2066 3
a2068 1
    if(wp->save_inlog2bpp >= 5)
d2071 1
a2071 1
      ws->ColourTTRFormat = ws->in_pixelformat & ~PixelFormat_Alpha;
d2074 5
a2078 2
  ws->pixel_expansion_mask = ws->pixel_expansion_shift = 0;
  ws->pixel_expansion_in = ws->pixel_expansion_out = NULL;
d2098 1
a2098 1
    p = (char*) (SOURCE_BPPMASK ? wp->save_maskinptr : (int) wp->save_inptr + wp->save_masko);
a2130 3
  /* If using a palette, ignore any translation table */
  if (wp->trns_palette != 0) wp->ColourTTR = 0;

d2152 1
a2152 22
  /* Look for unit translation table */
#ifdef DEBUG
  if (wp->ColourTTR != 0 && wp->BPP == (1<<wp->save_inlog2bpp)) /* only if table, and depth matches */
  {
    char *t = (char*) wp->ColourTTR;
    BOOL  same = TRUE;
    int   size = 1 << (1 << (wp->save_inlog2bpp == 5 ? 4 : wp->save_inlog2bpp));

    if (wp->save_xsize * wp->save_ysize > size) /* Unless huge table for tiny sprite */
    {
      for (i = 0; i < size; i++)
        if (t[i] != i) {same = FALSE; break;}
      if (same)
      {
        tracef("Unit translation table - discarded\n");
        wp->ColourTTR = 0;
        assert(0, ERROR_FATAL); /* These are now zapped by the assembler, so they shouldn't ever turn up. */
      }
    }
  }
#endif

d2166 3
a2171 1
#endif
@


4.13
log
@Adopt colour conversions from MigrateIJG8b branch
Now for every colour conversion there is a corresponding C function, allowing swapping between them for test purposes.
Here, 'ASMCOLOR' is selected and the C functions not even referenced in the makefile, see branch for use.
Permits use of USAT, for a small 1.5% speedup and smaller code.
Some other typedefs and comment shuffling copied over - should be harmless.

Version 1.50. Tagged as 'SprExtend-1_50'
@
text
@a16 804
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include "swis.h"
#include "commondefs.h"
#include "jinclude.h"
#include "putscaled.h"
#include "C:Global.h.Sprite"

/**************************************************************************
*                                                                         *
*    Macros.                                                              *
*                                                                         *
**************************************************************************/

#define SOURCE_32_BIT  (wp->save_inlog2bpp == 5)
#define SOURCE_16_BIT  (wp->save_inlog2bpp == 4)
#define SOURCED_16_BIT (wp->save_inlog2bpc == 4) /* like SOURCE_16_BIT but includes 16-bit double-pixels */
#define SOURCE_MASK    (ws->masked)
#define SOURCE_BPPMASK (ws->mask1bpp)
#define SOURCE_TABLE   ((wp->ColourTTR != 0) || (wp->trns_palette != 0))

#define DPIXEL_INPUT   (wp->save_inlog2bpp != wp->save_inlog2bpc)
#define DPIXEL_OUTPUT  (wp->BPP != wp->BPC)

#define PLOTMASK       ((wp->spritecode & 255) == SpriteReason_PlotMaskScaled)

#define DEST_32_BIT    (wp->BPP == 32)
#define DEST_16_BIT    (wp->BPP == 16)
#define DEST_1_BIT     (wp->BPC == 1)
#define DESTD_16_BIT   (wp->BPC == 16) /* like DEST_16_BIT but includes 16-bit double-pixels */

/**************************************************************************
*                                                                         *
*    Low-level debugging output.                                          *
*                                                                         *
**************************************************************************/

#ifdef DEBUG
#define tracef(args)     do_sprintf(0, args)
#define assert(x, y)     do_assert(__LINE__, x, y, NULL)
#define newline()        tracef("\n");
#define comment(ws,text) do_comment(text)
#define IFDEBUG(a) a
#include "tracing.c"
#else
#define tracef(args)     /* Nothing */
#define assert(x, y)     {if (!(x)) exit_erl(y, __LINE__);}
#define newline()        /* Nothing */
#define comment(ws,text) /* Nothing */
#define IFDEBUG(a)       /* Nothing */
#endif

/**************************************************************************
*                                                                         *
*    JPEG handling.                                                       *
*                                                                         *
**************************************************************************/

#ifdef ASMjpeg
#include "rojpeg.c"
#endif

/**************************************************************************
*                                                                         *
*    C Workspace declarations.                                            *
*                                                                         *
**************************************************************************/

/* Code buffers */
#define NBUFFERS 8       /* Number of code buffers */
#define BUFSIZE 256      /* words per buffer */
typedef struct
{
  int key_word;              /* descriptor for this code, or -1 if empty */
  int xadd;                  /* precise scale factors compiled into this code */
  int xdiv;
  int yadd;
  int ydiv;
  int outoffset;             /* output row offset compiled into this code */
  int code[BUFSIZE];         /* the code itself */
} code_buffer;
#define FOR_EACH_BUFFER(ptr) for (ptr = &ws->buffers[0]; ptr < &ws->buffers[NBUFFERS]; ptr++)

/* Labels - there's one of these for each label in the source we generate. */
typedef struct
{
  int *def;          /* where the label is, or 0 if not yet defined. */
  int *ref;          /* a reference to the label, to be filled in when it's defined. */
#ifdef DEBUG
  char *name;        /* textual name of the label - same as field name */
#endif
} label;

/* Each label must be added as a field to this structure. */
typedef struct
{
  #define FIRST_LABEL loop_y_repeat
  label loop_y_repeat;
#ifdef TESTDEBUG
  label test1;
  label test2;
#endif
  label loop_x_enter;
  label loop_x_repeat;
  label loop_x_exit;
  label l_masked;
  label loop_put_pixel_repeat;
  label loop_put_masked_repeat;
  label y_loop;
  label y_loop_enter;
  label y_loop_exit;
  label loop_delay;

  label x_evenstart;
  label x_oddmask;
  label x_aligned_loop;
  label x_aligned_enter;
  label x_alignmask1;
  label x_alignmask2;
  label x_misaligned;
  label x_misaligned_loop;
  label x_misaligned_enter;
  label x_misalignmask1;
  label x_misalignmask2;
  label x_2atatime_exit;
  label x_lastmask;
  label loop_x_exit1;
  label loop_x_exitskip;
  label loop1;
  label loop2;
  label plot_loopa;
  label plot_loop1;
  label plot_loop1a;
  label plot_loop1b;
  label plot_loop1c;
  label plot_loop2;
  label plot_loop3;
  label plot_loop4;
  label plot_loop4a;
  label plot_loop4b;
  label plot_loop4c;

  label last;
  #define LAST_LABEL last
  /* If you add a label, add giving it a name in check_workspace */
} labels_rec;
#define FOR_EACH_LABEL(ptr) for (ptr = &ws->labels.FIRST_LABEL; ptr <= &ws->labels.LAST_LABEL; ptr++)
#define L(name) (&(ws->labels.name))

/* Register names - one for each register name (the register numbers are allocated at compile time) */
typedef struct
{
  int regno;     /* the physical register number */
#ifdef DEBUG
  char *name;    /* the name, for trace output */
#endif
} regname;

/* Each register name must be added as a field to this structure. */
typedef struct
{
  #define FIRST_REGISTER r_pixel
  regname r_pixel;
  regname r_inptr;
  regname r_inshift;
  regname r_inword;
  regname r_maskinptr;
  regname r_maskinword;
  regname r_maskinshift;
  regname r_masko;
  regname r_temp1;
  regname r_temp2;
  regname r_c1632;
  regname r_oditheradd;
  regname r_blockroutine;
  regname r_ecfindex;
  regname r_bgcolour;
  regname r_fetchroutine;
  regname r_outptr;
  regname r_outword;
  regname r_outshift;
  regname r_table;
  regname r_xsize;
  regname r_xcount;
  regname r_ysize;
  regname r_ycount;
  regname r_inoffset;
  regname r_maskinoffset;
  regname r_in_pixmask;    /* only used by 2-at-a-time loop */

  regname r1;
  regname r2;
  regname r3;
  regname wp;
  regname sp;
  regname lr;
  regname pc;
  #define LAST_REGISTER pc
} regnames_rec;
#define FOR_EACH_REGISTER_NAME(ptr) for (ptr = &ws->regnames.FIRST_REGISTER; ptr <= &ws->regnames.LAST_REGISTER; ptr++)

#if 0
#define R(reg) rr(&ws->regnames.reg)
static int rr(regname *r)
{
  /* Makes code bigger, lots of string clashes - rats! */
  if (r->regno == -1) tracef("Register %s not defined\n" _ r->name);
  assert(r->regno != -1, ERROR_FATAL);
  return r->regno;
}
#else
#define R(reg) rr(ws->regnames.reg.regno)
static int rr(int r)
{
  /* Assert that the register is at least set */
  assert(r != -1, ERROR_FATAL);
  return r;
}
#endif

/* The structure containing all workspace - essentially our static variables. */
#define CHECK_CODE 123456789
typedef struct
{
  /* Initialisation */
  int  check_code;

  /* Code buffer management */
  int  build_buffer;             /* Buffer currently being built, or next to build */
  int *compile_base;
  int *compile_ptr;              /* where to put next instruction */
  int *compile_lim;

  /* Label control and allocation */
  labels_rec labels;             /* each label, and where it is in the generated code */

  /* Register control and allocation */
  regnames_rec regnames;         /* physical assignment of each register name */
  int  next_free_reg;            /* allocator of physical registers, as they are needed. */
  BOOL leave_r12_alone;          /* Leave assembler 'wp' in place during compiled code */

  int  gcol;                     /* GCOL action */
  BOOL masked;                   /* whether to use mask */
  BOOL mask1bpp;                 /* whether mask is 1bpp mask */

  int  odither;                  /* If 0, then there's no ordered dither. If non-0, number of bits - 1 being truncated by dither. */
#if 0
  int  odither_eorvalue;         /* value for eor alternation along a line */
  int  odither_shift;            /* offset of two-bit dither value in r_oditheradd */
#endif

  /* Assemble-time constants */
  int  in_bpp;
  int  in_bpc;                   /* Same as bpp unless double-pixel, in which case double bpp */
  int  in_pixmask;
  int  mask_bpp;
  int  mask_bpc;
  int  mask_pixmask;
  int  out_l2bpp;                /* not provided in wp */
  int  out_l2bpc;                /* ditto */
  int  out_pixmask;              /* mask for one pixel */
  int  out_dpixmask;
  int  out_ppw;                  /* pixels per word */
  int  out_l2ppw;
  BOOL cal_table_simple;         /* If true, a simple table lookup is possible */

  /* Space for compiled code, near the end so most field accesses have only a small offset. */
  code_buffer buffers[NBUFFERS];

  /* Check for workspace overwritten */
  int  check_code2;
} workspace;

static void check_workspace(workspace *ws)
/* Basic validity checks, and initialise if this is the first time. */
{
  assert(ws != 0, ERROR_NO_MEMORY);
  if (ws->check_code != CHECK_CODE)
  {
    code_buffer *p;
    tracef("Initialising workspace.\n");
    ws->check_code = CHECK_CODE;
    ws->check_code2 = CHECK_CODE;
    ws->build_buffer = 0;
    FOR_EACH_BUFFER(p) p->key_word = -1;

#ifdef DEBUG
    {
      label *l;

      /* Set up textual names of all the labels */
      FOR_EACH_LABEL(l) l->name = 0;
      #define LN(lname) ws->labels.lname.name = #lname;
      LN(loop_y_repeat)
#ifdef TESTDEBUG
      LN(test1)
      LN(test2)
#endif
      LN(loop_x_enter)
      LN(loop_x_repeat)
      LN(loop_x_exit)
      LN(l_masked)
      LN(loop_put_pixel_repeat)
      LN(loop_put_masked_repeat)
      LN(y_loop)
      LN(y_loop_enter)
      LN(y_loop_exit)
      LN(loop_delay)

      LN(x_evenstart)
      LN(x_oddmask)
      LN(x_aligned_loop)
      LN(x_aligned_enter)
      LN(x_alignmask1)
      LN(x_alignmask2)
      LN(x_misaligned)
      LN(x_misaligned_loop)
      LN(x_misaligned_enter)
      LN(x_misalignmask1)
      LN(x_misalignmask2)
      LN(x_2atatime_exit)
      LN(x_lastmask)
      LN(loop_x_exit1)
      LN(loop_x_exitskip)
      LN(loop1)
      LN(loop2)
      LN(plot_loopa)
      LN(plot_loop1)
      LN(plot_loop1a)
      LN(plot_loop1b)
      LN(plot_loop1c)
      LN(plot_loop2)
      LN(plot_loop3)
      LN(plot_loop4)
      LN(plot_loop4a)
      LN(plot_loop4b)
      LN(plot_loop4c)

      LN(last)
      /* Check he's got them all */
      FOR_EACH_LABEL(l) assert(l->name != 0, ERROR_FATAL);
    }
    {
      regname *r;

      FOR_EACH_REGISTER_NAME(r) r->name = 0;
      #define RNN(rname) ws->regnames.rname.name = #rname;
      RNN(r_pixel)
      RNN(r_inptr)
      RNN(r_inshift)
      RNN(r_inword)
      RNN(r_maskinptr)
      RNN(r_maskinword)
      RNN(r_maskinshift)
      RNN(r_masko)
      RNN(r_temp1)
      RNN(r_temp2)
      RNN(r_c1632)
      RNN(r_oditheradd)
      RNN(r_blockroutine)
      RNN(r_ecfindex)
      RNN(r_bgcolour)
      RNN(r_fetchroutine)
      RNN(r_outptr)
      RNN(r_outword)
      RNN(r_outshift)
      RNN(r_table)
      RNN(r_xsize)
      RNN(r_xcount)
      RNN(r_ysize)
      RNN(r_ycount)
      RNN(r_inoffset)
      RNN(r_maskinoffset)
      RNN(r_in_pixmask)

      RNN(r1)
      RNN(r2)
      RNN(r3)
      RNN(wp)
      RNN(sp)
      RNN(lr)
      RNN(pc)
      FOR_EACH_REGISTER_NAME(r) assert(r->name != 0, ERROR_FATAL);
      ws->leave_r12_alone = FALSE;
    }
#endif
  }
  assert(ws->check_code2 == CHECK_CODE, ERROR_FATAL);
}

#ifdef DEBUG
static void dump_asm_workspace(asm_workspace *wp)
{
  /* Oddly spaced out to allow it to be easily lined up with the structure definition */
  tracef("Assembler workspace at %x:\n" _ wp);
  tracef("save_outoffset=%i        %t32. byte offset between output rows - SUBTRACT for next row.\n" _ wp->save_outoffset);
  tracef("save_inoffset=%i         %t32. byte offset between input rows - SUBTRACT for next row.\n" _ wp->save_inoffset);
  tracef("save_inptr=0x%x          %t32. word address of input pixels.\n" _ wp->save_inptr);
  tracef("save_outptr=0x%x         %t32. address of word containing first output pixel.\n" _ wp->save_outptr);
  tracef("save_ydiv=%i             %t32. subtracter value for y scale.\n" _ wp->save_ydiv);
  tracef("save_yadd=%i             %t32. adder value for y scale.\n" _ wp->save_yadd);
  tracef("save_ysize=%i            %t32. number of output rows.\n" _ wp->save_ysize);
  tracef("save_ycount=%i           %t32. total of ymag/ydiv sum, for y scale factor\n" _ wp->save_ycount);
  newline();
  
  tracef("save_inshift=%i          %t32. bit shift of first pixel.\n" _ wp->save_inshift);


  tracef("save_xsize=%i            %t32. number of output pixels per row.\n" _ wp->save_xsize);
  tracef("save_xcount=%i           %t32. total of xmag/xdiv sum, for x scale factor\n" _ wp->save_xcount);
  tracef("save_ecfptr=0x%x         %t32. ECF pointer - only useful if plotting the mask.\n" _ wp->save_ecfptr);
  tracef("save_ecflimit=0x%x       %t32. ECF limit - only useful if plotting the mask.\n" _ wp->save_ecflimit);

  tracef("save_xdiv=%i             %t32. subtracter value for x scale.\n" _ wp->save_xdiv);
  tracef("save_xadd=%i             %t32. adder value for x scale\n" _ wp->save_xadd);
  newline();
  tracef("save_masko=%i            %t32. if not 1bpp mask then this is mask data offset from inptr. Otherwise...\n" _ wp->save_masko);
  tracef("save_xcoord=%i           %t32. pixel x coordinate of first output pixel.\n" _ wp->save_xcoord);
  tracef("save_ycoord=%i           %t32. pixel y coordinate of first output pixel.\n" _ wp->save_ycoord);





  tracef("save_xmag=%i             %t32. adder value for x scale?\n" _ wp->save_xmag);
  tracef("save_ymag=%i             %t32. adder value for y scale?\n" _ wp->save_ymag);
  newline();

  tracef("save_inlog2bpp=%i        %t32. log 2 bits per pixel of input.\n" _ wp->save_inlog2bpp);
  tracef("save_inlog2bpc=%i        %t32. log 2 bits per character of input (only different for double-pixels).\n"
                                   _ wp->save_inlog2bpc);
  tracef("save_mode=%i (>>27 = %i) %t32. mode number/pointer of sprite - 1bpp sprites have hi bits set.\n" _ wp->save_mode _ wp->save_mode >> 27);
  newline();

  tracef("save_maskinshift=%i      %t32. initial bit shift within mask word.\n" _ wp->save_maskinshift);
  tracef("save_maskinptr=0x%x      %t32. word address of mask (or 0 if there isn't one).\n" _ wp->save_maskinptr);
  tracef("save_maskinoffset=%i     %t32. byte offset between mask rows - SUBTRACT for next row.\n" _ wp->save_maskinoffset);
  newline();

  tracef("BPP=%i                   %t32. bits per pixel of output.\n" _ wp->BPP);
  tracef("BPC=%i                   %t32. bits per character of output (only different for double pixels).\n" _ wp->BPC);
  tracef("ColourTTR=0x%x           %t32. translation table or palette.\n" _ wp->ColourTTR);
  tracef("trns_palette=0x%x        %t32. if non-0 ignore TTR and use this palette instead.\n" _ wp->trns_palette);
  tracef("spritecode=%i (& 255 = %i) %t32. SpriteOp - 52 for PutSpriteScaled, 50 for PlotMaskScaled.\n" _ wp->spritecode _ wp->spritecode & 255);
  tracef("bgcolour=%i              %t32. Background colour (only valid if plotting the mask)\n" _ wp->bgcolour);
  newline();
}
#endif

#ifdef TESTDEBUG
static void dump_workspace(workspace *ws)
{
  code_buffer *p;

  tracef("Dumping workspace.\n");
  #define DUMPINT(field) tracef("%s = %i.\n" _ #field _ ws->field);
  DUMPINT(build_buffer)
  FOR_EACH_BUFFER(p) tracef("buffer->keyword = %i.\n" _ p->key_word);
}
#endif

/**************************************************************************
*                                                                         *
*    Low-level instruction generation.                                    *
*                                                                         *
**************************************************************************/

/* Condition codes */
#define EQ 0xf0000000      /* It's 0 really - frigged so that 0 can be 'always' - the usual case. */
#define NE 0x10000000
#define CS 0x20000000
#define CC 0x30000000
#define MI 0x40000000
#define PL 0x50000000
#define VS 0x60000000
#define VC 0x70000000
#define HI 0x80000000
#define LS 0x90000000
#define GE 0xa0000000
#define LT 0xb0000000
#define GT 0xc0000000
#define LE 0xd0000000
#define AL 0xe0000000
#define NV 0xDONOTUSE

/* Branches */
#define B  0x0a000000
#define BL 0x0b000000
#define B_OFFSET_MASK 0x00ffffff /* and with this for negative offsets */

/* ALU ops */
#define S  (1<<20)
#define AND(dst,op1,rest,str)      ins(ws,(0x0 << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define EOR(dst,op1,rest,str)      ins(ws,(0x1 << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define SUB(dst,op1,rest,str)      ins(ws,(0x2 << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define RSB(dst,op1,rest,str)      ins(ws,(0x3 << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define ADD(dst,op1,rest,str)      ins(ws,(0x4 << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define ADC(dst,op1,rest,str)      ins(ws,(0x5 << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define SBC(dst,op1,rest,str)      ins(ws,(0x6 << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define RSC(dst,op1,rest,str)      ins(ws,(0x7 << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define TST(op1,rest,str)          ins(ws,(0x8 << 21) | S | OP1R(op1) | (rest), str)
#define TEQ(op1,rest,str)          ins(ws,(0x9 << 21) | S | OP1R(op1) | (rest), str)
#define CMP(op1,rest,str)          ins(ws,(0xa << 21) | S | OP1R(op1) | (rest), str)
#define CMN(op1,rest,str)          ins(ws,(0xb << 21) | S | OP1R(op1) | (rest), str)
#define ORR(dst,op1,rest,str)      ins(ws,(0xc << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define MOV(dst,rest,str)          ins(ws,(0xd << 21) | DSTR(dst) | (rest), str)
#define BIC(dst,op1,rest,str)      ins(ws,(0xe << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define MVN(dst,rest,str)          ins(ws,(0xf << 21) | DSTR(dst) | (rest), str)

#define ADD_OPCODE (0x4 << 21)
#define SUB_OPCODE (0x2 << 21)
#define MOV_OPCODE (0xd << 21)

#define DSTR(x) ((x) << 12)          /* destination - ignored by TST/TEQ/CMP/CMN */
#define OP1R(x) ((x) << 16)          /* first operand */
#define OP2R(x) ((x) << 0)           /* if !IMM */
#define IMM(x) ((x) | (1<<25))       /* an 8-bit unsigned field */
#define IMMROR(x) ((x) << 7)         /* an EVEN number to rotate right IMM by */

#define LSLI(x) (((x) << 7) | 0x00)   /* 5-bit immed shift applied to OP2R */
#define LSRI(x) (((x) << 7) | 0x20)
#define ASRI(x) (((x) << 7) | 0x40)
#define RORI(x) (((x) << 7) | 0x60)

#define LSLR(x) (((x) << 8) | 0x10)   /* shift register applied to OP2R */
#define LSRR(x) (((x) << 8) | 0x30)
#define ASRR(x) (((x) << 8) | 0x50)
#define RORR(x) (((x) << 8) | 0x70)

/* Load and store ops */
#define LDR(reg,basereg)  (0x04100000 | ((reg) << 12)| ((basereg) << 16))
#define STR(reg,basereg)  (0x04000000 | ((reg) << 12)| ((basereg) << 16))
#define LDRB(reg,basereg) (0x04500000 | ((reg) << 12)| ((basereg) << 16))
#define STRB(reg,basereg) (0x04400000 | ((reg) << 12)| ((basereg) << 16))

#define WRITEBACK (1 << 21)
#define ADDOFFSET (1 << 23) /* else subtract */
#define PREADD (1 << 24) /* else post */

#define OFFSET(x) (PREADD | ADDOFFSET | (x))        /* normal simple index */
#define NEGOFFSET(x) (PREADD | (x))                 /* subtract offset */
#define PREINC(x) (WRITEBACK | ADDOFFSET | PREADD | (x))
#define PREDEC(x) (WRITEBACK | PREADD | (x))
#define POSTINC(x) (ADDOFFSET | (x))                /* The manual says, do not set WRITEBACK if doing post-addition */
#define POSTDEC(x) ((x))                            /* writeback will always occur, setting it is does LDRT/LDRBT */

#define PUSH (0x08000000 | (13<<16) /* register 13 */ \
                         | (1<<21) /* write-back */ \
                         | (1<<24) /* add offset before transfer */)
#define POP  (0x08000000 | (13<<16) /* register 13 */ \
                         | (1<<20) /* load from memory */ \
                         | (1<<21) /* write-back */ \
                         | (1<<23) /* add, not subtract */ )

#define LDMIA(reg) (0x08000000 | (reg<<16) /* register to load from */ \
                               | (1<<20) /* load from memory */ \
                               | (1<<23) /* add, not subtract */ )

#define STMIA(reg) (0x08000000 | (reg<<16) /* register to load from */ \
                               | (1<<23) /* add, not subtract */ )

/* Supervisor call */
#define SWI(swino) (0x0F000000 | swino)

/* Indexed load - LSL shift assumed - writeback or negative not covered */
#define INDEX(reg, shift) ((1<<25) | OFFSET(0) | OP2R(reg) | LSLI(shift))

/* Offset in assembler workspace */
#define WP_OFFSET(field) OFFSET(((char*)&(wp->field)) - ((char*)&(wp->WP_FIRST_FIELD)))

/* Define an assembler register */
#define RN(name,no,describe) set_regname(ws, &ws->regnames.name, no, describe);

#ifdef DEBUG
static void ldm_reg_list(workspace *ws, char *a, int regmask, BOOL lastname)
/* Construct a string in a which can be placed in curly brackets, describing
 * a LDM/STM instruction. If lastname then find the last such register name in
 * the case of duplicates - eg. the y-loop name rather than the x-loop name
 * for the same physical register.
 */
{
  int i;
  regname *r;
  BOOL found;
  char *aptr;

  a[0] = 0;
  for (i = 0; i <= 15; i++) /* for each physical register */
  {
    if ((regmask & (1<<i)) != 0) /* find a name for this register */
    {
      found = FALSE;
      aptr = a;
      while (*aptr != 0) aptr++; /* points at the null at the end of the string */
      FOR_EACH_REGISTER_NAME(r)
      {
        if (r->regno == i)
        {
          *aptr = 0; /* If lastname and finding it again, delete last one */
          if (a[0] != 0) strcat(aptr, ",");
          strcat(aptr, r->name);
          found = TRUE;
          if (!lastname) break;
        }
      }
      assert(found, ERROR_FATAL);
    }
  }
}
#endif

#ifdef DEBUG
static void ins(workspace *ws, int w, char *description)
#else
#define ins(ws,w,description) do_ins(ws,w)
static void do_ins(workspace *ws, int w)
#endif
/* Put an instruction into the output buffer.
 * When debugging an assembler listings is generated too. These can be fed through
 * objasm, and the results compared with the opcodes that I generate.
 * Columns of assembler output:
 * addressX  opcodeXX  label   opcodes regs                            comment
 * ^0        ^10       ^20     ^28     ^36                             ^68
 */
{
  int ccode = w & 0xf0000000;

  /* Handle the AL/EQ condition codes being wrong, so that 0 can be AL elsewhere. */
  if (ccode == 0xf0000000) w = w & 0x0fffffff;   /* EQ code */
  else if (ccode == 0) w = w | 0xe0000000;       /* AL code */
  /* All others are per the ARM expects */
  tracef("%x  %x  %t28.%s\n" _
    (ws->compile_ptr - ws->compile_base) * sizeof(int) _
    w _ description); /* pseudo-assembler format of output */

  assert(ws->compile_ptr < ws->compile_lim, ERROR_NO_MEMORY); /* Check the buffer is big enough */
  *(ws->compile_ptr)++ = w; /* Store at then increment P% */
}

#ifdef DEBUG
#define DEFINE_LABEL(lab,describe) define_label(ws, L(lab), describe);
static void define_label(workspace *ws, label *lab, char *description)
#else
#define DEFINE_LABEL(lab,describe) define_label(ws, L(lab));
static void define_label(workspace *ws, label *lab)
#endif
/* Define a label, and fill in a forward reference to it if necessary. */
{
   assert(lab->def == 0, ERROR_FATAL); /* Check not defined twice */
   lab->def = ws->compile_ptr;
   tracef("%t20.%s%t68.; %s\n" _ lab->name _ description);
   if (lab->ref != 0)
   {
     int newvalue = *(lab->ref) | (B_OFFSET_MASK & (lab->def - (lab->ref + 2))); /* compute offset */
     tracef("%t20.; Zapping forward ref instruction at %x to be %x.\n" _
       sizeof(int) * (lab->ref - ws->compile_base) _ newvalue);
     *(lab->ref) = newvalue;
     lab->ref = 0;
   }
}

#ifdef DEBUG
static void branch(workspace *ws, unsigned int opcode, label *lab, char *description)
#else
#define branch(ws,opcode,lab,description) do_branch(ws,opcode,lab)
static void do_branch(workspace *ws, unsigned int opcode, label *lab)
#endif
/* Compile a branch instruction to a label. The opcode includes the condition code. */
{
  if (lab->def == 0) /* Forward reference */
  {
#ifdef DEBUG
    if (lab->ref != 0)
      tracef("Already referenced at 0x%x\n" _ sizeof(int) * (lab->ref - ws->compile_base));
#endif
    assert(lab->ref == 0, ERROR_FATAL); /* Check for two forward refs to same label */
    lab->ref = ws->compile_ptr;
    ins(ws, opcode, description); /* Just give as offset 0 for now */
  }
  else
  {
    assert(lab->ref == 0, ERROR_FATAL);
    ins(ws,
      opcode | (B_OFFSET_MASK & (lab->def - (ws->compile_ptr + 2))), description);
  }
}

#ifdef DEBUG
static void set_regname(workspace *ws, regname *r, int regno, char *describe)
#else
#define set_regname(ws,r,regno,describe) do_set_regname(ws,r,regno)
static void do_set_regname(workspace *ws, regname *r, int regno)
#endif
/* Allocate a physical register number. If regno is -1 then allocate an
 * as-yet-unused one, otherwise it's a specific register number.
 */
{
  if (regno == -1) /* allocate a number, one of 0..12 */
  {
    regno = ws->next_free_reg;
    ws->next_free_reg++;
    assert(regno >= 0 && regno <= 12, ERROR_FATAL); /* Check for register overflow */
    if (regno == 12) assert(!ws->leave_r12_alone, ERROR_FATAL);
  }
  r->regno = regno;
  tracef("%t20.%s%t27 RN %t36.%i %t68.; %s\n" _ r->name _ r->regno _ describe);
}

static void align16(asm_workspace *wp, workspace *ws)
/* Align next instruction to quadword boundary */
{
  UNUSED(wp);
  while (((int) ws->compile_ptr) & 15 != 0)
    MOV(R(r_pixel), OP2R(R(r_pixel)),                        "MOV     r_pixel,r_pixel                 ; align to 16-byte boundary");
}

#if defined(DEBUG_TML) && defined(DEBUG)
static void write_reg(workspace *ws, regname *reg)
/* Sppol the register to the TML hardware */
{
    comment(ws, "Write Register to TML card");
    tracef("Register to be output is... %s\n" _ reg->name);
    ins(ws, PUSH | (1<<10) | (1<<11) | 1 | (1<<1) | (1<<14),        "STMDB   sp!,{r0,r1,r10,r11,r14}          ; prepare to call SWI");
    ins(ws, MOV_OPCODE | DSTR(1) | OP2R(reg->regno),                "MOV     r1,r_somereg");
    ins(ws, MOV_OPCODE | DSTR(0) | OP2R(1),                         "MOV     r0,r1");
    AND(0, 0, IMM(0xff),                                            "AND     r0,r0,#255 ");
    ins(ws, SWI(HostFS_WriteC),                                     "SWI     HostFS_WriteC                    ; convert r1 value");
    ins(ws, MOV_OPCODE | DSTR(0) | OP2R(1) | LSRI(8),               "MOV     r0,r1 LSR #8");
    AND(0, 0, IMM(0xff),                                            "AND     r0,r0,#255                               ");
    ins(ws, SWI(HostFS_WriteC),                                     "SWI     HostFS_WriteC                    ; convert r1 value");
    ins(ws, MOV_OPCODE | DSTR(0) | OP2R(1) | LSRI(16),              "MOV     r0,r1 LSR #16");
    AND(0, 0, IMM(0xff),                                            "AND     r0,r0,#255                               ");
    ins(ws, SWI(HostFS_WriteC),                                     "SWI     HostFS_WriteC                    ; convert r1 value");
    ins(ws, MOV_OPCODE | DSTR(0) | OP2R(1) | LSRI(24),              "MOV     r0,r1 LSR #24");
    AND(0, 0, IMM(0xff),                                            "AND     r0,r0,#255                               ");
    ins(ws, SWI(HostFS_WriteC),                                     "SWI     HostFS_WriteC                    ; convert r1 value");
    ins(ws, POP | (1<<10) | (1<<11) | 1 | (1<<1) | (1<<14),         "LDMIA   sp!,{r0,r1,r10,r11,r14}          ; restore after calling SWI");
    comment(ws, "");
}
#endif

static void compile_buffer_init(asm_workspace *wp, workspace *ws)
/* We intend to compile some code. Pick a buffer to use, and set up
 * for generating into it. We use a simple round-robin for reusing buffers,
 * rather than attempting to do LRU.
 */
{
  label *p;
  regname *r;
  code_buffer *b = &(ws->buffers[ws->build_buffer]);
  ws->compile_base = &(b->code[0]);
  ws->compile_ptr = ws->compile_base;
  ws->compile_lim = ws->compile_base + BUFSIZE;
  FOR_EACH_LABEL(p) {p->def = 0; p->ref = 0;} /* zap all the labels to be undefined. */
  FOR_EACH_REGISTER_NAME(r) r->regno = -1;
  ws->next_free_reg = 0; /* allocate registers from 0 */
  tracef("Compile buffer initialised.\n");
  tracef("%t20; Blitting code for %s, scale factors %i:%i,%i:%i outoffset %x\n" _
    (PLOTMASK ? "PlotMaskScaled" : "PutSpriteScaled") _
    b->xadd - b->xdiv _ b->xdiv _ b->yadd _ b->ydiv _ wp->save_outoffset);
  tracef("%t20; gcol action=%i in-bpp=%i out-bpp=%i in-dpix=%s out-dpix=%s mask=%s 1bppmask=%s palette=%s table=%s\n" _
    ws->gcol _ (1<<wp->save_inlog2bpp) _ wp->BPP _
    whether(DPIXEL_INPUT) _ whether(DPIXEL_OUTPUT) _
    whether(SOURCE_MASK) _ whether(SOURCE_BPPMASK) _
    whether(wp->trns_palette != 0) _ whether(wp->ColourTTR != 0));
  tracef("%t20.; Generated by compiler of (%s %s)\n" _ __DATE__ _ __TIME__);
  comment(ws, "Get register and workspace definitions, turn on listing");
  tracef("%t28.GET     w.GenHdr\n");
  tracef("%t28.OPT     1\n");
  RN(r1, 1, "r1");
  RN(r2, 2, "r2");
  RN(r3, 3, "r3");
  RN(wp, 12, "workspace pointer")
  RN(sp, 13, "stack pointer")
  RN(lr, 14, "link register")
  RN(pc, 15, "program counter")
  ws->leave_r12_alone = FALSE;  /* by default, compiled code does not have module workspace pointer */
  UNUSED(wp);
}

static void compile_buffer_done(workspace *ws)
/* Finished compiling code sequence. */
{
#ifdef DEBUG
  label *p;
#endif

  tracef("%t28.END\n");
  tracef("Compile buffer done, %i words generated.\n" _ ws->compile_ptr - ws->compile_base);
  /* Increment pointer for next buffer to reuse. */
  ws->build_buffer++;
  if (ws->build_buffer >= NBUFFERS) ws->build_buffer = 0;
#ifdef DEBUG
  /* Check no unresolved references to labels */
  FOR_EACH_LABEL(p)
  {
    IFDEBUG(if(p->ref != 0) tracef("Unresolved reference to label %s at %x\n" _ p->name _ sizeof(int) * (p->ref - ws->compile_base));)
    assert(p->ref == 0, ERROR_FATAL);
  }
#endif
  /* ws->compile_base can be used as the base of the resulting procedure. */
}

d125 1
a236 7
      {
        /* Work out whether we need 16->32 or 32->16 transformations, with their temp registers
         * So, mirror the structure of translate_pixel
         */
        int pixl2bpp = wp->save_inlog2bpp;

        if ((wp->trns_palette != 0) && (wp->BPP != 16)) pixl2bpp = 5;
d238 1
a238 8
        if (pixl2bpp == 5 && wp->BPP != 32) need_temps = 2;

        if (pixl2bpp == 4 && wp->BPP == 32)
        {
          need_temps = 2;
          RN(r_c1632, -1, "constant for 16->32 transformation")
        }
      }
a317 27
/* Loading a constant index from the workspace pointer */
#define LDR_WP(reg,value) ins(ws, LDR(R(reg),R(wp)) + WP_OFFSET(value), \
                              "LDR     " #reg "," #value);

#ifdef DEBUG
  #define LDR_WP_C(reg,value, comment)                                \
  {                                                                   \
    char a[256];                                                      \
    do_sprintf(a, "LDR     " #reg "," #value " %t40.; " comment);        \
    ins(ws, LDR(R(reg),R(wp)) + WP_OFFSET(value), a);                 \
  }
#else
  #define LDR_WP_C(reg,value, comment) ins(ws, LDR(R(reg),R(wp)) + WP_OFFSET(value), 0);
#endif

/* Loading a constant index from a register */
#ifdef DEBUG
  #define LDR_INDEX(destreg,indexreg,offset,comment)                                      \
  {                                                                                       \
    char a[256];                                                                          \
    do_sprintf(a, "LDR     " #destreg ",[" #indexreg ", #%i] %t40.; " comment, offset);      \
    ins(ws, LDR(R(destreg),R(indexreg)) | OFFSET(offset), a);                             \
  }
#else
  #define LDR_INDEX(destreg,indexreg,offset,comment) ins(ws, LDR(R(destreg),R(indexreg)) | OFFSET(offset), 0);
#endif

a370 4
#if 0
    LDR_WP_C(r_inshift, save_inshift, "input initial shift (for block move)")
    RSB(R(r_inshift), R(r_inshift), IMM(32),                 "RSB     r_inshift,r_inshift,#32         ; pixels of first word to transfer, in 1..32");
#else
a371 1
#endif
a381 1
      LDR_WP(r_bgcolour, bgcolour) /* background colour pixel */
a388 4
#if 0
        LDR_WP(r_inshift, save_inshift)
        RSB(R(r_inshift), R(r_inshift), IMM(32),             "RSB     r_inshift,r_inshift,#32         ; pixels still to shift");
#else
a389 1
#endif
d439 2
a440 48
    if (ws->regnames.r_c1632.regno != -1) /* Generate binary constant 0000000011100000 1110000011100000 */
    {
      MOV(R(r_c1632), IMM(0xe0),                          "MOV     r_c1632,#&e0                    ; 0000000000000000 0000000011100000");
      ORR(R(r_c1632), R(r_c1632),OP2R(R(r_c1632))|LSLI(8),"ORR     r_c1632,r_c1632,r_c1632,LSL #8  ; 0000000000000000 1110000011100000");
      ORR(R(r_c1632), R(r_c1632),OP2R(R(r_c1632))|LSLI(8),"ORR     r_c1632,r_c1632,r_c1632,LSL #8  ; 0000000011100000 1110000011100000");
    }

    if (ws->odither)
    {
      /* We use ordered dither to attempt to increase the output resolution by almost two bits.
       * This only happens for a 16bpp or 32bpp source that's being truncated somewhat.
       * A square of output pixels has the following binary addition values:
       *              11    01
       *              00    10
       * These values are added to the value of each or R/G/B, just before those values are
       * truncated or looked up in a table, shifted so that we add to the bits which are
       * just about to be discarded.
       * We keep the value to add in r_oditheradd.
       * To proceed along the x axis we EOR by 10 every output pixel.
       * We must also EOR by 01 every line.
       * The starting value must be aligned with the origin of the output.
       */
      comment(ws, "Compute initial dither addition value - bit 0 changes every y, bit 1 every x");
      LDR_WP(r_pixel, save_xcoord)
      AND(R(r_pixel), R(r_pixel), IMM(1),                        "AND     r_pixel,r_pixel,#1               ; least sig bit of x, for dither");
      LDR_WP(r_oditheradd, save_ycoord)
      AND(R(r_oditheradd), R(r_oditheradd), IMM(1),              "AND     r_oditheradd,r_oditheradd,#1     ; least sig bit of y, for dither");
      EOR(R(r_pixel),R(r_pixel),OP2R(R(r_oditheradd)),           "EOR     r_pixel,r_pixel,r_oditheradd     ; if we start Y off on an odd footing, invert x as well");
      ORR(R(r_oditheradd), R(r_oditheradd),
      OP2R(R(r_pixel)) | LSLI(1),                                "ORR     r_oditheradd,r_oditheradd,r_pixel,LSL #1 ; dither add value");

      /* The dither should start based on the current ECF offset */
      MOV(R(r_pixel),IMM(0x10) | IMMROR(24),                     "MOV     r_pixel,#&1000                   ; prepare to get ECFYOffset");
      LDR_INDEX(r_pixel,r_pixel,0x1FC,"get kernel variable ECFYOffset from &11FC")
      TST(R(r_pixel),IMM(1),                                     "TST     r_pixel,#1                       ; is Y ECF offset odd?");
      EOR(R(r_oditheradd),R(r_oditheradd),NE | IMM(3),           "EORNE   r_oditheradd,r_oditheradd,#3     ; if so, change ordered dither origin to match");
      MOV(R(r_pixel),IMM(0x10) | IMMROR(24),                     "MOV     r_pixel,#&1000                   ; prepare to get ECFShift");
      LDR_INDEX(r_pixel,r_pixel,0x1F8,"get kernel variable ECFShift from &11F8")
      TST(R(r_pixel),IMM(wp->BPP),                               "TST     r_pixel,#out_bpp                 ; is ECF Shift an odd number of pixels?");
      EOR(R(r_oditheradd),R(r_oditheradd),NE | IMM(2),           "EORNE   r_oditheradd,r_oditheradd,#2     ; if so, change ordered dither origin to match");

      /* Shift the dither value to the top of the register. */
      {
        IFDEBUG(char a[256];)
        IFDEBUG(do_sprintf(a, "MOV     r_oditheradd,r_oditheradd,LSL #%i %t40; shift to top of word", 23 + ws->odither);)
        MOV(R(r_oditheradd), OP2R(R(r_oditheradd)) | LSLI(23 + ws->odither), a);
      }
    }
d442 1
d458 1
a458 1
    MOV(R(r_outshift),OP2R(R(r_outshift)) | LSLI(ws->out_l2bpc),  "MOV     r_outshift,r_outshift,LSL #out_l2bpc ; bit offset of start, in 0..31");
a469 10
#if 0
      AND(R(r_ecfindex), R(r_pixel), IMM(ws->out_ppw),          "AND     r_ecfindex,r_pixel,#out_ppw  ; pixels into ECF pattern");
      /* Convert from pixels, to byte offset into ECF line - either 0 or 4 */
      if (ws->out_l2ppw > 2) /* > 4 output pixels per word */
        MOV(R(r_ecfindex), OP2R(R(r_ecfindex))
            | LSRI(ws->out_l2ppw - 2),                          "MOV     r_ecfindex,r_ecfindex,LSR #out_l2ppw-2 ; convert to byte offset");
      if (ws->out_l2ppw < 2) /* < 4 output pixels per word (ie 2 or 1) */
        MOV(R(r_ecfindex), OP2R(R(r_ecfindex))
            | LSLI(2 - ws->out_l2ppw),                          "MOV     r_ecfindex,r_ecfindex,LSL #2-out_l2ppw ; convert to byte offset");
#endif
d475 1
a475 1
      MOV(R(r_outshift),OP2R(R(r_outshift)) | LSLI(ws->out_l2bpc),"MOV     r_outshift,r_outshift,LSL #out_l2bpc ; bit offset of start");
d501 1
a501 1
    MOV(R(r_xsize), OP2R(R(r_xsize)) | LSLI(ws->out_l2bpc),       "MOV     r_xsize,r_xsize,LSL #out_l2bpc  ; size in bits");
a556 5
      else
      {
//        AND(R(r_pixel), R(r_inword), IMM(ws->out_pixmask),"AND     r_pixel,r_inword,#out_pixmask    ; fetch the pixel from the ECF pattern");
//        AND(R(r_pixel), R(r_pixel), OP2R(R(r_bgcolour)),  "AND     r_pixel,r_pixel,r_bgcolour       ; turn it into a background colour pixel");
      }
a647 242
#ifdef DEBUG
static void add_ordered_dither_gun(asm_workspace *wp, workspace *ws, int bits_per_gun, int offset, char *gun)
#else
#define add_ordered_dither_gun(a,b,c,d,e) do_add_ordered_dither_gun(a,b,c,d)
static void do_add_ordered_dither_gun(asm_workspace *wp, workspace *ws, int bits_per_gun, int offset)
#endif
/* Do one gun of the ordered dither - entirely local to add_ordered_dither below
 * Offset is the offset from bit 0 of the base of this field of the colour
 */
{
  int x = 32 - bits_per_gun - offset; /* amount to shift the colour field in question */
#ifdef DEBUG
  char a[256];
#endif

  IFDEBUG(do_sprintf(a,                                  "CMN     r_oditheradd,r_pixel,LSL #%i %t40; will the %s value overflow?", x, gun);)
  CMN(R(r_oditheradd), OP2R(R(r_pixel)) | LSLI(x), a);

  IFDEBUG(do_sprintf(a,                                  "ADDCC   r_pixel,r_pixel,r_oditheradd,LSR #%i %t40; if not, add.", x);)
  ADD(R(r_pixel), R(r_pixel), CC | OP2R(R(r_oditheradd)) | LSRI(x), a);
  UNUSED(wp);
}

static void add_ordered_dither(asm_workspace *wp, workspace *ws, int bits_per_gun)
/* bits_per_gun is 5 or 8. The 32-bit RGB value in r_pixel should have
 * r_oditheradd >> (32-bits_per_gun) added to each of R/G/B, except that these
 * additions should be 'sticky' at 255 in each gun.
 * 
 * The resulting values are just about to be truncated somewhat, so the lo
 * bits of each answer do not matter much. Thus, if the value is currently
 * 254 we never add, but this doesn't matter.
 */
{
  if (ws->odither) /* turn off for now */
  {
    comment(ws, "Add current value for ordered dither");
    add_ordered_dither_gun(wp, ws, bits_per_gun, 2*bits_per_gun, "blue");
    add_ordered_dither_gun(wp, ws, bits_per_gun, 1*bits_per_gun, "green");
    add_ordered_dither_gun(wp, ws, bits_per_gun, 0, "red");
    newline();
  }
}

static void translate_pixel(asm_workspace *wp, workspace *ws)
/* Translate r_pixel from being a source pixel, to being a destination pixel. */
{
  int pixl2bpp = wp->save_inlog2bpp;

  if (PLOTMASK)
  {
    if ((ws->gcol & 7) == 2) /* AND plot action */
    {
      MOV(R(r_pixel), OP2R(R(r_pixel)) | LSLI(31-(wp->BPP)),  "MOV     r_pixel, r_pixel, LSL 31-out_bpp ;a");
      ORR(R(r_pixel), R(r_pixel), IMM(2) | IMMROR(2),         "ORR     r_pixel,r_pixel,#&80000000       ;a");
      MOV(R(r_pixel), OP2R(R(r_pixel)) | ASRI(31-(wp->BPP)),  "MOV     r_pixel, r_pixel, ASR 31-out_bpp ;a");
    }
    return; /* No more transformation necessary */
  }

  if (ws->odither) add_ordered_dither(wp, ws, pixl2bpp == 5 ? 8 : 5); /* do ordered dither */

  comment(ws, "Perform any0 transformation necessary");
  if (wp->trns_palette != 0)
  {
    assert(pixl2bpp <= 3, ERROR_FATAL);
    if (wp->BPP == 16)
    {
      ins(ws, LDR(R(r_pixel), R(r_table))
            | INDEX(R(r_pixel), 2),                     "LDR     r_pixel,[r_table, r_pixel, LSL #2] ; 16bpp palette lookup");
      pixl2bpp = 4;
    }
    else
    {
      ins(ws, LDR(R(r_pixel), R(r_table))
            | INDEX(R(r_pixel), 3),                     "LDR     r_pixel,[r_table, r_pixel, LSL #3] ; palette lookup");
      MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(8),       "MOV     r_pixel,r_pixel,LSR #8             ; BBGGRR00 to 00BBGGRR ");
      pixl2bpp = 5;
    }
  }

  if (pixl2bpp == 5 && wp->BPP != 32 && !(wp->is_it_jpeg && (wp->dither_truecolour & 2) && (wp->BPP != 16))) /* all we can do is truncate to 4, as a first stage. */
  {
    /* if (wp->BPP == 16 && ws->odither) add_ordered_dither(wp, ws, 8); */
    comment(ws,                                   " Taken from munge32to16                                      fedcba9876543210 fedcba9876543210");
    comment(ws,                                   "                                                   r_pixel = 00000000bbbbbbbb ggggggggrrrrrrrr");
    AND(R(r_temp1),R(r_pixel),IMM(0xf8) | IMMROR(16),   "AND     r_temp1,r_pixel,#&F80000           ; r_temp1 = 00000000bbbbb000 0000000000000000");
    MOV(R(r_temp2), OP2R(R(r_temp1)) | LSLI(7),         "MOV     r_temp2,r_temp1,LSL #7             ; r_temp2 = 0bbbbb0000000000 0000000000000000");
    AND(R(r_temp1), R(r_pixel), IMM(0xf8)|IMMROR(24),   "AND     r_temp1,r_pixel,#&f800             ; r_temp1 = 0000000000000000 ggggg00000000000");
    ORR(R(r_temp2),R(r_temp2),OP2R(R(r_temp1))|LSLI(10),"ORR     r_temp2,r_temp2,r_temp1,LSL #10    ; r_temp2 = 0bbbbbggggg00000");
    AND(R(r_temp1), R(r_pixel), IMM(0xf8),              "AND     r_temp1,r_pixel,#&F8               ; r_temp1 = 0000000000000000 00000000rrrrr000");
    ORR(R(r_pixel),R(r_temp2),OP2R(R(r_temp1))|LSLI(13),"ORR     r_pixel,r_temp2,r_temp1,LSL #13    ; r_pixel = 0bbbbbgggggrrrrr");
    MOV(R(r_pixel),OP2R(R(r_pixel)) | LSRI(16),          "MOV     r_pixel,r_pixel,LSR #16            ; result in bottom half");
    /* >>> check re keeping 16bit r_pixel at the top */
    pixl2bpp = 4;
  }

  if (pixl2bpp == 4 && wp->BPP == 32) /* pad out to 32bpp */
  {
    MOV(R(r_pixel),OP2R(R(r_pixel)) | LSLI(16),          "MOV     r_pixel,r_pixel,LSL #16           ; input in top half");
    /* >>> check re keeping 16bit r_pixel at the top */
    comment(ws,                                    "                                                ;           fedcba9876543210 fedcba9876543210");
    comment(ws,                                    "                                                ; r_pixel = 0bbbbbgggggrrrrr");
    MOV(R(r_temp1), OP2R(R(r_pixel)) | LSRI(26),         "MOV     r_temp1,r_pixel,LSR #26           ; r_temp1 =                            0bbbbb");
    MOV(R(r_temp2), OP2R(R(r_temp1)) | LSLI(19),         "MOV     r_temp2,r_temp1,LSL #19           ; r_temp2 =        0bbbbb000 0000000000000000");
    AND(R(r_temp1), R(r_pixel), IMM(0x3E) | IMMROR(12),  "AND     r_temp1,r_pixel,#&03E00000        ; r_temp1 = 000000ggggg00000");
    ORR(R(r_temp2), R(r_temp2),OP2R(R(r_temp1))|LSRI(10),"ORR     r_temp2,r_temp2,r_temp1,LSR #10   ; r_temp2 =        0bbbbb000 ggggg00000000000");
    MOV(R(r_temp1), OP2R(R(r_pixel)) | LSLI(11),         "MOV     r_temp1,r_pixel,LSL #11           ; r_temp1 = rrrrr00000000000 0000000000000000");
    ORR(R(r_temp2), R(r_temp2),OP2R(R(r_temp1))|LSRI(24),"ORR     r_temp2,r_temp2,r_temp1,LSR #24   ; r_temp2 =        0bbbbb000 ggggg000rrrrr000");
    comment(ws, "Now copy the top three bits of each colour component into the bottom three");
    comment(ws,                                    "                                                ; r_c1632 = 0000000011100000 1110000011100000");
    AND(R(r_temp1), R(r_temp2), OP2R(R(r_c1632)),        "AND     r_temp1,r_temp2,r_c1632           ; r_temp1 = 00000000bbb00000 ggg00000rrr00000");
    ORR(R(r_pixel), R(r_temp2),OP2R(R(r_temp1))|LSRI(5), "ORR     r_pixel,r_temp2,r_temp1,LSR #5    ; r_pixel = 00000000bbbbbbbb ggggggggrrrrrrrr");
    pixl2bpp = 5;
  }

  /* Translation table lookup */
  if (wp->ColourTTR != 0)
  {
    comment(ws, "We have a translation table.");
    if (ws->out_l2bpp <= 3) /* ie BPP <= 8 */
    {
      assert(pixl2bpp <= 4, ERROR_FATAL); /* up to 32K entries in byte table */
      /* if (pixl2bpp == 4 && ws->odither) add_ordered_dither(wp, ws, 5); */
      ins(ws, LDRB(R(r_pixel), R(r_table)) | INDEX(R(r_pixel), 0),  "LDRB    r_pixel,[r_table, r_pixel]      ; byte table lookup");
    }
    else
    {
      assert(pixl2bpp <= 3, ERROR_FATAL); /* up to 256 entries in word table */
      ins(ws, LDR(R(r_pixel), R(r_table)) | INDEX(R(r_pixel), 2),   "LDR     r_pixel,[r_table, r_pixel, LSL #2] ; word table lookup");
      /* >>> with 16bpp that could be in the top half? Not sure... */
    }
    pixl2bpp = ws->out_l2bpp;              /* we've finished */
  }
  else if (wp->is_it_jpeg && (wp->dither_truecolour & 2))
  {
    /* bottom n bits of word contains colour number we want... */
    pixl2bpp = ws->out_l2bpp;              /* we've finished */
    comment(ws, "JPEG error diffusion should have done all the work!");
  }
  else if (pixl2bpp == 4 && ws->out_l2bpp < 4)
  {
    /* Hack for JPEG data in RISC OS 3
     * r_pixel is a 16bpp colour value at the moment, but we have no lookup table for the 16->1/2/4/8 transition
     * For 1/2/4bpp we use the top bits of red as the grey level. From a JPEG source this will work
     * fine, as the JPEG will have noticed that the output is mono and simply produced greyscale
     * output.
     */
    comment(ws, "Colour truncation without lookup table.\n");
    if (ws->out_l2bpp == 0) /* 1bpp */
    {
      comment(ws, "Creating 0 or 1 from 0bbbbbgg gggrrrrr");
      TST(R(r_pixel), IMM(16),                                      "TST     r_pixel,#16                     ; test hi bit of R");
      MOV(R(r_pixel), IMM(1),                                       "MOV     r_pixel,#1                      ; black");
      MOV(R(r_pixel), NE | IMM(0),                                  "MOVNE   r_pixel,#0                      ; white");
      pixl2bpp = 0;
    }
    else if (ws->out_l2bpp == 1) /* 2bpp */
    {
      comment(ws, "Creating 0,1,2 or 3 from 0bbbbbgg gggrrrrr");
      MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(3),                   "MOV     r_pixel,r_pixel,LSR #3           ; hi 2 bits of R");
      AND(R(r_pixel), R(r_pixel), IMM(3),                           "AND     r_pixel,r_pixel,#3               ; mask off everything else");
      RSB(R(r_pixel), R(r_pixel), IMM(3),                           "RSB     r_pixel,r_pixel,#3               ; change to 0->white, 3->black");
      pixl2bpp = 1;
    }
    if (ws->out_l2bpp == 2) /* 4bpp */
    {
      comment(ws, "Creating wimp colour in 0..7 from 0bbbbbgg gggrrrrr");
      MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(2),                   "MOV     r_pixel,r_pixel,LSR #2           ; hi 3 bits of R");
      AND(R(r_pixel), R(r_pixel), IMM(7),                           "AND     r_pixel,r_pixel,#7               ; mask off everything else");
      RSB(R(r_pixel), R(r_pixel), IMM(7),                           "RSB     r_pixel,r_pixel,#7               ; change to 0->white, 7->black");
      pixl2bpp = 2;
    }
    else if (ws->out_l2bpp == 3) /* 8bpp from 16bpp true colour, no lookup table - only for use on RISC OS 3.10 */
    {
      /* Get the top two bits of each gun. The organisation is:
       * bit 0 - tint 0
       * bit 1 - tint 1
       * bit 2 - red 2
       * bit 3 - blue 2
       * bit 4 - red 3 (high)
       * bit 5 - green 2
       * bit 6 - green 3 (high)
       * bit 7 - blue 3 (high)
       */
      comment(ws, "Creating bggrbrtt from 0bbbbbgg gggrrrrr");

      /* Making the tint - the average of the lo 3 bits of RGB isn't a bad approximation. We make this
       * by adding them all up, multiplying by 3, and dividing by 8. We involve the lo bits in the approximation
       * as well, in case they produce a useful carry.
       */
      AND(R(r_temp1), R(r_pixel), IMM(0x1C) | IMMROR(24),           "AND     r_temp1,r_pixel,#&1C00           ; bottom 3 bits of B");
      MOV(R(r_temp2), OP2R(R(r_temp1)) | LSRI(10),                  "MOV     r_temp2,r_temp1,LSR #10          ; at bottom of temp2");
      AND(R(r_temp1), R(r_pixel), IMM(0xE0),                        "AND     r_temp1,r_pixel,#&E0             ; bottom 3 bits of G");
      ADD(R(r_temp2), R(r_temp2), OP2R(R(r_temp1)) | LSRI(5),       "ADD     r_temp2,r_temp2,r_temp1,LSR #5   ; add to bottom B bits");
      AND(R(r_temp1), R(r_pixel), IMM(0x07),                        "AND     r_temp1,r_pixel,#&07             ; bottom 3 bits of R");
      ADD(R(r_temp2), R(r_temp2), OP2R(R(r_temp1)),                 "ADD     r_temp2,r_temp2,r_temp1          ; add to bottom B+G bits");
      ADD(R(r_temp2), R(r_temp2), OP2R(R(r_temp2)) | LSLI(2),       "ADD     r_temp2,r_temp2,r_temp2,LSL #2   ; (lo R+G+B)*5    (< 128)");

      /* The hi bits are just done by extracting from the 16bpp value. This takes ages! */
      MOV(R(r_temp1), IMM(0),                                       "MOV     r_temp1,#0                       ; building result pixel for hi bits");

      /* Top bits of B */
      TST(R(r_pixel), IMM(64) | IMMROR(24),                         "TST     r_pixel,#&4000                   ; test top bit of B");
      ORR(R(r_temp1), R(r_temp1), NE | IMM(128),                    "ORRNE   r_temp1,r_temp1,#128             ; bit 7 = top bit of B");
      TST(R(r_pixel), IMM(32) | IMMROR(24),                         "TST     r_pixel,#&2000                   ; test next bit of B");
      ORR(R(r_temp1), R(r_temp1), NE | IMM(8),                      "ORRNE   r_temp1,r_temp1,#8               ; bit 3 = next bit of B");

      /* Top bits of G */
      TST(R(r_pixel), IMM(2) | IMMROR(24),                          "TST     r_pixel,#&200                    ; test top bit of G");
      ORR(R(r_temp1), R(r_temp1), NE | IMM(64),                     "ORRNE   r_temp1,r_temp1,#64              ; bit 6 = top bit of G");
      TST(R(r_pixel), IMM(1) | IMMROR(24),                          "TST     r_pixel,#&100                    ; test next bit of G");
      ORR(R(r_temp1), R(r_temp1), NE | IMM(32),                     "ORRNE   r_temp1,r_temp1,#32              ; bit 5 = next bit of G");

      /* Top bits of R */
      TST(R(r_pixel), IMM(16),                                      "TST     r_pixel,#&10                     ; test top bit of R");
      ORR(R(r_temp1), R(r_temp1), NE | IMM(16),                     "ORRNE   r_temp1,r_temp1,#16              ; bit 4 = top bit of R");
      TST(R(r_pixel), IMM(8),                                       "TST     r_pixel,#&08                     ; test next bit of R");
      ORR(R(r_temp1), R(r_temp1), NE | IMM(4),                      "ORRNE   r_temp1,r_temp1,#4               ; bit 2 = next bit of R");

      ORR(R(r_pixel), R(r_temp1), OP2R(R(r_temp2)) | LSRI(5),       "ORR     r_pixel,r_temp1,r_temp2,LSR #5   ; combine hi bits and tint");

      pixl2bpp = 3;
    }
  }

  assert(pixl2bpp == ws->out_l2bpp, ERROR_FATAL); /* If this hasn't happened, we haven't completed the transformation. */

  if (((ws->gcol & 7) == 2) && (pixl2bpp != 5)) /* AND plot action which did something stupid for 32bpp (GPS)*/
  {
    MOV(R(r_pixel), OP2R(R(r_pixel)) | LSLI(31-(wp->BPP)), "MOV     r_pixel, r_pixel, LSL 31-out_bpp");
    ORR(R(r_pixel), R(r_pixel), IMM(2) | IMMROR(2),         "ORR     r_pixel,r_pixel,#&80000000 ");
    MOV(R(r_pixel), OP2R(R(r_pixel)) | ASRI(31-(wp->BPP)),  "MOV     r_pixel, r_pixel, ASR 31-out_bpp");
  }

  comment(ws, "r_pixel is now a destination pixel.");

  if (DPIXEL_OUTPUT)
    ORR(R(r_pixel), R(r_pixel), OP2R(R(r_pixel)) | LSLI(wp->BPP),   "ORR     r_pixel,r_pixel,r_pixel,LSL #out_bpp:SHR:1 ; double pixel output");

  newline();
}

a901 8
#if 0
      MOV(R(r_maskinword), OP2R(R(r_maskinword))
                         | RORI(ws->mask_bpp),                 "x"/*MOV     r_maskinword,r_maskinword,ROR #mask_bpp"*/);
      SUB(R(r_maskinshift),R(r_maskinshift),
                         S | IMM(ws->mask_bpp*2) | IMMROR(6),  "x"/*SUBS    r_maskinshift,r_maskinshift,#mask_bpp:SHL:27"*/);
      ins(ws, LDR(R(r_maskinword), R(r_maskinptr))
            | EQ | WRITEBACK | OFFSET(4),                     "x"/* "LDREQ   r_maskinword,[r_maskinptr,#4]!     ; load more mask pixels (inc2)"*/);
#endif
a917 12
static void odither_inc(asm_workspace *wp, workspace *ws, int xy)
/* Call every output pixel - alternates the ordered dither addition value
 * xy == 0 for x, 1 for y
 */
{
  if (ws->odither)
    EOR(R(r_oditheradd),R(r_oditheradd), IMM(1 << (ws->odither - xy)) | IMMROR(8),
      xy == 0 ? "EOR     r_oditheradd,r_oditheradd,#odither_eorvalue ; alternate dither offset"
              : "EOR     r_oditheradd,r_oditheradd,#odither_eorvalue:SHR:1 ; alternate dither offset");
  UNUSED(wp);
}

d933 1
a933 1
    MOV(R(r_temp1),  OP2R(R(r_temp1)) | LSLI(ws->out_l2bpc),      "4~MOV     r_temp1, t_temp1, LSL #out_log2bpc");
d950 1
a950 1
    MOV(R(r_temp1),  OP2R(R(r_xcount)) | LSLI(ws->out_l2bpc),    "2~~MOV     r_temp1, r_xcount, LSL #out_log2bpc");
a965 14
    if (PLOTMASK)
    {
#if 0
      EOR(R(r_ecfindex), R(r_ecfindex), IMM(4),              "EOR     r_ecfindex,r_ecfindex,#4        ; either 0 or 4323232");
#endif
/*      ins(ws, LDR(R(r_inword), R(r_inptr))
            | INDEX(R(r_ecfindex), 0),                       "LDR     r_inword,[r_inptr,r_ecfindex]   ; load next word of ECF  32323");
      ADD(R(r_ecfindex), R(r_ecfindex),
            IMM(4),                                          "ADD     r_ecfindex,r_ecfindex,#4 132323");
      ins(ws, LDR(R(r_bgcolour), R(r_inptr))
            | INDEX(R(r_ecfindex), 0),                       "LDR     r_bgcolour,[r_inptr,r_ecfindex]   ; load next EOR word of ECF123232");
      SUB(R(r_ecfindex), R(r_ecfindex),
            IMM(4),                                          "SUB     r_ecfindex,r_ecfindex,#4 132323");
*/    }
a981 19
    /* If entirely replacing pixels, no need to fetch the old ones.
     * The last word has to be patched up carefully, see x_loop.
     */
    if (PLOTMASK)
    {
#if 0
      EOR(R(r_ecfindex), R(r_ecfindex), EQ | IMM(4),         "EOREQ   r_ecfindex,r_ecfindex,#4        ; either 0 or 4");
#endif
#if 0
      ins(ws, LDR(R(r_inword), R(r_inptr))
            | INDEX(R(r_ecfindex) | EQ, 0),                       "LDREQ   r_inword,[r_inptr,r_ecfindex]   ; load next word of ECF  1");
      ADD(R(r_ecfindex), R(r_ecfindex),
            IMM(4) | EQ,                                          "ADDEQ   r_ecfindex,r_ecfindex,#4  2");
      ins(ws, LDR(R(r_bgcolour), R(r_inptr))
            | INDEX(R(r_ecfindex) | EQ, 0),                       "LDREQ   r_bgcolour,[r_inptr,r_ecfindex]   ; load next EOR word of ECF2");
      SUB(R(r_ecfindex), R(r_ecfindex),
            IMM(4) | EQ,                                          "SUBEQ   r_ecfindex,r_ecfindex,#4 2");
#endif
    }
a1180 48
#define ADD_A(reg,value) arbitrary_add(ws, TRUE, FALSE, &ws->regnames.reg, value);
#define ADDS_A(reg,value) arbitrary_add(ws, TRUE, TRUE, &ws->regnames.reg, value);
#define SUB_A(reg,value) arbitrary_add(ws, FALSE, FALSE, &ws->regnames.reg, value);
#define SUBS_A(reg,value) arbitrary_add(ws, FALSE, TRUE, &ws->regnames.reg, value);

static void arbitrary_add(workspace *ws, BOOL add, BOOL s, regname *r, int value)
/* Add/subtract an arbitrary constant to a register - could be more than 8 bits. */
{
  IFDEBUG(char a[256];)

  if (value < 0) {value = -value; add = !add;}
  if (value == 0) /* special case with 0 constant */
  {
    if (s)
    {
      IFDEBUG(do_sprintf(a, "CMP     %s,#0", r->name);)
      CMP(r->regno, IMM(0), a);
    }
    /* else, nothing */
  }
  else
  {
    int opcode = add ? ADD_OPCODE : SUB_OPCODE;
    int sopcode = s ? S : 0;
    int shift_it = 0;

    while (value != 0)
    {
      BOOL last;
      int valuebyte;

      if (value > 255)
        while ((value & 3) == 0) {value >>= 2; shift_it += 2;}
      valuebyte = value & 0xff;
      value &= 0xffffff00;
      last = value == 0; /* the last instruction needed */
      IFDEBUG(
        do_sprintf(a,
          (last && sopcode ? "%sS%t8.%s,%s,#&%x" : "%s%t8.%s,%s,#&%x") _
          (add ? "ADD" : "SUB") _ r->name _ r->name _ valuebyte << shift_it);)
      ins(ws, opcode | (last ? sopcode : 0)
            | DSTR(r->regno) | OP1R(r->regno)
            | IMM(valuebyte) | IMMROR ((32 - shift_it) & 0x1e),
            a);
    }
  }
}

d1265 9
a1273 2
    MOV(R(lr), OP2R(R(pc)),                                  "MOV     lr,pc                           ; remember return address");
    MOV(R(pc), OP2R(R(r_blockroutine)),                      "MOV     pc,r_blockroutine               ; block move");
d1469 1
a1469 1
              MOV(R(r_temp1), OP2R(R(r_temp1)) | LSRI(ws->out_l2bpc),       "3MOV     r_temp1, r_temp1, LSR #out_log2bpc");
a1489 24
#if 0
          int   loop;

          comment(ws, "Doing multiple plots of same pixel in line");
          DEFINE_LABEL(                                       loop_x_repeat, "Loop around for each source pixel")

          CMN(R(pc), OP2R(R(pc)),                                 "CMN     pc, pc   ; this will clear the Z flag");
          DEFINE_LABEL(loop_x_exitskip,          "Kludge to avoid multiple forward references");
          branch(ws, B | EQ, L(loop_x_exit),                      "BEQ     loop_x_exit");
          mask_possible = fetch_pixel(wp, ws, &ws->labels.l_masked);
          translate_pixel(wp, ws); /* If we're about the discard the pixel this is in fact wasted work - we could reorganise
                                    * this whole loop to improve that situation, but it doesn't really seem worthwhile, the gain
                                    * is not enormous.
                                    */
          fetch_pixel_inc(wp, ws);
          for (loop = 0;loop < (wp->save_xmag / wp->save_xdiv);loop++)
          {
            save_pixel(wp, ws);
            save_pixel_inc(wp, ws);
            SUB(R(r_xsize), R(r_xsize), S | IMM(1),                    "SUBS    r_xsize,r_xsize,#1              ; count for each output pixel");
            branch(ws, B | EQ, L(loop_x_exitskip),                     "BEQ     loop_x_exitskip");
          }
          branch(ws, B , L(loop_x_repeat),                             "B     loop_x_repeat                   ; discard this pixel");
#endif
d1534 1
a1534 1
              MOV(R(r_temp1), OP2R(R(r_temp1)) | LSRI(ws->out_l2bpc),       "@@@@MOV     r_temp1, r_temp1, LSR #log2bpc");
d1674 1
a1674 1
  ws->out_l2ppw      = 5 - ws->out_l2bpc;
d1680 2
a1681 2
  tracef("%t20.out_l2bpp *     %i %t68; log base 2 of bits per output pixel\n" _ ws->out_l2bpp);
  tracef("%t20.out_l2bpc *     %i %t68; log base 2 of bits per output double-pixel\n" _ ws->out_l2bpc);
d1691 1
a1691 6
  if (  !PLOTMASK                     /* if plotting sprite */
     && ws->in_bpp >= 16              /* from true colour source */
     && wp->BPP < ws->in_bpp          /* and losing resolution */
     && (wp->dither_truecolour & 1)
     && !(wp->is_it_jpeg && (wp->dither_truecolour & 2))
     )
d1696 6
a1701 3
    if (wp->BPP == 16) /* dithering down from 32 bit to 16 bit */
      ws->odither = 2;
    else  /* dithering down from 16 or 32 bit, to 1/2/4/8 bit. */
d1703 2
a1704 1
      if (ws->out_l2bpp == 3) /* 8bpp */
d1716 1
a1716 1
        ws->odither = 6 - ws->out_l2bpp; /* 6, 5 or 4 for 2, 4, or 16 colour output (2, 4 or 8 grey level) */
d1820 9
a1828 2
    MOV(R(lr), OP2R(R(pc)),                                 "MOV     lr,pc                           ; remember return address from fetchroutine");
    MOV(R(pc), OP2R(R(r_fetchroutine)),                     "MOV     pc,r_fetchroutine               ; get source address");
d1950 2
a1951 10
  key_word = wp->save_inlog2bpp          /* 0..2 */
               + (ws->out_l2bpp << 3)    /* 3..5 */
               + (ws->gcol << 6);        /* 6..8 */
  if (SOURCE_MASK) key_word |= 1<<9;
  if (SOURCE_BPPMASK) key_word |= 1<<10;
  if (wp->trns_palette != 0) key_word |= 1<<11;
  if (wp->ColourTTR != 0) key_word |= 1<<12;
  if (wp->BPP != wp->BPC) key_word |= 1<<13;
  if (wp->save_inlog2bpp != wp->save_inlog2bpc) key_word |= 1<<14;
  if (PLOTMASK) key_word |= 1<<15;
d1953 2
a1954 2
  if (wp->is_it_jpeg) key_word |= 1<<16;
  if (wp->is_it_jpeg && cinfo->jpeg_color_space == CS_GRAYSCALE) key_word |= 1<<17;
d1958 3
a1960 3
    key_word |= 1<<18;
    if (ws->cal_table_simple) key_word |= 1<<19;
    if (wp->cal_table->tablecount == 3) key_word |= 1<<20;
d1963 2
a1964 2
  if (wp->is_it_jpeg && (wp->dither_truecolour & 1)) key_word |= 1<<21;
  if (wp->is_it_jpeg && (wp->dither_truecolour & 2)) key_word |= 1<<22;
d1966 10
d1978 1
a1978 1
  tracef("simple_x_scale=%s x_block_move=%s jpeg=%s calibration table=0x%x\n"
d1982 2
a1983 1
        _ wp->cal_table);
d2093 52
d2146 1
d2148 21
a2220 11
  /* Compute l2bpp from BPP of output - all we're given. */
  i = 0;
  j = wp->BPP;
  while (j > 1)
  {
    j = j >> 1; i++;
  }
  ws->out_l2bpp = i;
  if (wp->BPP != wp->BPC) i++;
  ws->out_l2bpc = i;

@


4.12
log
@Paper and fill some JPEG cracks.
The exit_c function was repeatedly being called with the line number argument and error code the wrong way round and since only bits 0-2 of the error code are inspected on exit any fatal exits from the ported JPEG library code would either report the wrong error or fail silently (depending on the line number) - example a 12 bits per sample JPEG would be rendered without fault into a screen full of random memory garbage.
Assembling/compiling with the 'jpeg' switch off didn't work, fixed, and also now zeros out the SWI decode values in the module header.
Moved include of 'yuvtabs.s' into the colour conversion code.
Deleted panic_exit, it did nothing useful but trace a value then exit, so it now just calls exit() like everyone else.
Removed excess call to find_image_dims(), this was needed just to get the workspace requirements when the JPEG had already been sized up by asm_find_image_dims() earlier. Side effect of removing the pilot JPEG code earlier is that this call can now only get to the JPEG code from a JPEG_ SWI. Changed to just pass the workspace requirements into 'c.PutScaled' and save a duplicate scan.
Fatal exits from the assembler huffman decoder now report a sensible error.
Trimmed out all the JPEG assessment code from 'c.PutScaled' and moved it into 'c.rojpeg' so the put scaled is only concerned with putting things scaled.
Sanitised the #includes a bit.
Fixed on last check of wp->save_mode looking at the wrong bits for the mode number.
Resolved all the warning in the genhdr/genyuvtabs/genpalette utilities by casting a bit harder.[A[B
Added new more descriptive error messages to the messages file (not currently used), and made the 'not supported by' ones consistent so the tokeniser might crunch the file a bit more.
In looks_like_jpeg() changed a bitwise to logical or.
Fixed longstanding problem of not being able to render JPEGs at a scale of less than 1/6 in any greyscale mode, because, err, there was no code to do it - only the colour case was checked for. Implemented for 8bpp grey and 32bpp grey (which gets dithered for other lower modes) by just converting the luma channel into an equally weighted RGB value or replicating it for 256 greys.
Tested in all 8 colour depths on a Risc PC using sampling ratios of 1x1; 2x1; 1x2; 2x2 of the IJG test image scaled in !Draw by 0.16.

Version 1.32. Tagged as 'SprExtend-1_32'
@
text
@d3314 1
a3314 1
    char *jpeg_data;
d3320 1
a3320 1
    jpeg_data = (char*)compress_id_word[1];
@


4.12.2.1
log
@Push some redundant files into the attic.
@
text
@@


4.11
log
@Remove pilot JPEG code.
During the original development (referred to in the docs as Sprite Extend 2) JPEG data was briefly wrapped inside a sprite file before the JPEG_ swis were introduced. Within SpriteExtend some code still remained to fake a mode 20 sprite header with the JPEG output sized adjusted as though it was 4bpp, then later undo the faking by checking for a mode 20 sprite with is_it_jpeg set.
This version removes all of the code looking out for pilot JPEGs, and rationalises the fake sprite header to just report the true X/Y size.
Fix bug where r4 would be corrupted on exit from JPEG_PlotScaled if an error occurred, and generally rationalised the exit cases a bit more sensibly.
Made the JPEG_ swi despatch a bit more simple to follow.
Corrected a comment in the NSM_bpptable.
Deleted unused 'ecfspace' from the workspace.
Hid the 'macroword' from the C code as it's now an assembler only value.
Cut the initial comments from c/putscaled and placed in Docs.
Cut the debug tracing code (a notable %age) from c/putscaled and placed in tracing support file.
Simplified the entry to putscaled_compiler() now we don't have to look out for pilot format JPEGs within sprites any more.
Sprinkled in some block comments to make navigating the c/putscaled file a bit easier.

Version 1.30. Tagged as 'SprExtend-1_30'
@
text
@d15 1
a15 1
/* c.putscaled - the bitblit compiler for PutSpriteScaled/PlotMaskScaled */
d22 2
a27 17
*    Switches.                                                            *
*                                                                         *
**************************************************************************/

#undef  DEBUG               /* Define this (along with switch 'debug' in the assembler) to get the tracef() output */
#undef  DEBUG_TML           /* Extra output via HostFS too */
#undef  TEST_DEBUG          /* Used to validate the debug tracing facilities */
#define DYNAMIC_AREA        /* Otherwise uses the RMA */
#undef  ASMmultibuffer      /* Defines which mirror the equivalent GBLL in the assembler code */
#define ASMnbuffers         8
#define ASMignore_ttr
#define ASMflagbit
#define ASMwidetrans
#define ASMjpeg

/**************************************************************************
*                                                                         *
d57 1
a57 1
#define assert(x, y)     do_assert(__LINE__, x, y, 0)
d64 1
a64 1
#define assert(x, y)     {if (!(x)) exit_c(__LINE__, y);}
a77 2
#else
typedef int decompress_info_ptr; /* allow as unused arg in various places */
a243 1
  int  tracing;                  /* Whether tracing (in debug mode) */
a407 2
#include "putscaled.h"

d838 1
d842 1
a842 4

  /* Check that the assembler has an adequate opinion of our workspace needs. */
  assert(ws_end >= (ws + 1), ERROR_NO_MEMORY);

d3233 1
a3233 1
  if (wp->cal_table != 0)
d3280 2
a3281 2
  _swix(OS_SynchroniseCodeAreas, _IN(0) | _IN(1) | _IN(2),
              1,(int)ws->compile_base,(int)ws->compile_base+(4*BUFSIZE)-4 );
d3289 3
a3291 9
  decompress_info_ptr cinfo;
  IFDEBUG(BOOL tracing = (int)asm_writech('\n') >= 0;)

  IFDEBUG(if (tracing)
  {
    tracef("wp=%x ws=%x ws_end=%x.\n" _ wp _ ws _ ws_end);
    tracef("Size of assembler workspace: %i.\n" _ ((char*)ws) - ((char*)wp));
    tracef("Size of C workspace: %i.\n" _ ((char*)ws_end) - ((char*)ws));
  })
d3294 6
a3299 1
  assert(ws_end >= (ws + 1), ERROR_FATAL);
a3300 5
  check_workspace(ws);
#ifdef DEBUG
  ws->tracing = tracing;
  if (tracing) dump_asm_workspace(wp);
#endif
d3304 4
a3307 6
  IFDEBUG(if (tracing)
  {
    tracef("gcol=%i (& 7 = %i)       %t32. GCOL action - 0 for plot, 1..7 for various others.\n" _ gcol _ gcol & 7);
    tracef("masked=%s                %t32. whether to use mask.\n" _ whether(ws->masked));
    tracef("1bpp mask=%s             %t32. whether mask is new format.\n" _ whether(ws->mask1bpp));
  })
d3313 1
a3313 1
    int *compress_id_word = (int*)((char*) s + s->image); /* The first word of the sprite data */
d3315 3
a3317 4
    int jpeg_data_size;
    int ws_size = 0;
    int ok;

a3318 1

d3322 2
a3323 9

    ok = find_image_dims(jpeg_data, 0, 0, 0, 0, &ws_size, 0); /* Find out how many bytes of workspace we need */
    assert(ok == 0, ERROR_BAD_JPEG); /* else, bad JPEG data  - >>>> Need better error reporting here! */
#ifndef DYNAMIC_AREA
    ws_size -=10000; /* find_image_dims returns required size +10000 so that when
                      * it is called by the JPEG_Info SWIs it can tell an application
                      * how much space will be eventually allocated.
                      */
#endif
a3324 5
#ifdef DYNAMIC_AREA
    if (!cinfo)
    {
      _kernel_oserror *error;
      int              area_no, size;
d3326 2
a3327 72
      tracef("Creating JPEG Dynamic Area\n");
      area_no = create_dynamic_area(ws_size);
      assert(area_no != 0, ERROR_NO_MEMORY);
      error = _swix(OS_ReadDynamicArea, _IN(0) | _OUT(0) | _OUT(1), area_no, &cinfo, &size);
      tracef("JPEG Dynamic area no %d is %x bytes big\n" _ area_no _ size);
      assert(error == NULL, ERROR_FATAL);
      wp->jpeg_info_ptr = cinfo;
      wp->area_number = area_no;
      cinfo->error_code = -1;                      /* mark the workspace entirely uninitialised */
      cinfo->workspace_size = size;
    }
    else
    {
      _kernel_oserror *error;
      int              size;

      tracef("JPEG area exists\n");
      error = _swix(OS_ReadDynamicArea, _IN(0) | _OUT(1), wp->area_number, &size);
      if (size > 0)
      {
        if (size != cinfo->workspace_size)
        {
          cinfo->error_code = -1;
          cinfo->workspace_size = size;
          tracef("Marking area as duff\n");
        }
#ifdef DEBUG
        else
        {
          tracef("Area hasn't changed size\n");
        }
#endif
      }
      tracef("JPEG area is %x bytes big\n" _ size);
      assert(error == NULL, ERROR_FATAL);
      if (size < ws_size)      /* Need to grow area */
      {
        _kernel_oserror *error;
        int              bytes_moved;
        
        error = _swix(OS_ChangeDynamicArea, _IN(0) | _IN(1) | _OUT(1),
                      wp->area_number, ws_size-size, &bytes_moved);
        tracef("JPEG area grown by %x bytes\n" _ bytes_moved);
        assert(error == NULL, ERROR_NO_MEMORY);
        cinfo->error_code = -1;                    /* mark the workspace entirely uninitialised */
        cinfo->workspace_size = size+bytes_moved;
        tracef("JPEG area size recorded as %x bytes\n" _ cinfo->workspace_size);
      }
    }
#else
    if (!cinfo)
    {
      ws_size += 10000;                            /* leave safety margin to minimise reallocations */
      wp->jpeg_info_ptr = malloc(ws_size);         /* allocate space on RMA */
      cinfo = wp->jpeg_info_ptr;
      assert(cinfo != 0, ERROR_NO_MEMORY);         /* >>>> Got to be a better way of returning this error! */
      cinfo->error_code = -1;                      /* mark the workspace entirely uninitialised */
      cinfo->workspace_size = ws_size;
    }
    else if (cinfo->workspace_size < ws_size)      /* Need to realloc */
    {
      ws_size += 20000;
      cinfo = realloc_delta(cinfo, ws_size - cinfo->workspace_size);
      assert(cinfo != 0, ERROR_NO_MEMORY);         /* >>>> Got to be a better way of returning this error! */
      wp->jpeg_info_ptr = cinfo;
      cinfo->error_code = -1;                      /* mark the workspace entirely uninitialised */
      cinfo->workspace_size = ws_size;
      wp->jpeg_info_ptr = cinfo;
    }
#endif
    assert(wp->save_inlog2bpp == 5, ERROR_FATAL);        /* 32bpp source */
    assert(!SOURCE_MASK, ERROR_FATAL);                   /* no mask */
d3329 1
a3329 1
    if ((wp->save_mode >> 24) == 0)
d3332 2
a3333 2
      wp->ColourTTR = 0;         /* >>>> mainly for JPEG on RO3 */
      wp->trns_palette = 0;      /* >>>> mainly for JPEG on RO3 */
d3336 10
a3345 12
#if 0
    /* In case of interpolation in the X direction, we've been lying so far about
     * the number of pixels in the X direction. Correct this now. If we get x-interpolation
     * then this gets undone later.
     */
    tracef("Performing X scale correction.\n");
    wp->in_x = wp->in_x/2;
    wp->save_xadd -= wp->save_xdiv;
    wp->save_xadd <<= 1;
    wp->save_xadd += wp->save_xdiv;
    tracef("Corrected xadd,xdiv = %i,%i.\n" _ wp->save_xadd _ wp->save_xdiv);
#endif
d3347 8
d3356 1
a3356 149
      /* Scan the JPEG file */
      int xmax = wp->in_x + 2 + (wp->save_xsize * wp->save_xdiv) / (wp->save_xadd - wp->save_xdiv); /* reverse scaling calculation */
      int err;
      int opt = 0;
      int modeflags = 0;

      /* JPEG decompression options */
      if (wp->BPP < 4)
      {
        opt |= jopt_GREY; /* greyscale if 4bpp or less */
        if ((wp->save_PdriverIntercept & 2) == 0) /* printing is not on */
          wp->ColourTTR = 0; /* don't use trans table for 4bpp or less, results are naff */
      }
      if ((wp->BPP <=8) && (wp->dither_truecolour & 2))
      {
        opt |= jopt_DIFFUSE;
        wp->ColourTTR = 0;
      }
      if (xmax < 0) xmax = s->width - 1; /* check overflow of reverse scale calculation, and give safe value if necessary */
      if (  (wp->save_xadd - wp->save_xdiv) * 6 <= wp->save_xdiv
         && (wp->save_yadd - wp->save_ydiv) * 6 <= wp->save_ydiv
         )
        opt |= jopt_DC_ONLY; /* postage stamp - go faster, do only DC values of JPEG tiles */
#if 0
      _swix(OS_ReadModeVariable, _IN(0) | _IN(1) | _OUT(2), -1, 0, &modeflags);
      if ((modeflags & 1<<7) == 0 && (wp->save_PdriverIntercept & 2) == 0
          && (wp->dither_truecolour & 1) ) /* old format palette and printing is not on */
      {
        tracef("trying new shiny 8BPP plotting technique\n");
        if (wp->BPP == 8)
        {
          if (wp->dither_truecolour & 2)
            opt |= jopt_OUTBPP_8;                              /*full error diffusion*/
          else
            opt |= jopt_OUTBPP_8YUV;                           /*strange diffusion from YUV data*/
        }
        else if (wp->BPP == 16) opt |= jopt_OUTBPP_16;
      }
#else
      if (wp->BPP == 8)
      {
        int temp;
        int size;

        _swix(ColourTrans_ReadPalette, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _IN(4) | _OUT(3),
                                       -1, -1, 0, 256*4, 0, &size); /*save palette into newtranstable area */
        tracef("need %x bytes for palette\n" _ size);
        _swix(ColourTrans_ReadPalette, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _IN(4),
                                       -1, -1, &(wp->newtranstable[0]), size, 0); /*save palette into newtranstable area */
        temp = palette_is_grey(wp->newtranstable, size/4);
        if (temp) opt |= jopt_GREY;
        if (temp == 2)
        {
          opt |= jopt_OUTBPP_8GREY;
          opt &= ~jopt_DIFFUSE;
        }
      }
      if ((wp->save_PdriverIntercept & 2) == 0 && (wp->dither_truecolour & 1)) /* old format palette and printing is not on */
      {
        int  size;

        if ((wp->dither_truecolour & 2) && wp->BPP < 16)
        {
#ifdef DEBUG
          int loop;
#endif

          tracef("trying new shiny 8BPP plotting technique\n");
          _swix(ColourTrans_ReadPalette, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _IN(4) | _OUT(3),
                                         -1, -1, 0, 256*4, 0, &size); /*save palette into newtranstable area */
          tracef("need %x bytes for palette\n" _ size);
          _swix(ColourTrans_ReadPalette, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _IN(4),
                                         -1, -1, &(wp->newtranstable[0]), size, 0); /*save palette into newtranstable area */
          tracef("created palette at %x\n" _ &(wp->newtranstable[0]));
#ifdef DEBUG
          tracef("Read palette, palette entries are:-\n");
          for(loop = 0;loop<size/4;loop++)
            tracef("Entry %d = %x\n" _ loop _ wp->newtranstable[loop]);
#endif
          if (wp->BPP == 4)
          {
            if (palette_is_grey(wp->newtranstable, size/4)) opt |= jopt_GREY;
          }
          else if (wp->BPP == 8)
          {
            int temp = palette_is_grey(wp->newtranstable, size/4);

            if (temp) opt |= jopt_GREY;
            if (temp == 2)
            {
               opt |= jopt_OUTBPP_8GREY;
               opt &= ~jopt_DIFFUSE;
            }
          }
        }

        if ((wp->BPP == 4) && !(wp->dither_truecolour & 2)) opt |= jopt_GREY;

        if (wp->BPP == 8)
        {
          if ((wp->dither_truecolour & 2) && !(opt & jopt_OUTBPP_8GREY))
          {
            opt |= jopt_OUTBPP_8;                        /* full error diffusion */
            cinfo->error_code = -1;                      /* mark the workspace entirely uninitialised */
          }
          else
          {
            _swix(OS_ReadModeVariable, _IN(0) | _IN(1) | _OUT(2), -1, 0, &modeflags);
            if ((modeflags & 1<<7) == 0)
              opt |= jopt_OUTBPP_8YUV;                   /* strange diffusion from YUV data */
          }
        }
        else if (wp->BPP == 16)
          opt |= jopt_OUTBPP_16;
      }
#endif
#ifdef DEBUG
      tracef("After set up, options are:\n");
      if (opt & jopt_GREY) tracef("   jopt_GREY\n");
      if (opt & jopt_DC_ONLY) tracef("   jopt_DC_ONLY\n");
      if (opt & jopt_INTERP_X) tracef("   jopt_INTERP_X\n");
      if (opt & jopt_OUTBPP_8) tracef("   jopt_OUTBPP_8\n");
      if (opt & jopt_OUTBPP_16) tracef("   jopt_OUTBPP_16\n");
      if (opt & jopt_OUTBPP_8YUV) tracef("   jopt_OUTBPP_8YUV\n");
      if (opt & jopt_DIFFUSE) tracef("   jopt_DIFFUSE\n");
      if (opt & jopt_OUTBPP_8GREY) tracef("   jopt_OUTBPP_8GREY\n");
#endif
      err = jpeg_scan_file(cinfo, jpeg_data, jpeg_data_size, wp->in_x, xmax, -1, -1, opt);

      assert(err == 0, ERROR_BAD_JPEG);

#if 0
      if (cinfo->error_argument1 & jopt_INTERP_X) /* we asked for it, and we got it - he'll produce twice as many pixels */
      {
        wp->in_x = wp->in_x * 2;
        wp->save_xadd -= wp->save_xdiv;
        wp->save_xadd >>= 1;
        wp->save_xadd += wp->save_xdiv;
        tracef("Doing X interpolation, re-corrected xadd,xdiv = %i,%i.\n" _ wp->save_xadd _ wp->save_xdiv);
      }
#endif

      tracef("cinfo->erooarg1 = %d\n" _ cinfo->error_argument1);
      if (cinfo->error_argument1 & (jopt_OUTBPP_8 | jopt_OUTBPP_8YUV | jopt_OUTBPP_8GREY)) /* we asked for it, and we got it - 8bpp output pixels */
      {
        tracef("actually doing new shiny 8BPP plotting technique\n");
        wp->save_inlog2bpp = wp->save_inlog2bpc = 3;
        wp->ColourTTR = 0;
      } else if (cinfo->error_argument1 & jopt_OUTBPP_16) /* we asked for it, and we got it - 8bpp output pixels */
d3360 1
a3360 1
#endif /* ASMjpeg */
a3361 1
#if 1
a3365 2
    int i;
    int j;
d3367 1
d3375 1
a3375 1
      tracef("\n");
d3378 1
d3385 1
a3385 1
      tracef("\n");
a3387 17
  }
#endif
#endif

  /* Current limitations. */
#if 0
  assert((wp->spritecode & 255) == SpriteReason_PutSpriteScaled);        /* Only PutSpriteScaled supported so far. */
  assert(wp->BPP == wp->BPC);                  /* Double pixel modes not supported so far. */
  assert(wp->save_inlog2bpp == wp->save_inlog2bpc);
#endif
  ws->odither = FALSE; /* Set more carefully later. */

#ifdef DEBUG
  if (PLOTMASK)
  {
    int *ecf = (int*) wp->save_ecflimit;
    int i;
d3389 1
a3389 1
    tracef("PlotMaskScaled, ECF pattern:\n");
d3401 5
a3405 9
    {
      int i;

      tracef("Calibration table at 0x%x: version=%i idealblack=0x%x idealwhite=0x%x postprocessSWI=0x%x tablecount=%i simple=%s.\n"
        _ t->version _ t->idealblack _ t->idealwhite _ t->postprocessSWI _ t->tablecount _ whether(ws->cal_table_simple));
      for (i = 0; i < 256; i++) tracef(" %i" _ t->redtable[i]); newline();
      if (t->tablecount == 3) for (i = 0; i < 256; i++) tracef(" %i" _ t->greentable[i]); newline();
      if (t->tablecount == 3) for (i = 0; i < 256; i++) tracef(" %i" _ t->bluetable[i]); newline();
    }
d3414 9
a3422 8
  {
    int i = 0;
    int j = wp->BPP;

    while (j > 1) {j = j >> 1; i++;} ws->out_l2bpp = i;
    ws->out_l2bpc = ws->out_l2bpp;
    if (wp->BPP != wp->BPC) ws->out_l2bpc++;
  }
d3432 15
a3446 11
  while (  (wp->save_xadd & 1) == 0
        && (wp->save_xdiv & 1) == 0
        && (wp->save_xcount & 1) == 0
        && (wp->save_xmag & 1) == 0
        )
    {wp->save_xadd >>= 1; wp->save_xdiv >>= 1; wp->save_xcount >>= 1; wp->save_xmag >>=1;}
  while (  (wp->save_yadd & 1) == 0
        && (wp->save_ydiv & 1) == 0
        && (wp->save_ycount & 1) == 0
        )
    {wp->save_yadd >>= 1; wp->save_ydiv >>= 1; wp->save_ycount >>= 1;}
a3451 1
    int i;
d3453 2
a3454 2
    BOOL same = TRUE;
    int size = 1 << (1 << (wp->save_inlog2bpp == 5 ? 4 : wp->save_inlog2bpp));
d3470 15
a3484 18
  {
    /* Precise handling of double-pixel modes by the surrounding code is still unclear to me!
     * When it enters this code bpc!=bpp can still be the case, but it seems that the actual
     * value of bpc is best ignored, it has all been frigged into the scale factors. Avoid
     * this issue for now, but note that we must set the values back afterwards because they
     * can be reused on the next sprite plot, if the source sprite mode word is the same.
     */
    int outBPC = wp->BPC;
    int inl2bpc = wp->save_inlog2bpc;
    blitter result;

    wp->BPC = wp->BPP;
    wp->save_inlog2bpc = wp->save_inlog2bpp;
    result = find_or_compile_code(wp, ws, cinfo);
    wp->BPC = outBPC;
    wp->save_inlog2bpc = inl2bpc;
    return result;
  }
a3485 1

@


4.10
log
@Remove postprocessing step of C code.
Since 2001 this module has been using objasm, but still using the C compiler to output (via -S) assembly code which is then passed through 'sed' and included via GET into the assembler code.
Changed to compile the C code into object files, and use the linker to patch up the unresolved references - this has required some reordering of the C code to make sure static functions now appear in the object file, and some reordering of the header files to ensure both the module and the CFSI version still compile without conflicts.
Minor fix to 'swiv2', the label was in the wrong place for _swi() though it's not used in this module so didn't affect the _swix() case.
Makefile cut down a bit. Unixify some path names.
Test code moved to 'Test/c' directory.
Tested in both debug and non debug cases via softloaded module. Oddly, it's 4 bytes longer than the previous version.

Version 1.28. Tagged as 'SprExtend-1_28'
@
text
@d15 1
a15 97
/* c.putscaled - a new bitblit compiler for PutSpriteScaled */

#undef  DEBUG
#undef  DEBUG_TML
#define DYNAMIC_AREA
#define JPEG

/* BEWARE 10000 VOLTS (this park will never fail, the TRex will never get
out, etc) - This code is compiled into assembler source, which is then
passed through ObjAsm. Do not use high-level functions, or static variables.
 */

/* BEWARE 20000 VOLTS - The PlotMaskScaled code has to continue to use the kernel's
internal ECF pattern for the foreground and background colours. This is because when
performing a PaintCharScaled of the delete character the kernel temporarily swaps the
foreground patter with the background one to make it work! Change this at your own
risk... GPS (after having to change it all!) 23/3/95 */

/*
02 Aug 93 WRS started
25 Aug 93 WRS basic stuff, with 2-at-a-time loop, seems to work.
              simple 16bpp and 32bpp cases have been shown to work.
              PlotMaskScaled coded but doesn't work yet.
              double-pixel sprites mysteriously wrong.
              old compiler taken out - module now 30K (was 18K when I started...)
27 Aug 93 WRS checking for unit translation table moved into assembler (in Sources.PutScaled)
 1 Sep 93 WRS optimised loop for inner loop just being a block transfer (in Sources.PutScaled)
28 Sep 93 WRS JPEG decompression, with assembler DCT/colour conv/huffman, works.

PlotMask - precise meaning of the ECF pointers etc.?
eg. shadows in DragASprite seem to come out cyan, should be black - but I feel
there are F pixels in the ECF pattern, where do the 7 pixels come from? Confused.
ECF plotting - ignoring the EOR word at the moment.

double-pixel sprites - mystery of apparently random behaviour.

Are there times when a 16bit pixel is better off in the
top half of r_pixel? Not thought through yet.

When a pixel is masked, I generate a B around the fetch/xlate/put
code. This is often around 2 or 3 instructions - would be better
to make those instructions conditional.
  Are they always conditionalisable? Not thought through.

At the moment I don't believe the inner loop can spill its registers. If it
does, the most effective short-term measure is for temp1 and temp2 to be
overlaid with something, and STM..LDM to surround their use. Bank switching
is a more powerful general technique, but requires STM,LDM every time you
switch banks. If it comes to this I'd victimise masks first as a thing to
slow down, especially 1BPP masks which are quite expensive.

-------------------------------------------

Other misc things to do/check:

test prog needs doing!
Want TPSS to run in any mode. Generate an xlation table if the modes aren't
compatible - is there a SWI to do this?

>>> I have moved to using PL and MI for the add/div sums, so that I can do
it all as constants. Is this OK? What if it isn't? Needs add/div to be
very big in order to matter, should at least check for this.
(actually do I need this, or is CS/CC still correct after fragmentary
unsigned add/sub? no!)
After all, in the assembler the coordinate is multiplied by xdiv,
divided by xadd - is all this really going to work if xdiv/xadd are
close to 32 bits big?

>>> Initial loading in the compiled code is all off R12 - for an x loop with
max variables, isn't this used? Then it will be trampled on before y vars
are loaded. Can this happen? If so, consider loading all off R14 instead.
At least put in asserts to guard against this.
  If used in one-bank case, surely the very last load loads the last register
declared so there's no problem? Again, check for this carefully.

Augst 93 WRS: I've worked on custom code for scale-up and scale-down along
an x line, but it scarely seems worth it. You end up saving one or two
instructions per source/dest pixel (whichever there is fewer of!). Custom
2:1 would probably be more effective, but is it really important? Abandoned.

---------------------------------------------------------

GPS - Inner loop spills a register when plotting 16bpp sprite with mask and
dithering (ie Scaling up and losing depth)
    FIX - Stopped r12(wp) from being overwritten until after all variables
          had been moved to the stack.

GPS - Plot corrupted when left hand side of sprite obscured.
    FIX - Mask shift was being stored in top 5 bits of register but not
          shifted down when originally used in mask_word rotate.

*/

/* The compile-time variable DEBUG is used in conjunction with hdr.NDRDebug
in the assembler. If NDRDebug is on then the C can have DEBUG either on or off,
if NDRDebug is not on then DEBUG will cause the assembler to fail with
an undefined symbol. */
d20 1
d22 1
d26 1
a26 1
*    Low-level debugging output.                                          *
d30 10
a39 1
extern void exit_c(int reason, int error); /* Provided by assembler */
d41 5
a45 2
/* For macros taking variable argument packs */
#define _ ,
d47 6
a52 1
#ifdef DEBUG
d54 2
a55 16
#define verbose 1
/* In the JPEG stuff the trace macros refer to this, so that
j2s can turn on/off the comments dynamically */

#define assert(x, y) do_assert(__LINE__, x, y, 0)
static void do_assert(int line, BOOL arg, int error, char *describe); /* forward reference */

/* Low-level debugging output routines */
#ifdef DEBUG_TML
#define HostFS_WriteC 0x00040102
#include "swis.h"
#define asm_writech(c) _swix(HostFS_WriteC, _IN(0), c)
#else
extern int asm_writech(char c); /* provided in assembler - handles newline */
                                /* Returns < 0 if trace output is being ignored right now. */
#endif
d57 1
a57 12
static void writech(char **dest, char c) /* output to string or to output stream */
{
  if (dest == 0 || *dest == 0) asm_writech(c); else {*(*dest)++ = c; **dest = 0;}
}
#ifdef TESTDEBUG
static void writes(char **d, char *c) {while(*c != 0) writech(d, *c++);}
#endif
static void writehex(char **d, int i, int width)
{
  int j;
  for (j = 4*(width-1); j >= 0; j-=4) writech(d, "0123456789abcdef"[(i>>j)&15]);
}
d59 4
a62 4
/* Routines that handle column tracking */
static void cwritech(char **d, int *column, char c) {writech(d, c); *column = c == '\n' ? 0 : *column+1;}
static void cwrites(char **d, int *column, char *c) {if (c != 0) {while (*c != 0) cwritech(d, column, *c++);}}
static void cwritehex(char **d, int *column, int i, int width) {*column += width; writehex(d, i, width);}
d64 5
a68 96
static void sprintf(char *d, char *format, ...)
/* as conventional sprintf: only %% for %, %s for string, %c for character,
%i for integer, %x for hex, %t<column> for tab implemented */
{
  va_list args;
  int ch;
  int column = 0;

  asm_writech(4);
/*  asm_writech(17);
  asm_writech(5);*/
  va_start(args, format);
  while ((ch = *format++) != 0)
  {
    if (ch == '%')
    {
      int width = 8; /* default width for hex output */

      while (*format == '0') format++;
      if (*format >= '1' && *format <= '9') width = *format-'0'; /* probably only one digit! */
      while (*format >= '0' && *format <= '9') format++; /* read over width specifier - better than gagging! */

      switch (*format++)
      {
      case '%': cwritech(&d, &column, '%'); break;
      case 's': cwrites(&d, &column, va_arg(args, char*)); break;
      case 'c': cwritech(&d, &column, va_arg(args, int)); break;
      case 'd':
      case 'i':
                {
                  int i = va_arg(args, int);
                  int j = 16;
                  BOOL neg = FALSE;
                  char c[16];
                  int ten = 10;

                  if (i < 0) {neg = TRUE; i = -i;}
                  if (i < 0)
                    cwrites(&d, &column, "0x80000000"); /* minint - probably more useful in hex! */
                  else
                  {
                    c[--j] = 0;
                    while (i >= 10)
                    {
                      c[--j] = '0' + (i % ten);
                      i = i / ten;
                    }
                    c[--j] = '0' + i;
                    if (neg) c[--j] = '-';
                    cwrites(&d, &column, &c[j]);
                  }
                }
                break;
      case 'x': cwritehex(&d, &column, va_arg(args, int), width);
                break;
      case 't': /* tab to specific column */
                {
                  int n = 0;
                  while (*format >= '0' && *format <= '9') n = n * 10 + (*format++ - '0');
                  while (column < n) cwritech(&d, &column, ' ');
                }
                break;
      }
      if (*format == '.') format++; /* terminator for esc sequence. */
    }
    else
      cwritech(&d, &column, ch);
  }
  va_end(args);
  asm_writech(0xd);
/*  asm_writech(17);
  asm_writech(7);*/
}

extern char *strcat(char *aa, const char *b)
{
  char *a = aa;

  while (*a != 0) a++; /* find end of string */
  while (*b != 0) *a++ = *b++;
  *a = 0;
  return aa;
}

/* The way to actually call this in normal code. */
/* Use _ to separate arguments in calls to this. */
#define tracef(args) sprintf(0, args)

static void do_assert(int line, BOOL arg, int error, char *describe)
{
  if (arg == 0)
  {
    tracef("ASSERTION FAILED (line %i): %s\n" _ line _ describe);
    exit_c(line, error);
  }
}
d70 5
d76 7
a82 3

#ifndef newline
#define newline() tracef("\n");
d85 5
a89 1
static char *whether (BOOL p) {return p ? "YES" : "NO";}
d91 2
d94 1
a94 11

/* If not debugging, trace output removed */
#define tracef(args) ((void) 0)

/* Do a fatal exit on assertion when not debugging! */
#define assert(x, y) {if (!(x)) exit_c(__LINE__, y);}

#define newline() ((void) 0)

#define IFDEBUG(a) ;

a96 1

a102 9
#ifdef JPEG
  #include "rojpeg.c"
#else
  typedef int decompress_info_ptr; /* allow as unused arg in various places */
#endif

/* Now structures purely local to this C source, not accessed by
the assembler. */

d118 1
a118 2
/* Labels */
/* There's one of these for each label in the source we generate. */
d123 3
a125 3
  #ifdef DEBUG
    char *name;      /* textual name of the label - same as field name */
  #endif
a126 1
/* A label can only store one forward reference to it - sorry! */
d132 5
a136 5
  label loop_y_repeat;                 /* >>> tidy this up - some used by the TstDebug option, silly names */
  #ifdef TESTDEBUG
    label test1;
    label test2;
  #endif
a180 1
/* Macro to iterate over the labels: (thus the FIRST/LAST macros). */
d184 1
a184 3
/* Register names */
/* There is one of these for each register name. The actual register numbers
are allocated at compile time. */
a215 5
/*
  regname r_vcount;
  regname r_vcounti;
  regname r_voutoffset;
*/
d234 1
a234 9
#define FOR_EACH_REGISTER_NAME(ptr) \
  for (ptr = &ws->regnames.FIRST_REGISTER; \
       ptr <= &ws->regnames.LAST_REGISTER; ptr++)

#if 0
#define R(name) (assert(ws->regnames.name.regno != -1), ws->regnames.name.regno)
/* >>> This is the ultra-paranoid form, which probably makes debug code very bulky.
Consider making it a procedure, if we want to keep it like this? */
#endif
d240 1
d245 1
a245 3
/* Makes code bigger, lots of string clashes - rats! */
#endif

d249 1
d253 1
d260 2
a261 2
  int check_code;
  int tracing;                   /* Whether tracing (in debug mode) */
d264 1
a264 1
  int build_buffer;              /* Buffer currently being built, or next to build */
d274 1
a274 1
  int next_free_reg;             /* allocator of physical registers, as they are needed. */
d277 1
a277 1
  int gcol;                      /* GCOL action */
d281 1
a281 2
  int odither;                   /* If 0, then there's no ordered dither.
                                    If non-0, number of bits - 1 being truncated by dither. */
d283 2
a284 2
  int odither_eorvalue;          /* value for eor alternation along a line */
  int odither_shift;             /* offset of two-bit dither value in r_oditheradd */
d288 12
a299 12
  int in_bpp;
  int in_bpc;                    /* Same as bpp unless double-pixel, in which case double bpp */
  int in_pixmask;
  int mask_bpp;
  int mask_bpc;
  int mask_pixmask;
  int out_l2bpp;                 /* not provided in wp */
  int out_l2bpc;                 /* ditto */
  int out_pixmask;               /* mask for one pixel */
  int out_dpixmask;
  int out_ppw;                   /* pixels per word */
  int out_l2ppw;
d302 1
a302 2
  /* Space for compiled code, near the end so most field accesses have
  only a small offset. */
d306 1
a306 1
  int check_code2;
d321 2
a322 2
    /* Set up textual names of all the labels */
    #ifdef DEBUG
d326 1
d330 4
a333 4
      #ifdef TESTDEBUG
        LN(test1)
        LN(test2)
      #endif
d344 1
d373 1
d410 1
d421 1
a421 1
    #endif
d431 1
d433 2
d436 7
d444 9
a452 4
  tracef("save_inoffset=%i         %t32. byte offset between input rows - SUBTRACT for next row.\n" _ wp->save_inoffset);
  tracef("save_inlog2bpp=%i        %t32. log 2 bits per pixel of input.\n" _ wp->save_inlog2bpp);
  tracef("save_inlog2bpc=%i        %t32. log 2 bits per character of input (only different for double-pixels).\n"
                                   _ wp->save_inlog2bpc);
d454 1
a454 3

  tracef("save_outptr=0x%x         %t32. address of word containing first output pixel.\n" _ wp->save_outptr);
/*  tracef("save_outword=0x%x        %t32. output word mask showing bit before least sig bit of first output pixel.\n" _ wp->save_outword); */
a456 4
  tracef("save_outoffset=%i        %t32. byte offset between output rows - SUBTRACT for next row.\n" _ wp->save_outoffset);
  tracef("save_BPP=%i              %t32. bits per pixel of output.\n" _ wp->BPP);
  tracef("save_BPC=%i              %t32. bits per character of output (only different for double pixels).\n" _ wp->BPC);
  newline();
d458 6
a463 4
  tracef("save_masko=%i            %t32. if not 1bpp mask then this is mask data offset from inptr. Otherwise...\n" _ wp->save_masko);
  tracef("save_maskinptr=0x%x      %t32. word address of mask (or 0 if there isn't one).\n" _ wp->save_maskinptr);
  tracef("save_maskinshift=%i      %t32. initial bit shift within mask word.\n" _ wp->save_maskinshift);
  tracef("save_maskinoffset=%i     %t32. byte offset between mask rows - SUBTRACT for next row.\n" _ wp->save_maskinoffset);
d466 4
a469 5
  tracef("save_xmag=%i             %t32. adder value for x scale?\n" _ wp->save_xmag);
/*    used by grey scale, not otherwise */
  tracef("save_xdiv=%i             %t32. subtracter value for x scale.\n" _ wp->save_xdiv);
  tracef("save_xadd=%i             %t32. adder value for x scale\n" _ wp->save_xadd);
  tracef("save_xcount=%i           %t32. total of xmag/xdiv sum, for x scale factor\n" _ wp->save_xcount);
d472 3
a474 6
/*  tracef("save_ymag=%i             %t32. adder value for y scale?\n" _ wp->save_ymag);
    used by grey scale, not otherwise */
  tracef("save_ydiv=%i             %t32. subtracter value for y scale.\n" _ wp->save_ydiv);
  tracef("save_yadd=%i             %t32. adder value for y scale.\n" _ wp->save_yadd);
  tracef("save_ycount=%i           %t32. total of ymag/ydiv sum, for y scale factor\n" _ wp->save_ycount);
/*  tracef("save_xftimesyf=%i        %t32. (to do with grey scales)?.\n" _ wp->save_xftimesyf); */
d477 2
a478 4
  tracef("save_xsize=%i            %t32. number of output pixels per row.\n" _ wp->save_xsize);
  tracef("save_ysize=%i            %t32. number of output rows.\n" _ wp->save_ysize);
/*  tracef("save_vcount=%i           %t32. counts from 0 to ysize - not an input\n" _ wp->save_vcount); */
/*  tracef("save_inflags=%i          %t32. (not used in the assembler sources!)\n" _ wp->save_inflags); */
a480 2
  tracef("save_ecfptr=0x%x         %t32. ECF pointer - only useful if plotting the mask.\n" _ wp->save_ecfptr);
  tracef("save_ecflimit=0x%x       %t32. ECF limit - only useful if plotting the mask.\n" _ wp->save_ecflimit);
a481 1
  tracef("save_mode=%i (>> 27 = %i) %t32. mode number/pointer of sprite - 1bpp sprites have hi bits set.\n" _ wp->save_mode _ wp->save_mode >> 27);
a483 1

a498 19
#define SOURCE_32_BIT (wp->save_inlog2bpp == 5)
#define SOURCE_16_BIT (wp->save_inlog2bpp == 4)
#define SOURCED_16_BIT (wp->save_inlog2bpc == 4) /* like SOURCE_16_BIT but includes 16-bit double-pixels */
#define SOURCE_MASK (ws->masked)
#define SOURCE_BPPMASK (ws->mask1bpp)
#define SOURCE_TABLE ((wp->ColourTTR != 0) || (wp->trns_palette != 0))
#define DPIXEL_INPUT (wp->save_inlog2bpp != wp->save_inlog2bpc)
#define DPIXEL_OUTPUT (wp->BPP != wp->BPC)
#define PLOTMASK ((wp->spritecode & 255) == 50)

#define DEST_32_BIT (wp->BPP == 32)
#define DEST_16_BIT (wp->BPP == 16)
#define DEST_1_BIT (wp->BPC == 1)
#define DESTD_16_BIT (wp->BPC == 16)
/* Note that DEST_16_BIT is pixels, not characters. Mode 10 is a double-pixel 256-colour mode,
where the characters are 16bpp. */

#define ODITHER (TRUE)

d521 1
a521 1
/* The 'never' opcode should not be used. */
a526 1
/* Add a word offset, assuming PC is 2 words on from the B instruction itself. */
d567 1
a567 4
/* ... MUL and MLA - don't need them */

/* LDR and STR */

a583 9
/* Indexed load - LSL shift assumed - writeback or negative not covered */
#define INDEX(reg, shift) ((1<<25) | OFFSET(0) | OP2R(reg) | LSLI(shift))

/* Offset in assembler workspace */
#define WP_OFFSET(field) OFFSET(((char*)&(wp->field)) - ((char*)&(wp->WP_FIRST_FIELD)))

/* LDM and STM */

/* Just or in a register mask, (1<<n) for each register n. */
d599 1
d602 9
d614 4
a617 3
a LDM/STM instruction. If lastname then find the last such register name in
the case of duplicates - eg. the y-loop name rather than the x-loop name
for the same physical register. */
a646 1

a648 14
static void compile_word(workspace *ws, int w)
{
  assert(ws->compile_ptr < ws->compile_lim, ERROR_NO_MEMORY); /* Check the buffer is big enough */
  *(ws->compile_ptr)++ = w;
}

/* Assembler listings are generated when DEBUG is set. These can be fed through
AAsm, and the results compared with the opcodes that I generate.

Columns of assembler output:
addressX  opcodeXX  label   opcodes regs                            comment
^0        ^10       ^20     ^28     ^36                             ^68
*/

d655 7
a661 2
/* Put an instruction into the output buffer. */
/* Handle the AL/EQ condition codes being wrong, so that 0 can be AL elsewhere. */
d664 2
d668 1
a668 1
  /* all others are OK */
a671 2
  compile_word(ws, w);
}
d673 2
a674 4
#ifdef DEBUG
static void comment(workspace *ws, char *text)
{
  tracef("%t20; %s\n" _ text);
a675 3
#else
#define comment(ws,text) ((void*) 0)
#endif
d707 6
a712 10
   /* temp added by (GPS) */
/*   tracef("Adding Branch: Lab = %x\n" _ lab);
   tracef("Adding Branch: Lab->def = %x\n" _ lab->def);
   tracef("Adding Branch: Lab->ref = %x\n" _ lab->ref);*/
     if (lab->def == 0) /* Forward reference */
  {
    #ifdef DEBUG
      if (lab->ref != 0)
        tracef("Already referenced at 0x%x\n" _ sizeof(int) * (lab->ref - ws->compile_base));
    #endif
d732 2
a733 1
as-yet-unused one, otherwise it's a specific register number. */
d745 8
a752 1
#define RN(name,no,describe) set_regname(ws, &ws->regnames.name, no, describe);
d756 1
a757 2
/* need to change add to work on arbitary register, one other exmple in
file somewhere, search on ADD. */
a778 94
#if 0
/* code to decide whther or not to use error-diffusion for a given palette,
   we finally decided to use it regardless!*/
#define SPAN_SHORTFALL_LIMIT  1500000
#define FULL_COLOUR_SHORTFALL 10
#define SQR(x) ((x)*(x))
static int distance_to_nearest_colour(int Colour, int *palette)
{
  int ColourNumber,
      Colour2;
  int Distance;

  _swix(ColourTrans_ReturnColourNumberForMode, _IN(0) | _IN(1) | _IN(2) | _OUT(0),
        Colour, -1, palette, &ColourNumber);

  Colour2 = palette[ColourNumber];
  tracef("Closest colour Number to %x is %x which is really %x\n" _ Colour _ ColourNumber _ Colour2);
  Distance =  SQR((Colour>>8  & 0xff) - (Colour2>>8  & 0xff))*2;
  tracef("Distance including red component = %d\n" _ Distance);
  Distance += SQR((Colour>>16 & 0xff) - (Colour2>>16 & 0xff))*4;
  tracef("Distance including red + Green components = %d\n" _ Distance);
  Distance += SQR((Colour>>24 & 0xff) - (Colour2>>24 & 0xff));
  tracef("weighted square Distance to colour is %x, (%d)\n" _ Distance _ Distance);
  return(Distance);
}

static int palette_is_map_spanning(int *palette)
{
  int loop;
  int maxred = 0,
      maxgreen = 0,
      maxblue = 0,
      minred = 255,
      mingreen = 255,
      minblue = 255,
      entry;
  tracef("Checking palette, palette entries are:-\n");
  for(loop = 0;loop<256;loop++)
  {
    int red,green,blue;
    entry = palette[loop];
    red = (entry>>8) & 0xff;
    green = (entry>>16) & 0xff;
    blue = (entry>>24) & 0xff;
    if (red > maxred) maxred = red;
    if (green > maxgreen) maxgreen = green;
    if (blue > maxblue) maxblue = blue;
    if (red < minred) minred = red;
    if (green < mingreen) mingreen = green;
    if (blue < minblue) minblue = blue;
    tracef("entry %d = %x\n" _ loop _ palette[loop]);
  }
  tracef("red (%d,%d) green (%d,%d) blue (%d,%d)\n" _ minred _ maxred _ mingreen _ maxgreen _ minblue _ maxblue);
  if (distance_to_nearest_colour(0x00000000, palette) > SPAN_SHORTFALL_LIMIT)
    return(0);
  if (distance_to_nearest_colour(0x0000ff00, palette) > SPAN_SHORTFALL_LIMIT)
    return(0);
  if (distance_to_nearest_colour(0x00ff0000, palette) > SPAN_SHORTFALL_LIMIT)
    return(0);
  if (distance_to_nearest_colour(0x00ffff00, palette) > SPAN_SHORTFALL_LIMIT)
    return(0);
  if (distance_to_nearest_colour(0xff000000, palette) > SPAN_SHORTFALL_LIMIT)
    return(0);
  if (distance_to_nearest_colour(0xff00ff00, palette) > SPAN_SHORTFALL_LIMIT)
    return(0);
  if (distance_to_nearest_colour(0xffff0000, palette) > SPAN_SHORTFALL_LIMIT)
    return(0);
  if (distance_to_nearest_colour(0xffffff00, palette) > SPAN_SHORTFALL_LIMIT)
    return(0);

  return(1);
}
#endif

static int palette_is_grey(int *palette, int entries)
{
  int loop;
  int entry;
  int ascending = 1;

  for (loop=0;loop<entries;loop++)
  {
    entry = palette[loop];

    if (((entry ^ (entry>>8)) & 0xffff00) != 0)
      return 0;
    if ((entry & 0xff00)>>8 != loop)
      ascending = 0;
  }
  if (ascending)
   return 2;
  return 1;
}

d781 3
a783 2
for generating into it. We use a simple round-robin for reusing buffers,
rather than attempting to do LRU. */
d821 3
a823 3
  #ifdef DEBUG
    label *p;
  #endif
d830 8
a837 8
  #ifdef DEBUG
    /* Check no unresolved references to labels */
    FOR_EACH_LABEL(p)
    {
      IFDEBUG(if(p->ref != 0) tracef("Unresolved reference to label %s at %x\n" _ p->name _ sizeof(int) * (p->ref - ws->compile_base));)
      assert(p->ref == 0, ERROR_FATAL);
    }
  #endif
a847 1

a856 1
/*  assert(TRUE);*/
d871 3
a873 3
  have its binary details stripped, be run through AAsm, and the resulting listings
  compared to check the bit patterns generated. */

d888 13
a900 13
  ins(ws, LDR(8,3) | OFFSET(249),                               "LDR     r8,[r3,#249]");
  ins(ws, LDR(8,3) | OFFSET(0),                                 "LDR     r8,[r3]");
  ins(ws, STR(1,2) | GT + NEGOFFSET(12),                        "STRGT   r1,[r2,#-12]");
  ins(ws, LDRB(1,2) | PREINC(4),                                "LDRB    r1,[r2,#4]!");
  ins(ws, STRB(6,7) | POSTINC(4),                               "STRB    r6,[r7],#4");
  ins(ws, LDRB(1,2) | PREDEC(4),                                "LDRB    r1,[r2,#-4]!");
  ins(ws, STRB(6,7) | POSTDEC(4),                               "STRB    r6,[r7],#-4");
  ins(ws, LDRB(8,3) | INDEX(4,0),                               "LDRB    r8,[r3,r4]");
  ins(ws, LDR(8,3) | INDEX(4,2),                                "LDR     r8,[r3,r4, LSL #2]");

  ins(ws, PUSH | GT | (1<<4) | (1<<5) | (1<<6),                 "STMGTDB sp!,{r4,r5,r6}");
  ins(ws, POP | (1<<4) | (1<<5) | (1<<6),                       "LDMIA   sp!,{r4,r5,r6}");
  ins(ws, POP | (1<<4) | (1<<5) | (1<<6) | (1<<R(pc)),          "LDMIA   sp!,{r4,r5,r6,pc}");
d908 1
a908 1
    sprintf(a2, "LDMIA   lr,{%s}", a)
d910 1
a910 1
    sprintf(a2, "STMIA   l4,{%s}", a)
a919 1

a920 1
/* The real compiler... */
d924 1
a924 1
*    Register declaration.                                                *
a927 15
/* Most of the code generation is split into several areas: fetching a
pixel, writing a pixel, advancing source pointer, advancing destination
pointer, handling the x loop, handling the y loop. For each of these
register declarations, initialisation, and actually doing it are presented
separately. */

/* r_inword rotates right, so that the 'current' pixel is at the least
significant end. r_inshift contains the number of bits it still has to
rotate before we have used all the input pixels. r_outword and r_outshift
behave similarly. */

/* If doing PLOTMASK then r_inptr points at the ECF pattern, r_inword holds
data from the ECF pattern and rotates with r_outshift.
r_maskinword/ptr/shift are used to get the mask data. */

a935 4
#if 0
         /* debugging thing */
         && FALSE
#endif
a950 1
   /* && FALSE debug */
d961 27
d992 3
a994 2
  So, we put it in r14 to remove the need for the register allocator
  to worry about r14. */
d998 4
a1001 3
  the outer (y) loop requires swapping two 'banks' of registers.
  inptr, outptr (and maskinptr if it exists) are always registers
  r0, r1, r2, and they are visible when the y registers are swapped in. */
d1008 2
a1009 1
  so it helps to have r_oditheradd visible in the y loop */
d1032 1
a1032 3
    /* Normal case */
    /* Declare whatever other registers are needed for fetching and translating
    pixels. */
a1047 2
/*tracef("need_temps = %d, PLOTMASK = %d, DEST_32_BIT = %d\n" _ need_temps _ PLOTMASK _ DEST_32_BIT);
tracef("answerm %d\n" _ (  need_temps == 0 && ((ws->gcol != 0) || (PLOTMASK)) && DEST_32_BIT ));*/      /* use in save_pixel */
a1061 1

d1063 3
a1065 2
        /* Work out whether we need 16->32 or 32->16 transformations, with their temp registers */
        /* So, mirror the structure of translate_pixel */
a1078 1

d1087 2
a1088 1
    into the current destination pixel. */
d1100 3
a1102 2
    horizontal scaling. For some simple cases no scaling registers
    are needed. */
d1110 2
a1111 1
  it does not get loaded before the y loop variables are initialised. */
d1114 7
a1121 5
/* MAX POSSIBLE REQUIREMENT - 13, if vcount stuff not done.
It may appear 15, but temp1 and temp2 are only needed if one of src/dst
is 32bpp, in which case we save elsewhere.
>>> AH not so, they are also needed if a palette is used, in which case
the source can be fewer bpp. Ooops. Can we ever overflow? Not sure. */
d1135 3
a1137 2
the vertical loop. These registers are part of a separate 'bank'
from those in the central loop. */
d1141 3
a1143 2
                                  RN(r_ycount, -1, "total for y scale")
                                                  /* Adder and subractor values become constants in the code. */
d1147 2
a1149 1
/* MAX POSSIBLE REGISTER USAGE - 5 registers */
d1153 1
a1153 1
*    Register initialisation.                                             *
d1157 1
d1165 1
a1165 1
    sprintf(a, "LDR     " #reg "," #value " %t40.; " comment);        \
a1171 1

d1177 1
a1177 1
    sprintf(a, "LDR     " #destreg ",[" #indexreg ", #%i] %t40.; " comment, offset);      \
d1186 4
a1189 3
that if this is JPEG data then the save_inshift value was not calculated,
because SpriteExtend assembler stuff thought this was 32bit data. This
only matters if JPEG is being made to produce 8bpp or 16bpp data. */
d1216 2
a1217 1
pixels. */
a1218 1

d1251 1
a1251 2
      AND(R(r_pixel), R(r_ecfindex), IMM(0x18),              "AND     r_pixel,r_ecfindex,#&18          ; extract initial row offset in ECF");
/*      AND(R(r_pixel), R(r_ecfindex), IMM(0x38),              "AND     r_pixel,r_ecfindex,#&38         ; extract initial row offset in ECF");*/
a1295 1

a1315 1

d1326 12
a1337 12
      This only happens for a 16bpp or 32bpp source that's being truncated somewhat.
      A square of output pixels has the following binary addition values:
                   11    01
                   00    10
      These values are added to the value of each or R/G/B, just before those values are
      truncated or looked up in a table, shifted so that we add to the bits which are
      just about to be discarded.
      We keep the value to add in r_oditheradd.
      To proceed along the x axis we EOR by 10 every output pixel.
      We must also EOR by 01 every line.
      The starting value must be aligned with the origin of the output. */

d1345 1
a1345 1
          OP2R(R(r_pixel)) | LSLI(1),                            "ORR     r_oditheradd,r_oditheradd,r_pixel,LSL #1 ; dither add value");
d1360 1
a1360 1
        IFDEBUG(sprintf(a, "MOV     r_oditheradd,r_oditheradd,LSL #%i %t40; shift to top of word", 23 + ws->odither);)
d1370 2
a1371 1
into the current destination pixel. */
a1385 1

d1416 3
a1418 2
horizontal scaling. For some simple cases no scaling registers
are needed. */
d1425 5
a1429 3
        LDR_WP(r_pixel, save_xcount); /* Changed by (GPS) to fix register spill bug*/
    } else {
        LDR_WP(r_xcount, save_xcount);
d1438 3
a1440 2
the vertical loop. These registers are part of a separate 'bank'
from those in the central loop. */
d1459 1
a1459 1
*    Pixel loading, translation, saving.                                  *
a1461 19

#ifdef DEBUG
  #define DELAY 0 /* turn it off - just an experiment */
  #if DELAY
    static void artificial_delay(asm_workspace *wp, workspace *ws, int count)
    {
      char a[256];
      comment(ws, "Artificial delay");
      assert(count < 256, ERROR_FATAL);
      sprintf(a,                                      "MOV     r_pixel,#%i           ; delay counter", count);
      MOV(R(r_pixel), IMM(count), a);
      ws->labels.loop_delay.def = 0; /* Reuse label if necessary - won't compile with AAsm, sorry! */
      DEFINE_LABEL(                            loop_delay,                            "Delay loop")
      SUB(R(r_pixel), R(r_pixel), S | IMM(1),         "SUBS    r_pixel,r_pixel,#1    ; decrement count");
      branch(ws, B | NE, L(loop_delay),               "BNE     loop_delay            ; until done");
    }
  #endif
#endif

d1464 3
a1466 2
from fetch_pixel for the case of scaling up an ordered dither, where the same input
pixel is repeatedly fetched and translated. */
a1467 8
  #ifdef DEBUG
    #if DELAY
      /* Artificial delay, to simulate what working with decompression is like */
      artificial_delay(wp, ws, 50);
      /* 50 here is 200 ticks of the CPU - a reasonable guess at my "100 instructions"? */
    #endif
  #endif

d1474 1
a1474 1
             | INDEX(R(r_ecfindex), 0),                 "LDR     r_inword,[r_inptr,r_ecfindex] 2222");
d1491 2
a1492 2
//          AND(R(r_pixel), R(r_inword), IMM(ws->out_pixmask),"AND     r_pixel,r_inword,#out_pixmask    ; fetch the pixel from the ECF pattern");
//        AND(R(r_pixel), R(r_pixel), OP2R(R(r_bgcolour)),    "AND     r_pixel,r_pixel,r_bgcolour       ; turn it into a background colour pixel");
d1503 2
a1504 2
        MOV(R(r_pixel), OP2R(R(r_inword)) | LSLI(16),     "MOV     r_pixel,r_inword,LSL #16        ; fetch 16 bit pixel");
        MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(16),      "MOV     r_pixel,r_pixel,LSR #16");
d1509 1
a1509 1
        AND(R(r_pixel), R(r_inword), IMM(ws->in_pixmask), "AND     r_pixel,r_inword,#in_pixmask    ; fetch the pixel");
a1513 48
#if 0

static void fetch_pixel_unmaskedPL(asm_workspace *wp, workspace *ws)
/* Assuming no mask, get the next input pixel and put it in r_pixel. This is separated
from fetch_pixel for the case of scaling up an ordered dither, where the same input
pixel is repeatedly fetched and translated. */
/* Conditional version added by (GPS) so unnecessary fetch_pixel is skipped.*/
{
  #ifdef DEBUG
    #if DELAY
      /* Artificial delay, to simulate what working with decompression is like */
      artificial_delay(wp, ws, 50);
      /* 50 here is 200 ticks of the CPU - a reasonable guess at my "100 instructions"? */
    #endif
  #endif

  if (PLOTMASK)
  {
 /*   comment(ws, "Fetch an ECF pixel");
    if (DEST_32_BIT)
      ins(ws, LDR(R(r_pixel), R(r_inptr))
             | INDEX(R(r_ecfindex), 0),                 "LDR     r_pixel,[r_inptr,r_ecfindex]");
    else if (DEST_16_BIT)
    {
      MOV(R(r_pixel), OP2R(R(r_inword)) | LSLI(16),     "MOV     r_pixel,r_inword,LSL #16        ; fetch 16 bit ECF pattern pixel");
      MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(16),      "MOV     r_pixel,r_pixel,LSR #16");
    }
    else
      AND(R(r_pixel), R(r_inword), IMM(ws->out_pixmask),"AND     r_pixel,r_inword,#out_pixmask    ; fetch the pixel from the ECF pattern");
    AND(R(r_pixel), R(r_pixel), OP2R(R(r_bgcolour)),    "AND     r_pixel,r_pixel,r_bgcolour       ; turn it into a background colour pixel");
 */ }
  else
  {
    comment(ws, "Fetch a source pixel");
    if (SOURCE_32_BIT)
      ins(ws, LDR(R(r_pixel), R(r_inptr)) | PL | OFFSET(0),  "LDRPL         r_pixel,[r_inptr]");
    else if (SOURCE_16_BIT)
    {
      MOV(R(r_pixel), OP2R(R(r_inword)) | PL | LSLI(16),     "MOV     r_pixel,r_inword,LSL #16        ; fetch 16 bit pixel");
      MOV(R(r_pixel), OP2R(R(r_pixel)) | PL | LSRI(16),      "MOV     r_pixel,r_pixel,LSR #16");
/*       >>> Maybe we can leave it in the top 16 bits, and get by? Not yet.*/
    }
    else
      AND(R(r_pixel), R(r_inword), PL | IMM(ws->in_pixmask), "AND     r_pixel,r_inword,#in_pixmask    ; fetch the pixel");
  }
}
#endif

d1516 3
a1518 2
transparent then branch out to l_masked. Return TRUE if the branch could be
taken, else FALSE. */
d1525 1
a1525 1
    IFDEBUG(sprintf(a,                                "BEQ     %s", l_masked->name);)
d1536 4
a1539 3
that no word of input need be loaded between these two. If the pixel is
transparent then branch out to l_masked. Return TRUE if the branch could be
taken, else FALSE. */
d1541 3
a1543 3
  #ifdef DEBUG
    char a[256];
  #endif
d1551 7
a1557 7
        MOV(R(r_maskinword), OP2R(R(r_maskinword))
                         | RORI(ws->mask_bpp),                 "x"/*MOV     r_maskinword,r_maskinword,ROR #mask_bpp"*/);
        SUB(R(r_maskinshift),R(r_maskinshift),
                         S | IMM(ws->mask_bpp*2) | IMMROR(6),  "x"/*SUBS    r_maskinshift,r_maskinshift,#mask_bpp:SHL:27"*/);
        ins(ws, LDR(R(r_maskinword), R(r_maskinptr))
            | EQ | WRITEBACK | OFFSET(4),                     "x"/* "LDREQ   r_maskinword,[r_maskinptr,#4]!     ; load more mask pixels (inc2)"*/);
        TST(R(r_maskinword), IMM(1),                           "TST     r_maskinword,#1");
d1565 1
a1565 1
      IFDEBUG(sprintf(a,                                "BEQ     %s", l_masked->name);)
a1587 1
/* Discard the gun name argument */
d1591 3
a1593 2
/* Do one gun of the ordered dither - entirely local to add_ordered_dither below */
/* Offset is the offset from bit 0 of the base of this field of the colour */
d1596 3
a1598 3
  #ifdef DEBUG
    char a[256];
  #endif
d1600 1
a1600 1
  IFDEBUG(sprintf(a,                                  "CMN     r_oditheradd,r_pixel,LSL #%i %t40; will the %s value overflow?", x, gun);)
d1603 1
a1603 1
  IFDEBUG(sprintf(a,                                  "ADDCC   r_pixel,r_pixel,r_oditheradd,LSR #%i %t40; if not, add.", x);)
d1610 7
a1616 6
r_oditheradd >> (32-bits_per_gun) added to each of R/G/B, except that these
additions should be 'sticky' at 255 in each gun.

The resulting values are just about to be truncated somewhat, so the lo
bits of each answer do not matter much. Thus, if the value is currently
254 we never add, but this doesn't matter. */
d1641 1
a1641 1
  return; /* No more transformation necessary */
d1668 1
a1668 1
    comment(ws,                                   "                                                             fedcba9876543210 fedcba9876543210");
a1675 13
    /* From AGlover's code:
    munge32to16:
                                              ;       fedcba9876543210 fedcba9876543210
                                              ; in2 = 00000000bbbbbbbb ggggggggrrrrrrrr
        AND     xadd,in2,#&F80000             ; im1 = 00000000bbbbb000 0000000000000000
        MOV     ttr,xadd,LSL #7               ; ttr = 0bbbbb0000000000
        AND     xadd,in2,#&F800               ; im1 = 0000000000000000 ggggg00000000000
        ORR     ttr,ttr,xadd,LSL #10          ; ttr = 0bbbbbggggg00000
        AND     xadd,in2,#&F8                 ; im1 = 0000000000000000 00000000rrrrr000
        ORR     in2,ttr,xadd,LSL #13          ; in2 = 0bbbbbgggggrrrrr
    ; NB result in top half of register
    ; Needs two work registers
    */
a1696 20
    /* From AGlover's code:
                                          ;       fedcba9876543210 fedcba9876543210
                                          ; in2 = 0bbbbbgggggrrrrr
        MOV     im1,in2,LSR #26           ; im1 =                            0bbbbb
        MOV     ttr,im1,LSL #19           ; ttr =        0bbbbb000 0000000000000000
        AND     im1,in2,#&03E00000        ; im1 = 000000ggggg00000
        ORR     ttr,ttr,im1,LSR #10       ; ttr =        0bbbbb000 ggggg00000000000
        MOV     im1,in2,LSL #11           ; im1 = rrrrr00000000000 0000000000000000
        ORR     ttr,ttr,im1,LSR #24       ; ttr =        0bbbbb000 ggggg000rrrrr000
    ;now copy the top three bits of each colour component into the bottom three
        MOV     im1,#&E0                  ;avoid an LDR for speed
        ORR     im1,im1,im1,LSL #8
        ORR     im1,im1,im1,LSL #8        ; im1 = 0000000011100000 1110000011100000
        AND     im1,im1,ttr               ; im1 = 00000000bbb00000 ggg00000rrr00000
        ORR     in2,ttr,im1,LSR #5        ; in2 = 00000000bbbbbbbb ggggggggrrrrrrrr
    ; NB input in top half of register
    ; Needs two work registers
    ; Three instructions above are constructing a constant: could be retained if
    ; no register pressure.
    */
d1726 6
a1731 5
    /* Hack for JPEG data in RISC OS 3 */
    /* r_pixel is a 16bpp colour value at the moment, but we have no lookup table for the 16->1/2/4/8 transition */
    /* For 1/2/4bpp we use the top bits of red as the grey level. From a JPEG source this will work
       fine, as the JPEG will have noticed that the output is mono and simply produced greyscale
       output. */
d1760 9
a1768 9
        bit 0 - tint 0
        bit 1 - tint 1
        bit 2 - red 2
        bit 3 - blue 2
        bit 4 - red 3 (high)
        bit 5 - green 2
        bit 6 - green 3 (high)
        bit 7 - blue 3 (high)
      */
d1772 3
a1774 2
      by adding them all up, multiplying by 3, and dividing by 8. We involve the lo bits in the approximation
      as well, in case they produce a useful carry. */
a1811 18
#if 0
  if (wp->cal_table)
  {
    /* >>> This ought to be more complex. There's no real reason why it can't work on any combination of
    16 and 32 bit data. If simple, do the lookups yourself. If you have to call SWIs, keep a cache. */
/*#ifndef DEBUG*/
/* Commented out because it's never used (GP */
#define ColourTrans_ConvertDeviceColour   0x40753
    comment(ws, "Perform printer calibration adjustment.");
    assert(pixl2bpp == 5, ERROR_FATAL); /* we have 32-bit data in r_pixel */
    ins(ws, PUSH | 14,                                              "STMDB   sp!,{r1,r2,r3}                   ; prepare to call SWI");
    MOV(R(r1), OP2R(R(r_pixel)) | LSLI(8),                          "MOV     r1,r_pixel,LSL #8                ; r1=&BBGGRR00");
    MOV(R(r3), OP2R(R(r_table)),                                    "MOV     r3,r_table                       ; r3=calibration table");
    ins(ws, SWI(ColourTrans_ConvertDeviceColour),                   "SWI     ColourTrans_ConvertDeviceColour  ; convert r1 value");
    MOV(R(r_pixel), OP2R(R(r3)) | LSLI(8),                          "MOV     r_pixel,r2,LSR #8                ; returned r2 is calibrated colour");
    ins(ws, POP | 14,                                               "LDMIA   sp!,{r1,r2,r3}                   ; restore after calling SWI");
  }
#endif
d1829 10
a1838 10
/* GCOL actions:
  0 -> overwrite old pixel
  1 -> OR with old pixel
  2 -> AND with old pixel
  3 -> EOR with old pixel
  4 -> invert old pixel
  5 -> do nothing
  6 -> AND old pixel with NOT of new pixel
  7 -> OR old pixel with NOT of new pixel
*/
a1853 2
/*        BIC(R(r_outword), R(r_outword), IMM(255),                 "BIC     r_outword,r_outword,#0x00ff       ;4349");
        BIC(R(r_outword), R(r_outword), IMM(255) | IMMROR(24),    "BIC     r_outword,r_outword,#0xff00       ;449");*/
a1862 1
/*        BIC(R(r_outword), R(r_outword), IMM(ws->out_dpixmask),    "1BIC     r_outword,r_outword,#out_dpixmask");*/
d1879 7
a1885 7
        case 7: MVN(R(r_pixel), OP2R(R(r_pixel)),                     "MVN     r_pixel,r_pixel                       ; OR with neg action");
        case 1: ORR(R(r_temp1), R(r_pixel), OP2R(R(r_temp1)),         "ORR     r_temp1,r_pixel,r_temp1               ; OR gcol action"); break;
        case 6: MVN(R(r_pixel), OP2R(R(r_pixel)),                     "MVN     r_pixel,r_pixel                       ; AND with neg action");
        case 2: AND(R(r_temp1), R(r_pixel), OP2R(R(r_temp1)),         "AND     r_temp1,r_pixel,r_temp1               ; AND gcol action"); break;
        case 3: EOR(R(r_temp1), R(r_pixel), OP2R(R(r_temp1)),         "EOR     r_temp1,r_pixel,r_temp1               ; EOR gcol action"); break;
        case 4: MVN(R(r_temp1), OP2R(R(r_temp1)),                     "MVN     r_temp1,r_temp1                       ; neg gcol action"); break;
  /*      case 5: MOV(R(r_temp1), OP2R(R(r_temp1)),                     "MOV     r_temp1,r_temp1                       ; no gcol action"); break;*/
d1911 2
a1912 4
      case 0:
        if (SOURCE_MASK) /* if no mask, the pixels are clear already */
        {
          if (DESTD_16_BIT)
d1914 7
a1920 2
            BIC(R(r_outword), R(r_outword), IMM(255),                 "BIC     r_outword,r_outword,#0x00ff");
            BIC(R(r_outword), R(r_outword), IMM(255) | IMMROR(24),    "BIC     r_outword,r_outword,#0xff00");
d1922 15
a1936 18
          else
            BIC(R(r_outword), R(r_outword), IMM(ws->out_dpixmask),    "BIC     r_outword,r_outword,#out_dpixmask");
        }
        /* fall through */
      case 7:
      case 1: ORR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),       "ORR     r_outword,r_outword,r_pixel           ; gcol action"); break;
      case 6:
      case 2: AND(R(r_outword), R(r_outword), OP2R(R(r_pixel)),       "AND     r_outword,r_outword,r_pixel           ; AND gcol action"); break;
      case 3: EOR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),       "EOR     r_outword,r_outword,r_pixel           ; EOR gcol action"); break;
      case 4: if (DESTD_16_BIT)
              {
                EOR(R(r_outword), R(r_outword), IMM(255),             "EOR     r_outword,r_outword,#0x00ff           ; negate existing pixel");
                EOR(R(r_outword), R(r_outword), IMM(255) | IMMROR(24),"EOR     r_outword,r_outword,#0xff00");
              }
              else
                EOR(R(r_outword), R(r_outword), IMM(ws->out_dpixmask),"EOR     r_outword,r_outword,#out_dpixmask     ; negate existing pixel");
              break;
      case 5: comment(ws, "no GCOL action"); break;
d1953 1
a1953 1
/* Save pixel for use by optimised >5 scaleing code. */
d2001 1
a2001 1
*    Advancing the current pixel.                                         *
a2036 1
      /*MOV(R(r_maskinshift), EQ | IMM(32),                    "MOVEQ   r_maskinshift,#32"); */
d2051 2
a2052 1
optimised loop */
d2090 1
a2090 1
                         | RORI(ws->mask_bpp),               "x"/*MOV     r_maskinword,r_maskinword,ROR #mask_bpp"*/);
d2092 2
a2093 4
                         S | IMM(ws->mask_bpp*2) | IMMROR(6),  "x"/*SUBS    r_maskinshift,r_maskinshift,#mask_bpp:SHL:27"*/);
/*                         S | IMM(ws->mask_bpp*2),          "SUBS    r_maskinshift,r_maskinshift,#mask_bpp*2");*/
/*      MOV(R(r_maskinshift), EQ | IMM(16) | IMMROR(4),        "MOVEQ   r_maskinshift,#32:SHL:27                  ; reset shift counter (inc2)");
*/      ins(ws, LDR(R(r_maskinword), R(r_maskinptr))
d2106 3
a2108 2
/* Call every output pixel - alternates the ordered dither addition value */
/* xy == 0 for x, 1 for y */
d2119 3
a2121 2
/* skip over masked out words. r_xcount = output pixels to skip
                               r_temp1   = pixels left in current word.*/
d2147 1
d2196 2
a2197 1
    The last word has to be patched up carefully, see x_loop. */
a2215 1

d2220 3
a2222 2
a word fetch won't be necessary after the first of these. Only used in the
optimised 2-at-a-time inner loop. You are assured that gcol==0. */
d2247 2
a2248 1
    The last word has to be patched up carefully, see x_loop. */
d2255 3
a2257 2
                                     r_temp1   = pixels left in current word.
                                     r_pixel = pixel to output.*/
a2297 1

a2301 1
/*    DEFINE_LABEL(plot_loopa, "3331???")*/
a2330 12
/*    if (DESTD_16_BIT)
    {
      BIC(R(r_outword), R(r_outword), NE | IMM(255),                 "23BICNE   r_outword,r_outword,#0x00ff");
      BIC(R(r_outword), R(r_outword), NE |IMM(255) | IMMROR(24),     "24BICNE   r_outword,r_outword,#0xff00");
    }
    else
      BIC(R(r_outword), R(r_outword), NE | IMM(ws->out_dpixmask),    "25BICNE   r_outword,r_outword,#out_dpixmask");
    ORR(R(r_outword), R(r_outword), NE | OP2R(R(r_pixel)),           "26ORRNE   r_outword,r_outword,r_pixel           ; gcol action");
    MOV(R(r_outword), NE | OP2R(R(r_outword)) | RORI(wp->BPC),       "25MOVNE   r_outword,r_outword,ROR #out_bpc");
    SUB(R(r_outshift), R(r_outshift),
        NE | S | IMM(wp->BPC*2) | IMMROR(6),                         "27SUBNES  r_outshift,r_outshift,#out_bpc:SHL:27");
*/
d2367 1
a2368 1

a2400 1
/*  write_reg(ws, &ws->regnames.r_temp1);*/
d2409 1
a2409 1
*    Overall construction of the X loop                                   *
d2428 1
a2428 1
      IFDEBUG(sprintf(a, "CMP     %s,#0", r->name);)
d2450 1
a2450 1
        sprintf(a,
d2463 2
a2464 1
and shift values. */
a2487 2
      /* Changed by (GPS) to fix bug when LHS of sprite obscured => Plotting mask incorrectly */
/*      RSB(R(r_pixel), R(r_maskinshift), IMM(32),              "RSB     r_pixel,r_maskinshift,#32         ; mask shift");*/
a2528 1

a2533 8
static void align16(asm_workspace *wp, workspace *ws)
/* Align next instruction to quadword boundary */
{
  UNUSED(wp);
  while (((int) ws->compile_ptr) & 15 != 0)
    MOV(R(r_pixel), OP2R(R(r_pixel)),                        "MOV     r_pixel,r_pixel                 ; align to 16-byte boundary");
}

d2536 2
a2537 1
single line. Fall out of the bottom of the loop when complete. */
d2548 2
a2549 1
    and so only save registers that need to be saved - not a big saving, and only per-line. */
d2559 1
a2559 1
  #if 0
d2570 1
a2570 1
  #else
d2573 5
a2577 4
      etc. every two pixels. There are two versions of this loop, one where the in and out shifts
      are 'in phase' (ie initially both even or both odd), one where they are out of phase. There
      is also some initial stuff to get the outshift to be even if necessary when entering either
      of these, and some final stuff to patch up the end. */
d2625 3
a2627 2
        by effectively winding it back by a pixel. We know this won't go back a word,
        however, because r_inshift is an odd number of pixels. */
d2679 1
a2679 2
  #endif

d2687 2
a2688 1
        a pixel we must repeatedly fetch_pixel it. */
d2692 1
a2692 3
#ifdef DEBUG
        /*write_reg(ws, &ws->regnames.r_xcount);*/
#endif
d2702 2
a2703 2
        the dithering on scaled up pixels will not occur. */
/*        fetch_pixel_unmaskedPL(wp, ws);*/ /* reextract the pixel into r_pixel */
d2716 2
a2717 9
/*          wp->save_xmag = wp->save_xmag / wp->save_xdiv;
          wp->save_xadd = wp->save_xadd / wp->save_xdiv;
          wp->save_xcount = wp->save_xcount / wp->save_xdiv;
          wp->save_xdiv = 1;
          wp->save_ymag = wp->save_ymag / wp->save_ydiv;
          wp->save_yadd = wp->save_yadd / wp->save_ydiv;
          wp->save_ycount = wp->save_ycount / wp->save_ydiv;
          wp->save_ydiv = 1;*/
tracef("in optimised scale\nxmag = %d, xdiv = %d, xmag mod xdiv = %d\n" _ wp->save_xmag _ wp->save_xdiv _ wp->save_xmag % wp->save_xdiv);
d2721 1
a2721 2
/*          CMN(R(pc), OP2R(R(pc)),                                 "CMN     pc, pc   ; this will clear the Z flag");
*/          DEFINE_LABEL(loop_x_exitskip,          "3Kludge to avoid multiple forward references");
d2726 3
a2728 2
                                 this whole loop to improve that situation, but it doesn't really seem worthwhile, the gain
                                 is not enormous. */
d2736 1
a2736 2
/*          MOV(R(r_xcount), PL | IMM(toskip),                            "3MOVPL   r_xcount, #scalefactor                               ");
*/
d2746 1
a2746 1
/*          DEFINE_LABEL(loop1, "We need to skip at least this word.")*/
d2749 1
a2749 3
/*          TEQ(R(r_xsize), IMM(0),                                       "TEQ     r_xsize, #0");
          branch(ws, B + EQ, L(loop_x_exitskip),                        "BEQ     loop_x_exitskip                 ; end of line");
*/        if (DEST_32_BIT)
d2760 1
a2760 3
/*            TEQ(R(r_xsize), IMM(0),                                      "1TEQ     r_xsize, #0");
            branch(ws, B + EQ, L(loop_x_exitskip),                       "1BEQ     loop_x_exitskip                 ; end of line");
*/          branch(ws, B, L(loop_x_repeat),                              "1B       loop_x_repeat                   ; end of this masked input pixel");
d2774 3
a2776 2
                                 this whole loop to improve that situation, but it doesn't really seem worthwhile, the gain
                                 is not enormous. */
d2790 3
a2792 2
        /* >>> There's not all that much point in this being separate from the odither case - could really
        abandon this one and use the ditering one all the time, with tiny variants. Not done. */
d2798 3
a2800 2
                                 this whole loop to improve that situation, but it doesn't really seem worthwhile, the gain
                                 is not enormous. */
d2818 1
a2818 2
/*          register int toskip = wp->save_xmag / wp->save_xdiv;
*/
a2819 2
          fetch_pixel_inc(wp, ws);
/*          CMP(R(r_xsize), IMM(toskip),                               "CMP      r_xsize, #scalefactor");*/
d2835 1
a2835 1
/*          DEFINE_LABEL(loop1, "We need to skip at least this word.")*/
d2838 1
a2838 3
/*          TEQ(R(r_xsize), IMM(0),                                      "1@@TEQ     r_xsize, #0");
          branch(ws, B + EQ, L(loop_x_exitskip),                       "11@@BEQ     loop_x_exitskip                 ; end of line");
*/          if (DEST_32_BIT)
d2848 2
a2849 3
/*            TEQ(R(r_xsize), IMM(0),                                      "1@@@@TEQ     r_xsize, #0");
            branch(ws, B + EQ, L(loop_x_exitskip),                       "1@@BEQ     loop_x_exitskip                 ; end of line");
*/            branch(ws, B, L(loop_x_repeat),                            "1@@@@B       loop_x_repeat                   ; end of this masked input pixel");
d2888 2
a2889 1
        partially overwrite, and combine the new and old pixels. */
d2910 1
a2910 1
*    Overall construction of the Y loop                                   *
a2913 21
#if 0
static void tracepoint(asm_workspace *wp, workspace *ws)
/* Insert this in your compiled code to call back to the assembler code,
to output debugging info. Of limited use because of the registers it
needs. */
/* This routine was added in order to chase a specific bug. It would be better
to build in a more general trace facility from the compiled code, which finds fp
and an assembler routine to call. The ability to preserve r14 during this would
also be good, so that only sp was assumed. Another time! */
{
#if 0
  assert(R(r_blockroutine), ERROR_FATAL); /* make sure it's in use */
  assert(ws->leave_r12_alone, ERROR_FATAL); /* the trace routine relies on it */
  MOV(R(lr), OP2R(R(pc)),                                       "MOV     lr,pc                    ; TRACE: remember return address");
  SUB(R(pc), R(r_blockroutine), IMM(4),                         "SUB     pc,r_blockroutine,#4     ; TRACE: secret trace entrypoint");
    MOV(R(r_pixel), OP2R(R(r_pixel)),                        "MOV     r_pixel,r_pixel                 ; TRACE1");
    MOV(R(r_pixel), OP2R(R(r_pixel)),                        "MOV     r_pixel,r_pixel                 ; TRACE2");
#endif
}
#endif

d2925 6
a2930 6
  #ifdef DEBUG
    char xregs[256];
    char yregs[256];
    char ptrregs[256];
    char a[256];
  #endif
a3003 1
        #ifdef JPEG
a3006 1
        #endif
d3008 4
a3011 3
                           you were assuming 4 bits of colour per gun. In other words, the tint is NOT
                           effective enough at representing the next two bits of colour output!
                           If the source is known to be greyscale then 3 is a better value. */
d3051 1
a3051 1
  if (! onebank) ws->next_free_reg = 4; /* Overlay the x-loop register allocations - but not ptr registers */
d3064 1
a3064 3
#ifdef DEBUG
  /*write_reg(ws, &ws->regnames.r_pixel);*/
#endif
d3068 1
a3068 1
  IFDEBUG(sprintf(a, "STMDB   sp!,{%s,%s}", ptrregs,xregs);)
a3081 1
    /*write_reg(ws, &ws->regnames.r_pixel);*/
d3088 1
a3088 1
  /*end added code...*/
d3110 1
a3110 1
    IFDEBUG(sprintf(a,                                      "STMIA   sp,{%s}", ptrregs);)
d3133 1
a3133 3
  if (onebank)
    ; /* the x-loop variables are already set up, with inptr/outptr/maskinptr saved at new values */
  else
d3135 1
d3137 1
a3137 1
    IFDEBUG(sprintf(a,                                      "STMDB   sp!,{%s} %t40; push y-loop variables", yregs);)
d3139 1
a3139 1
    IFDEBUG(sprintf(a,                                      "LDMIA   lr,{%s} %t40; load x-loop variables", xregs);)
d3150 1
a3150 1
    IFDEBUG(sprintf(a,                                      "LDMIA   sp,{%s,%s} %t40; reload x-loop and ptr registers", ptrregs, xregs);)
d3155 1
a3155 1
    IFDEBUG(sprintf(a,                                      "LDMIA   sp!,{%s} %t40; pop y-loop variables", yregs);)
d3159 1
a3159 1
    IFDEBUG(sprintf(a,                                      "LDMIA   sp,{%s} %t40; reload ptr registers", ptrregs);)
d3180 1
a3180 1
    IFDEBUG(sprintf(a,                                      "STMIA   sp,{%s} %t40.; Save updated ptr registers", ptrregs);)
a3197 1
/*      ADD(R(r_inptr), R(r_inptr), EQ | IMM(32),             "ADDEQ   r_inptr,r_inptr,#32             ; and if reached, reset to top");*/
d3221 1
a3221 2
 /* MOV(R(r_inshift), OP2R(R(sp)),         "MOV   r_inshift, sp");
  write_reg(ws, &ws->regnames.r_inshift);*/
d3223 1
a3223 3
/*  MOV(R(r_inshift), OP2R(R(sp)),         "MOV   r_inshift, sp");
  write_reg(ws, &ws->regnames.r_inshift);*/
/*  ins(ws, POP | 0x9fff,                                     "LDMIA   sp!,{r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,pc} ; restore, exit");*/
d3225 1
a3225 2
/*  MOV(R(r_inshift), OP2R(R(lr)),         "MOV   r_inshift, lr");
  write_reg(ws, &ws->regnames.r_inshift);*/
d3231 1
a3231 1
*    The main compiler.                                                   *
d3236 1
d3251 1
a3252 1
#ifdef JPEG
d3261 1
a3261 1
#ifdef JPEG
d3282 2
a3283 3
   /*    if((((p->xadd-p->xdiv) % p->xdiv) == 0) && (((p->xadd-p->xdiv) / p->xdiv) > 4))
         wp->save_xcount = wp->save_xcount / p->xdiv;*/
       return (blitter) p->code;
d3299 3
a3301 2
  p->key_word = key_word; /* doesn't happen if we bomb from the compilation for any reason */
  /** SWI here to synchronise the code areas on ARM810/StrongARM **/
d3304 2
a3305 1
  return (blitter) ws->compile_base;
d3325 4
a3328 4
  #ifdef DEBUG
    ws->tracing = tracing;
    if (tracing) dump_asm_workspace(wp);
  #endif
d3331 1
a3331 1
  ws->mask1bpp = ws->masked & (((wp->save_mode) >> 27) != 0);
d3339 1
a3339 1
  #ifdef JPEG
d3347 3
d3351 3
a3353 11
    if (*compress_id_word == -1)
    {
      tracef("This JPEG sprite was constructed by PutJPEGScaled\n");
      jpeg_data = (char*)(compress_id_word[1]);
      jpeg_data_size = compress_id_word[2];
    }
    else
    {
      jpeg_data = (char*) s + s->image + sizeof(int);
      jpeg_data_size = s->next - s->image - sizeof(int);
    }
d3355 2
a3356 2
    {
      int ok0 = find_image_dims(jpeg_data, 0, 0, 0, 0, &ws_size, 0); /* Find out how many bytes of workspace we need */
d3358 4
a3361 3
      ws_size -=10000; /* find_image_dims returns required size +10000 so that when
                          it is called by the JPEG_Info SWIs it can tell an application
                          how much space will be eventually allocated. */
a3362 4
      assert(ok0 == 0, ERROR_BAD_JPEG);                            /* else, bad JPEG data  - >>>> Need better error reporting here! */
                                                                              /* Error already reported... (GPS) */
    }

d3368 1
a3368 2
      int             area_no,
      		      size;
d3384 1
a3384 1
      int	      size;
d3390 5
a3394 5
      	if (size != cinfo->workspace_size)
      	{
      	  cinfo->error_code = -1;
      	  cinfo->workspace_size = size;
      	  tracef("Marking area as duff\n");
d3407 5
a3411 4
      	_kernel_oserror *error;
      	int             bytes_moved;
      	error = _swix(OS_ChangeDynamicArea, _IN(0) | _IN(1) | _OUT(1),
      	      	      	      	    wp->area_number, ws_size-size, &bytes_moved);
d3413 3
a3415 3
      	assert(error == NULL, ERROR_NO_MEMORY);
      	cinfo->error_code = -1;                      /* mark the workspace entirely uninitialised */
      	cinfo->workspace_size = size+bytes_moved;
d3425 1
a3425 1
      assert(cinfo != 0, ERROR_NO_MEMORY);                          /* >>>> Got to be a better way of returning this error! */
d3433 1
a3433 1
      assert(cinfo != 0, ERROR_NO_MEMORY);                         /* >>>> Got to be a better way of returning this error! */
d3452 3
a3454 2
    the number of pixels in the X direction. Correct this now. If we get x-interpolation
    then this gets undone later. */
a3486 2
      /* if ((wp->save_xadd - wp->save_xdiv) > wp->save_xdiv) opt |= jopt_INTERP_X; */
      /* if (wp->save_xadd - wp->save_xdiv == wp->save_xdiv && simple_y_scale(wp,ws)) */
d3514 5
a3518 5
     	if (temp) opt |= jopt_GREY;
	if (temp == 2)
	{
	  opt |= jopt_OUTBPP_8GREY;
	  opt &= ~jopt_DIFFUSE;
d3551 5
a3555 5
	    if (temp) opt |= jopt_GREY;
	    if (temp == 2)
	    {
	       opt |= jopt_OUTBPP_8GREY;
	       opt &= ~jopt_DIFFUSE;
d3557 1
a3557 1
	  }
d3581 9
a3589 9
  tracef("After set up, options are:\n");
  if (opt & jopt_GREY) tracef("   jopt_GREY\n");
  if (opt & jopt_DC_ONLY) tracef("   jopt_DC_ONLY\n");
  if (opt & jopt_INTERP_X) tracef("   jopt_INTERP_X\n");
  if (opt & jopt_OUTBPP_8) tracef("   jopt_OUTBPP_8\n");
  if (opt & jopt_OUTBPP_16) tracef("   jopt_OUTBPP_16\n");
  if (opt & jopt_OUTBPP_8YUV) tracef("   jopt_OUTBPP_8YUV\n");
  if (opt & jopt_DIFFUSE) tracef("   jopt_DIFFUSE\n");
  if (opt & jopt_OUTBPP_8GREY) tracef("   jopt_OUTBPP_8GREY\n");
a3606 1
/*      if (cinfo->error_argument1 & jopt_OUTBPP_8YUV) *//* we asked for it, and we got it - 8bpp output pixels */
d3616 1
a3616 1
  #endif
d3618 8
a3625 8
  #if 1
  #ifdef DEBUG
    /* Additional mask tracing */
    if (PLOTMASK)
    {
      int i;
      int j;
      char *p;
d3627 17
a3643 18
      tracef("Sprite data:\n");
      p = (char*) wp->save_inptr;
      for (i = 0; i < 16; i++)
      {
        tracef("%x" _ p);
        for (j = 0; j < 16; j++) tracef(" %2x" _ p[j]);
        tracef("\n");
        p -= wp->save_inoffset; /* convert from byte offset to int offset */
      }
      tracef("Mask data:\n");
      p = (char*) (SOURCE_BPPMASK ? wp->save_maskinptr : (int) wp->save_inptr + wp->save_masko);
      for (i = 0; i < 16; i++)
      {
        tracef("%x" _ p);
        for (j = 0; j < 16; j++) tracef(" %2x" _ p[j]);
        tracef("\n");
        p -= wp->save_inoffset;
      }
d3645 3
a3647 2
  #endif
  #endif
d3651 1
a3651 1
  assert((wp->spritecode & 255) == 52);        /* Only PutSpriteScaled supported so far. */
d3657 5
a3661 5
  #ifdef DEBUG
    if (PLOTMASK)
    {
      int *ecf = (int*) wp->save_ecflimit;
      int i;
d3663 5
a3667 5
      tracef("PlotMaskScaled, ECF pattern:\n");
      for (i = 0; i <= 8; i++)
        tracef("%x: %c %x %x\n" _ ecf + 2*i _ (ecf+2*i == (int*)wp->save_ecfptr ? '>' : ' ') _ ecf[2*i] _ ecf[2*i + 1]);
    }
  #endif
d3674 1
a3674 1
    #ifdef DEBUG
d3684 1
a3684 1
    #endif
d3722 1
a3722 1
  #ifdef DEBUG
d3742 1
a3742 16
  #endif

  /* Check the form of a 32K lookup table - now in the assembler introduction */
  #if 0
  if (  wp->ColourTTR != 0
     && wp->BPP <= 8                  /* 256 colours or less on output */
     && wp->save_inlog2bpp >= 4       /* thousands or millions of input colours */
     )
  {
    int *t = (int*) wp->ColourTTR;

    tracef("32K lookup table passed in from ColourTrans, %x %x %x\n" _ t[0] _ t[1] _ t[2]);
    assert(t[0] == 0x2e4b3233, ERROR_FATAL); /* "32K." guard word */
    assert(t[2] == 0x2e4b3233, ERROR_FATAL); /* "32K." */
  }
  #endif
d3746 5
a3750 4
    When it enters this code bpc!=bpp can still be the case, but it seems that the actual
    value of bpc is best ignored, it has all been frigged into the scale factors. Avoid
    this issue for now, but note that we must set the values back afterwards because they
    can be reused on the next sprite plot, if the source sprite mode word is the same. */
@


4.9
log
@Clean up pass.
Trim 200+ lines of changes dating back to 1987, combine with non duplicates in the 'BlackLog'.
Use 'offsetof' macro in genjhdr to avoid warnings about uninitialised variables, rename from makejhdr so all the utils are clearly demarked.
Add throwback to MkCFSI-j.
Replace reason codes passed to SWIs with textual equivalents from the respective header files.
Speed up SWI despatch a bit by making the first few debug instructions depend on 'debuggs'.
Qualify all of the debug switches with the global 'debug' one.
Eliminate single use of 'pullx' macro.
Make do_branch() take an unsigned opcode so 50% of the branches don't result in implied cast warnings.
Added an UNUSED() macro to reduce a few of the legitimate warnings (the remainder are either in the original JPEG code or ones that it is worth checking the logic of.
Unixify one last filename.

Version 1.24. Tagged as 'SprExtend-1_24'
@
text
@d114 3
a116 5
#include <stdlib.h> /* to get malloc, free declarations */

extern void *realloc_delta(void *pointer, size_t size);
/* Like realloc, but a change in size rather than an absolute new size:
what the underlying RMA calls can most naturally support. */
d120 1
a120 1
*    Basic low-level definitions.                                         *
d124 1
a124 3
#define BOOL int
#define TRUE 1
#define FALSE 0
a128 22
/* A sprite header, copied from RISC_OSLib */
typedef struct
{
 int next;
 char name[12];
 int width;
 int height;
 int lbit;
 int rbit;
 int image;
 int mask;
 int mode;
}sprite_header;

/**************************************************************************
*                                                                         *
*    Low-level debugging output.                                          *
*                                                                         *
**************************************************************************/

extern void exit_c(int reason, int error); /* Provided by assembler */

a134 1
/* #define assert(x) do_assert(__LINE__, x, #x) */
d152 1
d154 1
d265 3
a267 1
static void newline(void) {tracef("\n");}
d276 1
a276 2
/* Ignore assertions too when not debugging! */
/* #define assert(arg) ((void) 0) */
a277 1
/*static void do_assert(BOOL x, int line) {if (!x) exit(line);} */
d285 1
d288 1
a288 1
*    JPEG code.                                                           *
a297 219
/**************************************************************************
*                                                                         *
*    Assembler Workspace declarations.                                    *
*                                                                         *
**************************************************************************/

/* These correspond to the assembler workspace. Changes to either must
be synchronised. */

/* variables in the assembler source */
#define ASMnbuffers 8
#undef ASMmultibuffer
#define ASMignorettr
#define ASMflagbit

typedef struct /* printer calibration table - definition internal to ColourTrans,
                  colour printer drivers. */
{
  int version;            /* table version number - must be 0 */
  int idealblack;         /* if not 0, need to do colour skewing */
  int idealwhite;         /* if not &FFFFFF00, need to do colour skewing */
  int postprocessSWI;     /* if not 0, need to call ColourTrans */
  int tablecount;         /* number of tables (1 or 3) */
  char redtable[256];     /* if tablecount==1 this is blue and green tables too */
  char greentable[256];   /* translate 24-bit colour values by doing a lookup for each colour */
  char bluetable[256];
} calibration_table;
/* If idealblack==0, idealwhite==&ffffff00, postprocessSWI==0 then we can do the
colour calibration by doing thee lookups. Otherwise, you have to call ColourTrans for
each pixel. */

typedef struct
{
  #define WP_FIRST_FIELD save_outoffset
  int    save_outoffset;  /* #       4       ; reloaded from R12 */
  int    save_inoffset;   /* #       4 */
  int *  save_inptr;      /* #       4 */
  int *  save_outptr;     /* #       4 */
  int    save_ydiv;       /* #       4 */
  int    save_yadd;       /* #       4 */
  int    save_ysize;      /* #       4 */
  int    save_ycount;     /* #       4 */

  /*int    save_block;*/      /* #       0 */
  int    save_inshift;    /* #       4       ; <---!   this data is copied onto the stack */
  int    save_outword;    /* #       4       ;     !   so that R12 can be re-used */
  int    save_outmask;    /* #       4       ;     ! */
  int    save_xsize;      /* #       4       ;     ! */
  int    save_xcount;     /* #       4       ;     ! */
  int    save_ecfptr;     /* #       4       ;   --!   up to here is reloaded using LDMIA */
  int    save_ecflimit;   /* #       4       ;     ! */
  int    save_vcount;     /* #       4       ;     ! */
  int    save_xdiv;       /* #       4       ;     ! */
  int    save_xadd;       /* #       4       ; <---! */

  int    save_masko;      /* #       4 */
  int    save_xcoord;     /* #       4 */
  int    save_ycoord;     /* #       4 */
  int    save_inputxsize; /* #       4 */
  int    save_inputysize; /* #       4 */
  int    save_tempxsize;  /* #       4 */
  int    save_tempysize;  /* #       4 */
  int    save_xftimesyf;  /* #       4 */
  int    save_xmag;       /* #       4 */
  int    save_ymag;       /* #       4 */

                      /* [ Version >= 047 */
  int    save_inflags;    /* #       4      */
                      /* ] */
  int    save_inlog2bpp;  /* #       4 */
  int    save_inlog2bpc;  /* #       4 */
  int    save_inbpp;      /* #       4 */
  int    save_mode;       /* #       4               ; used in PaintChar */
  int    save_spr_type;   /* #       4 */

  int    save_maskinshift; /* #      4 */
  int    save_maskinptr;  /* #       4 */
  int    save_maskinoffset; /* #     4 */

  int    save_calladdr;   /* #       4               ; points to 'l_start' */
  int    save_calladdr2;  /* #       4               ; points to 'l_putword' */

/* UNUSED */  int    macroword;       /* #       4 */

#ifdef ASMmultibuffer
  int    pc_ecflimit0[ASMnbuffers];     /* #       nbuffers :SHL: 2              ; addresses inside macro code */
  int    pc_outoffset0[ASMnbuffers];    /* #       nbuffers :SHL: 2 */
  int    thisslot;         /* #       4 */
  int    calladdr20[ASMnbuffers];       /* #       nbuffers :SHL: 2               */
  int    calladdr0[ASMnbuffers];        /* #       nbuffers :SHL: 2 */
#else
  int    pc_ecflimit;     /* #       4                       ; addresses inside macro code */
  int    pc_outoffset;    /* #       4 */
#endif


  int    inmode;          /* #       4 */
  int    inlog2px;        /* #       4 */
  int    inlog2py;        /* #       4 */
  int    ColourTTR;       /* #       4 */

  int    nextrowdata[3];     /* #       12 */
  int    nextcoldata[3];     /* #       12 */
  int    TOTAL;           /* #       4 */
  int    XTOTAL;          /* #       4 */

  int    vduspritepars[2];   /* #       4+4         ; sprite code, areaCBptr ... */
  int    vduspritename[3];   /* #       12          ; ... name */

  int    changedbox;      /* #       4 */

  int    spritecode;      /* #       4 */

/* Things moved in the assembler source so I can get at them,
without duplicating the whole of the rest of the assembler workspace... */

#ifdef ASMignorettr
  int    trns_palette;    /* #       4 */
#endif
#ifdef ASMflagbit
  int    trns_flags2;      /* #       4      ; Added when merged with 0.62 (GPS)*/
#endif
  int    BPC;             /* #       4 */
  int    BPP;             /* #       4 */

  int    ccompiler_bitblockmove; /* # 4     ; routine for C to call back into assembler. */
  calibration_table * cal_table; /* # 4     ; printer calibration table */

#if 1
  BOOL   is_it_jpeg;      /* #       4 */
  BOOL   ctrans_recent;   /* #       4 */
  int    in_x;            /* #       4       ; initial x coord in input sprite */
  int    in_y;            /* #       4       ; initial y coord in input sprite */
  int    fetchroutine;    /* #       4       ; routine for compiled code to call to get line of JPEG data. */
  sprite_header * save_sprite;     /* #       4       ; the actual source sprite */
  decompress_info_ptr jpeg_info_ptr; /* #       4       ; pointer to JPEG workspace */
  int    area_number;       /* #       4      ; dynamic area number*/
#if 0
  char * jpeg_data;       /* #       4       ; the start of the JPEG data */
  int    jpeg_data_size;  /* #       4       ; length of JPEG data in bytes */
#endif
#endif

  int    bgcolour;            /* #       4       ; background colour, for plotting mask. */
  int    save_PdriverIntercept; /* #  4       ; Flags used to determine if the pdriver is*/
  BOOL   dither_truecolour;    /* #       4       ; do we dither true colour images when reducing BPP? */
  int    newtranstable[256];   /*   #       256 *4                  ; buffer for pixel translation table */
} asm_workspace;

/* Notes about some of these:
macroword - used internally by the old compiler, to record essential characteristics
  of the compiled code. Used to see if existing code is OK.
  Bit 6 (transformed) - never set.
*/

#ifdef DEBUG
static void dump_asm_workspace(asm_workspace *wp)
{
  tracef("Assembler workspace at %x:\n" _ wp);
  tracef("save_inptr=0x%x          %t32. word address of input pixels.\n" _ wp->save_inptr);
  tracef("save_inshift=%i          %t32. bit shift of first pixel.\n" _ wp->save_inshift);
  tracef("save_inoffset=%i         %t32. byte offset between input rows - SUBTRACT for next row.\n" _ wp->save_inoffset);
  tracef("save_inlog2bpp=%i        %t32. log 2 bits per pixel of input.\n" _ wp->save_inlog2bpp);
  tracef("save_inlog2bpc=%i        %t32. log 2 bits per character of input (only different for double-pixels).\n"
                                   _ wp->save_inlog2bpc);
  newline();

  tracef("save_outptr=0x%x         %t32. address of word containing first output pixel.\n" _ wp->save_outptr);
/*  tracef("save_outword=0x%x        %t32. output word mask showing bit before least sig bit of first output pixel.\n" _ wp->save_outword); */
  tracef("save_xcoord=%i           %t32. pixel x coordinate of first output pixel.\n" _ wp->save_xcoord);
  tracef("save_ycoord=%i           %t32. pixel y coordinate of first output pixel.\n" _ wp->save_ycoord);
  tracef("save_outoffset=%i        %t32. byte offset between output rows - SUBTRACT for next row.\n" _ wp->save_outoffset);
  tracef("save_BPP=%i              %t32. bits per pixel of output.\n" _ wp->BPP);
  tracef("save_BPC=%i              %t32. bits per character of output (only different for double pixels).\n" _ wp->BPC);
  newline();

  tracef("save_masko=%i            %t32. if not 1bpp mask then this is mask data offset from inptr. Otherwise...\n" _ wp->save_masko);
  tracef("save_maskinptr=0x%x      %t32. word address of mask (or 0 if there isn't one).\n" _ wp->save_maskinptr);
  tracef("save_maskinshift=%i      %t32. initial bit shift within mask word.\n" _ wp->save_maskinshift);
  tracef("save_maskinoffset=%i     %t32. byte offset between mask rows - SUBTRACT for next row.\n" _ wp->save_maskinoffset);
  newline();

  tracef("save_xmag=%i             %t32. adder value for x scale?\n" _ wp->save_xmag);
/*    used by grey scale, not otherwise */
  tracef("save_xdiv=%i             %t32. subtracter value for x scale.\n" _ wp->save_xdiv);
  tracef("save_xadd=%i             %t32. adder value for x scale\n" _ wp->save_xadd);
  tracef("save_xcount=%i           %t32. total of xmag/xdiv sum, for x scale factor\n" _ wp->save_xcount);
  newline();

/*  tracef("save_ymag=%i             %t32. adder value for y scale?\n" _ wp->save_ymag);
    used by grey scale, not otherwise */
  tracef("save_ydiv=%i             %t32. subtracter value for y scale.\n" _ wp->save_ydiv);
  tracef("save_yadd=%i             %t32. adder value for y scale.\n" _ wp->save_yadd);
  tracef("save_ycount=%i           %t32. total of ymag/ydiv sum, for y scale factor\n" _ wp->save_ycount);
/*  tracef("save_xftimesyf=%i        %t32. (to do with grey scales)?.\n" _ wp->save_xftimesyf); */
  newline();

  tracef("save_xsize=%i            %t32. number of output pixels per row.\n" _ wp->save_xsize);
  tracef("save_ysize=%i            %t32. number of output rows.\n" _ wp->save_ysize);
/*  tracef("save_vcount=%i           %t32. counts from 0 to ysize - not an input\n" _ wp->save_vcount); */
/*  tracef("save_inflags=%i          %t32. (not used in the assembler sources!)\n" _ wp->save_inflags); */
  tracef("ColourTTR=0x%x           %t32. translation table or palette.\n" _ wp->ColourTTR);
  tracef("trns_palette=0x%x        %t32. if non-0 ignore TTR and use this palette instead.\n" _ wp->trns_palette);
  tracef("save_ecfptr=0x%x         %t32. ECF pointer - only useful if plotting the mask.\n" _ wp->save_ecfptr);
  tracef("save_ecflimit=0x%x       %t32. ECF limit - only useful if plotting the mask.\n" _ wp->save_ecflimit);
  tracef("spritecode=%i (& 255 = %i) %t32. SpriteOp - 52 for PutSpriteScaled, 50 for PlotMaskScaled.\n" _ wp->spritecode _ wp->spritecode & 255);
  tracef("save_mode=%i (>> 27 = %i) %t32. mode number/pointer of sprite - 1bpp sprites have hi bits set.\n" _ wp->save_mode _ wp->save_mode >> 27);
  tracef("bgcolour=%i              %t32. Background colour (only valid if plotting the mask)\n" _ wp->bgcolour);
  newline();

}
#endif

/**************************************************************************
*                                                                         *
*    C Workspace declarations.                                            *
*                                                                         *
**************************************************************************/

d639 2
d642 58
d1187 1
a1187 1
static void putscaled_compiler(asm_workspace *wp, workspace *ws, workspace *ws_end /*, decompress_info_ptr cinfo*/)
a3748 2
typedef void (*blitter)(asm_workspace *wp);

d3820 1
a3820 1
static blitter putscaled_compiler(asm_workspace *wp, workspace *ws, workspace *ws_end, int gcol)
@


4.8
log
@A few small fixes.
Sources/PutScaled:
 Sync comment with C code.
Sources/SprExtend:
 Debug switch 'debuggs' had been left on, which left in some unnecessary code, but turning it off pulled in code with a stack imbalance. Now off.
 Ensured a terminator at the end of the RMEnsure.
 Colour translation tables passed to SetPointerShape that were in top bit set addresses were being interpreted as though no tt was supplied. Now tested against zero to match docs.
Sources/SprTrans:
 Switches pre 0.60 collapsed.
Sources/diffuse:
 The C code was corrupting r12 workspace pointer so the check of the flag 'ctrans_recent' sometimes failed leading to a duff table lookup.
 Small optimisation to checking of guard word.
c/PutScaled:
 Change paths to be Unix friendly.
rojpeg:
 Put assembler_panic in the header file to shut the compiler up.
3x unused files deleted.

Version 1.23. Tagged as 'SprExtend-1_23'
@
text
@d17 2
a18 4
/* #define DEBUG */

#define KLUDGE*/  /* Hack to enable TML debugging info */

a21 1
extern int create_dynamic_area(int size);
d166 1
a166 1
#ifdef KLUDGE
d172 1
a172 1
/* Returns < 0 if trace output is being ignored right now. */
d1131 1
a1131 1
static void branch(workspace *ws, int opcode, label *lab, char *description)
d1134 1
a1134 1
static void do_branch(workspace *ws, int opcode, label *lab)
d1181 1
a1181 3
#ifdef DEBUG
#ifdef KLUDGE
#if 1
d1187 1
a1187 1
tracef("Register to be output is... %s\n" _ reg->name);
a1203 1
/*_swi(HostFS_WriteC, _IN(0), c)*/
a1205 2
#endif
#endif
d1336 1
d1502 1
d2187 1
d2748 1
d2786 1
d3183 1
@


4.7
log
@Code generator improvements for ARMv5T and later.
The code generator could output TST instructions with immediate constants not generated in the ARM approved way, while this isn't currently a problem the generator is changed to encode constants less than 256 as an immediate with no shift.
Use of LDR rn, Rd,[Rn] would produce
       LDR Rd,[Rn],#0
which is unpredictable when Rd=Rn. Swapped use of OFFSET0 to OFFSET(0) so
an indexed load is used instead.
Removed the explicit 'S' from TST use, since the TST macro includes 'S' already.
Delete h/swis (held centrally).
Delete h/kernel (held centrally).
Delete hdr/Modes (not used).

Version 1.22. Tagged as 'SprExtend-1_22'
@
text
@d320 1
a320 1
  #include "c.rojpeg"
a3840 10
#if 0
  MOV(R(r_pixel), OP2R(R(r_pixel)),                        "MOV     r_pixel,r_pixel                 ; THIS MAKES IT WORK....");
  /* >>>> 22-Oct-93 WRS - a very mysterious bug with bitblockmove has appeared in the
  last week - it sometimes misses out scan lines, eg. plotting mode 12 in mode 20.
  This problem GOES AWAY when this instruction is inserted, perhaps it separates
  the MOV lr,pc:MOV pc,blocroutine from a LDR on return - is this relevant?
  Don't know, not explored further. */
/* it was the lack of an ALIGN after a string const before the block move routine!!! */
#endif

a4080 3
/*      error = _swix(OS_DynamicArea, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _IN(4) | _IN(5) | _IN(6) | _IN(7) | _IN(8) | _OUT(1) | _OUT(3),
       	      	      	            0, -1 , ws_size, -1, 0, 6*1024*1024, 0, 0, "JPEG Workspace",
      	      	      	            &area_no, &cinfo);*/
a4084 1
/*      cinfo = wp->jpeg_info_ptr;*/
@


4.6
log
@Performance improvement and code tidy-up.

Removed local definition of XOS_CLI and XColourTrans_SelectTable, replaced
with header file.

Delete swiv2_old (moved to _old directory)

Changed to use {TRUE} and {FALSE} built in objasm variables.

Label dividebyzero fall through had code in the way for debug = {TRUE}.

Trimmed some dead code and definitions.

Stopped thrashing OS_CLI every time a JPEG plot is required to check
ColourTrans version, this is now done once at startup and a flag kept
instead.

Author: Rob Sprowson

Version 1.19. Tagged as 'SprExtend-1_19'
@
text
@d1002 2
a1003 8
#define POSTINC(x) (ADDOFFSET | (x))
#define POSTDEC(x) ((x))
/* The manual says, do not set WRITEBACK if doing post-addition:
writeback will always occur, and asserting it will cause SVC mode to
do a funny memory management translation... */

/* If just doing LDR a,[b] you must still do an OFFSET0 */
#define OFFSET0 (ADDOFFSET)
d1419 1
a1419 1
  ins(ws, LDR(8,3) | OFFSET0,                                 "LDR     r8,[r3]");
d2042 1
a2042 1
      ins(ws, LDR(R(r_pixel), R(r_inptr)) | OFFSET0,    "LDR     r_pixel,[r_inptr]");
d2091 1
a2091 1
      ins(ws, LDR(R(r_pixel), R(r_inptr)) | PL | OFFSET0,    "LDRPL         r_pixel,[r_inptr]");
d2150 2
a2151 2
          ws->mask_bpp == 1
            ? IMM(2)
d2354 1
a2354 1
      TST(R(r_pixel), S | IMM(16),                                  "TST     r_pixel,#16                     ; test hi bit of R");
d2404 1
a2404 1
      TST(R(r_pixel), S | IMM(64) | IMMROR(24),                     "TST     r_pixel,#&4000                   ; test top bit of B");
d2406 1
a2406 1
      TST(R(r_pixel), S | IMM(32) | IMMROR(24),                     "TST     r_pixel,#&2000                   ; test next bit of B");
d2410 1
a2410 1
      TST(R(r_pixel), S | IMM(2) | IMMROR(24),                      "TST     r_pixel,#&200                    ; test top bit of G");
d2412 1
a2412 1
      TST(R(r_pixel), S | IMM(1) | IMMROR(24),                      "TST     r_pixel,#&100                    ; test next bit of G");
d2416 1
a2416 1
      TST(R(r_pixel), S | IMM(16),                                  "TST     r_pixel,#&10                     ; test top bit of R");
d2418 1
a2418 1
      TST(R(r_pixel), S | IMM(8),                                   "TST     r_pixel,#&08                     ; test next bit of R");
d2439 1
a2439 1
    ins(ws, PUSH | 7,                                               "STMDB   sp!,{r1,r2,r3}                   ; prepare to call SWI");
d2444 1
a2444 1
    ins(ws, POP | 7,                                                "LDMIA   sp!,{r1,r2,r3}                   ; restore after calling SWI");
d2480 1
a2480 1
      ins(ws, LDR(R(r_pixel), R(r_outptr)) | OFFSET0,                "LDR     r_pixel,[r_outptr] ;bkah");
d2483 1
a2483 1
      ins(ws, STR(R(r_pixel), R(r_outptr)) | OFFSET0,                "STR     r_pixel,[r_outptr]                    ;blaq5h");
d2514 1
a2514 1
        ins(ws, LDR(R(r_temp1), R(r_outptr)) | OFFSET0,               "LDR     r_temp1,[r_outptr]");
d2525 1
a2525 1
      ins(ws, STR(R(r_temp1), R(r_outptr)) | OFFSET0,                 "STR     r_temp1,[r_outptr]");
d2531 1
a2531 1
        ins(ws, STR(R(r_pixel), R(r_outptr)) | OFFSET0,                 "STR     r_pixel,[r_outptr]");
d2777 1
a2777 1
    ins(ws, LDR(R(r_outword), R(r_outptr)) | OFFSET0,             "4~~LDR     r_outword,[r_outptr]");
d2829 1
a2829 1
      ins(ws, LDR(R(r_outword), R(r_outptr)) | EQ | OFFSET0, "LDREQ   r_outword,[r_outptr]        4");
d2868 1
a2868 1
      ins(ws, LDR(R(r_outword), R(r_outptr)) | OFFSET0,      "LDR     r_outword,[r_outptr]            ; load dest data (in case of mask)");
d2879 1
a2879 1
      ins(ws, LDR(R(r_outword), R(r_outptr)) | EQ | OFFSET0, "LDREQ   r_outword,[r_outptr]            ; get dest data (in case of mask)");
d3008 1
a3008 1
    ins(ws, LDR(R(r_outword), R(r_outptr)) | OFFSET0,             "0LDR     r_outword,[r_outptr]");
d3119 1
a3119 1
      ins(ws, LDR(R(r_inword), R(r_inptr)) + OFFSET0,           "LDR     r_inword,[r_inptr]              ; fetch first input pixels");
d3131 1
a3131 1
      ins(ws, LDR(R(r_maskinword), R(r_maskinptr)) + OFFSET0, "LDR     r_maskinword,[r_maskinptr]        ; fetch first mask word");
d3150 1
a3150 1
      ins(ws, NE | LDR(R(r_outword), R(r_outptr)) + OFFSET0,  "LDRNE   r_outword,[r_outptr]            ; load up output word");
d3158 1
a3158 1
      ins(ws, LDR(R(r_outword), R(r_outptr)) + OFFSET0,       "LDR     r_outword,[r_outptr]            ; load up output word");
d3560 1
a3560 1
        ins(ws, LDR(R(r_pixel), R(r_outptr)) | OFFSET0,          "LDR     r_pixel,[r_outptr]              ; temporary use of r_pixel");
d3565 1
a3565 1
        ins(ws, STR(R(r_outword), R(r_outptr)) | OFFSET0,        "STR     r_outword,[r_outptr]            ; store updated word");
d3570 1
a3570 1
        ins(ws, STR(R(r_outword), R(r_outptr)) | OFFSET0,        "STR     r_outword,[r_outptr]");
@


4.5
log
@Change to file vetting (only affects SpriteExtend module).
First pass check now only looks for a SOI tag,not bothering looking
for the "JFIF" text: this lets both JFIF and EXIF files through the
first gate.
Next,improvements to the find_image_dimensions routine to properly
look for tags rather than assuming tag APP0 is always at the start of
the file as it is in ".jpg" files.Again - EXIF files are now understood
as a side effect,plus a nice speed up for when skipping unknown tags.So
rather than loading lots of unused 1k blocks it just sets the file
pointer forwards to the required point.
Tested with a handful of specially contrived EXIF files plus some frommy
Panasonic camera,plus retested the JPEGs in the ChangeFSI test directory
to check that progressive JPEGs are still correctly faulted.
Yay - !Paint and !Draw can now load digital camera piccies!

Version 1.15. Tagged as 'SprExtend-1_15'
@
text
@a430 1
  int    maskorimage;     /* #       4 */
d455 1
a467 1
  int    oldReadModeVariable; /* #      4 */
a549 1
/*#define BUFSIZE 200 */     /* words per buffer */
@


4.4
log
@A couple of 32-bit fixes.
Used to interpret negative translation table pointers as "none"; now just 0
as per documentation.
Plotting 16bpp sprites into 32bpp modes now correctly sets the 3 least
significant bits of each channel - used to be set to 0 due to a typo.
Build option (currently set to on) to use SMULL instructions.

Version 1.11. Tagged as 'SprExtend-1_11'
@
text
@d27 2
a28 7
passed through AAs. Do not use high-level functions, or static variables.
Repeated references to a string constant also seem to lead to non-AAsm
source (a DCD label+constant) - if this happens you must change the
source so that the offending string literal is not repeated. There's also
something about one-character strings that actually generates bum assembler
from cc 4.13, references to non-existent labels that even ObjAsm would choke
at. */
d31 1
a31 1
internet ECF pattern for the foreground and background colours. This is because when
a165 2
/* Description string removed because there are too many duplicate strings, so we hit
the AAsm problem. Have to make do with line number. */
d1010 1
a1011 3
/* If just doing LDR a,[b] you must still do an OFFSET0. This is only
different to OFFSET(0) in one arbitrary bit, but it sets it the way that
AAsm does to make the resulting binaries the same. */
@


4.3
log
@32-bit compatible. Tagged as SprExtend-1_06
@
text
@d2311 1
a2311 1
    AND(R(r_temp1), R(r_temp1), OP2R(R(r_c1632)),        "AND     r_temp1,r_temp1,r_c1632           ; r_temp1 = 00000000bbb00000 ggg00000rrr00000");
d4112 1
a4112 1
      tracef("JPEG Dynamic area no %d is %x bytes big\n" _ area_no);
@


4.2
log
@Version RO_3_70 taken
@
text
@a1037 2
#define POPFLAGS (1<<22)
/* Include this as well when popping the PC for a return. */
d1433 1
a1433 1
  MOV(R(pc)), S | OP2R(R(lr)),                        "MOVS    pc,lr");
d1447 1
a1447 1
  ins(ws, POP | (1<<4) | (1<<5) | (1<<6) | (1<<R(pc)) | POPFLAGS,"LDMIA   sp!,{r4,r5,r6,pc}^");
@


4.1
log
@Initial revision
@
text
@d17 1
a17 1
/*#define DEBUG
d179 1
a179 1
#define asm_writech(c) _swi(HostFS_WriteC, _IN(0), c)
d1308 20
d2270 1
a2270 1
  if (pixl2bpp == 5 && wp->BPP != 32) /* all we can do is truncate to 4, as a first stage. */
d2341 1
d2356 6
d3700 1
d3992 1
d4030 3
d4040 1
a4040 1
  IFDEBUG(BOOL tracing = asm_writech('\n') >= 0;)
d4210 1
a4210 1
      if (wp->BPP <= 4)
d4216 5
d4235 6
a4240 2
          if (wp->dither_truecolour & 2) opt |= jopt_OUTBPP_8;    /*full error diffusion*/
          else opt |= jopt_OUTBPP_8YUV;                           /*strange diffusion from YUV data*/
d4244 18
d4265 2
a4266 1
        if (wp->BPP == 8)
d4277 1
a4277 1
                                         -1, -1, &(wp->newtranstable[0]), 256*4, 0); /*save palette into newtranstable area */
d4281 1
a4281 1
          for(loop = 0;loop<256;loop++)
d4284 22
a4305 1
          if (wp->dither_truecolour & 2)
d4307 1
a4307 1
            opt |= jopt_OUTBPP_8;    /*full error diffusion*/
d4314 1
a4314 1
              opt |= jopt_OUTBPP_8YUV;                           /*strange diffusion from YUV data*/
d4321 11
a4334 1
      /* >>>> Should return a kosher error to the user at this point, eg. out of space or unacceptable JPEG data. */
d4349 1
a4349 1
      if (cinfo->error_argument1 & (jopt_OUTBPP_8 | jopt_OUTBPP_8YUV)) /* we asked for it, and we got it - 8bpp output pixels */
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d17 1
a17 1
/* #define DEBUG */
d179 1
a179 1
#define asm_writech(c) _swix(HostFS_WriteC, _IN(0), c)
a1307 20
static int palette_is_grey(int *palette, int entries)
{
  int loop;
  int entry;
  int ascending = 1;

  for (loop=0;loop<entries;loop++)
  {
    entry = palette[loop];

    if (((entry ^ (entry>>8)) & 0xffff00) != 0)
      return 0;
    if ((entry & 0xff00)>>8 != loop)
      ascending = 0;
  }
  if (ascending)
   return 2;
  return 1;
}

d2250 1
a2250 1
  if (pixl2bpp == 5 && wp->BPP != 32 && !(wp->is_it_jpeg && (wp->dither_truecolour & 2) && (wp->BPP != 16))) /* all we can do is truncate to 4, as a first stage. */
a2320 1
    comment(ws, "We have a translation table.");
a2334 6
  else if (wp->is_it_jpeg && (wp->dither_truecolour & 2))
  {
    /* bottom n bits of word contains colour number we want... */
    pixl2bpp = ws->out_l2bpp;              /* we've finished */
    comment(ws, "JPEG error diffusion should have done all the work!");
  }
a3672 1
     && !(wp->is_it_jpeg && (wp->dither_truecolour & 2))
a3963 1
  if (wp->is_it_jpeg && (wp->dither_truecolour & 2)) key_word |= 1<<22;
a4000 3
  /** SWI here to synchronise the code areas on ARM810/StrongARM **/
  _swix(OS_SynchroniseCodeAreas, _IN(0) | _IN(1) | _IN(2),
              1,(int)ws->compile_base,(int)ws->compile_base+(4*BUFSIZE)-4 );
d4008 1
a4008 1
  IFDEBUG(BOOL tracing = (int)asm_writech('\n') >= 0;)
d4178 1
a4178 1
      if (wp->BPP < 4)
a4183 5
      if ((wp->BPP <=8) && (wp->dither_truecolour & 2))
      {
        opt |= jopt_DIFFUSE;
        wp->ColourTTR = 0;
      }
d4198 2
a4199 6
        {
          if (wp->dither_truecolour & 2)
            opt |= jopt_OUTBPP_8;                              /*full error diffusion*/
          else
            opt |= jopt_OUTBPP_8YUV;                           /*strange diffusion from YUV data*/
        }
a4202 18
      if (wp->BPP == 8)
      {
        int temp;
        int size;

        _swix(ColourTrans_ReadPalette, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _IN(4) | _OUT(3),
                                       -1, -1, 0, 256*4, 0, &size); /*save palette into newtranstable area */
        tracef("need %x bytes for palette\n" _ size);
        _swix(ColourTrans_ReadPalette, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _IN(4),
                                       -1, -1, &(wp->newtranstable[0]), size, 0); /*save palette into newtranstable area */
        temp = palette_is_grey(wp->newtranstable, size/4);
     	if (temp) opt |= jopt_GREY;
	if (temp == 2)
	{
	  opt |= jopt_OUTBPP_8GREY;
	  opt &= ~jopt_DIFFUSE;
        }
      }
d4206 1
a4206 2

        if ((wp->dither_truecolour & 2) && wp->BPP < 16)
d4217 1
a4217 1
                                         -1, -1, &(wp->newtranstable[0]), size, 0); /*save palette into newtranstable area */
d4221 1
a4221 1
          for(loop = 0;loop<size/4;loop++)
d4224 1
a4224 5
          if (wp->BPP == 4)
          {
            if (palette_is_grey(wp->newtranstable, size/4)) opt |= jopt_GREY;
          }
          else if (wp->BPP == 8)
d4226 1
a4226 18
            int temp = palette_is_grey(wp->newtranstable, size/4);

	    if (temp) opt |= jopt_GREY;
	    if (temp == 2)
	    {
	       opt |= jopt_OUTBPP_8GREY;
	       opt &= ~jopt_DIFFUSE;
            }
	  }
        }

        if ((wp->BPP == 4) && !(wp->dither_truecolour & 2)) opt |= jopt_GREY;

        if (wp->BPP == 8)
        {
          if ((wp->dither_truecolour & 2) && !(opt & jopt_OUTBPP_8GREY))
          {
            opt |= jopt_OUTBPP_8;                        /* full error diffusion */
d4233 1
a4233 1
              opt |= jopt_OUTBPP_8YUV;                   /* strange diffusion from YUV data */
a4239 11
#ifdef DEBUG
  tracef("After set up, options are:\n");
  if (opt & jopt_GREY) tracef("   jopt_GREY\n");
  if (opt & jopt_DC_ONLY) tracef("   jopt_DC_ONLY\n");
  if (opt & jopt_INTERP_X) tracef("   jopt_INTERP_X\n");
  if (opt & jopt_OUTBPP_8) tracef("   jopt_OUTBPP_8\n");
  if (opt & jopt_OUTBPP_16) tracef("   jopt_OUTBPP_16\n");
  if (opt & jopt_OUTBPP_8YUV) tracef("   jopt_OUTBPP_8YUV\n");
  if (opt & jopt_DIFFUSE) tracef("   jopt_DIFFUSE\n");
  if (opt & jopt_OUTBPP_8GREY) tracef("   jopt_OUTBPP_8GREY\n");
#endif
d4243 1
d4258 1
a4258 1
      if (cinfo->error_argument1 & (jopt_OUTBPP_8 | jopt_OUTBPP_8YUV | jopt_OUTBPP_8GREY)) /* we asked for it, and we got it - 8bpp output pixels */
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.8;
access;
symbols
	SprExtend-1_83:4.8
	SprExtend-1_82:4.8
	SprExtend-1_81:4.8
	SprExtend-1_80:4.8
	SprExtend-1_79:4.8
	SprExtend-1_78:4.8
	SprExtend-1_77:4.8
	SprExtend-1_76:4.8
	SprExtend-1_75:4.7
	SprExtend-1_74:4.7
	SprExtend-1_73:4.6
	SprExtend-1_72:4.6
	SprExtend-1_71-nocfsi:4.6
	SprExtend-1_71:4.6
	SprExtend-1_70-tracef:4.5
	SprExtend-1_70-headers:4.4
	SprExtend-1_70:4.3
	SprExtend-1_69:4.3
	SprExtend-1_68:4.3
	SprExtend-1_67:4.3
	SprExtend-1_66:4.3
	SprExtend-1_65:4.3
	SprExtend-1_64:4.3
	SprExtend-1_63:4.3
	SprExtend-1_62:4.3
	SprExtend-1_61:4.3
	SprExtend-1_60:4.3
	SprExtend-1_59:4.3
	SprExtend-1_58:4.3
	SprExtend-1_57:4.3
	SprExtend-1_56:4.3
	SprExtend-1_55:4.3
	SprExtend-1_54:4.3
	SprExtend-1_53:4.3
	SprExtend-1_52:4.3
	SprExtend-1_51:4.3
	SprExtend-1_50:4.3
	SprExtend-1_38-1_35_2_16:4.3.2.10
	SprExtend-1_49:4.3
	SprExtend-1_48:4.3
	SprExtend-1_47:4.3
	SprExtend-1_38-1_35_2_15:4.3.2.10
	SprExtend-1_46:4.3
	SprExtend-1_45:4.3
	SprExtend-1_44:4.3
	SprExtend-1_43:4.3
	SprExtend-1_42:4.3
	SprExtend-1_41:4.3
	SprExtend-1_38-1_35_2_14:4.3.2.9
	SprExtend-1_40:4.3
	SprExtend-1_38-1_35_2_13:4.3.2.8
	SprExtend-1_38-1_35_2_12:4.3.2.7
	SprExtend-1_38-1_35_2_11:4.3.2.6
	SprExtend-1_38-1_35_2_10:4.3.2.6
	SprExtend-1_38-1_35_2_9:4.3.2.5
	SprExtend-1_38-1_35_2_8:4.3.2.4
	SprExtend-1_39:4.3
	SprExtend-1_38-1_35_2_7:4.3.2.3
	SprExtend-1_38-1_35_2_6:4.3.2.3
	SprExtend-1_38-1_35_2_5:4.3.2.2
	SprExtend-1_38-1_35_2_4:4.3.2.2
	SprExtend-1_38-1_35_2_3:4.3.2.2
	SprExtend-1_38-1_35_2_2:4.3.2.1
	SprExtend-1_38-1_35_2_1:4.3.2.1
	MigrateIJG8b:4.3.0.2
	SprExtend-1_38:4.3
	SprExtend-1_37:4.3
	SprExtend-1_36:4.3
	SprExtend-1_35:4.3
	SprExtend-1_34:4.3
	SprExtend-1_33:4.3
	SprExtend-1_32:4.3
	SprExtend-1_31:4.3
	SprExtend-1_30:4.3
	SprExtend-1_29:4.3
	SprExtend-1_28:4.3
	SprExtend-1_27:4.2
	SprExtend-1_26:4.2
	SprExtend-1_25:4.2
	SprExtend-1_24:4.2
	SprExtend-1_23:4.2
	SprExtend-1_22:4.2
	SprExtend-1_21:4.2
	SprExtend-1_20:4.2
	SprExtend-1_19:4.2
	SprExtend-1_18:4.2
	SprExtend-1_17:4.2
	RO_5_07:4.2
	SprExtend-1_16:4.2
	SprExtend-1_15:4.2
	SprExtend-1_14:4.2
	SprExtend-1_13:4.2
	SprExtend-1_12:4.2
	SprExtend-1_11:4.2
	SprExtend-1_10:4.1
	SprExtend-1_09:4.1
	SprExtend-1_08:4.1
	dellis_autobuild_BaseSW:4.1
	SprExtend-1_07:4.1
	SprExtend-1_06:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	SprExtend-1_05:4.1
	Ursula_merge:4.1
	nturton_SprExtend-1_04:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2016.05.21.14.16.32;	author rool;	state Exp;
branches;
next	4.7;
commitid	xdjBCBYna4x7am7z;

4.7
date	2016.05.21.14.10.17;	author rool;	state Exp;
branches;
next	4.6;
commitid	RAjaHu2jGaPW7m7z;

4.6
date	2016.05.21.13.44.38;	author rool;	state Exp;
branches;
next	4.5;
commitid	ZDqmsyNiMhv6Zl7z;

4.5
date	2016.05.21.13.37.18;	author rool;	state Exp;
branches;
next	4.4;
commitid	TvdqzFBJfCe7Wl7z;

4.4
date	2016.05.21.13.32.20;	author rool;	state Exp;
branches;
next	4.3;
commitid	yTqS85yKh7k8Ul7z;

4.3
date	2010.09.25.12.19.23;	author rsprowson;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	2002.11.06.13.20.30;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.45.02;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	2011.01.04.21.18.07;	author rsprowson;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	2011.01.04.21.37.00;	author rsprowson;	state Exp;
branches;
next	4.3.2.3;

4.3.2.3
date	2011.01.09.10.42.59;	author rsprowson;	state Exp;
branches;
next	4.3.2.4;

4.3.2.4
date	2011.01.13.21.12.20;	author rsprowson;	state Exp;
branches;
next	4.3.2.5;

4.3.2.5
date	2011.01.22.17.58.30;	author rsprowson;	state Exp;
branches;
next	4.3.2.6;

4.3.2.6
date	2011.01.22.18.01.49;	author rsprowson;	state Exp;
branches;
next	4.3.2.7;

4.3.2.7
date	2011.01.29.10.05.55;	author rsprowson;	state Exp;
branches;
next	4.3.2.8;

4.3.2.8
date	2011.02.05.09.56.53;	author rsprowson;	state Exp;
branches;
next	4.3.2.9;

4.3.2.9
date	2011.02.15.20.58.02;	author rsprowson;	state Exp;
branches;
next	4.3.2.10;

4.3.2.10
date	2011.08.06.10.44.32;	author rsprowson;	state Exp;
branches;
next	;
commitid	gAycmEnWp5AVeruv;

4.1.1.1
date	96.11.05.09.45.02;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.40.52;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.57.28;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.20.08;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Lazy MCU decoding
Detail:
  Only colour convert from the left clipping border (rounded down) to the right (rounding up).
  Only entropy decode the DC component for blocks likewise, skipping AC and IDCT steps.
Admin:
  Submission for the JPEG bounty.

Version 1.76. Tagged as 'SprExtend-1_76'
@
text
@/*
 * jdhuff.c
 *
 * Copyright (C) 1991-1997, Thomas G. Lane.
 * Modified 2006-2009 by Guido Vollbeding.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains Huffman entropy decoding routines.
 * Both sequential and progressive modes are supported in this single module.
 *
 * Much of the complexity here has to do with supporting input suspension.
 * If the data source module demands suspension, we want to be able to back
 * up to the start of the current MCU.  To do this, we copy state variables
 * into local working storage, and update them back to the permanent
 * storage only upon successful completion of an MCU.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* Derived data constructed for each Huffman table */

#define HUFF_LOOKAHEAD	8	/* # of bits of lookahead */

typedef struct {
  /* Basic tables: (element [0] of each array is unused) */
  INT32 maxcode[18];		/* largest code of length k (-1 if none) */
  /* (maxcode[17] is a sentinel to ensure jpeg_huff_decode terminates) */
  INT32 valoffset[17];		/* huffval[] offset for codes of length k */
  /* valoffset[k] = huffval[] index of 1st symbol of code length k, less
   * the smallest code of length k; so given a code of length k, the
   * corresponding symbol is huffval[code + valoffset[k]]
   */

  /* Link to public Huffman table (needed only in jpeg_huff_decode) */
  JHUFF_TBL *pub;

  /* Lookahead tables: indexed by the next HUFF_LOOKAHEAD bits of
   * the input data stream.  If the next Huffman code is no more
   * than HUFF_LOOKAHEAD bits long, we can obtain its length and
   * the corresponding symbol directly from these tables.
   */
  int look_nbits[1<<HUFF_LOOKAHEAD]; /* # bits, or 0 if too long */
  UINT8 look_sym[1<<HUFF_LOOKAHEAD]; /* symbol, or unused */
} d_derived_tbl;


/*
 * Fetching the next N bits from the input stream is a time-critical operation
 * for the Huffman decoders.  We implement it with a combination of inline
 * macros and out-of-line subroutines.  Note that N (the number of bits
 * demanded at one time) never exceeds 15 for JPEG use.
 *
 * We read source bytes into get_buffer and dole out bits as needed.
 * If get_buffer already contains enough bits, they are fetched in-line
 * by the macros CHECK_BIT_BUFFER and GET_BITS.  When there aren't enough
 * bits, jpeg_fill_bit_buffer is called; it will attempt to fill get_buffer
 * as full as possible (not just to the number of bits needed; this
 * prefetching reduces the overhead cost of calling jpeg_fill_bit_buffer).
 * Note that jpeg_fill_bit_buffer may return FALSE to indicate suspension.
 * On TRUE return, jpeg_fill_bit_buffer guarantees that get_buffer contains
 * at least the requested number of bits --- dummy zeroes are inserted if
 * necessary.
 */

typedef INT32 bit_buf_type;	/* type of bit-extraction buffer */
#define BIT_BUF_SIZE  32	/* size of buffer in bits */

/* If long is > 32 bits on your machine, and shifting/masking longs is
 * reasonably fast, making bit_buf_type be long and setting BIT_BUF_SIZE
 * appropriately should be a win.  Unfortunately we can't define the size
 * with something like  #define BIT_BUF_SIZE (sizeof(bit_buf_type)*8)
 * because not all machines measure sizeof in 8-bit bytes.
 */

typedef struct {		/* Bitreading state saved across MCUs */
  bit_buf_type get_buffer;	/* current bit-extraction buffer */
  int bits_left;		/* # of unused bits in it */
} bitread_perm_state;

typedef struct {		/* Bitreading working state within an MCU */
  /* Current data source location */
  /* We need a copy, rather than munging the original, in case of suspension */
  const JOCTET * next_input_byte; /* => next byte to read from source */
  size_t bytes_in_buffer;	/* # of bytes remaining in source buffer */
  /* Bit input buffer --- note these values are kept in register variables,
   * not in this struct, inside the inner loops.
   */
  bit_buf_type get_buffer;	/* current bit-extraction buffer */
  int bits_left;		/* # of unused bits in it */
  /* Pointer needed by jpeg_fill_bit_buffer. */
  j_decompress_ptr cinfo;	/* back link to decompress master record */
} bitread_working_state;

/* Macros to declare and load/save bitread local variables. */
#define BITREAD_STATE_VARS  \
	register bit_buf_type get_buffer;  \
	register int bits_left;  \
	bitread_working_state br_state

#define BITREAD_LOAD_STATE(cinfop,permstate)  \
	br_state.cinfo = cinfop; \
	br_state.next_input_byte = cinfop->src->next_input_byte; \
	br_state.bytes_in_buffer = cinfop->src->bytes_in_buffer; \
	get_buffer = permstate.get_buffer; \
	bits_left = permstate.bits_left;

#define BITREAD_SAVE_STATE(cinfop,permstate)  \
	cinfop->src->next_input_byte = br_state.next_input_byte; \
	cinfop->src->bytes_in_buffer = br_state.bytes_in_buffer; \
	permstate.get_buffer = get_buffer; \
	permstate.bits_left = bits_left

/*
 * These macros provide the in-line portion of bit fetching.
 * Use CHECK_BIT_BUFFER to ensure there are N bits in get_buffer
 * before using GET_BITS, PEEK_BITS, or DROP_BITS.
 * The variables get_buffer and bits_left are assumed to be locals,
 * but the state struct might not be (jpeg_huff_decode needs this).
 *	CHECK_BIT_BUFFER(state,n,action);
 *		Ensure there are N bits in get_buffer; if suspend, take action.
 *      val = GET_BITS(n);
 *		Fetch next N bits.
 *      val = PEEK_BITS(n);
 *		Fetch next N bits without removing them from the buffer.
 *	DROP_BITS(n);
 *		Discard next N bits.
 * The value N should be a simple variable, not an expression, because it
 * is evaluated multiple times.
 */

#define CHECK_BIT_BUFFER(state,nbits,action) \
	{ if (bits_left < (nbits)) {  \
	    if (! jpeg_fill_bit_buffer(&(state),get_buffer,bits_left,nbits))  \
	      { action; }  \
	    get_buffer = (state).get_buffer; bits_left = (state).bits_left; } }

#define GET_BITS(nbits) \
	(((int) (get_buffer >> (bits_left -= (nbits)))) & BIT_MASK(nbits))

#define PEEK_BITS(nbits) \
	(((int) (get_buffer >> (bits_left -  (nbits)))) & BIT_MASK(nbits))

#define DROP_BITS(nbits) \
	(bits_left -= (nbits))


/*
 * Code for extracting next Huffman-coded symbol from input bit stream.
 * Again, this is time-critical and we make the main paths be macros.
 *
 * We use a lookahead table to process codes of up to HUFF_LOOKAHEAD bits
 * without looping.  Usually, more than 95% of the Huffman codes will be 8
 * or fewer bits long.  The few overlength codes are handled with a loop,
 * which need not be inline code.
 *
 * Notes about the HUFF_DECODE macro:
 * 1. Near the end of the data segment, we may fail to get enough bits
 *    for a lookahead.  In that case, we do it the hard way.
 * 2. If the lookahead table contains no entry, the next code must be
 *    more than HUFF_LOOKAHEAD bits long.
 * 3. jpeg_huff_decode returns -1 if forced to suspend.
 */

#define HUFF_DECODE(result,state,htbl,failaction,slowlabel) \
{ register int nb, look; \
  if (bits_left < HUFF_LOOKAHEAD) { \
    if (! jpeg_fill_bit_buffer(&state,get_buffer,bits_left, 0)) {failaction;} \
    get_buffer = state.get_buffer; bits_left = state.bits_left; \
    if (bits_left < HUFF_LOOKAHEAD) { \
      nb = 1; goto slowlabel; \
    } \
  } \
  look = PEEK_BITS(HUFF_LOOKAHEAD); \
  if ((nb = htbl->look_nbits[look]) != 0) { \
    DROP_BITS(nb); \
    result = htbl->look_sym[look]; \
  } else { \
    nb = HUFF_LOOKAHEAD+1; \
slowlabel: \
    if ((result=jpeg_huff_decode(&state,get_buffer,bits_left,htbl,nb)) < 0) \
	{ failaction; } \
    get_buffer = state.get_buffer; bits_left = state.bits_left; \
  } \
}


/*
 * Expanded entropy decoder object for Huffman decoding.
 *
 * The savable_state subrecord contains fields that change within an MCU,
 * but must not be updated permanently until we complete the MCU.
 */

typedef struct {
  unsigned int EOBRUN;			/* remaining EOBs in EOBRUN */
  int last_dc_val[MAX_COMPS_IN_SCAN];	/* last DC coef for each component */
} savable_state;

/* This macro is to work around compilers with missing or broken
 * structure assignment.  You'll need to fix this code if you have
 * such a compiler and you change MAX_COMPS_IN_SCAN.
 */

#ifndef NO_STRUCT_ASSIGN
#define ASSIGN_STATE(dest,src)  ((dest) = (src))
#else
#if MAX_COMPS_IN_SCAN == 4
#define ASSIGN_STATE(dest,src)  \
	((dest).EOBRUN = (src).EOBRUN, \
	 (dest).last_dc_val[0] = (src).last_dc_val[0], \
	 (dest).last_dc_val[1] = (src).last_dc_val[1], \
	 (dest).last_dc_val[2] = (src).last_dc_val[2], \
	 (dest).last_dc_val[3] = (src).last_dc_val[3])
#endif
#endif


typedef struct {
  struct jpeg_entropy_decoder pub; /* public fields */

  /* These fields are loaded into local variables at start of each MCU.
   * In case of suspension, we exit WITHOUT updating them.
   */
  bitread_perm_state bitstate;	/* Bit buffer at start of MCU */
  savable_state saved;		/* Other state at start of MCU */

  /* These fields are NOT loaded into local working state. */
  boolean insufficient_data;	/* set TRUE after emitting warning */
  unsigned int restarts_to_go;	/* MCUs left in this restart interval */

  /* Following two fields used only in progressive mode */

  /* Pointers to derived tables (these workspaces have image lifespan) */
  d_derived_tbl * derived_tbls[NUM_HUFF_TBLS];

  d_derived_tbl * ac_derived_tbl; /* active table during an AC scan */

  /* Following fields used only in sequential mode */

  /* Pointers to derived tables (these workspaces have image lifespan) */
  d_derived_tbl * dc_derived_tbls[NUM_HUFF_TBLS];
  d_derived_tbl * ac_derived_tbls[NUM_HUFF_TBLS];

  /* Precalculated info set up by start_pass for use in decode_mcu: */

  /* Pointers to derived tables to be used for each block within an MCU */
  d_derived_tbl * dc_cur_tbls[D_MAX_BLOCKS_IN_MCU];
  d_derived_tbl * ac_cur_tbls[D_MAX_BLOCKS_IN_MCU];
  /* Whether we care about the DC and AC coefficient values for each block */
  int coef_limit[D_MAX_BLOCKS_IN_MCU];
} huff_entropy_decoder;

typedef huff_entropy_decoder * huff_entropy_ptr;


#ifndef RISCOS /* Avoid const relocation, use code */
static const int jpeg_zigzag_order[8][8] = {
  {  0,  1,  5,  6, 14, 15, 27, 28 },
  {  2,  4,  7, 13, 16, 26, 29, 42 },
  {  3,  8, 12, 17, 25, 30, 41, 43 },
  {  9, 11, 18, 24, 31, 40, 44, 53 },
  { 10, 19, 23, 32, 39, 45, 52, 54 },
  { 20, 22, 33, 38, 46, 51, 55, 60 },
  { 21, 34, 37, 47, 50, 56, 59, 61 },
  { 35, 36, 48, 49, 57, 58, 62, 63 }
};

static const int jpeg_zigzag_order7[7][7] = {
  {  0,  1,  5,  6, 14, 15, 27 },
  {  2,  4,  7, 13, 16, 26, 28 },
  {  3,  8, 12, 17, 25, 29, 38 },
  {  9, 11, 18, 24, 30, 37, 39 },
  { 10, 19, 23, 31, 36, 40, 45 },
  { 20, 22, 32, 35, 41, 44, 46 },
  { 21, 33, 34, 42, 43, 47, 48 }
};

static const int jpeg_zigzag_order6[6][6] = {
  {  0,  1,  5,  6, 14, 15 },
  {  2,  4,  7, 13, 16, 25 },
  {  3,  8, 12, 17, 24, 26 },
  {  9, 11, 18, 23, 27, 32 },
  { 10, 19, 22, 28, 31, 33 },
  { 20, 21, 29, 30, 34, 35 }
};

static const int jpeg_zigzag_order5[5][5] = {
  {  0,  1,  5,  6, 14 },
  {  2,  4,  7, 13, 15 },
  {  3,  8, 12, 16, 21 },
  {  9, 11, 17, 20, 22 },
  { 10, 18, 19, 23, 24 }
};

static const int jpeg_zigzag_order4[4][4] = {
  { 0,  1,  5,  6 },
  { 2,  4,  7, 12 },
  { 3,  8, 11, 13 },
  { 9, 10, 14, 15 }
};

static const int jpeg_zigzag_order3[3][3] = {
  { 0, 1, 5 },
  { 2, 4, 6 },
  { 3, 7, 8 }
};

static const int jpeg_zigzag_order2[2][2] = {
  { 0, 1 },
  { 2, 3 }
};
#else
LOCAL(int) 
get_zigzag_pos (int x, int y, int size)
{
  int d, m, p, dist, index;

  /* Calculate the zigzag value for an arbitrary NxN square.
   * See Test/ZigZag for proof, Norcroft reduces this to 12 instructions!
   */
  d = x + y;
  p = (d & 1) ? y : x;
  dist = (d * (d + 1)) >> 1;
  index = dist + p;
  if (d >= size) {
    m = d - size;
    index = index - ((m + 1) * (m + 1));
  }

  return index;
}

GLOBAL(void)
huff_pointer_save(j_decompress_ptr cinfo, huff_pointer *h)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;

  assert(entropy->bitstate.bits_left < BIT_BUF_SIZE, ERROR_BAD_JPEG);
  assert(entropy->bitstate.bits_left >= 0, ERROR_BAD_JPEG);
  assert(cinfo->jpeg_buffer < cinfo->src->next_input_byte, ERROR_BAD_JPEG);
  assert(cinfo->src->next_input_byte < &cinfo->jpeg_buffer[cinfo->jpeg_buffer_size], ERROR_BAD_JPEG);
  assert(MAX_COMPS_IN_SCAN == 4, ERROR_FATAL);

  /* Save the state of the huffman stream, for later random access */
  h->get_buffer = entropy->bitstate.get_buffer;
  h->restarts_to_go = (short)entropy->restarts_to_go;
  h->bits_left = (unsigned char)entropy->bitstate.bits_left;
  h->next_restart_num = (unsigned char)cinfo->marker->next_restart_num;
  h->unread_marker = cinfo->unread_marker;
  h->next_input_byte = cinfo->src->next_input_byte; /* Can derive bytes_in_buffer from that */
  h->last_dc_val[0] = entropy->saved.last_dc_val[0];
  h->last_dc_val[1] = entropy->saved.last_dc_val[1];
  h->last_dc_val[2] = entropy->saved.last_dc_val[2];
  h->last_dc_val[3] = entropy->saved.last_dc_val[3]; /* EOBRUN unused for baseline JPEGs */
}                  

GLOBAL(void)
huff_pointer_restore(j_decompress_ptr cinfo, const huff_pointer *h)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;

  /* Restore the state of the huffman stream to a random earlier point */
  entropy->bitstate.get_buffer = h->get_buffer;
  entropy->restarts_to_go = h->restarts_to_go;
  entropy->bitstate.bits_left = h->bits_left;
  cinfo->marker->next_restart_num = h->next_restart_num;
  cinfo->unread_marker = h->unread_marker;
  cinfo->src->next_input_byte = h->next_input_byte;
  cinfo->src->bytes_in_buffer = cinfo->jpeg_buffer_size -
                                (cinfo->src->next_input_byte - cinfo->jpeg_buffer); 
  entropy->saved.last_dc_val[0] = h->last_dc_val[0];
  entropy->saved.last_dc_val[1] = h->last_dc_val[1];
  entropy->saved.last_dc_val[2] = h->last_dc_val[2];
  entropy->saved.last_dc_val[3] = h->last_dc_val[3];
}
#endif

/*
 * Compute the derived values for a Huffman table.
 * This routine also performs some validation checks on the table.
 */

LOCAL(void)
jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,
			 d_derived_tbl ** pdtbl)
{
  JHUFF_TBL *htbl;
  d_derived_tbl *dtbl;
  int p, i, l, si, numsymbols;
  int lookbits, ctr;
  char huffsize[257];
  unsigned int huffcode[257];
  unsigned int code;

  /* Note that huffsize[] and huffcode[] are filled in code-length order,
   * paralleling the order of the symbols themselves in htbl->huffval[].
   */

  /* Find the input Huffman table */
  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
  htbl =
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
  if (htbl == NULL)
    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);

  /* Allocate a workspace if we haven't already done so. */
  if (*pdtbl == NULL)
    *pdtbl = (d_derived_tbl *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(d_derived_tbl));
  dtbl = *pdtbl;
  dtbl->pub = htbl;		/* fill in back link */
  
  /* Figure C.1: make table of Huffman code length for each symbol */

  p = 0;
  for (l = 1; l <= 16; l++) {
    i = (int) htbl->bits[l];
    if (i < 0 || p + i > 256)	/* protect against table overrun */
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
    while (i--)
      huffsize[p++] = (char) l;
  }
  huffsize[p] = 0;
  numsymbols = p;
  
  /* Figure C.2: generate the codes themselves */
  /* We also validate that the counts represent a legal Huffman code tree. */
  
  code = 0;
  si = huffsize[0];
  p = 0;
  while (huffsize[p]) {
    while (((int) huffsize[p]) == si) {
      huffcode[p++] = code;
      code++;
    }
    /* code is now 1 more than the last code used for codelength si; but
     * it must still fit in si bits, since no code is allowed to be all ones.
     */
    if (((INT32) code) >= (((INT32) 1) << si))
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
    code <<= 1;
    si++;
  }

  /* Figure F.15: generate decoding tables for bit-sequential decoding */

  p = 0;
  for (l = 1; l <= 16; l++) {
    if (htbl->bits[l]) {
      /* valoffset[l] = huffval[] index of 1st symbol of code length l,
       * minus the minimum code of length l
       */
      dtbl->valoffset[l] = (INT32) p - (INT32) huffcode[p];
      p += htbl->bits[l];
      dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */
    } else {
      dtbl->maxcode[l] = -1;	/* -1 if no codes of this length */
    }
  }
  dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */

  /* Compute lookahead tables to speed up decoding.
   * First we set all the table entries to 0, indicating "too long";
   * then we iterate through the Huffman codes that are short enough and
   * fill in all the entries that correspond to bit sequences starting
   * with that code.
   */

  MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));

  p = 0;
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
      /* l = current code's length, p = its index in huffcode[] & huffval[]. */
      /* Generate left-justified code followed by all possible bit sequences */
      lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
	dtbl->look_nbits[lookbits] = l;
	dtbl->look_sym[lookbits] = htbl->huffval[p];
	lookbits++;
      }
    }
  }

  /* Validate symbols as being reasonable.
   * For AC tables, we make no check, but accept all byte values 0..255.
   * For DC tables, we require the symbols to be in range 0..15.
   * (Tighter bounds could be applied depending on the data depth and mode,
   * but this is sufficient to ensure safe decoding.)
   */
  if (isDC) {
    for (i = 0; i < numsymbols; i++) {
      int sym = htbl->huffval[i];
      if (sym < 0 || sym > 15)
	ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
    }
  }
}


/*
 * Out-of-line code for bit fetching.
 * Note: current values of get_buffer and bits_left are passed as parameters,
 * but are returned in the corresponding fields of the state struct.
 *
 * On most machines MIN_GET_BITS should be 25 to allow the full 32-bit width
 * of get_buffer to be used.  (On machines with wider words, an even larger
 * buffer could be used.)  However, on some machines 32-bit shifts are
 * quite slow and take time proportional to the number of places shifted.
 * (This is true with most PC compilers, for instance.)  In this case it may
 * be a win to set MIN_GET_BITS to the minimum value of 15.  This reduces the
 * average shift distance at the cost of more calls to jpeg_fill_bit_buffer.
 */

#ifdef SLOW_SHIFT_32
#define MIN_GET_BITS  15	/* minimum allowable value */
#else
#define MIN_GET_BITS  (BIT_BUF_SIZE-7)
#endif


LOCAL(boolean)
jpeg_fill_bit_buffer (bitread_working_state * state,
		      register bit_buf_type get_buffer, register int bits_left,
		      int nbits)
/* Load up the bit buffer to a depth of at least nbits */
{
  /* Copy heavily used state fields into locals (hopefully registers) */
  register const JOCTET * next_input_byte = state->next_input_byte;
  register size_t bytes_in_buffer = state->bytes_in_buffer;
  j_decompress_ptr cinfo = state->cinfo;

  /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
  /* (It is assumed that no request will be for more than that many bits.) */
  /* We fail to do so only if we hit a marker or are forced to suspend. */

  if (cinfo->unread_marker == 0) {	/* cannot advance past a marker */
    while (bits_left < MIN_GET_BITS) {
      register int c;

      /* Attempt to read a byte */
      if (bytes_in_buffer == 0) {
	if (! (*cinfo->src->fill_input_buffer) (cinfo))
	  return FALSE;
	next_input_byte = cinfo->src->next_input_byte;
	bytes_in_buffer = cinfo->src->bytes_in_buffer;
      }
      bytes_in_buffer--;
      c = GETJOCTET(*next_input_byte++);

      /* If it's 0xFF, check and discard stuffed zero byte */
      if (c == 0xFF) {
	/* Loop here to discard any padding FF's on terminating marker,
	 * so that we can save a valid unread_marker value.  NOTE: we will
	 * accept multiple FF's followed by a 0 as meaning a single FF data
	 * byte.  This data pattern is not valid according to the standard.
	 */
	do {
	  if (bytes_in_buffer == 0) {
	    if (! (*cinfo->src->fill_input_buffer) (cinfo))
	      return FALSE;
	    next_input_byte = cinfo->src->next_input_byte;
	    bytes_in_buffer = cinfo->src->bytes_in_buffer;
	  }
	  bytes_in_buffer--;
	  c = GETJOCTET(*next_input_byte++);
	} while (c == 0xFF);

	if (c == 0) {
	  /* Found FF/00, which represents an FF data byte */
	  c = 0xFF;
	} else {
	  /* Oops, it's actually a marker indicating end of compressed data.
	   * Save the marker code for later use.
	   * Fine point: it might appear that we should save the marker into
	   * bitread working state, not straight into permanent state.  But
	   * once we have hit a marker, we cannot need to suspend within the
	   * current MCU, because we will read no more bytes from the data
	   * source.  So it is OK to update permanent state right away.
	   */
	  cinfo->unread_marker = c;
	  /* See if we need to insert some fake zero bits. */
	  goto no_more_bytes;
	}
      }

      /* OK, load c into get_buffer */
      get_buffer = (get_buffer << 8) | c;
      bits_left += 8;
    } /* end while */
  } else {
  no_more_bytes:
    /* We get here if we've read the marker that terminates the compressed
     * data segment.  There should be enough bits in the buffer register
     * to satisfy the request; if so, no problem.
     */
    if (nbits > bits_left) {
      /* Uh-oh.  Report corrupted data to user and stuff zeroes into
       * the data stream, so that we can produce some kind of image.
       * We use a nonvolatile flag to ensure that only one warning message
       * appears per data segment.
       */
      if (! ((huff_entropy_ptr) cinfo->entropy)->insufficient_data) {
	WARNMS(cinfo, JWRN_HIT_MARKER);
#ifndef RISCOS /* Random access may seek backwards */
	((huff_entropy_ptr) cinfo->entropy)->insufficient_data = TRUE;
#endif
      }
      /* Fill the buffer with zero bits */
      get_buffer <<= MIN_GET_BITS - bits_left;
      bits_left = MIN_GET_BITS;
    }
  }

  /* Unload the local registers */
  state->next_input_byte = next_input_byte;
  state->bytes_in_buffer = bytes_in_buffer;
  state->get_buffer = get_buffer;
  state->bits_left = bits_left;

  return TRUE;
}


/*
 * Figure F.12: extend sign bit.
 * On some machines, a shift and sub will be faster than a table lookup.
 */

#ifdef AVOID_TABLES

#define BIT_MASK(nbits)   ((1<<(nbits))-1)
#define HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) - ((1<<(s))-1) : (x))

#else

#define BIT_MASK(nbits)   bmask[nbits]
#define HUFF_EXTEND(x,s)  ((x) <= bmask[(s) - 1] ? (x) - bmask[s] : (x))

static const int bmask[16] =	/* bmask[n] is mask for n rightmost bits */
  { 0, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF,
    0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF };

#endif /* AVOID_TABLES */


/*
 * Out-of-line code for Huffman code decoding.
 */

LOCAL(int)
jpeg_huff_decode (bitread_working_state * state,
		  register bit_buf_type get_buffer, register int bits_left,
		  d_derived_tbl * htbl, int min_bits)
{
  register int l = min_bits;
  register INT32 code;

  /* HUFF_DECODE has determined that the code is at least min_bits */
  /* bits long, so fetch that many bits in one swoop. */

  CHECK_BIT_BUFFER(*state, l, return -1);
  code = GET_BITS(l);

  /* Collect the rest of the Huffman code one bit at a time. */
  /* This is per Figure F.16 in the JPEG spec. */

  while (code > htbl->maxcode[l]) {
    code <<= 1;
    CHECK_BIT_BUFFER(*state, 1, return -1);
    code |= GET_BITS(1);
    l++;
  }

  /* Unload the local registers */
  state->get_buffer = get_buffer;
  state->bits_left = bits_left;

  /* With garbage input we may reach the sentinel value l = 17. */

  if (l > 16) {
    WARNMS(state->cinfo, JWRN_HUFF_BAD_CODE);
    return 0;			/* fake a zero as the safest result */
  }

  return htbl->pub->huffval[ (int) (code + htbl->valoffset[l]) ];
}


/*
 * Check for a restart marker & resynchronize decoder.
 * Returns FALSE if must suspend.
 */

LOCAL(boolean)
process_restart (j_decompress_ptr cinfo)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  int ci;

  /* Throw away any unused bits remaining in bit buffer; */
  /* include any full bytes in next_marker's count of discarded bytes */
  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
  entropy->bitstate.bits_left = 0;

  /* Advance past the RSTn marker */
  if (! (*cinfo->marker->read_restart_marker) (cinfo))
    return FALSE;

  /* Re-initialize DC predictions to 0 */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
    entropy->saved.last_dc_val[ci] = 0;
  /* Re-init EOB run count, too */
  entropy->saved.EOBRUN = 0;

  /* Reset restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;

  /* Reset out-of-data flag, unless read_restart_marker left us smack up
   * against a marker.  In that case we will end up treating the next data
   * segment as empty, and we can avoid producing bogus output pixels by
   * leaving the flag set.
   */
  if (cinfo->unread_marker == 0)
    entropy->insufficient_data = FALSE;

  return TRUE;
}


/*
 * Huffman MCU decoding.
 * Each of these routines decodes and returns one MCU's worth of
 * Huffman-compressed coefficients. 
 * The coefficients are reordered from zigzag order into natural array order,
 * but are not dequantized.
 *
 * The i'th block of the MCU is stored into the block pointed to by
 * MCU_data[i].  WE ASSUME THIS AREA IS INITIALLY ZEROED BY THE CALLER.
 * (Wholesale zeroing is usually a little faster than retail...)
 *
 * We return FALSE if data source requested suspension.  In that case no
 * changes have been made to permanent state.  (Exception: some output
 * coefficients may already have been assigned.  This is harmless for
 * spectral selection, since we'll just re-assign them on the next call.
 * Successive approximation AC refinement has to be more careful, however.)
 */

/*
 * MCU decoding for DC initial scan (either spectral selection,
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  int Al = cinfo->Al;
  register int s, r;
  int blkn, ci;
  JBLOCKROW block;
  BITREAD_STATE_VARS;
  savable_state state;
  d_derived_tbl * tbl;
  jpeg_component_info * compptr;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! process_restart(cinfo))
	return FALSE;
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->insufficient_data) {

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
    ASSIGN_STATE(state, entropy->saved);

    /* Outer loop handles each block in the MCU */

    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
      block = MCU_data[blkn];
      ci = cinfo->MCU_membership[blkn];
      compptr = cinfo->cur_comp_info[ci];
      tbl = entropy->derived_tbls[compptr->dc_tbl_no];

      /* Decode a single block's worth of coefficients */

      /* Section F.2.2.1: decode the DC coefficient difference */
      HUFF_DECODE(s, br_state, tbl, return FALSE, label1);
      if (s) {
	CHECK_BIT_BUFFER(br_state, s, return FALSE);
	r = GET_BITS(s);
	s = HUFF_EXTEND(r, s);
      }

      /* Convert DC difference to actual value, update last_dc_val */
      s += state.last_dc_val[ci];
      state.last_dc_val[ci] = s;
      /* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */
      (*block)[0] = (JCOEF) (s << Al);
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
    ASSIGN_STATE(entropy->saved, state);
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;

  return TRUE;
}


/*
 * MCU decoding for AC initial scan (either spectral selection,
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  register int s, k, r;
  unsigned int EOBRUN;
  int Se, Al;
#ifdef RISCOS /* More compact form */
  const char * natural_order;
#else
  const int * natural_order;
#endif
  JBLOCKROW block;
  BITREAD_STATE_VARS;
  d_derived_tbl * tbl;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! process_restart(cinfo))
	return FALSE;
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->insufficient_data) {

    Se = cinfo->Se;
    Al = cinfo->Al;
    natural_order = cinfo->natural_order;

    /* Load up working state.
     * We can avoid loading/saving bitread state if in an EOB run.
     */
    EOBRUN = entropy->saved.EOBRUN;	/* only part of saved state we need */

    /* There is always only one block per MCU */

    if (EOBRUN > 0)		/* if it's a band of zeroes... */
      EOBRUN--;			/* ...process it now (we do nothing) */
    else {
      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
      block = MCU_data[0];
      tbl = entropy->ac_derived_tbl;

      for (k = cinfo->Ss; k <= Se; k++) {
	HUFF_DECODE(s, br_state, tbl, return FALSE, label2);
	r = s >> 4;
	s &= 15;
	if (s) {
	  k += r;
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
	  r = GET_BITS(s);
	  s = HUFF_EXTEND(r, s);
	  /* Scale and output coefficient in natural (dezigzagged) order */
	  (*block)[natural_order[k]] = (JCOEF) (s << Al);
	} else {
	  if (r == 15) {	/* ZRL */
	    k += 15;		/* skip 15 zeroes in band */
	  } else {		/* EOBr, run length is 2^r + appended bits */
	    EOBRUN = 1 << r;
	    if (r) {		/* EOBr, r > 0 */
	      CHECK_BIT_BUFFER(br_state, r, return FALSE);
	      r = GET_BITS(r);
	      EOBRUN += r;
	    }
	    EOBRUN--;		/* this band is processed at this moment */
	    break;		/* force end-of-band */
	  }
	}
      }

      BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
    }

    /* Completed MCU, so update state */
    entropy->saved.EOBRUN = EOBRUN;	/* only part of saved state we need */
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;

  return TRUE;
}


/*
 * MCU decoding for DC successive approximation refinement scan.
 * Note: we assume such scans can be multi-component, although the spec
 * is not very clear on the point.
 */

METHODDEF(boolean)
decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
  int blkn;
  JBLOCKROW block;
  BITREAD_STATE_VARS;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! process_restart(cinfo))
	return FALSE;
  }

  /* Not worth the cycles to check insufficient_data here,
   * since we will not change the data anyway if we read zeroes.
   */

  /* Load up working state */
  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
    block = MCU_data[blkn];

    /* Encoded data is simply the next bit of the two's-complement DC value */
    CHECK_BIT_BUFFER(br_state, 1, return FALSE);
    if (GET_BITS(1))
      (*block)[0] |= p1;
    /* Note: since we use |=, repeating the assignment later is safe */
  }

  /* Completed MCU, so update state */
  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;

  return TRUE;
}


/*
 * MCU decoding for AC successive approximation refinement scan.
 */

METHODDEF(boolean)
decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  register int s, k, r;
  unsigned int EOBRUN;
  int Se, p1, m1;
#ifdef RISCOS /* More compact form */
  const char * natural_order;
#else
  const int * natural_order;
#endif
  JBLOCKROW block;
  JCOEFPTR thiscoef;
  BITREAD_STATE_VARS;
  d_derived_tbl * tbl;
  int num_newnz;
  int newnz_pos[DCTSIZE2];

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! process_restart(cinfo))
	return FALSE;
  }

  /* If we've run out of data, don't modify the MCU.
   */
  if (! entropy->insufficient_data) {

    Se = cinfo->Se;
    p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
    m1 = (-1) << cinfo->Al;	/* -1 in the bit position being coded */
    natural_order = cinfo->natural_order;

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
    EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we need */

    /* There is always only one block per MCU */
    block = MCU_data[0];
    tbl = entropy->ac_derived_tbl;

    /* If we are forced to suspend, we must undo the assignments to any newly
     * nonzero coefficients in the block, because otherwise we'd get confused
     * next time about which coefficients were already nonzero.
     * But we need not undo addition of bits to already-nonzero coefficients;
     * instead, we can test the current bit to see if we already did it.
     */
    num_newnz = 0;

    /* initialize coefficient loop counter to start of band */
    k = cinfo->Ss;

    if (EOBRUN == 0) {
      for (; k <= Se; k++) {
	HUFF_DECODE(s, br_state, tbl, goto undoit, label3);
	r = s >> 4;
	s &= 15;
	if (s) {
	  if (s != 1)		/* size of new coef should always be 1 */
	    WARNMS(cinfo, JWRN_HUFF_BAD_CODE);
	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
	  if (GET_BITS(1))
	    s = p1;		/* newly nonzero coef is positive */
	  else
	    s = m1;		/* newly nonzero coef is negative */
	} else {
	  if (r != 15) {
	    EOBRUN = 1 << r;	/* EOBr, run length is 2^r + appended bits */
	    if (r) {
	      CHECK_BIT_BUFFER(br_state, r, goto undoit);
	      r = GET_BITS(r);
	      EOBRUN += r;
	    }
	    break;		/* rest of block is handled by EOB logic */
	  }
	  /* note s = 0 for processing ZRL */
	}
	/* Advance over already-nonzero coefs and r still-zero coefs,
	 * appending correction bits to the nonzeroes.  A correction bit is 1
	 * if the absolute value of the coefficient must be increased.
	 */
	do {
	  thiscoef = *block + natural_order[k];
	  if (*thiscoef != 0) {
	    CHECK_BIT_BUFFER(br_state, 1, goto undoit);
	    if (GET_BITS(1)) {
	      if ((*thiscoef & p1) == 0) { /* do nothing if already set it */
		if (*thiscoef >= 0)
		  *thiscoef += p1;
		else
		  *thiscoef += m1;
	      }
	    }
	  } else {
	    if (--r < 0)
	      break;		/* reached target zero coefficient */
	  }
	  k++;
	} while (k <= Se);
	if (s) {
	  int pos = natural_order[k];
	  /* Output newly nonzero coefficient */
	  (*block)[pos] = (JCOEF) s;
	  /* Remember its position in case we have to suspend */
	  newnz_pos[num_newnz++] = pos;
	}
      }
    }

    if (EOBRUN > 0) {
      /* Scan any remaining coefficient positions after the end-of-band
       * (the last newly nonzero coefficient, if any).  Append a correction
       * bit to each already-nonzero coefficient.  A correction bit is 1
       * if the absolute value of the coefficient must be increased.
       */
      for (; k <= Se; k++) {
	thiscoef = *block + natural_order[k];
	if (*thiscoef != 0) {
	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
	  if (GET_BITS(1)) {
	    if ((*thiscoef & p1) == 0) { /* do nothing if already changed it */
	      if (*thiscoef >= 0)
		*thiscoef += p1;
	      else
		*thiscoef += m1;
	    }
	  }
	}
      }
      /* Count one block completed in EOB run */
      EOBRUN--;
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
    entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we need */
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;

  return TRUE;

undoit:
  /* Re-zero any output coefficients that we made newly nonzero */
  while (num_newnz > 0)
    (*block)[newnz_pos[--num_newnz]] = 0;

  return FALSE;
}


/*
 * Decode one MCU's worth of Huffman-compressed coefficients,
 * partial blocks.
 */

METHODDEF(boolean)
decode_mcu_sub (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
#ifdef RISCOS /* More compact form */
  const char * natural_order;
#else
  const int * natural_order;
#endif
  int Se, blkn;
  BITREAD_STATE_VARS;
  savable_state state;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! process_restart(cinfo))
	return FALSE;
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->insufficient_data) {

#ifdef LAZYDECODE
    boolean dconly;

    dconly = ((int)MCU_data & 1) != 0;
    MCU_data = (JBLOCKROW *)((int)MCU_data & ~1);
#endif
    natural_order = cinfo->natural_order;
    Se = cinfo->lim_Se;

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
    ASSIGN_STATE(state, entropy->saved);

    /* Outer loop handles each block in the MCU */

    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
      JBLOCKROW block = MCU_data[blkn];
      d_derived_tbl * htbl;
      register int s, k, r;
      int coef_limit, ci;

      /* Decode a single block's worth of coefficients */

      /* Section F.2.2.1: decode the DC coefficient difference */
      htbl = entropy->dc_cur_tbls[blkn];
      HUFF_DECODE(s, br_state, htbl, return FALSE, label1);

      htbl = entropy->ac_cur_tbls[blkn];
      k = 1;
#ifdef LAZYDECODE
      coef_limit = dconly ? 1 : entropy->coef_limit[blkn];
#else
      coef_limit = entropy->coef_limit[blkn];
#endif
      if (coef_limit) {
	/* Convert DC difference to actual value, update last_dc_val */
	if (s) {
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
	  r = GET_BITS(s);
	  s = HUFF_EXTEND(r, s);
	}
	ci = cinfo->MCU_membership[blkn];
	s += state.last_dc_val[ci];
	state.last_dc_val[ci] = s;
	/* Output the DC coefficient */
	(*block)[0] = (JCOEF) s;

	/* Section F.2.2.2: decode the AC coefficients */
	/* Since zeroes are skipped, output area must be cleared beforehand */
	for (; k < coef_limit; k++) {
	  HUFF_DECODE(s, br_state, htbl, return FALSE, label2);

	  r = s >> 4;
	  s &= 15;

	  if (s) {
	    k += r;
	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
	    r = GET_BITS(s);
	    s = HUFF_EXTEND(r, s);
	    /* Output coefficient in natural (dezigzagged) order.
	     * Note: the extra entries in natural_order[] will save us
	     * if k > Se, which could happen if the data is corrupted.
	     */
	    (*block)[natural_order[k]] = (JCOEF) s;
	  } else {
	    if (r != 15)
	      goto EndOfBlock;
	    k += 15;
	  }
	}
      } else {
	if (s) {
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
	  DROP_BITS(s);
	}
      }

      /* Section F.2.2.2: decode the AC coefficients */
      /* In this path we just discard the values */
      for (; k <= Se; k++) {
	HUFF_DECODE(s, br_state, htbl, return FALSE, label3);

	r = s >> 4;
	s &= 15;

	if (s) {
	  k += r;
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
	  DROP_BITS(s);
	} else {
	  if (r != 15)
	    break;
	  k += 15;
	}
      }

      EndOfBlock: ;
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
    ASSIGN_STATE(entropy->saved, state);
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;

  return TRUE;
}


#ifndef RISCOS /* Indistinguishable from general decode_mcu_sub() */
/*
 * Decode one MCU's worth of Huffman-compressed coefficients,
 * full-size blocks.
 */

METHODDEF(boolean)
decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  int blkn;
  BITREAD_STATE_VARS;
  savable_state state;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! process_restart(cinfo))
	return FALSE;
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->insufficient_data) {

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
    ASSIGN_STATE(state, entropy->saved);

    /* Outer loop handles each block in the MCU */

    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
      JBLOCKROW block = MCU_data[blkn];
      d_derived_tbl * htbl;
      register int s, k, r;
      int coef_limit, ci;

      /* Decode a single block's worth of coefficients */

      /* Section F.2.2.1: decode the DC coefficient difference */
      htbl = entropy->dc_cur_tbls[blkn];
      HUFF_DECODE(s, br_state, htbl, return FALSE, label1);

      htbl = entropy->ac_cur_tbls[blkn];
      k = 1;
      coef_limit = entropy->coef_limit[blkn];
      if (coef_limit) {
	/* Convert DC difference to actual value, update last_dc_val */
	if (s) {
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
	  r = GET_BITS(s);
	  s = HUFF_EXTEND(r, s);
	}
	ci = cinfo->MCU_membership[blkn];
	s += state.last_dc_val[ci];
	state.last_dc_val[ci] = s;
	/* Output the DC coefficient */
	(*block)[0] = (JCOEF) s;

	/* Section F.2.2.2: decode the AC coefficients */
	/* Since zeroes are skipped, output area must be cleared beforehand */
	for (; k < coef_limit; k++) {
	  HUFF_DECODE(s, br_state, htbl, return FALSE, label2);

	  r = s >> 4;
	  s &= 15;

	  if (s) {
	    k += r;
	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
	    r = GET_BITS(s);
	    s = HUFF_EXTEND(r, s);
	    /* Output coefficient in natural (dezigzagged) order.
	     * Note: the extra entries in jpeg_natural_order[] will save us
	     * if k >= DCTSIZE2, which could happen if the data is corrupted.
	     */
	    (*block)[jpeg_natural_order[k]] = (JCOEF) s;
	  } else {
	    if (r != 15)
	      goto EndOfBlock;
	    k += 15;
	  }
	}
      } else {
	if (s) {
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
	  DROP_BITS(s);
	}
      }

      /* Section F.2.2.2: decode the AC coefficients */
      /* In this path we just discard the values */
      for (; k < DCTSIZE2; k++) {
	HUFF_DECODE(s, br_state, htbl, return FALSE, label3);

	r = s >> 4;
	s &= 15;

	if (s) {
	  k += r;
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
	  DROP_BITS(s);
	} else {
	  if (r != 15)
	    break;
	  k += 15;
	}
      }

      EndOfBlock: ;
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
    ASSIGN_STATE(entropy->saved, state);
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;

  return TRUE;
}
#endif


/*
 * Initialize for a Huffman-compressed scan.
 */

METHODDEF(void)
start_pass_huff_decoder (j_decompress_ptr cinfo)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  int ci, blkn, tbl, i;
  jpeg_component_info * compptr;

  if (cinfo->progressive_mode) {
    /* Validate progressive scan parameters */
    if (cinfo->Ss == 0) {
      if (cinfo->Se != 0)
	goto bad;
    } else {
      /* need not check Ss/Se < 0 since they came from unsigned bytes */
      if (cinfo->Se < cinfo->Ss || cinfo->Se > cinfo->lim_Se)
	goto bad;
      /* AC scans may have only one component */
      if (cinfo->comps_in_scan != 1)
	goto bad;
    }
    if (cinfo->Ah != 0) {
      /* Successive approximation refinement scan: must have Al = Ah-1. */
      if (cinfo->Ah-1 != cinfo->Al)
	goto bad;
    }
    if (cinfo->Al > 13) {	/* need not check for < 0 */
      /* Arguably the maximum Al value should be less than 13 for 8-bit precision,
       * but the spec doesn't say so, and we try to be liberal about what we
       * accept.  Note: large Al values could result in out-of-range DC
       * coefficients during early scans, leading to bizarre displays due to
       * overflows in the IDCT math.  But we won't crash.
       */
      bad:
      ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
	       cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);
    }
    /* Update progression status, and verify that scan order is legal.
     * Note that inter-scan inconsistencies are treated as warnings
     * not fatal errors ... not clear if this is right way to behave.
     */
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
      int coefi, cindex = cinfo->cur_comp_info[ci]->component_index;
      int *coef_bit_ptr = & cinfo->coef_bits[cindex][0];
      if (cinfo->Ss && coef_bit_ptr[0] < 0) /* AC without prior DC scan */
	WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);
      for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
	int expected = (coef_bit_ptr[coefi] < 0) ? 0 : coef_bit_ptr[coefi];
	if (cinfo->Ah != expected)
	  WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);
	coef_bit_ptr[coefi] = cinfo->Al;
      }
    }

    /* Select MCU decoding routine */
    if (cinfo->Ah == 0) {
      if (cinfo->Ss == 0)
	entropy->pub.decode_mcu = (boolean (*)(j_decompress_ptr, JBLOCKROW *))RELOCCODE(decode_mcu_DC_first);
      else
	entropy->pub.decode_mcu = (boolean (*)(j_decompress_ptr, JBLOCKROW *))RELOCCODE(decode_mcu_AC_first);
    } else {
      if (cinfo->Ss == 0)
	entropy->pub.decode_mcu = (boolean (*)(j_decompress_ptr, JBLOCKROW *))RELOCCODE(decode_mcu_DC_refine);
      else
	entropy->pub.decode_mcu = (boolean (*)(j_decompress_ptr, JBLOCKROW *))RELOCCODE(decode_mcu_AC_refine);
    }

    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
      compptr = cinfo->cur_comp_info[ci];
      /* Make sure requested tables are present, and compute derived tables.
       * We may build same derived table more than once, but it's not expensive.
       */
      if (cinfo->Ss == 0) {
	if (cinfo->Ah == 0) {	/* DC refinement needs no table */
	  tbl = compptr->dc_tbl_no;
	  jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,
				  & entropy->derived_tbls[tbl]);
	}
      } else {
	tbl = compptr->ac_tbl_no;
	jpeg_make_d_derived_tbl(cinfo, FALSE, tbl,
				& entropy->derived_tbls[tbl]);
	/* remember the single active table */
	entropy->ac_derived_tbl = entropy->derived_tbls[tbl];
      }
      /* Initialize DC predictions to 0 */
      entropy->saved.last_dc_val[ci] = 0;
    }

    /* Initialize private state variables */
    entropy->saved.EOBRUN = 0;
  } else {
    /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
     * This ought to be an error condition, but we make it a warning because
     * there are some baseline files out there with all zeroes in these bytes.
     */
    if (cinfo->Ss != 0 || cinfo->Ah != 0 || cinfo->Al != 0 ||
	((cinfo->is_baseline || cinfo->Se < DCTSIZE2) &&
	cinfo->Se != cinfo->lim_Se))
      WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);

    /* Select MCU decoding routine */
#ifndef RISCOS /* Indistinguishable from general decode_mcu_sub() */
    /* We retain the hard-coded case for full-size blocks.
     * This is not necessary, but it appears that this version is slightly
     * more performant in the given implementation.
     * With an improved implementation we would prefer a single optimized
     * function.
     */
    if (cinfo->lim_Se != DCTSIZE2-1)
      entropy->pub.decode_mcu = decode_mcu_sub;
    else
      entropy->pub.decode_mcu = decode_mcu;
#else
    entropy->pub.decode_mcu = (boolean (*)(j_decompress_ptr, JBLOCKROW *))RELOCCODE(decode_mcu_sub);
#endif

    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
      compptr = cinfo->cur_comp_info[ci];
      /* Compute derived values for Huffman tables */
      /* We may do this more than once for a table, but it's not expensive */
      tbl = compptr->dc_tbl_no;
      jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,
			      & entropy->dc_derived_tbls[tbl]);
      if (cinfo->lim_Se) {	/* AC needs no table when not present */
	tbl = compptr->ac_tbl_no;
	jpeg_make_d_derived_tbl(cinfo, FALSE, tbl,
				& entropy->ac_derived_tbls[tbl]);
      }
      /* Initialize DC predictions to 0 */
      entropy->saved.last_dc_val[ci] = 0;
    }

    /* Precalculate decoding info for each block in an MCU of this scan */
    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
      ci = cinfo->MCU_membership[blkn];
      compptr = cinfo->cur_comp_info[ci];
      /* Precalculate which table to use for each block */
      entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
      entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
      /* Decide whether we really care about the coefficient values */
      if (compptr->component_needed) {
	ci = compptr->DCT_v_scaled_size;
	i = compptr->DCT_h_scaled_size;
#ifndef RISCOS /* Avoid const relocation, use code */
	switch (cinfo->lim_Se) {
	case (1*1-1):
	  entropy->coef_limit[blkn] = 1;
	  break;
	case (2*2-1):
	  if (ci <= 0 || ci > 2) ci = 2;
	  if (i <= 0 || i > 2) i = 2;
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order2[ci - 1][i - 1];
	  break;
	case (3*3-1):
	  if (ci <= 0 || ci > 3) ci = 3;
	  if (i <= 0 || i > 3) i = 3;
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order3[ci - 1][i - 1];
	  break;
	case (4*4-1):
	  if (ci <= 0 || ci > 4) ci = 4;
	  if (i <= 0 || i > 4) i = 4;
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order4[ci - 1][i - 1];
	  break;
	case (5*5-1):
	  if (ci <= 0 || ci > 5) ci = 5;
	  if (i <= 0 || i > 5) i = 5;
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order5[ci - 1][i - 1];
	  break;
	case (6*6-1):
	  if (ci <= 0 || ci > 6) ci = 6;
	  if (i <= 0 || i > 6) i = 6;
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order6[ci - 1][i - 1];
	  break;
	case (7*7-1):
	  if (ci <= 0 || ci > 7) ci = 7;
	  if (i <= 0 || i > 7) i = 7;
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order7[ci - 1][i - 1];
	  break;
	default:
	  if (ci <= 0 || ci > 8) ci = 8;
	  if (i <= 0 || i > 8) i = 8;
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order[ci - 1][i - 1];
	  break;
	}
#else
	for (tbl = 1; tbl <= DCTSIZE; tbl++) {
	  if (((tbl*tbl) - 1) == cinfo->lim_Se) {
	    if (ci <= 0 || ci > tbl) ci = tbl;
	    if (i <= 0 || i > tbl) i = tbl;
	    entropy->coef_limit[blkn] = 1 + get_zigzag_pos(ci - 1, i - 1, tbl);
	    break;
	  }
	}
#endif
      } else {
	entropy->coef_limit[blkn] = 0;
      }
    }
  }

  /* Initialize bitread state variables */
  entropy->bitstate.bits_left = 0;
  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
  entropy->insufficient_data = FALSE;

  /* Initialize restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
}


/*
 * Module initialization routine for Huffman entropy decoding.
 */

GLOBAL(void)
jinit_huff_decoder (j_decompress_ptr cinfo)
{
  huff_entropy_ptr entropy;
  int i;

  entropy = (huff_entropy_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(huff_entropy_decoder));
  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
  entropy->pub.start_pass = (void (*)(j_decompress_ptr))RELOCCODE(start_pass_huff_decoder);

  if (cinfo->progressive_mode) {
    /* Create progression status table */
    int *coef_bit_ptr, ci;
    cinfo->coef_bits = (int (*)[DCTSIZE2])
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  cinfo->num_components*DCTSIZE2*SIZEOF(int));
    coef_bit_ptr = & cinfo->coef_bits[0][0];
    for (ci = 0; ci < cinfo->num_components; ci++)
      for (i = 0; i < DCTSIZE2; i++)
	*coef_bit_ptr++ = -1;

    /* Mark derived tables unallocated */
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
      entropy->derived_tbls[i] = NULL;
    }
  } else {
    /* Mark tables unallocated */
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
      entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
    }
  }
}
@


4.7
log
@Bug fixes
Detail:
  Remove the unused gray (sic) output colour space support. Remove the patches to set output colour space to RGB, this can be overridden in code per the design intent of the library. Only decode luma for grey output.
  Fix bug rendering test image monorose2x4 - this was caused by the huffman pointer saving not decoding enough MCUs when the source image is monochrome hence an MCU outputs 8x8 rather than hsamp x vsamp pixels. Also removed the setting of insufficient_data in the entropy decoder, this meant that any error at the end of the image (eg. truncated) would cause the rest of the image to not render because JPEGs are stored top down but RISC OS plots them bottom up.
  Fix endless failure to match previously cached JPEG, especially at 16bpp, when the source JPEG doesn't meet the fast colour conversion criteria (eg. not 2x2 subsampling). The flags test was checking the requested flags against the filtered flags, which never matched (because the unmet options get cleared). Now, keep the original flags prior to filtering and compare those on the basis that the conversion decision will be consistent; simply ANDing out those modifiable flags doesn't help because then you can't spot when they genuinely change (eg. a mode change) as the filtered flags determine what format the blitter is expecting back.
  Fix bug causing aborts when the user manually resizes (down) the JPEG workspace DA. The calculation of new_size in jpeg_find_image_dims() had at some point lost the height multiplier on the band buffer, so when auto resizing back up again the buffer was too small to convert a whole band into.
Admin:
  Submission for the JPEG bounty.

Version 1.74. Tagged as 'SprExtend-1_74'
@
text
@d1158 6
d1187 3
d1191 1
@


4.6
log
@Import of IJG8d library sources
Detail:
  Using the decoder in "example.c" as a starting point, we try to follow that sequence more closely even if in our embedded implementation some of the functions don't do much.
  Uses the default colour backend for 32bpp BGR output for most of the unusual cases.
  The most common 2x2 subsampling case uses a custom merged upsampler and colour converter, with colour output directly in RISC OS format for the respective screen mode.
Admin:
  Submission for the JPEG bounty.

Version 1.71. Tagged as 'SprExtend-1_71'
@
text
@d612 1
d614 1
@


4.5
log
@Replace tracef debug calls
Detail:
  Change tracef() to use the double brackets trick rather than _ for , substitution
Admin:
  Debug build built, but not tested. Non debug build functions as before.
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_70-tracef
@
text
@a0 14
/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
d4 2
a5 1
 * Copyright (C) 1991, 1992, Thomas G. Lane.
d10 17
a26 2
 * These routines are invoked via the methods entropy_decode
 * and entropy_decoder_init/term.
d28 39
a66 1
 * Not only hacked for use deep within RISC OS, but bits of release 4 transplanted in too.
a67 2
#undef FILE_
#define FILE_ (10000)
d69 150
a218 2
#ifndef RISCOS
#include "jinclude.h"
d222 164
a385 2
LOCAL(int)
huff_DECODE_buildshortcut (j_decompress_ptr cinfo, JHUFF_TBL * htbl); /* forward reference */
d388 2
a389 2
fix_huff_tbl (j_decompress_ptr cinfo, JHUFF_TBL * htbl)
/* Compute derived values for a Huffman table */
d391 4
a394 1
  int p, i, l, si;
d396 2
a397 2
  UINT16 huffcode[257];
  UINT16 code;
d399 20
a419 1
  /* Note that this is in code-length order. */
d423 4
a426 1
    for (i = 1; i <= (int) htbl->bits[l]; i++)
d430 2
a431 1

d433 2
a434 2
  /* Note that this is in code-length order. */

d443 5
d452 1
a452 4
  /* We don't bother to fill in the encoding tables ehufco[] and ehufsi[], */
  /* since they are not used for decoding. */

  /* Figure F.15: generate decoding tables */
d457 4
a460 3
      htbl->valptr[l] = p;      /* huffval[] index of 1st sym of code len l */
      htbl->valptr[l] -= huffcode[p]; /* subtract value in old 'mincode' table, for speed later */
      /* htbl->mincode[l] = huffcode[p]; */ /* minimum code of length l */
d462 1
a462 1
      htbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */
d464 1
a464 1
      htbl->maxcode[l] = -1;
d467 1
a467 1
  htbl->maxcode[17] = 0xFFFFF /*0xFFFFFL*/; /* ensures huff_DECODE terminates */
d469 19
a487 20
  /* Now we build the shortcut table. Using the above, reading a huffman code
  proceeds by reading bits one at a time, and looking up the result in a table
  to see if it is big enough yet. The shortcut table reads the next 8 bits
  of input, and uses this to index a table that says what to do. This table
  is constructed by trying all 256 possibles. */
  {
    int i; /* index into shortcut table */
    int h; /* the code you read */

    for (i = 0; i < 256; i++) /* for each element of shortcut table */
    {
      cinfo->bits_left = 32;
      cinfo->get_buffer = i << 24; /* fake the input bits */
      h = huff_DECODE_buildshortcut(cinfo, htbl); /* the C-coded decoding doesn't use the shortcut table - we haven't built it yet! */
      if (cinfo->bits_left < 24) /* code longer than 8 bits */
        htbl->shortcut[i] = -1;
      else
      {
        assert(h >= 0, ERROR_FATAL);
        htbl->shortcut[i] = ((32 - cinfo->bits_left) << 24) | h; /* remember size and value */
d490 14
a503 2
    cinfo->bits_left = 0;
    cinfo->get_buffer = 0;
a506 1
/* Extract the next N bits from the input stream (N <= 15) */
d508 26
a533 2
LOCAL(int)
get_bits (j_decompress_ptr cinfo, int nbits)
d535 22
a556 1
  int result;
d558 35
a592 2
  while (nbits > cinfo->bits_left) {
    int c = JGETC(cinfo);
d594 23
a616 8
    cinfo->get_buffer <<= 8;
    cinfo->get_buffer |= c;
    cinfo->bits_left += 8;
    /* If it's 0xFF, check and discard stuffed zero byte */
    if (c == 0xff) {
      c = JGETC(cinfo);  /* Byte stuffing */
      if (c != 0)
        ERREXIT1(cinfo, JTRC_PARMLESS_MARKER, c);
d620 7
a626 3
  cinfo->bits_left -= nbits;
  result = ((int) (cinfo->get_buffer >> cinfo->bits_left)) & ((1 << nbits) - 1);
  return result;
a628 1
/* Macro to make things go at some speed! */
d630 21
a650 3
#define get_bit(cinfo)       (cinfo->bits_left ? \
                             ((int) (cinfo->get_buffer >> (--cinfo->bits_left))) & 1 : \
                             get_bits(cinfo, 1))
d652 3
a654 1
/* Figure F.16: extract next coded symbol from input stream */
a655 1
/* Altered version of huff_DECODE for use in constructing the shortcut table */
d657 3
a659 1
huff_DECODE_buildshortcut (j_decompress_ptr cinfo, JHUFF_TBL * htbl)
d661 2
a662 2
  int l, p;
  INT32 code;
d664 2
a665 10
  code = get_bit(cinfo);
  l = 1;
  while (code > htbl->maxcode[l] && l <= 8) {
    code = (code << 1) + get_bit(cinfo);
    l++;
  }
  if (l > 8) return -1;
  p = (int) (htbl->valptr[l] + (code /* - htbl->mincode[l] */));
  return (int) htbl->huffval[p];
}
d667 2
a668 1
#ifndef ASMHUFF
d670 2
a671 5
LOCAL(int)
huff_DECODE (j_decompress_ptr cinfo, JHUFF_TBL * htbl)
{
  int l, p;
  INT32 code;
a672 2
  code = get_bit(cinfo);
  l = 1;
d674 3
a676 1
    code = (code << 1) + get_bit(cinfo);
d680 4
d687 2
a688 1
    ERREXIT(cinfo->emethods, "Corrupted data in JPEG file");
d691 4
a694 1
  p = (int) (htbl->valptr[l] + (code /* - htbl->mincode[l] */));
d696 37
a732 4
  dprintf(("", "Decoded huffman value=%i next_byte=0x%x bits_left=%i get_buf=0x%x.\n"
 , htbl->huffval[p], (int)cinfo->next_input_byte, cinfo->bits_left, cinfo->get_buffer);
*/
  return (int) htbl->huffval[p];
a734 1
/* Figure F.12: extend sign bit */
d736 42
a777 1
/* NB: on some compilers this will only work for s > 0 */
d779 26
a804 3
#define huff_EXTEND(x, s)       ((x) < (1 << ((s)-1)) ? \
                                 (x) + (-1 << (s)) + 1 : \
                                 (x))
d806 6
d813 4
a816 1
/* Decode a single block's worth of coefficients */
d818 2
a819 5
/* ZAG[i] is the natural-order position of the i'th element of zigzag order.
 * If the incoming data is corrupted, huff_decode_mcu could attempt to
 * reference values beyond the end of the array.  To avoid a wild store,
 * we put some extra zeroes after the real entries.
 */
d821 2
a822 1
#if 0
a823 12
static const short ZAG[DCTSIZE2+16] = {
  0,  1,  8, 16,  9,  2,  3, 10,
 17, 24, 32, 25, 18, 11,  4,  5,
 12, 19, 26, 33, 40, 48, 41, 34,
 27, 20, 13,  6,  7, 14, 21, 28,
 35, 42, 49, 56, 57, 50, 43, 36,
 29, 22, 15, 23, 30, 37, 44, 51,
 58, 59, 52, 45, 38, 31, 39, 46,
 53, 60, 61, 54, 47, 55, 62, 63,
  0,  0,  0,  0,  0,  0,  0,  0, /* extra entries in case k>63 below */
  0,  0,  0,  0,  0,  0,  0,  0
};
d825 4
a828 12
/* 2-digit ones in decimal: */
#define ZAG (\
"\x00\x01\x08\x16\x09\x02\x03\x10" \
"\x17\x24\x32\x25\x18\x11\x04\x05" \
"\x12\x19\x26\x33\x40\x48\x41\x34" \
"\x27\x20\x13\x06\x07\x14\x21\x28" \
"\x35\x42\x49\x56\x57\x50\x43\x36" \
"\x29\x22\x15\x23\x30\x37\x44\x51" \
"\x58\x59\x52\x45\x38\x31\x39\x46" \
"\x53\x60\x61\x54\x47\x55\x62\x63" \
"\x00\x00\x00\x00\x00\x00\x00\x00" \
"\x00\x00\x00\x00\x00\x00\x00\x00")
d830 9
d840 62
d903 2
a904 11
#define ZAG (\
"\x00\x01\x08\x10\x09\x02\x03\x0a" \
"\x11\x18\x20\x19\x12\x0b\x04\x05" \
"\x0c\x13\x1a\x21\x28\x30\x29\x22" \
"\x1b\x14\x0d\x06\x07\x0e\x15\x1c" \
"\x23\x2a\x31\x38\x39\x32\x2b\x24" \
"\x1d\x16\x0f\x17\x1e\x25\x2c\x33" \
"\x3a\x3b\x34\x2d\x26\x1f\x27\x2e" \
"\x35\x3c\x3d\x36\x2f\x37\x3e\x3f" \
"\x00\x00\x00\x00\x00\x00\x00\x00" \
"\x00\x00\x00\x00\x00\x00\x00\x00")
d906 3
a908 1
#endif
d910 2
a911 4
LOCAL(void)
decode_one_block (j_decompress_ptr cinfo, JBLOCK block, JHUFF_TBL *dctbl, JHUFF_TBL *actbl, QUANT_TBL_PTR quanttbl, int *last_dc_val)
{
  int s, k, r, n;
d913 2
a914 1
  /* zero out the coefficient block */
a915 1
  MEMZERO((void *) block, SIZEOF(JBLOCK));
d917 5
a921 1
  /* Section F.2.2.1: decode the DC coefficient difference */
d923 14
a936 4
  s = huff_DECODE(cinfo, dctbl);
  if (s) {
    r = get_bits(cinfo, s);
    s = huff_EXTEND(r, s);
a937 5
  /* Convert DC difference to actual value, update last_dc_val */
  s += *last_dc_val;
  *last_dc_val = (JCOEF) s;
  /* Descale and output the DC coefficient (assumes ZAG[0] = 0) */
  block[0] = (JCOEF) (((JCOEF) s) * quanttbl->quantval[0]);
d939 27
a965 1
  /* Section F.2.2.2: decode the AC coefficients */
a966 2
  for (k = 1; k < DCTSIZE2; k++) {
    r = huff_DECODE(cinfo, actbl);
d968 3
a970 2
    s = r & 15;
    n = r >> 4;
d972 133
a1104 10
    if (s) {
      k += n;
      r = get_bits(cinfo, s);
      s = huff_EXTEND(r, s);
      /* Descale coefficient and output in natural (dezigzagged) order */
      block[ZAG[k]] = (JCOEF) (((JCOEF) s) * quanttbl->quantval[k]);
    } else {
      if (n != 15)
        break;
      k += 15;
d1106 4
d1111 12
a1124 6
LOCAL(void)
skip_one_block (j_decompress_ptr cinfo, JHUFF_TBL *dctbl, JHUFF_TBL *actbl, int *last_dc_val)
/* Like decode_one_block in its effect on *last_dc_val and the source of the input stream,
but no block of coefficients need be produced. */
{
  int s, k, r, n;
d1126 4
a1129 1
  /* Section F.2.2.1: decode the DC coefficient difference */
d1131 18
a1148 4
  s = huff_DECODE(cinfo, dctbl);
  if (s) {
    r = get_bits(cinfo, s);
    s = huff_EXTEND(r, s);
a1149 3
  /* Convert DC difference to actual value, update last_dc_val */
  s += *last_dc_val;
  *last_dc_val = (JCOEF) s;
d1151 72
a1222 1
  /* Section F.2.2.2: decode the AC coefficients */
d1224 18
a1241 2
  for (k = 1; k < DCTSIZE2; k++) {
    r = huff_DECODE(cinfo, actbl);
d1243 2
a1244 2
    s = r & 15;
    n = r >> 4;
d1246 3
a1248 8
    if (s) {
      k += n;
      r = get_bits(cinfo, s);
    } else {
      if (n != 15)
        break;
      k += 15;
    }
d1250 5
d1257 20
a1276 9
LOCAL(void)
huff_decode_blocks(j_decompress_ptr cinfo, JBLOCK block,
                   JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JHUFF_TBL * quanttbl,
                   int *last_dc_val, int nblocks)
{
  while (nblocks > 0)
  {
    decode_one_block(cinfo,block,dctbl,actbl,quanttbl,last_dc_val);
    nblocks--;
a1277 1
}
d1279 95
a1373 11
extern void
huff_skip_blocks (j_decompress_ptr cinfo, JBLOCK block,
                  JHUFF_TBL *dctbl, JHUFF_TBL *actbl,
                  JHUFF_TBL * quanttbl, int *last_dc_val, int nblocks)
{
  block=block; /* unused */
  quanttbl=quanttbl; /* unused */
  while (nblocks > 0)
  {
    skip_one_block(cinfo,dctbl,actbl,last_dc_val);
    nblocks--;
d1375 5
d1381 1
a1382 1
#endif
a1385 1
 * This is invoked after reading the SOS marker.
d1389 215
a1603 1
huff_decoder_init (j_decompress_ptr cinfo)
d1605 2
a1606 3
  /* Initialize static variables */
/*  dcinfo = cinfo; */
  cinfo->bits_left = 0;
d1608 27
@


4.4
log
@Update headers to stock copy
Detail:
  Added headers jerror, jmorecfg, jpegint from IJG8d. Removed jpegdata header.
  Bulk rename of structure members to match newer headers, some RISCOS-isms wrapped in #ifdef RISCOS, retained for the time being.
  Assembler code now gets cinfo member offsets from jhdr.s derived from the C header rather than keeping its own dangerous copy of the offsets.
Admin
  Note: this has broken CFSI-jpeg as it expects the error values to be at the top of cinfo.
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_70-headers.
@
text
@d194 2
a195 2
  tracef("Decoded huffman value=%i next_byte=0x%x bits_left=%i get_buf=0x%x.\n"
  _ htbl->huffval[p] _ (int)cinfo->next_input_byte _ cinfo->bits_left _ cinfo->get_buffer);
@


4.3
log
@Remove postprocessing step of C code.
Since 2001 this module has been using objasm, but still using the C compiler to output (via -S) assembly code which is then passed through 'sed' and included via GET into the assembler code.
Changed to compile the C code into object files, and use the linker to patch up the unresolved references - this has required some reordering of the C code to make sure static functions now appear in the object file, and some reordering of the header files to ensure both the module and the CFSI version still compile without conflicts.
Minor fix to 'swiv2', the label was in the wrong place for _swi() though it's not used in this module so didn't affect the _swix() case.
Makefile cut down a bit. Unixify some path names.
Test code moved to 'Test/c' directory.
Tested in both debug and non debug cases via softloaded module. Oddly, it's 4 bytes longer than the previous version.

Version 1.28. Tagged as 'SprExtend-1_28'
@
text
@d31 1
d33 2
d36 2
a37 2
LOCAL int
huff_DECODE_buildshortcut (decompress_info_ptr cinfo, HUFF_TBL * htbl); /* forward reference */
d39 2
a40 2
LOCAL void
fix_huff_tbl (decompress_info_ptr cinfo, HUFF_TBL * htbl)
d121 2
a122 2
LOCAL int
get_bits (decompress_info_ptr cinfo, int nbits)
d136 1
a136 2
        ERREXIT1(cinfo->emethods,
                 "Unexpected marker 0x%02x in compressed data", c);
d154 2
a155 2
LOCAL int
huff_DECODE_buildshortcut (decompress_info_ptr cinfo, HUFF_TBL * htbl)
d173 2
a174 2
LOCAL int
huff_DECODE (decompress_info_ptr cinfo, HUFF_TBL * htbl)
d261 2
a262 2
LOCAL void
decode_one_block (decompress_info_ptr cinfo, JBLOCK block, HUFF_TBL *dctbl, HUFF_TBL *actbl, QUANT_TBL_PTR quanttbl, int *last_dc_val)
d281 1
a281 1
  block[0] = (JCOEF) (((JCOEF) s) * quanttbl[0]);
d296 1
a296 1
      block[ZAG[k]] = (JCOEF) (((JCOEF) s) * quanttbl[k]);
d305 2
a306 2
LOCAL void
skip_one_block (decompress_info_ptr cinfo, HUFF_TBL *dctbl, HUFF_TBL *actbl, int *last_dc_val)
d342 3
a344 3
LOCAL void
huff_decode_blocks(decompress_info_ptr cinfo, JBLOCK block,
                   HUFF_TBL *dctbl, HUFF_TBL *actbl, QUANT_TBL_PTR quanttbl,
d355 3
a357 3
huff_skip_blocks (decompress_info_ptr cinfo, JBLOCK block,
                  HUFF_TBL *dctbl, HUFF_TBL *actbl,
                  QUANT_TBL_PTR quanttbl, int *last_dc_val, int nblocks)
d375 2
a376 2
METHODDEF void
huff_decoder_init (decompress_info_ptr cinfo)
@


4.3.2.1
log
@Push some redundant files into the attic.
@
text
@d31 1
a31 1
#include "jpeglib.h"
d33 2
a34 2
LOCAL(int)
huff_DECODE_buildshortcut (j_decompress_ptr cinfo, JHUFF_TBL * htbl); /* forward reference */
d36 2
a37 2
LOCAL(void)
fix_huff_tbl (j_decompress_ptr cinfo, JHUFF_TBL * htbl)
d118 2
a119 2
LOCAL(int)
get_bits (j_decompress_ptr cinfo, int nbits)
d152 2
a153 2
LOCAL(int)
huff_DECODE_buildshortcut (j_decompress_ptr cinfo, JHUFF_TBL * htbl)
d171 2
a172 2
LOCAL(int)
huff_DECODE (j_decompress_ptr cinfo, JHUFF_TBL * htbl)
d259 2
a260 2
LOCAL(void)
decode_one_block (j_decompress_ptr cinfo, JBLOCK block, JHUFF_TBL *dctbl, JHUFF_TBL *actbl, QUANT_TBL_PTR quanttbl, int *last_dc_val)
d303 2
a304 2
LOCAL(void)
skip_one_block (j_decompress_ptr cinfo, JHUFF_TBL *dctbl, JHUFF_TBL *actbl, int *last_dc_val)
d340 3
a342 3
LOCAL(void)
huff_decode_blocks(j_decompress_ptr cinfo, JBLOCK block,
                   JHUFF_TBL *dctbl, JHUFF_TBL *actbl, QUANT_TBL_PTR quanttbl,
d353 2
a354 2
huff_skip_blocks (j_decompress_ptr cinfo, JBLOCK block,
                  JHUFF_TBL *dctbl, JHUFF_TBL *actbl,
d373 2
a374 2
METHODDEF(void)
huff_decoder_init (j_decompress_ptr cinfo)
@


4.3.2.2
log
@Reinstate C code version of jdhuff.
In huff_decode_blocks the block pointer wasn't being incremented, as it was in the assembler.
Useful for speed comparisons.

Version 1.38, 1.35.2.3. Tagged as 'SprExtend-1_38-1_35_2_3'
@
text
@d206 3
d214 31
d257 2
d260 1
a260 2
decode_one_block (j_decompress_ptr cinfo, JBLOCK block, JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JQUANT_TBL *quanttbl, JCOEF *last_dc_val)
/* Decode a single block's worth of coefficients */
d279 1
a279 1
  block[0] = (JCOEF) (((JCOEF) s) * quanttbl->quantval[0]);
d294 1
a294 1
      block[ZAG[k]] = (JCOEF) (((JCOEF) s) * quanttbl->quantval[k]);
d304 1
a304 1
skip_one_block (j_decompress_ptr cinfo, JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JCOEF *last_dc_val)
d342 2
a343 2
                   JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JQUANT_TBL *quanttbl,
                   JCOEF *last_dc_val, int nblocks)
d347 1
a347 2
    decode_one_block(cinfo, block, dctbl, actbl, quanttbl, last_dc_val);
    block = block + DCTSIZE2;
d352 1
a352 1
LOCAL(void)
d355 1
a355 1
                  JQUANT_TBL *quanttbl, JCOEF *last_dc_val, int nblocks)
d357 2
d361 1
a361 1
    skip_one_block(cinfo, dctbl, actbl, last_dc_val);
a363 2
  UNUSED(block);
  UNUSED(quanttbl);
d377 1
d379 1
@


4.3.2.3
log
@Create assembler equivalents of C colour conversions, approx 10% speed up.
Add new switch ASMCOLOR to select which to use, C or assembler.
Remove FILE_ exit trace concept, just use __FILE__ instead in exit_erl.
Add some comments to exit_erl and friends.
A few bits of cinfo setup moved into start_pass_huff_decoder() or eliminated.
Bumped up the precision of SCALE_BITS in the C colour handling so FIX() uses more bits of an int.
Deleted the unused remenants of light dithering in the 8bpp colour converter - saves a few cycles.
colour_convert_8 and colour_convert_16 no longer save entry registers the C compiler doesn't care about.
Update genyuvtabs to EXPORT the table bases.
Split out the compilation of IJG files as separate objects in the make file, rather than including them from within rojpeg, which is itself included from putscaled.

Version 1.38, 1.35.2.6. Tagged as 'SprExtend-1_38-1_35_2_6'
@
text
@d28 2
a30 2
#define JPEG_INTERNALS
#include "jinclude.h"
a32 1

d36 1
a36 1
GLOBAL(void)
d152 1
a152 1
GLOBAL(int)
d305 1
a305 1
GLOBAL(void)
d318 1
a318 1
GLOBAL(void)
d336 1
d339 2
a340 2
GLOBAL(void)
start_pass_huff_decoder (j_decompress_ptr cinfo)
d342 1
a342 1
  /* Initialize bitread state variables */
a343 5
  //cinfo->get_buffer = 0; /* unnecessary, but keeps Purify quiet */
  //cinfo->insufficient_data = FALSE;

  /* Initialize restart counter */
  cinfo->restarts_to_go = cinfo->restart_interval;
@


4.3.2.4
log
@Use USAT in 150 occurrences of colour clamping for ARMv6 and later.
Some IDCT renaming.
Shock addition of some documentation on how it all works.
Mirror fix from 1.39 on the trunk.
Debug
 Made DEBUG version compile again, earlier header shuffling was preventing it.
 Replaced the ' _ ' method of variadic macro emulation with more familiar double brackets for tracef().
 Eliminated IFDEBUG macro and just used #ifdef DEBUG/#endif or tracef() directly.
 Don't bother passing the line number and file name to exit() when in the non DEBUG case.

Version 1.38, 1.35.2.8. Tagged as 'SprExtend-1_38-1_35_2_8'
@
text
@d192 4
a195 1

@


4.3.2.5
log
@New jerror.h taken from IJG8b.
Swap to using JERR_ numbers, deleted E_ numbers.
Modify genjhdr to pass some defines to the assembler code, so jdcolor can clarify use of DCTSIZE and DCTSIZE2.
Added chart of possible subsampling ratios to documentation.

Version 1.38, 1.35.2.9. Tagged as 'SprExtend-1_38-1_35_2_9'
@
text
@d33 1
a45 2
  if (htbl == NULL) return; /* Not defined */

d204 17
a225 1
  const int *natural_order = cinfo->natural_order;
d241 1
a241 1
  /* Descale and output the DC coefficient (assumes natural_order[0] = 0) */
d257 1
a257 1
      block[natural_order[k]] = (JCOEF) (((JCOEF) s) * quanttbl->quantval[k]);
@


4.3.2.6
log
@Huffman decode adjusted to accept quantisation tables of 16 or 32 bit values (though use of LDAH macro).
IJG 8b uses UINT16 values now, but there's no measurable speed difference despite one/two extra instructions per AC component.

Version 1.38, 1.35.2.10. Tagged as 'SprExtend-1_38-1_35_2_10'
@
text
@d80 2
a81 2
      htbl->valoffset[l] = p;      /* huffval[] index of 1st sym of code len l */
      htbl->valoffset[l] -= huffcode[p]; /* subtract value in old 'mincode' table, for speed later */
d167 1
a167 1
  p = (int) (htbl->valoffset[l] + (code /* - htbl->mincode[l] */));
d192 1
a192 1
  p = (int) (htbl->valoffset[l] + (code /* - htbl->mincode[l] */));
d210 1
a210 1
  const char *natural_order = cinfo->natural_order;
@


4.3.2.7
log
@Migrate to jdmarker from IJG 8b.
ERREXIT's in jdhuff now use JERR_ numbers (missed earlier because it's switched out by default).

Version 1.38, 1.35.2.12. Tagged as 'SprExtend-1_38-1_35_2_12'
@
text
@d36 1
a36 1
LOCAL(void)
d135 2
a136 1
        ERREXIT1(cinfo, JTRC_PARMLESS_MARKER, c);
d189 1
a189 1
    ERREXIT(cinfo, JWRN_HUFF_BAD_CODE);
a323 2
  int i;

d326 2
a327 8

  /* Calculate shortcuts for any huffman tables present. */
  for (i = 0; i < NUM_HUFF_TBLS; i++)
  {
    fix_huff_tbl(cinfo, cinfo->dc_huff_tbl_ptrs[i]);
    fix_huff_tbl(cinfo, cinfo->ac_huff_tbl_ptrs[i]);
    tracef(("Huffman table %i fixed.\n", i));
  }
a330 13

  cinfo->current_huff_pointer = -1; /* no band currently loaded. */
}


/*
 * Module initialization routine for Huffman entropy decoding.
 */

GLOBAL(void)
jinit_huff_decoder (j_decompress_ptr cinfo)
{
  UNUSED(cinfo);
@


4.3.2.8
log
@Reorganise data input.
Fill in INPUT_VARS and INPUT_SYNC so it uses register variables.
Make use of data source manager (cinfo->src).
Calculate bytes_in_buffer when restoring the huffman position.
Swap process_restart() for the one now in jdmarker.

Version 1.38, 1.35.2.13. Tagged as 'SprExtend-1_38-1_35_2_13'
@
text
@a32 4

/* The buffer contains the entire file */
#define JGETC(cinfo) (int) ((cinfo)->src->bytes_in_buffer ? *(cinfo)->src->next_input_byte++ : 255)

@


4.3.2.9
log
@Abstract entropy decoding.
Currently still only support Huffman, but now agnostic, there are two functions 'decode_mcu()' which does the full DC+AC decode of a full MCU worth of data, and 'skip_mcu()' which just does DC and consumes but discards the AC coefficients.
Apply fix from 1.40 trunk version for monochrome output in a 8bpp greyscale mode.
Restore name of DCTFIX() macro to FIX(), no longer needed now the constituent parts are compiled seperately rather than #included.
Fix CFSIjpeg to assemble even though it doesn't have a module base (the recently added 'relocatefn()' was breaking it).

Version 1.38, 1.35.2.14. Tagged as 'SprExtend-1_38-1_35_2_14'
@
text
@d99 1
a99 1
  is constructed by trying all 256 possibilities. */
d106 2
a107 2
      cinfo->s_entropy_decoder.bitstate.bits_left = 32;
      cinfo->s_entropy_decoder.bitstate.get_buffer = i << 24; /* fake the input bits */
d109 1
a109 1
      if (cinfo->s_entropy_decoder.bitstate.bits_left < 24) /* code longer than 8 bits */
d114 1
a114 1
        htbl->shortcut[i] = ((32 - cinfo->s_entropy_decoder.bitstate.bits_left) << 24) | h; /* remember size and value */
d117 2
a118 2
    cinfo->s_entropy_decoder.bitstate.bits_left = 0;
    cinfo->s_entropy_decoder.bitstate.get_buffer = 0;
d129 1
a129 1
  while (nbits > cinfo->s_entropy_decoder.bitstate.bits_left) {
d132 3
a134 3
    cinfo->s_entropy_decoder.bitstate.get_buffer <<= 8;
    cinfo->s_entropy_decoder.bitstate.get_buffer |= c;
    cinfo->s_entropy_decoder.bitstate.bits_left += 8;
d143 2
a144 2
  cinfo->s_entropy_decoder.bitstate.bits_left -= nbits;
  result = ((int) (cinfo->s_entropy_decoder.bitstate.get_buffer >> cinfo->s_entropy_decoder.bitstate.bits_left)) & ((1 << nbits) - 1);
a147 8
/* Figure F.12: extend sign bit */

/* NB: on some compilers this will only work for s > 0 */

#define huff_EXTEND(x, s)       ((x) < (1 << ((s)-1)) ? \
                                 (x) + (-1 << (s)) + 1 : \
                                 (x))

d150 3
a152 3
#define get_bit(cinfo)  (cinfo->s_entropy_decoder.bitstate.bits_left ? \
        ((int)(cinfo->s_entropy_decoder.bitstate.get_buffer >> (--cinfo->s_entropy_decoder.bitstate.bits_left))) & 1 : \
        get_bits(cinfo, 1))
d200 8
d209 1
a209 2
decode_one_block (j_decompress_ptr cinfo, JBLOCK block, JHUFF_TBL *dctbl, JHUFF_TBL *actbl,
                  JQUANT_TBL *quanttbl, JCOEF *last_dc_val)
d255 1
a255 2
skip_one_block (j_decompress_ptr cinfo, JBLOCK block, JHUFF_TBL *dctbl, JHUFF_TBL *actbl,
                JQUANT_TBL *quanttbl, JCOEF *last_dc_val)
d257 1
a257 2
 * but only the DC entry of block[0] need be produced.
 */
a270 2
  /* Descale and output the DC coefficient (assumes natural_order[0] = 0) */
  block[0] = (JCOEF) (((JCOEF) s) * quanttbl->quantval[0]);
d291 4
a294 4
LOCAL(void)
huff_decode_blocks (j_decompress_ptr cinfo, JBLOCK block,
                    JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JQUANT_TBL *quanttbl,
                    JCOEF *last_dc_val, int nblocks)
d304 1
a304 1
LOCAL(void)
d306 2
a307 2
                   JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JQUANT_TBL *quanttbl,
                   JCOEF *last_dc_val, int nblocks)
d311 1
a311 2
    skip_one_block(cinfo, block, dctbl, actbl, quanttbl, last_dc_val);
    block = block + DCTSIZE2;
d314 2
a319 150
LOCAL(void)
save_huff_stream (j_decompress_ptr cinfo, entropy_state *h)
/* Save the current state of the huffman stream, so that we could
 * restart reading at this point.
 */
{
  int i;
  assert(cinfo->s_entropy_decoder.bitstate.bits_left < 32, ERROR_BAD_JPEG);
  assert(cinfo->s_entropy_decoder.bitstate.bits_left >= 0, ERROR_BAD_JPEG);
  assert(cinfo->jpeg_buffer < cinfo->s_source_mgr.next_input_byte, ERROR_FATAL);
  assert(cinfo->s_source_mgr.next_input_byte < &cinfo->jpeg_buffer[cinfo->jpeg_size], ERROR_FATAL);

  h->bit_pointer = ((cinfo->s_source_mgr.next_input_byte - cinfo->jpeg_buffer) << 5) |
                   cinfo->s_entropy_decoder.bitstate.bits_left;
  h->get_buffer = cinfo->s_entropy_decoder.bitstate.get_buffer;
  for (i = 0; i < MAX_COMPS_IN_SCAN; i++)
    h->last_dc_val[i] = cinfo->s_entropy_decoder.saved.last_dc_val[i];
  h->restarts_to_go = cinfo->s_entropy_decoder.restarts_to_go;
  h->next_restart_num = cinfo->marker->next_restart_num;
}

LOCAL(void)
restore_huff_stream (j_decompress_ptr cinfo, entropy_state *h)
/* Reset a save state of the huffman stream, so that we can continue reading. */
{
  int i;

  cinfo->s_source_mgr.next_input_byte = cinfo->jpeg_buffer + (h->bit_pointer >> 5);
  cinfo->s_source_mgr.bytes_in_buffer = cinfo->jpeg_size - (h->bit_pointer >> 5);
  cinfo->s_entropy_decoder.bitstate.bits_left = h->bit_pointer & 31;
  cinfo->s_entropy_decoder.bitstate.get_buffer = h->get_buffer;
  for (i = 0; i < MAX_COMPS_IN_SCAN; i++)
    cinfo->s_entropy_decoder.saved.last_dc_val[i] = h->last_dc_val[i];
  cinfo->s_entropy_decoder.restarts_to_go = h->restarts_to_go;
  cinfo->marker->next_restart_num = h->next_restart_num;
}

METHODDEF(boolean)
skip_mcu (j_decompress_ptr cinfo, JBLOCKROW *row)
{
  JBLOCK *block = (JBLOCK *)row;
  int ci;
  
  if (cinfo->restart_interval)
  {
    if (cinfo->s_entropy_decoder.restarts_to_go == 0)
    {
      if (!cinfo->marker->read_restart_marker(cinfo))
        ERREXIT(cinfo, JTRC_RST);
      cinfo->s_entropy_decoder.bitstate.get_buffer = 0; /* Flush the remaining bits */
      cinfo->s_entropy_decoder.bitstate.bits_left = 0;
      cinfo->s_entropy_decoder.restarts_to_go = cinfo->restart_interval;
      for (ci = 0; ci < MAX_COMPS_IN_SCAN; ci++)
        cinfo->s_entropy_decoder.saved.last_dc_val[ci] = 0;
    }
    cinfo->s_entropy_decoder.restarts_to_go--;
  }

  if (cinfo->blocks_in_MCU == 1)
  {
    JHUFF_TBL  *ydc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
    JHUFF_TBL  *yac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
    JQUANT_TBL *yquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];

    huff_skip_blocks(cinfo, block[1], ydc, yac, yquanttbl,
                     &cinfo->s_entropy_decoder.saved.last_dc_val[0], 1);
  }
  else
  {
    JHUFF_TBL  *ydc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
    JHUFF_TBL  *yac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
    JQUANT_TBL *yquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];
    JHUFF_TBL  *udc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[1]->dc_tbl_no];
    JHUFF_TBL  *uac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[1]->ac_tbl_no];
    JQUANT_TBL *uquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[1]->quant_tbl_no];
    JHUFF_TBL  *vdc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[2]->dc_tbl_no];
    JHUFF_TBL  *vac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[2]->ac_tbl_no];
    JQUANT_TBL *vquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[2]->quant_tbl_no];

    /* Variable amounts of Y */
    huff_skip_blocks(cinfo, block[1], ydc, yac, yquanttbl,
                     &cinfo->s_entropy_decoder.saved.last_dc_val[0], cinfo->blocks_in_MCU - 2);

    /* And always U & V */
    huff_skip_blocks(cinfo, block[5], udc, uac, uquanttbl,
                     &cinfo->s_entropy_decoder.saved.last_dc_val[1], 1);
    huff_skip_blocks(cinfo, block[6], vdc, vac, vquanttbl,
                     &cinfo->s_entropy_decoder.saved.last_dc_val[2], 1);
  }

  return FALSE;
}

METHODDEF(boolean)
decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *row)
{
  JBLOCK *block = (JBLOCK *)row;
  int ci;

  if (cinfo->restart_interval)
  {
    if (cinfo->s_entropy_decoder.restarts_to_go == 0)
    {
      if (!cinfo->marker->read_restart_marker(cinfo))
        ERREXIT(cinfo, JTRC_RST);
      cinfo->s_entropy_decoder.bitstate.get_buffer = 0; /* Flush the remaining bits */
      cinfo->s_entropy_decoder.bitstate.bits_left = 0;
      cinfo->s_entropy_decoder.restarts_to_go = cinfo->restart_interval;
      for (ci = 0; ci < MAX_COMPS_IN_SCAN; ci++)
        cinfo->s_entropy_decoder.saved.last_dc_val[ci] = 0;
    }
    cinfo->s_entropy_decoder.restarts_to_go--;
  }

  if (cinfo->blocks_in_MCU == 1)
  {
    JHUFF_TBL  *ydc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
    JHUFF_TBL  *yac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
    JQUANT_TBL *yquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];

    huff_decode_blocks(cinfo, block[1], ydc, yac, yquanttbl,
                       &cinfo->s_entropy_decoder.saved.last_dc_val[0], 1);
  }
  else
  {
    JHUFF_TBL  *ydc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
    JHUFF_TBL  *yac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
    JQUANT_TBL *yquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];
    JHUFF_TBL  *udc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[1]->dc_tbl_no];
    JHUFF_TBL  *uac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[1]->ac_tbl_no];
    JQUANT_TBL *uquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[1]->quant_tbl_no];
    JHUFF_TBL  *vdc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[2]->dc_tbl_no];
    JHUFF_TBL  *vac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[2]->ac_tbl_no];
    JQUANT_TBL *vquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[2]->quant_tbl_no];

    /* Variable amounts of Y */
    huff_decode_blocks(cinfo, block[1], ydc, yac, yquanttbl,
                       &cinfo->s_entropy_decoder.saved.last_dc_val[0], cinfo->blocks_in_MCU - 2);

    /* And always U & V */
    huff_decode_blocks(cinfo, block[5], udc, uac, uquanttbl,
                       &cinfo->s_entropy_decoder.saved.last_dc_val[1], 1);
    huff_decode_blocks(cinfo, block[6], vdc, vac, vquanttbl,
                       &cinfo->s_entropy_decoder.saved.last_dc_val[2], 1);
  }

  return FALSE;
}


d324 1
a324 1
METHODDEF(void)
d328 3
a330 1
  struct jpeg_entropy_decoder *entropy = &cinfo->s_entropy_decoder;
d340 2
a341 4
  /* Initialize bitread state variables */
  entropy->bitstate.bits_left = 0;
  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
  entropy->insufficient_data = FALSE;
d343 1
a343 2
  /* Initialize restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
d354 1
a354 6
  cinfo->entropy = &cinfo->s_entropy_decoder; /* Statics rather than malloc */
  cinfo->entropy->save_state = (void (*)(j_decompress_ptr, entropy_state *))RELOCATE(save_huff_stream);
  cinfo->entropy->restore_state = (void (*)(j_decompress_ptr, entropy_state *))RELOCATE(restore_huff_stream);
  cinfo->entropy->start_pass = (void (*)(j_decompress_ptr))RELOCATE(start_pass_huff_decoder);
  cinfo->entropy->skip_mcu = (boolean (*)(j_decompress_ptr, JBLOCKROW *))RELOCATE(skip_mcu);
  cinfo->entropy->decode_mcu = (boolean (*)(j_decompress_ptr, JBLOCKROW *))RELOCATE(decode_mcu);
@


4.3.2.10
log
@Push recent changes on the trunk to the IJG8b branch.
Tested briefly, still works.

Version 1.38, 1.35.2.15. Tagged as 'SprExtend-1_38-1_35_2_15'
@
text
@d353 1
a353 1
  cinfo->s_entropy_decoder.bitstate.bits_left = h->bit_pointer & 31; /* 27b word#, 5b bit# */
@


4.2
log
@A couple of 32-bit fixes.
Used to interpret negative translation table pointers as "none"; now just 0
as per documentation.
Plotting 16bpp sprites into 32bpp modes now correctly sets the 3 least
significant bits of each channel - used to be set to 0 due to a typo.
Build option (currently set to on) to use SMULL instructions.

Version 1.11. Tagged as 'SprExtend-1_11'
@
text
@a32 13
#ifndef assert
  /* Stolen from c.PutScaled */
  #define assert(x, y) do_assert(__LINE__, x, y, 0)
  static void do_assert(int line, BOOL arg, int error, char *describe)
  {
    if (arg == 0)
    {
      tracef("ASSERTION FAILED (line %i): %s\n" _ line _ describe);
      exit(error);
    }
  }
#endif

@


4.1
log
@Initial revision
@
text
@d33 11
a43 8

/* Static variables to avoid passing 'round extra parameters */

#if 0
static decompress_info_ptr dcinfo;

static INT32 get_buffer;        /* current bit-extraction buffer */
static int bits_left;           /* # of unused bits in it */
a44 2
/* These have been moved to the cinfo structure, so that there are no
static variables. */
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

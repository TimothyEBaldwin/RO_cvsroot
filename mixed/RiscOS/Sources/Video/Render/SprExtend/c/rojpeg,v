head	4.36;
access;
symbols
	SprExtend-1_83:4.36
	SprExtend-1_82:4.36
	SprExtend-1_81:4.36
	SprExtend-1_80:4.36
	SprExtend-1_79:4.36
	SprExtend-1_78:4.35
	SprExtend-1_77:4.35
	SprExtend-1_76:4.35
	SprExtend-1_75:4.34
	SprExtend-1_74:4.33
	SprExtend-1_73:4.32
	SprExtend-1_72:4.31
	SprExtend-1_71-nocfsi:4.30
	SprExtend-1_71:4.29
	SprExtend-1_70-tracef:4.28
	SprExtend-1_70-headers:4.27
	SprExtend-1_70:4.26
	SprExtend-1_69:4.25
	SprExtend-1_68:4.25
	SprExtend-1_67:4.25
	SprExtend-1_66:4.25
	SprExtend-1_65:4.25
	SprExtend-1_64:4.25
	SprExtend-1_63:4.25
	SprExtend-1_62:4.25
	SprExtend-1_61:4.25
	SprExtend-1_60:4.25
	SprExtend-1_59:4.25
	SprExtend-1_58:4.25
	SprExtend-1_57:4.25
	SprExtend-1_56:4.25
	SprExtend-1_55:4.25
	SprExtend-1_54:4.24
	SprExtend-1_53:4.23
	SprExtend-1_52:4.23
	SprExtend-1_51:4.21
	SprExtend-1_50:4.21
	SprExtend-1_38-1_35_2_16:4.17.2.14
	SprExtend-1_49:4.20
	SprExtend-1_48:4.20
	SprExtend-1_47:4.20
	SprExtend-1_38-1_35_2_15:4.17.2.14
	SprExtend-1_46:4.20
	SprExtend-1_45:4.19
	SprExtend-1_44:4.19
	SprExtend-1_43:4.19
	SprExtend-1_42:4.19
	SprExtend-1_41:4.19
	SprExtend-1_38-1_35_2_14:4.17.2.13
	SprExtend-1_40:4.19
	SprExtend-1_38-1_35_2_13:4.17.2.12
	SprExtend-1_38-1_35_2_12:4.17.2.11
	SprExtend-1_38-1_35_2_11:4.17.2.10
	SprExtend-1_38-1_35_2_10:4.17.2.9
	SprExtend-1_38-1_35_2_9:4.17.2.8
	SprExtend-1_38-1_35_2_8:4.17.2.7
	SprExtend-1_39:4.18
	SprExtend-1_38-1_35_2_7:4.17.2.6
	SprExtend-1_38-1_35_2_6:4.17.2.5
	SprExtend-1_38-1_35_2_5:4.17.2.4
	SprExtend-1_38-1_35_2_4:4.17.2.3
	SprExtend-1_38-1_35_2_3:4.17.2.2
	SprExtend-1_38-1_35_2_2:4.17.2.1
	SprExtend-1_38-1_35_2_1:4.17.2.1
	MigrateIJG8b:4.17.0.2
	SprExtend-1_38:4.17
	SprExtend-1_37:4.16
	SprExtend-1_36:4.15
	SprExtend-1_35:4.14
	SprExtend-1_34:4.13
	SprExtend-1_33:4.12
	SprExtend-1_32:4.11
	SprExtend-1_31:4.10
	SprExtend-1_30:4.10
	SprExtend-1_29:4.9
	SprExtend-1_28:4.9
	SprExtend-1_27:4.8
	SprExtend-1_26:4.7
	SprExtend-1_25:4.7
	SprExtend-1_24:4.7
	SprExtend-1_23:4.6
	SprExtend-1_22:4.5
	SprExtend-1_21:4.5
	SprExtend-1_20:4.5
	SprExtend-1_19:4.5
	SprExtend-1_18:4.5
	SprExtend-1_17:4.5
	RO_5_07:4.5
	SprExtend-1_16:4.5
	SprExtend-1_15:4.5
	SprExtend-1_14:4.4
	SprExtend-1_13:4.4
	SprExtend-1_12:4.4
	SprExtend-1_11:4.4
	SprExtend-1_10:4.3
	SprExtend-1_09:4.3
	SprExtend-1_08:4.3
	dellis_autobuild_BaseSW:4.2
	SprExtend-1_07:4.2
	SprExtend-1_06:4.2
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.3
	SprExtend-1_05:4.2
	Ursula_merge:4.2
	nturton_SprExtend-1_04:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.36
date	2017.02.28.23.06.23;	author rsprowson;	state Exp;
branches;
next	4.35;
commitid	MQfaLocMT9fUZLHz;

4.35
date	2016.05.21.14.16.32;	author rool;	state Exp;
branches;
next	4.34;
commitid	xdjBCBYna4x7am7z;

4.34
date	2016.05.21.14.13.15;	author rool;	state Exp;
branches;
next	4.33;
commitid	2yhdQIv5WwwZ8m7z;

4.33
date	2016.05.21.14.10.17;	author rool;	state Exp;
branches;
next	4.32;
commitid	RAjaHu2jGaPW7m7z;

4.32
date	2016.05.21.14.07.28;	author rool;	state Exp;
branches;
next	4.31;
commitid	rlMVSSOn1jz07m7z;

4.31
date	2016.05.21.14.03.49;	author rool;	state Exp;
branches;
next	4.30;
commitid	4BquZHousteH5m7z;

4.30
date	2016.05.21.13.48.16;	author rool;	state Exp;
branches;
next	4.29;
commitid	F2CfxJ1XTlg50m7z;

4.29
date	2016.05.21.13.44.39;	author rool;	state Exp;
branches;
next	4.28;
commitid	ZDqmsyNiMhv6Zl7z;

4.28
date	2016.05.21.13.37.18;	author rool;	state Exp;
branches;
next	4.27;
commitid	TvdqzFBJfCe7Wl7z;

4.27
date	2016.05.21.13.32.20;	author rool;	state Exp;
branches;
next	4.26;
commitid	yTqS85yKh7k8Ul7z;

4.26
date	2016.03.12.10.25.11;	author rool;	state Exp;
branches;
next	4.25;
commitid	cdOKhcORM5Eb8lYy;

4.25
date	2013.10.07.00.39.09;	author jlee;	state Exp;
branches;
next	4.24;
commitid	HcUKy3PafwqToi8x;

4.24
date	2013.09.10.23.18.33;	author jlee;	state Exp;
branches;
next	4.23;
commitid	rBPHyiuHG965NW4x;

4.23
date	2013.08.07.23.39.05;	author jlee;	state Exp;
branches;
next	4.22;
commitid	OCG6UovOcK9SZz0x;

4.22
date	2013.08.06.23.16.23;	author jlee;	state Exp;
branches;
next	4.21;
commitid	z9XOph7zDZQ2Ur0x;

4.21
date	2012.07.28.15.23.42;	author rsprowson;	state Exp;
branches;
next	4.20;
commitid	b5jdybqzJ3Wdjlew;

4.20
date	2011.08.05.00.17.47;	author jlee;	state Exp;
branches;
next	4.19;
commitid	M4NYP50KHXLUNfuv;

4.19
date	2011.02.13.17.40.42;	author rsprowson;	state Exp;
branches;
next	4.18;

4.18
date	2011.01.11.08.10.57;	author rsprowson;	state Exp;
branches;
next	4.17;

4.17
date	2010.12.23.09.00.57;	author rsprowson;	state Exp;
branches
	4.17.2.1;
next	4.16;

4.16
date	2010.12.22.08.22.32;	author rsprowson;	state Exp;
branches;
next	4.15;

4.15
date	2010.11.14.14.52.02;	author rsprowson;	state Exp;
branches;
next	4.14;

4.14
date	2010.11.14.10.42.37;	author rsprowson;	state Exp;
branches;
next	4.13;

4.13
date	2010.11.06.17.29.37;	author rsprowson;	state Exp;
branches;
next	4.12;

4.12
date	2010.10.17.09.01.35;	author rsprowson;	state Exp;
branches;
next	4.11;

4.11
date	2010.10.13.20.26.21;	author rsprowson;	state Exp;
branches;
next	4.10;

4.10
date	2010.09.29.21.05.30;	author rsprowson;	state Exp;
branches;
next	4.9;

4.9
date	2010.09.25.12.19.23;	author rsprowson;	state Exp;
branches;
next	4.8;

4.8
date	2010.09.19.09.11.17;	author rsprowson;	state Exp;
branches;
next	4.7;

4.7
date	2010.09.01.20.48.54;	author rsprowson;	state Exp;
branches;
next	4.6;

4.6
date	2010.08.29.08.36.09;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2003.04.08.21.19.09;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2002.11.06.13.20.30;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2001.05.15.10.57.01;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.17.51.09;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.45.05;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.17.2.1
date	2011.01.04.21.18.07;	author rsprowson;	state Exp;
branches;
next	4.17.2.2;

4.17.2.2
date	2011.01.04.21.37.00;	author rsprowson;	state Exp;
branches;
next	4.17.2.3;

4.17.2.3
date	2011.01.04.21.45.30;	author rsprowson;	state Exp;
branches;
next	4.17.2.4;

4.17.2.4
date	2011.01.04.22.13.09;	author rsprowson;	state Exp;
branches;
next	4.17.2.5;

4.17.2.5
date	2011.01.09.10.42.59;	author rsprowson;	state Exp;
branches;
next	4.17.2.6;

4.17.2.6
date	2011.01.09.10.56.44;	author rsprowson;	state Exp;
branches;
next	4.17.2.7;

4.17.2.7
date	2011.01.13.21.12.20;	author rsprowson;	state Exp;
branches;
next	4.17.2.8;

4.17.2.8
date	2011.01.22.17.58.30;	author rsprowson;	state Exp;
branches;
next	4.17.2.9;

4.17.2.9
date	2011.01.22.18.01.50;	author rsprowson;	state Exp;
branches;
next	4.17.2.10;

4.17.2.10
date	2011.01.29.10.03.39;	author rsprowson;	state Exp;
branches;
next	4.17.2.11;

4.17.2.11
date	2011.01.29.10.05.56;	author rsprowson;	state Exp;
branches;
next	4.17.2.12;

4.17.2.12
date	2011.02.05.09.56.54;	author rsprowson;	state Exp;
branches;
next	4.17.2.13;

4.17.2.13
date	2011.02.15.20.58.02;	author rsprowson;	state Exp;
branches;
next	4.17.2.14;

4.17.2.14
date	2011.08.06.10.44.32;	author rsprowson;	state Exp;
branches;
next	;
commitid	gAycmEnWp5AVeruv;

4.1.1.1
date	96.11.05.09.45.05;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.41.10;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.57.40;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.20.20;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.36
log
@Fix to dpcm calculation leading to divide by zero in !Draw
For JPEGs specified in dots-per-cm some dodgy looking bytewise fractions and missing brackets meant the x and y densities always came out as zero, leading to an abort in !Draw when it asks JPEG_[File]Info for this to convert to internal units.
Correct the calculation and split it onto 2 lines for readability.

Tested with a sample JPEG at 37dpcm (~93dpi).

Version 1.79. Tagged as 'SprExtend-1_79'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* rojpeg.c - JPEG for use within RISC OS */

#include <stdlib.h>
#include <stdint.h>
#include "swis.h"
#include "Global/VduExt.h"
#include "Interface/HighFSI.h"
#include "commondefs.h"
#include "rojpeg.h"

/**************************************************************************
*                                                                         *
*    JPEG utility functions.                                              *
*                                                                         *
**************************************************************************/

static int palette_is_grey(int *palette, int entries); /* In c.PutScaled */

static void check_jpeg_workspace(asm_workspace *wp, int jpeg_ws_size)
/* Check (and adjust) the workspace needed */
{
  j_decompress_ptr cinfo = wp->jpeg_info_ptr;

  if (!cinfo)
  {
    dprintf(("", "Requesting %x bytes of workspace\n", jpeg_ws_size));
    cinfo = area_resize(AREA_WKSP0, NULL, jpeg_ws_size);
    assert(cinfo != NULL, ERROR_NO_MEMORY);
    wp->jpeg_info_ptr = cinfo;                   
    cinfo->error_code = -1;                      /* mark the workspace entirely uninitialised */
    cinfo->workspace_size = jpeg_ws_size;        /* at least that big, malloc might have rounded up */
  }
  else
  {
    if (jpeg_ws_size)                            /* need more */
    {
      void *area;

      dprintf(("", "Requesting %x extra bytes of workspace\n", jpeg_ws_size));
      jpeg_ws_size = jpeg_ws_size + cinfo->workspace_size;
      area = area_resize(AREA_WKSP0, &cinfo->workspace_size, jpeg_ws_size);
      assert(area != NULL, ERROR_NO_MEMORY);
      cinfo->error_code = -1;                    /* mark the workspace entirely uninitialised */
    }
  }
}

static int jpeg_decompressor_opts(j_decompress_ptr cinfo, asm_workspace *wp)
/* Deduce the decompressor options */
{
  int opt = 0;
  
  /* JPEG decompression options */
  if ((wp->save_xadd - wp->save_xdiv) * 6 <= wp->save_xdiv &&
      (wp->save_yadd - wp->save_ydiv) * 6 <= wp->save_ydiv)
    opt |= jopt_DC_ONLY; /* postage stamp - go faster, do only DC values of JPEG tiles */

  /* Starting assumption that the blitter wants 32bpp &BGR */
  cinfo->pixelformat = PixelFormat_32bpp;

  /* If colour mapping is in use, only produce ordinary 32bpp output. TODO - Improve on
   * this, e.g. could call colour mapping before error diffusion.
   */
  if (wp->TTRType != TTRType_ColourMap)
  {
    if ((wp->BPP < 4))
    {
      opt |= jopt_GREY; /* greyscale if 4bpp or less */
      if ((wp->save_PdriverIntercept & 2) == 0) /* printing is not on */
      {
        wp->ColourTTR = 0; /* don't use trans table for 4bpp or less, results are naff */
        wp->TTRType = TTRType_None;
      }
    }

    if ((wp->BPP <=8) && (wp->dither_truecolour & 2))
    {
      opt |= jopt_DIFFUSE;
      wp->ColourTTR = 0;
      wp->TTRType = TTRType_None;
    }

    if (wp->BPP == 8)
    {
      int temp, size;
  
      _swix(ColourTrans_ReadPalette, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _IN(4) | _OUT(3),
                                     -1, -1, 0, 256*4, 0, &size); /* save palette into newtranstable area */
      dprintf(("", "need %x bytes for palette\n", size));
      _swix(ColourTrans_ReadPalette, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _IN(4),
                                     -1, -1, wp->newtranstable, size, 0); /* save palette into newtranstable area */
      temp = palette_is_grey(wp->newtranstable, size / sizeof(int));
      if (temp) opt |= jopt_GREY;
      if (temp == 2)
      {
        opt |= jopt_OUTBPP_8GREY;
        opt &= ~jopt_DIFFUSE;
      }
    }

    if ((wp->save_PdriverIntercept & 2) == 0 && (wp->dither_truecolour & 1)) /* printing is not on, dither is on */
    {
      int  size;
  
      if ((wp->dither_truecolour & 2) && wp->BPP < 16) /* error diffused dither, and paletted mode */
      {
#ifdef DEBUG
        int loop;
#endif
        dprintf(("", "trying new shiny 8BPP plotting technique\n"));
        _swix(ColourTrans_ReadPalette, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _IN(4) | _OUT(3),
                                       -1, -1, 0, 256*4, 0, &size); /* save palette into newtranstable area */
        dprintf(("", "need %x bytes for palette\n", size));
        _swix(ColourTrans_ReadPalette, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _IN(4),
                                       -1, -1, &(wp->newtranstable[0]), size, 0); /* save palette into newtranstable area */
        dprintf(("", "created palette at %x\n", &(wp->newtranstable[0])));
#ifdef DEBUG
        dprintf(("", "Read palette, palette entries are:-\n"));
        for(loop = 0;loop<size/4;loop++)
          dprintf(("", "Entry %d = %x\n", loop, wp->newtranstable[loop]));
#endif
        if (wp->BPP == 4)
        {
          if (palette_is_grey(wp->newtranstable, size / sizeof(int))) opt |= jopt_GREY; /* prefer grey please */
        }
        else if (wp->BPP == 8)
        {
          int temp;
  
          temp = palette_is_grey(wp->newtranstable, size / sizeof(int));
          if (temp) opt |= jopt_GREY; /* prefer grey please */
          if (temp == 2)
          {
            opt |= jopt_OUTBPP_8GREY; /* grey palette, demand output grey */
            opt &= ~jopt_DIFFUSE; /* don't dither grey */
          }
        }
      }
  
      if ((wp->BPP == 4) && !(wp->dither_truecolour & 2)) /* 4bpp, no error diffusion, prefer grey please */
        opt |= jopt_GREY; 
  
      if (wp->BPP == 8)
      {
        if ((wp->dither_truecolour & 2) && !(opt & jopt_OUTBPP_8GREY))
        {
          opt |= jopt_OUTBPP_8DITHER;                  /* full error diffusion */
          cinfo->error_code = -1;                      /* mark the workspace entirely uninitialised */
        }
        else
        {
          int modeflags;
  
          _swix(OS_ReadModeVariable, _INR(0,1) | _OUT(2), -1, VduExt_ModeFlags, &modeflags);
          if ((modeflags & ModeFlag_FullPalette) == 0)
            opt |= jopt_OUTBPP_8YUV; /* diffusion from YUV data to 64 entry VIDC1 palette direct */
        }
      }
      else if (wp->BPP == 16)
      {
        opt |= jopt_OUTBPP_16; /* request 16bpp with ordered dither */
      }

    }

    /* Pick a specific pixel format for the merged upsampler/colour converter */
    if (opt & (jopt_OUTBPP_16 | jopt_OUTBPP_8YUV | jopt_OUTBPP_8GREY))
    {
      cinfo->pixelformat = (int)compute_pixelformat(wp->ncolour, wp->modeflags, wp->Log2bpp);
    }
  }

#ifdef DEBUG
  dprintf(("", "After set up, options are:\n"));
  if (opt & jopt_GREY) dprintf(("", "   jopt_GREY\n"));
  if (opt & jopt_DC_ONLY) dprintf(("", "   jopt_DC_ONLY\n"));
  if (opt & jopt_INTERP_X) dprintf(("", "   jopt_INTERP_X\n"));
  if (opt & jopt_OUTBPP_8DITHER) dprintf(("", "   jopt_OUTBPP_8DITHER\n"));
  if (opt & jopt_OUTBPP_16) dprintf(("", "   jopt_OUTBPP_16\n"));
  if (opt & jopt_OUTBPP_8YUV) dprintf(("", "   jopt_OUTBPP_8YUV\n"));
  if (opt & jopt_DIFFUSE) dprintf(("", "   jopt_DIFFUSE\n"));
  if (opt & jopt_OUTBPP_8GREY) dprintf(("", "   jopt_OUTBPP_8GREY\n"));
#endif

  return opt;
}

/**************************************************************************
*                                                                         *
*    JPEG entry points.                                                   *
*                                                                         *
**************************************************************************/

typedef enum {			/* JPEG marker codes */
  M_SOF0  = 0xc0,		/* baseline */         
  M_SOF1  = 0xc1,		/* extended sequential, Huffman */
  M_SOF2  = 0xc2,		/* progressive, Huffman */
  M_SOF3  = 0xc3,		/* lossless, Huffman */
                 		                                             
  M_SOF5  = 0xc5,		/* differential sequential, Huffman */
  M_SOF6  = 0xc6,		/* differential progressive, Huffman */
  M_SOF7  = 0xc7,		/* differential lossless, Huffman */         

  M_JPG   = 0xc8,
  M_SOF9  = 0xc9,		/* extended sequential, arithmetic */
  M_SOF10 = 0xca,		/* progressive, arithmetic */                
  M_SOF11 = 0xcb,		/* lossless, arithmetic */                                                        
                 
  M_SOF13 = 0xcd,		/* differential sequential, arithmetic */
  M_SOF14 = 0xce,		/* differential progressive, arithmetic */   
  M_SOF15 = 0xcf,		/* differential lossless, arithmetic */    
                                                                           
  M_DHT   = 0xc4,
  
  M_DAC   = 0xcc,
  
  M_RST0  = 0xd0,
  M_RST1  = 0xd1,
  M_RST2  = 0xd2,
  M_RST3  = 0xd3,
  M_RST4  = 0xd4,
  M_RST5  = 0xd5,
  M_RST6  = 0xd6,
  M_RST7  = 0xd7,
  
  M_SOI   = 0xd8,
  M_EOI   = 0xd9,
  M_SOS   = 0xda,
  M_DQT   = 0xdb,
  M_DNL   = 0xdc,
  M_DRI   = 0xdd,
  M_DHP   = 0xde,
  M_EXP   = 0xdf,
  
  M_APP0  = 0xe0,
  M_APP1  = 0xe1,
  M_APP2  = 0xe2,
  M_APP3  = 0xe3,
  M_APP4  = 0xe4,
  M_APP5  = 0xe5,
  M_APP6  = 0xe6,
  M_APP7  = 0xe7,
  M_APP8  = 0xe8,
  M_APP9  = 0xe9,
  M_APP10 = 0xea,
  M_APP11 = 0xeb,
  M_APP12 = 0xec,
  M_APP13 = 0xed,
  M_APP14 = 0xee,
  M_APP15 = 0xef,
  
  M_JPG0  = 0xf0,
  M_JPG13 = 0xfd,
  M_COM   = 0xfe,
  
  M_TEM   = 0x01,
  
  M_ERROR = 0x100
} JPEG_MARKER;

#define BADSAMPFACTOR(f) ((f > MAX_SAMP_FACTOR) || (f & (f-1)) || !f ) \
                       /* Out of range          OR Not a power of 2 */
#define BADCOMPCOUNT(c) ((c != 1) && (c != 3) && (c != 4)) \
                       /* Grey        RGB/YUV     CMYK/CYYK */
#define BADDCTSIZE(d) ((d != DCTSIZE) && (d != 1)) \
                     /* Baseline          Lossless */
#define BADFILE(reason) {dprintf(("", "bad file %d", reason)); \
                         cinfo->error_code = reason; \
                         return reason;}
#define BADFILE1(reason,arg) {dprintf(("", "bad file %d %d", reason, arg)); \
                              cinfo->error_code = reason; \
                              cinfo->error_argument = arg; \
                              return reason;}

/*!
 * \param   cinfo Compression state structure
 * \param   buffer The image to consider, word aligned
 * \param   buffer_size Bytes there are in the image buffer
 * \param   xmin Left clipping boundary
 * \param   xmax Right clipping boundary
 * \param   width Overall JPEG width in pixels
 * \param   height Overall JPEG height in pixels
 * \param   options Plotting options found with jpeg_decompressor_opts() earlier
 * \details Initial setup stage prior to rending an image.
 * \return  Error code, or 0 for none.
 */
int jpeg_scan_file(j_decompress_ptr cinfo, const JOCTET *buffer, size_t buffer_size,
                          int xmin, int xmax, int width, int height, int options)
{
  int i;
  int vsamp, hsamp, mcu_height, mcu_width;
  size_t huff_pointers_size;

  dprintf(("", "jpeg_scan_file cinfo=0x%x buffer=0x%x buffer_size=%i xmin=%i xmax=%i width=%i height=%i\n",
          (int)cinfo, (int)buffer, buffer_size, xmin, xmax, width, height));
  dprintf(("", "options=%i workspace_size %x\n", options, cinfo->workspace_size));

  if (xmin < 0) xmin = 0; /* xmax will be clipped to image_width, when we know it. */
  if (options & (jopt_OUTBPP_8DITHER | jopt_OUTBPP_8YUV))
  {
    xmin -= 16; /* cos errors can diffuse forwards a little - clipped to 0 later */
    if (xmin < 0) xmin = 0;
    xmin &= ~15; /* round down to multiple of 16 - needed by dithering */
    xmax += 16; /* cos errors can diffuse backwards a little - clipped to image width later */
  }

  /* Look to see if this is precisely the same JPEG file as last time */
  if (  cinfo->error_code == 0                                             /* check for very first time, or for error last time */
     && cinfo->jpeg_user_buffer == buffer                                  /* check for image in same place */
     && cinfo->jpeg_user_buffer_size == buffer_size                        /* check length unchanged */
     && (width == -1 || cinfo->image_width == width)                       /* width OK */
     && (height == -1 || cinfo->image_height == height)                    /* height OK */
     && cinfo->check1 == ((int*)buffer)[buffer_size/(2*4)]                 /* Random checks on data - the /4 gets us down to char offsets */
     && cinfo->check2 == ((int*)buffer)[buffer_size/4 - buffer_size/(4*4)] /* we check a word half-way through, and two later on */
     && cinfo->check3 == ((int*)buffer)[buffer_size/4 - buffer_size/(8*4)] /* any change will perturb the whole file - we trust! */
     && cinfo->orgoptions == options
     )
  {
    dprintf(("", "This looks like the same JPEG file as last time.\n"));
    if (xmax > cinfo->image_width) xmax = cinfo->image_width;
    if (xmin < cinfo->xmin || xmax > cinfo->xmax) cinfo->current_huff_pointer = -1; /* no band sufficiently loaded */
    cinfo->xmin = xmin; /* might need more, or less, than last time */
    cinfo->xmax = xmax;

    dprintf(("", "Exit jpeg_scan_file OK\n"));
    return 0;
  }

  /* Step 1: allocate and initialize JPEG decompression object */

  /* Errors are handled inline with the various macros in jerror.h, so there
   * is no call to jpeg_std_error() since nothing uses the function pointers
   * in cinfo->err.
   */

  /* If called for the first time, initialise the table32k pointer. */
  if (cinfo->error_code < 0) cinfo->table32k = NULL;

  /* Now we can initialize the JPEG decompression object. */
  jpeg_create_decompress(cinfo);

  /* Remember key facts about this JPEG, to hope for repeated calls */
  cinfo->check1 = ((int*)buffer)[buffer_size/(2*4)];
  cinfo->check2 = ((int*)buffer)[buffer_size/4 - buffer_size/(4*4)];
  cinfo->check3 = ((int*)buffer)[buffer_size/4 - buffer_size/(8*4)];
  cinfo->jpeg_user_buffer = buffer;
  cinfo->jpeg_user_buffer_size = buffer_size;

  /* Step 2: specify data source (from memory) */

  jpeg_mem_src(cinfo, (unsigned char *)buffer, (unsigned long)buffer_size);
  
  /* Step 3: read file parameters with jpeg_read_header() */

  (void) jpeg_read_header(cinfo, TRUE);
  /* We can ignore the return value from jpeg_read_header since
   * the whole image is in memory so suspension is never needed.
   */

#if defined(D_ARITH_CODING_SUPPORTED) || defined(D_PROGRESSIVE_SUPPORTED)
  /* Step 3a: transcode progressive and arithmetic into baseline */
  if (cinfo->progressive_mode || cinfo->arith_code)
  {
    jpegtrans_make_baseline(cinfo, &buffer, &buffer_size);
  }
#endif  
  cinfo->jpeg_buffer = buffer;
  cinfo->jpeg_buffer_size = buffer_size;

  /* Step 4: set parameters for decompression */

  cinfo->dct_method = JDCT_IFAST; /* The only method compiled in */
  cinfo->do_fancy_upsampling = FALSE; /* So merged upsampling happens */
  cinfo->orgoptions = cinfo->options = options; /* Contains colour conversion options */
  cinfo->out_color_space = JCS_RGB; /* Process everything as though RGB */

  /* Step 5: Start decompressor */

  (void) jpeg_start_decompress(cinfo);
  /* We can ignore the return value since
   * the whole image is in memory so suspension is never needed.
   */

  /* Adjust clipping box & opts now dimensions are known */ 
  if (xmax > cinfo->image_width) xmax = cinfo->image_width;
  if (xmin > xmax) xmin = xmax; /* guard against silly input */
  cinfo->xmin = xmin;
  cinfo->xmax = xmax;

  vsamp = cinfo->max_v_samp_factor;
  hsamp = cinfo->max_h_samp_factor;
  mcu_height = cinfo->block_size * vsamp; /* Scan lines */
  mcu_width = cinfo->block_size * hsamp; /* Pixels */
  dprintf(("", "MCUs are %dx%d pixels\n", mcu_width, mcu_height));

  /* Check various limitations of our code */
  if (BADCOMPCOUNT(cinfo->num_components)) BADFILE(JERR_COMPONENT_COUNT);
  if (cinfo->data_precision != BITS_IN_JSAMPLE) BADFILE1(JERR_BAD_PRECISION, cinfo->data_precision);
  if (BADSAMPFACTOR(hsamp) || BADSAMPFACTOR(vsamp)) BADFILE1(JERR_BAD_SAMPLING, (hsamp << 8) | vsamp);
  if (cinfo->image_width != width && width != -1) BADFILE1(JERR_IMAGE_TOO_BIG, cinfo->image_width);
  if (cinfo->image_height != height && height != -1) BADFILE1(JERR_IMAGE_TOO_BIG, cinfo->image_height);
  if (BADDCTSIZE(cinfo->block_size)) BADFILE1(JERR_BAD_DCTSIZE, cinfo->block_size);

  /* Allocate the array of pointers into the entropy stream */
  i = (cinfo->block_size != DCTSIZE) ? 0 : 3;
  cinfo->l2_mcu_width  = i +
                         ((hsamp == 4) ? hsamp - 2 : hsamp - 1); /* log2 of MCU width 1/2/4 -> 0/1/2 */
  cinfo->l2_mcu_height = i +
                         ((vsamp == 4) ? vsamp - 2 : vsamp - 1); /* log2 of MCU height 1/2/4 -> 0/1/2 */
  huff_pointers_size = sizeof(huff_pointer) * ((cinfo->image_height + mcu_height - 1) / mcu_height); /* Bytes */
  cinfo->huff_pointers = cinfo->mem->alloc_large((j_common_ptr)cinfo, JPOOL_IMAGE,
                                                 huff_pointers_size);
  cinfo->current_huff_pointer = -1; /* Nothing currently loaded. */

  /* Allocate the band buffer for output pixels */
  cinfo->band_buffer_size = cinfo->image_width *
                            sizeof(int) * /* 32bpp output max */
                            MAX(2, mcu_height); /* At least 2 lines for the diffuse routine */  
  cinfo->band_buffer = cinfo->mem->alloc_sarray((j_common_ptr)cinfo, JPOOL_IMAGE,
                                                cinfo->image_width * sizeof(int), MAX(2, mcu_height));

  dprintf(("", "Band buffer at %x, Huff pointers at %x\n", cinfo->band_buffer[0], cinfo->huff_pointers));

  /* Step 5a: Decompress all the MCU rows, recording an array of pointers into
   * the entropy stream to allow random access during rendering.
   */
  if (1)
  {
    size_t huff_pointer_index = 0;
    JCOEF dc[D_MAX_BLOCKS_IN_MCU];
    JBLOCKROW dummy[D_MAX_BLOCKS_IN_MCU];
    int mcus_wide, mcus_tall, mcus_per_imcu;
    int Se = cinfo->lim_Se;
  
    /* The static state for each MCU only includes the DC value, not AC, so speed
     * up this pass by forcing the entropy decoder to only do DC decompression.
     * An extra start pass with a DC limit recomputes the coefficient limits.
     */
    cinfo->lim_Se = 0;
    cinfo->entropy->start_pass(cinfo);
    cinfo->lim_Se = Se;
    
    /* Since only the DC components are needed, fake up some JBLOCKs with only
     * one coefficient's worth of storage on the stack. 
     */
    for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++)
    {
      dummy[i] = (JBLOCK *)&dc[i];
    }
  
    /* Generally each MCU comprises an hsamp * vsamp block, but if there's
     * only one component (ie. monochrome) each MCU is DCTSIZE2 so loop
     * an equivalent number of rows to make it look like the colour case.
     */
    mcus_per_imcu = cinfo->MCUs_per_row;
    if (cinfo->num_components == 1) mcus_per_imcu = mcus_per_imcu * vsamp;

    mcus_tall = 0;
    while (mcus_tall < cinfo->image_height)
    {
      /* Save the state at start of this band. This loop is broadly
       * based on decompress_onepass() minus the IDCT bit we don't need.
       */
      huff_pointer_save(cinfo, &cinfo->huff_pointers[huff_pointer_index]);
      huff_pointer_index++;

      for (mcus_wide = mcus_per_imcu; mcus_wide > 0; mcus_wide--)
      {
        cinfo->entropy->decode_mcu(cinfo, dummy);
      }
      mcus_tall += mcu_height;
    }
  
    if (!(options & jopt_DC_ONLY))
    {
      /* Do another start pass for all frequencies, so the coefficient limits
       * are their correct values. Leave as is for a postage stamp DC only decode.
       */
      cinfo->entropy->start_pass(cinfo);
      dprintf(("", "Restored entropy limits %d\n", cinfo->lim_Se));
    }
  }

  if (!cinfo->master->using_merged_upsample)
  {
    /* The discrete upsampler + colour converter only ever outputs 32bpp */
    options &= ~(jopt_OUTBPP_16 | jopt_OUTBPP_8YUV | jopt_OUTBPP_8GREY);
  }

  if (options & jopt_INTERP_X) /* interpolation requested */
  {
    int size_per_line = cinfo->band_buffer_size / mcu_width;

    if (cinfo->image_width * 2 <= size_per_line)
      cinfo->error_argument |= jopt_INTERP_X; /* signal that we'll do it */
    else
      options &= ~jopt_INTERP_X; /* not enough space - remember that we won't do it */
  }
  if (options & jopt_OUTBPP_8DITHER) cinfo->error_argument |= jopt_OUTBPP_8DITHER;
  if (options & jopt_OUTBPP_16) cinfo->error_argument |= jopt_OUTBPP_16;
  if (options & jopt_OUTBPP_8YUV) cinfo->error_argument |= jopt_OUTBPP_8YUV;
  if (options & jopt_OUTBPP_8GREY) cinfo->error_argument |= jopt_OUTBPP_8GREY;
  cinfo->options = options; /* post discovery options we're not prepared to do */

#ifdef DEBUG
  dprintf(("", "cinfo->error_argument = %d\n", cinfo->error_argument));
  dprintf(("", "After scan file, options are:\n"));
  if (options & jopt_GREY) dprintf(("", "  jopt_GREY\n"));
  if (options & jopt_DC_ONLY) dprintf(("", "  jopt_DC_ONLY\n"));
  if (options & jopt_INTERP_X) dprintf(("", "  jopt_INTERP_X\n"));
  if (options & jopt_OUTBPP_8DITHER) dprintf(("", "  jopt_OUTBPP_8DITHER\n"));
  if (options & jopt_OUTBPP_16) dprintf(("", "  jopt_OUTBPP_16\n"));
  if (options & jopt_OUTBPP_8YUV) dprintf(("", "  jopt_OUTBPP_8YUV\n"));
  if (options & jopt_DIFFUSE) dprintf(("", "  jopt_DIFFUSE\n"));
  if (options & jopt_OUTBPP_8GREY) dprintf(("", "  jopt_OUTBPP_8GREY\n"));
#endif

  dprintf(("", "Exit jpeg_scan_file (%d)\n", cinfo->error_code));

  return cinfo->error_code;
}

/*!
 * \param   cinfo Compression state structure
 * \param   ycoord Bottom up scan line number
 * \param   palette_data Pointer to palette
 * \details This gets called for every line of a rendered image. Most of the time it
 *          is fast, every MCU height it must do some de-JPEGing of some more data.
 * \return  Pointer to the line of pixels produced.
 */
int *jpeg_find_line(j_decompress_ptr cinfo, int ycoord, const int *palette_data)
{
  size_t huff_pointer_index;
  int    l2_band_height, l2_block_size;

  dprintf(("", "jpeg_find_line, palette data at %x\n", palette_data));
  
  l2_block_size = (cinfo->block_size != DCTSIZE) ? 0 : 3;
  l2_band_height = cinfo->l2_mcu_height;
  ycoord = cinfo->image_height - ycoord - 1; /* switch to top down row numbering */

  assert(cinfo->band_buffer != NULL, ERROR_FATAL);
  assert(ycoord >= 0, ERROR_FATAL);
  assert(ycoord < cinfo->image_height, ERROR_FATAL);
  assert(MAX_SAMP_FACTOR == 4, ERROR_FATAL);

  huff_pointer_index = ycoord >> l2_band_height;
  if (huff_pointer_index != cinfo->current_huff_pointer) /* Fetch a line */
  {
    int rows_wanted;
    JSAMPARRAY band_buffer = cinfo->band_buffer;
    JDIMENSION row_ctr;

    cinfo->current_huff_pointer = -1; /* In case of error exit - set correctly at end */

    /* De-JPEG one MCU's worth into the band buffer. Restore entropy state
     * at the start of the required band, then proceed to buffered case.
     */
    huff_pointer_restore(cinfo, &cinfo->huff_pointers[huff_pointer_index]);

    /* Various bits of the library count the number of lines emitted so
     * far and stop working once the end of image is reached. Since we want
     * to randomly access the image, reset all the accumulators to zero.
     * As this is guaranteed to be an MCU boundary, seeding the accumulators
     * to zero is sufficient, and avoids having to calculate them properly.
     */
    cinfo->output_scanline = 0;
    cinfo->input_iMCU_row = 0;
    cinfo->output_iMCU_row = 0;
    cinfo->global_state = DSTATE_SCANNING;

    /* A couple of processing steps also hold private state. These are normally
     * cleared in prepare_for_output_pass() when processing a full image, so
     * do the equivalent startup calls now. Can skip the idct/coef/post
     * ones since they do nothing useful state-wise.
     */
    cinfo->upsample->start_pass(cinfo);
    cinfo->main->start_pass(cinfo, JBUF_PASS_THRU);

    /* Step 6: while (scan lines remain to be read) */
    /*           jpeg_read_scanlines(...); */

    rows_wanted = 1 << l2_band_height;
    while (rows_wanted)
    {
      /* This is jpeg_read_scanlines() minus the front end checks */
      row_ctr = 0;
      cinfo->main->process_data(cinfo, band_buffer, &row_ctr, cinfo->block_size);
      rows_wanted -= row_ctr;
      band_buffer += row_ctr;
    }

    if (cinfo->options & jopt_DIFFUSE)
    {
      int rows_fetched = 1 << l2_band_height;
      int linelen, xmin;

      /* The error diffusion cannot handle a very thin strip at the right, eg one pixel wide. So the last
       * unit of diffusion may be up to 31 pixels. However, the units of diffusion until then must
       * be unaffected by exactly what xmin/xmax are, or we will get minor pixel variation depending
       * on the clipping. xmin is already a multiple of 16.
       */
      linelen = cinfo->xmax - cinfo->xmin;
      linelen = (linelen + 15) & ~15; /* round up to a multiple of 16 */
      if (linelen > cinfo->image_width - cinfo->xmin) linelen = cinfo->image_width - cinfo->xmin;
      xmin = cinfo->xmin;

      if (!cinfo->table32k_unavailable)
      {
        /* Try to get the 16bpp->8bpp lookup table from ColourTrans. If we
         * fail then never try again, probably running on old OS/ColourTrans where it
         * isn't available.
         */
        cinfo->table32k = asm_get_table32k(palette_data);
        if (cinfo->table32k == 0) cinfo->table32k_unavailable = TRUE;
        dprintf(("", "Fetched 32k lookup table, at 0x%x\n", (int) cinfo->table32k));
      }

      /* Dither in lengths of 16, to allow xmin to be non-zero. xmin is a multiple of 16 */
      if (cinfo->options & jopt_OUTBPP_8DITHER)
      {
        while (linelen > 0)
        {
          int blockwidth = linelen >= 32 ? 16 : linelen; /* avoid having very narrow blocks at r hand edge. */

          dprintf(("", "calling diffuse to 8bpp code. palette = %x\n", palette_data));
          asm_diffuse_to_8bpp(cinfo->band_buffer, blockwidth, cinfo->band_buffer, cinfo->table32k, rows_fetched, xmin, palette_data);
          linelen -= blockwidth;
          xmin    += blockwidth;
          dprintf(("", "done diffusion blockwidth = &%x linelen = &%x\n", blockwidth, linelen));
        }
      }
      else
      {
        while (linelen > 0)
        {
          int blockwidth = linelen >= 32 ? 16 : linelen; /* avoid having very narrow blocks at r hand edge. */

          dprintf(("", "calling diffuse to palette entries code. palette = %x\n", palette_data));
          asm_diffuse_to_24bpp(cinfo->band_buffer, blockwidth, cinfo->band_buffer, cinfo->table32k, rows_fetched, xmin, palette_data);
          linelen -= blockwidth;
          xmin += blockwidth;
          dprintf(("", "done diffusion blockwidth = &%x linelen = &%x\n", blockwidth, linelen));
        }
      }
    }

    cinfo->current_huff_pointer = huff_pointer_index; /* line completed correctly - remember for next time */
  }

  if (cinfo->options & jopt_DC_ONLY)
  {
    /* Rather than copy the data 8 times, the DC content is spaced out by just 1 line
     * and the address frigged here to point to line 0 (MCU height 8), 0 or 1 (MCU
     * height 16), 0 to 3 (MCU height 32).
     */
    return (int *)cinfo->band_buffer[(ycoord & ((1 << l2_band_height) - 1)) >> l2_block_size];
  }
  else
  {
    /* Non DC case, choose from 8 or 16 or 32 rows of pixels */
    return (int *)cinfo->band_buffer[(ycoord & ((1 << l2_band_height) - 1))];
  }
}

/*!
 * \param   jdata The image to consider (b0 of ws_size clear) or filename (b0 of ws_size set)
 * \param   image Structure to fill with image dimension and information
 * \param   ws_size Filled in with workspace size needed
 * \details Find basic dimensions of a JPEG file. Not done via main scanning code so
 *          that you can decide these things before you allocate the band buffer etc.
 * \return  Returns one of a) is a JPEG, can be rendered by me
 *                         b) looks like a JPEG, but can't be rendered by me
 *                         c) is not a valid JPEG
 *          or an OS error if a SWI fails during the decision making.
 */
_kernel_oserror *jpeg_find_image_dims(const char *jdata, image_dims_info *image, int *ws_size)
{
  int       iwidth, iheight, itype = 0;
  int       max_vsamp, max_hsamp, mcu_width, mcu_height;
  int       comps, new_size = 0;
  BOOL      hadapp0 = FALSE, hadsof = FALSE;
  size_t    i, markerlen, advance;
  _kernel_oserror *e;
  BOOL      load_file;
  char      buffer[1024];
  uintptr_t dataend;
  int       file_handle, xdens, ydens, ipixel_density;

  dprintf(("", "Find image dims called.\n"));

  /* Bit 0 clear means it's all in memory, else load from file */
  load_file = (((unsigned)ws_size & 3) == 1);
  if (load_file) 
  {
    dprintf(("", "We think it's a filename '%s'\n", jdata));
    e = _swix(OS_Find, _INR(0,1) | _OUT(0),
              OSFind_OpenIn | open_nopath | open_nodir | open_mustopen, jdata,
              &file_handle);
    if (e != NULL) /* failed to open the file */
    {
      dprintf(("", "Failed to open '%s', '%s'\n", jdata, e->errmess));
      return e;
    }
    jdata = buffer;
    dprintf(("", "Going to scan top of handle %d into buffer = %p\n", file_handle, buffer));
    e = _swix(OS_GBPB, _INR(0,3) | _OUT(2),
              OSGBPB_ReadFromPTR, file_handle, jdata, sizeof(buffer),
              &dataend);
    if (e != NULL) goto finish;
    dprintf(("", "Got jdata = %x, data_end = %x\n", jdata, dataend));
  }
  dprintf(("", "jdata = %x\n", jdata));

  /* Just check there's a SOI tag, the other decoding software can look
   * at the M_APPn tags. Thus we let through JFIF and EXIF at this stage
   * See JFIF 1.02 spec
   *     EXIF 2.00 spec
   * This is equivalent to IJG's first_marker().
   */
  if ((jdata[0] != 0xFF) || (jdata[1] != M_SOI))
  {
    dprintf(("", "Even a cursory look shows it ain't a jpeg\n"));
    e = jfid_NOT_JPEG;
    goto finish;
  }
  advance = 2; /* skip over 0xFF, M_SOI */

  /* We need the image width and height in order to construct the
   * sprite header. Walk into the JPEG file until we find the SOF marker.
   * This is equivalent to IJG's next_marker().
   */
  while (!hadsof)
  {
    jdata += advance;
#define M_READAHEAD_MAX 20 /* Longest read within marker of interest. M_SOF wins the prize. */
    if (load_file && (((uintptr_t)jdata + M_READAHEAD_MAX) > dataend))
    {
      size_t offset = (uintptr_t)jdata - dataend;
      size_t current;

      /* Next tag isn't in the buffer so jump forward and load more
       * such that the new tag is at the start of the RAM, thus there's no
       * danger of reading off the end of the buffer.
       */
      dprintf(("", "Loading another chunk. jdata = %x, offset = %x\n", jdata, offset));
      e = _swix(OS_Args, _INR(0,1) | _OUT(2), OSArgs_ReadPTR, file_handle, &current);
      if (e != NULL) goto finish;

      jdata = buffer;
      e = _swix(OS_GBPB, _INR(0,4) | _OUT(2),
                OSGBPB_ReadFromGiven, file_handle, jdata, sizeof(buffer), current + offset,
                &dataend);
      if (e != NULL) goto finish;
      
      if ((uintptr_t)jdata == dataend)
      {
        e = jfid_NOT_JPEG;
        goto finish; /* nothing was transferred, must be EOF of a malformed JPEG */
      }
    }
    if (jdata[0] == 0xFF)
    {
      advance = 1; 
      continue; /* the while() */
    }

    markerlen = (jdata[1] << 8) | jdata[2]; /* big endian, 65533 max */
    switch (jdata[0])
    {
      case 0: /* stuffing */
        advance = 1;
        continue;

      case M_SOS:
      case M_EOI: /* no SOF found before start of scan or end of image */
        e = jfid_NOT_JPEG;
        goto finish;

#ifndef D_PROGRESSIVE_SUPPORTED
      case M_SOF2:
#endif
#ifndef D_ARITH_CODING_SUPPORTED
      case M_SOF9:
#endif
#if !defined(D_ARITH_CODING_SUPPORTED) || !defined(D_PROGRESSIVE_SUPPORTED)
      case M_SOF10:
#endif
      case M_SOF3:  case M_SOF5:  case M_SOF6:  case M_SOF7:
      case M_SOF11: case M_SOF13: case M_SOF14: case M_SOF15:
        e = jfid_CANT_RENDER;
        goto finish;

#ifdef D_PROGRESSIVE_SUPPORTED
      case M_SOF2:
#endif
#ifdef D_ARITH_CODING_SUPPORTED
      case M_SOF9:
#endif      
#if defined(D_ARITH_CODING_SUPPORTED) && defined(D_PROGRESSIVE_SUPPORTED)
      case M_SOF10:
#endif
      case M_SOF0:
      case M_SOF1:
        if ((markerlen < 8) ||
            (markerlen < (8 + (jdata[8] * 3))))
        {
          e = jfid_NOT_JPEG;
          goto finish;
        }
        hadsof = TRUE;
        comps = jdata[8]; /* 1 for monochrome, 3 for YUV or RGB, 4 for CMYK or YCCK */
        iheight = (jdata[4] << 8) + jdata[5];
        iwidth = (jdata[6] << 8) + jdata[7];
        itype |= comps;
        itype |= ((jdata[0] & 0xF) << 8); /* mix in the 4 bit SOF type */
        max_vsamp = max_hsamp = 1;
        for (i = 0; i < comps; i++)
        {
          unsigned char c = jdata[10 + (i * 3)];

          max_vsamp = MAX(max_vsamp, c & 0xF);
          max_hsamp = MAX(max_hsamp, c >> 4);
        }
        if (BADCOMPCOUNT(comps) || /* same checks as jpeg_scan_file() */
            (jdata[3] != BITS_IN_JSAMPLE) ||
            BADSAMPFACTOR(max_vsamp) || BADSAMPFACTOR(max_hsamp))
        {
          e = jfid_CANT_RENDER;
          goto finish;
        }
        break;

      case M_APP0: /* the JFIF app segment */
        if ((markerlen < 16) ||
            (jdata[3] != 'J' || jdata[4] != 'F' || jdata[5] != 'I' || jdata[6] != 'F'))
        {
          break; /* probably a 'JFXX' marker then, ignore */
        }
        if (jdata[8] != 1) /* need major version 1 */
        {
          e = jfid_CANT_RENDER;
          goto finish;
        }
        hadapp0 = TRUE;
        dprintf(("", "pixel density type %x\n", jdata[10]));
        dprintf(("", "  jdata[11-14], %02x%02x %02x%02x\n", jdata[11], jdata[12], jdata[13], jdata[14]));
        switch (jdata[10])
        {
          case 0: /* ratio (no units) */
            xdens = STANDARDDPI;
            ydens = (jdata[11] << 8) + jdata[12];
            if (ydens == 0) ydens = 1; /* take into account the case where the scale may be 0:0, pah! */
            ydens = ((jdata[13] << 8) + jdata[14]) / ydens;
            if (ydens == 0)
              ydens = STANDARDDPI;
            else
              ydens *=STANDARDDPI;
            ipixel_density = (xdens << 16) | ydens;
            itype |= 0x80;    /* set bit in type word to indicate density is only a ratio */
            break;
     
          case 1: /* dp-inch */
            ipixel_density = (jdata[11] << 24) + (jdata[12] << 16) + (jdata[13] << 8) + jdata[14];
            break;
     
          case 2: /* dp-cm */
            xdens = ((int)((jdata[11] << 8) + jdata[12])*CMTOINCH_NUM)/CMTOINCH_DEN;
            ydens = ((int)((jdata[13] << 8) + jdata[14])*CMTOINCH_NUM)/CMTOINCH_DEN;
            ipixel_density = (xdens << 16) | ydens;
            break;
     
          default:
            e = jfid_CANT_RENDER;
            goto finish;
        }
        break;

      case M_TEM: /* no parameters with these markers */
      case M_RST0: case M_RST1: case M_RST2: case M_RST3:
      case M_RST4: case M_RST5: case M_RST6: case M_RST7:
        markerlen = 0; 
        /* Fall through.. */
      default:
        dprintf(("", "skip tag = %x\n", jdata[0]));
        break;
    }
    advance = markerlen + 2; /* skip over variable length marker */
  }

  if (!hadapp0)
  {
    dprintf(("", "no APP0 tag, assuming a 1:1 xdpi to ydpi ratio\n"));
    itype |= 0x80;    /* set bit in type word to indicate density is only a ratio */
    ipixel_density = (STANDARDDPI << 16) | STANDARDDPI;
  }
  dprintf(("", "pixel density is %d\n", ipixel_density));

  /* Work out the required workspace to handle this specimen */
  mcu_height = max_vsamp * DCTSIZE;
  mcu_width = max_hsamp * DCTSIZE;
  new_size = sizeof(struct jpeg_decompress_struct) /* Compression state structure */ +
             (24 * 1024) /* From libjpeg.txt */ +
             sizeof(huff_pointer) * ((iheight + (mcu_height - 1)) / mcu_height) /* Entropy pointers */ +
             MAX(2, mcu_height) * (iwidth + (mcu_width - 1)) * sizeof(int) /* Band buffer */;
  new_size = (new_size + 3) & ~3;

  if (image != NULL)
  {
    image->height = iheight;
    image->width = iwidth;
    image->type = itype;
    image->density = ipixel_density;
  }

  if ((unsigned)ws_size > 3)
  {
    j_decompress_ptr  cinfo;
    int               page_size;

    ws_size = (int *)((unsigned)ws_size & ~3);
    cinfo = (j_decompress_ptr)*ws_size;

    /* If cinfo is not NULL then it points to the current decompress_info_struct which
     * contains info about the current memory allocation
     */
    if (cinfo == NULL)
    {
      new_size = new_size + (10*1024); /* first jpeg => alloc size we need plus safety margin */
    }
    else
    {
      if (cinfo->workspace_size >= new_size)
      {
        new_size = 0; /* we already have enough memory */
      }
      else
      {
        new_size -= cinfo->workspace_size; /* size that will be added for this jpeg */
      }
    }
    _swix(OS_ReadMemMapInfo, _OUT(0), &page_size);
    new_size = (new_size + (page_size - 1)) & ~(page_size - 1);
    *ws_size = new_size;
    dprintf(("", "We need another %x bytes\n", new_size));
  }
  e = jfid_OK; /* checks out OK */

finish:
  if (load_file)
  {
    _swix(OS_Find, _INR(0,1), OSFind_Close, file_handle);
  }
  return e;
}
@


4.35
log
@Lazy MCU decoding
Detail:
  Only colour convert from the left clipping border (rounded down) to the right (rounding up).
  Only entropy decode the DC component for blocks likewise, skipping AC and IDCT steps.
Admin:
  Submission for the JPEG bounty.

Version 1.76. Tagged as 'SprExtend-1_76'
@
text
@d882 3
a884 4
            ipixel_density = (int)(jdata[11]*CMTOINCH_NUM/CMTOINCH_DEN) << 24 +
                             (int)(jdata[12]*CMTOINCH_NUM/CMTOINCH_DEN) << 16 +
                             (int)(jdata[13]*CMTOINCH_NUM/CMTOINCH_DEN) << 8  +
                             (int)(jdata[14]*CMTOINCH_NUM/CMTOINCH_DEN);
@


4.34
log
@Add lossless JPEG support
Detail:
  Update scanning, diffusing, line fetching to handle 1x1 DCTs.
  For transcoding, skip the jcmaster check on block_size having to generate optimal huffman tables - for a 1x1 DCT we don't need a huffman table at all and the defaults will suffice.
  For diffusing, rather that write out longhand another specialised diffuser to handle the 1x1 case, just overallocate one line in the band buffer and let it diffuse a line of garbage.
  Implement integer fast 1x1 DCT routine (to avoid having to drag in 25k of generic IDCT_ISLOW code).
Admin:
  Submission for the JPEG bounty.

Version 1.75. Tagged as 'SprExtend-1_75'
@
text
@a311 7
#if 0 /* DC only option now only affects entropy + IDCT */
  if (options & jopt_DC_ONLY)
  {
    options &= ~(jopt_OUTBPP_8DITHER | jopt_OUTBPP_16 | jopt_OUTBPP_8YUV);
    dprintf(("", "Clearing 8DITHER/16/8YUV because of DC_ONLY flag\n"));
  }
#endif  
a314 1
    /* xmin = 0;*/ /* always have to do left part, because errors diffuse over from there */
d419 5
d506 1
a506 1
    int size_per_line = cinfo->band_buffer_size / (cinfo->block_size * hsamp);
d548 1
a548 1
  int  vsamp, l2_band_height, l2_block_size;
a551 1
  vsamp = cinfo->max_v_samp_factor;
d553 1
a553 2
  l2_band_height = (vsamp == 4) ? vsamp - 2 : vsamp - 1; /* log2 of band height 1/2/4 -> 0/1/2 */
  l2_band_height += l2_block_size;
@


4.33
log
@Bug fixes
Detail:
  Remove the unused gray (sic) output colour space support. Remove the patches to set output colour space to RGB, this can be overridden in code per the design intent of the library. Only decode luma for grey output.
  Fix bug rendering test image monorose2x4 - this was caused by the huffman pointer saving not decoding enough MCUs when the source image is monochrome hence an MCU outputs 8x8 rather than hsamp x vsamp pixels. Also removed the setting of insufficient_data in the entropy decoder, this meant that any error at the end of the image (eg. truncated) would cause the rest of the image to not render because JPEGs are stored top down but RISC OS plots them bottom up.
  Fix endless failure to match previously cached JPEG, especially at 16bpp, when the source JPEG doesn't meet the fast colour conversion criteria (eg. not 2x2 subsampling). The flags test was checking the requested flags against the filtered flags, which never matched (because the unmet options get cleared). Now, keep the original flags prior to filtering and compare those on the basis that the conversion decision will be consistent; simply ANDing out those modifiable flags doesn't help because then you can't spot when they genuinely change (eg. a mode change) as the filtered flags determine what format the blitter is expecting back.
  Fix bug causing aborts when the user manually resizes (down) the JPEG workspace DA. The calculation of new_size in jpeg_find_image_dims() had at some point lost the height multiplier on the band buffer, so when auto resizing back up again the buffer was too small to convert a whole band into.
Admin:
  Submission for the JPEG bounty.

Version 1.74. Tagged as 'SprExtend-1_74'
@
text
@d279 2
d414 2
a415 2
  mcu_height = DCTSIZE * vsamp; /* Scan lines */
  mcu_width = DCTSIZE * hsamp; /* Pixels */
d424 1
d435 1
a435 1
                            mcu_height;   
d437 1
a437 1
                                                cinfo->image_width * sizeof(int), mcu_height);
d449 1
a449 1
    int mcus_read, mcus_per_imcu;
d475 2
a476 2
    mcu_height = 0;
    while (mcu_height < cinfo->image_height)
d484 1
a484 1
      for (mcus_read = mcus_per_imcu; mcus_read > 0; mcus_read--)
d488 1
a488 1
      mcu_height += DCTSIZE * vsamp;
d509 1
a509 1
    int size_per_line = cinfo->band_buffer_size / (DCTSIZE * hsamp);
d551 1
a551 1
  int  vsamp, l2_band_height;
d556 3
a558 1
  l2_band_height = (vsamp == 4) ? vsamp + 1 : vsamp + 2; /* log2 of band height 1/2/4 -> 3/4/5 */
d602 1
a602 1
    rows_wanted = vsamp * DCTSIZE;
d607 1
a607 1
      cinfo->main->process_data(cinfo, band_buffer, &row_ctr, DCTSIZE);
d614 1
a614 1
      int rows_fetched = vsamp * DCTSIZE;
d676 1
a676 1
    return (int *)cinfo->band_buffer[(ycoord & ((1 << l2_band_height) - 1)) / DCTSIZE];
d925 1
a925 1
             mcu_height * (iwidth + (mcu_width - 1)) * sizeof(int) /* Band buffer */;
@


4.32
log
@Transcode progressives
Detail:
  Enable the Huffman and arithmetic progressive code paths, these are handled much like arithmetic: undo the entropy part of the encoding process into a dynamic area full of raw coefficients, recompress as a baseline image, copy the image into the JPEG workspace for real time redraw.
Admin:
  Submission for the JPEG bounty.

Version 1.73. Tagged as 'SprExtend-1_73'
@
text
@d328 6
a333 6
  if (  cinfo->error_code == 0                                               /* check for very first time, or for error last time */
     && cinfo->jpeg_user_buffer == buffer                                    /* check for image in same place */
     && cinfo->jpeg_user_buffer_size == buffer_size                          /* check length unchanged */
     && (width == -1 || cinfo->image_width == width)                         /* width OK */
     && (height == -1 || cinfo->image_height == height)                      /* height OK */
     && cinfo->check1 == ((int*)buffer)[buffer_size/(2*4)]                  /* Random checks on data - the /4 gets us down to char offsets */
d336 1
a336 1
     && cinfo->options == options
d394 2
a395 1
  cinfo->options = options; /* Contains colour conversion options */
d446 1
d465 7
d480 2
a481 3
    
      mcu_width = 0;
      while (mcu_width < cinfo->image_width)
a483 1
        mcu_width += DCTSIZE * hsamp;
d920 1
a920 1
             (iwidth + (mcu_width - 1)) * sizeof(int) /* Band buffer */;
@


4.31
log
@Transcode arithmetics
Detail:
  Import of the raw coefficient Huffman entropy compressor elements of the IJG8d library.
  We don't need a full compressor (ala JCompMod) since there's never a need to go all the way through IDCT/upsampling/colour conversion only to reverse the whole process; it's sufficient only to collect up the raw coefficients and recompress them as a baseline JPEG.
  Two extra (temporary) dynamic areas are introduced, once to hold the raw coefficients and the other to act as a scratch file to make the JPEG in. See Doc/JPEGMmgr.
Admin:
  Submission for the JPEG bounty.

Version 1.72. Tagged as 'SprExtend-1_72'
@
text
@d380 1
a380 1
#ifdef D_ARITH_CODING_SUPPORTED
d386 1
a386 1
#endif
d787 3
d793 5
a797 4
      case M_SOF2:  case M_SOF3:
      case M_SOF5:  case M_SOF6:  case M_SOF7:
      case M_SOF10: case M_SOF11:
      case M_SOF13: case M_SOF14: case M_SOF15:
d801 3
d807 3
@


4.30
log
@Removed CFSI-JPEG support
Detail:
  ChangeFSI now makes its own helper plugin which just calls the JPEG SWIs of the host OS, so there's no need for SpriteExtend to be complicated by this now.
Admin:
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_71-nocfsi
@
text
@d41 1
a41 1
    cinfo = area_create(jpeg_ws_size);
d51 1
a51 1
      size_t areasize;
d55 2
a56 3
      areasize = area_resize(jpeg_ws_size);
      assert(areasize != 0, ERROR_NO_MEMORY);
      cinfo->workspace_size = areasize;
d209 9
a217 9
  M_SOF0  = 0xc0,
  M_SOF1  = 0xc1,
  M_SOF2  = 0xc2,
  M_SOF3  = 0xc3,
  
  M_SOF5  = 0xc5,
  M_SOF6  = 0xc6,
  M_SOF7  = 0xc7,
  
d219 8
a226 8
  M_SOF9  = 0xc9,
  M_SOF10 = 0xca,
  M_SOF11 = 0xcb,
  
  M_SOF13 = 0xcd,
  M_SOF14 = 0xce,
  M_SOF15 = 0xcf,
  
d317 1
a317 1
  if (xmin < 0) xmin = 0; /* xmax will be clipped to image_height, when we know it. */
d329 2
a330 2
     && cinfo->jpeg_buffer == buffer                                         /* check for image in same place */
     && cinfo->jpeg_buffer_size == buffer_size                               /* check length unchanged */
d366 2
a367 2
  cinfo->jpeg_buffer = buffer;
  cinfo->jpeg_buffer_size = buffer_size;
d380 10
d774 1
d787 7
a793 4
      case M_SOF2:  case M_SOF3: /* progressive and lossless huffman */
      case M_SOF5:  case M_SOF6:  case M_SOF7: /* differential huffman */
      case M_SOF9:  case M_SOF10: case M_SOF11: /* non differential arithmetic */
      case M_SOF13: case M_SOF14: case M_SOF15: /* differential arithmetic */
d797 5
a801 2
      case M_SOF0: /* huffman baseline */
      case M_SOF1: /* huffman extended sequential */
@


4.29
log
@Import of IJG8d library sources
Detail:
  Using the decoder in "example.c" as a starting point, we try to follow that sequence more closely even if in our embedded implementation some of the functions don't do much.
  Uses the default colour backend for 32bpp BGR output for most of the unusual cases.
  The most common 2x2 subsampling case uses a custom merged upsampler and colour converter, with colour output directly in RISC OS format for the respective screen mode.
Admin:
  Submission for the JPEG bounty.

Version 1.71. Tagged as 'SprExtend-1_71'
@
text
@a30 21
#ifdef CFSI
int do_jpeg_scan_file_32(char *space, int space_size, const JOCTET *file_image, int image_length)
/* Simple entry sequence for use by ChangeFSI - 32bpp output. */
{
  j_decompress_ptr cinfo = (j_decompress_ptr) space;

  cinfo->workspace_size = space_size;
  cinfo->error_code = -1; /* force total reset */
  return jpeg_scan_file(cinfo, file_image, image_length, 0, 0x7fffffff, -1, -1, 0);
}

int do_jpeg_scan_file_16(char *space, int space_size, const JOCTET *file_image, int image_length)
/* Simple entry sequence for use by ChangeFSI - 16bpp output. */
{
  j_decompress_ptr cinfo = (j_decompress_ptr) space;

  cinfo->workspace_size = space_size;
  cinfo->error_code = -1; /* force total reset */
  return jpeg_scan_file(cinfo, file_image, image_length, 0, 0x7fffffff, -1, -1, jopt_OUTBPP_16);
}
#else
a201 1
#endif
a682 1
#ifndef CFSI
a686 1
#endif
d689 1
a689 1
#ifndef CFSI
a710 1
#endif
a733 1
#ifndef CFSI
a759 1
#endif
a826 1
#ifndef CFSI
a858 1
#endif
a872 1
#ifndef CFSI
a879 1
#endif
a894 1
#ifndef CFSI
a895 1
#endif
a897 1
#ifndef CFSI
a928 6
#else
  if ((unsigned)ws_size > 1)
  {
    *ws_size = new_size;
  }
#endif
a931 1
#ifndef CFSI
a935 1
#endif
@


4.28
log
@Replace tracef debug calls
Detail:
  Change tracef() to use the double brackets trick rather than _ for , substitution
Admin:
  Debug build built, but not tested. Non debug build functions as before.
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_70-tracef
@
text
@a26 49
*    JPEG library code.                                                   *
*                                                                         *
**************************************************************************/

#ifdef SOURCE_IS_rojpeg
#define CFSI
#define dprintf(args)    /* Nothing */
#define dsprintf(args)   /* Nothing */
#define assert(x, y)     {if (!(x)) exit(y);}
#define newline()        /* Nothing */
#define comment(ws,text) /* Nothing */
#endif

#include "jrdjfif.c"
#include "jdhuff.c"

#undef FILE_
#define FILE_ (40000)

/**************************************************************************
*                                                                         *
*    Low-level debugging output.                                          *
*                                                                         *
**************************************************************************/

void panic_trace(j_decompress_ptr cinfo, int *regblock, int code)
/* The assembler code calls us here when something goes wrong, in an attempt
 * to learn what happened. On exit it then returns, usually leading to no picture
 * being painted.
 */
{
#ifdef DEBUG
  int i;

  dprintf(("", "Corrupted data in Huffman stream at byte %i\n", (char*)regblock[3] - (char*)cinfo->jpeg_buffer));
  dprintf(("", "cinfo=0x%x regblock=0x%x code=%i.\n", (int)cinfo, (int)regblock, code));
  for (i = 0; i < 16; i++) dprintf(("", "R%i=0x%x\n", i, regblock[i]));
  dprintf(("", "Nearby input bytes:\n"));
  for (i = -10; i < 10; i++) dprintf(("", "%i:0x%x ", i, ((char*)(regblock[3]))[i]));
  dprintf(("", "\n"));
#else
  UNUSED(cinfo);
  UNUSED(regblock);
  UNUSED(code);
#endif
}

/**************************************************************************
*                                                                         *
d33 1
a33 1
/* Simple entry sequence for use by ChangeFSI */
a48 1
  cinfo->convert_block_16 = asm_get_convert_block_16_func(65535,0); /* Only traditional 16bpp output for now */
d61 2
a62 2
    dprintf(("", "Malloc requesting %x bytes of workspace\n", jpeg_ws_size));
    cinfo = malloc(jpeg_ws_size);
d64 2
a65 2
    wp->jpeg_info_ptr = cinfo;                   /* mark the workspace entirely uninitialised */
    cinfo->error_code = -1;
d70 1
a70 1
    if (jpeg_ws_size)                            /* need to realloc */
d72 3
a74 1
      dprintf(("", "Realloc requesting %x extra bytes of workspace\n", jpeg_ws_size));
d76 3
a78 3
      cinfo = realloc(cinfo, jpeg_ws_size);
      assert(cinfo != NULL, ERROR_NO_MEMORY);
      wp->jpeg_info_ptr = cinfo;
a79 1
      cinfo->workspace_size = jpeg_ws_size;
d94 7
a100 1
  if(wp->TTRType != TTRType_ColourMap) /* If colour mapping is in use, only produce ordinary 32bpp output. TODO - Improve on this, e.g. could call colour mapping before error diffusion */
d111 1
d118 2
a119 2
  
    if ((wp->BPP == 8))
d121 1
a121 2
      int temp;
      int size;
d127 2
a128 2
                                     -1, -1, &(wp->newtranstable[0]), size, 0); /* save palette into newtranstable area */
      temp = palette_is_grey(wp->newtranstable, size/4);
d136 2
a137 1
    if ((wp->save_PdriverIntercept & 2) == 0 && (wp->dither_truecolour & 1)) /* old format palette and printing is not on */
d141 1
a141 1
      if ((wp->dither_truecolour & 2) && wp->BPP < 16)
d160 1
a160 1
          if (palette_is_grey(wp->newtranstable, size/4)) opt |= jopt_GREY;
d166 2
a167 2
          temp = palette_is_grey(wp->newtranstable, size/4);
          if (temp) opt |= jopt_GREY;
d170 2
a171 2
            opt |= jopt_OUTBPP_8GREY;
            opt &= ~jopt_DIFFUSE;
d176 2
a177 1
      if ((wp->BPP == 4) && !(wp->dither_truecolour & 2)) opt |= jopt_GREY;
d183 1
a183 1
          opt |= jopt_OUTBPP_8;                        /* full error diffusion */
d192 1
a192 1
            opt |= jopt_OUTBPP_8YUV;                   /* strange diffusion from YUV data */
d197 1
a197 2
        opt |= jopt_OUTBPP_16;
        cinfo->convert_block_16 = asm_get_convert_block_16_func(wp->ncolour,wp->modeflags);
d199 7
d214 1
a214 1
  if (opt & jopt_OUTBPP_8) dprintf(("", "   jopt_OUTBPP_8\n"));
a224 424
static void init_workspace(j_decompress_ptr cinfo, int size)
/* Workspace has been allocated. Initialise it, any subsidiary
 * structures etc. Do not touch the band buffer, might not be allocated yet.
 */
{
  int   i;
  int   workspace_size;
  char *table32k;
  convert_block_16_func convert_block_16;

  /* Must preserve the workspace size, 32k colour table, and 16bpp routine */
  workspace_size = cinfo->workspace_size;
  table32k = cinfo->table32k;
  convert_block_16 = cinfo->convert_block_16;
  memset(cinfo, 0, size);
  cinfo->workspace_size = workspace_size;
  cinfo->table32k = table32k;
  cinfo->convert_block_16 = convert_block_16;

  cinfo->comp_info = &cinfo->s_cur_comp_info[0];

  for (i = 0; i < NUM_QUANT_TBLS; i++) /* allocate quantisation tables */
    cinfo->quant_tbl_ptrs[i] = &cinfo->s_quant_tbl[i];
    
  for (i = 0; i < NUM_HUFF_TBLS; i++) /* allocate huffman tables */
  {
    cinfo->dc_huff_tbl_ptrs[i] = &cinfo->s_dc_huff_tbl[i];
    cinfo->ac_huff_tbl_ptrs[i] = &cinfo->s_ac_huff_tbl[i];
  }
}

static void process_restart(j_decompress_ptr cinfo)
/* Coping with restarts - whoever put restarts in this standard?
 * We should be precisely at a restart marker.
 */
{
  char c = *cinfo->next_input_byte++;
  int ci;

#if 0
  dprintf(("", "Processing restart marker %i at %i bytes\n", cinfo->next_restart_num, cinfo->next_input_byte - cinfo->jpeg_buffer));
  {
    int i;
    dprintf(("", "inbuf=0x%x nbits=%i inptr=0x%x file=0x%x\n", cinfo->get_buffer, cinfo->bits_left, (int)cinfo->next_input_byte, (int)cinfo->jpeg_buffer));
    for (i = -10; i < 10; i++) dprintf(("", "%i:0x%x ", i, cinfo->next_input_byte[i]));
    dprintf(("", "\n"));
  }
#endif
  assert(cinfo->bits_left <= 7, ERROR_BAD_JPEG);
  assert(c == 0xff, ERROR_BAD_JPEG);
  while (*cinfo->next_input_byte == 0xff) cinfo->next_input_byte++; /* additional 0xffs allowed at this point */
  c = *cinfo->next_input_byte++;
  assert((c & 0xF8) == 0xD0, ERROR_BAD_JPEG); /* RST0..RST7 markers */
  assert((c & 7) == cinfo->next_restart_num, ERROR_BAD_JPEG); /* should be precisely the correct marker */
  /* It appears to be a correctly formed restart marker */
  cinfo->bits_left = 0;       /* flush the remaining bits */
  cinfo->get_buffer = 0;
  cinfo->restarts_to_go = cinfo->restart_interval;
  cinfo->next_restart_num = (cinfo->next_restart_num + 1) & 7;
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) cinfo->last_dc_val[ci] = 0;
}

/**************************************************************************
*                                                                         *
*    Huffman.                                                             *
*                                                                         *
**************************************************************************/

static void save_huff_stream(j_decompress_ptr cinfo, huff_pointer *h)
/* Save the current state of the huffman stream, so that we could
 * restart reading at this point.
 */
{
  assert(cinfo->bits_left < 32, ERROR_BAD_JPEG);
  assert(cinfo->bits_left >= 0, ERROR_BAD_JPEG);
  assert(cinfo->jpeg_buffer < cinfo->next_input_byte, ERROR_BAD_JPEG);
  assert(cinfo->next_input_byte < &cinfo->jpeg_buffer[cinfo->jpeg_size], ERROR_BAD_JPEG);

  h->bit_pointer = (cinfo->next_input_byte - cinfo->jpeg_buffer)*32 + cinfo->bits_left;
  h->get_buffer = cinfo->get_buffer;
  h->last_dc_val[0] = cinfo->last_dc_val[0];
  h->last_dc_val[1] = cinfo->last_dc_val[1];
  h->last_dc_val[2] = cinfo->last_dc_val[2];
  h->restarts_to_go = cinfo->restarts_to_go;
  h->next_restart_num = cinfo->next_restart_num;
}

static void restore_huff_stream(j_decompress_ptr cinfo, huff_pointer *h)
/* Reset a save state of the huffman stream, so that we can continue reading. */
{
  cinfo->get_buffer = h->get_buffer;
  cinfo->next_input_byte = cinfo->jpeg_buffer + h->bit_pointer/32;
  cinfo->bits_left = h->bit_pointer & 31;
  cinfo->last_dc_val[0] = h->last_dc_val[0];
  cinfo->last_dc_val[1] = h->last_dc_val[1];
  cinfo->last_dc_val[2] = h->last_dc_val[2];
  cinfo->restarts_to_go = h->restarts_to_go;
  cinfo->next_restart_num = h->next_restart_num;

#ifdef DEBUG
  if (!(cinfo->jpeg_buffer < cinfo->next_input_byte && cinfo->next_input_byte < &cinfo->jpeg_buffer[cinfo->jpeg_size]))
    dprintf(("", "oops restore_huff_stream: 0x%x 0x%x 0x%x\n", (int)cinfo->jpeg_buffer, (int)cinfo->next_input_byte, (int)cinfo->jpeg_size));
#endif
  assert(cinfo->jpeg_buffer < cinfo->next_input_byte, ERROR_FATAL);
  assert(cinfo->next_input_byte < &cinfo->jpeg_buffer[cinfo->jpeg_size], ERROR_FATAL);
}

static void
do_huff_skip_blocks(j_decompress_ptr cinfo, JBLOCK block,
                    JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JQUANT_TBL * quanttbl,
                    JCOEF *last_dc_val, int nblocks, BOOL block_per_mcu)
/* Just like asm_huff_skip_blocks, but handles restart markers. If block_per_mcu
 * then count one restart interval per block, else just count one.
 */
{
  if (cinfo->restart_interval)
  {
    BOOL count = TRUE;

    while (nblocks > 0)
    {
      if (count)
      {
        if (cinfo->restarts_to_go == 0) process_restart(cinfo);
        cinfo->restarts_to_go--;
      }
      asm_huff_skip_blocks(cinfo, block, dctbl, actbl, quanttbl, last_dc_val, 1);
      nblocks--;
      count = block_per_mcu;
      block += DCTSIZE2;
    }
  }
  else
    asm_huff_skip_blocks(cinfo, block, dctbl, actbl, quanttbl, last_dc_val, nblocks);
}

static void
do_huff_decode_blocks(j_decompress_ptr cinfo, JBLOCK block,
                      JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JQUANT_TBL * quanttbl,
                      JCOEF *last_dc_val, int nblocks, BOOL block_per_mcu)
/* Just like asm_huff_decode_blocks, but handles restart markers. If block_per_mcu
 * then count one restart interval per block, else just count one.
 */
{
  if (cinfo->restart_interval)
  {
    BOOL count = TRUE;

    while (nblocks > 0)
    {
      if (count)
      {
        if (cinfo->restarts_to_go == 0) process_restart(cinfo);
        cinfo->restarts_to_go--;
      }
      asm_huff_decode_blocks(cinfo, block, dctbl, actbl, quanttbl, last_dc_val, 1);
      nblocks--;
      count = block_per_mcu;
      block += DCTSIZE2;
    }
  }
  else
    asm_huff_decode_blocks(cinfo, block, dctbl, actbl, quanttbl, last_dc_val, nblocks);
}

/**************************************************************************
*                                                                         *
*    Band expansion from entropy encoded data.                            *
*                                                                         *
**************************************************************************/

static int do_1_component_band(j_decompress_ptr cinfo, int line_offset)
{
  int width = 0;
  int *outptr = cinfo->band_buffer;
  int nlines_fetched;
  JQUANT_TBL * quanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];
  JHUFF_TBL *dc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
  JHUFF_TBL *ac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
  
  dprintf(("", "in do_1_component_band\n"));
  
  if (cinfo->xmin >= 8)
  {
    int count = (cinfo->xmin - 8) >> 3; /* how many blocks we can just skip */
  
    do_huff_skip_blocks(cinfo, cinfo->jblocks[0], dc, ac, quanttbl, &cinfo->last_dc_val[0], count, TRUE);
    width += 8*count;
    if (cinfo->options & jopt_OUTBPP_8GREY)
      outptr += 2*count;
    else
      outptr += 8*count;
  }
  
  if (cinfo->options & jopt_DC_ONLY) /* monochrome, only tile values */
  {
    /* We only want a flat value for each tile. Just create a single line but
     * do not attempt to collapse this in the x direction, too complex to interface to.
     */
    while (width < cinfo->xmax) /* the data we want */
    {
      int pix;
  
      do_huff_skip_blocks(cinfo, cinfo->jblocks[1], dc, ac, quanttbl, &cinfo->last_dc_val[0], 1, TRUE);
      pix = mono_convert_pixel(cinfo->last_dc_val[0] * quanttbl->quantval[0]);
      if (cinfo->options & jopt_OUTBPP_8GREY)
      {
        /* Native greyscale 8bpp */
        outptr[0] = outptr[1] = YYYTOYYYY(pix);
        outptr += 2;
      }
      else
      {
        /* Output greyscale 24bpp, and dither it later if needed */
        outptr[0] = pix; outptr[1] = pix;
        outptr[2] = pix; outptr[3] = pix;
        outptr[4] = pix; outptr[5] = pix;
        outptr[6] = pix; outptr[7] = pix;
        outptr += 8;
      }
      width += 8;
    }
    nlines_fetched = 1;
  }
  else /* mono normal case, all pixels required */
  {
    while (width < cinfo->xmax) /* the data we want */
    {
      do_huff_decode_blocks(cinfo, cinfo->jblocks[1], dc, ac, quanttbl, &cinfo->last_dc_val[0], 1, TRUE);
      jpeg_idct_ifast(cinfo, cinfo->jblocks[1], 1); /* output in jblocks[0] */
      if (cinfo->options & jopt_OUTBPP_8GREY)
      {
        asm_mono_convert_block_8(cinfo->jblocks[0], outptr, line_offset);
        outptr += 2;
      }
      else
      {
        asm_mono_convert_block(cinfo->jblocks[0], outptr, line_offset);
        outptr += 8;
      }
      width += 8;
    }
    nlines_fetched = 8;
  }

  return nlines_fetched;
}

static int do_3_component_band(j_decompress_ptr cinfo, int line_offset)
{
  int width = 0;
  int *outptr = cinfo->band_buffer;
  int nlines_fetched;
  JHUFF_TBL *ydc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
  JHUFF_TBL *yac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
  JQUANT_TBL * yquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];
  JHUFF_TBL *udc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[1]->dc_tbl_no];
  JHUFF_TBL *uac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[1]->ac_tbl_no];
  JQUANT_TBL * uquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[1]->quant_tbl_no];
  JHUFF_TBL *vdc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[2]->dc_tbl_no];
  JHUFF_TBL *vac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[2]->ac_tbl_no];
  JQUANT_TBL * vquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[2]->quant_tbl_no];
  int vsamp = cinfo->comp_info[0].v_samp_factor;
  int hsamp = cinfo->comp_info[0].h_samp_factor;
  
  dprintf(("", "in do_3_component_band\n"));
  
  while (width + 8*hsamp <= cinfo->xmin) /* skip over blocks we don't want */
  {
    do_huff_skip_blocks(cinfo, cinfo->jblocks[0], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], hsamp*vsamp, FALSE);
    asm_huff_skip_blocks(cinfo, cinfo->jblocks[0], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
    asm_huff_skip_blocks(cinfo, cinfo->jblocks[0], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
    width += 8*hsamp;
    if (cinfo->options & jopt_OUTBPP_16) outptr += 4*hsamp;
    else if (cinfo->options & jopt_OUTBPP_8YUV) outptr += 2*hsamp;
    else if (cinfo->options & jopt_OUTBPP_8GREY) outptr += 2*hsamp;
    else outptr += 8*hsamp;
  }
  
  if (cinfo->options & jopt_DC_ONLY) /* colour, only want pixel tile values */
  {
    while (width < cinfo->xmax) /* the data we want */
    {
      int y[4];
      int u;
      int v;
      int i;
  
      do_huff_skip_blocks(cinfo, cinfo->jblocks[1], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], 1, FALSE);
      y[0] = cinfo->last_dc_val[0] * yquanttbl->quantval[0];
      for (i = 1; i < hsamp*vsamp; i++)
      {
        asm_huff_skip_blocks(cinfo, cinfo->jblocks[1 + i], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], 1);
        y[i] = cinfo->last_dc_val[0] * yquanttbl->quantval[0];
      }
      asm_huff_skip_blocks(cinfo, cinfo->jblocks[5], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
      asm_huff_skip_blocks(cinfo, cinfo->jblocks[6], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
      if (cinfo->options & jopt_GREY) /* greyscale output is acceptable */
      {
        dprintf(("", "about to do replicate some luma\n"));
        mono_convert_pixels(y); /* results back in y[0..3] */
        if (cinfo->options & jopt_OUTBPP_8GREY)
        {
          /* Native greyscale 8bpp */
          outptr[0] = outptr[1] = YYYTOYYYY(y[0]);
          if (hsamp == 2) outptr[2] = outptr[3] = YYYTOYYYY(y[1]);
          if (vsamp == 2)
          {
            outptr[line_offset + 0] = outptr[line_offset + 1] = YYYTOYYYY(y[hsamp == 2 ? 2 : 1]);
            if (hsamp == 2) outptr[line_offset + 2] = outptr[line_offset + 3] = YYYTOYYYY(y[3]);
          }
        }
        else
        {
          /* Output greyscale 24bpp, and dither it later if needed */
          for (i = 0; i < 8; i++)
          {
            outptr[0 + i] = y[0];
            if (hsamp == 2) outptr[8 + i] = y[1];
            if (vsamp == 2)
            {
              outptr[line_offset + 0 + i] = y[hsamp == 2 ? 2 : 1];
              if (hsamp == 2) outptr[line_offset + 8 + i] = y[3];
            }
          }
        }
      }
      else
      {
        dprintf(("", "about to do YUV to greyscale\n"));
        u = cinfo->last_dc_val[1] * uquanttbl->quantval[0];
        v = cinfo->last_dc_val[2] * vquanttbl->quantval[0];
        colour_convert_pixels(y, u, v); /* results back in y[0..3] */
        for (i = 0; i < 8; i++)
        {
          outptr[i] = y[0];
          if (hsamp == 2) outptr[8+i] = y[1];
          if (vsamp == 2)
          {
            outptr[line_offset+i] = y[hsamp == 2 ? 2 : 1];
            if (hsamp == 2) outptr[line_offset+8+i] = y[3];
          }
        }
      }
      width += 8*hsamp;
      if (cinfo->options & jopt_OUTBPP_16) outptr += 4*hsamp;
      else if (cinfo->options & jopt_OUTBPP_8YUV) outptr += 2*hsamp;
      else if (cinfo->options & jopt_OUTBPP_8GREY) outptr += 2*hsamp;
      else outptr += 8*hsamp;
    }
    nlines_fetched = vsamp;
  }
  else /* colour, normal case (want all pixels) */
  {
    while (width < cinfo->xmax) /* the data we want */
    {
      do_huff_decode_blocks(cinfo, cinfo->jblocks[1], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], hsamp*vsamp, FALSE);
      asm_huff_decode_blocks(cinfo, cinfo->jblocks[5], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
      asm_huff_decode_blocks(cinfo, cinfo->jblocks[6], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);

      if (cinfo->options & jopt_GREY) /* greyscale output is acceptable */
      {
        dprintf(("", "about to do some grey conversion\n"));
        if (cinfo->options & jopt_OUTBPP_8GREY)
        {
          jpeg_idct_ifast(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
          asm_mono_convert_block_8(cinfo->jblocks[0], outptr, line_offset);
          if (hsamp == 2) asm_mono_convert_block_8(cinfo->jblocks[1], outptr + 2, line_offset);
          if (vsamp == 2)
          {
            asm_mono_convert_block_8(cinfo->jblocks[hsamp == 1 ? 1 : 2], outptr + 8*line_offset, line_offset);
            if (hsamp == 2) asm_mono_convert_block_8(cinfo->jblocks[3], outptr + 8*line_offset + 2, line_offset);
          }
        }
        else
        {
          jpeg_idct_ifast(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
          asm_mono_convert_block(cinfo->jblocks[0], outptr, line_offset);
          if (hsamp == 2) asm_mono_convert_block(cinfo->jblocks[1], outptr + 8, line_offset);
          if (vsamp == 2)
          {
            asm_mono_convert_block(cinfo->jblocks[hsamp == 1 ? 1 : 2], outptr + 8*line_offset, line_offset);
            if (hsamp == 2) asm_mono_convert_block(cinfo->jblocks[3], outptr + 8*line_offset + 8, line_offset);
          }
        }
      }
      else
      {
        dprintf(("", "about to do some colour conversion\n"));
        if (hsamp*vsamp == 4)
        {
          jpeg_idct_ifast(cinfo, cinfo->jblocks[1], 6); /* output in jblocks[0..5] */ /* usual, speed-critical case */
          if (cinfo->options & jopt_OUTBPP_16)
          {
#ifdef ASMCOLOR
            (cinfo->convert_block_16)(cinfo->jblocks[0], (short int*) outptr, line_offset);
#else
            colour_convert_block_16(cinfo->jblocks[0], (short int*) outptr, line_offset);
#endif
          }
          else if (cinfo->options & jopt_OUTBPP_8YUV)
            colour_convert_block_8(cinfo->jblocks[0], (char*) outptr, line_offset);
          else
            colour_convert_block_32(cinfo->jblocks[0], outptr, line_offset);
        }
        else
        {
          jpeg_idct_ifast(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* weird aspect ratio - only do DCTs we need to do */
          jpeg_idct_ifast(cinfo, cinfo->jblocks[5], 2);
          colour_convert_unusual_block(cinfo->jblocks[0], outptr, line_offset, hsamp, vsamp);
        }
      }
      width += 8*hsamp;
      if (cinfo->options & jopt_OUTBPP_16) outptr += 4*hsamp;
      else if (cinfo->options & jopt_OUTBPP_8YUV) outptr += 2*hsamp;
      else if (cinfo->options & jopt_OUTBPP_8GREY) outptr += 2*hsamp;
      else outptr += 8*hsamp;
    }
    nlines_fetched = 8*vsamp;
  }

  return nlines_fetched;
}

d231 71
d307 1
a307 1
                              cinfo->error_argument1 = arg; \
a308 4
#define BADFILE2(reason,arg1,arg2) {dprintf(("", "bad file %d %d %d", reason, arg1, arg2)); \
                                    cinfo->error_code = reason; \
                                    cinfo->error_argument1 = arg1; cinfo->error_argument2 = arg2; \
                                    return reason;}
d310 13
a322 1
int jpeg_scan_file(j_decompress_ptr cinfo, const JOCTET *file_image, size_t image_length,
a323 3
/* Effectively the length of the workspace available is passed in as cinfo->workspace_size,
 * a bit illogical. cinfo->error_code is also important.
 */
d326 2
a327 1
  int vsamp, hsamp;
d329 3
a331 5
#ifdef EMBED
  dprintf(("", "jpeg_scan_file cinfo=0x%x file_image=0x%x image_length=%i xmin=%i xmax=%i width=%i height=%i options=%i\n"
        , (int)cinfo, (int)file_image, image_length, xmin, xmax, width, height, options));
  dprintf(("", "wssize %x\n", cinfo->workspace_size));
#endif
d333 1
d336 2
a337 2
    options &= ~(jopt_OUTBPP_8 | jopt_OUTBPP_16 | jopt_OUTBPP_8YUV);
    dprintf(("", "Clearing 8YUV because of DC_ONLY flag\n"));
d339 1
d341 1
a341 1
  if (options & (jopt_OUTBPP_8 | jopt_OUTBPP_8YUV))
a349 7
#ifdef EMBED
  dprintf(("", "err %x buf %x file %x img %x\n", cinfo->error_code, cinfo->jpeg_buffer, file_image, image_length));
  dprintf(("", "ck1 %x im1 %x\n", cinfo->check1, ((int*)file_image)[image_length/(2*4)]));
  dprintf(("", "ck2 %x im2 %x\n", cinfo->check2, ((int*)file_image)[image_length/4 - image_length/(4*4)]));
  dprintf(("", "ck3 %x im3 %x\n", cinfo->check3, ((int*)file_image)[image_length/4 - image_length/(8*4)]));
#endif

d352 2
a353 2
     && cinfo->jpeg_buffer == file_image                                     /* check for image in same place */
     && cinfo->jpeg_size == image_length                                     /* check length unchanged */
d356 3
a358 3
     && cinfo->check1 == ((int*)file_image)[image_length/(2*4)]                  /* Random checks on data - the /4 gets us down to char offsets */
     && cinfo->check2 == ((int*)file_image)[image_length/4 - image_length/(4*4)] /* we check a word half-way through, and two later on */
     && cinfo->check3 == ((int*)file_image)[image_length/4 - image_length/(8*4)] /* any change will perturb the whole file - we trust! */
d368 1
a368 3
#ifdef EMBED
    dprintf(("", "Exit jpeg_scan_file OK\n\n"));
#endif
d372 7
d380 11
a390 1
  if (cinfo->error_code < 0) cinfo->table32k = 0;
d392 1
a392 2
  /* Clear out the info struct, preserving any possible workspace size. */
  init_workspace(cinfo, cinfo->workspace_size);
d394 8
a401 12
  /* Set up the band buffer pointer. */
  if (cinfo->workspace_size == 0) /* there's no workspace, they just want us to scan the header */
  {
    cinfo->band_buffer = NULL;
    cinfo->band_buffer_size = (64*1024 /* JPEG width limit */) *
                              (8*2 /* 8 x vsamp max */); /* prevent E_TOO_WIDE complaints later on */
  }
  else
  {
    cinfo->band_buffer = (int*)((char*)cinfo + sizeof(struct jpeg_decompress_struct));
    cinfo->band_buffer_size = (cinfo->workspace_size - sizeof(struct jpeg_decompress_struct))/sizeof(int) & 0xfffffff0;
  }
d403 1
a403 9
  /* Set up the check words, to hope for repeated calls on this sprite */
  cinfo->check1 = ((int*)file_image)[image_length/(2*4)];
  cinfo->check2 = ((int*)file_image)[image_length/4 - image_length/(4*4)];
  cinfo->check3 = ((int*)file_image)[image_length/4 - image_length/(8*4)];

  /* Preserve pointers to the jpeg file image */
  cinfo->jpeg_buffer = file_image;
  cinfo->jpeg_size = image_length;
  cinfo->next_input_byte = file_image;
d405 3
a407 2
  /* Read the file header - sets various cinfo fields. */
  read_file_header(cinfo);
d409 1
a409 2
  /* Read the header for the first scan - sets various cinfo fields. */
  read_scan_header(cinfo);
d411 4
a414 8
  /* Initialise any huffman tables present. */
  for (i = 0; i < 4; i++)
  {
    fix_huff_tbl(cinfo, cinfo->dc_huff_tbl_ptrs[i]);
    fix_huff_tbl(cinfo, cinfo->ac_huff_tbl_ptrs[i]);
  }
  dprintf(("", "Huffman tables fixed.\n"));
  dprintf(("", "Image starts at byte %i of JPEG data.\n", cinfo->next_input_byte - cinfo->jpeg_buffer));
d416 1
a416 5
  /* Initialise the first huff decoding stream. */
  huff_decoder_init(cinfo);
  cinfo->current_huff_pointer = -1; /* No band currently unloaded. */
  cinfo->restarts_to_go = cinfo->restart_interval;
  cinfo->next_restart_num = 0;
a420 9
  cinfo->options = options;
  vsamp = cinfo->comp_info[0].v_samp_factor;
  hsamp = cinfo->comp_info[0].h_samp_factor;

  /* Check various limitations of our code. */
  if (cinfo->data_precision != 8) BADFILE1(E_PRE_NOT_8, cinfo->data_precision);
  if (cinfo->num_components != cinfo->comps_in_scan) BADFILE(E_MULTI_SCAN);
  if (cinfo->image_width != width && width != -1) BADFILE1(E_WIDTH_DISAGREES, cinfo->image_width);
  if (cinfo->image_height != height && height != -1) BADFILE1(E_HEIGHT_DISAGREES, cinfo->image_height);
d422 25
a446 6
  /* Allocate the array of pointers into the huffman codes, at the base of where the band
   * buffer currently is.
   */
  {
    int mcu_height = 8 * vsamp; /* 8 or 16 */
    int huff_array_size = sizeof(huff_pointer) * ((cinfo->image_height + mcu_height - 1)/mcu_height); /* in bytes */
d448 1
a448 6
    cinfo->huff_pointers = (huff_pointer*) cinfo->band_buffer;
    cinfo->band_buffer += huff_array_size/sizeof(int);
    cinfo->band_buffer_size -= huff_array_size/sizeof(int);
    if (cinfo->image_width > cinfo->band_buffer_size / mcu_height)
      BADFILE2(E_TOO_WIDE, cinfo->image_width, cinfo->band_buffer_size / mcu_height);
  }
d450 4
a453 2
  /* Now try the specific cases that we can do. */
  switch (cinfo->num_components)
d455 32
a486 6
    case 1:
      dprintf(("", "num_components = 1 (Greyscale file)\n"));

      if (hsamp != 1 || vsamp != 1)
        BADFILE2(E_BAD_SAMPLE, hsamp, vsamp);
      if (cinfo->jpeg_color_space == JCS_GRAYSCALE)
d488 2
a489 16
        int height = 0;
        int hpointer_index = 0;
        JHUFF_TBL *dc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
        JHUFF_TBL *ac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
        JQUANT_TBL * quanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];

        options &= ~(jopt_OUTBPP_16 | jopt_OUTBPP_8YUV); /* haven't got optimised colour conversion for 16bpp output */

        while (height < cinfo->image_height)
        {
          /* save the state of the huff stream. */
          save_huff_stream(cinfo, &cinfo->huff_pointers[hpointer_index]);
          hpointer_index++;
          do_huff_skip_blocks(cinfo, cinfo->jblocks[0], dc, ac, quanttbl, &cinfo->last_dc_val[0], (cinfo->image_width + 7) >> 3, TRUE);
          height += 8;
        }
d491 7
a497 11
      else
        BADFILE1(E_COLOUR, cinfo->jpeg_color_space);
      break;

    case 3:
      dprintf(("", "num_components = 3 (YUV file)\n"));

      /* We expect an MCU (minimum coding unit) of 2x2 Y blocks to each U and V block.
       * We will accept MCUs of 1x1:1:1 or 2x1:1:1 and 1x2:1:1 as well, since there
       * are examples of this.
       * JFIF allows an arbitrary ratio - seems uncecessary. A band is always 1 MCU high.
d499 4
a502 19
      if (hsamp > 2 || vsamp > 2)
        BADFILE2(E_BAD_SAMPLE, hsamp, vsamp);
      if (cinfo->comp_info[1].h_samp_factor != 1 || cinfo->comp_info[1].v_samp_factor != 1)
        BADFILE2(E_BAD_SAMPLE, cinfo->comp_info[1].h_samp_factor, cinfo->comp_info[1].v_samp_factor);
      if (cinfo->comp_info[2].h_samp_factor != 1 || cinfo->comp_info[2].v_samp_factor != 1)
        BADFILE2(E_BAD_SAMPLE, cinfo->comp_info[2].h_samp_factor, cinfo->comp_info[2].v_samp_factor);
      if (cinfo->jpeg_color_space == JCS_YCbCr)
      {
        int height = 0;
        int hpointer_index = 0;
        JHUFF_TBL *ydc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
        JHUFF_TBL *yac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
        JQUANT_TBL * yquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];
        JHUFF_TBL *udc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[1]->dc_tbl_no];
        JHUFF_TBL *uac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[1]->ac_tbl_no];
        JQUANT_TBL * uquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[1]->quant_tbl_no];
        JHUFF_TBL *vdc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[2]->dc_tbl_no];
        JHUFF_TBL *vac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[2]->ac_tbl_no];
        JQUANT_TBL * vquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[2]->quant_tbl_no];
d504 4
a507 31
        if (hsamp != 2 || vsamp != 2) options &= ~(jopt_OUTBPP_16 | jopt_OUTBPP_8YUV); /* haven't got optimised colour conversion for unusual colour blocks */
  
        while (height < cinfo->image_height)
        {
          int width;

          /* save the state of the huff stream. */
          save_huff_stream(cinfo, &cinfo->huff_pointers[hpointer_index]);
          hpointer_index++;
  
          width = 0;
          while (width < cinfo->image_width)
          {
            /* Skip over the six blocks representing this square of pixels */
            do_huff_skip_blocks(cinfo, cinfo->jblocks[1], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], hsamp * vsamp, FALSE);
            asm_huff_skip_blocks(cinfo, cinfo->jblocks[5], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
            asm_huff_skip_blocks(cinfo, cinfo->jblocks[6], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
            width += 8 * hsamp;
          }
          height += 8 * vsamp;
        }
      }
      else
        BADFILE1(E_COLOUR, cinfo->jpeg_color_space);
      break;

    case 4:
      dprintf(("", "num_components = 4 (CMYK file)\n"));
    default:
      BADFILE1(E_COMPONENTS, cinfo->num_components);
      break;
d512 1
a512 1
    int size_per_line = cinfo->band_buffer_size / (8 * hsamp);
d515 1
a515 1
      cinfo->error_argument1 |= jopt_INTERP_X; /* signal that we'll do it */
d517 1
a517 1
      cinfo->options &= ~jopt_INTERP_X; /* not enough space - remember that we won't do it */
d519 5
a523 5
  if (options & jopt_OUTBPP_8) cinfo->error_argument1 |= jopt_OUTBPP_8;
  if (options & jopt_OUTBPP_16) cinfo->error_argument1 |= jopt_OUTBPP_16;
  if (options & jopt_OUTBPP_8YUV) cinfo->error_argument1 |= jopt_OUTBPP_8YUV;
  if (options & jopt_OUTBPP_8GREY) cinfo->error_argument1 |= jopt_OUTBPP_8GREY;
  cinfo->options = options; /* in case processing above has discovered options we're not prepared to do */
d526 1
a526 1
  dprintf(("", "cinfo->erooarg1 = %d\n", cinfo->error_argument1));
d531 1
a531 1
  if (options & jopt_OUTBPP_8) dprintf(("", "  jopt_OUTBPP_8\n"));
d538 2
a539 3
#ifdef EMBED
  dprintf(("", "Exit jpeg_scan_file OK (2)\n\n"));
#endif
d543 7
a549 3
int *jpeg_find_line(j_decompress_ptr cinfo, int ycoord, int *palette_data)
/* This gets called for every line of a rendered image. Most of the time it is fast,
 * every 8 or 16 lines or so it must do some de-JPEGing of some more data.
d551 1
d553 2
a554 4
  int  hpointer; /* huff pointer index */
  int  l2_band_height = 2 + cinfo->comp_info[0].v_samp_factor; /* log2 of band height - 3 for mono, usually 4 for colour */
  int  line_offset = cinfo->band_buffer_size >> l2_band_height; /* offset in words between lines of output */
  int *result;
d558 5
a562 5
  ycoord = cinfo->image_height - ycoord - 1; /* coordinates fed into this are RISC OS-style, with 0
                                              * meaning the bottom row. Reverse this so that 0 means
                                              * the top row.
                                              */
  assert(cinfo->band_buffer != NULL, ERROR_FATAL); /* someone had better have provided one! */
d565 1
a565 1
  hpointer = ycoord >> l2_band_height;
d567 2
a568 1
  if (hpointer != cinfo->current_huff_pointer) /* Fetch a line */
d570 3
a572 1
    int nlines_fetched = 0;
d574 1
a574 2
    cinfo->current_huff_pointer = -1; /* in case of error exit - set correctly at end */
    restore_huff_stream(cinfo, &cinfo->huff_pointers[hpointer]); /* restore the huffman stream */
d576 23
a598 6
    /* Get a row of blocks into the band buffer */
    switch (cinfo->num_components)
    {
      case 1:
        nlines_fetched = do_1_component_band(cinfo, line_offset); /* Greyscale */
        break;
d600 2
a601 3
      case 3:
        nlines_fetched = do_3_component_band(cinfo, line_offset); /* YUV */
        break;
d603 8
a610 4
      case 4:
      default:
        /* These were rejected in jpeg_scan_file() */
        break;
d615 2
a616 2
      int *line = cinfo->band_buffer + cinfo->xmin;
      int linelen = cinfo->xmax - cinfo->xmin;
d623 1
d626 1
d640 1
a640 1
      if (cinfo->options & jopt_OUTBPP_8)
a641 2
        char *outptr = (char *)cinfo->band_buffer + cinfo->xmin;

d647 1
a647 3
          asm_diffuse_to_8bpp(line, blockwidth, outptr, cinfo->table32k, nlines_fetched, line_offset, palette_data);
          outptr += blockwidth;
          line += blockwidth;
d649 2
a650 1
          dprintf(("", "done diffusion, outptr = &%x, blockwidth = &%xlinelen = &%x\n", outptr, blockwidth, linelen));
a654 2
        int *outptr = cinfo->band_buffer + cinfo->xmin;

d660 1
a660 3
          asm_diffuse_to_24bpp(line, blockwidth, outptr, cinfo->table32k, nlines_fetched, line_offset, palette_data);
          outptr += blockwidth;
          line += blockwidth;
d662 2
a663 1
          dprintf(("", "done diffusion, outptr = &%x, blockwidth = &%xlinelen = &%x\n", outptr, blockwidth, linelen));
d668 1
a668 1
    cinfo->current_huff_pointer = hpointer; /* line completed correctly - remember for next time. */
a670 1
  result = cinfo->band_buffer; /* the band buffer now contains suitable pixels */
d674 2
a675 1
     * and the address frigged here to point to one or the other
d677 1
a677 2
    if (l2_band_height == 4 && (ycoord & 0xf) >= 8)
      result += line_offset;
d681 2
a682 2
    /* normal - choose between 8 or 16 rows of pixels */
    result += (ycoord & ((1 << l2_band_height) - 1)) * line_offset;
a683 2
  
  return result;
d686 11
a696 1

a697 7
/* Find basic dimensions of a JPEG file. Not done via main scanning code so
 * that you can decide these things before you allocate the band buffer etc.
 * Returns one of a) is a JPEG, can be rendered by me
 *                b) looks like a JPEG, but can't be rendered by me
 *                c) is not a valid JPEG
 * or an OS error if a SWI fails during the decision making. 
 */
d700 1
d703 1
a703 1
  size_t    markerlen, advance;
d760 1
a760 1
#define M_READAHEAD_MAX 15 /* Longest read within marker of interest. M_APP0 wins the prize. */
d819 1
a820 6
        if (jdata[3] != 8) /* need 8 bits per component */
        {
          e = jfid_CANT_RENDER;
          goto finish;
        } 
        hadsof = TRUE;
d825 15
d890 1
a890 1
      case M_TEM: /* no paramters with these markers */
d894 1
a894 1
        /* Fall through */
d912 8
a919 8
  /* This is pessimistic overall for files with strange Y:U:V sample ratios - don't care.
   * (estimate for the huff_pointer array is optimistic, but the band buffer
   * size is vastly pessimistic)
   */
  new_size = sizeof(struct jpeg_decompress_struct) + 1024 +
             sizeof(huff_pointer) * (comps == 1 ? ((iheight + 7)/8) : ((iheight + 15)/16)) +
             (comps == 1 ? 8 : 16) * (iwidth + 15) * sizeof(int);
  new_size = (new_size + 3) & ~3; /* round up to a multiple of 4 */
d935 1
a935 1
    int                  page_size;
@


4.27
log
@Update headers to stock copy
Detail:
  Added headers jerror, jmorecfg, jpegint from IJG8d. Removed jpegdata header.
  Bulk rename of structure members to match newer headers, some RISCOS-isms wrapped in #ifdef RISCOS, retained for the time being.
  Assembler code now gets cinfo member offsets from jhdr.s derived from the C header rather than keeping its own dangerous copy of the offsets.
Admin
  Note: this has broken CFSI-jpeg as it expects the error values to be at the top of cinfo.
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_70-headers.
@
text
@d33 2
a34 1
#define tracef(args)     /* Nothing */
a37 1
#define IFDEBUG(a)       /* Nothing */
d61 6
a66 6
  tracef("Corrupted data in Huffman stream at byte %i\n" _ (char*)regblock[3] - (char*)cinfo->jpeg_buffer);
  tracef("cinfo=0x%x regblock=0x%x code=%i.\n" _ (int)cinfo _ (int)regblock _ code);
  for (i = 0; i < 16; i++) tracef("R%i=0x%x\n" _ i _ regblock[i]);
  tracef("Nearby input bytes:\n");
  for (i = -10; i < 10; i++) tracef("%i:0x%x " _ i _ ((char*)(regblock[3]))[i]);
  tracef("\n");
d111 1
a111 1
    tracef("Malloc requesting %x bytes of workspace\n" _ jpeg_ws_size);
d122 1
a122 1
      tracef("Realloc requesting %x extra bytes of workspace\n" _ jpeg_ws_size);
d168 1
a168 1
      tracef("need %x bytes for palette\n" _ size);
d188 1
a188 1
        tracef("trying new shiny 8BPP plotting technique\n");
d191 1
a191 1
        tracef("need %x bytes for palette\n" _ size);
d194 1
a194 1
        tracef("created palette at %x\n" _ &(wp->newtranstable[0]));
d196 1
a196 1
        tracef("Read palette, palette entries are:-\n");
d198 1
a198 1
          tracef("Entry %d = %x\n" _ loop _ wp->newtranstable[loop]);
d245 9
a253 9
  tracef("After set up, options are:\n");
  if (opt & jopt_GREY) tracef("   jopt_GREY\n");
  if (opt & jopt_DC_ONLY) tracef("   jopt_DC_ONLY\n");
  if (opt & jopt_INTERP_X) tracef("   jopt_INTERP_X\n");
  if (opt & jopt_OUTBPP_8) tracef("   jopt_OUTBPP_8\n");
  if (opt & jopt_OUTBPP_16) tracef("   jopt_OUTBPP_16\n");
  if (opt & jopt_OUTBPP_8YUV) tracef("   jopt_OUTBPP_8YUV\n");
  if (opt & jopt_DIFFUSE) tracef("   jopt_DIFFUSE\n");
  if (opt & jopt_OUTBPP_8GREY) tracef("   jopt_OUTBPP_8GREY\n");
d300 1
a300 1
  tracef("Processing restart marker %i at %i bytes\n" _ cinfo->next_restart_num _ cinfo->next_input_byte - cinfo->jpeg_buffer);
d303 3
a305 3
    tracef("inbuf=0x%x nbits=%i inptr=0x%x file=0x%x\n" _ cinfo->get_buffer _ cinfo->bits_left _ (int)cinfo->next_input_byte _ (int)cinfo->jpeg_buffer);
    for (i = -10; i < 10; i++) tracef("%i:0x%x " _ i _ cinfo->next_input_byte[i]);
    tracef("\n");
d361 1
a361 1
    tracef("oops restore_huff_stream: 0x%x 0x%x 0x%x\n" _ (int)cinfo->jpeg_buffer _ (int)cinfo->next_input_byte _ (int)cinfo->jpeg_size);
d440 1
a440 1
  tracef("in do_1_component_band\n");
d525 1
a525 1
  tracef("in do_3_component_band\n");
d559 1
a559 1
        tracef("about to do replicate some luma\n");
d589 1
a589 1
        tracef("about to do YUV to greyscale\n");
d622 1
a622 1
        tracef("about to do some grey conversion\n");
d648 1
a648 1
        tracef("about to do some colour conversion\n");
d690 1
a690 1
#define BADFILE(reason) {tracef("bad file %d" _ reason); \
d693 1
a693 1
#define BADFILE1(reason,arg) {tracef("bad file %d %d" _ reason _ arg); \
d697 1
a697 1
#define BADFILE2(reason,arg1,arg2) {tracef("bad file %d %d %d" _ reason _ arg1 _ arg2); \
d712 3
a714 3
  tracef("jpeg_scan_file cinfo=0x%x file_image=0x%x image_length=%i xmin=%i xmax=%i width=%i height=%i options=%i\n"
         _ (int)cinfo _ (int)file_image _ image_length _ xmin _ xmax _ width _ height _ options);
  tracef("wssize %x\n" _ cinfo->workspace_size);
d720 1
a720 1
    tracef("Clearing 8YUV because of DC_ONLY flag\n");
d733 4
a736 4
  tracef("err %x buf %x file %x img %x\n" _ cinfo->error_code _ cinfo->jpeg_buffer _ file_image _ image_length);
  tracef("ck1 %x im1 %x\n" _ cinfo->check1 _ ((int*)file_image)[image_length/(2*4)]);
  tracef("ck2 %x im2 %x\n" _ cinfo->check2 _ ((int*)file_image)[image_length/4 - image_length/(4*4)]);
  tracef("ck3 %x im3 %x\n" _ cinfo->check3 _ ((int*)file_image)[image_length/4 - image_length/(8*4)]);
d751 1
a751 1
    tracef("This looks like the same JPEG file as last time.\n");
d758 1
a758 1
    tracef("Exit jpeg_scan_file OK\n\n");
d804 2
a805 2
  tracef("Huffman tables fixed.\n");
  tracef("Image starts at byte %i of JPEG data.\n" _ cinfo->next_input_byte - cinfo->jpeg_buffer);
d844 1
a844 1
      tracef("num_components = 1 (Greyscale file)\n");
d872 1
a872 1
      tracef("num_components = 3 (YUV file)\n");
d926 1
a926 1
      tracef("num_components = 4 (CMYK file)\n");
d948 10
a957 10
  tracef("cinfo->erooarg1 = %d\n" _ cinfo->error_argument1);
  tracef("After scan file, options are:\n");
  if (options & jopt_GREY) tracef("  jopt_GREY\n");
  if (options & jopt_DC_ONLY) tracef("  jopt_DC_ONLY\n");
  if (options & jopt_INTERP_X) tracef("  jopt_INTERP_X\n");
  if (options & jopt_OUTBPP_8) tracef("  jopt_OUTBPP_8\n");
  if (options & jopt_OUTBPP_16) tracef("  jopt_OUTBPP_16\n");
  if (options & jopt_OUTBPP_8YUV) tracef("  jopt_OUTBPP_8YUV\n");
  if (options & jopt_DIFFUSE) tracef("  jopt_DIFFUSE\n");
  if (options & jopt_OUTBPP_8GREY) tracef("  jopt_OUTBPP_8GREY\n");
d961 1
a961 1
  tracef("Exit jpeg_scan_file OK (2)\n\n");
d976 1
a976 1
  tracef("jpeg_find_line, palette data at %x\n" _ palette_data);
d1032 1
a1032 1
        tracef("Fetched 32k lookup table, at 0x%x\n" _ (int) cinfo->table32k);
d1044 1
a1044 1
          tracef("calling diffuse to 8bpp code. palette = %x\n" _ palette_data);
d1049 1
a1049 1
          tracef("done diffusion, outptr = &%x, blockwidth = &%xlinelen = &%x\n" _ outptr _ blockwidth _ linelen);
d1060 1
a1060 1
          tracef("calling diffuse to palette entries code. palette = %x\n" _ palette_data);
d1065 1
a1065 1
          tracef("done diffusion, outptr = &%x, blockwidth = &%xlinelen = &%x\n" _ outptr _ blockwidth _ linelen);
d1113 1
a1113 1
  tracef("Find image dims called.\n");
d1119 1
a1119 1
    tracef("We think it's a filename '%s'\n" _ jdata);
d1125 1
a1125 1
      tracef("Failed to open '%s', '%s'\n" _ jdata _ e->errmess);
d1129 1
a1129 1
    tracef("Going to scan top of handle %d into buffer = %p\n" _ file_handle _ buffer);
d1134 1
a1134 1
    tracef("Got jdata = %x, data_end = %x\n" _ jdata _ dataend);
d1137 1
a1137 1
  tracef("jdata = %x\n" _ jdata);
d1147 1
a1147 1
    tracef("Even a cursory look shows it ain't a jpeg\n");
d1171 1
a1171 1
      tracef("Loading another chunk. jdata = %x, offset = %x\n" _ jdata _ offset);
d1246 2
a1247 2
        tracef("pixel density type %x\n" _ jdata[10]);
        tracef("  jdata[11-14], %02x%02x %02x%02x\n" _ jdata[11] _ jdata[12] _ jdata[13] _ jdata[14]);
d1287 1
a1287 1
        tracef("skip tag = %x\n" _ jdata[0]);
d1296 1
a1296 1
    tracef("no APP0 tag, assuming a 1:1 xdpi to ydpi ratio\n");
d1300 1
a1300 1
  tracef("pixel density is %d\n" _ ipixel_density);
d1352 1
a1352 1
    tracef("We need another %x bytes\n" _ new_size);
@


4.26
log
@Rewrite of find_image_dims
Detail:
  Now handles 0xFF padding, previously acceptable encoded images including padding were incorrectly rejected.
  Calculate the workspace for greyscale images correctly, the itype flags included the density (and latterly the SOF) flags, but the workspace calculation assumed it only contained 1 or 3 (for colour components).
  Exit cases now made common and propagate file errors correctly.
  Minor changes to the assembler that uses find_image_dims to handle 4 colour component return (now a 3 bit return value).
  Merge the other M_THING enum from IJG8d so we don't need our own copy.
  Fix signed pointer comparison.
  Use symbolic defines from Global & Interface headers where possible.
  The jdata pointer arg is now treated as const.
Admin:
  Submission for the JPEG bounty.

Version 1.70. Tagged as 'SprExtend-1_70'
@
text
@a22 1
#include "jinclude.h"
d52 1
a52 1
void panic_trace(decompress_info_ptr cinfo, int *regblock, int code)
d84 1
a84 1
  decompress_info_ptr cinfo = (decompress_info_ptr) space;
d94 1
a94 1
  decompress_info_ptr cinfo = (decompress_info_ptr) space;
d107 1
a107 1
  decompress_info_ptr cinfo = wp->jpeg_info_ptr;
d133 1
a133 1
static int jpeg_decompressor_opts(decompress_info_ptr cinfo, asm_workspace *wp)
d260 1
a260 1
static void init_workspace(decompress_info_ptr cinfo, int size)
d282 1
a282 1
    cinfo->quant_tbl_ptrs[i] = (QUANT_VAL*) &cinfo->s_quant_tbl[i];
d291 1
a291 1
static void process_restart(decompress_info_ptr cinfo)
d328 1
a328 1
static void save_huff_stream(decompress_info_ptr cinfo, huff_pointer *h)
d340 3
a342 3
  h->last_dc_val0 = cinfo->last_dc_val[0];
  h->last_dc_val1 = cinfo->last_dc_val[1];
  h->last_dc_val2 = cinfo->last_dc_val[2];
d347 1
a347 1
static void restore_huff_stream(decompress_info_ptr cinfo, huff_pointer *h)
d353 3
a355 3
  cinfo->last_dc_val[0] = h->last_dc_val0;
  cinfo->last_dc_val[1] = h->last_dc_val1;
  cinfo->last_dc_val[2] = h->last_dc_val2;
d368 3
a370 3
do_huff_skip_blocks(decompress_info_ptr cinfo, JBLOCK block,
                    HUFF_TBL *dctbl, HUFF_TBL *actbl, QUANT_TBL_PTR quanttbl,
                    int *last_dc_val, int nblocks, BOOL block_per_mcu)
d397 3
a399 3
do_huff_decode_blocks(decompress_info_ptr cinfo, JBLOCK block,
                      HUFF_TBL *dctbl, HUFF_TBL *actbl, QUANT_TBL_PTR quanttbl,
                      int *last_dc_val, int nblocks, BOOL block_per_mcu)
d431 1
a431 1
static int do_1_component_band(decompress_info_ptr cinfo, int line_offset)
d436 3
a438 3
  QUANT_TBL_PTR quanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];
  HUFF_TBL *dc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
  HUFF_TBL *ac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
d464 1
a464 1
      pix = mono_convert_pixel(cinfo->last_dc_val[0] * quanttbl[0]);
d508 1
a508 1
static int do_3_component_band(decompress_info_ptr cinfo, int line_offset)
d513 9
a521 9
  HUFF_TBL *ydc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
  HUFF_TBL *yac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
  QUANT_TBL_PTR yquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];
  HUFF_TBL *udc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[1]->dc_tbl_no];
  HUFF_TBL *uac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[1]->ac_tbl_no];
  QUANT_TBL_PTR uquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[1]->quant_tbl_no];
  HUFF_TBL *vdc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[2]->dc_tbl_no];
  HUFF_TBL *vac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[2]->ac_tbl_no];
  QUANT_TBL_PTR vquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[2]->quant_tbl_no];
d549 1
a549 1
      y[0] = cinfo->last_dc_val[0] * yquanttbl[0];
d553 1
a553 1
        y[i] = cinfo->last_dc_val[0] * yquanttbl[0];
d590 2
a591 2
        u = cinfo->last_dc_val[1] * uquanttbl[0];
        v = cinfo->last_dc_val[2] * vquanttbl[0];
d702 1
a702 1
int jpeg_scan_file(decompress_info_ptr cinfo, const JOCTET *file_image, size_t image_length,
d778 2
a779 2
    cinfo->band_buffer = (int*)((char*)cinfo + sizeof(struct decompress_info_struct));
    cinfo->band_buffer_size = (cinfo->workspace_size - sizeof(struct decompress_info_struct))/sizeof(int) & 0xfffffff0;
d848 1
a848 1
      if (cinfo->jpeg_color_space == CS_GRAYSCALE)
d852 3
a854 3
        HUFF_TBL *dc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
        HUFF_TBL *ac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
        QUANT_TBL_PTR quanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];
d885 1
a885 1
      if (cinfo->jpeg_color_space == CS_YCbCr)
d889 9
a897 9
        HUFF_TBL *ydc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
        HUFF_TBL *yac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
        QUANT_TBL_PTR yquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];
        HUFF_TBL *udc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[1]->dc_tbl_no];
        HUFF_TBL *uac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[1]->ac_tbl_no];
        QUANT_TBL_PTR uquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[1]->quant_tbl_no];
        HUFF_TBL *vdc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[2]->dc_tbl_no];
        HUFF_TBL *vac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[2]->ac_tbl_no];
        QUANT_TBL_PTR vquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[2]->quant_tbl_no];
d966 1
a966 1
int *jpeg_find_line(decompress_info_ptr cinfo, int ycoord, int *palette_data)
d1307 1
a1307 1
  new_size = sizeof(struct decompress_info_struct) + 1024 +
d1325 1
a1325 1
    decompress_info_ptr  cinfo;
d1329 1
a1329 1
    cinfo = (decompress_info_ptr)*ws_size;
@


4.25
log
@Add support for blended sprite & JPEG rendering - alpha masks, alpha channels, and translucency
Detail:
  This big set of changes adds support for the following user-facing APIs, as per ROL's specs:
  - OS_SpriteOp 52 (PutSpriteScaled) colour mapping, translucency blending, and alpha mask/alpha channel blending
  - OS_SpriteOp 56 (PutSpriteTransformed) colour mapping, translucency blending, and alpha mask/alpha channel blending
  - JPEG_Plot[File]Scaled colourmapping & translucency blending
  - JPEG_Plot[File]Transformed colourmapping & translucency blending
  Sources/CFSI-JPEG, Sources/PutScaled:
  - Added exit_oserror exit routine for use by C code.
  - For SpriteExtend this allows the C code to cause OS_SpriteOp to exit with a given OS error block.
  - For CFSI-JPEG the error block is returned and ERROR_FATAL is returned to ChangeFSI.
  Sources/CSupport:
  - Add definitions for some error codes (matches existing definitions from h/commondefs)
  Sources/PutScaled:
  - Stripped out code to look for identity translation tables; now handled by preparettr routine in Sources/SprOp
  Sources/SWIs, Hdr/SprExtend:
  - JPEG SWIs updated to add support for alpha-blended and colour mapped JPEG rendering, following ROL's APIs
  Sources/SprExtend:
  - Stripped out lots of old build flags which haven't been touched in years.
  - Strip out assembler SprTrans code generator.
  - Add new definitions needed for blending & colour mapping.
  Sources/SprOp:
  - Updated PutScaled frontend to deal with blending and colour mapping.
  - Disabled code which was bodging coordinates when dealing with double-pixel modes - it seems to cause a few issues, and the code generator mostly had proper double-pixel support anyway.
  - Translation table verification and fiddling code rewritten and consolidated into the preparettr routine. C code is now explicitly told what table type is in use and whether it can safely be ignored in favour of using the sprite palette.
  - Removed code from CheckSpriteArea which was deliberately throwing an error upon seeing alpha-masked sprites; I think the bug that was hiding has been fixed now
  Sources/SprTrans
  - Removed the assembler version of the code generator.
  - Updated to add support for blending and colour mapping
  c/PutScaled:
  - Old test code removed.
  - Updated to add support for blending & colour mapping
  - Assorted bugs fixed.
  - A few extra architecture-specific optimisations added.
  - Some workspace setup code moved to c/asmcore to allow sharing with SprTrans.
  c/asmcore:
  - Register allocation code rewritten. Instead of allocating on a first-come, first-served basis, the code now builds a list of which logical registers are needed (and which 'banks' they fall into) and then attempts to allocate them in a more intelligent manner. It still has some failings (e.g. reusing R12 as a general purpose register is currently impossible) but it's a lot more flexible and reliable than the old code.
  - Core pixel transformation code updated to add support for blending & colour mapping
  - Added some extra architecture-specific optimisations
  c/rojpeg:
  - JPEG option handling updated to avoid trashing any colour mapping descriptor that may have been passed in
  c/sprtrans:
  - Updated to add support for blending & colour mapping
  c/tracing:
  - Debug assert messages now show filename as well as line number
  h/commondefs:
  - Removed old #define's that related to old assembler switches.
  h/putscaled:
  - Workspace definition updated to match assembler version.
  - SprTrans stack workspace structure moved here from c/sprtrans
Admin:
  Tested on BB-xM plotting all major sprite & JPEG types into all modes with all major options


Version 1.55. Tagged as 'SprExtend-1_55'
@
text
@d15 1
a15 1
/* c.rojpeg - JPEG for use within RISC OS */
d18 1
d20 2
d186 1
a186 1
  #ifdef DEBUG
d188 1
a188 1
  #endif
d196 1
a196 1
  #ifdef DEBUG
d200 1
a200 1
  #endif
d232 1
a232 1
          _swix(OS_ReadModeVariable, _IN(0) | _IN(1) | _OUT(2), -1, 0, &modeflags);
d1092 8
a1099 22
#define M_APP0        0xE0
#define M_APP1        0xE1
#define M_SOI         0xd8
#define M_EOI         0xd9
#define M_SOS         0xda
#define M_SOFMASK     0xF0
#define M_SOFANY      0xC0
#define M_DHT         0xc4 /* False positives */
#define M_DAC         0xcc /* False positives */
#define M_JPG         0xc8 /* False positives */
#define M_SOF0        0xc0 /* Baseline */
#define M_SOF1        0xc1 /* Extended sequential */
#define IS_AN_SOF(k)  (((k & M_SOFMASK)==0xC0) && (k!=M_DHT) && (k!=M_DAC) && (k!=M_JPG))

int find_image_dims(char *jdata, image_dims_info *image, int *ws_size)
/* Code to find basic dimensions of a JPEG file. Not done via main scanning
 * code so that you can decide these things before you allocate the band buffer
 * etc.
 * Returns 0 if all is OK
 *         1 if this is not kosher JPEG data
 *         2 if this is valid JPEG data but cannot be rendered by SpriteExtend
 *         > 2 is an OS error pointer
d1102 5
a1106 3
  int             iwidth, iheight;
  int             itype = 0;
  int             new_size;
d1108 4
a1111 6
  BOOL            load_file;
  char            buffer[1024];
  int             file_handle,
                  dataend;
  int             pixel_density;
  _kernel_oserror *e;
d1116 1
a1116 1
  /* Bit 0 clear means its all in memory, else load from file */
d1121 4
a1124 2
    e = _swix(OS_Find, _IN(0) | _IN(1) | _OUT(0), 0x4f, jdata, &file_handle);
    if (e != 0) /* failed to open the file */
d1126 2
a1127 2
      tracef("e points to err %x '%s'\n" _ e->errnum _ e->errmess);
      return ((int)e);
d1130 5
a1134 8
    tracef("Going to scan top of handle %d into buffer = %x\n" _ file_handle _ buffer);
    e = _swix(OS_GBPB, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _OUT(2),
                  4, file_handle, jdata, sizeof(buffer), &dataend);
    if (e != 0)
    {
      _swix(OS_Find, _IN(0) | _IN(1), 0, file_handle);
      return ((int)e);
    }
d1144 1
d1146 1
a1146 1
  if (jdata[0] != 0xff || jdata[1] != M_SOI || jdata[2] != 0xff)
d1149 2
a1150 56
#ifndef CFSI
    if (load_file)
    {
      e = _swix(OS_Find, _IN(0) | _IN(1), 0, file_handle);
      if (e != 0) return ((int)e);
    }
#endif
    return 1;
  }

#ifndef CFSI
  if (jdata[3] == M_APP0)
  {
    int xdens, ydens;

    tracef("pixel density is %x\n" _ jdata[13]);
    tracef("  jdata[14-17], %x %x %x %x\n" _ jdata[14] _ jdata[15] _ jdata[16] _ jdata[17]);
    switch (jdata[13]) /* from JFIF 1.02 definition, if APP0 exists the density units will be here */
    {
      case 0:
        xdens = STANDARDDPI;
        ydens = (jdata[14] << 8) + jdata[15]; /* take into account the case where the scale may be 0:0, pah! */
        if (ydens == 0) ydens = 1;
        ydens = ((jdata[16] << 8) + jdata[17]) / ydens;
        if (ydens == 0)
          ydens = STANDARDDPI;
        else
          ydens *=STANDARDDPI;
        pixel_density = (xdens << 16) | ydens;
        itype |= 0x80;    /* set bit in type word to indicate density is only a ratio */
        break;

      case 1:
        pixel_density = (jdata[14] << 24) + (jdata[15] << 16) + (jdata[16] << 8) + jdata[17];
        /* Should make pixel_density = [XdenHigh XdenLow YdenHigh YdenLow] */
        break;

      case 2:
        pixel_density = (int)(jdata[14]*CMTOINCH_NUM/CMTOINCH_DEN) << 24 + (int)(jdata[15]*CMTOINCH_NUM/CMTOINCH_DEN) << 16
                         + (int)(jdata[16]*CMTOINCH_NUM/CMTOINCH_DEN) << 8 + (int)(jdata[17]*CMTOINCH_NUM/CMTOINCH_DEN);
        break;

      default:
        if (load_file)
        {
          e = _swix(OS_Find, _IN(0) | _IN(1), 0, file_handle);
          if (e != 0) return ((int)e);
        }
        return 1;
    }
  }
  else
  {
    tracef("no APP0 tag, assuming a 1:1 xdpi to ydpi ratio\n");
    itype |= 0x80;    /* set bit in type word to indicate density is only a ratio */
    pixel_density = (STANDARDDPI << 16) | STANDARDDPI;
d1152 1
a1152 2
  tracef("pixel density is %d\n" _ pixel_density);
#endif
d1156 1
d1158 1
a1158 5
  jdata += 2; /* skip over 0xFF, SOI(0xd8) */
  while (jdata[0] == 0xff &&
         !IS_AN_SOF(jdata[1]) && /* until we get to any SOF marker */
         jdata[1] != M_SOS &&
         jdata[1] != M_EOI) /* or start of scan or end of image */
d1160 1
a1160 2
    tracef("skip tag = %x\n" _ jdata[1]);
    jdata += (jdata[2] << 8) + jdata[3] + 2; /* skip over variable length marker */
d1162 2
a1163 1
    if (load_file && ((int)jdata >= dataend))  /* need to load up more data */
d1165 2
a1166 2
      int   offset = (int)jdata - dataend;
      int   current;
d1168 1
a1168 1
      /* Next tag isn't in the 1k of RAM so jump forward and load another 1k
d1170 1
a1170 1
       * danger of reading the 'next offset' from off the end of buffer
d1173 3
a1175 1
      _swix(OS_Args, _IN(0) | _IN(1) | _OUT(2), 0, file_handle, &current);
d1177 6
a1182 3
      e = _swix(OS_GBPB, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _IN(4) | _OUT(2),
                    3, file_handle, jdata, sizeof(buffer), current + offset, &dataend);
      if (e != 0)
d1184 2
a1185 7
        _swix(OS_Find, _IN(0) | _IN(1), 0, file_handle);
        return ((int)e);
      }
      if ((int)jdata == dataend)
      {
        jdata[1] = M_EOI;
        break; /* nothing was transferred, must be EOF */
d1189 103
d1294 2
a1295 1
  if (jdata[1] == M_SOF0 || jdata[1] == M_SOF1) /* found a supported SOF marker */
d1297 3
a1299 13
    iheight = (jdata[5] << 8) + jdata[6];
    iwidth = (jdata[7] << 8) + jdata[8];
    itype |= jdata[9]; /* 1 for monochrome or 3 for YUV, the other state we can accept. */
    itype |= ((jdata[1] & ~M_SOFMASK) << 8); /* mix in the 4 bit SOF type */
  }
  else
  {
    tracef("Header looks like JPEG data, but not not one we recognise.\n");
#ifndef CFSI
    if (load_file) _swix(OS_Find, _IN(0) | _IN(1), 0, file_handle);
#endif    
    if (jdata[1] == M_SOS || jdata[1] == M_EOI) return 1;
    return 2; /* wrong sort of entropy encoding. */
d1301 2
d1309 2
a1310 2
             sizeof(huff_pointer) * (itype == 1 ? ((iheight + 7)/8) : ((iheight + 15)/16)) +
             (itype == 1 ? 8 : 16) * (iwidth + 15) * sizeof(int);
d1319 1
a1319 1
    image->density = pixel_density;
d1355 1
a1355 11

  if (load_file) /* We need to close the file... */
  {
    tracef("closing file\n");
    e = _swix(OS_Find, _IN(0) | _IN(1), 0, file_handle);
    if (e != 0)
    {
      return ((int)e);
    }
  }
#else /* CFSI */
d1361 1
d1363 8
a1370 1
  return 0; /* all is well */
@


4.24
log
@Fix crash when directly producing 16bpp output from JPEGs
Detail:
  c/rojpeg - The init_workspace() function called from jpeg_scan_file() was trashing the YUV -> 16bpp decode function pointer that had been set earlier, causing a nice crash if 16bpp output was actually being used. Now fixed to preserve the pointer when resetting workspace.
Admin:
  Tested on BB-xM
  Fixes issue reported on forums with Phoenix and JPEG viewers crashing in 16bpp modes:
  https://www.riscosopen.org/forum/forums/4/topics/2094


Version 1.54. Tagged as 'SprExtend-1_54'
@
text
@a136 11
  if (wp->BPP < 4)
  {
    opt |= jopt_GREY; /* greyscale if 4bpp or less */
    if ((wp->save_PdriverIntercept & 2) == 0) /* printing is not on */
      wp->ColourTTR = 0; /* don't use trans table for 4bpp or less, results are naff */
  }
  if ((wp->BPP <=8) && (wp->dither_truecolour & 2))
  {
    opt |= jopt_DIFFUSE;
    wp->ColourTTR = 0;
  }
d141 1
a141 1
  if (wp->BPP == 8)
d143 10
a152 11
    int temp;
    int size;

    _swix(ColourTrans_ReadPalette, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _IN(4) | _OUT(3),
                                   -1, -1, 0, 256*4, 0, &size); /* save palette into newtranstable area */
    tracef("need %x bytes for palette\n" _ size);
    _swix(ColourTrans_ReadPalette, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _IN(4),
                                   -1, -1, &(wp->newtranstable[0]), size, 0); /* save palette into newtranstable area */
    temp = palette_is_grey(wp->newtranstable, size/4);
    if (temp) opt |= jopt_GREY;
    if (temp == 2)
d154 3
a156 2
      opt |= jopt_OUTBPP_8GREY;
      opt &= ~jopt_DIFFUSE;
d158 2
a159 6
  }
  if ((wp->save_PdriverIntercept & 2) == 0 && (wp->dither_truecolour & 1)) /* old format palette and printing is not on */
  {
    int  size;

    if ((wp->dither_truecolour & 2) && wp->BPP < 16)
d161 3
a163 4
#ifdef DEBUG
      int loop;
#endif
      tracef("trying new shiny 8BPP plotting technique\n");
d169 3
a171 7
      tracef("created palette at %x\n" _ &(wp->newtranstable[0]));
#ifdef DEBUG
      tracef("Read palette, palette entries are:-\n");
      for(loop = 0;loop<size/4;loop++)
        tracef("Entry %d = %x\n" _ loop _ wp->newtranstable[loop]);
#endif
      if (wp->BPP == 4)
d173 2
a174 1
        if (palette_is_grey(wp->newtranstable, size/4)) opt |= jopt_GREY;
d176 6
a181 1
      else if (wp->BPP == 8)
d183 20
a202 5
        int temp;

        temp = palette_is_grey(wp->newtranstable, size/4);
        if (temp) opt |= jopt_GREY;
        if (temp == 2)
d204 9
a212 2
          opt |= jopt_OUTBPP_8GREY;
          opt &= ~jopt_DIFFUSE;
d215 4
a218 7
    }

    if ((wp->BPP == 4) && !(wp->dither_truecolour & 2)) opt |= jopt_GREY;

    if (wp->BPP == 8)
    {
      if ((wp->dither_truecolour & 2) && !(opt & jopt_OUTBPP_8GREY))
d220 13
a232 2
        opt |= jopt_OUTBPP_8;                        /* full error diffusion */
        cinfo->error_code = -1;                      /* mark the workspace entirely uninitialised */
d234 1
a234 1
      else
d236 2
a237 5
        int modeflags;

        _swix(OS_ReadModeVariable, _IN(0) | _IN(1) | _OUT(2), -1, 0, &modeflags);
        if ((modeflags & (1<<7)) == 0)
          opt |= jopt_OUTBPP_8YUV;                   /* strange diffusion from YUV data */
a239 5
    else if (wp->BPP == 16)
    {
      opt |= jopt_OUTBPP_16;
      cinfo->convert_block_16 = asm_get_convert_block_16_func(wp->ncolour,wp->modeflags);
    }
@


4.23
log
@Fixup CFSI-JPEG
Detail:
  Sources/CFSI-JPEG - Add an extra GET for mode flag definitions used by jdcolor
  c/rojpeg - Use standard 555 TBGR colour conversion function when producing 16bpp output for CFSI-JPEG
Admin:
  ChangeFSI JPEG output tested on RISC OS 3.7, 5.17, 5.21
  3.7 works fine, but 5.XX fails to convert JPEGs correctly for <256 colour output - to be investigated


Version 1.52. Retagged as 'SprExtend-1_52'
@
text
@d258 1
d260 1
a260 1
  /* Must preserve the workspace size and 32k colour table */
d263 1
d267 1
@


4.22
log
@Add support for new sprite types & screen modes
Detail:
  Makefile - Updated to fix a couple of dependency issues and to make c/asmcore the main C file, not c/putscaled
  Sources/PutScaled - Add a utility routine that's used by the C code to get information about pixel formats
  Sources/SprAdjSize - Add support for wide masks & RISC OS 5 style sprite mode words
  Sources/SprExtend - Tidy up workspace by removing lots of unused bits and moving other bits within sight of the C code. Add flag to control whether C or assembler version of SprTrans is used. Query kernel for ECFYOffset/ECHShift locations instead of using hardcoded values in putscaled code. Add fix for garbage debug strings in softloaded debug versions of the module.
  Sources/SprOp - Add support for wide masks & RISC OS 5 style sprite mode words. Update makepalette16bpp to cope with all the new 16bpp modes. Flag_* -> ModeFlag_* renaming. Move some translation table handling code into a new routine, 'preparettr'. Update checktrans/converttrans to deal with new pixel formats.
  Sources/SprTrans - If the C version of SprTrans is enabled, disable all of these assembler bits except for the outer loop which steps over each row of the screen
  Sources/jdcolor - Updated to deal with new pixel formats. 16bpp conversion code split off into new file, Sources/jdcolor16.
  Sources/jdcolor16 - New file containing the guts of the YUV -> 16bpp conversion code. Gets included multiple times with different options to generate the different conversion routines (code is too big for a macro).
  c/asmcore - New file containing lots of common code ripped out of c/PutScaled - e.g. workspace definition, main functions for register assignment & instruction generation, and code for pixel format conversion. Pixel format conversion code rewritten to cope with new pixel formats, and code buffer key word generation rewritten to fix a couple of bugs (e.g. some issues with dithering options were observed)
  c/PutScaled - Ripped out lots of code that's now in c/asmcore. Now just deals with things that are PutScaled-specific, e.g. main plotter loop containing pixel read/write code. Code extended to cope with new pixel formats
  c/rojpeg, h/jinclude, h/jpegdata - Code extended to cope with new 16bpp conversion routines
  c/sprtrans - New C implementation of the core per-row transformed sprite plotting code generator. Allows reuse of the extensive pixel conversion code in c/asmcore, and allows for better code generation than the assembler original.
  h/putscaled - Worksapce definition updated to match assembler version
Admin:
  Tested on BB-xM, plotting lots of different sprites in lots of different modes
  Plotting of wide mask sprites not supported yet
  C version of YUV -> 16bpp code currently only deals with traditional &BGR 555 pixel format - code is aware of this and will do conversion to desired format if applicable (although quality may be reduced)
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 1.52. Tagged as 'SprExtend-1_52'
@
text
@d96 1
@


4.21
log
@Adopt colour conversions from MigrateIJG8b branch
Now for every colour conversion there is a corresponding C function, allowing swapping between them for test purposes.
Here, 'ASMCOLOR' is selected and the C functions not even referenced in the makefile, see branch for use.
Permits use of USAT, for a small 1.5% speedup and smaller code.
Some other typedefs and comment shuffling copied over - should be harmless.

Version 1.50. Tagged as 'SprExtend-1_50'
@
text
@d59 1
a59 1
  tracef("Corrupted data in Huffman stream at byte %i\n" _ (char*)regblock[3] - cinfo->jpeg_buffer);
d227 1
d229 2
d639 4
d644 2
d720 3
a722 3
  tracef("ck1 %s im1 %x\n" _ cinfo->check1 _ ((int*)file_image)[image_length/(2*4)]);
  tracef("ck2 %s im2 %x\n" _ cinfo->check2 _ ((int*)file_image)[image_length/4 - image_length/(4*4)]);
  tracef("ck3 %s im3 %x\n" _ cinfo->check3 _ ((int*)file_image)[image_length/4 - image_length/(8*4)]);
d947 1
a947 1
  tracef("Exit jpeg_scan_file OK\n\n");
@


4.20
log
@Update to work with zero page relocation
Detail:
  Sources/SprExtend - Try using OS_ReadSysInfo 6 to get ECF block addresses before falling back on legacy addresses. Store pointers in module workspace for speedy access.
  Sources/SprOp, Sources/SprTrans - Use workspace ECF block pointers
  c/rojpeg - Fix null pointer access (actually an unused variable)
Admin:
  Tested on rev A2 BB-xM


Version 1.46. Tagged as 'SprExtend-1_46'
@
text
@d50 1
a50 1
void assembler_panic(decompress_info_ptr cinfo, int *regblock, int code)
d59 1
a59 1
  tracef("Corrupted data in Huffman stream at byte %i\n" _ (char*)regblock[3] - cinfo->input_buffer);
d79 1
a79 1
int do_jpeg_scan_file(char *space, int space_size, char *file_image, int image_length)
d89 1
a89 1
int do_jpeg_scan_file_16(char *space, int space_size, char *file_image, int image_length)
d283 1
a283 1
  tracef("Processing restart marker %i at %i bytes\n" _ cinfo->next_restart_num _ cinfo->next_input_byte - cinfo->input_buffer);
d286 1
a286 1
    tracef("inbuf=0x%x nbits=%i inptr=0x%x file=0x%x\n" _ cinfo->get_buffer _ cinfo->bits_left _ (int)cinfo->next_input_byte _ (int)cinfo->input_buffer);
a306 116
*    Colour conversions which are not important enough for assembler.     *
*                                                                         *
**************************************************************************/

static int mono_convert_pixel(int pix)
/* Just do a single pixel - eg. for DC-only display. The pixel does not have to
 * be shifted down, as it has not gone through the DCT.
 */
{
  int y = pix;

  y = ((y + 4) >> 3) + 128;      /* normalise */
  if (y < 0) y = 0;              /* range check */
  if (y > 255) y = 255;
  
  return y | (y << 8) | (y << 16); /* replicate Y value */
}

static void colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset, int wide, int high)
/* yuv[0..1] are Y, yuv[4] is U, yuv[5] is V. wide/high are 1 or 2.
 * Both being 2 is the most common case, for which we use hand-coded assembler instead.
 */
{
  unsigned int i, j;
  JCOEF *by0 = yuv + 0*DCTSIZE2;
  JCOEF *by1 = yuv + 1*DCTSIZE2;
  JCOEF *bu = yuv + 4*DCTSIZE2;
  JCOEF *bv = yuv + 5*DCTSIZE2;

#define SCALEBITS       8       /* speedier right-shift on some machines */
#define ONE_HALF        ((INT32) 1 << (SCALEBITS-1))
#define FIX(x)          ((INT32) ((x) * (1L<<SCALEBITS) + 0.5))

  for (j = 0; j < 8*high; j++)
  {
    for (i = 0; i < 8*wide; i++)
    {
      int y;
      int u;
      int v;

      /* Simplification because we don't use this code in the 2x2 case, so
       * we only need to worry about accessing a second block. */

      y = ((i < 8 && j < 8) ? by0 : by1)[(j&7) + (i&7)*8]; /* extract from right block, NB row order */
      u = bu[(j>>(high-1)) + (i>>(wide-1))*8];
      v = bv[(j>>(high-1)) + (i>>(wide-1))*8];

      y = (y + (1<<18)) >> 19;      /* descale */
      y += 128;                     /* normalise */
      u = (u + (1<<18)) >> 19;
      v = (v + (1<<18)) >> 19;
      {
        int r =                        v * FIX(1.40200);
        int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
        int b =     u * FIX(1.77200);

        r += ONE_HALF; r >>= SCALEBITS; r += y; if (r < 0) r = 0; if (r > 255) r = 255;
        g += ONE_HALF; g >>= SCALEBITS; g += y; if (g < 0) g = 0; if (g > 255) g = 255;
        b += ONE_HALF; b >>= SCALEBITS; b += y; if (b < 0) b = 0; if (b > 255) b = 255;
        outptr[i] = r | (g << 8) | (b << 16);
      }
    }
    outptr += outoffset;
  }
}

static void colour_convert_pixels(int *y, int u, int v)
/* Convert four pixels. Input y values are in y[0..3], put output there too.
 * Used for DC-only colour output. The input pixels do not have to be shifted
 * down by 19, as they have not been through the DCT.
 */
{
  u = (u + 4) >> 3; /* descale */
  v = (v + 4) >> 3;

  {
    int r =                        v * FIX(1.40200);
    int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
    int b =     u * FIX(1.77200);
    int i;
    int rr, gg, bb, yy;

    r += ONE_HALF; r >>= SCALEBITS;
    g += ONE_HALF; g >>= SCALEBITS;
    b += ONE_HALF; b >>= SCALEBITS;
    for (i = 0; i < 4; i++)
    {
      yy = ((y[i] + 4) >> 3) + 128;
      rr = r + yy; if (rr < 0) rr = 0; if (rr > 255) rr = 255;
      gg = g + yy; if (gg < 0) gg = 0; if (gg > 255) gg = 255;
      bb = b + yy; if (bb < 0) bb = 0; if (bb > 255) bb = 255;
      y[i] = rr | (gg << 8) | (bb << 16);
    }
  }
}

static void mono_convert_pixels(int *y)
/* Convert four pixels. Input y values are in y[0..3], put output there too.
 * Used for DC-only mono output. The input pixels do not have to be shifted
 * down by 19, as they have not been through the DCT.
 */
{
  int i;
  int yy;

  for (i = 0; i < 4; i++)
  {
    yy = ((y[i] + 4) >> 3) + 128;
    if (yy < 0) yy = 0; if (yy > 255) yy = 255;
    y[i] = yy | (yy << 8) | (yy << 16);
  }
}

/**************************************************************************
*                                                                         *
d318 2
a319 2
  assert(cinfo->input_buffer < cinfo->next_input_byte, ERROR_BAD_JPEG);
  assert(cinfo->next_input_byte < cinfo->buffer_end, ERROR_BAD_JPEG);
d321 1
a321 1
  h->bit_pointer = (cinfo->next_input_byte - cinfo->input_buffer)*32 + cinfo->bits_left;
d334 1
a334 1
  cinfo->next_input_byte = cinfo->input_buffer + h->bit_pointer/32;
d343 2
a344 2
  if (!(cinfo->input_buffer < cinfo->next_input_byte && cinfo->next_input_byte < cinfo->buffer_end))
    tracef("oops restore_huff_stream: 0x%x 0x%x 0x%x\n" _ (int)cinfo->input_buffer _ (int)cinfo->next_input_byte _ (int)cinfo->buffer_end);
d346 2
a347 2
  assert(cinfo->input_buffer < cinfo->next_input_byte, ERROR_FATAL);
  assert(cinfo->next_input_byte < cinfo->buffer_end, ERROR_FATAL);
d472 1
a472 1
      asm_j_rev_dct(cinfo, cinfo->jblocks[1], 1); /* output in jblocks[0] */
d608 1
a608 1
          asm_j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
d619 1
a619 1
          asm_j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
d634 1
a634 1
          asm_j_rev_dct(cinfo, cinfo->jblocks[1], 6); /* output in jblocks[0..5] */ /* usual, speed-critical case */
d636 1
a636 1
            asm_colour_convert_block_16(cinfo->jblocks[0], (short int*) outptr, line_offset);
d638 1
a638 1
            asm_colour_convert_block_8(cinfo->jblocks[0], (char*) outptr, line_offset);
d640 1
a640 1
            asm_colour_convert_block(cinfo->jblocks[0], outptr, line_offset);
d644 2
a645 2
          asm_j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* weird aspect ratio - only do DCTs we need to do */
          asm_j_rev_dct(cinfo, cinfo->jblocks[5], 2);
d679 1
a679 1
int jpeg_scan_file(decompress_info_ptr cinfo, char *file_image, int image_length,
d710 1
a710 1
  tracef("err %x buf %x file %x img %x\n" _ cinfo->error_code _ cinfo->input_buffer _ file_image _ image_length);
d718 2
a719 2
     && cinfo->input_buffer == file_image                                    /* check for image in same place */
     && cinfo->buffer_end - cinfo->input_buffer == image_length              /* check length unchanged */
d765 2
a766 1
  cinfo->input_buffer = file_image;
a767 1
  cinfo->buffer_end = file_image + image_length;
d782 1
a782 1
  tracef("Image starts at byte %i of JPEG data.\n" _ cinfo->next_input_byte - cinfo->input_buffer);
@


4.19
log
@Fix rendering of monochrome JPEGs at a scale of less than 1/6.
The normalisation was wrong, leading to very dark images.
There was no code to deal with the 8bpp grey modes, leading to corruption.
This is the monochrome version of the same bug fixed for colour in 1.32.

Version 1.40. Tagged as 'SprExtend-1_40'
@
text
@d1395 1
a1395 1
    int                  current_size, page_size;
a1398 1
    current_size = cinfo->workspace_size;
@


4.18
log
@Fix bug in JPEG vetting, tag 0xC4 was being taken as an SOF and quitting the tag scanning loop, which in turn rejected the JPEG as 0xC4 isn't a supported SOF type. In fact, it's not even an SOF type at all. See new IS_AN_SOF macro.
Fix bug leaving JPEG file handle open when unknown SOF or entropy encoding encountered (spotted testing the above).

Version 1.39. Tagged as 'SprExtend-1_39'
@
text
@d318 1
a318 1
  y += 128;                      /* normalise */
d564 15
a578 4
      outptr[0] = pix; outptr[1] = pix;
      outptr[2] = pix; outptr[3] = pix;
      outptr[4] = pix; outptr[5] = pix;
      outptr[6] = pix; outptr[7] = pix;
a579 1
      outptr += 8;
d590 1
d592 2
d595 1
d597 2
a598 1

a599 4
      if (cinfo->options & jopt_OUTBPP_8GREY)
        outptr += 2;
      else
        outptr += 8;
@


4.17
log
@Retire unused IJG version 4 files.
Fold RISC OS specific colour conversion routines into rojpeg.
Remove jcconv, this also highlighted there were some more unused functions.
Should make move to IJG version 8 even easier.

Version 1.38. Tagged as 'SprExtend-1_38'
@
text
@d1180 3
d1185 1
a1307 1
  tracef("jdata = %x\n" _ jdata);
d1309 1
a1309 1
         ((jdata[1] & M_SOFMASK) != M_SOFANY) && /* until we get to any SOF marker */
d1313 1
d1354 3
@


4.17.2.1
log
@Push some redundant files into the attic.
@
text
@a17 1
#include <stdio.h>
d20 1
a20 1
#include "jpeglib.h"
d50 1
a50 1
void assembler_panic(j_decompress_ptr cinfo, int *regblock, int code)
d82 1
a82 1
  j_decompress_ptr cinfo = (j_decompress_ptr) space;
d92 1
a92 1
  j_decompress_ptr cinfo = (j_decompress_ptr) space;
d104 1
a104 1
  j_decompress_ptr cinfo = wp->jpeg_info_ptr;
d130 1
a130 1
static int jpeg_decompressor_opts(j_decompress_ptr cinfo, asm_workspace *wp)
d246 1
a246 1
static void init_workspace(j_decompress_ptr cinfo, int size)
d265 1
a265 1
    cinfo->quant_tbl_ptrs[i] = (JQUANT_TBL *)&cinfo->s_quant_tbl[i];
d274 1
a274 1
static void process_restart(j_decompress_ptr cinfo)
d427 1
a427 1
static void save_huff_stream(j_decompress_ptr cinfo, huff_pointer *h)
d446 1
a446 1
static void restore_huff_stream(j_decompress_ptr cinfo, huff_pointer *h)
d467 3
a469 3
do_huff_skip_blocks(j_decompress_ptr cinfo, JBLOCK block,
                    JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JQUANT_TBL *quanttbl,
                    JCOEF *last_dc_val, int nblocks, BOOL block_per_mcu)
d496 3
a498 3
do_huff_decode_blocks(j_decompress_ptr cinfo, JBLOCK block,
                      JHUFF_TBL *dctbl, JHUFF_TBL *actbl, JQUANT_TBL *quanttbl,
                      JCOEF *last_dc_val, int nblocks, BOOL block_per_mcu)
d530 1
a530 1
static int do_1_component_band(j_decompress_ptr cinfo, int line_offset)
d535 3
a537 3
  JQUANT_TBL *quanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];
  JHUFF_TBL *dc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
  JHUFF_TBL *ac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
d563 1
a563 1
      pix = mono_convert_pixel(cinfo->last_dc_val[0] * quanttbl->quantval[0]);
d596 1
a596 1
static int do_3_component_band(j_decompress_ptr cinfo, int line_offset)
d601 9
a609 9
  JHUFF_TBL *ydc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
  JHUFF_TBL *yac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
  JQUANT_TBL *yquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];
  JHUFF_TBL *udc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[1]->dc_tbl_no];
  JHUFF_TBL *uac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[1]->ac_tbl_no];
  JQUANT_TBL *uquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[1]->quant_tbl_no];
  JHUFF_TBL *vdc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[2]->dc_tbl_no];
  JHUFF_TBL *vac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[2]->ac_tbl_no];
  JQUANT_TBL *vquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[2]->quant_tbl_no];
d637 1
a637 1
      y[0] = cinfo->last_dc_val[0] * yquanttbl->quantval[0];
d641 1
a641 1
        y[i] = cinfo->last_dc_val[0] * yquanttbl->quantval[0];
d678 2
a679 2
        u = cinfo->last_dc_val[1] * uquanttbl->quantval[0];
        v = cinfo->last_dc_val[2] * vquanttbl->quantval[0];
d784 1
a784 1
int jpeg_scan_file(j_decompress_ptr cinfo, char *file_image, int image_length,
d860 2
a861 2
    cinfo->band_buffer = (int*)((char*)cinfo + sizeof(struct jpeg_decompress_struct));
    cinfo->band_buffer_size = (cinfo->workspace_size - sizeof(struct jpeg_decompress_struct))/sizeof(int) & 0xfffffff0;
d930 1
a930 1
      if (cinfo->jpeg_color_space == JCS_GRAYSCALE)
d934 3
a936 3
        JHUFF_TBL *dc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
        JHUFF_TBL *ac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
        JQUANT_TBL *quanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];
d967 1
a967 1
      if (cinfo->jpeg_color_space == JCS_YCbCr)
d971 9
a979 9
        JHUFF_TBL *ydc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
        JHUFF_TBL *yac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
        JQUANT_TBL *yquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];
        JHUFF_TBL *udc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[1]->dc_tbl_no];
        JHUFF_TBL *uac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[1]->ac_tbl_no];
        JQUANT_TBL *uquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[1]->quant_tbl_no];
        JHUFF_TBL *vdc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[2]->dc_tbl_no];
        JHUFF_TBL *vac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[2]->ac_tbl_no];
        JQUANT_TBL *vquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[2]->quant_tbl_no];
d1048 1
a1048 1
int *jpeg_find_line(j_decompress_ptr cinfo, int ycoord, int *palette_data)
d1358 1
a1358 1
  new_size = sizeof(struct jpeg_decompress_struct) + 1024 +
d1376 1
a1376 1
    j_decompress_ptr  cinfo;
d1380 1
a1380 1
    cinfo = (j_decompress_ptr)*ws_size;
@


4.17.2.2
log
@Reinstate C code version of jdhuff.
In huff_decode_blocks the block pointer wasn't being incremented, as it was in the assembler.
Useful for speed comparisons.

Version 1.38, 1.35.2.3. Tagged as 'SprExtend-1_38-1_35_2_3'
@
text
@d471 1
a471 1
/* Just like huff_skip_blocks, but handles restart markers. If block_per_mcu
d486 1
a486 1
      huff_skip_blocks(cinfo, block, dctbl, actbl, quanttbl, last_dc_val, 1);
d493 1
a493 1
    huff_skip_blocks(cinfo, block, dctbl, actbl, quanttbl, last_dc_val, nblocks);
d500 1
a500 1
/* Just like huff_decode_blocks, but handles restart markers. If block_per_mcu
d515 1
a515 1
      huff_decode_blocks(cinfo, block, dctbl, actbl, quanttbl, last_dc_val, 1);
d522 1
a522 1
    huff_decode_blocks(cinfo, block, dctbl, actbl, quanttbl, last_dc_val, nblocks);
d619 2
a620 2
    huff_skip_blocks(cinfo, cinfo->jblocks[0], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
    huff_skip_blocks(cinfo, cinfo->jblocks[0], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
d641 1
a641 1
        huff_skip_blocks(cinfo, cinfo->jblocks[1 + i], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], 1);
d644 2
a645 2
      huff_skip_blocks(cinfo, cinfo->jblocks[5], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
      huff_skip_blocks(cinfo, cinfo->jblocks[6], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
d706 2
a707 2
      huff_decode_blocks(cinfo, cinfo->jblocks[5], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
      huff_decode_blocks(cinfo, cinfo->jblocks[6], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
d997 2
a998 2
            huff_skip_blocks(cinfo, cinfo->jblocks[5], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
            huff_skip_blocks(cinfo, cinfo->jblocks[6], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
@


4.17.2.3
log
@Reinstate jrevdct4 option to use C code IDCT (switch "ASMIDCT").
Name inverse DCT to match IJG 8b integer fast implementation.
Remove -DEMBED option and collapse switches.
Useful for speed comparisons.

Version 1.38, 1.35.2.4. Tagged as 'SprExtend-1_38-1_35_2_4'
@
text
@d30 1
a30 1
#ifdef SOURCE_IS_ROJPEG
a40 1
#include "jidctfst.c"
d579 1
a579 1
      j_rev_dct(cinfo, cinfo->jblocks[1], 1); /* output in jblocks[0] */
d714 1
a714 1
          j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
d725 1
a725 1
          j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
d740 1
a740 1
          j_rev_dct(cinfo, cinfo->jblocks[1], 6); /* output in jblocks[0..5] */ /* usual, speed-critical case */
d750 2
a751 2
          j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* weird aspect ratio - only do DCTs we need to do */
          j_rev_dct(cinfo, cinfo->jblocks[5], 2);
d794 1
d798 1
d815 1
d820 1
d840 1
d842 1
d1043 1
d1045 1
@


4.17.2.4
log
@Fix CFSIjpeg due to earlier rename of jidctfst
Rename remaining files to match IJG 8b.

Version 1.38, 1.35.2.5. Tagged as 'SprExtend-1_38-1_35_2_5'
@
text
@d39 1
a39 1
#include "jdmarker.c"
d865 1
a865 1
  /* Preserve pointers to the JPEG file image */
d1233 1
a1233 1
    tracef("Even a cursory look shows it ain't a JPEG\n");
d1382 1
a1382 1
      new_size = new_size + (10*1024); /* first JPEG => alloc size we need plus safety margin */
d1392 1
a1392 1
        new_size -= cinfo->workspace_size; /* size that will be added for this JPEG */
@


4.17.2.5
log
@Create assembler equivalents of C colour conversions, approx 10% speed up.
Add new switch ASMCOLOR to select which to use, C or assembler.
Remove FILE_ exit trace concept, just use __FILE__ instead in exit_erl.
Add some comments to exit_erl and friends.
A few bits of cinfo setup moved into start_pass_huff_decoder() or eliminated.
Bumped up the precision of SCALE_BITS in the C colour handling so FIX() uses more bits of an int.
Deleted the unused remenants of light dithering in the 8bpp colour converter - saves a few cycles.
colour_convert_8 and colour_convert_16 no longer save entry registers the C compiler doesn't care about.
Update genyuvtabs to EXPORT the table bases.
Split out the compilation of IJG files as separate objects in the make file, rather than including them from within rojpeg, which is itself included from putscaled.

Version 1.38, 1.35.2.6. Tagged as 'SprExtend-1_38-1_35_2_6'
@
text
@a18 1
#include <string.h>
a20 1
#ifdef CHANGEFSI
d22 15
d38 7
a44 2
#include "jpegint.h"
#include "rojpeg.h"
d52 1
a52 1
void panic_trace(j_decompress_ptr cinfo, int *regblock, int code)
d80 1
a80 1
#ifdef CHANGEFSI
d309 116
d582 1
a582 1
        mono_convert_block_8(cinfo->jblocks[0], outptr, line_offset);
d584 1
a584 1
        mono_convert_block(cinfo->jblocks[0], outptr, line_offset);
d716 2
a717 2
          mono_convert_block_8(cinfo->jblocks[0], outptr, line_offset);
          if (hsamp == 2) mono_convert_block_8(cinfo->jblocks[1], outptr + 2, line_offset);
d720 2
a721 2
            mono_convert_block_8(cinfo->jblocks[hsamp == 1 ? 1 : 2], outptr + 8*line_offset, line_offset);
            if (hsamp == 2) mono_convert_block_8(cinfo->jblocks[3], outptr + 8*line_offset + 2, line_offset);
d727 2
a728 2
          mono_convert_block(cinfo->jblocks[0], outptr, line_offset);
          if (hsamp == 2) mono_convert_block(cinfo->jblocks[1], outptr + 8, line_offset);
d731 2
a732 2
            mono_convert_block(cinfo->jblocks[hsamp == 1 ? 1 : 2], outptr + 8*line_offset, line_offset);
            if (hsamp == 2) mono_convert_block(cinfo->jblocks[3], outptr + 8*line_offset + 8, line_offset);
d743 1
a743 1
            colour_convert_block_16(cinfo->jblocks[0], (short int*) outptr, line_offset);
d745 1
a745 1
            colour_convert_block_8(cinfo->jblocks[0], (char*) outptr, line_offset);
d747 1
a747 1
            colour_convert_block(cinfo->jblocks[0], outptr, line_offset);
d886 4
a889 3
  start_pass_huff_decoder(cinfo);
  cinfo->current_huff_pointer = -1; /* no band currently loaded. */

d1190 1
a1190 1
#ifndef CHANGEFSI
d1200 1
a1200 1
#ifndef CHANGEFSI
d1234 1
a1234 1
#ifndef CHANGEFSI
d1244 1
a1244 1
#ifndef CHANGEFSI
d1305 1
a1305 1
#ifndef CHANGEFSI
d1362 1
a1362 1
#ifndef CHANGEFSI
d1367 1
a1367 1
#ifndef CHANGEFSI
d1410 1
a1410 1
#else /* CHANGEFSI */
@


4.17.2.6
log
@For completeness, implement the 2x2->8bpp and 2x2->16bpp colour conversions in C too.
While slower than their assembler equivalents it makes the whacky address generation a bit easier to follow.
Fix MakeFile to not stop when trying to deleted an empty directory.

Version 1.38, 1.35.2.7. Tagged as 'SprExtend-1_38-1_35_2_7'
@
text
@d609 1
a609 1
            colour_convert_block_16(cinfo->jblocks[0], (short *)outptr, line_offset);
d611 1
a611 1
            colour_convert_block_8(cinfo->jblocks[0], (char *)outptr, line_offset);
@


4.17.2.7
log
@Use USAT in 150 occurrences of colour clamping for ARMv6 and later.
Some IDCT renaming.
Shock addition of some documentation on how it all works.
Mirror fix from 1.39 on the trunk.
Debug
 Made DEBUG version compile again, earlier header shuffling was preventing it.
 Replaced the ' _ ' method of variadic macro emulation with more familiar double brackets for tracef().
 Eliminated IFDEBUG macro and just used #ifdef DEBUG/#endif or tracef() directly.
 Don't bother passing the line number and file name to exit() when in the non DEBUG case.

Version 1.38, 1.35.2.8. Tagged as 'SprExtend-1_38-1_35_2_8'
@
text
@d43 6
a48 6
  tracef(("Corrupted data in Huffman stream at byte %i\n", (char*)regblock[3] - cinfo->input_buffer));
  tracef(("cinfo=0x%x regblock=0x%x code=%i.\n", (int)cinfo, (int)regblock, code));
  for (i = 0; i < 16; i++) tracef(("R%i=0x%x\n", i, regblock[i]));
  tracef(("Nearby input bytes:\n"));
  for (i = -10; i < 10; i++) tracef(("%i:0x%x ", i, ((char*)(regblock[3]))[i]));
  newline();
d92 1
a92 1
    tracef(("Malloc requesting %x bytes of workspace\n", jpeg_ws_size));
d103 1
a103 1
      tracef(("Realloc requesting %x extra bytes of workspace\n", jpeg_ws_size));
d142 1
a142 1
    tracef(("need %x bytes for palette\n", size));
d144 1
a144 1
                                   -1, -1, &wp->newtranstable[0], size, 0); /* save palette into newtranstable area */
d162 1
a162 1
      tracef(("trying new shiny 8BPP plotting technique\n"));
d165 1
a165 1
      tracef(("need %x bytes for palette\n", size));
d168 1
a168 1
      tracef(("created palette at %x\n", &wp->newtranstable[0]));
d170 1
a170 1
      tracef(("Read palette, palette entries are:-\n"));
d172 1
a172 1
        tracef(("Entry %d = %x\n", loop, wp->newtranstable[loop]));
d215 9
a223 9
  tracef(("After set up, options are:\n"));
  if (opt & jopt_GREY) tracef(("   jopt_GREY\n"));
  if (opt & jopt_DC_ONLY) tracef(("   jopt_DC_ONLY\n"));
  if (opt & jopt_INTERP_X) tracef(("   jopt_INTERP_X\n"));
  if (opt & jopt_OUTBPP_8) tracef(("   jopt_OUTBPP_8\n"));
  if (opt & jopt_OUTBPP_16) tracef(("   jopt_OUTBPP_16\n"));
  if (opt & jopt_OUTBPP_8YUV) tracef(("   jopt_OUTBPP_8YUV\n"));
  if (opt & jopt_DIFFUSE) tracef(("   jopt_DIFFUSE\n"));
  if (opt & jopt_OUTBPP_8GREY) tracef(("   jopt_OUTBPP_8GREY\n"));
d267 1
a267 1
  tracef(("Processing restart marker %i at %i bytes\n", cinfo->next_restart_num, cinfo->next_input_byte - cinfo->input_buffer));
d270 3
a272 3
    tracef(("inbuf=0x%x nbits=%i inptr=0x%x file=0x%x\n", cinfo->get_buffer, cinfo->bits_left, (int)cinfo->next_input_byte, (int)cinfo->input_buffer);
    for (i = -10; i < 10; i++) tracef(("%i:0x%x ", i, cinfo->next_input_byte[i]));
    newline();
d328 1
a328 1
    tracef(("oops restore_huff_stream: 0x%x 0x%x 0x%x\n", (int)cinfo->input_buffer, (int)cinfo->next_input_byte, (int)cinfo->buffer_end));
d407 1
a407 1
  tracef(("in do_1_component_band\n"));
d446 1
a446 1
      jpeg_idct_ifast(cinfo, cinfo->jblocks[1], 1); /* output in jblocks[0] */
d481 1
a481 1
  tracef(("in do_3_component_band\n"));
d515 1
a515 1
        tracef(("about to do replicate some luma\n"));
d545 1
a545 1
        tracef(("about to do YUV to greyscale\n"));
d578 1
a578 1
        tracef(("about to do some grey conversion\n"));
d581 1
a581 1
          jpeg_idct_ifast(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
d592 1
a592 1
          jpeg_idct_ifast(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
d604 1
a604 1
        tracef(("about to do some colour conversion\n"));
d607 1
a607 1
          jpeg_idct_ifast(cinfo, cinfo->jblocks[1], 6); /* output in jblocks[0..5] */ /* usual, speed-critical case */
d617 2
a618 2
          jpeg_idct_ifast(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* weird aspect ratio - only do DCTs we need to do */
          jpeg_idct_ifast(cinfo, cinfo->jblocks[5], 2);
d640 1
a640 1
#define BADFILE(reason) {tracef(("bad file %d", reason)); \
d643 1
a643 1
#define BADFILE1(reason,arg) {tracef(("bad file %d %d", reason, arg)); \
d647 1
a647 1
#define BADFILE2(reason,arg1,arg2) {tracef(("bad file %d %d %d", reason, arg1, arg2)); \
d661 3
a663 3
  tracef(("jpeg_scan_file cinfo=0x%x file_image=0x%x image_length=%i xmin=%i xmax=%i width=%i height=%i options=%i\n",
         (int)cinfo, (int)file_image, image_length, xmin, xmax, width, height, options));
  tracef(("wssize %x\n", cinfo->workspace_size));
d668 1
a668 1
    tracef(("Clearing 8YUV because of DC_ONLY flag\n"));
d680 4
a683 4
  tracef(("err %x buf %x file %x img %x\n", cinfo->error_code, cinfo->input_buffer, file_image, image_length));
  tracef(("ck1 %s im1 %x\n", cinfo->check1, ((int*)file_image)[image_length/(2*4)]));
  tracef(("ck2 %s im2 %x\n", cinfo->check2, ((int*)file_image)[image_length/4 - image_length/(4*4)]));
  tracef(("ck3 %s im3 %x\n", cinfo->check3, ((int*)file_image)[image_length/4 - image_length/(8*4)]));
d697 1
a697 1
    tracef(("This looks like the same JPEG file as last time.\n"));
d703 1
a703 1
    tracef(("Exit jpeg_scan_file OK\n\n"));
d748 2
a749 2
  tracef(("Huffman tables fixed.\n"));
  tracef(("Image starts at byte %i of JPEG data.\n", cinfo->next_input_byte - cinfo->input_buffer));
d787 1
a787 1
      tracef(("num_components = 1 (Greyscale file)\n"));
d815 1
a815 1
      tracef(("num_components = 3 (YUV file)\n"));
d869 1
a869 1
      tracef(("num_components = 4 (CMYK file)\n"));
d891 10
a900 10
  tracef(("cinfo->erooarg1 = %d\n", cinfo->error_argument1));
  tracef(("After scan file, options are:\n"));
  if (options & jopt_GREY) tracef(("  jopt_GREY\n"));
  if (options & jopt_DC_ONLY) tracef(("  jopt_DC_ONLY\n"));
  if (options & jopt_INTERP_X) tracef(("  jopt_INTERP_X\n"));
  if (options & jopt_OUTBPP_8) tracef(("  jopt_OUTBPP_8\n"));
  if (options & jopt_OUTBPP_16) tracef(("  jopt_OUTBPP_16\n"));
  if (options & jopt_OUTBPP_8YUV) tracef(("  jopt_OUTBPP_8YUV\n"));
  if (options & jopt_DIFFUSE) tracef(("  jopt_DIFFUSE\n"));
  if (options & jopt_OUTBPP_8GREY) tracef(("  jopt_OUTBPP_8GREY\n"));
d903 1
a903 1
  tracef(("Exit jpeg_scan_file OK\n\n"));
d917 1
a917 1
  tracef(("jpeg_find_line, palette data at %x\n", palette_data));
d973 1
a973 1
        tracef(("Fetched 32k lookup table, at 0x%x\n", (int) cinfo->table32k));
d985 1
a985 1
          tracef(("calling diffuse to 8bpp code. palette = %x\n", palette_data));
d990 1
a990 1
          tracef(("done diffusion, outptr = &%x, blockwidth = &%xlinelen = &%x\n", outptr, blockwidth, linelen));
d1001 1
a1001 1
          tracef(("calling diffuse to palette entries code. palette = %x\n", palette_data));
d1006 1
a1006 1
          tracef(("done diffusion, outptr = &%x, blockwidth = &%xlinelen = &%x\n", outptr, blockwidth, linelen));
a1038 3
#define M_DHT         0xc4 /* False positives */
#define M_DAC         0xcc /* False positives */
#define M_JPG         0xc8 /* False positives */
a1040 1
#define IS_AN_SOF(k)  (((k & M_SOFMASK)==0xC0) && (k!=M_DHT) && (k!=M_DAC) && (k!=M_JPG))
d1064 1
a1064 1
  tracef(("Find image dims called.\n"));
d1070 1
a1070 1
    tracef(("We think it's a filename '%s'\n", jdata));
d1074 1
a1074 1
      tracef(("e points to err %x '%s'\n", e->errnum, e->errmess));
d1078 1
a1078 1
    tracef(("Going to scan top of handle %d into buffer = %x\n", file_handle, buffer));
d1086 1
a1086 1
    tracef(("Got jdata = %x, data_end = %x\n", jdata, dataend));
d1089 1
a1089 1
  tracef(("jdata = %x\n", jdata));
d1098 1
a1098 1
    tracef(("Even a cursory look shows it ain't a JPEG\n"));
d1114 2
a1115 2
    tracef(("pixel density is %x\n", jdata[13]));
    tracef(("  jdata[14-17], %x %x %x %x\n", jdata[14], jdata[15], jdata[16], jdata[17]));
d1152 1
a1152 1
    tracef(("no APP0 tag, assuming a 1:1 xdpi to ydpi ratio\n"));
d1156 1
a1156 1
  tracef(("pixel density is %d\n", pixel_density));
d1163 1
d1165 1
a1165 1
         !IS_AN_SOF(jdata[1]) && /* until we get to any SOF marker */
a1168 1
    tracef(("skip tag = %x\n", jdata[1]));
d1180 1
a1180 1
      tracef(("Loading another chunk. jdata = %x, offset = %x\n", jdata, offset));
d1208 1
a1208 4
    tracef(("Header looks like JPEG data, but not one we recognise.\n"));
#ifndef CHANGEFSI
    if (load_file) _swix(OS_Find, _IN(0) | _IN(1), 0, file_handle);
#endif    
d1236 1
a1236 1
    int               current_size, page_size;
d1263 1
a1263 1
    tracef(("We need another %x bytes\n", new_size));
d1268 1
a1268 1
    tracef(("closing file\n"));
@


4.17.2.8
log
@New jerror.h taken from IJG8b.
Swap to using JERR_ numbers, deleted E_ numbers.
Modify genjhdr to pass some defines to the assembler code, so jdcolor can clarify use of DCTSIZE and DCTSIZE2.
Added chart of possible subsampling ratios to documentation.

Version 1.38, 1.35.2.9. Tagged as 'SprExtend-1_38-1_35_2_9'
@
text
@d337 1
a337 1
                    JCOEF *last_dc_val, int nblocks, boolean block_per_mcu)
d344 1
a344 1
    boolean count = TRUE;
d366 1
a366 1
                      JCOEF *last_dc_val, int nblocks, boolean block_per_mcu)
d373 1
a373 1
    boolean count = TRUE;
d613 1
a613 1
            colour_convert_block_32(cinfo->jblocks[0], outptr, line_offset);
d645 1
d649 1
a753 1
  cinfo->natural_order = jpeg_natural_order_base();
d764 4
a767 4
  if (cinfo->data_precision != BITS_IN_JSAMPLE) BADFILE1(JERR_BAD_PRECISION, cinfo->data_precision);
  if (cinfo->num_components != cinfo->comps_in_scan) BADFILE(JERR_NOTIMPL);
  if (cinfo->image_width != width && width != -1) BADFILE1(JERR_TOO_LITTLE_DATA, cinfo->image_width);
  if (cinfo->image_height != height && height != -1) BADFILE1(JERR_TOO_LITTLE_DATA, cinfo->image_height);
d773 1
a773 1
    int mcu_height = DCTSIZE * vsamp; /* 8 or 16 */
d780 1
a780 1
      BADFILE2(JERR_WIDTH_OVERFLOW, cinfo->image_width, cinfo->band_buffer_size / mcu_height);
d790 1
a790 1
        BADFILE2(JERR_BAD_SAMPLING, hsamp, vsamp);
d803 1
a803 1
          /* Cache the state of the huff stream at this MCU row. */
d807 1
a807 1
          height += DCTSIZE;
d811 1
a811 1
        BADFILE1(JERR_BAD_J_COLORSPACE, cinfo->jpeg_color_space);
d823 1
a823 1
        BADFILE2(JERR_BAD_SAMPLING, hsamp, vsamp);
d825 1
a825 1
        BADFILE2(JERR_BAD_DROP_SAMPLING, cinfo->comp_info[1].h_samp_factor, cinfo->comp_info[1].v_samp_factor);
d827 1
a827 1
        BADFILE2(JERR_BAD_DROP_SAMPLING, cinfo->comp_info[2].h_samp_factor, cinfo->comp_info[2].v_samp_factor);
d843 1
a843 1

d848 1
a848 1
          /* Cache the state of the huff stream at this MCU row. */
d851 1
a851 1

d859 1
a859 1
            width += DCTSIZE * hsamp;
d861 1
a861 1
          height += DCTSIZE * vsamp;
d865 1
a865 1
        BADFILE1(JERR_BAD_J_COLORSPACE, cinfo->jpeg_color_space);
d871 1
a871 1
      BADFILE1(JERR_COMPONENT_COUNT, cinfo->num_components);
d877 1
a877 1
    int size_per_line = cinfo->band_buffer_size / (DCTSIZE * hsamp);
d891 1
a891 1
  tracef(("error_argument1 = %d\n", cinfo->error_argument1));
d1060 1
a1060 1
  boolean         load_file;
@


4.17.2.9
log
@Huffman decode adjusted to accept quantisation tables of 16 or 32 bit values (though use of LDAH macro).
IJG 8b uses UINT16 values now, but there's no measurable speed difference despite one/two extra instructions per AC component.

Version 1.38, 1.35.2.10. Tagged as 'SprExtend-1_38-1_35_2_10'
@
text
@a299 1
  int i;
d307 3
a309 2
  for (i = 0; i < MAX_COMPS_IN_SCAN; i++)
    h->last_dc_val[i] = cinfo->last_dc_val[i];
a316 2
  int i;

d320 3
a322 2
  for (i = 0; i < MAX_COMPS_IN_SCAN; i++)
    cinfo->last_dc_val[i] = h->last_dc_val[i];
d413 1
a413 1
    do_huff_skip_blocks(cinfo, cinfo->s_jblocks[0], dc, ac, quanttbl, &cinfo->last_dc_val[0], count, TRUE);
d430 1
a430 1
      do_huff_skip_blocks(cinfo, cinfo->s_jblocks[1], dc, ac, quanttbl, &cinfo->last_dc_val[0], 1, TRUE);
d445 2
a446 2
      do_huff_decode_blocks(cinfo, cinfo->s_jblocks[1], dc, ac, quanttbl, &cinfo->last_dc_val[0], 1, TRUE);
      jpeg_idct_ifast(cinfo, cinfo->s_jblocks[1], 1); /* output in jblocks[0] */
d448 1
a448 1
        mono_convert_block_8(cinfo->s_jblocks[0], outptr, line_offset);
d450 1
a450 1
        mono_convert_block(cinfo->s_jblocks[0], outptr, line_offset);
d485 3
a487 3
    do_huff_skip_blocks(cinfo, cinfo->s_jblocks[0], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], hsamp*vsamp, FALSE);
    huff_skip_blocks(cinfo, cinfo->s_jblocks[0], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
    huff_skip_blocks(cinfo, cinfo->s_jblocks[0], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
d504 1
a504 1
      do_huff_skip_blocks(cinfo, cinfo->s_jblocks[1], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], 1, FALSE);
d508 1
a508 1
        huff_skip_blocks(cinfo, cinfo->s_jblocks[1 + i], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], 1);
d511 2
a512 2
      huff_skip_blocks(cinfo, cinfo->s_jblocks[5], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
      huff_skip_blocks(cinfo, cinfo->s_jblocks[6], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
d572 3
a574 3
      do_huff_decode_blocks(cinfo, cinfo->s_jblocks[1], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], hsamp*vsamp, FALSE);
      huff_decode_blocks(cinfo, cinfo->s_jblocks[5], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
      huff_decode_blocks(cinfo, cinfo->s_jblocks[6], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
d581 3
a583 3
          jpeg_idct_ifast(cinfo, cinfo->s_jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
          mono_convert_block_8(cinfo->s_jblocks[0], outptr, line_offset);
          if (hsamp == 2) mono_convert_block_8(cinfo->s_jblocks[1], outptr + 2, line_offset);
d586 2
a587 2
            mono_convert_block_8(cinfo->s_jblocks[hsamp == 1 ? 1 : 2], outptr + 8*line_offset, line_offset);
            if (hsamp == 2) mono_convert_block_8(cinfo->s_jblocks[3], outptr + 8*line_offset + 2, line_offset);
d592 3
a594 3
          jpeg_idct_ifast(cinfo, cinfo->s_jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
          mono_convert_block(cinfo->s_jblocks[0], outptr, line_offset);
          if (hsamp == 2) mono_convert_block(cinfo->s_jblocks[1], outptr + 8, line_offset);
d597 2
a598 2
            mono_convert_block(cinfo->s_jblocks[hsamp == 1 ? 1 : 2], outptr + 8*line_offset, line_offset);
            if (hsamp == 2) mono_convert_block(cinfo->s_jblocks[3], outptr + 8*line_offset + 8, line_offset);
d607 1
a607 1
          jpeg_idct_ifast(cinfo, cinfo->s_jblocks[1], 6); /* output in jblocks[0..5] */ /* usual, speed-critical case */
d609 1
a609 1
            colour_convert_block_16(cinfo->s_jblocks[0], (short *)outptr, line_offset);
d611 1
a611 1
            colour_convert_block_8(cinfo->s_jblocks[0], (char *)outptr, line_offset);
d613 1
a613 1
            colour_convert_block_32(cinfo->s_jblocks[0], outptr, line_offset);
d617 3
a619 3
          jpeg_idct_ifast(cinfo, cinfo->s_jblocks[1], hsamp*vsamp); /* weird aspect ratio - only do DCTs we need to do */
          jpeg_idct_ifast(cinfo, cinfo->s_jblocks[5], 2);
          colour_convert_unusual_block(cinfo->s_jblocks[0], outptr, line_offset, hsamp, vsamp);
d679 3
a681 3
  tracef(("ck1 %x im1 %x\n", cinfo->check1, ((int*)file_image)[image_length/(2*4)]));
  tracef(("ck2 %x im2 %x\n", cinfo->check2, ((int*)file_image)[image_length/4 - image_length/(4*4)]));
  tracef(("ck3 %x im3 %x\n", cinfo->check3, ((int*)file_image)[image_length/4 - image_length/(8*4)]));
d805 1
a805 1
          do_huff_skip_blocks(cinfo, cinfo->s_jblocks[0], dc, ac, quanttbl, &cinfo->last_dc_val[0], (cinfo->image_width + 7) >> 3, TRUE);
d855 3
a857 3
            do_huff_skip_blocks(cinfo, cinfo->s_jblocks[1], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], hsamp * vsamp, FALSE);
            huff_skip_blocks(cinfo, cinfo->s_jblocks[5], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
            huff_skip_blocks(cinfo, cinfo->s_jblocks[6], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
@


4.17.2.10
log
@Remap return results for CFSI-JPEG to match new cinfo structure.
Tested with a handful of JPEGs and !ChangeFSI.

Version 1.38, 1.35.2.11. Tagged as 'SprExtend-1_38-1_35_2_11'
@
text
@a22 1
#define JPEG_INTERNALS
@


4.17.2.11
log
@Migrate to jdmarker from IJG 8b.
ERREXIT's in jdhuff now use JERR_ numbers (missed earlier because it's switched out by default).

Version 1.38, 1.35.2.12. Tagged as 'SprExtend-1_38-1_35_2_12'
@
text
@d236 1
d247 10
a256 3
  cinfo->natural_order = jpeg_natural_order_base();
  jinit_marker_reader(cinfo);
  jinit_huff_decoder(cinfo);
d268 1
a268 1
  tracef(("Processing restart marker %i at %i bytes\n", cinfo->marker->next_restart_num, cinfo->next_input_byte - cinfo->input_buffer));
d281 1
a281 1
  assert((c & 7) == cinfo->marker->next_restart_num, ERROR_BAD_JPEG); /* should be precisely the correct marker */
d286 2
a287 3
  cinfo->marker->next_restart_num = (cinfo->marker->next_restart_num + 1) & 7;
  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
    cinfo->last_dc_val[ci] = 0;
d312 1
a312 1
  h->next_restart_num = cinfo->marker->next_restart_num;
d326 1
a326 1
  cinfo->marker->next_restart_num = h->next_restart_num;
d658 1
d681 3
a683 3
  tracef(("ck1 %x im1 %x\n", cinfo->check1, ((int *)file_image)[image_length/(2*4)]));
  tracef(("ck2 %x im2 %x\n", cinfo->check2, ((int *)file_image)[image_length/4 - image_length/(4*4)]));
  tracef(("ck3 %x im3 %x\n", cinfo->check3, ((int *)file_image)[image_length/4 - image_length/(8*4)]));
d691 5
a695 4
     && cinfo->check1 == ((int *)file_image)[image_length/(2*4)]                  /* Random checks on data - the /4 gets us down to char offsets */
     && cinfo->check2 == ((int *)file_image)[image_length/4 - image_length/(4*4)] /* we check a word half-way through, and two later on */
     && cinfo->check3 == ((int *)file_image)[image_length/4 - image_length/(8*4)] /* any change will perturb the whole file - we trust! */
     && cinfo->options == options)
d714 1
a714 1
  if (cinfo->workspace_size == 0) 
a715 3
    /* There's no workspace, they just want us to scan the header, just set up enough to
     * prevent JERR_WIDTH_OVERFLOW complaints later on
     */
d717 2
a718 1
    cinfo->band_buffer_size = (64 * 1024 /* JPEG width limit */) * (DCTSIZE * 2 /* vsamp max */);
d722 1
a722 1
    cinfo->band_buffer = (int *)((char *)cinfo + sizeof(struct jpeg_decompress_struct));
d726 5
d735 14
d751 12
a762 2
  /* Read the file header - sets various cinfo fields. */
  cinfo->marker->read_markers(cinfo);
a769 16
  /* Guess the input colorspace - defaulted to JCR_UNKNOWN in the marker reader. */
  if (cinfo->num_components == 1)
    cinfo->jpeg_color_space = JCS_GRAYSCALE; /* must be */

  if ((cinfo->num_components == 3) && cinfo->saw_JFIF_marker)
    cinfo->jpeg_color_space = JCS_YCbCr; /* JFIF implies YCbCr */

  if ((cinfo->num_components == 3) &&
      (cinfo->comp_info[0].component_id == 1) &&
      (cinfo->comp_info[1].component_id == 2) &&
      (cinfo->comp_info[2].component_id == 3))
    cinfo->jpeg_color_space = JCS_YCbCr; /* assume JFIF w/out marker */

  /* Initialise the first huff decoding stream. */
  start_pass_huff_decoder(cinfo);

d774 1
a774 1
    int mcu_height = DCTSIZE * cinfo->comp_info[0].v_samp_factor; /* 8 or 16 */
d777 1
a777 1
    cinfo->huff_pointers = (huff_pointer *)cinfo->band_buffer;
a783 12
  /* Set up the check words, to hope for repeated calls on this image */
  cinfo->check1 = ((int *)file_image)[image_length/(2*4)];
  cinfo->check2 = ((int *)file_image)[image_length/4 - image_length/(4*4)];
  cinfo->check3 = ((int *)file_image)[image_length/4 - image_length/(8*4)];

  /* Fill in the remaining platform specifics */
  if (xmax > cinfo->image_width) xmax = cinfo->image_width;
  if (xmin > xmax) xmin = xmax; /* guard against silly input */
  cinfo->xmin = xmin;
  cinfo->xmax = xmax;
  cinfo->options = options;

a784 2
  vsamp = cinfo->comp_info[0].v_samp_factor;
  hsamp = cinfo->comp_info[0].h_samp_factor;
@


4.17.2.12
log
@Reorganise data input.
Fill in INPUT_VARS and INPUT_SYNC so it uses register variables.
Make use of data source manager (cinfo->src).
Calculate bytes_in_buffer when restoring the huffman position.
Swap process_restart() for the one now in jdmarker.

Version 1.38, 1.35.2.13. Tagged as 'SprExtend-1_38-1_35_2_13'
@
text
@d44 1
a44 1
  tracef(("Corrupted data in Huffman stream at byte %i\n", (char *)regblock[3] - (char *)cinfo->jpeg_buffer));
d48 1
a48 1
  for (i = -10; i < 10; i++) tracef(("%i:0x%x ", i, ((char *)(regblock[3]))[i]));
a230 17
/**************************************************************************
*                                                                         *
*    Data source & workspace management                                   *
*                                                                         *
**************************************************************************/
static void skip_input_data(j_decompress_ptr cinfo, long num_bytes)
{
  /* Within this (non-ported) code, use the static structure so the
   * compiler can calculate the offset in one go
   */
  cinfo->s_source_mgr.next_input_byte += num_bytes;
  if (cinfo->s_source_mgr.bytes_in_buffer < num_bytes)
    cinfo->s_source_mgr.bytes_in_buffer = 0;
  else
    cinfo->s_source_mgr.bytes_in_buffer -= (size_t)num_bytes;
}

d246 1
a246 6
  /* Minimal data source manager */
  cinfo->src = &cinfo->s_source_mgr;
  cinfo->s_source_mgr.skip_input_data = (void (*)(j_decompress_ptr, long))RELOCATE(skip_input_data);
  cinfo->s_source_mgr.resync_to_restart = (boolean (*)(j_decompress_ptr, int))RELOCATE(jpeg_resync_to_restart); 

  /* Other library init */
d251 32
d297 2
a298 2
  assert(cinfo->jpeg_buffer < cinfo->s_source_mgr.next_input_byte, ERROR_FATAL);
  assert(cinfo->s_source_mgr.next_input_byte < &cinfo->jpeg_buffer[cinfo->jpeg_size], ERROR_FATAL);
d300 1
a300 1
  h->bit_pointer = ((cinfo->s_source_mgr.next_input_byte - cinfo->jpeg_buffer) << 5) | cinfo->bits_left;
d313 2
a314 2
  cinfo->s_source_mgr.next_input_byte = cinfo->jpeg_buffer + (h->bit_pointer >> 5);
  cinfo->s_source_mgr.bytes_in_buffer = cinfo->jpeg_size - (h->bit_pointer >> 5);
a315 1
  cinfo->get_buffer = h->get_buffer;
d320 7
a336 2
  int ci;
  
d345 1
a345 10
        if (cinfo->restarts_to_go == 0)
        {
          if (!cinfo->marker->read_restart_marker(cinfo))
            ERREXIT(cinfo, JTRC_RST);
          cinfo->get_buffer = 0; /* Flush the remaining bits */
          cinfo->bits_left = 0;
          cinfo->restarts_to_go = cinfo->restart_interval;
          for (ci = 0; ci < cinfo->comps_in_scan; ci++)
            cinfo->last_dc_val[ci] = 0;
        }
a365 2
  int ci;

d374 1
a374 10
        if (cinfo->restarts_to_go == 0)
        {
          if (!cinfo->marker->read_restart_marker(cinfo))
            ERREXIT(cinfo, JTRC_RST);
          cinfo->get_buffer = 0; /* Flush the remaining bits */
          cinfo->bits_left = 0;       
          cinfo->restarts_to_go = cinfo->restart_interval;
          for (ci = 0; ci < cinfo->comps_in_scan; ci++)
            cinfo->last_dc_val[ci] = 0;
        }
d645 2
a646 2
int jpeg_scan_file(j_decompress_ptr cinfo, const JOCTET *file_image, size_t image_length,
                   int xmin, int xmax, int width, int height, int options)
d672 1
a672 1
  tracef(("err %x buf %x file %x img %x\n", cinfo->error_code, cinfo->jpeg_buffer, file_image, image_length));
d679 2
a680 2
     && cinfo->jpeg_buffer == file_image                                     /* check for image in same place */
     && cinfo->jpeg_size == image_length                                     /* check length unchanged */
d720 4
a723 2
  cinfo->s_source_mgr.next_input_byte = cinfo->jpeg_buffer = (const JOCTET *)file_image;
  cinfo->s_source_mgr.bytes_in_buffer = cinfo->jpeg_size = image_length;
a746 5
  /* Derive block_size, natural_order, and lim_Se */
  cinfo->block_size = DCTSIZE;
  cinfo->natural_order = jpeg_natural_order_base();
  cinfo->lim_Se = DCTSIZE2-1;

@


4.17.2.13
log
@Abstract entropy decoding.
Currently still only support Huffman, but now agnostic, there are two functions 'decode_mcu()' which does the full DC+AC decode of a full MCU worth of data, and 'skip_mcu()' which just does DC and consumes but discards the AC coefficients.
Apply fix from 1.40 trunk version for monochrome output in a 8bpp greyscale mode.
Restore name of DCTFIX() macro to FIX(), no longer needed now the constituent parts are compiled seperately rather than #included.
Fix CFSIjpeg to assemble even though it doesn't have a module base (the recently added 'relocatefn()' was breaking it).

Version 1.38, 1.35.2.14. Tagged as 'SprExtend-1_38-1_35_2_14'
@
text
@d44 1
a44 1
  tracef(("Corrupted data in entropy stream at byte %i\n", (char *)regblock[3] - (char *)cinfo->jpeg_buffer));
d46 1
a46 2
  for (i = 0; i < 16; i++)
    tracef(("R%i=0x%x\n", i, regblock[i]));
d48 1
a48 2
  for (i = -10; i < 10; i++)
    tracef(("%i:0x%x ", i, ((char *)(regblock[3]))[i]));
d64 2
a65 2
int do_jpeg_scan_file_32(char *space, int space_size, const JOCTET *file_image, int image_length)
/* Simple entry sequence for use by ChangeFSI - 32bpp output. */
d74 1
a74 1
int do_jpeg_scan_file_16(char *space, int space_size, const JOCTET *file_image, int image_length)
d84 1
a84 1
static int palette_is_grey(int *palette, int entries); /* forward reference in c.putscaled */
a235 1

d275 120
d401 1
a401 1
  int  width = 0;
d403 4
a406 2
  int  nlines_fetched;
  JBLOCKROW *row = (JBLOCKROW *)cinfo->s_jblocks;
d409 2
a410 2

  while (cinfo->xmin >= width + 8) /* skip over blocks we don't want */
d412 8
a419 4
    cinfo->entropy->skip_mcu(cinfo, row);
    width += 8;
    if (cinfo->options & jopt_OUTBPP_8GREY) outptr += 2;
    else outptr += 8;
d424 3
d430 7
a436 21

      /* We only want a flat value for each tile. The skip function does update
       * the DC values but does no AC decoding.
       */
      cinfo->entropy->skip_mcu(cinfo, row);
      pix = mono_convert_pixel(cinfo->s_jblocks[1][0]);
      if (cinfo->options & jopt_OUTBPP_8GREY)
      {
        /* Native greyscale 8bpp */
        outptr[0] = outptr[1] = YYYTOYYYY(pix);
        outptr += 2;
      }
      else
      {        
        /* Output greyscale 24bpp, and dither it later if needed */
        outptr[0] = pix; outptr[1] = pix;
        outptr[2] = pix; outptr[3] = pix;
        outptr[4] = pix; outptr[5] = pix;
        outptr[6] = pix; outptr[7] = pix;
        outptr += 8;
      }
d438 1
d446 1
a446 1
      cinfo->entropy->decode_mcu(cinfo, row);
a448 1
      {
d450 5
a455 1
      }
a456 2
      {
        mono_convert_block(cinfo->s_jblocks[0], outptr, line_offset);
a457 2
      }
      width += 8;
d470 9
a478 1
  JBLOCKROW *row = (JBLOCKROW *)cinfo->s_jblocks;
d481 1
a481 1

d484 1
a484 1
  while (cinfo->xmin >= width + 8*hsamp) /* skip over blocks we don't want */
d486 3
a488 1
    cinfo->entropy->skip_mcu(cinfo, row);
d505 3
a507 2
      cinfo->entropy->skip_mcu(cinfo, row);
      for (i = 0; i < hsamp * vsamp; i++)
d509 2
a510 1
        y[i] = cinfo->s_jblocks[i + 1][0];
d512 2
d547 2
a548 2
        u = cinfo->s_jblocks[(hsamp * vsamp) + 1][0];
        v = cinfo->s_jblocks[(hsamp * vsamp) + 2][0];
d573 4
a576 1
      cinfo->entropy->decode_mcu(cinfo, row);
d582 1
a582 1
          jpeg_idct_ifast(cinfo, cinfo->s_jblocks[1], hsamp * vsamp); /* output in jblocks[0..3] */
d593 1
a593 1
          jpeg_idct_ifast(cinfo, cinfo->s_jblocks[1], hsamp * vsamp); /* output in jblocks[0..3] */
d606 1
a606 1
        if (hsamp * vsamp == 4)
d608 1
a608 1
          jpeg_idct_ifast(cinfo, cinfo->s_jblocks[1], 4 + 2); /* usual, speed-critical case */
d618 1
a618 1
          jpeg_idct_ifast(cinfo, cinfo->s_jblocks[1], hsamp * vsamp); /* weird aspect ratio - only do DCTs we need to do */
d696 1
a696 1
    if (xmin < cinfo->xmin || xmax > cinfo->xmax) cinfo->current_bookmark = -1; /* no band sufficiently loaded */
d725 1
a725 1
  /* Preserve pointers to the JPEG file image. */
d756 2
a757 2
  /* Restart the entropy decoding stream. */
  cinfo->entropy->start_pass(cinfo);
d759 1
a759 1
  /* Allocate the array of pointers into the entropy stream, at the base of where the band
d764 1
a764 1
    int bookmarks_size = sizeof(entropy_state) * ((cinfo->image_height + mcu_height - 1)/mcu_height); /* in bytes */
d766 3
a768 4
    cinfo->current_bookmark = -1; /* no band sufficiently loaded */
    cinfo->bookmarks = (entropy_state *)cinfo->band_buffer;
    cinfo->band_buffer += bookmarks_size/sizeof(int);
    cinfo->band_buffer_size -= bookmarks_size/sizeof(int);
d797 5
a801 3
        int width, height = 0;
        int bookmark = 0;
        JBLOCKROW *row = (JBLOCKROW *)cinfo->s_jblocks;
a803 1
        cinfo->blocks_in_MCU = 1;
d807 4
a810 9
          /* Record the state of the entropy stream at this MCU row. */
          cinfo->entropy->save_state(cinfo, &cinfo->bookmarks[bookmark]);
          bookmark++;
          width = 0;
          while (width < cinfo->image_width)
          {
            cinfo->entropy->skip_mcu(cinfo, row);
            width += DCTSIZE;
          }
d834 11
a844 3
        int width, height = 0;
        int bookmark = 0;
        JBLOCKROW *row = (JBLOCKROW *)cinfo->s_jblocks;
a846 1
        cinfo->blocks_in_MCU = (hsamp * vsamp) + 2;
d850 6
a855 3
          /* Record the state of the entropy stream at this MCU row. */
          cinfo->entropy->save_state(cinfo, &cinfo->bookmarks[bookmark]);
          bookmark++;
d859 4
a862 1
            cinfo->entropy->skip_mcu(cinfo, row);
d916 1
a916 1
  int  bookmark;
d930 1
a930 1
  bookmark = ycoord >> l2_band_height;
d932 1
a932 1
  if (bookmark != cinfo->current_bookmark) /* Fetch a line */
d936 2
a937 2
    cinfo->current_bookmark = -1; /* in case of error exit - set correctly at end */
    cinfo->entropy->restore_state(cinfo, &cinfo->bookmarks[bookmark]); /* restore the stream */
d1015 1
a1015 1
    cinfo->current_bookmark = bookmark; /* line completed correctly - remember for next time. */
d1225 1
a1225 1
   * (estimate for the bookmark array is optimistic, but the band buffer
d1229 1
a1229 1
             sizeof(entropy_state) * (itype == 1 ? ((iheight + 7)/8) : ((iheight + 15)/16)) +
@


4.17.2.14
log
@Push recent changes on the trunk to the IJG8b branch.
Tested briefly, still works.

Version 1.38, 1.35.2.15. Tagged as 'SprExtend-1_38-1_35_2_15'
@
text
@d235 1
a235 1
*    Data source & workspace management.                                  *
d1110 1
a1110 1
    int               page_size;
d1114 1
@


4.16
log
@Reorganise rojpeg.
Aside from moving blocks around and adding comments, decisions about numcomponents use switch/case statements to allow CMYK support in the future.
Split out (some of the) Huffman decoding to allow arithmetic support in the future.
Moved memcpy() and memset() into CSupport.
Tested in all colour depths with 1x1; 1x2; 2x1; 2x2 sampling & ChangeFSI.
Tighten up check on cinfo being NULL (was previously only checked in the colour decoder, not the monochrome).

Version 1.37. Tagged as 'SprExtend-1_37'
@
text
@a39 1
#include "jcconv.c"
d307 116
d563 1
a563 1
      pix = mono_convert_pixel(cinfo, cinfo->last_dc_val[0] * quanttbl[0]);
@


4.15
log
@Obey bit 0 of JPEG_[File]Info flags.
When clear, r2 and r3 are preserved per PRM documentation.
Also BIC'd out bits 7-10 of r0 on return so they can be reused in future, previous version would always have returned &C in those bits.

Version 1.36. Tagged as 'SprExtend-1_36'
@
text
@a15 6
#undef FILE_
#define FILE_ (40000)

#ifdef SOURCE_IS_rojpeg
#  define CFSI
#endif
d23 5
a27 6
/* ----------------- surrogate C library stuff, if embedded use within RISC OS ----------------- */
/* This section is dependent on the way in which the code is embedded into
assembler. It makes use of facilities provided by c.PutScaled for trace output,
since the two in factshare the same namespace. */
#ifdef EMBED

d29 7
a35 23
extern void *memcpy(void *dest, const void *src, size_t n)
{
  char *d = (char*) dest;
  char *s = (char*) src;

  while (n-- > 0) *d++ = *s++;
  return dest;
}

extern void *memset(void *s, int c, size_t n)
{
  char *d = (char*) s;

  while (n-- > 0) *d++ = c;
  return s;
}

#ifdef DEBUG
/* Debug only has an effect if embedded. */

#ifndef assert
#define assert(x, y) do_assert(__LINE__, x, y, NULL)
extern void do_assert(int line, BOOL arg, int error, char *describe); /* defined in c.PutScaled */
a37 50
#ifndef tracef
#define _ ,
#define tracef(args) sprintf(0, args)
extern void sprintf(char *d, char *format, ...); /* defined in c.PutScaled */
#endif

#ifndef newline
#define newline() tracef("\n");
#endif

#else
/* Non-debugging things */

#ifndef tracef
#define tracef(args) ((void) 0)
#endif
#ifndef newline
#define newline() ((void) 0)
#endif
#ifndef assert
#define assert(x, y) do_assert(__LINE__, x, y, NULL)
static void do_assert(int line, BOOL arg, int error, char *describe)
{
  if (!arg)
  {
    tracef("ASSERTION FAILED (line %i): %s\n" _ line _ describe);
    exit(error);
  }
}
#endif

#endif

#else
/* Non-embedded things */
#define verbose 1
/* In the JPEG stuff the trace macros refer to this, so that
j2s can turn on/off the comments dynamically */
#ifdef DEBUG
  #define tracef(args) if (verbose) printf(args)
  static void newline(void) {tracef("\n");}
#else
  #define tracef(args) ((void) 0)
  static void newline(void) {tracef("\n");}
#endif

#endif

/* ----------------- 'global' facilities declared within nested c files ----------------- */

a39 3
#ifdef STATS
  #include "jrevdct4.c"
#endif
a41 1
/* Reassert this file ID, for error exit identification */
d45 5
a49 1
/* ----------------- Assembler debug assistance ----------------------------- */
d53 3
a55 2
to learn what happened. On exit it then returns, usually leading to no picture
being painted. */
d58 1
a58 1
    int i;
d60 6
a65 8
    tracef("Corrupted data in Huffman stream at byte %i\n" _ (char*)regblock[3] - cinfo->input_buffer);
#if 1
      tracef("cinfo=0x%x regblock=0x%x code=%i.\n" _ (int)cinfo _ (int)regblock _ code);
      for (i = 0; i < 16; i++) tracef("R%i=0x%x\n" _ i _ regblock[i]);
      tracef("Nearby input bytes:\n");
      for (i = -10; i < 10; i++) tracef("%i:0x%x " _ i _ ((char*)(regblock[3]))[i]);
      tracef("\n");
#endif
d67 3
a69 3
    UNUSED(cinfo);
    UNUSED(regblock);
    UNUSED(code);
d73 11
d85 15
a99 2
/* ----------------- JPEG entrypoints and control ----------------------------- */
#ifndef CFSI
d123 1
a123 1
      assert(cinfo != 0, ERROR_NO_MEMORY);
d181 1
a181 1
                                     -1, -1, 0, 256*4, 0, &size); /*save palette into newtranstable area */
d184 1
a184 1
                                     -1, -1, &(wp->newtranstable[0]), size, 0); /*save palette into newtranstable area */
d248 3
a250 2
/* Workspace has been allocated. Initialise it, any subsidiary structures etc. Do not
touch the band buffer, might not be allocated yet. */
d252 22
a273 10
  int i;
#if 0
  char *free = (char*) (cinfo + 1);                           /* after the decompress_info_struct itself */
  int size = jpeg_workspace_size();
  char *end = (char*) cinfo + size;
  int *bb = cinfo->band_buffer;
  int bbs = cinfo->band_buffer_size;
#endif
  int wss = cinfo->workspace_size;
  char *t32k = cinfo->table32k;
d275 7
a281 1
  MEMZERO((void*) cinfo, size);
a282 1
  /* Replace workspace size */
d284 1
a284 12
  cinfo->band_buffer = bb;
  cinfo->band_buffer_size = bbs;
#endif
  cinfo->workspace_size = wss;
  cinfo->table32k = t32k;

#if 0
  cinfo->comp_info = (jpeg_component_info *) free; /* pointer to array of components */
  free = (char*) ((jpeg_component_info *) free + 3);

  /* Set up pointers to subsidiary structures */
  for (i = 0; i < NUM_QUANT_TBLS; i++)                  /* allocate quantisation tables */
d286 4
a289 21
    cinfo->quant_tbl_ptrs[i] = (QUANT_TBL_PTR) free;
    free = (char*) ((QUANT_TBL *) free + 1);
  }
  for (i = 0; i < NUM_HUFF_TBLS; i++)
  {
    cinfo->dc_huff_tbl_ptrs[i] = (HUFF_TBL *) free;
    free = (char*) ((HUFF_TBL *) free + 1);
    cinfo->ac_huff_tbl_ptrs[i] = (HUFF_TBL *) free;
    free = (char*) ((HUFF_TBL *) free + 1);
  }

  /* Check we got the size right */
  assert(free == end);
#else
  cinfo->comp_info = &(cinfo->s_cur_comp_info[0]);
  for (i = 0; i < NUM_QUANT_TBLS; i++)                  /* allocate quantisation tables */
    cinfo->quant_tbl_ptrs[i] = (QUANT_VAL*) &(cinfo->s_quant_tbl[i]);
  for (i = 0; i < NUM_HUFF_TBLS; i++)
  {
    cinfo->dc_huff_tbl_ptrs[i] = &(cinfo->s_dc_huff_tbl[i]);
    cinfo->ac_huff_tbl_ptrs[i] = &(cinfo->s_ac_huff_tbl[i]);
d292 12
d306 5
a310 11
#define BADFILE(reason) {tbad(reason,0,0); cinfo->error_code = reason; return reason;}
#define BADFILE1(reason,arg) {tbad(reason,arg,0); cinfo->error_code = reason; cinfo->error_argument1 = arg; return reason;}
#define BADFILE2(reason,arg1,arg2) \
  {tbad(reason,arg1,arg2); cinfo->error_code = reason; cinfo->error_argument1 = arg1; cinfo->error_argument2 = arg2; return reason;}
#if 0
  static void tbad(int r, int a1, int a2) {tracef("bad file (%i,%i,%i)\n" _ r _ a1 _ a2);}
#else
  #define tbad(r,a1,a2) ((void*) 0)
#endif

/* --------------------------------------------------------------------------------------------- */
d313 3
a315 1
/* Save the current state of the huffman stream, so that we could restart reading at this point. */
a316 1
#if 1
a320 1
#endif
a342 1
#if 1
d344 2
a345 2
    if (!(cinfo->input_buffer < cinfo->next_input_byte && cinfo->next_input_byte < cinfo->buffer_end))
      tracef("oops restore_huff_stream: 0x%x 0x%x 0x%x\n" _ (int)cinfo->input_buffer _ (int)cinfo->next_input_byte _ (int)cinfo->buffer_end);
a348 34
#endif
}

/* --------------------------------------------------------------------------------------------- */

/* Coping with restarts - whoever put restarts in this standard? */

static void process_restart(decompress_info_ptr cinfo)
/* We should be precisely at a restart marker */
{
  char c = *cinfo->next_input_byte++;
  int ci;

#if 0
  tracef("Processing restart marker %i at %i bytes\n" _ cinfo->next_restart_num _ cinfo->next_input_byte - cinfo->input_buffer);
  {
    int i;
    tracef("inbuf=0x%x nbits=%i inptr=0x%x file=0x%x\n" _ cinfo->get_buffer _ cinfo->bits_left _ (int)cinfo->next_input_byte _ (int)cinfo->input_buffer);
    for (i = -10; i < 10; i++) tracef("%i:0x%x " _ i _ cinfo->next_input_byte[i]);
    tracef("\n");
  }
  #endif
  assert(cinfo->bits_left <= 7, ERROR_BAD_JPEG);
  assert(c == 0xff, ERROR_BAD_JPEG);
  while (*cinfo->next_input_byte == 0xff) cinfo->next_input_byte++; /* additional 0xffs allowed at this point */
  c = *cinfo->next_input_byte++;
  assert((c & 0xF8) == 0xD0, ERROR_BAD_JPEG); /* RST0..RST7 markers */
  assert((c & 7) == cinfo->next_restart_num, ERROR_BAD_JPEG); /* should be precisely the correct marker */
  /* It appears to be a correctly formed restart marker */
  cinfo->bits_left = 0;       /* flush the remaining bits */
  cinfo->get_buffer = 0;
  cinfo->restarts_to_go = cinfo->restart_interval;
  cinfo->next_restart_num = (cinfo->next_restart_num + 1) & 7;
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) cinfo->last_dc_val[ci] = 0;
d355 3
a357 2
/* Just like asm_huff_skip_blocks, but handles restart markers */
/* If block_per_mcu then count one restart interval per block, else just count one. */
a379 1

d384 3
a386 2
/* Just like asm_huff_decode_blocks, but handles restart markers */
/* If block_per_mcu then count one restart interval per block, else just count one. */
d409 5
d415 1
a415 4
/* --------------------------------------------------------------------------------------------- */
#ifdef CFSI
int do_jpeg_scan_file(char *space, int space_size, char *file_image, int image_length)
/* Simple entry sequence for use by ChangeFSI */
d417 60
a476 1
  decompress_info_ptr cinfo = (decompress_info_ptr) space;
d478 1
a478 3
  cinfo->workspace_size = space_size;
  cinfo->error_code = -1; /* force total reset */
  return jpeg_scan_file(cinfo, file_image, image_length, 0, 0x7fffffff, -1, -1, 0);
d481 1
a481 2
int do_jpeg_scan_file_16(char *space, int space_size, char *file_image, int image_length)
/* Simple entry sequence for use by ChangeFSI - 16bpp output. */
d483 164
a646 1
  decompress_info_ptr cinfo = (decompress_info_ptr) space;
d648 1
a648 3
  cinfo->workspace_size = space_size;
  cinfo->error_code = -1; /* force total reset */
  return jpeg_scan_file(cinfo, file_image, image_length, 0, 0x7fffffff, -1, -1, jopt_OUTBPP_16);
d650 18
a667 1
#endif
d672 2
a673 1
a bit illogical. cinfo->error_code is also important. */
d676 2
a698 7
#if 0
  /* Paranoid check that band buffer and workspace do not overlap. */
  assert(cinfo->band_buffer == 0
        || (int*)cinfo->band_buffer + cinfo->band_buffer_size <= (int*)cinfo
        || (char*)cinfo + sizeof(struct decompress_info_struct) <= (char*) cinfo->band_buffer);
#endif

d714 1
a714 1
     && cinfo->check3 == ((int*)file_image)[image_length/4 - image_length/(8*4)]
a715 1
     /* In the compressed data, any change will perturb the whole file - we trust! */
a716 2
  /* >>> We could allow the image to be shifted in store, might help considerably with some clients.
  The other tests are surely adequate. Would have to shift all the pointers in the huff_pointer array. */
d723 4
d739 1
a739 1
    cinfo->band_buffer = 0;
a764 4
#ifdef DEBUG
    if (file_image[18] != 0) tracef("Packed RGB thumbnail size: %ix%i.\n" _ file_image[18] _ file_image[19]);
#endif

d784 2
d788 4
a791 5
  if (cinfo->data_precision != 8) BADFILE1(E_PRE_NOT_8, cinfo->data_precision)
  /* if (cinfo->restart_interval != 0) BADFILE1(E_RESTART, cinfo->restart_interval) */
  if (cinfo->num_components != cinfo->comps_in_scan) BADFILE(E_MULTI_SCAN)
  if (cinfo->image_width != width && width != -1) BADFILE1(E_WIDTH, cinfo->image_width)
  if (cinfo->image_height != height && height != -1) BADFILE1(E_HEIGHT, cinfo->image_height)
d794 2
a795 1
  buffer currently is. */
d797 1
a797 2
    int mcu_height = 8 * cinfo->comp_info[0].v_samp_factor; /* 8 or 16 */
    /*int mcu_width = 8 * cinfo->comp_info[0].h_samp_factor;*/ /* 8 or 16 */
d804 1
a804 1
      BADFILE2(E_TOO_WIDE, cinfo->image_width, cinfo->band_buffer_size / mcu_height)
d808 1
a808 1
  if (cinfo->num_components == 1)
d810 2
a811 14
    /* if (cinfo->image_height > 8 * HPOINTERS) BADFILE2(E_TOO_HIGH, cinfo->image_height, 8 * HPOINTERS) */
    if (cinfo->jpeg_color_space != CS_GRAYSCALE) BADFILE1(E_COLOUR, cinfo->jpeg_color_space)
    /* if (cinfo->image_width > cinfo->band_buffer_size / 8) BADFILE2(E_TOO_HIGH, cinfo->image_width, cinfo->band_buffer_size / 8) */
    if (cinfo->comp_info[0].h_samp_factor != 1
       || cinfo->comp_info[0].v_samp_factor != 1
       ) BADFILE2(E_BAD_SAMPLE, cinfo->comp_info[0].h_samp_factor, cinfo->comp_info[0].v_samp_factor)
    tracef("Greyscale file.\n");
    {
      int height = 0;
      jpeg_component_info * compptr = cinfo->cur_comp_info[0];
      HUFF_TBL *dc = cinfo->dc_huff_tbl_ptrs[compptr->dc_tbl_no];
      HUFF_TBL *ac = cinfo->ac_huff_tbl_ptrs[compptr->ac_tbl_no];
      QUANT_TBL_PTR quanttbl = cinfo->quant_tbl_ptrs[compptr->quant_tbl_no];
      int hpointer_index = 0;
d813 3
a815 1
      while (height < cinfo->image_height)
d817 5
a821 13
        /* save the state of the huff stream. */
        save_huff_stream(cinfo, &cinfo->huff_pointers[hpointer_index]);
        hpointer_index++;
        do_huff_skip_blocks(cinfo, cinfo->jblocks[0], dc, ac, quanttbl, &cinfo->last_dc_val[0], (cinfo->image_width + 7) >> 3, TRUE);
        height += 8;
        /* tracef("Scanned a band, bytes left = %i.\n" _ cinfo->buffer_end - cinfo->next_input_byte); */
      }
    }
    options &= ~(jopt_OUTBPP_16 | jopt_OUTBPP_8YUV); /* haven't got optimised colour conversion for 16bpp output */
    tracef("Clearing 8YUV because of Greyscale flag\n");
  }
  else if (cinfo->num_components == 3)
  {
d823 1
a823 19
    /* A usual MCU (minimum coding unit) contains 4 Y blocks, 1 U block, 1 V block.
    We will accept MCUs of 1:1:1 or 2:1:1 as well, since there are examples of this.
    JFIF allows an arbitrary ratio - seems uncecessary. A band is always 1 MCU high. */
    int vsamp = cinfo->comp_info[0].v_samp_factor;
    int hsamp = cinfo->comp_info[0].h_samp_factor;

    if (cinfo->comp_info[0].h_samp_factor > 2 || cinfo->comp_info[0].v_samp_factor > 2)
      BADFILE2(E_BAD_SAMPLE, cinfo->comp_info[0].h_samp_factor, cinfo->comp_info[0].v_samp_factor)
    if (cinfo->comp_info[1].h_samp_factor != 1 || cinfo->comp_info[1].v_samp_factor != 1)
      BADFILE2(E_BAD_SAMPLE, cinfo->comp_info[1].h_samp_factor, cinfo->comp_info[1].v_samp_factor)
    if (cinfo->comp_info[2].h_samp_factor != 1 || cinfo->comp_info[2].v_samp_factor != 1)
      BADFILE2(E_BAD_SAMPLE, cinfo->comp_info[2].h_samp_factor, cinfo->comp_info[2].v_samp_factor)
/*    if (cinfo->image_height > 8 * vsamp * HPOINTERS) BADFILE2(E_TOO_HIGH, cinfo->image_height, 8 * vsamp * HPOINTERS) */
    if (cinfo->jpeg_color_space != CS_YCbCr) BADFILE1(E_COLOUR, cinfo->jpeg_color_space)
/*    if (cinfo->image_width > cinfo->band_buffer_size / (8*hsamp)) BADFILE2(E_TOO_WIDE, cinfo->image_width, cinfo->band_buffer_size /(8*hsamp)) */
    tracef("Interleaved YUV colour file.\n");
    /* if (cinfo->image_height & 15 != 0) tracef("Warning - height not multiple of 16.\n"); */
    /* if (cinfo->image_width & 15 != 0) tracef("Warning - width not multiple of 16.\n"); */
    /* >>> Check that the components are in the order we expect/assume! */
d825 12
a836 1
    if (hsamp != 2 || vsamp != 2) options &= ~(jopt_OUTBPP_16 | jopt_OUTBPP_8YUV); /* haven't got optimised colour conversion for unusual colour blocks */
d838 2
a839 14
    {
      int width;
      int height = 0;
      int hpointer_index = 0;

      HUFF_TBL *ydc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
      HUFF_TBL *yac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
      QUANT_TBL_PTR yquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];
      HUFF_TBL *udc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[1]->dc_tbl_no];
      HUFF_TBL *uac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[1]->ac_tbl_no];
      QUANT_TBL_PTR uquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[1]->quant_tbl_no];
      HUFF_TBL *vdc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[2]->dc_tbl_no];
      HUFF_TBL *vac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[2]->ac_tbl_no];
      QUANT_TBL_PTR vquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[2]->quant_tbl_no];
d841 24
a864 5
      while (height < cinfo->image_height)
      {
        /* save the state of the huff stream. */
        save_huff_stream(cinfo, &cinfo->huff_pointers[hpointer_index]);
        hpointer_index++;
d866 3
a868 2
        width = 0;
        while (width < cinfo->image_width)
d870 1
a870 4
          /* Skip over the six blocks representing this 16*16 square of pixels */
          do_huff_skip_blocks(cinfo, cinfo->jblocks[1], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], hsamp * vsamp, FALSE);
          asm_huff_skip_blocks(cinfo, cinfo->jblocks[5], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
          asm_huff_skip_blocks(cinfo, cinfo->jblocks[6], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
d872 14
a885 2
          /* tracef("Done a block, bytes left = %i.\n" _ cinfo->buffer_end - cinfo->next_input_byte); */
          width += 8 * hsamp;
a886 2
        height += 8 * vsamp;
        /* tracef("Scanned a band, bytes left = %i.\n" _ cinfo->buffer_end - cinfo->next_input_byte); */
d888 9
a896 2
    }
    /* tracef("Finished scan, bytes left over = %i\n" _ cinfo->buffer_end - cinfo->next_input_byte); */
a897 4
  else
    BADFILE1(E_COMPONENTS, cinfo->num_components)

/*  assert(cinfo->error_code == 0);*/
d901 1
a901 1
    int size_per_line = cinfo->band_buffer_size / (8 * cinfo->comp_info[0].h_samp_factor);
d903 4
a906 2
    if (cinfo->image_width * 2 <= size_per_line) cinfo->error_argument1 |= jopt_INTERP_X; /* signal that we'll do it */
    else cinfo->options &= ~jopt_INTERP_X; /* not enough space - remember that we won't do it */
a932 2
/* -------------------------------------------------------------------------------------------- */

d934 3
a936 2
/* This gets called for every line of a rendered image. Most of the time it is fast, every 8 or 16 lines
or so it must do some de-JPEGing of some more data. */
d938 4
a941 3
  int hpointer; /* huff pointer index */
  int l2_band_height = 2 + cinfo->comp_info[0].v_samp_factor; /* log2 of band height - 3 for mono, usually 4 for colour */
  int line_offset = cinfo->band_buffer_size >> l2_band_height; /* offset in words between lines of output */
d944 6
a949 3
  /* coordinates fed into this are RISC OS-style, with 0 meaning the bottom row.
  Reverse this so that 0 means the top row. */
  ycoord = cinfo->image_height - ycoord - 1;
a953 12
#if 0
#ifdef DEBUG
    tracef("jpeg_find_line %i, hpointer=%i current=%i.\n" _ ycoord _ hpointer _ cinfo->current_huff_pointer);
    tracef("cinfo=0x%x band_buffer=0x%x band_buffer_size=%i\n" _ (int)cinfo _ (int)cinfo->band_buffer _ cinfo->band_buffer_size);
    if (ycoord < 0 || ycoord >= cinfo->image_height)
    {
      tracef("ycoord out of bounds, [%i..%i..%i]\n" _ 0 _ ycoord _ cinfo->image_height);
      assert(0);
    }
#endif
#endif

a957 3
    assert(cinfo->band_buffer != 0, ERROR_FATAL); /* someone had better have provided one! */

    /* Restore the huffman stream */
d959 1
a959 1
    restore_huff_stream(cinfo, &cinfo->huff_pointers[hpointer]);
d961 2
a962 1
    if (cinfo->num_components == 1)
d964 3
a966 7
      /* Get a row of blocks into the band buffer */
      int width = 0;
      int *outptr = cinfo->band_buffer;
      jpeg_component_info * compptr = cinfo->cur_comp_info[0];
      QUANT_TBL_PTR quanttbl = cinfo->quant_tbl_ptrs[compptr->quant_tbl_no];
      HUFF_TBL *dc = cinfo->dc_huff_tbl_ptrs[compptr->dc_tbl_no];
      HUFF_TBL *ac = cinfo->ac_huff_tbl_ptrs[compptr->ac_tbl_no];
d968 3
a970 1
      tracef("in mono half of jpeg_find_line\n");
d972 5
a976 3
      if (cinfo->xmin >= 8)
      {
        int count = (cinfo->xmin - 8) >> 3; /* how many blocks we can just skip */
d978 1
a978 63
        do_huff_skip_blocks(cinfo, cinfo->jblocks[0], dc, ac, quanttbl, &cinfo->last_dc_val[0], count, TRUE);
        width += 8*count;
        if (cinfo->options & jopt_OUTBPP_8GREY) outptr += 2*count;
          else outptr += 8*count;
      }

      if (cinfo->options & jopt_DC_ONLY) /* monochrome, only tile values */
      {
        /* We only want a flat value for each tile. Just create a single line but
        do not attempt to collapse this in the x direction, too complex to interface to. */
        while (width < cinfo->xmax) /* the data we want */
        {
          int pix;

          do_huff_skip_blocks(cinfo, cinfo->jblocks[1], dc, ac, quanttbl, &cinfo->last_dc_val[0], 1, TRUE);
          pix = mono_convert_pixel(cinfo, cinfo->last_dc_val[0] * quanttbl[0]);
          outptr[0] = pix;
          outptr[1] = pix;
          outptr[2] = pix;
          outptr[3] = pix;
          outptr[4] = pix;
          outptr[5] = pix;
          outptr[6] = pix;
          outptr[7] = pix;
          width += 8;
          outptr += 8;
        }
        nlines_fetched = 1;
      }
      else /* mono normal case, all pixels required */
      {
        while (width < cinfo->xmax) /* the data we want */
        {
          /* Could convert and DCT the data 6 blocks at a time? Increases cache requirement... so, we won't */
          do_huff_decode_blocks(cinfo, cinfo->jblocks[1], dc, ac, quanttbl, &cinfo->last_dc_val[0], 1, TRUE);
#ifdef TIMINGS
          if (!(cinfo->options & jopt_HUFF_ONLY))
#endif
          {
#ifdef STATS
              if (stats)
                j_rev_dct(cinfo, cinfo->jblocks[1], 1); /* output in jblocks[0] */
              else
#endif
                asm_j_rev_dct(cinfo, cinfo->jblocks[1], 1); /* output in jblocks[0] */
#ifdef TIMINGS
              if (!(cinfo->options & jopt_DCT_ONLY))
#endif
              if (cinfo->options & jopt_OUTBPP_8GREY)
                asm_mono_convert_block_8(cinfo->jblocks[0], outptr, line_offset);
              else
                asm_mono_convert_block(cinfo->jblocks[0], outptr, line_offset);
          }
          width += 8;
          if (cinfo->options & jopt_OUTBPP_8GREY)
            outptr += 2;
          else
            outptr += 8;
        }
        nlines_fetched = 8;
      }
    }
    else /* colour */
d980 2
a981 13
      int width = 0;
      int *outptr = cinfo->band_buffer;
      HUFF_TBL *ydc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
      HUFF_TBL *yac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
      QUANT_TBL_PTR yquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];
      HUFF_TBL *udc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[1]->dc_tbl_no];
      HUFF_TBL *uac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[1]->ac_tbl_no];
      QUANT_TBL_PTR uquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[1]->quant_tbl_no];
      HUFF_TBL *vdc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[2]->dc_tbl_no];
      HUFF_TBL *vac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[2]->ac_tbl_no];
      QUANT_TBL_PTR vquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[2]->quant_tbl_no];
      int vsamp = cinfo->comp_info[0].v_samp_factor;
      int hsamp = cinfo->comp_info[0].h_samp_factor;
d983 7
a989 194
      tracef("in colour half of jpeg_find_line\n");

      while (width + 8*hsamp <= cinfo->xmin) /* skip over blocks we don't want */
      {
        do_huff_skip_blocks(cinfo, cinfo->jblocks[0], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], hsamp*vsamp, FALSE);
        asm_huff_skip_blocks(cinfo, cinfo->jblocks[0], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
        asm_huff_skip_blocks(cinfo, cinfo->jblocks[0], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
        width += 8*hsamp;
        if (cinfo->options & jopt_OUTBPP_16) outptr += 4*hsamp;
        else if (cinfo->options & jopt_OUTBPP_8YUV) outptr += 2*hsamp;
        else if (cinfo->options & jopt_OUTBPP_8GREY) outptr += 2*hsamp;
        else outptr += 8*hsamp;
      }

      if (cinfo->options & jopt_DC_ONLY) /* colour, only want pixel tile values */
      {
        while (width < cinfo->xmax) /* the data we want */
        {
          int y[4];
          int u;
          int v;
          int i;

          do_huff_skip_blocks(cinfo, cinfo->jblocks[1], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], 1, FALSE);
          y[0] = cinfo->last_dc_val[0] * yquanttbl[0];
          for (i = 1; i < hsamp*vsamp; i++)
          {
            asm_huff_skip_blocks(cinfo, cinfo->jblocks[1 + i], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], 1);
            y[i] = cinfo->last_dc_val[0] * yquanttbl[0];
          }
          asm_huff_skip_blocks(cinfo, cinfo->jblocks[5], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
          asm_huff_skip_blocks(cinfo, cinfo->jblocks[6], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
          if (cinfo->options & jopt_GREY) /* greyscale output is acceptable */
          {
            tracef("about to do replicate some luma\n");
            mono_convert_pixels(y); /* results back in y[0..3] */
            if (cinfo->options & jopt_OUTBPP_8GREY)
            {
              /* Native greyscale 8bpp */
              outptr[0] = outptr[1] = YYYTOYYYY(y[0]);
              if (hsamp == 2) outptr[2] = outptr[3] = YYYTOYYYY(y[1]);
              if (vsamp == 2)
              {
                outptr[line_offset + 0] = outptr[line_offset + 1] = YYYTOYYYY(y[hsamp == 2 ? 2 : 1]);
                if (hsamp == 2) outptr[line_offset + 2] = outptr[line_offset + 3] = YYYTOYYYY(y[3]);
              }
            }
            else
            {
              /* Output greyscale 24bpp, and dither it later if needed */
              for (i = 0; i < 8; i++)
              {
                outptr[0 + i] = y[0];
                if (hsamp == 2) outptr[8 + i] = y[1];
                if (vsamp == 2)
                {
                  outptr[line_offset + 0 + i] = y[hsamp == 2 ? 2 : 1];
                  if (hsamp == 2) outptr[line_offset + 8 + i] = y[3];
                }
              }
            }
          }
          else
          {
            u = cinfo->last_dc_val[1] * uquanttbl[0];
            v = cinfo->last_dc_val[2] * vquanttbl[0];
            /* tracef("Colour values %i %i %i %i, %i %i\n" _ y[0] _ y[1] _ y[2] _ y[3] _ u _ v); */
            colour_convert_pixels(y, u, v); /* results back in y[0..3] */
            /* tracef("Converted colour values %i %i %i %i, %i %i\n" _ y[0] _ y[1] _ y[2] _ y[3] _ u _ v); */
            for (i = 0; i < 8; i++)
            {
              outptr[i] = y[0];
              if (hsamp == 2) outptr[8+i] = y[1];
              if (vsamp == 2)
              {
                outptr[line_offset+i] = y[hsamp == 2 ? 2 : 1];
                if (hsamp == 2) outptr[line_offset+8+i] = y[3];
              }
            }
          }
          width += 8*hsamp;
          if (cinfo->options & jopt_OUTBPP_16) outptr += 4*hsamp;
          else if (cinfo->options & jopt_OUTBPP_8YUV) outptr += 2*hsamp;
          else if (cinfo->options & jopt_OUTBPP_8GREY) outptr += 2*hsamp;
          else outptr += 8*hsamp;
        }
        nlines_fetched = vsamp;
      }
      else /* colour, normal case (want all pixels) */
      {
        while (width < cinfo->xmax) /* the data we want */
        {
          do_huff_decode_blocks(cinfo, cinfo->jblocks[1], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], hsamp*vsamp, FALSE);
          asm_huff_decode_blocks(cinfo, cinfo->jblocks[5], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
          asm_huff_decode_blocks(cinfo, cinfo->jblocks[6], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
#ifdef TIMINGS
          if (!(cinfo->options & jopt_HUFF_ONLY))
#endif
          {
#ifdef TIMINGS
            if (!(cinfo->options & jopt_DCT_ONLY))
#endif
            {
              if (cinfo->options & jopt_GREY) /* greyscale output is acceptable */
              {
                tracef("about to do some grey conversion\n");
                if (cinfo->options & jopt_OUTBPP_8GREY)
                {
                  asm_j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
                  asm_mono_convert_block_8(cinfo->jblocks[0], outptr, line_offset);
                  if (hsamp == 2) asm_mono_convert_block_8(cinfo->jblocks[1], outptr + 2, line_offset);
                  if (vsamp == 2)
                  {
                    asm_mono_convert_block_8(cinfo->jblocks[hsamp == 1 ? 1 : 2], outptr + 8*line_offset, line_offset);
                    if (hsamp == 2) asm_mono_convert_block_8(cinfo->jblocks[3], outptr + 8*line_offset + 2, line_offset);
                  }
                }
                else
                {
#ifdef STATS
                  if (stats)
                    j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
                  else
#endif
                    asm_j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
                  asm_mono_convert_block(cinfo->jblocks[0], outptr, line_offset);
                  if (hsamp == 2) asm_mono_convert_block(cinfo->jblocks[1], outptr + 8, line_offset);
                  if (vsamp == 2)
                  {
                    asm_mono_convert_block(cinfo->jblocks[hsamp == 1 ? 1 : 2], outptr + 8*line_offset, line_offset);
                    if (hsamp == 2) asm_mono_convert_block(cinfo->jblocks[3], outptr + 8*line_offset + 8, line_offset);
                  }
                }
              }
              else
              {
                tracef("about to do some colour conversion\n");

                if (hsamp*vsamp == 4)
                {
#ifdef STATS
                    if (stats)
                      j_rev_dct(cinfo, cinfo->jblocks[1], 6); /* output in jblocks[0..5] */
                    else
#endif
                      asm_j_rev_dct(cinfo, cinfo->jblocks[1], 6); /* output in jblocks[0..5] */ /* usual, speed-critical case */
                  if (cinfo->options & jopt_OUTBPP_16)
                    asm_colour_convert_block_16(cinfo->jblocks[0], (short int*) outptr, line_offset);
                  else if (cinfo->options & jopt_OUTBPP_8YUV)
                    asm_colour_convert_block_8(cinfo->jblocks[0], (char*) outptr, line_offset);
                  else
                    asm_colour_convert_block(cinfo->jblocks[0], outptr, line_offset);
                }
                else
                {
#ifdef STATS
                    if (stats)
                    {
                      j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* weird aspect ratio - only do DCTs we need to do */
                      j_rev_dct(cinfo, cinfo->jblocks[5], 2);
                    }
                    else
#endif
                    {
                      asm_j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* weird aspect ratio - only do DCTs we need to do */
                      asm_j_rev_dct(cinfo, cinfo->jblocks[5], 2);
                    }
                  colour_convert_unusual_block(cinfo->jblocks[0], outptr, line_offset, hsamp, vsamp);
                }
              }
            }
#ifdef TIMINGS
            else /* for timing experiments - still do the DCTs */
                 /* we don't gather stats and timings at the same time, so no need to check STATS */
            {
              if (hsamp*vsamp == 4)
                asm_j_rev_dct(cinfo, cinfo->jblocks[1], 6); /* output in jblocks[0..5] */ /* usual, speed-critical case */
              else
              {
                asm_j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* weird aspect ratio - only do DCTs we need to do */
                asm_j_rev_dct(cinfo, cinfo->jblocks[5], 2);
              }
            }
#endif
          }
          width += 8*hsamp;
          if (cinfo->options & jopt_OUTBPP_16) outptr += 4*hsamp;
          else if (cinfo->options & jopt_OUTBPP_8YUV) outptr += 2*hsamp;
          else if (cinfo->options & jopt_OUTBPP_8GREY) outptr += 2*hsamp;
          else outptr += 8*hsamp;
        } /* while */
        nlines_fetched = 8*vsamp;
      } /* if */
    } /* if */
d991 1
a991 4
    if (cinfo->options & jopt_DIFFUSE)
    /*cinfo->options & jopt_OUTBPP_8*/ /* convert to 8bpp output, for instance by dithering */
    {
      if (/*cinfo->table32k == 0 && */!cinfo->table32k_unavailable)
d994 3
a996 1
        fail then never try again, probably running on old OS/ColourTrans where it isn't available. */
a1001 1
      /* tracef("Doing dithering to 8bpp on %i lines\n" _ nlines_fetched); */
d1005 1
a1005 10
        int *line = cinfo->band_buffer + cinfo->xmin;
        int linelen = cinfo->xmax - cinfo->xmin;
        char *outptr = (char*) cinfo->band_buffer + cinfo->xmin;

        /* The error diffusion cannot handle a very thin strip at the right, eg one pixel wide. So the last
        unit of diffusion may be up to 31 pixels. However, the units of diffusion until then must
        be unaffected by exactly what xmin/xmax are, or we will get minor pixel variation depending
        on the clipping. xmin is already a multiple of 16. */
        linelen = (linelen + 15) & ~15; /* round up to a multiple of 16 */
        if (linelen > cinfo->image_width - cinfo->xmin) linelen = cinfo->image_width - cinfo->xmin;
a1006 1
//        if (cinfo->options & jopt_INTERP_X) {line += cinfo->xmin; linelen += linelen;} /* double if you have interpolated */
d1013 1
a1013 1
          outptr = outptr + blockwidth;
d1016 1
a1020 2
        int *line = cinfo->band_buffer + cinfo->xmin;
        int linelen = cinfo->xmax - cinfo->xmin;
a1022 8
        /* The error diffusion cannot handle a very thin strip at the right, eg one pixel wide. So the last
        unit of diffusion may be up to 31 pixels. However, the units of diffusion until then must
        be unaffected by exactly what xmin/xmax are, or we will get minor pixel variation depending
        on the clipping. xmin is already a multiple of 16. */
        linelen = (linelen + 15) & ~15; /* round up to a multiple of 16 */
        if (linelen > cinfo->image_width - cinfo->xmin) linelen = cinfo->image_width - cinfo->xmin;

//        if (cinfo->options & jopt_INTERP_X) {line += cinfo->xmin; linelen += linelen;} /* double if you have interpolated */
d1028 1
a1028 1
          asm_diffuse_to_24bpp(line, blockwidth, (int *)outptr, cinfo->table32k, nlines_fetched, line_offset, palette_data);
a1037 1
    /* tracef("Done requested band, bytes left = %i.\n" _ cinfo->buffer_end - cinfo->next_input_byte); */
d1040 10
a1049 1
  /* The band buffer now contains suitable pixels */
d1051 2
a1052 15
    int* result = cinfo->band_buffer;

    if (cinfo->options & jopt_DC_ONLY)
    {
      /* Rather than copy the data 8 times, the DC content is spaced out by just 1 line and the
       * address frigged here to point to one or the other
       */
      if (l2_band_height == 4 && (ycoord & 0xf) >= 8)
        result += line_offset;
    }
    else /* normal - choose between 8 or 16 rows of pixels */
      result += (ycoord & ((1<<l2_band_height)-1)) * line_offset;

    /* tracef("result=0x%x\n" _ (int)result); */
    return result;
d1054 2
@


4.14
log
@API enhancement and space saving refactoring.
Setting bit 1 of r0 in JPEG_FileInfo and JPEG_Info will now return the SOF type of the JPEG in question in bits 3-6 of the info flags in r0 on exit.
Took this opportunity to refactor find_image_dims to take a structure pointer rather than lots of individual pointers (CFSI-JPEG ammended to match). Untangled the return codes a bit so it is only necessary to inspect r0 on exit from C to determine the outcome. Values of 1 & 2 are translated in the assembler code into more specific error messages than just "Incomplete or corrupt JPEG".
Fix bug where unknown density marker would leave the file open in JPEG_FileInfo.
Don't bother ADRL'ing r1 for error messages that don't have a %0 in them.
Added all the input & output flag definitions to the exported header file so other callers can use them too.
More functionality, fewer bugs, about 200 bytes smaller too.

Version 1.35. Tagged as 'SprExtend-1_35'
@
text
@d1388 1
a1388 1
    itype |= (jdata[1] << 8); /* mix in the SOF type */
@


4.13
log
@Fix infinite loop when unrecognised entropy encoding encountered.
In find_image_dims() the while loop is only exited when SOF0 or SOF1 (the two supported ones) is encountered, the other 14 possible combinations got stuck in a loop because OS_GBPB doesn't return an error at EOF.
Check added for OS_GBPB returning nothing, plus an exit when a SOS or EOI tag is hit for the memory only check (it's not possible to know where the end truly is in that case.
jcconv: warning supressed.
SWIs: comment corrected.
Tested with a bogus SOF, now gives an error message instead.

Version 1.34. Tagged as 'SprExtend-1_34'
@
text
@a1215 5
/* --------------------------------------------------------------------- */
/* Stuff that scans a JPEG file and tells you the image height and
width, so that you can call jpeg_scan_file with sensible amounts of
workspace. Used by the ChangeFSI code, and by j2s. */

d1221 2
d1226 1
a1226 15
static BOOL looks_like_jpeg(char *jdata)
/* Just check there's a SOI tag, the other decoding software can look
   at the M_APPn tags. Thus we let through JFIF and EXIF at this stage
   See JFIF 1.02 spec
       EXIF 2.00 spec */
{
  if (jdata[0] != 0xff || jdata[1] != M_SOI || jdata[2] != 0xff) return FALSE;
  return TRUE;
}

int find_image_dims(char *jdata, int *image_width, int *image_height, int *image_type,
#ifndef CFSI
                    int *image_density,
#endif
                    int *ws_size, int *err)
d1228 7
a1234 3
code so that you can decide these things before you allocate the band buffer
etc. Returns 0 if all is OK, 1 if this is not kosher JPEG data. Returns
recommended minimum space needed by jpeg_scan_file in ws_size. */
d1240 1
a1240 1
  BOOL            load_file = FALSE;
d1251 2
a1252 4
  if (((unsigned)ws_size & 3) == 1)
    load_file = TRUE;

  if (load_file) /* We need to load the file... */
d1254 1
a1254 3
    tracef("We think it's a filename\n");
    tracef("file = '%s'\n" _ jdata);
    tracef("Got to 1\n");
d1256 1
a1256 1
    if (e != 0)
d1258 2
a1259 6
      tracef("e points to '%s'\n" _ e->errmess);
      tracef("err is %x\n" _ err);
      *err = (int)e;
      tracef("err points to %x\n" _ e);
      tracef("err is %x\n" _ err);
      return((int)e);
a1260 1
    tracef("Got to 2\n");
d1262 1
a1262 1
    tracef("Got to 3. buffer = %x\n" _ buffer);
d1268 1
a1268 2
      *err = (int)e;
      return((int)e);
d1270 1
a1270 1
    tracef("Got to 4 jdata = %x, data_end = %x\n" _ jdata _ dataend);
d1275 6
a1280 1
  if (!looks_like_jpeg(jdata))
d1282 1
a1282 1
    tracef("it ain't a jpeg\n");
a1285 1
      tracef("trying to close file\n");
d1287 1
a1287 5
      if (e != 0)
      {
        *err = (int)e;
        return((int)e);
      }
d1296 2
d1299 1
a1302 3
      {
        int xdens, ydens;
    
d1312 1
a1312 1
        itype |= 0x100;    /* set bit in type word to indicate density is only a ratio */
d1314 1
a1314 1
      }
a1315 2
      {
        tracef("  jdata[14-17], %x %x %x %x\n" _ jdata[14] _ jdata[15] _ jdata[16] _ jdata[17]);
d1319 1
a1319 1
      }
a1320 1
      {
d1324 1
a1324 1
      }
d1326 5
a1330 2
      {
        /* No idea what this means */
a1331 1
      }
d1337 1
a1337 1
    itype |= 0x100;    /* set bit in type word to indicate density is only a ratio */
d1344 2
a1345 1
  sprite header. Walk into the JPEG file until we find the SOF marker. */
d1348 4
a1351 5
  while (jdata[0] == 0xff   &&
         jdata[1] != M_SOF0 &&
         jdata[1] != M_SOF1 && /* until we get to a supported SOF marker */
         jdata[1] != M_SOS  &&
         jdata[1] != M_EOI)    /* or start of scan or end of image */
d1361 3
a1363 2
         such that the new tag is at the start of the RAM, thus there's no
         danger of reading the 'next offset' from off the end of buffer */
d1372 6
a1377 2
        *err = (int)e;
        return((int)e);
a1378 1
      if ((int)jdata == dataend) break; /* nothing was transferred, must be EOF */
d1382 2
a1383 2
  
  if (jdata[1] == M_SOF0 || jdata[1] == M_SOF1) /* found an SOF marker */
d1387 2
a1388 1
    itype |= jdata[9]; /* or 3 for YUV, the other state we can accept. */
d1392 3
a1394 4
    tracef("Header looks like JPEG data, but can't find image height/width.\n");
    return 1;
    /* It's hard to be more specific than this. The header of the file looks like
    JPEG, but it has been truncated, or has the wrong sort of entropy encoding. */
d1398 6
a1403 4
     (estimate for the huff_pointer array is optimistic, but the band buffer size is vastly pessimistic) */
  new_size = sizeof(struct decompress_info_struct) + 1024
            + sizeof(huff_pointer) * (itype==1 ? ((iheight + 7)/8) : (iheight + 15/16))
            + (itype == 1 ? 8 : 16) * (iwidth + 15) * sizeof(int);
d1406 5
a1410 3
  if (image_height) *image_height = iheight;
  if (image_width) *image_width = iwidth;
  if (image_type) *image_type = itype;
d1412 3
a1414 1
  if (image_density) *image_density = pixel_density;
d1416 1
d1456 1
a1456 2
      *err = (int)e;
      return((int)e);
a1463 1
  UNUSED(err);
@


4.12
log
@Change memory management strategy.
There's no need for the C code to know which pool of memory it's using, so simplify it to just use malloc() and realloc(), the assembler implementation can then select whether the RMA or a dynamic area is in use based on the 'dynamicarea' switch.
Be more careful about area_number when it is zero, since we use that to denote the area is not yet set up but area zero is a valid dynamic area number!
Trim out some unused workspace.
Variable ccompiler_errptr had '# 0' bytes assigned, resulting in writes off the end of the workspace.
Retire DUMPVAL[N]() macro.
Remove M_SOF9 as one of the SOF markers accepted - this is allocated to arithmetic JPEGs which aren't currently supported.
Save a few words by: changing arbitrary constants (eg. safety margins) to be a power of two so they can be register immediates; numerous loads and stores of R12 relative variables changed to not use ADRL; jpeg_fetchroutine similarly simplified.

Version 1.33. Tagged as 'SprExtend-1_33'
@
text
@a503 3
#if 0
  int *band_buffer = (int*) (space + jpeg_workspace_size());
  int band_buffer_size = (space_size - jpeg_workspace_size()) / sizeof(int);
a504 6
  band_buffer_size &= ~0xf; /* only multiples of 16 integers interesting */
  cinfo->band_buffer = band_buffer;
  cinfo->band_buffer_size = band_buffer_size;
  cinfo->error_code = -1; /* force total reset */
  return jpeg_scan_file(cinfo, file_image, image_length, 0, 0x7fffffff, -1, -1, 0);
#else
a507 1
#endif
d1224 2
d1239 1
a1239 2
int find_image_dims(char *jdata, int *image_width, int *image_height,
                           int *image_type,
d1241 1
a1241 1
                           int *image_density,
d1243 1
a1243 1
                           int *ws_size, int *err)
d1286 1
a1286 1
                  4, file_handle, jdata, 1024, &dataend);
d1373 3
a1375 1
         jdata[1] != M_SOF1) /* until we get to SOF marker */
d1391 1
a1391 1
                    3, file_handle, jdata, 1024, current + offset, &dataend);
d1398 1
@


4.11
log
@Paper and fill some JPEG cracks.
The exit_c function was repeatedly being called with the line number argument and error code the wrong way round and since only bits 0-2 of the error code are inspected on exit any fatal exits from the ported JPEG library code would either report the wrong error or fail silently (depending on the line number) - example a 12 bits per sample JPEG would be rendered without fault into a screen full of random memory garbage.
Assembling/compiling with the 'jpeg' switch off didn't work, fixed, and also now zeros out the SWI decode values in the module header.
Moved include of 'yuvtabs.s' into the colour conversion code.
Deleted panic_exit, it did nothing useful but trace a value then exit, so it now just calls exit() like everyone else.
Removed excess call to find_image_dims(), this was needed just to get the workspace requirements when the JPEG had already been sized up by asm_find_image_dims() earlier. Side effect of removing the pilot JPEG code earlier is that this call can now only get to the JPEG code from a JPEG_ SWI. Changed to just pass the workspace requirements into 'c.PutScaled' and save a duplicate scan.
Fatal exits from the assembler huffman decoder now report a sensible error.
Trimmed out all the JPEG assessment code from 'c.PutScaled' and moved it into 'c.rojpeg' so the put scaled is only concerned with putting things scaled.
Sanitised the #includes a bit.
Fixed on last check of wp->save_mode looking at the wrong bits for the mode number.
Resolved all the warning in the genhdr/genyuvtabs/genpalette utilities by casting a bit harder.[A[B
Added new more descriptive error messages to the messages file (not currently used), and made the 'not supported by' ones consistent so the tokeniser might crunch the file a bit more.
In looks_like_jpeg() changed a bitwise to logical or.
Fixed longstanding problem of not being able to render JPEGs at a scale of less than 1/6 in any greyscale mode, because, err, there was no code to do it - only the colour case was checked for. Implemented for 8bpp grey and 32bpp grey (which gets dithered for other lower modes) by just converting the luma channel into an equally weighted RGB value or replicating it for 256 greys.
Tested in all 8 colour depths on a Risc PC using sampling ratios of 1x1; 2x1; 1x2; 2x2 of the IJG test image scaled in !Draw by 0.16.

Version 1.32. Tagged as 'SprExtend-1_32'
@
text
@a156 1
#ifdef DYNAMIC_AREA
d159 6
a164 51
    _kernel_oserror *error;
    int              area_no, size;

    tracef("Creating JPEG Dynamic Area\n");
    area_no = create_dynamic_area(jpeg_ws_size);
    assert(area_no != 0, ERROR_NO_MEMORY);
    error = _swix(OS_ReadDynamicArea, _IN(0) | _OUT(0) | _OUT(1), area_no, &cinfo, &size);
    tracef("JPEG Dynamic area no %d is %x bytes big\n" _ area_no _ size);
    assert(error == NULL, ERROR_FATAL);
    wp->jpeg_info_ptr = cinfo;
    wp->area_number = area_no;
    cinfo->error_code = -1;                      /* mark the workspace entirely uninitialised */
    cinfo->workspace_size = size;
  }
  else
  {
    _kernel_oserror *error;
    int              size;

    tracef("JPEG area exists\n");
    error = _swix(OS_ReadDynamicArea, _IN(0) | _OUT(1), wp->area_number, &size);
    tracef("JPEG area is %x bytes big\n" _ size);
    assert(error == NULL, ERROR_FATAL);
    if ((size > 0) && (size != cinfo->workspace_size))
    {
      cinfo->error_code = -1;
      cinfo->workspace_size = size;
      tracef("Area was resized behind our back, marking area as duff\n");
    }
    if (size < jpeg_ws_size)      /* Need to grow area */
    {
      _kernel_oserror *error;
      int              bytes_moved;
      
      error = _swix(OS_ChangeDynamicArea, _IN(0) | _IN(1) | _OUT(1),
                    wp->area_number, jpeg_ws_size - size, &bytes_moved);
      tracef("JPEG area grown by %x bytes\n" _ bytes_moved);
      assert(error == NULL, ERROR_NO_MEMORY);
      cinfo->error_code = -1;                    /* mark the workspace entirely uninitialised */
      cinfo->workspace_size = size + bytes_moved;
      tracef("JPEG area size recorded as %x bytes\n" _ cinfo->workspace_size);
    }
  }
#else
  if (!cinfo)
  {
    cinfo = malloc(jpeg_ws_size);                /* Allocate space on RMA */
    assert(cinfo != NULL, ERROR_NO_MEMORY);      /* >>>> Got to be a better way of returning this error! */
    wp->jpeg_info_ptr = cinfo;
    cinfo->error_code = -1;                      /* mark the workspace entirely uninitialised */
    cinfo->workspace_size = jpeg_ws_size;
d168 1
a168 1
    if (cinfo->workspace_size < jpeg_ws_size)    /* Need to realloc */
d170 4
a173 2
      cinfo = realloc_delta(cinfo, jpeg_ws_size - cinfo->workspace_size);
      assert(cinfo != 0, ERROR_NO_MEMORY);       /* >>>> Got to be a better way of returning this error! */
a178 1
#endif
a382 1
  /* DUMPVAL(h->bit_pointer) DUMPVALN(h->get_buffer) */
a387 1
  /* DUMPVAL(h->bit_pointer) DUMPVALN(h->get_buffer) */
d540 1
a540 1
  DUMPVALN(cinfo->workspace_size)
d566 4
a569 6
  DUMPVALN(cinfo->error_code)
  DUMPVAL(cinfo->input_buffer) DUMPVALN(file_image)
  DUMPVAL(cinfo->buffer_end - cinfo->input_buffer) DUMPVALN(image_length)
  DUMPVAL(cinfo->check1) DUMPVALN(((int*)file_image)[image_length/(2*4)])
  DUMPVAL(cinfo->check2) DUMPVALN(((int*)file_image)[image_length/4 - image_length/(4*4)])
  DUMPVAL(cinfo->check3) DUMPVALN(((int*)file_image)[image_length/4 - image_length/(8*4)])
d605 2
a606 1
    cinfo->band_buffer_size = 100000000; /* prevent complaints later on */
d1234 2
a1235 3
#define M_SOF0        0xc0
#define M_SOF1        0xc1
#define M_SOF9        0xc9
d1258 1
a1258 2
  int             iwidth;
  int             iheight;
d1260 1
a1260 1
  int             load_file = 0;
d1262 1
a1269 3
#define CMTOINCH      254
#define STANDARDDPI   90

d1271 2
d1274 2
a1275 2
    load_file = 1;
#ifndef CFSI   /* remove when compiling CFSI-jpeg  */
d1309 1
a1310 1
    tracef("it ain't a jpeg\n");
d1327 40
a1366 44
     {
     switch (jdata[13]) /* from JFIF 1.02 definition, if APP0 exists the density units will be here */
            {
            case 0:
                  {
                  int xdens, ydens;
              
                  xdens = STANDARDDPI;
                  ydens = (jdata[14] << 8) + jdata[15]; /* take into account the case where the scale may be 0:0, pah! */
                  if (ydens == 0) ydens = 1;
                  ydens = ((jdata[16] << 8) + jdata[17]) / ydens;
                  if
                    (ydens == 0) ydens = STANDARDDPI;
                  else
                    ydens *=STANDARDDPI;
                  pixel_density = (xdens << 16) | ydens;
                  itype |= 0x100;    /* set bit in type word to indicate density is only a ratio */
                  tracef("0.pixel density in %x\n" _ jdata[13]);
                  break;
                  }
            case 1:
                  {
                  tracef("1.jdata[14-17], %x %x %x %x\n" _ jdata[14] _ jdata[15] _ jdata[16] _ jdata[17]);
                  /* tracef("1.(int)jdata[14], %x\n" _ ((int*)jdata)[14]);*/
                  pixel_density = (jdata[14] << 24) + (jdata[15] << 16) + (jdata[16] << 8) + jdata[17];
                  tracef("1.pixel density in %x\n" _ jdata[13]);
                  /*Should make pixel_density = [XdenHigh XdenLow YdenHigh YdenLow] */
                  break;
                  }
            case 2:
                  {
                  pixel_density = (int)(jdata[14]*CMTOINCH/100) << 24 + (int)(jdata[15]*CMTOINCH/100) << 16
                                   + (int)(jdata[16]*CMTOINCH/100) << 8 + (int)(jdata[17]*CMTOINCH/100);
                  tracef("2.pixel density in %d\n" _ jdata[13]);
                  break;
                  }
            default:
                  {
                  /* No idea what this means */
                  tracef("3.pixel density 'unknown' in %x\n" _ jdata[13]);
                  return 1;
                  }
            }
     }
d1368 6
a1373 5
     {
     tracef("no APP0 tag, assuming a 1:1 xdpi to ydpi ratio\n");
     itype |= 0x100;    /* set bit in type word to indicate density is only a ratio */
     pixel_density = (STANDARDDPI << 16) | STANDARDDPI;
     }
d1375 1
d1378 5
d1384 3
a1386 8
    jdata += 2; /* skip over 0xFF, SOI(0xd8) */
    tracef("jdata = %x\n" _ jdata);
    while (  1 /* jdata < jdata_max */
          && jdata[0] == 0xff
          && jdata[1] != M_SOF0
          && jdata[1] != M_SOF1
          && jdata[1] != M_SOF9
          ) /* until we get to SOF marker */
d1388 12
a1399 3
      jdata += (jdata[2] << 8) + jdata[3] + 2; /* skip over variable length marker */
#ifndef CFSI
      if( (load_file != 0) && ((int)jdata >= dataend) )  /* need to load up more data */
d1401 3
a1403 17
        int   offset = (int)jdata - dataend;
        int   current;

        /* Next tag isn't in the 1k of RAM so jump forward and load another 1k
           such that the new tag is at the start of the RAM, thus there's no
           danger of reading the 'next offset' from off the end of buffer */
        tracef("Loading another chunk. jdata = %x, offset = %x\n" _ jdata _ offset);
        _swix(OS_Args, _IN(0) | _IN(1) | _OUT(2), 0, file_handle, &current);
        jdata = buffer;
        e = _swix(OS_GBPB, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _IN(4) | _OUT(2),
                      3, file_handle, jdata, 1024, current + offset, &dataend);
        if (e != 0)
        {
          _swix(OS_Find, _IN(0) | _IN(1), 0, file_handle);
          *err = (int)e;
          return((int)e);
        }
d1405 1
a1406 14
    }
    if (jdata[1] == M_SOF0 || jdata[1] == M_SOF1 || jdata[1] == M_SOF9) /* found an SOF marker */
    {
      iheight = (jdata[5] << 8) + jdata[6];
      iwidth = (jdata[7] << 8) + jdata[8];
      itype |= jdata[9]; /* or 3 for YUV, the other state we can accept. */
    }
    else
    {
      tracef("Header looks like JPEG data, but can't find image height/width.\n");
      return 1;
      /* It's hard to be more specific than this. The header of the file looks like
      JPEG, but it has been truncated, or has the wrong sort of entropy encoding. */
    }
d1408 8
a1415 4

  /* tracef("Image width = %i, image height = %i, %s data.\n" _ iwidth _ iheight _ itype == 1 ? "greyscale" : "colour"); */
#ifdef CFSI
  if ((unsigned)ws_size > 1)
d1417 4
a1420 6
    *ws_size = sizeof(struct decompress_info_struct) + 1024
             + sizeof(huff_pointer) * (itype==1 ? ((iheight + 7)/8) : (iheight + 15/16))
             + (itype == 1 ? 8 : 16) * (iwidth + 15) * sizeof(int);
    /* This is pessimistic overall for files with strange Y:U::V sample ratios - don't care.
       (estimate for the huff_pointer array is optimistic, but the band buffer size is vastly pessimistic) */
    *ws_size = (*ws_size + 3) & ~3; /* round up to a multiple of 4 */
d1422 8
d1433 2
a1434 1
  UNUSED(err);
a1435 2
  return 0; /* all is well */
#else
d1438 2
a1439 4
    decompress_info_ptr   info;
    int             current_size,
                    new_size,
                    page_size;
d1442 7
a1448 15
    info = (decompress_info_ptr)*ws_size;
    current_size = info->workspace_size;
    new_size = sizeof(struct decompress_info_struct) + 1024
             + sizeof(huff_pointer) * (itype==1 ? ((iheight + 7)/8) : (iheight + 15/16))
             + (itype == 1 ? 8 : 16) * (iwidth + 15) * sizeof(int);
    /* This is pessimistic overall for files with strange Y:U::V sample ratios - don't care.
       (estimate for the huff_pointer array is optimistic, but the band buffer size is vastly pessimistic) */
    new_size = (new_size + 3) & ~3; /* round up to a multiple of 4 */

    /* if info is not NULL then it points to the current decompress_info_struct which
       contains info about the current memory allocation*/
#ifdef DYNAMIC_AREA
    tracef("We are thinking about a walk into the Dynamic Area...\n");
    _swix(OS_ReadMemMapInfo, _OUT(0), &page_size);
    if (!info)
d1450 1
a1450 1
      new_size = (new_size + page_size-1) & ~(page_size-1);
d1454 1
a1454 2
      tracef("We are walking into the Dynamix Area...\n");
      if (info->workspace_size >= new_size)
d1456 1
a1456 1
        new_size = 0;   /* we already have enough memory */
d1460 1
a1460 2
        new_size -= info->workspace_size;  /* size that will be added to Dynamic area for this jpeg */
        new_size = (new_size + page_size-1) & ~(page_size-1);
d1463 2
a1464 17
#else
    if (!info)
    {
      new_size = new_size + 10000;   /* first jpeg => alloc size we need plus safety margin */
    }
    else
    {
      if (info->workspace_size >= new_size)
      {
        new_size = 0;   /* we already have enough memory */
      }
      else
      {
        new_size = new_size + 20000;  /* size that will be re-alloced for this jpeg */
      }
    }
#endif
d1468 1
a1468 5
  if (image_height) *image_height = iheight;
  if (image_width) *image_width = iwidth;
  if (image_type) *image_type = itype;
  if (image_density) *image_density = pixel_density;
  tracef("4.pixel density in %d\n" _ pixel_density);
d1479 8
a1487 1
#endif
@


4.10
log
@Remove pilot JPEG code.
During the original development (referred to in the docs as Sprite Extend 2) JPEG data was briefly wrapped inside a sprite file before the JPEG_ swis were introduced. Within SpriteExtend some code still remained to fake a mode 20 sprite header with the JPEG output sized adjusted as though it was 4bpp, then later undo the faking by checking for a mode 20 sprite with is_it_jpeg set.
This version removes all of the code looking out for pilot JPEGs, and rationalises the fake sprite header to just report the true X/Y size.
Fix bug where r4 would be corrupted on exit from JPEG_PlotScaled if an error occurred, and generally rationalised the exit cases a bit more sensibly.
Made the JPEG_ swi despatch a bit more simple to follow.
Corrected a comment in the NSM_bpptable.
Deleted unused 'ecfspace' from the workspace.
Hid the 'macroword' from the C code as it's now an assembler only value.
Cut the initial comments from c/putscaled and placed in Docs.
Cut the debug tracing code (a notable %age) from c/putscaled and placed in tracing support file.
Simplified the entry to putscaled_compiler() now we don't have to look out for pilot format JPEGs within sprites any more.
Sprinkled in some block comments to make navigating the c/putscaled file a bit easier.

Version 1.30. Tagged as 'SprExtend-1_30'
@
text
@d26 1
a34 1
extern void exit(int reason); /* Provided by assembler */
a44 9
extern char *strcpy(char *dest, const char *src)
{
  char *d = (char*) dest;
  char *s = (char*) src;

  while (*s > 31) *d++ = *s++;
  return dest;
}

d57 2
a58 1
  #define assert(x, y) do_assert(__LINE__, x, y, 0)
a59 1
extern void do_assert(int line, BOOL arg, int error, char *describe); /* defined in c.PutScaled */
d81 1
a81 1
#define assert(x, y) do_assert(__LINE__, x, y, 0)
d84 1
a84 1
  if (arg == 0)
a108 8
#ifdef ASMHUFF
extern void panic_exit(int i)
{
  tracef("Assembler panic exit %i.\n" _ i);
  exit(i);
}
#endif

d120 1
a120 1
#define FILE_ (10000)
d149 2
d152 2
a153 3
#if 0
static int jpeg_workspace_size(void)
/* Return size of workspace needed */
d155 1
a155 1
  int s;
d157 46
a202 5
#if 0
  s = sizeof(struct decompress_info_struct)
    + 3 * sizeof(jpeg_component_info)          /* max of 3 components allowed */
    + NUM_QUANT_TBLS * sizeof(QUANT_TBL)
    + 2 * NUM_HUFF_TBLS * sizeof(HUFF_TBL);
d204 132
a335 1
  s = sizeof(struct decompress_info_struct);
d337 2
a338 2
  tracef("Workspace block - %i bytes\n" _ s); /* 18776 at 27-oct-93 */
  return s;
d546 1
a546 1

d576 1
d836 1
d849 1
a849 1
    tracef("Exit jpeg_scan_file OK\n\n");
d904 2
a905 1
      /* tracef("Greyscale line.\n"); */
d946 1
a946 1
            if (!(cinfo->options & jopt_HUFF_ONLY))
a988 1
      /* tracef("Fetching colour band\n"); */
d1020 1
a1020 6
          u = cinfo->last_dc_val[1] * uquanttbl[0];
          v = cinfo->last_dc_val[2] * vquanttbl[0];
          /* tracef("Colour values %i %i %i %i, %i %i\n" _ y[0] _ y[1] _ y[2] _ y[3] _ u _ v); */
          colour_convert_pixels(y, u, v); /* results back in y[0..3] */ /* wasteful for weird sample ratios, don't care */
          /* tracef("Converted colour values %i %i %i %i, %i %i\n" _ y[0] _ y[1] _ y[2] _ y[3] _ u _ v); */
          for (i = 0; i < 8; i++)
d1022 3
a1024 3
            outptr[i] = y[0];
            if (hsamp == 2) outptr[8+i] = y[1];
            if (vsamp == 2)
d1026 40
a1065 2
              outptr[line_offset+i] = y[hsamp == 2 ? 2 : 1];
              if (hsamp == 2) outptr[line_offset+8+i] = y[3];
d1069 4
a1072 1
          outptr += 8*hsamp;
d1084 1
a1084 1
            if (!(cinfo->options & jopt_HUFF_ONLY))
d1088 1
a1088 1
              if (!(cinfo->options & jopt_DCT_ONLY))
a1103 1

d1108 3
a1110 3
                    if (stats)
                      j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
                    else
d1112 1
a1112 1
                      asm_j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
d1260 5
a1264 2
      if (l2_band_height == 4 && (ycoord & 0xf) >= 8) /* colour - choose between two rows of pixels */
        result += line_offset; /* second row in colour output */
d1279 7
a1286 2
{

d1291 2
a1292 2

  if (jdata[0] != 0xff | jdata[1] != 0xd8 | jdata[2] != 0xff) return FALSE;
a1320 6
#define M_APP0        0xE0
#define M_APP1        0xE1
#define M_SOI         0xd8
#define M_SOF0        0xc0
#define M_SOF1        0xc1
#define M_SOF9        0xc9
a1336 1
     /* strcpy(err->errmess, e->errmess);*/
d1475 1
a1475 1
      JPEG, but it has been truncated, or has the wrong sort of entropy encoding. */#
a1521 3
/*      new_size += page_size; lets be a bit conservative!!*/
/*      new_size -= (new_size % page_size);
        new_size += page_size<<1;*/
a1533 4
/*      new_size += page_size; lets be a bit conservative!!*/
/*      new_size--;
        new_size -= (new_size % page_size);
        new_size += page_size<<1; */
a1535 2
    *ws_size = new_size;
    tracef("We need another %x bytes\n" _ new_size);
d1538 3
a1540 1
      *ws_size = new_size + 10000;   /* first jpeg => alloc size we need plus safety margin */
d1542 1
d1544 3
a1546 1
        *ws_size = 0;   /* we already have enough memory */
d1548 4
a1551 1
        *ws_size = new_size + 20000;  /* size that will be re-alloced for this jpeg */
d1553 2
d1560 1
a1560 1
  if (image_density) tracef("4.pixel density in %d\n" _ *image_density);
@


4.9
log
@Remove postprocessing step of C code.
Since 2001 this module has been using objasm, but still using the C compiler to output (via -S) assembly code which is then passed through 'sed' and included via GET into the assembler code.
Changed to compile the C code into object files, and use the linker to patch up the unresolved references - this has required some reordering of the C code to make sure static functions now appear in the object file, and some reordering of the header files to ensure both the module and the CFSI version still compile without conflicts.
Minor fix to 'swiv2', the label was in the wrong place for _swi() though it's not used in this module so didn't affect the _swix() case.
Makefile cut down a bit. Unixify some path names.
Test code moved to 'Test/c' directory.
Tested in both debug and non debug cases via softloaded module. Oddly, it's 4 bytes longer than the previous version.

Version 1.28. Tagged as 'SprExtend-1_28'
@
text
@d23 2
a26 1
#include "swis.h"
d105 3
a107 1

d150 1
a150 1
    #if 1
d156 1
a156 1
    #endif
d289 1
a289 1
  #ifdef DEBUG
d292 1
a292 1
  #endif
d308 1
a308 1
  #if 0
d521 1
a521 1
  #ifdef DEBUG
d523 1
a523 1
  #endif
d690 1
a690 1
  #ifdef EMBED
d692 1
a692 1
  #endif
d715 1
a715 1
  #ifdef DEBUG
d723 1
a723 1
  #endif
d786 1
a786 1
          #ifdef TIMINGS
d788 1
a788 1
          #endif
d790 1
a790 1
            #ifdef STATS
d794 1
a794 1
            #endif
d796 1
a796 1
            #ifdef TIMINGS
d798 1
a798 1
            #endif
d889 1
a889 1
          #ifdef TIMINGS
d891 1
a891 1
          #endif
d893 1
a893 1
            #ifdef TIMINGS
d895 1
a895 1
            #endif
d914 1
a914 1
                  #ifdef STATS
d918 1
a918 1
                  #endif
d935 1
a935 1
                  #ifdef STATS
d939 1
a939 1
                  #endif
d950 1
a950 1
                  #ifdef STATS
d957 1
a957 1
                  #endif
d966 1
a966 1
            #ifdef TIMINGS
d978 1
a978 1
            #endif
@


4.8
log
@Panel beat with hammer of sanity.
Deleted c.SpriteOp to untangle it from c.rojpeg to draw boundary around JPEG code.
Moved all the OS_SpriteOp code out of SprExtend into a new file SprOp, so the main file just contains the usual macros/includes/module heading.
Added new 'debugso' switch for debugging SpriteOps, was previously using 'debuggs' which is supposed to be for JPEG leading to reams of confusing debug.
TestForMaskAtDepth was rejecting 8bpp sprites with masks due to testing against log2bpp (4) instead of sprite type (5).
NSM_bpptable re-encoded in bytes rather than words, accesses ammended accordingly.
Took fresh copy of swiv2 from RISCOS_Lib revision 4.7.
SpriteV interception made a bit simpler (& faster).
Fixes to validate sprite (SpriteOp 17):
 Was looking at the wrong bits of the mode word to test for old mode words.
 Added new test for DPI values being non zero.
 Algorithm more closely follows PRM.

Version 1.27. Tagged as 'SprExtend-1_27'
@
text
@d23 1
d65 1
a65 1
  #define assert(x, y) do_assert(__LINE__, x, y, #x)
a81 1
/* #define assert(x) if (!(x)) exit(FILE_+__LINE__) */
d88 11
d388 1
a388 1
static int do_jpeg_scan_file(char *space, int space_size, char *file_image, int image_length)
d408 1
a408 1
static int do_jpeg_scan_file_16(char *space, int space_size, char *file_image, int image_length)
d418 1
a418 1
static int jpeg_scan_file(decompress_info_ptr cinfo, char *file_image, int image_length,
d695 1
a695 1
static int *jpeg_find_line(decompress_info_ptr cinfo, int ycoord, int *palette_data)
d1092 1
a1092 1
static int find_image_dims(char *jdata, int *image_width, int *image_height,
@


4.7
log
@Clean up pass.
Trim 200+ lines of changes dating back to 1987, combine with non duplicates in the 'BlackLog'.
Use 'offsetof' macro in genjhdr to avoid warnings about uninitialised variables, rename from makejhdr so all the utils are clearly demarked.
Add throwback to MkCFSI-j.
Replace reason codes passed to SWIs with textual equivalents from the respective header files.
Speed up SWI despatch a bit by making the first few debug instructions depend on 'debuggs'.
Qualify all of the debug switches with the global 'debug' one.
Eliminate single use of 'pullx' macro.
Make do_branch() take an unsigned opcode so 50% of the branches don't result in implied cast warnings.
Added an UNUSED() macro to reduce a few of the legitimate warnings (the remainder are either in the original JPEG code or ones that it is worth checking the logic of.
Unixify one last filename.

Version 1.24. Tagged as 'SprExtend-1_24'
@
text
@a1364 3

#include "SpriteOp.c"

@


4.6
log
@A few small fixes.
Sources/PutScaled:
 Sync comment with C code.
Sources/SprExtend:
 Debug switch 'debuggs' had been left on, which left in some unnecessary code, but turning it off pulled in code with a stack imbalance. Now off.
 Ensured a terminator at the end of the RMEnsure.
 Colour translation tables passed to SetPointerShape that were in top bit set addresses were being interpreted as though no tt was supplied. Now tested against zero to match docs.
Sources/SprTrans:
 Switches pre 0.60 collapsed.
Sources/diffuse:
 The C code was corrupting r12 workspace pointer so the check of the flag 'ctrans_recent' sometimes failed leading to a duff table lookup.
 Small optimisation to checking of guard word.
c/PutScaled:
 Change paths to be Unix friendly.
rojpeg:
 Put assembler_panic in the header file to shut the compiler up.
3x unused files deleted.

Version 1.23. Tagged as 'SprExtend-1_23'
@
text
@a25 3
/* For macros taking variable argument packs */
#define _ ,

d69 1
d82 1
d84 2
d87 1
d132 1
a132 1
  #ifdef DEBUG
d143 5
a147 1
  #endif
a987 8
#if 0
      /* Uni-directional dithering */
      for (i = 0; i < nlines_fetched; i++, line+=line_offset)
      {
        /* cinfo->xmin has been set to 0, so that dithering from the left all works OK */
        asm_diffuse_line_to_8bpp(line, linelen, (char*)line, cinfo->table32k);
      }
#endif
d1008 1
a1008 1
          tracef("calling diffuse to 8bpp code. pallete = %x\n" _ palette_data);
d1033 1
a1033 1
          tracef("calling diffuse to palette entires code. pallete = %x\n" _ palette_data);
d1285 2
d1366 1
a1366 1
#include "c.SpriteOp"
@


4.5
log
@Change to file vetting (only affects SpriteExtend module).
First pass check now only looks for a SOI tag,not bothering looking
for the "JFIF" text: this lets both JFIF and EXIF files through the
first gate.
Next,improvements to the find_image_dimensions routine to properly
look for tags rather than assuming tag APP0 is always at the start of
the file as it is in ".jpg" files.Again - EXIF files are now understood
as a side effect,plus a nice speed up for when skipping unknown tags.So
rather than loading lots of unused 1k blocks it just sets the file
pointer forwards to the required point.
Tested with a handful of specially contrived EXIF files plus some frommy
Panasonic camera,plus retested the JPEGs in the ChangeFSI test directory
to check that progressive JPEGs are still correctly faulted.
Yay - !Paint and !Draw can now load digital camera piccies!

Version 1.15. Tagged as 'SprExtend-1_15'
@
text
@d125 1
a125 1
extern void assembler_panic(decompress_info_ptr cinfo, int *regblock, int code)
@


4.4
log
@A couple of 32-bit fixes.
Used to interpret negative translation table pointers as "none"; now just 0
as per documentation.
Plotting 16bpp sprites into 32bpp modes now correctly sets the 3 least
significant bits of each channel - used to be set to 0 due to a typo.
Build option (currently set to on) to use SMULL instructions.

Version 1.11. Tagged as 'SprExtend-1_11'
@
text
@d1074 4
a1077 14
  if (  ((int*)jdata)[0] != 0xe0ffd8ff
     || jdata[6]  != 'J'
     || jdata[7]  != 'F'
     || jdata[8]  != 'I'
     || jdata[9]  != 'F'
     || jdata[10] != 0
     )
    return FALSE;
/*According to the JFIF 1.02 description from C-Cube, this test is safe.
However, we've found files which start with a comment field before this occurs.
What is more, the subsequent stuff is almost bound to be safe - so, OK to water
this test down? Here is the watered down one:
Decided to stick to official JFIF definition which gives us a guarantee of
finding Pixel densities (GPS)*/
d1079 1
a1079 1
/*  if (jdata[0] != 0xff | jdata[1] != 0xd8 | jdata[2] != 0xff) return FALSE;*/
d1097 1
d1102 1
a1102 5
#endif
  int             load_file = 0;
#ifndef CFSI
  int             pixel_density,
                  density_units;
d1108 6
d1149 2
a1150 1
      tracef("jdata = %x\n" _ jdata);
d1168 1
a1168 1
  tracef("jdata = %x\n" _ jdata);
d1170 51
a1220 34
  density_units = jdata[13]; /* from JFIF definition */
  tracef("pixel density units are  %d\n" _ density_units);
/*  pixel_density = ((int*)jdata)[14] + jdata[15] + jdata[16] + jdata[17]*/;
  /*Should make pixel_density = [XdenHigh XdenLow YdenHigh YdenLow] */
  if (density_units == 1)
  {
    tracef("1.jdata[14-17], %x %x %x %x\n" _ jdata[14] _ jdata[15] _ jdata[16] _ jdata[17]);
   /* tracef("1.(int)jdata[14], %x\n" _ ((int*)jdata)[14]);*/
    pixel_density = (jdata[14] << 24) + (jdata[15] << 16) + (jdata[16] << 8) + jdata[17];
    tracef("1.pixel density in %x\n" _ pixel_density);
  }  /*Should make pixel_density = [XdenHigh XdenLow YdenHigh YdenLow] */
  else if (density_units == 2)
  {
    pixel_density = (int)(jdata[14]*CMTOINCH/100) << 24 + (int)(jdata[15]*CMTOINCH/100) << 16
                     + (int)(jdata[16]*CMTOINCH/100) << 8 + (int)(jdata[17]*CMTOINCH/100);
    tracef("2.pixel density in %d\n" _ pixel_density);
  }
  else /* density_units == 0 */
  {
    int xdens, ydens;

    xdens = 90;
    ydens = (jdata[14] << 8) + jdata[15]; /* take into account the case where the scale may be 0:0, pah! */
    if (ydens == 0) ydens = 1;
    ydens = ((jdata[16] << 8) + jdata[17]) / ydens;
    if
      (ydens == 0) ydens = 90;
    else
      ydens *=90;
/*    ydens = 90*((jdata[16] << 8) + jdata[17])/((jdata[14] << 8) + jdata[15]);*/
    pixel_density = (xdens << 16) | ydens;
    itype |= 0x100;    /* set bit in type word to indicate density os only a ratio */
    tracef("3.pixel density in %x\n" _ pixel_density);
  }
a1224 8
    #if 0
    char *jdata_max = jdata + size; /* limit check in case of corrupted/truncated file */
    #endif

    #define M_SOI 0xd8
    #define M_SOF0 0xc0
    #define M_SOF1 0xc1
    #define M_SOF9 0xc9
d1226 1
a1226 1
      tracef("jdata = %x\n" _ jdata);
d1236 14
a1249 2
      if (load_file)
        if((int)jdata >= dataend)  /* load up more data */
d1251 3
a1253 28
          int   offset = (int)jdata - dataend;

          tracef("Loading another chunk. jdata = %x, data_end = %x\n" _ jdata _ dataend);
          jdata = buffer;
          tracef("jdata reset to %x\n" _ jdata);
          e = _swix(OS_GBPB, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _OUT(2),
                        4, file_handle, jdata, 1024, &dataend);
          if (e != 0)
          {
            _swix(OS_Find, _IN(0) | _IN(1), 0, file_handle);
            *err = (int)e;
            return((int)e);
          }
          while (offset > 1024)
          {
            tracef("Loading another chunk.\n");
            e = _swix(OS_GBPB, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _OUT(2),
                          4, file_handle, jdata, 1024, &dataend);
            if (e != 0)
            {
              _swix(OS_Find, _IN(0) | _IN(1), 0, file_handle);
              *err = (int)e;
              return((int)e);
            }
            offset-=1024;
          }
          jdata += offset;
          tracef("Loaded. jdata = %x, data_end = %x, offset = %x\n" _ jdata _ dataend _ offset);
d1255 1
d1314 1
a1314 1
/*      new_size += page_size; *//*lets be a bit conservative!!*/
d1329 2
a1330 2
/*        new_size += page_size;*/ /*lets be a bit conservative!!*/
/*	new_size--;
d1332 1
a1332 1
        new_size += page_size<<1;*/
@


4.3
log
@  Now uses objasm throughout instead of aasm.
Detail:
  The build structure for this module is not nice - I've sanitised it a
    bit, but it's still not nice.
Admin:
   Built and tested with the test program briefly - the test sprite seems
     to scale and rotate properly.  ChangeFSI not tested.


Version 1.08. Tagged as 'SprExtend-1_08'
@
text
@d76 4
d85 1
d1123 1
a1123 1
  if (((int)ws_size & 3) == 1)
d1208 1
a1208 1
    tracef("3.pixel density in %d\n" _ pixel_density);
d1284 1
a1284 1
  if ((int)ws_size > 1)
d1298 1
a1298 1
  if ((int)ws_size > 3)
d1305 1
a1305 1
    ws_size = (int *)((int)ws_size & ~3);
@


4.2
log
@Version RO_3_70 taken
@
text
@d19 4
@


4.1
log
@Initial revision
@
text
@d646 1
d649 12
d724 2
a725 1
        outptr += 8*count;
d770 4
a773 1
              asm_mono_convert_block(cinfo->jblocks[0], outptr, line_offset);
d776 4
a779 1
          outptr += 8;
d800 1
d810 2
a811 1
         else if (cinfo->options & jopt_OUTBPP_8YUV) outptr += 2*hsamp;
d870 14
a883 9
                #ifdef STATS
                  if (stats)
                    j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
                  else
                #endif
                    asm_j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
                asm_mono_convert_block(cinfo->jblocks[0], outptr, line_offset);
                if (hsamp == 2) asm_mono_convert_block(cinfo->jblocks[1], outptr + 8, line_offset);
                if (vsamp == 2)
d885 13
a897 2
                  asm_mono_convert_block(cinfo->jblocks[hsamp == 1 ? 1 : 2], outptr + 8*line_offset, line_offset);
                  if (hsamp == 2) asm_mono_convert_block(cinfo->jblocks[3], outptr + 8*line_offset + 8, line_offset);
d902 2
d953 2
a954 1
           else if (cinfo->options & jopt_OUTBPP_8YUV) outptr += 2*hsamp;
d961 2
a962 1
    if (cinfo->options & jopt_OUTBPP_8) /* convert to 8bpp output, for instance by dithering */
d964 1
a964 1
      if (cinfo->table32k == 0 && !cinfo->table32k_unavailable)
d968 1
a968 1
        cinfo->table32k = asm_get_table32k();
d970 1
a970 1
        /*tracef("Fetched 32k lookup table, at 0x%x\n" _ (int) cinfo->table32k);*/
d983 1
d996 1
a996 1
        if (cinfo->options & jopt_INTERP_X) {line += cinfo->xmin; linelen += linelen;} /* double if you have interpolated */
d1001 1
a1001 1
          tracef("calling diffuse code. pallete = %x\n" _ palette_data);
d1003 1
d1005 23
d1029 1
d1031 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a645 1
  if (options & jopt_OUTBPP_8GREY) cinfo->error_argument1 |= jopt_OUTBPP_8GREY;
a647 12
#ifdef DEBUG
  tracef("After scan file, options are:\n");
  if (options & jopt_GREY) tracef("  jopt_GREY\n");
  if (options & jopt_DC_ONLY) tracef("  jopt_DC_ONLY\n");
  if (options & jopt_INTERP_X) tracef("  jopt_INTERP_X\n");
  if (options & jopt_OUTBPP_8) tracef("  jopt_OUTBPP_8\n");
  if (options & jopt_OUTBPP_16) tracef("  jopt_OUTBPP_16\n");
  if (options & jopt_OUTBPP_8YUV) tracef("  jopt_OUTBPP_8YUV\n");
  if (options & jopt_DIFFUSE) tracef("  jopt_DIFFUSE\n");
  if (options & jopt_OUTBPP_8GREY) tracef("  jopt_OUTBPP_8GREY\n");
#endif

d711 1
a711 2
        if (cinfo->options & jopt_OUTBPP_8GREY) outptr += 2*count;
          else outptr += 8*count;
d756 1
a756 4
              if (cinfo->options & jopt_OUTBPP_8GREY)
                asm_mono_convert_block_8(cinfo->jblocks[0], outptr, line_offset);
              else
                asm_mono_convert_block(cinfo->jblocks[0], outptr, line_offset);
d759 1
a759 4
          if (cinfo->options & jopt_OUTBPP_8GREY)
            outptr += 2;
          else
            outptr += 8;
a779 1
      tracef("in colour half of jpeg_find_line\n");
d789 1
a789 2
        else if (cinfo->options & jopt_OUTBPP_8YUV) outptr += 2*hsamp;
        else if (cinfo->options & jopt_OUTBPP_8GREY) outptr += 2*hsamp;
d848 9
a856 14
                tracef("about to do some grey conversion\n");
                if (cinfo->options & jopt_OUTBPP_8GREY)
                {
                  asm_j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
                  asm_mono_convert_block_8(cinfo->jblocks[0], outptr, line_offset);
                  if (hsamp == 2) asm_mono_convert_block_8(cinfo->jblocks[1], outptr + 2, line_offset);
                  if (vsamp == 2)
                  {
                    asm_mono_convert_block_8(cinfo->jblocks[hsamp == 1 ? 1 : 2], outptr + 8*line_offset, line_offset);
                    if (hsamp == 2) asm_mono_convert_block_8(cinfo->jblocks[3], outptr + 8*line_offset + 2, line_offset);
                  }

                }
                else
d858 2
a859 13
                  #ifdef STATS
                    if (stats)
                      j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
                    else
                  #endif
                      asm_j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
                  asm_mono_convert_block(cinfo->jblocks[0], outptr, line_offset);
                  if (hsamp == 2) asm_mono_convert_block(cinfo->jblocks[1], outptr + 8, line_offset);
                  if (vsamp == 2)
                  {
                    asm_mono_convert_block(cinfo->jblocks[hsamp == 1 ? 1 : 2], outptr + 8*line_offset, line_offset);
                    if (hsamp == 2) asm_mono_convert_block(cinfo->jblocks[3], outptr + 8*line_offset + 8, line_offset);
                  }
a863 2
                tracef("about to do some colour conversion\n");

d913 1
a913 2
          else if (cinfo->options & jopt_OUTBPP_8YUV) outptr += 2*hsamp;
          else if (cinfo->options & jopt_OUTBPP_8GREY) outptr += 2*hsamp;
d920 1
a920 2
    if (cinfo->options & jopt_DIFFUSE)
    /*cinfo->options & jopt_OUTBPP_8*/ /* convert to 8bpp output, for instance by dithering */
d922 1
a922 1
      if (/*cinfo->table32k == 0 && */!cinfo->table32k_unavailable)
d926 1
a926 1
        cinfo->table32k = asm_get_table32k(palette_data);
d928 1
a928 1
        tracef("Fetched 32k lookup table, at 0x%x\n" _ (int) cinfo->table32k);
a940 1
      if (cinfo->options & jopt_OUTBPP_8)
d953 1
a953 1
//        if (cinfo->options & jopt_INTERP_X) {line += cinfo->xmin; linelen += linelen;} /* double if you have interpolated */
d958 1
a958 1
          tracef("calling diffuse to 8bpp code. pallete = %x\n" _ palette_data);
a959 1
          outptr = outptr + blockwidth;
a960 23
          linelen -= blockwidth;
        }
      }
      else
      {
        int *line = cinfo->band_buffer + cinfo->xmin;
        int linelen = cinfo->xmax - cinfo->xmin;
        int *outptr = cinfo->band_buffer + cinfo->xmin;

        /* The error diffusion cannot handle a very thin strip at the right, eg one pixel wide. So the last
        unit of diffusion may be up to 31 pixels. However, the units of diffusion until then must
        be unaffected by exactly what xmin/xmax are, or we will get minor pixel variation depending
        on the clipping. xmin is already a multiple of 16. */
        linelen = (linelen + 15) & ~15; /* round up to a multiple of 16 */
        if (linelen > cinfo->image_width - cinfo->xmin) linelen = cinfo->image_width - cinfo->xmin;

//        if (cinfo->options & jopt_INTERP_X) {line += cinfo->xmin; linelen += linelen;} /* double if you have interpolated */
        while (linelen > 0)
        {
          int blockwidth = linelen >= 32 ? 16 : linelen; /* avoid having very narrow blocks at r hand edge. */

          tracef("calling diffuse to palette entires code. pallete = %x\n" _ palette_data);
          asm_diffuse_to_24bpp(line, blockwidth, (int *)outptr, cinfo->table32k, nlines_fetched, line_offset, palette_data);
a961 1
          line += blockwidth;
a962 1
          tracef("done diffusion, outptr = &%x, blockwidth = &%xlinelen = &%x\n" _ outptr _ blockwidth _ linelen);
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

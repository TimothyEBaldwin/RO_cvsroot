head	4.5;
access;
symbols
	SprExtend-1_70-tracef:4.4
	SprExtend-1_70-headers:4.4
	SprExtend-1_70:4.3
	SprExtend-1_69:4.2
	SprExtend-1_68:4.2
	SprExtend-1_67:4.2
	SprExtend-1_66:4.2
	SprExtend-1_65:4.2
	SprExtend-1_64:4.2
	SprExtend-1_63:4.2
	SprExtend-1_62:4.2
	SprExtend-1_61:4.2
	SprExtend-1_60:4.2
	SprExtend-1_59:4.2
	SprExtend-1_58:4.2
	SprExtend-1_57:4.2
	SprExtend-1_56:4.2
	SprExtend-1_55:4.2
	SprExtend-1_54:4.2
	SprExtend-1_53:4.2
	SprExtend-1_52:4.2
	SprExtend-1_51:4.2
	SprExtend-1_50:4.2
	SprExtend-1_49:4.2
	SprExtend-1_48:4.2
	SprExtend-1_47:4.2
	SprExtend-1_46:4.2
	SprExtend-1_45:4.2
	SprExtend-1_44:4.2
	SprExtend-1_43:4.2
	SprExtend-1_42:4.2
	SprExtend-1_41:4.2
	SprExtend-1_40:4.2
	SprExtend-1_39:4.2
	SprExtend-1_38-1_35_2_4:4.2.2.1
	SprExtend-1_38-1_35_2_3:4.2.2.1
	SprExtend-1_38-1_35_2_2:4.2.2.1
	SprExtend-1_38-1_35_2_1:4.2.2.1
	MigrateIJG8b:4.2.0.2
	SprExtend-1_38:4.2
	SprExtend-1_37:4.2
	SprExtend-1_36:4.2
	SprExtend-1_35:4.2
	SprExtend-1_34:4.2
	SprExtend-1_33:4.2
	SprExtend-1_32:4.2
	SprExtend-1_31:4.2
	SprExtend-1_30:4.2
	SprExtend-1_29:4.2
	SprExtend-1_28:4.2
	SprExtend-1_27:4.2
	SprExtend-1_26:4.2
	SprExtend-1_25:4.2
	SprExtend-1_24:4.2
	SprExtend-1_23:4.2
	SprExtend-1_22:4.2
	SprExtend-1_21:4.2
	SprExtend-1_20:4.2
	SprExtend-1_19:4.2
	SprExtend-1_18:4.2
	SprExtend-1_17:4.2
	RO_5_07:4.2
	SprExtend-1_16:4.2
	SprExtend-1_15:4.2
	SprExtend-1_14:4.2
	SprExtend-1_13:4.2
	SprExtend-1_12:4.2
	SprExtend-1_11:4.2
	SprExtend-1_10:4.2
	SprExtend-1_09:4.2
	SprExtend-1_08:4.2
	dellis_autobuild_BaseSW:4.2
	SprExtend-1_07:4.2
	SprExtend-1_06:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.2
	SprExtend-1_05:4.1
	Ursula_merge:4.1
	nturton_SprExtend-1_04:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2016.05.21.13.44.39;	author rool;	state dead;
branches;
next	4.4;
commitid	ZDqmsyNiMhv6Zl7z;

4.4
date	2016.05.21.13.32.20;	author rool;	state Exp;
branches;
next	4.3;
commitid	yTqS85yKh7k8Ul7z;

4.3
date	2016.03.12.10.25.10;	author rool;	state Exp;
branches;
next	4.2;
commitid	cdOKhcORM5Eb8lYy;

4.2
date	2000.06.27.13.58.02;	author jfletche;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.45.03;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	2011.01.04.21.18.07;	author rsprowson;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	2011.01.04.22.13.09;	author rsprowson;	state dead;
branches;
next	;

4.1.1.1
date	96.11.05.09.45.03;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.40.55;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.57.32;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.20.10;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Import of IJG8d library sources
Detail:
  Using the decoder in "example.c" as a starting point, we try to follow that sequence more closely even if in our embedded implementation some of the functions don't do much.
  Uses the default colour backend for 32bpp BGR output for most of the unusual cases.
  The most common 2x2 subsampling case uses a custom merged upsampler and colour converter, with colour output directly in RISC OS format for the respective screen mode.
Admin:
  Submission for the JPEG bounty.

Version 1.71. Tagged as 'SprExtend-1_71'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * jrdjfif.c
 *
 * Copyright (C) 1991, 1992, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains routines to decode standard JPEG file headers/markers.
 * This code will handle "raw JPEG" and JFIF-convention JPEG files.
 *
 * You can also use this module to decode a raw-JPEG or JFIF-standard data
 * stream that is embedded within a larger file.  To do that, you must
 * position the file to the JPEG SOI marker (0xFF/0xD8) that begins the
 * data sequence to be decoded.  If nothing better is possible, you can scan
 * the file until you see the SOI marker, then use JUNGETC to push it back.
 *
 * This module relies on the JGETC macro and the read_jpeg_data method (which
 * is provided by the user interface) to read from the JPEG data stream.
 * Therefore, this module is not dependent on any particular assumption about
 * the data source; it need not be a stdio stream at all.  (This fact does
 * NOT carry over to more complex JPEG file formats such as JPEG-in-TIFF;
 * those format control modules may well need to assume stdio input.)
 *
 * These routines are invoked via the methods read_file_header,
 * read_scan_header, read_jpeg_data, read_scan_trailer, and read_file_trailer.
 */
#undef FILE_
#define FILE_ (20000)

#ifndef RISCOS
#include "jinclude.h"
#endif

typedef enum {			/* JPEG marker codes */
  M_SOF0  = 0xc0,
  M_SOF1  = 0xc1,
  M_SOF2  = 0xc2,
  M_SOF3  = 0xc3,
  
  M_SOF5  = 0xc5,
  M_SOF6  = 0xc6,
  M_SOF7  = 0xc7,
  
  M_JPG   = 0xc8,
  M_SOF9  = 0xc9,
  M_SOF10 = 0xca,
  M_SOF11 = 0xcb,
  
  M_SOF13 = 0xcd,
  M_SOF14 = 0xce,
  M_SOF15 = 0xcf,
  
  M_DHT   = 0xc4,
  
  M_DAC   = 0xcc,
  
  M_RST0  = 0xd0,
  M_RST1  = 0xd1,
  M_RST2  = 0xd2,
  M_RST3  = 0xd3,
  M_RST4  = 0xd4,
  M_RST5  = 0xd5,
  M_RST6  = 0xd6,
  M_RST7  = 0xd7,
  
  M_SOI   = 0xd8,
  M_EOI   = 0xd9,
  M_SOS   = 0xda,
  M_DQT   = 0xdb,
  M_DNL   = 0xdc,
  M_DRI   = 0xdd,
  M_DHP   = 0xde,
  M_EXP   = 0xdf,
  
  M_APP0  = 0xe0,
  M_APP1  = 0xe1,
  M_APP2  = 0xe2,
  M_APP3  = 0xe3,
  M_APP4  = 0xe4,
  M_APP5  = 0xe5,
  M_APP6  = 0xe6,
  M_APP7  = 0xe7,
  M_APP8  = 0xe8,
  M_APP9  = 0xe9,
  M_APP10 = 0xea,
  M_APP11 = 0xeb,
  M_APP12 = 0xec,
  M_APP13 = 0xed,
  M_APP14 = 0xee,
  M_APP15 = 0xef,
  
  M_JPG0  = 0xf0,
  M_JPG13 = 0xfd,
  M_COM   = 0xfe,
  
  M_TEM   = 0x01,
  
  M_ERROR = 0x100
} JPEG_MARKER;


/*
 * Routines to parse JPEG markers & save away the useful info.
 */


LOCAL(INT32)
get_2bytes (j_decompress_ptr cinfo)
/* Get a 2-byte unsigned integer (e.g., a marker parameter length field) */
{
  INT32 a;
  
  a = JGETC(cinfo);
  return (a << 8) + JGETC(cinfo);
}


LOCAL(void)
skip_variable (j_decompress_ptr cinfo, int code)
/* Skip over an unknown or uninteresting variable-length marker */
{
  INT32 length;
  
  length = get_2bytes(cinfo);
  
  TRACEMS2(cinfo->emethods, 1,
           "Skipping marker 0x%02x, length %u", code, (int) length);
  
  for (length -= 2; length > 0; length--)
    (void) JGETC(cinfo);
}


LOCAL(void)
get_dht (j_decompress_ptr cinfo)
/* Process a DHT marker */
{
  INT32 length;
  UINT8 bits[17];
  UINT8 huffval[256];
  int i, index, count;
  JHUFF_TBL **htblptr;
  
  length = get_2bytes(cinfo)-2;
  
  while (length > 0) {
    index = JGETC(cinfo);

    TRACEMS1(cinfo->emethods, 1, "Define Huffman Table 0x%02x", index);
      
    bits[0] = 0;
    count = 0;
    for (i = 1; i <= 16; i++) {
      bits[i] = (UINT8) JGETC(cinfo);
      count += bits[i];
    }

    TRACEMS8(cinfo->emethods, 2, "        %3d %3d %3d %3d %3d %3d %3d %3d",
             bits[1], bits[2], bits[3], bits[4],
             bits[5], bits[6], bits[7], bits[8]);
    TRACEMS8(cinfo->emethods, 2, "        %3d %3d %3d %3d %3d %3d %3d %3d",
             bits[9], bits[10], bits[11], bits[12],
             bits[13], bits[14], bits[15], bits[16]);

    if (count > 256)
      ERREXIT(cinfo->emethods, "Bogus DHT counts");

    for (i = 0; i < count; i++)
      huffval[i] = (UINT8) JGETC(cinfo);

    length -= 1 + 16 + count;

    if (index & 0x10) {         /* AC table definition */
      index -= 0x10;
      htblptr = &cinfo->ac_huff_tbl_ptrs[index];
    } else {                    /* DC table definition */
      htblptr = &cinfo->dc_huff_tbl_ptrs[index];
    }

    if (index < 0 || index >= NUM_HUFF_TBLS)
      ERREXIT1(cinfo->emethods, "Bogus DHT index %d", index);

#if 0
    if (*htblptr == NULL)
      *htblptr = (JHUFF_TBL *) malloc (SIZEOF(JHUFF_TBL));
#endif
  
    memcpy((void *) (*htblptr)->bits, (void *) bits,
           SIZEOF((*htblptr)->bits));
    memcpy((void *) (*htblptr)->huffval, (void *) huffval,
           SIZEOF((*htblptr)->huffval));
    }
}


LOCAL(void)
get_dac (j_decompress_ptr cinfo)
/* Process a DAC marker */
{
  INT32 length;
  int index, val;

  length = get_2bytes(cinfo)-2;
  
  while (length > 0) {
    index = JGETC(cinfo);
    val = JGETC(cinfo);

    TRACEMS2(cinfo->emethods, 1,
             "Define Arithmetic Table 0x%02x: 0x%02x", index, val);

    if (index < 0 || index >= (2*NUM_ARITH_TBLS))
      ERREXIT1(cinfo->emethods, "Bogus DAC index %d", index);

    if (index >= NUM_ARITH_TBLS) { /* define AC table */
      cinfo->arith_ac_K[index-NUM_ARITH_TBLS] = (UINT8) val;
    } else {                    /* define DC table */
      cinfo->arith_dc_L[index] = (UINT8) (val & 0x0F);
      cinfo->arith_dc_U[index] = (UINT8) (val >> 4);
      if (cinfo->arith_dc_L[index] > cinfo->arith_dc_U[index])
        ERREXIT1(cinfo->emethods, "Bogus DAC value 0x%x", val);
    }

    length -= 2;
  }
}


LOCAL(void)
get_dqt (j_decompress_ptr cinfo)
/* Process a DQT marker */
{
  INT32 length;
  int n, i, prec;
  UINT16 tmp;
  JQUANT_TBL * quant_ptr;
  
  length = get_2bytes(cinfo) - 2;
  
  while (length > 0) {
    n = JGETC(cinfo);
    prec = n >> 4;
    n &= 0x0F;

    TRACEMS2(cinfo->emethods, 1,
             "Define Quantization Table %d  precision %d", n, prec);

    if (n >= NUM_QUANT_TBLS)
      ERREXIT1(cinfo->emethods, "Bogus table number %d", n);
      
#if 0
    if (cinfo->quant_tbl_ptrs[n] == NULL)
      cinfo->quant_tbl_ptrs[n] = (JHUFF_TBL *)
        malloc (SIZEOF(JQUANT_TBL));
#endif
    quant_ptr = cinfo->quant_tbl_ptrs[n];

    for (i = 0; i < DCTSIZE2; i++) {
      tmp = JGETC(cinfo);
      if (prec)
        tmp = (tmp<<8) + JGETC(cinfo);
      quant_ptr->quantval[i] = tmp;
    }

#ifdef DEBUG
    for (i = 0; i < DCTSIZE2; i += 8) {
      TRACEMS8(cinfo->emethods, 2, "        %4d %4d %4d %4d %4d %4d %4d %4d",
               quant_ptr[i  ], quant_ptr[i+1], quant_ptr[i+2], quant_ptr[i+3],
               quant_ptr[i+4], quant_ptr[i+5], quant_ptr[i+6], quant_ptr[i+7]);
    }
#endif

    length -= DCTSIZE2+1;
    if (prec) length -= DCTSIZE2;
  }
}


LOCAL(void)
get_dri (j_decompress_ptr cinfo)
/* Process a DRI marker */
{
  if (get_2bytes(cinfo) != 4)
    ERREXIT(cinfo->emethods, "Bogus length in DRI");

  cinfo->restart_interval = (UINT16) get_2bytes(cinfo);

  TRACEMS1(cinfo->emethods, 1,
           "Define Restart Interval %d", cinfo->restart_interval);
}


LOCAL(void)
get_app0 (j_decompress_ptr cinfo)
/* Process an APP0 marker */
{
#define JFIF_LEN 14
  INT32 length;
  UINT8 b[JFIF_LEN];
  int buffp;

  length = get_2bytes(cinfo) - 2;

  /* See if a JFIF APP0 marker is present */

  if (length >= JFIF_LEN) {
    for (buffp = 0; buffp < JFIF_LEN; buffp++)
      b[buffp] = (UINT8) JGETC(cinfo);
    length -= JFIF_LEN;

    if (b[0]=='J' && b[1]=='F' && b[2]=='I' && b[3]=='F' && b[4]==0) {
      /* Found JFIF APP0 marker: check version */
      /* Major version must be 1 */
      if (b[5] != 1)
        ERREXIT2(cinfo->emethods, "Unsupported JFIF revision number %d.%02d",
                 b[5], b[6]);
      /* Minor version should be 0 or 1, but try to process anyway if newer */
      if (b[6] != 0 && b[6] != 1)
        TRACEMS2(cinfo->emethods, 0, "Warning: unknown JFIF revision number %d.%02d",
                 b[5], b[6]);
      /* Save info */
      cinfo->density_unit = b[7];
      cinfo->X_density = (b[8] << 8) + b[9];
      cinfo->Y_density = (b[10] << 8) + b[11];
      /* Assume colorspace is YCbCr, unless UI has overridden me */
      if (cinfo->jpeg_color_space == JCS_UNKNOWN)
        cinfo->jpeg_color_space = JCS_YCbCr;
      TRACEMS3(cinfo->emethods, 1, "JFIF APP0 marker, density %dx%d  %d",
               cinfo->X_density, cinfo->Y_density, cinfo->density_unit);
    } else {
      TRACEMS(cinfo->emethods, 1, "Unknown APP0 marker (not JFIF)");
    }
  } else {
    TRACEMS1(cinfo->emethods, 1,
             "Short APP0 marker, length %d", (int) length);
  }

  while (length-- > 0)          /* skip any remaining data */
    (void) JGETC(cinfo);
}


LOCAL(void)
get_sof (j_decompress_ptr cinfo, int code)
/* Process a SOFn marker */
{
  INT32 length;
  short ci;
  int c;
  jpeg_component_info * compptr;
  
  length = get_2bytes(cinfo);
  
  cinfo->data_precision = JGETC(cinfo);
  cinfo->image_height   = (JDIMENSION)get_2bytes(cinfo);
  cinfo->image_width    = (JDIMENSION)get_2bytes(cinfo);
  cinfo->num_components = JGETC(cinfo);

  TRACEMS4(cinfo->emethods, 1,
           "Start Of Frame 0x%02x: width=%u, height=%u, components=%d",
           code, (int) cinfo->image_width, (int) cinfo->image_height,
           cinfo->num_components);

  /* We don't support files in which the image height is initially specified */
  /* as 0 and is later redefined by DNL.  As long as we have to check that,  */
  /* might as well have a general sanity check. */
  if (cinfo->image_height <= 0 || cinfo->image_width <= 0
      || cinfo->num_components <= 0)
    ERREXIT(cinfo->emethods, "Empty JPEG image (DNL not supported)");

#ifdef EIGHT_BIT_SAMPLES
  if (cinfo->data_precision != 8)
    ERREXIT(cinfo->emethods, "Unsupported JPEG data precision");
#endif
#ifdef TWELVE_BIT_SAMPLES
  if (cinfo->data_precision != 12) /* this needs more thought?? */
    ERREXIT(cinfo->emethods, "Unsupported JPEG data precision");
#endif
#ifdef SIXTEEN_BIT_SAMPLES
  if (cinfo->data_precision != 16) /* this needs more thought?? */
    ERREXIT(cinfo->emethods, "Unsupported JPEG data precision");
#endif

  if (length != (cinfo->num_components * 3 + 8))
    ERREXIT(cinfo->emethods, "Bogus SOF length");

#if RISCOS
  if (cinfo->num_components > 3)
    ERREXIT(cinfo->emethods, "Too many colour components");
  /* cinfo->comp_info set up already */
#else
  cinfo->comp_info = (jpeg_component_info *) malloc
                        (cinfo->num_components * SIZEOF(jpeg_component_info));
#endif
  
  for (ci = 0; ci < cinfo->num_components; ci++) {
    compptr = &cinfo->comp_info[ci];
    compptr->component_index = ci;
    compptr->component_id = JGETC(cinfo);
    c = JGETC(cinfo);
    compptr->h_samp_factor = (c >> 4) & 15;
    compptr->v_samp_factor = (c     ) & 15;
    compptr->quant_tbl_no  = JGETC(cinfo);
      
    TRACEMS4(cinfo->emethods, 1, "    Component %d: %dhx%dv q=%d",
             compptr->component_id, compptr->h_samp_factor,
             compptr->v_samp_factor, compptr->quant_tbl_no);
  }
}


LOCAL(void)
get_sos (j_decompress_ptr cinfo)
/* Process a SOS marker */
{
  INT32 length;
  int i, ci, n, c, cc;
  jpeg_component_info * compptr;
  
  length = get_2bytes(cinfo);
  
  n = JGETC(cinfo);  /* Number of components */
  cinfo->comps_in_scan = n;
  length -= 3;
  
  if (length != (n * 2 + 3) || n < 1 || n > MAX_COMPS_IN_SCAN)
    ERREXIT(cinfo->emethods, "Bogus SOS length");

  TRACEMS1(cinfo->emethods, 1, "Start Of Scan: %d components", n);
  
  for (i = 0; i < n; i++) {
    cc = JGETC(cinfo);
    c = JGETC(cinfo);
    length -= 2;
    
    for (ci = 0; ci < cinfo->num_components; ci++)
      if (cc == cinfo->comp_info[ci].component_id)
        break;
    
    if (ci >= cinfo->num_components)
      ERREXIT(cinfo->emethods, "Invalid component number in SOS");
    
    compptr = &cinfo->comp_info[ci];
    cinfo->cur_comp_info[i] = compptr;
    compptr->dc_tbl_no = (c >> 4) & 15;
    compptr->ac_tbl_no = (c     ) & 15;
    
    TRACEMS3(cinfo->emethods, 1, "    c%d: [dc=%d ac=%d]", cc,
             compptr->dc_tbl_no, compptr->ac_tbl_no);
  }
  
  while (length > 0) {
    (void) JGETC(cinfo);
    length--;
  }
}


LOCAL(void)
get_soi (j_decompress_ptr cinfo)
/* Process an SOI marker */
{
  int i;
  
  TRACEMS(cinfo->emethods, 1, "Start of Image");

  /* Reset all parameters that are defined to be reset by SOI */

  for (i = 0; i < NUM_ARITH_TBLS; i++) {
    cinfo->arith_dc_L[i] = 0;
    cinfo->arith_dc_U[i] = 1;
    cinfo->arith_ac_K[i] = 5;
  }
  cinfo->restart_interval = 0;

  cinfo->density_unit = 0;      /* set default JFIF APP0 values */
  cinfo->X_density = 1;
  cinfo->Y_density = 1;

  cinfo->CCIR601_sampling = FALSE; /* Assume non-CCIR sampling */
}


LOCAL(int)
next_marker (j_decompress_ptr cinfo)
/* Find the next JPEG marker */
/* Note that the output might not be a valid marker code, */
/* but it will never be 0 or FF */
{
  int c, nbytes;

  nbytes = 0;
  do {
    do {                        /* skip any non-FF bytes */
      nbytes++;
      c = JGETC(cinfo);
    } while (c != 0xFF);
    do {                        /* skip any duplicate FFs */
      nbytes++;
      c = JGETC(cinfo);
    } while (c == 0xFF);
  } while (c == 0);             /* repeat if it was a stuffed FF/00 */

  if (nbytes != 2)
    TRACEMS2(cinfo->emethods, 1, "Skipped %d bytes before marker 0x%02x",
             nbytes-2, c);

  return c;
}


LOCAL(JPEG_MARKER)
process_tables (j_decompress_ptr cinfo)
/* Scan and process JPEG markers that can appear in any order */
/* Return when an SOI, EOI, SOFn, or SOS is found */
{
  int c;

  while (TRUE) {
    c = next_marker(cinfo);
      
    switch (c) {
    case M_SOF0:
    case M_SOF1:
    case M_SOF2:
    case M_SOF3:
    case M_SOF5:
    case M_SOF6:
    case M_SOF7:
    case M_JPG:
    case M_SOF9:
    case M_SOF10:
    case M_SOF11:
    case M_SOF13:
    case M_SOF14:
    case M_SOF15:
    case M_SOI:
    case M_EOI:
    case M_SOS:
      return ((JPEG_MARKER) c);
      
    case M_DHT:
      get_dht(cinfo);
      break;
      
    case M_DAC:
      get_dac(cinfo);
      break;
      
    case M_DQT:
      get_dqt(cinfo);
      break;
      
    case M_DRI:
      get_dri(cinfo);
      break;
      
    case M_APP0:
      get_app0(cinfo);
      break;

    case M_RST0:                /* these are all parameterless */
    case M_RST1:
    case M_RST2:
    case M_RST3:
    case M_RST4:
    case M_RST5:
    case M_RST6:
    case M_RST7:
    case M_TEM:
      TRACEMS1(cinfo->emethods, 1, "Unexpected marker 0x%02x", c);
      break;

    default:    /* must be DNL, DHP, EXP, APPn, JPGn, COM, or RESn */
      skip_variable(cinfo, c);
      break;
    }
  }
}



/*
 * Initialize and read the file header (everything through the SOF marker).
 */

METHODDEF(void)
read_file_header (j_decompress_ptr cinfo)
{
  int c;

  /* Demand an SOI marker at the start of the file --- otherwise it's
   * probably not a JPEG file at all.  If the user interface wants to support
   * nonstandard headers in front of the SOI, it must skip over them itself
   * before calling jpeg_decompress().
   */
  if (JGETC(cinfo) != 0xFF  ||  JGETC(cinfo) != M_SOI)
    ERREXIT(cinfo->emethods, "Not a JPEG file");

  get_soi(cinfo);               /* OK, process SOI */

  /* Process markers until SOF */
  c = process_tables(cinfo);

  switch (c) {
  case M_SOF0:
  case M_SOF1:
    get_sof(cinfo, c);
    cinfo->arith_code = FALSE;
    break;
      
  case M_SOF9:
    get_sof(cinfo, c);
    cinfo->arith_code = TRUE;
    break;

  default:
    ERREXIT1(cinfo->emethods, "Unsupported SOF marker type 0x%02x", c);
    break;
  }

  /* Figure out what colorspace we have */
  /* (too bad the JPEG committee didn't provide a real way to specify this) */

  switch (cinfo->num_components) {
  case 1:
    cinfo->jpeg_color_space = JCS_GRAYSCALE;
    break;

  case 3:
    /* if we saw a JFIF marker, leave it set to YCbCr; */
    /* also leave it alone if UI has provided a value */
    if (cinfo->jpeg_color_space == JCS_UNKNOWN) {
      short cid0 = cinfo->comp_info[0].component_id;
      short cid1 = cinfo->comp_info[1].component_id;
      short cid2 = cinfo->comp_info[2].component_id;

      if (cid0 == 1 && cid1 == 2 && cid2 == 3)
        cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's JFIF w/out marker */
      else if (cid0 == 82 && cid1 == 71 && cid2 == 66)
        cinfo->jpeg_color_space = JCS_RGB; /* ASCII 'R', 'G', 'B' */
      else {
        TRACEMS3(cinfo->emethods, 0,
                 "Unrecognized component IDs %d %d %d, assuming YCbCr",
                 cid0, cid1, cid2);
        cinfo->jpeg_color_space = JCS_YCbCr;
      }
    }
    break;

  case 4:
    cinfo->jpeg_color_space = JCS_CMYK;
    break;

  default:
    cinfo->jpeg_color_space = JCS_UNKNOWN;
    break;
  }
}


/*
 * Read the start of a scan (everything through the SOS marker).
 * Return TRUE if find SOS, FALSE if find EOI.
 */

METHODDEF(boolean)
read_scan_header (j_decompress_ptr cinfo)
{
  int c;
  
  /* Process markers until SOS or EOI */
  c = process_tables(cinfo);
  
  switch (c) {
  case M_SOS:
    get_sos(cinfo);
    return TRUE;
    
  case M_EOI:
    TRACEMS(cinfo->emethods, 1, "End Of Image");
    return FALSE;

  default:
    ERREXIT1(cinfo->emethods, "Unexpected marker 0x%02x", c);
    break;
  }
  return FALSE;                 /* keeps lint happy */
}


#if 0
/*
 * Finish up after a compressed scan (series of read_jpeg_data calls);
 * prepare for another read_scan_header call.
 */

METHODDEF void
read_scan_trailer (j_decompress_ptr cinfo)
{
  /* no work needed */
}
#endif

#if 0
/*
 * Finish up at the end of the file.
 */

METHODDEF void
read_file_trailer (j_decompress_ptr cinfo)
{
  /* no work needed */
}
#endif


#ifndef RISCOS
/*
 * The method selection routine for standard JPEG header reading.
 * Note that this must be called by the user interface before calling
 * jpeg_decompress.  When a non-JFIF file is to be decompressed (TIFF,
 * perhaps), the user interface must discover the file type and call
 * the appropriate method selection routine.
 */

GLOBAL void
jselrjfif (j_decompress_ptr cinfo)
{
  cinfo->methods->read_file_header = read_file_header;
  cinfo->methods->read_scan_header = read_scan_header;
  /* For JFIF/raw-JPEG format, the user interface supplies read_jpeg_data. */
#if 0
  cinfo->methods->read_jpeg_data = read_jpeg_data;
#endif
  cinfo->methods->read_scan_trailer = read_scan_trailer;
  cinfo->methods->read_file_trailer = read_file_trailer;
}

#endif
@


4.4
log
@Update headers to stock copy
Detail:
  Added headers jerror, jmorecfg, jpegint from IJG8d. Removed jpegdata header.
  Bulk rename of structure members to match newer headers, some RISCOS-isms wrapped in #ifdef RISCOS, retained for the time being.
  Assembler code now gets cinfo member offsets from jhdr.s derived from the C header rather than keeping its own dangerous copy of the offsets.
Admin
  Note: this has broken CFSI-jpeg as it expects the error values to be at the top of cinfo.
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_70-headers.
@
text
@@


4.3
log
@Rewrite of find_image_dims
Detail:
  Now handles 0xFF padding, previously acceptable encoded images including padding were incorrectly rejected.
  Calculate the workspace for greyscale images correctly, the itype flags included the density (and latterly the SOF) flags, but the workspace calculation assumed it only contained 1 or 3 (for colour components).
  Exit cases now made common and propagate file errors correctly.
  Minor changes to the assembler that uses find_image_dims to handle 4 colour component return (now a 3 bit return value).
  Merge the other M_THING enum from IJG8d so we don't need our own copy.
  Fix signed pointer comparison.
  Use symbolic defines from Global & Interface headers where possible.
  The jdata pointer arg is now treated as const.
Admin:
  Submission for the JPEG bounty.

Version 1.70. Tagged as 'SprExtend-1_70'
@
text
@d44 1
d46 1
a46 2

#ifdef JFIF_SUPPORTED
d121 2
a122 2
LOCAL INT32
get_2bytes (decompress_info_ptr cinfo)
d132 2
a133 2
LOCAL void
skip_variable (decompress_info_ptr cinfo, int code)
d148 2
a149 2
LOCAL void
get_dht (decompress_info_ptr cinfo)
d156 1
a156 1
  HUFF_TBL **htblptr;
d199 1
a199 1
      *htblptr = (HUFF_TBL *) malloc (SIZEOF(HUFF_TBL));
d210 2
a211 2
LOCAL void
get_dac (decompress_info_ptr cinfo)
d243 2
a244 2
LOCAL void
get_dqt (decompress_info_ptr cinfo)
d250 1
a250 1
  QUANT_TBL_PTR quant_ptr;
d267 2
a268 2
      cinfo->quant_tbl_ptrs[n] = (QUANT_TBL_PTR)
        malloc (SIZEOF(QUANT_TBL));
d276 1
a276 1
      quant_ptr[i] = tmp;
d293 2
a294 2
LOCAL void
get_dri (decompress_info_ptr cinfo)
d307 2
a308 2
LOCAL void
get_app0 (decompress_info_ptr cinfo)
d340 2
a341 2
      if (cinfo->jpeg_color_space == CS_UNKNOWN)
        cinfo->jpeg_color_space = CS_YCbCr;
d357 2
a358 2
LOCAL void
get_sof (decompress_info_ptr cinfo, int code)
d369 2
a370 2
  cinfo->image_height   = get_2bytes(cinfo);
  cinfo->image_width    = get_2bytes(cinfo);
d426 2
a427 2
LOCAL void
get_sos (decompress_info_ptr cinfo)
d473 2
a474 2
LOCAL void
get_soi (decompress_info_ptr cinfo)
d498 2
a499 2
LOCAL int
next_marker (decompress_info_ptr cinfo)
d526 2
a527 2
LOCAL JPEG_MARKER
process_tables (decompress_info_ptr cinfo)
d601 2
a602 2
METHODDEF void
read_file_header (decompress_info_ptr cinfo)
d641 1
a641 1
    cinfo->jpeg_color_space = CS_GRAYSCALE;
d647 1
a647 1
    if (cinfo->jpeg_color_space == CS_UNKNOWN) {
d653 3
a655 3
        cinfo->jpeg_color_space = CS_YCbCr; /* assume it's JFIF w/out marker */
      else if (cid0 == 1 && cid1 == 4 && cid2 == 5)
        cinfo->jpeg_color_space = CS_YIQ; /* prototype's YIQ matrix */
d660 1
a660 1
        cinfo->jpeg_color_space = CS_YCbCr;
d666 1
a666 1
    cinfo->jpeg_color_space = CS_CMYK;
d670 1
a670 1
    cinfo->jpeg_color_space = CS_UNKNOWN;
d681 2
a682 2
METHODDEF boolean
read_scan_header (decompress_info_ptr cinfo)
d713 1
a713 1
read_scan_trailer (decompress_info_ptr cinfo)
d725 1
a725 1
read_file_trailer (decompress_info_ptr cinfo)
d742 1
a742 1
jselrjfif (decompress_info_ptr cinfo)
a754 1
#endif /* JFIF_SUPPORTED */
@


4.2
log
@  Removal of empty debug loop.
  Addition of srccommit files.
Detail:
  * c.jrdjfif, get_dqt had an empty debug loop when debug was disabled.
    This is no longer compiled when debugging is not enabled.
  * VersionNum and VersionASM files added, and Sources.SprExtend modified
    to use symbols exported from there rather than from Version.
Admin:
  Ran on my machine. Previously tested in ROL builds.
  In future, might like to merge Exif support from ROL builds, but don't
  want to do that until I've re-read the specs on Exif format again.

Version 1.07. Tagged as 'SprExtend-1_07'
@
text
@d48 1
a48 2

typedef enum {                  /* JPEG marker codes */
d90 14
@


4.2.2.1
log
@Push some redundant files into the attic.
@
text
@d44 3
a46 2
#include "jpeglib.h"
#include <string.h>
a47 1
#if 1
d108 2
a109 2
LOCAL(INT32)
get_2bytes (j_decompress_ptr cinfo)
d119 2
a120 2
LOCAL(void)
skip_variable (j_decompress_ptr cinfo, int code)
a131 2
    
  UNUSED(code);
d135 2
a136 2
LOCAL(void)
get_dht (j_decompress_ptr cinfo)
d143 1
a143 1
  JHUFF_TBL **htblptr;
d197 2
a198 2
LOCAL(void)
get_dac (j_decompress_ptr cinfo)
d230 2
a231 2
LOCAL(void)
get_dqt (j_decompress_ptr cinfo)
d237 1
a237 1
  JQUANT_TBL *quant_ptr;
d254 2
a255 2
      cinfo->quant_tbl_ptrs[n] = (JQUANT_TBL *)
        malloc (SIZEOF(JQUANT_TBL));
d263 1
a263 1
      quant_ptr->quantval[i] = tmp;
d280 2
a281 2
LOCAL(void)
get_dri (j_decompress_ptr cinfo)
d294 2
a295 2
LOCAL(void)
get_app0 (j_decompress_ptr cinfo)
d327 2
a328 2
      if (cinfo->jpeg_color_space == JCS_UNKNOWN)
        cinfo->jpeg_color_space = JCS_YCbCr;
d344 2
a345 2
LOCAL(void)
get_sof (j_decompress_ptr cinfo, int code)
d368 1
a368 1
  if (cinfo->image_height == 0 || cinfo->image_width == 0
a409 2

  UNUSED(code);
d413 2
a414 2
LOCAL(void)
get_sos (j_decompress_ptr cinfo)
d460 2
a461 2
LOCAL(void)
get_soi (j_decompress_ptr cinfo)
d485 2
a486 2
LOCAL(int)
next_marker (j_decompress_ptr cinfo)
d513 2
a514 2
LOCAL(JPEG_MARKER)
process_tables (j_decompress_ptr cinfo)
d588 2
a589 2
METHODDEF(void)
read_file_header (j_decompress_ptr cinfo)
d628 1
a628 1
    cinfo->jpeg_color_space = JCS_GRAYSCALE;
d634 1
a634 1
    if (cinfo->jpeg_color_space == JCS_UNKNOWN) {
d640 1
a640 2
        cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's JFIF w/out marker */
#if 0
d642 1
a642 2
        cinfo->jpeg_color_space = JCS_YIQ; /* prototype's YIQ matrix */
#endif
d647 1
a647 1
        cinfo->jpeg_color_space = JCS_YCbCr;
d653 1
a653 1
    cinfo->jpeg_color_space = JCS_CMYK;
d657 1
a657 1
    cinfo->jpeg_color_space = JCS_UNKNOWN;
d668 2
a669 2
METHODDEF(boolean)
read_scan_header (j_decompress_ptr cinfo)
d699 2
a700 2
METHODDEF(void)
read_scan_trailer (j_decompress_ptr cinfo)
d711 2
a712 2
METHODDEF(void)
read_file_trailer (j_decompress_ptr cinfo)
d728 2
a729 2
GLOBAL(void)
jselrjfif (j_decompress_ptr cinfo)
@


4.2.2.2
log
@Fix CFSIjpeg due to earlier rename of jidctfst
Rename remaining files to match IJG 8b.

Version 1.38, 1.35.2.5. Tagged as 'SprExtend-1_38-1_35_2_5'
@
text
@@


4.1
log
@Initial revision
@
text
@d266 1
d272 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

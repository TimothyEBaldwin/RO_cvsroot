head	4.7;
access;
symbols
	SprExtend-1_37:4.6
	SprExtend-1_36:4.6
	SprExtend-1_35:4.6
	SprExtend-1_34:4.6
	SprExtend-1_33:4.5
	SprExtend-1_32:4.4
	SprExtend-1_31:4.3
	SprExtend-1_30:4.3
	SprExtend-1_29:4.3
	SprExtend-1_28:4.3
	SprExtend-1_27:4.2
	SprExtend-1_26:4.2
	SprExtend-1_25:4.2
	SprExtend-1_24:4.2
	SprExtend-1_23:4.2
	SprExtend-1_22:4.2
	SprExtend-1_21:4.2
	SprExtend-1_20:4.2
	SprExtend-1_19:4.2
	SprExtend-1_18:4.2
	SprExtend-1_17:4.2
	RO_5_07:4.2
	SprExtend-1_16:4.2
	SprExtend-1_15:4.2
	SprExtend-1_14:4.2
	SprExtend-1_13:4.1
	SprExtend-1_12:4.1
	SprExtend-1_11:4.1
	SprExtend-1_10:4.1
	SprExtend-1_09:4.1
	SprExtend-1_08:4.1
	dellis_autobuild_BaseSW:4.1
	SprExtend-1_07:4.1
	SprExtend-1_06:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	SprExtend-1_05:4.1
	Ursula_merge:4.1
	nturton_SprExtend-1_04:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.7
date	2010.12.23.09.00.56;	author rsprowson;	state dead;
branches;
next	4.6;

4.6
date	2010.11.06.17.29.36;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2010.10.17.09.01.35;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2010.10.13.20.26.21;	author rsprowson;	state Exp;
branches;
next	4.3;

4.3
date	2010.09.25.12.19.23;	author rsprowson;	state Exp;
branches;
next	4.2;

4.2
date	2002.12.19.18.53.15;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.45.02;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.45.02;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.40.48;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.57.26;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.20.06;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.7
log
@Retire unused IJG version 4 files.
Fold RISC OS specific colour conversion routines into rojpeg.
Remove jcconv, this also highlighted there were some more unused functions.
Should make move to IJG version 8 even easier.

Version 1.38. Tagged as 'SprExtend-1_38'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* c.jcconv - various cases of colour conversion which are not
important enough to be coded in assembler. */

void mono_convert_block(JBLOCK jblock, int *outptr, int outoffset)
/* Convert greyscale image into 32bit RBG values. */
{
  int i, j;

  for (j = 0; j < 8; j++)
  {
    for (i = 0; i < 8; i++)
    {
      int y;

      y = jblock[j + i*8];          /* extract, NB in row order */
      y = (y + (1<<18)) >> 19;      /* descale */
      y += 128;                     /* normalise */
      if (y < 0) y = 0;             /* clip */
      if (y > 255) y = 255;
      y = y | (y << 8) | (y << 16); /* construct RGB value */
      outptr[i] = y;
    }
    outptr += outoffset;
  }
}

static int mono_convert_pixel(decompress_info_ptr cinfo, int pix)
/* Just do a single pixel - eg. for DC-only display. The pixel does not have to
be shifted down, as it has not gone through the DCT. */
{
  int y = pix;

  y += 128;                      /* normalise */
  if (y < 0) y = 0;              /* range check */
  if (y > 255) y = 255;
  UNUSED(cinfo);
  
  return y | (y << 8) | (y << 16); /* replicate Y value */
}


#ifdef FIX
  #undef FIX
#endif
#define SCALEBITS       8 /*16*/      /* speedier right-shift on some machines */
#define ONE_HALF        ((INT32) 1 << (SCALEBITS-1))
#define FIX(x)          ((INT32) ((x) * (1L<<SCALEBITS) + 0.5))

#if 0
extern int gun_oflow = 0; /* pixels that did in some way overflow, +ve or -ve */
extern int gun_noflow = 0; /* didn't overflow */
/* Result of this experiment - about 6K/135K (<5%) of pixels in the dragon picture overflow. */
#endif

void colour_convert_block(JCOEF *yuv, int *outptr, int outoffset)
/* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block */
{
  int i, j;
  JCOEF *by0 = yuv;
  JCOEF *by1 = by0 + DCTSIZE2;
  JCOEF *by2 = by1 + DCTSIZE2;
  JCOEF *by3 = by2 + DCTSIZE2;
  JCOEF *bu = by3 + DCTSIZE2;
  JCOEF *bv = bu + DCTSIZE2;

  for (j = 0; j < 16; j++)
  {
    for (i = 0; i < 16; i++)
    {
      int y;
      int u;
      int v;

      y = (j < 8 ? (i < 8 ? by0 : by1) : (i < 8 ? by2 : by3))[(j&7) + (i&7)*8]; /* extract from right block, NB row order */
      u = bu[(j>>1) + (i>>1)*8];
      v = bv[(j>>1) + (i>>1)*8];

      y = (y + (1<<18)) >> 19;      /* descale */
      y += 128;                     /* normalise */
      u = (u + (1<<18)) >> 19;
      v = (v + (1<<18)) >> 19;
      {
        int r =                        v * FIX(1.40200);
        int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
        int b =     u * FIX(1.77200);

        r += ONE_HALF; r >>= SCALEBITS; r += y; if (r < 0) r = 0; if (r > 255) r = 255;
        g += ONE_HALF; g >>= SCALEBITS; g += y; if (g < 0) g = 0; if (g > 255) g = 255;
        b += ONE_HALF; b >>= SCALEBITS; b += y; if (b < 0) b = 0; if (b > 255) b = 255;
        outptr[i] = r | (g << 8) | (b << 16);
      }
    }
    outptr += outoffset;
  }
}

static void colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset, int wide, int high)
/* yuv[0..1] are Y, yuv[4] is U, yuv[5] is V. wide/high are 1 or 2. Both being 2 is the
most common case, for which we use hand-coded assembler instead. */
{
  unsigned int i, j;
  JCOEF *by0 = yuv + 0*DCTSIZE2;
  JCOEF *by1 = yuv + 1*DCTSIZE2;
  JCOEF *bu = yuv + 4*DCTSIZE2;
  JCOEF *bv = yuv + 5*DCTSIZE2;

  for (j = 0; j < 8*high; j++)
  {
    for (i = 0; i < 8*wide; i++)
    {
      int y;
      int u;
      int v;

      /* Simplification because we don't use this code in the 2x2 case, so
       * we only need to worry about accessing a second block. */

      y = ((i < 8 && j < 8) ? by0 : by1)[(j&7) + (i&7)*8]; /* extract from right block, NB row order */
      u = bu[(j>>(high-1)) + (i>>(wide-1))*8];
      v = bv[(j>>(high-1)) + (i>>(wide-1))*8];

      y = (y + (1<<18)) >> 19;      /* descale */
      y += 128;                     /* normalise */
      u = (u + (1<<18)) >> 19;
      v = (v + (1<<18)) >> 19;
      {
        int r =                        v * FIX(1.40200);
        int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
        int b =     u * FIX(1.77200);

        r += ONE_HALF; r >>= SCALEBITS; r += y; if (r < 0) r = 0; if (r > 255) r = 255;
        g += ONE_HALF; g >>= SCALEBITS; g += y; if (g < 0) g = 0; if (g > 255) g = 255;
        b += ONE_HALF; b >>= SCALEBITS; b += y; if (b < 0) b = 0; if (b > 255) b = 255;
        outptr[i] = r | (g << 8) | (b << 16);
      }
    }
    outptr += outoffset;
  }
}

static void colour_convert_pixels(int *y, int u, int v)
/* Convert four pixels. Input y values are in y[0..3], put output there too.
Used for DC-only colour output. The input pixels do not have to be shifted
down by 19, as they have not been through the DCT. */
{
  u = (u + 4) >> 3; /* descale */
  v = (v + 4) >> 3;

  {
    int r =                        v * FIX(1.40200);
    int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
    int b =     u * FIX(1.77200);
    int i;
    int rr, gg, bb, yy;

    r += ONE_HALF; r >>= SCALEBITS;
    g += ONE_HALF; g >>= SCALEBITS;
    b += ONE_HALF; b >>= SCALEBITS;
    for (i = 0; i < 4; i++)
    {
      yy = ((y[i] + 4) >> 3) + 128;
      rr = r + yy; if (rr < 0) rr = 0; if (rr > 255) rr = 255;
      gg = g + yy; if (gg < 0) gg = 0; if (gg > 255) gg = 255;
      bb = b + yy; if (bb < 0) bb = 0; if (bb > 255) bb = 255;
      y[i] = rr | (gg << 8) | (bb << 16);
    }
  }
}

static void mono_convert_pixels(int *y)
/* Convert four pixels. Input y values are in y[0..3], put output there too.
Used for DC-only mono output. The input pixels do not have to be shifted
down by 19, as they have not been through the DCT. */
{
  int i;
  int yy;

  for (i = 0; i < 4; i++)
  {
    yy = ((y[i] + 4) >> 3) + 128;
    if (yy < 0) yy = 0; if (yy > 255) yy = 255;
    y[i] = yy | (yy << 8) | (yy << 16);
  }
}

#if 0
/* This isn't called by anyone at the moment, I can't get the relationship
with the scaling code precisely right. */

static void interpolate_x(decompress_info_ptr cinfo)
/* The band buffer contains 8 or 16 lines of decompressed data. Double the
size of each line, by interpolating the pixels. There is enough room. We
actually do a teeny approximation by ignoring the bottom bit of each colour
gun when doing the interpolation, but this is almost certainly OK given the
inaccuracies that have already happened in the JPEG process. */
{
  int l2_band_height = 2 + cinfo->comp_info[0].v_samp_factor; /* log2 of band height - 3 for mono, usually 4 for colour */
  /* int band_height = 1 << l2_band_height; */
  int line_offset = cinfo->band_buffer_size >> l2_band_height; /* offset in words between lines of output */
  int *line_ptr;
  int *line_lim;
  int pix_mask = 0x00fefefe; /* mask to knock out bot pixel of each gun */

  for (line_ptr = cinfo->band_buffer, line_lim = cinfo->band_buffer + cinfo->band_buffer_size; line_ptr < line_lim; line_ptr += line_offset)
  {
    int prev_pixel = line_ptr[cinfo->image_width - 1] & pix_mask;
    int *pix_ptr;
    int *out_ptr = line_ptr + 2*cinfo->image_width;

    for (pix_ptr = line_ptr + cinfo->image_width; pix_ptr != line_ptr;)
    {
      int this_pixel = *--pix_ptr;
      int trunc_this_pixel = this_pixel & pix_mask;

      *--out_ptr = (trunc_this_pixel + prev_pixel) >> 1;
      *--out_ptr = this_pixel;
      prev_pixel = trunc_this_pixel;
    }
  }
}
#endif
@


4.6
log
@Fix infinite loop when unrecognised entropy encoding encountered.
In find_image_dims() the while loop is only exited when SOF0 or SOF1 (the two supported ones) is encountered, the other 14 possible combinations got stuck in a loop because OS_GBPB doesn't return an error at EOF.
Check added for OS_GBPB returning nothing, plus an exit when a SOS or EOI tag is hit for the memory only check (it's not possible to know where the end truly is in that case.
jcconv: warning supressed.
SWIs: comment corrected.
Tested with a bogus SOF, now gives an error message instead.

Version 1.34. Tagged as 'SprExtend-1_34'
@
text
@@


4.5
log
@Change memory management strategy.
There's no need for the C code to know which pool of memory it's using, so simplify it to just use malloc() and realloc(), the assembler implementation can then select whether the RMA or a dynamic area is in use based on the 'dynamicarea' switch.
Be more careful about area_number when it is zero, since we use that to denote the area is not yet set up but area zero is a valid dynamic area number!
Trim out some unused workspace.
Variable ccompiler_errptr had '# 0' bytes assigned, resulting in writes off the end of the workspace.
Retire DUMPVAL[N]() macro.
Remove M_SOF9 as one of the SOF markers accepted - this is allocated to arithmetic JPEGs which aren't currently supported.
Save a few words by: changing arbitrary constants (eg. safety margins) to be a power of two so they can be register immediates; numerous loads and stores of R12 relative variables changed to not use ADRL; jpeg_fetchroutine similarly simplified.

Version 1.33. Tagged as 'SprExtend-1_33'
@
text
@d50 2
@


4.4
log
@Paper and fill some JPEG cracks.
The exit_c function was repeatedly being called with the line number argument and error code the wrong way round and since only bits 0-2 of the error code are inspected on exit any fatal exits from the ported JPEG library code would either report the wrong error or fail silently (depending on the line number) - example a 12 bits per sample JPEG would be rendered without fault into a screen full of random memory garbage.
Assembling/compiling with the 'jpeg' switch off didn't work, fixed, and also now zeros out the SWI decode values in the module header.
Moved include of 'yuvtabs.s' into the colour conversion code.
Deleted panic_exit, it did nothing useful but trace a value then exit, so it now just calls exit() like everyone else.
Removed excess call to find_image_dims(), this was needed just to get the workspace requirements when the JPEG had already been sized up by asm_find_image_dims() earlier. Side effect of removing the pilot JPEG code earlier is that this call can now only get to the JPEG code from a JPEG_ SWI. Changed to just pass the workspace requirements into 'c.PutScaled' and save a duplicate scan.
Fatal exits from the assembler huffman decoder now report a sensible error.
Trimmed out all the JPEG assessment code from 'c.PutScaled' and moved it into 'c.rojpeg' so the put scaled is only concerned with putting things scaled.
Sanitised the #includes a bit.
Fixed on last check of wp->save_mode looking at the wrong bits for the mode number.
Resolved all the warning in the genhdr/genyuvtabs/genpalette utilities by casting a bit harder.[A[B
Added new more descriptive error messages to the messages file (not currently used), and made the 'not supported by' ones consistent so the tokeniser might crunch the file a bit more.
In looks_like_jpeg() changed a bitwise to logical or.
Fixed longstanding problem of not being able to render JPEGs at a scale of less than 1/6 in any greyscale mode, because, err, there was no code to do it - only the colour case was checked for. Implemented for 8bpp grey and 32bpp grey (which gets dithered for other lower modes) by just converting the luma channel into an equally weighted RGB value or replicating it for 256 greys.
Tested in all 8 colour depths on a Risc PC using sampling ratios of 1x1; 2x1; 1x2; 2x2 of the IJG test image scaled in !Draw by 0.16.

Version 1.32. Tagged as 'SprExtend-1_32'
@
text
@d30 1
a30 2
      y = (y + 0x40000) >> 19;       /* descale */
      /* tracef("%i " _ y); */
d90 1
a90 1
      y = (y + 0x40000) >> 19;       /* descale */
d92 2
a93 2
      u = (u + 0x40000) >> 19;
      v = (v + 0x40000) >> 19;
d114 1
a114 1
  JCOEF *by0 = yuv + 0*DCTSIZE2;;
d134 1
a134 1
      y = (y + 0x40000) >> 19;       /* descale */
d136 2
a137 2
      u = (u + 0x40000) >> 19;
      v = (v + 0x40000) >> 19;
@


4.3
log
@Remove postprocessing step of C code.
Since 2001 this module has been using objasm, but still using the C compiler to output (via -S) assembly code which is then passed through 'sed' and included via GET into the assembler code.
Changed to compile the C code into object files, and use the linker to patch up the unresolved references - this has required some reordering of the C code to make sure static functions now appear in the object file, and some reordering of the header files to ensure both the module and the CFSI version still compile without conflicts.
Minor fix to 'swiv2', the label was in the wrong place for _swi() though it's not used in this module so didn't affect the _swix() case.
Makefile cut down a bit. Unixify some path names.
Test code moved to 'Test/c' directory.
Tested in both debug and non debug cases via softloaded module. Oddly, it's 4 bytes longer than the previous version.

Version 1.28. Tagged as 'SprExtend-1_28'
@
text
@a158 5
#if 0
  u = (u + (1<<18)) >> 19;
  v = (v + (1<<18)) >> 19;
#endif

d183 16
@


4.2
log
@* Transformed sprite plotting did not use the translation table if its
  address had the top bit set.
* Transformed sprite plotting optimised to not read the screen memory when
  it could be simply avoided - greatly enhances performance on Iyonix.
* Decoding of 1x2 sampled JPEGs fixed.

Version 1.14. Tagged as 'SprExtend-1_14'
@
text
@d18 1
a18 1
static void mono_convert_block(JBLOCK jblock, int *outptr, int outoffset)
d68 1
a68 1
static void colour_convert_block(JCOEF *yuv, int *outptr, int outoffset)
@


4.1
log
@Initial revision
@
text
@d114 5
a118 7
  int i, j;
  JCOEF *by0 = yuv;
  JCOEF *by1 = by0 + DCTSIZE2;
  JCOEF *by2 = by1 + DCTSIZE2;
  JCOEF *by3 = by2 + DCTSIZE2;
  JCOEF *bu = by3 + DCTSIZE2;
  JCOEF *bv = bu + DCTSIZE2;
d128 4
a131 1
      y = (j < 8 ? (i < 8 ? by0 : by1) : (i < 8 ? by2 : by3))[(j&7) + (i&7)*8]; /* extract from right block, NB row order */
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

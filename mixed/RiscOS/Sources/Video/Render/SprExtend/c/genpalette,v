head	4.2;
access;
symbols
	SprExtend-1_83:4.2
	SprExtend-1_82:4.2
	SprExtend-1_81:4.2
	SprExtend-1_80:4.2
	SprExtend-1_79:4.2
	SprExtend-1_78:4.2
	SprExtend-1_77:4.2
	SprExtend-1_76:4.2
	SprExtend-1_75:4.2
	SprExtend-1_74:4.2
	SprExtend-1_73:4.2
	SprExtend-1_72:4.2
	SprExtend-1_71-nocfsi:4.2
	SprExtend-1_71:4.2
	SprExtend-1_70-tracef:4.2
	SprExtend-1_70-headers:4.2
	SprExtend-1_70:4.2
	SprExtend-1_69:4.2
	SprExtend-1_68:4.2
	SprExtend-1_67:4.2
	SprExtend-1_66:4.2
	SprExtend-1_65:4.2
	SprExtend-1_64:4.2
	SprExtend-1_63:4.2
	SprExtend-1_62:4.2
	SprExtend-1_61:4.2
	SprExtend-1_60:4.2
	SprExtend-1_59:4.2
	SprExtend-1_58:4.2
	SprExtend-1_57:4.2
	SprExtend-1_56:4.2
	SprExtend-1_55:4.2
	SprExtend-1_54:4.2
	SprExtend-1_53:4.2
	SprExtend-1_52:4.2
	SprExtend-1_51:4.2
	SprExtend-1_50:4.2
	SprExtend-1_38-1_35_2_16:4.2
	SprExtend-1_49:4.2
	SprExtend-1_48:4.2
	SprExtend-1_47:4.2
	SprExtend-1_38-1_35_2_15:4.2
	SprExtend-1_46:4.2
	SprExtend-1_45:4.2
	SprExtend-1_44:4.2
	SprExtend-1_43:4.2
	SprExtend-1_42:4.2
	SprExtend-1_41:4.2
	SprExtend-1_38-1_35_2_14:4.2
	SprExtend-1_40:4.2
	SprExtend-1_38-1_35_2_13:4.2
	SprExtend-1_38-1_35_2_12:4.2
	SprExtend-1_38-1_35_2_11:4.2
	SprExtend-1_38-1_35_2_10:4.2
	SprExtend-1_38-1_35_2_9:4.2
	SprExtend-1_38-1_35_2_8:4.2
	SprExtend-1_39:4.2
	SprExtend-1_38-1_35_2_7:4.2
	SprExtend-1_38-1_35_2_6:4.2
	SprExtend-1_38-1_35_2_5:4.2
	SprExtend-1_38-1_35_2_4:4.2
	SprExtend-1_38-1_35_2_3:4.2
	SprExtend-1_38-1_35_2_2:4.2
	SprExtend-1_38-1_35_2_1:4.2
	MigrateIJG8b:4.2.0.2
	SprExtend-1_38:4.2
	SprExtend-1_37:4.2
	SprExtend-1_36:4.2
	SprExtend-1_35:4.2
	SprExtend-1_34:4.2
	SprExtend-1_33:4.2
	SprExtend-1_32:4.2
	SprExtend-1_31:4.1
	SprExtend-1_30:4.1
	SprExtend-1_29:4.1
	SprExtend-1_28:4.1
	SprExtend-1_27:4.1
	SprExtend-1_26:4.1
	SprExtend-1_25:4.1
	SprExtend-1_24:4.1
	SprExtend-1_23:4.1
	SprExtend-1_22:4.1
	SprExtend-1_21:4.1
	SprExtend-1_20:4.1
	SprExtend-1_19:4.1
	SprExtend-1_18:4.1
	SprExtend-1_17:4.1
	RO_5_07:4.1
	SprExtend-1_16:4.1
	SprExtend-1_15:4.1
	SprExtend-1_14:4.1
	SprExtend-1_13:4.1
	SprExtend-1_12:4.1
	SprExtend-1_11:4.1
	SprExtend-1_10:4.1
	SprExtend-1_09:4.1
	SprExtend-1_08:4.1
	dellis_autobuild_BaseSW:4.1
	SprExtend-1_07:4.1
	SprExtend-1_06:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	SprExtend-1_05:4.1
	Ursula_merge:4.1
	nturton_SprExtend-1_04:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.2
date	2010.10.13.20.26.21;	author rsprowson;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.45.02;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.45.02;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.40.41;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.57.22;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.20.03;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.2
log
@Paper and fill some JPEG cracks.
The exit_c function was repeatedly being called with the line number argument and error code the wrong way round and since only bits 0-2 of the error code are inspected on exit any fatal exits from the ported JPEG library code would either report the wrong error or fail silently (depending on the line number) - example a 12 bits per sample JPEG would be rendered without fault into a screen full of random memory garbage.
Assembling/compiling with the 'jpeg' switch off didn't work, fixed, and also now zeros out the SWI decode values in the module header.
Moved include of 'yuvtabs.s' into the colour conversion code.
Deleted panic_exit, it did nothing useful but trace a value then exit, so it now just calls exit() like everyone else.
Removed excess call to find_image_dims(), this was needed just to get the workspace requirements when the JPEG had already been sized up by asm_find_image_dims() earlier. Side effect of removing the pilot JPEG code earlier is that this call can now only get to the JPEG code from a JPEG_ SWI. Changed to just pass the workspace requirements into 'c.PutScaled' and save a duplicate scan.
Fatal exits from the assembler huffman decoder now report a sensible error.
Trimmed out all the JPEG assessment code from 'c.PutScaled' and moved it into 'c.rojpeg' so the put scaled is only concerned with putting things scaled.
Sanitised the #includes a bit.
Fixed on last check of wp->save_mode looking at the wrong bits for the mode number.
Resolved all the warning in the genhdr/genyuvtabs/genpalette utilities by casting a bit harder.[A[B
Added new more descriptive error messages to the messages file (not currently used), and made the 'not supported by' ones consistent so the tokeniser might crunch the file a bit more.
In looks_like_jpeg() changed a bitwise to logical or.
Fixed longstanding problem of not being able to render JPEGs at a scale of less than 1/6 in any greyscale mode, because, err, there was no code to do it - only the colour case was checked for. Implemented for 8bpp grey and 32bpp grey (which gets dithered for other lower modes) by just converting the luma channel into an equally weighted RGB value or replicating it for 256 greys.
Tested in all 8 colour depths on a Risc PC using sampling ratios of 1x1; 2x1; 1x2; 2x2 of the IJG test image scaled in !Draw by 0.16.

Version 1.32. Tagged as 'SprExtend-1_32'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Simple code to generate assembler source for the
8bpp palette lookup table. The table consists of 256
32bit entries, containing the true RGB values of the
256 pixel values of the standard 8bpp palette. To get
that value, take the 4 bits of hicolour/tint for each
gun, and replicate them in the hi and lo 4 bits of that
gun.

The 8bpp pixels are bggrbrtt
*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define BIT(n) (1<<(n))

int main(void)
{
  int i;

  printf("; s.genpalette, generated by genpalette %s %s.\n\n"
         "; The table consists of 256 16bit entries, containing the true RGB values\n"
         "; of the 256 pixel values of the standard 8bpp palette.\n"
         "; The 8bpp pixels are bggrbrtt, the words are 0BGR\n", __DATE__, __TIME__);
  for (i = 0; i < 256; i++)
  {
#if 0
/* Code that generates 16bit entries - not accurate enough */
    int hibyte = 0;
    int lobyte = 0;

    if (i & BIT(7)) hibyte |= BIT(6); /* hi bit of blue */
    if (i & BIT(6)) hibyte |= BIT(1); /* hi bit of green */
    if (i & BIT(5)) hibyte |= BIT(0); /* next bit of green */
    if (i & BIT(4)) lobyte |= BIT(4); /* hi bit of red */
    if (i & BIT(3)) hibyte |= BIT(5); /* next bit of blue */
    if (i & BIT(2)) lobyte |= BIT(3); /* next bit of red */
    if (i & BIT(1)) /* hi bit of tint - bits 0 and 2 of each gun */
    {
      hibyte |= BIT(2) | BIT(4);
      lobyte |= BIT(7) | BIT(5) | BIT(2) | BIT(0);
    }
    if (i & BIT(0)) /* lo bit of tint - bit 1 of each gun */
    {
      hibyte |= BIT(3);
      lobyte |= BIT(6) | BIT(1);
    }
    printf("        DCB     %i,%i\n", lobyte, hibyte);
#else
    int r = 0, g = 0, b = 0;

    if (i & BIT(7)) b |= BIT(7); /* hi bit of blue */
    if (i & BIT(6)) g |= BIT(7); /* hi bit of green */
    if (i & BIT(5)) g |= BIT(6); /* next bit of green */
    if (i & BIT(4)) r |= BIT(7); /* hi bit of red */
    if (i & BIT(3)) b |= BIT(6); /* next bit of blue */
    if (i & BIT(2)) r |= BIT(6); /* next bit of red */
    if (i & BIT(1)) /* hi bit of tint - bit 5 of each gun */
    {
      r |= BIT(5);
      g |= BIT(5);
      b |= BIT(5);
    }
    if (i & BIT(0)) /* lo bit of tint - bit 1 of each gun */
    {
      r |= BIT(4);
      g |= BIT(4);
      b |= BIT(4);
    }
    r |= r>>4;
    g |= g>>4;
    b |= b>>4;
    printf("        DCB     %i,%i,%i,0\n", r, g, b);
#endif
  }
  printf("        ALIGN\n");
  printf("        END\n");

  return 0;
}
@


4.1
log
@Initial revision
@
text
@d32 1
a32 1
int main(int argc, char **argv)
d36 1
a36 1
  printf("; s.genpalette, generated by c.genpalette\n"
d39 1
a39 1
         "; The 8bpp pixels are bggrbrtt, the words are 0BGR\n");
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.6;
access;
symbols
	SprExtend-1_83:4.6
	SprExtend-1_82:4.6
	SprExtend-1_81:4.6
	SprExtend-1_80:4.6
	SprExtend-1_79:4.6
	SprExtend-1_78:4.6
	SprExtend-1_77:4.6
	SprExtend-1_76:4.6
	SprExtend-1_75:4.6
	SprExtend-1_74:4.6
	SprExtend-1_73:4.5
	SprExtend-1_72:4.5
	SprExtend-1_71-nocfsi:4.4
	SprExtend-1_71:4.4
	SprExtend-1_70-tracef:4.3
	SprExtend-1_70-headers:4.3
	SprExtend-1_70:4.3
	SprExtend-1_69:4.3
	SprExtend-1_68:4.3
	SprExtend-1_67:4.3
	SprExtend-1_66:4.3
	SprExtend-1_65:4.3
	SprExtend-1_64:4.3
	SprExtend-1_63:4.3
	SprExtend-1_62:4.3
	SprExtend-1_61:4.3
	SprExtend-1_60:4.3
	SprExtend-1_59:4.3
	SprExtend-1_58:4.3
	SprExtend-1_57:4.3
	SprExtend-1_56:4.3
	SprExtend-1_55:4.3
	SprExtend-1_54:4.3
	SprExtend-1_53:4.3
	SprExtend-1_52:4.3
	SprExtend-1_51:4.3
	SprExtend-1_50:4.3
	SprExtend-1_38-1_35_2_16:4.2.2.6
	SprExtend-1_38-1_35_2_15:4.2.2.6
	SprExtend-1_38-1_35_2_14:4.2.2.6
	SprExtend-1_38-1_35_2_13:4.2.2.5
	SprExtend-1_38-1_35_2_12:4.2.2.5
	SprExtend-1_38-1_35_2_11:4.2.2.5
	SprExtend-1_38-1_35_2_10:4.2.2.5
	SprExtend-1_38-1_35_2_9:4.2.2.5
	SprExtend-1_38-1_35_2_8:4.2.2.4
	SprExtend-1_38-1_35_2_7:4.2.2.3
	SprExtend-1_38-1_35_2_6:4.2.2.2
	MigrateIJG8b:4.2.0.2
	SprExtend-1_37:4.1
	SprExtend-1_36:4.1
	SprExtend-1_35:4.1
	SprExtend-1_34:4.1
	SprExtend-1_33:4.1
	SprExtend-1_32:4.1
	SprExtend-1_31:4.1
	SprExtend-1_30:4.1
	SprExtend-1_29:4.1
	SprExtend-1_28:4.1
	SprExtend-1_27:4.1
	SprExtend-1_26:4.1
	SprExtend-1_25:4.1
	SprExtend-1_24:4.1
	SprExtend-1_23:4.1
	SprExtend-1_22:4.1
	SprExtend-1_21:4.1
	SprExtend-1_20:4.1
	SprExtend-1_19:4.1
	SprExtend-1_18:4.1
	SprExtend-1_17:4.1
	RO_5_07:4.1
	SprExtend-1_16:4.1
	SprExtend-1_15:4.1
	SprExtend-1_14:4.1
	SprExtend-1_13:4.1
	SprExtend-1_12:4.1
	SprExtend-1_11:4.1
	SprExtend-1_10:4.1
	SprExtend-1_09:4.1
	SprExtend-1_08:4.1
	dellis_autobuild_BaseSW:4.1
	SprExtend-1_07:4.1
	SprExtend-1_06:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	SprExtend-1_05:4.1
	Ursula_merge:4.1
	nturton_SprExtend-1_04:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2016.05.21.14.10.17;	author rool;	state Exp;
branches;
next	4.5;
commitid	RAjaHu2jGaPW7m7z;

4.5
date	2016.05.21.14.03.48;	author rool;	state Exp;
branches;
next	4.4;
commitid	4BquZHousteH5m7z;

4.4
date	2016.05.21.13.44.38;	author rool;	state Exp;
branches;
next	4.3;
commitid	ZDqmsyNiMhv6Zl7z;

4.3
date	2012.07.28.15.23.41;	author rsprowson;	state Exp;
branches;
next	4.2;
commitid	b5jdybqzJ3Wdjlew;

4.2
date	2010.12.23.09.00.57;	author rsprowson;	state dead;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.45.02;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	2010.12.23.09.00.57;	author rsprowson;	state dead;
branches;
next	4.2.2.2;

4.2.2.2
date	2011.01.09.10.42.59;	author rsprowson;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	2011.01.09.10.56.44;	author rsprowson;	state Exp;
branches;
next	4.2.2.4;

4.2.2.4
date	2011.01.13.21.12.20;	author rsprowson;	state Exp;
branches;
next	4.2.2.5;

4.2.2.5
date	2011.01.22.17.58.30;	author rsprowson;	state Exp;
branches;
next	4.2.2.6;

4.2.2.6
date	2011.02.15.20.58.02;	author rsprowson;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.45.02;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.40.50;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.57.27;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.20.07;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Bug fixes
Detail:
  Remove the unused gray (sic) output colour space support. Remove the patches to set output colour space to RGB, this can be overridden in code per the design intent of the library. Only decode luma for grey output.
  Fix bug rendering test image monorose2x4 - this was caused by the huffman pointer saving not decoding enough MCUs when the source image is monochrome hence an MCU outputs 8x8 rather than hsamp x vsamp pixels. Also removed the setting of insufficient_data in the entropy decoder, this meant that any error at the end of the image (eg. truncated) would cause the rest of the image to not render because JPEGs are stored top down but RISC OS plots them bottom up.
  Fix endless failure to match previously cached JPEG, especially at 16bpp, when the source JPEG doesn't meet the fast colour conversion criteria (eg. not 2x2 subsampling). The flags test was checking the requested flags against the filtered flags, which never matched (because the unmet options get cleared). Now, keep the original flags prior to filtering and compare those on the basis that the conversion decision will be consistent; simply ANDing out those modifiable flags doesn't help because then you can't spot when they genuinely change (eg. a mode change) as the filtered flags determine what format the blitter is expecting back.
  Fix bug causing aborts when the user manually resizes (down) the JPEG workspace DA. The calculation of new_size in jpeg_find_image_dims() had at some point lost the height multiplier on the band buffer, so when auto resizing back up again the buffer was too small to convert a whole band into.
Admin:
  Submission for the JPEG bounty.

Version 1.74. Tagged as 'SprExtend-1_74'
@
text
@/*
 * jdcolor.c
 *
 * Copyright (C) 1991-1997, Thomas G. Lane.
 * Modified 2011 by Guido Vollbeding.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains output colorspace conversion routines.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* Private subobject */

typedef struct {
  struct jpeg_color_deconverter pub; /* public fields */

  /* Private state for YCC->RGB conversion */
  int * Cr_r_tab;		/* => table for Cr to R conversion */
  int * Cb_b_tab;		/* => table for Cb to B conversion */
  INT32 * Cr_g_tab;		/* => table for Cr to G conversion */
  INT32 * Cb_g_tab;		/* => table for Cb to G conversion */

  /* Private state for RGB->Y conversion */
  INT32 * rgb_y_tab;		/* => table for RGB to Y conversion */
} my_color_deconverter;

typedef my_color_deconverter * my_cconvert_ptr;


/**************** YCbCr -> RGB conversion: most common case **************/
/****************   RGB -> Y   conversion: less common case **************/

/*
 * YCbCr is defined per CCIR 601-1, except that Cb and Cr are
 * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
 * The conversion equations to be implemented are therefore
 *
 *	R = Y                + 1.40200 * Cr
 *	G = Y - 0.34414 * Cb - 0.71414 * Cr
 *	B = Y + 1.77200 * Cb
 *
 *	Y = 0.29900 * R + 0.58700 * G + 0.11400 * B
 *
 * where Cb and Cr represent the incoming values less CENTERJSAMPLE.
 * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
 *
 * To avoid floating-point arithmetic, we represent the fractional constants
 * as integers scaled up by 2^16 (about 4 digits precision); we have to divide
 * the products by 2^16, with appropriate rounding, to get the correct answer.
 * Notice that Y, being an integral input, does not contribute any fraction
 * so it need not participate in the rounding.
 *
 * For even more speed, we avoid doing any multiplications in the inner loop
 * by precalculating the constants times Cb and Cr for all possible values.
 * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
 * for 12-bit samples it is still acceptable.  It's not very reasonable for
 * 16-bit samples, but if you want lossless storage you shouldn't be changing
 * colorspace anyway.
 * The Cr=>R and Cb=>B values can be rounded to integers in advance; the
 * values for the G calculation are left scaled up, since we must add them
 * together before rounding.
 */

#define SCALEBITS	16	/* speediest right-shift on some machines */
#define ONE_HALF	((INT32) 1 << (SCALEBITS-1))
#define FIX(x)		((INT32) ((x) * (1L<<SCALEBITS) + 0.5))

/* We allocate one big table for RGB->Y conversion and divide it up into
 * three parts, instead of doing three alloc_small requests.  This lets us
 * use a single table base address, which can be held in a register in the
 * inner loops on many machines (more than can hold all three addresses,
 * anyway).
 */

#define R_Y_OFF		0			/* offset to R => Y section */
#define G_Y_OFF		(1*(MAXJSAMPLE+1))	/* offset to G => Y section */
#define B_Y_OFF		(2*(MAXJSAMPLE+1))	/* etc. */
#define TABLE_SIZE	(3*(MAXJSAMPLE+1))


/*
 * Initialize tables for YCC->RGB colorspace conversion.
 */

LOCAL(void)
build_ycc_rgb_table (j_decompress_ptr cinfo)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  int i;
  INT32 x;
  SHIFT_TEMPS

  cconvert->Cr_r_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(int));
  cconvert->Cb_b_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(int));
  cconvert->Cr_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(INT32));
  cconvert->Cb_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(INT32));

  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
    /* Cr=>R value is nearest int to 1.40200 * x */
    cconvert->Cr_r_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
    /* Cb=>B value is nearest int to 1.77200 * x */
    cconvert->Cb_b_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
    /* Cr=>G value is scaled-up -0.71414 * x */
    cconvert->Cr_g_tab[i] = (- FIX(0.71414)) * x;
    /* Cb=>G value is scaled-up -0.34414 * x */
    /* We also add in ONE_HALF so that need not do it in inner loop */
    cconvert->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
  }
}


/*
 * Convert some rows of samples to the output colorspace.
 *
 * Note that we change from noninterleaved, one-plane-per-component format
 * to interleaved-pixel format.  The output buffer is therefore three times
 * as wide as the input buffer.
 * A starting row offset is provided only for the input buffer.  The caller
 * can easily adjust the passed output_buf value to accommodate any row
 * offset required on that side.
 */

METHODDEF(void)
ycc_rgb_convert (j_decompress_ptr cinfo,
		 JSAMPIMAGE input_buf, JDIMENSION input_row,
		 JSAMPARRAY output_buf, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int y, cb, cr;
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
  register int * Crrtab = cconvert->Cr_r_tab;
  register int * Cbbtab = cconvert->Cb_b_tab;
  register INT32 * Crgtab = cconvert->Cr_g_tab;
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
  SHIFT_TEMPS

  while (--num_rows >= 0) {
    inptr0 = input_buf[0][input_row];
    inptr1 = input_buf[1][input_row];
    inptr2 = input_buf[2][input_row];
    input_row++;
    outptr = *output_buf++;
    for (col = 0; col < num_cols; col++) {
      y  = GETJSAMPLE(inptr0[col]);
      cb = GETJSAMPLE(inptr1[col]);
      cr = GETJSAMPLE(inptr2[col]);
      /* Range-limiting is essential due to noise introduced by DCT losses. */
#ifdef RISCOS /* Always &0BGR words */
      *(int *)outptr = (range_limit[y + Crrtab[cr]] << 0) |
                       (range_limit[y + ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
                                                           SCALEBITS))] << 8) |
                       (range_limit[y + Cbbtab[cb]] << 16);
#else
      outptr[RGB_RED] =   range_limit[y + Crrtab[cr]];
      outptr[RGB_GREEN] = range_limit[y +
			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
						 SCALEBITS))];
      outptr[RGB_BLUE] =  range_limit[y + Cbbtab[cb]];
#endif
      outptr += RGB_PIXELSIZE;
    }
  }
}


#ifndef RISCOS /* Processed to RGB, unused */
/**************** Cases other than YCbCr -> RGB **************/


/*
 * Initialize for RGB->grayscale colorspace conversion.
 */

LOCAL(void)
build_rgb_y_table (j_decompress_ptr cinfo)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  INT32 * rgb_y_tab;
  INT32 i;

  /* Allocate and fill in the conversion tables. */
  cconvert->rgb_y_tab = rgb_y_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(TABLE_SIZE * SIZEOF(INT32)));

  for (i = 0; i <= MAXJSAMPLE; i++) {
    rgb_y_tab[i+R_Y_OFF] = FIX(0.29900) * i;
    rgb_y_tab[i+G_Y_OFF] = FIX(0.58700) * i;
    rgb_y_tab[i+B_Y_OFF] = FIX(0.11400) * i + ONE_HALF;
  }
}


/*
 * Convert RGB to grayscale.
 */

METHODDEF(void)
rgb_gray_convert (j_decompress_ptr cinfo,
		  JSAMPIMAGE input_buf, JDIMENSION input_row,
		  JSAMPARRAY output_buf, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int r, g, b;
  register INT32 * ctab = cconvert->rgb_y_tab;
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;

  while (--num_rows >= 0) {
    inptr0 = input_buf[0][input_row];
    inptr1 = input_buf[1][input_row];
    inptr2 = input_buf[2][input_row];
    input_row++;
    outptr = *output_buf++;
    for (col = 0; col < num_cols; col++) {
      r = GETJSAMPLE(inptr0[col]);
      g = GETJSAMPLE(inptr1[col]);
      b = GETJSAMPLE(inptr2[col]);
      /* Y */
      outptr[col] = (JSAMPLE)
		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
		 >> SCALEBITS);
    }
  }
}
#endif


/*
 * No colorspace change, but conversion from separate-planes
 * to interleaved representation.
 */

METHODDEF(void)
rgb_convert (j_decompress_ptr cinfo,
	     JSAMPIMAGE input_buf, JDIMENSION input_row,
	     JSAMPARRAY output_buf, int num_rows)
{
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;

  while (--num_rows >= 0) {
    inptr0 = input_buf[0][input_row];
    inptr1 = input_buf[1][input_row];
    inptr2 = input_buf[2][input_row];
    input_row++;
    outptr = *output_buf++;
    for (col = 0; col < num_cols; col++) {
      /* We can dispense with GETJSAMPLE() here */
#ifdef RISCOS /* Always &0BGR words */
      *(int *)outptr = inptr0[col] | (inptr1[col] << 8) | (inptr2[col] << 16);
#else
      outptr[RGB_RED]   = inptr0[col];
      outptr[RGB_GREEN] = inptr1[col];
      outptr[RGB_BLUE]  = inptr2[col];
#endif
      outptr += RGB_PIXELSIZE;
    }
  }
}


/*
 * Color conversion for no colorspace change: just copy the data,
 * converting from separate-planes to interleaved representation.
 */

METHODDEF(void)
null_convert (j_decompress_ptr cinfo,
	      JSAMPIMAGE input_buf, JDIMENSION input_row,
	      JSAMPARRAY output_buf, int num_rows)
{
  register JSAMPROW inptr, outptr;
  register JDIMENSION count;
  register int num_components = cinfo->num_components;
  JDIMENSION num_cols = cinfo->output_width;
  int ci;

  while (--num_rows >= 0) {
    for (ci = 0; ci < num_components; ci++) {
      inptr = input_buf[ci][input_row];
      outptr = output_buf[0] + ci;
      for (count = num_cols; count > 0; count--) {
	*outptr = *inptr++;	/* needn't bother with GETJSAMPLE() here */
	outptr += num_components;
      }
    }
    input_row++;
    output_buf++;
  }
}


/*
 * Color conversion for grayscale: just copy the data.
 * This also works for YCbCr -> grayscale conversion, in which
 * we just copy the Y (luminance) component and ignore chrominance.
 */

METHODDEF(void)
grayscale_convert (j_decompress_ptr cinfo,
		   JSAMPIMAGE input_buf, JDIMENSION input_row,
		   JSAMPARRAY output_buf, int num_rows)
{
  jcopy_sample_rows(input_buf[0], (int) input_row, output_buf, 0,
		    num_rows, cinfo->output_width);
}


#ifdef RISCOS /* No native CMYK, use crude RGB */
/*
 * Convert CMYK to RGB. This is for fast screen display, abandon
 * hope all ye hoping this integer approximation is print worthy.
 */

METHODDEF(void)
cmyk_rgb_convert (j_decompress_ptr cinfo,
		   JSAMPIMAGE input_buf, JDIMENSION input_row,
		   JSAMPARRAY output_buf, int num_rows)
{
  register int cyan, magenta, yellow, key;
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2, inptr3;
  register JDIMENSION col;

  JDIMENSION num_cols = cinfo->output_width;

  while (--num_rows >= 0) {
    inptr0 = input_buf[0][input_row];
    inptr1 = input_buf[1][input_row];
    inptr2 = input_buf[2][input_row];
    inptr3 = input_buf[3][input_row];
    input_row++;
    outptr = *output_buf++;
    for (col = 0; col < num_cols; col++) {
      key = GETJSAMPLE(inptr3[col]);
      if (key) {
        cyan    = GETJSAMPLE(inptr0[col]);
        magenta = GETJSAMPLE(inptr1[col]);
        yellow  = GETJSAMPLE(inptr2[col]);
        key++; /* 0-255 is near enough 1-256 and allows fast divide */
        *(int *)outptr = ((JSAMPLE)((cyan    * key) / 256) << 0 ) |
                         ((JSAMPLE)((magenta * key) / 256) << 8 ) |
                         ((JSAMPLE)((yellow  * key) / 256) << 16);
      } else {
        *(int *)outptr = 0;
      }
      outptr += RGB_PIXELSIZE;
    }
  }
}


/*
 * Convert YCCK to RGB. This is based on ycck_cmyk_convert()
 * and cmyk_rgb_convert() joined together.
 */

METHODDEF(void)
ycck_rgb_convert (j_decompress_ptr cinfo,
		   JSAMPIMAGE input_buf, JDIMENSION input_row,
		   JSAMPARRAY output_buf, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int y, cb, cr, cyan, magenta, yellow, key;
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2, inptr3;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
  register int * Crrtab = cconvert->Cr_r_tab;
  register int * Cbbtab = cconvert->Cb_b_tab;
  register INT32 * Crgtab = cconvert->Cr_g_tab;
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
  SHIFT_TEMPS

  while (--num_rows >= 0) {
    inptr0 = input_buf[0][input_row];
    inptr1 = input_buf[1][input_row];
    inptr2 = input_buf[2][input_row];
    inptr3 = input_buf[3][input_row];
    input_row++;
    outptr = *output_buf++;
    for (col = 0; col < num_cols; col++) {
      key = GETJSAMPLE(inptr3[col]);
      if (key) {
        y  = GETJSAMPLE(inptr0[col]);
        cb = GETJSAMPLE(inptr1[col]);
        cr = GETJSAMPLE(inptr2[col]);
        /* Range-limiting is essential due to noise introduced by DCT losses. */
        cyan    = range_limit[MAXJSAMPLE - (y + Crrtab[cr])];
        magenta = range_limit[MAXJSAMPLE - (y +
			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
						 SCALEBITS)))];
        yellow  = range_limit[MAXJSAMPLE - (y + Cbbtab[cb])];
        key++; /* 0-255 is near enough 1-256 and allows fast divide */
        *(int *)outptr = ((JSAMPLE)((cyan    * key) / 256) << 0 ) |
                         ((JSAMPLE)((magenta * key) / 256) << 8 ) |
                         ((JSAMPLE)((yellow  * key) / 256) << 16);
      } else {
        *(int *)outptr = 0;
      }
      outptr += RGB_PIXELSIZE;
    }
  }
}
#endif


/*
 * Convert grayscale to RGB: just duplicate the graylevel three times.
 * This is provided to support applications that don't want to cope
 * with grayscale as a separate case.
 */

METHODDEF(void)
gray_rgb_convert (j_decompress_ptr cinfo,
		  JSAMPIMAGE input_buf, JDIMENSION input_row,
		  JSAMPARRAY output_buf, int num_rows)
{
  register JSAMPROW inptr, outptr;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;

  while (--num_rows >= 0) {
    inptr = input_buf[0][input_row++];
    outptr = *output_buf++;
    for (col = 0; col < num_cols; col++) {
      /* We can dispense with GETJSAMPLE() here */
#ifdef RISCOS /* Always &0BGR words */
      *(int *)outptr = inptr[col] | (inptr[col] << 8) | (inptr[col] << 16);
#else
      outptr[RGB_RED] = outptr[RGB_GREEN] = outptr[RGB_BLUE] = inptr[col];
#endif
      outptr += RGB_PIXELSIZE;
    }
  }
}


#ifndef RISCOS /* Processed to RGB, unused */
/*
 * Adobe-style YCCK->CMYK conversion.
 * We convert YCbCr to R=1-C, G=1-M, and B=1-Y using the same
 * conversion as above, while passing K (black) unchanged.
 * We assume build_ycc_rgb_table has been called.
 */

METHODDEF(void)
ycck_cmyk_convert (j_decompress_ptr cinfo,
		   JSAMPIMAGE input_buf, JDIMENSION input_row,
		   JSAMPARRAY output_buf, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int y, cb, cr;
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2, inptr3;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
  register int * Crrtab = cconvert->Cr_r_tab;
  register int * Cbbtab = cconvert->Cb_b_tab;
  register INT32 * Crgtab = cconvert->Cr_g_tab;
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
  SHIFT_TEMPS

  while (--num_rows >= 0) {
    inptr0 = input_buf[0][input_row];
    inptr1 = input_buf[1][input_row];
    inptr2 = input_buf[2][input_row];
    inptr3 = input_buf[3][input_row];
    input_row++;
    outptr = *output_buf++;
    for (col = 0; col < num_cols; col++) {
      y  = GETJSAMPLE(inptr0[col]);
      cb = GETJSAMPLE(inptr1[col]);
      cr = GETJSAMPLE(inptr2[col]);
      /* Range-limiting is essential due to noise introduced by DCT losses. */
      outptr[0] = range_limit[MAXJSAMPLE - (y + Crrtab[cr])];	/* red */
      outptr[1] = range_limit[MAXJSAMPLE - (y +			/* green */
			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
						 SCALEBITS)))];
      outptr[2] = range_limit[MAXJSAMPLE - (y + Cbbtab[cb])];	/* blue */
      /* K passes through unchanged */
      outptr[3] = inptr3[col];	/* don't need GETJSAMPLE here */
      outptr += 4;
    }
  }
}
#endif


/*
 * Empty method for start_pass.
 */

METHODDEF(void)
start_pass_dcolor (j_decompress_ptr cinfo)
{
  /* no work needed */
}


/*
 * Module initialization routine for output colorspace conversion.
 */

GLOBAL(void)
jinit_color_deconverter (j_decompress_ptr cinfo)
{
  my_cconvert_ptr cconvert;
  int ci;

  cconvert = (my_cconvert_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_color_deconverter));
  cinfo->cconvert = (struct jpeg_color_deconverter *) cconvert;
  cconvert->pub.start_pass = (void (*)(j_decompress_ptr))RELOCCODE(start_pass_dcolor);

  /* Make sure num_components agrees with jpeg_color_space */
  switch (cinfo->jpeg_color_space) {
  case JCS_GRAYSCALE:
    if (cinfo->num_components != 1)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    break;

  case JCS_RGB:
  case JCS_YCbCr:
    if (cinfo->num_components != 3)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    break;

  case JCS_CMYK:
  case JCS_YCCK:
    if (cinfo->num_components != 4)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    break;

  default:			/* JCS_UNKNOWN can be anything */
    if (cinfo->num_components < 1)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    break;
  }

  /* Set out_color_components and conversion method based on requested space.
   * Also clear the component_needed flags for any unused components,
   * so that earlier pipeline stages can avoid useless computation.
   */

  switch (cinfo->out_color_space) {
#ifndef RISCOS /* Processed to RGB, unused */
  case JCS_GRAYSCALE:
    cinfo->out_color_components = 1;
    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
	cinfo->jpeg_color_space == JCS_YCbCr) {
      cconvert->pub.color_convert = grayscale_convert;
      /* For color->grayscale conversion, only the Y (0) component is needed */
      for (ci = 1; ci < cinfo->num_components; ci++)
	cinfo->comp_info[ci].component_needed = FALSE;
    } else if (cinfo->jpeg_color_space == JCS_RGB) {
      cconvert->pub.color_convert = rgb_gray_convert;
      build_rgb_y_table(cinfo);
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;
#endif

  case JCS_RGB:
    cinfo->out_color_components = RGB_PIXELSIZE;
    if (cinfo->jpeg_color_space == JCS_YCbCr) {
      cconvert->pub.color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))RELOCCODE(ycc_rgb_convert);
      build_ycc_rgb_table(cinfo);
    } else if (cinfo->jpeg_color_space == JCS_GRAYSCALE) {
      cconvert->pub.color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))RELOCCODE(gray_rgb_convert);
#ifdef RISCOS /* Speed up */
      /* For color->grayscale conversion, only the Y (0) component is needed */
      for (ci = 1; ci < cinfo->num_components; ci++)
	cinfo->comp_info[ci].component_needed = FALSE;
#endif
    } else if (cinfo->jpeg_color_space == JCS_RGB) {
      cconvert->pub.color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))RELOCCODE(rgb_convert);
#ifdef RISCOS /* No native CMYK, use crude RGB */
    } else if (cinfo->jpeg_color_space == JCS_CMYK) {
      cconvert->pub.color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))RELOCCODE(cmyk_rgb_convert);
    } else if (cinfo->jpeg_color_space == JCS_YCCK) {
      cconvert->pub.color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))RELOCCODE(ycck_rgb_convert);
      build_ycc_rgb_table(cinfo);
#endif
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

#ifndef RISCOS /* Processed to RGB, unused */
  case JCS_CMYK:
    cinfo->out_color_components = 4;
    if (cinfo->jpeg_color_space == JCS_YCCK) {
      cconvert->pub.color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))RELOCCODE(ycck_cmyk_convert);
      build_ycc_rgb_table(cinfo);
    } else if (cinfo->jpeg_color_space == JCS_CMYK) {
      cconvert->pub.color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))RELOCCODE(null_convert);
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;
#endif

  default:
    /* Permit null conversion to same output space */
    if (cinfo->out_color_space == cinfo->jpeg_color_space) {
      cinfo->out_color_components = cinfo->num_components;
      cconvert->pub.color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))RELOCCODE(null_convert);
    } else			/* unsupported non-null conversion */
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;
  }

  if (cinfo->quantize_colors)
    cinfo->output_components = 1; /* single colormapped output component */
  else
    cinfo->output_components = cinfo->out_color_components;
}
@


4.5
log
@Transcode arithmetics
Detail:
  Import of the raw coefficient Huffman entropy compressor elements of the IJG8d library.
  We don't need a full compressor (ala JCompMod) since there's never a need to go all the way through IDCT/upsampling/colour conversion only to reverse the whole process; it's sufficient only to collect up the raw coefficients and recompress them as a baseline JPEG.
  Two extra (temporary) dynamic areas are introduced, once to hold the raw coefficients and the other to act as a scratch file to make the JPEG in. See Doc/JPEGMmgr.
Admin:
  Submission for the JPEG bounty.

Version 1.72. Tagged as 'SprExtend-1_72'
@
text
@d170 1
a170 1
#ifdef RISCOS /* Always &BGR */
d188 1
d250 1
d276 3
d282 1
d368 3
a370 3
        outptr[RGB_RED] =   (JSAMPLE)((cyan    * key) / 256);
        outptr[RGB_GREEN] = (JSAMPLE)((magenta * key) / 256);
        outptr[RGB_BLUE] =  (JSAMPLE)((yellow  * key) / 256);
d372 1
a372 1
        outptr[RGB_RED] = outptr[RGB_GREEN] = outptr[RGB_BLUE] = 0;
d424 3
a426 3
        outptr[RGB_RED] =   (JSAMPLE)((cyan   *key) >> 8);
        outptr[RGB_GREEN] = (JSAMPLE)((magenta*key) >> 8);
        outptr[RGB_BLUE] =  (JSAMPLE)((yellow *key) >> 8);
d428 1
a428 1
        outptr[RGB_RED] = outptr[RGB_GREEN] = outptr[RGB_BLUE] = 0;
d457 1
a457 1
#ifdef RISCOS /* Always &BGR */
d579 1
d584 1
a584 1
      cconvert->pub.color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))RELOCCODE(grayscale_convert);
d589 1
a589 1
      cconvert->pub.color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))RELOCCODE(rgb_gray_convert);
d594 1
d603 5
@


4.4
log
@Import of IJG8d library sources
Detail:
  Using the decoder in "example.c" as a starting point, we try to follow that sequence more closely even if in our embedded implementation some of the functions don't do much.
  Uses the default colour backend for 32bpp BGR output for most of the unusual cases.
  The most common 2x2 subsampling case uses a custom merged upsampler and colour converter, with colour output directly in RISC OS format for the respective screen mode.
Admin:
  Submission for the JPEG bounty.

Version 1.71. Tagged as 'SprExtend-1_71'
@
text
@d462 1
a462 1
#ifndef RISCOS /* Save space */
d608 1
a608 1
#ifndef RISCOS /* Save space */
@


4.3
log
@Adopt colour conversions from MigrateIJG8b branch
Now for every colour conversion there is a corresponding C function, allowing swapping between them for test purposes.
Here, 'ASMCOLOR' is selected and the C functions not even referenced in the makefile, see branch for use.
Permits use of USAT, for a small 1.5% speedup and smaller code.
Some other typedefs and comment shuffling copied over - should be harmless.

Version 1.50. Tagged as 'SprExtend-1_50'
@
text
@d1 10
a15 1
#ifndef ASMCOLOR
d17 1
a17 3
#define SCALEBITS       19
#define ONE_HALF        ((INT32) 1 << (SCALEBITS - 1))
#define FIX(x)          ((INT32) ((x) * (1L<<SCALEBITS) + 0.5))
d19 2
a20 5
/*****************************************************************************
*                                                                            *
*   Monochrome colour conversion                                             *
*                                                                            *
*****************************************************************************/
d22 45
a66 3
int mono_convert_pixel(int pix)
/* Just do a single pixel - eg. for DC-only display. The pixel does not have to
 * be shifted down, as it has not gone through the DCT.
a67 2
{
  int y = pix;
d69 16
a84 6
  y = ((y + 4) >> 3) + 128;      /* normalise */
  if (y < 0) y = 0;              /* range check */
  if (y > 255) y = 255;
  
  return y | (y << 8) | (y << 16); /* replicate Y value */
}
d86 2
a87 4
void mono_convert_pixels(int *y)
/* Convert four pixels. Input y values are in y[0..3], put output there too.
 * Used for DC-only mono output. The input pixels do not have to be shifted
 * down by 19, as they have not been through the DCT.
d89 3
d93 1
d95 2
a96 1
  int yy;
d98 27
a124 5
  for (i = 0; i < 4; i++)
  {
    yy = ((y[i] + 4) >> 3) + 128;
    if (yy < 0) yy = 0; if (yy > 255) yy = 255;
    y[i] = yy | (yy << 8) | (yy << 16);
d128 16
a143 2
void mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset)
/* Convert greyscale image into 8bit Grey values. */
d145 41
a185 2
  int i, j;
  char *pixel;
a186 6
  for (j = 0; j < 8; j++)
  {
    pixel = (char *)outptr;
    for (i = 0; i < 8; i++)
    {
      int y;
d188 1
a188 2
      y = jblock[j + i*8];             /* extract, NB in row order */
      y = (y + ONE_HALF) >> SCALEBITS; /* descale */
a189 3
      y += 128;                        /* normalise */
      if (y < 0) y = 0;                /* clip */
      if (y > 255) y = 255;            
d191 20
a210 3
      pixel[i] = y;                    /* store the pixel value */
    }
    outptr += outoffset;
d214 9
a222 2
void mono_convert_block(JBLOCK jblock, int *outptr, int outoffset)
/* Convert greyscale image into 32bit RGB values. */
d224 25
a248 1
  int i, j;
a249 5
  for (j = 0; j < 8; j++)
  {
    for (i = 0; i < 8; i++)
    {
      int y;
d251 4
a254 2
      y = jblock[j + i*8];             /* extract, NB in row order */
      y = (y + ONE_HALF) >> SCALEBITS; /* descale */
d256 22
a277 5
      y += 128;                        /* normalise */
      if (y < 0) y = 0;                /* clip */
      if (y > 255) y = 255;
      y = y | (y << 8) | (y << 16);    /* construct RGB value */
      outptr[i] = y;
a278 1
    outptr += outoffset;
d282 24
a305 45
/*****************************************************************************
*                                                                            *
*   YUV->RGB colour conversion.                                              *
*                                                                            *
*****************************************************************************/

void colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset, int wide, int high)
/* yuv[0..1] are Y, yuv[4] is U, yuv[5] is V. wide/high are 1 or 2.
 * Both being 2 is the most common case, for which we use hand-coded assembler instead.
 */
{
  int i, j;
  JCOEF *by0 = yuv + 0*DCTSIZE2;
  JCOEF *by1 = yuv + 1*DCTSIZE2;
  JCOEF *bu =  yuv + 4*DCTSIZE2;
  JCOEF *bv =  yuv + 5*DCTSIZE2;

  for (j = 0; j < 8*high; j++)
  {
    for (i = 0; i < 8*wide; i++)
    {
      int y;
      int u;
      int v;

      /* Simplification because we don't use this code in the 2x2 case, so
       * we only need to worry about accessing a second block. */

      y = ((i < 8 && j < 8) ? by0 : by1)[(j&7) + (i&7)*8]; /* extract from right block, NB row order */
      u = bu[(j>>(high-1)) + (i>>(wide-1))*8];
      v = bv[(j>>(high-1)) + (i>>(wide-1))*8];

      y = (y + ONE_HALF) >> SCALEBITS;     /* descale */
      y += 128;                            /* normalise */
      u = (u + ONE_HALF) >> SCALEBITS;
      v = (v + ONE_HALF) >> SCALEBITS;
      {
        int r =                        v * FIX(1.40200);
        int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
        int b =     u * FIX(1.77200);

        r += ONE_HALF; r >>= SCALEBITS; r += y; if (r < 0) r = 0; if (r > 255) r = 255;
        g += ONE_HALF; g >>= SCALEBITS; g += y; if (g < 0) g = 0; if (g > 255) g = 255;
        b += ONE_HALF; b >>= SCALEBITS; b += y; if (b < 0) b = 0; if (b > 255) b = 255;
        outptr[i] = r | (g << 8) | (b << 16);
d308 2
a309 1
    outptr += outoffset;
d313 56
a368 26
void colour_convert_pixels(int *y, int u, int v)
/* Convert four pixels. Input y values are in y[0..3], put output there too.
 * Used for DC-only colour output. The input pixels do not have to be shifted
 * down by SCALEBITS, as they have not been through the DCT.
 */
{
  u = (u + 4) >> 3; /* descale */
  v = (v + 4) >> 3;

  {
    int r =                        v * FIX(1.40200);
    int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
    int b =     u * FIX(1.77200);
    int i;
    int rr, gg, bb, yy;

    r += ONE_HALF; r >>= SCALEBITS;
    g += ONE_HALF; g >>= SCALEBITS;
    b += ONE_HALF; b >>= SCALEBITS;
    for (i = 0; i < 4; i++)
    {
      yy = ((y[i] + 4) >> 3) + 128;
      rr = r + yy; if (rr < 0) rr = 0; if (rr > 255) rr = 255;
      gg = g + yy; if (gg < 0) gg = 0; if (gg > 255) gg = 255;
      bb = b + yy; if (bb < 0) bb = 0; if (bb > 255) bb = 255;
      y[i] = rr | (gg << 8) | (bb << 16);
d373 10
a382 2
void colour_convert_block_16(JCOEF *yuv, short *outptr, int outoffset)
/* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block of 16bit pixels */
d384 39
a422 47
  int i, j;
  JCOEF *by0 = yuv + 0*DCTSIZE2;
  JCOEF *by1 = yuv + 1*DCTSIZE2;
  JCOEF *by2 = yuv + 2*DCTSIZE2;
  JCOEF *by3 = yuv + 3*DCTSIZE2;
  JCOEF *bu =  yuv + 4*DCTSIZE2;
  JCOEF *bv =  yuv + 5*DCTSIZE2;
  int *words = (int *)outptr;
  unsigned int pair = 0;

  for (j = 0; j < 16; j++)
  {
    for (i = 0; i < 16; i++)
    {
      int  y, u, v;
      char dither[4];

#if 1
      dither[0] = 2; dither[1] = 6;
      dither[2] = 4; dither[3] = 0;
#else
      dither[0] = dither[1] = dither[2] = dither[3] = 3; /* no dither */
#endif

      y = (j < 8 ? (i < 8 ? by0 : by1) : (i < 8 ? by2 : by3))[(j&7) + (i&7)*8]; /* extract from right block, NB row order */
      u = bu[(j>>1) + (i>>1)*8];
      v = bv[(j>>1) + (i>>1)*8];

      y += (dither[((j&1)*2) + (i&1)]<<SCALEBITS);
      y += (125<<SCALEBITS); /* + mean of 3 contributed by dither */
      y += (ONE_HALF<<3);
      u = (u + ONE_HALF) >> SCALEBITS;
      v = (v + ONE_HALF) >> SCALEBITS;
      {
        int r =                        v * FIX(1.40200);
        int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
        int b =     u * FIX(1.77200);

        r += y; r >>= (SCALEBITS+3); if (r < 0) r = 0; if (r > 31) r = 31;
        g += y; g >>= (SCALEBITS+3); if (g < 0) g = 0; if (g > 31) g = 31;
        b += y; b >>= (SCALEBITS+3); if (b < 0) b = 0; if (b > 31) b = 31;
        pair = (pair >> 16) | ((r | (g << 5) | (b << 10)) << 16);
        if (i & 1)
        {
          words[i>>1] = pair;
          pair = 0;
        }
d424 1
a425 1
    words += outoffset;
d428 1
d430 11
a440 2
void colour_convert_block_8(JCOEF *yuv, char *outptr, int outoffset)
/* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block of 8bit pixels */
d442 11
a452 44
  int i, j;
  JCOEF *by0 = yuv + 0*DCTSIZE2;
  JCOEF *by1 = yuv + 1*DCTSIZE2;
  JCOEF *by2 = yuv + 2*DCTSIZE2;
  JCOEF *by3 = yuv + 3*DCTSIZE2;
  JCOEF *bu =  yuv + 4*DCTSIZE2;
  JCOEF *bv =  yuv + 5*DCTSIZE2;
  int erry, erru, errv;
  extern int *pixel_to_yuv_table_base(void); /* relocation without CMHG */
  extern char *yuv_to_pixel_table_base(void); /* relocation without CMHG */
  const int *pixel_to_yuv_table = pixel_to_yuv_table_base();
  const char *yuv_to_pixel_table = yuv_to_pixel_table_base();

  for (j = 0; j < 8; j++) /* count row pairs output */
  {
    erry = erru = errv = 0; /* new row, wipe the cumulative errors */

    for (i = 0; i < 32; i++) /* count pixels output */
    {
      int  y, u, v;
      char p = i & 3; /* do pixels in 2x2 squares */
      char colour;

      /* 'n' shaped source access, extract from right block, NB row order */
      y = (j < 4 ? (i < 16 ? by0 : by1) : (i < 16 ? by2 : by3))[((j<<1)&7) + (((p - 1)&2)>>1) + (((i&15)>>1)*8)];
      u = bu[j + (i>>2)*8];
      v = bv[j + (i>>2)*8];

      y = (y + (128<<SCALEBITS)) >> SCALEBITS; /* descale */
      u = (u + (128<<SCALEBITS)) >> SCALEBITS;
      v = (v + (128<<SCALEBITS)) >> SCALEBITS;

      /* Mix in the errors and clamp */
      y += erry; if (y < 0) y = 0; if (y > 255) y = 255;
      u += erru; if (u < 0) u = 0; if (u > 255) u = 255;
      v += errv; if (v < 0) v = 0; if (v > 255) v = 255;

      /* Combine Y:U:V in the ratio 5:4:4, and use as an index
       * into the YUV->pixel table
       */
#if 1
      colour = yuv_to_pixel_table[((y & 0xF8) << 5) |
                                   (u & 0xF0) |
                                  ((v & 0xF0) >> 4)];
d454 1
a454 1
      colour = i + (j * 32); /* test of patterning */
d456 1
a456 15
      /* Reduce patterning by doing a 'n' shaped dance
       *   [ p=1  p=2 ]
       *   [ p=0  p=3 ]
       * which is a 'u' shape when the origin is in the BLHC
       */
      outptr[((p & 2) >> 1) +
             (((p - 1) & 2) ? (outoffset * sizeof(int)) : 0)] = colour;

      /* Lookup backwards to calculate the error term */
      erry = y - ((pixel_to_yuv_table[colour] >> 16) & 0xFF);
      erru = u - ((pixel_to_yuv_table[colour] >> 8) & 0xFF);
      errv = v - ((pixel_to_yuv_table[colour] >> 0) & 0xFF);

      /* Next output pair on this row */
      if (p == 3) outptr += 2;
a457 3

    /* Start on the left 2 rows down */
    outptr += (outoffset * sizeof(int) * 2) - (DCTSIZE * 2);
d461 13
a473 2
void colour_convert_block_32(JCOEF *yuv, int *outptr, int outoffset)
/* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block */
d475 34
a508 32
  int i, j;
  JCOEF *by0 = yuv + 0*DCTSIZE2;
  JCOEF *by1 = yuv + 1*DCTSIZE2;
  JCOEF *by2 = yuv + 2*DCTSIZE2;
  JCOEF *by3 = yuv + 3*DCTSIZE2;
  JCOEF *bu =  yuv + 4*DCTSIZE2;
  JCOEF *bv =  yuv + 5*DCTSIZE2;

  for (j = 0; j < 16; j++)
  {
    for (i = 0; i < 16; i++)
    {
      int y, u, v;

      y = (j < 8 ? (i < 8 ? by0 : by1) : (i < 8 ? by2 : by3))[(j&7) + (i&7)*8]; /* extract from right block, NB row order */
      u = bu[(j>>1) + (i>>1)*8];
      v = bv[(j>>1) + (i>>1)*8];

      y = (y + ONE_HALF) >> SCALEBITS;     /* descale */
      y += 128;                            /* normalise */
      u = (u + ONE_HALF) >> SCALEBITS;
      v = (v + ONE_HALF) >> SCALEBITS;
      {
        int r =                        v * FIX(1.40200);
        int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
        int b =     u * FIX(1.77200);

        r += ONE_HALF; r >>= SCALEBITS; r += y; if (r < 0) r = 0; if (r > 255) r = 255;
        g += ONE_HALF; g >>= SCALEBITS; g += y; if (g < 0) g = 0; if (g > 255) g = 255;
        b += ONE_HALF; b >>= SCALEBITS; b += y; if (b < 0) b = 0; if (b > 255) b = 255;
        outptr[i] = r | (g << 8) | (b << 16);
      }
a509 1
    outptr += outoffset;
d512 17
d530 89
d620 16
@


4.2
log
@Retire unused IJG version 4 files.
Fold RISC OS specific colour conversion routines into rojpeg.
Remove jcconv, this also highlighted there were some more unused functions.
Should make move to IJG version 8 even easier.

Version 1.38. Tagged as 'SprExtend-1_38'
@
text
@a0 11
/*
 * jdcolor.c
 *
 * Copyright (C) 1991, 1992, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains output colorspace conversion routines.
 * These routines are invoked via the methods color_convert
 * and colorout_init/term.
 */
d2 1
d4 1
d6 1
d8 3
a10 1
/**************** YCbCr -> RGB conversion: most common case **************/
d12 9
a20 25
/*
 * YCbCr is defined per CCIR 601-1, except that Cb and Cr are
 * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
 * The conversion equations to be implemented are therefore
 *      R = Y                + 1.40200 * Cr
 *      G = Y - 0.34414 * Cb - 0.71414 * Cr
 *      B = Y + 1.77200 * Cb
 * where Cb and Cr represent the incoming values less MAXJSAMPLE/2.
 * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
 *
 * To avoid floating-point arithmetic, we represent the fractional constants
 * as integers scaled up by 2^16 (about 4 digits precision); we have to divide
 * the products by 2^16, with appropriate rounding, to get the correct answer.
 * Notice that Y, being an integral input, does not contribute any fraction
 * so it need not participate in the rounding.
 *
 * For even more speed, we avoid doing any multiplications in the inner loop
 * by precalculating the constants times Cb and Cr for all possible values.
 * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
 * for 12-bit samples it is still acceptable.  It's not very reasonable for
 * 16-bit samples, but if you want lossless storage you shouldn't be changing
 * colorspace anyway.
 * The Cr=>R and Cb=>B values can be rounded to integers in advance; the
 * values for the G calculation are left scaled up, since we must add them
 * together before rounding.
d22 2
d25 6
a30 7
#ifdef SIXTEEN_BIT_SAMPLES
#define SCALEBITS       14      /* avoid overflow */
#else
#define SCALEBITS       16      /* speedier right-shift on some machines */
#endif
#define ONE_HALF        ((INT32) 1 << (SCALEBITS-1))
#define FIX(x)          ((INT32) ((x) * (1L<<SCALEBITS) + 0.5))
d32 4
a35 8
static int * Cr_r_tab;          /* => table for Cr to R conversion */
static int * Cb_b_tab;          /* => table for Cb to B conversion */
static INT32 * Cr_g_tab;        /* => table for Cr to G conversion */
static INT32 * Cb_g_tab;        /* => table for Cb to G conversion */


/*
 * Initialize for colorspace conversion.
a36 3

METHODDEF void
ycc_rgb_init (decompress_info_ptr cinfo)
d38 2
a39 2
  INT32 i, x2;
  SHIFT_TEMPS
d41 5
a45 24
  Cr_r_tab = (int *) (*cinfo->emethods->alloc_small)
                                ((MAXJSAMPLE+1) * SIZEOF(int));
  Cb_b_tab = (int *) (*cinfo->emethods->alloc_small)
                                ((MAXJSAMPLE+1) * SIZEOF(int));
  Cr_g_tab = (INT32 *) (*cinfo->emethods->alloc_small)
                                ((MAXJSAMPLE+1) * SIZEOF(INT32));
  Cb_g_tab = (INT32 *) (*cinfo->emethods->alloc_small)
                                ((MAXJSAMPLE+1) * SIZEOF(INT32));

  for (i = 0; i <= MAXJSAMPLE; i++) {
    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
    /* The Cb or Cr value we are thinking of is x = i - MAXJSAMPLE/2 */
    x2 = 2*i - MAXJSAMPLE;      /* twice x */
    /* Cr=>R value is nearest int to 1.40200 * x */
    Cr_r_tab[i] = (int)
                    RIGHT_SHIFT(FIX(1.40200/2) * x2 + ONE_HALF, SCALEBITS);
    /* Cb=>B value is nearest int to 1.77200 * x */
    Cb_b_tab[i] = (int)
                    RIGHT_SHIFT(FIX(1.77200/2) * x2 + ONE_HALF, SCALEBITS);
    /* Cr=>G value is scaled-up -0.71414 * x */
    Cr_g_tab[i] = (- FIX(0.71414/2)) * x2;
    /* Cb=>G value is scaled-up -0.34414 * x */
    /* We also add in ONE_HALF so that need not do it in inner loop */
    Cb_g_tab[i] = (- FIX(0.34414/2)) * x2 + ONE_HALF;
d49 5
d55 13
a67 3
/*
 * Convert some rows of samples to the output colorspace.
 */
d69 1
a69 42
METHODDEF void
ycc_rgb_convert (decompress_info_ptr cinfo, int num_rows, long num_cols,
                 JSAMPIMAGE input_data, JSAMPIMAGE output_data)
{
#ifdef SIXTEEN_BIT_SAMPLES
  register INT32 y;
  register UINT16 cb, cr;
#else
  register int y, cb, cr;
#endif
  register JSAMPROW inptr0, inptr1, inptr2;
  register JSAMPROW outptr0, outptr1, outptr2;
  register long col;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
  register int * Crrtab = Cr_r_tab;
  register int * Cbbtab = Cb_b_tab;
  register INT32 * Crgtab = Cr_g_tab;
  register INT32 * Cbgtab = Cb_g_tab;
  int row;
  SHIFT_TEMPS
  
  for (row = 0; row < num_rows; row++) {
    inptr0 = input_data[0][row];
    inptr1 = input_data[1][row];
    inptr2 = input_data[2][row];
    outptr0 = output_data[0][row];
    outptr1 = output_data[1][row];
    outptr2 = output_data[2][row];
    for (col = 0; col < num_cols; col++) {
      y  = GETJSAMPLE(inptr0[col]);
      cb = GETJSAMPLE(inptr1[col]);
      cr = GETJSAMPLE(inptr2[col]);
      /* Note: if the inputs were computed directly from RGB values,
       * range-limiting would be unnecessary here; but due to possible
       * noise in the DCT/IDCT phase, we do need to apply range limits.
       */
      outptr0[col] = range_limit[y + Crrtab[cr]];       /* red */
      outptr1[col] = range_limit[y +                    /* green */
                                 ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
                                                    SCALEBITS))];
      outptr2[col] = range_limit[y + Cbbtab[cb]];       /* blue */
d71 1
d75 4
d80 17
a96 8
/*
 * Finish up at the end of the file.
 */

METHODDEF void
ycc_rgb_term (decompress_info_ptr cinfo)
{
  /* no work (we let free_all release the workspace) */
d99 9
a107 6

/**************** Cases other than YCbCr -> RGB **************/


/*
 * Initialize for colorspace conversion.
a108 4

METHODDEF void
null_init (decompress_info_ptr cinfo)
/* colorout_init for cases where no setup is needed */
d110 38
a147 1
  /* no work needed */
d150 4
a153 3

/*
 * Color conversion for no colorspace change: just copy the data.
a154 4

METHODDEF void
null_convert (decompress_info_ptr cinfo, int num_rows, long num_cols,
              JSAMPIMAGE input_data, JSAMPIMAGE output_data)
d156 2
a157 1
  short ci;
d159 18
a176 3
  for (ci = 0; ci < cinfo->num_components; ci++) {
    jcopy_sample_rows(input_data[ci], 0, output_data[ci], 0,
                      num_rows, num_cols);
d180 26
d207 27
a233 12
/*
 * Color conversion for grayscale: just copy the data.
 * This also works for YCbCr/YIQ -> grayscale conversion, in which
 * we just copy the Y (luminance) component and ignore chrominance.
 */

METHODDEF void
grayscale_convert (decompress_info_ptr cinfo, int num_rows, long num_cols,
                   JSAMPIMAGE input_data, JSAMPIMAGE output_data)
{
  jcopy_sample_rows(input_data[0], 0, output_data[0], 0,
                    num_rows, num_cols);
d236 2
a237 8

/*
 * Finish up at the end of the file.
 */

METHODDEF void
null_term (decompress_info_ptr cinfo)
/* colorout_term for cases where no teardown is needed */
d239 36
a274 2
  /* no work needed */
}
d276 17
d294 4
d299 3
a301 3
/*
 * The method selection routine for output colorspace conversion.
 */
d303 2
a304 25
GLOBAL void
jseldcolor (decompress_info_ptr cinfo)
{
  /* Make sure num_components agrees with jpeg_color_space */
  switch (cinfo->jpeg_color_space) {
  case CS_GRAYSCALE:
    if (cinfo->num_components != 1)
      ERREXIT(cinfo->emethods, "Bogus JPEG colorspace");
    break;

  case CS_RGB:
  case CS_YCbCr:
  case CS_YIQ:
    if (cinfo->num_components != 3)
      ERREXIT(cinfo->emethods, "Bogus JPEG colorspace");
    break;

  case CS_CMYK:
    if (cinfo->num_components != 4)
      ERREXIT(cinfo->emethods, "Bogus JPEG colorspace");
    break;

  default:
    ERREXIT(cinfo->emethods, "Unsupported JPEG colorspace");
    break;
d306 1
d308 37
a344 38
  /* Set color_out_comps and conversion method based on requested space */
  switch (cinfo->out_color_space) {
  case CS_GRAYSCALE:
    cinfo->color_out_comps = 1;
    if (cinfo->jpeg_color_space == CS_GRAYSCALE ||
        cinfo->jpeg_color_space == CS_YCbCr ||
        cinfo->jpeg_color_space == CS_YIQ) {
      cinfo->methods->color_convert = grayscale_convert;
      cinfo->methods->colorout_init = null_init;
      cinfo->methods->colorout_term = null_term;
    } else
      ERREXIT(cinfo->emethods, "Unsupported color conversion request");
    break;

  case CS_RGB:
    cinfo->color_out_comps = 3;
    if (cinfo->jpeg_color_space == CS_YCbCr) {
      cinfo->methods->color_convert = ycc_rgb_convert;
      cinfo->methods->colorout_init = ycc_rgb_init;
      cinfo->methods->colorout_term = ycc_rgb_term;
    } else if (cinfo->jpeg_color_space == CS_RGB) {
      cinfo->methods->color_convert = null_convert;
      cinfo->methods->colorout_init = null_init;
      cinfo->methods->colorout_term = null_term;
    } else
      ERREXIT(cinfo->emethods, "Unsupported color conversion request");
    break;

  default:
    /* Permit null conversion from CMYK or YCbCr to same output space */
    if (cinfo->out_color_space == cinfo->jpeg_color_space) {
      cinfo->color_out_comps = cinfo->num_components;
      cinfo->methods->color_convert = null_convert;
      cinfo->methods->colorout_init = null_init;
      cinfo->methods->colorout_term = null_term;
    } else                      /* unsupported non-null conversion */
      ERREXIT(cinfo->emethods, "Unsupported color conversion request");
    break;
d346 1
d348 1
a348 5
  if (cinfo->quantize_colors)
    cinfo->final_out_comps = 1; /* single colormapped output component */
  else
    cinfo->final_out_comps = cinfo->color_out_comps;
}
@


4.2.2.1
log
@file jdcolor was added on branch MigrateIJG8b on 2011-01-09 10:42:59 +0000
@
text
@d1 294
@


4.2.2.2
log
@Create assembler equivalents of C colour conversions, approx 10% speed up.
Add new switch ASMCOLOR to select which to use, C or assembler.
Remove FILE_ exit trace concept, just use __FILE__ instead in exit_erl.
Add some comments to exit_erl and friends.
A few bits of cinfo setup moved into start_pass_huff_decoder() or eliminated.
Bumped up the precision of SCALE_BITS in the C colour handling so FIX() uses more bits of an int.
Deleted the unused remenants of light dithering in the 8bpp colour converter - saves a few cycles.
colour_convert_8 and colour_convert_16 no longer save entry registers the C compiler doesn't care about.
Update genyuvtabs to EXPORT the table bases.
Split out the compilation of IJG files as separate objects in the make file, rather than including them from within rojpeg, which is itself included from putscaled.

Version 1.38, 1.35.2.6. Tagged as 'SprExtend-1_38-1_35_2_6'
@
text
@a0 234

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"

#ifndef ASMCOLOR

#define SCALEBITS       19
#define ONE_HALF        ((INT32) 1 << (SCALEBITS - 1))
#define FIX(x)          ((INT32) ((x) * (1L<<SCALEBITS) + 0.5))

/*****************************************************************************
*                                                                            *
*   Monochrome colour conversion                                             *
*                                                                            *
*****************************************************************************/

int mono_convert_pixel(int pix)
/* Just do a single pixel - eg. for DC-only display. The pixel does not have to
 * be shifted down, as it has not gone through the DCT.
 */
{
  int y = pix;

  y += 128;                      /* normalise */
  if (y < 0) y = 0;              /* range check */
  if (y > 255) y = 255;
  
  return y | (y << 8) | (y << 16); /* replicate Y value */
}

void mono_convert_pixels(int *y)
/* Convert four pixels. Input y values are in y[0..3], put output there too.
 * Used for DC-only mono output. The input pixels do not have to be shifted
 * down by 19, as they have not been through the DCT.
 */
{
  int i;
  int yy;

  for (i = 0; i < 4; i++)
  {
    yy = ((y[i] + 4) >> 3) + 128;
    if (yy < 0) yy = 0; if (yy > 255) yy = 255;
    y[i] = yy | (yy << 8) | (yy << 16);
  }
}

void mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset)
/* Convert greyscale image into 8bit Grey values. */
{
  int i, j;
  char *pixel;

  for (j = 0; j < 8; j++)
  {
    pixel = (char *)outptr;
    for (i = 0; i < 8; i++)
    {
      int y;

      y = jblock[j + i*8];             /* extract, NB in row order */
      y = (y + ONE_HALF) >> SCALEBITS; /* descale */

      y += 128;                        /* normalise */
      if (y < 0) y = 0;                /* clip */
      if (y > 255) y = 255;            

      pixel[i] = y;                    /* store the pixel value */
    }
    outptr += outoffset;
  }
}

void mono_convert_block(JBLOCK jblock, int *outptr, int outoffset)
/* Convert greyscale image into 32bit RGB values. */
{
  int i, j;

  for (j = 0; j < 8; j++)
  {
    for (i = 0; i < 8; i++)
    {
      int y;

      y = jblock[j + i*8];             /* extract, NB in row order */
      y = (y + ONE_HALF) >> SCALEBITS; /* descale */

      y += 128;                        /* normalise */
      if (y < 0) y = 0;                /* clip */
      if (y > 255) y = 255;
      y = y | (y << 8) | (y << 16);    /* construct RGB value */
      outptr[i] = y;
    }
    outptr += outoffset;
  }
}

/*****************************************************************************
*                                                                            *
*   YUV->RGB colour conversion.                                              *
*                                                                            *
*****************************************************************************/

void colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset, int wide, int high)
/* yuv[0..1] are Y, yuv[4] is U, yuv[5] is V. wide/high are 1 or 2.
 * Both being 2 is the most common case, for which we use hand-coded assembler instead.
 */
{
  int i, j;
  JCOEF *by0 = yuv + 0*DCTSIZE2;
  JCOEF *by1 = yuv + 1*DCTSIZE2;
  JCOEF *bu =  yuv + 4*DCTSIZE2;
  JCOEF *bv =  yuv + 5*DCTSIZE2;

  for (j = 0; j < 8*high; j++)
  {
    for (i = 0; i < 8*wide; i++)
    {
      int y;
      int u;
      int v;

      /* Simplification because we don't use this code in the 2x2 case, so
       * we only need to worry about accessing a second block. */

      y = ((i < 8 && j < 8) ? by0 : by1)[(j&7) + (i&7)*8]; /* extract from right block, NB row order */
      u = bu[(j>>(high-1)) + (i>>(wide-1))*8];
      v = bv[(j>>(high-1)) + (i>>(wide-1))*8];

      y = (y + ONE_HALF) >> SCALEBITS;     /* descale */
      y += 128;                            /* normalise */
      u = (u + ONE_HALF) >> SCALEBITS;
      v = (v + ONE_HALF) >> SCALEBITS;
      {
        int r =                        v * FIX(1.40200);
        int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
        int b =     u * FIX(1.77200);

        r += ONE_HALF; r >>= SCALEBITS; r += y; if (r < 0) r = 0; if (r > 255) r = 255;
        g += ONE_HALF; g >>= SCALEBITS; g += y; if (g < 0) g = 0; if (g > 255) g = 255;
        b += ONE_HALF; b >>= SCALEBITS; b += y; if (b < 0) b = 0; if (b > 255) b = 255;
        outptr[i] = r | (g << 8) | (b << 16);
      }
    }
    outptr += outoffset;
  }
}

void colour_convert_pixels(int *y, int u, int v)
/* Convert four pixels. Input y values are in y[0..3], put output there too.
 * Used for DC-only colour output. The input pixels do not have to be shifted
 * down by SCALEBITS, as they have not been through the DCT.
 */
{
  u = (u + 4) >> 3; /* descale */
  v = (v + 4) >> 3;

  {
    int r =                        v * FIX(1.40200);
    int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
    int b =     u * FIX(1.77200);
    int i;
    int rr, gg, bb, yy;

    r += ONE_HALF; r >>= SCALEBITS;
    g += ONE_HALF; g >>= SCALEBITS;
    b += ONE_HALF; b >>= SCALEBITS;
    for (i = 0; i < 4; i++)
    {
      yy = ((y[i] + 4) >> 3) + 128;
      rr = r + yy; if (rr < 0) rr = 0; if (rr > 255) rr = 255;
      gg = g + yy; if (gg < 0) gg = 0; if (gg > 255) gg = 255;
      bb = b + yy; if (bb < 0) bb = 0; if (bb > 255) bb = 255;
      y[i] = rr | (gg << 8) | (bb << 16);
    }
  }
}

void colour_convert_block_16(JCOEF *yuv, short *outptr, int outoffset)
/* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block of 16bit pixels */
{
  asm_colour_convert_block_16(yuv, outptr, outoffset);
}

void colour_convert_block_8(JCOEF *yuv, char *outptr, int outoffset)
/* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block of 8bit pixels */
{
  asm_colour_convert_block_8(yuv, outptr, outoffset);
}

void colour_convert_block(JCOEF *yuv, int *outptr, int outoffset)
/* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block */
{
  int i, j;
  JCOEF *by0 = yuv + 0*DCTSIZE2;
  JCOEF *by1 = yuv + 1*DCTSIZE2;
  JCOEF *by2 = yuv + 2*DCTSIZE2;
  JCOEF *by3 = yuv + 3*DCTSIZE2;
  JCOEF *bu =  yuv + 4*DCTSIZE2;
  JCOEF *bv =  yuv + 5*DCTSIZE2;

  for (j = 0; j < 16; j++)
  {
    for (i = 0; i < 16; i++)
    {
      int y;
      int u;
      int v;

      y = (j < 8 ? (i < 8 ? by0 : by1) : (i < 8 ? by2 : by3))[(j&7) + (i&7)*8]; /* extract from right block, NB row order */
      u = bu[(j>>1) + (i>>1)*8];
      v = bv[(j>>1) + (i>>1)*8];

      y = (y + ONE_HALF) >> SCALEBITS;     /* descale */
      y += 128;                            /* normalise */
      u = (u + ONE_HALF) >> SCALEBITS;
      v = (v + ONE_HALF) >> SCALEBITS;
      {
        int r =                        v * FIX(1.40200);
        int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
        int b =     u * FIX(1.77200);

        r += ONE_HALF; r >>= SCALEBITS; r += y; if (r < 0) r = 0; if (r > 255) r = 255;
        g += ONE_HALF; g >>= SCALEBITS; g += y; if (g < 0) g = 0; if (g > 255) g = 255;
        b += ONE_HALF; b >>= SCALEBITS; b += y; if (b < 0) b = 0; if (b > 255) b = 255;
        outptr[i] = r | (g << 8) | (b << 16);
      }
    }
    outptr += outoffset;
  }
}

#endif
@


4.2.2.3
log
@For completeness, implement the 2x2->8bpp and 2x2->16bpp colour conversions in C too.
While slower than their assembler equivalents it makes the whacky address generation a bit easier to follow.
Fix MakeFile to not stop when trying to deleted an empty directory.

Version 1.38, 1.35.2.7. Tagged as 'SprExtend-1_38-1_35_2_7'
@
text
@d183 1
a183 51
  int i, j;
  JCOEF *by0 = yuv + 0*DCTSIZE2;
  JCOEF *by1 = yuv + 1*DCTSIZE2;
  JCOEF *by2 = yuv + 2*DCTSIZE2;
  JCOEF *by3 = yuv + 3*DCTSIZE2;
  JCOEF *bu =  yuv + 4*DCTSIZE2;
  JCOEF *bv =  yuv + 5*DCTSIZE2;
  int *words = (int *)outptr;
  unsigned int pair = 0;

  for (j = 0; j < 16; j++)
  {
    for (i = 0; i < 16; i++)
    {
      int  y, u, v;
      char dither[4];

#if 1
      dither[0] = 2; dither[1] = 6;
      dither[2] = 4; dither[3] = 0;
#else
      dither[0] = dither[1] = dither[2] = dither[3] = 3; /* no dither */
#endif

      y = (j < 8 ? (i < 8 ? by0 : by1) : (i < 8 ? by2 : by3))[(j&7) + (i&7)*8]; /* extract from right block, NB row order */
      u = bu[(j>>1) + (i>>1)*8];
      v = bv[(j>>1) + (i>>1)*8];

      y += (dither[((j&1)*2) + (i&1)]<<SCALEBITS);
      y += (125<<SCALEBITS); /* + mean of 3 contributed by dither */
      y += (ONE_HALF<<3);
      u = (u + ONE_HALF) >> SCALEBITS;
      v = (v + ONE_HALF) >> SCALEBITS;
      {
        int r =                        v * FIX(1.40200);
        int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
        int b =     u * FIX(1.77200);

        r += y; r >>= (SCALEBITS+3); if (r < 0) r = 0; if (r > 31) r = 31;
        g += y; g >>= (SCALEBITS+3); if (g < 0) g = 0; if (g > 31) g = 31;
        b += y; b >>= (SCALEBITS+3); if (b < 0) b = 0; if (b > 31) b = 31;
        pair = (pair >> 16) | ((r | (g << 5) | (b << 10)) << 16);
        if (i & 1)
        {
          words[i>>1] = pair;
          pair = 0;
        }
      }
    }
    words += outoffset;
  }
d189 1
a189 67
  int i, j;
  JCOEF *by0 = yuv + 0*DCTSIZE2;
  JCOEF *by1 = yuv + 1*DCTSIZE2;
  JCOEF *by2 = yuv + 2*DCTSIZE2;
  JCOEF *by3 = yuv + 3*DCTSIZE2;
  JCOEF *bu =  yuv + 4*DCTSIZE2;
  JCOEF *bv =  yuv + 5*DCTSIZE2;
  int erry, erru, errv;
  extern int *pixel_to_yuv_table_base(void); /* relocation without CMHG */
  extern char *yuv_to_pixel_table_base(void); /* relocation without CMHG */
  const int *pixel_to_yuv_table = pixel_to_yuv_table_base();
  const char *yuv_to_pixel_table = yuv_to_pixel_table_base();

  for (j = 0; j < 8; j++) /* count row pairs output */
  {
    erry = erru = errv = 0; /* new row, wipe the cumulative errors */

    for (i = 0; i < 32; i++) /* count pixels output */
    {
      int  y, u, v;
      char p = i & 3; /* do pixels in 2x2 squares */
      char colour;

      /* 'n' shaped source access, extract from right block, NB row order */
      y = (j < 4 ? (i < 16 ? by0 : by1) : (i < 16 ? by2 : by3))[((j<<1)&7) + (((p - 1)&2)>>1) + (((i&15)>>1)*8)];
      u = bu[j + (i>>2)*8];
      v = bv[j + (i>>2)*8];

      y = (y + (128<<SCALEBITS)) >> SCALEBITS; /* descale */
      u = (u + (128<<SCALEBITS)) >> SCALEBITS;
      v = (v + (128<<SCALEBITS)) >> SCALEBITS;

      /* Mix in the errors and clamp */
      y += erry; if (y < 0) y = 0; if (y > 255) y = 255;
      u += erru; if (u < 0) u = 0; if (u > 255) u = 255;
      v += errv; if (v < 0) v = 0; if (v > 255) v = 255;

      /* Combine Y:U:V in the ratio 5:4:4, and use as an index
       * into the YUV->pixel table
       */
#if 1
      colour = yuv_to_pixel_table[((y & 0xF8) << 5) |
                                   (u & 0xF0) |
                                  ((v & 0xF0) >> 4)];
#else
      colour = i + (j * 32); /* test of patterning */
#endif
      /* Reduce patterning by doing a 'n' shaped dance
       *   [ p=1  p=2 ]
       *   [ p=0  p=3 ]
       * which is a 'u' shape when the origin is in the BLHC
       */
      outptr[((p & 2) >> 1) +
             (((p - 1) & 2) ? (outoffset * sizeof(int)) : 0)] = colour;

      /* Lookup backwards to calculate the error term */
      erry = y - ((pixel_to_yuv_table[colour] >> 16) & 0xFF);
      erru = u - ((pixel_to_yuv_table[colour] >> 8) & 0xFF);
      errv = v - ((pixel_to_yuv_table[colour] >> 0) & 0xFF);

      /* Next output pair on this row */
      if (p == 3) outptr += 2;
    }

    /* Carry on or start on the left 2 rows down? */
    outptr += (outoffset * sizeof(int) * 2) - (DCTSIZE * 2);
  }
d207 3
a209 1
      int y, u, v;
@


4.2.2.4
log
@Use USAT in 150 occurrences of colour clamping for ARMv6 and later.
Some IDCT renaming.
Shock addition of some documentation on how it all works.
Mirror fix from 1.39 on the trunk.
Debug
 Made DEBUG version compile again, earlier header shuffling was preventing it.
 Replaced the ' _ ' method of variadic macro emulation with more familiar double brackets for tracef().
 Eliminated IFDEBUG macro and just used #ifdef DEBUG/#endif or tracef() directly.
 Don't bother passing the line number and file name to exit() when in the non DEBUG case.

Version 1.38, 1.35.2.8. Tagged as 'SprExtend-1_38-1_35_2_8'
@
text
@d303 1
a303 1
    /* Start on the left 2 rows down */
@


4.2.2.5
log
@New jerror.h taken from IJG8b.
Swap to using JERR_ numbers, deleted E_ numbers.
Modify genjhdr to pass some defines to the assembler code, so jdcolor can clarify use of DCTSIZE and DCTSIZE2.
Added chart of possible subsampling ratios to documentation.

Version 1.38, 1.35.2.9. Tagged as 'SprExtend-1_38-1_35_2_9'
@
text
@d308 1
a308 1
void colour_convert_block_32(JCOEF *yuv, int *outptr, int outoffset)
@


4.2.2.6
log
@Abstract entropy decoding.
Currently still only support Huffman, but now agnostic, there are two functions 'decode_mcu()' which does the full DC+AC decode of a full MCU worth of data, and 'skip_mcu()' which just does DC and consumes but discards the AC coefficients.
Apply fix from 1.40 trunk version for monochrome output in a 8bpp greyscale mode.
Restore name of DCTFIX() macro to FIX(), no longer needed now the constituent parts are compiled seperately rather than #included.
Fix CFSIjpeg to assemble even though it doesn't have a module base (the recently added 'relocatefn()' was breaking it).

Version 1.38, 1.35.2.14. Tagged as 'SprExtend-1_38-1_35_2_14'
@
text
@d25 1
a25 1
  y = ((y + 4) >> 3) + 128;      /* normalise */
@


4.1
log
@Initial revision
@
text
@@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

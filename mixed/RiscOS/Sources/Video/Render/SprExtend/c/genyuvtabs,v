head	4.3;
access;
symbols
	SprExtend-1_83:4.3
	SprExtend-1_82:4.3
	SprExtend-1_81:4.3
	SprExtend-1_80:4.3
	SprExtend-1_79:4.3
	SprExtend-1_78:4.3
	SprExtend-1_77:4.3
	SprExtend-1_76:4.3
	SprExtend-1_75:4.3
	SprExtend-1_74:4.3
	SprExtend-1_73:4.3
	SprExtend-1_72:4.3
	SprExtend-1_71-nocfsi:4.3
	SprExtend-1_71:4.3
	SprExtend-1_70-tracef:4.2
	SprExtend-1_70-headers:4.2
	SprExtend-1_70:4.2
	SprExtend-1_69:4.2
	SprExtend-1_68:4.2
	SprExtend-1_67:4.2
	SprExtend-1_66:4.2
	SprExtend-1_65:4.2
	SprExtend-1_64:4.2
	SprExtend-1_63:4.2
	SprExtend-1_62:4.2
	SprExtend-1_61:4.2
	SprExtend-1_60:4.2
	SprExtend-1_59:4.2
	SprExtend-1_58:4.2
	SprExtend-1_57:4.2
	SprExtend-1_56:4.2
	SprExtend-1_55:4.2
	SprExtend-1_54:4.2
	SprExtend-1_53:4.2
	SprExtend-1_52:4.2
	SprExtend-1_51:4.2
	SprExtend-1_50:4.2
	SprExtend-1_38-1_35_2_16:4.2.2.2
	SprExtend-1_49:4.2
	SprExtend-1_48:4.2
	SprExtend-1_47:4.2
	SprExtend-1_38-1_35_2_15:4.2.2.2
	SprExtend-1_46:4.2
	SprExtend-1_45:4.2
	SprExtend-1_44:4.2
	SprExtend-1_43:4.2
	SprExtend-1_42:4.2
	SprExtend-1_41:4.2
	SprExtend-1_38-1_35_2_14:4.2.2.2
	SprExtend-1_40:4.2
	SprExtend-1_38-1_35_2_13:4.2.2.2
	SprExtend-1_38-1_35_2_12:4.2.2.2
	SprExtend-1_38-1_35_2_11:4.2.2.2
	SprExtend-1_38-1_35_2_10:4.2.2.2
	SprExtend-1_38-1_35_2_9:4.2.2.2
	SprExtend-1_38-1_35_2_8:4.2.2.2
	SprExtend-1_39:4.2
	SprExtend-1_38-1_35_2_7:4.2.2.2
	SprExtend-1_38-1_35_2_6:4.2.2.1
	SprExtend-1_38-1_35_2_5:4.2
	SprExtend-1_38-1_35_2_4:4.2
	SprExtend-1_38-1_35_2_3:4.2
	SprExtend-1_38-1_35_2_2:4.2
	SprExtend-1_38-1_35_2_1:4.2
	MigrateIJG8b:4.2.0.2
	SprExtend-1_38:4.2
	SprExtend-1_37:4.2
	SprExtend-1_36:4.2
	SprExtend-1_35:4.2
	SprExtend-1_34:4.2
	SprExtend-1_33:4.2
	SprExtend-1_32:4.2
	SprExtend-1_31:4.1
	SprExtend-1_30:4.1
	SprExtend-1_29:4.1
	SprExtend-1_28:4.1
	SprExtend-1_27:4.1
	SprExtend-1_26:4.1
	SprExtend-1_25:4.1
	SprExtend-1_24:4.1
	SprExtend-1_23:4.1
	SprExtend-1_22:4.1
	SprExtend-1_21:4.1
	SprExtend-1_20:4.1
	SprExtend-1_19:4.1
	SprExtend-1_18:4.1
	SprExtend-1_17:4.1
	RO_5_07:4.1
	SprExtend-1_16:4.1
	SprExtend-1_15:4.1
	SprExtend-1_14:4.1
	SprExtend-1_13:4.1
	SprExtend-1_12:4.1
	SprExtend-1_11:4.1
	SprExtend-1_10:4.1
	SprExtend-1_09:4.1
	SprExtend-1_08:4.1
	dellis_autobuild_BaseSW:4.1
	SprExtend-1_07:4.1
	SprExtend-1_06:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	SprExtend-1_05:4.1
	Ursula_merge:4.1
	nturton_SprExtend-1_04:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.3
date	2016.05.21.13.44.38;	author rool;	state Exp;
branches;
next	4.2;
commitid	ZDqmsyNiMhv6Zl7z;

4.2
date	2010.10.13.20.26.21;	author rsprowson;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.45.02;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	2011.01.09.10.42.59;	author rsprowson;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	2011.01.09.10.56.44;	author rsprowson;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.45.02;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.40.44;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.57.24;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.20.04;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.3
log
@Import of IJG8d library sources
Detail:
  Using the decoder in "example.c" as a starting point, we try to follow that sequence more closely even if in our embedded implementation some of the functions don't do much.
  Uses the default colour backend for 32bpp BGR output for most of the unusual cases.
  The most common 2x2 subsampling case uses a custom merged upsampler and colour converter, with colour output directly in RISC OS format for the respective screen mode.
Admin:
  Submission for the JPEG bounty.

Version 1.71. Tagged as 'SprExtend-1_71'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* 
 * c.genyuvtabs - Generate tables (in assembler source form) to assist in converting
 *                YUV data directly to 8bit RGB.
 *
 * 08-Feb-94 0.01 WRS - started
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

/**************** RGB -> YCbCr conversion **************/

/*
 * YCbCr is defined per CCIR 601-1, except that Cb and Cr are
 * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
 * The conversion equations to be implemented are therefore
 *      Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
 *      Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B  + MAXJSAMPLE/2
 *      Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B  + MAXJSAMPLE/2
 * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
 *
 */

static int rgb_to_yuv(int r, int g, int b)
/* Input values are in 0..255 */
/* Returns a word containing 00000000yyyyyyyyuuuuuuuuvvvvvvvv */
{
  double ytemp =  0.29900 * (float)r + 0.58700 * (float)g + 0.11400 * (float)b;
  double utemp = -0.16874 * (float)r - 0.33126 * (float)g + 0.50000 * (float)b  + 256.0/2.0;
  double vtemp =  0.50000 * (float)r - 0.41869 * (float)g - 0.08131 * (float)b  + 256.0/2.0;
  int    y     = (int)ytemp;
  int    u     = (int)utemp;
  int    v     = (int)vtemp;

  if (y < 0) y = 0; if (y > 255) y = 255;
  if (u < 0) u = 0; if (u > 255) u = 255;
  if (v < 0) v = 0; if (v > 255) v = 255;
  /*printf("rgb_to_yuv: %i,%i,%i -> %i,%i,%i\n" ,r ,g ,b ,y ,u ,v);*/
  return (y<<16) + (u<<8) + v;
}

/**************** YCbCr -> RGB conversion **************/

/*
 * YCbCr is defined per CCIR 601-1, except that Cb and Cr are
 * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
 * The conversion equations to be implemented are therefore
 *      R = Y                + 1.40200 * Cr
 *      G = Y - 0.34414 * Cb - 0.71414 * Cr
 *      B = Y + 1.77200 * Cb
 * where Cb and Cr represent the incoming values less MAXJSAMPLE/2.
 * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
 *
 */

static int yuv_to_rgb(int y, int u, int v)
/* Input values are in 0..255 */
/* Returns a word containing 00000000bbbbbbbbggggggggrrrrrrrr */
{
  double rtemp = (float)y                                  + 1.40200 * (float)(v-256.0/2.0);
  double gtemp = (float)y - 0.34414 * (float)(u-256.0/2.0) - 0.71414 * (float)(v-256.0/2.0);
  double btemp = (float)y + 1.77200 * (float)(u-256.0/2.0);
  int    r     = (int)rtemp;
  int    g     = (int)gtemp;
  int    b     = (int)btemp;

  if (r < 0) r = 0; if (r > 255) r = 255;
  if (g < 0) g = 0; if (g > 255) g = 255;
  if (b < 0) b = 0; if (b > 255) b = 255;
  /*printf("yuv_to_rgb: %i,%i,%i -> %i,%i,%i\n" ,y ,u ,v ,r ,g ,b);*/
  return (b<<16) + (g<<8) + r;
}

/**************** RGB <-> 8bit conversions **************/

#define BIT(n) (1<<(n))

static int pixel_to_rgb(int i)
/* Given a VIDC1 8bpp pixel bggrbrtt, return a precise rgb as 00000000bbbbbbbbggggggggrrrrrrrr */
{
  int r = 0, g = 0, b = 0;

  if (i & BIT(7)) b |= BIT(7); /* hi bit of blue */
  if (i & BIT(6)) g |= BIT(7); /* hi bit of green */
  if (i & BIT(5)) g |= BIT(6); /* next bit of green */
  if (i & BIT(4)) r |= BIT(7); /* hi bit of red */
  if (i & BIT(3)) b |= BIT(6); /* next bit of blue */
  if (i & BIT(2)) r |= BIT(6); /* next bit of red */
  if (i & BIT(1)) /* hi bit of tint - bit 5 of each gun */
  {
    r |= BIT(5);
    g |= BIT(5);
    b |= BIT(5);
  }
  if (i & BIT(0)) /* lo bit of tint - bit 1 of each gun */
  {
    r |= BIT(4);
    g |= BIT(4);
    b |= BIT(4);
  }
  r |= r>>4;
  g |= g>>4;
  b |= b>>4;
  /*printf("pixel_to_rgb: %i to %i,%i,%i\n", i, r, g, b);*/
  return (b<<16)+(g<<8)+r;
}

static int palette[256]; /* cache of pixel_to_rgb values */

static void palette_init(void)
{
  int i;

  for (i = 0; i < 256; i++) palette[i] = pixel_to_rgb(i);
}

static int pixel_closest_to_rgb(int r, int g, int b)
/* Returns VIDC1 pixel closest to specified colour */
/* This 256-time loop is called for each output byte! So, quite speed intensive. */
{
  int i;
  int mindistance = 1000000;
  int mini = 0;

  for (i = 0; i < 256; i++)
  {
    int rgb = palette[i];
    int dg = ((rgb>>8)&255) - g;
    int distance = 1*dg*dg;
    if (distance < mindistance) /* Quite often green distance will swamp the others, cut off quicker. */
    {
      int dr = (rgb&255) - r;
      int db = ((rgb>>16)&255) - b;
      distance += 1*dr*dr + db*db;
      if (distance < mindistance) {mini = i; mindistance = distance;}
    }
  }
  /*printf("pixel_closest_to_rgb %i,%i,%i -> %i.\n", r, g, b, mini);*/
  return mini;
}

static int pixel_to_yuv(int pixel)
/* Given a VIDC1 8bpp pixel, return a precise yuv as 00000000yyyyyyyyuuuuuuuuvvvvvvvv */
{
  int rgb = pixel_to_rgb(pixel);
  return rgb_to_yuv(rgb & 255, (rgb>>8)&255, (rgb>>16)&255);
}

/**************** Formatting huge byte tables neatly, as assembler source ****************/
static int offset = 0;
static int count = 0;

static void byte_begin(void)
{
  offset = 0;
  count = 0;
}

static void byte_put(int b)
{
  if (0 == (offset & 15)) printf(" DCB "); else printf(", ");
  printf("%i", b);
  offset++;
  if (0 == (offset & 15)) printf("\n");
  count++;
}

static void word_put(int w)
{
  byte_put(w&255);
  byte_put((w>>8)&255);
  byte_put((w>>16)&255);
  byte_put((w>>24)&255);
}

static void byte_end(int count_total)
{
  printf("\n");
  if (count != count_total) printf("Generated %i bytes, expected %i.\n", count, count_total);
  assert(count == count_total); /* Just a little check that we're generating the right amount */
}

/**************** Generating the tables ****************/

static void pixel_to_yuv_table(void)
{
  int i;

  printf(" EXPORT pixel_to_yuv_table\n");
  printf("pixel_to_yuv_table ; word i is the closest yuv value to VIDC1 8bpp pixel i\n");
  byte_begin();
  for (i = 0; i < 256; i++) word_put(pixel_to_yuv(i));
  byte_end(4 * 256);
}

static void yuv_to_pixel_table(void)
{
  int bits_of_y = 5;
  int bits_of_u = 4;
  int bits_of_v = 4;
  int y, u, v;

  printf(" EXPORT yuv_to_pixel_table\n");
  printf("yuv_to_pixel_table\n");
  printf("yuvtab_ybits * %i\n", bits_of_y);
  printf("yuvtab_ubits * %i\n", bits_of_u);
  printf("yuvtab_vbits * %i\n", bits_of_v);
  printf("; A byte table indexed by yuv value, returns the closest 8bpp pixel\n");
  byte_begin();
  for (y = 0 /*(1<<(7-bits_of_y))*/; y < 256; y += (1<<(8-bits_of_y)))
  {
    printf(" ; y=%i\n", y);
    for (u = 0 /*(1<<(7-bits_of_u))*/; u < 256; u += (1<<(8-bits_of_u)))
    {
      for (v = 0 /*(1<<(7-bits_of_v))*/; v < 256; v += (1<<(8-bits_of_v)))
      /* This loop effectively looks for values one-half above the precise
      value that you're looking up. The intention is that this is right for
      truncating the values before doing the lookup - on average, I'm putting
      back half the truncated value before finding the closest match */
      /* >>> No, maybe this leads to the dirty-white phenomenon? Should
      really replicate top pixels at bottom.  */
      {
        int rgb = yuv_to_rgb(y + (y>>bits_of_y), u + (u>>bits_of_u), v + (v>>bits_of_v));
        int byte = pixel_closest_to_rgb(rgb&255, (rgb>>8)&255, (rgb>>16)&255);
        byte_put(byte);
      }
    }
  }
  byte_end((1<<bits_of_y) * (1<<bits_of_u) * (1<<bits_of_v));
}

int main(void)
{
  printf("; s.yuvtabs, generated by genyuvtabs %s %s.\n\n", __DATE__, __TIME__);
  palette_init();
  pixel_to_yuv_table();
  yuv_to_pixel_table();
  printf("\n END\n");
  return 0;
}
@


4.2
log
@Paper and fill some JPEG cracks.
The exit_c function was repeatedly being called with the line number argument and error code the wrong way round and since only bits 0-2 of the error code are inspected on exit any fatal exits from the ported JPEG library code would either report the wrong error or fail silently (depending on the line number) - example a 12 bits per sample JPEG would be rendered without fault into a screen full of random memory garbage.
Assembling/compiling with the 'jpeg' switch off didn't work, fixed, and also now zeros out the SWI decode values in the module header.
Moved include of 'yuvtabs.s' into the colour conversion code.
Deleted panic_exit, it did nothing useful but trace a value then exit, so it now just calls exit() like everyone else.
Removed excess call to find_image_dims(), this was needed just to get the workspace requirements when the JPEG had already been sized up by asm_find_image_dims() earlier. Side effect of removing the pilot JPEG code earlier is that this call can now only get to the JPEG code from a JPEG_ SWI. Changed to just pass the workspace requirements into 'c.PutScaled' and save a duplicate scan.
Fatal exits from the assembler huffman decoder now report a sensible error.
Trimmed out all the JPEG assessment code from 'c.PutScaled' and moved it into 'c.rojpeg' so the put scaled is only concerned with putting things scaled.
Sanitised the #includes a bit.
Fixed on last check of wp->save_mode looking at the wrong bits for the mode number.
Resolved all the warning in the genhdr/genyuvtabs/genpalette utilities by casting a bit harder.[A[B
Added new more descriptive error messages to the messages file (not currently used), and made the 'not supported by' ones consistent so the tokeniser might crunch the file a bit more.
In looks_like_jpeg() changed a bitwise to logical or.
Fixed longstanding problem of not being able to render JPEGs at a scale of less than 1/6 in any greyscale mode, because, err, there was no code to do it - only the colour case was checked for. Implemented for 8bpp grey and 32bpp grey (which gets dithered for other lower modes) by just converting the luma channel into an equally weighted RGB value or replicating it for 256 greys.
Tested in all 8 colour depths on a Risc PC using sampling ratios of 1x1; 2x1; 1x2; 2x2 of the IJG test image scaled in !Draw by 0.16.

Version 1.32. Tagged as 'SprExtend-1_32'
@
text
@d206 1
d220 1
@


4.2.2.1
log
@Create assembler equivalents of C colour conversions, approx 10% speed up.
Add new switch ASMCOLOR to select which to use, C or assembler.
Remove FILE_ exit trace concept, just use __FILE__ instead in exit_erl.
Add some comments to exit_erl and friends.
A few bits of cinfo setup moved into start_pass_huff_decoder() or eliminated.
Bumped up the precision of SCALE_BITS in the C colour handling so FIX() uses more bits of an int.
Deleted the unused remenants of light dithering in the 8bpp colour converter - saves a few cycles.
colour_convert_8 and colour_convert_16 no longer save entry registers the C compiler doesn't care about.
Update genyuvtabs to EXPORT the table bases.
Split out the compilation of IJG files as separate objects in the make file, rather than including them from within rojpeg, which is itself included from putscaled.

Version 1.38, 1.35.2.6. Tagged as 'SprExtend-1_38-1_35_2_6'
@
text
@d178 1
a178 1
  if (0 == (offset & 15)) printf("        DCB "); else printf(", ");
d206 1
a206 3
  printf("        EXPORT pixel_to_yuv_table\n");
  printf("pixel_to_yuv_table\n");
  printf("; word i is the closest yuv value to VIDC1 8bpp pixel i\n");
d219 1
a222 2
  printf("        EXPORT yuv_to_pixel_table\n");
  printf("yuv_to_pixel_table\n");
d227 1
a227 1
    printf("        ; y=%i\n", y);
d253 1
a253 1
  printf("        END\n");
@


4.2.2.2
log
@For completeness, implement the 2x2->8bpp and 2x2->16bpp colour conversions in C too.
While slower than their assembler equivalents it makes the whacky address generation a bit easier to follow.
Fix MakeFile to not stop when trying to deleted an empty directory.

Version 1.38, 1.35.2.7. Tagged as 'SprExtend-1_38-1_35_2_7'
@
text
@d206 1
d224 1
@


4.1
log
@Initial revision
@
text
@d45 6
a50 3
  int y =  0.29900 * (float)r + 0.58700 * (float)g + 0.11400 * (float)b;
  int u = -0.16874 * (float)r - 0.33126 * (float)g + 0.50000 * (float)b  + 256/2;
  int v =  0.50000 * (float)r - 0.41869 * (float)g - 0.08131 * (float)b  + 256/2;
d77 6
a82 3
  int r = (float)y                              + 1.40200 * (float)(v-256/2);
  int g = (float)y - 0.34414 * (float)(u-256/2) - 0.71414 * (float)(v-256/2);
  int b = (float)y + 1.77200 * (float)(u-256/2);
d247 1
a247 1
extern int main(int argc, char **argv)
d249 1
a249 1
  printf("; YUV<->pixel tables, generated %s\n", __DATE__);
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

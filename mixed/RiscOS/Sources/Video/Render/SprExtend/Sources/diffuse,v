head	4.11;
access;
symbols
	SprExtend-1_83:4.11
	SprExtend-1_82:4.11
	SprExtend-1_81:4.11
	SprExtend-1_80:4.11
	SprExtend-1_79:4.11
	SprExtend-1_78:4.11
	SprExtend-1_77:4.11
	SprExtend-1_76:4.11
	SprExtend-1_75:4.11
	SprExtend-1_74:4.11
	SprExtend-1_73:4.11
	SprExtend-1_72:4.11
	SprExtend-1_71-nocfsi:4.11
	SprExtend-1_71:4.10
	SprExtend-1_70-tracef:4.9
	SprExtend-1_70-headers:4.9
	SprExtend-1_70:4.9
	SprExtend-1_69:4.9
	SprExtend-1_68:4.9
	SprExtend-1_67:4.9
	SprExtend-1_66:4.9
	SprExtend-1_65:4.9
	SprExtend-1_64:4.9
	SprExtend-1_63:4.9
	SprExtend-1_62:4.9
	SprExtend-1_61:4.9
	SprExtend-1_60:4.9
	SprExtend-1_59:4.9
	SprExtend-1_58:4.9
	SprExtend-1_57:4.9
	SprExtend-1_56:4.9
	SprExtend-1_55:4.9
	SprExtend-1_54:4.9
	SprExtend-1_53:4.9
	SprExtend-1_52:4.9
	SprExtend-1_51:4.9
	SprExtend-1_50:4.9
	SprExtend-1_38-1_35_2_16:4.8.2.2
	SprExtend-1_49:4.8
	SprExtend-1_48:4.8
	SprExtend-1_47:4.8
	SprExtend-1_38-1_35_2_15:4.8.2.2
	SprExtend-1_46:4.8
	SprExtend-1_45:4.8
	SprExtend-1_44:4.8
	SprExtend-1_43:4.8
	SprExtend-1_42:4.8
	SprExtend-1_41:4.8
	SprExtend-1_38-1_35_2_14:4.8.2.2
	SprExtend-1_40:4.8
	SprExtend-1_38-1_35_2_13:4.8.2.2
	SprExtend-1_38-1_35_2_12:4.8.2.2
	SprExtend-1_38-1_35_2_11:4.8.2.2
	SprExtend-1_38-1_35_2_10:4.8.2.2
	SprExtend-1_38-1_35_2_9:4.8.2.2
	SprExtend-1_38-1_35_2_8:4.8.2.2
	SprExtend-1_39:4.8
	SprExtend-1_38-1_35_2_7:4.8.2.1
	SprExtend-1_38-1_35_2_6:4.8.2.1
	SprExtend-1_38-1_35_2_5:4.8.2.1
	SprExtend-1_38-1_35_2_4:4.8.2.1
	SprExtend-1_38-1_35_2_3:4.8
	SprExtend-1_38-1_35_2_2:4.8
	SprExtend-1_38-1_35_2_1:4.8
	MigrateIJG8b:4.8.0.2
	SprExtend-1_38:4.8
	SprExtend-1_37:4.8
	SprExtend-1_36:4.8
	SprExtend-1_35:4.8
	SprExtend-1_34:4.8
	SprExtend-1_33:4.8
	SprExtend-1_32:4.8
	SprExtend-1_31:4.8
	SprExtend-1_30:4.8
	SprExtend-1_29:4.8
	SprExtend-1_28:4.8
	SprExtend-1_27:4.7
	SprExtend-1_26:4.7
	SprExtend-1_25:4.7
	SprExtend-1_24:4.6
	SprExtend-1_23:4.5
	SprExtend-1_22:4.4
	SprExtend-1_21:4.4
	SprExtend-1_20:4.4
	SprExtend-1_19:4.4
	SprExtend-1_18:4.3
	SprExtend-1_17:4.3
	RO_5_07:4.3
	SprExtend-1_16:4.3
	SprExtend-1_15:4.3
	SprExtend-1_14:4.3
	SprExtend-1_13:4.3
	SprExtend-1_12:4.3
	SprExtend-1_11:4.3
	SprExtend-1_10:4.3
	SprExtend-1_09:4.3
	SprExtend-1_08:4.3
	dellis_autobuild_BaseSW:4.3
	SprExtend-1_07:4.3
	SprExtend-1_06:4.3
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.3
	SprExtend-1_05:4.2
	Ursula_merge:4.2
	nturton_SprExtend-1_04:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.11
date	2016.05.21.13.48.14;	author rool;	state Exp;
branches;
next	4.10;
commitid	F2CfxJ1XTlg50m7z;

4.10
date	2016.05.21.13.44.32;	author rool;	state Exp;
branches;
next	4.9;
commitid	ZDqmsyNiMhv6Zl7z;

4.9
date	2012.07.28.15.23.38;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	b5jdybqzJ3Wdjlew;

4.8
date	2010.09.25.12.19.17;	author rsprowson;	state Exp;
branches
	4.8.2.1;
next	4.7;

4.7
date	2010.09.17.21.07.21;	author rsprowson;	state Exp;
branches;
next	4.6;

4.6
date	2010.09.01.20.48.51;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2010.08.29.08.36.04;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2009.04.24.00.48.33;	author srevill;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.12.12.59.07;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.17.51.01;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.45.12;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.8.2.1
date	2011.01.04.21.45.26;	author rsprowson;	state Exp;
branches;
next	4.8.2.2;

4.8.2.2
date	2011.01.13.21.12.16;	author rsprowson;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.45.12;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.42.02;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.58.10;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.20.43;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.11
log
@Removed CFSI-JPEG support
Detail:
  ChangeFSI now makes its own helper plugin which just calls the JPEG SWIs of the host OS, so there's no need for SpriteExtend to be complicated by this now.
Admin:
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_71-nocfsi
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.diffuse

; Error diffusion for 8bpp & 24bpp JPEG output
;   01-Nov-93 WRS started
;   04-Nov-93 WRS it works!

; This code implements error diffusion for JPEG output when plotting at 8bpp.
; It does it only for the unscaled case, a shame but necessary in order to
; get acceptable speed. It's specialised to 8bpp because for 16bpp an
; ordered dither is good enough, and for 4bpp or less you just don't get
; a good picture - stick to ordered dither. For 8bpp it can make all the
; difference, and is worth doing.

; The diffusion happens within the JPEG band buffer, rather than onto
; the destination image. The data will then be copied again to get it onto
; the screen.

; Performance target - an extra 100 ticks/pixel is the outer limit. Beyond
; that it's really not acceptable - you're better off with an off-line
; conversion tool like ChangeFSI.

; We only diffuse errors within an MCU, in order to retain the clipping
; property. Experiments with ChangeFSI indicated that this is scarcely
; noticable.

; for each pixel the basic algorithm is:

;         get error shuffled in from left as r,g,b
;         get value required of this pixel
;           unpack it
;           add it to r,g,b
;         pack up r,g,b as 16bpp value
;         look it up in 32K table (ie choose closest 8bit pixel)
;         save that byte (we have chosen this pixel now)
;         look up true rgb of that byte
;           unpack it
;           subtract it from r,g,b (leftover error)
;         fetch next line, prev pixel
;           unpack it
;           add 5/16 of r,g,b to it
;           pack it up
;           save it
;         fetch next line, pixel below
;           unpack it
;           add 3/16 of r,g,b to it
;           pack it up
;           save it
;         fetch next line, next pixel
;           unpack its
;           add 1/16 of r,g,b to it
;           pack it up
;           save it
;         remember 7/16 of r,g,b in r,g,b
;         loop

; This is the basic algorithm used by ChangeFSI. The sending of different
; bits of error in different directions ensures that you don't get localised
; stripes or other undesirable effects.

; At the start and end of the line, use different fractions - never throw
; any error away.

; As stated above the problem becomes that all that adding of values
; (which happens for each gun) has to be carefully clamped, so that
; no colour value goes below 0 or above 255. This takes ages. So,
; the colour values are represtented by a new format within a word that
; gives 10 bits for each colour value. This allows errors to be added
; to or subtracted from the gun values without any clamping checks, these
; are only performed once at the end when the whole value of a pixel
; is unpacked. Within the 10-bit fields the gun values are kept to 9 bits
; of accuracy, and I tend to truncate colour values everywhere rather than
; rounding. This is not as accurate as ChangeFSI, but speed is more
; important here.

; registers:
d_inptr RN      0           ; -> this pixel
d_count RN      1           ; = number of pixels still to do
d_outptr RN     2           ; -> where to save pixels
d_table RN      3           ; = 16->8 conversion table

d_r     RN      7
d_g     RN      8
d_b     RN      9
d_nextline RN   10          ; -> line above inptr, two pixels ahead
d_nlprevpix RN  4           ; = [nextline,#-4]
d_nlpix RN      5           ; = [nextline]
d_nlnextpix RN  6           ; = [nextline,#4]
d_palette RN    11          ; -> palette
d_t1    RN      12
d_t2    RN      14

; The expanded format for a colour value:
;   9 bits for each gun
;   128 added to each such value
; The accumulated errors in a pixel can never add up to -128 or +128,
; so this can never overflow/underflow the 0..511 range. To get the
; real value back subtract 128 again, being careful about underflow
; or a result greater than 255.

; There's enough space in the word to allow 10 bits per gun. We don't
; do this because it takes more cycles to split it up - hope the
; quality's good enough!

        MACRO
        ClipAbove
        ; common tail for AddUnspacedPixelToRGB, AddSpacedPixelToRGB
        CMP     d_r,#255
        MOVGT   d_r,#255
        CMP     d_g,#255
        MOVGT   d_g,#255
        CMP     d_b,#255
        MOVGT   d_b,#255
        MEND

; to add a regular 32-bit pixel in d_t1 to R,G,B, and clamp output values:
        MACRO
        AddUnspacedPixelToRGB
        AND     d_t2,d_t1,#255               ; get red
        ADDS    d_r,d_r,d_t2
        MOVLT   d_r,#0
        AND     d_t2,d_t1,#&ff00
        ADDS    d_g,d_g,d_t2,LSR #8
        MOVLT   d_g,#0
        AND     d_t2,d_t1,#&ff0000
        ADDS    d_b,d_b,d_t2,LSR #16
        MOVLT   d_b,#0
        ClipAbove
        MEND

; to add a 'spaced out' pixel in d_t1 to R,G,B, and clamp output values:
        MACRO
        AddSpacedPixelToRGB
        MOV     d_t2,d_t1,LSL #22            ; get red, in top 9 bits
        ADD     d_r,d_r,d_t2,LSR #22
        SUBS    d_r,d_r,#&180
        MOVLT   d_r,#0
        MOV     d_t2,d_t1,LSL #12            ; get green
        ADD     d_g,d_g,d_t2,LSR #22
        SUBS    d_g,d_g,#&180
        MOVLT   d_g,#0
        ADD     d_b,d_b,d_t1,LSR #20        ; add in blue
        SUBS    d_b,d_b,#&180
        MOVLT   d_b,#0
        ClipAbove
        MEND

; to convert R,G,B to a 16 bit value (for a table lookup):
; Truncating version, seems little different to rounding one
        MACRO
        ConvertRGBTo16bit
        MOVS    d_t2,d_r,ASR #3                ; get red
        MOVS    d_t1,d_g,ASR #3                ; get green
        ORR     d_t1,d_t2,d_t1,LSL #5
        MOVS    d_t2,d_b,ASR #3                ; get blue
        ORR     d_t1,d_t1,d_t2,LSL #10         ; combine blue with red,green
        ; d_t1 contains a 15bit RGB value
        MEND

        MACRO
        DoTableLookup
        CMP     d_table,#0
        LDRNEB  d_t1,[d_table,d_t1]
        BNE     %ft1

        ; Algorithmic colour conversion. Lifted from what c.PutScaled can generate dynamically,
        ; which just goes to show I should be generating this dynamically in a more general way...
        ; 'd_table' is used as a temporary variable, and reset to 0 at the end.

        ; Creating bggrbrtt from 0bbbbbgg gggrrrrr
        ; Making the tint - the average of the lo 3 bits of RGB isn't a bad approximation. We make this
        ; by adding them all up, multiplying by 3, and dividing by 8. We involve the lo bits in the approximation
        ; as well, in case they produce a useful carry.
        AND     d_t2,d_t1,#&1C00                 ; bottom 3 bits of B
        MOV     d_table,d_t2,LSR #10             ; at bottom of temp2
        AND     d_t2,d_t1,#&E0                   ; bottom 3 bits of G
        ADD     d_table,d_table,d_t2,LSR #5      ; add to bottom B bits
        AND     d_t2,d_t1,#&07                   ; bottom 3 bits of R
        ADD     d_table,d_table,d_t2             ; add to bottom B+G bits
        ADD     d_table,d_table,d_table,LSL #2   ; (lo R+G+B)*5    (< 128)

        ; The hi bits are just done by extracting from the 16bpp value. This takes ages!
        MOV     d_t2,#0                          ; building result pixel for hi bits

        ; Top bits of B */
        TST     d_t1,#&4000                      ; test top bit of B
        ORRNE   d_t2,d_t2,#128                   ; bit 7 = top bit of B
        TST     d_t1,#&2000                      ; test next bit of B
        ORRNE   d_t2,d_t2,#8                     ; bit 3 = next bit of B

        ; Top bits of G */
        TST     d_t1,#&200                       ; test top bit of G
        ORRNE   d_t2,d_t2,#64                    ; bit 6 = top bit of G
        TST     d_t1,#&100                       ; test next bit of G
        ORRNE   d_t2,d_t2,#32                    ; bit 5 = next bit of G

        ; Top bits of R */
        TST     d_t1,#&10                        ; test top bit of R
        ORRNE   d_t2,d_t2,#16                    ; bit 4 = top bit of R
        TST     d_t1,#&08                        ; test next bit of R
        ORRNE   d_t2,d_t2,#4                     ; bit 2 = next bit of R

        ORR     d_t1,d_t2,d_table,LSR #5         ; combine hi bits and tint
        MOV     d_table,#0                       ; reset our temporary variable
1
        MEND

        MACRO
        ConvertSpacedPixelPlusRGBTo8bit
        AddSpacedPixelToRGB
        ConvertRGBTo16bit
        DoTableLookup
        MEND

        MACRO
        ConvertPixelPlusRGBTo8bit
        AddUnspacedPixelToRGB
        ConvertRGBTo16bit
        DoTableLookup
        MEND

; to save the byte
        MACRO
        Save8bitPixel
        STRB    d_t1,[d_outptr],#1
        MEND

; to save the word
        MACRO
        Save24bitPixel
        STR     d_t1,[d_outptr],#4
        MEND

        MACRO
        GetTrueRGBof8bitPixel
; to look up true rgb of that byte - as a 16bit pixel
        LDR     d_t1,[d_palette,d_t1,LSL #2]     ; a table of 32-bit RGB values
        MEND

;        start bbggrr00
        MACRO
        Subtract32bitFromRGB
        ; d_t1=32 bit pixel - subtract it from R,G,B
        AND     d_t2,d_t1,#&ff00
        SUB     d_r,d_r,d_t2,LSR #8
        AND     d_t2,d_t1,#&ff0000
        SUB     d_g,d_g,d_t2,LSR #16
        SUB     d_b,d_b,d_t1,LSR #24
        MEND

; about 42 cycles up to here for 'normal' case?

; fetch next line, prev pixel - add 5/16 of r,g,b to it
        MACRO
        Add5_16ToNextLinePrevPix
        ADD     d_t1,d_r,d_r,LSL #2                   ; d_r*5
        ADD     d_nlprevpix,d_nlprevpix,d_t1,ASR #4   ; d_r*5>>4
        ADD     d_t1,d_g,d_g,LSL #2                   ; d_g*5
        MOV     d_t1,d_t1,ASR #4                      ; d_g*5>>4
;        ADD     d_nlprevpix,d_nlprevpix,d_t1,LSL #9
        ADD     d_nlprevpix,d_nlprevpix,d_t1,LSL #10
        ADD     d_t1,d_b,d_b,LSL #2                   ; d_b*5
        MOV     d_t1,d_t1,ASR #4                      ; d_b*5>>4
;        ADD     d_nlprevpix,d_nlprevpix,d_t1,LSL #18
        ADD     d_nlprevpix,d_nlprevpix,d_t1,LSL #20
        MEND

; fetch next line, prev pixel - add 8/16 of r,g,b to it
        MACRO
        Add8_16ToNextLinePrevPix
        ADD     d_nlprevpix,d_nlprevpix,d_r,ASR #2
        MOV     d_t1,d_g,ASR #1
        ADD     d_nlprevpix,d_nlprevpix,d_t1,LSL #10
        MOV     d_t1,d_g,ASR #1
        ADD     d_nlprevpix,d_nlprevpix,d_t1,LSL #20
        MEND

        MACRO
        Add3_16ToNextLinePix
        ADD     d_t1,d_r,d_r,LSL #1                   ; d_r*3
        ADD     d_nlpix,d_nlpix,d_t1,ASR #4           ; d_r*3>>4
        ADD     d_t1,d_g,d_g,LSL #1                   ; d_g*3
        MOV     d_t1,d_t1,ASR #4                      ; d_g*3>>4
;        ADD     d_nlpix,d_nlpix,d_t1,LSL #9
        ADD     d_nlpix,d_nlpix,d_t1,LSL #10
        ADD     d_t1,d_b,d_b,LSL #1                   ; d_b*3
        MOV     d_t1,d_t1,ASR #4                      ; d_b*3>>4
;        ADD     d_nlpix,d_nlpix,d_t1,LSL #18
        ADD     d_nlpix,d_nlpix,d_t1,LSL #20
        MEND

        MACRO
        Add8_16ToNextLinePix
        ; This is used at the start and end of lines in the middle of a block,
        ; instead of throwing away the diagonal error we pump more of it up
        ; vertically.
        ADD     d_nlpix,d_nlpix,d_r,ASR #1            ; d_r>>1
        MOV     d_t1,d_g,ASR #1                       ; d_g>>1
;        ADD     d_nlpix,d_nlpix,d_t1,LSL #9
        ADD     d_nlpix,d_nlpix,d_t1,LSL #10
        MOV     d_t1,d_b,ASR #1                       ; d_b>>1
;        ADD     d_nlpix,d_nlpix,d_t1,LSL #18
        ADD     d_nlpix,d_nlpix,d_t1,LSL #20
        MEND

        MACRO
        Add1_16ToNextLineNextPix
        ADD     d_nlnextpix,d_nlnextpix,d_r,ASR #4    ; d_r>>4
        MOV     d_t1,d_g,ASR #4                       ; d_g>>4
;        ADD     d_nlnextpix,d_nlnextpix,d_t1,LSL #9
        ADD     d_nlnextpix,d_nlnextpix,d_t1,LSL #10
        MOV     d_t1,d_b,ASR #4                       ; d_b>>4
;        ADD     d_nlnextpix,d_nlnextpix,d_t1,LSL #18
        ADD     d_nlnextpix,d_nlnextpix,d_t1,LSL #20
        MEND
; 42+21 - 63 so far

        MACRO
        CutRGBby7_16
        ; remember 7/16 of r,g,b in r,g,b
        RSB     d_r,d_r,d_r,LSL #3
        MOV     d_r,d_r,ASR #4
        RSB     d_g,d_g,d_g,LSL #3
        MOV     d_g,d_g,ASR #4
        RSB     d_b,d_b,d_b,LSL #3
        MOV     d_b,d_b,ASR #4
        MEND

        MACRO
        CutRGBby12_16
        ; remember 12/16 of r,g,b in r,g,b
        MOV     d_t1,d_r,LSL #2
        RSB     d_r,d_t1,d_r,LSL #4
        MOV     d_r,d_r,ASR #4
        MOV     d_t1,d_g,LSL #2
        RSB     d_g,d_t1,d_g,LSL #4
        MOV     d_g,d_g,ASR #4
        MOV     d_t1,d_b,LSL #2
        RSB     d_b,d_t1,d_b,LSL #4
        MOV     d_b,d_b,ASR #4
        MEND

        MACRO
        SpaceOutPixel $r,$temp
        ; space out the RGB in a pixel to leave a bit between them,
        ; and add 128 to each gun value
        AND     $temp.,$r.,#&ff0000
        ADD     $r.,$r.,$temp.                     ; shift b up one
        ADD     $r.,$r.,$temp.,LSL #1              ; shift b up another 1
        BIC     $temp.,$r.,#&ff
        ADD     $r.,$r.,$temp.                     ; shift g,b up one
        ADD     $r.,$r.,$temp.,LSL #1              ; shift g,b up another 1
        ADD     $r.,$r.,#&180
        ADD     $r.,$r.,#&180:SHL:10
        ADD     $r.,$r.,#&180:SHL:20
;        AND     $temp.,$r.,#&ff0000
;        ADD     $r.,$r.,$temp.                     ; shift b up one
;        BIC     $temp.,$r.,#&ff
;        ADD     $r.,$r.,$temp.                     ; shift g,b up one
;        ADD     $r.,$r.,#128
;        ADD     $r.,$r.,#128:SHL:9
;        ADD     $r.,$r.,#128:SHL:18
        ; or, want an extra register to hold this whacky constant
        MEND

        MACRO
        AdvanceLineAbove
        ; advance to next pixel
        STR     d_nlprevpix,[d_nextline,#-12]
        MOV     d_nlprevpix,d_nlpix
        MOV     d_nlpix,d_nlnextpix
        LDR     d_nlnextpix,[d_nextline],#4
        SpaceOutPixel d_nlnextpix,d_t1
        MEND
; 80 so far? not bad!

        MACRO
        LineAboveStartup
        ; given 'd_nextline' pointing at the start of the line above,
        ; get nextline registers ready to traverse this line.
        ; d_nlprevpix first set up by AdvanceLineAboveForFirstInLine.
        LDR     d_nlpix,[d_nextline],#4
        SpaceOutPixel d_nlpix,d_t1
        LDR     d_nlnextpix,[d_nextline],#4
        SpaceOutPixel d_nlnextpix,d_t1
        MEND

        MACRO
        AdvanceLineAboveForFirstInLine
        ; advance to next pixel - there is no next-line-prev-pixel yet,
        MOV     d_nlprevpix,d_nlpix
        MOV     d_nlpix,d_nlnextpix
        LDR     d_nlnextpix,[d_nextline],#4
        SpaceOutPixel d_nlnextpix,d_t1
        MEND

        MACRO
        AdvanceLineAboveForLastInLine
        ; advance to next pixel
        STR     d_nlprevpix,[d_nextline,#-12]
        STR     d_nlpix,[d_nextline,#-8]
        MEND

; that's about it!

;About 85 cycles per pixel total?

; --------------------------------------------------------------------------------------
;
; extern char *asm_get_table32k(const int *palette_data);
;
; --------------------------------------------------------------------------------------
; Get the big table from ColourTrans. Return 0 if there's an error of any sort.

        EXPORT  asm_get_table32k
asm_get_table32k
        STMDB   sp!,{r4-r7,lr}                ; save work registers
; We'll check for a recent ColourTrans. The one in RISC OS 3.10 seems to produce
; an address exception if you make the SelectTable call below!
; Note the flag is retrieved SL relative since the C code between 'jpeg_fetchroutine'
; and here has trashed r12, but handily 'jpeg_fetchroutine' copied it into SL too
        LDR     r2,[SL,#:INDEX:ctrans_recent]
        TEQ     r2,#0
        MOVEQ   r0,#0                         ; error return - not new ColourTrans
        LDMEQIA sp!,{r4-r7,pc}                ; so return with no table.
; OK, a recent ColourTrans. Ask it for the 32K lookup table.
        MOV     r3,r0                         ; palette data
        MOV     r0,#SpriteType_New32bpp :SHL: 27
        ORR     r0,r0,#1                      ; new mode number for 32bpp
        MOV     r1,#-1                        ; default input, output, palette, everything
        MOV     r2,#-1
        SUB     sp,sp,#12
        MOV     r4,sp                         ; pointer to buffer to put table in
        MOV     r5,#0                         ; no special flags
        MOV     r6,#0
        MOV     r7,#0
        SWI     XColourTrans_SelectTable
        BVS     asm_get_table32k_fail         ; error return, no table about
        
        LDR     r1,asm_table32k_guard
        LDR     r0,[sp,#0]                    ; check first guard word
        CMP     r0,r1
        LDREQ   r0,[sp,#8]                    ; check second guard word
        CMPEQ   r0,r1
        BNE     asm_get_table32k_fail
        LDR     r0,[sp,#4]                    ; all is well - get the table pointer
        ADD     sp,sp,#12                     ; discard stack workspace
        LDMIA   sp!,{r4-r7,pc}                ; return

asm_get_table32k_fail
        MOV     r0,#0
        ADD     sp,sp,#12
        LDMIA   sp!,{r4-r7,pc}

asm_table32k_guard
        DCD     &2e4b3233                     ; "32K." guard word value

; --------------------------------------------------------------------------------------
;
; extern void asm_diffuse_to_8bpp(JSAMPARRAY inrows, int count, JSAMPARRAY outrows, char *table,
;                                 int nlines, int xmin, const int *palette);
;
; --------------------------------------------------------------------------------------
; Rows of pixels at   inrows[0..nlines-1]         nlines >= 2
; Each row comprises  pix[0..count-1]             count >= 1
; Only want from xmin pixels onwards in each row, xmin is a multiple of 16
; Table, if non-zero, is a 32K lookup table that converts 15bit RGB values to 8-bit pixels.
;
; You may trample on the input pixels if need be. In fact, inrows and outrows may point at
; the same memory initially, if you do things in the obvious order it won't matter.

        EXPORT  asm_diffuse_to_8bpp
asm_diffuse_to_8bpp
; The first line is special because the input pixels are in un-spaced-out format.

        STMDB   sp!,{r0-r12,lr}                       ; we need them all!
        ; d_count, d_table already set up
        MOV     d_t1,r0
        LDR     d_nextline,[d_t1,#4]                  ; pointer to line above d_inptr
        LDR     d_inptr,[d_t1],#4                     ; pointer to first input line
        STR     d_t1,[sp,#0*4]                        ; ripple inrows by 1
        LDR     d_t2,[sp,#14*4+4]                     ; recover xmin
        MOV     d_t1,r2
        LDR     d_outptr,[d_t1],#4                    ; pointer to output line
        STR     d_t1,[sp,#2*4]                        ; ripple outrows by 1
        ADD     d_nextline,d_nextline,d_t2,LSL#2      ; don't bother dithering outside the clipping box
        ADD     d_inptr,d_inptr,d_t2,LSL#2
        ADD     d_outptr,d_outptr,d_t2,LSL#0
        LDR     d_palette, [sp,#14*4+8]

        MOV     d_r,#0
        MOV     d_g,#0
        MOV     d_b,#0

        LineAboveStartup
        SUBS    d_count,d_count,#1
        BEQ     dither_first_line_last_pixel          ; lines are just one pixel long
; Start processing the first pixel
        LDR     d_t1,[d_inptr],#4                     ; get very first pixel
        ConvertPixelPlusRGBTo8bit
        Save8bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        ; 5/16ths of the error is thrown away
        Add3_16ToNextLinePix
        Add1_16ToNextLineNextPix
        CutRGBby7_16
        AdvanceLineAboveForFirstInLine
; now the loop for most of the pixels in the first line
        SUBS    d_count,d_count,#1
        BEQ     dither_first_line_last_pixel          ; lines are just two pixels long
dither_each_pixel_in_first_line
        LDR     d_t1,[d_inptr],#4                     ; get this pixel - not spaced out one
        ConvertPixelPlusRGBTo8bit
        Save8bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        Add5_16ToNextLinePrevPix
        Add3_16ToNextLinePix
        Add1_16ToNextLineNextPix
        CutRGBby7_16
        AdvanceLineAbove
        SUBS    d_count,d_count,#1
        BNE     dither_each_pixel_in_first_line
; now the very last pixel in the line
dither_first_line_last_pixel
        LDR     d_t1,[d_inptr],#4                     ; get this pixel - not spaced out one
        ConvertPixelPlusRGBTo8bit
        Save8bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        Add5_16ToNextLinePrevPix
        Add3_16ToNextLinePix
        ; 1/16+7/16 of error gets thrown away
        AdvanceLineAboveForLastInLine
dither_first_line_done

; Now the loop for each line in the middle - pixels picked up will be spaced out ones.
dither_each_line

        ASSERT  d_inptr=0 :LAND: d_count=1 :LAND: d_outptr=2
        LDMIA   sp,{r0-r2}                            ; d_inptr,d_count,d_outptr
        MOV     d_t1,r0
        LDR     d_nextline,[d_t1,#4]                  ; pointer to line above d_inptr
        LDR     d_inptr,[d_t1],#4                     ; pointer to first input line
        STR     d_t1,[sp,#0*4]                        ; ripple inrows by 1
        LDR     d_t2,[sp,#14*4+4]                     ; recover xmin
        MOV     d_t1,r2
        LDR     d_outptr,[d_t1],#4                    ; pointer to output line
        STR     d_t1,[sp,#2*4]                        ; ripple outrows by 1
        ADD     d_nextline,d_nextline,d_t2,LSL#2      ; don't bother dithering outside the clipping box
        ADD     d_inptr,d_inptr,d_t2,LSL#2
        ADD     d_outptr,d_outptr,d_t2,LSL#0

        MOV     d_r,#0                                ; initial cumulative error is 0
        MOV     d_g,#0
        MOV     d_b,#0

        LDR     d_t1,[sp,#14*4+0]                     ; get line count
        SUBS    d_t1,d_t1,#1
        CMP     d_t1,#1                               ; we didn't count for the first line, nor the last
        BLE     dither_each_pixel_in_last_line        ; time to do very last line
        STR     d_t1,[sp,#14*4+0]                     ; save for next time

        LineAboveStartup
        SUBS    d_count,d_count,#1                    ; line is one pixel long, fake as last
        BEQ     dither_last_pixel
; Start processing the first pixel
        LDR     d_t1,[d_inptr],#4                     ; get very first pixel
        ConvertSpacedPixelPlusRGBTo8bit
        Save8bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        Add8_16ToNextLinePix                          ; 3/16 + 5/16 sent upwards, since NextLinePrevPix doesn't exit.
        Add1_16ToNextLineNextPix
        CutRGBby7_16
        AdvanceLineAboveForFirstInLine
        SUBS    d_count,d_count,#1
        BEQ     dither_last_pixel                     ; line is two pixels long
; now the loop for most of the pixels
dither_each_pixel
        LDR     d_t1,[d_inptr],#4                     ; get this pixel - not spaced out one
        ConvertSpacedPixelPlusRGBTo8bit
        Save8bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        Add5_16ToNextLinePrevPix
        Add3_16ToNextLinePix
        Add1_16ToNextLineNextPix
        CutRGBby7_16
        AdvanceLineAbove
        SUBS    d_count,d_count,#1
        BNE     dither_each_pixel
; now the very last pixel in the line
dither_last_pixel
        LDR     d_t1,[d_inptr],#4                     ; get this pixel - not spaced out one
        ConvertSpacedPixelPlusRGBTo8bit
        Save8bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        Add5_16ToNextLinePrevPix
        Add3_16ToNextLinePix
        Add8_16ToNextLinePix                          ; 3/16 + 7/16 + 1/16 sent upwards, since no pixels to right of here.
        AdvanceLineAboveForLastInLine

        B       dither_each_line

; And the final line - all errors propagated to the right.
; On the last line all pixels are treated the same.
; Registers for the loop have already been set up, at the start of the main loop.
dither_each_pixel_in_last_line
        LDR     d_t1,[d_inptr],#4                     ; get this pixel - not spaced out one
        ConvertSpacedPixelPlusRGBTo8bit
        Save8bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        CutRGBby12_16
        SUBS    d_count,d_count,#1
        BNE     dither_each_pixel_in_last_line

dither_each_line_exit
; Done, finished, finito.
        ADD     sp,sp,#4*4                            ; it's a void function
        LDMIA   sp!,{r4-r12,pc}

; --------------------------------------------------------------------------------------
;
; extern void asm_diffuse_to_24bpp(JSAMPARRAY inrows, int count, JSAMPARRAY outrows, char *table,
;                                  int nlines, int xmin, const int *palette);
;
; --------------------------------------------------------------------------------------
; Rows of pixels at   inrows[0..nlines-1]         nlines >= 2
; Each row comprises  pix[0..count-1]             count >= 1
; Only want from xmin pixels onwards in each row, xmin is a multiple of 16
; Table, if non-zero, is a 32K lookup table that converts 15bit RGB values to 8-bit pixels.
;
; Diffuse into 24bit values that are all contained within source palette.

        EXPORT  asm_diffuse_to_24bpp
asm_diffuse_to_24bpp
; The first line is special because the input pixels are in un-spaced-out format.
        STMDB   sp!,{r0-r12,lr}                       ; we need them all!
        ; d_count, d_table already set up
        MOV     d_t1,r0
        LDR     d_nextline,[d_t1,#4]                  ; pointer to line above d_inptr
        LDR     d_inptr,[d_t1],#4                     ; pointer to first input line
        STR     d_t1,[sp,#0*4]                        ; ripple inrows by 1
        LDR     d_t2,[sp,#14*4+4]                     ; recover xmin
        MOV     d_t1,r2
        LDR     d_outptr,[d_t1],#4                    ; pointer to output line
        STR     d_t1,[sp,#2*4]                        ; ripple outrows by 1
        ADD     d_nextline,d_nextline,d_t2,LSL#2      ; don't bother dithering outside the clipping box
        ADD     d_inptr,d_inptr,d_t2,LSL#2
        ADD     d_outptr,d_outptr,d_t2,LSL#2
        LDR     d_palette, [sp,#14*4+8]

        MOV     d_r,#0
        MOV     d_g,#0
        MOV     d_b,#0

        LineAboveStartup
        SUBS    d_count,d_count,#1
        BEQ     dither24_first_line_last_pixel        ; lines are just one pixel long
; Start processing the first pixel
        LDR     d_t1,[d_inptr],#4                     ; get very first pixel
        ConvertPixelPlusRGBTo8bit
        Save24bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        ; 5/16ths of the error is thrown away
        Add3_16ToNextLinePix
        Add1_16ToNextLineNextPix
        CutRGBby7_16
        AdvanceLineAboveForFirstInLine
; now the loop for most of the pixels in the first line
        SUBS    d_count,d_count,#1
        BEQ     dither24_first_line_last_pixel          ; lines are just two pixels long
dither24_each_pixel_in_first_line
        LDR     d_t1,[d_inptr],#4                     ; get this pixel - not spaced out one
        ConvertPixelPlusRGBTo8bit
        Save24bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        Add5_16ToNextLinePrevPix
        Add3_16ToNextLinePix
        Add1_16ToNextLineNextPix
        CutRGBby7_16
        AdvanceLineAbove
        SUBS    d_count,d_count,#1
        BNE     dither24_each_pixel_in_first_line
; now the very last pixel in the line
dither24_first_line_last_pixel
        LDR     d_t1,[d_inptr],#4                     ; get this pixel - not spaced out one
        ConvertPixelPlusRGBTo8bit
        Save24bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        Add5_16ToNextLinePrevPix
        Add3_16ToNextLinePix
        ; 1/16+7/16 of error gets thrown away
        AdvanceLineAboveForLastInLine
dither24_first_line_done

; Now the loop for each line in the middle - pixels picked up will be spaced out ones.
dither24_each_line

        ASSERT  d_inptr=0 :LAND: d_count=1 :LAND: d_outptr=2
        LDMIA   sp,{r0-r2}                            ; d_inptr,d_count,d_outptr
        MOV     d_t1,r0
        LDR     d_nextline,[d_t1,#4]                  ; pointer to line above d_inptr
        LDR     d_inptr,[d_t1],#4                     ; pointer to first input line
        STR     d_t1,[sp,#0*4]                        ; ripple inrows by 1
        LDR     d_t2,[sp,#14*4+4]                     ; recover xmin
        MOV     d_t1,r2
        LDR     d_outptr,[d_t1],#4                    ; pointer to output line
        STR     d_t1,[sp,#2*4]                        ; ripple outrows by 1
        ADD     d_nextline,d_nextline,d_t2,LSL#2      ; don't bother dithering outside the clipping box
        ADD     d_inptr,d_inptr,d_t2,LSL#2
        ADD     d_outptr,d_outptr,d_t2,LSL#2

        MOV     d_r,#0                                ; initial cumulative error is 0
        MOV     d_g,#0
        MOV     d_b,#0

        LDR     d_t1,[sp,#14*4+0]                     ; get line count
        SUBS    d_t1,d_t1,#1
        CMP     d_t1,#1                               ; we didn't count for the first line, nor the last
        BLE     dither24_each_pixel_in_last_line      ; time to do very last line
        STR     d_t1,[sp,#14*4+0]                     ; save for next time

        LineAboveStartup
        SUBS    d_count,d_count,#1                    ; line is one pixel long, fake as last
        BEQ     dither24_last_pixel
; Start processing the first pixel
        LDR     d_t1,[d_inptr],#4                     ; get very first pixel
        ConvertSpacedPixelPlusRGBTo8bit
        Save24bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        Add8_16ToNextLinePix                          ; 3/16 + 5/16 sent upwards, since NextLinePrevPix doesn't exit.
        Add1_16ToNextLineNextPix
        CutRGBby7_16
        AdvanceLineAboveForFirstInLine
        SUBS    d_count,d_count,#1
        BEQ     dither24_last_pixel                   ; line is two pixels long
; now the loop for most of the pixels
dither24_each_pixel
        LDR     d_t1,[d_inptr],#4                     ; get this pixel - not spaced out one
        ConvertSpacedPixelPlusRGBTo8bit
        Save24bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        Add5_16ToNextLinePrevPix
        Add3_16ToNextLinePix
        Add1_16ToNextLineNextPix
        CutRGBby7_16
        AdvanceLineAbove
        SUBS    d_count,d_count,#1
        BNE     dither24_each_pixel
; now the very last pixel in the line
dither24_last_pixel
        LDR     d_t1,[d_inptr],#4                     ; get this pixel - not spaced out one
        ConvertSpacedPixelPlusRGBTo8bit
        Save24bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        Add5_16ToNextLinePrevPix
        Add3_16ToNextLinePix
        Add8_16ToNextLinePix                          ; 3/16 + 7/16 + 1/16 sent upwards, since no pixels to right of here.
        AdvanceLineAboveForLastInLine

        B       dither24_each_line

; And the final line - all errors propagated to the right.
; On the last line all pixels are treated the same.
; Registers for the loop have already been set up, at the start of the main loop.
dither24_each_pixel_in_last_line
        LDR     d_t1,[d_inptr],#4                     ; get this pixel - not spaced out one
        ConvertSpacedPixelPlusRGBTo8bit
        Save24bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        CutRGBby12_16
        SUBS    d_count,d_count,#1
        BNE     dither24_each_pixel_in_last_line

dither24_each_line_exit
; Done, finished, finito.
        ADD     sp,sp,#4*4                            ; it's a void function
        LDMIA   sp!,{r4-r12,pc}

        END
@


4.10
log
@Import of IJG8d library sources
Detail:
  Using the decoder in "example.c" as a starting point, we try to follow that sequence more closely even if in our embedded implementation some of the functions don't do much.
  Uses the default colour backend for 32bpp BGR output for most of the unusual cases.
  The most common 2x2 subsampling case uses a custom merged upsampler and colour converter, with colour output directly in RISC OS format for the respective screen mode.
Admin:
  Submission for the JPEG bounty.

Version 1.71. Tagged as 'SprExtend-1_71'
@
text
@a430 3
      [ cfsi_jpeg
; Skip test as !ChangeFSI wont run on UtilityModule < 3.60
      |
a438 1
      ]
@


4.9
log
@Adopt colour conversions from MigrateIJG8b branch
Now for every colour conversion there is a corresponding C function, allowing swapping between them for test purposes.
Here, 'ASMCOLOR' is selected and the C functions not even referenced in the makefile, see branch for use.
Permits use of USAT, for a small 1.5% speedup and smaller code.
Some other typedefs and comment shuffling copied over - should be harmless.

Version 1.50. Tagged as 'SprExtend-1_50'
@
text
@d17 1
a17 1
; Error diffusion for 8bpp JPEG output
a88 8
; Potential desirable code variants:
;   for 4bpp
;   no 32K table - got to do 16->8 algorithmically (on RO3)
;   arbitrary dest palette - need palette ptr on stack?
;   faster version for monochrome (could be combined with the 4bpp one?)
; Dynamic code generation is obviously desirable here, but we can get
; by without it.

d101 2
a102 2
d_nlnpix RN     6           ; = [nextline,#4]
d_palette RN    11          ; = &101010 - useful in some of the expansion calculations.
a105 7
; The palette, which converts 8bit pixels back to their true RGB values,
; could be located PC-relative.
; >>> not so good for arbitrary palette... How about LDR from SP?
; Probably necessary, I guess. Any cheaper way of saving a register?
;   inptr,d_nextline,d_count,outptr -> ?
; dynamic assembly would let outptr be a constant from inptr.

a117 3
; to get the next pixel:
;        MOV     d_t1,[d_inptr],#4           ; get this pixel

a128 15
        MACRO
        MakePixelGrey $r,$temp
;        BIC     $temp.,$r.,#&100
        AND     $temp.,$r.,#&ff
        ADD     $temp.,$temp.,$r.,LSR #16
        BIC     $r.,$r.,#&80
        BIC     $r.,$r.,#&10000
        ADD     $temp.,$temp.,$r.,LSR #7
        MOV     $temp.,$temp.,LSL #22
        MOV     $r.,$temp.,LSR #24
;        MOV     $temp.,$temp.,LSR #24
;        ORR     $temp.,$temp.,$temp.,LSL #8
;        ORR     $r.,$temp.,$temp.,LSL #8
        MEND

a146 17
;        ADD     d_t2,d_t1,d_t1,LSR #20
;        BIC     d_t1,d_t1,#&200
;        ADD     d_t2,d_t2,d_t1,LSR #9
;        MOV     d_t2,d_t2,LSL #20
;        MOV     d_t2,d_t2,LSR #22
;
;        ADD     d_r,d_r,d_t2
;        SUBS    d_r,d_r,#&180
;        MOVLT   d_r,#0
;        ADD     d_g,d_g,d_t2
;        SUBS    d_g,d_g,#&180
;        MOVLT   d_g,#0
;        ADD     d_b,d_b,d_t2
;        SUBS    d_b,d_b,#&180
;        MOVLT   d_b,#0
;        ClipAbove

a160 13
;        MACRO
;        Convert5bitRGBTo16bit
;        ; common tail for Convert[Spaced]RGBTo16bit
;        CMP     d_r,#31
;        MOVGT   d_r,#31
;        CMP     d_g,#31
;        MOVGT   d_g,#31
;        CMP     d_b,#31
;        MOVGT   d_b,#31
;        ORR     d_t1,d_r,d_g,LSL #5
;        ORR     d_t1,d_t1,d_b,LSL #10
;        MEND

a171 27
; Rounding version:
;        MACRO
;        ConvertRGBTo16bit
;        ADD     d_t2,d_r,#4                   ; could make >255! Frig constants in ClipAbove to 251 if using this.
;        MOV     d_t1,d_t2,ASR #3
;        CMP     d_g,#250
;        ADD     d_t2,d_g,#4
;        MOV     d_t2,d_t2,ASR #3
;        ORR     d_t1,d_t1,d_t2,LSL #5
;        ADD     d_t2,d_b,#4
;        MOV     d_t2,d_t2,ASR #3
;        ORR     d_t1,d_t1,d_t2,LSL #10
;        MEND

;        MACRO
;        ConvertRGBMinus128To16bit
;        ; Use this one after adding in a spaced pixel.
;        MOV     d_t1,#16
;;       RSBS    d_r,d_t1,d_r,LSR #3
;        MOVLT   d_r,#0
;        RSBS    d_g,d_t1,d_g,LSR #3
;        MOVLT   d_g,#0
;        RSBS    d_b,d_t1,d_b,LSR #3
;        MOVLT   d_b,#0
;        Convert5bitRGBTo16bit
;        ; d_t1 contains a 15bit RGB value
;        MEND
a217 1

d321 1
a321 1
        ADD     d_nlnpix,d_nlnpix,d_r,ASR #4          ; d_r>>4
d323 2
a324 2
;        ADD     d_nlnpix,d_nlnpix,d_t1,LSL #9
        ADD     d_nlnpix,d_nlnpix,d_t1,LSL #10
d326 2
a327 2
;        ADD     d_nlnpix,d_nlnpix,d_t1,LSL #18
        ADD     d_nlnpix,d_nlnpix,d_t1,LSL #20
d384 3
a386 3
        MOV     d_nlpix,d_nlnpix
        LDR     d_nlnpix,[d_nextline],#4
        SpaceOutPixel d_nlnpix,d_t1
d397 2
a398 2
        LDR     d_nlnpix,[d_nextline],#4
        SpaceOutPixel d_nlnpix,d_t1
d405 3
a407 3
        MOV     d_nlpix,d_nlnpix
        LDR     d_nlnpix,[d_nextline],#4
        SpaceOutPixel d_nlnpix,d_t1
a416 4
; to advance to the next pixel:
;        SUBS    d_count,d_count,#1
;        BNE     dither_each_pixel

a417 1
; 23
d423 1
a423 1
; extern char *asm_get_table32k(int *palette_data);
d477 2
a478 2
; extern void asm_diffuse_to_8bpp(int *line, int linelength, char *output, char *table, int nlines, int linestep,
;                                 int *palette);
d481 7
a487 12
; pixels in
;   line[0..linelength-1]..line[(nlines-1)*linestep..(nlines-1)*linestep+linelength-1]
; should be converted into 8-bit pixels as best you can.
; The output pixels should be placed at
;   output[0..linelength-1]..output[(nlines-1)*linestep*sizeof(int)..(nlines-1)*linestep*sizeof(int)+linelength-1].

; In particular, note that 'linestep' is a word offset.
; table, if non-zero, is a 32K lookup table that converts 15bit RGB values to 8-bit pixels.
; You may trample on the input pixels if need be. In fact, (void*)output may equal (void*)line
; initially, if you do things in the obvious order it won't matter.

; linelength >= 3, nlines >= 3.
d494 12
a505 3
        ; d_inptr,d_count,d_outptr,d_table already set up, and will need to get reloaded
        LDR     d_nextline,[sp,#14*4+4]               ; get 'linestep' argument
        ADD     d_nextline,d_inptr,d_nextline,LSL #2  ; construct pointer to line above d_inptr
d511 1
d558 13
a570 6
        LDMIA   sp,{r0-r3}                            ; d_inptr,d_count,d_outptr,d_table reset
        LDR     d_nextline,[sp,#14*4+4]               ; get 'linestep' argument
        ADD     d_inptr,d_inptr,d_nextline,LSL #2     ; construct pointer to line above d_inptr
        ADD     d_outptr,d_outptr,d_nextline,LSL #2   ; construct pointer to line above d_outptr
        ADD     d_nextline,d_inptr,d_nextline,LSL #2  ; and pointer to next line
        STMIA   sp,{r0-r2}                            ; save back d_inptr and d_outptr
d576 1
a576 1
        LDR     d_t1,[sp,#14*4]                       ; get line count
d579 2
a580 2
        BLE     dither_each_line_exit                 ; time to do very last line
        STR     d_t1,[sp,#14*4]                       ; save for next time
a623 1
dither_each_line_exit
d625 1
a625 1
; And the final line - all errors propogated to the right.
d638 1
d640 2
a641 1
        LDMIA   sp!,{r0-r12,pc}
d645 2
a646 2
; extern void asm_diffuse_to_24bpp(int *line, int linelength, char *output, char *table, int nlines, int linestep,
;                                  int *palette);
d649 6
a654 4
; pixels in
;   line[0..linelength-1]..line[(nlines-1)*linestep..(nlines-1)*linestep+linelength-1]

; diffuse into 24bit values that are all contained within source palette.
d660 12
a671 3
        ; d_inptr,d_count,d_outptr,d_table already set up, and will need to get reloaded
        LDR     d_nextline,[sp,#14*4+4]               ; get 'linestep' argument
        ADD     d_nextline,d_inptr,d_nextline,LSL #2  ; construct pointer to line above d_inptr
d724 13
a736 6
        LDMIA   sp,{r0-r3}                            ; d_inptr,d_count,d_outptr,d_table reset
        LDR     d_nextline,[sp,#14*4+4]               ; get 'linestep' argument
        ADD     d_inptr,d_inptr,d_nextline,LSL #2     ; construct pointer to line above d_inptr
        ADD     d_outptr,d_outptr,d_nextline,LSL #2   ; construct pointer to line above d_outptr
        ADD     d_nextline,d_inptr,d_nextline,LSL #2  ; and pointer to next line
        STMIA   sp,{r0-r2}                            ; save back d_inptr and d_outptr
d742 1
a742 1
        LDR     d_t1,[sp,#14*4]                       ; get line count
d745 2
a746 2
        BLE     dither24_each_line_exit               ; time to do very last line
        STR     d_t1,[sp,#14*4]                       ; save for next time
a789 1
dither24_each_line_exit
d791 1
a791 1
; And the final line - all errors propogated to the right.
d804 1
d806 2
a807 1
        LDMIA   sp!,{r0-r12,pc}
@


4.8
log
@Remove postprocessing step of C code.
Since 2001 this module has been using objasm, but still using the C compiler to output (via -S) assembly code which is then passed through 'sed' and included via GET into the assembler code.
Changed to compile the C code into object files, and use the linker to patch up the unresolved references - this has required some reordering of the C code to make sure static functions now appear in the object file, and some reordering of the header files to ensure both the module and the CFSI version still compile without conflicts.
Minor fix to 'swiv2', the label was in the wrong place for _swi() though it's not used in this module so didn't affect the _swix() case.
Makefile cut down a bit. Unixify some path names.
Test code moved to 'Test/c' directory.
Tested in both debug and non debug cases via softloaded module. Oddly, it's 4 bytes longer than the previous version.

Version 1.28. Tagged as 'SprExtend-1_28'
@
text
@d15 2
a17 1

d106 1
a106 1
d_nextline RN  10           ; -> line above inptr, two pixels ahead
d345 9
a353 9
         MACRO
         Subtract32bitFromRGB
         ; d_t1=32 bit pixel - subtract it from R,G,B
         AND     d_t2,d_t1,#&ff00
         SUB     d_r,d_r,d_t2,LSR #8
         AND     d_t2,d_t1,#&ff0000
         SUB     d_g,d_g,d_t2,LSR #16
         SUB     d_b,d_b,d_t1,LSR #24
         MEND
d451 16
a466 16
        AND        $temp.,$r.,#&ff0000
        ADD        $r.,$r.,$temp.                     ; shift b up one
        ADD        $r.,$r.,$temp.,LSL #1              ; shift b up another 1
        BIC        $temp.,$r.,#&ff
        ADD        $r.,$r.,$temp.                     ; shift g,b up one
        ADD        $r.,$r.,$temp.,LSL #1              ; shift g,b up another 1
        ADD        $r.,$r.,#&180
        ADD        $r.,$r.,#&180:SHL:10
        ADD        $r.,$r.,#&180:SHL:20
;        AND        $temp.,$r.,#&ff0000
;        ADD        $r.,$r.,$temp.                     ; shift b up one
;        BIC        $temp.,$r.,#&ff
;        ADD        $r.,$r.,$temp.                     ; shift g,b up one
;        ADD        $r.,$r.,#128
;        ADD        $r.,$r.,#128:SHL:9
;        ADD        $r.,$r.,#128:SHL:18
d667 2
a668 2
        SUBS     d_count,d_count,#1                   ; line is one pixel long, fake as last
        BEQ      dither_last_pixel
d679 2
a680 2
        SUBS     d_count,d_count,#1
        BEQ      dither_last_pixel                    ; line is two pixels long
d810 1
a810 1
        BLE     dither24_each_line_exit                 ; time to do very last line
d814 2
a815 2
        SUBS     d_count,d_count,#1                   ; line is one pixel long, fake as last
        BEQ      dither24_last_pixel
d826 2
a827 2
        SUBS     d_count,d_count,#1
        BEQ      dither24_last_pixel                    ; line is two pixels long
@


4.8.2.1
log
@Reinstate jrevdct4 option to use C code IDCT (switch "ASMIDCT").
Name inverse DCT to match IJG 8b integer fast implementation.
Remove -DEMBED option and collapse switches.
Useful for speed comparisons.

Version 1.38, 1.35.2.4. Tagged as 'SprExtend-1_38-1_35_2_4'
@
text
@d15 1
a15 1
; > Sources.diffuse
a16 1
; Error diffusion for 8bpp JPEG output
@


4.8.2.2
log
@Use USAT in 150 occurrences of colour clamping for ARMv6 and later.
Some IDCT renaming.
Shock addition of some documentation on how it all works.
Mirror fix from 1.39 on the trunk.
Debug
 Made DEBUG version compile again, earlier header shuffling was preventing it.
 Replaced the ' _ ' method of variadic macro emulation with more familiar double brackets for tracef().
 Eliminated IFDEBUG macro and just used #ifdef DEBUG/#endif or tracef() directly.
 Don't bother passing the line number and file name to exit() when in the non DEBUG case.

Version 1.38, 1.35.2.8. Tagged as 'SprExtend-1_38-1_35_2_8'
@
text
@d106 1
a106 1
d_nextline RN   10          ; -> line above inptr, two pixels ahead
d345 9
a353 9
        MACRO
        Subtract32bitFromRGB
        ; d_t1=32 bit pixel - subtract it from R,G,B
        AND     d_t2,d_t1,#&ff00
        SUB     d_r,d_r,d_t2,LSR #8
        AND     d_t2,d_t1,#&ff0000
        SUB     d_g,d_g,d_t2,LSR #16
        SUB     d_b,d_b,d_t1,LSR #24
        MEND
d451 16
a466 16
        AND     $temp.,$r.,#&ff0000
        ADD     $r.,$r.,$temp.                     ; shift b up one
        ADD     $r.,$r.,$temp.,LSL #1              ; shift b up another 1
        BIC     $temp.,$r.,#&ff
        ADD     $r.,$r.,$temp.                     ; shift g,b up one
        ADD     $r.,$r.,$temp.,LSL #1              ; shift g,b up another 1
        ADD     $r.,$r.,#&180
        ADD     $r.,$r.,#&180:SHL:10
        ADD     $r.,$r.,#&180:SHL:20
;        AND     $temp.,$r.,#&ff0000
;        ADD     $r.,$r.,$temp.                     ; shift b up one
;        BIC     $temp.,$r.,#&ff
;        ADD     $r.,$r.,$temp.                     ; shift g,b up one
;        ADD     $r.,$r.,#128
;        ADD     $r.,$r.,#128:SHL:9
;        ADD     $r.,$r.,#128:SHL:18
d667 2
a668 2
        SUBS    d_count,d_count,#1                    ; line is one pixel long, fake as last
        BEQ     dither_last_pixel
d679 2
a680 2
        SUBS    d_count,d_count,#1
        BEQ     dither_last_pixel                     ; line is two pixels long
d810 1
a810 1
        BLE     dither24_each_line_exit               ; time to do very last line
d814 2
a815 2
        SUBS    d_count,d_count,#1                    ; line is one pixel long, fake as last
        BEQ     dither24_last_pixel
d826 2
a827 2
        SUBS    d_count,d_count,#1
        BEQ     dither24_last_pixel                   ; line is two pixels long
@


4.7
log
@Fix two bugs causing aborts on corner cases.
1 pixel wide JPEGs:
The diffuse dithering code considers all lines as 1-N-1 where N can be zero and the first and last pixel are dealt with specially because there's no data to scatter beyond the edge.
With a 1 pixel wide JPEG the dithering code ended up with a -ve number in the X counter and wandered off the end of memory. Fix just moves a SUB up a few lines and turns it into a SUBS so that the 1 wide case becomes 0-N-1 with N=0.
1 pixel high sprites:
With output switched to a 1 pixel high sprite an abort would quickly follow because the read of mode variables had a backdoor check to workaround a bug in RISC OS 2.00 which returned a duff value for YWindLimit in MODE 22. As the definition of MODE 22 got changed to 768x288 in RISC OS 3.xx (and the YWindLimit bug fixed) this code now just falsely reported a 1 pixel high sprite as being 1024 high and the blitter splattered all over memory it shouldn't.
Result:
Loss of RISC OS 2.00 compatibility, but can now load JPEGs of Xx1 or 1xY and even 1x1.

Version 1.25. Tagged as 'SprExtend-1_25'
@
text
@d523 1
d589 1
d736 1
@


4.6
log
@Clean up pass.
Trim 200+ lines of changes dating back to 1987, combine with non duplicates in the 'BlackLog'.
Use 'offsetof' macro in genjhdr to avoid warnings about uninitialised variables, rename from makejhdr so all the utils are clearly demarked.
Add throwback to MkCFSI-j.
Replace reason codes passed to SWIs with textual equivalents from the respective header files.
Speed up SWI despatch a bit by making the first few debug instructions depend on 'debuggs'.
Qualify all of the debug switches with the global 'debug' one.
Eliminate single use of 'pullx' macro.
Make do_branch() take an unsigned opcode so 50% of the branches don't result in implied cast warnings.
Added an UNUSED() macro to reduce a few of the legitimate warnings (the remainder are either in the original JPEG code or ones that it is worth checking the logic of.
Unixify one last filename.

Version 1.24. Tagged as 'SprExtend-1_24'
@
text
@d601 2
a613 2
        SUBS    d_count,d_count,#1
        BEQ     dither_first_line_done               ; lines are just one pixel long
a662 1
        SUB     d_count,d_count,#1                    ; number of pix in line excluding first and last
d664 2
a722 1

a735 1

d745 1
d747 2
a759 2
        SUBS    d_count,d_count,#1
        BEQ     dither24_first_line_done               ; lines are just one pixel long
a808 1
        SUB     d_count,d_count,#1                    ; number of pix in line excluding first and last
d810 2
@


4.5
log
@A few small fixes.
Sources/PutScaled:
 Sync comment with C code.
Sources/SprExtend:
 Debug switch 'debuggs' had been left on, which left in some unnecessary code, but turning it off pulled in code with a stack imbalance. Now off.
 Ensured a terminator at the end of the RMEnsure.
 Colour translation tables passed to SetPointerShape that were in top bit set addresses were being interpreted as though no tt was supplied. Now tested against zero to match docs.
Sources/SprTrans:
 Switches pre 0.60 collapsed.
Sources/diffuse:
 The C code was corrupting r12 workspace pointer so the check of the flag 'ctrans_recent' sometimes failed leading to a duff table lookup.
 Small optimisation to checking of guard word.
c/PutScaled:
 Change paths to be Unix friendly.
rojpeg:
 Put assembler_panic in the header file to shut the compiler up.
3x unused files deleted.

Version 1.23. Tagged as 'SprExtend-1_23'
@
text
@d539 1
a539 1
        MOV     r0,#6:SHL:27
d572 1
a572 1
;                                  int palette);
a582 1
; NB The palette built in to this code assumes that this is the default 8bpp palette.
a594 1
;        ADRL    d_palette,standard_palette
d726 1
a726 1
;                                  int palette);
a740 1
;        ADRL    d_palette,standard_palette
@


4.4
log
@Performance improvement and code tidy-up.

Removed local definition of XOS_CLI and XColourTrans_SelectTable, replaced
with header file.

Delete swiv2_old (moved to _old directory)

Changed to use {TRUE} and {FALSE} built in objasm variables.

Label dividebyzero fall through had code in the way for debug = {TRUE}.

Trimmed some dead code and definitions.

Stopped thrashing OS_CLI every time a JPEG plot is required to check
ColourTrans version, this is now done once at startup and a flag kept
instead.

Author: Rob Sprowson

Version 1.19. Tagged as 'SprExtend-1_19'
@
text
@d334 1
a334 1
        STR    d_t1,[d_outptr],#4
d518 1
a518 1
; extern char *asm_get_table32k(int *palette_data/*void*/);
a524 1
        MOV     r7, r0
d530 4
a533 2
        LDR     r0, ctrans_recent
        TEQ     r0, #0
d538 1
a538 1
        SUB     sp,sp,#12                     ; memory block for ColourTrans to put result in
d543 1
a543 1
        MOV     r3,r7
d550 3
a552 5
        LDR     r0,[sp]                       ; should be a guard word
        LDR     r1,asm_table32k_guard         ; check first guard word
        CMP     r0,r1
        BNE     asm_get_table32k_fail
        LDR     r0,[sp,#8]                    ; check second guard word
d554 2
@


4.3
log
@32-bit compatible. Tagged as SprExtend-1_06
@
text
@a342 10
;         MACRO
;         Subtract32bitFromRGB
;         ; d_t1=32 bit pixel - subtract it from R,G,B
;         AND     d_t2,d_t1,#255
;         SUB     d_r,d_r,d_t2
;         AND     d_t2,d_t1,#&ff00
;         SUB     d_g,d_g,d_t2,LSR #8
;         SUB     d_b,d_b,d_t1,LSR #16
;         MEND

a521 3
       [ cfsi_jpeg
XColourTrans_SelectTable * &40740 + (1:SHL:17)
       ]
d526 3
d531 5
a535 5
        ADR     r0,asm_checkColourTrans
        SWI     XOS_CLI                       ; *RMEnsure ColourTrans 1.25 Error no good
        MOVVS   r0,#0                         ; error return - not new ColourTrans
        LDMVSIA sp!,{r4-r7,pc}                ; so return with no table.

a567 36
asm_checkColourTrans
        DCB     "RMEnsure ColourTrans 1.25 Error no good", 0 ; any error will do
        ALIGN

; --------------------------------------------------------------------------------------
;
; extern void asm_diffuse_line_to_8bpp(int *line, int linelength, char *output, char *table);
;
; --------------------------------------------------------------------------------------

; The relatively simple case of right-only diffusion. Only a single line is
; involved, no spaced-out pixels anywhere.

;asm_diffuse_line_to_8bpp
;; in: d_inptr, d_count, d_outptr, d_table already set up
;
;        STMDB   sp!,{r4-r12,lr}                       ; save all registers
;        MOV     d_r,#0
;        MOV     d_g,#0
;        MOV     d_b,#0
;        ADR     d_palette,standard_palette
;
;diffuse_line_loop
;        LDR     d_t1,[d_inptr],#4                     ; get a pixel
;        ConvertPixelPlusRGBTo8bit                     ; convert to 8-bit pixel in d_t1
;        Save8bitPixel                                 ; save it at d_outptr
;        GetTrueRGBof8bitPixel                         ; get as 32-bit value in d_t1
;        Subtract32bitFromRGB                          ; subtract this from r,g,b
;        SUBS    d_count,d_count,#1
;        BNE     diffuse_line_loop                     ; and loop round - any error from this pixel is added to the next.
;
;        LDMIA   sp!,{r4-r12,pc}

;standard_palette
;        GET     s.stdpalette

a869 45

;asm_convert_to_8bpp_grey
;; In:
;;  r0 = in pointer
;;  r1 = words per line
;;  r2 = out pointer
;;  r3 = number of lines
;
;        STMDB   sp!,{r0-r12,lr}                       ; we need them all!
;
;        ; d_inptr,d_count,d_outptr,d_table already set up, and will need to get reloaded
;        LDR     r4,[sp,#14*4]                        ; get 'linestep' argument
;;        LDR     r5,[sp,#14*4]                          ; get line count
;
;        MOV     r6, r0
;        MOV     r7, r2
;togrey_nextline
;        MOV     r0,r6
;        MOV     r2,r7
;        ADD     r6,r0,r4,LSL #2                        ; start of next line.
;        ADD     r7,r2,r4,LSL #2                        ; start of next line.
;        MOV     r5,#4
;        MOV     r11,#0
;        MOV     r8, r1                                 ;count
;togrey_nextpixel
;        LDR     r9, [r0],#4
;        MakePixelGrey r9, r10
;        AND     r9, r9, #&ff
;        ORR     r11, r11, r9
;        MOV     r11, r11, ROR #8
;        SUBS    r5, r5, #1
;        STREQ   r11, [r2],#4
;        MOVEQ   r5, #4
;        MOVEQ   r11, #0
;        SUBS    r8, r8, #1
;        BGT     togrey_nextpixel
;        CMP     r5,#4
;        MOVNE   r5,r5,LSL #3
;        MOVNE   r11, r11, ROR r5
;        SUBS    r3, r3, #1
;        BGT     togrey_nextline
;
;
;        LDMIA   sp!,{r0-r12,pc}

@


4.2
log
@Version RO_3_70 taken
@
text
@d184 1
a184 1
;        
d195 1
a195 1
        
d384 2
a385 2
        ADD     d_nlprevpix,d_nlprevpix,d_r,ASR #2    
        MOV     d_t1,d_g,ASR #1                      
d387 1
a387 1
        MOV     d_t1,d_g,ASR #1                      
d535 1
a535 1
       
d544 1
a544 1
        LDMVSIA sp!,{r4-r7,pc}^               ; so return with no table.
d568 1
a568 1
        LDMIA   sp!,{r4-r7,pc}^               ; return
d573 1
a573 1
        LDMIA   sp!,{r4-r7,pc}^
d609 1
a609 1
;        LDMIA   sp!,{r4-r12,pc}^
d616 1
a616 1
; extern void asm_diffuse_to_8bpp(int *line, int linelength, char *output, char *table, int nlines, int linestep, 
d767 1
a767 1
        LDMIA   sp!,{r0-r12,pc}^
d772 1
a772 1
; extern void asm_diffuse_to_24bpp(int *line, int linelength, char *output, char *table, int nlines, int linestep, 
d914 1
a914 1
        LDMIA   sp!,{r0-r12,pc}^
d925 1
a925 1
;        
d929 1
a929 1
;        
d958 2
a959 2
;     
;        LDMIA   sp!,{r0-r12,pc}^
@


4.1
log
@Initial revision
@
text
@d146 15
d179 17
a207 12
;        MOV     d_t2,d_t1,LSL #23            ; get red, in top 9 bits
;        ADD     d_r,d_r,d_t2,LSR #23
;        SUBS    d_r,d_r,#128
;        MOVLT   d_r,#0
;        MOV     d_t2,d_t1,LSL #14            ; get green
;        ADD     d_g,d_g,d_t2,LSR #23
;        SUBS    d_g,d_g,#128
;        MOVLT   d_g,#0
;        ADD     d_b,d_b,d_t1,LSR #18        ; add in blue
;        SUBS    d_b,d_b,#128
;        MOVLT   d_b,#0
;        ClipAbove
d331 6
d528 1
a528 1
; extern char *asm_get_table32k(void);
d538 1
a538 1

d552 1
a552 1
        MOV     r3,#-1
a642 1
;        Debug   gs,"Palette located at ", d_palette   ;R11?
d768 192
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a145 15
        MACRO
        MakePixelGrey $r,$temp
;        BIC     $temp.,$r.,#&100
        AND     $temp.,$r.,#&ff
        ADD     $temp.,$temp.,$r.,LSR #16
        BIC     $r.,$r.,#&80
        BIC     $r.,$r.,#&10000
        ADD     $temp.,$temp.,$r.,LSR #7
        MOV     $temp.,$temp.,LSL #22
        MOV     $r.,$temp.,LSR #24
;        MOV     $temp.,$temp.,LSR #24
;        ORR     $temp.,$temp.,$temp.,LSL #8
;        ORR     $r.,$temp.,$temp.,LSL #8
        MEND

a163 17
;        ADD     d_t2,d_t1,d_t1,LSR #20
;        BIC     d_t1,d_t1,#&200
;        ADD     d_t2,d_t2,d_t1,LSR #9
;        MOV     d_t2,d_t2,LSL #20
;        MOV     d_t2,d_t2,LSR #22
;        
;        ADD     d_r,d_r,d_t2
;        SUBS    d_r,d_r,#&180
;        MOVLT   d_r,#0
;        ADD     d_g,d_g,d_t2
;        SUBS    d_g,d_g,#&180
;        MOVLT   d_g,#0
;        ADD     d_b,d_b,d_t2
;        SUBS    d_b,d_b,#&180
;        MOVLT   d_b,#0
;        ClipAbove
        
d176 12
a310 6
; to save the word
        MACRO
        Save24bitPixel
        STR    d_t1,[d_outptr],#4
        MEND

d502 1
a502 1
; extern char *asm_get_table32k(int *palette_data/*void*/);
d512 1
a512 1
        MOV     r7, r0
d526 1
a526 1
        MOV     r3,r7
d617 1
a742 192


; --------------------------------------------------------------------------------------
;
; extern void asm_diffuse_to_24bpp(int *line, int linelength, char *output, char *table, int nlines, int linestep, 
;                                  int palette);
;
; --------------------------------------------------------------------------------------
; pixels in
;   line[0..linelength-1]..line[(nlines-1)*linestep..(nlines-1)*linestep+linelength-1]

; diffuse into 24bit values that are all contained within source palette.

asm_diffuse_to_24bpp
; The first line is special because the input pixels are in un-spaced-out format.

        STMDB   sp!,{r0-r12,lr}                       ; we need them all!
        ; d_inptr,d_count,d_outptr,d_table already set up, and will need to get reloaded
        LDR     d_nextline,[sp,#14*4+4]               ; get 'linestep' argument
        ADD     d_nextline,d_inptr,d_nextline,LSL #2  ; construct pointer to line above d_inptr
;        ADRL    d_palette,standard_palette
        LDR     d_palette, [sp,#14*4+8]

        MOV     d_r,#0
        MOV     d_g,#0
        MOV     d_b,#0
        LineAboveStartup
; Start processing the first pixel
        LDR     d_t1,[d_inptr],#4                     ; get very first pixel
        ConvertPixelPlusRGBTo8bit
        Save24bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        ; 5/16ths of the error is thrown away
        Add3_16ToNextLinePix
        Add1_16ToNextLineNextPix
        CutRGBby7_16
        AdvanceLineAboveForFirstInLine
        SUBS    d_count,d_count,#1
        BEQ     dither24_first_line_done               ; lines are just one pixel long
; now the loop for most of the pixels in the first line
        SUBS    d_count,d_count,#1
        BEQ     dither24_first_line_last_pixel          ; lines are just two pixels long
dither24_each_pixel_in_first_line
        LDR     d_t1,[d_inptr],#4                     ; get this pixel - not spaced out one
        ConvertPixelPlusRGBTo8bit
        Save24bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        Add5_16ToNextLinePrevPix
        Add3_16ToNextLinePix
        Add1_16ToNextLineNextPix
        CutRGBby7_16
        AdvanceLineAbove
        SUBS    d_count,d_count,#1
        BNE     dither24_each_pixel_in_first_line
; now the very last pixel in the line
dither24_first_line_last_pixel
        LDR     d_t1,[d_inptr],#4                     ; get this pixel - not spaced out one
        ConvertPixelPlusRGBTo8bit
        Save24bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        Add5_16ToNextLinePrevPix
        Add3_16ToNextLinePix
        ; 1/16+7/16 of error gets thrown away
        AdvanceLineAboveForLastInLine
dither24_first_line_done

; Now the loop for each line in the middle - pixels picked up will be spaced out ones.
dither24_each_line

        LDMIA   sp,{r0-r3}                            ; d_inptr,d_count,d_outptr,d_table reset
        LDR     d_nextline,[sp,#14*4+4]               ; get 'linestep' argument
        ADD     d_inptr,d_inptr,d_nextline,LSL #2     ; construct pointer to line above d_inptr
        ADD     d_outptr,d_outptr,d_nextline,LSL #2   ; construct pointer to line above d_outptr
        ADD     d_nextline,d_inptr,d_nextline,LSL #2  ; and pointer to next line
        STMIA   sp,{r0-r2}                            ; save back d_inptr and d_outptr

        MOV     d_r,#0                                ; initial cumulative error is 0
        MOV     d_g,#0
        MOV     d_b,#0

        LDR     d_t1,[sp,#14*4]                       ; get line count
        SUBS    d_t1,d_t1,#1
        CMP     d_t1,#1                               ; we didn't count for the first line, nor the last
        BLE     dither24_each_line_exit                 ; time to do very last line
        STR     d_t1,[sp,#14*4]                       ; save for next time

        SUB     d_count,d_count,#1                    ; number of pix in line excluding first and last
        LineAboveStartup
; Start processing the first pixel
        LDR     d_t1,[d_inptr],#4                     ; get very first pixel
        ConvertSpacedPixelPlusRGBTo8bit
        Save24bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        Add8_16ToNextLinePix                          ; 3/16 + 5/16 sent upwards, since NextLinePrevPix doesn't exit.
        Add1_16ToNextLineNextPix
        CutRGBby7_16
        AdvanceLineAboveForFirstInLine
        SUBS     d_count,d_count,#1
        BEQ      dither24_last_pixel                    ; line is two pixels long
; now the loop for most of the pixels
dither24_each_pixel
        LDR     d_t1,[d_inptr],#4                     ; get this pixel - not spaced out one
        ConvertSpacedPixelPlusRGBTo8bit
        Save24bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        Add5_16ToNextLinePrevPix
        Add3_16ToNextLinePix
        Add1_16ToNextLineNextPix
        CutRGBby7_16
        AdvanceLineAbove
        SUBS    d_count,d_count,#1
        BNE     dither24_each_pixel
; now the very last pixel in the line
dither24_last_pixel
        LDR     d_t1,[d_inptr],#4                     ; get this pixel - not spaced out one
        ConvertSpacedPixelPlusRGBTo8bit
        Save24bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        Add5_16ToNextLinePrevPix
        Add3_16ToNextLinePix
        Add8_16ToNextLinePix                          ; 3/16 + 7/16 + 1/16 sent upwards, since no pixels to right of here.
        AdvanceLineAboveForLastInLine

        B       dither24_each_line
dither24_each_line_exit

; And the final line - all errors propogated to the right.
; On the last line all pixels are treated the same.
; Registers for the loop have already been set up, at the start of the main loop.
dither24_each_pixel_in_last_line
        LDR     d_t1,[d_inptr],#4                     ; get this pixel - not spaced out one
        ConvertSpacedPixelPlusRGBTo8bit
        Save24bitPixel
        GetTrueRGBof8bitPixel
        Subtract32bitFromRGB
        CutRGBby12_16
        SUBS    d_count,d_count,#1
        BNE     dither24_each_pixel_in_last_line

; Done, finished, finito.
        LDMIA   sp!,{r0-r12,pc}^


;asm_convert_to_8bpp_grey
;; In:
;;  r0 = in pointer
;;  r1 = words per line
;;  r2 = out pointer
;;  r3 = number of lines
;
;        STMDB   sp!,{r0-r12,lr}                       ; we need them all!
;        
;        ; d_inptr,d_count,d_outptr,d_table already set up, and will need to get reloaded
;        LDR     r4,[sp,#14*4]                        ; get 'linestep' argument
;;        LDR     r5,[sp,#14*4]                          ; get line count
;        
;        MOV     r6, r0
;        MOV     r7, r2
;togrey_nextline
;        MOV     r0,r6
;        MOV     r2,r7
;        ADD     r6,r0,r4,LSL #2                        ; start of next line.
;        ADD     r7,r2,r4,LSL #2                        ; start of next line.
;        MOV     r5,#4
;        MOV     r11,#0
;        MOV     r8, r1                                 ;count
;togrey_nextpixel
;        LDR     r9, [r0],#4
;        MakePixelGrey r9, r10
;        AND     r9, r9, #&ff
;        ORR     r11, r11, r9
;        MOV     r11, r11, ROR #8
;        SUBS    r5, r5, #1
;        STREQ   r11, [r2],#4
;        MOVEQ   r5, #4
;        MOVEQ   r11, #0
;        SUBS    r8, r8, #1
;        BGT     togrey_nextpixel
;        CMP     r5,#4
;        MOVNE   r5,r5,LSL #3
;        MOVNE   r11, r11, ROR r5
;        SUBS    r3, r3, #1
;        BGT     togrey_nextline
;
;     
;        LDMIA   sp!,{r0-r12,pc}^
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

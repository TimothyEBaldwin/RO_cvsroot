head	4.25;
access;
symbols
	SprExtend-1_83:4.25
	SprExtend-1_82:4.25
	SprExtend-1_81:4.25
	SprExtend-1_80:4.25
	SprExtend-1_79:4.25
	SprExtend-1_78:4.25
	SprExtend-1_77:4.25
	SprExtend-1_76:4.25
	SprExtend-1_75:4.25
	SprExtend-1_74:4.25
	SprExtend-1_73:4.24
	SprExtend-1_72:4.24
	SprExtend-1_71-nocfsi:4.23
	SprExtend-1_71:4.23
	SprExtend-1_70-tracef:4.22
	SprExtend-1_70-headers:4.22
	SprExtend-1_70:4.21
	SprExtend-1_69:4.20
	SprExtend-1_68:4.19
	SprExtend-1_67:4.19
	SprExtend-1_66:4.19
	SprExtend-1_65:4.19
	SprExtend-1_64:4.19
	SprExtend-1_63:4.18
	SprExtend-1_62:4.18
	SprExtend-1_61:4.18
	SprExtend-1_60:4.17
	SprExtend-1_59:4.17
	SprExtend-1_58:4.17
	SprExtend-1_57:4.17
	SprExtend-1_56:4.17
	SprExtend-1_55:4.17
	SprExtend-1_54:4.16
	SprExtend-1_53:4.16
	SprExtend-1_52:4.16
	SprExtend-1_51:4.16
	SprExtend-1_50:4.16
	SprExtend-1_38-1_35_2_16:4.16.2.2
	SprExtend-1_49:4.16
	SprExtend-1_48:4.16
	SprExtend-1_47:4.16
	SprExtend-1_38-1_35_2_15:4.16.2.2
	SprExtend-1_46:4.16
	SprExtend-1_45:4.16
	SprExtend-1_44:4.16
	SprExtend-1_43:4.16
	SprExtend-1_42:4.16
	SprExtend-1_41:4.16
	SprExtend-1_38-1_35_2_14:4.16.2.2
	SprExtend-1_40:4.16
	SprExtend-1_38-1_35_2_13:4.16.2.2
	SprExtend-1_38-1_35_2_12:4.16.2.2
	SprExtend-1_38-1_35_2_11:4.16.2.2
	SprExtend-1_38-1_35_2_10:4.16.2.1
	SprExtend-1_38-1_35_2_9:4.16.2.1
	SprExtend-1_38-1_35_2_8:4.16
	SprExtend-1_39:4.16
	SprExtend-1_38-1_35_2_7:4.16
	SprExtend-1_38-1_35_2_6:4.16
	SprExtend-1_38-1_35_2_5:4.16
	SprExtend-1_38-1_35_2_4:4.16
	SprExtend-1_38-1_35_2_3:4.16
	SprExtend-1_38-1_35_2_2:4.16
	SprExtend-1_38-1_35_2_1:4.16
	MigrateIJG8b:4.16.0.2
	SprExtend-1_38:4.16
	SprExtend-1_37:4.16
	SprExtend-1_36:4.16
	SprExtend-1_35:4.15
	SprExtend-1_34:4.14
	SprExtend-1_33:4.13
	SprExtend-1_32:4.12
	SprExtend-1_31:4.11
	SprExtend-1_30:4.10
	SprExtend-1_29:4.9
	SprExtend-1_28:4.9
	SprExtend-1_27:4.9
	SprExtend-1_26:4.8
	SprExtend-1_25:4.7
	SprExtend-1_24:4.6
	SprExtend-1_23:4.5
	SprExtend-1_22:4.4
	SprExtend-1_21:4.4
	SprExtend-1_20:4.4
	SprExtend-1_19:4.4
	SprExtend-1_18:4.3
	SprExtend-1_17:4.3
	RO_5_07:4.3
	SprExtend-1_16:4.3
	SprExtend-1_15:4.3
	SprExtend-1_14:4.3
	SprExtend-1_13:4.3
	SprExtend-1_12:4.3
	SprExtend-1_11:4.3
	SprExtend-1_10:4.3
	SprExtend-1_09:4.3
	SprExtend-1_08:4.3
	dellis_autobuild_BaseSW:4.3
	SprExtend-1_07:4.3
	SprExtend-1_06:4.3
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.3
	SprExtend-1_05:4.2
	Ursula_merge:4.1.4.1
	nturton_SprExtend-1_04:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.25
date	2016.05.21.14.10.14;	author rool;	state Exp;
branches;
next	4.24;
commitid	RAjaHu2jGaPW7m7z;

4.24
date	2016.05.21.14.03.45;	author rool;	state Exp;
branches;
next	4.23;
commitid	4BquZHousteH5m7z;

4.23
date	2016.05.21.13.44.32;	author rool;	state Exp;
branches;
next	4.22;
commitid	ZDqmsyNiMhv6Zl7z;

4.22
date	2016.05.21.13.32.17;	author rool;	state Exp;
branches;
next	4.21;
commitid	yTqS85yKh7k8Ul7z;

4.21
date	2016.03.12.10.25.07;	author rool;	state Exp;
branches;
next	4.20;
commitid	cdOKhcORM5Eb8lYy;

4.20
date	2016.01.11.21.13.11;	author rsprowson;	state Exp;
branches;
next	4.19;
commitid	9u3DBFHppwA6GyQy;

4.19
date	2014.12.06.08.51.27;	author rsprowson;	state Exp;
branches;
next	4.18;
commitid	En1PFGHfLo2OsX0y;

4.18
date	2014.03.04.20.45.03;	author jlee;	state Exp;
branches;
next	4.17;
commitid	6KWofF44yd1Fjqrx;

4.17
date	2013.10.07.00.39.07;	author jlee;	state Exp;
branches;
next	4.16;
commitid	HcUKy3PafwqToi8x;

4.16
date	2010.11.14.14.51.58;	author rsprowson;	state Exp;
branches
	4.16.2.1;
next	4.15;

4.15
date	2010.11.14.10.42.34;	author rsprowson;	state Exp;
branches;
next	4.14;

4.14
date	2010.11.06.17.29.32;	author rsprowson;	state Exp;
branches;
next	4.13;

4.13
date	2010.10.17.09.01.32;	author rsprowson;	state Exp;
branches;
next	4.12;

4.12
date	2010.10.13.20.26.17;	author rsprowson;	state Exp;
branches;
next	4.11;

4.11
date	2010.10.07.20.11.03;	author rsprowson;	state Exp;
branches;
next	4.10;

4.10
date	2010.09.29.21.05.27;	author rsprowson;	state Exp;
branches;
next	4.9;

4.9
date	2010.09.19.09.03.44;	author rsprowson;	state Exp;
branches;
next	4.8;

4.8
date	2010.09.17.22.15.32;	author rsprowson;	state Exp;
branches;
next	4.7;

4.7
date	2010.09.17.21.07.21;	author rsprowson;	state Exp;
branches;
next	4.6;

4.6
date	2010.09.01.20.48.51;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2010.08.26.08.58.12;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2009.04.24.00.48.33;	author srevill;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.12.12.59.05;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	99.08.05.18.03.11;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.45.18;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.16.2.1
date	2011.01.22.17.58.26;	author rsprowson;	state Exp;
branches;
next	4.16.2.2;

4.16.2.2
date	2011.01.29.10.03.35;	author rsprowson;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.45.18;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.43.01;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.03.26.16.10.16;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.58.35;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.21.08;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.25
log
@Bug fixes
Detail:
  Remove the unused gray (sic) output colour space support. Remove the patches to set output colour space to RGB, this can be overridden in code per the design intent of the library. Only decode luma for grey output.
  Fix bug rendering test image monorose2x4 - this was caused by the huffman pointer saving not decoding enough MCUs when the source image is monochrome hence an MCU outputs 8x8 rather than hsamp x vsamp pixels. Also removed the setting of insufficient_data in the entropy decoder, this meant that any error at the end of the image (eg. truncated) would cause the rest of the image to not render because JPEGs are stored top down but RISC OS plots them bottom up.
  Fix endless failure to match previously cached JPEG, especially at 16bpp, when the source JPEG doesn't meet the fast colour conversion criteria (eg. not 2x2 subsampling). The flags test was checking the requested flags against the filtered flags, which never matched (because the unmet options get cleared). Now, keep the original flags prior to filtering and compare those on the basis that the conversion decision will be consistent; simply ANDing out those modifiable flags doesn't help because then you can't spot when they genuinely change (eg. a mode change) as the filtered flags determine what format the blitter is expecting back.
  Fix bug causing aborts when the user manually resizes (down) the JPEG workspace DA. The calculation of new_size in jpeg_find_image_dims() had at some point lost the height multiplier on the band buffer, so when auto resizing back up again the buffer was too small to convert a whole band into.
Admin:
  Submission for the JPEG bounty.

Version 1.74. Tagged as 'SprExtend-1_74'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.SWIs

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; JPEG_SWI decoding entry point
; Entry: R11 = reason code
;        R12 --> private word
; Exit : R0-R9 may be used to contain results
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SpriteExtend_SWIDecode
        Debug   gs,"X R0-3",R0,R1,R2,R3
        Debug   gs,"X R4-7",R4,R5,R6,R7
        Debug   gs,"X R8-9,12",R8,R9,R12
      [ debuggs
        Push    "R0"
        MOV     r0, lr
        Debug   gs,"we will return to ",R0
        Pull    "R0"
      ]
        Push    "LR"
        CLRPSR  I_bit,R14                        ; re-enable interrupts

        LDR     r12,[R12]                        ; wsptr --> workspace

        Debug   gs,"R12 = ",R12
        Debug   gs,"R11 = ",R11
        CMP     r11, #2                          ; JPEG_PlotScaled ?
        CMPNE   r11, #3                          ; JPEG_PlotFileScaled ?
        CMPNE   r11, #4                          ; JPEG_PlotTransformed ?
        CMPNE   r11, #5                          ; JPEG_PlotFileTransformed ?
        BNE     swijpnonprinter

        LDR     r14, save_PdriverIntercept
        TST     r14, #1
        BEQ     swijpnonprinter
        Push    "R8"
        AND     r8, r11, #63
        Debug   gs, "I should be calling the printer SWI...",R8
        SWI     XPDriver_JPEGSWI
        Pull    "R8,PC"

swijpnonprinter
        CMP     R11,#maxnewswi
        ADDCC   R14,R11,#(swijptable-swijporg-4)/4
        ADDCC   PC,PC,R14,ASL #2                 ; go!

swijporg
        ADR     R0,ErrorBlock_BadSWI
        BL      copy_error_one
        Pull    "PC"

swijptable
        B       SWIJPEG_Info
        B       SWIJPEG_FileInfo
        B       SWIJPEG_PlotScaled
        B       SWIJPEG_PlotFileScaled
        B       SWIJPEG_PlotTransformed
        B       SWIJPEG_PlotFileTransformed
        B       SWIJPEG_PDriverIntercept
swijptableend
maxnewswi   *   (swijptableend-swijptable)/4

ErrorBlock_BadSWI
        DCD     ErrorNumber_ModuleBadSWI
        DCB     "BadSWI"
        DCB     0
        ALIGN

ErrorBlock_NoFile
        DCD     ErrorNumber_FileNotFound
        DCB     "NoFile"
        DCB     0
        ALIGN

SpriteExtend_SWINames
        DCB     SpriteExtendJPEGSWI_Name,0                ; prefix
        DCB     "Info",0
        DCB     "FileInfo",0
        DCB     "PlotScaled",0
        DCB     "PlotFileScaled",0
        DCB     "PlotTransformed",0
        DCB     "PlotFileTransformed",0
        DCB     "PDriverIntercept",0
        DCB     0
        ALIGN

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; JPEG_Info
; ---------
; Entry: r0 = flags for desired operation
;             b0 set : return dimensions.
;             b1 set : return SOF type.
;        r1 = Pointer to JPEG image in memory.
;        r2 = length of data in memory (bytes)
; 
; Exit : r0 = returned information flags.
;             b0 set : greyscale image.
;             b1 set : set if transformed plots are not supported.
;             b2 set : pixel density is only a ratio.
;             b3-b6  : SOF type if requested.
;        r1 preserved
;        r2 = width in pixels.
;        r3 = height in pixels.
;        r4 = X pixel density.
;        r5 = Y pixel density
;        r6 = Extra workspace needed to render
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SWIJPEG_Info
        Pull    "LR"
        Debug   gs,"JPEGInfo: LR =",LR
        Push    "R1-R9,LR"              ; we must stick to the same form of saved registers as 'exitbiggie' assumes,
                                        ; in case of an unexpected exit from the C code.
        Debug   gs, "Image data pointer = ",R1
        MOV     r2, #0                  ; in memory JPEG (r1->data)

jpeginfo_afid
        BICS    r3, r0, #JPEGFlag_Return_Dimensions :OR: JPEGFlag_Return_SOF_Type
        ADRNEL  r0, ErrorBlock_BadFlags
        addr    r1, Title, NE
        BLNE    copy_error_one          ; Always sets the V bit
        BVS     exitbiggie

        STR     sp, ccompiler_sp        ; in case of unexpected exit
        MOV     r4, #0
        STR     r4, ccompiler_errptr    ; in case of error exit

        MOV     r7, r0                  ; keep flags for later
        MOV     r0, r1                  ; move JPEG pointer into r0

        BL      asm_find_image_dims     ; corrupts r0, sets r1-r6
        Pull    "R1-R9,PC", VS
        Debug   gs,"return from C: R1,R2,R3 =",R1,R2,R3

        AND     r0, r1, #7              ; number of components (1, 3, or 4)
        TEQ     r0, #1                  
        ASSERT  JPEGFlag_Info_Greyscale = 1
        MOVNE   r0, #0                  ; Not greyscale then
        TST     r1, #&80                ; Is the pixel density a ratio?
        ORRNE   r0, r0, #JPEGFlag_Info_DensityRatio
        TST     r7, #JPEGFlag_Return_SOF_Type
        MOVNE   r1, r1, LSR #8
        ORRNE   r0, r0, r1, LSL #JPEGFlag_Info_SOF_Shift
        
        ;******THIS MUST BE REMOVED WHEN TRANSFORMATIONS ARE ALLOWED*********
        ORR     r0, r0, #JPEGFlag_Info_NoPlotTransformed
        ;******THIS MUST BE REMOVED WHEN TRANSFORMATIONS ARE ALLOWED*********

        Pull    "R1"
        TST     r7, #JPEGFlag_Return_Dimensions
        LDMEQIA sp, {r2-r3}             ; didn't want the image dimensions after all
        ADDS    sp, sp, #5*4            ; get rid of saved r2-r6 - clear V
        Debug   gs,"returning R0,R1,R2,R3 =",R0,R1,R2,R3
        Debug   gs,"returning R4,R5,R6 =",R4,R5,R6
        Debug   gs,"Got to 12"
        Pull    "R7-R9,PC"              ; copied from exitbiggie, but returning r1-r6 - r0 restored by exit sequence.

        MakeSpriteErrorBlock BadJPEG,,BadJPEG

        MakeSpriteErrorBlock JPEGNoRoom,,JPEGNoRoom

        MakeSpriteErrorBlock JPEGFatal,,JPEGFatal

        MakeSpriteErrorBlock BadJPEGPlot,,BadJPEGPlot

        MakeSpriteErrorBlock BadJPEGUnsupported,,BadJPEGUnsupported

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; JPEG_FileInfo
; -------------
; Entry: r0 = flags for desired operation
;             b0 set : return dimensions.
;        r1 = pointer to control character terminated filename for
;             JPEG image.
;
; Exit : r0 = returned information flags.
;             b0 set : greyscale image.
;             b1 set : set if transformed plots are not supported.
;             b2 set : pixel density is only a ratio.
;        r1 preserved
;        r2 = width in pixels.
;        r3 = height in pixels.
;        r4 = X pixel density.
;        r5 = Y pixel density
;        r6 = Extra workspace needed to render
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SWIJPEG_FileInfo
        Pull    "LR"
        Debug   gs,"JPEGFileInfo: LR =",LR
        Push    "R1-R9,LR"              ; we must stick to the same form of saved registers as 'exitbiggie' assumes,
                                        ; in case of an unexpected exit from the C code.
        Debug   gs, "Filename pointer = ",R1
        MOV     r2, #1                  ; in file JPEG (r1->filename)
        B       jpeginfo_afid           ; common tail

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; JPEG_PlotScaled
; ---------------
; Entry: r0 = pointer to JPEG image in memory
;        r1 = x co-ordinate for plot
;        r2 = y co-ordinate for plot
;        r3 = scale factors or 0
;        r4 = length of data in memory
;        r5 = Flags
;             b0 set: dither output when plotting truecolour in 8bpp or less.
;             b1 set: Full error-diffusion when plotting to 8bpp.
;             b3 set: Use colour mapping
;             b4-b11: translucency (0=opaque, 255=1/256 visibility)
;        r6 = colour mapping descriptor (if relevant)
;
; Exit : all registers preserved.
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SWIJPEG_PlotScaled
        Pull    "LR"
        Push    "R1-R9,LR"              ; we must stick to the same form of saved registers as 'exitbiggie' assumes,
      [ debuggs
        MOV     r1, sp
        Debug   gs,"sp after push 1-9+lr =", r1
        Debug   gs,"JPEG_PlotScaled sprite: R0,R1,R2 =",R0,R1,R2
        Debug   gs,"JPEG_PlotScaled sprite: R3,R4,R5 =",R3,R4,R5
        ADRL    r3, newtranstable
        Debug   gs,"newtranstable at ",r3
      ]
        MOV     R1, R0
        MOV     R2, R4

        ; Extract the flg2_ flags
        ASSERT  JPEGFlag_Scaled_Translucency = flg2_translucency
        ASSERT  JPEGFlag_Scaled_Colourmap = flg2_colourmap
        LDR     r3, =JPEGFlag_Scaled_Translucency+JPEGFlag_Scaled_Colourmap
        AND     r3, r5, r3
        BIC     r5, r5, r3
        STR     r3, trns_flags2
        ANDS    r14, r3, #JPEGFlag_Scaled_Translucency
        MOVNE   r14, #1
        STR     r14, blending
        MOV     r7, r6 ; Preserve colour mapping descriptor

        ; Check the remaining flags are valid
        BICS    r3, r5, #JPEGFlag_Scaled_Dither_Enable :OR: JPEGFlag_Scaled_Error_Diffused_Dither
        ADRNEL  R0, ErrorBlock_BadFlags
        addr    r1, Title, NE
        BLNE    copy_error_one          ; Always sets the V bit
        BVS     exitbiggie

        AND     r3, r5, #JPEGFlag_Scaled_Dither_Enable :OR: JPEGFlag_Scaled_Error_Diffused_Dither
        STR     r3, dither_truecolour
        Debug   gs,"Storing in dither...R3 = ",R3

        ; Set escape stack level in case of unexpected exit from C code.
        STR     SP,ccompiler_sp         ; in case of unexpected exit
        MOV     R4,#0
        STR     R4,ccompiler_errptr     ; in case of error exit

        ; Space is allocated on the stack, as follows:
        ;   saved registers R1-R9,LR so that exitbiggie can come back to us
        ;   jpeg pointer - 11th register
        ;   a 32K translation table - from ColourTrans
        ;   a fake sprite control block
        ;   16 bytes immediately following the fake sprite of JPEG credentials (compress_id_words)
        ;            +0 id
        ;            +4 pointer to jpeg
        ;            +8 length of jpeg
        ;            +C amount of workspace to decompress jpeg
        ^       0, sp
pjs_start       #       0
pjs_savearea    #       10*4
pjs_r0save      #       4
pjs_table       #       12
pjs_sprite      #       SpriteCBsize
pjs_compressid  #       16
pjs_end         #       0
        SUB     sp,sp,#pjs_end-pjs_start          ; allocate that space

        ; The sprite header sits on the stack. A sprite header consists of:
        ;   spNext    # 4  ;  Offset to next sprite
        ;   spName    # 12 ;  Sprite name
        ;   spWidth   # 4  ;  Width in words-1      (0..639)
        ;   spHeight  # 4  ;  Height in scanlines-1 (0..255/511)
        ;   spLBit    # 4  ;  First bit used (left end of row)
        ;   spRBit    # 4  ;  Last bit used (right end of row)
        ;   spImage   # 4  ;  Offset to sprite image
        ;   spTrans   # 4  ;  Offset to transparancy mask
        ;   spMode    # 4  ;  Mode sprite was defined in
        ;   spPalette # 0  ;   
        MOV     r0,#spPalette+100
        STR     r0,pjs_sprite+spNext               ; look realistic for SWI calls that read this header
        MOV     r0,#'x'
        STR     r0,pjs_sprite+spName               ; terminated by a zero character

        MOV     r0,#0
        STR     r0,pjs_sprite+spLBit
        MOV     r0,#31
        STR     r0,pjs_sprite+spRBit               ; number of bits used in right hand word at 32bpp

        MOV     r0,#spPalette                      ; not paletted
        STR     r0,pjs_sprite+spImage
        STR     r0,pjs_sprite+spTrans

        MOV     r0, #1                             ; set mode number
        MOV     r3, #90
        ORR     r0, r0, r3, LSL #1                 ; Horizontal dpi
        ORR     r0, r0, r3, LSL #14                ; Vertical dpi
        ORR     r0, r0, #SpriteType_JPEG :SHL: 27  ; Sprite Type = 9
        STR     r0,pjs_sprite+spMode

        MOV     r0,#-1
        Debug   gs,"compress id words: R0,R1,R2 =",R0,R1,R2
        ASSERT  (pjs_sprite + SpriteCBsize) = pjs_compressid
        STR     r0,pjs_compressid+0                ; store identifier for in memory JPEG data.
        STR     r1,pjs_compressid+4                ; store pointer to JPEG data.
        STR     r1,pjs_r0save
        STR     r2,pjs_compressid+8                ; store length of JPEG data

        ; Call find_image_dims to find the dimensions of the JPEG,
        ; and use this to fill in the rest of the sprite header.
        MOV     r0, r1                             ; get pointer to JPEG
        MOV     r2, #0                             ; clear r2 because image is in memory
        BL      asm_find_image_dims                ; corrupts r0, sets r1-r6
        BVS     jpegscaled_errorexit
        Debug   gs,"found dims... R1,R2,R3,R6=",R1,R2,R3,R6

        STR     r6,pjs_compressid+12               ; store workspace requirements to work on this JPEG

        SUB     r3,r3,#1
        STR     r3,pjs_sprite+spHeight             ; height in scanlines - 1

        SUB     r2,r2,#1
        STR     r2,pjs_sprite+spWidth              ; number of words - 1 at 32bpp

        ; If colour mapping is in use, the C code is in charge of generating any table that's necessary
        LDR     r0, trns_flags2
        TST     r0, #flg2_colourmap
        BNE     %FT01
        ; Call ColourTrans to get a suitable translation table for sending 32-bit data
        ; into this screen mode. This is either a 32K table, or no table at all.
        ; If this produces an error then we're probably on RISC OS 3.1,
        ; in which case we go forward with no translation table.
        LDR     r0, ctrans_recent
        TEQ     r0, #0
        MOVEQ   r7,#0                              ; error return - not new ColourTrans
        BEQ     %FT01

        MOV     r0,#SpriteType_New32bpp :SHL: 27
        ORR     r0,r0,#1                           ; new mode number for 32bpp
        MOV     r1,#-1                             ; default input, output, palette, everything
        MOV     r2,#-1
        MOV     r3,#-1
        ADR     r4,pjs_table                       ; pointer to buffer to put table in
        MOV     r5,#0                              ; no special flags
        MOV     r6,#0
        MOV     r7,#0
        SWI     XColourTrans_SelectTable
        BVS     jpegscaled_errorexit               ; error return, no table about
        ADR     r7,pjs_table                       ; table to use now in r7, all through following code
        Debug   gs,"Generated trans table at ",R7
01
        ; Set up the output from readvduvars and readspritevars
        BL      readvduvars                        ; r7 undisturbed
        BVS     jpegscaled_errorexit

        ; This stuff is copied from readspritevars
        MOV     R3,#5                   ; log2 of 32
        STR     R3,save_inlog2bpc
        STR     R3,save_inlog2bpp
        MOV     R3,#1:SHL:5             ; bits per pixel
        STR     R3,save_inbpp
        MOV     R3,#1                   ; log2 of 2 OS-units
        Debug   gs,"inlog2px: R3=",R3
        STR     R3,inlog2px             ; pretend to be VGA-size pixels
        STR     R3,inlog2py             ; pretend to be VGA-size pixels
        STR     R3,is_it_jpeg           ; mark as a JPEG sprite
        MOV     R0,#20
        STR     R0,inmode               ; the mode vars are for mode 20 sprites.
        MOV     R0,#0
        STR     R0,save_inmodeflags
        MVN     R0,#0
        STR     R0,save_inncolour

        ; Update the area size incase the user resized it since last time
        LDR     r0, area_numbers + 8    ; currently only 1 user resizable
        MOVS    r2, r0
        BEQ     %FT10                   ; no area yet
        SWI     XOS_ReadDynamicArea     ; find out how big area is
        MOVVS   r1, #0                  ; area vanished (pretend zero size)
        MOVS    r2, r1                  ; area resized to nothing
        LDRNE   r2, jpeg_info_ptr
        STRNE   r1, [r2, #cinfo_workspace_size]
10
        STR     r2, jpeg_info_ptr

        ; Now set up the registers to enter the regular PutSpriteScaled code
        ; r7 is still the translation table to use
        ADR     r0,pjs_end              ; reach round the pjs frame to get at original saved registers
        LDMIA   r0,{r1-r6}
        ADR     lr,jpegscaled_exit
      [ debuggs
        MOV     r0,lr
        Debug   gs,"Lr for ret=",r0
      ]
        ASSERT  pjs_start = pjs_savearea
        STMIA   sp,{r1-r9,lr}           ; save state for cleanup-and-exit
        Debug   gs,"pjs sprite: R0,R1,R2 =",R0,R1,R2
        Debug   gs,"pjs sprite: R3,R4,R5 =",R3,R4,R5
        Debug   gs,"pjs sprite: R6,R7 =",R6,R7
        MOV     r6,r3                   ; put scale in r6
        MOV     r3,r1                   ; put x-coord in r3
        MOV     r0,r2                   ; temp r2
        MOV     r2,r4                   ; put size in r2
        MOV     r4,r0                   ; put y-coord in r4
        MOV     r5,#0                   ; only plot action of 0 allowed (eg no XOR etc.)
        ADR     r1,pjs_sprite           ; the fake sprite
        MOV     R8,#0                   ; no printer calibration table
        STR     R8,calibration_table
        Debug   gs,"pjs sprite: R0,R1,R2 =",R0,R1,R2
        Debug   gs,"pjs sprite: R3,R4,R5 =",R3,R4,R5
        Debug   gs,"pjs sprite: R6,R7 =",R6,R7
        B       putsprscaled_frompjs

        ; We come to here from exitbiggie, after either an error or plotting the sprite.
        ; Just drop the stack, and exit.
jpegscaled_exit
      [ debuggs
        MOV     r1, sp
        Debug   gs, "We returned to the right place",R1
      ]
        LDR     r2,ccompiler_errptr
        CMP     r2, #0                            ; did C code return an error?
        BNE     %FT20
      [ debuggs
        MOV     r1, sp
        Debug   gs,"ok1. sp = ",r1
      ]
        Pull    "R0"                              ; original R0 (pjs_r0save)
        ADD     sp,sp,#pjs_end-pjs_table          ; junk the fake sprite and colourtrans table
        Debug   gs,"r0 when loaded =",R0
      [ debuggs
        MOV     r1, sp
        Debug   gs,"ok23. sp = ",r1
      ]
        Pull    "R1-R9,LR"                        ; restore others (pjs_savearea)
        Debug   gs,"X R0-3",R0,R1,R2,R3
        Debug   gs,"X R4-7",R4,R5,R6,R7
        Debug   gs,"X R8-9",R8,R9
        MOV     pc, lr
20
        ADD     sp,sp,#4                          ; junk pjs_r0save
        SUB     sp,sp,#pjs_table-pjs_start        ; correct for the ADD in 'jpegscaled_errorexit' moving stack too far.

        MOV     r3, #0
        MOV     r0, #1                            ; Remove
        LDR     r1, area_numbers + 0              ; Coefficient DA
        TEQ     r1, #0
        STRNE   r3, area_numbers + 0
        SWINE   XOS_DynamicArea
        LDR     r1, area_numbers + 4              ; Transcoding DA
        TEQ     r1, #0
        STRNE   r3, area_numbers + 4
        SWINE   XOS_DynamicArea

        TST     r2, #ERROR_BAD_JPEG               ; C code returned bad jpeg error
        BNE     jpegscaled_errorexit1
        TST     r2, #ERROR_NO_MEMORY              ; C code bombed out with no memory
        BEQ     jpegscaled_errorexit2             ; Otherwise just claim it's a fatal error

jpegscaled_errorexit0
        Debug   gs, "We think we'be run out of memory"
        ADRL    R0,ErrorBlock_JPEGNoRoom
        Debug   gs,"error block at r0 = ",R0
        BL      copy_error_one
        B       jpegscaled_errorexit
jpegscaled_errorexit1
        Debug   gs, "We think we've got a duff JPEG"
        ADRL    R0,ErrorBlock_BadJPEG
        Debug   gs,"error block at r0 = ",R0
        BL      copy_error_one
        B       jpegscaled_errorexit
jpegscaled_errorexit2
        Debug   gs, "We think we've had a fatal error"
        ADRL    R0,ErrorBlock_JPEGFatal
        Debug   gs,"error block at r0 = ",R0
        BL      copy_error_one
        
jpegscaled_errorexit
      [ debuggs
        MOV     r1, sp
        Debug   gs,"1. sp = ",r14
        MOV     r4, #pjs_end-pjs_start
        Debug   gs,"pjs size = ",R4
      ]
        ADD     sp,sp,#pjs_end-pjs_start          ; free that space
      [ debuggs
        MOV     r4, sp
        Debug   gs,"2. sp = ",r4
      ]
        Pull    "R1-R9,LR"
        Debug   gs,"r0 is now (at end...) = ",R0
        Debug   gs,"X R0-3",R0,R1,R2,R3
        Debug   gs,"X R4-7",R4,R5,R6,R7
        Debug   gs,"X R8-9,12",R8,R9,R12
      [ debuggs
        MOV     r4, lr
        Debug   gs,"about to return to ",R4
      ]
        MOV     pc, lr

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; JPEG_PlotFileScaled
; -------------------
; Entry: r0 = pointer to control character terminated filename
;        r1 = x co-ordinate for plot
;        r2 = y co-ordinate for plot
;        r3 = scale factors or 0
;        r4 = Flags
;             b0 set: dither output when plotting truecolour in 8bpp or less.
;             b1 set: Full error-diffusion when plotting to 8bpp.
;             b3 set: Use colour mapping
;             b4-b11: Translucency
;        r5 = Colour mapping descriptor (if relevant)
;
; Exit : all registers preserved.
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SWIJPEG_PlotFileScaled
        LDR     LR, =JPEGFlag_Scaled_Translucency+JPEGFlag_Scaled_Colourmap+JPEGFlag_Scaled_Dither_Enable+JPEGFlag_Scaled_Error_Diffused_Dither
        BICS    LR, r4, LR
        ADRNEL  R0, ErrorBlock_BadFlags
        addr    r1, Title, NE
        BLNE    copy_error_one           ; Always sets the V bit
        Pull    "PC", VS

        Pull    "LR"
        Push    "R0,R4-R6,LR"
        Push    "R1-R5"

        ; Find out file size.
        MOV     r1, r0
        MOV     r0, #OSFile_ReadWithTypeNoPath
        SWI     XOS_File
        CMP     r0, #object_nothing
        BEQ     jpegplotfilescaled_nofile
        Debug   gs,"File size =", r4

        ; Claim space for buffer from Module area.
        MOV     r0, #ModHandReason_Claim
        MOV     r3, r4                   ; size of JPEG buffer
        SWI     XOS_Module               ; pointer to block now in r2
        Debug   gs,"Block for JPEG =", R2
        BVS     jpegplotfilescaled_error ; jump out and return error.

        ; Read file into buffer
        MOV     r6, r2                   ; Move r2 to r6 because r2 gets changed by OS_FILE
        MOV     r3, #0                   ; clear r3 so r2 used as load address
        MOV     r0, #OSFile_LoadNoPath
        Debug   gs,"Loading file: r0,r1,r2,r3 =", R0,R1,R2,R3
        SWI     XOS_File                 ; file name still in r1
        BVS     jpegplotfilescaled_error ; jump out and return error.

        Debug   gs,"Load address = ",R6
        MOV     r0, r6
        Pull    "R1-R3,R5-R6"            ; pull original parameters into correct regs for JPEG_plotscaled.
        Push    "R0"                     ; store address of buffer so we can free it.
        ADR     LR, jpegplotscaled_return
        Push    "LR"
        Debug   gs,"Calling PlotScaled: R0,R1,R2,R3,R4,R5,R6=",R0,R1,R2,R3,R4,R5,R6
        B       SWIJPEG_PlotScaled

jpegplotscaled_return
        Debug   gs,"Return From PlotScaled: R0,R1,R2,R3=",R0,R1,R2,R3
        MOVVS   r4, #1                   ; keep record of error after next SWI call.
        MOVVC   r4, #0
jpegplotfilescaled_exit1
        MOV     r5, r0                   ; temporarily store r0 and r2
        MOV     r6, r2
        Pull    "R2"                     ; recover location of buffer from stack
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module               ; Free module space
        BVS     jpegplotfilescaled_error2; jump out and return error.
        MOV     r0, r5                   ; recover original r0 and r2
        MOV     r2, r6
        CMP     r4, #1                   ; Did SWIJPEG_PlotScaled return an error?
        Pull    "R0,R4-R6,PC",NE         ; Nope
        SETV                             ; If so, make sure the V flag is set.
        B       jpegplotfilescaled_error2

jpegplotfilescaled_nofile
        ADRL    R0,ErrorBlock_NoFile
        Pull    "R1-R5"
        MOV     r4, r1
        Pull    "R1"                     ;should be r0 saved at start...
        BL      copy_error_one
        MOV     r1, r4
        Pull    "R4-R6,PC"

jpegplotfilescaled_error
        Pull    "R1-R5"
        Debug   gs,"about to return from filescaled..."

jpegplotfilescaled_error2
        ADD     sp, sp, #4
        Pull    "R4-R6,PC"

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; JPEG_PlotTransformed
; --------------------
; Entry: R0 = Pointer to JPEG file loaded in Memory
;        R1 = flag word
;                b0 set: R2 is pointer to dest. coords, else pointer to matrix
;                b1 set: dither output when plotting truecolour in 8bpp or less.
;                b2 set: Full error-diffusion when plotting to 8bpp.
;                b4 set: R4 is pointer to colour mapping descriptor
;                b5-b12: Translucency (0=opaque, 255=1/256 visibility)
;        R2 = pointer to matrix (as for Draw module) or
;             pointer to destination co-ordinate block.
;        R3 = length of data in memory.
;        R4 = pointer to colour mapping descriptor (if relevant)
;
; Exit : all registers preserved.
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SWIJPEG_PlotTransformed
        Pull    "LR"
        Push    "R0-R11,LR"
        LDR     r4, =JPEGFlag_Transformed_Translucency+JPEGFlag_Transformed_Colourmap+JPEGFlag_Transformed_Coords_In_R2+JPEGFlag_Transformed_Dither_Enable+JPEGFlag_Transformed_Error_Diffused_Dither
        BICS    r4, r1, r4
        Pull    "R0-R11", NE
        ADRNEL  R0, ErrorBlock_BadFlags
        addr    r1, Title, NE
        BLNE    copy_error_one          ; Always sets the V bit
        Pull    "PC", VS

        TST     r1, #1
        BNE     jpegtrans_destcoords

        ; Matrix
        LDR     r4, [r2, #4]            ; Rotation value
        CMP     r4, #0
        Debug   gs,"Rot value 1..",R4
        BNE     jpegtrans_errorexit
        LDR     r4, [r2, #8]            ; Rotation value
        CMP     r4, #0
        Debug   gs,"Rot value 2..",R4
        BNE     jpegtrans_errorexit
        LDR     r4, [r2]                ; X scale factor in Draw Transform units
        CMP     r4, #0
        BMI     jpegtrans_errorexit
        LDR     r4, [r2, #12]           ; Y scale factor in Draw Transform units
        CMP     r4, #0
        BMI     jpegtrans_errorexit

        ; Make up scale factor...
        Debug   gs,"scale factors are...",R7,R8,R2,R3
        Push    "R0-R2"
        MOV     r0, #-1
        MOV     r1, #VduExt_XEigFactor
        SWI     XOS_ReadModeVariable    ; Get X Eig in R2
        MOV     r7, r2                  ; Put into r7
        MOV     r1, #VduExt_YEigFactor
        SWI     XOS_ReadModeVariable    ; Get Y Eig in R2
        MOV     r8, r2                  ; Put into r8
        Pull    "R0-R2"
        SUB     sp, sp, #16             ; make room for scale factors
        LDR     r4, [r2]                ; X scale factor in Draw Transform units
        STR     r4, [sp]
        LDR     r4, [r2, #12]           ; Y scale factor in Draw Transform units
        STR     r4, [sp,#4]
        MOV     r6, #180                ; Dpi of 1 pixel per OS unit sprite.
        MOV     r7, r6, LSR r7          ; X Dpi of output sprite
        MOV     r8, r6, LSR r8          ; Y Dpi of output sprite
        Push    "R1-R6"

        ; JPEG pointer already in r0
        MOV     r2, #0
        BL      asm_find_image_dims

        MOV     r9, r4
        MOV     r10, r5
        Pull    "R1-R6"

        ; *************************************************
        ; ***  DivRem - Integer division and remainder  ***
        ; ***  rc := ra DIV rb; ra := ra REM rb         ***
        ; ***  rb preserved, rtemp corrupt              ***
        ; ***  DivRem   rc, ra, rb, rtemp               ***
        ; *************************************************
        
        ; We need to use a ratio of Output dpi to input dpi to convert
        ; the OS unit to OS unit scale factor from matrix to a pixel to
        ; pixel scale factor which we can send to PlotScaled.
        MOV     r4, r9, LSL #16         ; X input dpi * 2^16 (because of
                                        ; transform coordinates)
        DivRem  r5, r4, r7, r9          ; r5 = xdivisor div outdpi
        STR     r5, [sp,#8]
        MOV     r4, r10, LSL #16        ; X input dpi * 2^16 (because of
                                        ; transform coordinates)
        DivRem  r5, r4, r8, r9          ; r5 = xdivisor div outdpi
        STR     r5, [sp,#12]
        
        ; Set up registers for PutScaled Call
        MOV     r4, r3
        MOV     r3, sp                  ; Pointer to Scale factors
        MOV     r5, r1, LSR #1          ; Shift flags across for PlotScaled
        LDR     r1, [r2, #16]           ; X-coordinate in 1/256th OSunit
        MOV     r1, r1, ASR #8
        LDR     r2, [r2, #20]           ; Y-coordinate in 1/256th OSunit
        MOV     r2, r2, ASR #8
        LDR     r6, [sp, #16+4*4]       ; Grab entry R4
        Debug   gs,"Calliing PutScaled.R0,R1,R2,R3,R4,R5,R6=",R0,R1,R2,R3,R4,R5,R6
        ADRL    lr, jpegtrans_plotreturn
        Push    "LR"
        BL      SWIJPEG_PlotScaled

jpegtrans_destcoords
        Debug   gs,"Doing a DestCoords Plot Transformed"
        MOV     r11, r1

        ; Check output coord block is a rectangle
        LDR     r4, [r2]                ; X0
        Debug   gs,"load 1 ",r4
        LDR     r5, [r2, #24]           ; X3
        Debug   gs,"load 2 ",r5
        CMP     r4, r5
        BNE     jpegtrans_errorexit
        Debug   gs,"Check 1 passed"
        LDR     r4, [r2, #4]            ; Y0
        LDR     r5, [r2, #12]           ; Y1
        CMP     r4, r5
        BNE     jpegtrans_errorexit
        Debug   gs,"Check 2 passed"
        LDR     r4, [r2, #20]           ; Y2
        LDR     r5, [r2, #28]           ; Y3
        CMP     r4, r5
        BNE     jpegtrans_errorexit
        Debug   gs,"Check 3 passed"
        LDR     r4, [r2, #8]            ;X1
        LDR     r5, [r2, #16]           ;X2
        CMP     r4, r5
        BNE     jpegtrans_errorexit
        Debug   gs,"Check 4 passed"
        LDR     r4, [r2]                ; X0
        CMP     r4,r5                   ; which one is biggest?
        BGT     jpegtrans_errorexit     ; can't allow flipping...
        Debug   gs,"Check 5 passed"
        LDR     r6, [r2, #4]            ; Y0
        LDR     r7, [r2, #28]           ; Y3
        CMP     r7,r6                   ; which one is biggest?
        BGT     jpegtrans_errorexit     ; can't allow flipping...
        Debug   gs,"Check 6 passed"
        SUB     r4, r5, r4              ; dest X-size in r4 in 1/256th OS units
        SUB     r5, r6, r7              ; dest Y-size in r5 in 1/256th OS units
        MOV     r4, r4, LSR #8          ; dest X-size in r4 in OS units
        MOV     r5, r5, LSR #8          ; dest Y-size in r5 in OS units
        ; convert dest size from OS units to pixels
        Debug   gs,"Plot dosen't include any rotation or flipping"
        Push    "R0-R2"
        MOV     r0, #-1
        MOV     r1, #VduExt_XEigFactor
        SWI     XOS_ReadModeVariable    ; Get X Eig in R2
        MOV     r7, r4, LSR r2          ; Dest X-Size in pixels
        MOV     r1, #VduExt_YEigFactor
        SWI     XOS_ReadModeVariable    ; Get Y Eig in R2
        MOV     r8, r5, LSR r2          ; Dest Y-Size in pixels
        Pull    "R0-R2"
        MOV     r9, r2                  ; temp store of pointer to coord block;
        MOV     r10, r3                 ; temp store of length of data;
        ; find size of JPEG
        MOV     r1, r0                  ; pointer to JPEG
        MOV     r0, #1
        MOV     r2, r3                  ; length.
        ADRL    lr, jpegtrans_inforeturn
        Push    "LR"
        B       SWIJPEG_Info

        ; Make up scale factor...
jpegtrans_inforeturn
        Debug   gs,"scale factors are...",R7,R8,R2,R3
        SUB     sp, sp, #16             ; make room for scale factors
        STR     r7, [sp]
        STR     r8, [sp,#4]
        STR     r2, [sp,#8]
        STR     r3, [sp,#12]
        ; Set up registers for PutScaled Call
        MOV     r3, sp                  ; Pointer to Scale factors
        MOV     r0, r1                  ; Pointer to JPEG
        LDR     r1, [r9]                ; X-coordinate in 1/256th OSunit
        MOV     r1, r1, ASR #8
        LDR     r2, [r9,#28]            ; Y-coordinate in 1/256th OSunit
        MOV     r2, r2, ASR #8
        MOV     r4, r10
        MOV     r5, r11, LSR #1         ; Shift flags across for PlotScaled
        LDR     r6, [sp, #16+4*4]       ; Grab entry R5
        Debug   gs,"Calling PutScaled.R0,R1,R2,R3,R4,R5,R6=",R0,R1,R2,R3,R4,R5,R6
        ADRL    lr, jpegtrans_plotreturn
        Push    "LR"
        BL      SWIJPEG_PlotScaled

jpegtrans_plotreturn
        ; what if error returned?
        ADDVS   sp, sp, #16
        BVS     jpegtrans_errorexit1
        ; recover stack space
        Debug   gs,"Returned from putscaled"
        ADD     sp, sp, #16
        Pull    "R0-R11,PC"

jpegtrans_errorexit
        ADRL    R0,ErrorBlock_BadJPEGPlot
        BL      copy_error_one
        Debug   gs,"Done 'copy_error_one'"

jpegtrans_errorexit1
        ADD     sp, sp, #4                      ;Skip over r0
        Pull    "R1-R11,PC"

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; JPEG_PlotFileTransformed
; ------------------------
; Entry: R0 = Pointer to control charater terminated filename for JPEG image
;        R1 = flag word
;                b0 set: R2 is pointer to dest. coords, else pointer to matrix
;                b1 set: dither output when plotting truecolour in 8bpp or less.
;                b2 set: Full error-diffusion when plotting to 8bpp.
;                b4 set: R3 is pointer to colour mapping descriptor
;                b5-b12: Translucency (0=opaque, 255=1/256 visibility)
;        R2 = pointer to matrix (as for Draw module) or
;             pointer to destination co-ordinate block.
;        R3 = pointer to colour mapping descriptor (if relevant)
;
; Exit : all registers preserved.
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SWIJPEG_PlotFileTransformed
        Pull    "LR"
        Push    "R0,R3-R6,LR"
        LDR     r4, =JPEGFlag_Transformed_Translucency+JPEGFlag_Transformed_Colourmap+JPEGFlag_Transformed_Coords_In_R2+JPEGFlag_Transformed_Dither_Enable+JPEGFlag_Transformed_Error_Diffused_Dither
        BICS    r4, r1, r4
        Pull    "R0,R3-R6", NE
        ADRNEL  R0, ErrorBlock_BadFlags
        addr    r1, Title, NE
        BLNE    copy_error_one           ; Always sets the V bit
        Pull    "PC", VS

        Push    "R1-R3"

        ; Find out file size.
        MOV     r1, r0
        MOV     r0, #OSFile_ReadWithTypeNoPath
        SWI     XOS_File
        CMP     r0, #object_nothing
        BEQ     jpegplotfiletrans_nofile
        Debug   gs,"File size =", r4

        ; Claim space for buffer from Module area.
        MOV     r0, #ModHandReason_Claim
        MOV     r3, r4                   ; size of JPEG buffer
        SWI     XOS_Module               ; pointer to block now in r2
        Debug   gs,"Block for JPEG =", R2
        BVS     jpegplotfiletrans_error  ; jump out and return error.

        ; Read file into buffer
        MOV     r6, r2                   ; Move r2 to r6 because r2 gets changed by OS_FILE
        MOV     r3, #0                   ; clear r3 so r2 used as load address
        MOV     r0, #OSFile_LoadNoPath
        Debug   gs,"Loading file: r0,r1,r2,r3 =", R0,R1,R2,R3
        SWI     XOS_File                 ; file name still in r1
        BVS     jpegplotfiletrans_error  ; jump out and return error.
        Debug   gs,"Load address = ",R6
        MOV     r3, r4
        MOV     r0, r6
        Pull    "R1-R2,R4"               ; pull original parameters into correct regs for JPEG_plotTransformed.
        Push    "R6"                     ; store address of buffer so we can free it.
        ADR     LR, jpegplottrans_return ; set up return from plot code.
        Push    "LR"
        Debug   gs,"Calling PlotTransformed: R0,R1,R2,R3,R4,R5=",R0,R1,R2,R3,R4,R5
        B       SWIJPEG_PlotTransformed

jpegplottrans_return
        Debug   gs,"Return From PlotTransformed: R0,R1,R2,R3=",R0,R1,R2,R3
        MOVVS   r4, #1                  ;keep record of error after next SWI call.
        MOVVC   r4, #0

jpegplotfiletrans_exit1
        MOV     r5, r0                  ; temporarily store r0 and r2
        MOV     r6, r2
        Pull    "R2"                    ; recover location of buffer from stack
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module              ; Free module space
        BVS     jpegplotfiletrans_error2; jump out and return error.
        MOV     r0, r5                  ; recover original r0 and r2
        MOV     r2, r6
        CMP     r4, #1                  ; Did SWIJPEG_PlotTransformed return an error?
        BNE     jpegplotfiletrans_exit2
        SETV                            ; If so, make sure the V flag is set.
        B       jpegplotfiletrans_error2
        
jpegplotfiletrans_exit2
        Pull    "R0,R3-R6,PC"

jpegplotfiletrans_nofile
        ADRL    R0,ErrorBlock_NoFile
        Pull    "R1-R3"
        MOV     r4, r1
        Pull    "R1"                     ;should be r0 saved at start...
        BL      copy_error_one
        MOV     r1, r4
        Pull    "R3-R6,PC"

jpegplotfiletrans_error
        Pull    "R1-R3"
        Debug   gs,"about to return from fileTransformed..."
jpegplotfiletrans_error2
        ADD     sp, sp, #4
        Pull    "R3-R6,PC"

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; JPEG_PDriverIntercept
;----------------------
; Entry: R0 = flags
;             b0 = intercept state; 0 = off, 1 = on
;             b1 = set: plot all JPEGs using translation table
;             b2-31 reserved (set to 0)
;
; Exit : all registers preserved.
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SWIJPEG_PDriverIntercept
        Debug   gs,"Pdriver Intercept called...."
        Push    "R1"
        LDR     r1, save_PdriverIntercept
        AND     r0, r0, #JPEGFlag_Intercept_Pass_On_Plots :OR: JPEGFlag_Intercept_Use_Translation_Table
        STR     r0, save_PdriverIntercept
        Debug   gs, "Setting the Pdriver intercept flag to ...",R0
        MOV     r0, r1
        Pull    "R1,PC"

        ; Entry:  r0 points to JPEG/filename
        ;         r2 = 0 for JPEG in memory/1 for file
        ;         exit level for C panic set up
        ; Exit:   r1 = image type in bits 0-2, ratio in bit 7, SOF type in bits 8-11
        ;         r2 = width
        ;         r3 = height
        ;         r4 = X density
        ;         r5 = Y density
        ;         r6 = memory required
asm_find_image_dims ROUT
        Push    "R0,SL,LR"
        SUB     sp, sp, #20             ; space for image_dims_info structure and ws_size
        MOV     r4, r0
        MOV     r5, r2

        ; Update the area size incase the user resized it since last time
        LDR     r0, area_numbers + 8    ; currently only 1 user resizable
        MOVS    r2, r0
        BEQ     %FT10                   ; no area yet
        SWI     XOS_ReadDynamicArea     ; find out how big area is
        MOVVS   r1, #0                  ; area vanished (pretend zero size)
        MOVS    r2, r1                  ; area resized to nothing
        LDRNE   r2, jpeg_info_ptr
        STRNE   r1, [r2, #cinfo_workspace_size]
10
        STR     r2, jpeg_info_ptr
        MOV     r1, r2

        MOV     r0, r4                  ; put regs back where they should be
        MOV     r2, r5
        STR     r1, [sp]
        ORR     r2, sp, r2              ; r2->int (for ws_size plus flags in bits 0 & 1)
        ADD     r1, sp, #1*4            ; r1->image_dims_info structure
                                        ; r0->jdata
        MOV     sl, r12                 ; will be left alone by compiled C - for debug routines above.
        Debug   gs,"calling find_image_dims: R0,R1,R2,R3 =",R0,R1,R2,R3

        BL      jpeg_find_image_dims    ; dive into the C - returns 0 in r0 if all is well.

        Debug   gs,"just returned: R0 =",R0
        MOV     r12, sl                 ; R12 is ip to a C prog, will have been trampled on - restore it.
        CMP     r0, #2
        BHI     %FT99                   ; an OS error to pass on
        ADREQL  r0, ErrorBlock_BadJPEGUnsupported
        BEQ     %FT98                   ; Is JPEG but not supported
        TEQ     r0, #1
        ADREQL  r0, ErrorBlock_BadJPEG
        BEQ     %FT98                   ; Is not JPEG
        
        LDMIA   sp, {r0,r1-r4}          ; get memory requirements; image type; width; height; packed density
        MOV     r6, r0                  ; memory requirements in right register
        
        Debug   gs, "type = ",R1
        Debug   gs, "width, height = ",R2,R3
        MOV     r5, r4, LSL #16         ; put density into 2 separate regs.
        MOV     r5, r5, LSR #16
        MOV     r4, r4, LSR #16
        Debug   gs, "xdens, ydens =",R4,R5
        ADDS    sp, sp, #20             ; get rid of stack workspace & clear V
        Pull    "R0,SL,PC"
98
        BL      copy_error_one        
99
        SETV
        ADD     sp, sp, #20             ; get rid of stack workspace
        Debug   gs,"r0(err) =",R0
        ADD     sp, sp, #4              ; skip over stored version of r0
        Pull    "SL,PC"                 ; pull up other two

        END
@


4.24
log
@Transcode arithmetics
Detail:
  Import of the raw coefficient Huffman entropy compressor elements of the IJG8d library.
  We don't need a full compressor (ala JCompMod) since there's never a need to go all the way through IDCT/upsampling/colour conversion only to reverse the whole process; it's sufficient only to collect up the raw coefficients and recompress them as a baseline JPEG.
  Two extra (temporary) dynamic areas are introduced, once to hold the raw coefficients and the other to act as a scratch file to make the JPEG in. See Doc/JPEGMmgr.
Admin:
  Submission for the JPEG bounty.

Version 1.72. Tagged as 'SprExtend-1_72'
@
text
@d450 1
a451 1
        Pull    "R0"                              ; original R0 (pjs_jpegdata)
d463 1
a463 1
        ADD     sp,sp,#4                          ; junk pjs_jpegdata
@


4.23
log
@Import of IJG8d library sources
Detail:
  Using the decoder in "example.c" as a starting point, we try to follow that sequence more closely even if in our embedded implementation some of the functions don't do much.
  Uses the default colour backend for 32bpp BGR output for most of the unusual cases.
  The most common 2x2 subsampling case uses a custom merged upsampler and colour converter, with colour output directly in RISC OS format for the respective screen mode.
Admin:
  Submission for the JPEG bounty.

Version 1.71. Tagged as 'SprExtend-1_71'
@
text
@d397 1
a397 1
        LDR     r0, area_number
d443 2
a444 2
        LDR     r0,ccompiler_errptr
        CMP     r0, #0                            ; did C code return an error?
d465 13
a477 1
        TST     r0, #ERROR_BAD_JPEG               ; C code returned bad jpeg error
d479 1
a479 1
        TST     r0, #ERROR_NO_MEMORY              ; C code bombed out with no memory
d968 1
a968 1
        LDR     r0, area_number
@


4.22
log
@Update headers to stock copy
Detail:
  Added headers jerror, jmorecfg, jpegint from IJG8d. Removed jpegdata header.
  Bulk rename of structure members to match newer headers, some RISCOS-isms wrapped in #ifdef RISCOS, retained for the time being.
  Assembler code now gets cinfo member offsets from jhdr.s derived from the C header rather than keeping its own dangerous copy of the offsets.
Admin
  Note: this has broken CFSI-jpeg as it expects the error values to be at the top of cinfo.
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_70-headers.
@
text
@a395 1
      [ dynamicarea
d407 1
a407 1
      ]
a951 1
      [ dynamicarea
d954 1
d967 1
a969 3
      |
        LDR     r1, jpeg_info_ptr
      ]
@


4.21
log
@Rewrite of find_image_dims
Detail:
  Now handles 0xFF padding, previously acceptable encoded images including padding were incorrectly rejected.
  Calculate the workspace for greyscale images correctly, the itype flags included the density (and latterly the SOF) flags, but the workspace calculation assumed it only contained 1 or 3 (for colour components).
  Exit cases now made common and propagate file errors correctly.
  Minor changes to the assembler that uses find_image_dims to handle 4 colour component return (now a 3 bit return value).
  Merge the other M_THING enum from IJG8d so we don't need our own copy.
  Fix signed pointer comparison.
  Use symbolic defines from Global & Interface headers where possible.
  The jdata pointer arg is now treated as const.
Admin:
  Submission for the JPEG bounty.

Version 1.70. Tagged as 'SprExtend-1_70'
@
text
@d405 1
a405 1
        STRNE   r1, [r2, #workspace_size]
d964 1
a964 1
        STRNE   r1, [r2, #workspace_size]
@


4.20
log
@Fix corrupt R0 during JPEG plot
The JPEG_PlotScaled SWI (and friends) was pulling R0 at the wrong moment, so corrupting it. This manifested as "Incomplete or corrupt JPEG" when trying to plot a JPEG via the PostScript driver for example (which expects R0 preserved for no error).
Looks like ~5 year old bug, presumably not many people printing JPEGs to PostScript, or all suffering in silence.
Tested on a Risc PC - printed a picture from !Draw to postscript, then PDF'd it.

Version 1.69. Tagged as 'SprExtend-1_69'
@
text
@d149 2
a150 2
        AND     r0, r1, #3
        TEQ     r0, #3                  ; JPEG Colour = 3, JPEG Mono = 1
d152 1
a152 1
        MOVEQ   r0, #0
a450 1
        Pull    "R0"                              ; original R0 (pjs_r0save)
d452 1
d464 1
a464 1
        ADD     sp,sp,#4                          ; junk pjs_r0save
d944 1
a944 1
        ; Exit:   r1 = image type in bits 0 & 1, ratio in bit 7, SOF type in bits 8-11
d980 1
a980 1
        BL      find_image_dims         ; dive into the C - returns 0 in r0 if all is well.
@


4.19
log
@Fix for stack imbalance
In revision 4.17 the extra argument in R5 changed the stack frame, but the 'file not found' error exit was missed.
Submission from Rick Murray. Fixes ticket #398.

Version 1.64. Tagged as 'SprExtend-1_64'
@
text
@d451 1
a452 1
        Pull    "R0"                              ; original R0 (pjs_jpegdata)
d464 1
a464 1
        ADD     sp,sp,#4                          ; junk pjs_jpegdata
@


4.18
log
@Update to work with new "32K+" colour translation tables
Detail:
  Sources/SWIs, Sources/SprExtend, Sources/SprOp, c/PutScaled, c/sprtrans, h/putscaled - Cache the sprite NColour value in the save_* workspace
  Sources/SprOp - Update preparettr to perform extra validation on 32K-style translation tables (old "32K." or new "32K+"). Although we could potentially accept any format table, to cut down on the number of plotter combinations we currently require that the table matches the format that ColourTrans will create when given the source sprite.
  c/PutScaled, c/sprtrans - Update comments relating to determining input format of TTRType_32K tables
Admin:
  Tested on BB-xM
  Requires Colours-1_89


Version 1.61. Tagged as 'SprExtend-1_61'
@
text
@d593 1
a593 1
        Pull    "R1-R4"
@


4.17
log
@Add support for blended sprite & JPEG rendering - alpha masks, alpha channels, and translucency
Detail:
  This big set of changes adds support for the following user-facing APIs, as per ROL's specs:
  - OS_SpriteOp 52 (PutSpriteScaled) colour mapping, translucency blending, and alpha mask/alpha channel blending
  - OS_SpriteOp 56 (PutSpriteTransformed) colour mapping, translucency blending, and alpha mask/alpha channel blending
  - JPEG_Plot[File]Scaled colourmapping & translucency blending
  - JPEG_Plot[File]Transformed colourmapping & translucency blending
  Sources/CFSI-JPEG, Sources/PutScaled:
  - Added exit_oserror exit routine for use by C code.
  - For SpriteExtend this allows the C code to cause OS_SpriteOp to exit with a given OS error block.
  - For CFSI-JPEG the error block is returned and ERROR_FATAL is returned to ChangeFSI.
  Sources/CSupport:
  - Add definitions for some error codes (matches existing definitions from h/commondefs)
  Sources/PutScaled:
  - Stripped out code to look for identity translation tables; now handled by preparettr routine in Sources/SprOp
  Sources/SWIs, Hdr/SprExtend:
  - JPEG SWIs updated to add support for alpha-blended and colour mapped JPEG rendering, following ROL's APIs
  Sources/SprExtend:
  - Stripped out lots of old build flags which haven't been touched in years.
  - Strip out assembler SprTrans code generator.
  - Add new definitions needed for blending & colour mapping.
  Sources/SprOp:
  - Updated PutScaled frontend to deal with blending and colour mapping.
  - Disabled code which was bodging coordinates when dealing with double-pixel modes - it seems to cause a few issues, and the code generator mostly had proper double-pixel support anyway.
  - Translation table verification and fiddling code rewritten and consolidated into the preparettr routine. C code is now explicitly told what table type is in use and whether it can safely be ignored in favour of using the sprite palette.
  - Removed code from CheckSpriteArea which was deliberately throwing an error upon seeing alpha-masked sprites; I think the bug that was hiding has been fixed now
  Sources/SprTrans
  - Removed the assembler version of the code generator.
  - Updated to add support for blending and colour mapping
  c/PutScaled:
  - Old test code removed.
  - Updated to add support for blending & colour mapping
  - Assorted bugs fixed.
  - A few extra architecture-specific optimisations added.
  - Some workspace setup code moved to c/asmcore to allow sharing with SprTrans.
  c/asmcore:
  - Register allocation code rewritten. Instead of allocating on a first-come, first-served basis, the code now builds a list of which logical registers are needed (and which 'banks' they fall into) and then attempts to allocate them in a more intelligent manner. It still has some failings (e.g. reusing R12 as a general purpose register is currently impossible) but it's a lot more flexible and reliable than the old code.
  - Core pixel transformation code updated to add support for blending & colour mapping
  - Added some extra architecture-specific optimisations
  c/rojpeg:
  - JPEG option handling updated to avoid trashing any colour mapping descriptor that may have been passed in
  c/sprtrans:
  - Updated to add support for blending & colour mapping
  c/tracing:
  - Debug assert messages now show filename as well as line number
  h/commondefs:
  - Removed old #define's that related to old assembler switches.
  h/putscaled:
  - Workspace definition updated to match assembler version.
  - SprTrans stack workspace structure moved here from c/sprtrans
Admin:
  Tested on BB-xM plotting all major sprite & JPEG types into all modes with all major options


Version 1.55. Tagged as 'SprExtend-1_55'
@
text
@d393 2
@


4.16
log
@Obey bit 0 of JPEG_[File]Info flags.
When clear, r2 and r3 are preserved per PRM documentation.
Also BIC'd out bits 7-10 of r0 on return so they can be reused in future, previous version would always have returned &C in those bits.

Version 1.36. Tagged as 'SprExtend-1_36'
@
text
@d222 3
d243 13
d347 4
d391 2
a427 1
        STR     R1,save_sprite          ; so that later code can find the JPEG data again
d464 1
a464 1
        TST     r0, #2                            ; C code returned bad jpeg error
d466 2
a467 2
        TST     r0, #4                            ; C code bombed out with Fatal error
        BNE     jpegscaled_errorexit2             ; Otherwise must have a "Run out of memory" error
d520 3
d528 2
a529 1
        BICS    LR, r4, #JPEGFlag_Scaled_Dither_Enable :OR: JPEGFlag_Scaled_Error_Diffused_Dither
d537 1
a537 1
        Push    "R1-R4"
d564 2
a565 2
        Pull    "R1-R3,R5"               ; pull original parameters into correct regs for JPEG_plotscaled.
        Push    "R6"                     ; store address of buffer so we can free it.
d568 1
a568 1
        Debug   gs,"Calling PlotScaled: R0,R1,R2,R3,R4,R5=",R0,R1,R2,R3,R4,R5
d599 1
a599 1
        Pull    "R1-R4"
d614 2
d619 1
d627 2
a628 1
        BICS    r4, r1, #JPEGFlag_Transformed_Coords_In_R2 :OR: JPEGFlag_Transformed_Dither_Enable :OR: JPEGFlag_Transformed_Error_Diffused_Dither
d705 1
a705 1
        MOV     r5, r1, LSR #1
d710 2
a711 1
        Debug   gs,"Calliing PutScaled.R0,R1,R2,R3,R4,R5=",R0,R1,R2,R3,R4,R5
d793 3
a795 2
        MOV     r5, r11, LSR #1
        Debug   gs,"Calling PutScaled.R0,R1,R2,R3,R4,R5=",R0,R1,R2,R3,R4,R5
d826 2
d830 1
d838 2
a839 1
        BICS    r3, r1, #JPEGFlag_Transformed_Coords_In_R2 :OR: JPEGFlag_Transformed_Dither_Enable :OR: JPEGFlag_Transformed_Error_Diffused_Dither
@


4.16.2.1
log
@New jerror.h taken from IJG8b.
Swap to using JERR_ numbers, deleted E_ numbers.
Modify genjhdr to pass some defines to the assembler code, so jdcolor can clarify use of DCTSIZE and DCTSIZE2.
Added chart of possible subsampling ratios to documentation.

Version 1.38, 1.35.2.9. Tagged as 'SprExtend-1_38-1_35_2_9'
@
text
@d885 1
a885 1
; ---------------------
@


4.16.2.2
log
@Remap return results for CFSI-JPEG to match new cinfo structure.
Tested with a handful of JPEGs and !ChangeFSI.

Version 1.38, 1.35.2.11. Tagged as 'SprExtend-1_38-1_35_2_11'
@
text
@d381 1
a381 1
        STRNE   r1, [r2, #cinfo_workspace_size]
d927 1
a927 1
        STRNE   r1, [r2, #cinfo_workspace_size]
@


4.15
log
@API enhancement and space saving refactoring.
Setting bit 1 of r0 in JPEG_FileInfo and JPEG_Info will now return the SOF type of the JPEG in question in bits 3-6 of the info flags in r0 on exit.
Took this opportunity to refactor find_image_dims to take a structure pointer rather than lots of individual pointers (CFSI-JPEG ammended to match). Untangled the return codes a bit so it is only necessary to inspect r0 on exit from C to determine the outcome. Values of 1 & 2 are translated in the assembler code into more specific error messages than just "Incomplete or corrupt JPEG".
Fix bug where unknown density marker would leave the file open in JPEG_FileInfo.
Don't bother ADRL'ing r1 for error messages that don't have a %0 in them.
Added all the input & output flag definitions to the exported header file so other callers can use them too.
More functionality, fewer bugs, about 200 bytes smaller too.

Version 1.35. Tagged as 'SprExtend-1_35'
@
text
@d142 1
a143 1
        MOV     r7, r0                  ; keep flags for later
d164 2
@


4.14
log
@Fix infinite loop when unrecognised entropy encoding encountered.
In find_image_dims() the while loop is only exited when SOF0 or SOF1 (the two supported ones) is encountered, the other 14 possible combinations got stuck in a loop because OS_GBPB doesn't return an error at EOF.
Check added for OS_GBPB returning nothing, plus an exit when a SOS or EOI tag is hit for the memory only check (it's not possible to know where the end truly is in that case.
jcconv: warning supressed.
SWIs: comment corrected.
Tested with a bogus SOF, now gives an error message instead.

Version 1.34. Tagged as 'SprExtend-1_34'
@
text
@a62 2
        Push    "R1"
        ADRL    R1, Title
d64 1
a64 1
        Pull    "R1, PC"
d106 1
d114 1
d125 1
a125 1
        Debug   gs,"JPEG: LR =",LR
d128 6
a133 3
        CLRPSR  I_bit, R14              ; re-enable interrupts
        BICS    r3, r0, #1              ;has someone set illegal flags?
        ADRNEL  R0, ErrorBlock_BadFlags
d138 3
a140 8
        ; Set escape stack level in case of unexpected exit from C code.
        STR     SP,ccompiler_sp         ; in case of unexpected exit
        MOV     R4,#0
        STR     R4,ccompiler_errptr     ; in case of error exit
        MOV     r3,r0                   ; put flags into r3
        MOV     r0,r1                   ; put JPEG pointer into r0
        MOV     r7,r1                   ; copy JPEG pointer into r7
        MOV     r2, #0
d142 2
a143 2
        BL      asm_find_image_dims     ; corrupts r0 and sl, sets r1,r2,r3,r4,r5
        BVS     jpeginfo_exit
d145 2
a147 9
        ; If not JPEG Set V and point r0 to error block then pull out...
        CMP     r1, #0
        BEQ     jpeginfo_exit1
        ; If not JPEG Set V and point r0 to error block then pull out...
        AND     r0, r1, #3              ; temp use of r0
        TEQ     r0,#3                   ; Is JPEG Colour?
        BICEQ   r1,r1,#3                ; If so, Reset bits 0 and 1.
        TST     r1, #&100               ; is the pixel density a ratio?
        ORRNE   r1, r1, #4
d149 10
d160 1
a160 1
        ORR     r1, r1, #2              ;SET bit 1 because we can't transform JPEGS
d163 2
a164 3
        AND     r0,r1,#7                ; put result flags into r0
        MOV     r1,r7                   ; restore JPEG pointer in r1

a166 1
        ADDS    sp,sp,#6*4              ; get rid of saved r1-r6 - clear V
a169 6
jpeginfo_exit1
        ADRL  R0,ErrorBlock_BadJPEG
        BL      copy_error_one
jpeginfo_exit
        Pull    "R1-R9,PC"

d178 2
a200 1
        Debug   gs, "Filename pointer = ",r1
d202 1
a202 1
        Debug   gs,"JPEGFile: LR =",LR
d205 3
a207 39
        CLRPSR  I_bit, R14              ; re-enable interrupts

        BICS    r3, r0, #1              ;has someone set illegal flags?
        ADRNEL  R0, ErrorBlock_BadFlags
        addr    r1, Title, NE
        BLNE    copy_error_one          ; Always sets the V bit
        BVS     exitbiggie
        ; Set escape stack level in case of unexpected exit from C code.
        STR     SP,ccompiler_sp         ; in case of unexpected exit
        MOV     R4,#0
        STR     R4,ccompiler_errptr     ; in case of error exit
        MOV     r3,r0                   ; put flags into r3
        MOV     r0,r1                   ; put JPEG pointer into r0
        MOV     r7,r1                   ; copy JPEG pointer into r7
        MOV     r2, #1                  ; r1 is pointer to filename...

        BL      asm_find_image_dims     ; corrupts r0 and sl, sets r1-r6
        BVS     jpeginfo_exit

        Debug   gs,"return from C: R1,R2,R3 =",R1,R2,R3
        ; If not JPEG Set V and point r0 to error block then pull out...
        CMP     r1, #0
        BEQ     jpeginfo_exit1
        AND     r0, r1, #3              ; temp use of r0
        TEQ     r0,#3                   ; Is JPEG Colour?
        BICEQ   r1,r1,#3                ; If so, Reset bits 0 and 1.
        TST     r1, #&100               ; is the pixel density a ratio?
        ORRNE   r1, r1, #4

        ;******THIS MUST BE REMOVED WHEN TRANSFORMATIONS ARE ALLOWED*********
        ORR     r1, r1, #2              ;SET bit 1 because we can't transform JPEGS
        ;******THIS MUST BE REMOVED WHEN TRANSFORMATIONS ARE ALLOWED*********

        AND     r0, r1, #7              ; put result flags into r0
        MOV     r1,r7                   ; restore JPEG pointer in r1
        Debug   gs,"returning R0,R1,R2,R3 =",R0,R1,R2,R3
        Debug   gs,"returning R4,R5,R6 =",R4,R5,R6
        ADDS    sp,sp,#6*4              ; get rid of saved r1-r6 - clear V
        Pull    "R7-R9,PC"              ; copied from exitbiggie, but returning r1-r6 - r0 restored by exit sequence.
a229 1
      ]
a231 3
        MOV     R1, R0
        MOV     R2, R4
      [ debuggs
d235 2
d238 1
a238 3
        CLRPSR  I_bit, R14              ; re-enable interrupts

        BICS    r3, r5, #3              ;has someone set illegal flags?
d244 1
a244 1
        AND     r3, r5, #3
d317 2
a318 1
        BL      asm_find_image_dims                ; sets r1-r6
a319 2
        CMP     r1,#0                              ; if 0, it's not good JPEG data
        BEQ     jpegscaled_errorexit1
d502 1
a502 1
        BICS    LR, r4, #3               ; has someone set illegal flags?
d597 1
a597 1
        BICS    r4, r1, #7              ;has someone set illegal flags?
d802 1
a802 1
        BICS    r3, r1, #7               ; has someone set illegal flags?
d896 1
a896 1
        AND     r0, r0, #3
d904 2
a905 2
        ;         exit level for C escape set
        ; Exit:   r1 = 0 or 1 or 3 for not-jpeg or mono or colour
d908 3
a910 3
        ;         r4 = Xdensity
        ;         r5 = Ydensity
        ;         r6 = Memory required
d912 2
a913 3

        Push    "r0,sl,lr"
        SUB     sp,sp,#36               ; space for 5+6+7th args, and five returned results
d934 6
a939 15

        STR     r1, [sp, #32]
        ADD     r2, r2, sp
        ADD     r2, r2, #32             ; place to store memory requirements
        STR     r2,[sp,#4]              ; set sixth arg to r2
        ADD     r2,sp,#24               ; set up r2 with pointer to 5th returned result
        STR     r2,[sp]                 ; set fifth arg to point to return area
        ADD     r2,sp,#28               ; set up r2 with pointer to error buffer
        STR     r2,[sp,#8]              ; set seventh arg to error space
        Debug   gs,"err =",R2
        ADD     r1,sp,#12               ; set second arg
        ADD     r2,sp,#16               ; set third arg
        ADD     r3,sp,#20               ; set fourth arg
        MOV     SL,R12                  ; will be left alone by compiled C - for debug routines above.
        Debug   gs,"calling CC: R0,R1,R2,R3 =",R0,R1,R2,R3
d943 15
a957 11
        Debug   gs,"just returned: R0,R1,R2,R3,R4 =",R0,R1,R2,R3,R4
        MOV     R12,SL                  ; R12 is ip to a C prog, will have been trampled on - restore it.
        CMP     r0, #1
        LDRGT   r0, [sp,#28]
        BGT     %FT99
        Debug   gs,"returned"
        LDR     r2,[sp,#12]             ; get image width
        LDR     r3,[sp,#16]             ; get image height
        LDR     r4,[sp,#24]             ; get image density
        LDR     r6,[sp,#32]             ; get memory requirements
        Debug   gs, "returned density = ",R4
d962 4
a965 5
        MOVS    r1,r0                   ; is it JPEG?
        LDREQ   r1,[sp,#20]             ; get image_type - 1 or 3
        MOVNE   r1,#0
        ADD     sp,sp,#36               ; get rid of stack workspace
        Pull    "r0,sl,pc"
d968 1
a968 1
        ADD     sp,sp,#36               ; get rid of stack workspace
d970 2
a971 2
        ADD     sp, sp, #4              ; skip over stored verison of r0
        Pull    "sl,pc"                 ; pull up other two
@


4.13
log
@Change memory management strategy.
There's no need for the C code to know which pool of memory it's using, so simplify it to just use malloc() and realloc(), the assembler implementation can then select whether the RMA or a dynamic area is in use based on the 'dynamicarea' switch.
Be more careful about area_number when it is zero, since we use that to denote the area is not yet set up but area zero is a valid dynamic area number!
Trim out some unused workspace.
Variable ccompiler_errptr had '# 0' bytes assigned, resulting in writes off the end of the workspace.
Retire DUMPVAL[N]() macro.
Remove M_SOF9 as one of the SOF markers accepted - this is allocated to arithmetic JPEGs which aren't currently supported.
Save a few words by: changing arbitrary constants (eg. safety margins) to be a power of two so they can be register immediates; numerous loads and stores of R12 relative variables changed to not use ADRL; jpeg_fetchroutine similarly simplified.

Version 1.33. Tagged as 'SprExtend-1_33'
@
text
@d140 2
a141 2
        MOV     r0,r1                   ; put JPEG pointer into r3
        MOV     r7,r1                   ; put JPEG pointer into r6
d163 1
a163 1
        MOV     r1,r7                   ; put JPEG pointer into r1
d223 2
a224 2
        MOV     r0,r1                   ; put JPEG filename pointer into r3
        MOV     r7,r1                   ; put JPEG filename pointer into r6
@


4.12
log
@Paper and fill some JPEG cracks.
The exit_c function was repeatedly being called with the line number argument and error code the wrong way round and since only bits 0-2 of the error code are inspected on exit any fatal exits from the ported JPEG library code would either report the wrong error or fail silently (depending on the line number) - example a 12 bits per sample JPEG would be rendered without fault into a screen full of random memory garbage.
Assembling/compiling with the 'jpeg' switch off didn't work, fixed, and also now zeros out the SWI decode values in the module header.
Moved include of 'yuvtabs.s' into the colour conversion code.
Deleted panic_exit, it did nothing useful but trace a value then exit, so it now just calls exit() like everyone else.
Removed excess call to find_image_dims(), this was needed just to get the workspace requirements when the JPEG had already been sized up by asm_find_image_dims() earlier. Side effect of removing the pilot JPEG code earlier is that this call can now only get to the JPEG code from a JPEG_ SWI. Changed to just pass the workspace requirements into 'c.PutScaled' and save a duplicate scan.
Fatal exits from the assembler huffman decoder now report a sensible error.
Trimmed out all the JPEG assessment code from 'c.PutScaled' and moved it into 'c.rojpeg' so the put scaled is only concerned with putting things scaled.
Sanitised the #includes a bit.
Fixed on last check of wp->save_mode looking at the wrong bits for the mode number.
Resolved all the warning in the genhdr/genyuvtabs/genpalette utilities by casting a bit harder.[A[B
Added new more descriptive error messages to the messages file (not currently used), and made the 'not supported by' ones consistent so the tokeniser might crunch the file a bit more.
In looks_like_jpeg() changed a bitwise to logical or.
Fixed longstanding problem of not being able to render JPEGs at a scale of less than 1/6 in any greyscale mode, because, err, there was no code to do it - only the colour case was checked for. Implemented for 8bpp grey and 32bpp grey (which gets dithered for other lower modes) by just converting the luma channel into an equally weighted RGB value or replicating it for 256 greys.
Tested in all 8 colour depths on a Risc PC using sampling ratios of 1x1; 2x1; 1x2; 2x2 of the IJG test image scaled in !Draw by 0.16.

Version 1.32. Tagged as 'SprExtend-1_32'
@
text
@d120 1
a120 1
;        r6 = 0  (reserved for future use)
d136 1
a136 2
        ADRL    R3,ccompiler_sp
        STR     SP,[R3]                 ; in case of unexpected exit
d138 1
a138 2
        ADRL    R5,ccompiler_errptr
        STR     R4,[R5]                 ; in case of error exit
d202 1
a202 1
;        r6 = 0  (reserved for future use)
d219 1
a219 2
        ADRL    R3,ccompiler_sp
        STR     SP,[R3]                 ; in case of unexpected exit
d221 1
a221 2
        ADRL    R5,ccompiler_errptr
        STR     R4,[R5]                 ; in case of error exit
d273 2
a275 1
        Debug   gs,"r0 at start =",R0
d277 1
a277 3
        Debug   gs,"JPEG_PlotScaled sprite: R0,R1,R2 =",R0,R1,R2
        Debug   gs,"JPEG_PlotScaled sprite: R3,R4,R5 =",R3,R4,R5
        Debug   gs,"JPEG_PlotScaled sprite: R6,R7 =",R6,R7
d280 2
d291 1
a292 1
        STR     r3, dither_truecolour
d295 1
a295 2
        ADRL    R3,ccompiler_sp
        STR     SP,[R3]                 ; in case of unexpected exit
d297 1
a297 2
        ADRL    R5,ccompiler_errptr
        STR     R4,[R5]                 ; in case of error exit
d417 13
d462 1
d465 2
a466 2
        ADRL    r1, ccompiler_errptr
        LDR     r0, [r1]
d963 1
a963 1
        MOV     r4, r0                  ; temporrarily store regs r0 and r2
d965 1
d967 2
d970 4
a973 3
        BVS     %FT10
        CMP     r1, #0                  ; if size is zero act as if we had no JPEG workspace
        LDRNE   r1, jpeg_info_ptr
d975 3
a977 1
        MOVS    r0, r4                  ;put regs back where they should be.
d982 1
@


4.11
log
@Get scaled/transformed JPEG widths right
Function asm_get_image_dims returns width in r2, was using r0, so version 1.30 would leave shadows in !Draw. Changed to use r2.

Version 1.31. Tagged as 'SprExtend-1_31'
@
text
@d309 1
a309 1
        ;   12 bytes immediately following the fake sprite of JPEG credentials (compress_id_words)
d313 1
d320 1
a320 1
pjs_compressid  #       12
d368 2
a369 2
        BL      asm_find_image_dims                ; sets r1,r2,r3
        Debug   gs,"found dims... R1,R2,R3=",R1,R2,R3
d373 2
d1009 1
a1009 1
        Pull    "sl,pc"                 ; pull up other three
@


4.10
log
@Remove pilot JPEG code.
During the original development (referred to in the docs as Sprite Extend 2) JPEG data was briefly wrapped inside a sprite file before the JPEG_ swis were introduced. Within SpriteExtend some code still remained to fake a mode 20 sprite header with the JPEG output sized adjusted as though it was 4bpp, then later undo the faking by checking for a mode 20 sprite with is_it_jpeg set.
This version removes all of the code looking out for pilot JPEGs, and rationalises the fake sprite header to just report the true X/Y size.
Fix bug where r4 would be corrupted on exit from JPEG_PlotScaled if an error occurred, and generally rationalised the exit cases a bit more sensibly.
Made the JPEG_ swi despatch a bit more simple to follow.
Corrected a comment in the NSM_bpptable.
Deleted unused 'ecfspace' from the workspace.
Hid the 'macroword' from the C code as it's now an assembler only value.
Cut the initial comments from c/putscaled and placed in Docs.
Cut the debug tracing code (a notable %age) from c/putscaled and placed in tracing support file.
Simplified the entry to putscaled_compiler() now we don't have to look out for pilot format JPEGs within sprites any more.
Sprinkled in some block comments to make navigating the c/putscaled file a bit easier.

Version 1.30. Tagged as 'SprExtend-1_30'
@
text
@d375 2
a376 2
        SUB     r0,r0,#1
        STR     r0,pjs_sprite+spWidth              ; number of words - 1 at 32bpp
d667 1
a667 1
        MOV     r8, r2                  ; put into r7
@


4.9
log
@Title line made consistent.
No code change - not tagged.
@
text
@d17 7
a24 1

d45 5
a49 1
        BNE     NonPrinterSWI
d51 6
a56 5
        LDR     r8, save_PdriverIntercept
        TST     r8, #1
        BNE     JPEGSWI_Printer
        Pull    "R8"
NonPrinterSWI
d58 1
a58 1
        ADDCC   R14,R11,#(swijptable-swijporg-4)/4    ; bodge factor
d60 1
a67 6
JPEGSWI_Printer
        AND     r8, r11, #63
        Debug   gs, "I should be calling the printer SWI...",R8
        SWI     XPDriver_JPEGSWI
        Pull    "R8,PC"

d76 2
a77 3
endswijptable
maxnewswi   *   (endswijptable-swijptable)/4

d103 20
a122 23
;SpriteExtend_AreaName
;       DCB     "SpriteExtend JPEG",0
;       ALIGN

;SWIJPEG_Info
;In:
;  r0 = flags for desired operation
;         b0 set : return dimensions.
;  r1 = Pointer to JPEG image in memory.
;  r2 = length of data in memory (bytes)
;
;Out:
;  r0 = returned information flags.
;         b0 set : greyscale image.
;         b1 set : set if transformed plots are not supported.
;         b2 set : pixel density is only a ratio.
;  r1 preserved
;  r2 = width in pixels.
;  r3 = height in pixels.
;  r4 = X pixel density.
;  r5 = Y pixel density
;  r6 = 0  (reserved for future use)
;
a123 1

d135 1
a135 1
; Set escape stack level in case of unexpected exit from C code.
d147 1
a148 1
        BVS     JPEGInfo_Exit
d150 1
a150 1
; If not JPEG Set V and point r0 to error block then pull out...
d152 2
a153 2
        BEQ     JPEGInfo_Exit1
; If not JPEG Set V and point r0 to error block then pull out...
a156 1
;        ORR     r1,r1,#&ff00            ; get them to mask out top bits, in case we use them for other things later.
d160 1
a160 1
;******THIS MUST BE REMOVED WHEN TRANSFORMATIONS ARE ALLOWED*********
d162 1
a162 1
;******THIS MUST BE REMOVED WHEN TRANSFORMATIONS ARE ALLOWED*********
d166 1
a166 1
;        MOV     r6,#0
d173 1
a173 1
JPEGInfo_Exit1
d176 1
a176 1
JPEGInfo_Exit
d185 1
a185 69
asm_find_image_dims
; On entry:
;   r0 points to JPEG/filename
;   r2 = 0 for JPEG in memory/1 for file
;   exit level for C escape set
; On exit:
;   r1 = 0 or 1 or 3 for not-jpeg or mono or colour
;   r2 = width
;   r3 = height
;   r4 = Xdensity
;   r5 = Ydensity
;   r6 = Memory required
        Push    "r0,sl,lr"
        SUB     sp,sp,#36               ; space for 5+6+7th args, and five returned results
        [ dynamicarea
        MOV     r4, r0                  ; temporrarily store regs r0 and r2
        MOV     r5, r2
        LDR     r0, area_number
        SWI     XOS_ReadDynamicArea     ; find out how big area is
        BVS     %FT01
        CMP     r1, #0                  ; if size is zero act as if we had no JPEG workspace
        LDRNE   r1, jpeg_info_ptr
01
        MOVS    r0, r4                  ;put regs back where they should be.
        MOV     r2, r5
        |
        LDR     r1, jpeg_info_ptr
        ]
        STR     r1, [sp, #32]
        ADD     r2, r2, sp
        ADD     r2, r2, #32             ; place to store memory requirements
        STR     r2,[sp,#4]               ; set sixth arg to r2
        ADD     r2,sp,#24               ; set up r2 with pointer to 5th returned result
        STR     r2,[sp]                 ; set fifth arg to point to return area
        ADD     r2,sp,#28               ; set up r2 with pointer to error buffer
        STR     r2,[sp,#8]              ; set seventh arg to error space
        Debug   gs,"err =",R2
        ADD     r1,sp,#12               ; set second arg
        ADD     r2,sp,#16               ; set third arg
        ADD     r3,sp,#20               ; set fourth arg
        MOV     SL,R12                  ; will be left alone by compiled C - for debug routines above.
        Debug   gs,"calling CC: R0,R1,R2,R3 =",R0,R1,R2,R3
        BL      find_image_dims         ; dive into the C - returns 0 in r0 if all is well.
        Debug   gs,"just returned: R0,R1,R2,R3,R4 =",R0,R1,R2,R3,R4
        MOV     R12,SL                  ; R12 is ip to a C prog, will have been trampled on - restore it.
        CMP     r0, #1
        LDRGT   r0, [sp,#28]
        BGT     find_image_dims_error
        Debug   gs,"returned"
        LDR     r2,[sp,#12]             ; get image width
        LDR     r3,[sp,#16]             ; get image height
        LDR     r4,[sp,#24]             ; get image density
        LDR     r6,[sp,#32]             ; get memory requirements
        Debug   gs, "returned density = ",R4
        MOV     r5, r4, LSL #16         ; put density into 2 separate regs.
        MOV     r5, r5, LSR #16
        MOV     r4, r4, LSR #16
        Debug   gs, "xdens, ydens =",R4,R5
        MOVS    r1,r0                   ; is it JPEG?
        LDREQ   r1,[sp,#20]             ; get image_type - 1 or 3
        MOVNE   r1,#0
        ADD     sp,sp,#36               ; get rid of stack workspace
        Pull    "r0,sl,pc"
find_image_dims_error
        SETV
        ADD     sp,sp,#36               ; get rid of stack workspace
        Debug   gs,"r0(err) =",R0
        ADD     sp, sp, #4              ; skip over stored verison of r0
        Pull    "sl,pc"                 ; pull up other three
d187 7
a193 18
;SWIJPEG_FileInfo
;In:
;  r0 = flags for desired operation
;         b0 set : return dimensions.
;  r1 = pointer to control character terminated filename for
;       JPEG image.
;
;Out:
;  r0 = returned information flags.
;         b0 set : greyscale image.
;         b1 set : set if transformed plots are not supported.
;         b2 set : pixel density is only a ratio.
;  r1 preserved
;  r2 = width in pixels.
;  r3 = height in pixels.
;  r4 = X pixel density.
;  r5 = Y pixel density
;  r6 = 0  (reserved for future use)
d195 12
a207 1

d220 1
a220 1
; Set escape stack level in case of unexpected exit from C code.
d232 1
a233 1
        BVS     JPEGInfo_Exit
d235 1
a235 1
; If not JPEG Set V and point r0 to error block then pull out...
d237 1
a237 1
        BEQ     JPEGInfo_Exit1
a240 1
;        ORR     r1,r1,#&ff00            ; get them to mask out top bits, in case we use them for other things later.
d244 1
a244 1
;******THIS MUST BE REMOVED WHEN TRANSFORMATIONS ARE ALLOWED*********
d246 1
a246 1
;******THIS MUST BE REMOVED WHEN TRANSFORMATIONS ARE ALLOWED*********
a249 1
;        MOV     r6,#0
d255 14
a269 14
;SWIJPEG_PlotScaled
;In:
;  r0 = pointer to JPEG image in memory
;  r1 = x co-ordinate for plot
;  r2 = y co-ordinate for plot
;  r3 = scale factors or 0
;  r4 = length of data in memory
;  r5 = Flags
;       b0 set: dither output when plotting truecolour in 8bpp or less.
;       b1 set: Full error-diffusion when plotting to 8bpp.
;
;Out:
;  all registers preserved.
;
a270 1

d273 1
d276 1
d296 2
a297 1
; Set escape stack level in case of unexpected exit from C code.
a302 2
;        ADRL    R5,error_ptr
;        STR     R4,[R5]                 ; in case of error exit
d304 10
a313 5
; Space is allocated on the stack, as follows:
;   a fake sprite - spPalette+12 bytes
;   a translation table (in case ColourTrans writes one) - 256 bytes
;   saved registers R1-R9,LR so that exitbiggie can come back to us
        ^       0,sp
d317 3
a319 2
pjs_table       #       12                        ; biggest table we can allocate for plotting from 32bpp.
pjs_sprite      #       spPalette+12
d323 11
a333 10
; The sprite header sits on the stack. A sprite header consists of:
;   spNext    # 4  ;  Offset to next sprite
;   spName    # 12 ;  Sprite name
;   spWidth   # 4  ;  Width in words-1      (0..639)
;   spHeight  # 4  ;  Height in scanlines-1 (0..255/511)
;   spLBit    # 4  ;  First bit used (left end of row)
;   spRBit    # 4  ;  Last bit used (right end of row)
;   spImage   # 4  ;  Offset to sprite image
;   spTrans   # 4  ;  Offset to transparancy mask
;   spMode    # 4  ;  Mode sprite was defined in
d337 2
a338 1
        STR     r0,pjs_sprite+spName               ; terminated by a zero character (>>> is this right?)
d341 4
a344 1
        MOV     r0,#spPalette
d347 2
a348 2
; Set mode number to... &481680b5
        MOV     r0, #1
d352 1
a352 1
        ORR     r0, r0, #9:SHL:27                  ; Sprite Type = 9
d354 1
d356 6
a361 8
        Debug   gs,"sprite: R0,R1,R2 =",R0,R1,R2
        STR     r0,pjs_sprite+spPalette            ; store identifier for indirect JPEG data.
        STR     r1,pjs_sprite+spPalette+4          ; store pointer to JPEG data.
        Debug   gs,"r0 when stored =",R1
        STR     r2,pjs_sprite+spPalette+8          ; store length of JPEG data
;        STR     r0,pjs_sprite+spPalette            ; store identifier for indirect JPEG data.
;        STR     r1,pjs_sprite+spPalette+4          ; store pointer to JPEG data.
;        STR     r2,pjs_sprite+spPalette+8          ; store length of JPEG data
d363 2
a364 2
; Call find_image_dims to find the dimensions of the JPEG,
; and use this to fill in the rest of the sprite header.
d371 1
d374 8
a381 16
        AND     r0,r2,#7
        MOV     r0,r0,LSL #2                       ; (image_width & 7) * 4;
;fixing bug with word aligned jpegs?
        SUB     r0, r0, #1
        AND     r0, r0, #31
;end of hack
        STR     r0,pjs_sprite+spRBit               ; number of bits used in right hand word
        ADD     r0,r2,#7
        MOV     r0,r0,ASR #3
        SUB     r0,r0,#1                           ; ((image_width + 7) >> 3) - 1;
        STR     r0,pjs_sprite+spWidth              ; number of words - 1

; Call ColourTrans to get a suitable translation table for sending 32-bit data
; into this screen mode. This is either a 32K table, or no table at all.
; If this produces an error then we're probably on RISC OS 3.1,
; in which case we go forward with no translation table.
d384 1
a384 1
        MOVEQ   r7,#0                         ; error return - not new ColourTrans
d388 2
a389 2
        ORR     r0,r0,#1                      ; new mode number for 32bpp
        MOV     r1,#-1                        ; default input, output, palette, everything
d392 2
a393 2
        ADR     r4,pjs_table                  ; pointer to buffer to put table in
        MOV     r5,#0                         ; no special flags
d397 2
a398 2
        BVS     jpegscaled_errorexit          ; error return, no table about
        ADR     r7,pjs_table                  ; table to use now in r7, all through following code
a399 16
;        Push    "R0-R5"
;        LDR     R0, [R7, #4]
;        MOV     R2, #0
;loop1
;        LDRB    R1, [R0, R2]
;        ADD     R2, R2, #1
;        LDRB    R3, [R0, R2]
;        ADD     R2, R2, #1
;        LDRB    R4, [R0, R2]
;        ADD     R2, R2, #1
;        LDRB    R5, [R0, R2]
;        Debug   gs,"Table =",R1,R3,R4,R5
;        ADD     R2, R2, #1
;        CMP     R2, #2000
;        BLT     loop1
;        Pull    "R0-R5"
d401 3
d405 1
a405 4
; Set up the output from readvduvars and readspritevars
        BL      readvduvars             ; r7 undisturbed
        BVS     jpegscaled_errorexit
; This stuff is copied from readspritevars
d409 1
a409 1
        MOV     R3,#32                  ; bits per pixel
d419 3
a421 3
; Now set up the registers to enter the regular PutSpriteScaled code
; r7 is already the translation table to use
        ADR     r0,pjs_end              ; get at original saved registers
d424 1
a424 1
        [ debuggs
d427 1
a427 4
        ]
        LDR     r0,pjs_sprite+spPalette+4         ; store pointer to JPEG data.
        Debug   gs,"r0 when lpaded+stored =",R0
        STR     r0, pjs_r0save
d430 3
a432 3
        Debug   gs,"sprite: R0,R1,R2 =",R0,R1,R2
        Debug   gs,"sprite: R3,R4,R5 =",R3,R4,R5
        Debug   gs,"sprite: R6,R7 =",R6,R7
d435 3
a437 4
        MOV     r1,r0
        MOV     r0,r2                   ; put y-coord in r4
        MOV     r2,r4                   ; put sie in r2
        MOV     r4,r0                   ; put y-coord in r4 part 2
d443 3
a445 3
        Debug   gs,"sprite: R0,R1,R2 =",R0,R1,R2
        Debug   gs,"sprite: R3,R4,R5 =",R3,R4,R5
        Debug   gs,"sprite: R6,R7 =",R6,R7
d447 3
a449 2
; ??? We come to here from exitbiggie, after either an error or plotting the sprite.
; Just drop the stack, and exit.
d455 3
a457 15
        CMP     r0, #0                  ; did C code return an error?
        BEQ     jpegscaled_exit_ok
        ADD     sp, sp, #4                  ;skip stored R0
        SUB     sp,sp,#pjs_table-pjs_start  ;stop sp ADD in 'jpegscaled_errorextit' moving stack too far.
        TST     r0, #2                  ; C code returned bad jpeg error
        BNE     jpegscaled_errorexit1
        TST     r0, #4                  ; C code bombed out with Fatal error
        BNE     jpegscaled_errorexit2
; Must have a "Run out of memory" error
        Debug   gs, "We think we'be run out of memory"
        ADRL    R0,ErrorBlock_JPEGNoRoom
        Debug   gs,"error block at r0 = ",R0
        BL      copy_error_one
        B       jpegscaled_errorexit
jpegscaled_exit_ok
d460 5
a464 2
        Pull    "R0"
        Debug   gs,"r0 when lpaded =",R0
d466 3
a468 5
        Debug   gs,"ok2. sp = ",r1
        ADD     sp,sp,#pjs_end-pjs_table          ; free that space
        MOV     r1, sp
        Debug   gs,"ok3. sp = ",r1
        Pull    "R1-R9,LR"
d473 7
d481 3
a483 3
jpegscaled_errorexit2
        Debug   gs, "We think we'be had a fatal error"
        ADRL    R0,ErrorBlock_JPEGFatal
d488 1
a488 1
        Debug   gs, "We think we'be got a duff JPEG"
d492 7
a498 3
        Debug   gs,"1. r0 is now = ",R0
;        MOV     r1, sp
        Debug   gs,"1. sp = ",r1
d500 4
a503 1
        MOV     r4, #pjs_end-pjs_table
d505 1
d507 1
d510 1
a511 2
;        MOV     r1, sp
;        Debug   gs,"4. sp = ",r1
d516 1
d519 1
d522 10
a531 12
;SWIJPEG_PlotFileScaled
;In:
;  r0 = pointer to control character terminated filename
;  r1 = x co-ordinate for plot
;  r2 = y co-ordinate for plot
;  r3 = scale factors or 0
;  r4 = Flags
;       b0 set: dither output when plotting truecolour in 8bpp or less.
;       b1 set: Full error-diffusion when plotting to 8bpp.
;
;Out:
;  all registers preserved.
d533 3
d537 1
a537 2

        BICS    LR, r4, #3              ;has someone set illegal flags?
d540 1
a540 1
        BLNE    copy_error_one          ; Always sets the V bit
d547 1
a547 1
;Find out file size.
d552 1
a552 1
        BEQ     JPEG_PlotFileScaled_NoFile
a553 12
;Create Dynamic memory area for JPEG
;       Push    "R0-R8"
;        MOV    r0, #0
;       MOV     r1, #-1
;       MOV     r2, r4                  ; size of JPEG buffer
;       MOV     r3, #-1
;       MOV     r4,
;       MOV     r5, #-1                 ; Maximum area same as minimum?
;       MOV     r6, #0
;       MOV     r7, #0
;       ADRL    r8, SpriteExtend_AreaName
;       SWI     XOS_DynamicArea
d555 1
a555 1
;Claim space for buffer from Module area.
d560 5
a564 4
        BVS     JPEG_PlotFileScaled_error; jump out and return error.
;Read file into buffer
        MOV     r6, r2                  ; Move r2 to r6 because r2 gets changed by OS_FILE
        MOV     r3, #0                  ; clear r3 so r2 used as load address
d567 3
a569 2
        SWI     XOS_File                ; file name still in r1
        BVS     JPEG_PlotFileScaled_error; jump out and return error.
d572 3
a574 3
        Pull    "R1-R3,R5"             ; pull original parameters into correct regs for JPEG_plotscaled.
        Push    "R6"                   ; store address of buffer so we can free it.
        ADR     LR, PlotScaled_return ; set up return from plot code.
d578 2
a579 1
PlotScaled_return
d581 1
a581 1
        MOVVS   r4, #1                  ;keep record of error after next SWI call.
d583 2
a584 2
JPEG_PlotFileScaled_exit1
        MOV     r5, r0                  ; temporarily store r0 and r2
d586 1
a586 1
        Pull    "R2"                    ; recover location of buffer from stack
d588 3
a590 3
        SWI     XOS_Module              ; Free module space
        BVS     JPEG_PlotFileScaled_error2; jump out and return error.
        MOV     r0, r5                  ; recover original r0 and r2
d592 4
a595 6
        CMP     r4, #1                  ; Did SWIJPEG_PlotScaled return an error?
        BNE     JPEG_PlotFileScaled_exit2
        SETV                            ; If so, make sure the V flag is set.
        B       JPEG_PlotFileScaled_error2
JPEG_PlotFileScaled_exit2
        Pull    "R0,R4-R6,PC"
d597 1
a597 1
JPEG_PlotFileScaled_NoFile
d606 1
a606 1
JPEG_PlotFileScaled_error
d609 2
a610 1
JPEG_PlotFileScaled_error2
d614 14
a627 12
;SWIJPEG_PlotTransformed
;  In:
;       R0 = Pointer to JPEG file loaded in Memory
;       R1 = flag word
;               b0 set: R2 is pointer to dest. coords, else pointer to matrix
;               b1 set: dither output when plotting truecolour in 8bpp or less.
;               b2 set: Full error-diffusion when plotting to 8bpp.
;       R2 = pointer to matrix (as for Draw module) or
;            pointer to destination co-ordinate block.
;       R3 = length of data in memory.
;  Out:
;       All registers preserved.
a629 1

d640 4
a643 3
        BNE     DestCoords
;Matrix
        LDR     r4, [r2, #4]            ;Rotation value
d646 2
a647 2
        BNE     JPEGTrans_ErrorExit
        LDR     r4, [r2, #8]            ;Rotation value
d650 2
a651 2
        BNE     JPEGTrans_ErrorExit
        LDR     r4, [r2]                ;X scale factor in Draw Transform units
d653 2
a654 2
        BMI     JPEGTrans_ErrorExit
        LDR     r4, [r2, #12]           ;Y scale factor in Draw Transform units
d656 3
a658 2
        BMI     JPEGTrans_ErrorExit
;Make up scale factor...
d670 1
a670 1
        LDR     r4, [r2]                ;X scale factor in Draw Transform units
d672 1
a672 1
        LDR     r4, [r2, #12]           ;Y scale factor in Draw Transform units
d678 2
a679 1
; JPEG pointer already in r0?        MOV     r0, r0
d682 1
d687 10
a696 10
; *************************************************
; ***  DivRem - Integer division and remainder  ***
; ***  rc := ra DIV rb; ra := ra REM rb         ***
; ***  rb preserved, rtemp corrupt              ***
; ***  DivRem   rc, ra, rb, rtemp               ***
; *************************************************

; We need to use a ratio of Output dpi to input dpi to convert
; the OS unit to OS unit scale factor from matrix to a pixel to
; pixel scale factor which we can send to PlotScaled.
d705 2
a706 1
;Set up registers for PutScaled Call
d715 1
a715 1
        ADRL    lr, Trans_PlotReturn
d718 2
a719 1
DestCoords
d722 3
a724 2
;Check output coord block is a rectangle
        LDR     r4, [r2]                ;X0
d726 1
a726 1
        LDR     r5, [r2, #24]           ;X3
d729 1
a729 1
        BNE     JPEGTrans_ErrorExit
d731 2
a732 2
        LDR     r4, [r2, #4]            ;Y0
        LDR     r5, [r2, #12]           ;Y1
d734 1
a734 1
        BNE     JPEGTrans_ErrorExit
d736 2
a737 2
        LDR     r4, [r2, #20]           ;Y2
        LDR     r5, [r2, #28]           ;Y3
d739 1
a739 1
        BNE     JPEGTrans_ErrorExit
d744 1
a744 1
        BNE     JPEGTrans_ErrorExit
d746 1
a746 1
        LDR     r4, [r2]                ;X0
d748 1
a748 1
        BGT     JPEGTrans_ErrorExit     ; can't allow flipping...
d753 1
a753 1
        BGT     JPEGTrans_ErrorExit     ; can't allow flipping...
d759 1
a759 1
;convert dest size from OS units to pixels
d772 1
a772 1
;find size of JPEG
d776 1
a776 1
        ADRL    lr, Trans_InfoReturn
d779 3
a781 2
;Make up scale factor...
Trans_InfoReturn
d788 1
a788 1
;Set up registers for PutScaled Call
d797 2
a798 2
        Debug   gs,"Calliing PutScaled.R0,R1,R2,R3,R4,R5=",R0,R1,R2,R3,R4,R5
        ADRL    lr, Trans_PlotReturn
d801 3
a803 2
Trans_PlotReturn
;what if error returned?
d805 2
a806 2
        BVS     JPEGTrans_ErrorExit1
;recover stack space
d811 1
a811 1
JPEGTrans_ErrorExit
d815 2
a816 1
JPEGTrans_ErrorExit1
a818 13
;       MOV     pc, lr

;SWIJPEG_PlotFileTransformed
;  In:
;       R0 = Pointer to control charater terminated filename for JPEG image
;       R1 = flag word
;               b0 set: R2 is pointer to dest. coords, else pointer to matrix
;               b1 set: dither output when plotting truecolour in 8bpp or less.
;               b2 set: Full error-diffusion when plotting to 8bpp.
;       R2 = pointer to matrix (as for Draw module) or
;            pointer to destination co-ordinate block.
;  Out:
;       All registers preserved.
d820 13
a834 1

d837 1
a837 1
        BICS    r3, r1, #7              ;has someone set illegal flags?
d841 1
a841 1
        BLNE    copy_error_one          ; Always sets the V bit
d846 1
a846 1
;Find out file size.
d851 1
a851 1
        BEQ     JPEG_PlotFileTransformed_NoFile
d854 1
a854 1
;Claim space for buffer from Module area.
d859 5
a863 4
        BVS     JPEG_PlotFileTransformed_error; jump out and return error.
;Read file into buffer
        MOV     r6, r2                  ; Move r2 to r6 because r2 gets changed by OS_FILE
        MOV     r3, #0                  ; clear r3 so r2 used as load address
d866 2
a867 2
        SWI     XOS_File                ; file name still in r1
        BVS     JPEG_PlotFileTransformed_error; jump out and return error.
d871 3
a873 3
        Pull    "R1-R2,R4"             ; pull original parameters into correct regs for JPEG_plotTransformed.
        Push    "R6"                   ; store address of buffer so we can free it.
        ADR     LR, PlotTransformed_return ; set up return from plot code.
d877 2
a878 1
PlotTransformed_return
d882 2
a883 1
JPEG_PlotFileTransformed_exit1
d889 1
a889 1
        BVS     JPEG_PlotFileTransformed_error2; jump out and return error.
d893 1
a893 1
        BNE     JPEG_PlotFileTransformed_exit2
d895 3
a897 2
        B       JPEG_PlotFileTransformed_error2
JPEG_PlotFileTransformed_exit2
d900 1
a900 1
JPEG_PlotFileTransformed_NoFile
d909 1
a909 1
JPEG_PlotFileTransformed_error
d912 1
a912 1
JPEG_PlotFileTransformed_error2
d916 10
a925 8
;SWIJPEG_PDriverIntercept
;  In:
;       R0 = flags
;               b0 = intercept state; 0 = off, 1 = on
;               b1 = set: plot all JPEGs using translation table
;               b2-31 reserved (set to 0)
;  Out:
;       All registers preserved.
a927 1

d937 70
a1006 1
        MakeSpriteErrorBlock BadJPEGPlot,,BadJPEGPlot
@


4.8
log
@Retire old compiler.
2000 lines of unloved code from 1993 deleted, binary still the same afterwards, so should be same as 1.25.

Version 1.26. Tagged as 'SprExtend-1_26'
@
text
@d15 1
a15 1
; Sources.SWIs
@


4.7
log
@Fix two bugs causing aborts on corner cases.
1 pixel wide JPEGs:
The diffuse dithering code considers all lines as 1-N-1 where N can be zero and the first and last pixel are dealt with specially because there's no data to scatter beyond the edge.
With a 1 pixel wide JPEG the dithering code ended up with a -ve number in the X counter and wandered off the end of memory. Fix just moves a SUB up a few lines and turns it into a SUBS so that the 1 wide case becomes 0-N-1 with N=0.
1 pixel high sprites:
With output switched to a 1 pixel high sprite an abort would quickly follow because the read of mode variables had a backdoor check to workaround a bug in RISC OS 2.00 which returned a duff value for YWindLimit in MODE 22. As the definition of MODE 22 got changed to 768x288 in RISC OS 3.xx (and the YWindLimit bug fixed) this code now just falsely reported a 1 pixel high sprite as being 1024 high and the blitter splattered all over memory it shouldn't.
Result:
Loss of RISC OS 2.00 compatibility, but can now load JPEGs of Xx1 or 1xY and even 1x1.

Version 1.25. Tagged as 'SprExtend-1_25'
@
text
@a18 1
        [ ccompiler
a84 1
        ]
a134 1
        [ ccompiler
a253 1
        ]
a275 1
        [ ccompiler
a323 1
        ]
d341 1
a341 10
;On Entry: what original code expected...
;  R0 = 66
;  R1 = pointer to JPEG file image
;  R2 = length of JPEG file image
;  R3 = x coordinate at which to plot
;  R4 = y coordinate at which to plot
;  R5 = plot action
;  R6 = scale factors: 0 -> no scaling
;  R7 = pixel translation table
        [ ccompiler
a600 1
        ]
a616 1
        [ ccompiler
a702 1
        ]
a914 1
        [ ccompiler
a990 1
        ]
@


4.6
log
@Clean up pass.
Trim 200+ lines of changes dating back to 1987, combine with non duplicates in the 'BlackLog'.
Use 'offsetof' macro in genjhdr to avoid warnings about uninitialised variables, rename from makejhdr so all the utils are clearly demarked.
Add throwback to MkCFSI-j.
Replace reason codes passed to SWIs with textual equivalents from the respective header files.
Speed up SWI despatch a bit by making the first few debug instructions depend on 'debuggs'.
Qualify all of the debug switches with the global 'debug' one.
Eliminate single use of 'pullx' macro.
Make do_branch() take an unsigned opcode so 50% of the branches don't result in implied cast warnings.
Added an UNUSED() macro to reduce a few of the legitimate warnings (the remainder are either in the original JPEG code or ones that it is worth checking the logic of.
Unixify one last filename.

Version 1.24. Tagged as 'SprExtend-1_24'
@
text
@d522 2
a523 1
;        MOV     r0,lr
d525 1
d529 1
a530 2
;        MOV     r5,sp
        Debug   gs,"sp = ",R5
@


4.5
log
@Collapse old switches.
Removed braces selecting code from 0.47 0.50 and 0.55, this is over 80
versions ago and just confusing.
Binary the same, not tagged.
@
text
@d15 1
a15 1
; Sources. SWIS
d23 1
d28 1
a60 1
;        SWI     &a015d                  ;PDriver_JPEGSWI
d208 1
a208 2
        CMP     r1, #0                  ; if size is zero
        MOVEQ   r1, #0                  ; act as if we had no JPEG workspace
d469 1
a469 1
        MOV     r0,#6:SHL:27
d645 1
a645 1
        MOV     r0, #23
d647 1
a647 1
        CMP     r0, #0
d664 1
a664 1
        MOV     r0, #6                   ; prepare for OS_Module call
d672 1
a672 1
        MOV     r0, #16                 ; load file Reason code for OS_File
d692 1
a692 1
        MOV     r0, #7
d766 1
a766 1
        MOV     r1, #4
d769 1
a769 1
        MOV     r1, #5
d862 1
a862 1
        MOV     r1, #4
d865 1
a865 1
        MOV     r1, #5
d946 1
a946 1
        MOV     r0, #23
d948 1
a948 1
        CMP     r0, #0
d953 1
a953 1
        MOV     r0, #6                   ; prepare for OS_Module call
d961 1
a961 1
        MOV     r0, #16                 ; load file Reason code for OS_File
d982 1
a982 1
        MOV     r0, #7
@


4.4
log
@Performance improvement and code tidy-up.

Removed local definition of XOS_CLI and XColourTrans_SelectTable, replaced
with header file.

Delete swiv2_old (moved to _old directory)

Changed to use {TRUE} and {FALSE} built in objasm variables.

Label dividebyzero fall through had code in the way for debug = {TRUE}.

Trimmed some dead code and definitions.

Stopped thrashing OS_CLI every time a JPEG plot is required to check
ColourTrans version, this is now done once at startup and a flag kept
instead.

Author: Rob Sprowson

Version 1.19. Tagged as 'SprExtend-1_19'
@
text
@d35 1
a35 1
        CMPNE   r11, #3                          ; JPEG_plotFileScaled ?
@


4.3
log
@32-bit compatible. Tagged as SprExtend-1_06
@
text
@d68 2
a69 2
        B   	SWIJPEG_PlotFileTransformed
	B	SWIJPEG_PDriverIntercept
d100 2
a101 2
;	DCB	"SpriteExtend JPEG",0
;	ALIGN
d207 1
a207 1
        CMP     r1, #0			; if size is zero
a331 1

d422 5
a426 7
	MOV     r0,#1
	MOV	r3, #90				; dpi;
	ORR	r0, r0, r3, LSL #1		;Horizontal dpi
	ORR	r0, r0, r3, LSL #14		;Vertical dpi
	MOV	r3, #9				;Sprite Type
	ORR	r0, r0, r3, LSL #27
;        MOV     r0,#20                             ; pretend to be mode 20
d451 2
a452 2
	SUB	r0, r0, #1
        AND	r0, r0, #31
d464 5
a468 4
        ADRL    r0,pjs_checkColourTrans
        SWI     XOS_CLI                       ; *RMEnsure ColourTrans 1.25 Error no good
        MOVVS   r7,#0                         ; error return - not new ColourTrans
        BVS     %FT01
d562 1
a562 1
	BNE	jpegscaled_errorexit2
d568 1
a568 1
	B	jpegscaled_errorexit
d590 1
a590 1
	B	jpegscaled_errorexit
a614 4

pjs_checkColourTrans
        DCB     "RMEnsure ColourTrans 1.25 Error no good", 0 ; any error will do
        ALIGN
d641 1
a641 1
	Push    "R1-R4"
d644 3
a646 3
	MOV	r1, r0
	MOV	r0, #23
	SWI	XOS_File
d649 1
a649 1
	Debug   gs,"File size =", r4
d651 11
a661 11
;	Push	"R0-R8"
;        MOV	r0, #0
;	MOV	r1, #-1
;	MOV	r2, r4			; size of JPEG buffer
;	MOV	r3, #-1
;	MOV	r4,
;	MOV	r5, #-1			; Maximum area same as minimum?
;	MOV	r6, #0
;	MOV	r7, #0
;	ADRL	r8, SpriteExtend_AreaName
;	SWI	XOS_DynamicArea
d671 1
a671 1
	MOV     r3, #0		  	; clear r3 so r2 used as load address
d673 1
a673 1
	Debug   gs,"Loading file: r0,r1,r2,r3 =", R0,R1,R2,R3
d676 3
a678 3
	Debug   gs,"Load address = ",R6
	MOV	r0, r6
	Pull    "R1-R3,R5"             ; pull original parameters into correct regs for JPEG_plotscaled.
d682 1
a682 1
	Debug   gs,"Calling PlotScaled: R0,R1,R2,R3,R4,R5=",R0,R1,R2,R3,R4,R5
d685 1
a685 1
	Debug   gs,"Return From PlotScaled: R0,R1,R2,R3=",R0,R1,R2,R3
d711 1
a711 1
	Pull	"R4-R6,PC"
d717 2
a718 2
        ADD	sp, sp, #4
	Pull	"R4-R6,PC"
d723 7
a729 7
;	R0 = Pointer to JPEG file loaded in Memory
;	R1 = flag word
;		b0 set: R2 is pointer to dest. coords, else pointer to matrix
;		b1 set: dither output when plotting truecolour in 8bpp or less.
;		b2 set: Full error-diffusion when plotting to 8bpp.
;	R2 = pointer to matrix (as for Draw module) or
;	     pointer to destination co-ordinate block.
d732 1
a732 1
;	All registers preserved.
d736 2
a737 2
	Pull    "LR"
        Push	"R0-R11,LR"
d745 2
a746 2
	TST     r1, #1
	BNE     DestCoords
d748 2
a749 2
	LDR	r4, [r2, #4]		;Rotation value
	CMP	r4, #0
d751 3
a753 3
	BNE	JPEGTrans_ErrorExit
	LDR	r4, [r2, #8]		;Rotation value
	CMP	r4, #0
d755 7
a761 7
	BNE	JPEGTrans_ErrorExit
	LDR	r4, [r2]		;X scale factor in Draw Transform units
	CMP     r4, #0
	BMI     JPEGTrans_ErrorExit
	LDR	r4, [r2, #12]		;Y scale factor in Draw Transform units
	CMP     r4, #0
	BMI     JPEGTrans_ErrorExit
d763 15
a777 15
	Debug	gs,"scale factors are...",R7,R8,R2,R3
	Push	"R0-R2"
	MOV	r0, #-1
	MOV	r1, #4
	SWI	XOS_ReadModeVariable	; Get X Eig in R2
	MOV	r7, r2		        ; Put into r7
	MOV	r1, #5
	SWI	XOS_ReadModeVariable	; Get Y Eig in R2
	MOV	r8, r2		        ; put into r7
	Pull	"R0-R2"
	SUB	sp, sp, #16		; make room for scale factors
	LDR	r4, [r2]		;X scale factor in Draw Transform units
	STR	r4, [sp]
	LDR	r4, [r2, #12]		;Y scale factor in Draw Transform units
	STR	r4, [sp,#4]
d799 2
a800 2
	MOV	r4, r9, LSL #16		; X input dpi * 2^16 (because of
					; transform coordinates)
d802 3
a804 3
	STR	r5, [sp,#8]
	MOV     r4, r10, LSL #16	; X input dpi * 2^16 (because of
					; transform coordinates)
d806 1
a806 1
	STR	r5, [sp,#12]
d808 4
a811 4
	MOV	r4, r3
	MOV	r3, sp                  ; Pointer to Scale factors
	MOV     r5, r1, LSR #1
	LDR	r1, [r2, #16]		; X-coordinate in 1/256th OSunit
d813 1
a813 1
	LDR	r2, [r2, #20]		; Y-coordinate in 1/256th OSunit
d815 4
a818 4
	Debug	gs,"Calliing PutScaled.R0,R1,R2,R3,R4,R5=",R0,R1,R2,R3,R4,R5
	ADRL	lr, Trans_PlotReturn
	Push	"LR"
	BL 	SWIJPEG_PlotScaled
d820 2
a821 2
	Debug	gs,"Doing a DestCoords Plot Transformed"
	MOV	r11, r1
d823 35
a857 35
	LDR     r4, [r2]		;X0
	Debug	gs,"load 1 ",r4
	LDR	r5, [r2, #24]		;X3
	Debug	gs,"load 2 ",r5
	CMP	r4, r5
        BNE	JPEGTrans_ErrorExit
	Debug	gs,"Check 1 passed"
	LDR     r4, [r2, #4]		;Y0
	LDR     r5, [r2, #12]		;Y1
	CMP	r4, r5
        BNE	JPEGTrans_ErrorExit
	Debug	gs,"Check 2 passed"
	LDR     r4, [r2, #20]		;Y2
	LDR     r5, [r2, #28]		;Y3
	CMP	r4, r5
        BNE	JPEGTrans_ErrorExit
	Debug	gs,"Check 3 passed"
	LDR     r4, [r2, #8]		;X1
	LDR     r5, [r2, #16]		;X2
	CMP	r4, r5
        BNE	JPEGTrans_ErrorExit
	Debug	gs,"Check 4 passed"
	LDR     r4, [r2]		;X0
	CMP	r4,r5			; which one is biggest?
	BGT	JPEGTrans_ErrorExit	; can't allow flipping...
	Debug	gs,"Check 5 passed"
	LDR     r6, [r2, #4]		; Y0
	LDR     r7, [r2, #28]		; Y3
	CMP	r7,r6			; which one is biggest?
	BGT	JPEGTrans_ErrorExit	; can't allow flipping...
	Debug	gs,"Check 6 passed"
	SUB	r4, r5, r4		; dest X-size in r4 in 1/256th OS units
	SUB	r5, r6, r7		; dest Y-size in r5 in 1/256th OS units
	MOV	r4, r4, LSR #8		; dest X-size in r4 in OS units
	MOV	r5, r5, LSR #8		; dest Y-size in r5 in OS units
d859 12
a870 12
	Debug	gs,"Plot dosen't include any rotation or flipping"
	Push	"R0-R2"
	MOV	r0, #-1
	MOV	r1, #4
	SWI	XOS_ReadModeVariable	; Get X Eig in R2
	MOV	r7, r4, LSR r2		; Dest X-Size in pixels
	MOV	r1, #5
	SWI	XOS_ReadModeVariable	; Get Y Eig in R2
	MOV	r8, r5, LSR r2		; Dest Y-Size in pixels
	Pull	"R0-R2"
	MOV     r9, r2			; temp store of pointer to coord block;
	MOV	r10, r3			; temp store of length of data;
d872 6
a877 6
	MOV	r1, r0			; pointer to JPEG
	MOV	r0, #1
	MOV	r2, r3			; length.
	ADRL	lr, Trans_InfoReturn
	Push	"LR"
	B	SWIJPEG_Info
d880 6
a885 6
	Debug	gs,"scale factors are...",R7,R8,R2,R3
	SUB	sp, sp, #16		; make room for scale factors
	STR	r7, [sp]
	STR	r8, [sp,#4]
	STR	r2, [sp,#8]
	STR	r3, [sp,#12]
d887 3
a889 3
	MOV	r3, sp                  ; Pointer to Scale factors
	MOV 	r0, r1			; Pointer to JPEG
	LDR	r1, [r9]		; X-coordinate in 1/256th OSunit
d891 1
a891 1
	LDR	r2, [r9,#28]		; Y-coordinate in 1/256th OSunit
d893 6
a898 6
	MOV	r4, r10
	MOV     r5, r11, LSR #1
	Debug	gs,"Calliing PutScaled.R0,R1,R2,R3,R4,R5=",R0,R1,R2,R3,R4,R5
	ADRL	lr, Trans_PlotReturn
	Push	"LR"
	BL 	SWIJPEG_PlotScaled
d901 2
a902 2
	ADDVS	sp, sp, #16
	BVS	JPEGTrans_ErrorExit1
d904 3
a906 3
	Debug	gs,"Returned from putscaled"
	ADD	sp, sp, #16
	Pull	"R0-R11,PC"
d909 1
a909 1
        ADRL  	R0,ErrorBlock_BadJPEGPlot
d913 3
a915 3
	ADD     sp, sp, #4                      ;Skip over r0
	Pull	"R1-R11,PC"
;	MOV     pc, lr
d919 7
a925 7
;	R0 = Pointer to control charater terminated filename for JPEG image
;	R1 = flag word
;		b0 set: R2 is pointer to dest. coords, else pointer to matrix
;		b1 set: dither output when plotting truecolour in 8bpp or less.
;		b2 set: Full error-diffusion when plotting to 8bpp.
;	R2 = pointer to matrix (as for Draw module) or
;	     pointer to destination co-ordinate block.
d927 1
a927 1
;	All registers preserved.
d942 1
a942 1
	Push    "R1-R3"
d945 3
a947 3
	MOV	r1, r0
	MOV	r0, #23
	SWI	XOS_File
d950 1
a950 1
	Debug   gs,"File size =", r4
d960 1
a960 1
	MOV     r3, #0		  	; clear r3 so r2 used as load address
d962 1
a962 1
	Debug   gs,"Loading file: r0,r1,r2,r3 =", R0,R1,R2,R3
d965 1
a965 1
	Debug   gs,"Load address = ",R6
d967 2
a968 2
  	MOV	r0, r6
	Pull    "R1-R2,R4"             ; pull original parameters into correct regs for JPEG_plotTransformed.
d972 1
a972 1
	Debug   gs,"Calling PlotTransformed: R0,R1,R2,R3,R4,R5=",R0,R1,R2,R3,R4,R5
d975 1
a975 1
	Debug   gs,"Return From PlotTransformed: R0,R1,R2,R3=",R0,R1,R2,R3
d1001 1
a1001 1
	Pull	"R3-R6,PC"
d1007 2
a1008 2
        ADD	sp, sp, #4
	Pull	"R3-R6,PC"
d1013 4
a1016 4
;	R0 = flags
;	   	b0 = intercept state; 0 = off, 1 = on
;	   	b1 = set: plot all JPEGs using translation table
;		b2-31 reserved (set to 0)
d1018 1
a1018 1
;	All registers preserved.
d1023 7
a1029 7
      	Push	"R1"
	LDR	r1, save_PdriverIntercept
	AND	r0, r0, #3
	STR	r0, save_PdriverIntercept
	Debug   gs, "Setting the Pdriver intercept flag to ...",R0
	MOV	r0, r1
	Pull	"R1,PC"
@


4.2
log
@Spinner and Ursula branches merged.
@
text
@d28 1
a28 2
        MVN     R14,#I_bit
        TSTP    R14,PC                           ; re-enable interrupts
@


4.1
log
@Initial revision
@
text
@d135 1
a135 1
        
d147 1
a147 1
        
d210 1
a210 1
        LDRNE   r1, jpeg_info_ptr       
a413 4
        MOV     r3,#&d800
        ORR     r3,r3,#&20
        LDR     r0,[r3]
        Debug   gs,"Dodgy word = ", r0
d645 1
a645 1
        
d751 1
a751 1
        
d948 1
a948 1
        
@


4.1.4.1
log
@Fixed problem where SpriteExtend would read a word from &D820 for no reason
@
text
@d135 1
a135 1

d147 1
a147 1

d210 1
a210 1
        LDRNE   r1, jpeg_info_ptr
d414 4
d649 1
a649 1

d755 1
a755 1

d952 1
a952 1

@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

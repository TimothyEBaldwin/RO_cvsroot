head	4.6;
access;
symbols
	SprExtend-1_83:4.6
	SprExtend-1_82:4.6
	SprExtend-1_81:4.6
	SprExtend-1_80:4.6
	SprExtend-1_79:4.6
	SprExtend-1_78:4.6
	SprExtend-1_77:4.6
	SprExtend-1_76:4.6
	SprExtend-1_75:4.6
	SprExtend-1_74:4.6
	SprExtend-1_73:4.6
	SprExtend-1_72:4.6
	SprExtend-1_71-nocfsi:4.6
	SprExtend-1_71:4.6
	SprExtend-1_70-tracef:4.6
	SprExtend-1_70-headers:4.6
	SprExtend-1_70:4.6
	SprExtend-1_69:4.6
	SprExtend-1_68:4.6
	SprExtend-1_67:4.6
	SprExtend-1_66:4.6
	SprExtend-1_65:4.6
	SprExtend-1_64:4.6
	SprExtend-1_63:4.6
	SprExtend-1_62:4.6
	SprExtend-1_61:4.6
	SprExtend-1_60:4.6
	SprExtend-1_59:4.6
	SprExtend-1_58:4.6
	SprExtend-1_57:4.6
	SprExtend-1_56:4.6
	SprExtend-1_55:4.6
	SprExtend-1_54:4.6
	SprExtend-1_53:4.6
	SprExtend-1_52:4.6
	SprExtend-1_51:4.6
	SprExtend-1_50:4.6
	SprExtend-1_38-1_35_2_16:4.6
	SprExtend-1_49:4.6
	SprExtend-1_48:4.6
	SprExtend-1_47:4.6
	SprExtend-1_38-1_35_2_15:4.6
	SprExtend-1_46:4.6
	SprExtend-1_45:4.6
	SprExtend-1_44:4.6
	SprExtend-1_43:4.6
	SprExtend-1_42:4.6
	SprExtend-1_41:4.6
	SprExtend-1_38-1_35_2_14:4.6
	SprExtend-1_40:4.6
	SprExtend-1_38-1_35_2_13:4.6
	SprExtend-1_38-1_35_2_12:4.6
	SprExtend-1_38-1_35_2_11:4.6
	SprExtend-1_38-1_35_2_10:4.6
	SprExtend-1_38-1_35_2_9:4.6
	SprExtend-1_38-1_35_2_8:4.6
	SprExtend-1_39:4.6
	SprExtend-1_38-1_35_2_7:4.6
	SprExtend-1_38-1_35_2_6:4.6
	SprExtend-1_38-1_35_2_5:4.6
	SprExtend-1_38-1_35_2_4:4.6
	SprExtend-1_38-1_35_2_3:4.6
	SprExtend-1_38-1_35_2_2:4.6
	SprExtend-1_38-1_35_2_1:4.6
	MigrateIJG8b:4.6.0.2
	SprExtend-1_38:4.6
	SprExtend-1_37:4.6
	SprExtend-1_36:4.6
	SprExtend-1_35:4.6
	SprExtend-1_34:4.6
	SprExtend-1_33:4.6
	SprExtend-1_32:4.6
	SprExtend-1_31:4.6
	SprExtend-1_30:4.6
	SprExtend-1_29:4.6
	SprExtend-1_28:4.6
	SprExtend-1_27:4.5
	SprExtend-1_26:4.4
	SprExtend-1_25:4.4
	SprExtend-1_24:4.4
	SprExtend-1_23:4.4
	SprExtend-1_22:4.4
	SprExtend-1_21:4.4
	SprExtend-1_20:4.4
	SprExtend-1_19:4.4
	SprExtend-1_18:4.4
	SprExtend-1_17:4.4
	RO_5_07:4.3
	SprExtend-1_16:4.3
	SprExtend-1_15:4.3
	SprExtend-1_14:4.3
	SprExtend-1_13:4.3
	SprExtend-1_12:4.3
	SprExtend-1_11:4.3
	SprExtend-1_10:4.3
	SprExtend-1_09:4.3
	SprExtend-1_08:4.3
	dellis_autobuild_BaseSW:4.3
	SprExtend-1_07:4.3
	SprExtend-1_06:4.3
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.3
	SprExtend-1_05:4.2
	Ursula_merge:4.2
	nturton_SprExtend-1_04:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2010.09.25.12.19.17;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2010.09.19.09.11.14;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2004.12.07.15.46.55;	author jbyrne;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.12.12.59.08;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.17.51.02;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.45.19;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.45.19;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.43.03;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.58.37;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.21.10;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Remove postprocessing step of C code.
Since 2001 this module has been using objasm, but still using the C compiler to output (via -S) assembly code which is then passed through 'sed' and included via GET into the assembler code.
Changed to compile the C code into object files, and use the linker to patch up the unresolved references - this has required some reordering of the C code to make sure static functions now appear in the object file, and some reordering of the header files to ensure both the module and the CFSI version still compile without conflicts.
Minor fix to 'swiv2', the label was in the wrong place for _swi() though it's not used in this module so didn't affect the _swix() case.
Makefile cut down a bit. Unixify some path names.
Test code moved to 'Test/c' directory.
Tested in both debug and non debug cases via softloaded module. Oddly, it's 4 bytes longer than the previous version.

Version 1.28. Tagged as 'SprExtend-1_28'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        MACRO
$name   StoreSWIXFlags
  [ {CONFIG}=26
$name   STR     pc, [sp, #4*4]!
  |
$name   MRS     lr, CPSR
        STR     lr, [sp, #4*4]!
  ]
        MEND

        AREA    |C$$code|, CODE, READONLY

        EXPORT  |_swix|
        EXPORT  |_swi|

  [ StrongARM
    ; tedious static _swi(x) entry handling, to avoid generating dynamic code, and
    ; requiring an expensive XOS_SynchroniseCodeAreas

|_swix|
        ORR     r0, r0, #&20000
|_swi|
        STMFD   sp!, {r2, r3}             ; put 1st two variadic args on stack
        STMDB   sp!, {r1, r4-r9, lr}      ; save stuff

        SUB     sp, sp, #5*4              ; so we can use tail code common with dynamic version (and room for regs stash)

        ADD     r14, sp, #(5+8)*4         ; r14 -> input args
        MOV     r12, r0                   ; target SWI code
        STR     fp, [sp]                  ; stash fp

        MOV     r11, r1
        TST     r11, #&001
        LDRNE   r0, [r14], #4
        TST     r11, #&002
        LDRNE   r1, [r14], #4
        TST     r11, #&004
        LDRNE   r2, [r14], #4
        TST     r11, #&008
        LDRNE   r3, [r14], #4

        TST     r11, #&FF0                ; check for use of input regs. 4 to 9, or of block param
        STREQ   r14, [sp, #4]             ; stash args ptr
        BEQ     swix_get_on_with_it
        
        TST     r11, #&010
        LDRNE   r4, [r14], #4
        TST     r11, #&020
        LDRNE   r5, [r14], #4
        TST     r11, #&040
        LDRNE   r6, [r14], #4
        TST     r11, #&080
        LDRNE   r7, [r14], #4
        TST     r11, #&100
        LDRNE   r8, [r14], #4
        TST     r11, #&200
        LDRNE   r9, [r14], #4

        STR     r14, [sp, #4]             ; stash args ptr
        TST     r11, #&800                ; use of block parameter input?
        BLNE    swi_blockhead             ; if so, handle it and... (BL<cond> 32-bit OK)
        TST     r11, #&800                ; use of block parameter input? (r11 preserved by the call, flags not)
        LDRNE   r14, [sp, #4]             ; ...restore arg ptr

swix_get_on_with_it
        TST     r12, #&20000              ; if non X SWI, could be a return value register
        BEQ     swi_beyond_a_joke

        LDR     fp, [sp, #0]              ; get fp and lr saying something useful in case
        LDR     lr, [sp, #48]             ; SWI aborts or throws an error.
        SWI     XOS_CallASWIR12
        LDR     ip, [sp, #4]              ; restore (ip -> args)
        B       SWIXReturn

swi_beyond_a_joke
;so we have to deal with a return value then
        LDR     fp, [sp, #0]              ; get fp and lr saying something useful in case
        LDR     lr, [sp, #48]             ; SWI aborts or throws an error.
        SWI     XOS_CallASWIR12
        LDR     ip, [sp, #4]              ; restore (ip -> args)
        StoreSWIXFlags
        LDR     lr, [sp, #1*4]
;right, if R0 is also required as an output param, we'd better sort that first
        TST     lr,#&80000000
        BEQ     swi_beyond_a_joke_R0safe
        LDRNE   lr, [r12], #4
        STRNE   r0, [lr]
        LDR     lr, [sp, #1*4]
        BIC     lr,lr,#&80000000       ;done it now
        STR     lr, [sp, #1*4]
swi_beyond_a_joke_R0safe
        ANDS    lr, lr, #&000F0000     ;select return value register
        BEQ     SWIReturn2
        CMP     lr, #&00010000
        MOVEQ   r0, r1
        CMP     lr, #&00020000
        MOVEQ   r0, r2
        CMP     lr, #&00030000
        MOVEQ   r0, r3
        CMP     lr, #&00040000
        MOVEQ   r0, r4
        CMP     lr, #&00050000
        MOVEQ   r0, r5
        CMP     lr, #&00060000
        MOVEQ   r0, r6
        CMP     lr, #&00070000
        MOVEQ   r0, r7
        CMP     lr, #&00080000
        MOVEQ   r0, r8
        CMP     lr, #&00090000
        MOVEQ   r0, r9
        CMP     lr, #&000F0000         ;for goodness sake!
        LDREQ   r0, [sp]
        B       SWIReturn2

swi_blockhead
        STMFD   sp!, {r10-r12, lr}
        LDR     r12, [sp, #(4+1)*4]    ;pick up args ptr from stack
;r12 currently -> first output arg, so crank it past them
        MOVS    r11, r11, ASL #1
        ADDCS   r12, r12, #4           ;tests R0 output bit
        ADDMI   r12, r12, #4           ;tests R1 output bit
        MOV     r10, #5                ;5 more reg bit pairs to go (includes PC and one dummy)
swi_blockhead1
        MOVS    r11, r11, ASL #2
        ADDCS   r12, r12, #4
        ADDMI   r12, r12, #4
        SUBS    r10, r10, #1
        BNE     swi_blockhead1
;now r12 -> parameter block args on stack
        LDR     r11, [sp,#4]
        ANDS    r11, r11, #&f000       ;select reg for parameter block pointer
        MOVEQ   r0, r12
        CMP     r11, #&1000
        MOVEQ   r1, r12
        CMP     r11, #&2000
        MOVEQ   r2, r12
        CMP     r11, #&3000
        MOVEQ   r3, r12
        CMP     r11, #&4000
        MOVEQ   r4, r12
        CMP     r11, #&5000
        MOVEQ   r5, r12
        CMP     r11, #&6000
        MOVEQ   r6, r12
        CMP     r11, #&7000
        MOVEQ   r7, r12
        CMP     r11, #&8000
        MOVEQ   r8, r12
        CMP     r11, #&9000
        MOVEQ   r9, r12

        LDMFD   sp!, {r10-r12, pc} ; no need to restore flags

  ] ; StrongARM


  [ :LNOT: StrongARM

|_swi|

; Construct a stack frame that looks something like this:
;       LDMIA   r12!, {r0..rn}      ; Or NOP if no input regs
;       ADD     Rb, R12, #Nout * 4  ; Or NOP if no parameter block
;       SWI     xxxxxx
;       MOV     R0, Rn              ; Use ADD because Rn is correct bitfield
;       B       SWIReturn
;       saved r4-r11,lr
;       saved r1
;       saved input values (r2...rn)

        STMFD   sp!, {r2-r3}            ; Save r1 and put 1st two variadic args on stack
        STMDB   sp!, {r1, r4-r9, lr}
        ADR     r6, SWIReturn-4
        B       swix0
|_swix|
        ORR     r0, r0, #&20000
        STMDB   sp!, {r2-r3}
        STMDB   sp!, {r1, r4-r9, lr}
        ADR     r6, SWIXReturn-4
swix0
        ORR     r3, r0, #&ef000000      ; Construct SWI instruction
        MOV     r0, r1, LSL #22         ; Construct LDMIA R12!, {regs} instruction
        MOVS    r0, r0, LSR #22         ; {regs} = {} (IE no input regs) we must not
        ORRNE   r0, r0, #&e8000000      ; use an LDMIA R12!, {} instruction as this is an
        ORRNE   r0, r0, #&00bc0000      ; invalid instruction, we use a suitable NOP instead.
        MOV     r5, r1, LSR #16
        AND     r5, r5, #&f
        ORR     r5, r5, #&e1000000
        ORR     r5, r5, #&a00000
        ANDS    r2, r1, #&800
        BLNE    BuildBlockInst          ; BL<cond> 32-bit OK
        SUB     r6, r6, sp
        MOV     r6, r6, LSR #2
        BIC     r6, r6, #&ff000000
        ADD     r6, r6, #&ea000000
        STMDB   sp!, {r0,r2,r3,r5,r6}
        ADD     r12, sp, #(5+8)*4       ; Point R12 at input regs on stack.
        MOV     pc, sp                  ; Call routine on stack

SWIReturn
        StoreSWIXFlags
  ] ; not StrongARM
SWIReturn2
        LDR     lr, [sp, #1*4]
        MOVS    lr, lr, ASL #1          ; Shift out setting C if R0 to be written, N
        LDRCS   lr, [r12], #4           ; if R1 to be written.
        STRCS   r0, [lr]
        LDRMI   lr, [r12], #4
        STRMI   r1, [lr]
        LDR     lr, [sp, #1*4]
        B       ReturnTail
SWIXReturn
        StoreSWIXFlags                  ; increments sp by 16
        LDR     lr, [sp, #1*4]
        BVS     VSetReturn
        MOVS    lr, lr, ASL #1          ; Shift out setting C if R0 to be written, N
        LDRCS   lr, [r12], #4           ; if R1 to be written.
        STRCS   r0, [lr]
        LDRMI   lr, [r12], #4
        STRMI   r1, [lr]
        LDR     lr, [sp, #1*4]
        TST     lr, #&f0000
        MOVEQ   r0, #0
ReturnTail
        MOVS    lr, lr, ASL #3          ; Shift 2 bits each time for the next 2 regs
        LDRCS   r1, [r12], #4
        STRCS   r2, [r1]
        LDRMI   r1, [r12], #4
        STRMI   r3, [r1]
        AND     lr, lr, #&ff000000
        MOVS    lr, lr, ASL #2
        LDRCS   r1, [r12], #4
        STRCS   r4, [r1]
        BEQ     VSetReturn              ; Typically saves 16S - (3S + 1N)
        LDRMI   r1, [r12], #4
        STRMI   r5, [r1]
        MOVS    lr, lr, ASL #2
        LDRCS   r1, [r12], #4
        STRCS   r6, [r1]
        LDRMI   r1, [r12], #4
        STRMI   r7, [r1]
        MOVS    lr, lr, ASL #2
        LDRCS   r1, [r12], #4
        STRCS   r8, [r1]
        LDRMI   r1, [r12], #4
        STRMI   r9, [r1]
        MOVS    lr, lr, ASL #2
        LDRCS   r9, [sp]
        LDRCS   r1, [r12], #4
        STRCS   r9, [r1]
VSetReturn
        ADD     sp, sp, #2*4
        LDMIA   sp!, {r4-r9,lr}
        ADD     sp, sp, #2 * 4
        MOV     pc, lr

  [ :LNOT: StrongARM
BuildBlockInst
        MOV     r4, #6
        AND     r2, r1, #&f000
        ORR     r2, r2, #&e2000000
        ORR     r2, r2, #&008c0000
BuildBlockInst1
        MOVS    r1, r1, ASL #2
        ADDCS   r2, r2, #4
        ADDMI   r2, r2, #4
        SUBS    r4, r4, #1
        BNE     BuildBlockInst1
        MOV     pc, lr
  ]

        END
@


4.5
log
@Panel beat with hammer of sanity.
Deleted c.SpriteOp to untangle it from c.rojpeg to draw boundary around JPEG code.
Moved all the OS_SpriteOp code out of SprExtend into a new file SprOp, so the main file just contains the usual macros/includes/module heading.
Added new 'debugso' switch for debugging SpriteOps, was previously using 'debuggs' which is supposed to be for JPEG leading to reams of confusing debug.
TestForMaskAtDepth was rejecting 8bpp sprites with masks due to testing against log2bpp (4) instead of sprite type (5).
NSM_bpptable re-encoded in bytes rather than words, accesses ammended accordingly.
Took fresh copy of swiv2 from RISCOS_Lib revision 4.7.
SpriteV interception made a bit simpler (& faster).
Fixes to validate sprite (SpriteOp 17):
 Was looking at the wrong bits of the mode word to test for old mode words.
 Added new test for DPI values being non zero.
 Algorithm more closely follows PRM.

Version 1.27. Tagged as 'SprExtend-1_27'
@
text
@d80 1
a83 1
swix_get_on_with_it
@


4.4
log
@  Fix bug where "Sprite doesn't exist" error message was being truncated.
Detail:
  cache_sprite_doesnt_exist_error routine in MsgCode failed to take into
  account the fact that the messages file might be tokenised. Calling
  MessageTrans_Lookup with R2=0 gives you the length of the unexpanded
  message in R3. Now fixed to work in a better way.
  Also rename fp to r11 in swiv2 file to avoid assembler warnings.
Admin:
  Soft-loaded module tested. Problem seems to be solved.


Version 1.17. Tagged as 'SprExtend-1_17'
@
text
@d16 11
a26 1
                AREA    |C$$code|, CODE, READONLY
d37 1
a37 3
        TST     r1, #&FF0                 ; check for use of input regs. 4 to 9, or of block param
        BNE     swix_even_more_tedious    ; if so, do full stuff

d41 1
a41 2
        SUB     sp, sp, #5*4              ; so we can use tail code common with dynamic version
        STMIA   sp, {r10, r11}            ; and room enough to stash r10, r11
d43 3
a45 2
        ADD     r12, sp, #(5+8)*4         ; r12 -> input args
        MOV     r10, r0                   ; target SWI code
d49 1
a49 1
        LDRNE   r0, [r12], #4
d51 1
a51 1
        LDRNE   r1, [r12], #4
d53 1
a53 1
        LDRNE   r2, [r12], #4
d55 1
a55 10
        LDRNE   r3, [r12], #4

        SWI     XOS_CallASWI
        LDMIA   sp, {r10, r11}            ; restore
        B       SWIXReturn

swix_even_more_tedious
|_swi|
        STMFD   sp!, {r2, r3}             ; put 1st two variadic args on stack
        STMDB   sp!, {r1, r4-r9, lr}      ; save stuff
d57 4
a60 15
        SUB     sp, sp, #5*4              ; so we can use tail code common with dynamic version
        STMIA   sp, {r10, r11}            ; and room enough to stash r10, r11

        ADD     r12, sp, #(5+8)*4         ; r12 -> input args
        MOV     r10, r0                   ; target SWI code

        MOV     r11, r1
        TST     r11, #&001
        LDRNE   r0, [r12], #4
        TST     r11, #&002
        LDRNE   r1, [r12], #4
        TST     r11, #&004
        LDRNE   r2, [r12], #4
        TST     r11, #&008
        LDRNE   r3, [r12], #4
d62 1
a62 1
        LDRNE   r4, [r12], #4
d64 1
a64 1
        LDRNE   r5, [r12], #4
d66 1
a66 1
        LDRNE   r6, [r12], #4
d68 1
a68 1
        LDRNE   r7, [r12], #4
d70 1
a70 1
        LDRNE   r8, [r12], #4
d72 1
a72 1
        LDRNE   r9, [r12], #4
d74 5
a78 2
        TST     r11, #&800                ; use of block parameter input
        BLNE    swi_blockhead
d80 1
a80 1
        TST     r10, #&20000              ; if non X SWI, could be a return value register
d83 5
a87 2
        SWI     XOS_CallASWI
        LDMIA   sp, {r10, r11}            ; restore
d91 6
a96 3
        SWI     XOS_CallASWI
        LDMIA   sp, {r10, r11}            ; restore
        STR     pc, [sp, #4*4]!
d98 10
a107 1
        ANDS    lr, lr, #&000F0000        ; select return value register
d127 1
a127 1
        CMP     lr, #&000F0000          ; for goodness sake!
d133 6
a138 2
        ;r12 currently -> first output arg, so crank it past them
        MOV     r10, #6
d145 1
a145 1
        ;now r12 -> parameter block args on stack
d168 1
a168 1
        LDMFD   sp!, {r10-r12, pc}
d207 1
a207 1
        BLNE    BuildBlockInst
a213 4
  [ StrongARMfudge
    ; so that dynamic version would at least work
    SyncStackCode 5
  ]
d217 1
a217 1
        STR     pc, [sp, #4*4]!
d229 1
a229 1
        STR     pc, [sp, #4*4]!
@


4.3
log
@32-bit compatible. Tagged as SprExtend-1_06
@
text
@d34 1
a34 1
        STMIA   sp, {sl, fp}              ; and room enough to stash r10, r11
d50 1
a50 1
        LDMIA   sp, {sl, fp}              ; restore
d59 1
a59 1
        STMIA   sp, {sl, fp}              ; and room enough to stash r10, r11
d93 1
a93 1
        LDMIA   sp, {sl, fp}              ; restore
d98 1
a98 1
        LDMIA   sp, {sl, fp}              ; restore
@


4.2
log
@Version RO_3_70 taken
@
text
@d265 1
a265 1
        MOVS    pc, lr
d279 1
a279 1
        MOVS    pc, lr
@


4.1
log
@Initial revision
@
text
@d20 145
d204 4
d209 1
d212 2
d267 1
d280 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a19 145

  [ StrongARM
    ; tedious static _swi(x) entry handling, to avoid generating dynamic code, and
    ; requiring an expensive XOS_SynchroniseCodeAreas

|_swix|
        ORR     r0, r0, #&20000
        TST     r1, #&FF0                 ; check for use of input regs. 4 to 9, or of block param
        BNE     swix_even_more_tedious    ; if so, do full stuff

        STMFD   sp!, {r2, r3}             ; put 1st two variadic args on stack
        STMDB   sp!, {r1, r4-r9, lr}      ; save stuff

        SUB     sp, sp, #5*4              ; so we can use tail code common with dynamic version
        STMIA   sp, {sl, fp}              ; and room enough to stash r10, r11

        ADD     r12, sp, #(5+8)*4         ; r12 -> input args
        MOV     r10, r0                   ; target SWI code

        MOV     r11, r1
        TST     r11, #&001
        LDRNE   r0, [r12], #4
        TST     r11, #&002
        LDRNE   r1, [r12], #4
        TST     r11, #&004
        LDRNE   r2, [r12], #4
        TST     r11, #&008
        LDRNE   r3, [r12], #4

        SWI     XOS_CallASWI
        LDMIA   sp, {sl, fp}              ; restore
        B       SWIXReturn

swix_even_more_tedious
|_swi|
        STMFD   sp!, {r2, r3}             ; put 1st two variadic args on stack
        STMDB   sp!, {r1, r4-r9, lr}      ; save stuff

        SUB     sp, sp, #5*4              ; so we can use tail code common with dynamic version
        STMIA   sp, {sl, fp}              ; and room enough to stash r10, r11

        ADD     r12, sp, #(5+8)*4         ; r12 -> input args
        MOV     r10, r0                   ; target SWI code

        MOV     r11, r1
        TST     r11, #&001
        LDRNE   r0, [r12], #4
        TST     r11, #&002
        LDRNE   r1, [r12], #4
        TST     r11, #&004
        LDRNE   r2, [r12], #4
        TST     r11, #&008
        LDRNE   r3, [r12], #4
        TST     r11, #&010
        LDRNE   r4, [r12], #4
        TST     r11, #&020
        LDRNE   r5, [r12], #4
        TST     r11, #&040
        LDRNE   r6, [r12], #4
        TST     r11, #&080
        LDRNE   r7, [r12], #4
        TST     r11, #&100
        LDRNE   r8, [r12], #4
        TST     r11, #&200
        LDRNE   r9, [r12], #4

        TST     r11, #&800                ; use of block parameter input
        BLNE    swi_blockhead

        TST     r10, #&20000              ; if non X SWI, could be a return value register
        BEQ     swi_beyond_a_joke

        SWI     XOS_CallASWI
        LDMIA   sp, {sl, fp}              ; restore
        B       SWIXReturn

swi_beyond_a_joke
        SWI     XOS_CallASWI
        LDMIA   sp, {sl, fp}              ; restore
        STR     pc, [sp, #4*4]!
        LDR     lr, [sp, #1*4]
        ANDS    lr, lr, #&000F0000        ; select return value register
        BEQ     SWIReturn2
        CMP     lr, #&00010000
        MOVEQ   r0, r1
        CMP     lr, #&00020000
        MOVEQ   r0, r2
        CMP     lr, #&00030000
        MOVEQ   r0, r3
        CMP     lr, #&00040000
        MOVEQ   r0, r4
        CMP     lr, #&00050000
        MOVEQ   r0, r5
        CMP     lr, #&00060000
        MOVEQ   r0, r6
        CMP     lr, #&00070000
        MOVEQ   r0, r7
        CMP     lr, #&00080000
        MOVEQ   r0, r8
        CMP     lr, #&00090000
        MOVEQ   r0, r9
        CMP     lr, #&000F0000          ; for goodness sake!
        LDREQ   r0, [sp]
        B       SWIReturn2

swi_blockhead
        STMFD   sp!, {r10-r12, lr}
        ;r12 currently -> first output arg, so crank it past them
        MOV     r10, #6
swi_blockhead1
        MOVS    r11, r11, ASL #2
        ADDCS   r12, r12, #4
        ADDMI   r12, r12, #4
        SUBS    r10, r10, #1
        BNE     swi_blockhead1
        ;now r12 -> parameter block args on stack
        LDR     r11, [sp,#4]
        ANDS    r11, r11, #&f000       ;select reg for parameter block pointer
        MOVEQ   r0, r12
        CMP     r11, #&1000
        MOVEQ   r1, r12
        CMP     r11, #&2000
        MOVEQ   r2, r12
        CMP     r11, #&3000
        MOVEQ   r3, r12
        CMP     r11, #&4000
        MOVEQ   r4, r12
        CMP     r11, #&5000
        MOVEQ   r5, r12
        CMP     r11, #&6000
        MOVEQ   r6, r12
        CMP     r11, #&7000
        MOVEQ   r7, r12
        CMP     r11, #&8000
        MOVEQ   r8, r12
        CMP     r11, #&9000
        MOVEQ   r9, r12

        LDMFD   sp!, {r10-r12, pc}

  ] ; StrongARM


  [ :LNOT: StrongARM

a58 4
  [ StrongARMfudge
    ; so that dynamic version would at least work
    SyncStackCode 5
  ]
a59 1

a61 2
  ] ; not StrongARM
SWIReturn2
a114 1
  [ :LNOT: StrongARM
a126 1
  ]
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.21;
access;
symbols
	SprExtend-1_83:4.21
	SprExtend-1_82:4.21
	SprExtend-1_81:4.21
	SprExtend-1_80:4.21
	SprExtend-1_79:4.21
	SprExtend-1_78:4.21
	SprExtend-1_77:4.21
	SprExtend-1_76:4.21
	SprExtend-1_75:4.21
	SprExtend-1_74:4.21
	SprExtend-1_73:4.21
	SprExtend-1_72:4.21
	SprExtend-1_71-nocfsi:4.20
	SprExtend-1_71:4.19
	SprExtend-1_70-tracef:4.18
	SprExtend-1_70-headers:4.17
	SprExtend-1_70:4.16
	SprExtend-1_69:4.16
	SprExtend-1_68:4.16
	SprExtend-1_67:4.16
	SprExtend-1_66:4.16
	SprExtend-1_65:4.15
	SprExtend-1_64:4.15
	SprExtend-1_63:4.15
	SprExtend-1_62:4.15
	SprExtend-1_61:4.15
	SprExtend-1_60:4.15
	SprExtend-1_59:4.15
	SprExtend-1_58:4.15
	SprExtend-1_57:4.15
	SprExtend-1_56:4.15
	SprExtend-1_55:4.15
	SprExtend-1_54:4.14
	SprExtend-1_53:4.14
	SprExtend-1_52:4.14
	SprExtend-1_51:4.13
	SprExtend-1_50:4.13
	SprExtend-1_38-1_35_2_16:4.12.2.7
	SprExtend-1_49:4.12
	SprExtend-1_48:4.12
	SprExtend-1_47:4.12
	SprExtend-1_38-1_35_2_15:4.12.2.7
	SprExtend-1_46:4.12
	SprExtend-1_45:4.12
	SprExtend-1_44:4.12
	SprExtend-1_43:4.12
	SprExtend-1_42:4.12
	SprExtend-1_41:4.12
	SprExtend-1_38-1_35_2_14:4.12.2.6
	SprExtend-1_40:4.12
	SprExtend-1_38-1_35_2_13:4.12.2.6
	SprExtend-1_38-1_35_2_12:4.12.2.5
	SprExtend-1_38-1_35_2_11:4.12.2.5
	SprExtend-1_38-1_35_2_10:4.12.2.4
	SprExtend-1_38-1_35_2_9:4.12.2.4
	SprExtend-1_38-1_35_2_8:4.12.2.3
	SprExtend-1_39:4.12
	SprExtend-1_38-1_35_2_7:4.12.2.3
	SprExtend-1_38-1_35_2_6:4.12.2.3
	SprExtend-1_38-1_35_2_5:4.12.2.2
	SprExtend-1_38-1_35_2_4:4.12.2.1
	SprExtend-1_38-1_35_2_3:4.12
	SprExtend-1_38-1_35_2_2:4.12
	SprExtend-1_38-1_35_2_1:4.12
	MigrateIJG8b:4.12.0.2
	SprExtend-1_38:4.12
	SprExtend-1_37:4.12
	SprExtend-1_36:4.12
	SprExtend-1_35:4.12
	SprExtend-1_34:4.12
	SprExtend-1_33:4.12
	SprExtend-1_32:4.11
	SprExtend-1_31:4.10
	SprExtend-1_30:4.10
	SprExtend-1_29:4.10
	SprExtend-1_28:4.10
	SprExtend-1_27:4.9
	SprExtend-1_26:4.8
	SprExtend-1_25:4.8
	SprExtend-1_24:4.7
	SprExtend-1_23:4.6
	SprExtend-1_22:4.5
	SprExtend-1_21:4.5
	SprExtend-1_20:4.4
	SprExtend-1_19:4.4
	SprExtend-1_18:4.3
	SprExtend-1_17:4.3
	RO_5_07:4.3
	SprExtend-1_16:4.3
	SprExtend-1_15:4.3
	SprExtend-1_14:4.3
	SprExtend-1_13:4.3
	SprExtend-1_12:4.3
	SprExtend-1_11:4.3
	SprExtend-1_10:4.3
	SprExtend-1_09:4.3
	SprExtend-1_08:4.3
	dellis_autobuild_BaseSW:4.2
	SprExtend-1_07:4.2
	SprExtend-1_06:4.2
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.3
	SprExtend-1_05:4.1
	Ursula_merge:4.1
	nturton_SprExtend-1_04:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.21
date	2016.05.21.14.03.45;	author rool;	state Exp;
branches;
next	4.20;
commitid	4BquZHousteH5m7z;

4.20
date	2016.05.21.13.48.14;	author rool;	state Exp;
branches;
next	4.19;
commitid	F2CfxJ1XTlg50m7z;

4.19
date	2016.05.21.13.44.32;	author rool;	state Exp;
branches;
next	4.18;
commitid	ZDqmsyNiMhv6Zl7z;

4.18
date	2016.05.21.13.37.15;	author rool;	state Exp;
branches;
next	4.17;
commitid	TvdqzFBJfCe7Wl7z;

4.17
date	2016.05.21.13.32.17;	author rool;	state Exp;
branches;
next	4.16;
commitid	yTqS85yKh7k8Ul7z;

4.16
date	2015.06.25.22.19.59;	author jlee;	state Exp;
branches;
next	4.15;
commitid	H3G7oogaq7kBtRqy;

4.15
date	2013.10.07.00.39.07;	author jlee;	state Exp;
branches;
next	4.14;
commitid	HcUKy3PafwqToi8x;

4.14
date	2013.08.06.23.16.18;	author jlee;	state Exp;
branches;
next	4.13;
commitid	z9XOph7zDZQ2Ur0x;

4.13
date	2012.07.28.15.23.38;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	b5jdybqzJ3Wdjlew;

4.12
date	2010.10.17.09.01.32;	author rsprowson;	state Exp;
branches
	4.12.2.1;
next	4.11;

4.11
date	2010.10.13.20.26.17;	author rsprowson;	state Exp;
branches;
next	4.10;

4.10
date	2010.09.25.12.19.17;	author rsprowson;	state Exp;
branches;
next	4.9;

4.9
date	2010.09.19.09.03.44;	author rsprowson;	state Exp;
branches;
next	4.8;

4.8
date	2010.09.17.20.58.15;	author rsprowson;	state Exp;
branches;
next	4.7;

4.7
date	2010.09.01.20.48.51;	author rsprowson;	state Exp;
branches;
next	4.6;

4.6
date	2010.08.29.08.36.04;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2009.06.11.22.12.54;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2009.04.24.00.48.33;	author srevill;	state Exp;
branches;
next	4.3;

4.3
date	2001.05.15.10.57.00;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	2000.05.12.12.59.05;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.45.16;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.12.2.1
date	2011.01.04.21.45.26;	author rsprowson;	state Exp;
branches;
next	4.12.2.2;

4.12.2.2
date	2011.01.04.22.13.05;	author rsprowson;	state Exp;
branches;
next	4.12.2.3;

4.12.2.3
date	2011.01.09.10.42.55;	author rsprowson;	state Exp;
branches;
next	4.12.2.4;

4.12.2.4
date	2011.01.22.17.58.26;	author rsprowson;	state Exp;
branches;
next	4.12.2.5;

4.12.2.5
date	2011.01.29.10.03.35;	author rsprowson;	state Exp;
branches;
next	4.12.2.6;

4.12.2.6
date	2011.02.05.09.56.50;	author rsprowson;	state Exp;
branches;
next	4.12.2.7;

4.12.2.7
date	2011.08.06.10.44.29;	author rsprowson;	state Exp;
branches;
next	;
commitid	gAycmEnWp5AVeruv;

4.1.1.1
date	96.11.05.09.45.16;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.42.46;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.58.27;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.21.00;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.21
log
@Transcode arithmetics
Detail:
  Import of the raw coefficient Huffman entropy compressor elements of the IJG8d library.
  We don't need a full compressor (ala JCompMod) since there's never a need to go all the way through IDCT/upsampling/colour conversion only to reverse the whole process; it's sufficient only to collect up the raw coefficients and recompress them as a baseline JPEG.
  Two extra (temporary) dynamic areas are introduced, once to hold the raw coefficients and the other to act as a scratch file to make the JPEG in. See Doc/JPEGMmgr.
Admin:
  Submission for the JPEG bounty.

Version 1.72. Tagged as 'SprExtend-1_72'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.PutScaled.

; started WRS 3rd August 1993
; This is link and service code for the compiled form of c.putscaled,
; which exists in s.putscaled.
; It needs no hand patches, except that the register definitions at
; the beginning duplicate existing definitions and should be removed.

; ... is it a problem being in SVC mode? No problems so far!

; --------------------------------------------------------------------------------------
; Provide a basic debugging output routine.
; => R0 = a character to output
; <= R0 = -ve to denote no tracing right now 
    [ debug
        EXPORT  asm_writech
asm_writech
      [ {TRUE}
        ; HAL serial out
        Push    "R12,LR"
        MOV     R12,SL          ; get back workspace pointer.
        LDR     R1,debug_transmit
        TEQ     R1,#0
        MOVEQ   R0,#-1          ; no function pointer
        Pull    "R12,PC",EQ
        MOV     LR,PC
        MOV     PC,R1
        MOV     R0,#0
        Pull    "R12,PC"
      |
        ; HostFS out
        Push    "LR"
        SWI     XHostFS_WriteC
        MOVVS   R0,#-1
        MOVVC   R0,#0
        Pull    "PC"
      ]
    ]

dividebyzero
        Debug   cc,"DIVIDE BY ZERO",a2,a1,lr
        B exit

exit_oserror
; Exit from C with R0 = error ptr
        SETV
        ; FALL THROUGH to exit.

; --------------------------------------------------------------------------------------
; For an unexpected exit from compiled code, such as an assertion failure.
; There's no error message unless you're debugging, you simply stop the
; whole plot operation and return as fast as possible.
; If debugging, you have (presumably) already put out an error message.
exit
        MOV     r1, #0
exit_erl
        MOV     R12,SL              ; get back workspace pointer.
        STR     r0,ccompiler_errptr
        LDR     SP,ccompiler_sp     ; get back SP
        Debug   cc,"unexpected exit C code",R1 ; usually C line number
        B       exitbiggie

; ---------------------------------------------------------------------------------------
; Dynamic area allocation for the JPEG code.

ErrorBlock_DynName
        DCD     1
        DCB     "DynName:JPEG workspace"
        DCB     0
        ALIGN

ErrorBlock_DynTran
        DCD     1
        DCB     "DynTran:JPEG transcode"
        DCB     0
        ALIGN

ErrorBlock_DynCoef
        DCD     1
        DCB     "DynCoef:JPEG coefficients"
        DCB     0
        ALIGN

        EXPORT  area_resize
; on entry r0 = area type
;          r1 = pointer to variable with current size and to receive actual size after rounding
;          r2 = new absolute size size requested
; on exit  r0 = pointer to block, or 0 for 'none possible'
area_resize ROUT
        Push    "r4,lr"
        MOVS    r4,r1               ; check for a create operation
        LDRNE   r3,[r1]             ; current size
        BNE     %FT10

        ADD     lr,sl,#:INDEX:area_numbers
        LDR     lr,[lr,r0,LSL#2]
        TEQ     lr,#0
        MOVNE   r3,#0
        BNE     %FT10               ; area previously created, just zero size

        Push    "r0,r4-r8"
        CMP     r0,#1
        ADRHIL  r0,ErrorBlock_DynName
        MOVHI   r4,#0               ; area flags
        MOVLS   r4,#1:SHL:7         ; not draggable
        ADREQL  r0,ErrorBlock_DynTran
        MOVCS   r5,#&500000         ; max size approx for 32kx32k JPEG with worst case band buffer
        ADRCCL  r0,ErrorBlock_DynCoef
        MOVCC   r5,#&40000000       ; max size approx 8kx8k of JCOEF's
        BL      copy_error_one

        ADD     r8,r0,#4            ; r8 now points to Dynamic Area Name string!
        MOV     r0,#0               ; Create a new area
        MOV     r1,#-1
        MOV     r3,#-1
        MOV     r6,#0
        MOV     r7,#0
        SWI     XOS_DynamicArea
        Pull    "r0,r4-r8"
        BVS     %FT20

        ADD     lr,sl,#:INDEX:area_numbers
        STR     r1,[lr,r0,LSL#2]
        MOV     r0,r1
        B       %FT15
10
        SUB     r1,r2,r3            ; change in size
        ADD     lr,sl,#:INDEX:area_numbers
        LDR     r0,[lr,r0,LSL#2]    ; area
        SWI     XOS_ChangeDynamicArea
15
        SWIVC   XOS_ReadDynamicArea
20
        STRVS   r0,[sl,#:INDEX:ccompiler_errptr] ; if an error, remember it
        MOVVS   r0,#0               ; ... and return null pointer
        Pull    "r4,pc",VS
        TEQ     r4,#0
        STRNE   r1,[r4]             ; update workspace size
        Pull    "r4,pc"

        EXPORT  area_remove
; on entry r0 = area type
area_remove ROUT
        MOV     r3,lr
        ADD     lr,sl,#:INDEX:area_numbers
        LDR     r1,[lr,r0,LSL#2]    ; area
        CMP     r1,#0
        MOVNE   r2,#0
        STRNE   r2,[lr,r0,LSL#2]    ; mark as forgotten
        MOVNE   r0,#1               ; remove
        SWINE   XOS_DynamicArea
        MOV     pc,r3

; ---------------------------------------------------------------------------------------
bitblockmove
; routine for simple bit block move.

; This is called by the compiled code when pixels are equal size, no mask, only 'set' gcol action, no table.
; There's no point in 'compiling' it because there are no important variants that we want to compile in,
; so it's clearer to just write it in the assembler.

; Registers on entry:
r_inptr RN      0       ; r_inptr -> input (word pointer)
r_outptr RN     1       ; r_outptr -> output (word pointer)
r_inshift RN    2       ; r_inshift (aka r_inword3) - number of (most significant) bits of first word to transfer, in 1..32
r_outshift RN   3       ; r_outshift (aka r_inword4) - number of (most significant) bits of space in first word to fill up, in 1..32
r_xcount RN     4       ; r_xcount - number of bits to transfer.

; Workspace registers:
r_inword RN     5       ; r_inword, r_inword2 - temp space
r_inword2 RN    6       ; must come AFTER r_inword for LDM
r_outword RN    7       ; r_outword, r_outword2, r_outword3, r_outword4 - temp space
r_outword2 RN   8       ; must come AFTER r_outword for STM
r_shl    RN     9       ; r_shl, r_shr - temp space
r_shr    RN     10
                        ; NB r12 is NOT set up.
                        ; On exit arg registers are corrupted, others preserved

        STMDB   sp!,{r_inword,r_inword2,r_outword,r_outword2,r_shl,r_shr,lr}

;        Debug   cc,"bitblockmove: ",r0,r1,r2,r3,r4
;        Debug   cc,"            : ",r5,r6,r7,r8,r9
;        Debug   cc,"            : ",r10,r11,r12,sp,lr,pc

; The following diagrams help when trying to think about shift cases, especially for start conditions etc.
; Note particularly that an entire display line is 'little-endian' - least sig pixel is at the left,
; most sig pixel is at the right in an entirely consistent way.

; Input words:
; 0                             31 0                             31 0                             31 bit number
; |------------------------------| |------------------------------| |------------------------------|
; What to transfer:
;                         |***************************************************** . . .
;                         <-----> this is r_inshift on entry
; Output words:
; 0                             31 0                             31 0                             31 bit number
; |------------------------------| |------------------------------| |------------------------------|
; What to fill up:
;                |***************************************************** . . .
;                <--------------> this is r_outshift on entry

; The difference between r_outshift and r_inshift is the distance that bulk data has to be shifted,
; once we get into the main loop.

; the bottom 32-outshift bits of outword should be loaded
; with whatever is there already.
        LDR     r_outword,[r_outptr]
        MOV     r_outword,r_outword,LSL r_outshift
        MOV     r_outword,r_outword,LSR r_outshift                     ; discard unwanted bits

; xcount counts the number of bits which must be
; saved at r_outptr, of which the first r_shl bits can be found in outword
; and the remainder are still to be fetched from r_inptr.
        RSB     r_outword2,r_outshift,#32                              ; temp use of r_outword2
        ADD     r_xcount,r_xcount,r_outword2                           ; add the bits we've just loaded in

; Only the top r_inshift bits of r_inword are interesting
        LDR     r_inword,[r_inptr],#4
        RSB     r_inword2,r_inshift,#32                                ; temp use of r_inword2
        MOV     r_inword,r_inword,LSR r_inword2                        ; discard unwanted bits
        MOV     r_inword,r_inword,LSL r_inword2

; differing code depending on which of r_inshift and r_outshift is bigger
        CMP     r_outshift,r_inshift
        BEQ     insh_equal
        BLT     insh_more

; r_outshift is bigger than r_inshift:
; the first output word will consist of:
;   bottom 32-outshift bits undisturbed
;   top inshift bits from first input word
;   bottom outshift-inshift (= r_shr bits, shifted left by r_shl) bits from the next input word

        SUB     r_shr,r_outshift,r_inshift
        RSB     r_shl,r_shr,#32
        ORR     r_outword,r_outword,r_inword,LSR r_shr
        ; bottom r_shl bits of r_outword are now loaded with input.
        ; fetch the top of the next word as part of the main loop.
        B       loop64_enter

insh_equal
; No shift offset between input and output - everything a lot simpler!
; the first output word consists of:
;   bottom 32-outshift bits undisturbed
;   top 32-outshift bits of the input
        ORR     r_outword,r_outword,r_inword
        CMP     r_xcount,#32
        BLT     less32
        STR     r_outword,[r_outptr],#4
        SUBS    r_xcount,r_xcount,#32
        BEQ     done
; Now extra-simple 64-bit loop for no-shift case.
        B       loop64_noshift_enter
loop64_noshift
        LDMIA   r_inptr!,{r_inword,r_inword2}
        STMIA   r_outptr!,{r_inword,r_inword2}
loop64_noshift_enter
        SUBS    r_xcount,r_xcount,#64
        BGE     loop64_noshift
        MOV     r_outword,#0
        MOV     r_shl,#0
        MOV     r_shr,#32
        B       loop64_exit

insh_more
; inshift is bigger than outshift
; the first output word will consist of:
;   bottom 32-outshift bits undisturbed
;   outshift bits from the middle of the input word
        SUB     r_shl,r_inshift,r_outshift
        RSB     r_shr,r_shl,#32
        ORR     r_outword,r_outword,r_inword,LSL r_shl
; We still have r_shl bits of input at the top of r_inword,
; not the correct situation for entering the 64-bit loop (they should be
; at the bottom of r_outword). So, have to do one word of output by steam.
        CMP     r_xcount,#32
        BLT     less32
        STR     r_outword,[r_outptr],#4
        MOV     r_outword,r_inword,LSR r_shr
        SUBS    r_xcount,r_xcount,#32
        BEQ     done
        ; and fall into the 64-bit loop.

; the 64-bit loop - main time-critical bit
; The bottom r_shl bits of r_outword are valid and must be saved at r_outptr.
        SUBS    r_xcount,r_xcount,#64
        BLT     loop64_exit
loop64
        LDMIA   r_inptr!,{r_inword,r_inword2}                      ; pick up 64 input bits
        ORR     r_outword,r_outword,r_inword,LSL r_shl             ; borrow r_shl bits already in r_outword
        MOV     r_outword2,r_inword,LSR r_shr                      ; create outword2
        ORR     r_outword2,r_outword2,r_inword2,LSL r_shl
        STMIA   r_outptr!,{r_outword,r_outword2}                   ; output 64 bits
        MOV     r_outword,r_inword2,LSR r_shr                      ; holding r_shl bits over in r_outword
loop64_enter
        SUBS    r_xcount,r_xcount,#64                              ; loop if at least 64 bits still to do
        BGE     loop64                                             ; loop unless finished finished
loop64_exit                                                        ; we have finished the 64-bit loop
        ADDS    r_xcount,r_xcount,#64                              ; count how many still to do
        BEQ     done                                               ; exit if exactly finished

; The bottom r_shl bits of r_outword are valid and must be saved at r_outptr.
; r_xcount is less than 64.
        LDMIA   r_inptr!,{r_inword,r_inword2}                      ; all the input we'll ever need
        ORR     r_outword,r_outword,r_inword,LSL r_shl             ; make r_outword valid
        CMP     r_xcount,#32
        STRGE   r_outword,[r_outptr],#4                            ; if xcount >= 32 then do a whole word
        SUBGE   r_xcount,r_xcount,#32
        BEQ     done                                               ; if exactly 32 bits were left
        MOVGT   r_outword,r_inword,LSR r_shr                       ; create last output word
        ORRGT   r_outword,r_outword,r_inword2,LSL r_shl
less32
; output the bottom xcount (in 1..31) bits of r_outword, combined with what is already at [r_outptr].
        LDR     r_outword2,[r_outptr]                              ; load word already there - we want top 32-xcount bits
        MOV     r_outword2,r_outword2,LSR r_xcount                 ; get rid of unwanted bits
        MOV     r_outword2,r_outword2,LSL r_xcount
        RSB     r_shl,r_xcount,#32
        MOV     r_outword,r_outword,LSL r_shl                      ; get rid of any unwanted new bits
        ORR     r_outword,r_outword2,r_outword,LSR r_shl           ; and combine the two
        STR     r_outword,[r_outptr]                               ; then save - we've finished
done
        LDMIA   sp!,{r_inword,r_inword2,r_outword,r_outword2,r_shl,r_shr,pc}

; --------------------------------------------------------------------------
; Now the entry sequence from the main assembler.
; We B here from the assembler when various calculations
; have already been done, and various values in the assembler workspace
; set up.
; To exit from here we B exitbiggie - r12,r13 must be preserved.
; Entry: r1 = the sprite itself
;        r5 = GCOL action, and whether to use mask.
;        r12 = assembler workspace pointer (of course)
;        r13 = SVC stack (of course)
new_putscaled_compiler

; --------------------------------------------------------------------------------------
; Now the entry to the C code.
; Entry: r1 = the sprite itself
;        r5 = GCOL action, and whether to use mask.
;        r12 = assembler workspace pointer (of course)
;        r13 = SVC stack (of course)
;        all others are trash.

        LDR     r1,[r1,#spMode]     ; get the mode number/identifier
        STR     r1,save_mode        ; can be picked up by the C from here.

        MOV     R0,R12              ; assembler workspace pointer
        ADRL    R1,ccompiler_space  ; above R12, space for me.
        ADRL    R2,ccompiler_end    ; end of space for me.
        MOV     R3,R5               ; GCOL action and mask bit

        Debug   gs,"R1,R5,R12 = ",R1,R5,R12
        MOV     R4,#0
        STR     R4,ccompiler_errptr ; in case of error exit
        STR     SP,ccompiler_sp     ; in case of unexpected exit

        Debug   cc,"entering c code"
        MOV     SL,R12              ; will be left alone by compiled C - for debug routines above.
        BL      putscaled_compiler  ; dive into the C (returns r0=compiled code)
        MOV     R12,SL              ; R12 is ip to a C prog, will have been trampled on - restore it.

        SWI     XOS_RemoveCursors   ; about to stomp on the screen
        BVS     exitbiggie

        ADR     LR,ret              ; set return address
        MOV     PC,R0               ; and branch to the compiled code
        NOP
ret
        NOP
        SWI     XOS_RestoreCursors
        B       exitbiggie

      [ jpeg
; ----------------------------------------------------------------------
jpeg_fetchroutine
; This is called every line by compiled code from PutSpriteScaled, when the
; source is JPEG compressed data. It uses C function jpeg_find_line() to get some pixels.
; Entry:
;   r0 = y coordinate
;   r12 = wp
; Exit:
;   r0 = initial address to get RGB data from for this line, based given y coord.
;   all other registers preserved.

        Push    "R1-R3,R10-R12,LR"               ; r4-r9 are preserved by C code.

        MOV     R1,R0                            ; arg2 - int y coord
        LDR     R0,jpeg_info_ptr                 ; arg1 - decompress_info_ptr cinfo
        ADRL    R2,newtranstable                 ; arg3 - palette data
        Debug   gs,"palette in R2 = ",R2

        ; get ready to call C code
        MOV     SL,R12                           ; will be left alone by compiled C - for debug routines above.

        ; and call
        BL      jpeg_find_line                   ; base of that line in R0 on return

        Pull    "R1-R3,R10-R12,PC"               ; restore registers and return to runtime generated code.
      ]
      
; ----------------------------------------------------------------------------------------------

; Assembler function used by the C code to look up information about a pixel
; format. This would be in C, if the compiler didn't try and apply relocation
; offsets to it!

        MACRO
        PixelFormatInfo $br, $bg, $bb, $ba, $tr, $tg, $tb, $ta, $hints, $alphaimm12
        DCB $br, $bg, $bb, $ba, $tr, $tg, $tb, $ta, $hints, 0
        DCW $alphaimm12
        MEND

HINT_HIGHEST * 1

pixelformatinfo_table ; BITS        TOP             HINTS            ALPHAIMM12
        PixelFormatInfo 4, 4, 4, 0,  4,  8, 12,  0, 0,                 0         ; 12bpp TBGR
        PixelFormatInfo 4, 4, 4, 0, 12,  8,  4,  0, 0,                 0         ; 12bpp TRGB
        PixelFormatInfo 4, 4, 4, 4,  4,  8, 12, 16, HINT_HIGHEST<<3,  15+(20<<7) ; 12bpp ABGR
        PixelFormatInfo 4, 4, 4, 4, 12,  8,  4, 16, HINT_HIGHEST<<3,  15+(20<<7) ; 12bpp ABGR
        PixelFormatInfo 5, 5, 5, 0,  5, 10, 15,  0, 0,                 0         ; 15bpp TBGR
        PixelFormatInfo 5, 5, 5, 0, 15, 10,  5,  0, 0,                 0         ; 15bpp TRGB
        PixelFormatInfo 5, 5, 5, 1,  5, 10, 15, 16, HINT_HIGHEST<<3,   2+(18<<7) ; 15bpp ABGR
        PixelFormatInfo 5, 5, 5, 1, 15, 10,  5, 16, HINT_HIGHEST<<3,   2+(18<<7) ; 15bpp ABGR
        PixelFormatInfo 5, 6, 5, 0,  5, 11, 16,  0, HINT_HIGHEST<<2,   0         ; 16bpp  BGR
        PixelFormatInfo 5, 6, 5, 0, 16, 11,  5,  0, HINT_HIGHEST<<0,   0         ; 16bpp  RGB
        PixelFormatInfo 8, 8, 8, 0,  8, 16, 24,  0, 0,                 0         ; 24/32  BGR
        PixelFormatInfo 8, 8, 8, 0, 24, 16,  8,  0, 0,                 0         ; 24/32  RGB
        PixelFormatInfo 8, 8, 8, 8,  8, 16, 24, 32, HINT_HIGHEST<<3, 255+( 8<<7) ; 32bpp ABGR
        PixelFormatInfo 8, 8, 8, 8, 24, 16,  8, 32, HINT_HIGHEST<<3, 255+( 8<<7) ; 32bpp ARGB
        PixelFormatInfo 8, 8, 8, 0, 16, 24, 32,  0, HINT_HIGHEST<<2,   0         ; 32 HI TBGR

PixelFormat_12bpp * 5
PixelFormat_15bpp * 6
PixelFormat_16bpp * 7
PixelFormat_24bpp * 8
PixelFormat_32bpp * 9
PixelFormat_BPPMask * 15

        EXPORT  pixelformat_info
pixelformat_info
        AND     r1,r0,#PixelFormat_BPPMask       ; Get base format
        SUB     r2,r1,#PixelFormat_12bpp
        MOV     r2,r2,LSL #2                     ; r2 = table index
        CMP     r1,#PixelFormat_16bpp
        SUBHI   r2,r2,#2                         ; 16bpp only has two entries
        CMP     r1,#PixelFormat_24bpp
        SUBHI   r2,r2,#4                         ; 24bpp only has two entries, and 32bp is aliased ontop of  them
        ADD     r2,r2,r0,LSR #4                  ; Merge in RGB & alpha flags
        ADR     r0,pixelformatinfo_table
        ADD     r0,r0,r2,LSL #3                  ; 12 bytes per table entry
        ADD     r0,r0,r2,LSL #2
        MOV     pc,lr

        GET     Sources.swiv2
        GET     Sources.CSupport

      [ jpeg
; Now get optimised assembler bits of JPEG
        GET     jhdr.s
        GET     yuvtabs.s
        GET     Sources.diffuse
      ]
        END
@


4.20
log
@Removed CFSI-JPEG support
Detail:
  ChangeFSI now makes its own helper plugin which just calls the JPEG SWIs of the host OS, so there's no need for SpriteExtend to be complicated by this now.
Admin:
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_71-nocfsi
@
text
@d79 19
a97 1
        EXPORT  area_create
d99 25
a123 11
; on entry r0 = size in bytes
; on exit  r0 = pointer to block, or 0 for 'none possible'.
area_create  ROUT
        LDR     r2,[sl,#:INDEX:area_number]
        TEQ     r2,#0
        MOVNE   r1,r0               ; Already got an area number but malloc() got called
        BNE     area_resize         ; because some plonker resized it to zero

        Push    "r4-r8,lr"
        MOV     r2,r0               ; Initial size
        ADRL    r0,ErrorBlock_DynName
d125 1
a129 2
        MOV     r4,#0
        MOV     r5,#&600000         ; Maximum area size
d133 2
a134 5
        Pull    "r4-r8,lr"
        STRVC   r1,[sl,#:INDEX:area_number]
        MOVVC   r0,r3
        MOV     r1,lr               ; for the common exit
        B       %FT10
d136 8
a143 16
ErrorBlock_DynName
        DCD     1
        DCB     "DynName:JPEG workspace"
        DCB     0
        ALIGN

; on entry r0 = new size
; on exit  r0 = new size after rounding, or 0 for 'none possible'.
area_resize
        LDR     r2,[sl,#:INDEX:jpeg_info_ptr]
        TEQ     r2,#0               ; check if someone set it to zero behind our back
        LDRNE   r3,[r2,#cinfo_workspace_size]
        MOVEQ   r3,#0
        SUB     r1,r0,r3            ; change in size
        MOV     r3,lr
        LDR     r0,[sl,#:INDEX:area_number]
d145 1
d147 1
a147 3
        MOVVC   r0,r1
        MOV     r1,r3               ; shuffle return link for exit
10
d150 17
a166 1
        MOV     pc,r1
@


4.19
log
@Import of IJG8d library sources
Detail:
  Using the decoder in "example.c" as a starting point, we try to follow that sequence more closely even if in our embedded implementation some of the functions don't do much.
  Uses the default colour backend for 32bpp BGR output for most of the unusual cases.
  The most common 2x2 subsampling case uses a custom merged upsampler and colour converter, with colour output directly in RISC OS format for the respective screen mode.
Admin:
  Submission for the JPEG bounty.

Version 1.71. Tagged as 'SprExtend-1_71'
@
text
@a437 3
        GBLL    cfsi_jpeg
cfsi_jpeg SETL  {FALSE}

@


4.18
log
@Replace tracef debug calls
Detail:
  Change tracef() to use the double brackets trick rather than _ for , substitution
Admin:
  Debug build built, but not tested. Non debug build functions as before.
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_70-tracef
@
text
@d78 6
a83 10
; Memory allocation for the C code.
; malloc   on entry r0 = number of bytes to allocate (see PRM3 1-233)
;          on exit  r0 = pointer to block, or 0 for 'none possible'.
; realloc  on entry r0 = existing block pointer
;                   r1 = new size
;          on exit  r0 = pointer to block, or 0 for 'none possible'.
        EXPORT  malloc
        EXPORT  realloc
malloc  ROUT
      [ dynamicarea
d87 2
a88 1
        BNE     realloc             ; because some plonker resized it to zero
d90 1
a90 1
        MOV     r2,r0
a92 1
        CLRV
d94 1
a94 1
        MOV     r0,#0
d104 1
a104 1
        MOVVC   r2,r3
d113 4
a116 11
      |
        MOV     r3,r0               ; required size, for RMA allocation
        MOV     r0,#ModHandReason_Claim
        MOV     r1,lr               ; keep return link
        SWI     XOS_Module          ; do the claim - on exit R2 points to block, if non-error
        B       %FT10
      ]
      
realloc
      [ dynamicarea
        LDR     r0,[sl,#:INDEX:area_number]
d121 1
a121 1
        SUB     r1,r1,r3            ; change in size
d123 1
d125 2
a126 2
        SWI     XOS_ReadDynamicArea
        MOV     r2,r0
a127 9
      |
        LDR     r3,[sl,#:INDEX:jpeg_info_ptr]
        LDR     r3,[r3,#cinfo_workspace_size]
        SUB     r3,r1,r3            ; change in size
        MOV     r2,r0               ; pointer to existing heap block
        MOV     r0,#ModHandReason_ExtendBlock
        MOV     r1,lr               ; keep return link
        SWI     XOS_Module
      ]
d129 1
a129 2
        ADRVSL  r2,ccompiler_errptr
        STRVS   r0,[r2]             ; if an error, remember it
a130 1
        MOVVC   r0,r2               ; if no error, return pointer to C code
d441 2
a442 3
        GET     Sources.jdhuff
        GET     Sources.jidctfst
        GET     Sources.jdcolor
@


4.17
log
@Update headers to stock copy
Detail:
  Added headers jerror, jmorecfg, jpegint from IJG8d. Removed jpegdata header.
  Bulk rename of structure members to match newer headers, some RISCOS-isms wrapped in #ifdef RISCOS, retained for the time being.
  Assembler code now gets cinfo member offsets from jhdr.s derived from the C header rather than keeping its own dangerous copy of the offsets.
Admin
  Note: this has broken CFSI-jpeg as it expects the error values to be at the top of cinfo.
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_70-headers.
@
text
@d27 3
a29 2
; R0 = a character to output
      [ debug
d32 2
d36 7
a42 7
        CMP     R0,#10          ; newline char?
        BLEQ    Neil_NewLine
        BLNE    Neil_WriteC
        ADRL    R0,Neil_FileHandle
        LDR     R0,[R0]         ; return the file handle as a result of this function:
                                ; allows the C to know whether output is turned on,
                                ; <0 return -> no tracing right now.
d44 7
d52 1
@


4.16
log
@Fix rendering of sprites with garbage in the top bits of each pixel
Detail:
  Sources/PutScaled - Correct the hints in the pixel format table to not flag a component as being at the highest position in the colour if it doesn't actually touch the highest bit in the colour. Otherwise, the "We can merely shift this down into place" optimisation in convert_pixel() may be used, resulting in garbage data from the top bits of the source pixel being placed into the output.
Admin:
  Tested on Iyonix
  32bpp TBGR sprite with garbage in top byte of each pixel, now displays correctly in 15/16bpp TRGB modes
  Issue reported by Rob Sprowson


Version 1.66. Tagged as 'SprExtend-1_66'
@
text
@d119 1
a119 1
        LDRNE   r3,[r2,#workspace_size]
d129 1
a129 1
        LDR     r3,[r3,#workspace_size]
d366 1
a366 1
; source is JPEG compressed data.
a372 2
; This works by calling the C proc jpeg_find_line, defined in h.rojpeg, as:
;   static int *jpeg_find_line(decompress_info_ptr cinfo, int ycoord, int *palette_data);
@


4.15
log
@Add support for blended sprite & JPEG rendering - alpha masks, alpha channels, and translucency
Detail:
  This big set of changes adds support for the following user-facing APIs, as per ROL's specs:
  - OS_SpriteOp 52 (PutSpriteScaled) colour mapping, translucency blending, and alpha mask/alpha channel blending
  - OS_SpriteOp 56 (PutSpriteTransformed) colour mapping, translucency blending, and alpha mask/alpha channel blending
  - JPEG_Plot[File]Scaled colourmapping & translucency blending
  - JPEG_Plot[File]Transformed colourmapping & translucency blending
  Sources/CFSI-JPEG, Sources/PutScaled:
  - Added exit_oserror exit routine for use by C code.
  - For SpriteExtend this allows the C code to cause OS_SpriteOp to exit with a given OS error block.
  - For CFSI-JPEG the error block is returned and ERROR_FATAL is returned to ChangeFSI.
  Sources/CSupport:
  - Add definitions for some error codes (matches existing definitions from h/commondefs)
  Sources/PutScaled:
  - Stripped out code to look for identity translation tables; now handled by preparettr routine in Sources/SprOp
  Sources/SWIs, Hdr/SprExtend:
  - JPEG SWIs updated to add support for alpha-blended and colour mapped JPEG rendering, following ROL's APIs
  Sources/SprExtend:
  - Stripped out lots of old build flags which haven't been touched in years.
  - Strip out assembler SprTrans code generator.
  - Add new definitions needed for blending & colour mapping.
  Sources/SprOp:
  - Updated PutScaled frontend to deal with blending and colour mapping.
  - Disabled code which was bodging coordinates when dealing with double-pixel modes - it seems to cause a few issues, and the code generator mostly had proper double-pixel support anyway.
  - Translation table verification and fiddling code rewritten and consolidated into the preparettr routine. C code is now explicitly told what table type is in use and whether it can safely be ignored in favour of using the sprite palette.
  - Removed code from CheckSpriteArea which was deliberately throwing an error upon seeing alpha-masked sprites; I think the bug that was hiding has been fixed now
  Sources/SprTrans
  - Removed the assembler version of the code generator.
  - Updated to add support for blending and colour mapping
  c/PutScaled:
  - Old test code removed.
  - Updated to add support for blending & colour mapping
  - Assorted bugs fixed.
  - A few extra architecture-specific optimisations added.
  - Some workspace setup code moved to c/asmcore to allow sharing with SprTrans.
  c/asmcore:
  - Register allocation code rewritten. Instead of allocating on a first-come, first-served basis, the code now builds a list of which logical registers are needed (and which 'banks' they fall into) and then attempts to allocate them in a more intelligent manner. It still has some failings (e.g. reusing R12 as a general purpose register is currently impossible) but it's a lot more flexible and reliable than the old code.
  - Core pixel transformation code updated to add support for blending & colour mapping
  - Added some extra architecture-specific optimisations
  c/rojpeg:
  - JPEG option handling updated to avoid trashing any colour mapping descriptor that may have been passed in
  c/sprtrans:
  - Updated to add support for blending & colour mapping
  c/tracing:
  - Debug assert messages now show filename as well as line number
  h/commondefs:
  - Removed old #define's that related to old assembler switches.
  h/putscaled:
  - Workspace definition updated to match assembler version.
  - SprTrans stack workspace structure moved here from c/sprtrans
Admin:
  Tested on BB-xM plotting all major sprite & JPEG types into all modes with all major options


Version 1.55. Tagged as 'SprExtend-1_55'
@
text
@d407 2
a408 2
        PixelFormatInfo 4, 4, 4, 0,  4,  8, 12,  0, HINT_HIGHEST<<2,   0         ; 12bpp TBGR
        PixelFormatInfo 4, 4, 4, 0, 12,  8,  4,  0, HINT_HIGHEST<<0,   0         ; 12bpp TRGB
d411 2
a412 2
        PixelFormatInfo 5, 5, 5, 0,  5, 10, 15,  0, HINT_HIGHEST<<2,   0         ; 15bpp TBGR
        PixelFormatInfo 5, 5, 5, 0, 15, 10,  5,  0, HINT_HIGHEST<<0,   0         ; 15bpp TRGB
d417 2
a418 2
        PixelFormatInfo 8, 8, 8, 0,  8, 16, 24,  0, HINT_HIGHEST<<2,   0         ; 24/32  BGR
        PixelFormatInfo 8, 8, 8, 0, 24, 16,  8,  0, HINT_HIGHEST<<0,   0         ; 24/32  RGB
@


4.14
log
@Add support for new sprite types & screen modes
Detail:
  Makefile - Updated to fix a couple of dependency issues and to make c/asmcore the main C file, not c/putscaled
  Sources/PutScaled - Add a utility routine that's used by the C code to get information about pixel formats
  Sources/SprAdjSize - Add support for wide masks & RISC OS 5 style sprite mode words
  Sources/SprExtend - Tidy up workspace by removing lots of unused bits and moving other bits within sight of the C code. Add flag to control whether C or assembler version of SprTrans is used. Query kernel for ECFYOffset/ECHShift locations instead of using hardcoded values in putscaled code. Add fix for garbage debug strings in softloaded debug versions of the module.
  Sources/SprOp - Add support for wide masks & RISC OS 5 style sprite mode words. Update makepalette16bpp to cope with all the new 16bpp modes. Flag_* -> ModeFlag_* renaming. Move some translation table handling code into a new routine, 'preparettr'. Update checktrans/converttrans to deal with new pixel formats.
  Sources/SprTrans - If the C version of SprTrans is enabled, disable all of these assembler bits except for the outer loop which steps over each row of the screen
  Sources/jdcolor - Updated to deal with new pixel formats. 16bpp conversion code split off into new file, Sources/jdcolor16.
  Sources/jdcolor16 - New file containing the guts of the YUV -> 16bpp conversion code. Gets included multiple times with different options to generate the different conversion routines (code is too big for a macro).
  c/asmcore - New file containing lots of common code ripped out of c/PutScaled - e.g. workspace definition, main functions for register assignment & instruction generation, and code for pixel format conversion. Pixel format conversion code rewritten to cope with new pixel formats, and code buffer key word generation rewritten to fix a couple of bugs (e.g. some issues with dithering options were observed)
  c/PutScaled - Ripped out lots of code that's now in c/asmcore. Now just deals with things that are PutScaled-specific, e.g. main plotter loop containing pixel read/write code. Code extended to cope with new pixel formats
  c/rojpeg, h/jinclude, h/jpegdata - Code extended to cope with new 16bpp conversion routines
  c/sprtrans - New C implementation of the core per-row transformed sprite plotting code generator. Allows reuse of the extensive pixel conversion code in c/asmcore, and allows for better code generation than the assembler original.
  h/putscaled - Worksapce definition updated to match assembler version
Admin:
  Tested on BB-xM, plotting lots of different sprites in lots of different modes
  Plotting of wide mask sprites not supported yet
  C version of YUV -> 16bpp code currently only deals with traditional &BGR 555 pixel format - code is aware of this and will do conversion to desired format if applicable (although quality may be reduced)
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 1.52. Tagged as 'SprExtend-1_52'
@
text
@d45 5
a325 81
; Before entering the C code, one more possible optimisation: we check for
; a lookup table that has no effect at all, and if found remove it.
; You'd be surprised how often such lookup tables get passed in :-)
; They slow down the blitting code, significantly in some cases.
        LDR     r0,ColourTTR               ; get the table
        CMP     r0,#0                      ; if no table
        BEQ     t_exit                     ; then skip this bit
        LDR     r2,BPP                     ; get output bpp
        LDR     r3,save_inlog2bpp          ; get log2 of input bpp
        MOV     r4,#1
        MOV     r4,r4,LSL r3               ; get input bpp
        CMP     r2,r4                      ; output bpp = input bpp?
        BNE     t_exit                     ; if not, don't even try
        CMP     r4,#16                     ; is input bpp 16 or more?
        BGE     t_exit                     ; if so, don't even try
        MOV     r3,#1
        MOV     r3,r3,LSL r4               ; get size of table, in bytes (2,4,16 or 256)
        ; If we reach here it's definitely worth looking through the table.
        ; r0 = table
        ; r3 = size of table
        ; r1,r5 to be preserved
        ; all others are trash.

        MOV     r2,#0                      ; r2 = expected next value in table
        TST     r0,#3                      ; is the table word-aligned?
        TSTEQ   r3,#3                      ; is the table more than 2 bytes?
        BEQ     t_wordaligned              ; if so, skip first loop that does first 1..3 bytes
        ; table pointer not aligned, or table of just 2 entries
t_loop0
        LDRB    r4,[r0],#1                 ; r4 = next value fetched from table
        CMP     r4,r2                      ; should equal expected value
        BNE     t_fail                     ; if not, give up
        ADD     r2,r2,#1                   ; increment expected value
        SUBS    r3,r3,#1                   ; decrement remaining size of table
        BEQ     t_identity                 ; table of just 2 bytes
        TST     r0,#3                      ; are we word aligned yet?
        BNE     t_loop0                    ; loop until word aligned
        ; exit from first-three-bytes loop - table is now word aligned.

        ; The main loop does four table entries at a time.
        ORR     r2,r2,r2,LSL #8            ; construct four copies of current value of table
        ORR     r2,r2,r2,LSL #16
t_wordaligned                              ; we branched to here with r2=0 if already word aligned
        LDR     r6,c03020100
        ADD     r2,r2,r6                   ; r2 = next four values in table
        LDR     r6,c04040404               ; r6 = what to add to get next four values
        SUBS    r3,r3,#4                   ; is table size at least four?
        BLT     t_loop_exit                ; if not, it was 2 or 4 to start with and not word-aligned
t_loop                                     ; start of 4-at-a-time loop
        LDR     r4,[r0],#4                 ; r4 = next 4 values fetched from table
        CMP     r4,r2                      ; compare four values
        BNE     t_fail                     ; fail if any one not identical
        ADD     r2,r2,r6                   ; advance all four bytes
        SUBS    r3,r3,#4                   ; counter of remaining table size
        BGE     t_loop
t_loop_exit ; exit from 4-at-a-time loop

        ADDS    r3,r3,#4                   ; remaining table size
        BEQ     t_identity                 ; succeed - normal route for word-aligned table

        ; otherwise, <3 bytes left to check as the tail of the table is not word-aligned
        MOV     r2,r2,LSR #24
        ADD     r2,r2,#1                   ; next expected table value
t_loop2
        LDRB    r4,[r0],#1                 ; next value from table
        CMP     r4,r2                      ; table value = expected value?
        BNE     t_fail                     ; if not, fail
        ADD     r2,r2,#1                   ; increment expected value
        SUBS    r3,r3,#1                   ; decrement size
        BNE     t_loop2                    ; branch until 0
        ; exit from last-three-bytes loop

t_identity
        ; success! discard the table
        STR     r3,ColourTTR               ; r3 known to be 0, as we've tested the whole table

t_exit
t_fail
        ; a normal table, or no table - do nothing.

; --------------------------------------------------------------------------------------
a361 4
        ; constants required for table comparison
c03020100 DCD   &03020100
c04040404 DCD   &04040404

@


4.13
log
@Adopt colour conversions from MigrateIJG8b branch
Now for every colour conversion there is a corresponding C function, allowing swapping between them for test purposes.
Here, 'ASMCOLOR' is selected and the C functions not even referenced in the makefile, see branch for use.
Permits use of USAT, for a small 1.5% speedup and smaller code.
Some other typedefs and comment shuffling copied over - should be harmless.

Version 1.50. Tagged as 'SprExtend-1_50'
@
text
@d474 51
@


4.12
log
@Change memory management strategy.
There's no need for the C code to know which pool of memory it's using, so simplify it to just use malloc() and realloc(), the assembler implementation can then select whether the RMA or a dynamic area is in use based on the 'dynamicarea' switch.
Be more careful about area_number when it is zero, since we use that to denote the area is not yet set up but area zero is a valid dynamic area number!
Trim out some unused workspace.
Variable ccompiler_errptr had '# 0' bytes assigned, resulting in writes off the end of the workspace.
Retire DUMPVAL[N]() macro.
Remove M_SOF9 as one of the SOF markers accepted - this is allocated to arithmetic JPEGs which aren't currently supported.
Save a few words by: changing arbitrary constants (eg. safety margins) to be a power of two so they can be register immediates; numerous loads and stores of R12 relative variables changed to not use ADRL; jpeg_fetchroutine similarly simplified.

Version 1.33. Tagged as 'SprExtend-1_33'
@
text
@d474 2
a475 2
        GET     sources.swiv2
        GET     sources.CSupport
d482 4
a485 4
        GET     sources.jdhuff
        GET     sources.jrevdct
        GET     sources.jcconv
        GET     sources.diffuse
@


4.12.2.1
log
@Reinstate jrevdct4 option to use C code IDCT (switch "ASMIDCT").
Name inverse DCT to match IJG 8b integer fast implementation.
Remove -DEMBED option and collapse switches.
Useful for speed comparisons.

Version 1.38, 1.35.2.4. Tagged as 'SprExtend-1_38-1_35_2_4'
@
text
@d483 1
a483 1
        GET     sources.jidctfst
@


4.12.2.2
log
@Fix CFSIjpeg due to earlier rename of jidctfst
Rename remaining files to match IJG 8b.

Version 1.38, 1.35.2.5. Tagged as 'SprExtend-1_38-1_35_2_5'
@
text
@d484 1
a484 1
        GET     sources.jdcolor
@


4.12.2.3
log
@Create assembler equivalents of C colour conversions, approx 10% speed up.
Add new switch ASMCOLOR to select which to use, C or assembler.
Remove FILE_ exit trace concept, just use __FILE__ instead in exit_erl.
Add some comments to exit_erl and friends.
A few bits of cinfo setup moved into start_pass_huff_decoder() or eliminated.
Bumped up the precision of SCALE_BITS in the C colour handling so FIX() uses more bits of an int.
Deleted the unused remenants of light dithering in the 8bpp colour converter - saves a few cycles.
colour_convert_8 and colour_convert_16 no longer save entry registers the C compiler doesn't care about.
Update genyuvtabs to EXPORT the table bases.
Split out the compilation of IJG files as separate objects in the make file, rather than including them from within rojpeg, which is itself included from putscaled.

Version 1.38, 1.35.2.6. Tagged as 'SprExtend-1_38-1_35_2_6'
@
text
@d17 7
a23 5
; Link and service code for the compiled form of c.putscaled
;   03-Aug-93 WRS started
;   It needs no hand patches, except that the register definitions at
;   the beginning duplicate existing definitions and should be removed.
;   ... is it a problem being in SVC mode? No problems so far!
a24 1
      [ debug
d27 2
a28 2
; asm_writech on entry r0 = a character to output
;             on exit  r0 = handle used for tracing, or -ve if not currently tracing
d32 2
a33 2
        MOV     R12,SL              ; get back workspace pointer.
        CMP     R0,#10              ; newline char?
d37 3
a39 1
        LDR     R0,[R0]
a42 5
; --------------------------------------------------------------------------------------
; Panic exit from divide function.
; dividebyzero on entry r0 = arg0
;                       r1 = arg1

a48 4
; exit        on entry r0 = exit reason code
; exit_erl    on entry r0 = exit reason code
;                      r1 = line number
;                      r2 = optional description
a51 3

        EXPORT  exit
        EXPORT  exit_erl
a53 1
        MOV     r2, #0
d58 1
a58 2
        Debug   cc,"exit line",R1   ; usually C line number
        DebugS  cc,"exit extra",R2  ; usually C file name
d63 5
a67 6
; malloc      on entry r0 = number of bytes to allocate (see PRM3 1-233)
;             on exit  r0 = pointer to block, or 0 for 'none possible'.
; realloc     on entry r0 = existing block pointer
;                      r1 = new size
;             on exit  r0 = pointer to block, or 0 for 'none possible'.

@


4.12.2.4
log
@New jerror.h taken from IJG8b.
Swap to using JERR_ numbers, deleted E_ numbers.
Modify genjhdr to pass some defines to the assembler code, so jdcolor can clarify use of DCTSIZE and DCTSIZE2.
Added chart of possible subsampling ratios to documentation.

Version 1.38, 1.35.2.9. Tagged as 'SprExtend-1_38-1_35_2_9'
@
text
@a493 1
        GET     jhdr.s
@


4.12.2.5
log
@Remap return results for CFSI-JPEG to match new cinfo structure.
Tested with a handful of JPEGs and !ChangeFSI.

Version 1.38, 1.35.2.11. Tagged as 'SprExtend-1_38-1_35_2_11'
@
text
@d126 1
a126 1
        LDRNE   r3,[r2,#cinfo_workspace_size]
d136 1
a136 1
        LDR     r3,[r3,#cinfo_workspace_size]
@


4.12.2.6
log
@Reorganise data input.
Fill in INPUT_VARS and INPUT_SYNC so it uses register variables.
Make use of data source manager (cinfo->src).
Calculate bytes_in_buffer when restoring the huffman position.
Swap process_restart() for the one now in jdmarker.

Version 1.38, 1.35.2.13. Tagged as 'SprExtend-1_38-1_35_2_13'
@
text
@d486 2
a487 2
        GET     Sources.swiv2
        GET     Sources.CSupport
d495 4
a498 4
        GET     Sources.jdhuff
        GET     Sources.jidctfst
        GET     Sources.jdcolor
        GET     Sources.diffuse
@


4.12.2.7
log
@Push recent changes on the trunk to the IJG8b branch.
Tested briefly, still works.

Version 1.38, 1.35.2.15. Tagged as 'SprExtend-1_38-1_35_2_15'
@
text
@d15 1
a15 1
; > Sources.PutScaled
@


4.11
log
@Paper and fill some JPEG cracks.
The exit_c function was repeatedly being called with the line number argument and error code the wrong way round and since only bits 0-2 of the error code are inspected on exit any fatal exits from the ported JPEG library code would either report the wrong error or fail silently (depending on the line number) - example a 12 bits per sample JPEG would be rendered without fault into a screen full of random memory garbage.
Assembling/compiling with the 'jpeg' switch off didn't work, fixed, and also now zeros out the SWI decode values in the module header.
Moved include of 'yuvtabs.s' into the colour conversion code.
Deleted panic_exit, it did nothing useful but trace a value then exit, so it now just calls exit() like everyone else.
Removed excess call to find_image_dims(), this was needed just to get the workspace requirements when the JPEG had already been sized up by asm_find_image_dims() earlier. Side effect of removing the pilot JPEG code earlier is that this call can now only get to the JPEG code from a JPEG_ SWI. Changed to just pass the workspace requirements into 'c.PutScaled' and save a duplicate scan.
Fatal exits from the assembler huffman decoder now report a sensible error.
Trimmed out all the JPEG assessment code from 'c.PutScaled' and moved it into 'c.rojpeg' so the put scaled is only concerned with putting things scaled.
Sanitised the #includes a bit.
Fixed on last check of wp->save_mode looking at the wrong bits for the mode number.
Resolved all the warning in the genhdr/genyuvtabs/genpalette utilities by casting a bit harder.[A[B
Added new more descriptive error messages to the messages file (not currently used), and made the 'not supported by' ones consistent so the tokeniser might crunch the file a bit more.
In looks_like_jpeg() changed a bitwise to logical or.
Fixed longstanding problem of not being able to render JPEGs at a scale of less than 1/6 in any greyscale mode, because, err, there was no code to do it - only the colour case was checked for. Implemented for 8bpp grey and 32bpp grey (which gets dithered for other lower modes) by just converting the luma channel into an equally weighted RGB value or replicating it for 256 greys.
Tested in all 8 colour depths on a Risc PC using sampling ratios of 1x1; 2x1; 1x2; 2x2 of the IJG test image scaled in !Draw by 0.16.

Version 1.32. Tagged as 'SprExtend-1_32'
@
text
@d25 1
a25 1
; --------------------------------------------------------------------------
d27 1
a27 1
; R0 = string to output
a30 1
; R0 = a character to output
d56 2
a57 4
        ADRL    R2,ccompiler_errptr
        STR     r0,[r2]
        ADRL    R1,ccompiler_sp
        LDR     SP,[R1]             ; get back SP
d63 39
a101 4
; malloc - r0 = number of bytes to allocate (see PRM3 1-233)
;          on exit, r0 = pointer to block, or 0 for 'none possible'.
malloc
        MOV     r1,lr               ; keep return link
d104 1
d106 26
a131 1
from_realloc
a137 27
; free - r0 = pointer to previously malloc'd block. (see PRM3 1-234)
free
        MOV     r1,lr               ; keep return link
        MOV     r2,r0               ; pointer to heap block
        MOV     r0,#ModHandReason_Free
        SWI     OS_Module           ; no error expected, unless we have internal errors
        MOV     pc,r1

; realloc_delta - r0 = pointer to block, r1 = CHANGE in size (see PRM3 1-240)
; (Can't provide the real realloc sadly, because these are the args that the OS wants)
realloc_delta
        MOV     r2,r0               ; pointer to heap block
        MOV     r3,r1               ; change in size
        MOV     r0,#ModHandReason_ExtendBlock
        MOV     r1,lr               ; keep return link
        SWI     XOS_Module
        B       from_realloc

; ---------------------------------------------------------------------------------------
;; debug output from within the compiled code.
;traceentry1
;        Debug   cc,"Tracepoint: lr,r4=",lr,r4
;        MOV     pc,lr

;; accessed from compiled code as bitblockmove-4 - sorry!
;traceentry
;        B       traceentry1
d411 1
a414 3
        MOV     SL,R12              ; will be left alone by compiled C - for debug routines above.
        ADRL    R3,ccompiler_sp
        STR     SP,[R3]             ; in case of unexpected exit
d416 1
d419 3
a421 2
        ADRL    R5,ccompiler_errptr
        STR     R4,[R5]             ; in case of error exit
d423 2
a424 2
        BL      putscaled_compiler  ; dive into the C
                                    ; returns r0==compiled code.
a426 9
;; We can't try the next bit until I can actually compile a routine:
;; returning a literal C routine doesn't work, AAsm can't handle what CC puts out.
;; So, do nothing for now.
;        Debug   cc,"exit c code",R0
;        B       exitbiggie

; If debugging, and if Debug$File is set, then do not enter the code.
; Only if Debug$File is unset do we enter the code.

d459 3
a462 4
        ADRL    R0,jpeg_info_ptr
        LDR     R0,[R0]                             ; arg1 - decompress_info_ptr cinfo
        ADRL    R2,newtranstable
        Debug   gs,"palette in R2 = ",R2
d469 1
a469 38
; This bit now removed, the calling code adds the in_x offset. This could be
; a word, byte or half-word offset, depending on how jpeg_scan_file was called.
;        MOV     R12,SL                           ; R12 is ip to a C prog, will have been trampled on - restore it.
;        ; returned value is int* for base of line.
;        ; now add in the initial source X coordinate.
;        LDR     R1,in_x                          ; x offset, as word count
;        ;Debug   cc,"x offset to add",R1
;        ADD     R0,R0,R1,LSL #2                  ; add word offset

        Pull    "R1-R3,R10-R12,PC"                ; restore registers and return to compiled code.

; Routine to Create a dynamic area with an Internationalised name.
; Called from C because the C code does not know about the Messages file.
        EXPORT  create_dynamic_area
create_dynamic_area
        Push    "R1-R9,LR"
        MOV     r2, r0
        ADRL    r0, ErrorBlock_DynName
        BL      copy_error_one
        CLRV
        ADD     r8, r0, #4     ; r8 now points to Dynamic Area Name string!
        MOV     r0, #0
        MOV     r1, #-1
        MOV     r3, #-1
        MOV     r4, #0
        MOV     r5, #&600000
        MOV     r6, #0
        MOV     r7, #0
        SWI     XOS_DynamicArea
        MOVVS   r0, #0
        MOVVC   r0, r1
        Pull    "R1-R9,PC"

ErrorBlock_DynName
        DCD     1
        DCB     "DynName:JPEG Workspace"
        DCB     0
        ALIGN
@


4.10
log
@Remove postprocessing step of C code.
Since 2001 this module has been using objasm, but still using the C compiler to output (via -S) assembly code which is then passed through 'sed' and included via GET into the assembler code.
Changed to compile the C code into object files, and use the linker to patch up the unresolved references - this has required some reordering of the C code to make sure static functions now appear in the object file, and some reordering of the header files to ensure both the module and the CFSI version still compile without conflicts.
Minor fix to 'swiv2', the label was in the wrong place for _swi() though it's not used in this module so didn't affect the _swix() case.
Makefile cut down a bit. Unixify some path names.
Test code moved to 'Test/c' directory.
Tested in both debug and non debug cases via softloaded module. Oddly, it's 4 bytes longer than the previous version.

Version 1.28. Tagged as 'SprExtend-1_28'
@
text
@d55 1
a55 1
exit_c
d58 1
a58 1
        STR     r1,[r2]
d61 1
a61 1
        Debug   cc,"unexpected exit c code",R0 ; a reason code is possible - usually C line number.
a458 2
      ]

d461 1
d486 2
a487 1

d490 1
d493 1
a499 1
        GET     yuvtabs.s
d502 1
a502 1
        GET     sources.swiv2
@


4.9
log
@Title line made consistent.
No code change - not tagged.
@
text
@a24 3
; Get things that compiled C needs
        GET     sources.CSupport

d29 1
a29 1

a462 1

a487 1

d490 1
a490 1
        GET     putscaled.s
d493 1
a493 1
        GBLL    cfsi_jpeg                        ; for inclusion in ChangeFSI binary?
@


4.8
log
@Comment corrected.
@
text
@d15 2
a16 1
; Sources.PutScaled.
@


4.7
log
@Clean up pass.
Trim 200+ lines of changes dating back to 1987, combine with non duplicates in the 'BlackLog'.
Use 'offsetof' macro in genjhdr to avoid warnings about uninitialised variables, rename from makejhdr so all the utils are clearly demarked.
Add throwback to MkCFSI-j.
Replace reason codes passed to SWIs with textual equivalents from the respective header files.
Speed up SWI despatch a bit by making the first few debug instructions depend on 'debuggs'.
Qualify all of the debug switches with the global 'debug' one.
Eliminate single use of 'pullx' macro.
Make do_branch() take an unsigned opcode so 50% of the branches don't result in implied cast warnings.
Added an UNUSED() macro to reduce a few of the legitimate warnings (the remainder are either in the original JPEG code or ones that it is worth checking the logic of.
Unixify one last filename.

Version 1.24. Tagged as 'SprExtend-1_24'
@
text
@d169 1
a169 1
        RSB     r_outword2,r_outshift,#32                              ; temp use of r_inword2
@


4.6
log
@A few small fixes.
Sources/PutScaled:
 Sync comment with C code.
Sources/SprExtend:
 Debug switch 'debuggs' had been left on, which left in some unnecessary code, but turning it off pulled in code with a stack imbalance. Now off.
 Ensured a terminator at the end of the RMEnsure.
 Colour translation tables passed to SetPointerShape that were in top bit set addresses were being interpreted as though no tt was supplied. Now tested against zero to match docs.
Sources/SprTrans:
 Switches pre 0.60 collapsed.
Sources/diffuse:
 The C code was corrupting r12 workspace pointer so the check of the flag 'ctrans_recent' sometimes failed leading to a duff table lookup.
 Small optimisation to checking of guard word.
c/PutScaled:
 Change paths to be Unix friendly.
rojpeg:
 Put assembler_panic in the header file to shut the compiler up.
3x unused files deleted.

Version 1.23. Tagged as 'SprExtend-1_23'
@
text
@d73 1
a73 1
        MOV     r0,#6               ; reason code
d86 1
a86 1
        MOV     r0,#7               ; reason code
d95 1
a95 1
        MOV     r0,#13              ; reason code
@


4.5
log
@  GET file pathnames changed
Detail:
  Uses suffixed file extensions for compatiblity with both objasm and asasm.
Admin:
  Supplied by Peter Naulls, tested at ROOL

Version 1.20. Not tagged
@
text
@d434 1
a434 1
;   static int *jpeg_find_line(decompress_info_ptr cinfo, int ycoord, int palette_data);
@


4.4
log
@Performance improvement and code tidy-up.

Removed local definition of XOS_CLI and XColourTrans_SelectTable, replaced
with header file.

Delete swiv2_old (moved to _old directory)

Changed to use {TRUE} and {FALSE} built in objasm variables.

Label dividebyzero fall through had code in the way for debug = {TRUE}.

Trimmed some dead code and definitions.

Stopped thrashing OS_CLI every time a JPEG plot is required to check
ColourTrans version, this is now done once at startup and a flag kept
instead.

Author: Rob Sprowson

Version 1.19. Tagged as 'SprExtend-1_19'
@
text
@d502 1
a502 1
        GET     s.yuvtabs
@


4.3
log
@  Now uses objasm throughout instead of aasm.
Detail:
  The build structure for this module is not nice - I've sanitised it a
    bit, but it's still not nice.
Admin:
   Built and tested with the test program briefly - the test sprite seems
     to scale and rotate properly.  ChangeFSI not tested.


Version 1.08. Tagged as 'SprExtend-1_08'
@
text
@a26 4
dividebyzero
        Debug   cc,"DIVIDE BY ZERO",a2,a1,lr
        ; FALL THROUGH to exit.

d44 1
d46 3
a48 1
      ]
a63 12

; Even when not debugging we attempt to remember the exit code, by setting
; an environment variable.
;        STMDB   sp!,{R0}            ; value to set must be in memory
;        ADR     R0,errvar           ; var name
;        MOV     R1,sp               ; pointer to value to set
;        MOV     R2,#0               ; -ve to delete variable
;        MOV     R3,#0               ; context pointer - doesn't apply
;        MOV     R4,#1               ; integer variable
;        SWI     XOS_SetVarVal
;        ADD     sp,sp,#4            ; discard memory location

a65 3
;errvar  =       "Sys$RC", 0
        ALIGN

a381 4
;        [ debug
;        MOV     r0,sp
;        Debug   gs,"9 sp = ",r0
;        ]
a388 2
;        [ debug
;        MOV     R4,sp
a389 1
;	]
a392 4
;      [ jpeg
;        ADRL    lr,jpeg_space       ; address of JPEG workspace, if needed
;        STMDB   sp!,{lr}            ; store on stack as fifth arg
;      ]
a395 4
;	[ debug
;        MOV     R12,sp
;        Debug   gs,"11 sp = ",r12
;	]
a396 1
;        ADD     sp,sp,#4            ; get rid of space for 5th arg.
d409 1
a410 12

;        Debug   cc,"About to call compiled/found code :",R0,R1,R2,R3,R4
;        Debug   cc,"                                  :",R5,R6,R7,R8,R9
;        Debug   cc,"                                  :",R10,R11,R12,sp,lr,pc

;      [ debug ;  (currently compiled out - it DOES enter)
      [ false
        ADRL    R2,Neil_FileHandle
        LDR     R2,[R2]
        CMP     R2,#0
        MOVLT   PC,R0               ; if file handle < 0, do it.
      |
a411 1
      ]
a414 4
;        [ debug
;        MOV     R12,sp
;        Debug   gs,"13 sp = ",r12
;	]
a415 4
;        [ debug
;        MOV     R12,sp
;        Debug   gs,"14 sp = ",r12
;	]
a439 1
;        ADRL    R0,jpeg_space                    ; arg1 - decompress_info_ptr cinfo
a460 60
 [ {FALSE}
; ----------------------------------------------------------------------------------------------
; Patch OS_ReadModeVariable so that type-9 new format sprites (JPEG) are treated just
; like type-6 ones (uncompressed 32-bit RGB).
; >>>> Not really needed any more - this isn't a sufficient patch, because there
;      are other consistency tests in the kernel which this does not pass.
newRMVr12 %     4                                 ; r12 will have been stored here

; This routine is entered in the kernel dispatch table.
; OS_ReadModeVariable args:
;   r0 = mode number/word/specifier
;   r1 = variable number
; on exit,
;   r2 = value of variable
;   C set if anything invalid
newReadModeVariable
;        STMDB   sp!,{r0-r3,lr}                    ; save registers
        STMDB   sp!,{r0-r3,wp,lr,pc}              ; get ready to call existing code
        LDR     wp,newRMVr12                      ; get our workspace pointer
        LDR     r2,oldReadModeVariable            ; get existing pointer
        STR     r2,[sp,#6*4]                      ; zap the saved PC

        ; Now we can zap a few registers, whatever we desire
        ; and write the zaps back onto the stacked registers
        MOV     r2,r0,LSR #27
        CMP     r2,#9                             ; this this type 9?
        BNE     %FT01
        TST     r0,#1                             ; is it a typed mode descriptor word?
        BEQ     %FT01
        ; It's a type 9

;        ; For variables that we actually care about, do the work ourselves rather
;        ; than passing it on. This makes it work on RISC OS 3.10.
;        CMP     r1,#4                             ; XEigFactor?
;        CMPNE   r1,#5                             ; YEigFactor?
;        MOVEQ   r2,#1                             ; if so, answer is 1
;        BEQ     %FT03
;        CMP     r1,#9                             ; Log2BPP?
;        CMPNE   r1,#10                            ; Log2BPC?
;        MOVEQ   r2,#5                             ; 32 bit
;        BEQ     %FT03

        ; It's not a variable I care about, so goodness knows what answer
        ; should be provided. Zap to type 6, and pass on to the existing code.
        BIC     r0,r0,#9:SHL:27                   ; no longer type 9
        ORR     r0,r0,#6:SHL:27                   ; set as type 6
        STR     r0,[sp]                           ; save to be his r0.
01      LDMIA   sp!,{r0-r3,wp,lr,pc}              ; go to his code (leave flags alone)
        ; This has a flaw, we don't get a chance to set R1 back again on exit:
        ; it is supposed to be unchanged for the caller. Hope it won't matter in
        ; this case!

03      ; r2 has an answer, return from the SWI
        STR     r2,[sp,#2*4]                      ; store r2 for reply
        LDMIA   sp!,{r0-r3,wp,lr}                 ; get all registers correct for exit
        ADD     sp,sp,#4                          ; get rid of PC value
        GBLL    Module                            ; needed by this macro
Module  SETL    {FALSE}                           ; this is what IRQUtils does
        ExitSWIHandler                            ; return to caller
       ]
a462 218
; ------------------------------------------------------------------------------------------------------
; SpriteOp JPEGInfo - a simple call through to find_image_dims, with suitable
; processing of arguments.
; Current state:
;  R1 = pointer to JPEG file image
;  R2 = length of JPEG file image
;  R3 = info flags - 0 -> validate, get dimensions
; Desired state:
;  R1 = info flags. Bits 0..7 are:
;       0 -> not JPEG data
;       1 -> greyscale
;       3 -> colour
;       bit 0 set -> monochrome
;  R2 = width in pixels
;  R3 = height in pixels
;  R4 corrupted
;  R5 corrupted
;  R6 corrupted
; Entry to the C code requires:
; static int find_image_dims(char *jdata, int *image_width, int *image_height, int *image_type, int *ws_size)
;   r0 = pointer to JPEG data
;   r1 = pointer to int to hold width
;   r2 = pointer to int to hold height
;   r3 = pointer to int to hold type (1 for grey, 3 for YUV)
;   [sp] = 0 (not interested in workspace size)
Go_JPEGInfo
        Push    "R1-R9,LR"              ; we must stick to the same form of saved registers as 'exitbiggie' assumes,
                                        ; in case of an unexpected exit from the C code.
;        Debug   in,"JPEGInfo sprite: R0,R1 =",R0,R1
;        CLRPSR  I_bit, R14              ; re-enable interrupts

; Set escape stack level in case of unexpected exit from C code.
;        ADRL    R3,ccompiler_sp
;        STR     SP,[R3]                 ; in case of unexpected exit
;        MOV     R4,#0
;        ADRL    R5,ccompiler_errptr
;        STR     R4,[R5]                 ; in case of error exit
;        MOV     r0,r1                   ; put JPEG pointer into r0

;        BL      asm_find_image_dims     ; corrupts r0 and sl, sets r1,r2,r3

;        ORR     r1,r1,#&ff00            ; get them to mask out top bits, in case we use them for other things later.
;        MOV     r4,lr                   ; spec'd as corrupted - so do the job properly
;        MOV     r5,lr
;        MOV     r6,lr
;        ADDS    sp,sp,#6*4              ; get rid of saved r1-r6 - clear V
        Pull    "R7-R9,PC"              ; copied from exitbiggie, but returning r1-r6 - r0 restored by exit sequence.

;asm_find_image_dims
; On entry:
;   r0 points to JPEG
;   exit level for C escape set
; On exit:
;   r1 = 0 or 1 or 3 for not-jpeg or mono or colour
;   r2 = width
;   r3 = height
;        Push    "r0,sl,lr"
;        SUB     sp,sp,#16               ; space for 5th arg, and three returned results
;        MOV     r3,#0
;        STR     r3,[sp]                 ; set fifth arg to 0
;        ADD     r1,sp,#4                ; set second arg
;        ADD     r2,sp,#8                ; set third arg
;        ADD     r3,sp,#12               ; set fourth arg
;        MOV     SL,R12                  ; will be left alone by compiled C - for debug routines above.
;        BL      find_image_dims         ; dive into the C - returns 0 in r0 if all is well.
;        MOV     R12,SL                  ; R12 is ip to a C prog, will have been trampled on - restore it.
;        LDR     r2,[sp,#4]              ; get image width
;        LDR     r3,[sp,#8]              ; get image height
;        MOVS    r1,r0                   ; is it JPEG?
;        LDREQ   r1,[sp,#12]             ; get image_type - 1 or 3
;        ADD     sp,sp,#16               ; get rid of stack workspace
;        Pull    "r0,sl,pc"

; ------------------------------------------------------------------------------------------------------
; Sprite op PutJPEGScaled
;
;On Entry:
;  R0 = 66
;  R1 = pointer to JPEG file image
;  R2 = length of JPEG file image
;  R3 = x coordinate at which to plot
;  R4 = y coordinate at which to plot
;  R5 = plot action
;  R6 = scale factors: 0 -> no scaling
;  R7 = pixel translation table
; We construct a bogus sprite header on the stack, and enter PutSpriteScaled pointing to this.
; For JPEG data in a real sprite the JPEG data starts after one word of the sprite data.
; For this sprite, that word is -1 in which case the next two words are the JPEG data pointer
; and length.
Go_PutJPEGScaled
        Push    "R1-R9,LR"              ; we must stick to the same form of saved registers as 'exitbiggie' assumes,
        Debug   in,"PutJPEGScaled sprite: R0,R1 =",R0,R1
;        CLRPSR  I_bit, R14              ; re-enable interrupts

; Set escape stack level in case of unexpected exit from C code.
;        ADRL    R3,ccompiler_sp
;        STR     SP,[R3]                 ; in case of unexpected exit
;        MOV     R4,#0
;        ADRL    R5,ccompiler_errptr
;        STR     R4,[R5]                 ; in case of error exit

; Space is allocated on the stack, as follows:
;   a fake sprite - spPalette+12 bytes
;   a translation table (in case ColourTrans writes one) - 256 bytes
;   saved registers R1-R9,LR so that exitbiggie can come back to us
        ^       0,sp
;pjs_start       #       0
;pjs_savearea    #       10*4
;pjs_table       #       12                        ; biggest table we can allocate for plotting from 32bpp.
;pjs_sprite      #       spPalette+12
;pjs_end         #       0
;        SUB     sp,sp,#pjs_end-pjs_start          ; allocate that space

; The sprite header sits on the stack. A sprite header consists of:
;   spNext    # 4  ;  Offset to next sprite
;   spName    # 12 ;  Sprite name
;   spWidth   # 4  ;  Width in words-1      (0..639)
;   spHeight  # 4  ;  Height in scanlines-1 (0..255/511)
;   spLBit    # 4  ;  First bit used (left end of row)
;   spRBit    # 4  ;  Last bit used (right end of row)
;   spImage   # 4  ;  Offset to sprite image
;   spTrans   # 4  ;  Offset to transparancy mask
;   spMode    # 4  ;  Mode sprite was defined in
;        MOV     r0,#spPalette+100
;        STR     r0,pjs_sprite+spNext               ; look realistic for SWI calls that read this header
;        MOV     r0,#'x'
;        STR     r0,pjs_sprite+spName               ; terminated by a zero character (>>> is this right?)
;        MOV     r0,#0
;        STR     r0,pjs_sprite+spLBit
;        MOV     r0,#spPalette
;        STR     r0,pjs_sprite+spImage
;        STR     r0,pjs_sprite+spTrans
;        MOV     r0,#20                             ; pretend to be mode 20
;        STR     r0,pjs_sprite+spMode
;        MOV     r0,#-1
;        STR     r0,pjs_sprite+spPalette            ; store identifier for indirect JPEG data.
;        STR     r1,pjs_sprite+spPalette+4          ; store pointer to JPEG data.
;        STR     r2,pjs_sprite+spPalette+8          ; store length of JPEG data

; Call find_image_dims to find the dimensions of the JPEG,
; and use this to fill in the rest of the sprite header.
;        MOV     r0,r1                              ; get pointer to JPEG
;        BL      asm_find_image_dims                ; sets r1,r2,r3
;        CMP     r1,#0                              ; if 0, it's not good JPEG data
;        BEQ     jpegscaled_errorexit
;        SUB     r3,r3,#1
;        STR     r3,pjs_sprite+spHeight             ; height in scanlines - 1
;        AND     r0,r2,#7
;        MOV     r0,r0,LSL #2                       ; (image_width & 7) * 4;
;        STR     r0,pjs_sprite+spRBit               ; number of bits used in right hand word
;        ADD     r0,r2,#7
;        MOV     r0,r0,ASR #3
;        SUB     r0,r0,#1                           ; ((image_width + 7) >> 3) - 1;
;        STR     r0,pjs_sprite+spWidth              ; number of words - 1

; Call ColourTrans to get a suitable translation table for sending 32-bit data
; into this screen mode. This is either a 32K table, or no table at all.
; If this produces an error then we're probably on RISC OS 3.1,
; in which case we go forward with no translation table.
;        ADR     r0,pjs_checkColourTrans
;        SWI     XOS_CLI                       ; *RMEnsure ColourTrans 1.25 Error no good
;        MOVVS   r7,#0                         ; error return - not new ColourTrans
;        BVS     %FT01
;        MOV     r0,#6:SHL:27
;        ORR     r0,r0,#1                      ; new mode number for 32bpp
;        MOV     r1,#-1                        ; default input, output, palette, everything
;        MOV     r2,#-1
;        MOV     r3,#-1
;        ADR     r4,pjs_table                  ; pointer to buffer to put table in
;        MOV     r5,#0                         ; no special flags
;        MOV     r6,#0
;        MOV     r7,#0
;        SWI     XColourTrans_SelectTable
;        BVS     jpegscaled_errorexit          ; error return, no table about
;        ADR     r7,pjs_table                  ; table to use now in r7, all through following code
;01

; Set up the output from readvduvars and readspritevars
;        BL      readvduvars             ; r7 undisturbed
;        BVS     jpegscaled_errorexit
;; This stuff is copied from readspritevars
;        MOV     R3,#5                   ; log2 of 32
;        STR     R3,save_inlog2bpc
;        STR     R3,save_inlog2bpp
;        MOV     R3,#32                  ; bits per pixel
;        STR     R3,save_inbpp
;        MOV     R3,#1                   ; log2 of 2 OS-units
;        STR     R3,inlog2px             ; pretend to be VGA-size pixels
;        STR     R3,inlog2py             ; pretend to be VGA-size pixels
;        STR     R3,is_it_jpeg           ; mark as a JPEG sprite
;        MOV     R0,#20
;        STR     R0,inmode               ; the mode vars are for mode 20 sprites.
;
;; Now set up the registers to enter the regular PutSpriteScaled code
;; r7 is already the translation table to use
;        ADR     r0,pjs_end              ; get at original saved registers
;        LDMIA   r0,{r1-r6}
;        ADR     lr,jpegscaled_exit
;        STMIA   sp,{r1-r9,lr}           ; save state for cleanup-and-exit
;        MOV     r6,r5                   ; the scale factor
;        MOV     r5,#0                   ; only plot action of 0 allowed (eg no XOR etc.)
;        ADR     r1,pjs_sprite           ; the fake sprite
;        STR     R1,save_sprite          ; so that later code can find the JPEG data again
;        MOV     R8,#0                   ; no printer calibration table
;        STR     R8,calibration_table
;        B       putsprscaled_frompjs
;
;; We come to here from exitbiggie, after either an error or plotting the sprite.
;; Just drop the stack, and exit.
;jpegscaled_exit
;jpegscaled_errorexit
;        ADD     sp,sp,#pjs_end-pjs_table          ; free that space
;        B       exitbiggie
;
;pjs_checkColourTrans
;        DCB     "RMEnsure ColourTrans 1.25 Error no good", 0 ; any error will do
;        ALIGN

d467 3
a469 3
	Push    "R1-R9,LR"
	MOV	r2, r0
	ADRL    r0, ErrorBlock_DynName
d472 12
a483 12
	ADD	r8, r0, #4     ; r8 now points to Dynamic Area Name string!
	MOV	r0, #0
	MOV	r1, #-1
	MOV	r3, #-1
	MOV	r4, #0
	MOV	r5, #&600000
	MOV	r6, #0
	MOV	r7, #0
	SWI	XOS_DynamicArea
	MOVVS   r0, #0
	MOVVC   r0, r1
	Pull    "R1-R9,PC"
d486 4
a489 4
	DCD	1
	DCB	"DynName:JPEG Workspace"
	DCB	0
	ALIGN
@


4.2
log
@32-bit compatible. Tagged as SprExtend-1_06
@
text
@d824 2
a825 2
; Now the compiled code itself.
        GET     S.PutScaled
a832 1
;        GET     sources.idct
@


4.1
log
@Initial revision
@
text
@d47 1
a47 1
        Pull    "R12,PC",,^
d514 1
d573 1
a573 1

@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

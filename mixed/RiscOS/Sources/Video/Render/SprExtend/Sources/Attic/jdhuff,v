head	4.9;
access;
symbols
	SprExtend-1_70-tracef:4.8
	SprExtend-1_70-headers:4.8
	SprExtend-1_70:4.8
	SprExtend-1_69:4.8
	SprExtend-1_68:4.8
	SprExtend-1_67:4.8
	SprExtend-1_66:4.8
	SprExtend-1_65:4.8
	SprExtend-1_64:4.8
	SprExtend-1_63:4.8
	SprExtend-1_62:4.8
	SprExtend-1_61:4.8
	SprExtend-1_60:4.8
	SprExtend-1_59:4.8
	SprExtend-1_58:4.8
	SprExtend-1_57:4.8
	SprExtend-1_56:4.8
	SprExtend-1_55:4.8
	SprExtend-1_54:4.8
	SprExtend-1_53:4.8
	SprExtend-1_52:4.8
	SprExtend-1_51:4.8
	SprExtend-1_50:4.8
	SprExtend-1_38-1_35_2_16:4.6.2.9
	SprExtend-1_49:4.7
	SprExtend-1_48:4.7
	SprExtend-1_47:4.7
	SprExtend-1_38-1_35_2_15:4.6.2.8
	SprExtend-1_46:4.6
	SprExtend-1_45:4.6
	SprExtend-1_44:4.6
	SprExtend-1_43:4.6
	SprExtend-1_42:4.6
	SprExtend-1_41:4.6
	SprExtend-1_38-1_35_2_14:4.6.2.8
	SprExtend-1_40:4.6
	SprExtend-1_38-1_35_2_13:4.6.2.7
	SprExtend-1_38-1_35_2_12:4.6.2.6
	SprExtend-1_38-1_35_2_11:4.6.2.6
	SprExtend-1_38-1_35_2_10:4.6.2.6
	SprExtend-1_38-1_35_2_9:4.6.2.5
	SprExtend-1_38-1_35_2_8:4.6.2.4
	SprExtend-1_39:4.6
	SprExtend-1_38-1_35_2_7:4.6.2.4
	SprExtend-1_38-1_35_2_6:4.6.2.4
	SprExtend-1_38-1_35_2_5:4.6.2.3
	SprExtend-1_38-1_35_2_4:4.6.2.3
	SprExtend-1_38-1_35_2_3:4.6.2.2
	SprExtend-1_38-1_35_2_2:4.6.2.1
	SprExtend-1_38-1_35_2_1:4.6.2.1
	MigrateIJG8b:4.6.0.2
	SprExtend-1_38:4.6
	SprExtend-1_37:4.6
	SprExtend-1_36:4.6
	SprExtend-1_35:4.6
	SprExtend-1_34:4.6
	SprExtend-1_33:4.6
	SprExtend-1_32:4.6
	SprExtend-1_31:4.5
	SprExtend-1_30:4.5
	SprExtend-1_29:4.5
	SprExtend-1_28:4.5
	SprExtend-1_27:4.4
	SprExtend-1_26:4.4
	SprExtend-1_25:4.4
	SprExtend-1_24:4.4
	SprExtend-1_23:4.4
	SprExtend-1_22:4.4
	SprExtend-1_21:4.4
	SprExtend-1_20:4.4
	SprExtend-1_19:4.4
	SprExtend-1_18:4.4
	SprExtend-1_17:4.4
	RO_5_07:4.4
	SprExtend-1_16:4.4
	SprExtend-1_15:4.4
	SprExtend-1_14:4.4
	SprExtend-1_13:4.4
	SprExtend-1_12:4.3
	SprExtend-1_11:4.3
	SprExtend-1_10:4.3
	SprExtend-1_09:4.3
	SprExtend-1_08:4.3
	dellis_autobuild_BaseSW:4.2
	SprExtend-1_07:4.2
	SprExtend-1_06:4.2
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.3
	SprExtend-1_05:4.1
	Ursula_merge:4.1
	nturton_SprExtend-1_04:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.9
date	2016.05.21.13.44.33;	author rool;	state dead;
branches;
next	4.8;
commitid	ZDqmsyNiMhv6Zl7z;

4.8
date	2012.07.28.15.23.38;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	b5jdybqzJ3Wdjlew;

4.7
date	2011.10.03.20.35.14;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	jlqGNWSdKaK0EWBv;

4.6
date	2010.10.13.20.26.17;	author rsprowson;	state Exp;
branches
	4.6.2.1;
next	4.5;

4.5
date	2010.09.25.12.19.17;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2002.12.02.20.35.36;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2001.05.15.10.57.00;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	2000.05.12.12.59.07;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.45.14;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.6.2.1
date	2011.01.04.21.23.44;	author rsprowson;	state Exp;
branches;
next	4.6.2.2;

4.6.2.2
date	2011.01.04.21.36.56;	author rsprowson;	state Exp;
branches;
next	4.6.2.3;

4.6.2.3
date	2011.01.04.21.45.26;	author rsprowson;	state Exp;
branches;
next	4.6.2.4;

4.6.2.4
date	2011.01.09.10.42.55;	author rsprowson;	state Exp;
branches;
next	4.6.2.5;

4.6.2.5
date	2011.01.22.17.58.26;	author rsprowson;	state Exp;
branches;
next	4.6.2.6;

4.6.2.6
date	2011.01.22.18.01.46;	author rsprowson;	state Exp;
branches;
next	4.6.2.7;

4.6.2.7
date	2011.02.05.09.56.50;	author rsprowson;	state Exp;
branches;
next	4.6.2.8;

4.6.2.8
date	2011.02.15.20.57.58;	author rsprowson;	state Exp;
branches;
next	4.6.2.9;

4.6.2.9
date	2012.07.28.14.42.48;	author rsprowson;	state Exp;
branches;
next	;
commitid	Ny6vV3CHXwee5lew;

4.1.1.1
date	96.11.05.09.45.14;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.42.15;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.58.16;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.20.50;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.9
log
@Import of IJG8d library sources
Detail:
  Using the decoder in "example.c" as a starting point, we try to follow that sequence more closely even if in our embedded implementation some of the functions don't do much.
  Uses the default colour backend for 32bpp BGR output for most of the unusual cases.
  The most common 2x2 subsampling case uses a custom merged upsampler and colour converter, with colour output directly in RISC OS format for the respective screen mode.
Admin:
  Submission for the JPEG bounty.

Version 1.71. Tagged as 'SprExtend-1_71'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; Assembler decoding of huffman stream.

;   21-Sep-93 WRS - started.
;   29-Oct-93 WRS - handling of EOI marker added, usage found in ONE JPEG file
;                   among hundreds (xuxa2/jpg, I think it was).
;   09-Nov-93 WRS - tried a few speedups:
;                     write out the fill_her_up loop in main AC-fetch loop
;                     swap args of MUL to avoid late termination for -ve args
;                   could also try:
;                     zag array deserves a register (would save 1)
;                   But, no measurable effect so regressed to previous version.

; Structure/algorithm generally follows that of the Indep JPEG gp's release 4 code,
; except that an additional lookup table is used to decode huffman codes up to
; 8 bits big in a single step. Some of the comments in this assembler refer to
; variable names etc. in the IJG4 C code.

; Reading the huffman stream, and skipping over it without generating an answer,
; are separated into two routines to speed up the skipping operation.

        GET     jhdr.s

h_temp     RN      0
h_temp2    RN      1
h_temp3    RN      2
h_inptr    RN      3
h_inword   RN      4
h_incount  RN      5
h_maxcode  RN      6      ; points into huff tables
h_huffval  RN      7      ; points into huff tables
h_shortcut RN      8      ; points into huff tables
h_quanttbl RN      9
h_block    RN      10
h_k        RN      11
h_topbit   RN      12
h_code     RN      1      ; used in huff_decode - same as temp2
h_l        RN      2      ; used in huff_decode - same as temp3

; --------------------------------------------------------------------
; Accessing a HUFF_TBL structure.

        MACRO
        HUFF_DECODE_SETUP $tbl
        ; set up the specific table pointers for ac or dc huff table
        ; $tbl is a HUFF_TBL*.
        ADD     h_maxcode,$tbl,#huff_tbl_maxcode
        ADD     h_shortcut,$tbl,#huff_tbl_shortcut
        ADD     h_huffval,$tbl,#huff_tbl_huffval
        MEND

; -------------------------------------------------------------------
; Bit extraction.

        MACRO
        Huff_getbits $n
; get $n bits, put them into h_temp sign extended.
; there are h_incount bits left at the TOP of h_inword
; Potentially corrupts h_temp2, h_temp3, lr.
; $n CAN be h_temp.
;
; Having fetched the bits we must 'sign extend' them according to:
; #define huff_EXTEND(x, s)       ((x) < (1 << ((s)-1)) ? \             ; semicolons to stop warnings
;                                  (x) + (-1 << (s)) + 1 : \            ; only!  Remove these three
;                                  (x))                                 ; if you want the macro!!!
; ie top bit set -> stays unaltered
;             else, set all bits above and add 1
; (this is because we KNOW the top bit is significant, so simple sign extension
; would waste possible combinations.)
;
        CMP     h_incount,$n                           ; we're about to take the top n bits of inword
        BLLT    huff_fill_her_up                       ; make sure inword has at least n bits
        RSB     h_temp2,$n,#32                         ; get ready for shifts by 32-n
        SUB     h_incount,h_incount,$n                 ; update incount for what you're taking
        ; do the 'sign extend'
        EOR     h_temp3,h_inword,h_topbit              ; invert top bit
        MOV     h_inword,h_inword,LSL $n               ; get rid of those bits from inword
        MOVS    h_temp3,h_temp3,ASR h_temp2            ; now sign extend
        EOR     h_temp,h_temp3,h_topbit, LSR h_temp2   ; invert that bit again
        ADDLT   h_temp,h_temp,#1                       ; if it was negative, add one.
        ; that's it - result in h_temp.
        MEND

        MACRO
        Huff_skipbits $n
; Exactly like Huff_getbits, but we are not interested in the answer.
; Used for skipping forward in the huffman stream.
        CMP     h_incount,$n                           ; we're about to take the top n bits of inword
        BLLT    huff_fill_her_up                       ; make sure inword has at least n bits
        SUB     h_incount,h_incount,$n                 ; update incount for what you're taking
        MOV     h_inword,h_inword,LSL $n               ; get rid of those bits from inword
        MEND

; To fill up h_inword with at least 24 bits of input.
; DO NOT CALL if h_incount already >= 24.
; Corrupts h_temp2, h_temp3, lr but NOT h_temp.
huff_fill_her_up
        LDRB    h_temp3,[h_inptr],#1
        ADD     h_incount,h_incount,#8                ; get another 8 bits
        ORR     h_inword,h_inword,h_temp3,ROR h_incount ; combine into inword
        CMP     h_temp3,#255                          ; check for stuffed byte
        BEQ     huff_check_stuff_byte
huff_checked_stuff_byte
        CMP     h_incount,#24                         ; since we're here, do as many as poss.
        BLE     huff_fill_her_up
        MOV     pc,lr

huff_check_stuff_byte
        LDRB    h_temp3,[h_inptr],#1
        CMP     h_temp3,#0
        BEQ     huff_checked_stuff_byte

; It COULD be a restart marker - FFs and then one of RST0..RST7, (&D0..&D7).
; If this is found then don't read it, but return from huff_fill_her_up without
; filling it as much as was requested.
; If this is a well-formed stream then we won't actually need more than there
; are before the restart marker appears.
        MOV     h_temp2,#255
        EOR     h_inword,h_inword,h_temp2,ROR h_incount ; remove the 255 from the input buffer.
        SUB     h_incount,h_incount,#8                  ; remove the bits from the count in bits_left
        SUB     h_temp2,h_inptr,#2                      ; remember start pos in input stream.
huff_check_restart_loop
        CMP     h_temp3,#255                            ; more 255s are legal at this point.
        LDREQB  h_temp3,[h_inptr],#1                    ; if found, try next byte
        BEQ     huff_check_restart_loop                 ; and go round
        CMP     h_temp3,#&D9                            ; EOI (end of image) marker?
        ANDNE   h_temp3,h_temp3,#&F8                    ; else, only check top bits:
        CMPNE   h_temp3,#&D0                            ; is it a restart marker?
        MOVEQ   h_inptr,h_temp2                         ; if so, set h_temp2 as if nothing had happened
        MOVEQ   pc,lr                                   ; and return.

; Looks like bad data. There's just one other possibility, that
; we're at the very end of the input data and that this part will
; never actually be read (we are reading ahead a byte or two, after all).
; So, check for the end of the input buffer and if beyond it, keep quiet
; (trusting that the data will never be used).
        LDR     h_temp2,[sp,#0]                       ; ...cinfo
        LDR     h_temp3,[h_temp2,#cinfo_jpeg_buffer]  ; ...cinfo->jpeg_buffer
        LDR     h_temp2,[h_temp2,#cinfo_jpeg_size]    ; ...cinfo->jpeg_size
        ADD     h_temp2,h_temp3,h_temp2
        SUB     h_temp2,h_temp2,#8                    ; in case buffer_end padded up to mul of 4
        CMP     h_temp2,h_inptr                       ; have we read past the end?
        MOVLT   pc,lr                                 ; if so then return - we've got enough
        B       huff_bad_stuff_byte                   ; panic exit, bad data

; -------------------------------------------------------------------
; Decoding the huffman stream.

; Decode a symbol from the input stream - answer in h_temp.
; Potentially corrupts h_temp2, h_temp3, lr.
        MACRO
        Huff_decode $lab
        CMP     h_incount,#8
        BLLT    huff_fill_her_up                   ; ensure h_inword has enough bits for a shortcut-derived answer

; try the shortcut table
        MOV     h_temp3,h_inword,LSR #24           ; get next 8 bits of input
        LDR     h_temp3,[h_shortcut,h_temp3,LSL #2] ; get shortcut value
        ; the shortcut value is in h_temp3 - top byte is number of bits, rest is value
        BIC     h_temp,h_temp3,#&ff000000          ; the answer in h_temp
        MOVS    h_temp3,h_temp3,ASR #24            ; the number of bits we've used
        BLT     huff_noshortcut$lab                ; the shortcut entry was -ve - no shortcut.
        SUB     h_incount,h_incount,h_temp3        ; set h_incount correctly
        MOV     h_inword,h_inword,LSL h_temp3      ; the bit source
huff_decodeexit$lab
; the value is in 'temp' - return.
        MEND

        MACRO
        Huff_decode_leftovers $lab
huff_noshortcut$lab
        ; According to some stuff on the net, this happens for 3-4% of the huffman codes.
        ; the incoming value is at least 8 bits - could avoid going round the loop first 8 times,
        ; instead of setting h_code and h_l to 0.
        CMP     h_incount,#16
        BLLT    huff_fill_her_up                   ; ensure h_inword has enough bits
        MOV     h_l,#8                             ; as though we've been round 8 times already
        MOV     h_code,h_inword,LSR #24            ; first 8 bits
        MOV     h_inword,h_inword,LSL #8           ; shift input by 8 bits - inword done at the end.

;        ; don't use the shortcut table - all the way round the loop.
;        MOV     h_code,#0                          ; loop initialise
;        MOV     h_l,#0

huff_decode_loop$lab
        MOVS    h_inword,h_inword,LSL #1
        ADC     h_code,h_code,h_code               ; code = (code << 1) + get_bit(cinfo);
        ADD     h_l,h_l,#1                         ; l++;
        LDR     h_temp,[h_maxcode,h_l,LSL #2]      ; ...htbl->maxcode[l]
        CMP     h_code,h_temp                      ; while (code > htbl->maxcode[l])
        BGT     huff_decode_loop$lab               ;    ... loop

; check for garbage input
        CMP     h_l,#16
        BGT     huff_badinput

; do the final table lookups.
        ADD     h_temp,h_shortcut,#huff_tbl_valptr-huff_tbl_shortcut ; get valptr table
        LDR     h_temp,[h_temp,h_l,LSL #2]        ; do lookup in valptr table
        ADD     h_temp,h_temp,h_code
        LDRB    h_temp,[h_huffval,h_temp]

; advance in the bit stream
        SUB     h_incount,h_incount,h_l

; we've finished, return to the main stream
        B       huff_decodeexit$lab
        MEND

; --------------------------------------------------------------------
        EXPORT  asm_huff_decode_blocks
asm_huff_decode_blocks
;LOCAL void
;huff_decode_blocks (decompress_info_ptr cinfo, JBLOCK block,
;                    HUFF_TBL *dctbl, HUFF_TBL *actbl,
;                    QUANT_TBL_PTR quanttbl, int *last_dc_val, int nblocks)
;  r0 = cinfo
;  r1 = block pointer
;  r2 = HUFF_TBL* dctbl
;  r3 = HUFF_TBL* actbl
;  [sp] = quanttbl
;  [sp,#4] = int *last_dc_val
;  [sp,#8] = int nblocks

; save registers
        STMDB   sp!,{r0-r12,lr}
        ; args 0..3 are at sp
        ; args 4..6 are at [sp,#14*4..16*4]

; if nblocks<=0, return
        LDR     r2,[sp,#16*4]                    ; get nblocks
        CMP     r2,#0                            ; if <=0
        LDMLEIA sp!,{r0-r12,pc}                  ; then return

; paranoid search for nondeterministic results
        MOV     r3,#0
        MOV     lr,#0

; clear out the target block(s) - r1 is the block pointer
        LDR     r2,[sp,#16*4]           ; nblocks
        MOV     r4,#0                   ; get ready to clear the block
        MOV     r5,#0
        MOV     r6,#0
        MOV     r7,#0
        MOV     r8,#0
        MOV     r9,#0
        MOV     r10,#0
        MOV     r11,#0
huff_block_clear
        STMIA   r1!,{r4,r5,r6,r7,r8,r9,r10,r11}
        STMIA   r1!,{r4,r5,r6,r7,r8,r9,r10,r11}
        STMIA   r1!,{r4,r5,r6,r7,r8,r9,r10,r11}
        STMIA   r1!,{r4,r5,r6,r7,r8,r9,r10,r11}
        STMIA   r1!,{r4,r5,r6,r7,r8,r9,r10,r11}
        STMIA   r1!,{r4,r5,r6,r7,r8,r9,r10,r11}
        STMIA   r1!,{r4,r5,r6,r7,r8,r9,r10,r11}
        STMIA   r1!,{r4,r5,r6,r7,r8,r9,r10,r11}
        SUBS    r2,r2,#1
        BNE     huff_block_clear
; Now scratch all registers except r0=h_temp=cinfo.

; now set up registers for the main procedure.
; r0=h_temp=cinfo
        LDR     h_inptr,[h_temp,#cinfo_next_input_byte]
        LDR     h_inword,[h_temp,#cinfo_get_buffer]
        LDR     h_incount,[h_temp,#cinfo_bits_left]
        LDR     h_quanttbl,[sp,#14*4]
        ADD     h_quanttbl,h_quanttbl,#64*4      ; indexed from the end, to make termination testing faster
        LDR     h_block,[sp,#4]
        MOV     h_topbit,#&80000000

huff_anotherblock                                ; loop round to here nblocks times

; Set up huffman decoding for the DC component.
        LDR     h_temp,[sp,#2*4]                 ; HUFF_TBL* dctbl    (DC table pointer)
        HUFF_DECODE_SETUP h_temp                 ; set maxcode,huffval,shortcut

; Handle the DC component
        Huff_decode 0                            ; h_temp = s = huff_DECODE(cinfo, dctbl);
        CMP     h_temp,#0                        ; if (s)
        BEQ     huff_dc_0
        Huff_getbits h_temp                      ; h_temp counts the bits, result in h_temp
                                                 ; s = huff_EXTEND(get_bits(cinfo, s), s);
huff_dc_0
        ; h_temp holds the delta to the DC value for this block
        ; Create the absolute DC value
        LDR     h_temp3,[sp,#15*4]               ; int *last_dc_val
        LDR     h_temp2,[h_temp3]                ; ...*last_dc_val
        ADD     h_temp2,h_temp,h_temp2           ; s += *last_dc_val;
        STR     h_temp2,[h_temp3]                ; and write *last_dc_val back
        ; Now multiply by the quantisation value, and store in the block
        LDR     h_temp3,[h_quanttbl,#-64*4]      ; ...quanttbl[0]
        MUL     h_temp,h_temp2,h_temp3           ; ...s * quanttbl[0]

; >>>> hack for experimental DCT code, which wants shifted-up inputs
;        MOV     h_temp,h_temp,LSL #16

        STR     h_temp,[h_block]                 ; block[0] = (JCOEF) (((JCOEF) s) * quanttbl[0]);
        ; That's the DC value done.

; Set up huffman decoding for the AC components.
        LDR     h_temp,[sp,#3*4]                 ; HUFF_TBL* actbl    (AC table pointer)
        HUFF_DECODE_SETUP h_temp                 ; set maxcode,huffval,shortcut

; The loop that does AC components, once round for each non-zero component.
        MOV     h_k,#-63                         ; index into block
huff_loop
        Huff_decode 1                            ; result in r (ie h_temp)

        MOV     h_temp2,h_temp,LSR #4            ; n = r >> 4;
        ANDS    h_temp,h_temp,#15                ; s = r & 15;
        BEQ     huff_else                        ; if (s) {
        ADD     h_k,h_k,h_temp2                  ;   k += n;
        Huff_getbits h_temp                      ;   s = huff_EXTEND(get_bits(cinfo, s), s); in h_temp
        LDR     h_temp2,[h_quanttbl,h_k,LSL #2]  ;   ... quanttbl[k]
        MUL     h_temp,h_temp2,h_temp            ;   ... s * quanttbl[k]
        ADR     h_temp2,huff_zag_end
        LDRB    h_temp2,[h_temp2,h_k]            ;   ... ZAG[k]

; >>>> hack for experimental DCT code, which wants shifted-up inputs
;        MOV     h_temp,h_temp,LSL #16

        STR     h_temp,[h_block,h_temp2,LSL #2]  ;   block[ZAG[k]] = (JCOEF) (((JCOEF) s) * quanttbl[k]);
        ADDS    h_k,h_k,#1
;        CMP     h_k,#63
        BLT     huff_loop
        B       huff_exit
huff_else                                        ; } else {
        CMP     h_temp2,#15                      ;   if (n != 15)
        BNE     huff_exit                        ;     break;
        ADDS    h_k,h_k,#16                      ;   k += 15;     (and 1 for the for loop)
;        CMP     h_k,#63
        BLT     huff_loop
huff_exit
; That block is completed now.

; Have we done enough blocks? If not, do another.
        ADD     h_block,h_block,#64*4                    ; advance block pointer
        LDR     h_temp,[sp,#16*4]                        ; get nblocks
        SUBS    h_temp,h_temp,#1                         ; decrement it
        STRNE   h_temp,[sp,#16*4]                        ; if not zero, save new value
        BNE     huff_anotherblock                        ;           ...and loop.

; We are going to exit.
; Save the state of the huff stream, and return.
        LDR     h_temp,[sp]                              ; cinfo
        STR     h_inptr,[h_temp,#cinfo_next_input_byte]  ; save state of input bit stream
        STR     h_inword,[h_temp,#cinfo_get_buffer]
        STR     h_incount,[h_temp,#cinfo_bits_left]
        LDMIA   sp!,{r0-r12,pc}                          ; exit

; --------------------------------------------------------------------
; The zig-zag reordering table - the coefficients are actually provided
; in a zig-zag ordering to maximise the length of runs of 0, this table
; descrambles this order.
huff_zag
        DCB      0,  1,  8, 16,  9,  2,  3, 10
        DCB     17, 24, 32, 25, 18, 11,  4,  5
        DCB     12, 19, 26, 33, 40, 48, 41, 34
        DCB     27, 20, 13,  6,  7, 14, 21, 28
        DCB     35, 42, 49, 56, 57, 50, 43, 36
        DCB     29, 22, 15, 23, 30, 37, 44, 51
        DCB     58, 59, 52, 45, 38, 31, 39, 46
        DCB     53, 60, 61, 54, 47, 55, 62, 63
huff_zag_end
        DCB      0,  0,  0,  0,  0,  0,  0,  0  ;extra entries in case k>63
        DCB      0,  0,  0,  0,  0,  0,  0,  0

; --------------------------------------------------------------------
        EXPORT  asm_huff_skip_blocks
asm_huff_skip_blocks
;LOCAL void
;huff_skip_blocks (decompress_info_ptr cinfo, JBLOCK block,
;                  HUFF_TBL *dctbl, HUFF_TBL *actbl,
;                  QUANT_TBL_PTR quanttbl, int *last_dc_val, int nblocks)
;  r0 = cinfo
;  r1 = block pointer             (UNUSED)
;  r2 = HUFF_TBL* dctbl
;  r3 = HUFF_TBL* actbl
;  [sp] = quanttbl                (UNUSED)
;  [sp,#4] = int *last_dc_val
;  [sp,#8] = int nblocks
; This routine is very similar to huff_decode_blocks, except that
; we do not actually output the block - we simply skip forward that far
; in the huffman stream, updating last_dc_val correctly.

; save registers
        STMDB   sp!,{r0-r12,lr}
        ; args 0..3 are at sp
        ; args 4..6 are at [sp,#14*4..16*4]

; now set up registers for the main procedure.
; r0=h_temp=cinfo
        LDR     h_inptr,[h_temp,#cinfo_next_input_byte]
        LDR     h_inword,[h_temp,#cinfo_get_buffer]
        LDR     h_incount,[h_temp,#cinfo_bits_left]
        MOV     h_topbit,#&80000000

; if nblocks<=0, return
        LDR     h_temp2,[sp,#16*4]               ; get nblocks
        CMP     h_temp2,#0                       ; if <=0
        LDMLEIA sp!,{r0-r12,pc}                  ; then return

huff_skip_anotherblock                           ; loop round to here nblocks times

; Set up huffman decoding for the DC component.
        LDR     h_temp,[sp,#2*4]                 ; HUFF_TBL* dctbl    (DC table pointer)
        HUFF_DECODE_SETUP h_temp                 ; set maxcode,huffval,shortcut

; Handle the DC component
        Huff_decode 2                            ; h_temp = s = huff_DECODE(cinfo, dctbl);
        CMP     h_temp,#0                        ; if (s)
        BEQ     huff_skip_dc_0
        Huff_getbits h_temp                      ; h_temp counts the bits, result in h_temp
                                                 ; s = huff_EXTEND(get_bits(cinfo, s), s);
huff_skip_dc_0
        ; h_temp holds the delta to the DC value for this block
        ; Create the absolute DC value
        LDR     h_temp3,[sp,#15*4]               ; int *last_dc_val
        LDR     h_temp2,[h_temp3]                ; ...*last_dc_val
        ADD     h_temp2,h_temp,h_temp2           ; s += *last_dc_val;
        STR     h_temp2,[h_temp3]                ; and write *last_dc_val back
        ; ... and throw the value away
        ; That's the DC value done.

; Set up huffman decoding for the AC components.
        LDR     h_temp,[sp,#3*4]                 ; HUFF_TBL* actbl    (AC table pointer)
        HUFF_DECODE_SETUP h_temp                 ; set maxcode,huffval,shortcut

; The loop that does AC components, once round for each non-zero component.
        MOV     h_k,#-63                         ; index into block
huff_skip_loop
        Huff_decode 3                            ; result in r (ie h_temp)
        MOV     h_temp2,h_temp,LSR #4            ; n = r >> 4;
        ANDS    h_temp,h_temp,#15                ; s = r & 15;
        BEQ     huff_skip_else                   ; if (s) {
        ADD     h_k,h_k,h_temp2                  ;   k += n;
        Huff_skipbits h_temp                     ;   s = huff_EXTEND(get_bits(cinfo, s), s); in h_temp
                                                 ; ... and throw the value away.
        ADDS    h_k,h_k,#1
        BLT     huff_skip_loop
        B       huff_skip_exit
huff_skip_else                                   ; } else {
        CMP     h_temp2,#15                      ;   if (n != 15)
        BNE     huff_skip_exit                   ;     break;
        ADDS    h_k,h_k,#16                      ;   k += 15;     (and 1 for the for loop)
        BLT     huff_skip_loop
huff_skip_exit
; That block is completed now.

; Have we done enough blocks? If not, do another.
        LDR     h_temp,[sp,#16*4]                        ; get nblocks
        SUBS    h_temp,h_temp,#1                         ; decrement it
        STRNE   h_temp,[sp,#16*4]                        ; if not zero, save new value
        BNE     huff_skip_anotherblock                   ;           ...and loop.

; We are going to exit.
; Save the state of the huff stream, and return.
        LDR     h_temp,[sp]                              ; cinfo
        STR     h_inptr,[h_temp,#cinfo_next_input_byte]  ; save state of input bit stream
        STR     h_inword,[h_temp,#cinfo_get_buffer]
        STR     h_incount,[h_temp,#cinfo_bits_left]
        LDMIA   sp!,{r0-r12,pc}                          ; exit

        Huff_decode_leftovers 0
        Huff_decode_leftovers 1
        Huff_decode_leftovers 2
        Huff_decode_leftovers 3

; -------------------------------------------------------------------
; Errors in the input stream.
; Should really construct an error message, for the moment do a panic exit.
; We reload the registers to get things like sl back, which gets us the
; module wp again.

huff_bad_stuff_byte
        ; attempt to get details out there of what the situation was when we went wrong.
        SUB     sp,sp,#16*4
        STMDB   sp,{r0-r12}                              ; dump ALL the registers.
        ADD     r2,sp,#16*4
        STR     r2,[sp,#13*4]
        STR     lr,[sp,#14*4]
        STR     pc,[sp,#15*4]
        MOV     r2,#124                                  ; r2 = panic type
        B       huff_panic_exit                          ; join common code
huff_badinput
        ; attempt to get details out there of what the situation was when we went wrong.
        SUB     sp,sp,#16*4
        STMDB   sp,{r0-r12}                              ; dump ALL the registers.
        ADD     r2,sp,#16*4
        STR     r2,[sp,#13*4]
        STR     lr,[sp,#14*4]
        STR     pc,[sp,#15*4]
        MOV     r2,#123                                  ; r2 = panic type
        ; Fall through
huff_panic_exit
        ADD     r3,sp,#16*4+4*4                          ; point at original saved registers, except r0-r3
        LDMIA   r3,{r4-r12}                              ; restore registers that C wants
        LDR     r0,[r3,#-16]                             ; r0 = cinfo
        MOV     r1,sp                                    ; r1 -> saved register block
        
        BL      panic_trace                              ; call dump routine, written in C
        ADD     sp,sp,#16*4                              ; set sp back to what it was

        LDMIA   sp!,{r1-r12,lr}                          ; restore entry registers (and junk r0)
        MOV     r0,#2                                    ; this is ERROR_BAD_JPEG
        B       exit

        END
@


4.8
log
@Adopt colour conversions from MigrateIJG8b branch
Now for every colour conversion there is a corresponding C function, allowing swapping between them for test purposes.
Here, 'ASMCOLOR' is selected and the C functions not even referenced in the makefile, see branch for use.
Permits use of USAT, for a small 1.5% speedup and smaller code.
Some other typedefs and comment shuffling copied over - should be harmless.

Version 1.50. Tagged as 'SprExtend-1_50'
@
text
@@


4.7
log
@Fix up some warnings from the assembler.
Transformed sprites tested briefly & still work.

Version 1.47. Tagged as 'SprExtend-1_47'
@
text
@d151 3
a153 1
        LDR     h_temp2,[h_temp2,#cinfo_buffer_end]   ; ...cinfo->buffer_end
d515 1
a515 1
        BL      assembler_panic                          ; call dump routine, written in C
@


4.6
log
@Paper and fill some JPEG cracks.
The exit_c function was repeatedly being called with the line number argument and error code the wrong way round and since only bits 0-2 of the error code are inspected on exit any fatal exits from the ported JPEG library code would either report the wrong error or fail silently (depending on the line number) - example a 12 bits per sample JPEG would be rendered without fault into a screen full of random memory garbage.
Assembling/compiling with the 'jpeg' switch off didn't work, fixed, and also now zeros out the SWI decode values in the module header.
Moved include of 'yuvtabs.s' into the colour conversion code.
Deleted panic_exit, it did nothing useful but trace a value then exit, so it now just calls exit() like everyone else.
Removed excess call to find_image_dims(), this was needed just to get the workspace requirements when the JPEG had already been sized up by asm_find_image_dims() earlier. Side effect of removing the pilot JPEG code earlier is that this call can now only get to the JPEG code from a JPEG_ SWI. Changed to just pass the workspace requirements into 'c.PutScaled' and save a duplicate scan.
Fatal exits from the assembler huffman decoder now report a sensible error.
Trimmed out all the JPEG assessment code from 'c.PutScaled' and moved it into 'c.rojpeg' so the put scaled is only concerned with putting things scaled.
Sanitised the #includes a bit.
Fixed on last check of wp->save_mode looking at the wrong bits for the mode number.
Resolved all the warning in the genhdr/genyuvtabs/genpalette utilities by casting a bit harder.[A[B
Added new more descriptive error messages to the messages file (not currently used), and made the 'not supported by' ones consistent so the tokeniser might crunch the file a bit more.
In looks_like_jpeg() changed a bitwise to logical or.
Fixed longstanding problem of not being able to render JPEGs at a scale of less than 1/6 in any greyscale mode, because, err, there was no code to do it - only the colour case was checked for. Implemented for 8bpp grey and 32bpp grey (which gets dithered for other lower modes) by just converting the luma channel into an equally weighted RGB value or replicating it for 256 greys.
Tested in all 8 colour depths on a Risc PC using sampling ratios of 1x1; 2x1; 1x2; 2x2 of the IJG test image scaled in !Draw by 0.16.

Version 1.32. Tagged as 'SprExtend-1_32'
@
text
@d486 11
a497 1

d500 1
a500 1
        STMDB   sp,{r0-lr,pc}                            ; dump ALL the registers.
d503 2
d506 1
d512 1
d516 1
a516 1
        LDMIA   sp!,{r0-r12,lr}                          ; restore entry registers
a519 9
huff_bad_stuff_byte
        ; attempt to get details out there of what the situation was when we went wrong.
        SUB     sp,sp,#16*4
        STMDB   sp,{r0-lr,pc}                            ; dump ALL the registers.
        ADD     r2,sp,#16*4
        STR     r2,[sp,#13*4]
        MOV     r2,#124                                  ; r2 = panic type
        B       huff_panic_exit                          ; join common code

@


4.6.2.1
log
@Bulk search & replace to use 8b headers.
Highlighted that last_dc_val should have been a JCOEF * not an int *.
Still works - amazing!

Version 1.38, 1.35.2.1. Tagged as 'SprExtend-1_38-1_35_2_1'
@
text
@d59 1
a59 1
        ; $tbl is a JHUFF_TBL*.
d224 4
a227 3
;huff_decode_blocks (j_decompress_ptr cinfo, JBLOCK block,
;                    JHUFF_TBL *dctbl, JHUFF_TBL *actbl,
;                    JQUANT_TBL *quanttbl, JCOEF *last_dc_val, int nblocks)
d230 4
a233 4
;  r2 = JHUFF_TBL *dctbl
;  r3 = JHUFF_TBL *actbl
;  [sp,#0] = quanttbl
;  [sp,#4] = JCOEF *last_dc_val
d286 1
a286 1
        LDR     h_temp,[sp,#2*4]                 ; JHUFF_TBL* dctbl    (DC table pointer)
d313 1
a313 1
        LDR     h_temp,[sp,#3*4]                 ; JHUFF_TBL* actbl    (AC table pointer)
d383 4
a386 3
;huff_skip_blocks (j_decompress_ptr cinfo, JBLOCK block,
;                  JHUFF_TBL *dctbl, JHUFF_TBL *actbl,
;                  JQUANT_TBL *quanttbl, JCOEF *last_dc_val, int nblocks)
d389 4
a392 4
;  r2 = JHUFF_TBL *dctbl
;  r3 = JHUFF_TBL *actbl
;  [sp,#0] = quanttbl             (UNUSED)
;  [sp,#4] = JCOEF *last_dc_val
d418 1
a418 1
        LDR     h_temp,[sp,#2*4]                 ; JHUFF_TBL* dctbl    (DC table pointer)
d438 1
a438 1
        LDR     h_temp,[sp,#3*4]                 ; JHUFF_TBL* actbl    (AC table pointer)
@


4.6.2.2
log
@Reinstate C code version of jdhuff.
In huff_decode_blocks the block pointer wasn't being incremented, as it was in the assembler.
Useful for speed comparisons.

Version 1.38, 1.35.2.3. Tagged as 'SprExtend-1_38-1_35_2_3'
@
text
@d297 1
a297 1
        LDR     h_temp3,[sp,#15*4]               ; JCOEF *last_dc_val
d302 2
a303 2
        LDR     h_temp3,[h_quanttbl,#-64*4]      ; ...quanttbl->quanttbl[0]
        MUL     h_temp,h_temp2,h_temp3           ; ...s * quanttbl->quantval[0]
d305 4
a308 1
        STR     h_temp,[h_block]                 ; block[0] = (JCOEF) (((JCOEF) s) * quanttbl->quantval[0]);
d325 2
a326 2
        LDR     h_temp2,[h_quanttbl,h_k,LSL #2]  ;   ... quanttbl->quanttbl[k]
        MUL     h_temp,h_temp2,h_temp            ;   ... s * quanttbl->quantval[k]
d330 4
a333 1
        STR     h_temp,[h_block,h_temp2,LSL #2]  ;   block[ZAG[k]] = (JCOEF) (((JCOEF) s) * quanttbl->quantval[k]);
d428 1
a428 1
        LDR     h_temp3,[sp,#15*4]               ; JCOEF *last_dc_val
@


4.6.2.3
log
@Reinstate jrevdct4 option to use C code IDCT (switch "ASMIDCT").
Name inverse DCT to match IJG 8b integer fast implementation.
Remove -DEMBED option and collapse switches.
Useful for speed comparisons.

Version 1.38, 1.35.2.4. Tagged as 'SprExtend-1_38-1_35_2_4'
@
text
@d15 1
a15 1
; > Sources.jdhuff
a16 1
; Assembler decoding of huffman stream.
@


4.6.2.4
log
@Create assembler equivalents of C colour conversions, approx 10% speed up.
Add new switch ASMCOLOR to select which to use, C or assembler.
Remove FILE_ exit trace concept, just use __FILE__ instead in exit_erl.
Add some comments to exit_erl and friends.
A few bits of cinfo setup moved into start_pass_huff_decoder() or eliminated.
Bumped up the precision of SCALE_BITS in the C colour handling so FIX() uses more bits of an int.
Deleted the unused remenants of light dithering in the 8bpp colour converter - saves a few cycles.
colour_convert_8 and colour_convert_16 no longer save entry registers the C compiler doesn't care about.
Update genyuvtabs to EXPORT the table bases.
Split out the compilation of IJG files as separate objects in the make file, rather than including them from within rojpeg, which is itself included from putscaled.

Version 1.38, 1.35.2.6. Tagged as 'SprExtend-1_38-1_35_2_6'
@
text
@d492 1
a492 1
        BL      panic_trace                              ; call dump routine, written in C
@


4.6.2.5
log
@New jerror.h taken from IJG8b.
Swap to using JERR_ numbers, deleted E_ numbers.
Modify genjhdr to pass some defines to the assembler code, so jdcolor can clarify use of DCTSIZE and DCTSIZE2.
Added chart of possible subsampling ratios to documentation.

Version 1.38, 1.35.2.9. Tagged as 'SprExtend-1_38-1_35_2_9'
@
text
@d17 11
a27 11
; Decoding of huffman stream, see also the contents of c.jdhuff.
; 21-Sep-93 - started.
; 29-Oct-93 - handling of EOI marker added, usage found in ONE JPEG file
;             among hundreds (xuxa2/jpg, I think it was).
; 09-Nov-93 - tried a few speedups:
;               write out the fill_her_up loop in main AC-fetch loop
;               swap args of MUL to avoid late termination for -ve args
;             could also try:
;               zag array deserves a register (would save 1)
;             But, no measurable effect so regressed to previous version.
;
d32 1
a32 1
;
d36 2
d54 2
a55 3
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Accessing a HUFF_TBL structure
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d66 2
a67 3
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Bit extraction
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d71 18
a88 18
        ; get $n bits, put them into h_temp sign extended.
        ; there are h_incount bits left at the TOP of h_inword
        ; Potentially corrupts h_temp2, h_temp3, lr.
        ; $n CAN be h_temp.
        ;
        ; Having fetched the bits we must 'sign extend' them according to:
        ; #define huff_EXTEND(x, s)       ((x) < (1 << ((s)-1)) ? \             ; semicolons to stop warnings
        ;                                  (x) + (-1 << (s)) + 1 : \            ; only!  Remove these three
        ;                                  (x))                                 ; if you want the macro!!!
        ; ie top bit set -> stays unaltered
        ;             else, set all bits above and add 1
        ; (this is because we KNOW the top bit is significant, so simple sign extension
        ; would waste possible combinations.)
        ;
        CMP     h_incount,$n                            ; we're about to take the top n bits of inword
        BLLT    huff_fill_her_up                        ; make sure inword has at least n bits
        RSB     h_temp2,$n,#32                          ; get ready for shifts by 32-n
        SUB     h_incount,h_incount,$n                  ; update incount for what you're taking
d90 5
a94 5
        EOR     h_temp3,h_inword,h_topbit               ; invert top bit
        MOV     h_inword,h_inword,LSL $n                ; get rid of those bits from inword
        MOVS    h_temp3,h_temp3,ASR h_temp2             ; now sign extend
        EOR     h_temp,h_temp3,h_topbit, LSR h_temp2    ; invert that bit again
        ADDLT   h_temp,h_temp,#1                        ; if it was negative, add one.
d100 6
a105 6
        ; Exactly like Huff_getbits, but we are not interested in the answer.
        ; Used for skipping forward in the huffman stream.
        CMP     h_incount,$n                            ; we're about to take the top n bits of inword
        BLLT    huff_fill_her_up                        ; make sure inword has at least n bits
        SUB     h_incount,h_incount,$n                  ; update incount for what you're taking
        MOV     h_inword,h_inword,LSL $n                ; get rid of those bits from inword
d108 3
a110 3
        ; To fill up h_inword with at least 24 bits of input.
        ; DO NOT CALL if h_incount already >= 24.
        ; Corrupts h_temp2, h_temp3, lr but NOT h_temp.
d113 1
a113 1
        ADD     h_incount,h_incount,#8                  ; get another 8 bits
d115 1
a115 1
        CMP     h_temp3,#255                            ; check for stuffed byte
d118 1
a118 1
        CMP     h_incount,#24                           ; since we're here, do as many as poss.
d127 5
a131 5
        ; It COULD be a restart marker - FFs and then one of RST0..RST7, (&D0..&D7).
        ; If this is found then don't read it, but return from huff_fill_her_up without
        ; filling it as much as was requested.
        ; If this is a well-formed stream then we won't actually need more than there
        ; are before the restart marker appears.
d146 11
a156 15
        ; Looks like bad data. There's just one other possibility, that
        ; we're at the very end of the input data and that this part will
        ; never actually be read (we are reading ahead a byte or two, after all).
        ; So, check for the end of the input buffer and if beyond it, keep quiet
        ; (trusting that the data will never be used).
        LDR     h_temp2,[sp,#0]                         ; ...cinfo
        LDR     h_temp2,[h_temp2,#cinfo_buffer_end]     ; ...cinfo->buffer_end
        SUB     h_temp2,h_temp2,#8                      ; in case buffer_end padded up to mul of 4
        CMP     h_temp2,h_inptr                         ; have we read past the end?
        MOVLT   pc,lr                                   ; if so then return - we've got enough
        B       huff_bad_stuff_byte                     ; panic exit, bad data

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Zig-zag reordering table
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d158 2
a159 12
jpeg_natural_order
        DCB      0,  1,  8, 16,  9,  2,  3, 10
        DCB     17, 24, 32, 25, 18, 11,  4,  5
        DCB     12, 19, 26, 33, 40, 48, 41, 34
        DCB     27, 20, 13,  6,  7, 14, 21, 28
        DCB     35, 42, 49, 56, 57, 50, 43, 36
        DCB     29, 22, 15, 23, 30, 37, 44, 51
        DCB     58, 59, 52, 45, 38, 31, 39, 46
        DCB     53, 60, 61, 54, 47, 55, 62, 63
jpeg_natural_order_end
        DCB      0,  0,  0,  0,  0,  0,  0,  0          ; extra entries in case k>63
        DCB      0,  0,  0,  0,  0,  0,  0,  0
d161 2
a162 6
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Decoding the huffman stream
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        ; Decode a symbol from the input stream - answer in h_temp.
        ; Potentially corrupts h_temp2, h_temp3, lr.
d166 1
a166 1
        BLLT    huff_fill_her_up                        ; ensure h_inword has enough bits for a shortcut-derived answer
d168 3
a170 3
        ; try the shortcut table
        MOV     h_temp3,h_inword,LSR #24                ; get next 8 bits of input
        LDR     h_temp3,[h_shortcut,h_temp3,LSL #2]     ; get shortcut value
d172 5
a176 5
        BIC     h_temp,h_temp3,#&ff000000               ; the answer in h_temp
        MOVS    h_temp3,h_temp3,ASR #24                 ; the number of bits we've used
        BLT     huff_noshortcut$lab                     ; the shortcut entry was -ve - no shortcut.
        SUB     h_incount,h_incount,h_temp3             ; set h_incount correctly
        MOV     h_inword,h_inword,LSL h_temp3           ; the bit source
d178 1
a178 1
        ; the value is in 'temp' - return.
d188 8
a195 4
        BLLT    huff_fill_her_up                        ; ensure h_inword has enough bits
        MOV     h_l,#8                                  ; as though we've been round 8 times already
        MOV     h_code,h_inword,LSR #24                 ; first 8 bits
        MOV     h_inword,h_inword,LSL #8                ; shift input by 8 bits - inword done at the end.
d199 5
a203 5
        ADC     h_code,h_code,h_code                    ; code = (code << 1) + get_bit(cinfo);
        ADD     h_l,h_l,#1                              ; l++;
        LDR     h_temp,[h_maxcode,h_l,LSL #2]           ; ...htbl->maxcode[l]
        CMP     h_code,h_temp                           ; while (code > htbl->maxcode[l])
        BGT     huff_decode_loop$lab                    ;    ... loop
d205 1
a205 1
        ; check for garbage input
d209 1
a209 1
        ; do the final table lookups.
d211 1
a211 1
        LDR     h_temp,[h_temp,h_l,LSL #2]              ; do lookup in valptr table
d215 1
a215 1
        ; advance in the bit stream
d218 1
a218 1
        ; we've finished, return to the main stream
d222 1
a222 16
        ; extern const int *jpeg_natural_order_base(void)
        EXPORT jpeg_natural_order_base
jpeg_natural_order_base
        ADR     r0,jpeg_natural_order
        MOV     pc,lr
        
        ; extern asm_huff_decode_blocks (j_decompress_ptr cinfo, JBLOCK block,
        ;                                JHUFF_TBL *dctbl, JHUFF_TBL *actbl,
        ;                                JQUANT_TBL *quanttbl, JCOEF *last_dc_val, int nblocks)
        ;   r0 = cinfo
        ;   r1 = block pointer
        ;   r2 = JHUFF_TBL *dctbl
        ;   r3 = JHUFF_TBL *actbl
        ;   [sp,#0] = quanttbl
        ;   [sp,#4] = JCOEF *last_dc_val
        ;   [sp,#8] = int nblocks
d225 10
d236 1
a236 1
        ; save registers
d241 4
a244 4
        ; if nblocks<=0, return
        LDR     r2,[sp,#16*4]                           ; get nblocks
        CMP     r2,#0                                   ; if <=0
        LDMLEIA sp!,{r0-r12,pc}                         ; then return
d246 1
a246 1
        ; paranoid search for nondeterministic results
d250 3
a252 3
        ; clear out the target block(s) - r1 is the block pointer
        LDR     r2,[sp,#16*4]                           ; nblocks
        MOV     r4,#0                                   ; get ready to clear the block
a260 1
        ASSERT  DCTSIZE=8
d271 1
a271 1
        ; Now scratch all registers except r0=h_temp=cinfo.
d273 2
a274 2
        ; now set up registers for the main procedure.
        ; r0=h_temp=cinfo
d279 1
a279 1
        ADD     h_quanttbl,h_quanttbl,#64*4             ; indexed from the end, to make termination testing faster
d283 1
a283 1
huff_anotherblock                                       ; loop round to here nblocks times
d285 7
a291 7
        ; Set up huffman decoding for the DC component.
        LDR     h_temp,[sp,#2*4]                        ; JHUFF_TBL* dctbl    (DC table pointer)
        HUFF_DECODE_SETUP h_temp                        ; set maxcode,huffval,shortcut

        ; Handle the DC component
        Huff_decode 0                                   ; h_temp = s = huff_DECODE(cinfo, dctbl);
        CMP     h_temp,#0                               ; if (s)
d293 2
a294 2
        Huff_getbits h_temp                             ; h_temp counts the bits, result in h_temp
                                                        ; s = huff_EXTEND(get_bits(cinfo, s), s);
d298 4
a301 4
        LDR     h_temp3,[sp,#15*4]                      ; JCOEF *last_dc_val
        LDR     h_temp2,[h_temp3]                       ; ...*last_dc_val
        ADD     h_temp2,h_temp,h_temp2                  ; s += *last_dc_val;
        STR     h_temp2,[h_temp3]                       ; and write *last_dc_val back
d303 4
a306 4
        LDR     h_temp3,[h_quanttbl,#-64*4]             ; ...quanttbl->quanttbl[0]
        MUL     h_temp,h_temp2,h_temp3                  ; ...s * quanttbl->quantval[0]
                                                        
        STR     h_temp,[h_block]                        ; block[0] = (JCOEF) (((JCOEF) s) * quanttbl->quantval[0]);
d309 3
a311 3
        ; Set up huffman decoding for the AC components.
        LDR     h_temp,[sp,#3*4]                        ; JHUFF_TBL* actbl    (AC table pointer)
        HUFF_DECODE_SETUP h_temp                        ; set maxcode,huffval,shortcut
d313 2
a314 2
        ; The loop that does AC components, once round for each non-zero component.
        MOV     h_k,#-DCTSIZE2+1                        ; index into block
d316 1
a316 1
        Huff_decode 1                                   ; result in r (ie h_temp)
d318 9
a326 9
        MOV     h_temp2,h_temp,LSR #4                   ; n = r >> 4;
        ANDS    h_temp,h_temp,#15                       ; s = r & 15;
        BEQ     huff_else                               ; if (s) {
        ADD     h_k,h_k,h_temp2                         ;   k += n;
        Huff_getbits h_temp                             ;   s = huff_EXTEND(get_bits(cinfo, s), s); in h_temp
        LDR     h_temp2,[h_quanttbl,h_k,LSL #2]         ;   ... quanttbl->quanttbl[k]
        MUL     h_temp,h_temp2,h_temp                   ;   ... s * quanttbl->quantval[k]
        ADR     h_temp2,jpeg_natural_order_end
        LDRB    h_temp2,[h_temp2,h_k]                   ;   ... jpeg_natural_order[k]
d328 1
a328 1
        STR     h_temp,[h_block,h_temp2,LSL #2]         ;   block[jpeg_natural_order[k]] = (JCOEF) (((JCOEF) s) * quanttbl->quantval[k]);
d330 1
d333 5
a337 4
huff_else                                               ; } else {
        CMP     h_temp2,#15                             ;   if (n != 15)
        BNE     huff_exit                               ;     break;
        ADDS    h_k,h_k,#15+1                           ;   k += 15;     (and 1 for the for loop)
d340 1
a340 1
        ; That block is completed now.
d342 11
a352 11
        ; Have we done enough blocks? If not, do another.
        ADD     h_block,h_block,#DCTSIZE2*4             ; advance block pointer
        LDR     h_temp,[sp,#16*4]                       ; get nblocks
        SUBS    h_temp,h_temp,#1                        ; decrement it
        STRNE   h_temp,[sp,#16*4]                       ; if not zero, save new value
        BNE     huff_anotherblock                       ;           ...and loop.

        ; We are going to exit.
        ; Save the state of the huff stream, and return.
        LDR     h_temp,[sp]                             ; cinfo
        STR     h_inptr,[h_temp,#cinfo_next_input_byte] ; save state of input bit stream
d355 18
a372 1
        LDMIA   sp!,{r0-r12,pc}                         ; exit
d374 1
a374 10
        ; extern asm_huff_skip_blocks (j_decompress_ptr cinfo, JBLOCK block,
        ;                              JHUFF_TBL *dctbl, JHUFF_TBL *actbl,
        ;                              JQUANT_TBL *quanttbl, JCOEF *last_dc_val, int nblocks)
        ;   r0 = cinfo
        ;   r1 = block pointer           (UNUSED)
        ;   r2 = JHUFF_TBL *dctbl
        ;   r3 = JHUFF_TBL *actbl
        ;   [sp,#0] = quanttbl           (UNUSED)
        ;   [sp,#4] = JCOEF *last_dc_val
        ;   [sp,#8] = int nblocks
d377 15
a391 1
        ; save registers
d396 2
a397 2
        ; now set up registers for the main procedure.
        ; r0=h_temp=cinfo
d403 14
a416 14
        ; if nblocks<=0, return
        LDR     h_temp2,[sp,#16*4]                      ; get nblocks
        CMP     h_temp2,#0                              ; if <=0
        LDMLEIA sp!,{r0-r12,pc}                         ; then return

huff_skip_anotherblock                                  ; loop round to here nblocks times

        ; Set up huffman decoding for the DC component.
        LDR     h_temp,[sp,#2*4]                        ; JHUFF_TBL* dctbl    (DC table pointer)
        HUFF_DECODE_SETUP h_temp                        ; set maxcode,huffval,shortcut

        ; Handle the DC component
        Huff_decode 2                                   ; h_temp = s = huff_DECODE(cinfo, dctbl);
        CMP     h_temp,#0                               ; if (s)
d418 2
a419 2
        Huff_getbits h_temp                             ; h_temp counts the bits, result in h_temp
                                                        ; s = huff_EXTEND(get_bits(cinfo, s), s);
d423 4
a426 4
        LDR     h_temp3,[sp,#15*4]                      ; JCOEF *last_dc_val
        LDR     h_temp2,[h_temp3]                       ; ...*last_dc_val
        ADD     h_temp2,h_temp,h_temp2                  ; s += *last_dc_val;
        STR     h_temp2,[h_temp3]                       ; and write *last_dc_val back
d430 3
a432 3
        ; Set up huffman decoding for the AC components.
        LDR     h_temp,[sp,#3*4]                        ; JHUFF_TBL* actbl    (AC table pointer)
        HUFF_DECODE_SETUP h_temp                        ; set maxcode,huffval,shortcut
d434 2
a435 2
        ; The loop that does AC components, once round for each non-zero component.
        MOV     h_k,#-DCTSIZE2+1                        ; index into block
d437 7
a443 7
        Huff_decode 3                                   ; result in r (ie h_temp)
        MOV     h_temp2,h_temp,LSR #4                   ; n = r >> 4;
        ANDS    h_temp,h_temp,#15                       ; s = r & 15;
        BEQ     huff_skip_else                          ; if (s) {
        ADD     h_k,h_k,h_temp2                         ;   k += n;
        Huff_skipbits h_temp                            ;   s = huff_EXTEND(get_bits(cinfo, s), s); in h_temp
                                                        ; ... and throw the value away.
d447 4
a450 4
huff_skip_else                                          ; } else {
        CMP     h_temp2,#15                             ;   if (n != 15)
        BNE     huff_skip_exit                          ;     break;
        ADDS    h_k,h_k,#15+1                           ;   k += 15;     (and 1 for the for loop)
d453 1
a453 1
        ; That block is completed now.
d455 10
a464 10
        ; Have we done enough blocks? If not, do another.
        LDR     h_temp,[sp,#16*4]                       ; get nblocks
        SUBS    h_temp,h_temp,#1                        ; decrement it
        STRNE   h_temp,[sp,#16*4]                       ; if not zero, save new value
        BNE     huff_skip_anotherblock                  ;           ...and loop.

        ; We are going to exit.
        ; Save the state of the huff stream, and return.
        LDR     h_temp,[sp]                             ; cinfo
        STR     h_inptr,[h_temp,#cinfo_next_input_byte] ; save state of input bit stream
d467 1
a467 1
        LDMIA   sp!,{r0-r12,pc}                         ; exit
d474 6
a479 3
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Error handling
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
a480 1
huff_bad_stuff_byte
d483 1
a483 1
        STMDB   sp,{r0-lr,pc}                           ; dump ALL the registers.
d486 14
a499 3
        MOV     r2,#JWRN_TOO_MUCH_DATA                  ; r2 = panic type
        B       huff_panic_exit                         ; join common code
huff_badinput
d502 1
a502 1
        STMDB   sp,{r0-lr,pc}                           ; dump ALL the registers.
d505 2
a506 13
        MOV     r2,#JWRN_HUFF_BAD_CODE                  ; r2 = panic type
        ; Fall through
huff_panic_exit
        ADD     r3,sp,#16*4+4*4                         ; point at original saved registers, except r0-r3
        LDMIA   r3,{r4-r12}                             ; restore registers that C wants
        LDR     r0,[r3,#-16]                            ; r0 = cinfo
        MOV     r1,sp                                   ; r1 -> saved register block

        BL      panic_trace                             ; call dump routine, returns appropriate error code

        ADD     sp,sp,#16*4+1*4                         ; set sp back to what it was (and junk r0)
        LDMIA   sp!,{r1-r12,lr}                         ; restore entry registers
        B       exit
@


4.6.2.6
log
@Huffman decode adjusted to accept quantisation tables of 16 or 32 bit values (though use of LDAH macro).
IJG 8b uses UINT16 values now, but there's no measurable speed difference despite one/two extra instructions per AC component.

Version 1.38, 1.35.2.10. Tagged as 'SprExtend-1_38-1_35_2_10'
@
text
@d87 1
a89 1
        RSB     h_temp2,$n,#32                          ; get ready for shifts by 32-n
d93 1
a93 1
        EOR     h_temp,h_temp3,h_topbit,LSR h_temp2     ; invert that bit again
d171 1
d224 2
a225 2
        ADD     h_temp,h_shortcut,#huff_tbl_valoffset-huff_tbl_shortcut ; get valoffset table
        LDR     h_temp,[h_temp,h_l,LSL #2]              ; do lookup in valoffset table
d236 1
a236 1
        ; extern const char *jpeg_natural_order_base(void)
d299 1
d323 1
a323 6
      [ sizeof_quantval = 4
        LDR     h_temp3,[h_quanttbl,#0]                 ; ...quanttbl->quantval[0]
      |
        MOV     h_temp3,#0
        LDHA    h_temp3,h_quanttbl,h_temp3,h_temp       ; ...quanttbl->quantval[0]
      ]
d334 1
a334 1
        MOV     h_k,#1                                  ; index into block
d343 1
a343 5
      [ sizeof_quantval = 4
        LDR     h_temp2,[h_quanttbl,h_k,LSL #2]         ;   ... quanttbl->quantval[k]
      |
        LDHA    h_temp2,h_quanttbl,h_k,h_temp3          ;   ... quanttbl->quantval[k]
      ]
d345 1
a345 1
        ADR     h_temp2,jpeg_natural_order
d349 2
a350 3
        ADD     h_k,h_k,#1
        CMP     h_k,#DCTSIZE2
        BCC     huff_loop
d355 2
a356 3
        ADD     h_k,h_k,#15+1                           ;   k += 15;     (and 1 for the for loop)
        CMP     h_k,#DCTSIZE2
        BCC     huff_loop
d431 1
a431 1
        MOV     h_k,#1                                  ; index into block
d440 2
a441 3
        ADD     h_k,h_k,#1
        CMP     h_k,#DCTSIZE2
        BCC     huff_skip_loop
d446 2
a447 3
        ADD     h_k,h_k,#15+1                           ;   k += 15;     (and 1 for the for loop)
        CMP     h_k,#DCTSIZE2
        BCC     huff_skip_loop
@


4.6.2.7
log
@Reorganise data input.
Fill in INPUT_VARS and INPUT_SYNC so it uses register variables.
Make use of data source manager (cinfo->src).
Calculate bytes_in_buffer when restoring the huffman position.
Swap process_restart() for the one now in jdmarker.

Version 1.38, 1.35.2.13. Tagged as 'SprExtend-1_38-1_35_2_13'
@
text
@d151 4
a154 5
        LDR     h_temp,[sp]                             ; cinfo
        LDR     h_temp2,[h_temp,#cinfo_next_input_byte]
        SUB     h_temp2,h_inptr,h_temp2                 ; consumed bytes
        LDR     h_temp3,[h_temp,#cinfo_bytes_in_buffer]
        CMP     h_temp3,h_temp2                         ; have we read past the end?
d379 1
a379 7
        LDR     h_temp2,[h_temp,#cinfo_next_input_byte]
        SUB     h_temp2,h_inptr,h_temp2                 ; consumed bytes
        LDR     h_temp3,[h_temp,#cinfo_bytes_in_buffer]
        SUBS    h_temp3,h_temp3,h_temp2
        MOVMI   h_temp3,#0
        STR     h_temp3,[h_temp,#cinfo_bytes_in_buffer] ; save state of input bit stream
        STR     h_inptr,[h_temp,#cinfo_next_input_byte] 
d471 1
a471 7
        LDR     h_temp2,[h_temp,#cinfo_next_input_byte]
        SUB     h_temp2,h_inptr,h_temp2                 ; consumed bytes
        LDR     h_temp3,[h_temp,#cinfo_bytes_in_buffer]
        SUBS    h_temp3,h_temp3,h_temp2
        MOVMI   h_temp3,#0
        STR     h_temp3,[h_temp,#cinfo_bytes_in_buffer] ; save state of input bit stream
        STR     h_inptr,[h_temp,#cinfo_next_input_byte] 
@


4.6.2.8
log
@Abstract entropy decoding.
Currently still only support Huffman, but now agnostic, there are two functions 'decode_mcu()' which does the full DC+AC decode of a full MCU worth of data, and 'skip_mcu()' which just does DC and consumes but discards the AC coefficients.
Apply fix from 1.40 trunk version for monochrome output in a 8bpp greyscale mode.
Restore name of DCTFIX() macro to FIX(), no longer needed now the constituent parts are compiled seperately rather than #included.
Fix CFSIjpeg to assemble even though it doesn't have a module base (the recently added 'relocatefn()' was breaking it).

Version 1.38, 1.35.2.14. Tagged as 'SprExtend-1_38-1_35_2_14'
@
text
@d254 1
d305 1
a305 1
        LDR     h_temp,[sp,#2*4]                        ; JHUFF_TBL *dctbl    (DC table pointer)
d334 1
a334 1
        LDR     h_temp,[sp,#3*4]                        ; JHUFF_TBL *actbl    (AC table pointer)
d341 1
d395 1
a395 1
        ;   r1 = block pointer
d398 1
a398 1
        ;   [sp,#0] = quanttbl
a407 5
        ; if nblocks<=0, return
        LDR     r2,[sp,#16*4]                           ; get nblocks
        CMP     r2,#0                                   ; if <=0
        LDMLEIA sp!,{r0-r12,pc}                         ; then return

a412 2
        LDR     h_quanttbl,[sp,#14*4]
        LDR     h_block,[sp,#4]
d415 5
d423 1
a423 1
        LDR     h_temp,[sp,#2*4]                        ; JHUFF_TBL *dctbl    (DC table pointer)
d439 1
a439 10
        ; Now multiply by the quantisation value, and store in the block
      [ sizeof_quantval = 4
        LDR     h_temp3,[h_quanttbl,#0]                 ; ...quanttbl->quantval[0]
      |
        MOV     h_temp3,#0
        LDHA    h_temp3,h_quanttbl,h_temp3,h_temp       ; ...quanttbl->quantval[0]
      ]
        MUL     h_temp,h_temp2,h_temp3                  ; ...s * quanttbl->quantval[0]
                                                        
        STR     h_temp,[h_block]                        ; block[0] = (JCOEF) (((JCOEF) s) * quanttbl->quantval[0]);
d443 1
a443 1
        LDR     h_temp,[sp,#3*4]                        ; JHUFF_TBL *actbl    (AC table pointer)
a469 1
        ADD     h_block,h_block,#DCTSIZE2*4             ; advance block pointer
@


4.6.2.9
log
@Sync with trunk
Sources/SprOp - revision 4.10 copied
Sources/SprTrans - revision 4.16 copied
Sources/jdhuff - revision 4.7 copied
Also:
 DCI changed to instruction mnemonic for objasm 4
 Makefile excess '-c' removed
 Util.mk double inclusion of rules removed

Version 1.38, 1.35.2.16. Tagged as 'SprExtend-1_38-1_35_2_16'
@
text
@d511 1
a511 1
        STMDB   sp,{r0-r12}                              ; dump ALL the registers.
a513 2
        STR     lr,[sp,#14*4]
        STR     pc,[sp,#15*4]
d519 1
a519 1
        STMDB   sp,{r0-r12}                              ; dump ALL the registers.
a521 2
        STR     lr,[sp,#14*4]
        STR     pc,[sp,#15*4]
a530 1
        ADD     sp,sp,#(16*4)+4                         ; set sp back to what it was (and junk r0)
d532 1
a533 1
        MOV     r0,#2                                   ; this is ERROR_BAD_JPEG
@


4.5
log
@Remove postprocessing step of C code.
Since 2001 this module has been using objasm, but still using the C compiler to output (via -S) assembly code which is then passed through 'sed' and included via GET into the assembler code.
Changed to compile the C code into object files, and use the linker to patch up the unresolved references - this has required some reordering of the C code to make sure static functions now appear in the object file, and some reordering of the header files to ensure both the module and the CFSI version still compile without conflicts.
Minor fix to 'swiv2', the label was in the wrong place for _swi() though it's not used in this module so didn't affect the _swix() case.
Makefile cut down a bit. Unixify some path names.
Test code moved to 'Test/c' directory.
Tested in both debug and non debug cases via softloaded module. Oddly, it's 4 bytes longer than the previous version.

Version 1.28. Tagged as 'SprExtend-1_28'
@
text
@d503 2
a504 2
        MOV     r0,#123                                  ; >>>> rationalise exit codes!
        B       panic_exit
a514 4
;        LDMIA   sp!,{r0-r12,lr}                          ; restore entry registers
;        MOV     r0,#124                                  ; >>>> rationalise exit codes!
;        B       panic_exit

@


4.4
log
@Replaced a couple of STMs in error recovery code with code sequences that
don't use UNPREDICTABLE (and XScale-unsafe) instructions.

Version 1.13. Tagged as 'SprExtend-1_13'
@
text
@d222 1
d381 1
@


4.3
log
@  Now uses objasm throughout instead of aasm.
Detail:
  The build structure for this module is not nice - I've sanitised it a
    bit, but it's still not nice.
Admin:
   Built and tested with the test program briefly - the test sprite seems
     to scale and rotate properly.  ChangeFSI not tested.


Version 1.08. Tagged as 'SprExtend-1_08'
@
text
@d487 4
a490 1
        STMDB   sp!,{r0-lr,pc}                           ; dump ALL the registers.
d506 4
a509 1
        STMDB   sp!,{r0-lr,pc}                           ; dump ALL the registers.
@


4.2
log
@32-bit compatible. Tagged as SprExtend-1_06
@
text
@d35 1
a35 1
        GET     s.jhdr
d76 3
a78 3
; #define huff_EXTEND(x, s)       ((x) < (1 << ((s)-1)) ? \
;                                  (x) + (-1 << (s)) + 1 : \
;                                  (x))
a493 1
        IMPORT  assembler_panic
@


4.1
log
@Initial revision
@
text
@d243 1
a243 1
        LDMLEIA sp!,{r0-r12,pc}^                 ; then return
d360 1
a360 1
        LDMIA   sp!,{r0-r12,pc}^                         ; exit
d411 1
a411 1
        LDMLEIA sp!,{r0-r12,pc}^                 ; then return
d472 1
a472 1
        LDMIA   sp!,{r0-r12,pc}^                         ; exit
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

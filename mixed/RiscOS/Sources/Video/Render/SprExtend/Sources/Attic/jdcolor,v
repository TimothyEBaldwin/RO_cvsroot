head	4.3;
access;
symbols
	SprExtend-1_70-tracef:4.2
	SprExtend-1_70-headers:4.2
	SprExtend-1_70:4.2
	SprExtend-1_69:4.2
	SprExtend-1_68:4.2
	SprExtend-1_67:4.2
	SprExtend-1_66:4.2
	SprExtend-1_65:4.2
	SprExtend-1_64:4.2
	SprExtend-1_63:4.2
	SprExtend-1_62:4.2
	SprExtend-1_61:4.2
	SprExtend-1_60:4.2
	SprExtend-1_59:4.2
	SprExtend-1_58:4.2
	SprExtend-1_57:4.2
	SprExtend-1_56:4.2
	SprExtend-1_55:4.2
	SprExtend-1_54:4.2
	SprExtend-1_53:4.2
	SprExtend-1_52:4.2
	SprExtend-1_51:4.1
	SprExtend-1_50:4.1
	SprExtend-1_38-1_35_2_16:1.1.2.7
	SprExtend-1_38-1_35_2_15:1.1.2.6
	SprExtend-1_38-1_35_2_14:1.1.2.6
	SprExtend-1_38-1_35_2_13:1.1.2.5
	SprExtend-1_38-1_35_2_12:1.1.2.5
	SprExtend-1_38-1_35_2_11:1.1.2.5
	SprExtend-1_38-1_35_2_10:1.1.2.5
	SprExtend-1_38-1_35_2_9:1.1.2.5
	SprExtend-1_38-1_35_2_8:1.1.2.4
	SprExtend-1_38-1_35_2_7:1.1.2.3
	SprExtend-1_38-1_35_2_6:1.1.2.2
	SprExtend-1_38-1_35_2_5:1.1.2.1
	MigrateIJG8b:1.1.0.2;
locks; strict;
comment	@# @;


4.3
date	2016.05.21.13.44.32;	author rool;	state dead;
branches;
next	4.2;
commitid	ZDqmsyNiMhv6Zl7z;

4.2
date	2013.08.06.23.16.19;	author jlee;	state Exp;
branches;
next	4.1;
commitid	z9XOph7zDZQ2Ur0x;

4.1
date	2012.07.28.15.23.38;	author rsprowson;	state Exp;
branches;
next	1.1;
commitid	b5jdybqzJ3Wdjlew;

1.1
date	2011.01.04.22.13.05;	author rsprowson;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2011.01.04.22.13.05;	author rsprowson;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2011.01.09.10.42.55;	author rsprowson;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2011.01.09.10.56.40;	author rsprowson;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2011.01.13.21.12.16;	author rsprowson;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2011.01.22.17.58.26;	author rsprowson;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2011.02.15.20.57.58;	author rsprowson;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2012.07.28.14.42.48;	author rsprowson;	state Exp;
branches;
next	;
commitid	Ny6vV3CHXwee5lew;


desc
@@


4.3
log
@Import of IJG8d library sources
Detail:
  Using the decoder in "example.c" as a starting point, we try to follow that sequence more closely even if in our embedded implementation some of the functions don't do much.
  Uses the default colour backend for 32bpp BGR output for most of the unusual cases.
  The most common 2x2 subsampling case uses a custom merged upsampler and colour converter, with colour output directly in RISC OS format for the respective screen mode.
Admin:
  Submission for the JPEG bounty.

Version 1.71. Tagged as 'SprExtend-1_71'
@
text
@; Copyright 2011 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.jdcolor

; Colour conversion facilities, see also the contents of c.jdcolor.
; 24-Sep-93 - started

        ; All values in DCT blocks are scaled up by SCALEBITS bits.
SCALEBITS * 19
ONE_HALF  * 1:SHL:(SCALEBITS - 1)

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Monochrome colour conversion
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        ; If negative, clamp at zero. If >= 2^bits, clamp at (2^bits)-1.
        MACRO
        Clamp   $r,$bits
      [ NoARMv6
        MOVLT   $r,#0                    ; must be preceded by a flags setting op
        CMP     $r,#1:SHL:$bits
      [ $bits > 8
        MOVCS   $r,#(1:SHL:$bits)
        SUBCS   $r,$r,#1                 ; pesky 8 bit immediates
      |
        MOVCS   $r,#(1:SHL:$bits) - 1
      ]
      |                                  ; take a look at my funky USAT
        USAT    $r, #$bits, $r
      ]
        MEND
        
        ; Do descaling etc. for a mono pixel
        MACRO
        MonoConv $r
        ADD     $r,$r,#ONE_HALF          ; rounding prior to truncation
        ADDS    $r,r12,$r,ASR #SCALEBITS ; normalise, truncate
        Clamp   $r,8
        ORR     $r,$r,$r,LSL #8          ; replicate grey value in each of R, G, B
        ORR     $r,$r,$r,LSL #8
        MEND

        ; Do a DC mono pixel no descaling
        MACRO
        MonoDC  $r
        ADD     $r,$r,#4
        MOV     $r,$r,ASR #3             ; descale Y
        ADDS    $r,$r,#128               ; normalise
        Clamp   $r,8
        ORR     $r,$r,$r,LSL #8          ; replicate grey value in each of R, G, B
        ORR     $r,$r,$r,LSL #8
        MEND

        ; Do descaling etc. for a mono pixel
        MACRO
        MonoConv8 $r
        ADD     $r,$r,#ONE_HALF          ; rounding prior to truncation
        ADDS    $r,r12,$r,ASR #SCALEBITS ; normalise, truncate
        Clamp   $r,8
        MEND

        ; Combine three seperate RGB values into a final colour, with an
        ; optional constant alpha value
        MACRO
        CombineRGB $out,$r,$g,$b,$alpha,$red_shift,$green_shift,$blue_shift
      [ $red_shift = 0
        ORR     $out,$r,$g,LSL #$green_shift   ; G and R
        ORR     $out,$out,$b,LSL #$blue_shift  ; complete output pixel
      |
        ASSERT $blue_shift = 0
        ORR     $out,$b,$g,LSL #$green_shift   ; G and B
        ORR     $out,$out,$r,LSL #$red_shift   ; complete output pixel
      ]
      [ $alpha <> 0
        ORR     $out,$out,#$alpha              ; with alpha
      ]
        MEND
       

        ; extern int asm_mono_convert_pixel(int pix)
        ; /* Convert greyscale pixel into 32bit RGB values. */
        ;   r0 = luma, no shifting needed as it's not been through the DCT.
        EXPORT  asm_mono_convert_pixel
asm_mono_convert_pixel
        MonoDC  r0
        MOV     pc,lr

        ; extern int asm_mono_convert_pixels(int *y)
        ; /* Convert 4 greyscale pixels into 32bit RGB values. */
        ;   r0 -> array of luma, no shifting needed as it's not been through the DCT.
        EXPORT  asm_mono_convert_pixels
asm_mono_convert_pixels
        MOV     r1,#4
10
        SUBS    r1,r1,#1
        MOVMI   pc,lr
        LDR     r2,[r0,r1,LSL#2]
        MonoDC  r2
        STR     r2,[r0,r1,LSL#2]
        B       %BT10

        ; extern void asm_mono_convert_block(JBLOCK jblock, int *outptr, int outoffset)
        ; /* Convert greyscale image into 32bit RGB values. */
        ;   r0 = jblock - in row order, values that need descaling
        ;   r1 = outptr - in column order, put RGB values here
        ;   r2 = outoffset - distance (in words) between output rows.
        ;   r11 = col counter.
        ; We LDR from the block and STM to the output rather than visa versa,
        ; because a long sequence of STRs clogs up the write buffer and is slow.
        EXPORT  asm_mono_convert_block
asm_mono_convert_block
        STMDB   sp!,{r4-r11,lr}             ; save state
        MOV     r11,#DCTSIZE                ; col counter
        MOV     r12,#128                    ; required constant

jc_mono_loop
        LDR     r3,[r0,#DCTSIZE*4*0]        ; get a whole row
        LDR     r4,[r0,#DCTSIZE*4*1]        ; interleave order hopes to help ARM8!
        MonoConv r3
        LDR     r5,[r0,#DCTSIZE*4*2]
        MonoConv r4
        LDR     r6,[r0,#DCTSIZE*4*3]
        MonoConv r5
        LDR     r7,[r0,#DCTSIZE*4*4]
        MonoConv r6
        LDR     r8,[r0,#DCTSIZE*4*5]
        MonoConv r7
        LDR     r9,[r0,#DCTSIZE*4*6]
        MonoConv r8
        LDR     r10,[r0,#DCTSIZE*4*7]
        MonoConv r9
        MonoConv r10

        STMIA   r1,{r3-r10}                 ; store a row
        ADD     r1,r1,r2,LSL #2             ; add row offset to output pointer
        ADD     r0,r0,#4                    ; advance input pointer
        SUBS    r11,r11,#1                  ; outer loop
        BNE     jc_mono_loop

        LDMIA   sp!,{r4-r11,pc}

        ; extern void asm_mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset)
        ; /* Convert greyscale image into 8bit Grey values. */
        ;   r0 = jblock - in row order, values that need descaling
        ;   r1 = outptr - in column order, put grey values here
        ;   r2 = outoffset - distance (in words) between output rows.
        ;   r11 = col counter.
        ; We LDR from the block and STM to the output rather than visa versa,
        ; because a long sequence of STRs clogs up the write buffer and is slow.
        EXPORT  asm_mono_convert_block_8
asm_mono_convert_block_8
        STMDB   sp!,{r4-r11,lr}             ; save state
        MOV     r11,#DCTSIZE                ; col counter
        MOV     r12,#128                    ; required constant

jc_mono_loop8
        LDR     r3,[r0,#DCTSIZE*4*0]        ; get a whole row
        LDR     r4,[r0,#DCTSIZE*4*1]        ; interleave order hopes to help ARM8!
        MonoConv8 r3
        LDR     r5,[r0,#DCTSIZE*4*2]
        MonoConv8 r4
        ORR     r3,r3,r4,LSL #8
        LDR     r6,[r0,#DCTSIZE*4*3]
        MonoConv8 r5
        ORR     r3,r3,r5,LSL #16
        LDR     r7,[r0,#DCTSIZE*4*4]
        MonoConv8 r6
        ORR     r3,r3,r6,LSL #24
        LDR     r8,[r0,#DCTSIZE*4*5]
        MonoConv8 r7
        LDR     r9,[r0,#DCTSIZE*4*6]
        MonoConv8 r8
        ORR     r7,r7,r8,LSL #8
        LDR     r10,[r0,#DCTSIZE*4*7]
        MonoConv8 r9
        ORR     r7,r7,r9,LSL #16
        MonoConv8 r10
        ORR     r7,r7,r10,LSL #24

        STMIA   r1,{r3,r7}                  ; store a row
        ADD     r1,r1,r2,LSL #2             ; add row offset to output pointer
        ADD     r0,r0,#4                    ; advance input pointer
        SUBS    r11,r11,#1                  ; outer loop
        BNE     jc_mono_loop8

        LDMIA   sp!,{r4-r11,pc}

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; YUV->RGB colour conversion 32bpp
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        ; combine the y value of r/g/b with the value derived from u and v.
        ; then normalise the result to be $gunbits number of bits
        ; $y holds the y value, $gunsrc the value from u and v, result in $gun.
        MACRO
        NormaliseGun $op,$gun,$y,$gunsrc,$gunbits
        $op     $gun,$y,$gunsrc             ; R/G/B, at SCALEBITS bits
        MOVS    $gun,$gun,ASR #SCALEBITS+8-$gunbits ; truncate
        Clamp   $gun,$gunbits
        MEND

k140200 RN 3
k034414 RN 4
k071414 RN 5
k177200 RN 6

jc_fix_table
        ;       FIX(1.40200), FIX(0.34414), FIX(0.71414), FIX(1.77200)
        ASSERT  SCALEBITS=19
        DCD     735052,       180428,       374415,       929038 

        ; extern void asm_colour_convert_pixels(int *y, int u, int v)
        ; /* Convert four pixels. Input y values are in y[0..3]. */
        ;   r0 -> the four blocks, YYYY, no shifting needed as it's not been through the DCT.
        ;   r1 = corresponding u
        ;   r2 = corresponding v
        ; the output goes back in y[0..3]
        EXPORT  asm_colour_convert_pixels
asm_colour_convert_pixels
      [ cfsi_jpeg
        MOV     pc,lr                       ; referenced from C code, but never used.
      |
        STMDB   sp!,{r4-r8,lr}

        ADD     r1,r1,#4
        MOV     r1,r1,ASR #3
        ADD     r2,r2,#4
        MOV     r2,r2,ASR #3                ; descale

        ADR     r14,jc_fix_table
        LDMIA   r14,{r3-r6}                 ; get magic scalers

        MUL     r3,r2,k140200               ; r = v * 1.40200
        ADD     r3,r3,#ONE_HALF

        MUL     r4,r1,k034414
        MLA     r5,r2,k071414,r4            ; g = 0 -  u * 0.34414 - v * 0.71414
        RSB     r4,r5,#0                    ;   = 0 - (u * 0.34414 + v * 0.71414)
        ADD     r4,r4,#ONE_HALF

        MUL     r5,r1,k177200               ; b = u * 1.77200
        ADD     r5,r5,#ONE_HALF

        MOV     r1,#4
        MOV     r14,#128
10
        SUBS    r1,r1,#1
        LDMMIIA sp!,{r4-r8,pc}              ; loop 3 to 0

        LDR     r2,[r0,r1,LSL#2]

        ADD     r2,r2,#4
        ADD     r2,r14,r2,ASR #3            ; normalise and descale Y

        ADDS    r6,r2,r3,ASR #SCALEBITS     ; rr = r + yy unFIX'd
        Clamp   r6,8
        ADDS    r7,r2,r4,ASR #SCALEBITS     ; gg = g + yy unFIX'd
        Clamp   r7,8
        ADDS    r8,r2,r5,ASR #SCALEBITS     ; bb = b + yy unFIX'd
        Clamp   r8,8

        ORR     r6,r6,r8,LSL #16            ; collect up &0BGR and store
        ORR     r6,r6,r7,LSL #8 
        STR     r6,[r0,r1,LSL#2]
        B       %BT10
      ]

        ; extern void asm_colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset, int wide, int high)
        ; /* yuv[0..1] are Y, yuv[4] is U, yuv[5] is V. wide/high are 1 or 2. */
        ;   r0 -> the six blocks, YYYYUV (all row-ordered, ie 'wrong' way round, different from output)
        ;   r1 -> output buffer
        ;   r2 = offset in words between rows of output
        ;   r3 = hsamp
        ;   sp+0 = vsamp
        ; the output goes in outptr[row*outoffset + col] for row/col in 0..15
        EXPORT  asm_colour_convert_unusual_block
asm_colour_convert_unusual_block
        STMDB   sp!,{r2,r4-r11,lr}
        LDR     r2,[sp,#10*4]               ; recover vsamp
        SUB     r2,r2,#1                    ; vsamp zeros based
        SUB     r10,r3,#1                   ; hsamp zeros based
        MOV     r11,#0                      ; ycoord counter (j)
        MOV     r12,#0                      ; xcoord counter (i)
        MOV     r14,#128                    ; useful constant
10
        AND     r4,r11,#7
        AND     r6,r12,#7
        ADD     r4,r4,r6,LSL #3
        ADD     r4,r0,r4,LSL #2
        CMP     r11,#DCTSIZE
        CMPCC   r12,#DCTSIZE
        LDRCC   r7,[r4,#0*4*DCTSIZE2]
        LDRCS   r7,[r4,#1*4*DCTSIZE2]       ; extract y from right block, NB row order

        MOV     r4,r11,ASR r2
        MOV     r6,r12,ASR r10
        ADD     r4,r4,r6,LSL #3             ; (j >> (vsamp-1)) + ((i >> (hsamp-1)) * 8)
        ADD     r4,r0,r4,LSL #2

        LDR     r8,[r4,#4*4*DCTSIZE2]       ; u
        LDR     r9,[r4,#5*4*DCTSIZE2]       ; v

        ADD     r7,r7,#ONE_HALF
        ADD     r8,r8,#ONE_HALF
        ADD     r9,r9,#ONE_HALF
        ADD     r7,r14,r7,ASR #SCALEBITS    ; normalise & descale
        MOV     r8,r8,ASR #SCALEBITS        ; descale
        MOV     r9,r9,ASR #SCALEBITS        ; descale

        ADR     r3,jc_fix_table
        LDMIA   r3,{r3-r6}                  ; get magic scalers

        MUL     r3,r9,k140200               ; r = v * 1.40200
        ADD     r3,r3,#ONE_HALF

        MUL     r4,r8,k034414
        MLA     r5,r9,k071414,r4            ; g = 0 -  u * 0.34414 - v * 0.71414
        RSB     r4,r5,#0                    ;   = 0 - (u * 0.34414 + v * 0.71414)
        ADD     r4,r4,#ONE_HALF

        MUL     r5,r8,k177200               ; b = u * 1.77200
        ADD     r5,r5,#ONE_HALF

        ADDS    r6,r7,r3,ASR #SCALEBITS     ; r = r unFIX'd + y
        Clamp   r6,8
        ADDS    r3,r7,r4,ASR #SCALEBITS     ; g = g unFIX'd + y
        Clamp   r3,8
        ADDS    r4,r7,r5,ASR #SCALEBITS     ; b = b unFIX'd + y
        Clamp   r4,8

        ORR     r6,r6,r4,LSL #16            ; collect up &0BGR and store
        ORR     r6,r6,r3,LSL #8
        STR     r6,[r1,r12,LSL#2]

        ADD     r12,r12,#1                  ; next i
        CMP     r10,r12,LSR #3              ; 8->1 16->2 comparing with 0 or 1
        BHS     %BT10

        MOV     r12,#0                      ; restart i=0
        LDR     r3,[sp]                     ; outoffset on entry
        ADD     r1,r1,r3,LSL #2             ; outptr += outoffset

        ADD     r11,r11,#1                  ; next j
        CMP     r2,r11,LSR #3               ; 8->1 16->2 comparing with 0 or 1
        BHS     %BT10

        LDMIA   sp!,{r2,r4-r11,pc}

        ; extern void asm_colour_convert_block_32(JCOEF *yuv, int *outptr, int outoffset)
        ; /* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block */
        ;   r0 -> the six blocks, YYYYUV (all row-ordered, ie 'wrong' way round, different from output)
        ;   r1 -> output buffer
        ;   r2 = offset in words between rows of output
        ; the output goes in outptr[row*outoffset + col] for row/col in 0..15
        EXPORT  asm_colour_convert_block_32
asm_colour_convert_block_32
        STMDB   sp!,{r4-r11,lr}             ; save state
        ADD     r3,r1,#(2*DCTSIZE)*4        ; column limit pointer (inner loop) - outptr+16 words
        ADD     r4,r1,r2,LSL #3+2           ; row limit pointer (outer loop) - outptr+8*outoffset words
        ADD     r5,r0,#4*DCTSIZE2*4         ; pointer into U block. V values DCTSIZE2 words on from this
        ADD     r6,r4,r2,LSL #3+2           ; real row limit pointer - outptr+16*outoffset words

        ; The main loop goes round once for each 2*2 square of four output pixels, using
        ; four Y values, one U value, one V value.
jc_colour_loop                              ; each two rows and each two columns of output

        ; do four output pixels, using:
        ; [r5] is U value
        ; [r5,#DCTSIZE*4] is V value
        ; [r0] is Y value for output word [r1]
        ; [r0,#4] is Y value for output word [r1,r2,LSL #2]
        ; [r0,#DCTSIZE*4] is Y value for output word [r1,#4]
        ; [r0,#DCTSIZE*4+4] is Y value for output word [r1,#4 + r2,LSL #2] (so to speak!)

        ; first we compute the values derived from U and V, which are
        ; true for all four pixels.
        LDR     r7,[r5]                     ; U value
        MOV     r7,r7,ASR #8                ; the multiplies will get us back to SCALEBITS again
        LDR     r8,[r5, #DCTSIZE2*4]        ; V value
        MOV     r8,r8,ASR #8                ; the multiplies will get us back to SCALEBITS again
        ; Should add 1:SHL:7 before ASR #8, but not regarded as significant enough
        ; considering how much bigger SCALEBITS is.

        ; Multiply sequences generated by cc 4.50, for 8 bits of accuracy.
        ; these sequences lead to a result shifted left by 8 bits.
        ;MulCon  r9,r7,FIX(1.77200)         ; B, without the Y yet
        ADD     r9,r7,r7,LSL #5
        RSB     r9,r9,r7,LSL #8
        SUB     r9,r9,r7,LSL #3             ; still needs a LSL #1

        ;MulCon  r10,r8,FIX(1.40200)        ; R, without the Y yet
        ADD     r10,r8,r8,LSL #5
        RSB     r10,r10,r10,LSL #3
        ADD     r10,r10,r8,LSL #7

        ;MulCon  r12,r8,-FIX(0.71414)
        RSB     r12,r8,r8,LSL #6
        ADD     r12,r12,r8,LSL #7
        SUB     r12,r12,r8,LSL #3

        ;MulCon  r11,r7,-FIX(0.34414)
        ADD     r11,r7,r7,LSL #1
        ADD     r11,r11,r7,LSL #3           ; LSL #3 still needed - see below
        ADD     r11,r12,r11,LSL #3          ; -G, without the Y yet - did the LSL #3, see above.

        ; After those multiplies, the values are shifted up by SCALEBITS again.
        ; We're going to add each of r9/r10/r11 to the Y values.
        ; The Y values need 128 added to them - add it at this point.
        ; need to add a half for the truncation of NormaliseGun - do that at the same time.
        MOV     r7,#ONE_HALF
        ADD     r7,r7,#128:SHL:SCALEBITS
        ADD     r9,r7,r9,LSL #1             ; LSL #1 still owed to R9 - see above.
        ADD     r10,r7,r10
        RSB     r11,r7,r11                  ; r11 is to be subtracted from Y, not added.

        ; now process the four pixels one at a time.
        LDMIA   r0,{r7,r8}                  ; first two Y values, shifted up by SCALEBITS
        NormaliseGun ADD,r12,r7,r9,8        ; B
        NormaliseGun ADD,lr,r7,r10,8        ; R
        NormaliseGun SUB,r7,r7,r11,8        ; G
        ORR     r7,lr,r7,LSL #8             ; G and R
        ORR     r7,r7,r12,LSL #16           ; complete output pixel
        STR     r7,[r1]                     ; output pixel

        NormaliseGun ADD,r12,r8,r9,8        ; B
        NormaliseGun ADD,lr,r8,r10,8        ; R
        NormaliseGun SUB,r8,r8,r11,8        ; G
        ORR     r8,lr,r8,LSL #8             ; G and R
        ORR     r8,r8,r12,LSL #16           ; complete output pixel
        STR     r8,[r1,r2,LSL #2]           ; output pixel
        ADD     r1,r1,#4

        ADD     r7,r0,#DCTSIZE*4            ; prepare to load next two pixels
        
        LDMIA   r7,{r7,r8}                  ; other two pixels
        NormaliseGun ADD,r12,r7,r9,8        ; B
        NormaliseGun ADD,lr,r7,r10,8        ; R
        NormaliseGun SUB,r7,r7,r11,8        ; G
        ORR     r7,lr,r7,LSL #8             ; G and R
        ORR     r7,r7,r12,LSL #16           ; complete output pixel
        STR     r7,[r1]                     ; output pixel

        NormaliseGun ADD,r12,r8,r9,8        ; B
        NormaliseGun ADD,lr,r8,r10,8        ; R
        NormaliseGun SUB,r8,r8,r11,8        ; G
        ORR     r8,lr,r8,LSL #8             ; G and R
        ORR     r8,r8,r12,LSL #16           ; complete output pixel
        STR     r8,[r1,r2,LSL #2]           ; output pixel
        ADD     r1,r1,#4

        ; increment pointers to go two pixels along an output row
        ; r1 (output pointer) already updated
        ADD     r5,r5,#DCTSIZE*4            ; pointer into row-organised U,V values
        ADD     r0,r0,#2*DCTSIZE*4          ; ditto for Y values

        ; check for end of row
        CMP     r1,r3                       ; output pointer reached end of output row?
        BNE     jc_colour_loop              ; go round for next column

        ; Amazingly there is no special action to take half-way along each output row,
        ; when we switch from one Y block to the next - because of the ordering and
        ; arrangement of the Y blocks, it just acts as a single 8*16 block.

        ; It's the end of the row. Update all input and output pointers to
        ; advance to next one.
        ADD     r1,r1,r2,LSL #2+1           ; advance output ptr by two output rows
        SUB     r1,r1,#2*DCTSIZE*4          ;      ... and then to beginning of next output row.
        SUB     r5,r5,#(DCTSIZE2*4-4)*1     ; advance UV pointer to start of next row
        SUB     r0,r0,#(DCTSIZE2*4-4)*2     ; ditto Y pointer, but back two blocks
        ADD     r3,r1,#2*DCTSIZE*4          ; reset column limit pointer (inner loop) - outptr+16 words

        ; Check for having to change to the second pair of Y blocks, or terminate
        CMP     r1,r4
        BNE     jc_colour_loop              ; normal case - we set off on another two rows of output

        ; It's either the half-way point, in which case we need to change to the second pair
        ; of input Y blocks, or it's the end. Test r4 against the 'real' limit pointer.

        CMP     r4,r6                       ; is this the end?
        LDMEQIA sp!,{r4-r11,pc}             ; if so, return - nothing more to do

        ; We've reached the half-way point.
        MOV     r4,r6                       ; next time we test r4 and r6, exit.
        ADD     r0,r0,#((2*DCTSIZE2)-DCTSIZE)*4  ; advance r0 from end of row 0 of block 0,
                                            ; to start of row 0 of block 2.
        B       jc_colour_loop              ; and continue.

        ; Performance notes for colour conversion.
        ; approx number of ticks for 4 pixels:
        ;    7        loop etc.
        ;   23        common work on the UV values
        ;   40        loading/storing,combining gun values
        ;   52        normalising gun values
        ;   --
        ;  122/4 = 30.5 per pixel.

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; YUV->RGB colour conversion 16bpp
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        GBLA    red_bits
        GBLA    green_bits
        GBLA    blue_bits
        GBLA    red_shift
        GBLA    green_shift
        GBLA    blue_shift
        GBLA    alpha_value
        GBLS    function_name

        ; extern convert_block_16_func asm_get_convert_block_16_func(int ncolour,int modeflags);
        ;
        ; Return a pointer to the right colour conversion function
        ; Handled in assembler because I don't trust Norcroft!
        EXPORT  asm_get_convert_block_16_func
asm_get_convert_block_16_func
        ADD     r0,r0,#1
        CMP     r0,#4096
        MOVEQ   r2,#0
        MOVNE   r2,#4
        TSTNE   r1,#ModeFlag_64k
        MOVNE   r2,#8
        BICNE   r1,r1,#ModeFlag_DataFormatSub_Alpha
        TST     r1,#ModeFlag_DataFormatSub_RGB
        ADDNE   r2,r2,#1
        TST     r1,#ModeFlag_DataFormatSub_Alpha
        ADDNE   r2,r2,#2
        ADR     r0,convert_16_table
        LDR     r1,[r0,r2,LSL #2]
        ADD     r0,r0,r1
        MOV     pc,lr

convert_16_table
        DCD   asm_colour_convert_block_4444_TBGR - convert_16_table
        DCD   asm_colour_convert_block_4444_TRGB - convert_16_table
        DCD   asm_colour_convert_block_4444_ABGR - convert_16_table
        DCD   asm_colour_convert_block_4444_ARGB - convert_16_table
        DCD   asm_colour_convert_block_1555_TBGR - convert_16_table
        DCD   asm_colour_convert_block_1555_TRGB - convert_16_table
        DCD   asm_colour_convert_block_1555_ABGR - convert_16_table
        DCD   asm_colour_convert_block_1555_ARGB - convert_16_table
        DCD   asm_colour_convert_block_565_BGR - convert_16_table
        DCD   asm_colour_convert_block_565_RGB - convert_16_table

        ; 4444 formats
        
red_bits      SETA 4
green_bits    SETA 4
blue_bits     SETA 4
red_shift     SETA 0
green_shift   SETA 4
blue_shift    SETA 8
alpha_value   SETA 0
function_name SETS "asm_colour_convert_block_4444_TBGR"
        GET     jdcolor16
alpha_value   SETA &F000
function_name SETS "asm_colour_convert_block_4444_ABGR"
        GET     jdcolor16
red_shift     SETA 8
blue_shift    SETA 0
function_name SETS "asm_colour_convert_block_4444_ARGB"
        GET     jdcolor16
alpha_value   SETA 0
function_name SETS "asm_colour_convert_block_4444_TRGB"
        GET     jdcolor16

        ; 1555 formats
        
red_bits      SETA 5
green_bits    SETA 5
blue_bits     SETA 5
red_shift     SETA 0
green_shift   SETA 5
blue_shift    SETA 10
alpha_value   SETA 0
function_name SETS "asm_colour_convert_block_1555_TBGR"
        GET     jdcolor16
alpha_value   SETA &8000
function_name SETS "asm_colour_convert_block_1555_ABGR"
        GET     jdcolor16
red_shift     SETA 10
blue_shift    SETA 0
function_name SETS "asm_colour_convert_block_1555_ARGB"
        GET     jdcolor16
alpha_value   SETA 0
function_name SETS "asm_colour_convert_block_1555_TRGB"
        GET     jdcolor16

        ; 565 formats
        
red_bits      SETA 5
green_bits    SETA 6
blue_bits     SETA 5
red_shift     SETA 0
green_shift   SETA 5
blue_shift    SETA 11
function_name SETS "asm_colour_convert_block_565_BGR"
        GET     jdcolor16
red_shift     SETA 11
blue_shift    SETA 0
function_name SETS "asm_colour_convert_block_565_RGB"
        GET     jdcolor16


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; YUV->RGB colour conversion 8bpp
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        ; Similar in structure to 32bpp and 16bpp output, except that 8bpp (VIDC1) pixels
        ; are generated.

        ; A macro to generate an 8bpp pixel from YUV values, and subtract the actual value
        ; of that pixel from the YUV values.
        ; r12 holds the lookup table (yuv->pixel, approximate)
        ; r11 holds the palette (pixel->yuv)
        MACRO
        Generate8bitFromYUV   $y,$u,$v,$pixel,$temp,$dest
        MOVS    $temp,$v,ASR #8-yuvtab_vbits                  ; get relevant bits of v
        MOVS    $pixel,$u,ASR #8-yuvtab_ubits                 ; get relevant bits of u
        ORR     $pixel,$temp,$pixel,LSL #yuvtab_vbits         ; combine u and v
        MOVS    $temp,$y,ASR #8-yuvtab_ybits                  ; get relevant bits of v
        ORR     $pixel,$pixel,$temp,LSL #yuvtab_ubits+yuvtab_vbits ; combine y, u, v
        LDRB    $pixel,[r12,$pixel]                           ; get the pixel value
        STRB    $pixel,$dest                                  ; store the pixel
        LDR     $pixel,[r11,$pixel,LSL #2]                    ; get real yuv value, as word &0YUV
        AND     $temp,$pixel,#&ff                             ; get real v value
        SUB     $v,$v,$temp                                   ; subtract it from v
        AND     $temp,$pixel,#&ff00                           ; get real u value
        SUB     $u,$u,$temp,LSR #8                            ; subtract it from u
        SUB     $y,$y,$pixel,LSR #16                          ; subtract it from y
        MEND

        ; The yuv values are SCALEBITS up in their respective words, in the approximate range
        ; (0..255):SHL:SCALEBITS.
        ; Get a Y, U or V value from the given location, subtract 128 from it,
        ; add it to the cumulative error so far in that gun.
        MACRO
        GetColourValue $reg,$loc,$temp
        LDR     $temp,$loc                                    ; get the value into temp register - shifted up SCALEBITS
        ADD     $temp,$temp,#128:SHL:SCALEBITS                ; make it in approx range 0..256
        ADDS    $reg,$reg,$temp,ASR #SCALEBITS                ; add it to error so far
        Clamp   $reg,8
        MEND

      [ :LNOT: cfsi_jpeg
        GET     yuvtabs.s

        ; extern char *pixel_to_yuv_table_base(void)
        ; Returns the relocated address of the pixel to YUV table
        EXPORT  pixel_to_yuv_table_base
pixel_to_yuv_table_base
        ADRL    r0, pixel_to_yuv_table
        MOV     pc, lr

        ; extern int *yuv_to_pixel_table_base(void)
        ; Returns the relocated address of the YUV to pixel table
        EXPORT  yuv_to_pixel_table_base
yuv_to_pixel_table_base
        ADRL    r0, yuv_to_pixel_table
        MOV     pc, lr
      ]
      
        ; extern void asm_colour_convert_block_8(JCOEF *yuv, char *outptr, int outoffset)
        ; /* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block of 8bit pixels */
        ;   r0 -> the six blocks, YYYYUV (all row-ordered, ie 'wrong' way round, different from output)
        ;   r1 -> output buffer
        ;   r2 = offset in words between rows of output
        ; the output goes in outptr[row*outoffset + col] for row/col in 0..15
        EXPORT  asm_colour_convert_block_8
asm_colour_convert_block_8
      [ cfsi_jpeg
        MOV     pc,lr                       ; referenced from C code, but never used.
      |
        STMDB   sp!,{r0-r1,r4-r11,lr}       ; save state
        ADD     r3,r1,#(2*DCTSIZE)*1        ; column limit pointer (inner loop) - outptr+16 bytes
        ADD     r4,r1,r2,LSL #3+2           ; row limit pointer (outer loop) - outptr+8*outoffset words
        ADD     r5,r0,#4*DCTSIZE2*4         ; pointer into U block. V values DCTSIZE2 words on from this
        ADD     r6,r4,r2,LSL #3+2           ; real row limit pointer - outptr+16*outoffset words

        STMIA   sp,{r4,r6}                  ; r4 and r6 used as temp workspace during the colour conversion:
                                            ; we never need to reload r0/r1, so use these stack locations.

        ADRL    r12,yuv_to_pixel_table
        ADRL    r11,pixel_to_yuv_table
        MOV     r7,#0                       ; cumulative error in U so far
        MOV     r8,#0                       ; cumulative error in V so far
        MOV     r9,#0                       ; cumulative error in Y so far

        ; The main loop goes round once for each 2*2 square of four output pixels, using
        ; four Y values, one U value, one V value.
jc_colour_loop8                             ; each two rows and each two columns of output

        ; do four output pixels, using:
        ; [r5] is U value
        ; [r5,#DCTSIZE2*4] is V value
        ; [r0] and [r0,#DCTSIZE*4] are Y values for output word [r1]
        ; [r0,#4] and [r0,#DCTSIZE*4+4] are Y values for output word [r1,r2,LSL #2]

        GetColourValue r7,"[r5]",r4              ; U value
        GetColourValue r8,"[r5,#DCTSIZE2*4]",r4  ; V value
        GetColourValue r9,"[r0,#4]",r4           ; Y value
        Generate8bitFromYUV r9,r7,r8,r4,r6,"[r1,r2,LSL #2]"

        GetColourValue r7,"[r5]",r4              ; U value
        GetColourValue r8,"[r5,#DCTSIZE2*4]",r4  ; V value
        GetColourValue r9,"[r0]",r4              ; Y value
        Generate8bitFromYUV r9,r7,r8,r4,r6,"[r1]"
        ADD     r1,r1,#1

        ; Next two pixels done in a swapped order, so we do a little U around the square of four
        ; pixels - this seems to reduce the amount of horizontal-line effect that you get.

        GetColourValue r7,"[r5]",r4              ; U value
        GetColourValue r8,"[r5,#DCTSIZE2*4]",r4  ; V value
        GetColourValue r9,"[r0,#DCTSIZE*4]",r4   ; Y value
        Generate8bitFromYUV r9,r7,r8,r4,r6,"[r1]"

        GetColourValue r7,"[r5]",r4              ; U value
        GetColourValue r8,"[r5,#DCTSIZE2*4]",r4  ; V value
        GetColourValue r9,"[r0,#DCTSIZE*4+4]",r4 ; Y value
        Generate8bitFromYUV r9,r7,r8,r4,r6,"[r1,r2,LSL #2]"
        ADD     r1,r1,#1

        ; increment pointers to go two pixels along an output row
        ; r1 (output pointer) already updated
        ADD     r5,r5,#DCTSIZE*4            ; pointer into row-organised U,V values
        ADD     r0,r0,#2*DCTSIZE*4          ; ditto for Y values

        ; check for end of row
        CMP     r1,r3                       ; output pointer reached end of output row?
        BNE     jc_colour_loop8             ; go round for next column

        ; Amazingly there is no special action to take half-way along each output row,
        ; when we switch from one Y block to the next - because of the ordering and
        ; arrangement of the Y blocks, it just acts as a single 8*16 block.

        ; It's the end of the row. Update all input and output pointers to
        ; advance to next one.
        ADD     r1,r1,r2,LSL #2+1           ; advance output ptr by two output rows
        SUB     r1,r1,#2*DCTSIZE*1          ;      ... and then to beginning of next output row.
        SUB     r5,r5,#(DCTSIZE2*4-4)*1     ; advance UV pointer to start of next row
        SUB     r0,r0,#(DCTSIZE2*4-4)*2     ; ditto Y pointer, but back two blocks
        ADD     r3,r1,#2*DCTSIZE*1          ; reset column limit pointer (inner loop) - outptr+16 bytes

        ; zero cumulative error on Y U V registers
        MOV     r7,#0
        MOV     r8,#0
        MOV     r9,#0

        ; Check for having to change to the second pair of Y blocks, or terminate
        LDMIA   sp,{r4,r6}                  ; reload loop end test registers
        CMP     r1,r4
        BNE     jc_colour_loop8             ; normal case - we set off on another two rows of output

        ; It's either the half-way point, in which case we need to change to the second pair
        ; of input Y blocks, or it's the end. Test r4 against the 'real' limit pointer.

        CMP     r4,r6                       ; is this the end?
        LDMEQIA sp!,{r0-r1,r4-r11,pc}       ; if so, return - nothing more to do

        ; We've reached the half-way point.
        MOV     r4,r6                       ; next time we test r4 and r6, exit.
        STR     r4,[sp]                     ; remember for final termination
        ADD     r0,r0,#((2*DCTSIZE2)-DCTSIZE)*4  ; advance r0 from end of row 0 of block 0,
                                            ; to start of row 0 of block 2.
        B       jc_colour_loop8             ; and continue.
      ]

        END
@


4.2
log
@Add support for new sprite types & screen modes
Detail:
  Makefile - Updated to fix a couple of dependency issues and to make c/asmcore the main C file, not c/putscaled
  Sources/PutScaled - Add a utility routine that's used by the C code to get information about pixel formats
  Sources/SprAdjSize - Add support for wide masks & RISC OS 5 style sprite mode words
  Sources/SprExtend - Tidy up workspace by removing lots of unused bits and moving other bits within sight of the C code. Add flag to control whether C or assembler version of SprTrans is used. Query kernel for ECFYOffset/ECHShift locations instead of using hardcoded values in putscaled code. Add fix for garbage debug strings in softloaded debug versions of the module.
  Sources/SprOp - Add support for wide masks & RISC OS 5 style sprite mode words. Update makepalette16bpp to cope with all the new 16bpp modes. Flag_* -> ModeFlag_* renaming. Move some translation table handling code into a new routine, 'preparettr'. Update checktrans/converttrans to deal with new pixel formats.
  Sources/SprTrans - If the C version of SprTrans is enabled, disable all of these assembler bits except for the outer loop which steps over each row of the screen
  Sources/jdcolor - Updated to deal with new pixel formats. 16bpp conversion code split off into new file, Sources/jdcolor16.
  Sources/jdcolor16 - New file containing the guts of the YUV -> 16bpp conversion code. Gets included multiple times with different options to generate the different conversion routines (code is too big for a macro).
  c/asmcore - New file containing lots of common code ripped out of c/PutScaled - e.g. workspace definition, main functions for register assignment & instruction generation, and code for pixel format conversion. Pixel format conversion code rewritten to cope with new pixel formats, and code buffer key word generation rewritten to fix a couple of bugs (e.g. some issues with dithering options were observed)
  c/PutScaled - Ripped out lots of code that's now in c/asmcore. Now just deals with things that are PutScaled-specific, e.g. main plotter loop containing pixel read/write code. Code extended to cope with new pixel formats
  c/rojpeg, h/jinclude, h/jpegdata - Code extended to cope with new 16bpp conversion routines
  c/sprtrans - New C implementation of the core per-row transformed sprite plotting code generator. Allows reuse of the extensive pixel conversion code in c/asmcore, and allows for better code generation than the assembler original.
  h/putscaled - Worksapce definition updated to match assembler version
Admin:
  Tested on BB-xM, plotting lots of different sprites in lots of different modes
  Plotting of wide mask sprites not supported yet
  C version of YUV -> 16bpp code currently only deals with traditional &BGR 555 pixel format - code is aware of this and will do conversion to desired format if applicable (although quality may be reduced)
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 1.52. Tagged as 'SprExtend-1_52'
@
text
@@


4.1
log
@Adopt colour conversions from MigrateIJG8b branch
Now for every colour conversion there is a corresponding C function, allowing swapping between them for test purposes.
Here, 'ASMCOLOR' is selected and the C functions not even referenced in the makefile, see branch for use.
Permits use of USAT, for a small 1.5% speedup and smaller code.
Some other typedefs and comment shuffling copied over - should be harmless.

Version 1.50. Tagged as 'SprExtend-1_50'
@
text
@d74 18
d205 1
a205 1
        ; then normalise the result to be a value in 0..255.
d208 1
a208 1
        NormaliseGun $op,$gun,$y,$gunsrc
d210 2
a211 2
        MOVS    $gun,$gun,ASR #SCALEBITS    ; truncate
        Clamp   $gun,8
d430 3
a432 3
        NormaliseGun ADD,r12,r7,r9          ; B
        NormaliseGun ADD,lr,r7,r10          ; R
        NormaliseGun SUB,r7,r7,r11          ; G
d437 3
a439 3
        NormaliseGun ADD,r12,r8,r9          ; B
        NormaliseGun ADD,lr,r8,r10          ; R
        NormaliseGun SUB,r8,r8,r11          ; G
d448 3
a450 3
        NormaliseGun ADD,r12,r7,r9          ; B
        NormaliseGun ADD,lr,r7,r10          ; R
        NormaliseGun SUB,r7,r7,r11          ; G
d455 3
a457 3
        NormaliseGun ADD,r12,r8,r9          ; B
        NormaliseGun ADD,lr,r8,r10          ; R
        NormaliseGun SUB,r8,r8,r11          ; G
d513 30
a542 16
        ; Almost identical to the 32bpp case above, except that 16bit pixels are generated.
        ; An ordered dither is added to this using Bayer's ordered dither matrix of
        ; of D2 = [ 3   1 ]
        ;         [ 0   2 ]
        ; Really only good for 1:1 plotting in 16bpp, thus a block copy can move it to the
        ; screen, and the whole thing is a great deal faster.

        ; combine the y value of r/g/b with the value derived from u and v.
        ; then normalise the result to be a value in 0..31.
        ; $y holds the y value, $gunsrc the value from u and v, result in $gun.
        MACRO
        NormaliseGun16 $op,$gun,$y,$gunsrc
        $op     $gun,$y,$gunsrc             ; R/G/B, at SCALEBITS bits
        MOVS    $gun,$gun,ASR #SCALEBITS+3  ; truncate
        Clamp   $gun,5
        MEND
d544 11
a554 16
        ; extern void asm_colour_convert_block_16(JCOEF *yuv, short *outptr, int outoffset)
        ; /* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block of 16bit pixels */
        ;   r0 -> the six blocks, YYYYUV (all row-ordered, ie 'wrong' way round, different from output)
        ;   r1 -> output buffer
        ;   r2 = offset in words between rows of output
        ; the output goes in outptr[row*outoffset + col] for row/col in 0..15
        EXPORT  asm_colour_convert_block_16
asm_colour_convert_block_16
        STMDB   sp!,{r0-r1,r4-r11,lr}       ; save state
        ADD     r3,r1,#(2*DCTSIZE)*2        ; column limit pointer (inner loop) - outptr+16 halfwords
        ADD     r4,r1,r2,LSL #3+2           ; row limit pointer (outer loop) - outptr+8*outoffset words
        ADD     r5,r0,#4*DCTSIZE2*4         ; pointer into U block. V values DCTSIZE2 words on from this
        ADD     r6,r4,r2,LSL #3+2           ; real row limit pointer - outptr+16*outoffset words

        STMIA   sp,{r4,r6}                  ; r4 and r6 used as temp workspace during the colour conversion:
                                            ; we never need to reload r0/r1, so use these stack locations.
d556 1
a556 25
        ; The main loop goes round once for each 2*2 square of four output pixels, using
        ; four Y values, one U value, one V value.
jc_colour_loop16                            ; each two rows and each two columns of output

        ; do four output pixels, using:
        ; [r5] is U value
        ; [r5,#DCTSIZE2*4] is V value
        ; [r0] and [r0,#DCTSIZE*4] are Y values for output word [r1]
        ; [r0,#4] and [r0,#DCTSIZE*4+4] are Y values for output word [r1,r2,LSL #2]

        ; first we compute the values derived from U and V, which are
        ; true for all four pixels.
        LDR     r7,[r5]                     ; U value
        MOV     r7,r7,ASR #8                ; the multiplies will get us back to SCALEBITS again
        LDR     r8,[r5,#DCTSIZE2*4]         ; V value
        MOV     r8,r8,ASR #8                ; the multiplies will get us back to SCALEBITS again
        ; Should add 1:SHL:7 before ASR #8, but not regarded as significant enough
        ; considering how much bigger SCALEBITS is.

        ; Multiply sequences generated by cc 4.50, for 8 bits of accuracy.
        ; these sequences lead to a result shifted left by 8 bits.
        ;MulCon r9,r7,FIX(1.77200)          ; B, without the Y yet
        ADD     r9,r7,r7,LSL #5
        RSB     r9,r9,r7,LSL #8
        SUB     r9,r9,r7,LSL #3             ; still needs a LSL #1
d558 19
a576 4
        ;MulCon r10,r8,FIX(1.40200)         ; R, without the Y yet
        ADD     r10,r8,r8,LSL #5
        RSB     r10,r10,r10,LSL #3
        ADD     r10,r10,r8,LSL #7
d578 1
a578 18
        ;MulCon r12,r8,-FIX(0.71414)
        RSB     r12,r8,r8,LSL #6
        ADD     r12,r12,r8,LSL #7
        SUB     r12,r12,r8,LSL #3

        ;MulCon r11,r7,-FIX(0.34414)
        ADD     r11,r7,r7,LSL #1
        ADD     r11,r11,r7,LSL #3           ; LSL #3 still needed - see below
        ADD     r11,r12,r11,LSL #3          ; -G, without the Y yet

        ; After those multiplies, the values are shifted up by SCALEBITS again.
        ; We're going to add each of r9/r10/r11 to the Y values.
        ; The Y values need 128 added to them - add it at this point.
        ; need to add a half for the truncation of NormaliseGun16 - do that at the same time.
        MOV     r7,#(ONE_HALF:SHL:3) + (128:SHL:SCALEBITS)
        ADD     r9,r7,r9,LSL #1             ; LSL #1 still owed to R9 - see above.
        ADD     r10,r7,r10
        RSB     r11,r7,r11                  ; r11 is to be subtracted from Y, not added.
d580 19
a598 15
        ; now process the four pixels one at a time.
        LDMIA   r0,{r7,r8}                  ; first two Y values, shifted up by SCALEBITS
        ;ADD    r7,r7,#0:SHL:SCALEBITS      ; ordered dither
        ADD     r8,r8,#4:SHL:SCALEBITS      ; ordered dither
        NormaliseGun16 ADD,r12,r7,r9        ; B
        NormaliseGun16 ADD,lr,r7,r10        ; R
        NormaliseGun16 SUB,r7,r7,r11        ; G
        ORR     r7,lr,r7,LSL #5             ; G and R
        ORR     r4,r7,r12,LSL #10           ; complete output pixel

        NormaliseGun16 ADD,r12,r8,r9        ; B
        NormaliseGun16 ADD,lr,r8,r10        ; R
        NormaliseGun16 SUB,r8,r8,r11        ; G
        ORR     r8,lr,r8,LSL #5             ; G and R
        ORR     r6,r8,r12,LSL #10           ; complete output pixel
d600 1
a600 1
        ADD     r7,r0,#DCTSIZE*4            ; prepare to load next two pixels
d602 12
a613 28
        LDMIA   r7,{r7,r8}                  ; other two pixels
        ADD     r7,r7,#6:SHL:SCALEBITS      ; ordered dither
        ADD     r8,r8,#2:SHL:SCALEBITS      ; ordered dither
        NormaliseGun16 ADD,r12,r7,r9        ; B
        NormaliseGun16 ADD,lr,r7,r10        ; R
        NormaliseGun16 SUB,r7,r7,r11        ; G
        ORR     r7,lr,r7,LSL #5             ; G and R
        ORR     r7,r7,r12,LSL #10           ; complete output pixel
        ORR     r7,r4,r7,LSL #16            ; combine two pixels
        STR     r7,[r1]                     ; output two pixels

        NormaliseGun16 ADD,r12,r8,r9        ; B
        NormaliseGun16 ADD,lr,r8,r10        ; R
        NormaliseGun16 SUB,r8,r8,r11        ; G
        ORR     r8,lr,r8,LSL #5             ; G and R
        ORR     r8,r8,r12,LSL #10           ; complete output pixel
        ORR     r8,r6,r8,LSL #16            ; combine the two pixels
        STR     r8,[r1,r2,LSL #2]           ; output pixel
        ADD     r1,r1,#4

        ; increment pointers to go two pixels along an output row
        ; r1 (output pointer) already updated
        ADD     r5,r5,#DCTSIZE*4            ; pointer into row-organised U,V values
        ADD     r0,r0,#2*DCTSIZE*4          ; ditto for Y values

        ; check for end of row
        CMP     r1,r3                       ; output pointer reached end of output row?
        BNE     jc_colour_loop16            ; go round for next column
a614 29
        ; Amazingly there is no special action to take half-way along each output row,
        ; when we switch from one Y block to the next - because of the ordering and
        ; arrangement of the Y blocks, it just acts as a single 8*16 block.

        ; It's the end of the row. Update all input and output pointers to
        ; advance to next one.
        ADD     r1,r1,r2,LSL #2+1           ; advance output ptr by two output rows
        SUB     r1,r1,#2*DCTSIZE*2          ;      ... and then to beginning of next output row.
        SUB     r5,r5,#(DCTSIZE2*4-4)*1     ; advance UV pointer to start of next row
        SUB     r0,r0,#(DCTSIZE2*4-4)*2     ; ditto Y pointer, but back two blocks
        ADD     r3,r1,#2*DCTSIZE*2          ; reset column limit pointer (inner loop) - outptr+16 halfwords

        ; Check for having to change to the second pair of Y blocks, or terminate
        LDMIA   sp,{r4,r6}                  ; reload loop end test registers
        CMP     r1,r4
        BNE     jc_colour_loop16            ; normal case - we set off on another two rows of output

        ; It's either the half-way point, in which case we need to change to the second pair
        ; of input Y blocks, or it's the end. Test r4 against the 'real' limit pointer.

        CMP     r4,r6                       ; is this the end?
        LDMEQIA sp!,{r0-r1,r4-r11,pc}       ; if so, return - nothing more to do

        ; We've reached the half-way point.
        MOV     r4,r6                       ; next time we test r4 and r6, exit.
        STR     r4,[sp]                     ; remember for final termination
        ADD     r0,r0,#((2*DCTSIZE2)-DCTSIZE)*4  ; advance r0 from end of row 0 of block 0,
                                            ; to start of row 0 of block 2.
        B       jc_colour_loop16            ; and continue.
@


1.1
log
@file jdcolor was initially added on branch MigrateIJG8b.
@
text
@d1 820
@


1.1.2.1
log
@Fix CFSIjpeg due to earlier rename of jidctfst
Rename remaining files to match IJG 8b.

Version 1.38, 1.35.2.5. Tagged as 'SprExtend-1_38-1_35_2_5'
@
text
@a0 702
; Copyright 2011 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.jdcolor (formerly jcconv)

; JPEG Colour conversion facilities
;   started 24-Sep-93 WRS
;   called from c.rojpeg - C equivalents of these functions can also be found there.

; ******************************************************************************
; *                                                                            *
; *   Monochrome colour conversion                                             *
; *                                                                            *
; ******************************************************************************

        ; Do descaling etc. for a mono pixel
        MACRO
        MonoConv $r
        ADD     $r,$r,#1:SHL:18          ; ready to cut off 19 bits
        ADDS    $r,r12,$r,ASR #19        ; add 128, cut off 19 bits
        MOVLT   $r,#0                    ; if result < 0, cut off at 0
        CMP     $r,#255
        MOVGT   $r,#255                  ; if result > 255, cut off at 255.
        ORR     $r,$r,$r,LSL #8          ; replicate grey value in each of R, G, B
        ORR     $r,$r,$r,LSL #8
        MEND

        ; Do descaling etc. for a mono pixel
        MACRO
        MonoConv8 $r
        ADD     $r,$r,#1:SHL:18          ; ready to cut off 19 bits
        ADDS    $r,r12,$r,ASR #19        ; add 128, cut off 19 bits
        MOVLT   $r,#0                    ; if result < 0, cut off at 0
        CMP     $r,#255
        MOVGT   $r,#255                  ; if result > 255, cut off at 255.
        MEND

; extern void asm_mono_convert_block(JBLOCK jblock, int *outptr, int outoffset)
; /* Convert greyscale image into 32bit RGB values. */
;   r0 = jblock - in row order, values that need descaling
;   r1 = outptr - in column order, put RGB values here
;   r2 = outoffset - distance (in words) between output rows.
;   r11 = col counter.
; We LDR from the block and STM to the output rather than visa versa,
; because a long sequence of STRs clogs up the write buffer and is slow.
        EXPORT  asm_mono_convert_block
asm_mono_convert_block
        STMDB   sp!,{r0-r12,lr}             ; save state
        MOV     r11,#8                      ; col counter
        MOV     r12,#128                    ; required constant

jc_mono_loop
        LDR     r3,[r0,#8*4*0]              ; get a whole row
        LDR     r4,[r0,#8*4*1]              ; interleave order hopes to help ARM8!
        MonoConv r3
        LDR     r5,[r0,#8*4*2]
        MonoConv r4
        LDR     r6,[r0,#8*4*3]
        MonoConv r5
        LDR     r7,[r0,#8*4*4]
        MonoConv r6
        LDR     r8,[r0,#8*4*5]
        MonoConv r7
        LDR     r9,[r0,#8*4*6]
        MonoConv r8
        LDR     r10,[r0,#8*4*7]
        MonoConv r9
        MonoConv r10

        STMIA   r1,{r3-r10}                 ; store a row
        ADD     r1,r1,r2,LSL #2             ; add row offset to output pointer
        ADD     r0,r0,#4                    ; advance input pointer
        SUBS    r11,r11,#1                  ; outer loop
        BNE     jc_mono_loop

        LDMIA   sp!,{r0-r12,pc}             ; return

; extern void asm_mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset)
; /* Convert greyscale image into 8bit Grey values. */
;   r0 = jblock - in row order, values that need descaling
;   r1 = outptr - in column order, put grey values here
;   r2 = outoffset - distance (in words) between output rows.
;   r11 = col counter.
; We LDR from the block and STM to the output rather than visa versa,
; because a long sequence of STRs clogs up the write buffer and is slow.
        EXPORT  asm_mono_convert_block_8
asm_mono_convert_block_8
        STMDB   sp!,{r0-r12,lr}             ; save state
        MOV     r11,#8                      ; col counter
        MOV     r12,#128                    ; required constant

jc_mono_loop8
        LDR     r3,[r0,#8*4*0]              ; get a whole row
        LDR     r4,[r0,#8*4*1]              ; interleave order hopes to help ARM8!
        MonoConv8 r3
        LDR     r5,[r0,#8*4*2]
        MonoConv8 r4
        ORR     r3,r3,r4,LSL #8
        LDR     r6,[r0,#8*4*3]
        MonoConv8 r5
        ORR     r3,r3,r5,LSL #16
        LDR     r7,[r0,#8*4*4]
        MonoConv8 r6
        ORR     r3,r3,r6,LSL #24
        LDR     r8,[r0,#8*4*5]
        MonoConv8 r7
        LDR     r9,[r0,#8*4*6]
        MonoConv8 r8
        ORR     r7,r7,r8,LSL #8
        LDR     r10,[r0,#8*4*7]
        MonoConv8 r9
        ORR     r7,r7,r9,LSL #16
        MonoConv8 r10
        ORR     r7,r7,r10,LSL #24

        STMIA   r1,{r3,r7}                  ; store a row
        ADD     r1,r1,r2,LSL #2             ; add row offset to output pointer
        ADD     r0,r0,#4                    ; advance input pointer
        SUBS    r11,r11,#1                  ; outer loop
        BNE     jc_mono_loop8

        LDMIA   sp!,{r0-r12,pc}             ; return

; ******************************************************************************
; *                                                                            *
; *   YUV->RGB colour conversion.                                              *
; *                                                                            *
; ******************************************************************************

; Given four 8*8 Y blocks and one block each of U and V, create 16*16 output
; RGB pixels.

; All values in DCT blocks are scaled up by SCALEBITS bits.
SCALEBITS * 19
ONE_HALF  * (1:SHL:SCALEBITS):SHR:1

; combine the y value of r/g/b with the value derived from u and v.
; then normalise the result to be a value in 0..255.
; $y holds the y value, $gunsrc the value from u and v, result in $gun.
        MACRO
        NormaliseGun $op,$gun,$y,$gunsrc
        $op     $gun,$y,$gunsrc             ; R/G/B, at 19 bits
        MOVS    $gun,$gun,ASR #SCALEBITS    ; truncate
        MOVLT   $gun,#0
        CMP     $gun,#255
        MOVGT   $gun,#255
        MEND

; static void colour_convert_block(JCOEF *yuv, int *outptr, int outoffset)
; /* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block */
;   r0 -> the six blocks, YYYYUV (all row-ordered, ie 'wrong' way round, different from output)
;   r1 -> output buffer
;   r2 = offset in words between rows of output
; the output goes in outptr[row*outoffset + col] for row/col in 0..15
        EXPORT  asm_colour_convert_block
asm_colour_convert_block
        STMDB   sp!,{r0-r12,lr}             ; save state
;        Debug   gs,"in colour_convert_block"
        ADD     r3,r1,#16*4                 ; column limit pointer (inner loop) - outptr+16 words
        ADD     r4,r1,r2,LSL #3+2           ; row limit pointer (outer loop) - outptr+8*outoffset words
        ADD     r5,r0,#4*64*4               ; pointer into U block. V values 64 words on from this
        ADD     r6,r4,r2,LSL #3+2           ; real row limit pointer - outptr+16*outoffset words

; The main loop goes round once for each 2*2 square of four output pixels, using
; four Y values, one U value, one V value.
jc_colour_loop                              ; each two rows and each two columns of output

        ; do four output pixels, using:
        ; [r5] is U value
        ; [r5,#64*4] is V value
        ; [r0] is Y value for output word [r1]
        ; [r0,#4] is Y value for output word [r1,r2,LSL #2]
        ; [r0,#8*4] is Y value for output word [r1,#4]
        ; [r0,#8*4+4] is Y value for output word [r1,#4 + r2,LSL #2] (so to speak!)

        ; first we compute the values derived from U and V, which are
        ; true for all four pixels.
        LDR     r7,[r5]                     ; U value
        MOV     r7,r7,ASR #8                ; the multiplies will get us back to SCALEBITS again
        LDR     r8,[r5, #64*4]              ; V value
        MOV     r8,r8,ASR #8                ; the multiplies will get us back to SCALEBITS again
        ; Should add 1:SHL:7 before ASR #8, but not regarded as significant enough
        ; considering how much bigger SCALEBITS is.

        ; Multiply sequences generated by cc 4.50, for 8 bits of accuracy.
        ; these sequences lead to a result shifted left by left by 8 bits.
        ;MulCon  r9,r7,FIX(1.77200)          ; B, without the Y yet
        ADD      r9,r7,r7,LSL #5
        RSB      r9,r9,r7,LSL #8
        SUB      r9,r9,r7,LSL #3             ; still needs a LSL #1

        ;MulCon  r10,r8,FIX(1.40200)         ; R, without the Y yet
        ADD     r10,r8,r8,LSL #5
        RSB     r10,r10,r10,LSL #3
        ADD     r10,r10,r8,LSL #7

        ;MulCon  r11,r7,-FIX(0.34414)
        ADD     r11,r7,r7,LSL #1
        ADD     r11,r11,r7,LSL #3            ; LSL #3 still needed - see below

        ;MulCon  r12,r8,-FIX(0.71414)
        RSB     r12,r8,r8,LSL #6
        ADD     r12,r12,r8,LSL #7
        SUB     r12,r12,r8,LSL #3

        ; After those multiplies, the values are shifted up by SCALEBITS again.
        ; scratch r7,r8
        ADD     r11,r12,r11,LSL #3          ; -G, without the Y yet - did the LSL #3, see above.
        ; scratch r12

        ; We're going to add each of r9/r10/r11 to the Y values.
        ; The Y values need 128 added to them - add it at this point.
        ; need to add a half for the truncation - do that at the same time.
        ; We'll be truncating at SCA
        MOV     r7,#ONE_HALF                ; construct constant - can't quite be done in one instruction.
        ADD     r7,r7,#128:SHL:SCALEBITS
        ADD     r9,r7,r9,LSL #1             ; LSL #1 still owed to R9 - see above.
        ADD     r10,r10,r7
        SUB     r11,r11,r7                  ; r11 is to be subtracted from Y, not added.

        ; now process the four pixels one at a time.
        LDMIA   r0,{r7,r8}                  ; first two Y values, shifted up by SCALEBITS
        NormaliseGun ADD,r12,r7,r9          ; B
        NormaliseGun ADD,lr,r7,r10          ; R
        NormaliseGun SUB,r7,r7,r11          ; G
        ORR     r7,lr,r7,LSL #8             ; G and R
        ORR     r7,r7,r12,LSL #16           ; complete output pixel
        STR     r7,[r1]                     ; output pixel
;        Debug   gs,"conp = ",r7
        
        NormaliseGun ADD,r12,r8,r9          ; B
        NormaliseGun ADD,lr,r8,r10          ; R
        NormaliseGun SUB,r8,r8,r11          ; G
        ORR     r8,lr,r8,LSL #8             ; G and R
        ORR     r8,r8,r12,LSL #16           ; complete output pixel
        STR     r8,[r1,r2,LSL #2]           ; output pixel
        ADD     r1,r1,#4

        ADD     r7,r0,#8*4                  ; prepare to load next two pixels
        LDMIA   r7,{r7,r8}                  ; other two pixels
        NormaliseGun ADD,r12,r7,r9          ; B
        NormaliseGun ADD,lr,r7,r10          ; R
        NormaliseGun SUB,r7,r7,r11          ; G
        ORR     r7,lr,r7,LSL #8             ; G and R
        ORR     r7,r7,r12,LSL #16           ; complete output pixel
        STR     r7,[r1]                     ; output pixel

        NormaliseGun ADD,r12,r8,r9          ; B
        NormaliseGun ADD,lr,r8,r10          ; R
        NormaliseGun SUB,r8,r8,r11          ; G
        ORR     r8,lr,r8,LSL #8             ; G and R
        ORR     r8,r8,r12,LSL #16           ; complete output pixel
        STR     r8,[r1,r2,LSL #2]           ; output pixel
        ADD     r1,r1,#4

        ; increment pointers to go two pixels along an output row
        ; r1 (output pointer) already updated
        ADD     r5,r5,#8*4                  ; pointer into row-organised U,V values
        ADD     r0,r0,#2*8*4                ; ditto for Y values

        ; check for end of row
        CMP     r1,r3                       ; output pointer reached end of output row?
        BNE     jc_colour_loop              ; go round for next column

        ; Amazingly there is not special action to take half-way along each output row,
        ; when we switch from one Y block to the next - because of the ordering and
        ; arrangement of the Y blocks, it just acts as a single 8*16 block.

        ; It's the end of the row. Update all input and output pointers to
        ; advance to next one.
        ADD     r1,r1,r2,LSL #2+1           ; advance output ptr by two output rows
        SUB     r1,r1,#16*4                 ;      ... and then to beginning of next output row.
        SUB     r5,r5,#64*4-4               ; advance UV pointer to start of next row
        SUB     r0,r0,#2*64*4-8             ; ditto Y pointer, but back two blocks
        ADD     r3,r1,#16*4                 ; reset column limit pointer (inner loop) - outptr+16 words

        ; Check for having to change to the second pair of Y blocks, or terminate
        CMP     r1,r4
        BNE     jc_colour_loop              ; normal case - we set off on another two rows of output

        ; It's either the half-way point, in which case we need to change to the second pair
        ; of input Y blocks, or it's the end. Test r4 against the 'real' limit pointer.

        CMP     r4,r6                       ; is this the end?
        LDMEQIA sp!,{r0-r12,pc}             ; if so, return - nothing more to do

        ; We've reached the half-way point.
        MOV     r4,r6                       ; next time we test r4 and r6, exit.
        ADD     r0,r0,#7*8*4+8*8*4          ; advance r0 from end of row 0 of block 0,
                                            ; to start of row 0 of block 2.
        B       jc_colour_loop              ; and continue.

; Performance notes for colour conversion.
; approx number of ticks for 4 pixels:
;    7        loop etc.
;   23        common work on the UV values
;   40        loading/storing,combining gun values
;   52        normalising gun values
;   --
;  122/4 = 30.5 per pixel.

; Could a register to hold &101, saves 1 per pixel.

; How common is <0 and >255? If rare,
; test all at once (easy on <0, harder for >255)
;   and do a B if there's a problem.
; Not QUITE worth it, overflow about 5% of the time.

; Lookup tables don't save much - 3 instructions becomes a LDR.
; Could replace whole 'normalise' by a single LDR? Not QUITE worth it.
; A lookup for the entire computation, indexed by Y and U and V, saves quite
; a lot. BUT, 5 bits of U and V is insufficient, in smoothly shaded pictures
; (after a brief experiment). 6 bits each makes a .5MB table, too big!

; ******************************************************************************
; *                                                                            *
; *   YUV->32bpp grey conversion.                                              *
; *                                                                            *
; ******************************************************************************

; Given four 8*8 Y blocks and one block each of U and V, create 16*16 output
; RGB pixels.


; ******************************************************************************
; *                                                                            *
; *   YUV->RGB colour conversion for 16bpp output                              *
; *                                                                            *
; ******************************************************************************

; Almost identical to the 32bpp case above, except that 16bit pixels are generated.
; An ordered dither is added to this - really only good for 1:1 plotting in 16bpp.
; Thus, a block copy can move it to the screen, and the whole thing is a great
; deal faster.

; combine the y value of r/g/b with the value derived from u and v.
; then normalise the result to be a value in 0..31.
; $y holds the y value, $gunsrc the value from u and v, result in $gun.
        MACRO
        NormaliseGun16 $op,$gun,$y,$gunsrc
        $op     $gun,$y,$gunsrc             ; R/G/B, at 19 bits
        MOVS    $gun,$gun,ASR #SCALEBITS+3  ; truncate
        MOVLT   $gun,#0
        CMP     $gun,#31
        MOVGT   $gun,#31
        MEND

; static void colour_convert_block_16(JCOEF *yuv, short int *outptr, int outoffset)
; /* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block of 16bit pixels */
;   r0 -> the six blocks, YYYYUV (all row-ordered, ie 'wrong' way round, different from output)
;   r1 -> output buffer
;   r2 = offset in words between rows of output
; the output goes in outptr[row*outoffset + col] for row/col in 0..15
        EXPORT  asm_colour_convert_block_16
asm_colour_convert_block_16
        STMDB   sp!,{r0-r12,lr}             ; save state
        ADD     r3,r1,#16*2                 ; column limit pointer (inner loop) - outptr+16 pixels
        ADD     r4,r1,r2,LSL #3+2           ; row limit pointer (outer loop) - outptr+8*outoffset words
        ADD     r5,r0,#4*64*4               ; pointer into U block. V values 64 words on from this
        ADD     r6,r4,r2,LSL #3+2           ; real row limit pointer - outptr+16*outoffset words

        STMIA   sp,{r4,r6}                  ; r4 and r6 used as temp workspace during the colour conversion:
                                            ; we never need to reload r0/r1, so use these stack locations.

; The main loop goes round once for each 2*2 square of four output pixels, using
; four Y values, one U value, one V value.
jc_colour_loop16                              ; each two rows and each two columns of output

        ; do four output pixels, using:
        ; [r5] is U value
        ; [r5,#64*4] is V value
        ; [r0] and [r0,#8*4] are Y values for output word [r1]
        ; [r0,#4] and [r0,#8*4+4] are Y values for output word [r1,r2,LSL #2]

        ; first we compute the values derived from U and V, which are
        ; true for all four pixels.
        LDR     r7,[r5]                     ; U value
        MOV     r7,r7,ASR #8                ; the multiplies will get us back to SCALEBITS again
        LDR     r8,[r5, #64*4]              ; V value
        MOV     r8,r8,ASR #8                ; the multiplies will get us back to SCALEBITS again
        ; Should add 1:SHL:7 before ASR #8, but not regarded as significant enough
        ; considering how much bigger SCALEBITS is.

        ; Multiply sequences generated by cc 4.50, for 8 bits of accuracy.
        ; these sequences lead to a result shifted left by left by 8 bits.
        ;MulCon  r9,r7,FIX(1.77200)          ; B, without the Y yet
        ADD      r9,r7,r7,LSL #5
        RSB      r9,r9,r7,LSL #8
        SUB      r9,r9,r7,LSL #3             ; still needs a LSL #1

        ;MulCon  r10,r8,FIX(1.40200)         ; R, without the Y yet
        ADD     r10,r8,r8,LSL #5
        RSB     r10,r10,r10,LSL #3
        ADD     r10,r10,r8,LSL #7

        ;MulCon  r11,r7,-FIX(0.34414)
        ADD     r11,r7,r7,LSL #1
        ADD     r11,r11,r7,LSL #3            ; LSL #3 still needed - see below

        ;MulCon  r12,r8,-FIX(0.71414)
        RSB     r12,r8,r8,LSL #6
        ADD     r12,r12,r8,LSL #7
        SUB     r12,r12,r8,LSL #3

        ; After those multiplies, the values are shifted up by SCALEBITS again.
        ; scratch r7,r8
        ADD     r11,r12,r11,LSL #3          ; -G, without the Y yet - did the LSL #3, see above.
        ; scratch r12

        ; We're going to add each of r9/r10/r11 to the Y values.
        ; The Y values need 128 added to them - add it at this point.
        ; need to add a half for the truncation - do that at the same time.
        ; We'll be truncating at SCA
;        MOV     r7,#ONE_HALF                ; construct constant - can't quite be done in one instruction.
;        ADD     r7,r7,#128:SHL:SCALEBITS
        MOV     r7,#(ONE_HALF:SHL:3)+(128:SHL:SCALEBITS)
        ADD     r9,r7,r9,LSL #1             ; LSL #1 still owed to R9 - see above.
        ADD     r10,r10,r7
        SUB     r11,r11,r7                  ; r11 is to be subtracted from Y, not added.

        ; now process the four pixels one at a time.
        LDMIA   r0,{r7,r8}                  ; first two Y values, shifted up by SCALEBITS
        ADD     r8,r8,#4:SHL:SCALEBITS      ; ordered dither
        NormaliseGun16 ADD,r12,r7,r9        ; B
        NormaliseGun16 ADD,lr,r7,r10        ; R
        NormaliseGun16 SUB,r7,r7,r11        ; G
        ORR     r7,lr,r7,LSL #5             ; G and R
        ORR     r4,r7,r12,LSL #10           ; complete output pixel

        NormaliseGun16 ADD,r12,r8,r9        ; B
        NormaliseGun16 ADD,lr,r8,r10        ; R
        NormaliseGun16 SUB,r8,r8,r11        ; G
        ORR     r8,lr,r8,LSL #5             ; G and R
        ORR     r6,r8,r12,LSL #10           ; complete output pixel

        ADD     r7,r0,#8*4                  ; prepare to load next two pixels
        LDMIA   r7,{r7,r8}                  ; other two pixels
        ADD     r7,r7,#6:SHL:SCALEBITS      ; ordered dither
        ADD     r8,r8,#2:SHL:SCALEBITS      ; ordered dither
        NormaliseGun16 ADD,r12,r7,r9        ; B
        NormaliseGun16 ADD,lr,r7,r10        ; R
        NormaliseGun16 SUB,r7,r7,r11        ; G
        ORR     r7,lr,r7,LSL #5             ; G and R
        ORR     r7,r7,r12,LSL #10           ; complete output pixel
        ORR     r7,r4,r7,LSL #16            ; combine two pixels
        STR     r7,[r1]                     ; output two pixels

        NormaliseGun16 ADD,r12,r8,r9        ; B
        NormaliseGun16 ADD,lr,r8,r10        ; R
        NormaliseGun16 SUB,r8,r8,r11        ; G
        ORR     r8,lr,r8,LSL #5             ; G and R
        ORR     r8,r8,r12,LSL #10           ; complete output pixel
        ORR     r8,r6,r8,LSL #16            ; combine the two pixels
        STR     r8,[r1,r2,LSL #2]           ; output pixel
        ADD     r1,r1,#4

        ; increment pointers to go two pixels along an output row
        ; r1 (output pointer) already updated
        ADD     r5,r5,#8*4                  ; pointer into row-organised U,V values
        ADD     r0,r0,#2*8*4                ; ditto for Y values

        ; check for end of row
        CMP     r1,r3                       ; output pointer reached end of output row?
        BNE     jc_colour_loop16            ; go round for next column

        ; Amazingly there is not special action to take half-way along each output row,
        ; when we switch from one Y block to the next - because of the ordering and
        ; arrangement of the Y blocks, it just acts as a single 8*16 block.

        ; It's the end of the row. Update all input and output pointers to
        ; advance to next one.
        ADD     r1,r1,r2,LSL #2+1           ; advance output ptr by two output rows
        SUB     r1,r1,#16*2                 ;      ... and then to beginning of next output row.
        SUB     r5,r5,#64*4-4               ; advance UV pointer to start of next row
        SUB     r0,r0,#2*64*4-8             ; ditto Y pointer, but back two blocks
        ADD     r3,r1,#16*2                 ; reset column limit pointer (inner loop) - outptr+16 words

        ; Check for having to change to the second pair of Y blocks, or terminate
        LDMIA   sp,{r4,r6}                  ; reload loop end test registers
        CMP     r1,r4
        BNE     jc_colour_loop16            ; normal case - we set off on another two rows of output

        ; It's either the half-way point, in which case we need to change to the second pair
        ; of input Y blocks, or it's the end. Test r4 against the 'real' limit pointer.

        CMP     r4,r6                       ; is this the end?
        LDMEQIA sp!,{r0-r12,pc}             ; if so, return - nothing more to do

        ; We've reached the half-way point.
        MOV     r4,r6                       ; next time we test r4 and r6, exit.
        STR     r4,[sp]                     ; remember for final termination
        ADD     r0,r0,#7*8*4+8*8*4          ; advance r0 from end of row 0 of block 0,
                                            ; to start of row 0 of block 2.
        B       jc_colour_loop16            ; and continue.

; ******************************************************************************
; *                                                                            *
; *   YUV->RGB colour conversion for 8bpp output                               *
; *                                                                            *
; ******************************************************************************

      [ cfsi_jpeg
        EXPORT  asm_colour_convert_block_8
asm_colour_convert_block_8 ; referenced from C code, but never used.
        MOV     pc,lr
      |
        GET     yuvtabs.s

; Similar in structure to 32bpp and 16bpp output, except that 8bpp (VIDC1) pixels
; are generated. Partial dithering is used, so it's really only good for 1:1 plotting
; at 8bpp.

; A macro to generate an 8bpp pixel from YUV values, and subtract the actual value
; of that pixel from the YUV values.
; The yuv values are SCALEBITS up in their respective words, in the approximate range
; (0..255):SHL:SCALEBITS.
; r12 holds the lookup table (yuv->pixel, approximate)
; r11 holds the palette (pixel->yuv)
        MACRO
        Generate8bitFromYUV   $y,$u,$v,$pixel,$temp,$dest
        MOVS    $temp,$v,ASR #8-yuvtab_vbits                  ; get relevant bits of v
        MOVS    $pixel,$u,ASR #8-yuvtab_ubits                 ; get relevant bits of v
        ORR     $pixel,$temp,$pixel,LSL #yuvtab_vbits         ; combine u and v
        MOVS    $temp,$y,ASR #8-yuvtab_ybits                  ; get relevant bits of v
        ORR     $pixel,$pixel,$temp,LSL #yuvtab_ubits+yuvtab_vbits ; combine y, u, v
        LDRB    $pixel,[r12,$pixel]                           ; get the pixel value
        STRB    $pixel,$dest                                  ; store the pixel
        LDR     $pixel,[r11,$pixel,LSL #2]                    ; get real yuv value, as bytes 0yuv
        AND     $temp,$pixel,#&ff                             ; get real v value
        SUB     $v,$v,$temp                                   ; subtract it from v
        AND     $temp,$pixel,#&ff00                           ; get real u value
        SUB     $u,$u,$temp,LSR #8                            ; subtract it from u
        SUB     $y,$y,$pixel,LSR #16                          ; subtract it from y
        MEND

; Get a Y, U or V value from the given location, subtract 128 from it,
; add it to the cumulative error so far in that gun.
        MACRO
        GetColourValue $reg,$loc
        LDR     r4,$loc                                       ; get the value into temp register - shifted up SCALEBITS
        ADD     r4,r4,#128:SHL:SCALEBITS                      ; make it in approx range 0..256
        ADDS    $reg,$reg,r4,ASR #SCALEBITS                   ; add it to error so far
        MOVLT   $reg,#0                                       ; clamp
        CMP     $reg,#255
        MOVGT   $reg,#255
        MEND

; static void colour_convert_block_8(JCOEF *yuv, char *outptr, int outoffset)
; /* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block of 8bit pixels */
;   r0 -> the six blocks, YYYYUV (all row-ordered, ie 'wrong' way round, different from output)
;   r1 -> output buffer
;   r2 = offset in words between rows of output
; the output goes in outptr[row*outoffset + col] for row/col in 0..15
        EXPORT  asm_colour_convert_block_8
asm_colour_convert_block_8

        STMDB   sp!,{r0-r12,lr}             ; save state
        ADD     r3,r1,#16                   ; column limit pointer (inner loop) - outptr+16 pixels
        ADD     r4,r1,r2,LSL #3+2           ; row limit pointer (outer loop) - outptr+8*outoffset words
        ADD     r5,r0,#4*64*4               ; pointer into U block. V values 64 words on from this
        ADD     r6,r4,r2,LSL #3+2           ; real row limit pointer - outptr+16*outoffset words

        STMIA   sp,{r4,r6}                  ; r4 and r6 used as temp workspace during the colour conversion:
                                            ; we never need to reload r0/r1, so use these stack locations.

        ADRL    r12,yuv_to_pixel_table
        ADRL    r11,pixel_to_yuv_table
        MOV     r7,#0                       ; cumulative error in U so far
        MOV     r8,#0                       ; cumulative error in V so far
        MOV     r9,#0                       ; cumulative error in Y so far

        SUB     r10,r0,#2*64*4-8            ; set to NEXT y pointer row
;        MOV     r10,#0                      ; for 4x2 cell

; The main loop goes round once for each 2*2 square of four output pixels, using
; four Y values, one U value, one V value.
jc_colour_loop8                             ; each two rows and each two columns of output

        ; do four output pixels, using:
        ; [r5] is U value
        ; [r5,#64*4] is V value
        ; [r0] and [r0,#8*4] are Y values for output word [r1]
        ; [r0,#4] and [r0,#8*4+4] are Y values for output word [r1,r2,LSL #2]

        GetColourValue r7,[r5]              ; U value
        GetColourValue r8,"[r5,#64*4]"      ; V value
        GetColourValue r9,"[r0,#4]"         ; Y value
        Generate8bitFromYUV r9,r7,r8,r4,r6,"[r1,r2,LSL #2]"

        GetColourValue r7,[r5]              ; U value
        GetColourValue r8,"[r5, #64*4]"     ; V value
        GetColourValue r9,[r0]              ; Y value
        Generate8bitFromYUV r9,r7,r8,r4,r6,[r1]
        ADD     r1,r1,#1

        ; Next two pixels done in a swapped order, so we do a little U around the square of four
        ; pixels - this seems to reduce the amount of horizontal-line effect that you get.

        GetColourValue r7,[r5]              ; U value
        GetColourValue r8,"[r5,#64*4]"      ; V value
        GetColourValue r9,"[r0,#8*4]"       ; Y value
        Generate8bitFromYUV r9,r7,r8,r4,r6,[r1]

        GetColourValue r7,[r5]              ; U value
        GetColourValue r8,"[r5,#64*4]"      ; V value
        GetColourValue r9,"[r0,#9*4]"       ; Y value
        Generate8bitFromYUV r9,r7,r8,r4,r6,"[r1,r2,LSL #2]"
        ADD     r1,r1,#1

        ; We have done a cell of four pixels, and have cumulative error values in Y, U, V.
        ; Instead of carrying all this error over to the next cell at the right, diffuse some
        ; of it onto the next row as indicated by r10.
 ;       LDR     r4,[r10,#8*4]
 ;       ADD     r4,r4,r9,LSL #SCALEBITS-2   ; add quarter the value in r9
 ;       STR     r4,[r10,#8*4]
 ;       LDR     r4,[r10]
 ;       ADD     r4,r4,r9,LSL #SCALEBITS-2   ; add quarter the value in r9
 ;       STR     r4,[r10]
 ;       MOV     r9,r9,ASR #1                ; halve what is left over

        ; and do it for U and V as well.
        CMP     r10,r0                      ; have we a valid r10?
 ;       LDRNE   r4,[r5,#4]
 ;       ADDNE   r4,r4,r7,LSL #SCALEBITS-1
 ;       MOVNE   r7,r7,ASR #1
 ;       STRNE   r4,[r5,#4]
 ;       LDRNE   r4,[r5,#64*4+4]
 ;       ADDNE   r4,r4,r8,LSL #SCALEBITS-1
 ;       MOVNE   r8,r8,ASR #1
 ;       STRNE   r4,[r5,#64*4+4]

        ; zero cumulative error on Y U V registers - for 4x2 cell
;        EORS    r10,r10,#1
;        MOVEQ   r7,#0
;        MOVEQ   r8,#0
;        MOVEQ   r9,#0

        ; increment pointers to go two pixels along an output row
        ; r1 (output pointer) already updated
        ADD     r5,r5,#8*4                  ; pointer into row-organised U,V values
        ADD     r0,r0,#2*8*4                ; ditto for Y values

        ; check for end of row
        CMP     r1,r3                       ; output pointer reached end of output row?
        BNE     jc_colour_loop8             ; go round for next column

        ; Amazingly there is not special action to take half-way along each output row,
        ; when we switch from one Y block to the next - because of the ordering and
        ; arrangement of the Y blocks, it just acts as a single 8*16 block.

        ; It's the end of the row. Update all input and output pointers to
        ; advance to next one.
        ADD     r1,r1,r2,LSL #2+1           ; advance output ptr by two output rows
        SUB     r1,r1,#16                   ;      ... and then to beginning of next output row.
        SUB     r5,r5,#64*4-4               ; advance UV pointer to start of next row
        SUB     r0,r0,#2*64*4-8             ; ditto Y pointer, but back two blocks
        ADD     r3,r1,#16                   ; reset column limit pointer (inner loop) - outptr+16 words

        ; zero cumulative error on Y U V registers
        MOV     r7,#0
        MOV     r8,#0
        MOV     r9,#0

        ; Set r10 to pointer to the NEXT row of Y values, or equal to r0 if there isn't
        ; one or we're at the half-way point (where the next row is hard to find).
        SUB     r10,r0,#2*64*4-8            ; set to NEXT y row pointer

        ; Check for having to change to the second pair of Y blocks, or terminate
        LDMIA   sp,{r4,r6}                  ; reload loop end test registers
        CMP     r10,r4                      ; check NEXT row pointer
        MOVEQ   r10,r0                      ; if a tricky case, discard it (>>> could do better here, and get half-way point right)
        CMP     r1,r4
        BNE     jc_colour_loop8             ; normal case - we set off on another two rows of output

        ; It's either the half-way point, in which case we need to change to the second pair
        ; of input Y blocks, or it's the end. Test r4 against the 'real' limit pointer.

        CMP     r4,r6                       ; is this the end?
        LDMEQIA sp!,{r0-r12,pc}             ; if so, return - nothing more to do

        ; We've reached the half-way point.
        MOV     r4,r6                       ; next time we test r4 and r6, exit.
        STR     r4,[sp]                     ; remember for final termination
        ADD     r0,r0,#7*8*4+8*8*4          ; advance r0 from end of row 0 of block 0,
                                            ; to start of row 0 of block 2.
        SUB     r10,r0,#2*64*4-8            ; set to NEXT y row pointer
        B       jc_colour_loop8             ; and continue.

      ]

        END
@


1.1.2.2
log
@Create assembler equivalents of C colour conversions, approx 10% speed up.
Add new switch ASMCOLOR to select which to use, C or assembler.
Remove FILE_ exit trace concept, just use __FILE__ instead in exit_erl.
Add some comments to exit_erl and friends.
A few bits of cinfo setup moved into start_pass_huff_decoder() or eliminated.
Bumped up the precision of SCALE_BITS in the C colour handling so FIX() uses more bits of an int.
Deleted the unused remenants of light dithering in the 8bpp colour converter - saves a few cycles.
colour_convert_8 and colour_convert_16 no longer save entry registers the C compiler doesn't care about.
Update genyuvtabs to EXPORT the table bases.
Split out the compilation of IJG files as separate objects in the make file, rather than including them from within rojpeg, which is itself included from putscaled.

Version 1.38, 1.35.2.6. Tagged as 'SprExtend-1_38-1_35_2_6'
@
text
@d19 1
a19 7
;   called from 'c.rojpeg' and the C equivalents are in 'c.jdcolor'

        ; All values in DCT blocks are scaled up by SCALEBITS bits.
DCTSIZE   * 8
DCTSIZE2  * 64
SCALEBITS * 19
ONE_HALF  * 1:SHL:(SCALEBITS - 1)
a26 8
        ; If negative, clamp at zero. If > 255, clamp at 255.
        MACRO
        Clamp   $r
        MOVLT   $r,#0                    ; must be preceded by a flags setting op
        CMP     $r,#255
        MOVGT   $r,#255
        MEND
        
d30 5
a34 12
        ADD     $r,$r,#ONE_HALF          ; rounding prior to truncation
        ADDS    $r,r12,$r,ASR #SCALEBITS ; add 128, truncate
        Clamp   $r
        ORR     $r,$r,$r,LSL #8          ; replicate grey value in each of R, G, B
        ORR     $r,$r,$r,LSL #8
        MEND

        ; Do a DC mono pixel no descaling
        MACRO
        MonoDC  $r
        ADDS    $r,$r,#128               ; add 128
        Clamp   $r
d42 5
a46 3
        ADD     $r,$r,#ONE_HALF          ; rounding prior to truncation
        ADDS    $r,r12,$r,ASR #SCALEBITS ; add 128, truncate
        Clamp   $r
a48 24
; extern int asm_mono_convert_pixel(int pix)
; /* Convert greyscale pixel into 32bit RGB values. */
;   r0 = luma, no shifting needed as it's not been through the DCT.
        EXPORT  asm_mono_convert_pixel
asm_mono_convert_pixel
        MonoDC  r0
        MOV     pc,lr

; extern int asm_mono_convert_pixels(int *y)
; /* Convert 4 greyscale pixels into 32bit RGB values. */
;   r0 -> array of luma, no shifting needed as it's not been through the DCT.
        EXPORT  asm_mono_convert_pixels
asm_mono_convert_pixels
        MOV     r1,#4
10
        SUBS    r1,r1,#1
        MOVMI   pc,lr
        LDR     r2,[r0,r1,LSL#2]
        ADD     r2,r2,#4
        MOV     r2,r2,ASR #3             ; descale Y
        MonoDC  r2
        STR     r2,[r0,r1,LSL#2]
        B       %BT10

d87 1
a87 1
        LDMIA   sp!,{r0-r12,pc}
d133 1
a133 1
        LDMIA   sp!,{r0-r12,pc}
d141 10
a150 3
        ; combine the y value of r/g/b with the value derived from u and v.
        ; then normalise the result to be a value in 0..255.
        ; $y holds the y value, $gunsrc the value from u and v, result in $gun.
d153 1
a153 1
        $op     $gun,$y,$gunsrc             ; R/G/B, at SCALEBITS bits
d155 3
a157 1
        Clamp   $gun
d160 1
a160 148
k140200 RN 3
k034414 RN 4
k071414 RN 5
k177200 RN 6

jc_fix_table
        ;       FIX(1.40200), FIX(0.34414), FIX(0.71414), FIX(1.77200)
        ASSERT  SCALEBITS=19
        DCD     735052,       180428,       374415,       929038 

; static void asm_colour_convert_pixels(int *y, int u, int v)
; /* Convert four pixels. Input y values are in y[0..3]. */
;   r0 -> the four blocks, YYYY, no shifting needed as it's not been through the DCT.
;   r1 = corresponding u
;   r2 = corresponding v
; the output goes back in y[0..3]
        EXPORT  asm_colour_convert_pixels
asm_colour_convert_pixels
      [ cfsi_jpeg
        MOV     pc,lr                       ; referenced from C code, but never used.
      |
        STMDB   sp!,{r4-r8,lr}

        ADD     r1,r1,#4
        MOV     r1,r1,ASR #3
        ADD     r2,r2,#4
        MOV     r2,r2,ASR #3                ; descale

        ADR     r14,jc_fix_table
        LDMIA   r14,{r3-r6}                 ; get magic scalers

        MUL     r3,r2,k140200               ; r = v * 1.40200
        ADD     r3,r3,#ONE_HALF

        MUL     r4,r1,k034414
        MLA     r5,r2,k071414,r4            ; g = 0 -  u * 0.34414 - v * 0.71414
        RSB     r4,r5,#0                    ;   = 0 - (u * 0.34414 + v * 0.71414)
        ADD     r4,r4,#ONE_HALF

        MUL     r5,r1,k177200               ; b = u * 1.77200
        ADD     r5,r5,#ONE_HALF

        MOV     r1,#4
        MOV     r14,#128
10
        SUBS    r1,r1,#1
        LDMMIIA sp!,{r4-r8,pc}              ; loop 3 to 0

        LDR     r2,[r0,r1,LSL#2]

        ADD     r2,r2,#4
        ADD     r2,r14,r2,ASR #3            ; normalise and descale Y

        ADDS    r6,r2,r3,ASR #SCALEBITS     ; rr = r + yy unFIX'd
        Clamp   r6
        ADDS    r7,r2,r4,ASR #SCALEBITS     ; gg = g + yy unFIX'd
        Clamp   r7
        ADDS    r8,r2,r5,ASR #SCALEBITS     ; bb = b + yy unFIX'd
        Clamp   r8

        ORR     r6,r6,r8,LSL #16            ; collect up &0BGR and store
        ORR     r6,r6,r7,LSL #8 
        STR     r6,[r0,r1,LSL#2]
        B       %BT10
      ]

; static void asm_colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset, int wide, int high)
; /* yuv[0..1] are Y, yuv[4] is U, yuv[5] is V. wide/high are 1 or 2. */
;   r0 -> the six blocks, YYYYUV (all row-ordered, ie 'wrong' way round, different from output)
;   r1 -> output buffer
;   r2 = offset in words between rows of output
;   r3 = hsamp
;   sp+0 = vsamp
; the output goes in outptr[row*outoffset + col] for row/col in 0..15
        EXPORT  asm_colour_convert_unusual_block
asm_colour_convert_unusual_block
        STMDB   sp!,{r2,r4-r11,lr}
        LDR     r2,[sp,#10*4]               ; recover vsamp
        SUB     r2,r2,#1                    ; vsamp zeros based
        SUB     r10,r3,#1                   ; hsamp zeros based
        MOV     r11,#0                      ; ycoord counter (j)
        MOV     r12,#0                      ; xcoord counter (i)
        MOV     r14,#128                    ; useful constant
10
        AND     r4,r11,#7
        AND     r6,r12,#7
        ADD     r4,r4,r6,LSL #3
        ADD     r4,r0,r4,LSL #2
        CMP     r11,#DCTSIZE
        CMPCC   r12,#DCTSIZE
        LDRCC   r7,[r4,#0*4*DCTSIZE2]
        LDRCS   r7,[r4,#1*4*DCTSIZE2]       ; extract y from right block, NB row order

        MOV     r4,r11,ASR r2
        MOV     r6,r12,ASR r10
        ADD     r4,r4,r6,LSL #3             ; (j >> (vsamp-1)) + ((i >> (hsamp-1)) * 8)
        ADD     r4,r0,r4,LSL #2

        LDR     r8,[r4,#4*4*DCTSIZE2]       ; u
        LDR     r9,[r4,#5*4*DCTSIZE2]       ; v

        ADD     r7,r7,#ONE_HALF
        ADD     r8,r8,#ONE_HALF
        ADD     r9,r9,#ONE_HALF
        ADD     r7,r14,r7,ASR #SCALEBITS    ; normalise & descale
        MOV     r8,r8,ASR #SCALEBITS        ; descale
        MOV     r9,r9,ASR #SCALEBITS        ; descale

        ADR     r3,jc_fix_table
        LDMIA   r3,{r3-r6}                  ; get magic scalers

        MUL     r3,r9,k140200               ; r = v * 1.40200
        ADD     r3,r3,#ONE_HALF

        MUL     r4,r8,k034414
        MLA     r5,r9,k071414,r4            ; g = 0 -  u * 0.34414 - v * 0.71414
        RSB     r4,r5,#0                    ;   = 0 - (u * 0.34414 + v * 0.71414)
        ADD     r4,r4,#ONE_HALF

        MUL     r5,r8,k177200               ; b = u * 1.77200
        ADD     r5,r5,#ONE_HALF

        ADDS    r6,r7,r3,ASR #SCALEBITS     ; r = r unFIX'd + y
        Clamp   r6
        ADDS    r3,r7,r4,ASR #SCALEBITS     ; g = g unFIX'd + y
        Clamp   r3
        ADDS    r4,r7,r5,ASR #SCALEBITS     ; b = b unFIX'd + y
        Clamp   r4

        ORR     r6,r6,r4,LSL #16            ; collect up &0BGR and store
        ORR     r6,r6,r3,LSL #8
        STR     r6,[r1,r12,LSL#2]

        ADD     r12,r12,#1                  ; next i
        CMP     r10,r12,LSR #3              ; 8->1 16->2 comparing with 0 or 1
        BHS     %BT10

        MOV     r12,#0                      ; restart i=0
        LDR     r3,[sp]                     ; outoffset on entry
        ADD     r1,r1,r3,LSL #2             ; outptr += outoffset

        ADD     r11,r11,#1                  ; next j
        CMP     r2,r11,LSR #3               ; 8->1 16->2 comparing with 0 or 1
        BHS     %BT10

        LDMIA   sp!,{r2,r4-r11,pc}

; static void asm_colour_convert_block(JCOEF *yuv, int *outptr, int outoffset)
d168 2
a169 1
        STMDB   sp!,{r4-r11,lr}             ; save state
d175 2
a176 2
        ; The main loop goes round once for each 2*2 square of four output pixels, using
        ; four Y values, one U value, one V value.
d197 5
a201 5
        ; these sequences lead to a result shifted left by 8 bits.
        ;MulCon  r9,r7,FIX(1.77200)         ; B, without the Y yet
        ADD     r9,r7,r7,LSL #5
        RSB     r9,r9,r7,LSL #8
        SUB     r9,r9,r7,LSL #3             ; still needs a LSL #1
d203 1
a203 1
        ;MulCon  r10,r8,FIX(1.40200)        ; R, without the Y yet
d208 4
d217 2
a218 3
        ;MulCon  r11,r7,-FIX(0.34414)
        ADD     r11,r7,r7,LSL #1
        ADD     r11,r11,r7,LSL #3           ; LSL #3 still needed - see below
d220 1
a221 1
        ; After those multiplies, the values are shifted up by SCALEBITS again.
d224 3
a226 2
        ; need to add a half for the truncation of NormaliseGun - do that at the same time.
        MOV     r7,#ONE_HALF
d229 2
a230 2
        ADD     r10,r7,r10
        RSB     r11,r7,r11                  ; r11 is to be subtracted from Y, not added.
d240 2
a241 1

d276 1
a276 1
        ; Amazingly there is no special action to take half-way along each output row,
d296 1
a296 1
        LDMEQIA sp!,{r4-r11,pc}             ; if so, return - nothing more to do
d304 31
a334 21
        ; Performance notes for colour conversion.
        ; approx number of ticks for 4 pixels:
        ;    7        loop etc.
        ;   23        common work on the UV values
        ;   40        loading/storing,combining gun values
        ;   52        normalising gun values
        ;   --
        ;  122/4 = 30.5 per pixel.

;        ; Could a register to hold &101, saves 1 per pixel.
;
;        ; How common is <0 and >255? If rare,
;        ; test all at once (easy on <0, harder for >255)
;        ;   and do a B if there's a problem.
;        ; Not QUITE worth it, overflow about 5% of the time.
;
;        ; Lookup tables don't save much - 3 instructions becomes a LDR.
;        ; Could replace whole 'normalise' by a single LDR? Not QUITE worth it.
;        ; A lookup for the entire computation, indexed by Y and U and V, saves quite
;        ; a lot. BUT, 5 bits of U and V is insufficient, in smoothly shaded pictures
;        ; (after a brief experiment). 6 bits each makes a .5MB table, too big!
d342 8
a349 10
        ; Almost identical to the 32bpp case above, except that 16bit pixels are generated.
        ; An ordered dither is added to this using Bayer's ordered dither matrix of
        ; of D2 = [ 3   1 ]
        ;         [ 0   2 ]
        ; Really only good for 1:1 plotting in 16bpp, thus a block copy can move it to the
        ; screen, and the whole thing is a great deal faster.

        ; combine the y value of r/g/b with the value derived from u and v.
        ; then normalise the result to be a value in 0..31.
        ; $y holds the y value, $gunsrc the value from u and v, result in $gun.
d352 1
a352 1
        $op     $gun,$y,$gunsrc             ; R/G/B, at SCALEBITS bits
d359 1
a359 1
; static void asm_colour_convert_block_16(JCOEF *yuv, short *outptr, int outoffset)
d367 1
a367 1
        STMDB   sp!,{r0-r1,r4-r11,lr}       ; save state
d376 3
a378 3
        ; The main loop goes round once for each 2*2 square of four output pixels, using
        ; four Y values, one U value, one V value.
jc_colour_loop16                            ; each two rows and each two columns of output
d390 1
a390 1
        LDR     r8,[r5,#64*4]               ; V value
d396 7
a402 7
        ; these sequences lead to a result shifted left by 8 bits.
        ;MulCon r9,r7,FIX(1.77200)          ; B, without the Y yet
        ADD     r9,r7,r7,LSL #5
        RSB     r9,r9,r7,LSL #8
        SUB     r9,r9,r7,LSL #3             ; still needs a LSL #1
        
        ;MulCon r10,r8,FIX(1.40200)         ; R, without the Y yet
d407 5
a411 1
        ;MulCon r12,r8,-FIX(0.71414)
d416 4
a419 4
        ;MulCon r11,r7,-FIX(0.34414)
        ADD     r11,r7,r7,LSL #1
        ADD     r11,r11,r7,LSL #3           ; LSL #3 still needed - see below
        ADD     r11,r12,r11,LSL #3          ; -G, without the Y yet
a420 1
        ; After those multiplies, the values are shifted up by SCALEBITS again.
d423 5
a427 2
        ; need to add a half for the truncation of NormaliseGun16 - do that at the same time.
        MOV     r7,#(ONE_HALF:SHL:3) + (128:SHL:SCALEBITS)
d429 3
a431 3
        ADD     r10,r7,r10
        RSB     r11,r7,r11                  ; r11 is to be subtracted from Y, not added.
        
a433 1
        ;ADD    r7,r7,#0:SHL:SCALEBITS      ; ordered dither
d477 1
a477 1
        ; Amazingly there is no special action to take half-way along each output row,
d498 1
a498 1
        LDMEQIA sp!,{r0-r1,r4-r11,pc}       ; if so, return - nothing more to do
d513 6
a518 2
        ; Similar in structure to 32bpp and 16bpp output, except that 8bpp (VIDC1) pixels
        ; are generated.
d520 10
a529 4
        ; A macro to generate an 8bpp pixel from YUV values, and subtract the actual value
        ; of that pixel from the YUV values.
        ; r12 holds the lookup table (yuv->pixel, approximate)
        ; r11 holds the palette (pixel->yuv)
d533 1
a533 1
        MOVS    $pixel,$u,ASR #8-yuvtab_ubits                 ; get relevant bits of u
d539 1
a539 1
        LDR     $pixel,[r11,$pixel,LSL #2]                    ; get real yuv value, as word &0YUV
d547 2
a548 4
        ; The yuv values are SCALEBITS up in their respective words, in the approximate range
        ; (0..255):SHL:SCALEBITS.
        ; Get a Y, U or V value from the given location, subtract 128 from it,
        ; add it to the cumulative error so far in that gun.
d550 7
a556 5
        GetColourValue $reg,$loc,$temp
        LDR     $temp,$loc                                    ; get the value into temp register - shifted up SCALEBITS
        ADD     $temp,$temp,#128:SHL:SCALEBITS                ; make it in approx range 0..256
        ADDS    $reg,$reg,$temp,ASR #SCALEBITS                ; add it to error so far
        Clamp   $reg
d559 1
a559 5
      [ :LNOT: cfsi_jpeg
        GET     yuvtabs.s
      ]
      
; static void asm_colour_convert_block_8(JCOEF *yuv, char *outptr, int outoffset)
d567 2
a568 4
      [ cfsi_jpeg
        MOV     pc,lr                       ; referenced from C code, but never used.
      |
        STMDB   sp!,{r0-r1,r4-r11,lr}       ; save state
d583 5
a587 2
        ; The main loop goes round once for each 2*2 square of four output pixels, using
        ; four Y values, one U value, one V value.
d596 3
a598 3
        GetColourValue r7,"[r5]",r4         ; U value
        GetColourValue r8,"[r5,#64*4]",r4   ; V value
        GetColourValue r9,"[r0,#4]",r4      ; Y value
d601 4
a604 4
        GetColourValue r7,"[r5]",r4         ; U value
        GetColourValue r8,"[r5,#64*4]",r4   ; V value
        GetColourValue r9,"[r0]",r4         ; Y value
        Generate8bitFromYUV r9,r7,r8,r4,r6,"[r1]"
d610 8
a617 8
        GetColourValue r7,"[r5]",r4         ; U value
        GetColourValue r8,"[r5,#64*4]",r4   ; V value
        GetColourValue r9,"[r0,#8*4]",r4    ; Y value
        Generate8bitFromYUV r9,r7,r8,r4,r6,"[r1]"

        GetColourValue r7,"[r5]",r4         ; U value
        GetColourValue r8,"[r5,#64*4]",r4   ; V value
        GetColourValue r9,"[r0,#9*4]",r4    ; Y value
d621 28
d658 1
a658 1
        ; Amazingly there is no special action to take half-way along each output row,
d675 4
d681 2
d690 1
a690 1
        LDMEQIA sp!,{r0-r1,r4-r11,pc}       ; if so, return - nothing more to do
d697 1
d699 1
@


1.1.2.3
log
@For completeness, implement the 2x2->8bpp and 2x2->16bpp colour conversions in C too.
While slower than their assembler equivalents it makes the whacky address generation a bit easier to follow.
Fix MakeFile to not stop when trying to deleted an empty directory.

Version 1.38, 1.35.2.7. Tagged as 'SprExtend-1_38-1_35_2_7'
@
text
@a712 10

        EXPORT  pixel_to_yuv_table_base
pixel_to_yuv_table_base
        ADRL    r0, pixel_to_yuv_table
        MOV     pc, lr

        EXPORT  yuv_to_pixel_table_base
yuv_to_pixel_table_base
        ADRL    r0, yuv_to_pixel_table
        MOV     pc, lr
@


1.1.2.4
log
@Use USAT in 150 occurrences of colour clamping for ARMv6 and later.
Some IDCT renaming.
Shock addition of some documentation on how it all works.
Mirror fix from 1.39 on the trunk.
Debug
 Made DEBUG version compile again, earlier header shuffling was preventing it.
 Replaced the ' _ ' method of variadic macro emulation with more familiar double brackets for tracef().
 Eliminated IFDEBUG macro and just used #ifdef DEBUG/#endif or tracef() directly.
 Don't bother passing the line number and file name to exit() when in the non DEBUG case.

Version 1.38, 1.35.2.8. Tagged as 'SprExtend-1_38-1_35_2_8'
@
text
@d15 1
a15 1
; > Sources.jdcolor
d33 1
a33 1
        ; If negative, clamp at zero. If >= 2^bits, clamp at (2^bits)-1.
d35 1
a35 2
        Clamp   $r,$bits
      [ NoARMv6
d37 2
a38 10
        CMP     $r,#1:SHL:$bits
      [ $bits > 8
        MOVCS   $r,#(1:SHL:$bits)
        SUBCS   $r,$r,#1                 ; pesky 8 bit immediates
      |
        MOVCS   $r,#(1:SHL:$bits) - 1
      ]
      |                                  ; take a look at my funky USAT
        DCI     &E6E00010 :OR: ($bits:SHL:16) :OR: ($r:SHL:12) :OR: $r
      ]
d45 2
a46 2
        ADDS    $r,r12,$r,ASR #SCALEBITS ; normalise, truncate
        Clamp   $r,8
d54 2
a55 2
        ADDS    $r,$r,#128               ; normalise
        Clamp   $r,8
d64 2
a65 2
        ADDS    $r,r12,$r,ASR #SCALEBITS ; normalise, truncate
        Clamp   $r,8
d102 1
a102 1
        STMDB   sp!,{r4-r11,lr}             ; save state
d130 1
a130 1
        LDMIA   sp!,{r4-r11,pc}
d142 1
a142 1
        STMDB   sp!,{r4-r11,lr}             ; save state
d176 1
a176 1
        LDMIA   sp!,{r4-r11,pc}
d191 1
a191 1
        Clamp   $gun,8
d248 1
a248 1
        Clamp   r6,8
d250 1
a250 1
        Clamp   r7,8
d252 1
a252 1
        Clamp   r8,8
d317 1
a317 1
        Clamp   r6,8
d319 1
a319 1
        Clamp   r3,8
d321 1
a321 1
        Clamp   r4,8
d521 3
a523 1
        Clamp   $gun,5
d708 1
a708 1
        Clamp   $reg,8
@


1.1.2.5
log
@New jerror.h taken from IJG8b.
Swap to using JERR_ numbers, deleted E_ numbers.
Modify genjhdr to pass some defines to the assembler code, so jdcolor can clarify use of DCTSIZE and DCTSIZE2.
Added chart of possible subsampling ratios to documentation.

Version 1.38, 1.35.2.9. Tagged as 'SprExtend-1_38-1_35_2_9'
@
text
@d17 3
a19 2
; Colour conversion facilities, see also the contents of c.jdcolor.
; 24-Sep-93 - started
d22 2
d27 5
a31 3
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Monochrome colour conversion
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d77 3
a79 3
        ; extern int asm_mono_convert_pixel(int pix)
        ; /* Convert greyscale pixel into 32bit RGB values. */
        ;   r0 = luma, no shifting needed as it's not been through the DCT.
d85 3
a87 3
        ; extern int asm_mono_convert_pixels(int *y)
        ; /* Convert 4 greyscale pixels into 32bit RGB values. */
        ;   r0 -> array of luma, no shifting needed as it's not been through the DCT.
d101 8
a108 8
        ; extern void asm_mono_convert_block(JBLOCK jblock, int *outptr, int outoffset)
        ; /* Convert greyscale image into 32bit RGB values. */
        ;   r0 = jblock - in row order, values that need descaling
        ;   r1 = outptr - in column order, put RGB values here
        ;   r2 = outoffset - distance (in words) between output rows.
        ;   r11 = col counter.
        ; We LDR from the block and STM to the output rather than visa versa,
        ; because a long sequence of STRs clogs up the write buffer and is slow.
d112 1
a112 1
        MOV     r11,#DCTSIZE                ; col counter
d116 2
a117 2
        LDR     r3,[r0,#DCTSIZE*4*0]        ; get a whole row
        LDR     r4,[r0,#DCTSIZE*4*1]        ; interleave order hopes to help ARM8!
d119 1
a119 1
        LDR     r5,[r0,#DCTSIZE*4*2]
d121 1
a121 1
        LDR     r6,[r0,#DCTSIZE*4*3]
d123 1
a123 1
        LDR     r7,[r0,#DCTSIZE*4*4]
d125 1
a125 1
        LDR     r8,[r0,#DCTSIZE*4*5]
d127 1
a127 1
        LDR     r9,[r0,#DCTSIZE*4*6]
d129 1
a129 1
        LDR     r10,[r0,#DCTSIZE*4*7]
d141 8
a148 8
        ; extern void asm_mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset)
        ; /* Convert greyscale image into 8bit Grey values. */
        ;   r0 = jblock - in row order, values that need descaling
        ;   r1 = outptr - in column order, put grey values here
        ;   r2 = outoffset - distance (in words) between output rows.
        ;   r11 = col counter.
        ; We LDR from the block and STM to the output rather than visa versa,
        ; because a long sequence of STRs clogs up the write buffer and is slow.
d152 1
a152 1
        MOV     r11,#DCTSIZE                ; col counter
d156 2
a157 2
        LDR     r3,[r0,#DCTSIZE*4*0]        ; get a whole row
        LDR     r4,[r0,#DCTSIZE*4*1]        ; interleave order hopes to help ARM8!
d159 1
a159 1
        LDR     r5,[r0,#DCTSIZE*4*2]
d162 1
a162 1
        LDR     r6,[r0,#DCTSIZE*4*3]
d165 1
a165 1
        LDR     r7,[r0,#DCTSIZE*4*4]
d168 1
a168 1
        LDR     r8,[r0,#DCTSIZE*4*5]
d170 1
a170 1
        LDR     r9,[r0,#DCTSIZE*4*6]
d173 1
a173 1
        LDR     r10,[r0,#DCTSIZE*4*7]
d187 5
a191 3
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; YUV->RGB colour conversion 32bpp
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d213 6
a218 6
        ; extern void asm_colour_convert_pixels(int *y, int u, int v)
        ; /* Convert four pixels. Input y values are in y[0..3]. */
        ;   r0 -> the four blocks, YYYY, no shifting needed as it's not been through the DCT.
        ;   r1 = corresponding u
        ;   r2 = corresponding v
        ; the output goes back in y[0..3]
d269 8
a276 8
        ; extern void asm_colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset, int wide, int high)
        ; /* yuv[0..1] are Y, yuv[4] is U, yuv[5] is V. wide/high are 1 or 2. */
        ;   r0 -> the six blocks, YYYYUV (all row-ordered, ie 'wrong' way round, different from output)
        ;   r1 -> output buffer
        ;   r2 = offset in words between rows of output
        ;   r3 = hsamp
        ;   sp+0 = vsamp
        ; the output goes in outptr[row*outoffset + col] for row/col in 0..15
d350 8
a357 8
        ; extern void asm_colour_convert_block_32(JCOEF *yuv, int *outptr, int outoffset)
        ; /* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block */
        ;   r0 -> the six blocks, YYYYUV (all row-ordered, ie 'wrong' way round, different from output)
        ;   r1 -> output buffer
        ;   r2 = offset in words between rows of output
        ; the output goes in outptr[row*outoffset + col] for row/col in 0..15
        EXPORT  asm_colour_convert_block_32
asm_colour_convert_block_32
d359 1
a359 1
        ADD     r3,r1,#(2*DCTSIZE)*4        ; column limit pointer (inner loop) - outptr+16 words
d361 1
a361 1
        ADD     r5,r0,#4*DCTSIZE2*4         ; pointer into U block. V values DCTSIZE2 words on from this
d370 1
a370 1
        ; [r5,#DCTSIZE*4] is V value
d373 2
a374 2
        ; [r0,#DCTSIZE*4] is Y value for output word [r1,#4]
        ; [r0,#DCTSIZE*4+4] is Y value for output word [r1,#4 + r2,LSL #2] (so to speak!)
d380 1
a380 1
        LDR     r8,[r5, #DCTSIZE2*4]        ; V value
d434 1
a434 2
        ADD     r7,r0,#DCTSIZE*4            ; prepare to load next two pixels
        
d453 2
a454 2
        ADD     r5,r5,#DCTSIZE*4            ; pointer into row-organised U,V values
        ADD     r0,r0,#2*DCTSIZE*4          ; ditto for Y values
d467 4
a470 4
        SUB     r1,r1,#2*DCTSIZE*4          ;      ... and then to beginning of next output row.
        SUB     r5,r5,#(DCTSIZE2*4-4)*1     ; advance UV pointer to start of next row
        SUB     r0,r0,#(DCTSIZE2*4-4)*2     ; ditto Y pointer, but back two blocks
        ADD     r3,r1,#2*DCTSIZE*4          ; reset column limit pointer (inner loop) - outptr+16 words
d484 1
a484 1
        ADD     r0,r0,#((2*DCTSIZE2)-DCTSIZE)*4  ; advance r0 from end of row 0 of block 0,
d497 18
a514 3
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; YUV->RGB colour conversion 16bpp
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d533 6
a538 6
        ; extern void asm_colour_convert_block_16(JCOEF *yuv, short *outptr, int outoffset)
        ; /* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block of 16bit pixels */
        ;   r0 -> the six blocks, YYYYUV (all row-ordered, ie 'wrong' way round, different from output)
        ;   r1 -> output buffer
        ;   r2 = offset in words between rows of output
        ; the output goes in outptr[row*outoffset + col] for row/col in 0..15
d542 1
a542 1
        ADD     r3,r1,#(2*DCTSIZE)*2        ; column limit pointer (inner loop) - outptr+16 halfwords
d544 1
a544 1
        ADD     r5,r0,#4*DCTSIZE2*4         ; pointer into U block. V values DCTSIZE2 words on from this
d556 3
a558 3
        ; [r5,#DCTSIZE2*4] is V value
        ; [r0] and [r0,#DCTSIZE*4] are Y values for output word [r1]
        ; [r0,#4] and [r0,#DCTSIZE*4+4] are Y values for output word [r1,r2,LSL #2]
d564 1
a564 1
        LDR     r8,[r5,#DCTSIZE2*4]         ; V value
d616 1
a616 2
        ADD     r7,r0,#DCTSIZE*4            ; prepare to load next two pixels
        
d639 2
a640 2
        ADD     r5,r5,#DCTSIZE*4            ; pointer into row-organised U,V values
        ADD     r0,r0,#2*DCTSIZE*4          ; ditto for Y values
d653 4
a656 4
        SUB     r1,r1,#2*DCTSIZE*2          ;      ... and then to beginning of next output row.
        SUB     r5,r5,#(DCTSIZE2*4-4)*1     ; advance UV pointer to start of next row
        SUB     r0,r0,#(DCTSIZE2*4-4)*2     ; ditto Y pointer, but back two blocks
        ADD     r3,r1,#2*DCTSIZE*2          ; reset column limit pointer (inner loop) - outptr+16 halfwords
d672 1
a672 1
        ADD     r0,r0,#((2*DCTSIZE2)-DCTSIZE)*4  ; advance r0 from end of row 0 of block 0,
d676 5
a680 3
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; YUV->RGB colour conversion 8bpp
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
a720 2
        ; extern char *pixel_to_yuv_table_base(void)
        ; Returns the relocated address of the pixel to YUV table
a725 2
        ; extern int *yuv_to_pixel_table_base(void)
        ; Returns the relocated address of the YUV to pixel table
d732 6
a737 6
        ; extern void asm_colour_convert_block_8(JCOEF *yuv, char *outptr, int outoffset)
        ; /* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block of 8bit pixels */
        ;   r0 -> the six blocks, YYYYUV (all row-ordered, ie 'wrong' way round, different from output)
        ;   r1 -> output buffer
        ;   r2 = offset in words between rows of output
        ; the output goes in outptr[row*outoffset + col] for row/col in 0..15
d744 1
a744 1
        ADD     r3,r1,#(2*DCTSIZE)*1        ; column limit pointer (inner loop) - outptr+16 bytes
d746 1
a746 1
        ADD     r5,r0,#4*DCTSIZE2*4         ; pointer into U block. V values DCTSIZE2 words on from this
d764 7
a770 7
        ; [r5,#DCTSIZE2*4] is V value
        ; [r0] and [r0,#DCTSIZE*4] are Y values for output word [r1]
        ; [r0,#4] and [r0,#DCTSIZE*4+4] are Y values for output word [r1,r2,LSL #2]

        GetColourValue r7,"[r5]",r4              ; U value
        GetColourValue r8,"[r5,#DCTSIZE2*4]",r4  ; V value
        GetColourValue r9,"[r0,#4]",r4           ; Y value
d773 3
a775 3
        GetColourValue r7,"[r5]",r4              ; U value
        GetColourValue r8,"[r5,#DCTSIZE2*4]",r4  ; V value
        GetColourValue r9,"[r0]",r4              ; Y value
d782 3
a784 3
        GetColourValue r7,"[r5]",r4              ; U value
        GetColourValue r8,"[r5,#DCTSIZE2*4]",r4  ; V value
        GetColourValue r9,"[r0,#DCTSIZE*4]",r4   ; Y value
d787 3
a789 3
        GetColourValue r7,"[r5]",r4              ; U value
        GetColourValue r8,"[r5,#DCTSIZE2*4]",r4  ; V value
        GetColourValue r9,"[r0,#DCTSIZE*4+4]",r4 ; Y value
d795 2
a796 2
        ADD     r5,r5,#DCTSIZE*4            ; pointer into row-organised U,V values
        ADD     r0,r0,#2*DCTSIZE*4          ; ditto for Y values
d809 4
a812 4
        SUB     r1,r1,#2*DCTSIZE*1          ;      ... and then to beginning of next output row.
        SUB     r5,r5,#(DCTSIZE2*4-4)*1     ; advance UV pointer to start of next row
        SUB     r0,r0,#(DCTSIZE2*4-4)*2     ; ditto Y pointer, but back two blocks
        ADD     r3,r1,#2*DCTSIZE*1          ; reset column limit pointer (inner loop) - outptr+16 bytes
d833 1
a833 1
        ADD     r0,r0,#((2*DCTSIZE2)-DCTSIZE)*4  ; advance r0 from end of row 0 of block 0,
@


1.1.2.6
log
@Abstract entropy decoding.
Currently still only support Huffman, but now agnostic, there are two functions 'decode_mcu()' which does the full DC+AC decode of a full MCU worth of data, and 'skip_mcu()' which just does DC and consumes but discards the AC coefficients.
Apply fix from 1.40 trunk version for monochrome output in a 8bpp greyscale mode.
Restore name of DCTFIX() macro to FIX(), no longer needed now the constituent parts are compiled seperately rather than #included.
Fix CFSIjpeg to assemble even though it doesn't have a module base (the recently added 'relocatefn()' was breaking it).

Version 1.38, 1.35.2.14. Tagged as 'SprExtend-1_38-1_35_2_14'
@
text
@a57 2
        ADD     $r,$r,#4
        MOV     $r,$r,ASR #3             ; descale Y
d90 2
@


1.1.2.7
log
@Sync with trunk
Sources/SprOp - revision 4.10 copied
Sources/SprTrans - revision 4.16 copied
Sources/jdhuff - revision 4.7 copied
Also:
 DCI changed to instruction mnemonic for objasm 4
 Makefile excess '-c' removed
 Util.mk double inclusion of rules removed

Version 1.38, 1.35.2.16. Tagged as 'SprExtend-1_38-1_35_2_16'
@
text
@d41 1
a41 1
        USAT    $r, #$bits, $r
@



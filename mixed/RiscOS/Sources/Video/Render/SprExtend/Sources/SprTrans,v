head	4.19;
access;
symbols
	SprExtend-1_83:4.19
	SprExtend-1_82:4.19
	SprExtend-1_81:4.19
	SprExtend-1_80:4.19
	SprExtend-1_79:4.19
	SprExtend-1_78:4.19
	SprExtend-1_77:4.19
	SprExtend-1_76:4.19
	SprExtend-1_75:4.19
	SprExtend-1_74:4.19
	SprExtend-1_73:4.19
	SprExtend-1_72:4.19
	SprExtend-1_71-nocfsi:4.19
	SprExtend-1_71:4.19
	SprExtend-1_70-tracef:4.19
	SprExtend-1_70-headers:4.19
	SprExtend-1_70:4.19
	SprExtend-1_69:4.19
	SprExtend-1_68:4.19
	SprExtend-1_67:4.19
	SprExtend-1_66:4.19
	SprExtend-1_65:4.19
	SprExtend-1_64:4.19
	SprExtend-1_63:4.19
	SprExtend-1_62:4.19
	SprExtend-1_61:4.19
	SprExtend-1_60:4.19
	SprExtend-1_59:4.18
	SprExtend-1_58:4.18
	SprExtend-1_57:4.18
	SprExtend-1_56:4.18
	SprExtend-1_55:4.18
	SprExtend-1_54:4.17
	SprExtend-1_53:4.17
	SprExtend-1_52:4.17
	SprExtend-1_51:4.16
	SprExtend-1_50:4.16
	SprExtend-1_38-1_35_2_16:4.11.2.2
	SprExtend-1_49:4.16
	SprExtend-1_48:4.16
	SprExtend-1_47:4.16
	SprExtend-1_38-1_35_2_15:4.11.2.1
	SprExtend-1_46:4.15
	SprExtend-1_45:4.14
	SprExtend-1_44:4.14
	SprExtend-1_43:4.13
	SprExtend-1_42:4.12
	SprExtend-1_41:4.12
	SprExtend-1_38-1_35_2_14:4.11
	SprExtend-1_40:4.11
	SprExtend-1_38-1_35_2_13:4.11
	SprExtend-1_38-1_35_2_12:4.11
	SprExtend-1_38-1_35_2_11:4.11
	SprExtend-1_38-1_35_2_10:4.11
	SprExtend-1_38-1_35_2_9:4.11
	SprExtend-1_38-1_35_2_8:4.11
	SprExtend-1_39:4.11
	SprExtend-1_38-1_35_2_7:4.11
	SprExtend-1_38-1_35_2_6:4.11
	SprExtend-1_38-1_35_2_5:4.11
	SprExtend-1_38-1_35_2_4:4.11
	SprExtend-1_38-1_35_2_3:4.11
	SprExtend-1_38-1_35_2_2:4.11
	SprExtend-1_38-1_35_2_1:4.11
	MigrateIJG8b:4.11.0.2
	SprExtend-1_38:4.11
	SprExtend-1_37:4.11
	SprExtend-1_36:4.11
	SprExtend-1_35:4.11
	SprExtend-1_34:4.11
	SprExtend-1_33:4.11
	SprExtend-1_32:4.11
	SprExtend-1_31:4.11
	SprExtend-1_30:4.11
	SprExtend-1_29:4.11
	SprExtend-1_28:4.11
	SprExtend-1_27:4.11
	SprExtend-1_26:4.10
	SprExtend-1_25:4.10
	SprExtend-1_24:4.10
	SprExtend-1_23:4.10
	SprExtend-1_22:4.9
	SprExtend-1_21:4.9
	SprExtend-1_20:4.9
	SprExtend-1_19:4.9
	SprExtend-1_18:4.8
	SprExtend-1_17:4.8
	RO_5_07:4.8
	SprExtend-1_16:4.8
	SprExtend-1_15:4.8
	SprExtend-1_14:4.8
	SprExtend-1_13:4.7
	SprExtend-1_12:4.7
	SprExtend-1_11:4.6
	SprExtend-1_10:4.5
	SprExtend-1_09:4.5
	SprExtend-1_08:4.5
	dellis_autobuild_BaseSW:4.4
	SprExtend-1_07:4.4
	SprExtend-1_06:4.3
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.5
	SprExtend-1_05:4.2
	Ursula_merge:4.2
	nturton_SprExtend-1_04:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.19
date	2013.10.25.20.31.24;	author jlee;	state Exp;
branches;
next	4.18;
commitid	cSPorALl6Vf2qIax;

4.18
date	2013.10.07.00.39.07;	author jlee;	state Exp;
branches;
next	4.17;
commitid	HcUKy3PafwqToi8x;

4.17
date	2013.08.06.23.16.19;	author jlee;	state Exp;
branches;
next	4.16;
commitid	z9XOph7zDZQ2Ur0x;

4.16
date	2011.10.03.20.35.14;	author rsprowson;	state Exp;
branches;
next	4.15;
commitid	jlqGNWSdKaK0EWBv;

4.15
date	2011.08.05.00.17.44;	author jlee;	state Exp;
branches;
next	4.14;
commitid	M4NYP50KHXLUNfuv;

4.14
date	2011.07.10.10.08.02;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	OPrPsD1BKiXeUXqv;

4.13
date	2011.07.09.17.39.35;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	4K1NKIOUmX5SqSqv;

4.12
date	2011.03.14.23.30.04;	author srevill;	state Exp;
branches;
next	4.11;
commitid	liob2Sw1t7Hx8Sbv;

4.11
date	2010.09.19.09.03.44;	author rsprowson;	state Exp;
branches
	4.11.2.1;
next	4.10;

4.10
date	2010.08.29.08.36.04;	author rsprowson;	state Exp;
branches;
next	4.9;

4.9
date	2009.04.24.00.48.33;	author srevill;	state Exp;
branches;
next	4.8;

4.8
date	2002.12.19.18.53.14;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	2002.12.02.20.28.58;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2002.11.06.13.20.29;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2001.05.15.10.57.00;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	2000.06.27.13.58.02;	author jfletche;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.12.12.59.06;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.17.51.05;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.45.18;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.11.2.1
date	2011.08.06.10.44.29;	author rsprowson;	state Exp;
branches;
next	4.11.2.2;
commitid	gAycmEnWp5AVeruv;

4.11.2.2
date	2012.07.28.14.42.48;	author rsprowson;	state Exp;
branches;
next	;
commitid	Ny6vV3CHXwee5lew;

4.1.1.1
date	96.11.05.09.45.18;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.42.58;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.58.33;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.21.06;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.19
log
@Fix some sprite rendering issues. Add a new test app.
Detail:
  Bug fixes:
  - Sources/SprOp: Fixed a bug with PlotMask of old-format sprites not working correctly if the sprite is off the left edge of the screen. Fixed Log2bpp/Log2bpc confusion when plotting to double-pixel modes, caused by double pixel bodge being disabled.
  - Sources/SprTrans: Fixed transformed plotting of sprites with lefthand wastage drawing the sprite offset if a transformation matrix is used
  - c/PutScaled: Fixed another double pixel bodge related bug, when plotting double pixel sprites at certain offsets and with the two-at-a-time plotting code
  Test code:
  - Test/c/bigtest: A fairly comprehensive test app that generates lots of random sprites in every supported mode, and plots them using all APIs and options into all supported destination modes. Output is redirected to sprites (so the capabilities of the host video hardware are irrelevant), and checked against a model of what the expected output should look like. Also features some JPEG tests. A fast computer is recommended when running the tests!
  - Test/mkbigtest,fd7: Helper script to build bigtest
  - Test/bigtest2,ffb: Helper BASIC program to allow easy re-testing of failure cases
  - Test/JPEGs/*: Test JPEGs and reference sprites which are used by the JPEG test. JPEGs chosen to exercise all the output formats the JPEG code supports.
Admin:
  Tested on BB-xM


Version 1.60. Tagged as 'SprExtend-1_60'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.SprTrans

 ^ 0,SP
trns_spr_xcoords                #       16      ;       Four x coordinates
trns_spr_ycoords                #       16      ;       Four y coordinates
trns_comp_spr_left              #       4       ;       Sprite left hand edge (bottom 16 bits)
trns_comp_spr_start             #       4       ;       Sprite start (accounting for internal coord block top)
trns_comp_spr_byte_width        #       4       ;       Sprite byte width << (3-sprite bpp) i.e. row pitch in pixels
trns_comp_spr_height            #       4       ;       Sprite height (top 16 bits) and right hand edge (bottom 16)
trns_comp_spr_ttr               #       4       ;       Translation table (if required)
trns_comp_spr_masko             #       4       ;       Sprite mask offset from image << (3-sprite bpp)
trns_comp_ecf_ora               #       4       ;       ECF OR word
trns_comp_ecf_eor               #       4       ;       ECF EOR word
trns_codebuffer                 #       4       ;       Pointer to codebuffer
trns_spr_X_x0_y                 #       4       ;       Sprite X,Y at top coordinate of area
trns_spr_Y_x0_y                 #       4       ;            in 16.16 fixed point
trns_spr_inc_X_x                #       4       ;       Sprite increments
trns_spr_inc_Y_x                #       4       ;          ( change induced by single
trns_spr_inc_Y_y                #       4       ;            increments in screen x,y on
trns_spr_inc_X_y                #       4       ;            sprite X,Y )
trns_spr_lineptr                #       4       ;       Line to output onto
trns_spr_edgeblock              #       6*4*4   ;       Edge blocks, in format as below
trns_spr_edgeblock_end          #       4*6     ;        -1, to denote end of edge block
trns_ecf_ptr                    #       4       ;       Ecf pointer
trns_masking_word               #       4       ;       Masking word for > eight bit per pixel
trns_comp_mask_offset           #       4       ;       used to point at 1bpp mask data
trns_comp_spr_mask_width        #       4       ;       1bpp mask equivalent of spr_width
trns_comp_mask_base             #       4       ;       1bpp mask adjustment to mask data
trns_asm_workspace              #       4       ;       assembler R12
trns_spr_vars_end               *       :INDEX:@@

; The edge blocks are stored in a similar fashion to Draw Quick Fill, and the code is mainly a copy
; of that. The actual layout of the blocks is as follows:
;   Offset 0  : Flag word. Top two bits specify direction of line in the X-axis (01=positive,1x=negative)
;                          Bottom two bits specify whether edge is active (01), not yet active (00), or dead (11)
;      The next 5 words are dependent on the flags. For active edges:
;   Offset 4  : Lower Y coordinate (in 256ths pixels, bottom of screen is 0) of edge. The line is deactivated
;                 after reaching this Y coordinate
;   Offset 8  : ABS(deltaX) for the line, in 256ths of a pixel
;   Offset 12 : ABS(deltaY) for the line, in 256ths of a pixel
;   Offset 16 : Bresenham error value for the pixel
;   Offset 20 : Current X coordinate of the point (in pixels)
;       For inactive edges:
;   Offset 4  : Lower X coordinate (256ths of pixel)
;   Offset 8  : Lower Y coordinate
;   Offset 12 : Upper X coordinate
;   Offset 16 : Upper Y coordinate
trns_activated          *       2_0001
trns_deactivated        *       2_0010


trns_xsize              RN      0 ; Top 16 bits only.           Used throughout the compiled loop
trns_spr_left           RN      0 ; Bottom 16 bits only.        Used throughout the compiled loop
trns_scr_lx             RN      0 ;                             Used outside the loop
trns_spr_start          RN      1 ;                             Used throughout the loop
trns_scr_rx             RN      1 ;                             Used outside the loop
trns_offset             RN      2 ;                             Used throughout the loop
trns_scr_y              RN      2 ;                             Used outside the loop
trns_X                  RN      3 ;                             Used throughout the loop
trns_X_x0_y             RN      3 ;                             Used outside the loop
trns_Y                  RN      4 ;                             Used throughout the loop
trns_Y_x0_y             RN      4 ;                             Used outside the loop
trns_inc_X_x            RN      5 ;                             Used throughout the loop & outside the loop
trns_inc_Y_x            RN      6 ;                             Used throughout the loop & outside the loop
trns_byte_width         RN      7 ;                             Used throughout the loop
trns_inc_X_y            RN      7 ;                             Used outside the loop
trns_spr_height         RN      8 ; Top 16 bits only.           Used throughout the compiled loop
trns_spr_right          RN      8 ; Bottom 16 bits only.        Used throughout the compiled loop
trns_inc_Y_y            RN      8 ;                             Used outside the loop
trns_out_ptr            RN      9 ;                             Used throughout the loop
trns_line_ptr           RN      9 ;                             Used outside the loop
trns_out_word           RN      10;                             Used throughout the loop
trns_vertex_ptrs        RN      10;                             Used outside the loop
trns_out_mask           RN      11;                             Used throughout the loop
trns_dummy11            RN      11;                              (dummy register - used outside the loop)
trns_out_x              RN      12;                             Used on entry to the compiled loop
trns_workspace_ptr      RN      12;                             Workspace pointer
trns_dummy12            RN      12;                              (dummy register - used everywhere)
trns_in_pixel           RN      14;                             Used in the middle to end of loop
trns_dummy14            RN      14;                              (dummy register - used everywhere)

        MACRO
$label  DivRem2 $rc, $ra, $rb, $rtemp
$label
        [       debugtr
        TEQ     $rb,#0
        SWIEQ   OS_BreakPt
        ]
        MOV     $rtemp, $rb
        CMP     $rtemp, $ra, LSR #1
01
        MOVLS   $rtemp, $rtemp, LSL #1
        CMPLS   $rtemp, $ra, LSR #1
        BLS     %BT01
        MOV     $rc, #0
02
        CMP     $ra, $rtemp
        SUBCS   $ra, $ra, $rtemp
        ADC     $rc, $rc, $rc
        MOV     $rtemp, $rtemp, LSR #1
        CMP     $rtemp, $rb
        BCS     %BT02
        MEND

 [ usemull
        ! 0, "Using SMULL - StrongARM or later only"
 ]

        MACRO
        SSmultD $ra,$rb,$rl,$rh
        ; Asserts to check requirements always meet both options
        ASSERT  $rh = $rl + 1
        ASSERT  $ra <= R8
        ASSERT  $rb <= R8
        ASSERT  $rl <= R7
 [ usemull
    [ $ra = $rl :LOR: $ra = $rh
        ! 0, "Register clash avoided in SSmultD"
        MOV     R14, $ra
        SMULL   $rl,$rh,R14,$rb
    |
        SMULL   $rl,$rh,$ra,$rb
    ]
 |
        BL      arith_SSmultD
        DCB     $ra,$rb,$rl,0
 ]
        MEND


        MakeSpriteErrorBlock BadFlags,,BadFlgs
        MakeSpriteErrorBlock BadCoordBlock,,BadCBlk
        MakeSpriteErrorBlock BadSourceRectangle,,BadRect
        MakeSpriteErrorBlock BadTransformation,,BadTfrm

badcoordblock
        ADR     R0, ErrorBlock_BadCoordBlock
        addr    r1, Title
        BL      copy_error_one                  ; Always sets the V bit
        B       exitbiggie

nullareasource
        ADR     R0, ErrorBlock_BadSourceRectangle
        addr    r1, Title
        BL      copy_error_one                  ; Always sets the V bit
        B       exitbiggie

badtransformation
        ADR     R0, ErrorBlock_BadTransformation
        addr    r1, Title
        BL      copy_error_one                  ; Always sets the V bit
        B       exitbiggie

        GBLA    flg_matrix
        GBLA    flg_coordblock
flg_matrix      SETA    1
flg_coordblock  SETA    2

Go_PlotMaskTransformed
        Push    "R1-R9,LR"
; Pretend its a GCOL 8 - use sprite's mask if it has one
        MOV     R5,#8
; No colour translation
        MOV     R7,#0
        B       %FT01

Go_PutSpriteTransformed
        Push    "R1-R9,LR"
01
        Debug   tr,"Draw sprite: R0,R1,R2 =",R0,R1,R2
        Debug   tr,"Coords, gcol, &scale, &ttr =",R3,R4,R5,R6,R7

        CLRPSR  I_bit, R14              ; re-enable interrupts

        MOV     R14, R5, LSR #4
        STR     R14, trns_flags2
        BIC     R14, R14, #flg2_translucency
        BICS    R14, R14, #flg2_ignorettr + flg2_widetrans + flg2_ditheron + flg2_colourmap
        ADRNE   R0, ErrorBlock_BadFlags
        addr    r1, Title, NE
        BLNE    copy_error_one          ; Always sets the V bit
        BVS     exitbiggie

        AND     R5,R5,#&0F              ; only bottom 4 bits are interesting

        BICS    R14, R3, #flg_matrix:OR:flg_coordblock  ; Check for legal flags
        ADRNE   R0, ErrorBlock_BadFlags
        addr    r1, Title, NE
        BLNE    copy_error_one          ; Always sets the V bit
        BVS     exitbiggie

; see if reason code indicated a sprite name or sprite pointer in R2

        BL      findsprite              ; R2 --> sprite

        MOVVC   R1,R2                   ; now R1 --> sprite

; read input/output mode variables

        BLVC    readvduvars
        LDRVC   R0,[R1,#spMode]         ; get sprite's original mode
        STRVC   R0,save_mode            ; save mode for C code to use
        STRVC   R1,save_sprite          ; save sprite too
        MOVVC   R14,R0,LSR #27

        STRVC   R14,save_spr_type       ; and derive the sprite type from it
        BLVC    readspritevars
        BVS     exitbiggie

        MOV     R8,#0                   
        STR     R8,calibration_table    ; no printer calibration table
        LDR     r14, trns_flags2
        TST     r14, #flg2_translucency
        MOVEQ   r14, #0
        MOVNE   r14, #1                 ; set up translucency blending
        TST     r0, #&80000000          ; alpha mask?
        LDREQ   r0, save_inmodeflags
        TSTEQ   r0, #ModeFlag_DataFormatSub_Alpha ; or alpha channel?
        LDRNEB  r0, spritecode
        TSTNE   R5,#8                   ; and masking enabled?
        TEQNE   r0, #SpriteReason_PlotMaskTransformed ; and not plotting mask?
        ORRNE   r14, r14, #2            ; set up alpha channel/mask blending
        STR     r14, blending
        CMP     r14, #0                 ; blending enabled?
        BICNE   r5, r5, #7              ; then GCOL not allowed
        CMP     R7,R7,ASR #31           ; documented as <=0 being none - now accept 0 or -1
        MOVEQS  R7,#0                   ; 0 ==> no translation
        BL      preparettr

; adapt mode variables intelligently (account for double pixel modes)

        LDR     R8, Log2bpc
        LDR     R9, Log2bpp
        SUB     R8, R8, R9
        LDR     R0, gwx0
        MOV     R0, R0, ASL R8
        STR     R0, gwx0
        LDR     R0, gwx1
        ADD     R0, R0, #1
        MOV     R0, R0, ASL R8
        STR     R0, gwx1

; Valid registers: R1 - ptr to sprite?, R3 - flags, R4 -> coordinate block, R5 GCOL, R6->matrix/coords
;        Debug   tr,"Read VDU and sprite:",#gwx0,#gwy0,#gwx1,#gwy1,#orgx,#orgy
;        Debug   tr,"Pointer to sprite:",R1
; Get coordinate block

        LDR     R2, save_inlog2bpp
        TST     R3, #flg_coordblock
        BNE     %FT01

; (whole sprite R0 - left, R8 - top y, R9 - right, R14 - bottom)

        LDR     R14, save_spr_type
        CMP     R14, #0
        LDREQ   R0, [R1, #spLBit]
        MOVEQ   R0, R0, ASR R2
        MOVNE   R0, #0                  ; new format sprites don't have any lh wastage
        LDR     R8, [R1, #spHeight]
        ADD     R8, R8, #1
        LDR     R9, [R1, #spRBit]
        RSB     R9, R9, #31
        LDR     R4, [R1, #spWidth]
        ADD     R4, R4, #1
        RSB     R9, R9, R4, LSL#5
        MOV     R9, R9, ASR R2
        MOV     R14, #0
        B       %FT02
01

; Check area passed in

        LDMIA   R4, {R0,R8,R9,R14}

; If using a matrix then clip source rectangle to sprite

        TST     R3, #flg_matrix
        BNE     %FT03
        CMP     R8, #0
        MOVLT   R8, #0
        CMP     R14, #0
        MOVLT   R14, #0
        LDR     R4, [R1, #spHeight]
        ADD     R4, R4, #1
        CMP     R8, R4
        MOVGT   R8, R4
        CMP     R14, R4
        MOVGT   R14, R4
        CMP     R0, #0
        MOVLT   R0, #0
        CMP     R9, #0
        MOVLT   R9, #0

        LDR     R4, [R1, #spLBit]
        ADD     R0, R0, R4, LSR R2
        ADD     R9, R9, R4, LSR R2
        LDR     R4, [R1, #spRBit]
        RSB     R4, R4, #31
        LDR     R10, [R1, #spWidth]
        ADD     R10, R10, #1
        RSB     R4, R4, R10, LSL#5

        CMP     R0, R4, LSR R2
        MOVGT   R0, R4, LSR R2
        CMP     R9, R4, LSR R2
        MOVGT   R9, R4, LSR R2
        CMP     R0, R9
        CMPNE   R8, R14
        BEQ     nullareasource
        B       %FT02
03

; If not using a matrix then check valid source area

        CMP     R0, R9
        CMPNE   R8, R14
        BEQ     nullareasource
        CMP     R8, #0
        CMPGE   R14, #0
        BLT     badcoordblock
        LDR     R4, [R1, #spHeight]
        ADD     R4, R4, #1
        CMP     R8, R4
        CMPLE   R14, R4
        BGT     badcoordblock
        CMP     R0, #0
        CMPGE   R9, #0
        BLT     badcoordblock

        LDR     R4, [R1, #spLBit]
        ADD     R0, R0, R4, LSR R2
        ADD     R9, R9, R4, LSR R2
        LDR     R4, [R1, #spRBit]
        RSB     R4, R4, #31
        LDR     R10, [R1, #spWidth]
        ADD     R10, R10, #1
        RSB     R4, R4, R10, LSL#5

        CMP     R0, R4, LSR R2
        CMPLE   R9, R4, LSR R2
        BGT     badcoordblock
02
        TST     R3, #flg_matrix
        BNE     coords_passed_in

; Valid registers: R0,R8,R9,R14 - source rect, R1 - ptr to sprite, R5 GCOL, R6->matrix/coords
; Set up input path for draw - move to R0,R8, move to R9,R14, end path

        Push    "R0,R1,R2,R3,R4,R5,R7,R8,R9,R10,R11,R12,R14"

; The X min/max coordinates generated above are pixel offsets into the sprite
; data, including any required lefthand wastage offset. But when generating
; the path block we want to ignore lefthand wastage to avoid sprites with
; wastage being rendered at an offset.

        LDR     R11, save_spr_type
        CMP     R11, #0
        LDREQ   R11, [R1, #spLBit]
        SUBEQ   R0, R0, R11, ASR R2     ; adjust left edge by wastage
        SUBEQ   R9, R9, R11, ASR R2     ; adjust right edge by wastage

        LDR     R11, inlog2px
        ADD     R11, R11, #8
        MOV     R1, R0, ASL R11         ; R1 = R0 scaled x
        MOV     R9, R9, ASL R11         ; R9 = R9 scaled x

        LDR     R11, inlog2py
        ADD     R11, R11, #8
        MOV     R8, R8, ASL R11         ; R8 = R8 scaled y
        MOV     R3, R14, ASL R11        ; R3 = R14 scaled y

        SUB     sp, sp, #64             ; Space for a path block
        MOV     R10, SP

        MOV     R11, #2
        MOV     R0, #2
        STMIA   R10!, {R0,R1,R8}        ; Move R1, R8.
        STMIA   R10!, {R0,R9}           ; Move R9,
        STMIA   R10!, {R8,R11}          ; R8. Move
        MOV     R11, #0
        STMIA   R10!, {R1,R3,R11}       ; R1, R3. End.

; Transform the path

        MOV     R0, SP
        MOV     R1, #0
        MOV     R2, R6
        MOV     R3, #0
        SWI     XDraw_TransformPath
        ADDVS   sp, sp, #64+4
        Pull    "R1,R2,R3,R4,R5,R7,R8,R9,R10,R11,R12,R14",VS
        BVS     exitbiggie

        ADD     R10, SP, #4             ; Get the transformed path (skipping 'Move')
        LDMIA   R10!, {R0,R3,R4,R6,R8,R9,R11,R14}
        ADR     R10, save_outoffset
        STMIA   R10!, {R0,R3,R6,R8}
        ADD     R6, R6, R11
        ADD     R8, R8, R14
        SUB     R6, R6, R0
        SUB     R8, R8, R3
        STMIA   R10!,{R6,R8,R11,R14}

; Recover R6
        ADR     R6, save_outoffset
        ADD     sp, sp, #64
        Pull    "R0,R1,R2,R3,R4,R5,R7,R8,R9,R10,R11,R12,R14"

; Make Y values offset from the top of the sprite, not the bottom

coords_passed_in
        LDR     R2, [R1, #spHeight]
        ADD     R2, R2, #1
        SUB     R8, R2, R8
        SUB     R14, R2, R14

; Get R4 = distance from top of sprite, R2 = height of sprite, and set R8,R14 to be offset from R4

        SUBS    R2, R8, R14
        RSBMI   R2, R2, #0
        MOVMI   R4, R8
        MOVPL   R4, R14
        SUB     R8, R8, R4
        SUB     R14, R14, R4

; Store height, left, right of sprite for inner loop

        SUB     sp, sp, #trns_spr_vars_end
        STR     R12, trns_asm_workspace
        CMP     R9, R0
        ORRGT   R10, R9, R2, LSL#16
        ORRLE   R10, R0, R2, LSL#16
        STR     R10, trns_comp_spr_height  ;       Height in top 16 bits, right side in bottom 16 bits
        STRGT   R0, trns_comp_spr_left    ;       Left side in bottom 16 bits (measurements in pixels)
        STRLE   R9, trns_comp_spr_left    ;       Left side in bottom 16 bits (measurements in pixels)

; Add R4*sprite_byte_width to sprite_pixel_data_start to give top of sprite, and store for loop


        LDR     R2, [R1, #spImage]
        LDR     R10, [R1, #spWidth]
        Debug   ag,"spWidth is",R10
        Debug   ag,"sprite is at",R1
        ADD     R10, R10, #1
        MOV     R10, R10, LSL#2
        MLA     R11, R10, R4, R2
        ADD     R11, R11, R1
        STR     R11, trns_comp_spr_start

        LDR     R2,[r1,#spMode]
        Debug   ag,"spMode is",R2

; and we have to do the same for the mask data now
; for now we just save the R4 value and deal with it once we have the mask
; equivalent of spWidth computed for the mask

        STR     R4, trns_comp_mask_base

; Work out byte width << 3-input_bpp, and store for loop

        LDR     R4, save_inlog2bpp
        CMP     R4, #4
        BCC     %FT89

        SUB     R4, R4, #3
        MOV     R11, R10, LSL #3
        MOV     R10, R10, LSR R4
        B       %FT88
89
        RSB     R4, R4, #3
        MOV     R11, R10, LSL #3
        MOV     R10, R10, LSL R4
88

        STR     R10, trns_comp_spr_byte_width

        TST     R2, #&80000000
        MOVNE   R10, R10, LSL #3

        ANDS    R11, R10, #&1F
        MOVNE   R11, #32
        ADD     R11, R11, R10
        BIC     R11, R11, #&1F

        TST     R2, #&80000000
        MOVNE   R11, R11, LSR #3
        Debug   ag,"mask_width is",R11

        STR     R11, trns_comp_spr_mask_width   ; used only for 1bpp/8bpp masks

        ;the mask_base was used earlier for the number of rows to go into the
        ;data, so now we turn that into a byte offset

        LDR     R10, trns_comp_mask_base        ; recover row number
        MUL     R10, R11, R10                   ; convert to offset (pixels)
        MOVEQ   R10, R10, LSR #3                ; convert to bytes for 1bpp
        STR     R10, trns_comp_mask_base

; Get mask offset and store ttr pointer (clear mask GCOL bit if there is no mask)

        LDR     R10, BPP
        LDR     R7, ColourTTR
        STR     R7, trns_comp_spr_ttr

        SUB     R10, R10,#1
        MOV     R11, #1:SHL:31
        MOV     R11, R11, ASR R10
        STR     R11, trns_masking_word                  ; suitable mask for pixels
        Debug   tr,"trns_masking_word",R11

        LDR     R10, [R1, #spTrans]
        LDR     R11, [R1, #spImage]

        Debug   ag,"trans and image offsets",R10,R11

        SUBS    R11, R10, R11
        BICEQ   R5, R5, #8                 ; no mask, so can't do a plot with b3 set

        Debug   ag,"trans minus image",R11

        LDR     R4, save_inlog2bpp
        CMP     R4, #4
        RSBCC   R4, R4, #3
        SUBCS   R4, R4, #3
        MOVCC   R11, R11, LSL R4
        MOVCS   R11, R11, LSR R4

        ; R4 is finished with now, so used as a working register for the mask stuff

        LDR     R10,[R1,#spTrans]             ; re-fetch offset to mask
        ADD     R10,R10,R1                    ; turn into absolute address
        LDR     R4, trns_comp_mask_base       ; fetch byte offset within 1bpp mask data
        ADD     R10,R10,R4                    ; include it
        STR     R10,trns_comp_mask_base       ; and store back the final result
        Debug   ag,"mask_base is",R10

        STR     R11, trns_comp_spr_masko
        Debug   ag,"stored masko as",R11

        Debug   tr,"Coordinate block:",R0,R8,R9,R14
        Debug   tr,"Mask offset:",#trns_comp_spr_masko
        Debug   tr,"Flags, GCOL, &Screen block, &TTR",R3, R5, R6, R7
        Debug   tr,"Height/right, left, spr_start, spr_byte_width",#trns_comp_spr_height,#trns_comp_spr_left,#trns_comp_spr_start,#trns_comp_spr_byte_width

; Copy the coordinate block
; Valid registers: R0,R8,R9,R14 - source rect, R1 - ptr to sprite, R5 GCOL, R6->matrix/coords, R7->ttr
; copy coordinates, adding graphics origin

        Push    "R1,R5,R7,R12"
        Push    "R0,R8,R9,R14"
        ADR     R0, trns_spr_xcoords + 4*8

; get O.S. to pixel shift (account for double pixel modes)

        LDR     R1, log2px
        LDR     R2, Log2bpp
        ADD     R1, R1, R2
        LDR     R2, Log2bpc
        SUB     R1, R1, R2
        LDR     R2, log2py

; get graphics origin

        LDR     R3, orgx
        LDR     R4, orgy

; get coordinates

        LDMIA   R6, {R5,R6,R7,R8,R9,R10,R11,R12}

; x coords

        ADD     R14, R7, R11
        SUB     R14, R14, R5
        CMP     R14, R9
        Pull    "R0,R8,R9,R14",NE
        Pull    "R1,R5,R7,R12",NE
        ADDNE   sp, sp, #trns_spr_vars_end
        BNE     badtransformation
        ADD     R5, R5, R3, LSL#8
        ADD     R7, R7, R3, LSL#8
        ADD     R9, R9, R3, LSL#8
        ADD     R11, R11, R3, LSL#8
        MOV     R5, R5, ASR R1
        MOV     R7, R7, ASR R1
        MOV     R9, R9, ASR R1
        MOV     R11, R11, ASR R1
        STMIA   R0!, {R5,R7,R9,R11}

; y coordinates

        ADD     R14, R8, R12
        SUB     R14, R14, R6
        CMPNE   R14, R10
        Pull    "R0,R8,R9,R14",NE
        Pull    "R1,R5,R7,R12",NE
        ADDNE   sp, sp, #trns_spr_vars_end
        BNE     badtransformation
        ADD     R6, R6, R4, LSL#8
        ADD     R8, R8, R4, LSL#8
        ADD     R10, R10, R4, LSL#8
        ADD     R12, R12, R4, LSL#8
        MOV     R6, R6, ASR R2
        MOV     R8, R8, ASR R2
        MOV     R10, R10, ASR R2
        MOV     R12, R12, ASR R2
        STMIA   R0!, {R6,R8,R10,R12}

        Debug tr,"Transformed coords are:",R5,R6,R7,R8
        Debug tr,"Transformed coords are:",R9,R10,R11,R12

; Get determinant

        SUB     R9, R7, R5      ; x1
        SUB     R10, R11, R5     ; x2
        SUB     R11, R8, R6      ; y1
        SUB     R12, R12, R6     ; y2

        Debug tr,"x1,x2,y1,y2",R9,R10,R11,R12

; R4,5 = x1 * y2

        MOV     R0, R9
        MOV     R1, R12
        SSmultD R0,R1,R4,R5

; R6,7 = x2 * y1

        MOV     R0, R10
        MOV     R1, R11
        SSmultD R0,R1,R6,R7

; R4,R5 = x1*y2 - x2*y1 (48.16 precision)

        SUBS    R4, R4, R6
        SBC     R5, R5, R7

        Debug tr,"R4,R5,R6,R7:",R4,R5,R6,R7
; R4,R5 = x1*y2 - x2*y1 / 4 (48.14 precision)

        MOV     R4, R4, LSR#2
        ORR     R4, R4, R5,LSL#30
        MOV     R5, R5, ASR#2

; R6,R7 = 1 / (x1*y2 - x2*y1) (16.48 precision)

        TEQ     R4, #0
        TEQEQ   R5, #0
        MOVEQ   R6, #0
        MOVEQ   R7, #0
        BEQ     trns_division_by_zero
        MOV     R0, #0
        MOV     R1, #&40000000
        Debug tr,"Dividing:",R0,R1,R4,R5
        mextralong_divide R6,R7,R0,R1,R4,R5,R2,R3,R8
        Debug tr,"Gives:",R6,R7

trns_division_by_zero
        LDMFD   sp, {R0,R1,R2,R3}
        SUBS    R2, R2, R0
;        RSBMI   R2, R2, #0
        SUBS    R3, R3, R1
;        RSBMI   R3, R3, #0

; spr_inc_X_x = det*y2 [ * xsize ]

        MOV     R0, R12
        MOV     R1, R2
        BL      produce_increment
        MOV     R12, R4

; spr_inc_Y_x = det*-y1 [ * ysize ]

        RSB     R0, R11, #0
        MOV     R1, R3
        BL      produce_increment
        MOV     R11, R4

; spr_inc_X_y = det*-x2 [ * xsize ]

        RSB     R0, R10, #0
        MOV     R1, R2
        BL      produce_increment
        MOV     R10, R4

; spr_inc_Y_y = det*x1 [ * ysize ]

        MOV     R0, R9
        MOV     R1, R3
        BL      produce_increment
        MOV     R9, R4

; Store increments

        STR     R12, trns_spr_inc_X_x + 8*4
        STR     R11, trns_spr_inc_Y_x + 8*4
        STR     R10, trns_spr_inc_X_y + 8*4
        STR     R9, trns_spr_inc_Y_y + 8*4
        Pull    "R0,R8,R9,R14"
        Pull    "R1,R5,R7,R12"
        Debug   tr,"Coordinate block:",R0,R8,R9,R14

; thats all the horrid fixed point stuff out of the way
; Find the top y coordinate

        ADR     R3, trns_spr_ycoords
        LDMIA   R3!, {R4,R6,R10,R11}
        CMP     R6, R4
        MOVGT   R4, R6
        CMP     R10, R4
        MOVGT   R4, R10
        CMP     R11, R4
        MOVGT   R4, R11
        MOV     R2, R8

; Valid registers: R5 GCOL, R7->ttr, R4 - maximum ycoordinate of area
;                                       Get top y coordinate of centre of line being drawn in R1

        SUB     R1, R4, #128
        MOV     R1, R1, ASR#8
        LDR     R3, gwy1
        CMP     R1, R3
        MOVGT   R1, R3
        STR     R1, save_ycoord
        Debug tr,"Top coordinate on screen (PIXELS) is:",R1

;                                       Get address of line on screen

        LDR     R3, ywindlimit
        SUB     R3, R3, R1
        LDR     R8, screenstart
        LDR     R6, linelength
        MLA     R6, R3, R6, R8
        STR     R6, trns_spr_lineptr
;                                       Get ECF pointer
        LDR     R6, vdu_bgecforaeor
        AND     R3, R3, #7
        ADD     R6, R6, R3,LSL#3
;        Debug   tr, "Ecf pointer is:",R6
        STR     R6, trns_ecf_ptr

;spr_X_x0_y% += ((screen_y%-y(0)) * (!asm_spr_inc_X_y)) / 256
; screen_y%-y(0) = R6.R4

        MOV     R1, R1, ASL#8
        ADD     R1, R1, #128
        LDR     R4, trns_spr_ycoords
        SUB     R4, R1, R4
;        Debug tr,"scry%-y0:",R4
        MOV     R6, R4, ASR#16
        BIC     R4, R4, R6, LSL#16

; inc_X_y = R8.R9

        LDR     R14, trns_spr_inc_X_x
;        Debug tr,"IncXx",R14
        LDR     R14, trns_spr_inc_X_y
;        Debug tr,"incXy,Xx0",R14,R0
        MOV     R8, R14, ASR#16
        BIC     R9, R14, R8, LSL#16

; multiply

        MUL     R10, R9, R6
        MLA     R10, R8, R4, R10
        MUL     R11, R6, R8
        MUL     R14, R9, R4
        MOV     R14, R14, LSR#8
        ADD     R10, R14, R10,LSL #8
        ADD     R0, R10, R0,LSL #16
        ADD     R0, R0, R11,LSL#24

        Debug tr,"Xx0y:",R0
;spr_Y_x0_y% += ((screen_y%-y(0)) * (!asm_spr_inc_Y_y)) / 256
; inc_Y_y = R8.R9

        LDR     R14, trns_spr_inc_Y_y
        Debug tr,"incYy=",R14
        MOV     R8, R14, ASR#16
        BIC     R9, R14, R8, LSL#16
        MUL     R10, R9, R6
        MLA     R10, R8, R4, R10
        MUL     R11, R6, R8
        MUL     R14, R9, R4
        MOV     R14, R14, LSR#8
        ADD     R10, R14, R10,LSL #8
        ADD     R2, R10, R2,LSL#16
        ADD     R2, R2, R11,LSL#24

; Valid registers: R0,R2 - X_x0_y/Y_x0_y, R5 GCOL, R7->ttr

        STR     R0, trns_spr_X_x0_y
        STR     R2, trns_spr_Y_x0_y
        Debug tr,"Top corner (w.r.t. sprite) is:",R0,R2

; Now compile the code

        BL      compile_transform_code
return_from_sprtrans_compiler      
        MOV     R10, R0
        STR     R10, trns_codebuffer
        Debug tr,"Code compiled:",R10

; Now, set up the edges in the edge block

        ADR     R0, trns_spr_edgeblock
        MOV     R1, #0
        ADR     R2, trns_spr_xcoords
        LDMIA   R2, {R2,R3,R4,R5, R6,R7,R8,R9}

; Edge 0->1

        CMP     R6, R7
        STMGTIA R0!,{R1,R3,R7}
        STMGTIA R0!,{R2,R6}
        STMLEIA R0!,{R1,R2,R6}
        STMLEIA R0!,{R3,R7}

; Edge 1->2

        ADD     R0, R0, #8
        CMP     R7, R8
        STMGTIA R0!,{R1,R4,R8}
        STMGTIA R0!,{R3,R7}
        STMLEIA R0!,{R1,R3,R7}
        STMLEIA R0!,{R4,R8}

; Edge 0->3

        ADD     R0, R0, #8
        CMP     R6, R9
        STMGTIA R0!,{R1,R5,R9}
        STMGTIA R0!,{R2,R6}
        STMLEIA R0!,{R1,R2,R6}
        STMLEIA R0!,{R5,R9}

; Edge 3->2

        ADD     R0, R0, #8
        CMP     R9, R8
        STMGTIA R0!,{R1,R4,R8}
        STMGTIA R0!,{R5,R9}
        STMLEIA R0!,{R1,R5,R9}
        STMLEIA R0!,{R4,R8}
        ADD     R0, R0, #8
        MVN     R1, #0
        STR     R1, [R0]

;;        Debug tr,"Active edge list:",#trns_spr_edgeblock,#trns_spr_edgeblock+4,#trns_spr_edgeblock+8,#trns_spr_edgeblock+12,#trns_spr_edgeblock+16,#trns_spr_edgeblock+20,#trns_spr_edgeblock+24
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+28,#trns_spr_edgeblock+32,#trns_spr_edgeblock+36,#trns_spr_edgeblock+40,#trns_spr_edgeblock+44,#trns_spr_edgeblock+48,#trns_spr_edgeblock+52
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+56,#trns_spr_edgeblock+60,#trns_spr_edgeblock+64,#trns_spr_edgeblock+68,#trns_spr_edgeblock+72,#trns_spr_edgeblock+76,#trns_spr_edgeblock+80
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+84,#trns_spr_edgeblock+88,#trns_spr_edgeblock+92,#trns_spr_edgeblock+96,#trns_spr_edgeblock+100,#trns_spr_edgeblock+104,#trns_spr_edgeblock+108

; Get top Y coordinate

        LDR     R1, save_ycoord
        MOV     R11, #3

; Start loop - looping until all edges are deactivated or below Y coord

00
        LDR     R14, gwy0
        CMP     R1, R14
        BLT     trns_completed_drawing

; Activate any new edges, deactivate old ones (R11 = count of deactivated edges)

        ADR     R10, trns_spr_edgeblock
01
        LDMIA   R10, {R0,R5,R6,R7,R8,R9,R14}

; Checked all the edges?

        CMN     R0, #1
        BEQ     activated_all_edges

; If dead then ignore

        TST     R0, #trns_deactivated
        BNE     edge_inactive

; If active then shoule we deactivate it?

        TST     R0, #trns_activated
        BNE     edge_active

; Test for activation

        SUB     R14, R8, #128
        CMP     R1, R14, ASR #8
        BGT     edge_inactive

; Activate an edge

        SUB     R8, R8, #128
        SUB     R6, R6, #128
        ORR     R0, R0, #trns_activated

; Calculate R3=ABS(deltaX) and R4=ABS(deltaY).

        SUBS    R3,R7,R5
        RSBLT   R3,R3,#0
        SUB     R4,R8,R6                ;Must be correct sign already - lines are sorted wrt Y coords.

; Record direction of line as 1 or -1 in top two bits of flags

        ORR     R0,R0,#&40000000        ;line goes rightwards
        ORRGE   R0,R0,#&80000000        ;Processor Status preserved from above - GE if line goes leftwards

; Now calculate target Y co-ordinate - the line must stop after this Y value is reached.

        MOV     R2,R6,ASR #8
        ADD     R2,R2,#1
        CMP     R1, R2
        MOVLT   R0, #trns_deactivated
        BLT     edge_inactive

; Valid registers: R0-flags, R1-current Y, R2-target Y, R3,R4-dX,dY,
;                  R7,R8-Upper x,y, R10-store for edge, R11-count of deactivated edges
; Now get Bresenham error in R6.

        AND     R14,R7,#&FF
        MOV     R7,R7,ASR #8
        ADD     R6,R3,R4                ;ABS(deltaX)+ABS(deltaY)
        CMP     R6,#&80000000:SHR:8
        BLO     out_qfill_spbres

; Only do complicated stuff if simple stuff will overflow

out_qfill_dpbres
        Push    "R0,R4,R5,R7"

; R7=-1,C=1 for leftward lines, R7=0,C=0 for rightward lines.

        MOVS    R7,R0,ASR #32

; Get R0=real sub-X coordinate on screen (R14=subpixel now)

        SUB     R0,R14,#128
        RSBCS   R0,R0,#0

; R4,R5 = R0*dY , R6,R7=R4,R5 -1 if leftward,+0 i rightward

        SSmultD R0,R4,R4,R5             ;subpixelX * ABS(deltaY) into R4,R5
        ADDS    R6,R4,R7                ;Accumulate into R6,R7
        ADC     R7,R5,R7

; R6,R7 += R0*dX

        AND     R0,R8,#255
        SSmultD R0,R3,R4,R5
        ADDS    R6,R4,R6
        ADC     R7,R5,R7

; Change error to full pixel instead of 256ths pixels

        MOV     R6,R6,LSR #8
        ORR     R6,R6,R7,LSL #24
        Pull    "R0,R4,R5,R7"
        B       out_qfill_bresdone

; Do simple stuff

out_qfill_spbres

; R6=-1,C=1 for leftward lines, R6=0,C=0 for rightward lines.

        MOVS    R6,R0,ASR #32

; Get R0=real sub-X coordinate on screen (R14=subpixel now)

        SUB     R14,R14,#128
        RSBCS   R14,R14,#0
        MLA     R6,R14,R4,R6            ;Accumulate subpixelX * ABS(deltaY)
        AND     R14,R8,#255
        MLA     R6,R14,R3,R6            ;Accumulate subpixelY * ABS(deltaX)
        MOV     R6,R6,ASR #8            ;Change units to full pixels

; Now R6=Bresenham value

out_qfill_bresdone
        MOV     R8,R8,ASR #8

; Now advance the edge until we're on the right scan line and the Bresenham
; value is negative.

        CMP     R1,R2                   ;Don't bother if we're below target Y
        BLT     out_qfill_doneclip
        SUBS    R8,R8,R1                ;Must set GT or EQ
        BLGT    out_qfill_fastclip
        CMP     R6,#0                   ;So this can only happen if R1 >= R2
out_qfill_Xcliploop
        ADDGE   R7,R7,R0,ASR #30        ;Advance in X direction as far as
        SUBGES  R6,R6,R4                ;  possible
        BGE     out_qfill_Xcliploop
out_qfill_doneclip
        ADD     R6,R6,R3

; Store flags,targetY,deltaX,deltaY

        STMIA   R10!,{R0,R2,R3,R4}
        STMIA   R10!, {R6,R7,R8}
        B       edge_no_store
edge_active

; If now below it then kill it

        CMP     R1, R5                  ; Check for deactivating the edge
        MOVLT   R0, #trns_deactivated
        SUBLT   R11, R11, #1
        ADD     R8,R8,R6                ;Adjust Bresenham value for Y move
edge_inactive
        STMIA   R10!, {R0,R5,R6,R7,R8,R9,R14}
edge_no_store
        B       %BT01
activated_all_edges
        CMP     R11, #0
        BLT     trns_completed_drawing

;;        Debug tr,"Active edge list:",#trns_spr_edgeblock,#trns_spr_edgeblock+4,#trns_spr_edgeblock+8,#trns_spr_edgeblock+12,#trns_spr_edgeblock+16,#trns_spr_edgeblock+20,#trns_spr_edgeblock+24
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+28,#trns_spr_edgeblock+32,#trns_spr_edgeblock+36,#trns_spr_edgeblock+40,#trns_spr_edgeblock+44,#trns_spr_edgeblock+48,#trns_spr_edgeblock+52
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+56,#trns_spr_edgeblock+60,#trns_spr_edgeblock+64,#trns_spr_edgeblock+68,#trns_spr_edgeblock+72,#trns_spr_edgeblock+76,#trns_spr_edgeblock+80
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+84,#trns_spr_edgeblock+88,#trns_spr_edgeblock+92,#trns_spr_edgeblock+96,#trns_spr_edgeblock+100,#trns_spr_edgeblock+104,#trns_spr_edgeblock+108
;;        Debug tr,"Number of active/not yet activated edges:",R11

; Move on all active lines

        ADR     R10, trns_spr_edgeblock
01
        LDMIA   R10!, {R0,R2,R3,R4,R6,R7,R8}
        CMN     R0, #1
        BEQ     trns_draw_line
        TST     R0, #trns_activated
        BEQ     %BT01

; R0-flags, R2 - target Y, R3 - deltaX, R4-deltaY
; R6-Bresenham error value, R7-current X

        SUB     R8,R7,R0,ASR #31        ;Calculate crossing X
        CMP     R1,R2                   ;Stop if already below target
        BLT     trns_deactivate_2
;        CMP     R4,R6,ASR #3            ;Use fast code?
;        BLLE    out_qfill_fasthoriz
        CMP     R6,#0                   ;Are we still below the edge?
02
        ADDGE   R7,R7,R0,ASR #30        ;Make X moves until we're above the
        SUBGES  R6,R6,R4                ;  edge, adjusting Bresenham value
        BGE     %BT02                   ;  for them
        STMDB   R10, {R0,R2,R3,R4,R6,R7,R8}
        B       %BT01

trns_deactivate_2
        MOV     R0, #trns_deactivated
        STMDB   R10, {R0,R2,R3,R4,R6,R7,R8}
        B       %BT01

; Now find the pair of lines which are active

trns_draw_line
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock,#trns_spr_edgeblock+4,#trns_spr_edgeblock+8,#trns_spr_edgeblock+12,#trns_spr_edgeblock+16,#trns_spr_edgeblock+20,#trns_spr_edgeblock+24
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+28,#trns_spr_edgeblock+32,#trns_spr_edgeblock+36,#trns_spr_edgeblock+40,#trns_spr_edgeblock+44,#trns_spr_edgeblock+48,#trns_spr_edgeblock+52
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+56,#trns_spr_edgeblock+60,#trns_spr_edgeblock+64,#trns_spr_edgeblock+68,#trns_spr_edgeblock+72,#trns_spr_edgeblock+76,#trns_spr_edgeblock+80
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+84,#trns_spr_edgeblock+88,#trns_spr_edgeblock+92,#trns_spr_edgeblock+96,#trns_spr_edgeblock+100,#trns_spr_edgeblock+104,#trns_spr_edgeblock+108
;;        Debug tr,"Number of active/not yet activated edges:",R11
        ADR     R10, trns_spr_edgeblock
01
        LDMIA   R10!, {R0,R2,R3,R4,R5,R6,R7}
        CMN     R0, #1
        BEQ     trns_completed_drawing
        TST     R0, #1
        BEQ     %BT01
01
        LDMIA   R10!, {R0,R2,R3,R4,R5,R6,R8}
        CMN     R0, #1
        BEQ     trns_completed_drawing
        TST     R0, #1
        BEQ     %BT01

; R6,R7 are x coords to plot between at current Y

        Push    "R1,R11,R12"
        MOV     trns_scr_lx, R7
        MOV     trns_scr_rx, R8
        ASSERT trns_scr_lx<>R6
        ASSERT trns_scr_y<>R6
        ASSERT trns_scr_y<>R7
        LDR     R14, trns_ecf_ptr + 3*4
        LDMIA   R14!, {trns_X_x0_y, trns_Y_x0_y}
        STR     trns_X_x0_y, trns_comp_ecf_ora + 3*4
        STR     trns_Y_x0_y, trns_comp_ecf_eor + 3*4
        LDR     trns_scr_y, vdu_bgecforaeor
        ADD     trns_scr_y, trns_scr_y, #64
        CMP     R14, trns_scr_y
        SUBGE   R14, trns_scr_y, #64
        MOV     trns_scr_y, R1
        STR     R14, trns_ecf_ptr + 3*4
        ADR     R14, trns_spr_X_x0_y + 3*4
        LDMIA   R14, {trns_X_x0_y,trns_Y_x0_y,trns_inc_X_x,trns_inc_Y_x,trns_inc_X_y,trns_inc_Y_y,trns_line_ptr}

;;        Debug tr,"Calling plotting routine: lx,rx,ty",trns_scr_lx, trns_scr_rx, trns_scr_y
;;        Debug tr,"incXx,Yx,Xy,Yy,lineptr",trns_inc_X_x,trns_inc_Y_x,trns_inc_X_y,trns_inc_Y_y,trns_line_ptr
;;        Debug tr,"X0Y0",trns_X_x0_y,trns_Y_x0_y

        BL      plot_and_calculate_row
        Pull    "R1,R11,R12"
        LDR     R14, linelength
        LDR     trns_line_ptr, trns_spr_lineptr
        ADD     trns_line_ptr, trns_line_ptr, R14
        STR     trns_line_ptr, trns_spr_lineptr
        LDR     trns_X_x0_y, trns_spr_X_x0_y
        LDR     trns_Y_x0_y, trns_spr_Y_x0_y
        LDR     trns_inc_X_y, trns_spr_inc_X_y
        LDR     trns_inc_Y_y, trns_spr_inc_Y_y
        SUB     trns_X_x0_y, trns_X_x0_y, trns_inc_X_y
        SUB     trns_Y_x0_y, trns_Y_x0_y, trns_inc_Y_y
        STR     trns_X_x0_y, trns_spr_X_x0_y
        STR     trns_Y_x0_y, trns_spr_Y_x0_y
        SUB     R1, R1, #1
        B       %BT00

trns_completed_drawing

; Update changed coordinate block?

        LDR     R14, changedbox
        LDR     R0, [R14], #4
        TST     R0, #1
        BEQ     trns_no_changed_box

; Get R6 = top y, R4 = bottom y

        LDR     R6, save_ycoord
        MOV     R4, R1

; Check top y was above gwy0, else no change to box

        LDR     R0, gwy0
        CMP     R6, R0
        BLT     trns_no_changed_box

; Find R3 = left x, R5 = right x

        ADR     R0, trns_spr_xcoords
        LDMIA   R0, {R3,R7,R8,R9}
        MOV     R5, R3
        CMP     R3, R7
        MOVGT   R3, R7
        CMP     R3, R8
        MOVGT   R3, R8
        CMP     R3, R9
        MOVGT   R3, R9
        CMP     R5, R7
        MOVLT   R5, R7
        CMP     R5, R8
        MOVLT   R5, R8
        CMP     R5, R9
        MOVLT   R5, R9

; Now convert from 256ths pixels to pixels, and clip to graphics window

        ADD     R3, R3, #128
        MOV     R3, R3, ASR #8
        ADD     R5, R5, #128
        MOV     R5, R5, ASR #8
        LDR     R0, gwx0
        LDR     R1, gwx1
        CMP     R3, R0
        MOVLT   R3, R0
        CMP     R5, R1
        MOVGT   R5, R1
        CMP     R3, R5
        BGT     trns_no_changed_box

; Unbodge double pixels

        LDR     R7, Log2bpc
        LDR     R8, Log2bpp
        SUB     R7, R7, R8
        MOVNE   R3, R3, LSL R7
        MOVNE   R5, R5, LSL R7
        ADD     R4, R4, #1

; Get original box and update it

        LDMIA   R14, {R0,R1,R2,R7}
        CMP     R0, R3
        MOVGT   R0, R3
        CMP     R1, R4
        MOVGT   R1, R4
        CMP     R2, R5
        MOVLT   R2, R5
        CMP     R7, R6
        MOVLT   R7, R6
        STMIA   R14, {R0,R1,R2,R7}

trns_no_changed_box
        ADD     sp, sp, #trns_spr_vars_end
        CLRV
        B       exitbiggie


; -------------------------------------------------------------
; - Routine to get increment in sprite due to x or y movement -
; -------------------------------------------------------------
; R0 - x or y distance
; R1 - size of sprite (width or height)
; R6,7 - 64 bit determinant (16.48 format)
; Result in R4

produce_increment
        Push    "R0-R3,R5-R12,R14"
        Debug tr,"Inputs:",R0,R1,R6,R7

; First split R6/7 into R4-R7

        MOVS    R3, R7, ASR #32
        BEQ     %FT01
        RSBS    R6, R6, #0
        RSC     R7, R7, #0
01
        MOV     R4, R7, LSR #16
        BIC     R5, R7, R4, LSL #16
        MOV     R7, R6, LSR #16
        BIC     R6, R6, R7, LSL #16

; Now check sign of R0, R3 = sign of product

        EORS    R3, R3, R0, ASR #32

; If R3<0 (i.e. product<0) then R1=-R1

        RSBMI   R1, R1, #0

; If R0<0 then R0=-R0

        RSBCS   R0, R0, #0

; Split R0

        MOV     R2, R0, LSR #16
        BIC     R0, R0, R2, LSL #16
        Debug tr,"Premultiply values:R0,R2,R1,R3:",R0,R2,R1,R3
        Debug tr,"Premultiply values:R4,R5,R7,R6:",R4,R5,R7,R6

; Now produce R8 = U0.6 + L2.6 + L0.7, R6 = U2.6 + U0.7 (inc. carries)

        MUL     R8, R0, R6
        MUL     R6, R2, R6
        MUL     R3, R0, R7
        ADDS    R3, R3, R6
        MOV     R6, R3, LSR #16
        ADDCS   R6, R6, #&10000
        ADDS    R8, R8, R3, LSL #16
        MOV     R8, R8, LSR #16
        ADC     R6, R6, #0
        Debug tr,"Stage 1:R6,R8",R6,R8

; Now produce R9 = L6 + L2.7 + L0.5, R7 = U6 + U2.7 + U0.5 (inc carries)

        MUL     R9, R0, R5
        MUL     R7, R2, R7
        ADDS    R3, R7, R9
        MOV     R7, R3, LSR #16
        ADDCS   R7, R7, #&10000
        ADD     R7, R7, R6, LSR #16
        MOV     R9, R3, LSL #16
        ADDS    R9, R9, R6, LSL #16
        MOV     R9, R9, LSR #16
        ADC     R7, R7, #0
        Debug tr,"Stage 2:R7,R9",R7,R9

; Now produce R10 = L7 + L2.5 + L0.4, R5 = U7 + U2.5 + U0.4 (inc. carries)

        MUL     R10, R0, R4
        MUL     R5, R2, R5
        ADDS    R3, R5, R10
        MOV     R5, R3, LSR #16
        ADDCS   R5, R5, #&10000
        ADD     R5, R5, R7, LSR #16
        MOV     R10, R3, LSL #16
        ADDS    R10, R10, R7, LSL #16
        MOV     R10, R10, LSR #16
        ADC     R5, R5, #0
        Debug tr,"Stage 3:R10,R5",R10,R5

; Now produce R11 = L5 + L2.4

        MLA     R11, R2, R4, R5
        MOV     R3, R11, LSR #16
        BIC     R11, R11, R3, LSL #16

; Now R11.R10.R9.R8 (sixteen bits each) = 256/Det*Size in 32.32 form
; So get R1 * R11.R10.R9.R8 into R4

        MUL     R8, R1, R8
        MUL     R9, R1, R9
        MUL     R10, R1, R10
        MUL     R11, R1, R11
        MOV     R4, R8, ASR #24
        ADD     R4, R4, R9, ASR #8
        ADD     R4, R4, R10, ASL #8
        ADD     R4, R4, R11, ASL #24

        ;bug fix, round up if necessary
        TST     R9,#&80
        ADDNE   R4,R4,#1

        Debug tr,"Output:R4",R4

        Pull    "R0-R3,R5-R12,PC"



; -----------------------------------
; - DrQfill routines required above -
; -----------------------------------
; Fast Y clipping routine

out_qfill_fastclip
        Push    "R1,R2,R7,LR"
        MOV     R7,R6,ASR #31           ;Sign-extend Bresenham value
        SSmultD R8,R3,R1,R2             ;(no. Y steps) * deltaX into R1,R2
        ADDS    R6,R6,R1                ;Accumulate into Bresenham value
        ADCS    R7,R7,R2
        MOVMI   R8,#0                   ;Check for still being to the right
        BMI     out_qfill_fastclipdone  ;  of the edge
        BL      arith_DSdivS            ;Divide by deltaY
        DCB     R6,R4,R8,0
        SSmultD R8,R4,R1,R2             ;(no. X steps) * deltaY into R1,R2
        SUB     R6,R6,R1                ;Not interested in high word!

out_qfill_fastclipdone
        Pull    "R1,R2,R7,LR"
        TEQ     R0,#0                   ;Move X co-ord. in right direction
        ADDPL   R7,R7,R8
        SUBMI   R7,R7,R8
        MOV     PC,LR

; Subroutine to advance an edge horizontally fast (i.e. using long division
; rather than division by repeated subtraction!)
;   Updates R6 and R7, corrupts R2 and R3, preserves flags & other registers

out_qfill_fasthoriz
        DivRem  R2,R6,R4,R3
        TEQ     R0,#0
        ADDPL   R7,R7,R2
        SUBMI   R7,R7,R2
        MOV     PC,LR

 [ :LNOT:usemull
; Subroutine to multiply two single precision signed numbers together and
; get a double precision result. The word following the BL should contain
; the numbers of the two operand registers in its bottom two bytes and the
; number of the register to take the ls part of the result in the next byte.
; The ms part of the result will go into the next register.
;   This routine will only work on registers R0-R8.

arith_SSmultD
        Push    "R0-R8"                 ;REMEMBER: need to stack R0-R8 so they can hold results
        RSB     R8,PC,PC                ;get embedded PSR flags into R8 - 26/32-bit mode neutral
        LDRB    R0,[R14,-R8]!           ;Get first operand; R14 := (R14 - PSR)
        LDR     R0,[R13,R0,LSL #2]
        LDRB    R1,[R14,#1]             ;Get second operand
        LDR     R1,[R13,R1,LSL #2]
        MOV     R4,R0,LSR #16           ;Split first operand into halves
        BIC     R3,R0,R4,LSL #16
        MOVS    R6,R1,LSR #16           ;Split second operand into halves
        BIC     R5,R1,R6,LSL #16
        MUL     R2,R3,R5                ;Produce low partial product
        MUL     R3,R6,R3                ;And middle partial products
        MUL     R5,R4,R5
        MULNE   R6,R4,R6                ;And high partial product
        ADDS    R3,R3,R5                ;Add middle partial products, dealing
        ADDCS   R6,R6,#&10000           ;  with overflow
        ADDS    R2,R2,R3,LSL #16        ;Add middle partial product sum into
        ADC     R6,R6,R3,LSR #16        ;  result
        TEQ     R0,#0                   ;Add cross products of operands and
        SUBMI   R6,R6,R1                ;  operand sign extensions into
        TEQ     R1,#0                   ;  result
        SUBMI   R6,R6,R0
        LDRB    R0,[R14,#2]             ;Store the result on the stack, to be
        ADD     R0,R13,R0,LSL #2        ;  picked up by the correct registers
        STMIA   R0,{R2,R6}
        Pull    "R0-R8"
        ADD     PC,R14,#4               ;Skip the argument word on return (don't use ADDS!)
 ]

; Subroutine to divide a double precision unsigned number by a single
; precision unsigned number, yielding a single precision unsigned result.
; The word following the BL should contain the number of the register holding
; the ls part of the dividend in its bottom byte; the ms part of the dividend
; is in the next register. The next byte of the word contains the number of
; the divisor register, and the next byte the number of the register in which
; to deposit the quotient.
;   This routine will only work on registers R0-R8. It assumes that the
; divisor is not zero, and that the quotient will not overflow.

arith_DSdivS
        Push    "R0-R8"
        RSB     R8,PC,PC                ;get embedded PSR flags into R8 - 26/32-bit mode neutral
        LDRB    R0,[R14,-R8]!           ;Get first operand; R14 := (R14 - PSR)
        ADD     R0,R13,R0,LSL #2
        LDMIA   R0,{R0,R1}
        LDRB    R2,[R14,#1]             ;Get second operand
        LDR     R2,[R13,R2,LSL #2]
        MOV     R3,#1                   ;Init. quotient with a sentinel bit

arith_DSdivS_loop
        ADDS    R0,R0,R0                ;Shift a bit up into the ms half of
        ADC     R1,R1,R1                ;  the dividend
        CMP     R1,R2                   ;Do trial subtraction, producing
        SUBCS   R1,R1,R2                ;  result bit in C
        ADCS    R3,R3,R3                ;Result bit into result, then loop
        BCC     arith_DSdivS_loop       ;  unless sentinel bit shifted out
        LDRB    R0,[R14,#2]             ;Store the result on the stack, to be
        STR     R3,[R13,R0,LSL #2]      ;  picked up by the correct registers
        Pull    "R0-R8"
        ADD     PC,R14,#4               ;Skip the argument word on return (don't use ADDS!)


; ---------------------------------------------
; - Routine to compile the code specified by  -
; - the GCOL action, in_bpp, out_bpp          -
; - translation table, and plotmask/putsprite -
; - options                                   -
; ---------------------------------------------
        IMPORT  sprtrans_compiler
compile_transform_code
; R5 = GCOL value (including mask bit)
        MOV     R0,R12              ; assembler workspace pointer
        ADRL    R1,ccompiler_space  ; above R12, space for me.
        ADRL    R2,ccompiler_end    ; end of space for me.
        MOV     R3,R5               ; GCOL action and mask bit

        Debug   gs,"R1,R5,R12 = ",R1,R5,R12
        MOV     R4,#0
        STR     R4,ccompiler_errptr ; in case of error exit
        ADD     R4,SP,#trns_spr_vars_end
        STR     R4,ccompiler_sp     ; in case of unexpected exit

        Debug   cc,"entering c code"
        MOV     SL,R12              ; will be left alone by compiled C - for debug routines above.
        BL      sprtrans_compiler   ; dive into the C (returns r0=compiled code)
        MOV     R12,SL              ; R12 is ip to a C prog, will have been trampled on - restore it.
        B       return_from_sprtrans_compiler

calc_row_stacked        *       4*4    ;       Number of bytes stacked in plot_and_calculate_row
plot_and_calculate_row
        Push    "R14"
        CMP     trns_scr_lx, trns_scr_rx
        Swap    trns_scr_lx, trns_scr_rx, GT
        LDR     trns_dummy14, gwx0
        CMP     trns_scr_lx, trns_dummy14
        MOVLT   trns_scr_lx, trns_dummy14
        LDR     trns_dummy14, gwx1
        CMP     trns_scr_rx, trns_dummy14
        MOVGT   trns_scr_rx, trns_dummy14
        CMP     trns_scr_lx, trns_scr_rx
        Pull    "PC",GE
;                                       Get sprite offsets for left of current y line
;                                       First get dummy11 = scr_lx - x(0)
        LDR     trns_dummy11, trns_spr_xcoords + calc_row_stacked
;        Debug tr,"X,Y(x0,y0), incXx, incYy",trns_X_x0_y,trns_Y_x0_y,trns_inc_X_x,trns_inc_Y_x
;        Debug tr,"coords:",trns_scr_lx, trns_scr_rx,trns_scr_y,trns_dummy11
        MOV     trns_dummy11, trns_dummy11, ASR#8
        SUB     trns_dummy11, trns_scr_lx, trns_dummy11
; X = ((screen_lx%-x(0)) * (inc_X_x)) + X_x0_y
        MLA     trns_X, trns_dummy11, trns_inc_X_x, trns_X_x0_y
; Y = ((screen_lx%-x(0)) * (spr_inc_Y_x)) + Y_x0_y
        MLA     trns_Y, trns_inc_Y_x, trns_dummy11, trns_Y_x0_y
;                                       Get the x posn and x size for the plot
        SUB     trns_dummy14, trns_scr_rx, trns_scr_lx
        MOV     trns_out_x, trns_scr_lx
;                                       Load the compile routine registers - HERE
        ADR     trns_spr_start, trns_comp_spr_left + calc_row_stacked
        LDMIA   trns_spr_start, {trns_xsize, trns_spr_start, trns_byte_width, trns_spr_height}
        ORR     trns_xsize, trns_xsize, trns_dummy14,LSL#16
;                               Plot the row (call compiled code)
        Pull    "R14"
        LDR     PC, trns_codebuffer + calc_row_stacked -4

        END
@


4.18
log
@Add support for blended sprite & JPEG rendering - alpha masks, alpha channels, and translucency
Detail:
  This big set of changes adds support for the following user-facing APIs, as per ROL's specs:
  - OS_SpriteOp 52 (PutSpriteScaled) colour mapping, translucency blending, and alpha mask/alpha channel blending
  - OS_SpriteOp 56 (PutSpriteTransformed) colour mapping, translucency blending, and alpha mask/alpha channel blending
  - JPEG_Plot[File]Scaled colourmapping & translucency blending
  - JPEG_Plot[File]Transformed colourmapping & translucency blending
  Sources/CFSI-JPEG, Sources/PutScaled:
  - Added exit_oserror exit routine for use by C code.
  - For SpriteExtend this allows the C code to cause OS_SpriteOp to exit with a given OS error block.
  - For CFSI-JPEG the error block is returned and ERROR_FATAL is returned to ChangeFSI.
  Sources/CSupport:
  - Add definitions for some error codes (matches existing definitions from h/commondefs)
  Sources/PutScaled:
  - Stripped out code to look for identity translation tables; now handled by preparettr routine in Sources/SprOp
  Sources/SWIs, Hdr/SprExtend:
  - JPEG SWIs updated to add support for alpha-blended and colour mapped JPEG rendering, following ROL's APIs
  Sources/SprExtend:
  - Stripped out lots of old build flags which haven't been touched in years.
  - Strip out assembler SprTrans code generator.
  - Add new definitions needed for blending & colour mapping.
  Sources/SprOp:
  - Updated PutScaled frontend to deal with blending and colour mapping.
  - Disabled code which was bodging coordinates when dealing with double-pixel modes - it seems to cause a few issues, and the code generator mostly had proper double-pixel support anyway.
  - Translation table verification and fiddling code rewritten and consolidated into the preparettr routine. C code is now explicitly told what table type is in use and whether it can safely be ignored in favour of using the sprite palette.
  - Removed code from CheckSpriteArea which was deliberately throwing an error upon seeing alpha-masked sprites; I think the bug that was hiding has been fixed now
  Sources/SprTrans
  - Removed the assembler version of the code generator.
  - Updated to add support for blending and colour mapping
  c/PutScaled:
  - Old test code removed.
  - Updated to add support for blending & colour mapping
  - Assorted bugs fixed.
  - A few extra architecture-specific optimisations added.
  - Some workspace setup code moved to c/asmcore to allow sharing with SprTrans.
  c/asmcore:
  - Register allocation code rewritten. Instead of allocating on a first-come, first-served basis, the code now builds a list of which logical registers are needed (and which 'banks' they fall into) and then attempts to allocate them in a more intelligent manner. It still has some failings (e.g. reusing R12 as a general purpose register is currently impossible) but it's a lot more flexible and reliable than the old code.
  - Core pixel transformation code updated to add support for blending & colour mapping
  - Added some extra architecture-specific optimisations
  c/rojpeg:
  - JPEG option handling updated to avoid trashing any colour mapping descriptor that may have been passed in
  c/sprtrans:
  - Updated to add support for blending & colour mapping
  c/tracing:
  - Debug assert messages now show filename as well as line number
  h/commondefs:
  - Removed old #define's that related to old assembler switches.
  h/putscaled:
  - Workspace definition updated to match assembler version.
  - SprTrans stack workspace structure moved here from c/sprtrans
Admin:
  Tested on BB-xM plotting all major sprite & JPEG types into all modes with all major options


Version 1.55. Tagged as 'SprExtend-1_55'
@
text
@d365 11
@


4.17
log
@Add support for new sprite types & screen modes
Detail:
  Makefile - Updated to fix a couple of dependency issues and to make c/asmcore the main C file, not c/putscaled
  Sources/PutScaled - Add a utility routine that's used by the C code to get information about pixel formats
  Sources/SprAdjSize - Add support for wide masks & RISC OS 5 style sprite mode words
  Sources/SprExtend - Tidy up workspace by removing lots of unused bits and moving other bits within sight of the C code. Add flag to control whether C or assembler version of SprTrans is used. Query kernel for ECFYOffset/ECHShift locations instead of using hardcoded values in putscaled code. Add fix for garbage debug strings in softloaded debug versions of the module.
  Sources/SprOp - Add support for wide masks & RISC OS 5 style sprite mode words. Update makepalette16bpp to cope with all the new 16bpp modes. Flag_* -> ModeFlag_* renaming. Move some translation table handling code into a new routine, 'preparettr'. Update checktrans/converttrans to deal with new pixel formats.
  Sources/SprTrans - If the C version of SprTrans is enabled, disable all of these assembler bits except for the outer loop which steps over each row of the screen
  Sources/jdcolor - Updated to deal with new pixel formats. 16bpp conversion code split off into new file, Sources/jdcolor16.
  Sources/jdcolor16 - New file containing the guts of the YUV -> 16bpp conversion code. Gets included multiple times with different options to generate the different conversion routines (code is too big for a macro).
  c/asmcore - New file containing lots of common code ripped out of c/PutScaled - e.g. workspace definition, main functions for register assignment & instruction generation, and code for pixel format conversion. Pixel format conversion code rewritten to cope with new pixel formats, and code buffer key word generation rewritten to fix a couple of bugs (e.g. some issues with dithering options were observed)
  c/PutScaled - Ripped out lots of code that's now in c/asmcore. Now just deals with things that are PutScaled-specific, e.g. main plotter loop containing pixel read/write code. Code extended to cope with new pixel formats
  c/rojpeg, h/jinclude, h/jpegdata - Code extended to cope with new 16bpp conversion routines
  c/sprtrans - New C implementation of the core per-row transformed sprite plotting code generator. Allows reuse of the extensive pixel conversion code in c/asmcore, and allows for better code generation than the assembler original.
  h/putscaled - Worksapce definition updated to match assembler version
Admin:
  Tested on BB-xM, plotting lots of different sprites in lots of different modes
  Plotting of wide mask sprites not supported yet
  C version of YUV -> 16bpp code currently only deals with traditional &BGR 555 pixel format - code is aware of this and will do conversion to desired format if applicable (although quality may be reduced)
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 1.52. Tagged as 'SprExtend-1_52'
@
text
@d22 1
a22 1
trns_comp_spr_byte_width        #       4       ;       Sprite byte width << (3-sprite bpp)
d43 1
a95 57
 [ :LNOT: SprTransC
 
        GBLA    ldmreg
        GBLA    ldmreg3
        GBLS    ldmreg2

        MACRO
$l      TrnsAsm         $label,$size,$cc
ldmreg  SETA    $size:SHR:2
ldmreg3 SETA    ldmreg+3
ldmreg2 SETS    "$ldmreg3":RIGHT:1
$l
    [ ldmreg>6
        ADR$cc  R4,$label
        LDM$cc.IA R4!,{R4-R9}
        STM$cc.IA R10!,{R4-R9}
        TrnsAsm ($label+6*4),($size-6*4),$cc
    |
      [ ldmreg>1
        ADR$cc.L  R4,$label
        LDM$cc.IA R4,{R4-R$ldmreg2}
        STM$cc.IA R10!,{R4-R$ldmreg2}
      |
        LDR$cc  R4,$label
        STR$cc  R4, [R10], #4
      ]
    ]
        MEND


        MACRO
$l      TrnsAsmReg      $reg,$size,$cc
ldmreg  SETA    $size:SHR:2
ldmreg3 SETA    ldmreg+3
ldmreg2 SETS    "$ldmreg3":RIGHT:1
      [ ldmreg>1
$l      LDM$cc.IA $reg,{R4-R$ldmreg2}
        STM$cc.IA R10!,{R4-R$ldmreg2}
      |
$l      LDR$cc  R4,[$reg]
        STR$cc  R4, [R10], #4
      ]
        MEND


        MACRO
$l      TrnsBranch      $reg,$op
        SUB     $reg,$reg,R10
        SUB     $reg,$reg,#8
        MOV     $reg,$reg,LSL#6
        MOV     $reg,$reg,LSR#8
        ORR     $reg,$reg,#$op
        STR     $reg,[R10],#4
        MEND

 ]

a188 1
        [       flagbit
d191 2
a192 5
        [ widetrans
        BICS    R14, R14, #flg2_ignorettr+flg2_widetrans + flg2_ditheron
        |
        BICS    R14, R14, #flg2_ignorettr + flg2_ditheron
        ]
a196 1
        ]
a215 1
      [ SprTransC
d217 1
a217 1
      ]
d224 16
a239 1
    [ SprTransC
a242 55
    |
        [ ignore_ttr
; check whether it has a palette - if doing <16 to >8 we may use it in preference
; to the translation table

        MOV     R0, #0
        STR     R0, trns_palette

        LDR     R0,[R1,#spImage]
        CMP     R0,#SpriteCBsize
        BEQ     trns_has_no_palette

        LDR     R14,[R1,#spTrans]
        CMP     R14,#SpriteCBsize
        BEQ     trns_has_no_palette

        ;validate it (to exclude 8bpp without full palettes)
        ;test is that palette size should be 8*ncolours

        ;find the lower of the sprite start and mask start
        CMP     R0,R14
        MOVCS   R0,R14
        SUB     R0,R0,#SpriteCBsize

        MOV     R0,R0,LSR #3 ;divide by 8 for number of palette entries
        MOV     R14,#1
        LDR     R9,save_inbpp
        MOV     R14,R14,ASL R9

        CMP     R14,R0
        BNE     trns_has_no_palette

        [       flagbit
        LDR     R14, trns_flags2
        TST     R14, #flg2_ignorettr
;        BNE     %FT01
;        [       med01867
;        CMP     R9, #8
;        BNE     trns_has_no_palette ;restrict it to 8bpp full palette only
;        ]
        BEQ     trns_has_no_palette
01
        |
;        [       med01867
;        CMP     R9, #8
;        BNE     trns_has_no_palette ;restrict it to 8bpp full palette only
;        ]
        B       trns_has_no_palette
        ]

        LDR     R14,[R1,#spTrans]
        ADD     R14,R1,#SpriteCBsize
        STR     R14, trns_palette
trns_has_no_palette
       ]
a243 59
; validate supplied translation table (if any)

        CMP     R7,R7,ASR #31           ; documented as <=0 being none - now accept 0 or -1
        MOVEQS  R7,#0                   ; 0 ==> no translation
        BLNE    checktrans
        BVS     exitbiggie              ; fault it because it failed
;
        [ ignore_ttr
; if doing a sprite of <16bpp to >8bpp, and it has a palette, change the ttr pointer
; to point at the palette data instead of the ttr data. Note that the two are different
; formats, so there is also a different plotting routine to include too...

        LDR     R14, BPP                               ; output bpp
        CMP     R14, #16
        MOVCC   R14, #0
        STRCC   R14, trns_palette
        BCC     %FT45
        LDR     R14, save_inbpp
        CMP     R14, #16
        MOVCS   R14, #0
        STRCS   R14, trns_palette
        BCS     %FT45
        LDR     R14, trns_palette
        TEQ     R14, #0
        MOVNE   R7,R14
        MOVEQ   R14,#0
        STREQ   R14, trns_palette ;only non-zero if going to use this

; trns_palette doubles as a pointer to the palette up this far, and then becomes a
; compilation flag for the macro generation (with the value being passed in as the
; ttr address)

45
        ]
        STR     R7,ColourTTR
        CMP     R7,#0
        BNE     trns_notrans
;
        LDRB    R14,spritecode          ; R14 = bottom 8 bits of reason code
        TEQ     R14,#SpriteReason_PlotMaskTransformed
        LDRNE   R14,save_inbpp
        LDRNE   R0,BPP
        TEQNE   R14,R0                  ; OK if same bpp or mask plotting

        ;however, don't error if going 16>32 or 32>16
        BEQ     trns_notrans ;dispose of the equal case

        CMP     R0,#16
        CMPEQ   R14,#32
        BEQ     trns_notrans

        CMP     R0,#32
        CMPEQ   R14,#16
        BEQ     trns_notrans

        B       errtrans

trns_notrans
    ] ; SprTransC
d257 1
a257 1
; Valid registers: R1 - ptr to sprite?, R3 - flags, R4 -> coordinate block, R5 GCOL, R6->matrix/coords, R7->ttr
d360 1
a360 1
; Valid registers: R0,R8,R9,R14 - source rect, R1 - ptr to sprite, R5 GCOL, R6->matrix/coords, R7->ttr
d392 1
a392 1
        SWI     Draw_TransformPath
d432 1
a441 2
        LDR     R2,[r1,#spMode]
        Debug   ag,"spMode is",R2
d453 3
d480 3
d488 5
a492 1
        STR     R11, trns_comp_spr_mask_width   ; used only for 1bpp masks
d498 2
a499 2
        MUL     R10, R11, R10                   ; convert to offset (bits)
        MOV     R10, R10, LSR #3                ; convert to bytes
a504 4
      [ SprTransC
        LDR     R7, trns_palette
        TEQ     R7, #0
        BNE     %FT90
a505 10
        ; If output is <=8bpp, and source is >=16bpp, this should be a 32K table
        ; In which case, the plotter would like a pointer straight to the data,
        ; not the table header
        CMP     R10, #8
        BGT     %FT90
        LDR     R11, save_inlog2bpp
        CMP     R11, #4
        LDRGE   R7, [R7, #4]
90
      ]
a801 3
      [ :LNOT: SprTransC
        ADR     R10, codebuffer
      |
a803 1
      ]
d1202 1
a1202 1
        Pull    "R1-R9,PC"
a1423 760
 [ :LNOT: SprTransC
;       ---------------------------------
;       - The code which is compiled in -
;       ---------------------------------
compiled_routine_stacked        *       calc_row_stacked + 1*4 - 4; Number of bytes stacked since main loop

;                       Start of routine
trnslp_strt
        Push    "R14"
        MOV     trns_out_word, #&80000000
        MOV     trns_out_mask, #0
        CMP     trns_xsize, #0
        Pull    "PC",LE
trnslp_strt_size        *       .-trnslp_strt
        ASSERT (trnslp_strt_size) = 5*4

;                       Get address of lefthand x on screen (dependent on out_bpp)
trnslp_getaddr_o1
        ADD     trns_out_ptr, trns_out_ptr, trns_out_x, LSR# 3 ;(0.1.2.3 - 8.4.2.1 out_bpp)
        BIC     trns_out_ptr, trns_out_ptr, #3
        AND     trns_out_x, trns_out_x, #31                     ;(3.7.15.31 - 8.4.2.1 out_bpp)
        ANDEQ   R0,R0,R0
trnslp_getaddr_o2
        ADD     trns_out_ptr, trns_out_ptr, trns_out_x, LSR# 2 ;(0.1.2.3 - 8.4.2.1 out_bpp)
        BIC     trns_out_ptr, trns_out_ptr, #3
        MOV     trns_out_x, trns_out_x, LSL#1
        AND     trns_out_x, trns_out_x, #30                     ;(3.7.15.31 - 8.4.2.1 out_bpp)
trnslp_getaddr_o4
        ADD     trns_out_ptr, trns_out_ptr, trns_out_x, LSR# 1  ;(0.1.2.3 - 8.4.2.1 out_bpp)
        BIC     trns_out_ptr, trns_out_ptr, #3
        MOV     trns_out_x, trns_out_x, LSL#2
        AND     trns_out_x, trns_out_x, #28                     ;(3<<3.7<<2.15<<1.31<<0 - 8.4.2.1 out_bpp)
trnslp_getaddr_o8
        ADD     trns_out_ptr, trns_out_ptr, trns_out_x          ;(0.1.2.3 - 8.4.2.1 out_bpp)
        BIC     trns_out_ptr, trns_out_ptr, #3
        MOV     trns_out_x, trns_out_x, LSL#3
        AND     trns_out_x, trns_out_x, #24                     ;(3.7.15.31 - 8.4.2.1 out_bpp)
trnslp_getaddr_o16
        ADD     trns_out_ptr, trns_out_ptr, trns_out_x, LSL #1
        BIC     trns_out_ptr, trns_out_ptr, #3
        MOV     trns_out_x, trns_out_x, LSL #4
        AND     trns_out_x, trns_out_x, #16
trnslp_getaddr_o24
        ADD     trns_out_ptr, trns_out_ptr, trns_out_x, LSL #2
        BIC     trns_out_ptr, trns_out_ptr, #3
        MOV     trns_out_x, trns_out_x, LSL#5
        AND     trns_out_x, trns_out_x, #0
trnslp_getaddr_size     *       .-trnslp_getaddr_o24
        ASSERT (.-trnslp_getaddr_o1) = 6*trnslp_getaddr_size

;                       Get pixel and macro word shifted to align with lefthand pixel inside screen word
trnslp_getwam
        MOV     trns_out_word, trns_out_word, LSR trns_out_x
trnslp_getwam_size      *       .-trnslp_getwam
        ASSERT (trnslp_getwam_size) = 1*4

;                       Start of loop
trnslp_stloop1
        MOVS    trns_offset, trns_Y, ASR#16
        MOVMI   trns_offset, #0
        MOV     trns_dummy14, trns_spr_height, LSR#16
        CMP     trns_dummy14, trns_Y, ASR#16
trnslp_stloop1_size      *       .-trnslp_stloop1
trnslp_stloop2
        SUBLE   trns_offset, trns_dummy14, #1
        MUL     trns_offset, trns_byte_width, trns_offset
        MOV     trns_dummy14, trns_X
        CMP     trns_X, trns_spr_left, LSL #16
trnslp_stloop2_size      *       .-trnslp_stloop2
trnslp_stloop3
        MOVLT   trns_dummy14, trns_spr_left, LSL #16
        CMP     trns_X, trns_spr_right, LSL #16
        MOVGE   trns_dummy14, trns_spr_right, LSL #16
        SUBGE   trns_dummy14, trns_dummy14, #1
        ADD     trns_offset, trns_offset, trns_dummy14, LSR #16
trnslp_stloop3_size      *       .-trnslp_stloop3

;                       Start of loop (1bpp mask)
trnslp_nmstloop1
        MOVS    trns_offset, trns_Y, ASR#16
        MOVMI   trns_offset, #0
        MOV     trns_dummy14, trns_spr_height, LSR#16
        CMP     trns_dummy14, trns_Y, ASR#16
trnslp_nmstloop1_size      *       .-trnslp_nmstloop1
trnslp_nmstloop2
        SUBLE   trns_offset, trns_dummy14, #1
        LDR     trns_dummy12, trns_comp_spr_mask_width + compiled_routine_stacked
        MUL     trns_dummy12, trns_offset, trns_dummy12
        MUL     trns_offset, trns_byte_width, trns_offset
        MOV     trns_dummy14, trns_X
trnslp_nmstloop2_size      *       .-trnslp_nmstloop2
trnslp_nmstloop3
        CMP     trns_X, trns_spr_left, LSL #16
        MOVLT   trns_dummy14, trns_spr_left, LSL #16
        CMP     trns_X, trns_spr_right, LSL #16
        MOVGE   trns_dummy14, trns_spr_right, LSL #16
        SUBGE   trns_dummy14, trns_dummy14, #1
trnslp_nmstloop3_size      *       .-trnslp_nmstloop3
trnslp_nmstloop4
        ADD     trns_offset, trns_offset, trns_dummy14, LSR #16
        ADD     trns_dummy12, trns_dummy12, trns_dummy14, LSR #16
        STR     trns_dummy12, trns_comp_mask_offset + compiled_routine_stacked
trnslp_nmstloop4_size      *       .-trnslp_nmstloop4


;                       Shift pixel and mask words by out_bpp
trnslp_shfwam_o1
        MOVS    trns_out_word, trns_out_word, LSR#1
        MOV     trns_out_mask, trns_out_mask, LSR#1
trnslp_shfwam_o2
        MOVS    trns_out_word, trns_out_word, LSR#2
        MOV     trns_out_mask, trns_out_mask, LSR#2
trnslp_shfwam_o4
        MOVS    trns_out_word, trns_out_word, LSR#4
        MOV     trns_out_mask, trns_out_mask, LSR#4
trnslp_shfwam_o8
        MOVS    trns_out_word, trns_out_word, LSR#8
        MOV     trns_out_mask, trns_out_mask, LSR#8
trnslp_shfwam_o16
        MOVS    trns_out_word, trns_out_word, LSR#16
        MOV     trns_out_mask, trns_out_mask, LSR#16
trnslp_shfwam_o24
        MOVS    trns_out_word, trns_out_word, LSR#32
        MOV     trns_out_mask, #0
trnslp_shfwam_size      *       .-trnslp_shfwam_o24
        ASSERT (.-trnslp_shfwam_o1) = trnslp_shfwam_size*6

;                       Read pixel from sprite (dependent on in_bpp)
trnslp_readpx_i1
        LDRB    trns_dummy14, [trns_spr_start, trns_offset, LSR #3]     ;(0.1.2.3 - 8.4.2.1 in_bpp)
        AND     trns_dummy12, trns_offset, #7                           ;(0.1.3.7 - 8.4.2.1 in_bpp)
        MOV     trns_dummy14, trns_dummy14, LSR trns_dummy12
        AND     trns_dummy14, trns_dummy14, #&1                         ;(&FF.&F.&3.&1 - 8.4.2.1 in_bpp)
trnslp_readpx_i1_size * .-trnslp_readpx_i1
        ANDEQ   R0,R0,R0
trnslp_readpx_i2
        LDRB    trns_dummy14, [trns_spr_start, trns_offset, LSR #2]     ;(0.1.2.3 - 8.4.2.1 in_bpp)
        AND     trns_dummy12, trns_offset, #3                           ;(0.1.3.7 - 8.4.2.1 in_bpp)
        MOV     trns_dummy12, trns_dummy12, LSL#1                       ;(3.2.1.0 - 8.4.2.1 in_bpp)
        MOV     trns_dummy14, trns_dummy14, LSR trns_dummy12
        AND     trns_dummy14, trns_dummy14, #&3                         ;(&FF.&F.&3.&1 - 8.4.2.1 in_bpp)
trnslp_readpx_i4
        LDRB    trns_dummy14, [trns_spr_start, trns_offset, LSR #1]     ;(0.1.2.3 - 8.4.2.1 in_bpp)
        AND     trns_dummy12, trns_offset, #1                           ;(0.1.3.7 - 8.4.2.1 in_bpp)
        MOV     trns_dummy12, trns_dummy12, LSL#2                       ;(3.2.1.0 - 8.4.2.1 in_bpp)
        MOV     trns_dummy14, trns_dummy14, LSR trns_dummy12
        AND     trns_dummy14, trns_dummy14, #&F                         ;(&FF.&F.&3.&1 - 8.4.2.1 in_bpp)
trnslp_readpx_i8
        LDRB    trns_dummy14, [trns_spr_start, trns_offset]
        ANDEQ   R0,R0,R0
        ANDEQ   R0,R0,R0
        ANDEQ   R0,R0,R0
        ANDEQ   R0,R0,R0
trnslp_readpx_i16
      [ NoARMv4
        LDR     trns_dummy14, [trns_spr_start, trns_offset, LSL #1]     ;note - this will be word or half word aligned
        MOV     trns_dummy14, trns_dummy14, LSL #16
        MOV     trns_dummy14, trns_dummy14, LSR #16
      |
        MOV     trns_dummy14, trns_offset, LSL #1
        LDRH    trns_dummy14, [trns_spr_start, trns_dummy14]
        ANDEQ   R0,R0,R0
      ]
        ANDEQ   R0,R0,R0
        ANDEQ   R0,R0,R0
trnslp_readpx_i32
        LDR     trns_dummy14, [trns_spr_start, trns_offset, LSL #2]
        ANDEQ   R0,R0,R0
        ANDEQ   R0,R0,R0
        ANDEQ   R0,R0,R0
        ANDEQ   R0,R0,R0
trnslp_readpx_size      *       trnslp_readpx_i8-trnslp_readpx_i4
        ASSERT (.-trnslp_readpx_i1) = trnslp_readpx_size*6

;                       Translate pixel through ttr
trnslp_transpx
        LDR     trns_dummy12, trns_comp_spr_ttr + compiled_routine_stacked
        LDRB    trns_dummy14, [trns_dummy12, trns_dummy14]
trnslp_transpx_size      *      .-trnslp_transpx
        ASSERT (trnslp_transpx_size) = 2*4

trnslp_transpx1
        LDR     trns_dummy12, trns_comp_spr_ttr + compiled_routine_stacked
        LDR     trns_dummy14, [trns_dummy12, trns_dummy14, LSL #2]
trnslp_transpx1_size    *       .-trnslp_transpx1

        [ ignore_ttr
trnslp_transpx2
        LDR     trns_dummy12, trns_comp_spr_ttr + compiled_routine_stacked
        LDR     trns_dummy14, [trns_dummy12, trns_dummy14, LSL #3]
        MOV     trns_dummy14, trns_dummy14, LSR #8 ;now in correct form for 32bpp
trnslp_transpx2_size    *       .-trnslp_transpx2
        ;use trnslp_munge_32to16 if doing 16bpp
        ]

trnslp_use32K
       MOV      trns_dummy14,trns_dummy14,LSL #17
       MOV      trns_dummy14,trns_dummy14,LSR #17

       LDR      trns_dummy12,trns_comp_spr_ttr + compiled_routine_stacked ;fetch the table address
       LDR      trns_dummy12,[trns_dummy12,#4]
       ; trns_dummy12 is correct at this point....
       LDRB     trns_dummy14,[trns_dummy12,trns_dummy14]
trnslp_use32K_size      *      .-trnslp_use32K

;                       Copy pixel into output word (dependent on out_bpp)
trnslp_setpx
        ORR     trns_out_word, trns_out_word, trns_dummy14, LSL #xxx
trnslp_setpx_size       *       .-trnslp_setpx
        ASSERT (trnslp_setpx_size) = 1*4

;                       If sprite has no mask, then ORR set bits into the output mask word
trnslp_sprnomask_o1
        ORR     trns_out_mask, trns_out_mask, #&80000000
trnslp_sprnomask_o2
        ORR     trns_out_mask, trns_out_mask, #&C0000000
trnslp_sprnomask_o4
        ORR     trns_out_mask, trns_out_mask, #&F0000000
trnslp_sprnomask_o8
        ORR     trns_out_mask, trns_out_mask, #&FF000000
trnslp_sprnomask_size   *       .-trnslp_sprnomask_o8
        ASSERT (.-trnslp_sprnomask_o1) = trnslp_sprnomask_size*4

trnslp_sprnomask16or24
        LDR     trns_dummy14, trns_masking_word +compiled_routine_stacked
        ORR     trns_out_mask, trns_out_mask, trns_dummy14
trnslp_sprnomask16or24_size * .-trnslp_sprnomask16or24
        ASSERT  trnslp_sprnomask16or24_size = 4*2
;                       If sprite has a mask then read it in (also uses trnslp_readpx_i, above)
trnslp_sprmask
        LDR     trns_dummy14, trns_comp_spr_masko + compiled_routine_stacked
        ADD     trns_offset, trns_offset, trns_dummy14
trnslp_sprmask_size     *       .-trnslp_sprmask
        ASSERT (trnslp_sprmask_size) = 2*4

;                       If sprite has a 1BPP mask then read it in
; (note: no longer uses trnslp_readpx_i1 - it needs a different base address and must
; preserve the original one by avoiding trns_spr_start (R1) )

trnslp_new_sprmask
        ;
        LDR     trns_dummy12, trns_comp_mask_base + compiled_routine_stacked
        LDR     trns_offset, trns_comp_mask_offset + compiled_routine_stacked
        LDRB    trns_dummy14,[trns_dummy12, trns_offset, LSR #3]
trnslp_new_sprmask_size     *       .-trnslp_new_sprmask
trnslp_new_sprmask2
        AND     trns_dummy12, trns_offset, #7
        MOV     trns_dummy14, trns_dummy14, LSR trns_dummy12
        AND     trns_dummy14, trns_dummy14, #1
trnslp_new_sprmask2_size     *       .-trnslp_new_sprmask2

;                       Setup valid mask pixel into mask word
trnslp_setmask_o1
        TEQ     trns_dummy14, #0                ;Is the mask pixel set?
        ORRNE   trns_out_mask, trns_out_mask, #&80000000
trnslp_setmask_o2
        TEQ     trns_dummy14, #0                ;Is the mask pixel set?
        ORRNE   trns_out_mask, trns_out_mask, #&C0000000
trnslp_setmask_o4
        TEQ     trns_dummy14, #0                ;Is the mask pixel set?
        ORRNE   trns_out_mask, trns_out_mask, #&F0000000
trnslp_setmask_o8
        TEQ     trns_dummy14, #0                ;Is the mask pixel set?
        ORRNE   trns_out_mask, trns_out_mask, #&FF000000
trnslp_setmask_size * .-trnslp_setmask_o8
        ASSERT  (.-trnslp_setmask_o1) = trnslp_setmask_size*4

trnslp_setmask16or24
        TEQ     trns_dummy14, #0                ;Is the mask pixel set?
        LDRNE   trns_dummy14, trns_masking_word +compiled_routine_stacked
        ORRNE   trns_out_mask, trns_out_mask, trns_dummy14
trnslp_setmask16or24_size * .-trnslp_setmask16or24
        ASSERT  (.-trnslp_setmask16or24) = 3*4

;                       Cope with 1:1 mapping in the mask and screen mode
trnslp_setmask2
        ORR     trns_out_mask, trns_out_mask, trns_dummy14, LSL #xxx
trnslp_setmask2_size    *       .-trnslp_setmask2
        ASSERT (trnslp_setmask2_size) = 1*4

;                       Read the screen word
trnslp_readscrn
        LDRCS   trns_offset, [trns_out_ptr]
        ANDCS   trns_out_word, trns_out_word, trns_out_mask
trnslp_readscrn_size    *       .-trnslp_readscrn
        ASSERT (trnslp_readscrn_size) = 2*4

 [ AvoidScreenReads
trnslp_readscrn0
        MVNS    trns_offset, trns_out_mask      ; Z set iff out_mask is all 1s
        LDRHI   trns_offset, [trns_out_ptr]     ; load if C set & Z clear
        ANDCS   trns_out_word, trns_out_word, trns_out_mask
trnslp_readscrn0_size   *       .-trnslp_readscrn0
 ]

;                       Effect the screen word depending on the GCOL action
trnslp_gcol
;      GCOL 0 - plot direct
                BICCS   trns_offset, trns_offset, trns_out_mask
                EORCS   trns_offset, trns_offset, trns_out_word
;      GCOL 1 - OR with screen
                ORRCS   trns_offset, trns_offset, trns_out_word
        ANDEQ   R0,R0,R0
;      GCOL 2 - AND with screen
                EORCS   trns_out_word, trns_out_word, trns_out_mask
                BICCS   trns_offset, trns_offset, trns_out_word
;      GCOL 3 - EOR with screen
                EORCS   trns_offset, trns_offset, trns_out_word
        ANDEQ   R0,R0,R0
;      GCOL 4 - Invert screen
                EORCS   trns_offset, trns_offset, trns_out_mask
        ANDEQ   R0, R0, R0
;      GCOL 5 - Do nothing
        ANDEQ   R0,R0,R0
        ANDEQ   R0,R0,R0
;      GCOL 6 - AND with NOT colour
                BICCS   trns_offset, trns_offset, trns_out_word
        ANDEQ   R0,R0,R0
;      GCOL 7 - ORR with NOT colour
                EORCS   trns_out_word, trns_out_word, trns_out_mask
                ORRCS   trns_offset, trns_offset, trns_out_word
trnslp_gcol_size        *       2*4
        ASSERT (.-trnslp_gcol) = trnslp_gcol_size * 8

;                       Effect the screen word according to the mask and ECF
trnslp_plotmask
                LDRCS   trns_dummy12, trns_comp_ecf_ora + compiled_routine_stacked
                LDRCS   trns_out_word, trns_comp_ecf_eor + compiled_routine_stacked
                ANDCS   trns_dummy12, trns_dummy12, trns_out_mask
                ANDCS   trns_out_word, trns_out_word, trns_out_mask
                ORRCS   trns_offset, trns_offset, trns_dummy12
                EORCS   trns_offset, trns_offset, trns_out_word
trnslp_plotmask_size    *       .-trnslp_plotmask
        ASSERT (trnslp_plotmask_size) = 6*4

;                       End of the loop - store the screen word and move on a screen pixel
trnslp_eoloop
                STRCS   trns_offset, [trns_out_ptr], #4
                MOVCS   trns_out_word, #&80000000
                ADD     trns_X, trns_X, trns_inc_X_x
                ADD     trns_Y, trns_Y, trns_inc_Y_x
                SUB     trns_xsize, trns_xsize, #&10000
                CMP     trns_xsize, #&10000
trnslp_eoloop_size      *       .-trnslp_eoloop
        ASSERT (trnslp_eoloop_size) = 6*4

;                       Finished row so store last compiled output word and mask, if necessary
trnslp_lastword
        CMP     trns_out_word, #&80000000
        Pull    "PC",EQ
trnslp_lastword_size        *       .-trnslp_lastword
        ASSERT (trnslp_lastword_size) = 2*4

;                       Stored last output word and mask on screen, so exit
trnslp_lastword2
        STR     trns_offset, [trns_out_ptr]
        Pull    "PC"
trnslp_lastword2_size        *       .-trnslp_lastword2
        ASSERT (trnslp_lastword2_size) = 2*4

trnslp_munge_16to321
        Push    "R0,R2"
                                          ;      fedcba9876543210 fedcba9876543210
                                          ; LR =                  0bbbbbgggggrrrrr
        MOV     R0,trns_dummy14,LSR #10   ; R0 =                            0bbbbb
        MOV     R2,R0,LSL #19             ; R2 =        0bbbbb000 0000000000000000
        AND     R0,trns_dummy14,#&3E0     ; R0 =                  000000ggggg00000
        ORR     R2,R2,R0,LSL #6           ; R2 =        0bbbbb000 ggggg00000000000
trnslp_m1632_size1        *       .-trnslp_munge_16to321
trnslp_munge_16to322
        MOV     R0,trns_dummy14,LSL #27   ; R0 = rrrrr00000000000 0000000000000000
        ORR     R2,R2,R0,LSR #24          ; R2 =        0bbbbb000 ggggg000rrrrr000

        ;now copy the top three bits of each colour component into the bottom three

        MOV     R0,#&E0                   ;avoid an LDR for speed
        ORR     R0,R0,R0,LSL #8
trnslp_m1632_size2        *       .-trnslp_munge_16to322
trnslp_munge_16to323
        ORR     R0,R0,R0,LSL #8           ; R0 = 0000000011100000 1110000011100000
        AND     R0,R0,R2                  ; R0 = 00000000bbb00000 ggg00000rrr00000
        ORR     trns_dummy14,R2,R0,LSR #5 ; LR = 00000000bbbbbbbb ggggggggrrrrrrrr
        Pull    "R0,R2"
trnslp_m1632_size3        *       .-trnslp_munge_16to323

trnslp_munge_32to161
        Push    "R0,R2"
                                             ;      fedcba9876543210 fedcba9876543210
                                             ; LR = 00000000bbbbbbbb ggggggggrrrrrrrr
        AND     R0,trns_dummy14,#&F80000     ; R0 = 00000000bbbbb000 0000000000000000
        MOV     R2,R0,LSR #9                 ; R2 =                  0bbbbb0000000000
        AND     R0,trns_dummy14,#&F800       ; R0 = 0000000000000000 ggggg00000000000
trnslp_m3216_size1        *       .-trnslp_munge_32to161
trnslp_munge_32to162
        ORR     R2,R2,R0,LSR #6              ; R2 =                  0bbbbbggggg00000
        AND     R0,trns_dummy14,#&F8         ; R0 = 0000000000000000 00000000rrrrr000
        ORR     trns_dummy14,R2,R0,LSR #3    ; LR =                  0bbbbbgggggrrrrr

        Pull    "R0,R2"
trnslp_m3216_size2        *       .-trnslp_munge_32to162


; ---------------------------------------------
; - Routine to compile the code specified by  -
; - the GCOL action, in_bpp, out_bpp          -
; - translation table, and plotmask/putsprite -
; - options                                   -
; ---------------------------------------------
compile_transform_code
        Push    "LR"
; R11 = GCOL calue (including mask bit)
        AND     R11,R5,#mc_gcol:OR:mc_hasmask
; Set mc_ttr if colour translation table is to be used
        CMP     R7,#0
        ORRNE   R11,R11,#mc_ttr
; Set mc_plotmask if plotting the mask, clear if putting a sprite
        LDR     R14,spritecode
        AND     R14,R14,#&FF
        TEQ     R14,#SpriteReason_PlotMaskTransformed
        ORREQ   R11,R11,#mc_plotmask
; Store the sprite type, so that new masks make a difference
        LDR     R0, save_spr_type
        ORR     R11, R11, R0, LSL #mcb_sprtype

; Set in_bpp, out_bpp
        LDR     R0,save_inbpp
        ORR     R11,R11,R0,LSL #mcb_inbpp
        LDR     R1,BPP
        ORR     R11,R11,R1,LSL #mcb_outbpp

; Set bit denoting transformed sprite, rather than scaled sprite (uses same area as Sprite_PutSpriteScaled)
        ORR     R11, R11, #mc_transformed
; Test with old compiled routine
        LDR     R14,macroword
        TEQ     R11,R14
        BEQ     trns_compiling_complete
;
        STR     R11,macroword

; compile the code - R0=in_bpp, R1=out_bpp
        LDR     R0, save_inlog2bpp
        LDR     R1, Log2bpp
        ADR     R10, codebuffer
        Debug   mc,"Transformation code starts at",R10

;      Start of loop
                TrnsAsm         trnslp_strt, trnslp_strt_size
;      Get start pixel on the screen line of lefthand x coord (4 instr)
                ADRL            R2, trnslp_getaddr_o1
                ADD             R2, R2, R1, LSL#4
                TrnsAsmReg      R2, trnslp_getaddr_size
                ASSERT trnslp_getaddr_size = 4*4
;      Shift start words (pixel and mask) according to pixel offset
                TrnsAsm         trnslp_getwam, trnslp_getwam_size
; loop Store address on stack for the loop
                Push            "R10"

; If using a 1bpp mask we need to work out a different offset for the mask too
                MOVS            R2, R11, LSR #mcb_sprtype
                TSTNE           R11, #mc_hasmask

;      First 15 words of the loop (to find byte offset in sprite from sprite X,Y coords)
                TrnsAsm         trnslp_stloop1, trnslp_stloop1_size ,EQ
                TrnsAsm         trnslp_stloop2, trnslp_stloop2_size ,EQ
                TrnsAsm         trnslp_stloop3, trnslp_stloop3_size ,EQ

                TrnsAsm         trnslp_nmstloop1, trnslp_nmstloop1_size ,NE
                TrnsAsm         trnslp_nmstloop2, trnslp_nmstloop2_size ,NE
                TrnsAsm         trnslp_nmstloop3, trnslp_nmstloop3_size ,NE
                TrnsAsm         trnslp_nmstloop4, trnslp_nmstloop4_size ,NE

;      Shift pixel and mask words by output bpp (2 instructions)
                ADRL            R2, trnslp_shfwam_o1
                ADD             R2, R2, R1, LSL#3
                TrnsAsmReg      R2, trnslp_shfwam_size
                ASSERT trnslp_shfwam_size = 2*4

;      If putting the sprite (i.e. not plotting the mask)
                TST     R11, #mc_plotmask
                BNE     trns_compile_plotmask
;      Compile reading of pixel (4,5,5,1 instructions - each input store 5 instructions)
                ADRL            R2, trnslp_readpx_i1
                ADD             R2, R2, R0, LSL#4
                ADD             R2, R2, R0, LSL#2
                TrnsAsmReg      R2, trnslp_readpx_size
                BL              trnslp_chopexcess

                ASSERT trnslp_readpx_size = 5*4

; if doing 16->32 and 32->16 then build in appropriate munging code
        CMP     R1,#4
        BCC     %FT07
        CMP     R0,#4
        BCC     %FT07

        CMP     R0,R1
        BEQ     %FT07

        ; input and output are both >8bpp and are different
        CMP     R0,#4 ;inbpp
        ADREQ   R2,trnslp_munge_16to321
        TrnsAsmReg R2, trnslp_m1632_size1, EQ
        ADREQ   R2,trnslp_munge_16to322
        TrnsAsmReg R2, trnslp_m1632_size2, EQ
        ADREQ   R2,trnslp_munge_16to323
        TrnsAsmReg R2, trnslp_m1632_size3, EQ
        ADRNE   R2,trnslp_munge_32to161
        TrnsAsmReg R2, trnslp_m3216_size1, NE
        ADRNE   R2,trnslp_munge_32to162
        TrnsAsmReg R2, trnslp_m3216_size2, NE
07

;      If there is a translation table ...
        TST     R11, #mc_ttr
;          then translate the pixel
        BEQ     %FT01

;if inbpp and outbpp are both >8bpp ignore the translation table
        CMP     R1,#4
        BCC     %FT09
        CMP     R0,#4
        BCS     %FT08
09

;if inbpp is 16 or 32 and outbpp is 8 or below we need a CTrans
;32K entry table for colour matched. This will already have been validated

        CMP     R1,#4
        BCS     %FT07         ;output depth is >8bpp so skip this

        CMP     R0,#4
        BCC     %FT07         ;input depth is <16bpp so skip this

        ;ok - we definitely need a 32K table here. If it is 32bpp
        ;we also need to munge down to 16bpp before using the table

        ADRNE   R2,trnslp_munge_32to161
        TrnsAsmReg R2, trnslp_m3216_size1, NE
        ADRNE   R2,trnslp_munge_32to162
        TrnsAsmReg R2, trnslp_m3216_size2, NE

        ADRL     R2,trnslp_use32K
        TrnsAsmReg R2, trnslp_use32K_size
        B       %FT08
07

; First check to see if the output depth is greater than 8 bit per pixel,
; if it is then compile in the new translation functions which use
; a word array, rather than a byte array!

                [ ignore_ttr
                CMP             R1,#4
                BCC             %FT29         ;not if output bpp is <16bpp
                CMP             R0,#4
                BCS             %FT29         ;or input bpp is >8bpp

                LDR             R2,trns_palette
                TEQ             R2,#0
                BEQ             %FT29
                TrnsAsm         trnslp_transpx2, trnslp_transpx2_size

                ;if output is 16bpp now need to munge it down as well
                CMP             R1,#5
                ADRNE           R2,trnslp_munge_32to161
                TrnsAsmReg      R2, trnslp_m3216_size1, NE
                ADRNE           R2,trnslp_munge_32to162
                TrnsAsmReg      R2, trnslp_m3216_size2, NE
                B               %FT28
29
                CMP             R1,#4
                TrnsAsm         trnslp_transpx,  trnslp_transpx_size,  LT
                TrnsAsm         trnslp_transpx1, trnslp_transpx1_size, GE
28
                |

                CMP             R1,#4
                TrnsAsm         trnslp_transpx,  trnslp_transpx_size,  LT
                TrnsAsm         trnslp_transpx1, trnslp_transpx1_size, GE
                ]
01
08

;      Copy pixel into output pixel word (ORR out_word, out_word, pixel,LSL#32-out_bpp)
                LDR             R2, trnslp_setpx
                MOV             R3, #1
                MOV             R3, R3, LSL R1
                RSB             R3, R3, #32
                SetLsl          R2, R3
                STR             R2, [R10], #4
                ASSERT (trnslp_setpx_size = 4)
;      Assemble mask word
trns_compile_plotmask
;      If in GCOL 0-7,9,11,13, then assume the mask is whole sprite
        AND     R2, R11, #15            ;       R2 = GCOL in range 0-15
        ADD     R2, R2, #1              ;       R2 = GCOL +1
        MOV     R3, #2_1101010100000000 ;       Bits set are 8, 10, 12, 14, 15
        MOVS    R3, R3, LSR R2          ;       Move bit (R2-1) of R3 into the carry flag
;      CC if GCOL 0-7,9,11,13 (or no mask, in which case GCOL is in range 0-7)

;;-----------------------------------------------------------------------------
;; CC if no mask / CS has a mask so attempt to assemble in the function
;; which is correct for this depth, for 1,2,4 or 8 bit per pixel we can
;; simply compile in the ORR with a suitable mask, for 16 or 24 bit per pixel
;; we need to faff around and generate a new workspace word which
;; contains the correctmask.
;;-----------------------------------------------------------------------------

                BCS             trns_compile_mask

                CMP             R1, #4                          ; is the depth sensible?
                ADRCCL          R2, trnslp_sprnomask_o1
                ADDCC           R2, R2, R1,LSL#2
                TrnsAsmReg      R2, trnslp_sprnomask_size,CC
                ADRCSL          R2, trnslp_sprnomask16or24
                TrnsAsmReg      R2, trnslp_sprnomask16or24_size,CS
                B               trns_compile_nomask

;      Sprite has mask and it is used (GCOL 8,10,12,14,15)

trns_compile_mask

                MOVS            R2, R11, LSR #mcb_sprtype
                BEQ             trns_old_mask

                TrnsAsm         trnslp_new_sprmask, trnslp_new_sprmask_size
                TrnsAsm         trnslp_new_sprmask2, trnslp_new_sprmask2_size

                B               trns_any_mask

trns_old_mask
                TrnsAsm         trnslp_sprmask, trnslp_sprmask_size

;      Compile reading of mask pixel (4,5,5,1 instructions - each input store 5 instructions)
                ADRL            R2, trnslp_readpx_i1
                ADD             R2, R2, R0, LSL#4
                ADD             R2, R2, R0, LSL#2
                TrnsAsmReg      R2, trnslp_readpx_size
                BL              trnslp_chopexcess
                ASSERT trnslp_readpx_size = 5*4

                TEQ             R0,R1                   ;Check for 1:1 mapping?
                BEQ             trns_compile_mask1to1
trns_any_mask
;       Copy mask byte into output mask, first check for non-zero then orr in special case

                CMP             R1,#4
                ADRCCL          R2,trnslp_setmask_o1
                ADDCC           R2,R2,R1,LSL #3         ;Each section is 8 bytes (2 words)
                TrnsAsmReg      R2,trnslp_setmask_size,CC
                ASSERT trnslp_setmask_size = 2*4
                ADRCSL          R2,trnslp_setmask16or24
                TrnsAsmReg      R2,trnslp_setmask16or24_size,CS
                B               trns_compile_nomask

;      Copy pixel into output pixel word (ORR out_mask, out_mask, mask_pixel,LSL#32-out_bpp)


trns_compile_mask1to1
                LDR             R2, trnslp_setmask2
                MOV             R3, #1
                MOV             R3, R3, LSL R1
                RSB             R3, R3, #32
                SetLsl          R2, R3
                STR             R2, [R10], #4
                ASSERT  (trnslp_setmask2_size = 4)

trns_compile_nomask
;      Compile code to read the screen word
 [ AvoidScreenReads
;      If action code 0 (solid), use alternate code that avoids a load if the
;      mask is solid.
                ANDS            R2, R11, #7
                TrnsAsm         trnslp_readscrn0, trnslp_readscrn0_size, EQ
                TrnsAsm         trnslp_readscrn,  trnslp_readscrn_size,  NE
 |
                TrnsAsm         trnslp_readscrn, trnslp_readscrn_size
 ]
;      Test for plotting mask - if so compile ECF code, else GCOL code
        TST     R11, #mc_plotmask
        BNE     trns_compile_ecf_store
;      Store the GCOL action code (2,1,2,1,1,0,1,2 instructions, stored as 2 instructions in input)
                ADRL            R3, trnslp_gcol
                ANDS            R2, R11, #7
                ADD             R3, R3, R2,LSL#3
                TrnsAsmReg      R3, trnslp_gcol_size
                CMPNE           R2, #2
                CMPNE           R2, #7
                SUBNE           R10, R10, #4
                CMP             R2, #5
                SUBEQ           R10, R10, #4
                ASSERT trnslp_gcol_size = 2*4
        B       trns_compiled_gcol
;      Handle the mask and ECF
trns_compile_ecf_store
                TrnsAsm         trnslp_plotmask, trnslp_plotmask_size
;      Store the end of loop code
trns_compiled_gcol
                TrnsAsm         trnslp_eoloop, trnslp_eoloop_size
                Pull            "R2"
                TrnsBranch      R2, BGE
;       Store the code for storing the last word
                TrnsAsm         trnslp_lastword, trnslp_lastword_size
; loop
                Push            "R10"
;      Shift pixel and mask words by output bpp (2 instructions)
                ADRL             R2, trnslp_shfwam_o1
                ADD             R2, R2, R1, LSL#3
                TrnsAsmReg      R2, trnslp_shfwam_size
                ASSERT trnslp_shfwam_size = 2*4
;      Loop until words are aligned
                Pull            "R2"
                TrnsBranch      R2, BCC
;      Compile code to read the screen word
                TrnsAsm         trnslp_readscrn, trnslp_readscrn_size
;      Test for plotting mask - if so compile ECF code, else GCOL code
        TST     R11, #mc_plotmask
        BNE     trns_compile_ecf_store2
;      Store the GCOL action code (2,1,2,1,1,0,1,2 instructions, stored as 2 instructions in input)
                ADRL            R3, trnslp_gcol
                ANDS            R2, R11, #7
                ADD             R3, R3, R2,LSL#3
                TrnsAsmReg      R3, trnslp_gcol_size
                CMPNE           R2, #2
                CMPNE           R2, #7
                SUBNE           R10, R10, #4
                CMP             R2, #5
                SUBEQ           R10, R10, #4
                ASSERT trnslp_gcol_size = 2*4
        B       trns_compiled_gcol2
;      Handle the mask and ECF
trns_compile_ecf_store2
                TrnsAsm         trnslp_plotmask, trnslp_plotmask_size
;      Compile code to store the word and exit
trns_compiled_gcol2
                TrnsAsm         trnslp_lastword2, trnslp_lastword2_size
;      Code compiled.
        Debug   mc,"Transformation code ends at",r10
        Push    "r0-r2"
        MOV     r2, r10
        LDR     r1, trns_codebuffer
        MOV     r0, #1
        SWI     XOS_SynchroniseCodeAreas
        Pull    "r0-r2"

trns_compiling_complete
        Pull    "PC"

trnslp_chopexcess
;this routine reduces the various readpx_i segments down to the real
;size rather than five words
        TEQ     R0, #0
        SUBEQ   R10, R10, #4
        TEQ     R0, #3
        SUBEQ   R10, R10, #16
        TEQ     R0, #4
        SUBEQ   R10, R10, #4
        TEQ     R0, #5
        SUBEQ   R10, R10, #16
        MOV     PC,LR
 |
a1448 1
 ]
@


4.16
log
@Fix up some warnings from the assembler.
Transformed sprites tested briefly & still work.

Version 1.47. Tagged as 'SprExtend-1_47'
@
text
@d95 2
d150 2
d277 3
d286 5
d404 1
d656 16
a673 1
        LDR     R10, BPP
d968 1
d970 4
d1594 1
d2353 27
a2379 1

@


4.15
log
@Update to work with zero page relocation
Detail:
  Sources/SprExtend - Try using OS_ReadSysInfo 6 to get ECF block addresses before falling back on legacy addresses. Store pointers in module workspace for speedy access.
  Sources/SprOp, Sources/SprTrans - Use workspace ECF block pointers
  c/rojpeg - Fix null pointer access (actually an unused variable)
Admin:
  Tested on rev A2 BB-xM


Version 1.46. Tagged as 'SprExtend-1_46'
@
text
@d128 1
d131 4
d512 1
a512 2
        SUB     sp, sp, #64
        Push    "R12"
d515 3
a517 2
        MOV     R0, R0, ASL R11
        MOV     R9, R9, ASL R11
d520 6
a525 4
        MOV     R8, R8, ASL R11
        MOV     R14, R14, ASL R11
        ADD     R12, SP, #4
        MOV     R10, R12
d527 4
a530 4
        STMIA   R10!, {R11}
        STMIA   R10!, {R0,R8,R11}
        STMIA   R10!, {R9}
        STMIA   R10!, {R8,R11}
d532 1
a532 2
        STMIA   R10!, {R0,R14}
        STMIA   R10!, {R11}
d536 1
a536 1
        MOV     R0, R12
d541 1
a541 1
        ADDVS   sp, sp, #64+8
d545 1
a545 3
; Recover R6

        ADD     R10, R12, #4
a546 1
        Pull    "R12"
d554 2
d1909 1
a1909 1
        LDMEQFD sp!, {PC}
d1916 1
a1916 1
        LDMFD   sp!, {PC}
@


4.14
log
@Small optimisation to mask twiddling in 24bpp case, the code was emitting 3 instructions because it didn't use LSR#32 which is a documented instruction.
Changed an unaligned load in the 16bpp case to use LDRH when possible.
Lined up some stuff, changed R15 to PC.

Version 1.44. Tagged as 'SprExtend-1_44'
@
text
@d872 1
a872 1
        MOV     R6, #VduDriverWorkSpace + BgEcfOraEor
a1216 1
        MOV     trns_scr_y, R1
d1226 5
a1230 2
        CMP     R14, #VduDriverWorkSpace + BgEcfOraEor+64
        MOVGE   R14, #VduDriverWorkSpace + BgEcfOraEor
@


4.13
log
@Singular myLSL expanded to MOV equivalent to match rest of code.
Retagged as SprExtend-1_43.
@
text
@d1675 2
a1676 5
        ;MOVS    trns_out_word, trns_out_word
        ;MOV     trns_out_mask, trns_out_mask
        ;achieve the same effect as a LSR#32 would do, if such existed!
        MOV      trns_out_word,#1
        MOVS     trns_out_word,trns_out_word,LSR #1
a1679 5
;can't do the 32 bit case in two instructions, so here's the last one

trnslp_shfwam_o24_2
        MOV      trns_out_mask, #0

d1703 2
a1704 2
        ANDNE   R0,R0,R0
        ANDNE   R0,R0,R0
d1707 2
a1708 2
        ;note - this will be word or half word aligned
        LDR     trns_dummy14, [trns_spr_start, trns_offset, LSL #1]
d1711 6
a1716 1
        ANDNE   R0,R0,R0
d1721 2
a1722 2
        ANDNE   R0,R0,R0
        ANDNE   R0,R0,R0
a2029 4
                CMP             R1, #5
                LDREQ           R2, trnslp_shfwam_o24_2
                STREQ           R2, [R10], #4      ; need three insts for 32bpp

d2290 6
a2295 6
	Push	"r0-r2"
	MOV	r2, r10
	LDR	r1, trns_codebuffer
	MOV	r0, #1
	SWI	XOS_SynchroniseCodeAreas
	Pull	"r0-r2"
d2303 9
a2311 9
        TEQ             R0, #0
        SUBEQ           R10, R10, #4
        TEQ             R0, #3
        SUBEQ           R10, R10, #16
        TEQ             R0, #4
        SUBEQ           R10, R10, #4
        TEQ             R0, #5
        SUBEQ           R10, R10, #16
        MOV R15,LR
@


4.12
log
@Made safe to build with newer ARM instruction support in objasm.

Replaced use of LSL (et al) macros with the new myLSL macros to avoid
potential clash with new pseudo-opcodes

Admin: requires HdrSrc 1.79 or later.

Version 1.41. Tagged as 'SprExtend-1_41'
@
text
@d592 1
a592 1
        myLSL   R10, 2
@


4.11
log
@Title line made consistent.
No code change - not tagged.
@
text
@d592 1
a592 1
        LSL     R10, 2
@


4.11.2.1
log
@Push recent changes on the trunk to the IJG8b branch.
Tested briefly, still works.

Version 1.38, 1.35.2.15. Tagged as 'SprExtend-1_38-1_35_2_15'
@
text
@a16 4
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Data areas & register allocation
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

d38 1
a38 1
trns_ecf_ptr                    #       4       ;       ECF pointer
d47 14
a60 15
;       Offset 0  : Flag word. Top two bits specify direction of line in the X-axis (01=positive,1x=negative)
;                              Bottom two bits specify whether edge is active (01), not yet active (00), or dead (11)
; The next 5 words are dependent on the flags.
; For active edges:
;       Offset 4  : Lower Y coordinate (in 256ths pixels, bottom of screen is 0) of edge.
;                   The line is deactivated after reaching this Y coordinate
;       Offset 8  : ABS(deltaX) for the line, in 256ths of a pixel
;       Offset 12 : ABS(deltaY) for the line, in 256ths of a pixel
;       Offset 16 : Bresenham error value for the pixel
;       Offset 20 : Current X coordinate of the point (in pixels)
; For inactive edges:
;       Offset 4  : Lower X coordinate (256ths of pixel)
;       Offset 8  : Lower Y coordinate
;       Offset 12 : Upper X coordinate
;       Offset 16 : Upper Y coordinate
a94 4
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Macros
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

d122 1
d132 1
d146 1
a146 1
      [ debugtr
d149 1
a149 1
      ]
d166 4
d177 2
a178 2
    [ usemull
      [ $ra = $rl :LOR: $ra = $rh
d182 1
a182 1
      |
d184 2
a185 2
      ]
    |
d188 1
a188 1
    ]
d191 1
a219 13
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SpriteOp_PlotMaskTransformed
; ----------------------------
; Entry: [spritecode] = reason code
;        R1 --> areaCBptr
;        R2 --> sprite name
;        R3 = flags
;        R4 --> source rectangle (if R1 b1 set)
;        R5 = plot action
;        R6 --> transformation matrix or destination rectangle (if R3 b0 set)
;        R7 --> pixel translation table
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

d222 1
a222 1
        ; Pretend its a GCOL 8 - use sprite's mask if it has one
d224 1
a224 1
        ; No colour translation
a227 13
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SpriteOp_PutSpriteTransformed
; ----------------------------
; Entry: [spritecode] = reason code
;        R1 --> areaCBptr
;        R2 --> sprite name
;        R3 = flags
;        R4 --> source rectangle (if R1 b1 set)
;        R5 = plot action
;        R6 --> transformation matrix or destination rectangle (if R3 b0 set)
;        R7 --> pixel translation table
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

d236 1
a236 1
      [ flagbit
d248 1
a248 1
      ]
d258 1
a258 1
        ; see if reason code indicated a sprite name or sprite pointer in R2
d264 1
a264 1
        ; read input/output mode variables
d274 3
a276 3
      [ ignore_ttr
        ; check whether it has a palette - if doing <16 to >8 we may use it in preference
        ; to the translation table
d305 1
a305 1
        [ flagbit
d308 5
d316 4
d327 1
a327 1
      ]
d329 1
a329 1
        ; validate supplied translation table (if any)
d335 5
a339 5

      [ ignore_ttr
        ; if doing a sprite of <16bpp to >8bpp, and it has a palette, change the ttr pointer
        ; to point at the palette data instead of the ttr data. Note that the two are different
        ; formats, so there is also a different plotting routine to include too...
d357 3
a359 3
        ; trns_palette doubles as a pointer to the palette up this far, and then becomes a
        ; compilation flag for the macro generation (with the value being passed in as the
        ; ttr address)
d362 1
a362 1
      ]
d366 1
a366 1

d387 1
a387 1
        ; adapt mode variables intelligently (account for double pixel modes)
d400 4
a403 4
        ; Valid registers: R1 - ptr to sprite?, R3 - flags, R4 -> coordinate block, R5 GCOL, R6->matrix/coords, R7->ttr
        ;        Debug   tr,"Read VDU and sprite:",#gwx0,#gwy0,#gwx1,#gwy1,#orgx,#orgy
        ;        Debug   tr,"Pointer to sprite:",R1
        ; Get coordinate block
d409 1
a409 1
        ; (whole sprite R0 - left, R8 - top y, R9 - right, R14 - bottom)
d428 1
a428 1
        ; Check area passed in
d432 1
a432 1
        ; If using a matrix then clip source rectangle to sprite
d470 1
a470 1
        ; If not using a matrix then check valid source area
d503 2
a504 2
        ; Valid registers: R0,R8,R9,R14 - source rect, R1 - ptr to sprite, R5 GCOL, R6->matrix/coords, R7->ttr
        ; Set up input path for draw - move to R0,R8, move to R9,R14, end path
d528 1
a528 1
        ; Transform the path
d539 1
a539 1
        ; Recover R6
d555 1
a555 1
        ; Make Y values offset from the top of the sprite, not the bottom
d563 1
a563 1
        ; Get R4 = distance from top of sprite, R2 = height of sprite, and set R8,R14 to be offset from R4
d572 1
a572 1
        ; Store height, left, right of sprite for inner loop
d582 1
a582 1
        ; Add R4*sprite_byte_width to sprite_pixel_data_start to give top of sprite, and store for loop
d592 1
a592 1
        MOV     R10, R10, LSL#2
d597 3
a599 3
        ; and we have to do the same for the mask data now
        ; for now we just save the R4 value and deal with it once we have the mask
        ; equivalent of spWidth computed for the mask
d603 1
a603 1
        ; Work out byte width << 3-input_bpp, and store for loop
d636 1
a636 1
        ; Get mask offset and store ttr pointer (clear mask GCOL bit if there is no mask)
d681 3
a683 3
        ; Copy the coordinate block
        ; Valid registers: R0,R8,R9,R14 - source rect, R1 - ptr to sprite, R5 GCOL, R6->matrix/coords, R7->ttr
        ; copy coordinates, adding graphics origin
d689 1
a689 1
        ; get O.S. to pixel shift (account for double pixel modes)
d698 1
a698 1
        ; get graphics origin
d703 1
a703 1
        ; get coordinates
d707 1
a707 1
        ; x coords
d726 1
a726 1
        ; y coordinates
d748 1
a748 1
        ; Get determinant
d757 1
a757 1
        ; R4,5 = x1 * y2
d763 1
a763 1
        ; R6,7 = x2 * y1
d769 1
a769 1
        ; R4,R5 = x1*y2 - x2*y1 (48.16 precision)
d775 1
a775 1
        ; R4,R5 = x1*y2 - x2*y1 / 4 (48.14 precision)
d781 1
a781 1
        ; R6,R7 = 1 / (x1*y2 - x2*y1) (16.48 precision)
d797 1
d799 1
d801 1
a801 1
        ; spr_inc_X_x = det*y2 [ * xsize ]
d808 1
a808 1
        ; spr_inc_Y_x = det*-y1 [ * ysize ]
d815 1
a815 1
        ; spr_inc_X_y = det*-x2 [ * xsize ]
d822 1
a822 1
        ; spr_inc_Y_y = det*x1 [ * ysize ]
d829 1
a829 1
        ; Store increments
d839 2
a840 2
        ; thats all the horrid fixed point stuff out of the way
        ; Find the top y coordinate
d852 2
a853 2
        ; Valid registers: R5 GCOL, R7->ttr, R4 - maximum ycoordinate of area
        ;                                       Get top y coordinate of centre of line being drawn in R1
d863 1
a863 1
        ; Get address of line on screen
d871 2
a872 2
        ; Get ECF pointer
        LDR     R6, vdu_bgecforaeor
d875 1
a875 1
        ; Debug   tr, "Ecf pointer is:",R6
d878 2
a879 2
        ;spr_X_x0_y% += ((screen_y%-y(0)) * (!asm_spr_inc_X_y)) / 256
        ; screen_y%-y(0) = R6.R4
d885 1
a885 1
        ; Debug tr,"scry%-y0:",R4
d889 1
a889 1
        ; inc_X_y = R8.R9
d892 1
a892 1
        ; Debug tr,"IncXx",R14
d894 1
a894 1
        ; Debug tr,"incXy,Xx0",R14,R0
d898 1
a898 1
        ; multiply
d910 2
a911 2
        ;spr_Y_x0_y% += ((screen_y%-y(0)) * (!asm_spr_inc_Y_y)) / 256
        ; inc_Y_y = R8.R9
d926 1
a926 1
        ; Valid registers: R0,R2 - X_x0_y/Y_x0_y, R5 GCOL, R7->ttr
d932 1
a932 1
        ; Now compile the code
d939 1
a939 1
        ; Now, set up the edges in the edge block
d946 1
a946 1
        ; Edge 0->1
d954 1
a954 1
        ; Edge 1->2
d963 1
a963 1
        ; Edge 0->3
d972 1
a972 1
        ; Edge 3->2
d984 4
a987 4
        ; Debug tr,"Active edge list:",#trns_spr_edgeblock,#trns_spr_edgeblock+4,#trns_spr_edgeblock+8,#trns_spr_edgeblock+12,#trns_spr_edgeblock+16,#trns_spr_edgeblock+20,#trns_spr_edgeblock+24
        ; Debug tr,"Active edge list:",#trns_spr_edgeblock+28,#trns_spr_edgeblock+32,#trns_spr_edgeblock+36,#trns_spr_edgeblock+40,#trns_spr_edgeblock+44,#trns_spr_edgeblock+48,#trns_spr_edgeblock+52
        ; Debug tr,"Active edge list:",#trns_spr_edgeblock+56,#trns_spr_edgeblock+60,#trns_spr_edgeblock+64,#trns_spr_edgeblock+68,#trns_spr_edgeblock+72,#trns_spr_edgeblock+76,#trns_spr_edgeblock+80
        ; Debug tr,"Active edge list:",#trns_spr_edgeblock+84,#trns_spr_edgeblock+88,#trns_spr_edgeblock+92,#trns_spr_edgeblock+96,#trns_spr_edgeblock+100,#trns_spr_edgeblock+104,#trns_spr_edgeblock+108
d989 1
a989 1
        ; Get top Y coordinate
d994 1
a994 1
        ; Start loop - looping until all edges are deactivated or below Y coord
d1001 1
a1001 1
        ; Activate any new edges, deactivate old ones (R11 = count of deactivated edges)
d1007 1
a1007 1
        ; Checked all the edges?
d1012 1
a1012 1
        ; If dead then ignore
d1017 1
a1017 1
        ; If active then shoule we deactivate it?
d1022 1
a1022 1
        ; Test for activation
d1028 1
a1028 1
        ; Activate an edge
d1034 1
a1034 1
        ; Calculate R3=ABS(deltaX) and R4=ABS(deltaY).
d1040 1
a1040 1
        ; Record direction of line as 1 or -1 in top two bits of flags
d1045 1
a1045 1
        ; Now calculate target Y co-ordinate - the line must stop after this Y value is reached.
d1053 3
a1055 3
        ; Valid registers: R0-flags, R1-current Y, R2-target Y, R3,R4-dX,dY,
        ;                  R7,R8-Upper x,y, R10-store for edge, R11-count of deactivated edges
        ; Now get Bresenham error in R6.
d1063 1
a1063 1
        ; Only do complicated stuff if simple stuff will overflow
d1068 1
a1068 1
        ; R7=-1,C=1 for leftward lines, R7=0,C=0 for rightward lines.
d1072 1
a1072 1
        ; Get R0=real sub-X coordinate on screen (R14=subpixel now)
d1077 1
a1077 1
        ; R4,R5 = R0*dY , R6,R7=R4,R5 -1 if leftward,+0 i rightward
d1083 1
a1083 1
        ; R6,R7 += R0*dX
d1090 1
a1090 1
        ; Change error to full pixel instead of 256ths pixels
d1097 1
a1097 1
        ; Do simple stuff
d1101 1
a1101 1
        ; R6=-1,C=1 for leftward lines, R6=0,C=0 for rightward lines.
d1105 1
a1105 1
        ; Get R0=real sub-X coordinate on screen (R14=subpixel now)
d1114 1
a1114 1
        ; Now R6=Bresenham value
d1119 2
a1120 2
        ; Now advance the edge until we're on the right scan line and the Bresenham
        ; value is negative.
d1134 1
a1134 1
        ; Store flags,targetY,deltaX,deltaY
d1141 1
a1141 1
        ; If now below it then kill it
d1155 5
a1159 5
        ; Debug tr,"Active edge list:",#trns_spr_edgeblock,#trns_spr_edgeblock+4,#trns_spr_edgeblock+8,#trns_spr_edgeblock+12,#trns_spr_edgeblock+16,#trns_spr_edgeblock+20,#trns_spr_edgeblock+24
        ; Debug tr,"Active edge list:",#trns_spr_edgeblock+28,#trns_spr_edgeblock+32,#trns_spr_edgeblock+36,#trns_spr_edgeblock+40,#trns_spr_edgeblock+44,#trns_spr_edgeblock+48,#trns_spr_edgeblock+52
        ; Debug tr,"Active edge list:",#trns_spr_edgeblock+56,#trns_spr_edgeblock+60,#trns_spr_edgeblock+64,#trns_spr_edgeblock+68,#trns_spr_edgeblock+72,#trns_spr_edgeblock+76,#trns_spr_edgeblock+80
        ; Debug tr,"Active edge list:",#trns_spr_edgeblock+84,#trns_spr_edgeblock+88,#trns_spr_edgeblock+92,#trns_spr_edgeblock+96,#trns_spr_edgeblock+100,#trns_spr_edgeblock+104,#trns_spr_edgeblock+108
        ; Debug tr,"Number of active/not yet activated edges:",R11
d1161 1
a1161 1
        ; Move on all active lines
d1171 2
a1172 2
        ; R0-flags, R2 - target Y, R3 - deltaX, R4-deltaY
        ; R6-Bresenham error value, R7-current X
d1177 2
d1192 1
a1192 1
        ; Now find the pair of lines which are active
d1195 5
a1199 5
        ; Debug tr,"Active edge list:",#trns_spr_edgeblock,#trns_spr_edgeblock+4,#trns_spr_edgeblock+8,#trns_spr_edgeblock+12,#trns_spr_edgeblock+16,#trns_spr_edgeblock+20,#trns_spr_edgeblock+24
        ; Debug tr,"Active edge list:",#trns_spr_edgeblock+28,#trns_spr_edgeblock+32,#trns_spr_edgeblock+36,#trns_spr_edgeblock+40,#trns_spr_edgeblock+44,#trns_spr_edgeblock+48,#trns_spr_edgeblock+52
        ; Debug tr,"Active edge list:",#trns_spr_edgeblock+56,#trns_spr_edgeblock+60,#trns_spr_edgeblock+64,#trns_spr_edgeblock+68,#trns_spr_edgeblock+72,#trns_spr_edgeblock+76,#trns_spr_edgeblock+80
        ; Debug tr,"Active edge list:",#trns_spr_edgeblock+84,#trns_spr_edgeblock+88,#trns_spr_edgeblock+92,#trns_spr_edgeblock+96,#trns_spr_edgeblock+100,#trns_spr_edgeblock+104,#trns_spr_edgeblock+108
        ; Debug tr,"Number of active/not yet activated edges:",R11
d1214 1
a1214 1
        ; R6,R7 are x coords to plot between at current Y
d1217 1
d1227 2
a1228 5
        LDR     trns_scr_y, vdu_bgecforaeor
        ADD     trns_scr_y, trns_scr_y, #64
        CMP     R14, trns_scr_y
        SUBGE   R14, trns_scr_y, #64
        MOV     trns_scr_y, R1
d1233 3
a1235 3
        ; Debug tr,"Calling plotting routine: lx,rx,ty",trns_scr_lx, trns_scr_rx, trns_scr_y
        ; Debug tr,"incXx,Yx,Xy,Yy,lineptr",trns_inc_X_x,trns_inc_Y_x,trns_inc_X_y,trns_inc_Y_y,trns_line_ptr
        ; Debug tr,"X0Y0",trns_X_x0_y,trns_Y_x0_y
d1256 1
a1256 1
        ; Update changed coordinate block?
d1263 1
a1263 1
        ; Get R6 = top y, R4 = bottom y
d1268 1
a1268 1
        ; Check top y was above gwy0, else no change to box
d1274 1
a1274 1
        ; Find R3 = left x, R5 = right x
d1292 1
a1292 1
        ; Now convert from 256ths pixels to pixels, and clip to graphics window
d1307 1
a1307 1
        ; Unbodge double pixels
d1316 1
a1316 1
        ; Get original box and update it
d1335 8
a1342 8
        ; produce_increment
        ;
        ; Routine to get increment in sprite due to x or y movement -
        ;
        ; R0 - x or y distance
        ; R1 - size of sprite (width or height)
        ; R6,7 - 64 bit determinant (16.48 format)
        ; Result in R4
d1347 1
a1347 1
        ; First split R6/7 into R4-R7
d1359 1
a1359 1
        ; Now check sign of R0, R3 = sign of product
d1363 1
a1363 1
        ; If R3<0 (i.e. product<0) then R1=-R1
d1367 1
a1367 1
        ; If R0<0 then R0=-R0
d1371 1
a1371 1
        ; Split R0
d1378 1
a1378 1
        ; Now produce R8 = U0.6 + L2.6 + L0.7, R6 = U2.6 + U0.7 (inc. carries)
d1391 1
a1391 1
        ; Now produce R9 = L6 + L2.7 + L0.5, R7 = U6 + U2.7 + U0.5 (inc carries)
d1405 1
a1405 1
        ; Now produce R10 = L7 + L2.5 + L0.4, R5 = U7 + U2.5 + U0.4 (inc. carries)
d1419 1
a1419 1
        ; Now produce R11 = L5 + L2.4
d1425 2
a1426 2
        ; Now R11.R10.R9.R8 (sixteen bits each) = 256/Det*Size in 32.32 form
        ; So get R1 * R11.R10.R9.R8 into R4
d1447 5
a1451 3
        ; out_qfill_fastclip
        ;
        ; Fast Y clipping routine
d1472 4
a1475 5
        ; out_qfill_fasthoriz
        ;
        ; Subroutine to advance an edge horizontally fast (i.e. using long division
        ; rather than division by repeated subtraction!)
        ;   Updates R6 and R7, corrupts R2 and R3, preserves flags & other registers
d1483 8
a1490 11
      [ usemull
        ! 0, "Using SMULL for SSmultD - StrongARM or later only"
      |
        ; arith_SSmultD
        ;
        ; Subroutine to multiply two single precision signed numbers together and
        ; get a double precision result. The word following the BL should contain
        ; the numbers of the two operand registers in its bottom two bytes and the
        ; number of the register to take the ls part of the result in the next byte.
        ; The ms part of the result will go into the next register.
        ;   This routine will only work on registers R0-R8.
d1519 11
a1529 1
      ]
a1530 11
        ; arith_DSdivS
        ;
        ; Subroutine to divide a double precision unsigned number by a single
        ; precision unsigned number, yielding a single precision unsigned result.
        ; The word following the BL should contain the number of the register holding
        ; the ls part of the dividend in its bottom byte; the ms part of the dividend
        ; is in the next register. The next byte of the word contains the number of
        ; the divisor register, and the next byte the number of the register in which
        ; to deposit the quotient.
        ;   This routine will only work on registers R0-R8. It assumes that the
        ; divisor is not zero, and that the quotient will not overflow.
d1541 1
a1541 1
10
d1547 1
a1547 1
        BCC     %BT10                   ;  unless sentinel bit shifted out
a1552 3
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Code primitives which get compiled in
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d1554 3
d1559 1
a1559 1
        ; Start of routine
d1569 1
a1569 1
        ; Get address of lefthand x on screen (dependent on out_bpp)
d1603 1
a1603 1
        ; Get pixel and macro word shifted to align with lefthand pixel inside screen word
d1609 1
a1609 1
        ; Start of loop
d1630 1
a1630 1
        ; Start of loop (1bpp mask)
d1658 1
a1658 1
        ; Shift pixel and mask words by out_bpp
d1675 5
a1679 2
        MOVS    trns_out_word, trns_out_word, LSR#32
        MOV     trns_out_mask, #0
d1683 6
a1688 1
        ; Read pixel from sprite (dependent on in_bpp)
d1694 1
d1711 2
a1712 2
        ANDEQ   R0,R0,R0
        ANDEQ   R0,R0,R0
d1715 2
a1716 2
      [ NoARMv4
        LDR     trns_dummy14, [trns_spr_start, trns_offset, LSL #1]     ;note - this will be word or half word aligned
d1719 1
a1719 6
      |
        MOV     trns_dummy14, trns_offset, LSL #1
        LDRH    trns_dummy14, [trns_spr_start, trns_dummy14]
        ANDEQ   R0,R0,R0
      ]
        ANDEQ   R0,R0,R0
d1724 2
a1725 2
        ANDEQ   R0,R0,R0
        ANDEQ   R0,R0,R0
d1730 1
a1730 1
        ; Translate pixel through ttr
d1742 1
a1742 1
      [ ignore_ttr
d1749 1
a1749 1
      ]
d1752 7
a1758 7
        MOV     trns_dummy14,trns_dummy14,LSL #17
        MOV     trns_dummy14,trns_dummy14,LSR #17
        
        LDR     trns_dummy12,trns_comp_spr_ttr + compiled_routine_stacked ;fetch the table address
        LDR     trns_dummy12,[trns_dummy12,#4]
        ; trns_dummy12 is correct at this point....
        LDRB    trns_dummy14,[trns_dummy12,trns_dummy14]
d1761 1
a1761 1
        ; Copy pixel into output word (dependent on out_bpp)
d1767 1
a1767 1
        ; If sprite has no mask, then ORR set bits into the output mask word
d1783 2
a1784 3
        ASSERT trnslp_sprnomask16or24_size = 4*2

        ; If sprite has a mask then read it in (also uses trnslp_readpx_i, above)
d1791 4
a1794 1
        ; If sprite has a 1BPP mask then read it in
d1796 1
d1807 1
a1807 1
        ; Setup valid mask pixel into mask word
d1821 1
a1821 1
        ASSERT (.-trnslp_setmask_o1) = trnslp_setmask_size*4
d1828 1
a1828 1
        ASSERT (.-trnslp_setmask16or24) = 3*4
d1830 1
a1830 1
        ; Cope with 1:1 mapping in the mask and screen mode
d1836 1
a1836 1
        ; Read the screen word
d1843 1
a1843 1
      [ AvoidScreenReads
d1849 1
a1849 1
      ]
d1851 1
a1851 1
        ; Effect the screen word depending on the GCOL action
d1853 5
a1857 5
        ;       GCOL 0 - plot direct
        BICCS   trns_offset, trns_offset, trns_out_mask
        EORCS   trns_offset, trns_offset, trns_out_word
        ;       GCOL 1 - OR with screen
        ORRCS   trns_offset, trns_offset, trns_out_word
d1859 5
a1863 5
        ;       GCOL 2 - AND with screen
        EORCS   trns_out_word, trns_out_word, trns_out_mask
        BICCS   trns_offset, trns_offset, trns_out_word
        ;       GCOL 3 - EOR with screen
        EORCS   trns_offset, trns_offset, trns_out_word
d1865 4
a1868 2
        ;       GCOL 4 - Invert screen
        EORCS   trns_offset, trns_offset, trns_out_mask
a1869 1
        ;       GCOL 5 - Do nothing
d1871 2
d1874 3
a1876 6
        ;       GCOL 6 - AND with NOT colour
        BICCS   trns_offset, trns_offset, trns_out_word
        ANDEQ   R0,R0,R0
        ;       GCOL 7 - ORR with NOT colour
        EORCS   trns_out_word, trns_out_word, trns_out_mask
        ORRCS   trns_offset, trns_offset, trns_out_word
d1880 1
a1880 1
        ; Effect the screen word according to the mask and ECF
d1882 6
a1887 6
        LDRCS   trns_dummy12, trns_comp_ecf_ora + compiled_routine_stacked
        LDRCS   trns_out_word, trns_comp_ecf_eor + compiled_routine_stacked
        ANDCS   trns_dummy12, trns_dummy12, trns_out_mask
        ANDCS   trns_out_word, trns_out_word, trns_out_mask
        ORRCS   trns_offset, trns_offset, trns_dummy12
        EORCS   trns_offset, trns_offset, trns_out_word
d1891 1
a1891 1
        ; End of the loop - store the screen word and move on a screen pixel
d1893 6
a1898 6
        STRCS   trns_offset, [trns_out_ptr], #4
        MOVCS   trns_out_word, #&80000000
        ADD     trns_X, trns_X, trns_inc_X_x
        ADD     trns_Y, trns_Y, trns_inc_Y_x
        SUB     trns_xsize, trns_xsize, #&10000
        CMP     trns_xsize, #&10000
d1902 1
a1902 1
        ; Finished row so store last compiled output word and mask, if necessary
d1909 1
a1909 1
        ; Stored last output word and mask on screen, so exit
d1929 1
a1929 1
        ; now copy the top three bits of each colour component into the bottom three
a1956 3
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Run time code generation
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d1958 6
a1963 4
        ; compile_transform_code
        ;
        ; Routine to compile the code specified by the GCOL action, in_bpp,
        ; out_bpp, translation table, and plotmask/putsprite options
d1966 1
a1966 1
        ; R11 = GCOL calue (including mask bit)
d1968 1
a1968 1
        ; Set mc_ttr if colour translation table is to be used
d1971 1
a1971 1
        ; Set mc_plotmask if plotting the mask, clear if putting a sprite
d1976 1
a1976 1
        ; Store the sprite type, so that new masks make a difference
d1980 1
a1980 1
        ; Set in_bpp, out_bpp
d1986 1
a1986 1
        ; Set bit denoting transformed sprite, rather than scaled sprite (uses same area as Sprite_PutSpriteScaled)
d1988 1
a1988 1
        ; Test with old compiled routine
d1992 1
a1992 1

d1995 1
a1995 1
        ; compile the code - R0=in_bpp, R1=out_bpp
d2001 45
a2045 31
        ; Start of loop
        TrnsAsm trnslp_strt, trnslp_strt_size
        ; Get start pixel on the screen line of lefthand x coord (4 instr)
        ADRL    R2, trnslp_getaddr_o1
        ADD     R2, R2, R1, LSL#4
        TrnsAsmReg R2, trnslp_getaddr_size
        ASSERT trnslp_getaddr_size = 4*4
        ; Shift start words (pixel and mask) according to pixel offset
        TrnsAsm trnslp_getwam, trnslp_getwam_size
        ; loop Store address on stack for the loop
        Push    "R10"

        ; If using a 1bpp mask we need to work out a different offset for the mask too
        MOVS    R2, R11, LSR #mcb_sprtype
        TSTNE   R11, #mc_hasmask

        ; First 15 words of the loop (to find byte offset in sprite from sprite X,Y coords)
        TrnsAsm trnslp_stloop1, trnslp_stloop1_size ,EQ
        TrnsAsm trnslp_stloop2, trnslp_stloop2_size ,EQ
        TrnsAsm trnslp_stloop3, trnslp_stloop3_size ,EQ

        TrnsAsm trnslp_nmstloop1, trnslp_nmstloop1_size ,NE
        TrnsAsm trnslp_nmstloop2, trnslp_nmstloop2_size ,NE
        TrnsAsm trnslp_nmstloop3, trnslp_nmstloop3_size ,NE
        TrnsAsm trnslp_nmstloop4, trnslp_nmstloop4_size ,NE

        ; Shift pixel and mask words by output bpp (2 instructions)
        ADRL    R2, trnslp_shfwam_o1
        ADD     R2, R2, R1, LSL#3
        TrnsAsmReg R2, trnslp_shfwam_size
        ASSERT trnslp_shfwam_size = 2*4
d2047 1
a2047 11
        ; If putting the sprite (i.e. not plotting the mask)
        TST     R11, #mc_plotmask
        BNE     trns_compile_plotmask
        ; Compile reading of pixel (4,5,5,1 instructions - each input store 5 instructions)
        ADRL    R2, trnslp_readpx_i1
        ADD     R2, R2, R0, LSL#4
        ADD     R2, R2, R0, LSL#2
        TrnsAsmReg R2, trnslp_readpx_size
        BL      trnslp_chopexcess

        ASSERT trnslp_readpx_size = 5*4
d2049 1
a2049 1
        ; if doing 16->32 and 32->16 then build in appropriate munging code
d2072 1
a2072 1
        ; If there is a translation table ...
d2074 1
a2074 1
        ; then translate the pixel
d2077 1
a2077 1
        ; if inbpp and outbpp are both >8bpp ignore the translation table
d2084 2
a2085 2
        ; if inbpp is 16 or 32 and outbpp is 8 or below we need a CTrans
        ; 32K entry table for colour matched. This will already have been validated
d2093 2
a2094 2
        ; ok - we definitely need a 32K table here. If it is 32bpp
        ; we also need to munge down to 16bpp before using the table
d2101 1
a2101 1
        ADRL    R2,trnslp_use32K
d2106 22
a2127 22
        ; First check to see if the output depth is greater than 8 bit per pixel,
        ; if it is then compile in the new translation functions which use
        ; a word array, rather than a byte array!

        [ ignore_ttr
        CMP     R1,#4
        BCC     %FT29         ;not if output bpp is <16bpp
        CMP     R0,#4
        BCS     %FT29         ;or input bpp is >8bpp
        
        LDR     R2,trns_palette
        TEQ     R2,#0
        BEQ     %FT29
        TrnsAsm trnslp_transpx2, trnslp_transpx2_size
        
        ; if output is 16bpp now need to munge it down as well
        CMP     R1,#5
        ADRNE   R2,trnslp_munge_32to161
        TrnsAsmReg R2, trnslp_m3216_size1, NE
        ADRNE   R2,trnslp_munge_32to162
        TrnsAsmReg R2, trnslp_m3216_size2, NE
        B       %FT28
d2129 3
a2131 3
        CMP     R1,#4
        TrnsAsm trnslp_transpx,  trnslp_transpx_size,  LT
        TrnsAsm trnslp_transpx1, trnslp_transpx1_size, GE
d2133 1
a2133 1
        |
d2135 4
a2138 4
        CMP     R1,#4
        TrnsAsm trnslp_transpx,  trnslp_transpx_size,  LT
        TrnsAsm trnslp_transpx1, trnslp_transpx1_size, GE
        ]
d2142 9
a2150 9
        ; Copy pixel into output pixel word (ORR out_word, out_word, pixel,LSL#32-out_bpp)
        LDR     R2, trnslp_setpx
        MOV     R3, #1
        MOV     R3, R3, LSL R1
        RSB     R3, R3, #32
        SetLsl  R2, R3
        STR     R2, [R10], #4
        ASSERT (trnslp_setpx_size = 4)
        ; Assemble mask word
d2152 1
a2152 1
        ; If in GCOL 0-7,9,11,13, then assume the mask is whole sprite
d2157 1
a2157 9
        ; CC if GCOL 0-7,9,11,13 (or no mask, in which case GCOL is in range 0-7)


        ; CC if no mask / CS has a mask so attempt to assemble in the function
        ; which is correct for this depth, for 1,2,4 or 8 bit per pixel we can
        ; simply compile in the ORR with a suitable mask, for 16 or 24 bit per pixel
        ; we need to faff around and generate a new workspace word which
        ; contains the correctmask.

d2159 17
a2175 1
        BCS     trns_compile_mask
d2177 1
a2177 9
        CMP     R1, #4                          ; is the depth sensible?
        ADRCCL  R2, trnslp_sprnomask_o1
        ADDCC   R2, R2, R1,LSL#2
        TrnsAsmReg R2, trnslp_sprnomask_size,CC
        ADRCSL  R2, trnslp_sprnomask16or24
        TrnsAsmReg R2, trnslp_sprnomask16or24_size,CS
        B       trns_compile_nomask

        ; Sprite has mask and it is used (GCOL 8,10,12,14,15)
d2181 2
a2182 2
        MOVS    R2, R11, LSR #mcb_sprtype
        BEQ     trns_old_mask
d2184 2
a2185 2
        TrnsAsm trnslp_new_sprmask, trnslp_new_sprmask_size
        TrnsAsm trnslp_new_sprmask2, trnslp_new_sprmask2_size
d2187 1
a2187 1
        B       trns_any_mask
d2190 1
a2190 1
        TrnsAsm trnslp_sprmask, trnslp_sprmask_size
d2192 7
a2198 7
        ; Compile reading of mask pixel (4,5,5,1 instructions - each input store 5 instructions)
        ADRL    R2, trnslp_readpx_i1
        ADD     R2, R2, R0, LSL#4
        ADD     R2, R2, R0, LSL#2
        TrnsAsmReg R2, trnslp_readpx_size
        BL      trnslp_chopexcess
        ASSERT trnslp_readpx_size = 5*4
d2200 2
a2201 2
        TEQ     R0,R1                   ;Check for 1:1 mapping?
        BEQ     trns_compile_mask1to1
d2203 1
a2203 1
        ; Copy mask byte into output mask, first check for non-zero then orr in special case
d2205 8
a2212 8
        CMP     R1,#4
        ADRCCL  R2,trnslp_setmask_o1
        ADDCC   R2,R2,R1,LSL #3         ;Each section is 8 bytes (2 words)
        TrnsAsmReg R2,trnslp_setmask_size,CC
        ASSERT trnslp_setmask_size = 2*4
        ADRCSL  R2,trnslp_setmask16or24
        TrnsAsmReg R2,trnslp_setmask16or24_size,CS
        B       trns_compile_nomask
d2214 1
a2214 1
        ; Copy pixel into output pixel word (ORR out_mask, out_mask, mask_pixel,LSL#32-out_bpp)
d2218 7
a2224 7
        LDR     R2, trnslp_setmask2
        MOV     R3, #1
        MOV     R3, R3, LSL R1
        RSB     R3, R3, #32
        SetLsl  R2, R3
        STR     R2, [R10], #4
        ASSERT (trnslp_setmask2_size = 4)
d2227 11
a2237 11
        ; Compile code to read the screen word
      [ AvoidScreenReads
        ; If action code 0 (solid), use alternate code that avoids a load if the
        ; mask is solid.
        ANDS    R2, R11, #7
        TrnsAsm trnslp_readscrn0, trnslp_readscrn0_size, EQ
        TrnsAsm trnslp_readscrn,  trnslp_readscrn_size,  NE
      |
        TrnsAsm trnslp_readscrn, trnslp_readscrn_size
      ]
        ; Test for plotting mask - if so compile ECF code, else GCOL code
d2240 11
a2250 11
        ; Store the GCOL action code (2,1,2,1,1,0,1,2 instructions, stored as 2 instructions in input)
        ADRL    R3, trnslp_gcol
        ANDS    R2, R11, #7
        ADD     R3, R3, R2,LSL#3
        TrnsAsmReg R3, trnslp_gcol_size
        CMPNE   R2, #2
        CMPNE   R2, #7
        SUBNE   R10, R10, #4
        CMP     R2, #5
        SUBEQ   R10, R10, #4
        ASSERT trnslp_gcol_size = 2*4
d2252 1
a2252 1
        ; Handle the mask and ECF
d2254 2
a2255 2
        TrnsAsm trnslp_plotmask, trnslp_plotmask_size
        ; Store the end of loop code
d2257 18
a2274 18
        TrnsAsm trnslp_eoloop, trnslp_eoloop_size
        Pull    "R2"
        TrnsBranch R2, BGE
        ; Store the code for storing the last word
        TrnsAsm trnslp_lastword, trnslp_lastword_size
        ; loop
        Push    "R10"
        ; Shift pixel and mask words by output bpp (2 instructions)
        ADRL    R2, trnslp_shfwam_o1
        ADD     R2, R2, R1, LSL#3
        TrnsAsmReg R2, trnslp_shfwam_size
        ASSERT trnslp_shfwam_size = 2*4
        ; Loop until words are aligned
        Pull    "R2"
        TrnsBranch R2, BCC
        ; Compile code to read the screen word
        TrnsAsm trnslp_readscrn, trnslp_readscrn_size
        ; Test for plotting mask - if so compile ECF code, else GCOL code
d2277 11
a2287 11
        ; Store the GCOL action code (2,1,2,1,1,0,1,2 instructions, stored as 2 instructions in input)
        ADRL    R3, trnslp_gcol
        ANDS    R2, R11, #7
        ADD     R3, R3, R2,LSL#3
        TrnsAsmReg R3, trnslp_gcol_size
        CMPNE   R2, #2
        CMPNE   R2, #7
        SUBNE   R10, R10, #4
        CMP     R2, #5
        SUBEQ   R10, R10, #4
        ASSERT trnslp_gcol_size = 2*4
d2289 1
a2289 1
        ; Handle the mask and ECF
d2291 2
a2292 2
        TrnsAsm trnslp_plotmask, trnslp_plotmask_size
        ; Compile code to store the word and exit
d2294 2
a2295 2
        TrnsAsm trnslp_lastword2, trnslp_lastword2_size
        ; Code compiled.
d2297 6
a2302 6
        Push    "r0-r2"
        MOV     r2, r10
        LDR     r1, trns_codebuffer
        MOV     r0, #1
        SWI     XOS_SynchroniseCodeAreas
        Pull    "r0-r2"
d2308 11
a2318 11
        ; this routine reduces the various readpx_i segments down to the real
        ; size rather than five words
        TEQ     R0, #0
        SUBEQ   R10, R10, #4
        TEQ     R0, #3
        SUBEQ   R10, R10, #16
        TEQ     R0, #4
        SUBEQ   R10, R10, #4
        TEQ     R0, #5
        SUBEQ   R10, R10, #16
        MOV     PC,LR
d2334 2
a2335 2
        ; Get sprite offsets for left of current y line
        ; First get dummy11 = scr_lx - x(0)
d2337 2
a2338 2
        ; Debug tr,"X,Y(x0,y0), incXx, incYy",trns_X_x0_y,trns_Y_x0_y,trns_inc_X_x,trns_inc_Y_x
        ; Debug tr,"coords:",trns_scr_lx, trns_scr_rx,trns_scr_y,trns_dummy11
d2341 1
a2341 1
        ; X = ((screen_lx%-x(0)) * (inc_X_x)) + X_x0_y
d2343 1
a2343 1
        ; Y = ((screen_lx%-x(0)) * (spr_inc_Y_x)) + Y_x0_y
d2345 1
a2345 1
        ; Get the x posn and x size for the plot
d2348 1
a2348 1
        ; Load the compile routine registers - HERE
d2352 1
a2352 1
        ; Plot the row (call compiled code)
@


4.11.2.2
log
@Sync with trunk
Sources/SprOp - revision 4.10 copied
Sources/SprTrans - revision 4.16 copied
Sources/jdhuff - revision 4.7 copied
Also:
 DCI changed to instruction mnemonic for objasm 4
 Makefile excess '-c' removed
 Util.mk double inclusion of rules removed

Version 1.38, 1.35.2.16. Tagged as 'SprExtend-1_38-1_35_2_16'
@
text
@a135 1
      [ ldmreg>1
a137 4
      |
$l      LDR$cc  R4,[$reg]
        STR$cc  R4, [R10], #4
      ]
d526 2
a527 1

d530 2
a531 3
        MOV     R1, R0, ASL R11         ; R1 = R0 scaled x
        MOV     R9, R9, ASL R11         ; R9 = R9 scaled x

d534 4
a537 6
        MOV     R8, R8, ASL R11         ; R8 = R8 scaled y
        MOV     R3, R14, ASL R11        ; R3 = R14 scaled y

        SUB     sp, sp, #64             ; Space for a path block
        MOV     R10, SP

d539 4
a542 4
        MOV     R0, #2
        STMIA   R10!, {R0,R1,R8}        ; Move R1, R8.
        STMIA   R10!, {R0,R9}           ; Move R9,
        STMIA   R10!, {R8,R11}          ; R8. Move
d544 2
a545 1
        STMIA   R10!, {R1,R3,R11}       ; R1, R3. End.
d547 1
a547 1
; Transform the path
d549 1
a549 1
        MOV     R0, SP
d554 1
a554 1
        ADDVS   sp, sp, #64+4
d558 3
a560 1
        ADD     R10, SP, #4             ; Get the transformed path (skipping 'Move')
d562 1
a569 2

; Recover R6
d1918 1
a1918 1
        Pull    "PC",EQ
d1925 1
a1925 1
        Pull    "PC"
@


4.10
log
@A few small fixes.
Sources/PutScaled:
 Sync comment with C code.
Sources/SprExtend:
 Debug switch 'debuggs' had been left on, which left in some unnecessary code, but turning it off pulled in code with a stack imbalance. Now off.
 Ensured a terminator at the end of the RMEnsure.
 Colour translation tables passed to SetPointerShape that were in top bit set addresses were being interpreted as though no tt was supplied. Now tested against zero to match docs.
Sources/SprTrans:
 Switches pre 0.60 collapsed.
Sources/diffuse:
 The C code was corrupting r12 workspace pointer so the check of the flag 'ctrans_recent' sometimes failed leading to a duff table lookup.
 Small optimisation to checking of guard word.
c/PutScaled:
 Change paths to be Unix friendly.
rojpeg:
 Put assembler_panic in the header file to shut the compiler up.
3x unused files deleted.

Version 1.23. Tagged as 'SprExtend-1_23'
@
text
@d15 1
@


4.9
log
@Performance improvement and code tidy-up.

Removed local definition of XOS_CLI and XColourTrans_SelectTable, replaced
with header file.

Delete swiv2_old (moved to _old directory)

Changed to use {TRUE} and {FALSE} built in objasm variables.

Label dividebyzero fall through had code in the way for debug = {TRUE}.

Trimmed some dead code and definitions.

Stopped thrashing OS_CLI every time a JPEG plot is required to check
ColourTrans version, this is now done once at startup and a flag kept
instead.

Author: Rob Sprowson

Version 1.19. Tagged as 'SprExtend-1_19'
@
text
@a37 1
                              [ Module_Version >= 047
a41 1
                              ]
a409 1
      [ Module_Version >= 047
a414 4
      |
        LDR     R0, [R1, #spLBit]
        MOV     R0, R0, ASR R2
      ]
d638 1
a638 2
;
      [ Module_Version >= 047
a644 2
      ]
;
a1435 1
        [ Module_Version >= 050
a1438 1
        ]
a1669 1
      [ Module_Version >= 047
a1680 4
      |
trnslp_shfwam_size      *       .-trnslp_shfwam_o8
        ASSERT (.-trnslp_shfwam_o1) = trnslp_shfwam_size*4
      ]
a1777 1
      [ Module_Version >= 047
a1782 1
      ]
a1821 1
      [ Module_Version >= 047
a1827 1
      ]
a2073 2
      [ Module_Version >= 047

a2138 3
      |
                TrnsAsm         trnslp_transpx, trnslp_transpx_size, NE
      ]
a2199 1
              [ Module_Version >= 047
a2211 7
              |
                ADRNE           R2,trnslp_setmask_o1
                ADDNE           R2,R2,R1,LSL #3         ;Each section is 8 bytes (2 words)
                TrnsAsmReg      R2,trnslp_setmask_size,NE
                ASSERT trnslp_setmask_size = 2*4
                BNE             trns_compile_nomask
              ]
@


4.8
log
@* Transformed sprite plotting did not use the translation table if its
  address had the top bit set.
* Transformed sprite plotting optimised to not read the screen memory when
  it could be simply avoided - greatly enhances performance on Iyonix.
* Decoding of 1x2 sampled JPEGs fixed.

Version 1.14. Tagged as 'SprExtend-1_14'
@
text
@a14 2
                        GBLL    AvoidScreenReads
AvoidScreenReads        SETL    {TRUE}
@


4.7
log
@New version from Kevin: OS_SpriteOp 55 and 56 can take top-bit-set
translation table pointers, at the expense of the condition for no
translation table being tightened to either 0 or -1 (previously documented
as <= 0). This is the version included in release 5.00 of the OS.

Version 1.12. Tagged as 'SprExtend-1_12'
@
text
@d15 3
d1865 8
d1992 1
a1992 1
        ORRGT   R11,R11,#mc_ttr
d2263 7
d2271 1
@


4.6
log
@A couple of 32-bit fixes.
Used to interpret negative translation table pointers as "none"; now just 0
as per documentation.
Plotting 16bpp sprites into 32bpp modes now correctly sets the 3 least
significant bits of each channel - used to be set to 0 due to a typo.
Build option (currently set to on) to use SMULL instructions.

Version 1.11. Tagged as 'SprExtend-1_11'
@
text
@d331 2
a332 2
        CMP     R7,#0
        MOVLES  R7,#0                   ; 0 ==> no translation
d1571 1
a1571 1
        STMFD   sp!, {R14}
d1575 1
a1575 1
        LDMLEFD sp!, {PC}
@


4.5
log
@  Now uses objasm throughout instead of aasm.
Detail:
  The build structure for this module is not nice - I've sanitised it a
    bit, but it's still not nice.
Admin:
   Built and tested with the test program briefly - the test sprite seems
     to scale and rotate properly.  ChangeFSI not tested.


Version 1.08. Tagged as 'SprExtend-1_08'
@
text
@d166 26
d769 1
a769 2
        BL      arith_SSmultD
        DCB     R0,R1,R4,0
d775 1
a775 2
        BL      arith_SSmultD
        DCB     R0,R1,R6,0
d1087 1
a1087 2
        BL      arith_SSmultD
        DCB     R0,R4,R4,0              ;subpixelX * ABS(deltaY) into R4,R5
d1094 1
a1094 2
        BL      arith_SSmultD
        DCB     R0,R3,R4,0
d1465 1
a1465 2
        BL      arith_SSmultD
        DCB     R8,R3,R1,0              ;(no. Y steps) * deltaX into R1,R2
d1472 1
a1472 2
        BL      arith_SSmultD
        DCB     R8,R4,R1,0              ;(no. X steps) * deltaY into R1,R2
d1493 1
d1529 1
@


4.4
log
@  Removal of empty debug loop.
  Addition of srccommit files.
Detail:
  * c.jrdjfif, get_dqt had an empty debug loop when debug was disabled.
    This is no longer compiled when debugging is not enabled.
  * VersionNum and VersionASM files added, and Sources.SprExtend modified
    to use symbols exported from there rather than from Version.
Admin:
  Ran on my machine. Previously tested in ROL builds.
  In future, might like to merge Exif support from ROL builds, but don't
  want to do that until I've re-read the specs on Exif format again.

Version 1.07. Tagged as 'SprExtend-1_07'
@
text
@d1481 3
a1483 9
        Push    "R0-R8"
        [ No32bitCode
        MOV     R0, #0
        ]
        mrs    ,R0,CPSR
        TST     R0,#2_11100
        BICEQ   R8,R14,#&FC000003
        MOVNE   R8,R14
        LDRB    R0,[R8]                 ;Get first operand
d1485 1
a1485 1
        LDRB    R1,[R8,#1]              ;Get second operand
d1503 1
a1503 1
        LDRB    R0,[R8,#2]              ;Store the result on the stack, to be
d1507 1
a1507 1
        ADD     PC,R14,#4               ;Skip the argument word on return
d1521 2
a1522 8
        [ No32bitCode
        MOV     R0, #0
        ]
        mrs    ,R0,CPSR
        TST     R0,#2_11100
        BICEQ   R8,R14,#&FC000003
        MOVNE   R8,R14
        LDRB    R0,[R8]                 ;Get first operand
d1525 1
a1525 1
        LDRB    R2,[R8,#1]              ;Get second operand
d1536 1
a1536 1
        LDRB    R0,[R8,#2]              ;Store the result on the stack, to be
d1539 1
a1539 1
        ADD     PC,R14,#4               ;Skip the argument word on return
@


4.3
log
@32-bit compatible. Tagged as SprExtend-1_06
@
text
@d37 1
a37 1
                              [ Version >= 047
d385 1
a385 1
      [ Version >= 047
d619 1
a619 1
      [ Version >= 047
d1423 1
a1423 1
        [ Version >= 050
d1671 1
a1671 1
      [ Version >= 047
d1784 1
a1784 1
      [ Version >= 047
d1830 1
a1830 1
      [ Version >= 047
d2076 1
a2076 1
      [ Version >= 047
d2207 1
a2207 1
              [ Version >= 047
@


4.2
log
@Version RO_3_70 taken
@
text
@d1109 4
a1112 3
        SUBGES  R8,R8,R1                ;Must set GT or EQ
        BLGT    out_qfill_fastclip      ;Preserves flags
        CMPGE   R6,#0                   ;So this can only happen if R1 >= R2
d1117 1
d1163 1
a1163 1
        CMP     R4,R6,ASR #3            ;Use fast code?
d1317 2
a1318 1
        Pull    "R1-R9,PC",,^
d1431 1
a1431 1
        Pull    "R0-R3,R5-R12,PC",,^
d1456 1
a1456 1
        Pull    "R1,R2,R7"
d1460 1
a1460 1
        Pull    "PC",,^
d1471 1
a1471 1
        MOVS    PC,LR
d1482 7
a1488 1
        BIC     R8,R14,#&FC000003
d1527 7
a1533 1
        BIC     R8,R14,#&FC000003
d1565 1
a1565 1
        LDMLEFD sp!, {PC}^
d1906 1
a1906 1
        LDMEQFD sp!, {PC}^
d1913 1
a1913 1
        LDMFD   sp!, {PC}^
d2339 1
a2339 1
        Pull    "PC",GE,^
@


4.1
log
@Initial revision
@
text
@d43 1
a43 1
trns_spr_vars_end               *       :INDEX:@@                                       
d55 1
a55 1
;   Offset 20 : Current X coordinate of the point (in pixels)        
d113 1
a113 1
        LDM$cc.IA R4,{R4-R$ldmreg2}  
d131 2
a132 2
  
        
d139 1
a139 1
        ORR     $reg,$reg,#$op   
d188 1
a188 1
        
d197 1
a197 1
        MOV     R5,#8                                   
d209 1
a209 1
        
d212 1
a212 1
        STR     R14, trns_flags2 
d223 1
a223 1
        
d235 1
a235 1
 
d247 1
a247 1
                               
d265 1
a265 1
        
d275 1
a275 1
                                                          
d278 1
a278 1
        
d280 2
a281 2
        LDR     R14, trns_flags2 
        TST     R14, #flg2_ignorettr 
d283 1
a283 1
;        [       med01867 
d286 1
a286 1
;        ] 
d288 1
a288 1
01          
d290 1
a290 1
;        [       med01867 
d293 1
a293 1
;        ]            
d302 1
a302 1
                  
d304 1
a304 1
                
d309 1
a309 1
;                              
d316 1
a316 1
        CMP     R14, #16  
d319 1
a319 1
        BCC     %FT45  
d321 1
a321 1
        CMP     R14, #16         
d360 1
a360 1
trns_notrans          
d377 1
a377 1
; Get coordinate block        
d405 1
a405 1
01                   
d410 1
a410 1
                
d413 1
a413 1
        TST     R3, #flg_matrix                         
d511 1
a511 1
        MOV     R2, R6 
d540 1
a540 1
        SUB     R14, R2, R14                  
d555 1
a555 1
        ORRGT   R10, R9, R2, LSL#16                                
d568 1
a568 1
        Debug   ag,"spWidth is",R10 
d571 1
a571 1
        LSL     R10, 2                            
d574 2
a575 2
        STR     R11, trns_comp_spr_start      
        
d577 2
a578 2
; for now we just save the R4 value and deal with it once we have the mask 
; equivalent of spWidth computed for the mask        
d583 2
a584 2
                               
        LDR     R4, save_inlog2bpp   
d586 3
a588 3
        BCC     %FT89   
        
        SUB     R4, R4, #3      
d592 1
a592 1
89        
d596 1
a596 1
88                              
d623 2
a624 2
        MOV     R11, R11, ASR R10   
        STR     R11, trns_masking_word                  ; suitable mask for pixels 
d626 1
a626 1
      ] 
d630 1
a630 1
        LDR     R11, [R1, #spImage]   
d640 1
a640 1
        CMP     R4, #4   
d644 1
a644 1
        MOVCS   R11, R11, LSR R4            
d647 1
a647 1
        
d654 2
a655 2
        
        STR     R11, trns_comp_spr_masko  
d661 2
a662 2
        Debug   tr,"Height/right, left, spr_start, spr_byte_width",#trns_comp_spr_height,#trns_comp_spr_left,#trns_comp_spr_start,#trns_comp_spr_byte_width                  
                    
d689 1
a689 1
; x coords          
d730 1
a730 1
; Get determinant   
d739 1
a739 1
; R4,5 = x1 * y2       
d742 1
a742 1
        MOV     R1, R12         
d746 1
a746 1
; R6,7 = x2 * y1     
d756 1
a756 1
        SBC     R5, R5, R7  
d778 1
a778 1
trns_division_by_zero            
d811 1
a811 1
        MOV     R9, R4               
d873 1
a873 1
; inc_X_y = R8.R9      
d891 1
a891 1
        ADD     R0, R0, R11,LSL#24 
d895 1
a895 1
; inc_Y_y = R8.R9      
d913 1
a913 1
        STR     R2, trns_spr_Y_x0_y                        
d956 1
a956 1
; Edge 3->2               
d963 1
a963 1
        STMLEIA R0!,{R4,R8}            
d975 1
a975 1
        LDR     R1, save_ycoord     
d994 1
a994 1
        BEQ     activated_all_edges     
d1004 1
a1004 1
        BNE     edge_active     
d1006 1
a1006 1
; Test for activation   
d1010 1
a1010 1
        BGT     edge_inactive          
d1012 1
a1012 1
; Activate an edge  
d1014 1
a1014 1
        SUB     R8, R8, #128     
d1052 1
a1052 1
; R7=-1,C=1 for leftward lines, R7=0,C=0 for rightward lines. 
d1081 1
a1081 1
        B       out_qfill_bresdone                       
d1087 1
a1087 1
; R6=-1,C=1 for leftward lines, R6=0,C=0 for rightward lines. 
d1123 1
a1123 1
edge_active                  
d1131 1
a1131 1
edge_inactive               
d1135 1
a1135 1
activated_all_edges         
d1146 1
a1146 1
                                     
d1191 1
a1191 1
01                              
d1196 1
a1196 1
        BEQ     %BT01    
d1295 1
a1295 1
        SUB     R7, R7, R8  
d1316 1
a1316 1
                            
d1330 1
a1330 1
; First split R6/7 into R4-R7  
d1371 1
a1371 1
        ADC     R6, R6, #0               
d1434 1
a1434 1
; -----------------------------------             
d1553 1
a1553 1
                        
d1579 1
a1579 1
        AND     trns_out_x, trns_out_x, #16          
d1584 1
a1584 1
        AND     trns_out_x, trns_out_x, #0           
d1587 1
a1587 1
                         
d1662 1
a1662 1
        ;MOV     trns_out_mask, trns_out_mask       
d1665 1
a1665 1
        MOVS     trns_out_word,trns_out_word,LSR #1 
d1671 2
a1672 2
      ]         
                                                
d1683 1
a1683 1
        AND     trns_dummy14, trns_dummy14, #&1                         ;(&FF.&F.&3.&1 - 8.4.2.1 in_bpp)                                  
d1704 1
a1704 1
trnslp_readpx_i16       
d1719 1
a1719 1
                                                                
d1741 1
a1741 1
trnslp_use32K                     
d1746 1
a1746 1
       LDR      trns_dummy12,[trns_dummy12,#4]             
d1749 1
a1749 1
trnslp_use32K_size      *      .-trnslp_use32K 
d1787 1
a1787 1
trnslp_new_sprmask                          
d1793 1
a1793 1
trnslp_new_sprmask2                          
d1814 1
a1814 1
       
d1829 1
a1829 1
                                                                           
d1836 1
a1836 1
                                            
d1865 1
a1865 1
                                                                     
d1867 1
a1867 1
trnslp_plotmask              
d1876 1
a1876 1
                               
d1887 1
a1887 1
                                                                         
d1894 1
a1894 1
                       
d1902 1
a1902 1
trnslp_munge_16to321    
d1920 1
a1920 1
trnslp_munge_16to323    
d1924 1
a1924 1
        Pull    "R0,R2"                   
d1943 1
a1943 1
                  
d1974 1
a1974 1
; Test with old compiled routine            
d1979 1
a1979 1
        STR     R11,macroword          
d1984 1
a1984 1
        ADR     R10, codebuffer                
d1997 2
a1998 2
                Push            "R10"      
                                                 
d2025 1
a2025 1
                BNE     trns_compile_plotmask                    
d2034 1
a2034 1
                               
d2040 1
a2040 1
        
d2042 1
a2042 1
        BEQ     %FT07  
d2061 1
a2061 1
      [ Version >= 047     
d2063 1
a2063 1
        BEQ     %FT01  
d2065 1
a2065 1
;if inbpp and outbpp are both >8bpp ignore the translation table  
d2070 1
a2070 1
09                     
d2074 1
a2074 1
        
d2079 1
a2079 1
        BCC     %FT07         ;input depth is <16bpp so skip this 
d2090 1
a2090 1
        TrnsAsmReg R2, trnslp_use32K_size  
d2093 3
a2095 3
         
; First check to see if the output depth is greater than 8 bit per pixel, 
; if it is then compile in the new translation functions which use 
d2097 2
a2098 2
                                
                [ ignore_ttr                 
d2110 1
a2110 1
                CMP             R1,#5    
d2117 1
a2117 1
                CMP             R1,#4  
d2123 1
a2123 1
                CMP             R1,#4  
d2130 1
a2130 1
      ]    
d2142 1
a2142 1
trns_compile_plotmask                                 
d2147 1
a2147 1
        MOVS    R3, R3, LSR R2          ;       Move bit (R2-1) of R3 into the carry flag    
d2177 1
a2177 1
                                                                  
d2193 1
a2193 1
                BEQ             trns_compile_mask1to1          
d2196 1
a2196 1
                                         
d2211 1
a2211 1
              ]               
d2222 1
a2222 1
                STR             R2, [R10], #4    
d2240 1
a2240 1
                SUBEQ           R10, R10, #4  
d2246 1
a2246 1
;      Store the end of loop code 
d2260 1
a2260 1
;      Loop until words are aligned         
d2277 1
a2277 1
                SUBEQ           R10, R10, #4  
d2288 7
d2300 1
a2300 1
;size rather than five words                
d2304 1
a2304 1
        SUBEQ           R10, R10, #16  
d2308 1
a2308 1
        SUBEQ           R10, R10, #16  
d2327 1
a2327 1
        LDR     trns_dummy11, trns_spr_xcoords + calc_row_stacked          
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d43 1
a43 1
trns_spr_vars_end               *       :INDEX:@@
d55 1
a55 1
;   Offset 20 : Current X coordinate of the point (in pixels)
d113 1
a113 1
        LDM$cc.IA R4,{R4-R$ldmreg2}
d131 2
a132 2


d139 1
a139 1
        ORR     $reg,$reg,#$op
d188 1
a188 1

d197 1
a197 1
        MOV     R5,#8
d209 1
a209 1

d212 1
a212 1
        STR     R14, trns_flags2
d223 1
a223 1

d235 1
a235 1

d247 1
a247 1

d265 1
a265 1

d275 1
a275 1

d278 1
a278 1

d280 2
a281 2
        LDR     R14, trns_flags2
        TST     R14, #flg2_ignorettr
d283 1
a283 1
;        [       med01867
d286 1
a286 1
;        ]
d288 1
a288 1
01
d290 1
a290 1
;        [       med01867
d293 1
a293 1
;        ]
d302 1
a302 1

d304 1
a304 1

d309 1
a309 1
;
d316 1
a316 1
        CMP     R14, #16
d319 1
a319 1
        BCC     %FT45
d321 1
a321 1
        CMP     R14, #16
d360 1
a360 1
trns_notrans
d377 1
a377 1
; Get coordinate block
d405 1
a405 1
01
d410 1
a410 1

d413 1
a413 1
        TST     R3, #flg_matrix
d511 1
a511 1
        MOV     R2, R6
d540 1
a540 1
        SUB     R14, R2, R14
d555 1
a555 1
        ORRGT   R10, R9, R2, LSL#16
d568 1
a568 1
        Debug   ag,"spWidth is",R10
d571 1
a571 1
        LSL     R10, 2
d574 2
a575 2
        STR     R11, trns_comp_spr_start

d577 2
a578 2
; for now we just save the R4 value and deal with it once we have the mask
; equivalent of spWidth computed for the mask
d583 2
a584 2

        LDR     R4, save_inlog2bpp
d586 3
a588 3
        BCC     %FT89

        SUB     R4, R4, #3
d592 1
a592 1
89
d596 1
a596 1
88
d623 2
a624 2
        MOV     R11, R11, ASR R10
        STR     R11, trns_masking_word                  ; suitable mask for pixels
d626 1
a626 1
      ]
d630 1
a630 1
        LDR     R11, [R1, #spImage]
d640 1
a640 1
        CMP     R4, #4
d644 1
a644 1
        MOVCS   R11, R11, LSR R4
d647 1
a647 1

d654 2
a655 2

        STR     R11, trns_comp_spr_masko
d661 2
a662 2
        Debug   tr,"Height/right, left, spr_start, spr_byte_width",#trns_comp_spr_height,#trns_comp_spr_left,#trns_comp_spr_start,#trns_comp_spr_byte_width

d689 1
a689 1
; x coords
d730 1
a730 1
; Get determinant
d739 1
a739 1
; R4,5 = x1 * y2
d742 1
a742 1
        MOV     R1, R12
d746 1
a746 1
; R6,7 = x2 * y1
d756 1
a756 1
        SBC     R5, R5, R7
d778 1
a778 1
trns_division_by_zero
d811 1
a811 1
        MOV     R9, R4
d873 1
a873 1
; inc_X_y = R8.R9
d891 1
a891 1
        ADD     R0, R0, R11,LSL#24
d895 1
a895 1
; inc_Y_y = R8.R9
d913 1
a913 1
        STR     R2, trns_spr_Y_x0_y
d956 1
a956 1
; Edge 3->2
d963 1
a963 1
        STMLEIA R0!,{R4,R8}
d975 1
a975 1
        LDR     R1, save_ycoord
d994 1
a994 1
        BEQ     activated_all_edges
d1004 1
a1004 1
        BNE     edge_active
d1006 1
a1006 1
; Test for activation
d1010 1
a1010 1
        BGT     edge_inactive
d1012 1
a1012 1
; Activate an edge
d1014 1
a1014 1
        SUB     R8, R8, #128
d1052 1
a1052 1
; R7=-1,C=1 for leftward lines, R7=0,C=0 for rightward lines.
d1081 1
a1081 1
        B       out_qfill_bresdone
d1087 1
a1087 1
; R6=-1,C=1 for leftward lines, R6=0,C=0 for rightward lines.
d1123 1
a1123 1
edge_active
d1131 1
a1131 1
edge_inactive
d1135 1
a1135 1
activated_all_edges
d1146 1
a1146 1

d1191 1
a1191 1
01
d1196 1
a1196 1
        BEQ     %BT01
d1295 1
a1295 1
        SUB     R7, R7, R8
d1316 1
a1316 1

d1330 1
a1330 1
; First split R6/7 into R4-R7
d1371 1
a1371 1
        ADC     R6, R6, #0
d1434 1
a1434 1
; -----------------------------------
d1553 1
a1553 1

d1579 1
a1579 1
        AND     trns_out_x, trns_out_x, #16
d1584 1
a1584 1
        AND     trns_out_x, trns_out_x, #0
d1587 1
a1587 1

d1662 1
a1662 1
        ;MOV     trns_out_mask, trns_out_mask
d1665 1
a1665 1
        MOVS     trns_out_word,trns_out_word,LSR #1
d1671 2
a1672 2
      ]

d1683 1
a1683 1
        AND     trns_dummy14, trns_dummy14, #&1                         ;(&FF.&F.&3.&1 - 8.4.2.1 in_bpp)
d1704 1
a1704 1
trnslp_readpx_i16
d1719 1
a1719 1

d1741 1
a1741 1
trnslp_use32K
d1746 1
a1746 1
       LDR      trns_dummy12,[trns_dummy12,#4]
d1749 1
a1749 1
trnslp_use32K_size      *      .-trnslp_use32K
d1787 1
a1787 1
trnslp_new_sprmask
d1793 1
a1793 1
trnslp_new_sprmask2
d1814 1
a1814 1

d1829 1
a1829 1

d1836 1
a1836 1

d1865 1
a1865 1

d1867 1
a1867 1
trnslp_plotmask
d1876 1
a1876 1

d1887 1
a1887 1

d1894 1
a1894 1

d1902 1
a1902 1
trnslp_munge_16to321
d1920 1
a1920 1
trnslp_munge_16to323
d1924 1
a1924 1
        Pull    "R0,R2"
d1943 1
a1943 1

d1974 1
a1974 1
; Test with old compiled routine
d1979 1
a1979 1
        STR     R11,macroword
d1984 1
a1984 1
        ADR     R10, codebuffer
d1997 2
a1998 2
                Push            "R10"

d2025 1
a2025 1
                BNE     trns_compile_plotmask
d2034 1
a2034 1

d2040 1
a2040 1

d2042 1
a2042 1
        BEQ     %FT07
d2061 1
a2061 1
      [ Version >= 047
d2063 1
a2063 1
        BEQ     %FT01
d2065 1
a2065 1
;if inbpp and outbpp are both >8bpp ignore the translation table
d2070 1
a2070 1
09
d2074 1
a2074 1

d2079 1
a2079 1
        BCC     %FT07         ;input depth is <16bpp so skip this
d2090 1
a2090 1
        TrnsAsmReg R2, trnslp_use32K_size
d2093 3
a2095 3

; First check to see if the output depth is greater than 8 bit per pixel,
; if it is then compile in the new translation functions which use
d2097 2
a2098 2

                [ ignore_ttr
d2110 1
a2110 1
                CMP             R1,#5
d2117 1
a2117 1
                CMP             R1,#4
d2123 1
a2123 1
                CMP             R1,#4
d2130 1
a2130 1
      ]
d2142 1
a2142 1
trns_compile_plotmask
d2147 1
a2147 1
        MOVS    R3, R3, LSR R2          ;       Move bit (R2-1) of R3 into the carry flag
d2177 1
a2177 1

d2193 1
a2193 1
                BEQ             trns_compile_mask1to1
d2196 1
a2196 1

d2211 1
a2211 1
              ]
d2222 1
a2222 1
                STR             R2, [R10], #4
d2240 1
a2240 1
                SUBEQ           R10, R10, #4
d2246 1
a2246 1
;      Store the end of loop code
d2260 1
a2260 1
;      Loop until words are aligned
d2277 1
a2277 1
                SUBEQ           R10, R10, #4
a2287 7
	Push	"r0-r2"
	MOV	r2, r10
	LDR	r1, trns_codebuffer
	MOV	r0, #1
	SWI	XOS_SynchroniseCodeAreas
	Pull	"r0-r2"

d2293 1
a2293 1
;size rather than five words
d2297 1
a2297 1
        SUBEQ           R10, R10, #16
d2301 1
a2301 1
        SUBEQ           R10, R10, #16
d2320 1
a2320 1
        LDR     trns_dummy11, trns_spr_xcoords + calc_row_stacked
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

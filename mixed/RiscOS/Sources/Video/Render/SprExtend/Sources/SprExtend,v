head	4.40;
access;
symbols
	SprExtend-1_83:4.40
	SprExtend-1_82:4.40
	SprExtend-1_81:4.39
	SprExtend-1_80:4.39
	SprExtend-1_79:4.39
	SprExtend-1_78:4.39
	SprExtend-1_77:4.38
	SprExtend-1_76:4.38
	SprExtend-1_75:4.38
	SprExtend-1_74:4.38
	SprExtend-1_73:4.38
	SprExtend-1_72:4.38
	SprExtend-1_71-nocfsi:4.37
	SprExtend-1_71:4.37
	SprExtend-1_70-tracef:4.36
	SprExtend-1_70-headers:4.35
	SprExtend-1_70:4.34
	SprExtend-1_69:4.33
	SprExtend-1_68:4.33
	SprExtend-1_67:4.33
	SprExtend-1_66:4.32
	SprExtend-1_65:4.32
	SprExtend-1_64:4.31
	SprExtend-1_63:4.30
	SprExtend-1_62:4.30
	SprExtend-1_61:4.29
	SprExtend-1_60:4.28
	SprExtend-1_59:4.28
	SprExtend-1_58:4.28
	SprExtend-1_57:4.28
	SprExtend-1_56:4.28
	SprExtend-1_55:4.28
	SprExtend-1_54:4.27
	SprExtend-1_53:4.27
	SprExtend-1_52:4.27
	SprExtend-1_51:4.26
	SprExtend-1_50:4.25
	SprExtend-1_38-1_35_2_16:4.21.2.6
	SprExtend-1_49:4.24
	SprExtend-1_48:4.24
	SprExtend-1_47:4.24
	SprExtend-1_38-1_35_2_15:4.21.2.6
	SprExtend-1_46:4.24
	SprExtend-1_45:4.23
	SprExtend-1_44:4.22
	SprExtend-1_43:4.22
	SprExtend-1_42:4.21
	SprExtend-1_41:4.21
	SprExtend-1_38-1_35_2_14:4.21.2.5
	SprExtend-1_40:4.21
	SprExtend-1_38-1_35_2_13:4.21.2.5
	SprExtend-1_38-1_35_2_12:4.21.2.5
	SprExtend-1_38-1_35_2_11:4.21.2.5
	SprExtend-1_38-1_35_2_10:4.21.2.4
	SprExtend-1_38-1_35_2_9:4.21.2.4
	SprExtend-1_38-1_35_2_8:4.21.2.3
	SprExtend-1_39:4.21
	SprExtend-1_38-1_35_2_7:4.21.2.2
	SprExtend-1_38-1_35_2_6:4.21.2.1
	SprExtend-1_38-1_35_2_5:4.21
	SprExtend-1_38-1_35_2_4:4.21
	SprExtend-1_38-1_35_2_3:4.21
	SprExtend-1_38-1_35_2_2:4.21
	SprExtend-1_38-1_35_2_1:4.21
	MigrateIJG8b:4.21.0.2
	SprExtend-1_38:4.21
	SprExtend-1_37:4.21
	SprExtend-1_36:4.21
	SprExtend-1_35:4.21
	SprExtend-1_34:4.20
	SprExtend-1_33:4.20
	SprExtend-1_32:4.19
	SprExtend-1_31:4.18
	SprExtend-1_30:4.18
	SprExtend-1_29:4.17
	SprExtend-1_28:4.17
	SprExtend-1_27:4.16
	SprExtend-1_26:4.15
	SprExtend-1_25:4.14
	SprExtend-1_24:4.13
	SprExtend-1_23:4.12
	SprExtend-1_22:4.10
	SprExtend-1_21:4.10
	SprExtend-1_20:4.9
	SprExtend-1_19:4.8
	SprExtend-1_18:4.7
	SprExtend-1_17:4.7
	RO_5_07:4.7
	SprExtend-1_16:4.7
	SprExtend-1_15:4.7
	SprExtend-1_14:4.7
	SprExtend-1_13:4.7
	SprExtend-1_12:4.7
	SprExtend-1_11:4.7
	SprExtend-1_10:4.6
	SprExtend-1_09:4.6
	SprExtend-1_08:4.6
	dellis_autobuild_BaseSW:4.5
	SprExtend-1_07:4.5
	SprExtend-1_06:4.4
	sbrodie_sedwards_16Mar2000:4.3
	dcotton_autobuild_BaseSW:4.6
	SprExtend-1_05:4.3
	Ursula_merge:4.2.2.1
	nturton_SprExtend-1_04:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.1
	Ursula_RiscPC:4.2.2.1.0.2
	nicke_SprExtend-0_99:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2.2.1
	UrsulaBuild_FinalSoftload:4.2.2.1
	rthornb_UrsulaBuild-12Aug1998:4.2.2.1
	aglover_UrsulaBuild-05Aug1998:4.2.2.1
	rthornb_UrsulaBuild-29Jul1998:4.2.2.1
	rthornb_UrsulaBuild-22Jul1998:4.2.2.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.1
	rthornb_UrsulaBuild-07Jul1998:4.2.2.1
	rthornb_UrsulaBuild-17Jun1998:4.2.2.1
	rthornb_UrsulaBuild-03Jun1998:4.2.2.1
	rthornb_UrsulaBuild-27May1998:4.2.2.1
	rthornb_UrsulaBuild-21May1998:4.2.2.1
	rthornb_UrsulaBuild_01May1998:4.2.2.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.40
date	2018.02.11.20.22.26;	author rsprowson;	state Exp;
branches;
next	4.39;
commitid	RLkDTc5eKEj6UtqA;

4.39
date	2016.12.17.18.50.00;	author jlee;	state Exp;
branches;
next	4.38;
commitid	6ZYEX0h1aDsqVmyz;

4.38
date	2016.05.21.14.03.45;	author rool;	state Exp;
branches;
next	4.37;
commitid	4BquZHousteH5m7z;

4.37
date	2016.05.21.13.44.32;	author rool;	state Exp;
branches;
next	4.36;
commitid	ZDqmsyNiMhv6Zl7z;

4.36
date	2016.05.21.13.37.16;	author rool;	state Exp;
branches;
next	4.35;
commitid	TvdqzFBJfCe7Wl7z;

4.35
date	2016.05.21.13.32.17;	author rool;	state Exp;
branches;
next	4.34;
commitid	yTqS85yKh7k8Ul7z;

4.34
date	2016.03.12.10.25.07;	author rool;	state Exp;
branches;
next	4.33;
commitid	cdOKhcORM5Eb8lYy;

4.33
date	2015.09.08.21.53.29;	author jlee;	state Exp;
branches;
next	4.32;
commitid	J8865goQD2q1VuAy;

4.32
date	2015.01.30.08.58.56;	author rsprowson;	state Exp;
branches;
next	4.31;
commitid	THgb9qDlN8jLJ18y;

4.31
date	2015.01.16.00.56.40;	author jlee;	state Exp;
branches;
next	4.30;
commitid	OC6HfJRk5rpfwb6y;

4.30
date	2014.03.09.17.30.36;	author jlee;	state Exp;
branches;
next	4.29;
commitid	kMmPd1A5kacZ43sx;

4.29
date	2014.03.04.20.45.03;	author jlee;	state Exp;
branches;
next	4.28;
commitid	6KWofF44yd1Fjqrx;

4.28
date	2013.10.07.00.39.07;	author jlee;	state Exp;
branches;
next	4.27;
commitid	HcUKy3PafwqToi8x;

4.27
date	2013.08.06.23.16.18;	author jlee;	state Exp;
branches;
next	4.26;
commitid	z9XOph7zDZQ2Ur0x;

4.26
date	2012.08.10.21.21.58;	author rsprowson;	state Exp;
branches;
next	4.25;
commitid	2YHsqEnypOzgS2gw;

4.25
date	2012.07.28.15.23.38;	author rsprowson;	state Exp;
branches;
next	4.24;
commitid	b5jdybqzJ3Wdjlew;

4.24
date	2011.08.05.00.17.43;	author jlee;	state Exp;
branches;
next	4.23;
commitid	M4NYP50KHXLUNfuv;

4.23
date	2011.07.20.08.15.27;	author rsprowson;	state Exp;
branches;
next	4.22;
commitid	Aux2MFhoCLTGXesv;

4.22
date	2011.06.25.23.02.08;	author jlee;	state Exp;
branches;
next	4.21;
commitid	hUTXxU53IjkHF6pv;

4.21
date	2010.11.14.10.42.34;	author rsprowson;	state Exp;
branches
	4.21.2.1;
next	4.20;

4.20
date	2010.10.17.09.01.32;	author rsprowson;	state Exp;
branches;
next	4.19;

4.19
date	2010.10.13.20.26.17;	author rsprowson;	state Exp;
branches;
next	4.18;

4.18
date	2010.09.29.21.05.27;	author rsprowson;	state Exp;
branches;
next	4.17;

4.17
date	2010.09.25.12.19.17;	author rsprowson;	state Exp;
branches;
next	4.16;

4.16
date	2010.09.19.09.11.14;	author rsprowson;	state Exp;
branches;
next	4.15;

4.15
date	2010.09.17.22.15.32;	author rsprowson;	state Exp;
branches;
next	4.14;

4.14
date	2010.09.17.21.07.21;	author rsprowson;	state Exp;
branches;
next	4.13;

4.13
date	2010.09.01.20.48.51;	author rsprowson;	state Exp;
branches;
next	4.12;

4.12
date	2010.08.29.08.36.04;	author rsprowson;	state Exp;
branches;
next	4.11;

4.11
date	2010.08.26.08.58.12;	author rsprowson;	state Exp;
branches;
next	4.10;

4.10
date	2009.06.16.00.41.57;	author bavison;	state Exp;
branches;
next	4.9;

4.9
date	2009.05.10.14.19.07;	author bavison;	state Exp;
branches;
next	4.8;

4.8
date	2009.04.24.00.48.33;	author srevill;	state Exp;
branches;
next	4.7;

4.7
date	2002.11.06.13.20.29;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2001.05.15.10.57.00;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2000.06.27.13.58.01;	author jfletche;	state Exp;
branches;
next	4.4;

4.4
date	2000.05.12.12.59.05;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.08.05.18.03.13;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.17.51.04;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.45.17;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.21.2.1
date	2011.01.09.10.42.55;	author rsprowson;	state Exp;
branches;
next	4.21.2.2;

4.21.2.2
date	2011.01.09.10.56.40;	author rsprowson;	state Exp;
branches;
next	4.21.2.3;

4.21.2.3
date	2011.01.13.21.12.16;	author rsprowson;	state Exp;
branches;
next	4.21.2.4;

4.21.2.4
date	2011.01.22.17.58.26;	author rsprowson;	state Exp;
branches;
next	4.21.2.5;

4.21.2.5
date	2011.01.29.10.03.35;	author rsprowson;	state Exp;
branches;
next	4.21.2.6;

4.21.2.6
date	2011.08.06.10.44.29;	author rsprowson;	state Exp;
branches;
next	;
commitid	gAycmEnWp5AVeruv;

4.2.2.1
date	98.04.03.08.53.58;	author rleggett;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.45.17;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.42.52;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.58.30;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.21.03;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.40
log
@Fixes from static analysis
asmcore.c: fix to align16() function to align as advertised due to operator precedence, and potential buffer overrun of userregs[].
Test/bigtest.c: correct some always false if's and printf() formatters
Ref: https://www.riscosopen.org/forum/forums/4/topics/9503#posts-72595

Unrelated, Sources/SprExtend and Sources/SprOp: use symbolic name for sprite name size.

Version 1.82. Tagged as 'SprExtend-1_82'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.SprExtend

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:VduExt
        GET     Hdr:HighFSI
        GET     Hdr:OsWords
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:NDRDebug
        GET     Hdr:Sprite
        GET     Hdr:ColourTran
        GET     Hdr:PublicWS
        GET     Hdr:Draw         ; needed for transform sprite
        GET     Hdr:ExtraLong    ; needed for transform sprite
        GET     Hdr:MsgTrans
        GET     Hdr:ResourceFS
        GET     Hdr:Proc
        GET     Hdr:HostFS
        GET     Hdr:PDriver
        GET     Hdr:OSRSI6
        GET     Hdr:BlendTable
        GET     Hdr:GraphicsV
        GET     Hdr:OSMisc
        GET     hdr.SprExtend
        GET     VersionASM

        IMPORT  putscaled_compiler
        EXPORT  exit
        EXPORT  exit_erl
        EXPORT  exit_oserror
        
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Switches
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        GBLL    hostvdu
        GBLL    file                    ; where to output the debugging to
hostvdu SETL    {FALSE}
file    SETL    {TRUE}

      [ :LNOT: :DEF: standalone
        GBLL    standalone
standalone      SETL {FALSE}            ; if carrying own messages register them in ResourceFS
      ]

        GBLA    flg2_ignorettr
flg2_ignorettr  SETA 1                  ; R5 is shifted right 4 before storing
        GBLA    flg2_ditheron
flg2_ditheron   SETA 4

        GBLA    flg2_widetrans
flg2_widetrans  SETA 2

        GBLA    flg2_colourmap          ; R5 bit 7: use colour mapping (not supported yet)
flg2_colourmap  SETA 8

        GBLA    flg2_translucency       ; R5 bits 8-15: translucency (0=opaque, 255=1/256 visiblity)
flg2_translucency SETA 255*16        

        GBLL    jpeg                    ; jpeg decompression
jpeg    SETL    {TRUE}

        GBLL    StrongARM               ; be safe about dynamic code
StrongARM SETL  {TRUE}

        GBLL    usemull                 ; faster signed long multiply
usemull SETL    :LNOT: NoARMM

        GBLL    doublepixel_bodge       ; whether to bodge scale factors in double pixel modes. Causes problems with dithering, and probably doesn't work with some scale factors.
doublepixel_bodge SETL {FALSE}

        GBLL    debugmc
        GBLL    debugpt
        GBLL    debugmg
        GBLL    debugid
        GBLL    debugin
        GBLL    debugsc
        GBLL    debugsp
        GBLL    debugso
        GBLL    debugch
        GBLL    debugtr
        GBLL    debuger
        GBLL    debugmb
        GBLL    debugms
        GBLL    debugag
        GBLL    debuggs
        GBLL    debugcc
        GBLL    debugti
debug   SETL    {FALSE}
debugmc SETL    debug :LAND: {FALSE}    ; macro compilation
debugpt SETL    debug :LAND: {FALSE}    ; pointer
debugmg SETL    debug :LAND: {FALSE}    ; 'merge sprites' code
debugid SETL    debug :LAND: {FALSE}    ; insertdelete rows or columns
debugin SETL    debug :LAND: {FALSE}    ; input parameters
debugsc SETL    debug :LAND: {FALSE}    ; screen parameters
debugsp SETL    debug :LAND: {FALSE}    ; sprite parameters
debugso SETL    debug :LAND: {TRUE}     ; sprite operations (non kernel OS_SpriteOp)
debugch SETL    debug :LAND: {FALSE}    ; character painting
debugtr SETL    debug :LAND: {FALSE}    ; transformed plotting
debuger SETL    debug :LAND: {FALSE}    ; error trapping
debugag SETL    debug :LAND: {FALSE}    ; amg transient debugging - could be anywhere :-)
debuggs SETL    debug :LAND: {FALSE}    ; JPEG SWI debugging.
debugcc SETL    debug :LAND: {FALSE}    ; PutSpriteScaled compiler in C
debugti SETL    debug :LAND: {TRUE}     ; TileSpriteScaled

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Module prefix
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        AREA    |!!!ModuleHeader|, CODE, READONLY, PIC

Module_BaseAddr
        ASSERT  (.=Module_BaseAddr)
        DCD     0                                           ; No start
        DCD     Init    - Module_BaseAddr
        DCD     Die     - Module_BaseAddr
        DCD     Service - Module_BaseAddr
        DCD     Title   - Module_BaseAddr
        DCD     Helpstr - Module_BaseAddr
        DCD     0                                           ; Helptable
      [ jpeg
        DCD     SpriteExtendJPEGSWI_Base                    ; MySWIBase
        DCD     SpriteExtend_SWIDecode - Module_BaseAddr    ; MySWIDecode
        DCD     SpriteExtend_SWINames - Module_BaseAddr     ; MySWINames
      |
        DCD     0
        DCD     0
        DCD     0
      ]
        DCD     0
        DCD     0
        DCD     ModFlags - Module_BaseAddr

Title   =       "SpriteExtend",0

Helpstr =       "SpriteExtension",9,"$Module_HelpVersion"
      [ debug
        =       " Development version"
      ]
        =       0
        ALIGN

ModFlags
      [ :LNOT: No32bitCode
        DCD     ModuleFlag_32bit
      |
        DCD     0
      ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Macros
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        ; OSS Macro for Sprite internationalised error blocks. This is because all
        ; the names start with "Sprite_". This adds no useful information to the
        ; string, and just makes the module and the Messages file bigger
        MACRO
$label  MakeSpriteErrorBlock $name, $noalign, $tag
        ALIGN
$label
ErrorBlock_$name
        DCD     ErrorNumber_Sprite_$name
      [ "$tag" = ""
        DCB     "$name"
      |
        DCB     "$tag"
      ]
        DCB     0
      [ "$noalign" = ""
        ALIGN
      ]
        MEND

        MACRO
$label  ALIGNHASH  $o,$m
      [ ((@@-$o):AND:($m-1))<>0
$label  #          $m-((@@-$o):AND:($m-1))
      |
$label  #          0
      ]
        MEND

        MACRO
        Claim   $vector,$entry
        MOV     R0,#$vector
        ADRL    R1,$entry
        MOV     R2,R12
        SWI     XOS_Claim
        MEND

        MACRO
        Release $vector,$entry
        MOV     R0,#$vector
        ADRL    R1,$entry
        MOV     R2,R12
        SWI     XOS_Release
        MEND

        MACRO
$l      CheckAlignedAndWithin $sprite,$offset,$end,$temp,$failure
$l      LDR     $temp, [$sprite, #$offset]
        TST     $temp, #3               ; not word aligned
        BNE     $failure
        ADDS    $temp, $sprite, $temp   ; check for unsigned overflow (C=1)
        CMPCC   $temp, $end
        BHI     $failure                ; out of range
        MEND

        MACRO
$l      CheckAlignedAndSensible $addr,$failure
$l      TST     $addr, #3               ; word aligned?
        BNE     $failure
        CMP     $addr, #area_sensible   ; not too low?
        BLO     $failure
        MEND
        

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Data areas & register allocation
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


; Everything from here down of interest to compiled C
; code. IF THERE ARE ANY CHANGES BELOW THIS POINT then there must be
; matching changes in the C workspace definition.

                ^       0,R12
data            #       0

        ASSERT  (:INDEX:@@)=0
save_outoffset  #       4       ; reloaded from R12
save_inoffset   #       4
save_inptr      #       4
save_outptr     #       4
save_ydiv       #       4
save_yadd       #       4
save_ysize      #       4
save_ycount     #       4

save_inshift    #       4
save_xsize      #       4
save_xcount     #       4
save_ecfptr     #       4
save_ecflimit   #       4
save_xdiv       #       4
save_xadd       #       4

save_masko      #       4
save_xcoord     #       4
save_ycoord     #       4
save_inputxsize #       4
save_inputysize #       4
save_xmag       #       4
save_ymag       #       4

save_inlog2bpp  #       4 ; <- updated by readspritevars, SWIJPEG_PlotScaled
save_inlog2bpc  #       4 ; <- updated by readspritevars, SWIJPEG_PlotScaled
save_inbpp      #       4 ; <- updated by readspritevars, SWIJPEG_PlotScaled
save_inmodeflags #      4 ; <- updated by readspritevars, SWIJPEG_PlotScaled
save_inncolour  #       4 ; <- updated by readspritevars, SWIJPEG_PlotScaled
save_mode       #       4 ; input sprite mode word, only used by putscaled_compiler
save_spr_type   #       4 ; top 5 bits of sprite mode word, a bit useless if RISC OS 5 sprite mode word

save_maskinshift #      4
save_maskinptr  #       4
save_maskinoffset #     4


inmode          #       4 ; <- updated by readspritevars, SWIJPEG_PlotScaled
inlog2px        #       4 ; <- updated by readspritevars, SWIJPEG_PlotScaled
inlog2py        #       4 ; <- updated by readspritevars, SWIJPEG_PlotScaled
ColourTTR       #       4
TTRType         #       4 ; Type of ColourTTR
TTRType_None      *     0
TTRType_Normal    *     1 ; byte lookup table for converting <=8bpp to <=8bpp
TTRType_Wide      *     2 ; wide lookup table for converting <=8bpp to >=16bpp, repacked to be one word per entry
TTRType_32K       *     3 ; 32K-style table for converting >=16bpp to <=8bpp
TTRType_ColourMap *     4 ; Colour mapping descriptor for >=16bpp source
TTRType_Palette   *     5 ; Using the sprite palette
TTRType_Optional  *     8 ; Extra flag: translation is optional, can use palette if we wish 

changedbox      #       4

spritecode      #       4 ; SpriteOp reason code we were called with

trns_flags2     #       4

vduoutputbuffer #       0
log2px          #       4 ; <- updated by readvduvars
log2py          #       4 ; <- updated by readvduvars
Log2bpp         #       4 ; <- updated by readvduvars
Log2bpc         #       4 ; <- updated by readvduvars
orgx            #       4 ; <- updated by readvduvars
orgy            #       4 ; <- updated by readvduvars
gwx0            #       4 ; <- updated by readvduvars, tweaked elsewhere for double pixel modes
gwy0            #       4 ; <- updated by readvduvars
gwx1            #       4 ; <- updated by readvduvars, tweaked elsewhere for double pixel modes
gwy1            #       4 ; <- updated by readvduvars
linelength      #       4 ; <- updated by readvduvars
screenstart     #       4 ; <- updated by readvduvars
ywindlimit      #       4 ; <- updated by readvduvars
modeflags       #       4 ; <- updated by readvduvars
ncolour         #       4 ; <- updated by readvduvars

BPC             #       4 ; <- updated by readvduvars
BPP             #       4 ; <- updated by readvduvars

ccompiler_bitblockmove # 4      ; routine for C to call back into assembler.
calibration_table # 4           ; printer calibration table

              [ jpeg
is_it_jpeg      #       4       ; BOOL - is this sprite JPEG?
ctrans_recent   #       4       ; BOOL - check for ColourTrans 1.25 or later
in_x            #       4       ; initial x coord in input sprite
in_y            #       4       ; initial y coord in input sprite
fetchroutine    #       4       ; routine for compiled code to call to get line of JPEG data.
jpeg_info_ptr   #       4       ; pointer to JPEG decompress workspace
area_numbers    #       4*3     ; dynamic area numbers
              ]
save_sprite     #       4       ; the actual source sprite

save_PdriverIntercept # 4       ; Flags used to determine if the pdriver is
                                ; currently intercepting the JPEG plots.

dither_truecolour   #   4       ; do we dither true colour images when reducing BPP?
blending            #   4       ; b0: translucency blending, b1: alpha mask/channel blending
ecfyoffset_ptr      #   4       ; pointer to Kernel's ECF offset & shift values, required for dithering
ecfshift_ptr        #   4

CPUFlags            #   4       ; Flags about which instructions we can use
CPUFlag_LDRH        *   1       ; LDRH/STRH available
CPUFlag_BLX         *   2       ; BLX available
CPUFlag_T2          *   4       ; ARMv6 Thumb2 instructions available: MOVW,MOVT,UBFX,BFC,BFI,etc.
CPUFlag_REV         *   8       ; REV available
CPUFlag_NoUnaligned *   16      ; Unaligned load/store not allowed

blendtables     #       4*6     ; Blending tables
screenpalette   #       4       ; Screen palette fetched via InverseTable, if necessary
inversetable    #       4       ; Inverse screen palette fetched via InverseTable, if necessary


newtranstable   #       256 *4  ; buffer for pixel translation table
                                ; or for palette converted to 16bpp...

; Everything from here up of interest to compiled C
; code. IF THERE ARE ANY CHANGES ABOVE THIS POINT then there must be
; matching changes in the C workspace definition.

spritename      #       SpriteNameSize

stackframe      #       4

debug_transmit  #       4               ; void debug_transmit(char c);

charblock       #       9

       ALIGNHASH        data,16

vdu_fgecforaeor #       4               ; Pointer to VDU drivers FgEcfOraEor
vdu_bgecforaeor #       4               ; Pointer to VDU drivers BgEcfOraEor

areaCB          #       0
                #       4               ; saEnd
                #       4               ; saNumber
                #       4               ; saFirst
                #       4               ; saFree
spriteCB        #       0
                #       4               ; spNext
                #       12              ; spName
                #       4               ; spWidth
                #       4               ; spHeight
                #       4               ; spLbit
                #       4               ; spRbit
                #       4               ; spImage
                #       4               ; spTrans
                #       4               ; spMode
spriteEnd       #       0

spriteSize      *       spriteEnd-spriteCB
spriteAreaSize  *       spriteEnd-areaCB + 2*8*8*16/8  ; mode 10 has 16 bpp!
                #       2*8*8*16/8
        ASSERT  (@@-areaCB) = spriteAreaSize

        ALIGNHASH       data,16

sp_mode         #       4               ;WT: added for 1bpp mask support
sp2_next        #       4               ;WT: added for 1bpp mask support

sp1_data        #       0
sp1_width       #       4
sp1_height      #       4
sp1_lbit        #       4
sp1_rbit        #       4
sp1_image       #       4
sp1_trans       #       4
sp1_header      #       4
sp1_imagesize   #       4

sp1_areaCBptr   #       4

sp2_data        #       0
sp2_width       #       4
sp2_height      #       4
sp2_lbit        #       4
sp2_rbit        #       4
sp2_image       #       4
sp2_trans       #       4
sp2_header      #       4
sp2_imagesize   #       4

        ALIGNHASH       data,64

sprite_doesnt_exist_error # 4   ; OSS Pointer to error block in RMA
ccompiler_sp    #       4       ; for unexpected jumps out of compiled C
ccompiler_errptr #      4       ; os_error pointer for if an OS error lead to exit from C code.

        ALIGNHASH       data,64

                ; Private space for use by compiled C.
                ; If the C code needs more than this then this area must be extended.
ccompiler_space #       &2800   ; C code checks at run-time for there being enough.
ccompiler_end   #       0

enddata         #       0

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Table of service calls we want
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        ASSERT  Service_ResourceFSStarting > Service_Reset
        ASSERT  Service_TerritoryStarted > Service_ResourceFSStarting

ServiceTable
        DCD     0
        DCD     ServiceUrsula - Module_BaseAddr
        DCD     Service_Reset
      [ standalone
        DCD     Service_ResourceFSStarting
      ]
        DCD     Service_TerritoryStarted
        DCD     0
        DCD     ServiceTable - Module_BaseAddr

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Service call handler
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Service
        MOV     r0, r0                  ; Indicates there is a service call table

        ; Fast rejection
        TEQ     r1, #Service_TerritoryStarted
      [ standalone
        TEQNE   r1, #Service_ResourceFSStarting
      ]
        TEQNE   r1, #Service_Reset
        MOVNE   pc, lr

ServiceUrsula
      [ standalone
        TEQ     r1, #Service_ResourceFSStarting
        BEQ     svc_resfsrestart
      ]
        TEQ     r1, #Service_Reset      ; Re-initialise on soft reset
        BEQ     Init

        ; ** Drop through for territory started **
        ; OSS A new Territory has started, so I need to re-cache the error block
svc_territory_started
        Push    "lr"
        LDR     r12, [r12]
        BL      cache_sprite_doesnt_exist_error
        Pull    "pc"

      [ standalone
        IMPORT  resfsarea
svc_resfsrestart
        Push    "r0, lr"
        BL      resfsarea               ; r0 := data area
        MOV     lr, pc
        MOV     pc, r2                  ; Call ResourceFS via r2
        Pull    "r0, pc"
      ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Initialisation
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Init
        Push    "R0-R12,LR"

      [ standalone :LAND: debug
        ; Call relocation code so debug strings in the C code work properly
        ; This is a bit dodgy as it might hide other relocation bugs!
        IMPORT  __RelocCode
        BL      __RelocCode
      ]

        LDR     R2,[R12]
        TEQ     R2,#0
        BNE     gotarea

        MOV     R0,#ModHandReason_Claim
        LDR     R3,=enddata-data
        SWI     XOS_Module
        BVS     initexitdie
        STR     R2,[R12]

        ; Set the error pointer to zero only if we are allocating the workspace.
        ; This is because on Service_Reset we have the workspace and we still have
        ; the old cached error block so zeroing the pointer would cause us to
        ; never free that block.

        MOV     r0, #0
        STR     r0, [r2, #:INDEX:sprite_doesnt_exist_error]
      [ jpeg
        ; zero the workspace pointer for JPEG - allocated later if needed
        STR     R0, [r2, #:INDEX:jpeg_info_ptr]
        ; zero the dynamic area numbers - allocated later if needed
        MOV     R3, #(?area_numbers:SHR:2) - 1
        ADD     R4, R2, #:INDEX:area_numbers
10
        STR     R0, [R4,R3,LSL#2]
        SUBS    R3, R3, #1
        BPL     %BT10
      ]
gotarea
        MOV     R12,R2

        MOV     R0,#-1
        STR     R0,inmode

        ; Get the ECF block pointers    
        MOV     R0,#6
        MOV     R1,#0
        MOV     R2,#OSRSI6_FgEcfOraEor
        SWI     XOS_ReadSysInfo
        MOVVS   R2,#0
        CMP     R2,#0
        MOVEQ   R2,#Legacy_VduDriverWorkSpace+Legacy_FgEcfOraEor
        STR     R2,vdu_fgecforaeor
        MOV     R0,#6
        MOV     R2,#OSRSI6_BgEcfOraEor
        SWI     XOS_ReadSysInfo
        MOVVS   R2,#0
        CMP     R2,#0
        MOVEQ   R2,#Legacy_VduDriverWorkSpace+Legacy_BgEcfOraEor
        STR     R2,vdu_bgecforaeor        
        MOV     R0,#6
        MOV     R2,#OSRSI6_ECFYOffset
        SWI     XOS_ReadSysInfo
        MOVVS   R2,#0
        CMP     R2,#0
        LDREQ   R2,=Legacy_VduDriverWorkSpace+Legacy_ECFYOffset
        STR     R2,ecfyoffset_ptr        
        MOV     R0,#6
        MOV     R2,#OSRSI6_ECFShift
        SWI     XOS_ReadSysInfo
        MOVVS   R2,#0
        CMP     R2,#0
        LDREQ   R2,=Legacy_VduDriverWorkSpace+Legacy_ECFShift
        STR     R2,ecfshift_ptr

      [ debug
        ; Fill in the debug transmit function pointer
        MOV     R0,#11
        SWI     XOS_ReadSysInfo
        MOVVS   R0,#0
        STR     R0,debug_transmit
      ]

        BL      GetCPUFlags

      [ standalone
        ; Register the messages before they get used
        BL      resfsarea
        SWI     XResourceFS_RegisterFiles
        BVS     initexitdie
      ]
        ; OSS Attempt to cache the error. This may well fail, but we ignore the
        ; failure. We will get another go later on Service_TerritoryStarted and
        ; that time it should succeed.

        BL      cache_sprite_doesnt_exist_error
02
        CLRV

        ; Hook onto the Sprite vector
        Claim   SpriteV,My_SpriteOp

        MOVVC   R0,#-1
        SWIVC   XOS_ChangedBox  ; R1 --> 5-word block for changed coords
        STRVC   R1,changedbox

        BLVC    readvduvars     ; read for later

      [ file
        Debug_Open "<Debug$$File>"
      ]

        
        MOV     r0, #0
        STR     r0, dither_truecolour     ; initialise dithering off..
        STR     r0, blending
        STR     R0,ccompiler_space        ; mark the ccompiler workspace clearly as uninitialised
        ASSERT  ?blendtables = 6*4
        STR     R0, blendtables
        STR     R0, blendtables+4
        STR     R0, blendtables+8
        STR     R0, blendtables+12
        STR     R0, blendtables+16
        STR     R0, blendtables+20                

        ADRL    r0,bitblockmove           ; ensure C code has access to bitblockmove
        STR     r0,ccompiler_bitblockmove

      [ jpeg
        ; set up the fetchroutine, for use by any subsequent compiled code.
        ADRL    R2,jpeg_fetchroutine
        STR     R2,fetchroutine

        ; clear pdriver intercept flags....
        STR     r0, save_PdriverIntercept

        ; check ColourTrans version is up to date
        ADR     r0, init_ctrans_check
        SWI     XOS_CLI
        MOVVS   r0, #0
        MOVVC   r0, #-1
        STR     r0, ctrans_recent
        CLRV
      ]

initexitdie
        STRVS   R0, [sp]
        Pull    "R0-R12,PC"

init_ctrans_check
        DCB     "RMEnsure ColourTrans 1.25",0
        ALIGN

Die
        Push    "R0-R12,LR"
        LDR     R12,[R12]       ; R12 --> workspace

      [ standalone
        ; Remove our message resources
        BL      resfsarea
        SWI     XResourceFS_DeregisterFiles
      ]
        ; OSS Free the cached "Sprite doesn't exist" error block - never
        ; returns errors.
        BL      free_sprite_doesnt_exist_error

      [ file
        Debug_Close
      ]

      [ jpeg
        MOV     R3, #(?area_numbers:SHR:2) - 1
        ADR     R4, area_numbers
10
        LDR     R1, [R4,R3,LSL#2]            ; dynamic area number N
        CMP     R1, #0
        MOVNE   R0, #1                       ; remove area
        SWINE   XOS_DynamicArea
        SUBS    R3, R3, #1
        BPL     %BT10
      ]

        ; Unhook from Sprite vector
        Release SpriteV,My_SpriteOp             ; OSS  Errors from this ARE returned
01
        B       initexitdie

; Set up CPUFlags
GetCPUFlags ROUT
        Entry   "R0-R5"
        MOV     R5, #0
        MOV     R0, #OSPlatformFeatures_ReadCodeFeatures
        SWI     XOS_PlatformFeatures
        BVS     %FT90                        ; Must be an old OS/CPU version
        ; Try and guess the CPU features for situations where OS_PlatformFeatures 34 isn't available
        TST     R0, #CPUFlag_No26bitMode
        ORRNE   R5, R5, #CPUFlag_NoUnaligned ; No 26bit mode, might be ARMv6+, so disallow unaligned load/store
        TST     R0, #CPUFlag_XScale
        ORRNE   R5, R5, #CPUFlag_LDRH+CPUFlag_BLX ; XScale, so ARMv5 features available
        BICNE   R5, R5, #CPUFlag_NoUnaligned ; ...and unaligned access should work
        MOV     R4, R0
        ; See if OS_ReadSysInfo 8 can give us a more authoritative view of whether unaligned loads are supported
        ; Currently NoUnaligned only controls our use of rotated loads, so check if the OS uses those
        MOV     R0, #8
        SWI     XOS_ReadSysInfo
        BVS     %FT10
        TST     R2, #3<<5                    ; OS describes alignment mode?
        BEQ     %FT10
        TST     R1, #1<<5                    ; OS uses rotated loads?
        ORREQ   R5, R5, #CPUFlag_NoUnaligned ; No: Disable unaligned loads
        BICNE   R5, R5, #CPUFlag_NoUnaligned ; Yes: Enable unaligned loads
10
        TST     R4, #CPUFlag_ExtraReasonCodesFixed
        BEQ     %FT90
        ; See if we can query things directly via OS_PlatformFeatures 34
        ADR     R4, CPUFlagsList
20
        LDRB    R3, [R4], #1
        CMP     R3, #0
        BEQ     %FT90
30
        LDRB    R1, [R4], #1
        CMP     R1, #255
        ORREQ   R5, R5, R3                   ; Enable feature if all requirements were met
        BEQ     %BT20                        ; Advance to next CPUFlag
        MOV     R0, #OSPlatformFeatures_ReadCPUFeatures
        SWI     XOS_PlatformFeatures
        BVS     %FT90
        TEQ     R0, #1
        BICNE   R5, R5, R3                   ; Negative response, disable feature
        MOVNE   R3, #0
        B       %BT30
90
        STR     R5,CPUFlags
        EXIT

CPUFlagsList
        = CPUFlag_LDRH, CPUFeature_LDRH_LDRSH_STRH, 255
        = CPUFlag_BLX, CPUFeature_BLX, 255
        = CPUFlag_T2, CPUFeature_MOVW_MOVT, CPUFeature_BFC_BFI_SBFX_UBFX, 255
        = CPUFlag_REV, CPUFeature_REV_REV16_REVSH, 255
        = 0
        ALIGN

      [ jpeg
        IMPORT  jpeg_find_image_dims
        IMPORT  jpeg_find_line
        GET     Sources.SWIs
      ]
        GET     Sources.SprOp
        GET     Sources.SprAdjSize
        GET     Sources.SprTrans
        GET     Sources.MsgCode
        GET     Sources.PutScaled

      [ debug
        InsertNDRDebugRoutines
      ]

        END
@


4.39
log
@Fix quality loss for some alpha blending ops. Perform dynamic CPU feature detection.
Detail:
  c/asmcore - Fix loss of quality for some alpha blending, e.g. 4K LARGB sprite being rendered into a 16M colour mode. All three channels were being expanded to 8 bit, but then two were being erroneously truncated to 4 bit.
  Sources/SprExtend - Make use of OS_PlatformFeatures + OS_ReadSysInfo to detect CPU features at runtime instead of relying on a hardcoded value. Should allow for better code generation with softload versions or Raspberry Pi 2/3 ROM versions.
Admin:
  Tested on Raspberry Pi 1, 3, Iyonix


Version 1.78. Tagged as 'SprExtend-1_78'
@
text
@d367 1
a367 1
spritename      #       12
@


4.38
log
@Transcode arithmetics
Detail:
  Import of the raw coefficient Huffman entropy compressor elements of the IJG8d library.
  We don't need a full compressor (ala JCompMod) since there's never a need to go all the way through IDCT/upsampling/colour conversion only to reverse the whole process; it's sufficient only to collect up the raw coefficients and recompress them as a baseline JPEG.
  Two extra (temporary) dynamic areas are introduced, once to hold the raw coefficients and the other to act as a scratch file to make the JPEG in. See Doc/JPEGMmgr.
Admin:
  Submission for the JPEG bounty.

Version 1.72. Tagged as 'SprExtend-1_72'
@
text
@d41 1
d590 1
a590 20
        ; Set up CPUFlags
        GBLA    CPUFlagsValue
CPUFlagsValue SETA 0
      [ :LNOT: NoARMv4
CPUFlagsValue SETA CPUFlagsValue + CPUFlag_LDRH
      ]
      [ :LNOT: NoARMv5
CPUFlagsValue SETA CPUFlagsValue + CPUFlag_BLX
      ]
      [ :LNOT: NoARMT2
CPUFlagsValue SETA CPUFlagsValue + CPUFlag_T2
      ]
      [ :LNOT: NoARMv6
CPUFlagsValue SETA CPUFlagsValue + CPUFlag_REV
      ]
      [ NoUnaligned
CPUFlagsValue SETA CPUFlagsValue + CPUFlag_NoUnaligned
      ]      
        MOV     R0,#CPUFlagsValue
        STR     R0,CPUFlags
d694 57
@


4.37
log
@Import of IJG8d library sources
Detail:
  Using the decoder in "example.c" as a starting point, we try to follow that sequence more closely even if in our embedded implementation some of the functions don't do much.
  Uses the default colour backend for 32bpp BGR output for most of the unusual cases.
  The most common 2x2 subsampling case uses a custom merged upsampler and colour converter, with colour output directly in RISC OS format for the respective screen mode.
Admin:
  Submission for the JPEG bounty.

Version 1.71. Tagged as 'SprExtend-1_71'
@
text
@d334 2
a335 2
jpeg_info_ptr   #       4       ; pointer to JPEG workspace
area_number     #       4       ; dynamic area number
d536 7
a542 1
        STR     R0, [r2, #:INDEX:area_number]
d696 4
a699 1
        LDR     R1, area_number              ; dynamic area number
d703 2
@


4.36
log
@Replace tracef debug calls
Detail:
  Change tracef() to use the double brackets trick rather than _ for , substitution
Admin:
  Debug build built, but not tested. Non debug build functions as before.
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_70-tracef
@
text
@a79 3
        GBLL    dynamicarea             ; for storing jpeg workspace
dynamicarea SETL {TRUE}

d334 1
a334 1
jpeg_info_ptr   #       4       ; pointer to JPEG workspace - allocated from RMA if needed
a689 1
      [ dynamicarea
d692 1
a692 1
        MOVNE   R0, #1
a693 6
      |
        LDR     R2,jpeg_info_ptr
        CMP     R2,#0
        MOVNE   R0,#ModHandReason_Free
        SWINE   XOS_Module                   ; free block
      ]
a703 1
        IMPORT  panic_trace
@


4.35
log
@Update headers to stock copy
Detail:
  Added headers jerror, jmorecfg, jpegint from IJG8d. Removed jpegdata header.
  Bulk rename of structure members to match newer headers, some RISCOS-isms wrapped in #ifdef RISCOS, retained for the time being.
  Assembler code now gets cinfo member offsets from jhdr.s derived from the C header rather than keeping its own dangerous copy of the offsets.
Admin
  Note: this has broken CFSI-jpeg as it expects the error values to be at the top of cinfo.
  Submission for the JPEG bounty.
  Tagged as SprExtend-1_70-headers.
@
text
@a19 1
        GET     Hdr:CPU.Arch
a36 2
        GET     Hdr:Debug
        GET     Hdr:HostDebug
d373 2
d578 8
a724 2
        InsertDebugRoutines
        InsertHostDebugRoutines
@


4.34
log
@Rewrite of find_image_dims
Detail:
  Now handles 0xFF padding, previously acceptable encoded images including padding were incorrectly rejected.
  Calculate the workspace for greyscale images correctly, the itype flags included the density (and latterly the SOF) flags, but the workspace calculation assumed it only contained 1 or 3 (for colour components).
  Exit cases now made common and propagate file errors correctly.
  Minor changes to the assembler that uses find_image_dims to handle 4 colour component return (now a 3 bit return value).
  Merge the other M_THING enum from IJG8d so we don't need our own copy.
  Fix signed pointer comparison.
  Use symbolic defines from Global & Interface headers where possible.
  The jdata pointer arg is now treated as const.
Admin:
  Submission for the JPEG bounty.

Version 1.70. Tagged as 'SprExtend-1_70'
@
text
@a248 6
                ^       0
error_code      #       4       ; decompress_info_struct
error_argument1 #       4
error_argument2 #       4
workspace_UNUSED #      4
workspace_size  #       4
@


4.33
log
@Fix orphaned dynamic area
Detail:
  Sources/SprExtend - Only initialise the JPEG workspace pointer + DA number the first time Init is called. This prevents the dynamic area from being orphaned if a JPEG operation is performed during the ROM boot (prior to Service_Reset), as is the case with BootFX on the Raspberry Pi.
Admin:
  Tested on Raspberry Pi
  Task manager now shows one JPEG workspace DA, whereas before there were two.


Version 1.67. Tagged as 'SprExtend-1_67'
@
text
@d711 1
a711 1
        IMPORT  find_image_dims
@


4.32
log
@Obscure case null pointer dereference fix
If ColourTrans is too old to have wide translation table support for JPEG plotting, module Init would detect this, but fail to clear the V flag and report oflaoflaofla.

Version 1.65. Tagged as 'SprExtend-1_65'
@
text
@d543 5
a653 5
        ; zero the workspace pointer for JPEG - allocated later if needed
        MOV     R0,#0
        STR     R0,jpeg_info_ptr
        STR     R0,area_number

@


4.31
log
@Escape some dollars
Detail:
  Sources/SprExtend - Escape some dollars contained in strings to avoid warnings from objasm
Admin:
  Resulting binary unchanged


Version 1.64. Retagged as 'SprExtend-1_64'
@
text
@d654 1
a654 1
        ; clear priver intercept flags....
d663 1
@


4.30
log
@Add OS_SpriteOp 65 implementation. Tweak OS_SpriteOp 52 logic for passing the request on to the kernel.
Detail:
  Sources/SprExtend - GET Hdr:GraphicsV, add debug switch for sprite tiling
  Sources/SprOp - Add OS_SpriteOp 65 (TileSpriteScaled) implementation. Will use OS_Plot to perform hardware-accelerated copies of tiles if no special plot actions are in effect (masking, blending) and the driver indicates copies are fast. For other situations OS_SpriteOp 52 is issued in a simple loop. Also tweak OS_SpriteOp 52 implementation to pass unmasked, true colour sprites to the kernel for rendering - contrary to the old source comment, the kernel is significantly faster at this than SpriteExtend.
Admin:
  Tested on Iyonix, BB-xM
  Requires HdrSrc-2_42


Version 1.62. Tagged as 'SprExtend-1_62'
@
text
@d625 1
a625 1
        Debug_Open "<Debug$File>"
@


4.29
log
@Update to work with new "32K+" colour translation tables
Detail:
  Sources/SWIs, Sources/SprExtend, Sources/SprOp, c/PutScaled, c/sprtrans, h/putscaled - Cache the sprite NColour value in the save_* workspace
  Sources/SprOp - Update preparettr to perform extra validation on 32K-style translation tables (old "32K." or new "32K+"). Although we could potentially accept any format table, to cut down on the number of plotter combinations we currently require that the table matches the format that ColourTrans will create when given the source sprite.
  c/PutScaled, c/sprtrans - Update comments relating to determining input format of TTRType_32K tables
Admin:
  Tested on BB-xM
  Requires Colours-1_89


Version 1.61. Tagged as 'SprExtend-1_61'
@
text
@d43 1
d111 1
d127 1
@


4.28
log
@Add support for blended sprite & JPEG rendering - alpha masks, alpha channels, and translucency
Detail:
  This big set of changes adds support for the following user-facing APIs, as per ROL's specs:
  - OS_SpriteOp 52 (PutSpriteScaled) colour mapping, translucency blending, and alpha mask/alpha channel blending
  - OS_SpriteOp 56 (PutSpriteTransformed) colour mapping, translucency blending, and alpha mask/alpha channel blending
  - JPEG_Plot[File]Scaled colourmapping & translucency blending
  - JPEG_Plot[File]Transformed colourmapping & translucency blending
  Sources/CFSI-JPEG, Sources/PutScaled:
  - Added exit_oserror exit routine for use by C code.
  - For SpriteExtend this allows the C code to cause OS_SpriteOp to exit with a given OS error block.
  - For CFSI-JPEG the error block is returned and ERROR_FATAL is returned to ChangeFSI.
  Sources/CSupport:
  - Add definitions for some error codes (matches existing definitions from h/commondefs)
  Sources/PutScaled:
  - Stripped out code to look for identity translation tables; now handled by preparettr routine in Sources/SprOp
  Sources/SWIs, Hdr/SprExtend:
  - JPEG SWIs updated to add support for alpha-blended and colour mapped JPEG rendering, following ROL's APIs
  Sources/SprExtend:
  - Stripped out lots of old build flags which haven't been touched in years.
  - Strip out assembler SprTrans code generator.
  - Add new definitions needed for blending & colour mapping.
  Sources/SprOp:
  - Updated PutScaled frontend to deal with blending and colour mapping.
  - Disabled code which was bodging coordinates when dealing with double-pixel modes - it seems to cause a few issues, and the code generator mostly had proper double-pixel support anyway.
  - Translation table verification and fiddling code rewritten and consolidated into the preparettr routine. C code is now explicitly told what table type is in use and whether it can safely be ignored in favour of using the sprite palette.
  - Removed code from CheckSpriteArea which was deliberately throwing an error upon seeing alpha-masked sprites; I think the bug that was hiding has been fixed now
  Sources/SprTrans
  - Removed the assembler version of the code generator.
  - Updated to add support for blending and colour mapping
  c/PutScaled:
  - Old test code removed.
  - Updated to add support for blending & colour mapping
  - Assorted bugs fixed.
  - A few extra architecture-specific optimisations added.
  - Some workspace setup code moved to c/asmcore to allow sharing with SprTrans.
  c/asmcore:
  - Register allocation code rewritten. Instead of allocating on a first-come, first-served basis, the code now builds a list of which logical registers are needed (and which 'banks' they fall into) and then attempts to allocate them in a more intelligent manner. It still has some failings (e.g. reusing R12 as a general purpose register is currently impossible) but it's a lot more flexible and reliable than the old code.
  - Core pixel transformation code updated to add support for blending & colour mapping
  - Added some extra architecture-specific optimisations
  c/rojpeg:
  - JPEG option handling updated to avoid trashing any colour mapping descriptor that may have been passed in
  c/sprtrans:
  - Updated to add support for blending & colour mapping
  c/tracing:
  - Debug assert messages now show filename as well as line number
  h/commondefs:
  - Removed old #define's that related to old assembler switches.
  h/putscaled:
  - Workspace definition updated to match assembler version.
  - SprTrans stack workspace structure moved here from c/sprtrans
Admin:
  Tested on BB-xM plotting all major sprite & JPEG types into all modes with all major options


Version 1.55. Tagged as 'SprExtend-1_55'
@
text
@d286 1
@


4.27
log
@Add support for new sprite types & screen modes
Detail:
  Makefile - Updated to fix a couple of dependency issues and to make c/asmcore the main C file, not c/putscaled
  Sources/PutScaled - Add a utility routine that's used by the C code to get information about pixel formats
  Sources/SprAdjSize - Add support for wide masks & RISC OS 5 style sprite mode words
  Sources/SprExtend - Tidy up workspace by removing lots of unused bits and moving other bits within sight of the C code. Add flag to control whether C or assembler version of SprTrans is used. Query kernel for ECFYOffset/ECHShift locations instead of using hardcoded values in putscaled code. Add fix for garbage debug strings in softloaded debug versions of the module.
  Sources/SprOp - Add support for wide masks & RISC OS 5 style sprite mode words. Update makepalette16bpp to cope with all the new 16bpp modes. Flag_* -> ModeFlag_* renaming. Move some translation table handling code into a new routine, 'preparettr'. Update checktrans/converttrans to deal with new pixel formats.
  Sources/SprTrans - If the C version of SprTrans is enabled, disable all of these assembler bits except for the outer loop which steps over each row of the screen
  Sources/jdcolor - Updated to deal with new pixel formats. 16bpp conversion code split off into new file, Sources/jdcolor16.
  Sources/jdcolor16 - New file containing the guts of the YUV -> 16bpp conversion code. Gets included multiple times with different options to generate the different conversion routines (code is too big for a macro).
  c/asmcore - New file containing lots of common code ripped out of c/PutScaled - e.g. workspace definition, main functions for register assignment & instruction generation, and code for pixel format conversion. Pixel format conversion code rewritten to cope with new pixel formats, and code buffer key word generation rewritten to fix a couple of bugs (e.g. some issues with dithering options were observed)
  c/PutScaled - Ripped out lots of code that's now in c/asmcore. Now just deals with things that are PutScaled-specific, e.g. main plotter loop containing pixel read/write code. Code extended to cope with new pixel formats
  c/rojpeg, h/jinclude, h/jpegdata - Code extended to cope with new 16bpp conversion routines
  c/sprtrans - New C implementation of the core per-row transformed sprite plotting code generator. Allows reuse of the extensive pixel conversion code in c/asmcore, and allows for better code generation than the assembler original.
  h/putscaled - Worksapce definition updated to match assembler version
Admin:
  Tested on BB-xM, plotting lots of different sprites in lots of different modes
  Plotting of wide mask sprites not supported yet
  C version of YUV -> 16bpp code currently only deals with traditional &BGR 555 pixel format - code is aware of this and will do conversion to desired format if applicable (although quality may be reduced)
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 1.52. Tagged as 'SprExtend-1_52'
@
text
@d42 1
d49 1
a64 19
        GBLL    AvoidScreenReads        ; when true, look out for BIC masks of FFFFFFFF and skip read
AvoidScreenReads SETL    {TRUE}

        GBLL    multibuffer
multibuffer     SETL {FALSE}            ; keep multiple copies of generated code
nbuffers        * 8                     ; number of code buffers to use

        GBLL    vidc20
vidc20  SETL    {TRUE}                  ; VIDC20 support, else graphics enhancer

        GBLL    ignore_ttr
ignore_ttr SETL {TRUE}                  ; if plotting <16 to >8bpp and it has a
                                        ; palette, use that instead of the ttr
        GBLL    med01867
med01867 SETL   {TRUE}                  ; if true changes ignore_ttr behaviour to
                                        ; only apply at 8bpp full palette
        GBLL    flagbit
flagbit SETL    {TRUE}                  ; if true forces the palette to be used over the translation
      [ flagbit                         ; table, overriding the effect of of med01867 if b4 of R5 on entry was set
a68 1
      ]
a69 3
        GBLL    widetrans               ; support for wide translation tables via R5 bit 5
widetrans SETL  {TRUE}
      [ widetrans
d72 6
a77 1
      ]
d91 2
a92 2
        GBLL    SprTransC               ; enable C version of SprTrans compiler
SprTransC SETL  {TRUE}
a121 2
debugmb SETL    debug :LAND: {FALSE}    ; multibuffer code for code generator
debugms SETL    debug :LAND: {FALSE}    ; minimal multibuffer info messages
a219 18
$l      SetImm  $reg,$value,$cc
$l      EOR$cc  $reg,$reg,#xxx
        EOR$cc  $reg,$reg,$value
        MEND

        MACRO
$l      SetLsr  $reg,$value,$cc
$l      EOR$cc  $reg,$reg,#xxx:SHL:7
        EOR$cc  $reg,$reg,$value,LSL #7
        MEND

        MACRO
$l      SetLsl  $reg,$value,$cc
$l      EOR$cc  $reg,$reg,#xxx:SHL:7
        EOR$cc  $reg,$reg,$value,LSL #7
        MEND

        MACRO
d285 1
a292 11
                [ multibuffer
pc_ecflimit0    #       nbuffers :SHL: 2        ; addresses inside macro code
pc_outoffset0   #       nbuffers :SHL: 2
thisslot        #       4
calladdr20      #       nbuffers :SHL: 2
calladdr0       #       nbuffers :SHL: 2
                |
pc_ecflimit     #       4                       ; addresses inside macro code
pc_outoffset    #       4
                ]

d298 8
a310 3
                [ ignore_ttr
trns_palette    #       4
                [ flagbit
a311 2
                ]
                ]
a341 1
save_sprite     #       4       ; the actual source sprite
d345 1
d351 1
d358 7
a364 1
CPUFlag_MOVW        *   4       ; MOVW available
a377 4
  [ :LNOT: SprTransC
macroword       #       4
  ]

a439 5
                [ multibuffer
buffer0mask     #       nbuffers :SHL: 2
buffer0count    #       nbuffers :SHL: 2
                ]

a441 9
        [ :LNOT: SprTransC
                [ multibuffer
codebuffer0     #       nbuffers * &200
codebuffer      #       &200 ;still needed elsewhere
                |
codebuffer      #       &200
                ]
        ]

d444 1
a444 1
ccompiler_space #       &2400   ; C code checks at run-time for there being enough.
d453 1
a453 2
        ASSERT  Service_ModeChange > Service_Reset
        ASSERT  Service_ResourceFSStarting > Service_ModeChange
a459 3
      [ multibuffer
        DCD     Service_ModeChange
      ]
a478 3
      [ multibuffer
        TEQNE   r1, #Service_ModeChange
      ]
a486 4
      [ multibuffer
        TEQ     r1, #Service_ModeChange
        BEQ     svc_modechange
      ]
a507 42
      [ multibuffer

        ; one of the problems with using a quick 'n' fast algorithm like usage counts
        ; for deciding which routine needs replacing is that it has weaknesses. The
        ; specific weakness being dealt with here is that if a long time is spent in
        ; one mode then high usage counts will result for that mode. When a new mode
        ; is selected the new routines needed for that mode will fight over the remaining
        ; slots with a lower usage count. In worst case this will mean that new
        ; routines will be built on virtually every plot!
        ;
        ; there are two options for avoiding this. The first is to hold a time stamp
        ; to indicate when a routine was last used. This option has been rejected
        ; because of the overhead of calling the SWI. The second is to junk all the
        ; currently built routines on a mode change. This may result in some routines
        ; being rebuilt which have already been built, but will avoid the scenario
        ; outlined above.
        ;
        ; note that I am not clearing the associated macrowords for each routine - this
        ; should help to avoid too many needless rebuilds of routines

svc_modechange
        Push    "R0-R2,LR"

        LDR     R0,[R12]
        MOVS    R12,R0
        BEQ     %FT20                   ; No workspace

        ; zero the workspace pointer for JPEG - allocated from RMA if needed
        MOV     R0,#0
        STR     R0,jpeg_info_ptr

        ADRL    R2,buffer0count
        MOV     R1,#((nbuffers :SHL: 2)-4)
10
        STR     R0,[R2,R1]
        SUBS    R1,R1,#4
        BPL     %BT10
        Debug   mb,"Clearing all usage counts on mode change"
20
        Pull    "R0-R2,PC"
      ]

a543 3
      [ :LNOT: SprTransC
        STR     R0,macroword
      ]
d577 2
a578 1
        MOV     R0,#0
d580 1
a580 1
        ORR     R0,R0,#CPUFlag_LDRH
d583 1
a583 1
        ORR     R0,R0,#CPUFlag_BLX
d586 1
a586 1
        ORR     R0,R0,#CPUFlag_MOVW
d588 7
a608 12
      [ multibuffer
        ; set up the buffer usage counts and current macrowords
        ADR     R4,buffer0mask
        ADR     R5,buffer0count
        MOV     R6,#0
        MOV     R7,#((nbuffers :SHL: 2)-4)
20
        STR     R6,[R4,R7]
        STR     R6,[R5,R7]
        SUBS    R7,R7,#4
        BPL     %BT20
      ]
d627 1
d629 7
@


4.26
log
@Add support for self registered resources (standalone)
* Listen for ResourceFS starting service call
* De/Register files appropriately
* Refactor makefile to have two possible install targets
* Simplify the ColourTrans RMEnsure

Version 1.51. Tagged as 'SprExtend-1_51'
@
text
@d56 1
a56 1
file    SETL    {TRUE}                  
d107 3
a277 56
log2bpc         RN      R11             ; bpc
ycount          RN      R9              ; xcount
ysize           RN      R8              ; xsize
yadd            RN      R5
ydiv            RN      R4
inoffset        RN      R1              ; inshift
outoffset       RN      R0

inshift         RN      R1              ; inoffset

im2             RN      R12             ; wsptr         ; ecfeor
im1             RN      R11             ; log2bpc       ; ecfora
masko           RN      R10             ; ttr           ; ecfptr
xcount          RN      R9              ; ycount
xsize           RN      R8              ; ysize
xadd            RN      R7
xdiv            RN      R6
outmask         RN      R5              ; yadd
outword         RN      R4              ; ydiv
outptr          RN      R3
inptr           RN      R2
in2             RN      R1              ; inoffset      ; inshift
in1             RN      R0              ; outoffset

inbpp           RN      R12             ; im2
ttr             RN      R10             ; masko

                  ^     0,R13           ; for stackframe
stack_inshift     #     4               ; this data is copied onto the stack
stack_outword     #     4               ; so that R12 can be re-used
stack_outmask     #     4
stack_xsize       #     4
stack_xcount      #     4
stack_ecfptr      #     4
stack_ecflimit    #     4
stack_vcount      #     4
stack_xdiv        #     4
stack_xadd        #     4
stack_tempoutptr  #     4
stack_wsptr       #     4               ; for recovering R12 later!
        ASSERT  (:INDEX:@@) = 12*4       ; must be exactly 12 words on stack
stack_BPP         #     4               ; copy
stack_outoffset   #     4               ; copy
stack_inbpp       #     4               ; copy
stack_colourttr   #     4               ; copy
stack_masko       #     4               ; copy
stack_calladdr    #     4               ; copy
stack_calladdr2   #     4               ; copy
stack_returnaddr  #     4
stack_maskword    #     4               ; = (2^outlog2bpp)-1 ROR outlog2bpp
stack_maskinptr   #     4               ; destroyable copy for inside loop
stack_maskinshift #     4               ; destroyable copy for inside loop
stack_temp1       #     4               ; for temp saving of registers inside loop
stack_temp2       #     4               ; for temp saving of registers inside loop
stack_end         #     0

d302 7
a308 11
save_block      #       0
save_inshift    #       4       ; <---!   this data is copied onto the stack
save_outword    #       4       ;     !   so that R12 can be re-used
save_outmask    #       4       ;     !
save_xsize      #       4       ;     !
save_xcount     #       4       ;     !
save_ecfptr     #       4       ;   --!   up to here is reloaded using LDMIA
save_ecflimit   #       4       ;     !
save_vcount     #       4       ;     !
save_xdiv       #       4       ;     !
save_xadd       #       4       ; <---!
a314 3
save_tempxsize  #       4
save_tempysize  #       4
save_xftimesyf  #       4
d318 5
a322 6
save_inflags    #       4
save_inlog2bpp  #       4
save_inlog2bpc  #       4
save_inbpp      #       4
save_mode       #       4               ; used in PaintChar
save_spr_type   #       4
d340 3
a342 3
inmode          #       4
inlog2px        #       4
inlog2py        #       4
a344 8
nextrowdata     #       12
nextcoldata     #       12
TOTAL           #       4
XTOTAL          #       4

vduspritepars   #       4+4         ; sprite code, areaCBptr ...
vduspritename   #       12          ; ... name

d347 1
a347 1
spritecode      #       4
d356 19
a374 2
BPC             #       4
BPP             #       4
a389 1
bgcolour        #       4       ; background colour, for plotting mask.
d394 8
d414 1
d416 1
a475 18
vduoutputbuffer #       0
log2px          #       4
log2py          #       4
Log2bpp         #       4
Log2bpc         #       4

orgx            #       4
orgy            #       4
gwx0            #       4
gwy0            #       4
gwx1            #       4
gwy1            #       4

linelength      #       4
screenstart     #       4
ywindlimit      #       4

modeflags       #       4
d487 1
d494 1
d622 7
d651 1
d653 1
a653 3

        MOV     R0,#0
        STR     R0,vduspritename
d671 27
@


4.25
log
@Adopt colour conversions from MigrateIJG8b branch
Now for every colour conversion there is a corresponding C function, allowing swapping between them for test purposes.
Here, 'ASMCOLOR' is selected and the C functions not even referenced in the makefile, see branch for use.
Permits use of USAT, for a small 1.5% speedup and smaller code.
Some other typedefs and comment shuffling copied over - should be harmless.

Version 1.50. Tagged as 'SprExtend-1_50'
@
text
@d35 1
d58 3
a60 3
      [ :LNOT: :DEF: localmessages
        GBLL    localmessages
localmessages SETL {FALSE}
d567 2
a568 1
        ASSERT  Service_ResourceFSStarted > Service_ModeChange
d577 4
a580 1
        DCD     Service_ResourceFSStarted
d592 4
a595 1
        TEQ     r1, #Service_ResourceFSStarted
d603 4
d609 1
a609 1
        BEQ     modechange
d616 2
a617 2
service_territory_started
        Entry "r0-r11"
d620 11
a630 1
        EXIT
d652 6
a657 2
modechange
        Push    "R0-R2,R12,LR"
d661 1
a661 6
        ADRL    R2,jpeg_info_ptr
        STR     R0,[R2]

        LDR     R0,[R12]
        MOVS    R12,R0
        BEQ     modechange_nospace
d663 1
a663 1
        ADRL    R0,buffer0count
d665 2
a666 3
        MOV     R2,#0
modechange_loop
        STR     R2,[R0,R1]
d668 1
a668 1
        BPL     modechange_loop
d670 2
a671 2
modechange_nospace
        Pull    "R0-R2,R12,PC"
d725 6
d798 1
a798 1
        DCB     "RMEnsure ColourTrans 1.25 Error 1",0
d805 5
@


4.24
log
@Update to work with zero page relocation
Detail:
  Sources/SprExtend - Try using OS_ReadSysInfo 6 to get ECF block addresses before falling back on legacy addresses. Store pointers in module workspace for speedy access.
  Sources/SprOp, Sources/SprTrans - Use workspace ECF block pointers
  c/rojpeg - Fix null pointer access (actually an unused variable)
Admin:
  Tested on rev A2 BB-xM


Version 1.46. Tagged as 'SprExtend-1_46'
@
text
@d809 1
a809 1
        IMPORT  assembler_panic
@


4.23
log
@Revise strictness of sprite area checking.
Those SpriteOps that modify the sprite input now
* R0=&0-&FF R1=don't care R2=mustn't be too low down
* R0=&100-&1FF R1=must be valid R2=mustn't be too low down
* R0=&200-&2FF R1=must be valid R2=must be valid
Those SpriteOps that just display but don't modify the input sprite
* R0=&0-&FF R1=don't care R2=mustn't be too low down
* R0=&100-&1FF R1=must be valid R2=mustn't be too low down
* R0=&200-&2FF R1=don't care R2=must be valid
In this context, valid means word aligned and not too low down.
In this context, too low down is anything below &100.

Version 1.45. Tagged as 'SprExtend-1_45'
@
text
@d40 1
d464 3
d688 17
@


4.22
log
@Make SpriteExtend perform sanity checks on sprite/area pointers
Detail:
  Sources/SprExtend - Added new CheckAlignedAndSensible macro to make it easy to check pointers. Pointers which aren't word aligned or are less than 256 are considered bad.
  Sources/SprOp - Update findsprite, getspritename and getspriteaddr to check sprite/area/name pointers for validity. Sprite names are the only ones that are allowed to not be word aligned.
Admin:
  Tested on rev A2 BB-xM.


Version 1.43. Tagged as 'SprExtend-1_43'
@
text
@d251 1
a251 1
$l      CheckAlignedAndWithin $sprite,$offset,$end,$temp
d254 1
a254 1
        BNE     %F99
d257 1
a257 1
        BHI     %F99                    ; out of range
d261 5
a265 5
$l      CheckAlignedAndSensible $addr,$failed
$l      TST     $addr, #3 ; word aligned?
        BNE     $failed
        CMP     $addr, #256 ; outside processor vectors?
        BLO     $failed
@


4.21
log
@API enhancement and space saving refactoring.
Setting bit 1 of r0 in JPEG_FileInfo and JPEG_Info will now return the SOF type of the JPEG in question in bits 3-6 of the info flags in r0 on exit.
Took this opportunity to refactor find_image_dims to take a structure pointer rather than lots of individual pointers (CFSI-JPEG ammended to match). Untangled the return codes a bit so it is only necessary to inspect r0 on exit from C to determine the outcome. Values of 1 & 2 are translated in the assembler code into more specific error messages than just "Incomplete or corrupt JPEG".
Fix bug where unknown density marker would leave the file open in JPEG_FileInfo.
Don't bother ADRL'ing r1 for error messages that don't have a %0 in them.
Added all the input & output flag definitions to the exported header file so other callers can use them too.
More functionality, fewer bugs, about 200 bytes smaller too.

Version 1.35. Tagged as 'SprExtend-1_35'
@
text
@d260 9
@


4.21.2.1
log
@Create assembler equivalents of C colour conversions, approx 10% speed up.
Add new switch ASMCOLOR to select which to use, C or assembler.
Remove FILE_ exit trace concept, just use __FILE__ instead in exit_erl.
Add some comments to exit_erl and friends.
A few bits of cinfo setup moved into start_pass_huff_decoder() or eliminated.
Bumped up the precision of SCALE_BITS in the C colour handling so FIX() uses more bits of an int.
Deleted the unused remenants of light dithering in the 8bpp colour converter - saves a few cycles.
colour_convert_8 and colour_convert_16 no longer save entry registers the C compiler doesn't care about.
Update genyuvtabs to EXPORT the table bases.
Split out the compilation of IJG files as separate objects in the make file, rather than including them from within rojpeg, which is itself included from putscaled.

Version 1.38, 1.35.2.6. Tagged as 'SprExtend-1_38-1_35_2_6'
@
text
@d44 2
d779 1
a779 1
        IMPORT  panic_trace
@


4.21.2.2
log
@For completeness, implement the 2x2->8bpp and 2x2->16bpp colour conversions in C too.
While slower than their assembler equivalents it makes the whacky address generation a bit easier to follow.
Fix MakeFile to not stop when trying to deleted an empty directory.

Version 1.38, 1.35.2.7. Tagged as 'SprExtend-1_38-1_35_2_7'
@
text
@d323 1
a323 1
error_code      #       4       ; jpeg_decompress_struct
@


4.21.2.3
log
@Use USAT in 150 occurrences of colour clamping for ARMv6 and later.
Some IDCT renaming.
Shock addition of some documentation on how it all works.
Mirror fix from 1.39 on the trunk.
Debug
 Made DEBUG version compile again, earlier header shuffling was preventing it.
 Replaced the ' _ ' method of variadic macro emulation with more familiar double brackets for tracef().
 Eliminated IFDEBUG macro and just used #ifdef DEBUG/#endif or tracef() directly.
 Don't bother passing the line number and file name to exit() when in the non DEBUG case.

Version 1.38, 1.35.2.8. Tagged as 'SprExtend-1_38-1_35_2_8'
@
text
@d91 1
a91 1
        GBLL    jpeg                    ; JPEG decompression
d94 1
a94 1
        GBLL    dynamicarea             ; for storing JPEG workspace
d418 1
d427 1
d706 1
a732 4
      |
        ; no, it isn't
        MOV     r0,0
        STR     r0,is_it_jpeg
@


4.21.2.4
log
@New jerror.h taken from IJG8b.
Swap to using JERR_ numbers, deleted E_ numbers.
Modify genjhdr to pass some defines to the assembler code, so jdcolor can clarify use of DCTSIZE and DCTSIZE2.
Added chart of possible subsampling ratios to documentation.

Version 1.38, 1.35.2.9. Tagged as 'SprExtend-1_38-1_35_2_9'
@
text
@d323 1
a323 1
error_code      #       4               ; jpeg_decompress_struct
d333 1
a333 1
save_outoffset  #       4               ; reloaded from R12
d343 10
a352 10
save_inshift    #       4               ; <---!   this data is copied onto the stack
save_outword    #       4               ;     !   so that R12 can be re-used
save_outmask    #       4               ;     !
save_xsize      #       4               ;     !
save_xcount     #       4               ;     !
save_ecfptr     #       4               ;   --!   up to here is reloaded using LDMIA
save_ecflimit   #       4               ;     !
save_vcount     #       4               ;     !
save_xdiv       #       4               ;     !
save_xadd       #       4               ; <---!
d376 3
a378 3
                [ multibuffer   
pc_ecflimit0    #       nbuffers :SHL:2 ; addresses inside macro code
pc_outoffset0   #       nbuffers :SHL:2
d380 2
a381 2
calladdr20      #       nbuffers :SHL:2
calladdr0       #       nbuffers :SHL:2
d383 1
a383 1
pc_ecflimit     #       4               ; addresses inside macro code
d398 2
a399 2
vduspritepars   #       4+4             ; sprite code, areaCBptr ...
vduspritename   #       12              ; ... name
d415 15
a429 2
ccompiler_bitblockmove # 4              ; routine for C to call back into assembler.
calibration_table # 4                   ; printer calibration table
d431 1
a431 14
is_it_jpeg      #       4               ; BOOL - is this sprite JPEG?
ctrans_recent   #       4               ; BOOL - check for ColourTrans 1.25 or later
in_x            #       4               ; initial x coord in input sprite
in_y            #       4               ; initial y coord in input sprite
fetchroutine    #       4               ; routine for compiled code to call to get line of JPEG data.
save_sprite     #       4               ; the actual source sprite
jpeg_info_ptr   #       4               ; pointer to JPEG workspace - allocated from RMA if needed
area_number     #       4               ; dynamic area number
                                        
bgcolour        #       4               ; background colour, for plotting mask.
save_PdriverIntercept # 4               ; Flags used to determine if the pdriver is
                                        ; currently intercepting the JPEG plots.
                                        
dither_truecolour   #   4               ; do we dither true colour images when reducing BPP?
d433 2
a434 2
newtranstable   #       256 *4          ; buffer for pixel translation table
                                        ; or for palette converted to 16bpp...
d519 3
a521 3
sprite_doesnt_exist_error # 4           ; OSS Pointer to error block in RMA
ccompiler_sp    #       4               ; for unexpected jumps out of compiled C
ccompiler_errptr #      4               ; os_error pointer for if an OS error lead to exit from C code.
d532 1
a532 1
codebuffer      #       &200            ; still needed elsewhere
d539 1
a539 1
ccompiler_space #       &2400           ; C code checks at run-time for there being enough.
d732 1
a732 1
        MOV     r0,#0
@


4.21.2.5
log
@Remap return results for CFSI-JPEG to match new cinfo structure.
Tested with a handful of JPEGs and !ChangeFSI.

Version 1.38, 1.35.2.11. Tagged as 'SprExtend-1_38-1_35_2_11'
@
text
@d42 1
a42 1
        
d322 6
d330 1
a330 1
data_start      #       0
d448 1
a448 1
       ALIGNHASH        data_start,16
d472 1
a472 1
        ALIGNHASH       data_start,16
d499 1
a499 1
        ALIGNHASH       data_start,64
d528 1
a528 1
        ALIGNHASH       data_start,64
d542 1
a542 1
data_end        #       0
d649 1
a649 1
        LDR     R3,=data_end - data_start
@


4.21.2.6
log
@Push recent changes on the trunk to the IJG8b branch.
Tested briefly, still works.

Version 1.38, 1.35.2.15. Tagged as 'SprExtend-1_38-1_35_2_15'
@
text
@a39 1
        GET     Hdr:OSRSI6
d42 1
a42 1

a43 2
        EXPORT  exit
        EXPORT  exit_erl
d91 1
a91 1
        GBLL    jpeg                    ; jpeg decompression
d94 1
a94 1
        GBLL    dynamicarea             ; for storing jpeg workspace
d249 1
a249 1
$l      CheckAlignedAndWithin $sprite,$offset,$end,$temp,$failure
d252 1
a252 1
        BNE     $failure
d255 1
a255 1
        BHI     $failure                ; out of range
a257 9
        MACRO
$l      CheckAlignedAndSensible $addr,$failure
$l      TST     $addr, #3               ; word aligned?
        BNE     $failure
        CMP     $addr, #area_sensible   ; not too low?
        BLO     $failure
        MEND
        

a321 6
                ^       0
error_code      #       4       ; decompress_info_struct
error_argument1 #       4
error_argument2 #       4
workspace_UNUSED #      4
workspace_size  #       4
d324 1
a324 1
data            #       0
d327 1
a327 1
save_outoffset  #       4       ; reloaded from R12
d337 10
a346 10
save_inshift    #       4       ; <---!   this data is copied onto the stack
save_outword    #       4       ;     !   so that R12 can be re-used
save_outmask    #       4       ;     !
save_xsize      #       4       ;     !
save_xcount     #       4       ;     !
save_ecfptr     #       4       ;   --!   up to here is reloaded using LDMIA
save_ecflimit   #       4       ;     !
save_vcount     #       4       ;     !
save_xdiv       #       4       ;     !
save_xadd       #       4       ; <---!
d370 3
a372 3
                [ multibuffer
pc_ecflimit0    #       nbuffers :SHL: 2        ; addresses inside macro code
pc_outoffset0   #       nbuffers :SHL: 2
d374 2
a375 2
calladdr20      #       nbuffers :SHL: 2
calladdr0       #       nbuffers :SHL: 2
d377 1
a377 1
pc_ecflimit     #       4                       ; addresses inside macro code
d392 2
a393 2
vduspritepars   #       4+4         ; sprite code, areaCBptr ...
vduspritename   #       12          ; ... name
d409 2
a410 2
ccompiler_bitblockmove # 4      ; routine for C to call back into assembler.
calibration_table # 4           ; printer calibration table
d412 14
a425 14
              [ jpeg
is_it_jpeg      #       4       ; BOOL - is this sprite JPEG?
ctrans_recent   #       4       ; BOOL - check for ColourTrans 1.25 or later
in_x            #       4       ; initial x coord in input sprite
in_y            #       4       ; initial y coord in input sprite
fetchroutine    #       4       ; routine for compiled code to call to get line of JPEG data.
save_sprite     #       4       ; the actual source sprite
jpeg_info_ptr   #       4       ; pointer to JPEG workspace - allocated from RMA if needed
area_number     #       4       ; dynamic area number
              ]

bgcolour        #       4       ; background colour, for plotting mask.
save_PdriverIntercept # 4       ; Flags used to determine if the pdriver is
                                ; currently intercepting the JPEG plots.
d427 2
a428 4
dither_truecolour   #   4       ; do we dither true colour images when reducing BPP?

newtranstable   #       256 *4  ; buffer for pixel translation table
                                ; or for palette converted to 16bpp...
d442 1
a442 4
       ALIGNHASH        data,16

vdu_fgecforaeor #       4               ; Pointer to VDU drivers FgEcfOraEor
vdu_bgecforaeor #       4               ; Pointer to VDU drivers BgEcfOraEor
d466 1
a466 1
        ALIGNHASH       data,16
d493 1
a493 1
        ALIGNHASH       data,64
d513 3
a515 3
sprite_doesnt_exist_error # 4   ; OSS Pointer to error block in RMA
ccompiler_sp    #       4       ; for unexpected jumps out of compiled C
ccompiler_errptr #      4       ; os_error pointer for if an OS error lead to exit from C code.
d522 1
a522 1
        ALIGNHASH       data,64
d526 1
a526 1
codebuffer      #       &200 ;still needed elsewhere
d533 1
a533 1
ccompiler_space #       &2400   ; C code checks at run-time for there being enough.
d536 1
a536 1
enddata         #       0
d643 1
a643 1
        LDR     R3,=enddata-data
a664 17
        ; Get the ECF block pointers    
        MOV     R0,#6
        MOV     R1,#0
        MOV     R2,#OSRSI6_FgEcfOraEor
        SWI     XOS_ReadSysInfo
        MOVVS   R2,#0
        CMP     R2,#0
        MOVEQ   R2,#Legacy_VduDriverWorkSpace+Legacy_FgEcfOraEor
        STR     R2,vdu_fgecforaeor
        MOV     R0,#6
        MOV     R2,#OSRSI6_BgEcfOraEor
        SWI     XOS_ReadSysInfo
        MOVVS   R2,#0
        CMP     R2,#0
        MOVEQ   R2,#Legacy_VduDriverWorkSpace+Legacy_BgEcfOraEor
        STR     R2,vdu_bgecforaeor        

a697 1
        
d724 4
@


4.20
log
@Change memory management strategy.
There's no need for the C code to know which pool of memory it's using, so simplify it to just use malloc() and realloc(), the assembler implementation can then select whether the RMA or a dynamic area is in use based on the 'dynamicarea' switch.
Be more careful about area_number when it is zero, since we use that to denote the area is not yet set up but area zero is a valid dynamic area number!
Trim out some unused workspace.
Variable ccompiler_errptr had '# 0' bytes assigned, resulting in writes off the end of the workspace.
Retire DUMPVAL[N]() macro.
Remove M_SOF9 as one of the SOF markers accepted - this is allocated to arithmetic JPEGs which aren't currently supported.
Save a few words by: changing arbitrary constants (eg. safety margins) to be a power of two so they can be register immediates; numerous loads and stores of R12 relative variables changed to not use ADRL; jpeg_fetchroutine similarly simplified.

Version 1.33. Tagged as 'SprExtend-1_33'
@
text
@d39 2
a41 1
        GET     Hdr:PDriver
@


4.19
log
@Paper and fill some JPEG cracks.
The exit_c function was repeatedly being called with the line number argument and error code the wrong way round and since only bits 0-2 of the error code are inspected on exit any fatal exits from the ported JPEG library code would either report the wrong error or fail silently (depending on the line number) - example a 12 bits per sample JPEG would be rendered without fault into a screen full of random memory garbage.
Assembling/compiling with the 'jpeg' switch off didn't work, fixed, and also now zeros out the SWI decode values in the module header.
Moved include of 'yuvtabs.s' into the colour conversion code.
Deleted panic_exit, it did nothing useful but trace a value then exit, so it now just calls exit() like everyone else.
Removed excess call to find_image_dims(), this was needed just to get the workspace requirements when the JPEG had already been sized up by asm_find_image_dims() earlier. Side effect of removing the pilot JPEG code earlier is that this call can now only get to the JPEG code from a JPEG_ SWI. Changed to just pass the workspace requirements into 'c.PutScaled' and save a duplicate scan.
Fatal exits from the assembler huffman decoder now report a sensible error.
Trimmed out all the JPEG assessment code from 'c.PutScaled' and moved it into 'c.rojpeg' so the put scaled is only concerned with putting things scaled.
Sanitised the #includes a bit.
Fixed on last check of wp->save_mode looking at the wrong bits for the mode number.
Resolved all the warning in the genhdr/genyuvtabs/genpalette utilities by casting a bit harder.[A[B
Added new more descriptive error messages to the messages file (not currently used), and made the 'not supported by' ones consistent so the tokeniser might crunch the file a bit more.
In looks_like_jpeg() changed a bitwise to logical or.
Fixed longstanding problem of not being able to render JPEGs at a scale of less than 1/6 in any greyscale mode, because, err, there was no code to do it - only the colour case was checked for. Implemented for 8bpp grey and 32bpp grey (which gets dithered for other lower modes) by just converting the luma channel into an equally weighted RGB value or replicating it for 256 greys.
Tested in all 8 colour depths on a Risc PC using sampling ratios of 1x1; 2x1; 1x2; 2x2 of the IJG test image scaled in !Draw by 0.16.

Version 1.32. Tagged as 'SprExtend-1_32'
@
text
@d323 7
a405 2
                ; things MOVED to let ccompiler get at them.

a452 6
RAM_SpriteEntry #       12
Sprite_OScopy   #       4       ; copy of OS routine address
OSflag          #       4

       ALIGNHASH        data,16

d522 3
a528 3
sprite_doesnt_exist_error # 4   ; OSS Pointer to error block in RMA
                                ; AMG moved here to avoid an out of range error

a539 6

                [ multibuffer
                |
sprite_doesnt_exist_error # 4   ; OSS Pointer to error block in RMA
                ]

d542 1
a542 2
ccompiler_sp    #       4       ; for unexpected jumps out of compiled C
ccompiler_space #       9392    ; C code checks at run-time for there being enough.
a543 1
ccompiler_errptr #      0       ; os_error pointer for if an OS error lead to exit from C code.
d707 5
a711 3
        MOV     R7,#0
        ADRL    R6,ccompiler_space
        STR     R7,[R6]                   ; mark the ccompiler workspace clearly as uninitialised
d720 1
a720 1
        ; zero the workspace pointer for JPEG - allocated from RMA if needed
d722 2
a723 2
        ADRL    R2,jpeg_info_ptr
        STR     R0,[R2]
d726 1
a726 3
        MOV     r0, #0
        ADRL    r2, save_PdriverIntercept
        STR     r0, [r2]
d733 1
a733 2
        ADRL    r2, ctrans_recent
        STR     r0, [r2]
d735 1
a735 5
        ; initialise dithering off..
        MOV     r0, #0
        ADRL    r2, dither_truecolour
        STR     r0, [r2]
        
d758 1
a758 2
        ADRL    R1, area_number              ; dynamic area number
        LDR     R1, [R1]
d763 1
a763 3
        ; if JPEG workspace has been allocated, free it.
        ADRL    R2,jpeg_info_ptr
        LDR     R2,[R2]
d766 1
a766 1
        SWINE   OS_Module                  ; free block
@


4.18
log
@Remove pilot JPEG code.
During the original development (referred to in the docs as Sprite Extend 2) JPEG data was briefly wrapped inside a sprite file before the JPEG_ swis were introduced. Within SpriteExtend some code still remained to fake a mode 20 sprite header with the JPEG output sized adjusted as though it was 4bpp, then later undo the faking by checking for a mode 20 sprite with is_it_jpeg set.
This version removes all of the code looking out for pilot JPEGs, and rationalises the fake sprite header to just report the true X/Y size.
Fix bug where r4 would be corrupted on exit from JPEG_PlotScaled if an error occurred, and generally rationalised the exit cases a bit more sensibly.
Made the JPEG_ swi despatch a bit more simple to follow.
Corrected a comment in the NSM_bpptable.
Deleted unused 'ecfspace' from the workspace.
Hid the 'macroword' from the C code as it's now an assembler only value.
Cut the initial comments from c/putscaled and placed in Docs.
Cut the debug tracing code (a notable %age) from c/putscaled and placed in tracing support file.
Simplified the entry to putscaled_compiler() now we don't have to look out for pilot format JPEGs within sprites any more.
Sprinkled in some block comments to make navigating the c/putscaled file a bit easier.

Version 1.30. Tagged as 'SprExtend-1_30'
@
text
@a41 1
        IMPORT  find_image_dims
a42 4
        IMPORT  jpeg_find_line
        IMPORT  assembler_panic
        IMPORT  panic_exit
        EXPORT  create_dynamic_area
d44 1
a44 1
        EXPORT  exit_c
d153 1
d157 5
a735 5
      ]
        ; initialise dithering off..
        MOV     r0, #0
        ADRL    r2, dither_truecolour
        STR     r0, [r2]
d744 5
d792 6
a798 1
        GET     Sources.SWIs
@


4.17
log
@Remove postprocessing step of C code.
Since 2001 this module has been using objasm, but still using the C compiler to output (via -S) assembly code which is then passed through 'sed' and included via GET into the assembler code.
Changed to compile the C code into object files, and use the linker to patch up the unresolved references - this has required some reordering of the C code to make sure static functions now appear in the object file, and some reordering of the header files to ensure both the module and the CFSI version still compile without conflicts.
Minor fix to 'swiv2', the label was in the wrong place for _swi() though it's not used in this module so didn't affect the _swix() case.
Makefile cut down a bit. Unixify some path names.
Test code moved to 'Test/c' directory.
Tested in both debug and non debug cases via softloaded module. Oddly, it's 4 bytes longer than the previous version.

Version 1.28. Tagged as 'SprExtend-1_28'
@
text
@d319 1
a319 1
; Everything from here is down of interest to compiled C
a368 4
save_calladdr   #       4               ; points to 'l_start'
save_calladdr2  #       4               ; points to 'l_putword'

macroword       #       4
d433 1
a433 1
; Everything from here is up of interest to compiled C
a436 2
ecfspace        #       72

d441 2
@


4.16
log
@Panel beat with hammer of sanity.
Deleted c.SpriteOp to untangle it from c.rojpeg to draw boundary around JPEG code.
Moved all the OS_SpriteOp code out of SprExtend into a new file SprOp, so the main file just contains the usual macros/includes/module heading.
Added new 'debugso' switch for debugging SpriteOps, was previously using 'debuggs' which is supposed to be for JPEG leading to reams of confusing debug.
TestForMaskAtDepth was rejecting 8bpp sprites with masks due to testing against log2bpp (4) instead of sprite type (5).
NSM_bpptable re-encoded in bytes rather than words, accesses ammended accordingly.
Took fresh copy of swiv2 from RISCOS_Lib revision 4.7.
SpriteV interception made a bit simpler (& faster).
Fixes to validate sprite (SpriteOp 17):
 Was looking at the wrong bits of the mode word to test for old mode words.
 Added new test for DPI values being non zero.
 Algorithm more closely follows PRM.

Version 1.27. Tagged as 'SprExtend-1_27'
@
text
@d42 9
a204 13
        ; Enable use of cc -cpu 6 with an old version of objasm
        ; If your objasm understands v6 opcodes, it will ignore these macros
        ; Note the 3rd parameter is not implemented yet (not currently needed)
        MACRO
$lab    SXTH    $rd,$rm
$lab    DCI     &E6BF0070 :OR: ($rd :SHL: 12) :OR: $rm
        MEND

        MACRO
$lab    UXTH    $rd,$rm
$lab    DCI     &E6FF0070 :OR: ($rd :SHL: 12) :OR: $rm
        MEND

@


4.15
log
@Retire old compiler.
2000 lines of unloved code from 1993 deleted, binary still the same afterwards, so should be same as 1.25.

Version 1.26. Tagged as 'SprExtend-1_26'
@
text
@a16 3
        GBLL    StrongARM
StrongARM SETL  {TRUE}

a37 1
        GET     Hdr:Debugger
d42 3
a44 21
        AREA    |!!!ModuleHeader|, CODE, READONLY, PIC
Module_BaseAddr

; ---------------------------------------------------------------------------


        GBLL    debugmc
        GBLL    debugpt
        GBLL    debugmg
        GBLL    debugid
        GBLL    debugin
        GBLL    debugsc
        GBLL    debugsp
        GBLL    debugch
        GBLL    debugtr
        GBLL    debuger
        GBLL    debugmb
        GBLL    debugms
        GBLL    debugag
        GBLL    debuggs
        GBLL    debugcc
d47 1
a47 1
        GBLL    file
d49 1
a49 1
file    SETL    {TRUE}                  ; Where to output the debugging to
d51 1
a51 1
        [ :LNOT: :DEF: localmessages
d54 1
a54 1
        ]
d56 2
a57 2
        GBLL    AvoidScreenReads
AvoidScreenReads SETL    {TRUE}         ; When true, look out for BIC masks of FFFFFFFF and skip read
d74 1
a74 1
        [       flagbit                 ; table, overriding the effect of of med01867 if b4 of R5 on entry was set
d79 1
a79 1
        ]
d81 3
a83 3
        GBLL    widetrans
widetrans SETL  {TRUE}                  ; support for wide translation tables via R5 bit 5
        [       widetrans
d86 1
a86 1
        ]
d94 4
a97 1
        GBLL    usemull
d100 16
d120 2
a121 2
debugid SETL    debug :LAND: {TRUE}     ; insertdelete rows or columns
debugin SETL    debug :LAND: {TRUE}     ; input parameters
d123 2
a124 1
debugsp SETL    debug :LAND: {TRUE}     ; sprite parameters
d130 1
a130 1
debugag SETL    debug :LAND: {TRUE}     ; amg transient debugging - could be anywhere :-)
d132 5
a136 1
debugcc SETL    debug :LAND: {TRUE}     ; PutSpriteScaled compiler in C
d138 1
a138 1
; ----------------------------------------------------------------------------
d140 1
d142 1
a142 1
        DCD     0            ; Start
d150 2
a151 2
        DCD     SpriteExtend_SWIDecode   - Module_BaseAddr  ; MySWIDecode
        DCD     SpriteExtend_SWINames      - Module_BaseAddr  ; MySWINames
d156 1
a156 3
Title   =       "SpriteExtend"
EndTitle                        ; For length calculations for caching the
        =       0               ; "Sprite doesn't exist" error
a171 1

d185 1
a185 1
    [   "$tag" = ""
d187 1
a187 1
    |
d189 1
a189 1
    ]
d191 1
a191 1
    [   "$noalign" = ""
d193 1
a193 1
    ]
d252 9
a260 95
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Table of service calls we want
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        ASSERT  Service_ModeChange > Service_Reset
        ASSERT  Service_ResourceFSStarted > Service_ModeChange

ServiceTable

        DCD     0
        DCD     ServiceUrsula - Module_BaseAddr
        DCD     Service_Reset
        [ multibuffer
        DCD     Service_ModeChange
        ]
        DCD     Service_ResourceFSStarted
        DCD     0
        DCD     ServiceTable - Module_BaseAddr


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Service call handler
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Service
        MOV     r0, r0                  ; Indicates there is a service call table

        ; Fast rejection
        TEQ     r1, #Service_ResourceFSStarted
        [ multibuffer
        TEQNE   r1, #Service_ModeChange
        ]
        TEQNE   r1, #Service_Reset
        MOVNE   pc, lr

ServiceUrsula

        [ multibuffer
        TEQ     r1, #Service_ModeChange
        BEQ     modechange
        ]
        TEQ     r1, #Service_Reset      ; Re-initialise on soft reset
        BEQ     Init

; ** Drop through for territory started **

; OSS A new Territory has started, so I need to re-cache the error block

service_territory_started Entry "r0-r11"
        LDR     r12, [r12]
        BL      cache_sprite_doesnt_exist_error
        EXIT

        [ multibuffer

; one of the problems with using a quick 'n' fast algorithm like usage counts
; for deciding which routine needs replacing is that it has weaknesses. The
; specific weakness being dealt with here is that if a long time is spent in
; one mode then high usage counts will result for that mode. When a new mode
; is selected the new routines needed for that mode will fight over the remaining
; slots with a lower usage count. In worst case this will mean that new
; routines will be built on virtually every plot!
;
; there are two options for avoiding this. The first is to hold a time stamp
; to indicate when a routine was last used. This option has been rejected
; because of the overhead of calling the SWI. The second is to junk all the
; currently built routines on a mode change. This may result in some routines
; being rebuilt which have already been built, but will avoid the scenario
; outlined above.
;
; note that I am not clearing the associated macrowords for each routine - this
; should help to avoid too many needless rebuilds of routines

modechange
        Push    "R0-R2,R12,LR"

        ; zero the workspace pointer for JPEG - allocated from RMA if needed
        MOV     R0,#0
        ADRL    R2,jpeg_info_ptr
        STR     R0,[R2]

        LDR     R0,[R12]
        MOVS    R12,R0
        BEQ     modechange_nospace

        ADRL    R0,buffer0count
        MOV     R1,#((nbuffers :SHL: 2)-4)
        MOV     R2,#0
modechange_loop
        STR     R2,[R0,R1]
        SUBS    R1,R1,#4
        BPL     modechange_loop
        Debug   mb,"Clearing all usage counts on mode change"
modechange_nospace
        Pull    "R0-R2,R12,PC"
        ]

d263 1
a263 1
; Initialisation
a264 158
Init
        Push    "R0-R12,LR"
;
        LDR     R2,[R12]
        TEQ     R2,#0
        BNE     gotarea
;
        MOV     R0,#ModHandReason_Claim
        LDR     R3,=enddata-data
        SWI     XOS_Module
        BVS     initexitdie
        STR     R2,[R12]

; Set the error pointer to zero only if we are allocating the workspace.
; This is because on Service_Reset we have the workspace and we still have
; the old cached error block so zeroing the pointer would cause us to
; never free that block.

        MOV     r0, #0
        STR     r0, [r2, #:INDEX:sprite_doesnt_exist_error]
gotarea
        MOV     R12,R2
;
        MOV     R0,#-1
        STR     R0,inmode
        STR     R0,macroword

        MOV     R0,#0
        STR     R0,vduspritename

; OSS Attempt to cache the error. This may well fail, but we ignore the
; failure. We will get another go later on Service_TerritoryStarted and
; that time it should succeed.

        BL      cache_sprite_doesnt_exist_error
02
        [ multibuffer
        ; set up the buffer usage counts and current macrowords
        ADR     R4,buffer0mask
        ADR     R5,buffer0count
        MOV     R6,#0
        MOV     R7,#((nbuffers :SHL: 2)-4)
20
        STR     R6,[R4,R7]
        STR     R6,[R5,R7]
        SUBS    R7,R7,#4
        BPL     %BT20
        ]
        CLRV

;
        Claim   SpriteV,My_SpriteOp

        MOVVC   R0,#-1
        SWIVC   XOS_ChangedBox  ; R1 --> 5-word block for changed coords
        STRVC   R1,changedbox
;
        BLVC    readvduvars     ; read for later

      [ file
        Debug_Open "<Debug$File>"
      ]

        MOV     R7,#0
        ADRL    R6,ccompiler_space
        STR     R7,[R6]                   ; mark the ccompiler workspace clearly as uninitialised
        ADRL    r0,bitblockmove           ; ensure C code has access to bitblockmove
        STR     r0,ccompiler_bitblockmove

      [ jpeg
;        MOV     R7,#-1
;        ADRL    R6,jpeg_error_code
;        STR     R7,[R6]                    ; mark the jpeg workspace clearly as uninitialised
;        ADRL    R1,jpeg_space              ; base of workspace - a decompress_info_struct
;        ADRL    R2,jpeg_end
;        SUB     R0,R2,R1                   ; amount of space.
;        ADRL    R2,jpeg_workspace_size
;        STR     R0,[R2]                    ; store workspace size

        ; set up the fetchroutine, for use by any subsequent compiled code.
        ADRL    R2,jpeg_fetchroutine
        STR     R2,fetchroutine

        ; zero the workspace pointer for JPEG - allocated from RMA if needed
        MOV     R0,#0
        ADRL    R2,jpeg_info_ptr
        STR     R0,[R2]

        ; clear priver intercept flags....
        MOV     r0, #0
        ADRL    r2, save_PdriverIntercept
        STR     r0, [r2]
      ]
        ; initialise dithering off..
        MOV     r0, #0
        ADRL    r2, dither_truecolour
        STR     r0, [r2]

        ; check ColourTrans version is up to date
        ADR     r0, init_ctrans_check
        SWI     XOS_CLI
        MOVVS   r0, #0
        MOVVC   r0, #-1
        ADRL    r2, ctrans_recent
        STR     r0, [r2]
        
initexitdie
        STRVS   R0, [sp]
        Pull    "R0-R12,PC"

init_ctrans_check
        DCB     "RMEnsure ColourTrans 1.25 Error 1",0
        ALIGN

Die
        Push    "R0-R12,LR"
        LDR     R12,[R12]       ; R12 --> workspace

; OSS Free the cached "Sprite doesn't exist" error block - never
; returns errors.

        BL      free_sprite_doesnt_exist_error

      [ file
        Debug_Close
      ]

      [ jpeg
;        ; release the patched OS_ReadModeVariable SWI.
;        LDR     R0,=SvcTable+(OS_ReadModeVariable :SHL: 2)
;        LDR     R1,[R0]                    ; load current pointer
;        ADRL    R2,newReadModeVariable
;        CMP     R1,R2                      ; check still points to me
;        LDREQ   R1,oldReadModeVariable     ; if so, restore old handler
;        STREQ   R1,[R0]                    ; if not, we're probably dead anyway.
      [ dynamicarea
        ADRL    R1, area_number              ; dynamic area number
        LDR     R1, [R1]
        CMP     R1, #0
        MOVNE   R0, #1
        SWINE   XOS_DynamicArea
      |
        ; if JPEG workspace has been allocated, free it.
        ADRL    R2,jpeg_info_ptr
        LDR     R2,[R2]
        CMP     R2,#0
        MOVNE   R0,#ModHandReason_Free
        SWINE   OS_Module                  ; free block
      ]
      ]

        Release SpriteV,My_SpriteOp             ; OSS  Errors from this ARE returned
01
        B       initexitdie

;;----------------------------------------------------------------------------
;; Data areas & register allocation
;;----------------------------------------------------------------------------
a289 4
ecfeor          RN      R12             ; wsptr         ; im2
ecfora          RN      R11             ;               ; im1
ecfptr          RN      R10             ; masko         ; ttr

a291 19
vcount          RN      R7              ; xadd

zs              RN      R11
zf              RN      R10
zys             RN      R9
ycounter        RN      R8
xcounter        RN      R7
inputcell       RN      R6
flags           RN      R5
; outword       RN      R4
; outptr        RN      R3
z               RN      R2              ; Rc
zyf             RN      R1              ; Rb
Rc              RN      R2              ; z
Rb              RN      R1              ; zyf
Ra              RN      R0


bignum          *       &1000000
a321 1
          ^     0,R12
d323 1
a323 1
; If ccompiler in use then from here is of interest to compiled C
d325 2
a326 2
; matching changes in the C.

d378 5
a382 5
pc_ecflimit0     #       nbuffers :SHL: 2              ; addresses inside macro code
pc_outoffset0    #       nbuffers :SHL: 2
thisslot         #       4
calladdr20       #       nbuffers :SHL: 2
calladdr0        #       nbuffers :SHL: 2
d441 1
a441 1
; If ccompiler in use then up to here is of interest to compiled C
d443 1
a443 1
; matching changes in the C.
d542 2
a543 2
codebuffer0      #       nbuffers * &200
codebuffer       #       &200 ;still needed elsewhere
d545 1
a545 1
codebuffer       #       &200
d554 2
a555 2
; Private space for use by compiled C.
; If the C code needs more than this then this area must be extended.
d563 3
d567 2
a568 76
;;----------------------------------------------------------------------------
;; OS_SpriteOp decoding entry point
;; Entry: R0 = reason code
;;        R12 --> private word
;; Exit : R0-R7 may be used to contain results
;;----------------------------------------------------------------------------

My_SpriteOp ROUT

        Debug   gs, "Sprite Extend sprite op called...",r0
        Push    "R1"
        MOV     r1, #SpriteReason_CheckSpriteArea << 24
        CMP     r1, r0, LSL #24
        Pull    "R1"
        BEQ     SpriteOp_CheckSpr
        MOV     r0, r0, ROR #8
        CMP     r0, #myminreason << 24
        MOV     r0, r0, ROR #24
        MOVCC   pc, lr

SpriteOp_CheckSpr
        Push    "R10-R11,LR"
        STR     R13,stackframe          ; for calling OS_SpriteOp
;
        STR     R0,spritecode
        MOV     R14,#VduDriverWorkSpace + BgEcfOraEor
        STR     R14,save_ecflimit       ; mask plotting uses bg ecf pattern
;
        JumpAddress LR,My_SpriteExit,forward
        AND     R10, R0, #&FF
;First check for new SpriteReason_CheckSpriteArea
        CMP     r10, #SpriteReason_CheckSpriteArea
        BEQ     Go_CheckSpriteArea
;now carry on as before...
        SUB     r10, r10, #myminreason

        CMP     R10,#mymaxreason-myminreason
        ADDCC   PC,PC,R10,LSL #2
        Pull    "R10-R11, PC"           ; I don't know about bigger ones

mymaxreason     *       SpriteReason_ReadSaveAreaSize + 1
myminreason     *       SpriteReason_AppendSprite

jptable
        B       Go_AppendSprite         ; SpriteReason_AppendSprite
        B       Go_SetPointerShape      ; SpriteReason_SetPointerShape
        B       Go_CreateRemovePalette
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
;
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
        Pull    "R10-R11, PC"
;
        B       Go_PlotMaskScaled       ; SpriteReason_PlotMaskScaled
        B       Go_PaintCharScaled      ; SpriteReason_PaintCharScaled
        B       Go_PutSpriteScaled      ; SpriteReason_PutSpriteScaled
        B       Go_PutSpriteGreyScaled  ; SpriteReason_PutSpriteGreyScaled
;        Pull    "R10-R11, PC"           ; Disable SpriteReason_PutSpriteGreyScaled
        Pull    "R10-R11, PC"           ; (allow for SpriteReason_RemoveLefthandWastage)
        B       Go_PlotMaskTransformed  ; SpriteReason_PlotMaskTransformed
        B       Go_PutSpriteTransformed ; SpriteReason_PutSpriteTransformed
        B       Go_InsertDeleteRows     ; SpriteReason_InsertDeleteRows
        B       Go_InsertDeleteColumns  ; SpriteReason_InsertDeleteColumns

        Pull    "R10-R11, PC" ; 59
        Pull    "R10-R11, PC" ; SpriteReason_SwitchOutputToSprite
        Pull    "R10-R11, PC" ; SpriteReason_SwitchOutputToMask
        Pull    "R10-R11, PC" ; SpriteReason_ReadSaveAreaSize
d570 10
a579 2
;        Pull    "R10-R11, PC" ; SpriteReason_PutSpriteScaledCalibrated
;        Pull    "R10-R11, PC" ; SpriteReason_PutSpriteTransformedCalibrated
d581 3
a583 1
        ASSERT  (.-jptable) = (mymaxreason-myminreason) * 4
d585 2
a586 4
My_SpriteExit
        LDRVC   R0,spritecode
01
        Pull    "R10-R11,LR,PC"
d588 7
d596 7
a602 63
Go_SpriteOp
        Push    "R10-R12,LR"
01
        LDR     R10,stackframe
        Push    "PC"                    ; set up return address
        LDMIA   R10,{R10-R11,PC}        ; call rest of vector owners
        NOP                             ; returns here or next instruction
        Pull    "R10-R12,PC"

TestFor16or32bpp ROUT ; return vs if R2 points at a 16/32bpp sprite
        Push    "R0-R3,R11,LR"
        MOV     R11, #0
        B       %FT40

TestForMaskAnyDepth ; fault a new format sprite with mask
        Push    "R0-R3,R11,LR"
        LDR     R0,[R2,#spMode]
        MOVS    R0,R0,LSR #27
        LDMEQFD R13!,{R0-R3,R11,PC}
        B       %FT32

TestForMaskAtDepth ; fault a mask at 16/32bpp
        Push    "R0-R3,R11,LR"
        ;reject any T=5 or T=6 sprites which have a mask, and also (later) any
        ;attempts to add a palette to one
        MOV     R11,#1
40
        ;should be called after findsprite has been called

        LDR     R0,[R2,#spMode]
        CMP     R0,#256
        BCC     %FT10                   ; go if a screen mode number
        MOV     R0,R0,LSR #27           ; isolate the type alone
        CMP     R0,#4
        BCC     %FT20                   ; under 16bpp, so don't care
30
        CMP     R11,#0
        BEQ     %FT50
32
        LDR     R0,[R2,#spImage]
        LDR     R1,[R2,#spTrans]
        TEQ     R0,R1
        BEQ     %FT20                   ; no mask, so no complaints
50
        ADR     R0, ErrorBlock_BadDepth
        addr    R1, Title
        BL      copy_error_one          ; returns V set
        STR     R0,[R13]
        STR     R1,[R13,#4]
        Pull    "R0-R3,R11,PC"

        MakeSpriteErrorBlock BadDepth,,BadDepth
10
        ;it's a mode number
        Push    "R2"
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable
        BCS     %BT50
        CMP     R2,#4
        Pull    "R2"
        BCS     %BT30                   ; 16 or 32 bpp so check for a mask
20
        Pull    "R0-R3,R11,PC"
d604 7
a610 37
;;----------------------------------------------------------------------------
;; SpriteReason_CreateRemovePalette
;; --------------------------------
;;
;; in:  r0  = 37 (SpriteReason_CreateRemovePalette) (+0 / 256 / 512)
;;      r1 -> sprite control block
;;      r2 -> sprite name / sprite
;;      r3  = -1: read palette size
;;          =  0: remove palette
;;          <> 0: add palette (bit 31=1, add extended palette)
;;
;; out: V=1 => r0 -> error block
;;
;;      r3 =-1 on entry then r3  = size of palette block, =0 if none
;;                           r4 -> palette block, =0 if none
;;                           r5  = mode
;;----------------------------------------------------------------------------

Go_CreateRemovePalette
        Push    "r1-r11, lr"

        BL      findsprite              ; r2 -> sprite block
        Pull    "r1-r11, PC",VS

        CMP     r3, #-1
        BNE     addremoveit             ; skip read palette size

        ADD     r3, r2, #spImage
        LDMIA   r3, {r3, r4}            ; r3,r4 offsets to mask/image
        CMP     r3, r4
        MOVGT   r3, r4                  ; r3 -> top of palette block
        SUB     r3, r3, #spPalette      ; r3  = size of palette block
        MOVS    r3, r3, ASR #3          ; r3  = number of colours in palette block

        ADDNE   r4, r2, #spPalette      ; r4 -> palette block to return
        MOVEQ   r4, #0                  ; or  =0 if no palette
        LDR     r5, [r2, #spMode]       ; r5  = mode number
d612 1
a612 2
        ADD     lr, sp, #4*2            ; lr -> r3 in return frame
        STMIA   lr, {r3, r4, r5}
d614 17
a630 2
        CLRV
        Pull    "r1-r11, pc"
d632 2
a633 34
addremoveit
        TEQ     r3, #0                  ; remove the palette?
        BNE     addpalette

; remove palette, simple case, assuming r1 -> sprite control block, r2 -> sprite
; we must move the data in the sprite and then update the header followed by
; the control block.
;

removepalette
        LDR     r4, [r2, #spImage]      ; r4   = offset to image
        LDR     r5, [r2, #spTrans]      ; r5   = offset to trans mask
        CMP     r4, r5
        MOVGT   r4, r5                  ; r4   = offset to first part of sprite data

        LDR     r8, [r1, #saFree]       ; r8   = free index into sprite area

        SUBS    r0, r4, #spPalette      ; r0   = size of palette block, if none then exit!
        ADDNE   r9, r2, #spPalette
        ADDNE   r10, r1, r8             ; r10 -> free in sprite area
        BLNE    move_memory_down

        SUB     r8, r8, r0              ; adjust free space
        STR     r8, [r1, #saFree]

        LDR     r3, [r2, #spNext]       ; adjust next sprite pointer
        SUB     r3, r3, r0
        STR     r3, [r2, #spNext]

        ADD     r3, r2, #spImage        ; adjust offsets to image data
        LDMIA   r3, {r4, r5}
        SUB     r4, r4, r0
        SUB     r5, r5, r0
        STMIA   r3, {r4, r5}
d635 4
a638 2
        CLRV
        Pull    "r1-r11, pc"
d640 3
d644 10
a653 402
; add sprite palettes, this involves creating a gap for the sprite
; palette and then writing the actual data for the palette into this area
; these routines will use a general purpose function 'addpalette' taking
; r1,r2 as sprite pointers and r4 as a mask to be applied to the maximum
; number of colours.  This mask is used to generate the real number of
; colours written into the sprite header.
;

addpalette

; the test for 16/32bpp only occurs here, so that read palette size, and
; remove palette won't complain

        LDR     r0, [r2, #spMode]       ; r0  = mode
        MOVS    lr, r0, LSR #27         ; EQ for old format sprite, NE otherwise
        BEQ     %FT10

        ;now allow T=1 to T=4 to have palettes
        CMP     lr, #5
        BCC     %FT10

        ADR     r0, ErrorBlock_BadDepth
        addr    R1, Title
        BL      copy_error_one          ; this call sets V
        Pull    "r1-r11, PC",VS
10
        TST     r3, #1:SHL:31           ; add extended palette?
        MOVNE   r4, #255
        MOVEQ   r4, #63                 ; max colours that can be added

        Push    "r1-r2"

        LDR     r0, [r2, #spMode]       ; r0  = mode
        MOV     r1, #VduExt_Log2BPP
        SWI     XOS_ReadModeVariable    ; no need to check for CS here - will already
        ADR     r1, palettetables       ; have happened in TestFor16or32bpp
        LDR     r5, [r1, r2, ASL #2]    ; r5  = offset to palette tables
        ADD     r5, r5, r1              ; r5 -> absolute table
        MOV     r8, #2                  ; shift =2 as reading from table (single entries)

        MOV     r0, #1
        MOV     r1, r0, ASL r2
        RSB     r3, r0, r0, ASL r1      ; r3  = maximum number of colours
        AND     r4, r3, r4              ; r4  = maximum number of written colours

        Pull    "r1-r2"                 ; preserve sprite pointers

        ADD     r0, r4, #1
        MOV     r0, r0, ASL #3          ; r0 = size of a palette block

        ADD     r6, r2, #spImage
        LDMIA   r6, {r6, r7}            ; r6, r7 -> sprite, mask

        MOV     lr, r6
        CMP     lr, r7
        MOVGT   lr, r7                  ; lr =lowest offset

        SUBS    lr, lr, #spPalette      ; lr =size of current palette
        SUBNE   r0, r0, lr
        ADDNE   r5, r2, #spPalette      ; if adjusting size then modify from current palette
        MOVNE   r8, #3                  ; shift =3, reading from sprite palette (double entries)

        LDR     r9, [r1, #saFree]
        LDR     r10, [r1, #saEnd]
        ADD     r9, r9, r0              ; r9 => end of free area
        CMP     r9, r10                 ; is there enough room?
        BHI     add_no_room             ; no, so complain!

        STR     r9, [r1, #saFree]       ; store new offset to start of free area
        ADD     r10, r9, r1             ; r10 -> new start of free area
        SUB     r10, r10, r0            ; r10 -> old start of free area
                                        ;     =  end address+1 of block to move

        LDR     r9, [r2, #spNext]
        ADD     r9, r9, r0
        STR     r9, [r2, #spNext]       ; adjust the offset to next sprite

        ADD     r6, r6, r0
        ADD     r7, r7, r0
        ADD     r9, r2, #spImage
        STMIA   r9, {r6, r7}            ; stash updated image + mask offsets

        ADD     r9, r2, #spPalette      ; r9 -> start of current palette
        ADD     r9, r9, lr              ; r9 -> end of current palette+1
                                        ;    =  start address of block to move
        BL      move_memory_up

        ADD     r6, r2, #spPalette      ; r6 -> destination buffer
        ADD     r6, r6, r4, LSL #3
        LDR     r7, =&0F0F0F00          ; r7  = masked used when ensuring palette entries

; r1 -> sprite blk
; r2 -> sprite
; r3  = total colours (ie. 1, 3, 15, 255)
; r4  = number of colours to write ( 1, 3, 15, 63 / 255)
; r5 -> table containing base palette entries
; r6 -> block to write data into
; r7  = &0F0F0F00
; r8  = shift to use when getting palette entries

addpalette_main
        AND     r0, r4, #15
        ADD     r0, r5, r0, LSL r8
        LDR     r0, [r0]                ; r0 = BGR combination

        TEQ     r3, #255                ; is it a 8bpp palette?
        BNE     addpalette_gotvalues

        BIC     r0, r0, #&80000000      ; transfer hard blue bit
        AND     lr, r4, #&80
        ORR     r0, r0, lr, LSL #31-7
        BIC     r0, r0, #&00C00000      ; transfer hard green bit
        AND     lr, r4, #&60
        ORR     r0, r0, lr, LSL #23-6
        BIC     r0, r0, #&00008000      ; transfer hard red bit
        AND     lr, r4, #&10
        ORR     r0, r0, lr, LSL #15-4

        BIC     r0, r0, r7
        ORR     r0, r0, r0, LSR #4      ; change from &B0G0R00 -> &BBGGRR00

addpalette_gotvalues
        ORR     r0, r0, #&10
        STR     r0, [r6],#4
        STR     r0, [r6],#-12           ; write and advance index

        SUBS    r4, r4, #1
        BGE     addpalette_main         ; loop whilst colour counter >= 0

        Pull    "r1-r11, pc"

add_no_room
        ADR     r0, ErrorBlock_NotEnoughRoom
        addr    r1, Title
        BL      copy_error_one          ; Always sets the V flag
        Pull    "r1-r11, PC"

        MakeSpriteErrorBlock NotEnoughRoom,,NoMem

; tables for creating default palettes
;

palettetables
        DCD     bpp1 -palettetables
        DCD     bpp2 -palettetables
        DCD     bpp4 -palettetables
        DCD     bpp8 -palettetables

bpp1    DCD     &00000000       ;  black
        DCD     &FFFFFF00       ;  white

bpp2    DCD     &00000000       ;  black
        DCD     &0000FF00       ;  red
        DCD     &00FFFF00       ;  yellow
        DCD     &FFFFFF00       ;  white

bpp4    DCD     &00000000       ;  black
        DCD     &0000FF00       ;  red
        DCD     &00FF0000       ;  green
        DCD     &00FFFF00       ;  yellow
        DCD     &FF000000       ;  blue
        DCD     &FF00FF00       ;  magenta
        DCD     &FFFF0000       ;  cyan
        DCD     &FFFFFF00       ;  white
        DCD     &00000000       ;  black
        DCD     &0000FF00       ;  red
        DCD     &00FF0000       ;  green
        DCD     &00FFFF00       ;  yellow
        DCD     &FF000000       ;  blue
        DCD     &FF00FF00       ;  magenta
        DCD     &FFFF0000       ;  cyan
        DCD     &FFFFFF00       ;  white

bpp8    DCD     &00000000       ;  0000
        DCD     &10101000       ;  0001
        DCD     &20202000       ;  0010
        DCD     &30303000       ;  0011
        DCD     &00004000       ;  0100
        DCD     &10105000       ;  0101
        DCD     &20206000       ;  0110
        DCD     &30307000       ;  0111
        DCD     &40000000       ;  1000
        DCD     &50101000       ;  1001
        DCD     &60202000       ;  1010
        DCD     &70303000       ;  1011
        DCD     &40004000       ;  1100
        DCD     &50105000       ;  1101
        DCD     &60206000       ;  1110
        DCD     &70307000       ;  1111

        LTORG



;;----------------------------------------------------------------------------
;; SetPointerShape
;;----------------------------------------------------------------------------

; Entry:  R1 --> sprite area
;         R2 --> sprite name/address
;         R3 bits 0..3 = pointer shape number (1..4)
;         R3 bit 4 set => don't use the sprite's image
;         R3 bit 5 set => don't use the sprite's palette
;         R3 bit 6 set => don't set the current shape number afterwards
;         R4,R5 = coordinates of active point (pixels from top-left)
;         R6 --> factors (<=0 ==> use default, depending on mode)
;         R7 --> pixel translation table (==> 2 bpp)
;

spp_ptrno       *       2_00001111
spp_noimage     *       2_00010000
spp_nopalette   *       2_00100000
spp_nosetno     *       2_01000000


sillyname       DCB     "pointer",0
                ALIGN

tempareasize    *       &200

Go_SetPointerShape
        Push    "R10,R11,LR"
        Debug   gs,"Regs at start = ",R0,R1,R2,R3,R4
        Debug   gs,"                ",R5,R6,R7,R8,R9
;
        Debug   pt, "R3 = ",R3
        TST     R3,#spp_noimage
        BLEQ    go_setimage
        Pull    "R10,R11,PC",VS

        Debug   pt, "done setimage"
        TST     R3,#spp_nopalette
        BLEQ    go_setpalette
        Pull    "R10,R11,PC",VS

        Debug   pt, "done setpalette"
        TST     R3,#spp_nosetno
        BLEQ    go_setno

        Debug   pt, "done setno",R3
        LDRVC   R0, spritecode
        Debug   gs,"Regs at end   = ",R0,R1,R2,R3,R4
        Debug   gs,"                ",R5,R6,R7,R8,R9
        Pull    "R10,R11,PC"
go_setimage
        LDR     R0,spritecode
        Push    "R0-R7,LR"              ; may need to find sprite again
;
        Debug   pt,"Input sprite:",#spritecode,R1,R2
        BL      findsprite              ; R2 --> sprite definition

        BLVC    TestFor16or32bpp

        Debug   pt,"Input sprite address is:",R2
        MOV     R1,R2                   ; R1 --> sprite definition
        MOV     R11,R2                  ; R11 --> sprite definition

        Debug   gs,"gonna do a create sprite"
        LDRVC   R0,[R2,#spMode]
        BLVC    readspritevars          ; log2px/y
        BLVC    readvduvars             ; inlog2px/y, save_inlog2bpp
        BVS     %FT99
        Debug   gs,"still gonna do a create sprite"
;
        ASSERT  saEnd=0                 ; create area header for output sprite
        MOV     R14,#tempareasize       ; should be big enough
        STR     R14,[sp,-R14]!
        MOV     R14,#0
        STR     R14,[sp,#saNumber]
        MOV     R14,#saExten
        STR     R14,[sp,#saFirst]
        STR     R14,[sp,#saFree]
;
        Debug   gs,"definately still gonna do a create sprite"
        MOV     R0,#SpriteReason_CreateSprite   ; create output sprite
        ADD     R0,R0,#&100
        MOV     R1,sp
        ADRL    R2,sillyname
        MOV     R3,#0                   ; no palette
        MOV     R4,#32                  ; 32 pixels wide
        MOV     R5,#32                  ; 32 pixels high
        MOV     R6,#1                   ; mode 1 seems reasonable
        Debug   pt,"Output sprite:",R0,R1,R2,R3,R4
        SWI     XOS_SpriteOp
        Debug   gs,"returned from crezte swi"
        BVS     %FT96
        Debug   gs,"V not set"
96
        MOVVC   R0,#SpriteReason_SwitchOutputToSprite
        ADDVC   R0,R0,#&100
        MOVVC   R3,#0                   ; no save area
        SWIVC   XOS_SpriteOp            ; on exit R0-R3 = old params
        Debug   gs,"returned from swi"
        ADDVS   sp,sp,#tempareasize
        BVS     %FT99
        Debug   gs,"V not set"
;
        Push    "R0-R3"
        ADD     R14,sp,#4*4 + tempareasize + 1*4
        LDMIA   R14,{R1-R7}
        Debug   pt,"Recovered input params:",R1,R2,R3,R4,R5,R6,R7
;
        CMP     R6,#0
        LDMNEIA R6,{R2-R5}              ; user-supplied scaling
        BNE     %FT01
;
        MOV     R14,#1
        LDR     R2,inlog2px             ; if no R6, make up the values!
        MOV     R2,R14,LSL R2
        LDR     R3,inlog2py
        MOV     R3,R14,LSL R3
        LDR     R4,log2px
        MOV     R4,R14,LSL R4
        LDR     R5,log2py
        MOV     R5,R14,LSL R5
        LDR     R14,Log2bpp             ; double-pixel modes ...
        MOV     R4,R4,LSL R14           ; ... are not quite as they seem !
        LDR     R14,Log2bpc
        MOV     R4,R4,ASR R14
        LDR     R14,modeflags
        TST     R14,#Flag_HiResMono
        MOVNE   R4,R4,LSL #1            ; 1/2 width in hi-res mono
01
        Push    "R2-R5"
        MOV     R6,sp
;
        MOV     R0,#SpriteReason_PutSpriteScaled     ; plot input into output
        ADD     R0,R0,#&200
        MOV     R2,R11                  ; R2 --> sprite

        LDR     R3,[R2,#spLBit]         ; first bit number used
        RSB     R3,R3,#1                ; remember bits are inclusive
        LDR     R14,[R2,#spRBit]        ; R14 = no of bits used in r.h. word
        ADD     R3,R3,R14
        LDR     R14,[R2,#spWidth]       ; R14 = no of words in the middle + 1
        ADD     R3,R3,R14,LSL #5        ; R3 = total width (bits)
        LDR     R14,save_inlog2bpc
        MOV     R4,R3,LSR R14           ; R4 = width (pixels)
        Debug   pt,"Input sprite width =",R4
        SUB     R6,R6,#4
        BL      mulR4                   ; scale to output pixels
        ADD     R6,R6,#4
        RSBS    R3,R4,#32               ; R3 = x-coordinate to plot sprite at
        MOVLT   R3,#0                   ; keep lhs visible!

        LDR     R4,[R2,#spHeight]
        ADD     R4,R4,#1                ; R4 = input height (pixels)
        BL      mulR4
        Push    "R3,R4"                 ; R4 = height of pointer (pixels)

        MOV     R3,R3,LSL #2            ; sprite is in mode 1 (log2px = 2)
        MOV     R4,R4,LSL #2            ; sprite is in mode 1 (log2py = 2)
        RSB     R4,R4,#32*4             ; make top-left match up

        MOV     R5,#0

        LDR     R14,modeflags

        TEQ     R7,#0                   ; PRM 1-780 zero means no table supplied
        BNE     %FT05
        TST     R14,#Flag_HiResMono
        ADRNE   R7,hiresmonottr         ; use built in table iff R7=0 and in hi-res mono
05
        Debug   pt,"Input sprite address,x,y =",R2,R3,R4
        SWI     XOS_SpriteOp
        Pull    "R10,R11"               ; R10,R11 = xcoord,height
;
        ADD     R14,sp,#4*4             ; skip factor block
        LDMIA   R14,{R0-R3}             ; SwitchOutput back to old parameters
        Debug   pt,"Switching back to",R0,R1,R2,R3
        SWI     XOS_SpriteOp
;
        ADD     R2,sp,#8*4+saExten      ; R2 --> output sprite
        Debug   pt,"Output sprite address =",R2
        LDR     R5,[R2,#spImage]
        ADD     R14,R2,R5               ; R14 --> sprite image
        Debug   pt,"Output sprite image =",R14
        MOV     R5,#0                   ; stick in reason code (= 0)
        Push    "R5,R6,R14"             ; [sp + 8] = sprite ptr
        CMP     R11,#32
        MOVGT   R11,#32
        ADD     R1,sp,#2                ; need correct alignment
        STRB    R11,[R1,#3]
        MOV     R14,#16/2               ; R14 = width (bytes)
        STRB    R14,[R1,#2]
;
        ADD     R14,sp,#3*4 + 8*4 + tempareasize + 3*4
        LDMIA   R14,{R3-R5}             ; shape no, active X, active Y
        AND     R3,R3,#spp_ptrno        ; bottom 4 bits = shape no
        STRB    R3,[R1,#1]
        SUB     R6,R6,#4                ; fool it so x-values used
        BL      mulR4
        ADD     R4,R4,R10               ; allow for sprite origin
        STRB    R4,[R1,#4]
        MOV     R4,R5
        ADD     R6,R6,#4                ; fool it so y-values used
        BL      mulR4
        STRB    R4,[R1,#5]
;
      [ debugpt
        LDMIA   sp,{R3-R5}
        Debug   pt,"OS_Word block =",R3,R4,R5
a654 104
        MOV     R0,#OsWord_DefinePointerAndMouse
        SWI     XOS_Word
        ADD     sp,sp,#3*4 + 8*4 + tempareasize   ; correct stack
99
        LDR     R14,[sp],#4
        STR     R14,spritecode          ; may be needed later
        Pull    "R1-R7,PC"

hiresmonottr    DCB     0,1,3,3         ; translate colour 2 into colour 3
                ALIGN


go_setpalette
        Push    "R1-R5,LR"
;
        Debug   pt,"Input sprite:",#spritecode,R1,R2
        BL      findsprite              ; R2 --> sprite definition
        Debug   pt,"Input sprite address:",R2
        LDRVC   R0,[R2,#spMode]
        MOV     R1, R2
        BLVC    readspritevars          ; get save_inlog2bpp
        Pull    "R1-R5,PC",VS
;
        MOV     R14,#1
        LDR     R5,save_inlog2bpp
        MOV     R5,R14,LSL R5           ; R5 = no of elements in ttr table
;
        MOV     R3,#3                   ; start with colour 3
01
        TEQ     R7,#0                   ; PRM 1-780 zero means no table supplied
        MOVEQ   R4,R3                   ; substitute 1:1 translation
        BEQ     %FT03                   ; got colour
        MOV     R4,#0
02
        LDRB    R14,[R7,R4]
        TEQ     R14,R3                  ; found it?
        BEQ     %FT03
        ADD     R4,R4,#1
        CMP     R4,R5                   ; R5 = no of entries in table
        BCC     %BT02
        B       %FT04                   ; don't bother programming palette
03
        Debug   pt,"Programming palette entry",R4
        MOV     R14,#spPalette+1        ; point at RGB of first flash state
        ADD     R4,R14,R4,LSL #3        ; 8 bytes per palette entry
        LDR     R14,[R2,#spImage]
        CMP     R14,R4                  ; is there a palette entry for this?
        BLE     %FT04
        SWI     XOS_WriteI+19           ; program palette
        MOV     R0,R3
        SWI     XOS_WriteC              ; mouse colour number
        SWI     XOS_WriteI+25           ; program mouse colour
        ADD     R0,R2,R4
        MOV     R1,#3
        SWI     XOS_WriteN              ; R,G,B
04
        SUBS    R3,R3,#1
        BNE     %BT01                   ; forget colour 0
;
        Pull    "R1-R5,PC"

go_setno
        Push    "R1-R3,LR"
;
        MOV     R0,#&6A
        AND     R1,R3,#spp_ptrno        ; pointer shape
        MOV     R2,#0                   ; pointer linked to mouse
        SWI     XOS_Byte
;
        Pull    "R1-R3,PC"


;
; Entry:  R4 = input coordinate (pixels)
;         R6 --> scale factors ([R6,#4] and [R6,#12])
; Exit:   R4 = R4 * R6!4 / R6!12
;

mulR4
        Push    "R5,R11,LR"
;
        LDR     R14,[R6,#1*4]           ; y-magnification
        MUL     R11,R14,R4
        LDR     R5,[R6,#3*4]            ; y-division
        DivRem  R4,R11,R5, R14          ; R4 = output height
;
        Pull    "R5,R11,PC"


;;----------------------------------------------------------------------------
;; PaintChar
;;----------------------------------------------------------------------------

; Entry:  R1 = character code
;         R3,R4 = x,y coordinates
;         R6 --> scale factors

areahdr
        DCD     spriteAreaSize
        DCD     1
        DCD     spriteCB - areaCB
spritehdr
        DCB     "character",0,0,0       ; Note - 12 chars long exactly
        ALIGN
d656 3
a658 141
Go_PaintCharScaled
        Push    "R1-R9,LR"
;
        STRB    R1,charblock
        ADRL    R1,charblock
        MOV     R0,#OsWord_ReadCharacterDefinition
        SWI     XOS_Word
;
        BLVC    readvduvars
        BVS     exitchar
;
; contruct a sprite header in module workspace
;
        MOV     R10, #0
        MOV     R11, #7                 ; Mode 0 sprite starting uses bits 0-7
;
        ADR     R14,areahdr             ; 3 words for area header,
        LDMIA   R14,{R1-R3,R6-R8}       ; and 3 for sprite name
        MOV     R5,#spriteSize+4*8*2    ; R5 = 44 + 2*8 rows of 1 word
        ADD     R4,R5,#spriteCB-areaCB  ; R4 = saFree
        ADR     R14,areaCB
        Debug   ch,"areaCB = &",R14
        STMIA   R14!,{R1-R3,R4,R5,R6-R8,R10}    ; up to spWidth
        MOV     R8,#7                   ; R8 = spHeight (no of rows - 1)
        MOV     R9,#0                   ; R9 = spLbit
        STMIA   R14!,{R8,R9,R11}        ; R11 = spRbit
        MOV     R8,#spriteSize
        ADD     R9,R8,#4*8              ; R9 = R8 + 8 rows of 1 word
        MOV     R11, #0                 ; mode 0 sprite
        STMIA   R14!,{R8,R9,R11}        ; R14 --> sprite pixels
        SUB     R7,R9,R8
        ADD     R7,R14,R7               ; R7 --> sprite mask
;
; now construct a sprite mask from the character definition
;
        ADRL    R10, charblock+1
        MOV     R5, #8
01
        LDRB    R9, [R10], #1
        MOV     R8, R9, LSR #7
        TST     R9, #&40
        ORRNE   R8, R8, #&02
        TST     R9, #&20
        ORRNE   R8, R8, #&04
        TST     R9, #&10
        ORRNE   R8, R8, #&08
        TST     R9, #&08
        ORRNE   R8, R8, #&10
        TST     R9, #&04
        ORRNE   R8, R8, #&20
        TST     R9, #&02
        ORRNE   R8, R8, #&40
        TST     R9, #&01
        ORRNE   R8, R8, #&80
        STR     R8, [R7], #4
        SUBS    R5, R5, #1
        BNE     %BT01
;
; now set up the parameters for a scaled mask plot
;
        MOV     R14,#VduDriverWorkSpace + FgEcfOraEor
        STR     R14,save_ecflimit       ; char painting uses fg ecf pattern
;
        ADR     R1,areaCB
        ADD     R2,R1,#spriteCB-areaCB
        ADD     R14,R13,#2*4            ; salvage params from stack
        LDMIA   R14,{R3-R7}
;
        MOV     R0,#&200                ; indicates that R2 --> sprite defn
        ADD     R0,R0,#SpriteReason_PlotMaskScaled
;
        LDR     R14,spritecode
        Push    "R14"
        STR     R0,spritecode
        MOV     r0, #SpriteReason_PaintCharScaled
        BL      Go_PlotMaskScaled
        Pull    "R14"
        STR     R14,spritecode

exitchar
        Pull    "R1-R9,PC"

;
; Read Vdu Variables
; also process the ones that the OS doesn't always provide
;

vduinputbuffer
        DCD     VduExt_XEigFactor               ; log2 pixels per unit (x)
        DCD     VduExt_YEigFactor               ; log2 pixels per unit (y)
        DCD     VduExt_Log2BPP                  ; for no. of colours
        DCD     VduExt_Log2BPC                  ; for double-pixel modes

        DCD     VduExt_OrgX
        DCD     VduExt_OrgY
        DCD     VduExt_GWLCol                   ; graphics window
        DCD     VduExt_GWBRow
        DCD     VduExt_GWRCol
        DCD     VduExt_GWTRow

        DCD     VduExt_LineLength
        DCD     VduExt_ScreenStart
        DCD     VduExt_YWindLimit

        DCD     VduExt_ModeFlags                ; for hi-res mono checking

        DCD     -1

readvduvars
        Push    "R0-R4,LR"
 ;
; read real vdu variables (mode is only required for PaintChar)
;
        ADR     R0,vduinputbuffer
        ADR     R1,vduoutputbuffer
        SWI     XOS_ReadVduVariables
        BVS     %FT99
;
        MOV     R0,#1
        LDR     R14,Log2bpc
        MOV     R14,R0,ASL R14
        STR     R14,BPC                 ; bpc = 2^log2bpc
        LDR     R14,Log2bpp
        MOV     R14,R0,ASL R14
        STR     R14,BPP                 ; bpp = 2^log2bpp
;
        Debug   sc,"ScreenStart,YWindLimit,LineLength,bpc =",#screenstart,#ywindlimit,#linelength,#BPC
99
        STRVS   R0,[R13]
        Pull    "R0-R4,PC"

;
; read mode-specific info for mode (R0)
;

readspritevars

        ; NB saved registers extended to include R3 purely for jpeg.
        ; R0=the sprite's mode word
        ; R1->the sprite
        Push    "R1-R3,LR"
d660 2
a661 2
      [ jpeg
      [ {TRUE}
d663 3
a665 182
        ; look for a JPEG sprite, and if you find it lie about these dimensions.
        LDR     R2,[R1,#spImage]        ; get offset to image data
        ADD     R2,R2,R1                ; get address of image data
        ADD     R2,R2,#4                ; skip past compression ID word

;        LDRB    R3,[R2,#6]              ; get 6th byte
;        CMP     R3,#'J'                 ; give me a J?
;        BNE     rsv_not_jpeg_file
;        LDRB    R3,[R2,#7]              ; if so, get 7th byte
;        CMP     R3,#'F'                 ; give me a F?
;        LDREQB  R3,[R2,#8]              ; if so, get 8th byte
;        CMPEQ   R3,#'I'                 ; give me a I?
;        LDREQB  R3,[R2,#9]              ; if so, get 9th byte
;        CMPEQ   R3,#'F'                 ; give me a F?
;        BNE     rsv_not_jpeg_file       ; what does that spell?
; This test is watered down a bit, to allow slightly more deviant files
; (eg. the ones that Tony Sumner finds on the net). Anything really wrong will
; still get caught later on in the C code. Still, note this increases (slightly)
; the risk that an innocent normal sprite will get accused of being JPEG.
; Alternative test:
        LDRB    R3,[R2]                 ; load first byte
        CMP     R3,#&ff                 ; is it ff?
        LDREQB  R3,[R2,#1]              ; load second byte
        CMPEQ   R3,#&d8                 ; is it d8?
        LDREQB  R3,[R2,#2]              ; load third byte
        CMPEQ   R3,#&ff                 ; is it ff?
        BNE     rsv_not_jpeg_file

        ; We have found a JPEG file - pretend it's a 32bpp sprite.
        Debug   in,"It's a JPEG file"
        LDR     R3,spritecode           ; check we're doing a PutSpriteScaled
        AND     R3,R3,#255              ; mask out to get op code
        CMP     R3,#SpriteReason_PutSpriteScaled
        Pull    "R1-R3,LR",NE           ; if not, discard stuff from readspritevars
        Pull    "R0-R12,PC",NE          ; and exit doing nothing.
                                        ; >>>> should produce an error return here.

        MOV     R3,#5                   ; log2 of 32
        STR     R3,save_inlog2bpc
        STR     R3,save_inlog2bpp
        MOV     R3,#32                  ; bits per pixel
        STR     R3,save_inbpp
        MOV     R3,#1                   ; log2 of 2 OS-units
        STR     R3,inlog2px             ; pretend to be VGA-size pixels
        STR     R3,inlog2py             ; pretend to be VGA-size pixels
        STR     R3,is_it_jpeg           ; mark as a JPEG sprite
        STR     R0,inmode               ; the mode vars are correct for mode 20 (old format) or new format compressed sprites.
        STR     R1,save_sprite          ; so that later code can find the JPEG data again
        Pull    "R1-R3,PC"
      ;  Pull    "R1-R3,LR"
      ;  B       jpeg_scan               ; initialise for this JPEG file, using R2.
rsv_not_jpeg_file
        ; if the last sprite was jpeg but this one is not then we MUST reload the sprite variables.
        LDR     R3,is_it_jpeg           ; was the last one JPEG? 0 -> not JPEG
        CMP     R3,#0
        MOVNE   R3,#0                   ; if the previous one was JPEG
        STRNE   R3,is_it_jpeg           ;   mark as not a JPEG sprite this time
        MOVNE   R14,#-1                 ;   force reload of sprite mode vars
        LDREQ   R14,inmode              ; else, vars reflect this sprite's mode
      |
        MOV     R14,#0                  ; jpeg stuff outside jpeg condition? stupid? (GPS)
        STR     R14,is_it_jpeg          ; ditto
        LDR     R14,inmode              ; check for sprite vars already right
      ]
      ]
;
        TEQ     R0,R14
        Pull    "R1-R3,PC",EQ           ; already have these variables!
        STR     R0,inmode
;
        MOV     R1,#VduExt_Log2BPC
        SWI     XOS_ReadModeVariable
        SETV    CS

        STRVC   R2,save_inlog2bpc       ; input log2(bytes per char)
        MOVVC   R1,#VduExt_Log2BPP
        SWIVC   XOS_ReadModeVariable
        STRVC   R2,save_inlog2bpp       ; input log2(bits per pixel)
        MOVVC   R1,#VduExt_XEigFactor
        SWIVC   XOS_ReadModeVariable
        STRVC   R2,inlog2px
        MOVVC   R1,#VduExt_YEigFactor
        SWIVC   XOS_ReadModeVariable
        STRVC   R2,inlog2py
        Pull    "R1-R3,PC",VS
;
        MOV     R14,#1
        LDR     R1,save_inlog2bpp
        MOV     R14,R14,ASL R1
        STR     R14,save_inbpp
;
        Debug   in,"Input log2bpc/p, bpp = ",#save_inlog2bpc,#save_inlog2bpp,#save_inbpp
;
        Pull    "R1-R3,PC"

;
; Find sprite address given areaCBptr/name
; Entry:  [spritecode] = reason code (including bits above bit 7)
;         R1 = areaCBptr
;         R2 --> sprite name
; Exit:   R2 --> sprite definition
;

findsprite
        Push    "LR"
        LDR     R0,spritecode
        BL      getspritename
        BLVC    getspriteaddr
        Pull    "PC"

; Entry:  R0 = original sprite code

getspritename
        Push    "R0-R1,R3-R4,LR"
;
        BICS    R14,R0,#&FF             ; R0 < 256 ==> system sprite (can't!)
        TEQ     R14,#&200               ; R2 --> sprite already
        STREQ   R2,spritename           ; if so, 1st word is sprite addr
        BEQ     %FT99
;
        ADRL    R3,spritename
        ADD     R4,R3,#12
01
        LDRB    R0,[R2],#1
        CMP     R0,#32+1                ; ignore <space> too!
        BCC     %FT02
        CMP     R0,#"A"
        RSBCSS  R14,R0,#"Z"
        ORRCS   R0,R0,#&20              ; force lower-case
        STRB    R0,[R3],#1
        CMP     R3,R4                   ; terminate after 12 characters
        BCC     %BT01
02
        MOV     R0,#0
03
        CMP     R3,R4                   ; pad with nulls
        STRCCB  R0,[R3],#1
        BCC     %BT03
99
        STRVS   R0,[R13]
        Pull    "R0-R1,R3-R4,PC"
        MakeSpriteErrorBlock NoWorkSpace,,NoWork

;
; scan the sprite list to find the address
;

getspriteaddr
        Push    "R1,R3-R9,LR"
;
        BICS    R14,R0,#&FF             ; R0 < 256 ==> system sprite (can't!)
        BNE     %FT00
;
        MOV     R0,#3
        SWI     XOS_ReadDynamicArea
        TEQ     R1,#0
        ADREQ   R0, ErrorBlock_NoWorkSpace   ; can't do anything with this!
        addr    r1, Title, EQ
        BLEQ    copy_error_one          ; Always sets the V bit
        BVS     %FT99
;
        MOV     R1,R0                   ; R1 -> system sprite area
        STR     R1,[sp]                 ; return for AppendSprite
00
        TEQ     R14,#&200               ; R2 --> sprite already
        BEQ     %FT99
;
        ADRL    R14,spritename
        LDMIA   R14,{R3,R4,R5}
;
        LDR     R14,[R1,#saFree]
        ADD     R9,R1,R14               ; R9 --> free area
        LDR     R14,[R1,#saFirst]
        ADD     R2,R1,R14               ; R2 --> first sprite
04
        CMP     R2,R9
      [ debuger
        BCC     %FT01
        ADR     R14,spritename
        DebugS  er,"Sprite doesn't exist ",R14
01
      ]
d667 5
a671 237
        BLCS    get_sprite_doesnt_exist_error  ; r0-> error block, V set
        BVS     %FT99
;
        LDMIA   R2,{R1,R6,R7,R8}       ; get link plus name
        TEQ     R6,R3
        TEQEQ   R7,R4
        TEQEQ   R8,R5
        ADDNE   R2,R2,R1
        BNE     %BT04
99
        Pull    "R1,R3-R9,PC"

; makepalette16bpp
; convert palette to 16bpp for output to 16bpp mode plotting directly from palette
; if this is not done, the spriteextend blitter will run out of registers!
makepalette16bpp
   [ debuggs
        Push    "R1-R7,LR"
        LDR     r7, sprite_doesnt_exist_error
        Debug   gs, "converting palette..."
   |
        Push    "R1-R6,LR"
   ]
        LDR     r1, save_inbpp
        MOV     r2, #1
        MOV     r1, r2, LSL r1        ; number of entries in palette
        Debug   gs, "going to do this many entries = ",R1
        LDR     r2, trns_palette      ; pointer to palette data
        ADRL    r3, newtranstable     ; where to store altered palette
        STR     r3, trns_palette      ; where to store altered palette
01
        LDR     r4, [r2], #8
        MOV     r4, r4, LSR #8                ; BBGGRR00 to 00BBGGRR
                                              ; r4 = in2, r5 = im1, r6 = ttr
                                              ;       fedcba9876543210 fedcba9876543210
                                              ; in2 = 00000000bbbbbbbb ggggggggrrrrrrrr
        AND     r5,r4,#&F80000                ; im1 = 00000000bbbbb000 0000000000000000
        MOV     r6,r5,LSL #7                  ; ttr = 0bbbbb0000000000
        AND     r5,r4,#&F800                  ; im1 = 0000000000000000 ggggg00000000000
        ORR     r6,r6,r5,LSL #10              ; ttr = 0bbbbbggggg00000
        AND     r5,r4,#&F8                    ; im1 = 0000000000000000 00000000rrrrr000
        ORR     r4,r6,r5,LSL #13              ; in2 = 0bbbbbgggggrrrrr
    ; NB result in top half of register
    ; Needs two work registers
        MOV     r4, r4, LSR #16
        Debug   gs, "gonna store thingy at thingy",R4,R3
        STR     r4, [R3],#4
        SUBS    r1, r1, #1
        Debug   gs, "R1 now ",R1
        BNE     %BT01
   [ debuggs
        ; check workspace word at end of 'newtranstable' space to confirm we haven't walked off the edge
        LDR     r6, sprite_doesnt_exist_error
        Debug   gs, "converted palette...check words are ",R6, R7
        Pull    "R1-R7,PC"
   |
        Pull    "R1-R6,PC"
   ]

;
; PutSpriteScaled
; Entry:  [spritecode] = reason code
;         R1 --> areaCBptr
;         R2 --> sprite name
;         R3,R4 = coords
;         R5 = gcol action (0 ==> no mask, 1 ==> use mask)
;         R6,R7 = x,y scaling (pixels per pixel)
;

        MakeInternatErrorBlock DivZero
diverror
        ADR     R0, ErrorBlock_DivZero
        addr    r1, Title
        BL      copy_error_one          ; Always sets the V bit

exitbiggie
        Pull    "R1-R9,PC"

; *****************************************************************************
Go_PutSpriteGreyScaled
        Push    "LR"
        SETV
        ADR     R0, ErrorBlock_NoGrScl
        BL      copy_error_one
        Pull    "PC"

        MakeSpriteErrorBlock NoGrScl

; *****************************************************************************
Go_PlotMaskScaled
        Push    "R1-R9,LR"
;        Push    "R0-R9,LR"              ; R0 pulled just below
;       MOV     r2,r0
;       Debug   gs,"Plot Mask Scaled"
;        ; Get the graphics background plot colour - temporarily uses R1,R2,R3
;        ADR     R0,getbgcolour
;        ADR     R1,bgcolour
;        SWI     XOS_ReadVduVariables
;
;; find current background plotting action
;       CMP     r2, #SpriteReason_PaintCharScaled
;        ADREQ   R0,getfgaction
;        ADRNE   R0,getbgaction
;        ADR     R1,bgcolour
;        SWI     XOS_ReadVduVariables
;       LDR     r5, bgcolour
;       ORR     r5, r5, #8                  ; avoid masko being knackered later
;;      Debug   gs, "Plot action is ",R5
;;
;       AND     r2, r2, #255
;       CMP     r2, #SpriteReason_PaintCharScaled
;       MOVEQ   r0, #&80
;       MOVNE   r0, #&90
;       ADRL    r1, ecfspace
;        SWI     XOS_SetColour
;;      Debug   gs, "setcolour returned, r0, r1=",r0,r1
;;;        LDR     r0, [r1]
;;;        Debug   gs, "ecfpattern1 =",r0
;;;        LDR     r0, [r1,#4]
;;;        Debug   gs, "ecfpattern2 =",r0
;        ANDS    r0, r0, #&20            ; is it a pattern block
;;;        CMP     r0, #0
;       STRNE   r1, save_ecflimit
;;;        STRNE   r1, save_ecfptr
;        MOVNE   r1, #-1
;;        MOV   r1, #-1
;        STR     r1, bgcolour
;
;        Pull    "R0"                    ; pull temporary workspace
;        LDMIA   sp,{R1,R2}              ; restore values of R1,R2
;        BVS     exitbiggie

        MOV     R5,#8                   ; avoid masko being knackered later
        MOV     R7,#0                   ; no pixel translation
        MOV     R8,#0                   ; no calibration table
        B       %FT01

getbgaction
        DCD     VduExt_GPLBMD
        DCD     -1

getfgaction
        DCD     VduExt_GPLFMD
        DCD     -1

getbgcolour
        DCD     VduExt_GBCOL
        DCD     -1

        MakeSpriteErrorBlock BadTranslation,,BadTran

; *****************************************************************************

Go_PutSpriteScaled
        Push    "R1-R9,LR"
        MOV     R8,#0                   ; no printer calibration table
01
        Debug   in,"Draw sprite: R0,R1,R2 =",R0,R1,R2
        Debug   in,"Coords, gcol, &scale, &ttr =",R3,R4,R5,R6,R7
        Debug   in,"Calibration table =",R8

;
        CLRPSR  I_bit, R14              ; re-enable interrupts
        [       flagbit
        MOV     R14, R5, LSR #4
        STR     R14, trns_flags2         ; store flags
        [ widetrans
        Debug   gs,"flags are ",R14
        BICS    R14, R14, #flg2_ignorettr + flg2_widetrans + flg2_ditheron
        |
        BICS    R14, R14, #flg2_ignorettr + flg2_ditheron
        ]
        Debug   gs,"flags are ",R14
        ADRNEL  R0, ErrorBlock_BadFlags
        addr    r1, Title, NE
        BLNE    copy_error_one          ; Always sets the V bit
        BVS     exitbiggie
        ]
        AND     R5,R5,#&0F              ; only bottom 4 bits are interesting

        STR     R8,calibration_table

;
; Check to see if truecolour sprites should be dithered
;
        [       flagbit
        LDR     r0, trns_flags2
        TST     r0, #flg2_ditheron
        MOVEQ   r0, #0
        MOVNE   r0, #1
        STR     r0, dither_truecolour
        ]
;
; see if reason code indicated a sprite name or sprite pointer in R2
;

        BL      findsprite              ; R2 --> sprite

        MOVVC   R1,R2                   ; now R1 --> sprite

; read input/output mode variables

        BLVC    readvduvars
        LDRVC   R0,[r1,#spMode]
        BLVC    readspritevars
        BVS     exitbiggie
        Debug   cc,"read sprite vars",R1

putsprscaled_frompjs
        LDR     R0,[R1,#spMode]         ; get sprite's original mode
        STR     R0,save_spr_type
;
; read scaling factors (set up default if necessary)
;
        CMP     R6,#0
        LDMNEIA R6,{R8-R11}
        BNE     %FT01
; Old source tries to rig scale factors which is opposed to
; what the PRM says.... Therefore I have changed it. (GPS)
;        MOV     R0,#1
;        LDR     R8,inlog2px
;        MOV     R8,R0,LSL R8
;        Debug   gs,"r8:",r8
;        LDR     R9,inlog2py
;        MOV     R9,R0,LSL R9
;        Debug   gs,"r9:",r9
;        LDR     R10,log2px
;        MOV     R10,R0,LSL R10
;        Debug   gs,"r10:",r10
;        LDR     R11,log2py
;        MOV     R11,R0,LSL R11
;        Debug   gs,"r11:",r11
        MOV     R8, #1
        MOV     R9, #1
        MOV     R10, #1
        MOV     R11, #1
01
d673 4
a676 206
;      [ jpeg
;        ; If jpeg we lie from here on, claiming there are twice as many pixels in the x direction
;        ; as the sprite contains, in case we want to do interpolation.
;        LDR     R14,is_it_jpeg               ; 1 -> JPEG sprite
;        CMP     R14,#0
;        MOVNE   R10,R10,LSL #1               ; if JPEG, double xdiv and so halve the scale factor
;      ]
;let's try to rationalise the scale factors...
; *************************************************
; ***  DivRem - Integer division and remainder  ***
; ***  rc := ra DIV rb; ra := ra REM rb         ***
; ***  rb preserved, rtemp corrupt              ***
; ***  DivRem   rc, ra, rb, rtemp               ***
; *************************************************
        Push    "R5-R7"
        MOV     R5, R8
        DivRem  R7, R5, R10, R6
        CMP     R5, #0
        MOVEQ   R8, R7
        MOVEQ   R10, #1
        MOV     R5, R9
        DivRem  R7, R5, R11, R6
        CMP     R5, #0
        MOVEQ   R9, R7
        MOVEQ   R11, #1
        Pull    "R5-R7"

        STR     R8,save_xmag
        STR     R9,save_ymag
        STR     R10,save_xdiv
        STR     R11,save_ydiv
        Debug   in,"x mag/div, y mag/div:",r8,r9,r10,r11

        [ ignore_ttr
;
; check for a ttr. If it's present and the sprite has a full entry palette set up to
; use that instead.
;
        MOV     R14, #0
        STR     R14, trns_palette

        LDR     R14,[R1,#spImage]
        CMP     R14,#SpriteCBsize
        BEQ     has_no_palette

        LDR     R0,[R1,#spTrans]
        CMP     R0,#SpriteCBsize
        BEQ     has_no_palette

        ;validate it (to exclude 8bpp without full palettes)
        ;test is that palette size should be 8*ncolours

        ;find the lower of the sprite start and mask start
        CMP     R14,R0
        MOVCS   R14,R0
        SUB     R14,R14,#SpriteCBsize

        MOV     R14,R14,LSR #3 ;divide by 8 for number of palette entries
        MOV     R0,#1
        LDR     R9,save_inbpp
        MOV     R0,R0,ASL R9

        CMP     R0,R14
        BNE     has_no_palette

        [       flagbit
        LDR     R14, trns_flags2
        Debug   gs,"Checking ttr flag", R14
        TST     R14, #flg2_ignorettr

;        B       has_no_palette   ;19th April 1994 remove 8bpp behaviour
        BEQ       has_no_palette   ;use ttr and ignore any palette

;        BNE     %FT01
;        [       med01867
;        CMP     R9, #8
;        BNE     has_no_palette ;restrict it to 8bpp full palette only
;        ]
01
        |
;        [       med01867
;        CMP     R9, #8
;        BNE     has_no_palette ;restrict it to 8bpp full palette only
;        ]
        Debug   gs,"ttr flag is not set"
        B       has_no_palette
        ]
        Debug   gs, "We're going to plot from palette"
        LDR     R14,[R1,#spTrans]
        ADD     R14,R1,#SpriteCBsize
        STR     R14, trns_palette
        LDR     R14, BPP
        CMP     R14, #16
        MOVEQ   r7, #0                   ; junk any translation table we were given to stop checktrans overwriting 16bpp palette
        BLEQ    makepalette16bpp
has_no_palette
       ]

;
; validate supplied translation table (if any)
;
        Debug   cc,"about to check trans table",R1
        CMP     R7,#0                    ; 0 ==> no translation
        BLNE    checktrans
        BVS     exitbiggie
        Debug   cc,"trans table is OK",R1
        [ ignore_ttr
; if doing a sprite of <16bpp to >8bpp, and it has a palette, change the ttr pointer
; to point at the palette data instead of the ttr data. Note that the two are different
; formats, so there is also a different plotting routine to include too...

        LDR     R14, BPP                               ; output bpp
        CMP     R14, #16
        MOVCC   R14, #0
        STRCC   R14, trns_palette
        BCC     %FT45
        LDR     R14, save_inbpp
        CMP     R14, #16
        MOVCS   R14, #0
        STRCS   R14, trns_palette
        BCS     %FT45
        LDR     R14, trns_palette
        TEQ     R14, #0
        MOVNE   R7,R14
        MOVEQ   R14,#0
        STREQ   R14, trns_palette ;only non-zero if going to use this

; trns_palette doubles as a pointer to the palette up this far, and then becomes a
; compilation flag for the macro generation (with the value being passed in as the
; ttr address)

45
        ]
;

        STR     R7,ColourTTR
        CMP     R7,#0
        BNE     notrans
;
        LDRB    R14,spritecode          ; R14 = bottom 8 bits of reason code
        TEQ     R14,#SpriteReason_PlotMaskScaled
      [ jpeg
;        TEQNE   R14,#SpriteReason_PutJPEGScaled    ; null table OK for this call
        LDRNE   R14,is_it_jpeg
        CMPNE   R14,#1
        Debug   gs,"1. is it JPEG?",R0
      ]
        LDRNE   R14,save_inbpp
        LDRNE   R0,BPP
        TEQNE   R14,R0                  ; OK if same bpp or mask plotting

        ;however, don't error if going 16>32 or 32>16
        BEQ     notrans ;dispose of the equal case

        CMP     R0,#16
        CMPEQ   R14,#32
        BEQ     notrans

        CMP     R0,#32
        CMPEQ   R14,#16
        BEQ     notrans
errtrans
        ADRL    R0,ErrorBlock_BadTranslation   ; different bpp ==> must have table
errexitscaled
        addr    r1, Title
        BL      copy_error_one          ; Always set the V bit
        Debug   gs,"error from trans table"
        BVS     exitbiggie
notrans
        Debug   gs,"Checked out trans table palette"
;
; try to optimise by using existing sprite plot code
; can only be done if bpp equal, no trans, no scaling and output not to sprite
;
      [ debug
        TEQ     R7,#0
        LDREQ   R14,save_inbpp
        LDREQ   R0,BPP
        TEQEQ   R14,R0                  ; if same bpp, try to optimise

        LDREQ   R14,vduspritename
        TEQEQ   R14,#0
        LDR     R6,save_xmag            ; load always!
        LDR     R7,save_ymag            ; load always!
        LDREQ   R8,save_xdiv
        LDREQ   R9,save_ydiv
        TEQEQ   R6,R8
        TEQEQ   R7,R9
        BNE     %FT87
87
      |
        TEQ     R7,#0
        LDREQ   R14,save_inbpp
        ANDS    R7, R14, #32+16         ; If we're dealing with deep sprites then the kernel is slower!!!
        LDREQ   R0,BPP
        TEQEQ   R14,R0                  ; if same bpp, try to optimise
;
        LDREQ   R14,vduspritename
        TEQEQ   R14,#0
        LDR     R6,save_xmag            ; load always!
        LDR     R7,save_ymag            ; load always!
        LDREQ   R8,save_xdiv
        LDREQ   R9,save_ydiv
        TEQEQ   R6,R8
        TEQEQ   R7,R9
        BNE     cantdoinOS
d678 4
a681 242
      [ jpeg
        LDREQ   R0,is_it_jpeg
        TEQEQ   R0,#0
        Debug   gs,"is it JPEG?",R0
        BNE     cantdoinOS
      ]
;
; if all parameters are ineffective, call the OS routine!
;
        LDR     R0,spritecode
        AND     R14,R0,#&FF             ; R14 = reason code only
        BIC     R0,R0,#&FF              ; R0 = code except for reason code
        TEQ     R14,#SpriteReason_PutSpriteScaled
        ORREQ   R0,R0,#SpriteReason_PutSpriteUserCoords
        BEQ     %FT01
        TEQ     R14,#SpriteReason_PlotMaskScaled
        ORREQ   R0,R0,#SpriteReason_PlotMaskUserCoords
        LDREQ   R14,save_ecflimit       ; is this background plotting?
        TEQEQ   R14,#VduDriverWorkSpace + BgEcfOraEor
        BNE     cantdoinOS
01
        LDMIA   R13,{R1,R2}             ; get original R1,R2
        Debug   gs,"doing it in OS"
        BL      Go_SpriteOp             ; call the OS version if there is one
        Pull    "R1-R9,PC"
cantdoinOS
      ]
        Debug   gs,"we can't do it in OS"
;
; convert coords to internal pixels
; R6,R7 = x,y magnification
;
        LDR     R14,orgx
        ADD     R3,R3,R14
        LDR     R14,log2px
        MOV     R3,R3,ASR R14
        LDR     R14,orgy
        ADD     R4,R4,R14
        LDR     R14,log2py
        MOV     R4,R4,ASR R14           ; convert to internal form
;
; bodge x-coords (inc. graphics window) so we can forget double-pixels
;
        LDR     R14,Log2bpc
        LDR     R0,Log2bpp
        SUBS    R14,R14,R0
        MOVNE   R3,R3,LSL R14
        LDRNE   R0,gwx0
        MOVNE   R0,R0,LSL R14
        STRNE   R0,gwx0
        LDRNE   R0,gwx1
        ADDNE   R0,R0,#1                ; make exclusive
        MOVNE   R0,R0,LSL R14
        SUBNE   R0,R0,#1                ; make inclusive again
        STRNE   R0,gwx1
;
; bodge x multiplier and divisor
;
        MOVNE   R6,R6,LSL R14
        STRNE   R6,save_xmag
;
        LDR     R14,save_inlog2bpc
        LDR     R0,save_inlog2bpp
        SUBS    R14,R14,R0
        LDRNE   R0,save_xdiv
        MOVNE   R0,R0,LSL R14
        STRNE   R0,save_xdiv
;
; R8, [save_ysize] <-- size of sprite in pixels (NOT double-pixels)
;
        LDR     R11,save_inlog2bpp      ; R11 = log2 ( bpp )
;
        LDR     R0,[R1,#spLBit]
        Debug   gs, "spLBit is ? = ",R0
        LDR     R2,[R1,#spRBit]
        Debug   gs, "spRbit is ? = ",R2
        SUB     R2,R2,R0
        ADD     R2,R2,#1                ; make inclusive
        Debug   gs, "R2 is ? = ",R2
        LDR     R0,[R1,#spWidth]
        Debug   gs, "Spwidth = ",R0
        ADD     R8,R2,R0,ASL #5         ; 32 bits per word
        Debug   gs, "R8 = ",R8
      [ jpeg
        ; >>> old-format (ie pilot development) JPEG files are mode 20 sprites, with JPEG data.
        ; For such a sprite the 'width' is quoted as if log2bpp were 2, ie 4bpp sprites,
        ; so that Draw gets the right width for the sprite. But this means we must shift
        ; right by 2 rather than by r11, which will be 5.
        Debug   gs, "X-size 1 = ",R8
        LDR     R14,is_it_jpeg
        CMP     R14,#0
        MOVEQ   R8,R8,ASR R11
        BEQ     %FT01
        ; It's JPEG - check for mode 20 or other.
        LDR     R14,inmode
        CMP     R14,#20
        MOVEQ   R8,R8,ASR #2            ; temp format - ASR by 2
        MOVNE   R8,R8,ASR R11           ; kosher new Medusa Sprite format - ASR by 5
        Debug   gs, "X-size 2 = ",R8
        ; >>>> This option can be thrown away when we're sure that pilot-format JPEG files
        ;      don't exist any more.

;        ; Finally, JPEG files claim to have twice as many pixels as they actually do.
;        ; This is in case we want to do interpolation in the X direction on scaling up.
;        MOV     R8,R8,LSL #1            ; R8 = no of pixels
1
      |
        MOV     R8,R8,ASR R11           ; R8 = no of pixels
      ]
        STR     R8,save_inputxsize
;
        Debug   gs, "X-size 3 = ",R8
        LDR     R14,[R1,#spHeight]
        ADD     R14,R14,#1
        STR     R14,save_inputysize
;
;
; do x-clipping
; Entry:  R6 = x-magnification
;         R8 = input x-size
; Exit:   R9 = xleft
;         [save_xcoord] = start x-coord on screen
;         [save_xcount] = initial xcount
;         [save_xsize] = output x-size
;
        Debug   cc,"Do x-clipping",r6,r8

        LDR     R14,gwx0
        SUBS    R9,R14,R3
        MOVLT   R9,#0                   ; R9 = no of pixels to skip on left
        ADD     R14,R3,R9
        STR     R14,save_xcoord
;
        MUL     R2,R8,R6                ; R2 = x-size * x-mag
        LDR     R0,save_xdiv            ; R0 = x-div
        TEQ     R0,#0
        BEQ     diverror
        DivRem  R8,R2,R0, R14           ; R8 = no of output pixels
        LDR     R14,gwx1
        ADD     R14,R14,#1
        SUB     R14,R14,R3
        CMP     R8,R14                  ; clip on right
        MOVGT   R8,R14
        SUBS    R8,R8,R9                ; R8 = number of output pixels
        BLE     exitbiggie              ; none of sprite is visible
        STR     R8,save_xsize
;
        LDR     R14,save_xdiv
        MUL     R10,R9,R14              ; R10 = initial count
        TEQ     R6,#0
        BEQ     diverror
        DivRem  R9,R10,R6, R14          ; R9 = initial INPUT pixel coord
        RSB     R10,R10,R6              ; R10 = amount of 1st input pixel left
        STR     R10,save_xcount
;
        Debug   in,"xcoord,xleft,xcount,xsize =",#save_xcoord,R9,#save_xcount,#save_xsize
;
; do y-clipping
; Entry:  [save_inputysize] = input y-size
; Exit:   R10 = ybot
;         [save_ycoord] = start y-coord on screen
;         [save_ycount] = initial y-counter
;         [save_ysize] = output y-size
;
        Debug   cc,"Do y-clipping",r10
        LDR     R14,gwy0
        SUBS    R10,R14,R4
        MOVLT   R10,#0                  ; R10 = no of pixels to skip at bottom
        ADD     R14,R4,R10
        STR     R14,save_ycoord
;
        LDR     R8,save_inputysize
        MUL     R2,R8,R7                ; R2 = y-size * ymag
        LDR     R0,save_ydiv
        TEQ     R0,#0
        BEQ     diverror
        DivRem  R8,R2,R0, R14           ; R8 = no of output pixels
        LDR     R14,gwy1
        ADD     R14,R14,#1
        SUB     R14,R14,R4
        CMP     R8,R14
        MOVGT   R8,R14
        SUBS    R8,R8,R10               ; number of output pixels
        BLE     exitbiggie
        STR     R8,save_ysize
;
        LDR     R14,save_ydiv
        MUL     R8,R10,R14              ; R8 = initial count
        TEQ     R7,#0
        BEQ     diverror
        DivRem  R10,R8,R7, R14          ; R10 = initial INPUT pixel y-coord
        RSB     R8,R8,R7                ; R8 = amount of first input pixel left
        STR     R8,save_ycount
;
        Debug   in,"ycoord,ybot,ycount,ysize =",#save_ycoord,R10,#save_ycount,#save_ysize
;
; update ChangedBox coords (if enabled)
; Entry:  [save_xcoord],[save_ycoord],[save_xsize],[save_ysize] set up
;
        LDR     R14,changedbox          ; read in initialisation routine
        LDR     R0,[R14],#4
        TST     R0,#1                   ; enabled?
        BEQ     %FT01
;
        Push    "R3-R10"
        LDR     R3,save_xcoord          ; coordinate after clipping
        LDR     R4,save_ycoord          ; ditto
        LDR     R5,save_xsize           ; size in output pixels
        LDR     R6,save_ysize           ; ditto
        LDR     R7,Log2bpc
        LDR     R8,Log2bpp
        SUBS    R7,R7,R8
        MOVNE   R3,R3,ASR R7            ; unbodge double-pixel stuff
        MOVNE   R5,R5,ASR R7
        ADD     R5,R3,R5
        ADD     R6,R4,R6
        SUB     R5,R5,#1                ; make inclusive
        SUB     R6,R6,#1
        LDMIA   R14,{R7-R10}            ; original box
        CMP     R7,R3
        MOVGT   R7,R3
        CMP     R8,R4
        MOVGT   R8,R4
        CMP     R9,R5
        MOVLT   R9,R5
        CMP     R10,R6
        MOVLT   R10,R6
        STMIA   R14,{R7-R10}            ; new box
        Pull    "R3-R10"
01
;
; get input address and shift
; Entry:  R9,R10 = initial input pixel coord (within sprite)
;         R11 = input log2bpp
; Exit:   [save_inptr] --> first input word
;         [save_inshift] = initial bit position
;         [save_inoffset] = length of 1 sprite row (bytes)
;         [save_masko] = offset from image to mask (0 ==> none)
;         [save_maskinshift] = initial mask bit position
;         [save_maskinptr] => first mask word
;         [save_maskinoffset] = length of 1 mask row (bytes)
;
d683 3
a685 7
; for a JPEG sprite we'll need the actual coordinates, not the computed
; address, for the input data.
      [ jpeg
        Debug   cc,"input coords",R9,R10
        STR     R9,in_x
        STR     R10,in_y
      ]
d687 2
a688 1
; set up things for 1bpp masks too - we decide later whether to use it
d690 3
a692 175
        AND     R14,R9,#31              ; mask is 1bpp, and there's no lh wastage
                                        ; so this is a lot simpler!
        STR     R14,save_maskinshift    ; save the inshift value for later

        Push    "R9"                    ; save unadjusted R9 for later

        LDR     R14,[R1,#spLBit]
        ADD     R9,R14,R9,LSL R11       ; R9 = initial bit position
        AND     R14,R9,#31
        STR     R14,save_inshift
;
        LDR     R14,[R1,#spImage]
        [ debuggs
        MOV     R0, R14
        Debug   gs,"Sprite Image at", R0
        ]
        ADD     R14,R1,R14              ; R14 --> sprite image
        LDR     R0,[R1,#spTrans]
        ADD     R0,R1,R0                ; R0 --> sprite mask
        Debug   gs,"Sprite mask at", R0
        TST     R5,#8
        MOVEQ   R0,R14                  ; R0=R14 ==> no mask
        SUBS    R0,R0,R14
        BICEQ   R5,R5,#8                ; R5 bit 3 ==> is there a mask?
        STR     R0,save_masko
;
        LDR     R2,[R1,#spHeight]
        SUB     R10,R2,R10              ; R10 = no of rows from top

        LDR     R3,save_inputxsize      ; number of pixels(==number of bits)
        ANDS    R4,R3,#&1F              ; R4=number of bits
        MOVNE   R4,#1                   ; R4=1 if R3 MOD 31 is not zero
        ADD     R4,R4,R3,LSR #5         ; R4=number of words
        MOV     R4,R4,ASL #2            ; R4=number of bytes for full row
        STR     R4,save_maskinoffset

        LDR     R2,[R1,#spWidth]
        ADD     R2,R2,#1
        MOV     R2,R2,ASL #2            ; R2 = line length
        STR     R2,save_inoffset

        MOV     R9,R9,ASR #5            ; R9 = word offset

        Pull    "R3"                    ; pull unaltered R9 from earlier
        MOV     R3,R3,ASR #5

        ADD     R11,R0,R3,ASL #2        ; R11= mask addr + byte offset
        MLA     R3,R10,R4,R11           ; R3= #rows * bytes_per_row + maskaddr & byteoffset
                                        ; R3=> first mask input word
        LDR     R11,[R1,#spImage]
        ADD     R3,R3,R11
        ADD     R3,R3,R1
        STR     R3,save_maskinptr
        Debug   gs, "Maskinptr is = ",R3
;
        ADD     R14,R14,R9,ASL #2
        MLA     R14,R10,R2,R14          ; R14 --> first input word
        STR     R14,save_inptr
;

; note that this points at the start of the last row of the sprite!

        Debug   in,"inptr,inshift,inoffset,masko =",#save_inptr,#save_inshift,#save_inoffset,#save_masko
;
; get output address and shift
; Entry:  [save_x/ycoord] = output x,y coord
;         [screenstart], [ywindlimit], [linelength] set up
; Exit:   [save_outptr] --> output address
;         [save_outword] = initial marker bit position
;         [save_outoffset] = line length
;
        LDR     R3,save_xcoord
        LDR     R4,save_ycoord
        LDR     R11,Log2bpp                     ; R11 = output log2(bpp)
;
        LDR     R14,ywindlimit
        SUB     R4,R14,R4                       ; R4 = no of rows down from top
        LDR     R2,save_ecflimit
        ADD     R14,R2,R4,ASL #3                ; R14 = offset into ecf table
        ADD     R14,R14,#8                      ; R14 --> initial ecf position
        STR     R14,save_ecfptr
;
        LDR     R14,linelength
        STR     R14,save_outoffset
        LDR     R2,screenstart
        MLA     R10,R14,R4,R2                   ; R10 = R2 + (R14 * R4)
        MOV     R3,R3,ASL R11
        AND     R14,R3,#31                      ; R14 = initial bit posn in word;
        MOV     R3,R3,ASR #5
        ADD     R10,R10,R3,ASL #2               ; R10 --> output address
        STR     R10,save_outptr
;
        MOV     R0,#&80000000
        MOV     R0,R0,LSR R14                   ; R0 = initial marker bit
        STR     R0,save_outword
;
        Debug   in,"Outptr, outword =",#save_outptr,#save_outword


;;----------------------------------------------------------------------------------------------------------------
;;
;; Register summary:
;;
;;       R0      R1      R2      R3      R4      R5      R6      R7      R8      R9      R10     R11     R12
;;       ------  ------  ------  ------  ------  ------  ------  ------  ------  ------  ------  ------  ------
;;               spriteptr       xcoord  ycoord  gcol    x-mag   y-mag
;;       -x-             -x-     R3      R4              R6      R7      -x-     -x-     -x-     log2bpp
;;    outoffset  inoffset                ydiv    yadd                    ysize   ycount
;;               inshift
;;       in1     in2     inptr   outptr  outword outmask xdiv    xadd    xsize   xcount  masko   bpp     inmask
;;
;;       in1     in2     inptr   outptr  outword outmask xdiv    xadd    xsize   xcount  ttr     bpp     inbpp
;;                                                       -x-     -x-                     ecfptr  ecfora  ecfeor
;;----------------------------------------------------------------------------------------------------------------

;
; compute xadd, yadd
;
        ASSERT  yadd<>R6
        STR     R7,save_yadd            ; yadd = size of input pixels (y-mag)
        LDR     R14,save_xdiv
        ADD     xadd,R14,R6             ; xadd = save_xdiv + xmag
        STR     xadd,save_xadd
;
        MOV     R14,#-1                 ; bit set ==> don't touch!
        STR     R14,save_outmask
        MOV     R14,#0
        STR     R14,save_vcount         ; bodge for 1st row

        B       new_putscaled_compiler

;;-----------------------------------------------------------------------------
;; Function to validate the pixel translation table, remapping as required
;; to take into account depth changes etc.
;;
;; in   R7 -> pixtrans table supplied to call
;; out  R0 -> error block (V set)
;;      R7 -> pixtrans table (may have been relocated!)
;;-----------------------------------------------------------------------------

; The following rules apply:
;
;    1/2/4/8 to 1/2/4/8 bpp   : no change
;          8 to   16/32 bpp   : use mungeGCOL8toXX routine, applied here
;      16/32 to 1/2/4/8 bpp   : only valid table is a CTrans 32K table providing 5 bit mappings
;         16 to      16 bpp   : no table allowed
;         32 to      32 bpp   : no table allowed
;      16/32 to   32/16 bpp   : no table, but a munge function will be applied instead
;                               (nb, this is called during plotting, since there's no table
;                               to modify in advance)
;
;    ColourTrans uses the following structure for the return from Select/GenerateTable:
;
;    Word 0 : &33324B2E "32K."
;    Word 4 : Pointer to the 32K table
;    Word 8 : &33324B2E "32K."
;

checktrans Entry

        LDR     LR,save_inbpp
        MOV     R8,#1
        MOV     R8,R8,ASL LR            ; R8 = number of input colours
        LDR     R9,BPP                  ; R9 = output depth
        MOV     R10,#0                  ; R10 = index / counter

        CMP     LR,#16
        BCC     checktrans1             ; branch if input is 8bpp or below

        ;now check out the following:
        ; 16 -> 16 : \                  ;
        ; 32 -> 32 :  \__ A table should never be used, however if one is presented
        ; 16 -> 32 :  /   it will be discarded but not faulted here.
        ; 32 -> 16 : /
        ; 16/32 -> 8 or lower : table must be CTrans 32K type
d694 15
a708 2
        CMP     R9,#16
        BCS     checktrans_ignorettr
d710 2
a711 149
        ;this is 16/32 to 8/lower, so check for a 32K table
      [ jpeg
        ; JPEG possibility - might get 32bpp data into small target, with no table.
        LDR     LR,is_it_jpeg
        TEQ     LR,#0                     ; 0 -> not JPEG
        BNE     checktrans_exitok
      ]
        LDR     LR,word32k
        LDR     R8,[R7,#0]
        CMP     R8,LR
        BNE     checktrans_giveerror
        LDR     R8,[R7,#8]
        CMP     R8,LR
        BNE     checktrans_giveerror
        B       checktrans_exitok

checktrans_ignorettr
        MOVS    R7,#0
        B       checktrans_exitok

word32k =       "32K."

checktrans1
        CMP     R9,#16                  ; are we outputting to >= 16 bit per pixel
        BLT     checktrans_old          ; if not then ignore the remapping

; For backwards compatibility we attempt to remap the colours by taking the GCOL
; byte which is in VIDC 1 format and convert it to a word value sensible for this
; depth of display.

; The functions which decode this byte now look for a word value which is then
; combined into the scan line being rendered.

        Push    "R0-R2,R9"
        LDR     R9,Log2bpp
        SUB     R9,R9,#3                ; convert the output Log2 bpp into a sensible index for conversion
        [ widetrans
        ; don't need to do anything for 32bpp, for 15bpp entries need to be moved to
        ; be word based. Problem is that CTrans produces a half word table, but the
        ; plot code here expects them to be words

        LDR     R14,trns_flags2         ; get the flag word
        TST     R14,#flg2_widetrans     ; if set we don't need to do the expansion
        BEQ     no_widetrans            ; skip if new bit is unset
        TSTNE   R9,#2                   ; check for 32bpp (note the the SUBS #3 above)
        LDMNEFD R13!,{R0-R2,R9}         ; it is 32bit - reload registers...
        BNE     checktrans_exitok       ; ...and go straight out

        Debug   gs,"We're gonna scribble all over newtranstable 1"
        ;now do the expansion needed for 15bpp
        ADR     R2,newtranstable        ; new table space
        MOV     R8,R8,LSR #1            ; loading a word collects two entries, so
                                        ; halve the number of colours to do
expand_15bpp
        SUBS    R8,R8,#1                ; decrement count
        Pull    "R0-R2,R9",MI           ; when we go minus we've finished, reload registers...
        ADRMI   R7,newtranstable        ; ...change the translation table pointer...
        BMI     checktrans_exitok       ; ...and get out of here!

        LDR     R0,[R7,R8,LSL #2]       ; load two values from original ctrans table
        MOV     LR,R0,LSR #16           ; put the second value in the low 16 bits of LR
        EOR     R0,R0,LR,LSL #16        ; and remove the second value from R0
        MOV     R8,R8,LSL #1            ; double the output pointer cos we've two words to store
        STR     R0,[R2,R8,LSL #2]       ; store the first word
        ADD     R8,R8,#1                ; increment
        STR     LR,[R2,R8,LSL #2]       ; and store the second word
        MOV     R8,R8,LSR #1            ; and bring the output pointer back to normal
        B       expand_15bpp            ; back to the loop to check for completion

no_widetrans
        ]

        ADR     R2,newtranstable        ; -> new translation table (passed out on exit)

converttrans_new
        SUBS    R8,R8,#1
        Pull    "R0-R2,R9",MI           ; preserve important registers
        ADRMI   R7,newtranstable
        BMI     checktrans_exitok

        LDRB    R0,[R7,R8]
        MOV     LR,PC
        ADD     PC,PC,R9,LSL #2         ; call function to remap the colour byte
        STR     R0,[R2,R8,LSL #2]       ; and store the converted value
        B       converttrans_new        ; outbpp = 3 (and inbpp < 4 log2bpp)
        B       mungeGCOL8to16          ; outbpp = 4
;        B       mungeGCOL8to32          ; outbpp = 5

mungeGCOL8to32

        Push    "R2,LR"
                                        ;      fedcba98 76543210 fedcba98 76543210
                                        ; R0 =                            bbggrrtt
        MOV     R2,R0,LSL #4            ; R2 =                       bbgg rrtt
        ORR     R2,R2,R0,LSL#10         ; R2 =                bb ggrrXXgg rrtt
        ORR     R2,R2,R0,LSL#16         ; R2 =          bbggrrXX ggrrXXgg rrtt
        AND     LR,R0,#&03              ; LR =                                  tt
        BIC     R2,R2,#&3F0000          ; R2 =          bb       ggrrXXgg rrtt
        BIC     R2,R2,#&3F00            ; R2 =          bb       gg       rrtt
        ORR     R2,R2,R14,LSL #12       ; R2 =          bb       ggtt     rrtt
        ORR     R0,R2,R14,LSL #20       ; R0 =          bbtt     ggtt     rrtt
        ORR     R0,R0,R0,LSR #4         ; R0 =          bbttbbtt ggttggtt rrttrrtt

; which saves one instruction on...
;        AND     R2,R0,#4_0033           ; R2 =                              rrtt
;        MOV     R2,R2,LSL #4            ; R2 =                          rrtt
;        AND     LR,R0,#4_0003           ; LR =                                tt
;        ORR     R2,R2,LR,LSL #12        ; R2 =                    tt    rrtt
;        ORR     R2,R2,LR,LSL #16 +4     ; R2 =           tt       tt    rrtt
;        AND     LR,R0,#4_0300           ; LR =                            gg
;        ORR     R2,R2,LR,LSL #14 -4     ; R2 =           tt     ggtt    rrtt
;        AND     LR,R0,#4_3000           ; LR =                          bb
;        ORR     R0,R2,LR,LSL #(6 +16)-6 ; R0 =         bbtt     ggtt    rrtt

        Pull    "R2,PC"


mungeGCOL8to16
      [ vidc20
                                        ;      fedcba9876543210fedcba9876543210

        Push    "R2,LR"
                                        ; R0 =                         bbggrrtt

        MOV     LR,R0,LSL #30           ; LR = tt
        ORR     R2,LR,R0,LSR #6         ; R2 = tt                            bb
        ORR     LR,LR,R0,LSR #4         ; LR = tt                          bbgg
        BIC     LR,LR,#&0C              ; LR = tt                            gg
        MOV     R0,R0,LSL #1            ; R0 =                        bbggrrtt
        AND     R0,R0,#&1E              ; R0 =                            rrtt
        ORR     R0,R0,LR,ROR #24        ; R0 =                       ggtt rrtt
        ORR     R0,R0,R2,ROR #19        ; R0 =                  bbtt ggtt rrtt
        ;and now fill in the bottom bit of the colour
        MOV     LR,LR,LSR #30           ; LR =                               tt
        AND     LR,LR,#1                ; LR =                                t
        ORR     LR,LR,LR,LSL #5         ; LR =                           t    t
        ORR     LR,LR,LR,LSL #5         ; LR =                      t    t    t
        ORR     R0,R0,LR                ; R0 =                  bbtttggtttrrttt

; which saves one inst on....
;        AND     R2,R0,#4_0033           ; R2 =             rrtt
;        AND     LR,R0,#4_0003           ; LR =               tt
;        ORR     R2,R2,LR,LSL #5         ; R2 =          tt rrtt
;        ORR     R2,R2,LR,LSL #10        ; R2 =     tt   tt rrtt
;        AND     LR,R0,#4_3000           ; LR =         bb
;        ORR     R2,R2,LR,LSL #12 -6     ; R2 =   bbtt   tt rrtt
;        AND     LR,R0,#4_0300           ; LR =           gg
;        ORR     R2,R2,LR,LSL #7 -4      ; R2 =   bbtt ggtt rrtt
;        MOV     R0,R2,LSL #1            ; R0 =  bbtt ggtt rrtt
d713 3
a715 2
        Pull    "R2,PC"
      |
d717 1
a717 2
; Tim's function for remapping the packed GCOL number to a value
; suitable for display memory.
d719 2
a720 8
        AND     R1,R0,#4_000033
        ORR     R0,R1,R0,LSL #4
        AND     R1,R0,#4_030330
        EOR     R1,R1,R1,LSR #6
        EOR     R1,R1,R1,LSR #4
        AND     R1,R1,#4_000330
        EOR     R0,R0,R1,LSL #4
        MOV     PC,LR
d723 5
a727 14
checktrans_old
        SUBS    R8,R8,#1                ; loop until -ve value
        ;B       checktrans_exitok
        BMI     checktrans_exitok       ;fix bug that was making this routine inactive! AMG

        LDRB    LR,[R7,R10]             ; get a byte from the table
        MOVS    LR,LR,LSR R9            ; if any bits are non-zero that shouldn't be then complain
        BEQ     checktrans_old
checktrans_giveerror
        Debug   gs, "We think the ttable is duff (XXX)"
        ADRL    R0,ErrorBlock_BadTranslation
        addr    R1,Title
        BL      copy_error_one          ; returns error block with V set, for bad table
        EXIT
d729 4
a732 3
checktrans_exitok
        CLRV
        EXIT
d734 4
a737 6
      ; some of these values used in SprTrans
mc_gcol         *       2_00000111              ; bits 0..2 of R5
mc_hasmask      *       2_00001000              ; bit 3 of R5
mc_ttr          *       2_00010000              ; R7
mc_plotmask     *       2_00100000              ; R0
mc_transformed  *       2_01000000              ; 0 if scaled, 1 if transformed sprite plot
d739 9
a747 3
                [ ignore_ttr
mc_ttrispalette *       2_10000000              ; use palette instead of ttr (ttr points at it)
                ]
d749 11
a759 90
mcb_inbpp       *       8
mcb_outbpp      *       16
mcb_sprtype     *       24

xxx             *       2

BNE             *       &1A000000
BCS             *       &2A000000
BCC             *       &3A000000
BMI             *       &4A000000
BPL             *       &5A000000
BVS             *       &6A000000
BVC             *       &7A000000
BHI             *       &8A000000
BLS             *       &9A000000
BGE             *       &AA000000
BLT             *       &BA000000
BGT             *       &CA000000
BLE             *       &DA000000
BAL             *       &EA000000
BNV             *       &FA000000

;;-----------------------------------------------------------------------------
;; Merge Sprites (horizontally or vertically)
;;
;; Entry:  R0 = reason code
;;         R1 = areaCBptr
;;         R2 = name/ptr of 1st sprite
;;         R3 = name/ptr of 2nd sprite
;;         R4 = flags (0 ==> merge horizontally, else vertically)
;; Exit:   1st sprite is result of merging both
;;         2nd sprite is deleted
;;         scratch space used (no extra memory apart from that)
;;-----------------------------------------------------------------------------


;
; Algorithm:
;       check that sprites are compatible - if not, give error/adjust sprite
;       move sprite2 to end of sprites
;       move sprite1 just before sprite2
;       eliminate sprite2 header
;       if masked, swap(mask1,data2)
;       if R4=0 (horiz. merge) interleave rows of data (& then masks if nec)
;       reclaim wastage (depends on h/v merge) of data + masks
;       correct sprite end ptrs, no of sprites etc.
;       correct size of sprite
;

Go_AppendSprite
        Push    "R1-R11,LR"
;
        CLRPSR  I_bit, R14              ; re-enable interrupts
;
        BL      findsprite
;        BLVC    TestForMaskAtDepth       Removed in merge with 0.62 (GPS)
        STRVC   R1,sp1_areaCBptr        ; R1 may be updated if system area
        MOVVC   R5,R2                   ; R5 --> first sprite
        MOVVC   R2,R3
        BLVC    findsprite              ; R2 --> second sprite
;        BLVC    TestForMaskAtDepth       Removed in merge with 0.62 (GPS)
        BVS     %FT99
;
; check that sprites are defined in the same mode
;
        TEQ     R2,R5                   ; same sprite?
        BEQ     badappend
        LDR     R14,[R2,#spMode]
        LDR     R0,[R5,#spMode]
        Debug   ag,"Modes are",R0,R14   ; Merged from 0.62 (GPS)
        TEQ     R0,R14
        BNE     badappend               ; can't merge different modes
;
; check that rows/columns are same (depends on R4)
;
        TEQ     R4,#0                   ; R4=0 ==> horiz merge (check rows)
        BNE     %FT01
;
        LDR     R14,[R2,#spHeight]
        LDR     R0,[R5,#spHeight]
        Debug   ag,"Heights are",R0,R14 ; Merged from 0.62 (GPS)
        TEQ     R0,R14
        BEQ     %FT02
badappend
        Debug   ag,"Bad append, setting up error block and exiting"
        ADR     R0, ErrorBlock_BadAppend
        addr    r1, Title
        BL      copy_error_one          ; Always sets the V bit
        B       %FT99
        MakeSpriteErrorBlock BadAppend,,AppErr
d761 3
a763 237
01
        Push    "R2"
        BL      getspritewidth          ; R2 --> sprite defn, R3 = width
        MOV     R2,R5
        MOV     R6,R3
        BL      getspritewidth
        Pull    "R2"
        Debug   ag,"Widths are",R3,R6   ; Merged from 0.62 (GPS)
        TEQ     R3,R6
        BNE     badappend
02
;
; if one has a mask & the other doesn't, create mask
;
        LDR     R14,[R2,#spImage]
        LDR     R0,[R2,#spTrans]
        EORS    R6,R0,R14
        MOVNE   R6,#-1                  ; R6 = (2nd sprite has mask)
        LDR     R14,[R5,#spImage]
        LDR     R0,[R5,#spTrans]
        EORS    R0,R0,R14
        MOVNE   R0,#-1
        TEQ     R0,R6                   ; if same, skip next bit
        BEQ     %FT01
;
        Debug   ag,"One of the sprites has no mask"   ; Merged from 0.62 (GPS)
        Push    "R2"
        TEQ     R6,#0
        MOVNE   R2,R5                   ; if 2nd sprite has mask, enmask 1st
        MOV     R0,#SpriteReason_CreateMask
        ADD     R0,R0,#&200             ; since R2 --> sprite definition
        BL      Go_SpriteOp             ; call MOS version
        Pull    "R2"
        BVS     %FT99                   ; error (eg. memory full)
01
;
; move sprites to end of memory (need to get addresses back again)
;
        LDMFD   R13,{R1-R3}
;
        BL      findsprite
        MOVVC   R5,R2                   ; R5 --> first sprite
        MOVVC   R2,R3
        BLVC    findsprite              ; R2 --> second sprite
        BVS     %FT99

        Debug   ag,"First sprite is at",R5      ; Merged from 0.62 (GPS)
        Debug   ag,"Second sprite is at",R2     ; Merged from 0.62 (GPS)
;
        LDR     R3,[R1,#saFree]         ; R3 --> end of sprites
        Debug   ag,"End of sprite area is",R3   ; Merged from 0.62 (GPS)
        ADD     R3,R1,R3
        MOV     R1,R2                   ; R1 --> sprite2
        LDR     R2,[R1,#spNext]
        ADD     R2,R1,R2                ; R2 --> end of sprite2
        Debug   ag,"End of sprite2 is",R2       ; Merged from 0.62 (GPS)
        BL      swapblocks
        MOV     R6,R1                   ; R6 --> sprite2 (in new position)
;
        CMP     R5,R2                   ; if sprite1 was after sprite2
        DebugIf CS,ag,"Sprite1 was after sprite2"   ; Merged from 0.62 (GPS)
        SUBCS   R14,R3,R1
        SUBCS   R5,R5,R14               ; move down by (R3-R1) ie. sprite2 size
;
        MOV     R3,R1
        MOV     R1,R5                   ; R1 --> sprite1
        LDR     R2,[R1,#spNext]
        ADD     R2,R1,R2
        Debug   ag,"End of sprite1 is",R2     ; Merged from 0.62 (GPS)
        BL      swapblocks              ; R1 --> sprite1 (in new position)
;
; note the sprite mode of sprite 1 (should = sprite2)
; and the spNext parameter of sprite 2
;
        LDR     R2, [R1,#spMode]        ; Merged from 0.62 (GPS)
        STR     R2, sp_mode             ; Merged from 0.62 (GPS)
        LDR     R2, [R6,#spNext]        ; Merged from 0.62 (GPS)
        STR     R2, sp2_next            ; Merged from 0.62 (GPS)
;
; note down sprite1's header
;
        MOV     R2,R1
        ADRL    R3,sp1_data
        BL      savespriteheader        ; sets up R5,R7-R11
;
; note down sprite2's header, and delete it
;
        MOV     R2,R6
        ADRL    R3,sp2_data
        BL      savespriteheader        ; sets up R5,R7-R11
;
        MOV     R1,R6                   ; destination
        ADD     R2,R1,R10               ; source (image)
        LDR     R3,[R1]
        SUB     R3,R3,R10               ; counter
        BL      copyblock               ; R3 bytes from R2 to R1
        MOV     R2,R6                   ; R2 --> sprite2 image
;
; if there is a mask (new or old), swap (mask1, image2) & do both sets of data
;
        SUBS    R11,R11,R10             ; offset from image to mask (sprite2)
        BEQ     %FT01
;
        Debug   ag,"These sprites have masks!"        ; Merged from 0.62 (GPS)
        LDR     R1,sp1_header
        LDR     R14,[R1,#spTrans]       ; R1 --> start of sprite1 mask
        ADD     R1,R1,R14               ; R2 --> sprite2 image
        ADD     R3,R2,R11               ; R3 --> end of sprite2 image
        BL      swapblocks              ; R2, R1 --> image2, mask1
;
        Push    "R1,R3"
;
        MOV     R3,R1                   ; R3 --> end of image2
        LDR     R1,sp1_header
        SUB     R14,R3,R1
        STR     R14,sp1_trans           ; for later
        LDR     R14,sp1_image
        ADD     R1,R1,R14               ; R1 --> start of image1
        BL      mergeblocks             ; takes note of R4
;
        Pull    "R1,R2"                 ; R1 --> mask1, R2 --> mask2
        LDR     R3,sp2_trans
        LDR     R14,sp2_next            ; Merged from 0.62 (GPS)
;        LDR     R14,sp2_image
        SUB     R3,R14,R3               ; R3 = size of mask2 (poss+) - From 0.62 (GPS)
;        SUB     R3,R3,R14               ; R3 = size of image2 (=size of mask2)
        ADD     R3,R2,R3                ; R3 --> end of mask2
        LDR     R14,sp1_header
        SUB     R14,R1,R14
;        STR     R14,sp1_trans           ; transparency mask offset (???!)
;        BL      mergeblocks            merged from 0.62 (GPS)
        Push    "R14"                   ; merged from 0.62 (GPS)
        LDR     R14, sp_mode            ; merged from 0.62 (GPS)
        MOVS    R14, R14, LSR #27       ; Old or new?                 merged from 0.62 (GPS)
        Pull    "R14"                                               ; merged from 0.62 (GPS)
        DebugIf EQ,ag,"Old format mergeblocks to be executed"       ; merged from 0.62 (GPS)
        BLEQ    mergeblocks             ;   if old format             merged from 0.62 (GPS)
        DebugIf NE,ag,"New format mergeblocks to be executed"       ; merged from 0.62 (GPS)
        BLNE    maskmergeblocks         ;   if new format             merged from 0.62 (GPS)
        B       %FT02
;
; otherwise just merge the images
;
01
        Debug   ag,"These sprites don't have masks"                 ; merged from 0.62 (GPS)
        LDR     R1,sp1_header
        LDR     R14,sp1_image
        ADD     R1,R1,R14               ; R1 --> sprite1 image
        LDR     R2,sp2_header           ; R2 --> sprite2 image
        LDR     R14,sp2_imagesize
        ADD     R3,R2,R14               ; R3 --> end of sprite2 image
        BL      mergeblocks
02
;
; now rationalise the final image - shunt all bits down
;
        Debug   ag,"Now rationalising..."          ; merged from 0.62 (GPS)
        LDR     R2,sp1_header
        LDR     R3,sp1_image
        ADD     R1,R2,R3
        MOV     R3,R1
        BL      chunterblock            ; R1 --> start of block
        LDR     R0,sp1_image
        LDR     R14,sp1_trans
        TEQ     R14,R0                  ; was there a mask?
;        SUBNE   R14,R3,R2                                          ; merged from 0.62 (GPS)
;        STRNE   R14,[R2,#spTrans]       ; point to it                merged from 0.62 (GPS)
;        BLNE    chunterblock            ; and process it             merged from 0.62 (GPS)
        BEQ     %FT03                   ; if not, skip the next bit
        SUB     R14,R3,R2                                           ; merged from 0.62 (GPS)
        STR     R14,[R2,#spTrans]       ; point to mask               merged from 0.62 (GPS)
        LDR     R14, sp_mode                                        ; merged from 0.62 (GPS)
        MOVS    R14, R14, LSR #27       ; New or old format mask?     merged from 0.62 (GPS)
        DebugIf EQ,ag,"Old format chunterblock to be executed"      ; merged from 0.62 (GPS)
        BLEQ    chunterblock            ; process old format mask     merged from 0.62 (GPS)
        DebugIf EQ,ag,"New format chunterblock to be executed"      ; merged from 0.62 (GPS)
        BLNE    maskchunterblock        ; process new format mask     merged from 0.62 (GPS)
;
03
        SUB     R14,R3,R2
        STR     R14,[R2,#spNext]        ; sprite size
        LDR     R2,sp1_areaCBptr
        SUB     R14,R3,R2
        STR     R14,[R2,#saFree]        ; area size
;
        LDR     R14,[R2,#saNumber]
        SUB     R14,R14,#1              ; sprite2 deleted
        STR     R14,[R2,#saNumber]

99
;        MOV     r0, #35                 ; merged from 0.62 (GPS)
        MOVVC   r0, #35                 ; made conditional to stop error block being junked (GPS)
        Pull    "R1-R11,PC"

;-------------------------------------------------------------------
; Chunterblock
;
; Entry:  R1 --> input data
;         R3 --> output data
;         R4 = 0/1 (horizontal/vertical merge)
;         [sp1/2_data] = original state of sprites
;         [sp1/2_imagesize] = amount of data to process
; Exit:   R1 --> end of input
;         R3 --> end of output
;         [[sp1_header]] contains correct width, height, lbit, rbit
;         sprite data crunched into shape
;
chunterblock
        Push    "R5-R11,LR"
        Debug   ag,"Chunterblock entry R1,R3,R4",R1,R3,R4
;
        TEQ     R4,#0
        BNE     %FT04
;
        LDR     R11,sp1_height          ; R11 = no of rows to do (-1)
01
        MOV     R10,R3                  ; original output ptr
;
        LDR     R5,sp1_width            ; R5 = no of intermediate words
        LDR     R6,sp1_lbit             ; R6 = input bit wastage on left
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        LDR     R8,sp1_rbit             ; bit non-wastage on right
        BL      chunterrow              ; R7 = no of bits set up in last word
;
        LDR     R5,sp2_width
        LDR     R6,sp2_lbit
        LDR     R8,sp2_rbit
        BL      chunterrow
;
        TEQ     R7,#0
        MOVEQ   R7,#32
        ADDNE   R3,R3,#4                ; skip last word if anything in it
;
        SUBS    R11,R11,#1
        BPL     %BT01
;
        B       setupwidth
d765 3
a767 50
04
        LDR     R11,sp1_height
01
        LDR     R5,sp1_width            ; R5 = no of intermediate words
        LDR     R6,sp1_lbit             ; R6 = input bit wastage on left
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        LDR     R8,sp1_rbit             ; bit non-wastage on right
        BL      chunterrow              ; R7 = no of bits set up in last word
        TEQ     R7,#0
        ADDNE   R3,R3,#4                ; skip last word if anything in it
;
        SUBS    R11,R11,#1
        BPL     %BT01
;
        LDR     R11,sp2_height
02
        MOV     R10,R3
        LDR     R5,sp2_width            ; R5 = no of intermediate words
        LDR     R6,sp2_lbit             ; R6 = input bit wastage on left
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        LDR     R8,sp2_rbit             ; bit non-wastage on right
        BL      chunterrow              ; R7 = no of bits set up in last word
        TEQ     R7,#0
        MOVEQ   R7,#32
        ADDNE   R3,R3,#4                ; skip last word if anything in it
;
        SUBS    R11,R11,#1
        BPL     %BT02
;
        LDR     R14,sp1_height
        LDR     R0,sp2_height
        ADD     R14,R14,R0
        ADD     R14,R14,#1              ; since each is <no of rows>-1
        STR     R14,[R2,#spHeight]
;
; R2 --> sprite header, R3-R10 = width of 1 row, R7 = spRBit+1, spLBit=0
;
setupwidth
        SUB     R14,R3,R10
        MOV     R14,R14,LSR #2
        SUB     R14,R14,#1
        STR     R14,[R2,#spWidth]       ; spWidth = no of words - 1
        MOV     R14,#0
        STR     R14,[R2,#spLBit]        ; spLBit = 0
        SUB     R7,R7,#1
        STR     R7,[R2,#spRBit]         ; spRBit = R7-1
;
        Debug   ag,"Chunterblock exit R1,R3,R4",R1,R3,R4

        Pull    "R5-R11,PC"
d769 3
d773 3
d777 16
a792 49
;-------------------------------------------------------------------
; Maskchunterblock
;
; Entry:  R1 --> input data
;         R3 --> output data
;         R4 = 0/1 (horizontal/vertical merge)
;         [sp1/2_data] = original state of sprites
;         [sp1/2_imagesize] = amount of data to process
; Exit:   R1 --> end of input
;         R3 --> end of output
;         [[sp1_header]] contains correct width, height, lbit, rbit
;         sprite data crunched into shape
;
; NOTE:   Only called for new format (1bpp) sprites
;
maskchunterblock
        Push    "R5-R11,LR"
;
        Debug   ag,"Chunterblock entry R1,R3,R4",R1,R3,R4

        TEQ     R4,#0                   ; Vertical or horizontal join?
        BNE     %FT04                   ; Go elsewhere if vertical join
;
        LDR     R11,sp1_height          ; R11 = no of rows to do (-1)
01
        MOV     R10,R3                  ; original output ptr
;
        LDR     R8,sp1_rbit
        LDR     R5,sp1_width            ; R5 = no of intermediate words
        BL      FindMaskWidth           ; Alters R5 & sets up R8 to Rbit
        MOV     R6,#0                   ; Lbit wastage = 0
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        BL      chunterrow              ; R7 = no of bits set up in last word
;
        LDR     R8,sp2_rbit
        LDR     R5,sp2_width
        BL      FindMaskWidth           ; Alters R5 & sets up R8 to Rbit for mask
        MOV     R6,#0                   ; Lbit wastage always = 0
        BL      chunterrow
;
        TEQ     R7,#0
        MOVEQ   R7,#32
        ADDNE   R3,R3,#4                ; skip last word if anything in it
;
        SUBS    R11,R11,#1              ; One line less to do...
        BPL     %BT01                   ; Do the next one
;
;        B       masksetupwidth
        Debug   ag,"Maskchunterblock exit R1,R3,R4",R1,R3,R4
d794 2
a795 4
        Pull    "R5-R11,PC"

04
        LDR     R11,sp1_height
d797 1
a797 404
        LDR     R8,sp1_rbit
        LDR     R5,sp1_width            ; R5 = no of intermediate words
        BL      FindMaskWidth           ; Convert R5 & set up R8
        MOV     R6,#0                   ; Lbit is zero for this format sprite
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        BL      chunterrow              ; R7 = no of bits set up in last word
        TEQ     R7,#0
        ADDNE   R3,R3,#4                ; skip last word if anything in it
;
        SUBS    R11,R11,#1
        BPL     %BT01
;
        LDR     R11,sp2_height
02
        MOV     R10,R3
        LDR     R8,sp2_rbit
        LDR     R5,sp2_width            ; R5 = no of intermediate words
        BL      FindMaskWidth
        MOV     R6,#0                   ; Lbit = 0 always
        MOV     R7,#0                   ; R7 = no of bits set up (none)
        BL      chunterrow              ; R7 = no of bits set up in last word
        TEQ     R7,#0
        MOVEQ   R7,#32
        ADDNE   R3,R3,#4                ; skip last word if anything in it
;
        SUBS    R11,R11,#1
        BPL     %BT02
;
;        LDR     R14,sp1_height
;        LDR     R0,sp2_height
;        ADD     R14,R14,R0
;        ADD     R14,R14,#1              ; since each is <no of rows>-1
;        STR     R14,[R2,#spHeight]
        Pull    "R5-R11,PC"

;
; R2 --> sprite header, R3-R10 = width of 1 row, R7 = spRBit+1, spLBit=0
;
masksetupwidth
        SUB     R14,R3,R10
        MOV     R14,R14,LSR #2
        SUB     R14,R14,#1
        STR     R14,[R2,#spWidth]       ; spWidth = no of words - 1
        MOV     R14,#0
        STR     R14,[R2,#spLBit]        ; spLBit = 0
        SUB     R7,R7,#1
        STR     R7,[R2,#spRBit]         ; spRBit = R7-1
;
        Pull    "R2,R5-R11,PC"


;------------------------------------------------------------------------
; Chunterrow
;
; Entry:  R1 --> input data
;         R3 --> output data (some of 1st word may be valid)
;         R5 = no of whole words to do (excluding the end 2)
;         R6 = bit offset of 1st valid bit in input word
;         R7 = bit offset of 1st unused bit in output word
;         R8 = bit offset of last used bit in output word
; Exit:   R1 --> end of input data
;         R3 --> end of output data
;         R7 = no of valid bits in [R3] - 0..31 (if 32, output word & go on)
;
chunterrow
        Push    "R0,R5,R6,R8-R10,LR"
        Debug   ag,"Chunterrow entered R1,R3,R5-R8",R1,R3,R5,R6,R7,R8
;
        ADD     R8,R8,#1                ; make exclusive
        LDR     R0,[R1],#4
        MOV     R0,R0,LSR R6
        LDR     R14,[R3]
        RSB     R10,R7,#32              ; for later
        MOV     R14,R14,LSL R10
        MOV     R14,R14,LSR R10
        ORR     R14,R14,R0,LSL R7
        TEQ     R5,#0
        RSBEQ   R9,R6,R8                ; R9 = no of valid bits shifted in
        RSBNE   R9,R6,#32
        ADD     R7,R7,R9
        CMP     R7,#32
        SUBCS   R7,R7,#32
        STRCS   R14,[R3],#4
        MOVCS   R14,R0,LSR R10          ; R14 = rest of input word
        RSB     R9,R7,#32               ; R9 = no of bits to be carried over
;
; R14 = output word, R7 = no of valid bits, R1 --> input (from bit 0)
;
        TEQ     R5,#0
        BEQ     %FT05                   ; 1st word = last - we've finished!
;
        MOV     R6,#0
        SUBS    R5,R5,#1
        BEQ     %FT04                   ; middle section is null
;
        TEQ     R7,#0
        BNE     %FT02
01
        LDR     R14,[R1],#4             ; do this the quick way!
        STR     R14,[R3],#4
        SUBS    R5,R5,#1
        BNE     %BT01
        MOV     R14,#0                  ; no more bits remaining!
        B       %FT04
02
        LDR     R0,[R1],#4              ; R0 = input word - from bit 0
        ORR     R14,R14,R0,LSL R7
        STR     R14,[R3],#4
        MOV     R14,R0,LSR R9           ; R14 = remaining bits of R0
        SUBS    R5,R5,#1
        BNE     %BT02
;
; R1 --> final word of input, R3 --> next output word
; R14 = output word, R7 = no of valid bits, R6 = first valid bit in [R1]
;
04
        LDR     R0,[R1],#4              ; read final word
        MOV     R0,R0,LSR R6
        SUB     R8,R8,R6                ; no of bits used in R0
        ORR     R14,R14,R0,LSL R7
        ADD     R7,R7,R8
        CMP     R7,#32
        SUBCS   R7,R7,#32
        STRCS   R14,[R3],#4
        MOVCS   R14,R0,LSR R9
05
        TEQ     R7,#0                   ; avoid splattering next word of input
        STRNE   R14,[R3]                ; for next time
;
        Debug   ag,"Chunterrow exit R1,R3,R5-R8",R1,R3,R5,R6,R7,R8

        Pull    "R0,R5,R6,R8-R10,PC"


;----------------------------------------------------------------------
; Savespriteheader
;
; Entry:  R2 --> sprite definition
;         R3 --> where to put data
; Exit:   R5,R7-R11 = width,height,Lbit,Rbit,Image,Trans
;         also copied to [R3]
;         [R3,#header] = address of header block
;         [R3,#imagesize] = size of sprite image (excl. mask)
;
savespriteheader
        Push    "R2,LR"
;
        STR     R2,[R3,#sp1_header-sp1_data]
        LDR     R14,[R2],#spWidth
        LDMIA   R2,{R5,R7-R11}          ; width,height,Lbit,Rbit,Image,Trans
        STMIA   R3,{R5,R7-R11}
        Debug   ag,"Sprite header",R5,R7,R8,R9,R10,R11
        LDR     R14,[R1,#spNext]        ; Try & work out the image size
        TEQ     R10,R11                 ; Hang on, but is there a mask?
        LDRNE   R14,[R1,#spTrans]       ; Yes, so we have to work it out different
        SUB     R14,R14,R10             ; Convert the offset to a 'size'
        STR     R14,[R3,#sp1_imagesize-sp1_data]
;
        Pull    "R2,PC"

;-----------------------------------------------------------------------
; Getspritewidth
;
; Entry:  R2 --> sprite defn
; Exit:   R3 = sprite width (bits)
;
getspritewidth
        Push    "LR"
;
        LDR     R14,[R2,#spLBit]
        LDR     R3,[R2,#spRBit]
        SUB     R3,R3,R14
        ADD     R3,R3,#1                ; make inclusive
        LDR     R14,[R2,#spWidth]
        ADD     R3,R3,R14,LSL #5        ; 32 bits per word
        Debug   ag,"Getspritewidth thinks the sprite width (bits) is",R3
;
        Pull    "PC"

;----------------------------------------------------------------------
; Swapblocks
;
; Entry:  R1 --> start of 1st block
;         R2 --> start of 2nd block (consecutive)
;         R3 --> end of 2nd block
; Exit:   blocks swapped over
;         R1 --> start of 1st block (after 2nd block)
;         R2 --> start of 2nd block
;
swapblocks
        Push    "R3,LR"
;
        Debug   mg,"Swap blocks: ",R1,R2,R3
;
        TEQ     R1,R2
        TEQNE   R2,R3                   ; Z set if either block is null
        SUB     R14,R3,R2               ; R14 = length of 2nd block
        MOV     R2,R1
        ADD     R1,R1,R14
        Pull    "R3,PC",EQ              ; ensure R1,R2 set up correctly on exit
        Push    "R1,R2"
;
        MOV     R1,R2
        MOV     R2,R3
        BL      reverseblock
;
        LDR     R2,[R13,#0*4]           ; reverse new 2nd block
        BL      reverseblock
        MOV     R1,R2
        LDR     R2,[R13,#2*4]           ; reverse new 1st block
        BL      reverseblock
;
        Pull    "R1-R3,PC"

;-------------------------------------------------------------
; Reverse block
;
; Entry:  R1 --> start of block
;         R2 --> end of block (JUST AFTER)
; Exit:   block reversed (words)
;
reverseblock
        Push    "R1-R4,LR"
01
        CMP     R1,R2
        LDRCC   R3,[R1]
        LDRCC   R4,[R2,#-4]!
        STRCC   R3,[R2]
        STRCC   R4,[R1],#4
        BLT     %BT01
;
        Pull    "R1-R4,PC"

;-------------------------------------------------------------
; Copyblock
;
; Entry:  R1 --> destination
;         R2 --> source
;         R3 = no of bytes (must be a whole number of words)
;
copyblock
        Debug   mg,"Copy block (to, from, count): ",R1,R2,R3
;
        TEQ     R1,R2           ; check for null copy
        TEQNE   R3,#0
        MOVEQ   PC,LR
;
        Push    "R1-R3,LR"
;
        CMP     R1,R2
        BCS     copyup
01
        LDR     R14,[R2],#4
        STR     R14,[R1],#4
        SUBS    R3,R3,#4
        BGT     %BT01
;
        Pull    "R1-R3,PC"
;
copyup
        ADD     R1,R1,R3
        ADD     R2,R2,R3
01
        LDR     R14,[R2,#-4]!
        STR     R14,[R1,#-4]!
        SUBS    R3,R3,#4
        BGT     %BT01
;
        Pull    "R1-R3,PC"

;----------------------------------------------------------------
; Mergeblocks
;
; Entry:  R1,R2,R3 --> delimit 2 blocks (consecutive)
;         R4 = 0/1 (merge horizontally/vertically)
;
mergeblocks
        Debug   mg,"Merge blocks: ",R1,R2,R3
;
        TEQ     R4,#0
        MOVNE   PC,LR                   ; vertical merge
;
        Push    "R1-R3,R5-R6,LR"
;
        LDR     R5,sp1_width
        ADD     R5,R5,#1
        MOV     R5,R5,LSL #2            ; R5 = size of 1 row (bytes)
        LDR     R6,sp2_width
        ADD     R6,R6,#1
        MOV     R6,R6,LSL #2            ; R6 = size of 1 row (bytes)
01
        ADD     R1,R1,R5
        CMP     R1,R2
        BCS     %FT02                   ; no more to do
        ADD     R3,R2,R6
        BL      swapblocks
        ADD     R1,R2,R6
        MOV     R2,R3
        B       %BT01
02
        Pull    "R1-R3,R5-R6,PC"



;----------------------------------------------------------------
; Maskmergeblocks
;
; Entry:  R1,R2,R3 --> delimit 2 blocks (consecutive)
;         R4 = 0/1 (merge horizontally/vertically)
;NOTE: Only called for new format sprites
;
maskmergeblocks
        Debug   mg,"Mask merge blocks: ",R1,R2,R3
;
        TEQ     R4,#0
        MOVNE   PC,LR                   ; vertical merge, so return
;
        Push    "R1-R3,R5-R6,R8,LR"
;
        LDR     R8,sp2_rbit
        LDR     R5,sp2_width
        BL      FindMaskWidth           ;Convert R5
        ADD     R6,R5,#1
        MOV     R6,R6,LSL #2            ; R6 = size of 1 row (bytes)
        Debug   ag,"Size of 1 row of sprite2 is (bytes)",R6
        LDR     R8,sp1_rbit
        LDR     R5,sp1_width
        BL      FindMaskWidth           ;Convert R5
        ADD     R5,R5,#1
        MOV     R5,R5,LSL #2            ; R5 = size of 1 row (bytes)
        Debug   ag,"Size of 1 row of sprite1 is (bytes)",R5
01
        ADD     R1,R1,R5
        CMP     R1,R2
        BCS     %FT02                   ; no more to do
        ADD     R3,R2,R6
        BL      swapblocks
        ADD     R1,R2,R6
        MOV     R2,R3
        B       %BT01
02
        Pull    "R1-R3,R5-R6,R8,PC"
;-----------------------------------------------------------------------------

; *****************************************************************************
;
;      FindMaskWidth - convert spWidth for data to spWidth for mask (1bpp masks)
;
;   NOTE: This routine should be similar to GetMaskspWidth in VduGrafH except it does
;         not return the updated PSR
;
;       Internal routine.
;
; in:   R5 = spWidth (ie width in words-1)
;       R8 = spRbit
;       (expects R2->sprite info)
;
; out:  R5 = spWidth (words -1) for mask data
;       R8 = Last bit (spRBit) used in mask data

; MUST only be called for new format sprites

FindMaskWidth ROUT
        Push    "R0, LR"
        Debug   ag,"Entered GetMaskspWidth with R5,R8",R5,R8

        LDR     LR, sp_mode             ; fetch the sprite mode
        MOVS    LR, LR, LSR #27         ; isolate the sprite type and test for =0

        Pull    "R0, PC",EQ         ; if an old format sprite, return R5 unchanged

        ; treat any T>max sprites as 32bpp
        CMP     LR, #SpriteType_MAX
        MOVCS   LR, #SpriteType_Substitute

        ; bugfix 9/8/93: get log2bpp this way
        ADRL    R0, NSM_bpptable-4
        LDR     LR, [R0, LR, LSL #2]    ; get the log2bpp to LR

        RSB     LR, LR, #5              ; and change to 5-log2bpp

        MOV     R5, R5, LSL LR          ; number of pixels for full words

        RSB     LR, LR, #5              ; now switch back to log2bpp
        ADD     R8, R8, #1
        ADD     R5, R5, R8, LSR LR

        ANDS    LR, R5, #&1F            ; fit exactly in a number of words ?
        SUB     R8, LR, #1              ; alter the last bit used for the mask data
                                        ; fix bug MED-01130....
        AND     R8, R8, #&1F            ; ....bring back into range 00-1F (may be -1 here)
        MOVNE   LR, #1                  ; if not, add an extra word
        ADD     R5, LR, R5, LSR #5      ; add the whole number of words
        SUB     R5, R5, #1              ; returns as words-1

        Debug   ag,"Left GetMaskspWidth with R5,R8",R5,R8

        Pull    "R0, PC"

;NSM_bpptable
         ; note, yes - I know this could be type-1, but at some point some new type
         ; will break the relationship so it's a table from day 1 to cope with this
;        &       0, 1, 2, 3, 4, 5
;
d799 1
d804 1
a804 1
        GET     Sources.PutScaled   ; needs commenting out if not using JPEG stuff.
a811 24
Go_CheckSpriteArea
        Push    "R1-R2,SL,LR"
        MOV     r2, r0                  ; save r0 in r2
        MOVS    r0, r0, LSR #8
        BEQ     CheckSprite_exit
        MOV     r0, r1                  ;set up register for C function
        MOV     SL,R12                  ; will be left alone by compiled C - for debug routines above.
        BL      check_sprite_area       ; branch into C
        MOV     R12,SL                  ; R12 is ip to a C prog, will have been trampled on - restore it.
        CMP     r0, #0                  ; check if sprite area was valid
        BEQ     CheckSprite_exit
        Debug   gs, "There's something wrong with the sprite area"
        SETV                            ; the sprite area is bad
        ADRL    R0,ErrorBlock_BadData
        BL      copy_error_one
        Pull    "R1-R2,SL,PC"

CheckSprite_exit
        MOV     r0, r2                  ;restore r0
        Pull    "R1-R2,SL,PC"


        MakeSpriteErrorBlock BadData,,BadData

@


4.14
log
@Fix two bugs causing aborts on corner cases.
1 pixel wide JPEGs:
The diffuse dithering code considers all lines as 1-N-1 where N can be zero and the first and last pixel are dealt with specially because there's no data to scatter beyond the edge.
With a 1 pixel wide JPEG the dithering code ended up with a -ve number in the X counter and wandered off the end of memory. Fix just moves a SUB up a few lines and turns it into a SUBS so that the 1 wide case becomes 0-N-1 with N=0.
1 pixel high sprites:
With output switched to a 1 pixel high sprite an abort would quickly follow because the read of mode variables had a backdoor check to workaround a bug in RISC OS 2.00 which returned a duff value for YWindLimit in MODE 22. As the definition of MODE 22 got changed to 768x288 in RISC OS 3.xx (and the YWindLimit bug fixed) this code now just falsely reported a 1 pixel high sprite as being 1024 high and the blitter splattered all over memory it shouldn't.
Result:
Loss of RISC OS 2.00 compatibility, but can now load JPEGs of Xx1 or 1xY and even 1x1.

Version 1.25. Tagged as 'SprExtend-1_25'
@
text
@a56 1
        GBLL    debuglp
a61 8
        GBLL    debugxx
        GBLL    debugcg
        GBLL    debugcp
        GBLL    debugco
        GBLL    debugcn
        GBLL    debugcs
        GBLL    debugcw
        GBLL    debugcu
d95 2
a96 8
flagbit SETL    {TRUE}                  ; if true forces the palette to be used over
                                        ; the translation table, overriding the effect
                                        ; of med01867 if b4 of R5 on entry was set

        GBLL    widetrans
widetrans SETL  {TRUE}                  ; support for wide translation tables via R5 bit 5

        [       flagbit
d103 2
a109 5
        GBLL    ccompiler               ; new PutSpriteScaled compiler, written in C
ccompiler SETL  {TRUE}
        GBLL    remoldcompiler          ; remove old compiler - set multibuffer to FALSE as well
remoldcompiler SETL {TRUE}

a124 1
debuglp SETL    debug :LAND: {FALSE}    ; loop
a129 8
debugxx SETL    debug :LAND: {FALSE}    ; misc debugging
debugcg SETL    debug :LAND: {FALSE}    ; code generator
debugcp SETL    debug :LAND: {FALSE}    ; code generator - asm_putmany
debugco SETL    debug :LAND: {FALSE}    ; code generator - asm_tryoutput
debugcn SETL    debug :LAND: {FALSE}    ; code generator - asm_newpixel
debugcs SETL    debug :LAND: {FALSE}    ; code generator - asm_start
debugcw SETL    debug :LAND: {FALSE}    ; code generator - asm_newword
debugcu SETL    debug :LAND: {FALSE}    ; code generator - asm_putword
d234 17
a413 1
      [ ccompiler
a418 1
      ]
a685 1
                [ ccompiler
a687 1
                ]
a823 1
                [ ccompiler
a827 1
                ]
a1700 16
      [ {FALSE}
        ; This rather weak test was to work around a bug in RISC OS 2.00 where MODE 22
        ; would return X & Y window limit of zero. MODE 22 was 320x1024.
        ; In RISC OS 3.xx MODE 22 was redefined as 768x288 and the mode variable bug fixed.
        ; However, this override code stops redirection to 1 line high sprites since
        ; the variable ywindlimit is zero based (ie. y-1) as all the blitting code
        ; would assume there was a 1024 line screen to write to, resulting in an abort!
        LDR     R14,ywindlimit
        TEQ     R14,#0                  ; impossible!
        MOVEQ   R14,#1024               ; bodge for old OS versions
        LDREQ   R0,log2py               ; (goes wrong in mode 22)
        MOVEQ   R14,R14,ASR R0
        SUBEQ   R14,R14,#1
        STREQ   R14,ywindlimit
      ]
;
a2082 1
        [       ccompiler
a2083 1
        ]
a2729 5
      [ ccompiler
;        LDR     R14,spritecode
;        AND     R14,R14,#255
;        CMP     R14,#SpriteReason_PutSpriteScaled
;        BEQ     new_putscaled_compiler
a2730 247
      ]

      [ remoldcompiler
      |
;
; compile appropriate macro (if not already done)
;
        BL      compilemacro

;
; remove cursors, since we are about to stomp on the screen!
;
        SWI     XOS_RemoveCursors
        BVS     exitbiggie              ; last chance to go to exitbiggie!
;
; copy relevant variables onto the stack, so that R12 is free
;
        LDR     R0,BPP
        LDR     R1,save_outoffset
        LDR     R2,save_inbpp
        LDR     R3,ColourTTR
        LDR     R4,save_masko
        LDR     R5,save_calladdr
        LDR     R6,save_calladdr2
        LDR     R9,save_maskinptr
        LDR     R10,save_maskinshift
;
        MVN     R8,#0                     ;fixes for 32bpp, amg
        CMP     R0,#32
        RSBLT   R14,R0,#32
        MOVLT   R8,R8,ASL R14           ; setup a suitable mask
        Debug   cn,"maskword ",R8
;
        Push    "R0-R12"                 ; R7 = space for stack_returnaddr
;
        ADR     R14,save_block
        LDMIA   R14,{R0-R9}             ; R10 irrelevant, R12 set up already
        Push    "R0-R10,R12"            ; create space on stack
;
; these variables are not reloaded at the start of the loop
;
        LDR     xdiv,save_xdiv
        LDR     xadd,save_xadd
        LDR     masko,save_masko
;
        LDR     R14,spritecode
        AND     R14,R14,#&FF
        TEQ     R14,#SpriteReason_PutSpriteScaled
        BEQ     gonextrow               ; loads up inptr, outptr
        TEQ     R14,#SpriteReason_PutSpriteGreyScaled
        BEQ     gogreyscale
;
; if plotting a mask, inptr --> mask itself
;
        LDR     R14,save_inptr          ; inptr --> mask instead of pixels
        ADD     R14,R14,masko
        STR     R14,save_inptr          ; *** R12 not corrupted yet !!!

        B       gonextmaskrow

nextrow
        LDMIA   R13,{inshift,outword,outmask,xsize,xcount}  ; unchangeable!

        STR     PC,stack_returnaddr
        LDR     PC,stack_calladdr
        NOP
;
        TEQ     outword,#&80000000
        BEQ     %FT02
;
        LDR     R14,stack_BPP                   ; R14 = bpp
        RSB     R14,R14,#32
        MVN     im1,#0
        MOV     im1,im1,ASL R14
;
        LDR     R14,stack_BPP                   ; prep up another register
01
        CMP     R14,#32
        MOVEQ   outmask,im1
        BEQ     %FT03                           ; AMG special case for 32BPP

        MOVS    outword,outword,LSR R14
        ORR     outmask,im1,outmask,LSR R14     ; set all bits from here
        BCC     %BT01
;
03      STR     PC,stack_returnaddr
        LDR     PC,stack_calladdr2              ; call 'putword'
        NOP
02
;
; go on to next row (including the first time)
;
gonextrow
        LDR     R12,stack_wsptr
        LDMIA   R12,{outoffset,inoffset,inptr,outptr,ydiv,yadd,ysize,ycount}
        LDR     R14,stack_vcount                ; =0 first time round
        SUBS    ysize,ysize,R14
        BEQ     donesprite                      ; finished!
;
        TEQ     R14,#0
01
        SUBNE   outptr,outptr,outoffset         ; move up appropriate amount
        SUBNES  R14,R14,#1
        BNE     %BT01
;
02
        SUBS    ycount,ycount,ydiv              ; room for an output row?
        ADDCS   R14,R14,#1                      ; yes
        BCS     %BT02
        ADD     ycount,ycount,ydiv              ; oops!
;
        TEQ     R14,#0                          ; any to do?
        BNE     %FT11

        STR     R0,stack_temp1
        STR     R1,stack_temp2

        LDR     R0,save_maskinptr
        LDR     R1,save_maskinoffset
        SUB     R0,R0,R1
        STR     R0,stack_maskinptr
        STR     R0,save_maskinptr
        LDR     R0,save_maskinshift
        STR     R0,stack_maskinshift

        LDR     R0,stack_temp1
        LDR     R1,stack_temp2

        SUB     inptr,inptr,inoffset            ; inptr --> row above
        ADD     ycount,ycount,yadd              ; if input row is not enough,
        B       %BT02                           ; try again
11
;
        CMP     R14,ysize
        MOVGT   R14,ysize
        STR     R14,stack_vcount
;
        ADR     R12,save_inptr
        STMIA   R12,{inptr,outptr,ydiv,yadd,ysize,ycount}
        B       nextrow
;
donesprite
        LDR     R12,stack_wsptr
        ADD     R13,R13,#:INDEX:stack_end       ; restore stack frame
;
        Push    "PC"
        SWI     XOS_RestoreCursors              ; preserve error state
        Pull    "LR"
        TEQP    LR,#0
;
        B       exitbiggie

;
; equivalent code for mask plotting (using background GCOL action)
;

nextmaskrow
        LDMIA   R13,{inshift,outword,outmask,xsize,xcount,ecfptr}  ; constant!
;
        ;if doing a new format mask sprite need to change inshift
        LDR     R12,stack_wsptr               ; get back the workspace base
        LDR     R11,save_spr_type             ; fetch the sprite type
        MOVS    R11,R11,LSR #27               ; test for T=0
        LDRNE   inshift,save_maskinshift      ; if T>0 need to change the inshift
        STRNE   inshift,save_inshift          ;   that we use to suit the 1bpp data

        STR     PC,stack_returnaddr
        LDR     PC,stack_calladdr
        MOV     R0,R0
;

        TEQ     outword,#&80000000
        BEQ     %FT02
        LDR     R14,stack_BPP
01
        MOVS    outword,outword,LSR R14
        BCC     %BT01
;

        STR     PC,stack_returnaddr
        LDR     PC,stack_calladdr2              ; call 'putword'
        MOV     R0,R0
02
;
; go on to next row (including the first time)
;
gonextmaskrow
        LDR     R14,stack_vcount                      ; =0 first time round
        LDR     ecfptr,stack_ecfptr
        LDR     yadd,stack_ecflimit
        SUB     ecfptr,ecfptr,R14,ASL #3              ; 8 bytes per pixel row
        SUB     ecfptr,ecfptr,yadd
        ANDS    ecfptr,ecfptr,#4*16-1
        ADDEQ   ecfptr,ecfptr,#4*16
        ADD     ecfptr,ecfptr,yadd
        STR     ecfptr,stack_ecfptr
;
        LDR     R12,stack_wsptr
        LDMIA   R12,{outoffset,inoffset,inptr,outptr,ydiv,yadd,ysize,ycount}
        SUBS    ysize,ysize,R14
        BEQ     donesprite                      ; finished!
;
        MUL     R14,outoffset,R14
        SUB     outptr,outptr,R14               ; move up appropriate amount
;
        MOV     R14,#0
02
        SUBS    ycount,ycount,ydiv              ; room for an output row?
        ADDCS   R14,R14,#1                      ; yes
        BCS     %BT02
        ADD     ycount,ycount,ydiv              ; oops!
;
        TEQ     R14,#0                          ; any to do?
        BNE     %FT03

        LDR     R11,save_spr_type               ; needs R12 to be right
        MOVS    R11,R11,LSR #27
        BEQ     %FT04                           ; skip 1bpp mask stuff if old format

        STR     R0,stack_temp1
        STR     R1,stack_temp2

        LDR     R0,save_maskinptr
        LDR     R1,save_maskinoffset
        SUB     R0,R0,R1
        STR     R0,stack_maskinptr
        STR     R0,save_maskinptr
        LDR     R0,save_maskinshift
        STR     R0,stack_maskinshift

        LDR     R0,stack_temp1
        LDR     R1,stack_temp2
04
        SUB     inptr,inptr,inoffset            ; inptr --> row above
        ADD     ycount,ycount,yadd              ; if input row is not enough,
        B       %BT02                           ; try again
;
03
        CMP     R14,ysize
        MOVGT   R14,ysize
        STR     R14,stack_vcount
;
        ADR     R12,save_inptr
        STMIA   R12,{inptr,outptr,ydiv,yadd,ysize,ycount}
        B       nextmaskrow

      ]
a2964 221

      [ remoldcompiler
      |

;;----------------------------------------------------------------------------
;; Scale 4-bits-per-pixel greyscale sprite into another
;; parameters set up as for the other types of sprite plotting
;;----------------------------------------------------------------------------

fcolbit         *       &80000000
frowbit         *       &40000000

; z zf zyf zs zys
; xcount ycount
; inputcell outword outptr
; flags
; Ra (Rb=zyf) (Rc=z)

; nextrowdata (12)
; nextcoldata (12)
; TOTAL
; XTOTAL

        MakeSpriteErrorBlock BadGreyScale,,BadGScl

defaultpixeltable
        DCB     0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15

gogreyscale
        LDR     R14,save_inlog2bpp
        TEQ     R14,#2
        ADRNE   R0, ErrorBlock_BadGreyScale
        addr    r1, Title, NE
        BLNE    copy_error_one                  ; Always sets the V bit
        BVS     donesprite                      ; restore cursors & stack
;
        LDR     Ra,ColourTTR                    ; pointer to pixel table?
        CMP     Ra,#0
        ADRNE   Ra,defaultpixeltable
        STRNE   Ra,ColourTTR
;
        LDR     Ra,save_xdiv
        LDR     Rb,save_ydiv
        MUL     R14,Ra,Rb
        STR     R14,save_xftimesyf
;
        LDR     inputcell,save_inptr
        MOV     inputcell,inputcell,LSL #3-2
        LDR     R14,save_inshift
        ADD     inputcell,inputcell,R14,LSR #2  ; 4 bits per pixel
;
        LDR     outptr,save_outptr
;
        LDR     zys,save_ycount
        LDR     ycounter,save_inputysize
        LDR     R14,save_ysize
        STR     R14,save_tempysize
nextgsrow
        LDR     outword,save_outword
        LDR     R14,[outptr]
01
        MOV     R14,R14,LSL #4
        MOVS    outword,outword,LSR #4
        BCC     %BT01
        LDR     outword,save_outword
        ORR     outword,outword,R14             ; initial output word
;
        LDR     zyf,save_ydiv
;
        ORR     flags,flags,#fcolbit            ; firstcolumn := true
        LDR     zs,save_xcount
        LDR     xcounter,save_inputxsize
        LDR     R14,save_xsize
        STR     R14,save_tempxsize
nextgscolumn
        LDR     zf,save_xdiv
        MOV     R14,#0
        STR     R14,TOTAL
        ORR     flags,flags,#frowbit            ; firstrow := true
        Push    "ycounter,zys,zyf"
mainloop1
        MOV     R14,#0                          ; sub-pixel total
        STR     R14,XTOTAL
        Push    "inputcell,xcounter,zs,zf"
mainloop2
        CMP     zs,zf
        MOVCC   z,zs
        MOVCS   z,zf
;
; add weighted input cell to row total
;
        MOVS    R14,inputcell,LSR #1            ; get pixel address
        LDRB    R14,[R14]
        ANDCC   R14,R14,#&0F                    ; low-order pixel
        MOVCS   R14,R14,LSR #4                  ; high-order pixel
;
        LDR     Ra,XTOTAL
        MLA     Ra,z,R14,Ra
        STR     Ra,XTOTAL
;
        SUBS    zs,zs,z
        LDREQ   zs,save_xmag
        ADDEQ   inputcell,inputcell,#1          ; go right 1 column
        SUBEQ   xcounter,xcounter,#1
        SUBS    zf,zf,z

        TEQNE   xcounter,#0
        BNE     mainloop2
;
        TST     flags,#frowbit                  ; if first row,
        BICNE   flags,flags,#frowbit
        ADRNE   R14,nextcoldata
        STMNEIA R14,{inputcell,zs,xcounter}       ; save for later.
;
; add row total into cell total
;
        Pull    "inputcell,xcounter,zs,zf"
;
        CMP     zys,zyf
        MOVCC   z,zys
        MOVCS   z,zyf
;
        LDR     Ra,TOTAL
        LDR     R14,XTOTAL
        MLA     Ra,R14,z,Ra
        STR     Ra,TOTAL
;
        SUBS    zys,zys,z
        LDREQ   zys,save_ymag
        LDREQ   R14,save_inoffset
        SUBEQ   inputcell,inputcell,R14,LSL #3-2   ; go up 1 row
        SUBEQ   ycounter,ycounter,#1
        SUBS    zyf,zyf,z
        TEQNE   ycounter,#0
        BNE     mainloop1
;
; now divide total for this cell by (xf*yf)
;
        LDR     Ra,TOTAL
        LDR     Rb,save_xftimesyf               ; zyf not used
        ADD     Ra,Ra,Rb,ASR #1                         ; round to nearest
        DivRem  Rc,Ra,Rb, R14                   ; z not used
        CMP     Rc,#16
        MOVCS   Rc,#15                                  ; 4-bit answer
;
        LDR     R14,ColourTTR           ; pixel look-up
        LDRB    Rc,[R14,Rc]
        LDR     R14,BPP
        MOV     Rc,Rc,ROR R14
        ORRS    outword,Rc,outword,LSR R14
        STRCS   outword,[outptr],#4
        MOVCS   outword,#&80000000
;
; if first column, save data for nextgsrow
;
        TST     flags,#fcolbit                  ; if first column,
        BICNE   flags,flags,#fcolbit
        ADRNE   R14,nextrowdata
        STMNEIA R14,{inputcell,zys,ycounter}      ; save for later.
;
; move right one output pixel
;
        Pull    "ycounter,zys,zyf"
        ADR     R14,nextcoldata
        LDMIA   R14,{inputcell,zs,xcounter}
        LDR     R14,save_tempxsize
        SUBS    R14,R14,#1
        STR     R14,save_tempxsize
        BGT     nextgscolumn
;
        TEQ     outword,#&80000000
        BEQ     %FT02
        MOV     Ra,#&FFFFFFFF
        LDR     R14,BPP
01
        MOV     Ra,Ra,LSR R14
        MOVS    outword,outword,LSR R14
        BCC     %BT01
        LDR     Rb,[outptr]
        BIC     Rb,Rb,Ra                ; should really depend on GCOL action
        ORR     Rb,Rb,outword
        STR     Rb,[outptr]
02
        LDR     R14,save_outoffset
        LDR     outptr,save_outptr
        SUB     outptr,outptr,R14
        STR     outptr,save_outptr
;
        ADR     R14,nextrowdata
        LDMIA   R14,{inputcell,zys,ycounter}
        LDR     R14,save_tempysize
        SUBS    R14,R14,#1
        STR     R14,save_tempysize
        BGT     nextgsrow
;
        B       donesprite


;;-----------------------------------------------------------------------------
;; Compile appropriate 'macro' for doing scaled SpriteOp's
;; Entry:  [macroword] = bits indicating state of macro
;;                0..2 = gcol action
;;                   3 = mask / no mask (used for input masking)
;;                   4 = ttr / no ttr
;;                   5 = plotmask / putsprite
;;                   6 = transformed / scaled
;; ( if ignore_ttr)  7 = use palette entries and ignore ttr (<16 to >8bpp only)
;;               8..15 = inbpp
;;              16..23 = outbpp
;;                  24 = transformed sprite routine/scaled sprite routine (version 23 and above)
;;         ColourTTR
;;         spritecode
;;         save_inshift
;;         save_inbpp
;;         BPP
;;         R5          = gcol action
;; Exit:   code recompiled if necessary
;;         ecflimit, outoffset updated inside code
;;-----------------------------------------------------------------------------

      ]
d2980 1
a2980 14
                ^       0
l_newword       #       4
l_newpixel      #       4
l_tryoutput     #       4
l_fref          #       4               ; forward reference
l_putmany       #       4
l_vloop         #       4
l_putword       #       4
l_max           #       0

vv_inbpp        RN      R6
vv_inbpp1       RN      R7
vv_outbpp       RN      R8
vv_outbpptop    RN      R9
a2981 1
BLEQ            *       &0B000000
a2997 1402
        GBLA    ldmreg
        GBLS    ldmreg2

xxx     *       2

        MACRO
$l      Asm     $label,$cc
$l      GetAsm  $label,$cc
        PutAsm  $label,$cc
        MEND

        MACRO
$l      GetAsm  $label,$cc
ldmreg  SETA    ($label.end-$label+4):SHR:2
ldmreg2 SETS    "$ldmreg":RIGHT:1
      [ ldmreg>1
$l      ADR$cc  R1,$label
        LDM$cc.IA R1,{R1-R$ldmreg2}
      |
$l      LDR$cc  R1,$label
      ]
        MEND

        MACRO
$l      SetImm  $reg,$value,$cc
$l      EOR$cc  $reg,$reg,#xxx
        EOR$cc  $reg,$reg,$value
        MEND

        MACRO
$l      SetLsr  $reg,$value,$cc
$l      EOR$cc  $reg,$reg,#xxx:SHL:7
        EOR$cc  $reg,$reg,$value,LSL #7
        MEND

        MACRO
$l      SetLsl  $reg,$value,$cc
$l      EOR$cc  $reg,$reg,#xxx:SHL:7
        EOR$cc  $reg,$reg,$value,LSL #7
        MEND

        MACRO
$l      PutAsm  $label,$cc
ldmreg  SETA    ($label.end-$label+4):SHR:2
ldmreg2 SETS    "$ldmreg":RIGHT:1
        [ debugcg
        STMFD R13!,{R9,R14}
        MOV R9,#$ldmreg2
        BL ag_disasm
        LDMFD R13!,{R9,R14}
        ]
$l      STM$cc.IA R10!,{R1-R$ldmreg2}
        MEND

        MACRO
$l      Label   $lab
$l      STR     R10,[sp,#$lab]
        MEND

        MACRO
$l      Branch  $op,$lab
$l      LDR     R0,[sp,#$lab]
        SUB     R0,R0,R10
        SUB     R0,R0,#8
        MOV     R0,R0,LSL #6
        MOV     R0,R0,LSR #8
        ORR     R0,R0,#$op
        STR     R0,[R10],#4
        MEND

      [ remoldcompiler
      |

compilemacro
        Push    "R11,LR"
        [ multibuffer
        Debug    mb,""
        Debug    mb,"Multibuffer code is enabled...."
        ]
;
        AND     R11,R5,#mc_gcol:OR:mc_hasmask
        LDR     R14,ColourTTR
        CMP     R14,#0
        ORRNE   R11,R11,#mc_ttr
        LDR     R14,spritecode
        AND     R14,R14,#&FF
        TEQ     R14,#SpriteReason_PlotMaskScaled
        ORREQ   R11,R11,#mc_plotmask
        BICEQ   R11,R11,#mc_ttr
        LDR     R14,BPP
        ORR     R11,R11,R14,LSL #mcb_outbpp
        LDR     R14,[R1,#spMode]
        MOV     R14,R14,LSR #27
        ORR     R11,R11,R14,LSL #mcb_sprtype   ;include sprite type
        LDR     R14,save_inbpp
        ORR     R11,R11,R14,LSL #mcb_inbpp

        ; from the addition of 1bpp mask handling the macroword generated by both
        ; macro generators adds the sprite type to the information in the macro
        ; word, at bit 24 up. this is necessary to ensure that a mask routine for
        ; a 1bpp mask can be distinguished from a mask routine for old mask format.

        [ ignore_ttr
        TST     R11,#mc_plotmask
        BNE     %FT21
        LDR     R14,trns_palette
        TEQ     R14,#0
        ORRNE   R11,R11,#mc_ttrispalette
21
        ]
;
        [ multibuffer

        STMFD   R13!,{R6-R10}
        Debug   mb,"Macroword is ",R11
        ;usage of registers....
        ;r6 - slot to overwrite
        ;r7 - least used count so far
        ;r8 - buffer number
        ;r11 - macroword
        ;r9 & r14 available

        MOV     R6,#0
        MOV     R7,#bignum
        MOV     R8,#0

        ADR     R9,buffer0mask
        ADR     R10,buffer0count

        Debug   mb,"Looking at entry ",R8
40
        LDR     R14,[R9,R8]     ;fetch the macroword used for the routine
        Debug   mb,"Current macroword in this slot ",R14
        TEQ     R11,R14
        BEQ     %FT41           ;this routine has already been built
                                ;increment its usage count and use it
        LDR     R14,[R10,R8]     ;fetch the count for the routine
        Debug   mb,"Usage count ",R14
        CMP     R14,R7          ;has this been used less than the maximum?
        MOVCC   R6,R8           ;if so, it's the one to build over
        MOVCC   R7,R14          ;and reduce the limit

        Debug   mb,"Slot to overwrite ",R6
        ADD     R8,R8,#4
        CMP     R8,#(nbuffers :SHL: 2) ;done all buffers yet ?
        BNE     %BT40           ;no, so go back and try again

        ;there isn't a matching routine. R6 is the slot number to overwrite
        Debug   mb,"About to replace routine in slot ",R6
        Debug   ms,"Building code for ",R11
        [ debugms
        LDR     R14,[R9,R6]
        Debug   ms,"Discarding ",R14
        ]
        STR     R11,[R9,R6]     ;update the macroword for the slot
        ADR     R9,buffer0count
        MOV     R14,#1
        STR     R14,[R9,R6]     ;and set its usage count
        STR     R11,macroword
        STR     R6,thisslot     ;save the slot number for 'fillins'
        LDMFD   R13!,{R6-R10}
        B       %FT42           ;and go and compile the routine

41
        Debug   mb,"The routine already exists..."
        ;Debug   ms,"Code already built for ",R11
        LDR     R14,[R10,R8]
        ADD     R14,R14,#1
        STR     R14,[R10,R8]
        Debug   mb,"New usage count for this routine ",R14
        STR     R8,thisslot
        STR     R11,macroword
        LDMFD   R13!,{R6-R10}
        B       do_fillins
42
        |
        LDR     R14,macroword
        TEQ     R11,R14        ;is code already built ?
        BEQ     do_fillins     ;EQ: it is, so just update values in it
;
        STR     R11,macroword
        ]
;
; compile appropriate code, depending on value of R11 (macroword)
;
        Push    "R1-R10"
        SUB     sp,sp,#l_max            ; create local stack frame
        [ multibuffer
        ADR     R10,codebuffer0
        Debug   mb,"Codebuffer is at ",R10
        LDR     R14,thisslot            ;presently 0,4,8 or 12
        Debug   mb,"Slot number ",R14
                                        ;need 0,&200,&400,&600
        ADD     R10,R10,R14,LSL #7      ;R10 is now the correct buffer
        Debug   mb,"Codebuffer being used: ",R10
        |
        ADR     R10,codebuffer
        ]
;
        Debug   mc,"Compilemacro: R10,R11 =",R10,R11
        Debug   cg,"Compilemacro: R10,R11 =",R10,R11
;
        MOV     R14,R11,LSR #mcb_inbpp
        AND     vv_inbpp,R14,#&FF
        MOV     R14,R11,LSR #mcb_outbpp
        AND     vv_outbpp,R14,#&FF
        MOV     R14,#1
        MOV     R14,R14,LSL vv_inbpp
        SUB     vv_inbpp1,R14,#1        ; inbpp1 = 2^inbpp-1

        MOV     R14,#1:SHL:31
        MOV     R14,R14,ASR vv_outbpp
        MOV     R0,R14,LSL #1           ; outbpptop = 2^31 >> outbpp << 1
        BL      convert_ROR
        MOV     vv_outbpptop,R0         ; convert to opcode form
;
        Debug   cg,"{{{{{{{{{{{{{{{{{{{ Recompiling code }}}}}}}}}}}}}}}}}}}}"
        Debug   cg,""
        Debug   cw,"###### asm_newword ######"
        BL      asm_newword
        Debug   cw,""
        Debug   cs,"###### asm_start ######"
        BL      asm_start
        Debug   cs,""
        Debug   cn,"###### asm_newpixel ######"
        BL      asm_newpixel
        Debug   cn,""
        Debug   co,"###### asm_tryoutput ######"
        BL      asm_tryoutput
        Debug   co,""
        Debug   cp,"###### asm_putmany ######"
        BL      asm_putmany
        Debug   cp,""
        Debug   cu,"###### asm_putword ######"
        BL      asm_putword
        Debug   cu,""
        Debug   cg,"###### code built ######"
;
        Debug   cg,"End of Compiled code:",R10
;
        LDR     R10,[sp,#l_fref]        ; complete the forward reference
        Branch  BCS,l_putword
;
        ADD     sp,sp,#l_max
        Pull    "R1-R10"

do_fillins
        [ multibuffer
        ADR     R14,pc_ecflimit0
        LDR     R11,thisslot
        Debug   mb,"Doing fillins for routine ",R11
        LDR     R11,[R14,R11]
        CMP     R11,#0
        Debug   mb,"pc_ecflimit for this routine ",R11
        LDRNE   R0,save_ecflimit
        BLNE    convert_ROR
        LDRNE   R14,m_ecflimit
        SetImm  R14,R0,NE
        STRNE   R14,[R11]

        [ debugmb
        Debug   mb,"save_ecflimit (as imm)",R0
        Debug   mb,"composite word to store",R14
        ]
;
        |
        LDR     R11,pc_ecflimit
        CMP     R11,#0
        LDRNE   R0,save_ecflimit
        BLNE    convert_ROR
        LDRNE   R14,m_ecflimit
        SetImm  R14,R0,NE
        STRNE   R14,[R11]
;
        ]
;
        [ multibuffer
        ;set up the correct calladdr and calladdr2 for now...
        LDR     R14,thisslot
        Debug   mb,"Setting up calladdrs, slot=",R14
        ADR     R0,calladdr0
        LDR     R0,[R0,R14]
        Debug   mb,"Calladdr = ",R0
        STR     R0,save_calladdr

        ADR     R0,calladdr20
        LDR     R0,[R0,R14]
        Debug   mb,"Calladdr2 = ",R0
        STR     R0,save_calladdr2
        ]

        Pull    "R11,PC"

;
; Entry:  R0 = immediate constant
; Exit:   R0 = value to ORR into instruction opcode
;

convert_ROR
        EntryS
      [ {TRUE}
        BIC     R0, R0, #3:SHL:0
      ]
        MOV     R14,#16                 ; assume R0 bits 0,1 unset on entry
01
        TST     R0,#3                   ; assume R0<>0 on entry
        MOVEQ   R0,R0,LSR #2
        SUBEQ   R14,R14,#1
        BEQ     %BT01
        ORR     R0,R0,R14,LSL #8

        EXITS                           ; preserve flags


; ############################## code fragments for newword

pm_newword_ext          LDR     im1,[inptr,masko]
                        MOVS    im1,im1,LSR #xxx        ; inbpp
                        MOVCS   im2,#0
pm_newword_extend       LDRCC   im2,stack_maskword      ; (2^outbpp-1) ROR outbpp
                        ASSERT  (pm_newword_extend -pm_newword_ext) = (pm_newwordend -pm_newword)


tm1_newword1_ext        LDR     im1,stack_maskinptr
                        LDR     im2,stack_maskinshift
                        LDR     im1,[im1]
tm1_newword1_extend     MOV     im1,im1,LSR im2          ; inbpp
tm1_newword2_ext        MOVS    im1,im1,LSR #1
                        MOVCS   im2,#0
tm1_newword2_extend     LDRCC   im2,stack_maskword      ; (2^outbpp-1) ROR outbpp


pm1_newword1_ext        LDR     im1,stack_maskinptr
                        LDR     im2,stack_maskinshift
                        LDR     im1,[im1]
pm1_newword1_extend     MOV     im1,im1,LSR im2          ; inbpp
pm1_newword2_ext        MOVS    im1,im1,LSR #1
                        MOVCS   im2,#0
pm1_newword2_extend     LDRCC   im2,stack_maskword      ; (2^outbpp-1) ROR outbpp


tm_newword_ext          LDR     im1,stack_masko
                        LDR     im1,[inptr,im1]
                        MOVS    im1,im1,LSR #xxx        ; inbpp
                        MOVCS   im2,#0
tm_newword_extend       LDRCC   im2,stack_maskword      ; (2^outbpp-1) ROR outbpp
                        ASSERT  (tm_newword_extend -tm_newword_ext) = (tm_newwordend -tm_newword)

; ### plot mask, old format mask

pm_newword              LDR     im1,[inptr,masko]
                        MOVS    im1,im1,LSR #xxx        ; inbpp
                        MOVCS   im2,#0
pm_newwordend           MOVCC   im2,#xxx                ; (2^outbpp-1) ROR outbpp


; ### plot mask, new format mask

pm1_newword1            LDR     im1,stack_maskinptr
                        LDR     im2,stack_maskinshift
                        LDR     im1,[im1]
pm1_newword1end         MOV     im1,im1,LSR im2
pm1_newword2            MOVS    im1,im1,LSR #1
                        MOVCS   im2,#0
pm1_newword2end         MOVCC   im2,#xxx                ; (2^outbpp-1) ROR outbpp


; ### plot mask, new format mask, 16/32bpp

pm1_newword132          LDR     im1,stack_maskinptr
                        LDR     im2,stack_maskinshift
                        LDR     im1,[im1]
pm1_newword132end       MOV     im1,im1,LSR im2
pm1_newword232          MOVS    im1,im1,LSR #1
                        MOVCS   im2,#0
pm1_newword232end       LDRCC   im2,stack_maskword      ; (2^outbpp-1) ROR outbpp


; ### new plot word

p_newword               LDR     in1,[inptr],#4
                        MOV     in2,in1,LSL #xxx        ; 32-inbpp
                        MOVS    in1,in1,LSR #xxx        ; inbpp
                        ORR     in1,in1,#1:SHL:31
p_newwordend            MOV     PC,LR


; ### new plot word, 32bpp

p_newword32             LDR     in2,[inptr],#4
                        MOV     in1,#1
                        MOVS    in1,in1,LSR #1
                        ORR     in1,in1,#&80000000
p_newword32end          MOV     PC,LR


; ### transform/mask new word, old mask

tm_newword              LDR     im1,stack_masko
                        LDR     im1,[inptr,im1]
                        MOVS    im1,im1,LSR #xxx        ; inbpp
                        MOVCS   im2,#0
tm_newwordend           MOVCC   im2,#xxx                ; (2^outbpp-1) ROR outbpp


; ### transform/mask new word, new mask

tm1_newword1            LDR     im1,stack_maskinptr
                        LDR     im2,stack_maskinshift
                        LDR     im1,[im1]
                        MOV     im1,im1,LSR im2
tm1_newword1end         MOVS    im1,im1,LSR #1
tm1_newword2            MOVCS   im2,#0
tm1_newword2end         MOVCC   im2,#xxx                ; (2^outbpp-1) ROR outbpp


; ### transform/mask new word, new mask, 16/32bpp

tm1_newword1ext         LDR     im1,stack_maskinptr
                        LDR     im2,stack_maskinshift
                        LDR     im1,[im1]
                        MOV     im1,im1,LSR im2
tm1_newword1extend      MOVS    im1,im1,LSR #1
tm1_newword2ext         MOVCS   im2,#0
tm1_newword2extend      LDRCC   im2,stack_maskword      ; (2^outbpp-1) ROR outbpp


; ### transform new word 32bpp

t_newword32             LDR     in2,[inptr],#4
                        MOV     in1,#1
                        MOV     in1,in1,LSR #1
                        ORR     in1,in1,#1:SHL:31
t_newword32end          MOV     PC,LR


; ### transform new word 16bpp

t_newword161            LDR     in1,[inptr],#4
                        MOV     in2,in1,LSL #16
t_newword161end         MOV     in2,in2,LSR #16
t_newword162            MOV     in1,in1,LSR #16         ; inbpp
                        ORR     in1,in1,#1:SHL:31
t_newword162end         MOV     PC,LR


; ### transform new word <16bpp

t_newword               LDR     in1,[inptr],#4
                        AND     in2,in1,#xxx            ; 2^inbpp-1
                        MOV     in1,in1,LSR #xxx        ; inbpp
                        ORR     in1,in1,#1:SHL:31
t_newwordend            MOV     PC,LR


; ### update 1bpp mask controls

;code fragment for updating maskinptr and maskinshift.

msk_increment1          STR     im1,stack_temp1
                        STR     im2,stack_temp2
                        LDR     im1,stack_maskinshift
                        LDR     im2,stack_maskinptr
msk_increment1end       ADD     im1,im1,#xxx             ;pixels per word
msk_increment2          CMP     im1,#32
                        ADDCS   im2,im2,#4
                        MOVCS   im1,#0
msk_increment2end       STR     im1,stack_maskinshift
msk_increment3          STR     im2,stack_maskinptr
                        LDR     im1,stack_temp1
msk_increment3end       LDR     im2,stack_temp2


; ### mask new word

m_newword               LDR     in1,[inptr],#4
                        MOVS    in1,in1,LSR #xxx        ; inbpp
                        ORR     in1,in1,#1:SHL:31
m_newwordend            MOV     PC,LR


; ### new mask word for 1bpp

m1_newword1             LDR     im2,stack_maskinptr
                        LDR     im1,stack_maskinshift
                        LDR     in1,[im2]
                        MOV     in1,in1,LSR im1
m1_newword1end          ADD     im1,im1,#xxx             ;pixels per word
m1_newword2             CMP     im1,#32
                        ADDCS   im2,im2,#4
                        MOVCS   im1,#0
                        STR     im1,stack_maskinshift
m1_newword2end          STR     im2,stack_maskinptr
m1_newword3             MOVS    in1,in1,LSR #1
                        ORR     in1,in1,#1:SHL:31
m1_newword3end          MOV     PC,LR


asm_newword
                        Debug   cw,"*** asm_newword"
                        Label   l_newword
;
                        TST     R11,#mc_plotmask
                        BNE     %FT02
                        TST     R11,#mc_ttr
                        BNE     %FT01
;
                        TST     R11,#mc_hasmask
                        BEQ     %FT47
;
                        MOVS    R2,R11,LSR #mcb_sprtype
                        BEQ     %FT46

                        TST     R11,#mc_plotmask
                        BNE     %FT46

                        CMP     vv_outbpp,#16
                        Asm     pm1_newword1,LT
                        GetAsm  pm1_newword2,LT
                        SetImm  R3,vv_outbpptop,LT
                        PutAsm  pm1_newword2,LT

                        Asm     pm1_newword132,GE
                        Asm     pm1_newword232,GE

                        B       %FT47
46
                        CMP     vv_outbpp,#16
                        GetAsm  pm_newword,LT                   ; pick up code for 8 bit per pixel or less
                        SetImm  R4,vv_outbpptop,LT             ; modify based on output pixels
                        GetAsm  pm_newword_ext,GE               ; pick up code for 16 bit per pixel or greater
;
                        SetLsr  R2,vv_inbpp                     ; and write input information into it
                        Debug   cw,"pm_newword"
                        PutAsm  pm_newword, LT
                        PutAsm  pm_newword_ext, GE
47
                        TST     R11,#mc_hasmask
                        BEQ     %FT61

                        ;if it has a new format mask, include the code to increment it
                        MOVS    R1,R11,LSR #mcb_sprtype
                        BEQ     %FT61

                        TST     R11,#mc_plotmask
                        BNE     %FT61

                        LDR     R1,save_inlog2bpp
                        MOV     R0,#32
                        MOV     R0,R0,LSR R1

                        GetAsm  msk_increment1
                        SetImm  R5,R0
                        PutAsm  msk_increment1

                        Asm     msk_increment2
                        Asm     msk_increment3

61
                        CMP     vv_inbpp,#32
                        BCS     %FT48

                        GetAsm  p_newword
                        RSB     R0,vv_inbpp,#32                ; R0 = 32-inbpp
                        SetLsl  R2,R0
                        SetLsr  R3,vv_inbpp
                        PutAsm  p_newword
                        B %FT49
48
                        Asm     p_newword32
49
                        Debug   cw,"p_newword"
                        MOV     PC,LR
01
                        TST     R11,#mc_hasmask
                        BEQ     %FT47
;
                        MOVS    R1,R11,LSR #mcb_sprtype
                        BEQ     %FT71

                        CMP     vv_outbpp,#16
                        Asm     tm1_newword1,LT
                        GetAsm  tm1_newword2,LT
                        SetImm  R2,vv_outbpptop,LT
                        PutAsm  tm1_newword2,LT

                        Asm     tm1_newword1ext,GE
                        Asm     tm1_newword2ext,GE
                        B       %FT47

71
                        CMP     vv_outbpp,#16
                        Debug   cw,"tm_newword"
                        GetAsm  tm_newword,LT                   ; pick up code for 8 bpp or less
                        SetImm  R5,vv_outbpptop,LT              ; and modify the mask writing instruction
                        GetAsm  tm_newword_ext,GE               ; otherwise pick up code for greater depths
                        SetLsr  R3,vv_inbpp
                        PutAsm  tm_newword,LT                   ; always modify based on input bpp and write instructions
                        PutAsm  tm_newword_ext,GE
47

                        TST      R11,#mc_hasmask
                        MOVNES   R1,R11,LSR #mcb_sprtype
                        BEQ      %FT62
                        TST      R11,#mc_plotmask
                        BNE      %FT62

                        LDR     R1,save_inlog2bpp
                        MOV     R0,#32
                        MOV     R0,R0,LSR R1
                        GetAsm  msk_increment1
                        SetImm  R5,R0
                        PutAsm  msk_increment1
                        Asm     msk_increment2
                        Asm     msk_increment3
62
                        CMP     vv_inbpp,#16

                        Asm     t_newword32,GT

                        Asm     t_newword161,EQ
                        Asm     t_newword162,EQ

                        MOVCS   PC,LR

                        Debug   cw,"t_newword"
                        GetAsm  t_newword
                        SetImm  R2,vv_inbpp1
                        SetLsr  R3,vv_inbpp
                        PutAsm  t_newword

                        MOV     PC,LR
02
                        TST     R11,#mc_hasmask                 ; nothing at all if no mask
                        [ debugcw
                        BEQ     %FT03
                        Debug   cw,"m_newword" ;debugging macro is not conditional. pah!
03
                        ]
                        MOVEQ   PC,LR

                        MOVS    R2,R11,LSR #mcb_sprtype

                        GetAsm  m_newword,EQ
                        SetLsr  R2,vv_inbpp,EQ
                        PutAsm  m_newword,EQ

                        MOVEQ   PC,LR

                        MOV     R0,#32
                        GetAsm  m1_newword1
                        SetImm  R5,R0
                        PutAsm  m1_newword1

                        Asm     m1_newword2
                        Asm     m1_newword3

                        MOV     PC,LR

; second version, for use with prevailing NE execution
; unfortunately it has to change flags itself...

msk_incrementne1        STRNE   im1,stack_temp1
                        STRNE   im2,stack_temp2
                        LDRNE   im1,stack_maskinshift
                        BICNE   im1,im1,#xxx                 ;pixels per word -1
msk_incrementne1end     LDRNE   im2,stack_maskinptr
msk_incrementne2        ADDNE   im1,im1,#xxx             ;pixels per word
                        BEQ     %FT98                    ;skip the next bit if not executing
                        CMP     im1,#32
                        ADDCS   im2,im2,#4
msk_incrementne2end     MOVCS   im1,#0
msk_incrementne3        STR     im1,stack_maskinshift
                        CMP     R13,#0                   ;reset NE
98
                        STRNE   im2,stack_maskinptr
                        LDRNE   im1,stack_temp1
msk_incrementne3end     LDRNE   im2,stack_temp2


t_start                 LDR     ttr,stack_colourttr
t_startend              *       t_start

pmt_start               TEQ     inshift,#0
pmt_startend            MOVEQ   in1,#0

p_start                 LDRNE   im1,[inptr,masko]
p_startend              MOVNE   im1,im1,LSR inshift

p1_start1               LDRNE   im1,stack_maskinptr
                        LDRNE   im1,[im1]
                        STRNE   im2,stack_temp1
p1_start1end            LDRNE   im2,stack_maskinshift
p1_start2               MOVNE   im1,im1,LSR im2
p1_start2end            LDRNE   im2,stack_temp1


t_start2                LDRNE   im1,stack_masko
                        LDRNE   im1,[inptr,im1]
t_start2end             MOVNE   im1,im1,LSR inshift


t1_start212             STRNE   im2,stack_temp1
                        LDRNE   im1,stack_maskinptr
t1_start212end          LDRNE   im2,stack_maskinshift
t1_start222             LDRNE   im1,[im1]
                        MOVNE   im1,im1,LSR im2
t1_start222end          LDRNE   im2,stack_temp1

pmt_start2              LDRNE   in1,[inptr],#4
pmt_start2end           MOVNE   in1,in1,LSR inshift

pmt1_start2             LDRNE   im1,stack_maskinptr
                        LDRNE   im2,stack_maskinshift
                        LDRNE   in1,[im1]
pmt1_start2end          MOVNE   in1,in1,LSR im2


pt_start                ANDNE  in1,in1,im1
pt_startend             *       pt_start

pmt_start3              MOVNE   R14,#1
                        ORRNE   in1,in1,R14,ROR inshift
pmt_start3end           SUB     xcount,xcount,xadd

mm_start                MOV     in2,#xxx                        ; outbpp_top
mm_startend             SUB     xcount,xcount,xadd

mm_start16              MOV     in2,#&FF000000
                        ORR     in2,in2,in2,LSR #8
mm_start16end           SUB     xcount,xcount,xadd

mm_start32              MVN     in2,#0 ; &FFFFFFFF
mm_start32end           SUB     xcount,xcount,xadd

asm_start
                        Debug   cs,"*** asm_start"

                        [ multibuffer
                        STMFD   R13!,{R1,R14}
                        ADR     R1,calladdr0
                        LDR     R14,thisslot
                        STR     R10,[R1,R14]
                        LDMFD   R13!,{R1,R14}
                        |
                        STR     R10,save_calladdr
                        ]
;
                        AND     R0,R11,#mc_plotmask:OR:mc_hasmask
                        TEQ     R0,#mc_plotmask
                        BNE     %FT19
                        [ debugcs
                        Debug   cs,"mm_start(EQ)"
                        ]
                        CMP     vv_outbpp,#16
                        Asm     mm_start16,EQ
                        Asm     mm_start32,GT
                        GetAsm  mm_start,LT            ; all we need is in2, if no mask
                        SetImm  R1,vv_outbpptop,LT
                        PutAsm  mm_start,LT

                        MOV     PC,LR
19
;
                        TST     R11,#mc_ttr

                        Asm     t_start,NE
;
                        Debug   cs,"pmt_start"
                        Asm     pmt_start
                        TST     R11,#mc_plotmask
                        BNE     %FT01
                        TST     R11,#mc_hasmask
                        BEQ     %FT01
                        TST     R11,#mc_ttr
                        [ debugcs
                        B       %FT10
11      ; code is at end of routine - breaks an ADR otherwise!
                        ]
                        BNE     %FT16
                        MOVS    R1,R11,LSR #mcb_sprtype
                        Asm     p_start,EQ
                        Asm     p1_start1,NE
                        Asm     p1_start2,NE
                        B       %FT01
16
                        MOVS    R1,R11,LSR #mcb_sprtype
                        Asm     t_start2,EQ
                        Asm     t1_start212,NE
                        Asm     t1_start222,NE
01
                        Debug   cs,"pmt_start2"

        ; if plotting a 1bpp mask we don't use pmt_start2

                        TST     R11,#mc_plotmask
                        MOVNES  R2,R11,LSR #mcb_sprtype
                        BEQ     %FT09

                        Asm     pmt1_start2

                        B       %FT08

09
                        Asm     pmt_start2
08

                        TST     R11,#mc_plotmask
                        BNE     %FT02
                        TST     R11,#mc_hasmask
                        [ debugcs
                        BNE     %FT05
                        Debug   cs,"pt_start"
05
                        ]

        ; this segment does nothing useful since mask and image data are combined
        ; again below ... when dealing with 1bpp masks it becomes quite harmful
        ; since we are directly applying 1bpp data to nbpp data!

        ; Asm     pt_start,NE

02
                        TST     R11,#mc_hasmask
                        MOVNES  R1,R11,LSR #mcb_sprtype
                        BEQ     %FT17

; AMG bug-fix from SprExtend 0.53 merged in by WRS:
; changed assembler to reflect AMG bug fix in 0.62 (GPS)
                        LDR     R1,save_inlog2bpp
                        MOV     R0,#32
                        TST     R11,#mc_plotmask
                        MOVEQ   R0,R0,LSR R1        ; derive pix per word
                        SUB     R0,R0,#1

                        GetAsm  msk_incrementne1
;                        MOV     R0,#&1F
                        SetImm  R4,R0
                        PutAsm  msk_incrementne1

                        ADD     R0,R0,#1

                        GetAsm  msk_incrementne2
;                        MOV     R0,#32
                        SetImm  R1,R0
                        PutAsm  msk_incrementne2

                        Asm     msk_incrementne3

17
                        Debug   cs,"pmt_start3"
                        Asm     pmt_start3
                        MOV     PC,LR

                        [ debugcs
10
                        BNE     %FT03
                        Debug   cs,"p_start (NE)"
                        BEQ     %FT04
03                      Debug   cs,"t_start2 (EQ)"
04                      B       %BT11
                        ]


pmt_newpixel            ADD     xcount,xcount,xadd
pmt_newpixelend         *       pmt_newpixel

pt_newpixel             MOVS    im1,im1,LSR #xxx        ; inbpp
                        MOVCS   im2,#0
pt_newpixelend          MOVCC   im2,#xxx                ; (2^outbpp-1) ROR outbpp

pt1_newpixel            MOVS    im1,im1,LSR #1        ; inbpp
                        MOVCS   im2,#0
pt1_newpixelend         MOVCC   im2,#xxx                ; (2^outbpp-1) ROR outbpp

p_newpixel              MOV     in2,in1,LSL #xxx        ; 32-inbpp
p_newpixelend           MOVS    in1,in1,LSR #xxx        ; inbpp

t_newpixel              AND     in2,in1,#xxx            ; 2^inbpp-1
t_newpixelend           MOVS    in1,in1,LSR #xxx        ; inbpp

t_newpixel16            MOV     in2,in1
t_newpixel16end         MOVS    in1,in1,LSR #16

t_newpixel32            MOV     in2,in1
                        MOV     in1,#1
t_newpixel32end         MOVS    in1,in1,LSR #1

m1_newpixel             MOVS    in1,in1,LSR #1       ; inbpp
m1_newpixelend          *       m1_newpixel

m_newpixel              MOVS    in1,in1,LSR #xxx        ; inbpp
m_newpixelend           *       m_newpixel

m_newpixel32            MOV     in1,#1
m_newpixel32end         MOVS    in1,in1,LSR #1

m_newpixel2             MOVCC   in2,#0
m_newpixel2end          MOVCS   in2,#xxx                ; (2^outbpp-1) ROR outbpp

; ##### the macro generator should not be thrown more than five instructions
; ##### at a time, otherwise vv_inbpp (R6) gets cr*pped on !!!!!

t_newpx_16to321
                                                          ;       fedcba9876543210 fedcba9876543210
                                                          ; in2 = 0bbbbbgggggrrrrr
                        STR     im1,stack_temp1
                        MOV     im1,in2,LSR #26           ; im1 =                            0bbbbb
                        MOV     ttr,im1,LSL #19           ; ttr =        0bbbbb000 0000000000000000
                        AND     im1,in2,#&03E00000        ; im1 = 000000ggggg00000
t_newpx_16to321end      ORR     ttr,ttr,im1,LSR #10       ; ttr =        0bbbbb000 ggggg00000000000
t_newpx_16to322         MOV     im1,in2,LSL #11           ; im1 = rrrrr00000000000 0000000000000000
                        ORR     ttr,ttr,im1,LSR #24       ; ttr =        0bbbbb000 ggggg000rrrrr000
        ;now copy the top three bits of each colour component into the bottom three
                        MOV     im1,#&E0                  ;avoid an LDR for speed
                        ORR     im1,im1,im1,LSL #8
t_newpx_16to322end      ORR     im1,im1,im1,LSL #8        ; im1 = 0000000011100000 1110000011100000
t_newpx_16to323         AND     im1,im1,ttr               ; im1 = 00000000bbb00000 ggg00000rrr00000
                        ORR     in2,ttr,im1,LSR #5        ; in2 = 00000000bbbbbbbb ggggggggrrrrrrrr
t_newpx_16to323end      LDR     im1,stack_temp1

                                                              ;       fedcba9876543210 fedcba9876543210
t_newpx_32to161
                                                              ; in2 = 00000000bbbbbbbb ggggggggrrrrrrrr
                        AND     xadd,in2,#&F80000             ; im1 = 00000000bbbbb000 0000000000000000
                        MOV     ttr,xadd,LSL #7               ; ttr = 0bbbbb0000000000
                        AND     xadd,in2,#&F800               ; im1 = 0000000000000000 ggggg00000000000
t_newpx_32to161end      ORR     ttr,ttr,xadd,LSL #10          ; ttr = 0bbbbbggggg00000
t_newpx_32to162         AND     xadd,in2,#&F8                 ; im1 = 0000000000000000 00000000rrrrr000
                        ORR     in2,ttr,xadd,LSL #13          ; in2 = 0bbbbbgggggrrrrr
                        LDR     xadd,stack_xadd
t_newpx_32to162end      LDR     ttr,stack_colourttr

t_newpixel2             LDRB    in2,[ttr,in2]
t_newpixel2end          MOV     in2,in2,ROR #xxx        ; outbpp

                        [ ignore_ttr
t_newpixel3             LDR    in2,[ttr,in2,LSL #3]
t_newpixel3end          MOV    in2,in2,LSR #8
                 ; if 16 need to munge down into top two bytes, if 32 no
                 ; adjustment needed
                        ]

pt_newpixel_ext         MOVS    im1,im1,LSR #xxx        ; inbpp
                        MOVCS   im2,#0
pt_newpixel_extend      LDRCC   im2,stack_maskword      ; (2^outbpp-1) ROR outbpp
                        ASSERT  (pt_newpixel_extend -pt_newpixel_ext) = (pt_newpixelend -pt_newpixel)

pt1_newpixel_ext        MOVS    im1,im1,LSR #1        ; inbpp
                        MOVCS   im2,#0
pt1_newpixel_extend     LDRCC   im2,stack_maskword      ; (2^outbpp-1) ROR outbpp
                        ASSERT  (pt_newpixel_extend -pt_newpixel_ext) = (pt_newpixelend -pt_newpixel)

t_makeindex321          ;the 32K table use bits of r,g,b as the index, so 32bpp needs to
                        ;be munged down into 5bits of each colour
                        STR      im1,stack_temp1
                        ;im1 is being used as a temporary register here
                                                     ; in2 = 0000 0000 bbbb bbbb gggg gggg rrrr rrrr
                        MOV      im1,in2,LSR #19     ; im1 = 0000 0000 0000 0000 0000 0000 000b bbbb
                        MOV      im1,im1,LSL #5      ; im1 = 0000 0000 0000 0000 0000 00bb bbb0 0000
t_makeindex321end       MOV      in2,in2,LSL #16     ; in2 = gggg gggg rrrr rrrr 0000 0000 0000 0000
t_makeindex322          ORR      im1,im1,in2,LSR #27 ; im1 = 0000 0000 0000 0000 0000 00bb bbbg gggg
                        MOV      im1,im1,LSL #5      ; im1 = 0000 0000 0000 0000 0bbb bbgg ggg0 0000
                        MOV      in2,in2,LSL #8      ; in2 = rrrr rrrr 0000 0000 0000 0000 0000 0000
                        ORR      in2,im1,in2,LSR #27 ; in2 = 0000 0000 0000 0000 0bbb bbgg gggr rrrr
t_makeindex322end       LDR      im1,stack_temp1


t_makeindex16           MOV      in2,in2,LSL #17
t_makeindex16end        MOV      in2,in2,LSR #17

t_use32Ktable           ;note, there is an additional indirection to play with here!
                        STR     im1,stack_temp1
                        LDR     im1,[ttr,#4]
                        LDRB    in2,[im1,in2]
                        LDR     im1,stack_temp1
t_use32Ktableend        MOV     in2,in2,ROR #xxx ;outbpp


t_newpixel216           LDR     in2,[ttr, in2, ASL #2]
t_newpixel216end        MOV     in2,in2,ROR #xxx     ; outbpp
                        ASSERT  (t_newpixel216end -t_newpixel216) = (t_newpixel2end -t_newpixel2)

t_newpixel232           LDR     in2,[ttr, in2, ASL #2]
t_newpixel232end        NOP
                        ASSERT  (t_newpixel232end -t_newpixel232) = (t_newpixel2end -t_newpixel2)


m_newpixel2_ext         MOVCC   in2,#0
m_newpixel2_extend      LDRCS   in2,stack_maskword      ; (2^outbpp-1) ROR outbpp
                        ASSERT  (m_newpixel2_extend -m_newpixel2_ext) = (m_newpixel2end -m_newpixel2)
asm_newpixel
                        Label   l_newpixel

                        Debug   cn,"*** asm_newpixel"
;
                        Debug   cn,"pmt_newpixel"
                        Asm     pmt_newpixel
;
                        TST     R11,#mc_plotmask
                        BEQ     %FT01
                        TST     R11,#mc_hasmask         ; if no mask, no code needed!
                        MOVEQ   PC,LR

                        MOVS    R2,R11,LSR #mcb_sprtype
                        Asm     m1_newpixel,NE
                        BNE     %FT02

                        CMP     vv_inbpp,#32

                        Debug   cn,"m_newpixel"

                        Asm     m_newpixel32,CS
                        BCS     %FT02

                        GetAsm  m_newpixel
                        SetLsr  R1,vv_inbpp
                        PutAsm  m_newpixel
                        B       %FT02
01
                        TST     R11,#mc_hasmask
                        BEQ     %FT47

                        MOVS    R1,R11,LSR #mcb_sprtype
                        BEQ     %FT46

                        CMP     vv_outbpp,#16

                        GetAsm  pt1_newpixel,LT
                        SetImm  R3,vv_outbpptop,LT
                        PutAsm  pt1_newpixel,LT

                        Asm     pt1_newpixel_ext,GE
                        B       %FT47
46
                        CMP     vv_outbpp,#16
                        Debug   cn,"newpixel"
                        GetAsm  pt_newpixel,LT        ; pick up and modify the appropriate code
                        GetAsm  pt_newpixel_ext,GE
                        SetLsr  R1,vv_inbpp
                        SetImm  R3,vv_outbpptop,LT
                        PutAsm  pt_newpixel,LT
                        PutAsm  pt_newpixel_ext,GE
47
                        Debug   cn,"adding two words for ttr"

                        ;if doing 16->32 or 32->16

                        TST     R11,#mc_ttr
                        BNE     %FT51
                        ADR     R1,p_newpixel
                        LDMIA   R1,{R1,R2}
                        RSB     R0,vv_inbpp,#32
                        SetLsl  R1,R0
                        SetLsr  R2,vv_inbpp
                        STMIA   R10!,{R1-R2}
                        B       %FT02
51
                        CMP     vv_inbpp,#16

                        ADRCC   R1,t_newpixel
                        ADREQ   R1,t_newpixel16
                        ADRHI   R1,t_newpixel32
                        LDMLSIA R1,{R1,R2}
                        LDMHIIA R1,{R1-R3}
                        SetImm  R1,vv_inbpp1,CC
                        SetLsr  R2,vv_inbpp,CC
52
                        STMLSIA   R10!,{R1,R2}
                        STMHIIA   R10!,{R1-R3}
02
                        Debug   cn,"Branch to l_newword"
                        Branch  BLEQ,l_newword

                        TST     R11,#mc_plotmask
                        BEQ     %FT47
;
                        Debug   cn,"newpixel2"
                        CMP     vv_outbpp,#16
                        GetAsm  m_newpixel2,LT
                        SetImm  R2,vv_outbpptop,LT
                        PutAsm  m_newpixel2,LT
                        Asm     m_newpixel2_ext,GE
47
;
                        TST     R11,#mc_ttr                             ; is there a translation table?
                        BNE     %FT53

        ;if we are doing 16->32 or 32->16 there is no translation table - instead
        ;a specific munger is used to bit shuffle the word.

                        CMP     vv_inbpp,vv_outbpp
                        BEQ     %FT54
                        CMP     vv_outbpp,#16
                        BCC     %FT54

                        CMP     vv_inbpp,#16
                        BCC     %FT54

        ;if EQ we are doing 16->32 otherwise it is 32->16

                        Asm     t_newpx_16to321,EQ
                        Asm     t_newpx_16to322,EQ
                        Asm     t_newpx_16to323,EQ
                        Asm     t_newpx_32to161,NE
                        Asm     t_newpx_32to162,NE
54
                        MOV   PC,LR
53
        ;if we are going from 16/32 to 8/less bpp we translate via a
        ;32K table, so check for these cases....

                        CMP     vv_outbpp,#16
                        BCS     %FT56
                        CMP     vv_inbpp,#16
                        BCC     %FT56

        ;if EQ it is input=16, else NE means 32 as input

                        Asm     t_makeindex321,NE
                        Asm     t_makeindex322,NE

                        Asm     t_makeindex16 ;always include it, to chop any high
                                              ;bits off

                        GetAsm  t_use32Ktable
                        SetLsr  R5,vv_outbpp
                        PutAsm  t_use32Ktable

                        MOV     PC,LR
56
                        [ ignore_ttr
                        ;if doing <16 to >8 then use the palette instead
                        CMP     vv_inbpp,#16
                        BCS     %FT57
                        CMP     vv_outbpp,#16
                        BCC     %FT57
                        TST     R11,#mc_ttrispalette
                        BEQ     %FT57

                        GetAsm  t_newpixel3
                        PutAsm  t_newpixel3

                        CMP     vv_outbpp,#32
                        Asm     t_newpx_32to161,NE
                        Asm     t_newpx_32to162,NE

                        B       %FT03
57
                        ]
                        CMP     vv_outbpp,#16                           ; decide which translation function

                        GetAsm t_newpixel2,LT                          ; getting the one required
                        GetAsm t_newpixel216,EQ
                        Asm    t_newpixel232,GT
                        SetLsr R2,vv_outbpp,LE
                        PutAsm t_newpixel2,LT
                        PutAsm t_newpixel216,EQ
03
                        MOV     PC,LR

                        [ debugcn
10
                        Debug  cg,"t_newpixel2"
                        B      %BT11
                        ]

pmt_tryoutput           SUBS    xcount,xcount,xdiv

ptm_tryoutput           ORR     outmask,im2,outmask,LSR #xxx    ; outbpp
pt_tryoutput            MOV     outmask,outmask,LSR #xxx        ; outbpp

ptm32_tryoutput         MOV     outmask,im2
pt32_tryoutput          MOV     outmask,#0

pmt_tryout2             ORRS    outword,in2,outword,LSR #xxx    ; outbpp
                        MOV     R14,R14         ; branch
pmt_tryout2end          SUBS    xsize,xsize,#1

pmt_tryout32            MOVS    outword,in2     ; nothing to mask through
                        MOV     R14,R14         ; branch
pmt_tryout32end         SUBS     xsize,xsize,#1

pmt_tryoutput4          LDR     PC,stack_returnaddr

asm_tryoutput
                        Label   l_tryoutput
                        Debug   co,"*** asm_tryoutput" ;
                        Debug   co,"pmt_tryoutput (1 word)"
                        LDR     R1,pmt_tryoutput
                        STR     R1,[R10],#4
                        Debug   co,"branch to l_newpixel"
                        Branch  BCC,l_newpixel
;
                        TST     R11,#mc_plotmask
                        BNE     %FT01
;
                        Debug   co,"ptm/pt_tryoutput (1 word)"

                        CMP     vv_outbpp,#32
                        BLT     %FT10
                        ;new code to make 32 bit go
                        TST     R11,#mc_hasmask
                        LDRNE   R1,ptm32_tryoutput
                        LDREQ   R1,pt32_tryoutput
                        B       %FT11
10
                        TST     R11,#mc_hasmask
                        LDRNE   R1,ptm_tryoutput
                        LDREQ   R1,pt_tryoutput
                        SetLsr  R1,vv_outbpp
11
                        STR     R1,[R10],#4
01
                        Debug   co,"Skipping a word"
                        ADD     R0,R10,#4
                        STR     R0,[sp,#l_fref]         ; forward reference filled in later
                        Debug   co,"tryout2"
                        CMP     vv_outbpp,#32
                        GetAsm  pmt_tryout2,NE
                        GetAsm  pmt_tryout32,EQ
                        SetLsr  R1,vv_outbpp,NE
                        PutAsm  pmt_tryout2,NE
                        PutAsm  pmt_tryout32,EQ
                        Debug   co,"branch l_tryoutput"
                        Branch  BGT,l_tryoutput
                        Debug   co,"pmt_tryoutput4 (1 word)"
                        LDR     R1,pmt_tryoutput4
                        STR     R1,[R10],#4
;
                        MOV     PC,LR

pmt_putmany             MOV     vcount,R14
pmt_putmanyend          MOV     xdiv,outptr

m_putmany               LDMDB   ecfptr!,{ecfora,ecfeor}
m_ecflimit              CMP     ecfptr,#xxx                     ; ecflimit
                        ADDLS   ecfptr,ecfptr,#64
                        AND     ecfora,ecfora,outword
m_putmanyend            AND     ecfeor,ecfeor,outword

pmt_putmany22           STR     R14,[outptr]                    ;   "
                        LDR     R14,stack_outoffset             ;   "
                        SUB     outptr, outptr, R14             ;   "
pmt_putmany22end        SUBS    vcount,vcount,#1                ;   "
m_putmany2              LDR     ecfptr,stack_ecfptr
m_putmany2end           *       m_putmany2

pmt_putmany3            ADD     outptr,xdiv,#4
                        LDR     xdiv,stack_xdiv
pmt_putmany3end         LDR     xadd,stack_xadd
                        ASSERT  vcount = xadd

asm_putmany
                        Label   l_putmany
                        Debug   cp,"*** asm_putmany"
                        Debug   cp,"pmt_putmany"
                        Asm     pmt_putmany
                        Debug   cp,"Label l_vloop"
                        Label   l_vloop
;
                        TST     R11,#mc_plotmask
                        MOVEQ   R0,#0
                        ADDNE   R0,R10,#4
                        [ multibuffer
                        STMFD   R13!,{R1,R14}
                        LDR     R14,thisslot
                        ADR     R1,pc_ecflimit0
                        STR     R0,[R1,R14]
                        LDMFD   R13!,{R1,R14}
                        |
                        STR     R0,pc_ecflimit                  ; remember for later
                        ]
                        Debug   cp,"m_putmany (NE)"
                        Asm     m_putmany,NE
;
                        Push    "LR"
                        Debug   cp,"asm_gcolaction"
                        BL      asm_gcolaction                  ; depends on GCOL action
                        [ multibuffer
                        STMFD   R13!,{R1,R14}
                        LDR     R14,thisslot
                        ADR     R1,pc_outoffset0
                        STR     R10,[R1,R14]
                        LDMFD   R13!,{R1,R14}
                        |
                        STR     R10,pc_outoffset                ; remember for later
                        ]

                        ; new version to get over implicit limit in old code
                        Asm     pmt_putmany22                   ; Merged from 0.62 (GPS)

                        Debug   cp,"branch on NE to l_vloop+4"
                        Branch  BNE,l_vloop+4                   ; allow for R14 on stack

;
                        TST     R11,#mc_plotmask
                        Debug   cp,"m_putmany2 (NE)"
                        Asm     m_putmany2,NE
;
                        Debug   cp,"pmt_putmany3"
                        Asm     pmt_putmany3
                        Debug   cp,"asm_nextword"
                        BL      asm_nextword
                        Pull    "PC"

pt_gcolprelude1         MVN     outword,outmask         ; Invert
pt_gcolprelude2         MVN     outword,outword         ; AND-NOT, ORR-NOT
pt_gcolprelude3         ORR     outword,outword,outmask

pt_putword              BIC     outword,outword,outmask
pt_putwordend           *       pt_putword

pmt_putword             LDR     R14,stack_vcount
pmt_putwordend          CMP     R14,#1

m_putword               LDMDB   ecfptr,{ecfora,ecfeor}
                        AND     ecfora,ecfora,outword
m_putwordend            AND     ecfeor,ecfeor,outword

pmt_putword2            STR     R14,[outptr],#4
pmt_putword2end         *       pmt_putword2

asm_putword
                        Debug   mc,"Putword is at",R10
                        Debug   cg,"Putword is at",R10
                        [ multibuffer
                        STMFD   R13!,{R1,R14}
                        ADR     R1,calladdr20
                        LDR     R14,thisslot
                        STR     R10,[R1,R14]
                        LDMFD   R13!,{R1,R14}
                        |
                        STR     R10,save_calladdr2
                        ]
                        Label   l_putword
                        TST     R11,#mc_plotmask
                        BNE     %FT01
                        AND     R0,R11,#mc_gcol
                        CMP     R0,#4
                        LDREQ   R1,pt_gcolprelude1              ; Invert
                        LDRGT   R1,pt_gcolprelude2              ; AND-NOT, ORR-NOT
                        STRGE   R1,[R10],#4
                        CMP     R0, #2
                        LDREQ   R1,pt_gcolprelude3              ; AND - bug fix
                        STREQ   R1,[R10],#4
                        CMPNE   R0, #6
                        Asm     pt_putword,NE
01
                        Asm     pmt_putword
                        Branch  BGT,l_putmany
;
                        TST     R11,#mc_plotmask
                        Asm     m_putword,NE
;
                        Push    "LR"
                        BL      asm_gcolaction                  ; depends on GCOL action
                        Asm     pmt_putword2
                        BL      asm_nextword
                        Pull    "PC"

pmt_nextword            MOV     outword,#&80000000
                        MOV     outmask,#0
pmt_nextwordend         SUBS    xsize,xsize,#1

pmt_nextword2           LDR     PC,stack_returnaddr
pmt_nextword2end        *     pmt_nextword2

asm_nextword            Asm     pmt_nextword
                        Branch  BGT,l_tryoutput+4               ; allow for R14 on stack
                        Asm     pmt_nextword2
                        MOV     PC,LR

pmt_gcol                LDR     R14,[outptr]

pt_gcolactions          AND     R14,R14,outmask         ; Store actually uses 2 instrs
                        ORR     R14,R14,outword
                        AND     R14,R14,outword
                        EOR     R14,R14,outword
                        EOR     R14,R14,outword         ; MVN outword,outmask
                        MOVNV   R14,R14
                        AND     R14,R14,outword         ; MVN outword,outword
                        ORR     R14,R14,outword         ; MVN outword,outword

m_gcolaction            ORR     R14,R14,ecfora
                        EOR     R14,R14,ecfeor

asm_gcolaction
                        LDR     R1,pmt_gcol
                        ADR     R2,pt_gcolactions
                        EOR     R0,R11,#mc_plotmask
                        TST     R0,#mc_plotmask
                        ADREQ   R2,m_gcolaction
                        ANDNES  R0,R11,#mc_gcol
                        LDMEQIA R2,{R2,R3}                      ; 2 instructions for STORE/mask
                        LDRNE   R2,[R2,R0,LSL #2]               ; 1 instruction for others
                        STMEQIA R10!,{R1-R3}
                        STMNEIA R10!,{R1-R2}
                        MOV     PC,LR

      ]

a3829 22
      [ debugcg
ag_disasm
      ;disassemble R1 to R[R9]
      ;base for R1=R10
      EntryS "R0-R12"
      dreg R10,"At: " ;location
      dreg R9,"#words = "
      SUB R9,R9,#1
01    STMFD R13!,{R1-R8}
      LDMFD R13!,{R0-R7} ;move everything down one reg
      STMFD R13!,{R0-R3} ;save registers the SWI will change
      MOV R1,R10         ;get the location into place

      SWI Debugger_Disassemble
      dstring R1,"" ;disassembly
      ADD R10,R10,#4
      LDMFD R13!,{R0-R3}
      SUBS R9,R9,#1
      BPL %BT01
      EXITS              ;ensure we return flags how they started....
      ]

@


4.13
log
@Clean up pass.
Trim 200+ lines of changes dating back to 1987, combine with non duplicates in the 'BlackLog'.
Use 'offsetof' macro in genjhdr to avoid warnings about uninitialised variables, rename from makejhdr so all the utils are clearly demarked.
Add throwback to MkCFSI-j.
Replace reason codes passed to SWIs with textual equivalents from the respective header files.
Speed up SWI despatch a bit by making the first few debug instructions depend on 'debuggs'.
Qualify all of the debug switches with the global 'debug' one.
Eliminate single use of 'pullx' macro.
Make do_branch() take an unsigned opcode so 50% of the branches don't result in implied cast warnings.
Added an UNUSED() macro to reduce a few of the legitimate warnings (the remainder are either in the original JPEG code or ones that it is worth checking the logic of.
Unixify one last filename.

Version 1.24. Tagged as 'SprExtend-1_24'
@
text
@d1717 7
d1731 1
d2368 1
a2368 1
        ANDS    R7, R14, #48            ; If we're dealing with deep sprites then the kernel is slower!!!
@


4.12
log
@A few small fixes.
Sources/PutScaled:
 Sync comment with C code.
Sources/SprExtend:
 Debug switch 'debuggs' had been left on, which left in some unnecessary code, but turning it off pulled in code with a stack imbalance. Now off.
 Ensured a terminator at the end of the RMEnsure.
 Colour translation tables passed to SetPointerShape that were in top bit set addresses were being interpreted as though no tt was supplied. Now tested against zero to match docs.
Sources/SprTrans:
 Switches pre 0.60 collapsed.
Sources/diffuse:
 The C code was corrupting r12 workspace pointer so the check of the flag 'ctrans_recent' sometimes failed leading to a duff table lookup.
 Small optimisation to checking of guard word.
c/PutScaled:
 Change paths to be Unix friendly.
rojpeg:
 Put assembler_panic in the header file to shut the compiler up.
3x unused files deleted.

Version 1.23. Tagged as 'SprExtend-1_23'
@
text
@a16 223
;;----------------------------------------------------------------------------
;; Sprite Extension Module
;;
;; *********************
;; ***  CHANGE LIST  ***
;; *********************
;;
;;  2-Jul-87    0.01    Implement enlarged sprites
;; 16-Sep-87    0.02    Implement scaled (up & down) sprites
;; 17-Sep-87            Optimise for large y-scaling
;; 24-Sep-87            Implement PostScript VDU 5 text
;; 29-Sep-87            Implement scaled mask plotting

;; 29-Sep-87            Implement scaled char painting
;;  7-Oct-87    0.03    Changed so that SpriteV is intercepted
;;  7-Oct-87            Grey-scale sprite scaling & pixel translation
;;  8-Oct-87            Change SpriteOp reason codes & parameters
;; 12-Oct-87            Generalise PutSpriteScaled (use colour translation)
;; 21-Oct-87    0.04    Make it work on Arthur 0.3
;; 29-Oct-87            Change name to 'SpriteExtension'
;; 29-Oct-87            Ensure that R3=0 on entry to SwitchOutputToSprite/Mask
;; 29-Oct-87            Implement mask plotting for unmasked sprites
;;  6-Nov-87            Implement SpriteReason_MergeSprites
;; 12-Nov-87            Changed name to SpriteReason_AppendSprite
;; 25-Jan-88            Put in 'division by zero' check on scale factors
;; 25-Jan-88            Fix bug in ttr code (bpp used instead of inbpp)
;; 28-Jan-88            PlotMaskScaled with different bpp does block instead (used to give an error - Bad Translation Table)
;;  1-Feb-88            Implement SpriteReason_SetPointerShape
;;  8-Mar-88    0.05    Remove OS version number bodgeing
;;  8-Mar-88            Fix bug: PaintCharScaled in 1-bpp modes
;;  8-Mar-88            Remove SwitchOutputToSprite/Mask (leave up to MOS)
;; 16-Mar-88            Allow scale factors and pixtrans in SetPointerShape
;; 24-Mar-88    0.06    Claim vectors on Service_Reset
;; 29-Mar-88    0.10    Change plot code so it is compiled into RAM
;;  3-Apr-88            Fix bug: double-pixel input sprite wasn't coped with
;;  7-Apr-88            Change Arthur 1.20 version so it doesn't use SWI table
;; 10-Apr-88    0.11    Fix bug: big reason codes are now passed on unchanged
;; 14-Apr-88            Change default scaling so 1st pixel is included
;; 15-Apr-88            Change it back again!
;; 24-Jun-88    0.12    Implement OS_ChangedBox stuff
;; 25-Jul-88    0.13    Fix bug: changedbox used x,ycount instead of x,ysize
;; 29-Jul-88    0.14    Change SetPointerShape to use 3 more bits in R3
;; 29-Jul-88    0.15    Fix bug: allow 12-character sprite names
;;  2-Aug-88    0.16    Fix bug: ChangedBox stuff got it wrong when clipping
;;  9-Aug-88    0.17    Fix bug: SetPointerShape should move sprite to right
;; 15-Aug-88    0.18    Fix bug: SetPointerShape corrupts [spritecode]
;; 19-Aug-88            SetPointerShape defaults ttr to 0,1,3,3 in hi-res mono
;; 19-Aug-88    0.19    SetPointerShape uses 1/2 ptr width in hi-res mono
;;  2-Sep-88    0.20    Change code to save 8 words in jump table
;; 20-Oct-88            Change to use new Make procedure
;; 31-Mar-89    0.21    Only call *FX &87 when mode number is needed
;; 23-May-89    0.22    Deal with system sprites by calling OS_ReadDynamicArea
;; 19-Sep-89    0.23    Fix bug: GCOL 2/6 in scaled sprites plotted too much
;; 29-Sep-89            Released new version to net - PutSpriteTransformed and PlotMaskTransformed working
;; 29-Sep-89    0.24    Rewrite PaintCharScaled to define a mode 0 sprite and then transform that
;; 28-Nov-89    0.25    Add SpriteReason_InsertDeleteRows and SpriteReason_InsertDeleteColumns
;; 18-Dec-89    0.26    Fixed inserting zero words in InsertDelete stuff. Used to set it all to zero
;; 05-Jan-90    0.27    Fixed two bugs in InsertDelete columns, due to LH and RH wastage
;; 12-Jan-90    0.28    And another...
;; 30-Jan-91    0.29    Add SpriteReason_CreateRemovePalette
;; 05-Feb-91    0.30    Extended above call to return palette pointer + mode
;; 13-Mar-91    0.31    Internationalisation; NB: "Sprite doesn't exist" is cached
;; 10-May-91    0.34    Fixed Service_Reset code
;; 14-Aug-91    0.35    Fix bug: Transforming transparent sprites work again
;; 14-Aug-91            Optimised for 1:1 mapping in BPP for transformed sprite masks
;; 14-Aug-91    0.36    Fix bug: Insert/delete columns works when rapping off a word boundary
;; 02-Sep-91    0.37    Fix bug: Insert columns doesn't barf when there's exactly enough room
;; 13-Sep-91            Fix bug: revist insert columns and apply crow bar where appropriate (used to scramble sprite quite often)
;; 10-Dec-91    0.38    Removed comments from Messages file and shortened tokens
;; 06-Feb-92    0.39    Fixed calculation of amount of memory to move in CreateRemovePalette
;; 17-Feb-92    0.39    ECN: Bug fix: Rotate sprite incorrectly calculated the amount to move the sprite pool to make room for the larger sprite
;; 20-Feb-92    0.40    ECN: Bug fix: Fixed out of memory error inserting 0 rows/columns
;; 18-Mar-92    0.41    ECN: Bug fix: Fixed insert columns
;; 18-Mar-92    0.42    ECN: Removed debugging OS_Confirm call
;; 30-Mar-92    0.43    ECN: Fixed insert column bug (another one)
;;                           Fixed garbage fill when inserting rows
;; 02-Apr-92    0.44    ECN: RP-2050: Deleting 1 column in a single column mode 0 sprite lead to a 32 bit wide sprite
;;                           "Sprite not found" error now cached on Service_ResourceFSStarted instead of Service_MessageFileClosed
;; 23-Apr-92    0.45    ECN: RP-2503: Fix boundary condition when inserting rows. Previously the test for space in sprite area did BGE
;;                           error, EQ is OK, changed to BGT
;; 23-Apr-92    0.46    TMD: RP-2540: Corrected start and end addresses of block to copy in CreateRemovePalette
;;
;; ---------------------- RISC OS 3.10 releae module -----------------
;;
;; 24-Jul-92            Removed the conditional code - made it more readable
;; 24-Jul-92            Bodge OS code removed - can no longer build Sprite Extend for Arthur - shame
;; 24-Jul-92            Seperated off Insert/Delete Rows/Columns into seperate file
;;  3-Aug-92            Support for rendering into higher depth modes implemented
;;  3-Aug-92            Incorporated Tims wacky bit reordering function
;;  5-Aug-92            Handling of masked sprites tidied to work with greater depths
;;  5-Aug-92            Modified pixel translation code, now works for all depths upto 32 bit per pixel
;; 11-Aug-92            PutSpriteScaled now faults sprites of depth > 8 bit per pixel
;; 17-Aug-92            Generalised copying and other functions for translation tables
;; 18-Aug-92            Transformed sprites into 16 or 32 bit per pixel now working (must test 32 bit per pixel)
;; 18-Aug-92            PutSpriteTransformed now errors if input depth > 8 bit per pixel
;; 28-Aug-92            PutSpriteScaled now copes with sprite containing new header (needs new kernel)
;;  7-Sep-92            Support for VIDC 20 added (conditional between two boards)
;; 11-Sep-92            Implemented a crude bit munging function to generate 32 bit per pixel sprites
;; 03-Mar-93            AMG: Added multiple buffer code
;;    Mar-93            AMG: Make SpriteScaled cope with input from/output to 16/32bpp
;;    Apr-93            AMG: Make SpriteTransformed cope with input from/output to 16/32bpp
;;    Apr-93            AMG: Optimise the but mungeing functions from 11-Sep-92
;;    Apr-93            AMG: When plotting a 8bpp or lower sprite with a full palette to
;;                           16bpp or above, ignore the translation table and use the
;;                           palette entries directly. NB will NOT work for braindamaged
;;                           8bpp 16 or 64 entry palettes. Flag 'ignore_ttr' controls this.
;; 04-Apr-93    0.48    AMG: New version number for return to source filer
;; 06-Apr-93                 Bug fix on sprext plotting via 32K tables
;;                           Bug fix on plotting 32bpp sprites to 8bpp
;; 11-May-93    0.49    AMG: Bounce mask/palette operations on 16 & 32bpp new format sprites
;; 21-May-93    0.50    AMG: Fix bug in PutSpriteTransformed (causing an extra plot of first
;;                           pixel on each row of sprite)
;; 23-Jun-93    0.51    AMG: Introduce 1bpp masks on sprites (only for putspritescaled &
;;                           transformed - NOT greyscaled)
;; 14-Jul-93    0.52    AMG: Wrap up mask work and fix bugs.
;; 03-Aug-93    0.52W   WRS: ccompiler flag - new PutSpriteScaled compiler started.
;;                           debug true, file true, hostvdu false.
;; 09-Aug-93    0.53    AMG: Fix bug in PutSprite/MaskScaled for sprites with LH obscured
;;                           (merged in by WRS - doesn't actually affect things,
;;                            cos it's in the compiler we're replacing)
;; 25-Aug-93    0.53W   WRS: ccompiler work continues - old compiler disabled,
;;                           PutSpriteGreyScaled disabled (noone uses it).
;; 14-Sep-93    0.54W   WRS: jpeg decompression started.
;; 14-Oct-93    0.55W   WRS: printer calibration stuff entered (not tried yet, no printer driver around)
;; 09-Nov-93            WRS: patch OS_ReadModeVariable to recognise type-9 new sprites as JPEG.
;; 21-Feb-94            WRS: added sprite reason codes JPEGInfo and PutJPEGScaled.
;; 20-Jun-94            GPS: Ported AMG changes between 0.53 and 0.62 to this version.
;;                           Added correct flags so compiles with + without C code added.
;; 28-Jul-94            AMG: Fix bug MED-03238. PlotTransformed went wrong plotting a 1bpp
;;                           mask if LH edge obscured or excluded using a source rectangle.
;;
;; 12-Aug-94    0.63    GPS: WRS new plotsclaed engine stabilised and new JPEG swis implemented.
;; 12-Aug-94    0.64    GPS: Chnaged c.rojpeg so CFSI-jpeg builds correctly.
;; 30-Aug-94    0.68    GPS: Removed bug in plotmaskscaled which was apparent when using dragasprite.
;;                           Bug was due to obscure use of ECF patterns. Why?
;;                           Implemented 3 more SWIs. JPEG_PDriverIntercept, and skeletons for
;;                           JPEG_PlotTransformed and JPEG_PlotFileTransformed.
;; 01-Sep-94    0.69    GPS: Implemented dithering switch on JPEG SWIs
;; 13-Sep-94    0.70    GPS: Implemented JPEG_PlotTransformed SWI
;;                           added switch to PutSpriteScaled to allow dithering of 16bpp+ sprites
;;                           fixed bug where word aligned JPEGS were not printed with the correct width.
;; 19-Sep-94    0.71    GPS: Added extra bit to JPEG_PDriverIntercept SWI so trnaslation table is always
;;                           used when printing.
;;                           Fixed bug where plotting sprites with 1bpp masks into 16bpp mode sometimes
;;                           corrupted with non-aligned data.
;; 22-Sep-94    0.72    GPS: Changed behaviour of Plotscaled when a NULL scale factors pointer passed.
;;                           Fixed bug in JPEG_PlotTransformed when co-ordinate was -ve.
;;                           Added Error handling for C plotscaled engine.
;; 26-Sep-94    0.73    GPS: Fixed bug where JPEG_PlotScaled junked r0
;;                           Implemented JPEG_PlotFileTrnasformed.
;;                           Corrected scaling in JPEG_PlotTransformed
;; 29-Sep-94    0.74    GPS: Impletmented Sprite_Reason CheckSpriteArea
;;                           Added extra return parameter to JPEG_Info SWIs. They now
;;                           return the memory required in R6.
;; 07-Oct-94    0.75    GPS: Fixed bug when plotting sprites with 1bpp masks, not word aligned.
;;                           Made SpriteExtend plot from palette when R5:b4 is set.
;; 20-Oct-94    0.76    GPS: Added speed-ups to plotscaled code, when plotting at large scales
;;                           because it went much slower than version 0.62!!
;; 25-Oct-94    0.77    GPS: Made operation of 'dither' flag consistent when error-diffusing JPEGS
;;                           Added an error when Sprite 'PutSpriteGreyScaled' is called
;; 31-Oct-94    0.78-0.79    Build changes.
;;
;; 01-Nov-94    0.80    GPS: Fixed bug in SpriteOp 35 (Append Sprite) where r0 was being junked
;;                           when returning an error.
;; 11-Nov-94    0.81    GPS: Stopped JPEG_FileInfo from grabbing a 1k buffer and not returning it...
;;                           Stopped error when trying to plot a JPEG without a translation table
;;                           which means that it works on pre RO3.5 machines.
;; 15-Nov-94    0.82    GPS: Fixed Bug where PlotMaskScaled was only allowing for 8 bits of bg colour
;;                           Fixed Bug where plotting with 'action' AND was masking out all other
;;                           pixels in a word.
;; 21-Nov-94    0.83    GPS: Fixed bug in OS_SpriteOp CheckSpriteArea where it was being slightly too
;;                           pessimistic. In c.SpriteOp
;;                           Added compiler flags to c.rojpeg so that CFSIjpeg compiles correctly.
;; 24-Nov-94    0.84    GPS: Fixed bug where JPEG_PlotTransformed didn't forbid -ve scale factors. in Sources.SWIs
;;                           Made SpriteExtend use a dynamic area to hold the JPEG workspace. in Sources.SprExtend,
;;                           Sources.SWIs, c.rojpeg and c.PutScaled
;;                           Internationalised name of Dynamic Area. In Sources.CSupport and c.PutScaled.
;; 28-Nov-94    0.85    GPS: Moved create_dynamic_area function from Sources.CSupport to Sources.PutScaled.
;;                           Fixed bug in SpriteOp PaintCharScaled, where both the colour used for the plot
;;                           and the plotting action were being junked. In Sources.SprExtend and c.PutScaled
;; 01-Dec-94    0.86    GPS: Fixed small semantic bugs in OS_SpriteOp CheckSpriteArea. In c.SpriteOp
;;                           Stopped OS_SpriteOp CheckSpriteArea junking r12. In Sources.SWIs
;; 02-Dec-94    0.87    GPS: Fixed bug MED-04026. Where plotting Old Format 1bpp Sprites with a mask was failing. In c.PutScaled
;; 07-Dec-94    0.88    GPS: Fixed bug in c.Putscaled, when using a non-zero plot action. The optimised code for scale factors >4
;;                           doesn't work, so the code now reverts to the non-optimised code in this case. This fixes
;;                           MED-03952 and MED-03968.
;; 16-Dec-94    0.89    GPS: Changed functionality of OS_SpriteOp CheckSpriteArea so that a sprite's mask has to be either 1bpp
;;                           for new sprites or the same size as the sprite image.
;;                           Fixed bug introduced into version 0.88 for plotting at 5:1+ scale without a mask. Ooops.
;; 01-Feb-95    0.90    GPS: Added extra bit to JPEG_Plot(File)Scaled SWIs to allow error-diffused dithering
;;                           Made JPEG SWIs error when invalid flag bits are set.
;; 09-Feb-95    0.91    GPS: Fixed MED-04481 where all plot actions except 'Set' were failing for scaling > 1:1 in 16M colour modes
;;                           Fixed MED-04508 where an invalid spritearea pointer was causing a crash even when it was not required
;;                           in the spriteOp.
;;                           Made JPEG_PlotFileScaled successfully return when invalid flag bits set.
;; 13-Feb-95    0.92    GPS: Fixed MED-04131 where JPEG files with pixel sizes of ratio 0:0 were causing a divide by zero error
;;                           a 0:0 ratio is now returned as 1:1
;; 15-Feb-95    0.93    GPS: Fixed MED-04158 where the PutScaled blitter was running out of registers when you plotted a new format
;;                           sprite <=8bpp, with a mask into a 16bpp mode plotting directly from the palette (phew!). SpriteExtend
;;                           now converts the palette to 16bpp and sticks it in the space resevered for the creation of a translation
;;                           table. This avoids the need for conversion on the fly which requires 2 temporary registers.
;; 24-Feb-95    0.94    GPS: Made error diffusion work with an arbitary palette held in 'newtranstable' a pointerto which is stacked
;;                           before entering the diffusion code. Investigated which palettes were unsuitable for error-diffusion
;;                           and came to the conclusion that the error-diffused result was always superior to the ordered-dither.
;;                           Fixes bug MED-04727.
;; 24-Feb-95    0.95    GPS: Checked Sources.SprAdjSize onto SrcFiler which was changed in December but overlooked (oops!).
;;                           Fixes MED-04141, MED-03966 and  MED-03967
;; 27-Feb-95    0.96    GPS: Fixed bug where optimised code for scales >4:1 failed with obscure values eg 575:115 which draw supplied!
;;                           This is fixed by trying to rationalise the scale factors near the beginning of a sprite plot.
;; 28-Feb-95    0.97    GPS: Fixed bug when outputting to 32bpp mode with large output scales.
;;                           removed warnings and error from CFSIjpeg compilation. Fixes MED-04643
;; 17-Mar-95    0.98    GPS: Fixed bug MED-05018. r_xcount was not being initialised with 16bop source and dither bit set.
;; 29-Mar-95    0.99    GPS: Fixed bug MED-05084. Redone the plotmask code to use the ECF AND & EOR mask in the kernel. This
;;                           has to be done because when doing a PaintCharScaled of a delete char. the kernel sneakily replaces
;;                           the foreground colour with the background one to make it work.
;;
;; ---------------------- RISC OS 3.60 release module -----------------
;;
;; 15-Jun-95    1.00    GPS: Made JPEG Error diffusion work with <8bpp output. When outputting to greyscale modes, only take
;;                           luminance of the JPEG.
;;
;;----------------------------------------------------------------------------

d18 1
a18 1
StrongARM SETL {TRUE}
d27 2
d34 1
a34 1
        GET     Hdr:PublicWS     ; only if bodgeOS is false
d41 1
a50 20
; OSS Macro for Sprite internationalised error blocks. This is because all
; the names start with "Sprite_". This adds no useful information to the
; string, and just makes the module and the Messages file bigger

        MACRO
$label  MakeSpriteErrorBlock $name, $noalign, $tag
        ALIGN
$label
ErrorBlock_$name
        DCD     ErrorNumber_Sprite_$name
    [   "$tag" = ""
        DCB     "$name"
    |
        DCB     "$tag"
    ]
        DCB     0
    [   "$noalign" = ""
        ALIGN
    ]
        MEND
d79 5
a83 2
 [ :LNOT: :DEF: localmessages
                GBLL    localmessages
d85 2
a86 1
 ]
d92 1
d137 25
a161 45
debug   SETL    {FALSE} 
debugmc SETL    {FALSE}                 ; macro compilation
debugpt SETL    {TRUE}                  ; pointer
debugmg SETL    {FALSE}                 ; 'merge sprites' code
debugid SETL    {TRUE}                  ; insertdelete rows or columns
debugin SETL    {TRUE}                  ; input parameters
debuglp SETL    {FALSE}                 ; loop
debugsc SETL    {FALSE}                 ; screen parameters
debugsp SETL    {TRUE}                  ; sprite parameters
debugch SETL    {FALSE}                 ; character painting
debugtr SETL    {FALSE}                 ; transformed plotting
debuger SETL    {FALSE}                 ; error trapping
debugxx SETL    {FALSE}                 ; misc debugging
debugcg SETL    {FALSE}                 ; code generator
debugcp SETL    {FALSE}                 ; code generator - asm_putmany
debugco SETL    {FALSE}                 ; code generator - asm_tryoutput
debugcn SETL    {FALSE}                 ; code generator - asm_newpixel
debugcs SETL    {FALSE}                 ; code generator - asm_start
debugcw SETL    {FALSE}                 ; code generator - asm_newword
debugcu SETL    {FALSE}                 ; code generator - asm_putword
debugmb SETL    {FALSE}                 ; multibuffer code for code generator
debugms SETL    {FALSE}                 ; minimal multibuffer info messages
debugag SETL    {TRUE}                  ; amg transient debugging - could be anywhere :-)
debuggs SETL    {FALSE}                 ; JPEG SWI debugging.
debugcc SETL    {TRUE}                  ; PutSpriteScaled compiler in C

hostvdu SETL    {TRUE}
file    SETL    {FALSE}

        [ multibuffer
nbuffers * 8                            ; number of code buffers to use
        ]

        ; Enable use of cc -cpu 6 with an old version of objasm
        ; If your objasm understands v6 opcodes, it will ignore these macros
        ; Note the 3rd parameter is not implemented yet (not currently needed)
        MACRO
$lab    SXTH    $rd,$rm
$lab    DCI     &E6BF0070 :OR: ($rd :SHL: 12) :OR: $rm
        MEND

        MACRO
$lab    UXTH    $rd,$rm
$lab    DCI     &E6FF0070 :OR: ($rd :SHL: 12) :OR: $rm
        MEND
a198 2


d203 33
a260 7
        MACRO
$label  pullx     $reglist,$cc,$hat
$label  LDM$cc.FD R13,{$reglist}$hat
        MEND



a280 2


a357 2


d509 1
a509 1
        MOVNE   R0,#7                      ; reason code
d716 2
a726 1
                                 ; currently intercepting the JPEG plots.
d1116 1
a1116 1
        MOV     r1, #9                  ; r1  = index for log2bpp
d1486 1
a1486 1
        MOV     R0,#&15
d1596 1
a1596 1
        MOV     R0,#&0A                 ; read character definition
d5020 1
a5020 1
        pullx   "R1-R3"
d5758 1
a5758 1
      SWI &40380
@


4.11
log
@Collapse old switches.
Removed braces selecting code from 0.47 0.50 and 0.55, this is over 80
versions ago and just confusing.
Binary the same, not tagged.
@
text
@d315 1
a315 1
        GBLL    debugcc                 ; new PutSpriteScaled compiler.
d395 1
a395 1
debuggs SETL    {TRUE}                  ; JPEG SWI debugging.
d709 1
a709 1
        DCB     "RMEnsure ColourTrans 1.25 Error 1"
a1673 3
        TST     R14,#Flag_HiResMono     ; N unset by this
        CMPNE   R7,#1                   ; sets N iff R7<=0 and in hi-res mono
        ADRMI   R7,hiresmonottr
d1675 5
d1749 3
a1751 3
        CMP     R7,#0
        MOVLE   R4,R3                   ; use 1:1 translation if no table
        BLE     %FT03                   ; got colour
d2217 1
a2217 1
        Pull    "R1-R7,PC"
d5971 1
a5971 4
        GET     Sources.PutScaled   ; needs comementing out if not using JPEG stuff.
      [ jpeg
;        GET     Sources.JPEG
      ]
@


4.10
log
@  Build fix
Detail:
  Defines UXTH and SXTH as macros. This means we can assemble the output of
  cc -S -cpu 6 even using current versions of objasm that are limited to the
  v5TEJ instruction set. It is expected that objasm will ignore these macros
  if/when it gains v6 instruction set support.
Admin:
  Tested - it works.
@
text
@a828 1
                [ Module_Version >= 047
a829 1
                ]
a876 1
              [ Module_Version >= 047
a877 1
              ]
a3020 2
      [ Module_Version >=047
;
a3027 3
      |
        Push    "R0-R11"                 ; R7 = space for stack_returnaddr
      ]
a3276 2
    [ Module_Version >= 047

a3454 1
    ]
a4007 17
        [ Module_Version >= 055
        ; no longer needed here - outoffset is pulled from the stack
        |
        ADR     R14,pc_outoffset0
        LDR     R11,thisslot
        LDR     R11,[R14,R11]

        LDR     R0,save_outoffset
        Debug   mb,"Save offset = ",R0

        LDR     R14,pmt_outoffset
        Debug   mb,"pmt_outoffset = ",R14
        SetImm  R14,R0                  ; don't convert_ROR it!!!
        Debug   mb,"Modified instruction = ",R14
        Debug   mb,"pc_outoffset for this routine ",R11
        STR     R14,[R11]
        ]
a4016 9
        [ Module_Version >= 055
        ; no longer needed here - outoffset is pulled from the stack
        |
        LDR     R11,pc_outoffset
        LDR     R0,save_outoffset
        LDR     R14,pmt_outoffset
        SetImm  R14,R0                  ; don't convert_ROR it!!!
        STR     R14,[R11]
        ]
a4058 2
                        [ Module_Version >= 047

a4089 1
                        ]
a4250 1
                        [ Module_Version >= 047
a4279 7
      |
                        GetAsm  pm_newword,NE
                        SetLsr  R2,vv_inbpp,NE
                        SetImm  R4,vv_outbpptop,NE
                        PutAsm  pm_newword,NE
      ]
;
a4317 1
                        [ Module_Version >= 047
a4342 7
      |
                        GetAsm  tm_newword,NE
                        SetLsr  R3,vv_inbpp,NE
                        SetImm  R5,vv_outbpptop,NE
                        PutAsm  tm_newword,NE
      ]
;
a4685 2
                        [ Module_Version >= 047

a4733 2
                 ]

a4763 1
                        [ Module_Version >= 047
a4786 7
                        |
                        GetAsm  pt_newpixel,NE
                        SetLsr  R1,vv_inbpp,NE
                        SetImm  R3,vv_outbpptop,NE
                        PutAsm  pt_newpixel,NE
                        ]
;
a4817 1
                        [ Module_Version >= 047
a4826 8
                        |
                        GetAsm  m_newpixel2,NE
                        SetImm  R2,vv_outbpptop,NE
                        PutAsm  m_newpixel2,NE
                        BNE     %FT03
                        ]
;
                        [ Module_Version >= 047
a4900 6
                        |
                        TST     R11,#mc_ttr
                        GetAsm  t_newpixel2,NE
                        SetLsr  R2,vv_outbpp,NE
                        PutAsm  t_newpixel2,NE
                        ]
a4983 1
                        [       Module_Version >= 55                   ; Merged from 0.62 (GPS)
a4987 5
                        |                                       ;   "
pmt_putmany2            STR     R14,[outptr],#-xxx              ; outoffset
pmt_putmany2end         SUBS    vcount,vcount,#1
pmt_outoffset           *       pmt_putmany2
                        ]                                       ; Merged from 0.62 (GPS)
a5031 1
                        [       Module_Version >= 55                   ; Merged from 0.62 (GPS)
a5033 4
                        |                                       ; Merged from 0.62 (GPS)
                        Debug   cp,"pmt_putmany2"
                        Asm     pmt_putmany2
                        ]                                       ; Merged from 0.62 (GPS)
@


4.9
log
@  Now safe to use in IOMD builds again.
Detail:
  The use of ARMv4 SMULL instructions is now switched based upon the
  Hdr:CPU.Arch header file. This means that in IOMD ROM builds, only pre-v4
  instructions are used, so it will function on all required target platforms.
  Tungsten and OMAP3 builds will continue to use SMULL.
Admin:
  Inspected binary to ensure correct behaviour. Requires HdrSrc 1.67 or
  1.62/4.162.2.4.

Version 1.20. Tagged as 'SprExtend-1_20'
@
text
@d405 13
@


4.8
log
@Performance improvement and code tidy-up.

Removed local definition of XOS_CLI and XColourTrans_SelectTable, replaced
with header file.

Delete swiv2_old (moved to _old directory)

Changed to use {TRUE} and {FALSE} built in objasm variables.

Label dividebyzero fall through had code in the way for debug = {TRUE}.

Trimmed some dead code and definitions.

Stopped thrashing OS_CLI every time a JPEG plot is required to check
ColourTrans version, this is now done once at startup and a flag kept
instead.

Author: Rob Sprowson

Version 1.19. Tagged as 'SprExtend-1_19'
@
text
@d246 1
d370 1
a370 1
usemull SETL    {TRUE}
@


4.7
log
@A couple of 32-bit fixes.
Used to interpret negative translation table pointers as "none"; now just 0
as per documentation.
Plotting 16bpp sprites into 32bpp modes now correctly sets the 3 least
significant bits of each channel - used to be set to 0 due to a typo.
Build option (currently set to on) to use SMULL instructions.

Version 1.11. Tagged as 'SprExtend-1_11'
@
text
@d322 2
d326 1
a326 1
multibuffer SETL false                  ; keep multiple copies of generated code
d329 1
a329 1
vidc20  SETL    true                    ; VIDC20 support, else graphics enhancer
d332 1
a332 1
ignore_ttr SETL true                    ; if plotting <16 to >8bpp and it has a
d335 1
a335 1
med01867 SETL   true                   ; if true changes ignore_ttr behaviour to
d338 1
a338 1
flagbit SETL    true                    ; if true forces the palette to be used over
a341 1

d343 1
a343 1
widetrans SETL  true                    ; support for wide translation tables via R5 bit 5
d358 1
a358 1
ccompiler SETL  true
d360 1
a360 1
remoldcompiler SETL true
d363 1
a363 1
jpeg    SETL    true
d366 1
a366 1
dynamicarea    SETL    true
d369 1
a369 1
usemull SETL    true
d371 25
a395 26
debug   SETL    false
debugmc SETL    false                   ; macro compilation
debugpt SETL    true                    ; pointer
debugmg SETL    false                   ; 'merge sprites' code
debugid SETL    true                    ; insertdelete rows or columns
debugin SETL    true                    ; input parameters
debuglp SETL    false                   ; loop
debugsc SETL    false                   ; screen parameters
debugsp SETL    true                    ; sprite parameters
debugch SETL    false                   ; character painting
debugtr SETL    false                   ; transformed plotting
debuger SETL    false                   ; error trapping
debugxx SETL    false                   ; misc debugging
debugcg SETL    false                   ; code generator
debugcp SETL    false                   ; code generator - asm_putmany
debugco SETL    false                   ; code generator - asm_tryoutput
debugcn SETL    false                   ; code generator - asm_newpixel
debugcs SETL    false                   ; code generator - asm_start
debugcw SETL    false                   ; code generator - asm_newword
debugcu SETL    false                   ; code generator - asm_putword
debugmb SETL    false                   ; multibuffer code for code generator
debugms SETL    false                   ; minimal multibuffer info messages
debugag SETL    true                    ; amg transient debugging - could be
                                        ;   anywhere :-)
debuggs SETL    true                    ; JPEG SWI debugging.
debugcc SETL    true                    ; PutSpriteScaled compiler in C
d397 2
a398 2
hostvdu SETL    true
file    SETL    false
d401 1
a401 1
nbuffers * 8                            ;number of code buffers to use
a438 2
cr      *       13
lf      *       10
d441 4
a444 3
;;----------------------------------------------------------------------------
;; Macros
;;----------------------------------------------------------------------------
d480 1
a480 4
; Initialisation
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


a481 2
; Table of service calls we want

d502 1
a502 1

d577 5
d592 1
a592 1
        BVS     exitinitdie
d608 1
a671 11
;        ; Patch OS_ReadModeVariable to recognise type-9 new format sprites, and treat
;        ; them just the same as type 6. Technique lifted from IRQUtils. This is not
;        ; ROM-able - but then, I hope it would change if we put it in a ROM!
;        LDR     R0,=SvcTable+(OS_ReadModeVariable :SHL: 2)
;        LDR     R1,[R0]
;        STR     R1,oldReadModeVariable
;        ADRL    R1,newReadModeVariable
;        STR     R1,[R0]
;        ADRL    R0,newRMVr12               ; PC-relative place to store our wp
;        STR     wp,[R0]                    ; remember for use by newReadModeVariable

d682 10
a691 2
exitinitdie
        STRVS   R0,[sp]
d694 3
d737 1
a737 1
        B       exitinitdie
a903 1
maskorimage     #       4
d930 1
a936 4

;jpeg_data       #       4       ; the start of the JPEG data
;jpeg_data_size  #       4       ; length of JPEG data in bytes
oldReadModeVariable #    4       ; old entry address for OS_ReadModeVariable
d940 2
a941 2
save_PdriverIntercept #  4       ; Flags used to determine if the pdriver is
dither_truecolour   #    4       ; do we dither true colour images when reducing BPP?
d943 2
a944 2
newtranstable   #       256 *4                  ; buffer for pixel translation table
                                                ; or for palette converted to 16bpp...
a1064 1
;ccompiler_space #       7600    ; C code checks at run-time for there being enough.
a1068 16
;                [ jpeg
;                ; >>>> This space should be allocated as a separate block,
;                ; the first time JPEG facilities are used. Otherwise it's just too great
;                ; an overhead.
;                ; In its current form this is both a decompress_info_struct, and
;                ; a band buffer into which compression occurs.
;jpeg_space      #       0
;jpeg_error_code #       4              ; see h.jpegdata for details
;jpeg_error_argument1 #  4
;jpeg_error_argument2 #  4
;jpeg_band_buffer #      4
;jpeg_workspace_size # 4                ; total size jpeg_end-jpeg_space.
;jpeg_workspace  #       250000
;jpeg_end        #       0
;                ]

@


4.6
log
@  Now uses objasm throughout instead of aasm.
Detail:
  The build structure for this module is not nice - I've sanitised it a
    bit, but it's still not nice.
Admin:
   Built and tested with the test program briefly - the test sprite seems
     to scale and rotate properly.  ChangeFSI not tested.


Version 1.08. Tagged as 'SprExtend-1_08'
@
text
@d367 3
d503 1
a503 1
        
d1121 1
a1121 1
        ADRL    LR,My_SpriteExit+SVC_mode
d1184 4
a1187 5
        ADR     LR,%FT02+SVC_mode
        Push    "LR"                    ; set up return address
        LDR     R14,stackframe
        LDMIA   R14,{R10-R11,PC}        ; call rest of vector owners
02
d1394 1
a1394 1
        BGT     add_no_room             ; no, so complain!
d1631 2
a1632 2
        LDMGTIA R6,{R2-R5}              ; user-supplied scaling
        BGT     %FT01
d2387 2
a2388 2
        LDMGTIA R6,{R8-R11}
        BGT     %FT01
d2512 1
a2512 2
        CMP     R7,#0
        MOVLES  R7,#0                   ; 0 ==> no translation
d3532 2
a3533 2
        ADRLE   Ra,defaultpixeltable
        STRLE   Ra,ColourTTR
d3845 1
a3845 1
        ORRGT   R11,R11,#mc_ttr
d4016 5
a4020 5
        LDRGT   R0,save_ecflimit
        BLGT    convert_ROR
        LDRGT   R14,m_ecflimit
        SetImm  R14,R0,GT
        STRGT   R14,[R11]
d4047 5
a4051 5
        LDRGT   R0,save_ecflimit
        BLGT    convert_ROR
        LDRGT   R14,m_ecflimit
        SetImm  R14,R0,GT
        STRGT   R14,[R11]
d5102 1
a5102 1
                        MOVEQ   R0,#-1
@


4.5
log
@  Removal of empty debug loop.
  Addition of srccommit files.
Detail:
  * c.jrdjfif, get_dqt had an empty debug loop when debug was disabled.
    This is no longer compiled when debugging is not enabled.
  * VersionNum and VersionASM files added, and Sources.SprExtend modified
    to use symbols exported from there rather than from Version.
Admin:
  Ran on my machine. Previously tested in ROL builds.
  In future, might like to merge Exif support from ROL builds, but don't
  want to do that until I've re-read the specs on Exif format again.

Version 1.07. Tagged as 'SprExtend-1_07'
@
text
@d185 2
a186 2
;;			     Fixed Bug where plotting with 'action' AND was masking out all other
;;			     pixels in a word.
d188 2
a189 2
;;			     pessimistic. In c.SpriteOp
;;			     Added compiler flags to c.rojpeg so that CFSIjpeg compiles correctly.
d191 1
a191 1
;;			     Made SpriteExtend use a dynamic area to hold the JPEG workspace. in Sources.SprExtend,
d193 1
a193 1
;;			     Internationalised name of Dynamic Area. In Sources.CSupport and c.PutScaled.
d195 2
a196 2
;;			     Fixed bug in SpriteOp PaintCharScaled, where both the colour used for the plot
;;			     and the plotting action were being junked. In Sources.SprExtend and c.PutScaled
d198 1
a198 1
;;	                     Stopped OS_SpriteOp CheckSpriteArea junking r12. In Sources.SWIs
a242 2
Module_BaseAddr

a261 1
;        GET     Hdr:SWIs
d265 2
a266 1
        LEADR   Module_LoadAddr
d422 1
a422 1
Helpstr =       "SpriteExtension",9,"$Module_MajorVersion ($Module_Date)"
d500 2
d523 2
a524 2
	TEQ	r1, #Service_Reset      ; Re-initialise on soft reset
	BEQ	Init
d530 1
a530 1
service_territory_started ENTRY "r0-r11"
d680 4
a683 4
	; clear priver intercept flags....
        MOV	r0, #0
        ADRL	r2, save_PdriverIntercept
	STR     r0, [r2]
d686 3
a688 3
        MOV	r0, #0
        ADRL	r2, dither_truecolour
	STR     r0, [r2]
d1548 2
a1549 2
	Debug   gs,"Regs at start = ",R0,R1,R2,R3,R4
	Debug   gs,"                ",R5,R6,R7,R8,R9
d1567 2
a1568 2
	Debug   gs,"Regs at end   = ",R0,R1,R2,R3,R4
	Debug   gs,"                ",R5,R6,R7,R8,R9
d1906 1
a1906 1
        MOV	r0, #SpriteReason_PaintCharScaled
d2260 2
a2261 2
;	MOV     r2,r0
;	Debug   gs,"Plot Mask Scaled"
d2268 1
a2268 1
;	CMP     r2, #SpriteReason_PaintCharScaled
d2273 3
a2275 3
;	LDR	r5, bgcolour
;	ORR	r5, r5, #8                  ; avoid masko being knackered later
;;	Debug   gs, "Plot action is ",R5
d2277 5
a2281 5
;	AND     r2, r2, #255
;	CMP     r2, #SpriteReason_PaintCharScaled
;	MOVEQ   r0, #&80
;	MOVNE	r0, #&90
;	ADRL	r1, ecfspace
d2283 1
a2283 1
;;	Debug   gs, "setcolour returned, r0, r1=",r0,r1
d2306 2
a2307 2
	DCD	VduExt_GPLBMD
	DCD	-1
d2310 2
a2311 2
	DCD	VduExt_GPLFMD
	DCD	-1
d2402 4
a2405 4
	MOV	R8, #1
	MOV	R9, #1
	MOV	R10, #1
	MOV	R11, #1
d3284 1
a3284 2
checktrans ENTRY ""

d3298 1
a3298 1
        ; 16 -> 16 : \
d6104 5
a6108 5
	Push	"R1-R2,SL,LR"
	MOV	r2, r0			; save r0 in r2
	MOVS    r0, r0, LSR #8
	BEQ     CheckSprite_exit
      	MOV	r0, r1			;set up register for C function
d6110 1
a6110 1
      	BL	check_sprite_area	; branch into C
d6112 2
a6113 2
	CMP	r0, #0			; check if sprite area was valid
	BEQ	CheckSprite_exit
d6115 2
a6116 2
	SETV				; the sprite area is bad
        ADRL  	R0,ErrorBlock_BadData
d6118 1
a6118 1
	Pull	"R1-R2,SL,PC"
d6121 2
a6122 2
	MOV	r0, r2			;restore r0
	Pull	"R1-R2,SL,PC"
d6127 1
a6127 1
      	END
@


4.4
log
@32-bit compatible. Tagged as SprExtend-1_06
@
text
@d265 1
a265 1
        GET     Version
d424 1
a424 1
Helpstr =       "SpriteExtension",9,"$VString ($Date)"
d812 1
a812 1
                [ Version >= 047
d862 1
a862 1
              [ Version >= 047
d3031 1
a3031 1
      [ Version >=047
d3293 1
a3293 1
    [ Version >= 047
d4027 1
a4027 1
        [ Version >= 055
d4053 1
a4053 1
        [ Version >= 055
d4104 1
a4104 1
                        [ Version >= 047
d4299 1
a4299 1
                        [ Version >= 047
d4374 1
a4374 1
                        [ Version >= 047
d4750 1
a4750 1
                        [ Version >= 047
d4832 1
a4832 1
                        [ Version >= 047
d4894 1
a4894 1
                        [ Version >= 047
d4911 1
a4911 1
                        [ Version >= 047
d5075 1
a5075 1
                        [       Version >= 55                   ; Merged from 0.62 (GPS)
d5129 1
a5129 1
                        [       Version >= 55                   ; Merged from 0.62 (GPS)
@


4.3
log
@Spinner and Ursula branches merged.
@
text
@d231 1
a231 1
;;                           the foreground colour with the background one to make it work. 
d237 1
a237 1
;;                           
d418 1
d431 7
d508 1
a508 1
        
d515 1
a515 1
        MOVNES  pc, lr
d557 1
a557 1
        
d578 2
a579 2
        
        
d686 1
a686 1
        MOV	r0, #0       
d1108 1
a1108 1
        MOVCCS  pc, lr
d1284 2
a1285 1
        Pull    "r1-r11, pc",,^
d1322 2
a1323 1
        Pull    "r1-r11, pc",,^
d1455 1
a1455 1
        Pull    "r1-r11, pc",,^
d2184 1
a2184 1
   [ debuggs 
d2200 1
a2200 1
        MOV     r4, r4, LSR #8                ; BBGGRR00 to 00BBGGRR 
d2217 1
a2217 1
        BNE     %BT01        
d2225 1
a2225 1
   ]   
d2258 1
a2258 1
        Push    "R1-R9,LR"              
d2502 1
a2502 1
        BLEQ    makepalette16bpp 
d3458 1
a3458 1
        Pull    "R2,PC",,^
d4087 1
a4087 1
        Push    "LR"
d4099 1
a4099 1
        Pull    "PC",,^                 ; preserve flags
d6031 1
a6031 1
        Pull    "R0, PC",EQ,^       ; if an old format sprite, return R5 unchanged
d6059 1
a6059 1
        Pull    "R0, PC",,^
d6086 1
a6086 1
      STMFD R13!,{R0-R12,R14}
d6101 1
a6101 1
      LDMFD R13!,{R0-R12,R15}^ ;ensure we return flags how they started....
@


4.2
log
@Version RO_3_70 taken
@
text
@d469 28
a496 3
;;----------------------------------------------------------------------------
;; Initialisation
;;----------------------------------------------------------------------------
d499 12
d515 2
a516 4
        CMP     r1, #Service_ResourceFSStarted          ; Sets C if equal
        TEQNE   r1, #(Service_Reset :SHL: 2), 2         ; Clears C if executed
        MOVNE   pc, lr
        BCC     Init            ; Re-initialise on soft reset
@


4.2.2.1
log
@Added Ursula service call table.
@
text
@d469 3
a471 28


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Initialisation
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Table of service calls we want

        ASSERT  Service_ModeChange > Service_Reset
        ASSERT  Service_ResourceFSStarted > Service_ModeChange

ServiceTable

        DCD     0
        DCD     ServiceUrsula - Module_BaseAddr
        DCD     Service_Reset
        [ multibuffer
        DCD     Service_ModeChange
        ]
        DCD     Service_ResourceFSStarted
        DCD     0
        DCD     ServiceTable - Module_BaseAddr


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Service call handler
a473 12
        MOV     r0, r0                  ; Indicates there is a service call table
        
        ; Fast rejection
        TEQ     r1, #Service_ResourceFSStarted
        [ multibuffer
        TEQNE   r1, #Service_ModeChange
        ]
        TEQNE   r1, #Service_Reset
        MOVNES  pc, lr

ServiceUrsula

@


4.1
log
@Initial revision
@
text
@d233 5
d240 2
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a232 5
;; ---------------------- RISC OS 3.60 release module -----------------
;;
;; 15-Jun-95    1.00    GPS: Made JPEG Error diffusion work with <8bpp output. When outputting to greyscale modes, only take
;;                           luminance of the JPEG.
;;                           
a234 2
        GBLL    StrongARM
StrongARM SETL {TRUE}
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	1.2;
access;
symbols
	ChangeFSI-1_56:1.1
	ChangeFSI-1_55:1.1
	ChangeFSI-1_54:1.1
	ChangeFSI-1_53:1.1
	ChangeFSI-1_52:1.1
	ChangeFSI-1_51:1.1
	ChangeFSI-1_50:1.1
	ChangeFSI-1_49:1.1
	ChangeFSI-1_48:1.1
	ChangeFSI-1_47:1.1
	ChangeFSI-1_46:1.1
	ChangeFSI-1_45:1.1
	ChangeFSI-1_44:1.1
	ChangeFSI-1_43:1.1
	ChangeFSI-1_42:1.1
	ChangeFSI-1_41:1.1
	ChangeFSI-1_40:1.1
	ChangeFSI-1_39:1.1
	ChangeFSI-1_38:1.1
	ChangeFSI-1_37:1.1
	ChangeFSI-1_36:1.1
	ChangeFSI-1_35:1.1
	ChangeFSI-1_34:1.1
	ChangeFSI-1_33:1.1
	ChangeFSI-1_32:1.1
	ChangeFSI-1_31:1.1
	ChangeFSI-1_30:1.1
	ChangeFSI-1_29:1.1
	ChangeFSI-1_28:1.1
	ChangeFSI-1_27:1.1
	ChangeFSI-1_26:1.1
	ChangeFSI-1_25:1.1
	ChangeFSI-1_24:1.1
	ChangeFSI-1_23:1.1
	ChangeFSI-1_22:1.1
	ChangeFSI-1_21:1.1
	ChangeFSI-1_20:1.1
	ChangeFSI-1_19:1.1
	ChangeFSI-1_18:1.1;
locks; strict;
comment	@# @;


1.2
date	2016.02.06.18.37.56;	author rool;	state dead;
branches;
next	1.1;
commitid	Ru1mYtY160bvYSTy;

1.1
date	2002.11.05.19.02.00;	author rsprowson;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Move aside IJG5 and IJG6b sources
Admin:
  Not tagged.
@
text
@/*
 * jmemansi.c
 *
 * Copyright (C) 1992-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file provides a simple generic implementation of the system-
 * dependent portion of the JPEG memory manager.  This implementation
 * assumes that you have the ANSI-standard library routine tmpfile().
 * Also, the problem of determining the amount of memory available
 * is shoved onto the user.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"
#include "jmemsys.h"		/* import the system-dependent declarations */

#ifndef HAVE_STDLIB_H		/* <stdlib.h> should declare malloc(),free() */
extern void * malloc JPP((size_t size));
extern void free JPP((void *ptr));
#endif

#ifndef SEEK_SET		/* pre-ANSI systems may not define this; */
#define SEEK_SET  0		/* if not, assume 0 is correct */
#endif


/*
 * Memory allocation and freeing are controlled by the regular library
 * routines malloc() and free().
 */

GLOBAL(void *)
jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject)
{
  return (void *) malloc(sizeofobject);
}

GLOBAL(void)
jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject)
{
  free(object);
}


/*
 * "Large" objects are treated the same as "small" ones.
 * NB: although we include FAR keywords in the routine declarations,
 * this file won't actually work in 80x86 small/medium model; at least,
 * you probably won't be able to process useful-size images in only 64KB.
 */

GLOBAL(void FAR *)
jpeg_get_large (j_common_ptr cinfo, size_t sizeofobject)
{
  return (void FAR *) malloc(sizeofobject);
}

GLOBAL(void)
jpeg_free_large (j_common_ptr cinfo, void FAR * object, size_t sizeofobject)
{
  free(object);
}


/*
 * This routine computes the total memory space available for allocation.
 * It's impossible to do this in a portable way; our current solution is
 * to make the user tell us (with a default value set at compile time).
 * If you can actually get the available space, it's a good idea to subtract
 * a slop factor of 5% or so.
 */

#ifndef DEFAULT_MAX_MEM		/* so can override from makefile */
#define DEFAULT_MAX_MEM		1000000L /* default: one megabyte */
#endif

GLOBAL(long)
jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed,
		    long max_bytes_needed, long already_allocated)
{
  return cinfo->mem->max_memory_to_use - already_allocated;
}


/*
 * Backing store (temporary file) management.
 * Backing store objects are only used when the value returned by
 * jpeg_mem_available is less than the total space needed.  You can dispense
 * with these routines if you have plenty of virtual memory; see jmemnobs.c.
 */


METHODDEF(void)
read_backing_store (j_common_ptr cinfo, backing_store_ptr info,
		    void FAR * buffer_address,
		    long file_offset, long byte_count)
{
  if (fseek(info->temp_file, file_offset, SEEK_SET))
    ERREXIT(cinfo, JERR_TFILE_SEEK);
  if (JFREAD(info->temp_file, buffer_address, byte_count)
      != (size_t) byte_count)
    ERREXIT(cinfo, JERR_TFILE_READ);
}


METHODDEF(void)
write_backing_store (j_common_ptr cinfo, backing_store_ptr info,
		     void FAR * buffer_address,
		     long file_offset, long byte_count)
{
  if (fseek(info->temp_file, file_offset, SEEK_SET))
    ERREXIT(cinfo, JERR_TFILE_SEEK);
  if (JFWRITE(info->temp_file, buffer_address, byte_count)
      != (size_t) byte_count)
    ERREXIT(cinfo, JERR_TFILE_WRITE);
}


METHODDEF(void)
close_backing_store (j_common_ptr cinfo, backing_store_ptr info)
{
  fclose(info->temp_file);
  /* Since this implementation uses tmpfile() to create the file,
   * no explicit file deletion is needed.
   */
}


/*
 * Initial opening of a backing-store object.
 *
 * This version uses tmpfile(), which constructs a suitable file name
 * behind the scenes.  We don't have to use info->temp_name[] at all;
 * indeed, we can't even find out the actual name of the temp file.
 */

GLOBAL(void)
jpeg_open_backing_store (j_common_ptr cinfo, backing_store_ptr info,
			 long total_bytes_needed)
{
  if ((info->temp_file = tmpfile()) == NULL)
    ERREXITS(cinfo, JERR_TFILE_CREATE, "");
  info->read_backing_store = read_backing_store;
  info->write_backing_store = write_backing_store;
  info->close_backing_store = close_backing_store;
}


/*
 * These routines take care of any system-dependent initialization and
 * cleanup required.
 */

GLOBAL(long)
jpeg_mem_init (j_common_ptr cinfo)
{
  return DEFAULT_MAX_MEM;	/* default for max_memory_to_use */
}

GLOBAL(void)
jpeg_mem_term (j_common_ptr cinfo)
{
  /* no work */
}
@


1.1
log
@Lost the sources to 1.15 somewhere,and RISC OS 4 came with 1.17.
Output template reworked
Zoom template swiped from !Paint
Infobox and saveas box swiped from !Edit
Improved error messages for unsupported formats
Hyphenated the date (also now derived at build time from the VersionNum
file)
Assembler stamped on to remove 26 bit code (uses MRS and MSR,hence ARM6
or later,but the RMEnsure of Utility module catches this).
Rejigged a few ADRs which were no longer in range due to the above.
Added ChangeFSI alias to !Boot file,it's always been documented as being
available...
Took 6b of the IJG jpeg code,and updated the JPEGinfo file accordingly
3dtemplate renamed as Template3d
Eliminated some dead documentation which never went on the disc image
anyway
Bug fix for CLI use when output is an S16 sprite,no default x dpi or y dpi
was assumed leading to an infinitely narrow infinitely tall sprite.
REM'd out the sketchy support for S24,a mythical 24 bpp packed sprite and
tweaked the docs to read S32 which you can actually generate!
Now handles progressive JPEGs (merged from a patched CFSI from RComp's
webpages).
Adds TechnoI video digitiser reading (untested)
Adds P8 reading (untested)
Merged the useful bits from RISC OS Ltd's sources,which seem to be
pretty unchanged from V1.15.
 * Missing hpcdtoppm sources,so no 32 bit there
 * Missing btpc sources,so no 32 bit there

Version 1.18. Tagged as 'ChangeFSI-1_18'
@
text
@@


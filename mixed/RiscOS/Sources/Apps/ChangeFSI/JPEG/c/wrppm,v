head	4.2;
access;
symbols
	ChangeFSI-1_62:4.2
	ChangeFSI-1_61:4.2
	ChangeFSI-1_60:4.2
	ChangeFSI-1_59:4.2
	ChangeFSI-1_58:4.2
	ChangeFSI-1_57:4.2
	ChangeFSI-Import-IJG8d:4.2
	ChangeFSI-1_56:4.1.1.1
	ChangeFSI-1_55:4.1.1.1
	ChangeFSI-1_54:4.1.1.1
	ChangeFSI-1_53:4.1.1.1
	ChangeFSI-1_52:4.1.1.1
	ChangeFSI-1_51:4.1.1.1
	ChangeFSI-1_50:4.1.1.1
	ChangeFSI-1_49:4.1.1.1
	ChangeFSI-1_48:4.1.1.1
	ChangeFSI-1_47:4.1.1.1
	ChangeFSI-1_46:4.1.1.1
	ChangeFSI-1_45:4.1.1.1
	ChangeFSI-1_44:4.1.1.1
	ChangeFSI-1_43:4.1.1.1
	ChangeFSI-1_42:4.1.1.1
	ChangeFSI-1_41:4.1.1.1
	ChangeFSI-1_40:4.1.1.1
	ChangeFSI-1_39:4.1.1.1
	ChangeFSI-1_38:4.1.1.1
	ChangeFSI-1_37:4.1.1.1
	ChangeFSI-1_36:4.1.1.1
	ChangeFSI-1_35:4.1.1.1
	ChangeFSI-1_34:4.1.1.1
	ChangeFSI-1_33:4.1.1.1
	ChangeFSI-1_32:4.1.1.1
	ChangeFSI-1_31:4.1.1.1
	ChangeFSI-1_30:4.1.1.1
	ChangeFSI-1_29:4.1.1.1
	ChangeFSI-1_28:4.1.1.1
	ChangeFSI-1_27:4.1.1.1
	ChangeFSI-1_26:4.1.1.1
	ChangeFSI-1_25:4.1.1.1
	ChangeFSI-1_24:4.1.1.1
	ChangeFSI-1_23:4.1.1.1
	ChangeFSI-1_22:4.1.1.1
	ChangeFSI-1_21:4.1.1.1
	ChangeFSI-1_20:4.1.1.1
	ChangeFSI-1_19:4.1.1.1
	ChangeFSI-1_18:4.1.1.1
	ChangeFSI-1_12:4.1.1.1
	RO_3_71:4.1.3.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.2
date	2016.02.06.18.57.40;	author rool;	state Exp;
branches;
next	4.1;
commitid	qz3Ii4kUgInF4TTy;

4.1
date	96.11.05.09.18.26;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1;
next	;

4.1.1.1
date	96.11.05.09.18.26;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.19.13;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.2
log
@Import IJG8d sources
Detail:
  This is a clean import of the reference code from JPEG 8d. One of the terms of use is to be able to show the changes made to the reference copy, so this commit serves as that point.
Admin:
  Tagged as ChangeFSI-Import-IJG8d
  Doesn't build.
@
text
@/*
 * wrppm.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * Modified 2009 by Guido Vollbeding.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains routines to write output images in PPM/PGM format.
 * The extended 2-byte-per-sample raw PPM/PGM formats are supported.
 * The PBMPLUS library is NOT required to compile this software
 * (but it is highly useful as a set of PPM image manipulation programs).
 *
 * These routines may need modification for non-Unix environments or
 * specialized applications.  As they stand, they assume output to
 * an ordinary stdio stream.
 */

#include "cdjpeg.h"		/* Common decls for cjpeg/djpeg applications */

#ifdef PPM_SUPPORTED


/*
 * For 12-bit JPEG data, we either downscale the values to 8 bits
 * (to write standard byte-per-sample PPM/PGM files), or output
 * nonstandard word-per-sample PPM/PGM files.  Downscaling is done
 * if PPM_NORAWWORD is defined (this can be done in the Makefile
 * or in jconfig.h).
 * (When the core library supports data precision reduction, a cleaner
 * implementation will be to ask for that instead.)
 */

#if BITS_IN_JSAMPLE == 8
#define PUTPPMSAMPLE(ptr,v)  *ptr++ = (char) (v)
#define BYTESPERSAMPLE 1
#define PPM_MAXVAL 255
#else
#ifdef PPM_NORAWWORD
#define PUTPPMSAMPLE(ptr,v)  *ptr++ = (char) ((v) >> (BITS_IN_JSAMPLE-8))
#define BYTESPERSAMPLE 1
#define PPM_MAXVAL 255
#else
/* The word-per-sample format always puts the MSB first. */
#define PUTPPMSAMPLE(ptr,v)			\
	{ register int val_ = v;		\
	  *ptr++ = (char) ((val_ >> 8) & 0xFF);	\
	  *ptr++ = (char) (val_ & 0xFF);	\
	}
#define BYTESPERSAMPLE 2
#define PPM_MAXVAL ((1<<BITS_IN_JSAMPLE)-1)
#endif
#endif


/*
 * When JSAMPLE is the same size as char, we can just fwrite() the
 * decompressed data to the PPM or PGM file.  On PCs, in order to make this
 * work the output buffer must be allocated in near data space, because we are
 * assuming small-data memory model wherein fwrite() can't reach far memory.
 * If you need to process very wide images on a PC, you might have to compile
 * in large-memory model, or else replace fwrite() with a putc() loop ---
 * which will be much slower.
 */


/* Private version of data destination object */

typedef struct {
  struct djpeg_dest_struct pub;	/* public fields */

  /* Usually these two pointers point to the same place: */
  char *iobuffer;		/* fwrite's I/O buffer */
  JSAMPROW pixrow;		/* decompressor output buffer */
  size_t buffer_width;		/* width of I/O buffer */
  JDIMENSION samples_per_row;	/* JSAMPLEs per output row */
} ppm_dest_struct;

typedef ppm_dest_struct * ppm_dest_ptr;


/*
 * Write some pixel data.
 * In this module rows_supplied will always be 1.
 *
 * put_pixel_rows handles the "normal" 8-bit case where the decompressor
 * output buffer is physically the same as the fwrite buffer.
 */

METHODDEF(void)
put_pixel_rows (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,
		JDIMENSION rows_supplied)
{
  ppm_dest_ptr dest = (ppm_dest_ptr) dinfo;

  (void) JFWRITE(dest->pub.output_file, dest->iobuffer, dest->buffer_width);
}


/*
 * This code is used when we have to copy the data and apply a pixel
 * format translation.  Typically this only happens in 12-bit mode.
 */

METHODDEF(void)
copy_pixel_rows (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,
		 JDIMENSION rows_supplied)
{
  ppm_dest_ptr dest = (ppm_dest_ptr) dinfo;
  register char * bufferptr;
  register JSAMPROW ptr;
  register JDIMENSION col;

  ptr = dest->pub.buffer[0];
  bufferptr = dest->iobuffer;
  for (col = dest->samples_per_row; col > 0; col--) {
    PUTPPMSAMPLE(bufferptr, GETJSAMPLE(*ptr++));
  }
  (void) JFWRITE(dest->pub.output_file, dest->iobuffer, dest->buffer_width);
}


/*
 * Write some pixel data when color quantization is in effect.
 * We have to demap the color index values to straight data.
 */

METHODDEF(void)
put_demapped_rgb (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,
		  JDIMENSION rows_supplied)
{
  ppm_dest_ptr dest = (ppm_dest_ptr) dinfo;
  register char * bufferptr;
  register int pixval;
  register JSAMPROW ptr;
  register JSAMPROW color_map0 = cinfo->colormap[0];
  register JSAMPROW color_map1 = cinfo->colormap[1];
  register JSAMPROW color_map2 = cinfo->colormap[2];
  register JDIMENSION col;

  ptr = dest->pub.buffer[0];
  bufferptr = dest->iobuffer;
  for (col = cinfo->output_width; col > 0; col--) {
    pixval = GETJSAMPLE(*ptr++);
    PUTPPMSAMPLE(bufferptr, GETJSAMPLE(color_map0[pixval]));
    PUTPPMSAMPLE(bufferptr, GETJSAMPLE(color_map1[pixval]));
    PUTPPMSAMPLE(bufferptr, GETJSAMPLE(color_map2[pixval]));
  }
  (void) JFWRITE(dest->pub.output_file, dest->iobuffer, dest->buffer_width);
}


METHODDEF(void)
put_demapped_gray (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,
		   JDIMENSION rows_supplied)
{
  ppm_dest_ptr dest = (ppm_dest_ptr) dinfo;
  register char * bufferptr;
  register JSAMPROW ptr;
  register JSAMPROW color_map = cinfo->colormap[0];
  register JDIMENSION col;

  ptr = dest->pub.buffer[0];
  bufferptr = dest->iobuffer;
  for (col = cinfo->output_width; col > 0; col--) {
    PUTPPMSAMPLE(bufferptr, GETJSAMPLE(color_map[GETJSAMPLE(*ptr++)]));
  }
  (void) JFWRITE(dest->pub.output_file, dest->iobuffer, dest->buffer_width);
}


/*
 * Startup: write the file header.
 */

METHODDEF(void)
start_output_ppm (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)
{
  ppm_dest_ptr dest = (ppm_dest_ptr) dinfo;

  /* Emit file header */
  switch (cinfo->out_color_space) {
  case JCS_GRAYSCALE:
    /* emit header for raw PGM format */
    fprintf(dest->pub.output_file, "P5\n%ld %ld\n%d\n",
	    (long) cinfo->output_width, (long) cinfo->output_height,
	    PPM_MAXVAL);
    break;
  case JCS_RGB:
    /* emit header for raw PPM format */
    fprintf(dest->pub.output_file, "P6\n%ld %ld\n%d\n",
	    (long) cinfo->output_width, (long) cinfo->output_height,
	    PPM_MAXVAL);
    break;
  default:
    ERREXIT(cinfo, JERR_PPM_COLORSPACE);
  }
}


/*
 * Finish up at the end of the file.
 */

METHODDEF(void)
finish_output_ppm (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)
{
  /* Make sure we wrote the output file OK */
  fflush(dinfo->output_file);
  if (ferror(dinfo->output_file))
    ERREXIT(cinfo, JERR_FILE_WRITE);
}


/*
 * The module selection routine for PPM format output.
 */

GLOBAL(djpeg_dest_ptr)
jinit_write_ppm (j_decompress_ptr cinfo)
{
  ppm_dest_ptr dest;

  /* Create module interface object, fill in method pointers */
  dest = (ppm_dest_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(ppm_dest_struct));
  dest->pub.start_output = start_output_ppm;
  dest->pub.finish_output = finish_output_ppm;

  /* Calculate output image dimensions so we can allocate space */
  jpeg_calc_output_dimensions(cinfo);

  /* Create physical I/O buffer.  Note we make this near on a PC. */
  dest->samples_per_row = cinfo->output_width * cinfo->out_color_components;
  dest->buffer_width = dest->samples_per_row * (BYTESPERSAMPLE * SIZEOF(char));
  dest->iobuffer = (char *) (*cinfo->mem->alloc_small)
    ((j_common_ptr) cinfo, JPOOL_IMAGE, dest->buffer_width);

  if (cinfo->quantize_colors || BITS_IN_JSAMPLE != 8 ||
      SIZEOF(JSAMPLE) != SIZEOF(char)) {
    /* When quantizing, we need an output buffer for colormap indexes
     * that's separate from the physical I/O buffer.  We also need a
     * separate buffer if pixel format translation must take place.
     */
    dest->pub.buffer = (*cinfo->mem->alloc_sarray)
      ((j_common_ptr) cinfo, JPOOL_IMAGE,
       cinfo->output_width * cinfo->output_components, (JDIMENSION) 1);
    dest->pub.buffer_height = 1;
    if (! cinfo->quantize_colors)
      dest->pub.put_pixel_rows = copy_pixel_rows;
    else if (cinfo->out_color_space == JCS_GRAYSCALE)
      dest->pub.put_pixel_rows = put_demapped_gray;
    else
      dest->pub.put_pixel_rows = put_demapped_rgb;
  } else {
    /* We will fwrite() directly from decompressor output buffer. */
    /* Synthesize a JSAMPARRAY pointer structure */
    /* Cast here implies near->far pointer conversion on PCs */
    dest->pixrow = (JSAMPROW) dest->iobuffer;
    dest->pub.buffer = & dest->pixrow;
    dest->pub.buffer_height = 1;
    dest->pub.put_pixel_rows = put_pixel_rows;
  }

  return (djpeg_dest_ptr) dest;
}

#endif /* PPM_SUPPORTED */
@


4.1
log
@Initial revision
@
text
@d4 2
a5 1
 * Copyright (C) 1991-1994, Thomas G. Lane.
d10 1
d25 5
a29 4
 * Currently, this code only knows how to write raw PPM or PGM format,
 * which can be no more than 8 bits/sample.  As an expedient for testing
 * 12-bit JPEG mode, we support writing 12-bit data to an 8-bit file by
 * downscaling the values.  Of course this implies loss of precision.
d35 3
a37 1
#define DOWNSCALE(x)  (x)
d39 14
a52 1
#define DOWNSCALE(x)  ((x) >> (BITS_IN_JSAMPLE-8))
d75 2
a76 2

  JDIMENSION buffer_width;	/* width of one row */
d90 1
a90 1
METHODDEF void
d101 2
a102 2
 * This code is used when we have to copy the data because JSAMPLE is not
 * the same size as char.  Typically this only happens in 12-bit mode.
d105 1
a105 1
METHODDEF void
d116 2
a117 2
  for (col = dest->buffer_width; col > 0; col--) {
    *bufferptr++ = (char) DOWNSCALE(GETJSAMPLE(*ptr++));
d128 1
a128 1
METHODDEF void
d145 3
a147 3
    *bufferptr++ = (char) DOWNSCALE(GETJSAMPLE(color_map0[pixval]));
    *bufferptr++ = (char) DOWNSCALE(GETJSAMPLE(color_map1[pixval]));
    *bufferptr++ = (char) DOWNSCALE(GETJSAMPLE(color_map2[pixval]));
d153 1
a153 1
METHODDEF void
d166 1
a166 1
    *bufferptr++ = (char) DOWNSCALE(GETJSAMPLE(color_map[GETJSAMPLE(*ptr++)]));
d176 1
a176 1
METHODDEF void
d186 2
a187 1
	    (long) cinfo->output_width, (long) cinfo->output_height, 255);
d192 2
a193 1
	    (long) cinfo->output_width, (long) cinfo->output_height, 255);
d205 1
a205 1
METHODDEF void
d219 1
a219 1
GLOBAL djpeg_dest_ptr
d235 4
a238 4
  dest->buffer_width = cinfo->output_width * cinfo->out_color_components;
  dest->iobuffer = (char *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(size_t) (dest->buffer_width * SIZEOF(char)));
d240 2
a241 1
  if (cinfo->quantize_colors || SIZEOF(JSAMPLE) != SIZEOF(char)) {
d244 1
a244 1
     * separate buffer if JSAMPLE and char are not the same size.
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

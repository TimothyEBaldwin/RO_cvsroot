head	4.14;
access;
symbols
	NFS-3_27:4.14
	NFS-3_26:4.13
	NFS-3_25:4.13
	NFS-3_24:4.12
	NFS-3_23:4.12
	NFS-3_22:4.11
	NFS-3_21:4.11
	NFS-3_20:4.11
	NFS-3_19:4.10
	sbrodie_NFS_dev_merge:4.9.2.2
	NFS-3_18-4_22_2_4:4.9.2.2
	NFS-3_18-4_22_2_3:4.9.2.1
	NFS-3_18-4_22_2_2:4.9
	NFS-3_18-4_22_2_1:4.9
	sbrodie_NFS_dev:4.9.0.2
	sbrodie_NFS_dev_bp:4.9
	NFS-3_18:4.9
	NFS-3_17:4.9
	NFS-3_16:4.8
	NFS-3_15:4.8
	NFS-3_14:4.7
	NFS-3_13:4.7
	NFS-3_12:4.7
	NFS-3_11:4.6
	NFS-3_10:4.6
	NFS-3_09:4.6
	NFS-3_08:4.5
	NFS-3_07:4.5
	NFS-3_06:4.5
	NFS-3_05:4.5
	NFS-3_04:4.4
	NFS-3_02:4.4
	NFS-3_01:4.4
	NFS-3_00:4.4
	NFS-2_37:4.3
	NFS-2_36:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.10
	NFS-2_35:4.2
	Spin_merge:4.1.7.1
	Spinner_23Sep1998_destend:4.1
	Spinner_23Sep1998_srcend:4.1.7.1
	Spinner_23Sep1998_srcbegin:4.1.7.1
	Spinner_23Sep1998_destbegin:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.8
	Ursula_13May1998_bp:4.1
	Ursula_13May1998:4.1.0.4
	rthornb_UrsulaBuild_01May1998:4.1
	pwombwel_2_32:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	MergeFiles:4.1.7.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1;
locks; strict;
comment	@# @;


4.14
date	2018.08.11.15.19.58;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	PqgMwO4OkSjEpINA;

4.13
date	2018.03.07.21.22.40;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	sKJZhgBEKf2WsztA;

4.12
date	2018.01.29.21.30.18;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	7TGUL0NEVVbjHOoA;

4.11
date	2004.06.07.14.13.07;	author srevill;	state Exp;
branches;
next	4.10;

4.10
date	2003.12.10.14.55.09;	author bavison;	state Exp;
branches;
next	4.9;

4.9
date	2000.08.23.11.39.36;	author sbrodie;	state Exp;
branches
	4.9.2.1;
next	4.8;

4.8
date	2000.07.06.16.30.13;	author sbrodie;	state Exp;
branches;
next	4.7;

4.7
date	2000.06.26.11.54.39;	author sbrodie;	state Exp;
branches;
next	4.6;

4.6
date	2000.03.20.15.52.15;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	99.12.06.15.58.02;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	99.05.14.12.42.05;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	98.11.27.15.58.24;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	98.11.13.16.07.04;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.22.14.49.27;	author nturton;	state Exp;
branches
	4.1.5.1
	4.1.7.1;
next	;

4.9.2.1
date	2001.06.18.12.31.25;	author sbrodie;	state Exp;
branches;
next	4.9.2.2;

4.9.2.2
date	2001.07.02.11.04.32;	author sbrodie;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.49.27;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.06.34;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.14
log
@Guard against potential NULL pointer read
Commands.c: Adjust logic so strchr() is only called with a valid pointer.
Found by cppcheck static analysis.
_Close.C: Tighten up sloppy check of load address to include exec address.

Version 3.27. Tagged as 'NFS-3_27'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*	COMMANDS

Purpose : Command processors for RISC OS NFS

History :
Date	Who    Comments
-----------------------------------------------------------------------------

10/02/95  CP   Added code to print out network accesses
23/02/95  KSR  Added nfs_boot() function
19/02/96  DNW  Added Timeout and CacheSize stuff
20/02/96  KJB  Removed TimeOffset command
19/10/96  AJS  Added udp retry-time option to *timeout
***************************************************************************/

#ifndef __NFSNFS_H
#include "nfsheaders.h"
#endif

#include "TimeOut.h"
#include "AsmUtils/callbacks.h"

#ifdef NETACCESSCOUNT
extern unsigned int NetAccessCountG;
#endif

#ifdef PACKETSIZE_COMMAND
int NFS_MAXDATA = 8192;
#endif

/*
        Select NFS for a *NFS command
*/
_kernel_oserror *command_nfs
(
        char *arg_string,
        int argc
)
{
        arg_string = arg_string;
        argc = argc;

        return _swix(OS_FSControl, _INR(0,1), FSControl_SelectFilingSystem,
                                              NFSFilingSystemName );
}

/*
        Encrypt a string for name checking
*/
static char *encryptstring
(
        char *string
)
{
        char *result = malloc( strlen( string ) + 1 );
        int i;

        if ( result )
        {
                for ( i = 0;
                        string[ i ];
                        i++ )
                {
                        result[ i ] = string[ i ] ^ 0x5b;
                }
                result[ i ] = '\0';
        }

        return result;
}

/*
        Switch to given user with password
*/
_kernel_oserror *process_nfsname
(
        char *username,
        char *password
)
{
        AUTH *authorisation;
        _kernel_oserror *err;
        v2_auth_args aargs;
        v2_auth_results *ares;
        unused_client *pcnfsd_client;
        char machname[MAX_MACHINE_NAME + 1];
        int len;
        u_long version;
        int gids[NGRPS];
        gid_t *gp;

        /*
                Is the user nobody?
        */
        if ( caseless_strcmp( username, User_Nobody ) == 0 )
        {
                err = new_user(
                        &current_user,
                        User_Nobody,
                        NULL,
                        UNIX_MagicNumber_UID_Nobody,
                        UNIX_MagicNumber_GID_Nobody,
                        authunix_create_default(),
                        0,
                        NULL,
                        -1);
                return err;
        }

        /*
                The user isn't nobody, so we jolly well aught to have a host
        */
        if ( current_nameing_host == NULL )
        {
                return mb_no_nameing_host;
        }

        /*
                No password, so assume empty string
        */
        if ( password == NULL )
        {
                password = "";
        }

        version = current_nameing_host->pcnfs_version;

        err = get_pcnfsd_client_for_host( &pcnfsd_client, current_nameing_host, version );
        if ( err )
                return err;

        gethostname(machname, MAX_MACHINE_NAME);
        machname[MAX_MACHINE_NAME] = 0;

        aargs.system = machname;
        aargs.id = encryptstring( username );
        aargs.pw = encryptstring( password );
        aargs.cm = "";

        if ( version == PCNFSDVERS)
        {
                static v2_auth_results ar2;
                auth_args a;
                auth_results *ar;
                a.id = aargs.id;
                a.pw = aargs.pw;
                ar = pcnfsd_auth_1( &a, pcnfsd_client->client );
                if (ar == NULL)
                {
                        ares = NULL;
                }
                else {
                        ares = &ar2;
                        ar2.stat = ar->stat;
                        ar2.uid = ar->uid;
                        ar2.gid = ar->gid;
                        ar2.gids.gids_len = 0;
                        ar2.def_umask = -1;
                }
        }
        else
        {
                ares = pcnfsd2_auth_2( &aargs, pcnfsd_client->client );
        }

        free( aargs.id );
        free( aargs.pw );

        if ( ares )
        {
                release_client( pcnfsd_client );

                if (ares->def_umask == 0) ares->def_umask = -1;

                switch( ares->stat )
                {
                case AUTH_RES_OK:
                        /* do nothing */
                        break;

                case AUTH_RES_FAKE:
                        return mb_authorisation_failed;
                        break;
                default:
                case AUTH_RES_FAIL:
                        return mb_authorisation_failed;
                        break;
                }
        }
        else
        {
                _kernel_oserror *err = (_kernel_oserror *)return_buffer;

                err->errnum = 0;
                strcpy( err->errmess, clnt_sperror( pcnfsd_client->client, "Authorising" ));

                release_client( pcnfsd_client );

                return err;
        }

        if (version == PCNFSDVERS || ares->gids.gids_len == 0)
        {
                len = getgroups( NGRPS, gids );
                gp = (gid_t *) gids;
        }
        else
        {
                len = ares->gids.gids_len;
                gp = (gid_t *) ares->gids.gids_val;
        }

        authorisation = authunix_create( machname, ares->uid, ares->gid, len, gp );

        err = new_user( &current_user, username, current_nameing_host, (int)ares->uid, (int)ares->gid, authorisation,
                len, (gid3 *) gp, ares->def_umask);

        if ( err )
                return err;

        memset( current_user->gnames, 0, sizeof current_user->gnames );

        if (version == PCNFSDV2)
        {
                /* PCNFS version 2 - attempt to find the group names; ignore errors */
                v2_mapid_results *res;
                mapreq_res gids;
                v2_mapid_args args;
                static mapreq_arg_item items[NGRPS+1];
                int i;

                if ( get_pcnfsd_client_for_host( &pcnfsd_client, current_nameing_host, version ) )
                        return NULL;

                args.cm = "";
                args.req_list = items;
                /* The irregular loop termination condition is because we are looking up the
                 * primary GID as well as the supplementary GIDs
                 */
                for (i = 0; i <= NGRPS; ++i) {
                        if (i <= len)
                        {
                                items[i].mapreq_next = items + i + 1;
                                items[i].req = MAP_REQ_GID;
                                items[i].name = "";
                                if ( i == 0 )
                                        items[i].id = (int) ares->gid;
                                else
                                        items[i].id = (int) gp[i - 1];
                        }
                        else
                        {
                                items[i-1].mapreq_next = NULL;
                        }
                }

                res = pcnfsd2_mapid_2( &args, pcnfsd_client->client );

                release_client( pcnfsd_client );

                if ( res ==  NULL)
                        return NULL;

                for (i = 0, gids = res->res_list; gids != NULL && i <= NGRPS; ++i)
                {
                        if ( gids->stat == MAP_RES_OK )
                        {
                                strncpy( current_user->gnames[i].name, gids->name, sizeof current_user->gnames[i].name );
                                if ( i == 0 )
                                {
                                        dprintf(("", "Primary GID %d -> %s\n", ares->gid, gids->name));
                                }
                                else
                                {
                                        dprintf(("", "Supplementary GID %ld -> %s\n", gp[i-1], gids->name));
                                }

                        }

                        gids = gids->mapreq_next;
                }

                xdr_free( xdr_v2_mapid_results, res );
        }

        return NULL;
}

/*
        Process *NFS:Logon command
*/
_kernel_oserror *command_nfsname
(
        char *arg_string,
        int argc
)
{
        int *readargs_buffer;
        _kernel_oserror *err;
        char *hostname;
        char *username;
        char *password;

        if ( argc == 0 )
        {
                /*
                        *Logon
                          Display the current NFSName.
                */
                if ( current_user == NULL )
                {
                        return mb_no_user;
                }
                else
                {
                        err = lightweight_printf( "The current user is %0s\n", current_user->name );

                        if ( !err )
                        {
                                if ( current_nameing_host )
                                {
                                        err = lightweight_printf( "The current name server is %0s\n", current_nameing_host->host_name );
                                }
                                else
                                {
                                        err = lightweight_printf( "There is no current name server\n" );
                                }
                        }

                        return err;
                }
        }
        else
        {
                /*
                        *Logon [-Host <hostname>] [<username> [<password>]]
                          Set the current user
                */

                readargs_buffer = (int *)malloc( ReadArgsBufferLen * sizeof( *readargs_buffer ));

                if ( readargs_buffer == NULL )
                        return mb_malloc_failed;

                err = _swix(OS_ReadArgs, _INR(0,3), "host=h/k/g,username/g,password/g",
                                                    arg_string, readargs_buffer,
                                                    ReadArgsBufferLen);

                if ( err )
                {
                        free( readargs_buffer );
                        return err;
                }

                hostname = username = password = NULL;

                err = readargs_getstring( &hostname, readargs_buffer, 0 );
                if ( !err )
                        err = readargs_getstring( &username, readargs_buffer, 1 );
                if ( !err )
                        err = readargs_getstring( &password, readargs_buffer, 2 );
                free( readargs_buffer );

                if ( !err )
                        err = new_host( &current_nameing_host, hostname );

                free( hostname );

                if ( err )
                {
                        if ( password )
                                free( password );
                        if ( username )
                                free( username );

                        return err;
                }

                /*
                        Are we specifying the user in this call?
                */
                if ( username == NULL )
                {
                        free( password );

                        return NULL;
                }

                /*
                        If user is not nobody and no password given then ask for one
                */
                if ( caseless_strcmp( username, User_Nobody ) != 0 &&
                     password == NULL &&
                     current_nameing_host != NULL )
                {
                        err = lightweight_printf( "Enter your password : " );
                        if ( !err )
                                err = askfor_password( &password );

                        if ( err )
                        {
                                free( username );
                                return err;
                        }
                }

                err = process_nfsname( username, password );

                free( username );
                free( password );

                return err;
        }
}

static _kernel_oserror *list_mountpoints_for_host
(
        char *hostname
)
{
        Chain_Link *link;
        char *last_hostname;
        MountPoint *mount_point;
        _kernel_oserror *err;

        /*
                Set link to point to the first element in the relevant list
                of mount points.
        */
        if ( hostname == NULL )
        {
                link = mount_point_list.forwards;
        }
        else
        {
                /*
                        Find the host with the given name
                */
                for ( link = host_list.forwards;
                      link->forwards != NULL &&
                          strcmp( ((Host *)Link_Wrapper( link ))->host_name, hostname ) != 0;
                      link = link->forwards )
                {
                        /* do nothing */
                }

                /*
                        Start along the list of mount points
                */
                if ( link->forwards != NULL )
                {
                        link = ((Host *)Link_Wrapper( link ))->mount_points.forwards;
                }
        }

        /*
                print column titles
        */
        err = lightweight_printf( Format_MountPoint_List, "Mount Name", "User", "Mount Path" );

        /*
                This is used to find out when the host changes and to print
                a line giving the new host
        */
        last_hostname = NULL;

        for ( ;
              !err &&
                  link->forwards;
              link = link->forwards )
        {
                mount_point = Link_Wrapper( link );

                /*
                        Check for the host changing. Note, a direct pointer to
                        the string comparison is appropriate here.
                */
                if ( mount_point->host->host_name != last_hostname )
                {
                        last_hostname = mount_point->host->host_name;
                        err = lightweight_printf( "Host: %0s\n", last_hostname );
                }

                if ( !err )
                        err = lightweight_printf( Format_MountPoint_List,
                                mount_point->mount_point_name,
                                mount_point->user->name,
                                mount_point->mount_path );
        }

        return err;
}

_kernel_oserror *nfs_mount_internal( char *mountname, char *mountpath, Host *host, UserSpecification *user)
{
        _kernel_oserror *err;
        MountPoint *new_mount_point;
        Chain_Link *link;
        union {
                void *res;
	        mountres3 *res3;
        	fhstatus *res1;
        } res;
        unused_client *mount_client;
        xdrproc_t freeproc;



        /*
                Find the mount point ge this in the list of all mount points.
        */
        for ( link = mount_point_list.forwards;
              link->forwards != NULL &&
                caseless_strcmp( ((MountPoint *)Link_Wrapper( link ))->mount_point_name, mountname ) < 0;
              link = link->forwards )
        {
                /* do nothing */
        }


        /*
                If eq return an error
        */
        if ( link->forwards != NULL &&
               caseless_strcmp( ((MountPoint *)Link_Wrapper( link ))->mount_point_name, mountname ) == 0 )
                return mb_duplicate_mount_point;

        new_mount_point = (MountPoint *)malloc( sizeof( MountPoint ));

        if ( new_mount_point == NULL )
                return mb_malloc_failed;

        new_mount_point->mount_point_name = malloc( strlen( mountname ) + 1 );

        if ( new_mount_point->mount_point_name == NULL )
        {
                free( new_mount_point );
                return mb_malloc_failed;
        }

        strcpy( new_mount_point->mount_point_name, mountname );

        new_mount_point->mount_path = malloc( strlen( mountpath ) + 1 );

        if ( new_mount_point->mount_path == NULL )
        {
                free( new_mount_point->mount_point_name );
                free( new_mount_point );

                return mb_malloc_failed;
        }

        strcpy( new_mount_point->mount_path, mountpath );

        new_mount_point->host = host;
        new_mount_point->user = user;
        new_mount_point->being_dismounted = No;


        err = get_mount_client_for_mp( &mount_client, new_mount_point );

        if ( err )
        {
                free( new_mount_point->mount_path );
                free( new_mount_point->mount_point_name );
                free( new_mount_point );

                return err;
        }

	if (mount_client->version == MOUNTVERS3) {
	        res.res3 = mountproc_mnt_3( &new_mount_point->mount_path, mount_client->client );
	        freeproc = xdr_mountres3;
	}
	else {
	        res.res1 = mountproc_mnt_1( &new_mount_point->mount_path, mount_client->client );
	        freeproc = xdr_fhstatus;
	}


        err = rpcmount_to_riscos_err( res.res, new_mount_point, mount_client->client );


        release_client( mount_client );

        if ( err )
        {
                free( new_mount_point->mount_path );
                free( new_mount_point->mount_point_name );
                free( new_mount_point );

                if (res.res) xdr_free(freeproc, res.res);

                return err;
        }

	if ( freeproc == xdr_mountres3 ) {
	        /* mount_client is "gone" */
	        fh3cpy_from_xdr(&new_mount_point->fhandle, (nfs_fh3 *)&res.res3->mountres3_u.mountinfo.fhandle);
	}
	else {
	        static nfs_fh3 fh3;
	        fh3cpy_from_fhandle(&fh3, (nfs_fh *) &res.res1->fhstatus_u.fhs_fhandle);
		fh3cpy_from_xdr(&new_mount_point->fhandle, &fh3);
	}
	xdr_free(freeproc, res.res);


        host->usage_count++;
        user->usage_count++;


        initialise_header( &new_mount_point->open_files );


        insert_before_link( &new_mount_point->all_mount_points_link, new_mount_point, link );

        /*
                Find the mount point ge this in the list of mount points
                on this host.
        */
        for ( link = current_mounting_host->mount_points.forwards;
              link->forwards != NULL &&
                caseless_strcmp( ((MountPoint *)Link_Wrapper( link ))->mount_point_name, mountname ) <= 0;
              link = link->forwards )
        {
                /* do nothing */
        }


        insert_before_link( &new_mount_point->mount_points_per_host_link, new_mount_point, link );

        /*
                Create two clients ready for use to allow CLI *copy to work
                Re-use mount_client variable here to save a variable.
        */
        if (!get_nfs_client_for_mp( &mount_client, new_mount_point ))
        {
                unused_client *client;
                if (!get_nfs_client_for_mp( &client, new_mount_point ))
                {
                        release_client( client );
                }
                release_client( mount_client );
        }

        /*
                Tell the world about the new mount
        */

        return _swix(OS_ServiceCall, _IN(1), Service_NFS);
}

/*
        All the parameters should be verified by here
*/
_kernel_oserror *nfs_mount( char *hostname, char *mountname, char *mountpath)
{
        _kernel_oserror *err;
        char *dirpath;



        /*
                Process the hostname into the current mounting host
        */
        err = new_host( &current_mounting_host, hostname );


        if ( !err &&
                current_mounting_host == NULL )
                err = mb_no_mounting_host;

        if ( err )
                return err;

        if ( current_user == NULL )
                return mb_no_user;

        /*
                Only mount if a mountpath is given, otherwise
                drop through to the directory setting bit.
        */
        if ( mountpath )
        {
                err = nfs_mount_internal( mountname, mountpath, current_mounting_host, current_user );
                if ( err )
                {
                        return err;
                }
        }

        if ( !find_mount( mountname ))
                return mb_no_mount_point_found;

        /*
                Set directories to the mount.
                Don't winge if one of these fails.
        */

        dirpath = malloc( strlen( mountname ) + sizeof ":.$" );
        if (dirpath)
        {
            sprintf( dirpath, ":%s.$", mountname );

            /* Set CSD */
            _swix(OS_FSControl, _INR(0,3)|_IN(6), 53, dirpath, 0, NFSFilingSystemName, 0);
            /* Leave PSD alone */

            /* Unset URD - will default to "$" */
            _swix(OS_FSControl, _INR(0,3)|_IN(6), 53, 0, 2, NFSFilingSystemName, 0);
            /* Unset Library - will default to "$.Library" */
            _swix(OS_FSControl, _INR(0,3)|_IN(6), 53, 0, 3, NFSFilingSystemName, 0);

            free(dirpath);
        }

        return NULL;
}

_kernel_oserror *command_nfsmount( char *arg_string, int argc)
{
        int *readargs_buffer;
        char *hostname;
        char *mountname;
        char *mountpath;
        _kernel_oserror *err;

        argc = argc;

        readargs_buffer = (int *)malloc( ReadArgsBufferLen * sizeof( *readargs_buffer ));

        if ( readargs_buffer == NULL )
                return mb_malloc_failed;

        err = _swix(OS_ReadArgs, _INR(0,3), "host=h/k/g,mountname/g,mountpath/g",
                                            arg_string, readargs_buffer,
                                            ReadArgsBufferLen);

        if ( err )
        {
                free( readargs_buffer );
                return err;
        }

        hostname = mountname = mountpath = NULL;

        err = readargs_getstring( &hostname, readargs_buffer, 0 );
        if ( !err )
                err = readargs_getstring( &mountname, readargs_buffer, 1 );
        if ( !err )
                err = readargs_getstring( &mountpath, readargs_buffer, 2 );
        free( readargs_buffer );

        if ( mountname == NULL &&
             mountpath != NULL )
        {
                err = mb_path_no_mount;
        }
        else if ( mountname == NULL &&
                  mountpath == NULL )
        {
                err = list_mountpoints_for_host( hostname );
        }
        else
        {
                if ( strchr( mountname, ' ' ) != NULL || strchr( mountname, ':' ) != NULL )
                        err = mb_no_spaces_in_mount_name;

                if ( !err )
                        err = nfs_mount( hostname, mountname, mountpath );
        }

        free( hostname );
        free( mountname );
        free( mountpath );

        return err;

}

/*
        Call FileSwitch to close the given file
*/
static _kernel_oserror *nfs_forceclose
(
        OpenFile *file
)
{
    int success;

    success=_kernel_osfind(0, (char *) file->fileswitch_handle);

    return success == _kernel_ERROR ? _kernel_last_oserror() : NULL;
}

/*
 * Check to see if one of NFS's special directories is on a given mount.
 * If it is, then unset it. The possible directory values are
 *    0 - @@, 1 - \, 2 - &, 3 - %
 */
static void void_directory_if_on_mount(const char *mount, int directory)
{
    char *buffer, *p;
    int size;
    _kernel_oserror *e;

    e=_swix(OS_FSControl, _INR(0,3)|_IN(5)|_OUT(5), 54, 0, directory, NFSFilingSystemName, 0, &size);

    if (e || size==0)
    	return;

    buffer=(char *)malloc(-size);
    if (buffer==NULL)
    	return;

    /* Read the canonical path name of the given directory, eg
               ":Home.$.Library"
     */
    e=_swix(OS_FSControl, _INR(0,3)|_IN(5), 54, buffer, directory, NFSFilingSystemName, -size);

    if (e)
    {
        free(buffer);
    	return;
    }

    /* Find the . after the mount name */
    p=strchr(buffer, '.');

    if (!p)
    {
        free(buffer);
    	return;
    }

    *p='\0';

    /* Compare the mount name with our argument - if it matches then unset
       that directory.
     */
    if (caseless_strcmp(mount, buffer+1) == 0)
        _swix(OS_FSControl, _INR(0,3)|_IN(6), 53, 0, directory, NFSFilingSystemName, 0);

    free(buffer);
}

/*
        Close all files on the given mount and remove it from the mount
        chain.
*/
_kernel_oserror *nfs_dismount
(
        MountPoint *mount
)
{
        _kernel_oserror *err = NULL;
        _kernel_oserror *error_to_return = NULL;
        OpenFile *lastfile;
        FSEntry_Close_Parameter closeparm;
        unused_client *mount_client;
        void *(*umnt_fn)(dirpath *, CLIENT *);
        char *DiscName;

        /*
                If dismount called as a result of a dismount, do nothing
                at this level and let the top level dismount handle it.
                This occurs if a dismount of a spool mount is done - the
                top level dismount closes all files, thus causing the spool
                mount to be dismounted.
        */
        if ( mount->being_dismounted == Yes )
                return NULL;
        mount->being_dismounted = Yes;

        /*
                If FileSwitch failed to cause this file to close, then
                call FSEntry_Close ourselves. These parameters are set
                to 0 to indicate no change.

                THIS SHOULD ONLY BE NEEDED IN DIRE EMERGENCIES.
        */
        closeparm.info.load_exec.load_address = 0;
        closeparm.info.load_exec.execute_address = 0;

        while ( mount->open_files.forwards->forwards )
        {
                /*
                        Hold lastfile just in case FileSwitch botches is
                */
                lastfile = Link_Wrapper( mount->open_files.forwards );

                err = nfs_forceclose( lastfile );

                /*
                        Check that FileSwitch got it right
                */
                if ( lastfile == Link_Wrapper( mount->open_files.forwards ) )
                {
                        /*
                                FileSwitch botched it, so do it ourselves.
                                Errors at this stage are ignored.
                        */
                        closeparm.handle = (int)lastfile;
                        fsentry_close( &closeparm );
                }

                /*
                        Only return the first error
                */
                if ( err && !error_to_return )
                        error_to_return = err;
        }

        /*
                Void all the directories:
                @@, \, & and %
                Void the current mount point (used for nfs:$.)
        */
        void_directory_if_on_mount(mount->mount_point_name, 0);
        void_directory_if_on_mount(mount->mount_point_name, 1);
        void_directory_if_on_mount(mount->mount_point_name, 2);
        void_directory_if_on_mount(mount->mount_point_name, 3);


        err = get_mount_client_for_mp( &mount_client, mount );
        if ( err && !error_to_return )
                error_to_return = err;

	umnt_fn = mount_client->version == MOUNTVERS3 ? mountproc_umnt_3 : mountproc_umnt_1;

        err = rpcmount_to_riscos_err( umnt_fn ( &mount->mount_path, mount_client->client ), mount, mount_client->client );
        release_client( mount_client );

        if ( err && !error_to_return )
                error_to_return = err;

        cancel_all_caches_by_mount_point( mount );

        /* Make a note of the disc name for issuing the service call later */
        DiscName=(char *)malloc(strlen(mount->mount_point_name)+
                                sizeof (NFSFilingSystemName "::")+1);
        if (DiscName)
            sprintf(DiscName, NFSFilingSystemName "::%s", mount->mount_point_name);

        free( mount->mount_point_name );
        free( mount->mount_path );
        remove_link( &mount->all_mount_points_link );
        remove_link( &mount->mount_points_per_host_link );

        err = release_host( mount->host );
        if ( err && !error_to_return )
                error_to_return = err;

        err = release_user( mount->user );
        if ( err && !error_to_return )
                error_to_return = err;

        free( mount );

        /*
                Tell everybody about the dismount
        */
        err = _swix(OS_ServiceCall, _IN(1), Service_NFS);
        if ( err && !error_to_return )
                error_to_return = err;

        if (DiscName)
        {
            err = _swix(OS_ServiceCall, _INR(1,2), Service_DiscDismounted, DiscName);
            if ( err && !error_to_return )
                error_to_return = err;
            free(DiscName);
        }

        return error_to_return;
}

_kernel_oserror *nfs_dismount_host
(
        Host *host
)
{
        _kernel_oserror *err;
        _kernel_oserror *error_to_return = NULL;

        while( host->mount_points.forwards->forwards )
        {
                err = nfs_dismount( Link_Wrapper( host->mount_points.forwards ));
                if ( err && !error_to_return )
                        error_to_return = err;
        }

        return error_to_return;
}

_kernel_oserror *nfs_dismount_all
(
        void
)
{
        _kernel_oserror *err;
        _kernel_oserror *error_to_return = NULL;

        while( mount_point_list.forwards->forwards )
        {
                err = nfs_dismount( Link_Wrapper( mount_point_list.forwards ));
                if ( err && !error_to_return )
                        error_to_return = err;
        }

        return error_to_return;
}

_kernel_oserror *command_nfsdismount
(
        char *arg_string,
        int argc
)
{
        int *readargs_buffer;
        _kernel_oserror *err;
        YesNoAnswer is_host;
        char *objname;
        Chain_Link *link;
        MountPoint *mp;

        argc = argc;

        readargs_buffer = (int *)malloc( ReadArgsBufferLen * sizeof( *readargs_buffer ));

        if ( readargs_buffer == NULL )
                return mb_malloc_failed;

        err = _swix(OS_ReadArgs, _INR(0,3), "host=/s,/g", arg_string,
                                            readargs_buffer, ReadArgsBufferLen );

        if ( err )
        {
                free( readargs_buffer );
                return err;
        }

        objname = NULL;

        is_host = readargs_buffer[0] != 0;

        err = readargs_getstring( &objname, readargs_buffer, 1 );

        free( readargs_buffer );

        if ( !err )
        {
                if ( is_host )
                {
                        for ( link = host_list.forwards;
                                link->forwards != NULL &&
                                        strcmp( ((Host *)Link_Wrapper( link ))->host_name, objname ) != 0;
                                link = link->forwards )
                        {
                                /* do nothing */
                        }

                        if ( link->forwards )
                        {
                                err = nfs_dismount_host( Link_Wrapper( link ));
                        }
                        else
                        {
                                err = mb_no_host_found;
                        }
                }
                else if ( objname )
                {
                        /*
                                Not a host, so must be a mount point
                        */

                        mp = find_mount( objname );

                        if ( mp )
                        {
                                err = nfs_dismount( mp );
                        }
                        else
                        {
                                err = mb_no_mount_point_found;
                        }
                }
                else
                {
                        /*
                                Nothing specified, dismount the whole lot
                        */

                        err = nfs_dismount_all();
                }
        } /* endif readargs etc worked */

        if ( objname )
                free( objname );

        return err;
}

_kernel_oserror *command_nfsinfo
(
        char *arg_string,
        int argc
)
{
        Chain_Link *link;
        Host *host;
        UserSpecification *user;
        _kernel_oserror *err = NULL;

        arg_string = arg_string;
        argc = argc;

        err = lightweight_printf( "Host list:\n" );
        for ( link = host_list.forwards;
                !err && link->forwards != NULL;
                link = link->forwards )
        {
                host = Link_Wrapper( link );
                err = lightweight_printf( "name=<%0s>, usage = %1d, NFS version = %2d\n", host->host_name, host->usage_count, host->nfs_version );
        }

        if ( !err )
                err = lightweight_printf( "\nCache hits %0d; Cache misses %1d\n", cache_hits, cache_misses);

        if ( !err && cache_hits+cache_misses > 0)
        {
            /* Do this fixed point, for simplicity */
            int percent;

            percent=(cache_hits*1000)/(cache_hits+cache_misses);
            err = lightweight_printf("Cache hit rate %0d.%1d%%\n", percent / 10, percent % 10);
        }

#ifdef NETACCESSCOUNT
        if ( !err )
                err = lightweight_printf( "\nTotal network accesses %0d\n", NetAccessCountG);

#endif

        if ( !err )
                err = lightweight_printf( "\nUser list:\n" );
        for ( link = user_list.forwards;
                !err && link->forwards != NULL;
                link = link->forwards )
        {
                user = Link_Wrapper( link );
                err = lightweight_printf( "name=<%0s>, uid=<%1d>, group=<%5s>, gid=<%2d>, default umask=<%4o> usage = %3d\n",
                        user->name, user->uid, user->gid, user->usage_count, user->umask & 0777, user->gnames[0].name );
                if (!err && user->len > 0)
                {
                        int i;
                        lightweight_printf("  groups:");
                        for (i = 0; i < user->len; ++i)
                        {
                                if (i)
                                        lightweight_printf( "," );

                                if (user->gnames[i+1].name[0])
                                {
                                        lightweight_printf( " %1s <%0d>", user->gids[i], user->gnames[i+1].name );
                                }
                                else
                                {
                                        lightweight_printf( " <%0d>", user->gids[i] );
                                }
                        }
                        lightweight_printf("\n");
                }
        }

        return err;
}

static _kernel_oserror *pr_justified
(
        char *string,
        int width
)
{
        _kernel_oserror *err = NULL;
        int slen = strlen( string );

        while ( !err && slen < width )
        {
                err = lightweight_printf( " " );
                slen++;
        }

        if ( !err )
                lightweight_printf( "%0s", string );

        return err;
}

static _kernel_oserror *convertswi(int swinum, long num, char *buffer, int len)
{
        return _swix(swinum, _INR(0,2), num, buffer, len);
}


#define ConvBufSize 20

static _kernel_oserror *prtime(long time)
{
        _kernel_oserror *err;
        int i;
        char buf[ConvBufSize];
        static struct {
                int c_secs;             /* conversion units in secs */
                char * c_str;           /* unit string */
        } cunits [] = {
                {60*60*24*28, "months"},
                {60*60*24*7, "weeks"},
                {60*60*24, "days"},
                {60*60, "hours"},
                {60, "mins"},
                {1, "secs"}
        };

        if (time <= 0) {
                return lightweight_printf("EXPIRED\n");
        }
        for (i = 0; i < sizeof(cunits)/sizeof(cunits[0]); i++) {
                if (time >= cunits[i].c_secs)
                        break;
        }
        err = convertswi( OS_ConvertSpacedInteger4, time/cunits[i].c_secs, buf, sizeof( buf ));
        if (!err)
                err = lightweight_printf(buf);
        if (!err)
                err = lightweight_printf(" %0s", cunits[i].c_str);
        return err;
}

#define kb(b) ((b)/1024)

static _kernel_oserror *warn( utils_spacestr *space, char *mount_name )
{
        _kernel_oserror *err;
        utils_quotastr *squota = &space->sp.quota.space,
                       *fquota = &space->sp.quota.files;
        if (squota->hlim &&
             squota->usage >= squota->hlim)
        {
                err = lightweight_printf(
"Block limit reached on %0s\n",
                      mount_name );
                if (err) return err;
        }
        else if (squota->slim &&
             squota->usage >= squota->slim)
        {
                err = lightweight_printf(
"Over disk quota on %0s, remove %1dK",
                      mount_name,
                      kb(squota->usage - squota->slim + 1 ) );
                if (err) return err;
                if (squota->timeleft > 0)
                {
                        err = lightweight_printf(" within ");
                        if (err) return err;
                        err = prtime(squota->timeleft);
                        if (err) return err;
                }
                err = lightweight_printf("\n");
                if (err) return err;
        }

        if (fquota->hlim &&
            fquota->usage >= fquota->hlim)
        {
                err = lightweight_printf(
"File count limit reached on %0s\n",
                      mount_name );
                if (err) return err;
        }
        else if (fquota->slim &&
            fquota->usage >= fquota->slim)
        {
                err = lightweight_printf(
"Over file quota on %0s, remove %1d file%2s",
                       mount_name,
                       fquota->usage - fquota->slim + 1,
                       ((fquota->usage - fquota->slim + 1) > 1 ? "s" : "" ) );
                if (err) return err;
                if (fquota->timeleft > 0)
                {
                        err = lightweight_printf(" within ");
                        if (err) return err;
                        err = prtime(fquota->timeleft);
                        if (err) return err;
                }
                err = lightweight_printf("\n");
                if (err) return err;
        }
        return NULL;
}


_kernel_oserror *command_free
(
        char *arg_string,
        int argc
)
{
        _kernel_oserror *err;
        utils_spacestr space;
        char user_free_buf[ConvBufSize];
        char usage_buf[ConvBufSize];
        char quota_buf[ConvBufSize];
        char limit_buf[ConvBufSize];
        char *buffer=NULL;
        utils_quotastr *squota = &space.sp.quota.space,   /* space quota struct */
                       *fquota = &space.sp.quota.files;   /* files quota struct */
        int maxwid = 0;

        if ( argc == 0 )
        {
            int bufsize;
            char *pc, *pd;

            /* Need to get CSD off FileSwitch */

            _swix(OS_FSControl, _INR(0,3)|_IN(5)|_OUT(5),
                                54, NULL, 0, NFSFilingSystemName, 0, &bufsize);

            if ( bufsize == 0 )
                return mb_no_current_mount_point;

            buffer=(char *)malloc(-bufsize);
            _swix(OS_FSControl, _INR(0,3)|_IN(5),
                                54, buffer, 0, NFSFilingSystemName, -bufsize);

            pc=strchr(buffer, ':');
            pd=NULL;
            if (pc!=NULL) pd=strchr(pc, '.');
            if (pc==NULL || pd==NULL)
            {
                free(buffer);
                return mb_no_current_mount_point;
            }
            *pd='\0';
            arg_string = pc+1;
        }
        else
        {
                space_reduce( arg_string );
        }

        err = utils_getfsspace( &space, arg_string );

        if (space.active_quota)
        {
                u_long free = (squota->slim > squota->usage) ? squota->slim - squota->usage : 0;
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, (free), user_free_buf, sizeof( user_free_buf ));
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, (squota->usage), usage_buf, sizeof( usage_buf ));
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, (squota->slim), quota_buf, sizeof( quota_buf ));
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, (squota->hlim), limit_buf, sizeof( limit_buf ));
                strcat(user_free_buf, "K");
                strcat(usage_buf, "K");
                strcat(quota_buf, "K");
                strcat(limit_buf, "K");
        }
        else
        {
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, space.sp.statfs.bfree, user_free_buf, sizeof( user_free_buf ));
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, space.sp.statfs.bavail, quota_buf, sizeof( quota_buf ));
                usage_buf[0] = '\0';
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, space.sp.statfs.blocks, limit_buf, sizeof( limit_buf ));
                strcat(user_free_buf, (space.sp.statfs.bsize == 1024) ? "K" : " blocks");
                strcat(quota_buf, (space.sp.statfs.bsize == 1024) ? "K" : " blocks");
                strcat(limit_buf, (space.sp.statfs.bsize == 1024) ? "K" : " blocks");
        }

        if ( !err )
        {
                if ( strlen( user_free_buf ) > maxwid )
                        maxwid = strlen( user_free_buf );
                if ( strlen( usage_buf ) > maxwid )
                        maxwid = strlen( usage_buf );
                if ( strlen( quota_buf ) > maxwid )
                        maxwid = strlen( quota_buf );
                if ( strlen( limit_buf ) > maxwid )
                        maxwid = strlen( limit_buf );
        }
        if ( space.active_quota )
        {
                if ( !err )
                        err = lightweight_printf( "Bytes free   " );
                if ( !err )
                        err = pr_justified( user_free_buf, maxwid );
                if ( !err )
                        err = lightweight_printf( "\nBytes used   " );
                if ( !err )
                        err = pr_justified( usage_buf, maxwid );
                if ( !err )
                        err = lightweight_printf( "\nBytes quota  " );
                if ( !err )
                        err = pr_justified( quota_buf, maxwid );
                if ( !err )
                        err = lightweight_printf( "\nBytes limit  " );
                if ( !err )
                        err = pr_justified( limit_buf, maxwid );
        }
        else  /* no quota; print out statfs info */
        {
                if ( !err )
                        err = lightweight_printf( "No quota on %0s\n", arg_string);
                if ( !err )
                        err = lightweight_printf( "Space on filing system:\nFree      " );
                if ( !err )
                        err = pr_justified( user_free_buf, maxwid );
                if ( !err )
                        err = lightweight_printf( "\nAvailable " );
                if ( !err )
                        err = pr_justified( quota_buf, maxwid );
                if ( !err )
                        err = lightweight_printf( "\nSize      " );
                if ( !err )
                        err = pr_justified( limit_buf, maxwid );
        }

        if ( !err )
                err = lightweight_printf( "\n" );

        if ( !err && space.active_quota
           && ( ( (squota->slim > 0) && (squota->usage > squota->slim) )
             || ( (fquota->slim > 0) && (fquota->usage > fquota->slim) ) ) )
        {
                err = warn( &space, arg_string );
        }

        free(buffer);

        return err;
}

_kernel_oserror *command_cachetime( char *arg_string, int argc)
{
        if (argc == 0)
            printf("The current cache expiry time is %d.%02d seconds.\n", out_of_date_time / 100, out_of_date_time % 100);
        else
            out_of_date_time = atoi(arg_string);

        return NULL;
}


static char *Commands_set_varname(char varbuf[20], int count)
{
        (void) strcpy(varbuf, "Inet$BootServer");
        if (count > 1) {
                sprintf(strchr(varbuf, '\0'), "%d", count);
        }
        return varbuf;
}

_kernel_oserror *nfs_boot(void)
{
        int first, nsecs, flags;
        int lasttime, curtime, elapsedtime, firsttime;
        char server_adr[32], mount_path[64], bootserver_varname[20];
        _kernel_oserror *err, *mnterr;
        int server_count, looped;
        unsigned int badservers = (-1U) & ~1; /* When this gets to zero, all servers have returned hard errors */

        err = _kernel_getenv(Commands_set_varname(bootserver_varname, 0), server_adr, sizeof server_adr);
        if ( err )
            return ( err );

        err = _kernel_getenv("Inet$MountPath", mount_path, sizeof mount_path);
        if (err || mount_path[0]=='\0')
        {
          err = _kernel_getenv("Inet$BootFile", mount_path, sizeof mount_path);
          if (err || mount_path[0]=='\0') strcpy(mount_path, "/nfsboot");
        }

#ifdef SILENTBOOT
#else
        lightweight_printf("Trying to mount %0s on server %1s\n", mount_path, server_adr);
#endif
        first = 1;
        nsecs = 0;
        looped = 0;
        server_count = 1;
        lasttime = time(0);
        firsttime = lasttime + 30;
        do
        {
                _swix(OS_ReadEscapeState, _OUT(_FLAGS), &flags);
                if (flags & _C)
                {
                    _kernel_osbyte(OSByte_CancelEscape, 0, 0);
                    return mb_escape;
                }
                mnterr = err = nfs_mount( server_adr, "NFSBoot", mount_path );
                if (!err)
                       break;
                usermode_donothing();
                curtime = time(0);
                elapsedtime = curtime - lasttime;
                if (err == mb_nfserr_noent || err == mb_nfserr_acces)
                       badservers &= ~(1<<server_count);
                else if (elapsedtime < 5)
                       continue;
                nsecs += elapsedtime;
                ++server_count;
                err = _kernel_getenv(Commands_set_varname(bootserver_varname, server_count), server_adr, sizeof server_adr);
                if ( err ) {
                        badservers &= ((1<<server_count)-1);
                        server_count = 1;
                        err = _kernel_getenv(Commands_set_varname(bootserver_varname, server_count), server_adr, sizeof server_adr);
                        if ( err )
                                return ( err );
                }
                if (first && server_count == 1)
                {
#ifdef SILENTBOOT
#else
                        lightweight_printf("Waiting for response from a boot server\n");
#endif
                        first = 0;
                }
                else if (first)
                {
#ifdef SILENTBOOT
#else
                        lightweight_printf("Trying to mount %0s on server %1s\n", mount_path, server_adr);
#endif
                }
                else
                {
#ifdef SILENTBOOT
#else
                        lightweight_printf("Elapsed time: %0d seconds\r", nsecs);
#endif
                }
                lasttime = time(0);
        } while ((time(0) < firsttime) && badservers != 0);

        if ( mnterr )
                return ( mnterr );

        /* Set current directory */
        err=_swix(OS_FSControl, _INR(0,1), 0, NFSFilingSystemName "::NFSBoot.$");

        if (!err)
        {
            int success=_kernel_oscli("/" NFSFilingSystemName "::NFSBoot.$.!NFSBoot");
            if (success == _kernel_ERROR)
                err=_kernel_last_oserror();
        }

        return err;
}


_kernel_oserror *command_timeout( char *arg_string, int argc)
{
int now;

	if ( argc == 0) /* no params ...  */
		{
		lightweight_printf("The current timeout is %0d seconds.\n", TIMEOUT.tv_sec);
		lightweight_printf("The current retry time is %0d seconds.\n", TIMERETRY.tv_sec);
		}
	else if (argc == 1) /* timeout value only */
		{
	        now = atoi( arg_string );
	        TIMEOUT.tv_sec = now;
		}
	else { /* timeout and retry values */
	        now = atoi( arg_string );
	        TIMEOUT.tv_sec = now;
	        while(*arg_string != 0x20) {
	          if(*arg_string < 0x20) return NULL;
	          arg_string++;
	        }
	        now = atoi( arg_string );
	        TIMERETRY.tv_sec = now;
	}
        return NULL;
}


_kernel_oserror *command_cachesize( char *arg_string, int argc)
{
    int size;

    if (argc == 1) /* want to set size  */
    {
	size = atoi(arg_string);
	if (size == 0)
	    return mb_nfs_cache_size_zero;
	else
	    set_cache_size (size);
    }
    else	/* ie want to know size  */
    {
        lightweight_printf("The current cache size is %0d entries.\n", get_cache_size());
    }

    return (NULL);
}


#ifdef PACKETSIZE_COMMAND

_kernel_oserror *command_packetsize( char *arg_string, int argc )
{
	int size;

	if (argc == 1) /* want to set size */
	{
		size = atoi(arg_string);
		if ((size < 1) || (size > 8))
			return mb_nfserr_BadParameters;
		else
			NFS_MAXDATA = size * 1024;
	}
	else /* want to know size */
	{
		lightweight_printf("The current NFS packet size is %0d bytes.\n", NFS_MAXDATA);
	}

	return (NULL);
}

#endif
@


4.13
log
@Store lxa files verbatim, without appendum
Files saved with load & exec address (as opposed to a filetype and the top nybble of load set to 0xFFF) would be extended by 8 bytes in order to hide the true load/exec for later retrieval.
While useful if only ever saving and retrieving from the RISC OS viewpoint, it would create apparently corrupt or overlong file if you wanted to do any analysis on the NFS server end. Given load/exec addresses are deprecated, change NFS to behave like LanManFS and just denote ",lxa" suffixed files with the appropriate icon in the Filer and a made up load/exec address.

pathmunge.c/_GBPB.c/V2support.c/_Args.c/_File.c/PutBytesX.c/Static.c/Changeinfo.c: Switch out 8 byte appending code. Give the file a proper date stamp instead when viewed on Unix.
_Open.c: Switch out the 8 byte appendum stuff, and use a common OS_Word 14 clock function.
Statics.h/Modulewrap.c: Compute a substitute load/exec using the same algorithm as LanManFS (the Kernel's address rounded down to 1MB). Use cmhg finalise function instead of atexit().

Also
MakeFile: pass in predefine DEBUG for debug builds.
cmhg/NFSHdr: remove *Histogram debug command except when debugging. Add finalise handler.
Commands.c/Commands.h: remove *Histogram debug command except when debugging.
Utils.c: delete unused long long support functions. Add a new time getting support function.
Utils.h: new time getting support function.

Tested with a handful of area saves using *Save, checking the file size when viewed at the server end was correct not 8 bytes longer.

Version 3.25. Tagged as 'NFS-3_25'
@
text
@d1356 2
a1357 1
            pd=strchr(pc, '.');
@


4.12
log
@Export our own SWIs as a header
Use the shared makefiles to export Interface/NFS.h and Hdr:NFS.
Remove local copy NFS.h which confuses the dependency checking, now called nfsheaders.h instead.
Delete unused UID/GID pair.
Tested on a mount from FreeBSD 11.1-RELEASE-p4.

Version 3.23. Tagged as 'NFS-3_23'
@
text
@a1611 5
_kernel_oserror *command_histogram( void )
{
    show_histogram();
    return NULL;
}
@


4.11
log
@  Minor change to *NFSBoot command
Detail:
  Existing behaviour is to fall-back to "/nfsboot" if the system variable
  "Inet$MountPath" isn't set. However, if you DHCPExecute to get your boot
  details, the mount path will be in "Inet$BootFile"; it is IPConfig which
  is supposed to set "Inet$MountPath".

  Anyway, *NFSBoot will first check "Inet$MountPath" and fall-back to
  "Inet$BootFile" if not set *then* fall-back to "/nfsboot" if both are
  unset.
Admin:
  To be tested in DB220 ROM build.

Version 3.20. Tagged as 'NFS-3_20'
@
text
@d31 1
a31 1
#include "NFS.h"
d35 1
a35 1
#include "callbacks.h"
@


4.10
log
@Merged in branch sbrodie_NFS_dev.
Also added -c90 to CFLAGS so that it will build with recent compilers.
Warning: provokes compiler bugs in many recent compilers!

Version 3.19. Tagged as 'NFS-3_19'
@
text
@d1500 4
a1503 1
            strcpy(mount_path, "/nfsboot");
@


4.9
log
@  Boot server failure detection improved.
Detail:
  If, when attempting to boot, the NFS module receives specific errors
    back (Insufficient access or Does not exist), it marks that server
    as not to be retried in future loops around Inet$BootServer* hosts.
Admin:
  Tested on desktop machine.

Version 3.17. Tagged as 'NFS-3_17'
@
text
@d1374 1
a1374 1
                long free = (squota->slim > squota->usage) ? squota->slim - squota->usage : 0;
d1376 1
a1376 1
                        err = convertswi( OS_ConvertSpacedCardinal4, kb(free), user_free_buf, sizeof( user_free_buf ));
d1378 1
a1378 1
                        err = convertswi( OS_ConvertSpacedCardinal4, kb(squota->usage), usage_buf, sizeof( usage_buf ));
d1380 1
a1380 1
                        err = convertswi( OS_ConvertSpacedCardinal4, kb(squota->slim), quota_buf, sizeof( quota_buf ));
d1382 1
a1382 1
                        err = convertswi( OS_ConvertSpacedCardinal4, kb(squota->hlim), limit_buf, sizeof( limit_buf ));
d1609 5
@


4.9.2.1
log
@  Added new SWI NFS_FreeSpace64
Detail:
  This SWI provides 64-bit free space information to external users.
    It's SWI number is &41506.  It's register usage is identical to
    that of the Free module's reason code 4 (PRM 5a-257)
  If NFS$NoQuotas is set, you will always be shown the disc parameters in
    preference to the quota information.
Admin:
  Desktop builds require Free 0.37 or later to use this new SWI.
  Tested with softloaded Free and NFS - it reports sol's /export/home
    statistics correctly.


Version 3.18, 4.22.2.3. Tagged as 'NFS-3_18-4_22_2_3'
@
text
@d1374 1
a1374 1
                u_long free = (squota->slim > squota->usage) ? squota->slim - squota->usage : 0;
d1376 1
a1376 1
                        err = convertswi( OS_ConvertSpacedCardinal4, (free), user_free_buf, sizeof( user_free_buf ));
d1378 1
a1378 1
                        err = convertswi( OS_ConvertSpacedCardinal4, (squota->usage), usage_buf, sizeof( usage_buf ));
d1380 1
a1380 1
                        err = convertswi( OS_ConvertSpacedCardinal4, (squota->slim), quota_buf, sizeof( quota_buf ));
d1382 1
a1382 1
                        err = convertswi( OS_ConvertSpacedCardinal4, (squota->hlim), limit_buf, sizeof( limit_buf ));
@


4.9.2.2
log
@  *Histogram filesystem command added to dump out the cache histograms.
Detail:
  Works - shows the distribution of the cache entries in the hash table.
Admin:
  Builds.


Version 3.18, 4.22.2.4. Tagged as 'NFS-3_18-4_22_2_4'
@
text
@a1608 5
_kernel_oserror *command_histogram( void )
{
    show_histogram();
    return NULL;
}
@


4.8
log
@  During booting, callbacks are allowed to go off.
  Overall timeout of 30 seconds implemented on boot tries.
Detail:
  If the Internet module has been given completely duff configuration
    information in the STB-400 Engineering Menu, then the Internet
    module never gets to send data on the network and callbacks are
    not triggered.  The NFS module now triggers callbacks to enable
    the splash screen to occur.
  The NFS module now has a 30-second timeout on boot attempts.
Admin:
  Compiled.

Version 3.15. Tagged as 'NFS-3_15'
@
text
@d1492 1
d1526 3
a1528 1
                if (elapsedtime < 5)
d1534 1
d1563 1
a1563 1
        } while (time(0) < firsttime);
@


4.7
log
@  Pre-allocated 2 NFS clients to avoid critical memory failures.
  Added SILENTBOOT build option.
Detail:
  Pass OPTIONS=-DSILENTBOOT from the build system to compile out the
    echoing of the various state messages during a boot operation.
  Pre-allocate two NFS clients and then free them immediately (so they
    are cached) when a new mount is made.  This means that the client
    memory will be available for use during a command-line *Copy op
    where pre-Ursula OSes will claim all free memory for buffers.
    A better solution is to use Ursula on the build machines rather
    than spending time fixing problems caused by ancient versions of
    FileSwitch that have been fixed for years.
Admin:
  Fixes bug #1482
  Fixes *Copy on the build machines on pre-Ursula OSes.

Version 3.12. Tagged as 'NFS-3_12'
@
text
@d35 1
d1488 1
a1488 1
        int lasttime, curtime, elapsedtime;
d1490 1
a1490 1
        _kernel_oserror *err;
d1510 1
d1519 1
a1519 1
                err = nfs_mount( server_adr, "NFSBoot", mount_path );
d1522 1
d1559 4
a1562 1
        } while (1);
@


4.6
log
@  Access permission code overhaul.
  Supplementary group code improved.
Detail:
  *NFSInfo now shows the group names as well as the group IDs for
    both your primary and supplementary GIDs.
  access.c now uses the supplementary GIDs to help determine whether
    or not you are allowed to read/write a file.
  access.c now provides the NFS->RISC OS attribute mapping - "Owner"
    attributes being UNIX's user/group access; "Public" being the
    UNIX other access.
  The end result of these changes should be that your access rights to
    any object on the NFS server should match those you would expect
    from a UNIX shell logged in with the same ACLs as those you get
    via PCNFS.
Admin:
  Tested on Risc PC.

Version 3.09. Tagged as 'NFS-3_09'
@
text
@d647 14
d1500 2
d1503 1
d1535 2
d1538 1
d1543 2
d1546 1
d1550 2
d1553 1
@


4.5
log
@  Now uses PCNFS version 2 to authenticate.
Detail:
  Group-writable directories should now be writable to.
  setgid directories should cause created objects to take on
    the directory group ownership instead of the user's primary
    GIF
  *NFSInfo output enhanced to list all the additional group IDs
    and the default umask being applied to each authentication.
Admin:
  Tested on normal home mount and on TWC mount.

Version 3.05. Tagged as 'NFS-3_05'
@
text
@d228 1
a228 1
        return new_user( &current_user, username, current_nameing_host, (int)ares->uid, (int)ares->gid, authorisation,
d230 70
d1153 2
a1154 2
                err = lightweight_printf( "name=<%0s>, uid=<%1d>, gid=<%2d>, default umask=<%4o> usage = %3d\n",
                        user->name, user->uid, user->gid, user->usage_count, user->umask & 0777 );
d1161 11
a1171 1
                                lightweight_printf(" <%0d>", user->gids[i]);
@


4.4
log
@  Now supports NFS version 3.
Detail:
  All client-server calls now use the superior NFS3 protocol.
  This particularly benefits directory enumeration and *NFSInfo
    is now reporting 80%+ cache hit rates which is a significant
    improvement (over 5% better - some hosts report 85%+)
  Hashing algorithms improved to increase cache hits (the cache
    algorithm doesn't use parts of names after a comma, so that
    the hash value for !Run is the same as the hash value for
    !Run,feb - which helps the cache hit rate a lot).   Directory
    browsing on the desktop appears noticably faster too.
  The module now has the original protocol (.x) files defining
    the RPC protocols being used (NFS, mount, pcnfs, rquota)
    and uses them to generate header files, XDR implementations,
    and client stubs automatically, instead of having hand
    written versions.
  NFS workspace comes from a dynamic area where possible.
Admin:
  Supporting documentation:
    Acorn NFS Software Functional Specification (1215,250/FS)
    RFC1014, RFC1057, RFC1094, RFC1813
  Tested in several desktop machines for everyday use against
    both NFS2 and NFS3 servers.
  Requires rpcgen 0.01 or later
    (CVS source: Tools/Sources/rpcgen  tag: rpcgen-0_01 or later)
    (CVS binary: RiscOS/Library  tag: Library-0_19 or later)
  Requires TCPIPLibs 5.13 or later
    (CVS: RiscOS/Sources/Lib/TCPIPLibs  tag: TCPIPLibs-5_13)

Version 3.00. Tagged as 'NFS-3_00'
@
text
@d96 2
a97 2
        auth_args aargs;
        auth_results *ares;
d101 1
d103 1
d116 4
a119 1
                        authunix_create_default() );
d139 3
a141 1
        err = get_pcnfsd_client_for_host( &pcnfsd_client, current_nameing_host );
d145 4
d151 1
d153 25
a177 1
        ares = pcnfsd_auth_1( &aargs, pcnfsd_client->client );
d186 2
d215 10
a224 1
        release_client( pcnfsd_client );
d226 1
a226 5
        gethostname(machname, MAX_MACHINE_NAME);
        machname[MAX_MACHINE_NAME] = 0;
        len = getgroups( NGRPS, gids );

        authorisation = authunix_create( machname, ares->uid, ares->gid, len, (gid_t *) gids );
d228 2
a229 1
        return new_user( &current_user, username, current_nameing_host, (int)ares->uid, (int)ares->gid, authorisation );
d1083 12
a1094 1
                err = lightweight_printf( "name=<%0s>, uid=<%1d>, gid=<%2d>, usage = %3d\n", user->name, user->uid, user->gid, user->usage_count );
@


4.3
log
@  Fix to free space finding routines.
  Build improvements.
Detail:
  Added missing parameter on call to xdr_string in rquota.c!  Fixes the free space
    display bug previously blamed on the compiler misbuilding rpclib.
  Added macro defining that missing parameter (value imported from Solaris NFS headers)
  Added some casts to get around type mismatches which it previously got away with
    due to the lack of proper rpclib prototypes.
  Cured some of the compile warnings.  (Unnecessary & on array name).
  Removed the large chunks of stdlib.h and stdio.h found in various places throughout
    the source.  Replaced with the appropriate #include statements instead.
Admin:
  Building this requires TCPIPLibs-5_04 (RiscOS/Sources/Lib/TCPIPLibs)
  RAM build built and tested: specifically basic functionality like mounting and file
    transfers and then previously broken things like free space displays.

Version 2.36. Tagged as 'NFS-2_36'
@
text
@d138 2
a139 2
        aargs.aa_ident = encryptstring( username );
        aargs.aa_password = encryptstring( password );
d143 2
a144 2
        free( aargs.aa_ident );
        free( aargs.aa_password );
d150 1
a150 1
                switch( ares->ar_stat )
d183 1
a183 1
        authorisation = authunix_create( machname, ares->ar_uid, ares->ar_gid, len, (gid_t *) gids );
d185 1
a185 1
        return new_user( &current_user, username, current_nameing_host, (int)ares->ar_uid, (int)ares->ar_gid, authorisation );
d398 5
a402 1
        fhstatus *res;
d404 1
a458 1

d470 8
a477 2

        res = mountproc_mnt_1( &new_mount_point->mount_path, mount_client->client );
d480 1
a480 1
        err = rpcmount_to_riscos_err( res, new_mount_point, mount_client->client );
d491 2
d496 12
a507 1
        new_mount_point->fhandle = *(nfs_fh *)(res->fhstatus_u.fhs_fhandle);
d747 1
d815 3
a817 1
        err = rpcmount_to_riscos_err( mountproc_umnt_1( &mount->mount_path, mount_client->client ), mount, mount_client->client );
d1011 1
a1011 1
                err = lightweight_printf( "name=<%0s>, usage = %1d\n", host->host_name, host->usage_count );
d1337 1
a1337 1
        int first, nsecs, nread, flags;
@


4.2
log
@  Added support for booting from alternative boot servers when primary
    boot server is unavailable.
Detail:
  Inet$BootServer2, 3, etc. can be used to specify alternate backup
    boot servers.  When retrying, the NFS module will cycle through
    the servers until it gets a response.
  NFSSTB was identical to NFS except in the title string of the module
    and in counting of accesses to the net.  The net access counting
    macros are retained as a build option, disabled by default.
Admin:
  Filing system boot behavioural changes specified in 1215,251/FS.
  Now uses srccommit.
  Module entitled "NFSSTB" is no longer, but it still generated as a
    dummy module in order to disable any ROM based module of the same
    name.

Version 2.35. Tagged as 'NFS-2_35'
@
text
@d183 1
a183 1
        authorisation = authunix_create( machname, ares->ar_uid, ares->ar_gid, len, gids );
@


4.1
log
@Initial revision
@
text
@d1300 9
d1313 1
a1313 1
        char server_adr[32], mount_path[64];
d1315 1
d1317 1
a1317 1
        err = _kernel_getenv("Inet$BootServer", server_adr, sizeof server_adr);
d1328 2
d1347 9
a1355 1
                if (first)
d1357 1
a1357 1
                        lightweight_printf("Waiting for response from boot server\n");
d1360 8
a1367 1
                lightweight_printf("Elapsed time: %0d seconds\r", nsecs);
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@

head	4.10;
access;
symbols
	NFS-3_27:4.10
	NFS-3_26:4.10
	NFS-3_25:4.10
	NFS-3_24:4.9
	NFS-3_23:4.9
	NFS-3_22:4.8
	NFS-3_21:4.8
	NFS-3_20:4.7
	NFS-3_19:4.7
	sbrodie_NFS_dev_merge:4.6.2.3
	NFS-3_18-4_22_2_4:4.6.2.3
	NFS-3_18-4_22_2_3:4.6.2.2
	NFS-3_18-4_22_2_2:4.6.2.2
	NFS-3_18-4_22_2_1:4.6.2.1
	sbrodie_NFS_dev:4.6.0.2
	sbrodie_NFS_dev_bp:4.6
	NFS-3_18:4.6
	NFS-3_17:4.5
	NFS-3_16:4.5
	NFS-3_15:4.5
	NFS-3_14:4.5
	NFS-3_13:4.5
	NFS-3_12:4.5
	NFS-3_11:4.5
	NFS-3_10:4.4
	NFS-3_09:4.4
	NFS-3_08:4.4
	NFS-3_07:4.4
	NFS-3_06:4.3
	NFS-3_05:4.3
	NFS-3_04:4.3
	NFS-3_02:4.3
	NFS-3_01:4.3
	NFS-3_00:4.2
	NFS-2_37:4.1
	NFS-2_36:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.10
	NFS-2_35:4.1
	Spin_merge:4.1.7.1
	Spinner_23Sep1998_destend:4.1
	Spinner_23Sep1998_srcend:4.1.7.1
	Spinner_23Sep1998_srcbegin:4.1.7.1
	Spinner_23Sep1998_destbegin:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.8
	Ursula_13May1998_bp:4.1
	Ursula_13May1998:4.1.0.4
	rthornb_UrsulaBuild_01May1998:4.1
	pwombwel_2_32:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	MergeFiles:4.1.7.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1;
locks; strict;
comment	@# @;


4.10
date	2018.03.07.21.22.40;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	sKJZhgBEKf2WsztA;

4.9
date	2018.01.29.21.30.18;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	7TGUL0NEVVbjHOoA;

4.8
date	2004.07.30.11.42.14;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	2003.12.10.14.55.08;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2000.11.15.15.19.35;	author sbrodie;	state Exp;
branches
	4.6.2.1;
next	4.5;

4.5
date	2000.05.12.08.06.01;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	2000.03.15.14.16.09;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	99.10.13.09.53.52;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	99.05.14.12.42.02;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.22.14.49.26;	author nturton;	state Exp;
branches
	4.1.5.1
	4.1.7.1;
next	;

4.6.2.1
date	2001.06.04.13.44.38;	author sbrodie;	state Exp;
branches;
next	4.6.2.2;

4.6.2.2
date	2001.06.12.13.37.40;	author sbrodie;	state Exp;
branches;
next	4.6.2.3;

4.6.2.3
date	2001.07.02.11.04.31;	author sbrodie;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.49.26;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.06.29;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Store lxa files verbatim, without appendum
Files saved with load & exec address (as opposed to a filetype and the top nybble of load set to 0xFFF) would be extended by 8 bytes in order to hide the true load/exec for later retrieval.
While useful if only ever saving and retrieving from the RISC OS viewpoint, it would create apparently corrupt or overlong file if you wanted to do any analysis on the NFS server end. Given load/exec addresses are deprecated, change NFS to behave like LanManFS and just denote ",lxa" suffixed files with the appropriate icon in the Filer and a made up load/exec address.

pathmunge.c/_GBPB.c/V2support.c/_Args.c/_File.c/PutBytesX.c/Static.c/Changeinfo.c: Switch out 8 byte appending code. Give the file a proper date stamp instead when viewed on Unix.
_Open.c: Switch out the 8 byte appendum stuff, and use a common OS_Word 14 clock function.
Statics.h/Modulewrap.c: Compute a substitute load/exec using the same algorithm as LanManFS (the Kernel's address rounded down to 1MB). Use cmhg finalise function instead of atexit().

Also
MakeFile: pass in predefine DEBUG for debug builds.
cmhg/NFSHdr: remove *Histogram debug command except when debugging. Add finalise handler.
Commands.c/Commands.h: remove *Histogram debug command except when debugging.
Utils.c: delete unused long long support functions. Add a new time getting support function.
Utils.h: new time getting support function.

Tested with a handful of area saves using *Save, checking the file size when viewed at the server end was correct not 8 bytes longer.

Version 3.25. Tagged as 'NFS-3_25'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*	C.CACHE

Purpose : Handling of NFS caches

Functions :  attrcache_hash
	     lookupcache_hash
	     update_attrcache
	     cancel_lookupcache
	     cancel_lookupcache_by_fhandle
	     cancel_lookupcache_by_mount_point
	     cancel_attrcache_at
	     cancel_attrcache_by_fhandle
	     cancel_attrcache_by_mount_point
	     cancel_all_caches_by_fhandle
	     cancel_all_caches_by_mount_point
	     nfs_getattr
	     nfs_setattr
	     update_lookupcache
	     nfs_lookup_basic
	     nfs_lookup
	     nfs_read
	     nfs_readmany
	     nfs_write
	     nfs_writemany
	     nfs_write_with_appendum
	     nfs_create
	     nfs_remove
	     nfs_rename
	     nfs_mkdir
	     nfs_rmdir
	     nfs_internal_dirplus_update

History :
Date	Who    Comments
-----------------------------------------------------------------------------
07/05/93 ??     INITIAL VERSION
12/01/95 CP     Removed function nfs_readdir since its functionality is
	       	totally replaced within Get_NFS_Directory.
	       	cancel_all_caches_by_fhandle now NOT static.  It can be
	       	exported (used in enumdir)
9/2/95	 CP	Increased the size of the cache to 50 - significant
	 	improvement found (65%->69% hit rate) on short test.
	 	Tending towards 75% in general use ?
21/2/95	 CP	Added better descriptions for each function.
6/2/96   KJB    Merged NFS and STBNFS
9/2/96   DNW    change the variables concerned to 53
18/4/99  SNB    added nfs_internal_dirplus_update for enumdir callback
                which improves the attribute cache hitrate to well over 90%
03/06/01 SNB    redesigned the cache, ~15% performance improvement
****************************************************************************/

#ifndef __NFS_H
#include "nfsheaders.h"
#endif

#ifdef NETACCESSCOUNT
extern unsigned int NetAccessCountG;
#endif


#include "TimeOut.h"
#include "nfsrw.h"

#include <sys/time.h>


/********* cache operation overview ***************************************

There are 2 caches implemented in this file....one for the basic file
information, a second for the attributes for the files ('lookup' and 'attr'
caches).  Both are hash tables using a number of buckets holding doubly
linked lists of entries.  Each entry itself comes from pre-allocated arrays
of structures for speed.

Entries are stored under a specific, almost unique 'hash' value made up from
the mount point and  file ID.  This specifies in which bucket the data is
to be stored.

Each item stored in an active chain is doubly-linked to its neighbours.
Each item stored in the free chain is singly linked to the next free block.
Each item not in the free chain is also doubly-linked through an age
chain.  The hash table holds pointers to both ends so that the oldest
entry can be expired, and updated entries can be promoted to the front of
the list.


SNB's other thoughts on the cache as of June 4th 2001:

Should attribute entries inserted by the nfs_internal_dirplus_update
routine be automatically moved to the front of the age list if they
already exist on the age list.  If we are only doing a directory search,
then we aren't actually interested in the attributes of anything that
doesn't match the entry we are looking for.

Soft-links are a disaster - we should have a cache of them too.

Should the hash_val be stored in with the entry?  It would remove the
need for cache_which_bucket.  Alternatively, the hashtable could contain
a pointer to the function that generates the hash value optimally for
a given entry.

Many update operations (nfs_rmdir, nfs_remove) flush data from the cache
unnecessarily.  If the NFS server gives us the new directory attributes
and the previous attributes match what is cached, we should simply update
the directory attributes - not throw everything known about that directory
away.


***************************************************************************/



/*
        (old comment about 23:)
        These numbers are about where significant roll-off in the
        cache's performance starts to happen.

        KJB:
        OM changed this to 50, increasing memory usage by a little
        under 5K and giving an estimated increase from a cache hit
        rate of 70% to around 75%. Given that the average memory
        size of a RISC OS machine has quadrupled since NFS was first
        built, it doesn't seem unreasonable to add 5K to its memory
        usage (besides, this much memory is saved by using the
        latest compiler and the -ff and -zps1 compile options).

        SNB:
        I increased this to 128 as it is no longer the modulo value
        for bucket choice, but a cap on the number of entries we can
        hold in the hash table at once.  It costs 180+172 bytes per
        entry, so 128 represents ~48K
*/

/* Default values  */

#define DefaultCacheSize   (128)  /* Was 53, was 50,  was 23 */
static int AttrCacheSize     = DefaultCacheSize;
static int LookupCacheSize   = DefaultCacheSize;


/*

So we can use some generic routines, we use a union to represent the hash table types.
We allocate "extra" buckets, so we have handy anchors for the free list and the age
list pointers.  Note that it is guaranteed safe to cast a cache_entry* to the appropriate
entry type point (e.g. attrcache_entry* or lookupcache_entry*).  NO checking is available
for this though - but it is a necessary to permit code sharing between the hash tables.
In reality, you should not need to cast - the only API that permits the implicit cast is
alloc_new_hashtable_entry - which SHOULD only be called from alloc_new_lookupcache_entry
and alloc_new_attrcache_entry anyway.

Note that since the pointers are unions of pointers, you have to be careful to dereference
the right one to maintain your type-safety (or not, depending on how you view it)



Number of buckets - compile time constant.  Note that this number should be chosen
carefully, taking into account the hashing algorithm being used and the fact that
particularly the lookup cache is going to be hashing ONLY ASCII character filenames.

*/
#define NumBuckets         (53)
#define FreeListBucket     (NumBuckets)
#define UseListBucketHead  (FreeListBucket+1)
#define UseListBucketTail  (FreeListBucket+2)
#define AllocBucketTotal   (FreeListBucket+3)
#define UnknownBucket      (-1)


typedef struct attrcache_entry attrcache_entry;
typedef struct lookupcache_entry lookupcache_entry;
typedef struct cache_entry cache_entry;

typedef union {
        cache_entry *generic;
        attrcache_entry *attr;
        lookupcache_entry *lookup;
} cache_entry_pointer;


struct cache_entry
{
        cache_entry_pointer next;
        cache_entry_pointer prev;
        cache_entry_pointer age_newer;
        cache_entry_pointer age_older;
        MountPoint *mount_point;
        clock_t out_of_date_time;
        RO_nfs_fh3 fhandle;
};


struct attrcache_entry
{
        cache_entry entry;
        fattr3 nattr;
};

struct lookupcache_entry
{
        cache_entry entry;
        RO_nfs_fh3 dir;
        char *nfs_name;
};


/* These are the pointers to the array of structures that hold the cached data. */

static struct attrcache_entry   *attrcache;
static struct lookupcache_entry *lookupcache;

typedef struct hashtable {
        cache_entry_pointer bucket[AllocBucketTotal];
} hashtable;


static hashtable attr_hash_table;
static hashtable lookup_hash_table;

static void empty_hash_table(hashtable *h)
{
  int i;

  for (i = 0; i < AllocBucketTotal; ++i) h->bucket[i].generic = NULL;
}


void free_cache(void)
{
  free(lookupcache);
  free(attrcache);
  empty_hash_table(&attr_hash_table);
  empty_hash_table(&lookup_hash_table);
}

int get_cache_size(void)
{
  return(AttrCacheSize);
}



/********* set_cache_size **************************************************

Purpose : Sets the number of entries in each cache.

Inputs : size         the number of entries to permit.

Returns : an error block pointer if the memory allocation failed.

This function allocates the arrays of structures for the cache.  The hash
table itself is static.  All the entries are added to the free list.

If size was 0 on entry, the value remains unchanged (used to initialise the
cache).

****************************************************************************/

_kernel_oserror *set_cache_size( int size)
{

  free_cache();

  if (size !=0)
    AttrCacheSize  =  LookupCacheSize  = size;

  attrcache   = calloc ( AttrCacheSize,    sizeof ( struct attrcache_entry ));
  lookupcache = calloc ( LookupCacheSize , sizeof ( struct lookupcache_entry ) );

  dprintf(("cache_1", "set_cache_sizes: attrcache => %d (* %d ==> %#x)\n", AttrCacheSize, sizeof(attrcache_entry),
    AttrCacheSize * sizeof(attrcache_entry)));
  dprintf(("cache_1", "set_cache_sizes: lookupcache => %d (* %d ==> %#x)\n", LookupCacheSize, sizeof(lookupcache_entry),
    LookupCacheSize * sizeof(lookupcache_entry)));

  if (lookupcache == NULL || attrcache == NULL)
  {
    free_cache();
    return( mb_malloc_failed);
  }

  if (AttrCacheSize != 0)
  {
    for (size = 0; size < AttrCacheSize; ++size)
    {
      attrcache[ size ].entry.next.attr = &attrcache[ size + 1 ];
      attrcache[ size ].entry.mount_point = NULL;

      lookupcache[ size ].entry.next.lookup = &lookupcache[ size + 1 ];
      lookupcache[ size ].entry.mount_point = NULL;
    }

    attrcache[ size - 1 ].entry.next.attr = NULL;
    lookupcache[ size -  1 ].entry.next.lookup = NULL;

    attr_hash_table.bucket[FreeListBucket].attr = attrcache;
    lookup_hash_table.bucket[FreeListBucket].lookup = lookupcache;
  }

  return(NULL);
}

/********* cache_delink_chain **********************************************

Purpose : De-links the cache entry from a bucket

Inputs : ce           ptr to the cache entry
         head_pointer ptr to the bucket's head pointer

Returns : ce.
          The next and prev fields are set to NULL.  The previous item's next
          pointer is pointed at our next item, and vice versa.  The head
          pointer is updated if our prev pointer was NULL (ie. we were first
          on the list)

****************************************************************************/

static cache_entry *cache_delink_chain(cache_entry *ce, cache_entry **head_pointer)
{
  cache_entry *prev, *next;

  prev = ce->prev.generic;
  if (prev) {
    /* previous node points to our next node */
    prev->next.generic = ce->next.generic;
  }
  else if (head_pointer) {
    /* head_pointer must have pointed to us (if it exists) */
    *head_pointer = ce->next.generic;
  }

  next = ce->next.generic;
  if (next) {
    /* next node points to our previous node */
    next->prev.generic = ce->prev.generic;
  }

  ce->next.generic = ce->prev.generic = NULL;

  return ce;
}


/********* cache_delink_age_list *******************************************

Purpose : De-links the cache entry from the age chain

Inputs : ce           ptr to the cache entry
         h            ptr to the hash table

Returns : ce.
          The object is delinked from the age chain and its next/prev ptrs
          are reset to NULL.  The hash table's head and tail pointers are
          reset, if necessary.  The previous and next objects on the list
          are joined if necessary.

****************************************************************************/

static cache_entry *cache_delink_age_list(cache_entry *ce, hashtable *h)
{
  cache_entry *prev, *next;

  /* BucketHead is the new entry addition end, Tail is the oldest entry */
  prev = ce->age_newer.generic;
  if (prev) {
    prev->age_older.generic = ce->age_older.generic;
  }
  else {
    /* this was the youngest entry - change the head pointer */
    h->bucket[UseListBucketHead].generic = ce->age_older.generic;
  }

  next = ce->age_older.generic;
  if (next) {
    next->age_newer.generic = ce->age_newer.generic;
  }
  else {
    h->bucket[UseListBucketTail].generic = ce->age_newer.generic;
  }

  ce->age_older.generic = ce->age_newer.generic = NULL;

  return ce;
}

/********* cache_make_newest ***********************************************

Purpose : Links the cache entry to the front of the age list

Inputs : ce           ptr to the cache entry
         h            ptr to the hash table holding ce

Returns : ce.
          ce has been moved to the newest end of the age chain.

****************************************************************************/

static cache_entry *cache_make_newest(cache_entry *ce, hashtable *h)
{
  ce->age_newer.generic = NULL;
  ce->age_older.generic = h->bucket[UseListBucketHead].generic;
  if (ce->age_older.generic) {
    ce->age_older.generic->age_newer.generic = ce;
  }
  if (h->bucket[UseListBucketTail].generic == NULL) {
    h->bucket[UseListBucketTail].generic = ce;
  }

  return ce;
}

/********* cache_add_to_chain **********************************************

Purpose : Links the cache entry to a bucket

Inputs : ce           ptr to the cache entry
         head_pointer ptr to the bucket's head pointer

Returns : ce.
          The next and prev fields of ce are filled in, the prev field of
          the previous head entry is pointed at ce.  the head pointer is
          updated to point to ce.

****************************************************************************/

static cache_entry *cache_add_to_chain(cache_entry *ce, cache_entry **head_pointer)
{
  ce->next.generic = *head_pointer;
  ce->prev.generic = NULL;
  *head_pointer = ce;
  if (ce->next.generic != NULL) {
    ce->next.generic->prev.generic = ce;
  }

  return ce;
}


/********* cache_which_bucket **********************************************

Purpose : Finds the bucket number holding the specified entry

Inputs : h            ptr to the hash table
         ce           ptr to the cache entry

Returns : the bucket containing 'ce' - or UnknownBucket if it does not
          appear in any (this is a fatal error!)

****************************************************************************/

static int cache_which_bucket(hashtable *h, cache_entry *ce)
{
  int i;

  for (i = 0; i < NumBuckets; ++i)
  {
    cache_entry *he;
    for (he = h->bucket[i].generic; he; he = he->next.generic) {
      if (h->bucket[i].generic == ce) return i;
    }
  }

  /* Error if we get here */
  dprintf(("", "cache_which_bucket: dead - did not find entry %p\n", ce));
  return UnknownBucket;
}


/********* cache_transfer_multiple_to_free_list ****************************

Purpose : Transfers expired cache entries to the free list

Inputs :  h            ptr to the hash table
          now          the time now
          force_one    non-zero to force at least entry to be expired

Returns : void.
          All expired entries have been transferred to the free list.
          If 'force_one' was non-zero, at least one entry will have
          been transferred even if it has not expired.

          The freed structures have been put on the free list.

****************************************************************************/

static void cache_transfer_multiple_to_free_list(hashtable *h, clock_t now, int force_one)
{
  cache_entry *ce;

  while ((ce = h->bucket[UseListBucketTail].generic) != NULL && (force_one || now > ce->out_of_date_time)) {
    dprintf(("cache_3", "expiring hash table entry (%p)\n", h->bucket[UseListBucketTail].generic));
    ce = cache_delink_chain(cache_delink_age_list(ce, h), &h->bucket[cache_which_bucket(h, ce)].generic);
    cache_add_to_chain(ce, &h->bucket[FreeListBucket].generic);
    force_one = 0;
  }
}


/********* alloc_new_hashtable_entry ***************************************

Purpose : Allocates an entry in a hashtable

Inputs : h            ptr to the hash table
         hash_val     the identity of the chain to look in

Returns : a pointer to a new cache_entry for holding the file's
          information.

This routine can never fail.  The returned object IS linked to the active
bucket and in the age list too.  If there are no objects on the free chain,
this routine expires one (or more) from the age list.

****************************************************************************/

static void *alloc_new_hashtable_entry(hashtable *h, int hash_val)
{
  cache_entry *ce;
  const clock_t now = clock();

  if (h->bucket[FreeListBucket].generic == NULL)
  {
    /* No free structures, throw away as many as possible and at least 1 */
    cache_transfer_multiple_to_free_list(h, now, 1);
  }

  dprintf(("cache_3", "obtaining item from free list (%p)\n", h->bucket[FreeListBucket].generic));
  ce = cache_delink_chain(h->bucket[FreeListBucket].generic, &h->bucket[FreeListBucket].generic);

  /* Stop this entry being immediately expired */
  ce->out_of_date_time = now + out_of_date_time;

  /* Attach our new entry to the bucket */
  ce = cache_add_to_chain(ce, &h->bucket[hash_val].generic);

  /* And add it to the head of the age expiry list and fix up the lists */
  return cache_make_newest(ce, h);
}

/********* alloc_new_attrentry *********************************************

Purpose : Allocates an entry in the attr cache for a file

Inputs : hash_val     the identity of the chain to look in

Returns : a pointer to a new attrcache_entry for holding the file's
          information

This routine can never fail.
The returned object IS linked to the active bucket and in the age list too.

****************************************************************************/

static attrcache_entry *alloc_new_attrentry(int hash_val)
{
  attrcache_entry *entry;

  dprintf(("cache_3", "alloc_new_attrentry in bucket %d\n", hash_val));

  entry = alloc_new_hashtable_entry(&attr_hash_table, hash_val);

  dprintf(("cache_3", "alloc_new_attrentry in bucket %d: returning object number %d\n", hash_val, entry ? (entry - attrcache) : -1));

  return entry;
}

/********* alloc_new_lookupentry *******************************************

Purpose : Allocates an entry in the lookup cache for a file

Inputs : filename     ptr to name of the object being sought
         hash_val     the identity of the chain to look in

Returns : a pointer to a new lookupcache_entry for holding the file's
          information; or NULL on malloc failure (for the filename copy).

This routine will always return a non-NULL result except on a memory
exhaustion.  The nfs_name field is the only field filled in by this
function.

The returned object IS linked to the active bucket and in the age list too.

****************************************************************************/

static lookupcache_entry *alloc_new_lookupentry(char *nfs_name, int hash_val)
{
  size_t name_length = strlen(nfs_name) + 1;
  char *new_name = malloc(name_length);

  dprintf(("cache_2", "alloc_new_lookupentry (%s) (bucket %d)\n", nfs_name, hash_val));

  if (new_name != NULL)
  {
    lookupcache_entry *entry = alloc_new_hashtable_entry(&lookup_hash_table, hash_val);
    if (entry->nfs_name != NULL)
    {
            /* The entry was obviously victimised - free up its string */
            free(entry->nfs_name);
    }
    entry->nfs_name = memcpy(new_name, nfs_name, name_length);
    return entry;
  }
  else
  {
    return NULL;
  }
}

#if 0
NOT USED YET - WORK IN PROGRESS;

/********* cache_is_entry_expired ******************************************

Purpose : Determines if a given cache entry has expired

Inputs : ce           ptr to the cache entry

Returns : true if the specified entry is past its expiry date.

****************************************************************************/

static bool_t cache_is_entry_expired(const cache_entry *ce)
{
        return ce->entry.out_of_date_time < clock();
}
#endif

/********* attrcache_locate_entry ******************************************

Purpose : Searches the attr cache for the specified file.

Inputs : mount_point  ptr to the mount point information
         fhandle      ptr to an nfs file handle
         hash_val     the identity of the chain to look in

Returns : a pointer to a attrcache_entry holding matching details, or NULL.

This routine will NOT discard an out-of-date entry - NULL return means
that the entry was not found.

****************************************************************************/

static attrcache_entry *attrcache_locate_entry(MountPoint *mount_point, RO_nfs_fh3 *fhandle, int hash_val)
{
        attrcache_entry *entry;

        for (entry = attr_hash_table.bucket[hash_val].attr; entry; entry = entry->entry.next.attr)
        {
                if ( entry->entry.mount_point == mount_point && 0 == fh3cmp(&entry->entry.fhandle, fhandle))
                {
                        break;
                }
        }

        dprintf(("cache_3", "attrcache_locate_entry returning %p (%d)\n", entry, entry?(entry - attrcache) : -1));
        return entry;
}


/********* attrcache_locate_entry_expire ***********************************

Purpose : Searches the attr cache for the specified file.

Inputs : mount_point  ptr to the mount point information
         fhandle      ptr to an nfs file handle
         hash_val     the identity of the chain to look in

Returns : a pointer to a attrcache_entry holding matching details, or NULL.

This routine will discard an out-of-date entry and return NULL - even on a
match.

****************************************************************************/

static attrcache_entry *attrcache_locate_entry_expire(MountPoint *mount_point, RO_nfs_fh3 *fhandle, int hash_val)
{
        attrcache_entry *entry = attrcache_locate_entry(mount_point, fhandle, hash_val);

        if ( entry != NULL && entry->entry.out_of_date_time < clock() )
        {
                /* Found the entry, but it had expired - move it to the free list */
                cache_entry *ce = &entry->entry;
                cache_delink_age_list(ce, &attr_hash_table);
                cache_delink_chain(ce, &attr_hash_table.bucket[hash_val].generic);
                cache_add_to_chain(ce, &attr_hash_table.bucket[FreeListBucket].generic);
                ce->mount_point = NULL;
                entry = NULL;
                dprintf(("cache_3", "but attrcache_locate_entry_expire expires that entry immediately\n"));
        }

        return entry;
}


/********* lookupcache_locate_entry ****************************************

Purpose : Searches the lookup cache for the specified file.

Inputs : mount_point  ptr to the mount point information
         dir          ptr to an nfs file handle of a directory
         filename     ptr to name of the object being sought
         hash_val     the identity of the chain to look in

Returns : a pointer to a lookupcache_entry holding matching details, or NULL.

This routine will NOT discard an out-of-date entry - NULL returns mean that
the entry was not found anywhere.

****************************************************************************/

static lookupcache_entry *lookupcache_locate_entry(MountPoint *mount_point, RO_nfs_fh3 *dir, char *filename, int hash_val)
{
        lookupcache_entry *entry;
        size_t filename_length = strlen(filename);

        dprintf(("cache_3", "lookupcache_locate_entry (bucket %d) (%s)\n", hash_val, filename));

        for (entry = lookup_hash_table.bucket[hash_val].lookup; entry; entry = entry->entry.next.lookup)
        {
                if ( entry->entry.mount_point == mount_point &&
                     0 == fh3cmp(&entry->dir, dir) &&
                     0 == memcmp(entry->nfs_name, filename, filename_length) )
                {
                        /* At least the stem of the filename matched - now check for a RISC OS suffix */
                        if (entry->nfs_name[filename_length+0] != '\0')
                        {
                                const char *const suffix = &entry->nfs_name[filename_length];

                                if (suffix[0] != FileChar_TypedNamePrefix || suffix[4] != '\0')
                                    continue;

                                if (!(
                                  (isxdigit(suffix[1]) && isxdigit(suffix[2]) && isxdigit(suffix[3])) ||
                                  (suffix[1] == FileString_DeadFile[0] &&
                                   suffix[2] == FileString_DeadFile[1] &&
                                   suffix[3] == FileString_DeadFile[2]) ||
                                  (suffix[1] == FileString_UntypedFile[0] &&
                                   suffix[2] == FileString_UntypedFile[1] &&
                                   suffix[3] == FileString_UntypedFile[2])
                                   ))
                                   continue;
                        }

                        break;
                }
        }

        dprintf(("cache_3", "lookupcache_locate_entry returning %p (%d)\n", entry, entry?(entry - lookupcache) : -1));

        return entry;
}


/********* lookupcache_locate_entry_expire *********************************

Purpose : Searches the lookup cache for the specified file.

Inputs : mount_point  ptr to the mount point information
         dir          ptr to an nfs file handle of a directory
         filename     ptr to name of the object being sought
         hash_val     the identity of the chain to look in

Returns : a pointer to a lookupcache_entry holding matching details, or NULL.

This routine will discard an out-of-date entry and return NULL - even on a
match.

****************************************************************************/

static lookupcache_entry *lookupcache_locate_entry_expire(MountPoint *mount_point, RO_nfs_fh3 *dir, char *filename, int hash_val)
{
        lookupcache_entry *entry = lookupcache_locate_entry(mount_point, dir, filename, hash_val);

        if ( entry != NULL && entry->entry.out_of_date_time < clock() )
        {
                /* Found the entry, but it had expired - move it to the free list */
                cache_entry *ce = &entry->entry;
                cache_delink_age_list(ce, &lookup_hash_table);
                cache_delink_chain(ce, &lookup_hash_table.bucket[hash_val].generic);
                cache_add_to_chain(ce, &lookup_hash_table.bucket[FreeListBucket].generic);
                free(entry->nfs_name), entry->nfs_name = NULL;
                ce->mount_point = NULL;
                entry = NULL;
                dprintf(("cache_3", "but lookupcache_locate_entry_expire expires that entry immediately\n"));
        }

        return entry;
}



/********* attrcache_hash **************************************************

Purpose : Generates the hash value for the attrcache entry.

Inputs : mount_point  ptr to the mount point information
         fhandle      ptr to an nfs file handle

Returns : a hash value based on the _value_ of the mount point pointer &
          fhandle, modulo (number of buckets)

NOTE   : This routine only identifies the chain in which data for the fhandle
         should be stored - callers must then search the appropriate list for
         the matching entry if they want it (even to delete it).

****************************************************************************/

static int attrcache_hash(MountPoint *mount_point, RO_nfs_fh3 *fhandle)
{
        unsigned hash_val;
        char *rover;
        int i;

        rover = (char *)&mount_point;
        hash_val = rover[0] ^ (rover[1]<<1) ^ (rover[2]<<2) ^ (rover[3]<<3);

        for ( i = 0;
                i < fhandle->fh3.data.data_len;
                i++ )
        {
                hash_val = (hash_val << 1) ^ (hash_val >> 31) ^ fhandle->fh3.data.data_val[i];
        }

        return (int)(hash_val % NumBuckets); /* (int)(hash_val % AttrCacheSize); */
} /* endfunction attrcache_hash */



/********* lookupcache_hash ************************************************

Purpose : Generates the hash value for the lookupcache entry.

Inputs : mount_point  ptr to the mount point information
         fhandle      ptr to  nfs file handle of the directory where the
                      file is
         nfs_name     ptr to the nfs name string of the file

Returns : a hash value based on the _address_ of the mount point, the
          directory where the file is, and the name string, modulo
          (number of buckets)

NOTE   : This routine only identifies the chain in which data for the fhandle
         should be stored - callers must then search the appropriate list for
         the matching entry if they want it (even to delete it).

****************************************************************************/

static int lookupcache_hash(MountPoint *mount_point, RO_nfs_fh3 *dir, char *nfs_name)
{
        unsigned hash_val;
        int i;

        hash_val = (int)mount_point;

        for ( i = 0;
                i < dir->fh3.data.data_len;
                i++ )
        {
                hash_val = ((hash_val << 1) | (hash_val >> 31)) + dir->fh3.data.data_val[i];
        }

        for ( i = 0;
                nfs_name[ i ] && nfs_name[ i ] != FileChar_TypedNamePrefix;
                i++ )
        {
                hash_val = ((hash_val << 1) | (hash_val >> 31)) + nfs_name[i];
        }

        return (int)(hash_val % NumBuckets); /* (int)(hash_val % LookupCacheSize); */
}  /* endfunction lookupcache_hash */




/********* update_attrcache_entry *******************************************

Purpose : Actually update the values held at a specified position in the
          attribute cache

Inputs :  mount_point  ptr to the mount point details
          fhandle      handle of the file to be put into the cache
          entry        pointer to the entry data structure
          nattr        attributes of the file

Returns : entry.
          Overwrites the data in the specified cache entry.

****************************************************************************/

static attrcache_entry *update_attrcache_entry(MountPoint *mount_point,RO_nfs_fh3 *fhandle, attrcache_entry *entry, fattr3 *nattr)
{
        entry->entry.mount_point = mount_point;
        entry->nattr = *nattr;
        fh3cpy(&entry->entry.fhandle, fhandle);
        entry->entry.out_of_date_time = clock() + out_of_date_time;

        return entry;
} /* endfunction update_attrcache_entry */


/********* update_attrcache *************************************************

Purpose : Update the cached attribute values held for the specified file.  Existing
          entries are updated, non-existent entries are created.

Inputs :  mount_point  ptr to the mount point details
          fhandle      handle of the file to be put into the cache
          nattr        attributes of the file

Returns : the address of the cache entry data structure.

****************************************************************************/

static attrcache_entry *update_attrcache(MountPoint *mount_point,RO_nfs_fh3 *fhandle, fattr3 *nattr, bool_t make_newest)
{
        const int hash_val  = attrcache_hash(mount_point, fhandle);
        attrcache_entry *entry = attrcache_locate_entry_expire(mount_point, fhandle, hash_val);

        if (entry == NULL)
        {
                /* We need a new structure - rip one out of the free pool and prepend it
                 * to the active bucket - we prepend because in all likelihood, we are
                 * probably going to be accessing this entry again soon.
                 */
                entry = alloc_new_attrentry(hash_val);
        }
        else
        {
                /* make it the newest entry in the age chain */
                if (make_newest)
                {
                        cache_make_newest(cache_delink_age_list(&entry->entry, &attr_hash_table), &attr_hash_table);
                }
        }

        dprintf(("cache_2", "update_attrcache (bucket %2d)\n", hash_val));
        return update_attrcache_entry(mount_point, fhandle, entry, nattr);
} /* endfunction update_attrcache */


/********* cancel_attr_cache_entry *****************************************

Purpose : Frees a single entry in the attribute cache

Inputs : entry     the entry to be freed
         hash_val  which chain the item is in (or UnknownBucket if not known)

Returns : void.
          returns entry to the free list.

****************************************************************************/
static void cancel_attr_cache_entry( attrcache_entry *entry, int hash_val)
{
        if (hash_val == UnknownBucket)
        {
                hash_val = attrcache_hash( entry->entry.mount_point, &entry->entry.fhandle );
        }

        cache_delink_age_list(&entry->entry, &attr_hash_table);
        cache_delink_chain(&entry->entry, &attr_hash_table.bucket[hash_val].generic);
        cache_add_to_chain(&entry->entry, &attr_hash_table.bucket[FreeListBucket].generic);
        entry->entry.mount_point = NULL;
} /* endfunction cancel_attrcache_entry */


/********* update_lookupcache_entry ****************************************

Purpose : Actually update the values held at a specified position in the
          lookup cache.

Inputs :  mount_point  ptr to the mount point details
          dir          ptr to handle of directory holding file to be entered
          entry        the entry in the hash table to update
          fhandle      ptr to handle of file

Returns : entry.
          Overwrites the cache entry data with the specified information.

****************************************************************************/

static lookupcache_entry *update_lookupcache_entry( MountPoint *mount_point, RO_nfs_fh3 *dir,
                                   lookupcache_entry *entry, RO_nfs_fh3 *fhandle)
{
        if ( entry )
        {
                dprintf(("cache_2", "update_lookupcache_entry (%s)\n", entry->nfs_name));
                entry->entry.mount_point = mount_point;
                fh3cpy(&entry->dir, dir);
                fh3cpy(&entry->entry.fhandle, fhandle);
                entry->entry.out_of_date_time = clock() + out_of_date_time;
                (void) cache_make_newest(cache_delink_age_list(&entry->entry, &lookup_hash_table), &lookup_hash_table);
        }

        return entry;
}   /* endfunction update_lookupcache_entry */


/********* update_lookupcache **********************************************

Purpose : Update the values held at a specified position in the
          lookup cache.

Inputs :  mount_point  ptr to the mount point details
          dir          ptr to handle of directory holding file to be entered
          nfs_name     ptr to name string of file to be put into the cache
          fhandle      ptr to handle of file

Returns : address of the cache entry data structure.

****************************************************************************/

static lookupcache_entry *update_lookupcache( MountPoint *mount_point, RO_nfs_fh3 *dir, char *nfs_name, RO_nfs_fh3 *fhandle)
{
        const int hash_val = lookupcache_hash(mount_point, dir, nfs_name);
        lookupcache_entry *entry = lookupcache_locate_entry_expire(mount_point, dir, nfs_name, hash_val);

        if (entry == NULL)
        {
                /* We need a new structure - rip one out of the free pool and prepend it
                 * to the active bucket - we prepend because in all likelihood, we are
                 * probably going to be accessing this entry again soon.
                 */
                entry = alloc_new_lookupentry(nfs_name, hash_val);
                /* Note - this may return NULL, but only on complete memory exhaustion
                 * Also note that update_lookupcache_entry copes with entry == NULL.
                 */
        }

        dprintf(("cache_2", "update_lookupcache (bucket %2d) entry %p\n", hash_val, entry));
        return update_lookupcache_entry(mount_point, dir, entry, fhandle);
} /* endfunction update_lookupcache */




/********* cancel_lookup_cache_entry ***************************************

Purpose : Frees a single entry in the lookup cache

Inputs : entry     the entry to be freed
         hashval   which chain the item is in (or UnknownBucket if not known)

Returns : void
          returns entry to the free list, and frees up memory for the filename.

****************************************************************************/
static void cancel_lookup_cache_entry( lookupcache_entry *entry, int hash_val)
{
        if (hash_val == UnknownBucket)
        {
                hash_val = lookupcache_hash(entry->entry.mount_point, &entry->dir, entry->nfs_name);
        }

        cache_delink_age_list(&entry->entry, &lookup_hash_table);
        cache_delink_chain(&entry->entry, &lookup_hash_table.bucket[hash_val].generic);
        cache_add_to_chain(&entry->entry, &lookup_hash_table.bucket[FreeListBucket].generic);
        free(entry->nfs_name), entry->nfs_name = NULL;
        entry->entry.mount_point = NULL;
}


/********* cancel_lookup_cache **********************************************

Purpose : Clears a single entry in the lookup cache by calling
          cancel_lookupcache_entry.

Inputs : mount_point  ptr to mount point information
         dir          nfs file handle of directory holding file
         nfs_name     nfs name of the object to clear

Returns : void.

****************************************************************************/

static void cancel_lookup_cache( MountPoint *mount_point, RO_nfs_fh3 *dir, char *nfs_name )
{
        int hash_val = lookupcache_hash( mount_point, dir, nfs_name );
        lookupcache_entry *entry = lookupcache_locate_entry_expire( mount_point, dir, nfs_name, hash_val );
        if (entry)
        {
                cancel_lookup_cache_entry(entry, hash_val);
        }
} /* endfunction cancel_lookup_cache */


/********* cancel_lookup_cache_by_fhandle ***********************************

Purpose : Clears the lookup cache entry associated with a file handle.  It
          does a simple linear search of the cache entries to find the right
          one to clear.

Inputs :  fhandle  filehandle of entry to clear

Returns : void
          if there is an entry in the lookup cache matching the file handle,
          it is returned tothe free list.

****************************************************************************/

static void cancel_lookup_cache_by_fhandle( RO_nfs_fh3 *fhandle )
{
        lookupcache_entry *entry;
        int i;

        for ( i = 0; i < NumBuckets; ++i )
        {
                for (entry = lookup_hash_table.bucket[i].lookup; entry; entry = entry->entry.next.lookup)
                {
                        if ( fh3cmp( &entry->entry.fhandle, fhandle ) == 0 )
                        {
                                cancel_lookup_cache_entry(entry, i);
                                return;
                        }
                }
        }
} /* endfunction cancel_lookupcache_by_fhandle */



/********* cancel_lookup_cache_by_mount_point ******************************

Purpose : Clears the lookup cache entries associated with a mount point value.
          It does a simple linear search of the cache entries to find the
          right ones to clear.

Inputs :  mount_point  ptr to mount point of entry to clear

Returns : void
          All hash table entries with a matching mount_point are returned to
          the free list.

****************************************************************************/

static void cancel_lookup_cache_by_mount_point( MountPoint *mount_point )
{
        int i;

        for ( i = 0;
                i < LookupCacheSize;
                i++ )
        {
                if ( lookupcache[ i ].entry.mount_point == mount_point )
                {
                        cancel_lookup_cache_entry(&lookupcache[ i ], UnknownBucket);
                }
        }
} /* endfunction cancel_lookup_cache_by_mount_point */


/********* cancel_attr_cache_by_fhandle *************************************

Purpose : Clears the attribute cache entry associated with a file handle.  It
          does a simple linear search of the cache entries to find the right
          one to clear.

Inputs :  fhandle  filehandle of entry to clear

Returns : void
          returns any matching attribute cache entry to the free pool.

****************************************************************************/

static void cancel_attr_cache_by_fhandle( RO_nfs_fh3 *fhandle )
{
        int i;

        for ( i = 0;
                i < AttrCacheSize;
                i++ )
        {
                if ( attrcache[ i ].entry.mount_point && fh3cmp( &attrcache[ i ].entry.fhandle, fhandle) == 0 )
                {
                        cancel_attr_cache_entry( &attrcache[i], UnknownBucket );
                        break;
                }
        }
} /* endfunction cancel_attr_cache_by_fhandle */


/********* cancel_attr_cache_by_mount_point ******************************

Purpose : Clears the attr cache entry associated with a mount point value.
          It  does a simple linear search of the cache entries to find the
          right ones to clear.

Inputs :  mount_point  ptr to mount point of entry to clear

Returns : void
          return all matching attribute cache entries to the free pool.

****************************************************************************/

static void cancel_attr_cache_by_mount_point( MountPoint *mount_point )
{
        int i;

        for ( i = 0;
                i < AttrCacheSize;
                ++i )
        {
                if ( attrcache[ i ].entry.mount_point == mount_point )
                {
                        cancel_attr_cache_entry( &attrcache[ i ], UnknownBucket );
                }
        }
} /* endfunction cancel_attr_cache_by_mount_point */


/********* cancel_all_caches_by_fhandle ***********************************

Purpose : Clears both lookup and attribute cache entries associated with a
	  file handle.  It does a simple linear search of the cache entries
	  to find the right one to clear.

Inputs :  fhandle  filehandle of entry to clear

Returns : void  Doesn't do a lot really, just calls other functions !

****************************************************************************/

void cancel_all_caches_by_fhandle( RO_nfs_fh3 *fhandle )
{
        cancel_lookup_cache_by_fhandle( fhandle );
        cancel_attr_cache_by_fhandle( fhandle );
} /* endfunction cancel_all_caches_by_fhandle */



/********* cancel_all_caches_by_mount_point *********************************

Purpose : Clears both lookup and attribute cache entries associated with a
	  mount point ptr.  It does a simple linear search of the cache
	  entries to find the right one to clear.

Inputs :  mount_point  ptr to mountpoint data

Returns : void  Doesn't do a lot really, just calls other functions !

****************************************************************************/

void cancel_all_caches_by_mount_point( MountPoint *mount_point )
{
        cancel_lookup_cache_by_mount_point( mount_point );
        cancel_attr_cache_by_mount_point( mount_point );
} /* endfunction cancel_all_caches_by_mount_point */



/********* nfs_getattr ******************************************************

Purpose : Gets attributes for given file.  It will check the attribute cache
	  first, then will go to the network for the information if it wasn't
	  found, or had timed out.  Any fresh information is stored in the
	  cache.  Flushes all caches if data is stale (NFS3ERR_STALE)

Inputs : nattr        ptr to ptr, somewhere to put the result
       	 mount_point  ptr to mount point info
       	 fhandle      handle of file to get attributes for

Returns : NULL if OK, ptr to error if not (eg not found)
	  If successful, nattr holds the attribute information for the file.

****************************************************************************/

_kernel_oserror *nfs_getattr( fattr3 **nattr, MountPoint *mount_point, RO_nfs_fh3 *fhandle)
{
        _kernel_oserror *err;
        int hash_val = attrcache_hash( mount_point, fhandle );
        static GETATTR3res *getattr_res = NULL;
        GETATTR3args args;
        unused_client *nfs_client;
        attrcache_entry *entry;

        /*
                Check if cache entry is present, then check if it is too old to be useful.
                If all is OK use the cached entry, otherwise obtain the value from the server.
        */

        entry = attrcache_locate_entry_expire(mount_point, fhandle, hash_val);
        if (entry != NULL)
        {
                cache_hits++;
                *nattr = &entry->nattr;
                dprintf(("cache_1", "nfs_getattr: returning cached data\n"));
                return NULL;
        }
        cache_misses++;
        dprintf(("cache_1", "nfs_getattr: going to network for data ...\n"));

        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

        if (getattr_res != NULL)
                xdr_free(xdr_GETATTR3res, getattr_res);

        args.object = fhandle->fh3;
        if (nfs_client->version == NFS_V3)
        {
        	getattr_res = nfsproc3_getattr_3( &args, nfs_client->client );
        }
        else
        {
        	getattr_res = nfs2_em_getattr_3( &args, nfs_client->client );
        }
        err = rpcnfs_to_riscos_err( getattr_res, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err )
        {
                if ( err == mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( fhandle );

                return err;
        }

        entry = alloc_new_attrentry( hash_val );
        update_attrcache_entry( mount_point, fhandle, entry, &getattr_res->GETATTR3res_u.resok.obj_attributes );
        *nattr = &entry->nattr;

        dprintf(("cache_1", "nfs_getattr: returning newly obtained data\n"));

        return NULL;
}   /* endfunction nfs_getattr */



/********* nfs_setattr ******************************************************

Purpose : Sets attributes for given file.  This routine alters the attributes
          of the file on the network, and updates the attribute cache.
          Flushes all caches if data is found to be stale (NFS3ERR_STALE).

Inputs : nattrres     ptr to ptr, somewhere to store result
         mount_point  ptr to mount point info
         fhandle      handle of file to get attributes for
         nattr        ptr to attribute information

Returns : NULL if OK, ptr to error if not (eg not found)
          If successful, nattrres holds the attribute information for the file

****************************************************************************/

_kernel_oserror *nfs_setattr( fattr3 **nattrres, MountPoint *mount_point, RO_nfs_fh3 *fhandle, sattr3 *nattr)
{
        _kernel_oserror *err;
        SETATTR3args sargs;
        static SETATTR3res *sres = NULL;
        unused_client *nfs_client;

        /*
                Get an NFS client
        */
        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

        /*
                Set up the arguments and call the routine
        */
        sargs.object = fhandle->fh3;
        sargs.new_attributes = *nattr;
        sargs.guard.check = FALSE;

        if (sres != NULL)
                xdr_free(xdr_SETATTR3res, sres);

        if (nfs_client->version == NFS_V3)
        {
	        sres = nfsproc3_setattr_3( &sargs, nfs_client->client );
        }
        else
        {
	        sres = nfs2_em_setattr_3( &sargs, nfs_client->client );
        }
        err = rpcnfs_to_riscos_err( sres, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err )
        {
                if ( err == mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( fhandle );

                return err;
        }


        /*
                Update the attrcache with the returned result
        */
        if (sres->SETATTR3res_u.resok.obj_wcc.after.attributes_follow)
        {
                attrcache_entry *entry;

                entry = update_attrcache( mount_point, fhandle, &sres->SETATTR3res_u.resok.obj_wcc.after.post_op_attr_u.attributes, Yes );
                /* In theory it would be possible to store &entry->nattr here, but remember that the cache is not guaranteed
                 * to survive for as long as the result of this call is required.
                 */
                *nattrres = &sres->SETATTR3res_u.resok.obj_wcc.after.post_op_attr_u.attributes;
        }
        else
        {
                cancel_all_caches_by_fhandle(fhandle);
        }

        /*
                No error, so return NULL
        */
        return NULL;
}   /* endfunction nfs_setattr */




/********* nfs_lookup_basic *************************************************

Purpose : Looks for given file.  First of all, the lookup cache is checked.
	  If the file is found, then its attributes are looked up in the
	  attribute cache and the routine returns.

          If the file is not found in the cache, then the network is
	  interrogated for it.  The caches are updated as necessary.

Inputs : fhandle      ptr to handle of file to find
         nattr        ptr to ptr, somewhere to store the attributes on
	 	      	  success
         mount_point  ptr to mount point info
         dir	      ptr to handle for parent directory
         filename     ptr to filename string
         realleafname ptr to ptr to string for real leaf name of file
         malloc_leaf  whether the leaf is to be malloced

Returns : NULL if found OK, otherwise ptr to error
          nattr is filled in with attribute data.
          fhandle is filled in with the full details of the found file
          realleafname is filled in with an optionally malloc'ed pointer to
          the real leaf name of any file found in the cache, or NULL if the
          leafname was correct or the answer did not come from the lookup cache.

****************************************************************************/

static _kernel_oserror *nfs_lookup_basic( RO_nfs_fh3 *fhandle, fattr3 **nattr,
                           MountPoint *mount_point, RO_nfs_fh3 *dir, char *filename,
                           char **realleafname, bool_t malloc_leaf)
{
        _kernel_oserror *err;
        LOOKUP3args dargs;
        static LOOKUP3res *dres = NULL;
        int hashval = lookupcache_hash( mount_point, dir, filename );
        unused_client *nfs_client;
        lookupcache_entry *entry;

        if (malloc_leaf) free(*realleafname);
        *realleafname = NULL;

        dprintf(("cache_3", "nfs_lookup_basic (bucket %02d) >>%s<< (MP=%p)\n", hashval, filename, mount_point));

        entry = lookupcache_locate_entry_expire(mount_point, dir, filename, hashval);

        if (entry != NULL)
        {
                dprintf(("cache_3", "Cache hit (%s => %s)\n", filename, entry->nfs_name));
                cache_hits++;
                fh3cpy(fhandle, &entry->entry.fhandle);
                if (strcmp(filename, entry->nfs_name) != 0) {
                  if (malloc_leaf) {
                    const size_t newlen = strlen(entry->nfs_name) + 1;

                    *realleafname = malloc(newlen);
                    if (*realleafname != NULL) {
                      memcpy(*realleafname, entry->nfs_name, newlen);
                    }
                  }
                  else
                    *realleafname = entry->nfs_name;
                }
                else {
                  *realleafname = NULL;
                }

                err = nfs_getattr( nattr, mount_point, fhandle );

                if ( !err )
                        return NULL;

                /*
                        If something has failed then fall through and do it
                        the hard way.
                */
        }
        cache_misses++;
        dprintf(("cache_3", "Cache miss (%s)\n", filename));

        dargs.what.dir = dir->fh3;
        dargs.what.name = filename;

        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

	if (dres != NULL)
	        xdr_free(xdr_LOOKUP3res, dres);

        if (nfs_client->version == NFS_V3)
        {
	        dres = nfsproc3_lookup_3( &dargs, nfs_client->client );
        }
        else
        {
        	dres = nfs2_em_lookup_3( &dargs, nfs_client->client );
        }
        err = rpcnfs_to_riscos_err( dres, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err )
        {
                if ( err == mb_nfserr_noent )
                {
                        if ( entry )
                        {
                                cancel_lookup_cache_entry( entry, hashval );
                        }
                }
                else if ( err == mb_nfserr_stale )
                {
                        cancel_all_caches_by_fhandle( dir );
                }

                return err;
        }

        fh3cpy_from_xdr(fhandle, &dres->LOOKUP3res_u.resok.object);

        if ( dres->LOOKUP3res_u.resok.obj_attributes.attributes_follow )
        {
                entry = alloc_new_lookupentry( filename, hashval );
                update_lookupcache_entry( mount_point, dir, entry, fhandle );
                *nattr = &dres->LOOKUP3res_u.resok.obj_attributes.post_op_attr_u.attributes;
                update_attrcache( mount_point, fhandle, *nattr, Yes );
        }
        else
        {
                /* Irritatingly, sometimes the server doesn't deign to send us
                 * the object attributes.  PITA servers are handled here by us
                 * making an explicit call to extract the attributes of the
                 * object.
                 */
                dprintf(("rpc_1", "NFS server did not return the attributes\n"));
                err = nfs_getattr( nattr, mount_point, fhandle );

                if ( err )
                {
                        cancel_all_caches_by_fhandle( fhandle );
                }
                else
                {
                        entry = alloc_new_lookupentry( filename, hashval );
                        update_lookupcache_entry( mount_point, dir, entry, fhandle );
                }
        }

        return NULL;
}   /* endfunction nfs_lookup_basic */


/********* nfs_lookup *******************************************************

Purpose : Looks for given file, coping with softlinks.

Inputs : fhandle      ptr to handle of file to find
         nattr        ptr to ptr, somewhere to store the attributes on
	 	      	  success
         mount_point  ptr to mount point info
         dir	      ptr to handle for parent directory
         pfilename    ptr to ptr filename string
         malloc_pf    true if *pfilename is malloced

Returns : NULL if found OK, otherwise ptr to error
	  nattr is filled in with attribute data.
	  fhandle is filled in with the full details of the found file, if
	  	  the network is used
	  pfilename may be updated to the correct NFS filename

****************************************************************************/

_kernel_oserror *nfs_lookup( RO_nfs_fh3 *fhandle, fattr3 **nattr, MountPoint *mount_point,
                                            RO_nfs_fh3 *dir, char **pfilename,
                                            bool_t malloc_pf)
{
        _kernel_oserror *err;
        char *filename = *pfilename;
        RO_nfs_fh3 *used_dir = dir;
        char *used_filename = filename;
        int used_filename_len = strlen( filename );
        int filename_rover = 0;
        int softlink_resolutions_left = MAX_Soft_Link_Resolutions;
        static READLINK3res *rlres = NULL;
        int link_len;
        char *new_block;
        char *end_of_leaf;
        char *start_of_leaf;
        RO_nfs_fh3 last_dir_found;
        YesNoAnswer went_via_soft_links = No;
        unused_client *nfs_client;
        char *realleaf = NULL;

	dprintf(("cache_1", "nfs_lookup(%s) (MP=%p)\n", filename, mount_point));

        do
        {
                /*
                        Determine the directory to search in.
                */
                if ( used_filename[ filename_rover ] == FileChar_NFSDirectorySeparator )
                {
                        /*
                                Starts with /, so must be root of mount point
                        */
                        used_dir = &mount_point->fhandle;
                        filename_rover++;
                }

                /*
                        Address of leaf to search for in the basic lookup.
                */
                start_of_leaf = &used_filename[ filename_rover ];

                /*
                        Skip filename_rover over this leaf name.
                */
                end_of_leaf = strchr( start_of_leaf, FileChar_NFSDirectorySeparator );
                if ( end_of_leaf )
                {
                        filename_rover = end_of_leaf - used_filename;
                }
                else
                {
                        filename_rover = used_filename_len;
                }

                /*
                        Force terminate the leaf (and resolve multiple /s at the same time).
                        Multiple /s may be caused if the last element of a soft link is
                        itself a soft link.
                */
                while( used_filename[ filename_rover ] == FileChar_NFSDirectorySeparator )
                        used_filename[ filename_rover++ ] = '\0';

                /*
                        Lookup that leaf name.
                */
                { static fattr3 safebuf; *nattr = &safebuf;
                err = nfs_lookup_basic( fhandle, nattr, mount_point, used_dir, start_of_leaf, &realleaf, malloc_pf );

                if ( err )
                        continue;

                if (&safebuf == *nattr) {
                        dprintf(("cache_1", "*!*!*!*! No error, but *nattr NOT UPDATED !*!*!*!\n"));
                }
                }

                /*
                        If its a soft link replace the path up to this soft link with
                        the soft link and resolve relative to here.
                */
                switch ( (*nattr)->type )
                {
                case NF3LNK:
                        /*
                                Woops we've run out of our tether!
                        */
                        if ( --softlink_resolutions_left < 0 )
                        {
                                err = mb_too_many_soft_links;
                                continue;
                        }

                        went_via_soft_links = Yes;

                        /*
                                Get the value of the soft link.
                        */
                        err = get_nfs_client_for_mp( &nfs_client, mount_point );
                        if ( err )
                                continue;

                        if (rlres != NULL)
                                xdr_free(xdr_READLINK3res, rlres);

		        if (nfs_client->version == NFS_V3)
		        {
	                        rlres = nfsproc3_readlink_3( (READLINK3args *) &fhandle->fh3, nfs_client->client );
		        }
		        else
		        {
	                        rlres = nfs2_em_readlink_3( (READLINK3args *) &fhandle->fh3, nfs_client->client );
		        }
                        err = rpcnfs_to_riscos_err( rlres, mount_point, nfs_client->client );
                        release_client( nfs_client );

                        if ( err )
                                continue;


                        /*
                                Attach to the front of the filename
                        */
                        if ( used_filename == filename )
                        {
                                /*
                                        used_filename was the name supplied - lets grab a fresh
                                        block as the caller would get upset otherwise.
                                */
                                used_filename_len = strlen( rlres->READLINK3res_u.resok.data );
                                new_block = malloc( used_filename_len + 1 );

                                if ( !new_block )
                                {
                                        err = mb_malloc_failed;
                                        continue;
                                }

                                used_filename = new_block;
                                memcpy( used_filename, rlres->READLINK3res_u.resok.data, used_filename_len + 1 );
                                filename_rover = 0;
                        }
                        else
                        {
                                /*
                                        used_filename wasn't name supplied so we can
                                        stretch the block we got.
                                */

                                /*
                                        String length of the soft link.
                                */
                                link_len = strlen( rlres->READLINK3res_u.resok.data );

                                /*
                                        Stretch (or shrink, possibly) the space to accomodate
                                        the soft link.
                                */
                                new_block = malloc( used_filename_len + link_len + 1 - filename_rover + 1 );

                                if ( !new_block )
                                {
                                        err = mb_malloc_failed;
                                        continue;
                                }

                                /*
                                        Fill in the path continuation.
                                */
                                sprintf( new_block, "%s%c%s",
                                        rlres->READLINK3res_u.resok.data,
                                        FileChar_NFSDirectorySeparator,
                                        &used_filename[ filename_rover ] );

                                free( used_filename );
                                used_filename = new_block;

                                /*
                                        Adjust how long we think the full path is currently.
                                */
                                used_filename_len += link_len + 1 - filename_rover;

                                /*
                                        Start again from the soft link.
                                */
                                filename_rover = 0;
                        }
                        break;

                default:
                        if ( used_filename[ filename_rover ] )
                        {
                                /*
                                        There's more to resolve after this directory, so
                                        take a copy of this dir's handle and point dir at it.
                                        If this isn't a dir, then the lookup will go bang and
                                        we'll get an error that way.
                                */
                                fh3cpy(&last_dir_found, fhandle);

                                used_dir = &last_dir_found;
                        }
                        break;
                }

                /*
                        At this stage, fhandle has been filled in and dir points
                        at the handle of the dir found or the dir searched in (if was a soft link found).
                */
        } while ( !err && used_filename[ filename_rover ] );

        if ( used_filename != filename )
                free( used_filename );

        /*
                Translate a not found whilst resolving a soft link into a soft link.
        */
        if ( err == mb_nfserr_noent && went_via_soft_links )
        {
                err = nfs_lookup_basic( fhandle, nattr, mount_point, dir, filename, &realleaf, malloc_pf );
        }

        if (realleaf != NULL) {
          if (malloc_pf) free(*pfilename);
          *pfilename = realleaf;
        }

        return err;
}



/********* nfs_read *********************************************************

Purpose : Read data from a given file.  It is assumed that there is
	  sufficient memory allocated at readres_data to hold the maximum
	  requested data.  Note that routine will also update the attribute
	  cache entry for the file read from.  If stale data is detected
	  (NFS3ERR_STALE), then all cache entries for that file are cancelled.

Inputs : readres_len    ptr, for storing result
       	 readres_data	ptr, for storing result
       	 mount_point    ptr to mount point info
       	 fhandle	ptr to file handle of file to read
       	 offset		offset from start of file
       	 count		number of bytes to read

Returns : NULL if found OK, otherwise ptr to error
	  readres_len holds the number of bytes actually read
	  readres_data holds the actual data

****************************************************************************/

_kernel_oserror *nfs_read( int *readres_len, char *readres_data, MountPoint *mount_point,
                                         RO_nfs_fh3 *fhandle, unsigned long offset, int count)
{
        _kernel_oserror *err;
        READ3args rargs;
        READ3res *rres;
        READ3res res;
        unused_client *nfs_client;

        rargs.file = fhandle->fh3;
        ui64_create(&rargs.offset, offset);
        rargs.count = count;
        res.READ3res_u.resok.data.data_val = readres_data;

        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

#ifdef PROFILEIT
{
        _kernel_swi_regs r;
        r.r[1] = 2;     /* lower levels */
        _kernel_swi( 0xc0103, &r, &r );
}
#endif
        /* Not using nfsproc_read_2() saves copying the received data */

#ifdef NETACCESSCOUNT
NetAccessCountG++;
#endif

	if (nfs_client->version == NFS_V3) {
	        if ( clnt_call( nfs_client->client, NFSPROC3_READ, xdr_READ3args, &rargs, xdr_READ3res, &res, TIMEOUT ) != RPC_SUCCESS )
	        {
        	        rres = NULL;
	        }
        	else
	        {
        	        rres = &res;
	        }
	}
	else {
	        rres = nfs2_em_read_3_direct(&rargs, nfs_client->client, &res);
	}
#ifdef PROFILEIT
{
        _kernel_swi_regs r;
        r.r[1] = 1;     /* upper levels */
        _kernel_swi( 0xc0103, &r, &r );
}
#endif

        err = rpcnfs_to_riscos_err( rres, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err )
        {
                if ( err == mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( fhandle );

                return err;
        }

        *readres_len = rres->READ3res_u.resok.data.data_len;

        if (rres->READ3res_u.resok.file_attributes.attributes_follow)
                update_attrcache( mount_point, fhandle, &rres->READ3res_u.resok.file_attributes.post_op_attr_u.attributes, Yes );

        return NULL;
}  /* endfunction nfs_read */



/********* nfs_readmany *****************************************************

Purpose : Reads multiple packets from NFS file.  If stale data encountered,
	  then the cache entries for the file are cancelled.  Otherwise the
	  attribute cache is updated.

Inputs : readres_len    ptr, for storing result
       	 readres_data	ptr, for storing result
       	 mount_point    ptr to mount point info
       	 fhandle	ptr to file handle of file to read
       	 offset		offset from start of file
       	 count		number of bytes to read


Returns : NULL if found OK, otherwise ptr to error
	  readres_len holds the number of bytes actually read
	  readres_data holds the actual data


****************************************************************************/

_kernel_oserror *nfs_readmany(int *readres_len, char *readres_data, MountPoint *mount_point,
                                      RO_nfs_fh3 *fhandle, unsigned long offset, int count)
{
        fattr3 nattr;
        _kernel_oserror *err;
        err = nfsrw_readmany(readres_len, readres_data, mount_point, fhandle, offset, count, &nattr );

        if ( err )
        {
                if ( err == mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( fhandle );

                return err;
        }

        update_attrcache( mount_point, fhandle, &nattr, Yes );

        return NULL;
} /* endfunction nfs_readmany */



/********* nfs_write *******************************************************

Purpose : Write data to a given file.  Note that routine will also update the
	  attribute  cache entry for the file read from.  If stale data is
	  detected  (NFS3ERR_STALE), then all cache entries for that file are
	  cancelled.

Inputs : nattr         ptr to ptr, somewhere to store result
       	 mount_point   ptr to mount details
       	 fhandle       ptr to handle of file to write to
       	 offset	       offset in file to write data
       	 data	       ptr to data to write
       	 count	       number of bytes to write

Returns : NULL if found OK, otherwise ptr to error
	  nattr is filled with the attribute data of the file

****************************************************************************/

_kernel_oserror *nfs_write( fattr3 **nattr, MountPoint *mount_point, RO_nfs_fh3 *fhandle,
                                   unsigned long offset, char *data, int count)
{
        _kernel_oserror *err;
        WRITE3args wargs;
        static WRITE3res *wres = NULL;
        unused_client *nfs_client;

        wargs.file = fhandle->fh3;
        ui64_create(&wargs.offset, offset);
        wargs.count = count;
        wargs.stable = FILE_SYNC; /* NFSv2 behaviour - server must guarantee filesystem write sync */
        wargs.data.data_len = count;
        wargs.data.data_val = data;

        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

#ifdef PROFILEIT
{
        _kernel_swi_regs r;
        r.r[1] = 2;     /* lower levels */
        _kernel_swi( 0xc0103, &r, &r );
}
#endif
        if (wres != NULL)
                xdr_free(xdr_WRITE3res, wres);

        if (nfs_client->version == NFS_V3)
        {
	        wres = nfsproc3_write_3( &wargs, nfs_client->client );
        }
        else
        {
	        wres = nfs2_em_write_3( &wargs, nfs_client->client );
        }
#ifdef PROFILEIT
{
        _kernel_swi_regs r;
        r.r[1] = 1;     /* upper levels */
        _kernel_swi( 0xc0103, &r, &r );
}
#endif
        err = rpcnfs_to_riscos_err( wres, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err )
        {
                if ( err == mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( fhandle );

                return err;
        }

        if (wres->WRITE3res_u.resok.file_wcc.after.attributes_follow)
        {
                *nattr = &wres->WRITE3res_u.resok.file_wcc.after.post_op_attr_u.attributes;
                update_attrcache( mount_point, fhandle, &wres->WRITE3res_u.resok.file_wcc.after.post_op_attr_u.attributes, Yes );
        }
        else
        {
                dprintf(("cache_1", "*** (nfs_write) DISCARDING written file attributes - NFS server didn't return them!\n"));
                cancel_all_caches_by_fhandle( fhandle );
        }

        return NULL;
}   /* endfunction nfs_write */



/********* nfs_writemany ***************************************************

Purpose : Write multiple packets of data to a given file.  Note that routine
	  will also update the  attribute  cache entry for the file read
	  from.  If stale data is  detected  (NFS3ERR_STALE), then all cache
	  entries for that file are  cancelled.

Inputs : nattr         ptr to ptr, somewhere to store result
       	 mount_point   ptr to mount details
       	 fhandle       ptr to handle of file to write to
       	 offset	       offset in file to write data
       	 data	       ptr to data to write
       	 count	       number of bytes to write

Returns : NULL if found OK, otherwise ptr to error
	  nattr is filled with the attribute data of the file

***************************************************************************/

_kernel_oserror *nfs_writemany
(
        fattr3 **nattr,
        MountPoint *mount_point,
        RO_nfs_fh3 *fhandle,
        unsigned long offset,
        char *data,
        int count
)
{
        _kernel_oserror *err;
        err = nfsrw_writemany( nattr, mount_point, fhandle, offset, data, count );

        if ( err )
        {
                if ( err == mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( fhandle );

                return err;
        }

        update_attrcache( mount_point, fhandle, *nattr, Yes );

        return NULL;
}  /* endfunction nfs_writemany */



#ifdef LXA_BY_APPENDUM
/********* nfs_write_with_appendum *****************************************

Purpose : Write data to a given file.  Note that routine will also update the
	  attribute  cache entry for the file read from.  If stale data is
	  detected  (NFS3ERR_STALE), then all cache entries for that file are
	  cancelled.

	  But what's the difference between this and nfs_write ?

Inputs : nattr         ptr to ptr, somewhere to store result
       	 mount_point   ptr to mount details
       	 fhandle       ptr to handle of file to write to
       	 offset	       offset in file to write data
       	 data	       ptr to data to write
       	 count	       number of bytes to write

Returns : NULL if found OK, otherwise ptr to error
	  nattr is filled with the attribute data of the file

****************************************************************************/

_kernel_oserror *nfs_write_with_appendum
(
        fattr3 **nattr,
        MountPoint *mount_point,
        RO_nfs_fh3 *fhandle,
        unsigned long offset,
        bytes_with_appendum *data,
        unsigned count
)
{
        _kernel_oserror *err;
        WRITE3args_with_appendum wargs;
        static WRITE3res *wres = NULL;
        unused_client *nfs_client;

        wargs.file = fhandle->fh3;
        ui64_create(&wargs.offset, offset);
        wargs.stable = FILE_SYNC;
        wargs.count = (count3) count + sizeof(appendum);
        wargs.data.data_len = count;
        wargs.data.data_val = data;

        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

#ifdef PROFILEIT
{
        _kernel_swi_regs r;
        r.r[1] = 2;     /* lower levels */
        _kernel_swi( 0xc0103, &r, &r );
}
#endif
        if (wres != NULL)
                xdr_free(xdr_WRITE3res, wres);

       wres = nfsproc3_write_with_appendum_3( &wargs, nfs_client );
#ifdef PROFILEIT
{
        _kernel_swi_regs r;
        r.r[1] = 1;     /* lower levels */
        _kernel_swi( 0xc0103, &r, &r );
}
#endif
        err = rpcnfs_to_riscos_err( wres, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err )
        {
                if ( err == mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( fhandle );

                return err;
        }

        if (wres->WRITE3res_u.resok.file_wcc.after.attributes_follow)
        {
                *nattr = &wres->WRITE3res_u.resok.file_wcc.after.post_op_attr_u.attributes;
                update_attrcache( mount_point, fhandle, &wres->WRITE3res_u.resok.file_wcc.after.post_op_attr_u.attributes, Yes );
        }
        else
        {
                dprintf(("cache_1", "*** (nfs_write_with_appendum) DISCARDING written file attributes - NFS server didn't return them!\n"));
                cancel_all_caches_by_fhandle( fhandle );
        }

        return NULL;
}  /* endfunction nfs_write_with_appendum */
#endif



/********* nfs_create *******************************************************

Purpose : Creates an NFS file.  The details of the new file are entered in
	  the caches, and the cache details of the directory where it is
	  created are cancelled ('cos it's just changed !)

Inputs :  fhandle       ptr, to store result
       	  nattr         ptr to ptr, to store result
       	  mount_point   ptr to mount details
       	  dir		ptr to handle of parent directory
       	  filename	ptr to name of file to create
       	  snattr	ptr to attributes of file to create

Returns :  NULL if OK, otherwise ptr to error
	   fhandle filled in with handle of new file
	   nattr filled in with attribute details of new file

****************************************************************************/

_kernel_oserror *nfs_create
(
        RO_nfs_fh3 *fhandle,
        fattr3 **nattr,
        MountPoint *mount_point,
        RO_nfs_fh3 *dir,
        char *filename,
        sattr3 *snattr
)
{
        _kernel_oserror *err;
        CREATE3args cargs;
        static CREATE3res *cres = NULL;
        unused_client *nfs_client;

        /*
                Get an NFS client
        */
        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

        /*
                Set up the arguments and call the routine
        */
        cargs.where.dir = dir->fh3;
        cargs.where.name = filename;
        cargs.how.mode = UNCHECKED;
        cargs.how.createhow3_u.obj_attributes = *snattr;

        if (cres != NULL)
                xdr_free(xdr_CREATE3res, cres);
        if (nfs_client->version == NFS_V3)
        {
        	cres = nfsproc3_create_3( &cargs, nfs_client->client );
        }
        else
        {
	        cres = nfs2_em_create_3( &cargs, nfs_client->client );
        }
        err = rpcnfs_to_riscos_err( cres, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err )
        {
                if ( err == mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( dir );

                return err;
        }

        fh3cpy_from_xdr(fhandle, &cres->CREATE3res_u.resok.obj.post_op_fh3_u.handle);
        if (cres->CREATE3res_u.resok.obj_attributes.attributes_follow)
        {
                *nattr = &cres->CREATE3res_u.resok.obj_attributes.post_op_attr_u.attributes;
                update_attrcache( mount_point, fhandle, *nattr, Yes );
        }
        update_lookupcache( mount_point, dir, filename, fhandle );

        /*
                Date last modified of directory will change.
        */
        if (cres->CREATE3res_u.resok.dir_wcc.after.attributes_follow) {
                update_attrcache( mount_point, dir, &cres->CREATE3res_u.resok.dir_wcc.after.post_op_attr_u.attributes, Yes );
        }
        else
                cancel_attr_cache_by_fhandle( dir );

        return NULL;
}  /* endfunction nfs_create */



/********* nfs_remove *******************************************************

Purpose : Removes (deletes) NFS file.  If this can be done, then all cache
	  entries for the file are cancelled.  Cache entry for parent dir
	  also cancelled since it has now changed.

Inputs : mount_point   ptr to mount details
       	 dir	       ptr to parent directory handle
       	 filename      ptr to filename string of file to delete

Returns : NULL if found OK, otherwise ptr to error

****************************************************************************/

_kernel_oserror *nfs_remove
(
        MountPoint *mount_point,
        RO_nfs_fh3 *dir,
        char *filename
)
{
        _kernel_oserror *err;
        REMOVE3args rargs;
        static REMOVE3res *res = NULL;
        unused_client *nfs_client;

        rargs.object.dir = dir->fh3;
        rargs.object.name = filename;

        dprintf(("cache_1", "nfs_remove(%s)\n", filename));

        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;
        if (res != NULL)
                xdr_free(xdr_REMOVE3res, res);
        if (nfs_client->version == NFS_V3)
        {
	        res = nfsproc3_remove_3( &rargs, nfs_client->client );
        }
        else
        {
	        res = nfs2_em_remove_3( &rargs, nfs_client->client );
        }
        err = rpcnfs_to_riscos_err(res, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err == mb_nfserr_stale )
        {
                cancel_all_caches_by_fhandle( dir );
        }
        else if ( !err )
        {
                cancel_lookup_cache( mount_point, dir, filename );

                /*
                        Date last modified will change.
                */
                if (res->REMOVE3res_u.resok.dir_wcc.after.attributes_follow)
                {
                        update_attrcache(mount_point, dir, &res->REMOVE3res_u.resok.dir_wcc.after.post_op_attr_u.attributes, Yes );
                }
                else
                {
                        cancel_attr_cache_by_fhandle( dir );
                }
        }

        return err;
}  /* endfunction nfs_remove */



/********* nfs_rename *******************************************************

Purpose : Renames an NFS file.  Cache entries for the source are cancelled.
	  The cache is not automatically updated with the new details.

Inputs : mount_point   ptr to mount details
       	 to_dir	       ptr to handle of destination parent dir
       	 to_filename   ptr to filename string of destination
       	 from_dir      ptr to handle of source parent dir
       	 from_filename ptr to filename string of source

Returns : NULL if found OK, otherwise ptr to error

****************************************************************************/

_kernel_oserror *nfs_rename
(
        MountPoint *mount_point,
        RO_nfs_fh3 *to_dir,
        char *to_filename,
        RO_nfs_fh3 *from_dir,
        char *from_filename
)
{
        _kernel_oserror *err;
        RENAME3args rargs;
        static RENAME3res *res = NULL;
        unused_client *nfs_client;

        rargs.from.dir = from_dir->fh3;
        rargs.from.name = from_filename;
        rargs.to.dir = to_dir->fh3;
        rargs.to.name = to_filename;

        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

        if (res != NULL)
                xdr_free(xdr_RENAME3res, res);
        if (nfs_client->version == NFS_V3)
        {
	        res = nfsproc3_rename_3( &rargs, nfs_client->client );
        }
        else
        {
	        res = nfs2_em_rename_3( &rargs, nfs_client->client );
        }
        err = rpcnfs_to_riscos_err(res, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err == mb_nfserr_stale )
        {
                cancel_all_caches_by_fhandle( from_dir );
                cancel_all_caches_by_fhandle( to_dir );
        }
        else if ( err == mb_nfserr_BadParameters )
        {
                err = mb_BadRENAME;
        }
        else if ( !err )
        {
                cancel_lookup_cache( mount_point, from_dir, from_filename );

                /*
                        Dates last modified will change.
                */
                if (res->RENAME3res_u.resok.fromdir_wcc.after.attributes_follow)
                {
                        update_attrcache(mount_point, from_dir, &res->RENAME3res_u.resok.fromdir_wcc.after.post_op_attr_u.attributes, Yes );
                }
                else
                {
                        cancel_attr_cache_by_fhandle( from_dir );
                }
                if (res->RENAME3res_u.resok.todir_wcc.after.attributes_follow)
                {
                        update_attrcache(mount_point, to_dir, &res->RENAME3res_u.resok.todir_wcc.after.post_op_attr_u.attributes, Yes );
                }
                else
                {
                        cancel_attr_cache_by_fhandle( to_dir );
                }
        }

        return err;
}  /* endfunction nfs_rename */



/********* nfs_mkdir ********************************************************

Purpose : Creates NFS directory.  Updates lookup cache with details of new
	  directory, and cancels cache entries for parent dir 'cos it's been
	  changed.

Inputs :  fhandle      ptr to handle, to be filled in
       	  nattr	       ptr to ptr, to be filled in
       	  mount_point  ptr to mount details
       	  dir	       ptr to handle of parent directory
       	  filename     ptr to name string for new directory
       	  snattr       ptr to new directory attributes

Returns : NULL if found OK, otherwise ptr to error
	  fhandle is filled in with the handle of the new directory
	  nattr filled in with attributes of new dir

****************************************************************************/

_kernel_oserror *nfs_mkdir
(
        RO_nfs_fh3 *fhandle,
        fattr3 **nattr,
        MountPoint *mount_point,
        RO_nfs_fh3 *dir,
        char *filename,
        sattr3 *snattr
)
{
        _kernel_oserror *err;
        MKDIR3args cargs;
        static MKDIR3res *cres = NULL;
        unused_client *nfs_client;

        /*
                Get an NFS client
        */
        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

        /*
                Set up the arguments and call the routine
        */
        cargs.where.dir = dir->fh3;
        cargs.where.name = filename;
        cargs.attributes = *snattr;

        if (cres != NULL)
                xdr_free(xdr_MKDIR3res, cres);
        if (nfs_client->version == NFS_V3)
        {
	        cres = nfsproc3_mkdir_3( &cargs, nfs_client->client );
        }
        else
        {
        	cres = nfs2_em_mkdir_3( &cargs, nfs_client->client );
        }
        err = rpcnfs_to_riscos_err( cres, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err )
        {
                if ( err == mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( dir );

                return err;
        }

        fh3cpy_from_xdr(fhandle, &cres->MKDIR3res_u.resok.obj.post_op_fh3_u.handle);
        if (cres->MKDIR3res_u.resok.obj_attributes.attributes_follow)
                *nattr = &cres->MKDIR3res_u.resok.obj_attributes.post_op_attr_u.attributes;

        /*
                Don't update the attrcache as it isn't returned correctly.
        */
        update_lookupcache( mount_point, dir, filename, fhandle );

        /*
                Date last modified will change.
        */
        if (cres->MKDIR3res_u.resok.dir_wcc.after.attributes_follow) {
                update_attrcache( mount_point, dir, &cres->MKDIR3res_u.resok.dir_wcc.after.post_op_attr_u.attributes, Yes );
        }
        else
                cancel_attr_cache_by_fhandle( dir );

        return NULL;
}  /* endfunction nfs_mkdir */



/********* nfs_rmdir ********************************************************

Purpose : Removes (deletes) nfs directory.  Cancels all cache entries for specified directory, and for the parent.

Inputs : mount_point   ptr to mount details
       	 dir	       ptr to handle of parent dir
       	 filename      ptr to name string of dir to delete

Returns : NULL if found OK, otherwise ptr to error

****************************************************************************/

_kernel_oserror *nfs_rmdir
(
        MountPoint *mount_point,
        RO_nfs_fh3 *dir,
        char *filename
)
{
        _kernel_oserror *err;
        RMDIR3args rargs;
        static RMDIR3res *res = NULL;
        unused_client *nfs_client;

        rargs.object.dir = dir->fh3;
        rargs.object.name = filename;

        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

        if (res != NULL)
                xdr_free(xdr_RMDIR3res, res);
        if (nfs_client->version == NFS_V3)
        {
        	res = nfsproc3_rmdir_3( &rargs, nfs_client->client );
        }
        else
        {
        	res = nfs2_em_rmdir_3( &rargs, nfs_client->client );
        }
        err = rpcnfs_to_riscos_err(res , mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err == mb_nfserr_stale )
        {
                cancel_all_caches_by_fhandle( dir );
        }
        else if ( !err )
        {
                cancel_lookup_cache( mount_point, dir, filename );

                /*
                        Date last modified will change.
                */
                if (res->RMDIR3res_u.resok.dir_wcc.after.attributes_follow)
                {
                        update_attrcache(mount_point, dir, &res->RMDIR3res_u.resok.dir_wcc.after.post_op_attr_u.attributes, Yes );
                }
                else
                {
                        cancel_attr_cache_by_fhandle( dir );
                }
        }

        return err;
}   /* endfunction nfs_rmdir */


/********* nfs_dirplus_update ***********************************************

Purpose : Enters data into the lookup and attribute caches as a result of data
          received from the READDIRPLUS RPC call in NFS3

Inputs : mount_point   ptr to mount details
       	 dir	       ptr to handle of parent dir
       	 filename      ptr to name string of dir to delete

Returns : NULL if found OK, otherwise ptr to error

****************************************************************************/

void nfs_internal_dirplus_update
(
        MountPoint *mount_point,
        RO_nfs_fh3 *dir,
        RO_nfs_fh3 *file,
        char *filename,
        fattr3 *nattr
)
{
        dprintf(("cache_1", "NFS3 Dir+ code cache update for >>%s<< (L%02d) (A%02d) (MP=%p)\n", filename,
                lookupcache_hash(mount_point, dir, filename), attrcache_hash(mount_point, file), mount_point));
        update_attrcache(mount_point, file, nattr, No);
        update_lookupcache(mount_point, dir, filename, file);
}


#ifdef DEBUG
/* histogram debugging */

static void do_show_histogram(hashtable *h)
{
  int bucket;
  cache_entry *e;

  for (bucket = 0; bucket < NumBuckets; ++bucket) {
    for (e = h->bucket[bucket].generic; e; e = e->next.generic) {
      lightweight_printf("*");
    }
    lightweight_printf("\n");
  }
}

void show_histogram(void)
{
  lightweight_printf("NFS attribute cache histogram\n");
  do_show_histogram(&attr_hash_table);
  lightweight_printf("\nNFS lookup cache histogram\n");
  do_show_histogram(&lookup_hash_table);
}
#endif
@


4.9
log
@Export our own SWIs as a header
Use the shared makefiles to export Interface/NFS.h and Hdr:NFS.
Remove local copy NFS.h which confuses the dependency checking, now called nfsheaders.h instead.
Delete unused UID/GID pair.
Tested on a mount from FreeBSD 11.1-RELEASE-p4.

Version 3.23. Tagged as 'NFS-3_23'
@
text
@d2104 1
d2194 1
d2643 1
d2666 1
@


4.8
log
@Fixed a memory leak that occurred in some circumstances when a non-exact
name was supplied (eg "Fred" when the server has "fred" or "Fred,ffb").

Version 3.21. Tagged as 'NFS-3_21'
@
text
@d67 1
a67 1
#include "NFS.h"
@


4.7
log
@Merged in branch sbrodie_NFS_dev.
Also added -c90 to CFLAGS so that it will build with recent compilers.
Warning: provokes compiler bugs in many recent compilers!

Version 3.19. Tagged as 'NFS-3_19'
@
text
@d1443 1
d1448 3
a1450 3
          realleafname is filled in with a malloc'ed pointer to the real
          leaf name of any file found in the cache, or NULL if the leafname
          was correct or the answer did not come from the lookup cache.
d1455 2
a1456 1
                           MountPoint *mount_point, RO_nfs_fh3 *dir, char *filename, char **realleafname)
d1465 2
a1466 1
        free(*realleafname), *realleafname = NULL;
d1478 2
a1479 1
                  const size_t newlen = strlen(entry->nfs_name) + 1;
d1481 4
a1484 3
                  *realleafname = malloc(newlen);
                  if (*realleafname != NULL) {
                    memcpy(*realleafname, entry->nfs_name, newlen);
d1486 2
d1587 2
a1588 1
         filename     ptr to filename string
d1594 1
d1599 2
a1600 1
                                            RO_nfs_fh3 *dir, char **pfilename)
d1665 1
a1665 1
                err = nfs_lookup_basic( fhandle, nattr, mount_point, used_dir, start_of_leaf, &realleaf );
d1817 1
a1817 1
                err = nfs_lookup_basic( fhandle, nattr, mount_point, dir, filename, &realleaf );
d1821 1
@


4.6
log
@  Improvement to enable directories that the NFS server refuses to
    serve to be viewed.
Detail:
  Recent versions of the NFS module are more insistent than earlier ones
    that the server divulge the object attributes for each object that
    the module finds out about *without error*.  Previously, errors were
    simply ignored.  Now they are flagged and prevent the directory
    containing the faulty object to be opened.
  The error is now ignored as it was previously.
Admin:
  Tested on desktop machine.
  Requires Filer 2.00 or later if you don't want the Filer giving weird
    error messages about unknown message file tokens when you click Menu
    over the faulty object.

Version 3.18. Tagged as 'NFS-3_18'
@
text
@a20 1
	     update_attrcache_at
a21 1
	     cancel_lookupcache_at
a31 1
	     update_lookupcache_at
d62 2
a74 1
/* static struct timeval TIMEOUT = { 25, 0 };  */
a75 1

d80 47
d140 6
d150 1
a150 2
#define DefaultCacheSize 53  /* Was 50,  was 23 */

d154 53
d209 1
a209 3
        MountPoint *mount_point;
        RO_nfs_fh3 fhandle;
        clock_t out_of_date_time;
a212 1

d215 1
a215 1
        MountPoint *mount_point;
a217 2
        clock_t out_of_date_time;
        RO_nfs_fh3 fhandle;
d220 3
d226 4
d231 4
a234 1
int get_cache_size(void)
d236 3
a238 1
return(AttrCacheSize);
d241 1
d244 4
a247 2
free(lookupcache);
free(attrcache);
d250 22
a272 1
/* Call this function if you want to set the size of the cache  */
d276 426
a701 1
free_cache();
d703 2
a704 2
if (size !=0)
	AttrCacheSize  =  LookupCacheSize  = size;
a705 2
attrcache   = calloc ( AttrCacheSize,    sizeof ( struct attrcache_entry ));
lookupcache = calloc ( LookupCacheSize , sizeof ( struct lookupcache_entry ) );
d707 1
d709 52
a760 5
if (lookupcache == NULL || attrcache == NULL )
	{
	free_cache();
	return( mb_malloc_failed);
	}
d762 1
a762 1
return(NULL);
d766 3
d770 4
d775 1
d777 2
d780 1
a780 1
/********* cache operation overview ***************************************
d782 3
a784 3
There are 2 caches implemented in this file....one for the basic file
informaton, the other for the attributes for the files ('lookup' and 'attr'
caches).  Both are simple predefined arrays of suitable structures.
d786 12
a797 3
Entries are stored under a specific, almost unique 'hash' value made up from
the mount point and  file ID.  This specifies where in the array to store the
data.
d799 2
a800 1
***************************************************************************/
d812 5
a816 2
	  fhandle, modulo (sizeof(cache)) (so it can't drop off the end of
	  the table !)
d836 1
a836 1
        return (int)(hash_val % AttrCacheSize);
d851 6
a856 2
	  directory where the file is, and the name string, modulo
	  (sizeof(cache)) (so it can't drop off the end of the table !)
d881 1
a881 3
	dprintf(("cache_4", "%p,%p,>>%s<< --> (L%02d)\n", mount_point, dir, nfs_name, (hash_val % LookupCacheSize)));

        return (int)(hash_val % LookupCacheSize);
d887 1
a887 1
/********* update_attrcache_at **********************************************
d890 1
a890 1
	  attribute cache
d893 3
a895 3
       	  fhandle      handle of the file to be put into the cache
       	  hash_val     hash value for the entry
       	  nattr	       attributes of the file
d897 2
a898 2
Returns : void.
	  Overwrites the cache entry in global array attrcache[hash_val]
d902 1
a902 1
static void update_attrcache_at(MountPoint *mount_point,RO_nfs_fh3 *fhandle, int hash_val, fattr3 *nattr)
d904 7
a910 6
        dprintf(("cache_2", "update_attrcache_at (A%2d)\n", hash_val));
        attrcache[ hash_val ].mount_point = mount_point;
        fh3cpy(&attrcache[ hash_val ].fhandle, fhandle);
        attrcache[ hash_val ].out_of_date_time = clock() + out_of_date_time;
        attrcache[ hash_val ].nattr = *nattr;
} /* endfunction update_attrcache_at */
d915 2
a916 3
Purpose : Update the values held at a specified position in the attribute
	  cache.  Generates the hash value, and passes it onto
	  update_attrcache_at.
d919 40
a958 2
       	  fhandle      handle of the file to be put into the cache
       	  nattr	       attributes of the file
d961 60
a1020 1
	  Doesn't do a lot itself, really ...
d1024 1
a1024 1
static void update_attrcache( MountPoint *mount_point, RO_nfs_fh3 *fhandle, fattr3 *nattr)
d1026 18
a1043 2
        update_attrcache_at( mount_point, fhandle, attrcache_hash( mount_point, fhandle ), nattr );
}   /* endfunction update_attrcache */
a1045 1
/********* cancel_lookup_cache_at *******************************************
a1046 1
Purpose : Clears a single entry in the lookup cache
d1048 6
a1053 1
Inputs : hashval   position in array to clear
d1056 1
a1056 2
	  frees memory and sets values to 0 at specified entry in global
	  array lookupcache
d1059 1
a1059 2

static void cancel_lookupcache_at( int hashval )
d1061 1
a1061 3
        dprintf(("cache_2", "cancel_lookupcache_at (L%02d)\n", hashval));
        lookupcache[ hashval ].mount_point = NULL;
        if ( lookupcache[ hashval ].nfs_name )
d1063 1
a1063 2
                free( lookupcache[ hashval ].nfs_name );
                lookupcache[ hashval ].nfs_name = NULL;
d1065 7
a1071 1
} /* endfunction cancel_lookupcache_at */
d1077 1
a1077 1
	  cancel_lookup_cache_at.
d1080 2
a1081 2
       	 dir	      nfs file handle of directory holding file
       	 nfs_name     nfs name of the object to clear
d1083 1
a1083 1
Returns : void (doesn't do a lot itself !)
d1087 1
a1087 1
static void cancel_lookupcache( MountPoint *mount_point, RO_nfs_fh3 *dir, char *nfs_name )
d1089 7
a1095 2
        cancel_lookupcache_at( lookupcache_hash( mount_point, dir, nfs_name ));
} /* endfunction cancel_lookupcache */
d1101 2
a1102 2
	  does a simple linear search of the cache entries to find the right
	  one to clear.
d1107 2
a1108 2
	  if there is an entry in global array lookupcache with a matching
	  filehandle, then it is cleared.
d1112 1
a1112 1
static void cancel_lookupcache_by_fhandle( RO_nfs_fh3 *fhandle )
d1114 1
d1117 1
a1117 3
        for ( i = 0;
                i < LookupCacheSize;
                i++ )
d1119 1
a1119 1
                if ( fh3cmp( &lookupcache[ i ].fhandle, fhandle ) == 0 )
d1121 5
a1125 1
                        cancel_lookupcache_at( i );
d1134 3
a1136 3
Purpose : Clears the lookup cache entry associated with a mount point value.
	  It  does a simple linear search of the cache entries to find the
	  right one to clear.
d1141 2
a1142 2
	  if there is an entry in global array lookupcache with a matching
	  mount point ptr, then it is cleared.
d1146 1
a1146 1
static void cancel_lookupcache_by_mount_point( MountPoint *mount_point )
d1154 1
a1154 1
                if ( lookupcache[ i ].mount_point == mount_point )
d1156 1
a1156 1
                        cancel_lookupcache_at( i );
d1159 1
a1159 22
} /* endfunction cancel_lookupcache_by_mount_point */



/********* cancel_attr_cache_at *******************************************

Purpose : Clears a single entry in the attribute cache

Inputs : hashval   position in array to clear

Returns : void
	  frees memory and sets values to 0 at specified entry in global
	  array attrcache

****************************************************************************/

static void cancel_attrcache_at( int hashval )
{
        dprintf(("cache_2", "cancel_attrcache_at (A%02d)\n", hashval));
        attrcache[ hashval ].mount_point = NULL;
} /* endfunction cancel_attrcache_at */

d1165 2
a1166 2
	  does a simple linear search of the cache entries to find the right
	  one to clear.
d1171 1
a1171 2
	  if there is an entry in global array attrcache with a matching
	  filehandle, then it is cleared.
d1175 1
a1175 1
static void cancel_attrcache_by_fhandle( RO_nfs_fh3 *fhandle )
d1183 1
a1183 1
                if ( fh3cmp( &attrcache[ i ].fhandle, fhandle) == 0 )
d1185 2
a1186 1
                        cancel_attrcache_at( i );
d1189 1
a1189 1
} /* endfunction cancel_attrcache_by_fhandle */
d1195 2
a1196 2
	  It  does a simple linear search of the cache entries to find the
	  right one to clear.
d1201 1
a1201 2
	  if there is an entry in global array attrcache with a matching
	  mount point ptr, then it is cleared.
d1205 1
a1205 1
static void cancel_attrcache_by_mount_point( MountPoint *mount_point )
d1211 1
a1211 1
                i++ )
d1213 1
a1213 1
                if ( attrcache[ i ].mount_point == mount_point )
d1215 1
a1215 1
                        cancel_attrcache_at( i );
d1218 1
a1218 1
} /* endfunction cancel_attrcache_by_mount_point */
d1235 2
a1236 2
        cancel_lookupcache_by_fhandle( fhandle );
        cancel_attrcache_by_fhandle( fhandle );
d1255 2
a1256 2
        cancel_lookupcache_by_mount_point( mount_point );
        cancel_attrcache_by_mount_point( mount_point );
d1284 1
d1291 2
a1292 3
        if ( attrcache[ hash_val ].mount_point == mount_point &&
             fh3cmp( &attrcache[ hash_val ].fhandle, fhandle) == 0 &&
             attrcache[ hash_val ].out_of_date_time > clock() )
d1295 2
a1296 3

                *nattr = &attrcache[ hash_val ].nattr;

d1300 1
d1329 3
a1331 1
        update_attrcache_at( mount_point, fhandle, hash_val, &getattr_res->GETATTR3res_u.resok.obj_attributes );
d1333 1
a1333 1
        *nattr = &attrcache[ hash_val ].nattr;
d1343 2
a1344 2
	  of the file on the network, and updates the attribute cache.
	  Flushes all caches if data is found to be stale (NFS3ERR_STALE).
d1347 3
a1349 3
       	 mount_point  ptr to mount point info
       	 fhandle      handle of file to get attributes for
       	 nattr	      ptr to attribute information
d1352 1
a1352 2
	  If successful, nattrres holds the attribute information for the
	  file?
d1405 6
a1410 1
                update_attrcache( mount_point, fhandle, &sres->SETATTR3res_u.resok.obj_wcc.after.post_op_attr_u.attributes );
a1425 54
/********* update_lookupcache_at *******************************************

Purpose : Actually update the values held at a specified position in the
	  lookup cache.  routine explicitly cancels the appropriate entry
	  first.

Inputs :  mount_point  ptr to the mount point details
       	  dir	       ptr to handle of directory to be entered
       	  nfs_name     ptr to name string of file to be put into the cache
       	  hash_val     hash value for the entry
       	  fhandle      ptr to handle of file

Returns : void.
	  Overwrites the cache entry in global array lookupcache[hash_val]

****************************************************************************/

static void update_lookupcache_at( MountPoint *mount_point, RO_nfs_fh3 *dir,
                                   char *nfs_name, int hashval, RO_nfs_fh3 *fhandle)
{
        cancel_lookupcache_at( hashval );
        dprintf(("cache_2", "update_lookupcache_at (L%2d) >>%s<<\n", hashval, nfs_name));
        lookupcache[ hashval ].nfs_name = malloc( strlen( nfs_name ) + 1 );
        if ( lookupcache[ hashval ].nfs_name )
        {
                strcpy( lookupcache[ hashval ].nfs_name, nfs_name );
                lookupcache[ hashval ].mount_point = mount_point;
                fh3cpy(&lookupcache[ hashval ].dir, dir);
                fh3cpy(&lookupcache[ hashval ].fhandle, fhandle);
                lookupcache[ hashval ].out_of_date_time = clock() + out_of_date_time;
        }
}   /* endfunction update_lookupcache_at */



/********* update_lookupcache **********************************************

Purpose : Update the values held at a specified position in the
	  lookup cache, generating hashvalue on the way.

Inputs :  mount_point  ptr to the mount point details
       	  dir	       ptr to handle of directory to be entered
       	  nfs_name     ptr to name string of file to be put into the cache
       	  fhandle      ptr to handle of file

Returns : void.  Doesn't change anything directly

****************************************************************************/

static void update_lookupcache( MountPoint *mount_point, RO_nfs_fh3 *dir, char *nfs_name, RO_nfs_fh3 *fhandle)
{
        update_lookupcache_at( mount_point, dir, nfs_name, lookupcache_hash( mount_point, dir, nfs_name ), fhandle );
}   /* endfunction update_lookupcache */

d1442 1
d1445 6
a1450 3
	  nattr is filled in with attribute data.
	  fhandle is filled in with the full details of the found file, if
	  	  the network is used
d1454 1
a1454 1
                           MountPoint *mount_point, RO_nfs_fh3 *dir, char *filename)
d1461 3
d1465 1
a1465 1
        dprintf(("cache_3", "nfs_lookup_basic (Lval=%02d) >>%s<< (MP=%p)\n", hashval, filename, mount_point));
d1467 3
a1469 4
        if ( lookupcache[ hashval ].mount_point == mount_point &&
                fh3cmp( &lookupcache[ hashval ].dir, dir) == 0 &&
                strcmp( lookupcache[ hashval ].nfs_name, filename ) == 0 &&
                lookupcache[ hashval ].out_of_date_time > clock() )
d1471 1
a1471 1
                dprintf(("cache_3", "Cache hit (%s)\n", filename));
d1473 12
a1484 1
                fh3cpy(fhandle, &lookupcache[ hashval ].fhandle);
d1497 1
a1497 6
        dprintf(("cache_3", "Cache miss - match flags: MP(%d);DirFH(%d);FN(%d);Fresh(%d) (MPhash %p .. MPthis %p)\n",
                lookupcache[ hashval ].mount_point == mount_point,
                fh3cmp( &lookupcache[ hashval ].dir, dir) == 0,
                strcmp( lookupcache[ hashval ].nfs_name, filename ) == 0,
                lookupcache[ hashval ].out_of_date_time > clock(),
                lookupcache[ hashval ].mount_point, mount_point));
d1524 4
a1527 1
                        cancel_lookupcache_at( hashval );
d1541 2
a1542 1
                update_lookupcache_at( mount_point, dir, filename, hashval, fhandle );
d1544 1
a1544 1
                update_attrcache( mount_point, fhandle, *nattr );
d1562 2
a1563 1
                        update_lookupcache_at( mount_point, dir, filename, hashval, fhandle );
d1590 1
a1590 1
                                            RO_nfs_fh3 *dir, char *filename)
d1593 1
d1607 1
d1655 1
a1655 1
                err = nfs_lookup_basic( fhandle, nattr, mount_point, used_dir, start_of_leaf );
a1661 2
                        dprintf(("cache_1", "*!*!*!*! No error, but *nattr NOT UPDATED !*!*!*!\n"));
                        dprintf(("cache_1", "*!*!*!*! No error, but *nattr NOT UPDATED !*!*!*!\n"));
d1807 5
a1811 1
                err = nfs_lookup_basic( fhandle, nattr, mount_point, dir, filename );
d1906 1
a1906 1
                update_attrcache( mount_point, fhandle, &rres->READ3res_u.resok.file_attributes.post_op_attr_u.attributes );
d1949 1
a1949 1
        update_attrcache( mount_point, fhandle, &nattr );
d2033 1
a2033 1
                update_attrcache( mount_point, fhandle, &wres->WRITE3res_u.resok.file_wcc.after.post_op_attr_u.attributes );
d2037 1
d2086 1
a2086 1
        update_attrcache( mount_point, fhandle, *nattr );
d2172 1
a2172 1
                update_attrcache( mount_point, fhandle, &wres->WRITE3res_u.resok.file_wcc.after.post_op_attr_u.attributes );
d2176 1
d2259 1
a2259 1
                update_attrcache( mount_point, fhandle, *nattr );
d2267 1
a2267 1
                update_attrcache( mount_point, dir, &cres->CREATE3res_u.resok.dir_wcc.after.post_op_attr_u.attributes );
d2270 1
a2270 1
                cancel_attrcache_by_fhandle( dir );
d2306 2
d2330 1
a2330 1
                cancel_lookupcache( mount_point, dir, filename );
d2335 8
a2342 1
                cancel_attrcache_by_fhandle( dir );
d2412 1
a2412 1
                cancel_lookupcache( mount_point, from_dir, from_filename );
d2417 16
a2432 2
                cancel_attrcache_by_fhandle( from_dir );
                cancel_attrcache_by_fhandle( to_dir );
d2522 1
a2522 1
                update_attrcache( mount_point, dir, &cres->MKDIR3res_u.resok.dir_wcc.after.post_op_attr_u.attributes );
d2525 1
a2525 1
                cancel_attrcache_by_fhandle( dir );
d2582 1
a2582 1
                cancel_lookupcache( mount_point, dir, filename );
d2587 8
a2594 1
                cancel_attrcache_by_fhandle( dir );
d2620 1
a2620 1
	fattr3 *nattr
d2624 2
a2625 3
        	lookupcache_hash(mount_point, dir, filename),
        	attrcache_hash(mount_point, file), mount_point));
        update_attrcache(mount_point, file, nattr);
d2627 24
@


4.6.2.1
log
@  Cacheing system redesigned.
Detail:
  The cache is now a proper hash table, so should cope a lot better with
    objects with equal hash values - they won't keep on causing each
    other to be thrown out of the cache.  Performance improvement measured
    by *Copy'ing the amu source tree (200K over a 56k6 modem connection
    to our dialup hub).  Data arrived in 42 seconds (~4.7K/sec) vs. 60
    seconds (~3.7K/sec) with version 3.18 due to the very much lower number
    of NFS LOOKUP_3 procedure calls.
Admin:
  Tested briefly - requires more testing before committing to STB products.


Version 3.18, 4.22.2.1. Tagged as 'NFS-3_18-4_22_2_1'
@
text
@d21 1
d23 1
d34 1
a64 2
                which improves the attribute cache hitrate to well over 90%
03/06/01 SNB    redesigned the cache, ~15% performance improvement
d76 1
d78 1
a82 47

/********* cache operation overview ***************************************

There are 2 caches implemented in this file....one for the basic file
information, a second for the attributes for the files ('lookup' and 'attr'
caches).  Both are hash tables using a number of buckets holding doubly
linked lists of entries.  Each entry itself comes from pre-allocated arrays
of structures for speed.

Entries are stored under a specific, almost unique 'hash' value made up from
the mount point and  file ID.  This specifies in whih bucket the data is
to be stored.

Each item stored in an active chain is doubly-linked to its neighbours.
Each item stored in the free chain is singly linked to the next free block.
Each item not in the free chain is also doubly-linked through an age
chain.  The hash table holds pointers to both ends so that the oldest
entry can be expired, and updated entries can be promoted to the front of
the list.


SNB's other thoughts on the cache at of June 4th 2001:

Should attribute entries inserted by the nfs_internal_dirplus_update
routine be automatically moved to the front of the age list if they
already exist on the age list.  If we are only doing a directory search,
then we aren't actually interested in the attributes of anything that
doesn't match the entry we are looking for.

Soft-links are a disaster - we should have a cache of them too.

Should the hash_val be stored in with the entry?  It would remove the
need for cache_which_bucket.  Alternatively, the hashtable could contain
a pointer to the function that generates the hash value optimally for
a given entry.

Many update operations (nfs_rmdir, nfs_remove) flush data from the cache
unnecessarily.  If the NFS server gives us the new directory attributes
and the previous attributes match what is cached, we should simply update
the directory attributes - not throw everything known about that directory
away.


***************************************************************************/



a95 6

        SNB:
        I increased this to 128 as it is no longer the modulo value
        for bucket choice, but a cap on the number of entries we can
        hold in the hash table at once.  It costs 180+172 bytes per
        entry, so 128 represents ~48K
d100 2
a101 1
#define DefaultCacheSize   (128)  /* Was 53, was 50,  was 23 */
d105 2
a106 47

/*

So we can use some generic routines, we use a union to represent the hash table types.
We allocate "extra" buckets, so we have handy anchors for the free list and the age
list pointers.  Note that it is guaranteed safe to cast a cache_entry* to the appropriate
entry type point (e.g. attrcache_entry* or lookupcache_entry*).  NO checking is available
for this though - but it is a necessary to permit code sharing between the hash tables.
In reality, you should not need to cast - the only API that permits the implicit cast is
alloc_new_hashtable_entry - which SHOULD only be called from alloc_new_lookupcache_entry
and alloc_new_attrcache_entry anyway.

Note that since the pointers are unions of pointers, you have to be careful to dereference
the right one to maintain your type-safety (or not, depending on how you view it)



Number of buckets - compile time constant.  Note that this number should be chosen
carefully, taking into account the hashing algorithm being used and the fact that
particularly the lookup cache is going to be hashing ONLY ASCII character filenames.

*/
#define NumBuckets         (53)
#define FreeListBucket     (NumBuckets)
#define UseListBucketHead  (FreeListBucket+1)
#define UseListBucketTail  (FreeListBucket+2)
#define AllocBucketTotal   (FreeListBucket+3)
#define UnknownBucket      (-1)


typedef struct attrcache_entry attrcache_entry;
typedef struct lookupcache_entry lookupcache_entry;
typedef struct cache_entry cache_entry;

typedef union {
        cache_entry *generic;
        attrcache_entry *attr;
        lookupcache_entry *lookup;
} cache_entry_pointer;


struct cache_entry
{
        cache_entry_pointer next;
        cache_entry_pointer prev;
        cache_entry_pointer age_newer;
        cache_entry_pointer age_older;
d108 1
d110 1
a110 1
        RO_nfs_fh3 fhandle;
a113 6
struct attrcache_entry
{
        cache_entry entry;
        fattr3 nattr;
};

d116 1
a116 1
        cache_entry entry;
d119 2
a122 3

/* These are the pointers to the array of structures that hold the cached data. */

a125 3
typedef struct hashtable {
        cache_entry_pointer bucket[AllocBucketTotal];
} hashtable;
d127 1
a127 5

static hashtable attr_hash_table;
static hashtable lookup_hash_table;

static void empty_hash_table(hashtable *h)
d129 1
a129 3
  int i;

  for (i = 0; i < AllocBucketTotal; ++i) h->bucket[i].generic = NULL;
a131 1

d134 2
a135 9
  free(lookupcache);
  free(attrcache);
  empty_hash_table(&attr_hash_table);
  empty_hash_table(&lookup_hash_table);
}

int get_cache_size(void)
{
  return(AttrCacheSize);
d139 1
a139 17

/********* set_cache_size **************************************************

Purpose : Sets the number of entries in each cache.

Inputs : size         the number of entries to permit.

Returns : an error block pointer if the memory allocation failed.

This function allocates the arrays of structures for the cache.  The hash
table itself is static.  All the entries are added to the free list.

If size was 0 on entry, the value remains unchanged (used to initialise the
cache).

****************************************************************************/

d143 1
a143 1
  free_cache();
d145 2
a146 2
  if (size !=0)
    AttrCacheSize  =  LookupCacheSize  = size;
d148 2
a149 2
  attrcache   = calloc ( AttrCacheSize,    sizeof ( struct attrcache_entry ));
  lookupcache = calloc ( LookupCacheSize , sizeof ( struct lookupcache_entry ) );
a150 28
  dprintf(("cache_1", "set_cache_sizes: attrcache => %d (* %d ==> %#x)\n", AttrCacheSize, sizeof(attrcache_entry),
    AttrCacheSize * sizeof(attrcache_entry)));
  dprintf(("cache_1", "set_cache_sizes: lookupcache => %d (* %d ==> %#x)\n", LookupCacheSize, sizeof(lookupcache_entry),
    LookupCacheSize * sizeof(lookupcache_entry)));

  if (lookupcache == NULL || attrcache == NULL)
  {
    free_cache();
    return( mb_malloc_failed);
  }

  if (AttrCacheSize != 0)
  {
    for (size = 0; size < AttrCacheSize; ++size)
    {
      attrcache[ size ].entry.next.attr = &attrcache[ size + 1 ];
      attrcache[ size ].entry.mount_point = NULL;

      lookupcache[ size ].entry.next.lookup = &lookupcache[ size + 1 ];
      lookupcache[ size ].entry.mount_point = NULL;
    }

    attrcache[ size - 1 ].entry.next.attr = NULL;
    lookupcache[ size -  1 ].entry.next.lookup = NULL;

    attr_hash_table.bucket[FreeListBucket].attr = attrcache;
    lookup_hash_table.bucket[FreeListBucket].lookup = lookupcache;
  }
d152 5
a156 39
  return(NULL);
}

/********* cache_delink_chain **********************************************

Purpose : De-links the cache entry from a bucket

Inputs : ce           ptr to the cache entry
         head_pointer ptr to the bucket's head pointer

Returns : ce.
          The next and prev fields are set to NULL.  The previous item's next
          pointer is pointed at our next item, and vice versa.  The head
          pointer is updated if our prev pointer was NULL (ie. we were first
          on the list)

****************************************************************************/

static cache_entry *cache_delink_chain(cache_entry *ce, cache_entry **head_pointer)
{
  cache_entry *prev, *next;

  prev = ce->prev.generic;
  if (prev) {
    /* previous node points to our next node */
    prev->next.generic = ce->next.generic;
  }
  else if (head_pointer) {
    /* head_pointer must have pointed to us (if it exists) */
    *head_pointer = ce->next.generic;
  }

  next = ce->next.generic;
  if (next) {
    /* next node points to our previous node */
    next->prev.generic = ce->prev.generic;
  }

  ce->next.generic = ce->prev.generic = NULL;
d158 1
a158 1
  return ce;
a161 1
/********* cache_delink_age_list *******************************************
a162 1
Purpose : De-links the cache entry from the age chain
a163 2
Inputs : ce           ptr to the cache entry
         h            ptr to the hash table
a164 5
Returns : ce.
          The object is delinked from the age chain and its next/prev ptrs
          are reset to NULL.  The hash table's head and tail pointers are
          reset, if necessary.  The previous and next objects on the list
          are joined if necessary.
d166 1
a166 1
****************************************************************************/
d168 3
a170 3
static cache_entry *cache_delink_age_list(cache_entry *ce, hashtable *h)
{
  cache_entry *prev, *next;
d172 3
a174 9
  /* BucketHead is the new entry addition end, Tail is the oldest entry */
  prev = ce->age_newer.generic;
  if (prev) {
    prev->age_older.generic = ce->age_older.generic;
  }
  else {
    /* this was the youngest entry - change the head pointer */
    h->bucket[UseListBucketHead].generic = ce->age_older.generic;
  }
d176 1
a176 342
  next = ce->age_older.generic;
  if (next) {
    next->age_newer.generic = ce->age_newer.generic;
  }
  else {
    h->bucket[UseListBucketTail].generic = ce->age_newer.generic;
  }

  ce->age_older.generic = ce->age_newer.generic = NULL;

  return ce;
}

/********* cache_add_to_chain **********************************************

Purpose : Links the cache entry to a bucket

Inputs : ce           ptr to the cache entry
         h            ptr to the hash table holding ce

Returns : ce.
          ce has been moved to the newest end of the age chain.

****************************************************************************/

static cache_entry *cache_make_newest(cache_entry *ce, hashtable *h)
{
  ce->age_newer.generic = NULL;
  ce->age_older.generic = h->bucket[UseListBucketHead].generic;
  if (ce->age_older.generic) {
    ce->age_older.generic->age_newer.generic = ce;
  }
  if (h->bucket[UseListBucketTail].generic == NULL) {
    h->bucket[UseListBucketTail].generic = ce;
  }

  return ce;
}

/********* cache_add_to_chain **********************************************

Purpose : Links the cache entry to a bucket

Inputs : ce           ptr to the cache entry
         head_pointer ptr to the bucket's head pointer

Returns : ce.
          The next and prev fields of ce are filled in, the prev field of
          the previous head entry is pointed at ce.  the head pointer is
          updated to point to ce.

****************************************************************************/

static cache_entry *cache_add_to_chain(cache_entry *ce, cache_entry **head_pointer)
{
  ce->next.generic = *head_pointer;
  ce->prev.generic = NULL;
  *head_pointer = ce;
  if (ce->next.generic != NULL) {
    ce->next.generic->prev.generic = ce;
  }

  return ce;
}


/********* cache_which_bucket **********************************************

Purpose : Finds the bucket number holding the specified entry

Inputs : h            ptr to the hash table
         ce           ptr to the cache entry

Returns : the bucket containing 'ce' - or UnknownBucket if it does not
          appear in any (this is a fatal error!)

****************************************************************************/

static int cache_which_bucket(hashtable *h, cache_entry *ce)
{
  int i;

  for (i = 0; i < NumBuckets; ++i)
  {
    cache_entry *he;
    for (he = h->bucket[i].generic; he; he = he->next.generic) {
      if (h->bucket[i].generic == ce) return i;
    }
  }

  /* Error if we get here */
  dprintf(("", "cache_which_bucket: dead - did not find entry %p\n", ce));
  return UnknownBucket;
}


/********* cache_transfer_multiple_to_free_list ****************************

Purpose : Transfers expired cache entries to the free list

Inputs :  h            ptr to the hash table
          now          the time now
          force_one    non-zero to force at least entry to be expired

Returns : void.
          All expired entries have been transferred to the free list.
          If 'force_one' was non-zero, at least one entry will have
          been transferred even if it has not expired.

          The freed structures have been put on the free list.

****************************************************************************/

static void cache_transfer_multiple_to_free_list(hashtable *h, clock_t now, int force_one)
{
  cache_entry *ce;

  while ((ce = h->bucket[UseListBucketTail].generic) != NULL && (force_one || now > ce->out_of_date_time)) {
    dprintf(("cache_3", "expiring hash table entry (%p)\n", h->bucket[UseListBucketTail].generic));
    ce = cache_delink_chain(cache_delink_age_list(ce, h), &h->bucket[cache_which_bucket(h, ce)].generic);
    cache_add_to_chain(ce, &h->bucket[FreeListBucket].generic);
    force_one = 0;
  }
}


/********* alloc_new_hashtable_entry ***************************************

Purpose : Allocates an entry in a hashtable

Inputs : h            ptr to the hash table
         hash_val     the identity of the chain to look in

Returns : a pointer to a new cache_entry for holding the file's
          information.

This routine can never fail.  The returned object IS linked to the active
bucket and in the age list too.  If there are no objects on the free chain,
this routine expires one (or more) from the age listd.

****************************************************************************/

static void *alloc_new_hashtable_entry(hashtable *h, int hash_val)
{
  cache_entry *ce;
  const clock_t now = clock();

  if (h->bucket[FreeListBucket].generic == NULL)
  {
    /* No free structures, throw away as many as possible and at least 1 */
    cache_transfer_multiple_to_free_list(h, now, 1);
  }

  dprintf(("cache_3", "obtaining item from free list (%p)\n", h->bucket[FreeListBucket].generic));
  ce = cache_delink_chain(h->bucket[FreeListBucket].generic, &h->bucket[FreeListBucket].generic);

  /* Stop this entry being immediately expired */
  ce->out_of_date_time = now + out_of_date_time;

  /* Attach our new entry to the bucket */
  ce = cache_add_to_chain(ce, &h->bucket[hash_val].generic);

  /* And add it to the head of the age expiry list and fix up the lists */
  return cache_make_newest(ce, h);
}

/********* alloc_new_attrentry *********************************************

Purpose : Allocates an entry in the attr cache for a file

Inputs : hash_val     the identity of the chain to look in

Returns : a pointer to a new attrcache_entry for holding the file's
          information

This routine can never fail.
The returned object IS linked to the active bucket and in the age list too.

****************************************************************************/

static attrcache_entry *alloc_new_attrentry(int hash_val)
{
  attrcache_entry *entry;

  dprintf(("cache_3", "alloc_new_attrentry in bucket %d\n", hash_val));

  entry = alloc_new_hashtable_entry(&attr_hash_table, hash_val);

  dprintf(("cache_3", "alloc_new_attrentry in bucket %d: returning object number %d\n", hash_val, entry ? (entry - attrcache) : -1));

  return entry;
}

/********* alloc_new_lookupentry *******************************************

Purpose : Allocates an entry in the lookup cache for a file

Inputs : filename     ptr to name of the object being sought
         hash_val     the identity of the chain to look in

Returns : a pointer to a new lookupcache_entry for holding the file's
          information; or NULL on malloc failure (for the filename copy).

This routine will always return a non-NULL result except on a memory
exhaustion.  The nfs_name field is the only field filled in by this
function.

The returned object IS linked to the active bucket and in the age list too.

****************************************************************************/

static lookupcache_entry *alloc_new_lookupentry(char *nfs_name, int hash_val)
{
  size_t name_length = strlen(nfs_name) + 1;
  char *new_name = malloc(name_length);

  dprintf(("cache_2", "alloc_new_lookupentry (%s) (bucket %d)\n", nfs_name, hash_val));

  if (new_name != NULL)
  {
    lookupcache_entry *entry = alloc_new_hashtable_entry(&lookup_hash_table, hash_val);
    if (entry->nfs_name != NULL)
    {
            /* The entry was obviously victimised - free up its string */
            free(entry->nfs_name);
    }
    entry->nfs_name = memcpy(new_name, nfs_name, name_length);
    return entry;
  }
  else
  {
    return NULL;
  }
}

/********* attrcache_locate_entry ******************************************

Purpose : Searches the attr cache for the specified file.

Inputs : mount_point  ptr to the mount point information
         fhandle      ptr to an nfs file handle
         hash_val     the identity of the chain to look in

Returns : a pointer to a attrcache_entry holding matching details, or NULL.

This routine will discard an out-of-date entry and return NULL - even on a
match.

Perhaps this routine should have a way of indicating that the data was there
but was out-of-date?

****************************************************************************/

static attrcache_entry *attrcache_locate_entry(MountPoint *mount_point, RO_nfs_fh3 *fhandle, int hash_val)
{
        attrcache_entry *entry;

        for (entry = attr_hash_table.bucket[hash_val].attr; entry; entry = entry->entry.next.attr)
        {
                if ( entry->entry.mount_point == mount_point && 0 == fh3cmp(&entry->entry.fhandle, fhandle))
                {
                        if ( entry->entry.out_of_date_time < clock() )
                        {
                                /* Found the entry, but it had expired - move it to the free list */
                                cache_entry *ce = &entry->entry;
                                cache_delink_age_list(ce, &attr_hash_table);
                                cache_delink_chain(ce, &attr_hash_table.bucket[hash_val].generic);
                                cache_add_to_chain(ce, &attr_hash_table.bucket[FreeListBucket].generic);
                                ce->mount_point = NULL;
                                entry = NULL;
                        }
                        break;
                }
        }

        dprintf(("cache_3", "attrcache_locate_entry returning %p (%d)\n", entry, entry?(entry - attrcache) : -1));
        return entry;
}


/********* lookupcache_locate_entry ****************************************

Purpose : Searches the lookup cache for the specified file.

Inputs : mount_point  ptr to the mount point information
         dir          ptr to an nfs file handle of a directory
         filename     ptr to name of the object being sought
         hash_val     the identity of the chain to look in

Returns : a pointer to a lookupcache_entry holding matching details, or NULL.

This routine will discard an out-of-date entry and return NULL - even on a
match.

Perhaps this routine should have a way of indicating that the data was there
but was out-of-date?

****************************************************************************/

static lookupcache_entry *lookupcache_locate_entry(MountPoint *mount_point, RO_nfs_fh3 *dir, char *filename, int hash_val)
{
        lookupcache_entry *entry;
        size_t filename_length = strlen(filename);

        dprintf(("cache_3", "lookupcache_locate_entry (bucket %d) (%s)\n", hash_val, filename));

        for (entry = lookup_hash_table.bucket[hash_val].lookup; entry; entry = entry->entry.next.lookup)
        {
                if ( entry->entry.mount_point == mount_point &&
                     0 == fh3cmp(&entry->dir, dir) &&
                     0 == memcmp(entry->nfs_name, filename, filename_length) )
                {
                        /* At least the stem of the filename matched - now check for a RISC OS suffix */
                        if (entry->nfs_name[filename_length+0] != '\0')
                        {
                                if (entry->nfs_name[filename_length+0] != FileChar_TypedNamePrefix ||
                                    !isxdigit( entry->nfs_name[filename_length+1] ) ||
                                    !isxdigit( entry->nfs_name[filename_length+2] ) ||
                                    !isxdigit( entry->nfs_name[filename_length+3] ) ||
                                    entry->nfs_name[filename_length+4] != '\0')
                                    continue;
                        }

                        if ( entry->entry.out_of_date_time < clock() )
                        {
                                /* Found the entry, but it had expired - move it to the free list */
                                cache_entry *ce = &entry->entry;
                                cache_delink_age_list(ce, &lookup_hash_table);
                                cache_delink_chain(ce, &lookup_hash_table.bucket[hash_val].generic);
                                cache_add_to_chain(ce, &lookup_hash_table.bucket[FreeListBucket].generic);
                                free(entry->nfs_name), entry->nfs_name = NULL;
                                ce->mount_point = NULL;
                                entry = NULL;
                        }
                        break;
                }
        }

        dprintf(("cache_3", "lookupcache_locate_entry returning %p (%d)\n", entry, entry?(entry - lookupcache) : -1));

        return entry;
}
d188 2
a189 5
          fhandle, modulo (number of buckets)

NOTE   : This routine only identifies the chain in which data for the fhandle
         should be stored - callers must then search the appropriate list for
         the matching entry if they want it (even to delete it).
d209 1
a209 1
        return (int)(hash_val % NumBuckets); /* (int)(hash_val % AttrCacheSize); */
d224 2
a225 6
          directory where the file is, and the name string, modulo
          (number of buckets)

NOTE   : This routine only identifies the chain in which data for the fhandle
         should be stored - callers must then search the appropriate list for
         the matching entry if they want it (even to delete it).
d250 3
a252 1
        return (int)(hash_val % NumBuckets); /* (int)(hash_val % LookupCacheSize); */
d258 1
a258 1
/********* update_attrcache_entry *******************************************
d261 1
a261 1
          attribute cache
d264 3
a266 3
          fhandle      handle of the file to be put into the cache
          entry        pointer to the entry data structure
          nattr        attributes of the file
d268 2
a269 2
Returns : entry.
          Overwrites the data in the specified cache entry.
d273 1
a273 1
static attrcache_entry *update_attrcache_entry(MountPoint *mount_point,RO_nfs_fh3 *fhandle, attrcache_entry *entry, fattr3 *nattr)
d275 6
a280 9
        entry->entry.mount_point = mount_point;
        entry->nattr = *nattr;
        fh3cpy(&entry->entry.fhandle, fhandle);
        entry->entry.out_of_date_time = clock() + out_of_date_time;

        (void) cache_make_newest(cache_delink_age_list(&entry->entry, &attr_hash_table), &attr_hash_table);

        return entry;
} /* endfunction update_attrcache_entry */
d285 3
a287 2
Purpose : Update the cached attribute values held for the specified file.  Existing
          entries are updated, non-existent entries are created.
d290 2
a291 37
          fhandle      handle of the file to be put into the cache
          nattr        attributes of the file

Returns : the address of the cache entry data structure.

****************************************************************************/

static attrcache_entry *update_attrcache(MountPoint *mount_point,RO_nfs_fh3 *fhandle, fattr3 *nattr)
{
        const int hash_val  = attrcache_hash(mount_point, fhandle);
        attrcache_entry *entry = attrcache_locate_entry(mount_point, fhandle, hash_val);

        if (entry == NULL)
        {
                /* We need a new structure - rip one out of the free pool and prepend it
                 * to the active bucket - we prepend because in all likelihood, we are
                 * probably going to be accessing this entry again soon.
                 */
                entry = alloc_new_attrentry(hash_val);
        }
        else
        {
                /* make it the newest entry in the age chain */
                cache_make_newest(cache_delink_age_list(&entry->entry, &attr_hash_table), &attr_hash_table);
        }

        dprintf(("cache_2", "update_attrcache (bucket %2d)\n", hash_val));
        return update_attrcache_entry(mount_point, fhandle, entry, nattr);
} /* endfunction update_attrcache */


/********* cancel_attr_cache_entry *****************************************

Purpose : Frees a single entry in the attribute cache

Inputs : entry     the entry to be freed
         hash_val  which chain the item is in (or UnknownBucket if not known)
d294 1
a294 1
          returns entry to the free list.
a296 15
static void cancel_attr_cache_entry( attrcache_entry *entry, int hash_val)
{
        if (hash_val == UnknownBucket)
        {
                hash_val = attrcache_hash( entry->entry.mount_point, &entry->entry.fhandle );
        }

        cache_delink_age_list(&entry->entry, &attr_hash_table);
        cache_delink_chain(&entry->entry, &attr_hash_table.bucket[hash_val].generic);
        cache_add_to_chain(&entry->entry, &attr_hash_table.bucket[FreeListBucket].generic);
        entry->entry.mount_point = NULL;
} /* endfunction cancel_attrcache_entry */


/********* update_lookupcache_entry ****************************************
d298 1
a298 15
Purpose : Actually update the values held at a specified position in the
          lookup cache.

Inputs :  mount_point  ptr to the mount point details
          dir          ptr to handle of directory holding file to be entered
          entry        the entry in the hash table to update
          fhandle      ptr to handle of file

Returns : entry.
          Overwrites the cache entry data with the specified information.

****************************************************************************/

static lookupcache_entry *update_lookupcache_entry( MountPoint *mount_point, RO_nfs_fh3 *dir,
                                   lookupcache_entry *entry, RO_nfs_fh3 *fhandle)
d300 2
a301 9
        if ( entry )
        {
                dprintf(("cache_2", "update_lookupcache_entry (%s)\n", entry->nfs_name));
                entry->entry.mount_point = mount_point;
                fh3cpy(&entry->dir, dir);
                fh3cpy(&entry->entry.fhandle, fhandle);
                entry->entry.out_of_date_time = clock() + out_of_date_time;
                (void) cache_make_newest(cache_delink_age_list(&entry->entry, &lookup_hash_table), &lookup_hash_table);
        }
a302 2
        return entry;
}   /* endfunction update_lookupcache_entry */
d304 1
d306 1
a306 1
/********* update_lookupcache **********************************************
d308 1
a308 2
Purpose : Update the values held at a specified position in the
          lookup cache.
d310 3
a312 6
Inputs :  mount_point  ptr to the mount point details
          dir          ptr to handle of directory holding file to be entered
          nfs_name     ptr to name string of file to be put into the cache
          fhandle      ptr to handle of file

Returns : address of the cache entry data structure.
d316 1
a316 36
static lookupcache_entry *update_lookupcache( MountPoint *mount_point, RO_nfs_fh3 *dir, char *nfs_name, RO_nfs_fh3 *fhandle)
{
        const int hash_val = lookupcache_hash(mount_point, dir, nfs_name);
        lookupcache_entry *entry = lookupcache_locate_entry(mount_point, dir, nfs_name, hash_val);

        if (entry == NULL)
        {
                /* We need a new structure - rip one out of the free pool and prepend it
                 * to the active bucket - we prepend because in all likelihood, we are
                 * probably going to be accessing this entry again soon.
                 */
                entry = alloc_new_lookupentry(nfs_name, hash_val);
                /* Note - this may return NULL, but only on complete memory exhaustion
                 * Also note that update_lookupcache_entry copes with entry == NULL.
                 */
        }

        dprintf(("cache_2", "update_lookupcache (bucket %2d) entry %p\n", hash_val, entry));
        return update_lookupcache_entry(mount_point, dir, entry, fhandle);
} /* endfunction update_lookupcache */




/********* cancel_lookup_cache_entry ***************************************

Purpose : Frees a single entry in the lookup cache

Inputs : entry     the entry to be freed
         hashval   which chain the item is in (or UnknownBucket if not known)

Returns : void
          returns entry to the free list, and frees up memory for the filename.

****************************************************************************/
static void cancel_lookup_cache_entry( lookupcache_entry *entry, int hash_val)
d318 3
a320 1
        if (hash_val == UnknownBucket)
d322 2
a323 1
                hash_val = lookupcache_hash(entry->entry.mount_point, &entry->dir, entry->nfs_name);
d325 1
a325 7

        cache_delink_age_list(&entry->entry, &lookup_hash_table);
        cache_delink_chain(&entry->entry, &lookup_hash_table.bucket[hash_val].generic);
        cache_add_to_chain(&entry->entry, &lookup_hash_table.bucket[FreeListBucket].generic);
        free(entry->nfs_name), entry->nfs_name = NULL;
        entry->entry.mount_point = NULL;
}
d331 1
a331 1
          cancel_lookupcache_entry.
d334 2
a335 2
         dir          nfs file handle of directory holding file
         nfs_name     nfs name of the object to clear
d337 1
a337 1
Returns : void.
d341 1
a341 1
static void cancel_lookup_cache( MountPoint *mount_point, RO_nfs_fh3 *dir, char *nfs_name )
d343 2
a344 7
        int hash_val = lookupcache_hash( mount_point, dir, nfs_name );
        lookupcache_entry *entry = lookupcache_locate_entry( mount_point, dir, nfs_name, hash_val );
        if (entry)
        {
                cancel_lookup_cache_entry(entry, hash_val);
        }
} /* endfunction cancel_lookup_cache */
d350 2
a351 2
          does a simple linear search of the cache entries to find the right
          one to clear.
d356 2
a357 2
          if there is an entry in the lookup cache matching the file handle,
          it is returned tothe free list.
d361 1
a361 1
static void cancel_lookup_cache_by_fhandle( RO_nfs_fh3 *fhandle )
a362 1
        lookupcache_entry *entry;
d365 3
a367 1
        for ( i = 0; i < NumBuckets; ++i )
d369 1
a369 1
                for (entry = lookup_hash_table.bucket[i].lookup; entry; entry = entry->entry.next.lookup)
d371 1
a371 5
                        if ( fh3cmp( &entry->entry.fhandle, fhandle ) == 0 )
                        {
                                cancel_lookup_cache_entry(entry, i);
                                return;
                        }
d380 3
a382 3
Purpose : Clears the lookup cache entries associated with a mount point value.
          It does a simple linear search of the cache entries to find the
          right ones to clear.
d387 2
a388 2
          All hash table entries with a matching mount_point are returned to
          the free list.
d392 1
a392 1
static void cancel_lookup_cache_by_mount_point( MountPoint *mount_point )
d400 1
a400 1
                if ( lookupcache[ i ].entry.mount_point == mount_point )
d402 1
a402 1
                        cancel_lookup_cache_entry(&lookupcache[ i ], UnknownBucket);
d405 22
a426 1
} /* endfunction cancel_lookup_cache_by_mount_point */
d432 2
a433 2
          does a simple linear search of the cache entries to find the right
          one to clear.
d438 2
a439 1
          returns any matching attribute cache entry to the free pool.
d443 1
a443 1
static void cancel_attr_cache_by_fhandle( RO_nfs_fh3 *fhandle )
d451 1
a451 1
                if ( attrcache[ i ].entry.mount_point && fh3cmp( &attrcache[ i ].entry.fhandle, fhandle) == 0 )
d453 1
a453 2
                        cancel_attr_cache_entry( &attrcache[i], UnknownBucket );
                        break;
d456 1
a456 1
} /* endfunction cancel_attr_cache_by_fhandle */
d462 2
a463 2
          It  does a simple linear search of the cache entries to find the
          right ones to clear.
d468 2
a469 1
          return all matching attribute cache entries to the free pool.
d473 1
a473 1
static void cancel_attr_cache_by_mount_point( MountPoint *mount_point )
d479 1
a479 1
                ++i )
d481 1
a481 1
                if ( attrcache[ i ].entry.mount_point == mount_point )
d483 1
a483 1
                        cancel_attr_cache_entry( &attrcache[ i ], UnknownBucket );
d486 1
a486 1
} /* endfunction cancel_attr_cache_by_mount_point */
d503 2
a504 2
        cancel_lookup_cache_by_fhandle( fhandle );
        cancel_attr_cache_by_fhandle( fhandle );
d523 2
a524 2
        cancel_lookup_cache_by_mount_point( mount_point );
        cancel_attr_cache_by_mount_point( mount_point );
a551 1
        attrcache_entry *entry;
d558 3
a560 2
        entry = attrcache_locate_entry(mount_point, fhandle, hash_val);
        if (entry != NULL)
d563 3
a565 1
                *nattr = &entry->nattr;
d597 3
a599 3
        entry = alloc_new_attrentry( hash_val );
        update_attrcache_entry( mount_point, fhandle, entry, &getattr_res->GETATTR3res_u.resok.obj_attributes );
        *nattr = &entry->nattr;
d609 2
a610 2
          of the file on the network, and updates the attribute cache.
          Flushes all caches if data is found to be stale (NFS3ERR_STALE).
d613 3
a615 3
         mount_point  ptr to mount point info
         fhandle      handle of file to get attributes for
         nattr        ptr to attribute information
d618 2
a619 1
          If successful, nattrres holds the attribute information for the file
d672 1
a672 6
                attrcache_entry *entry;

                entry = update_attrcache( mount_point, fhandle, &sres->SETATTR3res_u.resok.obj_wcc.after.post_op_attr_u.attributes );
                /* In theory it would be possible to store &entry->nattr here, but remember that the cache is not guaranteed
                 * to survive for as long as the result of this call is required.
                 */
d688 54
a772 1
        lookupcache_entry *entry;
d774 1
a774 1
        dprintf(("cache_3", "nfs_lookup_basic (bucket %02d) >>%s<< (MP=%p)\n", hashval, filename, mount_point));
d776 4
a779 3
        entry = lookupcache_locate_entry(mount_point, dir, filename, hashval);

        if (entry != NULL)
d783 1
a783 1
                fh3cpy(fhandle, &entry->entry.fhandle);
d796 6
a801 1
        dprintf(("cache_3", "Cache miss (%s)\n", filename));
d828 1
a828 4
                        if ( entry )
                        {
                                cancel_lookup_cache_entry( entry, hashval );
                        }
d842 1
a842 2
                entry = alloc_new_lookupentry( filename, hashval );
                update_lookupcache_entry( mount_point, dir, entry, fhandle );
d862 1
a862 2
                        entry = alloc_new_lookupentry( filename, hashval );
                        update_lookupcache_entry( mount_point, dir, entry, fhandle );
d1563 1
a1563 1
                cancel_attr_cache_by_fhandle( dir );
d1621 1
a1621 1
                cancel_lookup_cache( mount_point, dir, filename );
d1626 1
a1626 4
                /*
                        SNB: but does the NFSv3 response not include the updated attributes anyway?
                 */
                cancel_attr_cache_by_fhandle( dir );
d1696 1
a1696 1
                cancel_lookup_cache( mount_point, from_dir, from_filename );
d1701 2
a1702 2
                cancel_attr_cache_by_fhandle( from_dir );
                cancel_attr_cache_by_fhandle( to_dir );
d1795 1
a1795 1
                cancel_attr_cache_by_fhandle( dir );
d1852 1
a1852 1
                cancel_lookup_cache( mount_point, dir, filename );
d1857 1
a1857 1
                cancel_attr_cache_by_fhandle( dir );
@


4.6.2.2
log
@  Fixed some cache problems.
Detail:
  Untyped and lxa files now work again.
  Routines which call nfs_lookup now provide a char * into which the Real
    NFS Leafname can be stored.  This avoids problems with type extended
    files not being found, flushed from the cache, and re-sought - even
    when the files were there anyway.  Fixes the problems with not being
    able to write or delete filetype extended files too.  This should
    speed lots of ops up since it is removing the need for another GETATTR3
    call and/or a directory search.
  I've added in some more of the attribute updating to prevent directory
    attributes being thrown out of the cache when the directory changes
    in a predictable manner (e.h. deleting a file in the directory does
    not cause the cache entries for the directory to be scrapped - simply
    updated from the attributes in the REMOVE3 result - provided the dir
    hadn't changed since the last time we read its attributes.  Fixing this
    means you can delete files on an NFS mount much more quickly now.
Notes:
  Softlinks are a complete disaster for the cache still :-(
  I'm sure it should be possible to search the lookup cache for matching
    leafnames instead of doing a directory search every time - if it is and
    is implemented, this should speed things up a lot.
Admin:
  Tested briefly, seems to work at a basic level but still undergoing testing.


Version 3.18, 4.22.2.2. Tagged as 'NFS-3_18-4_22_2_2'
@
text
@d90 1
a90 1
the mount point and  file ID.  This specifies in which bucket the data is
d101 1
a101 1
SNB's other thoughts on the cache as of June 4th 2001:
d399 1
a399 1
/********* cache_make_newest ***********************************************
d401 1
a401 1
Purpose : Links the cache entry to the front of the age list
d524 1
a524 1
this routine expires one (or more) from the age list.
a620 19
#if 0
NOT USED YET - WORK IN PROGRESS;

/********* cache_is_entry_expired ******************************************

Purpose : Determines if a given cache entry has expired

Inputs : ce           ptr to the cache entry

Returns : true if the specified entry is past its expiry date.

****************************************************************************/

static bool_t cache_is_entry_expired(const cache_entry *ce)
{
        return ce->entry.out_of_date_time < clock();
}
#endif

d631 5
a635 2
This routine will NOT discard an out-of-date entry - NULL return means
that the entry was not found.
d647 10
a665 35
/********* attrcache_locate_entry_expire ***********************************

Purpose : Searches the attr cache for the specified file.

Inputs : mount_point  ptr to the mount point information
         fhandle      ptr to an nfs file handle
         hash_val     the identity of the chain to look in

Returns : a pointer to a attrcache_entry holding matching details, or NULL.

This routine will discard an out-of-date entry and return NULL - even on a
match.

****************************************************************************/

static attrcache_entry *attrcache_locate_entry_expire(MountPoint *mount_point, RO_nfs_fh3 *fhandle, int hash_val)
{
        attrcache_entry *entry = attrcache_locate_entry(mount_point, fhandle, hash_val);

        if ( entry != NULL && entry->entry.out_of_date_time < clock() )
        {
                /* Found the entry, but it had expired - move it to the free list */
                cache_entry *ce = &entry->entry;
                cache_delink_age_list(ce, &attr_hash_table);
                cache_delink_chain(ce, &attr_hash_table.bucket[hash_val].generic);
                cache_add_to_chain(ce, &attr_hash_table.bucket[FreeListBucket].generic);
                ce->mount_point = NULL;
                entry = NULL;
                dprintf(("cache_3", "but attrcache_locate_entry_expire expires that entry immediately\n"));
        }

        return entry;
}


d677 5
a681 2
This routine will NOT discard an out-of-date entry - NULL returns mean that
the entry was not found anywhere.
d701 5
a705 3
                                const char *const suffix = &entry->nfs_name[filename_length];

                                if (suffix[0] != FileChar_TypedNamePrefix || suffix[4] != '\0')
d707 1
d709 10
a718 10
                                if (!(
                                  (isxdigit(suffix[1]) && isxdigit(suffix[2]) && isxdigit(suffix[3])) ||
                                  (suffix[1] == FileString_DeadFile[0] &&
                                   suffix[2] == FileString_DeadFile[1] &&
                                   suffix[3] == FileString_DeadFile[2]) ||
                                  (suffix[1] == FileString_UntypedFile[0] &&
                                   suffix[2] == FileString_UntypedFile[1] &&
                                   suffix[3] == FileString_UntypedFile[2])
                                   ))
                                   continue;
a719 1

a729 37
/********* lookupcache_locate_entry_expire *********************************

Purpose : Searches the lookup cache for the specified file.

Inputs : mount_point  ptr to the mount point information
         dir          ptr to an nfs file handle of a directory
         filename     ptr to name of the object being sought
         hash_val     the identity of the chain to look in

Returns : a pointer to a lookupcache_entry holding matching details, or NULL.

This routine will discard an out-of-date entry and return NULL - even on a
match.

****************************************************************************/

static lookupcache_entry *lookupcache_locate_entry_expire(MountPoint *mount_point, RO_nfs_fh3 *dir, char *filename, int hash_val)
{
        lookupcache_entry *entry = lookupcache_locate_entry(mount_point, dir, filename, hash_val);

        if ( entry != NULL && entry->entry.out_of_date_time < clock() )
        {
                /* Found the entry, but it had expired - move it to the free list */
                cache_entry *ce = &entry->entry;
                cache_delink_age_list(ce, &lookup_hash_table);
                cache_delink_chain(ce, &lookup_hash_table.bucket[hash_val].generic);
                cache_add_to_chain(ce, &lookup_hash_table.bucket[FreeListBucket].generic);
                free(entry->nfs_name), entry->nfs_name = NULL;
                ce->mount_point = NULL;
                entry = NULL;
                dprintf(("cache_3", "but lookupcache_locate_entry_expire expires that entry immediately\n"));
        }

        return entry;
}


d836 2
d855 1
a855 1
static attrcache_entry *update_attrcache(MountPoint *mount_point,RO_nfs_fh3 *fhandle, fattr3 *nattr, bool_t make_newest)
d858 1
a858 1
        attrcache_entry *entry = attrcache_locate_entry_expire(mount_point, fhandle, hash_val);
d871 1
a871 4
                if (make_newest)
                {
                        cache_make_newest(cache_delink_age_list(&entry->entry, &attr_hash_table), &attr_hash_table);
                }
d953 1
a953 1
        lookupcache_entry *entry = lookupcache_locate_entry_expire(mount_point, dir, nfs_name, hash_val);
d1016 1
a1016 1
        lookupcache_entry *entry = lookupcache_locate_entry_expire( mount_point, dir, nfs_name, hash_val );
d1217 1
a1217 1
        entry = attrcache_locate_entry_expire(mount_point, fhandle, hash_val);
a1221 1
                dprintf(("cache_1", "nfs_getattr: returning cached data\n"));
a1224 1
        dprintf(("cache_1", "nfs_getattr: going to network for data ...\n"));
a1256 2
        dprintf(("cache_1", "nfs_getattr: returning newly obtained data\n"));

d1329 1
a1329 1
                entry = update_attrcache( mount_point, fhandle, &sres->SETATTR3res_u.resok.obj_wcc.after.post_op_attr_u.attributes, Yes );
a1363 1
         realleafname ptr to ptr to string for real leaf name of file
d1366 3
a1368 6
          nattr is filled in with attribute data.
          fhandle is filled in with the full details of the found file
          realleafname is filled in with a malloc'ed pointer to the real
          leaf name of any file found in the cache, or NULL if the leafname
          was correct or the answer did not come from the lookup cache.

d1372 1
a1372 1
                           MountPoint *mount_point, RO_nfs_fh3 *dir, char *filename, char **realleafname)
a1380 2
        free(*realleafname), *realleafname = NULL;

d1383 1
a1383 1
        entry = lookupcache_locate_entry_expire(mount_point, dir, filename, hashval);
d1387 1
a1387 1
                dprintf(("cache_3", "Cache hit (%s => %s)\n", filename, entry->nfs_name));
a1389 11
                if (strcmp(filename, entry->nfs_name) != 0) {
                  const size_t newlen = strlen(entry->nfs_name) + 1;

                  *realleafname = malloc(newlen);
                  if (*realleafname != NULL) {
                    memcpy(*realleafname, entry->nfs_name, newlen);
                  }
                }
                else {
                  *realleafname = NULL;
                }
d1449 1
a1449 1
                update_attrcache( mount_point, fhandle, *nattr, Yes );
d1495 1
a1495 1
                                            RO_nfs_fh3 *dir, char **pfilename)
a1497 1
        char *filename = *pfilename;
a1510 1
        char *realleaf = NULL;
d1558 1
a1558 1
                err = nfs_lookup_basic( fhandle, nattr, mount_point, used_dir, start_of_leaf, &realleaf );
d1565 2
d1712 1
a1712 5
                err = nfs_lookup_basic( fhandle, nattr, mount_point, dir, filename, &realleaf );
        }

        if (realleaf != NULL) {
          *pfilename = realleaf;
d1807 1
a1807 1
                update_attrcache( mount_point, fhandle, &rres->READ3res_u.resok.file_attributes.post_op_attr_u.attributes, Yes );
d1850 1
a1850 1
        update_attrcache( mount_point, fhandle, &nattr, Yes );
d1934 1
a1934 1
                update_attrcache( mount_point, fhandle, &wres->WRITE3res_u.resok.file_wcc.after.post_op_attr_u.attributes, Yes );
a1937 1
                dprintf(("cache_1", "*** (nfs_write) DISCARDING written file attributes - NFS server didn't return them!\n"));
d1986 1
a1986 1
        update_attrcache( mount_point, fhandle, *nattr, Yes );
d2072 1
a2072 1
                update_attrcache( mount_point, fhandle, &wres->WRITE3res_u.resok.file_wcc.after.post_op_attr_u.attributes, Yes );
a2075 1
                dprintf(("cache_1", "*** (nfs_write_with_appendum) DISCARDING written file attributes - NFS server didn't return them!\n"));
d2158 1
a2158 1
                update_attrcache( mount_point, fhandle, *nattr, Yes );
d2166 1
a2166 1
                update_attrcache( mount_point, dir, &cres->CREATE3res_u.resok.dir_wcc.after.post_op_attr_u.attributes, Yes );
a2204 2
        dprintf(("cache_1", "nfs_remove(%s)\n", filename));

d2232 4
a2235 8
                if (res->REMOVE3res_u.resok.dir_wcc.after.attributes_follow)
                {
                        update_attrcache(mount_point, dir, &res->REMOVE3res_u.resok.dir_wcc.after.post_op_attr_u.attributes, Yes );
                }
                else
                {
                        cancel_attr_cache_by_fhandle( dir );
                }
d2310 2
a2311 16
                if (res->RENAME3res_u.resok.fromdir_wcc.after.attributes_follow)
                {
                        update_attrcache(mount_point, from_dir, &res->RENAME3res_u.resok.fromdir_wcc.after.post_op_attr_u.attributes, Yes );
                }
                else
                {
                        cancel_attr_cache_by_fhandle( from_dir );
                }
                if (res->RENAME3res_u.resok.todir_wcc.after.attributes_follow)
                {
                        update_attrcache(mount_point, to_dir, &res->RENAME3res_u.resok.todir_wcc.after.post_op_attr_u.attributes, Yes );
                }
                else
                {
                        cancel_attr_cache_by_fhandle( to_dir );
                }
d2401 1
a2401 1
                update_attrcache( mount_point, dir, &cres->MKDIR3res_u.resok.dir_wcc.after.post_op_attr_u.attributes, Yes );
d2466 1
a2466 8
                if (res->RMDIR3res_u.resok.dir_wcc.after.attributes_follow)
                {
                        update_attrcache(mount_point, dir, &res->RMDIR3res_u.resok.dir_wcc.after.post_op_attr_u.attributes, Yes );
                }
                else
                {
                        cancel_attr_cache_by_fhandle( dir );
                }
d2492 1
a2492 1
        fattr3 *nattr
d2496 3
a2498 2
                lookupcache_hash(mount_point, dir, filename), attrcache_hash(mount_point, file), mount_point));
        update_attrcache(mount_point, file, nattr, No);
@


4.6.2.3
log
@  *Histogram filesystem command added to dump out the cache histograms.
Detail:
  Works - shows the distribution of the cache entries in the hash table.
Admin:
  Builds.


Version 3.18, 4.22.2.4. Tagged as 'NFS-3_18-4_22_2_4'
@
text
@a2627 24


/* histogram debugging */

static void do_show_histogram(hashtable *h)
{
  int bucket;
  cache_entry *e;

  for (bucket = 0; bucket < NumBuckets; ++bucket) {
    for (e = h->bucket[bucket].generic; e; e = e->next.generic) {
      lightweight_printf("*");
    }
    lightweight_printf("\n");
  }
}

void show_histogram(void)
{
  lightweight_printf("NFS attribute cache histogram\n");
  do_show_histogram(&attr_hash_table);
  lightweight_printf("\nNFS lookup cache histogram\n");
  do_show_histogram(&lookup_hash_table);
}
@


4.5
log
@  Hopefully fixed the "Bad parameters passed internally" error.
  Fixed a miscall that probably causes a memory leak.
Detail:
  There is a hacky routine that is used to support scatter writes (used
    to support ,lxa files - ie. those with explicit load&exec addresses
    instead of filetypes & datestamp) which wasn't working properly -
    the count of data (new in the NFS3 packet for NFSPROC3_WRITE) didn't
    match the opaque data size and the NFS server rejected the command.
    The count now has sizeof(appendum) added which solves the problem.
  The test is to attempt OS_File 7 with a load&exec address not representing
    a valid filetype+datestamp format.  This will fail on NFS 3.10 and
    succeed on NFS 3.11.
Admin:
  Tested only against NFS3 servers.

Version 3.11. Tagged as 'NFS-3_11'
@
text
@a858 1
                        return err;
d860 4
a863 2

                update_lookupcache_at( mount_point, dir, filename, hashval, fhandle );
@


4.4
log
@  Fixed potential use of uninitialised pointer.
Detail:
  If the LOOKUP remote procedure chose not to supply the optional
    object attributes in its result, the attribute pointer would
    remain uninitialised and be treated as safe to use.  This can
    no longer occur.
  All but the unused static rcsid variable compile warnings removed.
Admin:
  Requires AsmUtils 0.06 or later.
  Requires Library 0.39 or later (for rpcgen 0.03 or later)
  Built and tested on Risc PC.

Version 3.07. Tagged as 'NFS-3_07'
@
text
@d1425 1
a1425 1
        wargs.count = count;
d1441 1
a1441 1
                xdr_free(xdr_WRITE3args, wres);
d1443 1
a1443 1
        wres = nfsproc3_write_with_appendum_3( &wargs, nfs_client );
@


4.3
log
@  Attribute cacheing preload bug fixed.
  Debugging all switched to DebugLib-style.
Detail:
  The attribute cache preloading was failing to take effect because
    the hash value generation was giving the attribute cache preload
    function different answers to those it gave any other functions.
    This has now been fixed.
  Debugging support replaced completely by DebugLib support.
  The automatically generated RPC veneers do not contain any debugging
    (although it could be added by rpcgen - a beta version of rpcgen
    exists that writes DebugLib veneers into the stubs to note all RPC
    calls made via the stubs.  These functions do not, however, unpack
    the parameters and return structures yet.  That would be a massive
    job, requiring changes to all hand-written XDR functions - rpcgen
    could arrange to generate appropriate stuff for anything it writes,
    though)
  Removed obsolete db.c and db.h files.
  TaskObey script added to build the debugging version of the module.
Admin:
  This module has been tested on desktop machines for several months.
    The massive speedup expected from the use of NFS protocol version 3
    is now being noticed on directory operations,

Version 3.01. Tagged as 'NFS-3_01'
@
text
@d774 1
a774 1
	dprintf(("cache_3", "nfs_lookup_basic (L%02d) >>%s<< (MP=%p)\n", hashval, filename, mount_point));
d796 2
a797 2
        dprintf(("cache_3", "Cache miss (%s) (M=%d;D=%d;N=%d;T=%d) (%p .. %p)\n", filename,
 		lookupcache[ hashval ].mount_point == mount_point,
a838 2
        if (dres->LOOKUP3res_u.resok.obj_attributes.attributes_follow)
                *nattr = &dres->LOOKUP3res_u.resok.obj_attributes.post_op_attr_u.attributes;
d840 1
a840 2
        update_lookupcache_at( mount_point, dir, filename, hashval, fhandle );
        if (dres->LOOKUP3res_u.resok.obj_attributes.attributes_follow)
d842 2
d848 15
a862 1
                cancel_all_caches_by_fhandle(fhandle);
d950 1
d955 7
@


4.2
log
@  Now supports NFS version 3.
Detail:
  All client-server calls now use the superior NFS3 protocol.
  This particularly benefits directory enumeration and *NFSInfo
    is now reporting 80%+ cache hit rates which is a significant
    improvement (over 5% better - some hosts report 85%+)
  Hashing algorithms improved to increase cache hits (the cache
    algorithm doesn't use parts of names after a comma, so that
    the hash value for !Run is the same as the hash value for
    !Run,feb - which helps the cache hit rate a lot).   Directory
    browsing on the desktop appears noticably faster too.
  The module now has the original protocol (.x) files defining
    the RPC protocols being used (NFS, mount, pcnfs, rquota)
    and uses them to generate header files, XDR implementations,
    and client stubs automatically, instead of having hand
    written versions.
  NFS workspace comes from a dynamic area where possible.
Admin:
  Supporting documentation:
    Acorn NFS Software Functional Specification (1215,250/FS)
    RFC1014, RFC1057, RFC1094, RFC1813
  Tested in several desktop machines for everyday use against
    both NFS2 and NFS3 servers.
  Requires rpcgen 0.01 or later
    (CVS source: Tools/Sources/rpcgen  tag: rpcgen-0_01 or later)
    (CVS binary: RiscOS/Library  tag: Library-0_19 or later)
  Requires TCPIPLibs 5.13 or later
    (CVS: RiscOS/Sources/Lib/TCPIPLibs  tag: TCPIPLibs-5_13)

Version 3.00. Tagged as 'NFS-3_00'
@
text
@d250 2
d275 1
d318 1
d423 1
d709 1
d774 2
d781 1
d796 6
d892 2
d1864 3
@


4.1
log
@Initial revision
@
text
@d48 1
d64 1
d108 1
a108 1
        nfs_fh fhandle;
d110 1
a110 1
        fattr nattr;
d117 1
a117 1
        nfs_fh dir;
d120 1
a120 1
        nfs_fh fhandle;
d193 1
a193 1
static int attrcache_hash(MountPoint *mount_point, nfs_fh *fhandle)
d203 1
a203 1
                i < FHSIZE;
d206 1
a206 1
                hash_val = (hash_val << 1) ^ (hash_val >> 31) ^ fhandle->data[i];
d229 1
a229 1
static int lookupcache_hash(MountPoint *mount_point, nfs_fh *dir, char *nfs_name)
d237 1
a237 1
                i < FHSIZE;
d240 1
a240 1
                hash_val = ((hash_val << 1) | (hash_val >> 31)) + dir->data[i];
d244 1
a244 1
                nfs_name[ i ];
d271 1
a271 1
static void update_attrcache_at(MountPoint *mount_point,nfs_fh *fhandle, int hash_val, fattr *nattr)
d274 1
a274 1
        attrcache[ hash_val ].fhandle = *fhandle;
d295 1
a295 1
static void update_attrcache( MountPoint *mount_point, nfs_fh *fhandle, fattr *nattr)
d337 1
a337 1
static void cancel_lookupcache( MountPoint *mount_point, nfs_fh *dir, char *nfs_name )
d357 1
a357 1
static void cancel_lookupcache_by_fhandle( nfs_fh *fhandle )
d365 1
a365 1
                if ( memcmp( &lookupcache[ i ].fhandle, fhandle, sizeof( nfs_fh )) == 0 )
d438 1
a438 1
static void cancel_attrcache_by_fhandle( nfs_fh *fhandle )
d446 1
a446 1
                if ( memcmp( &attrcache[ i ].fhandle, fhandle, sizeof( nfs_fh )) == 0 )
d496 1
a496 1
void cancel_all_caches_by_fhandle( nfs_fh *fhandle )
d529 1
a529 1
	  cache.  Flushes all caches if data is stale (NFSERR_STALE)
d540 1
a540 1
_kernel_oserror *nfs_getattr( fattr **nattr, MountPoint *mount_point, nfs_fh *fhandle)
d544 2
a545 1
        attrstat *getattr_res;
d554 1
a554 1
             memcmp( &attrcache[ hash_val ].fhandle, fhandle, sizeof( *fhandle )) == 0 &&
d569 12
a580 1
        getattr_res = nfsproc_getattr_2( fhandle, nfs_client->client );
d592 1
a592 1
        update_attrcache_at( mount_point, fhandle, hash_val, &getattr_res->attrstat_u.attributes );
d605 1
a605 1
	  Flushes all caches if data is found to be stale (NFSERR_STALE).
d618 1
a618 1
_kernel_oserror *nfs_setattr( fattr **nattrres, MountPoint *mount_point, nfs_fh *fhandle, sattr *nattr)
d621 2
a622 2
        sattrargs sargs;
        attrstat *sres;
d635 6
a640 2
        sargs.file = *fhandle;
        sargs.attributes = *nattr;
d642 8
a649 1
        sres = nfsproc_setattr_2( &sargs, nfs_client->client );
d665 9
a673 3
        update_attrcache( mount_point, fhandle, &sres->attrstat_u.attributes );

        *nattrres = &sres->attrstat_u.attributes;
d700 2
a701 2
static void update_lookupcache_at( MountPoint *mount_point, nfs_fh *dir,
                                   char *nfs_name, int hashval, nfs_fh *fhandle)
d709 2
a710 2
                lookupcache[ hashval ].dir = *dir;
                lookupcache[ hashval ].fhandle = *fhandle;
d731 1
a731 1
static void update_lookupcache( MountPoint *mount_point, nfs_fh *dir, char *nfs_name, nfs_fh *fhandle)
d759 2
a760 2
static _kernel_oserror *nfs_lookup_basic( nfs_fh *fhandle, fattr **nattr,
                           MountPoint *mount_point, nfs_fh *dir, char *filename)
d763 2
a764 2
        diropargs dargs;
        diropres *dres;
d769 1
a769 1
                memcmp( &lookupcache[ hashval ].dir, dir, sizeof( *dir )) == 0 &&
d774 1
a774 1
                *fhandle = lookupcache[ hashval ].fhandle;
d788 2
a789 2
        dargs.dir = *dir;
        dargs.name = filename;
d795 11
a805 1
        dres = nfsproc_lookup_2( &dargs, nfs_client->client );
d823 3
a825 2
        *fhandle = dres->diropres_u.diropres.file;
        *nattr = &dres->diropres_u.diropres.attributes;
d828 8
a835 1
        update_attrcache( mount_point, fhandle, *nattr );
d859 2
a860 2
_kernel_oserror *nfs_lookup( nfs_fh *fhandle, fattr **nattr, MountPoint *mount_point,
                                            nfs_fh *dir, char *filename)
d863 1
a863 1
        nfs_fh *used_dir = dir;
d868 1
a868 1
        readlinkres *rlres;
d873 1
a873 1
        nfs_fh last_dir_found;
d929 1
a929 1
                switch ( (*nattr)->mode & NFSMODE_FMT )
d931 1
a931 1
                case NFSMODE_LNK:
d950 11
a960 1
                        rlres = nfsproc_readlink_2( fhandle, nfs_client->client );
d977 1
a977 1
                                used_filename_len = strlen( rlres->readlinkres_u.data );
d987 1
a987 1
                                strcpy( used_filename, rlres->readlinkres_u.data );
d1000 1
a1000 1
                                link_len = strlen( rlres->readlinkres_u.data );
d1018 1
a1018 1
                                        rlres->readlinkres_u.data,
d1046 1
a1046 1
                                last_dir_found = *fhandle;
d1081 1
a1081 1
	  (NFSERR_STALE), then all cache entries for that file are cancelled.
d1097 1
a1097 1
                                         nfs_fh *fhandle, unsigned offset, int count)
d1100 3
a1102 3
        readargs rargs;
        readres *rres;
        readres res;
d1105 2
a1106 2
        rargs.file = *fhandle;
        rargs.offset = offset;
d1108 1
a1108 1
        res.readres_u.reply.data.data_val = readres_data;
d1127 13
a1139 9

        if ( clnt_call( nfs_client->client, NFSPROC_READ, xdr_readargs, &rargs, xdr_readres, &res, TIMEOUT ) != RPC_SUCCESS )
        {
                rres = NULL;
        }
        else
        {
                rres = &res;
        }
d1159 1
a1159 1
        *readres_len = rres->readres_u.reply.data.data_len;
d1161 2
a1162 1
        update_attrcache( mount_point, fhandle, &rres->readres_u.reply.attributes );
d1191 1
a1191 1
                                      nfs_fh *fhandle, unsigned offset, int count)
d1193 1
a1193 1
        fattr nattr;
d1216 1
a1216 1
	  detected  (NFSERR_STALE), then all cache entries for that file are
d1231 2
a1232 2
_kernel_oserror *nfs_write( fattr **nattr, MountPoint *mount_point, nfs_fh *fhandle,
                                   unsigned offset, char *data, int count)
d1235 2
a1236 2
        writeargs wargs;
        attrstat *wres;
d1239 4
a1242 2
        wargs.file = *fhandle;
        wargs.offset = offset;
d1257 11
a1267 1
        wres = nfsproc_write_2( &wargs, nfs_client->client );
d1286 9
a1294 3
        *nattr = &wres->attrstat_u.attributes;

        update_attrcache( mount_point, fhandle, &wres->attrstat_u.attributes );
d1305 1
a1305 1
	  from.  If stale data is  detected  (NFSERR_STALE), then all cache
d1322 1
a1322 1
        fattr **nattr,
d1324 2
a1325 2
        nfs_fh *fhandle,
        unsigned offset,
d1352 1
a1352 1
	  detected  (NFSERR_STALE), then all cache entries for that file are
d1371 1
a1371 1
        fattr **nattr,
d1373 2
a1374 2
        nfs_fh *fhandle,
        unsigned offset,
d1380 2
a1381 2
        writeargs_with_appendum wargs;
        attrstat *wres;
d1384 4
a1387 2
        wargs.file = *fhandle;
        wargs.offset = offset;
d1402 4
a1405 1
        wres = nfsproc_write_with_appendum_2( &wargs, nfs_client->client );
d1424 9
a1432 3
        *nattr = &wres->attrstat_u.attributes;

        update_attrcache( mount_point, fhandle, &wres->attrstat_u.attributes );
d1460 2
a1461 2
        nfs_fh *fhandle,
        fattr **nattr,
d1463 1
a1463 1
        nfs_fh *dir,
d1465 1
a1465 1
        sattr *snattr
d1469 2
a1470 2
        createargs cargs;
        diropres *cres;
d1483 1
a1483 1
        cargs.where.dir = *dir;
d1485 2
a1486 1
        cargs.attributes = *snattr;
d1488 10
a1497 1
        cres = nfsproc_create_2( &cargs, nfs_client->client );
d1509 6
a1514 4
        *fhandle = cres->diropres_u.diropres.file;
        *nattr = &cres->diropres_u.diropres.attributes;

        update_attrcache( mount_point, fhandle, *nattr );
d1520 5
a1524 1
        cancel_attrcache_by_fhandle( dir );
d1548 1
a1548 1
        nfs_fh *dir,
d1553 2
a1554 1
        diropargs rargs;
d1557 2
a1558 2
        rargs.dir = *dir;
        rargs.name = filename;
d1563 11
a1573 2

        err = rpcnfs_to_riscos_err( nfsproc_remove_2( &rargs, nfs_client->client ), mount_point, nfs_client->client );
d1613 1
a1613 1
        nfs_fh *to_dir,
d1615 1
a1615 1
        nfs_fh *from_dir,
d1620 2
a1621 1
        renameargs rargs;
d1624 1
a1624 1
        rargs.from.dir = *from_dir;
d1626 1
a1626 1
        rargs.to.dir = *to_dir;
d1633 11
a1643 1
        err = rpcnfs_to_riscos_err( nfsproc_rename_2( &rargs, nfs_client->client ), mount_point, nfs_client->client );
d1692 2
a1693 2
        nfs_fh *fhandle,
        fattr **nattr,
d1695 1
a1695 1
        nfs_fh *dir,
d1697 1
a1697 1
        sattr *snattr
d1701 2
a1702 2
        createargs cargs;
        diropres *cres;
d1715 1
a1715 1
        cargs.where.dir = *dir;
d1719 10
a1728 1
        cres = nfsproc_mkdir_2( &cargs, nfs_client->client );
d1740 3
a1742 2
        *fhandle = cres->diropres_u.diropres.file;
        *nattr = &cres->diropres_u.diropres.attributes;
d1752 5
a1756 1
        cancel_attrcache_by_fhandle( dir );
d1778 1
a1778 1
        nfs_fh *dir,
d1783 2
a1784 1
        diropargs rargs;
d1787 2
a1788 2
        rargs.dir = *dir;
        rargs.name = filename;
d1794 11
a1804 1
        err = rpcnfs_to_riscos_err( nfsproc_rmdir_2( &rargs, nfs_client->client ), mount_point, nfs_client->client );
d1824 26
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@

head	4.10;
access;
symbols
	NFS-3_27:4.10
	NFS-3_26:4.10
	NFS-3_25:4.10
	NFS-3_24:4.9
	NFS-3_23:4.9
	NFS-3_22:4.7
	NFS-3_21:4.7
	NFS-3_20:4.7
	NFS-3_19:4.7
	sbrodie_NFS_dev_merge:4.6.2.2
	NFS-3_18-4_22_2_4:4.6.2.2
	NFS-3_18-4_22_2_3:4.6.2.1
	NFS-3_18-4_22_2_2:4.6
	NFS-3_18-4_22_2_1:4.6
	sbrodie_NFS_dev:4.6.0.2
	sbrodie_NFS_dev_bp:4.6
	NFS-3_18:4.6
	NFS-3_17:4.6
	NFS-3_16:4.6
	NFS-3_15:4.6
	NFS-3_14:4.6
	NFS-3_13:4.6
	NFS-3_12:4.6
	NFS-3_11:4.6
	NFS-3_10:4.6
	NFS-3_09:4.6
	NFS-3_08:4.6
	NFS-3_07:4.6
	NFS-3_06:4.6
	NFS-3_05:4.6
	NFS-3_04:4.5
	NFS-3_02:4.5
	NFS-3_01:4.5
	NFS-3_00:4.4
	NFS-2_37:4.3
	NFS-2_36:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.10
	NFS-2_35:4.3
	Spin_merge:4.1.7.1
	Spinner_23Sep1998_destend:4.2
	Spinner_23Sep1998_srcend:4.1.7.1
	Spinner_23Sep1998_srcbegin:4.1.7.1
	Spinner_23Sep1998_destbegin:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.8
	Ursula_13May1998_bp:4.1
	Ursula_13May1998:4.1.0.4
	rthornb_UrsulaBuild_01May1998:4.1
	pwombwel_2_32:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	MergeFiles:4.1.7.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1;
locks; strict;
comment	@# @;


4.10
date	2018.03.07.21.22.40;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	sKJZhgBEKf2WsztA;

4.9
date	2018.01.30.09.05.21;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	Hg37nwvmck2nxSoA;

4.8
date	2018.01.29.21.30.18;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	7TGUL0NEVVbjHOoA;

4.7
date	2003.12.10.14.55.09;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	99.12.06.15.58.02;	author sbrodie;	state Exp;
branches
	4.6.2.1;
next	4.5;

4.5
date	99.10.13.09.53.53;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	99.05.14.12.42.06;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	98.11.13.16.07.05;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	98.10.22.18.03.50;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.22.14.49.28;	author nturton;	state Exp;
branches
	4.1.5.1
	4.1.7.1;
next	;

4.6.2.1
date	2001.06.18.12.31.25;	author sbrodie;	state Exp;
branches;
next	4.6.2.2;

4.6.2.2
date	2001.07.02.11.04.32;	author sbrodie;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.49.28;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.06.39;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Store lxa files verbatim, without appendum
Files saved with load & exec address (as opposed to a filetype and the top nybble of load set to 0xFFF) would be extended by 8 bytes in order to hide the true load/exec for later retrieval.
While useful if only ever saving and retrieving from the RISC OS viewpoint, it would create apparently corrupt or overlong file if you wanted to do any analysis on the NFS server end. Given load/exec addresses are deprecated, change NFS to behave like LanManFS and just denote ",lxa" suffixed files with the appropriate icon in the Filer and a made up load/exec address.

pathmunge.c/_GBPB.c/V2support.c/_Args.c/_File.c/PutBytesX.c/Static.c/Changeinfo.c: Switch out 8 byte appending code. Give the file a proper date stamp instead when viewed on Unix.
_Open.c: Switch out the 8 byte appendum stuff, and use a common OS_Word 14 clock function.
Statics.h/Modulewrap.c: Compute a substitute load/exec using the same algorithm as LanManFS (the Kernel's address rounded down to 1MB). Use cmhg finalise function instead of atexit().

Also
MakeFile: pass in predefine DEBUG for debug builds.
cmhg/NFSHdr: remove *Histogram debug command except when debugging. Add finalise handler.
Commands.c/Commands.h: remove *Histogram debug command except when debugging.
Utils.c: delete unused long long support functions. Add a new time getting support function.
Utils.h: new time getting support function.

Tested with a handful of area saves using *Save, checking the file size when viewed at the server end was correct not 8 bytes longer.

Version 3.25. Tagged as 'NFS-3_25'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*	MODULEWRAP

Purpose : Sets uo all the module-type things for NFS

History :
Date	Who    Comments
-----------------------------------------------------------------------------
4/7/89   JSR   Copied from Filer.c.modulewrap

13/2/95  CP    Now opens/closes debug stream pipe:debug
23/2/95  KSR   Added support for *nfs_boot
06/2/96  KJB   Merged NFS and STBNFS into single source tree
09/2/96  DNW   Changed the *cmd handler (nfs_command)
                1) So it would appear on a zap function name lookup
                2) So that it handled the New commands :-)
****************************************************************************/

#include "NFSHdr.h"

#ifndef _NFSNFS_H
#include "nfsheaders.h"
#endif
#include "Global/ModHand.h"
#include "TimeOut.h"

#include <locale.h>
#include "memory.h"


struct timeval TIMEOUT = { 25, 0 }; /* is the timeout for nfs functions  */
struct timeval TIMERETRY = { 5, 0 }; /* is the retry timeout interval */

/*
        This is the SWI handler

SWI definitions:

NFS_Mount
In:     r0 -> host name (if NULL this means current mounting host)
        r1 -> mount name
        r2 -> mount path
Out:    mount point mounted or error; registers unchanged.

NFS_MountList
In:     r0 -> host name or NULL
        r1 -> previous mount name or NULL to start the listing
Out:    possible error if host speicifed does not exist
        r1 -> next mount name after one passed in, in alphabetical order
                list of mount points returned are for host list
                or for total mount point list if r0 = NULL on entry

NFS_SetUser
In:     r0 -> host name for nameing host - NULL means use current nameing host
        r1 -> username; if "nobody" no password is needed - NULL means just set nameing host
        r2 -> user password
Out:    error if user not verified on host

NFS_Dismount
In:     r0 -> host name
        r1 -> mount name
Out:    Specified mount point(s) dismounted. It is an error
        to specify both host and mount point.

NFS_MountInfo
In:     r1 -> mount name
Out:    r0 -> mount point's host's name
        r1 -> mount name (ie unchanged from entry)
        r2 -> mount path
        r3 -> user name used for mount point
        r4 -> host name used for verification and details of user

NFS_FreeSpace
In:     r1 -> mount name
Out:    r0 = total non-privileged free space available
        r1 -> mount name (unchanged)
        r2 = total size of disc
        R3 = total unused size of disc

NFS_FreeSpace64
In:     r0 = 4 (Free module's reason code)
        r1 = NFS filing system id
        r2 -> pointer to 6 word buffer
        r3 -> mount name
Out:    r0 = 0
        all other registers preserved

*/
_kernel_oserror *nfs_swi
(
        int swi_number,
        _kernel_swi_regs *r,
        void *private_word
)
{
        _kernel_oserror *err = NULL;
        MountPoint *mount_point;
        Chain_Link *link;

        private_word = private_word;

        hourglass_on();

        switch ( swi_number )
        {
        case NFS_Mount - NFS_00:
                if ( r->r[1] == NULL )
                {
                        err = mb_swi_mount_invalid_parameters;
                }
                else
                {
                        if ( strchr( (char *)r->r[0], ' ' ) != NULL || strchr( (char *)r->r[0], ':' ) != NULL )
                                err = mb_no_spaces_in_mount_name;

                        if ( !err )
                                err = nfs_mount( (char *)r->r[0], (char *)r->r[1], (char *)r->r[2] );
                }
                break;

        case NFS_MountList - NFS_00:
                /*
                        If a host is specified then find it and start through its mount point list
                */
                if ( r->r[0] != 0 )
                {
                        for ( link = host_list.forwards;
                                link->forwards != NULL &&
                                        strcmp( ((Host *)Link_Wrapper( link ))->host_name, (char *)r->r[0] ) != 0;
                                link = link->forwards )
                        {
                                /* do nothing */
                        }

                        if ( link->forwards == NULL )
                        {
                                err = mb_no_host_found;
                                break;
                        }

                        link = ((Host *)Link_Wrapper( link ))->mount_points.forwards;
                }
                else
                {
                        link = mount_point_list.forwards;
                }

                /*
                        If not starting through list then step through the list until we find an entry
                        greater than the one we've been given.
                */
                if ( r->r[1] != NULL )
                {
                        for ( ;
                                link->forwards &&
                                        caseless_strcmp( ((MountPoint *)Link_Wrapper( link ))->mount_point_name, (char *)r->r[1] ) <= 0;
                                link = link->forwards )
                        {
                                /* do nothing */
                        }
                }

                /*
                        Fill in the result as appropriate
                */
                if ( link->forwards )
                {
                        r->r[1] = (int)((MountPoint *)Link_Wrapper( link ))->mount_point_name;
                }
                else
                {
                        r->r[1] = NULL;
                }
                break;

        case NFS_SetUser - NFS_00:
                err = new_host( &current_nameing_host, (char *)r->r[0] );

                if ( !err && r->r[1] )
                {
                        err = process_nfsname( (char *)r->r[1], (char *)r->r[2] );
                }
                break;

        case NFS_Dismount - NFS_00:
                if ( r->r[0] != 0 )
                {
                        if ( r->r[1] != 0 )
                        {
                                /*
                                        Dismount host and mount point - its ambiguous
                                */
                                err = mb_swi_dismount_ambiguous_parameters;
                        }
                        else
                        {
                                /*
                                        Dismount host
                                */
                                for ( link = host_list.forwards;
                                        link->forwards != NULL &&
                                                strcmp( ((Host *)Link_Wrapper( link ))->host_name, (char *)r->r[0] ) != 0;
                                        link = link->forwards )
                                {
                                        /* do nothing */
                                }

                                if ( link->forwards )
                                {
                                        err = nfs_dismount_host( Link_Wrapper( link ));
                                }
                                else
                                {
                                        err = mb_no_host_found;
                                }
                        }
                }
                else
                {
                        if ( r->r[1] != 0 )
                        {
                                /*
                                        Dismount mount point
                                */
                                mount_point = find_mount( (char *)r->r[1] );
                                if ( mount_point == NULL )
                                {
                                        err = mb_no_mount_point_found;
                                }
                                else
                                {
                                        err = nfs_dismount( mount_point );
                                }
                        }
                        else
                        {
                                err = nfs_dismount_all();
                        }
                }
                break;

        case NFS_MountInfo - NFS_00:
                if ( r->r[1] != 0 )
                {
                        mount_point = find_mount( (char *)r->r[1] );
                        if ( mount_point != NULL )
                        {
                                r->r[0] = (int)mount_point->host->host_name;
                                r->r[2] = (int)mount_point->mount_path;
                                r->r[3] = (int)mount_point->user->name;
                                if ( mount_point->user->host )
                                        r->r[4] = (int)mount_point->user->host->host_name;
                                else
                                        r->r[4] = (int)"";
                        }
                        else
                        {
                                err = mb_no_mount_point_found;
                        }
                }
                else
                {
                        err = mb_no_mount_point_found;
                }
                break;

        case NFS_FreeSpace - NFS_00:
                        {
                        utils_spacestr space;
                        err = utils_getfsspace( &space, (char *)r->r[1] );
                        if (space.active_quota)
                        {
                                long free = (space.sp.quota.space.slim > space.sp.quota.space.usage)
                                                ? space.sp.quota.space.slim - space.sp.quota.space.usage
                                                : 0;
                                r->r[2] = (int)space.sp.quota.space.slim;
                                r->r[0] = (int)free;
                                r->r[3] = (int)space.sp.quota.space.slim - (int)space.sp.quota.space.usage;
                             /* r3 is arranged so that (r2 - r3) gives usage, which is what the
                              * free display is trying to derive */
                        }
                        else
                        {
                                /* the interface allows me to do nothing about these wrapping negative when multiplied */
                                r->r[0] = (int)(((int)space.sp.statfs.bavail>0) ? space.sp.statfs.bavail*space.sp.statfs.bsize : 0);
                                r->r[2] = (int)(((int)space.sp.statfs.blocks>0) ? space.sp.statfs.blocks*space.sp.statfs.bsize : 0);
                                r->r[3] = (int)(((int)space.sp.statfs.bfree>0) ? space.sp.statfs.bfree*space.sp.statfs.bsize : 0);
                        }

                        }
                break;

        case NFS_FreeSpace64 - NFS_00:
                        {
                        utils_spacestr space;
                        struct r2 {
                          u_int64_t total;
                          u_int64_t free;
                          u_int64_t used;
                        } *r2 = (struct r2 *)(r->r[2]);
                        err = utils_getfsspace( &space, (char *)r->r[3] );
                        if (err == NULL) r->r[0] = 0;
                        if (space.active_quota)
                        {
                                long free = (space.sp.quota.space.slim > space.sp.quota.space.usage)
                                                ? space.sp.quota.space.slim - space.sp.quota.space.usage
                                                : 0;
                                ui64_multiply_uu(&r2->total, space.sp.quota.space.slim,  space.sp.quota.space.bsize);
                                ui64_multiply_uu(&r2->free,  free,                       space.sp.quota.space.bsize);
                                ui64_multiply_uu(&r2->used,  space.sp.quota.space.usage, space.sp.quota.space.bsize);
                             /* r3 is arranged so that (r2 - r3) gives usage, which is what the
                              * free display is trying to derive */
                        }
                        else
                        {
                                ui64_multiply_uu(&r2->free,  space.sp.statfs.bavail, space.sp.statfs.bsize);
                                ui64_multiply_uu(&r2->total, space.sp.statfs.blocks, space.sp.statfs.bsize);
                                ui64_subtract_u64u64(&r2->used, &r2->total, &r2->free);
                        }

                        }
                break;

        default:
                break;
        }

        hourglass_off();

        return err;
}

static void junk_host_list
(
        void
)
{
        while( host_list.forwards->forwards )
        {
                (void)release_host( Link_Wrapper( host_list.forwards ));
        }
}

static void junk_user_list
(
        void
)
{
        while ( user_list.forwards->forwards )
        {
                (void)release_user( Link_Wrapper( user_list.forwards ));
        }
}

/*
        This is the finalisation code for NFS
*/
_kernel_oserror *nfs_finalise
(
        int fatal,
        int podule,
        void *pw
)
{
        nfs_dismount_all();

        junk_user_list();
        junk_host_list();

        (void)extensions_dispose();

        (void)_swix(OS_FSControl, _INR(0,1), FSControl_RemoveFilingSystem,
                                             NFSFilingSystemName );
        pw = pw;
        podule = podule;
        fatal = fatal;

        free_cache();
	memory_finalise();

        return NULL;
}

/*
        Declare NFS to FileSwitch
*/
static _kernel_oserror *declare_nfs
(
        void *private_word
)
{
        _kernel_oserror *err;
        int information_block[ Information_Block_Size ];

        /*
                Attach ourselves to FileSwitch
        */
        information_block[0] = (int)"NFS"                       - (int)Image_RO_Base;
#ifdef NFSSTB
        information_block[1] = (int)"OnLine Media Set-top NFS"  - (int)Image_RO_Base;
#else
        information_block[1] = (int)"Acorn RISC OS NFS"         - (int)Image_RO_Base;
#endif
        information_block[2] = (int)&veneer_fsentry_open        - (int)Image_RO_Base;
        information_block[3] = (int)&veneer_fsentry_getbytes    - (int)Image_RO_Base;
        information_block[4] = (int)&veneer_fsentry_putbytes    - (int)Image_RO_Base;
        information_block[5] = (int)&veneer_fsentry_args        - (int)Image_RO_Base;
        information_block[6] = (int)&veneer_fsentry_close       - (int)Image_RO_Base;
        information_block[7] = (int)&veneer_fsentry_file        - (int)Image_RO_Base;
        information_block[8] = Information_Word;
        information_block[9] = (int)&veneer_fsentry_func        - (int)Image_RO_Base;
        information_block[10] = (int)&veneer_fsentry_gbpb       - (int)Image_RO_Base;
        /*information_block[11] = Extra_Information_Word;*/

        err = _swix(OS_FSControl, _INR(0,3), FSControl_AddFilingSystem,
                                             Image_RO_Base,
                                             (char *)information_block - (char *)Image_RO_Base,
                                             private_word);
        if ( err )
                return err;

        /*
                Say hello to the world
        */
        return _swix(OS_ServiceCall, _IN(1), Service_NFS);
}

/*
        This is the initialisation code for NFS
*/
_kernel_oserror *nfs_initialise
(
        const char *cmd_tail,
        int podule_base,
        void *private_word
)
{
        _kernel_oserror *err;
        char sysvar_buffer[ 20 ];
        char *dummy;

    	debug_initialise("NFS", "", "");
    	debug_atexit();
    	debug_set_options(0, 0, 0);
    	debug_output_device(PRINTF_OUTPUT);

#ifdef TRACE_ENABLED
    	debug_initialise_trace (PRINTF_OUTPUT, "");
#endif

	err = memory_initialise();
	if ( err )
	        return err;

        cmd_tail = cmd_tail;
        podule_base = podule_base;

        setlocale(LC_ALL, "");

        initialise_header( &mount_point_list );
        initialise_header( &host_list );
        initialise_header( &user_list );
        current_nameing_host = NULL;
        current_mounting_host = NULL;

        current_user = NULL;

        /*
                Current user should always be nobody
        */
        err = new_user( &current_user, User_Nobody, NULL, UNIX_MagicNumber_UID_Nobody, UNIX_MagicNumber_GID_Nobody, authunix_create_default(),
                0, NULL, -1);
        if ( err )
                return err;

        err = extensions_read();
        if ( err )
        {
                junk_user_list();
                return err;
        }

        err = declare_nfs( private_word );
        if ( err )
        {
                extensions_dispose();
                junk_user_list();
                return err;
        }

        if ( !_kernel_getenv( NFSTruncateLengthVariable, sysvar_buffer, 20 ) )
        {
                sysvar_buffer[ 19 ] = '\0';
                max_riscos_name_length = (int)strtol( sysvar_buffer, &dummy, 0 );
        }

       if ( !_kernel_getenv( NFSTimeoutVariable, sysvar_buffer, 20 ) )
        {
                sysvar_buffer[ 19 ] = '\0';
                TIMEOUT.tv_sec = strtol( sysvar_buffer, &dummy, 0 );
        }

       if ( !_kernel_getenv( NFSCacheSizeVariable, sysvar_buffer, 20 ) )
        {
                sysvar_buffer[ 19 ] = '\0';
                err = set_cache_size((int)strtol( sysvar_buffer, &dummy, 0 ));
        }
        else
		err = set_cache_size(0);

#ifndef LXA_BY_APPENDUM
        /*
                Get kernel base as a substitute load/exec address
                which would abort if attempting to load there
        */
        _swix(OS_Module, _INR(0,2) | _OUT(3),
              ModHandReason_GetNames, 0, 0,
              &untyped_address);
        untyped_address = (untyped_address >> 20) << 20;
#endif               

        /*
                Set defaults for *TypesBase and *CacheTime
        */
        out_of_date_time = CacheOutOfDateTime;

        return err;
}

/*
        NFS service handler
*/
void nfs_service
(
        int service_number,
        _kernel_swi_regs *r,
        void *private_word
)
{
        r = r;

        switch( service_number )
        {
        case Service_FSRedeclare:
                declare_nfs( private_word );
                break;
        }
}

/*
        NFS command processor
*/
_kernel_oserror *nfs_command( const char *arg_string, int argc, int cmd_no, void *private_word)
{
        _kernel_oserror *err = NULL;
        char *temptr = my_command_parameter_buffer;

        private_word = private_word;

        /*
                Change the control character terminator to a nul terminator
        */
        for ( ;
              temptr - my_command_parameter_buffer < My_Command_Parameter_Buffer_Len && *arg_string >= ASpace;
              arg_string++ )
        {
                *(temptr++) = *arg_string;
        }

        *temptr = '\0';

        temptr = my_command_parameter_buffer;

        /*
                Switch between the commands
        */
        switch ( cmd_no )
        {
        case CMD_NFS:
                err = command_nfs( temptr, argc );
                break;

        case CMD_Logon:
                err = command_nfsname( temptr, argc );
                break;

        case CMD_Mount:
                err = command_nfsmount( temptr, argc );
                break;

        case CMD_Dismount:
                err = command_nfsdismount( temptr, argc );
                break;

        case CMD_Bye:
                err = nfs_dismount_all();
                if ( !err )
                        err = process_nfsname( User_Nobody, "" );
                break;

        case CMD_Free:
                err = command_free( temptr, argc );
                break;

        case CMD_CacheTime:
                err = command_cachetime( temptr, argc );
                break;

        case CMD_NFSInfo:
                err = command_nfsinfo( temptr, argc );
                break;

        case CMD_NFSBoot:
                err = nfs_boot( );
                break;

        case CMD_CacheSize:
        	err = command_cachesize( temptr, argc);
                break;

#ifdef DEBUG
        case CMD_Histogram:
                show_histogram();
                break;
#endif
        case CMD_Timeout:
                err = command_timeout( temptr, argc );
                break;

		case CMD_PacketSize:
				err = command_packetsize( temptr, argc );
				break;

        default:
                err = lightweight_printf( "Command not recognised by RISC OS NFS\n" );
                break;
        }

        return err;
}
@


4.9
log
@Build fix
Some lingering references to renamed header NFS.h remained in nested headers, renamed.
Retagged as NFS-3_23.
@
text
@d37 1
a37 1

a46 2
extern int atexit( void (*func)( void ));

d371 1
a371 1
static void nfs_finalise
d373 3
a375 1
        void
d387 3
d393 2
d524 10
a533 1
        atexit( nfs_finalise );
d634 1
d636 1
a636 1
                err = command_histogram();
d638 1
a638 1

@


4.8
log
@Export our own SWIs as a header
Use the shared makefiles to export Interface/NFS.h and Hdr:NFS.
Remove local copy NFS.h which confuses the dependency checking, now called nfsheaders.h instead.
Delete unused UID/GID pair.
Tested on a mount from FreeBSD 11.1-RELEASE-p4.

Version 3.23. Tagged as 'NFS-3_23'
@
text
@d32 1
a32 1
#include "nfscmhg.h"
@


4.7
log
@Merged in branch sbrodie_NFS_dev.
Also added -c90 to CFLAGS so that it will build with recent compilers.
Warning: provokes compiler bugs in many recent compilers!

Version 3.19. Tagged as 'NFS-3_19'
@
text
@d35 1
a35 1
#include "NFS.h"
@


4.6
log
@  Now uses PCNFS version 2 to authenticate.
Detail:
  Group-writable directories should now be writable to.
  setgid directories should cause created objects to take on
    the directory group ownership instead of the user's primary
    GIF
  *NFSInfo output enhanced to list all the additional group IDs
    and the default umask being applied to each authentication.
Admin:
  Tested on normal home mount and on TWC mount.

Version 3.05. Tagged as 'NFS-3_05'
@
text
@d94 9
d308 31
d618 4
@


4.6.2.1
log
@  Added new SWI NFS_FreeSpace64
Detail:
  This SWI provides 64-bit free space information to external users.
    It's SWI number is &41506.  It's register usage is identical to
    that of the Free module's reason code 4 (PRM 5a-257)
  If NFS$NoQuotas is set, you will always be shown the disc parameters in
    preference to the quota information.
Admin:
  Desktop builds require Free 0.37 or later to use this new SWI.
  Tested with softloaded Free and NFS - it reports sol's /export/home
    statistics correctly.


Version 3.18, 4.22.2.3. Tagged as 'NFS-3_18-4_22_2_3'
@
text
@a93 9

NFS_FreeSpace64
In:     r0 = 4 (Free module's reason code)
        r1 = NFS filing system id
        r2 -> pointer to 6 word buffer
        r3 -> mount name
Out:    r0 = 0
        all other registers preserved

a293 31
                        }

                        }
                break;

        case NFS_FreeSpace64 - NFS_00:
                        {
                        utils_spacestr space;
                        struct r2 {
                          u_int64_t total;
                          u_int64_t free;
                          u_int64_t used;
                        } *r2 = (struct r2 *)(r->r[2]);
                        err = utils_getfsspace( &space, (char *)r->r[3] );
                        if (err == NULL) r->r[0] = 0;
                        if (space.active_quota)
                        {
                                long free = (space.sp.quota.space.slim > space.sp.quota.space.usage)
                                                ? space.sp.quota.space.slim - space.sp.quota.space.usage
                                                : 0;
                                ui64_multiply_uu(&r2->total, space.sp.quota.space.slim,  space.sp.quota.space.bsize);
                                ui64_multiply_uu(&r2->free,  free,                       space.sp.quota.space.bsize);
                                ui64_multiply_uu(&r2->used,  space.sp.quota.space.usage, space.sp.quota.space.bsize);
                             /* r3 is arranged so that (r2 - r3) gives usage, which is what the
                              * free display is trying to derive */
                        }
                        else
                        {
                                ui64_multiply_uu(&r2->free,  space.sp.statfs.bavail, space.sp.statfs.bsize);
                                ui64_multiply_uu(&r2->total, space.sp.statfs.blocks, space.sp.statfs.bsize);
                                ui64_subtract_u64u64(&r2->used, &r2->total, &r2->free);
@


4.6.2.2
log
@  *Histogram filesystem command added to dump out the cache histograms.
Detail:
  Works - shows the distribution of the cache entries in the hash table.
Admin:
  Builds.


Version 3.18, 4.22.2.4. Tagged as 'NFS-3_18-4_22_2_4'
@
text
@a619 4
        case CMD_Histogram:
                err = command_histogram();
                break;

@


4.5
log
@  Attribute cacheing preload bug fixed.
  Debugging all switched to DebugLib-style.
Detail:
  The attribute cache preloading was failing to take effect because
    the hash value generation was giving the attribute cache preload
    function different answers to those it gave any other functions.
    This has now been fixed.
  Debugging support replaced completely by DebugLib support.
  The automatically generated RPC veneers do not contain any debugging
    (although it could be added by rpcgen - a beta version of rpcgen
    exists that writes DebugLib veneers into the stubs to note all RPC
    calls made via the stubs.  These functions do not, however, unpack
    the parameters and return structures yet.  That would be a massive
    job, requiring changes to all hand-written XDR functions - rpcgen
    could arrange to generate appropriate stuff for anything it writes,
    though)
  Removed obsolete db.c and db.h files.
  TaskObey script added to build the debugging version of the module.
Admin:
  This module has been tested on desktop machines for several months.
    The massive speedup expected from the use of NFS protocol version 3
    is now being noticed on directory operations,

Version 3.01. Tagged as 'NFS-3_01'
@
text
@d439 2
a440 1
        err = new_user( &current_user, User_Nobody, NULL, UNIX_MagicNumber_UID_Nobody, UNIX_MagicNumber_GID_Nobody, authunix_create_default() );
@


4.4
log
@  Now supports NFS version 3.
Detail:
  All client-server calls now use the superior NFS3 protocol.
  This particularly benefits directory enumeration and *NFSInfo
    is now reporting 80%+ cache hit rates which is a significant
    improvement (over 5% better - some hosts report 85%+)
  Hashing algorithms improved to increase cache hits (the cache
    algorithm doesn't use parts of names after a comma, so that
    the hash value for !Run is the same as the hash value for
    !Run,feb - which helps the cache hit rate a lot).   Directory
    browsing on the desktop appears noticably faster too.
  The module now has the original protocol (.x) files defining
    the RPC protocols being used (NFS, mount, pcnfs, rquota)
    and uses them to generate header files, XDR implementations,
    and client stubs automatically, instead of having hand
    written versions.
  NFS workspace comes from a dynamic area where possible.
Admin:
  Supporting documentation:
    Acorn NFS Software Functional Specification (1215,250/FS)
    RFC1014, RFC1057, RFC1094, RFC1813
  Tested in several desktop machines for everyday use against
    both NFS2 and NFS3 servers.
  Requires rpcgen 0.01 or later
    (CVS source: Tools/Sources/rpcgen  tag: rpcgen-0_01 or later)
    (CVS binary: RiscOS/Library  tag: Library-0_19 or later)
  Requires TCPIPLibs 5.13 or later
    (CVS: RiscOS/Sources/Lib/TCPIPLibs  tag: TCPIPLibs-5_13)

Version 3.00. Tagged as 'NFS-3_00'
@
text
@a41 1
#include "DebugLib/DebugLib.h"
a342 4
#ifdef SHOWCALLS
fclose (pipe_debug);
#endif

a421 14

#ifdef SHOWCALLS
pipe_debug = fopen("pipe:debug", "w");
if (pipe_debug == NULL)
    printf("Couldn't open pipe:debug\n");
#endif

#ifndef SHOWCALLS
#if DEBUGON
pipe_debug = fopen("pipe:debug", "w");
if (pipe_debug == NULL)
    printf("Couldn't open pipe:debug\n");
#endif
#endif
@


4.3
log
@  Added support for booting from alternative boot servers when primary
    boot server is unavailable.
Detail:
  Inet$BootServer2, 3, etc. can be used to specify alternate backup
    boot servers.  When retrying, the NFS module will cycle through
    the servers until it gets a response.
  NFSSTB was identical to NFS except in the title string of the module
    and in counting of accesses to the net.  The net access counting
    macros are retained as a build option, disabled by default.
Admin:
  Filing system boot behavioural changes specified in 1215,251/FS.
  Now uses srccommit.
  Module entitled "NFSSTB" is no longer, but it still generated as a
    dummy module in order to disable any ROM based module of the same
    name.

Version 2.35. Tagged as 'NFS-2_35'
@
text
@d41 3
d285 1
a285 1
                                r->r[3] = (int)space.sp.quota.space.slim - space.sp.quota.space.usage;
d354 1
a354 1

d414 13
@


4.2
log
@Module NFSSTB committed by srcmerge.
Merged from Spin_merge to Spinner.
Merge tag prefix is Spinner_23Sep1998
@
text
@d32 1
a32 5
#ifdef PACKETSIZE_COMMAND
#include "nfsstbcmhg.h"
#else
#include "nfscmhg.h"  /* So that the cmd handler knows about the * cmd names even if you change the order :-)  */
#endif
@


4.1
log
@Initial revision
@
text
@d407 1
a407 1
        char *cmd_tail,
d518 1
a518 1
_kernel_oserror *nfs_command( char *arg_string, int argc, int cmd_no, void *private_word)
d537 1
a537 1
        arg_string = my_command_parameter_buffer;
d545 1
a545 1
                err = command_nfs( arg_string, argc );
d549 1
a549 1
                err = command_nfsname( arg_string, argc );
d553 1
a553 1
                err = command_nfsmount( arg_string, argc );
d557 1
a557 1
                err = command_nfsdismount( arg_string, argc );
d567 1
a567 1
                err = command_free( arg_string, argc );
d571 1
a571 1
                err = command_cachetime( arg_string, argc );
d575 1
a575 1
                err = command_nfsinfo( arg_string, argc );
d583 1
a583 1
        	err = command_cachesize( arg_string, argc);
d587 1
a587 1
                err = command_timeout( arg_string, argc );
d591 1
a591 1
				err = command_packetsize( arg_string, argc );
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@

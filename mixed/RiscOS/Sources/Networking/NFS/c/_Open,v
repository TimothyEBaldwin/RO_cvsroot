head	4.7;
access;
symbols
	NFS-3_27:4.7
	NFS-3_26:4.7
	NFS-3_25:4.7
	NFS-3_24:4.6
	NFS-3_23:4.6
	NFS-3_22:4.5
	NFS-3_21:4.5
	NFS-3_20:4.5
	NFS-3_19:4.5
	sbrodie_NFS_dev_merge:4.5
	NFS-3_18-4_22_2_4:4.5
	NFS-3_18-4_22_2_3:4.5
	NFS-3_18-4_22_2_2:4.5
	NFS-3_18-4_22_2_1:4.5
	sbrodie_NFS_dev:4.5.0.2
	sbrodie_NFS_dev_bp:4.5
	NFS-3_18:4.5
	NFS-3_17:4.5
	NFS-3_16:4.5
	NFS-3_15:4.5
	NFS-3_14:4.5
	NFS-3_13:4.5
	NFS-3_12:4.5
	NFS-3_11:4.5
	NFS-3_10:4.5
	NFS-3_09:4.5
	NFS-3_08:4.4
	NFS-3_07:4.4
	NFS-3_06:4.4
	NFS-3_05:4.4
	NFS-3_04:4.3
	NFS-3_02:4.3
	NFS-3_01:4.3
	NFS-3_00:4.2
	NFS-2_37:4.1
	NFS-2_36:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.10
	NFS-2_35:4.1
	Spin_merge:4.1.7.1
	Spinner_23Sep1998_destend:4.1
	Spinner_23Sep1998_srcend:4.1.7.1
	Spinner_23Sep1998_srcbegin:4.1.7.1
	Spinner_23Sep1998_destbegin:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.8
	Ursula_13May1998_bp:4.1
	Ursula_13May1998:4.1.0.4
	rthornb_UrsulaBuild_01May1998:4.1
	pwombwel_2_32:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	MergeFiles:4.1.7.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1;
locks; strict;
comment	@# @;


4.7
date	2018.03.07.21.22.41;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	sKJZhgBEKf2WsztA;

4.6
date	2018.01.29.21.30.19;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	7TGUL0NEVVbjHOoA;

4.5
date	2000.03.20.15.52.16;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	99.12.06.15.58.05;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	99.10.13.09.53.57;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	99.05.14.12.42.13;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.22.14.49.32;	author nturton;	state Exp;
branches
	4.1.5.1
	4.1.7.1;
next	;

4.1.5.1
date	96.11.22.14.49.32;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.07.01;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.7
log
@Store lxa files verbatim, without appendum
Files saved with load & exec address (as opposed to a filetype and the top nybble of load set to 0xFFF) would be extended by 8 bytes in order to hide the true load/exec for later retrieval.
While useful if only ever saving and retrieving from the RISC OS viewpoint, it would create apparently corrupt or overlong file if you wanted to do any analysis on the NFS server end. Given load/exec addresses are deprecated, change NFS to behave like LanManFS and just denote ",lxa" suffixed files with the appropriate icon in the Filer and a made up load/exec address.

pathmunge.c/_GBPB.c/V2support.c/_Args.c/_File.c/PutBytesX.c/Static.c/Changeinfo.c: Switch out 8 byte appending code. Give the file a proper date stamp instead when viewed on Unix.
_Open.c: Switch out the 8 byte appendum stuff, and use a common OS_Word 14 clock function.
Statics.h/Modulewrap.c: Compute a substitute load/exec using the same algorithm as LanManFS (the Kernel's address rounded down to 1MB). Use cmhg finalise function instead of atexit().

Also
MakeFile: pass in predefine DEBUG for debug builds.
cmhg/NFSHdr: remove *Histogram debug command except when debugging. Add finalise handler.
Commands.c/Commands.h: remove *Histogram debug command except when debugging.
Utils.c: delete unused long long support functions. Add a new time getting support function.
Utils.h: new time getting support function.

Tested with a handful of area saves using *Save, checking the file size when viewed at the server end was correct not 8 bytes longer.

Version 3.25. Tagged as 'NFS-3_25'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __NFSNFS_H
#include "nfsheaders.h"
#endif

#include "access.h"

#define RISCOS_Style 1 /* When set, if open update fails write access, it returns a read-only handle
                        * when unset, if open update fails write access, it fails */

/*
        Perform a low-level rename, making sure all open files are kept up to date
*/
_kernel_oserror *nfs_rename_safely
(
        MountPoint *mp,
        RO_nfs_fh3 *to_dir,
        char *to_name,
        RO_nfs_fh3 *from_dir,
        char *from_name
)
{
        _kernel_oserror *err;
        Chain_Link *link;
        OpenFile *of;
        char *new_name;

        err = nfs_rename( mp, to_dir, to_name, from_dir, from_name );

        if ( !err )
        {
                /*
                        Go down that mount point's open file list
                */
                for ( link = mp->open_files.forwards;
                        link->forwards != NULL;
                        link = link->forwards )
                {
                        of = Link_Wrapper( link );

                        /*
                                If the open file's a match
                        */
                        if ( fh3cmp( &of->nfs_fd.dir, from_dir ) == 0 &&
                                strcmp( of->nfs_fd.desc.name, from_name ) == 0 )
                        {
                                /*
                                        Change the open file's information
                                */
                                new_name = malloc( strlen( to_name ) + 1 );
                                if ( new_name != NULL )
                                {
                                        free( of->nfs_fd.desc.name );
                                        of->nfs_fd.desc.name = new_name;
                                        strcpy( new_name, to_name );
                                        fh3cpy(&of->nfs_fd.dir, to_dir);
                                }
                                else
                                {
                                        /*
                                                do nothing, return an error, and let a
                                                failure happen at file closure
                                        */
                                        err = mb_malloc_failed;
                                }
                        }
                }
        }

        return err;
}


/*
        Creates a structure describing an open file, without the descriptor filled in.
*/
static _kernel_oserror *create_open_file
(
        OpenFile **of,
        int fileswitch_handle,
        YesNoAnswer read_only,
        SpoolFileDetails *sfdetails
)
{
        *of = (OpenFile *)malloc( sizeof( OpenFile ));

        if ( *of == NULL )
        {
                return mb_malloc_failed;
        }
        else
        {
                (*of)->fileswitch_handle = fileswitch_handle;
                (*of)->sequential_file_pointer = 0;
                (*of)->read_only = read_only;
                (*of)->spool_details = sfdetails;

                return NULL;
        }
}

/*
        Enter the open file into NFS's open file list.
*/
static void enter_open_file
(
        OpenFile *of
)
{
        insert_before_header( &of->link, of, &of->nfs_fd.mp->open_files );
}


/*
        Try real hard to create the nfs file with the required attributes.
        Will write memory at filling to the file if fill_it is true
*/
_kernel_oserror *create_nfs_file
(
        nfs_file_descriptor     *ndesc,
        char                    *riscos_name,
        int                     *length,
        unsigned long           *load_address,
        unsigned long           *execute_address,
        int                     *access,
        char                    *filling,
        bool_t                  fill_it  /* JRS 7/92 added because filling can have a valid value of 0 */
)
{
        _kernel_oserror *err;
        sattr3 nattr;
        char *path_to_leaf;
        char *leaf_position;
        riscos_file_description rdesc;
        char time_result[ 5 ];
        fattr3 *nattrres;
        int success;
        gid3 gid;

        err = find_dir_for_leaf( riscos_name, ndesc, &path_to_leaf, &leaf_position );

        if ( err )
                return err;

        err = nfs_getattr( &nattrres, ndesc->mp, &ndesc->dir );

        if ( err )
                return err;

        if (nattrres->mode & NFSMODE_SETGID)
        {
                gid = nattrres->gid;
        }
        else
        {
                gid = ndesc->mp->user->gid;
        }

        err = find_object_in_directory( ndesc, leaf_position );

        if ( err == mb_nfserr_noent )
        {
                /*
                        Object doesn't exist
                */

                rdesc.name = leaf_position;

                rdesc.attr.type = FileType_File;

                if ( load_address || execute_address )
                {
                        /*
                                Load or exec exists - use given
                        */
                        if ( load_address )
                                rdesc.attr.load_address = *load_address;
                        else
                                rdesc.attr.load_address = 0;

                        if ( execute_address )
                                rdesc.attr.execute_address = *execute_address;
                        else
                                rdesc.attr.execute_address = rdesc.attr.load_address;
                }
                else
                {
                        /*
                                Load and exec not specified - create data file stamped now
                        */

                        rdesc.attr.load_address = NewFile_DefaultLoad;

                        err = utils_setnowcs( &rdesc.attr.load_address, &rdesc.attr.execute_address );

                        if ( err )
                        {
                                free( path_to_leaf );
                                return err;
                        }
                }

                if ( access )
                        rdesc.attr.access = *access;
                else
                        rdesc.attr.access = FileAccess_OwnerRead | FileAccess_OwnerWrite;

                err = riscos_to_nfs_description( &ndesc->desc, &rdesc );

                if ( err )
                {
                        return err;
                }

                /*
                        If no access specified, create an access from the system variable.
                        If the variable fails to read, don't bother with it.
                */
                if ( !access )
                {
                        int cr_access = utils_getcreateaccess(ndesc);
                        if (cr_access >= 0)
                        {
                                if (!(cr_access & NFSMODE_GROUP_READ)) cr_access &= ~NFSMODE_GROUP_WRITE;
                                if (!(cr_access & NFSMODE_OTHERS_READ)) cr_access &= ~NFSMODE_OTHERS_WRITE;
                                ndesc->desc.attr.mode =
                                        ( ndesc->desc.attr.mode &
                                                ~( NFSMODE_OTHERS_WRITE | NFSMODE_OTHERS_READ |
                                                   NFSMODE_GROUP_WRITE | NFSMODE_GROUP_READ |
                                                   NFSMODE_USER_WRITE | NFSMODE_USER_READ ))
                                        | cr_access;
                        }
                }

                nattr.mode.set_it = TRUE;
                nattr.uid.set_it = TRUE;
                nattr.gid.set_it = TRUE;
                nattr.size.set_it = FALSE;
                nattr.atime.set_it = SET_TO_CLIENT_TIME;
                nattr.mtime.set_it = SET_TO_CLIENT_TIME;
                nattr.mode.set_mode3_u.mode = ndesc->desc.attr.mode;
                nattr.uid.set_uid3_u.uid = ndesc->mp->user->uid;
                nattr.gid.set_gid3_u.gid = gid;
                nattr.atime.set_atime_u.atime = ndesc->desc.attr.atime;
                nattr.mtime.set_mtime_u.mtime = ndesc->desc.attr.mtime;

                err = nfs_create( &ndesc->file, &nattrres, ndesc->mp, &ndesc->dir, ndesc->desc.name, &nattr );

                if ( err )
                {
                        free( ndesc->desc.name );

                        return err;
                }

                ndesc->desc.attr = *nattrres;

#ifdef LXA_BY_APPENDUM
                /*
                        If we have a bit on the end, write it.
                */
                if ( ndesc->desc.file_is_lxa )
                {
                        appendum bit_on_the_end;

                        bit_on_the_end.lxa.load_address = ndesc->desc.load_address;
                        bit_on_the_end.lxa.execute_address = ndesc->desc.execute_address;
                        err = nfs_write( &nattrres, ndesc->mp, &ndesc->file, 0, (char *)&bit_on_the_end, sizeof( appendum ));

                        if ( err )
                        {
                                free( ndesc->desc.name );

                                return err;
                        }

                        ndesc->desc.attr = *nattrres;
                }
#endif                
        }
        else if ( err )
        {
                /*
                        error other than 'Object doesn't exists'
                */
                free( path_to_leaf );

                return err;
        }

        /*
                Object exists and needs its length/contents/date stamps fixing
        */

        free( path_to_leaf );

        if ( ndesc->desc.attr.type != NF3REG )
        {
                /*
                        Object exists and isn't a regular file.
                */
                free( ndesc->desc.name );

                return mb_nfserr_dontmatch;
        }

        /*
                ndesc now refers to an extant regular file whose size may be wrong.
                ndesc's contents are also fully filled in and as up-to-date as reasonable.
        */

        err = change_length_given_file( ndesc, length ? *length : 0, filling, fill_it );

        if ( !err )
                err = change_info_given_file( ndesc, load_address, execute_address, access );

        if ( err )
        {
                free( ndesc->desc.name );
        }

        return err;
}

/*
        Given the fattr3 for a file and its mount point, return
        the best guess as to what we're permitted to do to it.
*/
static int access_on_file( fattr3 *nattr, MountPoint *mount_point )
{
        int result = 0;

        if ( access_Icanread( mount_point , nattr ) )
                result |= FileInfo_ReadPermitted;

        if ( access_Icanwrite( mount_point , nattr ) )
                result |= FileInfo_WritePermitted;

        return result;
}

/*
        Peel a .<item> into item
*/
static _kernel_oserror *peel_item( char **item, char **rover0, char *default_string )
{
        char *rover1;

        if ( **rover0 )
        {
                for ( rover1 = *rover0 + 1;
                        *rover1 && *rover1 != FileChar_DirectorySeparator;
                        rover1++ );

                *item = malloc( (rover1-*rover0) );

                if ( *item == NULL )
                {
                        return mb_malloc_failed;
                }

                strncpy( *item, *rover0 + 1, (rover1-*rover0) - 1 );
                (*item)[ (rover1-*rover0) - 1 ] = '\0';

                *rover0 = rover1;
        }
        else
        {
                *item = malloc( strlen( default_string ) + 1 );

                if ( *item == NULL )
                {
                        return mb_malloc_failed;
                }

                strcpy( *item, default_string );
        }

        return NULL;
}

/*
        Pick spooling filename apart into spool file details:

        NFS#Printer::<host>[[.$].<printername>[.<username>[.<options>]]]

        Directory returned by pcnfsd is mounted as Spool:<host>[:<printername>]

        NO translation is made from the given name to sending it to the pcnfsd.
*/
static _kernel_oserror *process_sfdetails
(
        SpoolFileDetails        **sfdetails,
        MountPoint              **artificial_mount,
        char                    **filename_out,
        char                    *filename_in
)
{
        _kernel_oserror *err;
        SpoolFileDetails *sfdet = *sfdetails = (SpoolFileDetails *)malloc( sizeof( SpoolFileDetails ));
        char *rover;
        char *spool_hostname;
        char *artificial_mountname;
        Host *spool_host;
        unused_client *pcnfsd_client;
        char machname[ MAX_MACHINE_NAME + 1 ];
        UserSpecification *user_nobody = NULL;
        pr_init_args pri_args;
        pr_init_results *pri_res;

        *artificial_mount = NULL;

        if ( !sfdet )
                return mb_malloc_failed;

        rover = filename_in;

        if ( *rover != FileChar_MountIntroduction )
        {
                free( sfdet );

                return mb_missing_spool_host;
        }

        /*
                Find the end of the spool host name.
        */
        err = peel_item( &spool_hostname, &rover, "" );
        if ( err )
        {
                free( sfdet );

                return err;
        }

        /*
                Skip a .$ if present and filter references to other directories
        */
        if ( rover[0] == FileChar_DirectorySeparator )
        {
                switch( rover[1] )
                {
                case FileChar_Root:
                        /*
                                Skip .$
                        */
                        rover += 2;
                        break;

                default:
                        /*
                                Everything else is ok
                        */
                        break;
                }
        }

        /*
                Process [.<printername>]
        */
        err = peel_item( &sfdet->printername, &rover, Spooling_DefaultPrinter );
        if ( err )
        {
                free( spool_hostname );
                free( sfdet );

                return err;
        }

        /*
                Process [.<username>]
        */
        err = peel_item( &sfdet->username, &rover, "" );
        if ( err )
        {
                free( sfdet->printername );
                free( spool_hostname );
                free( sfdet );

                return err;
        }

        /*
                Process [.<options>]
        */
        err = peel_item( &sfdet->options, &rover, "" );
        if ( err )
        {
                free( sfdet->username );
                free( sfdet->printername );
                free( spool_hostname );
                free( sfdet );

                return err;
        }

        /*
                Discount filenames with more leaves on their end
        */
        if ( *rover )
        {
                free( sfdet->options );
                free( sfdet->username );
                free( sfdet->printername );
                free( spool_hostname );
                free( sfdet );

                return mb_too_many_print_leaves;
        }

        /*
                Check if mount point already present
        */
        artificial_mountname = malloc( strlen( Spooling_MountPrefix ) + strlen( spool_hostname ) + 1 + strlen( sfdet->printername ) + 1 );

        if ( artificial_mountname == NULL )
        {
                free( sfdet->options );
                free( sfdet->username );
                free( sfdet->printername );
                free( spool_hostname );
                free( sfdet );

                return mb_malloc_failed;
        }

        sprintf( artificial_mountname, "%s%s%c%s", Spooling_MountPrefix, spool_hostname, FileChar_MountIntroduction, sfdet->printername );

        /*
                If mount not already present, create it
        */
        if ( !find_mount( artificial_mountname ) )
        {
                /*
                        Mount point not there yet - generate a mount
                */
                if ( gethostname( machname, MAX_MACHINE_NAME ) == -1 )
                {
                        free( artificial_mountname );
                        free( sfdet->options );
                        free( sfdet->username );
                        free( sfdet->printername );
                        free( spool_hostname );
                        free( sfdet );

                        return mb_machname_too_big;
                }


                spool_host = NULL;
                err = new_host( &spool_host, spool_hostname );

                if ( err )
                {
                        free( artificial_mountname );
                        free( sfdet->options );
                        free( sfdet->username );
                        free( sfdet->printername );
                        free( spool_hostname );
                        free( sfdet );

                        return err;
                }

                err = get_pcnfsd_client_for_host( &pcnfsd_client, spool_host, PCNFSDVERS );

                if ( err )
                {
                        release_host( spool_host );

                        free( artificial_mountname );
                        free( sfdet->options );
                        free( sfdet->username );
                        free( sfdet->printername );
                        free( spool_hostname );
                        free( sfdet );

                        return err;
                }

                pri_args.system = machname;
                if ( sfdet->printername )
                        pri_args.pn = sfdet->printername;
                else
                        pri_args.pn = "";

                pri_res = pcnfsd_pr_init_1( &pri_args, pcnfsd_client->client );
                err = rpcpcnfsd_pi_to_riscos_err( pri_res, pcnfsd_client->client, spool_hostname );
                release_client( pcnfsd_client );

                if ( err )
                {
                        release_host( spool_host );

                        free( artificial_mountname );
                        free( sfdet->options );
                        free( sfdet->username );
                        free( sfdet->printername );
                        free( spool_hostname );
                        free( sfdet );

                        return err;
                }

                /*
                        Create nobody
                */
                err = new_user( &user_nobody, User_Nobody, NULL, UNIX_MagicNumber_UID_Nobody, UNIX_MagicNumber_GID_Nobody, authunix_create_default(),
                        0, NULL, -1);

                if ( err )
                {
                        release_host( spool_host );

                        free( artificial_mountname );
                        free( sfdet->options );
                        free( sfdet->username );
                        free( sfdet->printername );
                        free( spool_hostname );
                        free( sfdet );

                        return err;
                }


                /*
                        Generate the artificial internal mount point for spooling
                */
                err = nfs_mount_internal( artificial_mountname, pri_res->dir, spool_host, user_nobody );

                /*
                        Drop 'Nobody' and spool_host given that our handles on these are being dropped now
                */
                release_user( user_nobody );
                release_host( spool_host );

                if ( err )
                {
                        free( artificial_mountname );
                        free( sfdet->options );
                        free( sfdet->username );
                        free( sfdet->printername );
                        free( spool_hostname );
                        free( sfdet );

                        return err;
                }
        }

        free( spool_hostname );

        /*
                Pick up our mount
        */
        *artificial_mount = find_mount( artificial_mountname );

        /*
                Generate the real filename to use
        */
        *filename_out = malloc( 1 + strlen( artificial_mountname ) + 1 + 8 + 1 );

        if ( *filename_out == NULL )
        {
                free( artificial_mountname );
                free( sfdet->options );
                free( sfdet->username );
                free( sfdet->printername );
                free( sfdet );

                return mb_malloc_failed;
        }

        sprintf( *filename_out, "%c%s%c%08x", FileChar_MountIntroduction, artificial_mountname, FileChar_DirectorySeparator, spool_name_count++ );
        free( artificial_mountname );

        return NULL;
}

_kernel_oserror *fsentry_open( FSEntry_Open_Parameter *parm )
{
        _kernel_oserror *err = NULL;
        FileSystemHandle fshandle = 0;
        char *path_to_leaf;
        char *leaf_position;
        OpenFile *of;
        SpoolFileDetails *sfdetails = NULL;
        char *filename = parm->open_definition.filename;
        MountPoint *spool_mount = NULL;

        hourglass_on();

#ifdef SHOWCALLS
        if ( parm->open_definition.special_field )
                printf(
                        "_Open( %d,, %s, %s )\n",
                        parm->open_definition.reason,
                        parm->open_definition.special_field,
                        parm->open_definition.filename );
        else
                printf(
                        "_Open( %d,, %s )\n",
                        parm->open_definition.reason,
                        parm->open_definition.filename );
#endif

        /*
                Process print spooling functions
        */
        if ( parm->open_definition.special_field )
        {
                if ( caseless_strcmp( parm->open_definition.special_field, Spooling_SpecialField ) == 0 )
                {
                        /*
                                It's NFS#printer:
                        */
                        err = process_sfdetails( &sfdetails, &spool_mount, &filename, filename );
                }
                else
                {
                        err = mb_bad_special_field;
                }
        }

        if ( !err )
        {
                switch ( parm->open_definition.reason )
                {
                case FSEntry_Open_Reason_Update:
                case FSEntry_Open_Reason_OpenRead:
                        err = create_open_file(
                                &of,
                                parm->open_definition.handle,
                                (parm->open_definition.reason == FSEntry_Open_Reason_OpenRead) ? Yes : No, /* readonly */
                                sfdetails );

                        if ( err )
                                break;

                        err = find_leaf( filename, &of->nfs_fd, &path_to_leaf, &leaf_position );

                        if ( err )
                        {
                                free( of );
                                break;
                        }

                        free( path_to_leaf );

                        /* JRS 7/92 check we have read access to file */
                        if ( !access_Icanread(of->nfs_fd.mp, &of->nfs_fd.desc.attr)
#if !RISCOS_Style
                          /* and write access if update. (RISCOS converts this to open read) */
                          || ( (parm->open_definition.reason == FSEntry_Open_Reason_Update)
                              && !access_Icanwrite(of->nfs_fd.mp, &of->nfs_fd.desc.attr) )
#endif
                           )
                        {
                                free( of );
                                err = mb_nfserr_acces;
                                break;
                        }

#if RISCOS_Style
                        /* set readonly flag of read-only file */
                        if ( (parm->open_definition.reason == FSEntry_Open_Reason_Update)
                            && !access_Icanwrite(of->nfs_fd.mp, &of->nfs_fd.desc.attr) )
                        {
                                of->read_only = Yes;
                        }
#endif

                        enter_open_file( of );

                        fshandle = (FileSystemHandle)of;

                        if ( of->nfs_fd.desc.attr.type == NF3DIR )
                        {
                                parm->open_result.information_word =
                                        FileInfo_ObjectIsDirectory;
                        }
                        else
                        {
                                parm->open_result.information_word =
                                        FileInfo_UnbufferedGBPBIsOK |
                                        access_on_file( &of->nfs_fd.desc.attr, of->nfs_fd.mp );
                        }
                        break;

                case FSEntry_Open_Reason_CreateUpdate:
                        /* It appears that this entry is never called! */
                        err = create_open_file( &of, parm->open_definition.handle, No, sfdetails );

                        if ( err )
                                break;

                        err = create_nfs_file( &of->nfs_fd, filename, NULL, NULL, NULL, NULL, NULL, No);

                        if ( err )
                                break;

                        enter_open_file( of );

                        fshandle = (FileSystemHandle)of;

                        parm->open_result.information_word =
                                FileInfo_UnbufferedGBPBIsOK | access_on_file( &of->nfs_fd.desc.attr, of->nfs_fd.mp );
                        break;

                default:
                        dprintf(("", "Unused FSEntry_Open entry called! (%d)\n", parm->open_definition.reason));
                        err = mb_nfserr_BadParameters;
                       /* JRS 7/92 removed return here which would leave hourglass on */
                        break;
                }
        }

        /*
                Free any articifially generated filenames
        */
        if ( filename != parm->open_definition.filename )
                free( filename );

        /*
                Unmount the temporary spool mount if it has no open files in it and there was an error
        */
        if ( err && spool_mount && spool_mount->open_files.forwards->forwards == NULL )
        {
                (void)nfs_dismount( spool_mount );
        }

        /*
                remap ran out of memory and not found errors
        */
        if ( err == mb_malloc_failed ||
                  err == mb_nfserr_noent )
        {
                err = NULL;
        }

        if ( !err )
        {
                parm->open_result.handle = fshandle;
                parm->open_result.buffer_size = NFSBufferSize;
                parm->open_result.file_extent = riscos_extent( &of->nfs_fd );
                parm->open_result.allocated_space = riscos_extent( &of->nfs_fd );
        }

        hourglass_off();

        return err;
}
@


4.6
log
@Export our own SWIs as a header
Use the shared makefiles to export Interface/NFS.h and Hdr:NFS.
Remove local copy NFS.h which confuses the dependency checking, now called nfsheaders.h instead.
Delete unused UID/GID pair.
Tested on a mount from FreeBSD 11.1-RELEASE-p4.

Version 3.23. Tagged as 'NFS-3_23'
@
text
@a150 1
        appendum bit_on_the_end;
d188 1
a188 1
                                load or exec exists - untyped file
d198 1
a198 1
                                rdesc.attr.execute_address = *load_address;
a204 1
                        time_result[0] = Word_ReadRealTime5ByteFormat;
d206 1
a206 1
                        success=_kernel_osword(Word_DateAndTime, (int *) time_result);
d208 3
a210 1
                        if ( success == _kernel_ERROR )
a211 1
                                err = _kernel_last_oserror();
a214 3

                        rdesc.attr.load_address = NewFile_DefaultLoad | time_result[4];
                        rdesc.attr.execute_address = *(unsigned long *)time_result;
d272 1
d278 2
d293 1
@


4.5
log
@  Access permission code overhaul.
  Supplementary group code improved.
Detail:
  *NFSInfo now shows the group names as well as the group IDs for
    both your primary and supplementary GIDs.
  access.c now uses the supplementary GIDs to help determine whether
    or not you are allowed to read/write a file.
  access.c now provides the NFS->RISC OS attribute mapping - "Owner"
    attributes being UNIX's user/group access; "Public" being the
    UNIX other access.
  The end result of these changes should be that your access rights to
    any object on the NFS server should match those you would expect
    from a UNIX shell logged in with the same ACLs as those you get
    via PCNFS.
Admin:
  Tested on Risc PC.

Version 3.09. Tagged as 'NFS-3_09'
@
text
@d17 1
a17 1
#include "NFS.h"
@


4.4
log
@  Now uses PCNFS version 2 to authenticate.
Detail:
  Group-writable directories should now be writable to.
  setgid directories should cause created objects to take on
    the directory group ownership instead of the user's primary
    GIF
  *NFSInfo output enhanced to list all the additional group IDs
    and the default umask being applied to each authentication.
Admin:
  Tested on normal home mount and on TWC mount.

Version 3.05. Tagged as 'NFS-3_05'
@
text
@d165 1
a165 1
        if (nattrres->mode & 0x400)
a344 1
        unsigned long access_bits;
d347 2
a348 15
        /*
                Get the access bits which apply into access_bits
        */
        if ( mount_point->user->uid == nattr->uid )
        {
                access_bits = (nattr->mode >> 6) & 0xf;
        }
        else if ( mount_point->user->gid == nattr->gid )
        {
                access_bits = (nattr->mode >> 3) & 0x7;
        }
        else
        {
                access_bits = nattr->mode & 0x7;
        }
d350 1
a350 9
        /*
                Translate the access bits to fileinfo bits
        */
        if ( access_bits & NFSMODE_OTHERS_READ )
        {
                result |= FileInfo_ReadPermitted;
        }
        if ( access_bits & NFSMODE_OTHERS_WRITE )
        {
a351 1
        }
@


4.3
log
@  Attribute cacheing preload bug fixed.
  Debugging all switched to DebugLib-style.
Detail:
  The attribute cache preloading was failing to take effect because
    the hash value generation was giving the attribute cache preload
    function different answers to those it gave any other functions.
    This has now been fixed.
  Debugging support replaced completely by DebugLib support.
  The automatically generated RPC veneers do not contain any debugging
    (although it could be added by rpcgen - a beta version of rpcgen
    exists that writes DebugLib veneers into the stubs to note all RPC
    calls made via the stubs.  These functions do not, however, unpack
    the parameters and return structures yet.  That would be a massive
    job, requiring changes to all hand-written XDR functions - rpcgen
    could arrange to generate appropriate stuff for anything it writes,
    though)
  Removed obsolete db.c and db.h files.
  TaskObey script added to build the debugging version of the module.
Admin:
  This module has been tested on desktop machines for several months.
    The massive speedup expected from the use of NFS protocol version 3
    is now being noticed on directory operations,

Version 3.01. Tagged as 'NFS-3_01'
@
text
@d153 1
d160 14
d242 2
d261 1
a261 1
                nattr.gid.set_gid3_u.gid = ndesc->mp->user->gid;
d602 1
a602 1
                err = get_pcnfsd_client_for_host( &pcnfsd_client, spool_host );
d645 2
a646 1
                err = new_user( &user_nobody, User_Nobody, NULL, UNIX_MagicNumber_UID_Nobody, UNIX_MagicNumber_GID_Nobody, authunix_create_default());
@


4.2
log
@  Now supports NFS version 3.
Detail:
  All client-server calls now use the superior NFS3 protocol.
  This particularly benefits directory enumeration and *NFSInfo
    is now reporting 80%+ cache hit rates which is a significant
    improvement (over 5% better - some hosts report 85%+)
  Hashing algorithms improved to increase cache hits (the cache
    algorithm doesn't use parts of names after a comma, so that
    the hash value for !Run is the same as the hash value for
    !Run,feb - which helps the cache hit rate a lot).   Directory
    browsing on the desktop appears noticably faster too.
  The module now has the original protocol (.x) files defining
    the RPC protocols being used (NFS, mount, pcnfs, rquota)
    and uses them to generate header files, XDR implementations,
    and client stubs automatically, instead of having hand
    written versions.
  NFS workspace comes from a dynamic area where possible.
Admin:
  Supporting documentation:
    Acorn NFS Software Functional Specification (1215,250/FS)
    RFC1014, RFC1057, RFC1094, RFC1813
  Tested in several desktop machines for everyday use against
    both NFS2 and NFS3 servers.
  Requires rpcgen 0.01 or later
    (CVS source: Tools/Sources/rpcgen  tag: rpcgen-0_01 or later)
    (CVS binary: RiscOS/Library  tag: Library-0_19 or later)
  Requires TCPIPLibs 5.13 or later
    (CVS: RiscOS/Sources/Lib/TCPIPLibs  tag: TCPIPLibs-5_13)

Version 3.00. Tagged as 'NFS-3_00'
@
text
@a20 1
#include "DebugLib/DebugLib.h"
@


4.1
log
@Initial revision
@
text
@d21 1
d32 1
a32 1
        nfs_fh *to_dir,
d34 1
a34 1
        nfs_fh *from_dir,
d59 1
a59 1
                        if ( memcmp( &of->nfs_fd.dir, from_dir, sizeof( *from_dir ) ) == 0 &&
d71 1
a71 1
                                        of->nfs_fd.dir = *to_dir;
d138 2
a139 2
        int                     *load_address,
        int                     *execute_address,
d146 1
a146 1
        sattr nattr;
d151 1
a151 1
        fattr *nattrres;
d204 1
a204 1
                        rdesc.attr.execute_address = *(int *)time_result;
d237 11
a247 6
                nattr.mode = ndesc->desc.attr.mode;
                nattr.uid = ndesc->mp->user->uid;
                nattr.gid = ndesc->mp->user->gid;
                nattr.size = 0;
                nattr.atime = ndesc->desc.attr.atime;
                nattr.mtime = ndesc->desc.attr.mtime;
d295 1
a295 1
        if ( (ndesc->desc.attr.mode & NFSMODE_FMT) != NFSMODE_REG )
d324 1
a324 1
        Given the fattr for a file and its mount point, return
d327 1
a327 1
static int access_on_file( fattr *nattr, MountPoint *mount_point )
d329 1
a329 1
        int access_bits;
d602 1
a602 1
                pri_args.pia_client = machname;
d604 1
a604 1
                        pri_args.pia_printername = sfdet->printername;
d606 1
a606 1
                        pri_args.pia_printername = "";
d649 1
a649 1
                err = nfs_mount_internal( artificial_mountname, pri_res->pir_spooldir, spool_host, user_nobody );
d796 1
a796 1
                        if ( (of->nfs_fd.desc.attr.mode & NFSMODE_FMT) == NFSMODE_DIR )
d830 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@

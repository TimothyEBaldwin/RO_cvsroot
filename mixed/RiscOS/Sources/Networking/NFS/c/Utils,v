head	4.10;
access;
symbols
	NFS-3_27:4.10
	NFS-3_26:4.10
	NFS-3_25:4.9
	NFS-3_24:4.8
	NFS-3_23:4.7
	NFS-3_22:4.6
	NFS-3_21:4.6
	NFS-3_20:4.6
	NFS-3_19:4.6
	sbrodie_NFS_dev_merge:4.5.2.1
	NFS-3_18-4_22_2_4:4.5.2.1
	NFS-3_18-4_22_2_3:4.5.2.1
	NFS-3_18-4_22_2_2:4.5
	NFS-3_18-4_22_2_1:4.5
	sbrodie_NFS_dev:4.5.0.2
	sbrodie_NFS_dev_bp:4.5
	NFS-3_18:4.5
	NFS-3_17:4.5
	NFS-3_16:4.5
	NFS-3_15:4.5
	NFS-3_14:4.5
	NFS-3_13:4.5
	NFS-3_12:4.4
	NFS-3_11:4.4
	NFS-3_10:4.4
	NFS-3_09:4.4
	NFS-3_08:4.4
	NFS-3_07:4.4
	NFS-3_06:4.3
	NFS-3_05:4.3
	NFS-3_04:4.2
	NFS-3_02:4.2
	NFS-3_01:4.2
	NFS-3_00:4.2
	NFS-2_37:4.1
	NFS-2_36:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.10
	NFS-2_35:4.1
	Spin_merge:4.1.7.1
	Spinner_23Sep1998_destend:4.1
	Spinner_23Sep1998_srcend:4.1.7.1
	Spinner_23Sep1998_srcbegin:4.1.7.1
	Spinner_23Sep1998_destbegin:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.8
	Ursula_13May1998_bp:4.1
	Ursula_13May1998:4.1.0.4
	rthornb_UrsulaBuild_01May1998:4.1
	pwombwel_2_32:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	MergeFiles:4.1.7.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1;
locks; strict;
comment	@# @;


4.10
date	2018.04.07.15.09.04;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	HgweY7xr0wiZowxA;

4.9
date	2018.03.07.21.22.41;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	sKJZhgBEKf2WsztA;

4.8
date	2018.02.26.21.04.07;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	nHC4qDQ18G1xEpsA;

4.7
date	2018.01.29.21.30.19;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	7TGUL0NEVVbjHOoA;

4.6
date	2003.12.10.14.55.09;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2000.06.27.14.45.03;	author sbrodie;	state Exp;
branches
	4.5.2.1;
next	4.4;

4.4
date	2000.03.15.14.16.10;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	99.12.06.15.58.03;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	99.05.14.12.42.08;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.22.14.49.31;	author nturton;	state Exp;
branches
	4.1.5.1
	4.1.7.1;
next	;

4.5.2.1
date	2001.06.18.12.31.25;	author sbrodie;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.49.31;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.06.53;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Change determination of choice of ReadLine SWI
Because we want password entry, OS_ReadLine isn't going to cut it on a 32 bit OS (which takes the default stance of R0 being all address and no flags). Select based on 32 bit-ness, same as NetFS and FSLock do.

Version 3.26. Tagged as 'NFS-3_26'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*	UTILS

Purpose : RISC OS NFS utilities

History :
Date	Who    Comments
-----------------------------------------------------------------------------

10/02/95  CP    Added code to increment network access counter
****************************************************************************/


#ifndef __NFSNFS_H
#include "nfsheaders.h"
#endif
#include "Global/OSMisc.h"

#ifdef NETACCESSCOUNT
extern unsigned int NetAccessCountG;
#endif


/*
        Strip leading spaces, trailing spaces and reduce
        multiple spaces to single spaces
*/
void space_reduce
(
        char *source
)
{
        char *destination = source;
        YesNoAnswer skipping_spaces;

        while ( *source && *source == ASpace )
                source++;

        skipping_spaces = No;

        while ( *source )
        {
                /*
                        If skipping_spaces then destination points to the
                        last space copied.
                        Otherwise, destination points to the next place to
                        put a character.
                */
                if ( !skipping_spaces )
                {
                        *destination = *source;

                        if ( *source == ASpace )
                        {
                                skipping_spaces = Yes;
                        }
                        else
                        {
                                destination++;
                        }
                }
                else
                {
                        if ( *source != ASpace )
                        {
                                *++destination = *source;
                                destination++;
                                skipping_spaces = No;
                        }
                }

                source++;
        }

        *destination = '\0';
}

/*
        Change the user on the end of the pointer *userp. This maintains the
        user list and usage counts on that. ownership of *username remains
        with the caller, however *authorisation changes ownership to this
        routine and the user it creates.
*/
_kernel_oserror *new_user
(
        UserSpecification **userp,
        char *username,
        Host *host,
        unsigned int uid,
        unsigned int gid,
        AUTH *authorisation,
        u_int len,
        gid3 *gids,
        int def_umask
)
{
        Chain_Link *link;
        UserSpecification *user = NULL;

        for ( link = user_list.forwards;
                link->forwards != NULL;
                link = link->forwards )
        {
                user = Link_Wrapper( link );

                if ( user->host == host &&
                        strcmp( user->name, username ) == 0 )
                {
                        break;
                }
        }

        if ( link->forwards != NULL )
        {
                /*
                        Found the user on the user list
                */
                user->usage_count++;

                /*
                        The found one will already have an authorisation,
                        so junk the one we've been given.
                */
                auth_destroy( authorisation );
        }
        else
        {
                /*
                        If we havn't got a saved user structure then allocate
                        a new one. If this fails junk the authorisation passed
                        to us, as that is now our responsibility, and return an
                        error of course.
                */
                user = (UserSpecification *)malloc( sizeof( UserSpecification ));
                if ( !user )
                {
                        auth_destroy( authorisation );
                        return mb_malloc_failed;
                }

                /*
                        user exists and is linked to the user chain somewhere.
                        Set its usage count and attach the user name and
                        authorisation to it. If no space for the user name
                        the give up.
                */
                user->usage_count = 1;
                user->name = malloc( strlen( username ) + 1);
                user->host = host;
                user->uid = uid;
                user->gid = gid;
                user->len = len;
                user->umask = def_umask;
                memset( user->gnames, 0, sizeof( user->gnames ) );
                if (user->len > 0)
                {
                        if (user->len > NGRPS) user->len = NGRPS;
                        memcpy(user->gids, gids, sizeof(gid3) * user->len);
                }
                if ( user->name == NULL )
                {
                        free( user );
                        auth_destroy( authorisation );
                        return mb_malloc_failed;
                }

                /*
                        If this user requires a host, increment the host's usage count
                */
                if ( host )
                        host->usage_count++;

                strcpy( user->name, username );
                user->authorisation = authorisation;

                insert_before_header( &user->link, user, &user_list );
        }

        /*
                Drop the usage count on the old user.
        */
        if ( *userp )
                release_user( *userp );

        *userp = user;

        return NULL;
}

/*
        Releases one user.
*/
_kernel_oserror *release_user
(
        UserSpecification *user
)
{
        if ( user && --user->usage_count <= 0 )
        {
                remove_link( &user->link );
                release_host( user->host );
                free( user->name );
                auth_destroy( user->authorisation );
                free( user );
        }

        return NULL;
}

/*
        Get a string into some malloced memory from a readargs call
*/
_kernel_oserror *readargs_getstring
(
        char **result,
        int *readargs_buffer,
        int parmno
)
{
        int len;
        char *extract;
        int i;

        /*
                Check for parameter's presence
        */
        if ( readargs_buffer[ parmno ] == NULL )
        {
                *result = NULL;

                return NULL;
        }

        len = 0;
        extract = (char *)readargs_buffer[ parmno ];

        /*
                get the length
        */
        len = (unsigned char)(*extract++);
        len = len + (unsigned char)(*extract++) * 256;
        /*
                Get some memory for the string
        */
        *result = malloc( len + 1 );
        if ( *result == NULL )
        {
                return mb_malloc_failed;
        }

        /*
                Copy the string into the memory
        */
        for ( i = 0;
              i < len;
              i++ )
        {
                (*result)[ i ] = extract[ i ];
        }

        (*result)[ i ] = '\0';

        return NULL;
}

_kernel_oserror *new_host
(
        Host **default_host,
        char *new_host_name
)
{
        Chain_Link *link;
        Host *new_host;
        _kernel_oserror *e;

        /*
                New host not specified
        */
        if ( new_host_name == NULL )
        {
                return NULL;
        }

        /*
                Find end of list/first host with name >= new name
        */
        for ( link = host_list.forwards;
              link->forwards != NULL &&
                  strcmp( ((Host *)Link_Wrapper( link ))->host_name, new_host_name ) < 0;
              link = link->forwards )
        {
                /* do nothing */
        }

        if ( link->forwards == NULL ||
             strcmp( ((Host *)Link_Wrapper( link ))->host_name, new_host_name ) != 0 )
        {
                /*
                        end of list or found host gt new host
                */

                /*
                        Get a Host structure
                */
                new_host = (Host *)malloc( sizeof( Host ));

                if ( !new_host )
                        return mb_malloc_failed;

                /*
                        Get space for the host name
                */
                new_host->host_name = malloc( strlen( new_host_name ) + 1 );

                if ( !new_host->host_name )
                {
                        free( new_host );
                        return mb_malloc_failed;
                }

                strcpy( new_host->host_name, new_host_name );

                /*
                        Clear out the client lists.
                */
                initialise_header( &new_host->nfs_clients );
                initialise_header( &new_host->mount_clients );
                initialise_header( &new_host->pcnfsd_clients );
                initialise_header( &new_host->quota_clients );

                new_host->usage_count = 0;

                e = initialise_nfs_version( new_host );
                if (e == NULL)
                {
                        e = initialise_pcnfs_version( new_host );
                }

                initialise_header( &new_host->mount_points );

                if (e != NULL)
                {
                        free( new_host->host_name );
                        free( new_host );
                        return e;
                }

                /*
                        Put the newly created host into the host list
                */
                insert_before_link( &new_host->link, new_host, link );
        }
        else
        {
                /*
                        Host already on host list
                */
                new_host = (Host *)Link_Wrapper( link );
        }

        /*
                Change over the default host
        */
        new_host->usage_count++;

        release_host( *default_host );

        *default_host = new_host;

        /*
                default the other hosts
        */
        if ( !current_nameing_host )
        {
                current_nameing_host = new_host;
                new_host->usage_count++;
        }

        if ( !current_mounting_host )
        {
                current_mounting_host = new_host;
                new_host->usage_count++;
        }

        return NULL;
}

void junk_clients
(
        Chain_Header *client_list
)
{
        unused_client *to_free;

        while ( client_list->forwards->forwards )
        {
                to_free = Link_Wrapper( client_list->forwards );

                remove_link( &to_free->link );

                clnt_destroy( to_free->client );

                free( to_free );
        }
}

/*
        Reduce the usage of the given host and dispose of it cleanly
        if unused.
*/
_kernel_oserror *release_host
(
        Host *host
)
{
        if ( host && --host->usage_count <= 0 )
        {
                remove_link( &host->link );

                junk_clients( &host->nfs_clients );
                junk_clients( &host->mount_clients );
                junk_clients( &host->pcnfsd_clients );
                junk_clients( &host->quota_clients );

                free( host->host_name );
                free( host );
        }

        return NULL;
}

/*
        Reads a password. If an error is returned, *pwdest will
        not point to a valid piece of memory.
*/
_kernel_oserror *askfor_password
(
        char **pwdest
)
{
        _kernel_oserror *err;
        int flags;
        char *buffer;
        int read_size;
        int readlineswi, hiflags, loflags;

        *pwdest = malloc( Password_MaxSize + 1 );

        if ( *pwdest == NULL )
                return mb_malloc_failed;

        buffer = *pwdest;

        flags = 0; /* In case of no such SWI */
        _swix(OS_PlatformFeatures, _IN(0) | _OUT(0),
              OSPlatformFeatures_ReadCodeFeatures, &flags);
        if (flags & CPUFlag_32bitOS)
        {
                /* Beware flags spilling into addresses */
                readlineswi = OS_ReadLine32;
                loflags = 0;
                hiflags = ReadLine_ReflectOnlyBuffered |
                          ReadLine_ReflectFixedCharacter;
        }
        else
        {
                readlineswi = OS_ReadLine;
                hiflags = 0;
                loflags = ReadLine_ReflectOnlyBuffered |
                          ReadLine_ReflectFixedCharacter;
        }
        err = _swix(readlineswi, _INR(0,4)|_OUT(1)|_OUT(_FLAGS),
                                 (u_int)buffer | loflags,
                                 Password_MaxSize,
                                 Password_LowCharacter,
                                 Password_HighCharacter,
                                 Password_BlankCharacter | hiflags,
                                 &read_size,
                                 &flags);

        if ( !err )
        {
                if ( flags & _C ) /* escape */
                {
                        /*
                                Don't care if this fails
                        */
                        _kernel_osbyte( OSByte_CancelEscape, 0, 0 );
                        _swix(OS_NewLine, 0);

                        err = mb_escape;

                        free( buffer );
                }
                else
                {
                        buffer[ read_size ] = '\0';
                }
        }
        else
        {
                free( buffer );
        }

        return err;
}


/*
        Finds the mount point with the given name.
        Returns NULL if not found.
*/
MountPoint *find_mount
(
        char *mount_name
)
{
        if ( mount_name )
        {
                Chain_Link *link;
                MountPoint *mp;

                for ( link = mount_point_list.forwards;
                        link->forwards != NULL;
                        link = link->forwards )
                {
                        mp = Link_Wrapper( link );
                        if ( caseless_strcmp( mp->mount_point_name, mount_name ) == 0 )
                                return mp;
                }
        }

        return NULL;
}

/*
        Adjust quota sizes so results are in kilobytes
*/
static void normalise_quota(utils_quotastr *quota)
{
  if (quota->bsize < 1024) {
    u_long multiplier = 1024ul / quota->bsize;

    quota->usage /= multiplier;
    quota->slim  /= multiplier;
    quota->hlim  /= multiplier;
  }
  else if (quota->bsize > 1024) {
    u_long divider = quota->bsize / 1024ul;
    quota->usage *= divider;
    quota->slim  *= divider;
    quota->hlim  *= divider;
  }

  quota->bsize = 1024;
}

/*
        JRS 11/9/92 get quota numbers for free display
*/
#include "rquota.h"

static enum clnt_stat getnfsquota( MountPoint  *mount,
                                       CLIENT  *client,
                                       bool_t   vflag,
                               utils_spacestr   *space )
{
        enum clnt_stat stat;
        static struct timeval timeout = { 5, 0 }; /* 5s timeout shouldn't keep us waiting too long */

        struct getquota_args gq_args;
        struct getquota_rslt gq_rslt;

        gq_args.gqa_pathp = mount->mount_path;
        gq_args.gqa_uid = (int) mount->user->uid;

#ifdef NETACCESSCOUNT
NetAccessCountG++;
#endif
        stat = clnt_call(client,
                         (vflag? RQUOTAPROC_GETQUOTA: RQUOTAPROC_GETACTIVEQUOTA),
                         xdr_getquota_args, (char*)&gq_args,
                         xdr_getquota_rslt, (char*)&gq_rslt,
                         timeout);

        if (stat != RPC_SUCCESS)
        {
                return stat;
        }

        switch (gq_rslt.status) {
        case Q_OK:
                {
                space->active_quota = gq_rslt.getquota_rslt_u.gqr_rquota.rq_active;
                if (!space->active_quota)
                        return RPC_SUCCESS;
                dprintf(("quota_1", "used: %#lx * %#lx\n",
                  (u_long) gq_rslt.getquota_rslt_u.gqr_rquota.rq_curblocks,
                  (u_long) gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize));
                dprintf(("quota_1", "soft: %#lx * %#lx\n",
                  (u_long) gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsoftlimit,
                  (u_long) gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize));
                dprintf(("quota_1", "hard: %#lx * %#lx\n",
                  (u_long) gq_rslt.getquota_rslt_u.gqr_rquota.rq_bhardlimit,
                  (u_long) gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize));
                space->sp.quota.space.bsize = gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize;
                space->sp.quota.space.usage = gq_rslt.getquota_rslt_u.gqr_rquota.rq_curblocks;
                space->sp.quota.space.slim = gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsoftlimit;
                space->sp.quota.space.hlim = gq_rslt.getquota_rslt_u.gqr_rquota.rq_bhardlimit;
                space->sp.quota.space.timeleft = gq_rslt.getquota_rslt_u.gqr_rquota.rq_btimeleft;
                space->sp.quota.files.hlim = gq_rslt.getquota_rslt_u.gqr_rquota.rq_fhardlimit;
                space->sp.quota.files.slim = gq_rslt.getquota_rslt_u.gqr_rquota.rq_fsoftlimit;
                space->sp.quota.files.usage = gq_rslt.getquota_rslt_u.gqr_rquota.rq_curfiles;
                space->sp.quota.files.timeleft = gq_rslt.getquota_rslt_u.gqr_rquota.rq_ftimeleft;
                space->sp.quota.files.bsize = 1; /* set multiplier to 1 for file counts */
                normalise_quota(&space->sp.quota.space);
                return RPC_SUCCESS;
                }

        case Q_NOQUOTA:
                break;

        case Q_EPERM:
                return RPC_AUTHERROR;
#if 0 /* unix error */
                fprintf(stderr, "quota permission error, host: %s\n", hostp);
#endif
                break;

        default:
                return RPC_SYSTEMERROR;
#if 0 /* unix error */
                fprintf(stderr, "bad rpc result, host: %s\n",  hostp);
#endif
                break;
        }
        return RPC_SUCCESS;
}

/*
        Read the real time clock, mix into the load/exec address
*/
_kernel_oserror *utils_setnowcs(unsigned long *load, unsigned long *exec)
{
        char time_result[ 5 ];
        _kernel_oserror *err;
        
        time_result[0] = Word_ReadRealTime5ByteFormat;
        err = _swix(OS_Word, _INR(0,1), Word_DateAndTime, time_result);

        if ( err == NULL )
        {
            *exec = *(int *)time_result;
            *load = (*load & ~0xFF) | time_result[4];
        }

        return err;
}

/*
        Get the filesystem space information for a mount point
*/
_kernel_oserror *utils_getfsspace( utils_spacestr *space,  char *mount_name )
{
        enum clnt_stat stat;
        _kernel_oserror *err;
        MountPoint *mount_point = find_mount( mount_name );
        FSSTAT3res *sres;
        unused_client *nfs_client, *quota_client;
        bzero(space, sizeof(*space));

        if ( mount_point == NULL )
        {
                return mb_no_mount_point_found;
        }

        /*
        JRS 11/9/92 get quota numbers which are more useful than statfs numbers
        */
        if (!getenv("NFS$NoQuotas"))
        {
        err = get_quota_client( &quota_client, mount_point );
        if ( err == NULL )
        {
                dprintf(("quota_1", "getnfsquota(%s,,use quota)\n", mount_name));
                stat = getnfsquota( mount_point, quota_client->client, TRUE, space );

                release_client( quota_client );

                if ((stat == RPC_SUCCESS) && space->active_quota) /* quota is defined */
                        return NULL;

                dprintf(("quota_1", "getnfsquota failed (%d, %d)\n", stat, space->active_quota));
        }
        }
        /*
                 if quota info not available get results from statfs
        */
        space->active_quota = FALSE;

        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

	if (nfs_client->version == NFS_V3)
	{
          sres = nfsproc3_fsstat_3( (FSSTAT3args *) &mount_point->fhandle.fh3, nfs_client->client );
	}
	else
	{
          sres = nfs2_em_fsstat_3( (FSSTAT3args *) &mount_point->fhandle.fh3, nfs_client->client );
	}
        err = rpcnfs_to_riscos_err( sres, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( !err )
        {
                static const unsigned shift = 10;
                FSSTAT3resok *const res = &sres->FSSTAT3res_u.resok;

                space->sp.statfs.bsize  = 1UL<<shift;
                space->sp.statfs.blocks = ui64_value(ui64_shift_right(&res->tbytes, shift));
                space->sp.statfs.bfree  = ui64_value(ui64_shift_right(&res->fbytes, shift));
                space->sp.statfs.bavail = ui64_value(ui64_shift_right(&res->abytes, shift));

                dprintf(("quota_1", "blocks on device: %#lx\n", space->sp.statfs.blocks));
                dprintf(("quota_1", "free   on device: %#lx\n", space->sp.statfs.bfree));
                dprintf(("quota_1", "avail  on device: %#lx\n", space->sp.statfs.bavail));

                dprintf(("quota_1", "blocks on device: (high) %#lx\n", res->tbytes.high));
                dprintf(("quota_1", "free   on device: (high) %#lx\n", res->fbytes.high));
                dprintf(("quota_1", "avail  on device: (high) %#lx\n", res->abytes.high));

        }

        if (sres != NULL)
                xdr_free(xdr_FSSTAT3res, sres);

        return err;
}

/* read the appropriate NFS$CreateAccess environment variable */
int utils_getcreateaccess(nfs_file_descriptor *ndesc)
{
        int mask = ( NFSMODE_OTHERS_WRITE | NFSMODE_OTHERS_READ |
                     NFSMODE_GROUP_WRITE | NFSMODE_GROUP_READ |
                     NFSMODE_USER_WRITE | NFSMODE_USER_READ );
        int rval = -1, umask;
        char sysvar_buffer[ 20 ];
        char *dummy;
        char *create_access_var = malloc( strlen(NFSCreateAccessVariable) + 1  /* 1 for the '_' */
                                        + strlen(ndesc->mp->mount_point_name) + 1 ); /* 1 for the '\0' */

        if (create_access_var != NULL)
        {
        /*
                Try variable "NFS$CreateAccess_foo" where foo is the mount name
        */
                strcpy(create_access_var, NFSCreateAccessVariable);
                strcat(create_access_var, "_");
                strcat(create_access_var, ndesc->mp->mount_point_name);
                if ( _kernel_getenv( create_access_var, sysvar_buffer, 20 ) == NULL )
                {
                        sysvar_buffer[ 19 ] = '\0';
                        rval = (int)strtol( sysvar_buffer, &dummy, 0 ) & mask;
                }
                free(create_access_var);
                if (rval >= 0) return rval;
        }
        /*
                Try variable "NFS$CreateAccess"
        */
        if ( _kernel_getenv( NFSCreateAccessVariable, sysvar_buffer, 20 ) == NULL )
        {
                sysvar_buffer[ 19 ] = '\0';
                return (int)strtol( sysvar_buffer, &dummy, 0 ) & mask;
        }

        umask = ndesc->mp->user->umask;
        if (umask != -1)
        {
                return mask & ~umask;
        }

        return -1;
}
@


4.9
log
@Store lxa files verbatim, without appendum
Files saved with load & exec address (as opposed to a filetype and the top nybble of load set to 0xFFF) would be extended by 8 bytes in order to hide the true load/exec for later retrieval.
While useful if only ever saving and retrieving from the RISC OS viewpoint, it would create apparently corrupt or overlong file if you wanted to do any analysis on the NFS server end. Given load/exec addresses are deprecated, change NFS to behave like LanManFS and just denote ",lxa" suffixed files with the appropriate icon in the Filer and a made up load/exec address.

pathmunge.c/_GBPB.c/V2support.c/_Args.c/_File.c/PutBytesX.c/Static.c/Changeinfo.c: Switch out 8 byte appending code. Give the file a proper date stamp instead when viewed on Unix.
_Open.c: Switch out the 8 byte appendum stuff, and use a common OS_Word 14 clock function.
Statics.h/Modulewrap.c: Compute a substitute load/exec using the same algorithm as LanManFS (the Kernel's address rounded down to 1MB). Use cmhg finalise function instead of atexit().

Also
MakeFile: pass in predefine DEBUG for debug builds.
cmhg/NFSHdr: remove *Histogram debug command except when debugging. Add finalise handler.
Commands.c/Commands.h: remove *Histogram debug command except when debugging.
Utils.c: delete unused long long support functions. Add a new time getting support function.
Utils.h: new time getting support function.

Tested with a handful of area saves using *Save, checking the file size when viewed at the server end was correct not 8 bytes longer.

Version 3.25. Tagged as 'NFS-3_25'
@
text
@d30 1
d467 4
a470 1
        if ((u_int)buffer >= 0x40000000)
@


4.8
log
@Use OS_ReadLine32 when near top bit set addresses
The password prompt will use OS_ReadLine32 if the buffer address has b31 or b30 set, a known issue with the original OS_ReadLine which packed flags up there.

Version 3.24. Tagged as 'NFS-3_24'
@
text
@a544 111
#if 0
/*
        Very long arithmetic routines
*/
static void add_step
(
        unsigned int *result,
        unsigned int a,
        unsigned int b,
        unsigned int *carry
)
{
        unsigned int work;

        work = (a & 0xffff) + (b & 0xffff) + *carry;
        *result = work & 0xffff;
        *carry = work >> 16;

        work = (a >> 16) + (b >> 16) + *carry;
        *result = *result | (work << 16);
        *carry = work >> 16;
}

void very_long_add
(
        unsigned int *rlo,
        unsigned int *rhi,
        unsigned int alo,
        unsigned int ahi,
        unsigned int blo,
        unsigned int bhi
)
{
        unsigned int carry = 0;

        add_step( rlo, alo, blo, &carry );
        add_step( rhi, ahi, bhi, &carry );
}

void very_long_multiply
(
        unsigned int *rlo,
        unsigned int *rhi,
        unsigned int alo,
        unsigned int ahi,
        unsigned int blo,
        unsigned int bhi
)
{
        unsigned int carry;

        *rlo = 0;
        *rhi = 0;

        while( (alo | ahi) != 0 )
        {
                if ( alo & 0x1 )
                        very_long_add( rlo, rhi, *rlo, *rhi, blo, bhi );

                /*
                        shift a right by 1
                */
                carry = ahi & 0x1;
                alo = (alo >> 1) + (carry << 31);
                ahi = ahi >> 1;

                /*
                        shift b left by 1
                */
                carry = blo & 0x80000000;
                bhi = (bhi << 1) + (carry >> 31);
                blo = blo << 1;
        }
}

static void subtract_step
(
        unsigned int *result,
        unsigned int a,
        unsigned int b,
        unsigned int *carry
)
{
        unsigned int work;

        work = (a & 0xffff) - (b & 0xffff) - *carry;
        *result = work & 0xffff;
        *carry = (work >> 16) & 0x1;

        work = (a >> 16) - (b >> 16) - *carry;
        *result = *result | (work << 16);
        *carry = (work >> 16) & 0x1;
}

void very_long_subtract
(
        unsigned int *rlo,
        unsigned int *rhi,
        unsigned int alo,
        unsigned int ahi,
        unsigned int blo,
        unsigned int bhi
)
{
        unsigned int carry = 0;

        subtract_step( rlo, alo, blo, &carry );
        subtract_step( rhi, ahi, bhi, &carry );
}
#endif

d650 20
@


4.7
log
@Export our own SWIs as a header
Use the shared makefiles to export Interface/NFS.h and Hdr:NFS.
Remove local copy NFS.h which confuses the dependency checking, now called nfsheaders.h instead.
Delete unused UID/GID pair.
Tested on a mount from FreeBSD 11.1-RELEASE-p4.

Version 3.23. Tagged as 'NFS-3_23'
@
text
@d457 1
d466 17
a482 4
        err = _swix(OS_ReadLine, _INR(0,4)|_OUT(1)|_OUT(_FLAGS),
                                 (int)buffer |
                                       ReadLine_ReflectOnlyBuffered |
                                       ReadLine_ReflectFixedCharacter,
d486 1
a486 1
                                 Password_BlankCharacter,
@


4.6
log
@Merged in branch sbrodie_NFS_dev.
Also added -c90 to CFLAGS so that it will build with recent compilers.
Warning: provokes compiler bugs in many recent compilers!

Version 3.19. Tagged as 'NFS-3_19'
@
text
@d28 1
a28 1
#include "NFS.h"
@


4.5
log
@  Changes to error handling in host record creation.
Detail:
  The functions called to establish whether a remote host supports
    PCNFSv2, Mount v3 and NFS v3 were not being very helpful with
    errors - always setting the NFS version supported to 2 on an
    error.  The functions now use clnt_call() directly so they can
    test the fn result for RPC_PROGVERSMISMATCH and only revert
    the version number in that case and generate real errors in other
    failure cases (e.g. Escape)
  Group names blanked out on creation of UserSpecification objects.
    Data was being left uninitialised if the group name was unavailable
    which screwed up the output of *NFSInfo.
Admin:
  Tested against an NFS2 only server and an NFS3 capable server.
  Correct reporting of Escape requires changes to TCPIPLibs (rpclib).
    These are ongoing.

Version 3.13. Tagged as 'NFS-3_13'
@
text
@d643 22
d703 13
a715 6
                space->sp.quota.space.usage = gq_rslt.getquota_rslt_u.gqr_rquota.rq_curblocks *
                    (u_long) gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize;
                space->sp.quota.space.slim = gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsoftlimit *
                    (u_long) gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize;
                space->sp.quota.space.hlim = gq_rslt.getquota_rslt_u.gqr_rquota.rq_bhardlimit *
                    (u_long) gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize;
d721 2
d766 2
d771 1
d778 3
d806 1
d811 9
@


4.5.2.1
log
@  Added new SWI NFS_FreeSpace64
Detail:
  This SWI provides 64-bit free space information to external users.
    It's SWI number is &41506.  It's register usage is identical to
    that of the Free module's reason code 4 (PRM 5a-257)
  If NFS$NoQuotas is set, you will always be shown the disc parameters in
    preference to the quota information.
Admin:
  Desktop builds require Free 0.37 or later to use this new SWI.
  Tested with softloaded Free and NFS - it reports sol's /export/home
    statistics correctly.


Version 3.18, 4.22.2.3. Tagged as 'NFS-3_18-4_22_2_3'
@
text
@a642 22
        Adjust quota sizes so results are in kilobytes
*/
static void normalise_quota(utils_quotastr *quota)
{
  if (quota->bsize < 1024) {
    u_long multiplier = 1024ul / quota->bsize;

    quota->usage /= multiplier;
    quota->slim  /= multiplier;
    quota->hlim  /= multiplier;
  }
  else if (quota->bsize > 1024) {
    u_long divider = quota->bsize / 1024ul;
    quota->usage *= divider;
    quota->slim  *= divider;
    quota->hlim  *= divider;
  }

  quota->bsize = 1024;
}

/*
d681 6
a686 13
                dprintf(("quota_1", "used: %#lx * %#lx\n",
                  (u_long) gq_rslt.getquota_rslt_u.gqr_rquota.rq_curblocks,
                  (u_long) gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize));
                dprintf(("quota_1", "soft: %#lx * %#lx\n",
                  (u_long) gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsoftlimit,
                  (u_long) gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize));
                dprintf(("quota_1", "hard: %#lx * %#lx\n",
                  (u_long) gq_rslt.getquota_rslt_u.gqr_rquota.rq_bhardlimit,
                  (u_long) gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize));
                space->sp.quota.space.bsize = gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize;
                space->sp.quota.space.usage = gq_rslt.getquota_rslt_u.gqr_rquota.rq_curblocks;
                space->sp.quota.space.slim = gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsoftlimit;
                space->sp.quota.space.hlim = gq_rslt.getquota_rslt_u.gqr_rquota.rq_bhardlimit;
a691 2
                space->sp.quota.files.bsize = 1; /* set multiplier to 1 for file counts */
                normalise_quota(&space->sp.quota.space);
a734 2
        if (!getenv("NFS$NoQuotas"))
        {
a737 1
                dprintf(("quota_1", "getnfsquota(%s,,use quota)\n", mount_name));
a743 3

                dprintf(("quota_1", "getnfsquota failed (%d, %d)\n", stat, space->active_quota));
        }
a768 1

a772 9

                dprintf(("quota_1", "blocks on device: %#lx\n", space->sp.statfs.blocks));
                dprintf(("quota_1", "free   on device: %#lx\n", space->sp.statfs.bfree));
                dprintf(("quota_1", "avail  on device: %#lx\n", space->sp.statfs.bavail));

                dprintf(("quota_1", "blocks on device: (high) %#lx\n", res->tbytes.high));
                dprintf(("quota_1", "free   on device: (high) %#lx\n", res->fbytes.high));
                dprintf(("quota_1", "avail  on device: (high) %#lx\n", res->abytes.high));

@


4.4
log
@  Fixed potential use of uninitialised pointer.
Detail:
  If the LOOKUP remote procedure chose not to supply the optional
    object attributes in its result, the attribute pointer would
    remain uninitialised and be treated as safe to use.  This can
    no longer occur.
  All but the unused static rcsid variable compile warnings removed.
Admin:
  Requires AsmUtils 0.06 or later.
  Requires Library 0.39 or later (for rpcgen 0.03 or later)
  Built and tested on Risc PC.

Version 3.07. Tagged as 'NFS-3_07'
@
text
@d166 1
d286 1
d345 5
a349 2
                initialise_nfs_version( new_host );
                initialise_pcnfs_version( new_host );
d352 7
@


4.3
log
@  Now uses PCNFS version 2 to authenticate.
Detail:
  Group-writable directories should now be writable to.
  setgid directories should cause created objects to take on
    the directory group ownership instead of the user's primary
    GIF
  *NFSInfo output enhanced to list all the additional group IDs
    and the default umask being applied to each authentication.
Admin:
  Tested on normal home mount and on TWC mount.

Version 3.05. Tagged as 'NFS-3_05'
@
text
@d670 1
a670 1
                    gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize;
d672 1
a672 1
                    gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize;
d674 1
a674 1
                    gq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize;
@


4.2
log
@  Now supports NFS version 3.
Detail:
  All client-server calls now use the superior NFS3 protocol.
  This particularly benefits directory enumeration and *NFSInfo
    is now reporting 80%+ cache hit rates which is a significant
    improvement (over 5% better - some hosts report 85%+)
  Hashing algorithms improved to increase cache hits (the cache
    algorithm doesn't use parts of names after a comma, so that
    the hash value for !Run is the same as the hash value for
    !Run,feb - which helps the cache hit rate a lot).   Directory
    browsing on the desktop appears noticably faster too.
  The module now has the original protocol (.x) files defining
    the RPC protocols being used (NFS, mount, pcnfs, rquota)
    and uses them to generate header files, XDR implementations,
    and client stubs automatically, instead of having hand
    written versions.
  NFS workspace comes from a dynamic area where possible.
Admin:
  Supporting documentation:
    Acorn NFS Software Functional Specification (1215,250/FS)
    RFC1014, RFC1057, RFC1094, RFC1813
  Tested in several desktop machines for everyday use against
    both NFS2 and NFS3 servers.
  Requires rpcgen 0.01 or later
    (CVS source: Tools/Sources/rpcgen  tag: rpcgen-0_01 or later)
    (CVS binary: RiscOS/Library  tag: Library-0_19 or later)
  Requires TCPIPLibs 5.13 or later
    (CVS: RiscOS/Sources/Lib/TCPIPLibs  tag: TCPIPLibs-5_13)

Version 3.00. Tagged as 'NFS-3_00'
@
text
@d103 4
a106 1
        AUTH *authorisation
d164 7
d344 1
d775 1
a775 1
        int rval = -1;
d805 7
@


4.1
log
@Initial revision
@
text
@d333 2
d377 1
a377 1
static void junk_clients
d508 1
d617 1
d636 1
a636 1
        gq_args.gqa_uid = mount->user->uid;
d652 1
a652 1
        switch (gq_rslt.gqr_status) {
d655 1
a655 1
                space->active_quota = gq_rslt.gqr_rquota.rq_active;
d658 11
a668 11
                space->sp.quota.space.usage = gq_rslt.gqr_rquota.rq_curblocks *
                    gq_rslt.gqr_rquota.rq_bsize;
                space->sp.quota.space.slim = gq_rslt.gqr_rquota.rq_bsoftlimit *
                    gq_rslt.gqr_rquota.rq_bsize;
                space->sp.quota.space.hlim = gq_rslt.gqr_rquota.rq_bhardlimit *
                    gq_rslt.gqr_rquota.rq_bsize;
                space->sp.quota.space.timeleft = gq_rslt.gqr_rquota.rq_btimeleft;
                space->sp.quota.files.hlim = gq_rslt.gqr_rquota.rq_fhardlimit;
                space->sp.quota.files.slim = gq_rslt.gqr_rquota.rq_fsoftlimit;
                space->sp.quota.files.usage = gq_rslt.gqr_rquota.rq_curfiles;
                space->sp.quota.files.timeleft = gq_rslt.gqr_rquota.rq_ftimeleft;
d700 1
a700 1
        statfsres *sres;
d731 8
a738 1
        sres = nfsproc_statfs_2( &mount_point->fhandle, nfs_client->client );
d742 9
a750 2
        if ( err )
                return err;
d752 2
a753 4
        space->sp.statfs.bsize = sres->statfsres_u.reply.bsize;
        space->sp.statfs.blocks = sres->statfsres_u.reply.blocks;
        space->sp.statfs.bfree  = sres->statfsres_u.reply.bfree;
        space->sp.statfs.bavail = sres->statfsres_u.reply.bavail;
d755 1
a755 1
        return NULL;
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@

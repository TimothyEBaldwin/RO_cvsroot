head	4.9;
access;
symbols
	NFS-3_27:4.9
	NFS-3_26:4.9
	NFS-3_25:4.9
	NFS-3_24:4.8
	NFS-3_23:4.8
	NFS-3_22:4.7
	NFS-3_21:4.7
	NFS-3_20:4.6
	NFS-3_19:4.6
	sbrodie_NFS_dev_merge:4.5.2.1
	NFS-3_18-4_22_2_4:4.5.2.1
	NFS-3_18-4_22_2_3:4.5.2.1
	NFS-3_18-4_22_2_2:4.5.2.1
	NFS-3_18-4_22_2_1:4.5
	sbrodie_NFS_dev:4.5.0.2
	sbrodie_NFS_dev_bp:4.5
	NFS-3_18:4.5
	NFS-3_17:4.5
	NFS-3_16:4.5
	NFS-3_15:4.5
	NFS-3_14:4.5
	NFS-3_13:4.5
	NFS-3_12:4.5
	NFS-3_11:4.5
	NFS-3_10:4.5
	NFS-3_09:4.5
	NFS-3_08:4.5
	NFS-3_07:4.5
	NFS-3_06:4.4
	NFS-3_05:4.4
	NFS-3_04:4.4
	NFS-3_02:4.4
	NFS-3_01:4.4
	NFS-3_00:4.3
	NFS-2_37:4.2
	NFS-2_36:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.4
	NFS-2_35:4.2
	Spin_merge:4.1.7.1
	Spinner_23Sep1998_destend:4.2
	Spinner_23Sep1998_srcend:4.1.7.1
	Spinner_23Sep1998_srcbegin:4.1.7.1
	Spinner_23Sep1998_destbegin:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.2
	Ursula_13May1998_bp:4.1
	Ursula_13May1998:4.1.0.4
	rthornb_UrsulaBuild_01May1998:4.1
	pwombwel_2_32:4.2
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	MergeFiles:4.1.7.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1;
locks; strict;
comment	@# @;


4.9
date	2018.03.07.21.22.41;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	sKJZhgBEKf2WsztA;

4.8
date	2018.01.29.21.30.19;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	7TGUL0NEVVbjHOoA;

4.7
date	2004.07.30.11.42.15;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2003.12.10.14.55.09;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2000.03.15.14.16.12;	author sbrodie;	state Exp;
branches
	4.5.2.1;
next	4.4;

4.4
date	99.10.13.09.54.01;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	99.05.14.12.42.22;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	98.03.25.18.57.11;	author pwombwel;	state Exp;
branches;
next	4.1;

4.1
date	96.11.22.14.49.29;	author nturton;	state Exp;
branches
	4.1.5.1
	4.1.7.1;
next	;

4.5.2.1
date	2001.06.12.13.37.41;	author sbrodie;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.49.29;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.06.46;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.9
log
@Store lxa files verbatim, without appendum
Files saved with load & exec address (as opposed to a filetype and the top nybble of load set to 0xFFF) would be extended by 8 bytes in order to hide the true load/exec for later retrieval.
While useful if only ever saving and retrieving from the RISC OS viewpoint, it would create apparently corrupt or overlong file if you wanted to do any analysis on the NFS server end. Given load/exec addresses are deprecated, change NFS to behave like LanManFS and just denote ",lxa" suffixed files with the appropriate icon in the Filer and a made up load/exec address.

pathmunge.c/_GBPB.c/V2support.c/_Args.c/_File.c/PutBytesX.c/Static.c/Changeinfo.c: Switch out 8 byte appending code. Give the file a proper date stamp instead when viewed on Unix.
_Open.c: Switch out the 8 byte appendum stuff, and use a common OS_Word 14 clock function.
Statics.h/Modulewrap.c: Compute a substitute load/exec using the same algorithm as LanManFS (the Kernel's address rounded down to 1MB). Use cmhg finalise function instead of atexit().

Also
MakeFile: pass in predefine DEBUG for debug builds.
cmhg/NFSHdr: remove *Histogram debug command except when debugging. Add finalise handler.
Commands.c/Commands.h: remove *Histogram debug command except when debugging.
Utils.c: delete unused long long support functions. Add a new time getting support function.
Utils.h: new time getting support function.

Tested with a handful of area saves using *Save, checking the file size when viewed at the server end was correct not 8 bytes longer.

Version 3.25. Tagged as 'NFS-3_25'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*	C.PATHMUNGE

Purpose : This file gathers together the routines to perform file path
	  specific functions.

Functions:  assess_root_for_filename
	    find_dir_for_leaf
	    simple_riscos_to_nfs
	    appended_riscos_to_nfs
	    riscos_name_to_nfsname
	    move_nfsname_to_riscos_name
	    nfsname_to_riscos_name
	    extend_nfs_lookup
	    nfs_lookup_extended
	    caseless_wildncmp
	    wildncmp
	    caseless_strncmp
	    caseless_strcmp
	    find_object_in_directory
	    find_leaf
	    find_directory_leaf
	    find_regular_leaf
	    reject_nfs_file


History :
Date	Who    Comments
-----------------------------------------------------------------------------
07/05/93 ??    INITIAL VERSION
13/1/95	 CP    Changed find_object_in_directory to use new Get_NFS_Directory
	       routine.
7/2/95   CP    Corrected bugs in  find_object_in_directory
16/2/95  CP    Removed case tolerance from find_object_in_directory
21/2/95  CP    Added more detailed comments about each function to make code
 	       more maintainable in the future.
13/3/95  CP    Re-enabled case tolerance in find_object_in_directory
28/3/95  CP    Remembered there are two instances of case-sensitive code!

****************************************************************************/

#ifndef __NFSNFS_H
#include "nfsheaders.h"
#endif

#include "enumdir.h" /* prototypes */

#define TRACE_LOC 0 /* turn local tracing on or off */


/********* assess_root_for_filename *****************************************

Purpose : Strips off the root sequence of filepath, returning a pointer into
          filepath of what's left. The root sequence is found in the
	  structures and details for it are returned. The path for the root
	  sequence is relative to the mount point and so may by a "" string.

Inputs : filepath     ptr to the path to work on
         mount_point  ptr to ptr, for storing result
       	 path_to_root ptr to ptr, for storing result
       	 dirpath      ptr to ptr, for storing result

Returns : NULL if everything OK, error ptr otherwise
	  mount_point points to mount information
	  path_to_root points to directory path string
	     (inside filepath data!)
	  dirpath points to the leaf name string (inside filepath data!)

****************************************************************************/

static _kernel_oserror *assess_root_for_filename( char *filepath, MountPoint **mount_point,
        char **path_to_root, char **dirpath)
{
        char *filename = filepath;
        _kernel_oserror *err = NULL;

        /*
                Find the directory separator or the end of string
        */
        while ( *filename != '\0' &&
                *filename != FileChar_DirectorySeparator )
        {
                filename++;
        }

        /*
                Find the mount point
        */
        if ( *filename )
        {
                *filename = '\0';
                *mount_point = find_mount( filepath + 1 );
                *filename++ = FileChar_DirectorySeparator;
        }
        else
        {
                *mount_point = find_mount( filepath + 1 );
        }

	dprintf(("pathmunge_5", "assess_root_for_filename(%s) -> MP = %p\n", filepath, *mount_point));

        /*
                Check the mount point got found
        */
        if ( !*mount_point )
        {
                err = mb_no_mount_point_found;
        }
        else
        {
                *path_to_root = "";
        }

        /*
                Move past the $ or $. if present
        */
        if ( filename[0] == FileChar_Root )
        {
                if ( filename[1] == FileChar_DirectorySeparator )
                        filename += 2;
                else if ( filename[1] == '\0' )
                        filename += 1;
        }

        *dirpath = filename;

        return err;
} /* endfunction assess_root_for_filename */


/*********** find_dir_for_leaf **********************************************

Purpose : finds the directory for the given leaf. If found then *path_to_here
	  will be pointed at the full path for the dir, including preceding
	  ':' and trailing '.'. If path_to_here is NULL then no string will
	  be constructed. If a memory shortage occurs whilst constructing
	  path_to_here, then it will remain unconstructed.

Inputs : filepath      ptr to the leaf string
         ndesc         ptr
         path_to_leaf  ptr to ptr, for storing result
         leaf_position ptr to ptr, for storing result

Returns : NULL if OK, otherwise system error
	  path_to_leaf points to path to leaf string
	  leaf position points to the leaf name
	  ndesc filled in with details of directory holding the leaf

****************************************************************************/


_kernel_oserror *find_dir_for_leaf( char *filepath, nfs_file_descriptor *ndesc,
        char **path_to_leaf,        /* output */
        char **leaf_position	    /* output */
)
{
        char *dirpath;
        char *path_to_root;
        _kernel_oserror *err;
        char *full_dirpath;
        char *position;
        char *next_separator;

        /*
                Find the path from the mount point to the root
        */
        err = assess_root_for_filename( filepath, &ndesc->mp, &path_to_root, &dirpath );

        if ( err )
        {
                return err;
        }

        /*
                Tack the root path and the dirpath together to get the full path from
                the mount point to the leaf.
        */
        full_dirpath = malloc( strlen( path_to_root ) + 1 + strlen( dirpath ) + 1 );

        if ( full_dirpath == NULL )
        {
                return mb_malloc_failed;
        }

        sprintf( full_dirpath, "%s%c%s", path_to_root, FileChar_DirectorySeparator, dirpath );

        fh3cpy(&ndesc->dir, &ndesc->mp->fhandle);
        position = full_dirpath;
        for ( next_separator = strchr( position, FileChar_DirectorySeparator );
                !err && next_separator;
                position = next_separator + 1,
                        next_separator = strchr( position, FileChar_DirectorySeparator ) )
        {
                if ( next_separator > position )
                {
                        *next_separator = '\0';

                        err = find_object_in_directory( ndesc, position );

                        if ( !err )
                        {
                                free( ndesc->desc.name );
                                fh3cpy(&ndesc->dir, &ndesc->file);
                        }

                        *next_separator = FileChar_DirectorySeparator;
                }
        }

        if ( err )
        {
                free( full_dirpath );
        }
        else
        {
                *path_to_leaf = full_dirpath;
                *leaf_position = position;
        }

        return err;
} /* endfunction find_dir_for_leaf */



/********* simple_riscos_to_nfs *********************************************

Purpose : Converts from a riscos name to an NFS equivalent.  Doesn't do
	  anything fancy - just changes '/' to '.' and '<' to '$'

Inputs : dest    ptr to ptr, to store result
         source  ptr to name to convert

Returns : NULL if OK, otherwise system err ptr
	  dest filled with converted name

****************************************************************************/

static _kernel_oserror *simple_riscos_to_nfs( char **dest, char *source)
{
        int i;

        *dest = malloc( strlen( source ) + 1 );

        if ( *dest == NULL )
                return mb_malloc_failed;

        for ( i = 0;
                source[ i ] != '\0';
                i++ )
        {
                /* Convert RISCOS / into UNIX . extension */
                if ( source[ i ] == FileChar_NFSDirectorySeparator )
                {
                        (*dest)[ i ] = FileChar_DirectorySeparator;
                }
                else if ( source[ i ] == '<' )
                {
                        (*dest)[ i ] = '$';
                }
                else
                {
                        (*dest)[ i ] = source[ i ];
                }
        }

        (*dest)[i] = '\0';

       return NULL;
} /* endfunction sinple_riscos_to_nfs */


/********* appended_riscos_to_nfs ******************************************

Purpose :  Translate from riscos name ('/' = '.') to nfs name and
	   appends given string

Inputs : dest            ptr to ptr, for result
       	 source		 ptr to riscos name to convert
       	 appended_source ptr to string to append

Returns : NULL if OK, else ptr to error
	  dest holds onverted string

****************************************************************************/


static _kernel_oserror *appended_riscos_to_nfs( char **dest, char *source, char *appended_source)
{
        int i;

        *dest = malloc( strlen( source ) + strlen( appended_source ) + 1 );

        if ( *dest == NULL )
                return mb_malloc_failed;

        for ( i = 0;
                source[ i ] != '\0';
                i++ )
        {
                /* Convert RISCOS / into UNIX . extension */
                if ( source[ i ] == FileChar_NFSDirectorySeparator )
                {
                        (*dest)[ i ] = FileChar_DirectorySeparator;
                }
                else if ( source[ i ] == '<' )
                {
                        (*dest)[ i ] = '$';
                }
                else
                {
                        (*dest)[ i ] = source[ i ];
                }
        }

        strcpy( &(*dest)[ i ], appended_source );

        return NULL;
} /* endfunction appended_riscos_to_nfs */


/********* riscos_name_to_nfs_name ******************************************

Purpose : Convert a riscos name to an nfs name, including file type
	  identifier (<name>,<type>)

Inputs : nname   ptr to ptr, for result
       	 rname   ptr to riscos name to convert
       	 attr	 attributes of riscos file (including type info)

Returns : NULL if OK, else ptr to error
	  nname holds converted string

****************************************************************************/

_kernel_oserror *riscos_name_to_nfsname( char **nname, char *rname,
                        RISCOSAttributes *attr)
{
        _kernel_oserror *err;
        char hex_appendment[ 5 ];

        if ( !(attr->type & FileType_File) )
        {
                /*
                        Not a file
                */
                return simple_riscos_to_nfs( nname, rname );
        }
        else if ( attr->load_address == 0xdeaddead &&
                  attr->execute_address == 0xdeaddead )
        {
                /*
                        Dead file
                */
                sprintf( hex_appendment, "%c%s", FileChar_TypedNamePrefix, FileString_DeadFile );
                return appended_riscos_to_nfs( nname, rname, hex_appendment );
        }
        else if ( (attr->load_address & 0xfff00000) != 0xfff00000 || attr->load_address == attr->execute_address )
        {
                /*
                        Untyped file
                */
                sprintf( hex_appendment, "%c%s", FileChar_TypedNamePrefix, FileString_UntypedFile );
                return appended_riscos_to_nfs( nname, rname, hex_appendment );
        }
        else
        {
                         err = extensions_extend_nfs_name_with_file_type( nname, rname, (attr->load_address & 0x000fff00) >> FileType_Shift );

                if ( err || *nname != NULL )
                        return err;

                if ( (attr->load_address & 0xffffff00) == (0xfff00000 | (FileType_Text << FileType_Shift)) ||
                     (attr->load_address & 0xffffff00) == (0xfff00000 | (FileType_UNIXExecutable << FileType_Shift)) )
                {
                        /*
                                Text file or unix executable file
                        */
                        return simple_riscos_to_nfs( nname, rname );
                }
                else
                {
                        /*
                                Typed file
                        */
                        sprintf( hex_appendment, "%c%03lx", FileChar_TypedNamePrefix, (attr->load_address >> FileType_Shift) & FileType_Mask );
                        return appended_riscos_to_nfs( nname, rname, hex_appendment );
                }
        }
}  /* endfunction riscos_name_to_nfsname */



/********* move_nfsname_to_riscos_name **************************************

Purpose : Copies nfs name to a riscosname, making all the necessary changes

Inputs : riscosname ptr to _allocated_ memory for riscos string
       	 nfsname    ptr to nfs file string
       	 ndesc      ptr to nfs file descriptor structure

Returns : void
	  *riscosname filled in with converted name

****************************************************************************/

void move_nfsname_to_riscos_name( char *riscosname, char *nfsname,
        nfs_file_descriptor *ndesc)
{
        int length_to_copy;
        int i;
        unsigned long filetype;
        fattr3 *attr;
        _kernel_oserror *err;

        /* table for the nfs to riscos conversion
        under ascii 32 excluded, :*#$&@@^%\ excluded as illegal under riscos
        And . to / and space to hard space
        */

        static const char lookup_table[]   ="________________________________"
                                            " !\"_<__'()_+,-//0123456789_;<=>?"
                                            "_ABCDEFGHIJKLMNOPQRSTUVWXYZ[_]__"
                                            "`abcdefghijklmnopqrstuvwxyz{|}~_"
                                            "€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ"
                                            " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿"
                                            "ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞß"
                                            "àáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ";

        COMPILE_TIME_ASSERT(sizeof(lookup_table) == 257);

        /* JRS 28/8/92 get the attributes to see if it is a regular file.
         * Only files should have extensions removed */
        err = nfs_getattr( &attr, ndesc->mp, &ndesc->file );

        if ( (err == NULL) && (attr->type == NFREG) )
        { /* JRS 28/8/92 leave extension unaltered if there was an error getting the type */
                /*
                        Try a user defined extension first for a regular file
                */
                extensions_check_nfs_name_for_extension( nfsname, &filetype, &length_to_copy );
        }
        else
                filetype = -1UL;

        if ( filetype == -1UL )
        {
                /*
                Assess how much needs to be copied:
                length, less extensions, and not more than a max riscos name
                */
                length_to_copy = strlen( nfsname );

                if ( length_to_copy >= 4 &&
                     nfsname[length_to_copy-4] == FileChar_TypedNamePrefix &&
                     (( strchr( HexChars, nfsname[length_to_copy-3] ) != NULL &&
                       strchr( HexChars, nfsname[length_to_copy-2] ) != NULL &&
                       strchr( HexChars, nfsname[length_to_copy-1] ) != NULL ) ||
                        strcmp( &nfsname[length_to_copy-3], FileString_DeadFile ) == 0 ||
                        strcmp( &nfsname[length_to_copy-3], FileString_UntypedFile ) == 0 ) )
                {
                        length_to_copy -= 4;
                }
        }

        length_to_copy = MIN( length_to_copy, max_riscos_name_length );

        /*
                Convert UNIX characters that are illegal under riscos
                into friendly ones :-)

        */
        for ( i = 0; i < length_to_copy; i++ )
                riscosname[i] = lookup_table[nfsname[i] ];

        riscosname[ length_to_copy ] = '\0';
} /* endfunction move_nfsname_to_riscos_name */



/********* nfsname_to_riscos_name *******************************************

Purpose : Converts an nfsname to a riscos name.  Uses
	  move_nfsname_to_riscos_name.

Inputs : riscosname    ptr to ptr, for result
       	 nfsname       ptr to nfs name to convert
       	 ndesc	       ptr to nfs file descriptor

Returns : NULL if OK, else ptr to error
	  riscosname points to converted name

****************************************************************************/

_kernel_oserror *nfsname_to_riscos_name( char **riscosname,
        char *nfsname, nfs_file_descriptor *ndesc)
{
        /*
                Some space for the riscos name.
        */
        *riscosname = malloc( MIN( strlen( nfsname ), max_riscos_name_length ) + 1 );

        if ( *riscosname == NULL )
                return mb_malloc_failed;

        move_nfsname_to_riscos_name( *riscosname, nfsname, ndesc );

        return NULL;
} /* endfunction nfsname_to_riscos_name */



/********* extend_nfs_lookup ************************************************

Purpose : Fills in partially completed nfs file descriptor

Inputs :   ndesc   ptr to nfs descriptor
          	   	   ->mp
          	   	   ->dir (not used)
          	   	   ->file
          	   	   ->desc.attr
          	   	   ->desc.name       are already complete

Returns : NULL if OK, otherwise ptr to error
	  ndesc has been filled in with details.  The following fields _may_
	  be changed...
             ->desc.chars_before_suffix;
             ->desc.load_address;
             ->desc.execute_address;
             ->desc.file_is_lxa;

****************************************************************************/

static _kernel_oserror *extend_nfs_lookup( nfs_file_descriptor *ndesc)
{
        char *end_of_suffixed_name;
        _kernel_oserror *err;
        unsigned long filetype;

        if ( ndesc->desc.attr.type != NF3REG )
        {
                /*
                        Non-files (without a suffix).
                */
                ndesc->desc.chars_before_suffix = strlen( ndesc->desc.name );
                ndesc->desc.file_is_lxa = No;
                return NULL;
        }

        extensions_check_nfs_name_for_extension( ndesc->desc.name, &filetype, &ndesc->desc.chars_before_suffix );
        if ( filetype != -1UL )
        {
                ndesc->desc.file_is_lxa = No;
                return NULL;
        }

        for ( end_of_suffixed_name = ndesc->desc.name + strlen( ndesc->desc.name );
                end_of_suffixed_name > ndesc->desc.name && *end_of_suffixed_name != FileChar_TypedNamePrefix;
                end_of_suffixed_name-- );

        if ( *end_of_suffixed_name == FileChar_TypedNamePrefix &&
                strlen( end_of_suffixed_name ) == 4 )
        {
                if ( caseless_strcmp( end_of_suffixed_name+1, FileString_UntypedFile ) == 0 )
                {
#ifdef LXA_BY_APPENDUM
                        /*
                                Untyped file - read appendum (load and exec address).
                        */
                        appendum bit_on_end_of_file;
                        int len_read;

                        ndesc->desc.chars_before_suffix = end_of_suffixed_name - ndesc->desc.name;

                        err = nfs_read(
                                &len_read,
                                (char *)&bit_on_end_of_file,
                                ndesc->mp,
                                &ndesc->file,
                                ui64_value(&ndesc->desc.attr.size) - lsizeof( appendum ),
                                sizeof( appendum ) );

                        if ( err )
                                return err;

                        ndesc->desc.load_address = bit_on_end_of_file.lxa.load_address;
                        ndesc->desc.execute_address = bit_on_end_of_file.lxa.execute_address;
#else
                        ndesc->desc.load_address = untyped_address;
                        ndesc->desc.execute_address = untyped_address;
#endif
                        ndesc->desc.chars_before_suffix = end_of_suffixed_name - ndesc->desc.name;
                        ndesc->desc.file_is_lxa = Yes;
                }
                else if ( caseless_strcmp( end_of_suffixed_name+1, FileString_DeadFile ) == 0 ||
                          ( strchr( HexChars, end_of_suffixed_name[ 1 ] ) != NULL &&
                            strchr( HexChars, end_of_suffixed_name[ 2 ] ) != NULL &&
                            strchr( HexChars, end_of_suffixed_name[ 3 ] ) != NULL ) )
                {
                        /*
                                Dead or typed files
                        */
                        ndesc->desc.chars_before_suffix = end_of_suffixed_name - ndesc->desc.name;
                        ndesc->desc.file_is_lxa = No;
                }
                else
                {
                        /*
                                Files with an invalid suffix
                        */
                        ndesc->desc.chars_before_suffix = strlen( ndesc->desc.name );
                        ndesc->desc.file_is_lxa = No;
                }
        }
        else
        {
                /*
                        Files without a suffix
                */
                ndesc->desc.chars_before_suffix = strlen( ndesc->desc.name );
                ndesc->desc.file_is_lxa = No;
        }

        return NULL;
} /* endfunction extend_nfs_lookup */



/********* nfs_lookup_extended **********************************************

Purpose : Checks to see if a file is there.  Gets its details if it is.
          Uses extend_nfs_lookup to fill in gaps.

Inputs : ndesc   ptr to nfs file descriptor of file to search for.
       	 	 Entries ->file, ->mp already filled in
       	 free_name  whether ndesc->desc.name needs to be freed if altered

Returns : NULL if OK (file found), ptr to error otherwise.
	  If successful, ndesc has been filled in with details.

****************************************************************************/

_kernel_oserror *nfs_lookup_extended( nfs_file_descriptor *ndesc, bool_t free_name)
{
        _kernel_oserror *err;
        fattr3 *nattr;

        dprintf(("pathmunge", "nfs_lookup_extended >>%s<< (MP=%p)\n", ndesc->desc.name, ndesc->mp));
        err = nfs_lookup( &ndesc->file, &nattr, ndesc->mp, &ndesc->dir, &ndesc->desc.name, free_name );

        if ( err )
                return err;

        ndesc->desc.attr = *nattr;

        return extend_nfs_lookup( ndesc );

} /* nfs_lookup_extended */




/********* caseless_wildncmp ************************************************

Purpose : Compares first 'charsleft' characters of two strings, ignoring
	  case, and processing wildcard characters '?', '*'.

Inputs : a           ptr to 1st string, which includes wildcards
         b  	     ptr to 2nd string to be compared, no wildcards
         charsleft   number of characters to compare

Returns : 0 if compare is successful, value of difference if it is not.

****************************************************************************/

int caseless_wildncmp( const char *a, const char *b, int charsleft )
{
        int last_wildrover = -1;        /* first wild char after last wildcard */
        int last_realrover = -1;        /* first real char after wildcard in this test sequence */
        int wild_rover = 0;
        int real_rover = 0;
        int d;

        while ( (a[wild_rover] || b[real_rover]) && real_rover < charsleft )
        {
                switch( a[wild_rover] )
                {
                case FileChar_ManyAny:
                        last_wildrover = ++wild_rover;  /* Carry on after * in wildcard string */
                        last_realrover = real_rover;    /* try matching from here */
                        break;

                case FileChar_Any:
                        if ( !b[real_rover] )
                                return a[wild_rover];

                        wild_rover++;
                        real_rover++;
                        break;

                default:
                        d = toupper( a[wild_rover] ) - toupper( b[real_rover] );
                        if ( d )
                        {
                                if ( last_wildrover < 0 || !b[real_rover] )
                                        return d;

                                wild_rover = last_wildrover;    /* Restart after * in wilcard string */
                                real_rover = ++last_realrover;  /* test one character on */
                        }
                        else
                        {
                                wild_rover++;
                                real_rover++;
                        }
                        break;
                }
        }

        return 0;
} /* endfunction caseless_wildncmp */



/********* wildncmp *********************************************************

Purpose : Compares first 'charsleft' characters of two strings, and
	  processing wildcard characters '?', '*'.  Case sensitive.

Inputs : a           ptr to 1st string, which includes wildcards
         b  	     ptr to 2nd string to be compared, no wildcards
         charsleft   number of characters to compare

Returns : 0 if compare is successful, value of difference if it is not.

****************************************************************************/

int wildncmp( const char *a, const char *b, int charsleft )
{
        int last_wildrover = -1;        /* first wild char after last wildcard */
        int last_realrover = -1;        /* first real char after wildcard in this test sequence */
        int wild_rover = 0;
        int real_rover = 0;
        int d;

        while ( (a[wild_rover] || b[real_rover]) && real_rover < charsleft )
        {
                switch( a[wild_rover] )
                {
                case FileChar_ManyAny:
                        last_wildrover = ++wild_rover;  /* Carry on after * in wildcard string */
                        last_realrover = real_rover;    /* try matching from here */
                        break;

                case FileChar_Any:
                        if ( !b[real_rover] )
                                return a[wild_rover];

                        wild_rover++;
                        real_rover++;
                        break;

                default:
                        d = a[wild_rover] - b[real_rover];
                        if ( d )
                        {
                                if ( last_wildrover < 0 )
                                        return d;

                                wild_rover = last_wildrover;    /* Restart after * in wilcard string */
                                real_rover = ++last_realrover;  /* test one character on */
                        }
                        else
                        {
                                wild_rover++;
                                real_rover++;
                        }
                        break;
                }
        }

        return 0;
} /* endfunction wildncmp */



/********* caseless_strncmp ************************************************

Purpose : Compares first 'charsleft' characters of two strings, ignoring
	  case.

Inputs : a           ptr to 1st string to be compared
         b  	     ptr to 2nd string to be compared
         charsleft   number of characters to compare

Returns : 0 if compare is successful, value of difference if it is not.

****************************************************************************/

int caseless_strncmp( const char *a, const char *b, int charsleft )
{
        int d;

        while ( (*a || *b) && charsleft-- > 0 )
        {
                d = toupper( *(a++) ) - toupper( *(b++) );
                if ( d )
                        return d;
        }

        return 0;
} /* endfunction caseless_strncmp */


/********* caseless_strcmp ************************************************

Purpose : Compares two strings, ignoring case.

Inputs : a           ptr to 1st string to be compared
         b  	     ptr to 2nd string to be compared

Returns : 0 if compare is successful, value of difference if it is not.

****************************************************************************/

int caseless_strcmp( const char *a, const char *b )
{
        int d;

        while ( *a || *b )
        {
                d = toupper( *(a++) ) - toupper( *(b++) );
                if ( d )
                        return d;
        }

        return 0;
} /* endfunction caseless_strcmp */



/*********** find_object_in_directory ***************************************

Purpose : Find an object in a directory.  Converts name of object to its NFS
	  equivalent, and checks to see if it is in the cache.  If it is not,
	  then it will open the directory being searched, and check each
	  entry one by one, trying to find the name (plus riscos/NFS
	  filetype/extension).

	  NOTE: Case tolerance has been removed.  For this function to find
	  the file, the supplied name must be exact (except for extension).

Inputs : ndesc          pointer to details of directory to search for file
         riscos_name    pointer to riscos name of object to find

Returns :  NULL if OK, otherwise _kernel_oserror pointer
	   ndesc holds the details of the found object

****************************************************************************/

_kernel_oserror *find_object_in_directory(nfs_file_descriptor *ndesc,
        				  char                *riscos_name)
{
        _kernel_oserror *err;
        char *enumed_riscos_name;
        YesNoAnswer found_a_match = No;
        YesNoAnswer found_exact_match = No;
        nfs_file_descriptor ndescf;
        char *ThisFileName;

        err = simple_riscos_to_nfs( &ndesc->desc.name, riscos_name );

        if ( err )
        {
                return err;
        }
        err = nfs_lookup_extended( ndesc, TRUE );

        /*
                Found it?
        */
        if ( !err )
        {
                return NULL;
        }

        /*
                Well, we didn't find it under this name, so lets junk it.
        */
        free( ndesc->desc.name );

        /*
                If we didn't find the object for some other reason than it just wasn't there
                then return without trying harder.
        */
        if ( err != mb_nfserr_noent )
        {
                return err;
        }

        /*
                Let's try to find the file by other means. IE lets search through the
                objects one by one until we find the one we want.
        */

        found_a_match = No;
        found_exact_match = No;

        ndescf.mp = ndesc->mp;
        fh3cpy(&ndescf.dir, &ndesc->dir);

           /* Open the directory */
        dprintf(("pathmunge", "find_object_in_directory: opening directory...."));
        err = GetNFSDirEntry(ndesc->mp, &ndesc->dir, 0, &ThisFileName, NULL, NFS_MAXDATA);

        if ( err )
           return err; /* something went wrong */

        dprintf(("pathmunge", "First file name is %s\n", ThisFileName?ThisFileName:"<<NULL>>"));

        /* Carry on while there's no error and there's more directory to
           pull across */

        while (ThisFileName != NULL)
        {
           fattr3 *attr;

           /*
                   Get the name of this object
           */
	   ndescf.desc.name = ThisFileName;


           /* get attributes for name conversion (need to know if dir or file) */
           dprintf(("pathmunge", "nfs_lookup >>%s<< (MP=%p)\n", ndescf.desc.name, ndescf.mp));
           err = nfs_lookup( &ndescf.file, &attr, ndescf.mp, &ndescf.dir, &ndescf.desc.name, FALSE );
           if ( err )
           {
	     dprintf(("pathmunge", "find_object_in_directory: getting next entry..."));
             err = GetNextNFSDirEntry(&ThisFileName, NULL);

             if(err)
              return err;

	     dprintf(("pathmunge", "...%s\n", ThisFileName?ThisFileName:"<<NULL>>"));
             continue;
           }
           ndescf.desc.attr = *attr;

           /* convert nfs name to riscos name */
           err = nfsname_to_riscos_name( &enumed_riscos_name, ndescf.desc.name, &ndescf );
           if ( err )
           {
	     dprintf(("pathmunge", "find_object_in_directory: getting next entry..."));
             err = GetNextNFSDirEntry(&ThisFileName, NULL);

             if(err)
              return err;

	     dprintf(("pathmunge", "...%s\n", ThisFileName?ThisFileName:"<<NULL>>"));
             continue;
           }
           /*
                   Is it the right one?
           */


/*********************
CASE TOLERANCE PROVIDED HERE
**********************/
           if ( caseless_wildncmp( riscos_name, enumed_riscos_name, max_riscos_name_length ) != 0 )
           {
                   free( enumed_riscos_name );
		   dprintf(("pathmunge", "find_object_in_directory: getting next entry..."));
                   err = GetNextNFSDirEntry(&ThisFileName, NULL);

                   if(err)
                    return err;

		   dprintf(("pathmunge", "...%s\n", ThisFileName?ThisFileName:"<<NULL>>"));
                   continue;
           }
/**********************
END OF CASE TOLERACE CODE
***********************/
           /*
                   We've found something which is a match
           */


           if ( wildncmp( riscos_name, enumed_riscos_name, max_riscos_name_length ) != 0 )
           {
                   /*
                           This thing we've found isn't an exact match.
                   */
                   if ( found_a_match )
                   {
                           /*
                                   As we've already found an inexact match, we'll use
                                   that earlier one, and not this one we've just found.
                           */
                           free( enumed_riscos_name );
           /* Get next file, don't check for cache freshness */
			  dprintf(("pathmunge", "find_object_in_directory: getting next entry..."));
                          err = GetNextNFSDirEntry(&ThisFileName, NULL);

                          if(err)
                             return err;

			  dprintf(("pathmunge", "...%s\n", ThisFileName?ThisFileName:"<<NULL>>"));
		          continue;

                   }
           }
           else
           {
                   /*
                           This thing we've found is an exact match.
                   */
                   if ( found_a_match )
                   {
                           /*
                                   The previous inexact match must be junked
                           */
                           free( ndesc->desc.name );
                   }

                   found_exact_match = Yes;
           }

/***
DISABLED FOR CASE SENSITIVITY
CP 16/2/95
***/
           found_a_match = Yes;

           /*
                   It IS the right one. No longer need the enumed name'cos is the
                   same as that passed in.
           */
           free( enumed_riscos_name );

           /*
                   Copy the name
           */
           ndesc->desc.name = malloc( strlen( ndescf.desc.name ) + 1 );

           if ( ndesc->desc.name == NULL )
           {
                   return mb_malloc_failed;
           }

           strcpy( ndesc->desc.name, ndescf.desc.name );

           /*
                   Get the gory details 'cos the caller wants them.
           */
           err = nfs_lookup_extended( ndesc, TRUE );

           if ( err )
           {
                   return err;
           }

           /*
                   Finding an exact match means stop here
           */
           if ( found_exact_match )
           {
                   return NULL;
           }

           /* Get next file, don't check for cache freshness */
	   dprintf(("pathmunge", "find_object_in_directory: getting next entry..."));
           err = GetNextNFSDirEntry(&ThisFileName, NULL);

           if(err)
              return err;

	   dprintf(("pathmunge", "...%s\n", ThisFileName?ThisFileName:"<<NULL>>"));
        } /* endwhile (ThisFileName != NULL) */

        if ( found_a_match )
        {
                return NULL;
        }
        else
        {
                /*
                        Didn't find any match, its not in this directory.
                */
                return mb_nfserr_noent;
        }
}


/*********** find_leaf *****************************************************

Purpose : Finds a leaf (file/directory)

Inputs :  path          ptr to full path to object (including mount name?)
          ndesc         ptr, somewhere to put a result
          path_to_leaf  ptr to ptr, somewhere to put a result
          leaf_position ptr to ptr, somewhere to put result

Returns :  NULL if OK, otherwise _kernel_oserror pointer.  Nothing to free if 	      error.
	   ndesc holds NFS details of the directory where the leaf was found
	   path_to_leaf points to directory path to found leaf (calling
	       function must free this)
	   leaf_position points to the name of the found leaf

****************************************************************************/

_kernel_oserror *find_leaf( char *path, nfs_file_descriptor *ndesc,
        char **path_to_leaf, char **leaf_position)
{
        _kernel_oserror *err;
        fattr3 *attr;
        char *path_with_real_leaf;
        char *real_leaf;

        /*
                Find the directory for the leaf, and the leaf name
        */
        err = find_dir_for_leaf( path, ndesc, path_to_leaf, leaf_position );

        if ( err )
        {
                return err;
        }

        /*
                If the leaf is not empty, then try to find it. Empty is valid
                in this context, as it might be a result of nfs::<mountname>
        */
        if ( strcmp( *leaf_position, "" ) != 0 )
        {
                err = find_object_in_directory( ndesc, *leaf_position );

                if ( err )
                {
                        free( *path_to_leaf );

                        return err;
                }

                /*
                        Reconstruct path with expanded leaf name (cancels wildcards).
                */
                err = nfsname_to_riscos_name( &real_leaf, ndesc->desc.name, ndesc );

                if ( err )
                {
                        free( *path_to_leaf );
                        return err;
                }

                path_with_real_leaf = malloc( (*leaf_position - *path_to_leaf) + strlen( real_leaf ) + 1 );

                if ( path_with_real_leaf == NULL )
                {
                        free( real_leaf );
                        free( *path_to_leaf );

                        return mb_malloc_failed;
                }

                /*
                        Construct path from path to leaf and real leaf
                */
                memcpy( path_with_real_leaf, *path_to_leaf, (*leaf_position - *path_to_leaf) );
                *leaf_position += path_with_real_leaf - *path_to_leaf;
                strcpy( *leaf_position, real_leaf );

                dprintf(("pathmunge_1", "find_leaf(%s) -> '%s' '%s' '%s'\n", path, path_with_real_leaf, *leaf_position, ndesc->desc.name));

                /*
                        Discard junk we no longer need
                */
                free( real_leaf );
                free( *path_to_leaf );

                *path_to_leaf = path_with_real_leaf;
        }
        else
        {
                /*
                        We actually mean this directory
                */
                fh3cpy(&ndesc->file, &ndesc->dir);

                ndesc->desc.name = malloc( strlen( "" ) + 1 );
                ndesc->desc.chars_before_suffix = 0;

                if ( ndesc->desc.name == NULL )
                {
                        free( *path_to_leaf );
                        return mb_malloc_failed;
                }

                strcpy( ndesc->desc.name, "" );

                err = nfs_getattr( &attr, ndesc->mp, &ndesc->file );

                if ( err )
                {
                        free( ndesc->desc.name );
                        free( *path_to_leaf );
                }
                else
                {
                        ndesc->desc.attr = *attr;
                }
        }

        return err;
} /* endfunction find_leaf */



/********* find_directory_leaf **********************************************

Purpose : Find a leaf, and make sure it is a directory

Inputs : path          ptr to full path to object (including mount name?)
          ndesc         ptr, somewhere to put a result
          path_to_leaf  ptr to ptr, somewhere to put a result
          leaf_position ptr to ptr, somewhere to put result

Returns : NULL if OK, ptr to err if not (eg it's not a directory, or not
found)).  Nothing malloced if error.
	   ndesc holds NFS details of the directory where the leaf was found
	   path_to_leaf points to directory path to found leaf (calling
	       function must free this)
	   leaf_position points to the name of the found leaf

****************************************************************************/

_kernel_oserror *find_directory_leaf(
        char                    *path,
        nfs_file_descriptor     *ndesc,
        char                    **path_to_leaf,
        char                    **leaf_position
)
{
        _kernel_oserror *err;

        err = find_leaf( path, ndesc, path_to_leaf, leaf_position );

        if ( err )
        {
                return err;
        }

        if ( ndesc->desc.attr.type != NFDIR )
        {
                free( *path_to_leaf );
                free( ndesc->desc.name );
                return mb_nfserr_noent;  /* Must be noent, not notdir, otherwise
                                             IFSs don't work */
        }


        return NULL;
} /* endfunction find_directory_leaf */




/********* find_regular_leaf **********************************************

Purpose : Find a leaf, and make sure it is a file

Inputs : path          ptr to full path to object (including mount name?)
          ndesc         ptr, somewhere to put a result
          path_to_leaf  ptr to ptr, somewhere to put a result
          leaf_position ptr to ptr, somewhere to put result

Returns : NULL if OK, ptr to err if not (eg it's not a directory, or not
found)).  Nothing malloced if error.
	   ndesc holds NFS details of the directory where the leaf was found
	   path_to_leaf points to directory path to found leaf (calling
	       function must free this)
	   leaf_position points to the name of the found leaf

****************************************************************************/

_kernel_oserror *find_regular_leaf(
        char                    *path,
        nfs_file_descriptor     *ndesc,
        char                    **path_to_leaf,
        char                    **leaf_position
)
{
        _kernel_oserror *err;

        err = find_leaf( path, ndesc, path_to_leaf, leaf_position );

        if ( err )
                return err;

        if ( ndesc->desc.attr.type != NFREG )
        {
                free( *path_to_leaf );
                free( ndesc->desc.name );
                return mb_not_a_file;
        }

        return NULL;
} /* endfunction find_regular_leaf */



/********* reject_nfs_file **************************************************

Purpose : Checks a nfs filename validity.  Will reject any alien concepts (eg
	  '.' or '..').

Inputs : nfs_name   ptr to name to process

Returns : 'No' if the filename is valid ("No, don't reject it")
	  'Yes' if the filename cannot be converted to RiscOS (Yes, reject
	  it")

****************************************************************************/

YesNoAnswer reject_nfs_file(
        char *nfs_name
)
{
        if ( strcmp( nfs_name, "." ) != 0 &&
             strcmp( nfs_name, ".." ) != 0 )
        {
                return No;  /* don't reject it */
        }
        else
        {
                return Yes;  /* it's a hassle...reject it */
        }
}  /* endfunction reject_nfs_name */



@


4.8
log
@Export our own SWIs as a header
Use the shared makefiles to export Interface/NFS.h and Hdr:NFS.
Remove local copy NFS.h which confuses the dependency checking, now called nfsheaders.h instead.
Delete unused UID/GID pair.
Tested on a mount from FreeBSD 11.1-RELEASE-p4.

Version 3.23. Tagged as 'NFS-3_23'
@
text
@d578 1
d598 6
a605 2
                        ndesc->desc.load_address = bit_on_end_of_file.lxa.load_address;
                        ndesc->desc.execute_address = bit_on_end_of_file.lxa.execute_address;
@


4.7
log
@Fixed a memory leak that occurred in some circumstances when a non-exact
name was supplied (eg "Fred" when the server has "fred" or "Fred,ffb").

Version 3.21. Tagged as 'NFS-3_21'
@
text
@d56 1
a56 1
#include "NFS.h"
@


4.6
log
@Merged in branch sbrodie_NFS_dev.
Also added -c90 to CFLAGS so that it will build with recent compilers.
Warning: provokes compiler bugs in many recent compilers!

Version 3.19. Tagged as 'NFS-3_19'
@
text
@d643 1
d650 1
a650 1
_kernel_oserror *nfs_lookup_extended( nfs_file_descriptor *ndesc)
d656 1
a656 1
        err = nfs_lookup( &ndesc->file, &nattr, ndesc->mp, &ndesc->dir, &ndesc->desc.name );
d884 1
a884 1
        err = nfs_lookup_extended( ndesc );
d943 1
a943 1
           err = nfs_lookup( &ndescf.file, &attr, ndescf.mp, &ndescf.dir, &ndescf.desc.name );
d1065 1
a1065 1
           err = nfs_lookup_extended( ndesc );
@


4.5
log
@  Fixed potential use of uninitialised pointer.
Detail:
  If the LOOKUP remote procedure chose not to supply the optional
    object attributes in its result, the attribute pointer would
    remain uninitialised and be treated as safe to use.  This can
    no longer occur.
  All but the unused static rcsid variable compile warnings removed.
Admin:
  Requires AsmUtils 0.06 or later.
  Requires Library 0.39 or later (for rpcgen 0.03 or later)
  Built and tested on Risc PC.

Version 3.07. Tagged as 'NFS-3_07'
@
text
@d655 1
a655 1
        err = nfs_lookup( &ndesc->file, &nattr, ndesc->mp, &ndesc->dir, ndesc->desc.name );
d942 1
a942 1
           err = nfs_lookup( &ndescf.file, &attr, ndescf.mp, &ndescf.dir, ndescf.desc.name );
d960 1
a960 1
	     dprintf(("pathmungr", "find_object_in_directory: getting next entry..."));
d1180 2
@


4.5.2.1
log
@  Fixed some cache problems.
Detail:
  Untyped and lxa files now work again.
  Routines which call nfs_lookup now provide a char * into which the Real
    NFS Leafname can be stored.  This avoids problems with type extended
    files not being found, flushed from the cache, and re-sought - even
    when the files were there anyway.  Fixes the problems with not being
    able to write or delete filetype extended files too.  This should
    speed lots of ops up since it is removing the need for another GETATTR3
    call and/or a directory search.
  I've added in some more of the attribute updating to prevent directory
    attributes being thrown out of the cache when the directory changes
    in a predictable manner (e.h. deleting a file in the directory does
    not cause the cache entries for the directory to be scrapped - simply
    updated from the attributes in the REMOVE3 result - provided the dir
    hadn't changed since the last time we read its attributes.  Fixing this
    means you can delete files on an NFS mount much more quickly now.
Notes:
  Softlinks are a complete disaster for the cache still :-(
  I'm sure it should be possible to search the lookup cache for matching
    leafnames instead of doing a directory search every time - if it is and
    is implemented, this should speed things up a lot.
Admin:
  Tested briefly, seems to work at a basic level but still undergoing testing.


Version 3.18, 4.22.2.2. Tagged as 'NFS-3_18-4_22_2_2'
@
text
@d655 1
a655 1
        err = nfs_lookup( &ndesc->file, &nattr, ndesc->mp, &ndesc->dir, &ndesc->desc.name );
d942 1
a942 1
           err = nfs_lookup( &ndescf.file, &attr, ndescf.mp, &ndescf.dir, &ndescf.desc.name );
d960 1
a960 1
	     dprintf(("pathmunge", "find_object_in_directory: getting next entry..."));
a1179 2

                dprintf(("pathmunge_1", "find_leaf(%s) -> '%s' '%s' '%s'\n", path, path_with_real_leaf, *leaf_position, ndesc->desc.name));
@


4.4
log
@  Attribute cacheing preload bug fixed.
  Debugging all switched to DebugLib-style.
Detail:
  The attribute cache preloading was failing to take effect because
    the hash value generation was giving the attribute cache preload
    function different answers to those it gave any other functions.
    This has now been fixed.
  Debugging support replaced completely by DebugLib support.
  The automatically generated RPC veneers do not contain any debugging
    (although it could be added by rpcgen - a beta version of rpcgen
    exists that writes DebugLib veneers into the stubs to note all RPC
    calls made via the stubs.  These functions do not, however, unpack
    the parameters and return structures yet.  That would be a massive
    job, requiring changes to all hand-written XDR functions - rpcgen
    could arrange to generate appropriate stuff for anything it writes,
    though)
  Removed obsolete db.c and db.h files.
  TaskObey script added to build the debugging version of the module.
Admin:
  This module has been tested on desktop machines for several months.
    The massive speedup expected from the use of NFS protocol version 3
    is now being noticed on directory operations,

Version 3.01. Tagged as 'NFS-3_01'
@
text
@d925 1
a925 1
        dprintf(("pathmunge", "First file name is %s\n", ThisFileName));
d951 1
a951 1
	     dprintf(("pathmunge", "...%s\n", ThisFileName));
d966 1
a966 1
	     dprintf(("pathmunge", "...%s\n", ThisFileName));
d986 1
a986 1
		   dprintf(("pathmunge", "...%s\n", ThisFileName));
d1016 1
a1016 1
			  dprintf(("pathmunge", "...%s\n", ThisFileName));
d1086 1
a1086 1
	   dprintf(("pathmunge", "...%s\n", ThisFileName));
@


4.3
log
@  Now supports NFS version 3.
Detail:
  All client-server calls now use the superior NFS3 protocol.
  This particularly benefits directory enumeration and *NFSInfo
    is now reporting 80%+ cache hit rates which is a significant
    improvement (over 5% better - some hosts report 85%+)
  Hashing algorithms improved to increase cache hits (the cache
    algorithm doesn't use parts of names after a comma, so that
    the hash value for !Run is the same as the hash value for
    !Run,feb - which helps the cache hit rate a lot).   Directory
    browsing on the desktop appears noticably faster too.
  The module now has the original protocol (.x) files defining
    the RPC protocols being used (NFS, mount, pcnfs, rquota)
    and uses them to generate header files, XDR implementations,
    and client stubs automatically, instead of having hand
    written versions.
  NFS workspace comes from a dynamic area where possible.
Admin:
  Supporting documentation:
    Acorn NFS Software Functional Specification (1215,250/FS)
    RFC1014, RFC1057, RFC1094, RFC1813
  Tested in several desktop machines for everyday use against
    both NFS2 and NFS3 servers.
  Requires rpcgen 0.01 or later
    (CVS source: Tools/Sources/rpcgen  tag: rpcgen-0_01 or later)
    (CVS binary: RiscOS/Library  tag: Library-0_19 or later)
  Requires TCPIPLibs 5.13 or later
    (CVS: RiscOS/Sources/Lib/TCPIPLibs  tag: TCPIPLibs-5_13)

Version 3.00. Tagged as 'NFS-3_00'
@
text
@d113 2
d654 1
d919 1
a919 3
#if DEBUGON
printf("find_object_in_directory: opening directory....");
#endif
d925 1
a925 3
#if DEBUGON
printf("First file name is %s\n", ThisFileName);
#endif
d941 1
d945 1
a945 3
#if DEBUGON
printf("find_object_in_directory: getting next entry...");
#endif
d951 1
a951 3
#if DEBUGON
printf("%s\n", ThisFileName);
#endif
d960 1
a960 3
#if DEBUGON
printf("find_object_in_directory: getting next entry...");
#endif
d966 1
a966 3
#if DEBUGON
printf("%s\n", ThisFileName);
#endif
d980 1
a980 3
#if DEBUGON
printf("find_object_in_directory: getting next entry...");
#endif
d986 1
a986 3
#if DEBUGON
printf("%s\n", ThisFileName);
#endif
d1010 1
a1010 3
#if DEBUGON
printf("find_object_in_directory: getting next entry...");
#endif
d1016 1
a1016 3
#if DEBUGON
printf("%s\n", ThisFileName);
#endif
d1080 1
a1080 3
#if DEBUGON
printf("find_object_in_directory: getting next entry...");
#endif
d1086 1
a1086 3
#if DEBUGON
printf("%s\n", ThisFileName);
#endif
@


4.2
log
@Added '$' -> '<' filename translation
@
text
@d48 2
a49 1
21/2/95  CP    Added more detailed comments about each function to make code 	       more maintainable in the future.
a63 1

d198 1
a198 1
        ndesc->dir = ndesc->mp->fhandle;
d214 1
a214 1
                                ndesc->dir = ndesc->file;
d396 1
a396 1
                        sprintf( hex_appendment, "%c%03x", FileChar_TypedNamePrefix, (attr->load_address >> FileType_Shift) & FileType_Mask );
d422 2
a423 2
        int filetype;
        fattr *attr;
d431 1
a431 1
        static const char lookup_table[256]="________________________________"
d440 2
d454 1
a454 1
                filetype = -1;
d456 1
a456 1
        if ( filetype < 0 )
d548 1
a548 1
        int filetype;
d550 1
a550 1
        if ( (ndesc->desc.attr.mode & NFSMODE_FMT) != NFSMODE_REG )
d561 1
a561 1
        if ( filetype >= 0 )
d589 1
a589 1
                                ndesc->desc.attr.size - sizeof( appendum ),
d650 1
a650 1
        fattr *nattr;
d913 1
a913 1
        ndescf.dir = ndesc->dir;
d919 1
a919 1
        err = GetNFSDirEntry(ndesc->mp, ndesc->dir, 0, &ThisFileName, NULL);
d933 1
a933 1
           fattr *attr;
d1144 1
a1144 1
        fattr *attr;
d1214 1
a1214 1
                ndesc->file = ndesc->dir;
@


4.1
log
@Initial revision
@
text
@d239 1
a239 1
	  anything fancy - just changes '/' to '.'
d267 4
d316 4
d432 1
a432 1
                                            " !\"____'()_+,-//0123456789_;<=>?"
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@

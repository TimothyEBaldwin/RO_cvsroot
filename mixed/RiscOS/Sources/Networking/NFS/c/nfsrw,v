head	4.7;
access;
symbols
	NFS-3_27:4.7
	NFS-3_26:4.7
	NFS-3_25:4.7
	NFS-3_24:4.7
	NFS-3_23:4.7
	NFS-3_22:4.6
	NFS-3_21:4.6
	NFS-3_20:4.6
	NFS-3_19:4.6
	sbrodie_NFS_dev_merge:4.6
	NFS-3_18-4_22_2_4:4.6
	NFS-3_18-4_22_2_3:4.6
	NFS-3_18-4_22_2_2:4.6
	NFS-3_18-4_22_2_1:4.6
	sbrodie_NFS_dev:4.6.0.2
	sbrodie_NFS_dev_bp:4.6
	NFS-3_18:4.6
	NFS-3_17:4.6
	NFS-3_16:4.6
	NFS-3_15:4.6
	NFS-3_14:4.6
	NFS-3_13:4.6
	NFS-3_12:4.6
	NFS-3_11:4.5
	NFS-3_10:4.5
	NFS-3_09:4.5
	NFS-3_08:4.5
	NFS-3_07:4.5
	NFS-3_06:4.4
	NFS-3_05:4.4
	NFS-3_04:4.4
	NFS-3_02:4.4
	NFS-3_01:4.4
	NFS-3_00:4.3
	NFS-2_37:4.2
	NFS-2_36:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.10
	NFS-2_35:4.2
	Spin_merge:4.1.7.2
	Spinner_23Sep1998_destend:4.2
	Spinner_23Sep1998_srcend:4.1.7.2
	Spinner_23Sep1998_srcbegin:4.1.7.1
	Spinner_23Sep1998_destbegin:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.8
	Ursula_13May1998_bp:4.1
	Ursula_13May1998:4.1.0.4
	rthornb_UrsulaBuild_01May1998:4.1
	pwombwel_2_32:4.1
	Spinner_RCA116:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spinner_B10:4.1.7.2
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.2
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	MergeFiles:4.1.7.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1;
locks; strict;
comment	@# @;


4.7
date	2018.01.29.21.30.19;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	7TGUL0NEVVbjHOoA;

4.6
date	2000.06.26.11.54.39;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2000.03.15.14.16.12;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	99.10.13.09.54.00;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	99.05.14.12.42.21;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	98.10.22.18.03.51;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.22.14.49.29;	author nturton;	state Exp;
branches
	4.1.5.1
	4.1.7.1;
next	;

4.1.5.1
date	96.11.22.14.49.29;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.06.42;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.06.11.38.33;	author jfarrell;	state Exp;
branches;
next	;


desc
@@


4.7
log
@Export our own SWIs as a header
Use the shared makefiles to export Interface/NFS.h and Hdr:NFS.
Remove local copy NFS.h which confuses the dependency checking, now called nfsheaders.h instead.
Delete unused UID/GID pair.
Tested on a mount from FreeBSD 11.1-RELEASE-p4.

Version 3.23. Tagged as 'NFS-3_23'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*      NFSRW.C

Purpose : Pulls across many packets of data as fast as possible

Functions : start_transfer
            schedule
            transfermany
            setup_readargs
            endread
            nfsrw_readmany
            setup_writeargs
            nfsrw_writemany

History :
Date       Who      Comments
-----------------------------------------------------------------------------
09/09/92  J Sutton  Initial version
24/2/95   CP        Added header and some more comments
                    Added check in schedule() to see if NFS data being
                    returned is valid (an attempt to cure the 'Oops, remote
                    file been deleted/moved/renamed' bug/feature/quality
                    improvement opportunity)
04-Mar-97 jmf       Fix bug of dropped packets during large file saves
                    leaving holes in file and no error reported.  Caused
                    by inspecting NFS return codes that have not been set
                    when an RPC fails due to a communications error.
****************************************************************************/

#include "nfsheaders.h"

#include "nfsrw.h"

/* static struct timeval TIMEOUT = { 25, 0 };  */
#include "TimeOut.h"

/* try to keep the network busy by juggling many simultaneous transfers */

#define MAXCOROUTINES 2
         /* Determined by the size of memory on the ethernet card
          * 32K is the minimum on a card, ususally 64K.
          * Max packet size is 8K +IP header overhead, so 3 packets
          * shouldn't overflow 32K on a card. */

typedef struct {  /* state per udp packet transfer in progress */
  enum clnt_stat status;        /* coroutine status */

  clntudp_codatap udpdata;      /* pointer to clntudp coroutine hidden data */

  unused_client *nfs_client;    /* coroutine client */

  union {                       /* arguments to rpc (read or write) */
        READ3args rargs;
        WRITE3args wargs;
        readargs r2args;
        writeargs w2args;
      } coargs;

  union {                       /* results from rpc (read or write) */
        READ3res rres;
        WRITE3res wres;
        readres r2res;
        attrstat w2res;
      } cores;

  } nfsrwstate;

/* a function to setup the arguments for the transfer */
typedef void (*argsfn)(nfsrwstate *rwstate, RO_nfs_fh3 *fhandle, int *offset, int *nbytes, char **data);

static _kernel_oserror *start_transfer( nfsrwstate      rwstate[],
                                        MountPoint      *mount_point,
                                            u_long      proc,          /* procedure number */
                                        RO_nfs_fh3      *fhandle,
                                               int      *offset,
                                               int      *nbytes,
                                              char      **data,
                                               int      *ntransfers,
                                            argsfn      setup_args,
                                         xdrproc_t      xargs,         /* xdr routine for args */
                                         xdrproc_t      xresults)      /* xdr routine for results */
{ /* start one udp packet transfer */
        int co;
        _kernel_oserror *err;

        for (co = 0; co < MAXCOROUTINES; co++) /* find a 'slot' for the coroutine */
        {
                if ( rwstate[co].status != RPC_BUSY ) /* indicates an 'idle slot' */
                {
                        if (rwstate[co].nfs_client == NULL)  /* get a new client if one is needed */
                        {
                                err = get_nfs_client_for_mp( &rwstate[co].nfs_client, mount_point );
                                if (err) {
                                  dprintf(("nfsrw_1", "UNABLE TO GET A CLIENT! %s\n", err->errmess));
                                }
                                if (err != NULL)
                                        return err;
                        }

                        /* setup the arguments for this udp transfer */
                        setup_args(&rwstate[co], fhandle, offset, nbytes, data);

                        rwstate[co].status = clntudp_starttransfer(rwstate[co].nfs_client->client,
                                                                   proc,
                                                                   xargs,               /* xdr routine for arguments */
                                                          (caddr_t)&rwstate[co].coargs, /* pointer to args */
                                                                   xresults,            /* xdr routine for results */
                                                          (caddr_t)&rwstate[co].cores,  /* pointer to results */
                                                                   TIMEOUT,
                                                                   &rwstate[co].udpdata);
                        if ( rwstate[co].status == RPC_BUSY ) /* normal successful return */
                        {
                                if (co+1 > *ntransfers)
                                        *ntransfers = co+1; /* increment number of transfers in progress */
                                return NULL;
                        }
                        else
                        {
                                /*  Was passing &rwstate[co].cores as first argument - wrong because the NFS result
                                    is not set if the RPC fails.  */
                                err = rpcnfs_to_riscos_err( NULL, mount_point, rwstate[co].nfs_client->client );
                                dprintf(("nfsrw_1", "clntudp_starttransfer failed: %s\n", err->errmess));
                                return err;
                        }
                }
        }
        return NULL;
} /* endfunction start_transfer */



typedef void (*fn)(nfsrwstate *rwstate, void *arg);

/*
        schedule() calls clntudp_polltransfer on busy coroutines until they finish

        returns true in [*idle_slot] if any idle slots
        returns true in [*busy_slot] if any busy slots
 */
static _kernel_oserror *schedule( nfsrwstate    rwstate[],
                                  MountPoint    *mount_point,
                                         int    ntransfers,     /* number of transfers currently in progress */
                                      bool_t    *idle_slot,
                                      bool_t    *busy_slot,
                                          fn    endfn,          /* function to call on completion of transfer */
                                        void    *arg)           /* argument to pass to endfn */
{
        int co;
        _kernel_oserror *err;
        *idle_slot = (ntransfers < MAXCOROUTINES);
        *busy_slot = FALSE;

        for (co = 0; co < ntransfers; co++)
        {
                if (rwstate[co].status == RPC_BUSY)
                {
                        rwstate[co].status = clntudp_polltransfer(rwstate[co].udpdata);

                        if (rwstate[co].status == RPC_BUSY)
                                *busy_slot = TRUE;

                        else if (rwstate[co].status == RPC_SUCCESS) /* transfer finished */
                        {
/************** check added CP 24/2/95 **************************
  No check was being made on whether the NFS return was valid !
  (RPC return was being checked already)
 ****************************************************************/
                           if(rwstate[co].cores.rres.status != NFS3_OK)
                           {
                             *idle_slot = TRUE;
                             dprintf(("nfsrw_1", "Multi-RW failure: %d (%p)\n", rwstate[co].cores.rres.status, &rwstate[co]));
                             err = rpcnfs_to_riscos_err(&rwstate[co].cores.rres, mount_point, rwstate[co].nfs_client->client);
                             return err;
                           }

                           else
                           {
                                endfn(&rwstate[co], arg); /* call endfn when finished transfer */
                                *idle_slot = TRUE;
                           } /* endif(rwstate[co].cores.rres.status != NFS3_OK) */
                        }
                        else
                        {
                                *idle_slot = TRUE;
                                /*  Was passing &rwstate[co].cores as first argument - wrong because the NFS result
                                    is not set if the RPC fails.  */
                                err = rpcnfs_to_riscos_err( NULL, mount_point, rwstate[co].nfs_client->client );
                                dprintf(("nfsrw_1", "clntudp_polltransfer returned error: %s\n", err->errmess));
                                return err;
                        }
                }
                else
                        *idle_slot = TRUE;
        }
        return NULL;
}  /* endfunction schedule */



/*
        transfermany() transfers data to or from a file, attempting to fill available
        network bandwidth by starting a number of simultaneous packets for files larger
        than the packet size.

        On entry:
        [mount_point]
        [nfsproc]   procedure number NFSPROC3_READ or NFSPROC3_WRITE
        [fhandle]   the file handle
        [offset]    offset in file to start transfer
        [nbytes]    number of bytes to transfer to or from file
        [data]      pointer to data to transfer to file, or area to write data from file
        [setup_args] function to setup arguments for transfer
        [endfn]     a function to be called when a packet transfer is successfully completed
        [arg]       argument to pass to endfn
        [xargs]     xdr routine for arguments
        [xresults]  xdr routine for results

        On exit:
                return value is NULL if successful
*/
static _kernel_oserror *transfermany( MountPoint        *mount_point,
                                          u_long        proc,
                                      RO_nfs_fh3        *fhandle,
                                             int        offset,
                                             int        nbytes,
                                             char       *data,
                                          argsfn        setup_args,
                                              fn        endfn,
                                            void        *arg,
                                       xdrproc_t        xargs,
                                       xdrproc_t        xresults)
{
        nfsrwstate rwstate[MAXCOROUTINES];
        int co, ntransfers = 0;
        bool_t idle_slot = TRUE, busy_slot = FALSE;
        _kernel_oserror *err = NULL;
        int percentage_total = nbytes;
        clock_t last_start = (clock_t) 0;

        /* initialise empty client pointers and status */
        for (co = 0; co < MAXCOROUTINES; co++)
                {
                rwstate[co].nfs_client = NULL;
                rwstate[co].status = RPC_SUCCESS;
                }

        while (nbytes > 0)
        {
                clock_t time_now = clock();

                if (idle_slot && time_now != last_start)
                {
                        last_start = time_now;
                        err = start_transfer(rwstate, mount_point, proc, fhandle, &offset, &nbytes, &data, &ntransfers, setup_args, xargs, xresults);
                        if (err != NULL) {
                                /*  was (&& ntransfers == 0) but that leaves failed transfers in
                                    the middle of a file unreported.  */
                                goto abort;
                        }
                }

                err = schedule(rwstate, mount_point, ntransfers, &idle_slot, &busy_slot, endfn, arg);
                if (err != NULL)
                        goto abort;

               /* Advance the percentage on the hourglass */
                hourglass_percentage( (( percentage_total - nbytes ) * 100 ) / ( percentage_total + 1 ) );
        }

        /* finish all pending transfers */
        while (busy_slot)
        {
                err = schedule(rwstate, mount_point, ntransfers, &idle_slot, &busy_slot, endfn, arg);
                if (err != NULL)
                        goto abort;
        }

abort:
        /* release clients */
        for (co = 0; co < MAXCOROUTINES; co++)
                if ( rwstate[co].nfs_client != NULL )
                {
                        release_client( rwstate[co].nfs_client );
                        rwstate[co].nfs_client = NULL;
                }

        return err;
}


/*
        function to setup the arguments for reading
        passed to transfermany() and called by start_transfer()
*/
static void setup_readargs(nfsrwstate *rwstate, RO_nfs_fh3 *fhandle, int *offset, int *nbytes, char **data)
{
        if (rwstate->nfs_client->version == NFS_V3) {
                rwstate->coargs.rargs.file = fhandle->fh3;
                ui64_create(&rwstate->coargs.rargs.offset, *offset);
                rwstate->coargs.rargs.count = (*nbytes > NFS_MAXDATA) ? NFS_MAXDATA : *nbytes;
                *nbytes -= (int) rwstate->coargs.rargs.count;
                *offset += (int) rwstate->coargs.rargs.count;
                rwstate->cores.rres.READ3res_u.resok.data.data_val = *data;
                *data += rwstate->coargs.rargs.count;
        }
        else {
                fh2cpy_from_fh3(&rwstate->coargs.r2args.file, &fhandle->fh3);
                rwstate->coargs.r2args.offset = *offset;
                rwstate->coargs.r2args.count = (*nbytes > NFS_MAXDATA) ? NFS_MAXDATA : *nbytes;
                *nbytes -= rwstate->coargs.r2args.count;
                *offset += rwstate->coargs.r2args.count;
                rwstate->cores.r2res.readres_u.reply.data.data_val = *data;
                *data += rwstate->coargs.r2args.count;
        }
}  /* endfunction transfermany */

typedef struct {
  int *readres_len;
  fattr3 *nattr;
  } endreadargstr;

/*
        function to call when a read request has been sent, and the data has
        returned with no error
*/
static void endread(nfsrwstate *rwstate, void *arg)
{
        endreadargstr *args = arg;

        if (rwstate->nfs_client->version == NFS_V3) {
                *args->readres_len += rwstate->cores.rres.READ3res_u.resok.data.data_len;
                /* This really only needs to be set once, rather than on EVERY endread. */
                if (rwstate->cores.rres.READ3res_u.resok.file_attributes.attributes_follow)
                        *args->nattr = rwstate->cores.rres.READ3res_u.resok.file_attributes.post_op_attr_u.attributes;
                /* get attributes for caller cache update */
        }
        else {
                upcast_fattr(args->nattr, &rwstate->cores.r2res.readres_u.reply.attributes);
                *args->readres_len += rwstate->cores.r2res.readres_u.reply.data.data_len;
        }
}

_kernel_oserror *nfsrw_readmany
(
        int *readres_len,
        char *readres_data,
        MountPoint *mount_point,
        RO_nfs_fh3 *fhandle,
        unsigned long offset,
        int nbytes,
        fattr3 *nattr
)
{
        _kernel_oserror *err = NULL;
        endreadargstr endreadargs;

        dprintf(("nfsrw_1", "nfsrw_readmany starts ... read %d bytes at %ld\n", nbytes, offset));

        *readres_len = 0;  /* CHECK that this is acceptable (0 if error) */

        endreadargs.readres_len = readres_len;
        endreadargs.nattr = nattr;

        if (mount_point->host->nfs_version == NFS_V3) {
                err = transfermany(mount_point, NFSPROC3_READ,
                                   fhandle, (int)offset, nbytes, readres_data,
                                   setup_readargs, endread, &endreadargs,
                                   xdr_READ3args, xdr_READ3res);
        }
        else {
                err = transfermany(mount_point, NFSPROC_READ,
                                   fhandle, (int)offset, nbytes, readres_data,
                                   setup_readargs, endread, &endreadargs,
                                   xdr_readargs, xdr_readres);
        }

        dprintf(("nfsrw_1", "nfsrw_readmany completes (%serror)\n", err?"":"no "));

        if (err != NULL)
                return err;

        return NULL;
}


/*
        function to setup the arguments for writing
        passed to transfermany() and called by start_transfer()
*/
static void setup_writeargs(nfsrwstate *rwstate, RO_nfs_fh3 *fhandle, int *offset, int *nbytes, char **data)
{
        dprintf(("nfsrw_2", "setup_writeargs(1): at %8d, write %8d, from %p  (in) (%p)\n", *offset, *nbytes, *data, rwstate));
        if (rwstate->nfs_client->version == NFS_V3) {
                rwstate->coargs.wargs.file = fhandle->fh3;
                ui64_create(&rwstate->coargs.wargs.offset, *offset);
                rwstate->coargs.wargs.data.data_len = (*nbytes > NFS_MAXDATA) ? NFS_MAXDATA : *nbytes;
                rwstate->coargs.wargs.count = rwstate->coargs.wargs.data.data_len;
                *nbytes -= rwstate->coargs.wargs.data.data_len;
                *offset += rwstate->coargs.wargs.data.data_len;
                rwstate->coargs.wargs.data.data_val = *data;
                *data += rwstate->coargs.wargs.data.data_len;
                dprintf(("nfsrw_2", "setup_writeargs(2): at %8ld, write %8d, from %p  (structure)\n",
                        ui64_value(&rwstate->coargs.wargs.offset),
                        rwstate->coargs.wargs.data.data_len,
                        rwstate->coargs.wargs.data.data_val));
                dprintf(("nfsrw_2", "setup_writeargs(3): at %8d, write %8d, from %p  (remaining)\n", *offset, *nbytes, *data));
        }
        else {
                fh2cpy_from_fh3(&rwstate->coargs.w2args.file, &fhandle->fh3);
                rwstate->coargs.w2args.offset = *offset;
                rwstate->coargs.w2args.data.data_len = (*nbytes > NFS_MAXDATA) ? NFS_MAXDATA : *nbytes;
                *nbytes -= rwstate->coargs.w2args.data.data_len;
                *offset += rwstate->coargs.w2args.data.data_len;
                rwstate->coargs.w2args.data.data_val = *data;
                *data += rwstate->coargs.w2args.data.data_len;
        }
}

/*
        function to call when a write packet has been sent, and the acknowledgement
        is received with no error.
*/
static void endwrite(nfsrwstate *rwstate, void *arg)
{
        fattr3 **nattr = arg;
        if (rwstate->nfs_client->version == NFS_V3) {
                if (rwstate->cores.wres.WRITE3res_u.resok.file_wcc.after.attributes_follow)
                        *nattr = &rwstate->cores.wres.WRITE3res_u.resok.file_wcc.after.post_op_attr_u.attributes;
        }
        else {
                /* Note: wres and w2res are in a union with each other - so potentially unsafe to upgrade it in situ */
                fattr fcopy = rwstate->cores.w2res.attrstat_u.attributes;
                *nattr = &rwstate->cores.wres.WRITE3res_u.resok.file_wcc.after.post_op_attr_u.attributes;
                upcast_fattr(&rwstate->cores.wres.WRITE3res_u.resok.file_wcc.after.post_op_attr_u.attributes, &fcopy);
                dprintf(("nfsrw_2", "NFS2 writemany component succeeded\n"));
        }
        /* N.B. this should not be necessary after every packet transferred */
}

_kernel_oserror *nfsrw_writemany(
        fattr3 **nattr,
        MountPoint *mount_point,
        RO_nfs_fh3 *fhandle,
        unsigned long offset,
        char *data,
        int nbytes
)
{
        _kernel_oserror *err = NULL;

        dprintf(("nfsrw_1", "nfsrw_writemany starts ... write %d bytes at %ld\n", nbytes, offset));

        if (mount_point->host->nfs_version == NFS_V3) {
                err = transfermany(mount_point, NFSPROC3_WRITE,
                                   fhandle, (int)offset, nbytes, data,
                                   setup_writeargs, endwrite, nattr,
                                   xdr_WRITE3args, xdr_WRITE3res);
        }
        else {
#ifdef DEBUGLIB
                {
                  static char fhandlehex[1+2*(NFS_FHSIZE)];
                  int i;
                  for (i=0; i<NFS_FHSIZE; ++i) {
                    sprintf(fhandlehex + i*2, "%02x", fhandle->opaque[i]);
                  }
                  dprintf(("nfsrw_1", "(B) P_OK=%d (an NFS2 write: fhandle = %s) (%p, %p)\n",
                    fhandle->opaque == fhandle->fh3.data.data_val, fhandlehex, fhandle->opaque, fhandle->fh3.data.data_val));
                }
#endif
                err = transfermany(mount_point, NFSPROC_WRITE,
                                   fhandle, (int)offset, nbytes, data,
                                   setup_writeargs, endwrite, nattr,
                                   xdr_writeargs, xdr_attrstat);
        }

        dprintf(("nfsrw_1", "nfsrw_writemany completes (%serror)\n", err?"":"no "));

        return err;
} /* endfunction nfsrw_writemany */
@


4.6
log
@  Pre-allocated 2 NFS clients to avoid critical memory failures.
  Added SILENTBOOT build option.
Detail:
  Pass OPTIONS=-DSILENTBOOT from the build system to compile out the
    echoing of the various state messages during a boot operation.
  Pre-allocate two NFS clients and then free them immediately (so they
    are cached) when a new mount is made.  This means that the client
    memory will be available for use during a command-line *Copy op
    where pre-Ursula OSes will claim all free memory for buffers.
    A better solution is to use Ursula on the build machines rather
    than spending time fixing problems caused by ancient versions of
    FileSwitch that have been fixed for years.
Admin:
  Fixes bug #1482
  Fixes *Copy on the build machines on pre-Ursula OSes.

Version 3.12. Tagged as 'NFS-3_12'
@
text
@d43 1
a43 1
#include "NFS.h"
@


4.5
log
@  Fixed potential use of uninitialised pointer.
Detail:
  If the LOOKUP remote procedure chose not to supply the optional
    object attributes in its result, the attribute pointer would
    remain uninitialised and be treated as safe to use.  This can
    no longer occur.
  All but the unused static rcsid variable compile warnings removed.
Admin:
  Requires AsmUtils 0.06 or later.
  Requires Library 0.39 or later (for rpcgen 0.03 or later)
  Built and tested on Risc PC.

Version 3.07. Tagged as 'NFS-3_07'
@
text
@d15 1
a15 1
/*	NFSRW.C
d20 7
a26 7
	    schedule
	    transfermany
	    setup_readargs
	    endread
	    nfsrw_readmany
	    setup_writeargs
	    nfsrw_writemany
d29 1
a29 1
Date	   Who      Comments
d32 9
a40 9
24/2/95   CP	    Added header and some more comments
	  	    Added check in schedule() to see if NFS data being
		    returned is valid (an attempt to cure the 'Oops, remote
		    file been deleted/moved/renamed' bug/feature/quality
		    improvement opportunity)
04-Mar-97 jmf	    Fix bug of dropped packets during large file saves
		    leaving holes in file and no error reported.  Caused
		    by inspecting NFS return codes that have not been set
		    when an RPC fails due to a communications error.
d106 3
d132 2
a133 2
                          	/*  Was passing &rwstate[co].cores as first argument - wrong because the NFS result
                          	    is not set if the RPC fails.  */
d135 1
d181 7
a187 7
   	       	  	   if(rwstate[co].cores.rres.status != NFS3_OK)
   	       	  	   {
   	       	  	     *idle_slot = TRUE;
   	       	  	     dprintf(("nfsrw_1", "Multi-RW failure: %d (%p)\n", rwstate[co].cores.rres.status, &rwstate[co]));
   	       	  	     err = rpcnfs_to_riscos_err(&rwstate[co].cores.rres, mount_point, rwstate[co].nfs_client->client);
   	       	  	     return err;
    	       	  	   }
d189 2
a190 2
			   else
			   {
d198 2
a199 2
                          	/*  Was passing &rwstate[co].cores as first argument - wrong because the NFS result
                          	    is not set if the RPC fails.  */
d201 1
d238 2
a239 2
                                             int     	nbytes,
                                             char    	*data,
d242 1
a242 1
                                            void    	*arg,
d269 2
a270 2
                        	/*  was (&& ntransfers == 0) but that leaves failed transfers in
                        	    the middle of a file unreported.  */
d311 7
a317 7
	        rwstate->coargs.rargs.file = fhandle->fh3;
        	ui64_create(&rwstate->coargs.rargs.offset, *offset);
	        rwstate->coargs.rargs.count = (*nbytes > NFS_MAXDATA) ? NFS_MAXDATA : *nbytes;
        	*nbytes -= (int) rwstate->coargs.rargs.count;
	        *offset += (int) rwstate->coargs.rargs.count;
        	rwstate->cores.rres.READ3res_u.resok.data.data_val = *data;
	        *data += rwstate->coargs.rargs.count;
d320 7
a326 7
	        fh2cpy_from_fh3(&rwstate->coargs.r2args.file, &fhandle->fh3);
        	rwstate->coargs.r2args.offset = *offset;
	        rwstate->coargs.r2args.count = (*nbytes > NFS_MAXDATA) ? NFS_MAXDATA : *nbytes;
        	*nbytes -= rwstate->coargs.r2args.count;
	        *offset += rwstate->coargs.r2args.count;
        	rwstate->cores.r2res.readres_u.reply.data.data_val = *data;
	        *data += rwstate->coargs.r2args.count;
d344 5
a348 5
	        *args->readres_len += rwstate->cores.rres.READ3res_u.resok.data.data_len;
	        /* This really only needs to be set once, rather than on EVERY endread. */
	        if (rwstate->cores.rres.READ3res_u.resok.file_attributes.attributes_follow)
        	        *args->nattr = rwstate->cores.rres.READ3res_u.resok.file_attributes.post_op_attr_u.attributes;
	        /* get attributes for caller cache update */
d370 1
a370 1
	dprintf(("nfsrw_1", "nfsrw_readmany starts ... read %d bytes at %ld\n", nbytes, offset));
d377 12
a388 12
	if (mount_point->host->nfs_version == NFS_V3) {
	        err = transfermany(mount_point, NFSPROC3_READ,
        	                   fhandle, (int)offset, nbytes, readres_data,
                	           setup_readargs, endread, &endreadargs,
                        	   xdr_READ3args, xdr_READ3res);
	}
	else {
	        err = transfermany(mount_point, NFSPROC_READ,
        	                   fhandle, (int)offset, nbytes, readres_data,
                	           setup_readargs, endread, &endreadargs,
                        	   xdr_readargs, xdr_readres);
	}
d390 1
a390 1
	dprintf(("nfsrw_1", "nfsrw_readmany completes (%serror)\n", err?"":"no "));
d405 1
d407 8
a414 9
                dprintf(("nfsrw_2", "setup_writeargs(1): at %8d, write %8d, from %p  (in) (%p)\n", *offset, *nbytes, *data, rwstate));
	        rwstate->coargs.wargs.file = fhandle->fh3;
        	ui64_create(&rwstate->coargs.wargs.offset, *offset);
	        rwstate->coargs.wargs.data.data_len = (*nbytes > NFS_MAXDATA) ? NFS_MAXDATA : *nbytes;
	        rwstate->coargs.wargs.count = rwstate->coargs.wargs.data.data_len;
        	*nbytes -= rwstate->coargs.wargs.data.data_len;
	        *offset += rwstate->coargs.wargs.data.data_len;
        	rwstate->coargs.wargs.data.data_val = *data;
	        *data += rwstate->coargs.wargs.data.data_len;
d416 3
a418 3
                	ui64_value(&rwstate->coargs.wargs.offset),
                	rwstate->coargs.wargs.data.data_len,
                	rwstate->coargs.wargs.data.data_val));
d422 7
a428 7
	        fh2cpy_from_fh3(&rwstate->coargs.w2args.file, &fhandle->fh3);
	        rwstate->coargs.w2args.offset = *offset;
        	rwstate->coargs.w2args.data.data_len = (*nbytes > NFS_MAXDATA) ? NFS_MAXDATA : *nbytes;
	        *nbytes -= rwstate->coargs.w2args.data.data_len;
        	*offset += rwstate->coargs.w2args.data.data_len;
	        rwstate->coargs.w2args.data.data_val = *data;
        	*data += rwstate->coargs.w2args.data.data_len;
d440 2
a441 2
        	if (rwstate->cores.wres.WRITE3res_u.resok.file_wcc.after.attributes_follow)
                	*nattr = &rwstate->cores.wres.WRITE3res_u.resok.file_wcc.after.post_op_attr_u.attributes;
d448 1
d464 1
a464 1
	dprintf(("nfsrw_1", "nfsrw_writemany starts ... write %d bytes at %ld\n", nbytes, offset));
d466 23
a488 12
	if (mount_point->host->nfs_version == NFS_V3) {
	        err = transfermany(mount_point, NFSPROC3_WRITE,
        	                   fhandle, (int)offset, nbytes, data,
                	           setup_writeargs, endwrite, nattr,
                        	   xdr_WRITE3args, xdr_WRITE3res);
	}
	else {
	        err = transfermany(mount_point, NFSPROC_WRITE,
        	                   fhandle, (int)offset, nbytes, data,
                	           setup_writeargs, endwrite, nattr,
                        	   xdr_writeargs, xdr_attrstat);
	}
d490 1
a490 1
	dprintf(("nfsrw_1", "nfsrw_writemany completes (%serror)\n", err?"":"no "));
@


4.4
log
@  Attribute cacheing preload bug fixed.
  Debugging all switched to DebugLib-style.
Detail:
  The attribute cache preloading was failing to take effect because
    the hash value generation was giving the attribute cache preload
    function different answers to those it gave any other functions.
    This has now been fixed.
  Debugging support replaced completely by DebugLib support.
  The automatically generated RPC veneers do not contain any debugging
    (although it could be added by rpcgen - a beta version of rpcgen
    exists that writes DebugLib veneers into the stubs to note all RPC
    calls made via the stubs.  These functions do not, however, unpack
    the parameters and return structures yet.  That would be a massive
    job, requiring changes to all hand-written XDR functions - rpcgen
    could arrange to generate appropriate stuff for anything it writes,
    though)
  Removed obsolete db.c and db.h files.
  TaskObey script added to build the debugging version of the module.
Admin:
  This module has been tested on desktop machines for several months.
    The massive speedup expected from the use of NFS protocol version 3
    is now being noticed on directory operations,

Version 3.01. Tagged as 'NFS-3_01'
@
text
@d410 1
a410 1
                dprintf(("nfsrw_2", "setup_writeargs(2): at %8d, write %8d, from %p  (structure)\n",
@


4.3
log
@  Now supports NFS version 3.
Detail:
  All client-server calls now use the superior NFS3 protocol.
  This particularly benefits directory enumeration and *NFSInfo
    is now reporting 80%+ cache hit rates which is a significant
    improvement (over 5% better - some hosts report 85%+)
  Hashing algorithms improved to increase cache hits (the cache
    algorithm doesn't use parts of names after a comma, so that
    the hash value for !Run is the same as the hash value for
    !Run,feb - which helps the cache hit rate a lot).   Directory
    browsing on the desktop appears noticably faster too.
  The module now has the original protocol (.x) files defining
    the RPC protocols being used (NFS, mount, pcnfs, rquota)
    and uses them to generate header files, XDR implementations,
    and client stubs automatically, instead of having hand
    written versions.
  NFS workspace comes from a dynamic area where possible.
Admin:
  Supporting documentation:
    Acorn NFS Software Functional Specification (1215,250/FS)
    RFC1014, RFC1057, RFC1094, RFC1813
  Tested in several desktop machines for everyday use against
    both NFS2 and NFS3 servers.
  Requires rpcgen 0.01 or later
    (CVS source: Tools/Sources/rpcgen  tag: rpcgen-0_01 or later)
    (CVS binary: RiscOS/Library  tag: Library-0_19 or later)
  Requires TCPIPLibs 5.13 or later
    (CVS: RiscOS/Sources/Lib/TCPIPLibs  tag: TCPIPLibs-5_13)

Version 3.00. Tagged as 'NFS-3_00'
@
text
@a44 4
#if DEBUGON && 0
#include "osustime.h"
#endif

a49 2
#include "DebugLib/DebugLib.h"

d246 1
d257 3
a259 1
                if (idle_slot)
d261 1
a361 3
#if DEBUGON && 0
        OSusTimeLo t = OSusTime__ReadLo();
#endif
a455 3
#if DEBUGON && 0
        OSusTimeLo t = OSusTime__ReadLo();
#endif
@


4.2
log
@Module NFSSTB committed by srcmerge.
Merged from Spin_merge to Spinner.
Merge tag prefix is Spinner_23Sep1998
@
text
@d54 1
d72 4
a75 2
        readargs rargs;
        writeargs wargs;
d79 4
a82 2
        readres rres;
        attrstat wres;
d88 1
a88 1
typedef void (*argsfn)(nfsrwstate *rwstate, nfs_fh *fhandle, int *offset, int *nbytes, char **data);
d93 1
a93 1
                                            nfs_fh      *fhandle,
d183 1
a183 1
   	       	  	   if(rwstate[co].cores.rres.status != NFS_OK)
d186 1
d195 1
a195 1
                           } /* endif(rwstate[co].cores.rres.status != NFS_OK) */
d221 1
a221 1
        [nfsproc]   procedure number NFSPROC_READ or NFSPROC_WRITE
d237 1
a237 1
                                          nfs_fh        *fhandle,
d266 1
a266 1
                        	/*  was (&& ntransfers == 0) but that leaves failed transfers in 
d305 1
a305 1
static void setup_readargs(nfsrwstate *rwstate, nfs_fh *fhandle, int *offset, int *nbytes, char **data)
d307 18
a324 7
        rwstate->coargs.rargs.file = *fhandle;
        rwstate->coargs.rargs.offset = *offset;
        rwstate->coargs.rargs.count = (*nbytes > NFS_MAXDATA) ? NFS_MAXDATA : *nbytes;
        *nbytes -= rwstate->coargs.rargs.count;
        *offset += rwstate->coargs.rargs.count;
        rwstate->cores.rres.readres_u.reply.data.data_val = *data;
        *data += rwstate->coargs.rargs.count;
d329 1
a329 1
  fattr *nattr;
d339 12
a350 3
        *args->readres_len += rwstate->cores.rres.readres_u.reply.data.data_len;
        /* This really only needs to be set once, rather than on EVERY endread. */
        *args->nattr = rwstate->cores.rres.readres_u.reply.attributes; /* get attributes for caller cache update */
d358 2
a359 2
        nfs_fh *fhandle,
        unsigned offset,
d361 1
a361 1
        fattr *nattr
d370 2
d377 15
a391 4
        err = transfermany(mount_point, NFSPROC_READ,
                           fhandle, (int)offset, nbytes, readres_data,
                           setup_readargs, endread, &endreadargs,
                           xdr_readargs, xdr_readres);
d403 1
a403 1
static void setup_writeargs(nfsrwstate *rwstate, nfs_fh *fhandle, int *offset, int *nbytes, char **data)
d405 26
a430 8
        rwstate->coargs.wargs.file = *fhandle;
        rwstate->coargs.wargs.offset = *offset;
        rwstate->coargs.wargs.data.data_len = (*nbytes > NFS_MAXDATA) ? NFS_MAXDATA : *nbytes;
        *nbytes -= rwstate->coargs.wargs.data.data_len;
        *offset += rwstate->coargs.wargs.data.data_len;
        rwstate->coargs.wargs.data.data_val = *data;
        *data += rwstate->coargs.wargs.data.data_len;
} /* endfunction nfsrw_readmany */
d438 12
a449 2
        fattr **nattr = arg;
        *nattr = &rwstate->cores.wres.attrstat_u.attributes;  /* N.B. this should not be necessary after every packet transferred */
d453 1
a453 1
        fattr **nattr,
d455 2
a456 2
        nfs_fh *fhandle,
        unsigned offset,
d466 16
a481 4
        err = transfermany(mount_point, NFSPROC_WRITE,
                           fhandle, (int)offset, nbytes, data,
                           setup_writeargs, endwrite, nattr,
                           xdr_writeargs, xdr_attrstat);
@


4.1
log
@Initial revision
@
text
@d37 4
d130 3
a132 1
                                err = rpcnfs_to_riscos_err( &rwstate[co].cores, mount_point, rwstate[co].nfs_client->client );
d194 3
a196 1
                                err = rpcnfs_to_riscos_err( &rwstate[co].cores, mount_point, rwstate[co].nfs_client->client );
d259 3
a261 1
                        if (err != NULL && ntransfers == 0)
d263 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Fix bug of dropped packets during large file save leaving holes in files and
no error reported.
@
text
@a36 4
04-Mar-97 jmf	    Fix bug of dropped packets during large file saves
		    leaving holes in file and no error reported.  Caused
		    by inspecting NFS return codes that have not been set
		    when an RPC fails due to a communications error.
d126 1
a126 3
                          	/*  Was passing &rwstate[co].cores as first argument - wrong because the NFS result
                          	    is not set if the RPC fails.  */
                                err = rpcnfs_to_riscos_err( NULL, mount_point, rwstate[co].nfs_client->client );
d188 1
a188 3
                          	/*  Was passing &rwstate[co].cores as first argument - wrong because the NFS result
                          	    is not set if the RPC fails.  */
                                err = rpcnfs_to_riscos_err( NULL, mount_point, rwstate[co].nfs_client->client );
d251 1
a251 3
                        if (err != NULL) {
                        	/*  was (&& ntransfers == 0) but that leaves failed transfers in 
                        	    the middle of a file unreported.  */
a252 1
                        }
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@

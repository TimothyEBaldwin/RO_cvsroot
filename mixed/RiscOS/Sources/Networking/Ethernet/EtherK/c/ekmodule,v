head	1.22;
access;
symbols
	EtherK-0_25:1.22
	EtherK-0_24:1.21
	EtherK-0_23:1.20
	EtherK-0_22:1.19
	EtherK-0_21:1.19
	EtherK-0_20:1.19
	EtherK-0_19:1.18
	EtherK-0_18:1.17
	EtherK-0_17:1.16
	EtherK-0_16:1.15
	EtherK-0_15:1.15
	EtherK-0_14:1.15
	RO_5_07:1.14
	EtherK-0_13:1.14
	EtherK-0_12:1.13
	EtherK-0_11:1.12
	EtherK-0_10:1.11
	EtherK-0_09:1.10
	EtherK-0_08:1.9
	EtherK-0_07:1.8
	EtherK-0_06:1.7
	EtherK-0_05:1.6
	EtherK-0_04:1.5
	EtherK-0_03:1.4
	EtherK-0_02:1.3
	EtherK-0_01:1.2
	EtherK-0_00:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.22
date	2013.09.12.08.09.10;	author rsprowson;	state Exp;
branches;
next	1.21;
commitid	O2YVBEVtyVd7H75x;

1.21
date	2012.05.18.19.50.06;	author rsprowson;	state Exp;
branches;
next	1.20;
commitid	XXH42I7QHhN74f5w;

1.20
date	2012.02.05.22.38.16;	author jlee;	state Exp;
branches;
next	1.19;
commitid	IbuCtBQH8ng7j1Sv;

1.19
date	2006.02.27.16.45.56;	author jbyrne;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.10.16.00.30;	author jbyrne;	state Exp;
branches;
next	1.17;

1.17
date	2005.09.09.09.06.32;	author jballance;	state Exp;
branches;
next	1.16;

1.16
date	2005.09.07.23.40.53;	author jballance;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.29.00.55.35;	author jballance;	state Exp;
branches;
next	1.14;

1.14
date	2004.09.06.13.27.24;	author jbyrne;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.02.19.08.21;	author jbyrne;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.03.10.44.27;	author rsprowson;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.18.22.09.49;	author jbyrne;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.20.16.04.06;	author jbyrne;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.18.19.20.52;	author jbyrne;	state Exp;
branches;
next	1.8;

1.8
date	2002.12.13.17.55.54;	author jbyrne;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.11.19.14.02;	author jbyrne;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.04.16.19.10;	author rsprowson;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.21.08.37.49;	author rsprowson;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.14.23.17.20;	author rsprowson;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.09.19.54.04;	author rsprowson;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.09.19.38.10;	author rsprowson;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.09.19.21.37;	author rsprowson;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.09.19.21.37;	author rsprowson;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Fix to parsing of EKFlowControl
Using strcmp() on a control terminated argument never achieved a match, now uses OS_SubstituteArgs as a cheap way to get a null terminated string for matching.

Version 0.25. Tagged as 'EtherK-0_25'
@
text
@/* Copyright 2002 Tematic Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    ekmodule.c                                        */
/*                                                            */
/* Purpose: The EtherK DCI 4 driver for the Intel PRO/1000    */
/*          family of network adapters.                       */
/*                                                            */
/* Author:  J.R.Byrne.                                        */
/*                                                            */
/* Origins: Adapted from the Intel FreeBSD 'em' driver, which */
/*          is why all the other files refer to 'em' rather   */
/*          than 'ek' (the name 'EtherM' was already taken.)  */
/*          The RISC OS driver bits were based on Ether1 and  */
/*          EtherI.                                           */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <locale.h>

#include <kernel.h>
#include <swis.h>
#include <Interface/PCI.h>
#include <AsmUtils/irqs.h>
#include <callx/callx.h>
#include <Global/Services.h>

#include "VersionNum"
#include "EKHdr.h"
#include "em_riscos.h"
#include "if_em.h"
#include "em_device.h"
#include "filter.h"
#include "generic.h"
#include "info.h"
#include "log.h"
#include "mbuf.h"
#include "msgs.h"

/* Local definitions */

#ifndef ErrorNumber_Syntax
#define ErrorNumber_Syntax 0xDC
#endif

/* Checks for valid filter parameters */
#define check_errlevel(x)   ((x) == ERRLVL_NO_ERRORS)
#define check_addrlevel(x)  ((x) >= ADDRLVL_SPECIFIC && (x) <= ADDRLVL_PROMISCUOUS)

/* Local structures */

struct swient
{
    static int (*swi_call)(_kernel_swi_regs *); /* SWI handler */
};

/* SWI handler table */

static int ek_version   (_kernel_swi_regs *);
static int ek_inquire   (_kernel_swi_regs *);
static int ek_getmtu    (_kernel_swi_regs *);
static int ek_setmtu    (_kernel_swi_regs *);
static int ek_transmit  (_kernel_swi_regs *);
static int ek_filter    (_kernel_swi_regs *);
extern int ek_stats     (_kernel_swi_regs *);
static int ek_multicast (_kernel_swi_regs *);

static struct swient ek_ent[] =
{
    ek_version,
    ek_inquire,
    ek_getmtu,
    ek_setmtu,
    ek_transmit,
    ek_filter,
    ek_stats,
    ek_multicast
};

/* Static variables */

static void       * module_wsp;

static int          ekcnt = 0;          /* Number of devices */
static device_t     device_list = NULL; /* List of devices */

static bool         managerstarted = false;
static bool         finalising = false;

static bool         timer_callb_set = false;

static struct stats supported_stats;

/* Hard-coded strings */

static const char   location_unknown[] = "Unknown";
static const char   location_motherboard[] = "Motherboard";
static const char   location_string[] = "PCI Slot %u";
static const char   short_name[] = "ek";
static const char   ether_type[] = "ek0";
static const char   module_name[] = Module_Title;
static const char   link_param_auto[] = "Auto";
static const char   link_param_full[] = "Full";
static const char   link_param_half[] = "Half";
static const char   link_param_1000[] = "1000";
static const char   link_param_100[] = "100";
static const char   link_param_10[] = "10";
static const char   link_param_mdi[] = "MDI";
static const char   link_param_mdix[] = "MDI-X";
static const char   flow_param_none[] = "None";
static const char   flow_param_generate[] = "Generate";
static const char   flow_param_respond[] = "Respond";
static const char   flow_param_full[] = "Full";


/**************************************************************/
/* get_device()                                               */
/*                                                            */
/* Return a pointer to the device structure for the unit with */
/* a given number.                                            */
/*                                                            */
/* Parameters: Unit number.                                   */
/*                                                            */
/* Returns:    Pointer to device structure, or NULL.          */
/**************************************************************/

static device_t get_device(int unit)
{
    int         i;
    device_t    p = device_list;

    for (i = 0; i < unit && p != NULL; i++)
        p = p->next;

    return p;
}


/**************************************************************/
/* Timer routines.                                            */
/**************************************************************/


/**************************************************************/
/* callb_timer()                                              */
/*                                                            */
/* Handler for callback set by timer_handler() every second.  */
/* Execute em_local_timer() for alternately all odd numbered  */
/* units, then all even numbered ones. This means that each   */
/* unit has the routine called every 2 seconds.               */
/*                                                            */
/* Parameters: Register block on callback;                    */
/*                                                            */
/*             Module private word;                           */
/*                                                            */
/*             Handle.                                        */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * callb_timer(_kernel_swi_regs * r, void * pw, void * handle)
{
    static unsigned int which = 0;
    device_t            dev;

    (void)r;
    (void)pw;
    (void)handle;

    for (dev = device_list; dev; dev = dev->next)
    {
        if (dev->localtimerset && (dev->dib.dib_unit & 1) == which)
        {
            dprintf(("Timer", "%s: Calling em_local_timer() for unit %u\n", __func__, dev->dib.dib_unit));
            em_local_timer(&dev->adapter);
        }
    }

    which ^= 1;
    timer_callb_set = false;

    return NULL;
}

/**************************************************************/
/* timer_handler()                                            */
/*                                                            */
/* Handler for callevery timer called once a second.          */
/*                                                            */
/* Parameters: Register block;                                */
/*                                                            */
/*             Module private word;                           */
/*                                                            */
/*             Handle.                                        */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * timer_handler(_kernel_swi_regs * r, void * pw, void * handle)
{
    device_t dev;
    uint32_t now;

    (void)r;
    (void)pw;
    (void)handle;

    _swix(OS_ReadMonotonicTime, _OUT(0), &now);

    /* Do the watchdog check for each unit */
    for (dev = device_list; dev; dev = dev->next)
    {
        if (
            dev->initialised &&
            (dev->adapter.interface_data.ac_if.if_flags & IFF_RUNNING) != 0
           )
        {
            em_ro_watchdog(dev, now);
        }
    }

    /* Schedule a callback to call em_local_timer */
    if (!timer_callb_set)
    {
        if (callx_add_callback(callb_timer, NULL) == NULL)
        {
            timer_callb_set = true;
        }
    }

    return NULL;
}


/**************************************************************/
/* Service call handler support routines.                     */
/**************************************************************/


/**************************************************************/
/* panic()                                                    */
/*                                                            */
/* Log a 'panic' message for all units.                       */
/*                                                            */
/* Parameters: Pointer to the message string.                 */
/**************************************************************/

static void panic(char *s)
{
    device_t dev;

    for (dev = device_list; dev; dev = dev->next)
    {
        log_message(dev, "Panic: %s", s);
    }
}

/**************************************************************/
/* send_driverstatus()                                        */
/*                                                            */
/* Send a DCIDriverStatus Service Call for given dib.         */
/*                                                            */
/* Parameters: Pointer to the dib;                            */
/*                                                            */
/*             The status value to send                       */
/*             (0=starting, 1=terminating.)                   */
/**************************************************************/

static void send_driverstatus(DibRef dib, int status)
{
    dprintf(("Service", "%s: Sending Service_DCIDriverStatus for unit %d, status=%d\n",
        __func__, dib->dib_unit, status));

    _swix(OS_ServiceCall,
          _INR(0,3),

          dib,
          Service_DCIDriverStatus,
          status,
          DCIVERSION);
}

/**************************************************************/
/* callb_send_driverstatus()                                  */
/*                                                            */
/* Handler for callback primed by initialisation routine.     */
/* Sends round DCIDriverStatus Service Calls for all units    */
/* to say they are starting.                                  */
/*                                                            */
/* Parameters: Register block on callback;                    */
/*                                                            */
/*             Module private word;                           */
/*                                                            */
/*             Handle.                                        */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * callb_send_driverstatus(_kernel_swi_regs * r, void * pw, void * handle)
{
    device_t    dev;

    (void)r;
    (void)pw;
    (void)handle;

    for (dev = device_list; dev; dev = dev->next)
    {
        send_driverstatus(&dev->dib, DCIDRIVER_STARTING);
    }

    return NULL;
}

/**************************************************************/
/* handle_managerstatus()                                     */
/*                                                            */
/* Deal with a MbufManagerStatus service call.                */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/**************************************************************/

static void handle_managerstatus(_kernel_swi_regs * r)
{
    switch (r->r[0])
    {
      case MbufManagerStatus_Started:
        dprintf(("Service", "%s: MbufManagerStatus_Started\n", __func__));
        if (!managerstarted)
        {
            /* Mbuf manager has appeared - open session */
            if (mbuf_open_session() == NULL)
            {
                /* Mbuf system initialised, set a callback */
                /* to announce our presence.               */
                managerstarted = true;
                callx_add_callback(callb_send_driverstatus, NULL);
            }
        }

        break;

      case MbufManagerStatus_Stopping:
        dprintf(("Service", "%s: MbufManagerStatus_Stopping\n", __func__));
        /* We should only ever see this message if we are finalising our */
        /* own module, otherwise something has gone terribly wrong (the  */
        /* mbuf manager should only stop when all its clients have       */
        /* closed their sessions.)                                       */
        if (!finalising) panic("Mbuf manager has stopped");
        break;

      case MbufManagerStatus_Scavenge:
        dprintf(("Service", "%s: MbufManagerStatus_Scavenge\n", __func__));
        /* do nothing */
        break;

      default:
        break;
    }
}

/**************************************************************/
/* release_module_filters()                                   */
/*                                                            */
/* Remove all the filters associated with the module with the */
/* specified private word pointer.                            */
/*                                                            */
/* Parameters: Private word pointer.                          */
/**************************************************************/

static void release_module_filters(u_int pwp)
{
    device_t    dev;

    /* Loop over all active units looking for the module */
    for (dev = device_list; dev; dev = dev->next)
    {
        filter_release_module(dev, pwp);
    }
}


/**************************************************************/
/* SWI handler routines.                                      */
/**************************************************************/


/**************************************************************/
/* ek_version()                                               */
/*                                                            */
/* Implement SWI EtherK_Version.                              */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/*                                                            */
/* Returns:    BSD error number.                              */
/**************************************************************/

static int ek_version(_kernel_swi_regs *r)
{
    if (r->r[0])
        return EINVAL;

    r->r[1] = DCIVERSION;

    return 0;
}

/**************************************************************/
/* ek_inquire()                                               */
/*                                                            */
/* Implement SWI EtherK_Inquire.                              */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/*                                                            */
/* Returns:    BSD error number.                              */
/**************************************************************/

static int ek_inquire(_kernel_swi_regs *r)
{
    device_t dev = get_device(r->r[1]);

    if (r->r[0])
        return EINVAL;

    if (dev == NULL)
        return ENXIO;

    r->r[2] = dev->dib.dib_inquire;

    return 0;
}

/**************************************************************/
/* ek_getmtu()                                                */
/*                                                            */
/* Implement SWI EtherK_GetNetworkMTU.                        */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/*                                                            */
/* Returns:    BSD error number.                              */
/**************************************************************/

static int ek_getmtu(_kernel_swi_regs *r)
{
    device_t dev = get_device(r->r[1]);
    int      error = 0;

    if (r->r[0])
    {
        error = EINVAL;
    }
    else if (dev == NULL)
    {
        error = ENXIO;
    }
    else if (!dev->initialised)
    {
        error = ENETDOWN;
    }
    else
    {
        r->r[2] = (int)dev->adapter.interface_data.ac_if.if_mtu;
    }

    return error;
}

/**************************************************************/
/* ek_setmtu()                                                */
/*                                                            */
/* Implement SWI EtherK_SetNetworkMTU.                        */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/*                                                            */
/* Returns:    BSD error number.                              */
/**************************************************************/

static int ek_setmtu(_kernel_swi_regs *r)
{
    device_t dev = get_device(r->r[1]);
    int      error = 0;

    if (r->r[0])
    {
        error = EINVAL;
    }
    else if (dev == NULL)
    {
        error = ENXIO;
    }
    else if (!dev->initialised)
    {
        error = ENETDOWN;
    }
    else
    {
        if (r->r[2] > ETHERMTU)
        {
            error = EINVAL;
        }
        else
        {
            dev->adapter.interface_data.ac_if.if_mtu = r->r[2];
            dev->adapter.hw.max_frame_size = r->r[2] + ETHER_HDR_LEN + ETHER_CRC_LEN;
            /* Note that the BSD code calls em_init() after changing the */
            /* MTU, but this is only necessary to do the settings for    */
            /* jumbo frames, which we don't currently support.           */
        }
    }

    return error;
}

/**************************************************************/
/* ek_transmit()                                              */
/*                                                            */
/* Implement SWI EtherK_Transmit.                             */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/*                                                            */
/* Returns:    BSD error number.                              */
/**************************************************************/

static int ek_transmit(_kernel_swi_regs* r)
{
    uint32_t      flags = r->r[0];
    device_t      dev = get_device(r->r[1]);
    struct mbuf * m_head = (struct mbuf *)r->r[3];
    struct mbuf * m;
    uint8_t     * esrc;
    int           num_packets = 0;
    int           error = 0;

    dprintf(("SWI", "%s: unit=%d, flags=&%x, type=&%x, m_head=%p\n", __func__,
             r->r[1], flags, r->r[2], m_head));

    if (flags >= TX_1STRESERVED)
    {
        error = EINVAL;
    }
    else if (dev == NULL)
    {
        error = ENXIO;
    }
    else if (!dev->initialised ||
             (dev->adapter.interface_data.ac_if.if_flags & IFF_RUNNING) == 0)
    {
        error = ENETDOWN;
    }
    else if (!dev->adapter.link_active)
    {
        /* Was initialisation started without waiting for auto-negotiation? */
        if (dev->adapter.hw.wait_autoneg_complete == 0 &&
            dev->adapter.init_start_time != 0)
        {
            uint32_t now;

            /* Wait until the time out period has elapsed or the link comes up */
            dprintf(("TX", "Blocking for link up - "));
            do
            {
                _swix(OS_ReadMonotonicTime, _OUT(0), &now);
            } while (!dev->adapter.link_active && (now - dev->adapter.init_start_time) < (PHY_AUTO_NEG_TIME * 10));
            dprintf(("TX", "finished. Time diff=%u, link=%d\n", now - dev->adapter.init_start_time, dev->adapter.link_active));

            /* Don't do this again until the chip is reinitialised */
            dev->adapter.init_start_time = 0;

            if (!dev->adapter.link_active)
            {
                error = ENETDOWN;
            }
        }
        else
        {
            error = ENETDOWN;
        }
    }

    if (!error)
    {
        /* Count the number of packets to send */
        for (m = m_head; m; m = m->m_list)
            num_packets++;
    }

    if (num_packets > 0)
    {
        if ((flags & TX_FAKESOURCE) != 0 && r->r[5] != 0)
            esrc = (uint8_t *)r->r[5];
        else
            esrc = dev->adapter.hw.mac_addr;

        error = em_ro_transmit(dev, m_head, num_packets, (uint8_t *)r->r[4], esrc, htons(r->r[2]));
    }

    if ((flags & TX_PROTOSDATA) == 0)
    {
        /* We own the mbufs, so free them. It appears that this is the   */
        /* correct thing to do, even if we return an error, although the */
        /* DCI 4 specification is not clear on this.                     */

        while (m_head)
        {
            m = m_head;
            m_head = m_head->m_list;
            m_freem(m);
        }
    }

    return error;
}

/**************************************************************/
/* ek_filter()                                                */
/*                                                            */
/* Implement SWI EtherK_Filter.                               */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/*                                                            */
/* Returns:    BSD error number.                              */
/**************************************************************/

static int ek_filter(_kernel_swi_regs *r)
{
    device_t dev = get_device(r->r[1]);

    dprintf(("SWI", "%s: flags=&%x, unit=%d, frame type=&%x, address level=&%x, error level=&%x, pwp=&%x, handler=&%x\n",
              __func__,
              r->r[0], r->r[1], r->r[2], r->r[3], r->r[4], r->r[5], r->r[6]));

    /* Range checking */
    if (
        r->r[0] >= FILTER_1STRESERVED ||
        !check_addrlevel(r->r[3])     ||
        !check_errlevel(r->r[4])
       )
    {
        dprintf(("SWI", "%s: Invalid flags\n", __func__));
        return EINVAL;
    }

    if (dev == NULL)
        return ENXIO;

    if (!dev->initialised)
        return ENETDOWN;

    return filter_update(r, dev);
}

/**************************************************************/
/* ek_stats()                                                 */
/*                                                            */
/* Implement SWI EtherK_Stats.                                */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/*                                                            */
/* Returns:    BSD error number.                              */
/**************************************************************/

int ek_stats(_kernel_swi_regs * r)
{
    int error = 0;

    switch (r->r[0])
    {
        case 0:
            memcpy((char *)(r->r[2]), &supported_stats, sizeof(supported_stats));
            break;

        case 1:
        {
            device_t dev = get_device(r->r[1]);

            if (dev != NULL)
            {
                int irqstate;

                /* Get statistics up to date */
                em_ro_update_stats(dev);

                /* Disable interrupts during copy, as some stats may be updated by interrupt */
                irqstate = ensure_irqs_off();
                memcpy((char *)(r->r[2]), &dev->stats, sizeof(dev->stats));
                restore_irqs(irqstate);
            }
            else
            {
                error = ENXIO;
            }
            break;
        }

        default:
            error = EINVAL;
            break;
    }


    return error;
}

/**************************************************************/
/* ek_multicast()                                             */
/*                                                            */
/* Implement SWI EtherK_Multicast.                            */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/*                                                            */
/* Returns:    BSD error number.                              */
/**************************************************************/

static int ek_multicast(_kernel_swi_regs *r)
{
    (void)r;
    
    dprintf(("SWI", "%s: Called\n", __func__));
    /* !!!TODO!!! Not implemented yet */
    return ENOTTY;
}


/**************************************************************/
/* CLI command handler routines.                              */
/**************************************************************/


/**************************************************************/
/* parse_unit_num()                                           */
/*                                                            */
/* Parse unit number from command line parameter, checking    */
/* for validity.                                              */
/*                                                            */
/* Parameters: Pointer to parameter string;                   */
/*                                                            */
/*             Pointer to variable to hold unit number.       */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * parse_unit_num(const char ** arg_string, int * unit)
{
    _kernel_oserror * e;

    if (ekcnt == 0)
        return messages_make_error("Err_NoUnits", ENXIO, NULL);

    e = _swix(
              OS_ReadUnsigned,
              _INR(0,2) | _OUTR(1,2),

              10 | (1u<<29) | (1u<<31),
              *arg_string,
              ekcnt - 1,

              arg_string,
              unit);

    if (e != NULL)
        return messages_make_error("Err_BadUnit", ENXIO, NULL);

    return NULL;
}

/**************************************************************/
/* ek_cli_info()                                              */
/*                                                            */
/* Implement *EKInfo command.                                 */
/*                                                            */
/* Parameters: Pointer to parameter string;                   */
/*                                                            */
/*             Number of parameters.                          */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_info(const char * arg_string, int arg_count)
{
    static const char keywords[] = ",verbose/s";

    _kernel_oserror * e = NULL;
    int               unit = -1;
    bool              verbose = false;

    if (arg_count > 0)
    {
        uint32_t out_buff[5];   /* 2 pointers, 12 bytes for unit number parameter */

        e = _swix(OS_ReadArgs,
                  _INR(0,3),

                  keywords,
                  arg_string,
                  out_buff,
                  sizeof(out_buff));

        if (e != NULL)
            return messages_make_error("SETKINF", ErrorNumber_Syntax, NULL);

        verbose = (out_buff[1] != 0);

        if (out_buff[0] != 0)
        {
            e = parse_unit_num((const char **)out_buff, &unit);
            if (e != NULL)
                return e;
        }
    }

    if (unit == -1)
    {
        info_print(0, "Inf_Head1", 1, Module_FullVersion);
        info_printf(0, "Inf_Head2", "%d.%02d", DCIVERSION / 100, DCIVERSION % 100);

        if (ekcnt == 0)
        {
            info_print(0, "Err_NoUnits", 0);
        }
        else
        {
            info_printf(0, "Inf_Head3", "%d", ekcnt);
            for (int i = 0; i < ekcnt && e == NULL; i++)
            {
                e = info_output(get_device(i), verbose);
            }
        }
    }
    else
    {
        e = info_output(get_device(unit), verbose);
    }

    return e;
}

/**************************************************************/
/* ek_cli_test()                                              */
/*                                                            */
/* Implement *EKTest command.                                 */
/*                                                            */
/* Parameters: Pointer to parameter string.                   */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_test(const char *arg_string)
{
    _kernel_oserror * e;
    int               unit;

    e = parse_unit_num(&arg_string, &unit);
    if (e != NULL)
        return e;

    test_run(get_device(unit));
    return NULL;
}

/**************************************************************/
/* ek_cli_log()                                               */
/*                                                            */
/* Implement *EKLog command.                                  */
/*                                                            */
/* Parameters: Pointer to parameter string;                   */
/*                                                            */
/*             Number of parameters.                          */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_log(const char *arg_string, int arg_count)
{
    _kernel_oserror * e;
    int               unit;

    if (arg_count > 0)
    {
        e = parse_unit_num(&arg_string, &unit);
        if (e == NULL)
            e = log_output(get_device(unit));
    }
    else
    {
        for (unit = 0, e = NULL; unit < ekcnt && e == NULL; unit++)
        {
            if (unit != 0)
               putchar('\n');
            e = log_output(get_device(unit));
        }
    }

    return e;
}

/**************************************************************/
/* ek_cli_link()                                              */
/*                                                            */
/* Implement *Configure EKLink command.                       */
/*                                                            */
/* Parameters: Pointer to parameter string.                   */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_link(const char * arg_string)
{
    _kernel_oserror * e;
    int               unit;
    static const char arg_template[] = "%1\0%2\0%3\0%4";
    char              args[32];
    char            * duplex_arg;
    char            * mdi_arg;
    bool              have_duplex;
    bool              full_duplex = false;
    bool              syntax_error = false;
    ConfigLink        setting = link_auto;
    uint8_t           mdix;

    /* Use OS_SubstituteArgs to separate the arguments using CLI rules. */
    e = _swix(OS_SubstituteArgs,
              _INR(0,4),

              (uint32_t)arg_string,
              args,
              sizeof(args),
              arg_template,
              sizeof(arg_template));

    if (e != NULL)
        return messages_make_error("SETKLNK", ErrorNumber_Syntax, NULL);

    duplex_arg = args + strlen(args) + 1;
    mdi_arg = duplex_arg + strlen(duplex_arg) + 1;

    /* Now args points to the second argument, duplex_arg to the third, */
    /* mdi_arg to the fourth. If there's anything after this, we had    */
    /* too many arguments.                                              */
    if (*(mdi_arg + strlen(mdi_arg) + 1) != 0)
        return configure_TOO_MANY_PARAMS;

    /* Check the unit number */
    e = parse_unit_num(&arg_string, &unit);
    if (e != NULL)
        return e;

    /* Check the third argument to see if it is 'half' or 'full' */
    if (duplex_arg[0] == 0)
    {
        /* There were only two parameters */
        have_duplex = false;
        mdix = 0;
    }
    else
    {
        if (Strcmp_ci(duplex_arg, link_param_full) == 0)
        {
            have_duplex = true;
            full_duplex = true;
        }
        else if (Strcmp_ci(duplex_arg, link_param_half) == 0)
        {
            have_duplex = true;
            full_duplex = false;
        }
        else
        {
            /* Not 'full' or 'half'. As long as there isn't a third */
            /* argument, assume this is actually the MDI parameter. */
            have_duplex = false;
            if (mdi_arg[0] == 0)
            {
                mdi_arg = duplex_arg;
            }
            else
            {
                syntax_error = true;
            }
        }
    }

    /* Check the speed parameter */
    if (Strcmp_ci(args, link_param_auto) == 0)
    {
        setting = link_auto;
        if (have_duplex)
            syntax_error = true;
    }
    else if (Strcmp_ci(args, link_param_100) == 0)
    {
        setting = full_duplex ? link_100_full : link_100_half;
        if (!have_duplex)
            syntax_error = true;
    }
    else if (Strcmp_ci(args, link_param_10) == 0)
    {
        setting = full_duplex ? link_10_full : link_10_half;
        if (!have_duplex)
            syntax_error = true;
    }
    else
    {
        syntax_error = true;
    }

    /* Check the MDI parameter */
    if (mdi_arg[0] == 0)
    {
        /* Default is auto if the speed is auto or MDI if speed is forced */
        mdix = (setting == link_auto) ? 0 : 1;
    }
    else if (Strcmp_ci(mdi_arg, link_param_mdi) == 0)
    {
        mdix = 1;   /* MDI */
    }
    else if (Strcmp_ci(mdi_arg, link_param_mdix) == 0)
    {
        mdix = 2;   /* MDI-X */
    }
    else
    {
        syntax_error = true;
    }

    if (syntax_error)
        return messages_make_error("SETKLNK", ErrorNumber_Syntax, NULL);

    return em_ro_change_link(get_device(unit), setting, mdix);
}

/**************************************************************/
/* ek_cli_link_status()                                       */
/*                                                            */
/* Implement *Status EKLink command.                          */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_link_status(void)
{
    device_t dev;

    for (int i = 0; i < ekcnt; i++)
    {
        const char * p1 = "";
        const char * p2 = NULL;
#if 0
        const char * p3 = NULL;
#endif

        dev = get_device(i);

        switch (dev->link_setting)
        {
            case link_auto:
                p1 = link_param_auto;
                break;

            case link_1000:
                p1 = link_param_1000;
                break;

            case link_100_half:
                p1 = link_param_100;
                p2 = link_param_half;
                break;

            case link_100_full:
                p1 = link_param_100;
                p2 = link_param_full;
                break;

            case link_10_half:
                p1 = link_param_10;
                p2 = link_param_half;
                break;

            case link_10_full:
                p1 = link_param_10;
                p2 = link_param_full;
                break;
        }

        /* MDI/MDI-X option is currently hidden, as the fact that it */
        /* doesn't seem to work when the link speed is forced means  */
        /* that it isn't very useful.                                */
#if 0
        switch (dev->link_mdix)
        {
            case 1:
                p3 = link_param_mdi;
                break;

            case 2:
                p3 = link_param_mdix;
                break;
        }
#endif

        printf("EKLink     %d %s", i, p1);
        if (p2 != NULL)
            printf(" %s", p2);
#if 0
        if (p3 != NULL)
            printf(" %s", p3);
#endif
        putchar('\n');
    }
    return NULL;
}

/**************************************************************/
/* advertise_set_flags()                                      */
/*                                                            */
/* Set bits in a bit mask and return whether they were        */
/* already set or not.                                        */
/*                                                            */
/* Parameters: Bits to be tested and set;                     */
/*                                                            */
/*             Pointer to bit mask.                           */
/*                                                            */
/* Returns:    True if the bits were already set, else false. */
/**************************************************************/

static bool advertise_set_flags(uint8_t bits, uint8_t * mask)
{
    if (((*mask) & bits) != 0)
        return true;

    *mask |= bits;

    return false;
}

/**************************************************************/
/* ek_cli_advertise()                                         */
/*                                                            */
/* Implement *Configure EKAdvertise command.                  */
/*                                                            */
/* Parameters: Pointer to parameter string.                   */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_advertise(const char * arg_string)
{
    _kernel_oserror    * e;
    int                  unit;
    static const char    arg_template[] = "%1\0%2\0%3\0%4\0%5\0%6\0%7\0%8";
    char                 args[40];
    char               * arg_ptr;
    uint8_t              setting;
    uint8_t              speed;
    bool                 had_duplex;
    bool                 syntax_error;

    /* Use OS_SubstituteArgs to separate the arguments using CLI rules. */
    e = _swix(OS_SubstituteArgs,
              _INR(0,4),

              (uint32_t)arg_string,
              args,
              sizeof(args),
              arg_template,
              sizeof(arg_template));

    if (e != NULL)
        return messages_make_error("SETKADV", ErrorNumber_Syntax, NULL);

    /* Check the unit number */
    e = parse_unit_num(&arg_string, &unit);
    if (e != NULL)
        return e;

    /* Run through the arguments, setting the bits in the advertise mask. */
    /* If '10' or '100' is specified without 'half' or 'full' afterwards, */
    /* both duplex settings are made available. The same bit cannot be    */
    /* set twice.                                                         */
    arg_ptr = args;
    setting = 0;
    speed = 0;
    had_duplex = false;
    syntax_error = false;
    while(*arg_ptr != 0 && !syntax_error)
    {
        if (Strcmp_ci(arg_ptr, link_param_1000) == 0)
        {
            syntax_error = advertise_set_flags(ADVERTISE_1000_FULL, &setting);
            speed = 0;
            had_duplex = false;
        }
        else if (Strcmp_ci(arg_ptr, link_param_100) == 0)
        {
            if (speed != 0 && !had_duplex)
                syntax_error = advertise_set_flags(speed | (speed>>1), &setting);
            speed = ADVERTISE_100_FULL;
            had_duplex = false;
        }
        else if (Strcmp_ci(arg_ptr, link_param_10) == 0)
        {
            if (speed != 0 && !had_duplex)
                syntax_error = advertise_set_flags(speed | (speed>>1), &setting);
            speed = ADVERTISE_10_FULL;
            had_duplex = false;
        }
        else if (Strcmp_ci(arg_ptr, link_param_full) == 0)
        {
            if (speed == 0)
                syntax_error = true;
            else
                syntax_error = advertise_set_flags(speed, &setting);
            had_duplex = true;
        }
        else if (Strcmp_ci(arg_ptr, link_param_half) == 0)
        {
            if (speed == 0)
                syntax_error = true;
            else
                syntax_error = advertise_set_flags(speed>>1, &setting);
            had_duplex = true;
        }
        else
        {
            syntax_error = true;
        }

        arg_ptr += strlen(arg_ptr) + 1;
    }

    if (!syntax_error && speed != 0 && !had_duplex)
        syntax_error = advertise_set_flags(speed | (speed>>1), &setting);

    if (syntax_error)
        return messages_make_error("SETKADV", ErrorNumber_Syntax, NULL);

    return em_ro_set_advertise(get_device(unit), setting);
}

/**************************************************************/
/* ek_cli_advertise_status()                                  */
/*                                                            */
/* Implement *Status EKAdvertise command.                     */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_advertise_status(void)
{
    device_t dev;

    for (int i = 0; i < ekcnt; i++)
    {
        uint8_t advertised;

        dev = get_device(i);
        advertised = dev->advertise;
        
        printf("EKAdvertise %d", i);
        if (advertised & (ADVERTISE_10_HALF|ADVERTISE_10_FULL))
            printf(" %s", link_param_10);
        if (advertised & ADVERTISE_10_HALF)
            printf(" %s", link_param_half);
        if (advertised & ADVERTISE_10_FULL)
            printf(" %s", link_param_full);
        if (advertised & (ADVERTISE_100_HALF|ADVERTISE_100_FULL))
            printf(" %s", link_param_100);
        if (advertised & ADVERTISE_100_HALF)
            printf(" %s", link_param_half);
        if (advertised & ADVERTISE_100_FULL)
            printf(" %s", link_param_full);
        if (advertised & ADVERTISE_1000_FULL)
            printf(" %s", link_param_1000);
        putchar('\n');
    }

    return NULL;
}

/**************************************************************/
/* ek_cli_flow()                                              */
/*                                                            */
/* Implement *Configure EKFlowControl command.                */
/*                                                            */
/* Parameters: Pointer to parameter string.                   */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_flow(const char * arg_string)
{
    _kernel_oserror * e;
    int               unit;
    static const char arg_template[] = "%0";
    char              args[32];
    em_fc_type        setting;

    /* Check the unit number */
    e = parse_unit_num(&arg_string, &unit);
    if (e != NULL)
        return e;

    /* Ensure the control terminated parameter is compared as a C string */
    e = _swix(OS_SubstituteArgs,
              _INR(0,4),

              arg_string,
              args,
              sizeof(args),
              arg_template,
              sizeof(arg_template));

    /* Check the parameter */
    if (Strcmp_ci(args, flow_param_none) == 0)
    {
        setting = em_fc_none;
    }
    else if (Strcmp_ci(args, flow_param_respond) == 0)
    {
        setting = em_fc_rx_pause;
    }
    else if (Strcmp_ci(args, flow_param_generate) == 0)
    {
        setting = em_fc_tx_pause;
    }
    else if (Strcmp_ci(args, flow_param_full) == 0)
    {
        setting = em_fc_full;
    }
    else
    {
        return messages_make_error("SETKFLW", ErrorNumber_Syntax, NULL);
    }

    return em_ro_set_flow(get_device(unit), setting);
}

/**************************************************************/
/* ek_cli_flow_status()                                       */
/*                                                            */
/* Implement *Status EKFlowControl command.                   */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_flow_status(void)
{
    device_t dev;

    for (int i = 0; i < ekcnt; i++)
    {
        const char * p = "";

        dev = get_device(i);

        switch (dev->flow_control)
        {
            case em_fc_none:
                p = flow_param_none;
                break;

            case em_fc_rx_pause:
                p = flow_param_respond;
                break;

            case em_fc_tx_pause:
                p = flow_param_generate;
                break;

            case em_fc_full:
                p = flow_param_full;
                break;
        }

        printf("EKFlowControl %d %s\n", i, p);
    }
    return NULL;
}


/**************************************************************/
/* Module entry points                                        */
/**************************************************************/


/**************************************************************/
/* ek_initialise()                                            */
/*                                                            */
/* Module initialisation code.                                */
/*                                                            */
/* Parameters: Pointer to argument list;                      */
/*                                                            */
/*             Podule base;                                   */
/*                                                            */
/*             Module workspace pointer.                      */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

_kernel_oserror * ek_initialise(const char * cmd_tail, int podule_base, void * pw)
{
    _kernel_oserror *   e;
    uint32_t            num_handles;
    uint32_t            fh;
    device_t            dev = NULL;
    device_t            prev = NULL;
    bool                alloc_failed = false;
    bool                init_failed;
    struct
    {
        uint32_t        devfn;
        uint32_t        bus;
        uint32_t        slot;
        uint32_t        id;
        uint32_t        sub_id;
        uint32_t        device_vector;
    } pci_info;
    const uint32_t      pci_info_bits = PCI_ReadInfo_DevFn + PCI_ReadInfo_Bus +
                                        PCI_ReadInfo_Slot + PCI_ReadInfo_DeviceID +
                                        PCI_ReadInfo_SubsystemID + PCI_ReadInfo_IntDeviceVector;

    (void)cmd_tail;
    (void)podule_base;

    module_wsp = pw;

    /* Initialise DebugLib */
    debug_initialise("EtherK", "null:", NULL);
    debug_set_taskname_prefix(false);
    debug_set_stamp_debug(true);
    debug_set_device(DADEBUG_OUTPUT);
    debug_set_raw_device(NULL_OUTPUT);
    debug_set_trace_device(NULL_OUTPUT);

    /* Initalise callx */
    callx_init(pw);

#ifdef DBG_STATS
    em_ro_init_dbg_stats();
#endif

    /* Initialise messages */
    e = messages_init();
    if (e != NULL)
        return e;

    /* Initialise locale for printing formatted numbers */
    setlocale(LC_ALL, "");

    /* Initialise the supported statistics structure */
    em_ro_init_supported_stats(&supported_stats);

    /* Look for devices we can drive */

    e = _swix(PCI_ReturnNumber,
              _OUT(0),

              &num_handles);

    if (e != NULL)
    {
        dprintf(("", "%s: PCI_ReturnNumber failed: '%s'\n", __func__, e->errmess));
        num_handles = 0;
    }

    dprintf(("Init", "%s: PCI_ReturnNumber reports %d function handles\n", __func__, num_handles));

    for (fh = 1; fh <= num_handles; fh++)
    {
        /* Make sure we have a device structure to fill in */
        if (dev == NULL)
        {
            dev = calloc(1, sizeof(struct device));
            if (dev == NULL)
            {
                alloc_failed = true;
                break;
            }
        }

        dev->module_wsp = pw;
        dev->function_handle = fh;

        /* Read various PCI device information */
        e = _swix(PCI_ReadInfo,
                  _INR(0,3),

                  pci_info_bits,
                  &pci_info,
                  sizeof(pci_info),
                  fh);

        if (e != NULL)
        {
            /* Something went wrong - failed to read the info */
            dprintf(("Init", "%s: PCI_ReadInfo for function handle %u failed: '%s'\n", __func__, fh, e->errmess));
            continue;
        }

        dev->pci_id = pci_info.id;
        dev->pci_sub_id = pci_info.sub_id;
        dev->device_vector = pci_info.device_vector;

        dprintf(("Init", "%s: Function handle %d has vendor ID %04x, device ID %04x, subsystem vendor ID %04x, subsystem ID %04x\n",
             __func__, fh, (dev->pci_id & 0xffff), (dev->pci_id >> 16), (dev->pci_sub_id & 0xffff), (dev->pci_sub_id >> 16)));

        /* Ask the driver whether it recognises this device */
        if (em_probe(dev) == 0)
        {
            bool on_motherboard = ((pci_info.devfn == 0x20) && (pci_info.bus == 0));

            init_failed = false;
            dprintf(("Init", "%s: Function handle %d recognised by em_probe()\n", __func__, fh));
            dprintf(("Init", "%s: Device vector is %d\n", __func__, dev->device_vector));

#ifdef NOMOBO
            if (!on_motherboard) /* Ignore motherboard device */
            {
#endif

            log_message(dev, "Initialising device");

            /* Increment the global count of the number of units */
            ekcnt++;

            /* Initialise the address filter function pointer */
            dev->address_filter = af_reject;

            /* Fill in the Device Information Block */
            dev->dib.dib_swibase = EtherK_00;
            dev->dib.dib_name = (unsigned char *)short_name;
            dev->dib.dib_unit = ekcnt - 1;
            /* dev->dib.dib_address is set after em_attach() */
            dev->dib.dib_module = (unsigned char *)module_name;
            dev->dib.dib_inquire = (INQ_MULTICAST | INQ_PROMISCUOUS |
                                INQ_HWADDRVALID | INQ_SOFTHWADDR |
                                INQ_HASSTATS /*| INQ_HW_MULTICAST*/ );
            /* !!!TODO!!! - get the flags right */

            /* Read the NVRAM configuration settings */
            em_ro_read_configuration(dev);

            if (on_motherboard)
            {
                char    mac[8];

                /* This device is on the motherboard */

                dev->dib.dib_location = (unsigned char *)location_motherboard;

                /* The motherboard controller is a special case. There is */
                /* no EEPROM, so set up the fake EEPROM data now.         */

                dev->no_eeprom = true;

                /* Read the MAC address */
                e = _swix(PCI_ReadInfo,
                          _INR(0,3),

                          PCI_ReadInfo_EthernetAddress,
                          mac,
                          sizeof(mac),
                          fh);

                if (e == NULL)
                {
                    int i;

                    /* Bung the MAC address directly into the driver's */
                    /* hardware structure.                             */
                    for(i = 0; i < NODE_ADDRESS_SIZE; i++)
                        dev->adapter.hw.mac_addr[i] = dev->adapter.hw.perm_mac_addr[i] = mac[5-i];
                }
                else
                {
                    log_message(dev, "Failed to read MAC address for motherboard Ethernet controller (function handle %u, error: '%s')", fh, e->errmess);

                    /* No MAC address, so this device can't be initialised */
                    init_failed = true;
                }
            }
            else
            {
                if (pci_info.slot > 99 || (dev->dib.dib_location = malloc(sizeof(location_string))) == NULL)
                    dev->dib.dib_location = (unsigned char *)location_unknown;
                else
                    sprintf((char *)dev->dib.dib_location, location_string, pci_info.slot);
            }

            dprintf(("Init", "%s: Location of device for function handle %u is '%s'\n", __func__, fh, dev->dib.dib_location));

            dev->dib.dib_slot.sl_slotid = DIB_SLOT_PCI(pci_info.slot);
            dev->dib.dib_slot.sl_minor = 0;
            dev->dib.dib_slot.sl_pcmciaslot = 0;
            dev->dib.dib_slot.sl_mbz = 0;

            /* Initialise the device */
            if (!init_failed)
            {
                if (em_attach(dev) == 0)
                {
                    dev->initialised = true;
                    log_message(dev, "Device initialised successfully");

                    /* We now have the MAC address */
                    dev->dib.dib_address = dev->adapter.interface_data.ac_enaddr;

                    /* Get the bus info - the BSD code doesn't bother */
                    em_get_bus_info(&dev->adapter.hw);
                }
                else
                {
                    log_message(dev, "Device initialisation failed");
                }
            }

            /* Initialise the device statistics */
            em_ro_init_stats(dev);

            /* Add to linked list */
            if (prev == NULL)
            {
                device_list = dev;
            }
            else
            {
                prev->next = dev;
            }
            prev = dev;

            dev = NULL;
#ifdef NOMOBO
            }
#endif
        }
    }

    /* All done - free any leftover device structure */
    free (dev);
    dev = NULL;

    if (alloc_failed)
    {
        e = messages_make_error("NoStore", ENOMEM, NULL);
    }
    else if (ekcnt > 0)
    {
        /* Set Inet$EtherType as the DCI 4 spec says you have to */
        e = _kernel_setenv("Inet$EtherType", ether_type);

        /* Check whether the mbuf manager module is loaded yet */
        if (e == NULL && !managerstarted && mbuf_present())
        {
            /* Mbuf manager is loaded - initialise entry points */
            e = mbuf_open_session();

            if (e == NULL)
            {
                /* OK - set a callback to issue Service_DCIDriverStatus */
                callx_add_callback(callb_send_driverstatus, NULL);

                managerstarted = true;
            }
        }
    }
    else
    {
        /* If we failed to find any devices, ignore errors and exit */
        e = NULL;
    }

    if (e == NULL)
    {
        /* Start watchdog timer to execute every 1s */
        e = callx_add_callevery(100-1, timer_handler, NULL);
    }

    if (e != NULL)
    {
        /* If something went wrong, call the finalisation code to undo */
        /* everything we've done so far.                               */
        ek_quit(1, 0, pw);
    }

    return e;
}

/**************************************************************/
/* ek_quit()                                                  */
/*                                                            */
/* Module finalisation code.                                  */
/*                                                            */
/* Parameters: Finalisation entry R10 value;                  */
/*                                                            */
/*             Finalisation entry R11 value;                  */
/*                                                            */
/*             Module workspace pointer.                      */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

_kernel_oserror * ek_quit(int fatal, int podule, void * pw)
{
    device_t    dev, next;

    (void)fatal;
    (void)podule;
    (void)pw;

    finalising = true;

    /* Remove calleverys and callbacks */
    callx_remove_all_calleverys();
    callx_remove_all_callbacks();
    timer_callb_set = false;

    /* Stop all units and free their data */
    for (dev = device_list; dev; dev = next)
    {
        /* Send the DCI service call to say the driver is dying */
        if (managerstarted) send_driverstatus(&dev->dib, DCIDRIVER_DYING);

        /* Shutdown the device, release interrupt etc. */
        if (dev->initialised) em_detach(dev);

        next = dev->next;

        if (
            dev->dib.dib_location != (unsigned char *)location_unknown &&
            dev->dib.dib_location != (unsigned char *)location_motherboard
           )
        {
            free(dev->dib.dib_location);
        }

        free(dev);
    }

    /* Finish session with mbuf manager, ignore any errors (they don't */
    /* mean much, since the session *may* still be closed, despite any */
    /* errors returned.)                                               */
    if (managerstarted) mbuf_close_session();

    /* Close message file etc. */
    messages_quit();

    return NULL;
}

/**************************************************************/
/* ek_sc_handler()                                            */
/*                                                            */
/* Module Service Call handler.                               */
/*                                                            */
/* Parameters: Service Call number;                           */
/*                                                            */
/*             Pointer to register block;                     */
/*                                                            */
/*             Module workspace pointer.                      */
/**************************************************************/

void ek_sc_handler(int sn, _kernel_swi_regs *r, void *pw)
{
    (void)pw;
    
    switch (sn)
    {
        case Service_MbufManagerStatus:
            handle_managerstatus(r);
            break;

        case Service_PreReset:
            /* Stop/reset all devices. Note that this will also free the PCI */
            /* memory by calling PCI_RAMFree. Is this safe? !!!TODO!!!       */
            /* 20041029: Its safer to reset the hardware on Service_PreReset.*/
            /* failure to do so results in stalled booting in response to a  */
            /* soft reset or OS_Reset                                        */
            for (device_t dev = device_list; dev; dev = dev->next)
            {
                if (dev->initialised) em_stop(&dev->adapter);
            }
            break;

        case Service_EnumerateNetworkDrivers:
            if (managerstarted)
            {
                for (device_t dev = device_list; dev; dev = dev->next)
                {
                    ChDibRef chd;

                    chd = (ChDibRef)malloc(sizeof(*chd));
                    if (chd == NULL)
                    {
                        /* Failed to claim memory - return as much */
                        /* information as possible.                */
                        break;
                    }

                    chd->chd_dib = &dev->dib;
                    chd->chd_next = (ChDibRef)r->r[0];
                    r->r[0] = (int)chd;
                }
            }
            break;

        case Service_DCIProtocolStatus:
            dprintf(("Service", "%s: Protocol '%s' (ver. %u) is %sing\n", __func__,
                (char *)r->r[4], r->r[3], r->r[2] ? "dy" : "start"));
            /* Ignore messages from a protocol module with a different */
            /* major version number.                                   */
            if (managerstarted && (r->r[3] / 100) == (DCIVERSION / 100))
            {
                /* Only interested in termination calls. */
                if (r->r[2] == DCIPROTOCOL_DYING) release_module_filters(r->r[0]);
            }
            break;

        case Service_TerritoryStarted:
            setlocale(LC_ALL, "");
            break;

        default:
            break;
    }
}

/**************************************************************/
/* ek_swi_handler()                                           */
/*                                                            */
/* Module SWI handler.                                        */
/*                                                            */
/* Parameters: SWI number (offset from base);                 */
/*                                                            */
/*             Pointer to register block;                     */
/*                                                            */
/*             Module workspace pointer.                      */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

_kernel_oserror * ek_swi_handler(int swinum, _kernel_swi_regs * r, void * pw)
{
    struct swient * callp;
    int             error;
    int             irqstate;

    (void)pw;

    /* We *assume* that, since service calls are not active until the mbuf */
    /* manager has been started, nobody can find out our SWI base, and     */
    /* therefore cannot raise any SWIs. If this is not true (i.e. someone  */
    /* looks up our particular SWI number, then they deserve all the       */
    /* trouble which they are probably likely to receive.                  */
    if (swinum >= (sizeof(ek_ent) / sizeof(ek_ent[0])))
    {
        return error_BAD_SWI;
    }

    /* Check that a correct unit number has been given for all SWIs other */
    /* than Version.                                                      */
    if (swinum != DCI4Version && r->r[1] >= ekcnt)
    {
        return messages_make_error("Err_BadUnit", ENXIO, NULL);
    }

    dprintf(("SWI", "SWI &%x called\n", swinum));

    callp = &ek_ent[swinum];
    irqstate = ensure_irqs_on();
    error = (*(callp->swi_call))(r);
    restore_irqs(irqstate);

    dprintf(("SWI", "SWI exit, error=%d\n", error));

    return messages_make_error("Err_SWI", error, "%d", error);
}

/**************************************************************/
/* ek_cli_handler()                                           */
/*                                                            */
/* Module command handler.                                    */
/*                                                            */
/* Parameters: Pointer to arguments string;                   */
/*                                                            */
/*             Number of arguments;                           */
/*                                                            */
/*             Command number;                                */
/*                                                            */
/*             Module workspace pointer.                      */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

_kernel_oserror * ek_cli_handler(const char * arg_string, int arg_count,
                                 int cmd_no, void * pw)
{
    _kernel_oserror * e = NULL;

    (void)pw;

    switch (cmd_no)
    {
        case CMD_EKInfo:
            /* *EKInfo */
            e = ek_cli_info(arg_string, arg_count);
            break;

        case CMD_EKTest:
            /* *EKTest */
            e = ek_cli_test(arg_string);
            break;

        case CMD_EKLog:
            /* *EKLog */
            e = ek_cli_log(arg_string, arg_count);
            break;

        case CMD_EKLink:
            /* *Configure EKLink */
            if (arg_string == arg_CONFIGURE_SYNTAX)
            {
                info_print(0, "CETKLNK", 0);
            }
            else if (arg_string == arg_STATUS)
            {
                e = ek_cli_link_status();
            }
            else
            {
                e = ek_cli_link(arg_string);
            }
            break;

        case CMD_EKAdvertise:
            /* *Configure EKAdvertise */
            if (arg_string == arg_CONFIGURE_SYNTAX)
            {
                info_print(0, "CETKADV", 0);
            }
            else if (arg_string == arg_STATUS)
            {
                e = ek_cli_advertise_status();
            }
            else
            {
                e = ek_cli_advertise(arg_string);
            }
            break;

        case CMD_EKFlowControl:
            /* *Configure EKFlowControl */
            if (arg_string == arg_CONFIGURE_SYNTAX)
            {
                info_print(0, "CETKFLW", 0);
            }
            else if (arg_string == arg_STATUS)
            {
                e = ek_cli_flow_status();
            }
            else
            {
                e = ek_cli_flow(arg_string);
            }
            break;
    }

    return e;
}
@


1.21
log
@Make use of readability defines from TCPIPLibs-5_55.

Version 0.24. Tagged as 'EtherK-0_24'
@
text
@d1307 2
d1316 9
a1324 2
    while (*arg_string == ' ')
        arg_string++;
d1327 1
a1327 1
    if (Strcmp_ci(arg_string, flow_param_none) == 0)
d1331 1
a1331 1
    else if (Strcmp_ci(arg_string, flow_param_respond) == 0)
d1335 1
a1335 1
    else if (Strcmp_ci(arg_string, flow_param_generate) == 0)
d1339 1
a1339 1
    else if (Strcmp_ci(arg_string, flow_param_full) == 0)
@


1.20
log
@Fix rom_link errors
Detail:
  c/ekmodule, c/em_riscos, c/info, c/log, c/msgs, c/test, h/em_riscos, h/msgs
  After the makefile rewrite the rom_link phase has started complaining about msgs_init and msgs_lookup being multiply defined (in EtherK & clib)
  I'm not sure how the original makefile sidestepped the issue, but a simple search and replace of msgs_ -> messages_ fixes the issue
Admin:
  rom_link phase now completes without errors
  Module not tested at runtime


Version 0.23. Tagged as 'EtherK-0_23'
@
text
@d323 1
a323 1
        send_driverstatus(&dev->dib, 0);
d1596 1
a1596 1
            dev->dib.dib_slot.sl_slotid = 16 + pci_info.slot;
d1725 1
a1725 1
        if (managerstarted) send_driverstatus(&dev->dib, 1);
d1818 1
a1818 1
                if (r->r[2] == 1) release_module_filters(r->r[0]);
@


1.19
log
@  Allow MTU to be set to less than 1500 bytes.
Detail:
  The handlers for the SetNetworkMTU and GetNetworkMTU SWIs now allow an
  MTU less than 1500 bytes to be specified. Note that specifying a smaller
  MTU doesn't affect the operation of the driver in any way.
  Also update the minimum version number in the AutoSense file to 0.19.
  Versions prior to this had an interrupt hole, so this is the correct
  minimum version that should be used.
Admin:
  Confirmed that 'ifconfig' can set the MTU and reports it correctly.


Version 0.20. Tagged as 'EtherK-0_20'
@
text
@d761 1
a761 1
        return msgs_make_error("Err_NoUnits", ENXIO, NULL);
d775 1
a775 1
        return msgs_make_error("Err_BadUnit", ENXIO, NULL);
d813 1
a813 1
            return msgs_make_error("SETKINF", ErrorNumber_Syntax, NULL);
d945 1
a945 1
        return msgs_make_error("SETKLNK", ErrorNumber_Syntax, NULL);
d1040 1
a1040 1
        return msgs_make_error("SETKLNK", ErrorNumber_Syntax, NULL);
d1182 1
a1182 1
        return msgs_make_error("SETKADV", ErrorNumber_Syntax, NULL);
d1248 1
a1248 1
        return msgs_make_error("SETKADV", ErrorNumber_Syntax, NULL);
d1336 1
a1336 1
        return msgs_make_error("SETKFLW", ErrorNumber_Syntax, NULL);
d1447 1
a1447 1
    e = msgs_init();
d1648 1
a1648 1
        e = msgs_make_error("NoStore", ENOMEM, NULL);
d1749 1
a1749 1
    msgs_quit();
d1867 1
a1867 1
        return msgs_make_error("Err_BadUnit", ENXIO, NULL);
d1879 1
a1879 1
    return msgs_make_error("Err_SWI", error, "%d", error);
@


1.18
log
@  Fix a potential hole in em_disable_intr()
Detail:
  if_em.c - Add E1000_WRITE_FLUSH after clearing the interrupt mask bits
  in em_disable_intr(). The lack of this could potentially leave a small
  window of time in which interrupts were enabled and the Ethernet
  controller was capable of generating a new interrupt while already
  in the interrupt handler - something the code assumes cannot happen.
  If this did happen the interrupt handler to be re-entered and ignore
  the interrupt, which would lead to the interrupt line being disabled
  and Ethernet packet reception would stop (as would anything else
  sharing the same interrupt line).

  ekmodule.c - Tidy up a bit by merging multiple calls to PCI_ReadInfo
  during ek_initialise() into a single one.

  Makefile - Add a dependency for EKHdr.h on the CMHG file.
Admin:
  Confirmed working but not thoroughly tested.


Version 0.19. Tagged as 'EtherK-0_19'
@
text
@d459 3
d463 15
a477 1
        return EINVAL;
d479 1
a479 3
    r->r[2] = ETHERMTU;

    return 0;
d494 32
a525 3
    (void)r;
    
    return ENOTTY;
@


1.17
log
@	fine tuning of no motherboard version, including AutoSense
Detail:
	Autosense file now has line that can be set to FALSE so that it
	will not offer the motherboard interface. To be used in conjunction
	with the 'no motherboard' version of EtherK.
Admin:
	verified at castle .. castle added IP


Version 0.18. Tagged as 'EtherK-0_18'
@
text
@a1366 1
    uint32_t            slot;
d1369 12
d1444 8
a1451 8
        /* Read the PCI device ID */
        e = _swix(PCI_ReadID,
            _IN(3) | _OUTR(0,1),

            fh,

            &dev->pci_id,
            &dev->pci_sub_id);
d1455 2
a1456 1
            dprintf(("", "%s: PCI_ReadID for function handle %d failed: '%s'\n", __func__, fh, e->errmess));
d1460 4
d1470 2
a1472 1
            int ans[2];
d1474 1
a1474 8
            /* Get the PCI bus/device number */
            e = _swix(PCI_ReadInfo,
                      _INR(0,3),

                      PCI_ReadInfo_DevFn + PCI_ReadInfo_Bus,
                      &ans[0],
                      sizeof(ans),
                      fh);
d1477 1
a1477 1
            if (!((ans[0] == 0x20) && (ans[1] == 0))) // ignore motherboard device
a1499 18
            /* Get the Device Vector number */
            e = _swix(PCI_ReadInfo,
                      _INR(0,3),

                      PCI_ReadInfo_IntDeviceVector,
                      &dev->device_vector,
                      sizeof(dev->device_vector),
                      fh);

            if (e != NULL)
            {
                /* Something went wrong */
                log_message(dev, "PCI_ReadInfo (device vector) for function handle %u failed: '%s'", fh, e->errmess);
                init_failed = true;
            }

            dprintf(("Init", "%s: Device vector is %d\n", __func__, dev->device_vector));

d1503 1
a1503 16
            /* Get the PCI slot number */
            e = _swix(PCI_ReadInfo,
                      _INR(0,3),

                      PCI_ReadInfo_Slot,
                      &slot,
                      sizeof(slot),
                      fh);

            if (e != NULL)
            {
                /* Something went wrong - we don't know what slot this is in */
                dprintf(("Init", "%s: PCI_ReadInfo (slot) for function handle %u failed: '%s'\n", __func__, fh, e->errmess));
                dev->dib.dib_location = (unsigned char *)location_unknown;
            }
            else if ((ans[0] == 0x20) && (ans[1] == 0)) //
d1511 2
a1512 2
                /* Slot 0 (motherboard) is a special case. There is no */
                /* EEPROM, so set up the fake EEPROM data now.         */
d1544 1
a1544 1
                if (slot > 99 || (dev->dib.dib_location = malloc(sizeof(location_string))) == NULL)
d1547 1
a1547 1
                    sprintf((char *)dev->dib.dib_location, location_string, slot);
d1552 1
a1552 1
            dev->dib.dib_slot.sl_slotid = 16 + slot;
@


1.16
log
@	changed 'no motherboard' detection method following discussion with James
Detail:
	Now detects the motherboard by selecting the required Bus/Dev/Fn setting
	for the motherboard device. This allows the same chip type to be used on
	plugged in PCI cards
Admin:	tested at Castle.. does as expected. Castle added IP


Version 0.17. Tagged as 'EtherK-0_17'
@
text
@d1465 1
d1467 2
a1468 1
            if ((ans[0] == 0x20) && (ans[1] == 0)) break; // ignore motherboard device
d1615 3
@


1.15
log
@        (re-)instated handler for Service_PreReset.
Detail:
        RISC OS 5.07 was suffering frequent stalled boots. Traced to EtherK
        hardware being left active across a soft reset since the CMHG link
        to Service_PreReset had been omitted - presumably in error. Comments
        in c.ekmodule suggested a concern whether freeing PCI RAM was wise
        here.. reboot is MUCH more repeatable if the i/f IS stopped before
        the OS_Reset occurs.
Admin:
        Castle added IP
        JB tested

Version 0.14. Tagged as 'EtherK-0_14'
@
text
@d1455 5
d1461 7
a1467 1
            dprintf(("Init", "%s: Function handle %d recognised by em_probe()\n", __func__, fh));
d1524 1
a1524 1
            else if (slot == 0)
@


1.14
log
@  Update BSD-derived code to version 1.7.35 of the FreeBSD driver sources.
  Rewrite and improve test code.
Detail:
  if_em.c, if_em_hw.c, if_em.h, if_em_hw.h and if_em_osdep.h have all
  been updated to version 1.7.35 of the FreeBSD sources. This version of
  the FreeBSD source tarball is now in the Original directory and earlier
  ones have been removed. The main effect of the changes is to add support
  for later Intel controllers. Note that workaround code required to
  support the 82544 when running on a PCIX bus, and to support the 82547EI
  has not been included to remove unnecessary complication. If support for
  these controllers is ever required (unlikely), this would need to be
  added back in.
  The test code has been rewritten and is now in a new file, test.c.
  Loopback code from the Linux driver is located in the loopback.c file
  and can optionally be compiled in by changing the #define at the top of
  test.c, but since this is GPL code it cannot be included in any
  distributed module. Also, although the test will work, it does not
  restore everything correctly so the link stays down afterwards until the
  module is reinitialised.
  AutoSense/EtherK has been updated to recognise all supported cards.
  doc/UserGuide has been updated.
Admin:
  Basic testing has been carried out, but more testing is required.
  Note that the updated AutoSense and UserGuide files need to be
  included in future distributions including this module.


Version 0.13. Tagged as 'EtherK-0_13'
@
text
@d1742 3
@


1.13
log
@  Restructure and tidy up.
Detail:
  This version has no functional changes, but has been considerably
  tidied up to improve commenting and modularity. In particular the
  information printing routines, filtering routines and message
  logging routines have been split out into separate source files.
  The filtering routines have also been re-worked to be more
  comprehensible. Hopefully this will provide a useful base for
  developing future network drivers.
Admin:
  Requires an up-to-date version of BuildSys to build all variants.
  Basic testing indicates it still works, but more long term testing
  to confirm that nothing has been accidentally broken is required.


Version 0.12. Tagged as 'EtherK-0_12'
@
text
@d826 1
a826 1
    e1000_diag_run(get_device(unit));
@


1.12
log
@Typo in token name in SETFLW resulted in an error message moaning it
couldn't be found in the messages file instead of a syntax message.
Made sure the configuration syntax messages don't get tokenised as they're
also used as error messages elsewhere.

Version 0.11. Tagged as 'EtherK-0_11'
@
text
@d15 14
a28 11
/*
 * Name:        EtherK driver
 * Purpose:     DCI 4 driver for the Intel PRO/1000 Family of Adapters.
 *
 * Adapted from the Intel FreeBSD 'em' driver, which is why all the other
 * files refer to 'em' rather than 'ek' (the name 'EtherM' was already
 * taken.)
 *
 * The RISC OS driver bits were based on Ether1 and EtherI.
 *
 */
a33 1
#include <ctype.h>
a43 2
#include "mbuf.h"
#include "msgs.h"
d47 6
a52 2

#include "ekmodule.h"
d60 4
a93 6
/* Local functions */

static _kernel_oserror * timer_handler (_kernel_swi_regs * r, void * pw, void * handle);
static _kernel_oserror * callb_timer (_kernel_swi_regs * r, void * pw, void * handle);
static _kernel_oserror * callb_send_driverstatus (_kernel_swi_regs * r, void * pw, void * handle);

d110 2
a111 2
static char         location_unknown[] = "Unknown";
static char         location_motherboard[] = "Motherboard";
d113 3
a115 3
static char         short_name[] = "ek";
static char         ether_type[] = "ek0";
static char         module_name[] = Module_Title;
a128 48
/*
 * Strcmp_ci()
 *
 * Compare two strings case insensitively
 *
 * Parameters: matches those of strcmp.
 * Result: matches the exit conditions of strcmp.
 *
 * The conversions to unsigned int stop the compiler messing around with
 * shifts all over the place whilst trying to promote the chars to int
 * whilst retaining the sign.
 *
 * Problems: Choice of return value when strings do not match is based
 *           upon character number rather than any alphabetic sorting.
 *
 */

static int Strcmp_ci(const char *first, const char *second)
{
    for (;;)
    {
        unsigned int a = *first++;
        unsigned int b = *second++;

        if (a == 0)
            return -b;
        if (a != b)
        {
            unsigned int c = (unsigned int) tolower(a);
            unsigned int d = (unsigned int) tolower(b);
            signed int result = c - d;
            if (result != 0)
                return result;
        }
    }
}

/**********************************************************************/

static void panic(char *s)
{
    device_t dev;

    for (dev = device_list; dev; dev = dev->next)
    {
        em_ro_log_message(dev, "Panic: %s", s);
    }
}
d130 10
a139 1
/**********************************************************************/
a151 1
/**********************************************************************/
d153 23
a175 5
/*
 * check_addrlevel - check that address level for a filter SWI
 * is valid. returns 1 if valid, else 0.
 */
static int check_addrlevel(uint32_t level)
d177 2
a178 5
    if ((int)level < ADDRLVL_SPECIFIC || (int)level > ADDRLVL_PROMISCUOUS)
        return 0;
    else
        return 1;
}
d180 3
a182 1
/**********************************************************************/
d184 3
a186 52
/*
 * send_frametypefree - raise a service call to let protocol modules
 * know that a given frame type has been freed
 */
static void send_frametypefree(device_t dev, u_int type, FilterSingleRef fs)
{
    _swix(OS_ServiceCall,
          _INR(0,4),

          &dev->dib,
          Service_DCIFrameTypeFree,
          type,
          fs->fs_addrlevel,
          fs->fs_errlevel);
}

/**********************************************************************/

/*
 * undo_chainfilter - stop filtering on a filter level that
 * chains multiple frame types if the recipient protocol module
 * has a private word pointer that matches the one given
 */
static void undo_chainfilter(device_t dev, u_int pwp, u_int level,
                             FilterChainRef *fcrptr)
{
    FilterChainRef *fcprev = fcrptr;
    FilterChainRef fc = *fcrptr;

    while (fc)
    {
        if (fc->fc_pwptr == pwp)
        {
            u_int ftype = 0;
            SET_FRAMETYPE(ftype, fc->fc_type);
            SET_FRAMELEVEL(ftype, level);

            /*
             * Unchain this entry, send service call
             * indicating it is free, and free it
             */
            *fcprev = fc->fc_next;
            send_frametypefree(dev, ftype, &(fc->fc_filter));
            free(fc);

            /*
             * Previous entry is the same,
             * advance the current pointer
             */
            fc = *fcprev;
        }
        else
d188 2
a189 5
            /*
             * move both pointers down the list
             */
            fc = fc->fc_next;
            fcprev = (FilterChainRef *)(*fcprev);
d192 5
d199 13
a211 1
/**********************************************************************/
d213 1
a213 7
/*
 * undo_singlefilter - stop filtering on a filter level that does
 * not chain multiple frame types iff the recipient protocol module
 * has a private word pointer that matches the one given
 */
static void undo_singlefilter(device_t dev, u_int pwp, u_int level,
                              FilterSingleRef *fsrptr)
d215 2
a216 1
    FilterSingleRef fs = *fsrptr;
d218 3
a220 14
    if (fs && fs->fs_pwptr == pwp)
    {
        /*
         * We have a match - send a service call round
         * to let protocol modules know about new claims
         * available.
         */
        u_int ftype = 0;
        SET_FRAMELEVEL(ftype, level);
        send_frametypefree(dev, ftype, fs);
        free(fs);
        *fsrptr = NULL;
    }
}
d222 1
a222 1
/**********************************************************************/
d224 1
a224 9
/*
 * filtersoff - disable filtering for the module
 * with the given private word pointer.
 */
static void filtersoff(u_int pwp)
{
    device_t    dev;

    /* Loop over all active units looking for the module */
d227 7
a233 10
        /* Start with the chained filter level */
        undo_chainfilter(dev, pwp, FRMLVL_E2SPECIFIC, &dev->e2specific);

        /* Now the unique filter levels */
        undo_singlefilter(dev, pwp, FRMLVL_E2SINK,    &dev->e2sink);
        undo_singlefilter(dev, pwp, FRMLVL_E2MONITOR, &dev->e2monitor);
        undo_singlefilter(dev, pwp, FRMLVL_IEEE,      &dev->ieeefilter);

        /* Check whether receiver can be disabled */
        em_ro_update_addrlevel(dev);
a234 1
}
d236 2
a237 58
/**********************************************************************/

/*
 * do_chainfilter - handle a claim or release on a
 * filter level that chains multiple frame types.
 */
static int do_chainfilter(_kernel_swi_regs *r,
                          FilterChainRef *fcrptr,
                          FilterSingleRef *antagonist)
{
    FilterChainRef  fc, *fcprev;
    device_t        dev = get_device(r->r[1]);

    /*
     * Search down the FilterChain, looking for this frametype
     */
    for( fcprev = fcrptr, fc = *fcrptr;
        fc && fc->fc_type != GET_FRAMETYPE(r->r[2]);
        fc = fc->fc_next, fcprev = (FilterChainRef *)*fcprev )
        /* do nothing */
        ;

    dprintf (("Misc", "do_chainfilter(%x, %x): fcrptr = %p, fc = %p\n",
           r->r[0], r->r[2], fcrptr, fc));

    /*
     * Is this a claim or a release?
     */
    if( r->r[0] & FILTER_RELEASE )
    {
        if (!fc)
            /*
             * Trying to free a non-existent claim
             */
            return EINVAL;

        if( fc->fc_handler != (void (*)())r->r[6] || fc->fc_pwptr != r->r[5] )
            /*
             * Trying to release somebody else's claim
             */
            return EPERM;

        dprintf(("Misc", "%s: Releasing claim on frame type %x (fcprev = %p)\n", __func__,
               GET_FRAMETYPE(r->r[2]), *fcprev));

        /*
         * OK, this is a legitimate free, do it
         */
        *fcprev = fc->fc_next;
        send_frametypefree(dev, r->r[2], &(fc->fc_filter));
        free(fc);

        /*
         * Check whether receiver can be disabled
         */
        em_ro_update_addrlevel(dev);
    }
    else
d239 3
a241 43
        int error;

        /*
         * Claiming
         */
        if (fc || *antagonist)
        {
            /*
             * This frame type is already claimed in some fashion,
             * check that this is not an erroneous reclaim
             */
            if (
                dev->dupclaimexpected &&
                fc &&
                fc->fc_type == GET_FRAMETYPE(r->r[2]) &&
                fc->fc_addrlevel == r->r[3] &&
                fc->fc_errlevel == r->r[4] &&
                fc->fc_handler == (void (*)())r->r[6] &&
                fc->fc_pwptr == r->r[5]
               )
            {
                /*
                 * It is a legitimate reclaim - need to check that
                 * we can bring the card up live once again.
                 */
                if( (error = em_ro_start(dev)) != 0 )
                    /*
                     * Return an error, but *do not* free the structure
                     */
                    return error;

                /*
                 * Set receive level for this unit to the
                 * loosest address filtering necessary.
                 */
                em_ro_update_addrlevel(dev);

                return 0;
            }
            else
            {
                return INETERR_FILTERGONE;
            }
a242 39

        dprintf(("Misc", "%s: Claiming frame type %x (fcprev = %p)\n", __func__,
               GET_FRAMETYPE(r->r[2]), *fcprev));

        if ((fc = (FilterChainRef)malloc(sizeof(*fc))) == NULL)
            /*
             * Cannot claim memory for this structure
             */
            return ENOMEM;

        /*
         * Check that we can bring the card up live
         */
        if ((error = em_ro_start(dev)) != 0)
        {
            free(fc);
            return error;
        }

        /*
         * Fill out the fields
         */
        fc->fc_type      = GET_FRAMETYPE(r->r[2]);
        fc->fc_addrlevel = r->r[3];
        fc->fc_errlevel  = r->r[4];
        fc->fc_handler   = (void (*)())r->r[6];
        fc->fc_pwptr     = r->r[5];

        /*
         * Chain this structure onto the list
         */
        fc->fc_next = *fcprev;
        *fcprev = fc;

        /*
         * Set receive level for this unit to the
         * loosest address filtering necessary.
         */
        em_ro_update_addrlevel(dev);
d245 1
a245 1
    return 0;
a247 1
/**********************************************************************/
d249 4
a252 43
/*
 * do_singlefilter - handle a claim or release on a filter level
 * that does not chain multiple frame types.
 */
static int do_singlefilter(_kernel_swi_regs *r,
                           FilterSingleRef *level,
                           FilterSingleRef *antagonist)
{
    FilterSingleRef fs = *level;
    device_t        dev = get_device(r->r[1]);

    /*
     * Check whether claiming or releasing
     */
    if (r->r[0] & FILTER_RELEASE)
    {
        if (!fs)
            /*
             * Trying to free a non-existent claim
             */
            return EINVAL;

        if (fs->fs_handler != (void (*)())r->r[6] || fs->fs_pwptr != r->r[5])
            /*
             * Trying to release somebody else's claim
             */
            return EPERM;

        /*
         * Everything checks out, do the free
         */
        send_frametypefree(dev, r->r[2], fs);
        free(fs);
        *level = NULL;

        /*
         * Check whether receiver can be disabled
         */
        em_ro_update_addrlevel(dev);
    }
    else
    {
        int error;
d254 7
a260 33
        /*
         * It's a claim - most values have been range checked, but
         * take a look at frame type (which *must* be zero)
         */
        if (GET_FRAMETYPE(r->r[2]) != 0)
            return EINVAL;

        if (fs || *antagonist)
        {
            if (
                dev->dupclaimexpected &&
                fs &&
                fs->fs_addrlevel == r->r[3] &&
                fs->fs_errlevel == r->r[4] &&
                fs->fs_handler == (void (*)())r->r[6] &&
                fs->fs_pwptr == r->r[5]
               )
            {
                /*
                 * It is a legitimate reclaim - need to check that
                 * we can bring the card up live once again.
                 */
                if ((error = em_ro_start(dev)) != 0)
                    /*
                     * Return an error, but *do not* free the structure
                     */
                    return error;

                /*
                 * Set receive level for this unit to the
                 * loosest address filtering necessary.
                 */
                em_ro_update_addrlevel(dev);
d262 3
a264 10
                return 0;
            }
            else
            {
                /*
                 * This frame level is already claimed in some fashion
                 */
                return INETERR_FILTERGONE;
            }
        }
d266 3
a268 30
        if ((fs = (FilterSingleRef)malloc(sizeof(*fs))) == NULL)
            /*
             * Cannot claim memory for this structure
             */
            return ENOMEM;

        /*
         * Check that we can bring the card up live
         */
        if ((error = em_ro_start(dev)) != 0)
        {
            free(fs);
            return error;
        }

        /*
         * Everything checks out OK, initialise the structure
         */
        fs->fs_addrlevel = r->r[3];
        fs->fs_errlevel  = r->r[4];
        fs->fs_handler   = (void (*)())r->r[6];
        fs->fs_pwptr     = r->r[5];

        *level = fs;

        /*
         * Set receive level for this unit to the
         * loosest address filtering necessary.
         */
        em_ro_update_addrlevel(dev);
a269 2

    return 0;
d272 10
a281 1
/**********************************************************************/
a282 4
/*
 * send_driverstatus - send a DCIDriverStatus service
 * call for given dib
 */
d297 15
a311 1
/**********************************************************************/
a312 4
/*
 * callb_send_driverstatus - handler for callback primed by initialisation
 * routine: send round DCIDriverStatus service call for all units
 */
d329 7
a335 1
/**********************************************************************/
d337 1
a337 4
/*
 * timer_handler - handler for callevery timer called once a second.
 */
static _kernel_oserror * timer_handler(_kernel_swi_regs * r, void * pw, void * handle)
d339 15
a353 2
    device_t dev;
    uint32_t now;
d355 1
a355 3
    (void)r;
    (void)pw;
    (void)handle;
d357 8
a364 1
    _swix(OS_ReadMonotonicTime, _OUT(0), &now);
d366 4
a369 11
    /* Do the watchdog check for each unit */
    for (dev = device_list; dev; dev = dev->next)
    {
        if (
            dev->initialised &&
            (dev->adapter.interface_data.ac_if.if_flags & IFF_RUNNING) != 0
           )
        {
            em_ro_watchdog(dev, now);
        }
    }
d371 2
a372 7
    /* Schedule a callback to call em_local_timer */
    if (!timer_callb_set)
    {
        if (callx_add_callback(callb_timer, NULL) == NULL)
        {
            timer_callb_set = true;
        }
a373 2

    return NULL;
d376 8
a383 1
/**********************************************************************/
d385 1
a385 7
/*
 * callb_timer - handler for callback set by timer_handler() above
 * every second. Execute em_local_timer() for alternately all odd numbered
 * units, then all even numbered ones. This means that each unit has the
 * routine called every 2 seconds.
 */
static _kernel_oserror * callb_timer(_kernel_swi_regs * r, void * pw, void * handle)
d387 1
a387 6
    static unsigned int which = 0;
    device_t            dev;

    (void)r;
    (void)pw;
    (void)handle;
d389 1
d392 1
a392 5
        if (dev->localtimerset && (dev->dib.dib_unit & 1) == which)
        {
            dprintf(("Timer", "%s: Calling em_local_timer() for unit %u\n", __func__, dev->dib.dib_unit));
            em_local_timer(&dev->adapter);
        }
d394 22
d417 1
a417 2
    which ^= 1;
    timer_callb_set = false;
d419 1
a419 1
    return NULL;
d422 9
a430 1
/**********************************************************************/
d432 1
a432 4
/*
 * Module Initialisation code.
 */
_kernel_oserror * ek_initialise(const char *cmd_tail, int podule_base, void *pw)
d434 1
a434 11
    _kernel_oserror *   e;
    uint32_t            num_handles;
    uint32_t            fh;
    device_t            dev = NULL;
    device_t            prev = NULL;
    uint32_t            slot;
    bool                alloc_failed = false;
    bool                init_failed;
#ifdef NOPCI_HACK
    bool                HACK = false;
#endif
d436 2
a437 2
    (void)cmd_tail;
    (void)podule_base;
d439 2
a440 1
    module_wsp = pw;
d442 1
a442 7
    /* Initialise DebugLib */
    debug_initialise("EtherK", "null:", NULL);
    debug_set_taskname_prefix(false);
    debug_set_stamp_debug(true);
    debug_set_device(DADEBUG_OUTPUT);
    debug_set_raw_device(NULL_OUTPUT);
    debug_set_trace_device(NULL_OUTPUT);
d444 2
a445 2
    /* Initalise callx */
    callx_init(pw);
d447 9
a455 3
#ifdef DBG_STATS
    em_ro_init_dbg_stats();
#endif
d457 4
a460 4
    /* Initialise messages */
    e = msgs_init();
    if (e != NULL)
        return e;
d462 1
a462 2
    /* Initialise locale for printing formatted numbers */
    setlocale(LC_ALL, "");
d464 2
a465 2
    /* Initialise the supported statistics structure */
    em_ro_init_supported_stats(&supported_stats);
d467 9
a475 1
    /* Look for devices we can drive */
d477 6
a482 2
    e = _swix(PCI_ReturnNumber,
              _OUT(0),
d484 9
a492 1
              &num_handles);
d494 9
a502 9
    if (e != NULL)
    {
        dprintf(("", "%s: PCI_ReturnNumber failed: '%s'\n", __func__, e->errmess));
        num_handles = 0;
#ifdef NOPCI_HACK
        num_handles = 1;
        HACK = true;
#endif
    }
d504 2
a505 1
    dprintf(("Init", "%s: PCI_ReturnNumber reports %d function handles\n", __func__, num_handles));
d507 1
a507 1
    for (fh = 1; fh <= num_handles; fh++)
d509 16
a524 2
        /* Make sure we have a device structure to fill in */
        if (dev == NULL)
d526 14
a539 2
            dev = calloc(1, sizeof(struct device));
            if (dev == NULL)
d541 1
a541 2
                alloc_failed = true;
                break;
d544 5
d550 6
a555 2
        dev->module_wsp = pw;
        dev->function_handle = fh;
d557 6
a562 3
        /* Read the PCI device ID */
        e = _swix(PCI_ReadID,
            _IN(3) | _OUTR(0,1),
d564 2
a565 1
            fh,
d567 5
a571 2
            &dev->pci_id,
            &dev->pci_sub_id);
d573 1
a573 5
#ifdef NOPCI_HACK
        if (e != NULL && !HACK)
#else
        if (e != NULL)
#endif
d575 3
a577 2
            dprintf(("", "%s: PCI_ReadID for function handle %d failed: '%s'\n", __func__, fh, e->errmess));
            continue;
d579 1
d581 2
a582 2
        dprintf(("Init", "%s: Function handle %d has vendor ID %04x, device ID %04x, subsystem vendor ID %04x, subsystem ID %04x\n",
             __func__, fh, (dev->pci_id & 0xffff), (dev->pci_id >> 16), (dev->pci_sub_id & 0xffff), (dev->pci_sub_id >> 16)));
d584 9
a592 8
        /* Ask the driver whether it recognises this device */
#ifdef NOPCI_HACK
        if (em_probe(dev) == 0 || HACK)
#else
        if (em_probe(dev) == 0)
#endif
        {
            init_failed = false;
d594 3
a596 1
            dprintf(("Init", "%s: Function handle %d recognised by em_probe()\n", __func__, fh));
d598 3
a600 1
            em_ro_log_message(dev, "Initialising device");
d602 10
a611 2
            /* Increment the global count of the number of units */
            ekcnt++;
d613 2
a614 2
            /* Initialise the address filter function pointer */
            dev->address_filter = af_reject;
d616 2
a617 10
            /* Fill in the Device Information Block */
            dev->dib.dib_swibase = EtherK_00;
            dev->dib.dib_name = (unsigned char *)short_name;
            dev->dib.dib_unit = ekcnt - 1;
            /* dev->dib.dib_address is set after em_attach() */
            dev->dib.dib_module = (unsigned char *)module_name;
            dev->dib.dib_inquire = (INQ_MULTICAST | INQ_PROMISCUOUS |
                                INQ_HWADDRVALID | INQ_SOFTHWADDR |
                                INQ_HASSTATS /*| INQ_HW_MULTICAST*/ );
            /* !!!TODO!!! - get the flags right */
d619 2
a620 3
            /* Get the Device Vector number */
            e = _swix(PCI_ReadInfo,
                      _INR(0,3),
d622 9
a630 4
                      PCI_ReadInfo_IntDeviceVector,
                      &dev->device_vector,
                      sizeof(dev->device_vector),
                      fh);
d632 3
a634 6
            if (e != NULL)
            {
                /* Something went wrong */
                em_ro_log_message(dev, "PCI_ReadInfo (device vector) for function handle %u failed: '%s'", fh, e->errmess);
                init_failed = true;
            }
d636 5
a640 1
            dprintf(("Init", "%s: Device vector is %d\n", __func__, dev->device_vector));
d642 3
a644 2
            /* Read the NVRAM configuration settings */
            em_ro_read_configuration(dev);
d646 3
a648 3
            /* Get the PCI slot number */
            e = _swix(PCI_ReadInfo,
                      _INR(0,3),
d650 2
a651 4
                      PCI_ReadInfo_Slot,
                      &slot,
                      sizeof(slot),
                      fh);
d653 6
a658 1
            if (e != NULL)
d660 1
a660 3
                /* Something went wrong - we don't know what slot this is in */
                dprintf(("Init", "%s: PCI_ReadInfo (slot) for function handle %u failed: '%s'\n", __func__, fh, e->errmess));
                dev->dib.dib_location = (unsigned char *)location_unknown;
d662 2
a663 3
            else if (slot == 0)
            {
                char    mac[8];
d665 4
a668 1
                /* This device is on the motherboard */
a669 1
                dev->dib.dib_location = (unsigned char *)location_motherboard;
d671 2
a672 2
                /* Slot 0 (motherboard) is a special case. There is no */
                /* EEPROM, so set up the fake EEPROM data now.         */
d674 9
a682 1
                dev->no_eeprom = true;
d684 8
a691 3
                /* Read the MAC address */
                e = _swix(PCI_ReadInfo,
                          _INR(0,3),
a692 4
                          PCI_ReadInfo_EthernetAddress,
                          mac,
                          sizeof(mac),
                          fh);
d694 17
a710 3
                if (e == NULL)
                {
                    int i;
d712 3
a714 8
                    /* Bung the MAC address directly into the driver's */
                    /* hardware structure.                             */
                    for(i = 0; i < NODE_ADDRESS_SIZE; i++)
                        dev->adapter.hw.mac_addr[i] = dev->adapter.hw.perm_mac_addr[i] = mac[5-i];
                }
                else
                {
                    em_ro_log_message(dev, "Failed to read MAC address for motherboard Ethernet controller (function handle %u, error: '%s')", fh, e->errmess);
d716 2
a717 11
                    /* No MAC address, so this device can't be initialised */
                    init_failed = true;
                }
            }
            else
            {
                if (slot > 99 || (dev->dib.dib_location = malloc(sizeof(location_string))) == NULL)
                    dev->dib.dib_location = (unsigned char *)location_unknown;
                else
                    sprintf((char *)dev->dib.dib_location, location_string, slot);
            }
d719 3
a721 1
            dprintf(("Init", "%s: Location of device for function handle %u is '%s'\n", __func__, fh, dev->dib.dib_location));
d723 3
a725 4
            dev->dib.dib_slot.sl_slotid = 16 + slot;
            dev->dib.dib_slot.sl_minor = 0;
            dev->dib.dib_slot.sl_pcmciaslot = 0;
            dev->dib.dib_slot.sl_mbz = 0;
d727 2
a728 7
            /* Initialise the device */
            if (!init_failed)
            {
                if (em_attach(dev) == 0)
                {
                    dev->initialised = true;
                    em_ro_log_message(dev, "Device initialised successfully");
d730 2
a731 2
                    /* We now have the MAC address */
                    dev->dib.dib_address = dev->adapter.interface_data.ac_enaddr;
d733 2
a734 8
                    /* Get the bus info - the BSD code doesn't bother */
                    em_get_bus_info(&dev->adapter.hw);
                }
                else
                {
                    em_ro_log_message(dev, "Device initialisation failed");
                }
            }
d736 11
a746 2
            /* Initialise the device statistics */
            em_ro_init_stats(dev);
d748 3
a750 10
            /* Add to linked list */
            if (prev == NULL)
            {
                device_list = dev;
            }
            else
            {
                prev->next = dev;
            }
            prev = dev;
d752 26
a777 1
            dev = NULL;
d781 1
a781 9
    /* All done - free any leftover device structure */
    free (dev);
    dev = NULL;

    if (alloc_failed)
    {
        e = msgs_make_error("NoStore", ENOMEM, NULL);
    }
    else if (ekcnt > 0)
d783 2
a784 2
        /* Set Inet$EtherType as the DCI 4 spec says you have to */
        e = _kernel_setenv("Inet$EtherType", ether_type);
d786 5
a790 2
        /* Check whether the mbuf manager module is loaded yet */
        if (e == NULL && !managerstarted && mb_present())
d792 2
a793 4
            /* Mbuf manager is loaded - initialise entry points */
            e = mb_entryinit();

            if (e == NULL)
d795 1
a795 4
                /* OK - set a callback to issue Service_DCIDriverStatus */
                callx_add_callback(callb_send_driverstatus, NULL);

                managerstarted = true;
d801 1
a801 15
        /* If we failed to find any devices, ignore errors and exit */
        e = NULL;
    }

    if (e == NULL)
    {
        /* Start watchdog timer to execute every 1s */
        e = callx_add_callevery(100-1, timer_handler, NULL);
    }

    if (e != NULL)
    {
        /* If something went wrong, call the finalisation code to undo */
        /* everything we've done so far.                               */
        ek_quit(1, 0, pw);
d807 9
a815 1
/**********************************************************************/
d817 1
a817 4
/*
 * Module Finalisation code
 */
_kernel_oserror * ek_quit(int fatal, int podule, void *pw)
d819 6
a824 1
    device_t    dev, next;
d826 3
a828 3
    (void)fatal;
    (void)podule;
    (void)pw;
d830 11
a840 1
    finalising = true;
d842 4
a845 4
    /* Remove calleverys and callbacks */
    callx_remove_all_calleverys();
    callx_remove_all_callbacks();
    timer_callb_set = false;
d847 7
a853 2
    /* Stop all units and free their data */
    for (dev = device_list; dev; dev = next)
d855 10
a864 3
        /* Send the DCI service call to say the driver is dying */
        if (managerstarted)
            send_driverstatus(&dev->dib, 1);
d866 9
a874 3
        /* Shutdown the device, release interrupt etc. */
        if ((bool)dev->initialised)
            em_detach(dev);
d876 13
a888 1
        next = dev->next;
d890 3
a892 5
        if (
            dev->dib.dib_location != (unsigned char *)location_unknown &&
            dev->dib.dib_location != (unsigned char *)location_motherboard
           )
            free(dev->dib.dib_location);
d894 5
a898 2
        free(dev);
    }
d900 2
a901 8
    /*
     * Finish session with mbuf manager, ignore any
     * errors (they don't mean much, since session
     * *may* still be closed, despite any errors
     * returned)
     */
    if (managerstarted)
        mb_closesession();
d903 2
a904 2
    /* Close message file etc. */
    msgs_quit();
d906 5
a910 2
    return NULL;
}
d912 4
a915 1
/**********************************************************************/
d917 8
a924 6
/*
 * handle_managerstatus - deal with a MbufManagerStatus service call
 */
static void handle_managerstatus(_kernel_swi_regs *r)
{
    switch (r->r[0])
d926 11
a936 3
      case MbufManagerStatus_Started:
        dprintf(("Service", "%s: MbufManagerStatus_Started\n", __func__));
        if (!managerstarted)
d938 10
a947 11
            /*
             * mbuf manager has appeared - initialise entry points
             */
            if (mb_entryinit() == NULL)
            {
                /*
                 * mbuf system initialised, set a callback
                 * to announce our presence
                 */
                managerstarted = true;
                callx_add_callback(callb_send_driverstatus, NULL);
d950 1
d952 23
a974 1
        break;
d976 18
a993 11
      case MbufManagerStatus_Stopping:
        dprintf(("Service", "%s: MbufManagerStatus_Stopping\n", __func__));
        /*
         * should only ever see this message if we are
         * finalising our own module, otherwise something
         * has gone terribly wrong (the mbuf manager should
         * only stop when all its clients have closed their
         * sessions)
         */
        if (!finalising)
            panic("Mbuf manager has stopped");
d995 2
a996 1
        break;
d998 1
a998 8
      case MbufManagerStatus_Scavenge:
        dprintf(("Service", "%s: MbufManagerStatus_Scavenge\n", __func__));
        /* do nothing */
        break;

      default:
        break;
    }
d1001 7
a1007 1
/**********************************************************************/
d1009 1
a1009 2
/* Module Service Call handler */
void ek_sc_handler(int sn, _kernel_swi_regs *r, void *pw)
d1011 3
a1013 3
    (void)pw;
    
    switch (sn)
d1015 5
a1019 3
        case Service_MbufManagerStatus:
            handle_managerstatus(r);
            break;
d1021 1
a1021 9
        case Service_PreReset:
            /* Stop/reset all devices. Note that this will also free the PCI */
            /* memory by calling PCI_RAMFree. Is this safe? !!!TODO!!!       */
            for (device_t dev = device_list; dev; dev = dev->next)
            {
                if ((bool)dev->initialised)
                    em_stop(&dev->adapter);
            }
            break;
d1023 5
a1027 6
        case Service_EnumerateNetworkDrivers:
            if (managerstarted)
            {
                for (device_t dev = device_list; dev; dev = dev->next)
                {
                    ChDibRef chd;
d1029 3
a1031 4
                    if ((chd = (ChDibRef)malloc(sizeof(*chd))) == NULL)
                        /* Failed to claim memory - return as much */
                        /* information as possible.                */
                        break;
d1033 4
a1036 6
                    chd->chd_dib = &dev->dib;
                    chd->chd_next = (ChDibRef)r->r[0];
                    r->r[0] = (int)chd;
                }
            }
            break;
d1038 4
a1041 12
        case Service_DCIProtocolStatus:
            dprintf(("Service", "%s: Protocol '%s' (ver. %u) is %sing\n", __func__,
                (char *)r->r[4], r->r[3], r->r[2] ? "dy" : "start"));
            /* Ignore messages from a protocol module with a different */
            /* major version number.                                   */
            if (managerstarted && (r->r[3] / 100) == (DCIVERSION / 100))
            {
                /* Only interested in termination calls. */
                if (r->r[2] == 1)
                    filtersoff(r->r[0]);
            }
            break;
d1043 4
a1046 3
        case Service_TerritoryStarted:
            setlocale(LC_ALL, "");
            break;
d1048 5
a1052 4
        default:
            break;
    }
}
d1054 9
a1062 1
/**********************************************************************/
d1064 5
a1068 4
static int ek_version(_kernel_swi_regs *r)
{
    if (r->r[0])
        return EINVAL;
d1070 10
a1079 3
    r->r[1] = DCIVERSION;

    return 0;
d1082 12
a1093 1
/**********************************************************************/
d1095 1
a1095 1
static int ek_inquire(_kernel_swi_regs *r)
d1097 2
a1098 2
    if (r->r[0])
        return EINVAL;
d1100 1
a1100 1
    r->r[2] = get_device(r->r[1])->dib.dib_inquire;
d1102 1
a1102 1
    return 0;
d1105 9
a1113 1
/**********************************************************************/
d1115 1
a1115 1
static int ek_getmtu(_kernel_swi_regs *r)
d1117 9
a1125 2
    if (r->r[0])
        return EINVAL;
d1127 3
a1129 1
    r->r[2] = ETHERMTU;
d1131 5
a1135 2
    return 0;
}
d1137 2
a1138 1
/**********************************************************************/
d1140 4
a1143 6
static int ek_setmtu(_kernel_swi_regs *r)
{
    (void)r;
    
    return ENOTTY;
}
d1145 10
a1154 16
/**********************************************************************/

static int ek_transmit(_kernel_swi_regs* r)
{
    uint32_t      flags = r->r[0];
    device_t      dev = get_device(r->r[1]);
    struct mbuf * m_head = (struct mbuf *)r->r[3];
    struct mbuf * m;
    uint8_t     * esrc;
    int           num_packets = 0;
    int           error = 0;

    dprintf(("SWI", "%s: unit=%d, flags=&%x, type=&%x, m_head=%p\n", __func__,
             r->r[1], flags, r->r[2], m_head));

    if (flags >= TX_1STRESERVED)
d1156 29
a1184 12
        error = EINVAL;
    }
    else if (!dev->initialised ||
             (dev->adapter.interface_data.ac_if.if_flags & IFF_RUNNING) == 0)
    {
        error = ENETDOWN;
    }
    else if (!dev->adapter.link_active)
    {
        /* Was initialisation started without waiting for auto-negotiation? */
        if (dev->adapter.hw.wait_autoneg_complete == 0 &&
            dev->adapter.init_start_time != 0)
d1186 5
a1190 17
            uint32_t now;

            /* Wait until the time out period has elapsed or the link comes up */
            dprintf(("TX", "Blocking for link up - "));
            do
            {
                _swix(OS_ReadMonotonicTime, _OUT(0), &now);
            } while (!dev->adapter.link_active && (now - dev->adapter.init_start_time) < (PHY_AUTO_NEG_TIME * 10));
            dprintf(("TX", "finished. Time diff=%u, link=%d\n", now - dev->adapter.init_start_time, dev->adapter.link_active));

            /* Don't do this again until the chip is reinitialised */
            dev->adapter.init_start_time = 0;

            if (!dev->adapter.link_active)
            {
                error = ENETDOWN;
            }
d1194 1
a1194 1
            error = ENETDOWN;
a1195 1
    }
d1197 1
a1197 5
    if (!error)
    {
        /* Count the number of packets to send */
        for (m = m_head; m; m = m->m_list)
            num_packets++;
d1200 2
a1201 6
    if (num_packets > 0)
    {
        if ((flags & TX_FAKESOURCE) != 0 && r->r[5] != 0)
            esrc = (uint8_t *)r->r[5];
        else
            esrc = dev->adapter.hw.mac_addr;
d1203 17
a1219 2
        error = em_ro_transmit(dev, m_head, num_packets, (uint8_t *)r->r[4], esrc, htons(r->r[2]));
    }
d1221 1
a1221 1
    if ((flags & TX_PROTOSDATA) == 0)
d1223 1
a1223 3
        /* We own the mbufs, so free them. It appears that this is the   */
        /* correct thing to do, even if we return an error, although the */
        /* DCI 4 specification is not clear on this.                     */
d1225 19
a1243 6
        while (m_head)
        {
            m = m_head;
            m_head = m_head->m_list;
            m_freem(m);
        }
d1246 1
a1246 1
    return error;
d1249 9
a1257 1
/**********************************************************************/
d1259 1
a1259 1
static int ek_filter(_kernel_swi_regs *r)
d1261 3
a1263 3
    device_t    dev = get_device(r->r[1]);
    int         error = 0;
    void      * dummy = NULL;
d1265 7
a1271 2
    dprintf(("SWI", "%s: flags=&%x, unit=%d, frame type=&%x, address level=&%x, error level=&%x, pwp=&%x, handler=&%x\n", __func__,
              r->r[0], r->r[1], r->r[2], r->r[3], r->r[4], r->r[5], r->r[6]));
d1273 18
a1290 6
    /* Range checking */
    if (
        r->r[0] >= FILTER_1STRESERVED ||
        !check_addrlevel(r->r[3])     ||
        !check_errlevel(r->r[4])
       )
d1292 1
a1292 2
        dprintf(("SWI", "%s: Invalid flags\n", __func__));
        return EINVAL;
d1295 14
a1308 2
    if (!dev->initialised)
        return ENETDOWN;
d1310 1
a1310 1
    switch (GET_FRAMELEVEL(r->r[2]))
d1312 3
a1314 3
      case FRMLVL_E2SPECIFIC:
        error = do_chainfilter(r, &dev->e2specific, &dev->e2monitor);
        break;
d1316 5
a1320 3
      case FRMLVL_E2SINK:
        error = do_singlefilter(r, &dev->e2sink, &dev->e2monitor);
        break;
d1322 3
a1324 9
      case FRMLVL_E2MONITOR:
        if( dev->e2specific != NULL )
            /*
             * Already have some specific frames claimed,
             * therefore monitor is invalid
             */
            error = EAGAIN;
        else
            error = do_singlefilter(r, &dev->e2monitor, &dev->e2sink);
d1326 3
a1328 1
        break;
d1330 4
a1333 4
      case FRMLVL_IEEE:
        error = do_singlefilter(r, &dev->ieeefilter,
                                (FilterSingleRef *)(&dummy));
        break;
d1335 1
a1335 3
      default:
        error = EINVAL;
        break;
d1337 2
a1339 2
    return error;
}
d1341 18
a1358 1
/**********************************************************************/
d1360 1
a1360 1
int ek_stats(_kernel_swi_regs * r)
d1362 8
a1369 3
    struct stats * sptr;
    device_t       dev;
    int            irqstate;
d1371 2
a1372 5
    switch (r->r[0])
    {
        case 0:
            sptr = &supported_stats;
            break;
d1374 1
a1374 5
        case 1:
            dev = get_device(r->r[1]);
            em_ro_update_stats(dev);
            sptr = &dev->stats;
            break;
d1376 7
a1382 3
        default:
            return EINVAL;
    }
d1384 2
a1385 4
    /* Disable interrupts during copy, as some stats may be updated by interrupt */
    irqstate = ensure_irqs_off();
    memcpy((char *)(r->r[2]), (char *)sptr, sizeof (*sptr));
    restore_irqs(irqstate);
d1387 3
a1389 2
    return NULL;
}
d1391 4
a1394 1
/**********************************************************************/
d1396 2
a1397 8
static int ek_multicast(_kernel_swi_regs *r)
{
    (void)r;
    
    dprintf(("SWI", "%s: Called\n", __func__));
    /* !!!TODO!!! Not implemented yet */
    return ENOTTY;
}
d1399 2
a1400 1
/**********************************************************************/
d1402 1
a1402 7
/*
 * Module SWI handler
 */
_kernel_oserror * ek_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
    struct swient *callp;
    int error, oldstate;
d1404 2
a1405 1
    (void)pw;
d1407 1
a1407 12
    /*
     * We *assume* that, since service calls are not active
     * until the mbuf manager has been started, nobody can
     * find out our SWI base, and therefore cannot raise any
     * SWIs. If this is not true (i.e. someone looks up our
     * particular SWI number, then they deserve all the trouble
     * which they are probably likely to receive.
     */
    if (swinum >= (sizeof(ek_ent) / sizeof(ek_ent[0])))
    {
        return error_BAD_SWI;
    }
d1409 1
a1409 5
    /*
     * Check that a correct unit number has been
     * given for all SWIs other than Version
     */
    if (swinum != DCI4Version && r->r[1] >= ekcnt)
d1411 2
a1412 1
        return msgs_make_error("Err_BadUnit", ENXIO, NULL);
d1415 1
a1415 1
    dprintf(("SWI", "SWI &%x called\n", swinum & 63));
d1417 12
a1428 4
    callp = &ek_ent[swinum];
    oldstate = ensure_irqs_on();
    error = (*(callp->swi_call))(r);
    restore_irqs(oldstate);
d1430 2
a1431 1
    dprintf(("SWI", "SWI exit, error=%d\n", error));
d1433 3
a1435 2
    return msgs_make_error("Err_SWI", error, "%d", error);
}
d1437 1
a1437 1
/**********************************************************************/
d1439 2
a1440 3
static _kernel_oserror * parse_unit_num(const char ** arg_string, int * unit)
{
    _kernel_oserror * e;
d1442 5
a1446 2
    if (ekcnt == 0)
        return msgs_make_error("Err_NoUnits", ENXIO, NULL);
d1448 2
a1449 3
    e = _swix(
              OS_ReadUnsigned,
              _INR(0,2) | _OUTR(1,2),
d1451 4
a1454 3
              10 | (1u<<29) | (1u<<31),
              *arg_string,
              ekcnt - 1,
d1456 1
a1456 2
              arg_string,
              unit);
d1458 1
a1458 2
    if (e != NULL)
        return msgs_make_error("Err_BadUnit", ENXIO, NULL);
d1460 2
a1461 2
    return NULL;
}
d1463 2
a1464 1
/**********************************************************************/
d1466 14
a1479 3
static _kernel_oserror * ek_cli_info(const char * arg_string, int arg_count)
{
    static const char keywords[] = ",verbose/s";
d1481 4
a1484 3
    _kernel_oserror * e = NULL;
    int               unit = -1;
    bool              verbose = false;
d1486 6
a1491 3
    if (arg_count > 0)
    {
        uint32_t out_buff[5];   /* 2 pointers, 12 bytes for unit number parameter */
d1493 1
a1493 2
        e = _swix(OS_ReadArgs,
                  _INR(0,3),
d1495 2
a1496 4
                  keywords,
                  arg_string,
                  out_buff,
                  sizeof(out_buff));
d1498 3
a1500 2
        if (e != NULL)
            return msgs_make_error("SETKINF", ErrorNumber_Syntax, NULL);
d1502 4
a1505 1
        verbose = (out_buff[1] != 0);
a1506 3
        if (out_buff[0] != 0)
        {
            e = parse_unit_num((const char **)out_buff, &unit);
a1507 17
                return e;
        }
    }

    if (unit == -1)
    {
        em_ro_info_print(0, "Inf_Head1", 1, Module_FullVersion);
        em_ro_info_printf(0, "Inf_Head2", "%d.%02d", DCIVERSION / 100, DCIVERSION % 100);

        if (ekcnt == 0)
        {
            em_ro_info_print(0, "Err_NoUnits", 0);
        }
        else
        {
            em_ro_info_printf(0, "Inf_Head3", "%d", ekcnt);
            for (int i = 0; i < ekcnt && e == NULL; i++)
d1509 3
a1511 1
                e = em_ro_info(get_device(i), verbose);
d1513 3
a1515 6
        }
    }
    else
    {
        e = em_ro_info(get_device(unit), verbose);
    }
d1517 1
a1517 2
    return e;
}
d1519 1
a1519 1
/**********************************************************************/
d1521 2
a1522 4
static _kernel_oserror * ek_cli_test(const char *arg_string)
{
    _kernel_oserror * e;
    int               unit;
d1524 1
a1524 3
    e = parse_unit_num(&arg_string, &unit);
    if (e != NULL)
        return e;
d1526 3
a1528 3
    e1000_diag_run(get_device(unit));
    return NULL;
}
d1530 4
a1533 1
/**********************************************************************/
d1535 3
a1537 4
static _kernel_oserror * ek_cli_log(const char *arg_string, int arg_count)
{
    _kernel_oserror * e;
    int               unit;
d1539 8
a1546 15
    if (arg_count > 0)
    {
        e = parse_unit_num(&arg_string, &unit);
        if (e == NULL)
            e = em_ro_log(get_device(unit));
    }
    else
    {
        for (unit = 0, e = NULL; unit < ekcnt && e == NULL; unit++)
        {
            if (unit != 0)
               putchar('\n');
            e = em_ro_log(get_device(unit));
        }
    }
d1548 11
a1558 2
    return e;
}
d1560 1
a1560 1
/**********************************************************************/
d1562 4
a1565 13
static _kernel_oserror * ek_cli_link(const char * arg_string)
{
    _kernel_oserror * e;
    int               unit;
    static const char arg_template[] = "%1\0%2\0%3\0%4";
    char              args[32];
    char            * duplex_arg;
    char            * mdi_arg;
    bool              have_duplex;
    bool              full_duplex = false;
    bool              syntax_error = false;
    ConfigLink        setting = link_auto;
    uint8_t           mdix;
d1567 7
a1573 3
    /* Use OS_SubstituteArgs to separate the arguments using CLI rules. */
    e = _swix(OS_SubstituteArgs,
              _INR(0,4),
d1575 2
a1576 5
              (uint32_t)arg_string,
              args,
              sizeof(args),
              arg_template,
              sizeof(arg_template));
d1578 8
a1585 2
    if (e != NULL)
        return msgs_make_error("SETKLNK", ErrorNumber_Syntax, NULL);
d1587 2
a1588 2
    duplex_arg = args + strlen(args) + 1;
    mdi_arg = duplex_arg + strlen(duplex_arg) + 1;
d1590 2
a1591 36
    /* Now args points to the second argument, duplex_arg to the third, */
    /* mdi_arg to the fourth. If there's anything after this, we had    */
    /* too many arguments.                                              */
    if (*(mdi_arg + strlen(mdi_arg) + 1) != 0)
        return configure_TOO_MANY_PARAMS;

    /* Check the unit number */
    e = parse_unit_num(&arg_string, &unit);
    if (e != NULL)
        return e;

    /* Check the third argument to see if it is 'half' or 'full' */
    if (duplex_arg[0] == 0)
    {
        /* There were only two parameters */
        have_duplex = false;
        mdix = 0;
    }
    else
    {
        if (Strcmp_ci(duplex_arg, link_param_full) == 0)
        {
            have_duplex = true;
            full_duplex = true;
        }
        else if (Strcmp_ci(duplex_arg, link_param_half) == 0)
        {
            have_duplex = true;
            full_duplex = false;
        }
        else
        {
            /* Not 'full' or 'half'. As long as there isn't a third */
            /* argument, assume this is actually the MDI parameter. */
            have_duplex = false;
            if (mdi_arg[0] == 0)
d1593 1
a1593 1
                mdi_arg = duplex_arg;
d1597 1
a1597 1
                syntax_error = true;
d1599 3
d1605 5
a1609 2
    /* Check the speed parameter */
    if (Strcmp_ci(args, link_param_auto) == 0)
d1611 1
a1611 3
        setting = link_auto;
        if (have_duplex)
            syntax_error = true;
d1613 1
a1613 1
    else if (Strcmp_ci(args, link_param_100) == 0)
d1615 17
a1631 9
        setting = full_duplex ? link_100_full : link_100_half;
        if (!have_duplex)
            syntax_error = true;
    }
    else if (Strcmp_ci(args, link_param_10) == 0)
    {
        setting = full_duplex ? link_10_full : link_10_half;
        if (!have_duplex)
            syntax_error = true;
d1635 2
a1636 1
        syntax_error = true;
d1639 1
a1639 2
    /* Check the MDI parameter */
    if (mdi_arg[0] == 0)
d1641 2
a1642 2
        /* Default is auto if the speed is auto or MDI if speed is forced */
        mdix = (setting == link_auto) ? 0 : 1;
d1644 2
a1645 1
    else if (Strcmp_ci(mdi_arg, link_param_mdi) == 0)
d1647 3
a1649 9
        mdix = 1;   /* MDI */
    }
    else if (Strcmp_ci(mdi_arg, link_param_mdix) == 0)
    {
        mdix = 2;   /* MDI-X */
    }
    else
    {
        syntax_error = true;
d1652 1
a1652 79
    if (syntax_error)
        return msgs_make_error("SETKLNK", ErrorNumber_Syntax, NULL);

    return em_ro_change_link(get_device(unit), setting, mdix);
}

/**********************************************************************/

static _kernel_oserror * ek_cli_link_status(void)
{
    device_t dev;

    for (int i = 0; i < ekcnt; i++)
    {
        const char * p1 = "";
        const char * p2 = NULL;
#if 0
        const char * p3 = NULL;
#endif

        dev = get_device(i);

        switch (dev->link_setting)
        {
            case link_auto:
                p1 = link_param_auto;
                break;

            case link_1000:
                p1 = link_param_1000;
                break;

            case link_100_half:
                p1 = link_param_100;
                p2 = link_param_half;
                break;

            case link_100_full:
                p1 = link_param_100;
                p2 = link_param_full;
                break;

            case link_10_half:
                p1 = link_param_10;
                p2 = link_param_half;
                break;

            case link_10_full:
                p1 = link_param_10;
                p2 = link_param_full;
                break;
        }

        /* MDI/MDI-X option is currently hidden, as the fact that it */
        /* doesn't seem to work when the link speed is forced means  */
        /* that it isn't very useful.                                */
#if 0
        switch (dev->link_mdix)
        {
            case 1:
                p3 = link_param_mdi;
                break;

            case 2:
                p3 = link_param_mdix;
                break;
        }
#endif

        printf("EKLink     %d %s", i, p1);
        if (p2 != NULL)
            printf(" %s", p2);
#if 0
        if (p3 != NULL)
            printf(" %s", p3);
#endif
        putchar('\n');
    }
    return NULL;
d1655 13
a1667 1
/**********************************************************************/
d1669 1
a1669 1
static bool advertise_set_flags(uint8_t bits, uint8_t * mask)
d1671 1
a1671 2
    if (((*mask) & bits) != 0)
        return true;
d1673 3
a1675 1
    *mask |= bits;
d1677 1
a1677 2
    return false;
}
d1679 4
a1682 1
/**********************************************************************/
d1684 5
a1688 11
static _kernel_oserror * ek_cli_advertise(const char * arg_string)
{
    _kernel_oserror    * e;
    int                  unit;
    static const char    arg_template[] = "%1\0%2\0%3\0%4\0%5\0%6\0%7\0%8";
    char                 args[40];
    char               * arg_ptr;
    uint8_t              setting;
    uint8_t              speed;
    bool                 had_duplex;
    bool                 syntax_error;
d1690 2
a1691 3
    /* Use OS_SubstituteArgs to separate the arguments using CLI rules. */
    e = _swix(OS_SubstituteArgs,
              _INR(0,4),
d1693 1
a1693 5
              (uint32_t)arg_string,
              args,
              sizeof(args),
              arg_template,
              sizeof(arg_template));
d1695 4
a1698 20
    if (e != NULL)
        return msgs_make_error("SETKADV", ErrorNumber_Syntax, NULL);

    /* Check the unit number */
    e = parse_unit_num(&arg_string, &unit);
    if (e != NULL)
        return e;

    /* Run through the arguments, setting the bits in the advertise mask. */
    /* If '10' or '100' is specified without 'half' or 'full' afterwards, */
    /* both duplex settings are made available. The same bit cannot be    */
    /* set twice.                                                         */
    arg_ptr = args;
    setting = 0;
    speed = 0;
    had_duplex = false;
    syntax_error = false;
    while(*arg_ptr != 0 && !syntax_error)
    {
        if (Strcmp_ci(arg_ptr, link_param_1000) == 0)
d1700 1
a1700 37
            syntax_error = advertise_set_flags(ADVERTISE_1000_FULL, &setting);
            speed = 0;
            had_duplex = false;
        }
        else if (Strcmp_ci(arg_ptr, link_param_100) == 0)
        {
            if (speed != 0 && !had_duplex)
                syntax_error = advertise_set_flags(speed | (speed>>1), &setting);
            speed = ADVERTISE_100_FULL;
            had_duplex = false;
        }
        else if (Strcmp_ci(arg_ptr, link_param_10) == 0)
        {
            if (speed != 0 && !had_duplex)
                syntax_error = advertise_set_flags(speed | (speed>>1), &setting);
            speed = ADVERTISE_10_FULL;
            had_duplex = false;
        }
        else if (Strcmp_ci(arg_ptr, link_param_full) == 0)
        {
            if (speed == 0)
                syntax_error = true;
            else
                syntax_error = advertise_set_flags(speed, &setting);
            had_duplex = true;
        }
        else if (Strcmp_ci(arg_ptr, link_param_half) == 0)
        {
            if (speed == 0)
                syntax_error = true;
            else
                syntax_error = advertise_set_flags(speed>>1, &setting);
            had_duplex = true;
        }
        else
        {
            syntax_error = true;
d1703 1
a1703 1
        arg_ptr += strlen(arg_ptr) + 1;
d1706 4
a1709 2
    if (!syntax_error && speed != 0 && !had_duplex)
        syntax_error = advertise_set_flags(speed | (speed>>1), &setting);
d1711 2
a1712 2
    if (syntax_error)
        return msgs_make_error("SETKADV", ErrorNumber_Syntax, NULL);
d1714 1
a1714 1
    return em_ro_set_advertise(get_device(unit), setting);
d1717 11
a1727 1
/**********************************************************************/
d1729 1
a1729 1
static _kernel_oserror * ek_cli_advertise_status(void)
d1731 3
a1733 3
    device_t dev;

    for (int i = 0; i < ekcnt; i++)
d1735 3
a1737 1
        uint8_t advertised;
d1739 8
a1746 20
        dev = get_device(i);
        advertised = dev->advertise;
        
        printf("EKAdvertise %d", i);
        if (advertised & (ADVERTISE_10_HALF|ADVERTISE_10_FULL))
            printf(" %s", link_param_10);
        if (advertised & ADVERTISE_10_HALF)
            printf(" %s", link_param_half);
        if (advertised & ADVERTISE_10_FULL)
            printf(" %s", link_param_full);
        if (advertised & (ADVERTISE_100_HALF|ADVERTISE_100_FULL))
            printf(" %s", link_param_100);
        if (advertised & ADVERTISE_100_HALF)
            printf(" %s", link_param_half);
        if (advertised & ADVERTISE_100_FULL)
            printf(" %s", link_param_full);
        if (advertised & ADVERTISE_1000_FULL)
            printf(" %s", link_param_1000);
        putchar('\n');
    }
d1748 6
a1753 2
    return NULL;
}
d1755 7
a1761 1
/**********************************************************************/
d1763 6
a1768 5
static _kernel_oserror * ek_cli_flow(const char * arg_string)
{
    _kernel_oserror * e;
    int               unit;
    em_fc_type        setting;
d1770 11
a1780 4
    /* Check the unit number */
    e = parse_unit_num(&arg_string, &unit);
    if (e != NULL)
        return e;
d1782 3
a1784 2
    while (*arg_string == ' ')
        arg_string++;
d1786 2
a1787 20
    /* Check the parameter */
    if (Strcmp_ci(arg_string, flow_param_none) == 0)
    {
        setting = em_fc_none;
    }
    else if (Strcmp_ci(arg_string, flow_param_respond) == 0)
    {
        setting = em_fc_rx_pause;
    }
    else if (Strcmp_ci(arg_string, flow_param_generate) == 0)
    {
        setting = em_fc_tx_pause;
    }
    else if (Strcmp_ci(arg_string, flow_param_full) == 0)
    {
        setting = em_fc_full;
    }
    else
    {
        return msgs_make_error("SETKFLW", ErrorNumber_Syntax, NULL);
a1788 2

    return em_ro_set_flow(get_device(unit), setting);
d1791 19
a1809 1
/**********************************************************************/
d1811 1
a1811 3
static _kernel_oserror * ek_cli_flow_status(void)
{
    device_t dev;
d1813 6
a1818 1
    for (int i = 0; i < ekcnt; i++)
d1820 2
a1821 1
        const char * p = "";
d1823 6
a1828 1
        dev = get_device(i);
d1830 1
a1830 5
        switch (dev->flow_control)
        {
            case em_fc_none:
                p = flow_param_none;
                break;
d1832 4
a1835 3
            case em_fc_rx_pause:
                p = flow_param_respond;
                break;
d1837 1
a1837 3
            case em_fc_tx_pause:
                p = flow_param_generate;
                break;
d1839 1
a1839 8
            case em_fc_full:
                p = flow_param_full;
                break;
        }

        printf("EKFlowControl %d %s\n", i, p);
    }
    return NULL;
d1842 15
a1856 1
/**********************************************************************/
d1858 2
a1859 2
_kernel_oserror * ek_cli_handler(const char *arg_string, int arg_count,
                                int cmd_no, void *pw)
d1868 1
d1873 1
d1878 1
d1883 1
d1886 1
a1886 1
                em_ro_info_print(0, "CETKLNK", 0);
d1899 1
d1902 1
a1902 1
                em_ro_info_print(0, "CETKADV", 0);
d1915 1
d1918 1
a1918 1
                em_ro_info_print(0, "CETKFLW", 0);
a1932 4

/**********************************************************************/

/* EOF ekmodule.c */
@


1.11
log
@Lots of changes due to new code from Intel,this removes lots of
useless code from the driver - smaller and faster?
Now implements blocking if someone (eg.NetFS) tries to transmit before
the link is up.If noone is trying to transmit then the link will
come up in the background.

Version 0.10. Tagged as 'EtherK-0_10'
@
text
@d1985 1
a1985 1
        return msgs_make_error("SETFLW", ErrorNumber_Syntax, NULL);
@


1.10
log
@Adds reentrancy checks to the transmit routine.
Change to spl macros to disable *all* interrupts rather than just the
line relating to the device vector number.
User guide tweak.

Version 0.09. Tagged as 'EtherK-0_09'
@
text
@d1250 1
a1250 1
    int           num_packets;
d1257 1
d1259 1
d1261 2
a1262 2
             (dev->adapter.interface_data.ac_if.if_flags & IFF_RUNNING) == 0 ||
             !dev->adapter.link_active)
d1264 32
a1295 1
    else
a1297 1
        num_packets = 0;
d1302 1
a1302 1
    if (!error && num_packets > 0)
@


1.9
log
@Tidy up syntax messages
Addition of user guide
Rearrange ekinfo output
Function names stripped to save ROM space
Add link failures and polarity statistics

Version 0.08. Tagged as 'EtherK-0_08'
@
text
@d860 2
@


1.8
log
@Interrupt handling got broken in 0.06 so although packets were being
received noone ever saw them.
Change to DCI flags.
Addition of new Configure keywords (EkAdvertise and EkFlowControl).
Improvement to the interrupt handler so interrupts are turned off for
slightly less time.

Version 0.07. Tagged as 'EtherK-0_07'
@
text
@a36 1
#include <DebugLib/DebugLib.h>
d40 1
a46 1
#include "VersionNum"
d166 1
a166 1
void panic(char *s)
d599 1
a599 1
void send_driverstatus(DibRef dib, int status)
d623 4
d645 4
d688 4
d726 3
d1029 4
d1135 2
d1234 2
d1391 2
d1408 2
d1999 2
@


1.7
log
@Merge in changes from the latest BSD driver. EtherK is now based on
version 1.4.7 of the FreeBSD 'em' device driver.
Merge in changes from the latest BSD driver. EtherK is now based on version

Version 0.06. Tagged as 'EtherK-0_06'
@
text
@d121 6
d392 1
a392 1
                dev->dupclaimexpected != 0 &&
d524 1
a524 1
                dev->dupclaimexpected != 0 &&
d648 1
a648 1
            dev->initialised != 0 &&
d683 1
a683 1
        if (dev->localtimerset != 0 && (dev->dib.dib_unit & 1) == which)
d701 1
a701 1
_kernel_oserror *ek_initialise(const char *cmd_tail, int podule_base, void *pw)
d826 1
a826 1
                                INQ_HWADDRVALID | /*INQ_SOFTHWADDR |*/
d875 1
a875 1
                dev->no_eeprom = 1;
d923 1
a923 1
                    dev->initialised = 1;
d1011 1
a1011 1
_kernel_oserror *ek_quit(int fatal, int podule, void *pw)
d1030 1
a1030 1
        if (dev->initialised != 0)
d1128 1
a1128 1
                if (dev->initialised != 0)
d1234 1
a1234 1
    else if (dev->initialised == 0 ||
d1295 1
a1295 1
    if (dev->initialised == 0)
d1379 1
a1379 1
_kernel_oserror *ek_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
d1507 1
a1507 1
static _kernel_oserror *ek_cli_test(const char *arg_string)
d1522 1
a1522 1
static _kernel_oserror *ek_cli_log(const char *arg_string, int arg_count)
d1548 128
a1675 1
static _kernel_oserror *ek_cli_link_status(void)
d1681 1
a1681 1
        const char * p1 = NULL;
d1683 3
d1688 1
d1719 17
d1739 4
d1750 13
a1762 1
static _kernel_oserror *ek_cli_link(const char *arg_string)
d1766 7
a1772 7
    static const char    arg_template[] = "%1\0%2\0%3";
    char                 args[32];
    char               * duplex_arg;
    bool                 have_duplex;
    bool                 full_duplex = false;
    bool                 syntax_error = false;
    ConfigLink           setting = link_auto;
d1785 1
a1785 8
        return msgs_make_error("SETKLNK", ErrorNumber_Syntax, NULL);

    duplex_arg = args + strlen(args) + 1;

    /* Now args points to the second argument; duplex_arg to the third. */
    /* If there's anything after this, we had too many arguments.       */
    if (*(duplex_arg + strlen(duplex_arg) + 1) != 0)
        return configure_TOO_MANY_PARAMS;
d1792 53
a1844 4
    /* Check the half/full duplex parameter */
    if (duplex_arg[0] == 0)
    {
        have_duplex = false;
d1846 17
a1862 1
    else
d1864 21
a1884 7
        have_duplex = true;
        if (Strcmp_ci(duplex_arg, link_param_full) == 0)
            full_duplex = true;
        else if (Strcmp_ci(duplex_arg, link_param_half) == 0)
            full_duplex = false;
        else
            syntax_error = true;
d1887 21
a1907 2
    /* Check the speed parameter */
    if (Strcmp_ci(args, link_param_auto) == 0)
d1909 1
a1909 3
        setting = link_auto;
        if (have_duplex)
            syntax_error = true;
d1911 1
a1911 1
    else if (Strcmp_ci(args, link_param_1000) == 0)
d1913 1
a1913 3
        setting = link_1000;
        if (have_duplex)
            syntax_error = true;
d1915 1
a1915 1
    else if (Strcmp_ci(args, link_param_100) == 0)
d1917 1
a1917 3
        setting = full_duplex ? link_100_full : link_100_half;
        if (!have_duplex)
            syntax_error = true;
d1919 1
a1919 1
    else if (Strcmp_ci(args, link_param_10) == 0)
d1921 1
a1921 3
        setting = full_duplex ? link_10_full : link_10_half;
        if (!have_duplex)
            syntax_error = true;
d1925 1
a1925 1
        syntax_error = true;
d1928 33
a1960 2
    if (syntax_error)
        return msgs_make_error("SETKLNK", ErrorNumber_Syntax, NULL);
d1962 3
a1964 1
    return em_ro_change_link(get_device(unit), setting);
d1969 1
a1969 1
_kernel_oserror *ek_cli_handler(const char *arg_string, int arg_count,
d2000 30
@


1.6
log
@Addition of support for *CONFIGURE eklink to allow forceable setting of speed
Fix to link list handler so multiple 82540's are supported at once

Version 0.05. Tagged as 'EtherK-0_05'
@
text
@d38 1
d89 3
a91 1
static void callback(void (*f)(void), void *pw);
d103 2
d591 1
a591 1
 * Send_driverstatus - send a DCIDriverStatus service
d611 1
a611 1
 * callb_handler - handler for callback primed by initialisation
d614 1
a614 1
_kernel_oserror *callb_handler(_kernel_swi_regs *r, void *pw)
d628 43
a670 1
static void callback(void (*f)(), void *pw)
d672 16
a687 1
    _swix(OS_AddCallBack, _INR(0,1), f, pw);
d714 1
d719 3
d746 1
a746 1
        dprintf(("Init,Error", "%s: PCI_ReturnNumber failed: '%s'\n", __func__, e->errmess));
d787 1
a787 1
            dprintf(("Init,Error", "%s: PCI_ReadID for function handle %d failed: '%s'\n", __func__, fh, e->errmess));
d855 1
a855 1
                dprintf(("Init,Error", "%s: PCI_ReadInfo (slot) for function handle %u failed: '%s'\n", __func__, fh, e->errmess));
d972 1
a972 1
                callback(callb_entry, pw);
d984 6
d1011 6
d1076 1
a1076 1
                callback(callb_entry, module_wsp);
d1510 1
a1510 2
    /*em_ro_runtest(unit);*/
    printf("Not implemented yet.\n");
d1516 1
a1516 1
static _kernel_oserror *ek_cli_log(const char *arg_string)
d1521 15
a1535 3
    e = parse_unit_num(&arg_string, &unit);
    if (e == NULL)
        e = em_ro_log(get_device(unit));
d1699 1
a1699 1
            e = ek_cli_log(arg_string);
@


1.5
log
@New code drop from James
Adds AutoSense program to integrate with !Configure
Debugging support added to IRQ handlers
Messages tweaked to allow better compression in ROM

Version 0.04. Tagged as 'EtherK-0_04'
@
text
@d31 1
d110 43
d656 2
a657 2
#ifdef IRQ_STATS
    em_ro_init_irq_stats();
d774 3
a876 1
                prev = dev;
d878 1
d1035 1
a1035 1
        case Service_MbufManagerStatus:        
d1055 1
a1055 1
        
d1060 1
a1060 1
        
d1376 1
a1376 1
    
d1455 43
a1497 1
    printf("EKLink     Not implemented yet\n");
d1505 85
a1589 2
    printf("Not implemented yet.\n");
    return NULL;
@


1.4
log
@New drop from James Byrne
Resources capable of being ROMmed and tokenised
Makefile changes
Fix for declaring the wrong MAC address which confused some switches

Version 0.03. Tagged as 'EtherK-0_03'
@
text
@d91 1
a91 1
static void   * module_wsp;
d93 2
a94 2
static int      ekcnt = 0;          /* Number of devices */
static device_t device_list = NULL; /* List of devices */
d96 2
a97 2
static bool     managerstarted = false;
static bool     finalising = false;
a100 6
struct
{
    int  e_num;
    char e_mess[32];
} _ek_errblk = { 0 };

a123 24
static _kernel_oserror *ek_error(int error, char * errortext)
{
    if (error)
    {
        if (error >= 0x80)
            _ek_errblk.e_num = error;
        else
            REALLYSETDCI4ERRNO(_ek_errblk.e_num, error);

        if (errortext != NULL)
        {
            strncpy (_ek_errblk.e_mess, errortext, sizeof(_ek_errblk.e_mess) - 1);
            _ek_errblk.e_mess[sizeof(_ek_errblk.e_mess) - 1] = 0;
        }
        return (_kernel_oserror *)&_ek_errblk;
    }
    else
    {
        return NULL;
    }
}

/**********************************************************************/

d612 4
d843 1
a843 1
        e = ek_error(ENOMEM, "Out of memory while initialising " Module_Title);
d865 5
d1272 1
a1272 1
        return ek_error(ENXIO, "Invalid unit number for " Module_Title);
d1284 1
a1284 1
    return ek_error(error, Module_Title " SWI error");
d1294 1
a1294 1
        return msgs_make_error("Err_NoUnits", ENXIO, 0);
d1308 1
a1308 1
        return msgs_make_error("Err_BadUnit", ENXIO, 0);
d1336 1
a1336 1
            return msgs_make_error("SEKINFO", ErrorNumber_Syntax, 0);
d1355 1
a1355 1
            printf("%s.\n", msgs_return_message("Err_NoUnits"));
d1359 1
a1359 1
            em_ro_info_printf(0, "Inf_Head3","%d", ekcnt);
d1408 1
a1408 1
    printf("Not implemented yet.\n");
d1444 1
a1444 1
                printf("%s\n", msgs_return_message("CEKLINK"));
@


1.3
log
@Messages placed in messages file
Improvements to shared interrupt handling
Makefile updated
Tidied logging

Version 0.02. Tagged as 'EtherK-0_02'
@
text
@d30 1
d37 1
d629 3
d647 3
d664 4
d697 3
d701 1
d711 3
d715 1
d1055 4
d1141 1
a1141 1
            esrc = dev->adapter.hw.hw_addr;
@


1.2
log
@em_disable_intr fudged to disable ALL interrupts
PreReset attempt

Version 0.01. Tagged as 'EtherK-0_01'
@
text
@d33 1
a33 1

d39 1
d43 1
a43 1
#include "Interface/pci.h"
d47 6
a59 5
struct client
{
    static _kernel_oserror *(*cli_call)(int argc, char **argv);
};

a82 11
/* CLI handler table */

static _kernel_oserror *do_ekinfo(int argc, char **argv);
static _kernel_oserror *do_ektest(int argc, char **argv);

static struct client ek_cli_call[] =
{
    do_ekinfo,
    do_ektest
};

d91 1
a91 1
static int      emcnt = 0;          /* Number of devices */
d111 1
d116 1
a116 1
int panic(char *s)
d118 6
a123 3
    /* !!!TODO!!! */
    printf("EtherK: panic: %s\n", s);
    return(0);
d128 1
a128 1
static _kernel_oserror *ek_error(int error, char *errortext)
a275 1
    int         unit;
d279 1
a279 1
    for (unit = 0; unit < emcnt; ++unit)
a280 2
        dev = get_device(unit);

d316 1
a316 1
    dprintf (("", "do_chainfilter(%x, %x): fcrptr = %p, fc = %p\n",
d336 1
a336 1
        dprintf(("", "do_chainfilter: Releasing claim on frame type %x (fcprev = %p)\n",
d398 3
d575 3
d617 1
a617 1
_kernel_oserror *ek_initialise(const char *cmd_tail, int pbase, void *pw)
d625 2
a626 1
    bool                failed;
d630 11
a640 3
    debug_initialise ("EtherK", "", NULL);
    debug_set_options (0, 0, 0);
    debug_output_device (NULL_OUTPUT);
d653 4
a656 1
        return e;
d658 1
a658 1
    dprintf(("", "ek_initialise: PCI_ReturnNumber reports %d function handles\n", num_handles));
d667 4
a670 1
                return ek_error(ENOMEM, "Out of memory while initialising " Module_Title);
d687 1
a687 1
            dprintf(("", "ek_initialise: PCI_ReadID for function handle %d failed: '%s'\n", fh, e->errmess));
d691 2
a692 2
        dprintf(("", "ek_initialise: Function handle %d has vendor ID %04x, device ID %04x, subsystem vendor ID %04x, subsystem ID %04x\n",
            fh, (dev->pci_id & 0xffff), (dev->pci_id >> 16), (dev->pci_sub_id & 0xffff), (dev->pci_sub_id >> 16)));
d697 3
a699 1
            failed = false;
d701 1
a701 1
            dprintf(("", "ek_initialise: Function handle %d recognised by em_probe()\n", fh));
d704 1
a704 1
            emcnt++;
d712 1
a712 1
            dev->dib.dib_unit = emcnt - 1;
d732 2
a733 2
                dprintf(("", "ek_initialise: PCI_ReadInfo (device vector) for function handle %u failed: '%s'\n", fh, e->errmess));
                failed = true;
d748 1
a748 1
                dprintf(("", "ek_initialise: PCI_ReadInfo (slot) for function handle %u failed: '%s'\n", fh, e->errmess));
d784 1
a784 1
                    dprintf(("", "ek_initialise: PCI_ReadInfo (MAC) for function handle %u failed: '%s'\n", fh, e->errmess));
d787 1
a787 1
                    failed = true;
d798 1
a798 1
            dprintf(("", "ek_initialise: Location of device for function handle %u is '%s'\n", fh, dev->dib.dib_location));
d806 1
a806 1
            if (!failed)
d811 1
a811 1
                    dprintf(("", "ek_initialise: em_attach() succeeded\n"));
d815 3
d821 1
a821 1
                    dprintf(("", "ek_initialise: em_attach() failed\n"));
d847 14
a860 2
    if (emcnt == 0)
        return NULL;
d862 4
a865 10
    /*
     * Check whether the mbuf manager module is loaded yet
     */
    if (!managerstarted && mb_present())
    {
        /*
         * mbuf manager is loaded - initialise entry points
         */
        if ((e = mb_entryinit()) != NULL)
            return(e);
d867 4
a870 4
        /*
         * OK - set a callback to issue Service_DCIDriverStatus
         */
        callback(callb_entry, pw);
d872 5
a876 1
        managerstarted = true;
d879 1
a879 1
    return NULL;
d896 2
a897 1
        send_driverstatus(&dev->dib, 1);
d909 1
a909 1
            free (dev->dib.dib_location);
d911 1
a911 1
        free (dev);
d920 2
a921 1
    mb_closesession();
d923 2
a924 1
    debug_terminate();
d939 1
a939 1
        dprintf(("","handle_managerstatus: MbufManagerStatus_Started\n"));
d959 1
a959 1
        dprintf(("","handle_managerstatus: MbufManagerStatus_Stopping\n"));
d973 1
a973 1
        dprintf(("","handle_managerstatus: MbufManagerStatus_Scavenge\n"));
a983 15
/*
 * handle_prereset - deal with a PreReset service call
 */
static void handle_prereset(void)
{
    device_t dev;

    for (dev = device_list; dev; dev = dev->next)
    {
        em_shutdown(dev);
    }
}

/**********************************************************************/

d987 1
a987 5
    /*
     * Ignore nearly all calls until the
     * mbuf manager has been initialised
     */
    if (!managerstarted)
d989 1
a989 2
        if (sn == Service_MbufManagerStatus)
            /* Best not to ignore this one */
d991 1
a991 8
    }
    else
    {
        switch (sn)
        {
          case Service_PreReset:
              handle_prereset (); /* should still do it if no mbuf manager */
              break;
d993 9
a1001 3
          case Service_EnumerateNetworkDrivers:
          {
            device_t    dev;
d1003 2
a1004 1
            for (dev = device_list; dev; dev = dev->next)
d1006 13
a1018 12
                ChDibRef chd;

                if ((chd = (ChDibRef)malloc(sizeof(*chd))) == NULL)
                    /*
                     * failed to claim memory - return as
                     * much information as possible
                     */
                    break;

                chd->chd_dib = &dev->dib;
                chd->chd_next = (ChDibRef)r->r[0];
                r->r[0] = (int)chd;
a1019 1

a1020 1
          }
d1022 6
a1027 2
          case Service_DCIProtocolStatus:
            if (r->r[3] == DCIVERSION)
d1029 1
a1029 5
                dprintf(("", "\021\02et: Protocol '%s' is %sing\021\07\n",
                       (char *)r->r[4], r->r[2] ? "dy" : "start"));
                /*
                 * Only interested in termination calls
                 */
a1032 1

d1035 1
a1035 1
          default:
a1036 1
        }
d1095 1
a1095 1
    dprintf(("", "ek_transmit: unit=%d, flags=&%x, type=&%x, m_head=%p\n",
d1147 1
a1147 1
    dprintf (("", "ek_filter: flags=&%x, unit=%d, frame type=&%x, address level=&%x, error level=&%x, pwp=&%x, handler=&%x\n",
d1157 1
a1157 1
        dprintf (("", "ek_filter: Invalid flags\n"));
d1161 3
d1205 1
d1223 4
a1226 1
    memcpy ((char *)(r->r[2]), (char *)sptr, sizeof (*sptr));
d1235 1
a1235 1
    dprintf(("", "ek_multicast: Called\n"));
d1253 2
a1254 2
     * find out our swibase, and therefore cannot raise any
     * SWIS.  if this is not true (i.e. someone looks up our
d1267 1
a1267 1
    if (swinum != DCI4Version && r->r[1] >= emcnt)
d1272 2
a1273 1
    dprintf(("", "\021\06SWI %x...", swinum & 63));
d1279 1
a1279 1
    dprintf(("", "error %d\021\07\n", error));
d1286 1
a1286 1
static _kernel_oserror *do_ekinfo(int argc, char **argv)
d1288 18
a1305 2
    printf("%-18s", "DCI Version");
    printf("%d.%02d\n\n", DCIVERSION / 100, DCIVERSION % 100);
d1307 14
a1320 1
    if (emcnt == 0)
d1322 21
a1342 1
        printf("No network cards supported by "Module_Title" installed.\n");
d1344 2
a1345 1
    else
d1347 2
a1348 1
        int i;
d1350 5
a1354 1
        for (i = 0; i < emcnt; i++)
d1356 5
a1360 3
            em_ro_info(get_device(i));
            if (i != emcnt - 1)
               putchar('\n');
d1363 9
d1373 11
d1389 1
a1389 1
static _kernel_oserror *do_ektest(int argc, char **argv)
d1391 11
a1401 1
    int unit;
d1403 5
a1407 5
    if( (unit = atoi(*argv)) == 0 && **argv != '0' )
    {
        sprintf(_ek_errblk.e_mess, "EMTest: Bad unit number '%s'", *argv);
        return ek_error(ENXIO, NULL);
    }
d1409 1
a1409 5
    if( unit >= emcnt )
    {
        sprintf(_ek_errblk.e_mess, "EMTest: Invalid unit number: %d", unit);
        return ek_error(ENXIO, NULL);
    }
d1411 2
a1412 1
    /*em_runtest(unit);*/
d1422 1
a1422 6
    struct client * callp;
    int             margc;
    char          * margv[20];
    char          * cp;
    char         ** argp = margv;
    char            arg_string_copy[256];
d1424 1
a1424 1
    if (cmd_no >= sizeof(ek_cli_call) / sizeof(ek_cli_call[0]))
d1426 3
a1428 3
        sprintf (_ek_errblk.e_mess, "EMInfo: Bad command number: %d\n", cmd_no);
        return ek_error(EINVAL, NULL);
    }
d1430 3
a1432 13
    strncpy(arg_string_copy, arg_string, 255);
    arg_string_copy[255] = 0;

    if (arg_count > 20)
        /* limit set by size of margv array */
        arg_count = 20;

    margc = 0;
    cp = arg_string_copy;
    while (*cp && arg_count-- > 0)
    {
        while (*cp == ' ' || *cp == '\t')
            cp++;
d1434 2
a1435 3
        if (*cp < ' ')
        {
            *cp = '\0';
a1436 1
        }
d1438 13
a1450 8
        *argp++ = cp;
        margc++;
        while (*cp >= ' ' && *cp != ' ' && *cp != '\t')
            cp++;

        if (*cp < ' ')
        {
            *cp = '\0';
a1451 3
        }

        *cp++ = '\0';
d1454 1
a1454 4
    *argp++ = 0;

    callp = &ek_cli_call[cmd_no];
    return callp->cli_call(margc, margv);
d1459 1
a1459 1
/* EOF emmodule.c */
@


1.1
log
@Initial revision
@
text
@d953 15
d985 3
a987 3
          /*case 0x45:    * Pre reset *
              ek_reset_all ();
              break;*/
@


1.1.1.1
log
@Initial import from James Byrne

@
text
@@

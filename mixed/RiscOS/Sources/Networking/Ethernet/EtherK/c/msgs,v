head	1.6;
access;
symbols
	EtherK-0_25:1.6
	EtherK-0_24:1.6
	EtherK-0_23:1.6
	EtherK-0_22:1.5
	EtherK-0_21:1.5
	EtherK-0_20:1.5
	EtherK-0_19:1.5
	EtherK-0_18:1.5
	EtherK-0_17:1.5
	EtherK-0_16:1.5
	EtherK-0_15:1.5
	EtherK-0_14:1.5
	RO_5_07:1.5
	EtherK-0_13:1.5
	EtherK-0_12:1.5
	EtherK-0_11:1.4
	EtherK-0_10:1.4
	EtherK-0_09:1.4
	EtherK-0_08:1.4
	EtherK-0_07:1.4
	EtherK-0_06:1.4
	EtherK-0_05:1.3
	EtherK-0_04:1.3
	EtherK-0_03:1.2
	EtherK-0_02:1.1;
locks; strict;
comment	@# @;


1.6
date	2012.02.05.22.38.17;	author jlee;	state Exp;
branches;
next	1.5;
commitid	IbuCtBQH8ng7j1Sv;

1.5
date	2004.03.02.19.08.22;	author jbyrne;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.11.19.14.03;	author jbyrne;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.21.08.37.49;	author rsprowson;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.14.23.17.20;	author rsprowson;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.09.19.54.04;	author rsprowson;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Fix rom_link errors
Detail:
  c/ekmodule, c/em_riscos, c/info, c/log, c/msgs, c/test, h/em_riscos, h/msgs
  After the makefile rewrite the rom_link phase has started complaining about msgs_init and msgs_lookup being multiply defined (in EtherK & clib)
  I'm not sure how the original makefile sidestepped the issue, but a simple search and replace of msgs_ -> messages_ fixes the issue
Admin:
  rom_link phase now completes without errors
  Module not tested at runtime


Version 0.23. Tagged as 'EtherK-0_23'
@
text
@/* Copyright 2002 Tematic Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    Msgs.c                                            */
/*                                                            */
/* Purpose: Message lookup and error handling functions.      */
/*                                                            */
/* Author:  J.R.Byrne.                                        */
/**************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <sys/dcistructs.h>

#include "EKHdr.h"

#include "msgs.h"

/* External declarations */

#ifndef ROM
extern void * messages_file(void);   /* Resource block generated by ResGen */
#endif

/* Local definitions */

#define ERR_BLOCKS                 3
#define MessageTrans_TokenNotFound 0xAC2

/* Static variables */

static uint32_t   messages_fd[4] = {0, 0, 0, 0}; /* Message file descriptor */
static const char messages_default_token[] = "TNF:"Module_Title" message not found in messages file";
static const char messages_path[] = Module_Title "$Path";
static const char messages_path_filename[] = Module_Title ":Messages";
static const char messages_resfs_filename[] = "Resources:$.Resources." Module_Title ".Messages";

/**************************************************************/
/* messages_init()                                            */
/*                                                            */
/* This is called on module initialisation to register the    */
/* module's resources (if necessary) and open the messages    */
/* file, using the global messages block                      */
/*                                                            */
/* Returns: Error pointer.                                    */
/**************************************************************/

_kernel_oserror * messages_init(void)
{
    _kernel_oserror * e;
    bool              have_path;

#ifndef ROM
    /* Register resources */
    e = _swix(
              ResourceFS_RegisterFiles,
              _IN(0),

              messages_file());

    if (e != NULL)
        return e;
#endif

    /* Open messages file */
    have_path = (getenv(messages_path) != NULL);
    e = _swix(
              MessageTrans_OpenFile,
              _INR(0,2),

              messages_fd,
              have_path ? messages_path_filename : messages_resfs_filename,
              0);

#ifndef ROM
    if (e != NULL)
    {
        _swix(
              ResourceFS_DeregisterFiles,
              _IN(0),

              messages_file());
    }
#endif

  return e;
}

/**************************************************************/
/* messages_quit()                                            */
/*                                                            */
/* This is called on module finalisation to close the         */
/* messages file using the global messages block, and         */
/* deregister the module's resources (if necessary).          */
/**************************************************************/

void messages_quit(void)
{
    /* Close messages file */
    _swix(
          MessageTrans_CloseFile,
          _IN(0),

          messages_fd);

#ifndef ROM
    /* Deregister resources */
    _swix(
          ResourceFS_DeregisterFiles,
          _IN(0),

          messages_file());
#endif
}

/**************************************************************/
/* messages_return_message()                                  */
/*                                                            */
/* Lookup a message through MessageTrans and return a pointer */
/* to the message. If the token is not found a pointer to a   */
/* default message is returned instead. Messages looked up in */
/* this way must include a null terminator in the messages    */
/* file, and must not be tokenised.                           */
/*                                                            */
/* Parameters: Pointer to the message token.                  */
/*                                                            */
/* Returns:    Pointer to the message.                        */
/*                                                            */
/* Assumes:    Messages include a null terminator in the      */
/*             messages file, and are not tokenised.          */
/**************************************************************/

const char * messages_return_message(const char * token)
{
    _kernel_oserror * e;
    char            * ptr;

    /* Look up token */
    e = _swix(MessageTrans_Lookup,
              _INR(0,7) | _OUT(2),
    
              messages_fd,
              token,
              0,
              0,
              0,
              0,
              0,
              0,

              &ptr);

    /* If the token isn't found, replace with our not found message */
    if (e != NULL)
    {
        if (e->errnum == MessageTrans_TokenNotFound)
        {
            e = _swix(MessageTrans_Lookup,
                      _INR(0,7) | _OUT(2),
            
                      messages_fd,
                      messages_default_token,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,

                      &ptr);
        }

        /* Last resort - MessageTrans went wrong, so use its error message */
        if (e != NULL)
        {
            ptr = e->errmess;
        }
    }

    return ptr;
}

/**************************************************************/
/* messages_lookup_subst()                                    */
/*                                                            */
/* Look up a message token and perform parameter              */
/* substitution. If the token is not found it is replaced     */
/* with a default message. An error is only returned if       */
/* the lookup of the default message also fails, and in       */
/* this case the error message is copied to the output        */
/* buffer too.                                                */
/*                                                            */
/* Parameters: Pointer to a buffer to write the output to;    */
/*                                                            */
/*             The size of the buffer;                        */
/*                                                            */
/*             Pointer to the message token;                  */
/*                                                            */
/*             Pointer to an array containing four pointers   */
/*             to the strings to be substituted for the %0    */
/*             to %3 parameters. Any of these can be NULL     */
/*             if the parameter is not required.              */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

_kernel_oserror * messages_lookup_subst(char * buffer, size_t length,
    const char * token, const char * params[static 4])
{
    _kernel_oserror * e;

    /* Look up token */
    e = _swix(MessageTrans_Lookup,
              _INR(0,7),
    
              messages_fd,
              token,
              buffer,
              length,
              params[0],
              params[1],
              params[2],
              params[3]);

    /* If the token isn't found, replace with our own not found message */
    if (e != NULL)
    {
        if (e->errnum == MessageTrans_TokenNotFound)
        {
            e = _swix(MessageTrans_Lookup,
                      _INR(0,7),
            
                      messages_fd,
                      messages_default_token,
                      buffer,
                      length,
                      0,
                      0,
                      0,
                      0);
        }

        /* Last resort - MessageTrans went wrong, so use its error message */
        if (e != NULL)
        {
            strncpy(buffer, e->errmess, length);
            buffer[length-1] = 0;
        }
    }

    return e;
}

/**************************************************************/
/* messages_vlookup()                                         */
/*                                                            */
/* Look up a message token and perform parameter              */
/* substitution. If the token is not found it is replaced     */
/* with a default message. An error is only returned if       */
/* the lookup of the default message also fails, and in       */
/* this case the error message is copied to the output        */
/* buffer too.                                                */
/*                                                            */
/* Parameters: Pointer to a buffer to write the output to;    */
/*                                                            */
/*             The size of the buffer;                        */
/*                                                            */
/*             Pointer to the message token;                  */
/*                                                            */
/*             The number of parameters (0-4);                */
/*                                                            */
/*             Variable argument list pointer that has been   */
/*             initialised by the va_start macro. The         */
/*             arguments, if any, are pointers to the strings */
/*             to be substituted for the %0 to %3 parameters. */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

_kernel_oserror * messages_vlookup(char * buffer, size_t length,
    const char * token, int nparams, va_list ap)
{
    const char * p[4] = {NULL, NULL, NULL, NULL};

    /* Determine parameter pointers */
    if (nparams > 4)
        nparams = 4;

    for (int i = 0; i < nparams; i++)
    {
        p[i] = va_arg(ap, const char *);
    }

    return messages_lookup_subst(buffer, length, token, p);
}

/**************************************************************/
/* messages_lookup()                                          */
/*                                                            */
/* Look up a message token and perform parameter              */
/* substitution. If the token is not found it is replaced     */
/* with a default message. An error is only returned if       */
/* the lookup of the default message also fails, and in       */
/* this case the error message is copied to the output        */
/* buffer too.                                                */
/*                                                            */
/* Parameters: Pointer to a buffer to write the output to;    */
/*                                                            */
/*             The size of the buffer;                        */
/*                                                            */
/*             Pointer to the message token;                  */
/*                                                            */
/*             The number of parameters (0-4);                */
/*                                                            */
/*             Variable argument list of up to four pointers  */
/*             to the strings to be substituted for the %0    */
/*             to %3 parameters.                              */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

_kernel_oserror * messages_lookup(char * buffer, size_t length,
    const char * token, int nparams, ...)
{
    _kernel_oserror * e;
    va_list           ap;

    va_start(ap, nparams);
    e = messages_vlookup(buffer, length, token, nparams, ap);
    va_end(ap);

    return e;
}

/**************************************************************/
/* messages_vlookupf()                                        */
/*                                                            */
/* Look up a message token using MessageTrans, substituting   */
/* parameters with elements from a printf() style formatted   */
/* string. The format string and its parameters are processed */
/* by sprintf() first, then the resulting string is split at  */
/* any line feed characters within it. Each of the resulting  */
/* strings becomes one parameter for the MessageTrans         */
/* parameter substitution.                                    */
/*                                                            */
/* For example, if the message string for the token was       */
/* "First %0, then %1", the format string was "a=%d\nb=%d"    */
/* and the parameters were '1' and '2' then the result would  */
/* be "First a=1, then b=2".                                  */
/*                                                            */
/* If the token is not found it is replaced with a default    */
/* message.                                                   */
/*                                                            */
/* Parameters: Pointer to a buffer to write the output to;    */
/*                                                            */
/*             The size of the buffer;                        */
/*                                                            */
/*             Pointer to the message token;                  */
/*                                                            */
/*             Pointer to the format string;                  */
/*                                                            */
/*             Variable argument list pointer that has been   */
/*             initialised by the va_start macro.             */
/*                                                            */
/* Returns:    Error pointer.                                 */
/*                                                            */
/* Assumes:    The expanded string will be no more than 80    */
/*             characters in length. Longer strings will be   */
/*             truncated.                                     */
/**************************************************************/

_kernel_oserror * messages_vlookupf(char * buffer, size_t length,
    const char * token, const char * format, va_list ap)
{
    char         params[80];
    const char * pp[4] = {NULL, NULL, NULL, NULL};

    if (format != NULL)
    {
        vsnprintf(params, sizeof(params), format, ap);
    
        char * p = params;
        for (int i = 0; *p && i < 4; i++)
        {
            pp[i] = p;
            while (*p)
            {
                if (*p++ == '\n')
                {
                    *(p-1) = 0;
                    break;
                }
            }
        }
    }

    return messages_lookup_subst(buffer, length, token, pp);
}

/**************************************************************/
/* messages_lookupf()                                         */
/*                                                            */
/* Look up a message token using MessageTrans, substituting   */
/* parameters with elements from a printf() style formatted   */
/* string. The format string and its parameters are processed */
/* by sprintf() first, then the resulting string is split at  */
/* any line feed characters within it. Each of the resulting  */
/* strings becomes one parameter for the MessageTrans         */
/* parameter substitution.                                    */
/*                                                            */
/* For example, if the message string for the token was       */
/* "First %0, then %1", the format string was "a=%d\nb=%d"    */
/* and the parameters were '1' and '2' then the result would  */
/* be "First a=1, then b=2".                                  */
/*                                                            */
/* If the token is not found it is replaced with a default    */
/* message.                                                   */
/*                                                            */
/* Parameters: Pointer to a buffer to write the output to;    */
/*                                                            */
/*             The size of the buffer;                        */
/*                                                            */
/*             Pointer to the message token;                  */
/*                                                            */
/*             Pointer to the format string;                  */
/*                                                            */
/*             Variable argument list of parameters.          */
/*                                                            */
/* Returns:    Error pointer.                                 */
/*                                                            */
/* Assumes:    The expanded string will be no more than 80    */
/*             characters in length. Longer strings will be   */
/*             truncated.                                     */
/**************************************************************/

_kernel_oserror * messages_lookupf(char * buffer, size_t length,
    const char * token, const char * format, ...)
{
    _kernel_oserror * e;
    va_list           ap;

    va_start(ap, format);
    e = messages_vlookupf(buffer, length, token, format, ap);
    va_end(ap);

    return e;
}

/**************************************************************/
/* find_error()                                               */
/*                                                            */
/* Get a pointer to one of ERR_BLOCKS locally stored error    */
/* blocks, in which error messages can be stored for future   */
/* reference. Each request increments the internal counter    */
/* until it wraps around back to the first error block held.  */
/*                                                            */
/* Returns: Pointer to an error block.                        */
/**************************************************************/

static _kernel_oserror * find_error(void)
{
    static _kernel_oserror global_error_block[ERR_BLOCKS];
    static int             errblock = 0;

    errblock = (errblock+1) % ERR_BLOCKS;
    return &global_error_block[errblock];
}

/**************************************************************/
/* messages_make_error()                                      */
/*                                                            */
/* Builds an error block from a message file token.           */
/* Parameters in the message are substituted by using a       */
/* format string and argument list. See messages_lookupf()    */
/* for a description of how this works.                       */
/*                                                            */
/* Parameters: Pointer to the message token;                  */
/*                                                            */
/*             Error number;                                  */
/*                                                            */
/*             Pointer to the format string;                  */
/*                                                            */
/*             Variable argument list of parameters.          */
/*                                                            */
/* Returns:    Pointer to an error block.                     */
/**************************************************************/

_kernel_oserror * messages_make_error(const char * token, int errno,
    const char * format, ...)
{
    _kernel_oserror * e;

    if (errno == 0)
    {
        e = NULL;
    }
    else
    {
        e = find_error();
    
        /* Put error number in static error block */
        if (errno >= 0x80)
            e->errnum = errno;
        else
            REALLYSETDCI4ERRNO(e->errnum, errno);
    
        va_list ap;
        va_start(ap, format);
        messages_vlookupf(e->errmess, sizeof(e->errmess), token, format, ap);
        va_end(ap);
    }

    return e;
}
@


1.5
log
@  Restructure and tidy up.
Detail:
  This version has no functional changes, but has been considerably
  tidied up to improve commenting and modularity. In particular the
  information printing routines, filtering routines and message
  logging routines have been split out into separate source files.
  The filtering routines have also been re-worked to be more
  comprehensible. Hopefully this will provide a useful base for
  developing future network drivers.
Admin:
  Requires an up-to-date version of BuildSys to build all variants.
  Basic testing indicates it still works, but more long term testing
  to confirm that nothing has been accidentally broken is required.


Version 0.12. Tagged as 'EtherK-0_12'
@
text
@d52 5
a56 5
static uint32_t   msgs_fd[4] = {0, 0, 0, 0}; /* Message file descriptor */
static const char msgs_default_token[] = "TNF:"Module_Title" message not found in messages file";
static const char msgs_path[] = Module_Title "$Path";
static const char msgs_path_filename[] = Module_Title ":Messages";
static const char msgs_resfs_filename[] = "Resources:$.Resources." Module_Title ".Messages";
d59 1
a59 1
/* msgs_init()                                                */
d68 1
a68 1
_kernel_oserror * msgs_init(void)
d86 1
a86 1
    have_path = (getenv(msgs_path) != NULL);
d91 2
a92 2
              msgs_fd,
              have_path ? msgs_path_filename : msgs_resfs_filename,
d110 1
a110 1
/* msgs_quit()                                                */
d117 1
a117 1
void msgs_quit(void)
d124 1
a124 1
          msgs_fd);
d137 1
a137 1
/* msgs_return_message()                                      */
d153 1
a153 1
const char * msgs_return_message(const char * token)
d162 1
a162 1
              msgs_fd,
d181 2
a182 2
                      msgs_fd,
                      msgs_default_token,
d204 1
a204 1
/* msgs_lookup_subst()                                        */
d227 1
a227 1
_kernel_oserror * msgs_lookup_subst(char * buffer, size_t length,
d236 1
a236 1
              msgs_fd,
d253 2
a254 2
                      msgs_fd,
                      msgs_default_token,
d275 1
a275 1
/* msgs_vlookup()                                             */
d300 1
a300 1
_kernel_oserror * msgs_vlookup(char * buffer, size_t length,
d314 1
a314 1
    return msgs_lookup_subst(buffer, length, token, p);
d318 1
a318 1
/* msgs_lookup()                                              */
d342 1
a342 1
_kernel_oserror * msgs_lookup(char * buffer, size_t length,
d349 1
a349 1
    e = msgs_vlookup(buffer, length, token, nparams, ap);
d356 1
a356 1
/* msgs_vlookupf()                                            */
d392 1
a392 1
_kernel_oserror * msgs_vlookupf(char * buffer, size_t length,
d417 1
a417 1
    return msgs_lookup_subst(buffer, length, token, pp);
d421 1
a421 1
/* msgs_lookupf()                                             */
d456 1
a456 1
_kernel_oserror * msgs_lookupf(char * buffer, size_t length,
d463 1
a463 1
    e = msgs_vlookupf(buffer, length, token, format, ap);
d490 1
a490 1
/* msgs_make_error()                                          */
d494 2
a495 2
/* format string and argument list. See msgs_lookupf() for    */
/* a description of how this works.                           */
d508 1
a508 1
_kernel_oserror * msgs_make_error(const char * token, int errno,
d529 1
a529 1
        msgs_vlookupf(e->errmess, sizeof(e->errmess), token, format, ap);
@


1.4
log
@Merge in changes from the latest BSD driver. EtherK is now based on
version 1.4.7 of the FreeBSD 'em' device driver.
Merge in changes from the latest BSD driver. EtherK is now based on version

Version 0.06. Tagged as 'EtherK-0_06'
@
text
@d20 1
a20 1
/* History: 24-Sep-2002 (JRB): Created.                       */
d52 5
a56 6
static uint32_t        msgs_fd[4] = {0, 0, 0, 0}; /* Message file descriptor */
static _kernel_oserror msgs_errblk;
static const char      msgs_default_token[] = "TNF:"Module_Title" message not found in messages file";
static const char      msgs_path[] = Module_Title "$Path";
static const char      msgs_path_filename[] = Module_Title ":Messages";
static const char      msgs_resfs_filename[] = "Resources:$.Resources." Module_Title ".Messages";
d64 2
d137 67
d213 1
a213 1
/* Parameters: Pointer to a buffer to write the output to.    */
d215 1
a215 1
/*             The size of the buffer                         */
d217 1
a217 1
/*             The message token.                             */
d223 2
d226 1
d277 21
a297 2
/* Equivalent to msgs_lookup, but taking a variable argument  */
/* list for the list of strings for substitution.             */
d299 1
d319 21
d341 1
d357 33
d391 1
d422 32
d455 1
d476 2
d493 13
d507 3
a509 1
_kernel_oserror * msgs_make_error(const char * token, int errno, const char * format, ...)
a533 58
}

/**************************************************************/
/* msgs_return_message()                                      */
/*                                                            */
/* Lookup a message through MessageTrans and return a pointer */
/* to the message. Messages looked up this way will need to   */
/* include a null terminator in the messages file, and the    */
/* messages must not be tokenised.                            */
/**************************************************************/
char * msgs_return_message(const char * token)
{
    _kernel_oserror * e;
    char            * ptr;

    /* Look up token */
    e = _swix(MessageTrans_Lookup,
              _INR(0,7) | _OUT(2),
    
              msgs_fd,
              token,
              0,
              0,
              0,
              0,
              0,
              0,

              &ptr);

    /* If the token isn't found, replace with our not found message */
    if (e != NULL)
    {
        if (e->errnum == MessageTrans_TokenNotFound)
        {
            e = _swix(MessageTrans_Lookup,
                      _INR(0,7) | _OUT(2),
            
                      msgs_fd,
                      msgs_default_token,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,

                      &ptr);
        }

        /* Last resort - MessageTrans went wrong, so use its error message */
        if (e != NULL)
        {
            ptr = e->errmess;
        }
    }

    return ptr;
@


1.3
log
@New code drop from James
Adds AutoSense program to integrate with !Configure
Debugging support added to IRQ handlers
Messages tweaked to allow better compression in ROM

Version 0.04. Tagged as 'EtherK-0_04'
@
text
@d24 1
d55 3
d70 1
d85 1
d91 1
a91 1
              "Resources:$.Resources." Module_Title ".Messages",
@


1.2
log
@New drop from James Byrne
Resources capable of being ROMmed and tokenised
Makefile changes
Fix for declaring the wrong MAC address which confused some switches

Version 0.03. Tagged as 'EtherK-0_03'
@
text
@d46 1
a243 1
    char       * p;
d245 1
a245 4
    vsnprintf(params, sizeof(params), format, ap);

    p = params;
    for (int i = 0; *p && i < 4; i++)
d247 4
a250 2
        pp[i] = p;
        while (*p)
d252 2
a253 1
            if (*p++ == '\n')
d255 5
a259 2
                *(p-1) = 0;
                break;
d284 18
d304 1
a304 1
/* Builds an error block from a message file token            */
d306 1
a306 1
_kernel_oserror * msgs_make_error(const char * token, int errno, int nparams, ...)
d308 1
a308 1
    va_list ap;
d310 4
a313 3
    /* Put error number in static error block */
    if (errno >= 0x80)
        msgs_errblk.errnum = errno;
d315 14
a328 1
        REALLYSETDCI4ERRNO(msgs_errblk.errnum, errno);
d330 1
a330 5
    va_start(ap, nparams);
    msgs_vlookup(msgs_errblk.errmess, sizeof(msgs_errblk.errmess), token, nparams, ap);
    va_end(ap);

    return &msgs_errblk;
d337 3
a339 1
/* to the message.                                            */
@


1.1
log
@Messages placed in messages file
Improvements to shared interrupt handling
Makefile updated
Tidied logging

Version 0.02. Tagged as 'EtherK-0_02'
@
text
@d40 1
a40 1
#ifndef ROM_MODULE
d66 1
a66 1
#ifndef ROM_MODULE
d87 1
a87 1
#ifndef ROM_MODULE
d118 1
a118 1
#ifndef ROM_MODULE
@


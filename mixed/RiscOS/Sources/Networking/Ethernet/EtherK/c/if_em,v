head	1.16;
access;
symbols
	EtherK-0_25:1.16
	EtherK-0_24:1.16
	EtherK-0_23:1.16
	EtherK-0_22:1.16
	EtherK-0_21:1.16
	EtherK-0_20:1.16
	EtherK-0_19:1.16
	EtherK-0_18:1.15
	EtherK-0_17:1.15
	EtherK-0_16:1.14
	EtherK-0_15:1.13
	EtherK-0_14:1.13
	RO_5_07:1.13
	EtherK-0_13:1.13
	EtherK-0_12:1.12
	EtherK-0_11:1.11
	EtherK-0_10:1.11
	EtherK-0_09:1.10
	EtherK-0_08:1.9
	EtherK-0_07:1.8
	EtherK-0_06:1.7
	EtherK-0_05:1.6
	EtherK-0_04:1.5
	EtherK-0_03:1.4
	EtherK-0_02:1.3
	EtherK-0_01:1.2
	EtherK-0_00:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.16
date	2006.02.10.16.00.30;	author jbyrne;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.07.23.40.53;	author jballance;	state Exp;
branches;
next	1.14;

1.14
date	2005.09.06.09.26.39;	author jballance;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.06.13.27.24;	author jbyrne;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.02.19.08.21;	author jbyrne;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.18.22.09.49;	author jbyrne;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.20.16.04.06;	author jbyrne;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.18.19.20.52;	author jbyrne;	state Exp;
branches;
next	1.8;

1.8
date	2002.12.13.17.55.54;	author jbyrne;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.11.19.14.02;	author jbyrne;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.04.16.19.10;	author rsprowson;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.21.08.37.49;	author rsprowson;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.14.23.17.20;	author rsprowson;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.09.19.54.04;	author rsprowson;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.09.19.38.10;	author rsprowson;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.09.19.21.37;	author rsprowson;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.09.19.21.37;	author rsprowson;	state Exp;
branches;
next	;


desc
@@


1.16
log
@  Fix a potential hole in em_disable_intr()
Detail:
  if_em.c - Add E1000_WRITE_FLUSH after clearing the interrupt mask bits
  in em_disable_intr(). The lack of this could potentially leave a small
  window of time in which interrupts were enabled and the Ethernet
  controller was capable of generating a new interrupt while already
  in the interrupt handler - something the code assumes cannot happen.
  If this did happen the interrupt handler to be re-entered and ignore
  the interrupt, which would lead to the interrupt line being disabled
  and Ethernet packet reception would stop (as would anything else
  sharing the same interrupt line).

  ekmodule.c - Tidy up a bit by merging multiple calls to PCI_ReadInfo
  during ek_initialise() into a single one.

  Makefile - Add a dependency for EKHdr.h on the CMHG file.
Admin:
  Confirmed working but not thoroughly tested.


Version 0.19. Tagged as 'EtherK-0_19'
@
text
@/**************************************************************************

Copyright (c) 2001-2003, Intel Corporation
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

 3. Neither the name of the Intel Corporation nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

***************************************************************************/

/*$FreeBSD$*/

#ifndef RISCOS
#ifdef LM
#include "if_em.h"
#else
#include <dev/em/if_em.h>
#endif
#else
#include <stdio.h>
#include <string.h>
#include <kernel.h>
#include <swis.h>
#include <Interface/PCI.h>
#include <unixlib.h>
#include "em_riscos.h"
#include "if_em.h"
#include "em_device.h"
#include "log.h"
#endif



/*********************************************************************
 *  Set this to one to display debug statistics                                                   
 *********************************************************************/
#ifndef RISCOS
int             em_display_debug_stats = 0;
#endif

/*********************************************************************
 *  Linked list of board private structures for all NICs found
 *********************************************************************/

#ifndef RISCOS
struct adapter *em_adapter_list = NULL;
#else
static struct adapter *em_adapter_list = NULL;
#endif

/*********************************************************************
 *  Driver version
 *********************************************************************/

#ifndef RISCOS
char em_driver_version[] = "1.7.35";
#endif


/*********************************************************************
 *  PCI Device ID Table
 *
 *  Used by probe to select devices to load on
 *  Last field stores an index into em_strings
 *  Last entry must be all 0s
 *
 *  { Vendor ID, Device ID, SubVendor ID, SubDevice ID, String Index }
 *********************************************************************/

static em_vendor_info_t em_vendor_info_array[] =
{
        /* Intel(R) PRO/1000 Network Connection */
        { 0x8086, 0x1000, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1001, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1004, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1008, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1009, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x100C, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x100D, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x100E, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x100F, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1010, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1011, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1012, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1013, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1015, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1016, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1017, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1018, PCI_ANY_ID, PCI_ANY_ID, 0},
#ifndef RISCOS
/* RISC OS: Leave out 82547EI as we don't include the workaround code */
        { 0x8086, 0x1019, PCI_ANY_ID, PCI_ANY_ID, 0},
#endif
        { 0x8086, 0x101A, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x101D, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x101E, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1026, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1027, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1028, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1075, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1076, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1077, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1078, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x1079, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x107A, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x107B, PCI_ANY_ID, PCI_ANY_ID, 0},
        { 0x8086, 0x107C, PCI_ANY_ID, PCI_ANY_ID, 0},
        /* required last entry */
        { 0, 0, 0, 0, 0}
};

/*********************************************************************
 *  Table of branding strings for all supported NICs.
 *********************************************************************/

#ifndef RISCOS
static char *em_strings[] = {
	"Intel(R) PRO/1000 Network Connection"
};
#endif

/*********************************************************************
 *  Function prototypes            
 *********************************************************************/
#ifndef RISCOS
static int  em_probe(device_t);
static int  em_attach(device_t);
static int  em_detach(device_t);
static int  em_shutdown(device_t);
static void em_intr(void *);
static void em_start(struct ifnet *);
static int  em_ioctl(struct ifnet *, u_long, caddr_t);
static void em_watchdog(struct ifnet *);
static void em_init(void *);
static void em_stop(void *);
static void em_media_status(struct ifnet *, struct ifmediareq *);
static int  em_media_change(struct ifnet *);
#endif
static void em_identify_hardware(struct adapter *);
static int  em_allocate_pci_resources(struct adapter *);
static void em_free_pci_resources(struct adapter *);
#ifndef RISCOS
static void em_local_timer(void *);
#endif
static int  em_hardware_init(struct adapter *);
static void em_setup_interface(device_t, struct adapter *);
#ifndef RISCOS
static int  em_setup_transmit_structures(struct adapter *);
#endif
static void em_initialize_transmit_unit(struct adapter *);
#ifndef RISCOS
static int  em_setup_receive_structures(struct adapter *);
#endif
static void em_initialize_receive_unit(struct adapter *);
static void em_enable_intr(struct adapter *);
static void em_disable_intr(struct adapter *);
#ifndef RISCOS
static void em_free_transmit_structures(struct adapter *);
static void em_free_receive_structures(struct adapter *);
static void em_update_stats_counters(struct adapter *);
static void em_clean_transmit_interrupts(struct adapter *);
static int  em_allocate_receive_structures(struct adapter *);
static int  em_allocate_transmit_structures(struct adapter *);
#endif
static void em_process_receive_interrupts(struct adapter *, int);
#ifndef RISCOS
static void em_receive_checksum(struct adapter *, 
				struct em_rx_desc *,
				struct mbuf *);
static void em_transmit_checksum_setup(struct adapter *,
				       struct mbuf *,
				       u_int32_t *,
				       u_int32_t *);
static void em_set_promisc(struct adapter *);
static void em_disable_promisc(struct adapter *);
#endif
static void em_set_multi(struct adapter *);
#ifndef RISCOS
static void em_print_hw_stats(struct adapter *);
static void em_print_link_status(struct adapter *);
static int  em_get_buf(int i, struct adapter *,
		       struct mbuf *);
#endif
static void em_enable_vlans(struct adapter *);
#ifndef RISCOS
static int  em_encap(struct adapter *, struct mbuf *);
#endif
static void em_smartspeed(struct adapter *);
#ifndef RISCOS
static int  em_82547_fifo_workaround(struct adapter *, int);
static void em_82547_update_fifo_head(struct adapter *, int);
static int  em_82547_tx_fifo_reset(struct adapter *);
static void em_82547_move_tail(void *arg);
static void em_print_debug_info(struct adapter *);
#endif
static int  em_is_valid_ether_addr(u_int8_t *);
#ifndef RISCOS
static int  em_sysctl_stats(SYSCTL_HANDLER_ARGS);
static int  em_sysctl_debug_info(SYSCTL_HANDLER_ARGS);
static u_int32_t em_fill_descriptors (u_int64_t address, 
                              u_int32_t length, 
                              PDESC_ARRAY desc_array);
static int  em_sysctl_int_delay(SYSCTL_HANDLER_ARGS);
static void em_add_int_delay_sysctl(struct adapter *, const char *,
                                    const char *, struct em_int_delay_info *,
                                    int, int); 
#endif

/*********************************************************************
 *  FreeBSD Device Interface Entry Points                    
 *********************************************************************/

#ifndef RISCOS
static device_method_t em_methods[] = {
	/* Device interface */
	DEVMETHOD(device_probe, em_probe),
	DEVMETHOD(device_attach, em_attach),
	DEVMETHOD(device_detach, em_detach),
	DEVMETHOD(device_shutdown, em_shutdown),
	{0, 0}
};

static driver_t em_driver = {
	"em", em_methods, sizeof(struct adapter ),
};

static devclass_t em_devclass;
DRIVER_MODULE(if_em, pci, em_driver, em_devclass, 0, 0);
#endif

/*********************************************************************
 *  Tunable default values.
 *********************************************************************/

#ifndef RISCOS
#define E1000_TICKS_TO_USECS(ticks)     ((1024 * (ticks) + 500) / 1000)
#define E1000_USECS_TO_TICKS(usecs)     ((1000 * (usecs) + 512) / 1024)

static int em_tx_int_delay_dflt = E1000_TICKS_TO_USECS(EM_TIDV);
static int em_rx_int_delay_dflt = E1000_TICKS_TO_USECS(EM_RDTR);
static int em_tx_abs_int_delay_dflt = E1000_TICKS_TO_USECS(EM_TADV);
static int em_rx_abs_int_delay_dflt = E1000_TICKS_TO_USECS(EM_RADV);

TUNABLE_INT("hw.em.tx_int_delay", &em_tx_int_delay_dflt);
TUNABLE_INT("hw.em.rx_int_delay", &em_rx_int_delay_dflt);
TUNABLE_INT("hw.em.tx_abs_int_delay", &em_tx_abs_int_delay_dflt);
TUNABLE_INT("hw.em.rx_abs_int_delay", &em_rx_abs_int_delay_dflt);
#endif

/* sysctl vars */
/*
SYSCTL_INT(_hw, OID_AUTO, em_tx_int_delay, CTLFLAG_RD, &em_tx_int_delay_dflt, 0,
           "Transmit interrupt delay");
SYSCTL_INT(_hw, OID_AUTO, em_rx_int_delay, CTLFLAG_RD, &em_rx_int_delay_dflt, 0,
           "Receive interrupt delay");
SYSCTL_INT(_hw, OID_AUTO, em_tx_abs_int_delay, CTLFLAG_RD, &em_tx_abs_int_delay_dflt, 
	   0, "Transmit absolute interrupt delay");
SYSCTL_INT(_hw, OID_AUTO, em_rx_ans_int_delay, CTLFLAG_RD, &em_rx_abs_int_delay_dflt, 
	   0,
           "Receive absolute interrupt delay");
*/
/*********************************************************************
 *  Device identification routine
 *
 *  em_probe determines if the driver should be loaded on
 *  adapter based on PCI vendor/device id of the adapter.
 *
 *  return 0 on success, positive on failure
 *********************************************************************/

#ifndef RISCOS
static int
#else
int
#endif
em_probe(device_t dev)
{
	em_vendor_info_t *ent;

	u_int16_t       pci_vendor_id = 0;
	u_int16_t       pci_device_id = 0;
	u_int16_t       pci_subvendor_id = 0;
	u_int16_t       pci_subdevice_id = 0;
#ifndef RISCOS
	char            adapter_name[60];
#endif

	INIT_DEBUGOUT("em_probe: begin");

	pci_vendor_id = pci_get_vendor(dev);
	if (pci_vendor_id != EM_VENDOR_ID)
		return(ENXIO);

	pci_device_id = pci_get_device(dev);
	pci_subvendor_id = pci_get_subvendor(dev);
	pci_subdevice_id = pci_get_subdevice(dev);

	ent = em_vendor_info_array;
	while (ent->vendor_id != 0) {
		if ((pci_vendor_id == ent->vendor_id) &&
		    (pci_device_id == ent->device_id) &&

		    ((pci_subvendor_id == ent->subvendor_id) ||
		     (ent->subvendor_id == PCI_ANY_ID)) &&

		    ((pci_subdevice_id == ent->subdevice_id) ||
		     (ent->subdevice_id == PCI_ANY_ID))) {
#ifndef RISCOS
			sprintf(adapter_name, "%s, Version - %s",
				em_strings[ent->index], 
				em_driver_version);
			device_set_desc_copy(dev, adapter_name);
#endif
			return(0);
		}
		ent++;
	}

	return(ENXIO);
}

/*********************************************************************
 *  Device initialization routine
 *
 *  The attach entry point is called when the driver is being loaded.
 *  This routine identifies the type of hardware, allocates all resources 
 *  and initializes the hardware.     
 *  
 *  return 0 on success, positive on failure
 *********************************************************************/

#ifndef RISCOS
static int
#else
int
#endif
em_attach(device_t dev)
{
	struct adapter * adapter;
#ifndef RISCOS
	int             s;
#endif
	int             tsize, rsize;
	int             error = 0;

	INIT_DEBUGOUT("em_attach: begin");
#ifndef RISCOS
	s = splimp();

	/* Allocate, clear, and link in our adapter structure */
	if (!(adapter = device_get_softc(dev))) {
		printf("em: adapter structure allocation failed\n");
		splx(s);
		return(ENOMEM);
	}
	bzero(adapter, sizeof(struct adapter ));
#else
	dev->ignore_irqs = true;

	adapter = &dev->adapter;
	/* Don't clear the structure - it may have MAC address */
#endif
	adapter->dev = dev;
	adapter->osdep.dev = dev;
	adapter->unit = device_get_unit(dev);

	if (em_adapter_list != NULL)
		em_adapter_list->prev = adapter;
	adapter->next = em_adapter_list;
	em_adapter_list = adapter;

#ifndef RISCOS
	/* SYSCTL stuff */
        sysctl_ctx_init(&adapter->sysctl_ctx);
        adapter->sysctl_tree = SYSCTL_ADD_NODE(&adapter->sysctl_ctx,
					       SYSCTL_STATIC_CHILDREN(_hw),
					       OID_AUTO, 
					       device_get_nameunit(dev),
					       CTLFLAG_RD,
					       0, "");
        if (adapter->sysctl_tree == NULL) {
		error = EIO;
		goto err_sysctl;
        }
 
        SYSCTL_ADD_PROC(&adapter->sysctl_ctx,  
			SYSCTL_CHILDREN(adapter->sysctl_tree),
			OID_AUTO, "debug_info", CTLTYPE_INT|CTLFLAG_RW, 
			(void *)adapter, 0,
                        em_sysctl_debug_info, "I", "Debug Information");

	SYSCTL_ADD_PROC(&adapter->sysctl_ctx,  
			SYSCTL_CHILDREN(adapter->sysctl_tree),
			OID_AUTO, "stats", CTLTYPE_INT|CTLFLAG_RW, 
			(void *)adapter, 0,
                        em_sysctl_stats, "I", "Statistics");

	callout_handle_init(&adapter->timer_handle);
	callout_handle_init(&adapter->tx_fifo_timer_handle);
#endif

	/* Determine hardware revision */
	em_identify_hardware(adapter);
      
#ifndef RISCOS
	/* Set up some sysctls for the tunable interrupt delays */
        em_add_int_delay_sysctl(adapter, "rx_int_delay",
            "receive interrupt delay in usecs", &adapter->rx_int_delay,
            E1000_REG_OFFSET(&adapter->hw, RDTR), em_rx_int_delay_dflt);
        em_add_int_delay_sysctl(adapter, "tx_int_delay",
            "transmit interrupt delay in usecs", &adapter->tx_int_delay,
            E1000_REG_OFFSET(&adapter->hw, TIDV), em_tx_int_delay_dflt);
        if (adapter->hw.mac_type >= em_82540) {
                em_add_int_delay_sysctl(adapter, "rx_abs_int_delay",
                    "receive interrupt delay limit in usecs",
                    &adapter->rx_abs_int_delay,
                    E1000_REG_OFFSET(&adapter->hw, RADV),
                    em_rx_abs_int_delay_dflt);
                em_add_int_delay_sysctl(adapter, "tx_abs_int_delay",
                    "transmit interrupt delay limit in usecs",
                    &adapter->tx_abs_int_delay,
                    E1000_REG_OFFSET(&adapter->hw, TADV),
                    em_tx_abs_int_delay_dflt);
        }
#else
        adapter->tx_int_delay.value = EM_TIDV;
        adapter->tx_abs_int_delay.value = EM_TADV;
        adapter->rx_int_delay.value = EM_RDTR;
        adapter->rx_abs_int_delay.value = EM_RADV;
#endif

	/* Parameters (to be read from user) */   
        adapter->num_tx_desc = EM_MAX_TXD;
        adapter->num_rx_desc = EM_MAX_RXD;
        adapter->hw.autoneg = DO_AUTO_NEG;
        adapter->hw.wait_autoneg_complete = WAIT_FOR_AUTO_NEG_DEFAULT;
        adapter->hw.autoneg_advertised = AUTONEG_ADV_DEFAULT;
        adapter->hw.tbi_compatibility_en = TRUE;
        adapter->rx_buffer_len = EM_RXBUFFER_2048;
	
                        
	/* 
	 * These parameters control the automatic generation(Tx) and 
	 * response(Rx) to Ethernet PAUSE frames.
	 */
        adapter->hw.fc_high_water = FC_DEFAULT_HI_THRESH;
        adapter->hw.fc_low_water  = FC_DEFAULT_LO_THRESH;
        adapter->hw.fc_pause_time = FC_DEFAULT_TX_TIMER;
        adapter->hw.fc_send_xon   = TRUE;
        adapter->hw.fc = em_fc_full;
	
	adapter->hw.phy_init_script = 1;
	adapter->hw.phy_reset_disable = FALSE;

#ifndef EM_MASTER_SLAVE
	adapter->hw.master_slave = em_ms_hw_default;
#else
	adapter->hw.master_slave = EM_MASTER_SLAVE;
#endif

	/* 
	 * Set the max frame size assuming standard ethernet 
	 * sized frames 
	 */   
	adapter->hw.max_frame_size = 
		ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN;

	adapter->hw.min_frame_size = 
		MINIMUM_ETHERNET_PACKET_SIZE + ETHER_CRC_LEN;

	/* 
	 * This controls when hardware reports transmit completion 
	 * status. 
	 */
	adapter->hw.report_tx_early = 1;

#ifdef RISCOS
	em_ro_check_options(dev);
#endif


	if (em_allocate_pci_resources(adapter)) {
#ifndef RISCOS
		printf("em%d: Allocation of PCI resources failed\n", 
		       adapter->unit);
#else
		log_message(dev, "Allocation of PCI resources failed");
#endif
		error = ENXIO;
		goto err_pci;
	}

        em_init_eeprom_params(&adapter->hw);

	tsize = EM_ROUNDUP(adapter->num_tx_desc *
			   sizeof(struct em_tx_desc), 4096);

	/* Allocate Transmit Descriptor ring */
	if (!(adapter->tx_desc_base = (struct em_tx_desc *)
	      contigmalloc(tsize, M_DEVBUF, M_NOWAIT, 0, ~0, 
			   PAGE_SIZE, 0))) {
#ifndef RISCOS
		printf("em%d: Unable to allocate TxDescriptor memory\n", 
		       adapter->unit);
#else
		log_message(dev, "Unable to allocate TxDescriptor memory");
#endif
		error = ENOMEM;
		goto err_tx_desc;
	}

	rsize = EM_ROUNDUP(adapter->num_rx_desc *
			   sizeof(struct em_rx_desc), 4096);

	/* Allocate Receive Descriptor ring */
	if (!(adapter->rx_desc_base = (struct em_rx_desc *)
	      contigmalloc(rsize, M_DEVBUF, M_NOWAIT, 0, ~0, 
			   PAGE_SIZE, 0))) {
#ifndef RISCOS
		printf("em%d: Unable to allocate rx_desc memory\n", 
		       adapter->unit);
#else
		log_message(dev, "Unable to allocate rx_desc memory");
#endif
		error = ENOMEM;
		goto err_rx_desc;
	}

	/* Initialize the hardware */
	if (em_hardware_init(adapter)) {
#ifndef RISCOS
		printf("em%d: Unable to initialize the hardware\n",
		       adapter->unit);
#else
		log_message(dev, "Unable to initialise the hardware");
#endif
		error = EIO;
		goto err_hw_init;
	}

	/* Copy the permanent MAC address out of the EEPROM */
	if (em_read_mac_addr(&adapter->hw) < 0) {
#ifndef RISCOS
		printf("em%d: EEPROM read error while reading mac address\n",
		       adapter->unit);
#else
		log_message(dev, "EEPROM read error while reading mac address");
#endif
		error = EIO;
		goto err_mac_addr;
	}

	if (!em_is_valid_ether_addr(adapter->hw.mac_addr)) {
#ifndef RISCOS
		printf("em%d: Invalid mac address\n", adapter->unit);
#else
		log_message(dev, "Invalid mac address");
#endif
		error = EIO;
		goto err_mac_addr;
	}


	bcopy(adapter->hw.mac_addr, adapter->interface_data.ac_enaddr,
	      ETHER_ADDR_LEN);

	/* Setup OS specific network interface */
	em_setup_interface(dev, adapter);

	/* Initialize statistics */
	em_clear_hw_cntrs(&adapter->hw);
	em_update_stats_counters(adapter);
	adapter->hw.get_link_status = 1;
	em_check_for_link(&adapter->hw);

	/* Print the link status */
	if (adapter->link_active == 1) {
		em_get_speed_and_duplex(&adapter->hw, &adapter->link_speed, 
					&adapter->link_duplex);
#ifndef RISCOS
		printf("em%d:  Speed:%d Mbps  Duplex:%s\n",
		       adapter->unit,
		       adapter->link_speed,
		       adapter->link_duplex == FULL_DUPLEX ? "Full" : "Half");
	} else
		printf("em%d:  Speed:N/A  Duplex:N/A\n", adapter->unit);
#else
		log_message(dev, "Speed:%d Mbps  Duplex:%s",
		       adapter->link_speed,
		       adapter->link_duplex == FULL_DUPLEX ? "Full" : "Half");
	} else if (adapter->hw.wait_autoneg_complete)
		log_message(adapter->dev, "Speed:N/A  Duplex:N/A");
#endif

	/* Identify 82544 on PCIX */
 	em_get_bus_info(&adapter->hw);	
	if(adapter->hw.bus_type == em_bus_type_pcix &&
           adapter->hw.mac_type == em_82544) {
                adapter->pcix_82544 = TRUE;
	}
        else {
                adapter->pcix_82544 = FALSE;
 	}	
	INIT_DEBUGOUT("em_attach: end");
#ifndef RISCOS
	splx(s);
#else
	dev->ignore_irqs = false;
#endif
	return(error);


err_mac_addr:
err_hw_init:
	contigfree(adapter->rx_desc_base, rsize, M_DEVBUF);
err_rx_desc:
	contigfree(adapter->tx_desc_base, tsize, M_DEVBUF);
err_tx_desc:
err_pci:
	em_free_pci_resources(adapter);
#ifndef RISCOS
	sysctl_ctx_free(&adapter->sysctl_ctx);
err_sysctl:
        splx(s);
#endif
	return(error);
}

/*********************************************************************
 *  Device removal routine
 *
 *  The detach entry point is called when the driver is being removed.
 *  This routine stops the adapter and deallocates all the resources
 *  that were allocated for driver operation.
 *  
 *  return 0 on success, positive on failure
 *********************************************************************/

#ifndef RISCOS
static int
#else
int
#endif
em_detach(device_t dev)
{
	struct adapter * adapter = device_get_softc(dev);
	struct ifnet   *ifp = &adapter->interface_data.ac_if;
#ifndef RISCOS
	int             s;
#endif
	int             size;

	INIT_DEBUGOUT("em_detach: begin");
#ifndef RISCOS
	s = splimp();
#else
	dev->ignore_irqs = true;
#endif

	adapter->in_detach = 1;

	em_stop(adapter);
	em_phy_hw_reset(&adapter->hw);
#ifndef RISCOS
#if __FreeBSD_version < 500000
        ether_ifdetach(&adapter->interface_data.ac_if, ETHER_BPF_SUPPORTED);
#else
        ether_ifdetach(&adapter->interface_data.ac_if);
#endif
#endif
	em_free_pci_resources(adapter);
#ifndef RISCOS
	bus_generic_detach(dev);
#endif

	size = EM_ROUNDUP(adapter->num_tx_desc *
			  sizeof(struct em_tx_desc), 4096);

	/* Free Transmit Descriptor ring */
	if (adapter->tx_desc_base) {
		contigfree(adapter->tx_desc_base, size, M_DEVBUF);
		adapter->tx_desc_base = NULL;
	}

	size = EM_ROUNDUP(adapter->num_rx_desc *
			  sizeof(struct em_rx_desc), 4096);

	/* Free Receive Descriptor ring */
	if (adapter->rx_desc_base) {
		contigfree(adapter->rx_desc_base, size, M_DEVBUF);
		adapter->rx_desc_base = NULL;
	}

	/* Remove from the adapter list */
	if (em_adapter_list == adapter)
		em_adapter_list = adapter->next;
	if (adapter->next != NULL)
		adapter->next->prev = adapter->prev;
	if (adapter->prev != NULL)
		adapter->prev->next = adapter->next;

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
	ifp->if_timer = 0;

#ifndef RISCOS
	adapter->sysctl_tree = NULL;
	sysctl_ctx_free(&adapter->sysctl_ctx);

	splx(s);
#endif
	return(0);
}

/*********************************************************************
 *
 *  Shutdown entry point
 *
 **********************************************************************/ 

#ifndef RISCOS
static int
em_shutdown(device_t dev)
{
	struct adapter *adapter = device_get_softc(dev);
	em_stop(adapter);
	return(0);
}
#endif


/*********************************************************************
 *  Transmit entry point
 *
 *  em_start is called by the stack to initiate a transmit.
 *  The driver will remain in this routine as long as there are
 *  packets to transmit and transmit resources are available.
 *  In case resources are not available stack is notified and
 *  the packet is requeued.
 **********************************************************************/

#ifndef RISCOS
static void
em_start(struct ifnet *ifp)
{
        int             s;
        struct mbuf    *m_head;
        struct adapter *adapter = ifp->if_softc;

        if (!adapter->link_active)
                return;

        s = splimp();
        while (ifp->if_snd.ifq_head != NULL) {

                IF_DEQUEUE(&ifp->if_snd, m_head);
                
                if (m_head == NULL) break;
                        
		if (em_encap(adapter, m_head)) { 
			ifp->if_flags |= IFF_OACTIVE;
			IF_PREPEND(&ifp->if_snd, m_head);
			break;
                }

		/* Send a copy of the frame to the BPF listener */
#if __FreeBSD_version < 500000
                if (ifp->if_bpf)
                        bpf_mtap(ifp, m_head);
#else
		BPF_MTAP(ifp, m_head);
#endif
        
                /* Set timeout in case hardware has problems transmitting */
                ifp->if_timer = EM_TX_TIMEOUT;
        
        }
        splx(s);
        return;
}
#endif

/*********************************************************************
 *  Ioctl entry point
 *
 *  em_ioctl is called when the user wants to configure the
 *  interface.
 *
 *  return 0 on success, positive on failure
 **********************************************************************/

#ifndef RISCOS
static int
em_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	int             s, mask, error = 0;
	struct ifreq   *ifr = (struct ifreq *) data;
	struct adapter * adapter = ifp->if_softc;

	s = splimp();

	if (adapter->in_detach) goto out;

	switch (command) {
	case SIOCSIFADDR:
	case SIOCGIFADDR:
		IOCTL_DEBUGOUT("ioctl rcv'd: SIOCxIFADDR (Get/Set Interface Addr)");
		ether_ioctl(ifp, command, data);
		break;
	case SIOCSIFMTU:
		IOCTL_DEBUGOUT("ioctl rcv'd: SIOCSIFMTU (Set Interface MTU)");
		if (ifr->ifr_mtu > MAX_JUMBO_FRAME_SIZE - ETHER_HDR_LEN) {
			error = EINVAL;
		} else {
			ifp->if_mtu = ifr->ifr_mtu;
			adapter->hw.max_frame_size = 
			ifp->if_mtu + ETHER_HDR_LEN + ETHER_CRC_LEN;
			em_init(adapter);
		}
		break;
	case SIOCSIFFLAGS:
		IOCTL_DEBUGOUT("ioctl rcv'd: SIOCSIFFLAGS (Set Interface Flags)");
		if (ifp->if_flags & IFF_UP) {
			if (!(ifp->if_flags & IFF_RUNNING)) {
				em_init(adapter);
			}
			em_disable_promisc(adapter);
			em_set_promisc(adapter);
		} else {
			if (ifp->if_flags & IFF_RUNNING) {
				em_stop(adapter);
			}
		}
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		IOCTL_DEBUGOUT("ioctl rcv'd: SIOC(ADD|DEL)MULTI");
		if (ifp->if_flags & IFF_RUNNING) {
			em_disable_intr(adapter);
			em_set_multi(adapter);
			if (adapter->hw.mac_type == em_82542_rev2_0) {
				em_initialize_receive_unit(adapter);
			}
#ifdef DEVICE_POLLING
			if (!(ifp->if_ipending & IFF_POLLING))
#endif
				em_enable_intr(adapter);
		}
		break;
	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		IOCTL_DEBUGOUT("ioctl rcv'd: SIOCxIFMEDIA (Get/Set Interface Media)");
		error = ifmedia_ioctl(ifp, ifr, &adapter->media, command);
		break;
	case SIOCSIFCAP:
		IOCTL_DEBUGOUT("ioctl rcv'd: SIOCSIFCAP (Set Capabilities)");
		mask = ifr->ifr_reqcap ^ ifp->if_capenable;
		if (mask & IFCAP_HWCSUM) {
			if (IFCAP_HWCSUM & ifp->if_capenable)
				ifp->if_capenable &= ~IFCAP_HWCSUM;
			else
				ifp->if_capenable |= IFCAP_HWCSUM;
			if (ifp->if_flags & IFF_RUNNING)
				em_init(adapter);
		}
		break;
	default:
		IOCTL_DEBUGOUT1("ioctl received: UNKNOWN (0x%x)", (int)command);
		error = EINVAL;
	}

out:
	splx(s);
	return(error);
}
#endif

/*********************************************************************
 *  Watchdog entry point
 *
 *  This routine is called whenever hardware quits transmitting.
 *
 **********************************************************************/

#ifndef RISCOS
static void
em_watchdog(struct ifnet *ifp)
{
	struct adapter * adapter;
	adapter = ifp->if_softc;

	/* If we are in this routine because of pause frames, then
	 * don't reset the hardware.
	 */
	if (E1000_READ_REG(&adapter->hw, STATUS) & E1000_STATUS_TXOFF) {
		ifp->if_timer = EM_TX_TIMEOUT;
		return;
	}

	if (em_check_for_link(&adapter->hw))
		printf("em%d: watchdog timeout -- resetting\n", adapter->unit);

	ifp->if_flags &= ~IFF_RUNNING;

	em_stop(adapter);
	em_init(adapter);

	ifp->if_oerrors++;
	return;
}
#endif

/*********************************************************************
 *  Init entry point
 *
 *  This routine is used in two ways. It is used by the stack as
 *  init entry point in network interface structure. It is also used
 *  by the driver as a hw/sw initialization routine to get to a 
 *  consistent state.
 *
 *  return 0 on success, positive on failure
 **********************************************************************/

#ifndef RISCOS
static void
em_init(void *arg)
#else
int em_init(struct adapter * adapter)
#endif
{
#ifndef RISCOS
	int             s;
#endif
	uint32_t	pba;
	struct ifnet   *ifp;
#ifndef RISCOS
	struct adapter * adapter = arg;
#endif

	INIT_DEBUGOUT("em_init: begin");

#ifndef RISCOS
	s = splimp();
#else
	adapter->dev->ignore_irqs = true;
#endif

	em_stop(adapter);

	/* Packet Buffer Allocation (PBA)
	 * Writing PBA sets the receive portion of the buffer
	 * the remainder is used for the transmit buffer.
	 *
	 * Devices before the 82547 had a Packet Buffer of 64K.
	 *   Default allocation: PBA=48K for Rx, leaving 16K for Tx.
	 * After the 82547 the buffer was reduced to 40K.
	 *   Default allocation: PBA=30K for Rx, leaving 10K for Tx.
	 *   Note: default does not leave enough room for Jumbo Frame >10k.
	 */
	if(adapter->hw.mac_type < em_82547) {
		/* Total FIFO is 64K */
		if(adapter->rx_buffer_len > EM_RXBUFFER_8192)
			pba = E1000_PBA_40K; /* 40K for Rx, 24K for Tx */
		else
			pba = E1000_PBA_48K; /* 48K for Rx, 16K for Tx */
	} else {
		/* Total FIFO is 40K */
		if(adapter->hw.max_frame_size > EM_RXBUFFER_8192) {
			pba = E1000_PBA_22K; /* 22K for Rx, 18K for Tx */
		} else {
		        pba = E1000_PBA_30K; /* 30K for Rx, 10K for Tx */
		}
		adapter->tx_fifo_head = 0;
		adapter->tx_head_addr = pba << EM_TX_HEAD_ADDR_SHIFT;
		adapter->tx_fifo_size = (E1000_PBA_40K - pba) << EM_PBA_BYTES_SHIFT;
	}
	INIT_DEBUGOUT1("em_init: pba=%dK",pba);
	E1000_WRITE_REG(&adapter->hw, PBA, pba);
	
	/* Get the latest mac address, User can use a LAA */
	bcopy(adapter->interface_data.ac_enaddr, adapter->hw.mac_addr,
              ETHER_ADDR_LEN);

#ifdef RISCOS
	if (_swix(OS_ReadMonotonicTime, _OUT(0), &adapter->init_start_time) != NULL)
		adapter->init_start_time = 0;
	else if (adapter->init_start_time == 0)
		adapter->init_start_time = 1;
#endif

	/* Initialize the hardware */
	if (em_hardware_init(adapter)) {
#ifndef RISCOS
		printf("em%d: Unable to initialize the hardware\n", 
		       adapter->unit);
		splx(s);
		return;
#else
		log_message(adapter->dev, "Unable to initialize the hardware");
		return EIO;   /* Change to proper error somehow? */
#endif
	}

	em_enable_vlans(adapter);

	/* Prepare transmit descriptors and buffers */
	if (em_setup_transmit_structures(adapter)) {
#ifndef RISCOS
		printf("em%d: Could not setup transmit structures\n", 
		       adapter->unit);
#else
		log_message(adapter->dev, "Could not setup transmit structures");
#endif
		em_stop(adapter); 
#ifndef RISCOS
		splx(s);
		return;
#else
		return ENOMEM;
#endif
	}
	em_initialize_transmit_unit(adapter);

	/* Setup Multicast table */
	em_set_multi(adapter);

	/* Prepare receive descriptors and buffers */
	if (em_setup_receive_structures(adapter)) {
#ifndef RISCOS
		printf("em%d: Could not setup receive structures\n", 
		       adapter->unit);
#else
		log_message(adapter->dev, "Could not setup receive structures");
#endif
		em_stop(adapter);
#ifndef RISCOS
		splx(s);
		return;
#else
		return ENOMEM;
#endif
	}
	em_initialize_receive_unit(adapter);
	
#ifndef RISCOS
	/* Don't loose promiscuous settings */
	em_set_promisc(adapter);
#endif

	ifp = &adapter->interface_data.ac_if;
	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;

#ifndef RISCOS
	if (adapter->hw.mac_type >= em_82543) {
		if (ifp->if_capenable & IFCAP_TXCSUM)
			ifp->if_hwassist = EM_CHECKSUM_FEATURES;
		else
			ifp->if_hwassist = 0;
	}

	adapter->timer_handle = timeout(em_local_timer, adapter, 2*hz);
#else
	adapter->dev->localtimerset = true;
#endif
	em_clear_hw_cntrs(&adapter->hw);
#ifdef DEVICE_POLLING
        /*
         * Only enable interrupts if we are not polling, make sure
         * they are off otherwise.
         */
        if (ifp->if_ipending & IFF_POLLING)
                em_disable_intr(adapter);
        else
#endif /* DEVICE_POLLING */
#ifdef RISCOS
	adapter->dev->ignore_irqs = false;
#endif
	em_enable_intr(adapter);

	/* Don't reset the phy next time init gets called */
	adapter->hw.phy_reset_disable = TRUE;

#ifndef RISCOS
	splx(s);
	return;
#else
	return 0;
#endif
}


#ifdef DEVICE_POLLING
static poll_handler_t em_poll;
        
static void     
em_poll(struct ifnet *ifp, enum poll_cmd cmd, int count)
{
        struct adapter *adapter = ifp->if_softc;
        u_int32_t reg_icr;

        if (cmd == POLL_DEREGISTER) {       /* final call, enable interrupts */
                em_enable_intr(adapter);
                return;
        }
        if (cmd == POLL_AND_CHECK_STATUS) {
                reg_icr = E1000_READ_REG(&adapter->hw, ICR);
                if (reg_icr & (E1000_ICR_RXSEQ | E1000_ICR_LSC)) {
                        untimeout(em_local_timer, adapter, adapter->timer_handle);
                        adapter->hw.get_link_status = 1;
                        em_check_for_link(&adapter->hw);
                        em_print_link_status(adapter);
                        adapter->timer_handle = timeout(em_local_timer, adapter, 2*hz);
                }
        }
        if (ifp->if_flags & IFF_RUNNING) {
                em_process_receive_interrupts(adapter, count);
                em_clean_transmit_interrupts(adapter);
        }
	
        if (ifp->if_flags & IFF_RUNNING && ifp->if_snd.ifq_head != NULL)
                em_start(ifp);
}
#endif /* DEVICE_POLLING */

/*********************************************************************
 *
 *  Interrupt Service routine  
 *
 **********************************************************************/
#ifndef RISCOS
static void
em_intr(void *arg)
#else
int em_intr(struct adapter *adapter)
#endif
{
        u_int32_t       loop_cnt = EM_MAX_INTR;
        u_int32_t       reg_icr;
        struct ifnet    *ifp;
#ifndef RISCOS
        struct adapter  *adapter = arg;
#else
	u_int32_t       reg_ims = E1000_READ_REG(&adapter->hw, IMS);
#ifdef DBG_STATS
	u_int32_t       prev_rx_pkts = adapter->rx_pkts;
	u_int32_t       prev_dropped = adapter->dropped_pkts;
	u_int32_t       prev_mbuf = adapter->mbuf_alloc_failed;
	u_int32_t       prev_unwanted = adapter->dev->stats.st_unwanted_frames;
	u_int32_t       start_time = em_ro_get_time();
#endif
#endif

        ifp = &adapter->interface_data.ac_if;  

#ifdef DEVICE_POLLING
        if (ifp->if_ipending & IFF_POLLING)
                return;

        if (ether_poll_register(em_poll, ifp)) {
                em_disable_intr(adapter);
                em_poll(ifp, 0, 1);
                return;
        }
#endif /* DEVICE_POLLING */

#ifndef RISCOS
	reg_icr = E1000_READ_REG(&adapter->hw, ICR);
	if (!reg_icr) {
		return;
	}
#else
        reg_icr = E1000_READ_REG(&adapter->hw, ICR) & reg_ims;
        if (!reg_icr) {
                /* No interrupt - pass on */
                return 1;
        }
        em_disable_intr(adapter);
        _kernel_irqs_on();

        #ifdef DEBUGLIB
        if (adapter->dev->tx_handler_entered)
                dprintf(("", "Help!! Transmit interrupted!!\n"));
        #endif
#endif

	/* Link status change */
	if (reg_icr & (E1000_ICR_RXSEQ | E1000_ICR_LSC)) {
#ifndef RISCOS
		untimeout(em_local_timer, adapter,
			  adapter->timer_handle);
#else
		adapter->dev->localtimerset = false;
#endif
		adapter->hw.get_link_status = 1;
		em_check_for_link(&adapter->hw);
		em_print_link_status(adapter);
#ifndef RISCOS
		adapter->timer_handle =
		timeout(em_local_timer, adapter, 2*hz);
#else
		adapter->dev->localtimerset = true;
#endif
	}

        while (loop_cnt > 0) {
                if (ifp->if_flags & IFF_RUNNING) {
                        em_process_receive_interrupts(adapter, -1);
                        em_clean_transmit_interrupts(adapter);
                }
                loop_cnt--;
        }

#ifndef RISCOS
        if (ifp->if_flags & IFF_RUNNING && ifp->if_snd.ifq_head != NULL)
                em_start(ifp);

        return;
#else
	/* Interrupts processed - set interrupt state back to disabled and claim */
#ifdef DBG_STATS
#ifndef Mbuf_Statistic
#define Mbuf_Statistic 0x4a583
#endif
	uint32_t end_time = em_ro_get_time();
	uint32_t irq_time = end_time - start_time;
	uint32_t rx_pkts_this_time = adapter->rx_pkts - prev_rx_pkts;
	uint32_t mm_stats[3];

	_swix(Mbuf_Statistic,
	      _INR(0,4),

              1,
              8,
              10,
              mm_stats,
              sizeof(mm_stats));
	dprintf(("IRQStats", "%u-%u (%uus) received=%u, dropped(error)=%u, dropped(filter)=%u, dropped(mbuf)=%u, small mbufs free=%u, large mbufs free=%u\n",
		start_time, end_time, irq_time,
		rx_pkts_this_time,
		(uint32_t)adapter->dropped_pkts - prev_dropped,
		(uint32_t)adapter->dev->stats.st_unwanted_frames - prev_unwanted,
		(uint32_t)adapter->mbuf_alloc_failed - prev_mbuf,
		mm_stats[0],
		mm_stats[2]));
#endif
	_kernel_irqs_off();
	em_enable_intr(adapter);
#ifdef DBG_STATS
	if (rx_pkts_this_time != 0)
	{
		adapter->rx_interrupts++;
		adapter->rx_irq_time += irq_time;
		if (irq_time > adapter->max_rx_irq_time)
			adapter->max_rx_irq_time = irq_time;
		if (rx_pkts_this_time > adapter->max_rx_pkts)
			adapter->max_rx_pkts = rx_pkts_this_time;
	}
	else
	{
		adapter->non_rx_interrupts++;
		adapter->non_rx_irq_time += irq_time;
		if (irq_time > adapter->max_non_rx_irq_time)
			adapter->max_non_rx_irq_time = irq_time;
	}
#endif
	return 0;
#endif
}



/*********************************************************************
 *
 *  Media Ioctl callback
 *
 *  This routine is called whenever the user queries the status of
 *  the interface using ifconfig.
 *
 **********************************************************************/
#ifndef RISCOS
static void
em_media_status(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct adapter * adapter = ifp->if_softc;

	INIT_DEBUGOUT("em_media_status: begin");

	em_check_for_link(&adapter->hw);
	if (E1000_READ_REG(&adapter->hw, STATUS) & E1000_STATUS_LU) {
		if (adapter->link_active == 0) {
			em_get_speed_and_duplex(&adapter->hw, 
						&adapter->link_speed, 
						&adapter->link_duplex);
			adapter->link_active = 1;
		}
	} else {
		if (adapter->link_active == 1) {
			adapter->link_speed = 0;
			adapter->link_duplex = 0;
			adapter->link_active = 0;
		}
	}

	ifmr->ifm_status = IFM_AVALID;
	ifmr->ifm_active = IFM_ETHER;

	if (!adapter->link_active)
		return;

	ifmr->ifm_status |= IFM_ACTIVE;

	if (adapter->hw.media_type == em_media_type_fiber) {
		ifmr->ifm_active |= IFM_1000_SX | IFM_FDX;
	} else {
		switch (adapter->link_speed) {
		case 10:
			ifmr->ifm_active |= IFM_10_T;
			break;
		case 100:
			ifmr->ifm_active |= IFM_100_TX;
			break;
		case 1000:
#if __FreeBSD_version < 500000 
			ifmr->ifm_active |= IFM_1000_TX;
#else
			ifmr->ifm_active |= IFM_1000_T;
#endif
			break;
		}
		if (adapter->link_duplex == FULL_DUPLEX)
			ifmr->ifm_active |= IFM_FDX;
		else
			ifmr->ifm_active |= IFM_HDX;
	}
	return;
}
#endif

/*********************************************************************
 *
 *  Media Ioctl callback
 *
 *  This routine is called when the user changes speed/duplex using
 *  media/mediopt option with ifconfig.
 *
 **********************************************************************/
#ifndef RISCOS
static int
em_media_change(struct ifnet *ifp)
{
	struct adapter * adapter = ifp->if_softc;
	struct ifmedia  *ifm = &adapter->media;

	INIT_DEBUGOUT("em_media_change: begin");

	if (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)
		return(EINVAL);

	switch (IFM_SUBTYPE(ifm->ifm_media)) {
	case IFM_AUTO:
		adapter->hw.autoneg = DO_AUTO_NEG;
		adapter->hw.autoneg_advertised = AUTONEG_ADV_DEFAULT;
		break;
	case IFM_1000_SX:
#if __FreeBSD_version < 500000 
	case IFM_1000_TX:
#else
	case IFM_1000_T:
#endif
		adapter->hw.autoneg = DO_AUTO_NEG;
		adapter->hw.autoneg_advertised = ADVERTISE_1000_FULL;
		break;
	case IFM_100_TX:
		adapter->hw.autoneg = FALSE;
		adapter->hw.autoneg_advertised = 0;
		if ((ifm->ifm_media & IFM_GMASK) == IFM_FDX)
			adapter->hw.forced_speed_duplex = em_100_full;
		else
			adapter->hw.forced_speed_duplex	= em_100_half;
		break;
	case IFM_10_T:
		adapter->hw.autoneg = FALSE;
		adapter->hw.autoneg_advertised = 0;
		if ((ifm->ifm_media & IFM_GMASK) == IFM_FDX)
			adapter->hw.forced_speed_duplex = em_10_full;
		else
			adapter->hw.forced_speed_duplex	= em_10_half;
		break;
	default:
		printf("em%d: Unsupported media type\n", adapter->unit);
	}

	/* As the speed/duplex settings my have changed we nee to
	 * reset the PHY.
	 */
	adapter->hw.phy_reset_disable = FALSE;

	em_init(adapter);

	return(0);
}
#endif

/*********************************************************************
 *
 *  This routine maps the mbufs to tx descriptors.
 *
 *  return 0 on success, positive on failure
 **********************************************************************/

#ifndef RISCOS
static int
em_encap(struct adapter *adapter, struct mbuf *m_head)
{ 
        vm_offset_t     virtual_addr;
        u_int32_t       txd_upper;
        u_int32_t       txd_lower;
        int             txd_used, i, txd_saved;
        struct mbuf     *mp;
	u_int64_t	address;

/* For 82544 Workaround */
    	DESC_ARRAY              desc_array;
    	u_int32_t               array_elements;
    	u_int32_t               counter;

#if __FreeBSD_version < 500000
        struct ifvlan *ifv = NULL;
#else
        struct m_tag    *mtag;
#endif
        struct em_buffer   *tx_buffer = NULL;
        struct em_tx_desc *current_tx_desc = NULL;
        struct ifnet   *ifp = &adapter->interface_data.ac_if;

	/* 
	 * Force a cleanup if number of TX descriptors 
	 * available hits the threshold 
	 */
	if (adapter->num_tx_desc_avail <= EM_TX_CLEANUP_THRESHOLD)
		em_clean_transmit_interrupts(adapter);

	if (adapter->num_tx_desc_avail <= EM_TX_CLEANUP_THRESHOLD) {
		adapter->no_tx_desc_avail1++;
		return (ENOBUFS);
	}

	if (ifp->if_hwassist > 0) {
		em_transmit_checksum_setup(adapter,  m_head,
					   &txd_upper, &txd_lower);
	}
	else 
		txd_upper = txd_lower = 0;


        /* Find out if we are in vlan mode */
#if __FreeBSD_version < 500000
        if ((m_head->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&
            m_head->m_pkthdr.rcvif != NULL &&
            m_head->m_pkthdr.rcvif->if_type == IFT_L2VLAN)
                ifv = m_head->m_pkthdr.rcvif->if_softc;
#else
	mtag = VLAN_OUTPUT_TAG(ifp, m_head);
#endif

	i = adapter->next_avail_tx_desc;
	txd_saved = i;
	txd_used = 0;

	for (mp = m_head; mp != NULL; mp = mp->m_next) {
		if (mp->m_len == 0)
			continue;
	/* If adapter is 82544 and on PCIX bus */ 	
        	if(adapter->pcix_82544) {
			array_elements = 0;
			virtual_addr= mtod(mp, vm_offset_t);
			address = vtophys(virtual_addr);
			/* Check the Address and Length combination and split the data accordingly */
			array_elements = em_fill_descriptors(
			  address,
                          mp->m_len,  
                          &desc_array);

			for (counter = 0; counter < array_elements; counter++) {
				if (txd_used == adapter->num_tx_desc_avail) {
                               		 adapter->next_avail_tx_desc = txd_saved;
                              		  adapter->no_tx_desc_avail2++;
                              		  return (ENOBUFS);
                        	}

				tx_buffer = &adapter->tx_buffer_area[i];
	               		current_tx_desc = &adapter->tx_desc_base[i];
           			/*  Put in the buffer address*/
           			current_tx_desc->buffer_addr = desc_array.descriptor[counter].address;
           		 	/*  Put in the length */
           		   	current_tx_desc->lower.data = (adapter->txd_cmd | txd_lower 
						| (u_int16_t)desc_array.descriptor[counter].length);
				current_tx_desc->upper.data = (txd_upper);	
				if (++i == adapter->num_tx_desc)
       		                	 i = 0;
                		tx_buffer->m_head = NULL;
                		txd_used++;
			}
        	}
		else {
			if (txd_used == adapter->num_tx_desc_avail) {
                       		 adapter->next_avail_tx_desc = txd_saved;
                       		 adapter->no_tx_desc_avail2++;
                       		 return (ENOBUFS);
               		 }

			tx_buffer = &adapter->tx_buffer_area[i];
			current_tx_desc = &adapter->tx_desc_base[i];
			virtual_addr = mtod(mp, vm_offset_t);
			current_tx_desc->buffer_addr = vtophys(virtual_addr);
			current_tx_desc->lower.data = (adapter->txd_cmd | txd_lower | mp->m_len);
			current_tx_desc->upper.data = (txd_upper);

			if (++i == adapter->num_tx_desc)
				i = 0;

			tx_buffer->m_head = NULL;

			txd_used++;
		}
	}
        adapter->num_tx_desc_avail -= txd_used;
        adapter->next_avail_tx_desc = i;

#if __FreeBSD_version < 500000
        if (ifv != NULL) {
                /* Set the vlan id */
                current_tx_desc->upper.fields.special = ifv->ifv_tag;
#else
        if (mtag != NULL) {
                /* Set the vlan id */
                current_tx_desc->upper.fields.special = VLAN_TAG_VALUE(mtag);
#endif
                /* Tell hardware to add tag */
                current_tx_desc->lower.data |= E1000_TXD_CMD_VLE;
        }

	tx_buffer->m_head = m_head;
	
	/* 
	 * Last Descriptor of Packet needs End Of Packet (EOP)
	 */
	current_tx_desc->lower.data |= (E1000_TXD_CMD_EOP);

	/* 
	 * Advance the Transmit Descriptor Tail (Tdt), this tells the E1000
	 * that this frame is available to transmit.
	 */
	if (adapter->hw.mac_type == em_82547 &&
	    adapter->link_duplex == HALF_DUPLEX) {
		em_82547_move_tail(adapter);
	}
	else {
		E1000_WRITE_REG(&adapter->hw, TDT, i);
		if (adapter->hw.mac_type == em_82547) {
			em_82547_update_fifo_head(adapter, m_head->m_pkthdr.len);
		}
	}

	return (0);
}
#endif


/*********************************************************************
 *
 * 82547 workaround to avoid controller hang in half-duplex environment.
 * The workaround is to avoid queuing a large packet that would span   
 * the internal Tx FIFO ring boundary. We need to reset the FIFO pointers
 * in this case. We do that only when FIFO is queiced.
 *
 **********************************************************************/
#ifndef RISCOS
static void
em_82547_move_tail(void *arg)
{
	int s;
	struct adapter *adapter = arg;
	uint16_t hw_tdt;
	uint16_t sw_tdt;
	struct em_tx_desc *tx_desc;
	uint16_t length = 0;
	boolean_t eop = 0;

	s = splimp();
	hw_tdt = E1000_READ_REG(&adapter->hw, TDT);
	sw_tdt = adapter->next_avail_tx_desc;
	
	while (hw_tdt != sw_tdt) {
		tx_desc = &adapter->tx_desc_base[hw_tdt];
		length += tx_desc->lower.flags.length;
		eop = tx_desc->lower.data & E1000_TXD_CMD_EOP;
		if(++hw_tdt == adapter->num_tx_desc)
			hw_tdt = 0;

		if(eop) {
			if (em_82547_fifo_workaround(adapter, length)) {
				adapter->tx_fifo_wrk_cnt++;
				adapter->tx_fifo_timer_handle = 
					timeout(em_82547_move_tail,
						adapter, 1);
				splx(s);
				return;
			}
			else {
				E1000_WRITE_REG(&adapter->hw, TDT, hw_tdt);
				em_82547_update_fifo_head(adapter, length);
				length = 0;
			}
		}
	}	
	splx(s);
	return;
}

static int
em_82547_fifo_workaround(struct adapter *adapter, int len)
{	
	int fifo_space, fifo_pkt_len;

	fifo_pkt_len = EM_ROUNDUP(len + EM_FIFO_HDR, EM_FIFO_HDR);

	if (adapter->link_duplex == HALF_DUPLEX) {
		fifo_space = adapter->tx_fifo_size - adapter->tx_fifo_head;

		if (fifo_pkt_len >= (EM_82547_PKT_THRESH + fifo_space)) {
			if (em_82547_tx_fifo_reset(adapter)) {
				return(0);
			}
			else {
				return(1);
			}
		}
	}

	return(0);
}

static void
em_82547_update_fifo_head(struct adapter *adapter, int len)
{
	int fifo_pkt_len = EM_ROUNDUP(len + EM_FIFO_HDR, EM_FIFO_HDR);
	
	/* tx_fifo_head is always 16 byte aligned */
	adapter->tx_fifo_head += fifo_pkt_len;
	if (adapter->tx_fifo_head >= adapter->tx_fifo_size) {
		adapter->tx_fifo_head -= adapter->tx_fifo_size;
	}

	return;
}


static int
em_82547_tx_fifo_reset(struct adapter *adapter)
{	
	uint32_t tctl;

	if ( (E1000_READ_REG(&adapter->hw, TDT) ==
	      E1000_READ_REG(&adapter->hw, TDH)) &&
	     (E1000_READ_REG(&adapter->hw, TDFT) == 
	      E1000_READ_REG(&adapter->hw, TDFH)) &&
	     (E1000_READ_REG(&adapter->hw, TDFTS) ==
	      E1000_READ_REG(&adapter->hw, TDFHS)) &&
	     (E1000_READ_REG(&adapter->hw, TDFPC) == 0)) {

		/* Disable TX unit */
		tctl = E1000_READ_REG(&adapter->hw, TCTL);
		E1000_WRITE_REG(&adapter->hw, TCTL, tctl & ~E1000_TCTL_EN);

		/* Reset FIFO pointers */
		E1000_WRITE_REG(&adapter->hw, TDFT,  adapter->tx_head_addr);
		E1000_WRITE_REG(&adapter->hw, TDFH,  adapter->tx_head_addr);
		E1000_WRITE_REG(&adapter->hw, TDFTS, adapter->tx_head_addr);
		E1000_WRITE_REG(&adapter->hw, TDFHS, adapter->tx_head_addr);

		/* Re-enable TX unit */
		E1000_WRITE_REG(&adapter->hw, TCTL, tctl);
		E1000_WRITE_FLUSH(&adapter->hw);

		adapter->tx_fifo_head = 0;
		adapter->tx_fifo_reset_cnt++;

		return(TRUE);
	}
	else {
		return(FALSE);
	}
}
#endif

#ifndef RISCOS
static void
em_set_promisc(struct adapter * adapter)
{

	u_int32_t       reg_rctl;
	u_int32_t       ctrl;
	struct ifnet   *ifp = &adapter->interface_data.ac_if;

	reg_rctl = E1000_READ_REG(&adapter->hw, RCTL);
	ctrl = E1000_READ_REG(&adapter->hw, CTRL);

	if (ifp->if_flags & IFF_PROMISC) {
		reg_rctl |= (E1000_RCTL_UPE | E1000_RCTL_MPE);
		E1000_WRITE_REG(&adapter->hw, RCTL, reg_rctl);
		
		/* Disable VLAN stripping in promiscous mode 
		 * This enables bridging of vlan tagged frames to occur 
		 * and also allows vlan tags to be seen in tcpdump
		 */
		ctrl &= ~E1000_CTRL_VME; 
		E1000_WRITE_REG(&adapter->hw, CTRL, ctrl);

	} else if (ifp->if_flags & IFF_ALLMULTI) {
		reg_rctl |= E1000_RCTL_MPE;
		reg_rctl &= ~E1000_RCTL_UPE;
		E1000_WRITE_REG(&adapter->hw, RCTL, reg_rctl);
	}

	return;
}
#endif

#ifndef RISCOS
static void
em_disable_promisc(struct adapter * adapter)
{
	u_int32_t       reg_rctl;

	reg_rctl = E1000_READ_REG(&adapter->hw, RCTL);

	reg_rctl &=  (~E1000_RCTL_UPE);
	reg_rctl &=  (~E1000_RCTL_MPE);
	E1000_WRITE_REG(&adapter->hw, RCTL, reg_rctl);

	em_enable_vlans(adapter);
	return;
}
#endif


/*********************************************************************
 *  Multicast Update
 *
 *  This routine is called whenever multicast address list is updated.
 *
 **********************************************************************/

static void
em_set_multi(struct adapter * adapter)
{
        u_int32_t reg_rctl = 0;
        u_int8_t  mta[MAX_NUM_MULTICAST_ADDRESSES * ETH_LENGTH_OF_ADDRESS];
#ifndef RISCOS
        struct ifmultiaddr  *ifma;
#endif
        int mcnt = 0;
#ifndef RISCOS
        struct ifnet   *ifp = &adapter->interface_data.ac_if;
#endif
    
        IOCTL_DEBUGOUT("em_set_multi: begin");
 
        if (adapter->hw.mac_type == em_82542_rev2_0) {
                reg_rctl = E1000_READ_REG(&adapter->hw, RCTL);
                if (adapter->hw.pci_cmd_word & CMD_MEM_WRT_INVALIDATE) { 
                        em_pci_clear_mwi(&adapter->hw);
                }
                reg_rctl |= E1000_RCTL_RST;
                E1000_WRITE_REG(&adapter->hw, RCTL, reg_rctl);
                msec_delay(5);
        }
        
#ifndef RISCOS
#if __FreeBSD_version < 500000
        LIST_FOREACH(ifma, &ifp->if_multiaddrs, ifma_link) {
#else
        TAILQ_FOREACH(ifma, &ifp->if_multiaddrs, ifma_link) {
#endif  
                if (ifma->ifma_addr->sa_family != AF_LINK)
                        continue;

		if (mcnt == MAX_NUM_MULTICAST_ADDRESSES) break;

                bcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),
                      &mta[mcnt*ETH_LENGTH_OF_ADDRESS], ETH_LENGTH_OF_ADDRESS);
                mcnt++;
        }
#endif

        if (mcnt >= MAX_NUM_MULTICAST_ADDRESSES) {
                reg_rctl = E1000_READ_REG(&adapter->hw, RCTL);
                reg_rctl |= E1000_RCTL_MPE;
                E1000_WRITE_REG(&adapter->hw, RCTL, reg_rctl);
        } else
                em_mc_addr_list_update(&adapter->hw, mta, mcnt, 0, 1);

        if (adapter->hw.mac_type == em_82542_rev2_0) {
                reg_rctl = E1000_READ_REG(&adapter->hw, RCTL);
                reg_rctl &= ~E1000_RCTL_RST;
                E1000_WRITE_REG(&adapter->hw, RCTL, reg_rctl);
                msec_delay(5);
                if (adapter->hw.pci_cmd_word & CMD_MEM_WRT_INVALIDATE) {
                        em_pci_set_mwi(&adapter->hw);
                }
        }

        return;
}


/*********************************************************************
 *  Timer routine
 *
 *  This routine checks for link status and updates statistics.
 *
 **********************************************************************/

#ifndef RISCOS
static void
em_local_timer(void *arg)
#else
void
em_local_timer(struct adapter * adapter)
#endif
{
	int s;
#ifndef RISCOS
	struct ifnet   *ifp;
	struct adapter * adapter = arg;
	ifp = &adapter->interface_data.ac_if;
#endif

	s = splimp();

	em_check_for_link(&adapter->hw);
	em_print_link_status(adapter);
	em_update_stats_counters(adapter);   
#ifndef RISCOS
	if (em_display_debug_stats && ifp->if_flags & IFF_RUNNING) {
		em_print_hw_stats(adapter);
	}
#endif
	em_smartspeed(adapter);

#ifndef RISCOS
	adapter->timer_handle = timeout(em_local_timer, adapter, 2*hz);
#endif

	splx(s);
	return;
}

#ifndef RISCOS
static void
#else
void
#endif
em_print_link_status(struct adapter * adapter)
{
	if (E1000_READ_REG(&adapter->hw, STATUS) & E1000_STATUS_LU) {
		if (adapter->link_active == 0) {
			em_get_speed_and_duplex(&adapter->hw, 
						&adapter->link_speed, 
						&adapter->link_duplex);
#ifndef RISCOS
			printf("em%d: Link is up %d Mbps %s\n",
			       adapter->unit,
			       adapter->link_speed,
			       ((adapter->link_duplex == FULL_DUPLEX) ?
				"Full Duplex" : "Half Duplex"));
#else
			log_message(adapter->dev, "Link is up %d Mbps %s",
			       adapter->link_speed,
			       ((adapter->link_duplex == FULL_DUPLEX) ?
				"Full Duplex" : "Half Duplex"));
#endif
			adapter->link_active = 1;
			adapter->smartspeed = 0;
		}
	} else {
		if (adapter->link_active == 1) {
			adapter->link_speed = 0;
			adapter->link_duplex = 0;
#ifndef RISCOS
			printf("em%d: Link is Down\n", adapter->unit);
#else
			log_message(adapter->dev, "Link is Down");
			adapter->dev->stats.st_link_failures++;
#endif
			adapter->link_active = 0;
		}
	}

	return;
}

/*********************************************************************
 *
 *  This routine disables all traffic on the adapter by issuing a
 *  global reset on the MAC and deallocates TX/RX buffers. 
 *
 **********************************************************************/

#ifndef RISCOS
static void
em_stop(void *arg)
#else
void em_stop(struct adapter * adapter)
#endif
{
	struct ifnet   *ifp;
#ifndef RISCOS
	struct adapter * adapter = arg;
#endif
	ifp = &adapter->interface_data.ac_if;

	INIT_DEBUGOUT("em_stop: begin");
	em_disable_intr(adapter);
	em_reset_hw(&adapter->hw);
#ifndef RISCOS
	untimeout(em_local_timer, adapter, adapter->timer_handle);	
	untimeout(em_82547_move_tail, adapter, 
		  adapter->tx_fifo_timer_handle);
#else
	adapter->dev->localtimerset = false;
#endif
	em_free_transmit_structures(adapter);
	em_free_receive_structures(adapter);


	/* Tell the stack that the interface is no longer active */
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);

	return;
}


/*********************************************************************
 *
 *  Determine hardware revision.
 *
 **********************************************************************/
static void
em_identify_hardware(struct adapter * adapter)
{
	device_t dev = adapter->dev;

	/* Make sure our PCI config space has the necessary stuff set */
	adapter->hw.pci_cmd_word = pci_read_config(dev, PCIR_COMMAND, 2);
	if (!((adapter->hw.pci_cmd_word & PCIM_CMD_BUSMASTEREN) &&
	      (adapter->hw.pci_cmd_word & PCIM_CMD_MEMEN))) {
#ifndef RISCOS
		printf("em%d: Memory Access and/or Bus Master bits were not set!\n", 
		       adapter->unit);
#else
		log_message(adapter->dev, "Memory Access and/or Bus Master bits were not set!");
#endif
		adapter->hw.pci_cmd_word |= 
		(PCIM_CMD_BUSMASTEREN | PCIM_CMD_MEMEN);
		pci_write_config(dev, PCIR_COMMAND, adapter->hw.pci_cmd_word, 2);
	}

	/* Save off the information about this board */
	adapter->hw.vendor_id = pci_get_vendor(dev);
	adapter->hw.device_id = pci_get_device(dev);
	adapter->hw.revision_id = pci_read_config(dev, PCIR_REVID, 1);
	adapter->hw.subsystem_vendor_id = pci_read_config(dev, PCIR_SUBVEND_0, 2);
	adapter->hw.subsystem_id = pci_read_config(dev, PCIR_SUBDEV_0, 2);

	/* Identify the MAC */
   if (em_set_mac_type(&adapter->hw))
#ifndef RISCOS
           printf("em%d: Unknown MAC Type\n", adapter->unit);
#else
           log_message(adapter->dev, "Unknown MAC Type");
#endif

   if(adapter->hw.mac_type == em_82541 || adapter->hw.mac_type == em_82541_rev_2 ||
      adapter->hw.mac_type == em_82547 || adapter->hw.mac_type == em_82547_rev_2)
		   adapter->hw.phy_init_script = TRUE;


        return;
}

static int
em_allocate_pci_resources(struct adapter * adapter)
{
	int             i, val, rid;
	device_t        dev = adapter->dev;

#ifndef RISCOS
	rid = EM_MMBA;
	adapter->res_memory = bus_alloc_resource(dev, SYS_RES_MEMORY,
						 &rid, 0, ~0, 1,
						 RF_ACTIVE);
	if (!(adapter->res_memory)) {
		printf("em%d: Unable to allocate bus resource: memory\n", 
		       adapter->unit);
		return(ENXIO);
	}
	adapter->osdep.mem_bus_space_tag = 
	rman_get_bustag(adapter->res_memory);
	adapter->osdep.mem_bus_space_handle = 
	rman_get_bushandle(adapter->res_memory);
	adapter->hw.hw_addr = (uint8_t *)&adapter->osdep.mem_bus_space_handle;
#else
	if (!em_ro_get_pci_hw_address(dev, &adapter->hw.hw_addr))
		return(ENXIO);

	dprintf(("Init", "%s: hw_addr=&%08X\n", __func__, (unsigned)adapter->hw.hw_addr));
#endif

	if (adapter->hw.mac_type > em_82543) {
		/* Figure our where our IO BAR is ? */
		rid = EM_MMBA;
		for (i = 0; i < 5; i++) {
			val = pci_read_config(dev, rid, 4);
			if (val & 0x00000001) {
				adapter->io_rid = rid;
				break;
			}
			rid += 4;
		}

#ifndef RISCOS
		adapter->res_ioport = bus_alloc_resource(dev, SYS_RES_IOPORT,  
							 &adapter->io_rid, 0, ~0, 1,
							 RF_ACTIVE);   
		if (!(adapter->res_ioport)) {
			printf("em%d: Unable to allocate bus resource: ioport\n",
			       adapter->unit);
			return(ENXIO);  
		}

		adapter->hw.io_base =
		rman_get_start(adapter->res_ioport);
#else
		uint32_t address;
		if (!em_ro_get_pci_io_address(dev, (adapter->io_rid - EM_MMBA) / 4, &address))
			return(ENXIO);
		adapter->hw.io_base = address;

		dprintf(("Init", "%s: io_base=&%08X\n", __func__, (unsigned)address));
#endif
	}

#ifndef RISCOS
	rid = 0x0;
	adapter->res_interrupt = bus_alloc_resource(dev, SYS_RES_IRQ,
						    &rid, 0, ~0, 1,
						    RF_SHAREABLE | RF_ACTIVE);
	if (!(adapter->res_interrupt)) {
		printf("em%d: Unable to allocate bus resource: interrupt\n", 
		       adapter->unit);
		return(ENXIO);
	}
	if (bus_setup_intr(dev, adapter->res_interrupt, INTR_TYPE_NET,
			   (void (*)(void *)) em_intr, adapter,
			   &adapter->int_handler_tag)) {
		printf("em%d: Error registering interrupt handler!\n", 
		       adapter->unit);
		return(ENXIO);
	}
#else
	if (!em_ro_setup_intr(dev))
		return(ENXIO);
#endif

	adapter->hw.back = &adapter->osdep;

	return(0);
}

static void
em_free_pci_resources(struct adapter * adapter)
{
	device_t dev = adapter->dev;

#ifndef RISCOS
	if (adapter->res_interrupt != NULL) {
		bus_teardown_intr(dev, adapter->res_interrupt, 
				  adapter->int_handler_tag);
		bus_release_resource(dev, SYS_RES_IRQ, 0, 
				     adapter->res_interrupt);
	}
	if (adapter->res_memory != NULL) {
		bus_release_resource(dev, SYS_RES_MEMORY, EM_MMBA, 
				     adapter->res_memory);
	}

	if (adapter->res_ioport != NULL) {
		bus_release_resource(dev, SYS_RES_IOPORT, adapter->io_rid, 
				     adapter->res_ioport);
	}
#else
	em_ro_teardown_intr(dev);
#endif
	return;
}

/*********************************************************************
 *
 *  Initialize the hardware to a configuration as specified by the
 *  adapter structure. The controller is reset, the EEPROM is
 *  verified, the MAC address is set, then the shared initialization
 *  routines are called.
 *
 **********************************************************************/
static int
em_hardware_init(struct adapter * adapter)
{
	INIT_DEBUGOUT("em_hardware_init: begin");
	/* Issue a global reset */
	em_reset_hw(&adapter->hw);

	/* When hardware is reset, fifo_head is also reset */
	adapter->tx_fifo_head = 0;

	/* Make sure we have a good EEPROM before we read from it */
	if (em_validate_eeprom_checksum(&adapter->hw) < 0) {
#ifndef RISCOS
		printf("em%d: The EEPROM Checksum Is Not Valid\n",
		       adapter->unit);
#else
		log_message(adapter->dev, "The EEPROM Checksum Is Not Valid");
#endif
		return(EIO);
	}

	if (em_read_part_num(&adapter->hw, &(adapter->part_num)) < 0) {
#ifndef RISCOS
		printf("em%d: EEPROM read error while reading part number\n",
		       adapter->unit);
#else
		log_message(adapter->dev, "EEPROM read error while reading part number");
#endif
		return(EIO);
	}

	if (em_init_hw(&adapter->hw) < 0) {
#ifndef RISCOS
		printf("em%d: Hardware Initialization Failed",
		       adapter->unit);
#else
		log_message(adapter->dev, "Hardware Initialization Failed");
#endif
		return(EIO);
	}

	em_check_for_link(&adapter->hw);
	if (E1000_READ_REG(&adapter->hw, STATUS) & E1000_STATUS_LU)
		adapter->link_active = 1;
	else
		adapter->link_active = 0;

	if (adapter->link_active) {
		em_get_speed_and_duplex(&adapter->hw, 
					&adapter->link_speed, 
					&adapter->link_duplex);
	} else {
		adapter->link_speed = 0;
		adapter->link_duplex = 0;
	}

	return(0);
}

/*********************************************************************
 *
 *  Setup networking device structure and register an interface.
 *
 **********************************************************************/
static void
em_setup_interface(device_t dev, struct adapter * adapter)
{
	struct ifnet   *ifp;
#ifdef RISCOS
	(void)dev;
#endif
	INIT_DEBUGOUT("em_setup_interface: begin");

	ifp = &adapter->interface_data.ac_if;
#ifndef RISCOS
#if __FreeBSD_version >= 502000
	if_initname(ifp, device_get_name(dev), device_get_unit(dev));
#else
	ifp->if_unit = adapter->unit;
	ifp->if_name = "em";
#endif
#else
	ifp->if_unit = adapter->unit;
	ifp->if_name = "em";
#endif
	ifp->if_mtu = ETHERMTU;
#ifndef RISCOS
	ifp->if_output = ether_output;
#endif
	ifp->if_baudrate = 1000000000;
#ifndef RISCOS
	ifp->if_init =  em_init;
	ifp->if_softc = adapter;
#endif
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
#ifndef RISCOS
	ifp->if_ioctl = em_ioctl;
	ifp->if_start = em_start;
	ifp->if_watchdog = em_watchdog;
	ifp->if_snd.ifq_maxlen = adapter->num_tx_desc - 1;

#if __FreeBSD_version < 500000
        ether_ifattach(ifp, ETHER_BPF_SUPPORTED);
#else
        ether_ifattach(ifp, adapter->interface_data.ac_enaddr);
#endif

	if (adapter->hw.mac_type >= em_82543) {
		ifp->if_capabilities = IFCAP_HWCSUM;
		ifp->if_capenable = ifp->if_capabilities;
	}

 	/*
         * Tell the upper layer(s) we support long frames.
         */
        ifp->if_data.ifi_hdrlen = sizeof(struct ether_vlan_header);
#if __FreeBSD_version >= 500000
        ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU;
#endif


	/* 
	 * Specify the media types supported by this adapter and register
	 * callbacks to update media and link information
	 */
	ifmedia_init(&adapter->media, IFM_IMASK, em_media_change,
		     em_media_status);
	if (adapter->hw.media_type == em_media_type_fiber) {
		ifmedia_add(&adapter->media, IFM_ETHER | IFM_1000_SX | IFM_FDX, 
			    0, NULL);
		ifmedia_add(&adapter->media, IFM_ETHER | IFM_1000_SX, 
			    0, NULL);
	} else {
		ifmedia_add(&adapter->media, IFM_ETHER | IFM_10_T, 0, NULL);
		ifmedia_add(&adapter->media, IFM_ETHER | IFM_10_T | IFM_FDX, 
			    0, NULL);
		ifmedia_add(&adapter->media, IFM_ETHER | IFM_100_TX, 
			    0, NULL);
		ifmedia_add(&adapter->media, IFM_ETHER | IFM_100_TX | IFM_FDX, 
			    0, NULL);
#if __FreeBSD_version < 500000 
		ifmedia_add(&adapter->media, IFM_ETHER | IFM_1000_TX | IFM_FDX, 
			    0, NULL);
		ifmedia_add(&adapter->media, IFM_ETHER | IFM_1000_TX, 0, NULL);
#else
		ifmedia_add(&adapter->media, IFM_ETHER | IFM_1000_T | IFM_FDX, 
			    0, NULL);
		ifmedia_add(&adapter->media, IFM_ETHER | IFM_1000_T, 0, NULL);
#endif
	}
	ifmedia_add(&adapter->media, IFM_ETHER | IFM_AUTO, 0, NULL);
	ifmedia_set(&adapter->media, IFM_ETHER | IFM_AUTO);
#endif

	return;
}


/*********************************************************************
 *
 *  Workaround for SmartSpeed on 82541 and 82547 controllers
 *
 **********************************************************************/        
static void
em_smartspeed(struct adapter *adapter)
{
        uint16_t phy_tmp;
 
	if(adapter->link_active || (adapter->hw.phy_type != em_phy_igp) || 
	   !adapter->hw.autoneg || !(adapter->hw.autoneg_advertised & ADVERTISE_1000_FULL))
		return;

        if(adapter->smartspeed == 0) {
                /* If Master/Slave config fault is asserted twice,
                 * we assume back-to-back */
                em_read_phy_reg(&adapter->hw, PHY_1000T_STATUS, &phy_tmp);
                if(!(phy_tmp & SR_1000T_MS_CONFIG_FAULT)) return;
                em_read_phy_reg(&adapter->hw, PHY_1000T_STATUS, &phy_tmp);
                if(phy_tmp & SR_1000T_MS_CONFIG_FAULT) {
                        em_read_phy_reg(&adapter->hw, PHY_1000T_CTRL,
					&phy_tmp);
                        if(phy_tmp & CR_1000T_MS_ENABLE) {
                                phy_tmp &= ~CR_1000T_MS_ENABLE;
                                em_write_phy_reg(&adapter->hw,
                                                    PHY_1000T_CTRL, phy_tmp);
                                adapter->smartspeed++;
                                if(adapter->hw.autoneg &&
                                   !em_phy_setup_autoneg(&adapter->hw) &&
				   !em_read_phy_reg(&adapter->hw, PHY_CTRL,
                                                       &phy_tmp)) {
                                        phy_tmp |= (MII_CR_AUTO_NEG_EN |  
                                                    MII_CR_RESTART_AUTO_NEG);
                                        em_write_phy_reg(&adapter->hw,
							 PHY_CTRL, phy_tmp);
                                }
                        }
                }
                return;
        } else if(adapter->smartspeed == EM_SMARTSPEED_DOWNSHIFT) {
                /* If still no link, perhaps using 2/3 pair cable */
                em_read_phy_reg(&adapter->hw, PHY_1000T_CTRL, &phy_tmp);
                phy_tmp |= CR_1000T_MS_ENABLE;
                em_write_phy_reg(&adapter->hw, PHY_1000T_CTRL, phy_tmp);
                if(adapter->hw.autoneg &&
                   !em_phy_setup_autoneg(&adapter->hw) &&
                   !em_read_phy_reg(&adapter->hw, PHY_CTRL, &phy_tmp)) {
                        phy_tmp |= (MII_CR_AUTO_NEG_EN |
                                    MII_CR_RESTART_AUTO_NEG);
                        em_write_phy_reg(&adapter->hw, PHY_CTRL, phy_tmp);
                }
        }
        /* Restart process after EM_SMARTSPEED_MAX iterations */
        if(adapter->smartspeed++ == EM_SMARTSPEED_MAX)
                adapter->smartspeed = 0;

	return;
}


/*********************************************************************
 *
 *  Allocate memory for tx_buffer structures. The tx_buffer stores all 
 *  the information needed to transmit a packet on the wire. 
 *
 **********************************************************************/
static int
em_allocate_transmit_structures(struct adapter * adapter)
{
	if (!(adapter->tx_buffer_area =
#ifndef RISCOS
	      (struct em_buffer *) malloc(sizeof(struct em_buffer) *
					     adapter->num_tx_desc, M_DEVBUF,
					     M_NOWAIT))) {
		printf("em%d: Unable to allocate tx_buffer memory\n", 
		       adapter->unit);
#else
	      (struct em_tx_buffer *) em_ro_pci_memalloc(sizeof(struct em_tx_buffer) *
					     adapter->num_tx_desc, 4, 0))) {
		log_message(adapter->dev, "Unable to allocate tx_buffer memory");
#endif
		return ENOMEM;
	}

	bzero(adapter->tx_buffer_area,
#ifndef RISCOS
	      sizeof(struct em_buffer) * adapter->num_tx_desc);
#else
	      sizeof(struct em_tx_buffer) * adapter->num_tx_desc);
#endif

	return 0;
}

/*********************************************************************
 *
 *  Allocate and initialize transmit structures. 
 *
 **********************************************************************/
#ifndef RISCOS
static int
#else
int
#endif
em_setup_transmit_structures(struct adapter * adapter)
{
	if (em_allocate_transmit_structures(adapter))
		return ENOMEM;

        bzero((void *) adapter->tx_desc_base,
              (sizeof(struct em_tx_desc)) * adapter->num_tx_desc);
                          
        adapter->next_avail_tx_desc = 0;
	adapter->oldest_used_tx_desc = 0;

	/* Set number of descriptors available */
	adapter->num_tx_desc_avail = adapter->num_tx_desc;

	/* Set checksum context */
	adapter->active_checksum_context = OFFLOAD_NONE;

#ifdef RISCOS
        /* Get physical address of memory in each buffer */
	struct em_tx_buffer * tx_buffer = adapter->tx_buffer_area;

	for (int i = 0; i < adapter->num_tx_desc; i++, tx_buffer++) {
		tx_buffer->buffer_addr = vtophys((vm_offset_t)&tx_buffer->buffer[ETHER_ALIGN]);
	}

	em_ro_flush_wb();
#endif

	return 0;
}

/*********************************************************************
 *
 *  Enable transmit unit.
 *
 **********************************************************************/
static void
em_initialize_transmit_unit(struct adapter * adapter)
{
	u_int32_t       reg_tctl;
	u_int32_t       reg_tipg = 0;
	u_int64_t       tdba = vtophys((vm_offset_t)adapter->tx_desc_base);

	INIT_DEBUGOUT("em_initialize_transmit_unit: begin");

	/* Setup the Base and Length of the Tx Descriptor Ring */
	E1000_WRITE_REG(&adapter->hw, TDBAL,
			(tdba & 0x00000000ffffffffULL));
	E1000_WRITE_REG(&adapter->hw, TDBAH, (tdba >> 32));
	E1000_WRITE_REG(&adapter->hw, TDLEN, 
			adapter->num_tx_desc *
			sizeof(struct em_tx_desc));

	/* Setup the HW Tx Head and Tail descriptor pointers */
	E1000_WRITE_REG(&adapter->hw, TDH, 0);
	E1000_WRITE_REG(&adapter->hw, TDT, 0);


	HW_DEBUGOUT2("Base = %x, Length = %x\n", 
		     E1000_READ_REG(&adapter->hw, TDBAL),
		     E1000_READ_REG(&adapter->hw, TDLEN));


	/* Set the default values for the Tx Inter Packet Gap timer */
	switch (adapter->hw.mac_type) {
	case em_82542_rev2_0:
	case em_82542_rev2_1:
		reg_tipg = DEFAULT_82542_TIPG_IPGT;
		reg_tipg |= DEFAULT_82542_TIPG_IPGR1 << E1000_TIPG_IPGR1_SHIFT;
		reg_tipg |= DEFAULT_82542_TIPG_IPGR2 << E1000_TIPG_IPGR2_SHIFT;
		break;
	default:
		if (adapter->hw.media_type == em_media_type_fiber)
			reg_tipg = DEFAULT_82543_TIPG_IPGT_FIBER;
		else
			reg_tipg = DEFAULT_82543_TIPG_IPGT_COPPER;
		reg_tipg |= DEFAULT_82543_TIPG_IPGR1 << E1000_TIPG_IPGR1_SHIFT;
		reg_tipg |= DEFAULT_82543_TIPG_IPGR2 << E1000_TIPG_IPGR2_SHIFT;
	}

	E1000_WRITE_REG(&adapter->hw, TIPG, reg_tipg);
	E1000_WRITE_REG(&adapter->hw, TIDV, adapter->tx_int_delay.value);
	if(adapter->hw.mac_type >= em_82540)
		E1000_WRITE_REG(&adapter->hw, TADV, adapter->tx_abs_int_delay.value);

	/* Program the Transmit Control Register */
	reg_tctl = E1000_TCTL_PSP | E1000_TCTL_EN |
		   (E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT);
	if (adapter->link_duplex == 1) {
		reg_tctl |= E1000_FDX_COLLISION_DISTANCE << E1000_COLD_SHIFT;
	} else {
		reg_tctl |= E1000_HDX_COLLISION_DISTANCE << E1000_COLD_SHIFT;
	}
	E1000_WRITE_REG(&adapter->hw, TCTL, reg_tctl);

	/* Setup Transmit Descriptor Settings for this adapter */   
	adapter->txd_cmd = E1000_TXD_CMD_IFCS | E1000_TXD_CMD_RS;

	if (adapter->tx_int_delay.value > 0)
		adapter->txd_cmd |= E1000_TXD_CMD_IDE;

	return;
}

/*********************************************************************
 *
 *  Free all transmit related data structures.
 *
 **********************************************************************/
#ifndef RISCOS
static void
#else
void
#endif
em_free_transmit_structures(struct adapter * adapter)
{
#ifndef RISCOS
	struct em_buffer   *tx_buffer;
	int             i;
#endif

	INIT_DEBUGOUT("free_transmit_structures: begin");

#ifndef RISCOS
	if (adapter->tx_buffer_area != NULL) {
		tx_buffer = adapter->tx_buffer_area;
		for (i = 0; i < adapter->num_tx_desc; i++, tx_buffer++) {
			if (tx_buffer->m_head != NULL)
				m_freem(tx_buffer->m_head);
			tx_buffer->m_head = NULL;
		}
	}
#endif
	if (adapter->tx_buffer_area != NULL) {
#ifndef RISCOS
		free(adapter->tx_buffer_area, M_DEVBUF);
#else
		em_ro_pci_memfree(adapter->tx_buffer_area);
#endif
		adapter->tx_buffer_area = NULL;
	}
	return;
}

/*********************************************************************
 *
 *  The offload context needs to be set when we transfer the first
 *  packet of a particular protocol (TCP/UDP). We change the
 *  context only if the protocol type changes.
 *
 **********************************************************************/
#ifndef RISCOS
static void
em_transmit_checksum_setup(struct adapter * adapter,
			   struct mbuf *mp,
			   u_int32_t *txd_upper,
			   u_int32_t *txd_lower) 
{
	struct em_context_desc *TXD;
	struct em_buffer *tx_buffer;
	int curr_txd;

	if (mp->m_pkthdr.csum_flags) {

		if (mp->m_pkthdr.csum_flags & CSUM_TCP) {
			*txd_upper = E1000_TXD_POPTS_TXSM << 8;
			*txd_lower = E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D;
			if (adapter->active_checksum_context == OFFLOAD_TCP_IP)
				return;
			else
				adapter->active_checksum_context = OFFLOAD_TCP_IP;

		} else if (mp->m_pkthdr.csum_flags & CSUM_UDP) {
			*txd_upper = E1000_TXD_POPTS_TXSM << 8;
			*txd_lower = E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D;
			if (adapter->active_checksum_context == OFFLOAD_UDP_IP)
				return;
			else
				adapter->active_checksum_context = OFFLOAD_UDP_IP;
		} else {
			*txd_upper = 0;
			*txd_lower = 0;
			return;
		}
	} else {
		*txd_upper = 0;
		*txd_lower = 0;
		return;
	}

	/* If we reach this point, the checksum offload context
	 * needs to be reset.
	 */
	curr_txd = adapter->next_avail_tx_desc;
	tx_buffer = &adapter->tx_buffer_area[curr_txd];
	TXD = (struct em_context_desc *) &adapter->tx_desc_base[curr_txd];

	TXD->lower_setup.ip_fields.ipcss = ETHER_HDR_LEN;
	TXD->lower_setup.ip_fields.ipcso = 
		ETHER_HDR_LEN + offsetof(struct ip, ip_sum);
	TXD->lower_setup.ip_fields.ipcse = 
		ETHER_HDR_LEN + sizeof(struct ip) - 1;

	TXD->upper_setup.tcp_fields.tucss = 
		ETHER_HDR_LEN + sizeof(struct ip);
	TXD->upper_setup.tcp_fields.tucse = 0;

	if (adapter->active_checksum_context == OFFLOAD_TCP_IP) {
		TXD->upper_setup.tcp_fields.tucso = 
			ETHER_HDR_LEN + sizeof(struct ip) + 
			offsetof(struct tcphdr, th_sum);
	} else if (adapter->active_checksum_context == OFFLOAD_UDP_IP) {
		TXD->upper_setup.tcp_fields.tucso = 
			ETHER_HDR_LEN + sizeof(struct ip) + 
			offsetof(struct udphdr, uh_sum);
	}

	TXD->tcp_seg_setup.data = 0;
	TXD->cmd_and_length = (adapter->txd_cmd | E1000_TXD_CMD_DEXT);

	tx_buffer->m_head = NULL;

	if (++curr_txd == adapter->num_tx_desc)
		curr_txd = 0;

	adapter->num_tx_desc_avail--;
	adapter->next_avail_tx_desc = curr_txd;

	return;
}
#endif

/**********************************************************************
 *
 *  Examine each tx_buffer in the used queue. If the hardware is done
 *  processing the packet then free associated resources. The
 *  tx_buffer is put back on the free queue.
 *
 **********************************************************************/
#ifndef RISCOS
static void
#else
void
#endif
em_clean_transmit_interrupts(struct adapter * adapter)
{
        int s;
        int i, num_avail;
#ifndef RISCOS
	struct em_buffer *tx_buffer;
#else
	struct em_tx_buffer *tx_buffer;
#endif
	struct em_tx_desc   *tx_desc;
#ifndef RISCOS
	struct ifnet   *ifp = &adapter->interface_data.ac_if;
#else
	uint8_t          *last_dest_addr = NULL;
#endif

        if (adapter->num_tx_desc_avail == adapter->num_tx_desc)
                return;

        s = splimp();
#ifdef DBG_STATS
        adapter->clean_tx_interrupts++;
#endif
        num_avail = adapter->num_tx_desc_avail;	
	i = adapter->oldest_used_tx_desc;

	tx_buffer = &adapter->tx_buffer_area[i];
	tx_desc = &adapter->tx_desc_base[i];

	while(tx_desc->upper.fields.status & E1000_TXD_STAT_DD) {

		tx_desc->upper.data = 0;
		num_avail++;                        

#ifndef RISCOS
		if (tx_buffer->m_head) {
			ifp->if_opackets++;
			m_freem(tx_buffer->m_head);
			tx_buffer->m_head = NULL;
		}
#else
		last_dest_addr = &tx_buffer->buffer[ETHER_ALIGN];
#endif

                if (++i == adapter->num_tx_desc)
                        i = 0;

		tx_buffer = &adapter->tx_buffer_area[i];
		tx_desc = &adapter->tx_desc_base[i];
        }

	adapter->oldest_used_tx_desc = i;

#ifndef RISCOS
        /*
         * If we have enough room, clear IFF_OACTIVE to tell the stack
         * that it is OK to send packets.
         * If there are no pending descriptors, clear the timeout. Otherwise,
         * if some descriptors have been freed, restart the timeout.
         */
        if (num_avail > EM_TX_CLEANUP_THRESHOLD) {
                ifp->if_flags &= ~IFF_OACTIVE;
                if (num_avail == adapter->num_tx_desc)
                        ifp->if_timer = 0;
                else if (num_avail == adapter->num_tx_desc_avail)
                        ifp->if_timer = EM_TX_TIMEOUT;
        }
#else
        /* Note bug in BSD timer logic above, but we implement watchdog differently */

	if (last_dest_addr != NULL)
		memcpy(adapter->dev->stats.st_last_dest_addr, last_dest_addr, ETHER_HDR_LEN);
#endif
        adapter->num_tx_desc_avail = num_avail;
        splx(s);
        return;
}

/*********************************************************************
 *
 *  Get a buffer from system mbuf buffer pool.
 *
 **********************************************************************/
static int
em_get_buf(int i, struct adapter *adapter,
	   struct mbuf *nmp)
{
#ifndef RISCOS
	register struct mbuf    *mp = nmp;
	struct ifnet   *ifp;

	ifp = &adapter->interface_data.ac_if;

	if (mp == NULL) {
		MGETHDR(mp, M_DONTWAIT, MT_DATA);
		if (mp == NULL) {
			adapter->mbuf_alloc_failed++;
			return(ENOBUFS);
		}
		MCLGET(mp, M_DONTWAIT);
		if ((mp->m_flags & M_EXT) == 0) {
			m_freem(mp);
			adapter->mbuf_cluster_failed++;
			return(ENOBUFS);
		}
		mp->m_len = mp->m_pkthdr.len = MCLBYTES;
	} else {
		mp->m_len = mp->m_pkthdr.len = MCLBYTES;
		mp->m_data = mp->m_ext.ext_buf;
		mp->m_next = NULL;
	}

	if (ifp->if_mtu <= ETHERMTU) {
		m_adj(mp, ETHER_ALIGN);
	}
 
	adapter->rx_buffer_area[i].m_head = mp;
        adapter->rx_desc_base[i].buffer_addr =
                vtophys(mtod(mp, vm_offset_t));
#else
	(void)adapter;
	(void)nmp;

        adapter->rx_desc_base[i].buffer_addr = vtophys((vm_offset_t)&adapter->rx_buffer_area[i].buffer[ETHER_ALIGN]);
#endif

	return(0);
}

/*********************************************************************
 *
 *  Allocate memory for rx_buffer structures. Since we use one 
 *  rx_buffer per received packet, the maximum number of rx_buffer's 
 *  that we'll need is equal to the number of receive descriptors 
 *  that we've allocated.
 *
 **********************************************************************/
static int
em_allocate_receive_structures(struct adapter * adapter)
{
	int             i;

	if (!(adapter->rx_buffer_area =
#ifndef RISCOS
	      (struct em_buffer *) malloc(sizeof(struct em_buffer) *
					     adapter->num_rx_desc, M_DEVBUF,
					     M_NOWAIT))) {
		printf("em%d: Unable to allocate rx_buffer memory\n", 
		       adapter->unit);
#else
	      (struct em_rx_buffer *) em_ro_pci_memalloc(sizeof(struct em_rx_buffer) *
					     adapter->num_rx_desc, 4, 0))) {
		log_message(adapter->dev, "Unable to allocate rx_buffer memory");
#endif
		return(ENOMEM);
	}

	bzero(adapter->rx_buffer_area,
#ifndef RISCOS
	      sizeof(struct em_buffer) * adapter->num_rx_desc);
#else
	      sizeof(struct em_rx_buffer) * adapter->num_rx_desc);
#endif

	for (i = 0; i < adapter->num_rx_desc; i++) {
		if (em_get_buf(i, adapter, NULL) == ENOBUFS) {
#ifndef RISCOS
			adapter->rx_buffer_area[i].m_head = NULL;
#endif
			adapter->rx_desc_base[i].buffer_addr = 0;
			return(ENOBUFS);
		}
	}

	return(0);
}

/*********************************************************************
 *
 *  Allocate and initialize receive structures.
 *  
 **********************************************************************/
#ifndef RISCOS
static int
#else
int
#endif
em_setup_receive_structures(struct adapter * adapter)
{
	bzero((void *) adapter->rx_desc_base,
              (sizeof(struct em_rx_desc)) * adapter->num_rx_desc);

	if (em_allocate_receive_structures(adapter))
		return ENOMEM;

	/* Setup our descriptor pointers */
        adapter->next_rx_desc_to_check = 0;

#ifdef RISCOS
	em_ro_flush_wb();
#endif

	return(0);
}

/*********************************************************************
 *
 *  Enable receive unit.
 *  
 **********************************************************************/
static void
em_initialize_receive_unit(struct adapter * adapter)
{
	u_int32_t       reg_rctl;
#ifndef RISCOS
	u_int32_t       reg_rxcsum;
#endif
	struct ifnet    *ifp;
	u_int64_t       rdba = vtophys((vm_offset_t)adapter->rx_desc_base);

	INIT_DEBUGOUT("em_initialize_receive_unit: begin");

	ifp = &adapter->interface_data.ac_if;

	/* Make sure receives are disabled while setting up the descriptor ring */
	E1000_WRITE_REG(&adapter->hw, RCTL, 0);

	/* Set the Receive Delay Timer Register */
	E1000_WRITE_REG(&adapter->hw, RDTR, 
			adapter->rx_int_delay.value | E1000_RDT_FPDB);

	if(adapter->hw.mac_type >= em_82540) {
		E1000_WRITE_REG(&adapter->hw, RADV, adapter->rx_abs_int_delay.value);

                /* Set the interrupt throttling rate.  Value is calculated
                 * as DEFAULT_ITR = 1/(MAX_INTS_PER_SEC * 256ns) */
#define MAX_INTS_PER_SEC        8000
#define DEFAULT_ITR             1000000000/(MAX_INTS_PER_SEC * 256)
                E1000_WRITE_REG(&adapter->hw, ITR, DEFAULT_ITR);
        }       

	/* Setup the Base and Length of the Rx Descriptor Ring */
	E1000_WRITE_REG(&adapter->hw, RDBAL, 
			(rdba & 0x00000000ffffffffULL));
	E1000_WRITE_REG(&adapter->hw, RDBAH, (rdba >> 32));
	E1000_WRITE_REG(&adapter->hw, RDLEN, 
			adapter->num_rx_desc *
			sizeof(struct em_rx_desc));

	/* Setup the HW Rx Head and Tail Descriptor Pointers */
	E1000_WRITE_REG(&adapter->hw, RDH, 0);
	E1000_WRITE_REG(&adapter->hw, RDT, adapter->num_rx_desc - 1);

	/* Setup the Receive Control Register */
#ifndef RISCOS
	reg_rctl = E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_LBM_NO |
		   E1000_RCTL_RDMTS_HALF |
		   (adapter->hw.mc_filter_type << E1000_RCTL_MO_SHIFT);
#else
	/* For RISC OS, broadcast enable is set by the filter level code */
	reg_rctl = E1000_RCTL_EN | E1000_RCTL_LBM_NO |
		   E1000_RCTL_RDMTS_HALF |
		   (adapter->hw.mc_filter_type << E1000_RCTL_MO_SHIFT);
#endif

	if (adapter->hw.tbi_compatibility_on == TRUE)
		reg_rctl |= E1000_RCTL_SBP;


	switch (adapter->rx_buffer_len) {
	default:
	case EM_RXBUFFER_2048:
		reg_rctl |= E1000_RCTL_SZ_2048;
		break;
	case EM_RXBUFFER_4096:
		reg_rctl |= E1000_RCTL_SZ_4096 | E1000_RCTL_BSEX | E1000_RCTL_LPE;
		break;            
	case EM_RXBUFFER_8192:
		reg_rctl |= E1000_RCTL_SZ_8192 | E1000_RCTL_BSEX | E1000_RCTL_LPE;
		break;
	case EM_RXBUFFER_16384:
		reg_rctl |= E1000_RCTL_SZ_16384 | E1000_RCTL_BSEX | E1000_RCTL_LPE;
		break;
	}

	if (ifp->if_mtu > ETHERMTU)
		reg_rctl |= E1000_RCTL_LPE;

#ifndef RISCOS
	/* Enable 82543 Receive Checksum Offload for TCP and UDP */
	if ((adapter->hw.mac_type >= em_82543) && 
	    (ifp->if_capenable & IFCAP_RXCSUM)) {
		reg_rxcsum = E1000_READ_REG(&adapter->hw, RXCSUM);
		reg_rxcsum |= (E1000_RXCSUM_IPOFL | E1000_RXCSUM_TUOFL);
		E1000_WRITE_REG(&adapter->hw, RXCSUM, reg_rxcsum);
	}
#endif

	/* Enable Receives */
	E1000_WRITE_REG(&adapter->hw, RCTL, reg_rctl);	

	return;
}

/*********************************************************************
 *
 *  Free receive related data structures.
 *
 **********************************************************************/
#ifndef RISCOS
static void
#else
void
#endif
em_free_receive_structures(struct adapter *adapter)
{
#ifndef RISCOS
	struct em_buffer   *rx_buffer;
	int             i;
#endif

	INIT_DEBUGOUT("free_receive_structures: begin");

#ifndef RISCOS
	if (adapter->rx_buffer_area != NULL) {
		rx_buffer = adapter->rx_buffer_area;
		for (i = 0; i < adapter->num_rx_desc; i++, rx_buffer++) {
			if (rx_buffer->m_head != NULL)
				m_freem(rx_buffer->m_head);
			rx_buffer->m_head = NULL;
		}
	}
#endif
	if (adapter->rx_buffer_area != NULL) {
#ifndef RISCOS
		free(adapter->rx_buffer_area, M_DEVBUF);
#else
		em_ro_pci_memfree(adapter->rx_buffer_area);
#endif
		adapter->rx_buffer_area = NULL;
	}
	return;
}

/*********************************************************************
 *
 *  This routine executes in interrupt context. It replenishes
 *  the mbufs in the descriptor and sends data which has been
 *  dma'ed into host memory to upper layer.
 *
 *  We loop at most count times if count is > 0, or until done if
 *  count < 0.
 *
 *********************************************************************/
static void
em_process_receive_interrupts(struct adapter * adapter, int count)
{
	struct ifnet        *ifp;
	struct mbuf         *mp;
#ifndef RISCOS
#if __FreeBSD_version < 500000
        struct ether_header *eh;
#endif
#endif
	u_int8_t            accept_frame = 0;
 	u_int8_t            eop = 0;
        u_int16_t           len, desc_len, prev_len_adj;
	int                 i;
#ifdef RISCOS
	FilterSingleRef     fs;
#endif

	/* Pointer to the receive descriptor being examined. */
	struct em_rx_desc   *current_desc;

	ifp = &adapter->interface_data.ac_if;
	i = adapter->next_rx_desc_to_check;
        current_desc = &adapter->rx_desc_base[i];

	if (!((current_desc->status) & E1000_RXD_STAT_DD)) {
#ifdef DBG_STATS
		adapter->no_pkts_avail++;
#endif
		return;
	}

#ifdef RISCOS
	mp = NULL;
	fs = NULL;
#endif

	while ((current_desc->status & E1000_RXD_STAT_DD) && (count != 0)) {
		
#ifndef RISCOS
		mp = adapter->rx_buffer_area[i].m_head;
#endif

		accept_frame = 1;
		prev_len_adj = 0;
		desc_len = current_desc->length;
		if (current_desc->status & E1000_RXD_STAT_EOP) {
			count--;
			eop = 1;
			if (desc_len < ETHER_CRC_LEN) {
				len = 0;
				prev_len_adj = ETHER_CRC_LEN - desc_len;
			}
			else {
				len = desc_len - ETHER_CRC_LEN;
			}
		} else {
			eop = 0;
			len = desc_len;
		}

		if (current_desc->errors & E1000_RXD_ERR_FRAME_ERR_MASK) {
			u_int8_t            last_byte;
			u_int32_t           pkt_len = desc_len;

#ifndef RISCOS
			if (adapter->fmp != NULL)
				pkt_len += adapter->fmp->m_pkthdr.len; 
 
			last_byte = *(mtod(mp, caddr_t) + desc_len - 1);			
#else
			last_byte = adapter->rx_buffer_area[i].buffer[ETHER_ALIGN + current_desc->length - 1];
#endif

			if (TBI_ACCEPT(&adapter->hw, current_desc->status, 
				       current_desc->errors, 
				       pkt_len, last_byte)) {
				em_tbi_adjust_stats(&adapter->hw, 
						    &adapter->stats, 
						    pkt_len, 
						    adapter->hw.mac_addr);
				if (len > 0) len--;
			} 
			else {
				accept_frame = 0;
			}
		}

#ifndef RISCOS
		if (accept_frame) {

			if (em_get_buf(i, adapter, NULL) == ENOBUFS) {
				adapter->dropped_pkts++;
				em_get_buf(i, adapter, mp);
				if (adapter->fmp != NULL) 
					m_freem(adapter->fmp);
				adapter->fmp = NULL;
				adapter->lmp = NULL;
				break;
			}

			/* Assign correct length to the current fragment */
			mp->m_len = len;

			if (adapter->fmp == NULL) {
				mp->m_pkthdr.len = len;
				adapter->fmp = mp;	 /* Store the first mbuf */
				adapter->lmp = mp;
			} else {
				/* Chain mbuf's together */
				mp->m_flags &= ~M_PKTHDR;
				/* 
				 * Adjust length of previous mbuf in chain if we 
				 * received less than 4 bytes in the last descriptor.
				 */
				if (prev_len_adj > 0) {
					adapter->lmp->m_len -= prev_len_adj;
					adapter->fmp->m_pkthdr.len -= prev_len_adj;
				}
				adapter->lmp->m_next = mp;
				adapter->lmp = adapter->lmp->m_next;
				adapter->fmp->m_pkthdr.len += len;
			}

                        if (eop) {
                                adapter->fmp->m_pkthdr.rcvif = ifp;
				ifp->if_ipackets++;

#if __FreeBSD_version < 500000
                                eh = mtod(adapter->fmp, struct ether_header *);
                                /* Remove ethernet header from mbuf */
                                m_adj(adapter->fmp, sizeof(struct ether_header));
                                em_receive_checksum(adapter, current_desc,
                                                    adapter->fmp);
                                if (current_desc->status & E1000_RXD_STAT_VP)
                                        VLAN_INPUT_TAG(eh, adapter->fmp,
                                                       (current_desc->special & 
							E1000_RXD_SPC_VLAN_MASK));
                                else
                                        ether_input(ifp, eh, adapter->fmp);
#else

                                em_receive_checksum(adapter, current_desc,
                                                    adapter->fmp);
                                if (current_desc->status & E1000_RXD_STAT_VP)
                                        VLAN_INPUT_TAG(ifp, adapter->fmp,
                                                       (current_desc->special &
							E1000_RXD_SPC_VLAN_MASK),
						       adapter->fmp = NULL);
 
                                if (adapter->fmp != NULL)
                                        (*ifp->if_input)(ifp, adapter->fmp);
#endif
                                adapter->fmp = NULL;
                                adapter->lmp = NULL;
                        }
		} else {
			adapter->dropped_pkts++;
			em_get_buf(i, adapter, mp);
			if (adapter->fmp != NULL) 
				m_freem(adapter->fmp);
			adapter->fmp = NULL;
			adapter->lmp = NULL;
		}
#else
		if (accept_frame && eop)
			em_ro_filter_packet(adapter, &adapter->rx_buffer_area[i].buffer[ETHER_ALIGN], len, &mp, &fs);
		else
			adapter->dropped_pkts++;
		adapter->rx_pkts++;
#endif

		/* Zero out the receive descriptors status  */
		current_desc->status = 0;

#ifdef RISCOS
		em_ro_flush_wb();
#endif
 
		/* Advance the E1000's Receive Queue #0  "Tail Pointer". */
                E1000_WRITE_REG(&adapter->hw, RDT, i);

                /* Advance our pointers to the next descriptor */
                if (++i == adapter->num_rx_desc) {
                        i = 0;
                        current_desc = adapter->rx_desc_base;
                } else
			current_desc++;
	}
	adapter->next_rx_desc_to_check = i;
#ifdef RISCOS
	if (mp != NULL)
		em_asm_callproto(&adapter->dev->dib, mp, fs->fs_handler, fs->fs_pwptr);
#endif
	return;
}

/*********************************************************************
 *
 *  Verify that the hardware indicated that the checksum is valid. 
 *  Inform the stack about the status of checksum so that stack
 *  doesn't spend time verifying the checksum.
 *
 *********************************************************************/
#ifndef RISCOS
static void
em_receive_checksum(struct adapter *adapter,
		    struct em_rx_desc *rx_desc,
		    struct mbuf *mp)
{
	/* 82543 or newer only */
	if ((adapter->hw.mac_type < em_82543) ||
	    /* Ignore Checksum bit is set */
	    (rx_desc->status & E1000_RXD_STAT_IXSM)) {
		mp->m_pkthdr.csum_flags = 0;
		return;
	}

	if (rx_desc->status & E1000_RXD_STAT_IPCS) {
		/* Did it pass? */
		if (!(rx_desc->errors & E1000_RXD_ERR_IPE)) {
			/* IP Checksum Good */
			mp->m_pkthdr.csum_flags = CSUM_IP_CHECKED;
			mp->m_pkthdr.csum_flags |= CSUM_IP_VALID;

		} else {
			mp->m_pkthdr.csum_flags = 0;
		}
	}

	if (rx_desc->status & E1000_RXD_STAT_TCPCS) {
		/* Did it pass? */        
		if (!(rx_desc->errors & E1000_RXD_ERR_TCPE)) {
			mp->m_pkthdr.csum_flags |= 
			(CSUM_DATA_VALID | CSUM_PSEUDO_HDR);
			mp->m_pkthdr.csum_data = htons(0xffff);
		}
	}

	return;
}
#endif


static void 
em_enable_vlans(struct adapter *adapter)
{
	uint32_t ctrl;

	E1000_WRITE_REG(&adapter->hw, VET, ETHERTYPE_VLAN);

	ctrl = E1000_READ_REG(&adapter->hw, CTRL);
#ifndef RISCOS
	ctrl |= E1000_CTRL_VME;
#else
	/* For RISC OS, always disable VLANs */
	ctrl &= ~E1000_CTRL_VME;
#endif
	E1000_WRITE_REG(&adapter->hw, CTRL, ctrl);

	return;
}

static void
em_enable_intr(struct adapter * adapter)
{
	E1000_WRITE_REG(&adapter->hw, IMS, (IMS_ENABLE_MASK));
#ifdef RISCOS
	/* BSD driver forgot this */
	E1000_WRITE_FLUSH(&adapter->hw);
#endif
	return;
}

static void
em_disable_intr(struct adapter *adapter)
{
#ifndef RISCOS
	E1000_WRITE_REG(&adapter->hw, IMC, 
			(0xffffffff & ~E1000_IMC_RXSEQ));
#else
	E1000_WRITE_REG(&adapter->hw, IMC, 0xffffffff);
	/* It's not clear why the BSD driver doesn't disable RXSEQ  */
	/* interrupts. There appears to be no good reason for it,   */
	/* and it would be bad for us as we assume that the chip    */
	/* can't interrupt again whilst we are in the interrupt     */
	/* handler. They also forgot the write flush.               */
	E1000_WRITE_FLUSH(&adapter->hw);
#endif
	return;
}

static int
em_is_valid_ether_addr(u_int8_t *addr)
{
	char zero_addr[6] = { 0, 0, 0, 0, 0, 0 };

	if ((addr[0] & 1) || (!bcmp(addr, zero_addr, ETHER_ADDR_LEN))) {
		return (FALSE);
	}

	return(TRUE);
}

void 
em_write_pci_cfg(struct em_hw *hw,
		      uint32_t reg,
		      uint16_t *value)
{
	pci_write_config(((struct em_osdep *)hw->back)->dev, reg, 
			 *value, 2);
}

void 
em_read_pci_cfg(struct em_hw *hw, uint32_t reg,
		     uint16_t *value)
{
	*value = pci_read_config(((struct em_osdep *)hw->back)->dev,
				 reg, 2);
	return;
}

void
em_pci_set_mwi(struct em_hw *hw)
{
        pci_write_config(((struct em_osdep *)hw->back)->dev,
                         PCIR_COMMAND,
                         (hw->pci_cmd_word | CMD_MEM_WRT_INVALIDATE), 2);
        return;
}

void
em_pci_clear_mwi(struct em_hw *hw)
{
        pci_write_config(((struct em_osdep *)hw->back)->dev,
                         PCIR_COMMAND,
                         (hw->pci_cmd_word & ~CMD_MEM_WRT_INVALIDATE), 2);
        return;
}

uint32_t 
em_io_read(struct em_hw *hw, unsigned long port)
{
#ifndef RISCOS
	return(inl(port));
#else
	_kernel_oserror * e;
	uint32_t          value;

	e = _swix(PCI_IORead,
		  _IN(0) | _IN(2) | _OUT(1),

		  port,
		  4,

		  &value);

	if (e != NULL)
		log_error(((struct em_osdep *)hw->back)->dev, e);

	return value;
#endif
}

void 
em_io_write(struct em_hw *hw, unsigned long port, uint32_t value)
{
#ifndef RISCOS
	outl(port, value);
#else
	_kernel_oserror * e;

	e = _swix(PCI_IOWrite,
		  _INR(0,2),

		  port,
		  value,
		  4);

	if (e != NULL)
		log_error(((struct em_osdep *)hw->back)->dev, e);
#endif
	return;
}

/*********************************************************************
* 82544 Coexistence issue workaround. 
*    There are 2 issues.
*	1. Transmit Hang issue.
*    To detect this issue, following equation can be used...
*          SIZE[3:0] + ADDR[2:0] = SUM[3:0].
*          If SUM[3:0] is in between 1 to 4, we will have this issue.
*
*	2. DAC issue.
*    To detect this issue, following equation can be used...
*          SIZE[3:0] + ADDR[2:0] = SUM[3:0].
*          If SUM[3:0] is in between 9 to c, we will have this issue.
*
*
*    WORKAROUND:
*          Make sure we do not have ending address as 1,2,3,4(Hang) or 9,a,b,c (DAC)
*
*** *********************************************************************/
#ifndef RISCOS
static u_int32_t
em_fill_descriptors (u_int64_t address, 
                              u_int32_t length, 
                              PDESC_ARRAY desc_array)
{
	/* Since issue is sensitive to length and address.*/
	/* Let us first check the address...*/
	u_int32_t safe_terminator;
	if (length <= 4) {
		desc_array->descriptor[0].address = address;
        	desc_array->descriptor[0].length = length;
        	desc_array->elements = 1;
		return desc_array->elements;
    	}
    	safe_terminator = (u_int32_t)((((u_int32_t)address & 0x7) + (length & 0xF)) & 0xF);
	/* if it does not fall between 0x1 to 0x4 and 0x9 to 0xC then return */ 
	if (safe_terminator == 0   ||
        (safe_terminator > 4   &&
        safe_terminator < 9)   || 
        (safe_terminator > 0xC &&
        safe_terminator <= 0xF)) {
        	desc_array->descriptor[0].address = address;
        	desc_array->descriptor[0].length = length;
        	desc_array->elements = 1;
		return desc_array->elements;
    	}
	
	desc_array->descriptor[0].address = address;
    	desc_array->descriptor[0].length = length - 4;
    	desc_array->descriptor[1].address = address + (length - 4);
    	desc_array->descriptor[1].length = 4;
    	desc_array->elements = 2;
	return desc_array->elements;
}
#endif


		
/**********************************************************************
 *
 *  Update the board statistics counters. 
 *
 **********************************************************************/
#ifndef RISCOS
static void
#else
void
#endif
em_update_stats_counters(struct adapter *adapter)
{
#ifndef RISCOS
	struct ifnet   *ifp;
#endif

	if(adapter->hw.media_type == em_media_type_copper ||
	   (E1000_READ_REG(&adapter->hw, STATUS) & E1000_STATUS_LU)) {
		adapter->stats.symerrs += E1000_READ_REG(&adapter->hw, SYMERRS);
		adapter->stats.sec += E1000_READ_REG(&adapter->hw, SEC);
	}
	adapter->stats.crcerrs += E1000_READ_REG(&adapter->hw, CRCERRS);
	adapter->stats.mpc += E1000_READ_REG(&adapter->hw, MPC);
	adapter->stats.scc += E1000_READ_REG(&adapter->hw, SCC);
	adapter->stats.ecol += E1000_READ_REG(&adapter->hw, ECOL);

	adapter->stats.mcc += E1000_READ_REG(&adapter->hw, MCC);
	adapter->stats.latecol += E1000_READ_REG(&adapter->hw, LATECOL);
	adapter->stats.colc += E1000_READ_REG(&adapter->hw, COLC);
	adapter->stats.dc += E1000_READ_REG(&adapter->hw, DC);
	adapter->stats.rlec += E1000_READ_REG(&adapter->hw, RLEC);
	adapter->stats.xonrxc += E1000_READ_REG(&adapter->hw, XONRXC);
	adapter->stats.xontxc += E1000_READ_REG(&adapter->hw, XONTXC);
	adapter->stats.xoffrxc += E1000_READ_REG(&adapter->hw, XOFFRXC);
	adapter->stats.xofftxc += E1000_READ_REG(&adapter->hw, XOFFTXC);
	adapter->stats.fcruc += E1000_READ_REG(&adapter->hw, FCRUC);
	adapter->stats.prc64 += E1000_READ_REG(&adapter->hw, PRC64);
	adapter->stats.prc127 += E1000_READ_REG(&adapter->hw, PRC127);
	adapter->stats.prc255 += E1000_READ_REG(&adapter->hw, PRC255);
	adapter->stats.prc511 += E1000_READ_REG(&adapter->hw, PRC511);
	adapter->stats.prc1023 += E1000_READ_REG(&adapter->hw, PRC1023);
	adapter->stats.prc1522 += E1000_READ_REG(&adapter->hw, PRC1522);
	adapter->stats.gprc += E1000_READ_REG(&adapter->hw, GPRC);
	adapter->stats.bprc += E1000_READ_REG(&adapter->hw, BPRC);
	adapter->stats.mprc += E1000_READ_REG(&adapter->hw, MPRC);
	adapter->stats.gptc += E1000_READ_REG(&adapter->hw, GPTC);

	/* For the 64-bit byte counters the low dword must be read first. */
	/* Both registers clear on the read of the high dword */

	adapter->stats.gorcl += E1000_READ_REG(&adapter->hw, GORCL); 
	adapter->stats.gorch += E1000_READ_REG(&adapter->hw, GORCH);
	adapter->stats.gotcl += E1000_READ_REG(&adapter->hw, GOTCL);
	adapter->stats.gotch += E1000_READ_REG(&adapter->hw, GOTCH);

	adapter->stats.rnbc += E1000_READ_REG(&adapter->hw, RNBC);
	adapter->stats.ruc += E1000_READ_REG(&adapter->hw, RUC);
	adapter->stats.rfc += E1000_READ_REG(&adapter->hw, RFC);
	adapter->stats.roc += E1000_READ_REG(&adapter->hw, ROC);
	adapter->stats.rjc += E1000_READ_REG(&adapter->hw, RJC);

	adapter->stats.torl += E1000_READ_REG(&adapter->hw, TORL);
	adapter->stats.torh += E1000_READ_REG(&adapter->hw, TORH);
	adapter->stats.totl += E1000_READ_REG(&adapter->hw, TOTL);
	adapter->stats.toth += E1000_READ_REG(&adapter->hw, TOTH);

	adapter->stats.tpr += E1000_READ_REG(&adapter->hw, TPR);
	adapter->stats.tpt += E1000_READ_REG(&adapter->hw, TPT);
	adapter->stats.ptc64 += E1000_READ_REG(&adapter->hw, PTC64);
	adapter->stats.ptc127 += E1000_READ_REG(&adapter->hw, PTC127);
	adapter->stats.ptc255 += E1000_READ_REG(&adapter->hw, PTC255);
	adapter->stats.ptc511 += E1000_READ_REG(&adapter->hw, PTC511);
	adapter->stats.ptc1023 += E1000_READ_REG(&adapter->hw, PTC1023);
	adapter->stats.ptc1522 += E1000_READ_REG(&adapter->hw, PTC1522);
	adapter->stats.mptc += E1000_READ_REG(&adapter->hw, MPTC);
	adapter->stats.bptc += E1000_READ_REG(&adapter->hw, BPTC);

	if (adapter->hw.mac_type >= em_82543) {
		adapter->stats.algnerrc += 
		E1000_READ_REG(&adapter->hw, ALGNERRC);
		adapter->stats.rxerrc += 
		E1000_READ_REG(&adapter->hw, RXERRC);
		adapter->stats.tncrs += 
		E1000_READ_REG(&adapter->hw, TNCRS);
		adapter->stats.cexterr += 
		E1000_READ_REG(&adapter->hw, CEXTERR);
		adapter->stats.tsctc += 
		E1000_READ_REG(&adapter->hw, TSCTC);
		adapter->stats.tsctfc += 
		E1000_READ_REG(&adapter->hw, TSCTFC);
	}
#ifndef RISCOS
	ifp = &adapter->interface_data.ac_if;

	/* Fill out the OS statistics structure */
	ifp->if_ibytes = adapter->stats.gorcl;
	ifp->if_obytes = adapter->stats.gotcl;
	ifp->if_imcasts = adapter->stats.mprc;
	ifp->if_collisions = adapter->stats.colc;

	/* Rx Errors */
	ifp->if_ierrors =
	adapter->dropped_pkts +
	adapter->stats.rxerrc +
	adapter->stats.crcerrs +
	adapter->stats.algnerrc +
	adapter->stats.rlec + adapter->stats.rnbc + 
	adapter->stats.mpc + adapter->stats.cexterr;

	/* Tx Errors */
	ifp->if_oerrors = adapter->stats.ecol + adapter->stats.latecol;
#else
	/* The BSD driver forgot these */

	/* Phy Stats */

#define PHY_IDLE_ERROR_COUNT_MASK 0x00FF

        if (adapter->hw.media_type == em_media_type_copper) {
                uint16_t phy_reg;
                if (adapter->link_speed == 1000) {
                        if (em_read_phy_reg(&adapter->hw, PHY_1000T_STATUS, &phy_reg) == 0)
                                adapter->phy_stats.idle_errors += (phy_reg & PHY_IDLE_ERROR_COUNT_MASK);
                }

                if ((adapter->hw.mac_type <= em_82546) &&
                    (adapter->hw.phy_type == em_phy_m88)) {
                        if (em_read_phy_reg(&adapter->hw, M88E1000_RX_ERR_CNTR, &phy_reg) == 0)
                                adapter->phy_stats.receive_errors += phy_reg;
                }
        }
#endif
}


/**********************************************************************
 *
 *  This routine is called only when em_display_debug_stats is enabled.
 *  This routine provides a way to take a look at important statistics
 *  maintained by the driver and hardware.
 *
 **********************************************************************/
#ifndef RISCOS
static void
em_print_debug_info(struct adapter *adapter)
{
	int unit = adapter->unit;
	uint8_t *hw_addr = adapter->hw.hw_addr;

	printf("em%d: Adapter hardware address = %p \n", unit, hw_addr);
	printf("em%d:CTRL  = 0x%x\n", unit, 
		E1000_READ_REG(&adapter->hw, CTRL)); 
	printf("em%d:RCTL  = 0x%x PS=(0x8402)\n", unit, 
		E1000_READ_REG(&adapter->hw, RCTL)); 
	printf("em%d:tx_int_delay = %d, tx_abs_int_delay = %d\n", unit, 
	       E1000_READ_REG(&adapter->hw, TIDV),
	       E1000_READ_REG(&adapter->hw, TADV));
	printf("em%d:rx_int_delay = %d, rx_abs_int_delay = %d\n", unit, 
	       E1000_READ_REG(&adapter->hw, RDTR),
	       E1000_READ_REG(&adapter->hw, RADV));
#ifdef DBG_STATS
	printf("em%d: Packets not Avail = %ld\n", unit, 
	       adapter->no_pkts_avail);
	printf("em%d: CleanTxInterrupts = %ld\n", unit, 
	       adapter->clean_tx_interrupts);
#endif
	printf("em%d: fifo workaround = %lld, fifo_reset = %lld\n", unit, 
	       (long long)adapter->tx_fifo_wrk_cnt, 
	       (long long)adapter->tx_fifo_reset_cnt);
	printf("em%d: hw tdh = %d, hw tdt = %d\n", unit,
	       E1000_READ_REG(&adapter->hw, TDH), 
	       E1000_READ_REG(&adapter->hw, TDT));
	printf("em%d: Num Tx descriptors avail = %d\n", unit,
	       adapter->num_tx_desc_avail);
	printf("em%d: Tx Descriptors not avail1 = %ld\n", unit, 
	       adapter->no_tx_desc_avail1);
	printf("em%d: Tx Descriptors not avail2 = %ld\n", unit, 
	       adapter->no_tx_desc_avail2);
	printf("em%d: Std mbuf failed = %ld\n", unit, 
	       adapter->mbuf_alloc_failed);
	printf("em%d: Std mbuf cluster failed = %ld\n", unit, 
	       adapter->mbuf_cluster_failed);
	printf("em%d: Driver dropped packets = %ld\n", unit, 
	       adapter->dropped_pkts);

	return;
}
#endif

#ifndef RISCOS
static void
em_print_hw_stats(struct adapter *adapter)
{
	int unit = adapter->unit;

	printf("em%d: Excessive collisions = %lld\n", unit,
	       (long long)adapter->stats.ecol);
	printf("em%d: Symbol errors = %lld\n", unit, 
	       (long long)adapter->stats.symerrs);
	printf("em%d: Sequence errors = %lld\n", unit, 
	       (long long)adapter->stats.sec);
	printf("em%d: Defer count = %lld\n", unit, 
	       (long long)adapter->stats.dc);

	printf("em%d: Missed Packets = %lld\n", unit, 
	       (long long)adapter->stats.mpc);
	printf("em%d: Receive No Buffers = %lld\n", unit, 
	       (long long)adapter->stats.rnbc);
	printf("em%d: Receive length errors = %lld\n", unit, 
	       (long long)adapter->stats.rlec);
	printf("em%d: Receive errors = %lld\n", unit, 
	       (long long)adapter->stats.rxerrc);
	printf("em%d: Crc errors = %lld\n", unit, 
	       (long long)adapter->stats.crcerrs);
	printf("em%d: Alignment errors = %lld\n", unit, 
	       (long long)adapter->stats.algnerrc);
	printf("em%d: Carrier extension errors = %lld\n", unit,
	       (long long)adapter->stats.cexterr);

	printf("em%d: XON Rcvd = %lld\n", unit, 
	       (long long)adapter->stats.xonrxc);
	printf("em%d: XON Xmtd = %lld\n", unit, 
	       (long long)adapter->stats.xontxc);
	printf("em%d: XOFF Rcvd = %lld\n", unit, 
	       (long long)adapter->stats.xoffrxc);
	printf("em%d: XOFF Xmtd = %lld\n", unit, 
	       (long long)adapter->stats.xofftxc);

	printf("em%d: Good Packets Rcvd = %lld\n", unit,
	       (long long)adapter->stats.gprc);
	printf("em%d: Good Packets Xmtd = %lld\n", unit,
	       (long long)adapter->stats.gptc);

	return;
}
#endif

#ifndef RISCOS
static int
em_sysctl_debug_info(SYSCTL_HANDLER_ARGS)
{
	int error;
	int result;
	struct adapter *adapter;

	result = -1;
	error = sysctl_handle_int(oidp, &result, 0, req);
	
	if (error || !req->newptr)
		return (error);

	if (result == 1) {
		adapter = (struct adapter *)arg1;
		em_print_debug_info(adapter);
	}

	return error;
}


static int
em_sysctl_stats(SYSCTL_HANDLER_ARGS)
{
	int error;
	int result;
	struct adapter *adapter;
	
	result = -1;
	error = sysctl_handle_int(oidp, &result, 0, req);
	
	if (error || !req->newptr)
		return (error);

	if (result == 1) {
		adapter = (struct adapter *)arg1;
		em_print_hw_stats(adapter);
	}

	return error;
}

static int
em_sysctl_int_delay(SYSCTL_HANDLER_ARGS)
{
        struct em_int_delay_info *info;
        struct adapter *adapter;
        u_int32_t regval;
        int error;
        int usecs;
        int ticks;
        int s;

        info = (struct em_int_delay_info *)arg1;
        adapter = info->adapter;
        usecs = info->value;
        error = sysctl_handle_int(oidp, &usecs, 0, req);
        if (error != 0 || req->newptr == NULL)
                return error;
        if (usecs < 0 || usecs > E1000_TICKS_TO_USECS(65535))
                return EINVAL;
        info->value = usecs;
        ticks = E1000_USECS_TO_TICKS(usecs);

        s = splimp();
        regval = E1000_READ_OFFSET(&adapter->hw, info->offset);
        regval = (regval & ~0xffff) | (ticks & 0xffff);
        /* Handle a few special cases. */
        switch (info->offset) {
        case E1000_RDTR:
        case E1000_82542_RDTR:
                regval |= E1000_RDT_FPDB;
                break;
        case E1000_TIDV:
        case E1000_82542_TIDV:
                if (ticks == 0) {
                        adapter->txd_cmd &= ~E1000_TXD_CMD_IDE;
                        /* Don't write 0 into the TIDV register. */
                        regval++;
                } else
                        adapter->txd_cmd |= E1000_TXD_CMD_IDE;
                break;
        }
        E1000_WRITE_OFFSET(&adapter->hw, info->offset, regval);
        splx(s);
        return 0;
}

static void
em_add_int_delay_sysctl(struct adapter *adapter, const char *name,
    const char *description, struct em_int_delay_info *info,
    int offset, int value)
{
        info->adapter = adapter;
        info->offset = offset;
        info->value = value;
        SYSCTL_ADD_PROC(&adapter->sysctl_ctx,
            SYSCTL_CHILDREN(adapter->sysctl_tree),
            OID_AUTO, name, CTLTYPE_INT|CTLFLAG_RW,
            info, 0, em_sysctl_int_delay, "I", description);
}
#endif
@


1.15
log
@	changed 'no motherboard' detection method following discussion with James
Detail:
	Now detects the motherboard by selecting the required Bus/Dev/Fn setting
	for the motherboard device. This allows the same chip type to be used on
	plugged in PCI cards
Admin:	tested at Castle.. does as expected. Castle added IP


Version 0.17. Tagged as 'EtherK-0_17'
@
text
@d3287 2
a3288 1
	/* handler.                                                 */
@


1.14
log
@	build version of EtherK that ignores a (possibly) faulty
	motherboard device
Detail:
	added new target and a couple if ifndefs to avoid the 82540em
	device used on the motherboard.  needed for some failed out of
	warranty motherboards.
Admin:  tested at castle.. does as expected
	Castle added IP


Version 0.16. Tagged as 'EtherK-0_16'
@
text
@a102 1
#ifndef NOMOBO
a103 1
#endif
@


1.13
log
@  Update BSD-derived code to version 1.7.35 of the FreeBSD driver sources.
  Rewrite and improve test code.
Detail:
  if_em.c, if_em_hw.c, if_em.h, if_em_hw.h and if_em_osdep.h have all
  been updated to version 1.7.35 of the FreeBSD sources. This version of
  the FreeBSD source tarball is now in the Original directory and earlier
  ones have been removed. The main effect of the changes is to add support
  for later Intel controllers. Note that workaround code required to
  support the 82544 when running on a PCIX bus, and to support the 82547EI
  has not been included to remove unnecessary complication. If support for
  these controllers is ever required (unlikely), this would need to be
  added back in.
  The test code has been rewritten and is now in a new file, test.c.
  Loopback code from the Linux driver is located in the loopback.c file
  and can optionally be compiled in by changing the #define at the top of
  test.c, but since this is GPL code it cannot be included in any
  distributed module. Also, although the test will work, it does not
  restore everything correctly so the link stays down afterwards until the
  module is reinitialised.
  AutoSense/EtherK has been updated to recognise all supported cards.
  doc/UserGuide has been updated.
Admin:
  Basic testing has been carried out, but more testing is required.
  Note that the updated AutoSense and UserGuide files need to be
  included in future distributions including this module.


Version 0.13. Tagged as 'EtherK-0_13'
@
text
@d103 1
d105 1
@


1.12
log
@  Restructure and tidy up.
Detail:
  This version has no functional changes, but has been considerably
  tidied up to improve commenting and modularity. In particular the
  information printing routines, filtering routines and message
  logging routines have been split out into separate source files.
  The filtering routines have also been re-worked to be more
  comprehensible. Hopefully this will provide a useful base for
  developing future network drivers.
Admin:
  Requires an up-to-date version of BuildSys to build all variants.
  Basic testing indicates it still works, but more long term testing
  to confirm that nothing has been accidentally broken is required.


Version 0.12. Tagged as 'EtherK-0_12'
@
text
@d3 1
a3 1
Copyright (c) 2001-2002, Intel Corporation
d37 3
d41 1
d55 2
d60 1
d62 1
d68 1
d70 3
a72 1

d78 3
a80 1
char em_driver_version[] = "1.4.10";
d92 1
d108 1
d112 7
d120 11
d139 1
d143 1
d155 1
a155 1
static int  em_ioctl(struct ifnet *, IOCTL_CMD_TYPE, caddr_t);
a184 1
#endif
d187 1
d191 1
a191 1
				struct em_rx_desc * rx_desc,
a203 1
#endif
d206 6
a211 1
static void em_enable_vlans(struct adapter *adapter);
d213 17
a229 1
static int  em_encap(struct adapter *adapter, struct mbuf *m_head);
d255 31
d307 1
d309 1
d331 2
a332 1
			sprintf(adapter_name, "%s, Version - %s", 
d336 1
d367 1
d396 25
d422 1
d428 27
a457 4
        adapter->tx_int_delay = EM_TIDV;
        adapter->tx_abs_int_delay = EM_TADV;
        adapter->rx_int_delay = EM_RDTR;
        adapter->rx_abs_int_delay = EM_RADV;
d463 1
d465 4
d474 3
d478 5
d484 4
a487 1
	/* Set the max frame size assuming standard ethernet sized frames */   
d494 5
a498 10
	/* This controls when hardware reports transmit completion status. */
	if ((EM_REPORT_TX_EARLY == 0) || (EM_REPORT_TX_EARLY == 1)) {
		adapter->hw.report_tx_early = EM_REPORT_TX_EARLY;
	} else {
		if (adapter->hw.mac_type < em_82543) {
			adapter->hw.report_tx_early = 0;
		} else {
			adapter->hw.report_tx_early = 1;
		}
	}
d504 1
d512 2
a513 5
		em_free_pci_resources(adapter);
#ifndef RISCOS
		splx(s);
#endif
		return(ENXIO);
d515 3
a517 2
  
	
d523 2
a524 1
	      contigmalloc(tsize, M_DEVBUF, M_NOWAIT, 0, ~0, PAGE_SIZE, 0))) {
d531 2
a532 5
		em_free_pci_resources(adapter);
#ifndef RISCOS
		splx(s);
#endif
		return(ENOMEM);
d540 2
a541 1
	      contigmalloc(rsize, M_DEVBUF, M_NOWAIT, 0, ~0, PAGE_SIZE, 0))) {
d548 2
a549 6
		em_free_pci_resources(adapter);
		contigfree(adapter->tx_desc_base, tsize, M_DEVBUF);
#ifndef RISCOS
		splx(s);
#endif
		return(ENOMEM);
d560 2
a561 7
		em_free_pci_resources(adapter);
		contigfree(adapter->tx_desc_base, tsize, M_DEVBUF);
		contigfree(adapter->rx_desc_base, rsize, M_DEVBUF);
#ifndef RISCOS
		splx(s);
#endif
		return(EIO);
a570 4
		/* The BSD driver forgets to do this lot */
		em_free_pci_resources(adapter);
		contigfree(adapter->tx_desc_base, tsize, M_DEVBUF);
		contigfree(adapter->rx_desc_base, rsize, M_DEVBUF);
d572 12
a583 1
		return(EIO);
d586 3
a588 2
	memcpy(adapter->interface_data.ac_enaddr, adapter->hw.mac_addr,
	       ETH_LENGTH_OF_ADDRESS);
d618 9
a626 1

d633 17
a649 1
	return(0);
d683 2
d689 1
a689 1
	ether_ifdetach(&adapter->interface_data.ac_if, ETHER_BPF_SUPPORTED);
d691 1
a691 1
	ether_ifdetach(&adapter->interface_data.ac_if);
d695 3
d729 3
d768 1
a768 1
        int             s; 
d771 1
a771 1
        
d782 4
a785 4
                if (em_encap(adapter, m_head)) { 
                        ifp->if_flags |= IFF_OACTIVE;
                        IF_PREPEND(&ifp->if_snd, m_head);
                        break;
d788 1
a788 2

                /* Send a copy of the frame to the BPF listener */
d816 1
a816 1
em_ioctl(struct ifnet *ifp, IOCTL_CMD_TYPE command, caddr_t data)
d823 3
d846 1
a846 7
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC) {
				em_set_promisc(adapter);
			} else if (ifp->if_flags & IFF_RUNNING &&
				   !(ifp->if_flags & IFF_PROMISC)) {
				em_disable_promisc(adapter);
			} else
d848 3
d863 1
a863 1
			if (adapter->hw.mac_type == em_82542_rev2_0)
d865 5
a869 1
			em_enable_intr(adapter);
d890 1
a890 1
		IOCTL_DEBUGOUT1("ioctl received: UNKNOWN (0x%d)\n", (int)command);
d894 1
d922 2
a923 1
	printf("em%d: watchdog timeout -- resetting\n", adapter->unit);
d956 1
d972 34
d1066 5
d1089 9
d1103 3
d1115 33
d1150 1
a1150 1
 *  Interrupt Service routine
a1152 1

d1160 3
a1162 3
	u_int32_t       loop_cnt = EM_MAX_INTR;
	u_int32_t       reg_icr;
	struct ifnet    *ifp;
d1164 1
a1164 1
	struct adapter  *adapter = arg;
d1176 12
a1187 1
	ifp = &adapter->interface_data.ac_if;
a1188 2
	em_disable_intr(adapter);
	while (loop_cnt > 0 && 
d1190 4
a1193 1
	       (reg_icr = E1000_READ_REG(&adapter->hw, ICR)) != 0) {
d1195 7
a1201 6
	       (reg_icr = (E1000_READ_REG(&adapter->hw, ICR) & reg_ims)) != 0) {

		/* Re-enable interrupts the first time round this loop */
		if (loop_cnt == EM_MAX_INTR)
		{
			_kernel_irqs_on();
d1203 4
a1206 5
			#ifdef DEBUGLIB
			if (adapter->dev->tx_handler_entered)
				dprintf(("", "Help!! Transmit interrupted!!\n"));
			#endif
		}
d1209 2
a1210 2
		/* Link status change */
		if (reg_icr & (E1000_ICR_RXSEQ | E1000_ICR_LSC)) {
d1212 2
a1213 2
			untimeout(em_local_timer, adapter, 
				  adapter->timer_handle);
d1215 1
a1215 1
			adapter->dev->localtimerset = false;
d1217 3
a1219 3
			adapter->hw.get_link_status = 1;
			em_check_for_link(&adapter->hw);
			em_print_link_status(adapter);
d1221 2
a1222 2
			adapter->timer_handle = 
			timeout(em_local_timer, adapter, 2*hz); 
d1224 1
a1224 1
			adapter->dev->localtimerset = true;
d1226 1
a1226 1
		}
d1228 7
a1234 6
		if (ifp->if_flags & IFF_RUNNING) {
			em_process_receive_interrupts(adapter, -1);
			em_clean_transmit_interrupts(adapter);
		}
		loop_cnt--;
	}
d1237 2
a1238 1
	em_enable_intr(adapter);
d1240 1
a1240 4
	if (ifp->if_flags & IFF_RUNNING && ifp->if_snd.ifq_head != NULL)
		em_start(ifp);

	return;
d1242 1
a1242 10
	/* Were any interrupts actually processed? */
	if (loop_cnt == EM_MAX_INTR)
	{
		/* No - pass on */
		em_enable_intr(adapter);
		return 1;
	}
	else
	{
		/* Yes - set interrupt state back to disabled and claim */
d1247 21
a1267 21
		uint32_t end_time = em_ro_get_time();
		uint32_t irq_time = end_time - start_time;
		uint32_t rx_pkts_this_time = adapter->rx_pkts - prev_rx_pkts;
		uint32_t mm_stats[3];

		_swix(Mbuf_Statistic,
		      _INR(0,4),

                      1,
                      8,
                      10,
                      mm_stats,
                      sizeof(mm_stats));
		dprintf(("IRQStats", "%u-%u (%uus) received=%u, dropped(error)=%u, dropped(filter)=%u, dropped(mbuf)=%u, small mbufs free=%u, large mbufs free=%u\n",
			start_time, end_time, irq_time,
			rx_pkts_this_time,
			(uint32_t)adapter->dropped_pkts - prev_dropped,
			(uint32_t)adapter->dev->stats.st_unwanted_frames - prev_unwanted,
			(uint32_t)adapter->mbuf_alloc_failed - prev_mbuf,
			mm_stats[0],
			mm_stats[2]));
d1269 2
a1270 2
		_kernel_irqs_off();
		em_enable_intr(adapter);
d1272 16
a1287 16
		if (rx_pkts_this_time != 0)
		{
			adapter->rx_interrupts++;
			adapter->rx_irq_time += irq_time;
			if (irq_time > adapter->max_rx_irq_time)
				adapter->max_rx_irq_time = irq_time;
			if (rx_pkts_this_time > adapter->max_rx_pkts)
				adapter->max_rx_pkts = rx_pkts_this_time;
		}
		else
		{
			adapter->non_rx_interrupts++;
			adapter->non_rx_irq_time += irq_time;
			if (irq_time > adapter->max_non_rx_irq_time)
				adapter->max_non_rx_irq_time = irq_time;
		}
d1289 1
a1289 2
		return 0;
	}
d1294 1
d1416 5
d1443 7
d1453 1
a1453 1
	struct m_tag    *mtag;
a1454 1

d1459 4
a1462 1
	/* Force a cleanup if number of TX descriptors available hits the threshold */
d1478 2
a1479 1
	/* Find out if we are in vlan mode */
d1481 4
a1484 4
	if ((m_head->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&
	    m_head->m_pkthdr.rcvif != NULL &&
	    m_head->m_pkthdr.rcvif->if_type == IFT_L2VLAN)
		ifv = m_head->m_pkthdr.rcvif->if_softc;
d1492 1
d1496 45
d1542 2
a1543 5
		if (txd_used == adapter->num_tx_desc_avail) {
			adapter->next_avail_tx_desc = txd_saved;
			adapter->no_tx_desc_avail2++;
			return (ENOBUFS);
		}
d1545 1
a1545 4
		tx_buffer = &adapter->tx_buffer_area[i];
		current_tx_desc = &adapter->tx_desc_base[i];
		virtual_addr = mtod(mp, vm_offset_t);
		current_tx_desc->buffer_addr = vtophys(virtual_addr);
d1547 2
a1548 9
		current_tx_desc->lower.data = (adapter->txd_cmd | txd_lower | mp->m_len);
		current_tx_desc->upper.data = (txd_upper);

		if (++i == adapter->num_tx_desc)
			i = 0;

		tx_buffer->m_head = NULL;

		txd_used++;
d1550 2
a1551 3

	adapter->num_tx_desc_avail -= txd_used;
	adapter->next_avail_tx_desc = i;
d1554 7
a1560 7
	if (ifv != NULL) {
		/* Set the vlan id */
		current_tx_desc->upper.fields.special = ifv->ifv_tag;
#else
	if (mtag != NULL) {
		/* Set the vlan id */
		current_tx_desc->upper.fields.special = VLAN_TAG_VALUE(mtag);
d1562 3
a1564 3
		/* Tell hardware to add tag */
		current_tx_desc->lower.data |= E1000_TXD_CMD_VLE;
	}
d1577 10
a1586 1
	E1000_WRITE_REG(&adapter->hw, TDT, i);
d1592 128
d1726 1
d1730 1
d1735 8
d1765 1
d1811 3
a1813 1
 
d1820 1
a1820 1
        if (mcnt > MAX_NUM_MULTICAST_ADDRESSES) {
d1825 1
a1825 1
                em_mc_addr_list_update(&adapter->hw, mta, mcnt, 0);
d1872 4
d1908 1
a1926 2


d1947 1
a1947 1
	INIT_DEBUGOUT("em_stop: begin\n");
d1951 3
a1953 1
	untimeout(em_local_timer, adapter, adapter->timer_handle);
d1988 1
a1988 1
		adapter->hw.pci_cmd_word |=
d2001 1
a2001 1
        if (em_set_mac_type(&adapter->hw))
d2003 1
a2003 1
                printf("em%d: Unknown MAC Type\n", adapter->unit);
d2005 1
a2005 1
                log_message(adapter->dev, "Unknown MAC Type");
d2008 5
a2043 1

d2069 2
a2070 1
		if (!em_ro_get_pci_io_address(dev, (adapter->io_rid - EM_MMBA) / 4, &adapter->hw.io_base))
d2072 1
d2074 1
a2074 1
		dprintf(("Init", "%s: io_base=&%08X\n", __func__, (unsigned)adapter->hw.io_base));
d2143 1
d2147 3
d2208 3
d2214 4
d2220 5
d2241 2
a2242 2
#if __FreeBSD_version < 500000 
	ether_ifattach(ifp, ETHER_BPF_SUPPORTED);
d2244 1
a2244 1
	ether_ifattach(ifp, adapter->interface_data.ac_enaddr);
d2252 6
a2257 2
#if __FreeBSD_version >= 500000 
	ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU;
d2260 1
d2300 61
d2384 3
d2388 1
d2444 3
d2449 3
a2451 3
	E1000_WRITE_REG(&adapter->hw, TDBAL, 
			vtophys((vm_offset_t) adapter->tx_desc_base));
	E1000_WRITE_REG(&adapter->hw, TDBAH, 0);
a2467 12
	case em_82543:
	case em_82544:
	case em_82540:
	case em_82545:
	case em_82546:
		if (adapter->hw.media_type == em_media_type_fiber)
			reg_tipg = DEFAULT_82543_TIPG_IPGT_FIBER;
		else
			reg_tipg = DEFAULT_82543_TIPG_IPGT_COPPER;
		reg_tipg |= DEFAULT_82543_TIPG_IPGR1 << E1000_TIPG_IPGR1_SHIFT;
		reg_tipg |= DEFAULT_82543_TIPG_IPGR2 << E1000_TIPG_IPGR2_SHIFT;
		break;
d2475 6
a2480 5
#ifndef RISCOS
		printf("em%d: Invalid mac type detected\n", adapter->unit);
#else
		log_message(adapter->dev, "Invalid mac type detected");
#endif
d2482 1
d2484 1
a2484 1
	E1000_WRITE_REG(&adapter->hw, TIDV, adapter->tx_int_delay);
d2486 1
a2486 1
		E1000_WRITE_REG(&adapter->hw, TADV, adapter->tx_abs_int_delay);
d2499 1
a2499 1
	adapter->txd_cmd = E1000_TXD_CMD_IFCS;
d2501 1
a2501 1
	if (adapter->tx_int_delay > 0)
a2503 5
	if (adapter->hw.report_tx_early == 1)
		adapter->txd_cmd |= E1000_TXD_CMD_RS;
	else
		adapter->txd_cmd |= E1000_TXD_CMD_RPS;

d2657 3
a2659 1
#ifdef RISCOS
d2679 2
a2680 2
		num_avail++;
                        
d2683 1
a2707 2
                struct ifnet   *ifp = &adapter->interface_data.ac_if;

d2865 3
d2876 1
a2876 1
			adapter->rx_int_delay | E1000_RDT_FPDB);
d2879 1
a2879 1
		E1000_WRITE_REG(&adapter->hw, RADV, adapter->rx_abs_int_delay);
d2890 4
a2893 3
			vtophys((vm_offset_t) adapter->rx_desc_base));
	E1000_WRITE_REG(&adapter->hw, RDBAH, 0);
	E1000_WRITE_REG(&adapter->hw, RDLEN, adapter->num_rx_desc *
d2946 1
a2946 1
	E1000_WRITE_REG(&adapter->hw, RCTL, reg_rctl);
d3008 1
a3008 1
	struct ether_header *eh;
d3012 2
a3013 2
	u_int8_t            eop = 0;
	u_int16_t           len;
d3039 1
d3045 2
d3050 7
a3056 1
			len = current_desc->length - ETHER_CRC_LEN;
d3059 1
a3059 1
			len = current_desc->length;
d3064 1
a3064 1
			u_int32_t           pkt_len = current_desc->length;
d3070 1
a3070 2
			last_byte = *(mtod(mp, caddr_t) +
				      current_desc->length - 1);			
d3082 1
a3082 1
				len--;
d3112 8
d3125 3
a3127 2
			if (eop) {
				adapter->fmp->m_pkthdr.rcvif = ifp;
d3129 20
a3148 18
#if __FreeBSD_version < 500000 
				eh = mtod(adapter->fmp, struct ether_header *);
				/* Remove ethernet header from mbuf */
				m_adj(adapter->fmp, sizeof(struct ether_header));
				em_receive_checksum(adapter, current_desc, 
						    adapter->fmp);
				if (current_desc->status & E1000_RXD_STAT_VP)
					VLAN_INPUT_TAG(eh, adapter->fmp, 
						       current_desc->special);
				else
					ether_input(ifp, eh, adapter->fmp);
#else

				em_receive_checksum(adapter, current_desc, 
						    adapter->fmp);
				if (current_desc->status & E1000_RXD_STAT_VP)
					VLAN_INPUT_TAG(ifp, adapter->fmp,
						       current_desc->special,
d3150 3
a3152 3
				
				if (adapter->fmp != NULL)
					(*ifp->if_input)(ifp, adapter->fmp);
d3154 3
a3156 3
				adapter->fmp = NULL;
				adapter->lmp = NULL;
			}
d3250 1
a3250 1
	E1000_WRITE_REG(&adapter->hw, VET, QTAG_TYPE);
d3253 6
a3258 1
	ctrl |= E1000_CTRL_VME; 
d3292 12
d3341 1
a3341 1
em_io_read(struct em_hw *hw, uint32_t port)
d3365 1
a3365 1
em_io_write(struct em_hw *hw, uint32_t port, uint32_t value)
d3383 1
a3383 1
} 
d3385 57
d3458 5
a3463 1
	adapter->stats.symerrs += E1000_READ_REG(&adapter->hw, SYMERRS);
d3467 1
a3471 1
	adapter->stats.sec += E1000_READ_REG(&adapter->hw, SEC);
a3536 2
	ifp->if_ipackets = adapter->stats.gprc;
	ifp->if_opackets = adapter->stats.gptc;
d3554 1
a3554 1
	/* The BSD driver forgot these - this code came from the Linux driver */
d3560 6
a3565 7
	if(adapter->hw.media_type == em_media_type_copper) {
		uint16_t phy_tmp;
		if((adapter->link_speed == 1000) &&
		   (!em_read_phy_reg(&adapter->hw, PHY_1000T_STATUS, &phy_tmp))) {
			phy_tmp &= PHY_IDLE_ERROR_COUNT_MASK;
			adapter->phy_stats.idle_errors += phy_tmp;
		}
d3567 6
a3572 4
		if((adapter->hw.mac_type <= em_82546) &&
		   !em_read_phy_reg(&adapter->hw, M88E1000_RX_ERR_CNTR, &phy_tmp))
			adapter->phy_stats.receive_errors += phy_tmp;
	}
d3586 1
a3586 1
em_print_hw_stats(struct adapter *adapter)
d3589 1
d3591 11
d3608 8
a3615 1

d3620 1
a3620 1
	printf("em%d: Std Mbuf Failed = %ld\n",unit, 
d3622 1
a3622 1
	printf("em%d: Std Cluster Failed = %ld\n",unit, 
d3624 2
d3627 12
a3659 2
	printf("em%d: Driver dropped packets = %ld\n", unit, 
	       adapter->dropped_pkts);
d3676 105
@


1.11
log
@Lots of changes due to new code from Intel,this removes lots of
useless code from the driver - smaller and faster?
Now implements blocking if someone (eg.NetFS) tries to transmit before
the link is up.If noone is trying to transmit then the link will
come up in the background.

Version 0.10. Tagged as 'EtherK-0_10'
@
text
@d48 1
d358 1
a358 1
		em_ro_log_message(dev, "Allocation of PCI resources failed");
d378 1
a378 1
		em_ro_log_message(dev, "Unable to allocate TxDescriptor memory");
d397 1
a397 1
		em_ro_log_message(dev, "Unable to allocate rx_desc memory");
d413 1
a413 1
		em_ro_log_message(dev, "Unable to initialise the hardware");
d430 1
a430 1
		em_ro_log_message(dev, "EEPROM read error while reading mac address");
d463 1
a463 1
		em_ro_log_message(dev, "Speed:%d Mbps  Duplex:%s",
d467 1
a467 1
		em_ro_log_message(adapter->dev, "Speed:N/A  Duplex:N/A");
d801 1
a801 1
		em_ro_log_message(adapter->dev, "Unable to initialize the hardware");
d814 1
a814 1
		em_ro_log_message(adapter->dev, "Could not setup transmit structures");
d835 1
a835 1
		em_ro_log_message(adapter->dev, "Could not setup receive structures");
d1430 1
a1430 1
			em_ro_log_message(adapter->dev, "Link is up %d Mbps %s",
d1444 1
a1444 1
			em_ro_log_message(adapter->dev, "Link is Down");
d1513 1
a1513 1
		em_ro_log_message(adapter->dev, "Memory Access and/or Bus Master bits were not set!");
d1532 1
a1532 1
                em_ro_log_message(adapter->dev, "Unknown MAC Type");
d1673 1
a1673 1
		em_ro_log_message(adapter->dev, "The EEPROM Checksum Is Not Valid");
d1683 1
a1683 1
		em_ro_log_message(adapter->dev, "EEPROM read error while reading part number");
d1693 1
a1693 1
		em_ro_log_message(adapter->dev, "Hardware Initialization Failed");
d1817 1
a1817 1
		em_ro_log_message(adapter->dev, "Unable to allocate tx_buffer memory");
d1922 1
a1922 1
		em_ro_log_message(adapter->dev, "Invalid mac type detected");
d2245 1
a2245 1
		em_ro_log_message(adapter->dev, "Unable to allocate rx_buffer memory");
d2764 1
a2764 1
		em_ro_log_error(((struct em_osdep *)hw->back)->dev, e);
d2786 1
a2786 1
		em_ro_log_error(((struct em_osdep *)hw->back)->dev, e);
@


1.10
log
@Adds reentrancy checks to the transmit routine.
Change to spl macros to disable *all* interrupts rather than just the
line relating to the device vector number.
User guide tweak.

Version 0.09. Tagged as 'EtherK-0_09'
@
text
@d51 1
a51 1
 *  Set this to one to display debug statistics
d66 1
a66 1
char em_driver_version[] = "1.4.7";
d80 19
a98 19
	/* Intel(R) PRO/1000 Network Connection */
	{ 0x8086, 0x1000, PCI_ANY_ID, PCI_ANY_ID, 0},
	{ 0x8086, 0x1001, PCI_ANY_ID, PCI_ANY_ID, 0},
	{ 0x8086, 0x1004, PCI_ANY_ID, PCI_ANY_ID, 0},
	{ 0x8086, 0x1008, PCI_ANY_ID, PCI_ANY_ID, 0},
	{ 0x8086, 0x1009, PCI_ANY_ID, PCI_ANY_ID, 0},
	{ 0x8086, 0x100C, PCI_ANY_ID, PCI_ANY_ID, 0},
	{ 0x8086, 0x100D, PCI_ANY_ID, PCI_ANY_ID, 0},
	{ 0x8086, 0x100E, PCI_ANY_ID, PCI_ANY_ID, 0},
	{ 0x8086, 0x100F, PCI_ANY_ID, PCI_ANY_ID, 0},
	{ 0x8086, 0x1010, PCI_ANY_ID, PCI_ANY_ID, 0},
	{ 0x8086, 0x1011, PCI_ANY_ID, PCI_ANY_ID, 0},
	{ 0x8086, 0x1012, PCI_ANY_ID, PCI_ANY_ID, 0},
	{ 0x8086, 0x1015, PCI_ANY_ID, PCI_ANY_ID, 0},
	{ 0x8086, 0x1016, PCI_ANY_ID, PCI_ANY_ID, 0},
	{ 0x8086, 0x1017, PCI_ANY_ID, PCI_ANY_ID, 0},
	{ 0x8086, 0x101E, PCI_ANY_ID, PCI_ANY_ID, 0},
	/* required last entry */
	{ 0, 0, 0, 0, 0}
d110 1
a110 1
 *  Function prototypes
a111 3
#ifdef RISCOS
#define __P(a) a
#endif
d113 12
a124 12
static int  em_probe     __P((device_t));
static int  em_attach        __P((device_t));
static int  em_detach        __P((device_t));
static int  em_shutdown        __P((device_t));
static void em_intr __P((void *));
static void em_start __P((struct ifnet *));
static int  em_ioctl __P((struct ifnet *, IOCTL_CMD_TYPE, caddr_t));
static void em_watchdog __P((struct ifnet *));
static void em_init __P((void *));
static void em_stop __P((void *));
static void em_media_status __P((struct ifnet *, struct ifmediareq *));
static int  em_media_change __P((struct ifnet *));
d126 3
a128 3
static void em_identify_hardware __P((struct adapter *));
static int  em_allocate_pci_resources __P((struct adapter *));
static void em_free_pci_resources __P((struct adapter *));
d130 1
a130 1
static void em_local_timer __P((void *));
d132 2
a133 2
static int  em_hardware_init __P((struct adapter *));
static void em_setup_interface __P((device_t, struct adapter *));
d135 1
a135 1
static int  em_setup_transmit_structures __P((struct adapter *));
d137 1
a137 1
static void em_initialize_transmit_unit __P((struct adapter *));
d139 1
a139 1
static int  em_setup_receive_structures __P((struct adapter *));
d141 3
a143 3
static void em_initialize_receive_unit __P((struct adapter *));
static void em_enable_intr __P((struct adapter *));
static void em_disable_intr __P((struct adapter *));
d145 4
a148 4
static void em_free_transmit_structures __P((struct adapter *));
static void em_free_receive_structures __P((struct adapter *));
static void em_update_stats_counters __P((struct adapter *));
static void em_clean_transmit_interrupts __P((struct adapter *));
d150 3
a152 3
static int  em_allocate_receive_structures __P((struct adapter *));
static int  em_allocate_transmit_structures __P((struct adapter *));
static void em_process_receive_interrupts __P((struct adapter *));
d154 9
a162 9
static void em_receive_checksum __P((struct adapter *,
				     struct em_rx_desc * rx_desc,
				     struct mbuf *));
static void em_transmit_checksum_setup __P((struct adapter *,
					    struct mbuf *,
					    u_int32_t *,
					    u_int32_t *));
static void em_set_promisc __P((struct adapter *));
static void em_disable_promisc __P((struct adapter *));
d164 1
a164 1
static void em_set_multi __P((struct adapter *));
d166 2
a167 2
static void em_print_hw_stats __P((struct adapter *));
static void em_print_link_status __P((struct adapter *));
d169 3
a171 3
static int  em_get_buf __P((struct em_rx_buffer *, struct adapter *,
			    struct mbuf *));
static void em_enable_vlans __P((struct adapter *adapter));
d173 1
a173 1
static int  em_encap __P((struct adapter *adapter, struct mbuf *m_head));
d177 1
a177 1
 *  FreeBSD Device Interface Entry Points
d242 2
a243 2
			sprintf(adapter_name, "%s, Version - %s",
				em_strings[ent->index],
d258 3
a260 3
 *  This routine identifies the type of hardware, allocates all resources
 *  and initializes the hardware.
 *
d309 24
d334 2
a335 23
	/* Parameters (to be read from user) */
	adapter->num_tx_desc = EM_MAX_TXD;
	adapter->num_rx_desc = EM_MAX_RXD;
	adapter->tx_int_delay = EM_TIDV;
	adapter->rx_int_delay = EM_RDTR;
	adapter->hw.autoneg = DO_AUTO_NEG;
	adapter->hw.wait_autoneg_complete = WAIT_FOR_AUTO_NEG_DEFAULT;
	adapter->hw.autoneg_advertised = AUTONEG_ADV_DEFAULT;
	adapter->hw.tbi_compatibility_en = TRUE;
	adapter->rx_buffer_len = EM_RXBUFFER_2048;

	adapter->hw.fc_high_water = FC_DEFAULT_HI_THRESH;
	adapter->hw.fc_low_water  = FC_DEFAULT_LO_THRESH;
	adapter->hw.fc_pause_time = FC_DEFAULT_TX_TIMER;
	adapter->hw.fc_send_xon   = TRUE;
	adapter->hw.fc = em_fc_full;

	/* Set the max frame size assuming standard ethernet sized frames */
	adapter->hw.max_frame_size =
	ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN;

	adapter->hw.min_frame_size =
	MINIMUM_ETHERNET_PACKET_SIZE + ETHER_CRC_LEN;
d354 1
a354 1
		printf("em%d: Allocation of PCI resources failed\n",
d365 2
a366 1

d374 1
a374 1
		printf("em%d: Unable to allocate TxDescriptor memory\n",
d393 1
a393 1
		printf("em%d: Unable to allocate rx_desc memory\n",
d452 1
a452 1
		em_get_speed_and_duplex(&adapter->hw, &adapter->link_speed,
d485 1
a485 1
 *
d513 1
d515 3
d560 1
a560 1
 **********************************************************************/
d572 1
d587 19
a605 3
	int             s;
	struct mbuf    *m_head;
	struct adapter *adapter = ifp->if_softc;
a606 2
	if (!adapter->link_active)
		return;
d608 14
a621 23
	s = splimp();
	while (ifp->if_snd.ifq_head != NULL) {

		IF_DEQUEUE(&ifp->if_snd, m_head);

		if (m_head == NULL) break;

		if (em_encap(adapter, m_head)) {
			ifp->if_flags |= IFF_OACTIVE;
			IF_PREPEND(&ifp->if_snd, m_head);
			break;
		}

		/* Send a copy of the frame to the BPF listener */
		if (ifp->if_bpf)
			bpf_mtap(ifp, m_head);

		/* Set timeout in case hardware has problems transmitting */
		ifp->if_timer = EM_TX_TIMEOUT;

	}
	splx(s);
	return;
d655 1
a655 1
			adapter->hw.max_frame_size =
d754 1
a754 1
 *  by the driver as a hw/sw initialization routine to get to a
d785 7
d795 1
a795 1
		printf("em%d: Unable to initialize the hardware\n",
d810 1
a810 1
		printf("em%d: Could not setup transmit structures\n",
d815 1
a815 1
		em_stop(adapter);
d831 1
a831 1
		printf("em%d: Could not setup receive structures\n",
d876 1
d909 1
a909 2

	while (loop_cnt > 0 &&
d930 1
a930 1
			untimeout(em_local_timer, adapter,
d939 2
a940 2
			adapter->timer_handle =
			timeout(em_local_timer, adapter, 2*hz);
d947 1
a947 1
			em_process_receive_interrupts(adapter);
d1042 2
a1043 2
			em_get_speed_and_duplex(&adapter->hw,
						&adapter->link_speed,
d1074 1
a1074 1
#if __FreeBSD_version < 500000
d1116 1
a1116 1
#if __FreeBSD_version < 500000
a1149 1

d1160 15
a1174 12
{
	vm_offset_t     virtual_addr;
	u_int32_t       txd_upper;
	u_int32_t       txd_lower;
	u_int16_t       txd_used, count;

	struct mbuf     *mp;
	struct ifvlan *ifv = NULL;
	struct em_tx_buffer   *tx_buffer;
	struct em_tx_desc *saved_tx_desc = NULL;
	struct em_tx_desc *current_tx_desc = NULL;
	struct ifnet   *ifp = &adapter->interface_data.ac_if;
d1176 1
a1176 1
	/* Force a cleanup if number of descriptors available hit the threshold */
a1184 22
	/* Find out number of fragments in a mbuf chain */
	count = 0;
	for (mp = m_head; mp != NULL; mp = mp->m_next) {
		if (mp->m_len == 0)
			continue;
		count++;
	}

	/* Bail out if we don't have enough descriptors */
	if (adapter->num_tx_desc_avail <= count) {
		em_clean_transmit_interrupts(adapter);
		adapter->no_tx_desc_avail2++;
		return (ENOBUFS);
	}

	tx_buffer =  STAILQ_FIRST(&adapter->free_tx_buffer_list);
	if (!tx_buffer) {
		adapter->no_tx_buffer_avail1++;
		return (ENOBUFS);
	}

	/* Setup checksum context */
a1187 3
	} else {
		txd_upper = 0;
		txd_lower = 0;
d1189 2
d1193 1
d1198 3
d1202 2
a1203 1

a1204 1
	saved_tx_desc = adapter->next_avail_tx_desc;
d1209 3
a1211 4
		tx_buffer =  STAILQ_FIRST(&adapter->free_tx_buffer_list);
		if (!tx_buffer) {
			adapter->no_tx_buffer_avail2++;
			adapter->next_avail_tx_desc = saved_tx_desc;
d1215 2
a1216 1
		current_tx_desc = adapter->next_avail_tx_desc;
d1223 4
a1226 5
		if (current_tx_desc == adapter->last_tx_desc)
			adapter->next_avail_tx_desc =
			adapter->first_tx_desc;
		else
			adapter->next_avail_tx_desc++;
d1229 1
d1231 2
a1232 7
		tx_buffer->m_head = NULL;
		tx_buffer->used_tx_desc = current_tx_desc;
		STAILQ_REMOVE_HEAD(&adapter->free_tx_buffer_list, em_tx_entry);
		STAILQ_INSERT_TAIL(&adapter->used_tx_buffer_list, tx_buffer,
				   em_tx_entry);
	}
	adapter->num_tx_desc_avail-= txd_used;
d1234 1
d1236 7
a1244 3

		/* Set the vlan id */
		current_tx_desc->upper.fields.special = ifv->ifv_tag;
a1246 4
	/* Last Descriptor of Packet needs End Of Packet (EOP) bit set. */
	current_tx_desc->lower.data |= E1000_TXD_CMD_EOP;

	/* Save mbuf chain so that we can free it during transmit cleanup */
d1248 5
d1254 1
a1254 1
	/*
d1258 1
a1258 3
	E1000_WRITE_REG(&adapter->hw, TDT,
			(((uintptr_t) adapter->next_avail_tx_desc -
			  (uintptr_t) adapter->first_tx_desc) >> 4));
d1260 1
a1260 1
	return(0);
d1314 2
a1315 2
	u_int32_t reg_rctl = 0;
	u_int8_t  mta[MAX_NUM_MULTICAST_ADDRESSES * ETH_LENGTH_OF_ADDRESS];
d1317 1
a1317 1
	struct ifmultiaddr  *ifma;
d1319 1
a1319 1
	int mcnt = 0;
d1321 1
a1321 1
	struct ifnet   *ifp = &adapter->interface_data.ac_if;
d1323 13
a1335 13

	IOCTL_DEBUGOUT("em_set_multi: begin");

	if (adapter->hw.mac_type == em_82542_rev2_0) {
		reg_rctl = E1000_READ_REG(&adapter->hw, RCTL);
		if (adapter->hw.pci_cmd_word & CMD_MEM_WRT_INVALIDATE) {
			em_pci_clear_mwi(&adapter->hw);
		}
		reg_rctl |= E1000_RCTL_RST;
		E1000_WRITE_REG(&adapter->hw, RCTL, reg_rctl);
		msec_delay(5);
	}

d1338 1
a1338 1
	LIST_FOREACH(ifma, &ifp->if_multiaddrs, ifma_link) {
d1340 27
a1366 17
	TAILQ_FOREACH(ifma, &ifp->if_multiaddrs, ifma_link) {
#endif
		if (ifma->ifma_addr->sa_family != AF_LINK)
			continue;

		bcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),
		      &mta[mcnt*ETH_LENGTH_OF_ADDRESS], ETH_LENGTH_OF_ADDRESS);
		mcnt++;
	}
#endif

	if (mcnt > MAX_NUM_MULTICAST_ADDRESSES) {
		reg_rctl = E1000_READ_REG(&adapter->hw, RCTL);
		reg_rctl |= E1000_RCTL_MPE;
		E1000_WRITE_REG(&adapter->hw, RCTL, reg_rctl);
	} else
		em_mc_addr_list_update(&adapter->hw, mta, mcnt, 0);
d1368 1
a1368 11
	if (adapter->hw.mac_type == em_82542_rev2_0) {
		reg_rctl = E1000_READ_REG(&adapter->hw, RCTL);
		reg_rctl &= ~E1000_RCTL_RST;
		E1000_WRITE_REG(&adapter->hw, RCTL, reg_rctl);
		msec_delay(5);
		if (adapter->hw.pci_cmd_word & CMD_MEM_WRT_INVALIDATE) {
			em_pci_set_mwi(&adapter->hw);
		}
	}

	return;
d1398 1
a1398 1
	em_update_stats_counters(adapter);
d1419 2
a1420 2
			em_get_speed_and_duplex(&adapter->hw,
						&adapter->link_speed,
d1454 1
d1458 1
a1458 1
 *  global reset on the MAC and deallocates TX/RX buffers.
d1509 1
a1509 1
		printf("em%d: Memory Access and/or Bus Master bits were not set!\n",
d1527 1
a1527 1
	if (em_set_mac_type(&adapter->hw))
d1529 1
a1529 1
		printf("em%d: Unknown MAC Type\n", adapter->unit);
d1531 1
a1531 1
		em_ro_log_message(adapter->dev, "Unknown MAC Type");
d1534 1
a1534 1
	return;
d1549 1
a1549 1
		printf("em%d: Unable to allocate bus resource: memory\n",
d1553 1
a1553 1
	adapter->osdep.mem_bus_space_tag =
d1555 1
a1555 1
	adapter->osdep.mem_bus_space_handle =
d1579 1
a1579 1
		adapter->res_ioport = bus_alloc_resource(dev, SYS_RES_IOPORT,
d1581 1
a1581 1
							 RF_ACTIVE);
d1585 1
a1585 1
			return(ENXIO);
d1604 1
a1604 1
		printf("em%d: Unable to allocate bus resource: interrupt\n",
d1611 1
a1611 1
		printf("em%d: Error registering interrupt handler!\n",
d1632 1
a1632 1
		bus_teardown_intr(dev, adapter->res_interrupt,
d1634 1
a1634 1
		bus_release_resource(dev, SYS_RES_IRQ, 0,
d1638 1
a1638 1
		bus_release_resource(dev, SYS_RES_MEMORY, EM_MMBA,
d1643 1
a1643 1
		bus_release_resource(dev, SYS_RES_IOPORT, adapter->io_rid,
d1678 1
d1681 3
d1704 2
a1705 2
		em_get_speed_and_duplex(&adapter->hw,
					&adapter->link_speed,
d1744 2
d1747 3
d1756 5
a1760 1
	/*
d1767 1
a1767 1
		ifmedia_add(&adapter->media, IFM_ETHER | IFM_1000_SX | IFM_FDX,
d1769 1
a1769 1
		ifmedia_add(&adapter->media, IFM_ETHER | IFM_1000_SX,
d1773 1
a1773 1
		ifmedia_add(&adapter->media, IFM_ETHER | IFM_10_T | IFM_FDX,
d1775 1
a1775 1
		ifmedia_add(&adapter->media, IFM_ETHER | IFM_100_TX,
d1777 1
a1777 1
		ifmedia_add(&adapter->media, IFM_ETHER | IFM_100_TX | IFM_FDX,
d1779 2
a1780 2
#if __FreeBSD_version < 500000
		ifmedia_add(&adapter->media, IFM_ETHER | IFM_1000_TX | IFM_FDX,
d1784 1
a1784 1
		ifmedia_add(&adapter->media, IFM_ETHER | IFM_1000_T | IFM_FDX,
d1799 2
a1800 2
 *  Allocate memory for tx_buffer structures. The tx_buffer stores all
 *  the information needed to transmit a packet on the wire.
d1808 1
a1808 1
	      (struct em_tx_buffer *) malloc(sizeof(struct em_tx_buffer) *
d1811 1
a1811 1
		printf("em%d: Unable to allocate tx_buffer memory\n",
d1829 1
a1829 1
 *  Allocate and initialize transmit structures.
a1838 3
	struct em_tx_buffer   *tx_buffer;
	int             i;

d1842 5
a1846 25
	adapter->first_tx_desc = adapter->tx_desc_base;
	adapter->last_tx_desc =
	adapter->first_tx_desc + (adapter->num_tx_desc - 1);


	STAILQ_INIT(&adapter->free_tx_buffer_list);
	STAILQ_INIT(&adapter->used_tx_buffer_list);

	tx_buffer = adapter->tx_buffer_area;

	/* Setup the linked list of the tx_buffer's */
	for (i = 0; i < adapter->num_tx_desc; i++, tx_buffer++) {
		bzero((void *) tx_buffer, sizeof(struct em_tx_buffer));
#ifdef RISCOS
		tx_buffer->buffer_addr = vtophys((vm_offset_t)&tx_buffer->buffer[ETHER_ALIGN]);
#endif
		STAILQ_INSERT_TAIL(&adapter->free_tx_buffer_list,
				   tx_buffer, em_tx_entry);
	}

	bzero((void *) adapter->first_tx_desc,
	      (sizeof(struct em_tx_desc)) * adapter->num_tx_desc);

	/* Setup TX descriptor pointers */
	adapter->next_avail_tx_desc = adapter->first_tx_desc;
d1855 7
d1880 1
a1880 1
	E1000_WRITE_REG(&adapter->hw, TDBAL,
d1883 1
a1883 1
	E1000_WRITE_REG(&adapter->hw, TDLEN,
d1892 1
a1892 1
	HW_DEBUGOUT2("Base = %x, Length = %x\n",
d1926 2
d1939 1
a1939 1
	/* Setup Transmit Descriptor Settings for this adapter */
d1966 1
a1966 1
	struct em_tx_buffer   *tx_buffer;
d2002 1
a2002 1
em_transmit_checksum_setup(struct adapter *adapter,
d2005 1
a2005 1
			   u_int32_t *txd_lower)
d2008 2
a2009 2
	struct em_tx_desc * current_tx_desc;
	struct em_tx_buffer *tx_buffer;
d2042 3
a2044 2
	current_tx_desc = adapter->next_avail_tx_desc;
	tx_buffer =  STAILQ_FIRST(&adapter->free_tx_buffer_list);
a2045 1
	TXD = (struct em_context_desc *)current_tx_desc;
d2047 4
a2050 4
	TXD->lower_setup.ip_fields.ipcso =
	ETHER_HDR_LEN + offsetof(struct ip, ip_sum);
	TXD->lower_setup.ip_fields.ipcse =
	ETHER_HDR_LEN + sizeof(struct ip) - 1;
d2052 2
a2053 2
	TXD->upper_setup.tcp_fields.tucss =
	ETHER_HDR_LEN + sizeof(struct ip);
d2057 3
a2059 3
		TXD->upper_setup.tcp_fields.tucso =
		ETHER_HDR_LEN + sizeof(struct ip) +
		offsetof(struct tcphdr, th_sum);
d2061 3
a2063 3
		TXD->upper_setup.tcp_fields.tucso =
		ETHER_HDR_LEN + sizeof(struct ip) +
		offsetof(struct udphdr, uh_sum);
d2069 4
a2072 4
	if (current_tx_desc == adapter->last_tx_desc)
		adapter->next_avail_tx_desc = adapter->first_tx_desc;
	else
		adapter->next_avail_tx_desc++;
d2075 1
a2076 3
	tx_buffer->used_tx_desc = current_tx_desc;
	STAILQ_REMOVE_HEAD(&adapter->free_tx_buffer_list, em_tx_entry);
	STAILQ_INSERT_TAIL(&adapter->used_tx_buffer_list, tx_buffer, em_tx_entry);
d2095 5
d2101 1
a2102 2
	int             s;
	struct ifnet   *ifp;
d2104 1
a2104 1
	uint8_t        *last_dest_addr = NULL;
d2107 4
a2110 1
	s = splimp();
d2112 1
a2112 1
	adapter->clean_tx_interrupts++;
d2114 2
d2117 2
a2118 3
	for (tx_buffer = STAILQ_FIRST(&adapter->used_tx_buffer_list);
	    tx_buffer;
	    tx_buffer = STAILQ_FIRST(&adapter->used_tx_buffer_list)) {
d2120 1
a2120 16
		/*
		 * Get hold of the next descriptor that the hardware will report status
		 * back to. There is 1/1 correspondence between a tx descriptor
		 * and tx_buffer.
		 */

		tx_desc = tx_buffer->used_tx_desc;

		/*
		 * If the descriptor done bit is set, free tx_buffer and associated
		 * resources
		 */
		if (tx_desc->upper.fields.status & E1000_TXD_STAT_DD) {

			tx_desc->upper.data = 0;
			adapter->num_tx_desc_avail++;
d2122 3
d2126 4
a2129 4
			if (tx_buffer->m_head) {
				m_freem(tx_buffer->m_head);
				tx_buffer->m_head = NULL;
			}
d2131 1
a2131 1
			last_dest_addr = &tx_buffer->buffer[ETHER_ALIGN];
d2134 6
a2139 13
			STAILQ_REMOVE_HEAD(&adapter->used_tx_buffer_list,
					   em_tx_entry);
			/* Return this tx_buffer back to the "free" list */
			STAILQ_INSERT_TAIL(&adapter->free_tx_buffer_list,
					   tx_buffer, em_tx_entry);
		} else {
			/*
			 * Found a tx_buffer that the em is not done with then there is
			 * no reason to check the rest of the queue.
			 */
			break;
		}
	}		      /* end for each tx_buffer */
d2141 1
a2141 1
	ifp = &adapter->interface_data.ac_if;
d2144 15
a2158 5
	/* Tell the stack that it is OK to send packets */
	if (adapter->num_tx_desc_avail > EM_TX_CLEANUP_THRESHOLD) {
		ifp->if_timer = 0;
		ifp->if_flags &= ~IFF_OACTIVE;
	}
d2160 1
a2160 7
	/*
	 * For the RISC OS driver, reset the watchdog timer when all packets
	 * have been sent. This should be correct, shouldn't it?
	 */
	if (adapter->num_tx_desc_avail == adapter->num_tx_desc) {
		ifp->if_timer = 0;
	}
a2163 16

	#ifdef DEBUGLIB
	{
		int free = 0;

		for (tx_buffer = STAILQ_FIRST(&adapter->free_tx_buffer_list);
		     tx_buffer;
		     tx_buffer = STAILQ_NEXT(tx_buffer, em_tx_entry))
		{
			free++;
		}

		if (free != adapter->num_tx_desc_avail)
			dprintf(("", "Help!! Mismatch between TX buffer list (free=%d), and TXD count (avail=%d)\n", free, adapter->num_tx_desc_avail));
	}
	#endif
d2165 3
a2167 2
	splx(s);
	return;
a2169 1

d2176 2
a2177 2
em_get_buf(struct em_rx_buffer *rx_buffer, struct adapter *adapter,
	   struct mbuf *mp)
d2180 1
a2180 1
	struct mbuf    *nmp;
d2186 2
a2187 2
		MGETHDR(nmp, M_DONTWAIT, MT_DATA);
		if (nmp == NULL) {
d2191 3
a2193 3
		MCLGET(nmp, M_DONTWAIT);
		if ((nmp->m_flags & M_EXT) == 0) {
			m_freem(nmp);
d2197 1
a2197 1
		nmp->m_len = nmp->m_pkthdr.len = MCLBYTES;
d2199 3
a2201 4
		nmp = mp;
		nmp->m_len = nmp->m_pkthdr.len = MCLBYTES;
		nmp->m_data = nmp->m_ext.ext_buf;
		nmp->m_next = NULL;
d2205 1
a2205 1
		m_adj(nmp, ETHER_ALIGN);
d2207 4
a2210 3

	rx_buffer->m_head = nmp;
	rx_buffer->buffer_addr = vtophys(mtod(nmp, vm_offset_t));
d2213 1
a2213 1
	(void)mp;
d2215 1
a2215 2
	rx_buffer->m_head = NULL;
	rx_buffer->buffer_addr = vtophys((vm_offset_t)&rx_buffer->buffer[ETHER_ALIGN]);
d2223 3
a2225 3
 *  Allocate memory for rx_buffer structures. Since we use one
 *  rx_buffer per received packet, the maximum number of rx_buffer's
 *  that we'll need is equal to the number of receive descriptors
a2232 1
	struct em_rx_buffer   *rx_buffer;
d2236 1
a2236 1
	      (struct em_rx_buffer *) malloc(sizeof(struct em_rx_buffer) *
d2239 1
a2239 1
		printf("em%d: Unable to allocate rx_buffer memory\n",
d2250 3
d2254 1
d2256 6
a2261 5
	for (i = 0, rx_buffer = adapter->rx_buffer_area;
	    i < adapter->num_rx_desc; i++, rx_buffer++) {

		if (em_get_buf(rx_buffer, adapter, NULL) == ENOBUFS) {
			rx_buffer->m_head = NULL;
d2272 1
a2272 1
 *
d2281 2
a2282 3
	struct em_rx_buffer   *rx_buffer;
	struct em_rx_desc     *rx_desc;
	int             i;
a2286 30
	STAILQ_INIT(&adapter->rx_buffer_list);

	adapter->first_rx_desc =
	(struct em_rx_desc *) adapter->rx_desc_base;
	adapter->last_rx_desc =
	adapter->first_rx_desc + (adapter->num_rx_desc - 1);

	rx_buffer = (struct em_rx_buffer *) adapter->rx_buffer_area;

	bzero((void *) adapter->first_rx_desc,
	      (sizeof(struct em_rx_desc)) * adapter->num_rx_desc);

	/* Build a linked list of rx_buffer's */
	for (i = 0, rx_desc = adapter->first_rx_desc;
	    i < adapter->num_rx_desc;
	    i++, rx_buffer++, rx_desc++) {
#ifndef RISCOS
		if (rx_buffer->m_head == NULL)
			printf("em%d: Receive buffer memory not allocated",
			       adapter->unit);
#else
		if (0);
#endif
		else {
			rx_desc->buffer_addr = rx_buffer->buffer_addr;
			STAILQ_INSERT_TAIL(&adapter->rx_buffer_list,
					   rx_buffer, em_rx_entry);
		}
	}

d2288 1
a2288 1
	adapter->next_rx_desc_to_check = adapter->first_rx_desc;
d2300 1
a2300 1
 *
d2317 1
a2317 1
	E1000_WRITE_REG(&adapter->hw, RDTR,
d2320 10
d2331 1
a2331 1
	E1000_WRITE_REG(&adapter->hw, RDBAL,
d2339 1
a2339 3
	E1000_WRITE_REG(&adapter->hw, RDT,
			(((uintptr_t) adapter->last_rx_desc -
			  (uintptr_t) adapter->first_rx_desc) >> 4));
d2364 1
a2364 1
		break;
d2378 1
a2378 1
	if ((adapter->hw.mac_type >= em_82543) &&
d2402 1
a2402 1
em_free_receive_structures(struct adapter * adapter)
d2404 2
a2405 1
	struct em_rx_buffer   *rx_buffer;
d2407 1
d2411 1
d2420 1
d2438 3
d2443 1
a2443 1
em_process_receive_interrupts(struct adapter * adapter)
d2445 1
a2446 1
	struct ifnet        *ifp;
d2448 1
d2451 1
a2451 2
	u_int16_t           len;
	u_int8_t            last_byte;
d2454 2
a2455 1
	u_int32_t           pkt_len = 0;
a2461 2
	struct em_rx_desc   *last_desc_processed;
	struct em_rx_buffer *rx_buffer;
d2464 2
a2465 1
	current_desc = adapter->next_rx_desc_to_check;
d2479 1
a2479 6
	while (current_desc->status & E1000_RXD_STAT_DD) {

		/* Get a pointer to the actual receive buffer */
		rx_buffer = STAILQ_FIRST(&adapter->rx_buffer_list);

		if (rx_buffer == NULL) {
d2481 1
a2481 3
			printf("em%d: Found null rx_buffer\n", adapter->unit);
#else
			em_ro_log_message(adapter->dev, "Found null rx_buffer");
a2482 2
			return;
		}
a2483 3
#ifndef RISCOS
		mp = rx_buffer->m_head;
#endif
a2484 1

d2486 1
d2495 2
a2497 2
			/* Compute packet length for tbi_accept macro */
			pkt_len = current_desc->length;
d2499 5
a2503 6
			if (adapter->fmp != NULL) {
				pkt_len += adapter->fmp->m_pkthdr.len;
			}

			last_byte = *(mtod(rx_buffer->m_head,caddr_t) +
				      current_desc->length - 1);
d2505 1
a2505 1
			last_byte = rx_buffer->buffer[ETHER_ALIGN + current_desc->length - 1];
d2508 2
a2509 2
			if (TBI_ACCEPT(&adapter->hw, current_desc->status,
				       current_desc->errors,
d2511 3
a2513 3
				em_tbi_adjust_stats(&adapter->hw,
						    &adapter->stats,
						    pkt_len,
d2516 2
a2517 1
			} else {
d2525 1
a2525 1
			if (em_get_buf(rx_buffer, adapter, NULL) == ENOBUFS) {
d2527 3
a2529 2
				em_get_buf(rx_buffer, adapter, mp);
				if (adapter->fmp != NULL) m_freem(adapter->fmp);
d2553 1
a2554 1

d2557 1
a2557 1
				em_receive_checksum(adapter, current_desc,
d2560 1
a2560 1
					VLAN_INPUT_TAG(eh, adapter->fmp,
d2564 1
d2566 10
d2581 3
a2583 2
			em_get_buf(rx_buffer, adapter, mp);
			if (adapter->fmp != NULL) m_freem(adapter->fmp);
d2589 1
a2589 1
			em_ro_filter_packet(adapter, &rx_buffer->buffer[ETHER_ALIGN], len, &mp, &fs);
a2597 19
		if (rx_buffer->m_head != NULL) {
			current_desc->buffer_addr = rx_buffer->buffer_addr;
		}

		/* Advance our pointers to the next descriptor (checking for wrap). */
		if (current_desc == adapter->last_rx_desc)
			adapter->next_rx_desc_to_check = adapter->first_rx_desc;
		else
			((adapter)->next_rx_desc_to_check)++;

		last_desc_processed = current_desc;
		current_desc = adapter->next_rx_desc_to_check;
		/*
		 * Put the buffer that we just indicated back at the end of our list
		 */
		STAILQ_REMOVE_HEAD(&adapter->rx_buffer_list, em_rx_entry);
		STAILQ_INSERT_TAIL(&adapter->rx_buffer_list,
				   rx_buffer, em_rx_entry);

d2601 3
d2605 6
a2610 4
		/* Advance the E1000's Receive Queue #0  "Tail Pointer". */
		E1000_WRITE_REG(&adapter->hw, RDT,
				(((u_long) last_desc_processed -
				  (u_long) adapter->first_rx_desc) >> 4));
d2612 1
d2622 1
a2622 1
 *  Verify that the hardware indicated that the checksum is valid.
d2654 1
a2654 1
		/* Did it pass? */
d2656 1
a2656 1
			mp->m_pkthdr.csum_flags |=
d2667 2
a2668 1
static void em_enable_vlans(struct adapter *adapter)
d2675 1
a2675 1
	ctrl |= E1000_CTRL_VME;
d2696 1
a2696 1
	E1000_WRITE_REG(&adapter->hw, IMC,
d2709 1
a2709 1
void
d2711 2
a2712 2
		 uint32_t reg,
		 uint16_t *value)
d2714 1
a2714 1
	pci_write_config(((struct em_osdep *)hw->back)->dev, reg,
d2718 1
a2718 1
void
d2720 1
a2720 1
		uint16_t *value)
a2726 1

d2730 4
a2733 4
	pci_write_config(((struct em_osdep *)hw->back)->dev,
			 PCIR_COMMAND,
			 (hw->pci_cmd_word | CMD_MEM_WRT_INVALIDATE), 2);
	return;
d2739 4
a2742 4
	pci_write_config(((struct em_osdep *)hw->back)->dev,
			 PCIR_COMMAND,
			 (hw->pci_cmd_word & ~CMD_MEM_WRT_INVALIDATE), 2);
	return;
d2745 1
a2745 1
uint32_t
d2769 1
a2769 1
void
d2788 1
a2788 2
}

d2792 1
a2792 1
 *  Update the board statistics counters.
d2836 1
a2836 1
	adapter->stats.gorcl += E1000_READ_REG(&adapter->hw, GORCL);
d2864 1
a2864 1
		adapter->stats.algnerrc +=
d2866 1
a2866 1
		adapter->stats.rxerrc +=
d2868 1
a2868 1
		adapter->stats.tncrs +=
d2870 1
a2870 1
		adapter->stats.cexterr +=
d2872 1
a2872 1
		adapter->stats.tsctc +=
d2874 1
a2874 1
		adapter->stats.tsctfc +=
d2894 1
a2894 1
	adapter->stats.rlec + adapter->stats.rnbc +
d2936 1
a2936 1
	printf("em%d: Packets not Avail = %ld\n", unit,
d2938 1
a2938 1
	printf("em%d: CleanTxInterrupts = %ld\n", unit,
d2942 1
a2942 1
	printf("em%d: Tx Descriptors not avail1 = %ld\n", unit,
d2944 1
a2944 1
	printf("em%d: Tx Descriptors not avail2 = %ld\n", unit,
d2946 1
a2946 5
	printf("em%d: Tx Buffer not avail1 = %ld\n", unit,
	       adapter->no_tx_buffer_avail1);
	printf("em%d: Tx Buffer not avail2 = %ld\n", unit,
	       adapter->no_tx_buffer_avail2);
	printf("em%d: Std Mbuf Failed = %ld\n",unit,
d2948 1
a2948 1
	printf("em%d: Std Cluster Failed = %ld\n",unit,
a2949 2
	printf("em%d: Number of TX desc avail = %d\n", unit,
	       adapter->num_tx_desc_avail);
d2951 1
a2951 1
	printf("em%d: Symbol errors = %lld\n", unit,
d2953 1
a2953 1
	printf("em%d: Sequence errors = %lld\n", unit,
d2955 1
a2955 1
	printf("em%d: Defer count = %lld\n", unit,
d2958 1
a2958 1
	printf("em%d: Missed Packets = %lld\n", unit,
d2960 1
a2960 1
	printf("em%d: Receive No Buffers = %lld\n", unit,
d2962 1
a2962 1
	printf("em%d: Receive length errors = %lld\n", unit,
d2964 1
a2964 1
	printf("em%d: Receive errors = %lld\n", unit,
d2966 1
a2966 1
	printf("em%d: Crc errors = %lld\n", unit,
d2968 1
a2968 1
	printf("em%d: Alignment errors = %lld\n", unit,
d2972 1
a2972 1
	printf("em%d: Driver dropped packets = %ld\n", unit,
d2975 1
a2975 1
	printf("em%d: XON Rcvd = %lld\n", unit,
d2977 1
a2977 1
	printf("em%d: XON Xmtd = %lld\n", unit,
d2979 1
a2979 1
	printf("em%d: XOFF Rcvd = %lld\n", unit,
d2981 1
a2981 1
	printf("em%d: XOFF Xmtd = %lld\n", unit,
@


1.9
log
@Tidy up syntax messages
Addition of user guide
Rearrange ekinfo output
Function names stripped to save ROM space
Add link failures and polarity statistics

Version 0.08. Tagged as 'EtherK-0_08'
@
text
@d899 1
d901 6
d2173 16
@


1.8
log
@Interrupt handling got broken in 0.06 so although packets were being
received noone ever saw them.
Change to DCI flags.
Addition of new Configure keywords (EkAdvertise and EkFlowControl).
Improvement to the interrupt handler so interrupts are turned off for
slightly less time.

Version 0.07. Tagged as 'EtherK-0_07'
@
text
@a44 1
#include <DebugLib/DebugLib.h>
d1437 1
d2214 3
@


1.7
log
@Merge in changes from the latest BSD driver. EtherK is now based on
version 1.4.7 of the FreeBSD 'em' device driver.
Merge in changes from the latest BSD driver. EtherK is now based on version

Version 0.06. Tagged as 'EtherK-0_06'
@
text
@d276 1
d278 1
d293 2
a308 2
#else
	s = splimp();
d350 1
a350 1
	em_ro_check_options(adapter->dev);
d358 1
a358 1
		em_ro_log_message(adapter->dev, "Allocation of PCI resources failed");
d361 1
d363 1
d377 1
a377 1
		em_ro_log_message(adapter->dev, "Unable to allocate TxDescriptor memory");
d380 1
d382 1
d396 1
a396 1
		em_ro_log_message(adapter->dev, "Unable to allocate rx_desc memory");
d400 1
d402 1
d412 1
a412 1
		em_ro_log_message(adapter->dev, "Unable to initialize the hardware");
d417 1
d419 1
d429 1
a429 1
		em_ro_log_message(adapter->dev, "EEPROM read error while reading mac address");
a433 1
		splx(s);
d462 1
a462 1
		em_ro_log_message(adapter->dev, "Speed:%d Mbps  Duplex:%s",
d471 1
d473 3
d498 1
d500 1
d504 1
d506 3
d546 1
d548 1
d757 1
d759 1
d767 1
d769 3
a783 1
		splx(s);
d799 1
a800 1
#ifndef RISCOS
d820 1
a821 1
#ifndef RISCOS
d843 1
a843 1
	adapter->dev->localtimerset = 1;
d846 3
d851 1
a852 1
#ifndef RISCOS
d878 1
a878 1
	u_int32_t       reg_ims;
d891 1
a891 3
#ifdef RISCOS
	reg_ims = E1000_READ_REG(&adapter->hw, IMS); /* Will also flush interrupt disable write */
#endif
d909 1
a909 1
			adapter->dev->localtimerset = 0;
d918 1
a918 1
			adapter->dev->localtimerset = 1;
d1473 1
a1473 1
	adapter->dev->localtimerset = 0;
@


1.6
log
@Addition of support for *CONFIGURE eklink to allow forceable setting of speed
Fix to link list handler so multiple 82540's are supported at once

Version 0.05. Tagged as 'EtherK-0_05'
@
text
@d3 1
a3 1
Copyright (c) 2001-2002 Intel Corporation
d6 9
a14 11
Redistribution and use in source and binary forms of the Software, with or
without modification, are permitted provided that the following conditions
are met:

 1. Redistributions of source code of the Software may retain the above
    copyright notice, this list of conditions and the following disclaimer.

 2. Redistributions in binary form of the Software may reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.
d17 2
a18 2
    contributors shall be used to endorse or promote products derived from
    this Software without specific prior written permission.
d23 8
a30 8
ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR ITS CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
d67 1
a67 1
char em_driver_version[] = "1.3.14";
d94 4
a101 1

d133 1
d135 1
d138 1
d140 1
d142 1
d144 1
d148 1
a150 1
#ifndef RISCOS
a162 1
					    struct em_tx_buffer *,
d167 1
d169 1
d176 3
d313 4
a316 4
	adapter->num_tx_desc = MAX_TXD;
	adapter->num_rx_desc = MAX_RXD;
	adapter->tx_int_delay = TIDV;
	adapter->rx_int_delay = RIDV;
d420 5
a424 1

d456 1
a456 1
	} else
d531 6
a546 1

d562 2
a563 7
	struct mbuf    *m_head, *mp;
	vm_offset_t     virtual_addr;
	u_int32_t       txd_upper;
	u_int32_t       txd_lower;
	struct em_tx_buffer   *tx_buffer;
	struct em_tx_desc *current_tx_desc = NULL;
	struct adapter * adapter = ifp->if_softc;
a569 1
		struct ifvlan *ifv = NULL;
d575 1
a575 4
		if (adapter->num_tx_desc_avail <= TX_CLEANUP_THRESHOLD)
			em_clean_transmit_interrupts(adapter);

		if (adapter->num_tx_desc_avail <= TX_CLEANUP_THRESHOLD) {
a577 1
			adapter->no_tx_desc_avail++;
a580 74
		tx_buffer =  STAILQ_FIRST(&adapter->free_tx_buffer_list);
		if (!tx_buffer) {
			adapter->no_tx_buffer_avail1++;
			/*
			 * OK so we should not get here but I've seen it so let
			 * us try to clean up and then try to get a tx_buffer
			 * again and only break if we still don't get one.
			 */
			em_clean_transmit_interrupts(adapter);
			tx_buffer = STAILQ_FIRST(&adapter->free_tx_buffer_list);
			if (!tx_buffer) {
				ifp->if_flags |= IFF_OACTIVE;
				IF_PREPEND(&ifp->if_snd, m_head);
				adapter->no_tx_buffer_avail2++;
				break;
			}
		}
		STAILQ_REMOVE_HEAD(&adapter->free_tx_buffer_list, em_tx_entry);

		tx_buffer->num_tx_desc_used = 0;
		tx_buffer->m_head = m_head;

		if (ifp->if_hwassist > 0) {
			em_transmit_checksum_setup(adapter,  m_head, tx_buffer,
						   &txd_upper, &txd_lower);
		} else {
			txd_upper = 0;
			txd_lower = 0;
		}

		/* Find out if we are in vlan mode */
		if ((m_head->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&
		    m_head->m_pkthdr.rcvif != NULL &&
		    m_head->m_pkthdr.rcvif->if_type == IFT_L2VLAN)
			ifv = m_head->m_pkthdr.rcvif->if_softc;

		for (mp = m_head; mp != NULL; mp = mp->m_next) {
			if (mp->m_len == 0)
				continue;
			current_tx_desc = adapter->next_avail_tx_desc;
			virtual_addr = mtod(mp, vm_offset_t);
			current_tx_desc->buffer_addr = vtophys(virtual_addr);

			current_tx_desc->lower.data = (txd_lower | mp->m_len);
			current_tx_desc->upper.data = (txd_upper);

			if (current_tx_desc == adapter->last_tx_desc)
				adapter->next_avail_tx_desc =
				adapter->first_tx_desc;
			else
				adapter->next_avail_tx_desc++;

			adapter->num_tx_desc_avail--;
			tx_buffer->num_tx_desc_used++;
		}

		/* Put this tx_buffer at the end in the "in use" list */
		STAILQ_INSERT_TAIL(&adapter->used_tx_buffer_list, tx_buffer,
				   em_tx_entry);

		if (ifv != NULL) {
			/* Tell hardware to add tag */
			current_tx_desc->lower.data |= E1000_TXD_CMD_VLE;

			/* Set the vlan id */
			current_tx_desc->upper.fields.special = ifv->ifv_tag;
		}

		/*
		 * Last Descriptor of Packet needs End Of Packet (EOP), Report Status
		 * (RS) and append Ethernet CRC (IFCS) bits set.
		 */
		current_tx_desc->lower.data |= (adapter->txd_cmd | E1000_TXD_CMD_EOP);

d585 2
a586 8
		/*
		 * Advance the Transmit Descriptor Tail (Tdt), this tells the E1000
		 * that this frame is available to transmit.
		 */
		E1000_WRITE_REG(&adapter->hw, TDT,
				(((uintptr_t) adapter->next_avail_tx_desc -
				  (uintptr_t) adapter->first_tx_desc) >> 4));
	} /* end of while loop */
d588 1
a589 4

	/* Set timeout in case chip has problems transmitting */
	ifp->if_timer = EM_TX_TIMEOUT;

a683 110
#ifndef RISCOS
static void
em_set_promisc(struct adapter * adapter)
{

	u_int32_t       reg_rctl;
	struct ifnet   *ifp = &adapter->interface_data.ac_if;

	reg_rctl = E1000_READ_REG(&adapter->hw, RCTL);

	if (ifp->if_flags & IFF_PROMISC) {
		reg_rctl |= (E1000_RCTL_UPE | E1000_RCTL_MPE);
		E1000_WRITE_REG(&adapter->hw, RCTL, reg_rctl);
	} else if (ifp->if_flags & IFF_ALLMULTI) {
		reg_rctl |= E1000_RCTL_MPE;
		reg_rctl &= ~E1000_RCTL_UPE;
		E1000_WRITE_REG(&adapter->hw, RCTL, reg_rctl);
	}

	return;
}
#endif

#ifndef RISCOS
static void
em_disable_promisc(struct adapter * adapter)
{
	u_int32_t       reg_rctl;

	reg_rctl = E1000_READ_REG(&adapter->hw, RCTL);

	reg_rctl &=  (~E1000_RCTL_UPE);
	reg_rctl &=  (~E1000_RCTL_MPE);
	E1000_WRITE_REG(&adapter->hw, RCTL, reg_rctl);

	return;
}
#endif

/*********************************************************************
 *  Multicast Update
 *
 *  This routine is called whenever multicast address list is updated.
 *
 **********************************************************************/

static void
em_set_multi(struct adapter * adapter)
{
	u_int32_t reg_rctl = 0;
	u_int8_t  mta[MAX_NUM_MULTICAST_ADDRESSES * ETH_LENGTH_OF_ADDRESS];
	u_int16_t pci_cmd_word;
#ifndef RISCOS
	struct ifmultiaddr  *ifma;
#endif
	int mcnt = 0;
#ifndef RISCOS
	struct ifnet   *ifp = &adapter->interface_data.ac_if;
#endif

	IOCTL_DEBUGOUT("em_set_multi: begin");

	if (adapter->hw.mac_type == em_82542_rev2_0) {
		reg_rctl = E1000_READ_REG(&adapter->hw, RCTL);
		if (adapter->hw.pci_cmd_word & CMD_MEM_WRT_INVALIDATE) {
			pci_cmd_word = adapter->hw.pci_cmd_word &
				       ~CMD_MEM_WRT_INVALIDATE;
			pci_write_config(adapter->dev, PCIR_COMMAND, pci_cmd_word, 2);
		}
		reg_rctl |= E1000_RCTL_RST;
		E1000_WRITE_REG(&adapter->hw, RCTL, reg_rctl);
		msec_delay(5);
	}

#ifndef RISCOS
#if __FreeBSD_version < 500000
	LIST_FOREACH(ifma, &ifp->if_multiaddrs, ifma_link) {
#else
	TAILQ_FOREACH(ifma, &ifp->if_multiaddrs, ifma_link) {
#endif
		if (ifma->ifma_addr->sa_family != AF_LINK)
			continue;

		bcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),
		      &mta[mcnt*ETH_LENGTH_OF_ADDRESS], ETH_LENGTH_OF_ADDRESS);
		mcnt++;
	}
#endif

	if (mcnt > MAX_NUM_MULTICAST_ADDRESSES) {
		reg_rctl = E1000_READ_REG(&adapter->hw, RCTL);
		reg_rctl |= E1000_RCTL_MPE;
		E1000_WRITE_REG(&adapter->hw, RCTL, reg_rctl);
	} else
		em_mc_addr_list_update(&adapter->hw, mta, mcnt, 0);

	if (adapter->hw.mac_type == em_82542_rev2_0) {
		reg_rctl = E1000_READ_REG(&adapter->hw, RCTL);
		reg_rctl &= ~E1000_RCTL_RST;
		E1000_WRITE_REG(&adapter->hw, RCTL, reg_rctl);
		msec_delay(5);
		if (adapter->hw.pci_cmd_word & CMD_MEM_WRT_INVALIDATE) {
			pci_write_config(adapter->dev, PCIR_COMMAND,
					 adapter->hw.pci_cmd_word, 2);
		}
	}

	return;
}

a696 6
#else
void
em_watchdog(struct adapter * adapter)
{
	struct ifnet *ifp = &adapter->interface_data.ac_if;
#endif
a705 1
#ifndef RISCOS
a706 3
#else
	em_ro_log_message(adapter->dev, "watchdog timeout -- resetting");
#endif
a715 66

/*********************************************************************
 *  Timer routine
 *
 *  This routine checks for link status and updates statistics.
 *
 **********************************************************************/

static void
em_local_timer(void *arg)
{
	int s;
	struct ifnet   *ifp;
	struct adapter * adapter = arg;
	ifp = &adapter->interface_data.ac_if;

	s = splimp();

	em_check_for_link(&adapter->hw);
	em_print_link_status(adapter);
	em_update_stats_counters(adapter);
#ifndef RISCOS
	if (em_display_debug_stats && ifp->if_flags & IFF_RUNNING) {
		em_print_hw_stats(adapter);
	}
	adapter->timer_handle = timeout(em_local_timer, adapter, 2*hz);
#endif

	splx(s);
	return;
}

#ifndef RISCOS
static void
#else
void
#endif
em_print_link_status(struct adapter * adapter)
{
	if (E1000_READ_REG(&adapter->hw, STATUS) & E1000_STATUS_LU) {
		if (adapter->link_active == 0) {
			em_get_speed_and_duplex(&adapter->hw,
						&adapter->link_speed,
						&adapter->link_duplex);
#ifndef RISCOS
			printf("em%d: Link is up %d Mbps %s\n",
			       adapter->unit,
			       adapter->link_speed,
			       ((adapter->link_duplex == FULL_DUPLEX) ?
				"Full Duplex" : "Half Duplex"));
#else
			em_ro_log_message(adapter->dev, "Link is up %d Mbps %s",
			       adapter->link_speed,
			       ((adapter->link_duplex == FULL_DUPLEX) ?
				"Full Duplex" : "Half Duplex"));
#endif
			adapter->link_active = 1;
		}
	} else {
		if (adapter->link_active == 1) {
			adapter->link_speed = 0;
			adapter->link_duplex = 0;
#ifndef RISCOS
			printf("em%d: Link is Down\n", adapter->unit);
#else
			em_ro_log_message(adapter->dev, "Link is Down");
a716 6
			adapter->link_active = 0;
		}
	}

	return;
}
a829 1

d832 1
a832 2
 *  This routine disables all traffic on the adapter by issuing a
 *  global reset on the MAC and deallocates TX/RX buffers.
d838 1
a838 38
em_stop(void *arg)
#else
void em_stop(struct adapter * adapter)
#endif
{
	struct ifnet   *ifp;
#ifndef RISCOS
	struct adapter * adapter = arg;
#endif
	ifp = &adapter->interface_data.ac_if;

	INIT_DEBUGOUT("em_stop: begin\n");
	em_disable_intr(adapter);
	em_reset_hw(&adapter->hw);
#ifndef RISCOS
	untimeout(em_local_timer, adapter, adapter->timer_handle);
#else
	adapter->dev->localtimerset = 0;
#endif
	em_free_transmit_structures(adapter);
	em_free_receive_structures(adapter);


	/* Tell the stack that the interface is no longer active */
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);

	return;
}

/*********************************************************************
 *
 *  Interrupt Service routine
 *
 **********************************************************************/

#ifndef RISCOS
static void
em_intr(void *arg)
d849 1
a856 1
	u_int32_t       reg_ims = E1000_READ_REG(&adapter->hw, IMS);
d862 3
d1075 376
a1450 17
		adapter->hw.autoneg_advertised = 0;
		if ((ifm->ifm_media & IFM_GMASK) == IFM_FDX)
			adapter->hw.forced_speed_duplex = em_100_full;
		else
			adapter->hw.forced_speed_duplex	= em_100_half;
		break;
	case IFM_10_T:
		adapter->hw.autoneg = FALSE;
		adapter->hw.autoneg_advertised = 0;
		if ((ifm->ifm_media & IFM_GMASK) == IFM_FDX)
			adapter->hw.forced_speed_duplex = em_10_full;
		else
			adapter->hw.forced_speed_duplex	= em_10_half;
		break;
	default:
		printf("em%d: Unsupported media type\n", adapter->unit);
	}
d1452 2
a1453 1
	em_init(adapter);
d1455 1
a1455 1
	return(0);
a1456 2
#endif
/* Section end: Other registered entry points */
d1491 7
a1498 30
	/* Set MacType, etc. based on this PCI info */
	switch (adapter->hw.device_id) {
	case E1000_DEV_ID_82542:
		adapter->hw.mac_type = (adapter->hw.revision_id == 3) ?
				       em_82542_rev2_1 : em_82542_rev2_0;
		break;
	case E1000_DEV_ID_82543GC_FIBER:
	case E1000_DEV_ID_82543GC_COPPER:
		adapter->hw.mac_type = em_82543;
		break;
	case E1000_DEV_ID_82544EI_FIBER:
	case E1000_DEV_ID_82544EI_COPPER:
	case E1000_DEV_ID_82544GC_COPPER:
	case E1000_DEV_ID_82544GC_LOM:
		adapter->hw.mac_type = em_82544;
		break;
	case E1000_DEV_ID_82540EM:
		adapter->hw.mac_type = em_82540;
		break;
	case E1000_DEV_ID_82545EM_FIBER:
	case E1000_DEV_ID_82545EM_COPPER:
		adapter->hw.mac_type = em_82545;
		break;
	case E1000_DEV_ID_82546EB_FIBER:
	case E1000_DEV_ID_82546EB_COPPER:
		adapter->hw.mac_type = em_82546;
		break;
	default:
		INIT_DEBUGOUT1("Unknown device id 0x%x", adapter->hw.device_id);
	}
d1556 2
a1557 2
	if (!em_ro_get_pci_io_address(dev, (adapter->io_rid - EM_MMBA) / 4, &adapter->hw.io_base))
		return(ENXIO);
d1784 1
d1786 3
a1821 1
	adapter->oldest_used_tx_desc = adapter->first_tx_desc;
d1924 1
d1926 3
d1968 1
a1968 1
em_transmit_checksum_setup(struct adapter * adapter,
a1969 1
			   struct em_tx_buffer *tx_buffer,
d1975 1
d2009 2
a2011 1

d2033 1
a2033 1
	TXD->cmd_and_length = E1000_TXD_CMD_DEXT;
d2042 3
a2044 1
	tx_buffer->num_tx_desc_used++;
d2049 96
d2243 1
d2245 3
d2389 1
d2391 3
d2443 1
d2681 4
d2705 4
a2708 3
void em_write_pci_cfg(struct em_hw *hw,
		      uint32_t reg,
		      uint16_t *value)
d2714 3
a2716 2
void em_read_pci_cfg(struct em_hw *hw, uint32_t reg,
		     uint16_t *value)
d2723 21
a2743 1
uint32_t em_io_read(struct em_hw *hw, uint32_t port)
d2766 2
a2767 1
void em_io_write(struct em_hw *hw, uint32_t port, uint32_t value)
a2783 1

d2787 1
d2912 2
a2913 1
		if(!em_read_phy_reg(&adapter->hw, M88E1000_RX_ERR_CNTR, &phy_tmp))
d2940 4
a2943 2
	printf("em%d: Tx Descriptors not Avail = %ld\n", unit,
	       adapter->no_tx_desc_avail);
d2952 2
a2995 118

/**********************************************************************
 *
 *  Examine each tx_buffer in the used queue. If the hardware is done
 *  processing the packet then free associated resources. The
 *  tx_buffer is put back on the free queue.
 *
 **********************************************************************/
#ifndef RISCOS
static void
#else
void
#endif
em_clean_transmit_interrupts(struct adapter * adapter)
{
	struct em_tx_buffer *tx_buffer;
	struct em_tx_desc   *tx_desc;
	int             s;
	struct ifnet   *ifp;
#ifdef RISCOS
	uint8_t        *last_dest_addr = NULL;
#endif

	s = splimp();
#ifdef DBG_STATS
	adapter->clean_tx_interrupts++;
#endif

	for (tx_buffer = STAILQ_FIRST(&adapter->used_tx_buffer_list);
	    tx_buffer;
	    tx_buffer = STAILQ_FIRST(&adapter->used_tx_buffer_list)) {

		/*
		 * Get hold of the next descriptor that the em will report status
		 * back to (this will be the last descriptor of a given tx_buffer). We
		 * only want to free the tx_buffer (and it resources) if the driver is
		 * done with ALL of the descriptors.  If the driver is done with the
		 * last one then it is done with all of them.
		 */

#ifndef RISCOS
		tx_desc = adapter->oldest_used_tx_desc +
			  (tx_buffer->num_tx_desc_used - 1);
#else
		tx_desc = adapter->oldest_used_tx_desc;
#endif

		/* Check for wrap case */
		if (tx_desc > adapter->last_tx_desc)
			tx_desc -= adapter->num_tx_desc;


		/*
		 * If the descriptor done bit is set free tx_buffer and associated
		 * resources
		 */
		if (tx_desc->upper.fields.status & E1000_TXD_STAT_DD) {

			STAILQ_REMOVE_HEAD(&adapter->used_tx_buffer_list,
					   em_tx_entry);

			if ((tx_desc == adapter->last_tx_desc))
				adapter->oldest_used_tx_desc =
				adapter->first_tx_desc;
			else
				adapter->oldest_used_tx_desc = (tx_desc + 1);

			/* Make available the descriptors that were previously used */
#ifndef RISCOS
			adapter->num_tx_desc_avail +=
			tx_buffer->num_tx_desc_used;

			tx_buffer->num_tx_desc_used = 0;

			if (tx_buffer->m_head) {
				m_freem(tx_buffer->m_head);
				tx_buffer->m_head = NULL;
			}
#else
			adapter->num_tx_desc_avail += 1;
			last_dest_addr = &tx_buffer->buffer[ETHER_ALIGN];
#endif
			/* Return this "Software packet" back to the "free" list */
			STAILQ_INSERT_TAIL(&adapter->free_tx_buffer_list,
					   tx_buffer, em_tx_entry);
		} else {
			/*
			 * Found a tx_buffer that the em is not done with then there is
			 * no reason to check the rest of the queue.
			 */
			break;
		}
	}		      /* end for each tx_buffer */

	ifp = &adapter->interface_data.ac_if;

#ifndef RISCOS
	/* Tell the stack that it is OK to send packets */
	if (adapter->num_tx_desc_avail > TX_CLEANUP_THRESHOLD) {
		ifp->if_timer = 0;
		ifp->if_flags &= ~IFF_OACTIVE;
	}
#else
	/*
	 * For the RISC OS driver, reset the watchdog timer when all packets
	 * have been sent. This should be correct, shouldn't it?
	 */
	if (adapter->num_tx_desc_avail == adapter->num_tx_desc) {
		ifp->if_timer = 0;
	}

	if (last_dest_addr != NULL)
		memcpy(adapter->dev->stats.st_last_dest_addr, last_dest_addr, ETHER_HDR_LEN);
#endif
	splx(s);
	return;
}

@


1.5
log
@New code drop from James
Adds AutoSense program to integrate with !Configure
Debugging support added to IRQ handlers
Messages tweaked to allow better compression in ROM

Version 0.04. Tagged as 'EtherK-0_04'
@
text
@d112 3
d336 4
d1153 1
a1153 1
#ifdef IRQ_STATS
d1221 1
a1221 1
#ifdef IRQ_STATS
d1249 1
a1249 1
#ifdef IRQ_STATS
@


1.4
log
@New drop from James Byrne
Resources capable of being ROMmed and tokenised
Makefile changes
Fix for declaring the wrong MAC address which confused some switches

Version 0.03. Tagged as 'EtherK-0_03'
@
text
@d1146 7
a1153 1
	u_int32_t       prev_rx_pkts = adapter->rx_pkts;
a1212 2
		u_int32_t rx_pkts_this_time = adapter->rx_pkts - prev_rx_pkts;

d1214 26
d1242 1
a1242 1
		adapter->interrupts++;
d1246 12
a1257 2
			if (rx_pkts_this_time > adapter->max_rxd_used)
				adapter->max_rxd_used = rx_pkts_this_time;
d1259 1
@


1.3
log
@Messages placed in messages file
Improvements to shared interrupt handling
Makefile updated
Tidied logging

Version 0.02. Tagged as 'EtherK-0_02'
@
text
@d1147 1
d1207 2
d1213 6
d2379 1
a2703 3
#else
void
#endif
d2766 1
a2766 1

@


1.2
log
@em_disable_intr fudged to disable ALL interrupts
PreReset attempt

Version 0.01. Tagged as 'EtherK-0_01'
@
text
@d38 3
a40 1
#ifdef RISCOS
d45 1
a50 3
#include "Interface/pci.h"
#else
#include <dev/em/if_em.h>
d197 3
a199 1
#ifdef RISCOS
a200 2
#else
static int
d254 3
a256 1
#ifdef RISCOS
a257 2
#else
static int
d338 1
a338 2
		sprintf(adapter->dev->last_message, "Allocation of PCI resources failed");
		dprintf(("", "%s\n", adapter->dev->last_message));
d355 1
a355 2
		sprintf(adapter->dev->last_message, "Unable to allocate TxDescriptor memory");
		dprintf(("", "%s\n", adapter->dev->last_message));
d372 1
a372 2
		sprintf(adapter->dev->last_message, "Unable to allocate rx_desc memory");
		dprintf(("", "%s\n", adapter->dev->last_message));
d386 1
a386 2
		sprintf(adapter->dev->last_message, "Unable to initialize the hardware");
		dprintf(("", "%s\n", adapter->dev->last_message));
d401 2
a402 2
		sprintf(adapter->dev->last_message, "EEPROM read error while reading mac address");
		dprintf(("", "%s\n", adapter->dev->last_message));
d431 1
a431 1
		sprintf(adapter->dev->last_message, "Speed:%d Mbps  Duplex:%s",
d435 1
a435 2
		sprintf(adapter->dev->last_message, "Speed:N/A  Duplex:N/A");
	dprintf(("", "%s\n", adapter->dev->last_message));
d454 3
a456 1
#ifdef RISCOS
a457 2
#else
static int
d509 1
a509 3
#ifdef RISCOS
int
#else
a510 1
#endif
d517 1
a517 1
#
a547 1
#ifndef RISCOS
a548 1
#endif
a585 1
#ifndef RISCOS
a598 4
#else
		txd_upper = 0;
		txd_lower = 0;
#endif
a623 1
#ifndef RISCOS
a630 1
#endif
a637 1
#ifndef RISCOS
a640 1
#endif
d891 1
a891 2
	sprintf(adapter->dev->last_message, "watchdog timeout -- resetting");
	dprintf(("", "%s\n", adapter->dev->last_message));
d953 1
a953 1
			sprintf(adapter->dev->last_message, "Link is up %d Mbps %s",
a956 1
			dprintf(("", "%s\n", adapter->dev->last_message));
d967 1
a967 2
			sprintf(adapter->dev->last_message, "Link is Down");
			dprintf(("", "%s\n", adapter->dev->last_message));
d1014 1
a1014 2
		sprintf(adapter->dev->last_message, "Unable to initialize the hardware");
		dprintf(("", "%s\n", adapter->dev->last_message));
d1028 1
a1028 2
		sprintf(adapter->dev->last_message, "Could not setup transmit structures");
		dprintf(("", "%s\n", adapter->dev->last_message));
d1049 1
a1049 2
		sprintf(adapter->dev->last_message, "Could not setup receive structures");
		dprintf(("", "%s\n", adapter->dev->last_message));
d1112 3
a1114 1
#ifdef RISCOS
a1115 2
#else
	untimeout(em_local_timer, adapter, adapter->timer_handle);
d1143 2
a1144 2
#ifdef RISCOS
	u_int32_t	ours;
d1146 1
a1146 1
	struct adapter  *adapter = arg;
a1150 3
#ifdef RISCOS
	ours = E1000_READ_REG(&adapter->hw, IMS);
#endif
d1153 1
d1155 2
a1157 1
#ifdef RISCOS
a1159 2
		{
			ours &= reg_icr;
a1160 1
		}
d1165 1
a1165 3
#ifdef RISCOS
			adapter->dev->localtimerset = 0;
#else
d1168 2
d1174 1
a1174 3
#ifdef RISCOS
			adapter->dev->localtimerset = 1;
#else
d1177 2
d1197 15
a1211 4
	if (loop_cnt == EM_MAX_INTR) ours = 0;
	_kernel_irqs_off();
	em_enable_intr(adapter);
	return !ours;
d1363 1
a1363 2
		sprintf(adapter->dev->last_message, "Memory Access and/or Bus Master bits were not set!");
		dprintf(("", "%s\n", adapter->dev->last_message));
d1436 1
a1436 1
	dprintf(("", "em_allocate_pci_resources: hw_addr=&%08X\n", (unsigned) adapter->hw.hw_addr));
d1468 1
a1468 1
		dprintf(("", "em_allocate_pci_resources: io_base=&%08X\n", (unsigned) adapter->hw.io_base));
d1546 1
a1546 2
		sprintf(adapter->dev->last_message, "The EEPROM Checksum Is Not Valid");
		dprintf(("", "%s\n", adapter->dev->last_message));
d1562 1
a1562 2
		sprintf(adapter->dev->last_message, "Hardware Initialization Failed");
		dprintf(("", "%s\n", adapter->dev->last_message));
d1677 1
a1677 2
		sprintf(adapter->dev->last_message, "Unable to allocate tx_buffer memory");
		dprintf(("", "%s\n", adapter->dev->last_message));
d1736 1
a1736 1
	em_ro_flush_wb(adapter->first_tx_desc, (sizeof(struct em_tx_desc)) * adapter->num_tx_desc);
d1795 1
a1795 2
		sprintf(adapter->dev->last_message, "Invalid mac type detected");
		dprintf(("", "%s\n", adapter->dev->last_message));
d2021 1
a2021 2
		sprintf(adapter->dev->last_message, "Unable to allocate rx_buffer memory");
		dprintf(("", "%s\n", adapter->dev->last_message));
d2090 1
a2090 1
	em_ro_flush_wb(adapter->first_rx_desc, (sizeof(struct em_rx_desc)) * adapter->num_rx_desc);
d2267 1
a2267 2
			sprintf(adapter->dev->last_message, "Found null rx_buffer");
			dprintf(("", "%s\n", adapter->dev->last_message));
d2395 1
a2395 1
		em_ro_flush_wb(last_desc_processed, sizeof(struct em_rx_desc));
d2480 1
d2482 9
a2490 1
			(0xffffffff /*& ~E1000_IMC_RXSEQ*/));
d2527 1
a2527 1
		em_ro_copy_error(((struct em_osdep *)hw->back)->dev, e);
d2548 1
a2548 1
		em_ro_copy_error(((struct em_osdep *)hw->back)->dev, e);
d2663 18
d2768 3
a2770 1
#ifdef RISCOS
a2771 2
#else
static void
@


1.1
log
@Initial revision
@
text
@d514 3
a516 1
#ifndef RISCOS
d518 1
d525 1
a525 1
#endif
d1168 3
a1170 1
#ifndef RISCOS
d1176 3
d1186 2
d1189 1
d1226 4
a1229 14
	/* Were any interrupts actually processed? */
	if (loop_cnt == EM_MAX_INTR)
	{
		/* No - pass on */
		em_enable_intr(adapter);
		return 1;
	}
	else
	{
		/* Yes - set interrupt state back to disabled and claim */
		_kernel_irqs_off();
		em_enable_intr(adapter);
		return 0;
	}
d2506 1
a2506 1
			(0xffffffff & ~E1000_IMC_RXSEQ));
@


1.1.1.1
log
@Initial import from James Byrne

@
text
@@

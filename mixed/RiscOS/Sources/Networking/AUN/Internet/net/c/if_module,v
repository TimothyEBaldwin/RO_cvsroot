head	4.11;
access;
symbols
	Internet-5_65:4.11
	Internet-5_64:4.11
	Internet-5_63:4.11
	Internet-5_62:4.11
	Internet-5_61:4.11
	Internet-5_60:4.11
	Internet-5_59:4.11
	Internet-5_58:4.11
	Internet-5_57:4.11
	Internet-5_56:4.11
	Internet-5_55:4.11
	Internet-5_54:4.11
	Internet-5_53:4.11
	Internet-5_52:4.11
	Internet-5_51:4.11
	Internet-5_50:4.11
	RO_5_07:4.10
	Internet-5_49:4.10
	Internet-5_48:4.10
	Internet-5_47:4.10
	Internet-5_46:4.10
	Internet-5_45:4.9
	Internet-5_44:4.9
	Internet-5_43:4.9
	Internet-5_42:4.9
	Internet-5_41:4.9
	Internet-5_40:4.9
	Internet-5_39:4.9
	Internet-5_38:4.9
	Internet-5_37:4.9
	Internet-5_36:4.9
	Internet-5_35:4.9
	Internet-5_34:4.9
	Internet-5_33:4.9
	Internet-5_32:4.8
	Internet-5_31:4.7
	Internet-5_30:4.7
	Internet-5_29:4.6
	Internet-5_27:4.5
	Internet-5_26:4.5
	Internet-5_25:4.5
	Internet-5_24:4.5
	Internet-5_23:4.4
	Internet-5_22:4.4
	Internet-5_21:4.4
	Internet-5_20:4.4
	Internet-5_19:4.4
	Internet-5_18:4.4
	Internet-5_17:4.4
	Internet-5_16:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3
	Ursula_RiscPC:4.3.0.4
	Internet-5_15:4.4
	Internet-5_14:4.4
	Internet-5_13:4.4
	sforrest_daytona_appflash-0_31:4.3
	Internet-5_12:4.4
	Internet-5_11:4.3
	celkins_Internet-5_10:4.3
	nicke_Internat_25-9-98:4.3
	Internet-5_09:4.3
	blaughto_daytona_appflash-0_30:4.3
	rthornb_UrsulaBuild-19Aug1998:4.3
	UrsulaBuild_FinalSoftload:4.3
	rthornb_UrsulaBuild-12Aug1998:4.3
	aglover_UrsulaBuild-05Aug1998:4.3
	rthornb_UrsulaBuild-29Jul1998:4.3
	rthornb_UrsulaBuild-22Jul1998:4.3
	rwarren_Internet-5_08:4.3
	Spinner:4.3
	Internet_5_07:4.3
	rthornb_UrsulaBuild-15Jul1998:4.3
	rthornb_UrsulaBuild-07Jul1998:4.3
	rthornb_UrsulaBuild-17Jun1998:4.3
	rthornb_UrsulaBuild-03Jun1998:4.3
	rthornb_UrsulaBuild-27May1998:4.3
	rthornb_UrsulaBuild-21May1998:4.3
	Ursula_bp:4.3
	Ursula:4.3.0.2
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.3
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.3
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.2
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.11
date	2005.02.18.12.51.24;	author kbracey;	state Exp;
branches;
next	4.10;

4.10
date	2003.11.13.18.02.11;	author bavison;	state Exp;
branches;
next	4.9;

4.9
date	99.07.22.08.37.23;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	99.07.21.10.47.18;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	99.07.08.16.36.53;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.07.08.15.25.30;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.06.23.11.58.04;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	98.10.22.14.26.16;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	98.03.27.12.36.35;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.58.33;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.05;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.05;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.19.48;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.27.21;	author nturton;	state Exp;
branches;
next	4.1.3.2;

4.1.3.2
date	96.11.08.17.23.16;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.06.30;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.07;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.06.24;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.21;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.38.07;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.12;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.11
log
@Fixed some dodgy unaligned pointer casting which invokes undefined behaviour;
the old code no longer has the expected behaviour with cc 5.58, so older
versions of the module don't work unless compiled with cc 5.57 or earlier.

Version 5.50. Tagged as 'Internet-5_50'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
 *
 * support external device driver module.
 *
 */
#include "kernel.h"
#include "swis.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>

#ifndef __riscos
#include <machine/cpu.h>
#endif

#include <net/if.h>
#include <net/netisr.h>
#include <net/route.h>
#include <net/if_llc.h>
#include <net/if_dl.h>
#include <net/if_types.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#endif
#include <netinet/if_ether.h>

#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

#ifdef ISO
#include <netiso/argo_debug.h>
#include <netiso/iso.h>
#include <netiso/iso_var.h>
#include <netiso/iso_snpac.h>
#endif

#ifdef LLC
#include <netccitt/dll.h>
#include <netccitt/llc_var.h>
#endif

#if defined(LLC) && defined(CCITT)
extern struct ifqueue pkintrq;
#endif

#include <sys/dcistructs.h>
#include "module.h"
#include "svcdebug.h"
#include "debug.h"

u_char	etherbroadcastaddr[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
#define senderr(e) { error = (e); goto bad;}

static int if_module_addmulti(struct ifreq *ifr, struct ifnet *ifp);
static int if_module_delmulti(struct ifreq *ifr, struct ifnet *ifp);

/**********************************************************************/

int
if_module_output(ifp, m0, dst, rt0)
    register struct ifnet *ifp;
    struct mbuf *m0;
    struct sockaddr *dst;
    struct rtentry *rt0;
{
	int swinum = ifp->if_swibase + DCI4Transmit;
	_kernel_oserror *e;
	int type, off;
	u_char edst[6];
	struct mbuf *m = m0;
	register struct rtentry *rt;
	struct mbuf *mcopy = (struct mbuf *)0;
	register struct ether_header *eh;
	int error = 0;
	struct arpcom *ac = (struct arpcom *)ifp;
#ifdef FLASHY_SCROLLLOCK
	static struct timeval lastflash;
	struct timeval flashdiff;
#endif

#ifdef DEBUG
	    if( DODEBUG((1 << 16)) )
	    {
		int i = 0;
		struct mbuf *m1;

                Printf("if_module_output(ifp=%x,m0=%x,dst=%x,rt0=%x) dst->sa_family=%d, len=%d\n", ifp, m0, dst, rt0, dst->sa_family, m->m_pkthdr.len);
		Printf("\021\003if_module_output Packet Dump:\n");

		for( m1 = m0; m1; m1 = m1->m_next )
		{
		    int j;
		    u_char *cptr = mtod(m1, u_char *);

		    for( j = 0; j < m1->m_len; ++j )
		    {
			Printf("%02x", *cptr++);

			if( !(++i % 32) )
			    Printf("\n");
			else if( !(i % 4) )
			    Printf("  ");
		    }
		}

		if( (i % 32) )
		    Printf("\021\007\n");
	    Printf("\021\07\n");
	    }
#endif
	/*
	 * check that driver is still present.  this is quite probably
	 * paranoia, as there should be no way to get to this routine
	 * if the driver module has been killed, but it is better to
	 * be safe than sorry
	 */
	if (ifp->if_flags & IFF_NODRIVER)
		senderr(ENXIO);

	if ((ifp->if_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING))
		senderr(ENETDOWN);

	ifp->if_lastchange = time;
	if (rt = rt0) {
		if ((rt->rt_flags & RTF_UP) == 0) {
			if (rt0 = rt = rtalloc1(dst, 1, 0UL))
				rt->rt_refcnt--;
			else
				senderr(EHOSTUNREACH);
		}
		if (rt->rt_flags & RTF_GATEWAY) {
			if (rt->rt_gwroute == 0)
				goto lookup;
			if (((rt = rt->rt_gwroute)->rt_flags & RTF_UP) == 0) {
				rtfree(rt); rt = rt0;
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1,
							  0UL);
				if ((rt = rt->rt_gwroute) == 0)
					senderr(EHOSTUNREACH);
			}
		}
		if (rt->rt_flags & RTF_REJECT)
			if (rt->rt_rmx.rmx_expire == 0 ||
			    time.tv_sec < rt->rt_rmx.rmx_expire)
				senderr(rt == rt0 ? EHOSTDOWN : EHOSTUNREACH);
	}

	switch (dst->sa_family) {

#ifdef INET
	case AF_INET:
		if (!arpresolve(ac, rt, m, dst, edst, rt0)) {
#ifdef DEBUG
	    		if( DODEBUG(DBGOUTPUT) )
				Printf("imo: waiting for ARP resolution\n");
#endif
			return (0);	/* if not yet resolved */
	        }
		/* If broadcasting on a simplex interface, loopback a copy */
		/* Note - can't be a list - won't fragment broadcasts */
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
			mcopy = m_copy(m, 0, (int)M_COPYALL);
		off = m->m_pkthdr.len - m->m_len;
		type = ETHERTYPE_IP;
		break;

/*	if( usetrailers && off > 0 && (off & 0x1ff) == 0 &&
	   m->m_off >= MINOFF(m) + 2 * sizeof(u_short) )
	{
	    type = ETHERTYPE_TRAIL + (off >> 9);
	    m->m_off -= 2 * sizeof(u_short);
	    m->m_len += 2 * sizeof(u_short);
	    *mtod(m, u_short *) = htons((u_short)ETHERTYPE_IP);
	    *(mtod(m, u_short *) + 1) = htons((u_short)m->m_len);
	    goto gottrailertype;
	}

	type = ETHERTYPE_IP;
	off = 0;
	destp = edst;
	goto gottype;*/
#endif
#ifdef NS
	case AF_NS:
		type = ETHERTYPE_NS;
 		bcopy((caddr_t)&(((struct sockaddr_ns *)dst)->sns_addr.x_host),
		    (caddr_t)edst, sizeof (edst));
		if (!bcmp((caddr_t)edst, (caddr_t)&ns_thishost, sizeof(edst)))
			return (looutput(ifp, m, dst, rt));
		/* If broadcasting on a simplex interface, loopback a copy */
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
			mcopy = m_copy(m, 0, (int)M_COPYALL);
		break;
#endif
#ifdef	ISO
	case AF_ISO: {
		int	snpalen;
		struct	llc *l;
		register struct sockaddr_dl *sdl;

		if (rt && (sdl = (struct sockaddr_dl *)rt->rt_gateway) &&
		    sdl->sdl_family == AF_LINK && sdl->sdl_alen > 0) {
			bcopy(LLADDR(sdl), (caddr_t)edst, sizeof(edst));
		} else if (error =
			    iso_snparesolve(ifp, (struct sockaddr_iso *)dst,
					    (char *)edst, &snpalen))
			goto bad; /* Not Resolved */
		/* If broadcasting on a simplex interface, loopback a copy */
		if (*edst & 1)
			m->m_flags |= (M_BCAST|M_MCAST);
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX) &&
		    (mcopy = m_copy(m, 0, (int)M_COPYALL))) {
#error This won't work on RISC OS - sizeof (*eh) is 16
			M_PREPEND(mcopy, sizeof (*eh), M_DONTWAIT);
			if (mcopy) {
				eh = mtod(mcopy, struct ether_header *);
				bcopy((caddr_t)edst,
				      (caddr_t)eh->ether_dhost, sizeof (edst));
				bcopy((caddr_t)ac->ac_enaddr,
				      (caddr_t)eh->ether_shost, sizeof (edst));
			}
		}
		M_PREPEND(m, 3, M_DONTWAIT);
		if (m == NULL)
			return (0);
		type = m->m_pkthdr.len;
		l = mtod(m, struct llc *);
		l->llc_dsap = l->llc_ssap = LLC_ISO_LSAP;
		l->llc_control = LLC_UI;
		len += 3;
		IFDEBUG(D_ETHER)
			int i;
			printf("unoutput: sending pkt to: ");
			for (i=0; i<6; i++)
				printf("%x ", edst[i] & 0xff);
			printf("\n");
		ENDDEBUG
		} break;
#endif /* ISO */
#ifdef	LLC
/*	case AF_NSAP: */
	case AF_CCITT: {
		register struct sockaddr_dl *sdl =
			(struct sockaddr_dl *) rt -> rt_gateway;

		if (sdl && sdl->sdl_family == AF_LINK
		    && sdl->sdl_alen > 0) {
			bcopy(LLADDR(sdl), (char *)edst,
				sizeof(edst));
		} else goto bad; /* Not a link interface ? Funny ... */
		if ((ifp->if_flags & IFF_SIMPLEX) && (*edst & 1) &&
		    (mcopy = m_copy(m, 0, (int)M_COPYALL))) {
#error This won't work on RISC OS - sizeof (*eh) is 16
			M_PREPEND(mcopy, sizeof (*eh), M_DONTWAIT);
			if (mcopy) {
				eh = mtod(mcopy, struct ether_header *);
				bcopy((caddr_t)edst,
				      (caddr_t)eh->ether_dhost, sizeof (edst));
				bcopy((caddr_t)ac->ac_enaddr,
				      (caddr_t)eh->ether_shost, sizeof (edst));
			}
		}
		type = m->m_pkthdr.len;
#ifdef LLC_DEBUG
		{
			int i;
			register struct llc *l = mtod(m, struct llc *);

			printf("ether_output: sending LLC2 pkt to: ");
			for (i=0; i<6; i++)
				printf("%x ", edst[i] & 0xff);
			printf(" len 0x%x dsap 0x%x ssap 0x%x control 0x%x\n",
			       type & 0xff, l->llc_dsap & 0xff, l->llc_ssap &0xff,
			       l->llc_control & 0xff);

		}
#endif /* LLC_DEBUG */
		} break;
#endif /* LLC */

	case AF_UNSPEC:
#if 0 /* This code invokes undefined behaviour - dst->sa_data is not aligned */
		eh = (struct ether_header *)dst->sa_data;
		(void)memcpy(edst, eh->ether_dhost, sizeof (edst));
		type = eh->ether_type;
#else
                (void)memcpy(edst, dst->sa_data, ETHER_ADDR_LEN);
                type = *(u_short *)(dst->sa_data+2*ETHER_ADDR_LEN);
#endif
		break;

	default:
#ifdef DEBUG
		Printf("%s%d: can't handle af%d\n", ifp->if_name, ifp->if_unit,
			dst->sa_family);
#endif
		senderr(EAFNOSUPPORT);
	}


	if (mcopy) {
#ifdef DEBUG
                Printf("Copying via loopback: mcopy=%x\n", mcopy);
#endif
		(void) looutput(ifp, mcopy, dst, rt);
	}

#ifdef NotYet
  gottrailertype:
    /*
     * Packet to be sent as trailer: move first packet
     * (control information) to end of chain.
     */
    while (m->m_next)
	m = m->m_next;

    m->m_next = m0;
    m = m0->m_next;
    m0->m_next = 0;
    m0 = m;

  gottype:
#endif
#ifdef DEBUG
    if( DODEBUG(DBGOUTPUT) )
    {
	switch( type )
	{
	  case ETHERTYPE_IP:
	    Printf("imo: IP output to %s on i/f %s%d\n",
		   ether_sprintf(edst), ifp->if_name, ifp->if_unit);
	    break;

	  default:
	    Printf("imo: %x output to %s on i/f %s%d\n",
		   type, ether_sprintf(edst), ifp->if_name, ifp->if_unit);
	    break;
	}
    }
#endif

    {
        struct mbuf *m1;

        for (m1=m; m1; m1=m1->m_nextpkt) {
            /* TRACE */
            #ifdef DEBUG
            if (DODEBUG(DBGOUTPUT))
            {
        	struct mbuf *m2;

        	Printf("\021\003TXF (type %x): ", type);
        	for( m2 = m1; m2; m2 = m2->m_next )
        	    Printf("%x(%d, %d)-->", m2, m2->m_type, m2->m_len);
        	Printf("(NULL)\021\007\n");
            }
            #endif
            ifp->if_opackets++;
            ifp->if_obytes+=m1->m_pkthdr.len;
            if (m1->m_flags & (M_BCAST|M_MCAST))
                ifp->if_omcasts++;
        }
    }

#ifdef FLASHY_SCROLLLOCK
    flashdiff = ifp->if_lastchange;
    timevalsub(&flashdiff, &lastflash);
    if (flashdiff.tv_sec != 0)
        flashdiff.tv_usec = 1024*1024;

    if (flashdiff.tv_usec > 49152) /* If last flashed > ~1/20 second ago */
    {
        lastflash = ifp->if_lastchange;
    	_swix(OS_Byte, _INR(0,2), 202, 2, 255);  /* Toggle scrolllock state */
    	_swix(OS_Byte, _IN(0),    118);          /* Reflect status in LEDs  */
    	_swix(OS_Byte, _INR(0,2), 202, 2, 255);  /* Toggle scrolllock state */
    }
#endif

    /*
     * set parameters for Transmit - use default MAC address,
     * and the driver assumes ownership of the data
     *
     * XXX
     *
     * the only possible error the driver can return is
     * lack of output buffers, return an appropriate error
     */
    #if 1
    if( (e = _swix(swinum, _INR(0,4), TX_OWNSOURCE | TX_DRIVERSDATA,
                                      ifp->if_unit, type, m, edst)) != NULL ) {
	error = ENOBUFS;
	ifp->if_oerrors++;
    }
    #else
    {
        struct mbuf *aaa, *next = m;
        while (next)
        {
            aaa = next->m_list;
            m_freem(next);
            next = aaa;
        }

        error = ENOBUFS;
        ifp->if_oerrors++;
    }
    #endif

#ifdef FLASHY_SCROLLLOCK
    if (flashdiff.tv_usec > 49152)
    	_swix(OS_Byte, _IN(0), 118); /* Reflect status in LEDs */
#endif

#ifdef DEBUG
    if (DODEBUG(DBGOUTPUT))
        Printf("imo: done output, error=%d\n", error);
#endif
    return(error);

bad:
    /*
     * under DCI 4, m0 may be the head of a list of mbuf
     * chains, make sure each chain is correctly freed.
     */
    while (m0)
    {
	m = m0;
	m0 = m0->m_list;

	m_freem(m);
    }

    return (error);
}

/**********************************************************************/

int if_module_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
    _kernel_swi_regs r;
    _kernel_oserror *e = NULL;
    struct ifaddr *ifa = (struct ifaddr *)data;
    struct ifreq *ifr = (struct ifreq *)data;
    int error = 0;
    int s = splimp();

    r.r[0] = ifp->if_unit;

    switch (cmd)
    {
      case SIOCSIFADDR:
#ifdef DEBUG
        if (DODEBUG(DBGOUTPUT))
            Printf("if_module_ioctl(SIOCSIFADDR)\n");
#endif
	/*
	 * as well as setting the interface address, this
	 * call should also start the interface running
	 * if necessary.  we do not directly tell the driver
	 * to start running, but do this indirectly by
	 * claiming the required frame types.
	 */
	if( (ifp->if_flags & (IFF_UP | IFF_RUNNING)) !=
	   (IFF_UP | IFF_RUNNING) )
	{
	    if( (e = claim_frames(ifp, 1)) == NULL )
		ifp->if_flags |= (IFF_UP | IFF_RUNNING);
	}

        arp_ifinit((struct arpcom *)ifp, ifa);

	break;

#ifdef MULTICAST
      case SIOCADDMULTI:
	error = if_module_addmulti(ifr, ifp);
	break;
      case SIOCDELMULTI:
	error = if_module_delmulti(ifr, ifp);
	break;
#endif

	case SIOCSIFFLAGS:
	/*
	 * flags have already been set by higher levels,
	 * see whether interface is now supposed to be
	 * up or down
	 */
	if( (ifp->if_flags & IFF_UP) && !(ifp->if_flags & IFF_RUNNING) )
	{
	    /*
	     * try and bring the interface up
	     */
	    if( (e = claim_frames(ifp, 1)) != NULL )
		/*
		 * we failed
		 */
		ifp->if_flags &= ~(IFF_UP | IFF_RUNNING);
	    else
		ifp->if_flags |= IFF_RUNNING;
	}
	else if( !(ifp->if_flags & IFF_UP) && (ifp->if_flags & IFF_RUNNING) )
	{
	    /*
	     * take the interface down
	     */
	    e = claim_frames(ifp, 0);
	    ifp->if_flags &= ~(IFF_RUNNING);
	}

	break;

	case SIOCSIFMTU:
		e = _swix(ifp->if_swibase + DCI4SetNetworkMTU, _INR(0,2),
                          0, ifp->if_unit, ifr->ifr_metric);
                if (e == NULL)
			ifp->if_mtu=ifr->ifr_metric;
		break;

      default:
	break;
    }

    splx(s);

    if (error)
        return (error);

    /*
     * 950227 KWelton
     *
     * as an earlier comment suggested, we really
     * should return an error here.
     */
    if( e )
    {
	errtunnel = *e;
	return(ETUNNEL);
    }
    else
    {
	errtunnel.errnum = 0;
	errtunnel.errmess[0] = '\0';
	return(0);
    }
}

/**********************************************************************/

/*
 * if_module_null - do nothing, and return no error
 * (equivalent to nulldev() in BSD Unix).
 */
int if_module_null(struct ifnet *ifp, u_long cmd, caddr_t data)
{
    return(0);
}

/**********************************************************************/

/*
 * if_module_none - do nothing, and return ENXIO
 * (equivalent to nodev() in BSD Unix).
 */
int if_module_none(struct ifnet *ifp, struct mbuf *m0, struct sockaddr *dst, struct rtentry *rt)
{
    struct mbuf *m;

    /*
     * under DCI 4, m0 may be the head of a list of mbuf
     * chains, make sure each chain is correctly freed.
     */
    while (m0)
    {
        m = m0;
        m0 = m0->m_list;

        m_freem(m);
    }

    return(ENXIO);
}

/**********************************************************************/


/*
 * Convert Ethernet address to printable (loggable) representation.
 */
static char digits[] = "0123456789abcdef";
char *
ether_sprintf(ap)
	register const u_char *ap;
{
	register int i;
	static char etherbuf[18];
	register char *cp = etherbuf;

	for (i = 0; i < 6; i++) {
		*cp++ = digits[*ap >> 4];
		*cp++ = digits[*ap++ & 0xf];
		*cp++ = ':';
	}
	*--cp = 0;
	return (etherbuf);
}

#define ifp_to_dib(ifp) ((struct dib *)(ifp->if_dib))

#ifdef MULTICAST
static int if_module_addmulti(struct ifreq *ifr, struct ifnet *ifp)
{
    u_long addr;
    struct if_multi *ifm;
    struct sockaddr_in *sin;

    if (ifr->ifr_addr.sa_family != AF_INET)
        return EAFNOSUPPORT;

    sin = (struct sockaddr_in *)&ifr->ifr_addr;
    addr = sin->sin_addr.s_addr;

    if (!IN_MULTICAST(ntohl(addr)) && addr != INADDR_ANY)
        return EINVAL;

    for (ifm = ifp->if_multiaddrs; ifm; ifm = ifm->ifm_next)
    {
        /* We know all addrs in the list are AF_INET */
        if (((struct sockaddr_in *)&ifm->ifm_addr)->sin_addr.s_addr == addr)
        {
            ++ifm->ifm_refcount;
            return 0;
        }
    }

    /* New address - allocate it and link it in */
    ifm = (struct if_multi *) malloc(sizeof(*ifm), M_IFMADDR, M_NOWAIT);
    if (ifm == NULL)
        return ENOBUFS;

    ifm->ifm_next = ifp->if_multiaddrs;
    ifm->ifm_refcount = 1;
    ifm->ifm_addr = ifr->ifr_addr;
    ifp->if_multiaddrs = ifm;

    /* Need to do all the above to maintain the list even if we don't have a
     * DCI driver that can do anything with it, because the darned fool user
     * may later load a newer version of that driver with filtering!
     * So we only check at this point...
     */

    if (ifp_to_dib(ifp)->dib_inquire & INQ_FILTERMCAST)
    {
        _kernel_oserror *e;
        int flags = MULTICAST_ADDR_REQ;
        u_int typenlevel = ETHERTYPE_IP;
        u_char hwaddr[6];

        if (addr == INADDR_ANY)
            flags |= MULTICAST_ALL_ADDR;
        else
            ETHER_MAP_IP_MULTICAST(&sin->sin_addr, hwaddr);

        SET_FRAMELEVEL(typenlevel, FRMLVL_E2SPECIFIC);
        e = dci4_mc_request(ifp_to_dib(ifp), flags, typenlevel, hwaddr, &sin->sin_addr);
        if (e)
        {
            errtunnel = *e;
            return ETUNNEL;
        }
    }

    return 0;
}

static int if_module_delmulti(struct ifreq *ifr, struct ifnet *ifp)
{
    u_long addr;
    struct if_multi *ifm, **p;
    struct sockaddr_in *sin;

    if (ifr->ifr_addr.sa_family != AF_INET)
        return EAFNOSUPPORT;

    sin = (struct sockaddr_in *)&ifr->ifr_addr;
    addr = sin->sin_addr.s_addr;

    for (ifm = ifp->if_multiaddrs; ifm; ifm = ifm->ifm_next)
    {
        /* We know all addrs in the list are AF_INET */
        if (((struct sockaddr_in *)&ifm->ifm_addr)->sin_addr.s_addr == addr)
           break;
    }

    if (ifm == NULL)
        return ENXIO;

    if (--ifm->ifm_refcount != 0)
        return 0; /* Still some claims to this record */

    /* Unlink this record */
    for (p = &ifp->if_multiaddrs; *p != ifm; p = &(*p)->ifm_next)
        continue;

    *p = (*p)->ifm_next;
    free(ifm, M_IFMADDR);

    if (ifp_to_dib(ifp)->dib_inquire & INQ_FILTERMCAST)
    {
        _kernel_oserror *e;
        int flags = MULTICAST_ADDR_REL;
        u_int typenlevel = ETHERTYPE_IP;
        u_char hwaddr[6];

        if (addr == INADDR_ANY)
            flags |= MULTICAST_ALL_ADDR;
        else
            ETHER_MAP_IP_MULTICAST(&sin->sin_addr, hwaddr);

        SET_FRAMELEVEL(typenlevel, FRMLVL_E2SPECIFIC);
        e = dci4_mc_request(ifp_to_dib(ifp), flags, typenlevel, hwaddr, &sin->sin_addr);
        if (!e && addr == INADDR_ANY)
        {
            /* We've just released our "all addresses" claim. DCI requires us to reclaim
             * all our individual claims.
             */
             e = if_module_reclaimmulti(ifp);
        }

        if (e)
        {
            errtunnel = *e;
            return ETUNNEL;
        }
    }

    return 0;
}

_kernel_oserror *if_module_reclaimmulti(struct ifnet *ifp)
{
    _kernel_oserror *e;
    struct sockaddr_in *sin;
    u_long addr;
    struct if_multi *ifm;
    u_char hwaddr[6];
    u_int typenlevel = ETHERTYPE_IP;

    SET_FRAMELEVEL(typenlevel, FRMLVL_E2SPECIFIC);

    for (ifm = ifp->if_multiaddrs; ifm; ifm = ifm->ifm_next)
    {
        int flags = MULTICAST_ADDR_REQ;

        /* Again, we know all addresses are AF_INET */
        sin = (struct sockaddr_in *)&ifm->ifm_addr;
        addr = sin->sin_addr.s_addr;

        if (addr == INADDR_ANY)
            flags |= MULTICAST_ALL_ADDR;
        else
            ETHER_MAP_IP_MULTICAST(&sin->sin_addr, hwaddr);

        e = dci4_mc_request(ifp_to_dib(ifp), flags, typenlevel, hwaddr, &sin->sin_addr);
        if (e) return e;
    }

    return NULL;
}
#endif
@


4.10
log
@Commit of two years' worth of changes.
Upped version number, because it's about time it was.

Version 5.46. Tagged as 'Internet-5_46'
@
text
@d241 1
d281 1
d310 1
d314 4
@


4.9
log
@* Used to send fragmented multicasts to the wrong link-level address. This
  is fixed by MbufManager 0.23, but a work-around has been incorporated
  into the Internet module.
* Ability to debug using PDebug instead of TML added.
* Various compilation hiccoughs when DEBUG defined fixed.

Version 5.33. Tagged as 'Internet-5_33'
@
text
@d617 1
a617 1
	register i;
@


4.8
log
@* Removed some unused routines in the sysctl code.
* Now keeps track of interface multicast claims, even if the DCI driver is
  not capable of multicast filtering. This is necessary in case the user
  loads a multicast filtering capable driver later.
* Small tweak to ip_output(): multicast packets with specified interfaces
  don't need a route. This was spotted when we saw a machine failing to send
  IGMP reports because it had no default route set up.

Version 5.32. Tagged as 'Internet-5_32'
@
text
@a362 12
    /* TRACE */
#ifdef DEBUG
    if (DODEBUG(DBGOUTPUT))
    {
	struct mbuf *m1;

	Printf("\021\003TXF (type %x): ", type);
	for( m1 = m0; m1; m1 = m1->m_next )
	    Printf("%x(%d, %d)-->", m1, m1->m_type, m1->m_len);
	Printf("(NULL)\021\007\n");
    }
#endif
d367 12
@


4.7
log
@The horrible ac_ipaddr member of struct arpcom exorcised once and for all.

Version 5.30. Tagged as 'Internet-5_30'
@
text
@a635 2
    int flags = MULTICAST_ADDR_REQ;
    u_char hwaddr[6];
a637 5
    _kernel_oserror *e;
    u_int typenlevel = ETHERTYPE_IP;

    if (!(ifp_to_dib(ifp)->dib_inquire & INQ_FILTERMCAST))
    	return 0;
d668 7
a674 8
    if (addr == INADDR_ANY)
        flags |= MULTICAST_ALL_ADDR;
    else
        ETHER_MAP_IP_MULTICAST(&sin->sin_addr, hwaddr);

    SET_FRAMELEVEL(typenlevel, FRMLVL_E2SPECIFIC);
    e = dci4_mc_request(ifp_to_dib(ifp), flags, typenlevel, hwaddr, &sin->sin_addr);
    if (e)
d676 17
a692 2
        errtunnel = *e;
        return ETUNNEL;
a700 2
    int flags = MULTICAST_ADDR_REL;
    u_char hwaddr[6];
a702 5
    _kernel_oserror *e;
    u_int typenlevel = ETHERTYPE_IP;

    if (!(ifp_to_dib(ifp)->dib_inquire & INQ_FILTERMCAST))
    	return 0;
d730 1
a730 8
    if (addr == INADDR_ANY)
        flags |= MULTICAST_ALL_ADDR;
    else
        ETHER_MAP_IP_MULTICAST(&sin->sin_addr, hwaddr);

    SET_FRAMELEVEL(typenlevel, FRMLVL_E2SPECIFIC);
    e = dci4_mc_request(ifp_to_dib(ifp), flags, typenlevel, hwaddr, &sin->sin_addr);
    if (!e && addr == INADDR_ANY)
d732 19
a750 5
        /* We've just released our "all addresses" claim. DCI requires us to reclaim
         * all our individual claims.
         */
         e = if_module_reclaimmulti(ifp);
    }
d752 5
a756 4
    if (e)
    {
        errtunnel = *e;
        return ETUNNEL;
@


4.6
log
@* Dynamic ports now assigned in range 49152-65535.
* IP_RECVDSTADDR works for non-unicast packets.
* SO_TIMESTAMP added.
* IP_RECVIF added.
* Various other internal changes merged in from FreeBSD sources.

Version 5.29. Tagged as 'Internet-5_29'
@
text
@a491 4
#ifdef BSD43Code
	((struct arpcom *)ifp)->ac_ipaddr = IA_SIN(ifa)->sin_addr;
	arpwhohas((struct arpcom *)ifp, &IA_SIN(ifa)->sin_addr);
#else
a492 1
#endif
@


4.5
log
@Modified to keep track of multicast claims on interfaces. It will no longer
lose multicast claims if a replacement driver module is loaded, or if an
interface is configured down.
Now passes correct frame type to MulticastRequest (used to pass a zero frame
level).
No longer asks for multicast ARP or Reverse ARP packets.

Version 5.24. Tagged as 'Internet-5_24'
@
text
@d460 1
a460 1
int if_module_ioctl(struct ifnet *ifp, int cmd, char *data)
d581 1
a581 1
int if_module_null(struct ifnet *ifp, int cmd, caddr_t data)
d620 1
a620 1
	register u_char *ap;
@


4.4
log
@  Added multicast filtering support to Internet module
  More boot variables recognised in BOOTP/DHCP responses.
Detail:
  net/if_module.c:
    Interprets multicast ioctl requests and construct SWI parameters
    for passing to riscos/module.c for a call to MulticastRequest SWI.
  riscos/module.c:
    Wrapper for calling above SWI.  Sets appropriate flag bit on
    DCI4 Filter SWI to indicate our support for multicast filtering
    when Inquire SWI indicated that the driver supports it too.
  build/module.h:
    Prototype for dci4_mc_request() wrapper added.
  whoami/whoami.c:
    More variables are now known to the response handler.
    Multiple IP address options are handled (useful for Inet$Resolvers)
    Interoperability workaround for Microsoft DHCP servers added.
Admin:
  Requires RiscOS/Sources/Lib/TCPIPLibs version 5.02 or later.
    (tag: TCPIPLibs-5_02 or later)
  Supporting documentation: DCI4 Functional Specification
    (Drawing number 0284,036/FS; ECO 4112)
  BOOTP client tested against Microsoft DHCP server and standard server.
  Multicast filtering tested against new EtherH driver from I-cubed.
  Multicast filtering tested against old EtherM driver to verify the
    changes do not break older non-DCI 4.04 compliant drivers.

Version 5.12. Tagged as 'Internet-5_12'
@
text
@d82 3
d466 1
d502 6
a507 27
#define ifp_to_dib(ifp) ((struct dib *)(ifp->if_dib))
        case SIOCADDMULTI:
        case SIOCDELMULTI:

/*	if (!(ifp_to_dib(ifp)->dib_inquire & INQ_FILTERMCAST)) {
	        printf("Driver %s did not set INQ_FILTERMCAST (%08x)\n", ifp_to_dib(ifp)->dib_name,
	        	ifp_to_dib(ifp)->dib_inquire);
	}*/

	if (ifp_to_dib(ifp)->dib_inquire & INQ_FILTERMCAST) {
	        struct sockaddr_in *sin = (struct sockaddr_in *)&ifr->ifr_addr;
	        int flags = (cmd == SIOCDELMULTI ? MULTICAST_ADDR_REL : MULTICAST_ADDR_REQ);
	        u_char ipmulticast_mac[6];

	        if (sin->sin_addr.s_addr == INADDR_ANY) {
	                flags |= MULTICAST_ALL_ADDR;
	        }
	        else {
	                flags |= MULTICAST_SPECIFIC_ADDR;
	                ETHER_MAP_IP_MULTICAST(&sin->sin_addr, ipmulticast_mac);
	        }
		e = dci4_mc_request(ifp_to_dib(ifp), flags, ETHERTYPE_IP, ipmulticast_mac,
			(void *)&sin->sin_addr);
		if (e != NULL) printf(">> SWI error: %s\n", e->errmess);
	}
        break;
#undef ifp_to_dib
d553 3
d634 156
@


4.3
log
@Missed some changes in the last checkin
@
text
@d497 31
a527 1
      case SIOCSIFFLAGS:
@


4.2
log
@Version Spinner_B7 taken
@
text
@d185 1
d407 1
d413 14
@


4.1
log
@Initial revision
@
text
@d15 1
a15 5
/* -*-C-*-
 *
 * $Header: /ax/networking:Internet/net/if_module.c:networking  1.5  $
 * $Source: /ax/networking:Internet/net/if_module.c: $
 *
a19 18
 * $Log:	if_module.c,v $
 * Revision 1.5  95/03/31  11:51:52  kwelton
 * Added some more debug messages.
 * 
 * Revision 1.4  95/02/28  19:00:01  kwelton
 * if_module_ioctl() now "tunnels" error messages back to its caller.
 * 
 * Revision 1.3  95/01/03  14:11:20  kwelton
 * The name of the Transmit SWI has been changed to DCI4Transmit.
 * 
 * Revision 1.2  94/12/19  10:52:53  kwelton
 * if_module_ioctl() checks IFF_RUNNING within the case for SIOCSIFFLAGS
 * to prevent claim_frames being called twice (once implicitly from
 * SIFADDR, as well as an explicit call to SIFFLAGS).
 * 
 * Revision 1.1  94/12/02  10:59:23  kwelton
 * Initial revision
 * 
d24 49
a72 21
#include "sys/param.h"
#include "sys/systm.h"
#include "sys/socket.h"
#include "sys/socketvar.h"
#include "sys/protosw.h"
#include "sys/errno.h"
#include "sys/dir.h"
#include "sys/ioctl.h"
#include "sys/user.h"
#include "sys/mbuf.h"
#include "sys/dcistructs.h"

#include "net/if.h"
#include "net/af.h"
#include "net/netisr.h"

#include "netinet/in.h"
#include "netinet/in_systm.h"
#include "netinet/in_var.h"
#include "netinet/ip.h"
#include "netinet/if_ether.h"
d74 1
d79 3
d84 6
a89 1
int if_module_output(struct ifnet *ifp, struct mbuf *m0, struct sockaddr *dst)
d91 56
a146 9
    int swinum = XOS_Bit | (ifp->if_swibase + DCI4Transmit);
    _kernel_swi_regs r;
    _kernel_oserror *e;
    int type, off, usetrailers;
    char edst[6], *destp;
    struct in_addr idst;
    struct mbuf *m = m0;
    struct ether_header *eh;
    int error = 0;
d148 24
a171 11
    /*
     * check that driver is still present.  this is quite probably
     * paranoia, as there should be no way to get to this routine
     * if the driver module has been killed, but it is better to
     * be safe than sorry
     */
    if( ifp->if_flags & IFF_NODRIVER )
    {
	error = ENXIO;
	goto fail;
    }
d173 1
a173 5
    if ((ifp->if_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING))
    {
	error = ENETDOWN;
	goto fail;
    }
d175 3
a177 6
    switch (dst->sa_family)
    {
      case AF_INET:
	idst = ((struct sockaddr_in *)dst)->sin_addr;
	if (!arpresolve(ifp, m, &idst, edst, &usetrailers))
	{
d179 2
a180 2
	    if( DODEBUG(DBGOUTPUT) )
		Printf("imo: waiting for ARP resolution\n");
d182 8
a189 4
	    return (0);				/* if not yet resolved */
	}

	off = ntohs((u_short)mtod(m, struct ip *)->ip_len) - m->m_len;
d191 1
a191 1
	if( usetrailers && off > 0 && (off & 0x1ff) == 0 &&
d205 111
a315 1
	goto gottype;
a316 6
      case AF_UNSPEC:
	eh = (struct ether_header *)dst->sa_data;
	memcpy ((caddr_t)edst, (caddr_t)eh->ether_dhost, sizeof (edst));
	destp = edst;
	type = eh->ether_type;
	goto gottype;
d318 6
a323 4
      default:
	error = EAFNOSUPPORT;
	goto fail;
    }
d325 1
d340 1
d360 2
a361 1
    if( 0 )
d370 26
d400 1
a400 8
     */
    r.r[0] = TX_OWNSOURCE | TX_DRIVERSDATA;
    r.r[1] = ifp->if_unit;
    r.r[2] = (int)type;
    r.r[3] = (int)m0;
    r.r[4] = (int)destp;

    /*
d406 2
a407 1
    if( (e = _kernel_swi(swinum, &r, &r)) != NULL )
d409 7
d417 4
d423 1
a423 1
  fail:
d428 1
a428 1
    while( m0 )
a432 1
#ifdef OldCode
a433 3
#else
	FREEM(m);
#endif
d446 1
d454 4
d472 1
d475 3
d511 7
d549 1
a549 1
int if_module_null(void)
d560 1
a560 1
int if_module_none(void)
a561 8
    return(ENXIO);
}

/**********************************************************************/

int if_callb(void)
{
    struct ifnet *ifp;
a562 3
    u_int type;
    int s, srcsupplied;
    u_char ethersrc[6];
d565 2
a566 1
     * loop, dequeueing all received packets
d568 1
a568 1
    for(;;)
d570 2
a571 3
	s = splhi();
	IF_DEQUEUE(&ipintrq, m);
	splx(s);
d573 2
a574 2
	if( m == 0 )
	    return(1);
d576 2
a577 8
	ifp = *(mtod(m, struct ifnet **));
	if( ifp == (struct ifnet *)0xffffffff || ifp == 0 )
	{
#ifdef OldCode
	    m_freem(m);
#else
	    FREEM(m);
#endif
d579 1
a579 6
#ifdef OldCode
	    goto next;
#else
	    continue;
#endif
	}
a580 5
#ifdef DEBUG
	if( DODEBUG(DBGINPUT) )
	    Printf("if_callb: mbuf chain %x from i/f %s%d\n",
		   m, ifp->if_name, ifp->if_unit);
#endif
d582 16
a597 43
	if (ifp->if_flags & IFF_SRCSUPPLIED)
	{
	    srcsupplied = 1;
	    memcpy(ethersrc, mtod(m, char *) + 4, 6);
	}
	else
	    srcsupplied = 0;

	/*
	 * XXX
	 *
	 * this is singularly unpleasant!
	 */
	type = (u_short)m->m_len;
	m->m_len = sizeof(ifp);

	switch (type)
	{
	  case ETHERTYPE_IP:
	    IF_ADJ(m);
	    if( m )
		ipintr(ifp, m, srcsupplied ? ethersrc : (u_char *)0);
#ifdef DEBUG
	    else if( DODEBUG(DBGINPUT) )
		Printf("if_callb: chain IF_ADJ'ed to NULL!\n");
#endif
	    break;

	  case ETHERTYPE_ARP:
	    arpinput((struct arpcom *)ifp, m);
	    break;

	  case ETHERTYPE_REVARP:
	    revarpinput((struct arpcom *)ifp, m);
	    break;

	  default:
#ifdef OldCode
	    m_freem(m);
#else
	    FREEM(m);
#endif
	    break;
d599 2
a600 4
    }
#ifdef OldCode
    goto next;
#endif
a601 4

/**********************************************************************/

/* EOF if_module.c */
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d15 5
a19 1
/*
d24 18
d46 21
a66 49
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>

#ifndef __riscos
#include <machine/cpu.h>
#endif

#include <net/if.h>
#include <net/netisr.h>
#include <net/route.h>
#include <net/if_llc.h>
#include <net/if_dl.h>
#include <net/if_types.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#endif
#include <netinet/if_ether.h>

#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

#ifdef ISO
#include <netiso/argo_debug.h>
#include <netiso/iso.h>
#include <netiso/iso_var.h>
#include <netiso/iso_snpac.h>
#endif

#ifdef LLC
#include <netccitt/dll.h>
#include <netccitt/llc_var.h>
#endif

#if defined(LLC) && defined(CCITT)
extern struct ifqueue pkintrq;
#endif
a67 1
#include <sys/dcistructs.h>
a71 3
u_char	etherbroadcastaddr[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
#define senderr(e) { error = (e); goto bad;}

d74 1
a74 6
int
if_module_output(ifp, m0, dst, rt0)
    register struct ifnet *ifp;
    struct mbuf *m0;
    struct sockaddr *dst;
    struct rtentry *rt0;
d76 27
a102 14
	int swinum = ifp->if_swibase + DCI4Transmit;
	_kernel_oserror *e;
	int type, off;
	u_char edst[6];
	struct mbuf *m = m0;
	register struct rtentry *rt;
	struct mbuf *mcopy = (struct mbuf *)0;
	register struct ether_header *eh;
	int error = 0;
	struct arpcom *ac = (struct arpcom *)ifp;
#ifdef FLASHY_SCROLLLOCK
	static struct timeval lastflash;
	struct timeval flashdiff;
#endif
d104 6
d111 2
a112 28
	    if( DODEBUG((1 << 16)) )
	    {
		int i = 0;
		struct mbuf *m1;

                Printf("if_module_output(ifp=%x,m0=%x,dst=%x,rt0=%x) dst->sa_family=%d, len=%d\n", ifp, m0, dst, rt0, dst->sa_family, m->m_pkthdr.len);
		Printf("\021\003if_module_output Packet Dump:\n");

		for( m1 = m0; m1; m1 = m1->m_next )
		{
		    int j;
		    u_char *cptr = mtod(m1, u_char *);

		    for( j = 0; j < m1->m_len; ++j )
		    {
			Printf("%02x", *cptr++);

			if( !(++i % 32) )
			    Printf("\n");
			else if( !(i % 4) )
			    Printf("  ");
		    }
		}

		if( (i % 32) )
		    Printf("\021\007\n");
	    Printf("\021\07\n");
	    }
d114 1
a114 35
	/*
	 * check that driver is still present.  this is quite probably
	 * paranoia, as there should be no way to get to this routine
	 * if the driver module has been killed, but it is better to
	 * be safe than sorry
	 */
	if (ifp->if_flags & IFF_NODRIVER)
		senderr(ENXIO);

	if ((ifp->if_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING))
		senderr(ENETDOWN);

	ifp->if_lastchange = time;
	if (rt = rt0) {
		if ((rt->rt_flags & RTF_UP) == 0) {
			if (rt0 = rt = rtalloc1(dst, 1, 0UL))
				rt->rt_refcnt--;
			else
				senderr(EHOSTUNREACH);
		}
		if (rt->rt_flags & RTF_GATEWAY) {
			if (rt->rt_gwroute == 0)
				goto lookup;
			if (((rt = rt->rt_gwroute)->rt_flags & RTF_UP) == 0) {
				rtfree(rt); rt = rt0;
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1,
							  0UL);
				if ((rt = rt->rt_gwroute) == 0)
					senderr(EHOSTUNREACH);
			}
		}
		if (rt->rt_flags & RTF_REJECT)
			if (rt->rt_rmx.rmx_expire == 0 ||
			    time.tv_sec < rt->rt_rmx.rmx_expire)
				senderr(rt == rt0 ? EHOSTDOWN : EHOSTUNREACH);
d117 1
a117 17
	switch (dst->sa_family) {

#ifdef INET
	case AF_INET:
		if (!arpresolve(ac, rt, m, dst, edst, rt0)) {
#ifdef DEBUG
	    		if( DODEBUG(DBGOUTPUT) )
				Printf("imo: waiting for ARP resolution\n");
#endif
			return (0);	/* if not yet resolved */
	        }
		/* If broadcasting on a simplex interface, loopback a copy */
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
			mcopy = m_copy(m, 0, (int)M_COPYALL);
		off = m->m_pkthdr.len - m->m_len;
		type = ETHERTYPE_IP;
		break;
d119 1
a119 1
/*	if( usetrailers && off > 0 && (off & 0x1ff) == 0 &&
d133 1
a133 103
	goto gottype;*/
#endif
#ifdef NS
	case AF_NS:
		type = ETHERTYPE_NS;
 		bcopy((caddr_t)&(((struct sockaddr_ns *)dst)->sns_addr.x_host),
		    (caddr_t)edst, sizeof (edst));
		if (!bcmp((caddr_t)edst, (caddr_t)&ns_thishost, sizeof(edst)))
			return (looutput(ifp, m, dst, rt));
		/* If broadcasting on a simplex interface, loopback a copy */
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
			mcopy = m_copy(m, 0, (int)M_COPYALL);
		break;
#endif
#ifdef	ISO
	case AF_ISO: {
		int	snpalen;
		struct	llc *l;
		register struct sockaddr_dl *sdl;

		if (rt && (sdl = (struct sockaddr_dl *)rt->rt_gateway) &&
		    sdl->sdl_family == AF_LINK && sdl->sdl_alen > 0) {
			bcopy(LLADDR(sdl), (caddr_t)edst, sizeof(edst));
		} else if (error =
			    iso_snparesolve(ifp, (struct sockaddr_iso *)dst,
					    (char *)edst, &snpalen))
			goto bad; /* Not Resolved */
		/* If broadcasting on a simplex interface, loopback a copy */
		if (*edst & 1)
			m->m_flags |= (M_BCAST|M_MCAST);
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX) &&
		    (mcopy = m_copy(m, 0, (int)M_COPYALL))) {
			M_PREPEND(mcopy, sizeof (*eh), M_DONTWAIT);
			if (mcopy) {
				eh = mtod(mcopy, struct ether_header *);
				bcopy((caddr_t)edst,
				      (caddr_t)eh->ether_dhost, sizeof (edst));
				bcopy((caddr_t)ac->ac_enaddr,
				      (caddr_t)eh->ether_shost, sizeof (edst));
			}
		}
		M_PREPEND(m, 3, M_DONTWAIT);
		if (m == NULL)
			return (0);
		type = m->m_pkthdr.len;
		l = mtod(m, struct llc *);
		l->llc_dsap = l->llc_ssap = LLC_ISO_LSAP;
		l->llc_control = LLC_UI;
		len += 3;
		IFDEBUG(D_ETHER)
			int i;
			printf("unoutput: sending pkt to: ");
			for (i=0; i<6; i++)
				printf("%x ", edst[i] & 0xff);
			printf("\n");
		ENDDEBUG
		} break;
#endif /* ISO */
#ifdef	LLC
/*	case AF_NSAP: */
	case AF_CCITT: {
		register struct sockaddr_dl *sdl =
			(struct sockaddr_dl *) rt -> rt_gateway;

		if (sdl && sdl->sdl_family == AF_LINK
		    && sdl->sdl_alen > 0) {
			bcopy(LLADDR(sdl), (char *)edst,
				sizeof(edst));
		} else goto bad; /* Not a link interface ? Funny ... */
		if ((ifp->if_flags & IFF_SIMPLEX) && (*edst & 1) &&
		    (mcopy = m_copy(m, 0, (int)M_COPYALL))) {
			M_PREPEND(mcopy, sizeof (*eh), M_DONTWAIT);
			if (mcopy) {
				eh = mtod(mcopy, struct ether_header *);
				bcopy((caddr_t)edst,
				      (caddr_t)eh->ether_dhost, sizeof (edst));
				bcopy((caddr_t)ac->ac_enaddr,
				      (caddr_t)eh->ether_shost, sizeof (edst));
			}
		}
		type = m->m_pkthdr.len;
#ifdef LLC_DEBUG
		{
			int i;
			register struct llc *l = mtod(m, struct llc *);

			printf("ether_output: sending LLC2 pkt to: ");
			for (i=0; i<6; i++)
				printf("%x ", edst[i] & 0xff);
			printf(" len 0x%x dsap 0x%x ssap 0x%x control 0x%x\n",
			       type & 0xff, l->llc_dsap & 0xff, l->llc_ssap &0xff,
			       l->llc_control & 0xff);

		}
#endif /* LLC_DEBUG */
		} break;
#endif /* LLC */

	case AF_UNSPEC:
		eh = (struct ether_header *)dst->sa_data;
		(void)memcpy(edst, eh->ether_dhost, sizeof (edst));
		type = eh->ether_type;
		break;
d135 6
a140 7
	default:
#ifdef DEBUG
		Printf("%s%d: can't handle af%d\n", ifp->if_name, ifp->if_unit,
			dst->sa_family);
#endif
		senderr(EAFNOSUPPORT);
	}
d142 4
a146 8
	if (mcopy) {
#ifdef DEBUG
                Printf("Copying via loopback: mcopy=%x\n", mcopy);
#endif
		(void) looutput(ifp, mcopy, dst, rt);
	}

#ifdef NotYet
a160 1
#endif
d180 1
a180 2
#ifdef DEBUG
    if (DODEBUG(DBGOUTPUT))
a188 26
#endif
    {
        struct mbuf *m1;

        for (m1=m; m1; m1=m1->m_nextpkt) {
            ifp->if_opackets++;
            ifp->if_obytes+=m1->m_pkthdr.len;
            if (m1->m_flags & (M_BCAST|M_MCAST))
                ifp->if_omcasts++;
        }
    }

#ifdef FLASHY_SCROLLLOCK
    flashdiff = ifp->if_lastchange;
    timevalsub(&flashdiff, &lastflash);
    if (flashdiff.tv_sec != 0)
        flashdiff.tv_usec = 1024*1024;

    if (flashdiff.tv_usec > 49152) /* If last flashed > ~1/20 second ago */
    {
        lastflash = ifp->if_lastchange;
    	_swix(OS_Byte, _INR(0,2), 202, 2, 255);  /* Toggle scrolllock state */
    	_swix(OS_Byte, _IN(0),    118);          /* Reflect status in LEDs  */
    	_swix(OS_Byte, _INR(0,2), 202, 2, 255);  /* Toggle scrolllock state */
    }
#endif
d193 8
a200 1
     *
d206 1
a206 2
    if( (e = _swix(swinum, _INR(0,4), TX_OWNSOURCE | TX_DRIVERSDATA,
                                      ifp->if_unit, type, m, edst)) != NULL ) {
a207 7
	ifp->if_oerrors++;
    }

#ifdef FLASHY_SCROLLLOCK
    if (flashdiff.tv_usec > 49152)
    	_swix(OS_Byte, _IN(0), 118); /* Reflect status in LEDs */
#endif
a208 4
#ifdef DEBUG
    if (DODEBUG(DBGOUTPUT))
        Printf("imo: done output, error=%d\n", error);
#endif
d211 1
a211 1
bad:
d216 1
a216 1
    while (m0)
d221 1
d223 3
a237 1
    struct ifreq *ifr = (struct ifreq *)data;
a244 4
#ifdef DEBUG
        if (DODEBUG(DBGOUTPUT))
            Printf("if_module_ioctl(SIOCSIFADDR)\n");
#endif
a258 1
#ifdef BSD43Code
a260 3
#else
        arp_ifinit((struct arpcom *)ifp, ifa);
#endif
a293 7
	case SIOCSIFMTU:
		e = _swix(ifp->if_swibase + DCI4SetNetworkMTU, _INR(0,2),
                          0, ifp->if_unit, ifr->ifr_metric);
                if (e == NULL)
			ifp->if_mtu=ifr->ifr_metric;
		break;

d325 1
a325 1
int if_module_null(struct ifnet *ifp, int cmd, caddr_t data)
d336 1
a336 1
int if_module_none(struct ifnet *ifp, struct mbuf *m0, struct sockaddr *dst, struct rtentry *rt)
d338 8
d347 3
d352 1
a352 2
     * under DCI 4, m0 may be the head of a list of mbuf
     * chains, make sure each chain is correctly freed.
d354 1
a354 1
    while (m0)
d356 6
a361 2
        m = m0;
        m0 = m0->m_list;
d363 37
a399 2
        m_freem(m);
    }
d401 11
a411 2
    return(ENXIO);
}
d413 3
a415 1
/**********************************************************************/
d417 3
d421 7
a427 16
/*
 * Convert Ethernet address to printable (loggable) representation.
 */
static char digits[] = "0123456789abcdef";
char *
ether_sprintf(ap)
	register u_char *ap;
{
	register i;
	static char etherbuf[18];
	register char *cp = etherbuf;

	for (i = 0; i < 6; i++) {
		*cp++ = digits[*ap >> 4];
		*cp++ = digits[*ap++ & 0xf];
		*cp++ = ':';
d429 4
a432 2
	*--cp = 0;
	return (etherbuf);
d434 4
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d17 1
a17 1
 * $Header: /ax/networking:Internet/net/if_module.c:networking  1.6  $
a24 3
 * Revision 1.6  95/10/11  11:43:14  pwain
 * Added support for sioctl to set MTU of a device for PPP driver.
 * 
a433 27

/* 210995 PWain
 * Added call to set MTU on device.
 */

int if_set_mtu(ifp, ifr)
	struct ifnet *ifp;
	struct ifreq *ifr;
{
_kernel_swi_regs r;
_kernel_oserror *e;
struct dib *d=ifp->if_dib;

    r.r[0]=0;
    r.r[1]=(int) d->dib_unit;
    r.r[2]=(int) ifr->ifr_metric;

    e=_kernel_swi(d->dib_swibase + DCI4SetNetworkMTU, &r, &r);

    if (e == NULL) {
      ifp->if_mtu=ifr->ifr_metric;
      return 0;
      }

   return ENOTTY;
}
      
@


4.1.7.2
log
@RCS log keyword removed
@
text
@d24 1
a24 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@d17 1
a17 1
 * $Header: /ax/networking:Internet/net/if_module.c:networking  1.6  $
a24 3
 * Revision 1.6  95/10/11  11:43:14  pwain
 * Added support for sioctl to set MTU of a device for PPP driver.
 * 
a433 27

/* 210995 PWain
 * Added call to set MTU on device.
 */

int if_set_mtu(ifp, ifr)
	struct ifnet *ifp;
	struct ifreq *ifr;
{
_kernel_swi_regs r;
_kernel_oserror *e;
struct dib *d=ifp->if_dib;

    r.r[0]=0;
    r.r[1]=(int) d->dib_unit;
    r.r[2]=(int) ifr->ifr_metric;

    e=_kernel_swi(d->dib_swibase + DCI4SetNetworkMTU, &r, &r);

    if (e == NULL) {
      ifp->if_mtu=ifr->ifr_metric;
      return 0;
      }

   return ENOTTY;
}
      
@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d24 1
a24 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d17 1
a17 1
 * $Header: /ax/networking:Internet/net/if_module.c:networking  1.6  $
a24 3
 * Revision 1.6  95/10/11  11:43:14  pwain
 * Added support for sioctl to set MTU of a device for PPP driver.
 *
d27 1
a27 1
 *
d30 1
a30 1
 *
d33 1
a33 1
 *
d38 1
a38 1
 *
d41 1
a41 1
 *
d46 21
a66 14
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>

#ifndef __riscos
#include <machine/cpu.h>
#endif
a67 36
#include <net/if.h>
#include <net/netisr.h>
#include <net/route.h>
#include <net/if_llc.h>
#include <net/if_dl.h>
#include <net/if_types.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#endif
#include <netinet/if_ether.h>

#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

#ifdef ISO
#include <netiso/argo_debug.h>
#include <netiso/iso.h>
#include <netiso/iso_var.h>
#include <netiso/iso_snpac.h>
#endif

#ifdef LLC
#include <netccitt/dll.h>
#include <netccitt/llc_var.h>
#endif

#if defined(LLC) && defined(CCITT)
extern struct ifqueue pkintrq;
#endif

#include <sys/dcistructs.h>
a71 3
u_char	etherbroadcastaddr[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
#define senderr(e) { error = (e); goto bad;}

d74 1
a74 6
int
if_module_output(ifp, m0, dst, rt0)
    register struct ifnet *ifp;
    struct mbuf *m0;
    struct sockaddr *dst;
    struct rtentry *rt0;
d76 21
a96 10
	int swinum = ifp->if_swibase + DCI4Transmit;
	_kernel_oserror *e;
	int type, off;
	u_char edst[6];
	struct mbuf *m = m0;
	register struct rtentry *rt;
	struct mbuf *mcopy = (struct mbuf *)0;
	register struct ether_header *eh;
	int error = 0;
	struct arpcom *ac = (struct arpcom *)ifp;
d98 12
d111 2
a112 28
	    if( DODEBUG((1 << 16)) )
	    {
		int i = 0;
		struct mbuf *m1;

                Printf("if_module_output(ifp=%x,m0=%x,dst=%x,rt0=%x) dst->sa_family=%d, len=%d\n", ifp, m0, dst, rt0, dst->sa_family, m->m_pkthdr.len);
		Printf("\021\003if_module_output Packet Dump:\n");

		for( m1 = m0; m1; m1 = m1->m_next )
		{
		    int j;
		    u_char *cptr = mtod(m1, u_char *);

		    for( j = 0; j < m1->m_len; ++j )
		    {
			Printf("%02x", *cptr++);

			if( !(++i % 32) )
			    Printf("\n");
			else if( !(i % 4) )
			    Printf("  ");
		    }
		}

		if( (i % 32) )
		    Printf("\021\007\n");
	    Printf("\021\07\n");
	    }
d114 1
a114 35
	/*
	 * check that driver is still present.  this is quite probably
	 * paranoia, as there should be no way to get to this routine
	 * if the driver module has been killed, but it is better to
	 * be safe than sorry
	 */
	if (ifp->if_flags & IFF_NODRIVER)
		senderr(ENXIO);

	if ((ifp->if_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING))
		senderr(ENETDOWN);

	ifp->if_lastchange = time;
	if (rt = rt0) {
		if ((rt->rt_flags & RTF_UP) == 0) {
			if (rt0 = rt = rtalloc1(dst, 1, 0UL))
				rt->rt_refcnt--;
			else
				senderr(EHOSTUNREACH);
		}
		if (rt->rt_flags & RTF_GATEWAY) {
			if (rt->rt_gwroute == 0)
				goto lookup;
			if (((rt = rt->rt_gwroute)->rt_flags & RTF_UP) == 0) {
				rtfree(rt); rt = rt0;
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1,
							  0UL);
				if ((rt = rt->rt_gwroute) == 0)
					senderr(EHOSTUNREACH);
			}
		}
		if (rt->rt_flags & RTF_REJECT)
			if (rt->rt_rmx.rmx_expire == 0 ||
			    time.tv_sec < rt->rt_rmx.rmx_expire)
				senderr(rt == rt0 ? EHOSTDOWN : EHOSTUNREACH);
d117 1
a117 17
	switch (dst->sa_family) {

#ifdef INET
	case AF_INET:
		if (!arpresolve(ac, rt, m, dst, edst, rt0)) {
#ifdef DEBUG
	    		if( DODEBUG(DBGOUTPUT) )
				Printf("imo: waiting for ARP resolution\n");
#endif
			return (0);	/* if not yet resolved */
	        }
		/* If broadcasting on a simplex interface, loopback a copy */
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
			mcopy = m_copy(m, 0, (int)M_COPYALL);
		off = m->m_pkthdr.len - m->m_len;
		type = ETHERTYPE_IP;
		break;
d119 1
a119 1
/*	if( usetrailers && off > 0 && (off & 0x1ff) == 0 &&
d133 1
a133 103
	goto gottype;*/
#endif
#ifdef NS
	case AF_NS:
		type = ETHERTYPE_NS;
 		bcopy((caddr_t)&(((struct sockaddr_ns *)dst)->sns_addr.x_host),
		    (caddr_t)edst, sizeof (edst));
		if (!bcmp((caddr_t)edst, (caddr_t)&ns_thishost, sizeof(edst)))
			return (looutput(ifp, m, dst, rt));
		/* If broadcasting on a simplex interface, loopback a copy */
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
			mcopy = m_copy(m, 0, (int)M_COPYALL);
		break;
#endif
#ifdef	ISO
	case AF_ISO: {
		int	snpalen;
		struct	llc *l;
		register struct sockaddr_dl *sdl;

		if (rt && (sdl = (struct sockaddr_dl *)rt->rt_gateway) &&
		    sdl->sdl_family == AF_LINK && sdl->sdl_alen > 0) {
			bcopy(LLADDR(sdl), (caddr_t)edst, sizeof(edst));
		} else if (error =
			    iso_snparesolve(ifp, (struct sockaddr_iso *)dst,
					    (char *)edst, &snpalen))
			goto bad; /* Not Resolved */
		/* If broadcasting on a simplex interface, loopback a copy */
		if (*edst & 1)
			m->m_flags |= (M_BCAST|M_MCAST);
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX) &&
		    (mcopy = m_copy(m, 0, (int)M_COPYALL))) {
			M_PREPEND(mcopy, sizeof (*eh), M_DONTWAIT);
			if (mcopy) {
				eh = mtod(mcopy, struct ether_header *);
				bcopy((caddr_t)edst,
				      (caddr_t)eh->ether_dhost, sizeof (edst));
				bcopy((caddr_t)ac->ac_enaddr,
				      (caddr_t)eh->ether_shost, sizeof (edst));
			}
		}
		M_PREPEND(m, 3, M_DONTWAIT);
		if (m == NULL)
			return (0);
		type = m->m_pkthdr.len;
		l = mtod(m, struct llc *);
		l->llc_dsap = l->llc_ssap = LLC_ISO_LSAP;
		l->llc_control = LLC_UI;
		len += 3;
		IFDEBUG(D_ETHER)
			int i;
			printf("unoutput: sending pkt to: ");
			for (i=0; i<6; i++)
				printf("%x ", edst[i] & 0xff);
			printf("\n");
		ENDDEBUG
		} break;
#endif /* ISO */
#ifdef	LLC
/*	case AF_NSAP: */
	case AF_CCITT: {
		register struct sockaddr_dl *sdl =
			(struct sockaddr_dl *) rt -> rt_gateway;

		if (sdl && sdl->sdl_family == AF_LINK
		    && sdl->sdl_alen > 0) {
			bcopy(LLADDR(sdl), (char *)edst,
				sizeof(edst));
		} else goto bad; /* Not a link interface ? Funny ... */
		if ((ifp->if_flags & IFF_SIMPLEX) && (*edst & 1) &&
		    (mcopy = m_copy(m, 0, (int)M_COPYALL))) {
			M_PREPEND(mcopy, sizeof (*eh), M_DONTWAIT);
			if (mcopy) {
				eh = mtod(mcopy, struct ether_header *);
				bcopy((caddr_t)edst,
				      (caddr_t)eh->ether_dhost, sizeof (edst));
				bcopy((caddr_t)ac->ac_enaddr,
				      (caddr_t)eh->ether_shost, sizeof (edst));
			}
		}
		type = m->m_pkthdr.len;
#ifdef LLC_DEBUG
		{
			int i;
			register struct llc *l = mtod(m, struct llc *);

			printf("ether_output: sending LLC2 pkt to: ");
			for (i=0; i<6; i++)
				printf("%x ", edst[i] & 0xff);
			printf(" len 0x%x dsap 0x%x ssap 0x%x control 0x%x\n",
			       type & 0xff, l->llc_dsap & 0xff, l->llc_ssap &0xff,
			       l->llc_control & 0xff);

		}
#endif /* LLC_DEBUG */
		} break;
#endif /* LLC */

	case AF_UNSPEC:
		eh = (struct ether_header *)dst->sa_data;
		(void)memcpy(edst, eh->ether_dhost, sizeof (edst));
		type = eh->ether_type;
		break;
d135 6
a140 7
	default:
#ifdef DEBUG
		Printf("%s%d: can't handle af%d\n", ifp->if_name, ifp->if_unit,
			dst->sa_family);
#endif
		senderr(EAFNOSUPPORT);
	}
d142 4
a146 8
	if (mcopy) {
#ifdef DEBUG
                Printf("Copying via loopback: mcopy=%x\n", mcopy);
#endif
		(void) looutput(ifp, mcopy, dst, rt);
	}

#ifdef NotYet
a160 1
#endif
d180 1
a180 2
#ifdef DEBUG
    if (DODEBUG(DBGOUTPUT))
a188 3
#endif
    {
        struct mbuf *m1;
a189 7
        for (m1=m; m1; m1=m1->m_nextpkt) {
            ifp->if_opackets++;
            ifp->if_obytes+=m1->m_pkthdr.len;
            if (m1->m_flags & (M_BCAST|M_MCAST))
                ifp->if_omcasts++;
        }
    }
d193 8
a200 1
     *
d206 1
a206 2
    if( (e = _swix(swinum, _INR(0,4), TX_OWNSOURCE | TX_DRIVERSDATA,
                                      ifp->if_unit, type, m, edst)) != NULL ) {
a207 2
	ifp->if_oerrors++;
    }
a208 4
#ifdef DEBUG
    if (DODEBUG(DBGOUTPUT))
        Printf("imo: done output, error=%d\n", error);
#endif
d211 1
a211 1
bad:
d216 1
a216 1
    while (m0)
d221 1
d223 3
a237 1
    struct ifreq *ifr = (struct ifreq *)data;
a244 4
#ifdef DEBUG
        if (DODEBUG(DBGOUTPUT))
            Printf("if_module_ioctl(SIOCSIFADDR)\n");
#endif
a258 1
#ifdef BSD43Code
a260 3
#else
        arp_ifinit((struct arpcom *)ifp, ifa);
#endif
a293 7
	case SIOCSIFMTU:
		e = _swix(ifp->if_swibase + DCI4SetNetworkMTU, _INR(0,2),
                          0, ifp->if_unit, ifr->ifr_metric);
                if (e == NULL)
			ifp->if_mtu=ifr->ifr_metric;
		break;

d343 77
d421 7
a427 16
/*
 * Convert Ethernet address to printable (loggable) representation.
 */
static char digits[] = "0123456789abcdef";
char *
ether_sprintf(ap)
	register u_char *ap;
{
	register i;
	static char etherbuf[18];
	register char *cp = etherbuf;

	for (i = 0; i < 6; i++) {
		*cp++ = digits[*ap >> 4];
		*cp++ = digits[*ap++ & 0xf];
		*cp++ = ':';
d429 4
a432 2
	*--cp = 0;
	return (etherbuf);
d434 4
@


4.1.3.2
log
@RCS Log keyword removed
@
text
@d24 1
a24 1
 * :RCS Log discontinued:
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d24 1
a24 1
 * :RCS Log discontinued:
@

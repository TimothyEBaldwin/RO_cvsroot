head	4.7;
access;
symbols
	Internet-5_65:4.7
	Internet-5_64:4.7
	Internet-5_63:4.7
	Internet-5_62:4.7
	Internet-5_61:4.7
	Internet-5_60:4.7
	Internet-5_59:4.7
	Internet-5_58:4.7
	Internet-5_57:4.7
	Internet-5_56:4.6
	Internet-5_55:4.6
	Internet-5_54:4.6
	Internet-5_53:4.6
	Internet-5_52:4.6
	Internet-5_51:4.6
	Internet-5_50:4.6
	RO_5_07:4.6
	Internet-5_49:4.6
	Internet-5_48:4.6
	Internet-5_47:4.6
	Internet-5_46:4.6
	Internet-5_45:4.6
	Internet-5_44:4.6
	Internet-5_43:4.6
	Internet-5_42:4.6
	Internet-5_41:4.6
	Internet-5_40:4.6
	Internet-5_39:4.6
	Internet-5_38:4.6
	Internet-5_37:4.6
	Internet-5_36:4.6
	Internet-5_35:4.6
	Internet-5_34:4.6
	Internet-5_33:4.6
	Internet-5_32:4.6
	Internet-5_31:4.6
	Internet-5_30:4.5
	Internet-5_29:4.5
	Internet-5_27:4.4
	Internet-5_26:4.4
	Internet-5_25:4.3
	Internet-5_24:4.3
	Internet-5_23:4.3
	Internet-5_22:4.3
	Internet-5_21:4.3
	Internet-5_20:4.3
	Internet-5_19:4.2
	Internet-5_18:4.2
	Internet-5_17:4.2
	Internet-5_16:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Internet-5_15:4.2
	Internet-5_14:4.2
	Internet-5_13:4.2
	sforrest_daytona_appflash-0_31:4.2
	Internet-5_12:4.2
	Internet-5_11:4.2
	celkins_Internet-5_10:4.2
	nicke_Internat_25-9-98:4.2
	Internet-5_09:4.2
	blaughto_daytona_appflash-0_30:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rwarren_Internet-5_08:4.2
	Spinner:4.2
	Internet_5_07:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.2
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.7
date	2012.08.26.19.53.20;	author jlee;	state Exp;
branches;
next	4.6;
commitid	WbuxJGoZAqKXR5iw;

4.6
date	99.07.13.11.12.42;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.07.08.15.25.28;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.06.23.16.09.37;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	99.03.25.14.45.32;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.58.30;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.05;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.05;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.19.44;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.27.11;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.06.28;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.05;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.06.18;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.18;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.38.03;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.11;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.7
log
@Fix routes not being cleaned up properly when an interface changes its address
Detail:
  This is the Internet-side part of the fix, incorporating the following changes from FreeBSD:
  net/c/route - http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/net/route.c.diff?r1=1.59.2.1;r2=1.59.2.2;f=h
  netinet/c/in - http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/netinet/in.c.diff?r1=1.44.2.2;r2=1.44.2.3;f=h
  netinet/c/in_rmx - http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/netinet/in_rmx.c.diff?r1=1.37;r2=1.37.2.1;f=h
  netinet/c/raw_ip - http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/netinet/raw_ip.c.diff?r1=1.64.2.4;r2=1.64.2.5;f=h
  net/c/if - http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/net/if.c.diff?r1=1.43;r2=1.44;f=h
  This provides us with the fix for this bug:
  http://www.freebsd.org/cgi/query-pr.cgi?pr=20785
  Other required changes:
  netiniet/c/in_proto - Hooked up rip_ctlinput to appropriate handlers
  Also fixed build/Makefile to count the module as a dependency for rom_link phase
Admin:
  Tested on Raspberry Pi
  Requires TCPIPLibs-5_56
  Fixes issue reported on forums with ShareFS not always working:
  http://www.riscosopen.org/forum/forums/5/topics/1193


Version 5.57. Tagged as 'Internet-5_57'
@
text
@/*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include "kernel.h"

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/protosw.h>
#include <sys/kernel.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/radix.h>
#include <ether.h>

#ifdef __riscos
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <sys/queue.h>
#include <net/route.h>
#include <protocols/dhcp.h>
#include "whoami.h"
#include "module.h"
#include "debug.h"
#include "swiveneers.h"
#endif


static int ifconf(u_long, caddr_t);
static void if_qflush(struct ifqueue *);
static void if_slowtimo(void *);
static void link_rtrequest(int, struct rtentry *, struct sockaddr *);

extern struct inpcbhead udb, tcb;

int	ifqmaxlen = IFQ_MAXLEN;

/*
 * Network interface utility routines.
 *
 * Routines with ifa_ifwith* names take sockaddr *'s as
 * parameters.
 */
void
ifinit()
{
    register struct ifnet *ifp;

    for (ifp = ifnet; ifp; ifp = ifp->if_next)
	if (ifp->if_snd.ifq_maxlen == 0)
	    ifp->if_snd.ifq_maxlen = ifqmaxlen;

    if_slowtimo(0);
}

#ifdef vax
/*
 * Call each interface on a Unibus reset.
 */
ifubareset(uban)
	int uban;
{
	register struct ifnet *ifp;

	for (ifp = ifnet; ifp; ifp = ifp->if_next)
		if (ifp->if_reset)
			(*ifp->if_reset)(ifp->if_unit, uban);
}
#endif

int if_index = 0;
struct ifaddr **ifnet_addrs;
static char *sprint_d(u_int, char *, int);

/*
 * Attach an interface to the
 * list of "active" interfaces.
 */
void
if_attach(ifp)
	struct ifnet *ifp;
{
	unsigned socksize, ifasize;
	int namelen, unitlen, masklen;
	char workbuf[12], *unitname;
	register struct ifnet **p = &ifnet;
	register struct sockaddr_dl *sdl;
	register struct ifaddr *ifa;
	static int if_indexlim = 8;


	while (*p)
		p = &((*p)->if_next);
	*p = ifp;
	ifp->if_index = ++if_index;
	if (ifnet_addrs == 0 || if_index >= if_indexlim) {
		unsigned n = (if_indexlim <<= 1) * sizeof(ifa);
		struct ifaddr **q = (struct ifaddr **)
					malloc(n, M_IFADDR, M_WAITOK);
		bzero((caddr_t)q, n);
		if (ifnet_addrs) {
			bcopy((caddr_t)ifnet_addrs, (caddr_t)q, n/2);
			free((caddr_t)ifnet_addrs, M_IFADDR);
		}
		ifnet_addrs = q;
	}
	/*
	 * create a Link Level name for this device
	 */
	unitname = sprint_d((u_int)ifp->if_unit, workbuf, sizeof(workbuf));
	namelen = strlen(ifp->if_name);
	unitlen = strlen(unitname);
#define _offsetof(t, m) ((int)((caddr_t)&((t *)0)->m))
	masklen = _offsetof(struct sockaddr_dl, sdl_data[0]) +
			       unitlen + namelen;
	socksize = masklen + ifp->if_addrlen;
#define ROUNDUP(a) (1 + (((a) - 1) | (sizeof(long) - 1)))
	socksize = ROUNDUP(socksize);
	if (socksize < sizeof(*sdl))
		socksize = sizeof(*sdl);
	ifasize = sizeof(*ifa) + 2 * socksize;
	ifa = (struct ifaddr *)malloc(ifasize, M_IFADDR, M_WAITOK);
	if (ifa) {
		bzero((caddr_t)ifa, ifasize);
		sdl = (struct sockaddr_dl *)(ifa + 1);
		sdl->sdl_len = socksize;
		sdl->sdl_family = AF_LINK;
		bcopy(ifp->if_name, sdl->sdl_data, namelen);
		bcopy(unitname, namelen + (caddr_t)sdl->sdl_data, unitlen);
		sdl->sdl_nlen = (namelen += unitlen);
		sdl->sdl_index = ifp->if_index;
		sdl->sdl_type = ifp->if_type;
		ifnet_addrs[if_index - 1] = ifa;
		ifa->ifa_ifp = ifp;
		ifa->ifa_next = ifp->if_addrlist;
		ifa->ifa_rtrequest = link_rtrequest;
		ifp->if_addrlist = ifa;
		ifa->ifa_addr = (struct sockaddr *)sdl;
		sdl = (struct sockaddr_dl *)(socksize + (caddr_t)sdl);
		ifa->ifa_netmask = (struct sockaddr *)sdl;
		sdl->sdl_len = masklen;
		while (namelen != 0)
			sdl->sdl_data[--namelen] = 0xff;
	}
#ifndef __riscos
	/* XXX -- Temporary fix before changing 10 ethernet drivers */
#if NETHER > 0
	if (ifp->if_output == ether_output)
		ether_ifattach(ifp);
#endif
#endif
}

/*
 * Locate an interface based on a complete address.
 */
/*ARGSUSED*/
struct ifaddr *
ifa_ifwithaddr(addr)
	struct sockaddr *addr;
{
	register struct ifnet *ifp;
	register struct ifaddr *ifa;

#define	equal(a1, a2) \
  (bcmp((caddr_t)(a1), (caddr_t)(a2), ((struct sockaddr *)(a1))->sa_len) == 0)
	for (ifp = ifnet; ifp; ifp = ifp->if_next)
	    for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr->sa_family != addr->sa_family)
			continue;
		if (equal(addr, ifa->ifa_addr))
			return (ifa);
		if ((ifp->if_flags & IFF_BROADCAST) && ifa->ifa_broadaddr &&
		    equal(ifa->ifa_broadaddr, addr))
			return (ifa);
	}
	return ((struct ifaddr *)0);
}
/*
 * Locate the point to point interface with a given destination address.
 */
/*ARGSUSED*/
struct ifaddr *
ifa_ifwithdstaddr(addr)
	struct sockaddr *addr;
{
	register struct ifnet *ifp;
	register struct ifaddr *ifa;

	for (ifp = ifnet; ifp; ifp = ifp->if_next)
	    if (ifp->if_flags & IFF_POINTOPOINT)
		for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next) {
			if (ifa->ifa_addr->sa_family != addr->sa_family)
				continue;
			if (ifa->ifa_dstaddr && equal(addr, ifa->ifa_dstaddr))
				return (ifa);
	}
	return ((struct ifaddr *)0);
}

/*
 * Find an interface on a specific network.  If many, choice
 * is most specific found.
 */
struct ifaddr *
ifa_ifwithnet(addr)
	struct sockaddr *addr;
{
	register struct ifnet *ifp;
	register struct ifaddr *ifa;
	struct ifaddr *ifa_maybe = (struct ifaddr *) 0;
	u_int af = addr->sa_family;
	char *addr_data = addr->sa_data, *cplim;

	if (af == AF_LINK) {
	    register struct sockaddr_dl *sdl = (struct sockaddr_dl *)addr;
	    if (sdl->sdl_index && sdl->sdl_index <= if_index)
		return (ifnet_addrs[sdl->sdl_index - 1]);
	}
	for (ifp = ifnet; ifp; ifp = ifp->if_next) {
		for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next) {
			register char *cp, *cp2, *cp3;

			if (ifa->ifa_addr->sa_family != af)
				next: continue;
			if (ifp->if_flags & IFF_POINTOPOINT) {
				if (equal(addr, ifa->ifa_dstaddr))
 					return (ifa);
			} else {
				if (ifa->ifa_netmask == 0)
					continue;
				cp = addr_data;
				cp2 = ifa->ifa_addr->sa_data;
				cp3 = ifa->ifa_netmask->sa_data;
				cplim = ifa->ifa_netmask->sa_len + (char *)ifa->ifa_netmask;
				while (cp3 < cplim)
					if ((*cp++ ^ *cp2++) & *cp3++)
						goto next;
				if (ifa_maybe == 0 ||
				    rn_refines((caddr_t)ifa->ifa_netmask,
				    (caddr_t)ifa_maybe->ifa_netmask))
					ifa_maybe = ifa;
			}
		}
	}
	return (ifa_maybe);
}

/*
 * Find an interface using a specific address family
 */
struct ifaddr *
ifa_ifwithaf(af)
	register int af;
{
	register struct ifnet *ifp;
	register struct ifaddr *ifa;

	for (ifp = ifnet; ifp; ifp = ifp->if_next)
	    for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
		if (ifa->ifa_addr->sa_family == af)
			return (ifa);
	return ((struct ifaddr *)0);
}

/*
 * Find an interface address specific to an interface best matching
 * a given address.
 */
struct ifaddr *
ifaof_ifpforaddr(addr, ifp)
	struct sockaddr *addr;
	register struct ifnet *ifp;
{
	register struct ifaddr *ifa;
	register char *cp, *cp2, *cp3;
	register char *cplim;
	struct ifaddr *ifa_maybe = 0;
	u_int af = addr->sa_family;

	if (af >= AF_MAX)
		return (0);
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr->sa_family != af)
			continue;
		ifa_maybe = ifa;
		if (ifa->ifa_netmask == 0) {
			if (equal(addr, ifa->ifa_addr) ||
			    (ifa->ifa_dstaddr && equal(addr, ifa->ifa_dstaddr)))
				return (ifa);
			continue;
		}
		if (ifp->if_flags & IFF_POINTOPOINT) {
			if (equal(addr, ifa->ifa_dstaddr))
				return (ifa);
		} else {
			cp = addr->sa_data;
			cp2 = ifa->ifa_addr->sa_data;
			cp3 = ifa->ifa_netmask->sa_data;
			cplim = ifa->ifa_netmask->sa_len + (char *)ifa->ifa_netmask;
			for (; cp3 < cplim; cp3++)
				if ((*cp++ ^ *cp2++) & *cp3)
					break;
			if (cp3 == cplim)
				return (ifa);
		}
	}
	return (ifa_maybe);
}

#include <net/route.h>

/*
 * Default action when installing a route with a Link Level gateway.
 * Lookup an appropriate real ifa to point to.
 * This should be moved to /sys/net/link.c eventually.
 */
static void
link_rtrequest(cmd, rt, sa)
	int cmd;
	register struct rtentry *rt;
	struct sockaddr *sa;
{
	register struct ifaddr *ifa;
	struct sockaddr *dst;
	struct ifnet *ifp;

	if (cmd != RTM_ADD || ((ifa = rt->rt_ifa) == 0) ||
	    ((ifp = ifa->ifa_ifp) == 0) || ((dst = rt_key(rt)) == 0))
		return;
	ifa = ifaof_ifpforaddr(dst, ifp);
	if (ifa) {
		IFAFREE(rt->rt_ifa);
		rt->rt_ifa = ifa;
		ifa->ifa_refcnt++;
		if (ifa->ifa_rtrequest && ifa->ifa_rtrequest != link_rtrequest)
			ifa->ifa_rtrequest(cmd, rt, sa);
	}
}

/*
 * Mark an interface down and notify protocols of
 * the transition.
 * NOTE: must be called at splnet or eqivalent.
 */
void
if_down(ifp)
	register struct ifnet *ifp;
{
	register struct ifaddr *ifa;

	ifp->if_flags &= ~IFF_UP;
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
		pfctlinput(PRC_IFDOWN, ifa->ifa_addr);
	if_qflush(&ifp->if_snd);
	rt_ifmsg(ifp);
#ifdef __riscos
	{
		char buf[32];
		sprintf(buf, "%s%d", ifp->if_name, ifp->if_unit);
		service_internetstatus_interface_updown(0, buf, ifp->if_dib);
	}
#endif
}

/*
 * Mark an interface up and notify protocols of
 * the transition.
 * NOTE: must be called at splnet or eqivalent.
 */
void
if_up(ifp)
	register struct ifnet *ifp;
{
	register struct ifaddr *ifa;

	ifp->if_flags |= IFF_UP;
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
		pfctlinput(PRC_IFUP, ifa->ifa_addr);
	rt_ifmsg(ifp);
#ifdef __riscos
	{
		char buf[32];
		sprintf(buf, "%s%d", ifp->if_name, ifp->if_unit);
		service_internetstatus_interface_updown(1, buf, ifp->if_dib);
	}
#endif
}

/*
 * Flush an interface queue.
 */
static void
if_qflush(ifq)
	register struct ifqueue *ifq;
{
	register struct mbuf *m, *n;

	n = ifq->ifq_head;
	while ((m = n) != 0) {
		n = m->m_list;
		m_freem(m);
	}
	ifq->ifq_head = 0;
	ifq->ifq_tail = 0;
	ifq->ifq_len = 0;
}

/*
 * Handle interface watchdog timer routines.  Called
 * from softclock, we decrement timers (if set) and
 * call the appropriate interface routine on expiration.
 */
static void
if_slowtimo(arg)
	void *arg;
{
	register struct ifnet *ifp;

	for (ifp = ifnet; ifp; ifp = ifp->if_next) {
		if (ifp->if_timer == 0 || --ifp->if_timer)
			continue;
		if (ifp->if_watchdog)
			(*ifp->if_watchdog)(ifp);
	}
	timeout(if_slowtimo, (void *)0, hz / IFNET_SLOWHZ);
}

/*
 * Map interface name to
 * interface structure pointer.
 */
struct ifnet *
ifunit(name)
	register char *name;
{
	register char *cp;
	register struct ifnet *ifp;
	int unit;
	unsigned len;
	char *ep, c;

	for (cp = name; cp < name + IFNAMSIZ && *cp; cp++)
		if (*cp >= '0' && *cp <= '9')
			break;
	if (*cp == '\0' || cp == name + IFNAMSIZ)
		return ((struct ifnet *)0);
	/*
	 * Save first char of unit, and pointer to it,
	 * so we can put a null there to avoid matching
	 * initial substrings of interface names.
	 */
	len = cp - name + 1;
	c = *cp;
	ep = cp;
	for (unit = 0; *cp >= '0' && *cp <= '9'; )
		unit = unit * 10 + *cp++ - '0';
	*ep = 0;
	for (ifp = ifnet; ifp; ifp = ifp->if_next) {
		if (bcmp(ifp->if_name, name, len))
			continue;
#if defined __riscos && 0
		/*
		 * it *is* possible for a network driver to
		 * disappear, so check that this has not
		 * happened.
		 */
		if( unit == ifp->if_unit && !(ifp->if_flags & IFF_NODRIVER) )
	    		break;
#else
		if (unit == ifp->if_unit)
			break;
#endif
	}
	*ep = c;
	return (ifp);
}

#ifdef __riscos
/*
 * the ioctl's in this function were added at the request of
 * OMI, who need the SO_KEEPALIVE feature to kick in after a
 * time interval less than the system standard of 2 hours
 */
static int tcpconf(int cmd, caddr_t data)
{
    extern int tcp_keepidle;
    extern int tcp_keepcnt;

    switch(cmd)
    {
      case SIOCGTCPIDLE:
	*(int *)data = tcp_keepidle / PR_SLOWHZ;
	break;

      case SIOCSTCPIDLE:
	tcp_keepidle = (*(int *)data) * PR_SLOWHZ;
	break;

      case SIOCGTCPCNT:
	*(int *)data = tcp_keepcnt;
	break;

      case SIOCSTCPCNT:
	tcp_keepcnt = *(int *)data;
	break;
    }

    return(0);
}
#endif

/*
 * Interface ioctls.
 */
int
ifioctl(so, cmd, data)
    struct socket *so;
    u_long cmd;
    caddr_t data;
{
    register struct ifnet *ifp;
    register struct ifreq *ifr;
    int error;

    switch (cmd)
    {
#ifdef __riscos
	/*
	 * deal with the special TCP control commands
	 * added for the benefit of OMI
	 */
      case SIOCGTCPIDLE:
      case SIOCSTCPIDLE:
      case SIOCGTCPCNT:
      case SIOCSTCPCNT:
	return(tcpconf(cmd, data));

#if 0
      case SIOCGPCBHEADS:
	/*
	 * return head of UDP and TCP pcb linked lists
	 */
	((struct pcbheads *)data)->pcb_udb = udb.lh_first;
	((struct pcbheads *)data)->pcb_tcb = tcb.lh_first;
	return(0);

      case SIOCGPRSTATS:
        /*
         * return per-protocol statistics that used to be provided by
         * *InetInfo p
         */
        ((struct prstats *)data)->ipstat = &ipstat;
        ((struct prstats *)data)->icmpstat = &icmpstat;
        ((struct prstats *)data)->tcpstat = &tcpstat;
        ((struct prstats *)data)->udpstat = &udpstat;
        return 0;
#endif
#endif

      case SIOCGIFCONF:
      case OSIOCGIFCONF:
	return (ifconf(cmd, data));
    }
    ifr = (struct ifreq *)data;
    ifp = ifunit(ifr->ifr_name);
    if (ifp == 0)
	return (ENXIO);

    switch (cmd)
    {
#ifdef __riscos
      case SIOCGWHOIAMMNS:
	/* set flag so that we know that a Net module variant is using us */
	AUN_state = AUN_CLIENT;
	if (if_whoamimns(ifp) != 0)
	    return (EADDRNOTAVAIL);

	break;

      case SIOCGWHOIAMR:
      case SIOCGWHOIAMB:
      case SIOCGWHOIAMRB:
	return (if_whoamiaddr(ifp, cmd));
	break;

      case SIOCGWHOIAMD:
        if (if_sdhcpreq(ifp, (struct ifdhcpreq *)data) != 0)
            return (EADDRNOTAVAIL);

        break;

      case SIOCGWHOIAMM:
	if (if_whoamimask(ifp) != 0)
	    return (EADDRNOTAVAIL);

	break;

      case SIOCSWHOTHEYARE:
	/*
	 * XXX
	 *
	 * this ioctl() is a replacement for SIOCWHOIAMMNS
	 * which, in the InternetAG module provided
	 * completely different functionality to what it
	 * provides in the Internet and InternetA modules.
	 *
	 * this code is *even more* braindamaged than
	 * originally thought: a struct ifnet pointer is
	 * passed to revarp_broadcastclientaddrs(), whereas
	 * the function actually expects a struct arpcom
	 * pointer (this reproduces what happens in the
	 * old (DCI2) NetG/InternetAG code).
	 */

	/* set flag so that we know that a NetG module variant is using us */
	AUN_state = AUN_GATEWAY;
	revarp_broadcastclientaddrs((struct arpcom *) ifp);
	break;

#endif /* defined(__riscos) */

	case SIOCGIFFLAGS:
		ifr->ifr_flags = ifp->if_flags;
		break;

	case SIOCGIFMETRIC:
		ifr->ifr_metric = ifp->if_metric;
		break;

	case SIOCGIFMTU:
		ifr->ifr_mtu = ifp->if_mtu;
		break;

 	case SIOCGIFPHYS:
		ifr->ifr_phys = ifp->if_physical;
		break;

	case SIOCSIFFLAGS:
#ifndef __riscos
		error = suser(p->p_ucred, &p->p_acflag);
		if (error)
			return (error);
#endif
		if (ifp->if_flags & IFF_UP && (ifr->ifr_flags & IFF_UP) == 0) {
			int s = splimp();
			if_down(ifp);
			splx(s);
		}
		if (ifr->ifr_flags & IFF_UP && (ifp->if_flags & IFF_UP) == 0) {
			int s = splimp();
			if_up(ifp);
			splx(s);
		}
		ifp->if_flags = (ifp->if_flags & IFF_CANTCHANGE) |
			(ifr->ifr_flags & ~IFF_CANTCHANGE);
		if (ifp->if_ioctl)
			(void) (*ifp->if_ioctl)(ifp, cmd, data);
		break;

	case SIOCSIFMETRIC:
#ifndef __riscos
		error = suser(p->p_ucred, &p->p_acflag);
		if (error)
			return (error);
#endif
		ifp->if_metric = ifr->ifr_metric;
		break;

	case SIOCSIFPHYS:
#ifndef __riscos
		error = suser(p->p_ucred, &p->p_acflag);
		if (error) return error;
#endif

		if (!ifp->if_ioctl) return EOPNOTSUPP;
		return ifp->if_ioctl(ifp, cmd, data);

	case SIOCSIFMTU:
#ifndef __riscos
		error = suser(p->p_ucred, &p->p_acflag);
		if (error)
			return (error);
#endif
		if (ifp->if_ioctl == NULL)
			return (EOPNOTSUPP);
		/*
		 * 72 was chosen below because it is the size of a TCP/IP
		 * header (40) + the minimum mss (32).
		 */
		if (ifr->ifr_mtu < 72 || ifr->ifr_mtu > 65535)
			return (EINVAL);
		return ((*ifp->if_ioctl)(ifp, cmd, data));

	default:
		if (so->so_proto == 0)
			return (EOPNOTSUPP);
#ifndef COMPAT_43
		return ((*so->so_proto->pr_usrreq)(so, PRU_CONTROL,
			cmd, data, ifp));
#else
	    {
		int ocmd = cmd;

		switch (cmd) {

		case SIOCSIFDSTADDR:
		case SIOCSIFADDR:
		case SIOCSIFBRDADDR:
		case SIOCSIFNETMASK:
#if BYTE_ORDER != BIG_ENDIAN
			if (ifr->ifr_addr.sa_family == 0 &&
			    ifr->ifr_addr.sa_len < 16) {
				ifr->ifr_addr.sa_family = ifr->ifr_addr.sa_len;
				ifr->ifr_addr.sa_len = 16;
			}
#ifdef DEBUG
                        Printf("Munged ifr: now len=%d, family=%d\n", ifr->ifr_addr.sa_len, ifr->ifr_addr.sa_family);
#endif
#else
			if (ifr->ifr_addr.sa_len == 0)
				ifr->ifr_addr.sa_len = 16;
#endif
			break;

		case OSIOCGIFADDR:
			cmd = SIOCGIFADDR;
			break;

		case OSIOCGIFDSTADDR:
			cmd = SIOCGIFDSTADDR;
			break;

		case OSIOCGIFBRDADDR:
			cmd = SIOCGIFBRDADDR;
			break;

		case OSIOCGIFNETMASK:
			cmd = SIOCGIFNETMASK;
		}
		error =  ((*so->so_proto->pr_usrreq)(so, PRU_CONTROL,
							    cmd, data, ifp));
		switch (ocmd) {

		case OSIOCGIFADDR:
		case OSIOCGIFDSTADDR:
		case OSIOCGIFBRDADDR:
		case OSIOCGIFNETMASK:
			*(u_short *)&ifr->ifr_addr = ifr->ifr_addr.sa_family;
		}
		return (error);

	    }
#endif
	}
	return (0);
}

/*
 * Return interface configuration
 * of system.  List may be used
 * in later ioctl's (above) to get
 * other information.
 */
/*ARGSUSED*/
static int
ifconf(cmd, data)
	u_long cmd;
	caddr_t data;
{
	register struct ifconf *ifc = (struct ifconf *)data;
	register struct ifnet *ifp = ifnet;
	register struct ifaddr *ifa;
	struct ifreq ifr, *ifrp;
	int space = ifc->ifc_len, error = 0;

	ifrp = ifc->ifc_req;
	for (; space > sizeof (ifr) && ifp; ifp = ifp->if_next) {
		char workbuf[12], *unitname;
		int unitlen, ifnlen;

#ifdef __riscos
		if (ifp->if_flags & IFF_NODRIVER)
			continue;
#endif

		unitname = sprint_d(ifp->if_unit, workbuf, sizeof workbuf);
		unitlen = strlen(unitname);
		ifnlen = strlen(ifp->if_name);
		if(unitlen + ifnlen + 1 > sizeof ifr.ifr_name) {
			error = ENAMETOOLONG;
		} else {
			strcpy(ifr.ifr_name, ifp->if_name);
			strcpy(&ifr.ifr_name[ifnlen], unitname);
		}

#ifdef DEBUG
                Printf("ifconf: unitname=%s, if_name=%s\n", unitname, ifp->if_name);
#endif
		if ((ifa = ifp->if_addrlist) == 0) {
#ifdef DEBUG
                        Printf("     no addrlist\n");
#endif
			bzero((caddr_t)&ifr.ifr_addr, sizeof(ifr.ifr_addr));
			error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
			    sizeof (ifr));
			if (error)
				break;
			space -= sizeof (ifr), ifrp++;
		} else
		    for ( ; space > sizeof (ifr) && ifa; ifa = ifa->ifa_next) {
			register struct sockaddr *sa = ifa->ifa_addr;
#ifdef DEBUG
                        Printf("    address=%x %x %x %x\n", ((int *)sa)[0], ((int *)sa)[1],((int *)sa)[2],((int *)sa)[3]);
#endif
#ifdef COMPAT_43
			if (cmd == OSIOCGIFCONF) {
				struct osockaddr *osa =
					 (struct osockaddr *)&ifr.ifr_addr;
				ifr.ifr_addr = *sa;
				osa->sa_family = sa->sa_family;
				error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
						sizeof (ifr));
				ifrp++;
			} else
#endif
			if (sa->sa_len <= sizeof(*sa)) {
				ifr.ifr_addr = *sa;
				error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
						sizeof (ifr));
				ifrp++;
			} else {
				space -= sa->sa_len - sizeof(*sa);
				if (space < sizeof (ifr))
					break;
				error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
						sizeof (ifr.ifr_name));
				if (error == 0)
				    error = copyout((caddr_t)sa,
				      (caddr_t)&ifrp->ifr_addr, sa->sa_len);
				ifrp = (struct ifreq *)
					(sa->sa_len + (caddr_t)&ifrp->ifr_addr);
			}
			if (error)
				break;
			space -= sizeof (ifr);
		}
	}
	ifc->ifc_len -= space;
	return (error);
}

static char *
sprint_d(n, buf, buflen)
	u_int n;
	char *buf;
	int buflen;
{
	register char *cp = buf + buflen - 1;

	*cp = 0;
	do {
		cp--;
		*cp = "0123456789"[n % 10];
		n /= 10;
	} while (n != 0);
	return (cp);
}
@


4.6
log
@Added new FreeBSD sysctl handling using linker magic.
A few new sysctls added as a result.
SO_TIMESTAMP now gives real time, not Internet's internal time.
DHCP/BOOTP parsing picks up URL option and pops it into Inet$URL.
Requires TCPIPLibs 5.25 and link 5.12.

Version 5.31. Tagged as 'Internet-5_31'
@
text
@d414 1
a416 3
#ifdef notyet
	register struct ifaddr *ifa;
	/* this has no effect on IP, and will kill all iso connections XXX */
a418 1
#endif
@


4.5
log
@* Dynamic ports now assigned in range 49152-65535.
* IP_RECVDSTADDR works for non-unicast packets.
* SO_TIMESTAMP added.
* IP_RECVIF added.
* Various other internal changes merged in from FreeBSD sources.

Version 5.29. Tagged as 'Internet-5_29'
@
text
@d47 1
@


4.4
log
@Interim code added to enable the BOOTP/DHCP code to return proper values
for errno from the ioctl which controls dynamic booting.

Not tagged.
@
text
@d67 5
d356 1
a356 1
void
d434 1
a434 1
void
d455 1
a455 1
void
d465 1
a465 1
			(*ifp->if_watchdog)(ifp->if_unit);
d560 1
a560 1
    int cmd;
d807 1
a807 1
int
d809 1
a809 1
	int cmd;
@


4.3
log
@  Support for DHCP module added.
Detail:
  Support for the new ioctl (SIOCGWHOIAMD) added.
  BOOTP client code re-organised so that DHCP module can
    trigger particular things to be done for it such as
    sending a packet on an interface, interpreting a
    "BOOTP response" - ie. a DHCPACK message.  This allows
    the DHCP module to usurp the BOOTP behaviour of the
    Internet module and replace it without Internet module
    clients like IPConfig ever being aware that it is now
    using DHCP and not BOOTP.
Admin:
  Tested in general usage in desktop machine.
  Requires TCPIPLibs 5.09
    (RiscOS/Sources/Lib/TCPIPLibs tag: TCPIPLibs-5_09 or later)
  Required by DHCP 0.00
    (RiscOS/Sources/Networking/DHCP tag: DHCP-0_00 or later)

Version 5.20. Tagged as 'Internet-5_20'
@
text
@d620 1
a620 3
	if (if_whoamiaddr(ifp, cmd) != 0)
	    return (EADDRNOTAVAIL);

@


4.2
log
@Version Spinner_B7 taken
@
text
@d59 1
d624 6
@


4.1
log
@Initial revision
@
text
@d1 3
a3 1
/* -*-C-*-
d5 15
a19 2
 * $Header: /ax/networking:Internet/net/if.c:networking  1.2  $
 * $Source: /ax/networking:Internet/net/if.c: $
d21 11
a31 27
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
 *
 * $Log:	if.c,v $
 * Revision 1.2  95/01/24  15:26:21  kwelton
 * Added a new ioctl() SIOCSWHOTHEYARE, which duplicates the functionality
 * of SIOCGWHOIAMMNS in the old InternetAG module (yes, someone really was
 * stupid enough to have two different versions of the one ioctl() =8().
 * 
 * Revision 1.1  94/12/02  10:55:21  kwelton
 * Initial revision
 * 
 */
/*
 * Copyright (c) 1983, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d34 1
d37 27
a63 10
#include "sys/param.h"
#include "sys/systm.h"
#include "sys/dir.h"
#include "sys/user.h"
#include "sys/mbuf.h"
#include "sys/socket.h"
#include "sys/socketvar.h"
#include "sys/protosw.h"
#include "sys/errno.h"
#include "sys/ioctl.h"
a64 2
#include "net/if.h"
#include "net/af.h"
d66 1
a66 1
#include "ether.h"
d76 1
a76 1

d85 1
a85 1
    if_slowtimo();
d103 4
d111 1
d115 3
d119 5
d127 57
d197 2
a198 2
#define equal(a1, a2) \
	(bcmp((caddr_t)((a1)->sa_data), (caddr_t)((a2)->sa_data), 14) == 0)
d201 1
a201 1
		if (ifa->ifa_addr.sa_family != addr->sa_family)
d203 1
a203 1
		if (equal(&ifa->ifa_addr, addr))
d205 2
a206 2
		if ((ifp->if_flags & IFF_BROADCAST) &&
		    equal(&ifa->ifa_broadaddr, addr))
d225 1
a225 1
			if (ifa->ifa_addr.sa_family != addr->sa_family)
d227 1
a227 1
			if (equal(&ifa->ifa_dstaddr, addr))
d235 1
a235 1
 * is first found.
d239 1
a239 1
	register struct sockaddr *addr;
d243 12
a254 2
	register u_int af = addr->sa_family;
	register int (*netmatch)();
d256 21
a276 9
	if (af >= AF_MAX)
		return (0);
	netmatch = afswitch[af].af_netmatch;
	for (ifp = ifnet; ifp; ifp = ifp->if_next)
	    for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr.sa_family != addr->sa_family)
			continue;
		if ((*netmatch)(&ifa->ifa_addr, addr))
			return (ifa);
d278 1
a278 1
	return ((struct ifaddr *)0);
a280 1
#ifdef notdef
d293 1
a293 1
		if (ifa->ifa_addr.sa_family == af)
d297 75
a371 1
#endif
d378 1
d386 1
a386 1
		pfctlinput(PRC_IFDOWN, &ifa->ifa_addr);
d388 35
d428 1
d435 1
a435 1
	while (m = n) {
a436 1
#ifdef OldCode
a437 3
#else
		FREEM(m);
#endif
d449 3
a451 1
if_slowtimo()
d461 22
d484 3
a486 3
	 * XXX TRACE XXX
	 *
	 * have replaced hz with HZ here - is this correct?
d488 24
a511 1
	timeout(if_slowtimo, (caddr_t)0, HZ / IFNET_SLOWHZ);
d514 1
d516 3
a518 2
 * Map interface name to
 * interface structure pointer.
d520 1
a520 1
static struct ifnet *ifunit(char *name)
d522 2
a523 31
    register char *cp;
    register struct ifnet *ifp;
    int unit;
    unsigned len;
    char *ep, c;
#ifdef OldCode
    int tried_again = 0;
#endif /* OldCode */

    for (cp = name; cp < name + IFNAMSIZ && *cp; cp++)
	if (*cp >= '0' && *cp <= '9')
	    break;

    if (*cp == '\0' || cp == name + IFNAMSIZ)
	return ((struct ifnet *)0);

    /*
     * Save first char of unit, and pointer to it,
     * so we can put a null there to avoid matching
     * initial substrings of interface names.
     */
    len = cp - name + 1;
    c = *cp;
    ep = cp;
    for (unit = 0; *cp >= '0' && *cp <= '9'; )
	unit = unit * 10 + *cp++ - '0';
    *ep = 0;

#ifdef OldCode
  try_again:
#endif /* OldCode */
d525 1
a525 1
    for (ifp = ifnet; ifp; ifp = ifp->if_next)
d527 3
a529 2
	if (bcmp(ifp->if_name, name, len))
	    continue;
d531 7
a537 8
	/*
	 * it *is* possible for a network driver to
	 * disappear, so check that this has not
	 * happened.
	 */
	if( unit == ifp->if_unit && !(ifp->if_flags & IFF_NODRIVER) )
	    break;
    }
d539 3
a541 11
#ifdef OldCode
    /*
     * if_module interface
     */
    if (ifp == 0 && !tried_again)
    {
	if (if_module_attach(name, len))
	{
	    tried_again = 1;
	    goto try_again;
	}
a542 1
#endif /* OldCode */
d544 1
a544 2
    *ep = c;
    return (ifp);
d546 1
d551 5
a555 1
int ifioctl(struct socket *so, int cmd, caddr_t data)
d559 1
d563 32
d597 1
a598 13

#if defined(INET) && NETHER > 0
      case SIOCSARP:
      case SIOCDARP:
	/* FALL THROUGH */

#ifdef __riscos
      case SIOCTARP:
#endif

      case SIOCGARP:
	return (arpioctl(cmd, data));
#endif
a599 1

d609 2
d646 4
a649 1
	revarp_broadcastclientaddrs(ifp);
d654 46
a699 3
      case SIOCGIFFLAGS:
	ifr->ifr_flags = ifp->if_flags;
	break;
d701 5
a705 3
      case SIOCGIFMETRIC:
	ifr->ifr_metric = ifp->if_metric;
	break;
d707 2
a708 7
      case SIOCSIFFLAGS:
	if (ifp->if_flags & IFF_UP && (ifr->ifr_flags & IFF_UP) == 0)
	{
	    int s = splimp();
	    if_down(ifp);
	    splx(s);
	}
d710 25
a734 2
	ifp->if_flags = (ifp->if_flags & IFF_CANTCHANGE) |
			(ifr->ifr_flags & ~IFF_CANTCHANGE);
d736 1
a736 2
	if (ifp->if_ioctl)
	    (void) (*ifp->if_ioctl)(ifp, cmd, data);
d738 18
a755 1
	break;
d757 11
a767 3
      case SIOCSIFMETRIC:
	ifp->if_metric = ifr->ifr_metric;
	break;
d769 14
a782 3
      default:
	if (so->so_proto == 0)
	    return (EOPNOTSUPP);
d784 4
a787 4
	return ((*so->so_proto->pr_usrreq)(so, PRU_CONTROL, cmd, data, ifp));
    }

    return (0);
d797 1
a804 1
	register char *cp, *ep;
a808 1
	ep = ifr.ifr_name + sizeof (ifr.ifr_name) - 2;
d810 21
a830 4
		bcopy(ifp->if_name, ifr.ifr_name, sizeof (ifr.ifr_name) - 2);
		for (cp = ifr.ifr_name; cp < ep && *cp; cp++)
			;
		*cp++ = '0' + ifp->if_unit; *cp = '\0';
d832 3
d836 2
a837 1
			error = copyout((caddr_t)&ifr, (caddr_t)ifrp, sizeof (ifr));
d843 32
a874 2
			ifr.ifr_addr = ifa->ifa_addr;
			error = copyout((caddr_t)&ifr, (caddr_t)ifrp, sizeof (ifr));
d877 1
a877 1
			space -= sizeof (ifr), ifrp++;
d884 16
a899 1
/* EOF if.c */
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d1 17
d19 2
a20 18
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d22 11
a32 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a34 1

d37 10
a46 27
#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/protosw.h>
#include <sys/kernel.h>
#include <sys/ioctl.h>
#include <sys/errno.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/radix.h>
#include <ether.h>

#ifdef __riscos
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <sys/queue.h>
#include <net/route.h>
#include "whoami.h"
#include "module.h"
#include "debug.h"
#include "swiveneers.h"
#endif
d48 2
d51 1
a51 1
extern struct inpcbhead udb, tcb;
d61 1
a61 1
void
d70 1
a70 1
    if_slowtimo(0);
a87 4
int if_index = 0;
struct ifaddr **ifnet_addrs;
static char *sprint_d(u_int, char *, int);

a91 1
void
a94 3
	unsigned socksize, ifasize;
	int namelen, unitlen, masklen;
	char workbuf[12], *unitname;
a95 5
	register struct sockaddr_dl *sdl;
	register struct ifaddr *ifa;
	static int if_indexlim = 8;


a98 57
	ifp->if_index = ++if_index;
	if (ifnet_addrs == 0 || if_index >= if_indexlim) {
		unsigned n = (if_indexlim <<= 1) * sizeof(ifa);
		struct ifaddr **q = (struct ifaddr **)
					malloc(n, M_IFADDR, M_WAITOK);
		bzero((caddr_t)q, n);
		if (ifnet_addrs) {
			bcopy((caddr_t)ifnet_addrs, (caddr_t)q, n/2);
			free((caddr_t)ifnet_addrs, M_IFADDR);
		}
		ifnet_addrs = q;
	}
	/*
	 * create a Link Level name for this device
	 */
	unitname = sprint_d((u_int)ifp->if_unit, workbuf, sizeof(workbuf));
	namelen = strlen(ifp->if_name);
	unitlen = strlen(unitname);
#define _offsetof(t, m) ((int)((caddr_t)&((t *)0)->m))
	masklen = _offsetof(struct sockaddr_dl, sdl_data[0]) +
			       unitlen + namelen;
	socksize = masklen + ifp->if_addrlen;
#define ROUNDUP(a) (1 + (((a) - 1) | (sizeof(long) - 1)))
	socksize = ROUNDUP(socksize);
	if (socksize < sizeof(*sdl))
		socksize = sizeof(*sdl);
	ifasize = sizeof(*ifa) + 2 * socksize;
	ifa = (struct ifaddr *)malloc(ifasize, M_IFADDR, M_WAITOK);
	if (ifa) {
		bzero((caddr_t)ifa, ifasize);
		sdl = (struct sockaddr_dl *)(ifa + 1);
		sdl->sdl_len = socksize;
		sdl->sdl_family = AF_LINK;
		bcopy(ifp->if_name, sdl->sdl_data, namelen);
		bcopy(unitname, namelen + (caddr_t)sdl->sdl_data, unitlen);
		sdl->sdl_nlen = (namelen += unitlen);
		sdl->sdl_index = ifp->if_index;
		sdl->sdl_type = ifp->if_type;
		ifnet_addrs[if_index - 1] = ifa;
		ifa->ifa_ifp = ifp;
		ifa->ifa_next = ifp->if_addrlist;
		ifa->ifa_rtrequest = link_rtrequest;
		ifp->if_addrlist = ifa;
		ifa->ifa_addr = (struct sockaddr *)sdl;
		sdl = (struct sockaddr_dl *)(socksize + (caddr_t)sdl);
		ifa->ifa_netmask = (struct sockaddr *)sdl;
		sdl->sdl_len = masklen;
		while (namelen != 0)
			sdl->sdl_data[--namelen] = 0xff;
	}
#ifndef __riscos
	/* XXX -- Temporary fix before changing 10 ethernet drivers */
#if NETHER > 0
	if (ifp->if_output == ether_output)
		ether_ifattach(ifp);
#endif
#endif
d112 2
a113 2
#define	equal(a1, a2) \
  (bcmp((caddr_t)(a1), (caddr_t)(a2), ((struct sockaddr *)(a1))->sa_len) == 0)
d116 1
a116 1
		if (ifa->ifa_addr->sa_family != addr->sa_family)
d118 1
a118 1
		if (equal(addr, ifa->ifa_addr))
d120 2
a121 2
		if ((ifp->if_flags & IFF_BROADCAST) && ifa->ifa_broadaddr &&
		    equal(ifa->ifa_broadaddr, addr))
d140 1
a140 1
			if (ifa->ifa_addr->sa_family != addr->sa_family)
d142 1
a142 1
			if (ifa->ifa_dstaddr && equal(addr, ifa->ifa_dstaddr))
d150 1
a150 1
 * is most specific found.
d154 1
a154 1
	struct sockaddr *addr;
d158 2
a159 12
	struct ifaddr *ifa_maybe = (struct ifaddr *) 0;
	u_int af = addr->sa_family;
	char *addr_data = addr->sa_data, *cplim;

	if (af == AF_LINK) {
	    register struct sockaddr_dl *sdl = (struct sockaddr_dl *)addr;
	    if (sdl->sdl_index && sdl->sdl_index <= if_index)
		return (ifnet_addrs[sdl->sdl_index - 1]);
	}
	for (ifp = ifnet; ifp; ifp = ifp->if_next) {
		for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next) {
			register char *cp, *cp2, *cp3;
d161 9
a169 21
			if (ifa->ifa_addr->sa_family != af)
				next: continue;
			if (ifp->if_flags & IFF_POINTOPOINT) {
				if (equal(addr, ifa->ifa_dstaddr))
 					return (ifa);
			} else {
				if (ifa->ifa_netmask == 0)
					continue;
				cp = addr_data;
				cp2 = ifa->ifa_addr->sa_data;
				cp3 = ifa->ifa_netmask->sa_data;
				cplim = ifa->ifa_netmask->sa_len + (char *)ifa->ifa_netmask;
				while (cp3 < cplim)
					if ((*cp++ ^ *cp2++) & *cp3++)
						goto next;
				if (ifa_maybe == 0 ||
				    rn_refines((caddr_t)ifa->ifa_netmask,
				    (caddr_t)ifa_maybe->ifa_netmask))
					ifa_maybe = ifa;
			}
		}
d171 1
a171 1
	return (ifa_maybe);
d174 1
d187 1
a187 1
		if (ifa->ifa_addr->sa_family == af)
d191 1
a191 75

/*
 * Find an interface address specific to an interface best matching
 * a given address.
 */
struct ifaddr *
ifaof_ifpforaddr(addr, ifp)
	struct sockaddr *addr;
	register struct ifnet *ifp;
{
	register struct ifaddr *ifa;
	register char *cp, *cp2, *cp3;
	register char *cplim;
	struct ifaddr *ifa_maybe = 0;
	u_int af = addr->sa_family;

	if (af >= AF_MAX)
		return (0);
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr->sa_family != af)
			continue;
		ifa_maybe = ifa;
		if (ifa->ifa_netmask == 0) {
			if (equal(addr, ifa->ifa_addr) ||
			    (ifa->ifa_dstaddr && equal(addr, ifa->ifa_dstaddr)))
				return (ifa);
			continue;
		}
		if (ifp->if_flags & IFF_POINTOPOINT) {
			if (equal(addr, ifa->ifa_dstaddr))
				return (ifa);
		} else {
			cp = addr->sa_data;
			cp2 = ifa->ifa_addr->sa_data;
			cp3 = ifa->ifa_netmask->sa_data;
			cplim = ifa->ifa_netmask->sa_len + (char *)ifa->ifa_netmask;
			for (; cp3 < cplim; cp3++)
				if ((*cp++ ^ *cp2++) & *cp3)
					break;
			if (cp3 == cplim)
				return (ifa);
		}
	}
	return (ifa_maybe);
}

#include <net/route.h>

/*
 * Default action when installing a route with a Link Level gateway.
 * Lookup an appropriate real ifa to point to.
 * This should be moved to /sys/net/link.c eventually.
 */
void
link_rtrequest(cmd, rt, sa)
	int cmd;
	register struct rtentry *rt;
	struct sockaddr *sa;
{
	register struct ifaddr *ifa;
	struct sockaddr *dst;
	struct ifnet *ifp;

	if (cmd != RTM_ADD || ((ifa = rt->rt_ifa) == 0) ||
	    ((ifp = ifa->ifa_ifp) == 0) || ((dst = rt_key(rt)) == 0))
		return;
	ifa = ifaof_ifpforaddr(dst, ifp);
	if (ifa) {
		IFAFREE(rt->rt_ifa);
		rt->rt_ifa = ifa;
		ifa->ifa_refcnt++;
		if (ifa->ifa_rtrequest && ifa->ifa_rtrequest != link_rtrequest)
			ifa->ifa_rtrequest(cmd, rt, sa);
	}
}
a197 1
void
d205 1
a205 1
		pfctlinput(PRC_IFDOWN, ifa->ifa_addr);
a206 35
	rt_ifmsg(ifp);
#ifdef __riscos
	{
		char buf[32];
		sprintf(buf, "%s%d", ifp->if_name, ifp->if_unit);
		service_internetstatus_interface_updown(0, buf, ifp->if_dib);
	}
#endif
}

/*
 * Mark an interface up and notify protocols of
 * the transition.
 * NOTE: must be called at splnet or eqivalent.
 */
void
if_up(ifp)
	register struct ifnet *ifp;
{

	ifp->if_flags |= IFF_UP;
#ifdef notyet
	register struct ifaddr *ifa;
	/* this has no effect on IP, and will kill all iso connections XXX */
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
		pfctlinput(PRC_IFUP, ifa->ifa_addr);
#endif
	rt_ifmsg(ifp);
#ifdef __riscos
	{
		char buf[32];
		sprintf(buf, "%s%d", ifp->if_name, ifp->if_unit);
		service_internetstatus_interface_updown(1, buf, ifp->if_dib);
	}
#endif
a211 1
void
d218 1
a218 1
	while ((m = n) != 0) {
d220 1
d222 3
d236 1
a236 3
void
if_slowtimo(arg)
	void *arg;
d246 6
a251 1
	timeout(if_slowtimo, (void *)0, hz / IFNET_SLOWHZ);
d258 1
a258 3
struct ifnet *
ifunit(name)
	register char *name;
d260 37
a296 11
	register char *cp;
	register struct ifnet *ifp;
	int unit;
	unsigned len;
	char *ep, c;

	for (cp = name; cp < name + IFNAMSIZ && *cp; cp++)
		if (*cp >= '0' && *cp <= '9')
			break;
	if (*cp == '\0' || cp == name + IFNAMSIZ)
		return ((struct ifnet *)0);
d298 3
a300 3
	 * Save first char of unit, and pointer to it,
	 * so we can put a null there to avoid matching
	 * initial substrings of interface names.
d302 3
a304 36
	len = cp - name + 1;
	c = *cp;
	ep = cp;
	for (unit = 0; *cp >= '0' && *cp <= '9'; )
		unit = unit * 10 + *cp++ - '0';
	*ep = 0;
	for (ifp = ifnet; ifp; ifp = ifp->if_next) {
		if (bcmp(ifp->if_name, name, len))
			continue;
#if defined __riscos && 0
		/*
		 * it *is* possible for a network driver to
		 * disappear, so check that this has not
		 * happened.
		 */
		if( unit == ifp->if_unit && !(ifp->if_flags & IFF_NODRIVER) )
	    		break;
#else
		if (unit == ifp->if_unit)
			break;
#endif
	}
	*ep = c;
	return (ifp);
}

#ifdef __riscos
/*
 * the ioctl's in this function were added at the request of
 * OMI, who need the SO_KEEPALIVE feature to kick in after a
 * time interval less than the system standard of 2 hours
 */
static int tcpconf(int cmd, caddr_t data)
{
    extern int tcp_keepidle;
    extern int tcp_keepcnt;
d306 5
a310 1
    switch(cmd)
d312 5
a316 15
      case SIOCGTCPIDLE:
	*(int *)data = tcp_keepidle / PR_SLOWHZ;
	break;

      case SIOCSTCPIDLE:
	tcp_keepidle = (*(int *)data) * PR_SLOWHZ;
	break;

      case SIOCGTCPCNT:
	*(int *)data = tcp_keepcnt;
	break;

      case SIOCSTCPCNT:
	tcp_keepcnt = *(int *)data;
	break;
d318 1
d320 2
a321 1
    return(0);
a322 1
#endif
d327 1
a327 5
int
ifioctl(so, cmd, data)
    struct socket *so;
    int cmd;
    caddr_t data;
a330 1
    int error;
d334 9
d344 2
a345 9
	/*
	 * deal with the special TCP control commands
	 * added for the benefit of OMI
	 */
      case SIOCGTCPIDLE:
      case SIOCSTCPIDLE:
      case SIOCGTCPCNT:
      case SIOCSTCPCNT:
	return(tcpconf(cmd, data));
d347 2
a348 20
#if 0
      case SIOCGPCBHEADS:
	/*
	 * return head of UDP and TCP pcb linked lists
	 */
	((struct pcbheads *)data)->pcb_udb = udb.lh_first;
	((struct pcbheads *)data)->pcb_tcb = tcb.lh_first;
	return(0);

      case SIOCGPRSTATS:
        /*
         * return per-protocol statistics that used to be provided by
         * *InetInfo p
         */
        ((struct prstats *)data)->ipstat = &ipstat;
        ((struct prstats *)data)->icmpstat = &icmpstat;
        ((struct prstats *)data)->tcpstat = &tcpstat;
        ((struct prstats *)data)->udpstat = &udpstat;
        return 0;
#endif
d350 1
a351 4
      case SIOCGIFCONF:
      case OSIOCGIFCONF:
	return (ifconf(cmd, data));
    }
a360 2
	/* set flag so that we know that a Net module variant is using us */
	AUN_state = AUN_CLIENT;
d396 1
a396 4

	/* set flag so that we know that a NetG module variant is using us */
	AUN_state = AUN_GATEWAY;
	revarp_broadcastclientaddrs((struct arpcom *) ifp);
d401 7
a407 46
	case SIOCGIFFLAGS:
		ifr->ifr_flags = ifp->if_flags;
		break;

	case SIOCGIFMETRIC:
		ifr->ifr_metric = ifp->if_metric;
		break;

	case SIOCGIFMTU:
		ifr->ifr_mtu = ifp->if_mtu;
		break;

 	case SIOCGIFPHYS:
		ifr->ifr_phys = ifp->if_physical;
		break;

	case SIOCSIFFLAGS:
#ifndef __riscos
		error = suser(p->p_ucred, &p->p_acflag);
		if (error)
			return (error);
#endif
		if (ifp->if_flags & IFF_UP && (ifr->ifr_flags & IFF_UP) == 0) {
			int s = splimp();
			if_down(ifp);
			splx(s);
		}
		if (ifr->ifr_flags & IFF_UP && (ifp->if_flags & IFF_UP) == 0) {
			int s = splimp();
			if_up(ifp);
			splx(s);
		}
		ifp->if_flags = (ifp->if_flags & IFF_CANTCHANGE) |
			(ifr->ifr_flags & ~IFF_CANTCHANGE);
		if (ifp->if_ioctl)
			(void) (*ifp->if_ioctl)(ifp, cmd, data);
		break;

	case SIOCSIFMETRIC:
#ifndef __riscos
		error = suser(p->p_ucred, &p->p_acflag);
		if (error)
			return (error);
#endif
		ifp->if_metric = ifr->ifr_metric;
		break;
d409 7
a415 5
	case SIOCSIFPHYS:
#ifndef __riscos
		error = suser(p->p_ucred, &p->p_acflag);
		if (error) return error;
#endif
d417 2
a418 2
		if (!ifp->if_ioctl) return EOPNOTSUPP;
		return ifp->if_ioctl(ifp, cmd, data);
d420 2
a421 25
	case SIOCSIFMTU:
#ifndef __riscos
		error = suser(p->p_ucred, &p->p_acflag);
		if (error)
			return (error);
#endif
		if (ifp->if_ioctl == NULL)
			return (EOPNOTSUPP);
		/*
		 * 72 was chosen below because it is the size of a TCP/IP
		 * header (40) + the minimum mss (32).
		 */
		if (ifr->ifr_mtu < 72 || ifr->ifr_mtu > 65535)
			return (EINVAL);
		return ((*ifp->if_ioctl)(ifp, cmd, data));

	default:
		if (so->so_proto == 0)
			return (EOPNOTSUPP);
#ifndef COMPAT_43
		return ((*so->so_proto->pr_usrreq)(so, PRU_CONTROL,
			cmd, data, ifp));
#else
	    {
		int ocmd = cmd;
d423 1
a423 1
		switch (cmd) {
d425 3
a427 18
		case SIOCSIFDSTADDR:
		case SIOCSIFADDR:
		case SIOCSIFBRDADDR:
		case SIOCSIFNETMASK:
#if BYTE_ORDER != BIG_ENDIAN
			if (ifr->ifr_addr.sa_family == 0 &&
			    ifr->ifr_addr.sa_len < 16) {
				ifr->ifr_addr.sa_family = ifr->ifr_addr.sa_len;
				ifr->ifr_addr.sa_len = 16;
			}
#ifdef DEBUG
                        Printf("Munged ifr: now len=%d, family=%d\n", ifr->ifr_addr.sa_len, ifr->ifr_addr.sa_family);
#endif
#else
			if (ifr->ifr_addr.sa_len == 0)
				ifr->ifr_addr.sa_len = 16;
#endif
			break;
d429 3
a431 11
		case OSIOCGIFADDR:
			cmd = SIOCGIFADDR;
			break;

		case OSIOCGIFDSTADDR:
			cmd = SIOCGIFDSTADDR;
			break;

		case OSIOCGIFBRDADDR:
			cmd = SIOCGIFBRDADDR;
			break;
d433 2
a434 14
		case OSIOCGIFNETMASK:
			cmd = SIOCGIFNETMASK;
		}
		error =  ((*so->so_proto->pr_usrreq)(so, PRU_CONTROL,
							    cmd, data, ifp));
		switch (ocmd) {

		case OSIOCGIFADDR:
		case OSIOCGIFDSTADDR:
		case OSIOCGIFBRDADDR:
		case OSIOCGIFNETMASK:
			*(u_short *)&ifr->ifr_addr = ifr->ifr_addr.sa_family;
		}
		return (error);
d436 1
a436 4
	    }
#endif
	}
	return (0);
a445 1
int
d453 1
d458 1
d460 4
a463 21
		char workbuf[12], *unitname;
		int unitlen, ifnlen;

#ifdef __riscos
		if (ifp->if_flags & IFF_NODRIVER)
			continue;
#endif

		unitname = sprint_d(ifp->if_unit, workbuf, sizeof workbuf);
		unitlen = strlen(unitname);
		ifnlen = strlen(ifp->if_name);
		if(unitlen + ifnlen + 1 > sizeof ifr.ifr_name) {
			error = ENAMETOOLONG;
		} else {
			strcpy(ifr.ifr_name, ifp->if_name);
			strcpy(&ifr.ifr_name[ifnlen], unitname);
		}

#ifdef DEBUG
                Printf("ifconf: unitname=%s, if_name=%s\n", unitname, ifp->if_name);
#endif
a464 3
#ifdef DEBUG
                        Printf("     no addrlist\n");
#endif
d466 1
a466 2
			error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
			    sizeof (ifr));
d472 2
a473 32
			register struct sockaddr *sa = ifa->ifa_addr;
#ifdef DEBUG
                        Printf("    address=%x %x %x %x\n", ((int *)sa)[0], ((int *)sa)[1],((int *)sa)[2],((int *)sa)[3]);
#endif
#ifdef COMPAT_43
			if (cmd == OSIOCGIFCONF) {
				struct osockaddr *osa =
					 (struct osockaddr *)&ifr.ifr_addr;
				ifr.ifr_addr = *sa;
				osa->sa_family = sa->sa_family;
				error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
						sizeof (ifr));
				ifrp++;
			} else
#endif
			if (sa->sa_len <= sizeof(*sa)) {
				ifr.ifr_addr = *sa;
				error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
						sizeof (ifr));
				ifrp++;
			} else {
				space -= sa->sa_len - sizeof(*sa);
				if (space < sizeof (ifr))
					break;
				error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
						sizeof (ifr.ifr_name));
				if (error == 0)
				    error = copyout((caddr_t)sa,
				      (caddr_t)&ifrp->ifr_addr, sa->sa_len);
				ifrp = (struct ifreq *)
					(sa->sa_len + (caddr_t)&ifrp->ifr_addr);
			}
d476 1
a476 1
			space -= sizeof (ifr);
d483 1
a483 16
static char *
sprint_d(n, buf, buflen)
	u_int n;
	char *buf;
	int buflen;
{
	register char *cp = buf + buflen - 1;

	*cp = 0;
	do {
		cp--;
		*cp = "0123456789"[n % 10];
		n /= 10;
	} while (n != 0);
	return (cp);
}
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d3 1
a3 1
 * $Header: /ax/networking:Internet/net/if.c:networking  1.6  $
a8 17
 * Revision 1.6  95/11/14  12:06:43  pwain
 * Check in for jdavies@@csd
 * 
 * Added setting of AUN_state flag (used to control AUN REVARP behaviour)
 * on receipt of the ioctls SIOCWHOTHEYARE and SIOCGWHOIAMMNS.
 *
 * Revision 1.5  95/10/11  11:42:42  pwain
 * Added support for sioctl to set MTU of a device for PPP driver.
 * 
 * Revision 1.4  95/06/13  14:29:08  kwelton
 * Added support for new SIOCGPCBHEADS ioctl().  This is for the RISC OS
 * port of netstat (the UNIX command).
 * 
 * Revision 1.3  95/06/05  15:26:05  kwelton
 * Added four new ioctl()'s: SIOC[GS]TCP{IDLE,CNT}.  These are new commands
 * for the Internet module, implemented at the request of Online.
 * 
a52 3
extern struct inpcb udb, tcb;
extern int if_set_mtu();

a323 34
#ifdef __riscos
/*
 * the ioctl's in this function were added at the request of
 * OMI, who need the SO_KEEPALIVE feature to kick in after a
 * time interval less than the system standard of 2 hours
 */
static int tcpconf(int cmd, caddr_t data)
{
    extern int tcp_keepidle;
    extern int tcp_keepcnt;

    switch(cmd)
    {
      case SIOCGTCPIDLE:
	*(int *)data = tcp_keepidle / PR_SLOWHZ;
	break;

      case SIOCSTCPIDLE:
	tcp_keepidle = (*(int *)data) * PR_SLOWHZ;
	break;

      case SIOCGTCPCNT:
	*(int *)data = tcp_keepcnt;
	break;

      case SIOCSTCPCNT:
	tcp_keepcnt = *(int *)data;
	break;
    }

    return(0);
}
#endif

a333 19
#ifdef __riscos
	/*
	 * deal with the special TCP control commands
	 * added for the benefit of OMI
	 */
      case SIOCGTCPIDLE:
      case SIOCSTCPIDLE:
      case SIOCGTCPCNT:
      case SIOCSTCPCNT:
	return(tcpconf(cmd, data));

      case SIOCGPCBHEADS:
	/*
	 * return head of UDP and TCP pcb linked lists
	 */
	((struct pcbheads *)data)->pcb_udb = &udb;
	((struct pcbheads *)data)->pcb_tcb = &tcb;
	return(0);
#endif
a360 2
	/* set flag so that we know that a Net module variant is using us */
	AUN_state = AUN_CLIENT;
a395 3

	/* set flag so that we know that a NetG module variant is using us */
	AUN_state = AUN_GATEWAY;
a427 11

/* 950922 PWain
 * SIOCGIFMTU and SIOCSIFMTU added for PPP driver(s).
 */
      case SIOCGIFMTU:
        ifr->ifr_metric = ifp->if_mtu;

      case SIOCSIFMTU:
        return if_set_mtu(ifp, ifr);

/* PWain 950922 */
@


4.1.7.2
log
@RCS log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@d3 1
a3 1
 * $Header: /ax/networking:Internet/net/if.c:networking  1.6  $
a8 17
 * Revision 1.6  95/11/14  12:06:43  pwain
 * Check in for jdavies@@csd
 * 
 * Added setting of AUN_state flag (used to control AUN REVARP behaviour)
 * on receipt of the ioctls SIOCWHOTHEYARE and SIOCGWHOIAMMNS.
 *
 * Revision 1.5  95/10/11  11:42:42  pwain
 * Added support for sioctl to set MTU of a device for PPP driver.
 * 
 * Revision 1.4  95/06/13  14:29:08  kwelton
 * Added support for new SIOCGPCBHEADS ioctl().  This is for the RISC OS
 * port of netstat (the UNIX command).
 * 
 * Revision 1.3  95/06/05  15:26:05  kwelton
 * Added four new ioctl()'s: SIOC[GS]TCP{IDLE,CNT}.  These are new commands
 * for the Internet module, implemented at the request of Online.
 * 
a52 3
extern struct inpcb udb, tcb;
extern int if_set_mtu();

a323 34
#ifdef __riscos
/*
 * the ioctl's in this function were added at the request of
 * OMI, who need the SO_KEEPALIVE feature to kick in after a
 * time interval less than the system standard of 2 hours
 */
static int tcpconf(int cmd, caddr_t data)
{
    extern int tcp_keepidle;
    extern int tcp_keepcnt;

    switch(cmd)
    {
      case SIOCGTCPIDLE:
	*(int *)data = tcp_keepidle / PR_SLOWHZ;
	break;

      case SIOCSTCPIDLE:
	tcp_keepidle = (*(int *)data) * PR_SLOWHZ;
	break;

      case SIOCGTCPCNT:
	*(int *)data = tcp_keepcnt;
	break;

      case SIOCSTCPCNT:
	tcp_keepcnt = *(int *)data;
	break;
    }

    return(0);
}
#endif

a333 19
#ifdef __riscos
	/*
	 * deal with the special TCP control commands
	 * added for the benefit of OMI
	 */
      case SIOCGTCPIDLE:
      case SIOCSTCPIDLE:
      case SIOCGTCPCNT:
      case SIOCSTCPCNT:
	return(tcpconf(cmd, data));

      case SIOCGPCBHEADS:
	/*
	 * return head of UDP and TCP pcb linked lists
	 */
	((struct pcbheads *)data)->pcb_udb = &udb;
	((struct pcbheads *)data)->pcb_tcb = &tcb;
	return(0);
#endif
a360 2
	/* set flag so that we know that a Net module variant is using us */
	AUN_state = AUN_CLIENT;
a395 3

	/* set flag so that we know that a NetG module variant is using us */
	AUN_state = AUN_GATEWAY;
a427 11

/* 950922 PWain
 * SIOCGIFMTU and SIOCSIFMTU added for PPP driver(s).
 */
      case SIOCGIFMTU:
        ifr->ifr_metric = ifp->if_mtu;

      case SIOCSIFMTU:
        return if_set_mtu(ifp, ifr);

/* PWain 950922 */
@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d1 17
d19 2
a20 18
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d22 11
a32 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a33 2
 *	@@(#)if.c	8.3 (Berkeley) 1/4/94
 * $Id: if.c,v 1.15.4.1 1995/07/13 09:10:43 davidg Exp $
a34 1

d37 10
a46 16
#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/protosw.h>
#include <sys/kernel.h>
#include <sys/ioctl.h>
#include <sys/errno.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/radix.h>
#include <ether.h>
d48 2
a49 4
#ifdef __riscos
#include <sys/queue.h>
#include <net/route.h>
#endif
d51 1
a51 5
#include "module.h"
#include "debug.h"

extern struct inpcbhead udb, tcb;
extern int if_set_mtu();
d61 1
a61 1
void
d70 1
a70 1
    if_slowtimo(0);
a87 4
int if_index = 0;
struct ifaddr **ifnet_addrs;
static char *sprint_d(u_int, char *, int);

a91 1
void
a94 3
	unsigned socksize, ifasize;
	int namelen, unitlen, masklen;
	char workbuf[12], *unitname;
a95 5
	register struct sockaddr_dl *sdl;
	register struct ifaddr *ifa;
	static int if_indexlim = 8;


a98 57
	ifp->if_index = ++if_index;
	if (ifnet_addrs == 0 || if_index >= if_indexlim) {
		unsigned n = (if_indexlim <<= 1) * sizeof(ifa);
		struct ifaddr **q = (struct ifaddr **)
					malloc(n, M_IFADDR, M_WAITOK);
		bzero((caddr_t)q, n);
		if (ifnet_addrs) {
			bcopy((caddr_t)ifnet_addrs, (caddr_t)q, n/2);
			free((caddr_t)ifnet_addrs, M_IFADDR);
		}
		ifnet_addrs = q;
	}
	/*
	 * create a Link Level name for this device
	 */
	unitname = sprint_d((u_int)ifp->if_unit, workbuf, sizeof(workbuf));
	namelen = strlen(ifp->if_name);
	unitlen = strlen(unitname);
#define _offsetof(t, m) ((int)((caddr_t)&((t *)0)->m))
	masklen = _offsetof(struct sockaddr_dl, sdl_data[0]) +
			       unitlen + namelen;
	socksize = masklen + ifp->if_addrlen;
#define ROUNDUP(a) (1 + (((a) - 1) | (sizeof(long) - 1)))
	socksize = ROUNDUP(socksize);
	if (socksize < sizeof(*sdl))
		socksize = sizeof(*sdl);
	ifasize = sizeof(*ifa) + 2 * socksize;
	ifa = (struct ifaddr *)malloc(ifasize, M_IFADDR, M_WAITOK);
	if (ifa) {
		bzero((caddr_t)ifa, ifasize);
		sdl = (struct sockaddr_dl *)(ifa + 1);
		sdl->sdl_len = socksize;
		sdl->sdl_family = AF_LINK;
		bcopy(ifp->if_name, sdl->sdl_data, namelen);
		bcopy(unitname, namelen + (caddr_t)sdl->sdl_data, unitlen);
		sdl->sdl_nlen = (namelen += unitlen);
		sdl->sdl_index = ifp->if_index;
		sdl->sdl_type = ifp->if_type;
		ifnet_addrs[if_index - 1] = ifa;
		ifa->ifa_ifp = ifp;
		ifa->ifa_next = ifp->if_addrlist;
		ifa->ifa_rtrequest = link_rtrequest;
		ifp->if_addrlist = ifa;
		ifa->ifa_addr = (struct sockaddr *)sdl;
		sdl = (struct sockaddr_dl *)(socksize + (caddr_t)sdl);
		ifa->ifa_netmask = (struct sockaddr *)sdl;
		sdl->sdl_len = masklen;
		while (namelen != 0)
			sdl->sdl_data[--namelen] = 0xff;
	}
#ifndef __riscos
	/* XXX -- Temporary fix before changing 10 ethernet drivers */
#if NETHER > 0
	if (ifp->if_output == ether_output)
		ether_ifattach(ifp);
#endif
#endif
d112 2
a113 2
#define	equal(a1, a2) \
  (bcmp((caddr_t)(a1), (caddr_t)(a2), ((struct sockaddr *)(a1))->sa_len) == 0)
d116 1
a116 1
		if (ifa->ifa_addr->sa_family != addr->sa_family)
d118 1
a118 1
		if (equal(addr, ifa->ifa_addr))
d120 2
a121 2
		if ((ifp->if_flags & IFF_BROADCAST) && ifa->ifa_broadaddr &&
		    equal(ifa->ifa_broadaddr, addr))
d140 1
a140 1
			if (ifa->ifa_addr->sa_family != addr->sa_family)
d142 1
a142 1
			if (ifa->ifa_dstaddr && equal(addr, ifa->ifa_dstaddr))
d150 1
a150 1
 * is most specific found.
d154 1
a154 1
	struct sockaddr *addr;
d158 2
a159 12
	struct ifaddr *ifa_maybe = (struct ifaddr *) 0;
	u_int af = addr->sa_family;
	char *addr_data = addr->sa_data, *cplim;

	if (af == AF_LINK) {
	    register struct sockaddr_dl *sdl = (struct sockaddr_dl *)addr;
	    if (sdl->sdl_index && sdl->sdl_index <= if_index)
		return (ifnet_addrs[sdl->sdl_index - 1]);
	}
	for (ifp = ifnet; ifp; ifp = ifp->if_next) {
		for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next) {
			register char *cp, *cp2, *cp3;
d161 9
a169 21
			if (ifa->ifa_addr->sa_family != af)
				next: continue;
			if (ifp->if_flags & IFF_POINTOPOINT) {
				if (equal(addr, ifa->ifa_dstaddr))
 					return (ifa);
			} else {
				if (ifa->ifa_netmask == 0)
					continue;
				cp = addr_data;
				cp2 = ifa->ifa_addr->sa_data;
				cp3 = ifa->ifa_netmask->sa_data;
				cplim = ifa->ifa_netmask->sa_len + (char *)ifa->ifa_netmask;
				while (cp3 < cplim)
					if ((*cp++ ^ *cp2++) & *cp3++)
						goto next;
				if (ifa_maybe == 0 ||
				    rn_refines((caddr_t)ifa->ifa_netmask,
				    (caddr_t)ifa_maybe->ifa_netmask))
					ifa_maybe = ifa;
			}
		}
d171 1
a171 1
	return (ifa_maybe);
d174 1
d187 1
a187 1
		if (ifa->ifa_addr->sa_family == af)
d191 1
a191 75

/*
 * Find an interface address specific to an interface best matching
 * a given address.
 */
struct ifaddr *
ifaof_ifpforaddr(addr, ifp)
	struct sockaddr *addr;
	register struct ifnet *ifp;
{
	register struct ifaddr *ifa;
	register char *cp, *cp2, *cp3;
	register char *cplim;
	struct ifaddr *ifa_maybe = 0;
	u_int af = addr->sa_family;

	if (af >= AF_MAX)
		return (0);
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr->sa_family != af)
			continue;
		ifa_maybe = ifa;
		if (ifa->ifa_netmask == 0) {
			if (equal(addr, ifa->ifa_addr) ||
			    (ifa->ifa_dstaddr && equal(addr, ifa->ifa_dstaddr)))
				return (ifa);
			continue;
		}
		if (ifp->if_flags & IFF_POINTOPOINT) {
			if (equal(addr, ifa->ifa_dstaddr))
				return (ifa);
		} else {
			cp = addr->sa_data;
			cp2 = ifa->ifa_addr->sa_data;
			cp3 = ifa->ifa_netmask->sa_data;
			cplim = ifa->ifa_netmask->sa_len + (char *)ifa->ifa_netmask;
			for (; cp3 < cplim; cp3++)
				if ((*cp++ ^ *cp2++) & *cp3)
					break;
			if (cp3 == cplim)
				return (ifa);
		}
	}
	return (ifa_maybe);
}

#include <net/route.h>

/*
 * Default action when installing a route with a Link Level gateway.
 * Lookup an appropriate real ifa to point to.
 * This should be moved to /sys/net/link.c eventually.
 */
void
link_rtrequest(cmd, rt, sa)
	int cmd;
	register struct rtentry *rt;
	struct sockaddr *sa;
{
	register struct ifaddr *ifa;
	struct sockaddr *dst;
	struct ifnet *ifp;

	if (cmd != RTM_ADD || ((ifa = rt->rt_ifa) == 0) ||
	    ((ifp = ifa->ifa_ifp) == 0) || ((dst = rt_key(rt)) == 0))
		return;
	ifa = ifaof_ifpforaddr(dst, ifp);
	if (ifa) {
		IFAFREE(rt->rt_ifa);
		rt->rt_ifa = ifa;
		ifa->ifa_refcnt++;
		if (ifa->ifa_rtrequest && ifa->ifa_rtrequest != link_rtrequest)
			ifa->ifa_rtrequest(cmd, rt, sa);
	}
}
a197 1
void
d205 1
a205 1
		pfctlinput(PRC_IFDOWN, ifa->ifa_addr);
a206 21
	rt_ifmsg(ifp);
}

/*
 * Mark an interface up and notify protocols of
 * the transition.
 * NOTE: must be called at splnet or eqivalent.
 */
void
if_up(ifp)
	register struct ifnet *ifp;
{

	ifp->if_flags |= IFF_UP;
#ifdef notyet
	register struct ifaddr *ifa;
	/* this has no effect on IP, and will kill all iso connections XXX */
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
		pfctlinput(PRC_IFUP, ifa->ifa_addr);
#endif
	rt_ifmsg(ifp);
a211 1
void
d218 1
a218 1
	while ((m = n) != 0) {
d220 1
d222 3
d236 1
a236 3
void
if_slowtimo(arg)
	void *arg;
d246 6
a251 1
	timeout(if_slowtimo, (void *)0, hz / IFNET_SLOWHZ);
d258 1
a258 3
struct ifnet *
ifunit(name)
	register char *name;
d260 37
a296 11
	register char *cp;
	register struct ifnet *ifp;
	int unit;
	unsigned len;
	char *ep, c;

	for (cp = name; cp < name + IFNAMSIZ && *cp; cp++)
		if (*cp >= '0' && *cp <= '9')
			break;
	if (*cp == '\0' || cp == name + IFNAMSIZ)
		return ((struct ifnet *)0);
d298 3
a300 3
	 * Save first char of unit, and pointer to it,
	 * so we can put a null there to avoid matching
	 * initial substrings of interface names.
d302 3
a304 36
	len = cp - name + 1;
	c = *cp;
	ep = cp;
	for (unit = 0; *cp >= '0' && *cp <= '9'; )
		unit = unit * 10 + *cp++ - '0';
	*ep = 0;
	for (ifp = ifnet; ifp; ifp = ifp->if_next) {
		if (bcmp(ifp->if_name, name, len))
			continue;
#ifdef __riscos
		/*
		 * it *is* possible for a network driver to
		 * disappear, so check that this has not
		 * happened.
		 */
		if( unit == ifp->if_unit && !(ifp->if_flags & IFF_NODRIVER) )
	    		break;
#else
		if (unit == ifp->if_unit)
			break;
#endif
	}
	*ep = c;
	return (ifp);
}

#ifdef __riscos
/*
 * the ioctl's in this function were added at the request of
 * OMI, who need the SO_KEEPALIVE feature to kick in after a
 * time interval less than the system standard of 2 hours
 */
static int tcpconf(int cmd, caddr_t data)
{
    extern int tcp_keepidle;
    extern int tcp_keepcnt;
d306 5
a310 1
    switch(cmd)
d312 5
a316 15
      case SIOCGTCPIDLE:
	*(int *)data = tcp_keepidle / PR_SLOWHZ;
	break;

      case SIOCSTCPIDLE:
	tcp_keepidle = (*(int *)data) * PR_SLOWHZ;
	break;

      case SIOCGTCPCNT:
	*(int *)data = tcp_keepcnt;
	break;

      case SIOCSTCPCNT:
	tcp_keepcnt = *(int *)data;
	break;
d318 1
d320 2
a321 1
    return(0);
a322 1
#endif
d327 1
a327 5
int
ifioctl(so, cmd, data)
    struct socket *so;
    int cmd;
    caddr_t data;
a330 1
    int error;
d334 9
d344 2
a345 9
	/*
	 * deal with the special TCP control commands
	 * added for the benefit of OMI
	 */
      case SIOCGTCPIDLE:
      case SIOCSTCPIDLE:
      case SIOCGTCPCNT:
      case SIOCSTCPCNT:
	return(tcpconf(cmd, data));
d347 2
a348 20
#if 0
      case SIOCGPCBHEADS:
	/*
	 * return head of UDP and TCP pcb linked lists
	 */
	((struct pcbheads *)data)->pcb_udb = udb.lh_first;
	((struct pcbheads *)data)->pcb_tcb = tcb.lh_first;
	return(0);

      case SIOCGPRSTATS:
        /*
         * return per-protocol statistics that used to be provided by
         * *InetInfo p
         */
        ((struct prstats *)data)->ipstat = &ipstat;
        ((struct prstats *)data)->icmpstat = &icmpstat;
        ((struct prstats *)data)->tcpstat = &tcpstat;
        ((struct prstats *)data)->udpstat = &udpstat;
        return 0;
#endif
d350 1
a351 4
      case SIOCGIFCONF:
      case OSIOCGIFCONF:
	return (ifconf(cmd, data));
    }
a360 2
	/* set flag so that we know that a Net module variant is using us */
	AUN_state = AUN_CLIENT;
a395 3

	/* set flag so that we know that a NetG module variant is using us */
	AUN_state = AUN_GATEWAY;
d401 3
a403 46
	case SIOCGIFFLAGS:
		ifr->ifr_flags = ifp->if_flags;
		break;

	case SIOCGIFMETRIC:
		ifr->ifr_metric = ifp->if_metric;
		break;

	case SIOCGIFMTU:
		ifr->ifr_mtu = ifp->if_mtu;
		break;

 	case SIOCGIFPHYS:
		ifr->ifr_phys = ifp->if_physical;
		break;

	case SIOCSIFFLAGS:
#ifndef __riscos
		error = suser(p->p_ucred, &p->p_acflag);
		if (error)
			return (error);
#endif
		if (ifp->if_flags & IFF_UP && (ifr->ifr_flags & IFF_UP) == 0) {
			int s = splimp();
			if_down(ifp);
			splx(s);
		}
		if (ifr->ifr_flags & IFF_UP && (ifp->if_flags & IFF_UP) == 0) {
			int s = splimp();
			if_up(ifp);
			splx(s);
		}
		ifp->if_flags = (ifp->if_flags & IFF_CANTCHANGE) |
			(ifr->ifr_flags & ~IFF_CANTCHANGE);
		if (ifp->if_ioctl)
			(void) (*ifp->if_ioctl)(ifp, cmd, data);
		break;

	case SIOCSIFMETRIC:
#ifndef __riscos
		error = suser(p->p_ucred, &p->p_acflag);
		if (error)
			return (error);
#endif
		ifp->if_metric = ifr->ifr_metric;
		break;
d405 3
a407 5
	case SIOCSIFPHYS:
#ifndef __riscos
		error = suser(p->p_ucred, &p->p_acflag);
		if (error) return error;
#endif
d409 7
a415 2
		if (!ifp->if_ioctl) return EOPNOTSUPP;
		return ifp->if_ioctl(ifp, cmd, data);
d417 2
a418 25
	case SIOCSIFMTU:
#ifndef __riscos
		error = suser(p->p_ucred, &p->p_acflag);
		if (error)
			return (error);
#endif
		if (ifp->if_ioctl == NULL)
			return (EOPNOTSUPP);
		/*
		 * 72 was chosen below because it is the size of a TCP/IP
		 * header (40) + the minimum mss (32).
		 */
		if (ifr->ifr_mtu < 72 || ifr->ifr_mtu > 65535)
			return (EINVAL);
		return ((*ifp->if_ioctl)(ifp, cmd, data));

	default:
		if (so->so_proto == 0)
			return (EOPNOTSUPP);
#ifndef COMPAT_43
		return ((*so->so_proto->pr_usrreq)(so, PRU_CONTROL,
			cmd, data, ifp));
#else
	    {
		int ocmd = cmd;
d420 2
a421 1
		switch (cmd) {
d423 5
a427 18
		case SIOCSIFDSTADDR:
		case SIOCSIFADDR:
		case SIOCSIFBRDADDR:
		case SIOCSIFNETMASK:
#if BYTE_ORDER != BIG_ENDIAN
			if (ifr->ifr_addr.sa_family == 0 &&
			    ifr->ifr_addr.sa_len < 16) {
				ifr->ifr_addr.sa_family = ifr->ifr_addr.sa_len;
				ifr->ifr_addr.sa_len = 16;
			}
#ifdef DEBUG
                        Printf("Munged ifr: now len=%d, family=%d\n", ifr->ifr_addr.sa_len, ifr->ifr_addr.sa_family);
#endif
#else
			if (ifr->ifr_addr.sa_len == 0)
				ifr->ifr_addr.sa_len = 16;
#endif
			break;
d429 3
a431 11
		case OSIOCGIFADDR:
			cmd = SIOCGIFADDR;
			break;

		case OSIOCGIFDSTADDR:
			cmd = SIOCGIFDSTADDR;
			break;

		case OSIOCGIFBRDADDR:
			cmd = SIOCGIFBRDADDR;
			break;
d433 2
a434 14
		case OSIOCGIFNETMASK:
			cmd = SIOCGIFNETMASK;
		}
		error =  ((*so->so_proto->pr_usrreq)(so, PRU_CONTROL,
							    cmd, data, ifp));
		switch (ocmd) {

		case OSIOCGIFADDR:
		case OSIOCGIFDSTADDR:
		case OSIOCGIFBRDADDR:
		case OSIOCGIFNETMASK:
			*(u_short *)&ifr->ifr_addr = ifr->ifr_addr.sa_family;
		}
		return (error);
d436 1
a436 4
	    }
#endif
	}
	return (0);
a445 1
int
d453 1
d458 1
d460 4
a463 16
		char workbuf[12], *unitname;
		int unitlen, ifnlen;

		unitname = sprint_d(ifp->if_unit, workbuf, sizeof workbuf);
		unitlen = strlen(unitname);
		ifnlen = strlen(ifp->if_name);
		if(unitlen + ifnlen + 1 > sizeof ifr.ifr_name) {
			error = ENAMETOOLONG;
		} else {
			strcpy(ifr.ifr_name, ifp->if_name);
			strcpy(&ifr.ifr_name[ifnlen], unitname);
		}

#ifdef DEBUG
                Printf("ifconf: unitname=%s, if_name=%s\n", unitname, ifp->if_name);
#endif
a464 3
#ifdef DEBUG
                        Printf("     no addrlist\n");
#endif
d466 1
a466 2
			error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
			    sizeof (ifr));
d472 2
a473 32
			register struct sockaddr *sa = ifa->ifa_addr;
#ifdef DEBUG
                        Printf("    address=%x %x %x %x\n", ((int *)sa)[0], ((int *)sa)[1],((int *)sa)[2],((int *)sa)[3]);
#endif
#ifdef COMPAT_43
			if (cmd == OSIOCGIFCONF) {
				struct osockaddr *osa =
					 (struct osockaddr *)&ifr.ifr_addr;
				ifr.ifr_addr = *sa;
				osa->sa_family = sa->sa_family;
				error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
						sizeof (ifr));
				ifrp++;
			} else
#endif
			if (sa->sa_len <= sizeof(*sa)) {
				ifr.ifr_addr = *sa;
				error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
						sizeof (ifr));
				ifrp++;
			} else {
				space -= sa->sa_len - sizeof(*sa);
				if (space < sizeof (ifr))
					break;
				error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
						sizeof (ifr.ifr_name));
				if (error == 0)
				    error = copyout((caddr_t)sa,
				      (caddr_t)&ifrp->ifr_addr, sa->sa_len);
				ifrp = (struct ifreq *)
					(sa->sa_len + (caddr_t)&ifrp->ifr_addr);
			}
d476 1
a476 1
			space -= sizeof (ifr);
d483 1
a483 16
static char *
sprint_d(n, buf, buflen)
	u_int n;
	char *buf;
	int buflen;
{
	register char *cp = buf + buflen - 1;

	*cp = 0;
	do {
		cp--;
		*cp = "0123456789"[n % 10];
		n /= 10;
	} while (n != 0);
	return (cp);
}
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@

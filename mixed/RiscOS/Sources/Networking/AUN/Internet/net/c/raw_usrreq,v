head	4.2;
access;
symbols
	Internet-5_65:4.2
	Internet-5_64:4.2
	Internet-5_63:4.2
	Internet-5_62:4.2
	Internet-5_61:4.2
	Internet-5_60:4.2
	Internet-5_59:4.2
	Internet-5_58:4.2
	Internet-5_57:4.2
	Internet-5_56:4.2
	Internet-5_55:4.2
	Internet-5_54:4.2
	Internet-5_53:4.2
	Internet-5_52:4.2
	Internet-5_51:4.2
	Internet-5_50:4.2
	RO_5_07:4.2
	Internet-5_49:4.2
	Internet-5_48:4.2
	Internet-5_47:4.2
	Internet-5_46:4.2
	Internet-5_45:4.2
	Internet-5_44:4.2
	Internet-5_43:4.2
	Internet-5_42:4.2
	Internet-5_41:4.2
	Internet-5_40:4.2
	Internet-5_39:4.2
	Internet-5_38:4.2
	Internet-5_37:4.2
	Internet-5_36:4.2
	Internet-5_35:4.2
	Internet-5_34:4.2
	Internet-5_33:4.2
	Internet-5_32:4.2
	Internet-5_31:4.2
	Internet-5_30:4.2
	Internet-5_29:4.2
	Internet-5_27:4.2
	Internet-5_26:4.2
	Internet-5_25:4.2
	Internet-5_24:4.2
	Internet-5_23:4.2
	Internet-5_22:4.2
	Internet-5_21:4.2
	Internet-5_20:4.2
	Internet-5_19:4.2
	Internet-5_18:4.2
	Internet-5_17:4.2
	Internet-5_16:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Internet-5_15:4.2
	Internet-5_14:4.2
	Internet-5_13:4.2
	sforrest_daytona_appflash-0_31:4.2
	Internet-5_12:4.2
	Internet-5_11:4.2
	celkins_Internet-5_10:4.2
	nicke_Internat_25-9-98:4.2
	Internet-5_09:4.2
	blaughto_daytona_appflash-0_30:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rwarren_Internet-5_08:4.2
	Spinner:4.2
	Internet_5_07:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.2
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.2
date	97.05.12.22.58.36;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.06;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.06;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.19.51;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.27.32;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.06.34;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.10;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.06.27;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.23;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.38.13;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.14;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.2
log
@Version Spinner_B7 taken
@
text
@/*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/errno.h>

#include <net/if.h>
#include <net/route.h>
#include <net/netisr.h>
#include <net/raw_cb.h>

#include <string.h>

#include "module.h"

/*
 * Initialize raw connection block q.
 */
void
raw_init()
{
	rawcb.rcb_next = rawcb.rcb_prev = &rawcb;
}

/*
 * Raw protocol input routine.  Find the socket
 * associated with the packet(s) and move them over.  If
 * nothing exists for this packet, drop it.
 */
/*
 * Raw protocol interface.
 */
void
raw_input(m0, proto, src, dst)
	struct mbuf *m0;
	register struct sockproto *proto;
	struct sockaddr *src, *dst;
{
	register struct rawcb *rp;
	register struct mbuf *m = m0;
	register int sockets = 0;
	struct socket *last;

	last = 0;
	for (rp = rawcb.rcb_next; rp != &rawcb; rp = rp->rcb_next) {
		if (rp->rcb_proto.sp_family != proto->sp_family)
			continue;
		if (rp->rcb_proto.sp_protocol  &&
		    rp->rcb_proto.sp_protocol != proto->sp_protocol)
			continue;
		/*
		 * We assume the lower level routines have
		 * placed the address in a canonical format
		 * suitable for a structure comparison.
		 *
		 * Note that if the lengths are not the same
		 * the comparison will fail at the first byte.
		 */
#define	equal(a1, a2) \
  (bcmp((caddr_t)(a1), (caddr_t)(a2), a1->sa_len) == 0)
		if (rp->rcb_laddr && !equal(rp->rcb_laddr, dst))
			continue;
		if (rp->rcb_faddr && !equal(rp->rcb_faddr, src))
			continue;
		if (last) {
			struct mbuf *n;
			n = m_copy(m, 0, (int)M_COPYALL);
			if (n) {
				if (sbappendaddr(&last->so_rcv, src,
				    n, (struct mbuf *)0) == 0)
					/* should notify about lost packet */
					m_freem(n);
				else {
					sorwakeup(last);
					sockets++;
				}
			}
		}
		last = rp->rcb_socket;
	}
	if (last) {
		if (sbappendaddr(&last->so_rcv, src,
		    m, (struct mbuf *)0) == 0)
			m_freem(m);
		else {
			sorwakeup(last);
			sockets++;
		}
	} else
		m_freem(m);
}


/*ARGSUSED*/
void
raw_ctlinput(cmd, arg)
	int cmd;
	struct sockaddr *arg;
{

	if (cmd < 0 || cmd > PRC_NCMDS)
		return;
	/* INCOMPLETE */
}

/*ARGSUSED*/
int
raw_usrreq(so, req, m, nam, control)
	struct socket *so;
	int req;
	struct mbuf *m, *nam, *control;
{
	register struct rawcb *rp = sotorawcb(so);
	register int error = 0;
	int len;

	if (req == PRU_CONTROL)
		return (EOPNOTSUPP);
	if (control && control->m_len) {
		error = EOPNOTSUPP;
		goto release;
	}
	if (rp == 0) {
		error = EINVAL;
		goto release;
	}
	switch (req) {

	/*
	 * Allocate a raw control block and fill in the
	 * necessary info to allow packets to be routed to
	 * the appropriate raw interface routine.
	 */
	case PRU_ATTACH:
		if ((so->so_state & SS_PRIV) == 0) {
			error = EACCES;
			break;
		}
		error = raw_attach(so, (int)nam);
		break;

	/*
	 * Destroy state just before socket deallocation.
	 * Flush data or not depending on the options.
	 */
	case PRU_DETACH:
		if (rp == 0) {
			error = ENOTCONN;
			break;
		}
		raw_detach(rp);
		break;

	/*
	 * If a socket isn't bound to a single address,
	 * the raw input routine will hand it anything
	 * within that protocol family (assuming there's
	 * nothing else around it should go to).
	 */
	case PRU_CONNECT:
		error = EINVAL;
#if 0
		if (rp->rcb_faddr) {
			error = EISCONN;
			break;
		}
		nam = m_copym(nam, 0, M_COPYALL, M_WAIT);
		rp->rcb_faddr = mtod(nam, struct sockaddr *);
		soisconnected(so);
#endif
		break;

	case PRU_BIND:
		error = EINVAL;
#if 0
		if (rp->rcb_laddr) {
			error = EINVAL;			/* XXX */
			break;
		}
		error = raw_bind(so, nam);
#endif
		break;

	case PRU_CONNECT2:
		error = EOPNOTSUPP;
		goto release;

	case PRU_DISCONNECT:
		if (rp->rcb_faddr == 0) {
			error = ENOTCONN;
			break;
		}
		raw_disconnect(rp);
		soisdisconnected(so);
		break;

	/*
	 * Mark the connection as being incapable of further input.
	 */
	case PRU_SHUTDOWN:
		socantsendmore(so);
		break;

	/*
	 * Ship a packet out.  The appropriate raw output
	 * routine handles any massaging necessary.
	 */
	case PRU_SEND:
		if (nam) {
			if (rp->rcb_faddr) {
				error = EISCONN;
				break;
			}
			rp->rcb_faddr = mtod(nam, struct sockaddr *);
		} else if (rp->rcb_faddr == 0) {
			error = ENOTCONN;
			break;
		}
		/* TRACE */
#ifdef DEBUGSEND
		Printf("raw_usrreq: PRU_SEND, m = %x\n", m);
#endif
		error = (*so->so_proto->pr_output)(m, so);
		m = NULL;
		if (nam)
			rp->rcb_faddr = 0;
		break;

	case PRU_ABORT:
		raw_disconnect(rp);
		sofree(so);
		soisdisconnected(so);
		break;

	case PRU_SENSE:
		/*
		 * stat: don't bother with a blocksize.
		 */
		return (0);

	/*
	 * Not supported.
	 */
	case PRU_RCVOOB:
	case PRU_RCVD:
		return(EOPNOTSUPP);

	case PRU_LISTEN:
	case PRU_ACCEPT:
	case PRU_SENDOOB:
		error = EOPNOTSUPP;
		break;

	case PRU_SOCKADDR:
		if (rp->rcb_laddr == 0) {
			error = EINVAL;
			break;
		}
		len = rp->rcb_laddr->sa_len;
		bcopy((caddr_t)rp->rcb_laddr, mtod(nam, caddr_t), (unsigned)len);
		nam->m_len = len;
		break;

	case PRU_PEERADDR:
		if (rp->rcb_faddr == 0) {
			error = ENOTCONN;
			break;
		}
		len = rp->rcb_faddr->sa_len;
		bcopy((caddr_t)rp->rcb_faddr, mtod(nam, caddr_t), (unsigned)len);
		nam->m_len = len;
		break;

	default:
		panic("raw_usrreq");
	}
release:
	if (m != NULL)
		m_freem(m);
	return (error);
}
@


4.1
log
@Initial revision
@
text
@d1 3
a3 1
/* -*-C-*-
d5 15
a19 2
 * $Header: /ax/networking:Internet/net/raw_usrreq.c:networking  1.2  $
 * $Source: /ax/networking:Internet/net/raw_usrreq.c: $
d21 11
a31 26
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
 *
 * $Log:	raw_usrreq.c,v $
 * Revision 1.2  95/01/24  15:23:03  kwelton
 * The header file "machine/mtpr.h" no longer exists, therefore it is
 * no longer included by this file.
 * 
 * Revision 1.1  94/12/02  11:02:31  kwelton
 * Initial revision
 * 
 */
/*
 * Copyright (c) 1983, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d35 17
a51 12
#include "sys/param.h"
#include "sys/mbuf.h"
#include "sys/domain.h"
#include "sys/protosw.h"
#include "sys/socket.h"
#include "sys/socketvar.h"
#include "sys/errno.h"

#include "net/if.h"
#include "net/route.h"
#include "net/netisr.h"
#include "net/raw_cb.h"
d56 1
a59 1
	rawintrq.ifq_maxlen = IFQ_MAXLEN;
d63 5
d70 1
d73 1
a73 1
	struct sockproto *proto;
a75 64
	register struct mbuf *m;
	struct raw_header *rh;
	int s;

	/*
	 * Rip off an mbuf for a generic header.
	 */
#ifdef OldCode
	m = m_get(M_DONTWAIT, MT_HEADER);
	if (m == 0) {
		m_freem(m0);
		return;
	}
#else
	if( (m = ALLOC_S(MINCONTIG, NULL)) == NULL )
	{
#ifdef DEBUG
	    if( DODEBUG(DBGMMAN) )
		Printf("raw_input: ALLOC_S failed\n");
#endif
	    FREEM(m0);
	    return;
	}
	m->m_type = MT_HEADER;
#endif

	m->m_next = m0;
	m->m_len = sizeof(struct raw_header);
	rh = mtod(m, struct raw_header *);
	rh->raw_dst = *dst;
	rh->raw_src = *src;
	rh->raw_proto = *proto;

	/*
	 * Header now contains enough info to decide
	 * which socket to place packet in (if any).
	 * Queue it up for the raw protocol process
	 * running at software interrupt level.
	 */
	s = splimp();
	if (IF_QFULL(&rawintrq))
	{
#ifdef OldCode
	    m_freem(m);
#else
	    FREEM(m);
#endif
	}
	else
		IF_ENQUEUE(&rawintrq, m);
	splx(s);
	schednetisr(NETISR_RAW);
}

/*
 * Raw protocol input routine.	Process packets entered
 * into the queue at interrupt time.  Find the socket
 * associated with the packet(s) and move them over.  If
 * nothing exists for this packet, drop it.
 */
rawintr()
{
	int s;
	struct mbuf *m;
d77 2
a78 1
	register struct raw_header *rh;
a80 7
next:
	s = splimp();
	IF_DEQUEUE(&rawintrq, m);
	splx(s);
	if (m == 0)
		return;
	rh = mtod(m, struct raw_header *);
d83 1
a83 1
		if (rp->rcb_proto.sp_family != rh->raw_proto.sp_family)
d86 1
a86 1
		    rp->rcb_proto.sp_protocol != rh->raw_proto.sp_protocol)
d92 3
d96 3
a98 4
#define equal(a1, a2) \
	(bcmp((caddr_t)&(a1), (caddr_t)&(a2), sizeof (struct sockaddr)) == 0)
		if ((rp->rcb_flags & RAW_LADDR) &&
		    !equal(rp->rcb_laddr, rh->raw_dst))
d100 1
a100 2
		if ((rp->rcb_flags & RAW_FADDR) &&
		    !equal(rp->rcb_faddr, rh->raw_src))
d104 10
a113 18
#ifdef OldCode
			if (n = m_copy(m->m_next, 0, (int)M_COPYALL)) {
				if (sbappendaddr(&last->so_rcv, &rh->raw_src,
						 n, (struct mbuf *)0) == 0)
				    /* should notify about lost packet */
				    m_freem(n);
				else
				    sorwakeup(last);
			    }
#else
			if( (n = COPY_P(m->m_next, 0, M_COPYALL)) != NULL )
			{
			    if (sbappendaddr(&last->so_rcv, &rh->raw_src,
					     n, (struct mbuf *)0) == 0)
				/* should notify about lost packet */
				FREEM(n);
			    else
				sorwakeup(last);
a114 1
#endif
d119 6
a124 8
		if (sbappendaddr(&last->so_rcv, &rh->raw_src,
				 m->m_next, (struct mbuf *)0) == 0)
		{
#ifdef OldCode
		    m_freem(m->m_next);
#else
		    FREEM(m->m_next);
#endif
a125 7
		else
			sorwakeup(last);
#ifdef OldCode
		(void) m_free(m);		/* header */
#else
		FREE(m);
#endif
d127 1
a127 8
	{
#ifdef OldCode
	    m_freem(m);
#else
	    FREEM(m);
#endif
	}
	goto next;
d130 1
d132 1
d144 2
a145 1
raw_usrreq(so, req, m, nam, rights)
d148 1
a148 1
	struct mbuf *m, *nam, *rights;
d152 1
d156 1
a156 1
	if (rights && rights->m_len) {
d160 1
a160 1
	if (rp == 0 && req != PRU_ATTACH) {
a175 4
		if (rp) {
			error = EINVAL;
			break;
		}
d198 3
a200 1
		if (rp->rcb_flags & RAW_FADDR) {
d204 2
a205 1
		raw_connaddr(rp, nam);
d207 1
a209 4
	case PRU_CONNECT2:
		error = EOPNOTSUPP;
		goto release;

d211 3
a213 1
		if (rp->rcb_flags & RAW_LADDR) {
d218 1
d221 4
d226 1
a226 1
		if ((rp->rcb_flags & RAW_FADDR) == 0) {
d247 1
a247 1
			if (rp->rcb_flags & RAW_FADDR) {
d251 2
a252 2
			raw_connaddr(rp, nam);
		} else if ((rp->rcb_flags & RAW_FADDR) == 0) {
d263 1
a263 1
			rp->rcb_flags &= ~RAW_FADDR;
d292 7
a298 3
		bcopy((caddr_t)&rp->rcb_laddr, mtod(nam, caddr_t),
		    sizeof (struct sockaddr));
		nam->m_len = sizeof (struct sockaddr);
d302 7
a308 3
		bcopy((caddr_t)&rp->rcb_faddr, mtod(nam, caddr_t),
		    sizeof (struct sockaddr));
		nam->m_len = sizeof (struct sockaddr);
d316 1
a316 7
	{
#ifdef OldCode
	    m_freem(m);
#else
	    FREEM(m);
#endif
	}
a318 2

/* EOf raw_usrreq.c */
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d1 16
d18 2
a19 18
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d35 12
a46 17
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/errno.h>

#include <net/if.h>
#include <net/route.h>
#include <net/netisr.h>
#include <net/raw_cb.h>

#include <string.h>

#include "module.h"
a50 1
void
d54 1
a57 5
 * Raw protocol input routine.  Find the socket
 * associated with the packet(s) and move them over.  If
 * nothing exists for this packet, drop it.
 */
/*
a59 1
void
d62 1
a62 1
	register struct sockproto *proto;
d65 64
d130 1
a130 2
	register struct mbuf *m = m0;
	register int sockets = 0;
d133 7
d142 1
a142 1
		if (rp->rcb_proto.sp_family != proto->sp_family)
d145 1
a145 1
		    rp->rcb_proto.sp_protocol != proto->sp_protocol)
a150 3
		 *
		 * Note that if the lengths are not the same
		 * the comparison will fail at the first byte.
d152 4
a155 3
#define	equal(a1, a2) \
  (bcmp((caddr_t)(a1), (caddr_t)(a2), a1->sa_len) == 0)
		if (rp->rcb_laddr && !equal(rp->rcb_laddr, dst))
d157 2
a158 1
		if (rp->rcb_faddr && !equal(rp->rcb_faddr, src))
d162 18
a179 10
			n = m_copy(m, 0, (int)M_COPYALL);
			if (n) {
				if (sbappendaddr(&last->so_rcv, src,
				    n, (struct mbuf *)0) == 0)
					/* should notify about lost packet */
					m_freem(n);
				else {
					sorwakeup(last);
					sockets++;
				}
d181 1
d186 10
a195 4
		if (sbappendaddr(&last->so_rcv, src,
		    m, (struct mbuf *)0) == 0)
			m_freem(m);
		else {
d197 5
a201 2
			sockets++;
		}
d203 8
a210 1
		m_freem(m);
a212 1

a213 1
void
d225 1
a225 2
int
raw_usrreq(so, req, m, nam, control)
d228 1
a228 1
	struct mbuf *m, *nam, *control;
a231 1
	int len;
d235 1
a235 1
	if (control && control->m_len) {
d239 1
a239 1
	if (rp == 0) {
d255 4
d281 1
a281 3
		error = EINVAL;
#if 0
		if (rp->rcb_faddr) {
d285 1
a285 2
		nam = m_copym(nam, 0, M_COPYALL, M_WAIT);
		rp->rcb_faddr = mtod(nam, struct sockaddr *);
a286 1
#endif
d289 4
d294 1
a294 3
		error = EINVAL;
#if 0
		if (rp->rcb_laddr) {
a298 1
#endif
a300 4
	case PRU_CONNECT2:
		error = EOPNOTSUPP;
		goto release;

d302 1
a302 1
		if (rp->rcb_faddr == 0) {
d323 1
a323 1
			if (rp->rcb_faddr) {
d327 2
a328 2
			rp->rcb_faddr = mtod(nam, struct sockaddr *);
		} else if (rp->rcb_faddr == 0) {
d339 1
a339 1
			rp->rcb_faddr = 0;
d368 3
a370 7
		if (rp->rcb_laddr == 0) {
			error = EINVAL;
			break;
		}
		len = rp->rcb_laddr->sa_len;
		bcopy((caddr_t)rp->rcb_laddr, mtod(nam, caddr_t), (unsigned)len);
		nam->m_len = len;
d374 3
a376 7
		if (rp->rcb_faddr == 0) {
			error = ENOTCONN;
			break;
		}
		len = rp->rcb_faddr->sa_len;
		bcopy((caddr_t)rp->rcb_faddr, mtod(nam, caddr_t), (unsigned)len);
		nam->m_len = len;
d384 7
a390 1
		m_freem(m);
d393 2
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@RCS log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d1 16
d18 2
a19 2
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
d21 11
a31 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a32 14
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)raw_usrreq.c	8.1 (Berkeley) 6/10/93
 * $Id: raw_usrreq.c,v 1.6 1995/05/30 08:08:22 rgrimes Exp $
d35 12
a46 15
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/errno.h>

#include <net/if.h>
#include <net/route.h>
#include <net/netisr.h>
#include <net/raw_cb.h>

#include "module.h"
a50 1
void
d54 1
a57 5
 * Raw protocol input routine.  Find the socket
 * associated with the packet(s) and move them over.  If
 * nothing exists for this packet, drop it.
 */
/*
a59 1
void
d62 1
a62 1
	register struct sockproto *proto;
d65 64
d130 1
a130 2
	register struct mbuf *m = m0;
	register int sockets = 0;
d133 7
d142 1
a142 1
		if (rp->rcb_proto.sp_family != proto->sp_family)
d145 1
a145 1
		    rp->rcb_proto.sp_protocol != proto->sp_protocol)
a150 3
		 *
		 * Note that if the lengths are not the same
		 * the comparison will fail at the first byte.
d152 4
a155 3
#define	equal(a1, a2) \
  (bcmp((caddr_t)(a1), (caddr_t)(a2), a1->sa_len) == 0)
		if (rp->rcb_laddr && !equal(rp->rcb_laddr, dst))
d157 2
a158 1
		if (rp->rcb_faddr && !equal(rp->rcb_faddr, src))
d162 18
a179 10
			n = m_copy(m, 0, (int)M_COPYALL);
			if (n) {
				if (sbappendaddr(&last->so_rcv, src,
				    n, (struct mbuf *)0) == 0)
					/* should notify about lost packet */
					m_freem(n);
				else {
					sorwakeup(last);
					sockets++;
				}
d181 1
d186 10
a195 4
		if (sbappendaddr(&last->so_rcv, src,
		    m, (struct mbuf *)0) == 0)
			m_freem(m);
		else {
d197 5
a201 2
			sockets++;
		}
d203 8
a210 1
		m_freem(m);
a212 1

a213 1
void
d225 1
a225 2
int
raw_usrreq(so, req, m, nam, control)
d228 1
a228 1
	struct mbuf *m, *nam, *control;
a231 1
	int len;
d235 1
a235 1
	if (control && control->m_len) {
d239 1
a239 1
	if (rp == 0) {
d255 4
d281 1
a281 3
		error = EINVAL;
#if 0
		if (rp->rcb_faddr) {
d285 1
a285 2
		nam = m_copym(nam, 0, M_COPYALL, M_WAIT);
		rp->rcb_faddr = mtod(nam, struct sockaddr *);
a286 1
#endif
d289 4
d294 1
a294 3
		error = EINVAL;
#if 0
		if (rp->rcb_laddr) {
a298 1
#endif
a300 4
	case PRU_CONNECT2:
		error = EOPNOTSUPP;
		goto release;

d302 1
a302 1
		if (rp->rcb_faddr == 0) {
d323 1
a323 1
			if (rp->rcb_faddr) {
d327 2
a328 2
			rp->rcb_faddr = mtod(nam, struct sockaddr *);
		} else if (rp->rcb_faddr == 0) {
d339 1
a339 1
			rp->rcb_faddr = 0;
d368 3
a370 7
		if (rp->rcb_laddr == 0) {
			error = EINVAL;
			break;
		}
		len = rp->rcb_laddr->sa_len;
		bcopy((caddr_t)rp->rcb_laddr, mtod(nam, caddr_t), (unsigned)len);
		nam->m_len = len;
d374 3
a376 7
		if (rp->rcb_faddr == 0) {
			error = ENOTCONN;
			break;
		}
		len = rp->rcb_faddr->sa_len;
		bcopy((caddr_t)rp->rcb_faddr, mtod(nam, caddr_t), (unsigned)len);
		nam->m_len = len;
d384 7
a390 1
		m_freem(m);
d393 2
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@

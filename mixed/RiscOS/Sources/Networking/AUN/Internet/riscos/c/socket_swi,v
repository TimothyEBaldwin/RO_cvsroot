head	4.11;
access;
symbols
	Internet-5_65:4.11
	Internet-5_64:4.11
	Internet-5_63:4.11
	Internet-5_62:4.11
	Internet-5_61:4.11
	Internet-5_60:4.11
	Internet-5_59:4.11
	Internet-5_58:4.11
	Internet-5_57:4.11
	Internet-5_56:4.11
	Internet-5_55:4.11
	Internet-5_54:4.11
	Internet-5_53:4.11
	Internet-5_52:4.11
	Internet-5_51:4.11
	Internet-5_50:4.11
	RO_5_07:4.11
	Internet-5_49:4.11
	Internet-5_48:4.11
	Internet-5_47:4.11
	Internet-5_46:4.11
	Internet-5_45:4.11
	Internet-5_44:4.11
	Internet-5_43:4.11
	Internet-5_42:4.11
	Internet-5_41:4.11
	Internet-5_40:4.11
	Internet-5_39:4.11
	Internet-5_38:4.11
	Internet-5_37:4.11
	Internet-5_36:4.11
	Internet-5_35:4.11
	Internet-5_34:4.11
	Internet-5_33:4.11
	Internet-5_32:4.11
	Internet-5_31:4.11
	Internet-5_30:4.10
	Internet-5_29:4.10
	Internet-5_27:4.10
	Internet-5_26:4.10
	Internet-5_25:4.10
	Internet-5_24:4.10
	Internet-5_23:4.10
	Internet-5_22:4.10
	Internet-5_21:4.10
	Internet-5_20:4.10
	Internet-5_19:4.10
	Internet-5_18:4.10
	Internet-5_17:4.10
	Internet-5_16:4.9
	mstphens_UrsulaRiscPCBuild_20Nov98:4.4
	Ursula_RiscPC:4.4.0.4
	Internet-5_15:4.9
	Internet-5_14:4.9
	Internet-5_13:4.9
	sforrest_daytona_appflash-0_31:4.6
	Internet-5_12:4.9
	Internet-5_11:4.9
	celkins_Internet-5_10:4.8
	nicke_Internat_25-9-98:4.5
	Internet-5_09:4.7
	blaughto_daytona_appflash-0_30:4.6
	rthornb_UrsulaBuild-19Aug1998:4.4
	UrsulaBuild_FinalSoftload:4.4
	rthornb_UrsulaBuild-12Aug1998:4.4
	aglover_UrsulaBuild-05Aug1998:4.4
	rthornb_UrsulaBuild-29Jul1998:4.4
	rthornb_UrsulaBuild-22Jul1998:4.4
	rwarren_Internet-5_08:4.6
	Spinner:4.5
	Internet_5_07:4.5
	rthornb_UrsulaBuild-15Jul1998:4.4
	rthornb_UrsulaBuild-07Jul1998:4.4
	rthornb_UrsulaBuild-17Jun1998:4.4
	rthornb_UrsulaBuild-03Jun1998:4.4
	rthornb_UrsulaBuild-27May1998:4.4
	rthornb_UrsulaBuild-21May1998:4.4
	Ursula_bp:4.4
	Ursula:4.4.0.2
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.4
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.3
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.2
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.11
date	99.07.13.11.13.06;	author kbracey;	state Exp;
branches;
next	4.10;

4.10
date	98.11.27.14.49.14;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	98.10.05.14.25.47;	author sbrodie;	state Exp;
branches;
next	4.8;

4.8
date	98.09.29.14.00.44;	author celkins;	state Exp;
branches;
next	4.7;

4.7
date	98.08.21.17.15.44;	author sbrodie;	state Exp;
branches;
next	4.6;

4.6
date	98.07.22.09.40.34;	author rwarren;	state Exp;
branches;
next	4.5;

4.5
date	98.07.21.12.50.44;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	98.04.22.22.00.28;	author celkins;	state Exp;
branches;
next	4.3;

4.3
date	98.03.27.12.36.40;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.59.09;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.11;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.11;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.20.30;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.30.44;	author nturton;	state Exp;
branches;
next	4.1.3.2;

4.1.3.2
date	96.11.08.17.23.26;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.07.07;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.41;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.07.09;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.52;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.38.55;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.33;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.11
log
@Added new FreeBSD sysctl handling using linker magic.
A few new sysctls added as a result.
SO_TIMESTAMP now gives real time, not Internet's internal time.
DHCP/BOOTP parsing picks up URL option and pops it into Inet$URL.
Requires TCPIPLibs 5.25 and link 5.12.

Version 5.31. Tagged as 'Internet-5_31'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
 *
 */
#include "sys/param.h"
#include "sys/errno.h"
#include "sys/uio.h"
#include "sys/mbuf.h"
#include "sys/domain.h"
#include "sys/protosw.h"
#include "sys/socket.h"
#include "sys/socketvar.h"
#include "sys/ioctl.h"
#include "sys/stat.h"
#include "sys/time.h"
#include "sys/kernel.h"
#include "sys/proc.h"
#include "sys/file.h"
#include "sys/signalvar.h"
#include "sys/systm.h"
#include "sys/queue.h"
#include "sys/sysctl.h"

#include "netinet/in.h"
#include "netinet/ip_var.h"
#include "netinet/udp.h"
#include "netinet/udp_var.h"

#include "debug.h"
#include "module.h"
#include "InetHdr.h"

struct socket *socktab[SOCKTABSIZE];

static int getsockslot(void);
static int do_sock_select(struct socket *so, int which);
static int selscan(fd_set *ibits, fd_set *obits, int nfd, int *retval, int *noblock);

int
socketversion(_kernel_swi_regs *r, int *retval)
{
    *retval = Module_VersionNumber;
    return (0);
}

static void setsockslot(int sockid, struct socket *so)
{
    socktab[sockid] = so;
}

/* Should be in kern/uipc_sycall.c */
int
#ifdef __riscos
sendit(s, mp, flags, retsize)
#else
sendit(p, s, mp, flags, retsize)
	register struct proc *p;
#endif
	int s;
	register struct msghdr *mp;
	int flags, *retsize;
{
#ifndef __riscos
	struct file *fp;
#else
	struct socket *so;
#endif
	struct uio auio;
	register struct iovec *iov;
	register int i;
	struct mbuf *to, *control;
	int len, error;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
#endif

#ifdef __riscos
        if ((so = getsock(s)) == 0)
	        return (EBADF);
	else
		error = 0;
#else
	error = getsock(p->p_fd, s, &fp);
	if (error)
		return (error);
#endif
	auio.uio_iov = mp->msg_iov;
	auio.uio_iovcnt = mp->msg_iovlen;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_rw = UIO_WRITE;
#ifndef __riscos
	auio.uio_procp = p;
#endif
	auio.uio_offset = 0;			/* XXX */
	auio.uio_resid = 0;
	iov = mp->msg_iov;
	for (i = 0; i < mp->msg_iovlen; i++, iov++) {
		if ((auio.uio_resid += iov->iov_len) < 0)
			return (EINVAL);
	}
	if (mp->msg_name) {
		error = sockargs(&to, mp->msg_name, mp->msg_namelen, MT_SONAME);
		if (error)
			return (error);
	} else
		to = 0;
	if (mp->msg_control) {
		if (mp->msg_controllen < sizeof(struct cmsghdr)
#ifdef COMPAT_OLDSOCK
		    && mp->msg_flags != MSG_COMPAT
#endif
		) {
			error = EINVAL;
			goto bad;
		}
		error = sockargs(&control, mp->msg_control,
		    mp->msg_controllen, MT_CONTROL);
		if (error)
			goto bad;
#ifdef COMPAT_OLDSOCK
		if (mp->msg_flags == MSG_COMPAT) {
			register struct cmsghdr *cm;

			M_PREPEND(control, sizeof(*cm), M_WAIT);
			if (control == 0) {
				error = ENOBUFS;
				goto bad;
			} else {
				cm = mtod(control, struct cmsghdr *);
				cm->cmsg_len = control->m_len;
				cm->cmsg_level = SOL_SOCKET;
				cm->cmsg_type = SCM_RIGHTS;
			}
		}
#endif
	} else
		control = 0;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO)) {
		int iovlen = auio.uio_iovcnt * sizeof (struct iovec);

		MALLOC(ktriov, struct iovec *, iovlen, M_TEMP, M_WAITOK);
		bcopy((caddr_t)auio.uio_iov, (caddr_t)ktriov, iovlen);
	}
#endif
	len = auio.uio_resid;
#ifdef __riscos
	error = sosend(so, to, &auio,
	    (struct mbuf *)0, control, flags);
#else
	error = sosend((struct socket *)fp->f_data, to, &auio,
	    (struct mbuf *)0, control, flags);
#endif
	if (error) {
		if (auio.uio_resid != len && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
		if (error == EPIPE)
#ifdef __riscos
			psignal(pfind(so->so_pgid), SIGPIPE);
#else
			psignal(p, SIGPIPE);
#endif
	}
	if (error == 0)
		*retsize = len - auio.uio_resid;
#ifdef KTRACE
	if (ktriov != NULL) {
		if (error == 0)
			ktrgenio(p->p_tracep, s, UIO_WRITE,
				ktriov, *retsize, error);
		FREE(ktriov, M_TEMP);
	}
#endif
bad:
	if (to)
		m_freem(to);
	return (error);
}

/* Should be in kern/uipc_syscall.c */
int
recvit(s, mp, namelenp, retsize)
	int s;
	register struct msghdr *mp;
	caddr_t namelenp;
	int *retsize;
{
#ifdef __riscos
	struct socket *so;
#else
	struct file *fp;
#endif
	struct uio auio;
	register struct iovec *iov;
	register int i;
	int len, error;
	struct mbuf *from = 0, *control = 0;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
#endif

#ifdef __riscos
        so = getsock(s);
        if (so == NULL)
                return (EBADF);
        else
        	error = 0;
#else
	error = getsock(p->p_fd, s, &fp);
	if (error)
		return (error);
#endif
	auio.uio_iov = mp->msg_iov;
	auio.uio_iovcnt = mp->msg_iovlen;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_rw = UIO_READ;
#ifndef __riscos
	auio.uio_procp = p;
#endif
	auio.uio_offset = 0;			/* XXX */
	auio.uio_resid = 0;
	iov = mp->msg_iov;
	for (i = 0; i < mp->msg_iovlen; i++, iov++) {
		if ((auio.uio_resid += iov->iov_len) < 0)
			return (EINVAL);
	}
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO)) {
		int iovlen = auio.uio_iovcnt * sizeof (struct iovec);

		MALLOC(ktriov, struct iovec *, iovlen, M_TEMP, M_WAITOK);
		bcopy((caddr_t)auio.uio_iov, (caddr_t)ktriov, iovlen);
	}
#endif
	len = auio.uio_resid;
#ifdef __riscos
	error = soreceive(so, &from, &auio,
#else
	error = soreceive((struct socket *)fp->f_data, &from, &auio,
#endif
	    (struct mbuf **)0, mp->msg_control ? &control : (struct mbuf **)0,
	    &mp->msg_flags);
	if (error) {
		if (auio.uio_resid != len && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
	}
#ifdef KTRACE
	if (ktriov != NULL) {
		if (error == 0)
			ktrgenio(p->p_tracep, s, UIO_READ,
				ktriov, len - auio.uio_resid, error);
		FREE(ktriov, M_TEMP);
	}
#endif
	if (error)
		goto out;
	*retsize = len - auio.uio_resid;
	if (mp->msg_name) {
		len = mp->msg_namelen;
		if (len <= 0 || from == 0)
			len = 0;
		else {
#ifdef COMPAT_OLDSOCK
			if (mp->msg_flags & MSG_COMPAT)
				mtod(from, struct osockaddr *)->sa_family =
				    mtod(from, struct sockaddr *)->sa_family;
#endif
			if (len > from->m_len)
				len = from->m_len;
			/* else if len < from->m_len ??? */
			error = copyout(mtod(from, caddr_t),
			    (caddr_t)mp->msg_name, (unsigned)len);
			if (error)
				goto out;
		}
		mp->msg_namelen = len;
		if (namelenp &&
		    (error = copyout((caddr_t)&len, namelenp, sizeof (int)))) {
#ifdef COMPAT_OLDSOCK
			if (mp->msg_flags & MSG_COMPAT)
				error = 0;	/* old recvfrom didn't check */
			else
#endif
			goto out;
		}
	}
	if (mp->msg_control) {
#ifdef COMPAT_OLDSOCK
		/*
		 * We assume that old recvmsg calls won't receive access
		 * rights and other control info, esp. as control info
		 * is always optional and those options didn't exist in 4.3.
		 * If we receive rights, trim the cmsghdr; anything else
		 * is tossed.
		 */
		if (control && mp->msg_flags & MSG_COMPAT) {
			if (mtod(control, struct cmsghdr *)->cmsg_level !=
			    SOL_SOCKET ||
			    mtod(control, struct cmsghdr *)->cmsg_type !=
			    SCM_RIGHTS) {
				mp->msg_controllen = 0;
				goto out;
			}
			control->m_len -= sizeof (struct cmsghdr);
			control->m_off += sizeof (struct cmsghdr);
		}
#endif
		len = mp->msg_controllen;
		if (len <= 0 || control == 0)
			len = 0;
		else {
			if (len >= control->m_len)
				len = control->m_len;
			else
				mp->msg_flags |= MSG_CTRUNC;
			error = copyout((caddr_t)mtod(control, caddr_t),
			    (caddr_t)mp->msg_control, (unsigned)len);
		}
		mp->msg_controllen = len;
	}
out:
	if (from)
		m_freem(from);
	if (control)
		m_freem(control);
	return (error);
}

struct socket_args {
	int	domain;
	int	type;
	int	protocol;
};
int
socket(uap, retval)
	register struct socket_args *uap;
	int *retval;
{
	struct socket *so;
	int fd, error;

	fd = getsockslot();
	if (fd < 0)
		return (EMFILE);
	error = socreate(uap->domain, &so, uap->type, uap->protocol);
	if (error) {
		/* Do nothing */
	} else {
		*retval = fd;
		setsockslot(fd, so);
		so->so_pgid = fd+1;
	}
	return (error);
}

struct bind_args {
	int	s;
	caddr_t	name;
	int	namelen;
};
/* ARGSUSED */
int
bind(uap)
	register struct bind_args *uap;
{
	struct socket *so;
	struct mbuf *nam;
	int error;

	if ((so = getsock(uap->s)) == 0)
		return (EBADF);
	error = sockargs(&nam, uap->name, uap->namelen, MT_SONAME);
	if (error)
		return (error);
	error = sobind(so, nam);
	m_freem(nam);
	return (error);
}

struct listen_args {
	int	s;
	int	backlog;
};
/* ARGSUSED */
int
listen(uap, retval)
	register struct listen_args *uap;
	int *retval;
{
	struct socket *so;

	so = getsock(uap->s);
	if (so == 0)
		return (EBADF);

	return (solisten(so, uap->backlog));
}

struct accept_args {
	int	s;
	caddr_t	name;
	int	*anamelen;
#ifdef COMPAT_OLDSOCK
	int	compat_43;	/* pseudo */
#endif
};

#ifndef COMPAT_OLDSOCK
#  define	accept1	accept
#endif  /* COMPAT_OLDSOCK*/
int
accept1(uap, retval)
	register struct accept_args *uap;
	int *retval;
{
	struct mbuf *nam;
	int namelen, error, sockid;
	register struct socket *so;

	if (uap->name) {
		error = copyin((caddr_t)uap->anamelen, (caddr_t)&namelen,
			sizeof (namelen));
		if(error)
			return (error);
	}
	so = getsock(uap->s);
	if (so == 0)
		return (EBADF);
	else
		error = 0;

	if ((so->so_options & SO_ACCEPTCONN) == 0)
		return (EINVAL);

	if ((so->so_state & SS_NBIO) && so->so_qlen == 0)
		return (EWOULDBLOCK);

	while (so->so_qlen == 0 && so->so_error == 0) {
		if (so->so_state & SS_CANTRCVMORE) {
			so->so_error = ECONNABORTED;
			break;
		}
		error = tsleep((caddr_t)&so->so_timeo, PSOCK | PCATCH,
		    netcon, 0, so->so_state & SS_SLEEPTW);
		if (error)
			return (error);
	}

	if (so->so_error) {
		error = so->so_error;
		so->so_error = 0;
		return (error);
	}
	sockid = getsockslot();
	if (sockid < 0)
		return (EBADF);
	{ struct socket *aso = so->so_q;
	  if (soqremque(aso, 1) == 0) {
		panic("accept");
		return (EFAULT);
	  }
	  so = aso;
	}
	nam = m_get(M_WAIT, MT_SONAME);
	if (nam == NULL)
		return (ENOBUFS);
	(void) soaccept(so, nam);

	setsockslot(sockid, so);
	so->so_pgid = sockid+1;
	*retval = sockid;

	if (uap->name) {
#ifdef COMPAT_OLDSOCK
		if (uap->compat_43)
			mtod(nam, struct osockaddr *)->sa_family =
			    mtod(nam, struct sockaddr *)->sa_family;
#endif
		if (namelen > nam->m_len)
			namelen = nam->m_len;
		/* SHOULD COPY OUT A CHAIN HERE */
		error = copyout(mtod(nam, caddr_t), (caddr_t)(uap->name),
		    (u_int)namelen);
		if (!error)
			error = copyout((caddr_t)&namelen,
			    (caddr_t)(uap->anamelen), sizeof (*uap->anamelen));
	}
	m_freem(nam);
	return (error);
}

#ifdef COMPAT_OLDSOCK
int
accept(uap, retval)
	struct accept_args *uap;
	int *retval;
{

#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 0;
	error = accept1(uap, retval);
	uap->compat_43 = temp;
	return (error);
#else
	uap->compat_43 = 0;
	return (accept1(uap, retval));
#endif
}

int
oaccept(uap, retval)
	struct accept_args *uap;
	int *retval;
{

#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 1;
	error = accept1(uap, retval);
	uap->compat_43 = temp;
	return (error);
#else
	uap->compat_43 = 1;
	return (accept1(uap, retval));
#endif
}
#endif /* COMPAT_OLDSOCK */


struct connect_args {
	int	s;
	caddr_t	name;
	int	namelen;
};
/* ARGSUSED */
int
connect(uap)
	register struct connect_args *uap;
{
	register struct socket *so;
	struct mbuf *nam;
	int error;

	so = getsock(uap->s);
	if (so == 0)
		return (EBADF);

	if ((so->so_state & SS_NBIO) && (so->so_state & SS_ISCONNECTING))
		return (EALREADY);

	error = sockargs(&nam, uap->name, uap->namelen, MT_SONAME);
	if (error)
		return (error);
	error = soconnect(so, nam);
	if (error)
		goto bad;
	if ((so->so_state & SS_NBIO) && (so->so_state & SS_ISCONNECTING)) {
		m_freem(nam);
		return (EINPROGRESS);
	}
	while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) {
		error = tsleep((caddr_t)&so->so_timeo, PSOCK | PCATCH,
		    netcon, 0, so->so_state & SS_SLEEPTW);
		if (error)
			break;
	}
	if (error == 0) {
		error = so->so_error;
		so->so_error = 0;
	}
bad:
	so->so_state &= ~SS_ISCONNECTING;
	m_freem(nam);
	if (error == ERESTART)
		error = EINTR;
	return (error);
}

struct sendtosm_args {
	int      s;
	caddr_t *buf;
	u_int    len;
	caddr_t *buf1;
	u_int    len1;
	caddr_t  to;
};
int
sendtosm(uap)
	struct sendtosm_args *uap;
{
	struct socket *so;
	struct mbuf *to, *m, *n;
	int error;

	so = getsock(uap->s);
    	if (so == 0)
		return (EBADF);

    	error = sockargs(&to, uap->to, sizeof(struct sockaddr), MT_SONAME);
    	if (error)
		return (error);

    	m = 0; n = 0;

    	m = ALLOC_U(uap->len, uap->buf);
    	if (m == NULL) {
#ifdef DEBUG
		if (DODEBUG(DBGMMAN))
	    		Printf("sosendsm: ALLOC_U#1 failed\n");
#endif
		error = ENOBUFS;
		goto release;
    	}
    	m->m_type = MT_DATA;
    	m->m_flags = M_PKTHDR;
    	m->m_pkthdr.len = uap->len;
    	m->m_pkthdr.rcvif = (struct ifnet *) 0;

	if (uap->len1 > 0) {
		n = ALLOC_U(uap->len1, uap->buf1);
		if (n == NULL) {
#ifdef DEBUG
	    		if (DODEBUG(DBGMMAN))
				Printf("sosendsm: ALLOC_U#2 failed\n");
#endif
	    		error = ENOBUFS;
	    		goto release;
		}

		n->m_type = MT_DATA;
		n->m_flags = 0;
		m->m_pkthdr.len += uap->len1;
    	        m->m_next = n;
    	}

    	error = udp_usrreq(so, PRU_SEND, m, to, 0);
    	m = 0;

release:
    	if (m)
		m_freem(m);

    	m_freem(to);
    	return (error);
}

struct sendto_args {
	int	s;
	caddr_t	buf;
	size_t	len;
	int	flags;
	caddr_t	to;
	int	tolen;
};
int
sendto(register struct sendto_args *uap, int *retval)
{
        struct msghdr msg;
        struct iovec aiov;

        msg.msg_name = uap->to;
        msg.msg_namelen = uap->tolen;
        msg.msg_iov = &aiov;
        msg.msg_iovlen = 1;
	msg.msg_control = 0;
#ifdef COMPAT_OLDSOCK
	msg.msg_flags = 0;
#endif
        aiov.iov_base = uap->buf;
        aiov.iov_len = uap->len;

        /* TRACE */
#ifdef DEBUGSEND
        Printf("sendit: %d bytes to '%.*s'\n", uap->len, uap->tolen, uap->to);
#endif

        return (sendit(uap->s, &msg, uap->flags, retval));
}

#ifdef COMPAT_OLDSOCK
struct osend_args {
	int	s;
	caddr_t	buf;
	int	len;
	int	flags;
};
int
osend(uap, retval)
	register struct osend_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov;

	msg.msg_name = 0;
	msg.msg_namelen = 0;
	msg.msg_iov = &aiov;
	msg.msg_iovlen = 1;
	aiov.iov_base = uap->buf;
	aiov.iov_len = uap->len;
	msg.msg_control = 0;
	msg.msg_flags = 0;
	return (sendit(uap->s, &msg, uap->flags, retval));
}

struct osendmsg_args {
	int	s;
	caddr_t	msg;
	int	flags;
};
int
osendmsg(uap, retval)
	register struct osendmsg_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov[UIO_SMALLIOV], *iov;
	int error;

	error = copyin(uap->msg, (caddr_t)&msg, sizeof (struct omsghdr));
	if (error)
		return (error);
	if ((u_int)msg.msg_iovlen >= UIO_SMALLIOV) {
		if ((u_int)msg.msg_iovlen >= UIO_MAXIOV)
			return (EMSGSIZE);
		MALLOC(iov, struct iovec *,
		      sizeof(struct iovec) * (u_int)msg.msg_iovlen, M_IOV,
		      M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
	} else
		iov = aiov;
	error = copyin((caddr_t)msg.msg_iov, (caddr_t)iov,
	    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)));
	if (error)
		goto done;
	msg.msg_flags = MSG_COMPAT;
	msg.msg_iov = iov;
	error = sendit(uap->s, &msg, uap->flags, retval);
done:
	if (iov != aiov)
		FREE(iov, M_IOV);
	return (error);
}
#endif

struct sendmsg_args {
	int	s;
	caddr_t	msg;
	int	flags;
};
int
sendmsg(uap, retval)
	register struct sendmsg_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov[UIO_SMALLIOV], *iov;
	int error;

	error = copyin(uap->msg, (caddr_t)&msg, sizeof (msg));
	if (error)
		return (error);
	if ((u_int)msg.msg_iovlen >= UIO_SMALLIOV) {
		if ((u_int)msg.msg_iovlen >= UIO_MAXIOV)
			return (EMSGSIZE);
		MALLOC(iov, struct iovec *,
		       sizeof(struct iovec) * (u_int)msg.msg_iovlen, M_IOV,
		       M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
	} else
		iov = aiov;
	if (msg.msg_iovlen &&
	    (error = copyin((caddr_t)msg.msg_iov, (caddr_t)iov,
	    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)))))
		goto done;
	msg.msg_iov = iov;
#ifdef COMPAT_OLDSOCK
	msg.msg_flags = 0;
#endif
	error = sendit(uap->s, &msg, uap->flags, retval);
done:
	if (iov != aiov)
		FREE(iov, M_IOV);
	return (error);
}

struct recvfrom_args {
	int	s;
	caddr_t	buf;
	size_t	len;
	int	flags;
	caddr_t	from;
	int	*fromlenaddr;
};

int
recvfrom(register struct recvfrom_args *uap, int *retval)
{
    	struct msghdr msg;
    	struct iovec aiov;
    	int error;

	if (uap->fromlenaddr) {
		error = copyin((caddr_t)uap->fromlenaddr,
		    (caddr_t)&msg.msg_namelen, sizeof (msg.msg_namelen));
		if (error)
			return (error);
	} else
		msg.msg_namelen = 0;
	msg.msg_name = uap->from;
	msg.msg_iov = &aiov;
	msg.msg_iovlen = 1;
	aiov.iov_base = uap->buf;
	aiov.iov_len = uap->len;
	msg.msg_control = 0;
	msg.msg_flags = uap->flags;
	return (recvit(uap->s, &msg, (caddr_t)uap->fromlenaddr, retval));
}

#ifdef COMPAT_OLDSOCK
int
orecvfrom(uap, retval)
	struct recvfrom_args *uap;
	int *retval;
{

	uap->flags |= MSG_COMPAT;
	return (recvfrom(uap, retval));
}
#endif


#ifdef COMPAT_OLDSOCK
struct orecv_args {
	int	s;
	caddr_t	buf;
	int	len;
	int	flags;
};
int
orecv(uap, retval)
	register struct orecv_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov;

	msg.msg_name = 0;
	msg.msg_namelen = 0;
	msg.msg_iov = &aiov;
	msg.msg_iovlen = 1;
	aiov.iov_base = uap->buf;
	aiov.iov_len = uap->len;
	msg.msg_control = 0;
	msg.msg_flags = uap->flags;
	return (recvit(uap->s, &msg, (caddr_t)0, retval));
}

/*
 * Old recvmsg.  This code takes advantage of the fact that the old msghdr
 * overlays the new one, missing only the flags, and with the (old) access
 * rights where the control fields are now.
 */
struct orecvmsg_args {
	int	s;
	struct	omsghdr *msg;
	int	flags;
};
int
orecvmsg(uap, retval)
	register struct orecvmsg_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov[UIO_SMALLIOV], *iov;
	int error;

	error = copyin((caddr_t)uap->msg, (caddr_t)&msg,
	    sizeof (struct omsghdr));
	if (error)
		return (error);
	if ((u_int)msg.msg_iovlen >= UIO_SMALLIOV) {
		if ((u_int)msg.msg_iovlen >= UIO_MAXIOV)
			return (EMSGSIZE);
		MALLOC(iov, struct iovec *,
		      sizeof(struct iovec) * (u_int)msg.msg_iovlen, M_IOV,
		      M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
	} else
		iov = aiov;
	msg.msg_flags = uap->flags | MSG_COMPAT;
	error = copyin((caddr_t)msg.msg_iov, (caddr_t)iov,
	    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)));
	if (error)
		goto done;
	msg.msg_iov = iov;
	error = recvit(uap->s, &msg, (caddr_t)&uap->msg->msg_namelen, retval);

	if (msg.msg_controllen && error == 0)
		error = copyout((caddr_t)&msg.msg_controllen,
		    (caddr_t)&uap->msg->msg_accrightslen, sizeof (int));
done:
	if (iov != aiov)
		FREE(iov, M_IOV);
	return (error);
}
#endif

struct recvmsg_args {
	int	s;
	struct	msghdr *msg;
	int	flags;
};
int
recvmsg(uap, retval)
	register struct recvmsg_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov[UIO_SMALLIOV], *uiov, *iov;
	register int error;

	error = copyin((caddr_t)uap->msg, (caddr_t)&msg, sizeof (msg));
	if (error)
		return (error);
	if ((u_int)msg.msg_iovlen >= UIO_SMALLIOV) {
		if ((u_int)msg.msg_iovlen >= UIO_MAXIOV)
			return (EMSGSIZE);
		MALLOC(iov, struct iovec *,
		       sizeof(struct iovec) * (u_int)msg.msg_iovlen, M_IOV,
		       M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
	} else
		iov = aiov;
#ifdef COMPAT_OLDSOCK
	msg.msg_flags = uap->flags &~ MSG_COMPAT;
#else
	msg.msg_flags = uap->flags;
#endif
	uiov = msg.msg_iov;
	msg.msg_iov = iov;
	error = copyin((caddr_t)uiov, (caddr_t)iov,
	    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)));
	if (error)
		goto done;
	error = recvit(uap->s, &msg, (caddr_t)0, retval);
	if (!error) {
		msg.msg_iov = uiov;
		error = copyout((caddr_t)&msg, (caddr_t)uap->msg, sizeof(msg));
	}
done:
	if (iov != aiov)
		FREE(iov, M_IOV);
	return (error);
}

struct shutdown_args {
	int	s;
	int	how;
};
int
shutdown(uap)
	register struct shutdown_args *uap;
{
	struct socket *so;

	so = getsock(uap->s);
	if (so == NULL)
		return (EBADF);

	return (soshutdown(so, uap->how));
}

struct setsockopt_args {
	int	s;
	int	level;
	int	name;
	caddr_t	val;
	int	valsize;
};
/* ARGSUSED */
int
setsockopt(uap, retval)
	register struct setsockopt_args *uap;
	int *retval;
{
	struct socket *so;
	struct mbuf *m = NULL;
	int error;

	so = getsock(uap->s);
	if (so == NULL)
		return (EBADF);

	if (uap->valsize > MINCONTIG)
		return (EINVAL);
	if (uap->val) {
		m = ALLOC_S(uap->valsize, NULL);
		if (m == NULL)
			return (ENOBUFS);
		m->m_type = MT_SOOPTS;
		error = copyin(uap->val, mtod(m, caddr_t), (u_int)uap->valsize);
		if (error) {
			(void) m_free(m);
			return (error);
		}
	}
	return (sosetopt(so, uap->level, uap->name, m));
}

struct getsockopt_args {
	int	s;
	int	level;
	int	name;
	caddr_t	val;
	int	*avalsize;
};
/* ARGSUSED */
int
getsockopt(uap, retval)
	register struct getsockopt_args *uap;
	int *retval;
{
	struct socket *so;
	struct mbuf *m = NULL, *m0;
	int op, i, valsize, error;

	so = getsock(uap->s);
	if (so == NULL)
		return (EBADF);
	if (uap->val) {
		error = copyin((caddr_t)uap->avalsize, (caddr_t)&valsize,
		    sizeof (valsize));
		if (error)
			return (error);
	} else
		valsize = 0;
	if ((error = sogetopt(so, uap->level,
	    uap->name, &m)) == 0 && uap->val && valsize && m != NULL) {
		op = 0;
		while (m && !error && op < valsize) {
			i = min(m->m_len, (valsize - op));
			error = copyout(mtod(m, caddr_t), uap->val, (u_int)i);
			op += i;
			uap->val += i;
			m0 = m;
			MFREE(m0,m);
		}
		valsize = op;
		if (error == 0)
			error = copyout((caddr_t)&valsize,
			    (caddr_t)uap->avalsize, sizeof (valsize));
	}
	if (m != NULL)
		(void) m_free(m);
	return (error);
}

/*
 * Get socket name.
 */
struct getsockname_args {
	int	fdes;
	caddr_t	asa;
	int	*alen;
#ifdef COMPAT_OLDSOCK
	int	compat_43;	/* pseudo */
#endif
};

#ifndef COMPAT_OLDSOCK
#define	getsockname1	getsockname
#endif

/* ARGSUSED */
int
getsockname1(uap, retval)
	register struct getsockname_args *uap;
	int *retval;
{
	register struct socket *so;
	struct mbuf *m;
	int len, error;

	so = getsock(uap->fdes);
	if (so == NULL)
		return (EBADF);
	error = copyin((caddr_t)uap->alen, (caddr_t)&len, sizeof (len));
	if (error)
		return (error);
	m = ALLOC_C(0, NULL);
	if (m == NULL)
		return (ENOBUFS);
	m->m_type = MT_SONAME;
	error = (*so->so_proto->pr_usrreq)(so, PRU_SOCKADDR, 0, m, 0);
	if (error)
		goto bad;
	if (len > m->m_len)
		len = m->m_len;
#ifdef COMPAT_OLDSOCK
	if (uap->compat_43)
		mtod(m, struct osockaddr *)->sa_family =
		    mtod(m, struct sockaddr *)->sa_family;
#endif
	error = copyout(mtod(m, caddr_t), (caddr_t)uap->asa, (u_int)len);
	if (error == 0)
		error = copyout((caddr_t)&len, (caddr_t)uap->alen,
		    sizeof (len));
bad:
	m_freem(m);
	return (error);
}

#ifdef COMPAT_OLDSOCK
int
getsockname(uap, retval)
	struct getsockname_args *uap;
	int *retval;
{

#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 0;
	error = getsockname1(uap, retval);
	uap->compat_43 = temp;
	return (error);
#else
	uap->compat_43 = 0;
	return (getsockname1(uap, retval));
#endif
}

int
ogetsockname(uap, retval)
	struct getsockname_args *uap;
	int *retval;
{

#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 1;
	error = getsockname1(uap, retval);
	uap->compat_43 = temp;
	return (error);
#else
	uap->compat_43 = 1;
	return (getsockname1(uap, retval));
#endif
}
#endif /* COMPAT_OLDSOCK */

/*
 * Get name of peer for connected socket.
 */
struct getpeername_args {
	int	fdes;
	caddr_t	asa;
	int	*alen;
#ifdef COMPAT_OLDSOCK
	int	compat_43;	/* pseudo */
#endif
};


#ifndef COMPAT_OLDSOCK
#define	getpeername1	getpeername
#endif

/* ARGSUSED */
int
getpeername1(uap, retval)
	register struct getpeername_args *uap;
	int *retval;
{
	register struct socket *so;
	struct mbuf *m;
	int len, error;

	so = getsock(uap->fdes);
	if (so == NULL)
		return (EBADF);
	if ((so->so_state & (SS_ISCONNECTED|SS_ISCONFIRMING)) == 0)
		return (ENOTCONN);
	error = copyin((caddr_t)uap->alen, (caddr_t)&len, sizeof (len));
	if (error)
		return (error);
	m = ALLOC_C(0, NULL);
	if (m == NULL)
		return (ENOBUFS);
	m->m_type = MT_SONAME;
	error = (*so->so_proto->pr_usrreq)(so, PRU_PEERADDR, 0, m, 0);
	if (error)
		goto bad;
	if (len > m->m_len)
		len = m->m_len;
#ifdef COMPAT_OLDSOCK
	if (uap->compat_43)
		mtod(m, struct osockaddr *)->sa_family =
		    mtod(m, struct sockaddr *)->sa_family;
#endif
	error = copyout(mtod(m, caddr_t), (caddr_t)uap->asa, (u_int)len);
	if (error)
		goto bad;
	error = copyout((caddr_t)&len, (caddr_t)uap->alen, sizeof (len));
bad:
	m_freem(m);
	return (error);
}

#ifdef COMPAT_OLDSOCK
int
getpeername(uap, retval)
	struct getpeername_args *uap;
	int *retval;
{

#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 0;
	error = getpeername1(uap, retval);
	uap->compat_43 = temp;
	return (error);
#else
	uap->compat_43 = 0;
	return (getpeername1(uap, retval));
#endif
}

int
ogetpeername(uap, retval)
	struct getpeername_args *uap;
	int *retval;
{

#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 1;
	error = getpeername1(uap, retval);
	uap->compat_43 = temp;
	return (error);
#else
	uap->compat_43 = 1;
	return (getpeername1(uap, retval));
#endif
}
#endif /* COMPAT_OLDSOCK */
int
sockargs(mp, buf, buflen, type)
	struct mbuf **mp;
	caddr_t buf;
	int buflen, type;
{
	register struct sockaddr *sa;
	register struct mbuf *m;
	int error;

	if ((u_int)buflen > MINCONTIG) {
#if defined(COMPAT_OLDSOCK) && !defined(__riscos)
		if (type == MT_SONAME && (u_int)buflen <= 112)
			buflen = MLEN;		/* unix domain compat. hack */
		else
#endif
		return (EINVAL);
	}
	m = ALLOC(buflen, NULL);
	if (m == NULL)
		return (ENOBUFS);
	m->m_type = type;
	error = copyin(buf, mtod(m, caddr_t), (u_int)buflen);
	if (error)
		m_free(m);
	else {
		*mp = m;
		if (type == MT_SONAME) {
			sa = mtod(m, struct sockaddr *);

#if defined(COMPAT_OLDSOCK) && BYTE_ORDER != BIG_ENDIAN
			if (sa->sa_family == 0 && sa->sa_len < AF_MAX)
				sa->sa_family = sa->sa_len;
#endif
			sa->sa_len = buflen;
		}
	}
	return (error);
}

int
socketclose(int *r)
{
    struct a
    {
	int s;
    } *up = (struct a *)r;
    struct socket *so;
    int sockid;
    int error;

    sockid = up->s;
    if ((so = getsock(sockid)) == 0)
	return (EBADF);

    /* KJB - stop events going off after close */
    so->so_pgid = 0;
    error = soclose(so);
    setsockslot(sockid, (struct socket *)0);
#ifdef DELAY_EVENTS
    siglist[sockid] = 0;
#endif

    return (error);
}

/*
 * Ioctl system call
 */
struct ioctl_args {
	int	fd;
	int	com;
	caddr_t	data;
};
/* ARGSUSED */
int
socketioctl(uap)
	register struct ioctl_args *uap;
{
#ifdef __riscos
	register struct socket *so;
#else
	register struct file *fp;
	register struct filedesc *fdp;
	int tmp;
#endif
	register int com, error;
	register u_int size;
	caddr_t data, memp;
#define STK_PARAMS	128
	char stkbuf[STK_PARAMS];

#ifdef __riscos
	if ((so = getsock(uap->fd)) == 0)
		return (EBADF);

	com = uap->com;
#else
	fdp = p->p_fd;
	if ((u_int)uap->fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[uap->fd]) == NULL)
		return (EBADF);

	if ((fp->f_flag & (FREAD | FWRITE)) == 0)
		return (EBADF);

	switch (com = uap->com) {
	case FIONCLEX:
		fdp->fd_ofileflags[uap->fd] &= ~UF_EXCLOSE;
		return (0);
	case FIOCLEX:
		fdp->fd_ofileflags[uap->fd] |= UF_EXCLOSE;
		return (0);
	}
#endif

	/*
	 * Interpret high order word to find amount of data to be
	 * copied to/from the user's address space.
	 */
	size = IOCPARM_LEN(com);
	if (size > IOCPARM_MAX)
		return (ENOTTY);
	memp = NULL;
#ifdef COMPAT_IBCS2
	if (size + IBCS2_RETVAL_SIZE > sizeof (stkbuf)) {
		memp = (caddr_t)malloc((u_long)size + IBCS2_RETVAL_SIZE,
				       M_IOCTLOPS, M_WAITOK);
		if (memp==0)
			return (ENOBUFS);
		data = memp + IBCS2_RETVAL_SIZE;
	} else
		data = stkbuf + IBCS2_RETVAL_SIZE;
	*(int *)(data - IBCS2_RETVAL_SIZE) = IBCS2_MAGIC_IN;
	*(int *)(data - (IBCS2_RETVAL_SIZE - sizeof(int))) = 0;
	*(int *)(data - (IBCS2_RETVAL_SIZE - 2*sizeof(int))) = 0;
#else
	if (size > sizeof (stkbuf)) {
		memp = (caddr_t)malloc((u_long)size, M_IOCTLOPS, M_WAITOK);
		if (memp==0)
			return (ENOBUFS);
		data = memp;
	} else
		data = stkbuf;
#endif
	if (com&IOC_IN) {
		if (size) {
			error = copyin(uap->data, data, (u_int)size);
			if (error) {
				if (memp)
					free(memp, M_IOCTLOPS);
				return (error);
			}
		} else
			*(caddr_t *)data = uap->data;
	} else if ((com&IOC_OUT) && size)
		/*
		 * Zero the buffer so the user always
		 * gets back something deterministic.
		 */
		bzero(data, size);
	else if (com&IOC_VOID)
		*(caddr_t *)data = uap->data;
#ifdef COMPAT_IBCS2
	else if (com)
		/*
		 * Pick up such things as NIOCxx.
		 * Any copyouts will have to be done prior
		 * to return by their servicing code.
		 */
		*(caddr_t *)data = uap->data;
#endif

	switch (com) {
#ifndef __riscos
	case FIONBIO:
		if ((tmp = *(int *)data))
			fp->f_flag |= FNONBLOCK;
		else
			fp->f_flag &= ~FNONBLOCK;
		error = (*fp->f_ops->fo_ioctl)(fp, FIONBIO, (caddr_t)&tmp, p);
		break;

	case FIOASYNC:
		if ((tmp = *(int *)data))
			fp->f_flag |= FASYNC;
		else
			fp->f_flag &= ~FASYNC;
		error = (*fp->f_ops->fo_ioctl)(fp, FIOASYNC, (caddr_t)&tmp, p);
		break;

	case FIOSETOWN:
		tmp = *(int *)data;
		if (fp->f_type == DTYPE_SOCKET) {
			((struct socket *)fp->f_data)->so_pgid = tmp;
			error = 0;
			break;
		}
		if (tmp <= 0) {
			tmp = -tmp;
		} else {
			struct proc *p1 = pfind(tmp);
			if (p1 == 0) {
				error = ESRCH;
				break;
			}
			tmp = p1->p_pgrp->pg_id;
		}
		error = (*fp->f_ops->fo_ioctl)
			(fp, (int)TIOCSPGRP, (caddr_t)&tmp, p);
		break;

	case FIOGETOWN:
		if (fp->f_type == DTYPE_SOCKET) {
			error = 0;
			*(int *)data = ((struct socket *)fp->f_data)->so_pgid;
			break;
		}
		error = (*fp->f_ops->fo_ioctl)(fp, (int)TIOCGPGRP, data, p);
		*(int *)data = -*(int *)data;
		break;
#endif
	default:
#ifdef __riscos
		error = soo_ioctl(so, com, data);
#else
		error = (*fp->f_ops->fo_ioctl)(fp, com, data, p);
#endif
		/*
		 * Copy any data to user, size was
		 * already set and checked above.
		 */
		if (error == 0 && (com&IOC_OUT) && size)
			error = copyout(data, uap->data, (u_int)size);
		break;
	}
#ifdef COMPAT_IBCS2
	if ((*(int *)(data - IBCS2_RETVAL_SIZE)) == IBCS2_MAGIC_OUT) {
		retval[0] = *(int *)(data-(IBCS2_RETVAL_SIZE - sizeof(int)));
		retval[1] = *(int *)(data-(IBCS2_RETVAL_SIZE - 2*sizeof(int)));
	}
#endif
	if (memp)
		free(memp, M_IOCTLOPS);
	return (error);
}

/*
 * Read system call.
 */
struct read_args {
	int	fd;
	char	*buf;
	u_int	nbyte;
};
/* ARGSUSED */
int
socketread(uap, retval)
	register struct read_args *uap;
	int *retval;
{
	struct uio auio;
	struct iovec aiov;
	struct socket *so;
    	long cnt, error = 0;

	if ((so = getsock(uap->fd)) == 0)
		return (EBADF);

        aiov.iov_base = (caddr_t)uap->buf;
	aiov.iov_len = uap->nbyte;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;

	auio.uio_resid = uap->nbyte;
	if (auio.uio_resid < 0)
		return (EINVAL);

	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_USERSPACE;
#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO))
		ktriov = aiov;
#endif
	cnt = uap->nbyte;
	if ((error = soreceive(so, (struct mbuf **)0, &auio,
	       (struct mbuf **)0, (struct mbuf **)0, (int *)0)))
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
	cnt -= auio.uio_resid;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO) && error == 0)
		ktrgenio(p->p_tracep, uap->fd, UIO_READ, &ktriov, cnt, error);
#endif
	*retval = cnt;
	return (error);
}

/*
 * Scatter read system call.
 */
struct readv_args {
	int	fdes;
	struct	iovec *iovp;
	u_int	iovcnt;
};
int
socketreadv(uap, retval)
	register struct readv_args *uap;
	int *retval;
{
	struct uio auio;
	register struct iovec *iov;
	struct iovec *needfree;
	struct iovec aiov[UIO_SMALLIOV];
	struct socket *so;
	long i, cnt, error = 0;
	u_int iovlen;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
#endif

    	if ((so = getsock(uap->fdes)) == 0)
		return (EBADF);
	/* note: can't use iovlen until iovcnt is validated */
	iovlen = uap->iovcnt * sizeof (struct iovec);
	if (uap->iovcnt > UIO_SMALLIOV) {
		if (uap->iovcnt > UIO_MAXIOV)
			return (EINVAL);
		MALLOC(iov, struct iovec *, iovlen, M_IOV, M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
		needfree = iov;
	} else {
		iov = aiov;
		needfree = NULL;
	}
	auio.uio_iov = iov;
	auio.uio_iovcnt = uap->iovcnt;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_USERSPACE;
	if ((error = copyin((caddr_t)uap->iovp, (caddr_t)iov, iovlen)))
		goto done;
	auio.uio_resid = 0;
	for (i = 0; i < uap->iovcnt; i++) {
		auio.uio_resid += iov->iov_len;
		if (auio.uio_resid < 0) {
			error = EINVAL;
			goto done;
		}
		iov++;
	}
#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO))  {
		MALLOC(ktriov, struct iovec *, iovlen, M_TEMP, M_WAITOK);
		bcopy((caddr_t)auio.uio_iov, (caddr_t)ktriov, iovlen);
	}
#endif
	cnt = auio.uio_resid;
	if ((error = soreceive(so, (struct mbuf **)0, &auio,
	     (struct mbuf **)0, (struct mbuf **)0, (int *)0)))
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
	cnt -= auio.uio_resid;
#ifdef KTRACE
	if (ktriov != NULL) {
		if (error == 0)
			ktrgenio(p->p_tracep, uap->fdes, UIO_READ, ktriov,
			    cnt, error);
		FREE(ktriov, M_TEMP);
	}
#endif
	*retval = cnt;
done:
	if (needfree)
		FREE(needfree, M_IOV);
	return (error);
}

/*
 * Write system call
 */
struct write_args {
	int	fd;
	char	*buf;
	u_int	nbyte;
};
int
socketwrite(uap, retval)
	register struct write_args *uap;
	int *retval;
{
#ifdef __riscos
	register struct socket *so;
#else
	register struct file *fp;
	register struct filedesc *fdp = p->p_fd;
#endif
	struct uio auio;
	struct iovec aiov;
	long cnt, error = 0;
#ifdef KTRACE
	struct iovec ktriov;
#endif

#ifdef __riscos
	if ((so = getsock(uap->fd)) == 0)
		return (EBADF);
#else
	if (((u_int)uap->fd) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[uap->fd]) == NULL ||
	    (fp->f_flag & FWRITE) == 0)
		return (EBADF);
#endif
	aiov.iov_base = (caddr_t)uap->buf;
	aiov.iov_len = uap->nbyte;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_resid = uap->nbyte;
	auio.uio_rw = UIO_WRITE;
	auio.uio_segflg = UIO_USERSPACE;
#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO))
		ktriov = aiov;
#endif
	cnt = uap->nbyte;
#ifdef __riscos
	if ((error = sosend(so, 0, &auio, 0, 0, 0))) {
#else
	if ((error = (*fp->f_ops->fo_write)(fp, &auio, fp->f_cred))) {
#endif
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
		if (error == EPIPE)
#ifdef __riscos
			psignal(pfind(so->so_pgid), SIGPIPE);
#else
			psignal(p, SIGPIPE);
#endif
	}
	cnt -= auio.uio_resid;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO) && error == 0)
		ktrgenio(p->p_tracep, uap->fd, UIO_WRITE,
		    &ktriov, cnt, error);
#endif
	*retval = cnt;
	return (error);
}

/*
 * Gather write system call
 */
struct writev_args {
	int	fd;
	struct	iovec *iovp;
	u_int	iovcnt;
};
int
socketwritev(uap, retval)
	register struct writev_args *uap;
	int *retval;
{
	register struct socket *so;
	struct uio auio;
	register struct iovec *iov;
	struct iovec *needfree;
	struct iovec aiov[UIO_SMALLIOV];
	long i, cnt, error = 0;
	u_int iovlen;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
#endif

	if ((so = getsock(uap->fd)) == 0)
		return (EBADF);
	/* note: can't use iovlen until iovcnt is validated */
	iovlen = uap->iovcnt * sizeof (struct iovec);
	if (uap->iovcnt > UIO_SMALLIOV) {
		if (uap->iovcnt > UIO_MAXIOV)
			return (EINVAL);
		MALLOC(iov, struct iovec *, iovlen, M_IOV, M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
		needfree = iov;
	} else {
		iov = aiov;
		needfree = NULL;
	}
	auio.uio_iov = iov;
	auio.uio_iovcnt = uap->iovcnt;
	auio.uio_rw = UIO_WRITE;
	auio.uio_segflg = UIO_USERSPACE;
	if ((error = copyin((caddr_t)uap->iovp, (caddr_t)iov, iovlen)))
		goto done;
	auio.uio_resid = 0;
	for (i = 0; i < uap->iovcnt; i++) {
		auio.uio_resid += iov->iov_len;
		if (auio.uio_resid < 0) {
			error = EINVAL;
			goto done;
		}
		iov++;
	}
#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO))  {
		MALLOC(ktriov, struct iovec *, iovlen, M_TEMP, M_WAITOK);
		bcopy((caddr_t)auio.uio_iov, (caddr_t)ktriov, iovlen);
	}
#endif
	cnt = auio.uio_resid;
	if ((error = sosend(so, 0, &auio, 0, 0, 0))) {
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
		if (error == EPIPE)
			psignal(pfind(so->so_pgid), SIGPIPE);
	}
	cnt -= auio.uio_resid;
#ifdef KTRACE
	if (ktriov != NULL) {
		if (error == 0)
			ktrgenio(p->p_tracep, uap->fd, UIO_WRITE,
				ktriov, cnt, error);
		FREE(ktriov, M_TEMP);
	}
#endif
	*retval = cnt;
done:
	if (needfree)
		FREE(needfree, M_IOV);
	return (error);
}

int
socketstat(int *r)
{
    struct a
    {
	int s;
	struct stat *ub;
    } *up = (struct a *)r;
    struct socket *so;

	if ((so = getsock(up->s)) == 0)
		return (EBADF);

	bzero((caddr_t)(up->ub), sizeof (*(up->ub)));
	up->ub->st_mode = S_IFSOCK;
	return ((*so->so_proto->pr_usrreq)(so, PRU_SENSE,
				       (struct mbuf *)(up->ub),
				       (struct mbuf *)0,
				       (struct mbuf *)0));
}

/*ARGSUSED*/
int
getstablesize(int *r, int *rval)
{
    *rval = SOCKTABSIZE;
    return (0);
}

int	selwait, nselcoll;

/*
 * Select system call.
 */
struct select_args {
	u_int	nd;
	fd_set	*in, *ou, *ex;
	struct	timeval *tv;
};
int
socketselect(uap, retval)
	register struct select_args *uap;
	int *retval;
{
	fd_set ibits[3], obits[3];
	struct timeval atv;
	int s, ncoll, error = 0, timo;
	u_int ni;
	int noblock = 0;

	bzero((caddr_t)ibits, sizeof(ibits));
	bzero((caddr_t)obits, sizeof(obits));

	if (uap->nd > SOCKTABSIZE)
		uap->nd = SOCKTABSIZE;	/* forgiving; slightly wrong */
	ni = howmany(uap->nd, NFDBITS) * sizeof(fd_mask);

#define	getbits(name, x) \
	if (uap->name && \
	    (error = copyin((caddr_t)uap->name, (caddr_t)&ibits[x], ni))) \
		goto done;
	getbits(in, 0);
	getbits(ou, 1);
	getbits(ex, 2);
#undef	getbits

	if (uap->tv) {
		error = copyin((caddr_t)uap->tv, (caddr_t)&atv,
			sizeof (atv));
		if (error)
			goto done;
		if (itimerfix(&atv)) {
			error = EINVAL;
			goto done;
		}
		s = splhi();
		timevaladd(&atv, (struct timeval *)&time);
#ifdef DEBUG
		if (DODEBUG(DBGSELECT))
			Printf("atv=(%d,%d), time=(%d,%d)\n",
			            atv.tv_sec, atv.tv_usec,
			            time.tv_sec, time.tv_usec);
#endif
		timo = hzto(&atv);
		/*
		 * Avoid inadvertently sleeping forever.
		 */
		if (timo == 0)
			timo = 1;
		splx(s);
	} else
		timo = 0;

#ifdef DEBUG
	if (DODEBUG(DBGSELECT))
		Printf("\nSelect timeout = %d\n", timo);
#endif
retry:
	ncoll = nselcoll;
    	error = selscan(ibits, obits, uap->nd, retval, &noblock);
    	if (error || *retval)
		goto done;
	s = splhi();
	/* this should be timercmp(&time, &atv, >=) */
	if (uap->tv && (time.tv_sec > atv.tv_sec ||
	    (time.tv_sec == atv.tv_sec && time.tv_usec >= atv.tv_usec))) {
#ifdef DEBUG
		if (DODEBUG(DBGSELECT)) {
			Printf("Time too late ");
			Printf("atv=(%d,%d), time=(%d,%d)\n",
			       atv.tv_sec, atv.tv_usec,
			       time.tv_sec, time.tv_usec);
		}
#endif
		splx(s);
		goto done;
	}
	if (nselcoll != ncoll) {
#ifdef DEBUG
		if (DODEBUG(DBGSELECT))
			Printf("Select has happened ");
#endif
		splx(s);
		goto retry;
	}
#ifdef DEBUG
	if (DODEBUG(DBGSELECT))
		Printf("sleeping ");
#endif
	error = tsleep((caddr_t)&selwait, PSOCK | PCATCH, "select", timo, noblock);
#ifdef DEBUG
	if (DODEBUG(DBGSELECT))
		Printf("woken ");
#endif
	splx(s);
	if (error == 0)
		goto retry;
done:
	/* select is not restarted after signals... */
	if (error == ERESTART)
		error = EINTR;
	if (error == EWOULDBLOCK)
		error = 0;
#define	putbits(name, x) \
	if (uap->name && \
	    (error2 = copyout((caddr_t)&obits[x], (caddr_t)uap->name, ni))) \
		error = error2;
	if (error == 0) {
		int error2;

		putbits(in, 0);
		putbits(ou, 1);
		putbits(ex, 2);
#undef putbits
	}

    return (error);
}

static int
selscan(ibits, obits, nfd, retval, noblock)
	fd_set *ibits, *obits;
	int nfd, *retval, *noblock;
{
    int msk, i, j, s;
    fd_mask bits;
    struct socket *so;
    int n = 0;
    static int flag[3] = { FREAD, FWRITE, 0 };

    for (msk = 0; msk < 3; msk++) {
	for (i = 0; i < nfd; i += NFDBITS) {
	    bits = ibits[msk].fds_bits[i/NFDBITS];
	    while ((j = ffs(bits)) && (s = i + --j) < nfd) {
		bits &= ~(1 << j);
		so = getsock(s);
		if (so == NULL)
		    return (EBADF);
		*noblock=so->so_state & SS_SLEEPTW;
		if (do_sock_select(so, flag[msk])) {
		    FD_SET(s, &obits[msk]);
		    n++;
		}
	    }
	}
    }
    *retval = n;
    return (0);
}

/*ARGSUSED*/
#if 0
static int seltrue(int dev, int flag)
{
    return (1);
}
#endif /* 0/1 */

/*
 * Record a select request.
 */
void
selrecord(selector, sip)
	struct proc *selector;
	struct selinfo *sip;
{
#ifdef __riscos
	sip->si_flags |= SI_COLL;
#else
	struct proc *p;
	pid_t mypid;

	mypid = selector->p_pid;
	if (sip->si_pid == mypid)
		return;
	if (sip->si_pid && (p = pfind(sip->si_pid)))
		sip->si_flags |= SI_COLL;
	else
		sip->si_pid = mypid;
#endif
}

/*
 * Do a wakeup when a selectable event occurs.
 */
void
selwakeup(sip)
	register struct selinfo *sip;
{
#ifdef DEBUG
	if (DODEBUG(DBGSELECT))
       		Printf("selwakeup(%x)\n", sip);
#endif
	if (sip->si_flags & SI_COLL) {
#ifdef DEBUG
		if (DODEBUG(DBGSELECT))
                	Printf("  Waking up!\n");
#endif
		nselcoll++;
		sip->si_flags &= ~SI_COLL;
		wakeup((caddr_t)&selwait);
	}
}

static int
do_sock_select(so, which)
	struct socket *so;
	int which;
{
	struct proc *p=pfind(so->so_pgid);

	switch (which) {

	case FREAD:
		if (soreadable(so))
			return (1);
		selrecord(p, &so->so_rcv.sb_sel);
		so->so_rcv.sb_flags |= SB_SEL;
		break;

	case FWRITE:
		if (sowriteable(so))
			return (1);
		selrecord(p, &so->so_snd.sb_sel);
		so->so_snd.sb_flags |= SB_SEL;
		break;

	case 0:
		if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
			return (1);
		selrecord(p, &so->so_rcv.sb_sel);
		so->so_rcv.sb_flags |= SB_SEL;
		break;
	}
	return (0);
}

struct socket *
getsock(s)
	int s;
{
	if (s < 0 || s >= SOCKTABSIZE)
		return ((struct socket *)0);

    	return (socktab[s]);
}

int getsockid(struct socket *so)
{
    int sockid;

    for (sockid = 0; sockid < SOCKTABSIZE; sockid++)
	if (socktab[sockid] == so)
	    return (sockid);

    return (-1);
}

static int getsockslot(void)
{
    int sockid;

    for (sockid = 0; sockid < SOCKTABSIZE; sockid++)
	if (socktab[sockid] == 0)
	    return (sockid);

    return (-1);
}

int sockstats(void)
{
    int i;
    int sockcnt = 0;

    for (i = 0; i < SOCKTABSIZE; i++)
	if (socktab[i] != 0)
	    sockcnt++;

    return (sockcnt);
}

/* EOF socket_swi.c */
@


4.10
log
@Removed limitation on length of IP interrupt queue, and made psignal
generate events immediately, rather than at the end of callbacks.
In both respects, the behaviour is restored to that of Internet 4. This
fixes some performance problems with data streaming near the limit of the
machine's capability.

Version 5.17. Tagged as 'Internet-5_17'
@
text
@d35 2
@


4.9
log
@* Changed to use srccommit.
* Removed obsolete caveats on always having to keep version numbers
  between riscos/c/socket_swi and build/cmhg/InetHdr synchronised:
  the former now relies on the CMHG generated header file which, in
  turn, relies on the VersionNum file.

Version 5.11. Tagged as 'Internet-5_11'
@
text
@d1331 1
d1333 1
@


4.8
log
@Module version updated to 5.10
System variable "Inet$EtherIPAddr" is now set by BOOTP code to assist
in using the machine's local IP address in boot scripts etc.
@
text
@d43 1
a43 3

/* KEEP IN LINE WITH CMHG FILE */
#define MODVERSION 510
d54 1
a54 1
    *retval = MODVERSION;
@


4.7
log
@  BOOTP vendor specific data cookie validation fixed.
  BOOTP now sets the netmask as per response from BOOTP server.
  Module version incremented to 5.09
Detail:
  whoami/c/whoami:vend_verify(): ntohl the address so comparison works
    and the vendor-specific data is examined.  This includes netmask
    setting, DNS resolver settings, gateway address, hostname.
  whoami/c/whoami:bootp_udp_input(): catch netmask if it was supplied
    and use it to configure the interface netmask instead of relying on
    the default for the interface IP address class and/or InetSetup.
  build/cmhg/InetHdr:riscos/c/socket_swi: Version number increment.
Admin:
  Clean build; tested on A7000+: disabled netmask setting, Inet$Resolvers,
  and Inet$HostName in Choices:Internet.Startup; booted A7000+; verified
  variable settings were correct and interface was configured as per data
  in server's bootptab configuration file.

Version 5.09. Tagged as Internet-5_09
@
text
@d45 1
a45 1
#define MODVERSION 509
@


4.6
log
@Internet 5.08	Fixed memory leak in routing table.

net/route.c changed in RTM_ADD case, line 491.  Else clause added to free
allocated rtentry structure.  Fix pulled in from FreeBSD 1.37 version of
net/route.c.  This is the only fix taken from the 1.37 version.  1.37
version used as it is the one used in the latest FreeBSD, 2.2.6.

This is to fix a memory leak in Daytona on PPP dialups.
@
text
@d45 1
a45 1
#define MODVERSION 508
@


4.5
log
@BOOTP was a bit broken
@
text
@d45 1
a45 1
#define MODVERSION 507
@


4.4
log
@Internet module (RISC OS version 5.06)

C.Elkins - added a sysctl interface to control IGMPv2 'fast leave'
	optimisation, so that Internet can be forced to always send
	the leave message (default - implement fast leave as per rfc 2236)
	Note:
	should be used in conjunction with corresponding headers and binaries
	(sysctl and inetstat).
@
text
@d45 1
a45 1
#define MODVERSION 506
@


4.3
log
@Missed some changes in the last checkin
@
text
@d45 1
a45 1
#define MODVERSION 505
@


4.2
log
@Version Spinner_B7 taken
@
text
@d45 1
a45 1
#define MODVERSION 503
@


4.1
log
@Initial revision
@
text
@d15 1
a15 5
/* -*-C-*-
 *
 * $Header: /ax/networking:Internet/riscos/socket_swi.c:networking  1.4  $
 * $Source: /ax/networking:Internet/riscos/socket_swi.c: $
 *
a17 15
 * $Log:	socket_swi.c,v $
 * Revision 1.4  95/02/03  15:26:02  kwelton
 * Increased the size of the socket table (SOCKTABSIZE) from 32 to 96.
 * 
 * Revision 1.3  95/01/03  13:42:50  kwelton
 * Whoops - last fix was wrong: it cleared n->m_type *twice*, and
 * didn't touch n->m_next.
 * 
 * Revision 1.2  94/12/06  17:09:06  kwelton
 * n->m_next now cleared after successful ALLOC_U of up->len1, up->buf1
 * in sendtosm().
 * 
 * Revision 1.1  94/12/02  11:46:06  kwelton
 * Initial revision
 * 
d30 2
d33 7
d42 1
d44 2
a45 1
#define SOCKTABSIZE 96
d47 12
a58 3
struct socket *socktab[SOCKTABSIZE] = { 0 };
struct socket *getsock();
int selwait = 0;
d65 11
a75 1
static int sendit(int s, struct msghdr *mp, int flags, int *rval)
d77 13
a89 6
    struct socket *so;
    struct uio auio;
    struct iovec *iov;
    int i;
    struct mbuf *to, *rights;
    int len, error;
d91 7
a97 24
    if ((so = getsock(s)) == 0)
	return (EBADF);

    auio.uio_iov = mp->msg_iov;
    auio.uio_iovcnt = mp->msg_iovlen;
    auio.uio_segflg = 0;
    auio.uio_offset = 0;		    /* XXX */
    auio.uio_resid = 0;
    iov = mp->msg_iov;

    for (i = 0; i < mp->msg_iovlen; i++, iov++)
    {
	if (iov->iov_len < 0)
	    return (EINVAL);

	if (iov->iov_len == 0)
	    continue;

	auio.uio_resid += iov->iov_len;
    }

    if (mp->msg_name)
    {
	error = sockargs(&to, mp->msg_name, mp->msg_namelen, MT_SONAME);
d99 56
a154 4
	    return (error);
    }
    else
	to = 0;
d156 3
a158 15
    if (mp->msg_accrights)
    {
	error = sockargs(&rights, mp->msg_accrights, mp->msg_accrightslen,
			 MT_RIGHTS);
	if (error)
	    goto bad;
    }
    else
	rights = 0;

    len = auio.uio_resid;

    /* TRACE */
#ifdef DEBUGSEND
    Printf("sendit: calling sosend\n");
d160 4
a163 7

    error = sosend((struct socket *)so, to, &auio, flags, rights);
    *rval = len - auio.uio_resid;
    if (rights)
    {
#ifdef OldCode
	m_freem(rights);
d165 2
a166 1
	FREEM(rights);
d168 7
a174 7
    }

  bad:
    if (to)
    {
#ifdef OldCode
	m_freem(to);
d176 12
a187 1
	FREEM(to);
d189 4
a192 2
    }
    return (error);
d195 7
a201 2
static int recvit(int s, struct msghdr *mp, int flags, caddr_t namelenp,
       caddr_t rightslenp, int *rval)
d203 1
d205 3
d209 2
a210 3
	struct iovec *iov;
	int i;
	struct mbuf *from, *rights;
d212 4
d217 11
a227 2
	if ((so = getsock(s)) == 0)
		return (EBADF);
d230 6
a235 2
	auio.uio_segflg = 0;
	auio.uio_offset = 0;
d239 1
a239 1
		if (iov->iov_len < 0)
a240 1
		auio.uio_resid += iov->iov_len;
d242 8
d251 23
a273 4
	error =
	    soreceive(so, &from, &auio,
		flags, &rights);
	*rval = len - auio.uio_resid;
d279 5
d286 2
a287 1
			(void) copyout((caddr_t)mtod(from, caddr_t),
d289 12
a301 1
		(void) copyout((caddr_t)&len, namelenp, sizeof (int));
d303 23
a325 3
	if (mp->msg_accrights) {
		len = mp->msg_accrightslen;
		if (len <= 0 || rights == 0)
d328 6
a333 4
			if (len > rights->m_len)
				len = rights->m_len;
			(void) copyout((caddr_t)mtod(rights, caddr_t),
			    (caddr_t)mp->msg_accrights, (unsigned)len);
d335 1
a335 1
		(void) copyout((caddr_t)&len, rightslenp, sizeof (int));
d337 1
a337 3
#ifdef OldCode
	if (rights)
		m_freem(rights);
d340 2
a341 7
#else
	if( rights )
	    FREEM(rights);

	if( from )
	    FREEM(from);
#endif
d345 9
a353 1
socket(int *r, int *rval)
d355 2
a356 8
    struct a
    {
	int domain;
	int type;
	int protocol;
    } *up = (struct a *)r;
    struct socket *so;
    int error, sockid;
d358 11
a368 6
    sockid = getsockslot();
    if (sockid < 0)
	return (EMFILE);

    error = socreate(up->domain, &so, up->type, up->protocol);
    if (error)
a369 5

    *rval = sockid;
    setsockslot(sockid, so);
    so->so_pgrp = sockid+1;
    return (0);
d372 9
a380 1
bind(int *r)
d382 3
a384 9
    struct a
    {
	int s;
	char *name;
	int namelen;
    } *up = (struct a *)r;
    struct socket *so;
    struct mbuf *nam;
    int error;
d386 7
a392 5
    if ((so = getsock(up->s)) == 0)
	return (EBADF);

    error = sockargs(&nam, up->name, up->namelen, MT_SONAME);
    if (error)
a393 8

    error = sobind((struct socket *)so, nam);
#ifdef OldCode
    m_freem(nam);
#else
    FREEM(nam);
#endif
    return (error);
d396 9
a404 1
listen(int *r)
d406 1
a406 7
    struct a
    {
	int s;
	int backlog;
    } *up = (struct a *)r;
    struct socket *so;
    int error;
d408 3
a410 3
    so = getsock(up->s);
    if (so == 0)
	return (EBADF);
d412 1
a412 2
    error = solisten((struct socket *)so, up->backlog);
    return (error);
d415 32
a446 12
accept(int *r, int *rval)
{
    struct a
    {
	int s;
	char *name;
	int *anamelen;
    } *up = (struct a *)r;
    struct mbuf *nam;
    int namelen, sockid;
    struct socket *so, *aso;
    int error;
d448 2
a449 2
    if (up->name == 0)
	goto noname;
d451 2
a452 3
    error = copyin((char *)(up->anamelen), (char *)&namelen, sizeof(namelen));
    if (error)
	return (error);
d454 10
a463 3
  noname:
    if ((so = getsock(up->s)) == 0)
	return (EBADF);
d465 38
a502 12
    if ((so->so_options & SO_ACCEPTCONN) == 0)
	return (EINVAL);

    if ((so->so_state & SS_NBIO) && so->so_qlen == 0)
	return (EWOULDBLOCK);

    while (so->so_qlen == 0 && so->so_error == 0)
    {
	if (so->so_state & SS_CANTRCVMORE)
	{
	    so->so_error = ECONNABORTED;
	    break;
d504 3
d508 6
a513 6
	if (sleep((caddr_t)&so->so_timeo, PZERO+1) != 0)
	{
	    so->so_error = ECONNABORTED;
	    break;
	}
    }
d515 6
a520 4
    if (so->so_error)
    {
	error = so->so_error;
	so->so_error = 0;
a521 14
    }

    aso = so->so_q;
    if (soqremque(aso, 1) == 0)
	panic("accept");

    so = aso;
#ifdef OldCode
    nam = m_get(M_DONTWAIT, MT_SONAME);
    if (nam == NULL)
    {
	error = ENOBUFS;
	goto out;
    }
d523 2
a524 10
    if( (nam = ALLOC_S(MINCONTIG, NULL)) == NULL )
    {
#ifdef DEBUG
	if( DODEBUG(DBGMMAN) )
	    Printf("accept: ALLOC_S failed\n");
#endif
	error = ENOBUFS;
	goto out;
    }
    nam->m_type = MT_SONAME;
d526 1
d528 5
a532 3
    error = soaccept(so, nam);
    if (error)
	goto out;
d534 7
a540 29
    sockid = getsockslot();
    if (sockid < 0)
    {
	error = EBADF;
	goto out;
    }

    setsockslot(sockid, so);
    so->so_pgrp = sockid+1;
    *rval = sockid;

    if (up->name)
    {
	if (namelen > nam->m_len)
	    namelen = nam->m_len;

	error = copyout(mtod(nam, caddr_t), (char *)(up->name),
			(u_int)namelen);

	if( !error )
	    error = copyout((char *)&namelen, (char *)(up->anamelen),
			    sizeof (*(up->anamelen)));
    }

  out:
    if (nam != NULL)
    {
#ifdef OldCode
	m_freem(nam);
d542 2
a543 1
	FREEM(nam);
a544 3
    }

    return (error);
d546 1
d549 13
a561 11
connect(int *r)
{
    struct a
    {
	int s;
	char *name;
	int namelen;
    } *up = (struct a *)r;
    struct socket *so;
    struct mbuf *nam;
    int error;
d563 3
a565 2
    if ((so = getsock(up->s)) == 0)
	return (EBADF);
d567 2
a568 2
    if((so->so_state & SS_NBIO) && (so->so_state & SS_ISCONNECTING) )
	return (EALREADY);
d570 5
a574 6
    error = sockargs(&nam, up->name, up->namelen, MT_SONAME);
    if (error)
	return (error);

    error = soconnect(so, nam);
    if (error)
d576 16
a591 4

    if( (so->so_state & SS_NBIO) && (so->so_state & SS_ISCONNECTING) )
    {
#ifdef OldCode
d593 3
a595 23
#else
	FREEM(nam);
#endif
	return (EINPROGRESS);
    }

    while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0)
    {
	if (sleep((caddr_t)&so->so_timeo, 0) != 0)
	    so->so_error = ECONNABORTED;
    }

    error = so->so_error;
    so->so_error = 0;

  bad:
    so->so_state &= ~SS_ISCONNECTING;
#ifdef OldCode
    m_freem(nam);
#else
    FREEM(nam);
#endif
    return (error);
d598 11
a608 1
sendtosm(int *r)
d610 3
a612 12
    struct a
    {
	int	s;
	char	*buf;
	int	len;
	char	*buf1;
	int	len1;
	char	*to;
    } *up = (struct a *)r;
    struct socket *so;
    struct mbuf *to, *m, *n;
    int error;
d614 3
a616 8
    if ((so = getsock(up->s)) == 0)
	return (EBADF);

    error = sockargs(&to, up->to, sizeof(struct sockaddr), MT_SONAME);
    if (error)
	return (error);

    m = 0; n = 0;
d618 3
a620 2
#ifdef OldCode
    MGET(m, M_WAIT, MT_DATA);
d622 1
a622 5
    if (m == 0)
    {
	error = ENOBUFS;
	goto release;
    }
d624 2
a625 7
    m->m_len = up->len;
    m->m_datp = up->buf;
    m->m_indir = 1;
    m->m_off = 0;
#else /* OldCode */
    if( (m = ALLOC_U(up->len, up->buf)) == NULL )
    {
d627 2
a628 2
	if( DODEBUG(DBGMMAN) )
	    Printf("sosendsm: ALLOC_U#1 failed\n");
d630 11
a640 26
	error = ENOBUFS;
	goto release;
    }

    m->m_type = MT_DATA;
#endif /* OldCode */

    if (up->len1 > 0)
    {
#ifdef OldCode
	MGET(n, M_WAIT, MT_DATA);

	if (n == 0)
	{
	    error = ENOBUFS;
	    goto release;
	}

	n->m_len = up->len1;
	n->m_datp = up->buf1;
	n->m_indir = 1;
	n->m_off = 0;
	n->m_next = 0;
#else /* OldCode */
	if( (n = ALLOC_U(up->len1, up->buf1)) == NULL )
	{
d642 2
a643 2
	    if( DODEBUG(DBGMMAN) )
		Printf("sosendsm: ALLOC_U#2 failed\n");
d645 3
a647 3
	    error = ENOBUFS;
	    goto release;
	}
d649 5
a653 4
	n->m_next = 0;
	n->m_type = MT_DATA;
#endif /* OldCode */
    }
d655 2
a656 8
    m->m_next = n;
    error = udp_usrreq(so, PRU_SEND, m, (caddr_t)to, 0);
    m = 0;

  release:
#ifdef OldCode
    if (m)
	m_freem(m);
d658 3
a660 4
    m_freem(to);
#else
    if( m )
	FREEM(m);
d662 2
a663 3
    FREEM(to);
#endif
    return (error);
d666 1
a666 4
sendto(int *r, int *rval)
{
    struct a
    {
d668 2
a669 2
	char	*buf;
	int	len;
d671 1
a671 1
	char	*to;
d673 17
a689 3
    } *up = (struct a *)r;
    struct msghdr msg;
    struct iovec aiov;
d691 1
a691 10
    msg.msg_name = up->to;
    msg.msg_namelen = up->tolen;
    msg.msg_iov = &aiov;
    msg.msg_iovlen = 1;
    aiov.iov_base = up->buf;
    aiov.iov_len = up->len;
    msg.msg_accrights = 0;
    msg.msg_accrightslen = 0;

    /* TRACE */
d693 1
a693 1
    Printf("sendit: %d bytes to '%.*s'\n", up->len, up->tolen, up->to);
d696 1
a696 1
    return(sendit(up->s, &msg, up->flags, rval));
d699 25
a723 11
send(int *r, int *rval)
{
    struct a
    {
	int s;
	char *buf;
	int len;
	int flags;
    } *up = (struct a *)r;
    struct msghdr msg;
    struct iovec aiov;
d725 13
a737 8
    msg.msg_name = 0;
    msg.msg_namelen = 0;
    msg.msg_iov = &aiov;
    msg.msg_iovlen = 1;
    aiov.iov_base = up->buf;
    aiov.iov_len = up->len;
    msg.msg_accrights = 0;
    msg.msg_accrightslen = 0;
d739 24
a762 1
    return (sendit(up->s, &msg, up->flags, rval));
d764 1
d766 13
a778 11
sendmsg(int *r, int *rval)
{
    struct a
    {
	int s;
	char *msgptr;
	int flags;
    } *up = (struct a *)r;
    struct msghdr msg;
    struct iovec aiov[MSG_MAXIOVLEN];
    int error;
d780 25
a804 2
    error = copyin(up->msgptr, (caddr_t)&msg, sizeof (msg));
    if (error)
a805 11

    if ((u_int)msg.msg_iovlen >= sizeof (aiov) / sizeof (aiov[0]))
	return (EMSGSIZE);

    error = copyin((caddr_t)msg.msg_iov, (caddr_t)aiov,
		   (unsigned)(msg.msg_iovlen * sizeof(aiov[0])));
    if (error)
	return (error);

    msg.msg_iov = aiov;
    return (sendit(up->s, &msg, up->flags, rval));
d808 1
a808 4
recvfrom(int *r, int *rval)
{
    struct a
    {
d810 2
a811 2
	char	*buf;
	int	blen;
d813 1
a813 1
	char	*from;
d815 1
a815 4
    } *up = (struct a *)r;
    struct msghdr msg;
    struct iovec aiov;
    int len, error;
d817 6
a822 12
    error = copyin((caddr_t)(up->fromlenaddr), (caddr_t)&len, sizeof(len));
    if (error)
	return (error);

    msg.msg_name = up->from;
    msg.msg_namelen = len;
    msg.msg_iov = &aiov;
    msg.msg_iovlen = 1;
    aiov.iov_base = up->buf;
    aiov.iov_len = up->blen;
    msg.msg_accrights = 0;
    msg.msg_accrightslen = 0;
d824 15
a838 2
    return(recvit(up->s, &msg, up->flags, (char *)(up->fromlenaddr),
		  (caddr_t)0, rval));
d841 5
a845 1
recv(int *r, int *rval)
a846 18
    struct a
    {
	int s;
	char *buf;
	int len;
	int flags;
    } *up = (struct a *)r;
    struct msghdr msg;
    struct iovec aiov;

    msg.msg_name = 0;
    msg.msg_namelen = 0;
    msg.msg_iov = &aiov;
    msg.msg_iovlen = 1;
    aiov.iov_base = up->buf;
    aiov.iov_len = up->len;
    msg.msg_accrights = 0;
    msg.msg_accrightslen = 0;
d848 2
a849 1
    return (recvit(up->s, &msg, up->flags, (char *)0, (char *)0, rval));
d851 1
a852 12
recvmsg(int *r, int *rval)
{
    struct a
    {
	int s;
	char *mp;
	int flags;
	int *rval;
    } *up = (struct a *)r;
    struct msghdr msg, *msgptr;
    struct iovec aiov[MSG_MAXIOVLEN];
    int error;
d854 25
a878 3
    error = copyin(up->mp, (caddr_t)&msg, sizeof (msg));
    if (error)
	return (error);
d880 18
a897 3
    msgptr = (struct msghdr *)up->mp;
    if ((u_int)msg.msg_iovlen >= sizeof (aiov) / sizeof (aiov[0]))
	return (EMSGSIZE);
d899 28
a926 3
    error = copyin((caddr_t)msg.msg_iov, (caddr_t)aiov,
		   (unsigned)(msg.msg_iovlen * sizeof (aiov[0])));
    if (error)
a927 4

    msg.msg_iov = aiov;
    return (recvit(up->s, &msg, up->flags, (caddr_t)&(msgptr->msg_namelen),
		   (caddr_t)&(msgptr->msg_accrightslen), rval));
a928 30

shutdown(int *r)
{
    struct a
    {
	int s;
	int how;
    } *up = (struct a *)r;
    struct socket *so;

    if( (so = getsock(up->s)) == 0 )
	return (EBADF);

    return (soshutdown(so, up->how));
}

setsockopt(int *r)
{
    struct a
    {
	int s;
	int level;
	int name;
	char *val;
	int valsize;
    } *up = (struct a *)r;
    struct socket *so;
    struct mbuf *m = NULL;
#ifdef OldCode
    int error;
d931 13
a943 11
    if ((so = getsock(up->s)) == 0)
	return (EBADF);

    if (up->valsize > MINCONTIG)
	return (EINVAL);

    if (up->val)
    {
#ifdef OldCode
	if ((m = m_get(M_DONTWAIT, MT_SOOPTS)) == 0)
	    return (ENOBUFS);
d945 1
a945 1
	error = copyin(up->val, mtod(m, caddr_t), (u_int)(up->valsize));
d947 13
a959 2
	    (void) m_free(m);
	    return (error);
d961 1
a961 5
	if( (m = ALLOC_S((u_int)(up->valsize), up->val)) == NULL )
	{
#ifdef DEBUG
	    if( DODEBUG(DBGMMAN) )
		Printf("setsockopt: ALLOC_S failed\n");
d963 10
a972 1
	    return(ENOBUFS);
d974 4
a977 11

	/*
	 * old code's use of copyin() could never fail, in the same
	 * way that we are assured of no errors if reached this far
	 */
	m->m_type = MT_SOOPTS;
#endif

	m->m_len = up->valsize;
    }
    return (sosetopt(so, up->level, up->name, m));
d980 7
a986 1
getsockopt(int *r)
d988 1
a988 11
    struct a
    {
	int s;
	int level;
	int name;
	char *val;
	int *avalsize;
    } *up = (struct a *)r;
    struct socket *so;
    struct mbuf *m = NULL;
    int valsize, error;
d990 3
a992 2
    if ((so = getsock(up->s)) == 0)
	return (EBADF);
d994 2
a995 9
    if (up->val)
    {
	error = copyin((char *)(up->avalsize), (char *)&valsize,
		       sizeof(valsize));
	if (error)
	    return (error);
    }
    else
	valsize = 0;
d997 16
a1012 3
    error = sogetopt(so, up->level, up->name, &m);
    if (error)
	goto bad;
d1014 3
a1016 4
    if (up->val && valsize && m != NULL)
    {
	if (valsize > m->m_len)
	    valsize = m->m_len;
d1018 15
a1032 3
	error = copyout(mtod(m, caddr_t), up->val, (u_int)valsize);
	if (error)
	    goto bad;
d1034 16
a1049 3
	error = copyout((caddr_t)&valsize, (char *)(up->avalsize),
			sizeof (valsize));
    }
d1051 29
a1079 11
  bad:
    if (m != NULL)
    {
#ifdef OldCode
	(void) m_free(m);
#else
	FREE(m);
#endif
    }

    return (error);
d1085 18
a1102 1
getsockname(int *r)
d1104 32
a1135 9
    struct a
    {
	int s;
	char *asa;
	int *alen;
    } *up = (struct a *)r;
    struct socket *so;
    struct mbuf *m;
    int len, error;
d1137 6
a1142 2
    if ((so = getsock(up->s)) == 0)
	return (EBADF);
d1144 6
a1149 2
    error = copyin((char *)(up->alen), (caddr_t)&len, sizeof (len));
    if (error)
a1150 4

#ifdef OldCode
    if ((m = m_getclr(M_DONTWAIT, MT_SONAME)) == 0)
	return (ENOBUFS);
d1152 2
a1153 5
    if( (m = ALLOC_C(MINCONTIG, NULL)) == NULL )
    {
#ifdef DEBUG
	if( DODEBUG(DBGMMAN) )
	    Printf("getsockname: ALLOC_C failed\n");
d1155 1
a1155 2
	return(ENOBUFS);
    }
d1157 5
a1161 2
    m->m_type = MT_SONAME;
#endif
d1163 7
a1169 16
    error = (*so->so_proto->pr_usrreq)(so, PRU_SOCKADDR, 0, m, 0);
    if (error)
	goto bad;

    if (len > m->m_len)
	len = m->m_len;

    error = copyout(mtod(m, caddr_t), (char *)(up->asa), (u_int)len);
    if (error)
	goto bad;

    error = copyout((caddr_t)&len, (char *)(up->alen), sizeof (len));

  bad:
#ifdef OldCode
    m_freem(m);
d1171 2
a1172 1
    FREEM(m);
a1173 1
    return (error);
d1175 1
d1180 9
a1188 11
getpeername(int *r)
{
    struct a
    {
	int s;
	char *asa;
	int *alen;
    } *up = (struct a *)r;
    struct socket *so;
    struct mbuf *m;
    int len, error;
d1190 3
a1192 2
    if ((so = getsock(up->s)) == 0)
	return (EBADF);
d1194 9
a1202 2
    if ((so->so_state & SS_ISCONNECTED) == 0)
	return (ENOTCONN);
d1204 21
a1224 9
#ifdef OldCode
    if ((m = m_getclr(M_DONTWAIT, MT_SONAME)) == 0)
	return (ENOBUFS);
#else
    if( (m = ALLOC_C(MINCONTIG, NULL)) == NULL )
    {
#ifdef DEBUG
	if( DODEBUG(DBGMMAN) )
	    Printf("getpeername: ALLOC_C failed\n");
d1226 6
a1231 7
	return(ENOBUFS);
    }
    m->m_type = MT_SONAME;
#endif

    error = copyin((char *)(up->alen), (caddr_t)&len, sizeof (len));
    if (error)
d1233 1
d1235 6
a1240 3
    error = (*so->so_proto->pr_usrreq)(so, PRU_PEERADDR, 0, m, 0);
    if (error)
	goto bad;
d1242 7
a1248 12
    if (len > m->m_len)
	len = m->m_len;

    error = copyout(mtod(m, caddr_t), (char *)(up->asa), (u_int)len);
    if (error)
	goto bad;

    error = copyout((caddr_t)&len, (char *)(up->alen), sizeof (len));

  bad:
#ifdef OldCode
    m_freem(m);
d1250 2
a1251 1
    FREEM(m);
a1252 1
    return (error);
d1255 4
a1258 1
static int sockargs(struct mbuf **aname, caddr_t name, int namelen, int type)
a1259 2
    struct mbuf *m;
    int error;
d1261 7
a1267 7
    if ((u_int)namelen > MINCONTIG)
	return (EINVAL);

#ifdef OldCode
    m = m_get(M_DONTWAIT, type);
    if (m == NULL)
	return (ENOBUFS);
d1269 2
a1270 5
    if( (m = ALLOC_S(MINCONTIG, NULL)) == NULL )
    {
#ifdef DEBUG
	if( DODEBUG(DBGMMAN) )
	    Printf("sockargs: ALLOC_S failed\n");
d1272 17
a1288 4
	return(ENOBUFS);
    }

    m->m_type = type;
d1290 17
a1306 9

    m->m_len = namelen;
    error = copyin(name, mtod(m, caddr_t), (u_int)namelen);
    if (error)
    {
#ifdef OldCode
	(void) m_free(m);
#else
	FREE(m);
d1308 4
a1311 5
    }
    else
	*aname = m;

    return (error);
d1314 1
d1323 1
d1329 3
a1331 1
    soclose(so);
d1333 3
a1335 1
    return (0);
d1338 12
a1349 1
socketioctl(int *r)
d1351 12
a1362 11
    struct a
    {
	int s;
	int cmd;
	char *cmarg;
    } *up = (struct a *)r;
    struct socket *so;
    int error = 0;
    int com;
    u_int size;
    char data[IOCPARM_MASK+1];
d1364 3
a1366 2
    if ((so = getsock(up->s)) == 0)
	return (EBADF);
d1368 6
a1373 1
    com = up->cmd;
d1375 2
a1376 8
    /*
     * Interpret high order word to find
     * amount of data to be copied to/from the
     * user's address space.
     */
    size = (com &~ (IOC_INOUT|IOC_VOID)) >> 16;
    if (size > sizeof (data))
	return (EFAULT);
d1378 7
a1384 7
    if (com & IOC_IN)
    {
	if (size)
	{
	    error = copyin(up->cmarg, (caddr_t)data, (u_int)size);
	    if (error)
		return(error);
d1386 1
a1386 3
	else
	    *(caddr_t *)data = up->cmarg;
    }
d1388 129
a1516 59
    else if ((com&IOC_OUT) && size)
	bzero((caddr_t)data, size);

    else if (com&IOC_VOID)
	*(caddr_t *)data = up->cmarg;

    switch (com)
    {
      case FIONBIO:
	if (*(int *)data)
	    so->so_state |= SS_NBIO;
	else
	    so->so_state &= ~SS_NBIO;

	goto out;

      case FIOASYNC:
	if (*(int *)data)
	    so->so_state |= SS_ASYNC;
	else
	    so->so_state &= ~SS_ASYNC;

	goto out;

      case FIORXDIR:
	if (*(int *)data)
	    so->so_state |= SS_RXDIRECT;
	else
	    so->so_state &= ~SS_RXDIRECT;

	goto out;

      case FIONREAD:
	*(int *)data = so->so_rcv.sb_cc;

	goto out;

      case SIOCATMARK:
	*(int *)data = (so->so_state & SS_RCVATMARK) != 0;

	goto out;
    }

#define cmdbyte(x)  (((x) >> 8) & 0xff)

    if (cmdbyte(com) == 'i')
	error = ifioctl(so, com, data);
    else if (cmdbyte(com) == 'r')
	error = rtioctl(com, data);
    else error = (*so->so_proto->pr_usrreq)(so, PRU_CONTROL,
					    (struct mbuf *)com,
					    (struct mbuf *)data,
					    (struct mbuf *)0);

  out:
    if (error == 0 && (com&IOC_OUT) && size)
	error = copyout(data, up->cmarg, (u_int)size);

    return (error);
d1519 13
a1531 1
socketread(int *r, int *rval)
d1533 4
a1536 9
    struct a
    {
	int s;
	char *cbuf;
	unsigned int count;
    } *up = (struct a *)r;
    struct uio auio;
    struct iovec aiov;
    struct socket *so;
d1538 2
a1539 2
    if ((so = getsock(up->s)) == 0)
	return (EBADF);
d1541 31
a1571 6
    aiov.iov_base = up->cbuf;
    aiov.iov_len = up->count;
    auio.uio_iov = &aiov;
    auio.uio_iovcnt = 1;

    return (rwuio(so, rval, &auio, UIO_READ));
d1574 12
a1585 1
socketreadv(int *r, int *rval)
d1587 10
a1596 10
    struct a
    {
	int s;
	struct iovec *iovp;
	unsigned int iovcnt;
    } *up = (struct a *)r;
    struct uio auio;
    struct iovec aiov[16];
    struct socket *so;
    int error;
d1598 58
a1655 11
    if ((so = getsock(up->s)) == 0)
	return (EBADF);

    if (up->iovcnt > sizeof(aiov)/sizeof(aiov[0]))
	return (EINVAL);

    auio.uio_iov = aiov;
    auio.uio_iovcnt = up->iovcnt;
    error = copyin((char *)up->iovp, (char *)aiov,
		   up->iovcnt * sizeof(struct iovec));
    if (error)
a1656 2

    return (rwuio(so, rval, &auio, UIO_READ));
d1659 12
a1670 1
socketwrite(int *r, int *rval)
d1672 12
a1683 9
    struct a
    {
	int s;
	char *cbuf;
	unsigned int count;
    } *up = (struct a *)r;
    struct uio auio;
    struct iovec aiov;
    struct socket *so;
d1685 47
a1731 9
    if ((so = getsock(up->s)) == 0)
	return (EBADF);

    aiov.iov_base = up->cbuf;
    aiov.iov_len = up->count;
    auio.uio_iov = &aiov;
    auio.uio_iovcnt = 1;

    return (rwuio(so, rval, &auio, UIO_WRITE));
d1734 12
a1745 1
socketwritev(int *r, int *rval)
d1747 10
a1756 10
    struct a
    {
	int s;
	struct iovec *iovp;
	unsigned int iovcnt;
    } *up = (struct a *)r;
    struct uio auio;
    struct iovec aiov[16];
    struct socket *so;
    int error;
d1758 60
a1817 11
    if ((so = getsock(up->s)) == 0)
	return (EBADF);

    if (up->iovcnt > sizeof(aiov)/sizeof(aiov[0]))
	return (EINVAL);

    auio.uio_iov = aiov;
    auio.uio_iovcnt = up->iovcnt;
    error = copyin((char *)up->iovp, (char *)aiov,
		   up->iovcnt * sizeof(struct iovec));
    if (error)
a1818 33

    return (rwuio(so, rval, &auio, UIO_WRITE));
}

static int rwuio(struct socket *so, int *rval, struct uio *uio, int flag)
{
    struct iovec *iov;
    int i, count, error;

    uio->uio_resid = 0;
    uio->uio_offset = 0;
    iov = uio->uio_iov;

    for (i = 0; i < uio->uio_iovcnt; i++)
    {
	if (iov->iov_len < 0)
	    return (EINVAL);

	uio->uio_resid += iov->iov_len;
	if (uio->uio_resid < 0)
	    return (EINVAL);

	iov++;
    }

    count = uio->uio_resid;
    if (flag == UIO_READ)
	error = soreceive(so, 0, uio, 0, 0);
    else
	error = sosend(so, 0, uio, 0, 0);

    *rval = count - uio->uio_resid;
    return (error);
d1821 1
d1831 2
a1832 2
    if ((so = getsock(up->s)) == 0)
	return (EBADF);
d1834 3
a1836 1
    return ((*so->so_proto->pr_usrreq)(so, PRU_SENSE,
d1843 1
d1850 7
a1856 5
socketselect(int *r, int *rval)
{
    struct a
    {
	int	nd;
d1859 54
a1912 10
    } *up = (struct a *)r;
    fd_set ibits[3], obits[3];
    struct timeval atv;
    int ni;
    int tried_once = 0;
    extern int unselect();
    int error = 0;

    bzero((caddr_t)ibits, sizeof(ibits));
    bzero((caddr_t)obits, sizeof(obits));
d1914 62
a1975 85
    if (up->nd > SOCKTABSIZE)
	up->nd = SOCKTABSIZE;

    ni = howmany(up->nd, NFDBITS);

    if (up->in)
    {
	error = copyin((caddr_t)up->in, (caddr_t)&ibits[0],
		       (unsigned)(ni * sizeof(fd_mask)));
	if (error)
	    goto done;
    }

    if (up->ou)
    {
	error = copyin((caddr_t)up->ou, (caddr_t)&ibits[1],
		       (unsigned)(ni * sizeof(fd_mask)));
	if (error)
	    goto done;
    }

    if (up->ex)
    {
	error = copyin((caddr_t)up->ex, (caddr_t)&ibits[2],
		       (unsigned)(ni * sizeof(fd_mask)));
	if (error)
	    goto done;
    }

    if (up->tv)
    {
	error = copyin((char *)(up->tv), (caddr_t)&atv,
		       sizeof (atv));
	if (error)
	    goto done;
    }

  retry:
    error = selscan(ibits, obits, up->nd, rval);
    if (error || *rval || tried_once)
	goto done;

    if (up->tv)
    {
	if (atv.tv_sec == 0 && atv.tv_usec == 0) /* just a poll really */
	    goto done;

	timeout(unselect, (caddr_t)0, hzto(&atv));
    }

    if (sleep((caddr_t)&selwait, PZERO+1) != 0)
	error = EINTR;

    if (up->tv)
    {
	untimeout(unselect, (caddr_t)0); /* cancel timeout here */
    }

    tried_once = 1;
    if (error)
	return (error);

    goto retry;

  done:
    if (error)
	return (error);

    if (up->in)
    {
	error = copyout((caddr_t)&obits[0], (caddr_t)up->in,
			(unsigned)(ni * sizeof(fd_mask)));
    }

    if (up->ou)
    {
	error = copyout((caddr_t)&obits[1], (caddr_t)up->ou,
			(unsigned)(ni * sizeof(fd_mask)));
    }

    if (up->ex)
    {
	error = copyout((caddr_t)&obits[2], (caddr_t)up->ex,
			(unsigned)(ni * sizeof(fd_mask)));
    }
d1980 4
a1983 1
unselect()
d1985 1
a1985 6
    wakeup((caddr_t)&selwait);
}

static int selscan(fd_set *ibits, fd_set *obits, int nfd, int *rval)
{
    int which, i, j;
d1987 1
a1987 1
    int flag, s, r;
d1989 1
d1991 4
a1994 23
    for (which = 0; which < 3; which++)
    {
	switch (which)
	{
	  case 0:
	    flag = FREAD;
	    break;

	  case 1:
	    flag = FWRITE;
	    break;

	  case 2:
	    flag = 0;
	    break;
	}

	for (i = 0; i < nfd; i += NFDBITS)
	{
	    bits = ibits[which].fds_bits[i/NFDBITS];

	    while ((j = ffs(bits)) && i + --j < nfd)
	    {
d1996 2
a1997 3
		s = i + j;
		r = do_sock_select(s, flag);
		if (r < 0)
d1999 3
a2001 4

		if (r == 1)
		{
		    FD_SET(s, &obits[which]);
a2003 3

		if (r < 0)
		    return (EBADF);
d2007 1
a2007 2

    *rval = n;
d2019 7
a2025 1
selwakeup(char *p, int coll)
d2027 14
a2040 1
    wakeup((caddr_t)&selwait);
d2043 6
a2048 1
static int do_sock_select(int d, int which)
d2050 12
a2061 11
    struct socket *so;

    if ((so = getsock(d)) == 0)
	return (-1);

    switch (which)
    {
      case FREAD:
	if (soreadable(so))
	{
	    return (1);
d2063 1
d2065 6
a2070 2
	sbselqueue(&so->so_rcv);
	break;
d2072 1
a2072 5
      case FWRITE:
	if (sowriteable(so))
	{
	    return (1);
	}
d2074 20
a2093 7
	sbselqueue(&so->so_snd);
	break;

      case 0:
	if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
	{
	    return (1);
d2095 1
a2095 6

	sbselqueue(&so->so_rcv);
	break;
    }

    return (0);
d2098 3
a2100 1
struct socket *getsock(int s)
d2102 2
a2103 2
    if (s < 0 || s >= SOCKTABSIZE)
	return ((struct socket *)0);
d2105 1
a2105 1
    return (socktab[s]);
d2119 1
a2119 1
int getsockslot(void)
a2127 8
}

void socktabinit(void)
{
    int i;

    for (i = 0; i < SOCKTABSIZE; i++)
	socktab[i] = 0;
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d15 5
a19 1
/*
d22 15
a48 2
#include "sys/kernel.h"
#include "sys/proc.h"
a49 7
#include "sys/signalvar.h"
#include "sys/systm.h"

#include "netinet/in.h"
#include "netinet/ip_var.h"
#include "netinet/udp.h"
#include "netinet/udp_var.h"
a51 1
#include "module.h"
d53 1
a53 2
/* KEEP IN LINE WITH CMHG FILE */
#define MODVERSION 503
d55 3
a57 12
struct socket *socktab[SOCKTABSIZE];

static int getsockslot(void);
static int do_sock_select(struct socket *so, int which);
static int selscan(fd_set *ibits, fd_set *obits, int nfd, int *retval, int *noblock);

int
socketversion(_kernel_swi_regs *r, int *retval)
{
    *retval = MODVERSION;
    return (0);
}
d64 1
a64 11
/* Should be in kern/uipc_sycall.c */
int
#ifdef __riscos
sendit(s, mp, flags, retsize)
#else
sendit(p, s, mp, flags, retsize)
	register struct proc *p;
#endif
	int s;
	register struct msghdr *mp;
	int flags, *retsize;
d66 36
a101 13
#ifndef __riscos
	struct file *fp;
#else
	struct socket *so;
#endif
	struct uio auio;
	register struct iovec *iov;
	register int i;
	struct mbuf *to, *control;
	int len, error;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
#endif
d103 4
a106 7
#ifdef __riscos
        if ((so = getsock(s)) == 0)
	        return (EBADF);
	else
		error = 0;
#else
	error = getsock(p->p_fd, s, &fp);
d108 10
a117 50
		return (error);
#endif
	auio.uio_iov = mp->msg_iov;
	auio.uio_iovcnt = mp->msg_iovlen;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_rw = UIO_WRITE;
#ifndef __riscos
	auio.uio_procp = p;
#endif
	auio.uio_offset = 0;			/* XXX */
	auio.uio_resid = 0;
	iov = mp->msg_iov;
	for (i = 0; i < mp->msg_iovlen; i++, iov++) {
		if ((auio.uio_resid += iov->iov_len) < 0)
			return (EINVAL);
	}
	if (mp->msg_name) {
		error = sockargs(&to, mp->msg_name, mp->msg_namelen, MT_SONAME);
		if (error)
			return (error);
	} else
		to = 0;
	if (mp->msg_control) {
		if (mp->msg_controllen < sizeof(struct cmsghdr)
#ifdef COMPAT_OLDSOCK
		    && mp->msg_flags != MSG_COMPAT
#endif
		) {
			error = EINVAL;
			goto bad;
		}
		error = sockargs(&control, mp->msg_control,
		    mp->msg_controllen, MT_CONTROL);
		if (error)
			goto bad;
#ifdef COMPAT_OLDSOCK
		if (mp->msg_flags == MSG_COMPAT) {
			register struct cmsghdr *cm;

			M_PREPEND(control, sizeof(*cm), M_WAIT);
			if (control == 0) {
				error = ENOBUFS;
				goto bad;
			} else {
				cm = mtod(control, struct cmsghdr *);
				cm->cmsg_len = control->m_len;
				cm->cmsg_level = SOL_SOCKET;
				cm->cmsg_type = SCM_RIGHTS;
			}
		}
a118 5
	} else
		control = 0;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO)) {
		int iovlen = auio.uio_iovcnt * sizeof (struct iovec);
d120 6
a125 8
		MALLOC(ktriov, struct iovec *, iovlen, M_TEMP, M_WAITOK);
		bcopy((caddr_t)auio.uio_iov, (caddr_t)ktriov, iovlen);
	}
#endif
	len = auio.uio_resid;
#ifdef __riscos
	error = sosend(so, to, &auio,
	    (struct mbuf *)0, control, flags);
d127 1
a127 2
	error = sosend((struct socket *)fp->f_data, to, &auio,
	    (struct mbuf *)0, control, flags);
d129 7
a135 7
	if (error) {
		if (auio.uio_resid != len && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
		if (error == EPIPE)
#ifdef __riscos
			psignal(pfind(so->so_pgid), SIGPIPE);
d137 1
a137 1
			psignal(p, SIGPIPE);
d139 2
a140 15
	}
	if (error == 0)
		*retsize = len - auio.uio_resid;
#ifdef KTRACE
	if (ktriov != NULL) {
		if (error == 0)
			ktrgenio(p->p_tracep, s, UIO_WRITE,
				ktriov, *retsize, error);
		FREE(ktriov, M_TEMP);
	}
#endif
bad:
	if (to)
		m_freem(to);
	return (error);
d143 2
a144 7
/* Should be in kern/uipc_syscall.c */
int
recvit(s, mp, namelenp, retsize)
	int s;
	register struct msghdr *mp;
	caddr_t namelenp;
	int *retsize;
a145 1
#ifdef __riscos
a146 3
#else
	struct file *fp;
#endif
d148 3
a150 2
	register struct iovec *iov;
	register int i;
a151 4
	struct mbuf *from = 0, *control = 0;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
#endif
d153 2
a154 11
#ifdef __riscos
        so = getsock(s);
        if (so == NULL)
                return (EBADF);
        else
        	error = 0;
#else
	error = getsock(p->p_fd, s, &fp);
	if (error)
		return (error);
#endif
d157 2
a158 6
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_rw = UIO_READ;
#ifndef __riscos
	auio.uio_procp = p;
#endif
	auio.uio_offset = 0;			/* XXX */
d162 1
a162 1
		if ((auio.uio_resid += iov->iov_len) < 0)
d164 1
a165 8
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO)) {
		int iovlen = auio.uio_iovcnt * sizeof (struct iovec);

		MALLOC(ktriov, struct iovec *, iovlen, M_TEMP, M_WAITOK);
		bcopy((caddr_t)auio.uio_iov, (caddr_t)ktriov, iovlen);
	}
#endif
d167 4
a170 23
#ifdef __riscos
	error = soreceive(so, &from, &auio,
#else
	error = soreceive((struct socket *)fp->f_data, &from, &auio,
#endif
	    (struct mbuf **)0, mp->msg_control ? &control : (struct mbuf **)0,
	    &mp->msg_flags);
	if (error) {
		if (auio.uio_resid != len && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
	}
#ifdef KTRACE
	if (ktriov != NULL) {
		if (error == 0)
			ktrgenio(p->p_tracep, s, UIO_READ,
				ktriov, len - auio.uio_resid, error);
		FREE(ktriov, M_TEMP);
	}
#endif
	if (error)
		goto out;
	*retsize = len - auio.uio_resid;
a175 5
#ifdef COMPAT_OLDSOCK
			if (mp->msg_flags & MSG_COMPAT)
				mtod(from, struct osockaddr *)->sa_family =
				    mtod(from, struct sockaddr *)->sa_family;
#endif
d178 1
a178 2
			/* else if len < from->m_len ??? */
			error = copyout(mtod(from, caddr_t),
a179 12
			if (error)
				goto out;
		}
		mp->msg_namelen = len;
		if (namelenp &&
		    (error = copyout((caddr_t)&len, namelenp, sizeof (int)))) {
#ifdef COMPAT_OLDSOCK
			if (mp->msg_flags & MSG_COMPAT)
				error = 0;	/* old recvfrom didn't check */
			else
#endif
			goto out;
d181 1
d183 3
a185 23
	if (mp->msg_control) {
#ifdef COMPAT_OLDSOCK
		/*
		 * We assume that old recvmsg calls won't receive access
		 * rights and other control info, esp. as control info
		 * is always optional and those options didn't exist in 4.3.
		 * If we receive rights, trim the cmsghdr; anything else
		 * is tossed.
		 */
		if (control && mp->msg_flags & MSG_COMPAT) {
			if (mtod(control, struct cmsghdr *)->cmsg_level !=
			    SOL_SOCKET ||
			    mtod(control, struct cmsghdr *)->cmsg_type !=
			    SCM_RIGHTS) {
				mp->msg_controllen = 0;
				goto out;
			}
			control->m_len -= sizeof (struct cmsghdr);
			control->m_off += sizeof (struct cmsghdr);
		}
#endif
		len = mp->msg_controllen;
		if (len <= 0 || control == 0)
d188 4
a191 6
			if (len >= control->m_len)
				len = control->m_len;
			else
				mp->msg_flags |= MSG_CTRUNC;
			error = copyout((caddr_t)mtod(control, caddr_t),
			    (caddr_t)mp->msg_control, (unsigned)len);
d193 1
a193 1
		mp->msg_controllen = len;
d195 3
a197 1
out:
d200 7
a206 2
	if (control)
		m_freem(control);
d210 1
a210 9
struct socket_args {
	int	domain;
	int	type;
	int	protocol;
};
int
socket(uap, retval)
	register struct socket_args *uap;
	int *retval;
d212 12
a223 2
	struct socket *so;
	int fd, error;
d225 2
a226 11
	fd = getsockslot();
	if (fd < 0)
		return (EMFILE);
	error = socreate(uap->domain, &so, uap->type, uap->protocol);
	if (error) {
		/* Do nothing */
	} else {
		*retval = fd;
		setsockslot(fd, so);
		so->so_pgid = fd+1;
	}
d228 5
d235 1
a235 9
struct bind_args {
	int	s;
	caddr_t	name;
	int	namelen;
};
/* ARGSUSED */
int
bind(uap)
	register struct bind_args *uap;
d237 12
a248 3
	struct socket *so;
	struct mbuf *nam;
	int error;
d250 2
a251 7
	if ((so = getsock(uap->s)) == 0)
		return (EBADF);
	error = sockargs(&nam, uap->name, uap->namelen, MT_SONAME);
	if (error)
		return (error);
	error = sobind(so, nam);
	m_freem(nam);
d253 8
d263 1
a263 9
struct listen_args {
	int	s;
	int	backlog;
};
/* ARGSUSED */
int
listen(uap, retval)
	register struct listen_args *uap;
	int *retval;
d265 7
a271 1
	struct socket *so;
d273 3
a275 3
	so = getsock(uap->s);
	if (so == 0)
		return (EBADF);
d277 2
a278 1
	return (solisten(so, uap->backlog));
d281 23
a303 32
struct accept_args {
	int	s;
	caddr_t	name;
	int	*anamelen;
#ifdef COMPAT_OLDSOCK
	int	compat_43;	/* pseudo */
#endif
};

#ifndef COMPAT_OLDSOCK
#  define	accept1	accept
#endif  /* COMPAT_OLDSOCK*/
int
accept1(uap, retval)
	register struct accept_args *uap;
	int *retval;
{
	struct mbuf *nam;
	int namelen, error, sockid;
	register struct socket *so;

	if (uap->name) {
		error = copyin((caddr_t)uap->anamelen, (caddr_t)&namelen,
			sizeof (namelen));
		if(error)
			return (error);
	}
	so = getsock(uap->s);
	if (so == 0)
		return (EBADF);
	else
		error = 0;
d305 2
a306 2
	if ((so->so_options & SO_ACCEPTCONN) == 0)
		return (EINVAL);
d308 2
a309 2
	if ((so->so_state & SS_NBIO) && so->so_qlen == 0)
		return (EWOULDBLOCK);
d311 6
a316 9
	while (so->so_qlen == 0 && so->so_error == 0) {
		if (so->so_state & SS_CANTRCVMORE) {
			so->so_error = ECONNABORTED;
			break;
		}
		error = tsleep((caddr_t)&so->so_timeo, PSOCK | PCATCH,
		    netcon, 0, so->so_state & SS_SLEEPTW);
		if (error)
			return (error);
d319 4
a322 4
	if (so->so_error) {
		error = so->so_error;
		so->so_error = 0;
		return (error);
d324 6
a329 35
	sockid = getsockslot();
	if (sockid < 0)
		return (EBADF);
	{ struct socket *aso = so->so_q;
	  if (soqremque(aso, 1) == 0) {
		panic("accept");
		return (EFAULT);
	  }
	  so = aso;
	}
	nam = m_get(M_WAIT, MT_SONAME);
	if (nam == NULL)
		return (ENOBUFS);
	(void) soaccept(so, nam);

	setsockslot(sockid, so);
	so->so_pgid = sockid+1;
	*retval = sockid;

	if (uap->name) {
#ifdef COMPAT_OLDSOCK
		if (uap->compat_43)
			mtod(nam, struct osockaddr *)->sa_family =
			    mtod(nam, struct sockaddr *)->sa_family;
#endif
		if (namelen > nam->m_len)
			namelen = nam->m_len;
		/* SHOULD COPY OUT A CHAIN HERE */
		error = copyout(mtod(nam, caddr_t), (caddr_t)(uap->name),
		    (u_int)namelen);
		if (!error)
			error = copyout((caddr_t)&namelen,
			    (caddr_t)(uap->anamelen), sizeof (*uap->anamelen));
	}
	m_freem(nam);
d331 1
a331 1
}
d333 12
a344 14
#ifdef COMPAT_OLDSOCK
int
accept(uap, retval)
	struct accept_args *uap;
	int *retval;
{

#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 0;
	error = accept1(uap, retval);
	uap->compat_43 = temp;
	return (error);
d346 5
a350 2
	uap->compat_43 = 0;
	return (accept1(uap, retval));
d352 28
a379 1
}
d381 4
a384 5
int
oaccept(uap, retval)
	struct accept_args *uap;
	int *retval;
{
d386 5
a390 7
#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 1;
	error = accept1(uap, retval);
	uap->compat_43 = temp;
	return (error);
d392 1
a392 2
	uap->compat_43 = 1;
	return (accept1(uap, retval));
d394 3
a397 1
#endif /* COMPAT_OLDSOCK */
d400 14
a413 13
struct connect_args {
	int	s;
	caddr_t	name;
	int	namelen;
};
/* ARGSUSED */
int
connect(uap)
	register struct connect_args *uap;
{
	register struct socket *so;
	struct mbuf *nam;
	int error;
d415 2
a416 3
	so = getsock(uap->s);
	if (so == 0)
		return (EBADF);
d418 3
a420 2
	if ((so->so_state & SS_NBIO) && (so->so_state & SS_ISCONNECTING))
		return (EALREADY);
d422 2
a423 5
	error = sockargs(&nam, uap->name, uap->namelen, MT_SONAME);
	if (error)
		return (error);
	error = soconnect(so, nam);
	if (error)
d425 4
a428 16
	if ((so->so_state & SS_NBIO) && (so->so_state & SS_ISCONNECTING)) {
		m_freem(nam);
		return (EINPROGRESS);
	}
	while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) {
		error = tsleep((caddr_t)&so->so_timeo, PSOCK | PCATCH,
		    netcon, 0, so->so_state & SS_SLEEPTW);
		if (error)
			break;
	}
	if (error == 0) {
		error = so->so_error;
		so->so_error = 0;
	}
bad:
	so->so_state &= ~SS_ISCONNECTING;
d430 23
a452 3
	if (error == ERESTART)
		error = EINTR;
	return (error);
d455 1
a455 11
struct sendtosm_args {
	int      s;
	caddr_t *buf;
	u_int    len;
	caddr_t *buf1;
	u_int    len1;
	caddr_t  to;
};
int
sendtosm(uap)
	struct sendtosm_args *uap;
d457 19
a475 3
	struct socket *so;
	struct mbuf *to, *m, *n;
	int error;
d477 1
a477 3
	so = getsock(uap->s);
    	if (so == 0)
		return (EBADF);
d479 2
a480 3
    	error = sockargs(&to, uap->to, sizeof(struct sockaddr), MT_SONAME);
    	if (error)
		return (error);
d482 5
a486 1
    	m = 0; n = 0;
d488 7
a494 2
    	m = ALLOC_U(uap->len, uap->buf);
    	if (m == NULL) {
d496 2
a497 2
		if (DODEBUG(DBGMMAN))
	    		Printf("sosendsm: ALLOC_U#1 failed\n");
d499 26
a524 11
		error = ENOBUFS;
		goto release;
    	}
    	m->m_type = MT_DATA;
    	m->m_flags = M_PKTHDR;
    	m->m_pkthdr.len = uap->len;
    	m->m_pkthdr.rcvif = (struct ifnet *) 0;

	if (uap->len1 > 0) {
		n = ALLOC_U(uap->len1, uap->buf1);
		if (n == NULL) {
d526 2
a527 2
	    		if (DODEBUG(DBGMMAN))
				Printf("sosendsm: ALLOC_U#2 failed\n");
d529 3
a531 3
	    		error = ENOBUFS;
	    		goto release;
		}
d533 4
a536 5
		n->m_type = MT_DATA;
		n->m_flags = 0;
		m->m_pkthdr.len += uap->len1;
    	        m->m_next = n;
    	}
d538 8
a545 2
    	error = udp_usrreq(so, PRU_SEND, m, to, 0);
    	m = 0;
d547 4
a550 3
release:
    	if (m)
		m_freem(m);
d552 3
a554 2
    	m_freem(to);
    	return (error);
d557 4
a560 1
struct sendto_args {
d562 2
a563 2
	caddr_t	buf;
	size_t	len;
d565 1
a565 1
	caddr_t	to;
d567 12
a578 17
};
int
sendto(register struct sendto_args *uap, int *retval)
{
        struct msghdr msg;
        struct iovec aiov;

        msg.msg_name = uap->to;
        msg.msg_namelen = uap->tolen;
        msg.msg_iov = &aiov;
        msg.msg_iovlen = 1;
	msg.msg_control = 0;
#ifdef COMPAT_OLDSOCK
	msg.msg_flags = 0;
#endif
        aiov.iov_base = uap->buf;
        aiov.iov_len = uap->len;
d580 1
a580 1
        /* TRACE */
d582 1
a582 1
        Printf("sendit: %d bytes to '%.*s'\n", uap->len, uap->tolen, uap->to);
d585 1
a585 1
        return (sendit(uap->s, &msg, uap->flags, retval));
d588 11
a598 25
#ifdef COMPAT_OLDSOCK
struct osend_args {
	int	s;
	caddr_t	buf;
	int	len;
	int	flags;
};
int
osend(uap, retval)
	register struct osend_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov;

	msg.msg_name = 0;
	msg.msg_namelen = 0;
	msg.msg_iov = &aiov;
	msg.msg_iovlen = 1;
	aiov.iov_base = uap->buf;
	aiov.iov_len = uap->len;
	msg.msg_control = 0;
	msg.msg_flags = 0;
	return (sendit(uap->s, &msg, uap->flags, retval));
}
d600 23
a622 13
struct osendmsg_args {
	int	s;
	caddr_t	msg;
	int	flags;
};
int
osendmsg(uap, retval)
	register struct osendmsg_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov[UIO_SMALLIOV], *iov;
	int error;
d624 2
a625 23
	error = copyin(uap->msg, (caddr_t)&msg, sizeof (struct omsghdr));
	if (error)
		return (error);
	if ((u_int)msg.msg_iovlen >= UIO_SMALLIOV) {
		if ((u_int)msg.msg_iovlen >= UIO_MAXIOV)
			return (EMSGSIZE);
		MALLOC(iov, struct iovec *,
		      sizeof(struct iovec) * (u_int)msg.msg_iovlen, M_IOV,
		      M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
	} else
		iov = aiov;
	error = copyin((caddr_t)msg.msg_iov, (caddr_t)iov,
	    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)));
	if (error)
		goto done;
	msg.msg_flags = MSG_COMPAT;
	msg.msg_iov = iov;
	error = sendit(uap->s, &msg, uap->flags, retval);
done:
	if (iov != aiov)
		FREE(iov, M_IOV);
a626 2
}
#endif
d628 2
a629 13
struct sendmsg_args {
	int	s;
	caddr_t	msg;
	int	flags;
};
int
sendmsg(uap, retval)
	register struct sendmsg_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov[UIO_SMALLIOV], *iov;
	int error;
d631 3
a633 25
	error = copyin(uap->msg, (caddr_t)&msg, sizeof (msg));
	if (error)
		return (error);
	if ((u_int)msg.msg_iovlen >= UIO_SMALLIOV) {
		if ((u_int)msg.msg_iovlen >= UIO_MAXIOV)
			return (EMSGSIZE);
		MALLOC(iov, struct iovec *,
		       sizeof(struct iovec) * (u_int)msg.msg_iovlen, M_IOV,
		       M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
	} else
		iov = aiov;
	if (msg.msg_iovlen &&
	    (error = copyin((caddr_t)msg.msg_iov, (caddr_t)iov,
	    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)))))
		goto done;
	msg.msg_iov = iov;
#ifdef COMPAT_OLDSOCK
	msg.msg_flags = 0;
#endif
	error = sendit(uap->s, &msg, uap->flags, retval);
done:
	if (iov != aiov)
		FREE(iov, M_IOV);
d635 3
d640 4
a643 1
struct recvfrom_args {
d645 2
a646 2
	caddr_t	buf;
	size_t	len;
d648 1
a648 1
	caddr_t	from;
d650 17
a666 1
};
d668 5
a672 2
int
recvfrom(register struct recvfrom_args *uap, int *retval)
d674 18
a691 3
    	struct msghdr msg;
    	struct iovec aiov;
    	int error;
d693 1
a693 15
	if (uap->fromlenaddr) {
		error = copyin((caddr_t)uap->fromlenaddr,
		    (caddr_t)&msg.msg_namelen, sizeof (msg.msg_namelen));
		if (error)
			return (error);
	} else
		msg.msg_namelen = 0;
	msg.msg_name = uap->from;
	msg.msg_iov = &aiov;
	msg.msg_iovlen = 1;
	aiov.iov_base = uap->buf;
	aiov.iov_len = uap->len;
	msg.msg_control = 0;
	msg.msg_flags = uap->flags;
	return (recvit(uap->s, &msg, (caddr_t)uap->fromlenaddr, retval));
d696 1
a696 5
#ifdef COMPAT_OLDSOCK
int
orecvfrom(uap, retval)
	struct recvfrom_args *uap;
	int *retval;
d698 14
d713 3
a715 4
	uap->flags |= MSG_COMPAT;
	return (recvfrom(uap, retval));
}
#endif
d717 4
d722 3
a724 24
#ifdef COMPAT_OLDSOCK
struct orecv_args {
	int	s;
	caddr_t	buf;
	int	len;
	int	flags;
};
int
orecv(uap, retval)
	register struct orecv_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov;

	msg.msg_name = 0;
	msg.msg_namelen = 0;
	msg.msg_iov = &aiov;
	msg.msg_iovlen = 1;
	aiov.iov_base = uap->buf;
	aiov.iov_len = uap->len;
	msg.msg_control = 0;
	msg.msg_flags = uap->flags;
	return (recvit(uap->s, &msg, (caddr_t)0, retval));
d727 11
a737 18
/*
 * Old recvmsg.  This code takes advantage of the fact that the old msghdr
 * overlays the new one, missing only the flags, and with the (old) access
 * rights where the control fields are now.
 */
struct orecvmsg_args {
	int	s;
	struct	omsghdr *msg;
	int	flags;
};
int
orecvmsg(uap, retval)
	register struct orecvmsg_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov[UIO_SMALLIOV], *iov;
	int error;
d739 1
a739 29
	error = copyin((caddr_t)uap->msg, (caddr_t)&msg,
	    sizeof (struct omsghdr));
	if (error)
		return (error);
	if ((u_int)msg.msg_iovlen >= UIO_SMALLIOV) {
		if ((u_int)msg.msg_iovlen >= UIO_MAXIOV)
			return (EMSGSIZE);
		MALLOC(iov, struct iovec *,
		      sizeof(struct iovec) * (u_int)msg.msg_iovlen, M_IOV,
		      M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
	} else
		iov = aiov;
	msg.msg_flags = uap->flags | MSG_COMPAT;
	error = copyin((caddr_t)msg.msg_iov, (caddr_t)iov,
	    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)));
	if (error)
		goto done;
	msg.msg_iov = iov;
	error = recvit(uap->s, &msg, (caddr_t)&uap->msg->msg_namelen, retval);

	if (msg.msg_controllen && error == 0)
		error = copyout((caddr_t)&msg.msg_controllen,
		    (caddr_t)&uap->msg->msg_accrightslen, sizeof (int));
done:
	if (iov != aiov)
		FREE(iov, M_IOV);
	return (error);
d741 15
d758 11
a768 13
struct recvmsg_args {
	int	s;
	struct	msghdr *msg;
	int	flags;
};
int
recvmsg(uap, retval)
	register struct recvmsg_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov[UIO_SMALLIOV], *uiov, *iov;
	register int error;
d770 1
a770 1
	error = copyin((caddr_t)uap->msg, (caddr_t)&msg, sizeof (msg));
d772 2
a773 13
		return (error);
	if ((u_int)msg.msg_iovlen >= UIO_SMALLIOV) {
		if ((u_int)msg.msg_iovlen >= UIO_MAXIOV)
			return (EMSGSIZE);
		MALLOC(iov, struct iovec *,
		       sizeof(struct iovec) * (u_int)msg.msg_iovlen, M_IOV,
		       M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
	} else
		iov = aiov;
#ifdef COMPAT_OLDSOCK
	msg.msg_flags = uap->flags &~ MSG_COMPAT;
d775 5
a779 1
	msg.msg_flags = uap->flags;
d781 1
a781 10
	uiov = msg.msg_iov;
	msg.msg_iov = iov;
	error = copyin((caddr_t)uiov, (caddr_t)iov,
	    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)));
	if (error)
		goto done;
	error = recvit(uap->s, &msg, (caddr_t)0, retval);
	if (!error) {
		msg.msg_iov = uiov;
		error = copyout((caddr_t)&msg, (caddr_t)uap->msg, sizeof(msg));
d783 11
a793 4
done:
	if (iov != aiov)
		FREE(iov, M_IOV);
	return (error);
d796 1
a796 7
struct shutdown_args {
	int	s;
	int	how;
};
int
shutdown(uap)
	register struct shutdown_args *uap;
d798 14
a811 1
	struct socket *so;
d813 9
a821 3
	so = getsock(uap->s);
	if (so == NULL)
		return (EBADF);
d823 3
a825 2
	return (soshutdown(so, uap->how));
}
d827 4
a830 16
struct setsockopt_args {
	int	s;
	int	level;
	int	name;
	caddr_t	val;
	int	valsize;
};
/* ARGSUSED */
int
setsockopt(uap, retval)
	register struct setsockopt_args *uap;
	int *retval;
{
	struct socket *so;
	struct mbuf *m = NULL;
	int error;
d832 3
a834 3
	so = getsock(uap->s);
	if (so == NULL)
		return (EBADF);
d836 3
a838 15
	if (uap->valsize > MINCONTIG)
		return (EINVAL);
	if (uap->val) {
		m = ALLOC_S(uap->valsize, NULL);
		if (m == NULL)
			return (ENOBUFS);
		m->m_type = MT_SOOPTS;
		error = copyin(uap->val, mtod(m, caddr_t), (u_int)uap->valsize);
		if (error) {
			(void) m_free(m);
			return (error);
		}
	}
	return (sosetopt(so, uap->level, uap->name, m));
}
d840 9
a848 16
struct getsockopt_args {
	int	s;
	int	level;
	int	name;
	caddr_t	val;
	int	*avalsize;
};
/* ARGSUSED */
int
getsockopt(uap, retval)
	register struct getsockopt_args *uap;
	int *retval;
{
	struct socket *so;
	struct mbuf *m = NULL, *m0;
	int op, i, valsize, error;
d850 1
a850 29
	so = getsock(uap->s);
	if (so == NULL)
		return (EBADF);
	if (uap->val) {
		error = copyin((caddr_t)uap->avalsize, (caddr_t)&valsize,
		    sizeof (valsize));
		if (error)
			return (error);
	} else
		valsize = 0;
	if ((error = sogetopt(so, uap->level,
	    uap->name, &m)) == 0 && uap->val && valsize && m != NULL) {
		op = 0;
		while (m && !error && op < valsize) {
			i = min(m->m_len, (valsize - op));
			error = copyout(mtod(m, caddr_t), uap->val, (u_int)i);
			op += i;
			uap->val += i;
			m0 = m;
			MFREE(m0,m);
		}
		valsize = op;
		if (error == 0)
			error = copyout((caddr_t)&valsize,
			    (caddr_t)uap->avalsize, sizeof (valsize));
	}
	if (m != NULL)
		(void) m_free(m);
	return (error);
d856 1
a856 18
struct getsockname_args {
	int	fdes;
	caddr_t	asa;
	int	*alen;
#ifdef COMPAT_OLDSOCK
	int	compat_43;	/* pseudo */
#endif
};

#ifndef COMPAT_OLDSOCK
#define	getsockname1	getsockname
#endif

/* ARGSUSED */
int
getsockname1(uap, retval)
	register struct getsockname_args *uap;
	int *retval;
d858 12
a869 3
	register struct socket *so;
	struct mbuf *m;
	int len, error;
d871 2
a872 26
	so = getsock(uap->fdes);
	if (so == NULL)
		return (EBADF);
	error = copyin((caddr_t)uap->alen, (caddr_t)&len, sizeof (len));
	if (error)
		return (error);
	m = ALLOC_C(0, NULL);
	if (m == NULL)
		return (ENOBUFS);
	m->m_type = MT_SONAME;
	error = (*so->so_proto->pr_usrreq)(so, PRU_SOCKADDR, 0, m, 0);
	if (error)
		goto bad;
	if (len > m->m_len)
		len = m->m_len;
#ifdef COMPAT_OLDSOCK
	if (uap->compat_43)
		mtod(m, struct osockaddr *)->sa_family =
		    mtod(m, struct sockaddr *)->sa_family;
#endif
	error = copyout(mtod(m, caddr_t), (caddr_t)uap->asa, (u_int)len);
	if (error == 0)
		error = copyout((caddr_t)&len, (caddr_t)uap->alen,
		    sizeof (len));
bad:
	m_freem(m);
a873 1
}
d875 12
a886 6
#ifdef COMPAT_OLDSOCK
int
getsockname(uap, retval)
	struct getsockname_args *uap;
	int *retval;
{
d888 1
a888 10
#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 0;
	error = getsockname1(uap, retval);
	uap->compat_43 = temp;
	return (error);
#else
	uap->compat_43 = 0;
	return (getsockname1(uap, retval));
a889 1
}
d891 12
a902 5
int
ogetsockname(uap, retval)
	struct getsockname_args *uap;
	int *retval;
{
d904 3
a906 7
#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 1;
	error = getsockname1(uap, retval);
	uap->compat_43 = temp;
	return (error);
d908 1
a908 2
	uap->compat_43 = 1;
	return (getsockname1(uap, retval));
d910 1
a911 1
#endif /* COMPAT_OLDSOCK */
d916 31
a946 6
struct getpeername_args {
	int	fdes;
	caddr_t	asa;
	int	*alen;
#ifdef COMPAT_OLDSOCK
	int	compat_43;	/* pseudo */
a947 1
};
d949 3
d953 3
a955 3
#ifndef COMPAT_OLDSOCK
#define	getpeername1	getpeername
#endif
d957 2
a958 9
/* ARGSUSED */
int
getpeername1(uap, retval)
	register struct getpeername_args *uap;
	int *retval;
{
	register struct socket *so;
	struct mbuf *m;
	int len, error;
d960 3
a962 30
	so = getsock(uap->fdes);
	if (so == NULL)
		return (EBADF);
	if ((so->so_state & (SS_ISCONNECTED|SS_ISCONFIRMING)) == 0)
		return (ENOTCONN);
	error = copyin((caddr_t)uap->alen, (caddr_t)&len, sizeof (len));
	if (error)
		return (error);
	m = ALLOC_C(0, NULL);
	if (m == NULL)
		return (ENOBUFS);
	m->m_type = MT_SONAME;
	error = (*so->so_proto->pr_usrreq)(so, PRU_PEERADDR, 0, m, 0);
	if (error)
		goto bad;
	if (len > m->m_len)
		len = m->m_len;
#ifdef COMPAT_OLDSOCK
	if (uap->compat_43)
		mtod(m, struct osockaddr *)->sa_family =
		    mtod(m, struct sockaddr *)->sa_family;
#endif
	error = copyout(mtod(m, caddr_t), (caddr_t)uap->asa, (u_int)len);
	if (error)
		goto bad;
	error = copyout((caddr_t)&len, (caddr_t)uap->alen, sizeof (len));
bad:
	m_freem(m);
	return (error);
}
d964 1
a964 6
#ifdef COMPAT_OLDSOCK
int
getpeername(uap, retval)
	struct getpeername_args *uap;
	int *retval;
{
d966 3
a968 7
#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 0;
	error = getpeername1(uap, retval);
	uap->compat_43 = temp;
	return (error);
d970 1
a970 2
	uap->compat_43 = 0;
	return (getpeername1(uap, retval));
d972 1
d975 1
a975 4
int
ogetpeername(uap, retval)
	struct getpeername_args *uap;
	int *retval;
d977 5
d983 4
a986 7
#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 1;
	error = getpeername1(uap, retval);
	uap->compat_43 = temp;
	return (error);
d988 5
a992 2
	uap->compat_43 = 1;
	return (getpeername1(uap, retval));
d994 4
a997 17
}
#endif /* COMPAT_OLDSOCK */
int
sockargs(mp, buf, buflen, type)
	struct mbuf **mp;
	caddr_t buf;
	int buflen, type;
{
	register struct sockaddr *sa;
	register struct mbuf *m;
	int error;

	if ((u_int)buflen > MINCONTIG) {
#if defined(COMPAT_OLDSOCK) && !defined(__riscos)
		if (type == MT_SONAME && (u_int)buflen <= 112)
			buflen = MLEN;		/* unix domain compat. hack */
		else
d999 9
a1007 17
		return (EINVAL);
	}
	m = ALLOC(buflen, NULL);
	if (m == NULL)
		return (ENOBUFS);
	m->m_type = type;
	error = copyin(buf, mtod(m, caddr_t), (u_int)buflen);
	if (error)
		m_free(m);
	else {
		*mp = m;
		if (type == MT_SONAME) {
			sa = mtod(m, struct sockaddr *);

#if defined(COMPAT_OLDSOCK) && BYTE_ORDER != BIG_ENDIAN
			if (sa->sa_family == 0 && sa->sa_len < AF_MAX)
				sa->sa_family = sa->sa_len;
d1009 5
a1013 4
			sa->sa_len = buflen;
		}
	}
	return (error);
a1015 1
int
a1023 1
    int error;
d1029 1
a1029 3
    /* KJB - stop events going off after close */
    so->so_pgid = 0;
    error = soclose(so);
d1031 1
a1031 3
    siglist[sockid] = 0;

    return (error);
d1034 1
a1034 12
/*
 * Ioctl system call
 */
struct ioctl_args {
	int	fd;
	int	com;
	caddr_t	data;
};
/* ARGSUSED */
int
socketioctl(uap)
	register struct ioctl_args *uap;
d1036 11
a1046 12
#ifdef __riscos
	register struct socket *so;
#else
	register struct file *fp;
	register struct filedesc *fdp;
	int tmp;
#endif
	register int com, error;
	register u_int size;
	caddr_t data, memp;
#define STK_PARAMS	128
	char stkbuf[STK_PARAMS];
d1048 2
a1049 3
#ifdef __riscos
	if ((so = getsock(uap->fd)) == 0)
		return (EBADF);
d1051 1
a1051 6
	com = uap->com;
#else
	fdp = p->p_fd;
	if ((u_int)uap->fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[uap->fd]) == NULL)
		return (EBADF);
d1053 8
a1060 2
	if ((fp->f_flag & (FREAD | FWRITE)) == 0)
		return (EBADF);
d1062 7
a1068 7
	switch (com = uap->com) {
	case FIONCLEX:
		fdp->fd_ofileflags[uap->fd] &= ~UF_EXCLOSE;
		return (0);
	case FIOCLEX:
		fdp->fd_ofileflags[uap->fd] |= UF_EXCLOSE;
		return (0);
d1070 84
a1153 1
#endif
d1155 1
a1155 129
	/*
	 * Interpret high order word to find amount of data to be
	 * copied to/from the user's address space.
	 */
	size = IOCPARM_LEN(com);
	if (size > IOCPARM_MAX)
		return (ENOTTY);
	memp = NULL;
#ifdef COMPAT_IBCS2
	if (size + IBCS2_RETVAL_SIZE > sizeof (stkbuf)) {
		memp = (caddr_t)malloc((u_long)size + IBCS2_RETVAL_SIZE,
				       M_IOCTLOPS, M_WAITOK);
		if (memp==0)
			return (ENOBUFS);
		data = memp + IBCS2_RETVAL_SIZE;
	} else
		data = stkbuf + IBCS2_RETVAL_SIZE;
	*(int *)(data - IBCS2_RETVAL_SIZE) = IBCS2_MAGIC_IN;
	*(int *)(data - (IBCS2_RETVAL_SIZE - sizeof(int))) = 0;
	*(int *)(data - (IBCS2_RETVAL_SIZE - 2*sizeof(int))) = 0;
#else
	if (size > sizeof (stkbuf)) {
		memp = (caddr_t)malloc((u_long)size, M_IOCTLOPS, M_WAITOK);
		if (memp==0)
			return (ENOBUFS);
		data = memp;
	} else
		data = stkbuf;
#endif
	if (com&IOC_IN) {
		if (size) {
			error = copyin(uap->data, data, (u_int)size);
			if (error) {
				if (memp)
					free(memp, M_IOCTLOPS);
				return (error);
			}
		} else
			*(caddr_t *)data = uap->data;
	} else if ((com&IOC_OUT) && size)
		/*
		 * Zero the buffer so the user always
		 * gets back something deterministic.
		 */
		bzero(data, size);
	else if (com&IOC_VOID)
		*(caddr_t *)data = uap->data;
#ifdef COMPAT_IBCS2
	else if (com)
		/*
		 * Pick up such things as NIOCxx.
		 * Any copyouts will have to be done prior
		 * to return by their servicing code.
		 */
		*(caddr_t *)data = uap->data;
#endif

	switch (com) {
#ifndef __riscos
	case FIONBIO:
		if ((tmp = *(int *)data))
			fp->f_flag |= FNONBLOCK;
		else
			fp->f_flag &= ~FNONBLOCK;
		error = (*fp->f_ops->fo_ioctl)(fp, FIONBIO, (caddr_t)&tmp, p);
		break;

	case FIOASYNC:
		if ((tmp = *(int *)data))
			fp->f_flag |= FASYNC;
		else
			fp->f_flag &= ~FASYNC;
		error = (*fp->f_ops->fo_ioctl)(fp, FIOASYNC, (caddr_t)&tmp, p);
		break;

	case FIOSETOWN:
		tmp = *(int *)data;
		if (fp->f_type == DTYPE_SOCKET) {
			((struct socket *)fp->f_data)->so_pgid = tmp;
			error = 0;
			break;
		}
		if (tmp <= 0) {
			tmp = -tmp;
		} else {
			struct proc *p1 = pfind(tmp);
			if (p1 == 0) {
				error = ESRCH;
				break;
			}
			tmp = p1->p_pgrp->pg_id;
		}
		error = (*fp->f_ops->fo_ioctl)
			(fp, (int)TIOCSPGRP, (caddr_t)&tmp, p);
		break;

	case FIOGETOWN:
		if (fp->f_type == DTYPE_SOCKET) {
			error = 0;
			*(int *)data = ((struct socket *)fp->f_data)->so_pgid;
			break;
		}
		error = (*fp->f_ops->fo_ioctl)(fp, (int)TIOCGPGRP, data, p);
		*(int *)data = -*(int *)data;
		break;
#endif
	default:
#ifdef __riscos
		error = soo_ioctl(so, com, data);
#else
		error = (*fp->f_ops->fo_ioctl)(fp, com, data, p);
#endif
		/*
		 * Copy any data to user, size was
		 * already set and checked above.
		 */
		if (error == 0 && (com&IOC_OUT) && size)
			error = copyout(data, uap->data, (u_int)size);
		break;
	}
#ifdef COMPAT_IBCS2
	if ((*(int *)(data - IBCS2_RETVAL_SIZE)) == IBCS2_MAGIC_OUT) {
		retval[0] = *(int *)(data-(IBCS2_RETVAL_SIZE - sizeof(int)));
		retval[1] = *(int *)(data-(IBCS2_RETVAL_SIZE - 2*sizeof(int)));
	}
#endif
	if (memp)
		free(memp, M_IOCTLOPS);
	return (error);
d1158 1
a1158 13
/*
 * Read system call.
 */
struct read_args {
	int	fd;
	char	*buf;
	u_int	nbyte;
};
/* ARGSUSED */
int
socketread(uap, retval)
	register struct read_args *uap;
	int *retval;
d1160 13
a1172 4
	struct uio auio;
	struct iovec aiov;
	struct socket *so;
    	long cnt, error = 0;
d1174 2
a1175 2
	if ((so = getsock(uap->fd)) == 0)
		return (EBADF);
d1177 5
a1181 30
        aiov.iov_base = (caddr_t)uap->buf;
	aiov.iov_len = uap->nbyte;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;

	auio.uio_resid = uap->nbyte;
	if (auio.uio_resid < 0)
		return (EINVAL);

	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_USERSPACE;
#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO))
		ktriov = aiov;
#endif
	cnt = uap->nbyte;
	if ((error = soreceive(so, (struct mbuf **)0, &auio,
	       (struct mbuf **)0, (struct mbuf **)0, (int *)0)))
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
	cnt -= auio.uio_resid;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO) && error == 0)
		ktrgenio(p->p_tracep, uap->fd, UIO_READ, &ktriov, cnt, error);
#endif
	*retval = cnt;
d1183 2
d1187 1
a1187 12
/*
 * Scatter read system call.
 */
struct readv_args {
	int	fdes;
	struct	iovec *iovp;
	u_int	iovcnt;
};
int
socketreadv(uap, retval)
	register struct readv_args *uap;
	int *retval;
d1189 17
a1205 10
	struct uio auio;
	register struct iovec *iov;
	struct iovec *needfree;
	struct iovec aiov[UIO_SMALLIOV];
	struct socket *so;
	long i, cnt, error = 0;
	u_int iovlen;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
#endif
d1207 1
a1207 59
    	if ((so = getsock(uap->fdes)) == 0)
		return (EBADF);
	/* note: can't use iovlen until iovcnt is validated */
	iovlen = uap->iovcnt * sizeof (struct iovec);
	if (uap->iovcnt > UIO_SMALLIOV) {
		if (uap->iovcnt > UIO_MAXIOV)
			return (EINVAL);
		MALLOC(iov, struct iovec *, iovlen, M_IOV, M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
		needfree = iov;
	} else {
		iov = aiov;
		needfree = NULL;
	}
	auio.uio_iov = iov;
	auio.uio_iovcnt = uap->iovcnt;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_USERSPACE;
	if ((error = copyin((caddr_t)uap->iovp, (caddr_t)iov, iovlen)))
		goto done;
	auio.uio_resid = 0;
	for (i = 0; i < uap->iovcnt; i++) {
		auio.uio_resid += iov->iov_len;
		if (auio.uio_resid < 0) {
			error = EINVAL;
			goto done;
		}
		iov++;
	}
#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO))  {
		MALLOC(ktriov, struct iovec *, iovlen, M_TEMP, M_WAITOK);
		bcopy((caddr_t)auio.uio_iov, (caddr_t)ktriov, iovlen);
	}
#endif
	cnt = auio.uio_resid;
	if ((error = soreceive(so, (struct mbuf **)0, &auio,
	     (struct mbuf **)0, (struct mbuf **)0, (int *)0)))
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
	cnt -= auio.uio_resid;
#ifdef KTRACE
	if (ktriov != NULL) {
		if (error == 0)
			ktrgenio(p->p_tracep, uap->fdes, UIO_READ, ktriov,
			    cnt, error);
		FREE(ktriov, M_TEMP);
	}
#endif
	*retval = cnt;
done:
	if (needfree)
		FREE(needfree, M_IOV);
	return (error);
d1210 1
a1210 12
/*
 * Write system call
 */
struct write_args {
	int	fd;
	char	*buf;
	u_int	nbyte;
};
int
socketwrite(uap, retval)
	register struct write_args *uap;
	int *retval;
d1212 16
a1227 12
#ifdef __riscos
	register struct socket *so;
#else
	register struct file *fp;
	register struct filedesc *fdp = p->p_fd;
#endif
	struct uio auio;
	struct iovec aiov;
	long cnt, error = 0;
#ifdef KTRACE
	struct iovec ktriov;
#endif
d1229 5
a1233 46
#ifdef __riscos
	if ((so = getsock(uap->fd)) == 0)
		return (EBADF);
#else
	if (((u_int)uap->fd) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[uap->fd]) == NULL ||
	    (fp->f_flag & FWRITE) == 0)
		return (EBADF);
#endif
	aiov.iov_base = (caddr_t)uap->buf;
	aiov.iov_len = uap->nbyte;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_resid = uap->nbyte;
	auio.uio_rw = UIO_WRITE;
	auio.uio_segflg = UIO_USERSPACE;
#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO))
		ktriov = aiov;
#endif
	cnt = uap->nbyte;
#ifdef __riscos
	if ((error = sosend(so, 0, &auio, 0, 0, 0))) {
#else
	if ((error = (*fp->f_ops->fo_write)(fp, &auio, fp->f_cred))) {
#endif
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
		if (error == EPIPE)
#ifdef __riscos
			psignal(pfind(so->so_pgid), SIGPIPE);
#else
			psignal(p, SIGPIPE);
#endif
	}
	cnt -= auio.uio_resid;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO) && error == 0)
		ktrgenio(p->p_tracep, uap->fd, UIO_WRITE,
		    &ktriov, cnt, error);
#endif
	*retval = cnt;
d1235 2
d1239 1
a1239 12
/*
 * Gather write system call
 */
struct writev_args {
	int	fd;
	struct	iovec *iovp;
	u_int	iovcnt;
};
int
socketwritev(uap, retval)
	register struct writev_args *uap;
	int *retval;
d1241 24
a1264 10
	register struct socket *so;
	struct uio auio;
	register struct iovec *iov;
	struct iovec *needfree;
	struct iovec aiov[UIO_SMALLIOV];
	long i, cnt, error = 0;
	u_int iovlen;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
#endif
d1266 2
a1267 61
	if ((so = getsock(uap->fd)) == 0)
		return (EBADF);
	/* note: can't use iovlen until iovcnt is validated */
	iovlen = uap->iovcnt * sizeof (struct iovec);
	if (uap->iovcnt > UIO_SMALLIOV) {
		if (uap->iovcnt > UIO_MAXIOV)
			return (EINVAL);
		MALLOC(iov, struct iovec *, iovlen, M_IOV, M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
		needfree = iov;
	} else {
		iov = aiov;
		needfree = NULL;
	}
	auio.uio_iov = iov;
	auio.uio_iovcnt = uap->iovcnt;
	auio.uio_rw = UIO_WRITE;
	auio.uio_segflg = UIO_USERSPACE;
	if ((error = copyin((caddr_t)uap->iovp, (caddr_t)iov, iovlen)))
		goto done;
	auio.uio_resid = 0;
	for (i = 0; i < uap->iovcnt; i++) {
		auio.uio_resid += iov->iov_len;
		if (auio.uio_resid < 0) {
			error = EINVAL;
			goto done;
		}
		iov++;
	}
#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO))  {
		MALLOC(ktriov, struct iovec *, iovlen, M_TEMP, M_WAITOK);
		bcopy((caddr_t)auio.uio_iov, (caddr_t)ktriov, iovlen);
	}
#endif
	cnt = auio.uio_resid;
	if ((error = sosend(so, 0, &auio, 0, 0, 0))) {
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
		if (error == EPIPE)
			psignal(pfind(so->so_pgid), SIGPIPE);
	}
	cnt -= auio.uio_resid;
#ifdef KTRACE
	if (ktriov != NULL) {
		if (error == 0)
			ktrgenio(p->p_tracep, uap->fd, UIO_WRITE,
				ktriov, cnt, error);
		FREE(ktriov, M_TEMP);
	}
#endif
	*retval = cnt;
done:
	if (needfree)
		FREE(needfree, M_IOV);
	return (error);
a1269 1
int
d1279 2
a1280 2
	if ((so = getsock(up->s)) == 0)
		return (EBADF);
d1282 1
a1282 3
	bzero((caddr_t)(up->ub), sizeof (*(up->ub)));
	up->ub->st_mode = S_IFSOCK;
	return ((*so->so_proto->pr_usrreq)(so, PRU_SENSE,
a1288 1
int
d1295 5
a1299 7
int	selwait, nselcoll;

/*
 * Select system call.
 */
struct select_args {
	u_int	nd;
d1302 90
a1391 54
};
int
socketselect(uap, retval)
	register struct select_args *uap;
	int *retval;
{
	fd_set ibits[3], obits[3];
	struct timeval atv;
	int s, ncoll, error = 0, timo;
	u_int ni;
	int noblock = 0;

	bzero((caddr_t)ibits, sizeof(ibits));
	bzero((caddr_t)obits, sizeof(obits));

	if (uap->nd > SOCKTABSIZE)
		uap->nd = SOCKTABSIZE;	/* forgiving; slightly wrong */
	ni = howmany(uap->nd, NFDBITS) * sizeof(fd_mask);

#define	getbits(name, x) \
	if (uap->name && \
	    (error = copyin((caddr_t)uap->name, (caddr_t)&ibits[x], ni))) \
		goto done;
	getbits(in, 0);
	getbits(ou, 1);
	getbits(ex, 2);
#undef	getbits

	if (uap->tv) {
		error = copyin((caddr_t)uap->tv, (caddr_t)&atv,
			sizeof (atv));
		if (error)
			goto done;
		if (itimerfix(&atv)) {
			error = EINVAL;
			goto done;
		}
		s = splhi();
		timevaladd(&atv, (struct timeval *)&time);
#ifdef DEBUG
		if (DODEBUG(DBGSELECT))
			Printf("atv=(%d,%d), time=(%d,%d)\n",
			            atv.tv_sec, atv.tv_usec,
			            time.tv_sec, time.tv_usec);
#endif
		timo = hzto(&atv);
		/*
		 * Avoid inadvertently sleeping forever.
		 */
		if (timo == 0)
			timo = 1;
		splx(s);
	} else
		timo = 0;
d1393 5
a1397 62
#ifdef DEBUG
	if (DODEBUG(DBGSELECT))
		Printf("\nSelect timeout = %d\n", timo);
#endif
retry:
	ncoll = nselcoll;
    	error = selscan(ibits, obits, uap->nd, retval, &noblock);
    	if (error || *retval)
		goto done;
	s = splhi();
	/* this should be timercmp(&time, &atv, >=) */
	if (uap->tv && (time.tv_sec > atv.tv_sec ||
	    (time.tv_sec == atv.tv_sec && time.tv_usec >= atv.tv_usec))) {
#ifdef DEBUG
		if (DODEBUG(DBGSELECT)) {
			Printf("Time too late ");
			Printf("atv=(%d,%d), time=(%d,%d)\n",
			       atv.tv_sec, atv.tv_usec,
			       time.tv_sec, time.tv_usec);
		}
#endif
		splx(s);
		goto done;
	}
	if (nselcoll != ncoll) {
#ifdef DEBUG
		if (DODEBUG(DBGSELECT))
			Printf("Select has happened ");
#endif
		splx(s);
		goto retry;
	}
#ifdef DEBUG
	if (DODEBUG(DBGSELECT))
		Printf("sleeping ");
#endif
	error = tsleep((caddr_t)&selwait, PSOCK | PCATCH, "select", timo, noblock);
#ifdef DEBUG
	if (DODEBUG(DBGSELECT))
		Printf("woken ");
#endif
	splx(s);
	if (error == 0)
		goto retry;
done:
	/* select is not restarted after signals... */
	if (error == ERESTART)
		error = EINTR;
	if (error == EWOULDBLOCK)
		error = 0;
#define	putbits(name, x) \
	if (uap->name && \
	    (error2 = copyout((caddr_t)&obits[x], (caddr_t)uap->name, ni))) \
		error = error2;
	if (error == 0) {
		int error2;

		putbits(in, 0);
		putbits(ou, 1);
		putbits(ex, 2);
#undef putbits
	}
d1402 1
a1402 4
static int
selscan(ibits, obits, nfd, retval, noblock)
	fd_set *ibits, *obits;
	int nfd, *retval, *noblock;
d1404 6
a1409 1
    int msk, i, j, s;
d1411 1
a1411 1
    struct socket *so;
a1412 1
    static int flag[3] = { FREAD, FWRITE, 0 };
d1414 23
a1436 4
    for (msk = 0; msk < 3; msk++) {
	for (i = 0; i < nfd; i += NFDBITS) {
	    bits = ibits[msk].fds_bits[i/NFDBITS];
	    while ((j = ffs(bits)) && (s = i + --j) < nfd) {
d1438 3
a1440 2
		so = getsock(s);
		if (so == NULL)
d1442 4
a1445 3
		*noblock=so->so_state & SS_SLEEPTW;
		if (do_sock_select(so, flag[msk])) {
		    FD_SET(s, &obits[msk]);
d1448 3
d1454 2
a1455 1
    *retval = n;
d1467 1
a1467 7
/*
 * Record a select request.
 */
void
selrecord(selector, sip)
	struct proc *selector;
	struct selinfo *sip;
d1469 1
a1469 14
#ifdef __riscos
	sip->si_flags |= SI_COLL;
#else
	struct proc *p;
	pid_t mypid;

	mypid = selector->p_pid;
	if (sip->si_pid == mypid)
		return;
	if (sip->si_pid && (p = pfind(sip->si_pid)))
		sip->si_flags |= SI_COLL;
	else
		sip->si_pid = mypid;
#endif
d1472 1
a1472 6
/*
 * Do a wakeup when a selectable event occurs.
 */
void
selwakeup(sip)
	register struct selinfo *sip;
d1474 11
a1484 12
#ifdef DEBUG
	if (DODEBUG(DBGSELECT))
       		Printf("selwakeup(%x)\n", sip);
#endif
	if (sip->si_flags & SI_COLL) {
#ifdef DEBUG
		if (DODEBUG(DBGSELECT))
                	Printf("  Waking up!\n");
#endif
		nselcoll++;
		sip->si_flags &= ~SI_COLL;
		wakeup((caddr_t)&selwait);
a1485 1
}
d1487 8
a1494 6
static int
do_sock_select(so, which)
	struct socket *so;
	int which;
{
	struct proc *p=pfind(so->so_pgid);
d1496 2
a1497 1
	switch (which) {
d1499 4
a1502 20
	case FREAD:
		if (soreadable(so))
			return (1);
		selrecord(p, &so->so_rcv.sb_sel);
		so->so_rcv.sb_flags |= SB_SEL;
		break;

	case FWRITE:
		if (sowriteable(so))
			return (1);
		selrecord(p, &so->so_snd.sb_sel);
		so->so_snd.sb_flags |= SB_SEL;
		break;

	case 0:
		if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
			return (1);
		selrecord(p, &so->so_rcv.sb_sel);
		so->so_rcv.sb_flags |= SB_SEL;
		break;
d1504 6
a1509 1
	return (0);
d1512 1
a1512 3
struct socket *
getsock(s)
	int s;
d1514 2
a1515 2
	if (s < 0 || s >= SOCKTABSIZE)
		return ((struct socket *)0);
d1517 1
a1517 1
    	return (socktab[s]);
d1531 1
a1531 1
static int getsockslot(void)
d1540 8
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@RCS log keyword removed
@
text
@d22 1
a22 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d22 1
a22 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a22 4
 *
 * Revision 1.5  96/03/11            kbracey
 * Stuff for UpCall 6 stuck into select etc.
 *
d25 1
a25 1
 *
d29 1
a29 1
 *
d33 1
a33 1
 *
d36 1
a36 1
 *
a48 2
#include "sys/kernel.h"
#include "sys/proc.h"
a51 1
#include "module.h"
d53 1
a53 2
/* KEEP IN LINE WITH CMHG FILE */
#define MODVERSION 502
d55 1
a55 1
struct socket *socktab[SOCKTABSIZE];
d57 1
a57 7

int
version(_kernel_swi_regs *r, int *retval)
{
    *retval = MODVERSION;
    return (0);
}
d64 1
a64 11
/* Should be in kern/uipc_sycall.c */
int
#ifdef __riscos
sendit(s, mp, flags, retsize)
#else
sendit(p, s, mp, flags, retsize)
	register struct proc *p;
#endif
	int s;
	register struct msghdr *mp;
	int flags, *retsize;
d66 36
a101 13
#ifndef __riscos
	struct file *fp;
#else
	struct socket *so;
#endif
	struct uio auio;
	register struct iovec *iov;
	register int i;
	struct mbuf *to, *control;
	int len, error;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
#endif
d103 4
a106 7
#ifdef __riscos
        if ((so = getsock(s)) == 0)
	        return (EBADF);
	else
		error = 0;
#else
	error = getsock(p->p_fd, s, &fp);
d108 10
a117 50
		return (error);
#endif
	auio.uio_iov = mp->msg_iov;
	auio.uio_iovcnt = mp->msg_iovlen;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_rw = UIO_WRITE;
#ifndef __riscos
	auio.uio_procp = p;
#endif
	auio.uio_offset = 0;			/* XXX */
	auio.uio_resid = 0;
	iov = mp->msg_iov;
	for (i = 0; i < mp->msg_iovlen; i++, iov++) {
		if ((auio.uio_resid += iov->iov_len) < 0)
			return (EINVAL);
	}
	if (mp->msg_name) {
		error = sockargs(&to, mp->msg_name, mp->msg_namelen, MT_SONAME);
		if (error)
			return (error);
	} else
		to = 0;
	if (mp->msg_control) {
		if (mp->msg_controllen < sizeof(struct cmsghdr)
#ifdef COMPAT_OLDSOCK
		    && mp->msg_flags != MSG_COMPAT
#endif
		) {
			error = EINVAL;
			goto bad;
		}
		error = sockargs(&control, mp->msg_control,
		    mp->msg_controllen, MT_CONTROL);
		if (error)
			goto bad;
#ifdef COMPAT_OLDSOCK
		if (mp->msg_flags == MSG_COMPAT) {
			register struct cmsghdr *cm;

			M_PREPEND(control, sizeof(*cm), M_WAIT);
			if (control == 0) {
				error = ENOBUFS;
				goto bad;
			} else {
				cm = mtod(control, struct cmsghdr *);
				cm->cmsg_len = control->m_len;
				cm->cmsg_level = SOL_SOCKET;
				cm->cmsg_type = SCM_RIGHTS;
			}
		}
a118 5
	} else
		control = 0;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO)) {
		int iovlen = auio.uio_iovcnt * sizeof (struct iovec);
d120 6
a125 8
		MALLOC(ktriov, struct iovec *, iovlen, M_TEMP, M_WAITOK);
		bcopy((caddr_t)auio.uio_iov, (caddr_t)ktriov, iovlen);
	}
#endif
	len = auio.uio_resid;
#ifdef __riscos
	error = sosend(so, to, &auio,
	    (struct mbuf *)0, control, flags);
d127 1
a127 2
	error = sosend((struct socket *)fp->f_data, to, &auio,
	    (struct mbuf *)0, control, flags);
d129 7
a135 7
	if (error) {
		if (auio.uio_resid != len && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
		if (error == EPIPE)
#ifdef __riscos
			psignal(pfind(so->so_pgid), SIGPIPE);
d137 1
a137 1
			psignal(p, SIGPIPE);
d139 2
a140 15
	}
	if (error == 0)
		*retsize = len - auio.uio_resid;
#ifdef KTRACE
	if (ktriov != NULL) {
		if (error == 0)
			ktrgenio(p->p_tracep, s, UIO_WRITE,
				ktriov, *retsize, error);
		FREE(ktriov, M_TEMP);
	}
#endif
bad:
	if (to)
		m_freem(to);
	return (error);
d143 2
a144 7
/* Should be in kern/uipc_syscall.c */
int
recvit(s, mp, namelenp, retsize)
	int s;
	register struct msghdr *mp;
	caddr_t namelenp;
	int *retsize;
a145 1
#ifdef __riscos
a146 3
#else
	struct file *fp;
#endif
d148 3
a150 2
	register struct iovec *iov;
	register int i;
a151 4
	struct mbuf *from = 0, *control = 0;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
#endif
d153 2
a154 11
#ifdef __riscos
        so = getsock(s);
        if (so == NULL)
                return (EBADF);
        else
        	error = 0;
#else
	error = getsock(p->p_fd, s, &fp);
	if (error)
		return (error);
#endif
d157 2
a158 6
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_rw = UIO_READ;
#ifndef __riscos
	auio.uio_procp = p;
#endif
	auio.uio_offset = 0;			/* XXX */
d162 1
a162 1
		if ((auio.uio_resid += iov->iov_len) < 0)
d164 1
a165 8
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO)) {
		int iovlen = auio.uio_iovcnt * sizeof (struct iovec);

		MALLOC(ktriov, struct iovec *, iovlen, M_TEMP, M_WAITOK);
		bcopy((caddr_t)auio.uio_iov, (caddr_t)ktriov, iovlen);
	}
#endif
d167 4
a170 23
#ifdef __riscos
	error = soreceive(so, &from, &auio,
#else
	error = soreceive((struct socket *)fp->f_data, &from, &auio,
#endif
	    (struct mbuf **)0, mp->msg_control ? &control : (struct mbuf **)0,
	    &mp->msg_flags);
	if (error) {
		if (auio.uio_resid != len && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
	}
#ifdef KTRACE
	if (ktriov != NULL) {
		if (error == 0)
			ktrgenio(p->p_tracep, s, UIO_READ,
				ktriov, len - auio.uio_resid, error);
		FREE(ktriov, M_TEMP);
	}
#endif
	if (error)
		goto out;
	*retsize = len - auio.uio_resid;
a175 5
#ifdef COMPAT_OLDSOCK
			if (mp->msg_flags & MSG_COMPAT)
				mtod(from, struct osockaddr *)->sa_family =
				    mtod(from, struct sockaddr *)->sa_family;
#endif
d178 1
a178 2
			/* else if len < from->m_len ??? */
			error = copyout(mtod(from, caddr_t),
a179 12
			if (error)
				goto out;
		}
		mp->msg_namelen = len;
		if (namelenp &&
		    (error = copyout((caddr_t)&len, namelenp, sizeof (int)))) {
#ifdef COMPAT_OLDSOCK
			if (mp->msg_flags & MSG_COMPAT)
				error = 0;	/* old recvfrom didn't check */
			else
#endif
			goto out;
d181 1
d183 3
a185 23
	if (mp->msg_control) {
#ifdef COMPAT_OLDSOCK
		/*
		 * We assume that old recvmsg calls won't receive access
		 * rights and other control info, esp. as control info
		 * is always optional and those options didn't exist in 4.3.
		 * If we receive rights, trim the cmsghdr; anything else
		 * is tossed.
		 */
		if (control && mp->msg_flags & MSG_COMPAT) {
			if (mtod(control, struct cmsghdr *)->cmsg_level !=
			    SOL_SOCKET ||
			    mtod(control, struct cmsghdr *)->cmsg_type !=
			    SCM_RIGHTS) {
				mp->msg_controllen = 0;
				goto out;
			}
			control->m_len -= sizeof (struct cmsghdr);
			control->m_off += sizeof (struct cmsghdr);
		}
#endif
		len = mp->msg_controllen;
		if (len <= 0 || control == 0)
d188 4
a191 6
			if (len >= control->m_len)
				len = control->m_len;
			else
				mp->msg_flags |= MSG_CTRUNC;
			error = copyout((caddr_t)mtod(control, caddr_t),
			    (caddr_t)mp->msg_control, (unsigned)len);
d193 1
a193 1
		mp->msg_controllen = len;
d195 3
a197 1
out:
d200 7
a206 2
	if (control)
		m_freem(control);
d210 1
a210 9
struct socket_args {
	int	domain;
	int	type;
	int	protocol;
};
int
socket(uap, retval)
	register struct socket_args *uap;
	int *retval;
d212 12
a223 2
	struct socket *so;
	int fd, error;
d225 2
a226 11
	fd = getsockslot();
	if (fd < 0)
		return (EMFILE);
	error = socreate(uap->domain, &so, uap->type, uap->protocol);
	if (error) {
		/* Do nothing */
	} else {
		*retval = fd;
		setsockslot(fd, so);
		so->so_pgid = fd+1;
	}
d228 5
d235 1
a235 9
struct bind_args {
	int	s;
	caddr_t	name;
	int	namelen;
};
/* ARGSUSED */
int
bind(uap)
	register struct bind_args *uap;
d237 12
a248 3
	struct socket *so;
	struct mbuf *nam;
	int error;
d250 2
a251 7
	if ((so = getsock(uap->s)) == 0)
		return (EBADF);
	error = sockargs(&nam, uap->name, uap->namelen, MT_SONAME);
	if (error)
		return (error);
	error = sobind(so, nam);
	m_freem(nam);
d253 8
d263 1
a263 9
struct listen_args {
	int	s;
	int	backlog;
};
/* ARGSUSED */
int
listen(uap, retval)
	register struct listen_args *uap;
	int *retval;
d265 7
a271 1
	struct socket *so;
d273 3
a275 3
	so = getsock(uap->s);
	if (so == 0)
		return (EBADF);
d277 2
a278 1
	return (solisten(so, uap->backlog));
d281 23
a303 32
struct accept_args {
	int	s;
	caddr_t	name;
	int	*anamelen;
#ifdef COMPAT_OLDSOCK
	int	compat_43;	/* pseudo */
#endif
};

#ifndef COMPAT_OLDSOCK
#  define	accept1	accept
#endif  /* COMPAT_OLDSOCK*/
int
accept1(uap, retval)
	register struct accept_args *uap;
	int *retval;
{
	struct mbuf *nam;
	int namelen, error, sockid;
	register struct socket *so;

	if (uap->name) {
		error = copyin((caddr_t)uap->anamelen, (caddr_t)&namelen,
			sizeof (namelen));
		if(error)
			return (error);
	}
	so = getsock(uap->s);
	if (so == 0)
		return (EBADF);
	else
		error = 0;
d305 2
a306 2
	if ((so->so_options & SO_ACCEPTCONN) == 0)
		return (EINVAL);
d308 2
a309 2
	if ((so->so_state & SS_NBIO) && so->so_qlen == 0)
		return (EWOULDBLOCK);
d311 6
a316 9
	while (so->so_qlen == 0 && so->so_error == 0) {
		if (so->so_state & SS_CANTRCVMORE) {
			so->so_error = ECONNABORTED;
			break;
		}
		error = tsleep((caddr_t)&so->so_timeo, PSOCK | PCATCH,
		    netcon, 0, so->so_state & SS_SLEEPTW);
		if (error)
			return (error);
d319 4
a322 4
	if (so->so_error) {
		error = so->so_error;
		so->so_error = 0;
		return (error);
d324 6
a329 35
	sockid = getsockslot();
	if (sockid < 0)
		return (EBADF);
	{ struct socket *aso = so->so_q;
	  if (soqremque(aso, 1) == 0) {
		panic("accept");
		return (EFAULT);
	  }
	  so = aso;
	}
	nam = m_get(M_WAIT, MT_SONAME);
	if (nam == NULL)
		return (ENOBUFS);
	(void) soaccept(so, nam);

	setsockslot(sockid, so);
	so->so_pgid = sockid+1;
	*retval = sockid;

	if (uap->name) {
#ifdef COMPAT_OLDSOCK
		if (uap->compat_43)
			mtod(nam, struct osockaddr *)->sa_family =
			    mtod(nam, struct sockaddr *)->sa_family;
#endif
		if (namelen > nam->m_len)
			namelen = nam->m_len;
		/* SHOULD COPY OUT A CHAIN HERE */
		error = copyout(mtod(nam, caddr_t), (caddr_t)(uap->name),
		    (u_int)namelen);
		if (!error)
			error = copyout((caddr_t)&namelen,
			    (caddr_t)(uap->anamelen), sizeof (*uap->anamelen));
	}
	m_freem(nam);
d331 1
a331 1
}
d333 12
a344 14
#ifdef COMPAT_OLDSOCK
int
accept(uap, retval)
	struct accept_args *uap;
	int *retval;
{

#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 0;
	error = accept1(uap, retval);
	uap->compat_43 = temp;
	return (error);
d346 5
a350 2
	uap->compat_43 = 0;
	return (accept1(uap, retval));
d352 28
a379 1
}
d381 4
a384 5
int
oaccept(uap, retval)
	struct accept_args *uap;
	int *retval;
{
d386 5
a390 7
#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 1;
	error = accept1(uap, retval);
	uap->compat_43 = temp;
	return (error);
d392 1
a392 2
	uap->compat_43 = 1;
	return (accept1(uap, retval));
d394 3
a397 1
#endif /* COMPAT_OLDSOCK */
d400 14
a413 13
struct connect_args {
	int	s;
	caddr_t	name;
	int	namelen;
};
/* ARGSUSED */
int
connect(uap)
	register struct connect_args *uap;
{
	register struct socket *so;
	struct mbuf *nam;
	int error;
d415 2
a416 3
	so = getsock(uap->s);
	if (so == 0)
		return (EBADF);
d418 3
a420 2
	if ((so->so_state & SS_NBIO) && (so->so_state & SS_ISCONNECTING))
		return (EALREADY);
d422 2
a423 5
	error = sockargs(&nam, uap->name, uap->namelen, MT_SONAME);
	if (error)
		return (error);
	error = soconnect(so, nam);
	if (error)
d425 4
a428 16
	if ((so->so_state & SS_NBIO) && (so->so_state & SS_ISCONNECTING)) {
		m_freem(nam);
		return (EINPROGRESS);
	}
	while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) {
		error = tsleep((caddr_t)&so->so_timeo, PSOCK | PCATCH,
		    netcon, 0, so->so_state & SS_SLEEPTW);
		if (error)
			break;
	}
	if (error == 0) {
		error = so->so_error;
		so->so_error = 0;
	}
bad:
	so->so_state &= ~SS_ISCONNECTING;
d430 23
a452 3
	if (error == ERESTART)
		error = EINTR;
	return (error);
d455 1
a455 11
struct sendtosm_args {
	int      s;
	caddr_t *buf;
	u_int    len;
	caddr_t *buf1;
	u_int    len1;
	caddr_t  to;
};
int
sendtosm(uap)
	struct sendtosm_args *uap;
d457 19
a475 3
	struct socket *so;
	struct mbuf *to, *m, *n;
	int error;
d477 1
a477 3
	so = getsock(uap->s);
    	if (so == 0)
		return (EBADF);
d479 2
a480 3
    	error = sockargs(&to, uap->to, sizeof(struct sockaddr), MT_SONAME);
    	if (error)
		return (error);
d482 5
a486 1
    	m = 0; n = 0;
d488 7
a494 2
    	m = ALLOC_U(uap->len, uap->buf);
    	if (m == NULL) {
d496 2
a497 2
		if (DODEBUG(DBGMMAN))
	    		Printf("sosendsm: ALLOC_U#1 failed\n");
d499 26
a524 11
		error = ENOBUFS;
		goto release;
    	}
    	m->m_type = MT_DATA;
    	m->m_flags = M_PKTHDR;
    	m->m_pkthdr.len = uap->len;
    	m->m_pkthdr.rcvif = (struct ifnet *) 0;

	if (uap->len1 > 0) {
		n = ALLOC_U(uap->len1, uap->buf1);
		if (n == NULL) {
d526 2
a527 2
	    		if (DODEBUG(DBGMMAN))
				Printf("sosendsm: ALLOC_U#2 failed\n");
d529 3
a531 3
	    		error = ENOBUFS;
	    		goto release;
		}
d533 4
a536 5
		n->m_type = MT_DATA;
		n->m_flags = 0;
		m->m_pkthdr.len += uap->len1;
    	        m->m_next = n;
    	}
d538 8
a545 2
    	error = udp_usrreq(so, PRU_SEND, m, to, 0);
    	m = 0;
d547 4
a550 3
release:
    	if (m)
		m_freem(m);
d552 3
a554 2
    	m_freem(to);
    	return (error);
d557 4
a560 1
struct sendto_args {
d562 2
a563 2
	caddr_t	buf;
	size_t	len;
d565 1
a565 1
	caddr_t	to;
d567 12
a578 17
};
int
sendto(register struct sendto_args *uap, int *retval)
{
        struct msghdr msg;
        struct iovec aiov;

        msg.msg_name = uap->to;
        msg.msg_namelen = uap->tolen;
        msg.msg_iov = &aiov;
        msg.msg_iovlen = 1;
	msg.msg_control = 0;
#ifdef COMPAT_OLDSOCK
	msg.msg_flags = 0;
#endif
        aiov.iov_base = uap->buf;
        aiov.iov_len = uap->len;
d580 1
a580 1
        /* TRACE */
d582 1
a582 1
        Printf("sendit: %d bytes to '%.*s'\n", uap->len, uap->tolen, uap->to);
d585 1
a585 1
        return (sendit(uap->s, &msg, uap->flags, retval));
d588 22
a609 24
#ifdef COMPAT_OLDSOCK
struct osend_args {
	int	s;
	caddr_t	buf;
	int	len;
	int	flags;
};
int
osend(uap, retval)
	register struct osend_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov;

	msg.msg_name = 0;
	msg.msg_namelen = 0;
	msg.msg_iov = &aiov;
	msg.msg_iovlen = 1;
	aiov.iov_base = uap->buf;
	aiov.iov_len = uap->len;
	msg.msg_control = 0;
	msg.msg_flags = 0;
	return (sendit(uap->s, &msg, uap->flags, retval));
d612 11
a622 13
struct osendmsg_args {
	int	s;
	caddr_t	msg;
	int	flags;
};
int
osendmsg(uap, retval)
	register struct osendmsg_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov[UIO_SMALLIOV], *iov;
	int error;
d624 2
a625 23
	error = copyin(uap->msg, (caddr_t)&msg, sizeof (struct omsghdr));
	if (error)
		return (error);
	if ((u_int)msg.msg_iovlen >= UIO_SMALLIOV) {
		if ((u_int)msg.msg_iovlen >= UIO_MAXIOV)
			return (EMSGSIZE);
		MALLOC(iov, struct iovec *,
		      sizeof(struct iovec) * (u_int)msg.msg_iovlen, M_IOV,
		      M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
	} else
		iov = aiov;
	error = copyin((caddr_t)msg.msg_iov, (caddr_t)iov,
	    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)));
	if (error)
		goto done;
	msg.msg_flags = MSG_COMPAT;
	msg.msg_iov = iov;
	error = sendit(uap->s, &msg, uap->flags, retval);
done:
	if (iov != aiov)
		FREE(iov, M_IOV);
a626 2
}
#endif
d628 2
a629 13
struct sendmsg_args {
	int	s;
	caddr_t	msg;
	int	flags;
};
int
sendmsg(uap, retval)
	register struct sendmsg_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov[UIO_SMALLIOV], *iov;
	int error;
d631 3
a633 25
	error = copyin(uap->msg, (caddr_t)&msg, sizeof (msg));
	if (error)
		return (error);
	if ((u_int)msg.msg_iovlen >= UIO_SMALLIOV) {
		if ((u_int)msg.msg_iovlen >= UIO_MAXIOV)
			return (EMSGSIZE);
		MALLOC(iov, struct iovec *,
		       sizeof(struct iovec) * (u_int)msg.msg_iovlen, M_IOV,
		       M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
	} else
		iov = aiov;
	if (msg.msg_iovlen &&
	    (error = copyin((caddr_t)msg.msg_iov, (caddr_t)iov,
	    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)))))
		goto done;
	msg.msg_iov = iov;
#ifdef COMPAT_OLDSOCK
	msg.msg_flags = 0;
#endif
	error = sendit(uap->s, &msg, uap->flags, retval);
done:
	if (iov != aiov)
		FREE(iov, M_IOV);
d635 3
d640 4
a643 1
struct recvfrom_args {
d645 2
a646 2
	caddr_t	buf;
	size_t	len;
d648 1
a648 1
	caddr_t	from;
d650 17
a666 1
};
d668 5
a672 2
int
recvfrom(register struct recvfrom_args *uap, int *retval)
d674 18
a691 3
    	struct msghdr msg;
    	struct iovec aiov;
    	int error;
d693 1
a693 15
	if (uap->fromlenaddr) {
		error = copyin((caddr_t)uap->fromlenaddr,
		    (caddr_t)&msg.msg_namelen, sizeof (msg.msg_namelen));
		if (error)
			return (error);
	} else
		msg.msg_namelen = 0;
	msg.msg_name = uap->from;
	msg.msg_iov = &aiov;
	msg.msg_iovlen = 1;
	aiov.iov_base = uap->buf;
	aiov.iov_len = uap->len;
	msg.msg_control = 0;
	msg.msg_flags = uap->flags;
	return (recvit(uap->s, &msg, (caddr_t)uap->fromlenaddr, retval));
d696 1
a696 5
#ifdef COMPAT_OLDSOCK
int
orecvfrom(uap, retval)
	struct recvfrom_args *uap;
	int *retval;
d698 14
d713 3
a715 4
	uap->flags |= MSG_COMPAT;
	return (recvfrom(uap, retval));
}
#endif
d717 4
d722 3
a724 24
#ifdef COMPAT_OLDSOCK
struct orecv_args {
	int	s;
	caddr_t	buf;
	int	len;
	int	flags;
};
int
orecv(uap, retval)
	register struct orecv_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov;

	msg.msg_name = 0;
	msg.msg_namelen = 0;
	msg.msg_iov = &aiov;
	msg.msg_iovlen = 1;
	aiov.iov_base = uap->buf;
	aiov.iov_len = uap->len;
	msg.msg_control = 0;
	msg.msg_flags = uap->flags;
	return (recvit(uap->s, &msg, (caddr_t)0, retval));
d727 11
a737 18
/*
 * Old recvmsg.  This code takes advantage of the fact that the old msghdr
 * overlays the new one, missing only the flags, and with the (old) access
 * rights where the control fields are now.
 */
struct orecvmsg_args {
	int	s;
	struct	omsghdr *msg;
	int	flags;
};
int
orecvmsg(uap, retval)
	register struct orecvmsg_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov[UIO_SMALLIOV], *iov;
	int error;
d739 1
a739 29
	error = copyin((caddr_t)uap->msg, (caddr_t)&msg,
	    sizeof (struct omsghdr));
	if (error)
		return (error);
	if ((u_int)msg.msg_iovlen >= UIO_SMALLIOV) {
		if ((u_int)msg.msg_iovlen >= UIO_MAXIOV)
			return (EMSGSIZE);
		MALLOC(iov, struct iovec *,
		      sizeof(struct iovec) * (u_int)msg.msg_iovlen, M_IOV,
		      M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
	} else
		iov = aiov;
	msg.msg_flags = uap->flags | MSG_COMPAT;
	error = copyin((caddr_t)msg.msg_iov, (caddr_t)iov,
	    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)));
	if (error)
		goto done;
	msg.msg_iov = iov;
	error = recvit(uap->s, &msg, (caddr_t)&uap->msg->msg_namelen, retval);

	if (msg.msg_controllen && error == 0)
		error = copyout((caddr_t)&msg.msg_controllen,
		    (caddr_t)&uap->msg->msg_accrightslen, sizeof (int));
done:
	if (iov != aiov)
		FREE(iov, M_IOV);
	return (error);
d741 15
d758 11
a768 13
struct recvmsg_args {
	int	s;
	struct	msghdr *msg;
	int	flags;
};
int
recvmsg(uap, retval)
	register struct recvmsg_args *uap;
	int *retval;
{
	struct msghdr msg;
	struct iovec aiov[UIO_SMALLIOV], *uiov, *iov;
	register int error;
d770 1
a770 1
	error = copyin((caddr_t)uap->msg, (caddr_t)&msg, sizeof (msg));
d772 2
a773 13
		return (error);
	if ((u_int)msg.msg_iovlen >= UIO_SMALLIOV) {
		if ((u_int)msg.msg_iovlen >= UIO_MAXIOV)
			return (EMSGSIZE);
		MALLOC(iov, struct iovec *,
		       sizeof(struct iovec) * (u_int)msg.msg_iovlen, M_IOV,
		       M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
	} else
		iov = aiov;
#ifdef COMPAT_OLDSOCK
	msg.msg_flags = uap->flags &~ MSG_COMPAT;
d775 5
a779 1
	msg.msg_flags = uap->flags;
d781 1
a781 10
	uiov = msg.msg_iov;
	msg.msg_iov = iov;
	error = copyin((caddr_t)uiov, (caddr_t)iov,
	    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)));
	if (error)
		goto done;
	error = recvit(uap->s, &msg, (caddr_t)0, retval);
	if (!error) {
		msg.msg_iov = uiov;
		error = copyout((caddr_t)&msg, (caddr_t)uap->msg, sizeof(msg));
d783 11
a793 4
done:
	if (iov != aiov)
		FREE(iov, M_IOV);
	return (error);
d796 1
a796 7
struct shutdown_args {
	int	s;
	int	how;
};
int
shutdown(uap)
	register struct shutdown_args *uap;
d798 14
a811 1
	struct socket *so;
d813 9
a821 3
	so = getsock(uap->s);
	if (so == NULL)
		return (EBADF);
d823 3
a825 2
	return (soshutdown(so, uap->how));
}
d827 4
a830 16
struct setsockopt_args {
	int	s;
	int	level;
	int	name;
	caddr_t	val;
	int	valsize;
};
/* ARGSUSED */
int
setsockopt(uap, retval)
	register struct setsockopt_args *uap;
	int *retval;
{
	struct socket *so;
	struct mbuf *m = NULL;
	int error;
d832 3
a834 3
	so = getsock(uap->s);
	if (so == NULL)
		return (EBADF);
d836 3
a838 15
	if (uap->valsize > MINCONTIG)
		return (EINVAL);
	if (uap->val) {
		m = ALLOC_S(uap->valsize, NULL);
		if (m == NULL)
			return (ENOBUFS);
		m->m_type = MT_SOOPTS;
		error = copyin(uap->val, mtod(m, caddr_t), (u_int)uap->valsize);
		if (error) {
			(void) m_free(m);
			return (error);
		}
	}
	return (sosetopt(so, uap->level, uap->name, m));
}
d840 9
a848 16
struct getsockopt_args {
	int	s;
	int	level;
	int	name;
	caddr_t	val;
	int	*avalsize;
};
/* ARGSUSED */
int
getsockopt(uap, retval)
	register struct getsockopt_args *uap;
	int *retval;
{
	struct socket *so;
	struct mbuf *m = NULL, *m0;
	int op, i, valsize, error;
d850 1
a850 29
	so = getsock(uap->s);
	if (so == NULL)
		return (EBADF);
	if (uap->val) {
		error = copyin((caddr_t)uap->avalsize, (caddr_t)&valsize,
		    sizeof (valsize));
		if (error)
			return (error);
	} else
		valsize = 0;
	if ((error = sogetopt(so, uap->level,
	    uap->name, &m)) == 0 && uap->val && valsize && m != NULL) {
		op = 0;
		while (m && !error && op < valsize) {
			i = min(m->m_len, (valsize - op));
			error = copyout(mtod(m, caddr_t), uap->val, (u_int)i);
			op += i;
			uap->val += i;
			m0 = m;
			MFREE(m0,m);
		}
		valsize = op;
		if (error == 0)
			error = copyout((caddr_t)&valsize,
			    (caddr_t)uap->avalsize, sizeof (valsize));
	}
	if (m != NULL)
		(void) m_free(m);
	return (error);
d856 1
a856 18
struct getsockname_args {
	int	fdes;
	caddr_t	asa;
	int	*alen;
#ifdef COMPAT_OLDSOCK
	int	compat_43;	/* pseudo */
#endif
};

#ifndef COMPAT_OLDSOCK
#define	getsockname1	getsockname
#endif

/* ARGSUSED */
int
getsockname1(uap, retval)
	register struct getsockname_args *uap;
	int *retval;
d858 12
a869 3
	register struct socket *so;
	struct mbuf *m;
	int len, error;
d871 2
a872 26
	so = getsock(uap->fdes);
	if (so == NULL)
		return (EBADF);
	error = copyin((caddr_t)uap->alen, (caddr_t)&len, sizeof (len));
	if (error)
		return (error);
	m = ALLOC_C(0, NULL);
	if (m == NULL)
		return (ENOBUFS);
	m->m_type = MT_SONAME;
	error = (*so->so_proto->pr_usrreq)(so, PRU_SOCKADDR, 0, m, 0);
	if (error)
		goto bad;
	if (len > m->m_len)
		len = m->m_len;
#ifdef COMPAT_OLDSOCK
	if (uap->compat_43)
		mtod(m, struct osockaddr *)->sa_family =
		    mtod(m, struct sockaddr *)->sa_family;
#endif
	error = copyout(mtod(m, caddr_t), (caddr_t)uap->asa, (u_int)len);
	if (error == 0)
		error = copyout((caddr_t)&len, (caddr_t)uap->alen,
		    sizeof (len));
bad:
	m_freem(m);
d874 37
d913 4
a916 5
#ifdef COMPAT_OLDSOCK
int
getsockname(uap, retval)
	struct getsockname_args *uap;
	int *retval;
d918 30
d949 2
a950 6
#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 0;
	error = getsockname1(uap, retval);
	uap->compat_43 = temp;
d952 17
d970 1
a970 2
	uap->compat_43 = 0;
	return (getsockname1(uap, retval));
d972 1
d975 1
a975 4
int
ogetsockname(uap, retval)
	struct getsockname_args *uap;
	int *retval;
d977 5
d983 23
a1005 7
#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 1;
	error = getsockname1(uap, retval);
	uap->compat_43 = temp;
	return (error);
d1007 1
a1007 2
	uap->compat_43 = 1;
	return (getsockname1(uap, retval));
d1009 5
a1014 1
#endif /* COMPAT_OLDSOCK */
d1016 8
a1023 11
/*
 * Get name of peer for connected socket.
 */
struct getpeername_args {
	int	fdes;
	caddr_t	asa;
	int	*alen;
#ifdef COMPAT_OLDSOCK
	int	compat_43;	/* pseudo */
#endif
};
d1025 3
d1029 4
a1032 3
#ifndef COMPAT_OLDSOCK
#define	getpeername1	getpeername
#endif
d1034 1
a1034 5
/* ARGSUSED */
int
getpeername1(uap, retval)
	register struct getpeername_args *uap;
	int *retval;
d1036 95
a1130 3
	register struct socket *so;
	struct mbuf *m;
	int len, error;
d1132 1
a1132 29
	so = getsock(uap->fdes);
	if (so == NULL)
		return (EBADF);
	if ((so->so_state & (SS_ISCONNECTED|SS_ISCONFIRMING)) == 0)
		return (ENOTCONN);
	error = copyin((caddr_t)uap->alen, (caddr_t)&len, sizeof (len));
	if (error)
		return (error);
	m = ALLOC_C(0, NULL);
	if (m == NULL)
		return (ENOBUFS);
	m->m_type = MT_SONAME;
	error = (*so->so_proto->pr_usrreq)(so, PRU_PEERADDR, 0, m, 0);
	if (error)
		goto bad;
	if (len > m->m_len)
		len = m->m_len;
#ifdef COMPAT_OLDSOCK
	if (uap->compat_43)
		mtod(m, struct osockaddr *)->sa_family =
		    mtod(m, struct sockaddr *)->sa_family;
#endif
	error = copyout(mtod(m, caddr_t), (caddr_t)uap->asa, (u_int)len);
	if (error)
		goto bad;
	error = copyout((caddr_t)&len, (caddr_t)uap->alen, sizeof (len));
bad:
	m_freem(m);
	return (error);
d1135 1
a1135 5
#ifdef COMPAT_OLDSOCK
int
getpeername(uap, retval)
	struct getpeername_args *uap;
	int *retval;
d1137 9
d1147 2
a1148 12
#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 0;
	error = getpeername1(uap, retval);
	uap->compat_43 = temp;
	return (error);
#else
	uap->compat_43 = 0;
	return (getpeername1(uap, retval));
#endif
}
d1150 4
a1153 5
int
ogetpeername(uap, retval)
	struct getpeername_args *uap;
	int *retval;
{
d1155 1
a1155 51
#ifdef __riscos
	/* Preserve this register (yuck!) */
	int temp = uap->compat_43, error;
	uap->compat_43 = 1;
	error = getpeername1(uap, retval);
	uap->compat_43 = temp;
	return (error);
#else
	uap->compat_43 = 1;
	return (getpeername1(uap, retval));
#endif
}
#endif /* COMPAT_OLDSOCK */
int
sockargs(mp, buf, buflen, type)
	struct mbuf **mp;
	caddr_t buf;
	int buflen, type;
{
	register struct sockaddr *sa;
	register struct mbuf *m;
	int error;

	if ((u_int)buflen > MINCONTIG) {
#if defined(COMPAT_OLDSOCK) && !defined(__riscos)
		if (type == MT_SONAME && (u_int)buflen <= 112)
			buflen = MLEN;		/* unix domain compat. hack */
		else
#endif
		return (EINVAL);
	}
	m = ALLOC(buflen, NULL);
	if (m == NULL)
		return (ENOBUFS);
	m->m_type = type;
	error = copyin(buf, mtod(m, caddr_t), (u_int)buflen);
	if (error)
		m_free(m);
	else {
		*mp = m;
		if (type == MT_SONAME) {
			sa = mtod(m, struct sockaddr *);

#if defined(COMPAT_OLDSOCK) && BYTE_ORDER != BIG_ENDIAN
			if (sa->sa_family == 0 && sa->sa_len < AF_MAX)
				sa->sa_family = sa->sa_len;
#endif
			sa->sa_len = buflen;
		}
	}
	return (error);
d1158 1
a1158 2
int
socketclose(int *r)
d1163 2
d1166 2
a1168 1
    int sockid;
d1171 1
a1171 2
    sockid = up->s;
    if ((so = getsock(sockid)) == 0)
d1174 9
a1182 5
    /* KJB - stop events going off after close */
    so->so_pgid = 0;
    error = soclose(so);
    setsockslot(sockid, (struct socket *)0);
    siglist[sockid] = 0;
d1184 1
a1184 1
    return (error);
d1187 1
a1187 12
/*
 * Ioctl system call
 */
struct ioctl_args {
	int	fd;
	int	com;
	caddr_t	data;
};
/* ARGSUSED */
int
socketioctl(uap)
	register struct ioctl_args *uap;
d1189 9
a1197 12
#ifdef __riscos
	register struct socket *so;
#else
	register struct file *fp;
	register struct filedesc *fdp;
	int tmp;
#endif
	register int com, error;
	register u_int size;
	caddr_t data, memp;
#define STK_PARAMS	128
	char stkbuf[STK_PARAMS];
d1199 2
a1200 13
#ifdef __riscos
	if ((so = getsock(uap->fd)) == 0)
		return (EBADF);

	com = uap->com;
#else
	fdp = p->p_fd;
	if ((u_int)uap->fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[uap->fd]) == NULL)
		return (EBADF);

	if ((fp->f_flag & (FREAD | FWRITE)) == 0)
		return (EBADF);
d1202 4
a1205 9
	switch (com = uap->com) {
	case FIONCLEX:
		fdp->fd_ofileflags[uap->fd] &= ~UF_EXCLOSE;
		return (0);
	case FIOCLEX:
		fdp->fd_ofileflags[uap->fd] |= UF_EXCLOSE;
		return (0);
	}
#endif
d1207 1
a1207 129
	/*
	 * Interpret high order word to find amount of data to be
	 * copied to/from the user's address space.
	 */
	size = IOCPARM_LEN(com);
	if (size > IOCPARM_MAX)
		return (ENOTTY);
	memp = NULL;
#ifdef COMPAT_IBCS2
	if (size + IBCS2_RETVAL_SIZE > sizeof (stkbuf)) {
		memp = (caddr_t)malloc((u_long)size + IBCS2_RETVAL_SIZE,
				       M_IOCTLOPS, M_WAITOK);
		if (memp==0)
			return (ENOBUFS);
		data = memp + IBCS2_RETVAL_SIZE;
	} else
		data = stkbuf + IBCS2_RETVAL_SIZE;
	*(int *)(data - IBCS2_RETVAL_SIZE) = IBCS2_MAGIC_IN;
	*(int *)(data - (IBCS2_RETVAL_SIZE - sizeof(int))) = 0;
	*(int *)(data - (IBCS2_RETVAL_SIZE - 2*sizeof(int))) = 0;
#else
	if (size > sizeof (stkbuf)) {
		memp = (caddr_t)malloc((u_long)size, M_IOCTLOPS, M_WAITOK);
		if (memp==0)
			return (ENOBUFS);
		data = memp;
	} else
		data = stkbuf;
#endif
	if (com&IOC_IN) {
		if (size) {
			error = copyin(uap->data, data, (u_int)size);
			if (error) {
				if (memp)
					free(memp, M_IOCTLOPS);
				return (error);
			}
		} else
			*(caddr_t *)data = uap->data;
	} else if ((com&IOC_OUT) && size)
		/*
		 * Zero the buffer so the user always
		 * gets back something deterministic.
		 */
		bzero(data, size);
	else if (com&IOC_VOID)
		*(caddr_t *)data = uap->data;
#ifdef COMPAT_IBCS2
	else if (com)
		/*
		 * Pick up such things as NIOCxx.
		 * Any copyouts will have to be done prior
		 * to return by their servicing code.
		 */
		*(caddr_t *)data = uap->data;
#endif

	switch (com) {
#ifndef __riscos
	case FIONBIO:
		if ((tmp = *(int *)data))
			fp->f_flag |= FNONBLOCK;
		else
			fp->f_flag &= ~FNONBLOCK;
		error = (*fp->f_ops->fo_ioctl)(fp, FIONBIO, (caddr_t)&tmp, p);
		break;

	case FIOASYNC:
		if ((tmp = *(int *)data))
			fp->f_flag |= FASYNC;
		else
			fp->f_flag &= ~FASYNC;
		error = (*fp->f_ops->fo_ioctl)(fp, FIOASYNC, (caddr_t)&tmp, p);
		break;

	case FIOSETOWN:
		tmp = *(int *)data;
		if (fp->f_type == DTYPE_SOCKET) {
			((struct socket *)fp->f_data)->so_pgid = tmp;
			error = 0;
			break;
		}
		if (tmp <= 0) {
			tmp = -tmp;
		} else {
			struct proc *p1 = pfind(tmp);
			if (p1 == 0) {
				error = ESRCH;
				break;
			}
			tmp = p1->p_pgrp->pg_id;
		}
		error = (*fp->f_ops->fo_ioctl)
			(fp, (int)TIOCSPGRP, (caddr_t)&tmp, p);
		break;

	case FIOGETOWN:
		if (fp->f_type == DTYPE_SOCKET) {
			error = 0;
			*(int *)data = ((struct socket *)fp->f_data)->so_pgid;
			break;
		}
		error = (*fp->f_ops->fo_ioctl)(fp, (int)TIOCGPGRP, data, p);
		*(int *)data = -*(int *)data;
		break;
#endif
	default:
#ifdef __riscos
		error = soo_ioctl(so, com, data);
#else
		error = (*fp->f_ops->fo_ioctl)(fp, com, data, p);
#endif
		/*
		 * Copy any data to user, size was
		 * already set and checked above.
		 */
		if (error == 0 && (com&IOC_OUT) && size)
			error = copyout(data, uap->data, (u_int)size);
		break;
	}
#ifdef COMPAT_IBCS2
	if ((*(int *)(data - IBCS2_RETVAL_SIZE)) == IBCS2_MAGIC_OUT) {
		retval[0] = *(int *)(data-(IBCS2_RETVAL_SIZE - sizeof(int)));
		retval[1] = *(int *)(data-(IBCS2_RETVAL_SIZE - 2*sizeof(int)));
	}
#endif
	if (memp)
		free(memp, M_IOCTLOPS);
	return (error);
d1210 1
a1210 13
/*
 * Read system call.
 */
struct read_args {
	int	fd;
	char	*buf;
	u_int	nbyte;
};
/* ARGSUSED */
int
socketread(uap, retval)
	register struct read_args *uap;
	int *retval;
d1212 13
a1224 4
	struct uio auio;
	struct iovec aiov;
	struct socket *so;
    	long cnt, error = 0;
d1226 2
a1227 2
	if ((so = getsock(uap->fd)) == 0)
		return (EBADF);
d1229 5
a1233 30
        aiov.iov_base = (caddr_t)uap->buf;
	aiov.iov_len = uap->nbyte;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;

	auio.uio_resid = uap->nbyte;
	if (auio.uio_resid < 0)
		return (EINVAL);

	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_USERSPACE;
#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO))
		ktriov = aiov;
#endif
	cnt = uap->nbyte;
	if ((error = soreceive(so, (struct mbuf **)0, &auio,
	       (struct mbuf **)0, (struct mbuf **)0, (int *)0)))
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
	cnt -= auio.uio_resid;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO) && error == 0)
		ktrgenio(p->p_tracep, uap->fd, UIO_READ, &ktriov, cnt, error);
#endif
	*retval = cnt;
d1235 2
d1239 1
a1239 12
/*
 * Scatter read system call.
 */
struct readv_args {
	int	fdes;
	struct	iovec *iovp;
	u_int	iovcnt;
};
int
socketreadv(uap, retval)
	register struct readv_args *uap;
	int *retval;
d1241 6
a1246 10
	struct uio auio;
	register struct iovec *iov;
	struct iovec *needfree;
	struct iovec aiov[UIO_SMALLIOV];
	struct socket *so;
	long i, cnt, error = 0;
	u_int iovlen;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
#endif
d1248 4
a1251 60
    	if ((so = getsock(uap->fdes)) == 0)
		return (EBADF);
	/* note: can't use iovlen until iovcnt is validated */
	iovlen = uap->iovcnt * sizeof (struct iovec);
	if (uap->iovcnt > UIO_SMALLIOV) {
		if (uap->iovcnt > UIO_MAXIOV)
			return (EINVAL);
		MALLOC(iov, struct iovec *, iovlen, M_IOV, M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
		needfree = iov;
	} else {
		iov = aiov;
		needfree = NULL;
	}
	auio.uio_iov = iov;
	auio.uio_iovcnt = uap->iovcnt;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_USERSPACE;
	if ((error = copyin((caddr_t)uap->iovp, (caddr_t)iov, iovlen)))
		goto done;
	auio.uio_resid = 0;
	for (i = 0; i < uap->iovcnt; i++) {
		auio.uio_resid += iov->iov_len;
		if (auio.uio_resid < 0) {
			error = EINVAL;
			goto done;
		}
		iov++;
	}
#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO))  {
		MALLOC(ktriov, struct iovec *, iovlen, M_TEMP, M_WAITOK);
		bcopy((caddr_t)auio.uio_iov, (caddr_t)ktriov, iovlen);
	}
#endif
	cnt = auio.uio_resid;
	if ((error = soreceive(so, (struct mbuf **)0, &auio,
	     (struct mbuf **)0, (struct mbuf **)0, (int *)0)))
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
	cnt -= auio.uio_resid;
#ifdef KTRACE
	if (ktriov != NULL) {
		if (error == 0)
			ktrgenio(p->p_tracep, uap->fdes, UIO_READ, ktriov,
			    cnt, error);
		FREE(ktriov, M_TEMP);
	}
#endif
	*retval = cnt;
done:
	if (needfree)
		FREE(needfree, M_IOV);
	return (error);
}
d1253 3
a1255 25
/*
 * Write system call
 */
struct write_args {
	int	fd;
	char	*buf;
	u_int	nbyte;
};
int
socketwrite(uap, retval)
	register struct write_args *uap;
	int *retval;
{
#ifdef __riscos
	register struct socket *so;
#else
	register struct file *fp;
	register struct filedesc *fdp = p->p_fd;
#endif
	struct uio auio;
	struct iovec aiov;
	long cnt, error = 0;
#ifdef KTRACE
	struct iovec ktriov;
#endif
d1257 2
a1258 48
#ifdef __riscos
	if ((so = getsock(uap->fd)) == 0)
		return (EBADF);
#else
	if (((u_int)uap->fd) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[uap->fd]) == NULL ||
	    (fp->f_flag & FWRITE) == 0)
		return (EBADF);
#endif
	aiov.iov_base = (caddr_t)uap->buf;
	aiov.iov_len = uap->nbyte;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_resid = uap->nbyte;
	auio.uio_rw = UIO_WRITE;
	auio.uio_segflg = UIO_USERSPACE;
#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO))
		ktriov = aiov;
#endif
	cnt = uap->nbyte;
#ifdef __riscos
	if ((error = sosend(so, 0, &auio, 0, 0, 0))) {
#else
	if ((error = (*fp->f_ops->fo_write)(fp, &auio, fp->f_cred))) {
#endif
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
		if (error == EPIPE)
#ifdef __riscos
			psignal(pfind(so->so_pgid), SIGPIPE);
#else
			psignal(p, SIGPIPE);
#endif
	}
	cnt -= auio.uio_resid;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO) && error == 0)
		ktrgenio(p->p_tracep, uap->fd, UIO_WRITE,
		    &ktriov, cnt, error);
#endif
	*retval = cnt;
	return (error);
}
d1260 5
a1264 23
/*
 * Gather write system call
 */
struct writev_args {
	int	fd;
	struct	iovec *iovp;
	u_int	iovcnt;
};
int
socketwritev(uap, retval)
	register struct writev_args *uap;
	int *retval;
{
	register struct socket *so;
	struct uio auio;
	register struct iovec *iov;
	struct iovec *needfree;
	struct iovec aiov[UIO_SMALLIOV];
	long i, cnt, error = 0;
	u_int iovlen;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
#endif
d1266 2
a1267 61
	if ((so = getsock(uap->fd)) == 0)
		return (EBADF);
	/* note: can't use iovlen until iovcnt is validated */
	iovlen = uap->iovcnt * sizeof (struct iovec);
	if (uap->iovcnt > UIO_SMALLIOV) {
		if (uap->iovcnt > UIO_MAXIOV)
			return (EINVAL);
		MALLOC(iov, struct iovec *, iovlen, M_IOV, M_WAITOK);
		if (iov == NULL)
			return (ENOBUFS);
		needfree = iov;
	} else {
		iov = aiov;
		needfree = NULL;
	}
	auio.uio_iov = iov;
	auio.uio_iovcnt = uap->iovcnt;
	auio.uio_rw = UIO_WRITE;
	auio.uio_segflg = UIO_USERSPACE;
	if ((error = copyin((caddr_t)uap->iovp, (caddr_t)iov, iovlen)))
		goto done;
	auio.uio_resid = 0;
	for (i = 0; i < uap->iovcnt; i++) {
		auio.uio_resid += iov->iov_len;
		if (auio.uio_resid < 0) {
			error = EINVAL;
			goto done;
		}
		iov++;
	}
#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO))  {
		MALLOC(ktriov, struct iovec *, iovlen, M_TEMP, M_WAITOK);
		bcopy((caddr_t)auio.uio_iov, (caddr_t)ktriov, iovlen);
	}
#endif
	cnt = auio.uio_resid;
	if ((error = sosend(so, 0, &auio, 0, 0, 0))) {
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
		if (error == EPIPE)
			psignal(pfind(so->so_pgid), SIGPIPE);
	}
	cnt -= auio.uio_resid;
#ifdef KTRACE
	if (ktriov != NULL) {
		if (error == 0)
			ktrgenio(p->p_tracep, uap->fd, UIO_WRITE,
				ktriov, cnt, error);
		FREE(ktriov, M_TEMP);
	}
#endif
	*retval = cnt;
done:
	if (needfree)
		FREE(needfree, M_IOV);
	return (error);
a1269 1
int
d1279 2
a1280 2
	if ((so = getsock(up->s)) == 0)
		return (EBADF);
d1282 1
a1282 3
	bzero((caddr_t)(up->ub), sizeof (*(up->ub)));
	up->ub->st_mode = S_IFSOCK;
	return ((*so->so_proto->pr_usrreq)(so, PRU_SENSE,
a1288 1
int
d1295 5
a1299 7
int	selwait, nselcoll;

/*
 * Select system call.
 */
struct select_args {
	u_int	nd;
d1302 90
a1391 54
};
int
socketselect(uap, retval)
	register struct select_args *uap;
	int *retval;
{
	fd_set ibits[3], obits[3];
	struct timeval atv;
	int s, ncoll, error = 0, timo;
	u_int ni;
	int noblock = 0;

	bzero((caddr_t)ibits, sizeof(ibits));
	bzero((caddr_t)obits, sizeof(obits));

	if (uap->nd > SOCKTABSIZE)
		uap->nd = SOCKTABSIZE;	/* forgiving; slightly wrong */
	ni = howmany(uap->nd, NFDBITS) * sizeof(fd_mask);

#define	getbits(name, x) \
	if (uap->name && \
	    (error = copyin((caddr_t)uap->name, (caddr_t)&ibits[x], ni))) \
		goto done;
	getbits(in, 0);
	getbits(ou, 1);
	getbits(ex, 2);
#undef	getbits

	if (uap->tv) {
		error = copyin((caddr_t)uap->tv, (caddr_t)&atv,
			sizeof (atv));
		if (error)
			goto done;
		if (itimerfix(&atv)) {
			error = EINVAL;
			goto done;
		}
		s = splhi();
		timevaladd(&atv, (struct timeval *)&time);
#ifdef DEBUG
		if (DODEBUG(DBGSELECT))
			Printf("atv=(%d,%d), time=(%d,%d)\n",
			            atv.tv_sec, atv.tv_usec,
			            time.tv_sec, time.tv_usec);
#endif
		timo = hzto(&atv);
		/*
		 * Avoid inadvertently sleeping forever.
		 */
		if (timo == 0)
			timo = 1;
		splx(s);
	} else
		timo = 0;
d1393 5
a1397 62
#ifdef DEBUG
	if (DODEBUG(DBGSELECT))
		Printf("\nSelect timeout = %d\n", timo);
#endif
retry:
	ncoll = nselcoll;
    	error = selscan(ibits, obits, uap->nd, retval, &noblock);
    	if (error || *retval)
		goto done;
	s = splhi();
	/* this should be timercmp(&time, &atv, >=) */
	if (uap->tv && (time.tv_sec > atv.tv_sec ||
	    (time.tv_sec == atv.tv_sec && time.tv_usec >= atv.tv_usec))) {
#ifdef DEBUG
		if (DODEBUG(DBGSELECT)) {
			Printf("Time too late ");
			Printf("atv=(%d,%d), time=(%d,%d)\n",
			       atv.tv_sec, atv.tv_usec,
			       time.tv_sec, time.tv_usec);
		}
#endif
		splx(s);
		goto done;
	}
	if (nselcoll != ncoll) {
#ifdef DEBUG
		if (DODEBUG(DBGSELECT))
			Printf("Select has happened ");
#endif
		splx(s);
		goto retry;
	}
#ifdef DEBUG
	if (DODEBUG(DBGSELECT))
		Printf("sleeping ");
#endif
	error = tsleep((caddr_t)&selwait, PSOCK | PCATCH, "select", timo, noblock);
#ifdef DEBUG
	if (DODEBUG(DBGSELECT))
		Printf("woken ");
#endif
	splx(s);
	if (error == 0)
		goto retry;
done:
	/* select is not restarted after signals... */
	if (error == ERESTART)
		error = EINTR;
	if (error == EWOULDBLOCK)
		error = 0;
#define	putbits(name, x) \
	if (uap->name && \
	    (error2 = copyout((caddr_t)&obits[x], (caddr_t)uap->name, ni))) \
		error = error2;
	if (error == 0) {
		int error2;

		putbits(in, 0);
		putbits(ou, 1);
		putbits(ex, 2);
#undef putbits
	}
d1402 1
a1402 4
int
selscan(ibits, obits, nfd, retval, noblock)
	fd_set *ibits, *obits;
	int nfd, *retval, *noblock;
d1404 6
a1409 1
    int msk, i, j, s;
d1411 1
a1411 1
    struct socket *so;
a1412 1
    static int flag[3] = { FREAD, FWRITE, 0 };
d1414 23
a1436 4
    for (msk = 0; msk < 3; msk++) {
	for (i = 0; i < nfd; i += NFDBITS) {
	    bits = ibits[msk].fds_bits[i/NFDBITS];
	    while ((j = ffs(bits)) && (s = i + --j) < nfd) {
d1438 3
a1440 2
		so = getsock(s);
		if (so == NULL)
d1442 4
a1445 3
		*noblock=so->so_state & SS_SLEEPTW;
		if (do_sock_select(so, flag[msk])) {
		    FD_SET(s, &obits[msk]);
d1448 3
d1454 2
a1455 1
    *retval = n;
d1467 1
a1467 7
/*
 * Record a select request.
 */
void
selrecord(selector, sip)
	struct proc *selector;
	struct selinfo *sip;
d1469 1
a1469 14
#ifdef __riscos
	sip->si_flags |= SI_COLL;
#else
	struct proc *p;
	pid_t mypid;

	mypid = selector->p_pid;
	if (sip->si_pid == mypid)
		return;
	if (sip->si_pid && (p = pfind(sip->si_pid)))
		sip->si_flags |= SI_COLL;
	else
		sip->si_pid = mypid;
#endif
d1472 1
a1472 6
/*
 * Do a wakeup when a selectable event occurs.
 */
void
selwakeup(sip)
	register struct selinfo *sip;
d1474 11
a1484 12
#ifdef DEBUG
	if (DODEBUG(DBGSELECT))
       		Printf("selwakeup(%x)\n", sip);
#endif
	if (sip->si_flags & SI_COLL) {
#ifdef DEBUG
		if (DODEBUG(DBGSELECT))
                	Printf("  Waking up!\n");
#endif
		nselcoll++;
		sip->si_flags &= ~SI_COLL;
		wakeup((caddr_t)&selwait);
a1485 1
}
d1487 8
a1494 6
static int
do_sock_select(so, which)
	struct socket *so;
	int which;
{
	struct proc *p=pfind(so->so_pgid);
d1496 2
a1497 1
	switch (which) {
d1499 4
a1502 20
	case FREAD:
		if (soreadable(so))
			return (1);
		selrecord(p, &so->so_rcv.sb_sel);
		so->so_rcv.sb_flags |= SB_SEL;
		break;

	case FWRITE:
		if (sowriteable(so))
			return (1);
		selrecord(p, &so->so_snd.sb_sel);
		so->so_snd.sb_flags |= SB_SEL;
		break;

	case 0:
		if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
			return (1);
		selrecord(p, &so->so_rcv.sb_sel);
		so->so_rcv.sb_flags |= SB_SEL;
		break;
d1504 6
a1509 1
	return (0);
d1512 1
a1512 3
struct socket *
getsock(s)
	int s;
d1514 2
a1515 2
	if (s < 0 || s >= SOCKTABSIZE)
		return ((struct socket *)0);
d1517 1
a1517 1
    	return (socktab[s]);
d1540 8
@


4.1.3.2
log
@RCS Log keyword removed
@
text
@d22 1
a22 1
 * :RCS Log discontinued:
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d22 1
a22 1
 * :RCS Log discontinued:
@

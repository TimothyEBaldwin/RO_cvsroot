head	4.31;
access;
symbols
	Internet-5_65:4.31
	Internet-5_64:4.31
	Internet-5_63:4.31
	Internet-5_62:4.30
	Internet-5_61:4.30
	Internet-5_60:4.29
	Internet-5_59:4.28
	Internet-5_58:4.28
	Internet-5_57:4.28
	Internet-5_56:4.28
	Internet-5_55:4.27
	Internet-5_54:4.26
	Internet-5_53:4.26
	Internet-5_52:4.25
	Internet-5_51:4.25
	Internet-5_50:4.25
	RO_5_07:4.25
	Internet-5_49:4.25
	Internet-5_48:4.25
	Internet-5_47:4.25
	Internet-5_46:4.25
	Internet-5_45:4.24
	Internet-5_44:4.23
	Internet-5_43:4.23
	Internet-5_42:4.22
	Internet-5_41:4.21
	Internet-5_40:4.20
	Internet-5_39:4.20
	Internet-5_38:4.20
	Internet-5_37:4.20
	Internet-5_36:4.19
	Internet-5_35:4.18
	Internet-5_34:4.18
	Internet-5_33:4.17
	Internet-5_32:4.17
	Internet-5_31:4.17
	Internet-5_30:4.16
	Internet-5_29:4.15
	Internet-5_27:4.14
	Internet-5_26:4.14
	Internet-5_25:4.14
	Internet-5_24:4.14
	Internet-5_23:4.13
	Internet-5_22:4.12
	Internet-5_21:4.12
	Internet-5_20:4.11
	Internet-5_19:4.11
	Internet-5_18:4.11
	Internet-5_17:4.10
	Internet-5_16:4.9
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3
	Ursula_RiscPC:4.3.0.4
	Internet-5_15:4.8
	Internet-5_14:4.8
	Internet-5_13:4.8
	sforrest_daytona_appflash-0_31:4.3
	Internet-5_12:4.7
	Internet-5_11:4.3
	celkins_Internet-5_10:4.3
	nicke_Internat_25-9-98:4.3
	Internet-5_09:4.3
	blaughto_daytona_appflash-0_30:4.3
	rthornb_UrsulaBuild-19Aug1998:4.3
	UrsulaBuild_FinalSoftload:4.3
	rthornb_UrsulaBuild-12Aug1998:4.3
	aglover_UrsulaBuild-05Aug1998:4.3
	rthornb_UrsulaBuild-29Jul1998:4.3
	rthornb_UrsulaBuild-22Jul1998:4.3
	rwarren_Internet-5_08:4.3
	Spinner:4.3
	Internet_5_07:4.3
	rthornb_UrsulaBuild-15Jul1998:4.3
	rthornb_UrsulaBuild-07Jul1998:4.3
	rthornb_UrsulaBuild-17Jun1998:4.3
	rthornb_UrsulaBuild-03Jun1998:4.3
	rthornb_UrsulaBuild-27May1998:4.3
	rthornb_UrsulaBuild-21May1998:4.3
	Ursula_bp:4.3
	Ursula:4.3.0.2
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.3
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.3
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.2
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.31
date	2018.01.06.21.44.22;	author jlee;	state Exp;
branches;
next	4.30;
commitid	EZkgEPf3bTXWvRlA;

4.30
date	2015.06.17.22.13.55;	author rsprowson;	state Exp;
branches;
next	4.29;
commitid	BrpcmgDoEfJnHPpy;

4.29
date	2015.01.04.10.35.50;	author rsprowson;	state Exp;
branches;
next	4.28;
commitid	IoIXaBIux4YM6H4y;

4.28
date	2012.05.18.19.47.38;	author rsprowson;	state Exp;
branches;
next	4.27;
commitid	BtYbu9tZVKZi3f5w;

4.27
date	2012.05.10.07.30.28;	author rsprowson;	state Exp;
branches;
next	4.26;
commitid	lytr3Y0VnjYle94w;

4.26
date	2011.12.15.22.20.10;	author rsprowson;	state Exp;
branches;
next	4.25;
commitid	TVCPLXal0LzsSkLv;

4.25
date	2003.11.13.18.02.13;	author bavison;	state Exp;
branches;
next	4.24;

4.24
date	2001.09.06.14.19.39;	author kbracey;	state Exp;
branches;
next	4.23;

4.23
date	2000.07.05.14.48.26;	author kbracey;	state Exp;
branches;
next	4.22;

4.22
date	2000.06.27.15.00.50;	author sbrodie;	state Exp;
branches;
next	4.21;

4.21
date	2000.05.12.11.49.04;	author kbracey;	state Exp;
branches;
next	4.20;

4.20
date	99.10.14.14.42.49;	author kbracey;	state Exp;
branches;
next	4.19;

4.19
date	99.08.27.17.02.40;	author kbracey;	state Exp;
branches;
next	4.18;

4.18
date	99.07.28.12.00.16;	author kbracey;	state Exp;
branches;
next	4.17;

4.17
date	99.07.13.11.13.04;	author kbracey;	state Exp;
branches;
next	4.16;

4.16
date	99.07.08.17.16.19;	author kbracey;	state Exp;
branches;
next	4.15;

4.15
date	99.07.08.15.25.45;	author kbracey;	state Exp;
branches;
next	4.14;

4.14
date	99.06.23.11.58.06;	author kbracey;	state Exp;
branches;
next	4.13;

4.13
date	99.06.07.10.48.06;	author kbracey;	state Exp;
branches;
next	4.12;

4.12
date	99.03.30.12.10.28;	author sbrodie;	state Exp;
branches;
next	4.11;

4.11
date	98.11.28.20.43.08;	author celkins;	state Exp;
branches;
next	4.10;

4.10
date	98.11.27.14.49.08;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	98.11.27.05.07.30;	author celkins;	state Exp;
branches;
next	4.8;

4.8
date	98.10.30.18.22.51;	author celkins;	state Exp;
branches;
next	4.7;

4.7
date	98.10.26.13.01.19;	author sbrodie;	state Exp;
branches;
next	4.6;

4.6
date	98.10.22.14.26.18;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	98.10.22.13.20.31;	author celkins;	state Exp;
branches;
next	4.4;

4.4
date	98.10.20.20.53.05;	author celkins;	state Exp;
branches;
next	4.3;

4.3
date	98.03.27.12.36.38;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.59.06;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.10;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.10;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.20.27;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.30.41;	author nturton;	state Exp;
branches;
next	4.1.3.2;

4.1.3.2
date	96.11.08.17.23.23;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.07.05;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.38;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.07.05;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.50;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.38.51;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.30;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.31
log
@Remove Service_PreReset handler
Detail:
  build/cmhg/InetHdr, riscos/c/module - Internet's PreReset handler leaves the module in a dangerous state; if another module attempts to access a previously-valid socket after Internet has completed its PreReset (or even during it, since the code explicitly triggers callbacks) then it will typically result in a crash due to the mbuf session having been closed.
  Since Internet isn't a hardware driver, it shouldn't need to do anything for Service_PreReset, so let's just remove the handler and leave the NIC drivers to deal with any reset handling (which they already appear to do correctly)
  Also, change InetHdr to use service call number #defines instead of magic numbers.
Admin:
  Tested on Iyonix, iMx6
  Fixes crashes seen on shutdown/reset when software is using sockets from callbacks (e.g. if a VNC server is running)


Version 5.63. Tagged as 'Internet-5_63'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* -*-C-*-
 *
 * module.c - RISC OS front end for Internet protocol module.
 *
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
 *
 */
#include <string.h>
#include <stdio.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"
#include "AsmUtils/callbacks.h"
#include "Global/Services.h"
#include "Global/NewErrors.h"
#include "int_hndlr.h"

#include "sys/param.h"
#include "sys/errno.h"
#include "sys/dcistructs.h"
#include "sys/types.h"
#include "sys/systm.h"
#include "sys/socket.h"
#include "sys/kernel.h"
#include "sys/mbuf.h"
#include "sys/queue.h"
#include "sys/sysctl.h"

#include "net/if.h"
#include "net/route.h"
#include "net/netisr.h"
#include "net/if_types.h"
#include "net/if_dl.h"

#include "netinet/in.h"
#include "netinet/in_systm.h"
#include "netinet/ip.h"
#include "netinet/ip_icmp.h"
#include "netinet/if_ether.h"
#include "netinet/udp.h"
#include "netinet/tcp.h"
#include "netinet/tcp_timer.h"
#include "netinet/in_var.h"
#include "netinet/in_pcb.h"
#include "netinet/icmp_var.h"

#include "module.h"
#include "svcdebug.h"
#include "debug.h"
#include "swiveneers.h"
#include "InetHdr.h"

/*
 * declare the minimum DCI version this module will accept
 * from device drivers.
 */
#if 0
# define DCIMINIMUM	DCIVERSION
#else
# define DCIMINIMUM	401			/* XXX this is exceptional */
#endif

typedef int swi_func_t(_kernel_swi_regs *r, int *retval);

swi_func_t socket, bind, listen, accept;
swi_func_t connect, recv, recvfrom, recvmsg;
swi_func_t send, sendto, sendmsg, shutdown;
swi_func_t setsockopt, getsockopt, getpeername;
swi_func_t getsockname, socketclose;
swi_func_t socketselect, socketioctl, sendtosm;
swi_func_t socketread, socketwrite, socketstat;
swi_func_t socketreadv, socketwritev, getstablesize;
swi_func_t sysctl;
swi_func_t orecv, orecvmsg, osend, osendmsg;
swi_func_t ogetsockname, ogetpeername, oaccept, orecvfrom;
swi_func_t _kvm_nlist, socketversion;

char *berkeley_copyright = "Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994 "
	"The Regents of the University of California.  All rights reserved.";

static swi_func_t *sock_ent[] =
{
    socket,
    bind,
    listen,
    oaccept,
    connect,
    orecv,
    orecvfrom,
    orecvmsg,
    osend,
    sendto,
    osendmsg,
    shutdown,
    setsockopt,
    getsockopt,
    ogetpeername,
    ogetsockname,
    socketclose,
    socketselect,
    socketioctl,
    socketread,
    socketwrite,
    socketstat,
    socketreadv,
    socketwritev,
    getstablesize,
    sendtosm,
    sysctl,
    accept,
    recvfrom,
    recvmsg,
    sendmsg,
    getpeername,
    getsockname,
    _kvm_nlist,
    socketversion,
};

extern void route_proto_init(void);
extern char *getenv(const char *);
extern int sockstats(void);
static int is_gateway_configured(void);

void *module_wsp;
static _kernel_oserror _inet_errblk[4];
static int errcount;

static int inactive = 1;
static int finalising;

extern void *Resources(void); /* From ResGen */
static u_long msgfd[4];
static int msgs_active;

int paniced;
char panicbuf[PANICBUFLEN];

/*
 * declare some constant strings used as
 * tags for looking up error messages
 */
static const char *TagModName = "ModName";
static const char *TagIntErr = "IntErr";
static const char *TagPaniced = "Paniced";
static const char *TagHInInfo = "HInInfo";
static const char *TagSInInfo = "SInInfo";
static const char *TagHInGate = "HInGate";
static const char *TagSInGate = "SInGate";
static const char *TagIsAct = "IsAct";
static const char *TagNotAct = "NotAct";

extern void tick_entry(void);

extern void arp_init(void);

static _kernel_oserror *inet_error(int);

extern int ipforwarding;

/**********************************************************************/

/*
 * init_msgs - initialise MessageTrans by opening resource file
 */
static _kernel_oserror *init_msgs(const char *filename, u_long *fd)
{
    _kernel_oserror *e;

#ifndef ROM
    /*
     * put our messages into ResourceFS
     */
    if( (e = resourcefs_register_files(Resources())) != NULL )
	return(e);
#endif
    /*
     * this code was ripped off from SCormie, guess this first
     * call is to check that the messages file is present.
     */
    if( (e = messagetrans_file_info(filename)) != NULL )
    {
	msgs_active = 0;
	return(e);
    }

    /*
     * this is a bit unpleasant, but necessary - there *may* be
     * errors returned (e.g. file already open) returned from the
     * OpenFile call, *assume* that the message system is active,
     * despite any errors returned.
     */
    msgs_active = 1;

    /*
     * now really do it (r1 is preserved from previous call)
     */
    return messagetrans_open_file(fd, filename, 0);
}

/**********************************************************************/

/*
 * release_msgs - close MessageTrans resource file
 */
static void release_msgs(u_long *fd)
{
    msgs_active = 0;

    messagetrans_close_file(fd);
#ifndef ROM
    resourcefs_deregister_files(Resources());
#endif
}

/**********************************************************************/

/*
 * lookup_tag - try to look up message tag via MessageTrans
 */
static char *lookup_tag(const char *tag)
{
    static char msgbuf[128];
    char *result;

    if( !msgs_active )
	return((char *)tag);

    if (messagetrans_lookup(msgfd, tag, msgbuf, sizeof msgbuf, &result) == NULL)
	return(result);
    else
	return((char *)tag);
}

/**********************************************************************/

/*
 * builderrmess - build an internationalised error message
 */
static void builderrmess(char *dest, char *preamble,
			 const char *tag, char **tail)
{
    if( preamble )
	dest += strlen(strcpy(dest, preamble));

    /*
     * 950331 KWelton
     *
     * any messages with colons in them will confuse MessageTrans,
     * therefore assume that, if the "tag" contains any spaces, then
     * it is a plain string.
     */
    if( !strchr(tag, ' ') )
	strcpy(dest, lookup_tag(tag));
    else
	strcpy(dest, tag);

    if( tail )
	*tail = dest + strlen(dest);
}

/**********************************************************************/

/*
 * malloc_failure - build an error message reporting malloc failure
 */
static _kernel_oserror *malloc_failure(void)
{
	char *tail;

        errcount = (errcount+1)&3;
	_inet_errblk[errcount].errnum = INETERR_MLCFAIL;
	builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
	builderrmess(tail, ": ", TagIntErr, &tail);
	builderrmess(tail, ": ", "MlcFail", NULL);

	return (&_inet_errblk[errcount]);
}

/**********************************************************************/

/*
 * sc_addrchanged - issue InternetStatus service call
 */
void sc_addrchanged(void)
{
    service_internetstatus_address_changed();
}

/**********************************************************************/

#ifdef MULTICAST
#if DCIVERSION < 404
# error "Multicast builds require DCI v4.04 or later (TCPIPLibs-5_01 or later)"
#endif
/*
 * dci4_mc_request - issue DCI4 MulticastRequest SWI calls
 */
_kernel_oserror *dci4_mc_request(struct dib *dib, int flags, int frame_type, u_char *mac, void *ip_addr)
{
    extern int rxf_entry(void);
/*
    printf("SWI MulticastRequest: SWI %x, R0=&%x; unit=%d, frame type=%04x\n"
    	"MAC address: %02x:%02x:%02x:%02x:%02x:%02x\n"
    	"IP address : %d.%d.%d.%d\n", dib->dib_swibase + DCI4MulticastRequest, flags,
    	dib->dib_unit, frame_type, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5],
    	((u_char *)ip_addr)[0], ((u_char *)ip_addr)[1], ((u_char *)ip_addr)[2], ((u_char *)ip_addr)[3]);
*/
    return _swix(dib->dib_swibase + DCI4MulticastRequest, _INR(0,6),
        flags, dib->dib_unit, frame_type, mac, ip_addr, module_wsp, rxf_entry);
}
#endif

/**********************************************************************/

/*
 * sc_protostatus - issue DCIProtocolStatus service call
 */
static void sc_protostatus(int status)
{
    /*
     * XXX
     *
     * declare __module_header as an external *function*
     * -- this stops it being incorrectly relocated
     */
    extern void __module_header(void);
    u_int *address = (u_int *)__module_header;
    u_char *titlestring;

    /*
     * calculate pointer to title string (this is messy)
     */
    titlestring = (u_char *)(address + 4);
    titlestring = ((u_char *)address + *titlestring);

    /*
     * we use our private workspace pointer as a Protocol Handle
     */
    service_dci_protocol_status(module_wsp, status, DCIVERSION, titlestring);
}

/**********************************************************************/

/*
 * dib_register - add the unit described by dib to ifnet chain. returns
 * 1 if unit attached OK, else 0 (this will be because of a malloc failure)
 */
static int dib_register(DibRef dib)
{
    struct arpcom *ac;
    struct ifnet *ifp;
    struct ifaddr *ifa;
    struct sockaddr_dl *sdl;
    struct stats st;
    u_int driver_flags;
    _kernel_oserror *e;
    int mtu, driver_version;
    func_splimp();

#ifdef DEBUG
    if( DODEBUG(DBGSTARTUP) )
	Printf("dib_register: new unit %s%d (dib %x)\n",
	       dib->dib_name, dib->dib_unit, dib);
#endif

    /*
     * only pay attention to those drivers which can handle
     * the required version of DCI 4.
     */
    if( (e = _swix(dib->dib_swibase + DCI4Version, _IN(0)|_OUT(1),
                0, &driver_version)) != NULL || driver_version < DCIMINIMUM )
    {
#ifdef DEBUG
	if( DODEBUG(DBGSTARTUP) )
	    Printf("dib_register: DCI version (%d) is too old\n", driver_version);
#endif

	/*
	 * failed to read DCI version, or it is
	 * too old, silently ignore this unit
	 */
	func_splx();
	return(1);
    }

    /*
     * claim another structure to hold this driver
     */
    if( (ac = (struct arpcom *)malloc(sizeof(*ac), M_IFADDR, M_NOWAIT)) == NULL )
    {
#ifdef DEBUG
	if( DODEBUG(DBGSTARTUP) )
	    Printf("dib_register: failed to claim space for struct arpcom\n");
#endif
	func_splx();
	return(0);
    }

    /*
     * clear the buffer
     */
    memset((caddr_t)ac, 0, sizeof(*ac));

    ifp = &ac->ac_if;

    /*
     * we need struct dib in ifnet for quick comparisons against
     * name & unit, also keep dib_swibase to prevent an extra
     * dereference every time a SWI is raised (e.g. for transmit)
     */
    ifp->if_swibase = dib->dib_swibase;
    ifp->if_dib = dib;
    ifp->if_unit = dib->dib_unit;

    /*
     * have to be a bit more careful with device names
     */
    if( (ifp->if_name = malloc(strlen((char *)dib->dib_name) + 1, M_IFADDR, M_NOWAIT)) == NULL )
    {
#ifdef DEBUG
	if( DODEBUG(DBGSTARTUP) )
	    Printf("dib_register: failed to claim space for if_name\n");
#endif
	func_splx();
	return(0);
    }
    strcpy(ifp->if_name, (char *)dib->dib_name);

    /*
     * initialise function pointers
     */
    ifp->if_output = if_module_output;
    ifp->if_ioctl = if_module_ioctl;

    /*
     * read driver specific features - MTU ...
     */
    (void)_swix(dib->dib_swibase + DCI4GetNetworkMTU, _INR(0,1)|_OUT(2),
                      0, dib->dib_unit, &mtu);
    ifp->if_mtu = (short)mtu;

    /*
     * ... and various Inquiry information
     */
    (void)_swix(dib->dib_swibase + DCI4Inquire, _INR(0,1)|_OUT(2),
                      0, dib->dib_unit, &driver_flags);


    /*
     * ... and some statistics
     */
    (void)_swix(dib->dib_swibase + DCI4Stats, _INR(0,2),
                      1, dib->dib_unit, &st);

    /*
     * "standard" ethernet devices have a unique hardware address,
     * and use ARP protocol to ascertain hardware <-> network
     * address mapping, other devices (e.g. PPP/SLIP) have no hardware
     * address, and do not use ARP.
     */
    if( driver_flags & INQ_HWADDRVALID ) {
	memcpy((caddr_t)ac->ac_enaddr, (caddr_t)dib->dib_address,
	       sizeof(ac->ac_enaddr));
	ifp->if_flags |= IFF_SRCSUPPLIED;
	ifp->if_addrlen = 6;

	/* Take the opportunity to seed the RNG again */
	{
            unsigned int *hw = (unsigned int *) ac->ac_enaddr;
	    srand(rand() ^ hw[0] ^ hw[1]);
	}
    }
    else {
	ifp->if_flags |= IFF_NOARP;
	ifp->if_addrlen = 0;
    }

    if( driver_flags & INQ_POINTOPOINT )
	ifp->if_flags |= IFF_POINTOPOINT;
    else
	ifp->if_flags |= IFF_BROADCAST;

    if (!(driver_flags & INQ_CANREFLECT))
	ifp->if_flags |= IFF_SIMPLEX;

    /*
     * INQ_MULTICAST means we can _receive_ multicast packets (ie you can
     * claim them via DCI-4). This obviously doesn't apply to point-to-point
     * interfaces, so assume that all point-to-point ifs can transmit and receive
     * multicast packets, and that non-point-to-point ifs can transmit and
     * receive them if INQ_MULTICAST is set
     */
    if (driver_flags & (INQ_MULTICAST|INQ_POINTOPOINT))
        ifp->if_flags |= IFF_MULTICAST;

    switch (st.st_interface_type) {
        case ST_TYPE_10BASE5:
        case ST_TYPE_10BASE2:
        case ST_TYPE_10BASET:
        case ST_TYPE_10BASE5N2:
        case ST_TYPE_10BASE2NT:
        case ST_TYPE_RSQUELCH10BASET:
        case ST_TYPE_10BASE5N2NT:
        case ST_TYPE_10BASEFX:
        case ST_TYPE_100BASETX:
        case ST_TYPE_100BASEVG:
        case ST_TYPE_100BASET4:
        case ST_TYPE_100BASEFX:
        case ST_TYPE_ATMFLANE:
        case ST_TYPE_1000BASESX:
        case ST_TYPE_1000BASET:
            ifp->if_type = IFT_ETHER;
            break;
        case ST_TYPE_SERIAL:
            ifp->if_type = IFT_MODEM;
            break;
        case ST_TYPE_PARALLEL:
            ifp->if_type = IFT_PARA;
            break;
        case ST_TYPE_ATM25_6:
        case ST_TYPE_ATM155:
            ifp->if_type = IFT_AAL5;
            ifp->if_flags &= ~IFF_BROADCAST;
            break;
        case ST_TYPE_ATMPLUSRELAY:
            ifp->if_type = IFT_AAL5;
            break;
        default:
            ifp->if_type = IFT_OTHER;
    }
    ifp->if_hdrlen = 14; /* This will do */

    /*
     * that's all - attach and return
     */
#ifdef DEBUG
    if( DODEBUG(DBGSTARTUP) )
	Printf("dib_register: all OK, calling if_attach(%x)\n", ifp);
#endif
    if_attach(ifp);
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
		if ((sdl = (struct sockaddr_dl *)ifa->ifa_addr) &&
		    sdl->sdl_family == AF_LINK) {
			sdl->sdl_type = ifp->if_type;
			sdl->sdl_alen = ifp->if_addrlen;
			bcopy((caddr_t)((struct arpcom *)ifp)->ac_enaddr,
			      LLADDR(sdl), ifp->if_addrlen);
			break;
		}
    func_splx();
    return(1);
}

/**********************************************************************/

/*
 * enumerate_drivers - build a list of all device drivers, and
 * if_attach() them.  returns NULL if all OK, else pointer to
 * standard error block.
 */
static _kernel_oserror *enumerate_drivers(void)
{
    _kernel_oserror *e;
    ChDibRef chd, chdnext;

    /*
     * ensure that ifnet is currently empty
     */
    if( ifnet != NULL )
    {
	char *tail;

        errcount=(errcount+1)&3;
	_inet_errblk[errcount].errnum = INETERR_IFBAD;
	builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
	builderrmess(tail, ": ", TagIntErr, &tail);
	builderrmess(tail, ": ", "IfBad", NULL);
	return (&_inet_errblk[errcount]);
    }

    /*
     * the first entry is *always* the loopback
     * driver - fill it in by hand
     */
    loopattach();

    /*
     * now use service call to obtain a list of all
     * device drivers in the system.
     */
    if( (e = service_enumerate_network_drivers(&chd)) != NULL)
	return(e);

    /*
     * loop over all units, and register them
     */
    for( ; chd != NULL; chd = chdnext )
    {
#ifdef DEBUG
	if( DODEBUG(DBGSTARTUP) )
	    Printf("enumerate_drivers: dib_register %s%d\n",
		   chd->chd_dib->dib_name, chd->chd_dib->dib_unit);
#endif

	if( !dib_register(chd->chd_dib) )
	    /*
	     * dib_register failed, this *must*
	     * have been a malloc failure
	     */
	    return(malloc_failure());

	/*
	 * it is our responsibility to free the chaining
	 * structures back into RMA, so do so.
	 */
	chdnext = chd->chd_next;

        osmodule_free(chd);
    }

    /*
     * all finished
     */
    return(NULL);
}

/**********************************************************************/

/*
 * claim_frames - claim/release all Internet frame types from unit: if
 * claim is 0 then release frame types, else claim frame types. returns
 * error block from Filter SWI, or NULL if no errors.
 */
_kernel_oserror *claim_frames(struct ifnet *ifp, int claim)
{
    _kernel_oserror *e;
    u_int swinum = ifp->if_swibase + DCI4Filter;
    int i;
    unsigned int flags, typenlevel, addrlevel;
    extern int rxf_entry(void);

    (void)&typenlevel;  /* Shut up compiler -fa */

    /*
     * the set of frames claimed depends upon the
     * type of interface - those interfaces which
     * do not support ARP, should not be expected
     * to filter ARP & REVARP frame types for us
     */
    if (ifp->if_flags & IFF_NOARP)
    {
	flags = (claim) ? (FILTER_CLAIM | FILTER_NO_UNSAFE) : FILTER_RELEASE;
	SET_FRAMELEVEL(typenlevel, FRMLVL_E2SPECIFIC);
	SET_FRAMETYPE(typenlevel, ETHERTYPE_IP);

#ifdef MULTICAST
	/*
	 * Tell driver that we support driver filtering of multicasts, but
	 * only if the driver said it could handle it
	 */
#  define ifp_to_dib(ifp) ((struct dib *)(ifp->if_dib))
	if (ifp_to_dib(ifp)->dib_inquire & INQ_FILTERMCAST) {
	        flags |= FILTER_SPECIFIC_MCAST;
	}
#  undef ifp_to_dib
#endif

	/*
	 * point-to-point interfaces have no concept of broadcast,
	 * only ask for specific frames to be filtered
	 */
	addrlevel = (ifp->if_flags & IFF_POINTOPOINT) ?
	    ADDRLVL_SPECIFIC :
#ifdef MULTICAST
            (ifp->if_flags & IFF_MULTICAST ? ADDRLVL_MULTICAST : ADDRLVL_NORMAL);
#else
	    ADDRLVL_NORMAL;
#endif

	e = _swix(swinum, _INR(0,6), flags, ifp->if_unit, typenlevel, addrlevel,
	                             ERRLVL_NO_ERRORS, module_wsp, rxf_entry);
    }
    else
    {
	static int frame_types[] =
	{
	    ETHERTYPE_IP,
	    ETHERTYPE_ARP,
	    ETHERTYPE_REVARP
	};

	/*
	 * fill in standard registers
	 */
	flags = (claim) ? (FILTER_CLAIM | FILTER_NO_UNSAFE) : FILTER_RELEASE;
#ifdef MULTICAST
	/*
	 * Tell driver that we support driver filtering of multicasts
	 */
#  define ifp_to_dib(ifp) ((struct dib *)(ifp->if_dib))
	if (ifp_to_dib(ifp)->dib_inquire & INQ_FILTERMCAST) {
	        flags |= FILTER_SPECIFIC_MCAST;
	}
#  undef ifp_to_dib
#endif

	/*
	 * frame level is the same for all types
	 */
	SET_FRAMELEVEL(typenlevel, FRMLVL_E2SPECIFIC);

	/*
	 * claim all required frame types
	 */
	for( i = 0; i < (sizeof(frame_types) / sizeof(frame_types[0])); ++i )
	{
	    int flags2 = flags;
	    SET_FRAMETYPE(typenlevel, frame_types[i]);

#ifdef MULTICAST
	    /* Only need multicast IP packets */
	    if (frame_types[i] == ETHERTYPE_IP && (ifp->if_flags & IFF_MULTICAST))
	        addrlevel = ADDRLVL_MULTICAST;
	    else {
	        addrlevel = ADDRLVL_NORMAL;
	        flags2 &= ~FILTER_SPECIFIC_MCAST;
	    }
#else
            addrlevel = ADDRLVL_NORMAL;
#endif

            if ( (e=_swix(swinum, _INR(0,6), flags, ifp->if_unit, typenlevel,
	                                     addrlevel, ERRLVL_NO_ERRORS,
	                                     module_wsp, rxf_entry)) )
                break;
	}

	if (!e && claim && (flags & FILTER_SPECIFIC_MCAST))
	    e = if_module_reclaimmulti(ifp);

	/*
	 * release all claimed frame types if an error occured
	 */
	if( e && claim )
	{
	    while( --i >= 0 )
	    {
		SET_FRAMETYPE(typenlevel, frame_types[i]);

		_swix(swinum, _INR(0,2)|_INR(5,6), FILTER_RELEASE, ifp->if_unit,
		                                   typenlevel, module_wsp, rxf_entry);
	    }
	}
    }

    return(e);
}

/**********************************************************************/

/*
 * ifq_flush - empty all frames on ifqueue queues
 */
static void ifq_flush(struct ifqueue *ifq)
{
    struct mbuf *m;

    for(;;)
    {
	IF_DEQUEUE(ifq, m);

	if( m )
	    m_freem(m);
	else
	    break;
    }
}

/**********************************************************************/

_kernel_oserror *inet_final(int fatal, int pbase, void *pw)
{
    struct ifnet *ifp;
    extern struct ifqueue revarpintrq;

    func_splhi();

    finalising = 1;

    /*
     * issue service calls to let other modules know we are dying
     */
    sc_protostatus(DCIPROTOCOL_DYING);

    /*
     * release timeout handler
     */
    removetickerevent(tick_entry);

    /*
     * bring all the interfaces down
     */
    for( ifp = ifnet; ifp; ifp = ifp->if_next )
	if_down(ifp);

    ifq_flush(&ipintrq);
    ifq_flush(&arpintrq);
    ifq_flush(&revarpintrq);

    /*
     * finish session with mbuf manager, ignore any
     * errors (they don't mean much, since session
     * *may* still be closed, despite any errors
     * returned
     */
    (void)mb_close_session();

    /*
     * shutdown MessageTrans
     */
    release_msgs(msgfd);

    /*
     * clear any outstanding callbacks that we may still have
     */
    callback_finalise();

    /*
     * 940816 KWelton
     *
     * I don't think this is necessary for the DCI 4 version
     * of the Internet module, but I will leave it here for
     * the time being.
     */
    usermode_donothing();

    /*
     * 990623 KBracey
     *
     * Probably still a lot of stuff allocated in various chains.
     * Should look into an exhaustive structure clear up one
     * of these days, I suppose.
     */

    func_splx();
    return(NULL);
}

/**********************************************************************/

/*
 * finish_init - perform second phase of module initialisation, i.e.
 * those operations which need the mbuf manager to be active.
 */
static _kernel_oserror *finish_init(void)
{
    _kernel_oserror *e;

    /*
     * this routine should only do anything the
     * first time it is called.
     */
    if( !inactive )
	return(NULL);

    /*
     * initialise mbuf system
     */
    if( (e = mb_entryinit()) != NULL )
    {
	char *tail;
	int msglen;

        errcount=(errcount+1)&3;
	_inet_errblk[errcount].errnum = INETERR_MMBAD;

	builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
	builderrmess(tail, ": ", TagIntErr, &tail);
	builderrmess(tail, ": ", "MmBad", &tail);

	tail += strlen(strcpy(tail, ": "));
	msglen = tail - _inet_errblk[errcount].errmess;
	strncpy(tail, e->errmess, sizeof(_inet_errblk[errcount].errmess) - msglen);

	e = &_inet_errblk[errcount];
	goto out;
    }

    /*
     * no longer inactive
     */
    inactive = 0;

    /*
     * final Internet initialisation
     */
    domaininit();

    /*
     * Set clock
     */
    microtime((struct timeval *) &kerneltime); /* casting away volatile */
    /* Clamp down time to be a whole number of ticks */
    kerneltime.tv_usec = (kerneltime.tv_usec / 10000) * 10000;

    /*
     * Check for power-saving features
     */
    portable_features = portable_read_features();

    /*
     * nearly all done - start calling timer interrupts
     */
    e = calleverytick(tick_entry);

  out:
    /*
     * if something went wrong with initialisation then
     * finalise module before returning error to caller
     */
    if( e != NULL )
	(void)inet_final(1, 0, NULL);
    else
	/*
	 * set a callback to issue a DCIProtocolStatus service
	 * call that announces our presence
	 */
	(void)callback(CALLB_STARTUP);

    return(e);
}

/**********************************************************************/

/*
 * handle_dcidriverstatus - cope with a DriverStatus service call
 */
static void handle_dcidriverstatus(_kernel_swi_regs *r)
{
    DibRef dib = (DibRef)r->r[0];
    struct ifnet *ifp;
    func_splimp();

#ifdef DEBUG
    if( DODEBUG(DBGSTARTUP) )
	Printf("handle_driverstatus: (dib %x) device %s%d %sting\n",
	       dib, dib->dib_name, dib->dib_unit,
	       r->r[2] ? "termina" : "star");
#endif

    /*
     * check DCI version of driver, reject
     * incompatible versions.
     */
    if( r->r[3] < DCIMINIMUM )
    {
#ifdef DEBUG
	if( DODEBUG(DBGSTARTUP) )
	    Printf("handle_driverstatus: module version (%d) is too old\n",
		   r->r[3]);
#endif

	/* ignore this driver */
	return;
    }

    /*
     * find the ifnet structure for this unit
     */
    for( ifp = ifnet; ifp; ifp = ifp->if_next )
	/*
	 * since this is an initialise/finalise call, we cannot
	 * use the standard shortcut of simply comparing dib
	 * addresses, but must compare name and unit to uniquely
	 * identify an interface.
	 */
	if( !strcmp(ifp->if_name, (char *)dib->dib_name) &&
	   ifp->if_unit == dib->dib_unit )
	    break;

#ifdef DEBUG
    if( DODEBUG(DBGSTARTUP) )
    {
	Printf("handle_driverstatus: ifp = %x", ifp);
	if( ifp )
	    Printf(" (%s%d) flags = %x\n",
		   ifp->if_name, ifp->if_unit, ifp->if_flags);
	else
	    Printf("\n");
    }
#endif

    /*
     * check driver status (held in r2)
     */
    if( r->r[2] == DCIDRIVER_DYING )
    {
	/*
	 * driver is terminating. this is slightly problematic, as
	 * the Berkeley Internet code (on which this module is based)
	 * does not expect (and cannot cope) with a driver disappearing.
	 * the best we can do here is to mark the interface as down, and
	 * flag it as missing a driver.	 the driver startup case (below)
	 * should first check whether it service call is from a previously
	 * existing driver, or a completely new startup.
	 */
	if( ifp )
	{
	    ifp->if_flags |= IFF_NODRIVER;
	    ifp->if_flags &= ~IFF_RUNNING;

	    /*
	     * output and ioctl routines now have no meaning,
	     * as the driver does not exist any more
	     */
	    ifp->if_output = if_module_none;
	    ifp->if_ioctl = if_module_null;
	}
	else
	    /*
	     * this should never happen, as we should know about
	     * *all* active drivers in the system.  all we can
	     * do is ignore the dying driver.
	     */
	    ;
    }
    else
    {
	/*
	 * driver is starting up.  as described above, this is
	 * either an old driver re-appearing, or a completely
	 * new driver.
	 *
	 * 941219 KWelton
	 *
	 * device drivers issue this service call under callback,
	 * therefore it can take a *long* time to appear - this
	 * means that the call it not necessarily an old driver
	 * re-appearing, so use IFF_NODRIVER to check whether it
	 * is or not.
	 */
	if( ifp && (ifp->if_flags & IFF_NODRIVER) )
	{
	    ifp->if_flags &= ~IFF_NODRIVER;

	    /*
	     * restore the standard output and ioctl routines
	     */
	    ifp->if_output = if_module_output;
	    ifp->if_ioctl = if_module_ioctl;

	    /*
	     * record the new dib address
	     */
	    ifp->if_dib = dib;

	    /*
	     * if the driver was previously up, then we
	     * should take it back up again.
	     */
	    if( (ifp->if_flags & IFF_UP) )
	    {
		/*
		 * we will need to claim all relevant
		 * frame types from the driver
		 */
		if( claim_frames(ifp, 1) == NULL )
		{
		    /*
		     * we have no means of reporting errors
		     * that occured while claiming frames,
		     * but only mark the interface as running
		     * if no such errors occured.
		     */
		    ifp->if_flags |= IFF_RUNNING;
		}
	    }
	}
	else if( !ifp )
	    /*
	     * unfortunately, there is no way to report any
	     * errors (i.e. malloc failures) that occured
	     * while registering this new interface
	     */
	    (void)dib_register(dib);
    }

    /*
     * finished - restore spl and return
     */
    func_splx();
}

/**********************************************************************/

/*
 * handle_managerstatus - cope with an MbufManagerStatus service call
 */
static void handle_managerstatus(_kernel_swi_regs *r)
{
    _kernel_oserror *e;

    switch(r->r[0])
    {
      case MbufManagerStatus_Started:
	/*
	 * cannot return any error from this call,
	 * so panic if something goes wrong
	 */
	if( (e = finish_init()) != NULL )
	    panic(e->errmess);

	break;

      case MbufManagerStatus_Stopping:
	/*
	 * should only ever see this message if we are
	 * finalising our own module, otherwise something
	 * has gone terribly wrong (the mbuf manager should
	 * only stop when all its clients have closed their
	 * sessions)
	 */
	if( !finalising )
	    panic("Mbuf manager has stopped");

	break;

      case MbufManagerStatus_Scavenge:
	/*
	 * try to free some mbufs (typically unreassembled
	 * IP fragments)
	 */
	m_reclaim();
	break;

      default:
	break;
    }
}

/**********************************************************************/

/*
 * startup_handler - callback routine used to issue a service call
 * announcing the arrival of the Internet module
 */
_kernel_oserror *startup_handler(_kernel_swi_regs *r, void *pw)
{
    callback_entered(CALLB_STARTUP);

    /*
     * issue the call
     */
    sc_protostatus(DCIPROTOCOL_STARTING);

    return NULL;
}

/**********************************************************************/

#ifdef DEBUG

#define CMOSRead	161
#define CMOSStartByte	31
/*
 * init_debug - use 4 bytes of USER CMOS starting at byte 31
 * to initialise debugctrl
 */
static void init_debug(void)
{
    _kernel_oserror *e;
    int i, b;

    debugctrl = 0;

    for( i = 0; i < 4; ++i )
    {
        if( (e = _swix(OS_Byte, _INR(0,1)|_OUT(2),
                                CMOSRead, CMOSStartByte + i, &b)) != NULL )
	    break;

	debugctrl |= (b << (i * 8));
    }

    /*
     * default is all debug bits on if CMOS read fails
     */
    if( e )
	debugctrl = ~0;
}

#endif

/**********************************************************************/

/*
 * inet_init - module initialisation code
 */
_kernel_oserror *inet_init(const char *cmd_tail, int pbase, void *pw)
{
    _kernel_oserror *e;

    module_wsp = pw;
    ipforwarding = is_gateway_configured();

#ifdef DEBUG
    /*
     * load debug state from CMOS RAM
     */
    init_debug();

    if( DODEBUG(DBGSTARTUP) )
	Printf("inet_init: ipforwarding %sabled\n",
	       ipforwarding ? "en" : "dis");
#endif

    /*
     * open MessageTrans file
     * It is a fatal error if the messages file cannot be opened
     */
    if( (e = init_msgs(Module_MessagesFile, msgfd)) != NULL )
	return(e);

    /*
     * Seed RNG, based on time (with high precision) and our MAC address.
     * May not have a MAC address at this point - so we'll reseed
     * again later when each DCI driver appears...
     */
    {
        struct timeval tv;
        unsigned int id[2];

        microtime(&tv);
        osreadsysinfo_machineid(id);
        srand(tv.tv_sec ^ tv.tv_usec ^ id[0] ^ id[1]);
    }

    /*
     * initialise callout structures
     */
    init_callout();

    /*
     * initialise callback recording system
     */
    callback_init();

    /*
     * generate list of existing device drivers
     */
    if( (e = enumerate_drivers()) != NULL )
	return(e);

    /*
     * initialise sleep management scheme
     */
    sleeptabinit();

    /*
     * some more internet initialisations
     */
    ifinit();
    arp_init();
    sysctl_init();

    /*
     * Initialise tables for Socket_InternalLookup
     */
    kvm_init();

    /*
     * check whether the mbuf manager is loaded
     */
    if( mb_present() )
	return(finish_init());
    else
	/*
	 * must return an OK status to allow
	 * any chance of running later
	 */
	return(NULL);
}

/**********************************************************************/

/*
 * sc_handler - top level handler for service calls
 */
void sc_handler(int sn, _kernel_swi_regs *r, void *pw)
{
    switch(sn)
    {
#ifndef ROM
      case Service_ResourceFSStarting:
	(*(void (*)(void *, void *, void *, void *))r->r[2])(Resources(), 0, 0, (void *)r->r[3]);
	break;
#endif
      case Service_DCIDriverStatus:
	handle_dcidriverstatus(r);
	break;

      case Service_MbufManagerStatus:
	handle_managerstatus(r);
	break;
    }
}

/**********************************************************************/

extern struct ifqueue revarpintrq;

/*
 * Process a list of received packets;
 * each packet is in the an mbuf chain m with
 * a prepended header in a separate mbuf
 */
_kernel_oserror *rxf_handler(_kernel_swi_regs *r, void *pw)
{
	DibRef dib = (DibRef) r->r[0];
	struct mbuf *m = (struct mbuf *) r->r[1];
	struct ifnet *ifp;
	struct ifqueue *inq;
	int s;

#ifdef DEBUG
    	if( DODEBUG(DBGINPUT) )
		Printf("\nRXF: (dib %x) ", dib);
#endif

	/*
	 * try to find the struct ifnet for the unit
	 * which is passing these frames in
	 */
	for (ifp = ifnet; ifp; ifp = ifp->if_next)
		/*
		 * Driver Information Blocks are static, so their addresses
		 * can be used to uniquely identify an interface
		 */
		if (ifp->if_dib == dib)
			break;

	if (!ifp) {
#ifdef DEBUG
		if (DODEBUG(DBGINPUT))
			Printf("no ifp\n\n");
#endif
		return NULL;
	}

#ifdef DEBUG
	if (DODEBUG(DBGINPUT))
		Printf("device %s%d\n", ifp->if_name, ifp->if_unit);
#endif

	if ((ifp->if_flags & IFF_UP | IFF_NEED_IPADDR) == 0) {
#ifdef DEBUG
		if (DODEBUG(DBGINPUT))
			Printf("iff is down!\n");
#endif
		m_freem(m);
		return NULL;
	}
	/*
	 * loop over all received frames, enqueuing them separately
	 *
	 * XXX TRACE XXX
	 *
	 * It would be nice if, at a later point, we could pass the
	 * entire block over in one fell swoop.
	 */
	while (m) {
		int len, rx_frame_type;
		struct mbuf *n;
		RxHdrRef rx = mtod(m, RxHdrRef);

		for (len=0, n=m->m_next; n; n=n->m_next)
			len += n->m_len;

#ifdef DEBUG
	    if( DODEBUG((1 << 17)) )
	    {
		int i = 0;
		struct mbuf *m1;

		Printf("\021\02rxf_handler Packet Dump: (type=%x)\n", rx->rx_frame_type);

		for (m1 = m->m_next; m1; m1 = m1->m_next)
		{
		    int j;
		    u_char *cptr = mtod(m1, u_char *);

		    for (j = 0; j < m1->m_len; ++j)
		    {
			Printf("%02x", *cptr++);

			if (!(++i % 32))
			    Printf("\n");
			else if(!(i % 4))
			    Printf("  ");
		    }
		}

		if (i % 32)
		    Printf("\021\007\n");
	        Printf("\021\07\n");
	    }
#endif
		/*
		 * Stick the packet header on the first real mbuf
		 */
		n = m->m_next;
		if (!n) {
			n = m->m_nextpkt;
			m_freem(m);
			m = n;
			continue;
		}
		n->m_flags = M_PKTHDR;
		n->m_pkthdr.len = len;
		n->m_pkthdr.rcvif = ifp;
		ifp->if_lastchange = time;
		ifp->if_ibytes += len;
		ifp->if_ipackets += 1;
		if (bcmp(etherbroadcastaddr, rx->rx_dst_addr,
		    sizeof(etherbroadcastaddr)) == 0)
			n->m_flags |= M_BCAST;
		else if (rx->rx_dst_addr[0] & 1) {
			/*
			 * We must not receive our own multicasts (RFC1112) -
			 * loopback is the job of the IP layer
			 */
			if (!(ifp->if_flags & IFF_SIMPLEX) &&
			    bcmp(((struct arpcom *)ifp)->ac_enaddr,
			                    rx->rx_src_addr, 6) == 0) {
				n = m->m_nextpkt;
				m_freem(m);
				m = n;
				continue;
			}
			n->m_flags |= M_MCAST;
		}
		if (n->m_flags & (M_BCAST|M_MCAST))
			ifp->if_imcasts++;

		n = m->m_nextpkt;
		/* Following added CE - 981125 to close the hole of freeing mbuf "m",
		 * then dereferencing the header pointer...
		 */
                rx_frame_type = rx->rx_frame_type;
#ifdef QuickMNSAcks
		/* Keep RxHdr on for IP, free it for others */
		if (rx_frame_type != ETHERTYPE_IP)
#endif
			m = m_freen(m);

		switch (rx_frame_type) {
#ifdef INET
		case ETHERTYPE_IP:
			schednetisr(NETISR_IP);
			inq = &ipintrq;
			break;

		case ETHERTYPE_ARP:
			schednetisr(NETISR_ARP);
			inq = &arpintrq;
			break;

		case ETHERTYPE_REVARP:
			schednetisr(NETISR_REVARP);
			inq = &revarpintrq;
			break;
#endif
#ifdef NS
		case ETHERTYPE_NS:
			schednetisr(NETISR_NS);
			inq = &nsintrq;
			break;

#endif
		default:
			m_freem(m);
			m = n;
			continue;
		}

		s = splimp();
#ifndef __riscos
/* KJB 981127 - this is causing problems on some STB MPEG streaming. This check was not
 * present in Internet 4, and my gut feeling is that given that the data has arrived
 * and is sitting in the buffers, it is best to hang on to it in the hope that the
 * next layer will get around to it soon.
 */
		if (IF_QFULL(inq)) {
			IF_DROP(inq);
			m_freem(m);
		} else
#endif
			IF_ENQUEUE(inq, m);
		splx(s);
		m = n;
	}

	return NULL;
}

/**********************************************************************/

/*
 * sock_swi_handler - top level handler for SWI calls
 */
_kernel_oserror *sock_swi_handler(int swinum, _kernel_swi_regs *r,
				  void *pw)
{
    int rval = 0, error, oldstate;
    char *tail;

    /*
     * range check SWI number
     */
    if( swinum >= sizeof(sock_ent) / sizeof(sock_ent[0]) )
    {
#ifdef DEBUG
	if( DODEBUG(DBGUSER) )
	    Printf("\021\01Bad SWI: %d\021\07\n", swinum);
#endif

        errcount=(errcount+1)&3;
	_inet_errblk[errcount].errnum = ErrorNumber_NoSuchSWI;
	builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
	builderrmess(tail, ": ", "InvalSWI", NULL);

	return(&_inet_errblk[errcount]);
    }

#ifdef DEBUG
{
    static char *swinames[] =
    {
	"socket",
	"bind",
	"listen",
	"oaccept",
	"connect",
	"orecv",
	"orecvfrom",
	"orecvmsg",
	"osend",
	"sendto",
	"osendmsg",
	"shutdown",
	"setsockopt",
	"getsockopt",
	"ogetpeername",
	"ogetsockname",
	"socketclose",
	"socketselect",
	"socketioctl",
	"socketread",
	"socketwrite",
	"socketstat",
	"socketreadv",
	"socketwritev",
	"getstablesize",
	"sendtosm",
	"sysctl",
	"accept",
	"recvfrom",
	"recvmsg",
	"sendmsg",
	"getpeername",
	"getsockname",
	"kvm_nlist",
    };

    if( DODEBUG(DBGUSER) )
	Printf("\021\005>%s<...\021\007", swinames[swinum]);
}
#endif

    if( inactive || paniced )
    {
	if( inactive )
	{
	    errcount=(errcount+1)&3;
	    _inet_errblk[errcount].errnum = INETERR_NOMM;
	    builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
	    builderrmess(tail, ": ", "NoMm", NULL);

#ifdef DEBUG
	    if( DODEBUG(DBGUSER) )
		Printf("\021\01module is inactive\021\07\n");
#endif

	    return(&_inet_errblk[errcount]);
	}
	else
	{
	    errcount=(errcount+1)&3;
	    _inet_errblk[errcount].errnum = INETERR_PANICED;

	    builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
	    builderrmess(tail, ": ", TagPaniced, &tail);
	    builderrmess(tail, ": ", panicbuf, NULL);

#ifdef DEBUG
	    if( DODEBUG(DBGUSER) )
		Printf("\021\01panicing with error %d (%s)\021\07\n",
		       _inet_errblk[errcount].errnum, _inet_errblk[errcount].errmess);
#endif

	    return (&_inet_errblk[errcount]);
	}
    }

    oldstate = ensure_irqs_on();

    error = sock_ent[swinum](r, &rval);

    if( !error )
	r->r[0] = rval;

    restore_irqs(oldstate);

#ifdef DEBUG
    if( DODEBUG(DBGUSER) )
    {
	if( error )
	{
	    _kernel_oserror *fail = inet_error(error);

	    Printf("\021\01failing with error %d (%s) (error %d)\021\07\n",
		   fail->errnum, fail->errmess, error);
	    return(fail);
	}
	else
	    Printf("\021\05OK\021\07\n");
    }
#endif

#ifdef DELAY_EVENTS
    sendallsignals();
#endif

    return(inet_error(error));
}

/**********************************************************************/

static _kernel_oserror *inet_error(int error)
{
    static const char *_sys_errlist[] =
    {
	"NONE",
	"PERM",
	"NOENT",
	"SRCH",
	"INTR",
	"IO",
	"NXIO",
	"2BIG",
	"NOEXEC",
	"BADF",
	"CHILD",
	"DEADLK",
	"NOMEM",
	"ACCES",
	"FAULT",
	"NOTBLK",
	"BUSY",
	"EXIST",
	"XDEV",
	"NODEV",
	"NOTDIR",
	"ISDIR",
	"INVAL",
	"NFILE",
	"MFILE",
	"NOTTY",
	"TXTBSY",
	"FBIG",
	"NOSPC",
	"SPIPE",
	"ROFS",
	"MLINK",
	"PIPE",
	"DOM",
	"RANGE",
	"AGAIN",
	"INPROGRESS",
	"ALREADY",
	"NOTSOCK",
	"DESTADDRREQ",
	"MSGSIZE",
	"PROTOTYPE",
	"NOPROTOOPT",
	"PROTONOSUPPORT",
	"SOCKTNOSUPPORT",
	"OPNOTSUPP",
	"PFNOSUPPORT",
	"AFNOSUPPORT",
	"ADDRINUSE",
	"ADDRNOTAVAIL",
	"NETDOWN",
	"NETUNREACH",
	"NETRESET",
	"CONNABORTED",
	"CONNRESET",
	"NOBUFS",
	"ISCONN",
	"NOTCONN",
	"SHUTDOWN",
	"TOOMANYREFS",
	"TIMEDOUT",
	"CONNREFUSED",
	"LOOP",
	"NAMETOOLONG",
	"HOSTDOWN",
	"HOSTUNREACH",
	"NOTEMPTY",
	"PROCLIM",
	"USERS",
	"DQUOT",
	"STALE",
	"REMOTE",
	"BADRPC",
	"RPCMISMATCH",
	"PROGUNAVAIL",
	"PROGMISMATCH",
	"PROCUNAVAIL",
	"NOLCK",
	"NOSYS",
	"FTYPE",
	"AUTH",
	"NEEDAUTH"
    };
    static int _sys_nerr = sizeof(_sys_errlist) / sizeof(_sys_errlist[0]);
    /* Use cyclic error blocks to reduce likelihood of an error message
       being returned from a Socket SWI, a callback going off as the
       SWI is exited, anda new error being generated overwriting the
       original one before the application gets a chance to copy it */

    /*
     * 950227 KWelton
     *
     * make a special case out of
     * tunnelled error messages
     */
    if( error == ETUNNEL )
	return(&errtunnel);

    if (error > _sys_nerr || paniced)
	error = EFAULT;

    if (error)
    {
	errcount = (errcount+1) & 3;
	SETDCI4ERRNO(_inet_errblk[errcount].errnum, error);
	strncpy(_inet_errblk[errcount].errmess,
		lookup_tag(_sys_errlist[error]),
		sizeof(_inet_errblk[errcount].errmess));
	return(&_inet_errblk[errcount]);
    }

    return NULL;
}

/**********************************************************************/

static _kernel_oserror *do_ininfo(int argc, const char *args)
{
	_kernel_oserror *e;
	int res = 0;
	int prot = 0;
	int ifaces = 0;

	if (paniced)
	{
		char *tail;

		/*
		 * 940331 KWelton
		 *
		 * use message block within _inet_errblk as this is a
		 * convenient buffer of suitable size.
		 */
		errcount = (errcount + 1) & 3;
		builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
		builderrmess(tail, ": ", TagPaniced, &tail);
		builderrmess(tail, ": ", panicbuf, NULL);
		printf("%s\n", _inet_errblk[errcount].errmess);
	}

	/* CMHG already checked max args, so argc is in range 0 to 3
	 * by this point
	 */
	if (argc > 0)
	{
		struct
		{
			const char *opt[3];
			char buffer[32];
		} parsed;

		parsed.opt[0] = parsed.opt[1] = parsed.opt[2] = NULL;
		e = _swix(OS_ReadArgs, _INR(0,3), ",,", args, &parsed, sizeof(parsed));
		if (e == NULL)
		{
			while (argc-- > 0)
			{
				if (parsed.opt[argc] == NULL) break;
				switch (*parsed.opt[argc])
				{
					case 'r':
						res = 1;
						break;

					case 'p':
						prot = 1;
						break;

					case 'i':
						ifaces = 1;
						break;
				}
			}
		}
	}
	else
	{
		res = 1; /* Default r */
	}

	if (res)
	{
		printf("%s:\n\n", lookup_tag("ResUse"));
		printf("%s %d\n", lookup_tag("ResSkt"), sockstats());
	}

	if (prot)
	{
		if (res) putchar('\n');
		printf("%s\n", lookup_tag("InfoP"));
	}

	if (ifaces)
	{
		struct ifnet *ifp = ifnet;

		if (res || prot) putchar('\n');
		if (ifnet != NULL)
		{
			printf("Name  MTU    Flags     (ifp)\n");

			while (ifp)
			{
				char name[8];

				sprintf(name, "%.3s%d", ifp->if_name,
				                        ifp->if_unit);
				printf("%-5s %-5ld  %08x  %08p\n",
				       name, ifp->if_mtu, ifp->if_flags, ifp);
				ifp = ifp->if_next;
			}
		}
		else
		{
			printf("%s\n", lookup_tag("NoIf"));
		}
	}

	if (res || prot || ifaces) putchar('\n');
	printf("%s\n", lookup_tag(ipforwarding ? TagIsAct : TagNotAct));

	return NULL;
}

/**********************************************************************/

static _kernel_oserror *do_ingateway(int argc, const char *args)
{
	_kernel_oserror *e;

	/* CMHG already checked max args, so argc is either 0 or 1
	 * by this point
	 */
	if (argc == 0)
	{
		/* Print current status */
		printf("%s\n", lookup_tag(ipforwarding ? TagIsAct
		                                       : TagNotAct));
	}
	else
	{
		struct
		{
			const char *opt;
			char buffer[32];
		} parsed;
		size_t i;

		e = _swix(OS_ReadArgs, _INR(0,3), "", args, &parsed, sizeof(parsed));
		if (e == NULL)
		{
			for (i = 0; i < sizeof(parsed.buffer); i++)
				parsed.buffer[i] = tolower(parsed.buffer[i]);

			/* Accept 1 as a synonym for 'on' and 0 for 'off */
			if( !strcmp(parsed.opt, "on") || !strcmp(parsed.opt, "1") )
				ipforwarding = 1;
			else if( !strcmp(parsed.opt, "off") || !strcmp(parsed.opt, "0") )
				ipforwarding = 0;
			else
				e = (_kernel_oserror *)!(int)NULL;
		}
		if (e != NULL)
		{
			errcount = (errcount + 1) & 3;
			_inet_errblk[errcount].errnum = ErrorNumber_Syntax;
			sprintf(_inet_errblk[errcount].errmess,
			        lookup_tag(TagSInGate));
			return &_inet_errblk[errcount];
		}
	}
	return NULL;
}

/**********************************************************************/

#if defined(CMD_InetDebug) && defined(DEBUG)
static _kernel_oserror *do_indebug(int argc, const char *args)
{
	_kernel_oserror *e;
	int newval;

	/* CMHG already checked max args, so argc is either 0 or 1
	 * by this point
	 */
	if (argc == 1)
	{
		/* Want to set a new value for debugctrl */
		e = _swix(OS_ReadUnsigned, _INR(0,1) | _OUT(2), 16, args,
		                                                &newval);
		if (e != NULL)
		{
			errcount = (errcount + 1) & 3;
			_inet_errblk[errcount].errnum = INETERR_BADCLI;
			sprintf(_inet_errblk[errcount].errmess,
			        "bad debug value '%s'", args);
			return &_inet_errblk[errcount];
		}
		debugctrl = newval;
	}

	printf("debug control set to 0x%02x\n", debugctrl);

	return NULL;
}
#endif

/**********************************************************************/

_kernel_oserror *sock_cli_handler(const char *arg_string, int arg_count,
                                  int cmd_no, void *pw)
{
	char *tail;

#if CMHG_VERSION < 543
#error "Need working help: keyword support in CMHG"
#endif
	switch (cmd_no)
	{
		case CMD_InetInfo:
			return do_ininfo(arg_count, arg_string);

		case CMDHELP_InetInfo:
			printf("%s\n", lookup_tag(TagHInInfo));
			printf("%s", lookup_tag(TagSInInfo));
			return NULL;

		case CMD_InetGateway:
			return do_ingateway(arg_count, arg_string);

		case CMDHELP_InetGateway:
			printf("%s\n", lookup_tag(TagHInGate));
			printf("%s", lookup_tag(TagSInGate));
			return NULL;

#if defined(CMD_InetDebug) && defined(DEBUG)
		case CMD_InetDebug:
			return do_indebug(arg_count, arg_string);

		case CMDHELP_InetDebug:
			printf("*InetDebug can be used to control debug areas\n");
			printf("Syntax: InetDebug [value]");
			return NULL;
#endif
		default:
			errcount = (errcount + 1) & 3;
			_inet_errblk[errcount].errnum = INETERR_BADCLI;
			builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
			builderrmess(tail, ": ", TagIntErr, &tail);
			builderrmess(tail, ": ", "BadCli", NULL);
			return &_inet_errblk[errcount];
	}
}

/**********************************************************************/

static int is_gateway_configured(void)
{
    char *val=getenv("Inet$IsGateway");

    return val != NULL && val[0] != '\0';
}

/**********************************************************************/

/* EOF module.c */
@


4.30
log
@Have Internet look after its own messages
Remove faulty logic for Service_MessageFileClosed, MessageTrans reopens the file, so no need to do it again locally.
Usual register/deregister/reregister code for ResourceFS.
Sort the SWI veneers into order, add veneers for ResourceFS in the RAM case.

Version 5.61. Tagged as 'Internet-5_61'
@
text
@a1308 4
      case Service_PreReset:
	inet_final(1, 0, NULL);
	break;

@


4.29
log
@Fixes to InetGateway InetInfo InetDebug CLI handling
With CMHG 5.43 and later the 'help:' keyword actually does something useful, in that it is possible to distinguish between the command being run and help on that command. The Internet module made various assumptions about CMHG command numbers (not including the autogenerated header) which are no longer true as the help keyword renumbers the command numbers that the command handler receives.
cmhg/InetHdr:
Ammend the syntax string to match other OS commands. Remove the comment on yucky CMHG messing as that's no longer required.
riscos/module.c:
Use the CMHG generated header, correcting function prototypes where needed - this exposed a sin where the Internet module wrote into the user's command buffer when it should not (eg. if the command originated in a read only memory region).
Simplify the despatch to a switch/case statement.
Simplify all the command decoding by using OS_ReadArgs.
Constify lookup_tag().
Delete OLDMBUFSTATS from pre MbufManager era.
Internationalised the strings in *InetInfo.
Fix bug where "NoIf" was printed when no interfaces exist - should have been looked up in the messages file.

Tested briefly in an OMAP4 ROM build. Requires a few more messages in the messages file.

Version 5.60. Tagged as 'Internet-5_60'
@
text
@d147 1
a147 1
static const char *MsgFile = "Resources:$.Resources.Internet.Messages";
d185 7
d226 3
a252 11
 * handle_messagefile - MessageFileClosed service call has been
 * received, so re-open the file if necssary.
 */
static void handle_messagefile(_kernel_swi_regs *r)
{
    (void)init_msgs(MsgFile, msgfd);
}

/**********************************************************************/

/*
d1235 1
a1235 1
     * It is *not* a fatal error if the messages file cannot be opened
d1237 2
a1238 1
    init_msgs(MsgFile, msgfd);
d1313 3
a1315 2
      case Service_MessageFileClosed:
	handle_messagefile(r);
d1317 1
a1317 1

@


4.28
log
@Update to work with TCPIPLibs-5_55.
Also fix a warning from the compiler about m_copyback.

Version 5.56. Tagged as 'Internet-5_56'
@
text
@d23 1
d66 1
a134 9
struct client
{
    _kernel_oserror *(*cli_call)(int argc, char **argv);
};

static _kernel_oserror *do_instats(int argc, char **argv);
static _kernel_oserror *do_gateway(int argc, char **argv);
//static _kernel_oserror *do_checksum(int argc, char **argv);
static _kernel_oserror *do_indebug(int argc, char **argv);
d136 2
a139 8
struct client inet_cli_call[] =
{
    do_instats,
    do_gateway,
    //do_checksum,
    do_indebug
};

a150 2
//extern u_char ipcksum, udpcksum, tcpcksum;

d161 2
d164 1
a167 3
static const char *SynGateway = "Syntax: InetGateway [on|off]";
/*static const char *SynChecksum = "Syntax: InetChecksum [u|t on|off]";*/

d226 1
a226 1
static char *lookup_tag(char *tag)
d232 1
a232 1
	return(tag);
d237 1
a237 1
	return(tag);
d270 1
a270 1
	strcpy(dest, lookup_tag((char *)tag));
d798 1
a798 1
_kernel_oserror *inet_final(void)
d939 1
a939 1
	(void)inet_final();
d1216 1
a1216 1
_kernel_oserror *inet_init(char *cmd_tail, int pbase, void *pw)
d1305 1
a1305 1
void sc_handler(int sn, _kernel_swi_regs *r)
d1310 1
a1310 1
	inet_final();
a1667 78
_kernel_oserror *sock_cli_handler(char *arg_string, int arg_count,
				  int cmd_no, void *pw)
{
    struct client *callp;
    int margc;
    char *margv[20];
    char *cp;
    char **argp = margv;

    if( cmd_no >= sizeof(inet_cli_call) / sizeof(inet_cli_call[0]) )
    {
	char *tail;

        errcount=(errcount+1) & 3;

	_inet_errblk[errcount].errnum = INETERR_BADCLI;

	builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
	builderrmess(tail, ": ", TagIntErr, &tail);
	builderrmess(tail, ": ", "BadCli", NULL);

	return(&_inet_errblk[errcount]);
    }

    /*
     * YEURGH!
     *
     * This time it is RISC OS and cmhg conspiring to necessitate
     * more grungy code: if the arg_count is "too large", assume
     * that this is a help request, rather than a *-command, in
     * which case arg_string is a text buffer, and arg_count is
     * the buffer length, and breaking the string up is a bad idea.
     * The "too large" level is set at 128, on the assumption that
     * the max. length of a command line is 256 bytes which gives a
     * (theoritical) maximum of 128 arguments
     */
    if( arg_count < 128 )
    {
	if( arg_count > 20 )
	    /* limit set by size of margv array */
	    arg_count = 20;

	margc = 0;
	cp = arg_string;
	while (*cp && arg_count-- > 0)
	{
	    while (*cp == ' ' || *cp == '\t')
		cp++;

	    if (*cp == '\0')
		break;

	    *argp++ = cp;
	    margc++;
	    while (*cp != '\0' && *cp != ' ' && *cp != '\t')
		cp++;

	    if (*cp == '\0')
		break;

	    *cp++ = '\0';
	}

	*argp++ = 0;
    }
    else
    {
	/* its a help request */
	margc = arg_count;
	margv[0] = arg_string;
    }

    callp = &inet_cli_call[cmd_no];
    return(callp->cli_call(margc, margv));
}

/**********************************************************************/

d1670 1
a1670 1
    static char *_sys_errlist[] =
d1783 1
a1783 1
    return ((_kernel_oserror *)0);
d1788 1
a1788 3
extern int callbackerr;

_kernel_oserror *do_instats(int argc, char **argv)
d1790 1
a1790 10
    /*
     * see the comments in sock_cli_handler for
     * an explanation of what is happening here
     */
    if( argc < 128 )
    {
	int sockstats(void);
#ifdef OLDMBUFSTATS
	struct mbstat *m = mbstat;
#endif
a1793 1
	int n = 0;
d1795 1
a1795 1
	if( paniced )
d1797 1
a1797 1
	    char *tail;
d1799 11
a1809 11
	    /*
	     * 940331 KWelton
	     *
	     * use message block within _inet_errblk as this is a
	     * convenient buffer of suitable size.
	     */
	    errcount=(errcount+1)&3;
	    builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
	    builderrmess(tail, ": ", TagPaniced, &tail);
	    builderrmess(tail, ": ", panicbuf, NULL);
	    printf("%s\n", _inet_errblk[errcount].errmess);
d1812 3
d1817 9
a1825 3
	    while (argc-- > 0)
	    {
		switch (**argv)
d1827 18
a1844 14
		  case 'r':
		    res = 1;
		    break;

		  case 'p':
		    prot = 1;
		    break;

		  case 'i':
		    ifaces = 1;
		    break;

		  default:
		    break;
a1845 2
		argv++;
	    }
d1848 3
a1850 1
	    res = 1;
d1854 2
a1855 13
	    printf("%s:\n\n", lookup_tag("ResUse"));
	    printf("Sockets\n	 Active %d\n", sockstats());

#ifdef OLDMBUFSTATS
	    printf("Data buffers\n	  Total %ld, InUse %ld, Hiwat %ld, ",
		   m->m_mbufs, m->m_inuse, m->m_hiwat);
	    for (m0 = *mfree; m0; m0 = m0->m_next)
		n++;
	    printf("Mfree %d, ", n);
#endif

	    n = 0;
	    printf("\n");
d1858 4
a1861 2
	if (prot) {
            printf("Use *InetStat -s to examine per-protocol statistics.\n");
d1864 1
a1864 1
	if( ifaces )
d1866 1
a1866 1
	    struct ifnet *ifp = ifnet;
d1868 4
a1871 3
	    if( ifnet )
	    {
		printf("Name Mtu    Flags     (ifp)\n");
d1873 12
a1884 1
		while( ifp )
d1886 1
a1886 6
		    printf("%.2s%d  %-5ld  %08x  %08p\n",
			   ifp->if_name, ifp->if_unit,
			   ifp->if_mtu, ifp->if_flags,
			   ifp);

		    ifp = ifp->if_next;
a1887 3
	    }
	    else
		printf("%s\n", "NoIf");
d1890 2
a1891 2
	printf("\n%s\n",
	       lookup_tag((char *)((ipforwarding) ? TagIsAct : TagNotAct)));
d1893 1
a1893 8
	return(NULL);
    }
    else
    {
	printf("%s\n", lookup_tag("HInInfo"));
	printf("Syntax: *InetInfo [r] [i]");
	return(NULL);
    }
d1898 1
a1898 1
_kernel_oserror *do_gateway(int argc, char **argv)
d1900 4
a1903 9
    /*
     * see the comments in sock_cli_handler for
     * an explanation of what is happening here
     */
    if( argc < 128 )
    {
	/*
	 * is a command, not a help request - argc
	 * will be either 0 or 1
d1905 1
a1905 1
	if( argc == 0 )
d1907 3
a1909 6
	    /*
	     * print current status
	     */
	    printf("%s\n",
		   lookup_tag((char *)((ipforwarding) ?
				       TagIsAct : TagNotAct)));
d1913 6
a1918 3
	    int i;
	    char shortbuf[5];
	    char *cptr = *argv;
d1920 5
a1924 7
	    for( i = 0; i < sizeof(shortbuf); ++i, ++cptr )
	    {
		/*
		 * don't increment cptr in tolower()
		 * as it may be a macro
		 */
		shortbuf[i] = tolower(*cptr);
d1926 9
a1934 7
		/*
		 * RISC OS allows any control character to be used as
		 * a string terminator.  The person responsible for
		 * this scheme needs to be taken out and maimed.
		 * :(
		 */
		if( shortbuf[i] < ' ' )
d1936 5
a1940 3
		    shortbuf[i] = '\0';
		    *cptr = '\0';
		    break;
a1941 18
	    }

	    if( i == sizeof(shortbuf) )
		shortbuf[i - 1] = '\0';

	    /*
	     * XXX
	     *
	     * backwards compatibility - "1" is a
	     * synonym for "on", and "0" equates
	     * to "off"
	     */
	    if( !strcmp(shortbuf, "on") || !strcmp(shortbuf, "1") )
		ipforwarding = 1;
	    else if( !strcmp(shortbuf, "off") || !strcmp(shortbuf, "0") )
		ipforwarding = 0;
	    else
		printf("\n%s\n", SynGateway);
d1943 1
a1943 11
	return(NULL);
    }
    else
    {
	/*
	 * is a help request
	 */
	printf("%s\n", lookup_tag((char *)TagHInGate));
	printf("%s", SynGateway);
	return(NULL);
    }
a1945 1
#if 0
d1948 2
a1949 1
_kernel_oserror *do_checksum(int argc, char **argv)
d1951 5
a1955 9
    /*
     * see the comments in sock_cli_handler for
     * an explanation of what is happening here
     */
    if( argc < 128 )
    {
	/*
	 * is a command, not a help request - argc
	 * will be either 0 or 1
d1957 1
a1957 10
	if( argc == 0 )
	{
	    printf(//"IP checksums are %s, "
		   "UDP checksums are %s, "
		   "TCP checksums are %s.\n",
		   //(ipcksum) ? "on" : "off",
		   (udpcksum) ? "on" : "off",
		   (tcpcksum) ? "on" : "off");
	}
	else
d1959 4
a1962 18
	    int i;
	    char shortbuf[5];
	    char *cptr = *(argv + 1);
	    u_char *iptr = NULL;

	    /*
	     * 950608 KWelton
	     *
	     * I must have been asleep when I wrote this: argc
	     * *should* be 0 or 2 (not 0 or 1), if it is 1 then
	     * an invalid syntax message should be printed.
	     */
	    if( argc == 2 )
	    {
		/*
		 * check the first argument
		 */
		switch( **argv )
d1964 5
a1968 14
		  /*case 'i':
		  case 'I':
		    iptr = &ipcksum;
		    break;*/

		  case 'u':
		  case 'U':
		    iptr = &udpcksum;
		    break;

		  case 't':
		  case 'T':
		    iptr = &tcpcksum;
		    break;
d1970 2
a1971 1
	    }
d1973 1
a1973 14
	    if( iptr != NULL )
	    {
		/*
		 * 1st arg is OK, wrestle once again with
		 * RISC OS to get a usable form of the
		 * second arg
		 */
		for( i = 0; i < sizeof(shortbuf); ++i, ++cptr )
		{
		    /*
		     * don't increment cptr in tolower()
		     * as it may be a macro
		     */
		    shortbuf[i] = tolower(*cptr);
d1975 1
a1975 46
		    /*
		     * XXX (I hate RISC OS!)
		     */
		    if( shortbuf[i] < ' ' )
		    {
			shortbuf[i] = '\0';
			*cptr = '\0';
			break;
		    }
		}

		if( i == sizeof(shortbuf) )
		    shortbuf[i - 1] = '\0';

		/*
		 * it won't hurt to once again treat "1" as
		 * a synonym for "on", and "0" for "off"
		 */
		if( !strcmp(shortbuf, "on") || !strcmp(shortbuf, "1") )
		{
		    *iptr = 1;
		    return(NULL);
		}
		else if( !strcmp(shortbuf, "off") || !strcmp(shortbuf, "0") )
		{
		    *iptr = 0;
		    return(NULL);
		}
	    }

	    /*
	     * to get here, means we failed!
	     */
	    printf("\n%s\n", SynChecksum);
	}
	return(NULL);
    }
    else
    {
	/*
	 * is a help request
	 */
	printf("%s\n", lookup_tag("HInCksum"));
	printf("%s", SynChecksum);
	return(NULL);
    }
d1981 2
a1982 1
_kernel_oserror *do_indebug(int argc, char **argv)
d1984 6
a1989 8
#ifdef DEBUG
    /*
     * see the comments in sock_cli_handler for
     * an explanation of what is happening here
     */
    if( argc < 128 )
    {
	if( argc == 1 )
d1991 2
a1992 4
	    /*
	     * want to set a new value for debugctrl
	     */
	    int newval = strtol(*argv, NULL, 0x10);
d1994 29
a2022 10
	    if( newval == 0 && **argv != '0' )
	    {
                errcount = (errcount+1)&3;
		_inet_errblk[errcount].errnum = DCI4ERRORBLOCK + 0x82;
		sprintf(_inet_errblk[errcount].errmess,
			"bad debug value '%s'", *argv);
		return(&_inet_errblk[errcount]);
	    }
	    else
		debugctrl = newval;
a2023 11

	printf("debug control set to 0x%02x\n", debugctrl);
    }
    else
	printf("*InetDebug can be used to control debug areas\n");

    return(NULL);
#else
    printf("%s\n", lookup_tag("DbgOff"));
    return(NULL);
#endif
a2027 2
extern char *getenv(const char *);

@


4.27
log
@Build fix to work with TCPIPLibs-5_54.

Version 5.55. Tagged as 'Internet-5_55'
@
text
@d29 1
d825 1
a825 1
    sc_protostatus(1);
d1028 1
a1028 1
    if( r->r[2] == 1 )
d1186 1
a1186 1
    sc_protostatus(0);
d1562 1
a1562 1
	_inet_errblk[errcount].errnum = INETERR_INVALIDSWI;
@


4.26
log
@Delete local user_mode_donothing() and replace with usermode_donothing() from AsmUtils.
Makefilse uses ModuleLibs too.
Lots of STM/LDM replaced with Push and Pull macros.
Local definitions in 'swiveneers' replaced with header files.

Version 5.53. Tagged as 'Internet-5_53'
@
text
@d28 1
d2252 1
a2252 1
static int is_gateway_configured()
@


4.25
log
@Commit of two years' worth of changes.
Upped version number, because it's about time it was.

Version 5.46. Tagged as 'Internet-5_46'
@
text
@d27 1
d865 1
a865 1
    user_mode_donothing();
@


4.24
log
@Removed escape acknowledgement again.

This was a bad solution to the problem - acknowledging the escape says that
the module has dealt with it and the calling environment shouldn't take
escape actions. The C library is broken in that when the escape condition
is cleared/acknowledged, it still proceeds to call its SIGINT handler.
Compare this to the correct behaviour of the BASIC run-time; the problem
was originally noticed when calling *Debug, which you have to press Escape
to exit, and it acknowledges that escape, but C still throws SIGINT. When
the C library is fixed (as it shortly will be), if the Internet module
acknowledges escapes, socket calls will return EINTR but not actually
generate SIGINT.

The change was originally made for NFS, whose central code (in common with
most Unix code) retried calls returning EINTR. The problem was that the
escape condition remained unacknowledged so it got stuck in an infinite
loop. The correct fix will be to make sure that any supervisor mode code
such as NFS making blocking socket calls takes appropriate action when EINTR
is returned, or ensures that escape is disabled. Until it is fixed, NFS will
show lock-up symptoms again with this module. Applications will function as
expected, as the C run-time will call the SIGINT handler on exit from the
socket SWI (and acknowledge the escape) - if the signal handler returns the
foreground code can retry the call.

Version 5.45. Tagged as 'Internet-5_45'
@
text
@d539 2
d767 1
a767 1
	if (!e && claim)
@


4.23
log
@Restored DELAY_EVENTS functionality.

Detail:
VideoControl was having a nasty reentrancy problem inside its event handler;
we've been sending out events at points where a BSD Unix system wouldn't and
exposing a number of potential problems. Fixed by restoring the delayed event
scheme used in earlier versions of Internet 5, but with an extra event send
inside the packet input loop which should alleviate the high load problems
seen with the NEC video client.

Seems to work fine, but we've been unable to get the NEC video client to
work at all, let alone test it on this Internet module. Doesn't matter for
now because we're not shipping it :)

Version 5.43. Tagged as 'Internet-5_43'
@
text
@a1652 5
    if ( error == EINTR )
    {
        osbyte_acknowledge_escape();
    }

@


4.22
log
@  Escape handling improved.
Detail:
  Attempts by the Internet module to return from a SWI call with an errno
    value of EINTR are now trapped and the escape condition acknowledged
    to prevent S/W that believes a return value of EINTR means "make the
    system call again" from getting stuck in infinite loops.  This fix
    also stops the Escape being returned by the next SWI to be called by
    the application/module that called the Internet SWI.
Admin:
  Behavioural change dependent on the ACKNOWLEDGE_ESCAPE macro definition.
  This macro is defined by the Makefile in this version.
  Tested on desktop machine.

Version 5.42. Tagged as 'Internet-5_42'
@
text
@a1652 1
#ifdef ACKNOWLEDGE_ESCAPE
d1655 1
a1655 1
        _swix(OS_Byte, _IN(0), 126);
a1656 1
#endif
@


4.21
log
@32-bit code modified to use new macros, plus a couple of fixes.
A (tiny) checksumming speed-up, courtesy of David Seal.

Version 5.41. Tagged as 'Internet-5_41'
@
text
@d1653 7
@


4.20
log
@Added power-saving - calls Portable_Idle when waiting for a network operation
to complete.

Version 5.37. Tagged as 'Internet-5_37'
@
text
@a1527 11
#ifdef __riscos
/* In addition to the above, however, it would be *very* useful to have some measure  *
 * of just how full this interrupt/callback buffer queue is becomming on a RISC OS    *
 * system, since if the above is not fulfilled, mbuf exhaustion is the likely outcome *
 * but this is not the only possible cause of this condition. We'll do this using     *
 * the already defined counters (with a slightly different interpretation) and sysctl *
 * to read them. CE - 981128                                                          *
 */
		if (inq->ifq_len > inq->ifq_maxlen)
			inq->ifq_maxlen = inq->ifq_len;
#endif
@


4.19
log
@Gawd this version number's creeping up.
Attempts to free some mbufs on receipt of MbufManagerStatus_Scavenge.
Extracts DHCP NTP servers setting to Inet$NTPServer.

Version 5.36. Tagged as 'Internet-5_36'
@
text
@d934 5
@


4.18
log
@microtime() now returns microsecond accuracy.
Random number generator now seeded from microtime(), machine ID and
hardware addresses of DCI drivers.
Some previously untested debugging code fixed to compile.

Version 5.34. Tagged as 'Internet-5_34'
@
text
@d1152 2
a1153 1
	 * nothing we can do to help
d1155 1
@


4.17
log
@Added new FreeBSD sysctl handling using linker magic.
A few new sysctls added as a result.
SO_TIMESTAMP now gives real time, not Internet's internal time.
DHCP/BOOTP parsing picks up URL option and pops it into Inet$URL.
Requires TCPIPLibs 5.25 and link 5.12.

Version 5.31. Tagged as 'Internet-5_31'
@
text
@d486 1
a486 1
     * and use ARP protocol to ascertain hardware <-> newtrok
d495 6
d929 3
a931 1
    kerneltime.tv_sec = realtime((long *) &kerneltime.tv_usec); /* casting away volatile */
a1238 8
     */
#ifdef OldCode
    if( (e = init_msgs(MsgFile, msgfd)) != NULL )
	return(e);
#else
    /*
     * 950213 KWelton
     *
d1241 2
a1242 2
    (void)init_msgs(MsgFile, msgfd);
#endif
d1244 3
a1246 1
     * Seed RNG
d1248 8
a1255 1
    srand(realtime(NULL));
@


4.16
log
@Removed debugging.
@
text
@d37 2
d1274 1
@


4.15
log
@* Dynamic ports now assigned in range 49152-65535.
* IP_RECVDSTADDR works for non-unicast packets.
* SO_TIMESTAMP added.
* IP_RECVIF added.
* Various other internal changes merged in from FreeBSD sources.

Version 5.29. Tagged as 'Internet-5_29'
@
text
@d328 1
a328 1

d334 1
a334 1

@


4.14
log
@Modified to keep track of multicast claims on interfaces. It will no longer
lose multicast claims if a replacement driver module is loaded, or if an
interface is configured down.
Now passes correct frame type to MulticastRequest (used to pass a zero frame
level).
No longer asks for multicast ARP or Reverse ARP packets.

Version 5.24. Tagged as 'Internet-5_24'
@
text
@d328 1
a328 1
/*
d333 2
a334 2
    	ip_addr[0], ip_addr[1], ip_addr[2], ip_addr[3]);
*/
a440 1
    ifp->if_flags = IFF_NOTRAILERS;
@


4.13
log
@IP timestamps and TCP sequence numbers now generated from system real-time
clock, rather than local monotonic copy. This gives a better chance of
uniqueness between reboots, as we should have found time from a server
at some stage.
Local clock initialised from system clock with centisecond accuracy.
IP firewalling and multicast routing disabled by default - specify them in
components file if really wanted.

Version 5.23. Tagged as 'Internet-5_23'
@
text
@d325 1
a325 1
_kernel_oserror *dci4_mc_request(struct dib *dib, int flags, int frame_type, u_char *mac, u_char *ip_addr)
a684 3
	else {
	        flags |= FILTER_ALL_MCAST;
	}
a723 3
	else {
	        flags |= FILTER_ALL_MCAST;
	}
d737 1
a739 1
            if ( (e=_swix(swinum, _INR(0,6), flags, ifp->if_unit, typenlevel,
d741 7
a747 2
	                                     ifp->if_flags & IFF_MULTICAST ?
	                                         ADDRLVL_MULTICAST : ADDRLVL_NORMAL,
d749 1
a749 1
	                                     ADDRLVL_NORMAL,
d751 3
a753 1
	                                     ERRLVL_NO_ERRORS,
d758 3
d857 8
d1519 1
a1519 3
		{
		  inq->ifq_maxlen = inq->ifq_len;
		}
@


4.12
log
@  Improved DHCP support.
  Added more ATM interface type support.
Detail:
  RFC2132 DHCP options migrated out of Internet module into TCPIPLibs
    header file protocols/dhcp.h where they belong.
  whoami.c:vend_find_code() now knows about DHCP field overloading and
    will extract options correctly - both normal options and the
    ones extracted from the overloaded field.
  Internet now knows about broadcast-capable ATM (ST_TYPE_ATMPLUSRELAY)
    and LANE (ST_TYPE_ATMFLANE) as interface types, and treats them
    appropriately.
Admin:
  Built and tested in STB22 NEC.
  Requires header file exported by DHCP 0.01
    (CVS: RiscOS/Sources/Networking/DHCP   tag: DHCP-0_01 or later)
  Requires TCPIPLibs 5.10 or later.
    (CVS: RiscOS/Sources/Libs/TCPIPLibs    tag: TCPIPLibs-5_10 or later)

Version 5.21. Tagged as 'Internet-5_21'
@
text
@d910 1
a910 2
    kerneltime.tv_sec = realtime();
    kerneltime.tv_usec = 0;
d1233 1
a1233 1
    srand(realtime());
@


4.11
log
@Enabled usage of interrupt queue maxlen variable as a high water mark
counter on the interrupt/callback buffer queue, so as to enable
monitoring of whether this is the cause of possible mbuf exhaustions,
given that this queue length is now limited only by the case of system
resource depletion.

Version 5.18. Tagged as 'Internet-5_18'
@
text
@d531 1
d544 3
@


4.10
log
@Removed limitation on length of IP interrupt queue, and made psignal
generate events immediately, rather than at the end of callbacks.
In both respects, the behaviour is restored to that of Internet 4. This
fixes some performance problems with data streaming near the limit of the
machine's capability.

Version 5.17. Tagged as 'Internet-5_17'
@
text
@d1495 13
@


4.9
log
@Makefile: added *access command to end of build sequence.
riscos/module.c: closed a free then dereference hole.
netinet/ip_input.c: added additional stats collection and ability to change
                    size of interrupt process receive queue limit.
This must be built against a set of TCPIPLibs of 5.03 or later, otherwise
the added stats collection will fault.

Version 5.16. Tagged as 'Internet-5_16'
@
text
@d1483 6
d1493 1
d1636 1
d1638 1
@


4.8
log
@Modified flags for ATM interfaces again, since currently they internally
fake ARP, and don't work at all if they're not given the opportunity to do so.
Also modified the behaviour of the BOOTP/DHCP client code to ensure
that correct routing information is generated for the interface, and
to request and pick up an additional server name (so that this can be
used by LanManFS over IP to determine where its next stage boot server
is (an IP address isn't much good to it).

Version 5.13. Not tagged
@
text
@d1368 1
a1368 1
		int len;
d1442 4
a1445 1

d1448 1
a1448 1
		if (rx->rx_frame_type != ETHERTYPE_IP)
d1452 1
a1452 1
		switch (rx->rx_frame_type) {
@


4.7
log
@Removed debugging
@
text
@d542 1
@


4.6
log
@  Added multicast filtering support to Internet module
  More boot variables recognised in BOOTP/DHCP responses.
Detail:
  net/if_module.c:
    Interprets multicast ioctl requests and construct SWI parameters
    for passing to riscos/module.c for a call to MulticastRequest SWI.
  riscos/module.c:
    Wrapper for calling above SWI.  Sets appropriate flag bit on
    DCI4 Filter SWI to indicate our support for multicast filtering
    when Inquire SWI indicated that the driver supports it too.
  build/module.h:
    Prototype for dci4_mc_request() wrapper added.
  whoami/whoami.c:
    More variables are now known to the response handler.
    Multiple IP address options are handled (useful for Inet$Resolvers)
    Interoperability workaround for Microsoft DHCP servers added.
Admin:
  Requires RiscOS/Sources/Lib/TCPIPLibs version 5.02 or later.
    (tag: TCPIPLibs-5_02 or later)
  Supporting documentation: DCI4 Functional Specification
    (Drawing number 0284,036/FS; ECO 4112)
  BOOTP client tested against Microsoft DHCP server and standard server.
  Multicast filtering tested against new EtherH driver from I-cubed.
  Multicast filtering tested against old EtherM driver to verify the
    changes do not break older non-DCI 4.04 compliant drivers.

Version 5.12. Tagged as 'Internet-5_12'
@
text
@d328 1
d334 1
d677 6
a682 1
	if (ifp_to_dib(ifp)->dib_inquire & INQ_FILTERMCAST) flags |= FILTER_SPECIFIC_MCAST;
a683 2
#else
	flags |= FILTER_ALL_MCAST;
d719 6
a724 1
	if (ifp_to_dib(ifp)->dib_inquire & INQ_FILTERMCAST) flags |= FILTER_SPECIFIC_MCAST;
a725 2
#else
	flags |= FILTER_ALL_MCAST;
@


4.5
log
@Added ATM25.6 and ATM155 interfaces to interface type table, flagging
type as AAL5, since we use IP over AAL5...
@
text
@d86 2
a87 1
char *berkeley_copyright = "Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994 The Regents of the University of California.  All rights reserved.";
d318 22
d474 1
d669 12
d709 10
@


4.4
log
@Updated interface type table to include the DCI-4.04 defined
Ethernet types - mainly 100MB support - see sys/dcistructs.h
@
text
@d513 4
@


4.3
log
@Missed some changes in the last checkin
@
text
@d500 5
@


4.2
log
@Version Spinner_B7 taken
@
text
@a1173 10
     * initialise Internet protocol structures
     */
    in_proto_init();

    /*
     * initialise route protocol structures
     */
    route_proto_init();

    /*
@


4.1
log
@Initial revision
@
text
@a16 3
 * $Header: /ax/networking:Internet/riscos/module.c:networking  1.13  $
 * $Source: /ax/networking:Internet/riscos/module.c: $
 *
a20 110
 * $Log:	module.c,v $
 * Revision 1.13  95/03/31  14:04:48  kwelton
 * Two more changes:
 * 
 * 1)  builderrmess() only tries to lookup a tag if that tag does not
 *     contain any spaces.
 * 
 * 2)  do_instats() uses the message buffer within the global error
 *     blockfor formatting the panic message.
 * 
 * Revision 1.12  95/03/31  12:00:58  kwelton
 * Two main changes:
 * 
 * 1)  Callback scheme has changed - see log for ../lib/unixenv.c.
 * 
 * 2)  Debugging control is now initialised by reading some user bytes from
 *     CMOS RAM.
 * 
 * Revision 1.11  95/03/19  18:13:58  kwelton
 * Added new function sc_addrchanged(), which issues the InternetStatus
 * service call.
 * 
 * Revision 1.10  95/03/15  15:07:59  kwelton
 * Although the Internet module is now DCI version 4.02, it will
 * accept device drivers build against version 4.01 (the changes
 * between 4.01 and 4.02 do not affect this module).
 * 
 * Revision 1.9  95/03/10  17:32:21  kwelton
 * Added a new *-command InetChecksum which {en,dis}ables IP, UDP, and
 * TCP checksums.  Tidied *-command messages up a bit.
 * 
 * Revision 1.8  95/03/07  16:02:01  kwelton
 * Looks like I was a bit over-zealous with the internationalisation - the
 * syntax of *-commands should *not* be internationalised so that Obey
 * files will work on all territories.  This also allows invalid-syntax
 * entries in the cmhg header file.
 * 
 * Revision 1.7  95/03/01  11:52:22  kwelton
 * A number of changes:
 * 
 * 1)  Added support for the new InetGateway *-command.
 * 
 * 2)  claim_frames() now preserves the error code from the filter call
 *     to interfaces that do not support ARP (i.e. those with IFF_NOARP
 *     set).
 * 
 * 3)  SWI calls are now range checked
 * 
 * 4)  inet_error() can handle "tunnelled" error messages.
 * 
 * 5)  The format of per-protocol statistics printed in do_instats()
 *     has been *completely* overhauled - it now follows the style
 *     of the UNIX netstat -s command.
 * 
 * Revision 1.6  95/02/21  11:30:50  kwelton
 * Two changes:
 * 
 * 1)  The module should still initialise, even if it cannot locate
 *     the messages file in ResourceFS.
 * 
 * 2)  Fixed a couple of bugs concerned with initialising point-to-point
 *     interfaces: claim_frames() now makes the SWI call it has so
 *     carefully set the registers for; dib_register() only sets the
 *     IFF_BROADCAST flag for those interfaces which are not
 *     point-to-point.
 * 
 * Revision 1.5  95/02/01  17:35:09  kwelton
 * Care is taken in inet_final() to flush input queues and to bring
 * interfaces down neatly before the mbuf manager session is closed.
 * Note that killing the Internet module is still a failrly drastic
 * operation - no attempt is made, e.g., to free the mbufs held in
 * routing tables, or to shut down sockets gracefully.
 * 
 * Revision 1.4  95/01/30  18:39:58  kwelton
 * Fixed a couple of bugs, one of them rather unpleasant:
 * 
 * 1)  dib_register() should malloc() some space to hold the device name
 *     from a struct dib: the dib_name is constant only over the life of
 *     the driver to which it belongs; this may be shorter than the life
 *     of the struct ifnet which dib_register() is filling in.
 * 
 * 2)  When handle_dcidriverstatus() detects a driver starting up, it
 *     should only call dib_register() if the the driver has not been
 *     previously registered.
 * 
 * Revision 1.3  95/01/24  16:13:38  kwelton
 * Two changes:
 * 
 * 1)  claim_frames() is a bit more careful about what frame types, and
 *     what address levels are claimed: it does not bother trying to
 *     claim ARP and REVARP frames on those interfaces that do not
 *     support ARP; furthermore, it does not bother asking for broadcast
 *     frames from Point-to-Point interfaces, which have no concept of a
 *     broadcast address.
 * 
 * 2)  sock_swi_handler still needs to return 0 in r0, even when a SWI is
 *     marked as not returning a value.
 * 
 * Revision 1.2  95/01/03  14:07:19  kwelton
 * Two major changes made:
 * 
 * 1)  The new (v4.01) DCI version of DCIProtocolStatus (previously called
 * DCIProtocolDying) service call has been implemented.
 * 
 * 2)  Help on *-commands, and all informational messages have been
 * internationalised.
 * 
 * Revision 1.1  94/12/02  11:44:39  kwelton
 * Initial revision
 * 
a21 1
#include <stdio.h>
d33 1
d35 1
d41 2
d45 1
a49 1
#include "netinet/in_pcb.h"
d53 1
a56 1
#include "instats.h"
d59 1
d71 1
a71 5
struct swient
{
    int swi_rval;
    int (*swi_call)();
};
d73 52
a124 39
int socket(), bind(), listen(), accept();
int connect(), recv(), recvfrom(), recvmsg();
int send(), sendto(), sendmsg(), shutdown();
int setsockopt(), getsockopt(), getpeername();
int getsockname(), socketclose();
int socketselect(), socketioctl(), sendtosm();
int socketread(), socketwrite(), socketstat();
int socketreadv(), socketwritev(), getstablesize();

char *berkeley_copyright = "Copyright (c) 1982, 1986 Regents of the University of California. All rights reserved.";

static struct swient sock_ent[26] =
{
    1, socket,
    0, bind,
    0, listen,
    1, accept,
    0, connect,
    1, recv,
    1, recvfrom,
    1, recvmsg,
    1, send,
    1, sendto,
    1, sendmsg,
    0, shutdown,
    0, setsockopt,
    0, getsockopt,
    0, getpeername,
    0, getsockname,
    0, socketclose,
    1, socketselect,
    0, socketioctl,
    1, socketread,
    1, socketwrite,
    0, socketstat,
    1, socketreadv,
    1, socketwritev,
    1, getstablesize,
    0, sendtosm,
d134 1
a134 1
static _kernel_oserror *do_checksum(int argc, char **argv);
d136 2
d143 1
a143 1
    do_checksum,
d147 3
a149 2
void *module_wsp = 0;
static _kernel_oserror _inet_errblk = { 0 };
d152 1
a152 1
static int finalising = 0;
d154 3
a156 3
static const char MsgFile[] = "Resources:$.Resources.Internet.Messages";
static u_long msgfd[4] = { 0 };
static int msgs_active = 0;
d158 1
a158 1
extern int ipcksum, udpcksum, tcpcksum;
d160 2
a161 2
int paniced = 0;
char panicbuf[PANICBUFLEN] = { 0 };
d167 9
a175 15
static const char TagModName[] = "ModName";
static const char TagIntErr[] = "IntErr";
static const char TagPaniced[] = "Paniced";
static const char TagHInGate[] = "HInGate";
static const char TagIsAct[] = "IsAct";
static const char TagNotAct[] = "NotAct";
static const char TagOn[] = "on";
static const char TagOff[] = "off";

static const char SynGateway[] = "Syntax: InetGateway [on|off]";
static const char SynChecksum[] = "Syntax: InetChecksum [i|u|t on|off]";

extern int tick_entry();
extern int inet_event_entry();
extern int startup_entry();
d177 5
a181 1
extern _kernel_oserror *inet_error(), *inet_claimv(), *calleverytick();
a183 1
extern char *malloc();
a191 1
    _kernel_swi_regs r;
d198 1
a198 2
    r.r[1] = (int)filename;
    if( (e = _kernel_swi(XOS_Bit | MessageTrans_FileInfo, &r, &r)) != NULL )
d215 1
a215 4
    r.r[0] = (int)fd;
    r.r[1] = (int)filename;
    r.r[2] = 0;
    return(_kernel_swi(XOS_Bit | MessageTrans_OpenFile, &r, &r));
a224 2
    _kernel_swi_regs r;

d227 1
a227 2
    r.r[0] = (int)fd;
    (void)_kernel_swi(XOS_Bit | MessageTrans_CloseFile, &r, &r);
d237 2
a238 3
    _kernel_swi_regs r;
    _kernel_oserror *e;
    static char msgbuf[128] = { 0 };
d243 2
a244 13
    /*
     * set all registers to zero - this prevents
     * unwanted parameter substitution
     */
    memset((char *)&r, 0, sizeof(r));

    r.r[0] = (int)msgfd;
    r.r[1] = (int)tag;
    r.r[2] = (int)msgbuf;
    r.r[3] = sizeof(msgbuf);

    if( (e = _kernel_swi(XOS_Bit | MessageTrans_Lookup, &r, &r)) == NULL )
	return((char *)(r.r[2]));
d296 3
a298 2
	_inet_errblk.errnum = INETERR_MLCFAIL;
	builderrmess(_inet_errblk.errmess, NULL, TagModName, &tail);
d302 1
a302 29
	return (&_inet_errblk);
}

/**********************************************************************/

/*
 * init_loopback - initialise internal loopback "driver". returns
 * 1 if loopback successfully initialised, else 0 (this will be
 * because of a malloc failure).
 */
static int init_loopback(void)
{
    extern struct ifnet loif;
    struct ifnet *ifp = &loif;
    static char lbname[] = "lo";

    ifp->if_name = lbname;
    ifp->if_unit = 0;
    ifp->if_mtu = ETHERMTU;
    ifp->if_flags = (IFF_NOTRAILERS | IFF_LOOPBACK);

    ifp->if_init = if_module_null;
    ifp->if_output = looutput;
    ifp->if_ioctl = loioctl;
    ifp->if_reset = if_module_null;

    /* add this to ifnet */
    if_attach(ifp);
    return(1);
d312 1
a312 5
    _kernel_swi_regs r;

    r.r[0] = InternetStatus_AddressChanged;
    r.r[1] = Service_InternetStatus;
    (void)_kernel_swi(XOS_Bit | OS_ServiceCall, &r, &r);
a329 1
    _kernel_swi_regs r;
d341 1
a341 6
    r.r[0] = (int)module_wsp;
    r.r[1] = Service_DCIProtocolStatus;
    r.r[2] = status;
    r.r[4] = (int)titlestring;
    r.r[3] = DCIVERSION;
    (void)_kernel_swi(XOS_Bit | OS_ServiceCall, &r, &r);
d354 3
a357 1
    _kernel_swi_regs r;
d359 2
a360 1
    int s = splimp();
d372 2
a373 3
    r.r[0] = 0;
    if( (e = _kernel_swi(XOS_Bit | (dib->dib_swibase + DCI4Version),
			 &r, &r)) != NULL || r.r[1] < DCIMINIMUM )
d377 1
a377 1
	    Printf("dib_register: DCI version (%d) is too old\n", r.r[1]);
d384 1
a384 1
	splx(s);
d391 1
a391 1
    if( (ac = (struct arpcom *)malloc(sizeof(*ac))) == NULL )
d397 1
a397 1
	splx(s);
d421 1
a421 1
    if( (ifp->if_name = malloc(strlen((char *)dib->dib_name) + 1)) == NULL )
d427 1
a427 1
	splx(s);
a434 1
    ifp->if_init = if_module_null;
a436 1
    ifp->if_reset = if_module_null;
d441 3
a443 5
    r.r[0] = 0;
    r.r[1] = dib->dib_unit;
    (void)_kernel_swi(XOS_Bit | (dib->dib_swibase + DCI4GetNetworkMTU),
		      &r, &r);
    ifp->if_mtu = (short)r.r[2];
d448 8
a455 2
    (void)_kernel_swi(XOS_Bit | (dib->dib_swibase + DCI4Inquire), &r, &r);
    driver_flags = r.r[2];
d463 1
a463 1
    if( driver_flags & INQ_HWADDRVALID )
d466 4
a469 1
    else
d471 2
d479 33
a511 2
    if( driver_flags & INQ_CANREFLECT )
	ifp->if_flags |= IFF_CANREFLECT;
d521 10
a530 1
    splx(s);
a542 1
    _kernel_swi_regs r;
d553 3
a555 2
	_inet_errblk.errnum = INETERR_IFBAD;
	builderrmess(_inet_errblk.errmess, NULL, TagModName, &tail);
d558 1
a558 1
	return (&_inet_errblk);
d565 1
a565 2
    if( !init_loopback() )
	return(malloc_failure());
d571 1
a571 3
    r.r[0] = NULL;
    r.r[1] = Service_EnumerateNetworkDrivers;
    if( (e = _kernel_swi(XOS_Bit | OS_ServiceCall, &r, &r)) != NULL )
d577 1
a577 1
    for( chd = (ChDibRef)r.r[0]; chd != NULL; chd = chdnext )
d598 1
a598 3
	r.r[0] = 7;
	r.r[2] = (int)chd;
	(void)_kernel_swi(XOS_Bit | OS_Module, &r, &r);
a615 1
    _kernel_swi_regs r;
d617 1
a617 1
    u_int swinum = XOS_Bit | (ifp->if_swibase + DCI4Filter);
d619 4
a622 2
    unsigned int typenlevel;
    extern int rxf_entry();
d630 1
a630 1
    if( (ifp->if_flags & IFF_NOARP) )
d632 3
a634 7
	/*
	 * fill in standard registers
	 */
	r.r[0] = (claim) ? (FILTER_CLAIM | FILTER_NO_UNSAFE) : FILTER_RELEASE;
	r.r[1] = ifp->if_unit;
	SET_FRAMELEVEL(r.r[2], FRMLVL_E2SPECIFIC);
	SET_FRAMETYPE(r.r[2], ETHERTYPE_IP);
d640 7
a646 5
	r.r[3] = (ifp->if_flags & IFF_POINTOPOINT) ?
	    ADDRLVL_SPECIFIC : ADDRLVL_NORMAL;
	r.r[4] = ERRLVL_NO_ERRORS;			/* error level */
	r.r[5] = (int)module_wsp;			/* Protocol Handle */
	r.r[6] = (int)rxf_entry;			/* Rx frame handler */
d648 2
a649 1
	e = _kernel_swi(swinum, &r, &r);
d663 1
a663 17
	r.r[0] = (claim) ? (FILTER_CLAIM | FILTER_NO_UNSAFE) : FILTER_RELEASE;
	r.r[1] = ifp->if_unit;
#if 1
	r.r[3] = ADDRLVL_NORMAL;			/* address level */
#else
	/*
	 * TRACE
	 *
	 * only accept directly addressed packets - this will force
	 * remote machines to have hard-wired ARP tables before they
	 * can talk to the local machine (among other things)
	 */
	r.r[3] = ADDRLVL_SPECIFIC;
#endif /* 0/1 */
	r.r[4] = ERRLVL_NO_ERRORS;			/* error level */
	r.r[5] = (int)module_wsp;			/* Protocol Handle */
	r.r[6] = (int)rxf_entry;			/* Rx frame handler */
a675 1
	    r.r[2] = typenlevel;
d677 10
a686 2
	    if( (e = _kernel_swi(swinum, &r, &r)) )
		break;
a693 2
	    r.r[0] = FILTER_RELEASE;

a696 1
		r.r[2] = typenlevel;
d698 2
a699 1
		(void)_kernel_swi(swinum, &r, &r);
d721 1
a721 1
	    FREEM(m);
a730 1
    int s = splhi();
d732 3
d755 2
a756 1
    ifq_flush(&rawintrq);
d764 1
a764 1
    (void)mb_closesession();
d785 1
a785 1
    splx(s);
d814 2
a815 1
	_inet_errblk.errnum = INETERR_MMBAD;
d817 1
a817 1
	builderrmess(_inet_errblk.errmess, NULL, TagModName, &tail);
d822 2
a823 2
	msglen = tail - _inet_errblk.errmess;
	strncpy(tail, e->errmess, sizeof(_inet_errblk.errmess) - msglen);
d825 1
a825 1
	e = &_inet_errblk;
d840 6
d876 1
a876 1
    int s = splimp();
d951 1
a951 1
	    ifp->if_ioctl = if_module_none;
d1025 1
a1025 1
    splx(s);
d1079 1
a1079 1
int startup_handler(void)
d1088 1
a1088 5
    /*
     * finished - return a non-zero value so
     * the cmhg veneers take the correct exit
     */
    return(1);
a1102 1
    _kernel_swi_regs r;
d1104 1
a1104 1
    int i;
a1105 1
    r.r[0] = CMOSRead;
d1110 2
a1111 3
	r.r[1] = CMOSStartByte + i;

	if( (e = _kernel_swi(XOS_Bit | OS_Byte, &r, &r)) != NULL )
d1114 1
a1114 1
	debugctrl |= ((r.r[2] & 0xff) << (i * 8));
a1162 1

d1164 1
a1164 2
     * initialise u-area and struct proc (these are Unix
     * features which are emulated under RISC OS).
d1166 1
a1166 1
    u_init();
d1179 5
a1201 1
    socktabinit();
d1203 6
d1252 2
d1255 3
a1257 1
 * rxf_handler - received frame handler. called from CMHG veneers.
d1259 1
a1259 1
int rxf_handler(_kernel_swi_regs *r, void *pw)
d1261 5
a1265 4
    DibRef dib = (DibRef)(r->r[0]);
    struct mbuf *m0 = (struct mbuf *)(r->r[1]);
    struct ifnet *ifp;
    int s = splhi();
d1268 2
a1269 2
    if( DODEBUG(DBGINPUT) )
	Printf("\nRXF: (dib %x) ", dib);
a1271 5
    /*
     * try to find the struct ifnet for the unit
     * which is passing these frames in
     */
    for( ifp = ifnet; ifp; ifp = ifp->if_next )
d1273 2
a1274 2
	 * Driver Information Blocks are static, so their addresses
	 * can be used to uniquely identify an interface
d1276 7
a1282 2
	if( ifp->if_dib == dib )
	    break;
d1284 1
a1284 5
    /*
     * no interface, no frames recognised
     */
    if( !ifp )
    {
d1286 2
a1287 2
	if( DODEBUG(DBGINPUT) )
	    Printf("no ifp\n\n");
d1289 2
a1290 3
	splx(s);
	return(1);
    }
d1293 2
a1294 2
    if( DODEBUG(DBGINPUT) )
	Printf("device %s%d\n", ifp->if_name, ifp->if_unit);
d1297 8
a1304 10
    /*
     * loop over all received frames, enqueuing them separately
     *
     * XXX TRACE XXX
     *
     * It would be nice if, at a later point, we could pass the
     * entire block over in one fell swoop.
     */
    while( m0 )
    {
d1306 6
a1311 2
	 * some hacky messing around with the mbuf length here;
	 * would be nice if this can be avoided in the future.
d1313 4
a1316 7
	RxHdrRef rx = mtod(m0, RxHdrRef);
	struct mbuf *m;

	/* TRACE */
	if( 0 )
	{
	    struct mbuf *m1 = m0;
d1318 2
a1319 4
	    Printf("\021\002RXF: hdr @@%x", m1);
	    for( m1 = m1->m_next; m1; m1 = m1->m_next )
		Printf("-->%x(%d, %d)", m1, m1->m_type, m1->m_len);
	    Printf("-->(NULL)\n\021\007");
d1321 2
a1322 1
	    if( DODEBUG((1 << 16)) )
d1325 1
d1327 1
a1327 1
		Printf("\021\005Packet Dump:\n");
d1329 1
a1329 1
		for( m1 = m0->m_next; m1; m1 = m1->m_next )
d1334 1
a1334 1
		    for( j = 0; j < m1->m_len; ++j )
d1338 1
a1338 1
			if( !(++i % 32) )
d1340 1
a1340 1
			else if( !(i % 4) )
d1345 1
a1345 1
		if( (i % 32) )
d1347 1
d1349 52
a1400 1
	}
d1402 4
a1405 2
	rx->rx_ptr = ifp;
	m0->m_len = rx->rx_frame_type;
d1407 4
a1410 7
#ifdef DEBUG
	if( DODEBUG(DBGINPUT) )
	{
	    Printf("src %s, ", ether_sprintf(rx->rx_src_addr));
	    Printf("dst %s, type %x\n",
		   ether_sprintf(rx->rx_dst_addr), rx->rx_frame_type);
	}
d1412 5
d1418 6
a1423 4
	/*
	 * move along the frame list, before it is broken below
	 */
	m = m0->m_list;
d1425 9
a1433 12
	/*
	 * add this to the queue of input frames, then
	 * move m0 along to next frame in the chain
	 *
	 * XXX
	 *
	 * this macro will clear the m_list field,
	 * breaking the list of frame chains
	 */
	IF_ENQUEUE(&ipintrq, m0);
	m0 = m;
    }
d1435 1
a1435 11
    /*
     * all done, schedule the soft interrupt and return
     */
    schednetisr(NETISR_IP);

#ifdef DEBUG
    if( DODEBUG(DBGINPUT) )
	Printf("RXF: complete\n");
#endif
    splx(s);
    return(1);
a1445 1
    struct swient *callp;
d1459 3
a1461 2
	_inet_errblk.errnum = INETERR_INVALIDSWI;
	builderrmess(_inet_errblk.errmess, NULL, TagModName, &tail);
d1464 1
a1464 1
	return(&_inet_errblk);
d1469 1
a1469 1
    static char *swinames[26] =
d1474 1
a1474 1
	"accept",
d1476 4
a1479 4
	"recv",
	"recvfrom",
	"recvmsg",
	"send",
d1481 1
a1481 1
	"sendmsg",
d1485 2
a1486 2
	"getpeername",
	"getsockname",
d1496 9
a1504 1
	"sendtosm"
d1516 3
a1518 2
	    _inet_errblk.errnum = INETERR_NOMM;
	    builderrmess(_inet_errblk.errmess, NULL, TagModName, &tail);
d1526 1
a1526 1
	    return(&_inet_errblk);
d1530 2
a1531 1
	    _inet_errblk.errnum = INETERR_PANICED;
d1533 1
a1533 1
	    builderrmess(_inet_errblk.errmess, NULL, TagModName, &tail);
d1540 1
a1540 1
		       _inet_errblk.errnum, _inet_errblk.errmess);
d1543 1
a1543 1
	    return (&_inet_errblk);
a1546 1
    callp = &sock_ent[swinum];
d1549 1
a1549 4
    if (callp->swi_rval)
	error = (*(callp->swi_call))(r, &rval);
    else
	error = (*(callp->swi_call))(r);
d1571 3
d1592 1
a1592 1
	_inet_errblk.errnum = INETERR_BADCLI;
d1594 3
a1596 1
	builderrmess(_inet_errblk.errmess, NULL, TagModName, &tail);
d1600 1
a1600 1
	return(&_inet_errblk);
d1657 1
a1657 1
_kernel_oserror *inet_error(int error)
d1672 1
a1672 1
	"AGAIN",
d1696 1
a1696 1
	"WOULDBLOCK",
d1722 1
a1722 1
	"REFUSED",
d1733 5
a1737 7
	"NOSTR",
	"TIME",
	"NOSR",
	"NOMSG",
	"BADMSG",
	"IDRM",
	"DEADLK",
a1738 7
	"NOMSG",
	"IDRM",
	"LIBVER",
	"LIBACC",
	"LIBLIM",
	"LIBNOENT",
	"LIBNOEXEC",
d1740 3
d1745 4
d1764 3
a1766 2
	SETDCI4ERRNO(_inet_errblk.errnum, error);
	strncpy(_inet_errblk.errmess,
d1768 2
a1769 2
		sizeof(_inet_errblk.errmess));
	return(&_inet_errblk);
a1776 7
static char *plural(int n)
{
    return (n != 1 ? "s" : "");
}

/**********************************************************************/

a1777 25
extern struct ipstat ipstat;
extern struct udpstat udpstat;
extern struct tcpstat tcpstat;

static const char *icmpnames[] = {
	"echo reply",
	"#1",
	"#2",
	"destination unreachable",
	"source quench",
	"routing redirect",
	"#6",
	"#7",
	"echo",
	"#9",
	"#10",
	"time exceeded",
	"parameter problem",
	"time stamp",
	"time stamp reply",
	"information request",
	"information request reply",
	"address mask request",
	"address mask reply",
};
d1787 1
a1787 1
	int sockstats();
d1806 2
a1807 1
	    builderrmess(_inet_errblk.errmess, NULL, TagModName, &tail);
d1810 1
a1810 1
	    printf("%s\n", _inet_errblk.errmess);
d1842 1
a1842 1
	    printf("\%s:\n\n", lookup_tag("ResUse"));
d1857 2
a1858 141
	if (prot)
	{
	    int first, i;

	    printf("\%s:\n\n", lookup_tag("ProtStat"));

	    printf("IP\n");
#if BSD>=43
	    printf("%ld total packets received\n", ipstat.ips_total);
#endif
	    printf("    %ld bad header checksum%s\n",
		   ipstat.ips_badsum, plural(ipstat.ips_badsum));
	    printf("    %ld with size smaller than minimum\n",
		   ipstat.ips_toosmall);
	    printf("    %ld with data size < data length\n",
		   ipstat.ips_tooshort);
	    printf("    %ld with header length < data size\n",
		   ipstat.ips_badhlen);
	    printf("    %ld with data length < header length\n",
		   ipstat.ips_badlen);
#if BSD>=43
	    printf("    %ld fragment%s received\n",
		   ipstat.ips_fragments, plural(ipstat.ips_fragments));
	    printf("    %ld fragment%s dropped (dup or out of space)\n",
		   ipstat.ips_fragdropped, plural(ipstat.ips_fragdropped));
	    printf("    %ld fragment%s dropped after timeout\n",
		   ipstat.ips_fragtimeout, plural(ipstat.ips_fragtimeout));
	    printf("    %ld packet%s forwarded\n",
		   ipstat.ips_forward, plural(ipstat.ips_forward));
	    printf("    %ld packet%s not forwardable\n",
		   ipstat.ips_cantforward, plural(ipstat.ips_cantforward));
	    printf("    %ld redirect%s sent\n",
		   ipstat.ips_redirectsent, plural(ipstat.ips_redirectsent));
#endif

	    printf("ICMP:\n");
	    printf("    %u call%s to icmp_error\n",
		   icmpstat.icps_error, plural(icmpstat.icps_error));
	    printf("    %u error%s not generated 'cuz old message was icmp\n",
		   icmpstat.icps_oldicmp, plural(icmpstat.icps_oldicmp));
	    for (first = 1, i = 0; i < ICMP_MAXTYPE + 1; i++)
		if (icmpstat.icps_outhist[i] != 0)
		{
		    if (first)
		    {
			printf("    Output histogram:\n");
			first = 0;
		    }
		    printf("        %s: %u\n", icmpnames[i],
			   icmpstat.icps_outhist[i]);
		}
	    printf("    %u message%s with bad code fields\n",
		   icmpstat.icps_badcode, plural(icmpstat.icps_badcode));
	    printf("    %u message%s < minimum length\n",
		   icmpstat.icps_tooshort, plural(icmpstat.icps_tooshort));
	    printf("    %u bad checksum%s\n",
		   icmpstat.icps_checksum, plural(icmpstat.icps_checksum));
	    printf("    %u message%s with bad length\n",
		   icmpstat.icps_badlen, plural(icmpstat.icps_badlen));
	    for (first = 1, i = 0; i < ICMP_MAXTYPE + 1; i++)
		if (icmpstat.icps_inhist[i] != 0)
		{
		    if (first)
		    {
			printf("    Input histogram:\n");
			first = 0;
		    }
		    printf("        %s: %u\n", icmpnames[i],
			   icmpstat.icps_inhist[i]);
		}
	    printf("    %u message response%s generated\n",
		   icmpstat.icps_reflect, plural(icmpstat.icps_reflect));

	    printf("TCP:\n");
#define	p(f, m)		printf(m, tcpstat.f, plural(tcpstat.f))
#define	p2(f1, f2, m)	printf(m, tcpstat.f1, plural(tcpstat.f1), tcpstat.f2, plural(tcpstat.f2))

	    p(tcps_sndtotal, "    %ld packet%s sent\n");
	    p2(tcps_sndpack,tcps_sndbyte,
	       "        %ld data packet%s (%ld byte%s)\n");
	    p2(tcps_sndrexmitpack, tcps_sndrexmitbyte,
	       "        %ld data packet%s (%ld byte%s) retransmitted\n");
	    p2(tcps_sndacks, tcps_delack,
	       "        %ld ack-only packet%s (%ld packet%s delayed)\n");
	    p(tcps_sndurg, "        %ld URG only packet%s\n");
	    p(tcps_sndprobe, "        %ld window probe packet%s\n");
	    p(tcps_sndwinup, "        %ld window update packet%s\n");
	    p(tcps_sndctrl, "        %ld control packet%s\n");
	    p(tcps_rcvtotal, "    %ld packet%s received\n");
	    p2(tcps_rcvackpack, tcps_rcvackbyte,
	       "        %ld ack%s (for %ld byte%s)\n");
	    p(tcps_rcvdupack, "        %ld duplicate ack%s\n");
	    p(tcps_rcvacktoomuch, "        %ld ack%s for unsent data\n");
	    p2(tcps_rcvpack, tcps_rcvbyte,
	       "        %ld packet%s (%ld byte%s) received in-sequence\n");
	    p2(tcps_rcvduppack, tcps_rcvdupbyte,
	       "        %ld completely duplicate packet%s (%ld byte%s)\n");
	    p2(tcps_rcvpartduppack, tcps_rcvpartdupbyte,
	       "        %ld packet%s with some dup data (%ld byte%s duped)\n");
	    p2(tcps_rcvoopack, tcps_rcvoobyte,
	       "        %ld out-of-order packet%s (%ld byte%s)\n");
	    p2(tcps_rcvpackafterwin, tcps_rcvbyteafterwin,
	       "        %ld packet%s (%ld byte%s) of data after window\n");
	    p(tcps_rcvwinprobe,
	      "        %ld window probe%s\n");
	    p(tcps_rcvwinupd,
	      "        %ld window update packet%s\n");
	    p(tcps_rcvafterclose,
	      "        %ld packet%s received after close\n");
	    p(tcps_rcvbadsum, "        %ld discarded for bad checksum%s\n");
	    p(tcps_rcvbadoff,
	      "        %ld discarded for bad header offset field%s\n");
	    p(tcps_rcvshort,
	      "        %ld discarded because packet%s too short\n");
	    p(tcps_connattempt, "    %ld connection request%s\n");
	    p(tcps_accepts, "    %ld connection accept%s\n");
	    p(tcps_connects,
	      "    %ld connection%s established (including accepts)\n");
	    p2(tcps_closed, tcps_drops,
	       "    %ld connection%s closed (including %ld drop%s)\n");
	    p(tcps_conndrops, "    %ld embryonic connection%s dropped\n");
	    p2(tcps_rttupdated, tcps_segstimed,
	       "    %ld segment%s updated rtt (of %ld attempt%s)\n");
	    p(tcps_rexmttimeo, "    %ld retransmit timeout%s\n");
	    p(tcps_timeoutdrop,
	      "        %ld connection%s dropped by rexmit timeout\n");
	    p(tcps_persisttimeo, "    %ld persist timeout%s\n");
	    p(tcps_keeptimeo, "    %ld keepalive timeout%s\n");
	    p(tcps_keepprobe, "        %ld keepalive probe%s sent\n");
	    p(tcps_keepdrops,
	      "        %ld connection%s dropped by keepalive\n");
#undef p
#undef p2

	    printf("UDP:\n");
	    printf("    %u incomplete header%s\n",
		   udpstat.udps_hdrops, plural(udpstat.udps_hdrops));
	    printf("    %u bad data length field%s\n",
		   udpstat.udps_badlen, plural(udpstat.udps_badlen));
	    printf("    %u bad checksum%s\n",
		   udpstat.udps_badsum, plural(udpstat.udps_badsum));
d1867 1
a1867 1
		printf("Name  Mtu	 Flags	    (ifp)\n");
d1871 1
a1871 1
		    printf("%.2s%d	 %-4d  %08x  %08p\n",
d1891 1
a1891 1
	printf("Syntax: *InetInfo [r] [i] [p]");
d1977 1
d1994 1
a1994 1
	    printf("IP checksums are %s, "
d1996 4
a1999 4
		   "TCP checksums are %s\n",
		   (ipcksum) ? TagOn : TagOff,
		   (udpcksum) ? TagOn : TagOff,
		   (tcpcksum) ? TagOn : TagOff);
d2006 1
a2006 1
	    int *iptr;
d2009 5
a2013 1
	     * check the first argument
d2015 1
a2015 1
	    switch( **argv )
d2017 14
a2030 4
	      case 'i':
	      case 'I':
		iptr = &ipcksum;
		break;
d2032 5
a2036 13
	      case 'u':
	      case 'U':
		iptr = &udpcksum;
		break;

	      case 't':
	      case 'T':
		iptr = &tcpcksum;
		break;

	      default:
		iptr = NULL;
		break;
d2101 1
d2123 3
a2125 2
		_inet_errblk.errnum = DCI4ERRORBLOCK + 0x82;
		sprintf(_inet_errblk.errmess,
d2127 1
a2127 1
		return(&_inet_errblk);
d2147 2
d2151 1
a2151 2
    _kernel_swi_regs r;
    char namebuf[32];
d2153 1
a2153 6
    r.r[0] = (int)"Inet$IsGateway";
    r.r[1] = (int)namebuf;
    r.r[2] = sizeof(namebuf);
    r.r[3] = 0; r.r[4] = 0;
    return((_kernel_swi(XOS_Bit | OS_ReadVarVal, &r, &r) == 0 &&
	    r.r[2] == 3) ? 1 : 0);
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d17 3
d24 110
d135 1
a146 1
#include "sys/systm.h"
a147 1
#include "sys/kernel.h"
a152 2
#include "net/if_types.h"
#include "net/if_dl.h"
a154 1
#include "netinet/in_systm.h"
d159 1
a162 1
#include "netinet/in_pcb.h"
d166 1
a168 1
#include "swiveneers.h"
d180 5
a184 1
typedef int swi_func_t(_kernel_swi_regs *r, int *retval);
d186 39
a224 52
swi_func_t socket, bind, listen, accept;
swi_func_t connect, recv, recvfrom, recvmsg;
swi_func_t send, sendto, sendmsg, shutdown;
swi_func_t setsockopt, getsockopt, getpeername;
swi_func_t getsockname, socketclose;
swi_func_t socketselect, socketioctl, sendtosm;
swi_func_t socketread, socketwrite, socketstat;
swi_func_t socketreadv, socketwritev, getstablesize;
swi_func_t sysctl;
swi_func_t orecv, orecvmsg, osend, osendmsg;
swi_func_t ogetsockname, ogetpeername, oaccept, orecvfrom;
swi_func_t _kvm_nlist, socketversion;

char *berkeley_copyright = "Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994 The Regents of the University of California.  All rights reserved.";

static swi_func_t *sock_ent[] =
{
    socket,
    bind,
    listen,
    oaccept,
    connect,
    orecv,
    orecvfrom,
    orecvmsg,
    osend,
    sendto,
    osendmsg,
    shutdown,
    setsockopt,
    getsockopt,
    ogetpeername,
    ogetsockname,
    socketclose,
    socketselect,
    socketioctl,
    socketread,
    socketwrite,
    socketstat,
    socketreadv,
    socketwritev,
    getstablesize,
    sendtosm,
    sysctl,
    accept,
    recvfrom,
    recvmsg,
    sendmsg,
    getpeername,
    getsockname,
    _kvm_nlist,
    socketversion,
d234 1
a234 1
//static _kernel_oserror *do_checksum(int argc, char **argv);
a235 2
extern void route_proto_init(void);
static int is_gateway_configured(void);
d241 1
a241 1
    //do_checksum,
d245 2
a246 3
void *module_wsp;
static _kernel_oserror _inet_errblk[4];
static int errcount;
d249 1
a249 1
static int finalising;
d251 3
a253 3
static const char *MsgFile = "Resources:$.Resources.Internet.Messages";
static u_long msgfd[4];
static int msgs_active;
d255 1
a255 1
//extern u_char ipcksum, udpcksum, tcpcksum;
d257 2
a258 2
int paniced;
char panicbuf[PANICBUFLEN];
d264 15
a278 9
static const char *TagModName = "ModName";
static const char *TagIntErr = "IntErr";
static const char *TagPaniced = "Paniced";
static const char *TagHInGate = "HInGate";
static const char *TagIsAct = "IsAct";
static const char *TagNotAct = "NotAct";

static const char *SynGateway = "Syntax: InetGateway [on|off]";
/*static const char *SynChecksum = "Syntax: InetChecksum [u|t on|off]";*/
d280 1
a280 5
extern void tick_entry(void);

extern void arp_init(void);

static _kernel_oserror *inet_error(int);
d283 1
d292 1
d299 2
a300 1
    if( (e = messagetrans_file_info(filename)) != NULL )
d317 4
a320 1
    return messagetrans_open_file(fd, filename, 0);
d330 2
d334 2
a335 1
    messagetrans_close_file(fd);
d345 3
a347 2
    static char msgbuf[128];
    char *result;
d352 13
a364 2
    if (messagetrans_lookup(msgfd, tag, msgbuf, sizeof msgbuf, &result) == NULL)
	return(result);
d416 2
a417 3
        errcount = (errcount+1)&3;
	_inet_errblk[errcount].errnum = INETERR_MLCFAIL;
	builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
d421 29
a449 1
	return (&_inet_errblk[errcount]);
d459 5
a463 1
    service_internetstatus_address_changed();
d481 1
d493 6
a498 1
    service_dci_protocol_status(module_wsp, status, DCIVERSION, titlestring);
a510 3
    struct ifaddr *ifa;
    struct sockaddr_dl *sdl;
    struct stats st;
d512 1
d514 1
a514 2
    int mtu, driver_version;
    func_splimp();
d526 3
a528 2
    if( (e = _swix(dib->dib_swibase + DCI4Version, _IN(0)|_OUT(1),
                0, &driver_version)) != NULL || driver_version < DCIMINIMUM )
d532 1
a532 1
	    Printf("dib_register: DCI version (%d) is too old\n", driver_version);
d539 1
a539 1
	func_splx();
d546 1
a546 1
    if( (ac = (struct arpcom *)malloc(sizeof(*ac), M_IFADDR, M_NOWAIT)) == NULL )
d552 1
a552 1
	func_splx();
d576 1
a576 1
    if( (ifp->if_name = malloc(strlen((char *)dib->dib_name) + 1, M_IFADDR, M_NOWAIT)) == NULL )
d582 1
a582 1
	func_splx();
d590 1
d593 1
d598 5
a602 3
    (void)_swix(dib->dib_swibase + DCI4GetNetworkMTU, _INR(0,1)|_OUT(2),
                      0, dib->dib_unit, &mtu);
    ifp->if_mtu = (short)mtu;
d607 2
a608 8
    (void)_swix(dib->dib_swibase + DCI4Inquire, _INR(0,1)|_OUT(2),
                      0, dib->dib_unit, &driver_flags);

    /*
     * ... and some statistics
     */
    (void)_swix(dib->dib_swibase + DCI4Stats, _INR(0,2),
                      1, dib->dib_unit, &st);
d616 1
a616 1
    if( driver_flags & INQ_HWADDRVALID ) {
d619 1
a619 4
	ifp->if_flags |= IFF_SRCSUPPLIED;
	ifp->if_addrlen = 6;
    }
    else {
a620 2
	ifp->if_addrlen = 0;
    }
d627 2
a628 33
    if (!(driver_flags & INQ_CANREFLECT))
	ifp->if_flags |= IFF_SIMPLEX;

    /*
     * INQ_MULTICAST means we can _receive_ multicast packets (ie you can
     * claim them via DCI-4). This obviously doesn't apply to point-to-point
     * interfaces, so assume that all point-to-point ifs can transmit and receive
     * multicast packets, and that non-point-to-point ifs can transmit and
     * receive them if INQ_MULTICAST is set
     */
    if (driver_flags & (INQ_MULTICAST|INQ_POINTOPOINT))
        ifp->if_flags |= IFF_MULTICAST;

    switch (st.st_interface_type) {
        case ST_TYPE_10BASE5:
        case ST_TYPE_10BASE2:
        case ST_TYPE_10BASET:
        case ST_TYPE_10BASE5N2:
        case ST_TYPE_10BASE2NT:
        case ST_TYPE_RSQUELCH10BASET:
        case ST_TYPE_10BASE5N2NT:
            ifp->if_type = IFT_ETHER;
            break;
        case ST_TYPE_SERIAL:
            ifp->if_type = IFT_MODEM;
            break;
        case ST_TYPE_PARALLEL:
            ifp->if_type = IFT_PARA;
            break;
        default:
            ifp->if_type = IFT_OTHER;
    }
    ifp->if_hdrlen = 14; /* This will do */
d638 1
a638 10
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
		if ((sdl = (struct sockaddr_dl *)ifa->ifa_addr) &&
		    sdl->sdl_family == AF_LINK) {
			sdl->sdl_type = ifp->if_type;
			sdl->sdl_alen = ifp->if_addrlen;
			bcopy((caddr_t)((struct arpcom *)ifp)->ac_enaddr,
			      LLADDR(sdl), ifp->if_addrlen);
			break;
		}
    func_splx();
d651 1
d662 2
a663 3
        errcount=(errcount+1)&3;
	_inet_errblk[errcount].errnum = INETERR_IFBAD;
	builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
d666 1
a666 1
	return (&_inet_errblk[errcount]);
d673 2
a674 1
    loopattach();
d680 3
a682 1
    if( (e = service_enumerate_network_drivers(&chd)) != NULL)
d688 1
a688 1
    for( ; chd != NULL; chd = chdnext )
d709 3
a711 1
        osmodule_free(chd);
d729 1
d731 1
a731 1
    u_int swinum = ifp->if_swibase + DCI4Filter;
d733 2
a734 4
    unsigned int flags, typenlevel, addrlevel;
    extern int rxf_entry(void);

    (void)&typenlevel;  /* Shut up compiler -fa */
d742 1
a742 1
    if (ifp->if_flags & IFF_NOARP)
d744 7
a750 3
	flags = (claim) ? (FILTER_CLAIM | FILTER_NO_UNSAFE) : FILTER_RELEASE;
	SET_FRAMELEVEL(typenlevel, FRMLVL_E2SPECIFIC);
	SET_FRAMETYPE(typenlevel, ETHERTYPE_IP);
d756 5
a760 7
	addrlevel = (ifp->if_flags & IFF_POINTOPOINT) ?
	    ADDRLVL_SPECIFIC :
#ifdef MULTICAST
            (ifp->if_flags & IFF_MULTICAST ? ADDRLVL_MULTICAST : ADDRLVL_NORMAL);
#else
	    ADDRLVL_NORMAL;
#endif
d762 1
a762 2
	e = _swix(swinum, _INR(0,6), flags, ifp->if_unit, typenlevel, addrlevel,
	                             ERRLVL_NO_ERRORS, module_wsp, rxf_entry);
d776 17
a792 1
	flags = (claim) ? (FILTER_CLAIM | FILTER_NO_UNSAFE) : FILTER_RELEASE;
d805 1
d807 2
a808 10
            if ( (e=_swix(swinum, _INR(0,6), flags, ifp->if_unit, typenlevel,
#ifdef MULTICAST
	                                     ifp->if_flags & IFF_MULTICAST ?
	                                         ADDRLVL_MULTICAST : ADDRLVL_NORMAL,
#else
	                                     ADDRLVL_NORMAL,
#endif
	                                     ERRLVL_NO_ERRORS,
	                                     module_wsp, rxf_entry)) )
                break;
d816 2
d821 1
d823 1
a823 2
		_swix(swinum, _INR(0,2)|_INR(5,6), FILTER_RELEASE, ifp->if_unit,
		                                   typenlevel, module_wsp, rxf_entry);
d845 1
a845 1
	    m_freem(m);
d855 1
a856 3
    extern struct ifqueue revarpintrq;

    func_splhi();
d877 1
a877 2
    ifq_flush(&arpintrq);
    ifq_flush(&revarpintrq);
d885 1
a885 1
    (void)mb_close_session();
d906 1
a906 1
    func_splx();
d935 1
a935 2
        errcount=(errcount+1)&3;
	_inet_errblk[errcount].errnum = INETERR_MMBAD;
d937 1
a937 1
	builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
d942 2
a943 2
	msglen = tail - _inet_errblk[errcount].errmess;
	strncpy(tail, e->errmess, sizeof(_inet_errblk[errcount].errmess) - msglen);
d945 1
a945 1
	e = &_inet_errblk[errcount];
a959 6
     * Set clock
     */
    kerneltime.tv_sec = realtime();
    kerneltime.tv_usec = 0;

    /*
d990 1
a990 1
    func_splimp();
d1065 1
a1065 1
	    ifp->if_ioctl = if_module_null;
d1139 1
a1139 1
    func_splx();
d1193 1
a1193 1
_kernel_oserror *startup_handler(_kernel_swi_regs *r, void *pw)
d1202 5
a1206 1
    return NULL;
d1221 1
d1223 1
a1223 1
    int i, b;
d1225 1
d1230 3
a1232 2
        if( (e = _swix(OS_Byte, _INR(0,1)|_OUT(2),
                                CMOSRead, CMOSStartByte + i, &b)) != NULL )
d1235 1
a1235 1
	debugctrl |= (b << (i * 8));
d1284 1
d1286 2
a1287 1
     * Seed RNG
d1289 1
a1289 1
    srand(realtime());
a1301 5
     * initialise route protocol structures
     */
    route_proto_init();

    /*
d1320 1
a1321 6
    arp_init();

    /*
     * Initialise tables for Socket_InternalLookup
     */
    kvm_init();
a1364 2
extern struct ifqueue revarpintrq;

d1366 1
a1366 3
 * Process a list of received packets;
 * each packet is in the an mbuf chain m with
 * a prepended header in a separate mbuf
d1368 1
a1368 1
_kernel_oserror *rxf_handler(_kernel_swi_regs *r, void *pw)
d1370 4
a1373 5
	DibRef dib = (DibRef) r->r[0];
	struct mbuf *m = (struct mbuf *) r->r[1];
	struct ifnet *ifp;
	struct ifqueue *inq;
	int s;
d1376 2
a1377 2
    	if( DODEBUG(DBGINPUT) )
		Printf("\nRXF: (dib %x) ", dib);
d1380 5
d1386 2
a1387 2
	 * try to find the struct ifnet for the unit
	 * which is passing these frames in
d1389 2
a1390 7
	for (ifp = ifnet; ifp; ifp = ifp->if_next)
		/*
		 * Driver Information Blocks are static, so their addresses
		 * can be used to uniquely identify an interface
		 */
		if (ifp->if_dib == dib)
			break;
d1392 5
a1396 1
	if (!ifp) {
d1398 2
a1399 2
		if (DODEBUG(DBGINPUT))
			Printf("no ifp\n\n");
d1401 3
a1403 2
		return NULL;
	}
d1406 2
a1407 2
	if (DODEBUG(DBGINPUT))
		Printf("device %s%d\n", ifp->if_name, ifp->if_unit);
d1410 10
a1419 8
	if ((ifp->if_flags & IFF_UP | IFF_NEED_IPADDR) == 0) {
#ifdef DEBUG
		if (DODEBUG(DBGINPUT))
			Printf("iff is down!\n");
#endif
		m_freem(m);
		return NULL;
	}
d1421 2
a1422 6
	 * loop over all received frames, enqueuing them separately
	 *
	 * XXX TRACE XXX
	 *
	 * It would be nice if, at a later point, we could pass the
	 * entire block over in one fell swoop.
d1424 7
a1430 4
	while (m) {
		int len;
		struct mbuf *n;
		RxHdrRef rx = mtod(m, RxHdrRef);
d1432 4
a1435 2
		for (len=0, n=m->m_next; n; n=n->m_next)
			len += n->m_len;
d1437 1
a1437 2
#ifdef DEBUG
	    if( DODEBUG((1 << 17)) )
a1439 1
		struct mbuf *m1;
d1441 1
a1441 1
		Printf("\021\02rxf_handler Packet Dump: (type=%x)\n", rx->rx_frame_type);
d1443 1
a1443 1
		for (m1 = m->m_next; m1; m1 = m1->m_next)
d1448 1
a1448 1
		    for (j = 0; j < m1->m_len; ++j)
d1452 1
a1452 1
			if (!(++i % 32))
d1454 1
a1454 1
			else if(!(i % 4))
d1459 1
a1459 1
		if (i % 32)
a1460 1
	        Printf("\021\07\n");
d1462 12
a1474 36
		/*
		 * Stick the packet header on the first real mbuf
		 */
		n = m->m_next;
		if (!n) {
			n = m->m_nextpkt;
			m_freem(m);
			m = n;
			continue;
		}
		n->m_flags = M_PKTHDR;
		n->m_pkthdr.len = len;
		n->m_pkthdr.rcvif = ifp;
		ifp->if_lastchange = time;
		ifp->if_ibytes += len;
		ifp->if_ipackets += 1;
		if (bcmp(etherbroadcastaddr, rx->rx_dst_addr,
		    sizeof(etherbroadcastaddr)) == 0)
			n->m_flags |= M_BCAST;
		else if (rx->rx_dst_addr[0] & 1) {
			/*
			 * We must not receive our own multicasts (RFC1112) -
			 * loopback is the job of the IP layer
			 */
			if (!(ifp->if_flags & IFF_SIMPLEX) &&
			    bcmp(((struct arpcom *)ifp)->ac_enaddr,
			                    rx->rx_src_addr, 6) == 0) {
				n = m->m_nextpkt;
				m_freem(m);
				m = n;
				continue;
			}
			n->m_flags |= M_MCAST;
		}
		if (n->m_flags & (M_BCAST|M_MCAST))
			ifp->if_imcasts++;
d1476 4
a1479 1
		n = m->m_nextpkt;
d1481 12
a1492 12
#ifdef QuickMNSAcks
		/* Keep RxHdr on for IP, free it for others */
		if (rx->rx_frame_type != ETHERTYPE_IP)
#endif
			m = m_freen(m);

		switch (rx->rx_frame_type) {
#ifdef INET
		case ETHERTYPE_IP:
			schednetisr(NETISR_IP);
			inq = &ipintrq;
			break;
d1494 4
a1497 4
		case ETHERTYPE_ARP:
			schednetisr(NETISR_ARP);
			inq = &arpintrq;
			break;
d1499 3
a1501 4
		case ETHERTYPE_REVARP:
			schednetisr(NETISR_REVARP);
			inq = &revarpintrq;
			break;
d1503 2
a1504 24
#ifdef NS
		case ETHERTYPE_NS:
			schednetisr(NETISR_NS);
			inq = &nsintrq;
			break;

#endif
		default:
			m_freem(m);
			m = n;
			continue;
		}

		s = splimp();
		if (IF_QFULL(inq)) {
			IF_DROP(inq);
			m_freem(m);
		} else
			IF_ENQUEUE(inq, m);
		splx(s);
		m = n;
	}

	return NULL;
d1515 1
d1529 2
a1530 3
        errcount=(errcount+1)&3;
	_inet_errblk[errcount].errnum = INETERR_INVALIDSWI;
	builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
d1533 1
a1533 1
	return(&_inet_errblk[errcount]);
d1538 1
a1538 1
    static char *swinames[] =
d1543 1
a1543 1
	"oaccept",
d1545 4
a1548 4
	"orecv",
	"orecvfrom",
	"orecvmsg",
	"osend",
d1550 1
a1550 1
	"osendmsg",
d1554 2
a1555 2
	"ogetpeername",
	"ogetsockname",
d1565 1
a1565 9
	"sendtosm",
	"sysctl",
	"accept",
	"recvfrom",
	"recvmsg",
	"sendmsg",
	"getpeername",
	"getsockname",
	"kvm_nlist",
d1577 2
a1578 3
	    errcount=(errcount+1)&3;
	    _inet_errblk[errcount].errnum = INETERR_NOMM;
	    builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
d1586 1
a1586 1
	    return(&_inet_errblk[errcount]);
d1590 1
a1590 2
	    errcount=(errcount+1)&3;
	    _inet_errblk[errcount].errnum = INETERR_PANICED;
d1592 1
a1592 1
	    builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
d1599 1
a1599 1
		       _inet_errblk[errcount].errnum, _inet_errblk[errcount].errmess);
d1602 1
a1602 1
	    return (&_inet_errblk[errcount]);
d1606 1
d1609 4
a1612 1
    error = sock_ent[swinum](r, &rval);
a1633 3

    sendallsignals();

d1652 1
a1652 1
        errcount=(errcount+1) & 3;
d1654 1
a1654 3
	_inet_errblk[errcount].errnum = INETERR_BADCLI;

	builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
d1658 1
a1658 1
	return(&_inet_errblk[errcount]);
d1715 1
a1715 1
static _kernel_oserror *inet_error(int error)
d1730 1
a1730 1
	"DEADLK",
d1754 1
a1754 1
	"AGAIN",
d1780 1
a1780 1
	"CONNREFUSED",
d1791 7
a1797 5
	"BADRPC",
	"RPCMISMATCH",
	"PROGUNAVAIL",
	"PROGMISMATCH",
	"PROCUNAVAIL",
d1799 7
a1806 3
	"FTYPE",
	"AUTH",
	"NEEDAUTH"
a1808 4
    /* Use cyclic error blocks to reduce likelihood of an error message
       being returned from a Socket SWI, a callback going off as the
       SWI is exited, anda new error being generated overwriting the
       original one before the application gets a chance to copy it */
d1824 2
a1825 3
	errcount = (errcount+1) & 3;
	SETDCI4ERRNO(_inet_errblk[errcount].errnum, error);
	strncpy(_inet_errblk[errcount].errmess,
d1827 2
a1828 2
		sizeof(_inet_errblk[errcount].errmess));
	return(&_inet_errblk[errcount]);
d1836 7
d1844 25
d1878 1
a1878 1
	int sockstats(void);
d1897 1
a1897 2
	    errcount=(errcount+1)&3;
	    builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
d1900 1
a1900 1
	    printf("%s\n", _inet_errblk[errcount].errmess);
d1932 1
a1932 1
	    printf("%s:\n\n", lookup_tag("ResUse"));
d1947 141
a2087 2
	if (prot) {
            printf("Use *InetStat -s to examine per-protocol statistics.\n");
d2096 1
a2096 1
		printf("Name Mtu    Flags     (ifp)\n");
d2100 1
a2100 1
		    printf("%.2s%d  %-5ld  %08x  %08p\n",
d2120 1
a2120 1
	printf("Syntax: *InetInfo [r] [i]");
a2205 1
#if 0
d2222 1
a2222 1
	    printf(//"IP checksums are %s, "
d2224 4
a2227 4
		   "TCP checksums are %s.\n",
		   //(ipcksum) ? "on" : "off",
		   (udpcksum) ? "on" : "off",
		   (tcpcksum) ? "on" : "off");
d2234 1
a2234 1
	    u_char *iptr = NULL;
d2237 1
a2237 5
	     * 950608 KWelton
	     *
	     * I must have been asleep when I wrote this: argc
	     * *should* be 0 or 2 (not 0 or 1), if it is 1 then
	     * an invalid syntax message should be printed.
d2239 1
a2239 1
	    if( argc == 2 )
d2241 14
a2254 14
		/*
		 * check the first argument
		 */
		switch( **argv )
		{
		  /*case 'i':
		  case 'I':
		    iptr = &ipcksum;
		    break;*/

		  case 'u':
		  case 'U':
		    iptr = &udpcksum;
		    break;
d2256 3
a2258 5
		  case 't':
		  case 'T':
		    iptr = &tcpcksum;
		    break;
		}
a2322 1
#endif
d2344 2
a2345 3
                errcount = (errcount+1)&3;
		_inet_errblk[errcount].errnum = DCI4ERRORBLOCK + 0x82;
		sprintf(_inet_errblk[errcount].errmess,
d2347 1
a2347 1
		return(&_inet_errblk[errcount]);
a2366 2
extern char *getenv(const char *);

d2369 2
a2370 1
    char *val=getenv("Inet$IsGateway");
d2372 6
a2377 1
    return val != NULL && val[0] != '\0';
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d17 1
a17 1
 * $Header: /ax/networking:Internet/riscos/module.c:networking  1.16  $
a24 15
 * Revision 1.16  95/10/11  11:43:45  pwain
 * Set DCIMINIMUM back to 401 since the higher value causes
 * problems for ether3 drivers! (and etherb)
 * 
 * Revision 1.15  95/09/07  09:06:53  kwelton
 * I'm not quite sure how this module manages to still be compatible with
 * DCI 4.01, so DCIMINIMUM has been changed to 4.02, which it *can* cope
 * with.  This is really an academic exercise, since all known drivers are
 * DCI 4.03, but since I will be gone within a fortnight, I would like to
 * leave things as tidy as possible.
 * 
 * Revision 1.14  95/06/13  14:37:00  kwelton
 * Fixed a bug in do_checksum() - argc should be either 0 or *2*, have to
 * cope correctly with the (erroneous) case where argc = 1.
 * 
d2234 1
a2234 1
	    int *iptr = NULL;
d2237 1
a2237 5
	     * 950608 KWelton
	     *
	     * I must have been asleep when I wrote this: argc
	     * *should* be 0 or 2 (not 0 or 1), if it is 1 then
	     * an invalid syntax message should be printed.
d2239 1
a2239 1
	    if( argc == 2 )
d2241 9
a2249 9
		/*
		 * check the first argument
		 */
		switch( **argv )
		{
		  case 'i':
		  case 'I':
		    iptr = &ipcksum;
		    break;
d2251 4
a2254 4
		  case 'u':
		  case 'U':
		    iptr = &udpcksum;
		    break;
d2256 3
a2258 5
		  case 't':
		  case 'T':
		    iptr = &tcpcksum;
		    break;
		}
@


4.1.7.2
log
@RCS log keyword removed
@
text
@d24 1
a24 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@d17 1
a17 1
 * $Header: /ax/networking:Internet/riscos/module.c:networking  1.16  $
a24 15
 * Revision 1.16  95/10/11  11:43:45  pwain
 * Set DCIMINIMUM back to 401 since the higher value causes
 * problems for ether3 drivers! (and etherb)
 * 
 * Revision 1.15  95/09/07  09:06:53  kwelton
 * I'm not quite sure how this module manages to still be compatible with
 * DCI 4.01, so DCIMINIMUM has been changed to 4.02, which it *can* cope
 * with.  This is really an academic exercise, since all known drivers are
 * DCI 4.03, but since I will be gone within a fortnight, I would like to
 * leave things as tidy as possible.
 * 
 * Revision 1.14  95/06/13  14:37:00  kwelton
 * Fixed a bug in do_checksum() - argc should be either 0 or *2*, have to
 * cope correctly with the (erroneous) case where argc = 1.
 * 
d2234 1
a2234 1
	    int *iptr = NULL;
d2237 1
a2237 5
	     * 950608 KWelton
	     *
	     * I must have been asleep when I wrote this: argc
	     * *should* be 0 or 2 (not 0 or 1), if it is 1 then
	     * an invalid syntax message should be printed.
d2239 1
a2239 1
	    if( argc == 2 )
d2241 9
a2249 9
		/*
		 * check the first argument
		 */
		switch( **argv )
		{
		  case 'i':
		  case 'I':
		    iptr = &ipcksum;
		    break;
d2251 4
a2254 4
		  case 'u':
		  case 'U':
		    iptr = &udpcksum;
		    break;
d2256 3
a2258 5
		  case 't':
		  case 'T':
		    iptr = &tcpcksum;
		    break;
		}
@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d24 1
a24 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d17 1
a17 1
 * $Header: /ax/networking:Internet/riscos/module.c:networking  1.16  $
a24 20
 * Revision 1.17  96/03/06            kbracey
 * Changed lots of _kernel_swi to _swix
 * Added *InetChecksum a
 * Changed DCIMINIMUM back to 4.02 - ANT have fixed their drivers
 *
 * Revision 1.16  95/10/11  11:43:45  pwain
 * Set DCIMINIMUM back to 401 since the higher value causes
 * problems for ether3 drivers! (and etherb)
 *
 * Revision 1.15  95/09/07  09:06:53  kwelton
 * I'm not quite sure how this module manages to still be compatible with
 * DCI 4.01, so DCIMINIMUM has been changed to 4.02, which it *can* cope
 * with.  This is really an academic exercise, since all known drivers are
 * DCI 4.03, but since I will be gone within a fortnight, I would like to
 * leave things as tidy as possible.
 *
 * Revision 1.14  95/06/13  14:37:00  kwelton
 * Fixed a bug in do_checksum() - argc should be either 0 or *2*, have to
 * cope correctly with the (erroneous) case where argc = 1.
 *
d27 1
a27 1
 *
d30 1
a30 1
 *
d33 1
a33 1
 *
d36 1
a36 1
 *
d38 1
a38 1
 *
d41 1
a41 1
 *
d45 1
a45 1
 *
d50 1
a50 1
 *
d54 1
a54 1
 *
d60 1
a60 1
 *
d63 1
a63 1
 *
d65 1
a65 1
 *
d69 1
a69 1
 *
d71 1
a71 1
 *
d73 1
a73 1
 *
d77 1
a77 1
 *
d80 1
a80 1
 *
d83 1
a83 1
 *
d89 1
a89 1
 *
d96 1
a96 1
 *
d99 1
a99 1
 *
d104 1
a104 1
 *
d108 1
a108 1
 *
d111 1
a111 1
 *
d118 1
a118 1
 *
d121 1
a121 1
 *
d124 1
a124 1
 *
d127 1
a127 1
 *
d130 1
a130 1
 *
d133 1
a133 1
 *
a147 1
#include "sys/kernel.h"
a152 2
#include "net/if_types.h"
#include "net/if_dl.h"
a154 1
#include "netinet/in_systm.h"
d159 1
a162 1
#include "netinet/in_pcb.h"
d166 1
a168 1
#include "swiveneers.h"
a193 4
int sysctl();
int orecv(), orecvmsg(), osend(), osendmsg();
int ogetsockname(), ogetpeername(), oaccept(), orecvfrom();
int _kvm_nlist(), version();
d195 1
a195 1
char *berkeley_copyright = "Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994 The Regents of the University of California.  All rights reserved.";
d197 1
a197 1
static struct swient sock_ent[] =
d202 1
a202 1
    1, oaccept,
d204 4
a207 4
    1, orecv,
    1, orecvfrom,
    1, orecvmsg,
    1, osend,
d209 1
a209 1
    1, osendmsg,
d213 2
a214 2
    0, ogetpeername,
    0, ogetsockname,
a224 9
    1, sysctl,
    1, accept,
    1, recvfrom,
    1, recvmsg,
    1, sendmsg,
    0, getpeername,
    0, getsockname,
    1, _kvm_nlist,
    1, version,
d234 1
a234 1
//static _kernel_oserror *do_checksum(int argc, char **argv);
a235 1
extern void route_proto_init(void);
d241 1
a241 1
    //do_checksum,
d245 2
a246 3
void *module_wsp;
static _kernel_oserror _inet_errblk[4];
static int errcount;
d249 1
a249 1
static int finalising;
d251 3
a253 3
static const char *MsgFile = "Resources:$.Resources.Internet.Messages";
static u_long msgfd[4];
static int msgs_active;
d255 1
a255 1
//extern u_char ipcksum, udpcksum, tcpcksum;
d257 2
a258 2
int paniced;
char panicbuf[PANICBUFLEN];
d264 8
a271 6
static const char *TagModName = "ModName";
static const char *TagIntErr = "IntErr";
static const char *TagPaniced = "Paniced";
static const char *TagHInGate = "HInGate";
static const char *TagIsAct = "IsAct";
static const char *TagNotAct = "NotAct";
d273 2
a274 2
static const char *SynGateway = "Syntax: InetGateway [on|off]";
//static const char *SynChecksum = "Syntax: InetChecksum [u|t on|off]";
a279 2
extern void arp_init(void);

d283 1
d292 1
d299 2
a300 1
    if( (e = messagetrans_file_info(filename)) != NULL )
d317 4
a320 1
    return messagetrans_open_file(fd, filename, 0);
d330 2
d334 2
a335 1
    messagetrans_close_file(fd);
d345 3
a347 2
    static char msgbuf[128];
    char *result;
d352 13
a364 2
    if (messagetrans_lookup(msgfd, tag, msgbuf, sizeof msgbuf, &result) == NULL)
	return(result);
d416 2
a417 3
        errcount = (errcount+1)&3;
	_inet_errblk[errcount].errnum = INETERR_MLCFAIL;
	builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
d421 29
a449 1
	return (&_inet_errblk[errcount]);
d459 5
a463 1
    service_internetstatus_address_changed();
d481 1
d493 6
a498 1
    service_dci_protocol_status(module_wsp, status, DCIVERSION, titlestring);
a510 3
    struct ifaddr *ifa;
    struct sockaddr_dl *sdl;
    struct stats st;
d512 1
d514 1
a514 2
    int mtu, driver_version;
    func_splimp();
d526 3
a528 2
    if( (e = _swix(dib->dib_swibase + DCI4Version, _IN(0)|_OUT(1),
                0, &driver_version)) != NULL || driver_version < DCIMINIMUM )
d532 1
a532 1
	    Printf("dib_register: DCI version (%d) is too old\n", driver_version);
d539 1
a539 1
	func_splx();
d546 1
a546 1
    if( (ac = (struct arpcom *)malloc(sizeof(*ac), M_IFADDR, M_NOWAIT)) == NULL )
d552 1
a552 1
	func_splx();
d576 1
a576 1
    if( (ifp->if_name = malloc(strlen((char *)dib->dib_name) + 1, M_IFADDR, M_NOWAIT)) == NULL )
d582 1
a582 1
	func_splx();
d590 1
d593 1
d598 5
a602 3
    (void)_swix(dib->dib_swibase + DCI4GetNetworkMTU, _INR(0,1)|_OUT(2),
                      0, dib->dib_unit, &mtu);
    ifp->if_mtu = (short)mtu;
d607 2
a608 8
    (void)_swix(dib->dib_swibase + DCI4Inquire, _INR(0,1)|_OUT(2),
                      0, dib->dib_unit, &driver_flags);

    /*
     * ... and some statistics
     */
    (void)_swix(dib->dib_swibase + DCI4Stats, _INR(0,2),
                      1, dib->dib_unit, &st);
d616 1
a616 1
    if( driver_flags & INQ_HWADDRVALID ) {
d619 1
a619 4
	ifp->if_flags |= IFF_SRCSUPPLIED;
	ifp->if_addrlen = 6;
    }
    else {
a620 2
	ifp->if_addrlen = 0;
    }
d627 2
a628 33
    if (!(driver_flags & INQ_CANREFLECT))
	ifp->if_flags |= IFF_SIMPLEX;

    /*
     * INQ_MULTICAST means we can _receive_ multicast packets (ie you can
     * claim them via DCI-4). This obviously doesn't apply to point-to-point
     * interfaces, so assume that all point-to-point ifs can transmit and receive
     * multicast packets, and that non-point-to-point ifs can transmit and
     * receive them if INQ_MULTICAST is set
     */
    if (driver_flags & (INQ_MULTICAST|INQ_POINTOPOINT))
        ifp->if_flags |= IFF_MULTICAST;

    switch (st.st_interface_type) {
        case ST_TYPE_10BASE5:
        case ST_TYPE_10BASE2:
        case ST_TYPE_10BASET:
        case ST_TYPE_10BASE5N2:
        case ST_TYPE_10BASE2NT:
        case ST_TYPE_RSQUELCH10BASET:
        case ST_TYPE_10BASE5N2NT:
            ifp->if_type = IFT_ETHER;
            break;
        case ST_TYPE_SERIAL:
            ifp->if_type = IFT_MODEM;
            break;
        case ST_TYPE_PARALLEL:
            ifp->if_type = IFT_PARA;
            break;
        default:
            ifp->if_type = IFT_OTHER;
    }
    ifp->if_hdrlen = 14; /* This will do */
d638 1
a638 10
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
		if ((sdl = (struct sockaddr_dl *)ifa->ifa_addr) &&
		    sdl->sdl_family == AF_LINK) {
			sdl->sdl_type = ifp->if_type;
			sdl->sdl_alen = ifp->if_addrlen;
			bcopy((caddr_t)((struct arpcom *)ifp)->ac_enaddr,
			      LLADDR(sdl), ifp->if_addrlen);
			break;
		}
    func_splx();
d651 1
d662 2
a663 3
        errcount=(errcount+1)&3;
	_inet_errblk[errcount].errnum = INETERR_IFBAD;
	builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
d666 1
a666 1
	return (&_inet_errblk[errcount]);
d673 2
a674 1
    loopattach();
d680 3
a682 1
    if( (e = service_enumerate_network_drivers(&chd)) != NULL)
d688 1
a688 1
    for( ; chd != NULL; chd = chdnext )
d709 3
a711 1
        osmodule_free(chd);
d729 1
d731 1
a731 1
    u_int swinum = ifp->if_swibase + DCI4Filter;
d733 1
a733 1
    unsigned int flags, typenlevel, addrlevel;
a735 2
    (void)&typenlevel;  /* Shut up compiler -fa */

d742 1
a742 1
    if (ifp->if_flags & IFF_NOARP)
d744 7
a750 3
	flags = (claim) ? (FILTER_CLAIM | FILTER_NO_UNSAFE) : FILTER_RELEASE;
	SET_FRAMELEVEL(typenlevel, FRMLVL_E2SPECIFIC);
	SET_FRAMETYPE(typenlevel, ETHERTYPE_IP);
d756 5
a760 7
	addrlevel = (ifp->if_flags & IFF_POINTOPOINT) ?
	    ADDRLVL_SPECIFIC :
#ifdef MULTICAST
            (ifp->if_flags & IFF_MULTICAST ? ADDRLVL_MULTICAST : ADDRLVL_NORMAL);
#else
	    ADDRLVL_NORMAL;
#endif
d762 1
a762 2
	e = _swix(swinum, _INR(0,6), flags, ifp->if_unit, typenlevel, addrlevel,
	                             ERRLVL_NO_ERRORS, module_wsp, rxf_entry);
d776 17
a792 1
	flags = (claim) ? (FILTER_CLAIM | FILTER_NO_UNSAFE) : FILTER_RELEASE;
d805 1
d807 2
a808 10
            if ( (e=_swix(swinum, _INR(0,6), flags, ifp->if_unit, typenlevel,
#ifdef MULTICAST
	                                     ifp->if_flags & IFF_MULTICAST ?
	                                         ADDRLVL_MULTICAST : ADDRLVL_NORMAL,
#else
	                                     ADDRLVL_NORMAL,
#endif
	                                     ERRLVL_NO_ERRORS,
	                                     module_wsp, rxf_entry)) )
                break;
d816 2
d821 1
d823 1
a823 2
		_swix(swinum, _INR(0,2)|_INR(5,6), FILTER_RELEASE, ifp->if_unit,
		                                   typenlevel, module_wsp, rxf_entry);
d845 1
a845 1
	    m_freem(m);
d855 1
a856 3
    extern struct ifqueue revarpintrq;

    func_splhi();
d877 1
a877 2
    ifq_flush(&arpintrq);
    ifq_flush(&revarpintrq);
d885 1
a885 1
    (void)mb_close_session();
d906 1
a906 1
    func_splx();
d935 1
a935 2
        errcount=(errcount+1)&3;
	_inet_errblk[errcount].errnum = INETERR_MMBAD;
d937 1
a937 1
	builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
d942 2
a943 2
	msglen = tail - _inet_errblk[errcount].errmess;
	strncpy(tail, e->errmess, sizeof(_inet_errblk[errcount].errmess) - msglen);
d945 1
a945 1
	e = &_inet_errblk[errcount];
a959 6
     * Set clock
     */
    kerneltime.tv_sec = realtime();
    kerneltime.tv_usec = 0;

    /*
d990 1
a990 1
    func_splimp();
d1139 1
a1139 1
    func_splx();
d1221 1
d1223 1
a1223 1
    int i, b;
d1225 1
d1230 3
a1232 2
        if( (e = _swix(OS_Byte, _INR(0,1)|_OUT(2),
                                CMOSRead, CMOSStartByte + i, &b)) != NULL )
d1235 1
a1235 1
	debugctrl |= (b << (i * 8));
d1284 1
d1286 2
a1287 1
     * Seed RNG
d1289 1
a1289 1
    srand(realtime());
a1301 5
     * initialise route protocol structures
     */
    route_proto_init();

    /*
d1320 1
a1321 6
    arp_init();

    /*
     * Initialise tables for Socket_InternalLookup
     */
    kvm_init();
a1364 2
extern struct ifqueue revarpintrq;

d1366 1
a1366 3
 * Process a list of received packets;
 * each packet is in the an mbuf chain m with
 * a prepended header in a separate mbuf
d1368 1
a1368 3
int
rxf_handler(r)
	_kernel_swi_regs *r;
d1370 4
a1373 5
	DibRef dib = (DibRef) r->r[0];
	struct mbuf *m = (struct mbuf *) r->r[1];
	struct ifnet *ifp;
	struct ifqueue *inq;
	int s;
d1376 2
a1377 2
    	if( DODEBUG(DBGINPUT) )
		Printf("\nRXF: (dib %x) ", dib);
d1380 5
d1386 2
a1387 2
	 * try to find the struct ifnet for the unit
	 * which is passing these frames in
d1389 2
a1390 7
	for (ifp = ifnet; ifp; ifp = ifp->if_next)
		/*
		 * Driver Information Blocks are static, so their addresses
		 * can be used to uniquely identify an interface
		 */
		if (ifp->if_dib == dib)
			break;
d1392 5
a1396 1
	if (!ifp) {
d1398 2
a1399 2
		if (DODEBUG(DBGINPUT))
			Printf("no ifp\n\n");
d1401 3
a1403 2
		return (1);
	}
d1406 2
a1407 2
	if (DODEBUG(DBGINPUT))
		Printf("device %s%d\n", ifp->if_name, ifp->if_unit);
d1410 10
a1419 8
	if ((ifp->if_flags & IFF_UP | IFF_NEED_IPADDR) == 0) {
#ifdef DEBUG
		if (DODEBUG(DBGINPUT))
			Printf("iff is down!\n");
#endif
		m_freem(m);
		return (1);
	}
d1421 2
a1422 6
	 * loop over all received frames, enqueuing them separately
	 *
	 * XXX TRACE XXX
	 *
	 * It would be nice if, at a later point, we could pass the
	 * entire block over in one fell swoop.
d1424 7
a1430 4
	while (m) {
		int len;
		struct mbuf *n;
		RxHdrRef rx = mtod(m, RxHdrRef);
d1432 4
a1435 2
		for (len=0, n=m->m_next; n; n=n->m_next)
			len += n->m_len;
d1437 1
a1437 2
#ifdef DEBUG
	    if( DODEBUG((1 << 17)) )
a1439 1
		struct mbuf *m1;
d1441 1
a1441 1
		Printf("\021\02rxf_handler Packet Dump: (type=%x)\n", rx->rx_frame_type);
d1443 1
a1443 1
		for (m1 = m->m_next; m1; m1 = m1->m_next)
d1448 1
a1448 1
		    for (j = 0; j < m1->m_len; ++j)
d1452 1
a1452 1
			if (!(++i % 32))
d1454 1
a1454 1
			else if(!(i % 4))
d1459 1
a1459 1
		if (i % 32)
a1460 1
	        Printf("\021\07\n");
d1462 12
a1474 36
		/*
		 * Stick the packet header on the first real mbuf
		 */
		n = m->m_next;
		if (!n) {
			n = m->m_nextpkt;
			m_freem(m);
			m = n;
			continue;
		}
		n->m_flags = M_PKTHDR;
		n->m_pkthdr.len = len;
		n->m_pkthdr.rcvif = ifp;
		ifp->if_lastchange = time;
		ifp->if_ibytes += len;
		ifp->if_ipackets += 1;
		if (bcmp(etherbroadcastaddr, rx->rx_dst_addr,
		    sizeof(etherbroadcastaddr)) == 0)
			n->m_flags |= M_BCAST;
		else if (rx->rx_dst_addr[0] & 1) {
			/*
			 * We must not receive our own multicasts (RFC1112) -
			 * loopback is the job of the IP layer
			 */
			if (!(ifp->if_flags & IFF_SIMPLEX) &&
			    bcmp(((struct arpcom *)ifp)->ac_enaddr,
			                    rx->rx_src_addr, 6) == 0) {
				n = m->m_nextpkt;
				m_freem(m);
				m = n;
				continue;
			}
			n->m_flags |= M_MCAST;
		}
		if (n->m_flags & (M_BCAST|M_MCAST))
			ifp->if_imcasts++;
d1476 4
a1479 1
		n = m->m_nextpkt;
d1481 12
a1492 12
#ifdef QuickMNSAcks
		/* Keep RxHdr on for IP, free it for others */
		if (rx->rx_frame_type != ETHERTYPE_IP)
#endif
			m = m_freen(m);

		switch (rx->rx_frame_type) {
#ifdef INET
		case ETHERTYPE_IP:
			schednetisr(NETISR_IP);
			inq = &ipintrq;
			break;
d1494 4
a1497 4
		case ETHERTYPE_ARP:
			schednetisr(NETISR_ARP);
			inq = &arpintrq;
			break;
d1499 3
a1501 4
		case ETHERTYPE_REVARP:
			schednetisr(NETISR_REVARP);
			inq = &revarpintrq;
			break;
d1503 2
a1504 24
#ifdef NS
		case ETHERTYPE_NS:
			schednetisr(NETISR_NS);
			inq = &nsintrq;
			break;

#endif
		default:
			m_freem(m);
			m = n;
			continue;
		}

		s = splimp();
		if (IF_QFULL(inq)) {
			IF_DROP(inq);
			m_freem(m);
		} else
			IF_ENQUEUE(inq, m);
		splx(s);
		m = n;
	}

	return (1);
d1529 2
a1530 3
        errcount=(errcount+1)&3;
	_inet_errblk[errcount].errnum = INETERR_INVALIDSWI;
	builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
d1533 1
a1533 1
	return(&_inet_errblk[errcount]);
d1538 1
a1538 1
    static char *swinames[] =
d1543 1
a1543 1
	"oaccept",
d1545 4
a1548 4
	"orecv",
	"orecvfrom",
	"orecvmsg",
	"osend",
d1550 1
a1550 1
	"osendmsg",
d1554 2
a1555 2
	"ogetpeername",
	"ogetsockname",
d1565 1
a1565 9
	"sendtosm",
	"sysctl",
	"accept",
	"recvfrom",
	"recvmsg",
	"sendmsg",
	"getpeername",
	"getsockname",
	"kvm_nlist",
d1577 2
a1578 3
	    errcount=(errcount+1)&3;
	    _inet_errblk[errcount].errnum = INETERR_NOMM;
	    builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
d1586 1
a1586 1
	    return(&_inet_errblk[errcount]);
d1590 1
a1590 2
	    errcount=(errcount+1)&3;
	    _inet_errblk[errcount].errnum = INETERR_PANICED;
d1592 1
a1592 1
	    builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
d1599 1
a1599 1
		       _inet_errblk[errcount].errnum, _inet_errblk[errcount].errmess);
d1602 1
a1602 1
	    return (&_inet_errblk[errcount]);
a1633 3

    sendallsignals();

d1652 1
a1652 3
        errcount=(errcount+1) & 3;

	_inet_errblk[errcount].errnum = INETERR_BADCLI;
d1654 1
a1654 1
	builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
d1658 1
a1658 1
	return(&_inet_errblk[errcount]);
d1730 1
a1730 1
	"DEADLK",
d1754 1
a1754 1
	"AGAIN",
d1780 1
a1780 1
	"CONNREFUSED",
d1791 7
a1797 5
	"BADRPC",
	"RPCMISMATCH",
	"PROGUNAVAIL",
	"PROGMISMATCH",
	"PROCUNAVAIL",
d1799 7
a1806 3
	"FTYPE",
	"AUTH",
	"NEEDAUTH"
a1808 4
    /* Use cyclic error blocks to reduce likelihood of an error message
       being returned from a Socket SWI, a callback going off as the
       SWI is exited, anda new error being generated overwriting the
       original one before the application gets a chance to copy it */
d1824 2
a1825 3
	errcount = (errcount+1) & 3;
	SETDCI4ERRNO(_inet_errblk[errcount].errnum, error);
	strncpy(_inet_errblk[errcount].errmess,
d1827 2
a1828 2
		sizeof(_inet_errblk[errcount].errmess));
	return(&_inet_errblk[errcount]);
d1836 7
d1844 25
d1897 1
a1897 2
	    errcount=(errcount+1)&3;
	    builderrmess(_inet_errblk[errcount].errmess, NULL, TagModName, &tail);
d1900 1
a1900 1
	    printf("%s\n", _inet_errblk[errcount].errmess);
d1947 141
a2087 2
	if (prot) {
            printf("Use *InetStat -s to examine per-protocol statistics.\n");
d2096 1
a2096 1
		printf("Name Mtu    Flags     (ifp)\n");
d2100 1
a2100 1
		    printf("%.2s%d  %-5ld  %08x  %08p\n",
d2120 1
a2120 1
	printf("Syntax: *InetInfo [r] [i]");
a2205 1
#if 0
d2222 1
a2222 1
	    printf(//"IP checksums are %s, "
d2224 4
a2227 4
		   "TCP checksums are %s.\n",
		   //(ipcksum) ? "on" : "off",
		   (udpcksum) ? "on" : "off",
		   (tcpcksum) ? "on" : "off");
d2234 1
a2234 1
	    u_char *iptr = NULL;
d2237 1
a2237 5
	     * 950608 KWelton
	     *
	     * I must have been asleep when I wrote this: argc
	     * *should* be 0 or 2 (not 0 or 1), if it is 1 then
	     * an invalid syntax message should be printed.
d2239 1
a2239 1
	    if( argc == 2 )
d2241 14
a2254 14
		/*
		 * check the first argument
		 */
		switch( **argv )
		{
		  /*case 'i':
		  case 'I':
		    iptr = &ipcksum;
		    break;*/

		  case 'u':
		  case 'U':
		    iptr = &udpcksum;
		    break;
d2256 3
a2258 5
		  case 't':
		  case 'T':
		    iptr = &tcpcksum;
		    break;
		}
a2322 1
#endif
d2344 2
a2345 3
                errcount = (errcount+1)&3;
		_inet_errblk[errcount].errnum = DCI4ERRORBLOCK + 0x82;
		sprintf(_inet_errblk[errcount].errmess,
d2347 1
a2347 1
		return(&_inet_errblk[errcount]);
a2366 2
extern char *getenv(const char *);

d2369 2
a2370 1
    char *val=getenv("Inet$IsGateway");
d2372 6
a2377 1
    return val != NULL && val[0] != '\0';
@


4.1.3.2
log
@RCS Log keyword removed
@
text
@d24 1
a24 1
 * :RCS Log discontinued:
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d24 1
a24 1
 * :RCS Log discontinued:
@

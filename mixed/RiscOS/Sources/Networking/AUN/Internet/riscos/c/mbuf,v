head	4.4;
access;
symbols
	Internet-5_65:4.4
	Internet-5_64:4.4
	Internet-5_63:4.4
	Internet-5_62:4.4
	Internet-5_61:4.4
	Internet-5_60:4.4
	Internet-5_59:4.4
	Internet-5_58:4.4
	Internet-5_57:4.4
	Internet-5_56:4.4
	Internet-5_55:4.3
	Internet-5_54:4.3
	Internet-5_53:4.3
	Internet-5_52:4.3
	Internet-5_51:4.3
	Internet-5_50:4.3
	RO_5_07:4.3
	Internet-5_49:4.3
	Internet-5_48:4.3
	Internet-5_47:4.3
	Internet-5_46:4.3
	Internet-5_45:4.3
	Internet-5_44:4.3
	Internet-5_43:4.3
	Internet-5_42:4.3
	Internet-5_41:4.3
	Internet-5_40:4.3
	Internet-5_39:4.3
	Internet-5_38:4.3
	Internet-5_37:4.3
	Internet-5_36:4.3
	Internet-5_35:4.3
	Internet-5_34:4.3
	Internet-5_33:4.3
	Internet-5_32:4.3
	Internet-5_31:4.3
	Internet-5_30:4.3
	Internet-5_29:4.3
	Internet-5_27:4.2
	Internet-5_26:4.2
	Internet-5_25:4.2
	Internet-5_24:4.2
	Internet-5_23:4.2
	Internet-5_22:4.2
	Internet-5_21:4.2
	Internet-5_20:4.2
	Internet-5_19:4.2
	Internet-5_18:4.2
	Internet-5_17:4.2
	Internet-5_16:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Internet-5_15:4.2
	Internet-5_14:4.2
	Internet-5_13:4.2
	sforrest_daytona_appflash-0_31:4.2
	Internet-5_12:4.2
	Internet-5_11:4.2
	celkins_Internet-5_10:4.2
	nicke_Internat_25-9-98:4.2
	Internet-5_09:4.2
	blaughto_daytona_appflash-0_30:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rwarren_Internet-5_08:4.2
	Spinner:4.2
	Internet_5_07:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.2
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.2
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2012.05.18.19.47.38;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	BtYbu9tZVKZi3f5w;

4.3
date	99.07.08.15.25.44;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.59.05;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.10;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.10;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.20.25;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.30.39;	author nturton;	state Exp;
branches;
next	4.1.3.2;

4.1.3.2
date	96.11.08.17.23.21;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.07.04;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.36;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.07.03;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.49;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.38.49;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.29;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.4
log
@Update to work with TCPIPLibs-5_55.
Also fix a warning from the compiler about m_copyback.

Version 5.56. Tagged as 'Internet-5_56'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
 */
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "sys/param.h"
#include "sys/errno.h"
#include "sys/mbuf.h"
#include "sys/socket.h"

#include "net/if.h"
#include "net/if_arp.h"

#include "netinet/in.h"
#include "netinet/if_ether.h"

#include "swiveneers.h"
#include "module.h"

#ifdef DBGMBUF
static void df(char *s)
{
    _swix(OS_WriteI+4, 0);

    printf(s);
}
#endif


struct mbctl MBCTL =
{
	0,				/* opaque */
	sizeof(struct mbctl),		/* mbcsize */
	MBUF_MANAGER_VERSION,		/* mbcvers */
	0ul,				/* flags */
	MINCONTIG,			/* advminubs */
	ETHERMTU,			/* advmaxubs */
	MINCONTIG,			/* mincontig */
	0ul,				/* spare1 */
	/*
	 * Rest of the structure gets initialised
	 * to zeroes due to the trailing comma
	 */
};

/**********************************************************************/

_kernel_oserror *mb_entryinit(void)
{
    return mbuf_open_session(&MBCTL);
}

/**********************************************************************/

/*
 * mb_present - check whether the mbuf manager is present or not,
 * using the Mbuf_Control SWI to do so.	 returns 1 if manager
 * present, else 0.
 */
int mb_present(void)
{
    /*
     * the control version SWI should *always*
     * succeed if the mbuf manager is loaded.
     */
    return mbufcontrol_version(0) == NULL;
}

/**********************************************************************/

_kernel_oserror *mb_close_session(void)
{
    return mbuf_close_session(&MBCTL);
}

/**********************************************************************/

/*
 * Copy data from a buffer back into the indicated mbuf chain,
 * starting "off" bytes from the beginning, extending the mbuf
 * chain if necessary.
 */
void m_copyback(struct mbuf *m0, register int off, register int len, caddr_t cp)
{
	register int mlen;
	register struct mbuf *m = m0, *n;
	int totlen = 0;

	if (m0 == 0)
		return;
	while (off > (mlen = m->m_len)) {
		off -= mlen;
		totlen += mlen;
		if (m->m_next == 0) {
			n = ALLOC_C(MINCONTIG, NULL);
			if (n == 0)
				goto out;
			n->m_type = m->m_type;
			n->m_len = min(MINCONTIG, len + off);
			m->m_next = n;
		}
		m = m->m_next;
	}
	while (len > 0) {
		mlen = min (m->m_len - off, len);
		memcpy(off + mtod(m, caddr_t), cp, (unsigned)mlen);
		cp += mlen;
		len -= mlen;
		mlen += off;
		off = 0;
		totlen += mlen;
		if (len == 0)
			break;
		if (m->m_next == 0) {
			n = ALLOC_S(MINCONTIG, NULL);
			if (n == 0)
				break;
			n->m_type = m->m_type;
			n->m_len = min(MINCONTIG, len);
			m->m_next = n;
		}
		m = m->m_next;
	}
out:
	if (((m = m0)->m_flags & M_PKTHDR) && (m->m_pkthdr.len < totlen))
		m->m_pkthdr.len = totlen;
}

/* EOF mbuf.c */
@


4.3
log
@* Dynamic ports now assigned in range 49152-65535.
* IP_RECVDSTADDR works for non-unicast packets.
* SO_TIMESTAMP added.
* IP_RECVIF added.
* Various other internal changes merged in from FreeBSD sources.

Version 5.29. Tagged as 'Internet-5_29'
@
text
@d87 1
a87 1
extern _kernel_oserror *mb_close_session(void)
d99 1
a99 6
void
m_copyback(m0, off, len, cp)
	struct	mbuf *m0;
	register int off;
	register int len;
	caddr_t cp;
@


4.2
log
@Version Spinner_B7 taken
@
text
@d25 1
@


4.1
log
@Initial revision
@
text
@d15 1
a15 5
/* -*-C-*-
 *
 * $Header: /ax/networking:Internet/riscos/mbuf.c:networking  1.1  $
 * $Source: /ax/networking:Internet/riscos/mbuf.c: $
 *
a16 5
 *
 * $Log:	mbuf.c,v $
 * Revision 1.1  94/12/02  11:39:04  kwelton
 * Initial revision
 * 
d18 1
d26 4
d32 3
d38 1
a38 2
    _kernel_swi_regs r;
    _kernel_swi(OS_WriteI+4, &r, &r);
d65 1
a65 4
    _kernel_swi_regs r;
    r.r[0] = (int) &MBCTL;

    return _kernel_swi( XOS_Bit | Mbuf_OpenSession, &r, &r);
a76 2
    _kernel_swi_regs r;

d78 1
a78 1
     * the control SWI with reason code 0 should *always*
d81 1
a81 2
    r.r[0] = 0;
    return((_kernel_swi(XOS_Bit | Mbuf_Control, &r, &r) == NULL) ? 1 : 0);
d86 1
a86 1
extern _kernel_oserror *mb_closesession(void)
d88 1
a88 4
    _kernel_swi_regs r;
    r.r[0] = (int) &MBCTL;

    return _kernel_swi( XOS_Bit | Mbuf_CloseSession, &r, &r);
d92 56
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d15 5
a19 1
/*
d21 5
a26 1
#include <string.h>
a33 4
#include "net/if.h"
#include "net/if_arp.h"

#include "netinet/in.h"
a35 3
#include "swiveneers.h"
#include "module.h"

d39 2
a40 1
    _swix(OS_WriteI+4, 0);
d67 4
a70 1
    return mbuf_open_session(&MBCTL);
d82 2
d85 1
a85 1
     * the control version SWI should *always*
d88 2
a89 1
    return mbufcontrol_version(0) == NULL;
d94 1
a94 1
extern _kernel_oserror *mb_close_session(void)
d96 4
a99 1
    return mbuf_close_session(&MBCTL);
a102 56

/*
 * Copy data from a buffer back into the indicated mbuf chain,
 * starting "off" bytes from the beginning, extending the mbuf
 * chain if necessary.
 */
void
m_copyback(m0, off, len, cp)
	struct	mbuf *m0;
	register int off;
	register int len;
	caddr_t cp;
{
	register int mlen;
	register struct mbuf *m = m0, *n;
	int totlen = 0;

	if (m0 == 0)
		return;
	while (off > (mlen = m->m_len)) {
		off -= mlen;
		totlen += mlen;
		if (m->m_next == 0) {
			n = ALLOC_C(MINCONTIG, NULL);
			if (n == 0)
				goto out;
			n->m_type = m->m_type;
			n->m_len = min(MINCONTIG, len + off);
			m->m_next = n;
		}
		m = m->m_next;
	}
	while (len > 0) {
		mlen = min (m->m_len - off, len);
		memcpy(off + mtod(m, caddr_t), cp, (unsigned)mlen);
		cp += mlen;
		len -= mlen;
		mlen += off;
		off = 0;
		totlen += mlen;
		if (len == 0)
			break;
		if (m->m_next == 0) {
			n = ALLOC_S(MINCONTIG, NULL);
			if (n == 0)
				break;
			n->m_type = m->m_type;
			n->m_len = min(MINCONTIG, len);
			m->m_next = n;
		}
		m = m->m_next;
	}
out:
	if (((m = m0)->m_flags & M_PKTHDR) && (m->m_pkthdr.len < totlen))
		m->m_pkthdr.len = totlen;
}
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@RCS log keyword removed
@
text
@d22 1
a22 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d22 1
a22 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a22 3
 * Revision 1.2  96/03/06            kbracey
 * Turn all _kernel_swi into veneer calls
 *
d25 1
a25 1
 *
a33 4
#include "net/if.h"
#include "net/if_arp.h"

#include "netinet/in.h"
a35 3
#include "swiveneers.h"
#include "module.h"

d39 2
a40 1
    _swix(OS_WriteI+4, 0);
d67 4
a70 1
    return mbuf_open_session(&MBCTL);
d82 2
d85 1
a85 1
     * the control version SWI should *always*
d88 2
a89 1
    return mbufcontrol_version(0) == NULL;
d94 1
a94 1
extern _kernel_oserror *mb_close_session(void)
d96 4
a99 1
    return mbuf_close_session(&MBCTL);
a102 56

/*
 * Copy data from a buffer back into the indicated mbuf chain,
 * starting "off" bytes from the beginning, extending the mbuf
 * chain if necessary.
 */
void
m_copyback(m0, off, len, cp)
	struct	mbuf *m0;
	register int off;
	register int len;
	caddr_t cp;
{
	register int mlen;
	register struct mbuf *m = m0, *n;
	int totlen = 0;

	if (m0 == 0)
		return;
	while (off > (mlen = m->m_len)) {
		off -= mlen;
		totlen += mlen;
		if (m->m_next == 0) {
			n = ALLOC_C(MINCONTIG, NULL);
			if (n == 0)
				goto out;
			n->m_type = m->m_type;
			n->m_len = min(MINCONTIG, len + off);
			m->m_next = n;
		}
		m = m->m_next;
	}
	while (len > 0) {
		mlen = min (m->m_len - off, len);
		memcpy(off + mtod(m, caddr_t), cp, (unsigned)mlen);
		cp += mlen;
		len -= mlen;
		mlen += off;
		off = 0;
		totlen += mlen;
		if (len == 0)
			break;
		if (m->m_next == 0) {
			n = ALLOC_S(MINCONTIG, NULL);
			if (n == 0)
				break;
			n->m_type = m->m_type;
			n->m_len = min(MINCONTIG, len);
			m->m_next = n;
		}
		m = m->m_next;
	}
out:
	if (((m = m0)->m_flags & M_PKTHDR) && (m->m_pkthdr.len < totlen))
		m->m_pkthdr.len = totlen;
}
@


4.1.3.2
log
@RCS Log keyword removed
@
text
@d22 1
a22 1
 * :RCS Log discontinued:
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d22 1
a22 1
 * :RCS Log discontinued:
@

head	4.28;
access;
symbols
	Internet-5_65:4.28
	Internet-5_64:4.28
	Internet-5_63:4.28
	Internet-5_62:4.28
	Internet-5_61:4.27
	Internet-5_60:4.27
	Internet-5_59:4.27
	Internet-5_58:4.26
	Internet-5_57:4.26
	Internet-5_56:4.26
	Internet-5_55:4.26
	Internet-5_54:4.26
	Internet-5_53:4.26
	Internet-5_52:4.25
	Internet-5_51:4.25
	Internet-5_50:4.25
	RO_5_07:4.25
	Internet-5_49:4.25
	Internet-5_48:4.24
	Internet-5_47:4.23
	Internet-5_46:4.22
	Internet-5_45:4.21
	Internet-5_44:4.21
	Internet-5_43:4.21
	Internet-5_42:4.21
	Internet-5_41:4.21
	Internet-5_40:4.21
	Internet-5_39:4.21
	Internet-5_38:4.21
	Internet-5_37:4.21
	Internet-5_36:4.21
	Internet-5_35:4.20
	Internet-5_34:4.20
	Internet-5_33:4.20
	Internet-5_32:4.20
	Internet-5_31:4.20
	Internet-5_30:4.19
	Internet-5_29:4.18
	Internet-5_27:4.17
	Internet-5_26:4.16
	Internet-5_25:4.15
	Internet-5_24:4.14
	Internet-5_23:4.14
	Internet-5_22:4.14
	Internet-5_21:4.14
	Internet-5_20:4.13
	Internet-5_19:4.12
	Internet-5_18:4.11
	Internet-5_17:4.11
	Internet-5_16:4.11
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Internet-5_15:4.11
	Internet-5_14:4.10
	Internet-5_13:4.9
	sforrest_daytona_appflash-0_31:4.3
	Internet-5_12:4.8
	Internet-5_11:4.5
	celkins_Internet-5_10:4.5
	nicke_Internat_25-9-98:4.3
	Internet-5_09:4.4
	blaughto_daytona_appflash-0_30:4.3
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rwarren_Internet-5_08:4.3
	Spinner:4.3
	Internet_5_07:4.3
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.2
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.2
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.28
date	2017.06.07.20.36.48;	author rsprowson;	state Exp;
branches;
next	4.27;
commitid	xgif914dBX0dZtUz;

4.27
date	2013.11.20.21.59.08;	author rsprowson;	state Exp;
branches;
next	4.26;
commitid	XW8tvC0YFL9k44ex;

4.26
date	2011.12.15.22.20.14;	author rsprowson;	state Exp;
branches;
next	4.25;
commitid	TVCPLXal0LzsSkLv;

4.25
date	2004.08.05.11.29.08;	author kbracey;	state Exp;
branches;
next	4.24;

4.24
date	2004.07.22.17.25.03;	author kbracey;	state Exp;
branches;
next	4.23;

4.23
date	2004.07.02.15.12.46;	author bavison;	state Exp;
branches;
next	4.22;

4.22
date	2003.11.13.18.02.15;	author bavison;	state Exp;
branches;
next	4.21;

4.21
date	99.08.27.17.02.42;	author kbracey;	state Exp;
branches;
next	4.20;

4.20
date	99.07.13.11.13.12;	author kbracey;	state Exp;
branches;
next	4.19;

4.19
date	99.07.08.16.36.56;	author kbracey;	state Exp;
branches;
next	4.18;

4.18
date	99.07.08.15.25.53;	author kbracey;	state Exp;
branches;
next	4.17;

4.17
date	99.06.30.13.15.46;	author kbracey;	state Exp;
branches;
next	4.16;

4.16
date	99.06.23.16.09.41;	author sbrodie;	state Exp;
branches;
next	4.15;

4.15
date	99.06.23.13.10.29;	author sbrodie;	state Exp;
branches;
next	4.14;

4.14
date	99.03.30.12.10.32;	author sbrodie;	state Exp;
branches;
next	4.13;

4.13
date	99.03.25.14.45.35;	author sbrodie;	state Exp;
branches;
next	4.12;

4.12
date	99.02.12.14.57.16;	author sbrodie;	state Exp;
branches;
next	4.11;

4.11
date	98.11.13.13.03.43;	author celkins;	state Exp;
branches;
next	4.10;

4.10
date	98.11.04.21.05.51;	author celkins;	state Exp;
branches;
next	4.9;

4.9
date	98.10.30.18.22.54;	author celkins;	state Exp;
branches;
next	4.8;

4.8
date	98.10.22.14.26.19;	author sbrodie;	state Exp;
branches;
next	4.7;

4.7
date	98.10.20.20.46.12;	author celkins;	state Exp;
branches;
next	4.6;

4.6
date	98.10.15.14.18.37;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	98.09.29.14.00.47;	author celkins;	state Exp;
branches;
next	4.4;

4.4
date	98.08.21.17.15.46;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	98.07.21.12.50.49;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.59.17;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.13;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.13;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.20.42;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.30.52;	author nturton;	state Exp;
branches;
next	4.1.3.2;

4.1.3.2
date	96.11.08.17.23.31;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.07.18;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.48;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.07.19;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.00.00;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.39.06;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.38;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.28
log
@Get Internet event numbers from Hdr:RISCOS and a microoptimisation
unixenv.c/whoami.c: don't define event numbers locally, use headers.
tick_entry.s: if available use the REV instruction for htonl().

Requires Kernel-5_81 for event numbers.

Version 5.62. Tagged as 'Internet-5_62'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Functions to implement bootp and revarp
 *
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
 *
 * :RCS Log discontinued:
 * Revision 1.5  95/11/14  12:08:41  pwain
 * Check in for jdavies@@csd
 *
 * Added use of AUN_state flag to control AUN REVARP behaviour.
 *
 * Revision 1.4  95/07/06  08:50:39  kwelton
 * Fixed the case for REVARP_REPLY in revarpinput() - only bother setting
 * the interface address if actively looking for an address, and the reply
 * is to a request from the local machine; *always* raise an internet event
 * for the revarp reply, as this is used (and needed) by the Net module when
 * talking to Gateway machines.
 *
 * Revision 1.3  95/01/24  17:17:46  kwelton
 * Whoops - missed an occurence of MMAXOFF within revarp_broadcastclientaddrs,
 * which should have been changed to MAXOFF(m) in the new mbuf scheme.
 *
 * Revision 1.2  95/01/24  16:24:53  kwelton
 * Several changes, mostly concerned with fixing remote address lookup,
 * which was badly broken in the DCI 2 version of the module.  Added the
 * new routine revarp_broadcastclientaddrs(), which implements the
 * functionality of the new ioctl SIOCSWHOTHEYARE.
 *
 * Used the opportunity to add a few debug lines.
 *
 * Revision 1.1  94/12/02  11:58:02  kwelton
 * Initial revision
 *
 */

#define _IP_VHL

#include <string.h>
#include <stddef.h>
#include "kernel.h"
#include "swis.h"
#include "AsmUtils/callbacks.h"
#include "Global/RISCOS.h"

#include "sys/types.h"
#include "sys/param.h"
#include "sys/systm.h"
#include "sys/syslog.h"
#include "sys/time.h"
#include "sys/mbuf.h"
#include "sys/socket.h"
#include "sys/socketvar.h"
#include "sys/errno.h"
#include "sys/ioctl.h"
#include "sys/kernel.h"
#include "sys/proc.h"
#include "sys/queue.h"
#include "sys/sysctl.h"

#include "net/if.h"
#include "net/route.h"

#include "netinet/in.h"
#include "netinet/in_systm.h"
#include "netinet/in_var.h"
#include "netinet/ip.h"
#include "netinet/in_pcb.h"
#include "netinet/if_ether.h"
#include "netinet/ip_icmp.h"
#include "netinet/ip_var.h"
#include "netinet/icmp_var.h"
#include "netinet/tcp.h"
#include "netinet/udp.h"
#include "netinet/udp_var.h"

#include "arpa/inet.h"

#include "machine/in_cksum.h"

#include "protocols/dhcp.h"

#include "debug.h"
#include "module.h"
#include "swiveneers.h"
#include "whoami.h"

/* This header is exported by the DHCP module */
#include "DHCP.h"

/*
 * Ho hum.  You can probably guess what this macro does.  The Microsoft DHCP
 * server (at least as far as NT4/SP3 goes) does NOT send BOOTP-style clients
 * any options other than those it thinks might be useful to a Microsoft
 * Windows client.  Typically this excludes some of the most useful data usually
 * returned via the BOOTP/DHCP protocol.  Its one saving grace in this respect
 * is that it DOES actually honour the DHCP Parameter List Request option when
 * it finds it in request packets and does respond with the requested options.
 * If you disable this option and try to use this module in conjunction with
 * such broken servers, then you will find that you do not get all the data
 * that you were hoping for.
 *
 * We are not 100% sure that inserting the DHCP Parameter List Request option
 * block in the options area of the request is compliant with RFC2132 (and
 * other related documents current at this time) but having examined the
 * source code for the generic BSD BOOTP and ISC DHCP servers, we believe
 * that they will either honour the request or ignore it completely and
 * send all available option data anyway.
 *
 */
#define FAULTY_MICROSOFT_SERVER


struct	ifqueue revarpintrq = {0, 0, 0, 10};

char *inet_ntoa(struct in_addr);
static void bootwakeup(void *arg);
static int revarp_myaddr(struct ifnet *, int);
static void revarpinput(struct mbuf *m);
static int if_askwhoiam(struct ifnet *ifp, int need,
                         int (*proc)(struct ifnet *, int), int flag);
static void bootsleep(int cmd);
static int bootp_myaddr(struct ifnet *, int retry);
static int request_netmask(struct ifnet *ifp, int flag);
static int backoff(int retry);
static int getrand(void);
static int left_alt_is_pressed(void), right_alt_is_pressed(void);

#define BOOTPSERVERVAR        "Inet$BootServer"
#define BOOTPSERVERFILE       "Inet$BootFile"
#define BOOTPGATEWAYVAR       "Inet$Gateway"
#define BOOTPNETMASKVAR       "Inet$EtherIPMask"
#define BOOTPIPADDRVAR        "Inet$EtherIPAddr"
#define BOOTPDNSVAR           "Inet$Resolvers"
#define BOOTPDOMAINNAMEVAR    "Inet$LocalDomain"
#define BOOTPHOSTVAR          "Inet$HostName"
#define BOOTPTIMESERVERVAR    "Inet$TimeServer"
#define BOOTPNTPSERVERVAR     "Inet$NTPServer"
#define BOOTPTIMEOFFSETVAR    "Inet$TimeOffset"
#define BOOTPNBNSVAR          "LanMan$NameServer"
#define BOOTPSERVERNAMEVAR    "Inet$ServerName"
#define BOOTPSMTPSERVERVAR    "Inet$SMTPServer"
#define BOOTPPOP3SERVERVAR    "Inet$POP3Server"
#define BOOTPNNTPSERVERVAR    "Inet$NNTPServer"
#define BOOTPWWWSERVERVAR     "Inet$WWWServer"
#define BOOTPFINGERSERVERVAR  "Inet$FingerServer"
#define BOOTPIRCSERVERVAR     "Inet$IRCServer"
#define BOOTPURLVAR           "Inet$URL"

#define MAX_NAMESERVERS		3
#define MAX_POPSERVERS		3
#define MAX_SMTPSERVERS		3
#define MAX_GENERICSERVERS	3

static int whoami_claimed_frames;

int
if_whoamimns(struct ifnet *ifp)
{
    ifp->if_flags |= IFF_NEED_IPADDR;
    if_askwhoiam(ifp, IFF_NEED_IPADDR, revarp_myaddr, 0);
    return (0);
}

static int
if_askwhoiam(struct ifnet *ifp, int need,
             int (*proc)(struct ifnet *, int), int flag)
{
    int f = ifp->if_flags;

    if (f & IFF_LOOPBACK)
	return 0;

    if ((f & IFF_BROADCAST) == 0)
	return 0;

    if (f & need)
	return (*proc)(ifp, flag);

    return 0;
}

#define IPADDR_MAX_WAIT 500

static int whoamiaddr = 0;
static int boot_tries = 1;
static int kernel_escape_seen = 0;
static struct timeval start_time;
static int whoiam_service_claimed = 0;

int
if_whoamiaddr(struct ifnet *ifp, int cmd)
{
    int error = EINVAL;

    kernel_escape_seen = 0;
    whoamiaddr = 0;
    whoiam_service_claimed = 0;

    if (boot_tries == 1)
    {
	microtime(&start_time);
    }

    if (cmd == SIOCGWHOIAMRB)
    {
	struct arpcom *ac = (struct arpcom *)ifp;
	printf("	 Physical address is %s\n",
	       ether_sprintf(&ac->ac_enaddr[0]));
    }

    ifp->if_flags |= IFF_NEED_IPADDR;
    timeout(bootwakeup, 0, backoff(boot_tries));

    if (cmd == SIOCGWHOIAMR || cmd == SIOCGWHOIAMRB)
	error = if_askwhoiam(ifp, IFF_NEED_IPADDR, revarp_myaddr, 1);

    if (!whoiam_service_claimed && (cmd == SIOCGWHOIAMB || cmd == SIOCGWHOIAMRB))
	error = if_askwhoiam(ifp, IFF_NEED_IPADDR, bootp_myaddr, 1);

    bootsleep(cmd);

    if ((ifp->if_flags & IFF_NEED_IPADDR) == IFF_NEED_IPADDR && !whoiam_service_claimed)
    {
	ifp->if_flags &= ~IFF_NEED_IPADDR;

	if (kernel_escape_seen)
	{
	    untimeout(bootwakeup, 0);
	    boot_tries = 1;
	}
	else
	{
	  boot_tries++;
	}

	if (whoami_claimed_frames)
	{
	  if_down(ifp);
	  claim_frames(ifp, 0);
	  ifp->if_flags &= ~IFF_RUNNING; /* Running flag implies that we have frames claimed */
	}
	return (EADDRNOTAVAIL);
    }

    untimeout(bootwakeup, 0);
    boot_tries = 1;
    return error;
}

#if 0
# define HZ 100 /* ticks per second */
#endif /* 0/1 */

static int
backoff(int retry)
{
    static unsigned char timeouts[] = { 2, 4, 8, 15, 20, 30, 60 };
    int t, s;

    t = retry - 1;
    if (t >= sizeof(timeouts)/sizeof(timeouts[0]))
	t = (sizeof(timeouts)/sizeof(timeouts[0])) - 1;

    /*
     * Construct a random delay between 0.5 and 1.5
     * times the value in the timeouts list
     */
    t = timeouts[t] * HZ;
    s = (getrand() % t) + (t / 2);
    return (s);
}

static int
getrand(void)
{
    int rand(void);

    return ((u_int)os_read_monotonic_time() % rand());
}

static void
bootsleep(int cmd)
{
  if (whoiam_service_claimed == 0)
    while (whoamiaddr == 0)
    {
	usermode_donothing();

	if (((cmd == SIOCGWHOIAMRB) || (cmd == SIOCGWHOIAMB)) && left_alt_is_pressed() && right_alt_is_pressed())
	{
	    kernel_escape_seen = 1;
	    break;
	}
    }
}

static void bootwakeup(void *arg)
{
    whoamiaddr = 1;
}

#define MASK_MAX_WAIT	500

int whoamimask = 0;

int
if_whoamimask(struct ifnet *ifp)
{
    ifp->if_flags |= IFF_NEED_MASK;
    if_askwhoiam(ifp, IFF_NEED_MASK, request_netmask, 0);
    tsleep(&whoamimask, PSOCK | PCATCH, "whoamimask", MASK_MAX_WAIT, 0);

    if ((ifp->if_flags & IFF_NEED_MASK) != 0)
    {
	ifp->if_flags &= ~IFF_NEED_MASK;
	return (-1);
    }

    return (0);
}

/*
 * Extract an IP address from 4 unaligned bytes.
 */
static u_long
vend_extractaddr(u_char *cp)
{
    return *cp + (*(cp+1) << 8) + (*(cp+2) << 16) + (*(cp+3) << 24);
}

/* Verify that vendor info is compliant with RFC-1048
 * by checking magic cookie.
 */
static int
vend_verify(BOOTP *pkt)
{
    return ntohl(vend_extractaddr(pkt->options)) == OPTIONS_COOKIE;
}

/*
 * Find code in vendor specific information
 * (returns pointer to length byte or NULL).
 * As of v5.21, copes with overload of sname and file fields
 */
static u_char *
vend_find_code(BOOTP *pkt, u_char code)
{
    u_char *cp = pkt->options + 4;     /* Skip magic cookie. */
    u_char c;
    u_char overload = 0;

    for (;;) {
      while ((c = *cp++) != OPTION_END)
      {
          if (c == OPTION_PAD) continue;
          if (c == OPTION_OPTIONOVERLOAD) overload = *(cp+1);
          if (c == code) return cp;
          cp += *cp + 1;
      }
      if (overload & 1) {
              cp = pkt->file;
              overload ^= 1;
              continue;
      }
      if (overload & 2) {
              cp = pkt->sname;
              overload ^= 2;
              continue;
      }
      break;
    }

    return NULL;
}

/*
 * Extract an IP address specified by data code from vendor specific data
 * (returns netmask or 0).
 */
static u_long
vend_iaddr(BOOTP *pkt, u_char code)
{
    u_char *cp = vend_find_code(pkt, code);

    return (cp++ != NULL) ? vend_extractaddr(cp) : 0;
}

/*
 * Extract a string from the vendor specific data
 * (returns length of string)
 */
static int
vend_string(BOOTP *pkt, u_char code, char *buf)
{
    u_char *cp = vend_find_code(pkt, code);

    if (cp != NULL)
    {
        int len = (int)*cp++;
        memcpy(buf, cp, len); /* This is safe, since buf is defined char[OPTIONS_MAX] */
        buf[len] = '\0';
        return len;
    }

    return 0;
}

/*
 * Extract multiple IP address responses.  Returns number of addresses
 * placed into buf
 */
static int
vend_miaddr(BOOTP *pkt, u_char code, char *buf, u_char max)
{
    	u_char *cp = vend_find_code(pkt, code);
    	u_char len;
        int i = 0;
        *buf = '\0';

	if (cp != NULL) {
	        len = *cp++;
	        if (len & 3) return 0;
		len >>= 2;
		if (len>max) len=max;
		for (; i<len; ++i, cp+=4) {
	        	struct in_addr addr;
		        if (i != 0) *buf++ = ' ';
                        addr.s_addr = vend_extractaddr(cp);
		        buf = strchr(strcpy(buf, inet_ntoa(addr)), '\0');
		}
	}

	return i;
}

/* Routine compensates for overloaded file field.  Return 0 if we set the var */
static int vend_bootpfile(BOOTP *pkt)
{
  if (vend_verify(pkt)) {
    u_char *cp = vend_find_code(pkt, OPTION_BOOTFILENAME);
    if (cp != NULL) {
      u_char tmp = cp[1+*cp];
      cp[1+*cp] = '\0';
      _kernel_setenv(BOOTPSERVERFILE, (char *) cp+1);
      cp[1+*cp] = tmp;
      return 0;
    }
  }
  return 1;
}

static void bootp_interpret(BOOTP *, int, struct ifnet *, int flags);
typedef enum {
        bif_DEFAULT,
        bif_DONT_SET_INTERFACE_ADDRESSES
} bootp_interpret_flags;

/*
 * A bootstrap packet reply has been received
 */
void
bootp_udp_input(struct mbuf *m)
{
    BOOTP pkt;
    int len = sizeof pkt;
    struct ifnet *ifp = m->m_pkthdr.rcvif;
    struct arpcom *ac = (struct arpcom *)ifp;

    if (!(ifp->if_flags & IFF_NEED_IPADDR))
        return;

    memset(&pkt, 0, sizeof(pkt));

    (void)EXPORT(m, len, &pkt);

#ifdef DEBUG
    if (DODEBUG(DBGADDRSRCH))
    {
        Printf("BOOTP response received\nac=%p, m=%p\n"
               "ac->ac_enaddr=%s, ", ac, m, ether_sprintf(ac->ac_enaddr));
        Printf("pkt.chaddr=%s, pkt.hlen=%d\n", ether_sprintf(pkt.chaddr), pkt.hlen);
    }
#endif

    /*
     * from 91/04/03 KWelton RISC iX fix
     *
     * make sure that this packet is for
     * us: broadcast BOOTP replies reach this
     * far, it is not a good idea to take any
     * notice of any replies not intended for
     * this machine.
     */
    if (memcmp(ac->ac_enaddr, pkt.chaddr, pkt.hlen))
	return;

#ifdef DEBUG
    if (DODEBUG(DBGADDRSRCH))
        Printf("Got BOOTP response: myaddr = %x\n", pkt.yiaddr);
#endif
    bootp_interpret(&pkt, len, ifp, bif_DEFAULT);
}

/* sbrodie 24/03/1999.  Split this function into two so that the DHCP module
 * can pass this function a DHCPACK message for it to look at and parse.
 */
static void bootp_interpret(BOOTP *pkt, int len, struct ifnet *ifp, int flags)
{
    char devname[16];
    struct in_addr in;
    struct in_addr netmask = { 0 };
    struct in_aliasreq ifra;

  do {

    if (!(flags & bif_DONT_SET_INTERFACE_ADDRESSES)) {
      in.s_addr = pkt->yiaddr;
      _kernel_setenv(BOOTPIPADDRVAR, inet_ntoa(in));

      in.s_addr = pkt->siaddr;
      _kernel_setenv(BOOTPSERVERVAR, inet_ntoa(in));

      /* If this was a DHCP packet, file field may have been overloaded */
      if (vend_bootpfile(pkt)) {
         /* But it wasn't this time */
         _kernel_setenv(BOOTPSERVERFILE, (char *) pkt->file);
      }
    }

    /* If this packet is RFC-1048 compliant then extract any pertinent
     * information from the vendor data (also rfc2132).
     */
    if (vend_verify(pkt))
    {
        static char buf[OPTIONS_MAX]; /* This MUST be OPTIONS_MAX */
        u_long tmp;

        tmp = vend_string(pkt, OPTION_HOSTNAME, buf);
        if (tmp) _kernel_setenv(BOOTPHOSTVAR, buf);

        tmp = vend_string(pkt, OPTION_DOMAINNAME, buf);
        if (tmp) _kernel_setenv(BOOTPDOMAINNAMEVAR, buf);

        if (!(flags & bif_DONT_SET_INTERFACE_ADDRESSES)) {
          netmask.s_addr = vend_iaddr(pkt, OPTION_NETMASK);
          if (netmask.s_addr) _kernel_setenv(BOOTPNETMASKVAR, inet_ntoa(netmask));
        }

        in.s_addr = vend_iaddr(pkt, OPTION_ROUTER);
        if (in.s_addr) _kernel_setenv(BOOTPGATEWAYVAR, inet_ntoa(in));

        if (vend_miaddr(pkt, OPTION_NAMESERVER, buf, MAX_NAMESERVERS))
        	_kernel_setenv(BOOTPDNSVAR, buf);

        if (vend_miaddr(pkt, OPTION_TIMESERVER, buf, MAX_GENERICSERVERS))
        	_kernel_setenv(BOOTPTIMESERVERVAR, buf);

        if (vend_miaddr(pkt, OPTION_NTPSERVERS, buf, MAX_GENERICSERVERS))
        	_kernel_setenv(BOOTPNTPSERVERVAR, buf);

        tmp = vend_iaddr(pkt, OPTION_TIMEOFFSET);
        if (tmp)
        {
          sprintf(buf,"%d",tmp);
          _kernel_setenv(BOOTPTIMEOFFSETVAR, buf);
        }

        if (vend_miaddr(pkt, OPTION_NBNSSERVERS, buf, MAX_GENERICSERVERS))
		_kernel_setenv(BOOTPNBNSVAR, buf);

        if (vend_miaddr(pkt, OPTION_SMTPSERVERS, buf, MAX_SMTPSERVERS))
        	_kernel_setenv(BOOTPSMTPSERVERVAR, buf);

        if (vend_miaddr(pkt, OPTION_POP3SERVER, buf, MAX_POPSERVERS))
        	_kernel_setenv(BOOTPPOP3SERVERVAR, buf);

        if (vend_miaddr(pkt, OPTION_NNTPSERVER, buf, MAX_GENERICSERVERS))
        	_kernel_setenv(BOOTPNNTPSERVERVAR, buf);

        if (vend_miaddr(pkt, OPTION_WWWSERVER, buf, MAX_GENERICSERVERS))
        	_kernel_setenv(BOOTPWWWSERVERVAR, buf);

        if (vend_miaddr(pkt, OPTION_FINGERSERVER, buf, MAX_GENERICSERVERS))
        	_kernel_setenv(BOOTPFINGERSERVERVAR, buf);

        if (vend_miaddr(pkt, OPTION_IRCSERVER, buf, MAX_GENERICSERVERS))
        	_kernel_setenv(BOOTPIRCSERVERVAR, buf);

        tmp = vend_string(pkt, OPTION_TFTPSERVER, buf);
        if (tmp) _kernel_setenv(BOOTPSERVERNAMEVAR, buf);

        tmp = vend_string(pkt, OPTION_URL, buf);
        if (tmp) _kernel_setenv(BOOTPURLVAR, buf);
    }

    if (!(flags & bif_DONT_SET_INTERFACE_ADDRESSES))
    {
        /* Better have a real socket here to be on the safe side. */
        struct socket *so;

        socreate(PF_INET, &so, SOCK_DGRAM, 0);

        /* Delete current address */
        memset(&ifra, 0, sizeof ifra);
        sprintf(ifra.ifra_name, "%s%d", ifp->if_name, ifp->if_unit);
        in_control(so, SIOCDIFADDR, (caddr_t) &ifra, ifp);

        /* Add new address */
        memset(&ifra, 0, sizeof ifra);
        sprintf(ifra.ifra_name, "%s%d", ifp->if_name, ifp->if_unit);
        ifra.ifra_addr.sin_family = AF_INET;
        ifra.ifra_addr.sin_len = sizeof ifra.ifra_addr;
        ifra.ifra_addr.sin_addr.s_addr = pkt->yiaddr;
        if (netmask.s_addr)
        {
            ifra.ifra_mask.sin_len = sizeof ifra.ifra_mask;
            ifra.ifra_mask.sin_addr = netmask;
        }
        in_control(so, SIOCAIFADDR, (caddr_t) &ifra, ifp);

        sofree(so);
    }

    /* Always do this, even if not setting the address. This routine being
     * called indicates the boot process is complete; it may have been
     * called by a DHCPExecute on an already-configured interface being
     * given a lease on the existing address.
     */
    ifp->if_flags &= ~IFF_NEED_IPADDR;

    sprintf(devname, "%s%d", ifp->if_name, ifp->if_unit);
    if (flags & bif_DONT_SET_INTERFACE_ADDRESSES) {
      service_internetstatus_dynamicboot_inform((char *) pkt, sizeof(*pkt));
      break;
    }
  } while (!service_internetstatus_dynamicboot_reply( devname, ifp->if_dib, (char *) pkt, sizeof(*pkt)));
    bootwakeup(0);
}

/*
 * Special version of IP output used during bootstrap.
 * This is needed since we do not at this stage know our IP address
 * and the normal ip_output uses the IP address to route the packet.
 * The packet in mbuf chain m contains a skeletal IP
 * header (with len, off, ttl, proto, tos, src, dst).
 * The mbuf chain containing the packet will be freed.
 */
static int
bootp_ip_output(struct mbuf *m, struct ifnet *ifp)
{
    register struct ip *ip;
    struct sockaddr_in dst;

    ip = mtod(m, struct ip *);
    ip->ip_vhl = IP_VHL_BORING;
    ip->ip_off &= IP_DF;
    ip->ip_id = htons(ip_id++);

    dst.sin_family = AF_INET;
    dst.sin_len = sizeof dst;
    dst.sin_addr = ip->ip_dst;

    ip->ip_len = htons((u_short)ip->ip_len);
    ip->ip_off = htons((u_short)ip->ip_off);
    ip->ip_sum = 0;
    ip->ip_sum = in_cksum_hdr(ip);
    return ((*ifp->if_output)(ifp, m, (struct sockaddr *)&dst, NULL));
}

/*
 * A special version of udp_output called while
 * attempting to obtain IP address
 */
static int bootp_udp_output(register struct mbuf *m, struct ifnet *ifp, u_long laddr, short lport, u_long faddr, short fport)
{
    register struct udpiphdr *ui;
    register int len = m->m_pkthdr.len;

    /*
     * get a mbuf for UDP and IP headers.
     */

    M_PREPEND(m, sizeof (struct udpiphdr), M_DONTWAIT);
    if (m == 0)
    {
#ifdef DEBUG
	if (DODEBUG(DBGMMAN))
	    Printf("bootp_udp_output: M_PREPEND failed\n");
#endif
	return (ENOBUFS);
    }

    /*
     * Fill in mbuf with extended UDP header
     * and addresses and length put into network format.
     */

    ui = mtod(m, struct udpiphdr *);
    ui->ui_next = ui->ui_prev = 0;
    ui->ui_x1 = 0;
    ui->ui_pr = IPPROTO_UDP;
    ui->ui_len = htons((u_short)len + sizeof (struct udphdr));
    ui->ui_src.s_addr = htonl(laddr);
    ui->ui_dst.s_addr = htonl(faddr);
    ui->ui_sport = htons(lport);
    ui->ui_dport = htons(fport);
    ui->ui_ulen = ui->ui_len;
    ui->ui_sum = 0;
    if ((ui->ui_sum = in_cksum(m, sizeof (struct udpiphdr) + len)) == 0)
        ui->ui_sum = 0xffff;
    ((struct ip *)ui)->ip_len = sizeof (struct udpiphdr) + len;
    ((struct ip *)ui)->ip_ttl = ip_defttl;

    return (bootp_ip_output(m, ifp));
}

static int
bootp_myaddr(struct ifnet *ifp, int retry)
{
    struct arpcom *ac = (struct arpcom *) ifp;
    struct mbuf *m0, *m;
    BOOTP   pkt;
    char *server = "", *file = "", devname[16];
    int option_index;
    unsigned int error_code;
#ifdef FAULTY_MICROSOFT_SERVER
    int req_index;
#endif
    struct timeval now;
    microtime(&now);

    memset(&pkt, 0, sizeof pkt);
    pkt.op = BOOTREQUEST;
    pkt.htype = ETHERNET_TYPE;
    pkt.hlen = ETHERNET_LEN;
    pkt.xid = time.tv_sec;
    pkt.secs = htons(now.tv_sec - start_time.tv_sec);
    memcpy(pkt.chaddr, ac->ac_enaddr, pkt.hlen);
    strcpy((char *)pkt.sname, server);  /* If known */
    strcpy((char *)pkt.file, file);		    /* If known */

    * (int *)&pkt.options[0] = htonl(OPTIONS_COOKIE);
    option_index = 4;
#ifdef FAULTY_MICROSOFT_SERVER
    pkt.options[option_index++] = OPTION_PARAMETERREQLIST;
    req_index = option_index++;
    pkt.options[option_index++] = OPTION_NETMASK;
    pkt.options[option_index++] = OPTION_ROUTER;
    pkt.options[option_index++] = OPTION_NAMESERVER;
    pkt.options[option_index++] = OPTION_DOMAINNAME;
    pkt.options[option_index++] = OPTION_HOSTNAME;
    pkt.options[option_index++] = OPTION_TIMESERVER;
    pkt.options[option_index++] = OPTION_NTPSERVERS;
    pkt.options[option_index++] = OPTION_TIMEOFFSET;
    pkt.options[option_index++] = OPTION_NBNSSERVERS;
    pkt.options[option_index++] = OPTION_TFTPSERVER;
    pkt.options[option_index++] = OPTION_WWWSERVER;
    pkt.options[option_index++] = OPTION_SMTPSERVERS;
    pkt.options[option_index++] = OPTION_POP3SERVER;
    pkt.options[option_index++] = OPTION_NNTPSERVER;
    pkt.options[option_index++] = OPTION_FINGERSERVER;
    pkt.options[option_index++] = OPTION_IRCSERVER;
    pkt.options[req_index] = option_index - 1 - req_index;
#endif
    pkt.options[option_index] = OPTION_END;

    sprintf(devname, "%s%d", ac->ac_if.if_name, ac->ac_if.if_unit);
    if (!service_internetstatus_dynamicboot_start(devname, ac->ac_if.if_dib, (char *)&pkt, sizeof(pkt),
                                                  offsetof(BOOTP, options) + option_index, &error_code)) {
                                                          whoiam_service_claimed = 1;
                                                          if (error_code > 255) error_code = EADDRNOTAVAIL;
                                                          return error_code;
                                                  }

    if (retry && ((ac->ac_if.if_flags & (IFF_UP | IFF_RUNNING)) != (IFF_UP | IFF_RUNNING)))
    {
      if ((ac->ac_if.if_flags & IFF_RUNNING) != IFF_RUNNING)
      {
        claim_frames(&ac->ac_if, 1);
        ac->ac_if.if_flags |= IFF_RUNNING;
        whoami_claimed_frames = TRUE;
      }
      ac->ac_if.if_flags |= IFF_UP;
    }
    else
    {
      whoami_claimed_frames = FALSE;
    }

    if ((m0 = m = ALLOC(sizeof pkt, &pkt)) == NULL)
	return (ENOBUFS);

    while (m)
    {
        m->m_type = MT_DATA;
        m = m->m_next;
    }

    m0->m_pkthdr.len = sizeof pkt;
    m0->m_pkthdr.rcvif = 0;
    m0->m_flags = M_PKTHDR | M_BCAST;

    return(bootp_udp_output(m0, &ac->ac_if, 0, BOOTPclient,
			    INADDR_BROADCAST, BOOTPserver));
}

/*
 * REVerse Address Resolution Protocol (revarp) is used by a diskless
 * client to find out its IP address when all it knows is its Ethernet address.
 */
static int
revarp_myaddr(register struct ifnet *ifp, int flag)
{
    struct arpcom *ac = (struct arpcom *) ifp;
    /*register struct sockaddr_in *sin;*/
    /*struct ifreq ifr;*/
    register struct mbuf *m;
    register struct ether_arp *ea;
    register struct ether_header *eh;
    struct sockaddr sa;

#ifdef DEBUG
    if( DODEBUG(DBGADDRSRCH) )
	Printf("\n\021\06revarp_myaddr: h/w addr %s on i/f %s%d, flag = %d\n",
	       ether_sprintf(ac->ac_enaddr), ifp->if_name, ifp->if_unit, flag);
#endif

    if (flag)
    {
        if ((ac->ac_if.if_flags & (IFF_UP | IFF_RUNNING)) != (IFF_UP | IFF_RUNNING))
        {
          if ((ac->ac_if.if_flags & IFF_RUNNING) != IFF_RUNNING)
          {
            claim_frames(ifp, 1);
            ifp->if_flags |= IFF_RUNNING;
            whoami_claimed_frames = TRUE;
          }
          ifp->if_flags |= IFF_UP;
        }
        else
        {
          whoami_claimed_frames = FALSE;
        }
    }

    if ((m = m_gethdr(M_DONTWAIT, MT_DATA)) == NULL)
	return (ENOBUFS);

    m->m_pkthdr.len = sizeof(struct ether_arp);
    m->m_pkthdr.rcvif = 0;
    m->m_flags |= M_BCAST;

    m->m_len = sizeof(struct ether_arp);
    MH_ALIGN(m, sizeof(struct ether_arp));
    ea = mtod(m, struct ether_arp *);
    memset(ea, 0, sizeof *ea);

    sa.sa_family = AF_UNSPEC;
    sa.sa_len = 16;
    eh = (struct ether_header *)sa.sa_data;
    memcpy(eh->ether_dhost, etherbroadcastaddr, sizeof eh->ether_dhost);
    memcpy(eh->ether_shost, ac->ac_enaddr, sizeof eh->ether_shost);

    eh->ether_type = ETHERTYPE_REVARP;

    ea->arp_hrd = htons(ARPHRD_ETHER);
    ea->arp_pro = htons(ETHERTYPE_IP);
    ea->arp_hln = sizeof(ea->arp_sha);	    /* hardware address length */
    ea->arp_pln = sizeof(ea->arp_spa);	    /* protocol address length */
    ea->arp_op = htons(REVARP_REQUEST);
    memcpy(ea->arp_sha, ac->ac_enaddr, sizeof ea->arp_sha);
    memcpy(ea->arp_tha, ac->ac_enaddr, sizeof ea->arp_tha);
#ifdef DEBUG
    if (DODEBUG(DBGADDRSRCH))
    {
	int err = (ifp->if_output)(ifp, m, &sa, NULL);

	Printf("\021\06revarp_myaddr: ifp->if_output (@@%x) returns %d\n",
	       /*ctosym*/(ifp->if_output), err);

	return err;
    }
    else
#endif
    return (*ifp->if_output)(ifp, m, &sa, NULL);
}

#ifdef NotYet
/*
 * These defines copied from netinet/if_ether.c
 */
#define ARPTAB_BSIZ	10		 /* bucket size (16) */
#define ARPTAB_NB	20		/* number of buckets (37) */
#define ARPTAB_SIZE	(ARPTAB_BSIZ * ARPTAB_NB)

extern struct arptab arptab[];
#endif

/*
 * Common length and type checks are done here,
 * then the protocol-specific routine is called.
 */
void
revarpintr(void)
{
	register struct mbuf *m;
	register struct arphdr *ar;
	int s;

#ifdef DEBUG
        Printf("revarpintr\n");
#endif
	while (revarpintrq.ifq_head) {
		s = splimp();
		IF_DEQUEUE(&revarpintrq, m);
		splx(s);
		if (m == 0 || (m->m_flags & M_PKTHDR) == 0) {
			panic("revarpintr");
			return;
		}
#ifdef DEBUG
                if (DODEBUG(DBGADDRSRCH))
                    Printf("got a REVARP packet\n");
#endif
		if (m->m_len >= sizeof(struct arphdr) &&
		    (ar = mtod(m, struct arphdr *)) &&
		    ntohs(ar->ar_hrd) == ARPHRD_ETHER &&
		    m->m_len >=
		      sizeof(struct arphdr) + 2 * ar->ar_hln + 2 * ar->ar_pln)
#ifdef DEBUG
                            if (DODEBUG(DBGADDRSRCH))
                                 Printf("Seems valid\n");
#endif
			    switch (ntohs(ar->ar_pro)) {

			    case ETHERTYPE_IP:
#ifdef DEBUG
                                    if (DODEBUG(DBGADDRSRCH))
                                            Printf("Is IP\n");
#endif
				    revarpinput(m);
				    continue;
			    }
		m_freem(m);
	}
}

/*
 * Reverse-ARP input. If this is a request we look the ethernet address
 * of the sender up in the arp table (server side).
 * If this is a response, the incoming packet contains our
 * internet address (client).
 */
static void
revarpinput(struct mbuf *m)
{
    register struct ether_arp *ea;
#ifdef NotYet
    register struct arptab *at = 0;
#endif
    register struct ether_header *eh;
    struct ifnet *ifp = m->m_pkthdr.rcvif;
    struct arpcom *ac = (struct arpcom *) ifp;
    struct ifreq ifr;
    struct in_ifaddr *ifa;
    struct sockaddr sa;
    struct sockaddr_in *sin;
    u_long thisip;
    struct in_addr serverip;

#ifdef DEBUG
    Printf("revarpinput(ac=%x, m=%x)\n", ac, m);
#endif
    ea = mtod(m, struct ether_arp *);
    if (m->m_len < sizeof *ea) {
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("Too short\n");
#endif
	goto out;
    }

    if (ac->ac_if.if_flags & IFF_NOARP) {
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("No ARP\n");
#endif
	goto out;
    }

    if (ntohs(ea->arp_pro) != ETHERTYPE_IP) {
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("Not IP: type=%d\n", ntohs(ea->arp_pro));
#endif
	goto out;
    }

    switch(ntohs(ea->arp_op))
    {
      case REVARP_REPLY:
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("REVARP_REPLY\n");
#endif
	/*
	 * don't bother, unless we are actively looking for an
	 * address, otherwise test whether this is a reply to a packet
	 * sent from local machine, by comparing hardware addresses
	 */
	if ((ifp->if_flags & IFF_NEED_IPADDR) &&
	    memcmp(ea->arp_tha, ac->ac_enaddr, 6) == 0)
	{
#ifdef DEBUG
            if (DODEBUG(DBGARP))
                Printf("It's a reply for us\n");
#endif

	    memcpy(&serverip, ea->arp_spa, sizeof serverip);

	    /*
	     * prepare for, and make a call to in_control() to set
	     * the interface address from the reply in the packet
	     */
	    memset(&ifr, 0, sizeof ifr);
	    sin = (struct sockaddr_in *)&ifr.ifr_addr;
	    sin->sin_family = AF_INET;
	    sin->sin_len = sizeof *sin;
	    memcpy(&sin->sin_addr, ea->arp_tpa, sizeof sin->sin_addr);
	    (void)in_control((struct socket *)0, SIOCSIFADDR,
			      (caddr_t)&ifr, ifp);

	    /*
	     * this interface has had an address set, so we aren't
	     * looking for an address any more
	     */
	    ifp->if_flags &= ~IFF_NEED_IPADDR;

	    /*
	     * this is for the benfit of dickless booting technology
	     */
	    _kernel_setenv(BOOTPSERVERVAR, inet_ntoa(serverip));

	    /*
	     * this will wakeup if_whoamiaddr(), which sets
	     * IFF_NEED_IPADDR before sleeping.
	     */
	    bootwakeup(0);
	}

	if (AUN_state == AUN_CLIENT)
	{
	    /*
	     * raise an Internet event for the benefit of the Net module
	     */
	    memcpy(&thisip, ea->arp_tpa, sizeof thisip);
	    memcpy(&serverip, ea->arp_spa, sizeof serverip);
	    os_generate_event(Event_Internet, Event_Internet_RevARPReply, (int)serverip.s_addr, (int)thisip);
	}

	break;

      case REVARP_REQUEST:
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("REVARP_REQUEST\n");
#endif
	/*
	 * it is dangerous to send a reply while we are
	 * actively looking for an address
	 */
	if ((ifp->if_flags & IFF_NEED_IPADDR) != 0)
	    goto out;

	if (AUN_state == AUN_CLIENT || AUN_state == AUN_GATEWAY)
	{
		eh = (struct ether_header *)sa.sa_data;
		memcpy(eh->ether_dhost, ea->arp_sha, sizeof(ea->arp_sha));
		IFP_TO_IA(ifp, ifa);
		if (ifa)
		{
		    if (AUN_state == AUN_CLIENT)
		        memset(ea->arp_spa, 0, sizeof ea->arp_spa);
		    else if (AUN_state == AUN_GATEWAY)
		        memcpy(ea->arp_spa, &IA_SIN(ifa)->sin_addr, sizeof ea->arp_spa);
		    memcpy(ea->arp_tpa, &IA_SIN(ifa)->sin_addr, sizeof ea->arp_tpa);
		    ea->arp_tpa[3] = 0; /* MNS station id */
		    memcpy(ea->arp_sha, ac->ac_enaddr, sizeof ea->arp_sha);
		    memcpy(eh->ether_shost, ac->ac_enaddr, sizeof ea->arp_sha);
		    eh->ether_type = ETHERTYPE_REVARP;
		    ea->arp_op = htons(REVARP_REPLY);
		    sa.sa_family = AF_UNSPEC;
		    sa.sa_len = 16;
		    (*ac->ac_if.if_output)(&ac->ac_if, m, &sa, NULL);

		    return;
	        }
	}
	else
	{
		os_generate_event(Event_Internet, Event_Internet_RevARPRequest, (int) m, ac->ac_if.if_swibase);
	}

	break;

      default:
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("Unknown REVARP type: %d\n", ntohs(ea->arp_op));
#endif
	break;
    }

  out:
    m_freem(m);
    return;
}

/*
 * this routine is from the InternetAG sources - it was run in
 * response to an SIOCGWHOIAMMNS ioctl() issued by the NetG
 * module -- unfortunately, the person who used this ioctl()
 * was severely brain damaged, as the same ioctl() has a completely
 * different functionality in the Internet, and InternetAG modules,
 * so the ioctl() has now been changed to SIOCSWHOTHEYARE.
 *
 * The routine broadcasts a REVARP_REPLY packet, which AUN clients
 * pick up (via the RevARPReply Internet event), and fill in the blank
 * target address field (ea->arp_tha[3]) with their station number
 * from CMOS RAM.  This is all so disgusting it makes my head hurt.
 *
 * XXX
 *
 * this routine is *actually* passed a struct ifnet, but intimate
 * knowledge of the way the Internet module hangs together (i.e. the
 * fact that the definitive struct ifnets within the system are actually
 * fields within struct arpcoms) allows the parameter to be implicitly
 * cast to a struct arpcom pointer.
 */
void
revarp_broadcastclientaddrs(struct arpcom *ac)
{
    struct ifnet *ifp = &ac->ac_if;
    struct mbuf *m;
    struct ether_arp *ea;
    struct ether_header *eh;
    struct in_ifaddr *ifa;
    struct sockaddr sa;

    if ((m = m_get(M_DONTWAIT, MT_DATA)) == NULL)
	return;

    m->m_len = sizeof(struct ether_arp);
    M_ALIGN(m, sizeof(struct ether_arp));
    ea = mtod(m, struct ether_arp *);

    memset(ea, 0, sizeof *ea);

    sa.sa_family = AF_UNSPEC;
    sa.sa_len = 16;
    eh = (struct ether_header *)sa.sa_data;
    memcpy(eh->ether_dhost, etherbroadcastaddr, sizeof eh->ether_dhost);
    memcpy(eh->ether_shost, ac->ac_enaddr, sizeof eh->ether_shost);
    eh->ether_type = ETHERTYPE_REVARP;
    ea->arp_hrd = htons(ARPHRD_ETHER);
    ea->arp_pro = htons(ETHERTYPE_IP);
    ea->arp_hln = sizeof ea->arp_sha;	    /* hardware address length */
    ea->arp_pln = sizeof ea->arp_spa;	    /* protocol address length */
    ea->arp_op = htons(REVARP_REPLY);
    memcpy(ea->arp_sha, ac->ac_enaddr, sizeof ea->arp_sha);
    memcpy(ea->arp_tha, ac->ac_enaddr, sizeof ea->arp_tha);

    IFP_TO_IA(ifp, ifa);
    if (ifa)
    {
	memcpy(ea->arp_spa, &IA_SIN(ifa)->sin_addr, sizeof ea->arp_spa);
	memcpy(ea->arp_tpa, &IA_SIN(ifa)->sin_addr, sizeof ea->arp_tpa);

	ea->arp_tpa[3] = 0;		   /* MNS station field */
	(*ifp->if_output)(ifp, m, &sa, NULL);
    }
    else
	m_freem(m);
}

extern int send_flags;		/* Allow broadcasts during boot */

/*
 * Whilst booting, attempt to find our netmask
 * by broadcasting an ICMP_MASKREQ
 */
static int
request_netmask(struct ifnet *ifp, int flag)
{
    struct mbuf *m;
    register struct in_ifaddr *ia = 0;
    struct ip *ip;

	/*
	 * Find address for this interface, if it exists.
	 */
	for (ia = in_ifaddr; ia; ia = ia->ia_next)
		if (ia->ia_ifp == ifp)
			break;
	if (ia == 0) {
		panic("request_netmask");
		return 0;
	}

    if ((m = m_gethdr(M_DONTWAIT, MT_DATA)) == NULL)
	return (ENOBUFS);

    /*
     * Fill in mbuf with IP header and addresses
     * and length put into network format.
     */
    MH_ALIGN(m, sizeof (struct ip));
    m->m_len = sizeof (struct ip);
    m->m_pkthdr.len = sizeof (struct ip);
    m->m_pkthdr.rcvif = ifp;
    ip = mtod(m, struct ip *);
    ip->ip_vhl = IP_VHL_BORING;
    ip->ip_tos = 0;
    ip->ip_len = htons(sizeof(struct ip));
    ip->ip_id = 0;
    ip->ip_off = 0;
    ip->ip_ttl = MAXTTL;
    ip->ip_p = IPPROTO_RAW;
    ip->ip_sum = 0;
    ip->ip_dst = ia->ia_addr.sin_addr;
    ip->ip_src = ia->ia_broadaddr.sin_addr;
    send_flags = SO_DONTROUTE | SO_BROADCAST;
    icmp_error(m, ICMP_MASKREQ, 0, 0, (struct ifnet *) 0);
    send_flags = 0;
    return 0;
}

char *
inet_ntoa(struct in_addr in)
{
    static char b[18];
    char *p;

    p = (char *)&in;
#define UC(b)	(((int)b)&0xff)
    sprintf(b, "%d.%d.%d.%d", UC(p[0]), UC(p[1]), UC(p[2]), UC(p[3]));
    return (b);
}

#define KEYSCAN 121
#define LEFTALT 5
#define RIGHTALT 8

static int
left_alt_is_pressed(void)
{
    return _kernel_osbyte(KEYSCAN, LEFTALT | 0x80, 0) & 0xFF;
}

static int
right_alt_is_pressed(void)
{
    return _kernel_osbyte(KEYSCAN, RIGHTALT | 0x80, 0) & 0xFF;
}

/* The following routines were added in version 5.20 to support the external DHCP
 * client module.
 */
int
if_sdhcpreq(struct ifnet *ifp, struct ifdhcpreq *ifd)
{
    struct arpcom *ac = (struct arpcom *) ifp;
    struct mbuf *m0, *m;
    int res = 0;

    if ((ifd->ifr.ifr_flags & 4) == 4) {
            /* DHCP module wanted this packet parsed */
            bootp_interpret(&ifd->packet, sizeof(ifd->packet), ifp, (ifd->ifr.ifr_flags >> 8) & 0xFF);
    }
    else if ((ifd->ifr.ifr_flags & 2) == 0) {
            /* We did want to send a packet.  Setting bit 1 allows us to simply clear
             * the frame claims after a DHCPNAK (as long as bit 0 is set too!)
             */

        boot_tries = 1; /* Force immediate transmission */

        if (((ac->ac_if.if_flags & (IFF_UP | IFF_RUNNING)) != (IFF_UP | IFF_RUNNING)))
        {
          if ((ac->ac_if.if_flags & IFF_RUNNING) != IFF_RUNNING)
          {
            claim_frames(&ac->ac_if, 1);
            ac->ac_if.if_flags |= IFF_RUNNING;
            whoami_claimed_frames = TRUE;
          }
          ac->ac_if.if_flags |= IFF_UP;
        }
        else
        {
          whoami_claimed_frames = FALSE;
        }

        if ((m0 = m = ALLOC(sizeof(ifd->packet), &ifd->packet)) == NULL)
            return (ENOBUFS);

        while (m)
        {
            m->m_type = MT_DATA;
            m = m->m_next;
        }

        m0->m_pkthdr.len = sizeof(ifd->packet);
        m0->m_pkthdr.rcvif = 0;
        m0->m_flags = M_PKTHDR | M_BCAST;

        res = bootp_udp_output(m0, &ac->ac_if,
                               ntohl(ifd->packet.ciaddr), BOOTPclient,
                               INADDR_BROADCAST, BOOTPserver);
    }

    if ((ifd->ifr.ifr_flags & 1) && whoami_claimed_frames) {
        if_down(ifp);
	claim_frames(ifp, 0);
	ifp->if_flags &= ~IFF_RUNNING; /* Running flag implies that we have frames claimed */
    }
    return res;
}

/* EOF whoami.c */
@


4.27
log
@Don't send an Acorn private option with a DHCP request
Per RFC3942 the public range of DHCP option numbers has been extended to reassign previously private option 164.
While renumbering into the new site specific range (224-254) was an option, it's also defined that site specific options shouldn't be baked into products, hence support for Inet$PrivateData has been removed.

Version 5.59. Tagged as 'Internet-5_59'
@
text
@d58 1
a168 4
#define Internet_Event	 19
#define RarpReply	  4
#define RarpRequest	  5

d1073 1
a1073 1
	    os_generate_event(Internet_Event, RarpReply, (int)serverip.s_addr, (int)thisip);
d1116 1
a1116 1
		os_generate_event(Internet_Event, RarpRequest, (int) m, ac->ac_if.if_swibase);
d1143 1
a1143 1
 * pick up (via the RarpReply Internet event), and fill in the blank
@


4.26
log
@Delete local user_mode_donothing() and replace with usermode_donothing() from AsmUtils.
Makefilse uses ModuleLibs too.
Lots of STM/LDM replaced with Push and Pull macros.
Local definitions in 'swiveneers' replaced with header files.

Version 5.53. Tagged as 'Internet-5_53'
@
text
@a161 1
#define BOOTPACORNVAR         "Inet$PrivateData"
a611 3

        tmp = vend_string(pkt, OPTION_ACORNPRIVATE, buf);
        if (tmp) _kernel_setenv(BOOTPACORNVAR, buf);
a780 1
    pkt.options[option_index++] = OPTION_ACORNPRIVATE;
@


4.25
log
@IFF_NEED_IPADDR flag now cleared whenever a BOOTP/DHCP response is processed;
previously this only happened if the address was set. This ensures correct
behaviour following the first DHCPREQUEST in the REBOOTING state, where the
address isn't changed.

Version 5.49. Tagged as 'Internet-5_49'
@
text
@d57 1
d306 1
a306 1
	user_mode_donothing();
@


4.24
log
@DHCP packets sent out through ioctl(SIOCGWHOIAMD) had their source address
in the IP header reversed - this was visible for packets the DHCP client
sent out in the REBINDING state.

Version 5.48. Tagged as 'Internet-5_48'
@
text
@a640 1
        ifp->if_flags &= ~IFF_NEED_IPADDR;
d644 7
@


4.23
log
@A small amount of ANSIisation, to satisfy modern compilers.

Version 5.47. Tagged as 'Internet-5_47'
@
text
@d1319 1
a1319 1
    	return (ENOBUFS);
d1331 3
a1333 2
        res = bootp_udp_output(m0, &ac->ac_if, ifd->packet.ciaddr, BOOTPclient,
    			    INADDR_BROADCAST, BOOTPserver);
@


4.22
log
@Commit of two years' worth of changes.
Upped version number, because it's about time it was.

Version 5.46. Tagged as 'Internet-5_46'
@
text
@d292 1
a292 1
getrand()
d1271 1
a1271 1
left_alt_is_pressed()
d1277 1
a1277 1
right_alt_is_pressed()
@


4.21
log
@Gawd this version number's creeping up.
Attempts to free some mbufs on receipt of MbufManagerStatus_Scavenge.
Extracts DHCP NTP servers setting to Inet$NTPServer.

Version 5.36. Tagged as 'Internet-5_36'
@
text
@d175 1
a175 2
if_whoamimns(ifp)
    struct ifnet *ifp;
d183 2
a184 4
if_askwhoiam(ifp, need, proc, flag)
    struct ifnet *ifp;
    int need, flag;
    int (*proc)(struct ifnet *, int);
d209 1
a209 3
if_whoamiaddr(ifp, cmd)
    struct ifnet *ifp;
    int cmd;
d273 1
a273 2
backoff(retry)
    int retry;
d300 1
a300 2
bootsleep(cmd)
    int cmd;
d325 1
a325 2
if_whoamimask(ifp)
    struct ifnet *ifp;
d480 1
a480 2
bootp_udp_input(m)
    struct mbuf *m;
d664 1
a664 3
bootp_ip_output(m, ifp)
    struct mbuf *m;
    struct ifnet *ifp;
d733 1
a733 3
bootp_myaddr(ifp, retry)
    struct ifnet *ifp;
    int retry;
d828 1
a828 3
revarp_myaddr(ifp, flag)
    register struct ifnet *ifp;
    int flag;
d971 1
a971 2
revarpinput(m)
    struct mbuf *m;
d981 1
a981 1
    struct ifaddr *ifa;
d1095 2
a1096 14
		for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
		{
		    if (ifa->ifa_ifp == ifp)
		    {
			if (AUN_state == AUN_CLIENT)
			    memset(ea->arp_spa, 0, sizeof ea->arp_spa);
			else if (AUN_state == AUN_GATEWAY)
			    memcpy(ea->arp_spa, &IA_SIN(ifa)->sin_addr, sizeof ea->arp_spa);
			memcpy(ea->arp_tpa, &IA_SIN(ifa)->sin_addr, sizeof ea->arp_tpa);
			ea->arp_tpa[3] = 0; /* MNS station id */
			break;
		    }
		}
		if (ifa != 0)
d1098 6
d1157 1
a1157 2
revarp_broadcastclientaddrs(ac)
    struct arpcom *ac;
d1163 1
a1163 1
    struct ifaddr *ifa;
d1189 2
a1190 1
    for(ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
d1192 2
a1193 4
	if (ifa->ifa_ifp == ifp)
	{
	    memcpy(ea->arp_spa, &IA_SIN(ifa)->sin_addr, sizeof ea->arp_spa);
	    memcpy(ea->arp_tpa, &IA_SIN(ifa)->sin_addr, sizeof ea->arp_tpa);
d1195 2
a1196 3
	    ea->arp_tpa[3] = 0;		   /* MNS station field */
	    break;
	}
d1198 1
a1198 2

    if (ifa == 0)
a1199 2
    else
	(*ifp->if_output)(ifp, m, &sa, NULL);
d1209 1
a1209 3
request_netmask(ifp, flag)
    struct ifnet *ifp;
    int flag;
d1255 1
a1255 2
inet_ntoa(in)
    struct in_addr in;
@


4.20
log
@Added new FreeBSD sysctl handling using linker magic.
A few new sysctls added as a result.
SO_TIMESTAMP now gives real time, not Internet's internal time.
DHCP/BOOTP parsing picks up URL option and pops it into Inet$URL.
Requires TCPIPLibs 5.25 and link 5.12.

Version 5.31. Tagged as 'Internet-5_31'
@
text
@d150 1
d585 3
d781 1
@


4.19
log
@The horrible ac_ipaddr member of struct arpcom exorcised once and for all.

Version 5.30. Tagged as 'Internet-5_30'
@
text
@d70 2
d159 1
d614 3
@


4.18
log
@* Dynamic ports now assigned in range 49152-65535.
* IP_RECVDSTADDR works for non-unicast packets.
* SO_TIMESTAMP added.
* IP_RECVIF added.
* Various other internal changes merged in from FreeBSD sources.

Version 5.29. Tagged as 'Internet-5_29'
@
text
@a849 24
#if 0
	/*
	 * We need to give the interface a temporary address just
	 * so it gets initialized. Hopefully, the address won't get used.
	 * Also force trailers to be off on this interface.
	 */
	memset(&ifr, 0, sizeof ifr);
	sin = (struct sockaddr_in *)&ifr.ifr_addr;
	sin->sin_family = AF_INET;
	sin->sin_len = sizeof(*sin);
	sin->sin_addr.s_addr = htonl(0x00FFFFFF);
	ifp->if_flags |= IFF_NOTRAILERS;

	(void) in_control((struct socket *)0, SIOCSIFADDR, (caddr_t)&ifr, ifp);
	if (ac->ac_ipaddr.s_addr && ac->ac_ipaddr.s_addr != sin->sin_addr.s_addr)
	{
#ifdef DEBUG
	    if( DODEBUG(DBGADDRSRCH) )
		Printf("\021\01revarp_myaddr: ac_ipaddr = %x, sin_addr = %x\n",
		       ac->ac_ipaddr.s_addr, sin->sin_addr.s_addr);
#endif
	    return;
	}
#else
a863 1
#endif
d1039 1
a1039 5
	    /*
	     * this duplicates an action taken within the in_control()
	     * call to set the interface address.
	     */
	    memcpy(&ac->ac_ipaddr, ea->arp_tpa, sizeof ac->ac_ipaddr);
d1050 1
a1050 1
	    sin->sin_addr = ac->ac_ipaddr;
a1220 2
#define satosin(sa) ((struct sockaddr_in *)(sa))

d1265 2
a1266 2
    ip->ip_dst = ((struct arpcom *)ifp)->ac_ipaddr;
    ip->ip_src = satosin(&ia->ia_broadaddr)->sin_addr;
@


4.17
log
@* Fixed bug introduced by tentative ARP probe - a typo made arp_ifinit() fail to
  set up the interface route structure properly.
* Divide-by-zero when an IGMP membership query with a time of 1 received fixed
  (from FreeBSD).
* IGMP messages now sent with TOS set to "maximum reliability".
* tcp_output.c updated from FreeBSD - in particular path_mtu_discovery sysctl
  now available.
* A few other FreeBSD structural changes and bug fixes integrated.
* Put UDP checksum in BOOTP packets.
* Null pointer dereferencing fixed in whoami.c. Address setting now done with
  SIOCDIFADDR and SIOCAIFADDR. Don't set the netmask if asked not to.
* Output BOOTP packets with the source address in ciaddr
Note that various structural changes mean that the support tools (in particular
InetStat) will need to be recompiled.
Requires TCPIPLibs 5.20

Version 5.27. Tagged as 'Internet-5_27'
@
text
@a531 2
    struct ifreq ifr;
    struct sockaddr_in *sin;
@


4.16
log
@Interim code added to enable the BOOTP/DHCP code to return proper values
for errno from the ioctl which controls dynamic booting.

Not tagged.
@
text
@d50 3
d65 1
d536 2
a537 3
    struct in_addr netmask;

    netmask.s_addr = 0L;
d618 6
a623 4
    memset(&ifr, 0, sizeof ifr);
    sin = (struct sockaddr_in *)&ifr.ifr_addr;
    sin->sin_family = AF_INET;
    sin->sin_len = sizeof *sin;
d625 18
a642 11
    if (netmask.s_addr)
    {
      /* Whilst it it might seem strange, setting the netmask *before*
       * setting the interface's address, it is necessary to do so to
       * ensure that the routing information generated when the address
       * *is* set is correct wrt its netmask value, and does not simply use
       * an appropriate 'class' mask - RCE:981030
       */
       sin->sin_addr.s_addr = netmask.s_addr;
       (void) in_control((struct socket *)0, SIOCSIFNETMASK, (caddr_t)&ifr, ifp);
    }
d644 1
a644 4
    if (!(flags & bif_DONT_SET_INTERFACE_ADDRESSES)) {
      sin->sin_addr.s_addr = pkt->yiaddr;
      (void) in_control((struct socket *)0, SIOCSIFADDR, (caddr_t)&ifr, ifp);
      ifp->if_flags &= ~IFF_NEED_IPADDR;
a646 5
    if (netmask.s_addr)
    {
       sin->sin_addr.s_addr = (netmask.s_addr & pkt->yiaddr) | ~netmask.s_addr;
       (void) in_control((struct socket *)0, SIOCSIFBRDADDR, (caddr_t)&ifr, ifp);
    }
d673 1
a673 1
    ip->ip_v = IPVERSION;
a675 1
    ip->ip_hl = sizeof(struct ip) >> 2;
d727 2
d1290 1
a1290 2
    ip->ip_v = IPVERSION;
    ip->ip_hl = 5;
d1384 1
a1384 1
        res = bootp_udp_output(m0, &ac->ac_if, 0, BOOTPclient,
@


4.15
log
@  Added new service call sub-reason code and support for DHCPINFORM.
  Bug fix for packet pointers.
Detail:
  A new flag has been introduced in the DHCP private ioctl interface
    to request that the Internet module does not fiddle with the
    addresses of interfaces but only sets the system variables in
    response to the content of the DHCPACK message.  The DHCP module
    will pass the DHCPACK message if and when it gets a response to
    an earlier DHCPINFORM that it originated.
  When the bootp_udp_input routine was split into two, the packet
    was passed as a pointer to the packet parser and one reference to
    &pkt hadn't been replaced with just pkt, hence completely wrong
    values were being passed around in the DynamicBootReply service
    call.
  The DynamicBootStart sub-reason code has also been modified to support
    claimers setting R2 to be the errno to be returned to the ioctl
    caller.  This means that modules such as DHCP can return errno
    values back via the Internet module instead of requiring clients to
    know to read the interface status from the DHCP module.
Admin:
  Requires TCPIPLibs 5.18 and later.
  Required by DHCP 0.05 and later.
  Required by IPConfig 0.19 and later.
  TCPIPLibs 5.18's LibraryDoc contains details of the service call.

Version 5.25. Tagged as 'Internet-5_25'
@
text
@d124 1
a124 1
static void revarp_myaddr(struct ifnet *, int);
d126 2
a127 2
static void if_askwhoiam(struct ifnet *ifp, int need,
                         void (*proc)(struct ifnet *, int), int flag);
d129 2
a130 3
static int bootp_myaddr(struct arpcom *ac, int retry);
static int dhcp_myaddr(struct ifnet *);
static void request_netmask(struct ifnet *ifp, int flag);
d175 1
a175 1
static void
d179 1
a179 1
    void (*proc)(struct ifnet *, int);
d184 1
a184 1
	return;
d187 1
a187 1
	return;
d190 3
a192 1
	(*proc)(ifp, flag);
d208 1
d229 2
a230 2
    if (!whoiam_service_claimed && (cmd == SIOCGWHOIAMR || cmd == SIOCGWHOIAMRB))
	if_askwhoiam(ifp, IFF_NEED_IPADDR, revarp_myaddr, 1);
d233 1
a233 5
	if_askwhoiam(ifp, IFF_NEED_IPADDR, (void (*)())bootp_myaddr, 1);

    if (!whoiam_service_claimed && (cmd == SIOCGWHOIAMD)) {
        dhcp_myaddr(ifp);
    }
d251 1
a251 1
	if (whoami_claimed_frames = TRUE)
d257 1
a257 1
	return (-1);
d262 1
a262 1
    return whoiam_service_claimed ? (-1) : (0);
d731 2
a732 2
bootp_myaddr(ac, retry)
    struct arpcom *ac;
d735 1
d826 1
a826 1
static void
d889 1
a889 1
	return;
d922 2
d927 1
a927 1
    (*ifp->if_output)(ifp, m, &sa, NULL);
d1253 1
a1253 1
static void
d1270 1
a1270 1
		return;
d1274 1
a1274 1
	return;
d1299 1
a1389 6
}

static int dhcp_myaddr(struct ifnet *ifp)
{
    (void) ifp;
    return (0);
@


4.14
log
@  Improved DHCP support.
  Added more ATM interface type support.
Detail:
  RFC2132 DHCP options migrated out of Internet module into TCPIPLibs
    header file protocols/dhcp.h where they belong.
  whoami.c:vend_find_code() now knows about DHCP field overloading and
    will extract options correctly - both normal options and the
    ones extracted from the overloaded field.
  Internet now knows about broadcast-capable ATM (ST_TYPE_ATMPLUSRELAY)
    and LANE (ST_TYPE_ATMFLANE) as interface types, and treats them
    appropriately.
Admin:
  Built and tested in STB22 NEC.
  Requires header file exported by DHCP 0.01
    (CVS: RiscOS/Sources/Networking/DHCP   tag: DHCP-0_01 or later)
  Requires TCPIPLibs 5.10 or later.
    (CVS: RiscOS/Sources/Libs/TCPIPLibs    tag: TCPIPLibs-5_10 or later)

Version 5.21. Tagged as 'Internet-5_21'
@
text
@d472 5
a476 1
static void bootp_interpret(BOOTP *, int, struct ifnet *);
d522 1
a522 1
    bootp_interpret(&pkt, len, ifp);
d528 1
a528 1
static void bootp_interpret(BOOTP *pkt, int len, struct ifnet *ifp)
d540 12
a551 10
    in.s_addr = pkt->yiaddr;
    _kernel_setenv(BOOTPIPADDRVAR, inet_ntoa(in));

    in.s_addr = pkt->siaddr;
    _kernel_setenv(BOOTPSERVERVAR, inet_ntoa(in));

    /* If this was a DHCP packet, file field may have been overloaded */
    if (vend_bootpfile(pkt)) {
       /* But it wasn't this time */
       _kernel_setenv(BOOTPSERVERFILE, (char *) pkt->file);
d568 4
a571 2
        netmask.s_addr = vend_iaddr(pkt, OPTION_NETMASK);
        if (netmask.s_addr) _kernel_setenv(BOOTPNETMASKVAR, inet_ntoa(netmask));
d634 5
a638 3
    sin->sin_addr.s_addr = pkt->yiaddr;
    (void) in_control((struct socket *)0, SIOCSIFADDR, (caddr_t)&ifr, ifp);
    ifp->if_flags &= ~IFF_NEED_IPADDR;
d646 5
a650 1
  } while (!service_internetstatus_dynamicboot_reply( devname, ifp->if_dib, (char *) &pkt, sizeof(pkt)));
d741 1
d785 1
a785 1
                                                  offsetof(BOOTP, options) + option_index)) {
d787 2
a788 1
                                                          return EADDRNOTAVAIL;
d1341 1
a1341 1
            bootp_interpret(&ifd->packet, sizeof(ifd->packet), ifp);
@


4.13
log
@  Support for DHCP module added.
Detail:
  Support for the new ioctl (SIOCGWHOIAMD) added.
  BOOTP client code re-organised so that DHCP module can
    trigger particular things to be done for it such as
    sending a packet on an interface, interpreting a
    "BOOTP response" - ie. a DHCPACK message.  This allows
    the DHCP module to usurp the BOOTP behaviour of the
    Internet module and replace it without Internet module
    clients like IPConfig ever being aware that it is now
    using DHCP and not BOOTP.
Admin:
  Tested in general usage in desktop machine.
  Requires TCPIPLibs 5.09
    (RiscOS/Sources/Lib/TCPIPLibs tag: TCPIPLibs-5_09 or later)
  Required by DHCP 0.00
    (RiscOS/Sources/Networking/DHCP tag: DHCP-0_00 or later)

Version 5.20. Tagged as 'Internet-5_20'
@
text
@d94 3
d363 1
d370 1
d372 19
a390 5
    while ((c = *cp++) != OPTION_END)
    {
        if (c == OPTION_PAD) continue;
        if (c == code) return cp;
        cp += *cp + 1;
d456 16
d541 6
a546 1
    _kernel_setenv(BOOTPSERVERFILE, (char *) pkt->file);
d584 1
a584 1
        if (vend_miaddr(pkt, OPTION_SMTPSERVER, buf, MAX_SMTPSERVERS))
d758 1
a758 1
    pkt.options[option_index++] = OPTION_SMTPSERVER;
@


4.12
log
@  New service calls at the point of BOOTP requests and replies to allow
    external software to add things to requests and to extract answers
    from replies.
Detail:
  Prior to sending a request, InternetStatus_DynamicBootStart is issued.
    If this call is claimed, then the request is not placed on the network.
    When the reply comes back, Internet processes it as normal, sets the
    system variables it usually sets and then issues the service call
    InternetStatus_DynamicBootReply to allow other modules to extract any
    configuration that they want but that Internet does not know about.
    If the service call is claimed, Internet reprocesses the packet.
    RiscOS/Sources/Lib/TCPIPLibs/LibraryDoc contains full details.
Admin:
  Requires TCPIPLibs 5.06 or later
    (CVS: RiscOS/Sources/Lib/TCPIPLibs   tag: TCPIPLibs-5_06)

Version 5.19. Tagged as 'Internet-5_19'
@
text
@d127 1
d230 4
d437 1
a447 2
    struct ifreq ifr;
    struct sockaddr_in *sin;
a449 3
    struct in_addr in;
    struct in_addr netmask;
    char devname[16];
a453 1
    netmask.s_addr = 0L;
d483 15
d501 1
a501 1
    in.s_addr = pkt.yiaddr;
d504 1
a504 1
    in.s_addr = pkt.siaddr;
d506 1
a506 1
    _kernel_setenv(BOOTPSERVERFILE, (char *) pkt.file);
d511 1
a511 1
    if (vend_verify(&pkt))
d516 1
a516 1
        tmp = vend_string(&pkt, OPTION_HOSTNAME, buf);
d519 1
a519 1
        tmp = vend_string(&pkt, OPTION_DOMAINNAME, buf);
d522 1
a522 1
        netmask.s_addr = vend_iaddr(&pkt, OPTION_NETMASK);
d525 1
a525 1
        in.s_addr = vend_iaddr(&pkt, OPTION_ROUTER);
d528 1
a528 1
        if (vend_miaddr(&pkt, OPTION_NAMESERVER, buf, MAX_NAMESERVERS))
d531 1
a531 1
        if (vend_miaddr(&pkt, OPTION_TIMESERVER, buf, MAX_GENERICSERVERS))
d534 1
a534 1
        tmp = vend_iaddr(&pkt, OPTION_TIMEOFFSET);
d541 1
a541 1
        if (vend_miaddr(&pkt, OPTION_NBNSSERVERS, buf, MAX_GENERICSERVERS))
d544 1
a544 1
        if (vend_miaddr(&pkt, OPTION_SMTPSERVER, buf, MAX_SMTPSERVERS))
d547 1
a547 1
        if (vend_miaddr(&pkt, OPTION_POP3SERVER, buf, MAX_POPSERVERS))
d550 1
a550 1
        if (vend_miaddr(&pkt, OPTION_NNTPSERVER, buf, MAX_GENERICSERVERS))
d553 1
a553 1
        if (vend_miaddr(&pkt, OPTION_WWWSERVER, buf, MAX_GENERICSERVERS))
d556 1
a556 1
        if (vend_miaddr(&pkt, OPTION_FINGERSERVER, buf, MAX_GENERICSERVERS))
d559 1
a559 1
        if (vend_miaddr(&pkt, OPTION_IRCSERVER, buf, MAX_GENERICSERVERS))
d562 1
a562 1
        tmp = vend_string(&pkt, OPTION_TFTPSERVER, buf);
d565 1
a565 1
        tmp = vend_string(&pkt, OPTION_ACORNPRIVATE, buf);
d586 1
a586 1
    sin->sin_addr.s_addr = pkt.yiaddr;
d592 1
a592 1
       sin->sin_addr.s_addr = (netmask.s_addr & pkt.yiaddr) | ~netmask.s_addr;
d1271 67
@


4.11
log
@Fixed a single character typo (well, cut & paste) error in the previous
version : it was harmless, but prevented correct operation of the
ALT+ALT BOOTP abort during the retry wait period in whoami.c

Version 5.15. Tagged as 'Internet-5_15'
@
text
@d51 1
d196 1
d206 1
d223 1
a223 1
    if (cmd == SIOCGWHOIAMR || cmd == SIOCGWHOIAMRB)
d226 1
a226 1
    if (cmd == SIOCGWHOIAMB || cmd == SIOCGWHOIAMRB)
d231 1
a231 1
    if ((ifp->if_flags & IFF_NEED_IPADDR) == IFF_NEED_IPADDR)
d256 1
a256 1
    return (0);
d295 1
d448 1
d484 2
d580 2
d670 1
a670 1
    char *server = "", *file = "";
a677 15
    if (retry && ((ac->ac_if.if_flags & (IFF_UP | IFF_RUNNING)) != (IFF_UP | IFF_RUNNING)))
    {
      if ((ac->ac_if.if_flags & IFF_RUNNING) != IFF_RUNNING)
      {
        claim_frames(&ac->ac_if, 1);
        ac->ac_if.if_flags |= IFF_RUNNING;
        whoami_claimed_frames = TRUE;
      }
      ac->ac_if.if_flags |= IFF_UP;
    }
    else
    {
      whoami_claimed_frames = FALSE;
    }

a701 1
    pkt.options[option_index++] = OPTION_ACORNPRIVATE;
d708 1
d711 23
a733 1
    pkt.options[option_index++] = OPTION_END;
@


4.10
log
@Modified the interface flag handling logic inside of whoami.c, since
the existing logic was not consistant in its handling of the flags
IFF_UP and IFF_RUNNING - IFF_UP obviously indicates that the interface
is up ie useable, whereas IFF_RUNNING indicates that resources (in this
case FRAMES) have been claimed for the interface. This was not used
consistantly, which caused problems for the BOOTP client code.

Version 5.14. Tagged as 'Internet-5_14'
@
text
@d296 1
a296 1
	if (((cmd == SIOCGWHOIAMRB) || (cmd == SIOCGWHOIAMRB)) && left_alt_is_pressed() && right_alt_is_pressed())
@


4.9
log
@Modified flags for ATM interfaces again, since currently they internally
fake ARP, and don't work at all if they're not given the opportunity to do so.
Also modified the behaviour of the BOOTP/DHCP client code to ensure
that correct routing information is generated for the interface, and
to request and pick up an additional server name (so that this can be
used by LanManFS over IP to determine where its next stage boot server
is (an IP address isn't much good to it).

Version 5.13. Not tagged
@
text
@d15 1
d131 1
a131 1
#define BOOTPSERVERVAR       "Inet$BootServer"
d160 1
a160 1
static int whoami_if_was_down;
d228 1
a228 1
    if ((ifp->if_flags & IFF_NEED_IPADDR) != 0)
d241 2
a242 1
	if (whoami_if_was_down = TRUE)
d246 1
d296 1
a296 1
	if (cmd == SIOCGWHOIAMRB && left_alt_is_pressed() && right_alt_is_pressed())
d669 1
a669 1
    if (retry && !(ac->ac_if.if_flags & IFF_UP))
d671 2
d674 4
a677 2
        ac->ac_if.if_flags |= IFF_UP | IFF_RUNNING;
        whoami_if_was_down = TRUE;
d681 1
a681 1
      whoami_if_was_down = FALSE;
d785 1
a785 1
        if (!(ac->ac_if.if_flags & IFF_UP))
d787 2
d790 4
a793 2
            ifp->if_flags |= IFF_UP | IFF_RUNNING;
            whoami_if_was_down = TRUE;
d797 1
a797 1
          whoami_if_was_down = FALSE;
@


4.8
log
@  Added multicast filtering support to Internet module
  More boot variables recognised in BOOTP/DHCP responses.
Detail:
  net/if_module.c:
    Interprets multicast ioctl requests and construct SWI parameters
    for passing to riscos/module.c for a call to MulticastRequest SWI.
  riscos/module.c:
    Wrapper for calling above SWI.  Sets appropriate flag bit on
    DCI4 Filter SWI to indicate our support for multicast filtering
    when Inquire SWI indicated that the driver supports it too.
  build/module.h:
    Prototype for dci4_mc_request() wrapper added.
  whoami/whoami.c:
    More variables are now known to the response handler.
    Multiple IP address options are handled (useful for Inet$Resolvers)
    Interoperability workaround for Microsoft DHCP servers added.
Admin:
  Requires RiscOS/Sources/Lib/TCPIPLibs version 5.02 or later.
    (tag: TCPIPLibs-5_02 or later)
  Supporting documentation: DCI4 Functional Specification
    (Drawing number 0284,036/FS; ECO 4112)
  BOOTP client tested against Microsoft DHCP server and standard server.
  Multicast filtering tested against new EtherH driver from I-cubed.
  Multicast filtering tested against old EtherM driver to verify the
    changes do not break older non-DCI 4.04 compliant drivers.

Version 5.12. Tagged as 'Internet-5_12'
@
text
@d141 1
d537 3
d548 13
d564 1
a566 3
       sin->sin_addr.s_addr = netmask.s_addr;
       (void) in_control((struct socket *)0, SIOCSIFNETMASK, (caddr_t)&ifr, ifp);

a692 1
    pkt.options[option_index++] = OPTION_TIMEOFFSET;
a693 1
    pkt.options[option_index++] = OPTION_TIMESERVER;
d695 1
d697 2
a698 1
    pkt.options[option_index++] = OPTION_DOMAINNAME;
d700 3
a705 1
    pkt.options[option_index++] = OPTION_WWWSERVER;
a707 1
    pkt.options[option_index++] = OPTION_ACORNPRIVATE;
@


4.7
log
@Pick up much more data from a fully configured server.
Tidied the interaction with the server to comply as closely as
possible with the behaviour defined in rfc 951, 1048, 1084, 1533, 2132 etc.
so as to interact with as many servers as possible, including DHCP (where
configured to support BOOTP clients).
Also modified the frame handling behaviour so as not to release frame types
if we didn't cliam them in the first place (this really should have some
additional checks to verify that we're still talking about the same interface,
but it's unlikely to be a problem.... famous last words, eh ?
@
text
@d92 23
d149 5
d397 29
d502 2
a503 2
        in.s_addr = vend_iaddr(&pkt, OPTION_NAMESERVER);
        if (in.s_addr) _kernel_setenv(BOOTPDNSVAR, inet_ntoa(in));
d505 2
a506 2
        in.s_addr = vend_iaddr(&pkt, OPTION_TIMESERVER);
        if (in.s_addr) _kernel_setenv(BOOTPTIMESERVERVAR, inet_ntoa(in));
d511 1
a511 1
          sprintf(buf,"%d\0",tmp);
d515 2
a516 2
        in.s_addr = vend_iaddr(&pkt, OPTION_NBNSSERVERS);
        if (in.s_addr) _kernel_setenv(BOOTPNBNSVAR, inet_ntoa(in));
d518 2
a519 2
        in.s_addr = vend_iaddr(&pkt, OPTION_SMTPSERVER);
        if (in.s_addr) _kernel_setenv(BOOTPSMTPSERVERVAR, inet_ntoa(in));
d521 2
a522 2
        in.s_addr = vend_iaddr(&pkt, OPTION_POP3SERVER);
        if (in.s_addr) _kernel_setenv(BOOTPPOP3SERVERVAR, inet_ntoa(in));
d524 2
a525 2
        in.s_addr = vend_iaddr(&pkt, OPTION_NNTPSERVER);
        if (in.s_addr) _kernel_setenv(BOOTPNNTPSERVERVAR, inet_ntoa(in));
d527 2
a528 2
        in.s_addr = vend_iaddr(&pkt, OPTION_WWWSERVER);
        if (in.s_addr) _kernel_setenv(BOOTPWWWSERVERVAR, inet_ntoa(in));
d530 2
a531 2
        in.s_addr = vend_iaddr(&pkt, OPTION_FINGERSERVER);
        if (in.s_addr) _kernel_setenv(BOOTPFINGERSERVERVAR, inet_ntoa(in));
d533 2
a534 2
        in.s_addr = vend_iaddr(&pkt, OPTION_IRCSERVER);
        if (in.s_addr) _kernel_setenv(BOOTPIRCSERVERVAR, inet_ntoa(in));
d645 3
a647 1

d674 3
a677 2
    pkt.options[option_index++] = 4;
    option_index += 4;
a678 2
    pkt.options[option_index++] = 4;
    option_index += 4;
a679 2
    pkt.options[option_index++] = 4;
    option_index += 4;
a680 2
    pkt.options[option_index++] = 4;
    option_index += 4;
a681 2
    pkt.options[option_index++] = 4;
    option_index += 4;
a682 2
    pkt.options[option_index++] = 1;
    option_index += 1;
a683 2
    pkt.options[option_index++] = 1;
    option_index += 1;
a684 2
    pkt.options[option_index++] = 4;
    option_index += 4;
a685 2
    pkt.options[option_index++] = 4;
    option_index += 4;
a686 2
    pkt.options[option_index++] = 4;
    option_index += 4;
a687 2
    pkt.options[option_index++] = 4;
    option_index += 4;
a688 2
    pkt.options[option_index++] = 4;
    option_index += 4;
a689 2
    pkt.options[option_index++] = 4;
    option_index += 4;
a690 2
    pkt.options[option_index++] = 4;
    option_index += 4;
d692 2
a693 2
    pkt.options[option_index++] = 1;
    option_index += 1;
@


4.6
log
@  Added support for setting LanMan nameserver system variable.
Detail:
  whoami/whoami.c:
    Updated to include protocols/dhcp.h instead of protocols/bootp.h
    Added support for setting LanMan$NameServer if that information
    was provided by the BOOTP/DHCP server.
Admin:
  Requires RiscOS/Sources/Lib/TCPIPLibs version 5.02 or later.
    (tag: TCPIPLibs-5_02 or later)
@
text
@d107 18
a124 8
#define BOOTPSERVERVAR  "Inet$BootServer"
#define BOOTPSERVERFILE "Inet$BootFile"
#define BOOTPGATEWAYVAR "Inet$Gateway"
#define BOOTPNETMASKVAR "Inet$EtherIPMask"
#define BOOTPIPADDRVAR  "Inet$EtherIPAddr"
#define BOOTPDNSVAR     "Inet$Resolvers"
#define BOOTPHOSTVAR    "Inet$HostName"
#define BOOTPNBNSVAR	"LanMan$NameServer"
d130 1
d161 4
a164 3
int whoamiaddr = 0;
int boot_tries = 0;
int kernel_escape_seen = 0;
d171 1
d175 4
a178 2
    if (boot_tries == 0)
	boot_tries = 1;
d207 9
a215 4

	else boot_tries++;
	if_down(ifp);
	claim_frames(ifp, 0);
d232 1
a232 1
    static unsigned char timeouts[] = { 10, 10, 15, 15, 20, 30, 60 };
d360 1
a360 1
        strncpy(buf, (char *)cp, len);
d426 1
a426 1
     * information from the vendor data.
d430 1
a430 1
        static char buf[OPTIONS_MAX];
d435 4
d441 1
d444 1
d447 11
d460 21
d494 3
d587 4
d596 5
d605 2
a606 2
    pkt.htype = 1;
    pkt.hlen = 6;
d608 1
a608 1
    pkt.secs = htons(retry);
d613 49
d732 5
@


4.5
log
@Module version updated to 5.10
System variable "Inet$EtherIPAddr" is now set by BOOTP code to assist
in using the machine's local IP address in boot scripts etc.
@
text
@d85 1
a85 1
#include "protocols/bootp.h"
d114 1
d293 1
a293 1
    return ntohl(vend_extractaddr(pkt->vend)) == VENDOR_COOKIE;
d303 1
a303 1
    u_char *cp = pkt->vend + 4;     /* Skip magic cookie. */
d306 1
a306 1
    while ((c = *cp++) != VENDOR_END)
d308 1
a308 1
        if (c == VENDOR_PAD) continue;
d410 1
a410 1
        char buf[VEND_MAX];
d413 1
a413 1
        tmp = vend_string(&pkt, VENDOR_HOSTNAME, buf);
d415 1
a415 1
        netmask.s_addr = vend_iaddr(&pkt, VENDOR_NETMASK);
d417 1
a417 1
        in.s_addr = vend_iaddr(&pkt, VENDOR_GATEWAY);
d419 1
a419 1
        in.s_addr = vend_iaddr(&pkt, VENDOR_NAMESERVER);
d421 2
@


4.4
log
@  BOOTP vendor specific data cookie validation fixed.
  BOOTP now sets the netmask as per response from BOOTP server.
  Module version incremented to 5.09
Detail:
  whoami/c/whoami:vend_verify(): ntohl the address so comparison works
    and the vendor-specific data is examined.  This includes netmask
    setting, DNS resolver settings, gateway address, hostname.
  whoami/c/whoami:bootp_udp_input(): catch netmask if it was supplied
    and use it to configure the interface netmask instead of relying on
    the default for the interface IP address class and/or InetSetup.
  build/cmhg/InetHdr:riscos/c/socket_swi: Version number increment.
Admin:
  Clean build; tested on A7000+: disabled netmask setting, Inet$Resolvers,
  and Inet$HostName in Choices:Internet.Startup; booted A7000+; verified
  variable settings were correct and interface was configured as per data
  in server's bootptab configuration file.

Version 5.09. Tagged as Internet-5_09
@
text
@d111 1
d396 3
@


4.3
log
@BOOTP was a bit broken
@
text
@d172 1
a172 1
    
d180 1
a180 1
    
d291 1
a291 1
    return vend_extractaddr(pkt->vend) == VENDOR_COOKIE;
d360 2
a361 1
    
d365 1
d410 2
a411 2
        in.s_addr = vend_iaddr(&pkt, VENDOR_NETMASK);
        if (in.s_addr) _kernel_setenv(BOOTPNETMASKVAR, inet_ntoa(in));
d425 5
@


4.2
log
@Version Spinner_B7 taken
@
text
@d172 1
a172 1

d180 1
d291 1
a291 1
    return *(u_long *)pkt->vend == VENDOR_COOKIE;
d360 3
d513 1
a513 1
    if (retry)
d595 5
a599 2
        claim_frames(ifp, 1);
        ifp->if_flags |= IFF_UP | IFF_RUNNING;
@


4.1
log
@Initial revision
@
text
@d15 4
a18 1
/* -*-C-*-
d20 3
a22 2
 * $Header: /ax/networking:Internet/whoami/whoami.c:networking  1.3  $
 * $Source: /ax/networking:Internet/whoami/whoami.c: $
d24 1
a24 1
 * Functions to implement bootp and revarp
d26 6
a31 1
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
a32 1
 * $Log:	whoami.c,v $
d36 1
a36 1
 * 
d42 1
a42 1
 * 
d44 1
a44 1
 * 
d47 1
a47 1
 * 
d49 1
d53 1
d62 2
a63 1
#include "sys/bootp.h"
d69 1
d71 1
a72 2
#include "netinet/in_systm.h"
#include "netinet/ip.h"
d81 6
d88 18
d107 10
a116 2
char *inet_ntoa();
void revarp_myaddr();
a117 2
#define BOOTPSERVERVAR "Inet$BootServer"
#define BOOTPSERVERFILE "Inet$BootFile"
d119 3
a121 1
int if_whoamimns(struct ifnet *ifp)
d128 5
a132 1
if_askwhoiam(struct ifnet *ifp, int need, void (*proc)(), int flag)
d152 4
a155 1
int if_whoamiaddr(struct ifnet *ifp, int cmd)
a156 3
    void bootwakeup();
    int bootp_myaddr();

d171 1
a171 1
    timeout(bootwakeup, (caddr_t)0, backoff(boot_tries));
d186 1
a186 1
	    untimeout(bootwakeup, (caddr_t)0);
d192 1
d196 1
a196 1
    untimeout(bootwakeup, (caddr_t)0);
d205 3
a207 1
int backoff(int retry)
d213 1
a213 1
    if( t >= sizeof(timeouts)/sizeof(timeouts[0]) )
d225 2
a226 1
int getrand(void)
d228 1
a228 3
    _kernel_oserror *e;
    _kernel_swi_regs rin, rout;
    int rand();
d230 1
a230 2
    e = _kernel_swi(XOS_Bit | OS_ReadMonotonicTime, &rin, &rout);
    return (rout.r[0] % rand());
d233 3
a235 1
bootsleep(int cmd)
d241 1
a241 2
	if (cmd == SIOCGWHOIAMRB &&
	    left_alt_is_pressed() && right_alt_is_pressed())
d249 1
a249 1
static void bootwakeup(void)
d258 3
a260 1
int if_whoamimask(struct ifnet *ifp)
a261 2
    void request_netmask(), wakeup();

a262 1
    timeout(wakeup, (caddr_t)&whoamimask, MASK_MAX_WAIT);
d264 1
a264 1
    sleep((caddr_t)&whoamimask, PZERO+1);
a270 2
    else
	untimeout(wakeup, (caddr_t)&whoamimask);
d275 8
a282 1
static	u_long	BOOTPclient = 68;
d284 5
a288 1
int in_bootpresponse(u_short port)
d290 1
a290 1
    return ((u_long)port == BOOTPclient ? 1 : 0);
d293 51
a343 1
static u_long BOOTPserver = 67;
d348 3
a350 1
bootp_udp_input(struct ifnet *ifp, struct mbuf *m)
d353 1
a353 4
    int len = sizeof(pkt);
#ifdef OldCode
    u_char *cp = (u_char *)&pkt;
#endif
d356 1
d358 1
d360 1
a360 1
    bzero((caddr_t)&pkt, sizeof(pkt));
d362 4
a365 2
#ifdef OldCode
    while (len > 0 && m)
d367 3
a369 5
	int i = MIN(len, m->m_len);
	bcopy(mtod(m, caddr_t), (caddr_t)cp, i);
	cp += i;
	len -= i;
	m = m->m_next;
a370 2
#else
    (void)EXPORT(m, len, &pkt);
d382 1
a382 1
    if( bcmp(ac->ac_enaddr, pkt.chaddr, pkt.hlen) )
d385 28
a412 3
    setriscosvar(BOOTPSERVERVAR, inet_ntoa(pkt.siaddr));
    setriscosvar(BOOTPSERVERFILE, pkt.file);
    bzero((caddr_t)&ifr, sizeof(ifr));
d415 1
d419 1
a419 1
    bootwakeup();
d430 4
a433 1
bootp_ip_output(struct mbuf *m, struct ifnet *ifp)
a436 1
    int hlen = sizeof(struct ip);
d442 1
a442 1
    ip->ip_hl = hlen >> 2;
d445 1
d451 2
a452 2
    ip->ip_sum = in_cksum(m, hlen);
    return ((*ifp->if_output)(ifp, m, (struct sockaddr *)&dst));
a454 2
extern int udp_ttl;

d459 1
a459 3
bootp_udp_output(struct mbuf *md, struct ifnet *ifp,
		 u_long laddr, short lport,
		 u_long faddr, short fport)
a460 1
    register struct mbuf *m;
d462 1
a462 1
    register int len = 0;
d465 1
a465 2
     * Calculate data length and get a mbuf
     * for UDP and IP headers.
a466 2
    for (m = md; m; m = m->m_next)
	len += m->m_len;
d468 1
a468 2
#ifdef OldCode
    MGET(m, M_DONTWAIT, MT_HEADER);
a470 6
	m_freem(md);
	return (ENOBUFS);
    }
#else
    if( (m = ALLOC_S(MINCONTIG, NULL)) == NULL )
    {
d472 2
a473 2
	if( DODEBUG(DBGMMAN) )
	    Printf("bootp_udp_output: ALLOC_S failed\n");
d475 1
a475 2
	FREEM(md);
	return(ENOBUFS);
a477 3
    m->m_type = MT_HEADER;
#endif

a481 3
    m->m_off = MAXOFF(m) - sizeof (struct udpiphdr);
    m->m_len = sizeof (struct udpiphdr);
    m->m_next = md;
d495 1
a495 1
    ((struct ip *)ui)->ip_ttl = udp_ttl;
d500 4
a503 1
int bootp_myaddr(struct arpcom *ac, int retry)
d505 1
a505 1
    struct mbuf *m0;
a506 2
    int len;
    caddr_t cp;
d509 5
a513 2
#ifdef OldCode
    struct mbuf *m;
d515 1
a515 4
    if ((m0 = m = m_get(M_DONTWAIT, MT_DATA)) == NULL)
	return (ENOBUFS);

    bzero((char *)&pkt, sizeof(pkt));
d519 1
a519 1
    pkt.xid = time(0);
d521 3
a523 13
    bcopy((caddr_t)&ac->ac_enaddr[0], &pkt.chaddr[0], pkt.hlen);
    strcpy(&pkt.sname[0], server);  /* If known */
    strcpy(&pkt.file[0], file);		    /* If known */
    len = sizeof(pkt);
    cp = (caddr_t)&pkt;

    while (len > 0)
    {
	int i = MIN(len, OLDMLEN);
	bcopy(cp, mtod(m, caddr_t), i);
	m->m_len = i;
	cp += i;
	len -= i;
d525 2
a526 17
	if (len > 0)
	{
	    struct mbuf *mnew = m_get(M_DONTWAIT, MT_DATA);
	    if (mnew == 0)
	    {
		m_freem(m0);
		return (ENOBUFS);
	    }

	    m->m_next = mnew;
	    m = mnew;
	    m->m_len = 0;
	}
    }
#else
    cp = (caddr_t)&pkt;
    bzero(cp, sizeof(pkt));
d528 1
a528 11
    pkt.op = BOOTREQUEST;
    pkt.htype = 1;
    pkt.hlen = 6;
    pkt.xid = time(0);
    pkt.secs = htons(retry);
    bcopy((caddr_t)&ac->ac_enaddr[0], &pkt.chaddr[0], pkt.hlen);
    strcpy(&pkt.sname[0], server);  /* If known */
    strcpy(&pkt.file[0], file);		    /* If known */
    len = sizeof(pkt);

    if( (m0 = ALLOC(len, cp)) == NULL )
d530 2
a531 5
#ifdef DEBUG
	if( DODEBUG(DBGMMAN) )
	    Printf("bootp_myaddr: ALLOC failed\n");
#endif
	return(ENOBUFS);
d533 4
a536 2
    m0->m_type = MT_DATA;
#endif
d546 8
a553 7
static int revarp = 1;

void revarp_myaddr(struct arpcom *ac, int flag)
{
    register struct ifnet *ifp = &ac->ac_if;
    register struct sockaddr_in *sin;
    struct ifreq ifr;
d567 1
d573 1
a573 1
	bzero((caddr_t)&ifr, sizeof(ifr));
d576 2
a577 1
	sin->sin_addr = in_makeaddr(INADDR_ANY, (u_long) 0xFFFFFF );
d581 1
a581 2
	if( ac->ac_ipaddr.s_addr && \
	   ac->ac_ipaddr.s_addr != sin->sin_addr.s_addr )
d590 4
d596 1
a596 2
#ifdef OldCode
    if ((m = m_get(M_DONTWAIT, MT_DATA)) == NULL)
a597 9
#else
    if( (m = ALLOC_S(MINCONTIG, NULL)) == NULL )
    {
#ifdef DEBUG
	if( DODEBUG(DBGMMAN) )
	    Printf("revarp_myaddr: ALLOC_S failed\n");
#endif
	return;
    }
d599 3
a601 2
    m->m_type = MT_DATA;
#endif
d604 1
a604 1
    m->m_off = MAXOFF(m) - m->m_len;
d606 1
a606 1
    bzero((caddr_t)ea, sizeof (*ea));
d609 1
d611 2
a612 4
    bcopy((caddr_t)etherbroadcastaddr, (caddr_t)eh->ether_dhost,
	  sizeof(eh->ether_dhost));
    bcopy((caddr_t)&ac->ac_enaddr[0], (caddr_t)eh->ether_shost,
	  sizeof(eh->ether_shost));
d621 2
a622 2
    bcopy((caddr_t)&ac->ac_enaddr[0],(caddr_t)ea->arp_sha,sizeof(ea->arp_sha));
    bcopy((caddr_t)&ac->ac_enaddr[0],(caddr_t)ea->arp_tha,sizeof(ea->arp_tha));
d624 1
a624 1
    if( DODEBUG(DBGADDRSRCH) )
d626 1
a626 1
	int err = (ifp->if_output)(ifp, m, &sa);
d629 1
a629 1
	       ctosym(ifp->if_output), err);
d633 1
a633 1
    (*ifp->if_output)(ifp, m, &sa);
d636 1
d645 50
d702 3
a704 1
revarpinput(struct arpcom *ac, struct mbuf *m)
d707 1
d709 1
d711 2
a712 1
    struct ifnet *ifp = &ac->ac_if;
d717 2
a718 1
    u_long serverip, thisip;
d720 3
a722 1
    IF_ADJ(m);
d724 5
a728 1
    if (m->m_len < sizeof *ea)
d730 1
d732 5
a736 1
    if (ac->ac_if.if_flags & IFF_NOARP)
d738 1
d740 5
a744 4
    if (ntohs(ea->arp_pro) != ETHERTYPE_IP)
	goto out;

    if(!revarp)
d746 1
d751 4
d756 3
a758 1
	 * don't bother, unless we are actively looking for an address
d760 43
a802 2
	if( (ifp->if_flags & IFF_NEED_IPADDR) == 0 )
	    goto out;
d804 1
a804 1
	if (bcmp((caddr_t)ea->arp_tha, (caddr_t)&ac->ac_enaddr[0], 6) == 0)
d806 6
a811 3
	    bcopy((caddr_t)ea->arp_tpa, (caddr_t)&ac->ac_ipaddr,
		  sizeof(ac->ac_ipaddr));
	    wakeup((caddr_t)&revarp);
a813 13
	bzero((caddr_t)&ifr, sizeof(ifr));
	sin = (struct sockaddr_in *)&ifr.ifr_addr;
	sin->sin_family = AF_INET;
	sin->sin_addr = ac->ac_ipaddr;
	(void) in_control((struct socket *)0, SIOCSIFADDR, (caddr_t)&ifr, ifp);
	ifp->if_flags &= ~IFF_NEED_IPADDR;

	bcopy((caddr_t)ea->arp_spa, &serverip, sizeof(serverip));
	bcopy((caddr_t)ea->arp_tpa, &thisip, sizeof(thisip));
	revarp_event(serverip, thisip);
	setriscosvar(BOOTPSERVERVAR, inet_ntoa(serverip));
	bootwakeup();

d817 4
d825 1
a825 1
	if( (ifp->if_flags & IFF_NEED_IPADDR) != 0 )
d828 1
a828 8
	for (at = arptab ; at < &arptab[ARPTAB_SIZE] ; at++)
	{
	    if( at->at_flags & ATF_PERM && !bcmp((caddr_t)at->at_enaddr,
						 (caddr_t)ea->arp_tha, 6) )
		break;
	}

	if (at < &arptab[ARPTAB_SIZE])
d830 3
a832 11
	    /* found a match, send it back */
	    eh = (struct ether_header *)sa.sa_data;
	    bcopy(ea->arp_sha, eh->ether_dhost,
		  sizeof(ea->arp_sha));
	    bcopy((caddr_t)(&at->at_iaddr), ea->arp_tpa,
		  sizeof(at->at_iaddr));

	    /* search for interface address to use */
	    for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
	    {
		if (ifa->ifa_ifp == ifp)
d834 10
a843 3
		    bcopy((caddr_t)&((struct sockaddr_in *)&ifa->ifa_addr)->sin_addr,
			  ea->arp_spa, sizeof(ea->arp_spa));
		    break;
d845 9
a853 1
	    }
d855 6
a860 12
	    if (ifa == 0)
		break;

	    bcopy((caddr_t)ac->ac_enaddr, (caddr_t)ea->arp_sha,
		  sizeof(ea->arp_sha));
	    bcopy((caddr_t)ac->ac_enaddr, (caddr_t)eh->ether_shost,
		  sizeof(ea->arp_sha));
	    eh->ether_type = ETHERTYPE_REVARP;
	    ea->arp_op = htons(REVARP_REPLY);
	    sa.sa_family = AF_UNSPEC;
	    (*ac->ac_if.if_output)(&ac->ac_if, m, &sa);
	    return;
d866 4
a873 1
#ifdef OldCode
a874 3
#else
    FREEM(m);
#endif
a877 14
#define Internet_Event	 19
#define RarpReply	  4

revarp_event(u_long serverip, u_long thisip)
{
    _kernel_swi_regs r;

    r.r[0] = Internet_Event;
    r.r[1] = RarpReply;
    r.r[2] = (int)serverip;
    r.r[3] = (int)thisip;
    (void)_kernel_swi(XOS_Bit | OS_GenerateEvent, &r, &r);
}

d899 3
a901 1
void revarp_broadcastclientaddrs(struct arpcom *ac)
a909 1
#ifdef OldCode
a911 6
#else
    if( (m = ALLOC_C(MINCONTIG, NULL)) == NULL )
	return;

    m->m_type = MT_DATA;
#endif
d914 1
a914 1
    m->m_off = MAXOFF(m) - m->m_len;
d917 1
a917 3
#ifdef OldCode
    memset ((caddr_t)ea, 0, sizeof (*ea));
#endif
d920 1
d922 2
a923 4
    memcpy((caddr_t)eh->ether_dhost, (caddr_t)etherbroadcastaddr,
	   sizeof(eh->ether_dhost));
    memcpy((caddr_t)eh->ether_shost, (caddr_t)&ac->ac_enaddr[0],
	   sizeof(eh->ether_shost));
d927 2
a928 2
    ea->arp_hln = sizeof(ea->arp_sha);	    /* hardware address length */
    ea->arp_pln = sizeof(ea->arp_spa);	    /* protocol address length */
d930 2
a931 4
    memcpy((caddr_t)ea->arp_sha, (caddr_t)&ac->ac_enaddr[0],
	   sizeof(ea->arp_sha));
    memcpy((caddr_t)ea->arp_tha, (caddr_t)&ac->ac_enaddr[0],
	   sizeof(ea->arp_tha));
d937 2
a938 6
	    memcpy(ea->arp_spa, 
		   (caddr_t)&((struct sockaddr_in *)&ifa->ifa_addr)->sin_addr,
		   sizeof(ea->arp_spa));
	    memcpy(ea->arp_tpa, 
		   (caddr_t)&((struct sockaddr_in *)&ifa->ifa_addr)->sin_addr,
		   sizeof(ea->arp_tpa));
a945 3
    {

#ifdef OldCode
a946 4
#else
        FREEM(m);
#endif
    }
d948 1
a948 1
	(*ifp->if_output)(ifp, m, &sa);
d953 2
d959 4
a962 1
void request_netmask(struct ifnet *ifp, int flag)
d965 1
d968 12
a979 10
#ifdef OldCode
    if ((m  = m_get(M_DONTWAIT, MT_HEADER)) == NULL)
	return;
#else
    if( (m = ALLOC_S(MINCONTIG, NULL)) == NULL )
    {
#ifdef DEBUG
	if( DODEBUG(DBGMMAN) )
	    Printf("request_netmask: ALLOC_s failed\n");
#endif
a980 3
    }
    m->m_type = MT_HEADER;
#endif
d986 1
a986 1
    m->m_off = MAXOFF(m) - sizeof (struct ip);
d988 2
d1001 1
a1001 1
    ip->ip_src = in_makeaddr(in_netof(ip->ip_dst), INADDR_BROADCAST);
d1003 1
a1003 1
    icmp_error(ip, ICMP_MASKREQ, 0, ifp);
d1007 3
a1009 20
#define satosin(sa) ((struct sockaddr_in *)(sa))

setriscosvar(char *var, char *str)
{
    _kernel_oserror *e;
    _kernel_swi_regs rin, rout;

    rin.r[0] = (int)var;
    rin.r[1] = (int)str;
    rin.r[2] = strlen(str)+1;

    if (rin.r[2] <= 1)
	return;

    rin.r[3] = 0;
    rin.r[4] = 0;
    e = _kernel_swi(XOS_Bit | OS_SetVarVal, &rin, &rout);
}

char *inet_ntoa(struct in_addr in)
d1024 2
a1025 1
int left_alt_is_pressed(void)
d1027 1
a1027 7
    _kernel_swi_regs rin, rout;
    _kernel_oserror *e;

    rin.r[0] = KEYSCAN;
    rin.r[1] = LEFTALT | 0x80;
    e = _kernel_swi(XOS_Bit | OS_Byte, &rin, &rout);
    return (rout.r[1]);
d1030 2
a1031 1
int right_alt_is_pressed()
d1033 1
a1033 7
    _kernel_swi_regs rin, rout;
    _kernel_oserror *e;

    rin.r[0] = KEYSCAN;
    rin.r[1] = RIGHTALT | 0x80;
    e = _kernel_swi(XOS_Bit | OS_Byte, &rin, &rout);
    return (rout.r[1]);
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d15 5
a19 1
/*
d24 1
a24 13
 * :RCS Log discontinued:
 * Revision 1.5  95/11/14  12:08:41  pwain
 * Check in for jdavies@@csd
 *
 * Added use of AUN_state flag to control AUN REVARP behaviour.
 *
 * Revision 1.4  95/07/06  08:50:39  kwelton
 * Fixed the case for REVARP_REPLY in revarpinput() - only bother setting
 * the interface address if actively looking for an address, and the reply
 * is to a request from the local machine; *always* raise an internet event
 * for the revarp reply, as this is used (and needed) by the Net module when
 * talking to Gateway machines.
 *
d28 1
a28 1
 *
d34 1
a34 1
 *
d36 1
a36 1
 *
d39 1
a39 1
 *
a40 1
#include <string.h>
a43 1
#include "sys/types.h"
d52 1
a52 2
#include "sys/kernel.h"
#include "sys/proc.h"
d58 2
a60 1
#include "netinet/in_var.h"
a61 1
#include "netinet/in_pcb.h"
d70 1
a70 3
#include "arpa/inet.h"

#include "machine/in_cksum.h"
d72 2
a73 21
#include "protocols/bootp.h"

#include "debug.h"
#include "module.h"
#include "swiveneers.h"
#include "whoami.h"

struct	ifqueue revarpintrq = {0, 0, 0, 10};

char *inet_ntoa(struct in_addr);
static void bootwakeup(void *arg);
static void revarp_myaddr(struct ifnet *, int);
static void revarpinput(struct mbuf *m);
static void if_askwhoiam(struct ifnet *ifp, int need,
                         void (*proc)(struct ifnet *, int), int flag);
static void bootsleep(int cmd);
static int bootp_myaddr(struct arpcom *ac, int retry);
static void request_netmask(struct ifnet *ifp, int flag);
static int backoff(int retry);
static int getrand(void);
static int left_alt_is_pressed(void), right_alt_is_pressed(void);
d75 1
a75 1
#define BOOTPSERVERVAR  "Inet$BootServer"
a76 8
#define BOOTPGATEWAYVAR "Inet$Gateway"
#define BOOTPNETMASKVAR "Inet$EtherIPMask"
#define BOOTPDNSVAR     "Inet$Resolvers"
#define BOOTPHOSTVAR    "Inet$HostName"

#define Internet_Event	 19
#define RarpReply	  4
#define RarpRequest	  5
d78 1
a78 4

int
if_whoamimns(ifp)
    struct ifnet *ifp;
d85 1
a85 5
static void
if_askwhoiam(ifp, need, proc, flag)
    struct ifnet *ifp;
    int need, flag;
    void (*proc)(struct ifnet *, int);
d105 1
a105 4
int
if_whoamiaddr(ifp, cmd)
    struct ifnet *ifp;
    int cmd;
d107 3
d124 1
a124 1
    timeout(bootwakeup, 0, backoff(boot_tries));
d139 1
a139 1
	    untimeout(bootwakeup, 0);
a144 1
	claim_frames(ifp, 0);
d148 1
a148 1
    untimeout(bootwakeup, 0);
d157 1
a157 3
static int
backoff(retry)
    int retry;
d163 1
a163 1
    if (t >= sizeof(timeouts)/sizeof(timeouts[0]))
d175 1
a175 2
static int
getrand()
d177 3
a179 1
    int rand(void);
d181 2
a182 1
    return ((u_int)os_read_monotonic_time() % rand());
d185 1
a185 3
static void
bootsleep(cmd)
    int cmd;
d191 2
a192 1
	if (cmd == SIOCGWHOIAMRB && left_alt_is_pressed() && right_alt_is_pressed())
d200 1
a200 1
static void bootwakeup(void *arg)
d209 1
a209 3
int
if_whoamimask(ifp)
    struct ifnet *ifp;
d211 2
d214 1
d216 1
a216 1
    tsleep(&whoamimask, PSOCK | PCATCH, "whoamimask", MASK_MAX_WAIT, 0);
d223 2
d229 1
a229 8
/*
 * Extract an IP address from 4 unaligned bytes.
 */
static u_long
vend_extractaddr(u_char *cp)
{
    return *cp + (*(cp+1) << 8) + (*(cp+2) << 16) + (*(cp+3) << 24);
}
d231 1
a231 5
/* Verify that vendor info is compliant with RFC-1048
 * by checking magic cookie.
 */
static int
vend_verify(BOOTP *pkt)
d233 1
a233 1
    return *(u_long *)pkt->vend == VENDOR_COOKIE;
d236 1
a236 51
/*
 * Find code in vendor specific information
 * (returns pointer to length byte or NULL).
 */
static u_char *
vend_find_code(BOOTP *pkt, u_char code)
{
    u_char *cp = pkt->vend + 4;     /* Skip magic cookie. */
    u_char c;

    while ((c = *cp++) != VENDOR_END)
    {
        if (c == VENDOR_PAD) continue;
        if (c == code) return cp;
        cp += *cp + 1;
    }

    return NULL;
}

/*
 * Extract an IP address specified by data code from vendor specific data
 * (returns netmask or 0).
 */
static u_long
vend_iaddr(BOOTP *pkt, u_char code)
{
    u_char *cp = vend_find_code(pkt, code);

    return (cp++ != NULL) ? vend_extractaddr(cp) : 0;
}

/*
 * Extract a string from the vendor specific data
 * (returns length of string)
 */
static int
vend_string(BOOTP *pkt, u_char code, char *buf)
{
    u_char *cp = vend_find_code(pkt, code);

    if (cp != NULL)
    {
        int len = (int)*cp++;
        strncpy(buf, (char *)cp, len);
        buf[len] = '\0';
        return len;
    }

    return 0;
}
d241 1
a241 3
void
bootp_udp_input(m)
    struct mbuf *m;
d244 4
a247 1
    int len = sizeof pkt;
a249 1
    struct ifnet *ifp = m->m_pkthdr.rcvif;
a250 1
    struct in_addr in;
d252 1
a252 1
    memset(&pkt, 0, sizeof(pkt));
d254 2
a255 4
    (void)EXPORT(m, len, &pkt);

#ifdef DEBUG
    if (DODEBUG(DBGADDRSRCH))
d257 5
a261 3
        Printf("BOOTP response received\nac=%p, m=%p\n"
               "ac->ac_enaddr=%s, ", ac, m, ether_sprintf(ac->ac_enaddr));
        Printf("pkt.chaddr=%s, pkt.hlen=%d\n", ether_sprintf(pkt.chaddr), pkt.hlen);
d263 2
d276 1
a276 1
    if (memcmp(ac->ac_enaddr, pkt.chaddr, pkt.hlen))
d279 3
a281 28
#ifdef DEBUG
    if (DODEBUG(DBGADDRSRCH))
        Printf("Got BOOTP response: myaddr = %x\n", pkt.yiaddr);
#endif

    in.s_addr = pkt.siaddr;
    _kernel_setenv(BOOTPSERVERVAR, inet_ntoa(in));
    _kernel_setenv(BOOTPSERVERFILE, (char *) pkt.file);

    /* If this packet is RFC-1048 compliant then extract any pertinent
     * information from the vendor data.
     */
    if (vend_verify(&pkt))
    {
        char buf[VEND_MAX];
        u_long tmp;

        tmp = vend_string(&pkt, VENDOR_HOSTNAME, buf);
        if (tmp) _kernel_setenv(BOOTPHOSTVAR, buf);
        in.s_addr = vend_iaddr(&pkt, VENDOR_NETMASK);
        if (in.s_addr) _kernel_setenv(BOOTPNETMASKVAR, inet_ntoa(in));
        in.s_addr = vend_iaddr(&pkt, VENDOR_GATEWAY);
        if (in.s_addr) _kernel_setenv(BOOTPGATEWAYVAR, inet_ntoa(in));
        in.s_addr = vend_iaddr(&pkt, VENDOR_NAMESERVER);
        if (in.s_addr) _kernel_setenv(BOOTPDNSVAR, inet_ntoa(in));
    }

    memset(&ifr, 0, sizeof ifr);
a283 1
    sin->sin_len = sizeof *sin;
d287 1
a287 1
    bootwakeup(0);
d298 1
a298 4
static int
bootp_ip_output(m, ifp)
    struct mbuf *m;
    struct ifnet *ifp;
d302 1
d308 1
a308 1
    ip->ip_hl = sizeof(struct ip) >> 2;
a310 1
    dst.sin_len = sizeof dst;
d316 2
a317 2
    ip->ip_sum = in_cksum_hdr(ip);
    return ((*ifp->if_output)(ifp, m, (struct sockaddr *)&dst, NULL));
d320 2
d326 3
a328 1
static int bootp_udp_output(register struct mbuf *m, struct ifnet *ifp, u_long laddr, short lport, u_long faddr, short fport)
d330 1
d332 1
a332 1
    register int len = m->m_pkthdr.len;
d335 2
a336 1
     * get a mbuf for UDP and IP headers.
d338 2
d341 2
a342 1
    M_PREPEND(m, sizeof (struct udpiphdr), M_DONTWAIT);
d345 6
d352 2
a353 2
	if (DODEBUG(DBGMMAN))
	    Printf("bootp_udp_output: M_PREPEND failed\n");
d355 2
a356 1
	return (ENOBUFS);
d359 3
d366 3
d382 1
a382 1
    ((struct ip *)ui)->ip_ttl = ip_defttl;
d387 1
a387 4
static int
bootp_myaddr(ac, retry)
    struct arpcom *ac;
    int retry;
d389 1
a389 1
    struct mbuf *m0, *m;
d391 2
d395 39
a433 4
    if (retry)
    {
        claim_frames(&ac->ac_if, 1);
        ac->ac_if.if_flags |= IFF_UP | IFF_RUNNING;
d435 3
a438 1
    memset(&pkt, 0, sizeof pkt);
d442 1
a442 1
    pkt.xid = time.tv_sec;
d444 4
a447 3
    memcpy(pkt.chaddr, ac->ac_enaddr, pkt.hlen);
    strcpy((char *)pkt.sname, server);  /* If known */
    strcpy((char *)pkt.file, file);		    /* If known */
d449 1
a449 4
    if ((m0 = m = ALLOC(sizeof pkt, &pkt)) == NULL)
	return (ENOBUFS);

    while (m)
d451 5
a455 2
        m->m_type = MT_DATA;
        m = m->m_next;
d457 2
a458 4

    m0->m_pkthdr.len = sizeof pkt;
    m0->m_pkthdr.rcvif = 0;
    m0->m_flags = M_PKTHDR | M_BCAST;
d468 7
a474 8
static void
revarp_myaddr(ifp, flag)
    register struct ifnet *ifp;
    int flag;
{
    struct arpcom *ac = (struct arpcom *) ifp;
    /*register struct sockaddr_in *sin;*/
    /*struct ifreq ifr;*/
a487 1
#if 0
d493 1
a493 1
	memset(&ifr, 0, sizeof ifr);
d496 1
a496 2
	sin->sin_len = sizeof(*sin);
	sin->sin_addr.s_addr = htonl(0x00FFFFFF);
d500 2
a501 1
	if (ac->ac_ipaddr.s_addr && ac->ac_ipaddr.s_addr != sin->sin_addr.s_addr)
d510 5
d516 5
a520 2
        claim_frames(ifp, 1);
        ifp->if_flags |= IFF_UP | IFF_RUNNING;
d522 1
d525 2
a526 6
    if ((m = m_gethdr(M_DONTWAIT, MT_DATA)) == NULL)
	return;

    m->m_pkthdr.len = sizeof(struct ether_arp);
    m->m_pkthdr.rcvif = 0;
    m->m_flags |= M_BCAST;
d529 1
a529 1
    MH_ALIGN(m, sizeof(struct ether_arp));
d531 1
a531 1
    memset(ea, 0, sizeof *ea);
a533 1
    sa.sa_len = 16;
d535 4
a538 2
    memcpy(eh->ether_dhost, etherbroadcastaddr, sizeof eh->ether_dhost);
    memcpy(eh->ether_shost, ac->ac_enaddr, sizeof eh->ether_shost);
d547 2
a548 2
    memcpy(ea->arp_sha, ac->ac_enaddr, sizeof ea->arp_sha);
    memcpy(ea->arp_tha, ac->ac_enaddr, sizeof ea->arp_tha);
d550 1
a550 1
    if (DODEBUG(DBGADDRSRCH))
d552 1
a552 1
	int err = (ifp->if_output)(ifp, m, &sa, NULL);
d555 1
a555 1
	       /*ctosym*/(ifp->if_output), err);
d559 1
a559 1
    (*ifp->if_output)(ifp, m, &sa, NULL);
a561 1
#ifdef NotYet
a569 50
#endif

/*
 * Common length and type checks are done here,
 * then the protocol-specific routine is called.
 */
void
revarpintr(void)
{
	register struct mbuf *m;
	register struct arphdr *ar;
	int s;

#ifdef DEBUG
        Printf("revarpintr\n");
#endif
	while (revarpintrq.ifq_head) {
		s = splimp();
		IF_DEQUEUE(&revarpintrq, m);
		splx(s);
		if (m == 0 || (m->m_flags & M_PKTHDR) == 0) {
			panic("revarpintr");
			return;
		}
#ifdef DEBUG
                if (DODEBUG(DBGADDRSRCH))
                    Printf("got a REVARP packet\n");
#endif
		if (m->m_len >= sizeof(struct arphdr) &&
		    (ar = mtod(m, struct arphdr *)) &&
		    ntohs(ar->ar_hrd) == ARPHRD_ETHER &&
		    m->m_len >=
		      sizeof(struct arphdr) + 2 * ar->ar_hln + 2 * ar->ar_pln)
#ifdef DEBUG
                            if (DODEBUG(DBGADDRSRCH))
                                 Printf("Seems valid\n");
#endif
			    switch (ntohs(ar->ar_pro)) {

			    case ETHERTYPE_IP:
#ifdef DEBUG
                                    if (DODEBUG(DBGADDRSRCH))
                                            Printf("Is IP\n");
#endif
				    revarpinput(m);
				    continue;
			    }
		m_freem(m);
	}
}
d577 1
a577 3
static void
revarpinput(m)
    struct mbuf *m;
a579 1
#ifdef NotYet
a580 1
#endif
d582 1
a582 2
    struct ifnet *ifp = m->m_pkthdr.rcvif;
    struct arpcom *ac = (struct arpcom *) ifp;
d587 1
a587 2
    u_long thisip;
    struct in_addr serverip;
d589 1
a589 3
#ifdef DEBUG
    Printf("revarpinput(ac=%x, m=%x)\n", ac, m);
#endif
d591 4
a594 5
    if (m->m_len < sizeof *ea) {
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("Too short\n");
#endif
a595 1
    }
d597 1
a597 5
    if (ac->ac_if.if_flags & IFF_NOARP) {
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("No ARP\n");
#endif
a598 1
    }
d600 1
a600 5
    if (ntohs(ea->arp_pro) != ETHERTYPE_IP) {
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("Not IP: type=%d\n", ntohs(ea->arp_pro));
#endif
a601 1
    }
a605 4
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("REVARP_REPLY\n");
#endif
d607 1
a607 3
	 * don't bother, unless we are actively looking for an
	 * address, otherwise test whether this is a reply to a packet
	 * sent from local machine, by comparing hardware addresses
d609 4
a612 2
	if ((ifp->if_flags & IFF_NEED_IPADDR) &&
	    memcmp(ea->arp_tha, ac->ac_enaddr, 6) == 0)
d614 3
a616 39
#ifdef DEBUG
            if (DODEBUG(DBGARP))
                Printf("It's a reply for us\n");
#endif
	    /*
	     * this duplicates an action taken within the in_control()
	     * call to set the interface address.
	     */
	    memcpy(&ac->ac_ipaddr, ea->arp_tpa, sizeof ac->ac_ipaddr);
	    memcpy(&serverip, ea->arp_spa, sizeof serverip);

	    /*
	     * prepare for, and make a call to in_control() to set
	     * the interface address from the reply in the packet
	     */
	    memset(&ifr, 0, sizeof ifr);
	    sin = (struct sockaddr_in *)&ifr.ifr_addr;
	    sin->sin_family = AF_INET;
	    sin->sin_len = sizeof *sin;
	    sin->sin_addr = ac->ac_ipaddr;
	    (void)in_control((struct socket *)0, SIOCSIFADDR,
			      (caddr_t)&ifr, ifp);

	    /*
	     * this interface has had an address set, so we aren't
	     * looking for an address any more
	     */
	    ifp->if_flags &= ~IFF_NEED_IPADDR;

	    /*
	     * this is for the benfit of dickless booting technology
	     */
	    _kernel_setenv(BOOTPSERVERVAR, inet_ntoa(serverip));

	    /*
	     * this will wakeup if_whoamiaddr(), which sets
	     * IFF_NEED_IPADDR before sleeping.
	     */
	    bootwakeup(0);
d619 12
a630 9
	if (AUN_state == AUN_CLIENT)
	{
	    /*
	     * raise an Internet event for the benefit of the Net module
	     */
	    memcpy(&thisip, ea->arp_tpa, sizeof thisip);
	    memcpy(&serverip, ea->arp_spa, sizeof serverip);
	    os_generate_event(Internet_Event, RarpReply, (int)serverip.s_addr, (int)thisip);
	}
a634 4
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("REVARP_REQUEST\n");
#endif
d639 1
a639 1
	if ((ifp->if_flags & IFF_NEED_IPADDR) != 0)
d642 8
a649 1
	if (AUN_state == AUN_CLIENT || AUN_state == AUN_GATEWAY)
d651 11
a661 3
		eh = (struct ether_header *)sa.sa_data;
		memcpy(eh->ether_dhost, ea->arp_sha, sizeof(ea->arp_sha));
		for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
d663 3
a665 10
		    if (ifa->ifa_ifp == ifp)
		    {
			if (AUN_state == AUN_CLIENT)
			    memset(ea->arp_spa, 0, sizeof ea->arp_spa);
			else if (AUN_state == AUN_GATEWAY)
			    memcpy(ea->arp_spa, &IA_SIN(ifa)->sin_addr, sizeof ea->arp_spa);
			memcpy(ea->arp_tpa, &IA_SIN(ifa)->sin_addr, sizeof ea->arp_tpa);
			ea->arp_tpa[3] = 0; /* MNS station id */
			break;
		    }
d667 4
a670 9
		if (ifa != 0)
		{
		    memcpy(ea->arp_sha, ac->ac_enaddr, sizeof ea->arp_sha);
		    memcpy(eh->ether_shost, ac->ac_enaddr, sizeof ea->arp_sha);
		    eh->ether_type = ETHERTYPE_REVARP;
		    ea->arp_op = htons(REVARP_REPLY);
		    sa.sa_family = AF_UNSPEC;
		    sa.sa_len = 16;
		    (*ac->ac_if.if_output)(&ac->ac_if, m, &sa, NULL);
d672 9
a680 6
		    return;
	        }
	}
	else
	{
		os_generate_event(Internet_Event, RarpRequest, (int) m, ac->ac_if.if_swibase);
a685 4
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("Unknown REVARP type: %d\n", ntohs(ea->arp_op));
#endif
d690 1
d692 3
d698 14
d733 1
a733 3
void
revarp_broadcastclientaddrs(ac)
    struct arpcom *ac;
d742 1
d745 6
d753 1
a753 1
    M_ALIGN(m, sizeof(struct ether_arp));
d756 3
a758 1
    memset(ea, 0, sizeof *ea);
a760 1
    sa.sa_len = 16;
d762 4
a765 2
    memcpy(eh->ether_dhost, etherbroadcastaddr, sizeof eh->ether_dhost);
    memcpy(eh->ether_shost, ac->ac_enaddr, sizeof eh->ether_shost);
d769 2
a770 2
    ea->arp_hln = sizeof ea->arp_sha;	    /* hardware address length */
    ea->arp_pln = sizeof ea->arp_spa;	    /* protocol address length */
d772 4
a775 2
    memcpy(ea->arp_sha, ac->ac_enaddr, sizeof ea->arp_sha);
    memcpy(ea->arp_tha, ac->ac_enaddr, sizeof ea->arp_tha);
d781 6
a786 2
	    memcpy(ea->arp_spa, &IA_SIN(ifa)->sin_addr, sizeof ea->arp_spa);
	    memcpy(ea->arp_tpa, &IA_SIN(ifa)->sin_addr, sizeof ea->arp_tpa);
d794 3
d798 4
d803 1
a803 1
	(*ifp->if_output)(ifp, m, &sa, NULL);
a807 2
#define satosin(sa) ((struct sockaddr_in *)(sa))

d812 1
a812 4
static void
request_netmask(ifp, flag)
    struct ifnet *ifp;
    int flag;
a814 1
    register struct in_ifaddr *ia = 0;
d817 10
a826 12
	/*
	 * Find address for this interface, if it exists.
	 */
	for (ia = in_ifaddr; ia; ia = ia->ia_next)
		if (ia->ia_ifp == ifp)
			break;
	if (ia == 0) {
		panic("request_netmask");
		return;
	}

    if ((m = m_gethdr(M_DONTWAIT, MT_DATA)) == NULL)
d828 3
d836 1
a836 1
    MH_ALIGN(m, sizeof (struct ip));
a837 2
    m->m_pkthdr.len = sizeof (struct ip);
    m->m_pkthdr.rcvif = ifp;
d849 1
a849 1
    ip->ip_src = satosin(&ia->ia_broadaddr)->sin_addr;
d851 1
a851 1
    icmp_error(m, ICMP_MASKREQ, 0, 0, (struct ifnet *) 0);
d855 20
a874 3
char *
inet_ntoa(in)
    struct in_addr in;
d889 1
a889 2
static int
left_alt_is_pressed()
d891 7
a897 1
    return _kernel_osbyte(KEYSCAN, LEFTALT | 0x80, 0) & 0xFF;
d900 1
a900 2
static int
right_alt_is_pressed()
d902 7
a908 1
    return _kernel_osbyte(KEYSCAN, RIGHTALT | 0x80, 0) & 0xFF;
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d17 1
a17 1
 * $Header: /ax/networking:Internet/whoami/whoami.c:networking  1.5  $
a24 12
 * Revision 1.5  95/11/14  12:08:41  pwain
 * Check in for jdavies@@csd
 * 
 * Added use of AUN_state flag to control AUN REVARP behaviour.
 *
 * Revision 1.4  95/07/06  08:50:39  kwelton
 * Fixed the case for REVARP_REPLY in revarpinput() - only bother setting
 * the interface address if actively looking for an address, and the reply
 * is to a request from the local machine; *always* raise an internet event
 * for the revarp reply, as this is used (and needed) by the Net module when
 * talking to Gateway machines.
 * 
d607 1
a607 3
	 * don't bother, unless we are actively looking for an
	 * address, otherwise test whether this is a reply to a packet
	 * sent from local machine, by comparing hardware addresses
d609 4
a612 2
	if( (ifp->if_flags & IFF_NEED_IPADDR) != 0 &&
	   bcmp((caddr_t)ea->arp_tha, (caddr_t)&ac->ac_enaddr[0], 6) == 0 )
a613 4
	    /*
	     * this duplicates an action taken within the in_control()
	     * call to set the interface address.
	     */
a615 4

	    /*
	     * this is most odd, as nobody sleeps on revarp!
	     */
d617 1
d619 6
a624 28
	    /*
	     * prepare for, and make a call to in_control() to set
	     * the interface address from the reply in the packet
	     */
	    bzero((caddr_t)&ifr, sizeof(ifr));
	    sin = (struct sockaddr_in *)&ifr.ifr_addr;
	    sin->sin_family = AF_INET;
	    sin->sin_addr = ac->ac_ipaddr;
	    (void)in_control((struct socket *)0, SIOCSIFADDR,
			      (caddr_t)&ifr, ifp);

	    /*
	     * this interface has had an address set, so we aren't
	     * looking for an address any more
	     */
	    ifp->if_flags &= ~IFF_NEED_IPADDR;

	    /*
	     * this is for the benfit of dickless booting technology
	     */
	    setriscosvar(BOOTPSERVERVAR, inet_ntoa(serverip));

	    /*
	     * this will wakeup if_whoamiaddr(), which sets
	     * IFF_NEED_IPADDR before sleeping.
	     */
	    bootwakeup();
	}
d626 5
a630 9
	if (AUN_state == AUN_CLIENT)
	{
	    /*
	     * raise an Internet event for the benefit of the Net module
	     */
	    bcopy((caddr_t)ea->arp_spa, &serverip, sizeof(serverip));
	    bcopy((caddr_t)ea->arp_tpa, &thisip, sizeof(thisip));
	    revarp_event(serverip, thisip);
	}
a680 36
	}
	else
	    if ((AUN_state == AUN_CLIENT) || (AUN_state == AUN_GATEWAY))
	    {
		eh = (struct ether_header *)sa.sa_data;
		memcpy(eh->ether_dhost, ea->arp_sha, sizeof(ea->arp_sha));
		for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
		{
		    if (ifa->ifa_ifp == ifp)
		    {
			if (AUN_state == AUN_CLIENT)
			    memset (ea->arp_spa, 0, sizeof(ea->arp_spa));
			if (AUN_state == AUN_GATEWAY)
			    memcpy(ea->arp_spa,
			    (caddr_t)&((struct sockaddr_in *)&ifa->ifa_addr)->sin_addr,
			    sizeof(ea->arp_spa));
			memcpy(ea->arp_tpa, 
			    (caddr_t)&((struct sockaddr_in *)&ifa->ifa_addr)->sin_addr,
			    sizeof(ea->arp_tpa));
			ea->arp_tpa[3] = 0; /* MNS station id */
			break;
		    }
		}
		if (ifa != 0)
		{
		    memcpy((caddr_t)ea->arp_sha,
		        (caddr_t)ac->ac_enaddr, sizeof(ea->arp_sha));
		    memcpy((caddr_t)eh->ether_shost,
		        (caddr_t)ac->ac_enaddr, sizeof(ea->arp_sha));
		    eh->ether_type = ETHERTYPE_REVARP;
		    ea->arp_op = htons(REVARP_REPLY);
		    sa.sa_family = AF_UNSPEC;
		    (*ac->ac_if.if_output)(&ac->ac_if, m, &sa);

		    return;
	    }
@


4.1.7.2
log
@RCS log keyword removed
@
text
@d24 1
a24 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@d27 1
a27 1
 *
d36 1
a36 1
 *
d40 1
a40 1
 *
d46 1
a46 1
 *
d48 1
a48 1
 *
d51 1
a51 1
 *
d87 1
a87 1
#define BOOTPSERVERVAR  "Inet$BootServer"
a88 5
#define BOOTPGATEWAYVAR "Inet$Gateway"
#define BOOTPNETMASKVAR "Inet$EtherIPMask"
#define BOOTPDNSVAR     "Inet$Resolvers"
#define BOOTPHOSTVAR    "Inet$HostName"

a249 66
/* Extract an IP address from 4 bytes.
 */
static u_long
vend_extractaddr(u_char *cp)
{
    return *cp + (*(cp+1) << 8) + (*(cp+2) << 16) + (*(cp+3) << 24);
}

/* Verify that vendor info is compliant with RFC-1048
 * by checking magic cookie.
 */
static int
vend_verify(BOOTP *pkt)
{
    return vend_extractaddr(pkt->vend) == RFC1048MAGIC;
}

/* Find code in vendor specific information
 * (returns pointer to length byte or NULL).
 */
static u_char *
vend_find_code(BOOTP *pkt, u_char code)
{
    u_char *cp = pkt->vend + 4;     /* Skip magic cookie. */
    u_char c;

    while ((c = *cp++) != TAG_END)
    {
        if (c == TAG_PAD) continue;
        if (c == code) return cp;
        cp += *cp + 1;
    }

    return NULL;
}

/* Extract an IP address specified by data code from vendor specific data
 * (returns netmask or 0).
 */
static u_long
vend_iaddr(BOOTP *pkt, u_char code)
{
    u_char *cp = vend_find_code(pkt, code);

    return (cp++ != NULL) ? vend_extractaddr(cp) : 0;
}

/* Extract a string from the vendor specific data
 * (returns length of string)
 */
static int
vend_string(BOOTP *pkt, u_char code, char *buf)
{
    u_char *cp = vend_find_code(pkt, code);

    if (cp != NULL)
    {
        int len = (int)*cp++;
        strncpy(buf, cp, len);
        buf[len] = '\0';
        return len;
    }

    return 0;
}

a292 19

    /* If this packet is RFC-1048 compliant then extract any pertinent
     * information from the vendor data.
     */
    if (vend_verify(&pkt))
    {
        char buf[VEND_MAX];
        u_long tmp;

        tmp = vend_string(&pkt, TAG_HOST_NAME, buf);
        if (tmp) setriscosvar(BOOTPHOSTVAR, buf);
        tmp = vend_iaddr(&pkt, TAG_SUBNET_MASK);
        if (tmp) setriscosvar(BOOTPNETMASKVAR, inet_ntoa(tmp));
        tmp = vend_iaddr(&pkt, TAG_GATEWAY);
        if (tmp) setriscosvar(BOOTPGATEWAYVAR, inet_ntoa(tmp));
        tmp = vend_iaddr(&pkt, TAG_DOMAIN_SERVER);
        if (tmp) setriscosvar(BOOTPDNSVAR, inet_ntoa(tmp));
    }

d742 1
a742 1
			memcpy(ea->arp_tpa,
d862 1
a862 1
	    memcpy(ea->arp_spa,
d865 1
a865 1
	    memcpy(ea->arp_tpa,
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d17 1
a17 1
 * $Header: /ax/networking:Internet/whoami/whoami.c:networking  1.5  $
a24 12
 * Revision 1.5  95/11/14  12:08:41  pwain
 * Check in for jdavies@@csd
 * 
 * Added use of AUN_state flag to control AUN REVARP behaviour.
 *
 * Revision 1.4  95/07/06  08:50:39  kwelton
 * Fixed the case for REVARP_REPLY in revarpinput() - only bother setting
 * the interface address if actively looking for an address, and the reply
 * is to a request from the local machine; *always* raise an internet event
 * for the revarp reply, as this is used (and needed) by the Net module when
 * talking to Gateway machines.
 * 
d607 1
a607 3
	 * don't bother, unless we are actively looking for an
	 * address, otherwise test whether this is a reply to a packet
	 * sent from local machine, by comparing hardware addresses
d609 4
a612 2
	if( (ifp->if_flags & IFF_NEED_IPADDR) != 0 &&
	   bcmp((caddr_t)ea->arp_tha, (caddr_t)&ac->ac_enaddr[0], 6) == 0 )
a613 4
	    /*
	     * this duplicates an action taken within the in_control()
	     * call to set the interface address.
	     */
a615 4

	    /*
	     * this is most odd, as nobody sleeps on revarp!
	     */
d617 1
d619 6
a624 28
	    /*
	     * prepare for, and make a call to in_control() to set
	     * the interface address from the reply in the packet
	     */
	    bzero((caddr_t)&ifr, sizeof(ifr));
	    sin = (struct sockaddr_in *)&ifr.ifr_addr;
	    sin->sin_family = AF_INET;
	    sin->sin_addr = ac->ac_ipaddr;
	    (void)in_control((struct socket *)0, SIOCSIFADDR,
			      (caddr_t)&ifr, ifp);

	    /*
	     * this interface has had an address set, so we aren't
	     * looking for an address any more
	     */
	    ifp->if_flags &= ~IFF_NEED_IPADDR;

	    /*
	     * this is for the benfit of dickless booting technology
	     */
	    setriscosvar(BOOTPSERVERVAR, inet_ntoa(serverip));

	    /*
	     * this will wakeup if_whoamiaddr(), which sets
	     * IFF_NEED_IPADDR before sleeping.
	     */
	    bootwakeup();
	}
d626 5
a630 9
	if (AUN_state == AUN_CLIENT)
	{
	    /*
	     * raise an Internet event for the benefit of the Net module
	     */
	    bcopy((caddr_t)ea->arp_spa, &serverip, sizeof(serverip));
	    bcopy((caddr_t)ea->arp_tpa, &thisip, sizeof(thisip));
	    revarp_event(serverip, thisip);
	}
a680 36
	}
	else
	    if ((AUN_state == AUN_CLIENT) || (AUN_state == AUN_GATEWAY))
	    {
		eh = (struct ether_header *)sa.sa_data;
		memcpy(eh->ether_dhost, ea->arp_sha, sizeof(ea->arp_sha));
		for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
		{
		    if (ifa->ifa_ifp == ifp)
		    {
			if (AUN_state == AUN_CLIENT)
			    memset (ea->arp_spa, 0, sizeof(ea->arp_spa));
			if (AUN_state == AUN_GATEWAY)
			    memcpy(ea->arp_spa,
			    (caddr_t)&((struct sockaddr_in *)&ifa->ifa_addr)->sin_addr,
			    sizeof(ea->arp_spa));
			memcpy(ea->arp_tpa, 
			    (caddr_t)&((struct sockaddr_in *)&ifa->ifa_addr)->sin_addr,
			    sizeof(ea->arp_tpa));
			ea->arp_tpa[3] = 0; /* MNS station id */
			break;
		    }
		}
		if (ifa != 0)
		{
		    memcpy((caddr_t)ea->arp_sha,
		        (caddr_t)ac->ac_enaddr, sizeof(ea->arp_sha));
		    memcpy((caddr_t)eh->ether_shost,
		        (caddr_t)ac->ac_enaddr, sizeof(ea->arp_sha));
		    eh->ether_type = ETHERTYPE_REVARP;
		    ea->arp_op = htons(REVARP_REPLY);
		    sa.sa_family = AF_UNSPEC;
		    (*ac->ac_if.if_output)(&ac->ac_if, m, &sa);

		    return;
	    }
@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d24 1
a24 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d17 1
a17 1
 * $Header: /ax/networking:Internet/whoami/whoami.c:networking  1.5  $
a24 12
 * Revision 1.5  95/11/14  12:08:41  pwain
 * Check in for jdavies@@csd
 *
 * Added use of AUN_state flag to control AUN REVARP behaviour.
 *
 * Revision 1.4  95/07/06  08:50:39  kwelton
 * Fixed the case for REVARP_REPLY in revarpinput() - only bother setting
 * the interface address if actively looking for an address, and the reply
 * is to a request from the local machine; *always* raise an internet event
 * for the revarp reply, as this is used (and needed) by the Net module when
 * talking to Gateway machines.
 *
d28 1
a28 1
 *
d34 1
a34 1
 *
d36 1
a36 1
 *
d39 1
a39 1
 *
a43 1
#include "sys/types.h"
d52 1
a52 1
#include "sys/kernel.h"
d58 2
a60 1
#include "netinet/in_var.h"
a61 1
#include "netinet/in_pcb.h"
a69 2
#include "protocols/bootp.h"

a70 3
#include "module.h"

struct	ifqueue revarpintrq = {0, 0, 0, 10};
d72 2
a73 7
char *inet_ntoa(struct in_addr);
void revarp_myaddr(struct ifnet *, int);
void revarpinput(struct mbuf *m);
static void bootwakeup(void);
static void if_askwhoiam(struct ifnet *ifp, int need,
                         void (*proc)(struct ifnet *, int), int flag);
static void bootsleep(int cmd);
d78 1
a78 7
#define Internet_Event	 19
#define RarpReply	  4
#define RarpRequest	  5

int
if_whoamimns(ifp)
    struct ifnet *ifp;
d85 1
a85 5
static void
if_askwhoiam(ifp, need, proc, flag)
    struct ifnet *ifp;
    int need, flag;
    void (*proc)(struct ifnet *, int);
d105 1
a105 4
int
if_whoamiaddr(ifp, cmd)
    struct ifnet *ifp;
    int cmd;
d124 1
a124 1
    timeout(bootwakeup, 0, backoff(boot_tries));
d139 1
a139 1
	    untimeout(bootwakeup, 0);
a144 1
	claim_frames(ifp, 0);
d148 1
a148 1
    untimeout(bootwakeup, 0);
d157 1
a157 3
int
backoff(retry)
    int retry;
d163 1
a163 1
    if (t >= sizeof(timeouts)/sizeof(timeouts[0]))
d175 1
a175 2
int
getrand()
d177 2
d181 2
a182 1
    return (os_read_monotonic_time() % rand());
d185 1
a185 3
static void
bootsleep(cmd)
    int cmd;
d191 2
a192 1
	if (cmd == SIOCGWHOIAMRB && left_alt_is_pressed() && right_alt_is_pressed())
d200 1
a200 2
static void
bootwakeup()
d209 1
a209 3
int
if_whoamimask(ifp)
    struct ifnet *ifp;
d211 1
a211 1
    void request_netmask();
d214 1
d216 1
a216 1
    tsleep(&whoamimask, PSOCK | PCATCH, "whoamimask", MASK_MAX_WAIT, 0);
d223 2
d229 1
a229 2
#define BOOTPserver 67
#define BOOTPclient 68
d231 1
a231 3
int
in_bootpresponse(port)
    u_short port;
d233 1
a233 1
    return (port == BOOTPclient);
d236 2
d241 1
a241 4
void
bootp_udp_input(ifp, m)
    struct ifnet *ifp;
    struct mbuf *m;
d244 4
a247 1
    int len = sizeof pkt;
a250 1
    struct in_addr in;
d252 1
a252 1
    memset(&pkt, 0, sizeof(pkt));
d254 10
d265 1
d276 1
a276 1
    if (memcmp(ac->ac_enaddr, pkt.chaddr, pkt.hlen))
d279 3
a281 4
    in.s_addr=pkt.siaddr;
    _kernel_setenv(BOOTPSERVERVAR, inet_ntoa(in));
    _kernel_setenv(BOOTPSERVERFILE, (char *) pkt.file);
    memset(&ifr, 0, sizeof ifr);
a283 1
    sin->sin_len = sizeof *sin;
d298 1
a298 4
int
bootp_ip_output(m, ifp)
    struct mbuf *m;
    struct ifnet *ifp;
d302 1
d308 1
a308 1
    ip->ip_hl = sizeof(struct ip) >> 2;
a310 1
    dst.sin_len = sizeof dst;
d316 2
a317 2
    ip->ip_sum = in_cksum_hdr(ip);
    return ((*ifp->if_output)(ifp, m, (struct sockaddr *)&dst, NULL));
d320 2
d326 4
a329 2
static int
bootp_udp_output(m, ifp, laddr, lport, faddr, fport)
a330 4
    struct ifnet *ifp;
    u_long laddr, faddr;
    short lport, fport;
{
d332 1
a332 1
    register int len = m->m_pkthdr.len;
d335 2
a336 1
     * get a mbuf for UDP and IP headers.
d338 2
d341 2
a342 1
    M_PREPEND(m, sizeof (struct udpiphdr), M_DONTWAIT);
d345 6
d352 2
a353 2
	if (DODEBUG(DBGMMAN))
	    Printf("bootp_udp_output: M_PREPEND failed\n");
d355 2
a356 1
	return (ENOBUFS);
d359 3
d366 3
d382 1
a382 1
    ((struct ip *)ui)->ip_ttl = ip_defttl;
d387 1
a387 4
int
bootp_myaddr(ac, retry)
    struct arpcom *ac;
    int retry;
d389 1
a389 1
    struct mbuf *m0, *m;
d391 2
d395 7
a401 1
    memset(&pkt, 0, sizeof pkt);
d405 1
a405 1
    pkt.xid = time.tv_sec;
d407 5
a411 3
    memcpy(pkt.chaddr, ac->ac_enaddr, pkt.hlen);
    strcpy((char *)pkt.sname, server);  /* If known */
    strcpy((char *)pkt.file, file);		    /* If known */
d413 35
a447 2
    if ((m0 = m = ALLOC(sizeof pkt, &pkt)) == NULL)
	return (ENOBUFS);
d449 1
a449 1
    while (m)
d451 5
a455 2
        m->m_type = MT_DATA;
        m = m->m_next;
d457 2
a458 4

    m0->m_pkthdr.len = sizeof pkt;
    m0->m_pkthdr.rcvif = 0;
    m0->m_flags = M_PKTHDR | M_BCAST;
d468 3
a470 4
void
revarp_myaddr(ifp, flag)
    register struct ifnet *ifp;
    int flag;
d472 1
a472 1
    struct arpcom *ac = (struct arpcom *) ifp;
d474 1
a474 1
    /*struct ifreq ifr;*/
a487 1
#if 0
d493 1
a493 1
	memset(&ifr, 0, sizeof ifr);
d496 1
a496 2
	sin->sin_len = sizeof(*sin);
	sin->sin_addr.s_addr = htonl(0x00FFFFFF);
d500 2
a501 1
	if (ac->ac_ipaddr.s_addr && ac->ac_ipaddr.s_addr != sin->sin_addr.s_addr)
d510 5
d516 5
a520 2
        claim_frames(ifp, 1);
        ifp->if_flags |= IFF_UP | IFF_RUNNING;
d522 1
d525 2
a526 6
    if ((m = m_gethdr(M_DONTWAIT, MT_DATA)) == NULL)
	return;

    m->m_pkthdr.len = sizeof(struct ether_arp);
    m->m_pkthdr.rcvif = 0;
    m->m_flags |= M_BCAST;
d529 1
a529 1
    MH_ALIGN(m, sizeof(struct ether_arp));
d531 1
a531 1
    memset(ea, 0, sizeof *ea);
a533 1
    sa.sa_len = 16;
d535 4
a538 2
    memcpy(eh->ether_dhost, etherbroadcastaddr, sizeof eh->ether_dhost);
    memcpy(eh->ether_shost, ac->ac_enaddr, sizeof eh->ether_shost);
d547 2
a548 2
    memcpy(ea->arp_sha, ac->ac_enaddr, sizeof ea->arp_sha);
    memcpy(ea->arp_tha, ac->ac_enaddr, sizeof ea->arp_tha);
d550 1
a550 1
    if (DODEBUG(DBGADDRSRCH))
d552 1
a552 1
	int err = (ifp->if_output)(ifp, m, &sa, NULL);
d555 1
a555 1
	       /*ctosym*/(ifp->if_output), err);
d559 1
a559 1
    (*ifp->if_output)(ifp, m, &sa, NULL);
a561 1
#ifdef NotYet
a569 50
#endif

/*
 * Common length and type checks are done here,
 * then the protocol-specific routine is called.
 */
void
revarpintr(void)
{
	register struct mbuf *m;
	register struct arphdr *ar;
	int s;

#ifdef DEBUG
        Printf("revarpintr\n");
#endif
	while (revarpintrq.ifq_head) {
		s = splimp();
		IF_DEQUEUE(&revarpintrq, m);
		splx(s);
		if (m == 0 || (m->m_flags & M_PKTHDR) == 0) {
			panic("revarpintr");
			return;
		}
#ifdef DEBUG
                if (DODEBUG(DBGADDRSRCH))
                    Printf("got a REVARP packet\n");
#endif
		if (m->m_len >= sizeof(struct arphdr) &&
		    (ar = mtod(m, struct arphdr *)) &&
		    ntohs(ar->ar_hrd) == ARPHRD_ETHER &&
		    m->m_len >=
		      sizeof(struct arphdr) + 2 * ar->ar_hln + 2 * ar->ar_pln)
#ifdef DEBUG
                            if (DODEBUG(DBGADDRSRCH))
                                 Printf("Seems valid\n");
#endif
			    switch (ntohs(ar->ar_pro)) {

			    case ETHERTYPE_IP:
#ifdef DEBUG
                                    if (DODEBUG(DBGADDRSRCH))
                                            Printf("Is IP\n");
#endif
				    revarpinput(m);
				    continue;
			    }
		m_freem(m);
	}
}
d577 1
a577 3
void
revarpinput(m)
    struct mbuf *m;
a579 1
#ifdef NotYet
a580 1
#endif
d582 1
a582 2
    struct ifnet *ifp = m->m_pkthdr.rcvif;
    struct arpcom *ac = (struct arpcom *) ifp;
d587 1
a587 2
    u_long thisip;
    struct in_addr serverip;
d589 1
a589 3
#ifdef DEBUG
    Printf("revarpinput(ac=%x, m=%x)\n", ac, m);
#endif
d591 4
a594 5
    if (m->m_len < sizeof *ea) {
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("Too short\n");
#endif
a595 1
    }
d597 1
a597 5
    if (ac->ac_if.if_flags & IFF_NOARP) {
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("No ARP\n");
#endif
a598 1
    }
d600 1
a600 5
    if (ntohs(ea->arp_pro) != ETHERTYPE_IP) {
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("Not IP: type=%d\n", ntohs(ea->arp_pro));
#endif
a601 1
    }
a605 4
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("REVARP_REPLY\n");
#endif
d607 1
a607 3
	 * don't bother, unless we are actively looking for an
	 * address, otherwise test whether this is a reply to a packet
	 * sent from local machine, by comparing hardware addresses
d609 4
a612 2
	if ((ifp->if_flags & IFF_NEED_IPADDR) &&
	    memcmp(ea->arp_tha, ac->ac_enaddr, 6) == 0)
d614 3
a616 39
#ifdef DEBUG
            if (DODEBUG(DBGARP))
                Printf("It's a reply for us\n");
#endif
	    /*
	     * this duplicates an action taken within the in_control()
	     * call to set the interface address.
	     */
	    memcpy(&ac->ac_ipaddr, ea->arp_tpa, sizeof ac->ac_ipaddr);
	    memcpy(&serverip, ea->arp_spa, sizeof serverip);

	    /*
	     * prepare for, and make a call to in_control() to set
	     * the interface address from the reply in the packet
	     */
	    memset(&ifr, 0, sizeof ifr);
	    sin = (struct sockaddr_in *)&ifr.ifr_addr;
	    sin->sin_family = AF_INET;
	    sin->sin_len = sizeof *sin;
	    sin->sin_addr = ac->ac_ipaddr;
	    (void)in_control((struct socket *)0, SIOCSIFADDR,
			      (caddr_t)&ifr, ifp);

	    /*
	     * this interface has had an address set, so we aren't
	     * looking for an address any more
	     */
	    ifp->if_flags &= ~IFF_NEED_IPADDR;

	    /*
	     * this is for the benfit of dickless booting technology
	     */
	    _kernel_setenv(BOOTPSERVERVAR, inet_ntoa(serverip));

	    /*
	     * this will wakeup if_whoamiaddr(), which sets
	     * IFF_NEED_IPADDR before sleeping.
	     */
	    bootwakeup();
d619 12
a630 9
	if (AUN_state == AUN_CLIENT)
	{
	    /*
	     * raise an Internet event for the benefit of the Net module
	     */
	    memcpy(&thisip, ea->arp_tpa, sizeof thisip);
	    memcpy(&serverip, ea->arp_spa, sizeof serverip);
	    os_generate_event(Internet_Event, RarpReply, serverip.s_addr, thisip);
	}
a634 4
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("REVARP_REQUEST\n");
#endif
d639 1
a639 1
	if ((ifp->if_flags & IFF_NEED_IPADDR) != 0)
d642 1
a642 1
	if (AUN_state == AUN_CLIENT || AUN_state == AUN_GATEWAY)
d644 18
a661 3
		eh = (struct ether_header *)sa.sa_data;
		memcpy(eh->ether_dhost, ea->arp_sha, sizeof(ea->arp_sha));
		for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
d663 3
a665 10
		    if (ifa->ifa_ifp == ifp)
		    {
			if (AUN_state == AUN_CLIENT)
			    memset(ea->arp_spa, 0, sizeof ea->arp_spa);
			else if (AUN_state == AUN_GATEWAY)
			    memcpy(ea->arp_spa, &IA_SIN(ifa)->sin_addr, sizeof ea->arp_spa);
			memcpy(ea->arp_tpa, &IA_SIN(ifa)->sin_addr, sizeof ea->arp_tpa);
			ea->arp_tpa[3] = 0; /* MNS station id */
			break;
		    }
d667 4
a670 9
		if (ifa != 0)
		{
		    memcpy(ea->arp_sha, ac->ac_enaddr, sizeof ea->arp_sha);
		    memcpy(eh->ether_shost, ac->ac_enaddr, sizeof ea->arp_sha);
		    eh->ether_type = ETHERTYPE_REVARP;
		    ea->arp_op = htons(REVARP_REPLY);
		    sa.sa_family = AF_UNSPEC;
		    sa.sa_len = 16;
		    (*ac->ac_if.if_output)(&ac->ac_if, m, &sa, NULL);
d672 9
a680 6
		    return;
	        }
	}
	else
	{
		os_generate_event(Internet_Event, RarpRequest, m, ac->ac_if.if_swibase);
a685 4
#ifdef DEBUG
        if (DODEBUG(DBGARP))
            Printf("Unknown REVARP type: %d\n", ntohs(ea->arp_op));
#endif
d690 1
d692 3
d698 14
d733 1
a733 3
void
revarp_broadcastclientaddrs(ac)
    struct arpcom *ac;
d742 1
d745 6
d753 1
a753 1
    M_ALIGN(m, sizeof(struct ether_arp));
d756 3
a758 1
    memset(ea, 0, sizeof *ea);
a760 1
    sa.sa_len = 16;
d762 4
a765 2
    memcpy(eh->ether_dhost, etherbroadcastaddr, sizeof eh->ether_dhost);
    memcpy(eh->ether_shost, ac->ac_enaddr, sizeof eh->ether_shost);
d769 2
a770 2
    ea->arp_hln = sizeof ea->arp_sha;	    /* hardware address length */
    ea->arp_pln = sizeof ea->arp_spa;	    /* protocol address length */
d772 4
a775 2
    memcpy(ea->arp_sha, ac->ac_enaddr, sizeof ea->arp_sha);
    memcpy(ea->arp_tha, ac->ac_enaddr, sizeof ea->arp_tha);
d781 6
a786 2
	    memcpy(ea->arp_spa, &IA_SIN(ifa)->sin_addr, sizeof ea->arp_spa);
	    memcpy(ea->arp_tpa, &IA_SIN(ifa)->sin_addr, sizeof ea->arp_tpa);
d794 3
d798 4
d803 1
a803 1
	(*ifp->if_output)(ifp, m, &sa, NULL);
a807 2
#define satosin(sa) ((struct sockaddr_in *)(sa))

d812 1
a812 4
void
request_netmask(ifp, flag)
    struct ifnet *ifp;
    int flag;
a814 1
    register struct in_ifaddr *ia = 0;
d817 10
a826 12
	/*
	 * Find address for this interface, if it exists.
	 */
	for (ia = in_ifaddr; ia; ia = ia->ia_next)
		if (ia->ia_ifp == ifp)
			break;
	if (ia == 0) {
		panic("request_netmask");
		return;
	}

    if ((m = m_gethdr(M_DONTWAIT, MT_DATA)) == NULL)
d828 3
d836 1
a836 1
    MH_ALIGN(m, sizeof (struct ip));
a837 2
    m->m_pkthdr.len = sizeof (struct ip);
    m->m_pkthdr.rcvif = ifp;
d849 1
a849 1
    ip->ip_src = satosin(&ia->ia_broadaddr)->sin_addr;
d851 1
a851 1
    icmp_error(m, ICMP_MASKREQ, 0, 0, (struct ifnet *) 0);
d855 20
a874 3
char *
inet_ntoa(in)
    struct in_addr in;
d889 1
a889 2
int
left_alt_is_pressed()
d891 7
a897 1
    return _kernel_osbyte(KEYSCAN, LEFTALT | 0x80, 0) & 0xFF;
d900 1
a900 2
int
right_alt_is_pressed()
d902 7
a908 1
    return _kernel_osbyte(KEYSCAN, RIGHTALT | 0x80, 0) & 0xFF;
@


4.1.3.2
log
@RCS Log keyword removed
@
text
@d24 1
a24 1
 * :RCS Log discontinued:
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d24 1
a24 1
 * :RCS Log discontinued:
@

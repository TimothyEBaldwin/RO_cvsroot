head	4.6;
access;
symbols
	Internet-5_65:4.6
	Internet-5_64:4.6
	Internet-5_63:4.6
	Internet-5_62:4.6
	Internet-5_61:4.6
	Internet-5_60:4.6
	Internet-5_59:4.6
	Internet-5_58:4.6
	Internet-5_57:4.6
	Internet-5_56:4.6
	Internet-5_55:4.6
	Internet-5_54:4.6
	Internet-5_53:4.6
	Internet-5_52:4.6
	Internet-5_51:4.6
	Internet-5_50:4.6
	RO_5_07:4.6
	Internet-5_49:4.6
	Internet-5_48:4.6
	Internet-5_47:4.6
	Internet-5_46:4.6
	Internet-5_45:4.6
	Internet-5_44:4.6
	Internet-5_43:4.6
	Internet-5_42:4.6
	Internet-5_41:4.6
	Internet-5_40:4.6
	Internet-5_39:4.6
	Internet-5_38:4.6
	Internet-5_37:4.6
	Internet-5_36:4.6
	Internet-5_35:4.6
	Internet-5_34:4.6
	Internet-5_33:4.5
	Internet-5_32:4.5
	Internet-5_31:4.5
	Internet-5_30:4.4
	Internet-5_29:4.4
	Internet-5_27:4.4
	Internet-5_26:4.4
	Internet-5_25:4.3
	Internet-5_24:4.3
	Internet-5_23:4.3
	Internet-5_22:4.2
	Internet-5_21:4.2
	Internet-5_20:4.2
	Internet-5_19:4.2
	Internet-5_18:4.2
	Internet-5_17:4.2
	Internet-5_16:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Internet-5_15:4.2
	Internet-5_14:4.2
	Internet-5_13:4.2
	sforrest_daytona_appflash-0_31:4.2
	Internet-5_12:4.2
	Internet-5_11:4.2
	celkins_Internet-5_10:4.2
	nicke_Internat_25-9-98:4.2
	Internet-5_09:4.2
	blaughto_daytona_appflash-0_30:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rwarren_Internet-5_08:4.2
	Spinner:4.2
	Internet_5_07:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.2
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	99.07.28.12.00.11;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.07.13.11.12.51;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.06.25.13.40.14;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.06.07.10.48.02;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.58.48;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.08;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.08;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.20.04;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.28.06;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.06.46;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.19;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.06.41;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.33;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.38.26;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.19;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@microtime() now returns microsecond accuracy.
Random number generator now seeded from microtime(), machine ID and
hardware addresses of DCI drivers.
Some previously untested debugging code fixed to compile.

Version 5.34. Tagged as 'Internet-5_34'
@
text
@/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include "kernel.h"

#include "sys/param.h"
#include "sys/systm.h"
#include "sys/kernel.h"
#include "sys/proc.h"
#include "sys/time.h"
#include "sys/mbuf.h"
#include "sys/protosw.h"
#include "sys/socket.h"
#include "sys/sysctl.h"

#include "net/route.h"
#include "net/if.h"

#include "netinet/in.h"
#include "netinet/in_systm.h"
#include "netinet/in_var.h"
#include "netinet/ip.h"
#include "netinet/ip_icmp.h"
#include "netinet/ip_var.h"
#include "netinet/icmp_var.h"

#include "svcdebug.h"
#include "module.h"
#include "debug.h"

/*
 * ICMP routines: error generation, receive packet processing, and
 * routines to turnaround packets back to the originator, and
 * host table maintenance routines.
 */

struct	icmpstat icmpstat;
SYSCTL_STRUCT(_net_inet_icmp, ICMPCTL_STATS, stats, CTLFLAG_RD,
	&icmpstat, icmpstat, "");

int	icmpmaskrepl = 0;
SYSCTL_INT(_net_inet_icmp, ICMPCTL_MASKREPL, maskrepl, CTLFLAG_RW,
	&icmpmaskrepl, 0, "");

#ifdef ICMP_BANDLIM

/*
 * ICMP error-response bandwidth limiting sysctl.  If not enabled, sysctl
 *      variable content is -1 and read-only.
 */

static int      icmplim = 100;
SYSCTL_INT(_net_inet_icmp, ICMPCTL_ICMPLIM, icmplim, CTLFLAG_RW,
	&icmplim, 0, "");
#else

static int      icmplim = -1;
SYSCTL_INT(_net_inet_icmp, ICMPCTL_ICMPLIM, icmplim, CTLFLAG_RD,
	&icmplim, 0, "");

#endif

/*
 * ICMP broadcast echo sysctl
 */

static int	icmpbmcastecho = 0;
SYSCTL_INT(_net_inet_icmp, OID_AUTO, bmcastecho, CTLFLAG_RW, &icmpbmcastecho,
	   0, "");


#ifdef ICMPPRINTFS
int	icmpprintfs = 0;
#endif

static void	icmp_reflect(struct mbuf *);
static void	icmp_send(struct mbuf *, struct mbuf *);
static int	ip_next_mtu(int, int);

extern	struct protosw inetsw[];

int send_flags = 0;

/*
 * Generate an error packet of type error
 * in response to bad packet ip.
 */
void
icmp_error(n, type, code, dest, destifp)
	struct mbuf *n;
	int type, code;
	n_long dest;
	struct ifnet *destifp;
{
	register struct ip *oip = mtod(n, struct ip *), *nip;
	register unsigned oiplen = oip->ip_hl << 2;
	register struct icmp *icp;
	register struct mbuf *m;
	unsigned icmplen;

#ifdef ICMPPRINTFS
	if (icmpprintfs)
		printf("icmp_error(%p, %x, %d)\n", oip, type, code);
#endif
	if (type != ICMP_REDIRECT)
		icmpstat.icps_error++;
	/*
	 * Don't send error if not the first fragment of message.
	 * Don't error if the old packet protocol was ICMP
	 * error message, only known informational types.
	 */
	if (oip->ip_off &~ (IP_MF|IP_DF))
		goto freeit;
	if (oip->ip_p == IPPROTO_ICMP && type != ICMP_REDIRECT &&
	  n->m_len >= oiplen + ICMP_MINLEN &&
	  !ICMP_INFOTYPE(((struct icmp *)((caddr_t)oip + oiplen))->icmp_type)) {
		icmpstat.icps_oldicmp++;
		goto freeit;
	}
	/* Don't send error in response to a multicast or broadcast packet */
	if (n->m_flags & (M_BCAST|M_MCAST))
		goto freeit;
	/*
	 * First, formulate icmp message
	 */
	m = m_gethdr(M_DONTWAIT, MT_HEADER);
	if (m == NULL)
		goto freeit;
	icmplen = oiplen + min(8, oip->ip_len);
	m->m_len = icmplen + ICMP_MINLEN;
	MH_ALIGN(m, m->m_len);
	icp = mtod(m, struct icmp *);
	if ((u_int)type > ICMP_MAXTYPE) {
		panic("icmp_error");
		return;
	}
	icmpstat.icps_outhist[type]++;
	icp->icmp_type = type;
	if (type == ICMP_REDIRECT)
		icp->icmp_gwaddr.s_addr = dest;
	else {
		icp->icmp_void = 0;
		/*
		 * The following assignments assume an overlay with the
		 * zeroed icmp_void field.
		 */
		if (type == ICMP_PARAMPROB) {
			icp->icmp_pptr = code;
			code = 0;
		} else if (type == ICMP_UNREACH &&
			code == ICMP_UNREACH_NEEDFRAG && destifp) {
			icp->icmp_nextmtu = htons(destifp->if_mtu);
		}
	}

	icp->icmp_code = code;
	bcopy((caddr_t)oip, (caddr_t)&icp->icmp_ip, icmplen);
	nip = &icp->icmp_ip;
	nip->ip_len = htons((u_short)(nip->ip_len + oiplen));

	/*
	 * Now, copy old ip header (without options)
	 * in front of icmp message.
	 */
	if (m->m_off - sizeof(struct ip) < m->m_inioff)
		panic("icmp len");
	m->m_off -= sizeof(struct ip);
	m->m_len += sizeof(struct ip);
	m->m_pkthdr.len = m->m_len;
	m->m_pkthdr.rcvif = n->m_pkthdr.rcvif;
	nip = mtod(m, struct ip *);
	bcopy((caddr_t)oip, (caddr_t)nip, sizeof(struct ip));
	nip->ip_len = m->m_len;
	nip->ip_hl = sizeof(struct ip) >> 2;
	nip->ip_p = IPPROTO_ICMP;
	nip->ip_tos = 0;
	icmp_reflect(m);

freeit:
	m_freem(n);
}

static struct sockaddr_in icmpsrc = { sizeof (struct sockaddr_in), AF_INET };
static struct sockaddr_in icmpdst = { sizeof (struct sockaddr_in), AF_INET };
static struct sockaddr_in icmpgw = { sizeof (struct sockaddr_in), AF_INET };

/*
 * Process a received ICMP message.
 */
void
icmp_input(m, hlen)
	register struct mbuf *m;
	int hlen;
{
	register struct icmp *icp;
	register struct ip *ip = mtod(m, struct ip *);
	int icmplen = ip->ip_len;
	register int i;
	struct in_ifaddr *ia;
	void (*ctlfunc)(int, struct sockaddr *, void *);
	int code;

	/*
	 * Locate icmp structure in mbuf, and check
	 * that not corrupted and of at least minimum length.
	 */
#ifdef DEBUG
	if( DODEBUG(DBGICMP) ) {
		char buf[4 * sizeof "123"];
		strcpy(buf, inet_ntoa(ip->ip_src));
		Printf("icmp_input from %s to %s, len %d\n",
		       buf, inet_ntoa(ip->ip_dst), icmplen);
	}
#endif
	if (icmplen < ICMP_MINLEN) {
		icmpstat.icps_tooshort++;
		goto freeit;
	}
	i = hlen + min(icmplen, ICMP_ADVLENMIN);
	if (m->m_len < i && (m = PULLUP(m, i)) == NULL ) {
		icmpstat.icps_tooshort++;
		return;
	}
	ip = mtod(m, struct ip *);
	m->m_len -= hlen;
	m->m_off += hlen;
	icp = mtod(m, struct icmp *);
	if (in_cksum(m, icmplen)) {
		icmpstat.icps_checksum++;
		goto freeit;
	}
	m->m_len += hlen;
	m->m_off -= hlen;

#ifdef DEBUG
	if( DODEBUG(DBGICMP) )
	    	Printf("icmp_input, type %d code %d\n", icp->icmp_type,
	    	    icp->icmp_code);
#endif

#ifdef __riscos
	if ((m->m_pkthdr.rcvif->if_flags & IFF_NEED_IPADDR) &&
	    !(icp->icmp_type == ICMP_MASKREPLY &&
	       (m->m_pkthdr.rcvif->if_flags & IFF_NEED_MASK)))
		/* Interface not configured yet - don't process anything apart from
		 * mask reply (if wanted)
		 */
		goto raw;
#endif
	/*
	 * Message type specific processing.
	 */
	if (icp->icmp_type > ICMP_MAXTYPE)
		goto raw;
	icmpstat.icps_inhist[icp->icmp_type]++;
	code = icp->icmp_code;
	switch (icp->icmp_type) {

	case ICMP_UNREACH:
		switch (code) {
			case ICMP_UNREACH_NET:
			case ICMP_UNREACH_HOST:
			case ICMP_UNREACH_PROTOCOL:
			case ICMP_UNREACH_PORT:
			case ICMP_UNREACH_SRCFAIL:
				code += PRC_UNREACH_NET;
				break;

			case ICMP_UNREACH_NEEDFRAG:
				code = PRC_MSGSIZE;
				break;

			case ICMP_UNREACH_NET_UNKNOWN:
			case ICMP_UNREACH_NET_PROHIB:
			case ICMP_UNREACH_TOSNET:
				code = PRC_UNREACH_NET;
				break;

			case ICMP_UNREACH_HOST_UNKNOWN:
			case ICMP_UNREACH_ISOLATED:
			case ICMP_UNREACH_HOST_PROHIB:
			case ICMP_UNREACH_TOSHOST:
				code = PRC_UNREACH_HOST;
				break;

			default:
				goto badcode;
		}
		goto deliver;

	case ICMP_TIMXCEED:
		if (code > 1)
			goto badcode;
		code += PRC_TIMXCEED_INTRANS;
		goto deliver;

	case ICMP_PARAMPROB:
		if (code > 1)
			goto badcode;
		code = PRC_PARAMPROB;
		goto deliver;

	case ICMP_SOURCEQUENCH:
		if (code)
			goto badcode;
		code = PRC_QUENCH;
	deliver:
		/*
		 * Problem with datagram; advise higher level routines.
		 */
		if (icmplen < ICMP_ADVLENMIN || icmplen < ICMP_ADVLEN(icp) ||
		    icp->icmp_ip.ip_hl < (sizeof(struct ip) >> 2)) {
			icmpstat.icps_badlen++;
			goto freeit;
		}
		NTOHS(icp->icmp_ip.ip_len);
		/* Discard ICMP's in response to multicast packets */
		if (IN_MULTICAST(ntohl(icp->icmp_ip.ip_dst.s_addr)))
			goto badcode;
#ifdef DEBUG
		if( DODEBUG(DBGICMP) )
		    Printf("deliver to protocol %d\n", icp->icmp_ip.ip_p);
#endif
		icmpsrc.sin_addr = icp->icmp_ip.ip_dst;
#if 1
		/*
		 * MTU discovery:
		 * If we got a needfrag and there is a host route to the
		 * original destination, and the MTU is not locked, then
		 * set the MTU in the route to the suggested new value
		 * (if given) and then notify as usual.  The ULPs will
		 * notice that the MTU has changed and adapt accordingly.
		 * If no new MTU was suggested, then we guess a new one
		 * less than the current value.  If the new MTU is
		 * unreasonably small (arbitrarily set at 296), then
		 * we reset the MTU to the interface value and enable the
		 * lock bit, indicating that we are no longer doing MTU
		 * discovery.
		 */
		if (code == PRC_MSGSIZE) {
			struct rtentry *rt;
			int mtu;

			rt = rtalloc1((struct sockaddr *)&icmpsrc, 0,
				      RTF_CLONING | RTF_PRCLONING);
			if (rt && (rt->rt_flags & RTF_HOST)
			    && !(rt->rt_rmx.rmx_locks & RTV_MTU)) {
				mtu = ntohs(icp->icmp_nextmtu);
				if (!mtu)
					mtu = ip_next_mtu(rt->rt_rmx.rmx_mtu,
							  1);
#ifdef DEBUG_MTUDISC
				Printf("MTU for %s reduced to %d\n",
					inet_ntoa(icmpsrc.sin_addr), mtu);
#endif
				if (mtu < 296) {
					/* rt->rt_rmx.rmx_mtu =
						rt->rt_ifp->if_mtu; */
					rt->rt_rmx.rmx_locks |= RTV_MTU;
				} else if (rt->rt_rmx.rmx_mtu > mtu) {
					rt->rt_rmx.rmx_mtu = mtu;
				}
			}
			if (rt)
				RTFREE(rt);
		}

#endif
		ctlfunc = inetsw[ip_protox[icp->icmp_ip.ip_p]].pr_ctlinput;
		if (ctlfunc)
			(*ctlfunc)(code, (struct sockaddr *)&icmpsrc,
				    (void *)&icp->icmp_ip);
		break;

	badcode:
		icmpstat.icps_badcode++;
		break;

	case ICMP_ECHO:
		icp->icmp_type = ICMP_ECHOREPLY;
		goto reflect;

	case ICMP_TSTAMP:
		if (icmplen < ICMP_TSLEN) {
			icmpstat.icps_badlen++;
			break;
		}
		icp->icmp_type = ICMP_TSTAMPREPLY;
		icp->icmp_rtime = iptime();
		icp->icmp_ttime = icp->icmp_rtime;	/* bogus, do later! */
		goto reflect;

#ifdef __riscos
#ifdef TODO
	case ICMP_IREQ:
		if (in_netof(ip->ip_src) == 0 &&
		    (ia = (struct in_ifaddr *)ifaof_ifpforaddr(
			    (struct sockaddr *)&icmpdst, m->m_pkthdr.rcvif)))
			ip->ip_src = in_makeaddr(in_netof(IA_SIN(ia)->sin_addr),
			    in_lnaof(ip->ip_src));
		icp->icmp_type = ICMP_IREQREPLY;
		goto reflect;
#endif
#endif

	case ICMP_MASKREQ:
#define satosin(sa)	((struct sockaddr_in *)(sa))
		if (icmpmaskrepl == 0)
			break;
		/*
		 * We are not able to respond with all ones broadcast
		 * unless we receive it over a point-to-point interface.
		 */
		if (icmplen < ICMP_MASKLEN)
			break;
		switch (ip->ip_dst.s_addr) {

		case INADDR_BROADCAST:
		case INADDR_ANY:
			icmpdst.sin_addr = ip->ip_src;
			break;

		default:
			icmpdst.sin_addr = ip->ip_dst;
		}
		ia = (struct in_ifaddr *)ifaof_ifpforaddr(
			    (struct sockaddr *)&icmpdst, m->m_pkthdr.rcvif);
		if (ia == 0)
			break;
		if (ia->ia_ifp == 0)
			break;
		icp->icmp_type = ICMP_MASKREPLY;
		icp->icmp_mask = ia->ia_sockmask.sin_addr.s_addr;
		if (ip->ip_src.s_addr == 0) {
			if (ia->ia_ifp->if_flags & IFF_BROADCAST)
			    ip->ip_src = satosin(&ia->ia_broadaddr)->sin_addr;
			else if (ia->ia_ifp->if_flags & IFF_POINTOPOINT)
			    ip->ip_src = satosin(&ia->ia_dstaddr)->sin_addr;
		}
reflect:
		ip->ip_len += hlen;	/* since ip_input deducts this */
		icmpstat.icps_reflect++;
		icmpstat.icps_outhist[icp->icmp_type]++;
		icmp_reflect(m);
		return;

	case ICMP_REDIRECT:
		if (code > 3)
			goto badcode;
		if (icmplen < ICMP_ADVLENMIN || icmplen < ICMP_ADVLEN(icp) ||
		    icp->icmp_ip.ip_hl < (sizeof(struct ip) >> 2)) {
			icmpstat.icps_badlen++;
			break;
		}
		/*
		 * Short circuit routing redirects to force
		 * immediate change in the kernel's routing
		 * tables.  The message is also handed to anyone
		 * listening on a raw socket (e.g. the routing
		 * daemon for use in updating its tables).
		 */
		icmpgw.sin_addr = ip->ip_src;
		icmpdst.sin_addr = icp->icmp_gwaddr;
#ifdef DEBUG
		if( DODEBUG(DBGICMP) ) {
			char buf[4 * sizeof "123"];
			strcpy(buf, inet_ntoa(icp->icmp_ip.ip_dst));

		    	Printf("redirect dst %s to %s\n",
			   buf, inet_ntoa(icp->icmp_gwaddr));
		}
#endif
		icmpsrc.sin_addr = icp->icmp_ip.ip_dst;
		rtredirect((struct sockaddr *)&icmpsrc,
		  (struct sockaddr *)&icmpdst,
		  (struct sockaddr *)0, RTF_GATEWAY | RTF_HOST,
		  (struct sockaddr *)&icmpgw, (struct rtentry **)0);
		pfctlinput(PRC_REDIRECT_HOST, (struct sockaddr *)&icmpsrc);
		break;

#ifdef __riscos
	case ICMP_MASKREPLY:
		if (m->m_pkthdr.rcvif->if_flags & IFF_NEED_MASK)
		{
		        extern int whoamimask;
#ifdef OldCode
		    	do_maskreply(ifp, icp);
		    	ifp->if_flags &= ~IFF_NEED_MASK;
#else
			struct in_ifaddr *ia;

			/*
			 * 920430 KWelton (RISC iX fix)
			 *
			 * this routine is called under interrupt, and is
			 * therefore forbidden from calling in_control():
			 * set netmask and reset interface address
			 * directly from this routine.
			 */
			ia = (struct in_ifaddr *)ifaof_ifpforaddr(
			    	(struct sockaddr *)&icmpdst, m->m_pkthdr.rcvif);
			if (ia == NULL) {
			    /*
			     * interface is running, therefore should
			     * have an address declared.
			     */
				panic("icmp_input: ia");
				return;
			}

                        ia->ia_sockmask.sin_len = sizeof ia->ia_sockmask;
                        ia->ia_sockmask.sin_family = AF_INET;
                        ia->ia_sockmask.sin_addr.s_addr = icp->icmp_mask;
			ia->ia_subnetmask = ntohl(icp->icmp_mask);

			/*
			 * Re-set the interface INET address, this
			 * re-calculates the broadcast address
			 */
#ifdef DEBUG
			if( in_ifinit(m->m_pkthdr.rcvif, ia, satosin(&(ia->ia_addr)), 1) )
			    Printf("\021\01ICMP_MASKREPLY: unable to reset address %08x\n",
				   ntohl((satosin(&(ia->ia_addr)))->sin_addr.s_addr));
#else
			(void)in_ifinit(m->m_pkthdr.rcvif, ia, satosin(&(ia->ia_addr)), 1);
#endif

			m->m_pkthdr.rcvif->if_flags &= ~IFF_NEED_MASK;
			wakeup(&whoamimask);
#endif
		}
	/* And fall through, to pass it on... */
#endif /* __riscos */

	/*
	 * No kernel processing for the following;
	 * just fall through to send to raw listener.
	 */
	case ICMP_ECHOREPLY:
	case ICMP_ROUTERADVERT:
	case ICMP_ROUTERSOLICIT:
	case ICMP_TSTAMPREPLY:
	case ICMP_IREQREPLY:
	default:
		break;
	}

raw:
#ifdef NotYet
	rip_input(m, hlen);
#else
        rip_input(m);
#endif
	return;

freeit:
	m_freem(m);
}

/*
 * Reflect the ip packet back to the source
 */
static void
icmp_reflect(m)
	struct mbuf *m;
{
	register struct ip *ip = mtod(m, struct ip *);
	register struct in_ifaddr *ia;
	struct in_addr t;
	struct mbuf *opts = 0;
	int optlen = (ip->ip_hl << 2) - sizeof(struct ip);

	if (!in_canforward(ip->ip_src) &&
	    ((ntohl(ip->ip_src.s_addr) & IN_CLASSA_NET) !=
	     (IN_LOOPBACKNET << IN_CLASSA_NSHIFT))) {
		m_freem(m);	/* Bad return address */
		goto done;	/* Ip_output() will check for broadcast */
	}
	t = ip->ip_dst;
	ip->ip_dst = ip->ip_src;

	/*
	 * If the incoming packet was addressed directly to us,
	 * use dst as the src for the reply.  Otherwise (broadcast
	 * or anonymous), use the address which corresponds
	 * to the incoming interface.
	 */
	for (ia = in_ifaddr; ia; ia = ia->ia_next) {
		if (t.s_addr == IA_SIN(ia)->sin_addr.s_addr)
			break;
		if (ia->ia_ifp && (ia->ia_ifp->if_flags & IFF_BROADCAST) &&
		    t.s_addr == satosin(&ia->ia_broadaddr)->sin_addr.s_addr)
			break;
	}
	icmpdst.sin_addr = t;
	if (ia == (struct in_ifaddr *)0)
		ia = (struct in_ifaddr *)ifaof_ifpforaddr(
			(struct sockaddr *)&icmpdst, m->m_pkthdr.rcvif);
	/*
	 * The following happens if the packet was not addressed to us,
	 * and was received on an interface with no IP address.
	 */
	if (ia == (struct in_ifaddr *)0)
		ia = in_ifaddr;
	t = IA_SIN(ia)->sin_addr;
	ip->ip_src = t;
	ip->ip_ttl = MAXTTL;

	if (optlen > 0) {
		register u_char *cp;
		int opt, cnt;
		u_int len;

		/*
		 * Retrieve any source routing from the incoming packet;
		 * add on any record-route or timestamp options.
		 */
		cp = (u_char *) (ip + 1);
		if ((opts = ip_srcroute()) == 0 &&
		    (opts = ALLOC_S(MINCONTIG, NULL))) {
		        opts->m_type = MT_HEADER;
			opts->m_len = sizeof(struct in_addr);
			mtod(opts, struct in_addr *)->s_addr = 0;
		}
		if (opts) {
#ifdef DEBUG
			if( DODEBUG(DBGICMP) )
			    Printf("icmp_reflect optlen %d rt %d => ",
				   optlen, opts->m_len);
#endif
		    for (cnt = optlen; cnt > 0; cnt -= len, cp += len) {
			    opt = cp[IPOPT_OPTVAL];
			    if (opt == IPOPT_EOL)
				    break;
			    if (opt == IPOPT_NOP)
				    len = 1;
			    else {
				    len = cp[IPOPT_OLEN];
				    if (len == 0 || len > cnt)
					    break;
			    }
			    /*
			     * should check for overflow, but it "can't happen"
			     */
			    if (opt == IPOPT_RR || opt == IPOPT_TS ||
				opt == IPOPT_SECURITY) {
				    bcopy((caddr_t)cp,
					mtod(opts, caddr_t) + opts->m_len, len);
				    opts->m_len += len;
			    }
		    }
		    /* Terminate & pad, if necessary */
		    cnt = opts->m_len % 4;
		    if (cnt) {
		    	for (; cnt < 4; cnt++) {
				*(mtod(opts, caddr_t) + opts->m_len) =
				    IPOPT_EOL;
				opts->m_len++;
			}
		    }
#ifdef DEBUG
			if( DODEBUG(DBGICMP) )
			    Printf("%d\n", opts->m_len);
#endif
		}
		/*
		 * Now strip out original options by copying rest of first
		 * mbuf's data back, and adjust the IP length.
		 */
		ip->ip_len -= optlen;
		ip->ip_hl = sizeof(struct ip) >> 2;
		m->m_len -= optlen;
		if (m->m_flags & M_PKTHDR)
			m->m_pkthdr.len -= optlen;
		optlen += sizeof(struct ip);
		bcopy((caddr_t)ip + optlen, (caddr_t)(ip + 1),
		    (unsigned)(m->m_len - sizeof(struct ip)));
	}
	m->m_flags &= ~(M_BCAST|M_MCAST);
	icmp_send(m, opts);
done:
	if (opts)
		(void)m_free(opts);
}

/*
 * Send an icmp packet back to the ip level,
 * after supplying a checksum.
 */
static void
icmp_send(m, opts)
	register struct mbuf *m;
	struct mbuf *opts;
{
	register struct ip *ip = mtod(m, struct ip *);
	register int hlen;
	register struct icmp *icp;
	struct route ro;

	hlen = ip->ip_hl << 2;
	m->m_off += hlen;
	m->m_len -= hlen;
	icp = mtod(m, struct icmp *);
	icp->icmp_cksum = 0;
	icp->icmp_cksum = in_cksum(m, ip->ip_len - hlen);
	m->m_off -= hlen;
	m->m_len += hlen;
#ifdef DEBUG
	if (DODEBUG(DBGICMP)) {
		char buf[4 * sizeof "123"];
		strcpy(buf, inet_ntoa(ip->ip_dst));
		Printf("icmp_send dst %s src %s\n",
		       buf, inet_ntoa(ip->ip_src));
	}
#endif
	bzero(&ro, sizeof ro);
#ifdef __riscos
	(void) ip_output(m, opts, &ro, send_flags, NULL);
#else
	(void) ip_output(m, opts, &ro, 0, NULL);
#endif
	if (ro.ro_rt)
		RTFREE(ro.ro_rt);
}


n_time
iptime()
{
	u_long t;
	struct timeval atv;

	microtime(&atv);
	t = (atv.tv_sec % (24*60*60)) * 1000 + atv.tv_usec / 1000;
	return (htonl(t));
}

#if 1
/*
 * Return the next larger or smaller MTU plateau (table from RFC 1191)
 * given current value MTU.  If DIR is less than zero, a larger plateau
 * is returned; otherwise, a smaller value is returned.
 */
static int
ip_next_mtu(mtu, dir)
	int mtu;
	int dir;
{
	static int mtutab[] = {
		65535, 32000, 17914, 8166, 4352, 2002, 1492, 1006, 508, 296,
		68, 0
	};
	int i;

	for (i = 0; i < (sizeof mtutab) / (sizeof mtutab[0]); i++) {
		if (mtu >= mtutab[i])
			break;
	}

	if (dir < 0) {
		if (i == 0) {
			return 0;
		} else {
			return mtutab[i - 1];
		}
	} else {
		if (mtutab[i] == 0) {
			return 0;
		} else if(mtu > mtutab[i]) {
			return mtutab[i];
		} else {
			return mtutab[i + 1];
		}
	}
}
#endif
@


4.5
log
@Added new FreeBSD sysctl handling using linker magic.
A few new sysctls added as a result.
SO_TIMESTAMP now gives real time, not Internet's internal time.
DHCP/BOOTP parsing picks up URL option and pops it into Inet$URL.
Requires TCPIPLibs 5.25 and link 5.12.

Version 5.31. Tagged as 'Internet-5_31'
@
text
@a763 7
#ifdef __riscos
	/* microtime may not be set correctly if no real-time clock -
	 * instead use realtime, which will check again, in case
	 * we've found a time server.
	 */
	atv.tv_sec = realtime(&atv.tv_usec);
#else
a764 1
#endif
@


4.4
log
@Added Service_InternetStatus_DuplicateIPAddress to allow graceful behaviour
in the event of a DHCP address clash.
When configuring an interface as a result of DHCP/BOOTP - do a two stage
ARP transmission - first a "gentle" probe from 0.0.0.0 to check, then a
broadcast ARP reply to update everyone's ARP caches if there is no response.
If the probe shows a duplicate, the DHCP module can catch the service call
and send a DHCPDECLINE.
Changed to not respond to ICMP or ARP packets on an interface in the process
of DHCP/BOOTP/RevARP booting. Solves problem of DHCP server probing the
address it wants to give us and having us respond, making it think it's in
use.

Version 5.26. Tagged as 'Internet-5_26'
@
text
@d39 1
d69 3
d73 30
a815 27

int
icmp_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR); /* XXX overloaded */

	switch (name[0]) {
	case ICMPCTL_MASKREPL:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &icmpmaskrepl));
	case ICMPCTL_STATS:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &icmpstat,
					sizeof icmpstat));
	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
}

/* EOF ip_icmp.c */
@


4.3
log
@IP timestamps and TCP sequence numbers now generated from system real-time
clock, rather than local monotonic copy. This gives a better chance of
uniqueness between reboots, as we should have found time from a server
at some stage.
Local clock initialised from system clock with centisecond accuracy.
IP firewalling and multicast routing disabled by default - specify them in
components file if really wanted.

Version 5.23. Tagged as 'Internet-5_23'
@
text
@d238 9
@


4.2
log
@Version Spinner_B7 taken
@
text
@d721 7
d729 1
@


4.1
log
@Initial revision
@
text
@d1 3
a3 1
/* -*-C-*-
d5 15
a19 2
 * $Header: /ax/networking:Internet/netinet/ip_icmp.c:networking  1.3  $
 * $Source: /ax/networking:Internet/netinet/ip_icmp.c: $
d21 11
a31 37
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
 *
 * $Log:	ip_icmp.c,v $
 * Revision 1.3  95/02/28  18:15:36  kwelton
 * Removed the definition of ICMPPRINTFS - this removes a number
 * of unwanted and unused debug messages.
 * 
 * Revision 1.2  95/01/24  15:48:11  kwelton
 * Two changes:
 * 
 * 1)  Restored the use of send_flags in icmp_send() this was (stupidly)
 *     removed when request_netmask() was removed from this file during
 *     the original RISC OS port.
 * 
 * 2)  Added an old RISC iX fix to icmp_input: when the netmask is changed
 *     on an ICMP_MASKREPLY, the interface address must be re-declared to
 *     allow the broadcast address to be calculated correctly.
 * 
 * Revision 1.1  94/12/02  11:16:57  kwelton
 * Initial revision
 * 
 */
/*
 * Copyright (c) 1983, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d34 1
d39 1
d44 1
d54 1
d58 2
a60 5
#if 0
# define ICMPPRINTFS
#endif

#ifdef ICMPPRINTFS
d66 4
d73 6
d85 3
a87 3
/*VARARGS4*/
icmp_error(oip, type, code, ifp, dest)
	struct ip *oip;
d89 2
a90 2
	struct ifnet *ifp;
	struct in_addr dest;
d92 1
a95 1
	struct ip *nip;
d100 1
a100 1
		printf("icmp_error(%x, %d, %d)\n", oip, type, code);
d110 1
a110 2
		goto free;
#ifdef OldCode
d112 1
a112 1
	  dtom(oip)->m_len >= oiplen + ICMP_MINLEN &&
d115 1
a115 10
		goto free;
	}
#else
	if (oip->ip_p == IPPROTO_ICMP && type != ICMP_REDIRECT &&
	    DTOM(oip)->m_len >= oiplen + ICMP_MINLEN &&
	    !ICMP_INFOTYPE(((struct icmp *)((caddr_t)oip +
					    oiplen))->icmp_type))
	{
	    icmpstat.icps_oldicmp++;
	    goto free;
d117 3
a119 2
#endif

d123 1
a123 2
#ifdef OldCode
	m = m_get(M_DONTWAIT, MT_HEADER);
d125 1
a125 13
		goto free;
#else
	if( (m = ALLOC_S(MINCONTIG, NULL)) == NULL )
	{
#ifdef DEBUG
	    if( DODEBUG(DBGMMAN) )
		Printf("icmp_error: ALLOC_S failed\n");
#endif
	    goto free;
	}

	m->m_type = MT_HEADER;
#endif
d128 1
a128 1
	m->m_off = MAXOFF(m) - m->m_len;
d137 2
a138 2
		icp->icmp_gwaddr = dest;
	else
d140 11
a150 3
	if (type == ICMP_PARAMPROB) {
		icp->icmp_pptr = code;
		code = 0;
d152 1
d162 1
a162 3
	if (m->m_len + oiplen > MLEN(m))
		oiplen = sizeof(struct ip);
	if (m->m_len + oiplen > MLEN(m)) {
a163 2
		return;
	}
d166 2
d169 1
a169 1
	bcopy((caddr_t)oip, (caddr_t)nip, oiplen);
d173 2
a174 1
	icmp_reflect(nip, ifp);
d176 2
a177 6
free:
#ifdef OldCode
	m_freem(dtom(oip));
#else
	DTOM_FREEM(oip);
#endif
d180 3
a182 5
static struct sockproto icmproto = { AF_INET, IPPROTO_ICMP };
static struct sockaddr_in icmpsrc = { AF_INET };
static struct sockaddr_in icmpdst = { AF_INET };
static struct sockaddr_in icmpgw = { AF_INET };
struct in_ifaddr *ifptoia();
d187 2
a188 1
icmp_input(m, ifp)
d190 1
a190 1
	struct ifnet *ifp;
d194 1
a194 1
	int icmplen = ip->ip_len, hlen = ip->ip_hl << 2;
d197 2
a198 3
	int (*ctlfunc)(), code;
	extern u_char ip_protox[];
	extern struct in_addr in_makeaddr();
d204 7
a210 3
#ifdef ICMPPRINTFS
	if (icmpprintfs)
		printf("icmp_input from %x, len %d\n", ip->ip_src, icmplen);
d214 1
a214 1
		goto free;
d216 1
a216 2

	i = hlen + MIN(icmplen, ICMP_ADVLENMIN);
d227 1
a227 1
		goto free;
d232 6
a237 1
#ifdef ICMPPRINTFS
a240 5
	if (icmpprintfs)
		printf("icmp_input, type %d code %d\n", icp->icmp_type,
		    icp->icmp_code);
#endif

d248 29
a276 3
		if (code > 5)
			goto badcode;
		code += PRC_UNREACH_NET;
d286 1
a286 1
		if (code)
d299 2
a300 2
		icp->icmp_ip.ip_len = ntohs((u_short)icp->icmp_ip.ip_len);
		if (icmplen < ICMP_ADVLENMIN || icmplen < ICMP_ADVLEN(icp)) {
d302 1
a302 1
			goto free;
d304 7
a310 3
#ifdef ICMPPRINTFS
		if (icmpprintfs)
			printf("deliver to protocol %d\n", icp->icmp_ip.ip_p);
d313 48
a360 2
		if (ctlfunc = inetsw[ip_protox[icp->icmp_ip.ip_p]].pr_ctlinput)
			(*ctlfunc)(code, (struct sockaddr *)&icmpsrc);
d381 2
d384 3
a386 2
#define satosin(sa)	((struct sockaddr_in *)(sa))
		if (in_netof(ip->ip_src) == 0 && (ia = ifptoia(ifp)))
d391 2
d395 2
a396 6
	    {
		struct ifaddr *ifa;

		if (icmplen < ICMP_MASKLEN ||
		    (ifp->if_flags & IFF_NEED_MASK) ||
		    (ia = ifptoia(ifp)) == 0)
a397 1

d399 2
a400 5
		 * XXX
		 *
		 * ignore requests from local machine, these
		 * arrive on interfaces which can receive
		 * their own broadcast packets.
d402 3
a404 4
		for( ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next )
		    if (satosin(&ifa->ifa_addr)->sin_addr.s_addr ==
			ip->ip_src.s_addr)
			return;
d406 14
d421 1
a421 2
		icp->icmp_mask = htonl(ia->ia_subnetmask);

d432 1
a432 1
		icmp_reflect(ip, ifp);
a433 1
	    }
d436 4
a439 1
		if (icmplen < ICMP_ADVLENMIN || icmplen < ICMP_ADVLEN(icp)) {
d452 7
a458 21
#ifdef	ICMPPRINTFS
		if (icmpprintfs)
			printf("redirect dst %x to %x\n", icp->icmp_ip.ip_dst,
				icp->icmp_gwaddr);
#endif
		if (code == ICMP_REDIRECT_NET || code == ICMP_REDIRECT_TOSNET) {
			icmpsrc.sin_addr =
			 in_makeaddr(in_netof(icp->icmp_ip.ip_dst), INADDR_ANY);
			rtredirect((struct sockaddr *)&icmpsrc,
			  (struct sockaddr *)&icmpdst, RTF_GATEWAY,
			  (struct sockaddr *)&icmpgw);
			icmpsrc.sin_addr = icp->icmp_ip.ip_dst;
			pfctlinput(PRC_REDIRECT_NET,
			  (struct sockaddr *)&icmpsrc);
		} else {
			icmpsrc.sin_addr = icp->icmp_ip.ip_dst;
			rtredirect((struct sockaddr *)&icmpsrc,
			  (struct sockaddr *)&icmpdst, RTF_GATEWAY | RTF_HOST,
			  (struct sockaddr *)&icmpgw);
			pfctlinput(PRC_REDIRECT_HOST,
			  (struct sockaddr *)&icmpsrc);
d460 7
d469 1
d471 1
a471 1
		if (ifp->if_flags & IFF_NEED_MASK)
d473 1
d488 3
a490 1
			if( (ia = ifptoia(ifp)) == NULL )
d495 7
a501 2
			    panic("icmp_input: ia");

d509 1
a509 1
			if( in_ifinit(ifp, ia, satosin(&(ia->ia_addr))) )
d513 1
a513 1
			(void)in_ifinit(ifp, ia, satosin(&(ia->ia_addr)));
d516 2
a517 1
			ifp->if_flags &= ~IFF_NEED_MASK;
d521 1
d528 2
a531 1

d537 5
a541 4
	icmpsrc.sin_addr = ip->ip_src;
	icmpdst.sin_addr = ip->ip_dst;
	raw_input(m, &icmproto, (struct sockaddr *)&icmpsrc,
	    (struct sockaddr *)&icmpdst);
d544 1
a544 2
free:
#ifdef OldCode
a545 3
#else
	FREEM(m);
#endif
d551 3
a553 3
icmp_reflect(ip, ifp)
	register struct ip *ip;
	struct ifnet *ifp;
d555 1
d558 1
a558 1
	struct mbuf *opts = 0, *ip_srcroute();
a559 1
	register struct mbuf *m;
d561 6
a566 8
/*
 * this line added by ksr 3.4.89.
 */
#ifdef OldCode
	m = dtom(ip);
#else
	m = DTOM(ip);
#endif
d579 1
a579 1
		if ((ia->ia_ifp->if_flags & IFF_BROADCAST) &&
d583 1
d585 6
a590 1
		ia = ifptoia(ifp);
a606 1
#ifdef OldCode
d608 2
a609 1
		    (opts = m_get(M_DONTWAIT, MT_HEADER))) {
d613 1
a613 9
#else
		if( (opts = ip_srcroute()) == 0 )
		{
		    if( (opts = ALLOC_S(MINCONTIG, NULL)) != NULL )
		    {
			opts->m_type = MT_HEADER;
			opts->m_len = sizeof(struct in_addr);
			mtod(opts, struct in_addr *)->s_addr = 0;
		    }
d615 3
a617 10
		    else if( DODEBUG(DBGMMAN) )
			Printf("icmp_reflect: ALLOC_S failed\n");
#endif
		}
#endif
		if (opts) {
#ifdef ICMPPRINTFS
		    if (icmpprintfs)
			    printf("icmp_reflect optlen %d rt %d => ",
				optlen, opts->m_len);
d633 2
a634 1
			    if (opt == IPOPT_RR || opt == IPOPT_TS) {
d640 8
a647 3
		    if (opts->m_len % 4 != 0) {
			    *(mtod(opts, caddr_t) + opts->m_len) = IPOPT_EOL;
			    opts->m_len++;
d649 3
a651 3
#ifdef ICMPPRINTFS
		    if (icmpprintfs)
			    printf("%d\n", opts->m_len);
d661 2
d665 1
a665 1
		    m->m_len - sizeof(struct ip));
d667 3
a669 1
	icmp_send(ip, opts);
d671 1
a671 19
	{
#ifdef OldCode
	    (void)m_free(opts);
#else
	    FREE(opts);
#endif
	}
}

struct in_ifaddr *
ifptoia(ifp)
	struct ifnet *ifp;
{
	register struct in_ifaddr *ia;

	for (ia = in_ifaddr; ia; ia = ia->ia_next)
		if (ia->ia_ifp == ifp)
			return (ia);
	return ((struct in_ifaddr *)0);
d678 3
a680 2
icmp_send(ip, opts)
	register struct ip *ip;
d683 1
d686 1
a686 1
	register struct mbuf *m;
a687 5
#ifdef OldCode
	m = dtom(ip);
#else
	m = DTOM(ip);
#endif
d696 13
a708 3
#ifdef ICMPPRINTFS
	if (icmpprintfs)
		printf("icmp_send dst %x src %x\n", ip->ip_dst, ip->ip_src);
d710 3
a713 2
	(void) ip_output(m, opts, (struct route *)0, send_flags);
}
d718 1
a719 1
	u_long t;
a720 4
#ifdef __riscos
	atv.tv_sec = time(0);
	t = (atv.tv_sec % (24*60*60)) * 1000;
#else
d723 41
d765 24
a788 1
	return (htonl(t));
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d1 27
d29 2
a30 18
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d32 11
a42 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a44 1

a48 1
#include "sys/proc.h"
a52 1
#include "sys/sysctl.h"
a61 1
#include "netinet/ip_var.h"
a64 2
#include "module.h"
#include "debug.h"
d66 5
a75 4

struct	icmpstat icmpstat;
int	icmpmaskrepl = 0;
#ifdef ICMPPRINTFS
a78 6
static void	icmp_reflect(struct mbuf *);
static void	icmp_send(struct mbuf *, struct mbuf *);
static int	ip_next_mtu(int, int);

extern	struct protosw inetsw[];

d85 3
a87 3
void
icmp_error(n, type, code, dest, destifp)
	struct mbuf *n;
d89 2
a90 2
	n_long dest;
	struct ifnet *destifp;
a91 1
	register struct ip *oip = mtod(n, struct ip *), *nip;
d95 1
d100 1
a100 1
		printf("icmp_error(%p, %x, %d)\n", oip, type, code);
d110 2
a111 1
		goto freeit;
d113 1
a113 1
	  n->m_len >= oiplen + ICMP_MINLEN &&
d116 10
a125 1
		goto freeit;
d127 2
a128 3
	/* Don't send error in response to a multicast or broadcast packet */
	if (n->m_flags & (M_BCAST|M_MCAST))
		goto freeit;
d132 2
a133 1
	m = m_gethdr(M_DONTWAIT, MT_HEADER);
d135 13
a147 1
		goto freeit;
d150 1
a150 1
	MH_ALIGN(m, m->m_len);
d159 2
a160 2
		icp->icmp_gwaddr.s_addr = dest;
	else {
d162 3
a164 11
		/*
		 * The following assignments assume an overlay with the
		 * zeroed icmp_void field.
		 */
		if (type == ICMP_PARAMPROB) {
			icp->icmp_pptr = code;
			code = 0;
		} else if (type == ICMP_UNREACH &&
			code == ICMP_UNREACH_NEEDFRAG && destifp) {
			icp->icmp_nextmtu = htons(destifp->if_mtu);
		}
a165 1

d175 3
a177 1
	if (m->m_off - sizeof(struct ip) < m->m_inioff)
d179 2
a182 2
	m->m_pkthdr.len = m->m_len;
	m->m_pkthdr.rcvif = n->m_pkthdr.rcvif;
d184 1
a184 1
	bcopy((caddr_t)oip, (caddr_t)nip, sizeof(struct ip));
d188 1
a188 2
	nip->ip_tos = 0;
	icmp_reflect(m);
d190 6
a195 2
freeit:
	m_freem(n);
d198 5
a202 3
static struct sockaddr_in icmpsrc = { sizeof (struct sockaddr_in), AF_INET };
static struct sockaddr_in icmpdst = { sizeof (struct sockaddr_in), AF_INET };
static struct sockaddr_in icmpgw = { sizeof (struct sockaddr_in), AF_INET };
d207 1
a207 2
void
icmp_input(m, hlen)
d209 1
a209 1
	int hlen;
d213 1
a213 1
	int icmplen = ip->ip_len;
d216 3
a218 2
	void (*ctlfunc)(int, struct sockaddr *, void *);
	int code;
d224 3
a226 7
#ifdef DEBUG
	if( DODEBUG(DBGICMP) ) {
		char buf[4 * sizeof "123"];
		strcpy(buf, inet_ntoa(ip->ip_src));
		Printf("icmp_input from %s to %s, len %d\n",
		       buf, inet_ntoa(ip->ip_dst), icmplen);
	}
d230 1
a230 1
		goto freeit;
d232 2
a233 1
	i = hlen + min(icmplen, ICMP_ADVLENMIN);
d244 1
a244 1
		goto freeit;
d249 1
a249 6
#ifdef DEBUG
	if( DODEBUG(DBGICMP) )
	    	Printf("icmp_input, type %d code %d\n", icp->icmp_type,
	    	    icp->icmp_code);
#endif

d253 5
d265 3
a267 29
		switch (code) {
			case ICMP_UNREACH_NET:
			case ICMP_UNREACH_HOST:
			case ICMP_UNREACH_PROTOCOL:
			case ICMP_UNREACH_PORT:
			case ICMP_UNREACH_SRCFAIL:
				code += PRC_UNREACH_NET;
				break;

			case ICMP_UNREACH_NEEDFRAG:
				code = PRC_MSGSIZE;
				break;

			case ICMP_UNREACH_NET_UNKNOWN:
			case ICMP_UNREACH_NET_PROHIB:
			case ICMP_UNREACH_TOSNET:
				code = PRC_UNREACH_NET;
				break;

			case ICMP_UNREACH_HOST_UNKNOWN:
			case ICMP_UNREACH_ISOLATED:
			case ICMP_UNREACH_HOST_PROHIB:
			case ICMP_UNREACH_TOSHOST:
				code = PRC_UNREACH_HOST;
				break;

			default:
				goto badcode;
		}
d277 1
a277 1
		if (code > 1)
d290 2
a291 2
		if (icmplen < ICMP_ADVLENMIN || icmplen < ICMP_ADVLEN(icp) ||
		    icp->icmp_ip.ip_hl < (sizeof(struct ip) >> 2)) {
d293 1
a293 1
			goto freeit;
d295 3
a297 7
		NTOHS(icp->icmp_ip.ip_len);
		/* Discard ICMP's in response to multicast packets */
		if (IN_MULTICAST(ntohl(icp->icmp_ip.ip_dst.s_addr)))
			goto badcode;
#ifdef DEBUG
		if( DODEBUG(DBGICMP) )
		    Printf("deliver to protocol %d\n", icp->icmp_ip.ip_p);
d300 2
a301 48
#if 1
		/*
		 * MTU discovery:
		 * If we got a needfrag and there is a host route to the
		 * original destination, and the MTU is not locked, then
		 * set the MTU in the route to the suggested new value
		 * (if given) and then notify as usual.  The ULPs will
		 * notice that the MTU has changed and adapt accordingly.
		 * If no new MTU was suggested, then we guess a new one
		 * less than the current value.  If the new MTU is
		 * unreasonably small (arbitrarily set at 296), then
		 * we reset the MTU to the interface value and enable the
		 * lock bit, indicating that we are no longer doing MTU
		 * discovery.
		 */
		if (code == PRC_MSGSIZE) {
			struct rtentry *rt;
			int mtu;

			rt = rtalloc1((struct sockaddr *)&icmpsrc, 0,
				      RTF_CLONING | RTF_PRCLONING);
			if (rt && (rt->rt_flags & RTF_HOST)
			    && !(rt->rt_rmx.rmx_locks & RTV_MTU)) {
				mtu = ntohs(icp->icmp_nextmtu);
				if (!mtu)
					mtu = ip_next_mtu(rt->rt_rmx.rmx_mtu,
							  1);
#ifdef DEBUG_MTUDISC
				Printf("MTU for %s reduced to %d\n",
					inet_ntoa(icmpsrc.sin_addr), mtu);
#endif
				if (mtu < 296) {
					/* rt->rt_rmx.rmx_mtu =
						rt->rt_ifp->if_mtu; */
					rt->rt_rmx.rmx_locks |= RTV_MTU;
				} else if (rt->rt_rmx.rmx_mtu > mtu) {
					rt->rt_rmx.rmx_mtu = mtu;
				}
			}
			if (rt)
				RTFREE(rt);
		}

#endif
		ctlfunc = inetsw[ip_protox[icp->icmp_ip.ip_p]].pr_ctlinput;
		if (ctlfunc)
			(*ctlfunc)(code, (struct sockaddr *)&icmpsrc,
				    (void *)&icp->icmp_ip);
a321 2
#ifdef __riscos
#ifdef TODO
d323 2
a324 3
		if (in_netof(ip->ip_src) == 0 &&
		    (ia = (struct in_ifaddr *)ifaof_ifpforaddr(
			    (struct sockaddr *)&icmpdst, m->m_pkthdr.rcvif)))
a328 2
#endif
#endif
d331 6
a336 2
#define satosin(sa)	((struct sockaddr_in *)(sa))
		if (icmpmaskrepl == 0)
d338 1
d340 5
a344 2
		 * We are not able to respond with all ones broadcast
		 * unless we receive it over a point-to-point interface.
d346 4
a349 3
		if (icmplen < ICMP_MASKLEN)
			break;
		switch (ip->ip_dst.s_addr) {
d351 2
a352 4
		case INADDR_BROADCAST:
		case INADDR_ANY:
			icmpdst.sin_addr = ip->ip_src;
			break;
a353 11
		default:
			icmpdst.sin_addr = ip->ip_dst;
		}
		ia = (struct in_ifaddr *)ifaof_ifpforaddr(
			    (struct sockaddr *)&icmpdst, m->m_pkthdr.rcvif);
		if (ia == 0)
			break;
		if (ia->ia_ifp == 0)
			break;
		icp->icmp_type = ICMP_MASKREPLY;
		icp->icmp_mask = ia->ia_sockmask.sin_addr.s_addr;
d364 1
a364 1
		icmp_reflect(m);
d366 1
d369 1
a369 4
		if (code > 3)
			goto badcode;
		if (icmplen < ICMP_ADVLENMIN || icmplen < ICMP_ADVLEN(icp) ||
		    icp->icmp_ip.ip_hl < (sizeof(struct ip) >> 2)) {
d382 21
a402 7
#ifdef DEBUG
		if( DODEBUG(DBGICMP) ) {
			char buf[4 * sizeof "123"];
			strcpy(buf, inet_ntoa(icp->icmp_ip.ip_dst));

		    	Printf("redirect dst %s to %s\n",
			   buf, inet_ntoa(icp->icmp_gwaddr));
a403 7
#endif
		icmpsrc.sin_addr = icp->icmp_ip.ip_dst;
		rtredirect((struct sockaddr *)&icmpsrc,
		  (struct sockaddr *)&icmpdst,
		  (struct sockaddr *)0, RTF_GATEWAY | RTF_HOST,
		  (struct sockaddr *)&icmpgw, (struct rtentry **)0);
		pfctlinput(PRC_REDIRECT_HOST, (struct sockaddr *)&icmpsrc);
a405 1
#ifdef __riscos
d407 1
a407 1
		if (m->m_pkthdr.rcvif->if_flags & IFF_NEED_MASK)
a408 1
		        extern int whoamimask;
d423 1
a423 3
			ia = (struct in_ifaddr *)ifaof_ifpforaddr(
			    	(struct sockaddr *)&icmpdst, m->m_pkthdr.rcvif);
			if (ia == NULL) {
d428 2
a429 7
				panic("icmp_input: ia");
				return;
			}

                        ia->ia_sockmask.sin_len = sizeof ia->ia_sockmask;
                        ia->ia_sockmask.sin_family = AF_INET;
                        ia->ia_sockmask.sin_addr.s_addr = icp->icmp_mask;
d437 1
a437 1
			if( in_ifinit(m->m_pkthdr.rcvif, ia, satosin(&(ia->ia_addr)), 1) )
d441 1
a441 1
			(void)in_ifinit(m->m_pkthdr.rcvif, ia, satosin(&(ia->ia_addr)), 1);
d444 1
a444 2
			m->m_pkthdr.rcvif->if_flags &= ~IFF_NEED_MASK;
			wakeup(&whoamimask);
a447 1
#endif /* __riscos */
a453 2
	case ICMP_ROUTERADVERT:
	case ICMP_ROUTERSOLICIT:
d456 1
d462 4
a465 5
#ifdef NotYet
	rip_input(m, hlen);
#else
        rip_input(m);
#endif
d468 2
a469 1
freeit:
d471 3
d479 3
a481 3
static void
icmp_reflect(m)
	struct mbuf *m;
a482 1
	register struct ip *ip = mtod(m, struct ip *);
d485 1
a485 1
	struct mbuf *opts = 0;
d487 1
d489 8
a496 6
	if (!in_canforward(ip->ip_src) &&
	    ((ntohl(ip->ip_src.s_addr) & IN_CLASSA_NET) !=
	     (IN_LOOPBACKNET << IN_CLASSA_NSHIFT))) {
		m_freem(m);	/* Bad return address */
		goto done;	/* Ip_output() will check for broadcast */
	}
d509 1
a509 1
		if (ia->ia_ifp && (ia->ia_ifp->if_flags & IFF_BROADCAST) &&
a512 1
	icmpdst.sin_addr = t;
d514 1
a514 6
		ia = (struct in_ifaddr *)ifaof_ifpforaddr(
			(struct sockaddr *)&icmpdst, m->m_pkthdr.rcvif);
	/*
	 * The following happens if the packet was not addressed to us,
	 * and was received on an interface with no IP address.
	 */
d531 1
d533 10
a542 2
		    (opts = ALLOC_S(MINCONTIG, NULL))) {
		        opts->m_type = MT_HEADER;
d545 5
d551 1
d553 4
a556 4
#ifdef DEBUG
			if( DODEBUG(DBGICMP) )
			    Printf("icmp_reflect optlen %d rt %d => ",
				   optlen, opts->m_len);
d572 1
a572 2
			    if (opt == IPOPT_RR || opt == IPOPT_TS ||
				opt == IPOPT_SECURITY) {
d578 3
a580 8
		    /* Terminate & pad, if necessary */
		    cnt = opts->m_len % 4;
		    if (cnt) {
		    	for (; cnt < 4; cnt++) {
				*(mtod(opts, caddr_t) + opts->m_len) =
				    IPOPT_EOL;
				opts->m_len++;
			}
d582 3
a584 3
#ifdef DEBUG
			if( DODEBUG(DBGICMP) )
			    Printf("%d\n", opts->m_len);
a593 2
		if (m->m_flags & M_PKTHDR)
			m->m_pkthdr.len -= optlen;
d596 1
a596 1
		    (unsigned)(m->m_len - sizeof(struct ip)));
d598 1
a598 3
	m->m_flags &= ~(M_BCAST|M_MCAST);
	icmp_send(m, opts);
done:
d600 19
a618 1
		(void)m_free(opts);
d625 2
a626 3
static void
icmp_send(m, opts)
	register struct mbuf *m;
a628 1
	register struct ip *ip = mtod(m, struct ip *);
d631 1
a631 1
	struct route ro;
d633 5
d646 3
a648 7
#ifdef DEBUG
	if (DODEBUG(DBGICMP)) {
		char buf[4 * sizeof "123"];
		strcpy(buf, inet_ntoa(ip->ip_dst));
		Printf("icmp_send dst %s src %s\n",
		       buf, inet_ntoa(ip->ip_src));
	}
d650 2
a651 8
	bzero(&ro, sizeof ro);
#ifdef __riscos
	(void) ip_output(m, opts, &ro, send_flags, NULL);
#else
	(void) ip_output(m, opts, &ro, 0, NULL);
#endif
	if (ro.ro_rt)
		RTFREE(ro.ro_rt);
a653 1

d657 1
a658 1
	struct timeval atv;
d660 4
d666 1
a667 65
}

#if 1
/*
 * Return the next larger or smaller MTU plateau (table from RFC 1191)
 * given current value MTU.  If DIR is less than zero, a larger plateau
 * is returned; otherwise, a smaller value is returned.
 */
static int
ip_next_mtu(mtu, dir)
	int mtu;
	int dir;
{
	static int mtutab[] = {
		65535, 32000, 17914, 8166, 4352, 2002, 1492, 1006, 508, 296,
		68, 0
	};
	int i;

	for (i = 0; i < (sizeof mtutab) / (sizeof mtutab[0]); i++) {
		if (mtu >= mtutab[i])
			break;
	}

	if (dir < 0) {
		if (i == 0) {
			return 0;
		} else {
			return mtutab[i - 1];
		}
	} else {
		if (mtutab[i] == 0) {
			return 0;
		} else if(mtu > mtutab[i]) {
			return mtutab[i];
		} else {
			return mtutab[i + 1];
		}
	}
}
#endif

int
icmp_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR); /* XXX overloaded */

	switch (name[0]) {
	case ICMPCTL_MASKREPL:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &icmpmaskrepl));
	case ICMPCTL_STATS:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &icmpstat,
					sizeof icmpstat));
	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d3 1
a3 1
 * $Header: /ax/networking:Internet/netinet/ip_icmp.c:networking  1.5  $
a8 7
 * Revision 1.5  95/09/06  14:52:31  kwelton
 * Corrected a small typo (#ifdef DBEUG -> #ifdef DEBUG).
 * 
 * Revision 1.4  95/06/05  15:35:25  kwelton
 * Changed all ICMPPRINTFS debug to depend on #ifdef DEBUG, and to use
 * Printf() instead of printf().
 * 
a64 1
#include "debug.h"
d224 3
a226 4
#ifdef DEBUG
	if( DODEBUG(DBGICMP) )
	    Printf("icmp_input from %s, len %d\n",
		   inet_ntoa(ip->ip_src), icmplen);
a227 1

d249 1
a249 1
#ifdef DEBUG
d253 3
a255 3
	if( DODEBUG(DBGICMP) )
	    Printf("icmp_input, type %d code %d\n",
		   icp->icmp_type, icp->icmp_code);
d295 3
a297 3
#ifdef DEBUG
		if( DODEBUG(DBGICMP) )
		    Printf("deliver to protocol %d\n", icp->icmp_ip.ip_p);
d382 4
a385 5
#ifdef DEBUG
		if( DODEBUG(DBGICMP) )
		    Printf("redirect dst %s to %s\n",
			   inet_ntoa(icp->icmp_ip.ip_dst),
			   inet_ntoa(icp->icmp_gwaddr));
d553 4
a556 4
#ifdef DEBUG
			if( DODEBUG(DBGICMP) )
			    Printf("icmp_reflect optlen %d rt %d => ",
				   optlen, opts->m_len);
d582 3
a584 3
#ifdef DEBUG
			if( DODEBUG(DBGICMP) )
			    Printf("%d\n", opts->m_len);
d646 3
a648 4
#ifdef DEBUG
	if( DODEBUG(DBGICMP) )
	    Printf("icmp_send dst %s src %s\n",
		   inet_ntoa(ip->ip_dst), inet_ntoa(ip->ip_src));
@


4.1.7.2
log
@RCS log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@d3 1
a3 1
 * $Header: /ax/networking:Internet/netinet/ip_icmp.c:networking  1.5  $
a8 7
 * Revision 1.5  95/09/06  14:52:31  kwelton
 * Corrected a small typo (#ifdef DBEUG -> #ifdef DEBUG).
 * 
 * Revision 1.4  95/06/05  15:35:25  kwelton
 * Changed all ICMPPRINTFS debug to depend on #ifdef DEBUG, and to use
 * Printf() instead of printf().
 * 
a64 1
#include "debug.h"
d224 3
a226 4
#ifdef DEBUG
	if( DODEBUG(DBGICMP) )
	    Printf("icmp_input from %s, len %d\n",
		   inet_ntoa(ip->ip_src), icmplen);
a227 1

d249 1
a249 1
#ifdef DEBUG
d253 3
a255 3
	if( DODEBUG(DBGICMP) )
	    Printf("icmp_input, type %d code %d\n",
		   icp->icmp_type, icp->icmp_code);
d295 3
a297 3
#ifdef DEBUG
		if( DODEBUG(DBGICMP) )
		    Printf("deliver to protocol %d\n", icp->icmp_ip.ip_p);
d382 4
a385 5
#ifdef DEBUG
		if( DODEBUG(DBGICMP) )
		    Printf("redirect dst %s to %s\n",
			   inet_ntoa(icp->icmp_ip.ip_dst),
			   inet_ntoa(icp->icmp_gwaddr));
d553 4
a556 4
#ifdef DEBUG
			if( DODEBUG(DBGICMP) )
			    Printf("icmp_reflect optlen %d rt %d => ",
				   optlen, opts->m_len);
d582 3
a584 3
#ifdef DEBUG
			if( DODEBUG(DBGICMP) )
			    Printf("%d\n", opts->m_len);
d646 3
a648 4
#ifdef DEBUG
	if( DODEBUG(DBGICMP) )
	    Printf("icmp_send dst %s src %s\n",
		   inet_ntoa(ip->ip_dst), inet_ntoa(ip->ip_src));
@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d1 27
d29 2
a30 18
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d32 11
a42 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a43 2
 *	@@(#)ip_icmp.c	8.2 (Berkeley) 1/4/94
 * $Id: ip_icmp.c,v 1.20 1996/04/03 18:52:22 wollman Exp $
a44 1

a61 1
#include "netinet/ip_var.h"
a64 2
#include "module.h"
#include "debug.h"
d66 5
a75 4

struct	icmpstat icmpstat;
int	icmpmaskrepl = 0;
#ifdef ICMPPRINTFS
a78 6
static void	icmp_reflect(struct mbuf *);
static void	icmp_send(struct mbuf *, struct mbuf *);
static int	ip_next_mtu(int, int);

extern	struct protosw inetsw[];

d85 3
a87 3
void
icmp_error(n, type, code, dest, destifp)
	struct mbuf *n;
d89 2
a90 2
	n_long dest;
	struct ifnet *destifp;
a91 1
	register struct ip *oip = mtod(n, struct ip *), *nip;
d95 1
d100 1
a100 1
		printf("icmp_error(%p, %x, %d)\n", oip, type, code);
d110 2
a111 1
		goto freeit;
d113 1
a113 1
	  n->m_len >= oiplen + ICMP_MINLEN &&
d116 10
a125 1
		goto freeit;
d127 2
a128 3
	/* Don't send error in response to a multicast or broadcast packet */
	if (n->m_flags & (M_BCAST|M_MCAST))
		goto freeit;
d132 2
a133 1
	m = m_gethdr(M_DONTWAIT, MT_HEADER);
d135 13
a147 1
		goto freeit;
d150 1
a150 1
	MH_ALIGN(m, m->m_len);
d159 2
a160 2
		icp->icmp_gwaddr.s_addr = dest;
	else {
d162 3
a164 11
		/*
		 * The following assignments assume an overlay with the
		 * zeroed icmp_void field.
		 */
		if (type == ICMP_PARAMPROB) {
			icp->icmp_pptr = code;
			code = 0;
		} else if (type == ICMP_UNREACH &&
			code == ICMP_UNREACH_NEEDFRAG && destifp) {
			icp->icmp_nextmtu = htons(destifp->if_mtu);
		}
a165 1

d175 3
a177 1
	if (m->m_off - sizeof(struct ip) < m->m_inioff)
d179 2
a182 2
	m->m_pkthdr.len = m->m_len;
	m->m_pkthdr.rcvif = n->m_pkthdr.rcvif;
d184 1
a184 1
	bcopy((caddr_t)oip, (caddr_t)nip, sizeof(struct ip));
d188 1
a188 2
	nip->ip_tos = 0;
	icmp_reflect(m);
d190 6
a195 2
freeit:
	m_freem(n);
d198 5
a202 3
static struct sockaddr_in icmpsrc = { sizeof (struct sockaddr_in), AF_INET };
static struct sockaddr_in icmpdst = { sizeof (struct sockaddr_in), AF_INET };
static struct sockaddr_in icmpgw = { sizeof (struct sockaddr_in), AF_INET };
d207 1
a207 2
void
icmp_input(m, hlen)
d209 1
a209 1
	int hlen;
d213 1
a213 1
	int icmplen = ip->ip_len;
d216 3
a218 2
	void (*ctlfunc)(int, struct sockaddr *, void *);
	int code;
d224 3
a226 7
#ifdef DEBUG
	if( DODEBUG(DBGICMP) ) {
		char buf[4 * sizeof "123"];
		strcpy(buf, inet_ntoa(ip->ip_src));
		Printf("icmp_input from %s to %s, len %d\n",
		       buf, inet_ntoa(ip->ip_dst), icmplen);
	}
d230 1
a230 1
		goto freeit;
d232 2
a233 1
	i = hlen + min(icmplen, ICMP_ADVLENMIN);
d244 1
a244 1
		goto freeit;
d249 1
a249 6
#ifdef DEBUG
	if( DODEBUG(DBGICMP) )
	    	Printf("icmp_input, type %d code %d\n", icp->icmp_type,
	    	    icp->icmp_code);
#endif

d253 5
d265 3
a267 29
		switch (code) {
			case ICMP_UNREACH_NET:
			case ICMP_UNREACH_HOST:
			case ICMP_UNREACH_PROTOCOL:
			case ICMP_UNREACH_PORT:
			case ICMP_UNREACH_SRCFAIL:
				code += PRC_UNREACH_NET;
				break;

			case ICMP_UNREACH_NEEDFRAG:
				code = PRC_MSGSIZE;
				break;

			case ICMP_UNREACH_NET_UNKNOWN:
			case ICMP_UNREACH_NET_PROHIB:
			case ICMP_UNREACH_TOSNET:
				code = PRC_UNREACH_NET;
				break;

			case ICMP_UNREACH_HOST_UNKNOWN:
			case ICMP_UNREACH_ISOLATED:
			case ICMP_UNREACH_HOST_PROHIB:
			case ICMP_UNREACH_TOSHOST:
				code = PRC_UNREACH_HOST;
				break;

			default:
				goto badcode;
		}
d277 1
a277 1
		if (code > 1)
d290 2
a291 2
		if (icmplen < ICMP_ADVLENMIN || icmplen < ICMP_ADVLEN(icp) ||
		    icp->icmp_ip.ip_hl < (sizeof(struct ip) >> 2)) {
d293 1
a293 1
			goto freeit;
d295 3
a297 7
		NTOHS(icp->icmp_ip.ip_len);
		/* Discard ICMP's in response to multicast packets */
		if (IN_MULTICAST(ntohl(icp->icmp_ip.ip_dst.s_addr)))
			goto badcode;
#ifdef DEBUG
		if( DODEBUG(DBGICMP) )
		    Printf("deliver to protocol %d\n", icp->icmp_ip.ip_p);
d300 2
a301 48
#if 1
		/*
		 * MTU discovery:
		 * If we got a needfrag and there is a host route to the
		 * original destination, and the MTU is not locked, then
		 * set the MTU in the route to the suggested new value
		 * (if given) and then notify as usual.  The ULPs will
		 * notice that the MTU has changed and adapt accordingly.
		 * If no new MTU was suggested, then we guess a new one
		 * less than the current value.  If the new MTU is
		 * unreasonably small (arbitrarily set at 296), then
		 * we reset the MTU to the interface value and enable the
		 * lock bit, indicating that we are no longer doing MTU
		 * discovery.
		 */
		if (code == PRC_MSGSIZE) {
			struct rtentry *rt;
			int mtu;

			rt = rtalloc1((struct sockaddr *)&icmpsrc, 0,
				      RTF_CLONING | RTF_PRCLONING);
			if (rt && (rt->rt_flags & RTF_HOST)
			    && !(rt->rt_rmx.rmx_locks & RTV_MTU)) {
				mtu = ntohs(icp->icmp_nextmtu);
				if (!mtu)
					mtu = ip_next_mtu(rt->rt_rmx.rmx_mtu,
							  1);
#ifdef DEBUG_MTUDISC
				Printf("MTU for %s reduced to %d\n",
					inet_ntoa(icmpsrc.sin_addr), mtu);
#endif
				if (mtu < 296) {
					/* rt->rt_rmx.rmx_mtu =
						rt->rt_ifp->if_mtu; */
					rt->rt_rmx.rmx_locks |= RTV_MTU;
				} else if (rt->rt_rmx.rmx_mtu > mtu) {
					rt->rt_rmx.rmx_mtu = mtu;
				}
			}
			if (rt)
				RTFREE(rt);
		}

#endif
		ctlfunc = inetsw[ip_protox[icp->icmp_ip.ip_p]].pr_ctlinput;
		if (ctlfunc)
			(*ctlfunc)(code, (struct sockaddr *)&icmpsrc,
				    (void *)&icp->icmp_ip);
a321 2
#ifdef __riscos
#ifdef TODO
d323 2
a324 3
		if (in_netof(ip->ip_src) == 0 &&
		    (ia = (struct in_ifaddr *)ifaof_ifpforaddr(
			    (struct sockaddr *)&icmpdst, m->m_pkthdr.rcvif)))
a328 2
#endif
#endif
d331 6
a336 2
#define satosin(sa)	((struct sockaddr_in *)(sa))
		if (icmpmaskrepl == 0)
d338 1
d340 5
a344 2
		 * We are not able to respond with all ones broadcast
		 * unless we receive it over a point-to-point interface.
d346 4
a349 3
		if (icmplen < ICMP_MASKLEN)
			break;
		switch (ip->ip_dst.s_addr) {
d351 2
a352 4
		case INADDR_BROADCAST:
		case INADDR_ANY:
			icmpdst.sin_addr = ip->ip_src;
			break;
a353 11
		default:
			icmpdst.sin_addr = ip->ip_dst;
		}
		ia = (struct in_ifaddr *)ifaof_ifpforaddr(
			    (struct sockaddr *)&icmpdst, m->m_pkthdr.rcvif);
		if (ia == 0)
			break;
		if (ia->ia_ifp == 0)
			break;
		icp->icmp_type = ICMP_MASKREPLY;
		icp->icmp_mask = ia->ia_sockmask.sin_addr.s_addr;
d364 1
a364 1
		icmp_reflect(m);
d366 1
d369 1
a369 4
		if (code > 3)
			goto badcode;
		if (icmplen < ICMP_ADVLENMIN || icmplen < ICMP_ADVLEN(icp) ||
		    icp->icmp_ip.ip_hl < (sizeof(struct ip) >> 2)) {
d382 21
a402 7
#ifdef DEBUG
		if( DODEBUG(DBGICMP) ) {
			char buf[4 * sizeof "123"];
			strcpy(buf, inet_ntoa(icp->icmp_ip.ip_dst));

		    	Printf("redirect dst %s to %s\n",
			   buf, inet_ntoa(icp->icmp_gwaddr));
a403 7
#endif
		icmpsrc.sin_addr = icp->icmp_ip.ip_dst;
		rtredirect((struct sockaddr *)&icmpsrc,
		  (struct sockaddr *)&icmpdst,
		  (struct sockaddr *)0, RTF_GATEWAY | RTF_HOST,
		  (struct sockaddr *)&icmpgw, (struct rtentry **)0);
		pfctlinput(PRC_REDIRECT_HOST, (struct sockaddr *)&icmpsrc);
a405 1
#ifdef __riscos
d407 1
a407 1
		if (m->m_pkthdr.rcvif->if_flags & IFF_NEED_MASK)
a408 1
		        extern int whoamimask;
d423 1
a423 3
			ia = (struct in_ifaddr *)ifaof_ifpforaddr(
			    	(struct sockaddr *)&icmpdst, m->m_pkthdr.rcvif);
			if (ia == NULL) {
d428 2
a429 7
				panic("icmp_input: ia");
				return;
			}

                        ia->ia_sockmask.sin_len = sizeof ia->ia_sockmask;
                        ia->ia_sockmask.sin_family = AF_INET;
                        ia->ia_sockmask.sin_addr.s_addr = icp->icmp_mask;
d437 1
a437 1
			if( in_ifinit(m->m_pkthdr.rcvif, ia, satosin(&(ia->ia_addr)), 1) )
d441 1
a441 1
			(void)in_ifinit(m->m_pkthdr.rcvif, ia, satosin(&(ia->ia_addr)), 1);
d444 1
a444 2
			m->m_pkthdr.rcvif->if_flags &= ~IFF_NEED_MASK;
			wakeup(&whoamimask);
a447 1
#endif /* __riscos */
a453 2
	case ICMP_ROUTERADVERT:
	case ICMP_ROUTERSOLICIT:
d456 1
d462 4
a465 5
#ifdef NotYet
	rip_input(m, hlen);
#else
        rip_input(m);
#endif
d468 2
a469 1
freeit:
d471 3
d479 3
a481 3
static void
icmp_reflect(m)
	struct mbuf *m;
a482 1
	register struct ip *ip = mtod(m, struct ip *);
d485 1
a485 1
	struct mbuf *opts = 0;
d487 1
d489 8
a496 6
	if (!in_canforward(ip->ip_src) &&
	    ((ntohl(ip->ip_src.s_addr) & IN_CLASSA_NET) !=
	     (IN_LOOPBACKNET << IN_CLASSA_NSHIFT))) {
		m_freem(m);	/* Bad return address */
		goto done;	/* Ip_output() will check for broadcast */
	}
d509 1
a509 1
		if (ia->ia_ifp && (ia->ia_ifp->if_flags & IFF_BROADCAST) &&
a512 1
	icmpdst.sin_addr = t;
d514 1
a514 6
		ia = (struct in_ifaddr *)ifaof_ifpforaddr(
			(struct sockaddr *)&icmpdst, m->m_pkthdr.rcvif);
	/*
	 * The following happens if the packet was not addressed to us,
	 * and was received on an interface with no IP address.
	 */
d531 1
d533 10
a542 2
		    (opts = ALLOC_S(MINCONTIG, NULL))) {
		        opts->m_type = MT_HEADER;
d545 5
d551 1
d553 4
a556 4
#ifdef DEBUG
			if( DODEBUG(DBGICMP) )
			    Printf("icmp_reflect optlen %d rt %d => ",
				   optlen, opts->m_len);
d572 1
a572 2
			    if (opt == IPOPT_RR || opt == IPOPT_TS ||
				opt == IPOPT_SECURITY) {
d578 3
a580 8
		    /* Terminate & pad, if necessary */
		    cnt = opts->m_len % 4;
		    if (cnt) {
		    	for (; cnt < 4; cnt++) {
				*(mtod(opts, caddr_t) + opts->m_len) =
				    IPOPT_EOL;
				opts->m_len++;
			}
d582 3
a584 3
#ifdef DEBUG
			if( DODEBUG(DBGICMP) )
			    Printf("%d\n", opts->m_len);
a593 2
		if (m->m_flags & M_PKTHDR)
			m->m_pkthdr.len -= optlen;
d596 1
a596 1
		    (unsigned)(m->m_len - sizeof(struct ip)));
d598 1
a598 3
	m->m_flags &= ~(M_BCAST|M_MCAST);
	icmp_send(m, opts);
done:
d600 19
a618 1
		(void)m_free(opts);
d625 2
a626 3
static void
icmp_send(m, opts)
	register struct mbuf *m;
a628 1
	register struct ip *ip = mtod(m, struct ip *);
d631 1
a631 1
	struct route ro;
d633 5
d646 3
a648 7
#ifdef DEBUG
	if (DODEBUG(DBGICMP)) {
		char buf[4 * sizeof "123"];
		strcpy(buf, inet_ntoa(ip->ip_dst));
		Printf("icmp_send dst %s src %s\n",
		       buf, inet_ntoa(ip->ip_src));
	}
d650 2
a651 8
	bzero(&ro, sizeof ro);
#ifdef __riscos
	(void) ip_output(m, opts, &ro, send_flags, NULL);
#else
	(void) ip_output(m, opts, &ro, 0, NULL);
#endif
	if (ro.ro_rt)
		RTFREE(ro.ro_rt);
a653 1

d657 1
a658 1
	struct timeval atv;
d660 4
d666 1
a667 65
}

#if 1
/*
 * Return the next larger or smaller MTU plateau (table from RFC 1191)
 * given current value MTU.  If DIR is less than zero, a larger plateau
 * is returned; otherwise, a smaller value is returned.
 */
static int
ip_next_mtu(mtu, dir)
	int mtu;
	int dir;
{
	static int mtutab[] = {
		65535, 32000, 17914, 8166, 4352, 2002, 1492, 1006, 508, 296,
		68, 0
	};
	int i;

	for (i = 0; i < (sizeof mtutab) / (sizeof mtutab[0]); i++) {
		if (mtu >= mtutab[i])
			break;
	}

	if (dir < 0) {
		if (i == 0) {
			return 0;
		} else {
			return mtutab[i - 1];
		}
	} else {
		if (mtutab[i] == 0) {
			return 0;
		} else if(mtu > mtutab[i]) {
			return mtutab[i];
		} else {
			return mtutab[i + 1];
		}
	}
}
#endif

int
icmp_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR); /* XXX overloaded */

	switch (name[0]) {
	case ICMPCTL_MASKREPL:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &icmpmaskrepl));
	case ICMPCTL_STATS:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &icmpstat,
					sizeof icmpstat));
	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@

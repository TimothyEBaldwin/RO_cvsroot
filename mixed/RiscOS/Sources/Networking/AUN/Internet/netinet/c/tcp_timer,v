head	4.4;
access;
symbols
	Internet-5_65:4.4
	Internet-5_64:4.4
	Internet-5_63:4.4
	Internet-5_62:4.4
	Internet-5_61:4.4
	Internet-5_60:4.4
	Internet-5_59:4.4
	Internet-5_58:4.4
	Internet-5_57:4.4
	Internet-5_56:4.4
	Internet-5_55:4.4
	Internet-5_54:4.4
	Internet-5_53:4.4
	Internet-5_52:4.4
	Internet-5_51:4.4
	Internet-5_50:4.4
	RO_5_07:4.4
	Internet-5_49:4.4
	Internet-5_48:4.4
	Internet-5_47:4.4
	Internet-5_46:4.4
	Internet-5_45:4.4
	Internet-5_44:4.4
	Internet-5_43:4.4
	Internet-5_42:4.4
	Internet-5_41:4.4
	Internet-5_40:4.4
	Internet-5_39:4.4
	Internet-5_38:4.4
	Internet-5_37:4.4
	Internet-5_36:4.4
	Internet-5_35:4.4
	Internet-5_34:4.4
	Internet-5_33:4.4
	Internet-5_32:4.4
	Internet-5_31:4.4
	Internet-5_30:4.3
	Internet-5_29:4.3
	Internet-5_27:4.3
	Internet-5_26:4.3
	Internet-5_25:4.3
	Internet-5_24:4.3
	Internet-5_23:4.3
	Internet-5_22:4.3
	Internet-5_21:4.2
	Internet-5_20:4.2
	Internet-5_19:4.2
	Internet-5_18:4.2
	Internet-5_17:4.2
	Internet-5_16:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Internet-5_15:4.2
	Internet-5_14:4.2
	Internet-5_13:4.2
	sforrest_daytona_appflash-0_31:4.2
	Internet-5_12:4.2
	Internet-5_11:4.2
	celkins_Internet-5_10:4.2
	nicke_Internat_25-9-98:4.2
	Internet-5_09:4.2
	blaughto_daytona_appflash-0_30:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rwarren_Internet-5_08:4.2
	Spinner:4.2
	Internet_5_07:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.2
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	99.07.13.11.13.01;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.06.03.12.38.05;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.59.01;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.09;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.09;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.20.18;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.29.52;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.06.57;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.31;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.06.56;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.44;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.38.41;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.26;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.4
log
@Added new FreeBSD sysctl handling using linker magic.
A few new sysctls added as a result.
SO_TIMESTAMP now gives real time, not Internet's internal time.
DHCP/BOOTP parsing picks up URL option and pops it into Inet$URL.
Requires TCPIPLibs 5.25 and link 5.12.

Version 5.31. Tagged as 'Internet-5_31'
@
text
@/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/sysctl.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/protosw.h>
#include <sys/errno.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#include <netinet/tcp_fsm.h>
#include <netinet/tcp_seq.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/tcpip.h>

#include "debug.h"
#include "module.h"

int	tcp_keepinit = TCPTV_KEEP_INIT;
SYSCTL_INT(_net_inet_tcp, TCPCTL_KEEPINIT, keepinit,
	CTLFLAG_RW, &tcp_keepinit , 0, "");

int	tcp_keepidle = TCPTV_KEEP_IDLE;
SYSCTL_INT(_net_inet_tcp, TCPCTL_KEEPIDLE, keepidle,
	CTLFLAG_RW, &tcp_keepidle , 0, "");

static int	tcp_keepintvl = TCPTV_KEEPINTVL;
SYSCTL_INT(_net_inet_tcp, TCPCTL_KEEPINTVL, keepintvl,
	CTLFLAG_RW, &tcp_keepintvl , 0, "");

static int	always_keepalive = 0;
SYSCTL_INT(_net_inet_tcp, OID_AUTO, always_keepalive, CTLFLAG_RW,
    &always_keepalive , 0, "Assume SO_KEEPALIVE on all TCP connections");

int	tcp_keepcnt = TCPTV_KEEPCNT;
	/* max idle probes */
int	tcp_maxpersistidle = TCPTV_KEEP_IDLE;
	/* max idle time in persist */
int	tcp_maxidle;

extern int rand(void);

/*
 * Fast timeout routine for processing delayed acks
 */
void
tcp_fasttimo()
{
	register struct inpcb *inp;
	register struct tcpcb *tp;

	for (inp = tcb.lh_first; inp != NULL; inp = inp->inp_list.le_next) {
		if ((tp = (struct tcpcb *)inp->inp_ppcb) &&
		    (tp->t_flags & TF_DELACK)) {
			tp->t_flags &= ~TF_DELACK;
			tp->t_flags |= TF_ACKNOW;
			tcpstat.tcps_delack++;
			(void) tcp_output(tp);
		}
        }
}

/*
 * Tcp protocol timeout routine called every 500 ms.
 * Updates the timers in all active tcb's and
 * causes finite state machine actions if timers expire.
 */
void
tcp_slowtimo()
{
	register struct inpcb *ip, *ipnxt;
	register struct tcpcb *tp;
	register int i;

	tcp_maxidle = tcp_keepcnt * tcp_keepintvl;

	ip = tcb.lh_first;
	if (ip == NULL) {
		return;
	}
	/*
	 * Search through tcb's and update active timers.
	 */
	for (; ip != NULL; ip = ipnxt) {
		ipnxt = ip->inp_list.le_next;
		tp = intotcpcb(ip);
		if (tp == 0 || tp->t_state == TCPS_LISTEN)
			continue;
		for (i = 0; i < TCPT_NTIMERS; i++) {
#ifdef TCPTDEBUG
			if (tp->t_timer[i])
			{
			    printf("Timer %d = %d  ", i, --tp->t_timer[i]);
			    {
			        if (tp->t_timer[i]==0)
				if (tcp_usrreq(tp->t_inpcb->inp_socket,
				    PRU_SLOWTIMO, (struct mbuf *)0,
				    (struct mbuf *)i, (struct mbuf *)0) == NULL)
					goto tpgone;
			    }
			}
			printf("\n");
#else
			if (tp->t_timer[i] && --tp->t_timer[i] == 0) {
				if (tcp_usrreq(tp->t_inpcb->inp_socket,
				    PRU_SLOWTIMO, (struct mbuf *)0,
				    (struct mbuf *)i, (struct mbuf *)0) == NULL)
					goto tpgone;
			}
#endif
		}
		tp->t_idle++;
		tp->t_duration++;
		if (tp->t_rtt)
			tp->t_rtt++;
tpgone:
		;
	}
#ifndef __riscos
	tcp_iss += TCP_ISSINCR/PR_SLOWHZ;		/* increment iss */
#ifdef TCP_COMPAT_42
	if ((int)tcp_iss < 0)
		tcp_iss = TCP_ISSINCR;			/* XXX */
#endif
#endif
	tcp_now++;					/* for timestamps */
}
#ifndef TUBA_INCLUDE

/*
 * Cancel all timers for TCP tp.
 */
void
tcp_canceltimers(tp)
	struct tcpcb *tp;
{
	register int i;

	for (i = 0; i < TCPT_NTIMERS; i++)
		tp->t_timer[i] = 0;
}

int	tcp_backoff[TCP_MAXRXTSHIFT + 1] =
    { 1, 2, 4, 8, 16, 32, 64, 64, 64, 64, 64, 64, 64 };

static int tcp_totbackoff = 511;	/* sum of tcp_backoff[] */

/*
 * TCP timer processing.
 */
struct tcpcb *
tcp_timers(tp, timer)
	register struct tcpcb *tp;
	int timer;
{
	register int rexmt;

	switch (timer) {

	/*
	 * 2 MSL timeout in shutdown went off.	If we're closed but
	 * still waiting for peer to close and connection has been idle
	 * too long, or if 2MSL time is up from TIME_WAIT, delete connection
	 * control block.  Otherwise, check again in a bit.
	 */
	case TCPT_2MSL:
		if (tp->t_state != TCPS_TIME_WAIT &&
		    tp->t_idle <= tcp_maxidle)
			tp->t_timer[TCPT_2MSL] = tcp_keepintvl;
		else
			tp = tcp_close(tp);
		break;

	/*
	 * Retransmission timer went off.  Message has not
	 * been acked within retransmit interval.  Back off
	 * to a longer retransmit interval and retransmit one segment.
	 */
	case TCPT_REXMT:
		if (++tp->t_rxtshift > TCP_MAXRXTSHIFT) {
			tp->t_rxtshift = TCP_MAXRXTSHIFT;
			tcpstat.tcps_timeoutdrop++;
			tp = tcp_drop(tp, tp->t_softerror ?
			    tp->t_softerror : ETIMEDOUT);
			break;
		}
		tcpstat.tcps_rexmttimeo++;
#ifdef TCPTDEBUG
                printf("tp->t_srtt=%d, tp->t_rttvar=%d, tp->t_rxtshift=%d, TCP_REXMTVAL(tp)=%d\n", tp->t_srtt, tp->t_rttvar, tp->t_rxtshift, TCP_REXMTVAL(tp));
#endif
		rexmt = TCP_REXMTVAL(tp) * tcp_backoff[tp->t_rxtshift];
#ifdef TCPTDEBUG
                printf("tp->t_rxtcur was %d\n", tp->t_rxtcur);
#endif
		TCPT_RANGESET(tp->t_rxtcur, rexmt,
		    tp->t_rttmin, TCPTV_REXMTMAX);
		tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
#ifdef TCPTDEBUG
                printf("Resetting TCPT_REXMT to %d (rexmt=%d)\n", tp->t_rxtcur, rexmt);
#endif
		/*
		 * If losing, let the lower level know and try for
		 * a better route.  Also, if we backed off this far,
		 * our srtt estimate is probably bogus.	 Clobber it
		 * so we'll take the next rtt measurement as our srtt;
		 * move the current srtt into rttvar to keep the current
		 * retransmit times until then.
		 */
		if (tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) {
			in_losing(tp->t_inpcb);
			tp->t_rttvar += (tp->t_srtt >> TCP_RTT_SHIFT);
			tp->t_srtt = 0;
		}
		tp->snd_nxt = tp->snd_una;
		/*
		 * Force a segment to be sent.
		 */
		tp->t_flags |= TF_ACKNOW;
		/*
		 * If timing a segment in this window, stop the timer.
		 */
		tp->t_rtt = 0;
		/*
		 * Close the congestion window down to one segment
		 * (we'll open it by one segment for each ack we get).
		 * Since we probably have a window's worth of unacked
		 * data accumulated, this "slow start" keeps us from
		 * dumping all that data as back-to-back packets (which
		 * might overwhelm an intermediate gateway).
		 *
		 * There are two phases to the opening: Initially we
		 * open by one mss on each ack.	 This makes the window
		 * size increase exponentially with time.  If the
		 * window is larger than the path can handle, this
		 * exponential growth results in dropped packet(s)
		 * almost immediately.	To get more time between
		 * drops but still "push" the network to take advantage
		 * of improving conditions, we switch from exponential
		 * to linear window opening at some threshhold size.
		 * For a threshhold, we use half the current window
		 * size, truncated to a multiple of the mss.
		 *
		 * (the minimum cwnd that will give us exponential
		 * growth is 2 mss.  We don't allow the threshhold
		 * to go below this.)
		 */
		{
		u_int win = min(tp->snd_wnd, tp->snd_cwnd) / 2 / tp->t_maxseg;
		if (win < 2)
			win = 2;
		tp->snd_cwnd = tp->t_maxseg;
		tp->snd_ssthresh = win * tp->t_maxseg;
		tp->t_dupacks = 0;
		}
		(void) tcp_output(tp);
		break;

	/*
	 * Persistance timer into zero window.
	 * Force a byte to be output, if possible.
	 */
	case TCPT_PERSIST:
		tcpstat.tcps_persisttimeo++;
		/*
		 * Hack: if the peer is dead/unreachable, we do not
		 * time out if the window is closed.  After a full
		 * backoff, drop the connection if the idle time
		 * (no responses to probes) reaches the maximum
		 * backoff that we would use if retransmitting.
		 */
		if (tp->t_rxtshift == TCP_MAXRXTSHIFT) {
			u_long maxidle = TCP_REXMTVAL(tp);
			if (maxidle < tp->t_rttmin)
				maxidle = tp->t_rttmin;
			maxidle *= tcp_totbackoff;
			if (tp->t_idle >= tcp_maxpersistidle ||
			    tp->t_idle >= maxidle) {
				tcpstat.tcps_persistdrop++;
				tp = tcp_drop(tp, ETIMEDOUT);
				break;
			}
		}
		tcp_setpersist(tp);
		tp->t_force = 1;
		(void) tcp_output(tp);
		tp->t_force = 0;
		break;

	/*
	 * Keep-alive timer went off; send something
	 * or drop connection if idle for too long.
	 */
	case TCPT_KEEP:
		tcpstat.tcps_keeptimeo++;
		if (tp->t_state < TCPS_ESTABLISHED)
			goto dropit;
		if ((always_keepalive ||
		    tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE) &&
		    tp->t_state <= TCPS_CLOSE_WAIT) {
			if (tp->t_idle + 1 >= tcp_keepidle + tcp_maxidle)
				goto dropit;
			/*
			 * Send a packet designed to force a response
			 * if the peer is up and reachable:
			 * either an ACK if the connection is still alive,
			 * or an RST if the peer has closed the connection
			 * due to timeout or reboot.
			 * Using sequence number tp->snd_una-1
			 * causes the transmitted zero-length segment
			 * to lie outside the receive window;
			 * by the protocol spec, this requires the
			 * correspondent TCP to respond.
			 */
			tcpstat.tcps_keepprobe++;
#ifdef DEBUG
			if (DODEBUG(DBGTCP))
			    Printf("\021\03tcp_timers: probe\021\07\n");
#endif
#ifdef TCP_COMPAT_42
			/*
			 * The keepalive packet must have nonzero length
			 * to get a 4.2 host to respond.
			 */
			tcp_respond(tp, tp->t_template, (struct mbuf *)NULL,
			    tp->rcv_nxt - 1, tp->snd_una - 1, 0);
#else
			tcp_respond(tp, tp->t_template, (struct mbuf *)NULL,
			    tp->rcv_nxt, tp->snd_una - 1, 0);
#endif
			tp->t_timer[TCPT_KEEP] = tcp_keepintvl;
		} else
			tp->t_timer[TCPT_KEEP] = tcp_keepidle;
		break;
	dropit:
#ifdef DEBUG
		if (DODEBUG(DBGTCP))
		    Printf("\021\01tcp_timers: dropit\021\07\n");
#endif
		tcpstat.tcps_keepdrops++;
		tp = tcp_drop(tp, ETIMEDOUT);
		break;
	}
	return (tp);
}
#endif /* TUBA_INCLUDE */
@


4.3
log
@  Fixed TCP ISN generation.
Detail:
  When a device does not contain a real-time clock (eg. STB3) the
    generation of pseudo-random initial sequence numbers (ISNs) is not
    good enough to prevent confusion arising if a reconnection is
    attempted using the same 4-tuple socket address at the same time
    after machine is powered up. Commonly, this affects any application
    run by or immediately after the baseline boot system.  This results
    in attempts to connect a stream socket failing (the TCP code
    follows the TCP specification and ignores the server ACKs waiting
    for a SYN ACK to arrive)  A new function has been introduced to
    generate ISNs and the results are based on a monotonically
    increasing counter combined with the centisecond timer value.
Admin:
  Requires TCPIPLibs 5.14 or later.
    (CVS: RiscOS/Sources/Lib/TCPIPLibs  tag: TCPIPLibs-5_14 or later)

Version 5.22. Tagged as 'Internet-5_22'
@
text
@a34 1
#ifndef TUBA_INCLUDE
d37 2
d65 4
d70 7
a76 1
int	tcp_keepintvl = TCPTV_KEEPINTVL;
d78 3
a85 4
#else /* TUBA_INCLUDE */

static	int tcp_maxpersistidle;
#endif /* TUBA_INCLUDE */
@


4.2
log
@Version Spinner_B7 taken
@
text
@d155 1
d160 1
@


4.1
log
@Initial revision
@
text
@d1 3
a3 1
/* -*-C-*-
d5 15
a19 2
 * $Header: /ax/networking:Internet/netinet/tcp_timer.c:networking  1.1  $
 * $Source: /ax/networking:Internet/netinet/tcp_timer.c: $
d21 11
a31 1
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
a32 4
 * $Log:	tcp_timer.c,v $
 * Revision 1.1  94/12/02  11:24:02  kwelton
 * Initial revision
 * 
d34 29
a62 39
/*
 * Copyright (c) 1983, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 */
#include "sys/param.h"
#include "sys/systm.h"
#include "sys/mbuf.h"
#include "sys/socket.h"
#include "sys/socketvar.h"
#include "sys/protosw.h"
#include "sys/errno.h"

#include "net/if.h"
#include "net/route.h"

#include "netinet/in.h"
#include "netinet/in_pcb.h"
#include "netinet/in_systm.h"
#include "netinet/ip.h"
#include "netinet/ip_var.h"
#include "netinet/tcp.h"
#include "netinet/tcp_fsm.h"
#include "netinet/tcp_seq.h"
#include "netinet/tcp_timer.h"
#include "netinet/tcp_var.h"
#include "netinet/tcpip.h"
d66 12
a77 1
int	tcp_maxidle = 0;
d82 1
d88 1
a88 3
	inp = tcb.inp_next;
	if (inp)
	for (; inp != &tcb; inp = inp->inp_next)
d96 1
d104 1
d111 6
a116 1
	tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;
d120 2
a121 6
	ip = tcb.inp_next;
	if (ip == 0) {
		return;
	}
	for (; ip != &tcb; ip = ipnxt) {
		ipnxt = ip->inp_next;
d123 1
a123 1
		if (tp == 0)
d126 14
d141 1
a141 1
				(void) tcp_usrreq(tp->t_inpcb->inp_socket,
d143 1
a143 2
				    (struct mbuf *)i, (struct mbuf *)0);
				if (ipnxt->inp_prev != ip)
d146 1
d149 1
d158 1
a158 1
		tcp_iss = 0;				/* XXX */
d160 1
d162 1
d167 1
d180 2
d217 2
a218 1
			tp = tcp_drop(tp, ETIMEDOUT);
d222 9
a230 3
		rexmt = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
		rexmt *= tcp_backoff[tp->t_rxtshift];
		TCPT_RANGESET(tp->t_rxtcur, rexmt, TCPTV_MIN, TCPTV_REXMTMAX);
d232 3
a243 1
#if BSD>=43
d245 1
a245 2
#endif
			tp->t_rttvar += (tp->t_srtt >> 2);
d250 4
d282 1
a282 1
		u_int win = MIN(tp->snd_wnd, tp->snd_cwnd) / 2 / tp->t_maxseg;
d287 1
d298 19
d331 2
a332 1
		if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
d334 1
a334 1
			if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
d349 4
d358 1
a358 1
			tcp_respond(tp, tp->t_template,
d361 1
a361 1
			tcp_respond(tp, tp->t_template,
d369 4
d379 1
a379 2

/* EOF tcp_timer.c */
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d1 12
d14 2
a15 18
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d17 11
a27 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d30 22
a51 29

#ifndef TUBA_INCLUDE
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/protosw.h>
#include <sys/errno.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#include <netinet/tcp_fsm.h>
#include <netinet/tcp_seq.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/tcpip.h>

#include "debug.h"
#include "module.h"
d55 1
a55 12
static int	always_keepalive = 0;
int	tcp_keepcnt = TCPTV_KEEPCNT;
	/* max idle probes */
int	tcp_maxpersistidle = TCPTV_KEEP_IDLE;
	/* max idle time in persist */
int	tcp_maxidle;
#else /* TUBA_INCLUDE */

static	int tcp_maxpersistidle;
#endif /* TUBA_INCLUDE */

extern int rand(void);
a59 1
void
d65 3
a67 1
	for (inp = tcb.lh_first; inp != NULL; inp = inp->inp_list.le_next) {
a74 1
        }
a81 1
void
d88 1
a88 6
	tcp_maxidle = tcp_keepcnt * tcp_keepintvl;

	ip = tcb.lh_first;
	if (ip == NULL) {
		return;
	}
d92 6
a97 2
	for (; ip != NULL; ip = ipnxt) {
		ipnxt = ip->inp_list.le_next;
d99 1
a99 1
		if (tp == 0 || tp->t_state == TCPS_LISTEN)
a101 14
#ifdef TCPTDEBUG
			if (tp->t_timer[i])
			{
			    printf("Timer %d = %d  ", i, --tp->t_timer[i]);
			    {
			        if (tp->t_timer[i]==0)
				if (tcp_usrreq(tp->t_inpcb->inp_socket,
				    PRU_SLOWTIMO, (struct mbuf *)0,
				    (struct mbuf *)i, (struct mbuf *)0) == NULL)
					goto tpgone;
			    }
			}
			printf("\n");
#else
d103 1
a103 1
				if (tcp_usrreq(tp->t_inpcb->inp_socket,
d105 2
a106 1
				    (struct mbuf *)i, (struct mbuf *)0) == NULL)
a108 1
#endif
a110 1
		tp->t_duration++;
d119 1
a119 1
		tcp_iss = TCP_ISSINCR;			/* XXX */
a120 1
	tcp_now++;					/* for timestamps */
a121 1
#ifndef TUBA_INCLUDE
a125 1
void
a137 2
static int tcp_totbackoff = 511;	/* sum of tcp_backoff[] */

d173 1
a173 2
			tp = tcp_drop(tp, tp->t_softerror ?
			    tp->t_softerror : ETIMEDOUT);
d177 3
a179 9
#ifdef TCPTDEBUG
                printf("tp->t_srtt=%d, tp->t_rttvar=%d, tp->t_rxtshift=%d, TCP_REXMTVAL(tp)=%d\n", tp->t_srtt, tp->t_rttvar, tp->t_rxtshift, TCP_REXMTVAL(tp));
#endif
		rexmt = TCP_REXMTVAL(tp) * tcp_backoff[tp->t_rxtshift];
#ifdef TCPTDEBUG
                printf("tp->t_rxtcur was %d\n", tp->t_rxtcur);
#endif
		TCPT_RANGESET(tp->t_rxtcur, rexmt,
		    tp->t_rttmin, TCPTV_REXMTMAX);
a180 3
#ifdef TCPTDEBUG
                printf("Resetting TCPT_REXMT to %d (rexmt=%d)\n", tp->t_rxtcur, rexmt);
#endif
d190 1
d192 2
a193 1
			tp->t_rttvar += (tp->t_srtt >> TCP_RTT_SHIFT);
a197 4
		 * Force a segment to be sent.
		 */
		tp->t_flags |= TF_ACKNOW;
		/*
d226 1
a226 1
		u_int win = min(tp->snd_wnd, tp->snd_cwnd) / 2 / tp->t_maxseg;
a230 1
		tp->t_dupacks = 0;
a240 19
		/*
		 * Hack: if the peer is dead/unreachable, we do not
		 * time out if the window is closed.  After a full
		 * backoff, drop the connection if the idle time
		 * (no responses to probes) reaches the maximum
		 * backoff that we would use if retransmitting.
		 */
		if (tp->t_rxtshift == TCP_MAXRXTSHIFT) {
			u_long maxidle = TCP_REXMTVAL(tp);
			if (maxidle < tp->t_rttmin)
				maxidle = tp->t_rttmin;
			maxidle *= tcp_totbackoff;
			if (tp->t_idle >= tcp_maxpersistidle ||
			    tp->t_idle >= maxidle) {
				tcpstat.tcps_persistdrop++;
				tp = tcp_drop(tp, ETIMEDOUT);
				break;
			}
		}
d255 1
a255 2
		if ((always_keepalive ||
		    tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE) &&
d257 1
a257 1
			if (tp->t_idle + 1 >= tcp_keepidle + tcp_maxidle)
a271 4
#ifdef DEBUG
			if (DODEBUG(DBGTCP))
			    Printf("\021\03tcp_timers: probe\021\07\n");
#endif
d277 1
a277 1
			tcp_respond(tp, tp->t_template, (struct mbuf *)NULL,
d280 1
a280 1
			tcp_respond(tp, tp->t_template, (struct mbuf *)NULL,
a287 4
#ifdef DEBUG
		if (DODEBUG(DBGTCP))
		    Printf("\021\01tcp_timers: dropit\021\07\n");
#endif
d294 2
a295 1
#endif /* TUBA_INCLUDE */
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d3 1
a3 1
 * $Header: /ax/networking:Internet/netinet/tcp_timer.c:networking  1.2  $
a8 9
 * Revision 1.2  95/06/05  15:51:50  kwelton
 * The timeouts for the SO_KEEPALIVE option can now be controlled by
 * four new ioctl()'s added to the Internet module (see net/if.c).
 * These changes were added at the request of Online Media who need
 * SO_KEEPALIVE to kick in a bit sooner than its standard interval
 * of two hours.  Fixed a subtle bug in tcp_timers which meant that
 * connections only timed out after tcp_keepcnt + 1 (rather than
 * tcp_keepcnt) probes had been sent.
 * 
a52 2
#include "debug.h"

a54 1
int	tcp_keepcnt = TCPTV_KEEPCNT;
d88 1
a88 1
	tcp_maxidle = tcp_keepcnt * tcp_keepintvl;
d257 1
a257 1
			if (tp->t_idle + 1 >= tcp_keepidle + tcp_maxidle)
a271 4
#ifdef DEBUG
			if( DODEBUG(DBGTCP) )
			    Printf("\021\03tcp_timers: probe\021\07\n");
#endif
a287 4
#ifdef DEBUG
		if( DODEBUG(DBGTCP) )
		    Printf("\021\01tcp_timers: dropit\021\07\n");
#endif
@


4.1.7.2
log
@RCS log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@d3 1
a3 1
 * $Header: /ax/networking:Internet/netinet/tcp_timer.c:networking  1.2  $
a8 9
 * Revision 1.2  95/06/05  15:51:50  kwelton
 * The timeouts for the SO_KEEPALIVE option can now be controlled by
 * four new ioctl()'s added to the Internet module (see net/if.c).
 * These changes were added at the request of Online Media who need
 * SO_KEEPALIVE to kick in a bit sooner than its standard interval
 * of two hours.  Fixed a subtle bug in tcp_timers which meant that
 * connections only timed out after tcp_keepcnt + 1 (rather than
 * tcp_keepcnt) probes had been sent.
 * 
a52 2
#include "debug.h"

a54 1
int	tcp_keepcnt = TCPTV_KEEPCNT;
d88 1
a88 1
	tcp_maxidle = tcp_keepcnt * tcp_keepintvl;
d257 1
a257 1
			if (tp->t_idle + 1 >= tcp_keepidle + tcp_maxidle)
a271 4
#ifdef DEBUG
			if( DODEBUG(DBGTCP) )
			    Printf("\021\03tcp_timers: probe\021\07\n");
#endif
a287 4
#ifdef DEBUG
		if( DODEBUG(DBGTCP) )
		    Printf("\021\01tcp_timers: dropit\021\07\n");
#endif
@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d1 12
d14 2
a15 2
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
d17 11
a27 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a28 14
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @@(#)tcp_timer.c 8.2 (Berkeley) 5/24/95
 *      $Id: tcp_timer.c,v 1.17 1996/06/03 15:37:52 jdp Exp $
d30 22
a51 29

#ifndef TUBA_INCLUDE
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/protosw.h>
#include <sys/errno.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#include <netinet/tcp_fsm.h>
#include <netinet/tcp_seq.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/tcpip.h>

#include "debug.h"
#include "module.h"
d55 1
a55 10
static int	always_keepalive = 0;
int	tcp_keepcnt = TCPTV_KEEPCNT;
	/* max idle probes */
int	tcp_maxpersistidle = TCPTV_KEEP_IDLE;
	/* max idle time in persist */
int	tcp_maxidle;
#else /* TUBA_INCLUDE */

static	int tcp_maxpersistidle;
#endif /* TUBA_INCLUDE */
a59 1
void
d65 3
a67 1
	for (inp = tcb.lh_first; inp != NULL; inp = inp->inp_list.le_next) {
a74 1
        }
a81 1
void
d88 1
a88 6
	tcp_maxidle = tcp_keepcnt * tcp_keepintvl;

	ip = tcb.lh_first;
	if (ip == NULL) {
		return;
	}
d92 6
a97 2
	for (; ip != NULL; ip = ipnxt) {
		ipnxt = ip->inp_list.le_next;
d99 1
a99 1
		if (tp == 0 || tp->t_state == TCPS_LISTEN)
a101 14
#ifdef TCPTDEBUG
			if (tp->t_timer[i])
			{
			    printf("Timer %d = %d  ", i, --tp->t_timer[i]);
			    {
			        if (tp->t_timer[i]==0)
				if (tcp_usrreq(tp->t_inpcb->inp_socket,
				    PRU_SLOWTIMO, (struct mbuf *)0,
				    (struct mbuf *)i, (struct mbuf *)0) == NULL)
					goto tpgone;
			    }
			}
			printf("\n");
#else
d103 1
a103 1
				if (tcp_usrreq(tp->t_inpcb->inp_socket,
d105 2
a106 1
				    (struct mbuf *)i, (struct mbuf *)0) == NULL)
a108 1
#endif
a110 1
		tp->t_duration++;
d119 1
a119 1
		tcp_iss = TCP_ISSINCR;			/* XXX */
a120 1
	tcp_now++;					/* for timestamps */
a121 1
#ifndef TUBA_INCLUDE
a125 1
void
a137 2
static int tcp_totbackoff = 511;	/* sum of tcp_backoff[] */

d173 1
a173 2
			tp = tcp_drop(tp, tp->t_softerror ?
			    tp->t_softerror : ETIMEDOUT);
d177 3
a179 9
#ifdef TCPTDEBUG
                printf("tp->t_srtt=%d, tp->t_rttvar=%d, tp->t_rxtshift=%d, TCP_REXMTVAL(tp)=%d\n", tp->t_srtt, tp->t_rttvar, tp->t_rxtshift, TCP_REXMTVAL(tp));
#endif
		rexmt = TCP_REXMTVAL(tp) * tcp_backoff[tp->t_rxtshift];
#ifdef TCPTDEBUG
                printf("tp->t_rxtcur was %d\n", tp->t_rxtcur);
#endif
		TCPT_RANGESET(tp->t_rxtcur, rexmt,
		    tp->t_rttmin, TCPTV_REXMTMAX);
a180 3
#ifdef TCPTDEBUG
                printf("Resetting TCPT_REXMT to %d (rexmt=%d)\n", tp->t_rxtcur, rexmt);
#endif
d190 1
d192 2
a193 1
			tp->t_rttvar += (tp->t_srtt >> TCP_RTT_SHIFT);
a197 4
		 * Force a segment to be sent.
		 */
		tp->t_flags |= TF_ACKNOW;
		/*
d226 1
a226 1
		u_int win = min(tp->snd_wnd, tp->snd_cwnd) / 2 / tp->t_maxseg;
a230 1
		tp->t_dupacks = 0;
a240 19
		/*
		 * Hack: if the peer is dead/unreachable, we do not
		 * time out if the window is closed.  After a full
		 * backoff, drop the connection if the idle time
		 * (no responses to probes) reaches the maximum
		 * backoff that we would use if retransmitting.
		 */
		if (tp->t_rxtshift == TCP_MAXRXTSHIFT) {
			u_long maxidle = TCP_REXMTVAL(tp);
			if (maxidle < tp->t_rttmin)
				maxidle = tp->t_rttmin;
			maxidle *= tcp_totbackoff;
			if (tp->t_idle >= tcp_maxpersistidle ||
			    tp->t_idle >= maxidle) {
				tcpstat.tcps_persistdrop++;
				tp = tcp_drop(tp, ETIMEDOUT);
				break;
			}
		}
d255 1
a255 2
		if ((always_keepalive ||
		    tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE) &&
d257 1
a257 1
			if (tp->t_idle + 1 >= tcp_keepidle + tcp_maxidle)
a271 4
#ifdef DEBUG
			if (DODEBUG(DBGTCP))
			    Printf("\021\03tcp_timers: probe\021\07\n");
#endif
d277 1
a277 1
			tcp_respond(tp, tp->t_template, (struct mbuf *)NULL,
d280 1
a280 1
			tcp_respond(tp, tp->t_template, (struct mbuf *)NULL,
a287 4
#ifdef DEBUG
		if (DODEBUG(DBGTCP))
		    Printf("\021\01tcp_timers: dropit\021\07\n");
#endif
d294 2
a295 1
#endif /* TUBA_INCLUDE */
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@

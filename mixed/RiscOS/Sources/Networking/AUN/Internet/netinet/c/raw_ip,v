head	4.6;
access;
symbols
	Internet-5_65:4.6
	Internet-5_64:4.6
	Internet-5_63:4.6
	Internet-5_62:4.6
	Internet-5_61:4.6
	Internet-5_60:4.6
	Internet-5_59:4.6
	Internet-5_58:4.6
	Internet-5_57:4.6
	Internet-5_56:4.5
	Internet-5_55:4.5
	Internet-5_54:4.5
	Internet-5_53:4.5
	Internet-5_52:4.5
	Internet-5_51:4.5
	Internet-5_50:4.5
	RO_5_07:4.5
	Internet-5_49:4.5
	Internet-5_48:4.5
	Internet-5_47:4.5
	Internet-5_46:4.5
	Internet-5_45:4.5
	Internet-5_44:4.5
	Internet-5_43:4.5
	Internet-5_42:4.5
	Internet-5_41:4.5
	Internet-5_40:4.5
	Internet-5_39:4.5
	Internet-5_38:4.5
	Internet-5_37:4.5
	Internet-5_36:4.5
	Internet-5_35:4.5
	Internet-5_34:4.5
	Internet-5_33:4.5
	Internet-5_32:4.5
	Internet-5_31:4.5
	Internet-5_30:4.4
	Internet-5_29:4.4
	Internet-5_27:4.3
	Internet-5_26:4.2
	Internet-5_25:4.2
	Internet-5_24:4.2
	Internet-5_23:4.2
	Internet-5_22:4.2
	Internet-5_21:4.2
	Internet-5_20:4.2
	Internet-5_19:4.2
	Internet-5_18:4.2
	Internet-5_17:4.2
	Internet-5_16:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Internet-5_15:4.2
	Internet-5_14:4.2
	Internet-5_13:4.2
	sforrest_daytona_appflash-0_31:4.2
	Internet-5_12:4.2
	Internet-5_11:4.2
	celkins_Internet-5_10:4.2
	nicke_Internat_25-9-98:4.2
	Internet-5_09:4.2
	blaughto_daytona_appflash-0_30:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rwarren_Internet-5_08:4.2
	Spinner:4.2
	Internet_5_07:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.2
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2012.08.26.19.53.23;	author jlee;	state Exp;
branches;
next	4.5;
commitid	WbuxJGoZAqKXR5iw;

4.5
date	99.07.13.11.12.55;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.07.08.15.25.40;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.06.30.13.15.37;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.58.56;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.08;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.08;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.20.09;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.28.25;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.06.51;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.25;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.06.46;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.37;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.38.32;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.22;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Fix routes not being cleaned up properly when an interface changes its address
Detail:
  This is the Internet-side part of the fix, incorporating the following changes from FreeBSD:
  net/c/route - http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/net/route.c.diff?r1=1.59.2.1;r2=1.59.2.2;f=h
  netinet/c/in - http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/netinet/in.c.diff?r1=1.44.2.2;r2=1.44.2.3;f=h
  netinet/c/in_rmx - http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/netinet/in_rmx.c.diff?r1=1.37;r2=1.37.2.1;f=h
  netinet/c/raw_ip - http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/netinet/raw_ip.c.diff?r1=1.64.2.4;r2=1.64.2.5;f=h
  net/c/if - http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/net/if.c.diff?r1=1.43;r2=1.44;f=h
  This provides us with the fix for this bug:
  http://www.freebsd.org/cgi/query-pr.cgi?pr=20785
  Other required changes:
  netiniet/c/in_proto - Hooked up rip_ctlinput to appropriate handlers
  Also fixed build/Makefile to count the module as a dependency for rom_link phase
Admin:
  Tested on Raspberry Pi
  Requires TCPIPLibs-5_56
  Fixes issue reported on forums with ShareFS not always working:
  http://www.riscosopen.org/forum/forums/5/topics/1193


Version 5.57. Tagged as 'Internet-5_57'
@
text
@/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/proc.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
#include <netinet/ip_mroute.h>

#include <netinet/ip_fw.h>

#include "module.h"

static struct inpcbhead ripcb;
static struct inpcbinfo ripcbinfo;

/*
 * Nominal space allocated to a raw ip socket.
 */
#define	RIPSNDQ		8192
#define	RIPRCVQ		8192

/*
 * Raw interface to IP protocol.
 */

/*
 * Initialize raw connection block q.
 */
void
rip_init()
{
	LIST_INIT(&ripcb);
	ripcbinfo.listhead = &ripcb;
	/*
	 * XXX We don't use the hash list for raw IP, but it's easier
	 * to allocate a one entry hash list than it is to check all
	 * over the place for hashbase == NULL.
	 */
	ripcbinfo.hashbase = phashinit(1, M_PCB, &ripcbinfo.hashsize);
}

static struct	sockaddr_in ripsrc = { sizeof(ripsrc), AF_INET };
/*
 * Setup generic address and protocol structures
 * for raw_input routine, then pass them along with
 * mbuf chain.
 */
void
rip_input(m)
	struct mbuf *m;
{
	register struct ip *ip = mtod(m, struct ip *);
	register struct inpcb *inp;
	struct inpcb *last = 0;
	struct mbuf *opts = 0;

	ripsrc.sin_addr = ip->ip_src;
	for (inp = ripcb.lh_first; inp != NULL; inp = inp->inp_list.le_next) {
		if (inp->inp_ip_p && inp->inp_ip_p != ip->ip_p)
			continue;
		if (inp->inp_laddr.s_addr &&
                  inp->inp_laddr.s_addr != ip->ip_dst.s_addr)
			continue;
		if (inp->inp_faddr.s_addr &&
                  inp->inp_faddr.s_addr != ip->ip_src.s_addr)
			continue;
		if (last) {
			struct mbuf *n = m_copy(m, 0, M_COPYALL);
			if (n) {
				if (last->inp_flags & INP_CONTROLOPTS ||
				    last->inp_socket->so_options & SO_TIMESTAMP)
				    ip_savecontrol(last, &opts, ip, n);
				if (sbappendaddr(&last->inp_socket->so_rcv,
				    (struct sockaddr *)&ripsrc, n,
				    opts) == 0) {
					/* should notify about lost packet */
					m_freem(n);
					if (opts)
					    m_freem(opts);
				} else
					sorwakeup(last->inp_socket);
				opts = 0;
			}
		}
		last = inp;
	}
	if (last) {
		if (last->inp_flags & INP_CONTROLOPTS ||
		    last->inp_socket->so_options & SO_TIMESTAMP)
			ip_savecontrol(last, &opts, ip, m);
		if (sbappendaddr(&last->inp_socket->so_rcv,
		    (struct sockaddr *)&ripsrc, m, opts) == 0) {
			m_freem(m);
			if (opts)
			    m_freem(opts);
		} else
			sorwakeup(last->inp_socket);
	} else {
		m_freem(m);
		ipstat.ips_noproto++;
		ipstat.ips_delivered--;
      }
}

/*
 * Generate IP header and pass packet to ip_output.
 * Tack on options user may have setup with control call.
 */
int
rip_output(m, so, dst)
	register struct mbuf *m;
	struct socket *so;
	u_long dst;
{
	register struct ip *ip;
	register struct inpcb *inp = sotoinpcb(so);
	struct mbuf *opts;
	int flags = (so->so_options & SO_DONTROUTE) | IP_ALLOWBROADCAST;

#if 0
        Printf("rip_output(m=%x, so=%x, dst=%X)\n", m, so, dst);
#endif
	/*
	 * If the user handed us a complete IP packet, use it.
	 * Otherwise, allocate an mbuf for a header and fill it in.
	 */
	if ((inp->inp_flags & INP_HDRINCL) == 0) {
#if 0
                Printf("RIP_OUTPUT: Prepending header.  m->m_flags & M_PKTHDR=%d "
                       "m->m_pkthdr.len = %d m->m_len = %d M_LEADINGSPACE(m) = %d\n",
                       m->m_flags & M_PKTHDR, m->m_pkthdr.len, m->m_len,
                       M_LEADINGSPACE(m));
#endif
		M_PREPEND(m, sizeof(struct ip), M_WAIT);
#if 0
                Printf("RIP_OUTPUT: Prepended header.  m->m_flags & M_PKTHDR=%d "
                       "m->m_pkthdr.len = %d m->m_len = %d M_LEADINGSPACE(m) = %d\n",
                       m->m_flags & M_PKTHDR, m->m_pkthdr.len, m->m_len,
                       M_LEADINGSPACE(m));
#endif
		if (m == 0)
			return (ENOBUFS);
                ip = mtod(m, struct ip *);
		ip->ip_tos = 0;
		ip->ip_off = 0;
		ip->ip_p = inp->inp_ip_p;
		ip->ip_len = m->m_pkthdr.len;
		ip->ip_src = inp->inp_laddr;
		ip->ip_dst.s_addr = dst;
		ip->ip_ttl = MAXTTL;
#if 0
                Printf("Dest = %x, Src = %x\n", ip->ip_dst, ip->ip_src);
#endif
		opts = inp->inp_options;
	} else {
		ip = mtod(m, struct ip *);
		if (ip->ip_id == 0)
			ip->ip_id = htons(ip_id++);
		opts = NULL;
		/* XXX prevent ip_output from overwriting header fields */
		flags |= IP_RAWOUTPUT;
		ipstat.ips_rawout++;
	}
#if 0
        Printf("calling ip_output(m=%x, opts=%x, route=%x, flags=%x, options=%x)\n", m, opts, &inp->inp_route, flags, inp->inp_moptions);
#endif
	return (ip_output(m, opts, &inp->inp_route, flags, inp->inp_moptions));
}

/*
 * Raw IP socket option processing.
 */
int
rip_ctloutput(op, so, level, optname, m)
	int op;
	struct socket *so;
	int level, optname;
	struct mbuf **m;
{
	register struct inpcb *inp = sotoinpcb(so);
	register int error;

	if (level != IPPROTO_IP) {
		if (op == PRCO_SETOPT && *m)
			(void)m_free(*m);
		return (EINVAL);
	}

	switch (optname) {

	case IP_HDRINCL:
		error = 0;
		if (op == PRCO_SETOPT) {
			if (m == 0 || *m == 0 || (*m)->m_len < sizeof (int))
				error = EINVAL;
			else if (*mtod(*m, int *))
				inp->inp_flags |= INP_HDRINCL;
			else
				inp->inp_flags &= ~INP_HDRINCL;
			if (*m)
				(void)m_free(*m);
		} else {
			*m = ALLOC_S(MINCONTIG, NULL);
			if (*m == 0)
				return (ENOBUFS);
			(*m)->m_type = MT_SOOPTS;
			(*m)->m_len = sizeof (int);
			*mtod(*m, int *) = inp->inp_flags & INP_HDRINCL;
		}
		return (error);

#ifdef IPFIREWALL
#ifdef __riscos
	case IP_FW_ACTIVE:
		if (op == PRCO_SETOPT) {
		    	extern int ipfw_load(void), ipfw_unload(void);
		    	error = 0;
			if (m == 0 || *m == 0 || (*m)->m_len < sizeof (int))
				error = EINVAL;
			else if (*mtod(*m, int *))
				error = ipfw_load();
			else
				error = ipfw_unload();
			if (*m)
				(void)m_free(*m);
		} else {
			*m = ALLOC_S(0, NULL);
			if (*m == 0)
				return(ENOBUFS);
			(*m)->m_type = MT_SOOPTS;
			(*m)->m_len = sizeof (int);
			*mtod(*m, int *) = ip_fw_ctl_ptr != 0;
			error = 0;
		}
		return (error);

#endif
	case IP_FW_GET:
		if (ip_fw_ctl_ptr==NULL || op == PRCO_SETOPT) {
			if (*m) (void)m_free(*m);
			return(EINVAL);
		}
		return (*ip_fw_ctl_ptr)(optname, m);
	case IP_FW_ADD:
	case IP_FW_DEL:
	case IP_FW_FLUSH:
	case IP_FW_ZERO:
		if (ip_fw_ctl_ptr==NULL || op != PRCO_SETOPT) {
			if (*m) (void)m_free(*m);
			return(EINVAL);
		}

		return (*ip_fw_ctl_ptr)(optname, m);
		return(error);
#endif

	case IP_RSVP_ON:
		return ip_rsvp_init(so);
		break;

	case IP_RSVP_OFF:
		return ip_rsvp_done();
		break;

	case IP_RSVP_VIF_ON:
		return ip_rsvp_vif_init(so, *m);

	case IP_RSVP_VIF_OFF:
		return ip_rsvp_vif_done(so, *m);

	case MRT_INIT:
	case MRT_DONE:
	case MRT_ADD_VIF:
	case MRT_DEL_VIF:
	case MRT_ADD_MFC:
	case MRT_DEL_MFC:
	case MRT_VERSION:
	case MRT_ASSERT:
		if (op == PRCO_SETOPT) {
			error = ip_mrouter_set(optname, so, *m);
			if (*m)
				(void)m_free(*m);
		} else if (op == PRCO_GETOPT) {
			error = ip_mrouter_get(optname, so, m);
		} else
			error = EINVAL;
		return (error);
	}
	return (ip_ctloutput(op, so, level, optname, m));
}

/*
 * This function exists solely to receive the PRC_IFDOWN messages which
 * are sent by if_down().  It looks for an ifaddr whose ifa_addr is sa,
 * and calls in_ifadown() to remove all routes corresponding to that address.
 * It also receives the PRC_IFUP messages from if_up() and reinstalls the
 * interface routes.
 */
void
rip_ctlinput(cmd, sa, vip)
	int cmd;
	struct sockaddr *sa;
	void *vip;
{
	struct in_ifaddr *ia;
	struct ifnet *ifp;
	int err;
	int flags;

	switch (cmd) {
	case PRC_IFDOWN:
		for (ia = in_ifaddr; ia; ia = ia->ia_next) {
			if (ia->ia_ifa.ifa_addr == sa
			    && (ia->ia_flags & IFA_ROUTE)) {
				/*
				 * in_ifscrub kills the interface route.
				 */
				in_ifscrub(ia->ia_ifp, ia);
				/*
				 * in_ifadown gets rid of all the rest of
				 * the routes.  This is not quite the right
				 * thing to do, but at least if we are running
				 * a routing process they will come back.
				 */
				in_ifadown(&ia->ia_ifa, 0);
				break;
			}
		}
		break;

	case PRC_IFUP:
		for (ia = in_ifaddr; ia; ia = ia->ia_next) {
			if (ia->ia_ifa.ifa_addr == sa)
				break;
		}
		if (ia == 0 || (ia->ia_flags & IFA_ROUTE))
			return;
		flags = RTF_UP;
		ifp = ia->ia_ifa.ifa_ifp;

		if ((ifp->if_flags & IFF_LOOPBACK)
		    || (ifp->if_flags & IFF_POINTOPOINT))
			flags |= RTF_HOST;

		err = rtinit(&ia->ia_ifa, RTM_ADD, flags);
		if (err == 0)
			ia->ia_flags |= IFA_ROUTE;
		break;
	}
}

static u_long	rip_sendspace = RIPSNDQ;
static u_long	rip_recvspace = RIPRCVQ;

SYSCTL_INT(_net_inet_raw, OID_AUTO, maxdgram, CTLFLAG_RW,
    &rip_sendspace, 0, "Maximum outgoing raw IP datagram size");
SYSCTL_INT(_net_inet_raw, OID_AUTO, recvspace, CTLFLAG_RW,
    &rip_recvspace, 0, "Maximum incoming raw IP datagram size");

int
rip_usrreq(so, req, m, nam, control)
	register struct socket *so;
	int req;
	struct mbuf *m, *nam, *control;
{
	register int error = 0;
	register struct inpcb *inp = sotoinpcb(so);

	if (req == PRU_CONTROL)
		return (in_control(so, (u_long)m, (caddr_t)nam,
			(struct ifnet *)control));

	switch (req) {

	case PRU_ATTACH:
		if (inp) {
			panic("rip_attach");
			return (EFAULT);
		}
		if ((so->so_state & SS_PRIV) == 0) {
			error = EACCES;
			break;
		}
		if ((error = soreserve(so, rip_sendspace, rip_recvspace)) ||
		    (error = in_pcballoc(so, &ripcbinfo)))
			break;
		inp = (struct inpcb *)so->so_pcb;
		inp->inp_ip_p = (int)nam;
		break;

	case PRU_DISCONNECT:
		if ((so->so_state & SS_ISCONNECTED) == 0) {
			error = ENOTCONN;
			break;
		}
		/* FALLTHROUGH */
	case PRU_ABORT:
		soisdisconnected(so);
		/* FALLTHROUGH */
	case PRU_DETACH:
		if (inp == 0)
			panic("rip_detach");
#ifdef MROUTING
		if (so == ip_mrouter)
			ip_mrouter_done();
		ip_rsvp_force_done(so);
		if (so == ip_rsvpd)
			ip_rsvp_done();
#endif
		in_pcbdetach(inp);
		break;

	case PRU_BIND:
	    {
		struct sockaddr_in *addr = mtod(nam, struct sockaddr_in *);

		if (nam->m_len != sizeof(*addr)) {
			error = EINVAL;
			break;
		}
		if ((ifnet == 0) ||
		    ((addr->sin_family != AF_INET) &&
		     (addr->sin_family != AF_IMPLINK)) ||
		    (addr->sin_addr.s_addr &&
		     ifa_ifwithaddr((struct sockaddr *)addr) == 0)) {
			error = EADDRNOTAVAIL;
			break;
		}
		inp->inp_laddr = addr->sin_addr;
		break;
	    }
	case PRU_CONNECT:
	    {
		struct sockaddr_in *addr = mtod(nam, struct sockaddr_in *);

		if (nam->m_len != sizeof(*addr)) {
			error = EINVAL;
			break;
		}
		if (ifnet == 0) {
			error = EADDRNOTAVAIL;
			break;
		}
		if ((addr->sin_family != AF_INET) &&
		     (addr->sin_family != AF_IMPLINK)) {
			error = EAFNOSUPPORT;
			break;
		}
		inp->inp_faddr = addr->sin_addr;
		soisconnected(so);
		break;
	    }

	case PRU_CONNECT2:
		error = EOPNOTSUPP;
		break;

	/*
	 * Mark the connection as being incapable of further input.
	 */
	case PRU_SHUTDOWN:
		socantsendmore(so);
		break;

	/*
	 * Ship a packet out.  The appropriate raw output
	 * routine handles any massaging necessary.
	 */
	case PRU_SEND:
	    {
		register u_long dst;

		if (so->so_state & SS_ISCONNECTED) {
			if (nam) {
				error = EISCONN;
				break;
			}
			dst = inp->inp_faddr.s_addr;
		} else {
			if (nam == NULL) {
				error = ENOTCONN;
				break;
			}
			dst = mtod(nam, struct sockaddr_in *)->sin_addr.s_addr;
		}
		error = rip_output(m, so, dst);
		m = NULL;
		break;
	    }

	case PRU_SENSE:
		/*
		 * stat: don't bother with a blocksize.
		 */
		return (0);

	/*
	 * Not supported.
	 */
	case PRU_RCVOOB:
	case PRU_RCVD:
	case PRU_LISTEN:
	case PRU_ACCEPT:
	case PRU_SENDOOB:
		error = EOPNOTSUPP;
		break;

	case PRU_SOCKADDR:
		in_setsockaddr(inp, nam);
		break;

	case PRU_PEERADDR:
		in_setpeeraddr(inp, nam);
		break;

	default:
		panic("rip_usrreq");
	}
	if (m != NULL)
		m_freem(m);
	return (error);
}

static int
rip_pcblist SYSCTL_HANDLER_ARGS
{
	int error, i, n, s;
	struct inpcb *inp, **inp_list;
	inp_gen_t gencnt;
	struct xinpgen xig;

	/*
	 * The process of preparing the TCB list is too time-consuming and
	 * resource-intensive to repeat twice on every request.
	 */
	if (req->oldptr == 0) {
		n = ripcbinfo.ipi_count;
		req->oldidx = 2 * (sizeof xig)
			+ (n + n/8) * sizeof(struct xinpcb);
		return 0;
	}

	if (req->newptr != 0)
		return EPERM;

	/*
	 * OK, now we're committed to doing something.
	 */
	s = splnet();
	gencnt = ripcbinfo.ipi_gencnt;
	n = ripcbinfo.ipi_count;
	splx(s);

	xig.xig_len = sizeof xig;
	xig.xig_count = n;
	xig.xig_gen = gencnt;
	xig.xig_sogen = so_gencnt;
	error = SYSCTL_OUT(req, &xig, sizeof xig);
	if (error)
		return error;

	inp_list = malloc(n * sizeof *inp_list, M_TEMP, M_WAITOK);
	if (inp_list == 0)
		return ENOMEM;

	s = splnet();
	for (inp = ripcbinfo.listhead->lh_first, i = 0; inp && i < n;
	     inp = inp->inp_list.le_next) {
		if (inp->inp_gencnt <= gencnt)
			inp_list[i++] = inp;
	}
	splx(s);
	n = i;

	error = 0;
	for (i = 0; i < n; i++) {
		inp = inp_list[i];
		if (inp->inp_gencnt <= gencnt) {
			struct xinpcb xi;
			xi.xi_len = sizeof xi;
			/* XXX should avoid extra copy */
			bcopy(inp, &xi.xi_inp, sizeof *inp);
			if (inp->inp_socket)
				sotoxsocket(inp->inp_socket, &xi.xi_socket);
			error = SYSCTL_OUT(req, &xi, sizeof xi);
		}
	}
	if (!error) {
		/*
		 * Give the user an updated idea of our state.
		 * If the generation differs from what we told
		 * her before, she knows that something happened
		 * while we were processing this request, and it
		 * might be necessary to retry.
		 */
		s = splnet();
		xig.xig_gen = ripcbinfo.ipi_gencnt;
		xig.xig_sogen = so_gencnt;
		xig.xig_count = ripcbinfo.ipi_count;
		splx(s);
		error = SYSCTL_OUT(req, &xig, sizeof xig);
	}
	free(inp_list, M_TEMP);
	return error;
}

SYSCTL_PROC(_net_inet_raw, OID_AUTO/*XXX*/, pcblist, CTLFLAG_RD, 0, 0,
	    rip_pcblist, "S,xinpcb", "List of active raw IP sockets");
@


4.5
log
@Added new FreeBSD sysctl handling using linker magic.
A few new sysctls added as a result.
SO_TIMESTAMP now gives real time, not Internet's internal time.
DHCP/BOOTP parsing picks up URL option and pops it into Inet$URL.
Requires TCPIPLibs 5.25 and link 5.12.

Version 5.31. Tagged as 'Internet-5_31'
@
text
@d341 60
@


4.4
log
@* Dynamic ports now assigned in range 49152-65535.
* IP_RECVDSTADDR works for non-unicast packets.
* SO_TIMESTAMP added.
* IP_RECVIF added.
* Various other internal changes merged in from FreeBSD sources.

Version 5.29. Tagged as 'Internet-5_29'
@
text
@d36 2
d40 2
a42 1
#include <sys/protosw.h>
d45 1
a45 2
#include <sys/systm.h>
#include <sys/queue.h>
d341 7
a347 2
static u_long	rip_sendspace = RIPSNDQ; /* XXX sysctl ? */
static u_long	rip_recvspace = RIPRCVQ; /* XXX sysctl ? */
d512 86
@


4.3
log
@* Fixed bug introduced by tentative ARP probe - a typo made arp_ifinit() fail to
  set up the interface route structure properly.
* Divide-by-zero when an IGMP membership query with a time of 1 received fixed
  (from FreeBSD).
* IGMP messages now sent with TOS set to "maximum reliability".
* tcp_output.c updated from FreeBSD - in particular path_mtu_discovery sysctl
  now available.
* A few other FreeBSD structural changes and bug fixes integrated.
* Put UDP checksum in BOOTP packets.
* Null pointer dereferencing fixed in whoami.c. Address setting now done with
  SIOCDIFADDR and SIOCAIFADDR. Don't set the netmask if asked not to.
* Output BOOTP packets with the source address in ciaddr
Note that various structural changes mean that the support tools (in particular
InetStat) will need to be recompiled.
Requires TCPIPLibs 5.20

Version 5.27. Tagged as 'Internet-5_27'
@
text
@d101 2
a102 1
	struct socket *last = 0;
d117 4
a120 1
				if (sbappendaddr(&last->so_rcv,
d122 1
a122 1
				    (struct mbuf *)0) == 0)
d125 5
a129 2
				else
					sorwakeup(last);
d132 1
a132 1
		last = inp->inp_socket;
d135 5
a139 2
		if (sbappendaddr(&last->so_rcv, (struct sockaddr *)&ripsrc,
		    m, (struct mbuf *)0) == 0)
d141 4
a144 2
		else
			sorwakeup(last);
@


4.2
log
@Version Spinner_B7 taken
@
text
@d105 1
a105 1
		if (inp->inp_ip.ip_p && inp->inp_ip.ip_p != ip->ip_p)
d181 1
a181 1
		ip->ip_p = inp->inp_ip.ip_p;
d358 1
a358 1
		inp->inp_ip.ip_p = (int)nam;
@


4.1
log
@Initial revision
@
text
@d1 3
a3 1
/* -*-C-*-
d5 15
a19 2
 * $Header: /ax/networking:Internet/netinet/raw_ip.c:networking  1.1  $
 * $Source: /ax/networking:Internet/netinet/raw_ip.c: $
d21 11
a31 1
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
a32 4
 * $Log:	raw_ip.c,v $
 * Revision 1.1  94/12/02  11:18:48  kwelton
 * Initial revision
 * 
d34 29
d64 1
a64 15
 * Copyright (c) 1983, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
d66 2
a67 15
#include "sys/param.h"
#include "sys/mbuf.h"
#include "sys/socket.h"
#include "sys/protosw.h"
#include "sys/socketvar.h"
#include "sys/errno.h"

#include "net/if.h"
#include "net/route.h"
#include "net/raw_cb.h"

#include "netinet/in.h"
#include "netinet/in_systm.h"
#include "netinet/ip.h"
#include "netinet/ip_var.h"
d73 17
a89 3
struct	sockaddr_in ripdst = { AF_INET };
struct	sockaddr_in ripsrc = { AF_INET };
struct	sockproto ripproto = { PF_INET };
d95 1
d100 2
a102 2
	ripproto.sp_protocol = ip->ip_p;
	ripdst.sin_addr = ip->ip_dst;
d104 34
a137 2
	raw_input(m, &ripproto, (struct sockaddr *)&ripsrc,
	  (struct sockaddr *)&ripdst);
d144 3
a146 2
rip_output(m0, so)
	struct mbuf *m0;
d148 1
a149 1
	register struct mbuf *m;
d151 3
a153 3
	int len = 0, error;
	struct rawcb *rp = sotorawcb(so);
	struct sockaddr_in *sin;
d155 3
d159 2
a160 2
	 * Calculate data length and get an mbuf
	 * for IP header.
d162 6
a167 14
	for (m = m0; m; m = m->m_next)
		len += m->m_len;
#ifdef OldCode
	m = m_get(M_DONTWAIT, MT_HEADER);
	if (m == 0) {
		error = ENOBUFS;
		goto bad;
	}
#else
	if( (m = ALLOC_S(MINCONTIG, NULL)) == NULL )
	{
#ifdef DEBUG
	    if( DODEBUG(DBGMMAN) )
		Printf("rip_output: ALLOC_S failed\n");
d169 6
a174 4
	    error = ENOBUFS;
	    goto bad;
	}
	m->m_type = MT_HEADER;
d176 12
a187 4

	/* TRACE */
#ifdef DEBUGSEND
	Printf("rip_output: m = %x, m0 = %x\n", m, m0);
d189 12
a200 36

	/*
	 * Fill in IP header as needed.
	 */
	m->m_off = MAXOFF(m) - sizeof(struct ip);
	m->m_len = sizeof(struct ip);
	m->m_next = m0;
	ip = mtod(m, struct ip *);
	ip->ip_tos = 0;
	ip->ip_off = 0;
	ip->ip_p = rp->rcb_proto.sp_protocol;
	ip->ip_len = sizeof(struct ip) + len;
	if (rp->rcb_flags & RAW_LADDR) {
		sin = (struct sockaddr_in *)&rp->rcb_laddr;
		if (sin->sin_family != AF_INET) {
			error = EAFNOSUPPORT;
			goto bad;
		}
		ip->ip_src.s_addr = sin->sin_addr.s_addr;
	} else
		ip->ip_src.s_addr = 0;
	ip->ip_dst = ((struct sockaddr_in *)&rp->rcb_faddr)->sin_addr;
	ip->ip_ttl = MAXTTL;
	/* TRACE */
#ifdef DEBUGSEND
	Printf("rip_output: sending from %s to %s\n",
	       inet_ntoa(ip->ip_src.s_addr),
	       inet_ntoa(ip->ip_dst.s_addr));
#endif
	return (ip_output(m, rp->rcb_options, &rp->rcb_route,
	   (so->so_options & SO_DONTROUTE) | IP_ALLOWBROADCAST));
bad:
#ifdef OldCode
	m_freem(m);
#else
	FREEM(m);
d202 1
a202 1
	return (error);
d208 1
d215 56
a270 2
	int error = 0;
	register struct rawcb *rp = sotorawcb(so);
d272 15
a286 8
	if (level != IPPROTO_IP)
		error = EINVAL;
	else switch (op) {

	case PRCO_SETOPT:
		switch (optname) {
		case IP_OPTIONS:
			return (ip_pcbopts(&rp->rcb_options, *m));
d288 33
a320 1
		default:
d322 30
d354 5
d361 18
a378 13
	case PRCO_GETOPT:
		switch (optname) {
		case IP_OPTIONS:
#ifdef OldCode
			*m = m_get(M_WAIT, MT_SOOPTS);
			if (m == 0)
				return (ENOBUFS);
#else
			if( (*m = ALLOC_S(MINCONTIG, NULL)) == NULL )
			{
#ifdef DEBUG
			    if( DODEBUG(DBGMMAN) )
				Printf("rip_ctloutput: ALLOC_S failed\n");
d380 6
a385 2
			    return(ENOBUFS);
			}
d387 10
a396 9
			(*m)->m_type = MT_SOOPTS;
#endif
			if (rp->rcb_options) {
				(*m)->m_off = rp->rcb_options->m_off;
				(*m)->m_len = rp->rcb_options->m_len;
				bcopy(mtod(rp->rcb_options, caddr_t),
				    mtod(*m, caddr_t), (unsigned)(*m)->m_len);
			} else
				(*m)->m_len = 0;
d398 9
a406 1
		default:
d410 11
d422 66
d489 2
a490 8
	if (op == PRCO_SETOPT && *m)
	{
#ifdef OldCode
	    (void)m_free(*m);
#else
	    FREE(*m);
#endif
	}
a492 2

/* EOF raw_ip.c */
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d1 1
a1 3
/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
d3 2
a4 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d6 1
a6 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d8 4
a12 29

#include <sys/param.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/protosw.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/systm.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
#include <netinet/ip_mroute.h>

#include <netinet/ip_fw.h>

#include "module.h"

static struct inpcbhead ripcb;
static struct inpcbinfo ripcbinfo;

d14 15
a28 1
 * Nominal space allocated to a raw ip socket.
d30 15
a44 2
#define	RIPSNDQ		8192
#define	RIPRCVQ		8192
d50 3
a52 17
/*
 * Initialize raw connection block q.
 */
void
rip_init()
{
	LIST_INIT(&ripcb);
	ripcbinfo.listhead = &ripcb;
	/*
	 * XXX We don't use the hash list for raw IP, but it's easier
	 * to allocate a one entry hash list than it is to check all
	 * over the place for hashbase == NULL.
	 */
	ripcbinfo.hashbase = phashinit(1, M_PCB, &ripcbinfo.hashsize);
}

static struct	sockaddr_in ripsrc = { sizeof(ripsrc), AF_INET };
a57 1
void
a61 2
	register struct inpcb *inp;
	struct socket *last = 0;
d63 2
d66 2
a67 34
	for (inp = ripcb.lh_first; inp != NULL; inp = inp->inp_list.le_next) {
		if (inp->inp_ip.ip_p && inp->inp_ip.ip_p != ip->ip_p)
			continue;
		if (inp->inp_laddr.s_addr &&
                  inp->inp_laddr.s_addr != ip->ip_dst.s_addr)
			continue;
		if (inp->inp_faddr.s_addr &&
                  inp->inp_faddr.s_addr != ip->ip_src.s_addr)
			continue;
		if (last) {
			struct mbuf *n = m_copy(m, 0, M_COPYALL);
			if (n) {
				if (sbappendaddr(&last->so_rcv,
				    (struct sockaddr *)&ripsrc, n,
				    (struct mbuf *)0) == 0)
					/* should notify about lost packet */
					m_freem(n);
				else
					sorwakeup(last);
			}
		}
		last = inp->inp_socket;
	}
	if (last) {
		if (sbappendaddr(&last->so_rcv, (struct sockaddr *)&ripsrc,
		    m, (struct mbuf *)0) == 0)
			m_freem(m);
		else
			sorwakeup(last);
	} else {
		m_freem(m);
		ipstat.ips_noproto++;
		ipstat.ips_delivered--;
      }
d74 2
a75 3
int
rip_output(m, so, dst)
	register struct mbuf *m;
a76 1
	u_long dst;
d78 1
d80 3
a82 3
	register struct inpcb *inp = sotoinpcb(so);
	struct mbuf *opts;
	int flags = (so->so_options & SO_DONTROUTE) | IP_ALLOWBROADCAST;
a83 3
#if 0
        Printf("rip_output(m=%x, so=%x, dst=%X)\n", m, so, dst);
#endif
d85 2
a86 2
	 * If the user handed us a complete IP packet, use it.
	 * Otherwise, allocate an mbuf for a header and fill it in.
d88 14
a101 6
	if ((inp->inp_flags & INP_HDRINCL) == 0) {
#if 0
                Printf("RIP_OUTPUT: Prepending header.  m->m_flags & M_PKTHDR=%d "
                       "m->m_pkthdr.len = %d m->m_len = %d M_LEADINGSPACE(m) = %d\n",
                       m->m_flags & M_PKTHDR, m->m_pkthdr.len, m->m_len,
                       M_LEADINGSPACE(m));
d103 4
a106 6
		M_PREPEND(m, sizeof(struct ip), M_WAIT);
#if 0
                Printf("RIP_OUTPUT: Prepended header.  m->m_flags & M_PKTHDR=%d "
                       "m->m_pkthdr.len = %d m->m_len = %d M_LEADINGSPACE(m) = %d\n",
                       m->m_flags & M_PKTHDR, m->m_pkthdr.len, m->m_len,
                       M_LEADINGSPACE(m));
d108 4
a111 12
		if (m == 0)
			return (ENOBUFS);
                ip = mtod(m, struct ip *);
		ip->ip_tos = 0;
		ip->ip_off = 0;
		ip->ip_p = inp->inp_ip.ip_p;
		ip->ip_len = m->m_pkthdr.len;
		ip->ip_src = inp->inp_laddr;
		ip->ip_dst.s_addr = dst;
		ip->ip_ttl = MAXTTL;
#if 0
                Printf("Dest = %x, Src = %x\n", ip->ip_dst, ip->ip_src);
d113 36
a148 12
		opts = inp->inp_options;
	} else {
		ip = mtod(m, struct ip *);
		if (ip->ip_id == 0)
			ip->ip_id = htons(ip_id++);
		opts = NULL;
		/* XXX prevent ip_output from overwriting header fields */
		flags |= IP_RAWOUTPUT;
		ipstat.ips_rawout++;
	}
#if 0
        Printf("calling ip_output(m=%x, opts=%x, route=%x, flags=%x, options=%x)\n", m, opts, &inp->inp_route, flags, inp->inp_moptions);
d150 1
a150 1
	return (ip_output(m, opts, &inp->inp_route, flags, inp->inp_moptions));
a155 1
int
d162 2
a163 56
	register struct inpcb *inp = sotoinpcb(so);
	register int error;

	if (level != IPPROTO_IP) {
		if (op == PRCO_SETOPT && *m)
			(void)m_free(*m);
		return (EINVAL);
	}

	switch (optname) {

	case IP_HDRINCL:
		error = 0;
		if (op == PRCO_SETOPT) {
			if (m == 0 || *m == 0 || (*m)->m_len < sizeof (int))
				error = EINVAL;
			else if (*mtod(*m, int *))
				inp->inp_flags |= INP_HDRINCL;
			else
				inp->inp_flags &= ~INP_HDRINCL;
			if (*m)
				(void)m_free(*m);
		} else {
			*m = ALLOC_S(MINCONTIG, NULL);
			if (*m == 0)
				return (ENOBUFS);
			(*m)->m_type = MT_SOOPTS;
			(*m)->m_len = sizeof (int);
			*mtod(*m, int *) = inp->inp_flags & INP_HDRINCL;
		}
		return (error);

#ifdef IPFIREWALL
#ifdef __riscos
	case IP_FW_ACTIVE:
		if (op == PRCO_SETOPT) {
		    	extern int ipfw_load(void), ipfw_unload(void);
		    	error = 0;
			if (m == 0 || *m == 0 || (*m)->m_len < sizeof (int))
				error = EINVAL;
			else if (*mtod(*m, int *))
				error = ipfw_load();
			else
				error = ipfw_unload();
			if (*m)
				(void)m_free(*m);
		} else {
			*m = ALLOC_S(0, NULL);
			if (*m == 0)
				return(ENOBUFS);
			(*m)->m_type = MT_SOOPTS;
			(*m)->m_len = sizeof (int);
			*mtod(*m, int *) = ip_fw_ctl_ptr != 0;
			error = 0;
		}
		return (error);
d165 8
a172 15
#endif
	case IP_FW_GET:
		if (ip_fw_ctl_ptr==NULL || op == PRCO_SETOPT) {
			if (*m) (void)m_free(*m);
			return(EINVAL);
		}
		return (*ip_fw_ctl_ptr)(optname, m);
	case IP_FW_ADD:
	case IP_FW_DEL:
	case IP_FW_FLUSH:
	case IP_FW_ZERO:
		if (ip_fw_ctl_ptr==NULL || op != PRCO_SETOPT) {
			if (*m) (void)m_free(*m);
			return(EINVAL);
		}
d174 1
a174 33
		return (*ip_fw_ctl_ptr)(optname, m);
		return(error);
#endif

	case IP_RSVP_ON:
		return ip_rsvp_init(so);
		break;

	case IP_RSVP_OFF:
		return ip_rsvp_done();
		break;

	case IP_RSVP_VIF_ON:
		return ip_rsvp_vif_init(so, *m);

	case IP_RSVP_VIF_OFF:
		return ip_rsvp_vif_done(so, *m);

	case MRT_INIT:
	case MRT_DONE:
	case MRT_ADD_VIF:
	case MRT_DEL_VIF:
	case MRT_ADD_MFC:
	case MRT_DEL_MFC:
	case MRT_VERSION:
	case MRT_ASSERT:
		if (op == PRCO_SETOPT) {
			error = ip_mrouter_set(optname, so, *m);
			if (*m)
				(void)m_free(*m);
		} else if (op == PRCO_GETOPT) {
			error = ip_mrouter_get(optname, so, m);
		} else
a175 30
		return (error);
	}
	return (ip_ctloutput(op, so, level, optname, m));
}

static u_long	rip_sendspace = RIPSNDQ; /* XXX sysctl ? */
static u_long	rip_recvspace = RIPRCVQ; /* XXX sysctl ? */

int
rip_usrreq(so, req, m, nam, control)
	register struct socket *so;
	int req;
	struct mbuf *m, *nam, *control;
{
	register int error = 0;
	register struct inpcb *inp = sotoinpcb(so);

	if (req == PRU_CONTROL)
		return (in_control(so, (u_long)m, (caddr_t)nam,
			(struct ifnet *)control));

	switch (req) {

	case PRU_ATTACH:
		if (inp) {
			panic("rip_attach");
			return (EFAULT);
		}
		if ((so->so_state & SS_PRIV) == 0) {
			error = EACCES;
a177 5
		if ((error = soreserve(so, rip_sendspace, rip_recvspace)) ||
		    (error = in_pcballoc(so, &ripcbinfo)))
			break;
		inp = (struct inpcb *)so->so_pcb;
		inp->inp_ip.ip_p = (int)nam;
d180 13
a192 18
	case PRU_DISCONNECT:
		if ((so->so_state & SS_ISCONNECTED) == 0) {
			error = ENOTCONN;
			break;
		}
		/* FALLTHROUGH */
	case PRU_ABORT:
		soisdisconnected(so);
		/* FALLTHROUGH */
	case PRU_DETACH:
		if (inp == 0)
			panic("rip_detach");
#ifdef MROUTING
		if (so == ip_mrouter)
			ip_mrouter_done();
		ip_rsvp_force_done(so);
		if (so == ip_rsvpd)
			ip_rsvp_done();
d194 2
a195 2
		in_pcbdetach(inp);
		break;
d197 9
a205 6
	case PRU_BIND:
	    {
		struct sockaddr_in *addr = mtod(nam, struct sockaddr_in *);

		if (nam->m_len != sizeof(*addr)) {
			error = EINVAL;
d207 1
a207 17
		}
		if ((ifnet == 0) ||
		    ((addr->sin_family != AF_INET) &&
		     (addr->sin_family != AF_IMPLINK)) ||
		    (addr->sin_addr.s_addr &&
		     ifa_ifwithaddr((struct sockaddr *)addr) == 0)) {
			error = EADDRNOTAVAIL;
			break;
		}
		inp->inp_laddr = addr->sin_addr;
		break;
	    }
	case PRU_CONNECT:
	    {
		struct sockaddr_in *addr = mtod(nam, struct sockaddr_in *);

		if (nam->m_len != sizeof(*addr)) {
a210 11
		if (ifnet == 0) {
			error = EADDRNOTAVAIL;
			break;
		}
		if ((addr->sin_family != AF_INET) &&
		     (addr->sin_family != AF_IMPLINK)) {
			error = EAFNOSUPPORT;
			break;
		}
		inp->inp_faddr = addr->sin_addr;
		soisconnected(so);
a211 66
	    }

	case PRU_CONNECT2:
		error = EOPNOTSUPP;
		break;

	/*
	 * Mark the connection as being incapable of further input.
	 */
	case PRU_SHUTDOWN:
		socantsendmore(so);
		break;

	/*
	 * Ship a packet out.  The appropriate raw output
	 * routine handles any massaging necessary.
	 */
	case PRU_SEND:
	    {
		register u_long dst;

		if (so->so_state & SS_ISCONNECTED) {
			if (nam) {
				error = EISCONN;
				break;
			}
			dst = inp->inp_faddr.s_addr;
		} else {
			if (nam == NULL) {
				error = ENOTCONN;
				break;
			}
			dst = mtod(nam, struct sockaddr_in *)->sin_addr.s_addr;
		}
		error = rip_output(m, so, dst);
		m = NULL;
		break;
	    }

	case PRU_SENSE:
		/*
		 * stat: don't bother with a blocksize.
		 */
		return (0);

	/*
	 * Not supported.
	 */
	case PRU_RCVOOB:
	case PRU_RCVD:
	case PRU_LISTEN:
	case PRU_ACCEPT:
	case PRU_SENDOOB:
		error = EOPNOTSUPP;
		break;

	case PRU_SOCKADDR:
		in_setsockaddr(inp, nam);
		break;

	case PRU_PEERADDR:
		in_setpeeraddr(inp, nam);
		break;

	default:
		panic("rip_usrreq");
d213 8
a220 2
	if (m != NULL)
		m_freem(m);
d223 2
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d3 1
a3 1
 * $Header: /ax/networking:Internet/netinet/raw_ip.c:networking  1.2  $
a8 4
 * Revision 1.2  95/06/13  10:54:35  kwelton
 * Added the Van Jacobsen mods. to rip_output() to allow transmission of
 * completely raw packets.
 * 
d74 2
a75 2
rip_output(m, so)
	struct mbuf *m;
d78 1
d80 1
a80 1
	int error;
a82 1
	short proto = rp->rcb_proto.sp_protocol;
d85 2
a86 3
	 * if the protocol is IPPROTO_RAW, the user handed us a 
	 * complete IP packet.  Otherwise, allocate an mbuf for a
	 * header and fill it in as needed.
d88 2
a89 11
	if (proto != IPPROTO_RAW) {
		/*
		 * Calculate data length and get an mbuf
		 * for IP header.
		 */
		int len = 0;
		struct mbuf *m0;

		for (m0 = m; m; m = m->m_next)
			len += m->m_len;

d91 5
a95 6
		m = m_get(M_DONTWAIT, MT_HEADER);
		if (m == 0) {
			m = m0;
			error = ENOBUFS;
			goto bad;
		}
d97 2
a98 2
		if( (m = ALLOC_S(MINCONTIG, NULL)) == NULL )
		{
d100 2
a101 2
		    if( DODEBUG(DBGMMAN) )
			Printf("rip_output: ALLOC_S failed\n");
d103 4
a106 5
		    m = m0;
		    error = ENOBUFS;
		    goto bad;
		}
		m->m_type = MT_HEADER;
d109 4
a112 14
		/*
		 * Fill in IP header as needed.
		 */
		m->m_off = MAXOFF(m) - sizeof(struct ip);
		m->m_len = sizeof(struct ip);
		m->m_next = m0;
		ip = mtod(m, struct ip *);
		ip->ip_tos = 0;
		ip->ip_off = 0;
		ip->ip_p = proto;
		ip->ip_len = sizeof(struct ip) + len;
		ip->ip_ttl = MAXTTL;
	} else
		ip = mtod(m, struct ip *);
d114 11
a133 1

d135 7
a141 1

@


4.1.7.2
log
@RCS log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@d3 1
a3 1
 * $Header: /ax/networking:Internet/netinet/raw_ip.c:networking  1.2  $
a8 4
 * Revision 1.2  95/06/13  10:54:35  kwelton
 * Added the Van Jacobsen mods. to rip_output() to allow transmission of
 * completely raw packets.
 * 
d74 2
a75 2
rip_output(m, so)
	struct mbuf *m;
d78 1
d80 1
a80 1
	int error;
a82 1
	short proto = rp->rcb_proto.sp_protocol;
d85 2
a86 3
	 * if the protocol is IPPROTO_RAW, the user handed us a 
	 * complete IP packet.  Otherwise, allocate an mbuf for a
	 * header and fill it in as needed.
d88 2
a89 11
	if (proto != IPPROTO_RAW) {
		/*
		 * Calculate data length and get an mbuf
		 * for IP header.
		 */
		int len = 0;
		struct mbuf *m0;

		for (m0 = m; m; m = m->m_next)
			len += m->m_len;

d91 5
a95 6
		m = m_get(M_DONTWAIT, MT_HEADER);
		if (m == 0) {
			m = m0;
			error = ENOBUFS;
			goto bad;
		}
d97 2
a98 2
		if( (m = ALLOC_S(MINCONTIG, NULL)) == NULL )
		{
d100 2
a101 2
		    if( DODEBUG(DBGMMAN) )
			Printf("rip_output: ALLOC_S failed\n");
d103 4
a106 5
		    m = m0;
		    error = ENOBUFS;
		    goto bad;
		}
		m->m_type = MT_HEADER;
d109 4
a112 14
		/*
		 * Fill in IP header as needed.
		 */
		m->m_off = MAXOFF(m) - sizeof(struct ip);
		m->m_len = sizeof(struct ip);
		m->m_next = m0;
		ip = mtod(m, struct ip *);
		ip->ip_tos = 0;
		ip->ip_off = 0;
		ip->ip_p = proto;
		ip->ip_len = sizeof(struct ip) + len;
		ip->ip_ttl = MAXTTL;
	} else
		ip = mtod(m, struct ip *);
d114 11
a133 1

d135 7
a141 1

@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d1 1
a1 3
/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
d3 2
a4 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d6 1
a6 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d8 4
a11 2
 *	@@(#)raw_ip.c	8.7 (Berkeley) 5/15/95
 *	$Id: raw_ip.c,v 1.19.4.6 1996/02/26 15:23:39 phk Exp $
a12 29

#include <sys/param.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/protosw.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/systm.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
#include <netinet/ip_mroute.h>

#include <netinet/ip_fw.h>

#include "module.h"

static struct inpcbhead ripcb;
static struct inpcbinfo ripcbinfo;

d14 15
a28 1
 * Nominal space allocated to a raw ip socket.
d30 15
a44 2
#define	RIPSNDQ		8192
#define	RIPRCVQ		8192
d50 3
a52 17
/*
 * Initialize raw connection block q.
 */
void
rip_init()
{
	LIST_INIT(&ripcb);
	ripcbinfo.listhead = &ripcb;
	/*
	 * XXX We don't use the hash list for raw IP, but it's easier
	 * to allocate a one entry hash list than it is to check all
	 * over the place for hashbase == NULL.
	 */
	ripcbinfo.hashbase = phashinit(1, M_PCB, &ripcbinfo.hashsize);
}

static struct	sockaddr_in ripsrc = { sizeof(ripsrc), AF_INET };
a57 1
void
a61 2
	register struct inpcb *inp;
	struct socket *last = 0;
d63 2
d66 2
a67 34
	for (inp = ripcb.lh_first; inp != NULL; inp = inp->inp_list.le_next) {
		if (inp->inp_ip.ip_p && inp->inp_ip.ip_p != ip->ip_p)
			continue;
		if (inp->inp_laddr.s_addr &&
                  inp->inp_laddr.s_addr != ip->ip_dst.s_addr)
			continue;
		if (inp->inp_faddr.s_addr &&
                  inp->inp_faddr.s_addr != ip->ip_src.s_addr)
			continue;
		if (last) {
			struct mbuf *n = m_copy(m, 0, M_COPYALL);
			if (n) {
				if (sbappendaddr(&last->so_rcv,
				    (struct sockaddr *)&ripsrc, n,
				    (struct mbuf *)0) == 0)
					/* should notify about lost packet */
					m_freem(n);
				else
					sorwakeup(last);
			}
		}
		last = inp->inp_socket;
	}
	if (last) {
		if (sbappendaddr(&last->so_rcv, (struct sockaddr *)&ripsrc,
		    m, (struct mbuf *)0) == 0)
			m_freem(m);
		else
			sorwakeup(last);
	} else {
		m_freem(m);
		ipstat.ips_noproto++;
		ipstat.ips_delivered--;
      }
d74 2
a75 3
int
rip_output(m, so, dst)
	register struct mbuf *m;
a76 1
	u_long dst;
d78 1
d80 3
a82 3
	register struct inpcb *inp = sotoinpcb(so);
	struct mbuf *opts;
	int flags = (so->so_options & SO_DONTROUTE) | IP_ALLOWBROADCAST;
a83 3
#if 0
        Printf("rip_output(m=%x, so=%x, dst=%X)\n", m, so, dst);
#endif
d85 2
a86 2
	 * If the user handed us a complete IP packet, use it.
	 * Otherwise, allocate an mbuf for a header and fill it in.
d88 14
a101 6
	if ((inp->inp_flags & INP_HDRINCL) == 0) {
#if 0
                Printf("RIP_OUTPUT: Prepending header.  m->m_flags & M_PKTHDR=%d "
                       "m->m_pkthdr.len = %d m->m_len = %d M_LEADINGSPACE(m) = %d\n",
                       m->m_flags & M_PKTHDR, m->m_pkthdr.len, m->m_len,
                       M_LEADINGSPACE(m));
d103 4
a106 6
		M_PREPEND(m, sizeof(struct ip), M_WAIT);
#if 0
                Printf("RIP_OUTPUT: Prepended header.  m->m_flags & M_PKTHDR=%d "
                       "m->m_pkthdr.len = %d m->m_len = %d M_LEADINGSPACE(m) = %d\n",
                       m->m_flags & M_PKTHDR, m->m_pkthdr.len, m->m_len,
                       M_LEADINGSPACE(m));
d108 4
a111 12
		if (m == 0)
			return (ENOBUFS);
                ip = mtod(m, struct ip *);
		ip->ip_tos = 0;
		ip->ip_off = 0;
		ip->ip_p = inp->inp_ip.ip_p;
		ip->ip_len = m->m_pkthdr.len;
		ip->ip_src = inp->inp_laddr;
		ip->ip_dst.s_addr = dst;
		ip->ip_ttl = MAXTTL;
#if 0
                Printf("Dest = %x, Src = %x\n", ip->ip_dst, ip->ip_src);
d113 36
a148 12
		opts = inp->inp_options;
	} else {
		ip = mtod(m, struct ip *);
		if (ip->ip_id == 0)
			ip->ip_id = htons(ip_id++);
		opts = NULL;
		/* XXX prevent ip_output from overwriting header fields */
		flags |= IP_RAWOUTPUT;
		ipstat.ips_rawout++;
	}
#if 0
        Printf("calling ip_output(m=%x, opts=%x, route=%x, flags=%x, options=%x)\n", m, opts, &inp->inp_route, flags, inp->inp_moptions);
d150 1
a150 1
	return (ip_output(m, opts, &inp->inp_route, flags, inp->inp_moptions));
a155 1
int
d162 2
a163 56
	register struct inpcb *inp = sotoinpcb(so);
	register int error;

	if (level != IPPROTO_IP) {
		if (op == PRCO_SETOPT && *m)
			(void)m_free(*m);
		return (EINVAL);
	}

	switch (optname) {

	case IP_HDRINCL:
		error = 0;
		if (op == PRCO_SETOPT) {
			if (m == 0 || *m == 0 || (*m)->m_len < sizeof (int))
				error = EINVAL;
			else if (*mtod(*m, int *))
				inp->inp_flags |= INP_HDRINCL;
			else
				inp->inp_flags &= ~INP_HDRINCL;
			if (*m)
				(void)m_free(*m);
		} else {
			*m = ALLOC_S(MINCONTIG, NULL);
			if (*m == 0)
				return (ENOBUFS);
			(*m)->m_type = MT_SOOPTS;
			(*m)->m_len = sizeof (int);
			*mtod(*m, int *) = inp->inp_flags & INP_HDRINCL;
		}
		return (error);

#ifdef IPFIREWALL
#ifdef __riscos
	case IP_FW_ACTIVE:
		if (op == PRCO_SETOPT) {
		    	extern int ipfw_load(), ipfw_unload();
		    	error = 0;
			if (m == 0 || *m == 0 || (*m)->m_len < sizeof (int))
				error = EINVAL;
			else if (*mtod(*m, int *))
				error = ipfw_load();
			else
				error = ipfw_unload();
			if (*m)
				(void)m_free(*m);
		} else {
			*m = ALLOC_S(0, NULL);
			if (*m == 0)
				return(ENOBUFS);
			(*m)->m_type = MT_SOOPTS;
			(*m)->m_len = sizeof (int);
			*mtod(*m, int *) = ip_fw_ctl_ptr != 0;
			error = 0;
		}
		return (error);
d165 8
a172 15
#endif
	case IP_FW_GET:
		if (ip_fw_ctl_ptr==NULL || op == PRCO_SETOPT) {
			if (*m) (void)m_free(*m);
			return(EINVAL);
		}
		return (*ip_fw_ctl_ptr)(optname, m);
	case IP_FW_ADD:
	case IP_FW_DEL:
	case IP_FW_FLUSH:
	case IP_FW_ZERO:
		if (ip_fw_ctl_ptr==NULL || op != PRCO_SETOPT) {
			if (*m) (void)m_free(*m);
			return(EINVAL);
		}
d174 1
a174 33
		return (*ip_fw_ctl_ptr)(optname, m);
		return(error);
#endif

	case IP_RSVP_ON:
		return ip_rsvp_init(so);
		break;

	case IP_RSVP_OFF:
		return ip_rsvp_done();
		break;

	case IP_RSVP_VIF_ON:
		return ip_rsvp_vif_init(so, *m);

	case IP_RSVP_VIF_OFF:
		return ip_rsvp_vif_done(so, *m);

	case MRT_INIT:
	case MRT_DONE:
	case MRT_ADD_VIF:
	case MRT_DEL_VIF:
	case MRT_ADD_MFC:
	case MRT_DEL_MFC:
	case MRT_VERSION:
	case MRT_ASSERT:
		if (op == PRCO_SETOPT) {
			error = ip_mrouter_set(optname, so, *m);
			if (*m)
				(void)m_free(*m);
		} else if (op == PRCO_GETOPT) {
			error = ip_mrouter_get(optname, so, m);
		} else
a175 30
		return (error);
	}
	return (ip_ctloutput(op, so, level, optname, m));
}

static u_long	rip_sendspace = RIPSNDQ; /* XXX sysctl ? */
static u_long	rip_recvspace = RIPRCVQ; /* XXX sysctl ? */

int
rip_usrreq(so, req, m, nam, control)
	register struct socket *so;
	int req;
	struct mbuf *m, *nam, *control;
{
	register int error = 0;
	register struct inpcb *inp = sotoinpcb(so);

	if (req == PRU_CONTROL)
		return (in_control(so, (u_long)m, (caddr_t)nam,
			(struct ifnet *)control));

	switch (req) {

	case PRU_ATTACH:
		if (inp) {
			panic("rip_attach");
			return (EFAULT);
		}
		if ((so->so_state & SS_PRIV) == 0) {
			error = EACCES;
a177 5
		if ((error = soreserve(so, rip_sendspace, rip_recvspace)) ||
		    (error = in_pcballoc(so, &ripcbinfo)))
			break;
		inp = (struct inpcb *)so->so_pcb;
		inp->inp_ip.ip_p = (int)nam;
d180 13
a192 18
	case PRU_DISCONNECT:
		if ((so->so_state & SS_ISCONNECTED) == 0) {
			error = ENOTCONN;
			break;
		}
		/* FALLTHROUGH */
	case PRU_ABORT:
		soisdisconnected(so);
		/* FALLTHROUGH */
	case PRU_DETACH:
		if (inp == 0)
			panic("rip_detach");
#ifdef MROUTING
		if (so == ip_mrouter)
			ip_mrouter_done();
		ip_rsvp_force_done(so);
		if (so == ip_rsvpd)
			ip_rsvp_done();
d194 2
a195 2
		in_pcbdetach(inp);
		break;
d197 9
a205 6
	case PRU_BIND:
	    {
		struct sockaddr_in *addr = mtod(nam, struct sockaddr_in *);

		if (nam->m_len != sizeof(*addr)) {
			error = EINVAL;
d207 1
a207 17
		}
		if ((ifnet == 0) ||
		    ((addr->sin_family != AF_INET) &&
		     (addr->sin_family != AF_IMPLINK)) ||
		    (addr->sin_addr.s_addr &&
		     ifa_ifwithaddr((struct sockaddr *)addr) == 0)) {
			error = EADDRNOTAVAIL;
			break;
		}
		inp->inp_laddr = addr->sin_addr;
		break;
	    }
	case PRU_CONNECT:
	    {
		struct sockaddr_in *addr = mtod(nam, struct sockaddr_in *);

		if (nam->m_len != sizeof(*addr)) {
a210 11
		if (ifnet == 0) {
			error = EADDRNOTAVAIL;
			break;
		}
		if ((addr->sin_family != AF_INET) &&
		     (addr->sin_family != AF_IMPLINK)) {
			error = EAFNOSUPPORT;
			break;
		}
		inp->inp_faddr = addr->sin_addr;
		soisconnected(so);
a211 66
	    }

	case PRU_CONNECT2:
		error = EOPNOTSUPP;
		break;

	/*
	 * Mark the connection as being incapable of further input.
	 */
	case PRU_SHUTDOWN:
		socantsendmore(so);
		break;

	/*
	 * Ship a packet out.  The appropriate raw output
	 * routine handles any massaging necessary.
	 */
	case PRU_SEND:
	    {
		register u_long dst;

		if (so->so_state & SS_ISCONNECTED) {
			if (nam) {
				error = EISCONN;
				break;
			}
			dst = inp->inp_faddr.s_addr;
		} else {
			if (nam == NULL) {
				error = ENOTCONN;
				break;
			}
			dst = mtod(nam, struct sockaddr_in *)->sin_addr.s_addr;
		}
		error = rip_output(m, so, dst);
		m = NULL;
		break;
	    }

	case PRU_SENSE:
		/*
		 * stat: don't bother with a blocksize.
		 */
		return (0);

	/*
	 * Not supported.
	 */
	case PRU_RCVOOB:
	case PRU_RCVD:
	case PRU_LISTEN:
	case PRU_ACCEPT:
	case PRU_SENDOOB:
		error = EOPNOTSUPP;
		break;

	case PRU_SOCKADDR:
		in_setsockaddr(inp, nam);
		break;

	case PRU_PEERADDR:
		in_setpeeraddr(inp, nam);
		break;

	default:
		panic("rip_usrreq");
d213 8
a220 2
	if (m != NULL)
		m_freem(m);
d223 2
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@

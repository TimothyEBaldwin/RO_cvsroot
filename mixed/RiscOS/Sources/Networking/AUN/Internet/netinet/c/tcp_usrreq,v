head	4.6;
access;
symbols
	Internet-5_65:4.6
	Internet-5_64:4.6
	Internet-5_63:4.5
	Internet-5_62:4.5
	Internet-5_61:4.5
	Internet-5_60:4.5
	Internet-5_59:4.5
	Internet-5_58:4.5
	Internet-5_57:4.5
	Internet-5_56:4.5
	Internet-5_55:4.5
	Internet-5_54:4.5
	Internet-5_53:4.5
	Internet-5_52:4.5
	Internet-5_51:4.5
	Internet-5_50:4.5
	RO_5_07:4.5
	Internet-5_49:4.5
	Internet-5_48:4.5
	Internet-5_47:4.5
	Internet-5_46:4.5
	Internet-5_45:4.5
	Internet-5_44:4.5
	Internet-5_43:4.5
	Internet-5_42:4.5
	Internet-5_41:4.5
	Internet-5_40:4.5
	Internet-5_39:4.5
	Internet-5_38:4.5
	Internet-5_37:4.5
	Internet-5_36:4.5
	Internet-5_35:4.5
	Internet-5_34:4.5
	Internet-5_33:4.5
	Internet-5_32:4.5
	Internet-5_31:4.5
	Internet-5_30:4.4
	Internet-5_29:4.4
	Internet-5_27:4.4
	Internet-5_26:4.3
	Internet-5_25:4.3
	Internet-5_24:4.3
	Internet-5_23:4.3
	Internet-5_22:4.3
	Internet-5_21:4.2
	Internet-5_20:4.2
	Internet-5_19:4.2
	Internet-5_18:4.2
	Internet-5_17:4.2
	Internet-5_16:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Internet-5_15:4.2
	Internet-5_14:4.2
	Internet-5_13:4.2
	sforrest_daytona_appflash-0_31:4.2
	Internet-5_12:4.2
	Internet-5_11:4.2
	celkins_Internet-5_10:4.2
	nicke_Internat_25-9-98:4.2
	Internet-5_09:4.2
	blaughto_daytona_appflash-0_30:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rwarren_Internet-5_08:4.2
	Spinner:4.2
	Internet_5_07:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.2
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2018.04.28.09.24.44;	author rool;	state Exp;
branches;
next	4.5;
commitid	aNg1jDrc1Dm1PbAA;

4.5
date	99.07.13.11.13.01;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.06.30.13.15.41;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.06.07.09.43.00;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.59.02;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.09;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.09;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.20.19;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.29.54;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.06.59;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.32;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.06.57;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.45;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.38.44;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.27;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Strip out insecure T/TCP support
Detail:
  RFC6247 moved T/TCP to historic status due to security concerns, this change actively removes the code (where previously we disabled it through sysctl).

  tcp_subr.c: remove T/TCP support (per FreeBSD revision 137139).
  tcp_input.c: remove T/TCP support (per FreeBSD revision 137139).
  tcp_usrreq.c: remove T/TCP support (per FreeBSD revision 137139).
  tcp_output.c: remove T/TCP support (per FreeBSD revision 137139).
Admin:
  Requires TCPIPLibs-5_64.
  Submission for TCP/IP bounty.

Version 5.64. Tagged as 'Internet-5_64'
@
text
@/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include "opt_tcpdebug.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/sysctl.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/protosw.h>
#include <sys/errno.h>
#include <sys/stat.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#include <netinet/tcp_fsm.h>
#include <netinet/tcp_seq.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/tcpip.h>
#ifdef TCPDEBUG
#include <netinet/tcp_debug.h>
#endif

#include "module.h"

/*
 * TCP protocol interface to socket abstraction.
 */
extern	char *tcpstates[];
extern int path_mtu_discovery;
static int	tcp_attach(struct socket *);
static int	tcp_connect(struct tcpcb *, struct mbuf *);
static struct tcpcb *
		tcp_disconnect(struct tcpcb *);
static struct tcpcb *
		tcp_usrclosed(struct tcpcb *);

/*
 * Process a TCP user request for TCP tb.  If this is a send request
 * then m is the mbuf chain of send data.  If this is a timer expiration
 * (called from the software clock routine), then timertype tells which timer.
 */
/*ARGSUSED*/
int
tcp_usrreq(so, req, m, nam, control)
	struct socket *so;
	int req;
	struct mbuf *m, *nam, *control;
{
	register struct inpcb *inp;
	register struct tcpcb *tp = 0;
	struct sockaddr_in *sinp;
	int error = 0;
#ifdef TCPDEBUG
	int ostate;
#endif

	if (req == PRU_CONTROL)
		return (in_control(so, (u_long)m, (caddr_t)nam,
			(struct ifnet *)control));
	if (control && control->m_len) {
		m_freem(control);
		if (m)
			m_freem(m);
		return (EINVAL);
	}

	inp = sotoinpcb(so);
	/*
	 * When a TCP is attached to a socket, then there will be
	 * a (struct inpcb) pointed at by the socket, and this
	 * structure will point at a subsidary (struct tcpcb).
	 */
	if (inp == 0 && req != PRU_ATTACH) {
#if 0
		/*
		 * The following corrects an mbuf leak under rare
		 * circumstances, but has not been fully tested.
		 */
		if (m && req != PRU_SENSE)
			m_freem(m);
#else
		/* safer version of fix for mbuf leak */
		if (m && (req == PRU_SEND || req == PRU_SENDOOB))
			m_freem(m);
#endif
		return (EINVAL);		/* XXX */
	}
	if (inp) {
		tp = intotcpcb(inp);
		/* WHAT IF TP IS 0? */
#ifdef KPROF
		tcp_acounts[tp->t_state][req]++;
#endif
#ifdef TCPDEBUG
		ostate = tp->t_state;
	} else
		ostate = 0;
#else /* TCPDEBUG */
	}
#endif /* TCPDEBUG */

	switch (req) {

	/*
	 * TCP attaches to socket via PRU_ATTACH, reserving space,
	 * and an internet control block.
	 */
	case PRU_ATTACH:
		if (inp) {
			error = EISCONN;
			break;
		}
		error = tcp_attach(so);
		if (error)
			break;
		if ((so->so_options & SO_LINGER) && so->so_linger == 0)
			so->so_linger = TCP_LINGERTIME * hz;
		tp = sototcpcb(so);
		break;

	/*
	 * PRU_DETACH detaches the TCP protocol from the socket.
	 * If the protocol state is non-embryonic, then can't
	 * do this directly: have to initiate a PRU_DISCONNECT,
	 * which may finish later; embryonic TCB's can just
	 * be discarded here.
	 */
	case PRU_DETACH:
		if (tp->t_state > TCPS_LISTEN)
			tp = tcp_disconnect(tp);
		else
			tp = tcp_close(tp);
		break;

	/*
	 * Give the socket an address.
	 */
	case PRU_BIND:
		/*
		 * Must check for multicast addresses and disallow binding
		 * to them.
		 */
		sinp = mtod(nam, struct sockaddr_in *);
		if (sinp->sin_family == AF_INET &&
		    IN_MULTICAST(ntohl(sinp->sin_addr.s_addr))) {
			error = EAFNOSUPPORT;
			break;
		}
		error = in_pcbbind(inp, nam);
		if (error)
			break;
		break;

	/*
	 * Prepare to accept connections.
	 */
	case PRU_LISTEN:
		if (inp->inp_lport == 0)
			error = in_pcbbind(inp, NULL);
		if (error == 0)
			tp->t_state = TCPS_LISTEN;
		break;

	/*
	 * Initiate connection to peer.
	 * Create a template for use in transmissions on this connection.
	 * Enter SYN_SENT state, and mark socket as connecting.
	 * Start keep-alive timer, and seed output sequence space.
	 * Send initial segment on connection.
	 */
	case PRU_CONNECT:
		/*
		 * Must disallow TCP ``connections'' to multicast addresses.
		 */
		sinp = mtod(nam, struct sockaddr_in *);
		if (sinp->sin_family == AF_INET
		    && IN_MULTICAST(ntohl(sinp->sin_addr.s_addr))) {
			error = EAFNOSUPPORT;
			break;
		}

		if ((error = tcp_connect(tp, nam)) != 0)
			break;
		error = tcp_output(tp);
		break;

	/*
	 * Create a TCP connection between two sockets.
	 */
	case PRU_CONNECT2:
		error = EOPNOTSUPP;
		break;

	/*
	 * Initiate disconnect from peer.
	 * If connection never passed embryonic stage, just drop;
	 * else if don't need to let data drain, then can just drop anyways,
	 * else have to begin TCP shutdown process: mark socket disconnecting,
	 * drain unread data, state switch to reflect user close, and
	 * send segment (e.g. FIN) to peer.  Socket will be really disconnected
	 * when peer sends FIN and acks ours.
	 *
	 * SHOULD IMPLEMENT LATER PRU_CONNECT VIA REALLOC TCPCB.
	 */
	case PRU_DISCONNECT:
		tp = tcp_disconnect(tp);
		break;

	/*
	 * Accept a connection.	 Essentially all the work is
	 * done at higher levels; just return the address
	 * of the peer, storing through addr.
	 */
	case PRU_ACCEPT:
		in_setpeeraddr(inp, nam);
		break;

	/*
	 * Mark the connection as being incapable of further output.
	 */
	case PRU_SHUTDOWN:
		socantsendmore(so);
		tp = tcp_usrclosed(tp);
		if (tp)
			error = tcp_output(tp);
		break;

	/*
	 * After a receive, possibly send window update to peer.
	 */
	case PRU_RCVD:
		(void) tcp_output(tp);
		break;

	/*
	 * Do a send by putting data in output queue and updating urgent
	 * marker if URG set.  Possibly send more data.
	 */
	case PRU_SEND_EOF:
	case PRU_SEND:
		sbappend(&so->so_snd, m);
		if (nam && tp->t_state < TCPS_SYN_SENT) {
			/*
			 * Do implied connect if not yet connected,
			 * initialize window to default value, and
			 * initialize maxseg/maxopd using peer's cached
			 * MSS.
			 */
			error = tcp_connect(tp, nam);
			if (error)
				break;
			tp->snd_wnd = TTCP_CLIENT_SND_WND;
			tcp_mss(tp, -1);
		}

		if (req == PRU_SEND_EOF) {
			/*
			 * Close the send side of the connection after
			 * the data is sent.
			 */
			socantsendmore(so);
			tp = tcp_usrclosed(tp);
		}
		if (tp != NULL)
			error = tcp_output(tp);
		break;

	/*
	 * Abort the TCP.
	 */
	case PRU_ABORT:
		tp = tcp_drop(tp, ECONNABORTED);
		break;

	case PRU_SENSE:
		((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat;
		return (0);

	case PRU_RCVOOB:
		if ((so->so_oobmark == 0 &&
		    (so->so_state & SS_RCVATMARK) == 0) ||
		    so->so_options & SO_OOBINLINE ||
		    tp->t_oobflags & TCPOOB_HADDATA) {
			error = EINVAL;
			break;
		}
		if ((tp->t_oobflags & TCPOOB_HAVEDATA) == 0) {
			error = EWOULDBLOCK;
			break;
		}
		m->m_len = 1;
		*mtod(m, caddr_t) = tp->t_iobc;
		if (((int)nam & MSG_PEEK) == 0)
			tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
		break;

	case PRU_SENDOOB:
		if (sbspace(&so->so_snd) < -512) {
			m_freem(m);
			error = ENOBUFS;
			break;
		}
		/*
		 * According to RFC961 (Assigned Protocols),
		 * the urgent pointer points to the last octet
		 * of urgent data.  We continue, however,
		 * to consider it to indicate the first octet
		 * of data past the urgent section.
		 * Otherwise, snd_up should be one lower.
		 */
		sbappend(&so->so_snd, m);
		tp->snd_up = tp->snd_una + so->so_snd.sb_cc;
		tp->t_force = 1;
		error = tcp_output(tp);
		tp->t_force = 0;
		break;

	case PRU_SOCKADDR:
		in_setsockaddr(inp, nam);
		break;

	case PRU_PEERADDR:
		in_setpeeraddr(inp, nam);
		break;

	/*
	 * TCP slow timer went off; going through this
	 * routine for tracing's sake.
	 */
	case PRU_SLOWTIMO:
		tp = tcp_timers(tp, (int)nam);
#ifdef TCPDEBUG
		req |= (int)nam << 8;		/* for debug's sake */
#endif
		/* This hack seems to be needed by tcp_timer.c */
		error = (int) tp;
		break;

	default:
		panic("tcp_usrreq");
		return (EFAULT);

	}
#ifdef TCPDEBUG
	if (tp && (so->so_options & SO_DEBUG))
		tcp_trace(TA_USER, ostate, tp, (struct tcpiphdr *)0, req);
#endif
	return (error);
}

/*
 * Common subroutine to open a TCP connection to remote host specified
 * by struct sockaddr_in in mbuf *nam.  Call in_pcbbind to assign a local
 * port number if needed.  Call in_pcbladdr to do the routing and to choose
 * a local host address (interface).  If there is an existing incarnation
 * of the same connection in TIME-WAIT state and if the remote host was
 * sending CC options and if the connection duration was < MSL, then
 * truncate the previous TIME-WAIT state and proceed.
 * Initialize connection parameters and enter SYN-SENT state.
 */
static int
tcp_connect(tp, nam)
	register struct tcpcb *tp;
	struct mbuf *nam;
{
	struct inpcb *inp = tp->t_inpcb, *oinp;
	struct socket *so = inp->inp_socket;
	struct tcpcb *otp;
	struct sockaddr_in *sin = mtod(nam, struct sockaddr_in *);
	struct sockaddr_in *ifaddr;
	int error;

	if (inp->inp_lport == 0) {
		error = in_pcbbind(inp, NULL);
		if (error)
			return error;
	}

	/*
	 * Cannot simply call in_pcbconnect, because there might be an
	 * earlier incarnation of this same connection still in
	 * TIME_WAIT state, creating an ADDRINUSE error.
	 */
	error = in_pcbladdr(inp, nam, &ifaddr);
	if (error)
		return error;
	oinp = in_pcblookup(inp->inp_pcbinfo->listhead,
	    sin->sin_addr, sin->sin_port,
	    inp->inp_laddr.s_addr != INADDR_ANY ? inp->inp_laddr
						: ifaddr->sin_addr,
	    inp->inp_lport,  0);
	if (oinp)
		return EADDRINUSE;
	if (inp->inp_laddr.s_addr == INADDR_ANY)
		inp->inp_laddr = ifaddr->sin_addr;
	inp->inp_faddr = sin->sin_addr;
	inp->inp_fport = sin->sin_port;
	in_pcbrehash(inp);

	tp->t_template = tcp_template(tp);
	if (tp->t_template == 0) {
		in_pcbdisconnect(inp);
		return ENOBUFS;
	}

	/* Compute window scaling to request.  */
	while (tp->request_r_scale < TCP_MAX_WINSHIFT &&
	    (TCP_MAXWIN << tp->request_r_scale) < so->so_rcv.sb_hiwat)
		tp->request_r_scale++;

	soisconnecting(so);
	tcpstat.tcps_connattempt++;
	tp->t_state = TCPS_SYN_SENT;
	tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
#ifdef __riscos
	tp->iss = tcp_newisn();
#else
	tp->iss = tcp_iss; tcp_iss += TCP_ISSINCR/2;
#endif
	tcp_sendseqinit(tp);

	return 0;
}

int
tcp_ctloutput(op, so, level, optname, mp)
	int op;
	struct socket *so;
	int level, optname;
	struct mbuf **mp;
{
	int error = 0;
	struct inpcb *inp;
	register struct tcpcb *tp;
	register struct mbuf *m;
	register int i;

	inp = sotoinpcb(so);
	if (inp == NULL) {
		if (op == PRCO_SETOPT && *mp)
			(void) m_free(*mp);
		return (ECONNRESET);
	}
	if (level != IPPROTO_TCP)
		return (ip_ctloutput(op, so, level, optname, mp));

	tp = intotcpcb(inp);

	switch (op) {

	case PRCO_SETOPT:
		m = *mp;
		switch (optname) {

		case TCP_NODELAY:
			if (m == NULL || m->m_len < sizeof (int))
				error = EINVAL;
			else if (*mtod(m, int *))
				tp->t_flags |= TF_NODELAY;
			else
				tp->t_flags &= ~TF_NODELAY;
			break;

		case TCP_MAXSEG:
			if (m && (i = *mtod(m, int *)) > 0 && i <= tp->t_maxseg)
				tp->t_maxseg = i;
			else
				error = EINVAL;
			break;

		case TCP_NOOPT:
			if (m == NULL || m->m_len < sizeof (int))
				error = EINVAL;
			else if (*mtod(m, int *))
				tp->t_flags |= TF_NOOPT;
			else
				tp->t_flags &= ~TF_NOOPT;
			break;

		case TCP_NOPUSH:
			if (m == NULL || m->m_len < sizeof (int))
				error = EINVAL;
			else if (*mtod(m, int *))
				tp->t_flags |= TF_NOPUSH;
			else
				tp->t_flags &= ~TF_NOPUSH;
			break;

		default:
			error = ENOPROTOOPT;
			break;
		}
		if (m)
		        (void) m_free(m);
		break;

	case PRCO_GETOPT:
		*mp = m = m_get(M_WAIT, MT_SOOPTS);
		if (m == NULL)
			return (ENOBUFS);
		m->m_len = sizeof(int);

		switch (optname) {
		case TCP_NODELAY:
			*mtod(m, int *) = tp->t_flags & TF_NODELAY;
			break;
		case TCP_MAXSEG:
			*mtod(m, int *) = tp->t_maxseg;
			break;
		case TCP_NOOPT:
			*mtod(m, int *) = tp->t_flags & TF_NOOPT;
			break;
		case TCP_NOPUSH:
			*mtod(m, int *) = tp->t_flags & TF_NOPUSH;
			break;
		default:
			error = ENOPROTOOPT;
			break;
		}
		break;
	}
	return (error);
}

/*
 * tcp_sendspace and tcp_recvspace are the default send and receive window
 * sizes, respectively.  These are obsolescent (this information should
 * be set by the route).
 */
u_long	tcp_sendspace = 1024*16;
SYSCTL_INT(_net_inet_tcp, TCPCTL_SENDSPACE, sendspace, CTLFLAG_RW,
    &tcp_sendspace , 0, "Maximum outgoing TCP datagram size");
u_long	tcp_recvspace = 1024*16;
SYSCTL_INT(_net_inet_tcp, TCPCTL_RECVSPACE, recvspace, CTLFLAG_RW,
    &tcp_recvspace , 0, "Maximum incoming TCP datagram size");

/*
 * Attach TCP protocol to socket, allocating
 * internet protocol control block, tcp control block,
 * bufer space, and entering LISTEN state if to accept connections.
 */
static int
tcp_attach(so)
	struct socket *so;
{
	register struct tcpcb *tp;
	struct inpcb *inp;
	int error;

	if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) {
		error = soreserve(so, tcp_sendspace, tcp_recvspace);
		if (error)
			return (error);
	}
	error = in_pcballoc(so, &tcbinfo);
	if (error)
		return (error);
	inp = sotoinpcb(so);
	tp = tcp_newtcpcb(inp);
	if (tp == 0) {
		int nofd = so->so_state & SS_NOFDREF;	/* XXX */

		so->so_state &= ~SS_NOFDREF;	/* don't free the socket yet */
		in_pcbdetach(inp);
		so->so_state |= nofd;
		return (ENOBUFS);
	}
	tp->t_state = TCPS_CLOSED;
	return (0);
}

/*
 * Initiate (or continue) disconnect.
 * If embryonic state, just send reset (once).
 * If in ``let data drain'' option and linger null, just drop.
 * Otherwise (hard), mark socket disconnecting and drop
 * current input data; switch states based on user close, and
 * send segment to peer (with FIN).
 */
static struct tcpcb *
tcp_disconnect(tp)
	register struct tcpcb *tp;
{
	struct socket *so = tp->t_inpcb->inp_socket;

	if (tp->t_state < TCPS_ESTABLISHED)
		tp = tcp_close(tp);
	else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
		tp = tcp_drop(tp, 0);
	else {
		soisdisconnecting(so);
		sbflush(&so->so_rcv);
		tp = tcp_usrclosed(tp);
		if (tp)
			(void) tcp_output(tp);
	}
	return (tp);
}

/*
 * User issued close, and wish to trail through shutdown states:
 * if never received SYN, just forget it.  If got a SYN from peer,
 * but haven't sent FIN, then go to FIN_WAIT_1 state to send peer a FIN.
 * If already got a FIN from peer, then almost done; go to LAST_ACK
 * state.  In all other cases, have already sent FIN to peer (e.g.
 * after PRU_SHUTDOWN), and just have to play tedious game waiting
 * for peer to send FIN or not respond to keep-alives, etc.
 * We can let the user exit from the close as soon as the FIN is acked.
 */
static struct tcpcb *
tcp_usrclosed(tp)
	register struct tcpcb *tp;
{

	switch (tp->t_state) {

	case TCPS_CLOSED:
	case TCPS_LISTEN:
		tp->t_state = TCPS_CLOSED;
		tp = tcp_close(tp);
		break;

	case TCPS_SYN_SENT:
	case TCPS_SYN_RECEIVED:
		tp->t_flags |= TF_NEEDFIN;
		break;

	case TCPS_ESTABLISHED:
		tp->t_state = TCPS_FIN_WAIT_1;
		break;

	case TCPS_CLOSE_WAIT:
		tp->t_state = TCPS_LAST_ACK;
		break;
	}
	if (tp && tp->t_state >= TCPS_FIN_WAIT_2) {
		soisdisconnected(tp->t_inpcb->inp_socket);
		/* To prevent the connection hanging in FIN_WAIT_2 forever. */
		if (tp->t_state == TCPS_FIN_WAIT_2)
			tp->t_timer[TCPT_2MSL] = tcp_maxidle;
	}
	return (tp);
}
@


4.5
log
@Added new FreeBSD sysctl handling using linker magic.
A few new sysctls added as a result.
SO_TIMESTAMP now gives real time, not Internet's internal time.
DHCP/BOOTP parsing picks up URL option and pops it into Inet$URL.
Requires TCPIPLibs 5.25 and link 5.12.

Version 5.31. Tagged as 'Internet-5_31'
@
text
@a416 2
	struct rmxp_tao *taop;
	struct rmxp_tao tao_noncached;
d437 2
a438 9
	if (oinp) {
		if (oinp != inp && (otp = intotcpcb(oinp)) != NULL &&
		otp->t_state == TCPS_TIME_WAIT &&
		    otp->t_duration < TCPTV_MSL &&
		    (otp->t_flags & TF_RCVD_CC))
			otp = tcp_close(otp);
		else
			return EADDRINUSE;
	}
a466 18
	/*
	 * Generate a CC value for this connection and
	 * check whether CC or CCnew should be used.
	 */
	if ((taop = tcp_gettaocache(tp->t_inpcb)) == NULL) {
		taop = &tao_noncached;
		bzero(taop, sizeof(*taop));
	}

	tp->cc_send = CC_INC(tcp_ccgen);
	if (taop->tao_ccsent != 0 &&
	    CC_GEQ(tp->cc_send, taop->tao_ccsent)) {
		taop->tao_ccsent = tp->cc_send;
	} else {
		taop->tao_ccsent = 0;
		tp->t_flags |= TF_SENDCCNEW;
	}

@


4.4
log
@* Fixed bug introduced by tentative ARP probe - a typo made arp_ifinit() fail to
  set up the interface route structure properly.
* Divide-by-zero when an IGMP membership query with a time of 1 received fixed
  (from FreeBSD).
* IGMP messages now sent with TOS set to "maximum reliability".
* tcp_output.c updated from FreeBSD - in particular path_mtu_discovery sysctl
  now available.
* A few other FreeBSD structural changes and bug fixes integrated.
* Put UDP checksum in BOOTP packets.
* Null pointer dereferencing fixed in whoami.c. Address setting now done with
  SIOCDIFADDR and SIOCAIFADDR. Don't set the netmask if asked not to.
* Output BOOTP packets with the source address in ciaddr
Note that various structural changes mean that the support tools (in particular
InetStat) will need to be recompiled.
Requires TCPIPLibs 5.20

Version 5.27. Tagged as 'Internet-5_27'
@
text
@d35 2
d40 1
a47 6
#ifdef __riscos
#include <sys/queue.h>
#else
#include <vm/vm.h>
#endif
#include <sys/sysctl.h>
d603 2
d606 2
a714 52
}

/*
 * Sysctl for tcp variables.
 */
int
tcp_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case TCPCTL_DO_RFC1323:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_do_rfc1323));
	case TCPCTL_DO_RFC1644:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_do_rfc1644));
	case TCPCTL_MSSDFLT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_mssdflt));
	case TCPCTL_STATS:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &tcpstat,
					sizeof tcpstat));
	case TCPCTL_RTTDFLT:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &tcp_rttdflt));
	case TCPCTL_KEEPIDLE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &tcp_keepidle));
	case TCPCTL_KEEPINTVL:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &tcp_keepintvl));
	case TCPCTL_SENDSPACE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   (int *)&tcp_sendspace)); /* XXX */
	case TCPCTL_RECVSPACE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   (int *)&tcp_recvspace)); /* XXX */
	case TCPCTL_PATH_MTU_DISC:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &path_mtu_discovery));
	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
@


4.3
log
@Missed this in Internet 5.22 checkin.  Retagged Internet-5_22
@
text
@d77 1
a77 1

d759 3
@


4.2
log
@Version Spinner_B7 taken
@
text
@d472 3
d476 1
@


4.1
log
@Initial revision
@
text
@d1 3
a3 1
/* -*-C-*-
d5 15
a19 2
 * $Header: /ax/networking:Internet/netinet/tcp_usrreq.c:networking  1.1  $
 * $Source: /ax/networking:Internet/netinet/tcp_usrreq.c: $
d21 11
a31 1
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
a32 4
 * $Log:	tcp_usrreq.c,v $
 * Revision 1.1  94/12/02  11:24:07  kwelton
 * Initial revision
 * 
d34 38
a71 41
/*
 * Copyright (c) 1983, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 */
#include "sys/param.h"
#include "sys/systm.h"
#include "sys/stat.h"
#include "sys/mbuf.h"
#include "sys/socket.h"
#include "sys/socketvar.h"
#include "sys/protosw.h"
#include "sys/errno.h"

#include "net/if.h"
#include "net/route.h"

#include "netinet/in.h"
#include "netinet/in_pcb.h"
#include "netinet/in_systm.h"
#include "netinet/ip.h"
#include "netinet/ip_var.h"
#include "netinet/tcp.h"
#include "netinet/tcp_fsm.h"
#include "netinet/tcp_seq.h"
#include "netinet/tcp_timer.h"
#include "netinet/tcp_var.h"
#include "netinet/tcpip.h"
#include "netinet/tcp_debug.h"
d77 7
a83 1
struct	tcpcb *tcp_newtcpcb();
d91 2
a92 1
tcp_usrreq(so, req, m, nam, rights)
d95 1
a95 1
	struct mbuf *m, *nam, *rights;
d98 2
a99 1
	register struct tcpcb *tp;
d101 1
d103 1
a104 1
#if BSD>=43
d106 6
a111 7
		return (in_control(so, (int)m, (caddr_t)nam,
			(struct ifnet *)rights));
#else
	if (req == PRU_CONTROL)
		return(EOPNOTSUPP);
#endif
	if (rights && rights->m_len)
d113 1
d122 12
d142 1
d146 4
d165 1
a165 1
			so->so_linger = TCP_LINGERTIME;
d187 10
d207 1
a207 1
			error = in_pcbbind(inp, (struct mbuf *)0);
d220 8
a227 4
		if (inp->inp_lport == 0) {
			error = in_pcbbind(inp, (struct mbuf *)0);
			if (error)
				break;
d229 2
a230 7
		error = in_pcbconnect(inp, nam);
		if (error)
			break;
		tp->t_template = tcp_template(tp);
		if (tp->t_template == 0) {
			in_pcbdisconnect(inp);
			error = ENOBUFS;
a231 7
		}
		soisconnecting(so);
		tcpstat.tcps_connattempt++;
		tp->t_state = TCPS_SYN_SENT;
		tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
		tp->iss = tcp_iss; tcp_iss += TCP_ISSINCR/2;
		tcp_sendseqinit(tp);
d262 2
a263 7
	case PRU_ACCEPT: {
		struct sockaddr_in *sin = mtod(nam, struct sockaddr_in *);

		nam->m_len = sizeof (struct sockaddr_in);
		sin->sin_family = AF_INET;
		sin->sin_port = inp->inp_fport;
		sin->sin_addr = inp->inp_faddr;
a264 1
		}
d287 1
d290 24
a313 1
		error = tcp_output(tp);
a329 1
#ifdef SO_OOBINLINE
a330 1
#endif
a346 1
#ifdef OldCode
a347 3
#else
			FREEM(m);
#endif
d380 1
d382 3
d392 1
d395 1
d399 98
a496 1
#if BSD>=43
d504 2
a505 2
	struct inpcb *inp = sotoinpcb(so);
	register struct tcpcb *tp = intotcpcb(inp);
d507 1
d509 6
d518 2
d535 25
a559 1
		case TCP_MAXSEG:	/* not yet */
d561 1
a561 1
			error = EINVAL;
d565 1
a565 7
		{
#ifdef OldCode
		    (void) m_free(m);
#else
		    FREE(m);
#endif
		}
a568 1
#ifdef OldCode
d570 1
a570 1
		if (m == 0)
a571 12
#else
		if( (*mp = m = ALLOC_S(MINCONTIG, NULL)) == NULL )
		{
#ifdef DEBUG
		    if( DODEBUG(DBGMMAN) )
			Printf("tcp_ctloutput: ALLOC_S failed\n");
#endif
		    return(ENOBUFS);
		}

		m->m_type = MT_SOOPTS;
#endif
d581 6
d588 1
a588 1
			error = EINVAL;
a594 1
#endif
d596 8
a603 2
u_long	tcp_sendspace = 1024*12;
u_long	tcp_recvspace = 1024*12;
d609 1
d622 1
a622 1
	error = in_pcballoc(so, &tcb);
d647 1
a647 1
struct tcpcb *
d677 1
a677 1
struct tcpcb *
a685 1
	case TCPS_SYN_SENT:
d690 1
d692 3
d703 1
a703 1
	if (tp && tp->t_state >= TCPS_FIN_WAIT_2)
d705 4
d712 48
a759 1
/* EOF tcp_usrreq.c */
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d1 12
d14 2
a15 18
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d17 11
a27 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d30 24
a53 38

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/protosw.h>
#include <sys/errno.h>
#include <sys/stat.h>
#ifdef __riscos
#include <sys/queue.h>
#else
#include <vm/vm.h>
#endif
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#include <netinet/tcp_fsm.h>
#include <netinet/tcp_seq.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/tcpip.h>
#ifdef TCPDEBUG
#include <netinet/tcp_debug.h>
#endif

#include "module.h"
d59 1
a59 7

static int	tcp_attach(struct socket *);
static int	tcp_connect(struct tcpcb *, struct mbuf *);
static struct tcpcb *
		tcp_disconnect(struct tcpcb *);
static struct tcpcb *
		tcp_usrclosed(struct tcpcb *);
d67 1
a67 2
int
tcp_usrreq(so, req, m, nam, control)
d70 1
a70 1
	struct mbuf *m, *nam, *control;
d73 1
a73 2
	register struct tcpcb *tp = 0;
	struct sockaddr_in *sinp;
a74 1
#ifdef TCPDEBUG
a75 1
#endif
d77 5
d83 3
a85 6
		return (in_control(so, (u_long)m, (caddr_t)nam,
			(struct ifnet *)control));
	if (control && control->m_len) {
		m_freem(control);
		if (m)
			m_freem(m);
a86 1
	}
a94 12
#if 0
		/*
		 * The following corrects an mbuf leak under rare
		 * circumstances, but has not been fully tested.
		 */
		if (m && req != PRU_SENSE)
			m_freem(m);
#else
		/* safer version of fix for mbuf leak */
		if (m && (req == PRU_SEND || req == PRU_SENDOOB))
			m_freem(m);
#endif
a102 1
#ifdef TCPDEBUG
a105 4
#else /* TCPDEBUG */
	}
#endif /* TCPDEBUG */

d121 1
a121 1
			so->so_linger = TCP_LINGERTIME * hz;
a142 10
		/*
		 * Must check for multicast addresses and disallow binding
		 * to them.
		 */
		sinp = mtod(nam, struct sockaddr_in *);
		if (sinp->sin_family == AF_INET &&
		    IN_MULTICAST(ntohl(sinp->sin_addr.s_addr))) {
			error = EAFNOSUPPORT;
			break;
		}
d153 1
a153 1
			error = in_pcbbind(inp, NULL);
d166 12
a177 7
		/*
		 * Must disallow TCP ``connections'' to multicast addresses.
		 */
		sinp = mtod(nam, struct sockaddr_in *);
		if (sinp->sin_family == AF_INET
		    && IN_MULTICAST(ntohl(sinp->sin_addr.s_addr))) {
			error = EAFNOSUPPORT;
d180 6
a185 3

		if ((error = tcp_connect(tp, nam)) != 0)
			break;
d216 7
a222 2
	case PRU_ACCEPT:
		in_setpeeraddr(inp, nam);
d224 1
a246 1
	case PRU_SEND_EOF:
d249 1
a249 24
		if (nam && tp->t_state < TCPS_SYN_SENT) {
			/*
			 * Do implied connect if not yet connected,
			 * initialize window to default value, and
			 * initialize maxseg/maxopd using peer's cached
			 * MSS.
			 */
			error = tcp_connect(tp, nam);
			if (error)
				break;
			tp->snd_wnd = TTCP_CLIENT_SND_WND;
			tcp_mss(tp, -1);
		}

		if (req == PRU_SEND_EOF) {
			/*
			 * Close the send side of the connection after
			 * the data is sent.
			 */
			socantsendmore(so);
			tp = tcp_usrclosed(tp);
		}
		if (tp != NULL)
			error = tcp_output(tp);
d266 1
d268 1
d285 1
d287 3
a321 1
#ifdef TCPDEBUG
a322 3
#endif
		/* This hack seems to be needed by tcp_timer.c */
		error = (int) tp;
a329 1
#ifdef TCPDEBUG
a331 1
#endif
d335 1
a335 98
/*
 * Common subroutine to open a TCP connection to remote host specified
 * by struct sockaddr_in in mbuf *nam.  Call in_pcbbind to assign a local
 * port number if needed.  Call in_pcbladdr to do the routing and to choose
 * a local host address (interface).  If there is an existing incarnation
 * of the same connection in TIME-WAIT state and if the remote host was
 * sending CC options and if the connection duration was < MSL, then
 * truncate the previous TIME-WAIT state and proceed.
 * Initialize connection parameters and enter SYN-SENT state.
 */
static int
tcp_connect(tp, nam)
	register struct tcpcb *tp;
	struct mbuf *nam;
{
	struct inpcb *inp = tp->t_inpcb, *oinp;
	struct socket *so = inp->inp_socket;
	struct tcpcb *otp;
	struct sockaddr_in *sin = mtod(nam, struct sockaddr_in *);
	struct sockaddr_in *ifaddr;
	int error;
	struct rmxp_tao *taop;
	struct rmxp_tao tao_noncached;

	if (inp->inp_lport == 0) {
		error = in_pcbbind(inp, NULL);
		if (error)
			return error;
	}

	/*
	 * Cannot simply call in_pcbconnect, because there might be an
	 * earlier incarnation of this same connection still in
	 * TIME_WAIT state, creating an ADDRINUSE error.
	 */
	error = in_pcbladdr(inp, nam, &ifaddr);
	if (error)
		return error;
	oinp = in_pcblookup(inp->inp_pcbinfo->listhead,
	    sin->sin_addr, sin->sin_port,
	    inp->inp_laddr.s_addr != INADDR_ANY ? inp->inp_laddr
						: ifaddr->sin_addr,
	    inp->inp_lport,  0);
	if (oinp) {
		if (oinp != inp && (otp = intotcpcb(oinp)) != NULL &&
		otp->t_state == TCPS_TIME_WAIT &&
		    otp->t_duration < TCPTV_MSL &&
		    (otp->t_flags & TF_RCVD_CC))
			otp = tcp_close(otp);
		else
			return EADDRINUSE;
	}
	if (inp->inp_laddr.s_addr == INADDR_ANY)
		inp->inp_laddr = ifaddr->sin_addr;
	inp->inp_faddr = sin->sin_addr;
	inp->inp_fport = sin->sin_port;
	in_pcbrehash(inp);

	tp->t_template = tcp_template(tp);
	if (tp->t_template == 0) {
		in_pcbdisconnect(inp);
		return ENOBUFS;
	}

	/* Compute window scaling to request.  */
	while (tp->request_r_scale < TCP_MAX_WINSHIFT &&
	    (TCP_MAXWIN << tp->request_r_scale) < so->so_rcv.sb_hiwat)
		tp->request_r_scale++;

	soisconnecting(so);
	tcpstat.tcps_connattempt++;
	tp->t_state = TCPS_SYN_SENT;
	tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
	tp->iss = tcp_iss; tcp_iss += TCP_ISSINCR/2;
	tcp_sendseqinit(tp);

	/*
	 * Generate a CC value for this connection and
	 * check whether CC or CCnew should be used.
	 */
	if ((taop = tcp_gettaocache(tp->t_inpcb)) == NULL) {
		taop = &tao_noncached;
		bzero(taop, sizeof(*taop));
	}

	tp->cc_send = CC_INC(tcp_ccgen);
	if (taop->tao_ccsent != 0 &&
	    CC_GEQ(tp->cc_send, taop->tao_ccsent)) {
		taop->tao_ccsent = tp->cc_send;
	} else {
		taop->tao_ccsent = 0;
		tp->t_flags |= TF_SENDCCNEW;
	}

	return 0;
}

int
d343 2
a344 2
	struct inpcb *inp;
	register struct tcpcb *tp;
a345 1
	register int i;
a346 6
	inp = sotoinpcb(so);
	if (inp == NULL) {
		if (op == PRCO_SETOPT && *mp)
			(void) m_free(*mp);
		return (ECONNRESET);
	}
a349 2
	tp = intotcpcb(inp);

d365 1
a365 25
		case TCP_MAXSEG:
			if (m && (i = *mtod(m, int *)) > 0 && i <= tp->t_maxseg)
				tp->t_maxseg = i;
			else
				error = EINVAL;
			break;

		case TCP_NOOPT:
			if (m == NULL || m->m_len < sizeof (int))
				error = EINVAL;
			else if (*mtod(m, int *))
				tp->t_flags |= TF_NOOPT;
			else
				tp->t_flags &= ~TF_NOOPT;
			break;

		case TCP_NOPUSH:
			if (m == NULL || m->m_len < sizeof (int))
				error = EINVAL;
			else if (*mtod(m, int *))
				tp->t_flags |= TF_NOPUSH;
			else
				tp->t_flags &= ~TF_NOPUSH;
			break;

d367 1
a367 1
			error = ENOPROTOOPT;
d371 7
a377 1
		        (void) m_free(m);
d381 1
d383 1
a383 1
		if (m == NULL)
d385 12
a405 6
		case TCP_NOOPT:
			*mtod(m, int *) = tp->t_flags & TF_NOOPT;
			break;
		case TCP_NOPUSH:
			*mtod(m, int *) = tp->t_flags & TF_NOPUSH;
			break;
d407 1
a407 1
			error = ENOPROTOOPT;
d414 1
d416 2
a417 8
/*
 * tcp_sendspace and tcp_recvspace are the default send and receive window
 * sizes, respectively.  These are obsolescent (this information should
 * be set by the route).
 */
u_long	tcp_sendspace = 1024*16;
u_long	tcp_recvspace = 1024*16;

a422 1
static int
d435 1
a435 1
	error = in_pcballoc(so, &tcbinfo);
d460 1
a460 1
static struct tcpcb *
d490 1
a490 1
static struct tcpcb *
d499 1
a503 1
	case TCPS_SYN_SENT:
a504 3
		tp->t_flags |= TF_NEEDFIN;
		break;

d513 1
a513 1
	if (tp && tp->t_state >= TCPS_FIN_WAIT_2) {
a514 4
		/* To prevent the connection hanging in FIN_WAIT_2 forever. */
		if (tp->t_state == TCPS_FIN_WAIT_2)
			tp->t_timer[TCPT_2MSL] = tcp_maxidle;
	}
d518 1
a518 48
/*
 * Sysctl for tcp variables.
 */
int
tcp_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case TCPCTL_DO_RFC1323:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_do_rfc1323));
	case TCPCTL_DO_RFC1644:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_do_rfc1644));
	case TCPCTL_MSSDFLT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_mssdflt));
	case TCPCTL_STATS:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &tcpstat,
					sizeof tcpstat));
	case TCPCTL_RTTDFLT:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &tcp_rttdflt));
	case TCPCTL_KEEPIDLE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &tcp_keepidle));
	case TCPCTL_KEEPINTVL:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &tcp_keepintvl));
	case TCPCTL_SENDSPACE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   (int *)&tcp_sendspace)); /* XXX */
	case TCPCTL_RECVSPACE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   (int *)&tcp_recvspace)); /* XXX */
	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
}
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@RCS log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d1 12
d14 2
a15 18
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d17 11
a27 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a28 2
 *	From: @@(#)tcp_usrreq.c	8.2 (Berkeley) 1/3/94
 *	$Id: tcp_usrreq.c,v 1.15.2.3 1996/01/31 11:02:03 davidg Exp $
d30 24
a53 38

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/protosw.h>
#include <sys/errno.h>
#include <sys/stat.h>
#ifdef __riscos
#include <sys/queue.h>
#else
#include <vm/vm.h>
#endif
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#include <netinet/tcp_fsm.h>
#include <netinet/tcp_seq.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/tcpip.h>
#ifdef TCPDEBUG
#include <netinet/tcp_debug.h>
#endif

#include "module.h"
d59 1
a59 7

static int	tcp_attach(struct socket *);
static int	tcp_connect(struct tcpcb *, struct mbuf *);
static struct tcpcb *
		tcp_disconnect(struct tcpcb *);
static struct tcpcb *
		tcp_usrclosed(struct tcpcb *);
d67 1
a67 2
int
tcp_usrreq(so, req, m, nam, control)
d70 1
a70 1
	struct mbuf *m, *nam, *control;
d73 1
a73 2
	register struct tcpcb *tp = 0;
	struct sockaddr_in *sinp;
a74 1
#ifdef TCPDEBUG
a75 1
#endif
d77 5
d83 3
a85 6
		return (in_control(so, (u_long)m, (caddr_t)nam,
			(struct ifnet *)control));
	if (control && control->m_len) {
		m_freem(control);
		if (m)
			m_freem(m);
a86 1
	}
a94 12
#if 0
		/*
		 * The following corrects an mbuf leak under rare
		 * circumstances, but has not been fully tested.
		 */
		if (m && req != PRU_SENSE)
			m_freem(m);
#else
		/* safer version of fix for mbuf leak */
		if (m && (req == PRU_SEND || req == PRU_SENDOOB))
			m_freem(m);
#endif
a102 1
#ifdef TCPDEBUG
a105 4
#else /* TCPDEBUG */
	}
#endif /* TCPDEBUG */

d121 1
a121 1
			so->so_linger = TCP_LINGERTIME * hz;
a142 10
		/*
		 * Must check for multicast addresses and disallow binding
		 * to them.
		 */
		sinp = mtod(nam, struct sockaddr_in *);
		if (sinp->sin_family == AF_INET &&
		    IN_MULTICAST(ntohl(sinp->sin_addr.s_addr))) {
			error = EAFNOSUPPORT;
			break;
		}
d153 1
a153 1
			error = in_pcbbind(inp, NULL);
d166 12
a177 7
		/*
		 * Must disallow TCP ``connections'' to multicast addresses.
		 */
		sinp = mtod(nam, struct sockaddr_in *);
		if (sinp->sin_family == AF_INET
		    && IN_MULTICAST(ntohl(sinp->sin_addr.s_addr))) {
			error = EAFNOSUPPORT;
d180 6
a185 3

		if ((error = tcp_connect(tp, nam)) != 0)
			break;
d216 7
a222 2
	case PRU_ACCEPT:
		in_setpeeraddr(inp, nam);
d224 1
a246 1
	case PRU_SEND_EOF:
d249 1
a249 24
		if (nam && tp->t_state < TCPS_SYN_SENT) {
			/*
			 * Do implied connect if not yet connected,
			 * initialize window to default value, and
			 * initialize maxseg/maxopd using peer's cached
			 * MSS.
			 */
			error = tcp_connect(tp, nam);
			if (error)
				break;
			tp->snd_wnd = TTCP_CLIENT_SND_WND;
			tcp_mss(tp, -1);
		}

		if (req == PRU_SEND_EOF) {
			/*
			 * Close the send side of the connection after
			 * the data is sent.
			 */
			socantsendmore(so);
			tp = tcp_usrclosed(tp);
		}
		if (tp != NULL)
			error = tcp_output(tp);
d266 1
d268 1
d285 1
d287 3
a321 1
#ifdef TCPDEBUG
a322 3
#endif
		/* This hack seems to be needed by tcp_timer.c */
		error = (int) tp;
a329 1
#ifdef TCPDEBUG
a331 1
#endif
d335 1
a335 98
/*
 * Common subroutine to open a TCP connection to remote host specified
 * by struct sockaddr_in in mbuf *nam.  Call in_pcbbind to assign a local
 * port number if needed.  Call in_pcbladdr to do the routing and to choose
 * a local host address (interface).  If there is an existing incarnation
 * of the same connection in TIME-WAIT state and if the remote host was
 * sending CC options and if the connection duration was < MSL, then
 * truncate the previous TIME-WAIT state and proceed.
 * Initialize connection parameters and enter SYN-SENT state.
 */
static int
tcp_connect(tp, nam)
	register struct tcpcb *tp;
	struct mbuf *nam;
{
	struct inpcb *inp = tp->t_inpcb, *oinp;
	struct socket *so = inp->inp_socket;
	struct tcpcb *otp;
	struct sockaddr_in *sin = mtod(nam, struct sockaddr_in *);
	struct sockaddr_in *ifaddr;
	int error;
	struct rmxp_tao *taop;
	struct rmxp_tao tao_noncached;

	if (inp->inp_lport == 0) {
		error = in_pcbbind(inp, NULL);
		if (error)
			return error;
	}

	/*
	 * Cannot simply call in_pcbconnect, because there might be an
	 * earlier incarnation of this same connection still in
	 * TIME_WAIT state, creating an ADDRINUSE error.
	 */
	error = in_pcbladdr(inp, nam, &ifaddr);
	if (error)
		return error;
	oinp = in_pcblookup(inp->inp_pcbinfo->listhead,
	    sin->sin_addr, sin->sin_port,
	    inp->inp_laddr.s_addr != INADDR_ANY ? inp->inp_laddr
						: ifaddr->sin_addr,
	    inp->inp_lport,  0);
	if (oinp) {
		if (oinp != inp && (otp = intotcpcb(oinp)) != NULL &&
		otp->t_state == TCPS_TIME_WAIT &&
		    otp->t_duration < TCPTV_MSL &&
		    (otp->t_flags & TF_RCVD_CC))
			otp = tcp_close(otp);
		else
			return EADDRINUSE;
	}
	if (inp->inp_laddr.s_addr == INADDR_ANY)
		inp->inp_laddr = ifaddr->sin_addr;
	inp->inp_faddr = sin->sin_addr;
	inp->inp_fport = sin->sin_port;
	in_pcbrehash(inp);

	tp->t_template = tcp_template(tp);
	if (tp->t_template == 0) {
		in_pcbdisconnect(inp);
		return ENOBUFS;
	}

	/* Compute window scaling to request.  */
	while (tp->request_r_scale < TCP_MAX_WINSHIFT &&
	    (TCP_MAXWIN << tp->request_r_scale) < so->so_rcv.sb_hiwat)
		tp->request_r_scale++;

	soisconnecting(so);
	tcpstat.tcps_connattempt++;
	tp->t_state = TCPS_SYN_SENT;
	tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
	tp->iss = tcp_iss; tcp_iss += TCP_ISSINCR/2;
	tcp_sendseqinit(tp);

	/*
	 * Generate a CC value for this connection and
	 * check whether CC or CCnew should be used.
	 */
	if ((taop = tcp_gettaocache(tp->t_inpcb)) == NULL) {
		taop = &tao_noncached;
		bzero(taop, sizeof(*taop));
	}

	tp->cc_send = CC_INC(tcp_ccgen);
	if (taop->tao_ccsent != 0 &&
	    CC_GEQ(tp->cc_send, taop->tao_ccsent)) {
		taop->tao_ccsent = tp->cc_send;
	} else {
		taop->tao_ccsent = 0;
		tp->t_flags |= TF_SENDCCNEW;
	}

	return 0;
}

int
d343 2
a344 2
	struct inpcb *inp;
	register struct tcpcb *tp;
a345 1
	register int i;
a346 6
	inp = sotoinpcb(so);
	if (inp == NULL) {
		if (op == PRCO_SETOPT && *mp)
			(void) m_free(*mp);
		return (ECONNRESET);
	}
a349 2
	tp = intotcpcb(inp);

d365 1
a365 25
		case TCP_MAXSEG:
			if (m && (i = *mtod(m, int *)) > 0 && i <= tp->t_maxseg)
				tp->t_maxseg = i;
			else
				error = EINVAL;
			break;

		case TCP_NOOPT:
			if (m == NULL || m->m_len < sizeof (int))
				error = EINVAL;
			else if (*mtod(m, int *))
				tp->t_flags |= TF_NOOPT;
			else
				tp->t_flags &= ~TF_NOOPT;
			break;

		case TCP_NOPUSH:
			if (m == NULL || m->m_len < sizeof (int))
				error = EINVAL;
			else if (*mtod(m, int *))
				tp->t_flags |= TF_NOPUSH;
			else
				tp->t_flags &= ~TF_NOPUSH;
			break;

d367 1
a367 1
			error = ENOPROTOOPT;
d371 7
a377 1
		        (void) m_free(m);
d381 1
d383 1
a383 1
		if (m == NULL)
d385 12
a405 6
		case TCP_NOOPT:
			*mtod(m, int *) = tp->t_flags & TF_NOOPT;
			break;
		case TCP_NOPUSH:
			*mtod(m, int *) = tp->t_flags & TF_NOPUSH;
			break;
d407 1
a407 1
			error = ENOPROTOOPT;
d414 1
d416 2
a417 8
/*
 * tcp_sendspace and tcp_recvspace are the default send and receive window
 * sizes, respectively.  These are obsolescent (this information should
 * be set by the route).
 */
u_long	tcp_sendspace = 1024*16;
u_long	tcp_recvspace = 1024*16;

a422 1
static int
d435 1
a435 1
	error = in_pcballoc(so, &tcbinfo);
d460 1
a460 1
static struct tcpcb *
d490 1
a490 1
static struct tcpcb *
d499 1
a503 1
	case TCPS_SYN_SENT:
a504 3
		tp->t_flags |= TF_NEEDFIN;
		break;

d513 1
a513 1
	if (tp && tp->t_state >= TCPS_FIN_WAIT_2) {
a514 4
		/* To prevent the connection hanging in FIN_WAIT_2 forever. */
		if (tp->t_state == TCPS_FIN_WAIT_2)
			tp->t_timer[TCPT_2MSL] = tcp_maxidle;
	}
d518 1
a518 48
/*
 * Sysctl for tcp variables.
 */
int
tcp_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case TCPCTL_DO_RFC1323:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_do_rfc1323));
	case TCPCTL_DO_RFC1644:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_do_rfc1644));
	case TCPCTL_MSSDFLT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_mssdflt));
	case TCPCTL_STATS:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &tcpstat,
					sizeof tcpstat));
	case TCPCTL_RTTDFLT:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &tcp_rttdflt));
	case TCPCTL_KEEPIDLE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &tcp_keepidle));
	case TCPCTL_KEEPINTVL:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &tcp_keepintvl));
	case TCPCTL_SENDSPACE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   (int *)&tcp_sendspace)); /* XXX */
	case TCPCTL_RECVSPACE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   (int *)&tcp_recvspace)); /* XXX */
	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
}
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@

head	4.7;
access;
symbols
	Internet-5_65:4.7
	Internet-5_64:4.7
	Internet-5_63:4.7
	Internet-5_62:4.7
	Internet-5_61:4.7
	Internet-5_60:4.7
	Internet-5_59:4.7
	Internet-5_58:4.7
	Internet-5_57:4.7
	Internet-5_56:4.7
	Internet-5_55:4.7
	Internet-5_54:4.7
	Internet-5_53:4.7
	Internet-5_52:4.7
	Internet-5_51:4.7
	Internet-5_50:4.7
	RO_5_07:4.7
	Internet-5_49:4.7
	Internet-5_48:4.7
	Internet-5_47:4.7
	Internet-5_46:4.7
	Internet-5_45:4.7
	Internet-5_44:4.7
	Internet-5_43:4.6
	Internet-5_42:4.6
	Internet-5_41:4.6
	Internet-5_40:4.6
	Internet-5_39:4.6
	Internet-5_38:4.6
	Internet-5_37:4.6
	Internet-5_36:4.6
	Internet-5_35:4.6
	Internet-5_34:4.6
	Internet-5_33:4.6
	Internet-5_32:4.6
	Internet-5_31:4.6
	Internet-5_30:4.5
	Internet-5_29:4.5
	Internet-5_27:4.4
	Internet-5_26:4.3
	Internet-5_25:4.3
	Internet-5_24:4.3
	Internet-5_23:4.3
	Internet-5_22:4.3
	Internet-5_21:4.3
	Internet-5_20:4.3
	Internet-5_19:4.3
	Internet-5_18:4.3
	Internet-5_17:4.3
	Internet-5_16:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Internet-5_15:4.3
	Internet-5_14:4.3
	Internet-5_13:4.3
	sforrest_daytona_appflash-0_31:4.3
	Internet-5_12:4.3
	Internet-5_11:4.3
	celkins_Internet-5_10:4.3
	nicke_Internat_25-9-98:4.3
	Internet-5_09:4.3
	blaughto_daytona_appflash-0_30:4.3
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rwarren_Internet-5_08:4.3
	Spinner:4.3
	Internet_5_07:4.3
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.2
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.7
date	2000.07.13.10.39.41;	author ahodgkin;	state Exp;
branches;
next	4.6;

4.6
date	99.07.13.11.13.03;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.07.08.15.25.42;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.06.30.13.15.43;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.07.21.12.50.41;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.59.02;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.10;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.10;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.20.21;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.29.58;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.07.01;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.34;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.06.59;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.46;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.38.45;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.27;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.7
log
@  Econet_InetRxDirect interface extended.
Detail:
  Previously, the SWI didn't care about any return values. The Internet
  module would either free the MBuf passed or send it on to the socket,
  depending on the value of m_len on exit from the SWI. This still works,
  but SWI handlers can now set R1 to zero on exit to claim ownership of
  the MBuf. In this case, the item is neither freed nor passed on to the
  socket, and the new owner must be very careful to make sure that they
  do an appropriate m_free later.
Admin:
  This change was implemented to allow UDPV to point the MPEG system
  directly to the data in the MBuf chains it was passed rather than taking
  a local copy. It has been tested with both new and old UDPV versions and
  both work as expected. Note that any module using the new interface will
  absolutely require it to be present (new UDPV modules built to use the
  interface extension will refuse to start if Internet is too old).

Version 5.44. Tagged as 'Internet-5_44'
@
text
@/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/stat.h>
#ifndef __riscos
#include <vm/vm.h>
#else
#include <sys/dcistructs.h>
#endif
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>

#include "svcdebug.h"
#include "debug.h"
#include "module.h"
#include "whoami.h"

/*
 * UDP protocol implementation.
 * Per RFC 768, August, 1980.
 */
#ifndef __riscos
#ifndef	COMPAT_42
int	udpcksum = 1;
#else
int	udpcksum = 0;		/* XXX */
#endif
#else
int	udpcksum = 0;		/* XXX */
#endif
SYSCTL_INT(_net_inet_udp, UDPCTL_CHECKSUM, checksum, CTLFLAG_RW,
		&udpcksum, 0, "");

struct	inpcbhead udb;		/* from udp_var.h */
struct	inpcbinfo udbinfo;

#ifndef UDBHASHSIZE
#define UDBHASHSIZE 16
#endif

struct	udpstat udpstat;	/* from udp_var.h */
SYSCTL_STRUCT(_net_inet_udp, UDPCTL_STATS, stats, CTLFLAG_RD,
    &udpstat, udpstat, "UDP statistics (struct udpstat, netinet/udp_var.h)");

struct	sockaddr_in udp_in = { sizeof(udp_in), AF_INET };

static	void udp_detach(struct inpcb *);
static	void udp_notify(struct inpcb *, int);

void
udp_init()
{
	LIST_INIT(&udb);
	udbinfo.listhead = &udb;
	udbinfo.hashbase = phashinit(UDBHASHSIZE, M_PCB, &udbinfo.hashsize);
}

void
udp_input(m, iphlen, esrc)
	register struct mbuf *m;
	int iphlen;
	char *esrc;
{
	register struct ip *ip;
	register struct udphdr *uh;
	register struct inpcb *inp;
	struct mbuf *opts = 0;
	int len;
	struct ip save_ip;
#ifdef __riscos
	int sret;
#endif

	udpstat.udps_ipackets++;

	/*
	 * Strip IP options, if any; should skip this,
	 * make available to user, and use on returned packets,
	 * but we don't yet have a way to check the checksum
	 * with options still present.
	 */
	if (iphlen > sizeof (struct ip)) {
		ip_stripoptions(m, (struct mbuf *)0);
		iphlen = sizeof(struct ip);
	}

	/*
	 * Get IP and UDP header together in first mbuf.
	 */
	ip = mtod(m, struct ip *);
	if (m->m_len < iphlen + sizeof(struct udphdr)) {
		if ((m = PULLUP(m, iphlen + sizeof(struct udphdr))) == 0) {
			udpstat.udps_hdrops++;
			return;
		}
		ip = mtod(m, struct ip *);
	}
	uh = (struct udphdr *)((caddr_t)ip + iphlen);

	/*
	 * Make mbuf data length reflect UDP length.
	 * If not enough data to reflect UDP length, drop.
	 */
	len = ntohs((u_short)uh->uh_ulen);
	if (ip->ip_len != len) {
		if (len > ip->ip_len || len < sizeof(struct udphdr)) {
			udpstat.udps_badlen++;
			goto bad;
		}
		TRIM(m, len - ip->ip_len, NULL);
		/* ip->ip_len = len; */
	}
	/*
	 * Save a copy of the IP header in case we want restore it
	 * for sending an ICMP error message in response.
	 */
	save_ip = *ip;

	/*
	 * Checksum extended UDP header and data.
	 */
	if (uh->uh_sum) {
		((struct ipovly *)ip)->ih_next = 0;
		((struct ipovly *)ip)->ih_prev = 0;
		((struct ipovly *)ip)->ih_x1 = 0;
		((struct ipovly *)ip)->ih_len = uh->uh_ulen;
		uh->uh_sum = in_cksum(m, len + sizeof (struct ip));
		if (uh->uh_sum) {
			udpstat.udps_badsum++;
			m_freem(m);
			return;
		}
	}

#ifdef DEBUG
	if (DODEBUG(DBGUDP))
	{
	    Printf("udp_ip: datagram %s %x",
		   inet_ntoa(ip->ip_src), ntohs(uh->uh_sport));
	    Printf(", %s %x\n", inet_ntoa(ip->ip_dst), ntohs(uh->uh_dport));
	}
#endif
	if (IN_MULTICAST(ntohl(ip->ip_dst.s_addr)) ||
	    in_broadcast(ip->ip_dst, m->m_pkthdr.rcvif)) {
		struct inpcb *last;
#ifdef DEBUG
                if (DODEBUG(DBGUDP))
                        Printf("udp_input: it's a broadcast\n");
#endif
		/*
		 * Deliver a multicast or broadcast datagram to *all* sockets
		 * for which the local and remote addresses and ports match
		 * those of the incoming datagram.  This allows more than
		 * one process to receive multi/broadcasts on the same port.
		 * (This really ought to be done for unicast datagrams as
		 * well, but that would cause problems with existing
		 * applications that open both address-specific sockets and
		 * a wildcard socket listening to the same port -- they would
		 * end up receiving duplicates of every unicast datagram.
		 * Those applications open the multiple sockets to overcome an
		 * inadequacy of the UDP socket interface, but for backwards
		 * compatibility we avoid the problem here rather than
		 * fixing the interface.  Maybe 4.5BSD will remedy this?)
		 */

		/*
		 * Construct sockaddr format source address.
		 */
		udp_in.sin_port = uh->uh_sport;
		udp_in.sin_addr = ip->ip_src;
		m->m_len -= sizeof (struct udpiphdr);
		m->m_off += sizeof (struct udpiphdr);
		/*
		 * Locate pcb(s) for datagram.
		 * (Algorithm copied from raw_intr().)
		 */
		last = NULL;
		for (inp = udb.lh_first; inp != NULL; inp = inp->inp_list.le_next) {
			if (inp->inp_lport != uh->uh_dport)
				continue;
			if (inp->inp_laddr.s_addr != INADDR_ANY) {
				if (inp->inp_laddr.s_addr !=
				    ip->ip_dst.s_addr)
					continue;
			}
			if (inp->inp_faddr.s_addr != INADDR_ANY) {
				if (inp->inp_faddr.s_addr !=
				    ip->ip_src.s_addr ||
				    inp->inp_fport != uh->uh_sport)
					continue;
			}

			if (last != NULL) {
				struct mbuf *n;

				if ((n = m_copy(m, 0, M_COPYALL)) != NULL) {
					if (last->inp_flags & INP_CONTROLOPTS
					    || last->inp_socket->so_options & SO_TIMESTAMP)
						ip_savecontrol(last, &opts, ip, n);
#ifdef __riscos
					if ((sret = sorxdirect(last->inp_socket,
					      n, (struct sockaddr *)&udp_in,
					      ip->ip_dst.s_addr,
					      esrc, n->m_pkthdr.rcvif->if_unit,
					      n->m_pkthdr.rcvif->if_swibase
					                   + DCI4Transmit)) != 0) {
						if (sret == 1) m_freem(n);
						if (opts)
						    m_freem(opts);
						} else
#endif
					if (sbappendaddr(&last->inp_socket->so_rcv,
						(struct sockaddr *)&udp_in,
						n, opts) == 0) {
						m_freem(n);
						if (opts)
						    m_freem(opts);
						udpstat.udps_fullsock++;
					} else
						sorwakeup(last->inp_socket);
					opts = 0;
				}
			}
			last = inp;
			/*
			 * Don't look for additional matches if this one does
			 * not have either the SO_REUSEPORT or SO_REUSEADDR
			 * socket options set.  This heuristic avoids searching
			 * through all pcbs in the common case of a non-shared
			 * port.  It * assumes that an application will never
			 * clear these options after setting them.
			 */
			if ((last->inp_socket->so_options&(SO_REUSEPORT|SO_REUSEADDR) == 0))
				break;
		}

		if (last == NULL) {
			#ifdef __riscos
			if (in_bootpresponse(ntohs(uh->uh_dport))) {
				/* bootstrap packet response containing config info */
				bootp_udp_input(m);
			}
			#endif
			/*
			 * No matching pcb found; discard datagram.
			 * (No need to send an ICMP Port Unreachable
			 * for a broadcast or multicast datgram.)
			 */
			udpstat.udps_noportbcast++;
			goto bad;
		}
		if (last->inp_flags & INP_CONTROLOPTS
		    || last->inp_socket->so_options & SO_TIMESTAMP)
			ip_savecontrol(last, &opts, ip, m);
#ifdef __riscos
		if ((sret = sorxdirect(last->inp_socket, m, (struct sockaddr *)&udp_in, ip->ip_dst.s_addr,
	              esrc, m->m_pkthdr.rcvif->if_unit,
	              m->m_pkthdr.rcvif->if_swibase + DCI4Transmit)) != 0) {
			if (sret == 1) goto bad;
			else goto lessbad;
		}
#endif
		if (sbappendaddr(&last->inp_socket->so_rcv, (struct sockaddr *)&udp_in,
		     m, opts) == 0) {
			udpstat.udps_fullsock++;
			goto bad;
		}
		sorwakeup(last->inp_socket);
		return;
	}
	/*
	 * Locate pcb for datagram. First look for an exact match.
	 */
	inp = in_pcblookuphash(&udbinfo, ip->ip_src, uh->uh_sport,
	    ip->ip_dst, uh->uh_dport);
	/*
	 * ...and if that fails, do a wildcard search.
	 */
	if (inp == NULL) {
		inp = in_pcblookup(&udb, ip->ip_src, uh->uh_sport, ip->ip_dst,
		    uh->uh_dport, INPLOOKUP_WILDCARD);
	}
	if (inp == NULL) {
#ifdef DEBUG
		if( DODEBUG(DBGUDP) )
		    Printf("udp_ip: no pcb\n");
#endif
#ifdef __riscos
		if (in_bootpresponse(ntohs(uh->uh_dport))) {
		/* bootstrap packet response containing config info */
		    m->m_len -= sizeof(struct udpiphdr);
		    m->m_off += sizeof(struct udpiphdr);
		    bootp_udp_input(m);
		    goto bad;
		}
#endif
		udpstat.udps_noport++;
		if (m->m_flags & (M_BCAST | M_MCAST)) {
			udpstat.udps_noportbcast++;
			goto bad;
		}
		*ip = save_ip;
		icmp_error(m, ICMP_UNREACH, ICMP_UNREACH_PORT, 0, 0);
		return;
	}

	/*
	 * Construct sockaddr format source address.
	 * Stuff source address and datagram in user buffer.
	 */
	udp_in.sin_port = uh->uh_sport;
	udp_in.sin_addr = ip->ip_src;
	if (inp->inp_flags & INP_CONTROLOPTS
	    || inp->inp_socket->so_options & SO_TIMESTAMP)
		ip_savecontrol(inp, &opts, ip, m);
	iphlen += sizeof(struct udphdr);
	m->m_len -= iphlen;
	m->m_pkthdr.len -= iphlen;
	m->m_off += iphlen;
	if ((sret = sorxdirect(inp->inp_socket, m, (struct sockaddr *) &udp_in,
	               ip->ip_dst.s_addr, esrc, m->m_pkthdr.rcvif->if_unit,
	               m->m_pkthdr.rcvif->if_swibase + DCI4Transmit)) != 0) {
# ifdef DEBUG
	        if( DODEBUG(DBGUDP) )
		    Printf("udp_ip: rxdirect\n");
# endif
		if (sret == 1) goto bad;
		else goto lessbad;
	}
	if (sbappendaddr(&inp->inp_socket->so_rcv, (struct sockaddr *)&udp_in,
	    m, opts) == 0) {
#ifdef DEBUG
	        Printf("udp_ip: sbappendaddr failed\n");
#endif
		udpstat.udps_fullsock++;
		goto bad;
	}
	sorwakeup(inp->inp_socket);
	return;
bad:
	m_freem(m);
lessbad:
	if (opts)
		m_freem(opts);
}

#ifdef QuickMNSAcks
struct mbuf *
udp_setup_ack(m0, sin, laddr)
	struct mbuf *m0;
	struct sockaddr_in *sin;
	struct in_addr laddr;
{
	register int hlen = sizeof (struct ip);
	register struct mbuf *m;
	register struct udpiphdr *ui;
	register struct ip *ip;
	register int len = 8;
	char *p;
	struct mns_msg {
	    u_char  mns_opcode;
	    u_char  mns_port;
	    u_char  mns_control;
	    u_char  mns_status;
	    u_int   mns_handle;
	} *msg;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == 0)
		return ((struct mbuf *)0);
	MH_ALIGN(m, sizeof (struct udpiphdr) + len);

	m->m_pkthdr.rcvif = (struct ifnet *) 0;
	m->m_pkthdr.len = m->m_len = sizeof (struct udpiphdr) + len;
	ui = mtod(m, struct udpiphdr *);
	ui->ui_next = ui->ui_prev = 0;
	ui->ui_x1 = 0;
	ui->ui_pr = IPPROTO_UDP;
	ui->ui_len = htons((u_short)len + sizeof (struct udphdr));
	ui->ui_src = laddr;
	ui->ui_dst = sin->sin_addr;
	ui->ui_sport = sin->sin_port;
	ui->ui_dport = ui->ui_sport;
	ui->ui_ulen = ui->ui_len;
	ui->ui_sum = 0;
	((struct ip *)ui)->ip_len = sizeof (struct udpiphdr) + len;
	((struct ip *)ui)->ip_ttl = ip_defttl;
	ip = mtod(m, struct ip *);
	ip->ip_v = IPVERSION;
	ip->ip_off = 0;
	ip->ip_id = htons(ip_id++);
	ip->ip_hl = hlen >> 2;
	ip->ip_len = htons((u_short)ip->ip_len);
	ip->ip_sum = 0;
	p = mtod(m, char *) + sizeof(struct udpiphdr);
	memcpy (p, mtod(m0, char *), 8);
	msg = (struct mns_msg *)p;
	msg->mns_opcode = 3; /* ack */
	msg->mns_status = 0;

        ip->ip_sum = in_cksum(m, hlen);

	return (m);
}
#endif

/*
 * Notify a udp user of an asynchronous error;
 * just wake up so that he can collect error status.
 */
static void
udp_notify(inp, errno)
	register struct inpcb *inp;
	int errno;
{
	inp->inp_socket->so_error = errno;
	sorwakeup(inp->inp_socket);
	sowwakeup(inp->inp_socket);
}

void
udp_ctlinput(cmd, sa, vip)
	int cmd;
	struct sockaddr *sa;
	void *vip;
{
	register struct ip *ip = vip;
	register struct udphdr *uh;

	if (!PRC_IS_REDIRECT(cmd) &&
	    ((unsigned)cmd >= PRC_NCMDS || inetctlerrmap[cmd] == 0))
		return;
	if (ip) {
		uh = (struct udphdr *)((caddr_t)ip + (ip->ip_hl << 2));
		in_pcbnotify(&udb, sa, uh->uh_dport, ip->ip_src, uh->uh_sport,
			cmd, udp_notify);
	} else
		in_pcbnotify(&udb, sa, 0, zeroin_addr, 0, cmd, udp_notify);
}

static int
udp_pcblist SYSCTL_HANDLER_ARGS
{
	int error, i, n, s;
	struct inpcb *inp, **inp_list;
	inp_gen_t gencnt;
	struct xinpgen xig;

	/*
	 * The process of preparing the TCB list is too time-consuming and
	 * resource-intensive to repeat twice on every request.
	 */
	if (req->oldptr == 0) {
		n = udbinfo.ipi_count;
		req->oldidx = 2 * (sizeof xig)
			+ (n + n/8) * sizeof(struct xinpcb);
		return 0;
	}

	if (req->newptr != 0)
		return EPERM;

	/*
	 * OK, now we're committed to doing something.
	 */
	s = splnet();
	gencnt = udbinfo.ipi_gencnt;
	n = udbinfo.ipi_count;
	splx(s);

	xig.xig_len = sizeof xig;
	xig.xig_count = n;
	xig.xig_gen = gencnt;
	xig.xig_sogen = so_gencnt;
	error = SYSCTL_OUT(req, &xig, sizeof xig);
	if (error)
		return error;

	inp_list = malloc(n * sizeof *inp_list, M_TEMP, M_WAITOK);
	if (inp_list == 0)
		return ENOMEM;

	s = splnet();
	for (inp = udbinfo.listhead->lh_first, i = 0; inp && i < n;
	     inp = inp->inp_list.le_next) {
#ifdef __riscos
		if (inp->inp_gencnt <= gencnt)
#else
		if (inp->inp_gencnt <= gencnt && !prison_xinpcb(req->p, inp))
#endif
			inp_list[i++] = inp;
	}
	splx(s);
	n = i;

	error = 0;
	for (i = 0; i < n; i++) {
		inp = inp_list[i];
		if (inp->inp_gencnt <= gencnt) {
			struct xinpcb xi;
			xi.xi_len = sizeof xi;
			/* XXX should avoid extra copy */
			bcopy(inp, &xi.xi_inp, sizeof *inp);
			if (inp->inp_socket)
				sotoxsocket(inp->inp_socket, &xi.xi_socket);
			error = SYSCTL_OUT(req, &xi, sizeof xi);
		}
	}
	if (!error) {
		/*
		 * Give the user an updated idea of our state.
		 * If the generation differs from what we told
		 * her before, she knows that something happened
		 * while we were processing this request, and it
		 * might be necessary to retry.
		 */
		s = splnet();
		xig.xig_gen = udbinfo.ipi_gencnt;
		xig.xig_sogen = so_gencnt;
		xig.xig_count = udbinfo.ipi_count;
		splx(s);
		error = SYSCTL_OUT(req, &xig, sizeof xig);
	}
	free(inp_list, M_TEMP);
	return error;
}

SYSCTL_PROC(_net_inet_udp, UDPCTL_PCBLIST, pcblist, CTLFLAG_RD, 0, 0,
	    udp_pcblist, "S,xinpcb", "List of active UDP sockets");

int
udp_output(inp, m, addr, control)
	register struct inpcb *inp;
	register struct mbuf *m;
	struct mbuf *addr, *control;
{
	register struct udpiphdr *ui;
	register int len = m->m_pkthdr.len;
	struct in_addr laddr;
	int error = 0;

#ifdef DEBUG
    {
        struct mbuf *m1;
        Printf("\0x11\0x03udp_output(): inp = %x, m = %x, addr = %x, control = %x\n",
                inp, m, addr, control);
	for( m1 = m; m1; m1 = m1->m_next )
	    Printf("%x(%d, %d)-->", m1, m1->m_type, m1->m_len);
	Printf("(NULL)\021\007\n");
    }
#endif
	if (control)
		m_freem(control);		/* XXX */

	if (addr) {
		laddr = inp->inp_laddr;
		if (inp->inp_faddr.s_addr != INADDR_ANY) {
			error = EISCONN;
			goto release;
		}
		/*
		 * Must block input while temporarily connected.
		 */
		error = in_pcbconnect(inp, addr);
		if (error)
			goto release;
	} else {
                (void) &laddr; /* Shut up compiler -fa */
		if (inp->inp_faddr.s_addr == INADDR_ANY) {
			error = ENOTCONN;
			goto release;
		}
	}
	/*
	 * Calculate data length and get a mbuf
	 * for UDP and IP headers.
	 */
	M_PREPEND(m, sizeof(struct udpiphdr), M_DONTWAIT);
	if (m == 0) {
#ifdef DEBUG
		if (DODEBUG(DBGMMAN))
			Printf("udp_output: ALLOC_S failed\n");
#endif
		error = ENOBUFS;
		/*
		 * KJB fix - this probably never happens in Unix, but it
		 * can happen with our excellent Mbuf Manager...
		 */
		if (addr) {
			in_pcbdisconnect(inp);
			inp->inp_laddr = laddr;
		}
		goto release;
	}

	/*
	 * Fill in mbuf with extended UDP header
	 * and addresses and length put into network format.
	 */
	ui = mtod(m, struct udpiphdr *);
	ui->ui_next = ui->ui_prev = 0;
	ui->ui_x1 = 0;
	ui->ui_pr = IPPROTO_UDP;
	ui->ui_len = htons((u_short)len + sizeof (struct udphdr));
	ui->ui_src = inp->inp_laddr;
	ui->ui_dst = inp->inp_faddr;
	ui->ui_sport = inp->inp_lport;
	ui->ui_dport = inp->inp_fport;
	ui->ui_ulen = ui->ui_len;

	/*
	 * Stuff checksum and output datagram.
	 */
	ui->ui_sum = 0;
	if (udpcksum) {
	    if ((ui->ui_sum = in_cksum(m, sizeof (struct udpiphdr) + len)) == 0)
		ui->ui_sum = 0xffff;
	}
	((struct ip *)ui)->ip_len = sizeof (struct udpiphdr) + len;
	((struct ip *)ui)->ip_ttl = inp->inp_ip_ttl;	/* XXX */
	((struct ip *)ui)->ip_tos = inp->inp_ip_tos;	/* XXX */
	udpstat.udps_opackets++;
	error = ip_output(m, inp->inp_options, &inp->inp_route,
	    inp->inp_socket->so_options & (SO_DONTROUTE | SO_BROADCAST),
	    inp->inp_moptions);

	if (addr) {
		in_pcbdisconnect(inp);
		inp->inp_laddr = laddr;
	}
	return (error);

release:
	m_freem(m);
	return (error);
}

u_long	udp_sendspace = 9216;		/* really max datagram size */
SYSCTL_INT(_net_inet_udp, UDPCTL_MAXDGRAM, maxdgram, CTLFLAG_RW,
    &udp_sendspace, 0, "Maximum outgoing UDP datagram size");

u_long	udp_recvspace = 40 * (1024 + sizeof(struct sockaddr_in));
					/* 40 1K datagrams */
SYSCTL_INT(_net_inet_udp, UDPCTL_RECVSPACE, recvspace, CTLFLAG_RW,
    &udp_recvspace, 0, "Maximum incoming UDP datagram size");

/*ARGSUSED*/
int
udp_usrreq(so, req, m, addr, control)
	struct socket *so;
	int req;
	struct mbuf *m, *addr, *control;
{
	struct inpcb *inp = sotoinpcb(so);
	int error = 0;

#ifdef DEBUG2
        extern char *prurequests[];
        Printf("udp_usrreq(): so=%x, req=%s, m=%x, addr=%x, control=%x\n", so, prurequests[req], m, addr, control);
#endif
	if (req == PRU_CONTROL)
		return (in_control(so, (u_long)m, (caddr_t)addr,
			(struct ifnet *)control));
	if (inp == NULL && req != PRU_ATTACH) {
		error = EINVAL;
		goto release;
	}
	/*
	 * Note: need to block udp_input while changing
	 * the udp pcb queue and/or pcb addresses.
	 */
	switch (req) {

	case PRU_ATTACH:
		if (inp != NULL) {
			error = EINVAL;
			break;
		}
		error = in_pcballoc(so, &udbinfo);
		if (error)
			break;
		error = soreserve(so, udp_sendspace, udp_recvspace);
		if (error)
			break;
		((struct inpcb *) so->so_pcb)->inp_ip_ttl = ip_defttl;
		break;

	case PRU_DETACH:
		udp_detach(inp);
		break;

	case PRU_BIND:
		error = in_pcbbind(inp, addr);
		break;

	case PRU_LISTEN:
		error = EOPNOTSUPP;
		break;

	case PRU_CONNECT:
		if (inp->inp_faddr.s_addr != INADDR_ANY) {
			error = EISCONN;
			break;
		}
		error = in_pcbconnect(inp, addr);
		if (error == 0)
			soisconnected(so);
		break;

	case PRU_CONNECT2:
		error = EOPNOTSUPP;
		break;

	case PRU_ACCEPT:
		error = EOPNOTSUPP;
		break;

	case PRU_DISCONNECT:
		if (inp->inp_faddr.s_addr == INADDR_ANY) {
			error = ENOTCONN;
			break;
		}
		in_pcbdisconnect(inp);
		inp->inp_laddr.s_addr = INADDR_ANY;
		so->so_state &= ~SS_ISCONNECTED;		/* XXX */
		break;

	case PRU_SHUTDOWN:
		socantsendmore(so);
		break;

	case PRU_SEND:
		return (udp_output(inp, m, addr, control));

	case PRU_ABORT:
		soisdisconnected(so);
		udp_detach(inp);
		break;

	case PRU_SOCKADDR:
		in_setsockaddr(inp, addr);
		break;

	case PRU_PEERADDR:
		in_setpeeraddr(inp, addr);
		break;

	case PRU_SENSE:
		/*
		 * stat: don't bother with a blocksize.
		 */
		return (0);

	case PRU_SENDOOB:
	case PRU_FASTTIMO:
	case PRU_SLOWTIMO:
	case PRU_PROTORCV:
	case PRU_PROTOSEND:
		error =	 EOPNOTSUPP;
		break;

	case PRU_RCVD:
	case PRU_RCVOOB:
		return (EOPNOTSUPP);	/* do not free mbuf's */

	default:
		panic("udp_usrreq");
	}

release:
	if (control) {
		printf("udp control data unexpectedly retained\n");
		m_freem(control);
	}
	if (m)
	    m_freem(m);
	return (error);
}

static void
udp_detach(inp)
	struct inpcb *inp;
{
	in_pcbdetach(inp);
}
@


4.6
log
@Added new FreeBSD sysctl handling using linker magic.
A few new sysctls added as a result.
SO_TIMESTAMP now gives real time, not Internet's internal time.
DHCP/BOOTP parsing picks up URL option and pops it into Inet$URL.
Requires TCPIPLibs 5.25 and link 5.12.

Version 5.31. Tagged as 'Internet-5_31'
@
text
@d122 3
d253 1
a253 1
					if (sorxdirect(last->inp_socket,
d256 4
a259 4
	               			      esrc, n->m_pkthdr.rcvif->if_unit,
	               			      n->m_pkthdr.rcvif->if_swibase
	               			                   + DCI4Transmit)) {
	               				m_freem(n);
d262 1
a262 1
	               			} else
d291 2
a292 2
  			if (in_bootpresponse(ntohs(uh->uh_dport))) {
 				/* bootstrap packet response containing config info */
d308 1
a308 1
		if (sorxdirect(last->inp_socket, m, (struct sockaddr *)&udp_in, ip->ip_dst.s_addr,
d310 4
a313 2
	              m->m_pkthdr.rcvif->if_swibase + DCI4Transmit))
	               	goto bad;
d372 1
a372 1
	if (sorxdirect(inp->inp_socket, m, (struct sockaddr *) &udp_in,
d374 1
a374 1
	               m->m_pkthdr.rcvif->if_swibase + DCI4Transmit)) {
d379 2
a380 1
	        goto bad;
d394 1
@


4.5
log
@* Dynamic ports now assigned in range 49152-65535.
* IP_RECVDSTADDR works for non-unicast packets.
* SO_TIMESTAMP added.
* IP_RECVIF added.
* Various other internal changes merged in from FreeBSD sources.

Version 5.29. Tagged as 'Internet-5_29'
@
text
@d37 1
a44 1
#include <sys/queue.h>
d83 2
d90 1
a90 1
#define UDBHASHSIZE 64
d94 2
d486 90
d684 3
d689 2
a829 34
}

/*
 * Sysctl for udp variables.
 */
int
udp_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case UDPCTL_CHECKSUM:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &udpcksum));
	case UDPCTL_STATS:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &udpstat,
					sizeof udpstat));
	case UDPCTL_MAXDGRAM:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   (int *)&udp_sendspace)); /* XXX */
	case UDPCTL_RECVSPACE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   (int *)&udp_recvspace)); /* XXX */
	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
@


4.4
log
@* Fixed bug introduced by tentative ARP probe - a typo made arp_ifinit() fail to
  set up the interface route structure properly.
* Divide-by-zero when an IGMP membership query with a time of 1 received fixed
  (from FreeBSD).
* IGMP messages now sent with TOS set to "maximum reliability".
* tcp_output.c updated from FreeBSD - in particular path_mtu_discovery sysctl
  now available.
* A few other FreeBSD structural changes and bug fixes integrated.
* Put UDP checksum in BOOTP packets.
* Null pointer dereferencing fixed in whoami.c. Address setting now done with
  SIOCDIFADDR and SIOCAIFADDR. Don't set the netmask if asked not to.
* Output BOOTP packets with the source address in ciaddr
Note that various structural changes mean that the support tools (in particular
InetStat) will need to be recompiled.
Requires TCPIPLibs 5.20

Version 5.27. Tagged as 'Internet-5_27'
@
text
@a96 1
static	struct mbuf *udp_saveopt(caddr_t, int, int);
d190 1
a190 1
		struct socket *last;
d242 3
d246 1
a246 1
					if (sorxdirect(last,
d251 1
a251 1
	               			                   + DCI4Transmit))
d253 3
a255 1
	               			else
d257 1
a257 1
					if (sbappendaddr(&last->so_rcv,
d259 1
a259 1
						n, (struct mbuf *)0) == 0) {
d261 2
d264 3
a266 3
					} else {
						sorwakeup(last);
					}
d269 1
a269 1
			last = inp->inp_socket;
d278 1
a278 1
			if ((last->so_options&(SO_REUSEPORT|SO_REUSEADDR) == 0))
d297 3
d301 1
a301 1
		if (sorxdirect(last, m, (struct sockaddr *)&udp_in, ip->ip_dst.s_addr,
d306 2
a307 2
		if (sbappendaddr(&last->so_rcv, (struct sockaddr *)&udp_in,
		     m, (struct mbuf *)0) == 0) {
d311 1
a311 1
		sorwakeup(last);
d356 3
a358 26
	if (inp->inp_flags & INP_CONTROLOPTS) {
		struct mbuf **mp = &opts;

		if (inp->inp_flags & INP_RECVDSTADDR) {
			*mp = udp_saveopt((caddr_t) &ip->ip_dst,
			    sizeof(struct in_addr), IP_RECVDSTADDR);
			if (*mp)
				mp = &(*mp)->m_next;
		}
#ifdef notyet
		/* options were tossed above */
		if (inp->inp_flags & INP_RECVOPTS) {
			*mp = udp_saveopt((caddr_t) opts_deleted_above,
			    sizeof(struct in_addr), IP_RECVOPTS);
			if (*mp)
				mp = &(*mp)->m_next;
		}
		/* ip_srcroute doesn't do what we want here, need to fix */
		if (inp->inp_flags & INP_RECVRETOPTS) {
			*mp = udp_saveopt((caddr_t) ip_srcroute(),
			    sizeof(struct in_addr), IP_RECVRETOPTS);
			if (*mp)
				mp = &(*mp)->m_next;
		}
#endif
	}
a385 25
}

/*
 * Create a "control" mbuf containing the specified data
 * with the specified type for presentation with a datagram.
 */
static struct mbuf *
udp_saveopt(p, size, type)
	caddr_t p;
	register int size;
	int type;
{
	register struct cmsghdr *cp;
	struct mbuf *m;

	if ((m = m_get(M_DONTWAIT, MT_CONTROL)) == NULL)
		return ((struct mbuf *) NULL);
	cp = (struct cmsghdr *) mtod(m, struct cmsghdr *);
	(void)memcpy(CMSG_DATA(cp), p, size);
	size += sizeof(*cp);
	m->m_len = size;
	cp->cmsg_len = size;
	cp->cmsg_level = IPPROTO_IP;
	cp->cmsg_type = type;
	return (m);
@


4.3
log
@BOOTP was a bit broken
@
text
@d610 2
a611 2
	((struct ip *)ui)->ip_ttl = inp->inp_ip.ip_ttl;	/* XXX */
	((struct ip *)ui)->ip_tos = inp->inp_ip.ip_tos;	/* XXX */
d670 1
a670 1
		((struct inpcb *) so->so_pcb)->inp_ip.ip_ttl = ip_defttl;
@


4.2
log
@Version Spinner_B7 taken
@
text
@d277 6
d328 1
a328 2
		    m_freem(m);
		    return;
@


4.1
log
@Initial revision
@
text
@d1 3
a3 1
/* -*-C-*-
d5 15
a19 2
 * $Header: /ax/networking:Internet/netinet/udp_usrreq.c:networking  1.4  $
 * $Source: /ax/networking:Internet/netinet/udp_usrreq.c: $
d21 11
a31 1
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
a32 13
 * $Log:	udp_usrreq.c,v $
 * Revision 1.4  95/03/31  11:56:40  kwelton
 * Added some debugs to udp_input().
 * 
 * Revision 1.3  95/03/13  16:10:24  aideen
 * Default is to have UDP checksums disabled.
 * 
 * Revision 1.2  95/03/10  17:30:14  kwelton
 * Default is to have UDP checksums enabled.
 * 
 * Revision 1.1  94/12/02  11:24:42  kwelton
 * Initial revision
 * 
d34 30
a63 39
/*
 * Copyright (c) 1983, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 */
#include "sys/param.h"
#include "sys/dir.h"
#include "sys/user.h"
#include "sys/stat.h"
#include "sys/mbuf.h"
#include "sys/protosw.h"
#include "sys/socket.h"
#include "sys/socketvar.h"
#include "sys/errno.h"
#include "sys/dcistructs.h"

#include "net/if.h"
#include "net/route.h"

#include "netinet/in.h"
#include "netinet/in_pcb.h"
#include "netinet/in_systm.h"
#include "netinet/ip.h"
#include "netinet/ip_var.h"
#include "netinet/ip_icmp.h"
#include "netinet/udp.h"
#include "netinet/udp_var.h"
d67 2
d74 26
d102 3
a104 2

	udb.inp_next = udb.inp_prev = &udb;
d107 4
a110 8
int	udpcksum = 0;		/* XXX */
int	udp_ttl = UDP_TTL;

struct	sockaddr_in udp_in = { AF_INET };

udp_input(m0, ifp, esrc)
	struct mbuf *m0;
	struct ifnet *ifp;
d113 2
a114 1
	register struct udpiphdr *ui;
d116 1
a116 1
	register struct mbuf *m;
d118 14
a131 1
	struct ip ip;
a134 1
	 * Note: IP leaves IP header in first mbuf.
d136 7
a142 7
	m = m0;
	ui = mtod(m, struct udpiphdr *);
	if (((struct ip *)ui)->ip_hl > (sizeof (struct ip) >> 2))
		ip_stripoptions((struct ip *)ui, (struct mbuf *)0);
	if (m->m_len < sizeof (struct udpiphdr)) {
		udpstat.udps_hdrops++;
		return;
d144 2
d150 3
a152 3
	len = ntohs((u_short)ui->ui_ulen);
	if (((struct ip *)ui)->ip_len != len) {
		if (len > ((struct ip *)ui)->ip_len) {
d154 1
a154 1
			goto release;
d156 2
a157 6
#ifdef OldCode
		m_adj(m, len - ((struct ip *)ui)->ip_len);
#else
		TRIM(m, len - ((struct ip *)ui)->ip_len, NULL);
#endif
		/* ((struct ip *)ui)->ip_len = len; */
d160 2
a161 1
	 * Save a copy of the IP header in case we want restore it for ICMP.
d163 1
a163 1
	ip = *(struct ip*)ui;
d168 7
a174 5
	if (udpcksum && ui->ui_sum) {
		ui->ui_next = ui->ui_prev = 0;
		ui->ui_x1 = 0;
		ui->ui_len = ui->ui_ulen;
		if (ui->ui_sum = in_cksum(m, len + sizeof (struct ip))) {
a175 1
#ifdef OldCode
a176 3
#else
			FREEM(m);
#endif
d182 1
a182 1
	if( DODEBUG(DBGUDP) )
d185 2
a186 2
		   inet_ntoa(ui->ui_src), ntohs(ui->ui_sport));
	    Printf(", %s %x\n", inet_ntoa(ui->ui_dst), ntohs(ui->ui_dport));
d189 22
d212 87
d300 1
a300 1
	 * Locate pcb for datagram.
d302 10
a311 4
	inp = in_pcblookup(&udb,
	    ui->ui_src, ui->ui_sport, ui->ui_dst, ui->ui_dport,
		INPLOOKUP_WILDCARD);
	if (inp == 0) {
d316 2
a317 1
		if (in_bootpresponse(ntohs(ui->ui_dport))) {
d321 1
a321 2
		    bootp_udp_input(ifp, m);
#ifdef OldCode
d323 2
a324 2
#else
		    FREEM(m);
d326 4
a329 1
		    return;
d331 3
a333 1
		goto release;
d340 35
a374 16
	udp_in.sin_port = ui->ui_sport;
	udp_in.sin_addr = ui->ui_src;
	m->m_len -= sizeof (struct udpiphdr);
	m->m_off += sizeof (struct udpiphdr);

#ifdef OldCode
	if (sorxdirect(inp->inp_socket, m, &udp_in, ui->ui_dst, esrc, ifp->if_unit, ifp->if_swibase + 3))
	    goto release;
#else
	/*
	 * DCI swibase offset for transmit has changed for DCI 4
	 */
	if (sorxdirect(inp->inp_socket, m, &udp_in, ui->ui_dst,
		       esrc, ifp->if_unit,
		       ifp->if_swibase + DCI4Transmit))
	{
d376 2
a377 2
	    if( DODEBUG(DBGUDP) )
		Printf("udp_ip: rxdirect\n");
d379 1
a379 2
	    goto release;
#endif
d382 1
a382 2
	    m, (struct mbuf *)0) == 0)
	{
d384 1
a384 1
	    Printf("udp_ip: sbappendaddr failed\n");
d386 2
a387 1
	    goto release;
d391 1
a391 2
release:
#ifdef OldCode
d393 27
a419 3
#else
	FREEM(m);
#endif
d422 1
d425 3
a427 3
struct mbuf *m0;
struct sockaddr_in *sin;
struct in_addr laddr;
d443 1
a443 2
#ifdef OldCode
	MGET(m, M_DONTWAIT, MT_HEADER);
d446 1
a446 10
	m->m_off = MMAXOFF(m) - (sizeof (struct udpiphdr) + len);
#else
	if( (m = ALLOC_S(MINCONTIG, NULL)) == NULL )
	{
#ifdef DEBUG
	    if( DODEBUG(DBGMMAN) )
		Printf("udp_setup_ack: ALLOC_S failed\n");
#endif
	    return((struct mbuf *)0);
	}
d448 2
a449 4
	m->m_type = MT_HEADER;
	m->m_off = MAXOFF(m) - (sizeof (struct udpiphdr) + len);
#endif
	m->m_len = sizeof (struct udpiphdr) + len;
d462 1
a462 1
	((struct ip *)ui)->ip_ttl = udp_ttl;
d475 3
d480 1
d486 2
a487 1
udp_notify(inp)
d489 1
d491 1
a491 1

d496 2
a497 1
udp_ctlinput(cmd, sa)
d500 1
d502 2
a503 3
	extern u_char inetctlerrmap[];
	struct sockaddr_in *sin;
	int in_rtchange();
d505 2
a506 3
	if ((unsigned)cmd > PRC_NCMDS)
		return;
	if (sa->sa_family != AF_INET && sa->sa_family != AF_IMPLINK)
d508 6
a513 23
	sin = (struct sockaddr_in *)sa;
	if (sin->sin_addr.s_addr == INADDR_ANY)
		return;

	switch (cmd) {

	case PRC_QUENCH:
		break;

	case PRC_ROUTEDEAD:
	case PRC_REDIRECT_NET:
	case PRC_REDIRECT_HOST:
	case PRC_REDIRECT_TOSNET:
	case PRC_REDIRECT_TOSHOST:
		in_pcbnotify(&udb, &sin->sin_addr, 0, in_rtchange);
		break;

	default:
		if (inetctlerrmap[cmd] == 0)
			return;		/* XXX */
		in_pcbnotify(&udb, &sin->sin_addr, (int)inetctlerrmap[cmd],
			udp_notify);
	}
d516 2
a517 1
udp_output(inp, m0)
d519 2
a520 1
	struct mbuf *m0;
a521 1
	register struct mbuf *m;
d523 16
a538 1
	register int len = 0;
d540 19
d563 1
a563 4
	for (m = m0; m; m = m->m_next)
		len += m->m_len;
#ifdef OldCode
	MGET(m, M_DONTWAIT, MT_HEADER);
a564 6
		m_freem(m0);
		return (ENOBUFS);
	}
#else
	if( (m = ALLOC_S(MINCONTIG, NULL)) == NULL )
	{
d566 2
a567 2
	    if( DODEBUG(DBGMMAN) )
		Printf("udp_output: ALLOC_S failed\n");
d569 10
a578 2
	    FREEM(m0);
	    return(ENOBUFS);
a579 2
	m->m_type = MT_HEADER;
#endif
a584 3
	m->m_off = MAXOFF(m) - sizeof (struct udpiphdr);
	m->m_len = sizeof (struct udpiphdr);
	m->m_next = m0;
d605 16
a620 3
	((struct ip *)ui)->ip_ttl = udp_ttl;
	return (ip_output(m, inp->inp_options, &inp->inp_route,
	    inp->inp_socket->so_options & (SO_DONTROUTE | SO_BROADCAST)));
d623 3
a625 2
u_long	udp_sendspace = 20480;
u_long	udp_recvspace = 20480;
d628 2
a629 1
udp_usrreq(so, req, m, nam, rights)
d632 1
a632 1
	struct mbuf *m, *nam, *rights;
d637 4
d642 2
a643 6
		return (in_control(so, (int)m, (caddr_t)nam,
			(struct ifnet *)rights));
	if (rights && rights->m_len) {
		error = EINVAL;
		goto release;
	}
d648 4
d659 1
a659 1
		error = in_pcballoc(so, &udb);
d665 1
d669 1
a669 1
		in_pcbdetach(inp);
d673 1
a673 1
		error = in_pcbbind(inp, nam);
d685 1
a685 1
		error = in_pcbconnect(inp, nam);
d704 1
d712 2
a713 30
	case PRU_SEND: {
		struct in_addr laddr;

		if (nam) {
			laddr = inp->inp_laddr;
			if (inp->inp_faddr.s_addr != INADDR_ANY) {
				error = EISCONN;
				break;
			}
			/*
			 * Must block input while temporarily connected.
			 */
			error = in_pcbconnect(inp, nam);
			if (error) {
				break;
			}
		} else {
			if (inp->inp_faddr.s_addr == INADDR_ANY) {
				error = ENOTCONN;
				break;
			}
		}
		error = udp_output(inp, m);
		m = NULL;
		if (nam) {
			in_pcbdisconnect(inp);
			inp->inp_laddr = laddr;
		}
		}
		break;
d717 1
a717 1
		in_pcbdetach(inp);
d721 1
a721 1
		in_setsockaddr(inp, nam);
d725 1
a725 1
		in_setpeeraddr(inp, nam);
d749 1
d751 5
a755 3
	if (m != NULL)
	{
#ifdef OldCode
a756 4
#else
	    FREEM(m);
#endif
	}
d760 40
a799 1
/* EOF udp_usrreq.c */
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d1 21
d23 2
a24 2
 * Copyright (c) 1982, 1986, 1988, 1990, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
d26 11
a36 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d39 22
a60 30

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/stat.h>
#include <sys/queue.h>
#ifndef __riscos
#include <vm/vm.h>
#else
#include <sys/dcistructs.h>
#endif
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
a63 2
#include "module.h"
#include "whoami.h"
d69 2
a70 9
#ifndef __riscos
#ifndef	COMPAT_42
int	udpcksum = 1;
#else
int	udpcksum = 0;		/* XXX */
#endif
#else
int	udpcksum = 0;		/* XXX */
#endif
d72 2
a73 2
struct	inpcbhead udb;		/* from udp_var.h */
struct	inpcbinfo udbinfo;
d75 2
a76 3
#ifndef UDBHASHSIZE
#define UDBHASHSIZE 64
#endif
d78 1
a78 1
struct	udpstat udpstat;	/* from udp_var.h */
d80 3
a82 18
struct	sockaddr_in udp_in = { sizeof(udp_in), AF_INET };

static	void udp_detach(struct inpcb *);
static	void udp_notify(struct inpcb *, int);
static	struct mbuf *udp_saveopt(caddr_t, int, int);

void
udp_init()
{
	LIST_INIT(&udb);
	udbinfo.listhead = &udb;
	udbinfo.hashbase = phashinit(UDBHASHSIZE, M_PCB, &udbinfo.hashsize);
}

void
udp_input(m, iphlen, esrc)
	register struct mbuf *m;
	int iphlen;
d85 1
a85 2
	register struct ip *ip;
	register struct udphdr *uh;
d87 1
a87 1
	struct mbuf *opts = 0;
d89 1
a89 14
	struct ip save_ip;

	udpstat.udps_ipackets++;

	/*
	 * Strip IP options, if any; should skip this,
	 * make available to user, and use on returned packets,
	 * but we don't yet have a way to check the checksum
	 * with options still present.
	 */
	if (iphlen > sizeof (struct ip)) {
		ip_stripoptions(m, (struct mbuf *)0);
		iphlen = sizeof(struct ip);
	}
d93 1
d95 7
a101 7
	ip = mtod(m, struct ip *);
	if (m->m_len < iphlen + sizeof(struct udphdr)) {
		if ((m = PULLUP(m, iphlen + sizeof(struct udphdr))) == 0) {
			udpstat.udps_hdrops++;
			return;
		}
		ip = mtod(m, struct ip *);
a102 2
	uh = (struct udphdr *)((caddr_t)ip + iphlen);

d107 3
a109 3
	len = ntohs((u_short)uh->uh_ulen);
	if (ip->ip_len != len) {
		if (len > ip->ip_len || len < sizeof(struct udphdr)) {
d111 1
a111 1
			goto bad;
d113 6
a118 2
		TRIM(m, len - ip->ip_len, NULL);
		/* ip->ip_len = len; */
d121 1
a121 2
	 * Save a copy of the IP header in case we want restore it
	 * for sending an ICMP error message in response.
d123 1
a123 1
	save_ip = *ip;
d128 5
a132 7
	if (uh->uh_sum) {
		((struct ipovly *)ip)->ih_next = 0;
		((struct ipovly *)ip)->ih_prev = 0;
		((struct ipovly *)ip)->ih_x1 = 0;
		((struct ipovly *)ip)->ih_len = uh->uh_ulen;
		uh->uh_sum = in_cksum(m, len + sizeof (struct ip));
		if (uh->uh_sum) {
d134 1
d136 3
d144 1
a144 1
	if (DODEBUG(DBGUDP))
d147 2
a148 2
		   inet_ntoa(ip->ip_src), ntohs(uh->uh_sport));
	    Printf(", %s %x\n", inet_ntoa(ip->ip_dst), ntohs(uh->uh_dport));
a150 22
	if (IN_MULTICAST(ntohl(ip->ip_dst.s_addr)) ||
	    in_broadcast(ip->ip_dst, m->m_pkthdr.rcvif)) {
		struct socket *last;
#ifdef DEBUG
                if (DODEBUG(DBGUDP))
                        Printf("udp_input: it's a broadcast\n");
#endif
		/*
		 * Deliver a multicast or broadcast datagram to *all* sockets
		 * for which the local and remote addresses and ports match
		 * those of the incoming datagram.  This allows more than
		 * one process to receive multi/broadcasts on the same port.
		 * (This really ought to be done for unicast datagrams as
		 * well, but that would cause problems with existing
		 * applications that open both address-specific sockets and
		 * a wildcard socket listening to the same port -- they would
		 * end up receiving duplicates of every unicast datagram.
		 * Those applications open the multiple sockets to overcome an
		 * inadequacy of the UDP socket interface, but for backwards
		 * compatibility we avoid the problem here rather than
		 * fixing the interface.  Maybe 4.5BSD will remedy this?)
		 */
a151 87
		/*
		 * Construct sockaddr format source address.
		 */
		udp_in.sin_port = uh->uh_sport;
		udp_in.sin_addr = ip->ip_src;
		m->m_len -= sizeof (struct udpiphdr);
		m->m_off += sizeof (struct udpiphdr);
		/*
		 * Locate pcb(s) for datagram.
		 * (Algorithm copied from raw_intr().)
		 */
		last = NULL;
		for (inp = udb.lh_first; inp != NULL; inp = inp->inp_list.le_next) {
			if (inp->inp_lport != uh->uh_dport)
				continue;
			if (inp->inp_laddr.s_addr != INADDR_ANY) {
				if (inp->inp_laddr.s_addr !=
				    ip->ip_dst.s_addr)
					continue;
			}
			if (inp->inp_faddr.s_addr != INADDR_ANY) {
				if (inp->inp_faddr.s_addr !=
				    ip->ip_src.s_addr ||
				    inp->inp_fport != uh->uh_sport)
					continue;
			}

			if (last != NULL) {
				struct mbuf *n;

				if ((n = m_copy(m, 0, M_COPYALL)) != NULL) {
#ifdef __riscos
					if (sorxdirect(last,
					      n, (struct sockaddr *)&udp_in,
					      ip->ip_dst.s_addr,
	               			      esrc, n->m_pkthdr.rcvif->if_unit,
	               			      n->m_pkthdr.rcvif->if_swibase
	               			                   + DCI4Transmit))
	               				m_freem(n);
	               			else
#endif
					if (sbappendaddr(&last->so_rcv,
						(struct sockaddr *)&udp_in,
						n, (struct mbuf *)0) == 0) {
						m_freem(n);
						udpstat.udps_fullsock++;
					} else {
						sorwakeup(last);
					}
				}
			}
			last = inp->inp_socket;
			/*
			 * Don't look for additional matches if this one does
			 * not have either the SO_REUSEPORT or SO_REUSEADDR
			 * socket options set.  This heuristic avoids searching
			 * through all pcbs in the common case of a non-shared
			 * port.  It * assumes that an application will never
			 * clear these options after setting them.
			 */
			if ((last->so_options&(SO_REUSEPORT|SO_REUSEADDR) == 0))
				break;
		}

		if (last == NULL) {
			/*
			 * No matching pcb found; discard datagram.
			 * (No need to send an ICMP Port Unreachable
			 * for a broadcast or multicast datgram.)
			 */
			udpstat.udps_noportbcast++;
			goto bad;
		}
#ifdef __riscos
		if (sorxdirect(last, m, (struct sockaddr *)&udp_in, ip->ip_dst.s_addr,
	              esrc, m->m_pkthdr.rcvif->if_unit,
	              m->m_pkthdr.rcvif->if_swibase + DCI4Transmit))
	               	goto bad;
#endif
		if (sbappendaddr(&last->so_rcv, (struct sockaddr *)&udp_in,
		     m, (struct mbuf *)0) == 0) {
			udpstat.udps_fullsock++;
			goto bad;
		}
		sorwakeup(last);
		return;
	}
d153 1
a153 1
	 * Locate pcb for datagram. First look for an exact match.
d155 4
a158 10
	inp = in_pcblookuphash(&udbinfo, ip->ip_src, uh->uh_sport,
	    ip->ip_dst, uh->uh_dport);
	/*
	 * ...and if that fails, do a wildcard search.
	 */
	if (inp == NULL) {
		inp = in_pcblookup(&udb, ip->ip_src, uh->uh_sport, ip->ip_dst,
		    uh->uh_dport, INPLOOKUP_WILDCARD);
	}
	if (inp == NULL) {
d163 1
a163 2
#ifdef __riscos
		if (in_bootpresponse(ntohs(uh->uh_dport))) {
d167 2
a168 1
		    bootp_udp_input(m);
d170 3
d175 1
a175 9
#endif
		udpstat.udps_noport++;
		if (m->m_flags & (M_BCAST | M_MCAST)) {
			udpstat.udps_noportbcast++;
			goto bad;
		}
		*ip = save_ip;
		icmp_error(m, ICMP_UNREACH, ICMP_UNREACH_PORT, 0, 0);
		return;
d182 16
a197 35
	udp_in.sin_port = uh->uh_sport;
	udp_in.sin_addr = ip->ip_src;
	if (inp->inp_flags & INP_CONTROLOPTS) {
		struct mbuf **mp = &opts;

		if (inp->inp_flags & INP_RECVDSTADDR) {
			*mp = udp_saveopt((caddr_t) &ip->ip_dst,
			    sizeof(struct in_addr), IP_RECVDSTADDR);
			if (*mp)
				mp = &(*mp)->m_next;
		}
#ifdef notyet
		/* options were tossed above */
		if (inp->inp_flags & INP_RECVOPTS) {
			*mp = udp_saveopt((caddr_t) opts_deleted_above,
			    sizeof(struct in_addr), IP_RECVOPTS);
			if (*mp)
				mp = &(*mp)->m_next;
		}
		/* ip_srcroute doesn't do what we want here, need to fix */
		if (inp->inp_flags & INP_RECVRETOPTS) {
			*mp = udp_saveopt((caddr_t) ip_srcroute(),
			    sizeof(struct in_addr), IP_RECVRETOPTS);
			if (*mp)
				mp = &(*mp)->m_next;
		}
#endif
	}
	iphlen += sizeof(struct udphdr);
	m->m_len -= iphlen;
	m->m_pkthdr.len -= iphlen;
	m->m_off += iphlen;
	if (sorxdirect(inp->inp_socket, m, (struct sockaddr *) &udp_in,
	               ip->ip_dst.s_addr, esrc, m->m_pkthdr.rcvif->if_unit,
	               m->m_pkthdr.rcvif->if_swibase + DCI4Transmit)) {
d199 2
a200 2
	        if( DODEBUG(DBGUDP) )
		    Printf("udp_ip: rxdirect\n");
d202 2
a203 1
	        goto bad;
d206 2
a207 1
	    m, opts) == 0) {
d209 1
a209 1
	        Printf("udp_ip: sbappendaddr failed\n");
d211 1
a211 2
		udpstat.udps_fullsock++;
		goto bad;
d215 2
a216 1
bad:
d218 3
a220 2
	if (opts)
		m_freem(opts);
a222 26
/*
 * Create a "control" mbuf containing the specified data
 * with the specified type for presentation with a datagram.
 */
static struct mbuf *
udp_saveopt(p, size, type)
	caddr_t p;
	register int size;
	int type;
{
	register struct cmsghdr *cp;
	struct mbuf *m;

	if ((m = m_get(M_DONTWAIT, MT_CONTROL)) == NULL)
		return ((struct mbuf *) NULL);
	cp = (struct cmsghdr *) mtod(m, struct cmsghdr *);
	(void)memcpy(CMSG_DATA(cp), p, size);
	size += sizeof(*cp);
	m->m_len = size;
	cp->cmsg_len = size;
	cp->cmsg_level = IPPROTO_IP;
	cp->cmsg_type = type;
	return (m);
}

#ifdef QuickMNSAcks
d225 3
a227 3
	struct mbuf *m0;
	struct sockaddr_in *sin;
	struct in_addr laddr;
d243 2
a244 1
	MGETHDR(m, M_DONTWAIT, MT_DATA);
d247 10
a256 1
	MH_ALIGN(m, sizeof (struct udpiphdr) + len);
d258 4
a261 2
	m->m_pkthdr.rcvif = (struct ifnet *) 0;
	m->m_pkthdr.len = m->m_len = sizeof (struct udpiphdr) + len;
d274 1
a274 1
	((struct ip *)ui)->ip_ttl = ip_defttl;
a286 3

        ip->ip_sum = in_cksum(m, hlen);

a288 1
#endif
d294 1
a294 2
static void
udp_notify(inp, errno)
a295 1
	int errno;
d297 1
a297 1
	inp->inp_socket->so_error = errno;
d302 1
a302 2
void
udp_ctlinput(cmd, sa, vip)
a304 1
	void *vip;
d306 3
a308 2
	register struct ip *ip = vip;
	register struct udphdr *uh;
d310 3
a312 2
	if (!PRC_IS_REDIRECT(cmd) &&
	    ((unsigned)cmd >= PRC_NCMDS || inetctlerrmap[cmd] == 0))
d314 23
a336 6
	if (ip) {
		uh = (struct udphdr *)((caddr_t)ip + (ip->ip_hl << 2));
		in_pcbnotify(&udb, sa, uh->uh_dport, ip->ip_src, uh->uh_sport,
			cmd, udp_notify);
	} else
		in_pcbnotify(&udb, sa, 0, zeroin_addr, 0, cmd, udp_notify);
d339 1
a339 2
int
udp_output(inp, m, addr, control)
d341 2
a343 2
	struct mbuf *addr, *control;
{
d345 1
a345 16
	register int len = m->m_pkthdr.len;
	struct in_addr laddr;
	int error = 0;

#ifdef DEBUG
    {
        struct mbuf *m1;
        Printf("\0x11\0x03udp_output(): inp = %x, m = %x, addr = %x, control = %x\n",
                inp, m, addr, control);
	for( m1 = m; m1; m1 = m1->m_next )
	    Printf("%x(%d, %d)-->", m1, m1->m_type, m1->m_len);
	Printf("(NULL)\021\007\n");
    }
#endif
	if (control)
		m_freem(control);		/* XXX */
a346 19
	if (addr) {
		laddr = inp->inp_laddr;
		if (inp->inp_faddr.s_addr != INADDR_ANY) {
			error = EISCONN;
			goto release;
		}
		/*
		 * Must block input while temporarily connected.
		 */
		error = in_pcbconnect(inp, addr);
		if (error)
			goto release;
	} else {
                (void) &laddr; /* Shut up compiler -fa */
		if (inp->inp_faddr.s_addr == INADDR_ANY) {
			error = ENOTCONN;
			goto release;
		}
	}
d351 4
a354 1
	M_PREPEND(m, sizeof(struct udpiphdr), M_DONTWAIT);
d356 6
d363 2
a364 2
		if (DODEBUG(DBGMMAN))
			Printf("udp_output: ALLOC_S failed\n");
d366 2
a367 10
		error = ENOBUFS;
		/*
		 * KJB fix - this probably never happens in Unix, but it
		 * can happen with our excellent Mbuf Manager...
		 */
		if (addr) {
			in_pcbdisconnect(inp);
			inp->inp_laddr = laddr;
		}
		goto release;
d369 2
d376 3
d399 3
a401 16
	((struct ip *)ui)->ip_ttl = inp->inp_ip.ip_ttl;	/* XXX */
	((struct ip *)ui)->ip_tos = inp->inp_ip.ip_tos;	/* XXX */
	udpstat.udps_opackets++;
	error = ip_output(m, inp->inp_options, &inp->inp_route,
	    inp->inp_socket->so_options & (SO_DONTROUTE | SO_BROADCAST),
	    inp->inp_moptions);

	if (addr) {
		in_pcbdisconnect(inp);
		inp->inp_laddr = laddr;
	}
	return (error);

release:
	m_freem(m);
	return (error);
d404 2
a405 3
u_long	udp_sendspace = 9216;		/* really max datagram size */
u_long	udp_recvspace = 40 * (1024 + sizeof(struct sockaddr_in));
					/* 40 1K datagrams */
d408 1
a408 2
int
udp_usrreq(so, req, m, addr, control)
d411 1
a411 1
	struct mbuf *m, *addr, *control;
a415 4
#ifdef DEBUG2
        extern char *prurequests[];
        Printf("udp_usrreq(): so=%x, req=%s, m=%x, addr=%x, control=%x\n", so, prurequests[req], m, addr, control);
#endif
d417 6
a422 2
		return (in_control(so, (u_long)m, (caddr_t)addr,
			(struct ifnet *)control));
a426 4
	/*
	 * Note: need to block udp_input while changing
	 * the udp pcb queue and/or pcb addresses.
	 */
d434 1
a434 1
		error = in_pcballoc(so, &udbinfo);
a439 1
		((struct inpcb *) so->so_pcb)->inp_ip.ip_ttl = ip_defttl;
d443 1
a443 1
		udp_detach(inp);
d447 1
a447 1
		error = in_pcbbind(inp, addr);
d459 1
a459 1
		error = in_pcbconnect(inp, addr);
a477 1
		inp->inp_laddr.s_addr = INADDR_ANY;
d485 30
a514 2
	case PRU_SEND:
		return (udp_output(inp, m, addr, control));
d518 1
a518 1
		udp_detach(inp);
d522 1
a522 1
		in_setsockaddr(inp, addr);
d526 1
a526 1
		in_setpeeraddr(inp, addr);
a549 1

d551 7
a557 3
	if (control) {
		printf("udp control data unexpectedly retained\n");
		m_freem(control);
a558 2
	if (m)
	    m_freem(m);
d562 1
a562 40
static void
udp_detach(inp)
	struct inpcb *inp;
{
	in_pcbdetach(inp);
}

/*
 * Sysctl for udp variables.
 */
int
udp_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case UDPCTL_CHECKSUM:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &udpcksum));
	case UDPCTL_STATS:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &udpstat,
					sizeof udpstat));
	case UDPCTL_MAXDGRAM:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   (int *)&udp_sendspace)); /* XXX */
	case UDPCTL_RECVSPACE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   (int *)&udp_recvspace)); /* XXX */
	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
}
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@RCS log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d1 21
d23 2
a24 2
 * Copyright (c) 1982, 1986, 1988, 1990, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
d26 11
a36 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a37 14
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)udp_usrreq.c	8.6 (Berkeley) 5/23/95
 *	$Id: udp_usrreq.c,v 1.12.4.2 1995/10/07 20:20:58 davidg Exp $
d39 22
a60 30

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/stat.h>
#include <sys/queue.h>
#ifndef __riscos
#include <vm/vm.h>
#else
#include <sys/dcistructs.h>
#endif
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
a63 1
#include "module.h"
d69 2
a70 9
#ifndef __riscos
#ifndef	COMPAT_42
int	udpcksum = 1;
#else
int	udpcksum = 0;		/* XXX */
#endif
#else
int	udpcksum = 0;		/* XXX */
#endif
d72 2
a73 2
struct	inpcbhead udb;		/* from udp_var.h */
struct	inpcbinfo udbinfo;
d75 2
a76 3
#ifndef UDBHASHSIZE
#define UDBHASHSIZE 64
#endif
d78 1
a78 1
struct	udpstat udpstat;	/* from udp_var.h */
d80 3
a82 18
struct	sockaddr_in udp_in = { sizeof(udp_in), AF_INET };

static	void udp_detach(struct inpcb *);
static	void udp_notify(struct inpcb *, int);
static	struct mbuf *udp_saveopt(caddr_t, int, int);

void
udp_init()
{
	LIST_INIT(&udb);
	udbinfo.listhead = &udb;
	udbinfo.hashbase = phashinit(UDBHASHSIZE, M_PCB, &udbinfo.hashsize);
}

void
udp_input(m, iphlen, esrc)
	register struct mbuf *m;
	int iphlen;
d85 1
a85 2
	register struct ip *ip;
	register struct udphdr *uh;
d87 1
a87 1
	struct mbuf *opts = 0;
d89 1
a89 14
	struct ip save_ip;

	udpstat.udps_ipackets++;

	/*
	 * Strip IP options, if any; should skip this,
	 * make available to user, and use on returned packets,
	 * but we don't yet have a way to check the checksum
	 * with options still present.
	 */
	if (iphlen > sizeof (struct ip)) {
		ip_stripoptions(m, (struct mbuf *)0);
		iphlen = sizeof(struct ip);
	}
d93 1
d95 7
a101 7
	ip = mtod(m, struct ip *);
	if (m->m_len < iphlen + sizeof(struct udphdr)) {
		if ((m = PULLUP(m, iphlen + sizeof(struct udphdr))) == 0) {
			udpstat.udps_hdrops++;
			return;
		}
		ip = mtod(m, struct ip *);
a102 2
	uh = (struct udphdr *)((caddr_t)ip + iphlen);

d107 3
a109 3
	len = ntohs((u_short)uh->uh_ulen);
	if (ip->ip_len != len) {
		if (len > ip->ip_len || len < sizeof(struct udphdr)) {
d111 1
a111 1
			goto bad;
d113 6
a118 2
		TRIM(m, len - ip->ip_len, NULL);
		/* ip->ip_len = len; */
d121 1
a121 2
	 * Save a copy of the IP header in case we want restore it
	 * for sending an ICMP error message in response.
d123 1
a123 1
	save_ip = *ip;
d128 5
a132 7
	if (uh->uh_sum) {
		((struct ipovly *)ip)->ih_next = 0;
		((struct ipovly *)ip)->ih_prev = 0;
		((struct ipovly *)ip)->ih_x1 = 0;
		((struct ipovly *)ip)->ih_len = uh->uh_ulen;
		uh->uh_sum = in_cksum(m, len + sizeof (struct ip));
		if (uh->uh_sum) {
d134 1
d136 3
d144 1
a144 1
	if (DODEBUG(DBGUDP))
d147 2
a148 2
		   inet_ntoa(ip->ip_src), ntohs(uh->uh_sport));
	    Printf(", %s %x\n", inet_ntoa(ip->ip_dst), ntohs(uh->uh_dport));
a150 22
	if (IN_MULTICAST(ntohl(ip->ip_dst.s_addr)) ||
	    in_broadcast(ip->ip_dst, m->m_pkthdr.rcvif)) {
		struct socket *last;
#ifdef DEBUG
                if (DODEBUG(DBGUDP))
                        Printf("udp_input: it's a broadcast\n");
#endif
		/*
		 * Deliver a multicast or broadcast datagram to *all* sockets
		 * for which the local and remote addresses and ports match
		 * those of the incoming datagram.  This allows more than
		 * one process to receive multi/broadcasts on the same port.
		 * (This really ought to be done for unicast datagrams as
		 * well, but that would cause problems with existing
		 * applications that open both address-specific sockets and
		 * a wildcard socket listening to the same port -- they would
		 * end up receiving duplicates of every unicast datagram.
		 * Those applications open the multiple sockets to overcome an
		 * inadequacy of the UDP socket interface, but for backwards
		 * compatibility we avoid the problem here rather than
		 * fixing the interface.  Maybe 4.5BSD will remedy this?)
		 */
a151 87
		/*
		 * Construct sockaddr format source address.
		 */
		udp_in.sin_port = uh->uh_sport;
		udp_in.sin_addr = ip->ip_src;
		m->m_len -= sizeof (struct udpiphdr);
		m->m_off += sizeof (struct udpiphdr);
		/*
		 * Locate pcb(s) for datagram.
		 * (Algorithm copied from raw_intr().)
		 */
		last = NULL;
		for (inp = udb.lh_first; inp != NULL; inp = inp->inp_list.le_next) {
			if (inp->inp_lport != uh->uh_dport)
				continue;
			if (inp->inp_laddr.s_addr != INADDR_ANY) {
				if (inp->inp_laddr.s_addr !=
				    ip->ip_dst.s_addr)
					continue;
			}
			if (inp->inp_faddr.s_addr != INADDR_ANY) {
				if (inp->inp_faddr.s_addr !=
				    ip->ip_src.s_addr ||
				    inp->inp_fport != uh->uh_sport)
					continue;
			}

			if (last != NULL) {
				struct mbuf *n;

				if ((n = m_copy(m, 0, M_COPYALL)) != NULL) {
#ifdef __riscos
					if (sorxdirect(last,
					      n, (struct sockaddr *)&udp_in,
					      ip->ip_dst.s_addr,
	               			      esrc, n->m_pkthdr.rcvif->if_unit,
	               			      n->m_pkthdr.rcvif->if_swibase
	               			                   + DCI4Transmit))
	               				m_freem(n);
	               			else
#endif
					if (sbappendaddr(&last->so_rcv,
						(struct sockaddr *)&udp_in,
						n, (struct mbuf *)0) == 0) {
						m_freem(n);
						udpstat.udps_fullsock++;
					} else {
						sorwakeup(last);
					}
				}
			}
			last = inp->inp_socket;
			/*
			 * Don't look for additional matches if this one does
			 * not have either the SO_REUSEPORT or SO_REUSEADDR
			 * socket options set.  This heuristic avoids searching
			 * through all pcbs in the common case of a non-shared
			 * port.  It * assumes that an application will never
			 * clear these options after setting them.
			 */
			if ((last->so_options&(SO_REUSEPORT|SO_REUSEADDR) == 0))
				break;
		}

		if (last == NULL) {
			/*
			 * No matching pcb found; discard datagram.
			 * (No need to send an ICMP Port Unreachable
			 * for a broadcast or multicast datgram.)
			 */
			udpstat.udps_noportbcast++;
			goto bad;
		}
#ifdef __riscos
		if (sorxdirect(last, m, (struct sockaddr *)&udp_in, ip->ip_dst.s_addr,
	              esrc, m->m_pkthdr.rcvif->if_unit,
	              m->m_pkthdr.rcvif->if_swibase + DCI4Transmit))
	               	goto bad;
#endif
		if (sbappendaddr(&last->so_rcv, (struct sockaddr *)&udp_in,
		     m, (struct mbuf *)0) == 0) {
			udpstat.udps_fullsock++;
			goto bad;
		}
		sorwakeup(last);
		return;
	}
d153 1
a153 1
	 * Locate pcb for datagram. First look for an exact match.
d155 4
a158 10
	inp = in_pcblookuphash(&udbinfo, ip->ip_src, uh->uh_sport,
	    ip->ip_dst, uh->uh_dport);
	/*
	 * ...and if that fails, do a wildcard search.
	 */
	if (inp == NULL) {
		inp = in_pcblookup(&udb, ip->ip_src, uh->uh_sport, ip->ip_dst,
		    uh->uh_dport, INPLOOKUP_WILDCARD);
	}
	if (inp == NULL) {
d163 1
a163 2
#ifdef __riscos
		if (in_bootpresponse(ntohs(uh->uh_dport))) {
d167 2
a168 1
		    bootp_udp_input(m);
d170 3
d175 1
a175 9
#endif
		udpstat.udps_noport++;
		if (m->m_flags & (M_BCAST | M_MCAST)) {
			udpstat.udps_noportbcast++;
			goto bad;
		}
		*ip = save_ip;
		icmp_error(m, ICMP_UNREACH, ICMP_UNREACH_PORT, 0, 0);
		return;
d182 16
a197 35
	udp_in.sin_port = uh->uh_sport;
	udp_in.sin_addr = ip->ip_src;
	if (inp->inp_flags & INP_CONTROLOPTS) {
		struct mbuf **mp = &opts;

		if (inp->inp_flags & INP_RECVDSTADDR) {
			*mp = udp_saveopt((caddr_t) &ip->ip_dst,
			    sizeof(struct in_addr), IP_RECVDSTADDR);
			if (*mp)
				mp = &(*mp)->m_next;
		}
#ifdef notyet
		/* options were tossed above */
		if (inp->inp_flags & INP_RECVOPTS) {
			*mp = udp_saveopt((caddr_t) opts_deleted_above,
			    sizeof(struct in_addr), IP_RECVOPTS);
			if (*mp)
				mp = &(*mp)->m_next;
		}
		/* ip_srcroute doesn't do what we want here, need to fix */
		if (inp->inp_flags & INP_RECVRETOPTS) {
			*mp = udp_saveopt((caddr_t) ip_srcroute(),
			    sizeof(struct in_addr), IP_RECVRETOPTS);
			if (*mp)
				mp = &(*mp)->m_next;
		}
#endif
	}
	iphlen += sizeof(struct udphdr);
	m->m_len -= iphlen;
	m->m_pkthdr.len -= iphlen;
	m->m_off += iphlen;
	if (sorxdirect(inp->inp_socket, m, (struct sockaddr *) &udp_in,
	               ip->ip_dst.s_addr, esrc, m->m_pkthdr.rcvif->if_unit,
	               m->m_pkthdr.rcvif->if_swibase + DCI4Transmit)) {
d199 2
a200 2
	        if( DODEBUG(DBGUDP) )
		    Printf("udp_ip: rxdirect\n");
d202 2
a203 1
	        goto bad;
d206 2
a207 1
	    m, opts) == 0) {
d209 1
a209 1
	        Printf("udp_ip: sbappendaddr failed\n");
d211 1
a211 2
		udpstat.udps_fullsock++;
		goto bad;
d215 2
a216 1
bad:
d218 3
a220 2
	if (opts)
		m_freem(opts);
a222 26
/*
 * Create a "control" mbuf containing the specified data
 * with the specified type for presentation with a datagram.
 */
static struct mbuf *
udp_saveopt(p, size, type)
	caddr_t p;
	register int size;
	int type;
{
	register struct cmsghdr *cp;
	struct mbuf *m;

	if ((m = m_get(M_DONTWAIT, MT_CONTROL)) == NULL)
		return ((struct mbuf *) NULL);
	cp = (struct cmsghdr *) mtod(m, struct cmsghdr *);
	(void)memcpy(CMSG_DATA(cp), p, size);
	size += sizeof(*cp);
	m->m_len = size;
	cp->cmsg_len = size;
	cp->cmsg_level = IPPROTO_IP;
	cp->cmsg_type = type;
	return (m);
}

#ifdef QuickMNSAcks
d225 3
a227 3
	struct mbuf *m0;
	struct sockaddr_in *sin;
	struct in_addr laddr;
d243 2
a244 1
	MGETHDR(m, M_DONTWAIT, MT_DATA);
d247 10
a256 1
	MH_ALIGN(m, sizeof (struct udpiphdr) + len);
d258 4
a261 2
	m->m_pkthdr.rcvif = (struct ifnet *) 0;
	m->m_pkthdr.len = m->m_len = sizeof (struct udpiphdr) + len;
d274 1
a274 1
	((struct ip *)ui)->ip_ttl = ip_defttl;
a286 3

        ip->ip_sum = in_cksum(m, hlen);

a288 1
#endif
d294 1
a294 2
static void
udp_notify(inp, errno)
a295 1
	int errno;
d297 1
a297 1
	inp->inp_socket->so_error = errno;
d302 1
a302 2
void
udp_ctlinput(cmd, sa, vip)
a304 1
	void *vip;
d306 3
a308 2
	register struct ip *ip = vip;
	register struct udphdr *uh;
d310 3
a312 2
	if (!PRC_IS_REDIRECT(cmd) &&
	    ((unsigned)cmd >= PRC_NCMDS || inetctlerrmap[cmd] == 0))
d314 23
a336 6
	if (ip) {
		uh = (struct udphdr *)((caddr_t)ip + (ip->ip_hl << 2));
		in_pcbnotify(&udb, sa, uh->uh_dport, ip->ip_src, uh->uh_sport,
			cmd, udp_notify);
	} else
		in_pcbnotify(&udb, sa, 0, zeroin_addr, 0, cmd, udp_notify);
d339 1
a339 2
int
udp_output(inp, m, addr, control)
d341 2
a343 2
	struct mbuf *addr, *control;
{
d345 1
a345 16
	register int len = m->m_pkthdr.len;
	struct in_addr laddr;
	int error = 0;

#ifdef DEBUG
    {
        struct mbuf *m1;
        Printf("\0x11\0x03udp_output(): inp = %x, m = %x, addr = %x, control = %x\n",
                inp, m, addr, control);
	for( m1 = m; m1; m1 = m1->m_next )
	    Printf("%x(%d, %d)-->", m1, m1->m_type, m1->m_len);
	Printf("(NULL)\021\007\n");
    }
#endif
	if (control)
		m_freem(control);		/* XXX */
a346 19
	if (addr) {
		laddr = inp->inp_laddr;
		if (inp->inp_faddr.s_addr != INADDR_ANY) {
			error = EISCONN;
			goto release;
		}
		/*
		 * Must block input while temporarily connected.
		 */
		error = in_pcbconnect(inp, addr);
		if (error)
			goto release;
	} else {
                (void) &laddr; /* Shut up compiler -fa */
		if (inp->inp_faddr.s_addr == INADDR_ANY) {
			error = ENOTCONN;
			goto release;
		}
	}
d351 4
a354 1
	M_PREPEND(m, sizeof(struct udpiphdr), M_DONTWAIT);
d356 6
d363 2
a364 2
		if (DODEBUG(DBGMMAN))
			Printf("udp_output: ALLOC_S failed\n");
d366 2
a367 10
		error = ENOBUFS;
		/*
		 * KJB fix - this probably never happens in Unix, but it
		 * can happen with our excellent Mbuf Manager...
		 */
		if (addr) {
			in_pcbdisconnect(inp);
			inp->inp_laddr = laddr;
		}
		goto release;
d369 2
d376 3
d399 3
a401 16
	((struct ip *)ui)->ip_ttl = inp->inp_ip.ip_ttl;	/* XXX */
	((struct ip *)ui)->ip_tos = inp->inp_ip.ip_tos;	/* XXX */
	udpstat.udps_opackets++;
	error = ip_output(m, inp->inp_options, &inp->inp_route,
	    inp->inp_socket->so_options & (SO_DONTROUTE | SO_BROADCAST),
	    inp->inp_moptions);

	if (addr) {
		in_pcbdisconnect(inp);
		inp->inp_laddr = laddr;
	}
	return (error);

release:
	m_freem(m);
	return (error);
d404 2
a405 3
u_long	udp_sendspace = 9216;		/* really max datagram size */
u_long	udp_recvspace = 40 * (1024 + sizeof(struct sockaddr_in));
					/* 40 1K datagrams */
d408 1
a408 2
int
udp_usrreq(so, req, m, addr, control)
d411 1
a411 1
	struct mbuf *m, *addr, *control;
a415 4
#ifdef DEBUG2
        extern char *prurequests[];
        Printf("udp_usrreq(): so=%x, req=%s, m=%x, addr=%x, control=%x\n", so, prurequests[req], m, addr, control);
#endif
d417 6
a422 2
		return (in_control(so, (u_long)m, (caddr_t)addr,
			(struct ifnet *)control));
a426 4
	/*
	 * Note: need to block udp_input while changing
	 * the udp pcb queue and/or pcb addresses.
	 */
d434 1
a434 1
		error = in_pcballoc(so, &udbinfo);
a439 1
		((struct inpcb *) so->so_pcb)->inp_ip.ip_ttl = ip_defttl;
d443 1
a443 1
		udp_detach(inp);
d447 1
a447 1
		error = in_pcbbind(inp, addr);
d459 1
a459 1
		error = in_pcbconnect(inp, addr);
a477 1
		inp->inp_laddr.s_addr = INADDR_ANY;
d485 30
a514 2
	case PRU_SEND:
		return (udp_output(inp, m, addr, control));
d518 1
a518 1
		udp_detach(inp);
d522 1
a522 1
		in_setsockaddr(inp, addr);
d526 1
a526 1
		in_setpeeraddr(inp, addr);
a549 1

d551 7
a557 3
	if (control) {
		printf("udp control data unexpectedly retained\n");
		m_freem(control);
a558 2
	if (m)
	    m_freem(m);
d562 1
a562 40
static void
udp_detach(inp)
	struct inpcb *inp;
{
	in_pcbdetach(inp);
}

/*
 * Sysctl for udp variables.
 */
int
udp_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case UDPCTL_CHECKSUM:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &udpcksum));
	case UDPCTL_STATS:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &udpstat,
					sizeof udpstat));
	case UDPCTL_MAXDGRAM:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   (int *)&udp_sendspace)); /* XXX */
	case UDPCTL_RECVSPACE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   (int *)&udp_recvspace)); /* XXX */
	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
}
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@

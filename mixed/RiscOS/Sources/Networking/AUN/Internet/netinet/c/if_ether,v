head	4.8;
access;
symbols
	Internet-5_65:4.8
	Internet-5_64:4.8
	Internet-5_63:4.8
	Internet-5_62:4.8
	Internet-5_61:4.8
	Internet-5_60:4.8
	Internet-5_59:4.8
	Internet-5_58:4.8
	Internet-5_57:4.8
	Internet-5_56:4.8
	Internet-5_55:4.8
	Internet-5_54:4.8
	Internet-5_53:4.8
	Internet-5_52:4.8
	Internet-5_51:4.8
	Internet-5_50:4.8
	RO_5_07:4.8
	Internet-5_49:4.8
	Internet-5_48:4.8
	Internet-5_47:4.8
	Internet-5_46:4.8
	Internet-5_45:4.8
	Internet-5_44:4.8
	Internet-5_43:4.8
	Internet-5_42:4.8
	Internet-5_41:4.8
	Internet-5_40:4.8
	Internet-5_39:4.8
	Internet-5_38:4.8
	Internet-5_37:4.8
	Internet-5_36:4.8
	Internet-5_35:4.8
	Internet-5_34:4.8
	Internet-5_33:4.8
	Internet-5_32:4.7
	Internet-5_31:4.7
	Internet-5_30:4.7
	Internet-5_29:4.6
	Internet-5_27:4.5
	Internet-5_26:4.4
	Internet-5_25:4.3
	Internet-5_24:4.3
	Internet-5_23:4.3
	Internet-5_22:4.3
	Internet-5_21:4.3
	Internet-5_20:4.3
	Internet-5_19:4.3
	Internet-5_18:4.3
	Internet-5_17:4.3
	Internet-5_16:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3
	Ursula_RiscPC:4.3.0.4
	Internet-5_15:4.3
	Internet-5_14:4.3
	Internet-5_13:4.3
	sforrest_daytona_appflash-0_31:4.3
	Internet-5_12:4.3
	Internet-5_11:4.3
	celkins_Internet-5_10:4.3
	nicke_Internat_25-9-98:4.3
	Internet-5_09:4.3
	blaughto_daytona_appflash-0_30:4.3
	rthornb_UrsulaBuild-19Aug1998:4.3
	UrsulaBuild_FinalSoftload:4.3
	rthornb_UrsulaBuild-12Aug1998:4.3
	aglover_UrsulaBuild-05Aug1998:4.3
	rthornb_UrsulaBuild-29Jul1998:4.3
	rthornb_UrsulaBuild-22Jul1998:4.3
	rwarren_Internet-5_08:4.3
	Spinner:4.3
	Internet_5_07:4.3
	rthornb_UrsulaBuild-15Jul1998:4.3
	rthornb_UrsulaBuild-07Jul1998:4.3
	rthornb_UrsulaBuild-17Jun1998:4.3
	rthornb_UrsulaBuild-03Jun1998:4.3
	rthornb_UrsulaBuild-27May1998:4.3
	rthornb_UrsulaBuild-21May1998:4.3
	Ursula_bp:4.3
	Ursula:4.3.0.2
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.3
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.3
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	99.07.22.08.37.27;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	99.07.08.16.36.54;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.07.08.15.25.33;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.06.30.13.15.32;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.06.25.13.40.11;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.03.24.17.02.28;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.58.40;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.07;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.07;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.19.54;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.27.36;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.06.38;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.13;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.06.32;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.27;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.38.17;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.15;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.8
log
@* Used to send fragmented multicasts to the wrong link-level address. This
  is fixed by MbufManager 0.23, but a work-around has been incorporated
  into the Internet module.
* Ability to debug using PDebug instead of TML added.
* Various compilation hiccoughs when DEBUG defined fixed.

Version 5.33. Tagged as 'Internet-5_33'
@
text
@/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * Ethernet address resolution protocol.
 * TODO:
 *	add "inuse/lock" bit (or ref. count) along with valid bit
 */

#include "kernel.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/route.h>
#include <net/netisr.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>

#include <string.h>

#include "debug.h"
#include "module.h"
#include "swiveneers.h"

#define SIN(s) ((struct sockaddr_in *)s)
#define SDL(s) ((struct sockaddr_dl *)s)
#define SRP(s) ((struct sockaddr_inarp *)s)

/*
 * ARP trailer negotiation.  Trailer protocol is not IP specific,
 * but ARP request/response use IP addresses.
 */
#define ETHERTYPE_IPTRAILERS ETHERTYPE_TRAIL


/* timer values */
int	arpt_prune = (5*60*1);	/* walk list every 5 minutes */
int	arpt_keep = (20*60);	/* once resolved, good for 20 more minutes */
int	arpt_down = 20;		/* once declared down, don't send for 20 secs */
#define	rt_expire rt_rmx.rmx_expire

struct llinfo_arp {
	struct	llinfo_arp *la_next;
	struct	llinfo_arp *la_prev;
	struct	rtentry *la_rt;
	struct	mbuf *la_hold;		/* last packet until resolved/timeout */
	long	la_asked;		/* last time we QUERIED for this addr */
#define la_timer la_rt->rt_rmx.rmx_expire /* deletion time in seconds */
};

static	void arprequest(struct arpcom *, struct in_addr *, struct in_addr *, u_char *);
static	void arptfree(struct llinfo_arp *);
static	void arptimer(void *);
static	struct llinfo_arp *arplookup(u_long, int, int);
static	void in_arpinput(struct mbuf *);
#ifdef __riscos
static	void broadcastarpreply(void *p);
#endif

#ifdef __riscos
struct	llinfo_arp llinfo_arp;
#else
struct	llinfo_arp llinfo_arp = {&llinfo_arp, &llinfo_arp};
#endif
struct	ifqueue arpintrq = {0, 0, 0, 50};
int	arp_inuse, arp_allocated, arp_intimer;
int	arp_maxtries = 5;
int	useloopback = 1;	/* use loopback interface for local traffic */
int	arpinit_done = 0;

#ifdef	ARP_PROXYALL
int	arp_proxyall = 1;
#endif

#ifdef __riscos
void arp_init()
{
	llinfo_arp.la_next = llinfo_arp.la_prev = &llinfo_arp;
}
#endif

/*
 * Timeout routine.  Age arp_tab entries periodically.
 */
/* ARGSUSED */
static void
arptimer(ignored_arg)
	void *ignored_arg;
{
	register struct llinfo_arp *la = llinfo_arp.la_next;

	timeout(arptimer, (caddr_t)0, arpt_prune * hz);
	while (la != &llinfo_arp) {
		register struct rtentry *rt = la->la_rt;
		la = la->la_next;
		if (rt->rt_expire && rt->rt_expire <= time.tv_sec)
			arptfree(la->la_prev); /* timer has expired, clear */
	}
}

/*
 * Parallel to llc_rtrequest.
 */
static void
arp_rtrequest(req, rt, sa)
	int req;
	register struct rtentry *rt;
	struct sockaddr *sa;
{
	register struct sockaddr *gate = rt->rt_gateway;
	register struct llinfo_arp *la = (struct llinfo_arp *)rt->rt_llinfo;
	static struct sockaddr_dl null_sdl = {sizeof(null_sdl), AF_LINK};

	if (!arpinit_done) {
		arpinit_done = 1;
		timeout(arptimer, (caddr_t)0, hz);
	}
	if (rt->rt_flags & RTF_GATEWAY)
		return;
	switch (req) {

	case RTM_ADD:
		/*
		 * XXX: If this is a manually added route to interface
		 * such as older version of routed or gated might provide,
		 * restore cloning bit.
		 */
		if ((rt->rt_flags & RTF_HOST) == 0 &&
		    SIN(rt_mask(rt))->sin_addr.s_addr != 0xffffffff)
			rt->rt_flags |= RTF_CLONING;
		if (rt->rt_flags & RTF_CLONING) {
			/*
			 * Case 1: This route should come from a route to iface.
			 */
			rt_setgate(rt, rt_key(rt),
					(struct sockaddr *)&null_sdl);
			gate = rt->rt_gateway;
			SDL(gate)->sdl_type = rt->rt_ifp->if_type;
			SDL(gate)->sdl_index = rt->rt_ifp->if_index;
			rt->rt_expire = time.tv_sec;
			break;
		}
		/* Announce a new entry if requested. */
		if (rt->rt_flags & RTF_ANNOUNCE)
			arprequest((struct arpcom *)rt->rt_ifp,
			    &SIN(rt_key(rt))->sin_addr,
			    &SIN(rt_key(rt))->sin_addr,
			    (u_char *)LLADDR(SDL(gate)));
		/*FALLTHROUGH*/
	case RTM_RESOLVE:
		if (gate->sa_family != AF_LINK ||
		    gate->sa_len < sizeof(null_sdl)) {
			log(LOG_DEBUG, "arp_rtrequest: bad gateway value\n");
			break;
		}
		SDL(gate)->sdl_type = rt->rt_ifp->if_type;
		SDL(gate)->sdl_index = rt->rt_ifp->if_index;
		if (la != 0)
			break; /* This happens on a route change */
		/*
		 * Case 2:  This route may come from cloning, or a manual route
		 * add with a LL address.
		 */
		R_Malloc(la, struct llinfo_arp *, sizeof(*la));
		rt->rt_llinfo = (caddr_t)la;
		if (la == 0) {
			log(LOG_DEBUG, "arp_rtrequest: malloc failed\n");
			break;
		}
		arp_inuse++, arp_allocated++;
		Bzero(la, sizeof(*la));
		la->la_rt = rt;
		rt->rt_flags |= RTF_LLINFO;
		insque(la, &llinfo_arp);
		if (SIN(rt_key(rt))->sin_addr.s_addr ==
		    (IA_SIN(rt->rt_ifa))->sin_addr.s_addr) {
		    /*
		     * This test used to be
		     *	if (loif.if_flags & IFF_UP)
		     * It allowed local traffic to be forced
		     * through the hardware by configuring the loopback down.
		     * However, it causes problems during network configuration
		     * for boards that can't receive packets they send.
		     * It is now necessary to clear "useloopback" and remove
		     * the route to force traffic out to the hardware.
		     */
			rt->rt_expire = 0;
			Bcopy(((struct arpcom *)rt->rt_ifp)->ac_enaddr,
				LLADDR(SDL(gate)), SDL(gate)->sdl_alen = 6);
			if (useloopback)
				rt->rt_ifp = loif;
		}
		break;

	case RTM_DELETE:
		if (la == 0)
			break;
		arp_inuse--;
		remque(la);
		rt->rt_llinfo = 0;
		rt->rt_flags &= ~RTF_LLINFO;
		if (la->la_hold)
			m_freem(la->la_hold);
		Free((caddr_t)la);
	}
}

/*
 * Broadcast an ARP request. Caller specifies:
 *	- arp header source ip address
 *	- arp header target ip address
 *	- arp header source ethernet address
 */
static void
arprequest(ac, sip, tip, enaddr)
	register struct arpcom *ac;
	register struct in_addr *sip, *tip;
	register u_char *enaddr;
{
	register struct mbuf *m;
	register struct ether_header *eh;
	register struct ether_arp *ea;
	struct sockaddr sa;

	if ((m = m_gethdr(M_DONTWAIT, MT_DATA)) == NULL)
		return;
	m->m_len = sizeof *ea;
	m->m_pkthdr.len = sizeof(*ea);
	MH_ALIGN(m, sizeof(*ea));
	ea = mtod(m, struct ether_arp *);
	eh = (struct ether_header *)sa.sa_data;
	bzero((caddr_t)ea, sizeof (*ea));
	(void)memcpy(eh->ether_dhost, etherbroadcastaddr, sizeof(eh->ether_dhost));
	eh->ether_type = ETHERTYPE_ARP;		/* if_output will swap */
	ea->arp_hrd = htons(ARPHRD_ETHER);
	ea->arp_pro = htons(ETHERTYPE_IP);
	ea->arp_hln = sizeof(ea->arp_sha);	/* hardware address length */
	ea->arp_pln = sizeof(ea->arp_spa);	/* protocol address length */
	ea->arp_op = htons(ARPOP_REQUEST);
	(void)memcpy(ea->arp_sha, enaddr, sizeof(ea->arp_sha));
	(void)memcpy(ea->arp_spa, sip, sizeof(ea->arp_spa));
	(void)memcpy(ea->arp_tpa, tip, sizeof(ea->arp_tpa));
	sa.sa_family = AF_UNSPEC;
	sa.sa_len = sizeof(sa);
	(*ac->ac_if.if_output)(&ac->ac_if, m, &sa, (struct rtentry *)0);
}

/* TRACE */
#define ANY_UNSAFE(x) ((MBCTL.any_unsafe)(&MBCTL,(x)))

#ifdef __riscos
/*
 * Return the host portion of an internet address.
 */
u_long
in_lnaof(in)
	struct in_addr in;
{
	register u_long i = ntohl(in.s_addr);
	register u_long net, host;
	register struct in_ifaddr *ia;

	if (IN_CLASSA(i)) {
		net = i & IN_CLASSA_NET;
		host = i & IN_CLASSA_HOST;
	} else if (IN_CLASSB(i)) {
		net = i & IN_CLASSB_NET;
		host = i & IN_CLASSB_HOST;
	} else if (IN_CLASSC(i)) {
		net = i & IN_CLASSC_NET;
		host = i & IN_CLASSC_HOST;
	} else
		return (i);

	/*
	 * Check whether network is a subnet;
	 * if so, use the modified interpretation of `host'.
	 */
	for (ia = in_ifaddr; ia; ia = ia->ia_next)
		if (net == ia->ia_net)
			return (host &~ ia->ia_subnetmask);
	return (host);
}
#endif

/*
 * Resolve an IP address into an ethernet address.  If success,
 * desten is filled in.  If there is no entry in arptab,
 * set one up and broadcast a request for the IP address.
 * Hold onto this mbuf and resend it once the address
 * is finally resolved.  A return value of 1 indicates
 * that desten has been filled in and the packet should be sent
 * normally; a 0 return indicates that the packet has been
 * taken over here, either now or for later transmission.
 */
int
arpresolve(ac, rt, m, dst, desten, rt0)
	register struct arpcom *ac;
	register struct rtentry *rt;
	struct mbuf *m;
	register struct sockaddr *dst;
	register u_char *desten;
	struct rtentry *rt0;
{
	register struct llinfo_arp *la;
	struct sockaddr_dl *sdl;

	if (m->m_flags & M_BCAST) {	/* broadcast address */
		(void)memcpy(desten, etherbroadcastaddr, sizeof(etherbroadcastaddr));
		return (1);
	}
#ifdef MULTICAST
	if (m->m_flags & M_MCAST) {	/* multicast */
		ETHER_MAP_IP_MULTICAST(&SIN(dst)->sin_addr, desten);
		return(1);
	}
#else
	/* Can't transmit multicast! */
	if (m->m_flags & M_MCAST)
#ifdef __riscos
	{
		struct mbuf *m0 = m;
		while (m0)
		{
			m = m0;
			m0 = m0->m_list;
			m_freem(m);
		}
		return (0);
	}
#else
		return (0);
#endif /* __riscos */
#endif /* MULTICAST */
#ifdef __riscos
	if (ac->ac_if.if_flags & IFF_NOARP) {
		u_long lna = in_lnaof(SIN(dst)->sin_addr);
		memcpy(desten, ac->ac_enaddr, 3);
		desten[3] = (lna >> 16) & 0x7f;
		desten[4] = (lna >> 8) & 0xff;
		desten[5] = lna & 0xff;
		return (1);
	}
#endif
	if (rt)
		la = (struct llinfo_arp *)rt->rt_llinfo;
	else {
		la = arplookup(SIN(dst)->sin_addr.s_addr, 1, 0);
		if (la)
			rt = la->la_rt;
	}
	if (la == 0 || rt == 0) {
#ifdef __riscos
		struct mbuf *m0 = m;
#ifdef DEBUG
		Printf("arpresolve: can't allocate llinfo for %s\n",
			inet_ntoa(SIN(dst)->sin_addr));
#endif
		while (m0)
		{
			m = m0;
			m0 = m0->m_list;
			m_freem(m);
		}
		return (0);
#else
		m_freem(m);
		return (0);
#endif /* __riscos */
	}
	sdl = SDL(rt->rt_gateway);
	/*
	 * Check the address family and length is valid, the address
	 * is resolved; otherwise, try to resolve.
	 */
	if ((rt->rt_expire == 0 || rt->rt_expire > time.tv_sec) &&
	    sdl->sdl_family == AF_LINK && sdl->sdl_alen != 0) {
		(void)memcpy(desten, LLADDR(sdl), sdl->sdl_alen);
		return 1;
	}
	/*
	 * There is an arptab entry, but no ethernet address
	 * response yet.  Replace the held mbuf with this
	 * latest one.
	 */
	if (la->la_hold)
		m_freem(la->la_hold);
#ifdef __riscos
	/*
	 * We may be passed a list (blurgh). We simulate what
	 * the original code would do. Drop all except the last
	 * packet.
	 */
	while (m && m->m_list)
	{
	    struct mbuf *next = m->m_list;
	    m_freem(m);
	    m = next;
	}
#endif
	la->la_hold = ENSURE_SAFE(m);   /* Necessary because of UDP hack */
	if (rt->rt_expire) {
		rt->rt_flags &= ~RTF_REJECT;
		if (la->la_asked == 0 || rt->rt_expire != time.tv_sec) {
			rt->rt_expire = time.tv_sec;
			if (la->la_asked++ < arp_maxtries)
			    arprequest(ac,
			        &SIN(rt->rt_ifa->ifa_addr)->sin_addr,
				&SIN(dst)->sin_addr, ac->ac_enaddr);
			else {
				rt->rt_flags |= RTF_REJECT;
				rt->rt_expire += arpt_down;
				la->la_asked = 0;
			}

		}
	}
	return (0);
}

/*
 * Common length and type checks are done here,
 * then the protocol-specific routine is called.
 */
void
arpintr(void)
{
	register struct mbuf *m;
	register struct arphdr *ar;
	int s;

	while (arpintrq.ifq_head) {
		s = splimp();
		IF_DEQUEUE(&arpintrq, m);
		splx(s);
		if (m == 0 || (m->m_flags & M_PKTHDR) == 0) {
			panic("arpintr");
			return;
		}
		if (m->m_len >= sizeof(struct arphdr) &&
		    (ar = mtod(m, struct arphdr *)) &&
		    ntohs(ar->ar_hrd) == ARPHRD_ETHER &&
		    m->m_len >=
		      sizeof(struct arphdr) + 2 * ar->ar_hln + 2 * ar->ar_pln)

			    switch (ntohs(ar->ar_pro)) {

			    case ETHERTYPE_IP:
			    case ETHERTYPE_IPTRAILERS:
				    in_arpinput(m);
				    continue;
			    }
		m_freem(m);
	}
}

/*
 * ARP for Internet protocols on 10 Mb/s Ethernet.
 * Algorithm is that given in RFC 826.
 * In addition, a sanity check is performed on the sender
 * protocol address, to catch impersonators.
 * We no longer handle negotiations for use of trailer protocol:
 * Formerly, ARP replied for protocol type ETHERTYPE_TRAIL sent
 * along with IP replies if we wanted trailers sent to us,
 * and also sent them in response to IP replies.
 * This allowed either end to announce the desire to receive
 * trailer packets.
 * We no longer reply to requests for ETHERTYPE_TRAIL protocol either,
 * but formerly didn't normally send requests.
 */
static void
in_arpinput(m)
	struct mbuf *m;
{
	register struct ether_arp *ea;
	register struct arpcom *ac = (struct arpcom *)m->m_pkthdr.rcvif;
	struct ether_header *eh;
	register struct llinfo_arp *la = 0;
	register struct rtentry *rt;
	struct in_ifaddr *ia, *maybe_ia = 0;
	struct sockaddr_dl *sdl;
	struct sockaddr sa;
	struct in_addr isaddr, itaddr, myaddr;
	int op;

	ea = mtod(m, struct ether_arp *);
	op = ntohs(ea->arp_op);
	(void)memcpy(&isaddr, ea->arp_spa, sizeof (isaddr));
	(void)memcpy(&itaddr, ea->arp_tpa, sizeof (itaddr));

#ifdef DEBUG
	if (DODEBUG(DBGARP)) {
	    Printf("in_arpinput: sha %s, spa %s",
		   ether_sprintf(ea->arp_sha),
		   inet_ntoa(isaddr));
	    Printf(", tpa %s\n", inet_ntoa(itaddr));
	}
#endif

	for (ia = in_ifaddr; ia; ia = ia->ia_next)
		if (ia->ia_ifp == &ac->ac_if) {
			maybe_ia = ia;
			if ((itaddr.s_addr == ia->ia_addr.sin_addr.s_addr) ||
			     (isaddr.s_addr == ia->ia_addr.sin_addr.s_addr))
				break;
		}
	if (maybe_ia == 0)
		goto out;
	myaddr = ia ? ia->ia_addr.sin_addr : maybe_ia->ia_addr.sin_addr;
	if (!bcmp((caddr_t)ea->arp_sha, (caddr_t)ac->ac_enaddr,
		  sizeof (ea->arp_sha)))
		goto out;	/* it's from me, ignore it. */
	if (!bcmp((caddr_t)ea->arp_sha, (caddr_t)etherbroadcastaddr,
	    sizeof (ea->arp_sha))) {
#ifdef DEBUG
		Printf("arp: ether address is broadcast for IP address %s!\n",
		       inet_ntoa(isaddr));
#endif
		goto out;
	}
	if (isaddr.s_addr == myaddr.s_addr) {
#ifdef __riscos
		char buffer[80];
		untimeout(broadcastarpreply, ia);
		if (service_internetstatus_duplicate_ip_address(
		      ac->ac_if.if_name, ac->ac_if.if_dib, isaddr, ea->arp_sha)) {
			sprintf(buffer,
			  "Duplicate IP address %s! sent from ethernet address: %s",
			  inet_ntoa(isaddr), ether_sprintf(ea->arp_sha));
			panic(buffer);
		}
#else
		log(LOG_ERR,
		    "duplicate IP address %s! sent from ethernet address: %s\n",
		    inet_ntoa(isaddr), ether_sprintf(ea->arp_sha));
#endif
		itaddr = myaddr;
		if (op == ARPOP_REQUEST)
			goto reply;
		goto out;
	}
	la = arplookup(isaddr.s_addr, itaddr.s_addr == myaddr.s_addr, 0);
	if (la && (rt = la->la_rt) && (sdl = SDL(rt->rt_gateway))) {
#ifdef DEBUG
		if (sdl->sdl_alen &&
		    bcmp((caddr_t)ea->arp_sha, LLADDR(sdl), sdl->sdl_alen))
			Printf("arp info overwritten for %s by %s\n",
			    inet_ntoa(isaddr), ether_sprintf(ea->arp_sha));
#endif
		(void)memcpy(LLADDR(sdl), ea->arp_sha, sizeof(ea->arp_sha));
		sdl->sdl_alen = sizeof(ea->arp_sha);
		if (rt->rt_expire)
			rt->rt_expire = time.tv_sec + arpt_keep;
		rt->rt_flags &= ~RTF_REJECT;
		la->la_asked = 0;
		if (la->la_hold) {
			(*ac->ac_if.if_output)(&ac->ac_if, la->la_hold,
				rt_key(rt), rt);
			la->la_hold = 0;
		}
	}
reply:
#ifdef __riscos
	/* Don't respond to ARP requests if not actually up! */
	if (ac->ac_if.if_flags & IFF_NEED_IPADDR)
		goto out;
#endif
	if (op != ARPOP_REQUEST) {
	out:
		m_freem(m);
		return;
	}
	if (itaddr.s_addr == myaddr.s_addr) {
		/* I am the target */
		(void)memcpy(ea->arp_tha, ea->arp_sha, sizeof(ea->arp_sha));
		(void)memcpy(ea->arp_sha, ac->ac_enaddr, sizeof(ea->arp_sha));
	} else {
		la = arplookup(itaddr.s_addr, 0, SIN_PROXY);
		if (la == NULL) {
#ifdef ARP_PROXYALL
			struct sockaddr_in sin;

			if(!arp_proxyall) goto out;

			bzero(&sin, sizeof sin);
			sin.sin_family = AF_INET;
			sin.sin_len = sizeof sin;
			sin.sin_addr = itaddr;

			rt = rtalloc1((struct sockaddr *)&sin, 0, 0UL);
			if( !rt )
				goto out;
			/*
			 * Don't send proxies for nodes on the same interface
			 * as this one came out of, or we'll get into a fight
			 * over who claims what Ether address.
			 */
			if(rt->rt_ifp == &ac->ac_if) {
				rtfree(rt);
				goto out;
			}
			(void)memcpy(ea->arp_tha, ea->arp_sha, sizeof(ea->arp_sha));
			(void)memcpy(ea->arp_sha, ac->ac_enaddr, sizeof(ea->arp_sha));
			rtfree(rt);
#ifdef DEBUG_PROXY
			printf("arp: proxying for %s\n",
			       inet_ntoa(itaddr));
#endif
#else
			goto out;
#endif
		} else {
			rt = la->la_rt;
			(void)memcpy(ea->arp_tha, ea->arp_sha, sizeof(ea->arp_sha));
			sdl = SDL(rt->rt_gateway);
			(void)memcpy(ea->arp_sha, LLADDR(sdl), sizeof(ea->arp_sha));
		}
	}

	(void)memcpy(ea->arp_tpa, ea->arp_spa, sizeof(ea->arp_spa));
	(void)memcpy(ea->arp_spa, &itaddr, sizeof(ea->arp_spa));
	ea->arp_op = htons(ARPOP_REPLY);
	ea->arp_pro = htons(ETHERTYPE_IP); /* let's be sure! */
	eh = (struct ether_header *)sa.sa_data;
	(void)memcpy(eh->ether_dhost, ea->arp_tha, sizeof(eh->ether_dhost));
	eh->ether_type = ETHERTYPE_ARP;
	sa.sa_family = AF_UNSPEC;
	sa.sa_len = sizeof(sa);
	(*ac->ac_if.if_output)(&ac->ac_if, m, &sa, (struct rtentry *)0);
	return;
}

/*
 * Free an arptab entry.
 */
static void
arptfree(la)
	register struct llinfo_arp *la;
{
	register struct rtentry *rt = la->la_rt;
	register struct sockaddr_dl *sdl;
	if (rt == 0) {
		panic("arptfree");
		return;
	}
	if (rt->rt_refcnt > 0 && (sdl = SDL(rt->rt_gateway)) &&
	    sdl->sdl_family == AF_LINK) {
		sdl->sdl_alen = 0;
		la->la_asked = 0;
		rt->rt_flags &= ~RTF_REJECT;
		return;
	}
	rtrequest(RTM_DELETE, rt_key(rt), (struct sockaddr *)0, rt_mask(rt),
			0, (struct rtentry **)0);
}
/*
 * Lookup or enter a new address in arptab.
 */
static struct llinfo_arp *
arplookup(addr, create, proxy)
	u_long addr;
	int create, proxy;
{
	register struct rtentry *rt;
	static struct sockaddr_inarp sin = {sizeof(sin), AF_INET };
	const char *why = 0;

	sin.sin_addr.s_addr = addr;
	sin.sin_other = proxy ? SIN_PROXY : 0;
	rt = rtalloc1((struct sockaddr *)&sin, create, 0UL);
	if (rt == 0)
		return (0);
	rt->rt_refcnt--;

	if(rt->rt_flags & RTF_GATEWAY)
		why = "host is not on local network";
	else if((rt->rt_flags & RTF_LLINFO) == 0)
		why = "could not allocate llinfo";
	else if(rt->rt_gateway->sa_family != AF_LINK)
		why = "gateway route is not ours";

	if(why && create) {
#ifdef DEBUG
		Printf("arplookup %s failed: %s\n",
		    inet_ntoa(sin.sin_addr), why);
#endif
		return 0;
	} else if(why) {
		return 0;
	}
	return ((struct llinfo_arp *)rt->rt_llinfo);
}

int
arpioctl(cmd, data)
	int cmd;
	caddr_t data;
{
	return (EOPNOTSUPP);
}

void
arp_ifinit(ac, ifa)
	struct arpcom *ac;
	struct ifaddr *ifa;
{
	if (ntohl(IA_SIN(ifa)->sin_addr.s_addr) != INADDR_ANY) {
#ifdef __riscos
	if (ac->ac_if.if_flags & IFF_NEED_IPADDR) {
		/* Initial tentative probe with source IP set to 0 - as
		 * recommended in DHCP spec. */
		 struct in_addr sip = { 0 };
		 arprequest(ac, &sip, &IA_SIN(ifa)->sin_addr, ac->ac_enaddr);
		 /* If no response after 1 second, broadcast a definite
		  * ARP reply to announce our presence to the world.
		  */
		 timeout(broadcastarpreply, ifa, hz);
	}
	else
#endif
		arprequest(ac, &IA_SIN(ifa)->sin_addr,
			       &IA_SIN(ifa)->sin_addr, ac->ac_enaddr);
	}
	ifa->ifa_rtrequest = arp_rtrequest;
	ifa->ifa_flags |= RTF_CLONING;
}

#ifdef __riscos
static void
broadcastarpreply(void *p)
{
	struct ifaddr *ifa = (struct ifaddr *) p;
	struct arpcom *ac = (struct arpcom *) ifa->ifa_ifp;

	struct mbuf *m;
	struct ether_header *eh;
	struct ether_arp *ea;
	struct sockaddr sa;

	if ((m = m_gethdr(M_DONTWAIT, MT_DATA)) == NULL)
		return;
	m->m_len = sizeof *ea;
	m->m_pkthdr.len = sizeof(*ea);
	MH_ALIGN(m, sizeof(*ea));
	ea = mtod(m, struct ether_arp *);
	eh = (struct ether_header *)sa.sa_data;
	bzero((caddr_t)ea, sizeof (*ea));
	(void)memcpy(eh->ether_dhost, etherbroadcastaddr, sizeof(eh->ether_dhost));
	eh->ether_type = ETHERTYPE_ARP;		/* if_output will swap */
	ea->arp_hrd = htons(ARPHRD_ETHER);
	ea->arp_pro = htons(ETHERTYPE_IP);
	ea->arp_hln = sizeof(ea->arp_sha);	/* hardware address length */
	ea->arp_pln = sizeof(ea->arp_spa);	/* protocol address length */
	ea->arp_op = htons(ARPOP_REPLY);
	(void)memcpy(ea->arp_sha, ac->ac_enaddr, sizeof(ea->arp_sha));
	(void)memcpy(ea->arp_spa, &IA_SIN(ifa)->sin_addr, sizeof(ea->arp_spa));
	(void)memcpy(ea->arp_tha, ac->ac_enaddr, sizeof(ea->arp_tha));
	(void)memcpy(ea->arp_tpa, &IA_SIN(ifa)->sin_addr, sizeof(ea->arp_tpa));
	sa.sa_family = AF_UNSPEC;
	sa.sa_len = sizeof(sa);
	(*ac->ac_if.if_output)(&ac->ac_if, m, &sa, (struct rtentry *)0);

}
#endif
@


4.7
log
@The horrible ac_ipaddr member of struct arpcom exorcised once and for all.

Version 5.30. Tagged as 'Internet-5_30'
@
text
@d399 2
a404 2
#ifdef __riscos
		struct mbuf *m0 = m;
@


4.6
log
@* Dynamic ports now assigned in range 49152-65535.
* IP_RECVDSTADDR works for non-unicast packets.
* SO_TIMESTAMP added.
* IP_RECVIF added.
* Various other internal changes merged in from FreeBSD sources.

Version 5.29. Tagged as 'Internet-5_29'
@
text
@d88 9
a254 11
 * Broadcast an ARP packet, asking who has addr on interface ac.
 */
void
arpwhohas(ac, addr)
	register struct arpcom *ac;
	struct in_addr *addr;
{
	arprequest(ac, &ac->ac_ipaddr, addr, ac->ac_enaddr);
}

/*
d453 3
a455 1
				arpwhohas(ac, &(SIN(dst)->sin_addr));
d570 1
a570 1
		untimeout(broadcastarpreply, ac);
d753 1
a753 1
	ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;
d759 1
a759 1
		 arprequest(ac, &sip, &ac->ac_ipaddr, ac->ac_enaddr);
d763 1
a763 1
		 timeout(broadcastarpreply, ac, hz);
d767 3
a769 1
	arpwhohas(ac, &ac->ac_ipaddr);
d778 2
a779 1
	struct arpcom *ac = (struct arpcom *) p;
d802 1
a802 1
	(void)memcpy(ea->arp_spa, &ac->ac_ipaddr.s_addr, sizeof(ea->arp_spa));
d804 1
a804 1
	(void)memcpy(ea->arp_tpa, &ac->ac_ipaddr.s_addr, sizeof(ea->arp_tpa));
@


4.5
log
@* Fixed bug introduced by tentative ARP probe - a typo made arp_ifinit() fail to
  set up the interface route structure properly.
* Divide-by-zero when an IGMP membership query with a time of 1 received fixed
  (from FreeBSD).
* IGMP messages now sent with TOS set to "maximum reliability".
* tcp_output.c updated from FreeBSD - in particular path_mtu_discovery sysctl
  now available.
* A few other FreeBSD structural changes and bug fixes integrated.
* Put UDP checksum in BOOTP packets.
* Null pointer dereferencing fixed in whoami.c. Address setting now done with
  SIOCDIFADDR and SIOCAIFADDR. Don't set the netmask if asked not to.
* Output BOOTP packets with the source address in ciaddr
Note that various structural changes mean that the support tools (in particular
InetStat) will need to be recompiled.
Requires TCPIPLibs 5.20

Version 5.27. Tagged as 'Internet-5_27'
@
text
@d88 1
a88 1
static	void arprequest(struct arpcom *, u_long *, u_long *, u_char *);
d183 2
a184 2
			    &SIN(rt_key(rt))->sin_addr.s_addr,
			    &SIN(rt_key(rt))->sin_addr.s_addr,
d251 1
a251 1
	register struct in_addr *addr;
d253 1
a253 1
	arprequest(ac, &ac->ac_ipaddr.s_addr, &addr->s_addr, ac->ac_enaddr);
d265 1
a265 1
	register u_long *sip, *tip;
d758 2
a759 2
		 u_long sip = 0;
		 arprequest(ac, &sip, &ac->ac_ipaddr.s_addr, ac->ac_enaddr);
@


4.4
log
@Added Service_InternetStatus_DuplicateIPAddress to allow graceful behaviour
in the event of a DHCP address clash.
When configuring an interface as a result of DHCP/BOOTP - do a two stage
ARP transmission - first a "gentle" probe from 0.0.0.0 to check, then a
broadcast ARP reply to update everyone's ARP caches if there is no response.
If the probe shows a duplicate, the DHCP module can catch the service call
and send a DHCPDECLINE.
Changed to not respond to ICMP or ARP packets on an interface in the process
of DHCP/BOOTP/RevARP booting. Solves problem of DHCP server probing the
address it wants to give us and having us respond, making it think it's in
use.

Version 5.26. Tagged as 'Internet-5_26'
@
text
@d766 1
a766 1
#else
a767 1
#endif
@


4.3
log
@Internet 5.05. IGMPv2 (RFC2236) implemented from FreeBSD source.
SB_MAX increased to 256K. Nasty memory leak when sending large
UDP packets fixed.
@
text
@d69 1
d93 3
d570 8
a577 4
		sprintf(buffer,
			"Duplicate IP address %s! sent from ethernet address: %s",
			inet_ntoa(isaddr), ether_sprintf(ea->arp_sha));
		panic(buffer);
d609 5
d754 13
d768 1
d772 37
@


4.2
log
@Version Spinner_B7 taken
@
text
@d364 12
d377 2
a378 1
#endif
d401 10
d413 1
d432 13
@


4.1
log
@Initial revision
@
text
@d1 3
a3 4
/* -*-C-*-
 *
 * $Header: /ax/networking:Internet/netinet/if_ether.c:networking  1.3  $
 * $Source: /ax/networking:Internet/netinet/if_ether.c: $
d5 15
a19 1
 * Ethernet address resolution protocol.
d21 11
a31 1
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
a32 11
 * $Log:	if_ether.c,v $
 * Revision 1.3  95/03/31  14:03:02  kwelton
 * Module will now panic when a duplicate IP address is detected in
 * in_arpinput().
 * 
 * Revision 1.2  95/03/31  11:53:11  kwelton
 * Debugs in in_arpinput() can only have one call to inet_ntoa() per Printf().
 * 
 * Revision 1.1  94/12/02  11:06:06  kwelton
 * Initial revision
 * 
d34 1
d36 3
a38 15
 * Copyright (c) 1983, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
d40 1
d43 23
a65 15
#include "sys/param.h"
#include "sys/systm.h"
#include "sys/syslog.h"
#include "sys/time.h"
#include "sys/mbuf.h"
#include "sys/socket.h"
#include "sys/errno.h"
#include "sys/ioctl.h"

#include "net/if.h"

#include "netinet/in.h"
#include "netinet/in_systm.h"
#include "netinet/ip.h"
#include "netinet/if_ether.h"
d68 1
d70 3
a72 5
#define ARPTAB_BSIZ	10		 /* bucket size (16) */
#define ARPTAB_NB	20		/* number of buckets (37) */
#define ARPTAB_SIZE	(ARPTAB_BSIZ * ARPTAB_NB)
struct	arptab arptab[ARPTAB_SIZE] = { 0 };
int	arptab_size = ARPTAB_SIZE;	/* for arp command */
a79 2
#define ARPTAB_HASH(a) \
	((u_long)(a) % ARPTAB_NB)
d81 31
a111 8
#define ARPTAB_LOOK(at,addr) { \
	register n; \
	at = &arptab[ARPTAB_HASH(addr) * ARPTAB_BSIZ]; \
	for (n = 0 ; n < ARPTAB_BSIZ ; n++,at++) \
		if (at->at_iaddr.s_addr == addr) \
			break; \
	if (n >= ARPTAB_BSIZ) \
		at = 0; \
d113 1
d115 9
a123 4
/* timer values */
#define ARPT_AGE	(60*1)	/* aging timer, 1 min. */
#define ARPT_KILLC	20	/* kill completed entry in 20 mins. */
#define ARPT_KILLI	3	/* kill incomplete entry in 3 minutes */
d125 8
a132 2
u_char	etherbroadcastaddr[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
extern struct ifnet loif;
d135 1
a135 1
 * Timeout routine.  Age arp_tab entries once a minute.
d137 5
a141 1
arptimer()
d143 84
a226 2
	register struct arptab *at;
	register i;
d228 10
a237 16
	/*
	 * TRACE
	 *
	 * use (seemingly more accurate) HZ (100),
	 * rather than the old hz (50).
	 */
	timeout(arptimer, (caddr_t)0, ARPT_AGE * HZ);
	at = &arptab[0];
	for (i = 0; i < ARPTAB_SIZE; i++, at++) {
		if (at->at_flags == 0 || (at->at_flags & ATF_PERM))
			continue;
		if (++at->at_timer < ((at->at_flags&ATF_COM) ?
		    ARPT_KILLC : ARPT_KILLI))
			continue;
		/* timer has expired, clear entry */
		arptfree(at);
d244 1
d247 16
a262 1
	struct in_addr *addr;
d269 1
a269 2
#ifdef OldCode
	if ((m = m_get(M_DONTWAIT, MT_DATA)) == NULL)
a270 11
#else
	if( (m = ALLOC_S(MINCONTIG, NULL)) == NULL )
	{
#ifdef DEBUG
	    if( DODEBUG(DBGMMAN) )
		Printf("arpwhohas: ALLOC_S failed\n");
#endif
	    return;
	}
	m->m_type = MT_DATA;
#endif
d272 2
a273 1
	m->m_off = MAXOFF(m) - m->m_len;
d277 1
a277 2
	bcopy((caddr_t)etherbroadcastaddr, (caddr_t)eh->ether_dhost,
	    sizeof(eh->ether_dhost));
d284 3
a286 5
	bcopy((caddr_t)ac->ac_enaddr, (caddr_t)ea->arp_sha,
	   sizeof(ea->arp_sha));
	bcopy((caddr_t)&ac->ac_ipaddr, (caddr_t)ea->arp_spa,
	   sizeof(ea->arp_spa));
	bcopy((caddr_t)addr, (caddr_t)ea->arp_tpa, sizeof(ea->arp_tpa));
d288 2
a289 1
	(*ac->ac_if.if_output)(&ac->ac_if, m, &sa);
d295 34
a328 1
static int useloopback = 1;
d332 1
a332 1
 * desten is filled in.	 If there is no entry in arptab,
d335 1
a335 1
 * is finally resolved.	 A return value of 1 indicates
a338 4
 *
 * We do some (conservative) locking here at splimp, since
 * arptab is also altered from input interrupt service (ecintr/ilintr
 * calls arpinput when ETHERTYPE_ARP packets come in).
d340 2
a341 1
arpresolve(ac, m, destip, desten, usetrailers)
d343 1
d345 1
a345 1
	register struct in_addr *destip;
d347 1
a347 1
	int *usetrailers;
d349 2
a350 7
	register struct arptab *at;
	u_long lna;
	int s;

#ifndef OldCode
	struct sockaddr_in sin;
#endif
d352 2
a353 25
	*usetrailers = 0;
	if (in_broadcast(*destip)) {	/* broadcast address */
		/*
		 * CAB 03/Oct/88
		 *
		 * send broadcast packets to self
		 * thru "lo", also send out on if
		 *
		 * KWelton 920611
		 *
		 * do not send out on loopback if hardware is capable
		 * of receiving its own packets.
		 */
		if (useloopback && !(ac->ac_if.if_flags & IFF_CANREFLECT)) {
			struct mbuf *echo = 0;
			if( (echo = COPY_P(m, 0, M_COPYALL)) != NULL )
			{
			    sin.sin_family = AF_INET;
			    sin.sin_addr = *destip;
			    looutput(&loif, echo, (struct sockaddr *)&sin);
			}
		}
/** CAB 03/Oct/88	end of broadcast patch */
		bcopy((caddr_t)etherbroadcastaddr, (caddr_t)desten,
		    sizeof(etherbroadcastaddr));
d356 17
a372 6
	lna = in_lnaof(*destip);
#ifdef OldCode
	/* if for us, use software loopback driver if up */
	if (destip->s_addr == ac->ac_ipaddr.s_addr) {
		bcopy((caddr_t)ac->ac_enaddr, (caddr_t)desten,
			    sizeof(ac->ac_enaddr));
d375 7
a381 26
#else
	/* if for us, use software loopback driver if up */
	if (destip->s_addr == ac->ac_ipaddr.s_addr) {
		/*
		 * This test used to be
		 *	if (loif.if_flags & IFF_UP)
		 * It allowed local traffic to be forced
		 * through the hardware by configuring the loopback down.
		 * However, it causes problems during network configuration
		 * for boards that can't receive packets they send.
		 * It is now necessary to clear "useloopback"
		 * to force traffic out to the hardware.
		 */
		if (useloopback) {
			sin.sin_family = AF_INET;
			sin.sin_addr = *destip;
			(void) looutput(&loif, m, (struct sockaddr *)&sin);
			/*
			 * The packet has already been sent and freed.
			 */
			return (0);
		} else {
			bcopy((caddr_t)ac->ac_enaddr, (caddr_t)desten,
			    sizeof(ac->ac_enaddr));
			return (1);
		}
d383 4
d388 2
a389 23

	s = splimp();
	ARPTAB_LOOK(at, destip->s_addr);
	if (at == 0) {			/* not found */
		if (ac->ac_if.if_flags & IFF_NOARP) {
			bcopy((caddr_t)ac->ac_enaddr, (caddr_t)desten, 3);
			desten[3] = (lna >> 16) & 0x7f;
			desten[4] = (lna >> 8) & 0xff;
			desten[5] = lna & 0xff;
			splx(s);
			return (1);
		} else {
			at = arptnew(destip);
			if (at == 0) {
				panic("arpresolve: no free entry");
				splx(s);
				return (0);
			}
			at->at_hold = ENSURE_SAFE(m);
			arpwhohas(ac, destip);
			splx(s);
			return (0);
		}
d391 9
a399 8
	at->at_timer = 0;		/* restart the timer */
	if (at->at_flags & ATF_COM) {	/* entry IS complete */
		bcopy((caddr_t)at->at_enaddr, (caddr_t)desten,
		    sizeof(at->at_enaddr));
		if (at->at_flags & ATF_USETRAILERS)
			*usetrailers = 1;
		splx(s);
		return (1);
d406 16
a421 7
	if (at->at_hold)
	{
#ifdef OldCode
	    m_freem(at->at_hold);
#else
	    FREEM(at->at_hold);
#endif
a422 3
	at->at_hold = ENSURE_SAFE(m);
	arpwhohas(ac, destip);		/* ask again */
	splx(s);
d427 1
a427 3
 * Called from 10 Mb/s Ethernet interrupt handlers
 * when ether packet type ETHERTYPE_ARP
 * is received.	 Common length and type checks are done here,
d430 2
a431 3
arpinput(ac, m)
	struct arpcom *ac;
	struct mbuf *m;
d433 1
d435 1
d437 22
a458 26
#ifdef DEBUG
	if( DODEBUG(DBGARP) )
	    Printf("arpinput: m %x (next = %x)\n", m, m->m_next);
#endif

	if (ac->ac_if.if_flags & IFF_NOARP)
		goto out;

	IF_ADJ(m);
	if (m->m_len < sizeof(struct arphdr))
		goto out;
	ar = mtod(m, struct arphdr *);
	if (ntohs(ar->ar_hrd) != ARPHRD_ETHER)
		goto out;
	if (m->m_len < sizeof(struct arphdr) + 2 * ar->ar_hln + 2 * ar->ar_pln)
		goto out;

	switch (ntohs(ar->ar_pro)) {

	case ETHERTYPE_IP:
	case ETHERTYPE_IPTRAILERS:
		in_arpinput(ac, m);
		return;

	default:
		break;
a459 6
out:
#ifdef OldCode
	m_freem(m);
#else
	FREEM(m);
#endif
d467 5
a471 5
 * We also handle negotiations for use of trailer protocol:
 * ARP replies for protocol type ETHERTYPE_TRAIL are sent
 * along with IP replies if we want trailers sent to us,
 * and also send them in response to IP replies.
 * This allows either end to announce the desire to receive
d473 2
a474 2
 * We reply to requests for ETHERTYPE_TRAIL protocol as well,
 * but don't normally send requests.
d476 2
a477 2
in_arpinput(ac, m)
	register struct arpcom *ac;
d481 1
d483 4
a486 3
	register struct arptab *at;  /* same as "merge" flag */
	struct mbuf *mcopy = 0;
	struct sockaddr_in sin;
d489 1
a489 1
	int proto, op, s, completed = 0;
a490 1
	myaddr = ac->ac_ipaddr;
a491 1
	proto = ntohs(ea->arp_pro);
d493 2
a494 2
	bcopy((caddr_t)ea->arp_spa, (caddr_t)&isaddr, sizeof (isaddr));
	bcopy((caddr_t)ea->arp_tpa, (caddr_t)&itaddr, sizeof (itaddr));
d497 1
a497 2
	if( DODEBUG(DBGARP) )
	{
d505 10
a517 1

d520 3
a522 4
#ifndef __riscos
		log(LOG_ERR,
		    "arp: ether address is broadcast for IP address %x!\n",
		    ntohl(isaddr.s_addr));
d530 2
a531 2
			"Duplicate IP address sent from ethernet address %s",
			ether_sprintf(ea->arp_sha));
d534 3
a536 3
		log(LOG_ERR, "%s: %s\n",
			"duplicate IP address!! sent from ethernet address",
			ether_sprintf(ea->arp_sha));
d543 18
a560 23
	s = splimp();
	ARPTAB_LOOK(at, isaddr.s_addr);
	if (at) {
		bcopy((caddr_t)ea->arp_sha, (caddr_t)at->at_enaddr,
		    sizeof(ea->arp_sha));
		if ((at->at_flags & ATF_COM) == 0)
			completed = 1;
		at->at_flags |= ATF_COM;
		if (at->at_hold) {
			sin.sin_family = AF_INET;
			sin.sin_addr = isaddr;
			(*ac->ac_if.if_output)(&ac->ac_if,
			    at->at_hold, (struct sockaddr *)&sin);
			at->at_hold = 0;
		}
	}
	if (at == 0 && itaddr.s_addr == myaddr.s_addr) {
		/* ensure we have a table entry */
		if (at = arptnew(&isaddr)) {
			bcopy((caddr_t)ea->arp_sha, (caddr_t)at->at_enaddr,
			    sizeof(ea->arp_sha));
			completed = 1;
			at->at_flags |= ATF_COM;
a562 1
	splx(s);
d564 4
a567 23
	switch (proto) {

	case ETHERTYPE_IPTRAILERS:
		/* partner says trailers are OK */
		if (at)
			at->at_flags |= ATF_USETRAILERS;
		/*
		 * Reply to request iff we want trailers.
		 */
		if (op != ARPOP_REQUEST || ac->ac_if.if_flags & IFF_NOTRAILERS)
			goto out;
		break;

	case ETHERTYPE_IP:
		/*
		 * Reply if this is an IP request,
		 * or if we want to send a trailer response.
		 * Send the latter only to the IP response
		 * that completes the current ARP entry.
		 */
		if (op != ARPOP_REQUEST &&
		    (completed == 0 || ac->ac_if.if_flags & IFF_NOTRAILERS))
			goto out;
d571 2
a572 4
		bcopy((caddr_t)ea->arp_sha, (caddr_t)ea->arp_tha,
		    sizeof(ea->arp_sha));
		bcopy((caddr_t)ac->ac_enaddr, (caddr_t)ea->arp_sha,
		    sizeof(ea->arp_sha));
d574 32
a605 2
		ARPTAB_LOOK(at, itaddr.s_addr);
		if (at == NULL || (at->at_flags & ATF_PUBL) == 0)
d607 7
a613 4
		bcopy((caddr_t)ea->arp_sha, (caddr_t)ea->arp_tha,
		    sizeof(ea->arp_sha));
		bcopy((caddr_t)at->at_enaddr, (caddr_t)ea->arp_sha,
		    sizeof(ea->arp_sha));
d616 2
a617 4
	bcopy((caddr_t)ea->arp_spa, (caddr_t)ea->arp_tpa,
	    sizeof(ea->arp_spa));
	bcopy((caddr_t)&itaddr, (caddr_t)ea->arp_spa,
	    sizeof(ea->arp_spa));
d619 1
a619 18
	/*
	 * If incoming packet was an IP reply,
	 * we are sending a reply for type IPTRAILERS.
	 * If we are sending a reply for type IP
	 * and we want to receive trailers,
	 * send a trailer reply as well.
	 */
	if (op == ARPOP_REPLY)
		ea->arp_pro = htons(ETHERTYPE_IPTRAILERS);
	else if (proto == ETHERTYPE_IP &&
	    (ac->ac_if.if_flags & IFF_NOTRAILERS) == 0)
	{
#ifdef OldCode
	    mcopy = m_copy(m, 0, (int)M_COPYALL);
#else
	    mcopy = COPY_P(m, 0, (int)M_COPYALL);
#endif
	}
d621 1
a621 2
	bcopy((caddr_t)ea->arp_tha, (caddr_t)eh->ether_dhost,
	    sizeof(eh->ether_dhost));
d624 2
a625 13
	(*ac->ac_if.if_output)(&ac->ac_if, m, &sa);
	if (mcopy) {
		ea = mtod(mcopy, struct ether_arp *);
		ea->arp_pro = htons(ETHERTYPE_IPTRAILERS);
		(*ac->ac_if.if_output)(&ac->ac_if, mcopy, &sa);
	}
	return;
out:
#ifdef OldCode
	m_freem(m);
#else
	FREEM(m);
#endif
d632 3
a634 2
arptfree(at)
	register struct arptab *at;
d636 12
a647 9
	int s = splimp();

	if (at->at_hold)
	{
#ifdef OldCode
	    m_freem(at->at_hold);
#else
	    FREEM(at->at_hold);
#endif
d649 2
a650 4
	at->at_hold = 0;
	at->at_timer = at->at_flags = 0;
	at->at_iaddr.s_addr = 0;
	splx(s);
a651 1

d653 1
a653 6
 * Enter a new address in arptab, pushing out the oldest entry
 * from the bucket if there is no room.
 * This always succeeds since no bucket can be completely filled
 * with permanent entries (except from arpioctl when testing whether
 * another permanent entry will fit).
 * MUST BE CALLED AT SPLIMP.
d655 4
a658 3
struct arptab *
arptnew(addr)
	struct in_addr *addr;
d660 17
a676 4
	register n;
	int oldest = -1;
	register struct arptab *at, *ato = NULL;
	static int first = 1;
d678 8
a685 17
	/*
	 * TRACE - another use of HZ rather than hz
	 */
	if (first) {
		first = 0;
		timeout(arptimer, (caddr_t)0, HZ);
	}
	at = &arptab[ARPTAB_HASH(addr->s_addr) * ARPTAB_BSIZ];
	for (n = 0; n < ARPTAB_BSIZ; n++,at++) {
		if (at->at_flags == 0)
			goto out;	 /* found an empty entry */
		if (at->at_flags & ATF_PERM)
			continue;
		if ((int) at->at_timer > oldest) {
			oldest = at->at_timer;
			ato = at;
		}
d687 1
a687 8
	if (ato == NULL)
		return (NULL);
	at = ato;
	arptfree(at);
out:
	at->at_iaddr = *addr;
	at->at_flags = ATF_INUSE;
	return (at);
d690 1
d695 1
a695 72
	register struct arpreq *ar = (struct arpreq *)data;
	register struct arptab *at;
	register struct sockaddr_in *sin;
	int s;
#ifdef __riscos
	struct arptinfo *ai;

	if (cmd == SIOCTARP) {
	    ai = (struct arptinfo *)data;
	    ai->a_arptsize = arptab_size;
	    ai->a_arptab = (caddr_t)&arptab[0];
	    return (0);
	}
#endif
	if (ar->arp_pa.sa_family != AF_INET ||
	    ar->arp_ha.sa_family != AF_UNSPEC)
		return (EAFNOSUPPORT);
	sin = (struct sockaddr_in *)&ar->arp_pa;
	s = splimp();
	ARPTAB_LOOK(at, sin->sin_addr.s_addr);
	if (at == NULL) {		/* not found */
		if (cmd != SIOCSARP) {
			splx(s);
			return (ENXIO);
		}
		if (ifa_ifwithnet(&ar->arp_pa) == NULL) {
			splx(s);
			return (ENETUNREACH);
		}
	}
	switch (cmd) {

	case SIOCSARP:		/* set entry */
		if (at == NULL) {
			at = arptnew(&sin->sin_addr);
			if (at == NULL) {
				splx(s);
				return (EADDRNOTAVAIL);
			}
			if (ar->arp_flags & ATF_PERM) {
			/* never make all entries in a bucket permanent */
				register struct arptab *tat;

				/* try to re-allocate */
				tat = arptnew(&sin->sin_addr);
				if (tat == NULL) {
					arptfree(at);
					splx(s);
					return (EADDRNOTAVAIL);
				}
				arptfree(tat);
			}
		}
		bcopy((caddr_t)ar->arp_ha.sa_data, (caddr_t)at->at_enaddr,
		    sizeof(at->at_enaddr));
		at->at_flags = ATF_COM | ATF_INUSE |
			(ar->arp_flags & (ATF_PERM|ATF_PUBL|ATF_USETRAILERS));
		at->at_timer = 0;
		break;

	case SIOCDARP:		/* delete entry */
		arptfree(at);
		break;

	case SIOCGARP:		/* get entry */
		bcopy((caddr_t)at->at_enaddr, (caddr_t)ar->arp_ha.sa_data,
		    sizeof(at->at_enaddr));
		ar->arp_flags = at->at_flags;
		break;
	}
	splx(s);
	return (0);
d698 4
a701 6
/*
 * Convert Ethernet address to printable (loggable) representation.
 */
char *
ether_sprintf(ap)
	register u_char *ap;
d703 4
a706 12
	register i;
	static char etherbuf[18];
	register char *cp = etherbuf;
	static char digits[] = "0123456789abcdef";

	for (i = 0; i < 6; i++) {
		*cp++ = digits[*ap >> 4];
		*cp++ = digits[*ap++ & 0xf];
		*cp++ = ':';
	}
	*--cp = 0;
	return (etherbuf);
a707 2

/* EOF if_ether.c */
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d1 4
a4 3
/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
d6 1
a6 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d8 1
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 11
a21 1

d23 15
a37 3
 * Ethernet address resolution protocol.
 * TODO:
 *	add "inuse/lock" bit (or ref. count) along with valid bit
a38 1

d41 15
a55 23
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/route.h>
#include <net/netisr.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>

#include <string.h>
a57 1
#include "module.h"
d59 5
a63 3
#define SIN(s) ((struct sockaddr_in *)s)
#define SDL(s) ((struct sockaddr_dl *)s)
#define SRP(s) ((struct sockaddr_inarp *)s)
d71 2
d74 8
a81 31
/* timer values */
int	arpt_prune = (5*60*1);	/* walk list every 5 minutes */
int	arpt_keep = (20*60);	/* once resolved, good for 20 more minutes */
int	arpt_down = 20;		/* once declared down, don't send for 20 secs */
#define	rt_expire rt_rmx.rmx_expire

static	void arprequest(struct arpcom *, u_long *, u_long *, u_char *);
static	void arptfree(struct llinfo_arp *);
static	void arptimer(void *);
static	struct llinfo_arp *arplookup(u_long, int, int);
static	void in_arpinput(struct mbuf *);

#ifdef __riscos
struct	llinfo_arp llinfo_arp;
#else
struct	llinfo_arp llinfo_arp = {&llinfo_arp, &llinfo_arp};
#endif
struct	ifqueue arpintrq = {0, 0, 0, 50};
int	arp_inuse, arp_allocated, arp_intimer;
int	arp_maxtries = 5;
int	useloopback = 1;	/* use loopback interface for local traffic */
int	arpinit_done = 0;

#ifdef	ARP_PROXYALL
int	arp_proxyall = 1;
#endif

#ifdef __riscos
void arp_init()
{
	llinfo_arp.la_next = llinfo_arp.la_prev = &llinfo_arp;
a82 1
#endif
d84 4
a87 9
/*
 * Timeout routine.  Age arp_tab entries periodically.
 */
/* ARGSUSED */
static void
arptimer(ignored_arg)
	void *ignored_arg;
{
	register struct llinfo_arp *la = llinfo_arp.la_next;
d89 2
a90 8
	timeout(arptimer, (caddr_t)0, arpt_prune * hz);
	while (la != &llinfo_arp) {
		register struct rtentry *rt = la->la_rt;
		la = la->la_next;
		if (rt->rt_expire && rt->rt_expire <= time.tv_sec)
			arptfree(la->la_prev); /* timer has expired, clear */
	}
}
d93 1
a93 1
 * Parallel to llc_rtrequest.
d95 1
a95 5
static void
arp_rtrequest(req, rt, sa)
	int req;
	register struct rtentry *rt;
	struct sockaddr *sa;
d97 2
a98 11
	register struct sockaddr *gate = rt->rt_gateway;
	register struct llinfo_arp *la = (struct llinfo_arp *)rt->rt_llinfo;
	static struct sockaddr_dl null_sdl = {sizeof(null_sdl), AF_LINK};

	if (!arpinit_done) {
		arpinit_done = 1;
		timeout(arptimer, (caddr_t)0, hz);
	}
	if (rt->rt_flags & RTF_GATEWAY)
		return;
	switch (req) {
d100 16
a115 83
	case RTM_ADD:
		/*
		 * XXX: If this is a manually added route to interface
		 * such as older version of routed or gated might provide,
		 * restore cloning bit.
		 */
		if ((rt->rt_flags & RTF_HOST) == 0 &&
		    SIN(rt_mask(rt))->sin_addr.s_addr != 0xffffffff)
			rt->rt_flags |= RTF_CLONING;
		if (rt->rt_flags & RTF_CLONING) {
			/*
			 * Case 1: This route should come from a route to iface.
			 */
			rt_setgate(rt, rt_key(rt),
					(struct sockaddr *)&null_sdl);
			gate = rt->rt_gateway;
			SDL(gate)->sdl_type = rt->rt_ifp->if_type;
			SDL(gate)->sdl_index = rt->rt_ifp->if_index;
			rt->rt_expire = time.tv_sec;
			break;
		}
		/* Announce a new entry if requested. */
		if (rt->rt_flags & RTF_ANNOUNCE)
			arprequest((struct arpcom *)rt->rt_ifp,
			    &SIN(rt_key(rt))->sin_addr.s_addr,
			    &SIN(rt_key(rt))->sin_addr.s_addr,
			    (u_char *)LLADDR(SDL(gate)));
		/*FALLTHROUGH*/
	case RTM_RESOLVE:
		if (gate->sa_family != AF_LINK ||
		    gate->sa_len < sizeof(null_sdl)) {
			log(LOG_DEBUG, "arp_rtrequest: bad gateway value\n");
			break;
		}
		SDL(gate)->sdl_type = rt->rt_ifp->if_type;
		SDL(gate)->sdl_index = rt->rt_ifp->if_index;
		if (la != 0)
			break; /* This happens on a route change */
		/*
		 * Case 2:  This route may come from cloning, or a manual route
		 * add with a LL address.
		 */
		R_Malloc(la, struct llinfo_arp *, sizeof(*la));
		rt->rt_llinfo = (caddr_t)la;
		if (la == 0) {
			log(LOG_DEBUG, "arp_rtrequest: malloc failed\n");
			break;
		}
		arp_inuse++, arp_allocated++;
		Bzero(la, sizeof(*la));
		la->la_rt = rt;
		rt->rt_flags |= RTF_LLINFO;
		insque(la, &llinfo_arp);
		if (SIN(rt_key(rt))->sin_addr.s_addr ==
		    (IA_SIN(rt->rt_ifa))->sin_addr.s_addr) {
		    /*
		     * This test used to be
		     *	if (loif.if_flags & IFF_UP)
		     * It allowed local traffic to be forced
		     * through the hardware by configuring the loopback down.
		     * However, it causes problems during network configuration
		     * for boards that can't receive packets they send.
		     * It is now necessary to clear "useloopback" and remove
		     * the route to force traffic out to the hardware.
		     */
			rt->rt_expire = 0;
			Bcopy(((struct arpcom *)rt->rt_ifp)->ac_enaddr,
				LLADDR(SDL(gate)), SDL(gate)->sdl_alen = 6);
			if (useloopback)
				rt->rt_ifp = loif;
		}
		break;

	case RTM_DELETE:
		if (la == 0)
			break;
		arp_inuse--;
		remque(la);
		rt->rt_llinfo = 0;
		rt->rt_flags &= ~RTF_LLINFO;
		if (la->la_hold)
			m_freem(la->la_hold);
		Free((caddr_t)la);
a121 1
void
d124 1
a124 16
	register struct in_addr *addr;
{
	arprequest(ac, &ac->ac_ipaddr.s_addr, &addr->s_addr, ac->ac_enaddr);
}

/*
 * Broadcast an ARP request. Caller specifies:
 *	- arp header source ip address
 *	- arp header target ip address
 *	- arp header source ethernet address
 */
static void
arprequest(ac, sip, tip, enaddr)
	register struct arpcom *ac;
	register u_long *sip, *tip;
	register u_char *enaddr;
d131 2
a132 1
	if ((m = m_gethdr(M_DONTWAIT, MT_DATA)) == NULL)
d134 11
d146 1
a146 2
	m->m_pkthdr.len = sizeof(*ea);
	MH_ALIGN(m, sizeof(*ea));
d150 2
a151 1
	(void)memcpy(eh->ether_dhost, etherbroadcastaddr, sizeof(eh->ether_dhost));
d158 5
a162 3
	(void)memcpy(ea->arp_sha, enaddr, sizeof(ea->arp_sha));
	(void)memcpy(ea->arp_spa, sip, sizeof(ea->arp_spa));
	(void)memcpy(ea->arp_tpa, tip, sizeof(ea->arp_tpa));
d164 1
a164 2
	sa.sa_len = sizeof(sa);
	(*ac->ac_if.if_output)(&ac->ac_if, m, &sa, (struct rtentry *)0);
d170 1
a170 34
#ifdef __riscos
/*
 * Return the host portion of an internet address.
 */
u_long
in_lnaof(in)
	struct in_addr in;
{
	register u_long i = ntohl(in.s_addr);
	register u_long net, host;
	register struct in_ifaddr *ia;

	if (IN_CLASSA(i)) {
		net = i & IN_CLASSA_NET;
		host = i & IN_CLASSA_HOST;
	} else if (IN_CLASSB(i)) {
		net = i & IN_CLASSB_NET;
		host = i & IN_CLASSB_HOST;
	} else if (IN_CLASSC(i)) {
		net = i & IN_CLASSC_NET;
		host = i & IN_CLASSC_HOST;
	} else
		return (i);

	/*
	 * Check whether network is a subnet;
	 * if so, use the modified interpretation of `host'.
	 */
	for (ia = in_ifaddr; ia; ia = ia->ia_next)
		if (net == ia->ia_net)
			return (host &~ ia->ia_subnetmask);
	return (host);
}
#endif
d174 1
a174 1
 * desten is filled in.  If there is no entry in arptab,
d177 1
a177 1
 * is finally resolved.  A return value of 1 indicates
d181 4
d186 1
a186 2
int
arpresolve(ac, rt, m, dst, desten, rt0)
a187 1
	register struct rtentry *rt;
d189 1
a189 1
	register struct sockaddr *dst;
d191 1
a191 1
	struct rtentry *rt0;
d193 7
a199 2
	register struct llinfo_arp *la;
	struct sockaddr_dl *sdl;
d201 25
a225 2
	if (m->m_flags & M_BCAST) {	/* broadcast address */
		(void)memcpy(desten, etherbroadcastaddr, sizeof(etherbroadcastaddr));
d228 7
a234 4
#ifdef MULTICAST
	if (m->m_flags & M_MCAST) {	/* multicast */
		ETHER_MAP_IP_MULTICAST(&SIN(dst)->sin_addr, desten);
		return(1);
d237 25
a261 12
	/* Can't transmit multicast! */
	if (m->m_flags & M_MCAST)
		return (0);
#endif
#ifdef __riscos
	if (ac->ac_if.if_flags & IFF_NOARP) {
		u_long lna = in_lnaof(SIN(dst)->sin_addr);
		memcpy(desten, ac->ac_enaddr, 3);
		desten[3] = (lna >> 16) & 0x7f;
		desten[4] = (lna >> 8) & 0xff;
		desten[5] = lna & 0xff;
		return (1);
d264 23
a286 6
	if (rt)
		la = (struct llinfo_arp *)rt->rt_llinfo;
	else {
		la = arplookup(SIN(dst)->sin_addr.s_addr, 1, 0);
		if (la)
			rt = la->la_rt;
d288 8
a295 17
	if (la == 0 || rt == 0) {
#ifdef DEBUG
		Printf("arpresolve: can't allocate llinfo for %s\n",
			inet_ntoa(SIN(dst)->sin_addr));
#endif
		m_freem(m);
		return (0);
	}
	sdl = SDL(rt->rt_gateway);
	/*
	 * Check the address family and length is valid, the address
	 * is resolved; otherwise, try to resolve.
	 */
	if ((rt->rt_expire == 0 || rt->rt_expire > time.tv_sec) &&
	    sdl->sdl_family == AF_LINK && sdl->sdl_alen != 0) {
		(void)memcpy(desten, LLADDR(sdl), sdl->sdl_alen);
		return 1;
d302 7
a308 16
	if (la->la_hold)
		m_freem(la->la_hold);
	la->la_hold = ENSURE_SAFE(m);   /* Necessary because of UDP hack */
	if (rt->rt_expire) {
		rt->rt_flags &= ~RTF_REJECT;
		if (la->la_asked == 0 || rt->rt_expire != time.tv_sec) {
			rt->rt_expire = time.tv_sec;
			if (la->la_asked++ < arp_maxtries)
				arpwhohas(ac, &(SIN(dst)->sin_addr));
			else {
				rt->rt_flags |= RTF_REJECT;
				rt->rt_expire += arpt_down;
				la->la_asked = 0;
			}

		}
d310 3
d317 3
a319 1
 * Common length and type checks are done here,
d322 3
a324 2
void
arpintr(void)
a325 1
	register struct mbuf *m;
a326 1
	int s;
d328 26
a353 22
	while (arpintrq.ifq_head) {
		s = splimp();
		IF_DEQUEUE(&arpintrq, m);
		splx(s);
		if (m == 0 || (m->m_flags & M_PKTHDR) == 0) {
			panic("arpintr");
			return;
		}
		if (m->m_len >= sizeof(struct arphdr) &&
		    (ar = mtod(m, struct arphdr *)) &&
		    ntohs(ar->ar_hrd) == ARPHRD_ETHER &&
		    m->m_len >=
		      sizeof(struct arphdr) + 2 * ar->ar_hln + 2 * ar->ar_pln)

			    switch (ntohs(ar->ar_pro)) {

			    case ETHERTYPE_IP:
			    case ETHERTYPE_IPTRAILERS:
				    in_arpinput(m);
				    continue;
			    }
		m_freem(m);
d355 6
d368 5
a372 5
 * We no longer handle negotiations for use of trailer protocol:
 * Formerly, ARP replied for protocol type ETHERTYPE_TRAIL sent
 * along with IP replies if we wanted trailers sent to us,
 * and also sent them in response to IP replies.
 * This allowed either end to announce the desire to receive
d374 2
a375 2
 * We no longer reply to requests for ETHERTYPE_TRAIL protocol either,
 * but formerly didn't normally send requests.
d377 2
a378 2
static void
in_arpinput(m)
a381 1
	register struct arpcom *ac = (struct arpcom *)m->m_pkthdr.rcvif;
d383 3
a385 4
	register struct llinfo_arp *la = 0;
	register struct rtentry *rt;
	struct in_ifaddr *ia, *maybe_ia = 0;
	struct sockaddr_dl *sdl;
d388 1
a388 1
	int op;
d390 1
d392 1
d394 2
a395 2
	(void)memcpy(&isaddr, ea->arp_spa, sizeof (isaddr));
	(void)memcpy(&itaddr, ea->arp_tpa, sizeof (itaddr));
d398 2
a399 1
	if (DODEBUG(DBGARP)) {
a406 10
	for (ia = in_ifaddr; ia; ia = ia->ia_next)
		if (ia->ia_ifp == &ac->ac_if) {
			maybe_ia = ia;
			if ((itaddr.s_addr == ia->ia_addr.sin_addr.s_addr) ||
			     (isaddr.s_addr == ia->ia_addr.sin_addr.s_addr))
				break;
		}
	if (maybe_ia == 0)
		goto out;
	myaddr = ia ? ia->ia_addr.sin_addr : maybe_ia->ia_addr.sin_addr;
d410 1
d413 4
a416 3
#ifdef DEBUG
		Printf("arp: ether address is broadcast for IP address %s!\n",
		       inet_ntoa(isaddr));
d424 2
a425 2
			"Duplicate IP address %s! sent from ethernet address: %s",
			inet_ntoa(isaddr), ether_sprintf(ea->arp_sha));
d428 3
a430 3
		log(LOG_ERR,
		    "duplicate IP address %s! sent from ethernet address: %s\n",
		    inet_ntoa(isaddr), ether_sprintf(ea->arp_sha));
d437 23
a459 18
	la = arplookup(isaddr.s_addr, itaddr.s_addr == myaddr.s_addr, 0);
	if (la && (rt = la->la_rt) && (sdl = SDL(rt->rt_gateway))) {
#ifdef DEBUG
		if (sdl->sdl_alen &&
		    bcmp((caddr_t)ea->arp_sha, LLADDR(sdl), sdl->sdl_alen))
			Printf("arp info overwritten for %s by %s\n",
			    inet_ntoa(isaddr), ether_sprintf(ea->arp_sha));
#endif
		(void)memcpy(LLADDR(sdl), ea->arp_sha, sizeof(ea->arp_sha));
		sdl->sdl_alen = sizeof(ea->arp_sha);
		if (rt->rt_expire)
			rt->rt_expire = time.tv_sec + arpt_keep;
		rt->rt_flags &= ~RTF_REJECT;
		la->la_asked = 0;
		if (la->la_hold) {
			(*ac->ac_if.if_output)(&ac->ac_if, la->la_hold,
				rt_key(rt), rt);
			la->la_hold = 0;
d462 1
d464 23
a486 4
	if (op != ARPOP_REQUEST) {
	out:
		m_freem(m);
		return;
d490 4
a493 2
		(void)memcpy(ea->arp_tha, ea->arp_sha, sizeof(ea->arp_sha));
		(void)memcpy(ea->arp_sha, ac->ac_enaddr, sizeof(ea->arp_sha));
d495 8
a502 4
		la = arplookup(itaddr.s_addr, 0, SIN_PROXY);
		if (la == NULL) {
#ifdef ARP_PROXYALL
			struct sockaddr_in sin;
d504 19
a522 26
			if(!arp_proxyall) goto out;

			bzero(&sin, sizeof sin);
			sin.sin_family = AF_INET;
			sin.sin_len = sizeof sin;
			sin.sin_addr = itaddr;

			rt = rtalloc1((struct sockaddr *)&sin, 0, 0UL);
			if( !rt )
				goto out;
			/*
			 * Don't send proxies for nodes on the same interface
			 * as this one came out of, or we'll get into a fight
			 * over who claims what Ether address.
			 */
			if(rt->rt_ifp == &ac->ac_if) {
				rtfree(rt);
				goto out;
			}
			(void)memcpy(ea->arp_tha, ea->arp_sha, sizeof(ea->arp_sha));
			(void)memcpy(ea->arp_sha, ac->ac_enaddr, sizeof(ea->arp_sha));
			rtfree(rt);
#ifdef DEBUG_PROXY
			printf("arp: proxying for %s\n",
			       inet_ntoa(itaddr));
#endif
d524 1
a524 1
			goto out;
a525 6
		} else {
			rt = la->la_rt;
			(void)memcpy(ea->arp_tha, ea->arp_sha, sizeof(ea->arp_sha));
			sdl = SDL(rt->rt_gateway);
			(void)memcpy(ea->arp_sha, LLADDR(sdl), sizeof(ea->arp_sha));
		}
a526 5

	(void)memcpy(ea->arp_tpa, ea->arp_spa, sizeof(ea->arp_spa));
	(void)memcpy(ea->arp_spa, &itaddr, sizeof(ea->arp_spa));
	ea->arp_op = htons(ARPOP_REPLY);
	ea->arp_pro = htons(ETHERTYPE_IP); /* let's be sure! */
d528 2
a529 1
	(void)memcpy(eh->ether_dhost, ea->arp_tha, sizeof(eh->ether_dhost));
d532 13
a544 2
	sa.sa_len = sizeof(sa);
	(*ac->ac_if.if_output)(&ac->ac_if, m, &sa, (struct rtentry *)0);
d551 2
a552 3
static void
arptfree(la)
	register struct llinfo_arp *la;
d554 9
a562 12
	register struct rtentry *rt = la->la_rt;
	register struct sockaddr_dl *sdl;
	if (rt == 0) {
		panic("arptfree");
		return;
	}
	if (rt->rt_refcnt > 0 && (sdl = SDL(rt->rt_gateway)) &&
	    sdl->sdl_family == AF_LINK) {
		sdl->sdl_alen = 0;
		la->la_asked = 0;
		rt->rt_flags &= ~RTF_REJECT;
		return;
d564 4
a567 2
	rtrequest(RTM_DELETE, rt_key(rt), (struct sockaddr *)0, rt_mask(rt),
			0, (struct rtentry **)0);
d569 1
d571 6
a576 1
 * Lookup or enter a new address in arptab.
d578 3
a580 4
static struct llinfo_arp *
arplookup(addr, create, proxy)
	u_long addr;
	int create, proxy;
d582 4
a585 17
	register struct rtentry *rt;
	static struct sockaddr_inarp sin = {sizeof(sin), AF_INET };
	const char *why = 0;

	sin.sin_addr.s_addr = addr;
	sin.sin_other = proxy ? SIN_PROXY : 0;
	rt = rtalloc1((struct sockaddr *)&sin, create, 0UL);
	if (rt == 0)
		return (0);
	rt->rt_refcnt--;

	if(rt->rt_flags & RTF_GATEWAY)
		why = "host is not on local network";
	else if((rt->rt_flags & RTF_LLINFO) == 0)
		why = "could not allocate llinfo";
	else if(rt->rt_gateway->sa_family != AF_LINK)
		why = "gateway route is not ours";
d587 17
a603 8
	if(why && create) {
#ifdef DEBUG
		Printf("arplookup %s failed: %s\n",
		    inet_ntoa(sin.sin_addr), why);
#endif
		return 0;
	} else if(why) {
		return 0;
d605 8
a612 1
	return ((struct llinfo_arp *)rt->rt_llinfo);
a614 1
int
d619 72
a690 1
	return (EOPNOTSUPP);
d693 6
a698 4
void
arp_ifinit(ac, ifa)
	struct arpcom *ac;
	struct ifaddr *ifa;
d700 12
a711 4
	ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;
	arpwhohas(ac, &ac->ac_ipaddr);
	ifa->ifa_rtrequest = arp_rtrequest;
	ifa->ifa_flags |= RTF_CLONING;
d713 2
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@RCS log keyword removed
@
text
@d10 1
a10 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d10 1
a10 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d1 4
a4 3
/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
d6 1
a6 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d8 1
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 11
a20 2
 *	@@(#)if_ether.c	8.1 (Berkeley) 6/10/93
 * $Id: if_ether.c,v 1.17.4.2 1996/02/20 17:55:04 fenner Exp $
a21 1

d23 15
a37 3
 * Ethernet address resolution protocol.
 * TODO:
 *	add "inuse/lock" bit (or ref. count) along with valid bit
a38 1

d41 15
a55 21
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/route.h>
#include <net/netisr.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
a57 1
#include "module.h"
d59 5
a63 3
#define SIN(s) ((struct sockaddr_in *)s)
#define SDL(s) ((struct sockaddr_dl *)s)
#define SRP(s) ((struct sockaddr_inarp *)s)
d71 2
d74 8
a81 31
/* timer values */
int	arpt_prune = (5*60*1);	/* walk list every 5 minutes */
int	arpt_keep = (20*60);	/* once resolved, good for 20 more minutes */
int	arpt_down = 20;		/* once declared down, don't send for 20 secs */
#define	rt_expire rt_rmx.rmx_expire

static	void arprequest(struct arpcom *, u_long *, u_long *, u_char *);
static	void arptfree(struct llinfo_arp *);
static	void arptimer(void *);
static	struct llinfo_arp *arplookup(u_long, int, int);
static	void in_arpinput(struct mbuf *);

#ifdef __riscos
struct	llinfo_arp llinfo_arp;
#else
struct	llinfo_arp llinfo_arp = {&llinfo_arp, &llinfo_arp};
#endif
struct	ifqueue arpintrq = {0, 0, 0, 50};
int	arp_inuse, arp_allocated, arp_intimer;
int	arp_maxtries = 5;
int	useloopback = 1;	/* use loopback interface for local traffic */
int	arpinit_done = 0;

#ifdef	ARP_PROXYALL
int	arp_proxyall = 1;
#endif

#ifdef __riscos
void arp_init()
{
	llinfo_arp.la_next = llinfo_arp.la_prev = &llinfo_arp;
a82 1
#endif
d84 4
a87 9
/*
 * Timeout routine.  Age arp_tab entries periodically.
 */
/* ARGSUSED */
static void
arptimer(ignored_arg)
	void *ignored_arg;
{
	register struct llinfo_arp *la = llinfo_arp.la_next;
d89 2
a90 8
	timeout(arptimer, (caddr_t)0, arpt_prune * hz);
	while (la != &llinfo_arp) {
		register struct rtentry *rt = la->la_rt;
		la = la->la_next;
		if (rt->rt_expire && rt->rt_expire <= time.tv_sec)
			arptfree(la->la_prev); /* timer has expired, clear */
	}
}
d93 1
a93 1
 * Parallel to llc_rtrequest.
d95 1
a95 5
static void
arp_rtrequest(req, rt, sa)
	int req;
	register struct rtentry *rt;
	struct sockaddr *sa;
d97 2
a98 11
	register struct sockaddr *gate = rt->rt_gateway;
	register struct llinfo_arp *la = (struct llinfo_arp *)rt->rt_llinfo;
	static struct sockaddr_dl null_sdl = {sizeof(null_sdl), AF_LINK};

	if (!arpinit_done) {
		arpinit_done = 1;
		timeout(arptimer, (caddr_t)0, hz);
	}
	if (rt->rt_flags & RTF_GATEWAY)
		return;
	switch (req) {
d100 16
a115 83
	case RTM_ADD:
		/*
		 * XXX: If this is a manually added route to interface
		 * such as older version of routed or gated might provide,
		 * restore cloning bit.
		 */
		if ((rt->rt_flags & RTF_HOST) == 0 &&
		    SIN(rt_mask(rt))->sin_addr.s_addr != 0xffffffff)
			rt->rt_flags |= RTF_CLONING;
		if (rt->rt_flags & RTF_CLONING) {
			/*
			 * Case 1: This route should come from a route to iface.
			 */
			rt_setgate(rt, rt_key(rt),
					(struct sockaddr *)&null_sdl);
			gate = rt->rt_gateway;
			SDL(gate)->sdl_type = rt->rt_ifp->if_type;
			SDL(gate)->sdl_index = rt->rt_ifp->if_index;
			rt->rt_expire = time.tv_sec;
			break;
		}
		/* Announce a new entry if requested. */
		if (rt->rt_flags & RTF_ANNOUNCE)
			arprequest((struct arpcom *)rt->rt_ifp,
			    &SIN(rt_key(rt))->sin_addr.s_addr,
			    &SIN(rt_key(rt))->sin_addr.s_addr,
			    (u_char *)LLADDR(SDL(gate)));
		/*FALLTHROUGH*/
	case RTM_RESOLVE:
		if (gate->sa_family != AF_LINK ||
		    gate->sa_len < sizeof(null_sdl)) {
			log(LOG_DEBUG, "arp_rtrequest: bad gateway value\n");
			break;
		}
		SDL(gate)->sdl_type = rt->rt_ifp->if_type;
		SDL(gate)->sdl_index = rt->rt_ifp->if_index;
		if (la != 0)
			break; /* This happens on a route change */
		/*
		 * Case 2:  This route may come from cloning, or a manual route
		 * add with a LL address.
		 */
		R_Malloc(la, struct llinfo_arp *, sizeof(*la));
		rt->rt_llinfo = (caddr_t)la;
		if (la == 0) {
			log(LOG_DEBUG, "arp_rtrequest: malloc failed\n");
			break;
		}
		arp_inuse++, arp_allocated++;
		Bzero(la, sizeof(*la));
		la->la_rt = rt;
		rt->rt_flags |= RTF_LLINFO;
		insque(la, &llinfo_arp);
		if (SIN(rt_key(rt))->sin_addr.s_addr ==
		    (IA_SIN(rt->rt_ifa))->sin_addr.s_addr) {
		    /*
		     * This test used to be
		     *	if (loif.if_flags & IFF_UP)
		     * It allowed local traffic to be forced
		     * through the hardware by configuring the loopback down.
		     * However, it causes problems during network configuration
		     * for boards that can't receive packets they send.
		     * It is now necessary to clear "useloopback" and remove
		     * the route to force traffic out to the hardware.
		     */
			rt->rt_expire = 0;
			Bcopy(((struct arpcom *)rt->rt_ifp)->ac_enaddr,
				LLADDR(SDL(gate)), SDL(gate)->sdl_alen = 6);
			if (useloopback)
				rt->rt_ifp = loif;
		}
		break;

	case RTM_DELETE:
		if (la == 0)
			break;
		arp_inuse--;
		remque(la);
		rt->rt_llinfo = 0;
		rt->rt_flags &= ~RTF_LLINFO;
		if (la->la_hold)
			m_freem(la->la_hold);
		Free((caddr_t)la);
a121 1
void
d124 1
a124 16
	register struct in_addr *addr;
{
	arprequest(ac, &ac->ac_ipaddr.s_addr, &addr->s_addr, ac->ac_enaddr);
}

/*
 * Broadcast an ARP request. Caller specifies:
 *	- arp header source ip address
 *	- arp header target ip address
 *	- arp header source ethernet address
 */
static void
arprequest(ac, sip, tip, enaddr)
	register struct arpcom *ac;
	register u_long *sip, *tip;
	register u_char *enaddr;
d131 2
a132 1
	if ((m = m_gethdr(M_DONTWAIT, MT_DATA)) == NULL)
d134 11
d146 1
a146 2
	m->m_pkthdr.len = sizeof(*ea);
	MH_ALIGN(m, sizeof(*ea));
d150 2
a151 1
	(void)memcpy(eh->ether_dhost, etherbroadcastaddr, sizeof(eh->ether_dhost));
d158 5
a162 3
	(void)memcpy(ea->arp_sha, enaddr, sizeof(ea->arp_sha));
	(void)memcpy(ea->arp_spa, sip, sizeof(ea->arp_spa));
	(void)memcpy(ea->arp_tpa, tip, sizeof(ea->arp_tpa));
d164 1
a164 2
	sa.sa_len = sizeof(sa);
	(*ac->ac_if.if_output)(&ac->ac_if, m, &sa, (struct rtentry *)0);
d170 1
a170 34
#ifdef __riscos
/*
 * Return the host portion of an internet address.
 */
u_long
in_lnaof(in)
	struct in_addr in;
{
	register u_long i = ntohl(in.s_addr);
	register u_long net, host;
	register struct in_ifaddr *ia;

	if (IN_CLASSA(i)) {
		net = i & IN_CLASSA_NET;
		host = i & IN_CLASSA_HOST;
	} else if (IN_CLASSB(i)) {
		net = i & IN_CLASSB_NET;
		host = i & IN_CLASSB_HOST;
	} else if (IN_CLASSC(i)) {
		net = i & IN_CLASSC_NET;
		host = i & IN_CLASSC_HOST;
	} else
		return (i);

	/*
	 * Check whether network is a subnet;
	 * if so, use the modified interpretation of `host'.
	 */
	for (ia = in_ifaddr; ia; ia = ia->ia_next)
		if (net == ia->ia_net)
			return (host &~ ia->ia_subnetmask);
	return (host);
}
#endif
d174 1
a174 1
 * desten is filled in.  If there is no entry in arptab,
d177 1
a177 1
 * is finally resolved.  A return value of 1 indicates
d181 4
d186 1
a186 2
int
arpresolve(ac, rt, m, dst, desten, rt0)
a187 1
	register struct rtentry *rt;
d189 1
a189 1
	register struct sockaddr *dst;
d191 1
a191 1
	struct rtentry *rt0;
d193 7
a199 2
	register struct llinfo_arp *la;
	struct sockaddr_dl *sdl;
d201 25
a225 2
	if (m->m_flags & M_BCAST) {	/* broadcast address */
		(void)memcpy(desten, etherbroadcastaddr, sizeof(etherbroadcastaddr));
d228 7
a234 4
#ifdef MULTICAST
	if (m->m_flags & M_MCAST) {	/* multicast */
		ETHER_MAP_IP_MULTICAST(&SIN(dst)->sin_addr, desten);
		return(1);
d237 25
a261 12
	/* Can't transmit multicast! */
	if (m->m_flags & M_MCAST)
		return (0);
#endif
#ifdef __riscos
	if (ac->ac_if.if_flags & IFF_NOARP) {
		u_long lna = in_lnaof(SIN(dst)->sin_addr);
		memcpy(desten, ac->ac_enaddr, 3);
		desten[3] = (lna >> 16) & 0x7f;
		desten[4] = (lna >> 8) & 0xff;
		desten[5] = lna & 0xff;
		return (1);
d264 23
a286 6
	if (rt)
		la = (struct llinfo_arp *)rt->rt_llinfo;
	else {
		la = arplookup(SIN(dst)->sin_addr.s_addr, 1, 0);
		if (la)
			rt = la->la_rt;
d288 8
a295 17
	if (la == 0 || rt == 0) {
#ifdef DEBUG
		Printf("arpresolve: can't allocate llinfo for %s\n",
			inet_ntoa(SIN(dst)->sin_addr));
#endif
		m_freem(m);
		return (0);
	}
	sdl = SDL(rt->rt_gateway);
	/*
	 * Check the address family and length is valid, the address
	 * is resolved; otherwise, try to resolve.
	 */
	if ((rt->rt_expire == 0 || rt->rt_expire > time.tv_sec) &&
	    sdl->sdl_family == AF_LINK && sdl->sdl_alen != 0) {
		(void)memcpy(desten, LLADDR(sdl), sdl->sdl_alen);
		return 1;
d302 7
a308 16
	if (la->la_hold)
		m_freem(la->la_hold);
	la->la_hold = ENSURE_SAFE(m);   /* Necessary because of UDP hack */
	if (rt->rt_expire) {
		rt->rt_flags &= ~RTF_REJECT;
		if (la->la_asked == 0 || rt->rt_expire != time.tv_sec) {
			rt->rt_expire = time.tv_sec;
			if (la->la_asked++ < arp_maxtries)
				arpwhohas(ac, &(SIN(dst)->sin_addr));
			else {
				rt->rt_flags |= RTF_REJECT;
				rt->rt_expire += arpt_down;
				la->la_asked = 0;
			}

		}
d310 3
d317 3
a319 1
 * Common length and type checks are done here,
d322 3
a324 2
void
arpintr(void)
a325 1
	register struct mbuf *m;
a326 1
	int s;
d328 26
a353 22
	while (arpintrq.ifq_head) {
		s = splimp();
		IF_DEQUEUE(&arpintrq, m);
		splx(s);
		if (m == 0 || (m->m_flags & M_PKTHDR) == 0) {
			panic("arpintr");
			return;
		}
		if (m->m_len >= sizeof(struct arphdr) &&
		    (ar = mtod(m, struct arphdr *)) &&
		    ntohs(ar->ar_hrd) == ARPHRD_ETHER &&
		    m->m_len >=
		      sizeof(struct arphdr) + 2 * ar->ar_hln + 2 * ar->ar_pln)

			    switch (ntohs(ar->ar_pro)) {

			    case ETHERTYPE_IP:
			    case ETHERTYPE_IPTRAILERS:
				    in_arpinput(m);
				    continue;
			    }
		m_freem(m);
d355 6
d368 5
a372 5
 * We no longer handle negotiations for use of trailer protocol:
 * Formerly, ARP replied for protocol type ETHERTYPE_TRAIL sent
 * along with IP replies if we wanted trailers sent to us,
 * and also sent them in response to IP replies.
 * This allowed either end to announce the desire to receive
d374 2
a375 2
 * We no longer reply to requests for ETHERTYPE_TRAIL protocol either,
 * but formerly didn't normally send requests.
d377 2
a378 2
static void
in_arpinput(m)
a381 1
	register struct arpcom *ac = (struct arpcom *)m->m_pkthdr.rcvif;
d383 3
a385 4
	register struct llinfo_arp *la = 0;
	register struct rtentry *rt;
	struct in_ifaddr *ia, *maybe_ia = 0;
	struct sockaddr_dl *sdl;
d388 1
a388 1
	int op;
d390 1
d392 1
d394 2
a395 2
	(void)memcpy(&isaddr, ea->arp_spa, sizeof (isaddr));
	(void)memcpy(&itaddr, ea->arp_tpa, sizeof (itaddr));
d398 2
a399 1
	if (DODEBUG(DBGARP)) {
a406 10
	for (ia = in_ifaddr; ia; ia = ia->ia_next)
		if (ia->ia_ifp == &ac->ac_if) {
			maybe_ia = ia;
			if ((itaddr.s_addr == ia->ia_addr.sin_addr.s_addr) ||
			     (isaddr.s_addr == ia->ia_addr.sin_addr.s_addr))
				break;
		}
	if (maybe_ia == 0)
		goto out;
	myaddr = ia ? ia->ia_addr.sin_addr : maybe_ia->ia_addr.sin_addr;
d410 1
d413 4
a416 3
#ifdef DEBUG
		Printf("arp: ether address is broadcast for IP address %s!\n",
		       inet_ntoa(isaddr));
d424 2
a425 2
			"Duplicate IP address %s! sent from ethernet address: %s",
			inet_ntoa(isaddr), ether_sprintf(ea->arp_sha));
d428 3
a430 3
		log(LOG_ERR,
		    "duplicate IP address %s! sent from ethernet address: %s\n",
		    inet_ntoa(isaddr), ether_sprintf(ea->arp_sha));
d437 23
a459 18
	la = arplookup(isaddr.s_addr, itaddr.s_addr == myaddr.s_addr, 0);
	if (la && (rt = la->la_rt) && (sdl = SDL(rt->rt_gateway))) {
#ifdef DEBUG
		if (sdl->sdl_alen &&
		    bcmp((caddr_t)ea->arp_sha, LLADDR(sdl), sdl->sdl_alen))
			Printf("arp info overwritten for %s by %s\n",
			    inet_ntoa(isaddr), ether_sprintf(ea->arp_sha));
#endif
		(void)memcpy(LLADDR(sdl), ea->arp_sha, sizeof(ea->arp_sha));
		sdl->sdl_alen = sizeof(ea->arp_sha);
		if (rt->rt_expire)
			rt->rt_expire = time.tv_sec + arpt_keep;
		rt->rt_flags &= ~RTF_REJECT;
		la->la_asked = 0;
		if (la->la_hold) {
			(*ac->ac_if.if_output)(&ac->ac_if, la->la_hold,
				rt_key(rt), rt);
			la->la_hold = 0;
d462 1
d464 23
a486 4
	if (op != ARPOP_REQUEST) {
	out:
		m_freem(m);
		return;
d490 4
a493 2
		(void)memcpy(ea->arp_tha, ea->arp_sha, sizeof(ea->arp_sha));
		(void)memcpy(ea->arp_sha, ac->ac_enaddr, sizeof(ea->arp_sha));
d495 8
a502 4
		la = arplookup(itaddr.s_addr, 0, SIN_PROXY);
		if (la == NULL) {
#ifdef ARP_PROXYALL
			struct sockaddr_in sin;
d504 19
a522 26
			if(!arp_proxyall) goto out;

			bzero(&sin, sizeof sin);
			sin.sin_family = AF_INET;
			sin.sin_len = sizeof sin;
			sin.sin_addr = itaddr;

			rt = rtalloc1((struct sockaddr *)&sin, 0, 0UL);
			if( !rt )
				goto out;
			/*
			 * Don't send proxies for nodes on the same interface
			 * as this one came out of, or we'll get into a fight
			 * over who claims what Ether address.
			 */
			if(rt->rt_ifp == &ac->ac_if) {
				rtfree(rt);
				goto out;
			}
			(void)memcpy(ea->arp_tha, ea->arp_sha, sizeof(ea->arp_sha));
			(void)memcpy(ea->arp_sha, ac->ac_enaddr, sizeof(ea->arp_sha));
			rtfree(rt);
#ifdef DEBUG_PROXY
			printf("arp: proxying for %s\n",
			       inet_ntoa(itaddr));
#endif
d524 1
a524 1
			goto out;
a525 6
		} else {
			rt = la->la_rt;
			(void)memcpy(ea->arp_tha, ea->arp_sha, sizeof(ea->arp_sha));
			sdl = SDL(rt->rt_gateway);
			(void)memcpy(ea->arp_sha, LLADDR(sdl), sizeof(ea->arp_sha));
		}
a526 5

	(void)memcpy(ea->arp_tpa, ea->arp_spa, sizeof(ea->arp_spa));
	(void)memcpy(ea->arp_spa, &itaddr, sizeof(ea->arp_spa));
	ea->arp_op = htons(ARPOP_REPLY);
	ea->arp_pro = htons(ETHERTYPE_IP); /* let's be sure! */
d528 2
a529 1
	(void)memcpy(eh->ether_dhost, ea->arp_tha, sizeof(eh->ether_dhost));
d532 13
a544 2
	sa.sa_len = sizeof(sa);
	(*ac->ac_if.if_output)(&ac->ac_if, m, &sa, (struct rtentry *)0);
d551 2
a552 3
static void
arptfree(la)
	register struct llinfo_arp *la;
d554 9
a562 12
	register struct rtentry *rt = la->la_rt;
	register struct sockaddr_dl *sdl;
	if (rt == 0) {
		panic("arptfree");
		return;
	}
	if (rt->rt_refcnt > 0 && (sdl = SDL(rt->rt_gateway)) &&
	    sdl->sdl_family == AF_LINK) {
		sdl->sdl_alen = 0;
		la->la_asked = 0;
		rt->rt_flags &= ~RTF_REJECT;
		return;
d564 4
a567 2
	rtrequest(RTM_DELETE, rt_key(rt), (struct sockaddr *)0, rt_mask(rt),
			0, (struct rtentry **)0);
d569 1
d571 6
a576 1
 * Lookup or enter a new address in arptab.
d578 3
a580 4
static struct llinfo_arp *
arplookup(addr, create, proxy)
	u_long addr;
	int create, proxy;
d582 4
a585 17
	register struct rtentry *rt;
	static struct sockaddr_inarp sin = {sizeof(sin), AF_INET };
	const char *why = 0;

	sin.sin_addr.s_addr = addr;
	sin.sin_other = proxy ? SIN_PROXY : 0;
	rt = rtalloc1((struct sockaddr *)&sin, create, 0UL);
	if (rt == 0)
		return (0);
	rt->rt_refcnt--;

	if(rt->rt_flags & RTF_GATEWAY)
		why = "host is not on local network";
	else if((rt->rt_flags & RTF_LLINFO) == 0)
		why = "could not allocate llinfo";
	else if(rt->rt_gateway->sa_family != AF_LINK)
		why = "gateway route is not ours";
d587 17
a603 8
	if(why && create) {
#ifdef DEBUG
		Printf("arplookup %s failed: %s\n",
		    inet_ntoa(sin.sin_addr), why);
#endif
		return 0;
	} else if(why) {
		return 0;
d605 8
a612 1
	return ((struct llinfo_arp *)rt->rt_llinfo);
a614 1
int
d619 72
a690 1
	return (EOPNOTSUPP);
d693 6
a698 4
void
arp_ifinit(ac, ifa)
	struct arpcom *ac;
	struct ifaddr *ifa;
d700 12
a711 4
	ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;
	arpwhohas(ac, &ac->ac_ipaddr);
	ifa->ifa_rtrequest = arp_rtrequest;
	ifa->ifa_flags |= RTF_CLONING;
d713 2
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d10 1
a10 1
 * :RCS Log discontinued:
@

head	4.7;
access;
symbols
	Internet-5_65:4.7
	Internet-5_64:4.7
	Internet-5_63:4.7
	Internet-5_62:4.7
	Internet-5_61:4.7
	Internet-5_60:4.7
	Internet-5_59:4.7
	Internet-5_58:4.7
	Internet-5_57:4.7
	Internet-5_56:4.7
	Internet-5_55:4.7
	Internet-5_54:4.7
	Internet-5_53:4.7
	Internet-5_52:4.7
	Internet-5_51:4.7
	Internet-5_50:4.7
	RO_5_07:4.7
	Internet-5_49:4.7
	Internet-5_48:4.7
	Internet-5_47:4.7
	Internet-5_46:4.7
	Internet-5_45:4.6
	Internet-5_44:4.6
	Internet-5_43:4.6
	Internet-5_42:4.6
	Internet-5_41:4.6
	Internet-5_40:4.6
	Internet-5_39:4.6
	Internet-5_38:4.6
	Internet-5_37:4.6
	Internet-5_36:4.6
	Internet-5_35:4.6
	Internet-5_34:4.6
	Internet-5_33:4.6
	Internet-5_32:4.5
	Internet-5_31:4.4
	Internet-5_30:4.4
	Internet-5_29:4.4
	Internet-5_27:4.3
	Internet-5_26:4.2
	Internet-5_25:4.2
	Internet-5_24:4.2
	Internet-5_23:4.2
	Internet-5_22:4.2
	Internet-5_21:4.2
	Internet-5_20:4.2
	Internet-5_19:4.2
	Internet-5_18:4.2
	Internet-5_17:4.2
	Internet-5_16:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Internet-5_15:4.2
	Internet-5_14:4.2
	Internet-5_13:4.2
	sforrest_daytona_appflash-0_31:4.2
	Internet-5_12:4.2
	Internet-5_11:4.2
	celkins_Internet-5_10:4.2
	nicke_Internat_25-9-98:4.2
	Internet-5_09:4.2
	blaughto_daytona_appflash-0_30:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rwarren_Internet-5_08:4.2
	Spinner:4.2
	Internet_5_07:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.2
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.7
date	2003.11.13.18.02.12;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	99.07.22.08.37.29;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.07.21.10.47.20;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.07.08.15.25.37;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.06.30.13.15.35;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.58.54;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.08;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.08;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.20.08;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.28.20;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.06.50;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.23;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.06.44;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.35;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.38.30;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.21;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.7
log
@Commit of two years' worth of changes.
Upped version number, because it's about time it was.

Version 5.46. Tagged as 'Internet-5_46'
@
text
@/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#define _IP_VHL

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/errno.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>

#include <netinet/ip_fw.h>

#ifdef vax
#include "machine/mtpr.h"
#endif
#include <machine/in_cksum.h>

#include "svcdebug.h"
#include "debug.h"
#include "module.h"

u_short ip_id;

static struct mbuf *ip_insertoptions(struct mbuf *, struct mbuf *, int *);
#ifdef MULTICAST
static void ip_mloopback
	(struct ifnet *, struct mbuf *, struct sockaddr_in *);
static int	ip_getmoptions
	(int, struct ip_moptions *, struct mbuf **);
static int	ip_setmoptions
	(int, struct ip_moptions **, struct mbuf *);
#endif
static int	ip_optcopy(struct ip *, struct ip *);
static int	ip_pcbopts(struct mbuf **, struct mbuf *);

/*
 * IP output.  The packet in mbuf chain m contains a skeletal IP
 * header (with len, off, ttl, proto, tos, src, dst).
 * The mbuf chain containing the packet will be freed.
 * The mbuf opt, if present, will not be freed.
 */
int
ip_output(m0, opt, ro, flags, imo)
	struct mbuf *m0;
	struct mbuf *opt;
	struct route *ro;
	int flags;
	struct ip_moptions *imo;
{
	struct ip *ip, *mhip;
	struct ifnet *ifp;
	struct mbuf *m = m0;
	int hlen = sizeof (struct ip);
	int len, off, error = 0;
	struct sockaddr_in *dst;
	struct in_ifaddr *ia;
	int isbroadcast;

#ifdef DEBUG
	    if( DODEBUG((1 << 16)) )
	    {
		int i = 0;
		struct mbuf *m1;

		Printf("\021\003ip_output Packet Dump:\n");

		for( m1 = m0; m1; m1 = m1->m_next )
		{
		    int j;
		    u_char *cptr = mtod(m1, u_char *);

		    for( j = 0; j < m1->m_len; ++j )
		    {
			Printf("%02x", *cptr++);

			if( !(++i % 32) )
			    Printf("\n");
			else if( !(i % 4) )
			    Printf("  ");
		    }
		}

		if( (i % 32) )
		    Printf("\021\007\n");
	    Printf("\021\07\n");
	    Printf("   ro=%x, ro->ro_rt=%x, ro->ro_dst.sa_family=%d\n", ro, ro->ro_rt, ro->ro_dst.sa_family);
	    }
#endif
#ifdef DIAGNOSTIC
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("ip_output no HDR");
	if (!ro)
		panic("ip_output no route, proto = %d",
		      mtod(m, struct ip *)->ip_p);
#endif
	if (opt) {
		m = ip_insertoptions(m, opt, &len);
#ifdef DEBUG
Printf("Inserted options: m=%x\n", m);
#endif
		hlen = len;
	}
	ip = mtod(m, struct ip *);
	/*
	 * Fill in IP header.
	 */
	if ((flags & (IP_FORWARDING|IP_RAWOUTPUT)) == 0) {
		ip->ip_vhl = IP_MAKE_VHL(IPVERSION, hlen >> 2);
		ip->ip_off &= IP_DF;
		ip->ip_id = htons(ip_id++);
		ipstat.ips_localout++;
	} else {
		hlen = IP_VHL_HL(ip->ip_vhl) << 2;
        }

	dst = (struct sockaddr_in *)&ro->ro_dst;
	/*
	 * If there is a cached route,
	 * check that it is to the same destination
	 * and is still up.  If not, free it and try again.
	 */
	if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
	   dst->sin_addr.s_addr != ip->ip_dst.s_addr)) {
		RTFREE(ro->ro_rt);
		ro->ro_rt = (struct rtentry *)0;
	}
	if (ro->ro_rt == 0) {
		dst->sin_family = AF_INET;
		dst->sin_len = sizeof(*dst);
		dst->sin_addr = ip->ip_dst;
	}
	/*
	 * If routing to interface only,
	 * short circuit routing lookup.
	 */
#define ifatoia(ifa)	((struct in_ifaddr *)(ifa))
#define sintosa(sin)	((struct sockaddr *)(sin))
	if (flags & IP_ROUTETOIF) {
		if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst)))) == 0 &&
		    (ia = ifatoia(ifa_ifwithnet(sintosa(dst)))) == 0) {
			ipstat.ips_noroute++;
			error = ENETUNREACH;
			goto bad;
		}
		ifp = ia->ia_ifp;
		ip->ip_ttl = 1;
		isbroadcast = in_broadcast(dst->sin_addr, ifp);
#if 0 || !MULTICAST
	} else {
#else
/* KJB fix - shouldn't need a route to send a multicast on a specified
 * interface.
 */
	} else if (!(imo && imo->imo_multicast_ifp &&
		   IN_MULTICAST(ntohl(ip->ip_dst.s_addr)))) {
#endif
		/*
		 * If this is the case, we probably don't want to allocate
		 * a protocol-cloned route since we didn't get one from the
		 * ULP.  This lets TCP do its thing, while not burdening
		 * forwarding or ICMP with the overhead of cloning a route.
		 * Of course, we still want to do any cloning requested by
		 * the link layer, as this is probably required in all cases
		 * for correct operation (as it is for ARP).
		 */
		if (ro->ro_rt == 0)
			rtalloc_ign(ro, RTF_PRCLONING);
		if (ro->ro_rt == 0) {
			ipstat.ips_noroute++;
			error = EHOSTUNREACH;
			goto bad;
		}
		ia = ifatoia(ro->ro_rt->rt_ifa);
		ifp = ro->ro_rt->rt_ifp;
		ro->ro_rt->rt_use++;
		if (ro->ro_rt->rt_flags & RTF_GATEWAY)
			dst = (struct sockaddr_in *)ro->ro_rt->rt_gateway;
#ifdef NotYet
		if (ro->ro_rt->rt_flags & RTF_HOST)
			isbroadcast = (ro->ro_rt->rt_flags & RTF_BROADCAST);
		else
			isbroadcast = in_broadcast(dst->sin_addr, ifp);
#else
		isbroadcast = in_broadcast(dst->sin_addr, ifp);
#endif
	}
#ifdef MULTICAST
	if (IN_MULTICAST(ntohl(ip->ip_dst.s_addr))) {
		struct in_multi *inm;

		m->m_flags |= M_MCAST;
		/*
		 * IP destination address is multicast.  Make sure "dst"
		 * still points to the address in "ro".  (It may have been
		 * changed to point to a gateway address, above.)
		 */
		dst = (struct sockaddr_in *)&ro->ro_dst;
		/*
		 * See if the caller provided any multicast options
		 */
		if (imo != NULL) {
			ip->ip_ttl = imo->imo_multicast_ttl;
			if (imo->imo_multicast_ifp != NULL)
				ifp = imo->imo_multicast_ifp;
			if (imo->imo_multicast_vif != -1)
				ip->ip_src.s_addr =
				    ip_mcast_src(imo->imo_multicast_vif);
		} else
			ip->ip_ttl = IP_DEFAULT_MULTICAST_TTL;
		/*
		 * Confirm that the outgoing interface supports multicast.
		 */
		if ((imo == NULL) || (imo->imo_multicast_vif == -1)) {
			if ((ifp->if_flags & IFF_MULTICAST) == 0) {
				ipstat.ips_noroute++;
				error = ENETUNREACH;
				goto bad;
			}
		}
		/*
		 * If source address not specified yet, use address
		 * of outgoing interface.
		 */
		if (ip->ip_src.s_addr == INADDR_ANY) {
			register struct in_ifaddr *ia;

			for (ia = in_ifaddr; ia; ia = ia->ia_next)
				if (ia->ia_ifp == ifp) {
					ip->ip_src = IA_SIN(ia)->sin_addr;
					break;
				}
		}

		IN_LOOKUP_MULTI(ip->ip_dst, ifp, inm);
		if (inm != NULL &&
		   (imo == NULL || imo->imo_multicast_loop)) {
			/*
			 * If we belong to the destination multicast group
			 * on the outgoing interface, and the caller did not
			 * forbid loopback, loop back a copy.
			 */
			ip_mloopback(ifp, m, dst);
		}
		else {
			/*
			 * If we are acting as a multicast router, perform
			 * multicast forwarding as if the packet had just
			 * arrived on the interface to which we are about
			 * to send.  The multicast forwarding function
			 * recursively calls this function, using the
			 * IP_FORWARDING flag to prevent infinite recursion.
			 *
			 * Multicasts that are looped back by ip_mloopback(),
			 * above, will be forwarded by the ip_input() routine,
			 * if necessary.
			 */
			if (ip_mrouter && (flags & IP_FORWARDING) == 0) {
				/*
				 * Check if rsvp daemon is running. If not, don't
				 * set ip_moptions. This ensures that the packet
				 * is multicast and not just sent down one link
				 * as prescribed by rsvpd.
				 */
				if (!rsvp_on)
				  imo = NULL;
				if (ip_mforward(ip, ifp, m, imo) != 0) {
					m_freem(m);
					goto done;
				}
			}
		}
		/*
		 * Multicasts with a time-to-live of zero may be looped-
		 * back, above, but must not be transmitted on a network.
		 * Also, multicasts addressed to the loopback interface
		 * are not sent -- the above call to ip_mloopback() will
		 * loop back a copy if this host actually belongs to the
		 * destination group on the loopback interface.
		 */
		if (ip->ip_ttl == 0 || ifp->if_flags & IFF_LOOPBACK) {
			m_freem(m);
			goto done;
		}

		goto sendit;
	}
#endif
#ifndef notdef
	/*
	 * If source address not specified yet, use address
	 * of outgoing interface.
	 */
	if (ip->ip_src.s_addr == INADDR_ANY)
		ip->ip_src = IA_SIN(ia)->sin_addr;
#endif
#ifndef __riscos
        /*
         * Irrelevant as we don't actually queue the packets
         */
	/*
	 * Verify that we have any chance at all of being able to queue
	 *      the packet or packet fragments
	 */
	if ((ifp->if_snd.ifq_len + ip->ip_len / ifp->if_mtu + 1) >=
		ifp->if_snd.ifq_maxlen) {
			error = ENOBUFS;
			goto bad;
	}
#endif

	/*
	 * Look for broadcast address and
	 * and verify user is allowed to send
	 * such a packet.
	 */
	if (isbroadcast) {
		if ((ifp->if_flags & IFF_BROADCAST) == 0) {
			error = EADDRNOTAVAIL;
			goto bad;
		}
		if ((flags & IP_ALLOWBROADCAST) == 0) {
			error = EACCES;
			goto bad;
		}
		/* don't allow broadcast messages to be fragmented */
		if ((u_short)ip->ip_len > ifp->if_mtu) {
			error = EMSGSIZE;
			goto bad;
		}
		m->m_flags |= M_BCAST;
	} else {
		m->m_flags &= ~M_BCAST;
	}

sendit:
#ifdef IPFIREWALL
	/*
	 * Check with the firewall...
	 */
	if (ip_fw_chk_ptr && !(*ip_fw_chk_ptr)(&ip, hlen, ifp, 1, &m)) {
		error = EACCES;
		goto done;
	}
#endif

	/*
	 * If small enough for interface, can just send directly.
	 */
	if ((u_short)ip->ip_len <= ifp->if_mtu) {
		ip->ip_len = htons((u_short)ip->ip_len);
		ip->ip_off = htons((u_short)ip->ip_off);
		ip->ip_sum = 0;
		if (ip->ip_vhl == IP_VHL_BORING) {
			ip->ip_sum = in_cksum_hdr(ip);
		} else {
			ip->ip_sum = in_cksum(m, hlen);
		}
		error = (*ifp->if_output)(ifp, m,
				(struct sockaddr *)dst, ro->ro_rt);
#if 0
Printf("\x11\x03ip_output: fired directly; error=%d\n", error);
#endif
		goto done;
	}
	/*
	 * Too large for interface; fragment if possible.
	 * Must be able to put at least 8 bytes per fragment.
	 */
	if (ip->ip_off & IP_DF) {
		error = EMSGSIZE;
		ipstat.ips_cantfrag++;
		goto bad;
	}
	len = (ifp->if_mtu - hlen) &~ 7;
	if (len < 8) {
		error = EMSGSIZE;
		/*
		 * This case can happen if the user changed the MTU
		 * of an interface after enabling IP on it.  Because
		 * most netifs don't keep track of routes pointing to
		 * them, there is no way for one to update all its
		 * routes when the MTU is changed.
		 */
		if ((ro->ro_rt->rt_flags & (RTF_UP | RTF_HOST))
		    && !(ro->ro_rt->rt_rmx.rmx_locks & RTV_MTU)
		    && (ro->ro_rt->rt_rmx.rmx_mtu > ifp->if_mtu)) {
			ro->ro_rt->rt_rmx.rmx_mtu = ifp->if_mtu;
		}
		goto bad;
	}

    {
	int mhlen, firstlen = len;
	struct mbuf *master = NULL;
	struct mbuf **mnext = &m->m_nextpkt;

	/*
	 * Loop through length of segment after first fragment,
	 * make new header and copy data of each part and link onto chain.
	 */
	m0 = m;
	mhlen = sizeof (struct ip);
	for (off = hlen + len; off < (u_short)ip->ip_len; off += len) {
		MGETHDR(m, M_DONTWAIT, MT_HEADER);
		if (m == 0) {
#ifdef DEBUG
		        if( DODEBUG(DBGMMAN) )
				Printf("ip_output: ALLOC_S failed\n");
#endif
			error = ENOBUFS;
			ipstat.ips_odropped++;
			goto sendorfree;
		}
		m->m_off += max_linkhdr;
		mhip = mtod(m, struct ip *);
		*mhip = *ip;
		if (hlen > sizeof (struct ip)) {
			mhlen = ip_optcopy(ip, mhip) + sizeof (struct ip);
			mhip->ip_vhl = IP_MAKE_VHL(IPVERSION, mhlen >> 2);
		}
		m->m_len = mhlen;
		mhip->ip_off = ((off - hlen) >> 3) + (ip->ip_off & ~IP_MF);
		if (ip->ip_off & IP_MF)
			mhip->ip_off |= IP_MF;
		if (off + len >= (u_short)ip->ip_len)
			len = (u_short)ip->ip_len - off;
		else
			mhip->ip_off |= IP_MF;
		mhip->ip_len = htons((u_short)(len + mhlen));
#ifdef OldCode
		m->m_next = m_copy(m0, off, len);
#else
		/*
		 * XXX
		 *
		 * make an unsafe copy of the chain, and keep control
		 * of the master chain here, ready for freeing after
		 * the low-level output routines have returned.
		 */
		m->m_next = COPY_U(m0, off, len);
#endif
		if (m->m_next == 0) {
#ifdef OldCode
			(void) m_free(m);
#endif
			error = ENOBUFS;	/* ??? */
			ipstat.ips_odropped++;
			goto sendorfree;
		}
		m->m_pkthdr.len = mhlen + len;
		m->m_pkthdr.rcvif = (struct ifnet *)0;
		mhip->ip_off = htons((u_short)mhip->ip_off);
		mhip->ip_sum = 0;
		if (mhip->ip_vhl == IP_VHL_BORING) {
			mhip->ip_sum = in_cksum_hdr(mhip);    /* KJB fix */
		} else {
			mhip->ip_sum = in_cksum(m, mhlen);
		}
		*mnext = m;
		mnext = &m->m_nextpkt;
		ipstat.ips_ofragments++;
	}
	/*
	 * Update first fragment by trimming what's been copied out
	 * and updating header, then send each fragment (in order).
	 */
	m = m0;
#ifdef OldCode
	m_adj(m, hlen + firstlen - (u_short)ip->ip_len);
#else
	/*
	 * make an unsafe copy of the first fragment, and send this;
	 * keep control of the master chain in this routine
	 */
	master = m;

	TRIM(m, hlen + firstlen - (u_short)ip->ip_len, NULL);

	if( (m = COPY_U(master, 0, M_COPYALL)) == NULL )
	{
	    error = ENOBUFS;
	    goto sendorfree;
	}

	/*
	 * Mbuf Manager 0.22 and earlier fail to copy m_flags.
	 * We only really care about the flags of the first
	 * mbuf of the first fragment, as the output routines
	 * inspect it for the M_MCAST/M_BCAST flags.
	 */
	m->m_flags = master->m_flags;

	/*
	 * unsafe copy made - move the list
	 * of fragments onto m0
	 */
	m->m_list = master->m_list;
	master->m_list = NULL;
#endif
	m->m_pkthdr.len = hlen + firstlen;
	ip->ip_len = htons((u_short)m->m_pkthdr.len);
	ip->ip_off = htons((u_short)(ip->ip_off | IP_MF));
	ip->ip_sum = 0;
	if (ip->ip_vhl == IP_VHL_BORING) {
		ip->ip_sum = in_cksum_hdr(ip);
	} else {
		ip->ip_sum = in_cksum(m, hlen);
	}
sendorfree:
#ifdef OldCode
	for (m = m0; m; m = m0) {
		m0 = m->m_list;
		m->m_list = 0;
		if (error == 0)
			error = (*ifp->if_output)(ifp, m,
			    (struct sockaddr *)dst, ro->ro_rt);
		else
			m_freem(m);
	}
#else
	/*
	 * under DCI 4, we can pass all the mbuf chains linked on
	 * m_act via one call to the driver's transmit routine, so
	 * don't bother breaking the list up.
	 */
	if( error == 0 )
	    error = (ifp->if_output)(ifp, m, (struct sockaddr *)dst, ro->ro_rt);
	else
	{
	    /*
	     * free all mbuf chains in the list
	     */
	    while( m0 )
	    {
		m = m0->m_list;
		m_freem(m0);
		m0 = m;
	    }
	}

	/*
	 * have finished with the master mbuf chain - free it
	 */
	m_freem(master);
#endif
	if (error == 0)
		ipstat.ips_fragmented++;
    }
done:
	return (error);
bad:
	m_freem(m0);
	goto done;
}

/*
 * Insert IP options into preformed packet.
 * Adjust IP destination as required for IP source routing,
 * as indicated by a non-zero in_addr at the start of the options.
 *
 * XXX This routine assumes that the packet has no options in place.
 */
static struct mbuf *
ip_insertoptions(m, opt, phlen)
	register struct mbuf *m;
	struct mbuf *opt;
	int *phlen;
{
	register struct ipoption *p = mtod(opt, struct ipoption *);
	struct mbuf *n;
	register struct ip *ip = mtod(m, struct ip *);
	unsigned optlen;

	optlen = opt->m_len - sizeof(p->ipopt_dst);
	if (optlen + (u_short)ip->ip_len > IP_MAXPACKET)
		return (m);		/* XXX should fail */
	if (p->ipopt_dst.s_addr)
		ip->ip_dst = p->ipopt_dst;
#ifdef OldCode
	if (m->m_flags & M_EXT || m->m_data - optlen < m->m_pktdat) {
		MGETHDR(n, M_DONTWAIT, MT_HEADER);
		if (n == 0)
			return (m);
		n->m_pkthdr.len = m->m_pkthdr.len + optlen;
		m->m_len -= sizeof(struct ip);
		m->m_data += sizeof(struct ip);
		n->m_next = m;
		m = n;
		m->m_len = optlen + sizeof(struct ip);
		m->m_data += max_linkhdr;
		(void)memcpy(mtod(m, void *), ip, sizeof(struct ip));
#else
	/*
	 * it would be nice to be able to use the mbuf manager's
	 * "allocate and copy" feature, but this is not possible
	 * as the data needs to go to the *end* of the header mbuf
	 */
	if(m->m_off - optlen < m->m_inioff)
	{
	        n = ALLOC_S(MINCONTIG, NULL);
	        if (n == 0) {
#ifdef DEBUG
			if( DODEBUG(DBGMMAN) )
		    		Printf("ip_insertoptions: ALLOC_S failed\n");
#endif
	        	return (m);
	        }
		n->m_type = MT_HEADER;
		n->m_pkthdr.len = m->m_pkthdr.len + optlen;
		m->m_len -= sizeof(struct ip);
		m->m_off += sizeof(struct ip);
		n->m_next = m;
		m = n;
		m->m_len = optlen + sizeof(struct ip);
		m->m_off += max_linkhdr;
		(void)memcpy(mtod(m, void *), ip, sizeof(struct ip));
#endif
	} else {
		m->m_off -= optlen;
		m->m_len += optlen;
		m->m_pkthdr.len += optlen;
		ovbcopy((caddr_t)ip, mtod(m, caddr_t), sizeof(struct ip));
	}
	ip = mtod(m, struct ip *);
	(void)memcpy(ip + 1, p->ipopt_list, (unsigned)optlen);
	*phlen = sizeof(struct ip) + optlen;
	ip->ip_vhl = IP_MAKE_VHL(IPVERSION, *phlen >> 2);
	ip->ip_len += optlen;
	return (m);
}

/*
 * Copy options from ip to jp,
 * omitting those not copied during fragmentation.
 */
static int
ip_optcopy(ip, jp)
	struct ip *ip, *jp;
{
	register u_char *cp, *dp;
	int opt, optlen, cnt;

	cp = (u_char *)(ip + 1);
	dp = (u_char *)(jp + 1);
	cnt = (IP_VHL_HL(ip->ip_vhl) << 2) - sizeof (struct ip);
	for (; cnt > 0; cnt -= optlen, cp += optlen) {
		opt = cp[0];
		if (opt == IPOPT_EOL)
			break;
		if (opt == IPOPT_NOP) {
			/* Preserve for IP mcast tunnel's LSRR alignment. */
			*dp++ = IPOPT_NOP;
			optlen = 1;
			continue;
		} else
			optlen = cp[IPOPT_OLEN];
		/* bogus lengths should have been caught by ip_dooptions */
		if (optlen > cnt)
			optlen = cnt;
		if (IPOPT_COPIED(opt)) {
			(void)memcpy(dp, cp, (unsigned)optlen);
			dp += optlen;
		}
	}
	for (optlen = dp - (u_char *)(jp+1); optlen & 0x3; optlen++)
		*dp++ = IPOPT_EOL;
	return (optlen);
}

/*
 * IP socket option processing.
 */
int
ip_ctloutput(op, so, level, optname, mp)
	int op;
	struct socket *so;
	int level, optname;
	struct mbuf **mp;
{
	register struct inpcb *inp = sotoinpcb(so);
	register struct mbuf *m = *mp;
	register int optval = 0;
	int error = 0;

	if (level != IPPROTO_IP) {
		error = EINVAL;
		if (op == PRCO_SETOPT && *mp)
			(void) m_free(*mp);
	} else switch (op) {

	case PRCO_SETOPT:
		switch (optname) {
		case IP_OPTIONS:
#ifdef notyet
		case IP_RETOPTS:
			return (ip_pcbopts(optname, &inp->inp_options, m));
#else
			return (ip_pcbopts(&inp->inp_options, m));
#endif

		case IP_TOS:
		case IP_TTL:
		case IP_RECVOPTS:
		case IP_RECVRETOPTS:
		case IP_RECVDSTADDR:
		case IP_RECVIF:
			if (m == 0 || m->m_len != sizeof(int))
				error = EINVAL;
			else {
				optval = *mtod(m, int *);
				switch (optname) {

				case IP_TOS:
					inp->inp_ip_tos = optval;
					break;

				case IP_TTL:
					inp->inp_ip_ttl = optval;
					break;
#define	OPTSET(bit) \
	if (optval) \
		inp->inp_flags |= bit; \
	else \
		inp->inp_flags &= ~bit;

				case IP_RECVOPTS:
					OPTSET(INP_RECVOPTS);
					break;

				case IP_RECVRETOPTS:
					OPTSET(INP_RECVRETOPTS);
					break;

				case IP_RECVDSTADDR:
					OPTSET(INP_RECVDSTADDR);
					break;

				case IP_RECVIF:
					OPTSET(INP_RECVIF);
					break;
				}
			}
			break;
#undef OPTSET

#ifdef MULTICAST
		case IP_MULTICAST_IF:
		case IP_MULTICAST_VIF:
		case IP_MULTICAST_TTL:
		case IP_MULTICAST_LOOP:
		case IP_ADD_MEMBERSHIP:
		case IP_DROP_MEMBERSHIP:
			error = ip_setmoptions(optname, &inp->inp_moptions, m);
			break;

		case IP_PORTRANGE:
			if (m == 0 || m->m_len != sizeof(int))
				error = EINVAL;
			else {
				optval = *mtod(m, int *);

				switch (optval) {

				case IP_PORTRANGE_DEFAULT:
					inp->inp_flags &= ~(INP_LOWPORT);
					inp->inp_flags &= ~(INP_HIGHPORT);
					break;

				case IP_PORTRANGE_HIGH:
					inp->inp_flags &= ~(INP_LOWPORT);
					inp->inp_flags |= INP_HIGHPORT;
					break;

				case IP_PORTRANGE_LOW:
					inp->inp_flags &= ~(INP_HIGHPORT);
					inp->inp_flags |= INP_LOWPORT;
					break;

				default:
					error = EINVAL;
					break;
				}
			}
			break;
#endif

		default:
			error = ENOPROTOOPT;
			break;
		}
		if (m)
			(void)m_free(m);
		break;

	case PRCO_GETOPT:
		switch (optname) {
		case IP_OPTIONS:
		case IP_RETOPTS:
			*mp = m = ALLOC_S(MINCONTIG, NULL);
			if (m==0)
			        return (ENOBUFS);
			m->m_type=MT_SOOPTS;
			if (inp->inp_options) {
				m->m_len = inp->inp_options->m_len;
				(void)memcpy(mtod(m, void *),
				    mtod(inp->inp_options, void *), (unsigned)m->m_len);
			} else
				m->m_len = 0;
			break;

		case IP_TOS:
		case IP_TTL:
		case IP_RECVOPTS:
		case IP_RECVRETOPTS:
		case IP_RECVDSTADDR:
		case IP_RECVIF:
			*mp = m = ALLOC_S(MINCONTIG, NULL);
			if (m==0)
			        return (ENOBUFS);
			m->m_type = MT_SOOPTS;
			m->m_len = sizeof(int);
			switch (optname) {

			case IP_TOS:
				optval = inp->inp_ip_tos;
				break;

			case IP_TTL:
				optval = inp->inp_ip_ttl;
				break;

#define	OPTBIT(bit)	(inp->inp_flags & bit ? 1 : 0)

			case IP_RECVOPTS:
				optval = OPTBIT(INP_RECVOPTS);
				break;

			case IP_RECVRETOPTS:
				optval = OPTBIT(INP_RECVRETOPTS);
				break;

			case IP_RECVDSTADDR:
				optval = OPTBIT(INP_RECVDSTADDR);
				break;

			case IP_RECVIF:
				optval = OPTBIT(INP_RECVIF);
				break;
			}
			*mtod(m, int *) = optval;
			break;

#ifdef MULTICAST
		case IP_MULTICAST_IF:
		case IP_MULTICAST_VIF:
		case IP_MULTICAST_TTL:
		case IP_MULTICAST_LOOP:
		case IP_ADD_MEMBERSHIP:
		case IP_DROP_MEMBERSHIP:
			error = ip_getmoptions(optname, inp->inp_moptions, mp);
			break;

		case IP_PORTRANGE:
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
			m->m_len = sizeof(int);

			if (inp->inp_flags & INP_HIGHPORT)
				optval = IP_PORTRANGE_HIGH;
			else if (inp->inp_flags & INP_LOWPORT)
				optval = IP_PORTRANGE_LOW;
			else
				optval = 0;

			*mtod(m, int *) = optval;
			break;
#endif

		default:
			error = ENOPROTOOPT;
			break;
		}
		break;
	}
	return (error);
}

/*
 * Set up IP options in pcb for insertion in output packets.
 * Store in mbuf with pointer in pcbopt, adding pseudo-option
 * with destination address if source routed.
 */
static int
#ifdef notyet
ip_pcbopts(optname, pcbopt, m)
	int optname;
#else
ip_pcbopts(pcbopt, m)
#endif
	struct mbuf **pcbopt;
	register struct mbuf *m;
{
	register int cnt, optlen;
	register u_char *cp;
	u_char opt;

	/* turn off any old options */
	if (*pcbopt)
		(void)m_free(*pcbopt);
	*pcbopt = 0;
	if (m == (struct mbuf *)0 || m->m_len == 0) {
		/*
		 * Only turning off any previous options.
		 */
		if (m)
			(void)m_free(m);
		return (0);
	}

#ifdef DEBUG
        Printf("ip_pcbopts: m=%x, m->m_len=%d, m->m_off=%x\n", m, m->m_len, m->m_off);
#endif
#if !defined(vax) && !defined(__arm)
	if (m->m_len % sizeof(long))
		goto bad;
#endif
	/*
	 * IP first-hop destination address will be stored before
	 * actual options; move other options back
	 * and clear it when none present.
	 */
	if (m->m_off + m->m_len + sizeof(struct in_addr) >= MAXOFF(m))
		goto bad;
	cnt = m->m_len;
	m->m_len += sizeof(struct in_addr);
	cp = mtod(m, u_char *) + sizeof(struct in_addr);
	ovbcopy(mtod(m, caddr_t), (caddr_t)cp, (unsigned)cnt);
	bzero(mtod(m, caddr_t), sizeof(struct in_addr));

	for (; cnt > 0; cnt -= optlen, cp += optlen) {
		opt = cp[IPOPT_OPTVAL];
#ifdef DEBUG
                Printf("option %d\n", opt);
#endif
		if (opt == IPOPT_EOL)
			break;
		if (opt == IPOPT_NOP)
			optlen = 1;
		else {
			optlen = cp[IPOPT_OLEN];
#ifdef DEBUG
                        Printf("  optlen = %d\n", optlen);
#endif
			if (optlen <= IPOPT_OLEN || optlen > cnt)
				goto bad;
		}
		switch (opt) {

		default:
			break;

		case IPOPT_LSRR:
		case IPOPT_SSRR:
			/*
			 * user process specifies route as:
			 *	->A->B->C->D
			 * D must be our final destination (but we can't
			 * check that since we may not have connected yet).
			 * A is first hop destination, which doesn't appear in
			 * actual IP option, but is stored before the options.
			 */
			if (optlen < IPOPT_MINOFF - 1 + sizeof(struct in_addr))
				goto bad;
			m->m_len -= sizeof(struct in_addr);
			cnt -= sizeof(struct in_addr);
			optlen -= sizeof(struct in_addr);
			cp[IPOPT_OLEN] = optlen;
			/*
			 * Move first hop before start of options.
			 */
			bcopy((caddr_t)&cp[IPOPT_OFFSET+1], mtod(m, caddr_t),
			    sizeof(struct in_addr));
			/*
			 * Then copy rest of options back
			 * to close up the deleted entry.
			 */
			ovbcopy((caddr_t)(&cp[IPOPT_OFFSET+1] +
			    sizeof(struct in_addr)),
			    (caddr_t)&cp[IPOPT_OFFSET+1],
			    (unsigned)cnt + sizeof(struct in_addr));
			break;
		}
	}
	if (m->m_len > MAX_IPOPTLEN + sizeof(struct in_addr))
		goto bad;
	*pcbopt = m;
	return (0);

bad:
	(void)m_free(m);
	return (EINVAL);
}

#ifdef MULTICAST
/*
 * Set the IP multicast options in response to user setsockopt().
 */
static int
ip_setmoptions(optname, imop, m)
	int optname;
	struct ip_moptions **imop;
	struct mbuf *m;
{
	register int error = 0;
	u_char loop;
	register int i;
	struct in_addr addr;
	register struct ip_mreq *mreq;
	register struct ifnet *ifp;
	register struct ip_moptions *imo = *imop;
	struct route ro;
	register struct sockaddr_in *dst;
	int s;

	if (imo == NULL) {
		/*
		 * No multicast option buffer attached to the pcb;
		 * allocate one and initialize to default values.
		 */
		imo = (struct ip_moptions*)malloc(sizeof(*imo), M_IPMOPTS,
		    M_WAITOK);

		if (imo == NULL)
			return (ENOBUFS);
		*imop = imo;
		imo->imo_multicast_ifp = NULL;
		imo->imo_multicast_vif = -1;
		imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
		imo->imo_multicast_loop = IP_DEFAULT_MULTICAST_LOOP;
		imo->imo_num_memberships = 0;
	}

	switch (optname) {
	/* store an index number for the vif you wanna use in the send */
	case IP_MULTICAST_VIF:
		if (!legal_vif_num) {
			error = EOPNOTSUPP;
			break;
		}
		if (m == NULL || m->m_len != sizeof(int)) {
			error = EINVAL;
			break;
		}
		i = *(mtod(m, int *));
		if (!legal_vif_num(i) && (i != -1)) {
			error = EINVAL;
			break;
		}
		imo->imo_multicast_vif = i;
		break;

	case IP_MULTICAST_IF:
		/*
		 * Select the interface for outgoing multicast packets.
		 */
		if (m == NULL || m->m_len != sizeof(struct in_addr)) {
			error = EINVAL;
			break;
		}
		addr = *(mtod(m, struct in_addr *));
		/*
		 * INADDR_ANY is used to remove a previous selection.
		 * When no interface is selected, a default one is
		 * chosen every time a multicast packet is sent.
		 */
		if (addr.s_addr == INADDR_ANY) {
			imo->imo_multicast_ifp = NULL;
			break;
		}
		/*
		 * The selected interface is identified by its local
		 * IP address.  Find the interface and confirm that
		 * it supports multicasting.
		 */
		s = splimp();
		INADDR_TO_IFP(addr, ifp);
		if (ifp == NULL || (ifp->if_flags & IFF_MULTICAST) == 0) {
			error = EADDRNOTAVAIL;
			break;
		}
		imo->imo_multicast_ifp = ifp;
		splx(s);
		break;

	case IP_MULTICAST_TTL:
		/*
		 * Set the IP time-to-live for outgoing multicast packets.
		 */
		if (m == NULL || m->m_len != 1) {
			error = EINVAL;
			break;
		}
		imo->imo_multicast_ttl = *(mtod(m, u_char *));
		break;

	case IP_MULTICAST_LOOP:
		/*
		 * Set the loopback flag for outgoing multicast packets.
		 * Must be zero or one.
		 */
		if (m == NULL || m->m_len != 1 ||
		   (loop = *(mtod(m, u_char *))) > 1) {
			error = EINVAL;
			break;
		}
		imo->imo_multicast_loop = loop;
		break;

	case IP_ADD_MEMBERSHIP:
		/*
		 * Add a multicast group membership.
		 * Group must be a valid IP multicast address.
		 */
		if (m == NULL || m->m_len != sizeof(struct ip_mreq)) {
			error = EINVAL;
			break;
		}
		mreq = mtod(m, struct ip_mreq *);
		if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr.s_addr))) {
			error = EINVAL;
			break;
		}
		s = splimp();
		/*
		 * If no interface address was provided, use the interface of
		 * the route to the given multicast address.
		 */
		if (mreq->imr_interface.s_addr == INADDR_ANY) {
			bzero((caddr_t)&ro, sizeof(ro));
			dst = (struct sockaddr_in *)&ro.ro_dst;
			dst->sin_len = sizeof(*dst);
			dst->sin_family = AF_INET;
			dst->sin_addr = mreq->imr_multiaddr;
			rtalloc(&ro);
			if (ro.ro_rt == NULL) {
				error = EADDRNOTAVAIL;
				splx(s);
				break;
			}
			ifp = ro.ro_rt->rt_ifp;
			rtfree(ro.ro_rt);
		}
		else {
			INADDR_TO_IFP(mreq->imr_interface, ifp);
		}

		/*
		 * See if we found an interface, and confirm that it
		 * supports multicast.
		 */
		if (ifp == NULL || (ifp->if_flags & IFF_MULTICAST) == 0) {
			error = EADDRNOTAVAIL;
			splx(s);
			break;
		}
		/*
		 * See if the membership already exists or if all the
		 * membership slots are full.
		 */
		for (i = 0; i < imo->imo_num_memberships; ++i) {
			if (imo->imo_membership[i]->inm_ifp == ifp &&
			    imo->imo_membership[i]->inm_addr.s_addr
						== mreq->imr_multiaddr.s_addr)
				break;
		}
		if (i < imo->imo_num_memberships) {
			error = EADDRINUSE;
			splx(s);
			break;
		}
		if (i == IP_MAX_MEMBERSHIPS) {
			error = ETOOMANYREFS;
			splx(s);
			break;
		}
		/*
		 * Everything looks good; add a new record to the multicast
		 * address list for the given interface.
		 */
		if ((imo->imo_membership[i] =
		    in_addmulti(&mreq->imr_multiaddr, ifp)) == NULL) {
			error = ENOBUFS;
			splx(s);
			break;
		}
		++imo->imo_num_memberships;
		splx(s);
		break;

	case IP_DROP_MEMBERSHIP:
		/*
		 * Drop a multicast group membership.
		 * Group must be a valid IP multicast address.
		 */
		if (m == NULL || m->m_len != sizeof(struct ip_mreq)) {
			error = EINVAL;
			break;
		}
		mreq = mtod(m, struct ip_mreq *);
		if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr.s_addr))) {
			error = EINVAL;
			break;
		}

		s = splimp();
		/*
		 * If an interface address was specified, get a pointer
		 * to its ifnet structure.
		 */
		if (mreq->imr_interface.s_addr == INADDR_ANY)
			ifp = NULL;
		else {
			INADDR_TO_IFP(mreq->imr_interface, ifp);
			if (ifp == NULL) {
				error = EADDRNOTAVAIL;
				splx(s);
				break;
			}
		}
		/*
		 * Find the membership in the membership array.
		 */
		for (i = 0; i < imo->imo_num_memberships; ++i) {
			if ((ifp == NULL ||
			     imo->imo_membership[i]->inm_ifp == ifp) &&
			     imo->imo_membership[i]->inm_addr.s_addr ==
			     mreq->imr_multiaddr.s_addr)
				break;
		}
		if (i == imo->imo_num_memberships) {
			error = EADDRNOTAVAIL;
			splx(s);
			break;
		}
		/*
		 * Give up the multicast address record to which the
		 * membership points.
		 */
		in_delmulti(imo->imo_membership[i]);
		/*
		 * Remove the gap in the membership array.
		 */
		for (++i; i < imo->imo_num_memberships; ++i)
			imo->imo_membership[i-1] = imo->imo_membership[i];
		--imo->imo_num_memberships;
		splx(s);
		break;

	default:
		error = EOPNOTSUPP;
		break;
	}

	/*
	 * If all options have default values, no need to keep the mbuf.
	 */
	if (imo->imo_multicast_ifp == NULL &&
	    imo->imo_multicast_vif == -1 &&
	    imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
	    imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
	    imo->imo_num_memberships == 0) {
		free(*imop, M_IPMOPTS);
		*imop = NULL;
	}

	return (error);
}

/*
 * Return the IP multicast options in response to user getsockopt().
 */
static int
ip_getmoptions(optname, imo, mp)
	int optname;
	register struct ip_moptions *imo;
	register struct mbuf **mp;
{
	u_char *ttl;
	u_char *loop;
	struct in_addr *addr;
	struct in_ifaddr *ia;

	*mp = m_get(M_WAIT, MT_SOOPTS);

	switch (optname) {

	case IP_MULTICAST_VIF:
		if (imo != NULL)
			*(mtod(*mp, int *)) = imo->imo_multicast_vif;
		else
			*(mtod(*mp, int *)) = -1;
		(*mp)->m_len = sizeof(int);
		return(0);

	case IP_MULTICAST_IF:
		addr = mtod(*mp, struct in_addr *);
		(*mp)->m_len = sizeof(struct in_addr);
		if (imo == NULL || imo->imo_multicast_ifp == NULL)
			addr->s_addr = INADDR_ANY;
		else {
			IFP_TO_IA(imo->imo_multicast_ifp, ia);
			addr->s_addr = (ia == NULL) ? INADDR_ANY
					: IA_SIN(ia)->sin_addr.s_addr;
		}
		return (0);

	case IP_MULTICAST_TTL:
		ttl = mtod(*mp, u_char *);
		(*mp)->m_len = 1;
		*ttl = (imo == NULL) ? IP_DEFAULT_MULTICAST_TTL
				     : imo->imo_multicast_ttl;
		return (0);

	case IP_MULTICAST_LOOP:
		loop = mtod(*mp, u_char *);
		(*mp)->m_len = 1;
		*loop = (imo == NULL) ? IP_DEFAULT_MULTICAST_LOOP
				      : imo->imo_multicast_loop;
		return (0);

	default:
		return (EOPNOTSUPP);
	}
}

/*
 * Discard the IP multicast options.
 */
void
ip_freemoptions(imo)
	register struct ip_moptions *imo;
{
	register int i;

	if (imo != NULL) {
		for (i = 0; i < imo->imo_num_memberships; ++i)
			in_delmulti(imo->imo_membership[i]);
		free(imo, M_IPMOPTS);
	}
}

/*
 * Routine called from ip_output() to loop back a copy of an IP multicast
 * packet to the input queue of a specified interface.  Note that this
 * calls the output routine of the loopback "driver", but with an interface
 * pointer that might NOT be a loopback interface -- evil, but easier than
 * replicating that code here.
 */
static void
ip_mloopback(ifp, m, dst)
	struct ifnet *ifp;
	register struct mbuf *m;
	register struct sockaddr_in *dst;
{
	register struct ip *ip;
	struct mbuf *copym;

	copym = m_copy(m, 0, M_COPYALL);
	if (copym != NULL) {
		/*
		 * We don't bother to fragment if the IP length is greater
		 * than the interface's MTU.  Can this possibly matter?
		 */
		ip = mtod(copym, struct ip *);
		ip->ip_len = htons((u_short)ip->ip_len);
		ip->ip_off = htons((u_short)ip->ip_off);
		ip->ip_sum = 0;
		if (ip->ip_vhl == IP_VHL_BORING) {
			ip->ip_sum = in_cksum_hdr(ip);
		} else {
			ip->ip_sum = in_cksum(copym,
					      IP_VHL_HL(ip->ip_vhl) << 2);
		}
		/*
		 * NB:
		 * We can't simply call ip_input() directly because
		 * the ip_mforward() depends on the `input interface'
		 * being set to something unreasonable so that we don't
		 * attempt to forward the looped-back copy.
		 * It's also not clear whether there are any lingering
		 * reentrancy problems in other areas which might be
		 * exposed by this code.  For the moment, we'll err
		 * on the side of safety by continuing to abuse
		 * loinput().
		 */
#ifdef notdef
		copym->m_pkthdr.rcvif = &loif[0];
		ip_input(copym)
#else
		looutput(ifp, copym, (struct sockaddr *)dst, NULL);
#endif
	}
}
#endif /* MULTICAST */
@


4.6
log
@* Used to send fragmented multicasts to the wrong link-level address. This
  is fixed by MbufManager 0.23, but a work-around has been incorporated
  into the Internet module.
* Ability to debug using PDebug instead of TML added.
* Various compilation hiccoughs when DEBUG defined fixed.

Version 5.33. Tagged as 'Internet-5_33'
@
text
@d948 1
a948 1
	register cnt, optlen;
@


4.5
log
@* Removed some unused routines in the sysctl code.
* Now keeps track of interface multicast claims, even if the DCI driver is
  not capable of multicast filtering. This is necessary in case the user
  loads a multicast filtering capable driver later.
* Small tweak to ip_output(): multicast packets with specified interfaces
  don't need a route. This was spotted when we saw a machine failing to send
  IGMP reports because it had no default route set up.

Version 5.32. Tagged as 'Internet-5_32'
@
text
@d532 8
@


4.4
log
@* Dynamic ports now assigned in range 49152-65535.
* IP_RECVDSTADDR works for non-unicast packets.
* SO_TIMESTAMP added.
* IP_RECVIF added.
* Various other internal changes merged in from FreeBSD sources.

Version 5.29. Tagged as 'Internet-5_29'
@
text
@d194 1
d196 7
@


4.3
log
@* Fixed bug introduced by tentative ARP probe - a typo made arp_ifinit() fail to
  set up the interface route structure properly.
* Divide-by-zero when an IGMP membership query with a time of 1 received fixed
  (from FreeBSD).
* IGMP messages now sent with TOS set to "maximum reliability".
* tcp_output.c updated from FreeBSD - in particular path_mtu_discovery sysctl
  now available.
* A few other FreeBSD structural changes and bug fixes integrated.
* Put UDP checksum in BOOTP packets.
* Null pointer dereferencing fixed in whoami.c. Address setting now done with
  SIOCDIFADDR and SIOCAIFADDR. Don't set the netmask if asked not to.
* Output BOOTP packets with the source address in ciaddr
Note that various structural changes mean that the support tools (in particular
InetStat) will need to be recompiled.
Requires TCPIPLibs 5.20

Version 5.27. Tagged as 'Internet-5_27'
@
text
@d736 1
d767 4
d846 1
d875 4
d1429 1
a1429 1
		(void) looutput(ifp, copym, (struct sockaddr *)dst, NULL);
@


4.2
log
@Version Spinner_B7 taken
@
text
@d743 1
a743 1
					inp->inp_ip.ip_tos = optval;
d747 1
a747 1
					inp->inp_ip.ip_ttl = optval;
d849 1
a849 1
				optval = inp->inp_ip.ip_tos;
d853 1
a853 1
				optval = inp->inp_ip.ip_ttl;
@


4.1
log
@Initial revision
@
text
@d1 3
a3 1
/* -*-C-*-
d5 15
a19 2
 * $Header: /ax/networking:Internet/netinet/ip_output.c:networking  1.2  $
 * $Source: /ax/networking:Internet/netinet/ip_output.c: $
d21 11
a31 1
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
a32 13
 * $Log:	ip_output.c,v $
 * Revision 1.2  94/12/06  15:49:32  kwelton
 * Two changes:
 * 
 * 1)  Fragmentation code now uses COPY_U to make unsafe (i.e. indirected)
 *     copies of the original chain - this should speed up data throughput.
 * 
 * 2)  The code to free the list of mbuf chains when ifp->if_output is
 *     not called now records m0->m_list before calling FREEM.
 * 
 * Revision 1.1  94/12/02  11:18:27  kwelton
 * Initial revision
 * 
d34 24
a57 33
/*
 * Copyright (c) 1983, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 */
#include "sys/param.h"
#include "sys/mbuf.h"
#include "sys/errno.h"
#include "sys/protosw.h"
#include "sys/socket.h"
#include "sys/socketvar.h"

#include "net/if.h"
#include "net/route.h"

#include "netinet/in.h"
#include "netinet/in_pcb.h"
#include "netinet/in_systm.h"
#include "netinet/in_var.h"
#include "netinet/ip.h"
#include "netinet/ip_var.h"
d60 1
a60 1
#include "../machine/mtpr.h"
d62 1
d65 4
d70 11
a80 1
struct mbuf *ip_insertoptions();
d88 2
a89 1
ip_output(m0, opt, ro, flags)
d94 1
d96 4
a99 4
	register struct ip *ip, *mhip;
	register struct ifnet *ifp;
	register struct mbuf *m = m0;
	register int hlen = sizeof (struct ip);
a100 1
	struct route iproute;
d102 2
d105 7
a111 4
	/* TRACE */
	if( 0 )
	{
	    struct mbuf *m1 = m0;
d113 1
a113 6
	    Printf("\021\05ip_output: here is the mbuf chain:");
	    if( !m1 )
		Printf("\021\01	  <Empty>\021\07\n");
	    else
	    {
		while( m1 )
d115 12
a126 2
		    Printf("\n	  %d bytes @@ %x", m1->m_len, m1);
		    m1 = m1->m_next;
d128 5
d134 8
a141 3
	    Printf("\021\07\n");
	}

d144 3
d153 2
a154 2
	if ((flags & IP_FORWARDING) == 0) {
		ip->ip_v = IPVERSION;
d157 4
a160 3
		ip->ip_hl = hlen >> 2;
	} else
		hlen = ip->ip_hl << 2;
a161 7
	/*
	 * Route packet.
	 */
	if (ro == 0) {
		ro = &iproute;
		bzero((caddr_t)ro, sizeof (*ro));
	}
d175 1
d182 2
d185 3
a187 6
		struct in_ifaddr *ia;

		ia = (struct in_ifaddr *)ifa_ifwithdstaddr((struct sockaddr *)dst);
		if (ia == 0)
			ia = in_iaonnetof(in_netof(ip->ip_dst));
		if (ia == 0) {
d192 2
d195 9
d205 4
a208 6
			rtalloc(ro);
		if (ro->ro_rt == 0 || (ifp = ro->ro_rt->rt_ifp) == 0) {
			if (in_localaddr(ip->ip_dst))
				error = EHOSTUNREACH;
			else
				error = ENETUNREACH;
d211 2
d215 109
a323 1
			dst = (struct sockaddr_in *)&ro->ro_rt->rt_gateway;
d325 1
d331 15
a345 8
	if (ip->ip_src.s_addr == INADDR_ANY) {
		register struct in_ifaddr *ia;

		for (ia = in_ifaddr; ia; ia = ia->ia_next)
			if (ia->ia_ifp == ifp) {
				ip->ip_src = IA_SIN(ia)->sin_addr;
				break;
			}
d348 1
d354 1
a354 1
	if (in_broadcast(dst->sin_addr)) {
d364 1
a364 1
		if (ip->ip_len > ifp->if_mtu) {
d368 3
d373 11
d387 1
a387 1
	if (ip->ip_len <= ifp->if_mtu) {
d391 10
a400 2
		ip->ip_sum = in_cksum(m, hlen);
		error = (*ifp->if_output)(ifp, m, (struct sockaddr *)dst);
a402 1

d409 1
d415 12
d433 1
a433 1
	struct mbuf **mnext = &m->m_list;
d441 2
a442 3
	for (off = hlen + len; off < ip->ip_len; off += len) {
#ifdef OldCode
		MGET(m, M_DONTWAIT, MT_HEADER);
d444 4
d449 1
d452 1
a452 14
		m->m_off = MMAXOFF(m) - hlen;
#else
		if( (m = ALLOC_S(MINCONTIG, NULL)) == NULL )
		{
#ifdef DEBUG
		    if( DODEBUG(DBGMMAN) )
			Printf("ip_output: ALLOC_S failed\n");
#endif
		    error = ENOBUFS;
		    goto sendorfree;
		}
		m->m_type = MT_HEADER;
		m->m_off = MAXOFF(m) - hlen;
#endif
d457 1
a457 1
			mhip->ip_hl = mhlen >> 2;
d463 2
a464 2
		if (off + len >= ip->ip_len)
			len = ip->ip_len - off;
d481 3
d485 1
a485 3
			/* TRACE */
			if( 0 )
			    Printf("ip_output: COPY_U failed\n");
d488 2
d492 5
a496 1
		mhip->ip_sum = in_cksum(m, mhlen);
d498 2
a499 1
		mnext = &m->m_list;
d505 1
d507 1
a507 1
	m_adj(m0, hlen + firstlen - ip->ip_len);
d513 1
a513 1
	master = m0;
d515 1
a515 1
	TRIM(m0, hlen + firstlen - ip->ip_len, NULL);
d517 1
a517 1
	if( (m0 = COPY_U(master, 0, M_COPYALL)) == NULL )
d527 1
a527 1
	m0->m_list = master->m_list;
d530 2
a531 1
	ip->ip_len = htons((u_short)(hlen + firstlen));
d534 6
a539 3
	ip->ip_sum = in_cksum(m0, hlen);

      sendorfree:
d542 2
a543 2
		m0 = m->m_act;
		m->m_act = 0;
d546 1
a546 1
			    (struct sockaddr *)dst);
d557 1
a557 1
	    error = (ifp->if_output)(ifp, m0, (struct sockaddr *)dst);
d566 1
a566 1
		FREEM(m0);
d574 1
a574 1
	FREEM(master);
d576 2
d579 1
a579 6

      done:
	if (ro == &iproute && (flags & IP_ROUTETOIF) == 0 && ro->ro_rt) {
		RTFREE(ro->ro_rt);
	}

a581 1
#ifdef OldCode
a582 3
#else
	FREEM(m0);
#endif
d590 2
d593 1
a593 1
struct mbuf *
d605 2
d610 2
a611 2
	if (m->m_off >= MMAXOFF(m) || MMINOFF(m) + optlen > m->m_off) {
		MGET(n, M_DONTWAIT, MT_HEADER);
d614 1
d616 1
a616 1
		m->m_off += sizeof(struct ip);
a618 1
		m->m_off = MMAXOFF(m) - sizeof(struct ip) - optlen;
d620 2
a621 2
		bcopy((caddr_t)ip, mtod(m, caddr_t), sizeof(struct ip));
	    }
d628 1
a628 1
	if( m->m_off >= MAXOFF(m) || MINOFF(m) + optlen > m->m_off )
d630 2
a631 2
	    if( (n = ALLOC_S(MINCONTIG, NULL)) == NULL )
	    {
d633 2
a634 2
		if( DODEBUG(DBGMMAN) )
		    Printf("ip_insertoptions: ALLOC_S failed\n");
d636 11
a646 14
		return(m);
	    }

	    n->m_type = MT_HEADER;

	    m->m_len -= sizeof(struct ip);
	    m->m_off += sizeof(struct ip);
	    n->m_next = m;

	    m = n;
	    m->m_off = MAXOFF(m) - sizeof(struct ip) - optlen;
	    m->m_len = optlen + sizeof(struct ip);
	    bcopy((caddr_t)ip, mtod(m, caddr_t), sizeof(struct ip));
	}
d648 1
a648 1
	else {
d651 1
d655 1
a655 1
	bcopy((caddr_t)p->ipopt_list, (caddr_t)(ip + 1), (unsigned)optlen);
d657 1
d666 1
d675 1
a675 1
	cnt = (ip->ip_hl << 2) - sizeof (struct ip);
d680 3
a682 1
		if (opt == IPOPT_NOP)
d684 2
a685 1
		else
d691 1
a691 1
			bcopy((caddr_t)cp, (caddr_t)dp, (unsigned)optlen);
d703 2
a704 1
ip_ctloutput(op, so, level, optname, m)
d708 1
a708 1
	struct mbuf **m;
d710 3
a713 1
	struct inpcb *inp = sotoinpcb(so);
d715 1
a715 1
	if (level != IPPROTO_IP)
d717 3
a719 1
	else switch (op) {
d724 87
a810 1
			return (ip_pcbopts(&inp->inp_options, *m));
d813 1
a813 1
			error = EINVAL;
d816 2
d823 42
a864 5
#ifdef OldCode
			*m = m_get(M_WAIT, MT_SOOPTS);
#else
			{
			    struct mbuf *n;
d866 2
a867 8
			    if( (n = ALLOC_S(MINCONTIG, NULL)) == NULL )
			    {
				/*
				 * not sure how to handle this, so
				 * we had better panic
				 */
				panic("ip_ctloutput: PRCO_GETOPT");
				error = ENOBUFS;
a868 3
			    }
			    n->m_type = MT_SOOPTS;
			    *m = n;
d870 26
d897 1
a897 8
			if (inp->inp_options) {
				(*m)->m_off = inp->inp_options->m_off;
				(*m)->m_len = inp->inp_options->m_len;
				bcopy(mtod(inp->inp_options, caddr_t),
				    mtod(*m, caddr_t), (unsigned)(*m)->m_len);
			} else
				(*m)->m_len = 0;
			break;
d899 1
a899 1
			error = EINVAL;
a903 8
	if (op == PRCO_SETOPT && *m)
	{
#ifdef OldCode
	    (void)m_free(*m);
#else
	    FREE(*m);
#endif
	}
d912 5
d918 1
d928 1
a928 7
	{
#ifdef OldCode
	    (void)m_free(*pcbopt);
#else
	    FREE(*pcbopt);
#endif
	}
d935 1
a935 7
		{
#ifdef OldCode
		    (void)m_free(m);
#else
		    FREE(m);
#endif
		}
d939 3
d951 1
a951 2
#if	MAX_IPOPTLEN >= MINCONTIG
	if (m->m_off + m->m_len + sizeof(struct in_addr) > MAX_IPOPTLEN)
a952 4
#else
	if (m->m_off + m->m_len + sizeof(struct in_addr) > MAXOFF(m))
		goto bad;
#endif
d961 3
d970 3
d1013 2
a1018 1
#ifdef OldCode
d1020 398
d1419 1
a1419 1
	FREE(m);
d1421 1
a1421 1
	return (EINVAL);
d1423 1
a1423 2

/* EOF ip_output.c */
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d1 21
d23 2
a24 18
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d26 11
a36 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d39 16
a54 24

#define _IP_VHL

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/errno.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>

#include <netinet/ip_fw.h>
d57 1
a57 1
#include "machine/mtpr.h"
a58 1
#include <machine/in_cksum.h>
a60 4
#include "debug.h"
#include "module.h"

u_short ip_id;
d62 1
a62 11
static struct mbuf *ip_insertoptions(struct mbuf *, struct mbuf *, int *);
#ifdef MULTICAST
static void ip_mloopback
	(struct ifnet *, struct mbuf *, struct sockaddr_in *);
static int	ip_getmoptions
	(int, struct ip_moptions *, struct mbuf **);
static int	ip_setmoptions
	(int, struct ip_moptions **, struct mbuf *);
#endif
static int	ip_optcopy(struct ip *, struct ip *);
static int	ip_pcbopts(struct mbuf **, struct mbuf *);
d70 1
a70 2
int
ip_output(m0, opt, ro, flags, imo)
a74 1
	struct ip_moptions *imo;
d76 4
a79 4
	struct ip *ip, *mhip;
	struct ifnet *ifp;
	struct mbuf *m = m0;
	int hlen = sizeof (struct ip);
d81 1
a82 2
	struct in_ifaddr *ia;
	int isbroadcast;
d84 9
a92 2
#ifdef DEBUG
	    if( DODEBUG((1 << 16)) )
d94 1
a94 6
		int i = 0;
		struct mbuf *m1;

		Printf("\021\003ip_output Packet Dump:\n");

		for( m1 = m0; m1; m1 = m1->m_next )
d96 2
a97 12
		    int j;
		    u_char *cptr = mtod(m1, u_char *);

		    for( j = 0; j < m1->m_len; ++j )
		    {
			Printf("%02x", *cptr++);

			if( !(++i % 32) )
			    Printf("\n");
			else if( !(i % 4) )
			    Printf("  ");
		    }
d99 3
a102 13
		if( (i % 32) )
		    Printf("\021\007\n");
	    Printf("\021\07\n");
	    Printf("   ro=%x, ro->ro_rt=%x, ro->ro_dst.sa_family=%d\n", ro, ro->ro_rt, ro->ro_dst.sa_family);
	    }
#endif
#ifdef DIAGNOSTIC
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("ip_output no HDR");
	if (!ro)
		panic("ip_output no route, proto = %d",
		      mtod(m, struct ip *)->ip_p);
#endif
a104 3
#ifdef DEBUG
Printf("Inserted options: m=%x\n", m);
#endif
d111 2
a112 2
	if ((flags & (IP_FORWARDING|IP_RAWOUTPUT)) == 0) {
		ip->ip_vhl = IP_MAKE_VHL(IPVERSION, hlen >> 2);
d115 3
a117 4
		ipstat.ips_localout++;
	} else {
		hlen = IP_VHL_HL(ip->ip_vhl) << 2;
        }
d119 7
a138 1
		dst->sin_len = sizeof(*dst);
a144 2
#define ifatoia(ifa)	((struct in_ifaddr *)(ifa))
#define sintosa(sin)	((struct sockaddr *)(sin))
d146 6
a151 3
		if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst)))) == 0 &&
		    (ia = ifatoia(ifa_ifwithnet(sintosa(dst)))) == 0) {
			ipstat.ips_noroute++;
a155 2
		ip->ip_ttl = 1;
		isbroadcast = in_broadcast(dst->sin_addr, ifp);
a156 9
		/*
		 * If this is the case, we probably don't want to allocate
		 * a protocol-cloned route since we didn't get one from the
		 * ULP.  This lets TCP do its thing, while not burdening
		 * forwarding or ICMP with the overhead of cloning a route.
		 * Of course, we still want to do any cloning requested by
		 * the link layer, as this is probably required in all cases
		 * for correct operation (as it is for ARP).
		 */
d158 6
a163 4
			rtalloc_ign(ro, RTF_PRCLONING);
		if (ro->ro_rt == 0) {
			ipstat.ips_noroute++;
			error = EHOSTUNREACH;
a165 2
		ia = ifatoia(ro->ro_rt->rt_ifa);
		ifp = ro->ro_rt->rt_ifp;
d168 1
a168 109
			dst = (struct sockaddr_in *)ro->ro_rt->rt_gateway;
#ifdef NotYet
		if (ro->ro_rt->rt_flags & RTF_HOST)
			isbroadcast = (ro->ro_rt->rt_flags & RTF_BROADCAST);
		else
			isbroadcast = in_broadcast(dst->sin_addr, ifp);
#else
		isbroadcast = in_broadcast(dst->sin_addr, ifp);
#endif
	}
#ifdef MULTICAST
	if (IN_MULTICAST(ntohl(ip->ip_dst.s_addr))) {
		struct in_multi *inm;

		m->m_flags |= M_MCAST;
		/*
		 * IP destination address is multicast.  Make sure "dst"
		 * still points to the address in "ro".  (It may have been
		 * changed to point to a gateway address, above.)
		 */
		dst = (struct sockaddr_in *)&ro->ro_dst;
		/*
		 * See if the caller provided any multicast options
		 */
		if (imo != NULL) {
			ip->ip_ttl = imo->imo_multicast_ttl;
			if (imo->imo_multicast_ifp != NULL)
				ifp = imo->imo_multicast_ifp;
			if (imo->imo_multicast_vif != -1)
				ip->ip_src.s_addr =
				    ip_mcast_src(imo->imo_multicast_vif);
		} else
			ip->ip_ttl = IP_DEFAULT_MULTICAST_TTL;
		/*
		 * Confirm that the outgoing interface supports multicast.
		 */
		if ((imo == NULL) || (imo->imo_multicast_vif == -1)) {
			if ((ifp->if_flags & IFF_MULTICAST) == 0) {
				ipstat.ips_noroute++;
				error = ENETUNREACH;
				goto bad;
			}
		}
		/*
		 * If source address not specified yet, use address
		 * of outgoing interface.
		 */
		if (ip->ip_src.s_addr == INADDR_ANY) {
			register struct in_ifaddr *ia;

			for (ia = in_ifaddr; ia; ia = ia->ia_next)
				if (ia->ia_ifp == ifp) {
					ip->ip_src = IA_SIN(ia)->sin_addr;
					break;
				}
		}

		IN_LOOKUP_MULTI(ip->ip_dst, ifp, inm);
		if (inm != NULL &&
		   (imo == NULL || imo->imo_multicast_loop)) {
			/*
			 * If we belong to the destination multicast group
			 * on the outgoing interface, and the caller did not
			 * forbid loopback, loop back a copy.
			 */
			ip_mloopback(ifp, m, dst);
		}
		else {
			/*
			 * If we are acting as a multicast router, perform
			 * multicast forwarding as if the packet had just
			 * arrived on the interface to which we are about
			 * to send.  The multicast forwarding function
			 * recursively calls this function, using the
			 * IP_FORWARDING flag to prevent infinite recursion.
			 *
			 * Multicasts that are looped back by ip_mloopback(),
			 * above, will be forwarded by the ip_input() routine,
			 * if necessary.
			 */
			if (ip_mrouter && (flags & IP_FORWARDING) == 0) {
				/*
				 * Check if rsvp daemon is running. If not, don't
				 * set ip_moptions. This ensures that the packet
				 * is multicast and not just sent down one link
				 * as prescribed by rsvpd.
				 */
				if (!rsvp_on)
				  imo = NULL;
				if (ip_mforward(ip, ifp, m, imo) != 0) {
					m_freem(m);
					goto done;
				}
			}
		}
		/*
		 * Multicasts with a time-to-live of zero may be looped-
		 * back, above, but must not be transmitted on a network.
		 * Also, multicasts addressed to the loopback interface
		 * are not sent -- the above call to ip_mloopback() will
		 * loop back a copy if this host actually belongs to the
		 * destination group on the loopback interface.
		 */
		if (ip->ip_ttl == 0 || ifp->if_flags & IFF_LOOPBACK) {
			m_freem(m);
			goto done;
		}

		goto sendit;
a169 1
#endif
d175 8
a182 15
	if (ip->ip_src.s_addr == INADDR_ANY)
		ip->ip_src = IA_SIN(ia)->sin_addr;
#endif
#ifndef __riscos
        /*
         * Irrelevant as we don't actually queue the packets
         */
	/*
	 * Verify that we have any chance at all of being able to queue
	 *      the packet or packet fragments
	 */
	if ((ifp->if_snd.ifq_len + ip->ip_len / ifp->if_mtu + 1) >=
		ifp->if_snd.ifq_maxlen) {
			error = ENOBUFS;
			goto bad;
a184 1

d190 1
a190 1
	if (isbroadcast) {
d200 1
a200 1
		if ((u_short)ip->ip_len > ifp->if_mtu) {
a203 3
		m->m_flags |= M_BCAST;
	} else {
		m->m_flags &= ~M_BCAST;
a205 11
sendit:
#ifdef IPFIREWALL
	/*
	 * Check with the firewall...
	 */
	if (ip_fw_chk_ptr && !(*ip_fw_chk_ptr)(&ip, hlen, ifp, 1, &m)) {
		error = EACCES;
		goto done;
	}
#endif

d209 1
a209 1
	if ((u_short)ip->ip_len <= ifp->if_mtu) {
d213 2
a214 10
		if (ip->ip_vhl == IP_VHL_BORING) {
			ip->ip_sum = in_cksum_hdr(ip);
		} else {
			ip->ip_sum = in_cksum(m, hlen);
		}
		error = (*ifp->if_output)(ifp, m,
				(struct sockaddr *)dst, ro->ro_rt);
#if 0
Printf("\x11\x03ip_output: fired directly; error=%d\n", error);
#endif
d217 1
a223 1
		ipstat.ips_cantfrag++;
a228 12
		/*
		 * This case can happen if the user changed the MTU
		 * of an interface after enabling IP on it.  Because
		 * most netifs don't keep track of routes pointing to
		 * them, there is no way for one to update all its
		 * routes when the MTU is changed.
		 */
		if ((ro->ro_rt->rt_flags & (RTF_UP | RTF_HOST))
		    && !(ro->ro_rt->rt_rmx.rmx_locks & RTV_MTU)
		    && (ro->ro_rt->rt_rmx.rmx_mtu > ifp->if_mtu)) {
			ro->ro_rt->rt_rmx.rmx_mtu = ifp->if_mtu;
		}
d235 1
a235 1
	struct mbuf **mnext = &m->m_nextpkt;
d243 3
a245 2
	for (off = hlen + len; off < (u_short)ip->ip_len; off += len) {
		MGETHDR(m, M_DONTWAIT, MT_HEADER);
d247 7
d255 2
a256 2
		        if( DODEBUG(DBGMMAN) )
				Printf("ip_output: ALLOC_S failed\n");
d258 2
a259 3
			error = ENOBUFS;
			ipstat.ips_odropped++;
			goto sendorfree;
d261 3
a263 1
		m->m_off += max_linkhdr;
d268 1
a268 1
			mhip->ip_vhl = IP_MAKE_VHL(IPVERSION, mhlen >> 2);
d274 2
a275 2
		if (off + len >= (u_short)ip->ip_len)
			len = (u_short)ip->ip_len - off;
a291 3
#ifdef OldCode
			(void) m_free(m);
#endif
d293 3
a295 1
			ipstat.ips_odropped++;
a297 2
		m->m_pkthdr.len = mhlen + len;
		m->m_pkthdr.rcvif = (struct ifnet *)0;
d300 1
a300 5
		if (mhip->ip_vhl == IP_VHL_BORING) {
			mhip->ip_sum = in_cksum_hdr(mhip);    /* KJB fix */
		} else {
			mhip->ip_sum = in_cksum(m, mhlen);
		}
d302 1
a302 2
		mnext = &m->m_nextpkt;
		ipstat.ips_ofragments++;
a307 1
	m = m0;
d309 1
a309 1
	m_adj(m, hlen + firstlen - (u_short)ip->ip_len);
d315 1
a315 1
	master = m;
d317 1
a317 1
	TRIM(m, hlen + firstlen - (u_short)ip->ip_len, NULL);
d319 1
a319 1
	if( (m = COPY_U(master, 0, M_COPYALL)) == NULL )
d329 1
a329 1
	m->m_list = master->m_list;
d332 1
a332 2
	m->m_pkthdr.len = hlen + firstlen;
	ip->ip_len = htons((u_short)m->m_pkthdr.len);
d335 3
a337 6
	if (ip->ip_vhl == IP_VHL_BORING) {
		ip->ip_sum = in_cksum_hdr(ip);
	} else {
		ip->ip_sum = in_cksum(m, hlen);
	}
sendorfree:
d340 2
a341 2
		m0 = m->m_list;
		m->m_list = 0;
d344 1
a344 1
			    (struct sockaddr *)dst, ro->ro_rt);
d355 1
a355 1
	    error = (ifp->if_output)(ifp, m, (struct sockaddr *)dst, ro->ro_rt);
d364 1
a364 1
		m_freem(m0);
d372 1
a372 1
	m_freem(master);
a373 2
	if (error == 0)
		ipstat.ips_fragmented++;
d375 6
a380 1
done:
d383 1
d385 3
a394 2
 *
 * XXX This routine assumes that the packet has no options in place.
d396 1
a396 1
static struct mbuf *
a407 2
	if (optlen + (u_short)ip->ip_len > IP_MAXPACKET)
		return (m);		/* XXX should fail */
d411 2
a412 2
	if (m->m_flags & M_EXT || m->m_data - optlen < m->m_pktdat) {
		MGETHDR(n, M_DONTWAIT, MT_HEADER);
a414 1
		n->m_pkthdr.len = m->m_pkthdr.len + optlen;
d416 1
a416 1
		m->m_data += sizeof(struct ip);
d419 1
d421 2
a422 2
		m->m_data += max_linkhdr;
		(void)memcpy(mtod(m, void *), ip, sizeof(struct ip));
d429 1
a429 1
	if(m->m_off - optlen < m->m_inioff)
d431 2
a432 2
	        n = ALLOC_S(MINCONTIG, NULL);
	        if (n == 0) {
d434 2
a435 2
			if( DODEBUG(DBGMMAN) )
		    		Printf("ip_insertoptions: ALLOC_S failed\n");
d437 14
a450 11
	        	return (m);
	        }
		n->m_type = MT_HEADER;
		n->m_pkthdr.len = m->m_pkthdr.len + optlen;
		m->m_len -= sizeof(struct ip);
		m->m_off += sizeof(struct ip);
		n->m_next = m;
		m = n;
		m->m_len = optlen + sizeof(struct ip);
		m->m_off += max_linkhdr;
		(void)memcpy(mtod(m, void *), ip, sizeof(struct ip));
d452 1
a452 1
	} else {
a454 1
		m->m_pkthdr.len += optlen;
d458 1
a458 1
	(void)memcpy(ip + 1, p->ipopt_list, (unsigned)optlen);
a459 1
	ip->ip_vhl = IP_MAKE_VHL(IPVERSION, *phlen >> 2);
a467 1
static int
d476 1
a476 1
	cnt = (IP_VHL_HL(ip->ip_vhl) << 2) - sizeof (struct ip);
d481 1
a481 3
		if (opt == IPOPT_NOP) {
			/* Preserve for IP mcast tunnel's LSRR alignment. */
			*dp++ = IPOPT_NOP;
d483 1
a483 2
			continue;
		} else
d489 1
a489 1
			(void)memcpy(dp, cp, (unsigned)optlen);
d501 1
a501 2
int
ip_ctloutput(op, so, level, optname, mp)
d505 1
a505 1
	struct mbuf **mp;
a506 3
	register struct inpcb *inp = sotoinpcb(so);
	register struct mbuf *m = *mp;
	register int optval = 0;
d508 1
d510 1
a510 1
	if (level != IPPROTO_IP) {
d512 1
a512 3
		if (op == PRCO_SETOPT && *mp)
			(void) m_free(*mp);
	} else switch (op) {
d517 1
a517 87
#ifdef notyet
		case IP_RETOPTS:
			return (ip_pcbopts(optname, &inp->inp_options, m));
#else
			return (ip_pcbopts(&inp->inp_options, m));
#endif

		case IP_TOS:
		case IP_TTL:
		case IP_RECVOPTS:
		case IP_RECVRETOPTS:
		case IP_RECVDSTADDR:
			if (m == 0 || m->m_len != sizeof(int))
				error = EINVAL;
			else {
				optval = *mtod(m, int *);
				switch (optname) {

				case IP_TOS:
					inp->inp_ip.ip_tos = optval;
					break;

				case IP_TTL:
					inp->inp_ip.ip_ttl = optval;
					break;
#define	OPTSET(bit) \
	if (optval) \
		inp->inp_flags |= bit; \
	else \
		inp->inp_flags &= ~bit;

				case IP_RECVOPTS:
					OPTSET(INP_RECVOPTS);
					break;

				case IP_RECVRETOPTS:
					OPTSET(INP_RECVRETOPTS);
					break;

				case IP_RECVDSTADDR:
					OPTSET(INP_RECVDSTADDR);
					break;
				}
			}
			break;
#undef OPTSET

#ifdef MULTICAST
		case IP_MULTICAST_IF:
		case IP_MULTICAST_VIF:
		case IP_MULTICAST_TTL:
		case IP_MULTICAST_LOOP:
		case IP_ADD_MEMBERSHIP:
		case IP_DROP_MEMBERSHIP:
			error = ip_setmoptions(optname, &inp->inp_moptions, m);
			break;

		case IP_PORTRANGE:
			if (m == 0 || m->m_len != sizeof(int))
				error = EINVAL;
			else {
				optval = *mtod(m, int *);

				switch (optval) {

				case IP_PORTRANGE_DEFAULT:
					inp->inp_flags &= ~(INP_LOWPORT);
					inp->inp_flags &= ~(INP_HIGHPORT);
					break;

				case IP_PORTRANGE_HIGH:
					inp->inp_flags &= ~(INP_LOWPORT);
					inp->inp_flags |= INP_HIGHPORT;
					break;

				case IP_PORTRANGE_LOW:
					inp->inp_flags &= ~(INP_HIGHPORT);
					inp->inp_flags |= INP_LOWPORT;
					break;

				default:
					error = EINVAL;
					break;
				}
			}
			break;
#endif
d520 1
a520 1
			error = ENOPROTOOPT;
a522 2
		if (m)
			(void)m_free(m);
d528 5
a532 12
		case IP_RETOPTS:
			*mp = m = ALLOC_S(MINCONTIG, NULL);
			if (m==0)
			        return (ENOBUFS);
			m->m_type=MT_SOOPTS;
			if (inp->inp_options) {
				m->m_len = inp->inp_options->m_len;
				(void)memcpy(mtod(m, void *),
				    mtod(inp->inp_options, void *), (unsigned)m->m_len);
			} else
				m->m_len = 0;
			break;
d534 8
a541 32
		case IP_TOS:
		case IP_TTL:
		case IP_RECVOPTS:
		case IP_RECVRETOPTS:
		case IP_RECVDSTADDR:
			*mp = m = ALLOC_S(MINCONTIG, NULL);
			if (m==0)
			        return (ENOBUFS);
			m->m_type = MT_SOOPTS;
			m->m_len = sizeof(int);
			switch (optname) {

			case IP_TOS:
				optval = inp->inp_ip.ip_tos;
				break;

			case IP_TTL:
				optval = inp->inp_ip.ip_ttl;
				break;

#define	OPTBIT(bit)	(inp->inp_flags & bit ? 1 : 0)

			case IP_RECVOPTS:
				optval = OPTBIT(INP_RECVOPTS);
				break;

			case IP_RECVRETOPTS:
				optval = OPTBIT(INP_RECVRETOPTS);
				break;

			case IP_RECVDSTADDR:
				optval = OPTBIT(INP_RECVDSTADDR);
d543 3
d547 8
a554 25
			*mtod(m, int *) = optval;
			break;

#ifdef MULTICAST
		case IP_MULTICAST_IF:
		case IP_MULTICAST_VIF:
		case IP_MULTICAST_TTL:
		case IP_MULTICAST_LOOP:
		case IP_ADD_MEMBERSHIP:
		case IP_DROP_MEMBERSHIP:
			error = ip_getmoptions(optname, inp->inp_moptions, mp);
			break;

		case IP_PORTRANGE:
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
			m->m_len = sizeof(int);

			if (inp->inp_flags & INP_HIGHPORT)
				optval = IP_PORTRANGE_HIGH;
			else if (inp->inp_flags & INP_LOWPORT)
				optval = IP_PORTRANGE_LOW;
			else
				optval = 0;

			*mtod(m, int *) = optval;
a555 2
#endif

d557 1
a557 1
			error = ENOPROTOOPT;
d562 8
a577 5
static int
#ifdef notyet
ip_pcbopts(optname, pcbopt, m)
	int optname;
#else
a578 1
#endif
d588 7
a594 1
		(void)m_free(*pcbopt);
d601 7
a607 1
			(void)m_free(m);
a610 3
#ifdef DEBUG
        Printf("ip_pcbopts: m=%x, m->m_len=%d, m->m_off=%x\n", m, m->m_len, m->m_off);
#endif
d620 2
a621 1
	if (m->m_off + m->m_len + sizeof(struct in_addr) >= MAXOFF(m))
d623 4
a634 3
#ifdef DEBUG
                Printf("option %d\n", opt);
#endif
a640 3
#ifdef DEBUG
                        Printf("  optlen = %d\n", optlen);
#endif
a680 2
	if (m->m_len > MAX_IPOPTLEN + sizeof(struct in_addr))
		goto bad;
d685 1
d687 3
d693 1
a693 401
#ifdef MULTICAST
/*
 * Set the IP multicast options in response to user setsockopt().
 */
static int
ip_setmoptions(optname, imop, m)
	int optname;
	struct ip_moptions **imop;
	struct mbuf *m;
{
	register int error = 0;
	u_char loop;
	register int i;
	struct in_addr addr;
	register struct ip_mreq *mreq;
	register struct ifnet *ifp;
	register struct ip_moptions *imo = *imop;
	struct route ro;
	register struct sockaddr_in *dst;
	int s;

	if (imo == NULL) {
		/*
		 * No multicast option buffer attached to the pcb;
		 * allocate one and initialize to default values.
		 */
		imo = (struct ip_moptions*)malloc(sizeof(*imo), M_IPMOPTS,
		    M_WAITOK);

		if (imo == NULL)
			return (ENOBUFS);
		*imop = imo;
		imo->imo_multicast_ifp = NULL;
		imo->imo_multicast_vif = -1;
		imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
		imo->imo_multicast_loop = IP_DEFAULT_MULTICAST_LOOP;
		imo->imo_num_memberships = 0;
	}

	switch (optname) {
	/* store an index number for the vif you wanna use in the send */
	case IP_MULTICAST_VIF:
		if (!legal_vif_num) {
			error = EOPNOTSUPP;
			break;
		}
		if (m == NULL || m->m_len != sizeof(int)) {
			error = EINVAL;
			break;
		}
		i = *(mtod(m, int *));
		if (!legal_vif_num(i) && (i != -1)) {
			error = EINVAL;
			break;
		}
		imo->imo_multicast_vif = i;
		break;

	case IP_MULTICAST_IF:
		/*
		 * Select the interface for outgoing multicast packets.
		 */
		if (m == NULL || m->m_len != sizeof(struct in_addr)) {
			error = EINVAL;
			break;
		}
		addr = *(mtod(m, struct in_addr *));
		/*
		 * INADDR_ANY is used to remove a previous selection.
		 * When no interface is selected, a default one is
		 * chosen every time a multicast packet is sent.
		 */
		if (addr.s_addr == INADDR_ANY) {
			imo->imo_multicast_ifp = NULL;
			break;
		}
		/*
		 * The selected interface is identified by its local
		 * IP address.  Find the interface and confirm that
		 * it supports multicasting.
		 */
		s = splimp();
		INADDR_TO_IFP(addr, ifp);
		if (ifp == NULL || (ifp->if_flags & IFF_MULTICAST) == 0) {
			error = EADDRNOTAVAIL;
			break;
		}
		imo->imo_multicast_ifp = ifp;
		splx(s);
		break;

	case IP_MULTICAST_TTL:
		/*
		 * Set the IP time-to-live for outgoing multicast packets.
		 */
		if (m == NULL || m->m_len != 1) {
			error = EINVAL;
			break;
		}
		imo->imo_multicast_ttl = *(mtod(m, u_char *));
		break;

	case IP_MULTICAST_LOOP:
		/*
		 * Set the loopback flag for outgoing multicast packets.
		 * Must be zero or one.
		 */
		if (m == NULL || m->m_len != 1 ||
		   (loop = *(mtod(m, u_char *))) > 1) {
			error = EINVAL;
			break;
		}
		imo->imo_multicast_loop = loop;
		break;

	case IP_ADD_MEMBERSHIP:
		/*
		 * Add a multicast group membership.
		 * Group must be a valid IP multicast address.
		 */
		if (m == NULL || m->m_len != sizeof(struct ip_mreq)) {
			error = EINVAL;
			break;
		}
		mreq = mtod(m, struct ip_mreq *);
		if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr.s_addr))) {
			error = EINVAL;
			break;
		}
		s = splimp();
		/*
		 * If no interface address was provided, use the interface of
		 * the route to the given multicast address.
		 */
		if (mreq->imr_interface.s_addr == INADDR_ANY) {
			bzero((caddr_t)&ro, sizeof(ro));
			dst = (struct sockaddr_in *)&ro.ro_dst;
			dst->sin_len = sizeof(*dst);
			dst->sin_family = AF_INET;
			dst->sin_addr = mreq->imr_multiaddr;
			rtalloc(&ro);
			if (ro.ro_rt == NULL) {
				error = EADDRNOTAVAIL;
				splx(s);
				break;
			}
			ifp = ro.ro_rt->rt_ifp;
			rtfree(ro.ro_rt);
		}
		else {
			INADDR_TO_IFP(mreq->imr_interface, ifp);
		}

		/*
		 * See if we found an interface, and confirm that it
		 * supports multicast.
		 */
		if (ifp == NULL || (ifp->if_flags & IFF_MULTICAST) == 0) {
			error = EADDRNOTAVAIL;
			splx(s);
			break;
		}
		/*
		 * See if the membership already exists or if all the
		 * membership slots are full.
		 */
		for (i = 0; i < imo->imo_num_memberships; ++i) {
			if (imo->imo_membership[i]->inm_ifp == ifp &&
			    imo->imo_membership[i]->inm_addr.s_addr
						== mreq->imr_multiaddr.s_addr)
				break;
		}
		if (i < imo->imo_num_memberships) {
			error = EADDRINUSE;
			splx(s);
			break;
		}
		if (i == IP_MAX_MEMBERSHIPS) {
			error = ETOOMANYREFS;
			splx(s);
			break;
		}
		/*
		 * Everything looks good; add a new record to the multicast
		 * address list for the given interface.
		 */
		if ((imo->imo_membership[i] =
		    in_addmulti(&mreq->imr_multiaddr, ifp)) == NULL) {
			error = ENOBUFS;
			splx(s);
			break;
		}
		++imo->imo_num_memberships;
		splx(s);
		break;

	case IP_DROP_MEMBERSHIP:
		/*
		 * Drop a multicast group membership.
		 * Group must be a valid IP multicast address.
		 */
		if (m == NULL || m->m_len != sizeof(struct ip_mreq)) {
			error = EINVAL;
			break;
		}
		mreq = mtod(m, struct ip_mreq *);
		if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr.s_addr))) {
			error = EINVAL;
			break;
		}

		s = splimp();
		/*
		 * If an interface address was specified, get a pointer
		 * to its ifnet structure.
		 */
		if (mreq->imr_interface.s_addr == INADDR_ANY)
			ifp = NULL;
		else {
			INADDR_TO_IFP(mreq->imr_interface, ifp);
			if (ifp == NULL) {
				error = EADDRNOTAVAIL;
				splx(s);
				break;
			}
		}
		/*
		 * Find the membership in the membership array.
		 */
		for (i = 0; i < imo->imo_num_memberships; ++i) {
			if ((ifp == NULL ||
			     imo->imo_membership[i]->inm_ifp == ifp) &&
			     imo->imo_membership[i]->inm_addr.s_addr ==
			     mreq->imr_multiaddr.s_addr)
				break;
		}
		if (i == imo->imo_num_memberships) {
			error = EADDRNOTAVAIL;
			splx(s);
			break;
		}
		/*
		 * Give up the multicast address record to which the
		 * membership points.
		 */
		in_delmulti(imo->imo_membership[i]);
		/*
		 * Remove the gap in the membership array.
		 */
		for (++i; i < imo->imo_num_memberships; ++i)
			imo->imo_membership[i-1] = imo->imo_membership[i];
		--imo->imo_num_memberships;
		splx(s);
		break;

	default:
		error = EOPNOTSUPP;
		break;
	}

	/*
	 * If all options have default values, no need to keep the mbuf.
	 */
	if (imo->imo_multicast_ifp == NULL &&
	    imo->imo_multicast_vif == -1 &&
	    imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
	    imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
	    imo->imo_num_memberships == 0) {
		free(*imop, M_IPMOPTS);
		*imop = NULL;
	}

	return (error);
}

/*
 * Return the IP multicast options in response to user getsockopt().
 */
static int
ip_getmoptions(optname, imo, mp)
	int optname;
	register struct ip_moptions *imo;
	register struct mbuf **mp;
{
	u_char *ttl;
	u_char *loop;
	struct in_addr *addr;
	struct in_ifaddr *ia;

	*mp = m_get(M_WAIT, MT_SOOPTS);

	switch (optname) {

	case IP_MULTICAST_VIF:
		if (imo != NULL)
			*(mtod(*mp, int *)) = imo->imo_multicast_vif;
		else
			*(mtod(*mp, int *)) = -1;
		(*mp)->m_len = sizeof(int);
		return(0);

	case IP_MULTICAST_IF:
		addr = mtod(*mp, struct in_addr *);
		(*mp)->m_len = sizeof(struct in_addr);
		if (imo == NULL || imo->imo_multicast_ifp == NULL)
			addr->s_addr = INADDR_ANY;
		else {
			IFP_TO_IA(imo->imo_multicast_ifp, ia);
			addr->s_addr = (ia == NULL) ? INADDR_ANY
					: IA_SIN(ia)->sin_addr.s_addr;
		}
		return (0);

	case IP_MULTICAST_TTL:
		ttl = mtod(*mp, u_char *);
		(*mp)->m_len = 1;
		*ttl = (imo == NULL) ? IP_DEFAULT_MULTICAST_TTL
				     : imo->imo_multicast_ttl;
		return (0);

	case IP_MULTICAST_LOOP:
		loop = mtod(*mp, u_char *);
		(*mp)->m_len = 1;
		*loop = (imo == NULL) ? IP_DEFAULT_MULTICAST_LOOP
				      : imo->imo_multicast_loop;
		return (0);

	default:
		return (EOPNOTSUPP);
	}
}

/*
 * Discard the IP multicast options.
 */
void
ip_freemoptions(imo)
	register struct ip_moptions *imo;
{
	register int i;

	if (imo != NULL) {
		for (i = 0; i < imo->imo_num_memberships; ++i)
			in_delmulti(imo->imo_membership[i]);
		free(imo, M_IPMOPTS);
	}
}

/*
 * Routine called from ip_output() to loop back a copy of an IP multicast
 * packet to the input queue of a specified interface.  Note that this
 * calls the output routine of the loopback "driver", but with an interface
 * pointer that might NOT be a loopback interface -- evil, but easier than
 * replicating that code here.
 */
static void
ip_mloopback(ifp, m, dst)
	struct ifnet *ifp;
	register struct mbuf *m;
	register struct sockaddr_in *dst;
{
	register struct ip *ip;
	struct mbuf *copym;

	copym = m_copy(m, 0, M_COPYALL);
	if (copym != NULL) {
		/*
		 * We don't bother to fragment if the IP length is greater
		 * than the interface's MTU.  Can this possibly matter?
		 */
		ip = mtod(copym, struct ip *);
		ip->ip_len = htons((u_short)ip->ip_len);
		ip->ip_off = htons((u_short)ip->ip_off);
		ip->ip_sum = 0;
		if (ip->ip_vhl == IP_VHL_BORING) {
			ip->ip_sum = in_cksum_hdr(ip);
		} else {
			ip->ip_sum = in_cksum(copym,
					      IP_VHL_HL(ip->ip_vhl) << 2);
		}
		/*
		 * NB:
		 * We can't simply call ip_input() directly because
		 * the ip_mforward() depends on the `input interface'
		 * being set to something unreasonable so that we don't
		 * attempt to forward the looped-back copy.
		 * It's also not clear whether there are any lingering
		 * reentrancy problems in other areas which might be
		 * exposed by this code.  For the moment, we'll err
		 * on the side of safety by continuing to abuse
		 * loinput().
		 */
#ifdef notdef
		copym->m_pkthdr.rcvif = &loif[0];
		ip_input(copym)
#else
		(void) looutput(ifp, copym, (struct sockaddr *)dst, NULL);
#endif
	}
}
#endif /* MULTICAST */
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@RCS log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d1 21
d23 2
a24 18
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d26 11
a36 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a37 2
 *	@@(#)ip_output.c	8.3 (Berkeley) 1/21/94
 *	$Id: ip_output.c,v 1.38 1996/05/21 20:47:31 peter Exp $
d39 16
a54 24

#define _IP_VHL

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/errno.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>

#include <netinet/ip_fw.h>
d57 1
a57 1
#include "machine/mtpr.h"
a58 1
#include <machine/in_cksum.h>
a60 4
#include "debug.h"
#include "module.h"

u_short ip_id;
d62 1
a62 11
static struct mbuf *ip_insertoptions(struct mbuf *, struct mbuf *, int *);
#ifdef MULTICAST
static void ip_mloopback
	(struct ifnet *, struct mbuf *, struct sockaddr_in *);
static int	ip_getmoptions
	(int, struct ip_moptions *, struct mbuf **);
static int	ip_setmoptions
	(int, struct ip_moptions **, struct mbuf *);
#endif
static int	ip_optcopy(struct ip *, struct ip *);
static int	ip_pcbopts(struct mbuf **, struct mbuf *);
d70 1
a70 2
int
ip_output(m0, opt, ro, flags, imo)
a74 1
	struct ip_moptions *imo;
d76 4
a79 4
	struct ip *ip, *mhip;
	struct ifnet *ifp;
	struct mbuf *m = m0;
	int hlen = sizeof (struct ip);
d81 1
a82 2
	struct in_ifaddr *ia;
	int isbroadcast;
d84 9
a92 2
#ifdef DEBUG
	    if( DODEBUG((1 << 16)) )
d94 1
a94 6
		int i = 0;
		struct mbuf *m1;

		Printf("\021\003ip_output Packet Dump:\n");

		for( m1 = m0; m1; m1 = m1->m_next )
d96 2
a97 12
		    int j;
		    u_char *cptr = mtod(m1, u_char *);

		    for( j = 0; j < m1->m_len; ++j )
		    {
			Printf("%02x", *cptr++);

			if( !(++i % 32) )
			    Printf("\n");
			else if( !(i % 4) )
			    Printf("  ");
		    }
d99 3
a102 13
		if( (i % 32) )
		    Printf("\021\007\n");
	    Printf("\021\07\n");
	    Printf("   ro=%x, ro->ro_rt=%x, ro->ro_dst.sa_family=%d\n", ro, ro->ro_rt, ro->ro_dst.sa_family);
	    }
#endif
#ifdef DIAGNOSTIC
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("ip_output no HDR");
	if (!ro)
		panic("ip_output no route, proto = %d",
		      mtod(m, struct ip *)->ip_p);
#endif
a104 3
#ifdef DEBUG
Printf("Inserted options: m=%x\n", m);
#endif
d111 2
a112 2
	if ((flags & (IP_FORWARDING|IP_RAWOUTPUT)) == 0) {
		ip->ip_vhl = IP_MAKE_VHL(IPVERSION, hlen >> 2);
d115 3
a117 4
		ipstat.ips_localout++;
	} else {
		hlen = IP_VHL_HL(ip->ip_vhl) << 2;
        }
d119 7
a138 1
		dst->sin_len = sizeof(*dst);
a144 2
#define ifatoia(ifa)	((struct in_ifaddr *)(ifa))
#define sintosa(sin)	((struct sockaddr *)(sin))
d146 6
a151 3
		if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst)))) == 0 &&
		    (ia = ifatoia(ifa_ifwithnet(sintosa(dst)))) == 0) {
			ipstat.ips_noroute++;
a155 2
		ip->ip_ttl = 1;
		isbroadcast = in_broadcast(dst->sin_addr, ifp);
a156 9
		/*
		 * If this is the case, we probably don't want to allocate
		 * a protocol-cloned route since we didn't get one from the
		 * ULP.  This lets TCP do its thing, while not burdening
		 * forwarding or ICMP with the overhead of cloning a route.
		 * Of course, we still want to do any cloning requested by
		 * the link layer, as this is probably required in all cases
		 * for correct operation (as it is for ARP).
		 */
d158 6
a163 4
			rtalloc_ign(ro, RTF_PRCLONING);
		if (ro->ro_rt == 0) {
			ipstat.ips_noroute++;
			error = EHOSTUNREACH;
a165 2
		ia = ifatoia(ro->ro_rt->rt_ifa);
		ifp = ro->ro_rt->rt_ifp;
d168 1
a168 109
			dst = (struct sockaddr_in *)ro->ro_rt->rt_gateway;
#ifdef NotYet
		if (ro->ro_rt->rt_flags & RTF_HOST)
			isbroadcast = (ro->ro_rt->rt_flags & RTF_BROADCAST);
		else
			isbroadcast = in_broadcast(dst->sin_addr, ifp);
#else
		isbroadcast = in_broadcast(dst->sin_addr, ifp);
#endif
	}
#ifdef MULTICAST
	if (IN_MULTICAST(ntohl(ip->ip_dst.s_addr))) {
		struct in_multi *inm;

		m->m_flags |= M_MCAST;
		/*
		 * IP destination address is multicast.  Make sure "dst"
		 * still points to the address in "ro".  (It may have been
		 * changed to point to a gateway address, above.)
		 */
		dst = (struct sockaddr_in *)&ro->ro_dst;
		/*
		 * See if the caller provided any multicast options
		 */
		if (imo != NULL) {
			ip->ip_ttl = imo->imo_multicast_ttl;
			if (imo->imo_multicast_ifp != NULL)
				ifp = imo->imo_multicast_ifp;
			if (imo->imo_multicast_vif != -1)
				ip->ip_src.s_addr =
				    ip_mcast_src(imo->imo_multicast_vif);
		} else
			ip->ip_ttl = IP_DEFAULT_MULTICAST_TTL;
		/*
		 * Confirm that the outgoing interface supports multicast.
		 */
		if ((imo == NULL) || (imo->imo_multicast_vif == -1)) {
			if ((ifp->if_flags & IFF_MULTICAST) == 0) {
				ipstat.ips_noroute++;
				error = ENETUNREACH;
				goto bad;
			}
		}
		/*
		 * If source address not specified yet, use address
		 * of outgoing interface.
		 */
		if (ip->ip_src.s_addr == INADDR_ANY) {
			register struct in_ifaddr *ia;

			for (ia = in_ifaddr; ia; ia = ia->ia_next)
				if (ia->ia_ifp == ifp) {
					ip->ip_src = IA_SIN(ia)->sin_addr;
					break;
				}
		}

		IN_LOOKUP_MULTI(ip->ip_dst, ifp, inm);
		if (inm != NULL &&
		   (imo == NULL || imo->imo_multicast_loop)) {
			/*
			 * If we belong to the destination multicast group
			 * on the outgoing interface, and the caller did not
			 * forbid loopback, loop back a copy.
			 */
			ip_mloopback(ifp, m, dst);
		}
		else {
			/*
			 * If we are acting as a multicast router, perform
			 * multicast forwarding as if the packet had just
			 * arrived on the interface to which we are about
			 * to send.  The multicast forwarding function
			 * recursively calls this function, using the
			 * IP_FORWARDING flag to prevent infinite recursion.
			 *
			 * Multicasts that are looped back by ip_mloopback(),
			 * above, will be forwarded by the ip_input() routine,
			 * if necessary.
			 */
			if (ip_mrouter && (flags & IP_FORWARDING) == 0) {
				/*
				 * Check if rsvp daemon is running. If not, don't
				 * set ip_moptions. This ensures that the packet
				 * is multicast and not just sent down one link
				 * as prescribed by rsvpd.
				 */
				if (!rsvp_on)
				  imo = NULL;
				if (ip_mforward(ip, ifp, m, imo) != 0) {
					m_freem(m);
					goto done;
				}
			}
		}
		/*
		 * Multicasts with a time-to-live of zero may be looped-
		 * back, above, but must not be transmitted on a network.
		 * Also, multicasts addressed to the loopback interface
		 * are not sent -- the above call to ip_mloopback() will
		 * loop back a copy if this host actually belongs to the
		 * destination group on the loopback interface.
		 */
		if (ip->ip_ttl == 0 || ifp->if_flags & IFF_LOOPBACK) {
			m_freem(m);
			goto done;
		}

		goto sendit;
a169 1
#endif
d175 8
a182 15
	if (ip->ip_src.s_addr == INADDR_ANY)
		ip->ip_src = IA_SIN(ia)->sin_addr;
#endif
#ifndef __riscos
        /*
         * Irrelevant as we don't actually queue the packets
         */
	/*
	 * Verify that we have any chance at all of being able to queue
	 *      the packet or packet fragments
	 */
	if ((ifp->if_snd.ifq_len + ip->ip_len / ifp->if_mtu + 1) >=
		ifp->if_snd.ifq_maxlen) {
			error = ENOBUFS;
			goto bad;
a184 1

d190 1
a190 1
	if (isbroadcast) {
d200 1
a200 1
		if ((u_short)ip->ip_len > ifp->if_mtu) {
a203 3
		m->m_flags |= M_BCAST;
	} else {
		m->m_flags &= ~M_BCAST;
a205 11
sendit:
#ifdef IPFIREWALL
	/*
	 * Check with the firewall...
	 */
	if (ip_fw_chk_ptr && !(*ip_fw_chk_ptr)(&ip, hlen, ifp, 1, &m)) {
		error = EACCES;
		goto done;
	}
#endif

d209 1
a209 1
	if ((u_short)ip->ip_len <= ifp->if_mtu) {
d213 2
a214 10
		if (ip->ip_vhl == IP_VHL_BORING) {
			ip->ip_sum = in_cksum_hdr(ip);
		} else {
			ip->ip_sum = in_cksum(m, hlen);
		}
		error = (*ifp->if_output)(ifp, m,
				(struct sockaddr *)dst, ro->ro_rt);
#if 0
Printf("\x11\x03ip_output: fired directly; error=%d\n", error);
#endif
d217 1
a223 1
		ipstat.ips_cantfrag++;
a228 12
		/*
		 * This case can happen if the user changed the MTU
		 * of an interface after enabling IP on it.  Because
		 * most netifs don't keep track of routes pointing to
		 * them, there is no way for one to update all its
		 * routes when the MTU is changed.
		 */
		if ((ro->ro_rt->rt_flags & (RTF_UP | RTF_HOST))
		    && !(ro->ro_rt->rt_rmx.rmx_locks & RTV_MTU)
		    && (ro->ro_rt->rt_rmx.rmx_mtu > ifp->if_mtu)) {
			ro->ro_rt->rt_rmx.rmx_mtu = ifp->if_mtu;
		}
d235 1
a235 1
	struct mbuf **mnext = &m->m_nextpkt;
d243 3
a245 2
	for (off = hlen + len; off < (u_short)ip->ip_len; off += len) {
		MGETHDR(m, M_DONTWAIT, MT_HEADER);
d247 7
d255 2
a256 2
		        if( DODEBUG(DBGMMAN) )
				Printf("ip_output: ALLOC_S failed\n");
d258 2
a259 3
			error = ENOBUFS;
			ipstat.ips_odropped++;
			goto sendorfree;
d261 3
a263 1
		m->m_off += max_linkhdr;
d268 1
a268 1
			mhip->ip_vhl = IP_MAKE_VHL(IPVERSION, mhlen >> 2);
d274 2
a275 2
		if (off + len >= (u_short)ip->ip_len)
			len = (u_short)ip->ip_len - off;
a291 3
#ifdef OldCode
			(void) m_free(m);
#endif
d293 3
a295 1
			ipstat.ips_odropped++;
a297 2
		m->m_pkthdr.len = mhlen + len;
		m->m_pkthdr.rcvif = (struct ifnet *)0;
d300 1
a300 5
		if (mhip->ip_vhl == IP_VHL_BORING) {
			mhip->ip_sum = in_cksum_hdr(mhip);    /* KJB fix */
		} else {
			mhip->ip_sum = in_cksum(m, mhlen);
		}
d302 1
a302 2
		mnext = &m->m_nextpkt;
		ipstat.ips_ofragments++;
a307 1
	m = m0;
d309 1
a309 1
	m_adj(m, hlen + firstlen - (u_short)ip->ip_len);
d315 1
a315 1
	master = m;
d317 1
a317 1
	TRIM(m, hlen + firstlen - (u_short)ip->ip_len, NULL);
d319 1
a319 1
	if( (m = COPY_U(master, 0, M_COPYALL)) == NULL )
d329 1
a329 1
	m->m_list = master->m_list;
d332 1
a332 2
	m->m_pkthdr.len = hlen + firstlen;
	ip->ip_len = htons((u_short)m->m_pkthdr.len);
d335 3
a337 6
	if (ip->ip_vhl == IP_VHL_BORING) {
		ip->ip_sum = in_cksum_hdr(ip);
	} else {
		ip->ip_sum = in_cksum(m, hlen);
	}
sendorfree:
d340 2
a341 2
		m0 = m->m_list;
		m->m_list = 0;
d344 1
a344 1
			    (struct sockaddr *)dst, ro->ro_rt);
d355 1
a355 1
	    error = (ifp->if_output)(ifp, m, (struct sockaddr *)dst, ro->ro_rt);
d364 1
a364 1
		m_freem(m0);
d372 1
a372 1
	m_freem(master);
a373 2
	if (error == 0)
		ipstat.ips_fragmented++;
d375 6
a380 1
done:
d383 1
d385 3
a394 2
 *
 * XXX This routine assumes that the packet has no options in place.
d396 1
a396 1
static struct mbuf *
a407 2
	if (optlen + (u_short)ip->ip_len > IP_MAXPACKET)
		return (m);		/* XXX should fail */
d411 2
a412 2
	if (m->m_flags & M_EXT || m->m_data - optlen < m->m_pktdat) {
		MGETHDR(n, M_DONTWAIT, MT_HEADER);
a414 1
		n->m_pkthdr.len = m->m_pkthdr.len + optlen;
d416 1
a416 1
		m->m_data += sizeof(struct ip);
d419 1
d421 2
a422 2
		m->m_data += max_linkhdr;
		(void)memcpy(mtod(m, void *), ip, sizeof(struct ip));
d429 1
a429 1
	if(m->m_off - optlen < m->m_inioff)
d431 2
a432 2
	        n = ALLOC_S(MINCONTIG, NULL);
	        if (n == 0) {
d434 2
a435 2
			if( DODEBUG(DBGMMAN) )
		    		Printf("ip_insertoptions: ALLOC_S failed\n");
d437 14
a450 11
	        	return (m);
	        }
		n->m_type = MT_HEADER;
		n->m_pkthdr.len = m->m_pkthdr.len + optlen;
		m->m_len -= sizeof(struct ip);
		m->m_off += sizeof(struct ip);
		n->m_next = m;
		m = n;
		m->m_len = optlen + sizeof(struct ip);
		m->m_off += max_linkhdr;
		(void)memcpy(mtod(m, void *), ip, sizeof(struct ip));
d452 1
a452 1
	} else {
a454 1
		m->m_pkthdr.len += optlen;
d458 1
a458 1
	(void)memcpy(ip + 1, p->ipopt_list, (unsigned)optlen);
a459 1
	ip->ip_vhl = IP_MAKE_VHL(IPVERSION, *phlen >> 2);
a467 1
static int
d476 1
a476 1
	cnt = (IP_VHL_HL(ip->ip_vhl) << 2) - sizeof (struct ip);
d481 1
a481 3
		if (opt == IPOPT_NOP) {
			/* Preserve for IP mcast tunnel's LSRR alignment. */
			*dp++ = IPOPT_NOP;
d483 1
a483 2
			continue;
		} else
d489 1
a489 1
			(void)memcpy(dp, cp, (unsigned)optlen);
d501 1
a501 2
int
ip_ctloutput(op, so, level, optname, mp)
d505 1
a505 1
	struct mbuf **mp;
a506 3
	register struct inpcb *inp = sotoinpcb(so);
	register struct mbuf *m = *mp;
	register int optval = 0;
d508 1
d510 1
a510 1
	if (level != IPPROTO_IP) {
d512 1
a512 3
		if (op == PRCO_SETOPT && *mp)
			(void) m_free(*mp);
	} else switch (op) {
d517 1
a517 87
#ifdef notyet
		case IP_RETOPTS:
			return (ip_pcbopts(optname, &inp->inp_options, m));
#else
			return (ip_pcbopts(&inp->inp_options, m));
#endif

		case IP_TOS:
		case IP_TTL:
		case IP_RECVOPTS:
		case IP_RECVRETOPTS:
		case IP_RECVDSTADDR:
			if (m == 0 || m->m_len != sizeof(int))
				error = EINVAL;
			else {
				optval = *mtod(m, int *);
				switch (optname) {

				case IP_TOS:
					inp->inp_ip.ip_tos = optval;
					break;

				case IP_TTL:
					inp->inp_ip.ip_ttl = optval;
					break;
#define	OPTSET(bit) \
	if (optval) \
		inp->inp_flags |= bit; \
	else \
		inp->inp_flags &= ~bit;

				case IP_RECVOPTS:
					OPTSET(INP_RECVOPTS);
					break;

				case IP_RECVRETOPTS:
					OPTSET(INP_RECVRETOPTS);
					break;

				case IP_RECVDSTADDR:
					OPTSET(INP_RECVDSTADDR);
					break;
				}
			}
			break;
#undef OPTSET

#ifdef MULTICAST
		case IP_MULTICAST_IF:
		case IP_MULTICAST_VIF:
		case IP_MULTICAST_TTL:
		case IP_MULTICAST_LOOP:
		case IP_ADD_MEMBERSHIP:
		case IP_DROP_MEMBERSHIP:
			error = ip_setmoptions(optname, &inp->inp_moptions, m);
			break;

		case IP_PORTRANGE:
			if (m == 0 || m->m_len != sizeof(int))
				error = EINVAL;
			else {
				optval = *mtod(m, int *);

				switch (optval) {

				case IP_PORTRANGE_DEFAULT:
					inp->inp_flags &= ~(INP_LOWPORT);
					inp->inp_flags &= ~(INP_HIGHPORT);
					break;

				case IP_PORTRANGE_HIGH:
					inp->inp_flags &= ~(INP_LOWPORT);
					inp->inp_flags |= INP_HIGHPORT;
					break;

				case IP_PORTRANGE_LOW:
					inp->inp_flags &= ~(INP_HIGHPORT);
					inp->inp_flags |= INP_LOWPORT;
					break;

				default:
					error = EINVAL;
					break;
				}
			}
			break;
#endif
d520 1
a520 1
			error = ENOPROTOOPT;
a522 2
		if (m)
			(void)m_free(m);
d528 5
a532 12
		case IP_RETOPTS:
			*mp = m = ALLOC_S(MINCONTIG, NULL);
			if (m==0)
			        return (ENOBUFS);
			m->m_type=MT_SOOPTS;
			if (inp->inp_options) {
				m->m_len = inp->inp_options->m_len;
				(void)memcpy(mtod(m, void *),
				    mtod(inp->inp_options, void *), (unsigned)m->m_len);
			} else
				m->m_len = 0;
			break;
d534 8
a541 32
		case IP_TOS:
		case IP_TTL:
		case IP_RECVOPTS:
		case IP_RECVRETOPTS:
		case IP_RECVDSTADDR:
			*mp = m = ALLOC_S(MINCONTIG, NULL);
			if (m==0)
			        return (ENOBUFS);
			m->m_type = MT_SOOPTS;
			m->m_len = sizeof(int);
			switch (optname) {

			case IP_TOS:
				optval = inp->inp_ip.ip_tos;
				break;

			case IP_TTL:
				optval = inp->inp_ip.ip_ttl;
				break;

#define	OPTBIT(bit)	(inp->inp_flags & bit ? 1 : 0)

			case IP_RECVOPTS:
				optval = OPTBIT(INP_RECVOPTS);
				break;

			case IP_RECVRETOPTS:
				optval = OPTBIT(INP_RECVRETOPTS);
				break;

			case IP_RECVDSTADDR:
				optval = OPTBIT(INP_RECVDSTADDR);
d543 3
d547 8
a554 25
			*mtod(m, int *) = optval;
			break;

#ifdef MULTICAST
		case IP_MULTICAST_IF:
		case IP_MULTICAST_VIF:
		case IP_MULTICAST_TTL:
		case IP_MULTICAST_LOOP:
		case IP_ADD_MEMBERSHIP:
		case IP_DROP_MEMBERSHIP:
			error = ip_getmoptions(optname, inp->inp_moptions, mp);
			break;

		case IP_PORTRANGE:
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
			m->m_len = sizeof(int);

			if (inp->inp_flags & INP_HIGHPORT)
				optval = IP_PORTRANGE_HIGH;
			else if (inp->inp_flags & INP_LOWPORT)
				optval = IP_PORTRANGE_LOW;
			else
				optval = 0;

			*mtod(m, int *) = optval;
a555 2
#endif

d557 1
a557 1
			error = ENOPROTOOPT;
d562 8
a577 5
static int
#ifdef notyet
ip_pcbopts(optname, pcbopt, m)
	int optname;
#else
a578 1
#endif
d588 7
a594 1
		(void)m_free(*pcbopt);
d601 7
a607 1
			(void)m_free(m);
a610 3
#ifdef DEBUG
        Printf("ip_pcbopts: m=%x, m->m_len=%d, m->m_off=%x\n", m, m->m_len, m->m_off);
#endif
d620 2
a621 1
	if (m->m_off + m->m_len + sizeof(struct in_addr) >= MAXOFF(m))
d623 4
a634 3
#ifdef DEBUG
                Printf("option %d\n", opt);
#endif
a640 3
#ifdef DEBUG
                        Printf("  optlen = %d\n", optlen);
#endif
a680 2
	if (m->m_len > MAX_IPOPTLEN + sizeof(struct in_addr))
		goto bad;
d685 1
d687 3
d693 1
a693 401
#ifdef MULTICAST
/*
 * Set the IP multicast options in response to user setsockopt().
 */
static int
ip_setmoptions(optname, imop, m)
	int optname;
	struct ip_moptions **imop;
	struct mbuf *m;
{
	register int error = 0;
	u_char loop;
	register int i;
	struct in_addr addr;
	register struct ip_mreq *mreq;
	register struct ifnet *ifp;
	register struct ip_moptions *imo = *imop;
	struct route ro;
	register struct sockaddr_in *dst;
	int s;

	if (imo == NULL) {
		/*
		 * No multicast option buffer attached to the pcb;
		 * allocate one and initialize to default values.
		 */
		imo = (struct ip_moptions*)malloc(sizeof(*imo), M_IPMOPTS,
		    M_WAITOK);

		if (imo == NULL)
			return (ENOBUFS);
		*imop = imo;
		imo->imo_multicast_ifp = NULL;
		imo->imo_multicast_vif = -1;
		imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
		imo->imo_multicast_loop = IP_DEFAULT_MULTICAST_LOOP;
		imo->imo_num_memberships = 0;
	}

	switch (optname) {
	/* store an index number for the vif you wanna use in the send */
	case IP_MULTICAST_VIF:
		if (!legal_vif_num) {
			error = EOPNOTSUPP;
			break;
		}
		if (m == NULL || m->m_len != sizeof(int)) {
			error = EINVAL;
			break;
		}
		i = *(mtod(m, int *));
		if (!legal_vif_num(i) && (i != -1)) {
			error = EINVAL;
			break;
		}
		imo->imo_multicast_vif = i;
		break;

	case IP_MULTICAST_IF:
		/*
		 * Select the interface for outgoing multicast packets.
		 */
		if (m == NULL || m->m_len != sizeof(struct in_addr)) {
			error = EINVAL;
			break;
		}
		addr = *(mtod(m, struct in_addr *));
		/*
		 * INADDR_ANY is used to remove a previous selection.
		 * When no interface is selected, a default one is
		 * chosen every time a multicast packet is sent.
		 */
		if (addr.s_addr == INADDR_ANY) {
			imo->imo_multicast_ifp = NULL;
			break;
		}
		/*
		 * The selected interface is identified by its local
		 * IP address.  Find the interface and confirm that
		 * it supports multicasting.
		 */
		s = splimp();
		INADDR_TO_IFP(addr, ifp);
		if (ifp == NULL || (ifp->if_flags & IFF_MULTICAST) == 0) {
			error = EADDRNOTAVAIL;
			break;
		}
		imo->imo_multicast_ifp = ifp;
		splx(s);
		break;

	case IP_MULTICAST_TTL:
		/*
		 * Set the IP time-to-live for outgoing multicast packets.
		 */
		if (m == NULL || m->m_len != 1) {
			error = EINVAL;
			break;
		}
		imo->imo_multicast_ttl = *(mtod(m, u_char *));
		break;

	case IP_MULTICAST_LOOP:
		/*
		 * Set the loopback flag for outgoing multicast packets.
		 * Must be zero or one.
		 */
		if (m == NULL || m->m_len != 1 ||
		   (loop = *(mtod(m, u_char *))) > 1) {
			error = EINVAL;
			break;
		}
		imo->imo_multicast_loop = loop;
		break;

	case IP_ADD_MEMBERSHIP:
		/*
		 * Add a multicast group membership.
		 * Group must be a valid IP multicast address.
		 */
		if (m == NULL || m->m_len != sizeof(struct ip_mreq)) {
			error = EINVAL;
			break;
		}
		mreq = mtod(m, struct ip_mreq *);
		if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr.s_addr))) {
			error = EINVAL;
			break;
		}
		s = splimp();
		/*
		 * If no interface address was provided, use the interface of
		 * the route to the given multicast address.
		 */
		if (mreq->imr_interface.s_addr == INADDR_ANY) {
			bzero((caddr_t)&ro, sizeof(ro));
			dst = (struct sockaddr_in *)&ro.ro_dst;
			dst->sin_len = sizeof(*dst);
			dst->sin_family = AF_INET;
			dst->sin_addr = mreq->imr_multiaddr;
			rtalloc(&ro);
			if (ro.ro_rt == NULL) {
				error = EADDRNOTAVAIL;
				splx(s);
				break;
			}
			ifp = ro.ro_rt->rt_ifp;
			rtfree(ro.ro_rt);
		}
		else {
			INADDR_TO_IFP(mreq->imr_interface, ifp);
		}

		/*
		 * See if we found an interface, and confirm that it
		 * supports multicast.
		 */
		if (ifp == NULL || (ifp->if_flags & IFF_MULTICAST) == 0) {
			error = EADDRNOTAVAIL;
			splx(s);
			break;
		}
		/*
		 * See if the membership already exists or if all the
		 * membership slots are full.
		 */
		for (i = 0; i < imo->imo_num_memberships; ++i) {
			if (imo->imo_membership[i]->inm_ifp == ifp &&
			    imo->imo_membership[i]->inm_addr.s_addr
						== mreq->imr_multiaddr.s_addr)
				break;
		}
		if (i < imo->imo_num_memberships) {
			error = EADDRINUSE;
			splx(s);
			break;
		}
		if (i == IP_MAX_MEMBERSHIPS) {
			error = ETOOMANYREFS;
			splx(s);
			break;
		}
		/*
		 * Everything looks good; add a new record to the multicast
		 * address list for the given interface.
		 */
		if ((imo->imo_membership[i] =
		    in_addmulti(&mreq->imr_multiaddr, ifp)) == NULL) {
			error = ENOBUFS;
			splx(s);
			break;
		}
		++imo->imo_num_memberships;
		splx(s);
		break;

	case IP_DROP_MEMBERSHIP:
		/*
		 * Drop a multicast group membership.
		 * Group must be a valid IP multicast address.
		 */
		if (m == NULL || m->m_len != sizeof(struct ip_mreq)) {
			error = EINVAL;
			break;
		}
		mreq = mtod(m, struct ip_mreq *);
		if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr.s_addr))) {
			error = EINVAL;
			break;
		}

		s = splimp();
		/*
		 * If an interface address was specified, get a pointer
		 * to its ifnet structure.
		 */
		if (mreq->imr_interface.s_addr == INADDR_ANY)
			ifp = NULL;
		else {
			INADDR_TO_IFP(mreq->imr_interface, ifp);
			if (ifp == NULL) {
				error = EADDRNOTAVAIL;
				splx(s);
				break;
			}
		}
		/*
		 * Find the membership in the membership array.
		 */
		for (i = 0; i < imo->imo_num_memberships; ++i) {
			if ((ifp == NULL ||
			     imo->imo_membership[i]->inm_ifp == ifp) &&
			     imo->imo_membership[i]->inm_addr.s_addr ==
			     mreq->imr_multiaddr.s_addr)
				break;
		}
		if (i == imo->imo_num_memberships) {
			error = EADDRNOTAVAIL;
			splx(s);
			break;
		}
		/*
		 * Give up the multicast address record to which the
		 * membership points.
		 */
		in_delmulti(imo->imo_membership[i]);
		/*
		 * Remove the gap in the membership array.
		 */
		for (++i; i < imo->imo_num_memberships; ++i)
			imo->imo_membership[i-1] = imo->imo_membership[i];
		--imo->imo_num_memberships;
		splx(s);
		break;

	default:
		error = EOPNOTSUPP;
		break;
	}

	/*
	 * If all options have default values, no need to keep the mbuf.
	 */
	if (imo->imo_multicast_ifp == NULL &&
	    imo->imo_multicast_vif == -1 &&
	    imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
	    imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
	    imo->imo_num_memberships == 0) {
		free(*imop, M_IPMOPTS);
		*imop = NULL;
	}

	return (error);
}

/*
 * Return the IP multicast options in response to user getsockopt().
 */
static int
ip_getmoptions(optname, imo, mp)
	int optname;
	register struct ip_moptions *imo;
	register struct mbuf **mp;
{
	u_char *ttl;
	u_char *loop;
	struct in_addr *addr;
	struct in_ifaddr *ia;

	*mp = m_get(M_WAIT, MT_SOOPTS);

	switch (optname) {

	case IP_MULTICAST_VIF:
		if (imo != NULL)
			*(mtod(*mp, int *)) = imo->imo_multicast_vif;
		else
			*(mtod(*mp, int *)) = -1;
		(*mp)->m_len = sizeof(int);
		return(0);

	case IP_MULTICAST_IF:
		addr = mtod(*mp, struct in_addr *);
		(*mp)->m_len = sizeof(struct in_addr);
		if (imo == NULL || imo->imo_multicast_ifp == NULL)
			addr->s_addr = INADDR_ANY;
		else {
			IFP_TO_IA(imo->imo_multicast_ifp, ia);
			addr->s_addr = (ia == NULL) ? INADDR_ANY
					: IA_SIN(ia)->sin_addr.s_addr;
		}
		return (0);

	case IP_MULTICAST_TTL:
		ttl = mtod(*mp, u_char *);
		(*mp)->m_len = 1;
		*ttl = (imo == NULL) ? IP_DEFAULT_MULTICAST_TTL
				     : imo->imo_multicast_ttl;
		return (0);

	case IP_MULTICAST_LOOP:
		loop = mtod(*mp, u_char *);
		(*mp)->m_len = 1;
		*loop = (imo == NULL) ? IP_DEFAULT_MULTICAST_LOOP
				      : imo->imo_multicast_loop;
		return (0);

	default:
		return (EOPNOTSUPP);
	}
}

/*
 * Discard the IP multicast options.
 */
void
ip_freemoptions(imo)
	register struct ip_moptions *imo;
{
	register int i;

	if (imo != NULL) {
		for (i = 0; i < imo->imo_num_memberships; ++i)
			in_delmulti(imo->imo_membership[i]);
		free(imo, M_IPMOPTS);
	}
}

/*
 * Routine called from ip_output() to loop back a copy of an IP multicast
 * packet to the input queue of a specified interface.  Note that this
 * calls the output routine of the loopback "driver", but with an interface
 * pointer that might NOT be a loopback interface -- evil, but easier than
 * replicating that code here.
 */
static void
ip_mloopback(ifp, m, dst)
	struct ifnet *ifp;
	register struct mbuf *m;
	register struct sockaddr_in *dst;
{
	register struct ip *ip;
	struct mbuf *copym;

	copym = m_copy(m, 0, M_COPYALL);
	if (copym != NULL) {
		/*
		 * We don't bother to fragment if the IP length is greater
		 * than the interface's MTU.  Can this possibly matter?
		 */
		ip = mtod(copym, struct ip *);
		ip->ip_len = htons((u_short)ip->ip_len);
		ip->ip_off = htons((u_short)ip->ip_off);
		ip->ip_sum = 0;
		if (ip->ip_vhl == IP_VHL_BORING) {
			ip->ip_sum = in_cksum_hdr(ip);
		} else {
			ip->ip_sum = in_cksum(copym,
					      IP_VHL_HL(ip->ip_vhl) << 2);
		}
		/*
		 * NB:
		 * We can't simply call ip_input() directly because
		 * the ip_mforward() depends on the `input interface'
		 * being set to something unreasonable so that we don't
		 * attempt to forward the looped-back copy.
		 * It's also not clear whether there are any lingering
		 * reentrancy problems in other areas which might be
		 * exposed by this code.  For the moment, we'll err
		 * on the side of safety by continuing to abuse
		 * loinput().
		 */
#ifdef notdef
		copym->m_pkthdr.rcvif = &loif[0];
		ip_input(copym)
#else
		(void) looutput(ifp, copym, (struct sockaddr *)dst, NULL);
#endif
	}
}
#endif /* MULTICAST */
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@

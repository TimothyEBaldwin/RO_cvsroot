head	4.4;
access;
symbols
	Internet-5_65:4.4
	Internet-5_64:4.4
	Internet-5_63:4.4
	Internet-5_62:4.4
	Internet-5_61:4.4
	Internet-5_60:4.4
	Internet-5_59:4.4
	Internet-5_58:4.4
	Internet-5_57:4.4
	Internet-5_56:4.3
	Internet-5_55:4.3
	Internet-5_54:4.3
	Internet-5_53:4.3
	Internet-5_52:4.3
	Internet-5_51:4.3
	Internet-5_50:4.3
	RO_5_07:4.3
	Internet-5_49:4.3
	Internet-5_48:4.3
	Internet-5_47:4.3
	Internet-5_46:4.3
	Internet-5_45:4.3
	Internet-5_44:4.3
	Internet-5_43:4.3
	Internet-5_42:4.3
	Internet-5_41:4.3
	Internet-5_40:4.3
	Internet-5_39:4.3
	Internet-5_38:4.3
	Internet-5_37:4.3
	Internet-5_36:4.3
	Internet-5_35:4.3
	Internet-5_34:4.3
	Internet-5_33:4.3
	Internet-5_32:4.3
	Internet-5_31:4.3
	Internet-5_30:4.2
	Internet-5_29:4.2
	Internet-5_27:4.2
	Internet-5_26:4.2
	Internet-5_25:4.2
	Internet-5_24:4.2
	Internet-5_23:4.2
	Internet-5_22:4.2
	Internet-5_21:4.2
	Internet-5_20:4.2
	Internet-5_19:4.2
	Internet-5_18:4.2
	Internet-5_17:4.2
	Internet-5_16:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Internet-5_15:4.2
	Internet-5_14:4.2
	Internet-5_13:4.2
	sforrest_daytona_appflash-0_31:4.2
	Internet-5_12:4.2
	Internet-5_11:4.2
	celkins_Internet-5_10:4.2
	nicke_Internat_25-9-98:4.2
	Internet-5_09:4.2
	blaughto_daytona_appflash-0_30:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rwarren_Internet-5_08:4.2
	Spinner:4.2
	Internet_5_07:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.2
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2012.08.26.19.53.23;	author jlee;	state Exp;
branches;
next	4.3;
commitid	WbuxJGoZAqKXR5iw;

4.3
date	99.07.13.11.12.46;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.58.42;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.07;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.07;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.19.56;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.27.44;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.06.40;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.15;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.06.34;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.28;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.38.19;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.16;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.4
log
@Fix routes not being cleaned up properly when an interface changes its address
Detail:
  This is the Internet-side part of the fix, incorporating the following changes from FreeBSD:
  net/c/route - http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/net/route.c.diff?r1=1.59.2.1;r2=1.59.2.2;f=h
  netinet/c/in - http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/netinet/in.c.diff?r1=1.44.2.2;r2=1.44.2.3;f=h
  netinet/c/in_rmx - http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/netinet/in_rmx.c.diff?r1=1.37;r2=1.37.2.1;f=h
  netinet/c/raw_ip - http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/netinet/raw_ip.c.diff?r1=1.64.2.4;r2=1.64.2.5;f=h
  net/c/if - http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/net/if.c.diff?r1=1.43;r2=1.44;f=h
  This provides us with the fix for this bug:
  http://www.freebsd.org/cgi/query-pr.cgi?pr=20785
  Other required changes:
  netiniet/c/in_proto - Hooked up rip_ctlinput to appropriate handlers
  Also fixed build/Makefile to count the module as a dependency for rom_link phase
Admin:
  Tested on Raspberry Pi
  Requires TCPIPLibs-5_56
  Fixes issue reported on forums with ShareFS not always working:
  http://www.riscosopen.org/forum/forums/5/topics/1193


Version 5.57. Tagged as 'Internet-5_57'
@
text
@/*
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/socket.h>
#include <sys/kernel.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_var.h>

#include <netinet/igmp_var.h>

#include <string.h>

#include "module.h"
#include "debug.h"

/*
 * This structure is used to keep track of in_multi chains which belong to
 * deleted interface addresses.
 */
static LIST_HEAD(, multi_kludge) in_mk; /* XXX BSS initialization */

struct multi_kludge {
	LIST_ENTRY(multi_kludge) mk_entry;
	struct ifnet *mk_ifp;
	struct in_multihead mk_head;
};

/*
 * Return the network number from an internet address.
 */
u_long
in_netof(in)
	struct in_addr in;
{
	register u_long i = ntohl(in.s_addr);
	register u_long net;
	register struct in_ifaddr *ia;

	if (IN_CLASSA(i))
		net = i & IN_CLASSA_NET;
	else if (IN_CLASSB(i))
		net = i & IN_CLASSB_NET;
	else if (IN_CLASSC(i))
		net = i & IN_CLASSC_NET;
	else if (IN_CLASSD(i))
		net = i & IN_CLASSD_NET;
	else
		return (0);

	/*
	 * Check whether network is a subnet;
	 * if so, return subnet number.
	 */
	for (ia = in_ifaddr; ia; ia = ia->ia_next)
		if (net == ia->ia_net)
			return (i & ia->ia_subnetmask);
	return (net);
}

static int subnetsarelocal = 0;
SYSCTL_INT(_net_inet_ip, OID_AUTO, subnets_are_local, CTLFLAG_RW,
	&subnetsarelocal, 0, "");

/*
 * Return 1 if an internet address is for a ``local'' host
 * (one to which we have a connection).  If subnetsarelocal
 * is true, this includes other subnets of the local net.
 * Otherwise, it includes only the directly-connected (sub)nets.
 */
int
in_localaddr(in)
	struct in_addr in;
{
	register u_long i = ntohl(in.s_addr);
	register struct in_ifaddr *ia;

	if (subnetsarelocal) {
		for (ia = in_ifaddr; ia; ia = ia->ia_next)
			if ((i & ia->ia_netmask) == ia->ia_net)
				return (1);
	} else {
		for (ia = in_ifaddr; ia; ia = ia->ia_next)
			if ((i & ia->ia_subnetmask) == ia->ia_subnet)
				return (1);
	}
	return (0);
}

/*
 * Determine whether an IP address is in a reserved set of addresses
 * that may not be forwarded, or whether datagrams to that destination
 * may be forwarded.
 */
int
in_canforward(in)
	struct in_addr in;
{
	register u_long i = ntohl(in.s_addr);
	register u_long net;

	if (IN_EXPERIMENTAL(i) || IN_MULTICAST(i))
		return (0);
	if (IN_CLASSA(i)) {
		net = i & IN_CLASSA_NET;
		if (net == 0 || net == (IN_LOOPBACKNET << IN_CLASSA_NSHIFT))
			return (0);
	}
	return (1);
}

/*
 * Trim a mask in a sockaddr
 */
void
in_socktrim(ap)
struct sockaddr_in *ap;
{
    register char *cplim = (char *) &ap->sin_addr;
    register char *cp = (char *) (&ap->sin_addr + 1);

    ap->sin_len = 0;
    while (--cp >= cplim)
        if (*cp) {
	    (ap)->sin_len = cp - (char *) (ap) + 1;
	    break;
	}
}

int	in_interfaces;	    /* number of external internet interfaces */

/*
 * Generic internet control operations (ioctl's).
 * Ifp is 0 if not an interface-specific ioctl.
 */
/* ARGSUSED */
int
in_control(so, cmd, data, ifp)
	struct socket *so;
	int cmd;
	caddr_t data;
	register struct ifnet *ifp;
{
	register struct ifreq *ifr = (struct ifreq *)data;
	register struct in_ifaddr *ia = 0;
	register struct ifaddr *ifa;
	struct in_ifaddr *oia;
	struct in_aliasreq *ifra = (struct in_aliasreq *)data;
	struct sockaddr_in oldaddr;
	int error, hostIsNew, maskIsNew;
	u_long i;
	struct multi_kludge *mk;

	/*
	 * Find address for this interface, if it exists.
	 */
	if (ifp)
		for (ia = in_ifaddr; ia; ia = ia->ia_next)
			if (ia->ia_ifp == ifp)
				break;

#ifdef DEBUG
        Printf("in_control(so=%x,cmd=%x,data=%x,ifp=%x)\n", so, cmd, data, ifp);
        Printf("   ifreq=%s,%x %x %x %x\n", ifr->ifr_name, ifr->ifr_metric, *((&ifr->ifr_metric)+1),*((&ifr->ifr_metric)+2),*((&ifr->ifr_metric)+3));
#endif
	switch (cmd) {

	case SIOCAIFADDR:
	case SIOCDIFADDR:
		if (ifra->ifra_addr.sin_family == AF_INET) {
			for (oia = ia; ia; ia = ia->ia_next) {
				if (ia->ia_ifp == ifp  &&
				    ia->ia_addr.sin_addr.s_addr ==
				    ifra->ifra_addr.sin_addr.s_addr)
					break;
			}
			if ((ifp->if_flags & IFF_POINTOPOINT)
			    && (cmd == SIOCAIFADDR)
			    && (ifra->ifra_dstaddr.sin_addr.s_addr
				== INADDR_ANY)) {
				return EDESTADDRREQ;
			}
		}
		if (cmd == SIOCDIFADDR && ia == 0)
			return (EADDRNOTAVAIL);
		/* FALLTHROUGH */
	case SIOCSIFADDR:
	case SIOCSIFNETMASK:
	case SIOCSIFDSTADDR:
#ifndef __riscos
		if (p && (error = suser(p)) != 0)
			return error;
#endif

		if (ifp == 0) {
			panic("in_control");
			return (EFAULT);
		}
		if (ia == (struct in_ifaddr *)0) {
			oia = (struct in_ifaddr *)
				malloc(sizeof *oia, M_IFADDR, M_WAITOK);
			if (oia == (struct in_ifaddr *)NULL) {
#ifdef DEBUG
			    if( DODEBUG(DBGMMAN) )
				Printf("in_control: malloc failed\n");
#endif
			    return(ENOBUFS);
			}
			bzero((caddr_t)oia, sizeof *oia);
			ia = in_ifaddr;
			if (ia) {
				for ( ; ia->ia_next; ia = ia->ia_next)
					continue;
				ia->ia_next = oia;
			} else
				in_ifaddr = oia;
			ia = oia;
			ifa = ifp->if_addrlist;
			if (ifa) {
				for ( ; ifa->ifa_next; ifa = ifa->ifa_next)
					continue;
				ifa->ifa_next = (struct ifaddr *) ia;
			} else
				ifp->if_addrlist = (struct ifaddr *) ia;
			ia->ia_ifa.ifa_addr = (struct sockaddr *)&ia->ia_addr;
			ia->ia_ifa.ifa_dstaddr
					= (struct sockaddr *)&ia->ia_dstaddr;
			ia->ia_ifa.ifa_netmask
					= (struct sockaddr *)&ia->ia_sockmask;
			ia->ia_sockmask.sin_len = 8;
			if (ifp->if_flags & IFF_BROADCAST) {
				ia->ia_broadaddr.sin_len = sizeof(ia->ia_addr);
				ia->ia_broadaddr.sin_family = AF_INET;
			}
			ia->ia_ifp = ifp;
			if (!(ifp->if_flags & IFF_LOOPBACK))
				in_interfaces++;
		}
		break;

	case SIOCSIFBRDADDR:
#ifndef __riscos
		if (p && (error = suser(p)) != 0)
			return error;
#endif
		/* FALLTHROUGH */

	case SIOCGIFADDR:
	case SIOCGIFNETMASK:
	case SIOCGIFDSTADDR:
	case SIOCGIFBRDADDR:
		if (ia == (struct in_ifaddr *)0)
			return (EADDRNOTAVAIL);
		break;
	}
	switch (cmd) {

	case SIOCGIFADDR:
		*((struct sockaddr_in *)&ifr->ifr_addr) = ia->ia_addr;
		break;

	case SIOCGIFBRDADDR:
		if ((ifp->if_flags & IFF_BROADCAST) == 0)
			return (EINVAL);
		*((struct sockaddr_in *)&ifr->ifr_dstaddr) = ia->ia_broadaddr;
		break;

	case SIOCGIFDSTADDR:
		if ((ifp->if_flags & IFF_POINTOPOINT) == 0)
			return (EINVAL);
		*((struct sockaddr_in *)&ifr->ifr_dstaddr) = ia->ia_dstaddr;
		break;

	case SIOCGIFNETMASK:
		*((struct sockaddr_in *)&ifr->ifr_addr) = ia->ia_sockmask;
		break;

	case SIOCSIFDSTADDR:
		if ((ifp->if_flags & IFF_POINTOPOINT) == 0)
			return (EINVAL);
		oldaddr = ia->ia_dstaddr;
		ia->ia_dstaddr = *(struct sockaddr_in *)&ifr->ifr_dstaddr;
		if (ifp->if_ioctl && (error = (*ifp->if_ioctl)
					(ifp, SIOCSIFDSTADDR, (caddr_t)ia))) {
			ia->ia_dstaddr = oldaddr;
			return (error);
		}
		if (ia->ia_flags & IFA_ROUTE) {
			ia->ia_ifa.ifa_dstaddr = (struct sockaddr *)&oldaddr;
			rtinit(&(ia->ia_ifa), (int)RTM_DELETE, RTF_HOST);
			ia->ia_ifa.ifa_dstaddr =
					(struct sockaddr *)&ia->ia_dstaddr;
			rtinit(&(ia->ia_ifa), (int)RTM_ADD, RTF_HOST|RTF_UP);
		}
		break;

	case SIOCSIFBRDADDR:
		if ((ifp->if_flags & IFF_BROADCAST) == 0)
			return (EINVAL);
		ia->ia_broadaddr = *(struct sockaddr_in *)&ifr->ifr_broadaddr;
		break;

	case SIOCSIFADDR:
		return (in_ifinit(ifp, ia,
		    (struct sockaddr_in *) &ifr->ifr_addr, 1));

	case SIOCSIFNETMASK:
		i = ifra->ifra_addr.sin_addr.s_addr;
		ia->ia_subnetmask = ntohl(ia->ia_sockmask.sin_addr.s_addr = i);
		break;

	case SIOCAIFADDR:
		maskIsNew = 0;
		hostIsNew = 1;
		error = 0;
		if (ia->ia_addr.sin_family == AF_INET) {
			if (ifra->ifra_addr.sin_len == 0) {
				ifra->ifra_addr = ia->ia_addr;
				hostIsNew = 0;
			} else if (ifra->ifra_addr.sin_addr.s_addr ==
					       ia->ia_addr.sin_addr.s_addr)
				hostIsNew = 0;
		}
		if (ifra->ifra_mask.sin_len) {
			in_ifscrub(ifp, ia);
			ia->ia_sockmask = ifra->ifra_mask;
			ia->ia_subnetmask =
			     ntohl(ia->ia_sockmask.sin_addr.s_addr);
			maskIsNew = 1;
		}
		if ((ifp->if_flags & IFF_POINTOPOINT) &&
		    (ifra->ifra_dstaddr.sin_family == AF_INET)) {
			in_ifscrub(ifp, ia);
			ia->ia_dstaddr = ifra->ifra_dstaddr;
			maskIsNew  = 1; /* We lie; but the effect's the same */
		}
		if (ifra->ifra_addr.sin_family == AF_INET &&
		    (hostIsNew || maskIsNew))
			error = in_ifinit(ifp, ia, &ifra->ifra_addr, 0);
		if ((ifp->if_flags & IFF_BROADCAST) &&
		    (ifra->ifra_broadaddr.sin_family == AF_INET))
			ia->ia_broadaddr = ifra->ifra_broadaddr;
		return (error);

	case SIOCDIFADDR:
		mk = malloc(sizeof *mk, M_IPMADDR, M_WAITOK);
		if (!mk)
			return ENOBUFS;

		/*
		 * in_ifscrub kills the interface route.
		 */
		in_ifscrub(ifp, ia);
		/*
		 * in_ifadown gets rid of all the rest of
		 * the routes.  This is not quite the right
		 * thing to do, but at least if we are running
		 * a routing process they will come back.
		 */
		in_ifadown(&ia->ia_ifa, 1);

		if ((ifa = ifp->if_addrlist) == (struct ifaddr *)ia)
			ifp->if_addrlist = ifa->ifa_next;
		else {
			while (ifa->ifa_next &&
			       (ifa->ifa_next != (struct ifaddr *)ia))
				    ifa = ifa->ifa_next;
			if (ifa->ifa_next)
				ifa->ifa_next = ((struct ifaddr *)ia)->ifa_next;
			else
				printf("Couldn't unlink inifaddr from ifp\n");
		}
		oia = ia;
		if (oia == (ia = in_ifaddr))
			in_ifaddr = ia->ia_next;
		else {
			while (ia->ia_next && (ia->ia_next != oia))
				ia = ia->ia_next;
			if (ia->ia_next)
				ia->ia_next = oia->ia_next;
			else
				printf("Didn't unlink inifadr from list\n");
		}

		if (!oia->ia_multiaddrs.lh_first) {
			IFAFREE(&oia->ia_ifa);
			FREE(mk, M_IPMADDR);
			break;
		}

		/*
		 * Multicast address kludge:
		 * If there were any multicast addresses attached to this
		 * interface address, either move them to another address
		 * on this interface, or save them until such time as this
		 * interface is reconfigured for IP.
		 */
		IFP_TO_IA(oia->ia_ifp, ia);
		if (ia) {	/* there is another address */
			struct in_multi *inm;
			for(inm = oia->ia_multiaddrs.lh_first; inm;
			    inm = inm->inm_entry.le_next) {
				IFAFREE(&inm->inm_ia->ia_ifa);
				ia->ia_ifa.ifa_refcnt++;
				inm->inm_ia = ia;
				LIST_INSERT_HEAD(&ia->ia_multiaddrs, inm,
						 inm_entry);
			}
			FREE(mk, M_IPMADDR);
		} else {	/* last address on this if deleted, save */
			struct in_multi *inm;

			LIST_INIT(&mk->mk_head);
			mk->mk_ifp = ifp;

			for(inm = oia->ia_multiaddrs.lh_first; inm;
			    inm = inm->inm_entry.le_next) {
				LIST_INSERT_HEAD(&mk->mk_head, inm, inm_entry);
			}

			if (mk->mk_head.lh_first) {
				LIST_INSERT_HEAD(&in_mk, mk, mk_entry);
			} else {
				FREE(mk, M_IPMADDR);
			}
		}

		IFAFREE((&oia->ia_ifa));
		break;

	default:
		if (ifp == 0 || ifp->if_ioctl == 0)
			return (EOPNOTSUPP);
		return ((*ifp->if_ioctl)(ifp, cmd, data));
	}
	return (0);
}

/*
 * Delete any existing route for an interface.
 */
void
in_ifscrub(ifp, ia)
	register struct ifnet *ifp;
	register struct in_ifaddr *ia;
{

	if ((ia->ia_flags & IFA_ROUTE) == 0)
		return;
	if (ifp->if_flags & (IFF_LOOPBACK|IFF_POINTOPOINT))
		rtinit(&(ia->ia_ifa), (int)RTM_DELETE, RTF_HOST);
	else
		rtinit(&(ia->ia_ifa), (int)RTM_DELETE, 0);
	ia->ia_flags &= ~IFA_ROUTE;
}

/*
 * Initialize an interface's internet address
 * and routing table entry.
 */
int
in_ifinit(ifp, ia, sin, scrub)
	register struct ifnet *ifp;
	register struct in_ifaddr *ia;
	struct sockaddr_in *sin;
	int scrub;
{
	register u_long i = ntohl(sin->sin_addr.s_addr);
	struct sockaddr_in oldaddr;
	int s = splimp(), flags = RTF_UP, error;
#ifdef MULTICAST
	struct multi_kludge *mk;
#endif

#ifdef DEBUG
        Printf("in_ifinit(%x, %x, (sin), %d); sin=(%d,%d,%x)\n",
               ifp, ia, scrub, sin->sin_family, sin->sin_len, htonl(sin->sin_addr.s_addr));
#endif
	oldaddr = ia->ia_addr;
	ia->ia_addr = *sin;
	/*
	 * Give the interface a chance to initialize
	 * if this is its first address,
	 * and to validate the address if necessary.
	 */
	if (ifp->if_ioctl &&
	    (error = (*ifp->if_ioctl)(ifp, SIOCSIFADDR, (caddr_t)ia))) {
		splx(s);
		ia->ia_addr = oldaddr;
#ifdef DEBUG
                Printf("in_ifinit: interface returned error %d\n", error);
#endif
		return (error);
	}
	splx(s);
	if (scrub) {
		ia->ia_ifa.ifa_addr = (struct sockaddr *)&oldaddr;
		in_ifscrub(ifp, ia);
		ia->ia_ifa.ifa_addr = (struct sockaddr *)&ia->ia_addr;
	}
	if (IN_CLASSA(i))
		ia->ia_netmask = IN_CLASSA_NET;
	else if (IN_CLASSB(i))
		ia->ia_netmask = IN_CLASSB_NET;
	else
		ia->ia_netmask = IN_CLASSC_NET;
	/*
	 * The subnet mask usually includes at least the standard network part,
	 * but may may be smaller in the case of supernetting.
	 * If it is set, we believe it.
	 */
	if (ia->ia_subnetmask == 0) {
		ia->ia_subnetmask = ia->ia_netmask;
		ia->ia_sockmask.sin_addr.s_addr = htonl(ia->ia_subnetmask);
	} else
		ia->ia_netmask &= ia->ia_subnetmask;
	ia->ia_net = i & ia->ia_netmask;
	ia->ia_subnet = i & ia->ia_subnetmask;
	in_socktrim(&ia->ia_sockmask);
	/*
	 * Add route for the network.
	 */
#ifdef DEBUG
        Printf("in_ifinit: adding route!\n");
#endif
	ia->ia_ifa.ifa_metric = ifp->if_metric;
	if (ifp->if_flags & IFF_BROADCAST) {
		ia->ia_broadaddr.sin_addr.s_addr =
			htonl(ia->ia_subnet | ~ia->ia_subnetmask);
		ia->ia_netbroadcast.s_addr =
			htonl(ia->ia_net | ~ ia->ia_netmask);
	} else if (ifp->if_flags & IFF_LOOPBACK) {
		ia->ia_ifa.ifa_dstaddr = ia->ia_ifa.ifa_addr;
		flags |= RTF_HOST;
	} else if (ifp->if_flags & IFF_POINTOPOINT) {
		if (ia->ia_dstaddr.sin_family != AF_INET)
			return (0);
		flags |= RTF_HOST;
	}
	if ((error = rtinit(&(ia->ia_ifa), (int)RTM_ADD, flags)) == 0)
		ia->ia_flags |= IFA_ROUTE;

#ifdef DEBUG
        Printf("rtinit returned %d\n", error);
#endif
	LIST_INIT(&ia->ia_multiaddrs);
#ifdef MULTICAST
	/*
	 * If the interface supports multicast, join the "all hosts"
	 * multicast group on that interface.
	 */
	if (ifp->if_flags & IFF_MULTICAST) {
		struct in_addr addr;

		/*
		 * Continuation of multicast address hack:
		 * If there was a multicast group list previously saved
		 * for this interface, then we re-attach it to the first
		 * address configured on the i/f.
		 */
		for(mk = in_mk.lh_first; mk; mk = mk->mk_entry.le_next) {
			if(mk->mk_ifp == ifp) {
				struct in_multi *inm;

				for(inm = mk->mk_head.lh_first; inm;
				    inm = inm->inm_entry.le_next) {
					IFAFREE(&inm->inm_ia->ia_ifa);
					ia->ia_ifa.ifa_refcnt++;
					inm->inm_ia = ia;
					LIST_INSERT_HEAD(&ia->ia_multiaddrs,
							 inm, inm_entry);
				}
				LIST_REMOVE(mk, mk_entry);
				free(mk, M_IPMADDR);
				break;
			}
		}

		addr.s_addr = htonl(INADDR_ALLHOSTS_GROUP);
		in_addmulti(&addr, ifp);
	}
#endif
	/*
	 * 950316 KWelton
	 *
	 * issue a service call to let other modules know
	 * that an interface address has been changed.
	 *
	 * the service call *must* be issued at this point,
	 * i.e. after the address and routing entries have
	 * been altered.
	 */
#ifdef __riscos
	if (error == 0)
		sc_addrchanged();
#endif

	return (error);
}

/*
 * Return 1 if the address might be a local broadcast address.
 */
int
in_broadcast(in, ifp)
	struct in_addr in;
        struct ifnet *ifp;
{
	register struct ifaddr *ifa;
	u_long t;

	if (in.s_addr == INADDR_BROADCAST ||
	    in.s_addr == INADDR_ANY)
		return 1;
	if ((ifp->if_flags & IFF_BROADCAST) == 0)
		return 0;
	t = ntohl(in.s_addr);
	/*
	 * Look through the list of addresses for a match
	 * with a broadcast address.
	 */
#define ia ((struct in_ifaddr *)ifa)
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
		if (ifa->ifa_addr->sa_family == AF_INET &&
		    (in.s_addr == ia->ia_broadaddr.sin_addr.s_addr ||
		     in.s_addr == ia->ia_netbroadcast.s_addr ||
		     /*
		      * Check for old-style (host 0) broadcast.
		      */
		     t == ia->ia_subnet || t == ia->ia_net) &&
		     /*
		      * Check for an all one subnetmask. These
		      * only exist when an interface gets a secondary
		      * address.
		      */
		     ia->ia_subnetmask != (u_long)0xffffffff)
			    return 1;
	return (0);
#undef ia
}
#ifdef MULTICAST
/*
 * Add an address to the list of IP multicast addresses for a given interface.
 */
struct in_multi *
in_addmulti(ap, ifp)
	register struct in_addr *ap;
	register struct ifnet *ifp;
{
	register struct in_multi *inm;
	struct ifreq ifr;
	struct in_ifaddr *ia;

#ifdef DEBUG
	if (DODEBUG(DBGIGMP))
		Printf("in_addmulti(%x,%x)\n", *ap, ifp);
#endif
	/*
	 * See if address already in list.
	 */
	IN_LOOKUP_MULTI(*ap, ifp, inm);
	if (inm != NULL) {
		/*
		 * Found it; just increment the reference count.
		 */
		++inm->inm_refcount;
	}
	else {
		/*
		 * New address; allocate a new multicast record
		 * and link it into the interface's multicast list.
		 */
#ifdef DEBUG
		if (DODEBUG(DBGIGMP))
			Printf("New address\n");
#endif
		inm = (struct in_multi *)malloc(sizeof(*inm),
		    M_IPMADDR, M_NOWAIT);
		if (inm == NULL) {
			return (NULL);
		}
		inm->inm_addr = *ap;
		inm->inm_ifp = ifp;
		inm->inm_refcount = 1;
		IFP_TO_IA(ifp, ia);
		if (ia == NULL) {
#ifdef DEBUG
			if (DODEBUG(DBGIGMP))
				Printf("ia == NULL!!!\n");
#endif
			free(inm, M_IPMADDR);
			return (NULL);
		}
		inm->inm_ia = ia;
		ia->ia_ifa.ifa_refcnt++; /* gain a reference */
		LIST_INSERT_HEAD(&ia->ia_multiaddrs, inm, inm_entry);

		/*
		 * Ask the network driver to update its multicast reception
		 * filter appropriately for the new address.
		 */
		((struct sockaddr_in *)&ifr.ifr_addr)->sin_family = AF_INET;
		((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr = *ap;
		if ((ifp->if_ioctl == NULL) ||
		    (*ifp->if_ioctl)(ifp, SIOCADDMULTI,(caddr_t)&ifr) != 0) {
#ifdef DEBUG
			if (DODEBUG(DBGIGMP))
				Printf("ioctl failed!!!\n");
#endif
			LIST_REMOVE(inm, inm_entry);
			IFAFREE(&ia->ia_ifa); /* release reference */
			free(inm, M_IPMADDR);
			return (NULL);
		}
		/*
		 * Let IGMP know that we have joined a new IP multicast group.
		 */
		igmp_joingroup(inm);
	}
	return (inm);
}

/*
 * Delete a multicast address record.
 */
void
in_delmulti(inm)
	register struct in_multi *inm;
{
	struct ifreq ifr;

	if (--inm->inm_refcount == 0) {
		/*
		 * No remaining claims to this record; let IGMP know that
		 * we are leaving the multicast group.
		 */
		igmp_leavegroup(inm);
		/*
		 * Unlink from list.
		 */
		LIST_REMOVE(inm, inm_entry);
		IFAFREE(&inm->inm_ia->ia_ifa); /* release reference */

		/*
		 * Notify the network driver to update its multicast reception
		 * filter.
		 */
		((struct sockaddr_in *)&(ifr.ifr_addr))->sin_family = AF_INET;
		((struct sockaddr_in *)&(ifr.ifr_addr))->sin_addr =
								inm->inm_addr;
		(*inm->inm_ifp->if_ioctl)(inm->inm_ifp, SIOCDELMULTI,
							     (caddr_t)&ifr);
		free(inm, M_IPMADDR);
	}
}
#endif /* MULTICAST */
@


4.3
log
@Added new FreeBSD sysctl handling using linker magic.
A few new sysctls added as a result.
SO_TIMESTAMP now gives real time, not Internet's internal time.
DHCP/BOOTP parsing picks up URL option and pops it into Inet$URL.
Requires TCPIPLibs 5.25 and link 5.12.

Version 5.31. Tagged as 'Internet-5_31'
@
text
@d390 3
d394 8
@


4.2
log
@Version Spinner_B7 taken
@
text
@d37 1
a37 2
#include <sys/ioctl.h>
#include <sys/errno.h>
d39 1
d41 2
a42 2
#include <sys/socketvar.h>
#include <sys/queue.h>
a46 1
#include <netinet/in_systm.h>
a48 1
#include <netinet/if_ether.h>
d101 4
a104 4
#ifndef SUBNETSARELOCAL
#define	SUBNETSARELOCAL	1
#endif
int subnetsarelocal = SUBNETSARELOCAL;
d230 4
a233 2
		if ((so->so_state & SS_PRIV) == 0)
			return (EPERM);
d282 4
a285 2
		if ((so->so_state & SS_PRIV) == 0)
			return (EPERM);
@


4.1
log
@Initial revision
@
text
@d1 3
a3 1
/* -*-C-*-
d5 15
a19 2
 * $Header: /ax/networking:Internet/netinet/in.c:networking  1.2  $
 * $Source: /ax/networking:Internet/netinet/in.c: $
d21 11
a31 1
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
a32 8
 * $Log:	in.c,v $
 * Revision 1.2  95/03/19  18:14:48  kwelton
 * in_ifinit() now (indirectly) issues a service call after an internet
 * address has been changed.
 * 
 * Revision 1.1  94/12/02  11:06:54  kwelton
 * Initial revision
 * 
a33 41
/*
 * Copyright (c) 1983, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 */
#include "sys/param.h"
#include "sys/dir.h"
#include "sys/user.h"
#include "sys/ioctl.h"
#include "sys/mbuf.h"
#include "sys/protosw.h"
#include "sys/socket.h"
#include "sys/socketvar.h"
#include "sys/uio.h"

#include "net/if.h"
#include "net/route.h"
#include "net/af.h"

#include "netinet/in.h"
#include "netinet/in_var.h"
#include "netinet/in_systm.h"

#ifdef INET
inet_hash(sin, hp)
	register struct sockaddr_in *sin;
	struct afhash *hp;
{
	register u_long n;
d35 18
a52 7
	n = in_netof(sin->sin_addr);
	if (n)
	    while ((n & 0xff) == 0)
		n >>= 8;
	hp->afh_nethash = n;
	hp->afh_hosthash = ntohl(sin->sin_addr.s_addr);
}
d54 1
a54 3
inet_netmatch(sin1, sin2)
	struct sockaddr_in *sin1, *sin2;
{
d56 2
a57 2
	return (in_netof(sin1->sin_addr) == in_netof(sin2->sin_addr));
}
d60 2
a61 1
 * Formulate an Internet address from network + host.
d63 1
a63 7
struct in_addr
in_makeaddr(net, host)
	u_long net, host;
{
	register struct in_ifaddr *ia;
	register u_long mask;
	u_long addr;
d65 5
a69 14
	if (IN_CLASSA(net))
		mask = IN_CLASSA_HOST;
	else if (IN_CLASSB(net))
		mask = IN_CLASSB_HOST;
	else
		mask = IN_CLASSC_HOST;
	for (ia = in_ifaddr; ia; ia = ia->ia_next)
		if ((ia->ia_netmask & net) == ia->ia_net) {
			mask = ~ia->ia_subnetmask;
			break;
		}
	addr = htonl(net | (host & mask));
	return (*(struct in_addr *)&addr);
}
d88 2
a102 33
/*
 * Return the host portion of an internet address.
 */
u_long
in_lnaof(in)
	struct in_addr in;
{
	register u_long i = ntohl(in.s_addr);
	register u_long net, host;
	register struct in_ifaddr *ia;

	if (IN_CLASSA(i)) {
		net = i & IN_CLASSA_NET;
		host = i & IN_CLASSA_HOST;
	} else if (IN_CLASSB(i)) {
		net = i & IN_CLASSB_NET;
		host = i & IN_CLASSB_HOST;
	} else if (IN_CLASSC(i)) {
		net = i & IN_CLASSC_NET;
		host = i & IN_CLASSC_HOST;
	} else
		return (i);

	/*
	 * Check whether network is a subnet;
	 * if so, use the modified interpretation of `host'.
	 */
	for (ia = in_ifaddr; ia; ia = ia->ia_next)
		if (net == ia->ia_net)
			return (host &~ ia->ia_subnetmask);
	return (host);
}

d104 1
a104 1
#define SUBNETSARELOCAL 1
d109 1
a109 1
 * (one to which we have a connection).	 If subnetsarelocal
d113 1
d137 1
d144 1
a144 1
	if (IN_EXPERIMENTAL(i))
d148 1
a148 1
		if (net == 0 || net == IN_LOOPBACKNET)
d154 19
a172 2
int	in_interfaces = 0;	    /* number of external internet interfaces */
extern	struct ifnet loif;
d179 1
d188 7
a194 3
	struct ifaddr *ifa;
	struct mbuf *m;
	int error;
d204 4
d210 19
d232 2
d240 3
a242 7
#ifdef OldCode
			m = m_getclr(M_WAIT, MT_IFADDR);
			if (m == (struct mbuf *)NULL)
				return (ENOBUFS);
#else
			if( (m = ALLOC_C(MINCONTIG, NULL)) == NULL )
			{
d245 1
a245 1
				Printf("in_control: ALLOC_C failed\n");
d249 3
a251 4

			m->m_type = MT_IFADDR;
#endif
			if (ia = in_ifaddr) {
d253 2
a254 2
					;
				ia->ia_next = mtod(m, struct in_ifaddr *);
d256 4
a259 3
				in_ifaddr = mtod(m, struct in_ifaddr *);
			ia = mtod(m, struct in_ifaddr *);
			if (ifa = ifp->if_addrlist) {
d261 1
a261 1
					;
d265 10
d276 1
a276 2
			IA_SIN(ia)->sin_family = AF_INET;
			if (ifp != &loif)
d282 8
a289 1
	default:
a293 1

d297 1
a297 1
		ifr->ifr_addr = ia->ia_addr;
d303 1
a303 1
		ifr->ifr_dstaddr = ia->ia_broadaddr;
d309 1
a309 1
		ifr->ifr_dstaddr = ia->ia_dstaddr;
d313 1
a313 3
#define satosin(sa)	((struct sockaddr_in *)(sa))
		satosin(&ifr->ifr_addr)->sin_family = AF_INET;
		satosin(&ifr->ifr_addr)->sin_addr.s_addr = htonl(ia->ia_subnetmask);
a316 3
	    {
		struct sockaddr oldaddr;

d320 3
a322 3
		ia->ia_dstaddr = ifr->ifr_dstaddr;
		if (ifp->if_ioctl &&
		    (error = (*ifp->if_ioctl)(ifp, SIOCSIFDSTADDR, ia))) {
d327 5
a331 4
			rtinit(&oldaddr, &ia->ia_addr, (int)SIOCDELRT,
			    RTF_HOST);
			rtinit(&ia->ia_dstaddr, &ia->ia_addr, (int)SIOCADDRT,
			    RTF_HOST|RTF_UP);
a332 1
	    }
d338 1
a338 1
		ia->ia_broadaddr = ifr->ifr_broadaddr;
d343 1
a343 1
		    (struct sockaddr_in *) &ifr->ifr_addr));
d346 110
a455 1
		ia->ia_subnetmask = ntohl(satosin(&ifr->ifr_addr)->sin_addr.s_addr);
d467 18
d488 2
a489 1
in_ifinit(ifp, ia, sin)
d493 1
d496 5
a500 3
	struct sockaddr oldaddr;
	struct sockaddr_in netaddr;
	int s = splimp(), error;
d502 4
d507 1
a507 2
	ia->ia_addr = *(struct sockaddr *)sin;

d513 2
a514 1
	if (ifp->if_ioctl && (error = (*ifp->if_ioctl)(ifp, SIOCSIFADDR, ia))) {
d517 3
d522 5
a526 19

	/*
	 * Delete any previous route for an old address.
	 */
	bzero((caddr_t)&netaddr, sizeof (netaddr));
	netaddr.sin_family = AF_INET;
	if (ia->ia_flags & IFA_ROUTE) {
		if (ifp->if_flags & IFF_LOOPBACK)
			rtinit(&oldaddr, &oldaddr, (int)SIOCDELRT, RTF_HOST);
		else if (ifp->if_flags & IFF_POINTOPOINT)
			rtinit(&ia->ia_dstaddr, &oldaddr, (int)SIOCDELRT,
			    RTF_HOST);
		else {
			netaddr.sin_addr = in_makeaddr(ia->ia_subnet,
			    INADDR_ANY);
			rtinit((struct sockaddr *)&netaddr, &oldaddr,
			    (int)SIOCDELRT, 0);
		}
		ia->ia_flags &= ~IFA_ROUTE;
d534 10
d545 2
d548 1
a548 2
	 * The subnet mask includes at least the standard network part,
	 * but may already have been set to a larger value.
d550 4
a553 2
	ia->ia_subnetmask |= ia->ia_netmask;
	ia->ia_subnet = i & ia->ia_subnetmask;
d555 2
a556 3
		ia->ia_broadaddr.sa_family = AF_INET;
		((struct sockaddr_in *)(&ia->ia_broadaddr))->sin_addr =
			in_makeaddr(ia->ia_subnet, INADDR_BROADCAST);
d558 8
a565 1
		    htonl(ia->ia_net | (INADDR_BROADCAST &~ ia->ia_netmask));
d567 8
d576 2
a577 1
	 * Add route for the network.
d579 29
a607 10
	if (ifp->if_flags & IFF_LOOPBACK)
		rtinit(&ia->ia_addr, &ia->ia_addr, (int)SIOCADDRT,
		    RTF_HOST|RTF_UP);
	else if (ifp->if_flags & IFF_POINTOPOINT)
		rtinit(&ia->ia_dstaddr, &ia->ia_addr, (int)SIOCADDRT,
		    RTF_HOST|RTF_UP);
	else {
		netaddr.sin_addr = in_makeaddr(ia->ia_subnet, INADDR_ANY);
		rtinit((struct sockaddr *)&netaddr, &ia->ia_addr,
		    (int)SIOCADDRT, RTF_UP);
d609 1
a609 3
	ia->ia_flags |= IFA_ROUTE;
	splx(s);

d621 2
a622 1
	sc_addrchanged();
d625 1
a625 1
	return (0);
d629 1
a629 1
 * Return address info for specified internet network.
d631 4
a634 3
struct in_ifaddr *
in_iaonnetof(net)
	u_long net;
d636 2
a637 1
	register struct in_ifaddr *ia;
d639 28
a666 4
	for (ia = in_ifaddr; ia; ia = ia->ia_next)
		if (ia->ia_subnet == net)
			return (ia);
	return ((struct in_ifaddr *)0);
d668 1
a668 1

d670 1
a670 1
 * Return 1 if the address might be a local broadcast address.
d672 4
a675 2
in_broadcast(in)
	struct in_addr in;
d677 3
a679 2
	register struct in_ifaddr *ia;
	u_long t;
d681 4
d686 1
a686 2
	 * Look through the list of addresses for a match
	 * with a broadcast address.
d688 54
a741 4
	for (ia = in_ifaddr; ia; ia = ia->ia_next)
	    if (ia->ia_ifp->if_flags & IFF_BROADCAST) {
		if (satosin(&ia->ia_broadaddr)->sin_addr.s_addr == in.s_addr)
		     return (1);
d743 1
a743 1
		 * Check for old-style (host 0) broadcast.
d745 1
a745 2
		if ((t = ntohl(in.s_addr)) == ia->ia_subnet || t == ia->ia_net)
		    return (1);
d747 1
a747 3
	if (in.s_addr == INADDR_BROADCAST || in.s_addr == INADDR_ANY)
		return (1);
	return (0);
a748 1
#endif
d750 34
a783 1
/* EOF in.c */
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d1 16
d18 2
a19 18
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d34 24
d59 7
a65 16
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/if_ether.h>
d67 3
a69 1
#include <netinet/igmp_var.h>
d71 2
a72 4
#include <string.h>

#include "module.h"
#include "debug.h"
d75 1
a75 2
 * This structure is used to keep track of in_multi chains which belong to
 * deleted interface addresses.
d77 7
a83 1
static LIST_HEAD(, multi_kludge) in_mk; /* XXX BSS initialization */
d85 14
a98 5
struct multi_kludge {
	LIST_ENTRY(multi_kludge) mk_entry;
	struct ifnet *mk_ifp;
	struct in_multihead mk_head;
};
a116 2
	else if (IN_CLASSD(i))
		net = i & IN_CLASSD_NET;
d130 33
d164 1
a164 1
#define	SUBNETSARELOCAL	1
d169 1
a169 1
 * (one to which we have a connection).  If subnetsarelocal
a172 1
int
a195 1
int
d202 1
a202 1
	if (IN_EXPERIMENTAL(i) || IN_MULTICAST(i))
d206 1
a206 1
		if (net == 0 || net == (IN_LOOPBACKNET << IN_CLASSA_NSHIFT))
d212 2
a213 19
/*
 * Trim a mask in a sockaddr
 */
void
in_socktrim(ap)
struct sockaddr_in *ap;
{
    register char *cplim = (char *) &ap->sin_addr;
    register char *cp = (char *) (&ap->sin_addr + 1);

    ap->sin_len = 0;
    while (--cp >= cplim)
        if (*cp) {
	    (ap)->sin_len = cp - (char *) (ap) + 1;
	    break;
	}
}

int	in_interfaces;	    /* number of external internet interfaces */
a219 1
int
d228 3
a230 7
	register struct ifaddr *ifa;
	struct in_ifaddr *oia;
	struct in_aliasreq *ifra = (struct in_aliasreq *)data;
	struct sockaddr_in oldaddr;
	int error, hostIsNew, maskIsNew;
	u_long i;
	struct multi_kludge *mk;
a239 4
#ifdef DEBUG
        Printf("in_control(so=%x,cmd=%x,data=%x,ifp=%x)\n", so, cmd, data, ifp);
        Printf("   ifreq=%s,%x %x %x %x\n", ifr->ifr_name, ifr->ifr_metric, *((&ifr->ifr_metric)+1),*((&ifr->ifr_metric)+2),*((&ifr->ifr_metric)+3));
#endif
a241 19
	case SIOCAIFADDR:
	case SIOCDIFADDR:
		if (ifra->ifra_addr.sin_family == AF_INET) {
			for (oia = ia; ia; ia = ia->ia_next) {
				if (ia->ia_ifp == ifp  &&
				    ia->ia_addr.sin_addr.s_addr ==
				    ifra->ifra_addr.sin_addr.s_addr)
					break;
			}
			if ((ifp->if_flags & IFF_POINTOPOINT)
			    && (cmd == SIOCAIFADDR)
			    && (ifra->ifra_dstaddr.sin_addr.s_addr
				== INADDR_ANY)) {
				return EDESTADDRREQ;
			}
		}
		if (cmd == SIOCDIFADDR && ia == 0)
			return (EADDRNOTAVAIL);
		/* FALLTHROUGH */
a244 2
		if ((so->so_state & SS_PRIV) == 0)
			return (EPERM);
d251 7
a257 3
			oia = (struct in_ifaddr *)
				malloc(sizeof *oia, M_IFADDR, M_WAITOK);
			if (oia == (struct in_ifaddr *)NULL) {
d260 1
a260 1
				Printf("in_control: malloc failed\n");
d264 4
a267 3
			bzero((caddr_t)oia, sizeof *oia);
			ia = in_ifaddr;
			if (ia) {
d269 2
a270 2
					continue;
				ia->ia_next = oia;
d272 3
a274 4
				in_ifaddr = oia;
			ia = oia;
			ifa = ifp->if_addrlist;
			if (ifa) {
d276 1
a276 1
					continue;
a279 10
			ia->ia_ifa.ifa_addr = (struct sockaddr *)&ia->ia_addr;
			ia->ia_ifa.ifa_dstaddr
					= (struct sockaddr *)&ia->ia_dstaddr;
			ia->ia_ifa.ifa_netmask
					= (struct sockaddr *)&ia->ia_sockmask;
			ia->ia_sockmask.sin_len = 8;
			if (ifp->if_flags & IFF_BROADCAST) {
				ia->ia_broadaddr.sin_len = sizeof(ia->ia_addr);
				ia->ia_broadaddr.sin_family = AF_INET;
			}
d281 2
a282 1
			if (!(ifp->if_flags & IFF_LOOPBACK))
d288 1
a288 8
		if ((so->so_state & SS_PRIV) == 0)
			return (EPERM);
		/* FALLTHROUGH */

	case SIOCGIFADDR:
	case SIOCGIFNETMASK:
	case SIOCGIFDSTADDR:
	case SIOCGIFBRDADDR:
d293 1
d297 1
a297 1
		*((struct sockaddr_in *)&ifr->ifr_addr) = ia->ia_addr;
d303 1
a303 1
		*((struct sockaddr_in *)&ifr->ifr_dstaddr) = ia->ia_broadaddr;
d309 1
a309 1
		*((struct sockaddr_in *)&ifr->ifr_dstaddr) = ia->ia_dstaddr;
d313 3
a315 1
		*((struct sockaddr_in *)&ifr->ifr_addr) = ia->ia_sockmask;
d319 3
d325 3
a327 3
		ia->ia_dstaddr = *(struct sockaddr_in *)&ifr->ifr_dstaddr;
		if (ifp->if_ioctl && (error = (*ifp->if_ioctl)
					(ifp, SIOCSIFDSTADDR, (caddr_t)ia))) {
d332 4
a335 5
			ia->ia_ifa.ifa_dstaddr = (struct sockaddr *)&oldaddr;
			rtinit(&(ia->ia_ifa), (int)RTM_DELETE, RTF_HOST);
			ia->ia_ifa.ifa_dstaddr =
					(struct sockaddr *)&ia->ia_dstaddr;
			rtinit(&(ia->ia_ifa), (int)RTM_ADD, RTF_HOST|RTF_UP);
d337 1
d343 1
a343 1
		ia->ia_broadaddr = *(struct sockaddr_in *)&ifr->ifr_broadaddr;
d348 1
a348 1
		    (struct sockaddr_in *) &ifr->ifr_addr, 1));
d351 1
a351 110
		i = ifra->ifra_addr.sin_addr.s_addr;
		ia->ia_subnetmask = ntohl(ia->ia_sockmask.sin_addr.s_addr = i);
		break;

	case SIOCAIFADDR:
		maskIsNew = 0;
		hostIsNew = 1;
		error = 0;
		if (ia->ia_addr.sin_family == AF_INET) {
			if (ifra->ifra_addr.sin_len == 0) {
				ifra->ifra_addr = ia->ia_addr;
				hostIsNew = 0;
			} else if (ifra->ifra_addr.sin_addr.s_addr ==
					       ia->ia_addr.sin_addr.s_addr)
				hostIsNew = 0;
		}
		if (ifra->ifra_mask.sin_len) {
			in_ifscrub(ifp, ia);
			ia->ia_sockmask = ifra->ifra_mask;
			ia->ia_subnetmask =
			     ntohl(ia->ia_sockmask.sin_addr.s_addr);
			maskIsNew = 1;
		}
		if ((ifp->if_flags & IFF_POINTOPOINT) &&
		    (ifra->ifra_dstaddr.sin_family == AF_INET)) {
			in_ifscrub(ifp, ia);
			ia->ia_dstaddr = ifra->ifra_dstaddr;
			maskIsNew  = 1; /* We lie; but the effect's the same */
		}
		if (ifra->ifra_addr.sin_family == AF_INET &&
		    (hostIsNew || maskIsNew))
			error = in_ifinit(ifp, ia, &ifra->ifra_addr, 0);
		if ((ifp->if_flags & IFF_BROADCAST) &&
		    (ifra->ifra_broadaddr.sin_family == AF_INET))
			ia->ia_broadaddr = ifra->ifra_broadaddr;
		return (error);

	case SIOCDIFADDR:
		mk = malloc(sizeof *mk, M_IPMADDR, M_WAITOK);
		if (!mk)
			return ENOBUFS;

		in_ifscrub(ifp, ia);
		if ((ifa = ifp->if_addrlist) == (struct ifaddr *)ia)
			ifp->if_addrlist = ifa->ifa_next;
		else {
			while (ifa->ifa_next &&
			       (ifa->ifa_next != (struct ifaddr *)ia))
				    ifa = ifa->ifa_next;
			if (ifa->ifa_next)
				ifa->ifa_next = ((struct ifaddr *)ia)->ifa_next;
			else
				printf("Couldn't unlink inifaddr from ifp\n");
		}
		oia = ia;
		if (oia == (ia = in_ifaddr))
			in_ifaddr = ia->ia_next;
		else {
			while (ia->ia_next && (ia->ia_next != oia))
				ia = ia->ia_next;
			if (ia->ia_next)
				ia->ia_next = oia->ia_next;
			else
				printf("Didn't unlink inifadr from list\n");
		}

		if (!oia->ia_multiaddrs.lh_first) {
			IFAFREE(&oia->ia_ifa);
			FREE(mk, M_IPMADDR);
			break;
		}

		/*
		 * Multicast address kludge:
		 * If there were any multicast addresses attached to this
		 * interface address, either move them to another address
		 * on this interface, or save them until such time as this
		 * interface is reconfigured for IP.
		 */
		IFP_TO_IA(oia->ia_ifp, ia);
		if (ia) {	/* there is another address */
			struct in_multi *inm;
			for(inm = oia->ia_multiaddrs.lh_first; inm;
			    inm = inm->inm_entry.le_next) {
				IFAFREE(&inm->inm_ia->ia_ifa);
				ia->ia_ifa.ifa_refcnt++;
				inm->inm_ia = ia;
				LIST_INSERT_HEAD(&ia->ia_multiaddrs, inm,
						 inm_entry);
			}
			FREE(mk, M_IPMADDR);
		} else {	/* last address on this if deleted, save */
			struct in_multi *inm;

			LIST_INIT(&mk->mk_head);
			mk->mk_ifp = ifp;

			for(inm = oia->ia_multiaddrs.lh_first; inm;
			    inm = inm->inm_entry.le_next) {
				LIST_INSERT_HEAD(&mk->mk_head, inm, inm_entry);
			}

			if (mk->mk_head.lh_first) {
				LIST_INSERT_HEAD(&in_mk, mk, mk_entry);
			} else {
				FREE(mk, M_IPMADDR);
			}
		}

		IFAFREE((&oia->ia_ifa));
a362 18
 * Delete any existing route for an interface.
 */
void
in_ifscrub(ifp, ia)
	register struct ifnet *ifp;
	register struct in_ifaddr *ia;
{

	if ((ia->ia_flags & IFA_ROUTE) == 0)
		return;
	if (ifp->if_flags & (IFF_LOOPBACK|IFF_POINTOPOINT))
		rtinit(&(ia->ia_ifa), (int)RTM_DELETE, RTF_HOST);
	else
		rtinit(&(ia->ia_ifa), (int)RTM_DELETE, 0);
	ia->ia_flags &= ~IFA_ROUTE;
}

/*
d366 1
a366 2
int
in_ifinit(ifp, ia, sin, scrub)
a369 1
	int scrub;
d372 3
a374 5
	struct sockaddr_in oldaddr;
	int s = splimp(), flags = RTF_UP, error;
#ifdef MULTICAST
	struct multi_kludge *mk;
#endif
a375 4
#ifdef DEBUG
        Printf("in_ifinit(%x, %x, (sin), %d); sin=(%d,%d,%x)\n",
               ifp, ia, scrub, sin->sin_family, sin->sin_len, htonl(sin->sin_addr.s_addr));
#endif
d377 2
a378 1
	ia->ia_addr = *sin;
d384 1
a384 2
	if (ifp->if_ioctl &&
	    (error = (*ifp->if_ioctl)(ifp, SIOCSIFADDR, (caddr_t)ia))) {
a386 3
#ifdef DEBUG
                Printf("in_ifinit: interface returned error %d\n", error);
#endif
d389 19
a407 5
	splx(s);
	if (scrub) {
		ia->ia_ifa.ifa_addr = (struct sockaddr *)&oldaddr;
		in_ifscrub(ifp, ia);
		ia->ia_ifa.ifa_addr = (struct sockaddr *)&ia->ia_addr;
d415 1
d417 2
a418 3
	 * The subnet mask usually includes at least the standard network part,
	 * but may may be smaller in the case of supernetting.
	 * If it is set, we believe it.
d420 1
a420 6
	if (ia->ia_subnetmask == 0) {
		ia->ia_subnetmask = ia->ia_netmask;
		ia->ia_sockmask.sin_addr.s_addr = htonl(ia->ia_subnetmask);
	} else
		ia->ia_netmask &= ia->ia_subnetmask;
	ia->ia_net = i & ia->ia_netmask;
a421 8
	in_socktrim(&ia->ia_sockmask);
	/*
	 * Add route for the network.
	 */
#ifdef DEBUG
        Printf("in_ifinit: adding route!\n");
#endif
	ia->ia_ifa.ifa_metric = ifp->if_metric;
d423 3
a425 2
		ia->ia_broadaddr.sin_addr.s_addr =
			htonl(ia->ia_subnet | ~ia->ia_subnetmask);
d427 1
a427 8
			htonl(ia->ia_net | ~ ia->ia_netmask);
	} else if (ifp->if_flags & IFF_LOOPBACK) {
		ia->ia_ifa.ifa_dstaddr = ia->ia_ifa.ifa_addr;
		flags |= RTF_HOST;
	} else if (ifp->if_flags & IFF_POINTOPOINT) {
		if (ia->ia_dstaddr.sin_family != AF_INET)
			return (0);
		flags |= RTF_HOST;
a428 8
	if ((error = rtinit(&(ia->ia_ifa), (int)RTM_ADD, flags)) == 0)
		ia->ia_flags |= IFA_ROUTE;

#ifdef DEBUG
        Printf("rtinit returned %d\n", error);
#endif
	LIST_INIT(&ia->ia_multiaddrs);
#ifdef MULTICAST
d430 1
a430 2
	 * If the interface supports multicast, join the "all hosts"
	 * multicast group on that interface.
d432 13
a444 26
	if (ifp->if_flags & IFF_MULTICAST) {
		struct in_addr addr;

		/*
		 * Continuation of multicast address hack:
		 * If there was a multicast group list previously saved
		 * for this interface, then we re-attach it to the first
		 * address configured on the i/f.
		 */
		for(mk = in_mk.lh_first; mk; mk = mk->mk_entry.le_next) {
			if(mk->mk_ifp == ifp) {
				struct in_multi *inm;

				for(inm = mk->mk_head.lh_first; inm;
				    inm = inm->inm_entry.le_next) {
					IFAFREE(&inm->inm_ia->ia_ifa);
					ia->ia_ifa.ifa_refcnt++;
					inm->inm_ia = ia;
					LIST_INSERT_HEAD(&ia->ia_multiaddrs,
							 inm, inm_entry);
				}
				LIST_REMOVE(mk, mk_entry);
				free(mk, M_IPMADDR);
				break;
			}
		}
a445 4
		addr.s_addr = htonl(INADDR_ALLHOSTS_GROUP);
		in_addmulti(&addr, ifp);
	}
#endif
d457 1
a457 2
	if (error == 0)
		sc_addrchanged();
d460 16
a475 1
	return (error);
d481 1
a481 2
int
in_broadcast(in, ifp)
a482 1
        struct ifnet *ifp;
d484 1
a484 1
	register struct ifaddr *ifa;
a486 6
	if (in.s_addr == INADDR_BROADCAST ||
	    in.s_addr == INADDR_ANY)
		return 1;
	if ((ifp->if_flags & IFF_BROADCAST) == 0)
		return 0;
	t = ntohl(in.s_addr);
d491 4
a494 41
#define ia ((struct in_ifaddr *)ifa)
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
		if (ifa->ifa_addr->sa_family == AF_INET &&
		    (in.s_addr == ia->ia_broadaddr.sin_addr.s_addr ||
		     in.s_addr == ia->ia_netbroadcast.s_addr ||
		     /*
		      * Check for old-style (host 0) broadcast.
		      */
		     t == ia->ia_subnet || t == ia->ia_net) &&
		     /*
		      * Check for an all one subnetmask. These
		      * only exist when an interface gets a secondary
		      * address.
		      */
		     ia->ia_subnetmask != (u_long)0xffffffff)
			    return 1;
	return (0);
#undef ia
}
#ifdef MULTICAST
/*
 * Add an address to the list of IP multicast addresses for a given interface.
 */
struct in_multi *
in_addmulti(ap, ifp)
	register struct in_addr *ap;
	register struct ifnet *ifp;
{
	register struct in_multi *inm;
	struct ifreq ifr;
	struct in_ifaddr *ia;

#ifdef DEBUG
	if (DODEBUG(DBGIGMP))
		Printf("in_addmulti(%x,%x)\n", *ap, ifp);
#endif
	/*
	 * See if address already in list.
	 */
	IN_LOOKUP_MULTI(*ap, ifp, inm);
	if (inm != NULL) {
d496 1
a496 1
		 * Found it; just increment the reference count.
d498 2
a499 1
		++inm->inm_refcount;
d501 4
a504 8
	else {
		/*
		 * New address; allocate a new multicast record
		 * and link it into the interface's multicast list.
		 */
#ifdef DEBUG
		if (DODEBUG(DBGIGMP))
			Printf("New address\n");
a505 20
		inm = (struct in_multi *)malloc(sizeof(*inm),
		    M_IPMADDR, M_NOWAIT);
		if (inm == NULL) {
			return (NULL);
		}
		inm->inm_addr = *ap;
		inm->inm_ifp = ifp;
		inm->inm_refcount = 1;
		IFP_TO_IA(ifp, ia);
		if (ia == NULL) {
#ifdef DEBUG
			if (DODEBUG(DBGIGMP))
				Printf("ia == NULL!!!\n");
#endif
			free(inm, M_IPMADDR);
			return (NULL);
		}
		inm->inm_ia = ia;
		ia->ia_ifa.ifa_refcnt++; /* gain a reference */
		LIST_INSERT_HEAD(&ia->ia_multiaddrs, inm, inm_entry);
d507 1
a507 59
		/*
		 * Ask the network driver to update its multicast reception
		 * filter appropriately for the new address.
		 */
		((struct sockaddr_in *)&ifr.ifr_addr)->sin_family = AF_INET;
		((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr = *ap;
		if ((ifp->if_ioctl == NULL) ||
		    (*ifp->if_ioctl)(ifp, SIOCADDMULTI,(caddr_t)&ifr) != 0) {
#ifdef DEBUG
			if (DODEBUG(DBGIGMP))
				Printf("ioctl failed!!!\n");
#endif
			LIST_REMOVE(inm, inm_entry);
			IFAFREE(&ia->ia_ifa); /* release reference */
			free(inm, M_IPMADDR);
			return (NULL);
		}
		/*
		 * Let IGMP know that we have joined a new IP multicast group.
		 */
		igmp_joingroup(inm);
	}
	return (inm);
}

/*
 * Delete a multicast address record.
 */
void
in_delmulti(inm)
	register struct in_multi *inm;
{
	struct ifreq ifr;

	if (--inm->inm_refcount == 0) {
		/*
		 * No remaining claims to this record; let IGMP know that
		 * we are leaving the multicast group.
		 */
		igmp_leavegroup(inm);
		/*
		 * Unlink from list.
		 */
		LIST_REMOVE(inm, inm_entry);
		IFAFREE(&inm->inm_ia->ia_ifa); /* release reference */

		/*
		 * Notify the network driver to update its multicast reception
		 * filter.
		 */
		((struct sockaddr_in *)&(ifr.ifr_addr))->sin_family = AF_INET;
		((struct sockaddr_in *)&(ifr.ifr_addr))->sin_addr =
								inm->inm_addr;
		(*inm->inm_ifp->if_ioctl)(inm->inm_ifp, SIOCDELMULTI,
							     (caddr_t)&ifr);
		free(inm, M_IPMADDR);
	}
}
#endif /* MULTICAST */
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@RCS log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d1 16
d18 2
a19 18
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a32 2
 *	@@(#)in.c	8.2 (Berkeley) 11/15/93
 * $Id: in.c,v 1.14.4.2 1996/01/30 21:41:34 davidg Exp $
d34 24
d59 7
a65 16
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/if_ether.h>
d67 3
a69 1
#include <netinet/igmp_var.h>
d71 2
a72 2
#include "module.h"
#include "debug.h"
d75 1
a75 2
 * This structure is used to keep track of in_multi chains which belong to
 * deleted interface addresses.
d77 7
a83 1
static LIST_HEAD(, multi_kludge) in_mk; /* XXX BSS initialization */
d85 14
a98 5
struct multi_kludge {
	LIST_ENTRY(multi_kludge) mk_entry;
	struct ifnet *mk_ifp;
	struct in_multihead mk_head;
};
a116 2
	else if (IN_CLASSD(i))
		net = i & IN_CLASSD_NET;
d130 33
d164 1
a164 1
#define	SUBNETSARELOCAL	1
d169 1
a169 1
 * (one to which we have a connection).  If subnetsarelocal
a172 1
int
a195 1
int
d202 1
a202 1
	if (IN_EXPERIMENTAL(i) || IN_MULTICAST(i))
d206 1
a206 1
		if (net == 0 || net == (IN_LOOPBACKNET << IN_CLASSA_NSHIFT))
d212 2
a213 19
/*
 * Trim a mask in a sockaddr
 */
void
in_socktrim(ap)
struct sockaddr_in *ap;
{
    register char *cplim = (char *) &ap->sin_addr;
    register char *cp = (char *) (&ap->sin_addr + 1);

    ap->sin_len = 0;
    while (--cp >= cplim)
        if (*cp) {
	    (ap)->sin_len = cp - (char *) (ap) + 1;
	    break;
	}
}

int	in_interfaces;	    /* number of external internet interfaces */
a219 1
int
d228 3
a230 7
	register struct ifaddr *ifa;
	struct in_ifaddr *oia;
	struct in_aliasreq *ifra = (struct in_aliasreq *)data;
	struct sockaddr_in oldaddr;
	int error, hostIsNew, maskIsNew;
	u_long i;
	struct multi_kludge *mk;
a239 4
#ifdef DEBUG
        Printf("in_control(so=%x,cmd=%x,data=%x,ifp=%x)\n", so, cmd, data, ifp);
        Printf("   ifreq=%s,%x %x %x %x\n", ifr->ifr_name, ifr->ifr_metric, *((&ifr->ifr_metric)+1),*((&ifr->ifr_metric)+2),*((&ifr->ifr_metric)+3));
#endif
a241 19
	case SIOCAIFADDR:
	case SIOCDIFADDR:
		if (ifra->ifra_addr.sin_family == AF_INET) {
			for (oia = ia; ia; ia = ia->ia_next) {
				if (ia->ia_ifp == ifp  &&
				    ia->ia_addr.sin_addr.s_addr ==
				    ifra->ifra_addr.sin_addr.s_addr)
					break;
			}
			if ((ifp->if_flags & IFF_POINTOPOINT)
			    && (cmd == SIOCAIFADDR)
			    && (ifra->ifra_dstaddr.sin_addr.s_addr
				== INADDR_ANY)) {
				return EDESTADDRREQ;
			}
		}
		if (cmd == SIOCDIFADDR && ia == 0)
			return (EADDRNOTAVAIL);
		/* FALLTHROUGH */
a244 2
		if ((so->so_state & SS_PRIV) == 0)
			return (EPERM);
d251 7
a257 3
			oia = (struct in_ifaddr *)
				malloc(sizeof *oia, M_IFADDR, M_WAITOK);
			if (oia == (struct in_ifaddr *)NULL) {
d260 1
a260 1
				Printf("in_control: malloc failed\n");
d264 4
a267 3
			bzero((caddr_t)oia, sizeof *oia);
			ia = in_ifaddr;
			if (ia) {
d269 2
a270 2
					continue;
				ia->ia_next = oia;
d272 3
a274 4
				in_ifaddr = oia;
			ia = oia;
			ifa = ifp->if_addrlist;
			if (ifa) {
d276 1
a276 1
					continue;
a279 10
			ia->ia_ifa.ifa_addr = (struct sockaddr *)&ia->ia_addr;
			ia->ia_ifa.ifa_dstaddr
					= (struct sockaddr *)&ia->ia_dstaddr;
			ia->ia_ifa.ifa_netmask
					= (struct sockaddr *)&ia->ia_sockmask;
			ia->ia_sockmask.sin_len = 8;
			if (ifp->if_flags & IFF_BROADCAST) {
				ia->ia_broadaddr.sin_len = sizeof(ia->ia_addr);
				ia->ia_broadaddr.sin_family = AF_INET;
			}
d281 2
a282 1
			if (!(ifp->if_flags & IFF_LOOPBACK))
d288 1
a288 8
		if ((so->so_state & SS_PRIV) == 0)
			return (EPERM);
		/* FALLTHROUGH */

	case SIOCGIFADDR:
	case SIOCGIFNETMASK:
	case SIOCGIFDSTADDR:
	case SIOCGIFBRDADDR:
d293 1
d297 1
a297 1
		*((struct sockaddr_in *)&ifr->ifr_addr) = ia->ia_addr;
d303 1
a303 1
		*((struct sockaddr_in *)&ifr->ifr_dstaddr) = ia->ia_broadaddr;
d309 1
a309 1
		*((struct sockaddr_in *)&ifr->ifr_dstaddr) = ia->ia_dstaddr;
d313 3
a315 1
		*((struct sockaddr_in *)&ifr->ifr_addr) = ia->ia_sockmask;
d319 3
d325 3
a327 3
		ia->ia_dstaddr = *(struct sockaddr_in *)&ifr->ifr_dstaddr;
		if (ifp->if_ioctl && (error = (*ifp->if_ioctl)
					(ifp, SIOCSIFDSTADDR, (caddr_t)ia))) {
d332 4
a335 5
			ia->ia_ifa.ifa_dstaddr = (struct sockaddr *)&oldaddr;
			rtinit(&(ia->ia_ifa), (int)RTM_DELETE, RTF_HOST);
			ia->ia_ifa.ifa_dstaddr =
					(struct sockaddr *)&ia->ia_dstaddr;
			rtinit(&(ia->ia_ifa), (int)RTM_ADD, RTF_HOST|RTF_UP);
d337 1
d343 1
a343 1
		ia->ia_broadaddr = *(struct sockaddr_in *)&ifr->ifr_broadaddr;
d348 1
a348 1
		    (struct sockaddr_in *) &ifr->ifr_addr, 1));
d351 1
a351 110
		i = ifra->ifra_addr.sin_addr.s_addr;
		ia->ia_subnetmask = ntohl(ia->ia_sockmask.sin_addr.s_addr = i);
		break;

	case SIOCAIFADDR:
		maskIsNew = 0;
		hostIsNew = 1;
		error = 0;
		if (ia->ia_addr.sin_family == AF_INET) {
			if (ifra->ifra_addr.sin_len == 0) {
				ifra->ifra_addr = ia->ia_addr;
				hostIsNew = 0;
			} else if (ifra->ifra_addr.sin_addr.s_addr ==
					       ia->ia_addr.sin_addr.s_addr)
				hostIsNew = 0;
		}
		if (ifra->ifra_mask.sin_len) {
			in_ifscrub(ifp, ia);
			ia->ia_sockmask = ifra->ifra_mask;
			ia->ia_subnetmask =
			     ntohl(ia->ia_sockmask.sin_addr.s_addr);
			maskIsNew = 1;
		}
		if ((ifp->if_flags & IFF_POINTOPOINT) &&
		    (ifra->ifra_dstaddr.sin_family == AF_INET)) {
			in_ifscrub(ifp, ia);
			ia->ia_dstaddr = ifra->ifra_dstaddr;
			maskIsNew  = 1; /* We lie; but the effect's the same */
		}
		if (ifra->ifra_addr.sin_family == AF_INET &&
		    (hostIsNew || maskIsNew))
			error = in_ifinit(ifp, ia, &ifra->ifra_addr, 0);
		if ((ifp->if_flags & IFF_BROADCAST) &&
		    (ifra->ifra_broadaddr.sin_family == AF_INET))
			ia->ia_broadaddr = ifra->ifra_broadaddr;
		return (error);

	case SIOCDIFADDR:
		mk = malloc(sizeof *mk, M_IPMADDR, M_WAITOK);
		if (!mk)
			return ENOBUFS;

		in_ifscrub(ifp, ia);
		if ((ifa = ifp->if_addrlist) == (struct ifaddr *)ia)
			ifp->if_addrlist = ifa->ifa_next;
		else {
			while (ifa->ifa_next &&
			       (ifa->ifa_next != (struct ifaddr *)ia))
				    ifa = ifa->ifa_next;
			if (ifa->ifa_next)
				ifa->ifa_next = ((struct ifaddr *)ia)->ifa_next;
			else
				printf("Couldn't unlink inifaddr from ifp\n");
		}
		oia = ia;
		if (oia == (ia = in_ifaddr))
			in_ifaddr = ia->ia_next;
		else {
			while (ia->ia_next && (ia->ia_next != oia))
				ia = ia->ia_next;
			if (ia->ia_next)
				ia->ia_next = oia->ia_next;
			else
				printf("Didn't unlink inifadr from list\n");
		}

		if (!oia->ia_multiaddrs.lh_first) {
			IFAFREE(&oia->ia_ifa);
			FREE(mk, M_IPMADDR);
			break;
		}

		/*
		 * Multicast address kludge:
		 * If there were any multicast addresses attached to this
		 * interface address, either move them to another address
		 * on this interface, or save them until such time as this
		 * interface is reconfigured for IP.
		 */
		IFP_TO_IA(oia->ia_ifp, ia);
		if (ia) {	/* there is another address */
			struct in_multi *inm;
			for(inm = oia->ia_multiaddrs.lh_first; inm;
			    inm = inm->inm_entry.le_next) {
				IFAFREE(&inm->inm_ia->ia_ifa);
				ia->ia_ifa.ifa_refcnt++;
				inm->inm_ia = ia;
				LIST_INSERT_HEAD(&ia->ia_multiaddrs, inm,
						 inm_entry);
			}
			FREE(mk, M_IPMADDR);
		} else {	/* last address on this if deleted, save */
			struct in_multi *inm;

			LIST_INIT(&mk->mk_head);
			mk->mk_ifp = ifp;

			for(inm = oia->ia_multiaddrs.lh_first; inm;
			    inm = inm->inm_entry.le_next) {
				LIST_INSERT_HEAD(&mk->mk_head, inm, inm_entry);
			}

			if (mk->mk_head.lh_first) {
				LIST_INSERT_HEAD(&in_mk, mk, mk_entry);
			} else {
				FREE(mk, M_IPMADDR);
			}
		}

		IFAFREE((&oia->ia_ifa));
a362 18
 * Delete any existing route for an interface.
 */
void
in_ifscrub(ifp, ia)
	register struct ifnet *ifp;
	register struct in_ifaddr *ia;
{

	if ((ia->ia_flags & IFA_ROUTE) == 0)
		return;
	if (ifp->if_flags & (IFF_LOOPBACK|IFF_POINTOPOINT))
		rtinit(&(ia->ia_ifa), (int)RTM_DELETE, RTF_HOST);
	else
		rtinit(&(ia->ia_ifa), (int)RTM_DELETE, 0);
	ia->ia_flags &= ~IFA_ROUTE;
}

/*
d366 1
a366 2
int
in_ifinit(ifp, ia, sin, scrub)
a369 1
	int scrub;
d372 3
a374 5
	struct sockaddr_in oldaddr;
	int s = splimp(), flags = RTF_UP, error;
#ifdef MULTICAST
	struct multi_kludge *mk;
#endif
a375 4
#ifdef DEBUG
        Printf("in_ifinit(%x, %x, (sin), %d); sin=(%d,%d,%x)\n",
               ifp, ia, scrub, sin->sin_family, sin->sin_len, htonl(sin->sin_addr.s_addr));
#endif
d377 2
a378 1
	ia->ia_addr = *sin;
d384 1
a384 2
	if (ifp->if_ioctl &&
	    (error = (*ifp->if_ioctl)(ifp, SIOCSIFADDR, (caddr_t)ia))) {
a386 3
#ifdef DEBUG
                Printf("in_ifinit: interface returned error %d\n", error);
#endif
d389 19
a407 5
	splx(s);
	if (scrub) {
		ia->ia_ifa.ifa_addr = (struct sockaddr *)&oldaddr;
		in_ifscrub(ifp, ia);
		ia->ia_ifa.ifa_addr = (struct sockaddr *)&ia->ia_addr;
d415 1
d417 2
a418 3
	 * The subnet mask usually includes at least the standard network part,
	 * but may may be smaller in the case of supernetting.
	 * If it is set, we believe it.
d420 1
a420 6
	if (ia->ia_subnetmask == 0) {
		ia->ia_subnetmask = ia->ia_netmask;
		ia->ia_sockmask.sin_addr.s_addr = htonl(ia->ia_subnetmask);
	} else
		ia->ia_netmask &= ia->ia_subnetmask;
	ia->ia_net = i & ia->ia_netmask;
a421 8
	in_socktrim(&ia->ia_sockmask);
	/*
	 * Add route for the network.
	 */
#ifdef DEBUG
        Printf("in_ifinit: adding route!\n");
#endif
	ia->ia_ifa.ifa_metric = ifp->if_metric;
d423 3
a425 2
		ia->ia_broadaddr.sin_addr.s_addr =
			htonl(ia->ia_subnet | ~ia->ia_subnetmask);
d427 1
a427 8
			htonl(ia->ia_net | ~ ia->ia_netmask);
	} else if (ifp->if_flags & IFF_LOOPBACK) {
		ia->ia_ifa.ifa_dstaddr = ia->ia_ifa.ifa_addr;
		flags |= RTF_HOST;
	} else if (ifp->if_flags & IFF_POINTOPOINT) {
		if (ia->ia_dstaddr.sin_family != AF_INET)
			return (0);
		flags |= RTF_HOST;
a428 8
	if ((error = rtinit(&(ia->ia_ifa), (int)RTM_ADD, flags)) == 0)
		ia->ia_flags |= IFA_ROUTE;

#ifdef DEBUG
        Printf("rtinit returned %d\n", error);
#endif
	LIST_INIT(&ia->ia_multiaddrs);
#ifdef MULTICAST
d430 1
a430 2
	 * If the interface supports multicast, join the "all hosts"
	 * multicast group on that interface.
d432 13
a444 26
	if (ifp->if_flags & IFF_MULTICAST) {
		struct in_addr addr;

		/*
		 * Continuation of multicast address hack:
		 * If there was a multicast group list previously saved
		 * for this interface, then we re-attach it to the first
		 * address configured on the i/f.
		 */
		for(mk = in_mk.lh_first; mk; mk = mk->mk_entry.le_next) {
			if(mk->mk_ifp == ifp) {
				struct in_multi *inm;

				for(inm = mk->mk_head.lh_first; inm;
				    inm = inm->inm_entry.le_next) {
					IFAFREE(&inm->inm_ia->ia_ifa);
					ia->ia_ifa.ifa_refcnt++;
					inm->inm_ia = ia;
					LIST_INSERT_HEAD(&ia->ia_multiaddrs,
							 inm, inm_entry);
				}
				LIST_REMOVE(mk, mk_entry);
				free(mk, M_IPMADDR);
				break;
			}
		}
a445 4
		addr.s_addr = htonl(INADDR_ALLHOSTS_GROUP);
		in_addmulti(&addr, ifp);
	}
#endif
d457 1
a457 2
	if (error == 0)
		sc_addrchanged();
d460 16
a475 1
	return (error);
d481 1
a481 2
int
in_broadcast(in, ifp)
a482 1
        struct ifnet *ifp;
d484 1
a484 1
	register struct ifaddr *ifa;
a486 6
	if (in.s_addr == INADDR_BROADCAST ||
	    in.s_addr == INADDR_ANY)
		return 1;
	if ((ifp->if_flags & IFF_BROADCAST) == 0)
		return 0;
	t = ntohl(in.s_addr);
d491 4
a494 41
#define ia ((struct in_ifaddr *)ifa)
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
		if (ifa->ifa_addr->sa_family == AF_INET &&
		    (in.s_addr == ia->ia_broadaddr.sin_addr.s_addr ||
		     in.s_addr == ia->ia_netbroadcast.s_addr ||
		     /*
		      * Check for old-style (host 0) broadcast.
		      */
		     t == ia->ia_subnet || t == ia->ia_net) &&
		     /*
		      * Check for an all one subnetmask. These
		      * only exist when an interface gets a secondary
		      * address.
		      */
		     ia->ia_subnetmask != (u_long)0xffffffff)
			    return 1;
	return (0);
#undef ia
}
#ifdef MULTICAST
/*
 * Add an address to the list of IP multicast addresses for a given interface.
 */
struct in_multi *
in_addmulti(ap, ifp)
	register struct in_addr *ap;
	register struct ifnet *ifp;
{
	register struct in_multi *inm;
	struct ifreq ifr;
	struct in_ifaddr *ia;

#ifdef DEBUG
	if (DODEBUG(DBGIGMP))
		Printf("in_addmulti(%x,%x)\n", *ap, ifp);
#endif
	/*
	 * See if address already in list.
	 */
	IN_LOOKUP_MULTI(*ap, ifp, inm);
	if (inm != NULL) {
d496 1
a496 1
		 * Found it; just increment the reference count.
d498 2
a499 1
		++inm->inm_refcount;
d501 4
a504 8
	else {
		/*
		 * New address; allocate a new multicast record
		 * and link it into the interface's multicast list.
		 */
#ifdef DEBUG
		if (DODEBUG(DBGIGMP))
			Printf("New address\n");
a505 20
		inm = (struct in_multi *)malloc(sizeof(*inm),
		    M_IPMADDR, M_NOWAIT);
		if (inm == NULL) {
			return (NULL);
		}
		inm->inm_addr = *ap;
		inm->inm_ifp = ifp;
		inm->inm_refcount = 1;
		IFP_TO_IA(ifp, ia);
		if (ia == NULL) {
#ifdef DEBUG
			if (DODEBUG(DBGIGMP))
				Printf("ia == NULL!!!\n");
#endif
			free(inm, M_IPMADDR);
			return (NULL);
		}
		inm->inm_ia = ia;
		ia->ia_ifa.ifa_refcnt++; /* gain a reference */
		LIST_INSERT_HEAD(&ia->ia_multiaddrs, inm, inm_entry);
d507 1
a507 59
		/*
		 * Ask the network driver to update its multicast reception
		 * filter appropriately for the new address.
		 */
		((struct sockaddr_in *)&ifr.ifr_addr)->sin_family = AF_INET;
		((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr = *ap;
		if ((ifp->if_ioctl == NULL) ||
		    (*ifp->if_ioctl)(ifp, SIOCADDMULTI,(caddr_t)&ifr) != 0) {
#ifdef DEBUG
			if (DODEBUG(DBGIGMP))
				Printf("ioctl failed!!!\n");
#endif
			LIST_REMOVE(inm, inm_entry);
			IFAFREE(&ia->ia_ifa); /* release reference */
			free(inm, M_IPMADDR);
			return (NULL);
		}
		/*
		 * Let IGMP know that we have joined a new IP multicast group.
		 */
		igmp_joingroup(inm);
	}
	return (inm);
}

/*
 * Delete a multicast address record.
 */
void
in_delmulti(inm)
	register struct in_multi *inm;
{
	struct ifreq ifr;

	if (--inm->inm_refcount == 0) {
		/*
		 * No remaining claims to this record; let IGMP know that
		 * we are leaving the multicast group.
		 */
		igmp_leavegroup(inm);
		/*
		 * Unlink from list.
		 */
		LIST_REMOVE(inm, inm_entry);
		IFAFREE(&inm->inm_ia->ia_ifa); /* release reference */

		/*
		 * Notify the network driver to update its multicast reception
		 * filter.
		 */
		((struct sockaddr_in *)&(ifr.ifr_addr))->sin_family = AF_INET;
		((struct sockaddr_in *)&(ifr.ifr_addr))->sin_addr =
								inm->inm_addr;
		(*inm->inm_ifp->if_ioctl)(inm->inm_ifp, SIOCDELMULTI,
							     (caddr_t)&ifr);
		free(inm, M_IPMADDR);
	}
}
#endif /* MULTICAST */
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@

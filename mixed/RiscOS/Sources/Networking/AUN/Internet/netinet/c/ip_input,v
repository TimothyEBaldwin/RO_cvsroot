head	4.10;
access;
symbols
	Internet-5_65:4.10
	Internet-5_64:4.10
	Internet-5_63:4.10
	Internet-5_62:4.10
	Internet-5_61:4.10
	Internet-5_60:4.10
	Internet-5_59:4.10
	Internet-5_58:4.10
	Internet-5_57:4.10
	Internet-5_56:4.10
	Internet-5_55:4.10
	Internet-5_54:4.10
	Internet-5_53:4.10
	Internet-5_52:4.10
	Internet-5_51:4.10
	Internet-5_50:4.10
	RO_5_07:4.10
	Internet-5_49:4.10
	Internet-5_48:4.10
	Internet-5_47:4.10
	Internet-5_46:4.10
	Internet-5_45:4.10
	Internet-5_44:4.10
	Internet-5_43:4.10
	Internet-5_42:4.9
	Internet-5_41:4.9
	Internet-5_40:4.8
	Internet-5_39:4.8
	Internet-5_38:4.8
	Internet-5_37:4.8
	Internet-5_36:4.8
	Internet-5_35:4.8
	Internet-5_34:4.8
	Internet-5_33:4.7
	Internet-5_32:4.7
	Internet-5_31:4.7
	Internet-5_30:4.6
	Internet-5_29:4.6
	Internet-5_27:4.5
	Internet-5_26:4.5
	Internet-5_25:4.5
	Internet-5_24:4.5
	Internet-5_23:4.5
	Internet-5_22:4.5
	Internet-5_21:4.5
	Internet-5_20:4.5
	Internet-5_19:4.5
	Internet-5_18:4.5
	Internet-5_17:4.4
	Internet-5_16:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Internet-5_15:4.2
	Internet-5_14:4.2
	Internet-5_13:4.2
	sforrest_daytona_appflash-0_31:4.2
	Internet-5_12:4.2
	Internet-5_11:4.2
	celkins_Internet-5_10:4.2
	nicke_Internat_25-9-98:4.2
	Internet-5_09:4.2
	blaughto_daytona_appflash-0_30:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rwarren_Internet-5_08:4.2
	Spinner:4.2
	Internet_5_07:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.2
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.10
date	2000.07.05.14.48.26;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	2000.05.12.11.49.04;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	99.07.28.12.00.12;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	99.07.13.11.12.53;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.07.08.15.25.36;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	98.11.28.20.43.05;	author celkins;	state Exp;
branches;
next	4.4;

4.4
date	98.11.27.14.49.06;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.11.27.05.07.27;	author celkins;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.58.50;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.08;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.08;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.20.06;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.28.08;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.06.47;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.22;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.06.42;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.34;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.38.28;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.20;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Restored DELAY_EVENTS functionality.

Detail:
VideoControl was having a nasty reentrancy problem inside its event handler;
we've been sending out events at points where a BSD Unix system wouldn't and
exposing a number of potential problems. Fixed by restoring the delayed event
scheme used in earlier versions of Internet 5, but with an extra event send
inside the packet input loop which should alleviate the high load problems
seen with the NEC video client.

Seems to work fine, but we've been unable to get the NEC video client to
work at all, let alone test it on this Internet module. Doesn't matter for
now because we're not shipping it :)

Version 5.43. Tagged as 'Internet-5_43'
@
text
@/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <kernel.h>

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/errno.h>
#include <sys/sysctl.h>
#include <sys/dcistructs.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_dl.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>
#include <netinet/tcp.h>

#include <sys/socketvar.h>

#include <machine/in_cksum.h>

#include "svcdebug.h"
#include "debug.h"
#include "module.h"

int rsvp_on = 0;
int ip_rsvp_on;
struct socket *ip_rsvpd;

int	ipforwarding = 0;
SYSCTL_INT(_net_inet_ip, IPCTL_FORWARDING, forwarding, CTLFLAG_RW,
    &ipforwarding, 0, "Enable IP forwarding between interfaces");

static int	ipsendredirects = 1; /* XXX */
SYSCTL_INT(_net_inet_ip, IPCTL_SENDREDIRECTS, redirect, CTLFLAG_RW,
    &ipsendredirects, 0, "Enable sending IP redirects");

int	ip_defttl = IPDEFTTL;
SYSCTL_INT(_net_inet_ip, IPCTL_DEFTTL, ttl, CTLFLAG_RW,
    &ip_defttl, 0, "Maximum TTL on IP packets");

static int	ip_dosourceroute = 0;
SYSCTL_INT(_net_inet_ip, IPCTL_SOURCEROUTE, sourceroute, CTLFLAG_RW,
    &ip_dosourceroute, 0, "Enable forwarding source routed IP packets");

static int	ip_acceptsourceroute = 0;
SYSCTL_INT(_net_inet_ip, IPCTL_ACCEPTSOURCEROUTE, accept_sourceroute,
    CTLFLAG_RW, &ip_acceptsourceroute, 0,
    "Enable accepting source routed IP packets");
#ifdef DIAGNOSTIC
int	ipprintfs = 0;
#endif

extern	struct domain inetdomain;
extern	struct protosw inetsw[];
u_char	ip_protox[IPPROTO_MAX];
int	ipqmaxlen = IFQ_MAXLEN;
struct  in_ifaddr *in_ifaddr;		       /* first inet address */
struct	ifqueue ipintrq;
SYSCTL_INT(_net_inet_ip, IPCTL_INTRQMAXLEN, intr_queue_maxlen, CTLFLAG_RW,
    &ipintrq.ifq_maxlen, 0, "Maximum size of the IP input queue");
SYSCTL_INT(_net_inet_ip, IPCTL_INTRQDROPS, intr_queue_drops, CTLFLAG_RD,
    &ipintrq.ifq_drops, 0, "Number of packets dropped from the IP input queue");

struct ipstat ipstat;
SYSCTL_STRUCT(_net_inet_ip, IPCTL_STATS, stats, CTLFLAG_RD,
    &ipstat, ipstat, "IP statistics (struct ipstat, netinet/ip_var.h)");

struct ipq ipq;

/* Firewall hooks */
ip_fw_chk_t *ip_fw_chk_ptr;
ip_fw_ctl_t *ip_fw_ctl_ptr;

/*
 * We need to save the IP options in case a protocol wants to respond
 * to an incoming packet over the same route if the packet got here
 * using IP source routing.  This allows connection establishment and
 * maintenance when the remote end is on a network that is not known
 * to us.
 */
int	ip_nhops = 0;
static	struct ip_srcrt {
	struct	in_addr dst;			/* final destination */
	char	nop;				/* one NOP to align */
	char	srcopt[IPOPT_OFFSET + 1];	/* OPTVAL, OLEN and OFFSET */
	struct	in_addr route[MAX_IPOPTLEN/sizeof(struct in_addr)];
} ip_srcrt;

static void save_rte(u_char *, struct in_addr);
/*
 * IP initialization: fill in IP protocol switch table.
 * All protocols not implemented in kernel go to raw IP protocol handler.
 */
void
ip_init()
{
	register struct protosw *pr;
	register int i;

	pr = pffindproto(PF_INET, IPPROTO_RAW, SOCK_RAW);
	if (pr == 0) {
		panic("ip_init");
		return;
	}
	for (i = 0; i < IPPROTO_MAX; i++)
		ip_protox[i] = pr - inetsw;
	for (pr = inetdomain.dom_protosw;
	    pr < inetdomain.dom_protoswNPROTOSW; pr++)
		if (pr->pr_domain->dom_family == PF_INET &&
		    pr->pr_protocol && pr->pr_protocol != IPPROTO_RAW)
			ip_protox[pr->pr_protocol] = pr - inetsw;
	ipq.next = ipq.prev = &ipq;
	ip_id = time.tv_sec & 0xffff;
	ipintrq.ifq_maxlen = ipqmaxlen;
#if defined(IPFIREWALL) && !defined(__riscos)
	ip_fw_init();
#endif /* IPFIREWALL */
}

struct	sockaddr_in ipaddr = { sizeof(ipaddr), AF_INET };
struct	route ipforward_rt;

/*int	ipcksum = 1;*/
static int ipfragttl = IPFRAGTTL;
SYSCTL_INT(_net_inet_ip, IPCTL_FRAGTTL, fragttl, CTLFLAG_RW,
    &ipfragttl, 0, "Maximum time to keep fragments");

int	onesbroadcast = 1;

/*
 * Ip input routine.  Checksum and byte swap header.  If fragmented
 * try to reassemble.  Process options.  Pass to next level.
 */
void
ip_input(struct mbuf *m)
{
	struct ip *ip;
	struct ipq *fp;
	struct in_ifaddr *ia;
	int hlen;
#ifdef QuickMNSAcks
	char ethersrc[6];
#else
        char *ethersrc = 0;
#endif

#ifdef QuickMNSAcks
	/*
	 * RISC OS - get ethersrc from DCI-4 RxHdr, then strip
	 * it off.
	 */
	memcpy(ethersrc, mtod(m, RxHdrRef)->rx_src_addr, 6);
	m = m_freen(m);
	if (m == 0)
		return;
#endif
#ifdef	DIAGNOSTIC
	if ((m->m_flags & M_PKTHDR) == 0) {
		panic("ipintr no HDR");
                Printf("panic: ipintr no HDR\n");
                Printf("m=-x%x, m->m_flags=0x%x\n", m, m->m_flags);
	}
#endif
	/*
	 * If no IP addresses have been set yet but the interfaces
	 * are receiving, can't do anything with incoming packets yet.
	 */
	if (in_ifaddr == NULL) {
#ifdef DEBUG
		if (DODEBUG(DBGINPUT))
			Printf("ipintr: in_ifaddr not set!\n");
#endif
#ifdef __riscos
		if (!(m->m_pkthdr.rcvif->if_flags & IFF_NEED_IPADDR))
#endif
		goto bad;
	}
	ipstat.ips_total++;
	if (m->m_len < sizeof (struct ip) &&
	    (m = m_pullup(m, sizeof (struct ip))) == 0) {
#ifdef DEBUG
		if( DODEBUG(DBGINPUT) )
		    Printf("ipintr: m_len (%d) is too small\n", m->m_len);
#endif
		ipstat.ips_toosmall++;
		return;
	}
	ip = mtod(m, struct ip *);
	if (ip->ip_v != IPVERSION) {
		ipstat.ips_badvers++;
		goto bad;
	}
	hlen = ip->ip_hl << 2;
	if (hlen < sizeof(struct ip)) {	/* minimum header length */
		ipstat.ips_badhlen++;
		goto bad;
	}
	if (hlen > m->m_len) {
		if ((m = m_pullup(m, hlen)) == 0) {
			ipstat.ips_badhlen++;
			return;
		}
		ip = mtod(m, struct ip *);
	}
    if (ip->ip_sum) {      /* Compatibility hack required for AUN (yuck) */
	if (hlen == sizeof(struct ip))
		ip->ip_sum = in_cksum_hdr(ip);
	else
		ip->ip_sum = in_cksum(m, hlen);
    }
	if (ip->ip_sum) {
		ipstat.ips_badsum++;
		goto bad;
	}

	/*
	 * Convert fields to host representation.
	 */
	NTOHS(ip->ip_len);
	if (ip->ip_len < hlen) {
		ipstat.ips_badlen++;
		goto bad;
	}
	NTOHS(ip->ip_id);
	NTOHS(ip->ip_off);

	/*
	 * Check that the amount of data in the buffers
	 * is as at least much as the IP header would have us expect.
	 * Trim mbufs if longer than we expect.
	 * Drop packet if shorter than we expect.
	 */
	if (m->m_pkthdr.len < ip->ip_len) {
#ifdef DEBUG
		if( DODEBUG(DBGINPUT) )
		        Printf("ipintr: len (%d) is < ip->ip_len\n", m->m_pkthdr.len, ip->ip_len);
#endif
		ipstat.ips_tooshort++;
		goto bad;
	}
	if (m->m_pkthdr.len > ip->ip_len) {
		if (m->m_len == m->m_pkthdr.len) {
			m->m_len = ip->ip_len;
			m->m_pkthdr.len = ip->ip_len;
		} else
			m_adj(m, ip->ip_len - m->m_pkthdr.len);
	}
#ifdef IPFIREWALL
	/*
	 * IpHack's section.
	 * Right now when no processing on packet has done
	 * and it is still fresh out of network we do our black
	 * deals with it.
	 * - Firewall: deny/allow
	 * - Wrap: fake packet's addr/port <unimpl.>
	 * - Encapsulate: put it in another IP and send out. <unimp.>
 	 */

	if (ip_fw_chk_ptr &&
	    !(*ip_fw_chk_ptr)(&ip, hlen, m->m_pkthdr.rcvif, 0, &m))
		return;
#endif

	/*
	 * Process options and, if not destined for us,
	 * ship it on.  ip_dooptions returns 1 when an
	 * error was detected (causing an icmp message
	 * to be sent and the original packet to be freed).
	 */
	ip_nhops = 0;		/* for source routed packets */
	if (hlen > sizeof (struct ip) && ip_dooptions(m))
		return;

#ifdef MULTICAST
        /* greedy RSVP, snatches any PATH packet of the RSVP protocol and no
         * matter if it is destined to another node, or whether it is
         * a multicast one, RSVP wants it! and prevents it from being forwarded
         * anywhere else. Also checks if the rsvp daemon is running before
	 * grabbing the packet.
         */
	if (rsvp_on && ip->ip_p==IPPROTO_RSVP)
		goto ours;
#endif

	/*
	 * Check our list of addresses, to see if the packet is for us.
	 */
	for (ia = in_ifaddr; ia; ia = ia->ia_next) {
#define	satosin(sa)	((struct sockaddr_in *)(sa))

		if (IA_SIN(ia)->sin_addr.s_addr == ip->ip_dst.s_addr)
			goto ours;
		if (
#ifdef	DIRECTED_BROADCAST
		    ia->ia_ifp == m->m_pkthdr.rcvif &&
#endif
		    (ia->ia_ifp->if_flags & IFF_BROADCAST)) {
			u_long t;

			if (satosin(&ia->ia_broadaddr)->sin_addr.s_addr ==
			    ip->ip_dst.s_addr)
				goto ours;
			if (ip->ip_dst.s_addr == ia->ia_netbroadcast.s_addr)
				goto ours;
			/*
			 * Look for all-0's host part (old broadcast addr),
			 * either for subnet or net.
			 */
			t = ntohl(ip->ip_dst.s_addr);
			if (t == ia->ia_subnet)
				goto ours;
			if (t == ia->ia_net)
				goto ours;
		}
	}
#ifdef MULTICAST
	if (IN_MULTICAST(ntohl(ip->ip_dst.s_addr))) {
		struct in_multi *inm;
		if (ip_mrouter) {
			/*
			 * If we are acting as a multicast router, all
			 * incoming multicast packets are passed to the
			 * kernel-level multicast forwarding function.
			 * The packet is returned (relatively) intact; if
			 * ip_mforward() returns a non-zero value, the packet
			 * must be discarded, else it may be accepted below.
			 *
			 * (The IP ident field is put in the same byte order
			 * as expected when ip_mforward() is called from
			 * ip_output().)
			 */
			ip->ip_id = htons(ip->ip_id);
			if (ip_mforward(ip, m->m_pkthdr.rcvif, m, 0) != 0) {
				ipstat.ips_cantforward++;
				m_freem(m);
				return;
			}
			ip->ip_id = ntohs(ip->ip_id);

			/*
			 * The process-level routing demon needs to receive
			 * all multicast IGMP packets, whether or not this
			 * host belongs to their destination groups.
			 */
			if (ip->ip_p == IPPROTO_IGMP)
				goto ours;
			ipstat.ips_forward++;
		}
		/*
		 * See if we belong to the destination multicast group on the
		 * arrival interface.
		 */
		IN_LOOKUP_MULTI(ip->ip_dst, m->m_pkthdr.rcvif, inm);
		if (inm == NULL) {
			ipstat.ips_notmember++;
			m_freem(m);
			return;
		}
		goto ours;
	}
#endif
	if (ip->ip_dst.s_addr == (u_long)INADDR_BROADCAST)
		goto ours;
	if (ip->ip_dst.s_addr == INADDR_ANY)
		goto ours;
#ifdef __riscos
	if (m->m_pkthdr.rcvif->if_flags & IFF_NEED_IPADDR)
		goto ours;
#endif

	/*
	 * Not for us; forward if possible and desirable.
	 */
	if (ipforwarding == 0) {
#ifdef DEBUG
		if (DODEBUG(DBGINPUT))
		    Printf("ipintr: can't forward\n");
#endif
		ipstat.ips_cantforward++;
		m_freem(m);
	} else {
#ifdef DEBUG
		if (DODEBUG(DBGINPUT))
			Printf("ipintr: forwarding packet\n");
#endif
		ip_forward(m, 0);
	}
	return;

ours:
	/*
	 * If offset or IP_MF are set, must reassemble.
	 * Otherwise, nothing need be done.
	 * (We could look in the reassembly queue to see
	 * if the packet was previously fragmented,
	 * but it's not worth the time; just let them time out.)
	 */
	if (ip->ip_off &~ IP_DF) {
#ifdef DEBUG
		if (DODEBUG(DBGINPUT))
	    		Printf("ipintr: frag\n");
#endif
#ifndef __riscos
		if (m->m_flags & M_EXT) {		/* XXX */
			if ((m = m_pullup(m, sizeof (struct ip))) == 0) {
				ipstat.ips_toosmall++;
				return;
			}
			ip = mtod(m, struct ip *);
		}
#endif
		/*
		 * Look for queue of fragments
		 * of this datagram.
		 */
		for (fp = ipq.next; fp != &ipq; fp = fp->next)
			if (ip->ip_id == fp->ipq_id &&
			    ip->ip_src.s_addr == fp->ipq_src.s_addr &&
			    ip->ip_dst.s_addr == fp->ipq_dst.s_addr &&
			    ip->ip_p == fp->ipq_p)
				goto found;
		fp = 0;
found:

		/*
		 * Adjust ip_len to not reflect header,
		 * set ip_mff if more fragments are expected,
		 * convert offset of this to bytes.
		 */
		ip->ip_len -= hlen;
		((struct ipasfrag *)ip)->ipf_mff &= ~1;
		if (ip->ip_off & IP_MF)
			((struct ipasfrag *)ip)->ipf_mff |= 1;
		ip->ip_off <<= 3;

		/*
		 * If datagram marked as having more fragments
		 * or if this is not the first fragment,
		 * attempt reassembly; if it succeeds, proceed.
		 */
		if (((struct ipasfrag *)ip)->ipf_mff & 1 || ip->ip_off) {
			ipstat.ips_fragments++;
			ip = ip_reass((struct ipasfrag *)ip, fp);
			if (ip == 0)
				return;
			ipstat.ips_reassembled++;
			m = dtom(ip);
		} else
			if (fp)
				ip_freef(fp);
	} else
		ip->ip_len -= hlen;

	/*
	 * Switch out to protocol's input routine.
	 */
#ifdef DEBUG
	if (DODEBUG(DBGINPUT))
	    Printf("ipintr: pass to proto %d\n", ip->ip_p);
#endif
	ipstat.ips_delivered++;
	(*inetsw[ip_protox[ip->ip_p]].pr_input)(m, hlen, ethersrc);
	return;
bad:
	m_freem(m);
}

/*
 * IP software interrupt routine - to go away sometime soon
 */
void
ipintr(void)
{
	int s;
	struct mbuf *m;

	while(1) {
		s = splimp();
		IF_DEQUEUE(&ipintrq, m);
		splx(s);
		if (m == 0)
			return;
		ip_input(m);
#if defined(__riscos) && defined(DELAY_EVENTS)
		/*
		 * Oh hacky hacky hack hack. If data's coming in fast then
		 * we need to let some signals (events) go off to give
		 * apps a chance to clear their buffers.
		 */
		sendallsignals();
#endif
	}
}

/*
 * Take incoming datagram fragment and try to
 * reassemble it into whole datagram.  If a chain for
 * reassembly of this datagram already exists, then it
 * is given as fp; otherwise have to make a chain.
 */
struct ip *
ip_reass(ip, fp)
	register struct ipasfrag *ip;
	register struct ipq *fp;
{
	register struct mbuf *m = DTOM(ip);
	register struct ipasfrag *q;
	struct mbuf *t;
	int hlen = ip->ip_hl << 2;
	int i, next;

	/*
	 * Presence of header sizes in mbufs
	 * would confuse code below.
	 */
	m->m_off += hlen;
	m->m_len -= hlen;

	/*
	 * If first fragment to arrive, create a reassembly queue.
	 */
	if (fp == 0) {
		if ((t = m_get(M_DONTWAIT, MT_FTABLE)) == NULL) {
#ifdef DEBUG
		    if( DODEBUG(DBGMMAN) )
			Printf("ip_reass: m_get failed\n");
#endif
		    goto dropfrag;
		}
		fp = mtod(t, struct ipq *);
		insque(fp, &ipq);
		fp->ipq_ttl = ipfragttl;
		fp->ipq_p = ip->ip_p;
		fp->ipq_id = ip->ip_id;
		fp->ipq_next = fp->ipq_prev = (struct ipasfrag *)fp;
		fp->ipq_src = ((struct ip *)ip)->ip_src;
		fp->ipq_dst = ((struct ip *)ip)->ip_dst;
		q = (struct ipasfrag *)fp;
		goto insert;
	}

	/*
	 * Find a segment which begins after this one does.
	 */
	for (q = fp->ipq_next; q != (struct ipasfrag *)fp; q = q->ipf_next)
		if (q->ip_off > ip->ip_off)
			break;

	/*
	 * If there is a preceding segment, it may provide some of
	 * our data already.  If so, drop the data from the incoming
	 * segment.  If it provides all of our data, drop us.
	 */
	if (q->ipf_prev != (struct ipasfrag *)fp) {
		i = q->ipf_prev->ip_off + q->ipf_prev->ip_len - ip->ip_off;
		if (i > 0) {
			if (i >= ip->ip_len)
				goto dropfrag;
			TRIM(DTOM(ip), i, NULL);
			ip->ip_off += i;
			ip->ip_len -= i;
		}
	}

	/*
	 * While we overlap succeeding segments trim them or,
	 * if they are completely covered, dequeue them.
	 */
	while (q != (struct ipasfrag *)fp && ip->ip_off + ip->ip_len > q->ip_off) {
		i = (ip->ip_off + ip->ip_len) - q->ip_off;
		if (i < q->ip_len) {
			q->ip_len -= i;
			q->ip_off += i;
			TRIM(DTOM(q), i, NULL);
			break;
		}
		q = q->ipf_next;
		DTOM_FREEM(q->ipf_prev);
		ip_deq(q->ipf_prev);
	}

insert:
	/*
	 * Stick new segment in its place;
	 * check for complete reassembly.
	 */
	ip_enq(ip, q->ipf_prev);
	next = 0;
	for (q = fp->ipq_next; q != (struct ipasfrag *)fp; q = q->ipf_next) {
		if (q->ip_off != next)
			return (0);
		next += q->ip_len;
	}
	if (q->ipf_prev->ipf_mff & 1)
		return (0);

	/*
	 * Reassembly is complete; concatenate fragments.
	 */
	q = fp->ipq_next;
	m = DTOM(q);
	t = m->m_next;
	m->m_next = 0;
	CAT(m, t);
	q = q->ipf_next;
	while (q != (struct ipasfrag *)fp) {
		t = DTOM(q);
		q = q->ipf_next;
		CAT(m, t);
	}

	/*
	 * Create header for new ip packet by
	 * modifying header of first packet;
	 * dequeue and discard fragment reassembly header.
	 * Make header visible.
	 */
	ip = fp->ipq_next;
	ip->ip_len = next;
	ip->ipf_mff &= ~1;
	((struct ip *)ip)->ip_src = fp->ipq_src;
	((struct ip *)ip)->ip_dst = fp->ipq_dst;
	remque(fp);
	DTOM_FREE(fp);
	m = DTOM(ip);
	m->m_len += (ip->ip_hl << 2);
	m->m_off -= (ip->ip_hl << 2);
	/* some debugging cruft by sklower, below, will go away soon */
	if (m->m_flags & M_PKTHDR) { /* XXX this should be done elsewhere */
		register int plen = 0;
		for (t = m; m; m = m->m_next)
			plen += m->m_len;
		t->m_pkthdr.len = plen;
	}
	return ((struct ip *)ip);

dropfrag:
	ipstat.ips_fragdropped++;
	m_freem(m);
	return (0);
}

/*
 * Free a fragment reassembly header and all
 * associated datagrams.
 */
void
ip_freef(fp)
	struct ipq *fp;
{
	register struct ipasfrag *q, *p;

	for (q = fp->ipq_next; q != (struct ipasfrag *)fp; q = p) {
		p = q->ipf_next;
		ip_deq(q);
		DTOM_FREEM(q);
	}
	remque(fp);
	DTOM_FREE(fp);
}

/*
 * Put an ip fragment on a reassembly chain.
 * Like insque, but pointers in middle of structure.
 */
void
ip_enq(p, prev)
	register struct ipasfrag *p, *prev;
{

	p->ipf_prev = prev;
	p->ipf_next = prev->ipf_next;
	prev->ipf_next->ipf_prev = p;
	prev->ipf_next = p;
}

/*
 * To ip_enq as remque is to insque.
 */
void
ip_deq(p)
	register struct ipasfrag *p;
{

	p->ipf_prev->ipf_next = p->ipf_next;
	p->ipf_next->ipf_prev = p->ipf_prev;
}

/*
 * IP timer processing;
 * if a timer expires on a reassembly
 * queue, discard it.
 */
void
ip_slowtimo()
{
	register struct ipq *fp;
	func_splhi();

	fp = ipq.next;
	if (fp == 0) {
		func_splx();
		return;
	}
	while (fp != &ipq) {
		--fp->ipq_ttl;
		fp = fp->next;
		if (fp->prev->ipq_ttl == 0) {
			ipstat.ips_fragtimeout++;
			ip_freef(fp->prev);
		}
	}
	func_splrestore();
}

/*
 * Drain off all datagram fragments.
 */
void
ip_drain()
{

	while (ipq.next != &ipq) {
		ipstat.ips_fragdropped++;
		ip_freef(ipq.next);
	}
}


/*
 * Do option processing on a datagram,
 * possibly discarding it if bad options
 * are encountered.
 */
int
ip_dooptions(m)
	struct mbuf *m;
{
	register struct ip *ip = mtod(m, struct ip *);
	register u_char *cp;
	register struct ip_timestamp *ipt;
	register struct in_ifaddr *ia;
	int opt, optlen, cnt, off, code, type = ICMP_PARAMPROB, forward = 0;
	struct in_addr *sin, dst;
	n_time ntime;

	dst = ip->ip_dst;
	cp = (u_char *)(ip + 1);
	cnt = (ip->ip_hl << 2) - sizeof (struct ip);
	for (; cnt > 0; cnt -= optlen, cp += optlen) {
		opt = cp[IPOPT_OPTVAL];
		if (opt == IPOPT_EOL)
			break;
		if (opt == IPOPT_NOP)
			optlen = 1;
		else {
			optlen = cp[IPOPT_OLEN];
			if (optlen <= 0 || optlen > cnt) {
				code = &cp[IPOPT_OLEN] - (u_char *)ip;
				goto bad;
			}
		}
		switch (opt) {

		default:
			break;

		/*
		 * Source routing with record.
		 * Find interface with current destination address.
		 * If none on this machine then drop if strictly routed,
		 * or do nothing if loosely routed.
		 * Record interface address and bring up next address
		 * component.  If strictly routed make sure next
		 * address on directly accessible net.
		 */
		case IPOPT_LSRR:
		case IPOPT_SSRR:
			if ((off = cp[IPOPT_OFFSET]) < IPOPT_MINOFF) {
				code = &cp[IPOPT_OFFSET] - (u_char *)ip;
				goto bad;
			}
			ipaddr.sin_addr = ip->ip_dst;
			ia = (struct in_ifaddr *)
				ifa_ifwithaddr((struct sockaddr *)&ipaddr);
			if (ia == 0) {
				if (opt == IPOPT_SSRR) {
					type = ICMP_UNREACH;
					code = ICMP_UNREACH_SRCFAIL;
					goto bad;
				}
				/*
				 * Loose routing, and not at next destination
				 * yet; nothing to do except forward.
				 */
				break;
			}
			off--;			/* 0 origin */
			if (off > optlen - sizeof(struct in_addr)) {
				/*
				 * End of source route.	 Should be for us.
				 */
				save_rte(cp, ip->ip_src);
				break;
			}
			if (!ip_dosourceroute) {
				char buf[4*sizeof "123"];
				strcpy(buf, inet_ntoa(ip->ip_dst));

#ifdef DEBUG
				Printf(
				    "attempted source route from %s to %s\n",
				    inet_ntoa(ip->ip_src), buf);
#endif
				type = ICMP_UNREACH;
				code = ICMP_UNREACH_SRCFAIL;
				goto bad;
			}
			/*
			 * locate outgoing interface
			 */
			(void)memcpy(&ipaddr.sin_addr, cp + off,
			    sizeof(ipaddr.sin_addr));

			if (opt == IPOPT_SSRR) {
#define	INA	struct in_ifaddr *
#define	SA	struct sockaddr *
			    if ((ia = (INA)ifa_ifwithdstaddr((SA)&ipaddr)) == 0)
			        ia = (INA)ifa_ifwithnet((SA)&ipaddr);
			} else
				ia = ip_rtaddr(ipaddr.sin_addr);
			if (ia == 0) {
				type = ICMP_UNREACH;
				code = ICMP_UNREACH_SRCFAIL;
				goto bad;
			}
			ip->ip_dst = ipaddr.sin_addr;
			(void)memcpy(cp + off, &(IA_SIN(ia)->sin_addr),
			    sizeof(struct in_addr));
			cp[IPOPT_OFFSET] += sizeof(struct in_addr);
			/*
			 * Let ip_intr's mcast routing check handle mcast pkts
			 */
			forward = !IN_MULTICAST(ntohl(ip->ip_dst.s_addr));
			break;

		case IPOPT_RR:
			if ((off = cp[IPOPT_OFFSET]) < IPOPT_MINOFF) {
				code = &cp[IPOPT_OFFSET] - (u_char *)ip;
				goto bad;
			}
			/*
			 * If no space remains, ignore.
			 */
			off--;			/* 0 origin */
			if (off > optlen - sizeof(struct in_addr))
				break;
			(void)memcpy(&ipaddr.sin_addr, &ip->ip_dst,
			    sizeof(ipaddr.sin_addr));
			/*
			 * locate outgoing interface; if we're the destination,
			 * use the incoming interface (should be same).
			 */
			if ((ia = (INA)ifa_ifwithaddr((SA)&ipaddr)) == 0 &&
			    (ia = ip_rtaddr(ipaddr.sin_addr)) == 0) {
				type = ICMP_UNREACH;
				code = ICMP_UNREACH_HOST;
				goto bad;
			}
			(void)memcpy(cp + off, &(IA_SIN(ia)->sin_addr),
			    sizeof(struct in_addr));
			cp[IPOPT_OFFSET] += sizeof(struct in_addr);
			break;

		case IPOPT_TS:
			code = cp - (u_char *)ip;
			ipt = (struct ip_timestamp *)cp;
			if (ipt->ipt_len < 5)
				goto bad;
			if (ipt->ipt_ptr > ipt->ipt_len - sizeof (long)) {
				if (++ipt->ipt_oflw == 0)
					goto bad;
				break;
			}
			sin = (struct in_addr *)(cp + ipt->ipt_ptr - 1);
			switch (ipt->ipt_flg) {

			case IPOPT_TS_TSONLY:
				break;

			case IPOPT_TS_TSANDADDR:
				if (ipt->ipt_ptr + sizeof(n_time) +
				    sizeof(struct in_addr) > ipt->ipt_len)
					goto bad;
				ipaddr.sin_addr = dst;
				ia = (INA)ifaof_ifpforaddr((SA)&ipaddr,
							   m->m_pkthdr.rcvif);
				if (ia == 0)
					continue;
				(void)memcpy(sin, &IA_SIN(ia)->sin_addr,
				    sizeof(struct in_addr));
				ipt->ipt_ptr += sizeof(struct in_addr);
				break;

			case IPOPT_TS_PRESPEC:
				if (ipt->ipt_ptr + sizeof(n_time) +
				    sizeof(struct in_addr) > ipt->ipt_len)
					goto bad;
				(void)memcpy(&ipaddr.sin_addr, sin,
				    sizeof(struct in_addr));
				if (ifa_ifwithaddr((SA)&ipaddr) == 0)
					continue;
				ipt->ipt_ptr += sizeof(struct in_addr);
				break;

			default:
				goto bad;
			}
			ntime = iptime();
			(void)memcpy(cp + ipt->ipt_ptr - 1, &ntime,
			    sizeof(n_time));
			ipt->ipt_ptr += sizeof(n_time);
		}
	}
	if (forward) {
		ip_forward(m, 1);
		return (1);
	}
	return (0);
bad:
	ip->ip_len -= ip->ip_hl << 2;   /* XXX icmp_error adds in hdr length */
	icmp_error(m, type, code, 0, 0);
	ipstat.ips_badoptions++;
	return (1);
}

/*
 * Given address of next destination (final or next hop),
 * return internet address info of interface to be used to get there.
 */
struct in_ifaddr *
ip_rtaddr(dst)
	 struct in_addr dst;
{
	register struct sockaddr_in *sin;

	sin = (struct sockaddr_in *) &ipforward_rt.ro_dst;

	if (ipforward_rt.ro_rt == 0 || dst.s_addr != sin->sin_addr.s_addr) {
		if (ipforward_rt.ro_rt) {
			RTFREE(ipforward_rt.ro_rt);
			ipforward_rt.ro_rt = 0;
		}
		sin->sin_family = AF_INET;
		sin->sin_len = sizeof(*sin);
		sin->sin_addr = dst;

		rtalloc_ign(&ipforward_rt, RTF_PRCLONING);
	}
	if (ipforward_rt.ro_rt == 0)
		return ((struct in_ifaddr *)0);
	return ((struct in_ifaddr *) ipforward_rt.ro_rt->rt_ifa);
}

/*
 * Save incoming source route for use in replies,
 * to be picked up later by ip_srcroute if the receiver is interested.
 */
void
save_rte(option, dst)
	u_char *option;
	struct in_addr dst;
{
	unsigned olen;

	olen = option[IPOPT_OLEN];
#ifdef DIAGNOSTIC
	if (ipprintfs)
		printf("save_rte: olen %d\n", olen);
#endif
	if (olen > sizeof(ip_srcrt) - (1 + sizeof(dst)))
		return;
	(void)memcpy(ip_srcrt.srcopt, option, olen);
	ip_nhops = (olen - IPOPT_OFFSET - 1) / sizeof(struct in_addr);
	ip_srcrt.dst = dst;
}

/*
 * Retrieve incoming source route for use in replies,
 * in the same form used by setsockopt.
 * The first hop is placed before the options, will be removed later.
 */
struct mbuf *
ip_srcroute()
{
	register struct in_addr *p, *q;
	register struct mbuf *m;

	if (ip_nhops == 0)
		return ((struct mbuf *)0);
	m = ALLOC_S(MINCONTIG, NULL);
	if (m == 0) {
#ifdef DEBUG
	    if( DODEBUG(DBGMMAN) )
		Printf("ip_srcroute: ALLOC_S failed\n");
#endif
	    return ((struct mbuf *)0);
	}
	m->m_type = MT_SOOPTS;

#define OPTSIZ	(sizeof(ip_srcrt.nop) + sizeof(ip_srcrt.srcopt))

	/* length is (nhops+1)*sizeof(addr) + sizeof(nop + srcrt header) */
	m->m_len = ip_nhops * sizeof(struct in_addr) + sizeof(struct in_addr) +
	    OPTSIZ;
#ifdef DIAGNOSTIC
	if (ipprintfs)
		printf("ip_srcroute: nhops %d mlen %d", ip_nhops, m->m_len);
#endif

	/*
	 * First save first hop for return route
	 */
	p = &ip_srcrt.route[ip_nhops - 1];
	*(mtod(m, struct in_addr *)) = *p--;
#ifdef DIAGNOSTIC
	if (ipprintfs)
		printf(" hops %lx", (u_long)ntohl(mtod(m, struct in_addr *)->s_addr));
#endif

	/*
	 * Copy option fields and padding (nop) to mbuf.
	 */
	ip_srcrt.nop = IPOPT_NOP;
	ip_srcrt.srcopt[IPOPT_OFFSET] = IPOPT_MINOFF;
	(void)memcpy(mtod(m, caddr_t) + sizeof(struct in_addr),
	    &ip_srcrt.nop, OPTSIZ);
	q = (struct in_addr *)(mtod(m, caddr_t) +
	    sizeof(struct in_addr) + OPTSIZ);
#undef OPTSIZ
	/*
	 * Record return path as an IP source route,
	 * reversing the path (pointers are now aligned).
	 */
	while (p >= ip_srcrt.route) {
#ifdef DIAGNOSTIC
		if (ipprintfs)
			printf(" %lx", (u_long)ntohl(q->s_addr));
#endif
		*q++ = *p--;
	}
	/*
	 * Last hop goes to final destination.
	 */
	*q = ip_srcrt.dst;
#ifdef DIAGNOSTIC
	if (ipprintfs)
		printf(" %lx\n", (u_long)ntohl(q->s_addr));
#endif
	return (m);
}

/*
 * Strip out IP options, at higher
 * level protocol in the kernel.
 * Second argument is buffer to which options
 * will be moved, and return value is their length.
 * XXX should be deleted; last arg currently ignored.
 */
void
ip_stripoptions(m, mopt)
	register struct mbuf *m;
	struct mbuf *mopt;
{
	register int i;
	struct ip *ip = mtod(m, struct ip *);
	register caddr_t opts;
	int olen;

	olen = (ip->ip_hl<<2) - sizeof (struct ip);
	opts = (caddr_t)(ip + 1);
	i = m->m_len - (sizeof (struct ip) + olen);
	bcopy(opts + olen, opts, (unsigned)i);
	m->m_len -= olen;
#ifndef __riscos
	if (m->m_flags & M_PKTHDR)
		m->m_pkthdr.len -= olen;
#endif
	ip->ip_hl = sizeof(struct ip) >> 2;
#ifdef OldCodeWhy
	if (mopt) {
		/*
		 * XXX TRACE XXX
		 *
		 * is there a more efficient way to do this?
		 */
		mopt->m_len = olen;
		mopt->m_off = MINOFF(mopt);
		bcopy(opts, mtod(mopt, caddr_t), (unsigned)olen);
	}
	i = m->m_len - (sizeof (struct ip) + olen);
	bcopy(opts  + olen, opts, (unsigned)i);
	m->m_len -= olen;
#endif
	ip->ip_hl = sizeof(struct ip) >> 2;
}

u_char inetctlerrmap[PRC_NCMDS] = {
	0,		0,		0,		0,
	0,		EMSGSIZE,	EHOSTDOWN,	EHOSTUNREACH,
	ENETUNREACH,	EHOSTUNREACH,	ECONNREFUSED,	ECONNREFUSED,
	EMSGSIZE,	EHOSTUNREACH,	0,		0,
	0,		0,		0,		0,
	ENOPROTOOPT
};

/*
 * Forward a packet.  If some error occurs return the sender
 * an icmp packet.  Note we can't always generate a meaningful
 * icmp message because icmp doesn't have a large enough repertoire
 * of codes and types.
 *
 * If not forwarding, just drop the packet.  This could be confusing
 * if ipforwarding was zero but some routing protocol was advancing
 * us as a gateway to somewhere.  However, we must let the routing
 * protocol deal with that.
 *
 * The srcrt parameter indicates whether the packet is being forwarded
 * via a source route.
 */
void
ip_forward(m, srcrt)
	struct mbuf *m;
	int srcrt;
{
	register struct ip *ip = mtod(m, struct ip *);
	register struct sockaddr_in *sin;
	register struct rtentry *rt;
	int error, type = 0, code = 0;
	struct mbuf *mcopy;
	n_long dest;
	struct ifnet *destifp;

	dest = 0;
#ifdef DIAGNOSTIC
	if (ipprintfs)
		printf("forward: src %x dst %x ttl %x\n",
			ip->ip_src.s_addr, ip->ip_dst.s_addr, ip->ip_ttl);
#endif

	if (m->m_flags & M_BCAST || in_canforward(ip->ip_dst) == 0) {
		ipstat.ips_cantforward++;
		m_freem(m);
		return;
	}
	HTONS(ip->ip_id);
	if (ip->ip_ttl <= IPTTLDEC) {
		icmp_error(m, ICMP_TIMXCEED, ICMP_TIMXCEED_INTRANS, dest, 0);
		return;
	}
	ip->ip_ttl -= IPTTLDEC;

	sin = (struct sockaddr_in *)&ipforward_rt.ro_dst;
	if ((rt = ipforward_rt.ro_rt) == 0 ||
	    ip->ip_dst.s_addr != sin->sin_addr.s_addr) {
		if (ipforward_rt.ro_rt) {
			RTFREE(ipforward_rt.ro_rt);
			ipforward_rt.ro_rt = 0;
		}
		sin->sin_family = AF_INET;
		sin->sin_len = sizeof(*sin);
		sin->sin_addr = ip->ip_dst;

		rtalloc_ign(&ipforward_rt, RTF_PRCLONING);
		if (ipforward_rt.ro_rt == 0) {
			icmp_error(m, ICMP_UNREACH, ICMP_UNREACH_HOST, dest, 0);
			return;
		}
		rt = ipforward_rt.ro_rt;
	}

	/*
	 * Save at most 64 bytes of the packet in case
	 * we need to generate an ICMP message to the src.
	 */
	mcopy = m_copy(m, 0, imin((int)ip->ip_len, 64));

	/*
	 * If forwarding packet using same interface that it came in on,
	 * perhaps should send a redirect to sender to shortcut a hop.
	 * Only send redirect if source is sending directly to us,
	 * and if packet was not source routed (or has any options).
	 * Also, don't send redirect if forwarding using a default route
	 * or a route modfied by a redirect.
	 */
#define satosin(sa)	((struct sockaddr_in *)(sa))
	if (rt->rt_ifp == m->m_pkthdr.rcvif &&
	    (rt->rt_flags & (RTF_DYNAMIC|RTF_MODIFIED)) == 0 &&
	    satosin(rt_key(rt))->sin_addr.s_addr != 0 &&
	    ipsendredirects && !srcrt) {
#define	RTA(rt)	((struct in_ifaddr *)(rt->rt_ifa))
		u_long src = ntohl(ip->ip_src.s_addr);

		if (RTA(rt) &&
		    (src & RTA(rt)->ia_subnetmask) == RTA(rt)->ia_subnet) {
		    if (rt->rt_flags & RTF_GATEWAY)
			dest = satosin(rt->rt_gateway)->sin_addr.s_addr;
		    else
			dest = ip->ip_dst.s_addr;
		    /* Router requirements says to only send host redirects */
		    type = ICMP_REDIRECT;
		    code = ICMP_REDIRECT_HOST;
#ifdef DIAGNOSTIC
		    if (ipprintfs)
			printf("redirect (%d) to %x\n", code, (u_long)dest);
#endif
		}
	}

	error = ip_output(m, (struct mbuf *)0, &ipforward_rt, IP_FORWARDING
#ifdef DIRECTED_BROADCAST
			    | IP_ALLOWBROADCAST
#endif
						, 0);
	if (error)
		ipstat.ips_cantforward++;
	else {
		ipstat.ips_forward++;
		if (type)
			ipstat.ips_redirectsent++;
		else {
			if (mcopy)
				m_freem(mcopy);
			return;
		}
	}
	if (mcopy == NULL)
		return;
	destifp = NULL;

	switch (error) {

	case 0:				/* forwarded, but need redirect */
		/* type, code set above */
		break;

	case ENETUNREACH:		/* shouldn't happen, checked above */
	case EHOSTUNREACH:
	case ENETDOWN:
	case EHOSTDOWN:
	default:
		type = ICMP_UNREACH;
		code = ICMP_UNREACH_HOST;
		break;

	case EMSGSIZE:
		type = ICMP_UNREACH;
		code = ICMP_UNREACH_NEEDFRAG;
		if (ipforward_rt.ro_rt)
			destifp = ipforward_rt.ro_rt->rt_ifp;
		ipstat.ips_cantfrag++;
		break;

	case ENOBUFS:
		type = ICMP_SOURCEQUENCH;
		code = 0;
		break;
	}
	icmp_error(mcopy, type, code, dest, destifp);
}

void
ip_savecontrol(inp, mp, ip, m)
	register struct inpcb *inp;
	register struct mbuf **mp;
	register struct ip *ip;
	register struct mbuf *m;
{
	if (inp->inp_socket->so_options & SO_TIMESTAMP) {
		struct timeval tv;

		microtime(&tv);
		*mp = sbcreatecontrol((caddr_t) &tv, sizeof(tv),
			SCM_TIMESTAMP, SOL_SOCKET);
		if (*mp)
			mp = &(*mp)->m_next;
	}
	if (inp->inp_flags & INP_RECVDSTADDR) {
		*mp = sbcreatecontrol((caddr_t) &ip->ip_dst,
		    sizeof(struct in_addr), IP_RECVDSTADDR, IPPROTO_IP);
		if (*mp)
			mp = &(*mp)->m_next;
	}
#ifdef notyet
	/* XXX
	 * Moving these out of udp_input() made them even more broken
	 * than they already were.
	 */
	/* options were tossed already */
	if (inp->inp_flags & INP_RECVOPTS) {
		*mp = sbcreatecontrol((caddr_t) opts_deleted_above,
		    sizeof(struct in_addr), IP_RECVOPTS, IPPROTO_IP);
		if (*mp)
			mp = &(*mp)->m_next;
	}
	/* ip_srcroute doesn't do what we want here, need to fix */
	if (inp->inp_flags & INP_RECVRETOPTS) {
		*mp = sbcreatecontrol((caddr_t) ip_srcroute(),
		    sizeof(struct in_addr), IP_RECVRETOPTS, IPPROTO_IP);
		if (*mp)
			mp = &(*mp)->m_next;
	}
#endif
	if (inp->inp_flags & INP_RECVIF) {
		struct ifnet *ifp;
		struct sdlbuf {
			struct sockaddr_dl sdl;
			u_char	pad[32];
		} sdlbuf;
		struct sockaddr_dl *sdp;
		struct sockaddr_dl *sdl2 = &sdlbuf.sdl;

		if (((ifp = m->m_pkthdr.rcvif))
		&& ( ifp->if_index && (ifp->if_index <= if_index))) {
			sdp = (struct sockaddr_dl *)(ifnet_addrs
					[ifp->if_index - 1]->ifa_addr);
			/*
			 * Change our mind and don't try copy.
			 */
			if ((sdp->sdl_family != AF_LINK)
			|| (sdp->sdl_len > sizeof(sdlbuf))) {
				goto makedummy;
			}
			bcopy(sdp, sdl2, sdp->sdl_len);
		} else {
makedummy:
			sdl2->sdl_len
				= offsetof(struct sockaddr_dl, sdl_data[0]);
			sdl2->sdl_family = AF_LINK;
			sdl2->sdl_index = 0;
			sdl2->sdl_nlen = sdl2->sdl_alen = sdl2->sdl_slen = 0;
		}
		*mp = sbcreatecontrol((caddr_t) sdl2, sdl2->sdl_len,
			IP_RECVIF, IPPROTO_IP);
		if (*mp)
			mp = &(*mp)->m_next;
	}
}

int
ip_rsvp_init(struct socket *so)
{
	if (so->so_type != SOCK_RAW ||
	    so->so_proto->pr_protocol != IPPROTO_RSVP)
	  return EOPNOTSUPP;

	if (ip_rsvpd != NULL)
	  return EADDRINUSE;

	ip_rsvpd = so;
	/*
	 * This may seem silly, but we need to be sure we don't over-increment
	 * the RSVP counter, in case something slips up.
	 */
	if (!ip_rsvp_on) {
		ip_rsvp_on = 1;
		rsvp_on++;
	}

	return 0;
}

int
ip_rsvp_done(void)
{
	ip_rsvpd = NULL;
	/*
	 * This may seem silly, but we need to be sure we don't over-decrement
	 * the RSVP counter, in case something slips up.
	 */
	if (ip_rsvp_on) {
		ip_rsvp_on = 0;
		rsvp_on--;
	}
	return 0;
}
@


4.9
log
@32-bit code modified to use new macros, plus a couple of fixes.
A (tiny) checksumming speed-up, courtesy of David Seal.

Version 5.41. Tagged as 'Internet-5_41'
@
text
@d530 8
@


4.8
log
@microtime() now returns microsecond accuracy.
Random number generator now seeded from microtime(), machine ID and
hardware addresses of DCI drivers.
Some previously untested debugging code fixed to compile.

Version 5.34. Tagged as 'Internet-5_34'
@
text
@a159 1
#ifndef __riscos
a160 3
#else
	ipintrq.ifq_maxlen = 0; /* Allow use as a high water mark counter */
#endif
@


4.7
log
@Added new FreeBSD sysctl handling using linker magic.
A few new sysctls added as a result.
SO_TIMESTAMP now gives real time, not Internet's internal time.
DHCP/BOOTP parsing picks up URL option and pops it into Inet$URL.
Requires TCPIPLibs 5.25 and link 5.12.

Version 5.31. Tagged as 'Internet-5_31'
@
text
@d1070 1
a1070 1
		printf(" hops %X", ntohl(*mtod(m, struct in_addr *)));
d1090 1
a1090 1
			printf(" %X", ntohl(*q));
d1100 1
a1100 1
		printf(" %X\n", ntohl(q->s_addr));
a1323 3
#ifdef __riscos
		tv.tv_sec = realtime(&tv.tv_usec);
#else
a1324 1
#endif
@


4.6
log
@* Dynamic ports now assigned in range 49152-65535.
* IP_RECVDSTADDR works for non-unicast packets.
* SO_TIMESTAMP added.
* IP_RECVIF added.
* Various other internal changes merged in from FreeBSD sources.

Version 5.29. Tagged as 'Internet-5_29'
@
text
@a74 11
#ifndef IPFORWARDING
#ifdef GATEWAY
#define IPFORWARDING	1
#else /* GATEWAY */
#define IPFORWARDING	0
#endif /* GATEWAY */
#endif /* IPFORWARDING */
#ifndef IPSENDREDIRECTS
#define IPSENDREDIRECTS 1
#endif
#ifdef __riscos
d76 7
a82 4
#else
int	ipforwarding = IPFORWARDING;
#endif /* __riscos */
int	ipsendredirects = IPSENDREDIRECTS;
d84 11
a94 1
int	ip_dosourceroute = 0;
d105 4
d111 3
d175 3
d1324 3
d1328 1
a1393 60
}

int
ip_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case IPCTL_FORWARDING:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ipforwarding));
	case IPCTL_SENDREDIRECTS:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
			&ipsendredirects));
	case IPCTL_DEFTTL:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ip_defttl));
	case IPCTL_SOURCEROUTE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ip_dosourceroute));
#ifdef notyet
	case IPCTL_DEFMTU:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ip_mtu));
#endif
	case IPCTL_RTEXPIRE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &rtq_reallyold));
	case IPCTL_RTMINEXPIRE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &rtq_minreallyold));
	case IPCTL_RTMAXCACHE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &rtq_toomany));
	/* CE - 981128 : Allow read-only access to maxlen, since I'm using it to      *
	 *               monitor the maximum attained length of the queue             *
	 * KJB - 981127: Removed again, because the queue length is no longer         *
	 *               enforced; see riscos/module.c.                               *
	 * CE - 981126 : Added following 2 items to enable tracking of performance of *
	 *               interrupt/callback driven enqueueing and dequeueing system   *
	 *               These are read-only in BSD, but I can't see any good reason  *
	 *               for their being so (except maybe for the drop count...       */
	case IPCTL_INTRQMAXLEN:
		return (sysctl_rdint(oldp, oldlenp, newp, ipintrq.ifq_maxlen));
#ifndef __riscos
	case IPCTL_INTRQDROPS:
		return (sysctl_rdint(oldp, oldlenp, newp, ipintrq.ifq_drops));
#endif
	case IPCTL_FRAGTTL:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ipfragttl));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
@


4.5
log
@Enabled usage of interrupt queue maxlen variable as a high water mark
counter on the interrupt/callback buffer queue, so as to enable
monitoring of whether this is the cause of possible mbuf exhaustions,
given that this queue length is now limited only by the case of system
resource depletion.

Version 5.18. Tagged as 'Internet-5_18'
@
text
@d35 1
a35 1
#include "kernel.h"
d37 25
a61 23
#include "sys/param.h"
#include "sys/systm.h"
#include "sys/time.h"
#include "sys/mbuf.h"
#include "sys/kernel.h"
#include "sys/domain.h"
#include "sys/protosw.h"
#include "sys/socket.h"
#include "sys/errno.h"
#include "sys/sysctl.h"
#include "sys/dcistructs.h"

#include "net/if.h"
#include "net/route.h"

#include "netinet/in.h"
#include "netinet/in_systm.h"
#include "netinet/in_var.h"
#include "netinet/ip.h"
#include "netinet/in_pcb.h"
#include "netinet/ip_var.h"
#include "netinet/ip_icmp.h"
#include "netinet/tcp.h"
d63 1
a63 1
#include "sys/socketvar.h"
d65 1
a65 1
#include "machine/in_cksum.h"
a389 1
		 * Changed to record in ips_notmember (not ips_cantforward) CE - 981125
d1300 78
@


4.4
log
@Removed limitation on length of IP interrupt queue, and made psignal
generate events immediately, rather than at the end of callbacks.
In both respects, the behaviour is restored to that of Internet 4. This
fixes some performance problems with data streaming near the limit of the
machine's capability.

Version 5.17. Tagged as 'Internet-5_17'
@
text
@d149 1
d151 3
d1338 3
a1340 2
#ifndef __riscos
	/* KJB - 981127: Removed again, because the queue length is no longer         *
d1347 2
a1348 2
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ipintrq.ifq_maxlen));
@


4.3
log
@Makefile: added *access command to end of build sequence.
riscos/module.c: closed a free then dereference hole.
netinet/ip_input.c: added additional stats collection and ability to change
                    size of interrupt process receive queue limit.
This must be built against a set of TCPIPLibs of 5.03 or later, otherwise
the added stats collection will fault.

Version 5.16. Tagged as 'Internet-5_16'
@
text
@d1334 4
a1337 1
	/* CE - 981126 : Added following 2 items to enable tracking of performance of *
d1346 1
@


4.2
log
@Version Spinner_B7 taken
@
text
@d384 1
d388 1
a388 1
			ipstat.ips_cantforward++;
d1334 9
@


4.1
log
@Initial revision
@
text
@d1 3
a3 1
/* -*-C-*-
d5 15
a19 2
 * $Header: /ax/networking:Internet/netinet/ip_input.c:networking  1.4  $
 * $Source: /ax/networking:Internet/netinet/ip_input.c: $
d21 11
a31 31
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
 *
 * $Log:	ip_input.c,v $
 * Revision 1.4  95/03/31  11:55:22  kwelton
 * Put a load of debugging messages into ipintr().
 * 
 * Revision 1.3  95/03/13  16:11:01  aideen
 * Default is to have UDP checksums disabled.
 * 
 * Revision 1.2  95/03/10  17:30:02  kwelton
 * Default is to have IP checksums enabled.
 * 
 * Revision 1.1  94/12/02  11:17:44  kwelton
 * Initial revision
 * 
 */
/*
 * Copyright (c) 1983, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d34 1
d41 1
d46 2
a52 1
#include "netinet/in_pcb.h"
d56 1
d61 4
d67 5
a82 1
int	ipprintfs = 0;
d87 1
a87 2
#endif __riscos
extern	int in_interfaces;
d89 5
d95 3
a97 1
u_char	ip_protox[IPPROTO_MAX] = { 0 };
d99 9
a107 1
extern struct  in_ifaddr *in_ifaddr;		       /* first inet address */
d122 1
a122 1
} ip_srcrt = { 0 };
d124 1
d129 1
a147 3
#ifdef __riscos
	ip_id = time(0) & 0xffff;
#else
a148 1
#endif
d150 3
d155 5
a159 4
u_char	ipcksum = 0;
struct	ip *ip_reass();
struct	sockaddr_in ipaddr = { AF_INET };
struct	route ipforward_rt = { 0 };
d164 1
a164 2
 * try to reassamble.  If complete and fragment queue exists, discard.
 * Process options.  Pass to next level.
d166 2
a167 1
ipintr(struct ifnet *ifp, struct mbuf *m, char *esrc)
d169 3
a171 5
	register struct ip *ip;
	struct mbuf *m0;
	register int i;
	register struct ipq *fp;
	register struct in_ifaddr *ia;
d173 5
d179 17
d200 1
a200 2
	if (in_ifaddr == NULL)
	{
d202 5
a206 2
	    if( DODEBUG(DBGINPUT) )
		Printf("ipintr: in_ifaddr not set!\n");
d208 1
a208 1
	    goto bad;
a209 1

d211 2
a212 1
	if (m->m_len < sizeof (struct ip)) {
a217 5
#ifdef OldCode
		m_freem(m);
#else
		FREEM(m);
#endif
d220 3
a222 13

	/*
	 * XXX
	 *
	 * under DCI 4, it is the job of the device driver to
	 * *ensure* that all supplied data is safe, so do not
	 * bother to check for indirected (i.e. unsafe) data
	 */
#ifdef DCI2
	if (m->m_indir) {
	    m0 = m_get(M_DONTWAIT, MT_DATA);
	    if (m0 == NULL) {
		ipstat.ips_fragdropped++;
a223 7
	    }
	    i = MIN(MLEN, m->m_len);
	    memcpy (mtod(m0, caddr_t), mtod(m, caddr_t), i);
	    m_adj(m, i);
	    m0->m_len = i;
	    m0->m_next = m;
	    m = m0;
a224 3
#endif /* DCI2 */

	ip = mtod(m, struct ip *);
d226 1
a226 1
	if (hlen < sizeof(struct ip) || hlen > m->m_len) {
d230 14
a243 1
	if (ipcksum && (ip->ip_sum = in_cksum(m, hlen))) {
d247 1
d251 1
a251 1
	ip->ip_len = ntohs((u_short)ip->ip_len);
d256 2
a257 2
	ip->ip_id = ntohs(ip->ip_id);
	ip->ip_off = ntohs((u_short)ip->ip_off);
d265 4
a268 6
#if defined(__arm)
	i = -ip->ip_len;
#elif defined(vax)
	i = -(u_short)ip->ip_len;
#else
	XYZABCDEF;
d270 20
d291 3
a293 12
	m0 = m;
	for (;;) {
		i += m->m_len;
		if (m->m_next == 0)
			break;
		m = m->m_next;
	}
	if (i != 0) {
		if (i < 0) {
#ifdef DEBUG
			if( DODEBUG(DBGINPUT) )
			    Printf("ipintr: i (%d) is < 0\n", i);
a294 16
			ipstat.ips_tooshort++;
			m = m0;
			goto bad;
		}
		if (i <= m->m_len)
			m->m_len -= i;
		else
		{
#ifdef OldCode
		    m_adj(m0, -i);
#else
		    TRIM(m0, -i, NULL);
#endif
		}
	}
	m = m0;
d298 1
a298 1
	 * ship it on.	ip_dooptions returns 1 when an
d303 1
a303 6
	if (hlen > sizeof (struct ip) && ip_dooptions(m, ifp))
	{
#ifdef DEBUG
	    if( DODEBUG(DBGINPUT) )
		Printf("ipintr: ip_dooptions barfed\n");
#endif
a304 1
	}
d306 8
a313 5
#ifdef __riscos
	if (onesbroadcast && ip->ip_dst.s_addr == 0xffffffff)
		goto ours;

	if (ifp->if_flags & IFF_NEED_IPADDR)
d321 1
a321 1
#define satosin(sa)	((struct sockaddr_in *)(sa))
d327 1
a327 1
		    ia->ia_ifp == ifp &&
d348 46
d398 4
d406 1
a406 5
	if (ipforwarding == 0
#ifndef GATEWAY
	    || in_interfaces <= 1
#endif
	    ) {
d408 1
a408 1
		if( DODEBUG(DBGINPUT) )
a411 1
#ifdef OldCode
d413 1
a413 6
#else
		FREEM(m);
#endif
	}
	else
	{
d415 2
a416 2
	    if (DODEBUG(DBGINPUT) )
		Printf("ipintr: forwarding packet\n");
d418 1
a418 1
	    ip_forward(m, ifp);
a419 1

a422 5
#ifdef DEBUG
	if (DODEBUG(DBGINPUT) )
	    Printf("ipintr: ours\n");
#endif
	    
d432 11
a442 2
	if (DODEBUG(DBGINPUT) )
	    Printf("ipintr: frag\n");
d456 1
d463 1
a463 1
		((struct ipasfrag *)ip)->ipf_mff = 0;
d465 1
a465 1
			((struct ipasfrag *)ip)->ipf_mff = 1;
d473 1
a473 1
		if (((struct ipasfrag *)ip)->ipf_mff || ip->ip_off) {
d478 1
a478 2

#ifdef OldCode
a479 3
#else
			m = DTOM(ip);
#endif
d490 1
a490 1
	if (DODEBUG(DBGINPUT) )
d493 2
a494 1
	(*inetsw[ip_protox[ip->ip_p]].pr_input)(m, ifp, esrc);
d496 12
d509 8
a516 7
      bad:
#ifdef OldCode
	m_freem(m);
#else
	FREEM(m);
#endif
	return;
a529 3
#ifdef OldCode
	register struct mbuf *m = dtom(ip);
#else
a530 1
#endif
d547 1
a547 6
#ifdef OldCode
		if ((t = m_get(M_DONTWAIT, MT_FTABLE)) == NULL)
			goto dropfrag;
#else
		if( (t = ALLOC_S(MINCONTIG, NULL)) == NULL )
		{
d550 1
a550 1
			Printf("ip_reass: ALLOC_S failed\n");
a553 3

		t->m_type = MT_FTABLE;
#endif
d556 1
a556 1
		fp->ipq_ttl = IPFRAGTTL;
a582 3
#ifdef OldCode
			m_adj(dtom(ip), i);
#else
a583 1
#endif
a597 3
#ifdef OldCode
			m_adj(dtom(q), i);
#else
a598 1
#endif
a601 3
#ifdef OldCode
		m_freem(dtom(q->ipf_prev));
#else
a602 1
#endif
d618 1
a618 1
	if (q->ipf_prev->ipf_mff)
a627 3
#ifdef OldCode
	m_cat(m, t);
#else
a628 1
#endif
a632 3
#ifdef OldCode
		m_cat(m, t);
#else
a633 1
#endif
d644 1
a647 4
#ifdef OldCode
	(void) m_free(dtom(fp));
	m = dtom(ip);
#else
a649 1
#endif
d652 7
a662 1
#ifdef OldCode
a663 3
#else
	FREEM(m);
#endif
d671 1
a679 3
#ifdef OldCode
		m_freem(dtom(q));
#else
a680 1
#endif
a682 3
#ifdef OldCode
	(void) m_free(dtom(fp));
#else
a683 1
#endif
d690 1
d704 1
d718 1
d722 1
a722 1
	int s = splhi();
d726 1
a726 1
		splx(s);
d737 1
a737 1
	splrestore(s);
d743 1
a752 2
extern struct in_ifaddr *ifptoia();
struct in_ifaddr *ip_rtaddr();
d759 2
a760 1
ip_dooptions(m, ifp)
a761 1
	struct ifnet *ifp;
d768 1
a768 1
	struct in_addr *sin;
d771 1
d830 13
d846 1
a846 1
			bcopy((caddr_t)(cp + off), (caddr_t)&ipaddr.sin_addr,
d848 9
a856 3
			if ((opt == IPOPT_SSRR &&
			    in_iaonnetof(in_netof(ipaddr.sin_addr)) == 0) ||
			    (ia = ip_rtaddr(ipaddr.sin_addr)) == 0) {
d862 2
a863 2
			bcopy((caddr_t)&(IA_SIN(ia)->sin_addr),
			    (caddr_t)(cp + off), sizeof(struct in_addr));
d865 4
a868 1
			forward = 1;
d882 1
a882 1
			bcopy((caddr_t)(&ip->ip_dst), (caddr_t)&ipaddr.sin_addr,
d885 2
a886 1
			 * locate outgoing interface
d888 2
a889 1
			if ((ia = ip_rtaddr(ipaddr.sin_addr)) == 0) {
d894 2
a895 2
			bcopy((caddr_t)&(IA_SIN(ia)->sin_addr),
			    (caddr_t)(cp + off), sizeof(struct in_addr));
d919 7
a925 3
				ia = ifptoia(ifp);
				bcopy((caddr_t)&IA_SIN(ia)->sin_addr,
				    (caddr_t)sin, sizeof(struct in_addr));
d933 1
a933 1
				bcopy((caddr_t)sin, (caddr_t)&ipaddr.sin_addr,
d935 1
a935 1
				if (ifa_ifwithaddr((struct sockaddr *)&ipaddr) == 0)
d944 1
a944 1
			bcopy((caddr_t)&ntime, (caddr_t)cp + ipt->ipt_ptr - 1,
d950 1
a950 1
		ip_forward(m, ifp);
d952 2
a953 2
	} else
		return (0);
d955 3
a957 1
	icmp_error(ip, type, code, ifp);
a969 1
	register struct in_ifaddr *ia;
d979 1
d982 1
a982 1
		rtalloc(&ipforward_rt);
d986 1
a986 7
	/*
	 * Find address associated with outgoing interface.
	 */
	for (ia = in_ifaddr; ia; ia = ia->ia_next)
		if (ia->ia_ifp == ipforward_rt.ro_rt->rt_ifp)
			break;
	return (ia);
d993 1
d1001 1
d1004 1
d1007 1
a1007 1
	bcopy((caddr_t)option, (caddr_t)ip_srcrt.srcopt, olen);
d1025 2
a1026 7
#ifdef OldCode
	m = m_get(M_DONTWAIT, MT_SOOPTS);
	if (m == 0)
		return ((struct mbuf *)0);
#else
	if( (m = ALLOC_S(MINCONTIG, NULL)) == NULL )
	{
d1031 1
a1031 1
	    return(NULL);
a1032 1

a1033 1
#endif
d1040 1
d1043 1
d1050 1
d1053 1
d1060 2
a1061 2
	bcopy((caddr_t)&ip_srcrt.nop,
	    mtod(m, caddr_t) + sizeof(struct in_addr), OPTSIZ);
d1070 1
d1073 1
d1080 1
d1082 2
a1083 1
		printf(" %X\n", ntohl(*q));
a1091 1
#ifdef NEW
a1092 1
#endif NEW
d1094 3
a1096 2
ip_stripoptions(ip, mopt)
	struct ip *ip;
d1100 1
a1100 1
	register struct mbuf *m;
a1104 1
	m = DTOM(ip);
d1106 9
d1128 1
d1134 1
a1134 1
	0,		0,		EHOSTDOWN,	EHOSTUNREACH,
d1147 7
a1153 4
 * If not forwarding (possibly because we have only a single external
 * network), just drop the packet.  This could be confusing if ipforwarding
 * was zero but some routing protocol was advancing us as a gateway
 * to somewhere.  However, we must let the routing protocol deal with that.
d1155 2
a1156 1
ip_forward(m, ifp)
d1158 1
a1158 1
	struct ifnet *ifp;
a1160 1
	register int error, type = 0, code;
d1162 2
d1165 2
a1166 1
	struct in_addr dest;
d1168 2
a1169 1
	dest.s_addr = 0;
d1171 5
a1175 3
		printf("forward: src %x dst %x ttl %x\n", ip->ip_src,
			ip->ip_dst, ip->ip_ttl);
	if (in_canforward(ip->ip_dst) == 0) {
d1177 1
a1177 5
#ifdef OldCode
		m_freem(dtom(ip));
#else
		DTOM_FREEM(ip);
#endif
d1180 1
a1180 1
	ip->ip_id = htons(ip->ip_id);
d1182 2
a1183 2
		type = ICMP_TIMXCEED, code = ICMP_TIMXCEED_INTRANS;
		goto sendicmp;
a1186 10
	/*
	 * Save at most 64 bytes of the packet in case
	 * we need to generate an ICMP message to the src.
	 */
#ifdef OldCode
	mcopy = m_copy(dtom(ip), 0, imin((int)ip->ip_len, 64));
#else
	mcopy = COPY_P(DTOM(ip), 0, imin((int)ip->ip_len, 64));
#endif

d1188 1
a1188 1
	if (ipforward_rt.ro_rt == 0 ||
d1195 1
d1198 6
a1203 1
		rtalloc(&ipforward_rt);
d1205 7
d1221 5
a1225 5
	if (ipforward_rt.ro_rt && ipforward_rt.ro_rt->rt_ifp == ifp &&
	    (ipforward_rt.ro_rt->rt_flags & (RTF_DYNAMIC|RTF_MODIFIED)) == 0 &&
	    satosin(&ipforward_rt.ro_rt->rt_dst)->sin_addr.s_addr != 0 &&
	    ipsendredirects && ip->ip_hl == (sizeof(struct ip) >> 2)) {
		struct in_ifaddr *ia;
a1226 1
		u_long dst = ntohl(ip->ip_dst.s_addr);
d1228 4
a1231 4
		if ((ia = ifptoia(ifp)) &&
		   (src & ia->ia_subnetmask) == ia->ia_subnet) {
		    if (ipforward_rt.ro_rt->rt_flags & RTF_GATEWAY)
			dest = satosin(&ipforward_rt.ro_rt->rt_gateway)->sin_addr;
d1233 2
a1234 7
			dest = ip->ip_dst;
		    /*
		     * If the destination is reached by a route to host,
		     * is on a subnet of a local net, or is directly
		     * on the attached net (!), use host redirect.
		     * (We may be the correct first hop for other subnets.)
		     */
d1236 2
a1237 10
		    code = ICMP_REDIRECT_NET;
		    if ((ipforward_rt.ro_rt->rt_flags & RTF_HOST) ||
		       (ipforward_rt.ro_rt->rt_flags & RTF_GATEWAY) == 0)
			code = ICMP_REDIRECT_HOST;
		    else for (ia = in_ifaddr; ia = ia->ia_next; )
			if ((dst & ia->ia_netmask) == ia->ia_net) {
			    if (ia->ia_subnetmask != ia->ia_netmask)
				    code = ICMP_REDIRECT_HOST;
			    break;
			}
d1239 2
a1240 1
			printf("redirect (%d) to %x\n", code, dest);
d1244 5
a1248 2
	error = ip_output(DTOM(ip), (struct mbuf *)0, &ipforward_rt,
		IP_FORWARDING);
a1250 2
	else if (type)
		ipstat.ips_redirectsent++;
d1252 7
a1258 7
		if (mcopy)
		{
#ifdef OldCode
		    m_freem(mcopy);
#else
		    FREEM(mcopy);
#endif
a1259 2
		ipstat.ips_forward++;
		return;
d1263 2
a1264 2
	ip = mtod(mcopy, struct ip *);
	type = ICMP_UNREACH;
d1268 1
a1268 2
		type = ICMP_REDIRECT;
		/* code set above */
d1271 2
a1272 1
	case ENETUNREACH:
d1274 4
a1277 4
		if (in_localaddr(ip->ip_dst))
			code = ICMP_UNREACH_HOST;
		else
			code = ICMP_UNREACH_NET;
d1281 1
d1283 3
a1285 4
		break;

	case EPERM:
		code = ICMP_UNREACH_PORT;
d1290 1
d1292 49
d1342 18
a1359 4
	case EHOSTDOWN:
	case EHOSTUNREACH:
		code = ICMP_UNREACH_HOST;
		break;
d1361 2
a1362 2
sendicmp:
	icmp_error(ip, type, code, ifp, dest);
d1365 14
a1378 1
/* EOF ip_input.c */
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d1 21
d23 2
a24 2
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
d26 11
a36 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a38 1

a44 1
#include "sys/kernel.h"
a48 2
#include "sys/sysctl.h"
#include "sys/dcistructs.h"
d54 1
a57 1
#include "netinet/in_pcb.h"
a61 4
#include "sys/socketvar.h"

#include "machine/in_cksum.h"

a63 5
#include "module.h"

int rsvp_on = 0;
int ip_rsvp_on;
struct socket *ip_rsvpd;
d75 1
d80 2
a81 1
#endif /* __riscos */
a82 5
int	ip_defttl = IPDEFTTL;
int	ip_dosourceroute = 0;
#ifdef DIAGNOSTIC
int	ipprintfs = 0;
#endif
d84 1
a84 3
extern	struct domain inetdomain;
extern	struct protosw inetsw[];
u_char	ip_protox[IPPROTO_MAX];
d86 1
a86 9
struct  in_ifaddr *in_ifaddr;		       /* first inet address */
struct	ifqueue ipintrq;

struct ipstat ipstat;
struct ipq ipq;

/* Firewall hooks */
ip_fw_chk_t *ip_fw_chk_ptr;
ip_fw_ctl_t *ip_fw_ctl_ptr;
d101 1
a101 1
} ip_srcrt;
a102 1
static void save_rte(u_char *, struct in_addr);
a106 1
void
d125 3
d129 1
a130 3
#if defined(IPFIREWALL) && !defined(__riscos)
	ip_fw_init();
#endif /* IPFIREWALL */
d133 4
a136 5
struct	sockaddr_in ipaddr = { sizeof(ipaddr), AF_INET };
struct	route ipforward_rt;

/*int	ipcksum = 1;*/
static int ipfragttl = IPFRAGTTL;
d141 2
a142 1
 * try to reassemble.  Process options.  Pass to next level.
d144 1
a144 2
void
ip_input(struct mbuf *m)
d146 5
a150 3
	struct ip *ip;
	struct ipq *fp;
	struct in_ifaddr *ia;
a151 5
#ifdef QuickMNSAcks
	char ethersrc[6];
#else
        char *ethersrc = 0;
#endif
a152 17
#ifdef QuickMNSAcks
	/*
	 * RISC OS - get ethersrc from DCI-4 RxHdr, then strip
	 * it off.
	 */
	memcpy(ethersrc, mtod(m, RxHdrRef)->rx_src_addr, 6);
	m = m_freen(m);
	if (m == 0)
		return;
#endif
#ifdef	DIAGNOSTIC
	if ((m->m_flags & M_PKTHDR) == 0) {
		panic("ipintr no HDR");
                Printf("panic: ipintr no HDR\n");
                Printf("m=-x%x, m->m_flags=0x%x\n", m, m->m_flags);
	}
#endif
d157 2
a158 1
	if (in_ifaddr == NULL) {
d160 2
a161 5
		if (DODEBUG(DBGINPUT))
			Printf("ipintr: in_ifaddr not set!\n");
#endif
#ifdef __riscos
		if (!(m->m_pkthdr.rcvif->if_flags & IFF_NEED_IPADDR))
d163 1
a163 1
		goto bad;
d165 1
d167 1
a167 2
	if (m->m_len < sizeof (struct ip) &&
	    (m = m_pullup(m, sizeof (struct ip))) == 0) {
d173 5
d180 13
a192 3
	ip = mtod(m, struct ip *);
	if (ip->ip_v != IPVERSION) {
		ipstat.ips_badvers++;
d194 7
d202 3
d206 1
a206 1
	if (hlen < sizeof(struct ip)) {	/* minimum header length */
d210 1
a210 14
	if (hlen > m->m_len) {
		if ((m = m_pullup(m, hlen)) == 0) {
			ipstat.ips_badhlen++;
			return;
		}
		ip = mtod(m, struct ip *);
	}
    if (ip->ip_sum) {      /* Compatibility hack required for AUN (yuck) */
	if (hlen == sizeof(struct ip))
		ip->ip_sum = in_cksum_hdr(ip);
	else
		ip->ip_sum = in_cksum(m, hlen);
    }
	if (ip->ip_sum) {
a213 1

d217 1
a217 1
	NTOHS(ip->ip_len);
d222 2
a223 2
	NTOHS(ip->ip_id);
	NTOHS(ip->ip_off);
d231 17
a247 1
	if (m->m_pkthdr.len < ip->ip_len) {
d249 15
a263 2
		if( DODEBUG(DBGINPUT) )
		        Printf("ipintr: len (%d) is < ip->ip_len\n", m->m_pkthdr.len, ip->ip_len);
d265 1
a265 2
		ipstat.ips_tooshort++;
		goto bad;
d267 1
a267 22
	if (m->m_pkthdr.len > ip->ip_len) {
		if (m->m_len == m->m_pkthdr.len) {
			m->m_len = ip->ip_len;
			m->m_pkthdr.len = ip->ip_len;
		} else
			m_adj(m, ip->ip_len - m->m_pkthdr.len);
	}
#ifdef IPFIREWALL
	/*
	 * IpHack's section.
	 * Right now when no processing on packet has done
	 * and it is still fresh out of network we do our black
	 * deals with it.
	 * - Firewall: deny/allow
	 * - Wrap: fake packet's addr/port <unimpl.>
	 * - Encapsulate: put it in another IP and send out. <unimp.>
 	 */

	if (ip_fw_chk_ptr &&
	    !(*ip_fw_chk_ptr)(&ip, hlen, m->m_pkthdr.rcvif, 0, &m))
		return;
#endif
d271 1
a271 1
	 * ship it on.  ip_dooptions returns 1 when an
d276 6
a281 1
	if (hlen > sizeof (struct ip) && ip_dooptions(m))
d283 1
d285 5
a289 8
#ifdef MULTICAST
        /* greedy RSVP, snatches any PATH packet of the RSVP protocol and no
         * matter if it is destined to another node, or whether it is
         * a multicast one, RSVP wants it! and prevents it from being forwarded
         * anywhere else. Also checks if the rsvp daemon is running before
	 * grabbing the packet.
         */
	if (rsvp_on && ip->ip_p==IPPROTO_RSVP)
d297 1
a297 1
#define	satosin(sa)	((struct sockaddr_in *)(sa))
d303 1
a303 1
		    ia->ia_ifp == m->m_pkthdr.rcvif &&
a323 46
#ifdef MULTICAST
	if (IN_MULTICAST(ntohl(ip->ip_dst.s_addr))) {
		struct in_multi *inm;
		if (ip_mrouter) {
			/*
			 * If we are acting as a multicast router, all
			 * incoming multicast packets are passed to the
			 * kernel-level multicast forwarding function.
			 * The packet is returned (relatively) intact; if
			 * ip_mforward() returns a non-zero value, the packet
			 * must be discarded, else it may be accepted below.
			 *
			 * (The IP ident field is put in the same byte order
			 * as expected when ip_mforward() is called from
			 * ip_output().)
			 */
			ip->ip_id = htons(ip->ip_id);
			if (ip_mforward(ip, m->m_pkthdr.rcvif, m, 0) != 0) {
				ipstat.ips_cantforward++;
				m_freem(m);
				return;
			}
			ip->ip_id = ntohs(ip->ip_id);

			/*
			 * The process-level routing demon needs to receive
			 * all multicast IGMP packets, whether or not this
			 * host belongs to their destination groups.
			 */
			if (ip->ip_p == IPPROTO_IGMP)
				goto ours;
			ipstat.ips_forward++;
		}
		/*
		 * See if we belong to the destination multicast group on the
		 * arrival interface.
		 */
		IN_LOOKUP_MULTI(ip->ip_dst, m->m_pkthdr.rcvif, inm);
		if (inm == NULL) {
			ipstat.ips_cantforward++;
			m_freem(m);
			return;
		}
		goto ours;
	}
#endif
a327 4
#ifdef __riscos
	if (m->m_pkthdr.rcvif->if_flags & IFF_NEED_IPADDR)
		goto ours;
#endif
d332 5
a336 1
	if (ipforwarding == 0) {
d338 1
a338 1
		if (DODEBUG(DBGINPUT))
d342 1
d344 6
a349 1
	} else {
d351 2
a352 2
		if (DODEBUG(DBGINPUT))
			Printf("ipintr: forwarding packet\n");
d354 1
a354 1
		ip_forward(m, 0);
d356 1
d360 5
d374 2
a375 11
		if (DODEBUG(DBGINPUT))
	    		Printf("ipintr: frag\n");
#endif
#ifndef __riscos
		if (m->m_flags & M_EXT) {		/* XXX */
			if ((m = m_pullup(m, sizeof (struct ip))) == 0) {
				ipstat.ips_toosmall++;
				return;
			}
			ip = mtod(m, struct ip *);
		}
a388 1

d395 1
a395 1
		((struct ipasfrag *)ip)->ipf_mff &= ~1;
d397 1
a397 1
			((struct ipasfrag *)ip)->ipf_mff |= 1;
d405 1
a405 1
		if (((struct ipasfrag *)ip)->ipf_mff & 1 || ip->ip_off) {
d410 2
a411 1
			ipstat.ips_reassembled++;
d413 3
d426 1
a426 1
	if (DODEBUG(DBGINPUT))
d429 1
a429 2
	ipstat.ips_delivered++;
	(*inetsw[ip_protox[ip->ip_p]].pr_input)(m, hlen, ethersrc);
d431 3
a433 1
bad:
d435 4
a438 19
}

/*
 * IP software interrupt routine - to go away sometime soon
 */
void
ipintr(void)
{
	int s;
	struct mbuf *m;

	while(1) {
		s = splimp();
		IF_DEQUEUE(&ipintrq, m);
		splx(s);
		if (m == 0)
			return;
		ip_input(m);
	}
d452 3
d456 1
d473 6
a478 1
		if ((t = m_get(M_DONTWAIT, MT_FTABLE)) == NULL) {
d481 1
a481 1
			Printf("ip_reass: m_get failed\n");
d485 3
d490 1
a490 1
		fp->ipq_ttl = ipfragttl;
d517 3
d521 1
d536 3
d540 1
d544 3
d548 1
d564 1
a564 1
	if (q->ipf_prev->ipf_mff & 1)
d574 3
d578 1
d583 3
d587 1
a597 1
	ip->ipf_mff &= ~1;
d601 4
d607 1
a609 7
	/* some debugging cruft by sklower, below, will go away soon */
	if (m->m_flags & M_PKTHDR) { /* XXX this should be done elsewhere */
		register int plen = 0;
		for (t = m; m; m = m->m_next)
			plen += m->m_len;
		t->m_pkthdr.len = plen;
	}
d614 1
d616 3
a625 1
void
d634 3
d638 1
d641 3
d645 1
a651 1
void
a664 1
void
a677 1
void
d681 1
a681 1
	func_splhi();
d685 1
a685 1
		func_splx();
d696 1
a696 1
	func_splrestore();
a701 1
void
d711 2
d719 1
a719 2
int
ip_dooptions(m)
d721 1
d728 1
a728 1
	struct in_addr *sin, dst;
a730 1
	dst = ip->ip_dst;
a788 13
			if (!ip_dosourceroute) {
				char buf[4*sizeof "123"];
				strcpy(buf, inet_ntoa(ip->ip_dst));

#ifdef DEBUG
				Printf(
				    "attempted source route from %s to %s\n",
				    inet_ntoa(ip->ip_src), buf);
#endif
				type = ICMP_UNREACH;
				code = ICMP_UNREACH_SRCFAIL;
				goto bad;
			}
d792 1
a792 1
			(void)memcpy(&ipaddr.sin_addr, cp + off,
d794 3
a796 9

			if (opt == IPOPT_SSRR) {
#define	INA	struct in_ifaddr *
#define	SA	struct sockaddr *
			    if ((ia = (INA)ifa_ifwithdstaddr((SA)&ipaddr)) == 0)
			        ia = (INA)ifa_ifwithnet((SA)&ipaddr);
			} else
				ia = ip_rtaddr(ipaddr.sin_addr);
			if (ia == 0) {
d802 2
a803 2
			(void)memcpy(cp + off, &(IA_SIN(ia)->sin_addr),
			    sizeof(struct in_addr));
d805 1
a805 4
			/*
			 * Let ip_intr's mcast routing check handle mcast pkts
			 */
			forward = !IN_MULTICAST(ntohl(ip->ip_dst.s_addr));
d819 1
a819 1
			(void)memcpy(&ipaddr.sin_addr, &ip->ip_dst,
d822 1
a822 2
			 * locate outgoing interface; if we're the destination,
			 * use the incoming interface (should be same).
d824 1
a824 2
			if ((ia = (INA)ifa_ifwithaddr((SA)&ipaddr)) == 0 &&
			    (ia = ip_rtaddr(ipaddr.sin_addr)) == 0) {
d829 2
a830 2
			(void)memcpy(cp + off, &(IA_SIN(ia)->sin_addr),
			    sizeof(struct in_addr));
d854 3
a856 7
				ipaddr.sin_addr = dst;
				ia = (INA)ifaof_ifpforaddr((SA)&ipaddr,
							   m->m_pkthdr.rcvif);
				if (ia == 0)
					continue;
				(void)memcpy(sin, &IA_SIN(ia)->sin_addr,
				    sizeof(struct in_addr));
d864 1
a864 1
				(void)memcpy(&ipaddr.sin_addr, sin,
d866 1
a866 1
				if (ifa_ifwithaddr((SA)&ipaddr) == 0)
d875 1
a875 1
			(void)memcpy(cp + ipt->ipt_ptr - 1, &ntime,
d881 1
a881 1
		ip_forward(m, 1);
d883 2
a884 2
	}
	return (0);
d886 1
a886 3
	ip->ip_len -= ip->ip_hl << 2;   /* XXX icmp_error adds in hdr length */
	icmp_error(m, type, code, 0, 0);
	ipstat.ips_badoptions++;
d899 1
a908 1
		sin->sin_len = sizeof(*sin);
d911 1
a911 1
		rtalloc_ign(&ipforward_rt, RTF_PRCLONING);
d915 7
a921 1
	return ((struct in_ifaddr *) ipforward_rt.ro_rt->rt_ifa);
a927 1
void
a934 1
#ifdef DIAGNOSTIC
a936 1
#endif
d939 1
a939 1
	(void)memcpy(ip_srcrt.srcopt, option, olen);
d957 7
a963 2
	m = ALLOC_S(MINCONTIG, NULL);
	if (m == 0) {
d968 1
a968 1
	    return ((struct mbuf *)0);
d970 1
d972 1
a978 1
#ifdef DIAGNOSTIC
a980 1
#endif
a986 1
#ifdef DIAGNOSTIC
a988 1
#endif
d995 2
a996 2
	(void)memcpy(mtod(m, caddr_t) + sizeof(struct in_addr),
	    &ip_srcrt.nop, OPTSIZ);
a1004 1
#ifdef DIAGNOSTIC
a1006 1
#endif
a1012 1
#ifdef DIAGNOSTIC
d1014 1
a1014 2
		printf(" %X\n", ntohl(q->s_addr));
#endif
d1023 1
d1025 1
d1027 2
a1028 3
void
ip_stripoptions(m, mopt)
	register struct mbuf *m;
d1032 1
a1032 1
	struct ip *ip = mtod(m, struct ip *);
d1037 1
a1038 9
	i = m->m_len - (sizeof (struct ip) + olen);
	bcopy(opts + olen, opts, (unsigned)i);
	m->m_len -= olen;
#ifndef __riscos
	if (m->m_flags & M_PKTHDR)
		m->m_pkthdr.len -= olen;
#endif
	ip->ip_hl = sizeof(struct ip) >> 2;
#ifdef OldCodeWhy
a1051 1
#endif
d1057 1
a1057 1
	0,		EMSGSIZE,	EHOSTDOWN,	EHOSTUNREACH,
d1070 4
a1073 7
 * If not forwarding, just drop the packet.  This could be confusing
 * if ipforwarding was zero but some routing protocol was advancing
 * us as a gateway to somewhere.  However, we must let the routing
 * protocol deal with that.
 *
 * The srcrt parameter indicates whether the packet is being forwarded
 * via a source route.
d1075 1
a1075 2
void
ip_forward(m, srcrt)
d1077 1
a1077 1
	int srcrt;
d1080 1
a1081 2
	register struct rtentry *rt;
	int error, type = 0, code = 0;
d1083 1
a1083 2
	n_long dest;
	struct ifnet *destifp;
d1085 1
a1085 2
	dest = 0;
#ifdef DIAGNOSTIC
d1087 8
a1094 2
		printf("forward: src %x dst %x ttl %x\n",
			ip->ip_src.s_addr, ip->ip_dst.s_addr, ip->ip_ttl);
a1095 4

	if (m->m_flags & M_BCAST || in_canforward(ip->ip_dst) == 0) {
		ipstat.ips_cantforward++;
		m_freem(m);
d1098 1
a1098 1
	HTONS(ip->ip_id);
d1100 2
a1101 2
		icmp_error(m, ICMP_TIMXCEED, ICMP_TIMXCEED_INTRANS, dest, 0);
		return;
d1105 10
d1116 1
a1116 1
	if ((rt = ipforward_rt.ro_rt) == 0 ||
a1122 1
		sin->sin_len = sizeof(*sin);
d1125 1
a1125 6
		rtalloc_ign(&ipforward_rt, RTF_PRCLONING);
		if (ipforward_rt.ro_rt == 0) {
			icmp_error(m, ICMP_UNREACH, ICMP_UNREACH_HOST, dest, 0);
			return;
		}
		rt = ipforward_rt.ro_rt;
a1126 7

	/*
	 * Save at most 64 bytes of the packet in case
	 * we need to generate an ICMP message to the src.
	 */
	mcopy = m_copy(m, 0, imin((int)ip->ip_len, 64));

d1136 5
a1140 5
	if (rt->rt_ifp == m->m_pkthdr.rcvif &&
	    (rt->rt_flags & (RTF_DYNAMIC|RTF_MODIFIED)) == 0 &&
	    satosin(rt_key(rt))->sin_addr.s_addr != 0 &&
	    ipsendredirects && !srcrt) {
#define	RTA(rt)	((struct in_ifaddr *)(rt->rt_ifa))
d1142 1
d1144 4
a1147 4
		if (RTA(rt) &&
		    (src & RTA(rt)->ia_subnetmask) == RTA(rt)->ia_subnet) {
		    if (rt->rt_flags & RTF_GATEWAY)
			dest = satosin(rt->rt_gateway)->sin_addr.s_addr;
d1149 7
a1155 2
			dest = ip->ip_dst.s_addr;
		    /* Router requirements says to only send host redirects */
d1157 10
a1166 2
		    code = ICMP_REDIRECT_HOST;
#ifdef DIAGNOSTIC
d1168 1
a1168 2
			printf("redirect (%d) to %x\n", code, (u_long)dest);
#endif
d1172 2
a1173 5
	error = ip_output(m, (struct mbuf *)0, &ipforward_rt, IP_FORWARDING
#ifdef DIRECTED_BROADCAST
			    | IP_ALLOWBROADCAST
#endif
						, 0);
d1176 2
d1179 8
d1188 1
a1188 7
		if (type)
			ipstat.ips_redirectsent++;
		else {
			if (mcopy)
				m_freem(mcopy);
			return;
		}
d1192 2
a1193 2
	destifp = NULL;

d1197 2
a1198 1
		/* type, code set above */
d1201 1
a1201 2
	case ENETUNREACH:		/* shouldn't happen, checked above */
	case EHOSTUNREACH:
d1203 4
a1206 4
	case EHOSTDOWN:
	default:
		type = ICMP_UNREACH;
		code = ICMP_UNREACH_HOST;
a1209 1
		type = ICMP_UNREACH;
d1211 4
a1214 3
		if (ipforward_rt.ro_rt)
			destifp = ipforward_rt.ro_rt->rt_ifp;
		ipstat.ips_cantfrag++;
a1218 1
		code = 0;
a1219 3
	}
	icmp_error(mcopy, type, code, dest, destifp);
}
d1221 4
a1224 42
int
ip_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case IPCTL_FORWARDING:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ipforwarding));
	case IPCTL_SENDREDIRECTS:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
			&ipsendredirects));
	case IPCTL_DEFTTL:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ip_defttl));
	case IPCTL_SOURCEROUTE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ip_dosourceroute));
#ifdef notyet
	case IPCTL_DEFMTU:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ip_mtu));
#endif
	case IPCTL_RTEXPIRE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &rtq_reallyold));
	case IPCTL_RTMINEXPIRE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &rtq_minreallyold));
	case IPCTL_RTMAXCACHE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &rtq_toomany));
	case IPCTL_FRAGTTL:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ipfragttl));
	default:
		return (EOPNOTSUPP);
d1226 2
a1227 1
	/* NOTREACHED */
d1230 1
a1230 37
int
ip_rsvp_init(struct socket *so)
{
	if (so->so_type != SOCK_RAW ||
	    so->so_proto->pr_protocol != IPPROTO_RSVP)
	  return EOPNOTSUPP;

	if (ip_rsvpd != NULL)
	  return EADDRINUSE;

	ip_rsvpd = so;
	/*
	 * This may seem silly, but we need to be sure we don't over-increment
	 * the RSVP counter, in case something slips up.
	 */
	if (!ip_rsvp_on) {
		ip_rsvp_on = 1;
		rsvp_on++;
	}

	return 0;
}

int
ip_rsvp_done(void)
{
	ip_rsvpd = NULL;
	/*
	 * This may seem silly, but we need to be sure we don't over-decrement
	 * the RSVP counter, in case something slips up.
	 */
	if (ip_rsvp_on) {
		ip_rsvp_on = 0;
		rsvp_on--;
	}
	return 0;
}
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d3 1
a3 1
 * $Header: /ax/networking:Internet/netinet/ip_input.c:networking  1.5  $
a8 16
 * Revision 1.5  95/11/14  12:15:57  pwain
 * Check-in for jdavies@@csd
 * 
 * Enabled code dependent on DIRECTED_BROADCAST preprocessor symbol, but
 * made it dependent on the AUN_state flag being set to AUN_GATEWAY. This
 * appears to enable the forwarding of directed broadcasts (e.g. forwarding a
 * broadcast packet addressed to 1.0.128.255 from net 1.0.129.0). This is
 * required to allow a !Gateway setup to function as before. This code
 * (believed to be part of the Berkeley release) was not enabled in "normal"
 * releases of the Internet module but was previously enabled in the
 * InternetAG module by KRuttle.
 *
 * In order for the code to function correctly, it is also necessary to OR
 * in the IP_ALLOWBROADCAST flag to the ip_output() call made from within
 * the ip_forward() routine.
 *
a301 7
#ifdef OldCode
		/* This was supposedly the Berkeley release code. Only "receive"
		 * the packet if the interface Internet address we are
		 * comparing against is the address of the interface on which
		 * we received the packet. Otherwise, do not "receive" it, and
		 * thus forward it.
		 */
a304 4
#else
		/* Make this conditional on running in a !Gateway machine */
		    (AUN_state != AUN_GATEWAY || ia->ia_ifp == ifp) &&
#endif
a1171 1
#ifdef OldCode
a1173 11
#else
	/* This appears to be necessary to make !Gateway machines forward directed
	 * broadcast packets from one subnet to another.
	 */
	if (AUN_state == AUN_GATEWAY)
	    error = ip_output(DTOM(ip), (struct mbuf *)0, &ipforward_rt,
		IP_FORWARDING|IP_ALLOWBROADCAST);
	else
	    error = ip_output(DTOM(ip), (struct mbuf *)0, &ipforward_rt,
		IP_FORWARDING);
#endif
@


4.1.7.2
log
@RCS log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@d3 1
a3 1
 * $Header: /ax/networking:Internet/netinet/ip_input.c:networking  1.5  $
a8 16
 * Revision 1.5  95/11/14  12:15:57  pwain
 * Check-in for jdavies@@csd
 * 
 * Enabled code dependent on DIRECTED_BROADCAST preprocessor symbol, but
 * made it dependent on the AUN_state flag being set to AUN_GATEWAY. This
 * appears to enable the forwarding of directed broadcasts (e.g. forwarding a
 * broadcast packet addressed to 1.0.128.255 from net 1.0.129.0). This is
 * required to allow a !Gateway setup to function as before. This code
 * (believed to be part of the Berkeley release) was not enabled in "normal"
 * releases of the Internet module but was previously enabled in the
 * InternetAG module by KRuttle.
 *
 * In order for the code to function correctly, it is also necessary to OR
 * in the IP_ALLOWBROADCAST flag to the ip_output() call made from within
 * the ip_forward() routine.
 *
a301 7
#ifdef OldCode
		/* This was supposedly the Berkeley release code. Only "receive"
		 * the packet if the interface Internet address we are
		 * comparing against is the address of the interface on which
		 * we received the packet. Otherwise, do not "receive" it, and
		 * thus forward it.
		 */
a304 4
#else
		/* Make this conditional on running in a !Gateway machine */
		    (AUN_state != AUN_GATEWAY || ia->ia_ifp == ifp) &&
#endif
a1171 1
#ifdef OldCode
a1173 11
#else
	/* This appears to be necessary to make !Gateway machines forward directed
	 * broadcast packets from one subnet to another.
	 */
	if (AUN_state == AUN_GATEWAY)
	    error = ip_output(DTOM(ip), (struct mbuf *)0, &ipforward_rt,
		IP_FORWARDING|IP_ALLOWBROADCAST);
	else
	    error = ip_output(DTOM(ip), (struct mbuf *)0, &ipforward_rt,
		IP_FORWARDING);
#endif
@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d1 21
d23 2
a24 2
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
d26 11
a36 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a37 14
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ip_input.c	8.2 (Berkeley) 1/4/94
 * $Id: ip_input.c,v 1.22.4.4 1996/02/26 15:23:36 phk Exp $
a38 1

a44 1
#include "sys/kernel.h"
a48 1
#include "sys/dcistructs.h"
d54 1
a57 1
#include "netinet/in_pcb.h"
a61 2
#include "sys/socketvar.h"

a63 7
#include "module.h"

#ifdef MULTICAST
int rsvp_on = 0;
int ip_rsvp_on;
struct socket *ip_rsvpd;
#endif
d75 1
d81 1
a82 5
int	ip_defttl = IPDEFTTL;
int	ip_dosourceroute = 0;
#ifdef DIAGNOSTIC
int	ipprintfs = 0;
#endif
d84 1
a84 3
extern	struct domain inetdomain;
extern	struct protosw inetsw[];
u_char	ip_protox[IPPROTO_MAX];
d86 1
a86 9
struct  in_ifaddr *in_ifaddr;		       /* first inet address */
struct	ifqueue ipintrq;

struct ipstat ipstat;
struct ipq ipq;

/* Firewall hooks */
ip_fw_chk_t *ip_fw_chk_ptr;
ip_fw_ctl_t *ip_fw_ctl_ptr;
d101 1
a101 1
} ip_srcrt;
a102 1
static void save_rte(u_char *, struct in_addr);
a106 1
void
d125 3
d129 1
a130 3
#if defined(IPFIREWALL) && !defined(__riscos)
	ip_fw_init();
#endif /* IPFIREWALL */
d133 4
a136 4
struct	sockaddr_in ipaddr = { sizeof(ipaddr), AF_INET };
struct	route ipforward_rt;

//int	ipcksum = 1;
d141 2
a142 1
 * try to reassemble.  Process options.  Pass to next level.
d144 1
a144 2
void
ip_input(struct mbuf *m)
d146 5
a150 3
	struct ip *ip;
	struct ipq *fp;
	struct in_ifaddr *ia;
a151 5
#ifdef QuickMNSAcks
	char ethersrc[6];
#else
        char *ethersrc = 0;
#endif
a152 17
#ifdef QuickMNSAcks
	/*
	 * RISC OS - get ethersrc from DCI-4 RxHdr, then strip
	 * it off.
	 */
	memcpy(ethersrc, mtod(m, RxHdrRef)->rx_src_addr, 6);
	m = m_freen(m);
	if (m == 0)
		return;
#endif
#ifdef	DIAGNOSTIC
	if ((m->m_flags & M_PKTHDR) == 0) {
		panic("ipintr no HDR");
                Printf("panic: ipintr no HDR\n");
                Printf("m=-x%x, m->m_flags=0x%x\n", m, m->m_flags);
	}
#endif
d157 2
a158 1
	if (in_ifaddr == NULL) {
d160 2
a161 2
		if (DODEBUG(DBGINPUT))
			Printf("ipintr: in_ifaddr not set!\n");
d163 1
a163 1
		goto bad;
d165 1
d167 1
a167 2
	if (m->m_len < sizeof (struct ip) &&
	    (m = m_pullup(m, sizeof (struct ip))) == 0) {
d173 5
d180 13
a192 3
	ip = mtod(m, struct ip *);
	if (ip->ip_v != IPVERSION) {
		ipstat.ips_badvers++;
d194 7
d202 3
d206 1
a206 1
	if (hlen < sizeof(struct ip)) {	/* minimum header length */
d210 1
a210 14
	if (hlen > m->m_len) {
		if ((m = m_pullup(m, hlen)) == 0) {
			ipstat.ips_badhlen++;
			return;
		}
		ip = mtod(m, struct ip *);
	}
    if (ip->ip_sum) {      /* Compatibility hack required for AUN (yuck) */
	if (hlen == sizeof(struct ip))
		ip->ip_sum = in_cksum_hdr(ip);
	else
		ip->ip_sum = in_cksum(m, hlen);
    }
	if (ip->ip_sum) {
a213 1

d217 1
a217 1
	NTOHS(ip->ip_len);
d222 2
a223 2
	NTOHS(ip->ip_id);
	NTOHS(ip->ip_off);
d231 17
a247 1
	if (m->m_pkthdr.len < ip->ip_len) {
d249 15
a263 2
		if( DODEBUG(DBGINPUT) )
		        Printf("ipintr: len (%d) is < ip->ip_len\n", m->m_pkthdr.len, ip->ip_len);
d265 1
a265 9
		ipstat.ips_tooshort++;
		goto bad;
	}
	if (m->m_pkthdr.len > ip->ip_len) {
		if (m->m_len == m->m_pkthdr.len) {
			m->m_len = ip->ip_len;
			m->m_pkthdr.len = ip->ip_len;
		} else
			m_adj(m, ip->ip_len - m->m_pkthdr.len);
d267 1
a267 15
#ifdef IPFIREWALL
	/*
	 * IpHack's section.
	 * Right now when no processing on packet has done
	 * and it is still fresh out of network we do our black
	 * deals with it.
	 * - Firewall: deny/allow
	 * - Wrap: fake packet's addr/port <unimpl.>
	 * - Encapsulate: put it in another IP and send out. <unimp.>
 	 */

	if (ip_fw_chk_ptr &&
	    !(*ip_fw_chk_ptr)(&ip, hlen, m->m_pkthdr.rcvif, 0, &m))
		return;
#endif
d271 1
a271 1
	 * ship it on.  ip_dooptions returns 1 when an
d276 6
a281 1
	if (hlen > sizeof (struct ip) && ip_dooptions(m))
d283 5
d289 1
a289 8
#ifdef MULTICAST
        /* greedy RSVP, snatches any PATH packet of the RSVP protocol and no
         * matter if it is destined to another node, or whether it is
         * a multicast one, RSVP wants it! and prevents it from being forwarded
         * anywhere else. Also checks if the rsvp daemon is running before
	 * grabbing the packet.
         */
	if (rsvp_on && ip->ip_p==IPPROTO_RSVP)
d297 1
a297 1
#define	satosin(sa)	((struct sockaddr_in *)(sa))
d303 1
a303 1
		    ia->ia_ifp == m->m_pkthdr.rcvif &&
a323 46
#ifdef MULTICAST
	if (IN_MULTICAST(ntohl(ip->ip_dst.s_addr))) {
		struct in_multi *inm;
		if (ip_mrouter) {
			/*
			 * If we are acting as a multicast router, all
			 * incoming multicast packets are passed to the
			 * kernel-level multicast forwarding function.
			 * The packet is returned (relatively) intact; if
			 * ip_mforward() returns a non-zero value, the packet
			 * must be discarded, else it may be accepted below.
			 *
			 * (The IP ident field is put in the same byte order
			 * as expected when ip_mforward() is called from
			 * ip_output().)
			 */
			ip->ip_id = htons(ip->ip_id);
			if (ip_mforward(ip, m->m_pkthdr.rcvif, m, 0) != 0) {
				ipstat.ips_cantforward++;
				m_freem(m);
				return;
			}
			ip->ip_id = ntohs(ip->ip_id);

			/*
			 * The process-level routing demon needs to receive
			 * all multicast IGMP packets, whether or not this
			 * host belongs to their destination groups.
			 */
			if (ip->ip_p == IPPROTO_IGMP)
				goto ours;
			ipstat.ips_forward++;
		}
		/*
		 * See if we belong to the destination multicast group on the
		 * arrival interface.
		 */
		IN_LOOKUP_MULTI(ip->ip_dst, m->m_pkthdr.rcvif, inm);
		if (inm == NULL) {
			ipstat.ips_cantforward++;
			m_freem(m);
			return;
		}
		goto ours;
	}
#endif
a327 4
#ifdef __riscos
	if (m->m_pkthdr.rcvif->if_flags & IFF_NEED_IPADDR)
		goto ours;
#endif
d332 5
a336 1
	if (ipforwarding == 0) {
d338 1
a338 1
		if (DODEBUG(DBGINPUT))
d342 1
d344 6
a349 1
	} else {
d351 2
a352 2
		if (DODEBUG(DBGINPUT))
			Printf("ipintr: forwarding packet\n");
d354 1
a354 1
		ip_forward(m, 0);
d356 1
d360 5
d374 2
a375 11
		if (DODEBUG(DBGINPUT))
	    		Printf("ipintr: frag\n");
#endif
#ifndef __riscos
		if (m->m_flags & M_EXT) {		/* XXX */
			if ((m = m_pullup(m, sizeof (struct ip))) == 0) {
				ipstat.ips_toosmall++;
				return;
			}
			ip = mtod(m, struct ip *);
		}
a388 1

d395 1
a395 1
		((struct ipasfrag *)ip)->ipf_mff &= ~1;
d397 1
a397 1
			((struct ipasfrag *)ip)->ipf_mff |= 1;
d405 1
a405 1
		if (((struct ipasfrag *)ip)->ipf_mff & 1 || ip->ip_off) {
d410 2
a411 1
			ipstat.ips_reassembled++;
d413 3
d426 1
a426 1
	if (DODEBUG(DBGINPUT))
d429 1
a429 2
	ipstat.ips_delivered++;
	(*inetsw[ip_protox[ip->ip_p]].pr_input)(m, hlen, ethersrc);
d431 3
a433 1
bad:
d435 4
a438 19
}

/*
 * IP software interrupt routine - to go away sometime soon
 */
void
ipintr(void)
{
	int s;
	struct mbuf *m;

	while(1) {
		s = splimp();
		IF_DEQUEUE(&ipintrq, m);
		splx(s);
		if (m == 0)
			return;
		ip_input(m);
	}
d452 3
d456 1
d473 6
a478 1
		if ((t = m_get(M_DONTWAIT, MT_FTABLE)) == NULL) {
d481 1
a481 1
			Printf("ip_reass: m_get failed\n");
d485 3
d517 3
d521 1
d536 3
d540 1
d544 3
d548 1
d564 1
a564 1
	if (q->ipf_prev->ipf_mff & 1)
d574 3
d578 1
d583 3
d587 1
a597 1
	ip->ipf_mff &= ~1;
d601 4
d607 1
a609 7
	/* some debugging cruft by sklower, below, will go away soon */
	if (m->m_flags & M_PKTHDR) { /* XXX this should be done elsewhere */
		register int plen = 0;
		for (t = m; m; m = m->m_next)
			plen += m->m_len;
		t->m_pkthdr.len = plen;
	}
d614 1
d616 3
a625 1
void
d634 3
d638 1
d641 3
d645 1
a651 1
void
a664 1
void
a677 1
void
d681 1
a681 1
	func_splhi();
d685 1
a685 1
		func_splx();
d696 1
a696 1
	func_splrestore();
a701 1
void
d719 1
a719 2
int
ip_dooptions(m)
d721 1
d728 1
a728 1
	struct in_addr *sin, dst;
a730 1
	dst = ip->ip_dst;
a788 13
			if (!ip_dosourceroute) {
				char buf[4*sizeof "123"];
				strcpy(buf, inet_ntoa(ip->ip_dst));

#ifdef DEBUG
				Printf(
				    "attempted source route from %s to %s\n",
				    inet_ntoa(ip->ip_src), buf);
#endif
				type = ICMP_UNREACH;
				code = ICMP_UNREACH_SRCFAIL;
				goto bad;
			}
d792 1
a792 1
			(void)memcpy(&ipaddr.sin_addr, cp + off,
d794 3
a796 9

			if (opt == IPOPT_SSRR) {
#define	INA	struct in_ifaddr *
#define	SA	struct sockaddr *
			    if ((ia = (INA)ifa_ifwithdstaddr((SA)&ipaddr)) == 0)
			        ia = (INA)ifa_ifwithnet((SA)&ipaddr);
			} else
				ia = ip_rtaddr(ipaddr.sin_addr);
			if (ia == 0) {
d802 2
a803 2
			(void)memcpy(cp + off, &(IA_SIN(ia)->sin_addr),
			    sizeof(struct in_addr));
d805 1
a805 4
			/*
			 * Let ip_intr's mcast routing check handle mcast pkts
			 */
			forward = !IN_MULTICAST(ntohl(ip->ip_dst.s_addr));
d819 1
a819 1
			(void)memcpy(&ipaddr.sin_addr, &ip->ip_dst,
d822 1
a822 2
			 * locate outgoing interface; if we're the destination,
			 * use the incoming interface (should be same).
d824 1
a824 2
			if ((ia = (INA)ifa_ifwithaddr((SA)&ipaddr)) == 0 &&
			    (ia = ip_rtaddr(ipaddr.sin_addr)) == 0) {
d829 2
a830 2
			(void)memcpy(cp + off, &(IA_SIN(ia)->sin_addr),
			    sizeof(struct in_addr));
d854 3
a856 7
				ipaddr.sin_addr = dst;
				ia = (INA)ifaof_ifpforaddr((SA)&ipaddr,
							   m->m_pkthdr.rcvif);
				if (ia == 0)
					continue;
				(void)memcpy(sin, &IA_SIN(ia)->sin_addr,
				    sizeof(struct in_addr));
d864 1
a864 1
				(void)memcpy(&ipaddr.sin_addr, sin,
d866 1
a866 1
				if (ifa_ifwithaddr((SA)&ipaddr) == 0)
d875 1
a875 1
			(void)memcpy(cp + ipt->ipt_ptr - 1, &ntime,
d881 1
a881 1
		ip_forward(m, 1);
d883 2
a884 2
	}
	return (0);
d886 1
a886 3
	ip->ip_len -= ip->ip_hl << 2;   /* XXX icmp_error adds in hdr length */
	icmp_error(m, type, code, 0, 0);
	ipstat.ips_badoptions++;
d899 1
a908 1
		sin->sin_len = sizeof(*sin);
d911 1
a911 1
		rtalloc_ign(&ipforward_rt, RTF_PRCLONING);
d915 7
a921 1
	return ((struct in_ifaddr *) ipforward_rt.ro_rt->rt_ifa);
a927 1
void
a934 1
#ifdef DIAGNOSTIC
a936 1
#endif
d939 1
a939 1
	(void)memcpy(ip_srcrt.srcopt, option, olen);
d957 7
a963 2
	m = ALLOC_S(MINCONTIG, NULL);
	if (m == 0) {
d968 1
a968 1
	    return ((struct mbuf *)0);
d970 1
d972 1
a978 1
#ifdef DIAGNOSTIC
a980 1
#endif
a986 1
#ifdef DIAGNOSTIC
a988 1
#endif
d995 2
a996 2
	(void)memcpy(mtod(m, caddr_t) + sizeof(struct in_addr),
	    &ip_srcrt.nop, OPTSIZ);
a1004 1
#ifdef DIAGNOSTIC
a1006 1
#endif
a1012 1
#ifdef DIAGNOSTIC
d1014 1
a1014 2
		printf(" %X\n", ntohl(q->s_addr));
#endif
d1023 1
d1025 1
d1027 2
a1028 3
void
ip_stripoptions(m, mopt)
	register struct mbuf *m;
d1032 1
a1032 1
	struct ip *ip = mtod(m, struct ip *);
d1037 1
a1038 9
	i = m->m_len - (sizeof (struct ip) + olen);
	bcopy(opts + olen, opts, (unsigned)i);
	m->m_len -= olen;
#ifndef __riscos
	if (m->m_flags & M_PKTHDR)
		m->m_pkthdr.len -= olen;
#endif
	ip->ip_hl = sizeof(struct ip) >> 2;
#ifdef OldCodeWhy
a1051 1
#endif
d1057 1
a1057 1
	0,		EMSGSIZE,	EHOSTDOWN,	EHOSTUNREACH,
d1070 4
a1073 7
 * If not forwarding, just drop the packet.  This could be confusing
 * if ipforwarding was zero but some routing protocol was advancing
 * us as a gateway to somewhere.  However, we must let the routing
 * protocol deal with that.
 *
 * The srcrt parameter indicates whether the packet is being forwarded
 * via a source route.
d1075 1
a1075 2
void
ip_forward(m, srcrt)
d1077 1
a1077 1
	int srcrt;
d1080 1
a1081 2
	register struct rtentry *rt;
	int error, type = 0, code = 0;
d1083 1
a1083 2
	n_long dest;
	struct ifnet *destifp;
d1085 1
a1085 2
	dest = 0;
#ifdef DIAGNOSTIC
d1087 8
a1094 2
		printf("forward: src %x dst %x ttl %x\n",
			ip->ip_src.s_addr, ip->ip_dst.s_addr, ip->ip_ttl);
a1095 4

	if (m->m_flags & M_BCAST || in_canforward(ip->ip_dst) == 0) {
		ipstat.ips_cantforward++;
		m_freem(m);
d1098 1
a1098 1
	HTONS(ip->ip_id);
d1100 2
a1101 2
		icmp_error(m, ICMP_TIMXCEED, ICMP_TIMXCEED_INTRANS, dest, 0);
		return;
d1105 10
d1116 1
a1116 1
	if ((rt = ipforward_rt.ro_rt) == 0 ||
a1122 1
		sin->sin_len = sizeof(*sin);
d1125 1
a1125 6
		rtalloc_ign(&ipforward_rt, RTF_PRCLONING);
		if (ipforward_rt.ro_rt == 0) {
			icmp_error(m, ICMP_UNREACH, ICMP_UNREACH_HOST, dest, 0);
			return;
		}
		rt = ipforward_rt.ro_rt;
a1126 7

	/*
	 * Save at most 64 bytes of the packet in case
	 * we need to generate an ICMP message to the src.
	 */
	mcopy = m_copy(m, 0, imin((int)ip->ip_len, 64));

d1136 5
a1140 5
	if (rt->rt_ifp == m->m_pkthdr.rcvif &&
	    (rt->rt_flags & (RTF_DYNAMIC|RTF_MODIFIED)) == 0 &&
	    satosin(rt_key(rt))->sin_addr.s_addr != 0 &&
	    ipsendredirects && !srcrt) {
#define	RTA(rt)	((struct in_ifaddr *)(rt->rt_ifa))
d1142 1
d1144 4
a1147 4
		if (RTA(rt) &&
		    (src & RTA(rt)->ia_subnetmask) == RTA(rt)->ia_subnet) {
		    if (rt->rt_flags & RTF_GATEWAY)
			dest = satosin(rt->rt_gateway)->sin_addr.s_addr;
d1149 7
a1155 2
			dest = ip->ip_dst.s_addr;
		    /* Router requirements says to only send host redirects */
d1157 10
a1166 2
		    code = ICMP_REDIRECT_HOST;
#ifdef DIAGNOSTIC
d1168 1
a1168 2
			printf("redirect (%d) to %x\n", code, (u_long)dest);
#endif
d1172 2
a1173 5
	error = ip_output(m, (struct mbuf *)0, &ipforward_rt, IP_FORWARDING
#ifdef DIRECTED_BROADCAST
			    | IP_ALLOWBROADCAST
#endif
						, 0);
d1176 2
d1179 8
d1188 1
a1188 7
		if (type)
			ipstat.ips_redirectsent++;
		else {
			if (mcopy)
				m_freem(mcopy);
			return;
		}
d1192 2
a1193 2
	destifp = NULL;

d1197 2
a1198 1
		/* type, code set above */
d1201 1
a1201 2
	case ENETUNREACH:		/* shouldn't happen, checked above */
	case EHOSTUNREACH:
d1203 4
a1206 4
	case EHOSTDOWN:
	default:
		type = ICMP_UNREACH;
		code = ICMP_UNREACH_HOST;
a1209 1
		type = ICMP_UNREACH;
d1211 4
a1214 3
		if (ipforward_rt.ro_rt)
			destifp = ipforward_rt.ro_rt->rt_ifp;
		ipstat.ips_cantfrag++;
a1218 1
		code = 0;
a1219 3
	}
	icmp_error(mcopy, type, code, dest, destifp);
}
d1221 4
a1224 39
int
ip_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case IPCTL_FORWARDING:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ipforwarding));
	case IPCTL_SENDREDIRECTS:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
			&ipsendredirects));
	case IPCTL_DEFTTL:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ip_defttl));
	case IPCTL_SOURCEROUTE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ip_dosourceroute));
#ifdef notyet
	case IPCTL_DEFMTU:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ip_mtu));
#endif
	case IPCTL_RTEXPIRE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &rtq_reallyold));
	case IPCTL_RTMINEXPIRE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &rtq_minreallyold));
	case IPCTL_RTMAXCACHE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &rtq_toomany));
	default:
		return (EOPNOTSUPP);
d1226 2
a1227 1
	/* NOTREACHED */
d1230 1
a1230 39
#ifdef MULTICAST
int
ip_rsvp_init(struct socket *so)
{
	if (so->so_type != SOCK_RAW ||
	    so->so_proto->pr_protocol != IPPROTO_RSVP)
	  return EOPNOTSUPP;

	if (ip_rsvpd != NULL)
	  return EADDRINUSE;

	ip_rsvpd = so;
	/*
	 * This may seem silly, but we need to be sure we don't over-increment
	 * the RSVP counter, in case something slips up.
	 */
	if (!ip_rsvp_on) {
		ip_rsvp_on = 1;
		rsvp_on++;
	}

	return 0;
}

int
ip_rsvp_done(void)
{
	ip_rsvpd = NULL;
	/*
	 * This may seem silly, but we need to be sure we don't over-decrement
	 * the RSVP counter, in case something slips up.
	 */
	if (ip_rsvp_on) {
		ip_rsvp_on = 0;
		rsvp_on--;
	}
	return 0;
}
#endif
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@

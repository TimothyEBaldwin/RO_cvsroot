head	4.3;
access;
symbols
	Internet-5_65:4.3
	Internet-5_64:4.3
	Internet-5_63:4.3
	Internet-5_62:4.3
	Internet-5_61:4.3
	Internet-5_60:4.3
	Internet-5_59:4.3
	Internet-5_58:4.3
	Internet-5_57:4.3
	Internet-5_56:4.3
	Internet-5_55:4.3
	Internet-5_54:4.3
	Internet-5_53:4.3
	Internet-5_52:4.3
	Internet-5_51:4.3
	Internet-5_50:4.3
	RO_5_07:4.3
	Internet-5_49:4.3
	Internet-5_48:4.3
	Internet-5_47:4.3
	Internet-5_46:4.3
	Internet-5_45:4.3
	Internet-5_44:4.3
	Internet-5_43:4.3
	Internet-5_42:4.3
	Internet-5_41:4.3
	Internet-5_40:4.3
	Internet-5_39:4.3
	Internet-5_38:4.3
	Internet-5_37:4.3
	Internet-5_36:4.3
	Internet-5_35:4.3
	Internet-5_34:4.3
	Internet-5_33:4.3
	Internet-5_32:4.2
	Internet-5_31:4.2
	Internet-5_30:4.2
	Internet-5_29:4.2
	Internet-5_27:4.2
	Internet-5_26:4.2
	Internet-5_25:4.2
	Internet-5_24:4.2
	Internet-5_23:4.2
	Internet-5_22:4.2
	Internet-5_21:4.2
	Internet-5_20:4.2
	Internet-5_19:4.2
	Internet-5_18:4.2
	Internet-5_17:4.2
	Internet-5_16:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Internet-5_15:4.2
	Internet-5_14:4.2
	Internet-5_13:4.2
	sforrest_daytona_appflash-0_31:4.2
	Internet-5_12:4.2
	Internet-5_11:4.2
	celkins_Internet-5_10:4.2
	nicke_Internat_25-9-98:4.2
	Internet-5_09:4.2
	blaughto_daytona_appflash-0_30:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rwarren_Internet-5_08:4.2
	Spinner:4.2
	Internet_5_07:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.2
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.2
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.3
date	99.07.22.08.37.20;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.58.14;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.27.54;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.27.54;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.19.25;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.25.44;	author nturton;	state Exp;
branches;
next	4.1.3.2;

4.1.3.2
date	96.11.08.17.23.01;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.06.05;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.55.04;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.05.56;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.58.25;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.37.44;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.04;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.3
log
@* Used to send fragmented multicasts to the wrong link-level address. This
  is fixed by MbufManager 0.23, but a work-around has been incorporated
  into the Internet module.
* Ability to debug using PDebug instead of TML added.
* Various compilation hiccoughs when DEBUG defined fixed.

Version 5.33. Tagged as 'Internet-5_33'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * svcprint.c
 *
 * print debugging information down the TML tube link.
 *
 * provides:
 *	     %s - string
 *	     %C - character in range 20->7F (space printed if outside range)
 *	     %c - any character
 *	     %X - reverses order of bytes if >2 (or >4) specified as width
 *	     %x - hex
 *	     %B - reverses order of bytes if >2 (or >4) specified as width
 *	     %b - binary
 *	     %D - reverses order of bytes if >2 (or >4) specified as width
 *	     %d - decimal
 *	     %p - pointer ("@@xxxxxxxx")
 *
 * field width can be specified by placing a decimal number after the "%"
 * character... if the width is started by a "0" then numbers are padded
 * with "0"...
 *
 * standard format specifiers o,u,e,f and g are NOT supported
 *
 */
#include "kernel.h"
#include "swis.h"
#include "svcdebug.h"

#include "sys/types.h"

#ifndef NULL
# define NULL	((void *)0)
#endif

#ifdef DEBUG
/*int debug = 1;*/
#endif

#define USE_PDEBUG

/**********************************************************************/

/*static unsigned short ntohs(unsigned short n)
{
    return(((n << 8) & 0xff00) | ((n >> 8) & 0x00ff));
}*/

/**********************************************************************/

/*static unsigned long ntohl(unsigned long n)
{
    return(((n >> 24) & 0x000000ff) | ((n >> 8) & 0x0000ff00) |
	   ((n << 8) & 0x00ff0000) | ((n << 24) & 0xff000000) );
}*/

/**********************************************************************/

/*
 * call processor mode independant character output routine
 */
static void oswrch(unsigned char ch)
{
#ifdef USE_PDEBUG
    /*
     * use PDebug_Send (SWI 0x4F900) to print the character
     */
    _swix(0x4F900, _INR(0,2), 0, &ch, 1);
#else
    /*
     * use HostFS_WriteC (SWI 0x40102) to print the character
     */
    _swix(0x40102, _IN(0), ch);
#endif
}

/**********************************************************************/

/*
 * Printn prints a number n in base b, minimum width w adding pad chars
 * if needed.
 */
static void printn(unsigned n, unsigned b, int w, char pad)
{
    if( n >= b )
    {
	printn(n / b, b, --w, pad);
	oswrch("0123456789abcdef"[n % b]);
    }
    else
    {
	while (--w > 0)
	    oswrch(pad);

	oswrch("0123456789abcdef"[n]);
    }
}

/**********************************************************************/

static void prf(const char *format, unsigned *argp, ...)
{
    register int b; /* base to be used when displaying numbers */
    register int c; /* current character read from format string */
    register int w; /* field width */
    char pad;	    /* field padding character */
    unsigned val;   /* value of argument */

  loop:
    val = *argp;
    w = 0;
    pad = ' ';

    while( (c = *format++) != '%' )
    {
	if( c == '\0' )
	    return;
	if( c == '\n' )
	    oswrch('\r');
	oswrch(c);
    }

  again:
    /*
     * we have a special format command
     */
    c = *format++;
    switch( c )
    {
      case 's':
	{
	    /* string */
	    char *p = (char *)*argp++;
	    int	 width = 0;

	    if (p != NULL)
	    {
		/* NOT a NULL pointer */
		while (*p)
		{
		    oswrch(*p++);
		    width++;
		}
	    }

	    while( width++ < w )
		oswrch(' ');
	    goto loop;
	}

      case 'C':
	if( (*argp < ' ') || (*argp > '~') )
	{
	    oswrch(' ');
	    argp++;
	    goto loop;
	}

      case 'c':
	/* character */
	oswrch(*argp++);
	goto loop;

      case '0':
	if (w == 0)
	    pad = '0';

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
	/* field width */
	w = (w * 10) + ((int) c - '0');
	goto again;

      case 'X':
	/* hex number */
	if (w > 4)
	    val = (unsigned)ntohl(val);
	else
	{
	    if (w > 2)
		val = (unsigned)ntohs(val);
	}

	/*
	 * NB
	 *
	 * fall through to set base
	 */

      case 'x':
	/* hex number */
	b = 16;
	goto number;

      case 'p':
      	/* pointer */
      	oswrch('@@');
      	w = 8;
      	pad = '0';
      	b = 16;
      	goto number;

      case 'B':
	/* binary number */
	if (w > 4)
	    val = (unsigned)ntohl(val);
	else
	{
	    if( w > 2 )
		val = (unsigned)ntohs(val);
	}

	/*
	 * NB
	 *
	 * fall through to set base
	 */

      case 'b':
	/* binary number */
	b = 2;
	goto number;

      case 'D':
	/* decimal number */
	if (w > 4)
	    val = (unsigned)ntohl(val);
	else
	{
	    if (w > 2)
		val = (unsigned)ntohs(val);
	}

	/*
	 * NB
	 *
	 * fall through to set base
	 */

      case 'd':
	b = 10;
	/*
	 * NB
	 *
	 * fall through to write number
	 */

      number:
	printn(val,b,w,pad);
	argp++;

	break;
    } /* switch */

    goto loop;
}


/**********************************************************************/

#if 0
# define USETUBE
#endif /* 0/1 */

void Printf(const char *format, ...)
{
    unsigned *argp = (unsigned *)&format;
    static int inprf;

#ifdef USETUBE
    _kernel_swi_regs reglist;
    _kernel_oserror *err;
/*     int s = splhi(); */

    if( (err = _kernel_swi(0x40100, &reglist, &reglist)) != NULL )
    {
	prf("HostVDU: ", 0);
	prf(err->errmess, 0);
/*	splx(s); */
	return;
    }
#endif /* USETUBE */

    /*int s = splhi();*/
    if (inprf)
        return;

    inprf=1;
    prf(format, (argp + 1));
    inprf=0;
    /*splx(s);*/

#ifdef USETUBE
    if( (err = _kernel_swi(0x40101, &reglist, &reglist)) != NULL )
    {
	prf("TubeVDU: ", 0);
	prf(err->errmess, 0);
/*	splx(s); */
	return;
    }
/*    splx(s); */
#endif /* USETUBE */
}


/**********************************************************************/

/* EOF svcprint.c */
@


4.2
log
@Version Spinner_B7 taken
@
text
@d53 2
d77 6
a82 2
    _kernel_swi_regs regset;

d86 2
a87 2
    regset.r[0] = ch;
    (void)_kernel_swi(0x40102, &regset, &regset);
d114 1
a114 1
static void prf(char *format, unsigned *argp, ...)
d285 1
a285 1
void Printf(char *format, ...)
@


4.1
log
@Initial revision
@
text
@d15 1
a15 7
/* -*-C-*-
 *
 * $Header: /ax/networking:Internet/build/svcprint.c:networking  1.2  $
 * $Source: /ax/networking:Internet/build/svcprint.c: $
 *
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
 *
d30 1
a37 7
 * $Log:	svcprint.c,v $
 * Revision 1.2  95/03/31  11:36:04  kwelton
 * Added new debugging function ctosym().
 * 
 * Revision 1.1  94/12/02  09:57:20  kwelton
 * Initial revision
 * 
d50 1
a50 1
int debug = 1;
d55 1
a55 1
static unsigned short ntohs(unsigned short n)
d58 1
a58 1
}
d62 1
a62 1
static unsigned long ntohl(unsigned long n)
d66 1
a66 1
}
d209 8
a271 12
/**********************************************************************/

/*
 * strprint - print a string to the tube podule
 */
static void strprint(char *s)
{
    _kernel_swi_regs r;

    r.r[0] = (int)s;
    (void)_kernel_swi(0x40104, &r, &r);
}
d282 1
d298 5
a302 1
    int s = splhi();
d304 2
a305 1
    splx(s);
a318 130
/**********************************************************************/

/*
 * ctosym - convert an address to an entry in the module's symbol
 * table
 */
int ctosym(caddr_t ptr)
{
    /*
     * XXX
     *
     * declare __module_header as an external *function*
     * -- this stops it being incorrectly relocated
     */
    extern void __module_header(void);
    caddr_t address = (caddr_t)__module_header;

    /*
     * the hard part has alredy been done (finding the start
     * address of the module) - all that remains is to convert
     * passed pointer to an offset within the module.
     *
     * XXX
     *
     * the linker assumes a default offset of 32k, even for
     * modules, when writing the symbol table; this could
     * be considered a bug, but it is easily overcome.
     */
    return((ptr - address) + 0x8000);
}

/**********************************************************************/

#define	FCMAX	40
#ifdef	GPROF
#define FN_ENTRY_SIZE (5+3)	/* -p adds an extra 3 words to procedure entry */
#else	GPROF
#define FN_ENTRY_SIZE (5)
#endif	GPROF

backtrace(int dummy)
{
    int frames = FCMAX;
    int *fp, *ip, i;
    int linechars = 0;
    char *sep = "\021\004Stack backtrace: ";
    char card[81];

    fp = (int *)&dummy - 1;  /* Points at stacked entry mask pointer */
    fp = (int *)fp[-3];	 /* Points at	  ditto of caller */

    /*
     * NOTE
     *
     * this stack backtracing loop works only
     * for code from the Norcroft compiler.
     */

    /* limit the scan number of frames backtraced  */
    while( frames-- >= 0 )
    {
	int *next_fp;
	char *name = NULL;

	ip = ((int *)(fp[0] & 0x03fffffc)) - 3;

	/* ip now points at stmdb sp!, { .., fp, ip, lr, pc } */
	for( i = FN_ENTRY_SIZE; i > 0; i-- )
	{
	    if( (ip[0] & 0xffffff00) == 0xff000000 )
	    {
		int len = ip[0] & 0xff;
		if( (len % 4) == 0 )
		{
		    name = (char *)ip - len;
		    break;
		}
	    }
	    ip--;
	}

	if (name == NULL)
	    sprintf(card, "%s<fn@@%08x>", sep, ip+3);
	else
	    sprintf(card, "%s%s", sep, name);

	sep = ", ";

	linechars += strlen(card);
	if( linechars >= 80 )
	{
	    strprint(",\r\n	");
	    strprint(card + 2);
	    linechars = 5;
	}
	else
	    strprint(card);

	/* TRACE */
	if( !strcmp(name, "callb_handler") )
	{
	    /*
	     * I think this is what is breaking
	     * the debugging module
	     */
	    strprint(" (and that's as far as we're going)");
	    break;
	}

	next_fp = (int *)(fp[-3]);
	if (next_fp == 0)
	    break;
	else
	{
#ifdef __KERNEL__
	    if( (next_fp < fp) ||
	       (next_fp > (int *)((int)&u + (UPAGES*NBPG))) )
#else
	    if( (next_fp < fp ) )
#endif
	    {
		Printf("**** broken stack frame fp %08x, next fp %08x ****\n",
		       fp, next_fp);
		break;
	    }
	    fp = next_fp;
	}
    }
    Printf("\021\007\n");
}
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d15 7
a21 1
/*
a35 1
 *	     %p - pointer ("@@xxxxxxxx")
d43 7
d62 1
a62 1
/*int debug = 1;*/
d67 1
a67 1
/*static unsigned short ntohs(unsigned short n)
d70 1
a70 1
}*/
d74 1
a74 1
/*static unsigned long ntohl(unsigned long n)
d78 1
a78 1
}*/
a220 8
      case 'p':
      	/* pointer */
      	oswrch('@@');
      	w = 8;
      	pad = '0';
      	b = 16;
      	goto number;

d276 12
a297 1
    static int inprf;
d313 1
a313 5
    /*int s = splhi();*/
    if (inprf)
        return;

    inprf=1;
d315 1
a315 2
    inprf=0;
    /*splx(s);*/
d329 130
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@RCS log keyword removed
@
text
@d43 1
a43 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d43 1
a43 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a35 1
 *	     %p - pointer ("@@xxxxxxxx")
d46 1
a46 1
 *
d49 1
a49 1
 *
d62 1
a62 1
/*int debug = 1;*/
a220 8
      case 'p':
      	/* pointer */
      	oswrch('@@');
      	w = 8;
      	pad = '0';
      	b = 16;
      	goto number;

d276 12
a297 1
    static int inprf;
d313 1
a313 5
    /*int s = splhi();*/
    if (inprf)
        return;

    inprf=1;
d315 1
a315 2
    inprf=0;
    /*splx(s);*/
d329 130
@


4.1.3.2
log
@RCS Log keyword removed
@
text
@d44 1
a44 1
 * :RCS Log discontinued:
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d43 1
a43 1
 * :RCS Log discontinued:
@

head	4.9;
access;
symbols
	Internet-5_65:4.9
	Internet-5_64:4.9
	Internet-5_63:4.9
	Internet-5_62:4.9
	Internet-5_61:4.9
	Internet-5_60:4.9
	Internet-5_59:4.9
	Internet-5_58:4.9
	Internet-5_57:4.9
	Internet-5_56:4.9
	Internet-5_55:4.9
	Internet-5_54:4.9
	Internet-5_53:4.9
	Internet-5_52:4.7
	Internet-5_51:4.7
	Internet-5_50:4.7
	RO_5_07:4.7
	Internet-5_49:4.7
	Internet-5_48:4.7
	Internet-5_47:4.7
	Internet-5_46:4.7
	Internet-5_45:4.7
	Internet-5_44:4.7
	Internet-5_43:4.7
	Internet-5_42:4.6
	Internet-5_41:4.6
	Internet-5_40:4.5
	Internet-5_39:4.5
	Internet-5_38:4.5
	Internet-5_37:4.4
	Internet-5_36:4.4
	Internet-5_35:4.4
	Internet-5_34:4.4
	Internet-5_33:4.3
	Internet-5_32:4.3
	Internet-5_31:4.3
	Internet-5_30:4.3
	Internet-5_29:4.3
	Internet-5_27:4.3
	Internet-5_26:4.2
	Internet-5_25:4.2
	Internet-5_24:4.2
	Internet-5_23:4.2
	Internet-5_22:4.2
	Internet-5_21:4.2
	Internet-5_20:4.2
	Internet-5_19:4.2
	Internet-5_18:4.2
	Internet-5_17:4.2
	Internet-5_16:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Internet-5_15:4.2
	Internet-5_14:4.2
	Internet-5_13:4.2
	sforrest_daytona_appflash-0_31:4.2
	Internet-5_12:4.2
	Internet-5_11:4.2
	celkins_Internet-5_10:4.2
	nicke_Internat_25-9-98:4.2
	Internet-5_09:4.2
	blaughto_daytona_appflash-0_30:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rwarren_Internet-5_08:4.2
	Spinner:4.2
	Internet_5_07:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.2
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.2
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.9
date	2011.12.15.22.20.02;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	TVCPLXal0LzsSkLv;

4.8
date	2011.12.15.22.13.56;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	HZIJ91eGy2SeQkLv;

4.7
date	2000.07.05.14.48.26;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2000.05.12.11.49.03;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.11.11.15.18.58;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.07.28.12.00.06;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.06.30.13.15.29;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.58.22;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.27.59;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.27.59;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.19.37;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.25.51;	author nturton;	state Exp;
branches;
next	4.1.3.2;

4.1.3.2
date	96.11.08.17.23.08;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.06.17;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.55.35;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.06.10;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.58.52;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.37.56;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.09;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.9
log
@Delete local user_mode_donothing() and replace with usermode_donothing() from AsmUtils.
Makefilse uses ModuleLibs too.
Lots of STM/LDM replaced with Push and Pull macros.
Local definitions in 'swiveneers' replaced with header files.

Version 5.53. Tagged as 'Internet-5_53'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;
; Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
;
; Assembler function to enable podule irqs
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:EnvNumbers
        GET     Hdr:ModHand
        GET     Hdr:APCS.<APCS>

        EXPORT  splet
        EXPORT  splimp
        EXPORT  splnet
        EXPORT  splx
        EXPORT  splhi
        EXPORT  ensure_irqs_on
        EXPORT  restore_irqs
        EXPORT  splrestore
        EXPORT  in_cksum_hdr
        EXPORT  get_t0_count

        ^       0

        AREA    poduleirqs, PIC, CODE, REL, READONLY

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; splhi etc:
;
; Disable IRQs). Once IRQs are disabled, we cannot/must not be reentered.
;
; Returns a value indicating the state of interrupts prior to calling here.
;

splhi
splet
splnet
splimp
        [ {CONFIG}=26
        AND     r0, lr, # I_bit
        ORRS    pc, lr, # I_bit
        |
        MRS     a1, CPSR
        ORR     a2, a1, #I32_bit
        MSR     CPSR_c, a2
        AND     a1, a1, #I32_bit
        MOV     pc, lr
        ]


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ensure_irqs_on:
;
; Ensure that interrupts are enabled. Returns a value that, when passed
; to restore_irqs, will restore the state prior to enabling interrupts.
;

ensure_irqs_on
        [ {CONFIG}=26
        AND     r0, lr, # I_bit
        BICS    pc, lr, # I_bit
        |
        MRS     a1, CPSR
        BIC     a2, a1, #I32_bit
        MSR     CPSR_c, a2
        AND     a1, a1, #I32_bit
        MOV     pc, lr
        ]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; restore_irqs etc:
;
; Restore interrupts to the state they were in prior to a call to
; splhi, using the value returned by splhi.
;

restore_irqs
splrestore
splx
        [ {CONFIG}=26
        BIC     lr, lr, # I_bit
        ORRS    pc, lr, r0
        |
        MRS     a2, CPSR
        BIC     a2, a2, #I32_bit
        ORR     a2, a2, a1
        MSR     CPSR_c, a2
        MOV     pc, lr
        ]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; get_t0_count
;
; Read the current value in Timer 0.
;

get_t0_count
        [ {CONFIG}=26
        MOV     r12,lr
        MOV     r3,#IOC
; Shut off interrupts (briefly) to ensure an atomic read of these
; silly hardware registers.
        TEQP    pc,#I_bit :OR: SVC_mode
        STRB    r3,[r3,#Timer0LR]
        LDRB    r1,[r3,#Timer0CL]
        LDRB    r0,[r3,#Timer0CH]
        ORR     r0,r1,r0,LSL #8
        MOVS    pc,r12                  ; Will restore mode and interrupt status
        |
        MOV     r3,#IOC
; Shut off interrupts (briefly) to ensure an atomic read of these
; silly hardware registers.
        MRS     r2,CPSR
        ORR     r0,r2,#I32_bit
        MSR     CPSR_c,r0
        STRB    r3,[r3,#Timer0LR]
        LDRB    r1,[r3,#Timer0CL]
        LDRB    r0,[r3,#Timer0CH]
        MSR     CPSR_c,r2
        ORR     r0,r1,r0,LSL #8
        MOV     pc,lr
        ]



;
; Hyper-fast simple-case IP header checksum
;

in_cksum_hdr
        ; Load 20 bytes of IP header
        LDMIA   a1,{a1-a4,ip}

        ; Calculate 1's-complement sum of the 5 32-bit words.
        ADDS    a1,a1,a2
        ADCS    a1,a1,a3
        ADCS    a1,a1,a4
        ADCS    a1,a1,ip
        ADC     a1,a1,#0

        ; Fold two 16-bit words together - top half will
        ; contain the 1's complement sum
        ADD     a1,a1,a1,ROR #16

        ; Take the 1's-complement of the result
        MVN     a1,a1

        ; And shift it down to the bottom
        MOV     a1,a1,LSR #16

        Return  ,LinkNotStacked

        ^       0
m_next  #       4
m_list  #       4
m_off   #       4
m_len   #       4

        [ {TRUE}

        EXPORT  in_cksum

;
; This routine is engineered to be rapid on cached ARMs.
; See RFC1072 for the 1's-complement arithmetic tricks used.
;
; The routine is engineered with the following points in mind:
;    Arithmetic operations, including constant shifts, take 1 tick
;    Arithmetic operations with register shifts take 2 ticks
;    Unexecuted instructions take 1 tick
;    Branches take 3 ticks
;    An LDM of n registers is significantly faster than n LDRs
;
; The amount to "unroll" the loop is an issue.  On an ARM710,
; doing 64 bytes at a time appears to be significantly (11-12%) faster
; on average than doing 32 bytes at a time.  The trade-off
; between reducing the number of branches and utilising burst-reads,
; and the filling of the instruction cache, will differ from processor
; to processor.  This sort of slight tweaking is probably trivial
; compared to the 8 times speedup over the bytewise in_cksum routine
; present in Internet 4.08...
;
; The mind boggles at a "processor-tuned" variation of the standard
; BSD in_cksum routine that manages to be under half the speed.
;
; In speed tests, trying 16-byte blocks after 64-byte blocks does not
; noticeably affect the speed. This probably means that it will actually
; increase the speed in real use, when this routine is called less
; often, as it makes the routine smaller, hence disrupting the cache less.
;
; On entry:
;      a1 -> first mbuf
;      a2 -> length to checksum
;
; Throughout routine:
;      a1 = current mbuf
;      a2 = length remaining to checksum
;      v1 = data ptr
;      v2 = length remaining of mbuf
;      v3 = total rotate of checksum
;      ip = checksum
;
;      a3-a4,v4-v6,sl,fp,lr = general work registers
;
;    In final 64 bytes:
;      a3 = number of bits present in final word (0-31)
;
        ROUT
in_cksum
        FunctionEntry "v1-v6,sl,fp"

        ; Start off checksum and rotate
        MOV     v3, #0
        MOV     ip, #0

99      LDR     v1,[a1,#m_off]
        ; v2 = length of mbuf
        LDR     v2,[a1,#m_len]

        ; v1 = ptr to data
        ADD     v1,a1,v1

        ; if mlen > len, mlen = len
        CMPS    v2,a2
        MOVHI   v2,a2

        ; len -= mlen
        SUB     a2,a2,v2

        ANDS    a3,v1,#3
        BLNE    fiddly

        ; If we have 64 bytes, do it fast (utilising burst
        ; reads)
        SUBS    v2,v2,#64
        BMI     %F97
0       LDMIA   v1!,{a3,a4,v4,v5,v6,sl,fp,lr}
        ADDS    ip,ip,a3
        ADCS    ip,ip,a4
        ADCS    ip,ip,v4
        ADCS    ip,ip,v5
        ADCS    ip,ip,v6
        ADCS    ip,ip,sl
        ADCS    ip,ip,fp
        ADCS    ip,ip,lr
        LDMIA   v1!,{a3,a4,v4,v5,v6,sl,fp,lr}
        ADCS    ip,ip,a3
        ADCS    ip,ip,a4
        ADCS    ip,ip,v4
        ADCS    ip,ip,v5
        ADCS    ip,ip,v6
        ADCS    ip,ip,sl
        ADCS    ip,ip,fp
        ADCS    ip,ip,lr
        ADC     ip,ip,#0

        SUBS    v2,v2,#64
        BGE     %B0

        ; If we have 16 bytes, do it fast (utilising burst
        ; reads)
97      ADDS    v2,v2,#64-16
        BMI     %F1
98      LDMIA   v1!,{a3,a4,v4,v5}
        ADDS    ip,ip,a3
        ADCS    ip,ip,a4
        ADCS    ip,ip,v4
        ADCS    ip,ip,v5
        ADC     ip,ip,#0

        SUBS    v2,v2,#16
        BGE     %B98

        ; Right, down to < 16 bytes.
        ; However we get here, C is clear

        ; Do we have an "odd" number?
1       ANDS    a3,v2,#3       ; Doesn't alter C
        BEQ     %F2

        ; Yes we do. Argh!

        ; a3 is no of bytes present in incomplete word
        ; Get lr to point to end word
        SUB     lr,v2,a3
        ADD     lr,lr,#16
        ; Load word containing end-point. This will give us a3 bits
        ; that need to be ignored (high-bits).
        LDR     a4,[v1,lr]

        ; set a3 to no of bits present in incomplete word
        MOV     a3,a3,LSL #3
        ; set lr to number of bits missing in incomplete word
        RSB     lr,a3,#32
        ; clear bits to be ignored
        MOV     a4,a4,LSL lr
        ; add incomplete word to checksum
        ADDS    ip,ip,a4,LSR lr
        ; reduce amount left to read so the following code
        ; will only sum remaining whole words
        BIC     v2,v2,#3

        ; Now we continue. Note that as we reach label 2, a3 will
        ; be set to the number of extra bits beyond the complete
        ; words in the mbuf.

        ; Branch as appropriate to sum remaining 0-3 words
        ; Note that state of C as we reach this point is significant;
        ; if we didn't go through the incomplete word malarky, C
        ; must be clear, otherwise we take C from previous ADDS
        ; (although this will of course be clear also).
        ;
        ; Can't really loop here as any sort of end-of-loop test
        ; will corrupt the C flag.
2       SUB     pc,pc,v2,LSL #1
        NOP
        NOP                       ; Can't get here (honest!)
        NOP
        LDR     a4,[v1],#4        ; 12
        ADCS    ip,ip,a4
        LDR     a4,[v1],#4        ; 8
        ADCS    ip,ip,a4
        LDR     a4,[v1]           ; 4
        ADCS    ip,ip,a4
        ADC     ip,ip,#0          ; 0

        ; Have we finished?
        TEQS    a2,#0
        BEQ     %F03

        ; Now then, now then, now then. If this mbuf did not have
        ; a complete number of words, the next one will have "rotated
        ; words". Eg in 3 mbufs of 5 bytes:
        ;
        ; [(A B C D) (A)] -> [(B C D A) (B)] -> [(C D A B) (C)]
        ;
        ; to cope with this, rotate the checksum so far to match
        ; the rotation state of the next mbuf (eg rotate it one byte
        ; left in the above example), and keep track of the total
        ; rotations done in v3, so we can unwind at the end.
        ;
        MOV     ip,ip,ROR a3
        SUB     v3,v3,a3

        ; Back to the top for the next mbuf!
        LDR     a1,[a1,#m_next]
        B       %B99

3       MOV     ip,ip,ROR v3

        ; Fold two 16-bit words together - top half will
        ; contain the 1's complement sum
        ADD     a1,ip,ip,ROR #16

        ; Take the 1's-complement of the result
        MVN     a1,a1

        ; Shift it down to the bottom
        MOV     a1,a1,LSR #16

        ; And... relax.
        Return  "v1-v6,sl,fp"

        ; This is very rare, so separate it off down here
        ; can't be bothered to optimise
        ; a3 is number of missing bytes
fiddly
        ; Check if out of data
        TEQS    v2,#0
        MOVEQ   pc,lr

        ; Load byte
11      LDRB    a4,[v1],#1
        ; Add to checksum
        ADDS    ip,ip,a4
        ADC     ip,ip,#0
        ; Rotate checksum
        MOV     ip,ip,ROR #8
        SUB     v3,v3,#8
        ; Reduce counter
        SUBS    v2,v2,#1
        MOVEQ   pc,lr
        TSTS    v1,#3
        BNE     %B11
        MOV     pc,lr

        ]

        END



; EOF poduleirq.s
@


4.8
log
@Retab assembler to reduce diffs.
Not tagged.
@
text
@a27 1
        EXPORT  user_mode_donothing
a42 16
        ALIGN

; os_error *usermode_donothing();
user_mode_donothing ROUT

        FunctionEntry

        ; Now execute a SWI in user mode to trigger callbacks
        WritePSRc 0, r0                 ; IRQs on, user mode
        MOV r0, #0
        MOV r1, #1
        SWI XOS_Byte                    ; Read OS version
        SWI XOS_EnterOS                 ; Back to SVC mode

        Return

@


4.7
log
@Restored DELAY_EVENTS functionality.

Detail:
VideoControl was having a nasty reentrancy problem inside its event handler;
we've been sending out events at points where a BSD Unix system wouldn't and
exposing a number of potential problems. Fixed by restoring the delayed event
scheme used in earlier versions of Internet 5, but with an extra event send
inside the packet input loop which should alleviate the high load problems
seen with the NEC video client.

Seems to work fine, but we've been unable to get the NEC video client to
work at all, let alone test it on this Internet module. Doesn't matter for
now because we're not shipping it :)

Version 5.43. Tagged as 'Internet-5_43'
@
text
@d21 5
a25 5
	GET	Hdr:ListOpts
	GET	Hdr:Macros
	GET	Hdr:System
	GET	Hdr:EnvNumbers
	GET	Hdr:ModHand
d28 11
a38 11
	EXPORT	user_mode_donothing
	EXPORT	splet
	EXPORT	splimp
	EXPORT	splnet
	EXPORT	splx
	EXPORT	splhi
	EXPORT	ensure_irqs_on
	EXPORT	restore_irqs
	EXPORT	splrestore
	EXPORT  in_cksum_hdr
	EXPORT	get_t0_count
d40 1
a40 1
	^	0
d42 1
a42 1
	AREA	poduleirqs, PIC, CODE, REL, READONLY
d44 1
a44 1
	ALIGN
d51 1
a51 1
	; Now execute a SWI in user mode to trigger callbacks
d53 4
a56 4
	MOV r0, #0
	MOV r1, #1
	SWI XOS_Byte			; Read OS version
	SWI XOS_EnterOS			; Back to SVC mode
d74 2
a75 2
	AND	r0, lr, # I_bit
	ORRS	pc, lr, # I_bit
d95 2
a96 2
	AND	r0, lr, # I_bit
	BICS	pc, lr, # I_bit
d117 2
a118 2
	BIC	lr, lr, # I_bit
	ORRS	pc, lr, r0
d168 2
a169 2
	; Load 20 bytes of IP header
	LDMIA	a1,{a1-a4,ip}
d171 6
a176 6
	; Calculate 1's-complement sum of the 5 32-bit words.
	ADDS	a1,a1,a2
	ADCS	a1,a1,a3
	ADCS	a1,a1,a4
	ADCS	a1,a1,ip
	ADC	a1,a1,#0
d190 5
a194 5
	^	0
m_next	#	4
m_list	#	4
m_off	#	4
m_len	#	4
d196 1
a196 1
	[ {TRUE}
d198 1
a198 1
	EXPORT	in_cksum
d245 1
a245 1
	ROUT
d249 136
a384 136
	; Start off checksum and rotate
	MOV	v3, #0
	MOV	ip, #0

99	LDR	v1,[a1,#m_off]
	; v2 = length of mbuf
	LDR	v2,[a1,#m_len]

	; v1 = ptr to data
	ADD	v1,a1,v1

	; if mlen > len, mlen = len
	CMPS	v2,a2
	MOVHI	v2,a2

	; len -= mlen
	SUB	a2,a2,v2

	ANDS	a3,v1,#3
	BLNE	fiddly

	; If we have 64 bytes, do it fast (utilising burst
	; reads)
	SUBS	v2,v2,#64
	BMI	%F97
0	LDMIA	v1!,{a3,a4,v4,v5,v6,sl,fp,lr}
	ADDS	ip,ip,a3
	ADCS	ip,ip,a4
	ADCS	ip,ip,v4
	ADCS	ip,ip,v5
	ADCS	ip,ip,v6
	ADCS	ip,ip,sl
	ADCS	ip,ip,fp
	ADCS	ip,ip,lr
	LDMIA	v1!,{a3,a4,v4,v5,v6,sl,fp,lr}
	ADCS	ip,ip,a3
	ADCS	ip,ip,a4
	ADCS	ip,ip,v4
	ADCS	ip,ip,v5
	ADCS	ip,ip,v6
	ADCS	ip,ip,sl
	ADCS	ip,ip,fp
	ADCS	ip,ip,lr
	ADC	ip,ip,#0

	SUBS	v2,v2,#64
	BGE	%B0

	; If we have 16 bytes, do it fast (utilising burst
	; reads)
97	ADDS	v2,v2,#64-16
	BMI	%F1
98	LDMIA	v1!,{a3,a4,v4,v5}
	ADDS	ip,ip,a3
	ADCS	ip,ip,a4
	ADCS	ip,ip,v4
	ADCS	ip,ip,v5
	ADC	ip,ip,#0

	SUBS	v2,v2,#16
	BGE	%B98

	; Right, down to < 16 bytes.
	; However we get here, C is clear

	; Do we have an "odd" number?
1	ANDS	a3,v2,#3       ; Doesn't alter C
	BEQ	%F2

	; Yes we do. Argh!

	; a3 is no of bytes present in incomplete word
	; Get lr to point to end word
	SUB	lr,v2,a3
	ADD	lr,lr,#16
	; Load word containing end-point. This will give us a3 bits
	; that need to be ignored (high-bits).
	LDR	a4,[v1,lr]

	; set a3 to no of bits present in incomplete word
	MOV	a3,a3,LSL #3
	; set lr to number of bits missing in incomplete word
	RSB	lr,a3,#32
	; clear bits to be ignored
	MOV	a4,a4,LSL lr
	; add incomplete word to checksum
	ADDS	ip,ip,a4,LSR lr
	; reduce amount left to read so the following code
	; will only sum remaining whole words
	BIC	v2,v2,#3

	; Now we continue. Note that as we reach label 2, a3 will
	; be set to the number of extra bits beyond the complete
	; words in the mbuf.

	; Branch as appropriate to sum remaining 0-3 words
	; Note that state of C as we reach this point is significant;
	; if we didn't go through the incomplete word malarky, C
	; must be clear, otherwise we take C from previous ADDS
	; (although this will of course be clear also).
	;
	; Can't really loop here as any sort of end-of-loop test
	; will corrupt the C flag.
2	SUB	pc,pc,v2,LSL #1
	NOP
	NOP			  ; Can't get here (honest!)
	NOP
	LDR	a4,[v1],#4	  ; 12
	ADCS	ip,ip,a4
	LDR	a4,[v1],#4        ; 8
	ADCS	ip,ip,a4
	LDR	a4,[v1]           ; 4
	ADCS	ip,ip,a4
	ADC	ip,ip,#0          ; 0

	; Have we finished?
	TEQS	a2,#0
	BEQ	%F03

	; Now then, now then, now then. If this mbuf did not have
	; a complete number of words, the next one will have "rotated
	; words". Eg in 3 mbufs of 5 bytes:
	;
	; [(A B C D) (A)] -> [(B C D A) (B)] -> [(C D A B) (C)]
	;
	; to cope with this, rotate the checksum so far to match
	; the rotation state of the next mbuf (eg rotate it one byte
	; left in the above example), and keep track of the total
	; rotations done in v3, so we can unwind at the end.
	;
	MOV	ip,ip,ROR a3
	SUB	v3,v3,a3

	; Back to the top for the next mbuf!
	LDR	a1,[a1,#m_next]
	B	%B99
d386 1
a386 1
3	MOV	ip,ip,ROR v3
d398 1
a398 1
	; And... relax.
d401 3
a403 3
	; This is very rare, so separate it off down here
	; can't be bothered to optimise
	; a3 is number of missing bytes
d405 18
a422 18
	; Check if out of data
	TEQS	v2,#0
	MOVEQ	pc,lr

	; Load byte
11	LDRB	a4,[v1],#1
	; Add to checksum
	ADDS	ip,ip,a4
	ADC	ip,ip,#0
	; Rotate checksum
	MOV	ip,ip,ROR #8
	SUB	v3,v3,#8
	; Reduce counter
	SUBS	v2,v2,#1
	MOVEQ	pc,lr
	TSTS	v1,#3
	BNE	%B11
	MOV	pc,lr
d424 1
a424 1
	]
d426 1
a426 1
	END
@


4.6
log
@32-bit code modified to use new macros, plus a couple of fixes.
A (tiny) checksumming speed-up, courtesy of David Seal.

Version 5.41. Tagged as 'Internet-5_41'
@
text
@a27 1
	EXPORT	escape_seen
a44 19

; This routine returns 1 if escape condition set, else 0
escape_seen
        FunctionEntry
	SWI	XOS_ReadEscapeState
	MOVCS	r0, #1
	MOVCC	r0, #0

; I don't think it's up to us to acknowledge the escape condition
; It's the callee's problem
	[ {TRUE}
        Return
	|
	STMFD r13!,{r0}
	MOV r0, #126			; OS_Byte 126 = Acknowledge escape condition
	SWI XOS_Byte

        Return "r0"
	]
@


4.5
log
@Now 32-bit compatible, in a suitable build environment. In the standard
26-bit build environment it is unchanged, except for a fix in the "Module
Internet cannot be RAM loaded" checker.

Version 5.38. Tagged as 'Internet-5_38'
@
text
@d26 1
d49 1
a49 1
	STMFD	sp!,{lr}
d57 1
a57 5
        [ {CONFIG}=26
	LDMFD	sp!,{pc}^
        |
	LDMFD	sp!,{pc}
        ]
d63 1
a63 5
        [ {CONFIG}=26
	LDMFD r13!,{r0,pc}^
        |
	LDMFD r13!,{r0,pc}
        ]
d69 1
a69 1
	STMFD r13!,{lr}
d72 1
a72 7
        [ {CONFIG}=26
	TEQP pc, #0			; To user mode
        |
        MRS r0, CPSR
        BIC r0, r0, #&C3                ; IRQs off, user mode
        MSR CPSR_ctl, r0
        ]
d78 1
a78 5
        [ {CONFIG}=26
	LDMFD r13!,{pc}^
        |
	LDMFD r13!,{pc}
        ]
d99 2
a100 1
        MSR     CPSR_ctl, a2
d120 2
a121 1
        MSR     CPSR_ctl, a2
d140 4
a143 1
        MSR     CPSR_ctl, a1
d172 1
a172 1
        MSR     CPSR_ctl,r0
d176 1
a176 1
        MSR     CPSR_ctl,r2
d198 11
a208 13
	; Fold two 16-bit words together
	; May be left with 16-bit carry
	ADDS	a1,a1,a1,LSL #16

	; See below for the explanation of this bit
	MVN	a2,#0
	RSC	a1,a2,a1,LSR #16
	EOR	a1,a1,a2,LSR #16
        [ {CONFIG}=26
	MOVS	pc,lr
        |
	MOV	pc,lr
        ]
d267 1
a267 1
	STMFD	sp!,{v1-v6,sl,fp,lr}
a272 1
	; v1 = ptr to data
a273 2
	ADD	v1,a1,v1

d277 3
d408 6
a413 10
	; Fold two 16-bit words together
	; May be left with 16-bit carry
	ADDS	a1,ip,ip,LSL #16

	; Useful constant...
	MVN	a2,#0

	; This means a1=(a1>>16)+C, would you believe it.
	; The things we do to save a single instruction :-)
	RSC	a1,a2,a1,LSR #16
d415 2
a416 2
	; Take the 1's-complement of the (16-bit) result
	EOR	a1,a1,a2,LSR #16
d419 1
a419 5
        [ {CONFIG}=26
	LDMFD   sp!,{v1-v6,sl,fp,pc}^
        |
	LDMFD   sp!,{v1-v6,sl,fp,pc}
        ]
@


4.4
log
@microtime() now returns microsecond accuracy.
Random number generator now seeded from microtime(), machine ID and
hardware addresses of DCI drivers.
Some previously untested debugging code fixed to compile.

Version 5.34. Tagged as 'Internet-5_34'
@
text
@a26 3
	GBLL	DeferCallbacks
DeferCallbacks SETL	{FALSE}

a30 1
	EXPORT	splimp2
a33 1
	EXPORT	splhi2
d56 1
d58 3
d66 1
d68 3
a72 21
	[ DeferCallbacks

; This callback handler simple defers the callback until later
; Note that this may be entered in IRQ or SVC mode
defer_callback
	MOV	r8, pc			; Save current status/mode
	ORR	r8, r8, #SVC_Mode	; Derive SVC-mode version of it
	TEQP	r8, #0			; Enter SVC mode
	NOP
	SWI	XOS_SetCallBack		; Defer callback
	MOV	r14, r12		; Register block
	LDMIA	r14, {r0-r14}^		; Loads USR r13,r14
	NOP				; NOOP after accessing user
					; registers before accessing banked
					; register.
	LDR	r14, [r14, #15*4]	; Loads user PC into SVC r14
	MOVS	pc, r14			; Drop back to USR mode

	]


a76 17
	[ DeferCallbacks
	SUB sp, sp, #&40		; Make space on stack for reg dump

	; Update callback handler atomically in case an event occurs
	; between reading the old handler and writing the new handler
	;
        ; Callback handler needs defering so that escape code doesn't blow
        ; away the program which called this SWI before this SWI returns.
	MOV r0, #CallBackHandler
	ADR r1, defer_callback
	MOV r2, sp			; R12 in defer_callback = reg ptr
	MOV r3, sp			; Reg save area on stack
	SWI XOS_ChangeEnvironment
	STMVCFD r13!,{r1-r3}		; Save old handler
	MOVVC r3,#1
	MOVVS r3,#0
	]
d79 1
d81 5
d91 1
a91 9
	[ DeferCallbacks
	CMP r3,#0
	; Restore old callback handler
	MOVNE r0, #CallBackHandler
	LDMNEFD r13!,{r1-r3}
	SWINE XOS_ChangeEnvironment

	ADD sp, sp, #&40
	]
d93 3
d110 1
a111 2
splhi2
splimp2
d113 7
d130 1
d133 6
d151 1
d154 4
d167 1
d178 14
d218 1
d220 3
d437 1
d439 3
@


4.3
log
@* Fixed bug introduced by tentative ARP probe - a typo made arp_ifinit() fail to
  set up the interface route structure properly.
* Divide-by-zero when an IGMP membership query with a time of 1 received fixed
  (from FreeBSD).
* IGMP messages now sent with TOS set to "maximum reliability".
* tcp_output.c updated from FreeBSD - in particular path_mtu_discovery sysctl
  now available.
* A few other FreeBSD structural changes and bug fixes integrated.
* Put UDP checksum in BOOTP packets.
* Null pointer dereferencing fixed in whoami.c. Address setting now done with
  SIOCDIFADDR and SIOCAIFADDR. Don't set the netmask if asked not to.
* Output BOOTP packets with the source address in ciaddr
Note that various structural changes mean that the support tools (in particular
InetStat) will need to be recompiled.
Requires TCPIPLibs 5.20

Version 5.27. Tagged as 'Internet-5_27'
@
text
@d43 1
d175 21
d462 1
@


4.2
log
@Version Spinner_B7 taken
@
text
@d353 1
a353 1
	; Branch as appropriate to sum remaining 0-7 words
@


4.1
log
@Initial revision
@
text
@a14 4
; -*-As-*-
;
; $Header: /ax/networking:Internet/build/poduleirq.s:networking  1.1  $
; $Source: /ax/networking:Internet/build/poduleirq.s: $
d20 9
a28 16
; $Log:	poduleirq.s,v $
; Revision 1.1  94/12/02  10:00:24  kwelton
; Initial revision
; 

;;	GET	Hdr:ListOpts
;;	GET	Hdr:Macros
;;	GET	Hdr:System
;;	GET	Hdr:EnvNumbers
;;	GET	Hdr:ModHand

	GET	ListOpts
	GET	Macros
	GET	System
	GET	EnvNumbers
	GET	ModHand
d34 1
d38 1
d42 1
a49 3
memc_type
	DCD	0

d52 11
a62 6
	Push lr
	SWI XOS_ReadEscapeState
	MOVCS r0, #1
	MOVCC r0, #0

	Push r0
d66 2
a67 2
	Pull "r0, pc",,^

d69 1
d72 1
d74 8
a81 4
	SWI XOS_SetCallBack		; Defer callback
	MOV r14, r12			; Register block
	LDMIA r14, {r0-r14}^		; Loads USR r13,r14
	MOV r0, r0			; NOOP after accessing user
d84 2
a85 2
	LDR r14, [r14, #15*4]		; Loads user PC into SVC r14
	MOVS pc, r14			; Drop back to USR mode
d87 1
d93 2
a94 1
	Push "r0-r3, lr"
d99 3
d107 4
a110 1
	Push "r1-r3"			; Save old handler
d119 2
d122 3
a124 3
	MOV r0, #CallBackHandler
	Pull "r1-r3"
	SWI XOS_ChangeEnvironment
d127 2
a128 1
	Pull "r0-r3, pc",,^
d144 2
d174 265
d440 1
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d15 4
d24 16
a39 9

	GET	Hdr:ListOpts
	GET	Hdr:Macros
	GET	Hdr:System
	GET	Hdr:EnvNumbers
	GET	Hdr:ModHand

	GBLL	DeferCallbacks
DeferCallbacks SETL	{FALSE}
a44 1
	EXPORT	splimp2
a47 1
	EXPORT	splhi2
a50 1
	EXPORT  in_cksum_hdr
d58 3
d63 6
a68 11
	STMFD	sp!,{lr}
	SWI	XOS_ReadEscapeState
	MOVCS	r0, #1
	MOVCC	r0, #0

; I don't think it's up to us to acknowledge the escape condition
; It's the callee's problem
	[ {TRUE}
	LDMFD	sp!,{pc}^
	|
	STMFD r13!,{r0}
d72 2
a73 2
	LDMFD r13!,{r0,pc}^
	]
a74 1
	[ DeferCallbacks
a76 1
; Note that this may be entered in IRQ or SVC mode
d78 4
a81 8
	MOV	r8, pc			; Save current status/mode
	ORR	r8, r8, #SVC_Mode	; Derive SVC-mode version of it
	TEQP	r8, #0			; Enter SVC mode
	NOP
	SWI	XOS_SetCallBack		; Defer callback
	MOV	r14, r12		; Register block
	LDMIA	r14, {r0-r14}^		; Loads USR r13,r14
	NOP				; NOOP after accessing user
d84 2
a85 2
	LDR	r14, [r14, #15*4]	; Loads user PC into SVC r14
	MOVS	pc, r14			; Drop back to USR mode
a86 1
	]
d92 1
a92 2
	STMFD r13!,{lr}
	[ DeferCallbacks
a96 3
	;
        ; Callback handler needs defering so that escape code doesn't blow
        ; away the program which called this SWI before this SWI returns.
d102 1
a102 4
	STMVCFD r13!,{r1-r3}		; Save old handler
	MOVVC r3,#1
	MOVVS r3,#0
	]
a110 2
	[ DeferCallbacks
	CMP r3,#0
d112 3
a114 3
	MOVNE r0, #CallBackHandler
	LDMNEFD r13!,{r1-r3}
	SWINE XOS_ChangeEnvironment
d117 1
a117 2
	]
	LDMFD r13!,{pc}^
a132 2
splhi2
splimp2
a160 265
;
; Hyper-fast simple-case IP header checksum
;

in_cksum_hdr
	; Load 20 bytes of IP header
	LDMIA	a1,{a1-a4,ip}

	; Calculate 1's-complement sum of the 5 32-bit words.
	ADDS	a1,a1,a2
	ADCS	a1,a1,a3
	ADCS	a1,a1,a4
	ADCS	a1,a1,ip
	ADC	a1,a1,#0

	; Fold two 16-bit words together
	; May be left with 16-bit carry
	ADDS	a1,a1,a1,LSL #16

	; See below for the explanation of this bit
	MVN	a2,#0
	RSC	a1,a2,a1,LSR #16
	EOR	a1,a1,a2,LSR #16
	MOVS	pc,lr

	^	0
m_next	#	4
m_list	#	4
m_off	#	4
m_len	#	4

	[ {TRUE}

	EXPORT	in_cksum

;
; This routine is engineered to be rapid on cached ARMs.
; See RFC1072 for the 1's-complement arithmetic tricks used.
;
; The routine is engineered with the following points in mind:
;    Arithmetic operations, including constant shifts, take 1 tick
;    Arithmetic operations with register shifts take 2 ticks
;    Unexecuted instructions take 1 tick
;    Branches take 3 ticks
;    An LDM of n registers is significantly faster than n LDRs
;
; The amount to "unroll" the loop is an issue.  On an ARM710,
; doing 64 bytes at a time appears to be significantly (11-12%) faster
; on average than doing 32 bytes at a time.  The trade-off
; between reducing the number of branches and utilising burst-reads,
; and the filling of the instruction cache, will differ from processor
; to processor.  This sort of slight tweaking is probably trivial
; compared to the 8 times speedup over the bytewise in_cksum routine
; present in Internet 4.08...
;
; The mind boggles at a "processor-tuned" variation of the standard
; BSD in_cksum routine that manages to be under half the speed.
;
; In speed tests, trying 16-byte blocks after 64-byte blocks does not
; noticeably affect the speed. This probably means that it will actually
; increase the speed in real use, when this routine is called less
; often, as it makes the routine smaller, hence disrupting the cache less.
;
; On entry:
;      a1 -> first mbuf
;      a2 -> length to checksum
;
; Throughout routine:
;      a1 = current mbuf
;      a2 = length remaining to checksum
;      v1 = data ptr
;      v2 = length remaining of mbuf
;      v3 = total rotate of checksum
;      ip = checksum
;
;      a3-a4,v4-v6,sl,fp,lr = general work registers
;
;    In final 64 bytes:
;      a3 = number of bits present in final word (0-31)
;
	ROUT
in_cksum
	STMFD	sp!,{v1-v6,sl,fp,lr}

	; Start off checksum and rotate
	MOV	v3, #0
	MOV	ip, #0

	; v1 = ptr to data
99	LDR	v1,[a1,#m_off]
	ADD	v1,a1,v1

	; v2 = length of mbuf
	LDR	v2,[a1,#m_len]

	; if mlen > len, mlen = len
	CMPS	v2,a2
	MOVHI	v2,a2

	; len -= mlen
	SUB	a2,a2,v2

	ANDS	a3,v1,#3
	BLNE	fiddly

	; If we have 64 bytes, do it fast (utilising burst
	; reads)
	SUBS	v2,v2,#64
	BMI	%F97
0	LDMIA	v1!,{a3,a4,v4,v5,v6,sl,fp,lr}
	ADDS	ip,ip,a3
	ADCS	ip,ip,a4
	ADCS	ip,ip,v4
	ADCS	ip,ip,v5
	ADCS	ip,ip,v6
	ADCS	ip,ip,sl
	ADCS	ip,ip,fp
	ADCS	ip,ip,lr
	LDMIA	v1!,{a3,a4,v4,v5,v6,sl,fp,lr}
	ADCS	ip,ip,a3
	ADCS	ip,ip,a4
	ADCS	ip,ip,v4
	ADCS	ip,ip,v5
	ADCS	ip,ip,v6
	ADCS	ip,ip,sl
	ADCS	ip,ip,fp
	ADCS	ip,ip,lr
	ADC	ip,ip,#0

	SUBS	v2,v2,#64
	BGE	%B0

	; If we have 16 bytes, do it fast (utilising burst
	; reads)
97	ADDS	v2,v2,#64-16
	BMI	%F1
98	LDMIA	v1!,{a3,a4,v4,v5}
	ADDS	ip,ip,a3
	ADCS	ip,ip,a4
	ADCS	ip,ip,v4
	ADCS	ip,ip,v5
	ADC	ip,ip,#0

	SUBS	v2,v2,#16
	BGE	%B98

	; Right, down to < 16 bytes.
	; However we get here, C is clear

	; Do we have an "odd" number?
1	ANDS	a3,v2,#3       ; Doesn't alter C
	BEQ	%F2

	; Yes we do. Argh!

	; a3 is no of bytes present in incomplete word
	; Get lr to point to end word
	SUB	lr,v2,a3
	ADD	lr,lr,#16
	; Load word containing end-point. This will give us a3 bits
	; that need to be ignored (high-bits).
	LDR	a4,[v1,lr]

	; set a3 to no of bits present in incomplete word
	MOV	a3,a3,LSL #3
	; set lr to number of bits missing in incomplete word
	RSB	lr,a3,#32
	; clear bits to be ignored
	MOV	a4,a4,LSL lr
	; add incomplete word to checksum
	ADDS	ip,ip,a4,LSR lr
	; reduce amount left to read so the following code
	; will only sum remaining whole words
	BIC	v2,v2,#3

	; Now we continue. Note that as we reach label 2, a3 will
	; be set to the number of extra bits beyond the complete
	; words in the mbuf.

	; Branch as appropriate to sum remaining 0-7 words
	; Note that state of C as we reach this point is significant;
	; if we didn't go through the incomplete word malarky, C
	; must be clear, otherwise we take C from previous ADDS
	; (although this will of course be clear also).
	;
	; Can't really loop here as any sort of end-of-loop test
	; will corrupt the C flag.
2	SUB	pc,pc,v2,LSL #1
	NOP
	NOP			  ; Can't get here (honest!)
	NOP
	LDR	a4,[v1],#4	  ; 12
	ADCS	ip,ip,a4
	LDR	a4,[v1],#4        ; 8
	ADCS	ip,ip,a4
	LDR	a4,[v1]           ; 4
	ADCS	ip,ip,a4
	ADC	ip,ip,#0          ; 0

	; Have we finished?
	TEQS	a2,#0
	BEQ	%F03

	; Now then, now then, now then. If this mbuf did not have
	; a complete number of words, the next one will have "rotated
	; words". Eg in 3 mbufs of 5 bytes:
	;
	; [(A B C D) (A)] -> [(B C D A) (B)] -> [(C D A B) (C)]
	;
	; to cope with this, rotate the checksum so far to match
	; the rotation state of the next mbuf (eg rotate it one byte
	; left in the above example), and keep track of the total
	; rotations done in v3, so we can unwind at the end.
	;
	MOV	ip,ip,ROR a3
	SUB	v3,v3,a3

	; Back to the top for the next mbuf!
	LDR	a1,[a1,#m_next]
	B	%B99

3	MOV	ip,ip,ROR v3

	; Fold two 16-bit words together
	; May be left with 16-bit carry
	ADDS	a1,ip,ip,LSL #16

	; Useful constant...
	MVN	a2,#0

	; This means a1=(a1>>16)+C, would you believe it.
	; The things we do to save a single instruction :-)
	RSC	a1,a2,a1,LSR #16

	; Take the 1's-complement of the (16-bit) result
	EOR	a1,a1,a2,LSR #16

	; And... relax.
	LDMFD   sp!,{v1-v6,sl,fp,pc}^

	; This is very rare, so separate it off down here
	; can't be bothered to optimise
	; a3 is number of missing bytes
fiddly
	; Check if out of data
	TEQS	v2,#0
	MOVEQ	pc,lr

	; Load byte
11	LDRB	a4,[v1],#1
	; Add to checksum
	ADDS	ip,ip,a4
	ADC	ip,ip,#0
	; Rotate checksum
	MOV	ip,ip,ROR #8
	SUB	v3,v3,#8
	; Reduce counter
	SUBS	v2,v2,#1
	MOVEQ	pc,lr
	TSTS	v1,#3
	BNE	%B11
	MOV	pc,lr

	]

a161 1

@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d27 1
a27 1
;
d29 5
a33 5
	GET	Hdr:ListOpts
	GET	Hdr:Macros
	GET	Hdr:System
	GET	Hdr:EnvNumbers
	GET	Hdr:ModHand
d35 5
a39 5
;;	GET	ListOpts
;;	GET	Macros
;;	GET	System
;;	GET	EnvNumbers
;;	GET	ModHand
@


4.1.7.2
log
@RCS log keyword removed
@
text
@d24 1
a24 1
; :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@d27 1
a27 1
;
d29 5
a33 5
	GET	Hdr:ListOpts
	GET	Hdr:Macros
	GET	Hdr:System
	GET	Hdr:EnvNumbers
	GET	Hdr:ModHand
d35 5
a39 5
;;	GET	ListOpts
;;	GET	Macros
;;	GET	System
;;	GET	EnvNumbers
;;	GET	ModHand
@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d24 1
a24 1
; :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d27 1
a27 2
;

d29 11
a39 14
;;	GET	ListOpts
;;	GET	Macros
;;	GET	System
;;	GET	EnvNumbers
;;	GET	ModHand

XOS_Byte		*	&20006
XOS_EnterOS		*	&20016
XOS_SetCallBack		*	&2001B
XOS_ReadEscapeState	*	&2002C
XOS_ChangeEnvironment	*	&20040

CallBackHandler		*	7
I_bit	*	&08000000
a44 1
	EXPORT	splimp2
a47 1
	EXPORT	splhi2
a50 1
	EXPORT  in_cksum_hdr
d58 3
d63 6
a68 11
	STMFD	sp!,{lr}
	SWI	XOS_ReadEscapeState
	MOVCS	r0, #1
	MOVCC	r0, #0

; I don't think it's up to us to acknowledge the escape condition
; It's the callee's problem
	[ {TRUE}
	LDMFD	sp!,{pc}^
	|
	STMFD r13!,{r0}
d72 1
a72 2
	LDMFD r13!,{r0,pc}^
	]
a79 4
	[ {TRUE}
	NOP
	NOP
	]
d81 1
a81 1
	NOP				; NOOP after accessing user
a83 3
	[ {TRUE}
	NOP				; Second NOP needed (yuck!)
	]
d92 1
a92 2
	STMFD r13!,{r0-r3,lr}
	[ {TRUE}
a96 3
	;
        ; Callback handler needs defering so that escape code doesn't blow
        ; away the program which called this SWI before this SWI returns.
d102 1
a102 2
	STMFD r13!,{r1-r3}		; Save old handler
	]
a110 1
	[ {TRUE}
d113 1
a113 1
	LDMFD r13!,{r1-r3}
d117 1
a117 4
	|
	NOP
	]
	LDMFD r13!,{r0-r3,pc}^
a132 2
splhi2
splimp2
a160 265
;
; Hyper-fast simple-case IP header checksum
;

in_cksum_hdr
	; Load 20 bytes of IP header
	LDMIA	a1,{a1-a4,ip}

	; Calculate 1's-complement sum of the 5 32-bit words.
	ADDS	a1,a1,a2
	ADCS	a1,a1,a3
	ADCS	a1,a1,a4
	ADCS	a1,a1,ip
	ADC	a1,a1,#0

	; Fold two 16-bit words together
	; May be left with 16-bit carry
	ADDS	a1,a1,a1,LSL #16

	; See below for the explanation of this bit
	MVN	a2,#0
	RSC	a1,a2,a1,LSR #16
	EOR	a1,a1,a2,LSR #16
	MOVS	pc,lr

	^	0
m_next	#	4
m_list	#	4
m_off	#	4
m_len	#	4

	[ {TRUE}

	EXPORT	in_cksum

;
; This routine is engineered to be rapid on cached ARMs.
; See RFC1072 for the 1's-complement arithmetic tricks used.
;
; The routine is engineered with the following points in mind:
;    Arithmetic operations, including constant shifts, take 1 tick
;    Arithmetic operations with register shifts take 2 ticks
;    Unexecuted instructions take 1 tick
;    Branches take 3 ticks
;    An LDM of n registers is significantly faster than n LDRs
;
; The amount to "unroll" the loop is an issue.  On an ARM710,
; doing 64 bytes at a time appears to be significantly (11-12%) faster
; on average than doing 32 bytes at a time.  The trade-off
; between reducing the number of branches and utilising burst-reads,
; and the filling of the instruction cache, will differ from processor
; to processor.  This sort of slight tweaking is probably trivial
; compared to the 8 times speedup over the bytewise in_cksum routine
; present in Internet 4.08...
;
; The mind boggles at a "processor-tuned" variation of the standard
; BSD in_cksum routine that manages to be under half the speed.
;
; In speed tests, trying 16-byte blocks after 64-byte blocks does not
; noticeably affect the speed. This probably means that it will actually
; increase the speed in real use, when this routine is called less
; often, as it makes the routine smaller, hence disrupting the cache less.
;
; On entry:
;      a1 -> first mbuf
;      a2 -> length to checksum
;
; Throughout routine:
;      a1 = current mbuf
;      a2 = length remaining to checksum
;      v1 = data ptr
;      v2 = length remaining of mbuf
;      v3 = total rotate of checksum
;      ip = checksum
;
;      a3-a4,v4-v6,sl,fp,lr = general work registers
;
;    In final 64 bytes:
;      a3 = number of bits present in final word (0-31)
;
	ROUT
in_cksum
	STMFD	sp!,{v1-v6,sl,fp,lr}

	; Start off checksum and rotate
	MOV	v3, #0
	MOV	ip, #0

	; v1 = ptr to data
99	LDR	v1,[a1,#m_off]
	ADD	v1,a1,v1

	; v2 = length of mbuf
	LDR	v2,[a1,#m_len]

	; if mlen > len, mlen = len
	CMPS	v2,a2
	MOVHI	v2,a2

	; len -= mlen
	SUB	a2,a2,v2

	ANDS	a3,v1,#3
	BLNE	fiddly

	; If we have 64 bytes, do it fast (utilising burst
	; reads)
	SUBS	v2,v2,#64
	BMI	%F97
0	LDMIA	v1!,{a3,a4,v4,v5,v6,sl,fp,lr}
	ADDS	ip,ip,a3
	ADCS	ip,ip,a4
	ADCS	ip,ip,v4
	ADCS	ip,ip,v5
	ADCS	ip,ip,v6
	ADCS	ip,ip,sl
	ADCS	ip,ip,fp
	ADCS	ip,ip,lr
	LDMIA	v1!,{a3,a4,v4,v5,v6,sl,fp,lr}
	ADCS	ip,ip,a3
	ADCS	ip,ip,a4
	ADCS	ip,ip,v4
	ADCS	ip,ip,v5
	ADCS	ip,ip,v6
	ADCS	ip,ip,sl
	ADCS	ip,ip,fp
	ADCS	ip,ip,lr
	ADC	ip,ip,#0

	SUBS	v2,v2,#64
	BGE	%B0

	; If we have 16 bytes, do it fast (utilising burst
	; reads)
97	ADDS	v2,v2,#64-16
	BMI	%F1
98	LDMIA	v1!,{a3,a4,v4,v5}
	ADDS	ip,ip,a3
	ADCS	ip,ip,a4
	ADCS	ip,ip,v4
	ADCS	ip,ip,v5
	ADC	ip,ip,#0

	SUBS	v2,v2,#16
	BGE	%B98

	; Right, down to < 16 bytes.
	; However we get here, C is clear

	; Do we have an "odd" number?
1	ANDS	a3,v2,#3       ; Doesn't alter C
	BEQ	%F2

	; Yes we do. Argh!

	; a3 is no of bytes present in incomplete word
	; Get lr to point to end word
	SUB	lr,v2,a3
	ADD	lr,lr,#16
	; Load word containing end-point. This will give us a3 bits
	; that need to be ignored (high-bits).
	LDR	a4,[v1,lr]

	; set a3 to no of bits present in incomplete word
	MOV	a3,a3,LSL #3
	; set lr to number of bits missing in incomplete word
	RSB	lr,a3,#32
	; clear bits to be ignored
	MOV	a4,a4,LSL lr
	; add incomplete word to checksum
	ADDS	ip,ip,a4,LSR lr
	; reduce amount left to read so the following code
	; will only sum remaining whole words
	BIC	v2,v2,#3

	; Now we continue. Note that as we reach label 2, a3 will
	; be set to the number of extra bits beyond the complete
	; words in the mbuf.

	; Branch as appropriate to sum remaining 0-7 words
	; Note that state of C as we reach this point is significant;
	; if we didn't go through the incomplete word malarky, C
	; must be clear, otherwise we take C from previous ADDS
	; (although this will of course be clear also).
	;
	; Can't really loop here as any sort of end-of-loop test
	; will corrupt the C flag.
2	SUB	pc,pc,v2,LSL #1
	NOP
	NOP			  ; Can't get here (honest!)
	NOP
	LDR	a4,[v1],#4	  ; 12
	ADCS	ip,ip,a4
	LDR	a4,[v1],#4        ; 8
	ADCS	ip,ip,a4
	LDR	a4,[v1]           ; 4
	ADCS	ip,ip,a4
	ADC	ip,ip,#0          ; 0

	; Have we finished?
	TEQS	a2,#0
	BEQ	%F03

	; Now then, now then, now then. If this mbuf did not have
	; a complete number of words, the next one will have "rotated
	; words". Eg in 3 mbufs of 5 bytes:
	;
	; [(A B C D) (A)] -> [(B C D A) (B)] -> [(C D A B) (C)]
	;
	; to cope with this, rotate the checksum so far to match
	; the rotation state of the next mbuf (eg rotate it one byte
	; left in the above example), and keep track of the total
	; rotations done in v3, so we can unwind at the end.
	;
	MOV	ip,ip,ROR a3
	SUB	v3,v3,a3

	; Back to the top for the next mbuf!
	LDR	a1,[a1,#m_next]
	B	%B99

3	MOV	ip,ip,ROR v3

	; Fold two 16-bit words together
	; May be left with 16-bit carry
	ADDS	a1,ip,ip,LSL #16

	; Useful constant...
	MVN	a2,#0

	; This means a1=(a1>>16)+C, would you believe it.
	; The things we do to save a single instruction :-)
	RSC	a1,a2,a1,LSR #16

	; Take the 1's-complement of the (16-bit) result
	EOR	a1,a1,a2,LSR #16

	; And... relax.
	LDMFD   sp!,{v1-v6,sl,fp,pc}^

	; This is very rare, so separate it off down here
	; can't be bothered to optimise
	; a3 is number of missing bytes
fiddly
	; Check if out of data
	TEQS	v2,#0
	MOVEQ	pc,lr

	; Load byte
11	LDRB	a4,[v1],#1
	; Add to checksum
	ADDS	ip,ip,a4
	ADC	ip,ip,#0
	; Rotate checksum
	MOV	ip,ip,ROR #8
	SUB	v3,v3,#8
	; Reduce counter
	SUBS	v2,v2,#1
	MOVEQ	pc,lr
	TSTS	v1,#3
	BNE	%B11
	MOV	pc,lr

	]

a161 1

@


4.1.3.2
log
@RCS Log keyword removed
@
text
@d24 1
a24 1
; :RCS Log discontinued:
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d24 1
a24 1
; :RCS Log discontinued:
@

head	4.13;
access;
symbols
	Internet-5_65:4.13
	Internet-5_64:4.13
	Internet-5_63:4.13
	Internet-5_62:4.13
	Internet-5_61:4.13
	Internet-5_60:4.13
	Internet-5_59:4.13
	Internet-5_58:4.13
	Internet-5_57:4.13
	Internet-5_56:4.13
	Internet-5_55:4.13
	Internet-5_54:4.13
	Internet-5_53:4.13
	Internet-5_52:4.12
	Internet-5_51:4.12
	Internet-5_50:4.12
	RO_5_07:4.12
	Internet-5_49:4.12
	Internet-5_48:4.12
	Internet-5_47:4.12
	Internet-5_46:4.12
	Internet-5_45:4.12
	Internet-5_44:4.12
	Internet-5_43:4.11
	Internet-5_42:4.11
	Internet-5_41:4.11
	Internet-5_40:4.11
	Internet-5_39:4.11
	Internet-5_38:4.11
	Internet-5_37:4.10
	Internet-5_36:4.9
	Internet-5_35:4.9
	Internet-5_34:4.9
	Internet-5_33:4.8
	Internet-5_32:4.8
	Internet-5_31:4.8
	Internet-5_30:4.7
	Internet-5_29:4.7
	Internet-5_27:4.6
	Internet-5_26:4.5
	Internet-5_25:4.5
	Internet-5_24:4.5
	Internet-5_23:4.4
	Internet-5_22:4.3
	Internet-5_21:4.3
	Internet-5_20:4.3
	Internet-5_19:4.3
	Internet-5_18:4.3
	Internet-5_17:4.3
	Internet-5_16:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Internet-5_15:4.3
	Internet-5_14:4.3
	Internet-5_13:4.3
	sforrest_daytona_appflash-0_31:4.2
	Internet-5_12:4.3
	Internet-5_11:4.2
	celkins_Internet-5_10:4.2
	nicke_Internat_25-9-98:4.2
	Internet-5_09:4.2
	blaughto_daytona_appflash-0_30:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rwarren_Internet-5_08:4.2
	Spinner:4.2
	Internet_5_07:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.2
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.2
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.13
date	2011.12.15.22.20.00;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	TVCPLXal0LzsSkLv;

4.12
date	2000.07.13.10.39.41;	author ahodgkin;	state Exp;
branches;
next	4.11;

4.11
date	99.11.11.15.18.57;	author kbracey;	state Exp;
branches;
next	4.10;

4.10
date	99.10.14.14.42.44;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	99.07.28.12.00.04;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	99.07.13.11.12.33;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	99.07.08.15.25.24;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.06.30.13.15.27;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.06.23.11.58.02;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.06.07.10.47.57;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.10.22.14.26.15;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.58.17;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.27.55;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.27.55;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.19.35;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.25.48;	author nturton;	state Exp;
branches;
next	4.1.3.2;

4.1.3.2
date	96.11.08.17.23.06;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.06.14;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.55.11;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.06.06;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.58.31;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.37.53;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.08;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.13
log
@Delete local user_mode_donothing() and replace with usermode_donothing() from AsmUtils.
Makefilse uses ModuleLibs too.
Lots of STM/LDM replaced with Push and Pull macros.
Local definitions in 'swiveneers' replaced with header files.

Version 5.53. Tagged as 'Internet-5_53'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
 *
 * Module specific information
 *
 */

#ifndef __kernel_h
#include "kernel.h"
#endif
#include <string.h>

/*
 * length of panic buffer
 */
#define PANICBUFLEN	81

#define SOCKTABSIZE	96

/*
 * function prototypes
 */
int if_module_output(struct ifnet *ifp, struct mbuf *m0, struct sockaddr *dst, struct rtentry *);
int if_module_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data);
int if_module_null(struct ifnet *, u_long, caddr_t);
int if_module_none(struct ifnet *, struct mbuf *, struct sockaddr *, struct rtentry *);
_kernel_oserror *if_module_reclaimmulti(struct ifnet *);
_kernel_oserror *claim_frames(struct ifnet *ifp, int claim);

int callback(int callbackno);
void callback_entered(int callbackno);
void callback_finalise(void);

void revarpintr(void);
void callo_handler(void);

_kernel_oserror *calleverytick(void (*fun)(void));
void removetickerevent(void (*fun)(void));

void rsignal(struct proc *p, struct mbuf **m, struct sockaddr *sa,
             char *esrc, int unit, int swinum, struct mbuf *n);

void sendsignals(int sockid);
void sendallsignals(void);

int mb_present(void);
void m_copydata(struct mbuf *m, int off, int len, caddr_t cp);
void m_copyback(struct mbuf *m, int off, int len, caddr_t cp);

void insque(void *elem, void *pred);
void remque(void *elem);

int ffs(long);

char *ether_sprintf(const u_char *);

void loopattach(void);
int looutput(struct ifnet *, struct mbuf *, struct sockaddr *, struct rtentry *);

void sysctl_init(void);
void domaininit(void);
void init_callout(void);
void in_proto_init(void);
void callback_init(void);
void sleeptabinit(void);
void kvm_init(void);
int ensure_irqs_on(void);
void restore_irqs(int);
void setsoftnet(void);
u_int get_t0_count(void);

void sc_addrchanged(void);

_kernel_oserror *dci4_mc_request(struct dib *,int/*flags*/,int/*frame type*/,
	u_char */*mac*/, void */*logical addr*/);

extern int rand(void);
extern void srand(unsigned int);

extern void *osmodule_claim(size_t);
extern void osmodule_free(void *);


/*
 * #defines for the usual BSD string functions etc
 */
#define bcopy(src, dst, length) memcpy(dst, src, length)
#define bcmp(b1, b2, length) memcmp(b1, b2, length)
#define bzero(b, length) memset(b, 0, length)
#define htonl(x) ntohl(x)
#define htons(x) ntohs(x)
#define copyin(from, to, count) (memcpy(to, from, count), 0)
#define copyout(from, to, count) (memcpy(to, from, count), 0)
#define ovbcopy(from, to, count) memmove(to, from, count)
#define imin(a, b) ((int)(a) < (int)(b) ? (int)(a) : (int)(b))
#define imax(a, b) ((int)(a) > (int)(b) ? (int)(a) : (int)(b))
#define lmin(a, b) ((long)(a) < (long)(b) ? (long)(a) : (long)(b))
#define lmax(a, b) ((long)(a) > (long)(b) ? (long)(a) : (long)(b))
#define min(a, b) ((u_int)(a) < (u_int)(b) ? (u_int)(a) : (u_int)(b))
#define max(a, b) ((u_int)(a) > (u_int)(b) ? (u_int)(a) : (u_int)(b))
#define ulmin(a, b) ((u_long)(a) < (u_long)(b) ? (u_long)(a) : (u_long)(b))
#define ulmax(a, b) ((u_long)(a) > (u_long)(b) ? (u_long)(a) : (u_long)(b))
#define gsignal(p, sig) psignal((struct proc *)(p), (sig))
#define pfind(p) ((struct proc *)(p))

/*
 * Fudgery - the Unix bits don't expect malloc to return NULL
 * for zero length, which is what the C run-time helpfully
 * does in supervisor mode. OS_Module doesn't.
 */
#define malloc(a, b, c) osmodule_claim(a)
#define free(a, b) osmodule_free(a)

/* Stuff that should be in sys/mbuf.h */
extern int	max_linkhdr;			/* largest link-level header */
extern int	max_protohdr;			/* largest protocol header */
extern int	max_hdr;			/* largest link+protocol header */
extern int	max_datalen;			/* MHLEN - max_hdr */

extern _kernel_oserror *mb_close_session(void);


int splhi(void), splimp(void), splet(void), splnet(void);
void splhi2(void), splimp2(void);
void splx(int), splrestore(int);

/*
 * An optimisation for interrupts - the APCS means that interrupt state is
 * restored for us on exit from procedures. At least it did until we
 * started producing 32-bit code.
 */
#if 0
#define func_splhi() splhi2()
#define func_splimp() splimp2()
#define func_splx() {}
#define func_splrestore() {}
#else
#define func_splhi() int splstate=splhi()
#define func_splimp() int splstate=splimp()
#define func_splx() splx(splstate)
#define func_splrestore() splrestore(splstate)
#endif

/*
 * structures for handling callbacks, which
 * allow us to keep a record of outstanding
 * transient callbacks
 *
 * Note that tick_entry.s relies on these definitions
 */
#define CALLB_CALLB	0
#define CALLB_STARTUP	1
#define NCALLBACKS	2

extern struct callback_record
{
    void (*cb_entry)();
    int    cb_outstanding;
} callbacks[NCALLBACKS];

/*
 * Portable features mask
 */

#define PortableFeature_Speed (1u<<0)
#define PortableFeature_Idle  (1u<<4)
#define PortableFeature_Stop  (1u<<5)
extern unsigned int portable_features;

/*
 * Another declaration
 */
extern long siglist[SOCKTABSIZE];

/*
 * some nasty error handling - we sometimes need to "tunnel"
 * RISC OS error blocks through integer function returns;
 * the following error number and error block is used to
 * achieve this.
 */
extern _kernel_oserror errtunnel;
#define ETUNNEL		128

/* EOF module.h */
@


4.12
log
@  Econet_InetRxDirect interface extended.
Detail:
  Previously, the SWI didn't care about any return values. The Internet
  module would either free the MBuf passed or send it on to the socket,
  depending on the value of m_len on exit from the SWI. This still works,
  but SWI handlers can now set R1 to zero on exit to claim ownership of
  the MBuf. In this case, the item is neither freed nor passed on to the
  socket, and the new owner must be very careful to make sure that they
  do an appropriate m_free later.
Admin:
  This change was implemented to allow UDPV to point the MPEG system
  directly to the data in the MBuf chains it was passed rather than taking
  a local copy. It has been tested with both new and old UDPV versions and
  both work as expected. Note that any module using the new interface will
  absolutely require it to be present (new UDPV modules built to use the
  interface extension will refuse to start if Internet is too old).

Version 5.44. Tagged as 'Internet-5_44'
@
text
@a50 2
void user_mode_donothing(void);

@


4.11
log
@Now 32-bit compatible, in a suitable build environment. In the standard
26-bit build environment it is unchanged, except for a fix in the "Module
Internet cannot be RAM loaded" checker.

Version 5.38. Tagged as 'Internet-5_38'
@
text
@d56 1
a56 1
void rsignal(struct proc *p, struct mbuf *m, struct sockaddr *sa,
@


4.10
log
@Added power-saving - calls Portable_Idle when waiting for a network operation
to complete.

Version 5.37. Tagged as 'Internet-5_37'
@
text
@d145 2
a146 1
 * restored for us on exit from procedures
d148 1
a148 1
#ifdef __riscos
@


4.9
log
@microtime() now returns microsecond accuracy.
Random number generator now seeded from microtime(), machine ID and
hardware addresses of DCI drivers.
Some previously untested debugging code fixed to compile.

Version 5.34. Tagged as 'Internet-5_34'
@
text
@d177 9
@


4.8
log
@Added new FreeBSD sysctl handling using linker magic.
A few new sysctls added as a result.
SO_TIMESTAMP now gives real time, not Internet's internal time.
DHCP/BOOTP parsing picks up URL option and pops it into Inet$URL.
Requires TCPIPLibs 5.25 and link 5.12.

Version 5.31. Tagged as 'Internet-5_31'
@
text
@a75 1
u_long realtime(long *);
a84 1

d86 1
d96 2
a97 2
void *inet_malloc(size_t);
void inet_free(void *);
d122 7
a128 2
#define malloc(a, b, c) inet_malloc(a)
#define free(a, b) inet_free(a)
@


4.7
log
@* Dynamic ports now assigned in range 49152-65535.
* IP_RECVDSTADDR works for non-unicast packets.
* SO_TIMESTAMP added.
* IP_RECVIF added.
* Various other internal changes merged in from FreeBSD sources.

Version 5.29. Tagged as 'Internet-5_29'
@
text
@d77 1
d97 2
d122 3
@


4.6
log
@* Fixed bug introduced by tentative ARP probe - a typo made arp_ifinit() fail to
  set up the interface route structure properly.
* Divide-by-zero when an IGMP membership query with a time of 1 received fixed
  (from FreeBSD).
* IGMP messages now sent with TOS set to "maximum reliability".
* tcp_output.c updated from FreeBSD - in particular path_mtu_discovery sysctl
  now available.
* A few other FreeBSD structural changes and bug fixes integrated.
* Put UDP checksum in BOOTP packets.
* Null pointer dereferencing fixed in whoami.c. Address setting now done with
  SIOCDIFADDR and SIOCAIFADDR. Don't set the netmask if asked not to.
* Output BOOTP packets with the source address in ciaddr
Note that various structural changes mean that the support tools (in particular
InetStat) will need to be recompiled.
Requires TCPIPLibs 5.20

Version 5.27. Tagged as 'Internet-5_27'
@
text
@d38 2
a39 2
int if_module_ioctl(struct ifnet *ifp, int cmd, caddr_t data);
int if_module_null(struct ifnet *, int, caddr_t);
d70 5
@


4.5
log
@Modified to keep track of multicast claims on interfaces. It will no longer
lose multicast claims if a replacement driver module is loaded, or if an
interface is configured down.
Now passes correct frame type to MulticastRequest (used to pass a zero frame
level).
No longer asks for multicast ARP or Reverse ARP packets.

Version 5.24. Tagged as 'Internet-5_24'
@
text
@d104 8
a111 6
#define imin(a, b) ((a) < (b) ? (a) : (b))
#define imax(a, b) ((a) > (b) ? (a) : (b))
#define lmin(a, b) ((u_long)(a) < (u_long)(b) ? (u_long)(a) : (u_long)(b))
#define lmax(a, b) ((u_long)(a) > (u_long)(b) ? (u_long)(a) : (u_long)(b))
#define min(a, b) ((unsigned)(a) < (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))
#define max(a, b) ((unsigned)(a) > (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))
@


4.4
log
@IP timestamps and TCP sequence numbers now generated from system real-time
clock, rather than local monotonic copy. This gives a better chance of
uniqueness between reboots, as we should have found time from a server
at some stage.
Local clock initialised from system clock with centisecond accuracy.
IP firewalling and multicast routing disabled by default - specify them in
components file if really wanted.

Version 5.23. Tagged as 'Internet-5_23'
@
text
@d41 1
d86 1
a86 1
	u_char */*mac*/, u_char */*logical addr*/);
@


4.3
log
@  Added multicast filtering support to Internet module
  More boot variables recognised in BOOTP/DHCP responses.
Detail:
  net/if_module.c:
    Interprets multicast ioctl requests and construct SWI parameters
    for passing to riscos/module.c for a call to MulticastRequest SWI.
  riscos/module.c:
    Wrapper for calling above SWI.  Sets appropriate flag bit on
    DCI4 Filter SWI to indicate our support for multicast filtering
    when Inquire SWI indicated that the driver supports it too.
  build/module.h:
    Prototype for dci4_mc_request() wrapper added.
  whoami/whoami.c:
    More variables are now known to the response handler.
    Multiple IP address options are handled (useful for Inet$Resolvers)
    Interoperability workaround for Microsoft DHCP servers added.
Admin:
  Requires RiscOS/Sources/Lib/TCPIPLibs version 5.02 or later.
    (tag: TCPIPLibs-5_02 or later)
  Supporting documentation: DCI4 Functional Specification
    (Drawing number 0284,036/FS; ECO 4112)
  BOOTP client tested against Microsoft DHCP server and standard server.
  Multicast filtering tested against new EtherH driver from I-cubed.
  Multicast filtering tested against old EtherM driver to verify the
    changes do not break older non-DCI 4.04 compliant drivers.

Version 5.12. Tagged as 'Internet-5_12'
@
text
@d70 1
a70 1
long realtime(void);
@


4.2
log
@Version Spinner_B7 taken
@
text
@d84 3
@


4.1
log
@Initial revision
@
text
@d15 1
a15 5
/* -*-C-*-
 *
 * $Header: /ax/networking:Internet/build/module.h:networking  1.5  $
 * $Source: /ax/networking:Internet/build/module.h: $
 *
a19 19
 * $Log:	module.h,v $
 * Revision 1.5  95/03/31  14:07:08  kwelton
 * Changed PANICBUFLEN to 81.
 * 
 * Revision 1.4  95/03/31  11:15:35  kwelton
 * Added some function prototypes and structures for keeping track of
 * outstanding callbacks - this allows pending callbacks to be removed
 * during module finalisation.
 * 
 * Revision 1.3  95/02/28  18:51:15  kwelton
 * Added a nasty scheme which "tunnels" RISC OS error blocks through
 * integer error numbers/
 * 
 * Revision 1.2  95/01/03  14:14:31  kwelton
 * Added define for length of panic buffer
 * 
 * Revision 1.1  94/12/02  09:55:51  kwelton
 * Initial revision
 * 
d22 5
d32 2
d37 4
a40 4
int if_module_output(struct ifnet *ifp, struct mbuf *m0, struct sockaddr *dst);
int if_module_ioctl(struct ifnet *ifp, int cmd, char *data);
int if_module_null(void);
int if_module_none(void);
a42 2
int looutput(struct ifnet *ifp, struct mbuf *m0, struct sockaddr *dst);
int loioctl(struct ifnet *ifp, int cmd, caddr_t data);
d44 35
d80 57
a136 1
void callback_entered(int callbackno);
d142 2
d149 1
a149 1
struct callback_record
d156 5
d166 1
a166 1
_kernel_oserror errtunnel;
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d15 5
a19 1
/*
d24 19
a44 5
#ifndef __kernel_h
#include "kernel.h"
#endif
#include <string.h>

a49 2
#define SOCKTABSIZE	96

d53 4
a56 4
int if_module_output(struct ifnet *ifp, struct mbuf *m0, struct sockaddr *dst, struct rtentry *);
int if_module_ioctl(struct ifnet *ifp, int cmd, caddr_t data);
int if_module_null(struct ifnet *, int, caddr_t);
int if_module_none(struct ifnet *, struct mbuf *, struct sockaddr *, struct rtentry *);
d59 2
d62 1
a63 92
void callback_finalise(void);

void revarpintr(void);
void callo_handler(void);

void user_mode_donothing(void);

_kernel_oserror *calleverytick(void (*fun)(void));
void removetickerevent(void (*fun)(void));

void rsignal(struct proc *p, struct mbuf *m, struct sockaddr *sa,
             char *esrc, int unit, int swinum, struct mbuf *n);

void sendsignals(int sockid);
void sendallsignals(void);

int mb_present(void);
void m_copydata(struct mbuf *m, int off, int len, caddr_t cp);
void m_copyback(struct mbuf *m, int off, int len, caddr_t cp);

void insque(void *elem, void *pred);
void remque(void *elem);

int ffs(long);

long realtime(void);
void domaininit(void);
void init_callout(void);
void in_proto_init(void);
void callback_init(void);
void sleeptabinit(void);
void kvm_init(void);
int ensure_irqs_on(void);
void restore_irqs(int);

void setsoftnet(void);

void sc_addrchanged(void);

extern int rand(void);
extern void srand(unsigned int);



/*
 * #defines for the usual BSD string functions etc
 */
#define bcopy(src, dst, length) memcpy(dst, src, length)
#define bcmp(b1, b2, length) memcmp(b1, b2, length)
#define bzero(b, length) memset(b, 0, length)
#define htonl(x) ntohl(x)
#define htons(x) ntohs(x)
#define copyin(from, to, count) (memcpy(to, from, count), 0)
#define copyout(from, to, count) (memcpy(to, from, count), 0)
#define ovbcopy(from, to, count) memmove(to, from, count)
#define imin(a, b) ((a) < (b) ? (a) : (b))
#define imax(a, b) ((a) > (b) ? (a) : (b))
#define lmin(a, b) ((u_long)(a) < (u_long)(b) ? (u_long)(a) : (u_long)(b))
#define lmax(a, b) ((u_long)(a) > (u_long)(b) ? (u_long)(a) : (u_long)(b))
#define min(a, b) ((unsigned)(a) < (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))
#define max(a, b) ((unsigned)(a) > (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))
#define gsignal(p, sig) psignal((struct proc *)(p), (sig))
#define pfind(p) ((struct proc *)(p))

/* Stuff that should be in sys/mbuf.h */
extern int	max_linkhdr;			/* largest link-level header */
extern int	max_protohdr;			/* largest protocol header */
extern int	max_hdr;			/* largest link+protocol header */
extern int	max_datalen;			/* MHLEN - max_hdr */

extern _kernel_oserror *mb_close_session(void);


int splhi(void), splimp(void), splet(void), splnet(void);
void splhi2(void), splimp2(void);
void splx(int), splrestore(int);

/*
 * An optimisation for interrupts - the APCS means that interrupt state is
 * restored for us on exit from procedures
 */
#ifdef __riscos
#define func_splhi() splhi2()
#define func_splimp() splimp2()
#define func_splx() {}
#define func_splrestore() {}
#else
#define func_splhi() int splstate=splhi()
#define func_splimp() int splstate=splimp()
#define func_splx() splx(splstate)
#define func_splrestore() splrestore(splstate)
#endif
a68 2
 *
 * Note that tick_entry.s relies on these definitions
d74 1
a74 1
extern struct callback_record
a80 5
 * Another declaration
 */
extern long siglist[SOCKTABSIZE];

/*
d86 1
a86 1
extern _kernel_oserror errtunnel;
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@RCS log keyword removed
@
text
@d24 1
a24 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d24 1
a24 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d27 1
a27 1
 *
d32 1
a32 1
 *
d36 1
a36 1
 *
d39 1
a39 1
 *
d42 1
a42 1
 *
a44 4
#ifndef __kernel_h
#include "kernel.h"
#endif

a49 2
#define SOCKTABSIZE	96

d53 4
a56 4
int if_module_output(struct ifnet *ifp, struct mbuf *m0, struct sockaddr *dst, struct rtentry *);
int if_module_ioctl(struct ifnet *ifp, int cmd, caddr_t data);
int if_module_null();
int if_module_none();
d59 2
a64 45
void sendsignals(int sockid);
void sendallsignals(void);

/*
 * #defines for the usual BSD string functions etc
 */
#define bcopy(src, dst, length) memcpy(dst, src, length)
#define bcmp(b1, b2, length) memcmp(b1, b2, length)
#define bzero(b, length) memset(b, 0, length)
#define htonl(x) ntohl(x)
#define htons(x) ntohs(x)
#define copyin(from, to, count) (memcpy(to, from, count), 0)
#define copyout(from, to, count) (memcpy(to, from, count), 0)
#define ovbcopy(from, to, count) memmove(to, from, count)
#define imin(a, b) ((a) < (b) ? (a) : (b))
#define imax(a, b) ((a) > (b) ? (a) : (b))
#define lmin(a, b) ((u_long)(a) < (u_long)(b) ? (u_long)(a) : (u_long)(b))
#define lmax(a, b) ((u_long)(a) > (u_long)(b) ? (u_long)(a) : (u_long)(b))
#define min(a, b) ((unsigned)(a) < (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))
#define max(a, b) ((unsigned)(a) > (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))
#define gsignal(p, sig) psignal(p, sig)
#define pfind(p) ((struct proc *)p)

/* Stuff that should be in sys/mbuf.h */
extern int	max_linkhdr;			/* largest link-level header */
extern int	max_protohdr;			/* largest protocol header */
extern int	max_hdr;			/* largest link+protocol header */
extern int	max_datalen;			/* MHLEN - max_hdr */

/*
 * An optimisation for interrupts - the APCS means that interrupt state is
 * restored for us on exit from procedures
 */
#ifdef __riscos
#define func_splhi() splhi2()
#define func_splimp() splimp2()
#define func_splx() {}
#define func_splrestore() {}
#else
#define func_splhi() int splstate=splhi()
#define func_splimp() int splstate=splimp()
#define func_splx() splx(splstate)
#define func_splrestore() splrestore(splstate)
#endif

a68 2
 *
 * Note that tick_entry.s relies on these definitions
a78 5

/*
 * Another declaration
 */
extern long siglist[SOCKTABSIZE];
@


4.1.3.2
log
@RCS Log keyword removed
@
text
@d24 1
a24 1
 * :RCS Log discontinued:
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d24 1
a24 1
 * :RCS Log discontinued:
@

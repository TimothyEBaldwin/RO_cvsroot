head	4.13;
access;
symbols
	Internet-5_65:4.13
	Internet-5_64:4.12
	Internet-5_63:4.12
	Internet-5_62:4.12
	Internet-5_61:4.11
	Internet-5_60:4.11
	Internet-5_59:4.11
	Internet-5_58:4.11
	Internet-5_57:4.11
	Internet-5_56:4.11
	Internet-5_55:4.11
	Internet-5_54:4.11
	Internet-5_53:4.11
	Internet-5_52:4.10
	Internet-5_51:4.9
	Internet-5_50:4.9
	RO_5_07:4.9
	Internet-5_49:4.9
	Internet-5_48:4.9
	Internet-5_47:4.9
	Internet-5_46:4.9
	Internet-5_45:4.9
	Internet-5_44:4.9
	Internet-5_43:4.8
	Internet-5_42:4.7
	Internet-5_41:4.7
	Internet-5_40:4.7
	Internet-5_39:4.7
	Internet-5_38:4.7
	Internet-5_37:4.7
	Internet-5_36:4.6
	Internet-5_35:4.6
	Internet-5_34:4.6
	Internet-5_33:4.5
	Internet-5_32:4.5
	Internet-5_31:4.5
	Internet-5_30:4.4
	Internet-5_29:4.4
	Internet-5_27:4.4
	Internet-5_26:4.4
	Internet-5_25:4.4
	Internet-5_24:4.4
	Internet-5_23:4.4
	Internet-5_22:4.3
	Internet-5_21:4.3
	Internet-5_20:4.3
	Internet-5_19:4.3
	Internet-5_18:4.3
	Internet-5_17:4.3
	Internet-5_16:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Internet-5_15:4.2
	Internet-5_14:4.2
	Internet-5_13:4.2
	sforrest_daytona_appflash-0_31:4.2
	Internet-5_12:4.2
	Internet-5_11:4.2
	celkins_Internet-5_10:4.2
	nicke_Internat_25-9-98:4.2
	Internet-5_09:4.2
	blaughto_daytona_appflash-0_30:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rwarren_Internet-5_08:4.2
	Spinner:4.2
	Internet_5_07:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.2
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.2
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.13
date	2018.09.15.15.59.59;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	OWW4LiTujwQzvdSA;

4.12
date	2017.06.07.20.36.39;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	xgif914dBX0dZtUz;

4.11
date	2011.12.15.22.20.04;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	TVCPLXal0LzsSkLv;

4.10
date	2008.12.22.02.15.39;	author bavison;	state Exp;
branches;
next	4.9;

4.9
date	2000.07.13.10.39.41;	author ahodgkin;	state Exp;
branches;
next	4.8;

4.8
date	2000.07.05.14.48.26;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	99.10.14.14.42.46;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.07.28.12.00.08;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.07.13.11.12.41;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.06.07.10.48.00;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.11.27.14.49.03;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.58.27;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.04;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.04;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.19.40;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.27.08;	author nturton;	state Exp;
branches;
next	4.1.3.2;

4.1.3.2
date	96.11.08.17.23.13;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.06.25;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.02;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.06.14;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.15;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.37.59;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.10;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.13
log
@Fix to SO_SNDTIMEO and SO_RCVTIMEO options being ignored
The TCPIPLibs library docs remind us that a socket can be modified via setsockopt() to have a non-default timeout for receive (SO_RCVTIMEO) and send (SO_SNDTIMEO) operations, however neither of these options were honoured if set. Instead, a default timeout of ~60s was given.
This is because although the Internet module stores and propagates (via sbwait()) the timeouts correctly, the underlying tsleep() function is non compliant: it makes no distinction between returning due to a timeout and returning due to being awoken by an event. See
  https://www.freebsd.org/cgi/man.cgi?query=tsleep&sektion=9&manpath=FreeBSD+4.4-RELEASE

for details.

lib/unixenv.c: differentiate between timing out and being awoken, and return EWOULDBLOCK for timeouts.

Aside: select() worked because when tsleep() returned with 0 for a timeout this caused a retry attempt, and the retry loop happens to include its own timer compare, causing select() to return. Now that tsleep() returns EWOULDBLOCK in a timeout situation no retry occurs and the function returns directly.

Tested with a deliberately timing out receive operation, see TCPIPLibs/test/timeo.c
Tested on RISC OS and FreeBSD 11.1-RELEASE-p4 with both an unset timeout (~60s) and 10s timeout, both behave identically in terms of return value and setting errno appropriately.

Version 5.65. Tagged as 'Internet-5_65'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
 */
#include <string.h>
#include <stdbool.h>
#include <kernel.h>
#include <swis.h>

#include "sys/param.h"
#include "sys/systm.h"
#include "sys/queue.h"
#include "sys/uio.h"
#include "sys/time.h"
#include "sys/kernel.h"
#include "sys/callout.h"
#include "sys/mbuf.h"
#include "sys/proc.h"
#include "sys/socket.h" //
#include "sys/socketvar.h" //
#include "sys/domain.h" //
#include "sys/protosw.h" //

#include "net/netisr.h"
#include "net/route.h" //

#include "netinet/in.h" //
#include "netinet/in_systm.h"
#include "netinet/ip.h"
#include "netinet/in_pcb.h" //

#include "debug.h"
#include "swiveneers.h"

#include "module.h"
#include "AsmUtils/callbacks.h"
#include "Global/HALEntries.h"
#include "Global/RISCOS.h"

#define NCALLOUT 20

/*
 * The callout structure is for
 * a routine arranging
 * to be called by the clock interrupt
 * in a specified amount of time.
 */

struct	callout callout[NCALLOUT];

struct	callout *callfree;
struct	callout calltodo;

int	ncallout = NCALLOUT;

extern struct socket *getsock(int s);
extern int escape_seen(void);
static int generate_event(int sockid, int sig);

volatile int callo_pending;
extern void *module_wsp;
extern int paniced;

#ifdef DELAY_EVENTS
long siglist[SOCKTABSIZE];
#endif

/*
 * Queue a signal for later processing - ie as we exit a SWI or our
 * callback handler
 */
void
psignal(p, signum)
	struct proc *p;
	register int signum;
{
	register int sockid = (int) p - 1;

	if (sockid < 0)
		return;

#ifdef DELAY_EVENTS
	/* This was the behaviour in Internet 5.00-5.15 - it has now been restored to the
	 * Internet 4 behaviour, to allow speed-critical apps, such as MPEG streaming, to
	 * get their data faster. */
	siglist[sockid] |= sigmask(signum);
#else
	generate_event(sockid, signum);
#endif
}

#ifdef DELAY_EVENTS
void
sendallsignals()
{
	register int sockid;

	for (sockid = 0; sockid < SOCKTABSIZE; sockid++)
		if (siglist[sockid])
			sendsignals(sockid);
}

/*
 * Send pending signals on a socket id. Be careful not to erase signals
 * that are raised by routines responding to the signals - save them for
 * later processing
 */
void
sendsignals(sockid)
	register int sockid;
{
	register int signum;
	register long mask;

	mask = siglist[sockid];

	for (;;) {
		if (mask == 0)
			return;
		signum = ffs(mask);
#ifdef DIAGNOSTIC
		if (signum != SIGIO && signum != SIGURG && signum != SIGPIPE)
			Printf("Unknown signal pending for socket %d: %d\n",
				sockid, signum);
#endif
		siglist[sockid] &= ~sigmask(signum);
		mask &= ~sigmask(signum);
		generate_event(sockid, signum);
	}
}
#endif

static int
generate_event(sockid, sig)
	int sockid, sig;
{
    int event = 0;
    int port = 0;
    struct socket *so;

#ifdef DEBUG
    if( DODEBUG(DBGEVENTS) )
	Printf("\021\04generate_event: SIG%s on socket %d\021\07\n",
	       (sig == SIGIO) ? "IO" : (sig == SIGURG) ? "URG" : "PIPE",
	       sockid);
#endif

    switch (sig)
    {
      case SIGIO:
	event = Event_Internet_SocketAsync;
	break;

      case SIGURG:
	event = Event_Internet_SocketUrgent;
	break;

      case SIGPIPE:
	event = Event_Internet_SocketBroken;
	break;

      default:
	return(NULL);
    }

#   ifdef NO_PORT_EVENT
    return os_generate_event(Event_Internet, event, sockid, 0) ? -1 : 0;
#   else
    /* If it's an Inet socket, fill in R3 with the local port number */
    so=getsock(sockid);
    if (so && so->so_proto->pr_domain->dom_family == PF_INET)
    {
        struct inpcb *inp=(struct inpcb *) so->so_pcb;

        if (inp)
            port = inp->inp_lport;
    }

    return os_generate_event(Event_Internet, event, sockid, port) ? -1 : 0;
#   endif
}

void rsignal(struct proc *p, struct mbuf **m, struct sockaddr *sa, char *esrc, int unit, int swinum, struct mbuf *n)
{
    int sockid;

    sockid = (int)p - 1;
    if (sockid < 0)
	return;

    *m = econet_inet_rx_direct(sockid, *m, sa, esrc, unit, swinum, n);
}

_kernel_oserror *calleverytick(void (*fun)(void))
{
    return os_claim(TickerV, fun, module_wsp);
}

void removetickerevent(void (*fun)(void))
{
    os_release(TickerV, fun, module_wsp);
}

void init_callout(void)
{
    int i;

    callo_pending = 0;
    calltodo.c_next = 0;
    callfree = &callout[0];
    for (i = 1; i < ncallout; i++)
	callout[i-1].c_next = &callout[i];
}

/*
 * This routine, plus its veneer, have been recrafted in assembler, and can
 * be found in s.tick_entry - KJB
 */
#ifdef NoAsm
int tick_handler(int *r, void *pw)
{
    struct callout *p1;
    int needtocall = 0;

    /*
     * Update time ticker
     */
    if ((time.tv_usec += 10000) >= 1000000) {
        time.tv_usec = 0;
        time.tv_sec++;
    }

    /*
     * Update real-time timeout queue.
     * At front of queue are some number of events which are ``due''.
     * The time to these is <= 0 and if negative represents the
     * number of ticks which have passed since it was supposed to happen.
     * The rest of the q elements (times > 0) are events yet to happen,
     * where the time for each is given as a delta from the previous.
     * Decrementing just the first of these serves to decrement the time
     * to all events.
     */
    p1 = calltodo.c_next;
    while (p1)
    {
	if( --p1->c_time > 0 )
	    break;

	needtocall = 1;

	if( p1->c_time == 0 )
	    break;

	p1 = p1->c_next;
    }

    if (needtocall)
	schednetisr(NETISR_CALLO);

    return (1);
}
#endif

/*
 * callout handler
 */
void
callo_handler(void)
{
    struct callout *p1;
    void *arg;
    timeout_func_t func;
    int a;
    int s;

    for (;;)
    {
	if ((p1 = calltodo.c_next) == 0 || p1->c_time > 0)
	    return;

	arg = p1->c_arg; func = p1->c_func; a = p1->c_time;
        s = splimp();
	calltodo.c_next = p1->c_next;
	p1->c_next = callfree;
	callfree = p1;
	splx(s);
	(*func)(arg);
    }
}

/*
 * Arrange that (*fun)(arg) is called in t/hz seconds.
 */
void timeout(timeout_func_t fun, void *arg, int t)
{
	struct callout *p1, *p2, *pnew;
	func_splimp();

#if 0
        Printf("timeout(%x,%x,%d)\n", fun, arg, t);
#endif

	if (t <= 0)
		t = 1;

	pnew = callfree;
	if (pnew == NULL) {
		panic("timeout table overflow");
		func_splx();
		return;
	}

	callfree = pnew->c_next;
	pnew->c_arg = arg;
	pnew->c_func = fun;
	for (p1 = &calltodo; (p2 = p1->c_next) && p2->c_time < t; p1 = p2)
		if (p2->c_time > 0)
			t -= p2->c_time;

	p1->c_next = pnew;
	pnew->c_next = p2;
	pnew->c_time = t;

	if (p2)
		p2->c_time -= t;

	func_splx();
}

/*
 * untimeout is called to remove a function timeout call
 * from the callout structure.
 */
void untimeout(timeout_func_t fun, void *arg)
{
    struct callout *p1, *p2;
    func_splimp();

    for (p1 = &calltodo; (p2 = p1->c_next) != 0; p1 = p2)
    {
	if (p2->c_func == fun && p2->c_arg == arg)
	{
	    if (p2->c_next && p2->c_time > 0)
		p2->c_next->c_time += p2->c_time;

	    p1->c_next = p2->c_next;
	    p2->c_next = callfree;
	    callfree = p2;

	    break;
	}
    }

    func_splx();
}

int
hzto(tv)
	struct timeval *tv;
{
	long n;
	func_splhi();

	n = (tv->tv_sec - time.tv_sec) * 100 + (tv->tv_usec - time.tv_usec) / 10000;
	if (n < 0)
	    n = 0;

	func_splx();
	return n;
}

/*
uiomove(char *cp, int n, enum uio_rw rw, struct uio *uio)
{
    struct iovec *iov;
    u_int cnt;

    while (n > 0 && uio->uio_resid)
    {
	iov = uio->uio_iov;
	cnt = iov->iov_len;

	if (cnt == 0)
	{
	    uio->uio_iov++;
	    uio->uio_iovcnt--;
	    continue;
	}

	if (cnt > n)
	    cnt = n;

	if (rw == UIO_READ)
	    memcpy (iov->iov_base, cp, cnt);
	else
	    memcpy (cp, iov->iov_base, cnt);

	iov->iov_base += cnt;
	iov->iov_len -= cnt;
	uio->uio_resid -= cnt;
	uio->uio_offset += cnt;
	cp += cnt;
	n -= cnt;
    }

    return (0);
} */

extern char panicbuf[];

void
panic(const char *str, ...)
{
    if (paniced)
	return;

    paniced = 1;

    strncpy(panicbuf, str, PANICBUFLEN - 1);
    panicbuf[PANICBUFLEN - 1] = '\0';
}

#if 0
# define NSTAB	12
#else
# define NSTAB	96
#endif

struct stab_entry
{
    char	 *event;
    volatile int  flag;
#define STAB_WAITING 0
#define STAB_TIMEO   1
#define STAB_WOKEN   2
} stable[NSTAB];

void sleeptabinit()
{
    struct stab_entry *s;

    for (s = &stable[0]; s < &stable[NSTAB]; s++)
    {
	s->event = NULL;
	s->flag = STAB_WAITING;
    }
}

static void endtsleep(struct stab_entry *s);

/*
 * Returns true if UpCall 6 was claimed - ie a task window or some other
 * threading system let us sleep.
 */
static bool taskwindow_sleep(volatile int *pollword)
{
    /*
     * Always call UpCall 6 - modern TaskWindow modules don't mind if we're
     * not in a task window, and it allows other threading systems a look in.
     */
    return os_upcall(6, pollword) == 0;
}

int
tsleep(event, prio, wmesg, wait, sleep_task)
	void *event;
	char *wmesg;
	int prio, sleep_task, wait;
{
	struct stab_entry *s;
	int ms;
	int error = 0;

	ms = splimp();

#ifdef DEBUG
	Printf("tsleep(0x%x,0x%x,%s,%d,%d)\n", event, prio, wmesg, wait, sleep_task);
#endif
	for (s = &stable[0]; s < &stable[NSTAB]; s++) {
		if (s->event == NULL) {
			s->event = event;
			s->flag = STAB_WAITING;
			splx(ms);

			if (wait)
				timeout((timeout_func_t) endtsleep, s, wait);
			while (s->flag == STAB_WAITING) {
				bool slept = false;

				if (sleep_task)
					slept = taskwindow_sleep(&s->flag);

				/*
				 * Still waiting? Either not in a taskwindow, or it returned
				 * early. Go to sleep, little processor.
				 */
				if (!slept &&
				    (portable_features & PortableFeature_Idle) &&
				    s->flag == STAB_WAITING)
					portable_idle();

				if ((prio & PCATCH) && os_read_escape_state()) {
#ifdef DEBUG
					Printf("Escape seen\n");
#endif
					error = EINTR;
					goto out;
				}

				usermode_donothing();
			}
out:
			if (wait) {
				untimeout((timeout_func_t) endtsleep, s);
				if (s->flag == STAB_TIMEO) error = EWOULDBLOCK;
			}
			ms = splimp();
			s->event = NULL;
			splx(ms);
			return (error);
		}
	}

	splx(ms);
	panic("sleep");
	return (EFAULT);
}

static void
endtsleep(s)
	struct stab_entry *s;
{
	s->flag = STAB_TIMEO;
}

void
wakeup(event)
    void *event;
{
    struct stab_entry *s;
    func_splimp();

    for (s = &stable[0]; s < &stable[NSTAB]; s++)
	if (s->event == event)
	    s->flag = STAB_WOKEN;

    func_splx();
}

#define NBITS 32

int
ffs(mask)
	long mask;
{
	int i;

	for (i = 0; i < NBITS; i++) {
		if (mask & 1)
	    		return (i+1);
		mask >>= 1;
    	}

    	return (0);
}

#ifdef NoAsm
u_long
ntohl(u_long x)
{
    return( ((x & 0xff) << 24) | ((x & 0xff00) << 8) | \
	   ((x & 0xff0000) >> 8) | ((x & 0xff000000) >> 24) );
}
#endif

int
ntohs(int x)
{
    return ( (x & 0xff) << 8 | (x & 0xff00) >> 8 );
}

struct qelem
{
    struct qelem *q_forw;
    struct qelem *q_back;
    char *q_data;
};

void insque(void *e, void *p)
{
    struct qelem *elem, *pred;

    func_splhi();

    elem = (struct qelem *) e;
    pred = (struct qelem *) p;

    if (pred == 0 || elem == 0)
    {
	func_splrestore();
	return;
    }

    if (pred->q_forw)
	pred->q_forw->q_back = elem;

    elem->q_forw = pred->q_forw;
    pred->q_forw = elem;
    elem->q_back = pred;

    func_splrestore();
}

void remque(void *e)
{
    struct qelem *elem;

    func_splhi();

    elem = (struct qelem *) e;

    if (elem == 0)
    {
	func_splrestore();
	return;
    }

    if (elem->q_back != 0)
	elem->q_back->q_forw = elem->q_forw;

    if (elem->q_forw)
	elem->q_forw->q_back = elem->q_back;

    func_splrestore();
}

void callback_init(void)
{
    struct callback_record *cbptr;
    extern void callb_entry(void);
    extern void startup_entry(void);

    /*
     * manually fill in the callback tables here
     */
    cbptr = callbacks + CALLB_CALLB;
    cbptr->cb_entry = callb_entry;
    cbptr->cb_outstanding = 0;

    cbptr = callbacks + CALLB_STARTUP;
    cbptr->cb_entry = startup_entry;
    cbptr->cb_outstanding = 0;
}

void callback_finalise(void)
{
    int i;
    func_splimp();

    /*
     * loop over all possible callbacks
     */
    for( i = 0; i < NCALLBACKS; ++i )
    {
	struct callback_record *cbptr = callbacks + i;

	while( cbptr->cb_outstanding > 0 )
	{
	    os_remove_call_back(cbptr->cb_entry, module_wsp);
	    cbptr->cb_outstanding--;
	}
    }

    func_splx();
}

void callback_entered(int callbackno)
{
    func_splimp();

    callbacks[callbackno].cb_outstanding--;
    func_splx();
}

int callback(int callbackno)
{
    struct callback_record *cbptr = callbacks + callbackno;
    int s = splimp();

    cbptr->cb_outstanding++;
    splx(s);

    return os_add_call_back(cbptr->cb_entry, module_wsp) ? -1 : 0;
}

/*
 * Check that a proposed value to load into the .it_value or
 * .it_interval part of an interval timer is acceptable, and
 * fix it to have at least minimal value (i.e. if it is less
 * than the resolution of the clock, round it up.)
 */
int
itimerfix(tv)
	struct timeval *tv;
{

	if (tv->tv_sec < 0 || tv->tv_sec > 100000000 ||
	    tv->tv_usec < 0 || tv->tv_usec >= 1000000)
		return (EINVAL);
	if (tv->tv_sec == 0 && tv->tv_usec != 0 && tv->tv_usec < tick)
		tv->tv_usec = tick;
	return (0);
}

/*
 * Add and subtract routines for timevals.
 * N.B.: subtract routine doesn't deal with
 * results which are before the beginning,
 * it just gets very confused in this case.
 * Caveat emptor.
 */
void
timevaladd(t1, t2)
	struct timeval *t1, *t2;
{

	t1->tv_sec += t2->tv_sec;
	t1->tv_usec += t2->tv_usec;
	timevalfix(t1);
}

void
timevalsub(t1, t2)
	struct timeval *t1, *t2;
{

	t1->tv_sec -= t2->tv_sec;
	t1->tv_usec -= t2->tv_usec;
	timevalfix(t1);
}

void
timevalfix(t1)
	struct timeval *t1;
{

	if (t1->tv_usec < 0) {
		t1->tv_sec--;
		t1->tv_usec += 1000000;
	}
	if (t1->tv_usec >= 1000000) {
		t1->tv_sec++;
		t1->tv_usec -= 1000000;
	}
}

#define secs0070 (((unsigned)60*60*24) * (365 * 70 + 17)) /* less than 2^32 */

static long machinetime_to_realtime(machinetime *t, long *csecs)
{
    machinetime bt, w, w2;

    /* to two 3-byte things - for divide */
    w.h = ((t->h & 255) << 8) | (t->l >> 24);
    w.l = t->l & 0xffffff;

    /* turn csecs to secs */
    w2.h = w.h / 100;
    w2.l = ((w.h % 100 << 24) | w.l) / 100;
    if (csecs)
        *csecs = ((w.h % 100L << 24) | w.l) % 100;

    /* back to 8 byte binary */
    bt.h = w2.h >> 8;
    bt.l = (w2.h << 24) | w2.l;

    /* normalise to Jan70 instead of Jan00... */
    if (bt.l < secs0070) bt.h--;
    bt.l -= secs0070;

    /*
     * if high word is non-zero then date
     * is unset/out of unix range...
     */
    return bt.h ? -1 : bt.l;
}

/**********************************************************************/

/*
 * Return 1 if IOC/IOMD is present (OS_ReadSysInfo 2 reports I/O control
 * chip = 0 or 1 - IOC or IOMD).
 */
static int iomd_present()
{
    return (osreadsysinfo_hardware0() & 0xFF00) <= 0x0100 ? 1 : 2;
}

/**********************************************************************/

/*
 * Access to the real-time clock. This is read from the RTC,
 * so is not monotonic if some idiot changes the time. If you
 * want a monotonic time, look at the time global variable.
 *
 * We do get microsecond precision though.
 *
 */
void microtime(struct timeval *tv)
{
    static int iomd_check;  /* 0 = not checked, 1 = present, 2 = no counter present, 3 = use HAL */
    static unsigned long timer_divider; /* ticks per microsecond */
    machinetime t1, t2;
    unsigned long timer_count;
    unsigned long timer_period = 19999; /* default for non-HAL case */

    /* Only poke the hardware if we're sure it's there :) */
    if (!iomd_check)
    {
        if (_swix(OS_Hardware, _INR(8,9)|_OUT(0), 0, EntryNo_HAL_CounterRate, &timer_divider) != NULL)
        {
            iomd_check = iomd_present();
            timer_divider = 2;
        }
        else
        {
            iomd_check = 3;
            timer_divider /= 1000000;
            if (timer_divider == 0) timer_divider = 1; /* avoid division by 0 */
        }
    }

    if (iomd_check != 2)
    {
        if (iomd_check == 3)
            _swix(OS_Hardware, _INR(8,9)|_OUT(0), 0, EntryNo_HAL_CounterPeriod, &timer_period);

        /* Check initial time */
        osword_read_realtime(&t1);

        /* Read the Timer 0 value - it counts down from 19999 to 0,
         * the clock tick occurring as it changes from 0 to 19999.
         */
        if (iomd_check == 1)
            timer_count = get_t0_count();
        else
            _swix(OS_Hardware, _INR(8,9)|_OUT(0), 0, EntryNo_HAL_CounterRead, &timer_count);
    }

    /* Check new time */
    osword_read_realtime(&t2);

    tv->tv_sec = machinetime_to_realtime(&t2, &tv->tv_usec);
    tv->tv_usec *= 10000;

    if (iomd_check != 2 && t1.l == t2.l)
    {
        /* Clock didn't tick - add in timer count */
        tv->tv_usec += (timer_period - timer_count) / timer_divider;
    }
    else
    {
        /* Clock ticked - let it rest at the 10000us boundary */
    }
}
@


4.12
log
@Get Internet event numbers from Hdr:RISCOS and a microoptimisation
unixenv.c/whoami.c: don't define event numbers locally, use headers.
tick_entry.s: if available use the REV instruction for htonl().

Requires Kernel-5_81 for event numbers.

Version 5.62. Tagged as 'Internet-5_62'
@
text
@d446 3
d457 2
a458 2
	s->event = (char *)NULL;
	s->flag = 0;
d493 1
a493 1
		if (s->event == 0) {
d495 1
a495 1
			s->flag = 0;
d500 1
a500 1
			while (s->flag == 0) {
d512 1
a512 1
				    s->flag == 0)
d526 1
a526 1
			if (wait)
d528 2
d531 1
a531 2
			s->event = 0;
			s->flag = 0;
d546 1
a546 1
	s->flag = 1;
d558 1
a558 1
	    s->flag = 1;
@


4.11
log
@Delete local user_mode_donothing() and replace with usermode_donothing() from AsmUtils.
Makefilse uses ModuleLibs too.
Lots of STM/LDM replaced with Push and Pull macros.
Local definitions in 'swiveneers' replaced with header files.

Version 5.53. Tagged as 'Internet-5_53'
@
text
@d51 1
a51 2

#define TickerV  28
a76 6
#define INTERNET_EVENT	    19

#define SOCKET_ASYNC_EVENT  1
#define SOCKET_URGENT_EVENT 2
#define SOCKET_BROKEN_EVENT 3

d164 1
a164 1
	event = SOCKET_ASYNC_EVENT;
d168 1
a168 1
	event = SOCKET_URGENT_EVENT;
d172 1
a172 1
	event = SOCKET_BROKEN_EVENT;
d180 1
a180 1
    return os_generate_event(INTERNET_EVENT, event, sockid, 0) ? -1 : 0;
d192 1
a192 1
    return os_generate_event(INTERNET_EVENT, event, sockid, port) ? -1 : 0;
@


4.10
log
@  HALised microtime()
Detail:
  microtime(), which reads the current time into a struct timeval (seconds
  and microseconds) looked for an IOMD, and if not then dropped back to
  centisecond accuracy. This hadn't been noticed before, but upon trying the
  module on a 32-bit IOMD build, its attempt to access IOMD at its 26-bit
  address aborted. Now changed to use the HAL if possible, so all HAL machines
  now have a nice accurate microtime().
Admin:
  Tested to the extent that it doesn't abort any more - precise checking of
  microtime() values has not been done, nor any analysis of the effect of
  the increased accuracy.

Version 5.52. Tagged as 'Internet-5_52'
@
text
@a45 1
#include "module.h"
d48 2
d52 1
a52 1
#define TickerV	 28
d527 1
a527 1
				user_mode_donothing();
@


4.9
log
@  Econet_InetRxDirect interface extended.
Detail:
  Previously, the SWI didn't care about any return values. The Internet
  module would either free the MBuf passed or send it on to the socket,
  depending on the value of m_len on exit from the SWI. This still works,
  but SWI handlers can now set R1 to zero on exit to claim ownership of
  the MBuf. In this case, the item is neither freed nor passed on to the
  socket, and the new owner must be very careful to make sure that they
  do an appropriate m_free later.
Admin:
  This change was implemented to allow UDPV to point the MPEG system
  directly to the data in the MBuf chains it was passed rather than taking
  a local copy. It has been tested with both new and old UDPV versions and
  both work as expected. Note that any module using the new interface will
  absolutely require it to be present (new UDPV modules built to use the
  interface extension will refuse to start if Internet is too old).

Version 5.44. Tagged as 'Internet-5_44'
@
text
@d49 2
d826 2
a827 1
    static int iomd_check;  /* 0 = not checked, 1 = present, 2 = not present */
d830 1
d834 13
a846 1
        iomd_check = iomd_present();
d848 1
a848 1
    if (iomd_check == 1)
d850 3
d859 4
a862 1
        timer_count = get_t0_count();
d871 1
a871 1
    if (iomd_check == 1 && t1.l == t2.l)
d874 1
a874 1
        tv->tv_usec += (19999 - timer_count) / 2;
@


4.8
log
@Restored DELAY_EVENTS functionality.

Detail:
VideoControl was having a nasty reentrancy problem inside its event handler;
we've been sending out events at points where a BSD Unix system wouldn't and
exposing a number of potential problems. Fixed by restoring the delayed event
scheme used in earlier versions of Internet 5, but with an extra event send
inside the packet input loop which should alleviate the high load problems
seen with the NEC video client.

Seems to work fine, but we've been unable to get the NEC video client to
work at all, let alone test it on this Internet module. Doesn't matter for
now because we're not shipping it :)

Version 5.43. Tagged as 'Internet-5_43'
@
text
@d200 1
a200 1
void rsignal(struct proc *p, struct mbuf *m, struct sockaddr *sa, char *esrc, int unit, int swinum, struct mbuf *n)
d208 1
a208 1
    econet_inet_rx_direct(sockid, m, sa, esrc, unit, swinum, n);
@


4.7
log
@Added power-saving - calls Portable_Idle when waiting for a network operation
to complete.

Version 5.37. Tagged as 'Internet-5_37'
@
text
@d516 1
a516 1
				if ((prio & PCATCH) && escape_seen()) {
@


4.6
log
@microtime() now returns microsecond accuracy.
Random number generator now seeded from microtime(), machine ID and
hardware addresses of DCI drivers.
Some previously untested debugging code fixed to compile.

Version 5.34. Tagged as 'Internet-5_34'
@
text
@d19 1
d465 5
a469 1
static void taskwindow_sleep(volatile int *pollword)
d471 5
a475 7
    int in_taskwindow;
    _kernel_oserror *e;

    e=taskwindow_task_info(0, &in_taskwindow);

    if (!e && in_taskwindow)
        os_upcall(6, pollword);
d502 1
d505 10
a514 1
					taskwindow_sleep(&s->flag);
@


4.5
log
@Added new FreeBSD sysctl handling using linker magic.
A few new sysctls added as a result.
SO_TIMESTAMP now gives real time, not Internet's internal time.
DHCP/BOOTP parsing picks up URL option and pops it into Inet$URL.
Requires TCPIPLibs 5.25 and link 5.12.

Version 5.31. Tagged as 'Internet-5_31'
@
text
@a696 20
 * Access to our monotonic real-time clock. This is read
 * at module initialisation from the RTC, and is not affected
 * by any changes to the clock. Thus, on an NC-type device,
 * it will not actual contain a correct time. Where
 * monotonicity or speed are required, use microtime(). Where
 * a potentially more accurate real time is required, use
 * realtime().
 */
void
microtime(tv)
	struct timeval *tv;
{
	func_splhi();

	*tv = time;

	func_splx();
}

/*
d757 1
a757 3
#define secs0070 (((unsigned)86400) * (365 * 70 + 17))	/* less than 2^32 */

typedef struct {unsigned int l,h;} machinetime;
d759 1
a759 1
unsigned long realtime(long *usec)
a760 4
    /*
     * this is time(), recoded here to avoid the absurd 6ms delay
     * in the RISC OS 3 Shared C Library (penalty is timezone())
     */
a761 8
    unsigned int cs;

    /*
     * read timer as 5 byte integer
     * centiseconds since 1/1/1900
     */
    bt.l = 3;
    _kernel_osword(14, (int *)&bt);
d764 2
a765 2
    w.h = ((bt.h & 255) << 8) | (bt.l >> 24);
    w.l = bt.l & 0xffffff;
d769 3
a771 3
    w2.l = ((w.h % 100 << 24) | w.l);
    cs = w2.l % 100;
    w2.l /= 100;
a780 4
    /* return microseconds, if desired */
    if (usec)
        *usec = cs * 10000;

d788 2
d791 2
a792 3
 * Fudgery - the Unix bits don't expect malloc to return NULL
 * for zero length, which is what the C run-time helpfully
 * does in supervisor mode. OS_Module doesn't.
d794 1
a794 1
void *inet_malloc(size_t n)
d796 1
a796 3
    void *p = NULL;
    _swix(OS_Module, _IN(0)|_IN(3)|_OUT(2), 6, n, &p);
    return p;
d799 11
a809 1
void inet_free(void *p)
d811 34
a844 1
    _swix(OS_Module, _IN(0)|_IN(2), 7, p);
@


4.4
log
@IP timestamps and TCP sequence numbers now generated from system real-time
clock, rather than local monotonic copy. This gives a better chance of
uniqueness between reboots, as we should have found time from a server
at some stage.
Local clock initialised from system clock with centisecond accuracy.
IP firewalling and multicast routing disabled by default - specify them in
components file if really wanted.

Version 5.23. Tagged as 'Internet-5_23'
@
text
@d825 17
@


4.3
log
@Removed limitation on length of IP interrupt queue, and made psignal
generate events immediately, rather than at the end of callbacks.
In both respects, the behaviour is restored to that of Internet 4. This
fixes some performance problems with data streaming near the limit of the
machine's capability.

Version 5.17. Tagged as 'Internet-5_17'
@
text
@d696 9
d781 1
a781 1
long realtime()
d788 1
d794 1
a794 1
    bt.l = 3;				/* presumably 'request time' arg */
d803 3
a805 1
    w2.l = ((w.h % 100 << 24) | w.l) / 100;
d814 4
@


4.2
log
@Version Spinner_B7 taken
@
text
@d80 1
d82 1
d98 4
d103 3
d108 1
d147 1
@


4.1
log
@Initial revision
@
text
@d15 1
a15 5
/* -*-C-*-
 *
 * $Header: /ax/networking:Internet/lib/unixenv.c:networking  1.6  $
 * $Source: /ax/networking:Internet/lib/unixenv.c: $
 *
a16 31
 *
 * $Log:	unixenv.c,v $
 * Revision 1.6  95/03/31  14:02:09  kwelton
 * Improved string handling within panic().
 * 
 * Revision 1.5  95/03/31  11:44:58  kwelton
 * Callbacks are now handled slightly differently in a new scheme which allows
 * pending callbacks to be cancelled during module finalisation.
 * 
 * Revision 1.4  95/03/19  18:21:52  kwelton
 * There is a problem somewhere in sleep() - it is running out of sleeptab
 * entries.  The mechanism behind this is not understood yet, but the
 * imminent freeze of the Black ROMs needs some sort of fix, so:
 * 
 * 1)  Put spl protection around table manipulations - this is a bug fix,
 *     but it is not certain that it is the cause of the sleep() panics.
 * 
 * 2)  The size of the sleep table has been increased from 12 (a random
 *     number?) to 96 (max. no. of sockets open at one time) in a rather
 *     sad attempt to shove the problem under the carpet.
 * 
 * Revision 1.3  95/01/24  15:30:12  kwelton
 * Econet_InetRxDirect is declared in "swis.h", and does not need to be
 * defined here.
 * 
 * Revision 1.2  95/01/03  13:35:00  kwelton
 * Tidied up declaration of panicbuf, fixed header inclusion.
 * 
 * Revision 1.1  94/12/02  10:48:46  kwelton
 * Initial revision
 * 
d18 1
d23 2
d27 2
a29 1
#include "sys/user.h"
d31 4
d37 6
d44 1
d46 1
d50 2
d59 1
a59 2
struct user u = { 0 };
struct proc proc = { 0 };
d61 2
a62 7
struct	callout
{
    int		    c_time;		/* incremental time */
    caddr_t	    c_arg;		/* argument to routine */
    int		  (*c_func)();		/* routine */
    struct callout *c_next;
} callout[NCALLOUT] = { 0 };
d64 1
a64 2
struct	callout *callfree = 0;
struct	callout calltodo = { 0 };
d66 3
a68 1
int	ncallout = NCALLOUT;
d70 1
a70 3
extern void bcopy();
extern int user_mode_donothing();
volatile int callo_pending = 0;
d74 16
a89 1
u_init(void)
d91 6
a96 2
    u.u_procp = &proc;
    proc.p_wchan = 0;
d99 2
a100 1
struct proc *pfind(short p)
d102 1
a102 2
    return ((struct proc *)p);
}
d104 3
a106 3
gsignal(int p, int sig)
{
    generate_event(p, sig);
d109 27
a135 3
psignal(int p, int sig)
{
    generate_event(p, sig);
d138 3
a140 7
#define INTERNET_EVENT	    19

#define SOCKET_ASYNC_EVENT  1
#define SOCKET_URGENT_EVENT 2
#define SOCKET_BROKEN_EVENT 3

int generate_event(int s, int sig)
a141 2
    _kernel_swi_regs r;
    int sockid;
d143 2
d146 6
a151 3
    sockid = s - 1;
    if (sockid < 0)
	return(NULL);
d171 15
a185 4
    r.r[0] = INTERNET_EVENT;
    r.r[1] = event;
    r.r[2] = sockid;
    return(_kernel_swi(XOS_Bit | OS_GenerateEvent, &r, &r) != 0 ? -1 : 0);
d188 1
a188 1
rsignal(int s, int m, int sa, int esrc, int unit, int swinum, int n)
a189 1
    _kernel_swi_regs r;
d192 1
a192 1
    sockid = s - 1;
d194 1
a194 1
	return (0);
d196 1
a196 8
    r.r[0] = sockid;
    r.r[1] = m;
    r.r[2] = sa;
    r.r[3] = esrc;
    r.r[4] = unit;
    r.r[5] = swinum;
    r.r[6] = n;
    return(_kernel_swi(XOS_Bit | Econet_InetRxDirect, &r, &r) != 0 ? -1 : 0);
d199 1
a199 1
_kernel_oserror *calleverytick(int (*fun)())
d201 1
a201 6
    _kernel_swi_regs r;

    r.r[0] = TickerV;
    r.r[1] = (int)fun;
    r.r[2] = (int)module_wsp;
    return(_kernel_swi(XOS_Bit | OS_Claim, &r, &r));
d204 1
a204 1
removetickerevent(int (*fun)())
d206 1
a206 6
    _kernel_swi_regs r;

    r.r[0] = TickerV;
    r.r[1] = (int)fun;
    r.r[2] = (int)module_wsp;
    (void)_kernel_swi(XOS_Bit | OS_Release, &r, &r);
d209 1
a209 1
init_callout(void)
d220 6
a225 1
tick_handler(int *r, void *pw)
d231 8
d251 6
a256 3
	if (p1->c_time > 0 && --p1->c_time == 0)
	{
	    needtocall = 1;
a257 1
	}
d267 1
d272 1
d276 2
a277 2
    caddr_t arg;
    int (*func)();
d279 1
d287 1
d291 1
d299 1
a299 1
timeout(int (*fun)(), caddr_t arg, int t)
d301 6
a306 2
    struct callout *p1, *p2, *pnew;
    int s = splimp();
d308 2
a309 2
    if (t <= 0)
	t = 1;
d311 6
a316 7
    pnew = callfree;
    if (pnew == NULL)
    {
	panic("timeout table overflow");
	splx(s);
	return;
    }
d318 10
a327 10
    callfree = pnew->c_next;
    pnew->c_arg = arg;
    pnew->c_func = fun;
    for (p1 = &calltodo; (p2 = p1->c_next) && p2->c_time < t; p1 = p2)
	if (p2->c_time > 0)
	    t -= p2->c_time;

    p1->c_next = pnew;
    pnew->c_next = p2;
    pnew->c_time = t;
d329 2
a330 2
    if (p2)
	p2->c_time -= t;
d332 1
a332 1
    splx(s);
d339 1
a339 1
untimeout(int (*fun)(), caddr_t arg)
d342 1
a342 1
    int s = splimp();
d359 1
a359 1
    splx(s);
d362 3
a364 1
hzto(struct timeval *tv)
d366 2
a367 4
    long ticks = 0;

    if (tv->tv_sec > 0)
	ticks += (tv->tv_sec * 100);
d369 3
a371 2
    if (tv->tv_usec > 0)
	ticks += (tv->tv_usec / 10000);
d373 2
a374 1
    return (ticks);
d377 1
d412 1
a412 28
}

copyout(caddr_t from, caddr_t to, int cnt)
{
    memcpy(to, from, cnt);
    return (0);
}

copyin(caddr_t from, caddr_t to, int cnt)
{
    memcpy(to, from, cnt);
    return (0);
}

void ovbcopy(caddr_t f, caddr_t t, int count)
{
    u_char *from = (u_char *)f, *to = (u_char *)t;
    if (from < to)
    {
	from += count;
	to += count;
	while (count-- > 0)
	    *--to = *--from;
    }
    else
	while (count-- > 0)
	    *to++ = *from++;
}
d416 2
a417 1
panic(char *str)
a418 2
    int i;

d438 1
a438 1
} stable[NSTAB] = { 0 };
d440 1
a440 1
sleeptabinit(void)
d449 1
d451 1
a451 2
    return(0);
}
d453 1
a453 1
sleep(caddr_t event, int prio)
d455 2
a456 2
    struct stab_entry *s;
    int ms = splimp();
d458 1
a458 18
    for (s = &stable[0]; s < &stable[NSTAB]; s++)
    {
	if (s->event == (char *)NULL)
	{
	    s->event = event;
	    s->flag = 0;
	    splx(ms);

	    while (s->flag == 0)
	    {
		if (escape_seen())
		{
		    ms = splimp();
		    s->event = (char *)NULL;
		    s->flag = 0;
		    splx(ms);
		    return (1);
		}
d460 2
a461 14
		user_mode_donothing();
	    }

	    ms = splimp();
	    s->event = (char *)NULL;
	    s->flag = 0;
	    splx(ms);
	    return (0);
	}
    }

    splx(ms);
    panic("sleep");
    return (-1);
d464 5
a468 1
wakeup(caddr_t event)
d470 5
a474 2
    struct stab_entry *s;
    int ms = splimp();
d476 36
a511 3
    for (s = &stable[0]; s < &stable[NSTAB]; s++)
	if (s->event == event)
	    s->flag = 1;
d513 3
a515 1
    splx(ms);
d518 3
a520 1
imin(int a, int b)
d522 1
a522 1
    return (a < b ? a : b);
d525 3
a527 1
imax(int a, int b)
d529 2
a530 2
    return (a > b ? a : b);
}
d532 3
a534 4
unsigned min(u_int a, u_int b)
{
    return (a < b ? a : b);
}
d536 1
a536 3
unsigned max(u_int a, u_int b)
{
    return (a > b ? a : b);
d541 3
a543 20
ffs(long mask)
{
    int i;

    for (i = 0; i < NBITS; i++)
    {
	if (mask & 1)
	    return (i+1);
	mask >>= 1;
    }

    return (0);
}

void bcopy(char *src, char *dst, int length)
{
    memcpy(dst, src, length);
}

int bcmp(char *b1, char *b2, int length)
d545 1
a545 2
    return (memcmp(b1, b2, length));
}
d547 5
a551 4
void bzero(char *b, int length)
{
    memset(b, 0, length);
}
d553 1
a553 8
htonl(u_long x)
{
    return ( ntohl(x) );
}

htons(int x)
{
    return ( ntohs(x) );
d556 2
d563 1
d565 1
d578 1
a578 1
void _insque(struct qelem *elem, struct qelem *pred)
d580 6
a585 1
    int s = splhi();
d589 1
a589 1
	splrestore(s);
d600 1
a600 1
    splrestore(s);
d603 1
a603 1
void _remque(struct qelem *elem)
d605 5
a609 1
    int s = splhi();
d613 1
a613 1
	splrestore(s);
d623 1
a623 1
    splrestore(s);
d647 1
a647 7
    _kernel_swi_regs r;
    int s = splimp();

    /*
     * fill in module address
     */
    r.r[1] = (int)module_wsp;
a655 2
	r.r[0] = (int)(cbptr->cb_entry);

d658 1
a658 1
	    (void)_kernel_swi(XOS_Bit | OS_RemoveCallBack, &r, &r);
d663 1
a663 1
    splx(s);
d668 1
a668 1
    int s = splimp();
d671 1
a671 1
    splx(s);
a675 1
    _kernel_swi_regs r;
d682 48
a729 3
    r.r[0] = (int)cbptr->cb_entry;
    r.r[1] = (int)module_wsp;
    return((_kernel_swi(XOS_Bit | OS_AddCallBack, &r, &r) != NULL) ? -1 : 0);
d732 66
a797 1
/* EOF unixenv.c */
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d15 5
a19 1
/*
d21 31
a52 1
#include <string.h>
a56 2
#include "sys/systm.h"
#include "sys/queue.h"
a58 2
#include "sys/kernel.h"
#include "sys/callout.h"
d60 1
a61 4
#include "sys/socket.h" //
#include "sys/socketvar.h" //
#include "sys/domain.h" //
#include "sys/protosw.h" //
a63 6
#include "net/route.h" //

#include "netinet/in.h" //
#include "netinet/in_systm.h"
#include "netinet/ip.h"
#include "netinet/in_pcb.h" //
a64 1
#include "debug.h"
a65 1
#include "swiveneers.h"
a68 2
#define NCALLOUT 20

d76 2
a77 1
struct	callout callout[NCALLOUT];
d79 10
a88 2
struct	callout *callfree;
struct	callout calltodo;
d92 3
a94 5
extern struct socket *getsock(int s);
extern int escape_seen(void);
static int generate_event(int sockid, int sig);

volatile int callo_pending;
d98 5
a102 1
#define INTERNET_EVENT	    19
d104 4
a107 5
#define SOCKET_ASYNC_EVENT  1
#define SOCKET_URGENT_EVENT 2
#define SOCKET_BROKEN_EVENT 3

long siglist[SOCKTABSIZE];
d109 1
a109 8
/*
 * Queue a signal for later processing - ie as we exit a SWI or our
 * callback handler
 */
void
psignal(p, signum)
	struct proc *p;
	register int signum;
d111 1
a111 6
	register int sockid = (int) p - 1;

	if (sockid < 0)
		return;

	siglist[sockid] |= sigmask(signum);
d114 1
a114 2
void
sendallsignals()
d116 2
a117 1
	register int sockid;
d119 1
a119 4
	for (sockid = 0; sockid < SOCKTABSIZE; sockid++)
		if (siglist[sockid])
			sendsignals(sockid);
}
d121 3
a123 28
/*
 * Send pending signals on a socket id. Be careful not to erase signals
 * that are raised by routines responding to the signals - save them for
 * later processing
 */
void
sendsignals(sockid)
	register int sockid;
{
	register int signum;
	register long mask;

	mask = siglist[sockid];

	for (;;) {
		if (mask == 0)
			return;
		signum = ffs(mask);
#ifdef DIAGNOSTIC
		if (signum != SIGIO && signum != SIGURG && signum != SIGPIPE)
			Printf("Unknown signal pending for socket %d: %d\n",
				sockid, signum);
#endif
		siglist[sockid] &= ~sigmask(signum);
		mask &= ~sigmask(signum);
		generate_event(sockid, signum);
	}
}
d125 1
a125 3
static int
generate_event(sockid, sig)
	int sockid, sig;
d127 2
a129 2
    int port = 0;
    struct socket *so;
d131 3
a133 6
#ifdef DEBUG
    if( DODEBUG(DBGEVENTS) )
	Printf("\021\04generate_event: SIG%s on socket %d\021\07\n",
	       (sig == SIGIO) ? "IO" : (sig == SIGURG) ? "URG" : "PIPE",
	       sockid);
#endif
d153 4
a156 15
#   ifdef NO_PORT_EVENT
    return os_generate_event(INTERNET_EVENT, event, sockid, 0) ? -1 : 0;
#   else
    /* If it's an Inet socket, fill in R3 with the local port number */
    so=getsock(sockid);
    if (so && so->so_proto->pr_domain->dom_family == PF_INET)
    {
        struct inpcb *inp=(struct inpcb *) so->so_pcb;

        if (inp)
            port = inp->inp_lport;
    }

    return os_generate_event(INTERNET_EVENT, event, sockid, port) ? -1 : 0;
#   endif
d159 1
a159 1
void rsignal(struct proc *p, struct mbuf *m, struct sockaddr *sa, char *esrc, int unit, int swinum, struct mbuf *n)
d161 1
d164 1
a164 1
    sockid = (int)p - 1;
d166 1
a166 1
	return;
d168 8
a175 1
    econet_inet_rx_direct(sockid, m, sa, esrc, unit, swinum, n);
d178 1
a178 1
_kernel_oserror *calleverytick(void (*fun)(void))
d180 6
a185 1
    return os_claim(TickerV, fun, module_wsp);
d188 1
a188 1
void removetickerevent(void (*fun)(void))
d190 6
a195 1
    os_release(TickerV, fun, module_wsp);
d198 1
a198 1
void init_callout(void)
d209 1
a209 6
/*
 * This routine, plus its veneer, have been recrafted in assembler, and can
 * be found in s.tick_entry - KJB
 */
#ifdef NoAsm
int tick_handler(int *r, void *pw)
a214 8
     * Update time ticker
     */
    if ((time.tv_usec += 10000) >= 1000000) {
        time.tv_usec = 0;
        time.tv_sec++;
    }

    /*
d227 3
a229 6
	if( --p1->c_time > 0 )
	    break;

	needtocall = 1;

	if( p1->c_time == 0 )
d231 1
a240 1
#endif
a244 1
void
d248 2
a249 2
    void *arg;
    timeout_func_t func;
a250 1
    int s;
a257 1
        s = splimp();
a260 1
	splx(s);
d268 1
a268 1
void timeout(timeout_func_t fun, void *arg, int t)
d270 2
a271 2
	struct callout *p1, *p2, *pnew;
	func_splimp();
d273 2
a274 3
#if 0
        Printf("timeout(%x,%x,%d)\n", fun, arg, t);
#endif
d276 7
a282 2
	if (t <= 0)
		t = 1;
d284 10
a293 6
	pnew = callfree;
	if (pnew == NULL) {
		panic("timeout table overflow");
		func_splx();
		return;
	}
d295 2
a296 10
	callfree = pnew->c_next;
	pnew->c_arg = arg;
	pnew->c_func = fun;
	for (p1 = &calltodo; (p2 = p1->c_next) && p2->c_time < t; p1 = p2)
		if (p2->c_time > 0)
			t -= p2->c_time;

	p1->c_next = pnew;
	pnew->c_next = p2;
	pnew->c_time = t;
d298 1
a298 4
	if (p2)
		p2->c_time -= t;

	func_splx();
d305 1
a305 1
void untimeout(timeout_func_t fun, void *arg)
d308 1
a308 1
    func_splimp();
d325 1
a325 1
    func_splx();
d328 1
a328 3
int
hzto(tv)
	struct timeval *tv;
d330 4
a333 2
	long n;
	func_splhi();
d335 2
a336 3
	n = (tv->tv_sec - time.tv_sec) * 100 + (tv->tv_usec - time.tv_usec) / 10000;
	if (n < 0)
	    n = 0;
d338 1
a338 2
	func_splx();
	return n;
a340 1
/*
d375 28
a402 1
} */
d406 1
a406 2
void
panic(const char *str, ...)
d408 2
d429 1
a429 1
} stable[NSTAB];
d431 1
a431 1
void sleeptabinit()
d440 2
d444 26
a469 1
static void endtsleep(struct stab_entry *s);
d471 14
a484 1
static void taskwindow_sleep(volatile int *pollword)
d486 2
a487 2
    int in_taskwindow;
    _kernel_oserror *e;
d489 3
a491 1
    e=taskwindow_task_info(0, &in_taskwindow);
d493 1
a493 2
    if (!e && in_taskwindow)
        os_upcall(6, pollword);
d496 1
a496 5
int
tsleep(event, prio, wmesg, wait, sleep_task)
	void *event;
	char *wmesg;
	int prio, sleep_task, wait;
d498 2
a499 3
	struct stab_entry *s;
	int ms;
	int error = 0;
d501 4
a504 1
	ms = splimp();
d506 3
a508 40
#ifdef DEBUG
	Printf("tsleep(0x%x,0x%x,%s,%d,%d)\n", event, prio, wmesg, wait, sleep_task);
#endif
	for (s = &stable[0]; s < &stable[NSTAB]; s++) {
		if (s->event == 0) {
			s->event = event;
			s->flag = 0;
			splx(ms);

			if (wait)
				timeout((timeout_func_t) endtsleep, s, wait);
			while (s->flag == 0) {

				if (sleep_task)
					taskwindow_sleep(&s->flag);

				if ((prio & PCATCH) && escape_seen()) {
#ifdef DEBUG
					Printf("Escape seen\n");
#endif
					error = EINTR;
					goto out;
				}

				user_mode_donothing();
			}
out:
			if (wait)
				untimeout((timeout_func_t) endtsleep, s);
			ms = splimp();
			s->event = 0;
			s->flag = 0;
			splx(ms);
			return (error);
		}
	}

	splx(ms);
	panic("sleep");
	return (EFAULT);
d511 1
a511 3
static void
endtsleep(s)
	struct stab_entry *s;
d513 1
a513 1
	s->flag = 1;
d516 3
a518 3
void
wakeup(event)
    void *event;
d520 8
a527 2
    struct stab_entry *s;
    func_splimp();
d529 2
a530 3
    for (s = &stable[0]; s < &stable[NSTAB]; s++)
	if (s->event == event)
	    s->flag = 1;
d532 3
a534 1
    func_splx();
d537 4
a540 1
#define NBITS 32
d542 1
a542 3
int
ffs(mask)
	long mask;
d544 2
a545 1
	int i;
d547 4
a550 5
	for (i = 0; i < NBITS; i++) {
		if (mask & 1)
	    		return (i+1);
		mask >>= 1;
    	}
d552 3
a554 1
    	return (0);
a556 2
#ifdef NoAsm
u_long
a561 1
#endif
a562 1
int
d575 1
a575 1
void insque(void *e, void *p)
d577 1
a577 6
    struct qelem *elem, *pred;

    func_splhi();

    elem = (struct qelem *) e;
    pred = (struct qelem *) p;
d581 1
a581 1
	func_splrestore();
d592 1
a592 1
    func_splrestore();
d595 1
a595 1
void remque(void *e)
d597 1
a597 5
    struct qelem *elem;

    func_splhi();

    elem = (struct qelem *) e;
d601 1
a601 1
	func_splrestore();
d611 1
a611 1
    func_splrestore();
d635 7
a641 1
    func_splimp();
d650 2
d654 1
a654 1
	    os_remove_call_back(cbptr->cb_entry, module_wsp);
d659 1
a659 1
    func_splx();
d664 1
a664 1
    func_splimp();
d667 1
a667 1
    func_splx();
d672 1
d679 3
a681 48
    return os_add_call_back(cbptr->cb_entry, module_wsp) ? -1 : 0;
}

void
microtime(tv)
	struct timeval *tv;
{
	func_splhi();

	*tv = time;

	func_splx();
}

/*
 * Check that a proposed value to load into the .it_value or
 * .it_interval part of an interval timer is acceptable, and
 * fix it to have at least minimal value (i.e. if it is less
 * than the resolution of the clock, round it up.)
 */
int
itimerfix(tv)
	struct timeval *tv;
{

	if (tv->tv_sec < 0 || tv->tv_sec > 100000000 ||
	    tv->tv_usec < 0 || tv->tv_usec >= 1000000)
		return (EINVAL);
	if (tv->tv_sec == 0 && tv->tv_usec != 0 && tv->tv_usec < tick)
		tv->tv_usec = tick;
	return (0);
}

/*
 * Add and subtract routines for timevals.
 * N.B.: subtract routine doesn't deal with
 * results which are before the beginning,
 * it just gets very confused in this case.
 * Caveat emptor.
 */
void
timevaladd(t1, t2)
	struct timeval *t1, *t2;
{

	t1->tv_sec += t2->tv_sec;
	t1->tv_usec += t2->tv_usec;
	timevalfix(t1);
d684 1
a684 66
void
timevalsub(t1, t2)
	struct timeval *t1, *t2;
{

	t1->tv_sec -= t2->tv_sec;
	t1->tv_usec -= t2->tv_usec;
	timevalfix(t1);
}

void
timevalfix(t1)
	struct timeval *t1;
{

	if (t1->tv_usec < 0) {
		t1->tv_sec--;
		t1->tv_usec += 1000000;
	}
	if (t1->tv_usec >= 1000000) {
		t1->tv_sec++;
		t1->tv_usec -= 1000000;
	}
}

#define secs0070 (((unsigned)86400) * (365 * 70 + 17))	/* less than 2^32 */

typedef struct {unsigned int l,h;} machinetime;

long realtime()
{
    /*
     * this is time(), recoded here to avoid the absurd 6ms delay
     * in the RISC OS 3 Shared C Library (penalty is timezone())
     */
    machinetime bt, w, w2;

    /*
     * read timer as 5 byte integer
     * centiseconds since 1/1/1900
     */
    bt.l = 3;				/* presumably 'request time' arg */
    _kernel_osword(14, (int *)&bt);

    /* to two 3-byte things - for divide */
    w.h = ((bt.h & 255) << 8) | (bt.l >> 24);
    w.l = bt.l & 0xffffff;

    /* turn csecs to secs */
    w2.h = w.h / 100;
    w2.l = ((w.h % 100 << 24) | w.l) / 100;

    /* back to 8 byte binary */
    bt.h = w2.h >> 8;
    bt.l = (w2.h << 24) | w2.l;

    /* normalise to Jan70 instead of Jan00... */
    if (bt.l < secs0070) bt.h--;
    bt.l -= secs0070;

    /*
     * if high word is non-zero then date
     * is unset/out of unix range...
     */
    return bt.h ? -1 : bt.l;
}
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d17 1
a17 1
 * $Header: /ax/networking:Internet/lib/unixenv.c:networking  1.8  $
a22 6
 * Revision 1.8  95/06/13  14:25:54  kwelton
 * Undid the "optimisation" of tick_handler() which broke all timeout code.
 * 
 * Revision 1.7  95/06/05  14:57:06  kwelton
 * Added a debug line to generate_event().
 * 
a64 1
#include "debug.h"
a130 7
#ifdef DEBUG
    if( DODEBUG(DBGEVENTS) )
	Printf("\021\04generate_event: SIG%s on socket %d\021\07\n",
	       (sig == SIGIO) ? "IO" : (sig == SIGURG) ? "URG" : "PIPE",
	       s - 1);
#endif

a226 12
	/*
	 * 950613 KWelton
	 *
	 * It looks like someone made the mistake of trying to
	 * optimise the UNIX code (now re-installed) thinking
	 * that it could be made more efficient.  It can't.
	 *
	 * The "optimised" code ends up running down the entire
	 * callout list, decrementing c_time for each member;
	 * this is a Bad Thing
	 */
#ifdef OldCode
a231 9
#else
	if( --p1->c_time > 0 )
	    break;

	needtocall = 1;

	if( p1->c_time == 0 )
	    break;
#endif
d408 2
@


4.1.7.2
log
@RCS log keyword removed
@
text
@d22 1
a22 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@d17 1
a17 1
 * $Header: /ax/networking:Internet/lib/unixenv.c:networking  1.8  $
a22 6
 * Revision 1.8  95/06/13  14:25:54  kwelton
 * Undid the "optimisation" of tick_handler() which broke all timeout code.
 * 
 * Revision 1.7  95/06/05  14:57:06  kwelton
 * Added a debug line to generate_event().
 * 
a64 1
#include "debug.h"
a130 7
#ifdef DEBUG
    if( DODEBUG(DBGEVENTS) )
	Printf("\021\04generate_event: SIG%s on socket %d\021\07\n",
	       (sig == SIGIO) ? "IO" : (sig == SIGURG) ? "URG" : "PIPE",
	       s - 1);
#endif

a226 12
	/*
	 * 950613 KWelton
	 *
	 * It looks like someone made the mistake of trying to
	 * optimise the UNIX code (now re-installed) thinking
	 * that it could be made more efficient.  It can't.
	 *
	 * The "optimised" code ends up running down the entire
	 * callout list, decrementing c_time for each member;
	 * this is a Bad Thing
	 */
#ifdef OldCode
a231 9
#else
	if( --p1->c_time > 0 )
	    break;

	needtocall = 1;

	if( p1->c_time == 0 )
	    break;
#endif
d408 2
@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d22 1
a22 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d17 1
a17 1
 * $Header: /ax/networking:Internet/lib/unixenv.c:networking  1.8  $
a22 14
 * Revision 1.9  96/03/06            kbracey
 * Made sleep do an UpCall 6 if we're in a TaskWindow
 * Turn all _kernel_swi into _swix
 * Add taskwindow_sleep
 * Add R3 to generate_event (local port number)
 * Removed unnecessary splx() (interrupt state is restored on return from a
 * function in SVC mode!)
 *
 * Revision 1.8  95/06/13  14:25:54  kwelton
 * Undid the "optimisation" of tick_handler() which broke all timeout code.
 *
 * Revision 1.7  95/06/05  14:57:06  kwelton
 * Added a debug line to generate_event().
 *
d25 1
a25 1
 *
d29 1
a29 1
 *
d34 1
a34 1
 *
d37 1
a37 1
 *
d41 1
a41 1
 *
d45 1
a45 1
 *
d48 1
a48 1
 *
d51 1
a51 1
 *
a56 2
#include "sys/systm.h"
#include "sys/queue.h"
a58 2
#include "sys/kernel.h"
#include "sys/callout.h"
d60 1
a61 4
#include "sys/socket.h" //
#include "sys/socketvar.h" //
#include "sys/domain.h" //
#include "sys/protosw.h" //
a63 6
#include "net/route.h" //

#include "netinet/in.h" //
#include "netinet/in_systm.h"
#include "netinet/ip.h"
#include "netinet/in_pcb.h" //
a64 1
#include "debug.h"
a65 1
#include "swiveneers.h"
a68 2
#define NCALLOUT 20

d76 10
a85 1
struct	callout callout[NCALLOUT];
d87 2
a88 2
struct	callout *callfree;
struct	callout calltodo;
d92 1
d94 1
a94 3
extern struct socket *getsock(int s);

volatile int callo_pending;
d98 5
a102 1
#define INTERNET_EVENT	    19
d104 4
a107 3
#define SOCKET_ASYNC_EVENT  1
#define SOCKET_URGENT_EVENT 2
#define SOCKET_BROKEN_EVENT 3
d109 1
a109 10
long siglist[SOCKTABSIZE];

/*
 * Queue a signal for later processing - ie as we exit a SWI or our
 * callback handler
 */
void
psignal(p, signum)
	struct proc *p;
	register int signum;
d111 1
a111 6
	register int sockid = (int) p - 1;

	if (sockid < 0)
		return;

	siglist[sockid] |= sigmask(signum);
d114 1
a114 2
void
sendallsignals()
d116 2
a117 1
	register int sockid;
d119 1
a119 4
	for (sockid = 0; sockid < SOCKTABSIZE; sockid++)
		if (siglist[sockid])
			sendsignals(sockid);
}
d121 3
a123 28
/*
 * Send pending signals on a socket id. Be careful not to erase signals
 * that are raised by routines responding to the signals - save them for
 * later processing
 */
void
sendsignals(sockid)
	register int sockid;
{
	register int signum;
	register long mask;

	mask = siglist[sockid];

	for (;;) {
		if (mask == 0)
			return;
		signum = ffs(mask);
#ifdef DIAGNOSTIC
		if (signum != SIGIO && signum != SIGURG && signum != SIGPIPE)
			Printf("Unknown signal pending for socket %d: %d\n",
				sockid, signum);
#endif
		siglist[sockid] &= ~sigmask(signum);
		mask &= ~sigmask(signum);
		generate_event(sockid, signum);
	}
}
d125 1
a125 3
int
generate_event(sockid, sig)
	int sockid, sig;
d127 2
a129 2
    int port = 0;
    struct socket *so;
d131 3
a133 6
#ifdef DEBUG
    if( DODEBUG(DBGEVENTS) )
	Printf("\021\04generate_event: SIG%s on socket %d\021\07\n",
	       (sig == SIGIO) ? "IO" : (sig == SIGURG) ? "URG" : "PIPE",
	       sockid);
#endif
d153 4
a156 15
#   ifdef NO_PORT_EVENT
    return os_generate_event(INTERNET_EVENT, event, sockid, 0) ? -1 : 0;
#   else
    /* If it's an Inet socket, fill in R3 with the local port number */
    so=getsock(sockid);
    if (so && so->so_proto->pr_domain->dom_family == PF_INET)
    {
        struct inpcb *inp=(struct inpcb *) so->so_pcb;

        if (inp)
            port = inp->inp_lport;
    }

    return os_generate_event(INTERNET_EVENT, event, sockid, port) ? -1 : 0;
#   endif
d159 1
a159 1
void rsignal(int s, int m, int sa, int esrc, int unit, int swinum, int n)
d161 1
d166 1
a166 1
	return;
d168 8
a175 1
    econet_inet_rx_direct(sockid, m, sa, esrc, unit, swinum, n);
d180 6
a185 1
    return os_claim(TickerV, fun, module_wsp);
d188 1
a188 1
void removetickerevent(int (*fun)())
d190 6
a195 1
    os_release(TickerV, fun, module_wsp);
d198 1
a198 1
void init_callout(void)
d209 1
a209 6
/*
 * This routine, plus its veneer, have been recrafted in assembler, and can
 * be found in s.tick_entry - KJB
 */
#ifdef NoAsm
int tick_handler(int *r, void *pw)
a214 8
     * Update time ticker
     */
    if ((time.tv_usec += 10000) >= 1000000) {
        time.tv_usec = 0;
        time.tv_sec++;
    }

    /*
d227 3
a229 6
	if( --p1->c_time > 0 )
	    break;

	needtocall = 1;

	if( p1->c_time == 0 )
d231 1
a240 1
#endif
d248 2
a249 2
    void *arg;
    timeout_func_t func;
a250 1
    int s;
a257 1
        s = splimp();
a260 1
	splx(s);
d268 1
a268 5
void
timeout(fun, arg, t)
	timeout_func_t fun;
	void *arg;
	int t;
d270 2
a271 2
	struct callout *p1, *p2, *pnew;
	func_splimp();
d273 2
a274 3
#if 0
        Printf("timeout(%x,%x,%d)\n", fun, arg, t);
#endif
d276 7
a282 2
	if (t <= 0)
		t = 1;
d284 10
a293 6
	pnew = callfree;
	if (pnew == NULL) {
		panic("timeout table overflow");
		func_splx();
		return;
	}
d295 2
a296 10
	callfree = pnew->c_next;
	pnew->c_arg = arg;
	pnew->c_func = fun;
	for (p1 = &calltodo; (p2 = p1->c_next) && p2->c_time < t; p1 = p2)
		if (p2->c_time > 0)
			t -= p2->c_time;

	p1->c_next = pnew;
	pnew->c_next = p2;
	pnew->c_time = t;
d298 1
a298 4
	if (p2)
		p2->c_time -= t;

	func_splx();
d305 1
a305 4
void
untimeout(fun, arg)
	timeout_func_t fun;
	void *arg;
d308 1
a308 1
    func_splimp();
d325 1
a325 1
    func_splx();
d328 1
a328 3
int
hzto(tv)
	struct timeval *tv;
d330 1
a330 2
	long n;
	func_splhi();
d332 2
a333 3
	n = (tv->tv_sec - time.tv_sec) * 100 + (tv->tv_usec - time.tv_usec) / 10000;
	if (n < 0)
	    n = 0;
d335 4
a338 2
	func_splx();
	return n;
a340 1
/*
d375 28
a402 1
} */
d406 1
a406 2
void
panic(const char *str, ...)
d408 2
d429 1
a429 1
} stable[NSTAB];
d431 1
a431 2
int
sleeptabinit()
d444 39
a482 1
static void endtsleep(struct stab_entry *s);
d484 1
a484 1
static void taskwindow_sleep(volatile int *pollword)
d486 2
a487 2
    int in_taskwindow;
    _kernel_oserror *e;
d489 3
a491 1
    e=taskwindow_task_info(0, &in_taskwindow);
d493 1
a493 2
    if (!e && in_taskwindow)
        os_upcall(6, pollword);
d496 1
a496 5
int
tsleep(event, prio, wmesg, wait, sleep_task)
	void *event;
	char *wmesg;
	int prio, sleep_task, wait;
d498 2
a499 3
	struct stab_entry *s;
	int ms;
	int error = 0;
d501 4
a504 1
	ms = splimp();
d506 3
a508 40
#ifdef DEBUG
	Printf("tsleep(0x%x,0x%x,%s,%d,%d)\n", event, prio, wmesg, wait, sleep_task);
#endif
	for (s = &stable[0]; s < &stable[NSTAB]; s++) {
		if (s->event == 0) {
			s->event = event;
			s->flag = 0;
			splx(ms);

			if (wait)
				timeout(endtsleep, s, wait);
			while (s->flag == 0) {

				if (sleep_task)
					taskwindow_sleep(&s->flag);

				if ((prio & PCATCH) && escape_seen()) {
#ifdef DEBUG
					Printf("Escape seen\n");
#endif
					error = EINTR;
					goto out;
				}

				user_mode_donothing();
			}
out:
			if (wait)
				untimeout(endtsleep, s);
			ms = splimp();
			s->event = 0;
			s->flag = 0;
			splx(ms);
			return (error);
		}
	}

	splx(ms);
	panic("sleep");
	return (EFAULT);
d511 1
a511 3
static void
endtsleep(s)
	struct stab_entry *s;
d513 1
a513 1
	s->flag = 1;
d516 3
a518 3
void
wakeup(event)
    void *event;
d520 8
a527 2
    struct stab_entry *s;
    func_splimp();
d529 2
a530 3
    for (s = &stable[0]; s < &stable[NSTAB]; s++)
	if (s->event == event)
	    s->flag = 1;
d532 3
a534 1
    func_splx();
d537 4
a540 1
#define NBITS 32
d542 1
a542 3
int
ffs(mask)
	long mask;
d544 2
a545 1
	int i;
d547 4
a550 5
	for (i = 0; i < NBITS; i++) {
		if (mask & 1)
	    		return (i+1);
		mask >>= 1;
    	}
d552 3
a554 1
    	return (0);
a556 1
#ifdef NoAsm
a561 1
#endif
d575 1
a575 1
void insque(struct qelem *elem, struct qelem *pred)
d577 1
a577 1
    func_splhi();
d581 1
a581 1
	func_splrestore();
d592 1
a592 1
    func_splrestore();
d595 1
a595 1
void remque(struct qelem *elem)
d597 1
a597 1
    func_splhi();
d601 1
a601 1
	func_splrestore();
d611 1
a611 1
    func_splrestore();
d635 7
a641 1
    func_splimp();
d650 2
d654 1
a654 1
	    os_remove_call_back(cbptr->cb_entry, module_wsp);
d659 1
a659 1
    func_splx();
d664 1
a664 1
    func_splimp();
d667 1
a667 1
    func_splx();
d672 1
d679 3
a681 48
    return os_add_call_back(cbptr->cb_entry, module_wsp) ? -1 : 0;
}

void
microtime(tv)
	struct timeval *tv;
{
	func_splhi();

	*tv = time;

	func_splx();
}

/*
 * Check that a proposed value to load into the .it_value or
 * .it_interval part of an interval timer is acceptable, and
 * fix it to have at least minimal value (i.e. if it is less
 * than the resolution of the clock, round it up.)
 */
int
itimerfix(tv)
	struct timeval *tv;
{

	if (tv->tv_sec < 0 || tv->tv_sec > 100000000 ||
	    tv->tv_usec < 0 || tv->tv_usec >= 1000000)
		return (EINVAL);
	if (tv->tv_sec == 0 && tv->tv_usec != 0 && tv->tv_usec < tick)
		tv->tv_usec = tick;
	return (0);
}

/*
 * Add and subtract routines for timevals.
 * N.B.: subtract routine doesn't deal with
 * results which are before the beginning,
 * it just gets very confused in this case.
 * Caveat emptor.
 */
void
timevaladd(t1, t2)
	struct timeval *t1, *t2;
{

	t1->tv_sec += t2->tv_sec;
	t1->tv_usec += t2->tv_usec;
	timevalfix(t1);
d684 1
a684 66
void
timevalsub(t1, t2)
	struct timeval *t1, *t2;
{

	t1->tv_sec -= t2->tv_sec;
	t1->tv_usec -= t2->tv_usec;
	timevalfix(t1);
}

void
timevalfix(t1)
	struct timeval *t1;
{

	if (t1->tv_usec < 0) {
		t1->tv_sec--;
		t1->tv_usec += 1000000;
	}
	if (t1->tv_usec >= 1000000) {
		t1->tv_sec++;
		t1->tv_usec -= 1000000;
	}
}

#define secs0070 (((unsigned)86400) * (365 * 70 + 17))	/* less than 2^32 */

typedef struct {unsigned int l,h;} machinetime;

long realtime()
{
    /*
     * this is time(), recoded here to avoid the absurd 6ms delay
     * in the RISC OS 3 Shared C Library (penalty is timezone())
     */
    machinetime bt, w, w2;

    /*
     * read timer as 5 byte integer
     * centiseconds since 1/1/1900
     */
    bt.l = 3;				/* presumably 'request time' arg */
    _kernel_osword(14, (int *)&bt);

    /* to two 3-byte things - for divide */
    w.h = ((bt.h & 255) << 8) | (bt.l >> 24);
    w.l = bt.l & 0xffffff;

    /* turn csecs to secs */
    w2.h = w.h / 100;
    w2.l = ((w.h % 100 << 24) | w.l) / 100;

    /* back to 8 byte binary */
    bt.h = w2.h >> 8;
    bt.l = (w2.h << 24) | w2.l;

    /* normalise to Jan70 instead of Jan00... */
    if (bt.l < secs0070) bt.h--;
    bt.l -= secs0070;

    /*
     * if high word is non-zero then date
     * is unset/out of unix range...
     */
    return bt.h ? -1 : bt.l;
}
@


4.1.3.2
log
@RCS Log keyword removed
@
text
@d22 1
a22 1
 * :RCS Log discontinued:
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d22 1
a22 1
 * :RCS Log discontinued:
@

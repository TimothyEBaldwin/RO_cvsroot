head	4.6;
access;
symbols
	Internet-5_65:4.6
	Internet-5_64:4.6
	Internet-5_63:4.6
	Internet-5_62:4.6
	Internet-5_61:4.5
	Internet-5_60:4.5
	Internet-5_59:4.5
	Internet-5_58:4.5
	Internet-5_57:4.5
	Internet-5_56:4.5
	Internet-5_55:4.5
	Internet-5_54:4.5
	Internet-5_53:4.5
	Internet-5_52:4.3
	Internet-5_51:4.3
	Internet-5_50:4.3
	RO_5_07:4.3
	Internet-5_49:4.3
	Internet-5_48:4.3
	Internet-5_47:4.3
	Internet-5_46:4.3
	Internet-5_45:4.3
	Internet-5_44:4.3
	Internet-5_43:4.3
	Internet-5_42:4.3
	Internet-5_41:4.3
	Internet-5_40:4.2
	Internet-5_39:4.2
	Internet-5_38:4.2
	Internet-5_37:4.1.3.1
	Internet-5_36:4.1.3.1
	Internet-5_35:4.1.3.1
	Internet-5_34:4.1.3.1
	Internet-5_33:4.1.3.1
	Internet-5_32:4.1.3.1
	Internet-5_31:4.1.3.1
	Internet-5_30:4.1.3.1
	Internet-5_29:4.1.3.1
	Internet-5_27:4.1.3.1
	Internet-5_26:4.1.3.1
	Internet-5_25:4.1.3.1
	Internet-5_24:4.1.3.1
	Internet-5_23:4.1.3.1
	Internet-5_22:4.1.3.1
	Internet-5_21:4.1.3.1
	Internet-5_20:4.1.3.1
	Internet-5_19:4.1.3.1
	Internet-5_18:4.1.3.1
	Internet-5_17:4.1.3.1
	Internet-5_16:4.1.3.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.3.1
	Ursula_RiscPC:4.1.3.1.0.2
	Internet-5_15:4.1.3.1
	Internet-5_14:4.1.3.1
	Internet-5_13:4.1.3.1
	sforrest_daytona_appflash-0_31:4.1.3.1
	Internet-5_12:4.1.3.1
	Internet-5_11:4.1.3.1
	celkins_Internet-5_10:4.1.3.1
	nicke_Internat_25-9-98:4.1.3.1
	Internet-5_09:4.1.3.1
	blaughto_daytona_appflash-0_30:4.1.3.1
	rthornb_UrsulaBuild-19Aug1998:4.1.3.1
	UrsulaBuild_FinalSoftload:4.1.3.1
	rthornb_UrsulaBuild-12Aug1998:4.1.3.1
	aglover_UrsulaBuild-05Aug1998:4.1.3.1
	rthornb_UrsulaBuild-29Jul1998:4.1.3.1
	rthornb_UrsulaBuild-22Jul1998:4.1.3.1
	rwarren_Internet-5_08:4.1.3.1
	Spinner:4.1.3.1
	Internet_5_07:4.1.3.1
	rthornb_UrsulaBuild-15Jul1998:4.1.3.1
	rthornb_UrsulaBuild-07Jul1998:4.1.3.1
	rthornb_UrsulaBuild-17Jun1998:4.1.3.1
	rthornb_UrsulaBuild-03Jun1998:4.1.3.1
	rthornb_UrsulaBuild-27May1998:4.1.3.1
	rthornb_UrsulaBuild-21May1998:4.1.3.1
	Ursula_bp:4.1.3.1
	Ursula:4.1.3.1.0.10
	Ursula_13May1998_bp:4.1.3.1
	Ursula_13May1998:4.1.3.1.0.6
	rthornb_UrsulaBuild_01May1998:4.1.3.1
	celkins_Internet_506:4.1.3.1
	afrost_NC2_Generic:4.1.3.1
	afrost_Funai01-33:4.1.3.1
	Internet_505:4.1.3.1
	Spinner_RCA116:4.1.3.1
	Spinner_B20_2:4.1.3.1
	Spinner_19_3:4.1.3.1
	Spinner_B18:4.1.3.1
	Spinner_B17:4.1.3.1
	Spinner_B15:4.1.3.1
	Spinner_B14:4.1.3.1
	Spinner_B13:4.1.3.1
	Spinner_B12:4.1.3.1
	Spinner_B10:4.1.3.1
	Daytona:4.1.3.1.0.8
	Daytona_bp:4.1.3.1
	Spin_merge:4.1.3.1
	Spinner_B7:4.1.3.1
	RO_3_71:4.1.3.1
	RCA_bp:4.1.3.1
	RCA:4.1.3.1.0.4
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	StrongARM:4.1.3;
locks; strict;
comment	@# @;


4.6
date	2017.06.07.20.36.43;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	xgif914dBX0dZtUz;

4.5
date	2011.12.15.22.20.07;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	TVCPLXal0LzsSkLv;

4.4
date	2011.12.15.22.14.00;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	HZIJ91eGy2SeQkLv;

4.3
date	2000.05.12.11.49.03;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	99.11.11.15.18.59;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.22.27.09;	author nturton;	state Exp;
branches
	4.1.3.1;
next	;

4.1.3.1
date	96.11.05.22.27.09;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Get Internet event numbers from Hdr:RISCOS and a microoptimisation
unixenv.c/whoami.c: don't define event numbers locally, use headers.
tick_entry.s: if available use the REV instruction for htonl().

Requires Kernel-5_81 for event numbers.

Version 5.62. Tagged as 'Internet-5_62'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;
; Assembly veneer for dealing with TickerV fast
; Based on code generated by Norcroft C 5.06
;
; It is designed to minimise the load on the system - it is a
; Bad Thing (TM) to use TickerV, but I don't think there is much
; choice for elegant operation of the Internet stack. As a compromise,
; I have recrafted the tick_handler routine from unixenv.c into
; assembler that can run directly in IRQ mode on TickerV.

NETISR_CALLO    *       1

                ^       0
tv_sec          #       4
tv_usec         #       4

                ^       0
c_next          #       4
c_arg           #       4
c_func          #       4
c_time          #       4


        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:APCS.<APCS>

        AREA    TickEntry,CODE,READONLY

; The TickerV entry point - we arrive in IRQ mode with IRQs disabled.

        EXPORT  tick_entry
tick_entry
        Push    "r0-r2, lr"
        LDR     r2,[r12]
        LDR     r2,[r2,#8]
        LDR     r0,P_time
        ADD     r0,r2,r0
        LDR     r1,[r0,#tv_usec]
        ADD     r1,r1,#&0710
        ADD     r1,r1,#&2000         ; time.tv_usec += 10000
        STR     r1,[r0,#tv_usec]
        SUBS    lr,r1,#&000F4000
        CMPGE   lr,#&240             ; if time.tv_usec >= 1000000
        BLT     %F1
        MOV     r1,#0
        STR     r1,[r0,#tv_usec]     ;   time.tv_usec = 0
        LDR     r1,[r0,#tv_sec]      ;   time.tv_sec ++;
        ADD     r1,r1,#1
        STR     r1,[r0,#tv_sec]
1       MOV     r0,#0                ; r0=needtocall
        LDR     r1,P_calltodo
        ADD     r1,r2,r1             ; sort out relocations
        LDR     r1,[r1,#c_next]      ; r1=calltodo->c_next
        TEQS    r1,#0
        Pull    "r0-r2, pc",EQ
0                                    ; while (r1)
        LDR     r2,[r1,#c_time]
        SUBS    r2,r2,#1             ; decrement r1->c_time
        STR     r2,[r1,#c_time]
        BGT     break                ; if r1->c_time>0 end loop
        BEQ     break_with_sched     ; if r1->c_time==0 do schednetisr
        MOV     r0,#1                ; set needtocall
        LDR     r1,[r1,#c_next]      ; r1=r1->c_next
        TEQS    r1,#0
        BNE     %B0
        B       break_with_sched
break
        TEQS    a1,#0                ; check needtocall
        Pull    "r0-r2, pc",EQ

break_with_sched
        LDR     a3,[r12]
        LDR     a3,[a3,#8]
        ; This code corresponds to:
        ; schednetisr(NETISR_CALLO); which is a macro:
        ; netisr |= 1<<NETISR_CALLO;
        LDR     a1,P_netisr
        ADD     a1,a3,a1
        LDR     a2,[a1]
        ORR     a2,a2,#(1:SHL:NETISR_CALLO)
        STR     a2,[a1]
        ; setsoftnet();
        ; if (callbackflag != 0) then return doing nowt
        LDR     a1,P_callbackflag
        ADD     a1,a3,a1
        LDR     a2,[a1]
        TEQS    a2,#0
        Pull    "a1-a3, pc",NE
        ; callbackflag = 1;
        MOV     a2,#1
        STR     a2,[a1]
        ; callback(CALLB_CALLB);
        ; struct callback_record *cbptr = callbacks + CALLB_CALLB
        LDR     a1,P_callbacks
        ADD     a1,a3,a1            ; Now a1->callback[CALLB_CALLB]
        ; cbptr->cb_outstanding++;
        LDR     a2,[a1,#4]
        ADD     a2,a2,#1
        STR     a2,[a1,#4]
        ; os_add_callback(cbptr->cb_entry, module_wsp);
        LDR     a1,[a1,#0]
        MOV     a2,r12
        ; Right, guff to change up into SVC mode to call this SWI.
        ; This is okay because R12 isn't needed from now on.
        [ {CONFIG}=26
        MOV     r12,pc                  ; R12 holds PC and PSR
        AND     r12,r12,#3              ; Extract current mode bits
        EOR     r12,r12,#3              ; R8 = current mode EOR SVC
        TEQP    r12,pc                  ; Enter SVC
        NOP
        |
        MRS     r12,CPSR
        ORR     lr,r12,#3
        MSR     CPSR_c,lr
        ]
        Push    "lr"                    ; Save R14_SVC (in case in IRQ mode)
        SWI     XOS_AddCallBack
        Pull    "lr"                    ; Restore R14_SVC
        [ {CONFIG}=26
        TEQP    r12,pc                  ; Restore mode, preserving flags
        NOP
        |
        MSR     CPSR_c,r12
        ]
        Pull    "a1-a3, pc",VC
        ; if an error
        ; callbackflag=0;
        LDR     a1,P_callbackflag
        ADD     a1,a3,a1
        MOV     a2,#0
        STR     a2,[a1]
        ; callbackerr=1;
        LDR     a1,P_callbackerr
        ADD     a1,a3,a1
        MOV     a2,#1
        STR     a2,[a1]

        Pull    "a1-a3, pc"

P_time
        IMPORT  kerneltime
        DCD     kerneltime

P_calltodo
        IMPORT  calltodo
        DCD     calltodo

P_netisr
        IMPORT  netisr
        DCD     netisr

P_callbackflag
        IMPORT  callbackflag
        DCD     callbackflag

P_callbacks
        IMPORT  callbacks
        DCD     callbacks

P_callbackerr
        IMPORT  callbackerr
        DCD     callbackerr


        ; Extracted from ARM Architecture Reference
        EXPORT  ntohl
ntohl                                   ; a1 = A , B , C , D
      [ NoARMv6
        EOR     a2, a1, a1, ROR #16     ; a2 = A^C,B^D,C^A,D^B
        BIC     a2, a2, #&ff0000        ; a2 = A^C, 0 ,C^A,D^B
        MOV     a1, a1, ROR #8          ; a1 = D , A , B , C
        EOR     a1, a1, a2, LSR #8      ; a1 = D , C , B , A
      |
        REV     a1, a1                  ; a1 = D , C , B , A
      ]
        Return  ,LinkNotStacked

        END
@


4.5
log
@Delete local user_mode_donothing() and replace with usermode_donothing() from AsmUtils.
Makefilse uses ModuleLibs too.
Lots of STM/LDM replaced with Push and Pull macros.
Local definitions in 'swiveneers' replaced with header files.

Version 5.53. Tagged as 'Internet-5_53'
@
text
@d184 1
d189 3
@


4.4
log
@Retab assembler to reduce diffs.
Not tagged.
@
text
@d49 1
a49 1
        STMFD   sp!,{r0-r2,lr}
d71 1
a71 1
        LDMEQFD sp!,{r0-r2,pc}
d85 1
a85 1
        LDMEQFD sp!,{r0-r2,pc}
d104 1
a104 1
        LDMNEFD sp!,{a1-a3,pc}
d132 1
a132 1
        STMFD   sp!,{lr}                ; Save R14_SVC (in case in IRQ mode)
d134 1
a134 1
        LDMFD   sp!,{lr}                ; Restore R14_SVC
d141 1
a141 1
        LDMVCFD sp!,{a1-a3,pc}
d154 1
a154 1
        LDMFD   sp!,{a1-a3,pc}
@


4.3
log
@32-bit code modified to use new macros, plus a couple of fixes.
A (tiny) checksumming speed-up, courtesy of David Seal.

Version 5.41. Tagged as 'Internet-5_41'
@
text
@d25 1
a25 1
NETISR_CALLO	*	1
d27 14
a40 14
		^	0
tv_sec		#       4
tv_usec		#	4

		^	0
c_next		#	4
c_arg		#	4
c_func		#	4
c_time		#	4


	GET	Hdr:ListOpts
	GET	Hdr:Macros
	GET	Hdr:System
d43 1
a43 1
	AREA	TickEntry,CODE,READONLY
d47 1
a47 1
	EXPORT	tick_entry
d49 23
a71 23
	STMFD	sp!,{r0-r2,lr}
	LDR	r2,[r12]
	LDR	r2,[r2,#8]
	LDR	r0,P_time
	ADD	r0,r2,r0
	LDR	r1,[r0,#tv_usec]
	ADD	r1,r1,#&0710
	ADD	r1,r1,#&2000         ; time.tv_usec += 10000
	STR	r1,[r0,#tv_usec]
	SUBS	lr,r1,#&000F4000
	CMPGE	lr,#&240             ; if time.tv_usec >= 1000000
	BLT	%F1
	MOV	r1,#0
	STR	r1,[r0,#tv_usec]     ;   time.tv_usec = 0
	LDR	r1,[r0,#tv_sec]      ;   time.tv_sec ++;
	ADD	r1,r1,#1
	STR	r1,[r0,#tv_sec]
1	MOV	r0,#0                ; r0=needtocall
	LDR	r1,P_calltodo
	ADD	r1,r2,r1             ; sort out relocations
	LDR	r1,[r1,#c_next]      ; r1=calltodo->c_next
	TEQS	r1,#0
	LDMEQFD	sp!,{r0-r2,pc}
d73 10
a82 10
	LDR	r2,[r1,#c_time]
	SUBS	r2,r2,#1             ; decrement r1->c_time
	STR	r2,[r1,#c_time]
	BGT	break                ; if r1->c_time>0 end loop
	BEQ	break_with_sched     ; if r1->c_time==0 do schednetisr
	MOV	r0,#1                ; set needtocall
	LDR	r1,[r1,#c_next]      ; r1=r1->c_next
	TEQS	r1,#0
	BNE	%B0
	B	break_with_sched
d84 2
a85 2
	TEQS	a1,#0                ; check needtocall
	LDMEQFD	sp!,{r0-r2,pc}
d88 33
a120 33
	LDR	a3,[r12]
	LDR	a3,[a3,#8]
	; This code corresponds to:
	; schednetisr(NETISR_CALLO); which is a macro:
	; netisr |= 1<<NETISR_CALLO;
	LDR	a1,P_netisr
	ADD	a1,a3,a1
	LDR	a2,[a1]
	ORR	a2,a2,#(1:SHL:NETISR_CALLO)
	STR	a2,[a1]
	; setsoftnet();
	; if (callbackflag != 0) then return doing nowt
	LDR	a1,P_callbackflag
	ADD	a1,a3,a1
	LDR	a2,[a1]
	TEQS	a2,#0
	LDMNEFD	sp!,{a1-a3,pc}
	; callbackflag = 1;
	MOV	a2,#1
	STR	a2,[a1]
	; callback(CALLB_CALLB);
	; struct callback_record *cbptr = callbacks + CALLB_CALLB
	LDR	a1,P_callbacks
	ADD	a1,a3,a1            ; Now a1->callback[CALLB_CALLB]
	; cbptr->cb_outstanding++;
	LDR	a2,[a1,#4]
	ADD	a2,a2,#1
	STR	a2,[a1,#4]
	; os_add_callback(cbptr->cb_entry, module_wsp);
	LDR	a1,[a1,#0]
	MOV	a2,r12
	; Right, guff to change up into SVC mode to call this SWI.
	; This is okay because R12 isn't needed from now on.
d122 5
a126 5
	MOV	r12,pc              	; R12 holds PC and PSR
	AND	r12,r12,#3		; Extract current mode bits
	EOR	r12,r12,#3		; R8 = current mode EOR SVC
	TEQP	r12,pc			; Enter SVC
	NOP
d132 3
a134 3
	STMFD	sp!,{lr}		; Save R14_SVC (in case in IRQ mode)
	SWI	XOS_AddCallBack
	LDMFD	sp!,{lr}		; Restore R14_SVC
d136 2
a137 2
	TEQP	r12,pc			; Restore mode, preserving flags
	NOP
d141 12
a152 12
	LDMVCFD	sp!,{a1-a3,pc}
	; if an error
	; callbackflag=0;
	LDR	a1,P_callbackflag
	ADD	a1,a3,a1
	MOV	a2,#0
	STR	a2,[a1]
	; callbackerr=1;
	LDR	a1,P_callbackerr
	ADD	a1,a3,a1
	MOV	a2,#1
	STR	a2,[a1]
d154 1
a154 1
	LDMFD	sp!,{a1-a3,pc}
d157 2
a158 2
	IMPORT	kerneltime
	DCD	kerneltime
d161 2
a162 2
	IMPORT  calltodo
	DCD	calltodo
d165 2
a166 2
	IMPORT  netisr
	DCD	netisr
d169 2
a170 2
	IMPORT	callbackflag
	DCD	callbackflag
d173 2
a174 2
	IMPORT	callbacks
	DCD	callbacks
d177 2
a178 2
	IMPORT	callbackerr
	DCD	callbackerr
d181 7
a187 7
	; Extracted from ARM Architecture Reference
	EXPORT	ntohl
ntohl				   	; a1 = A , B , C , D
	EOR	a2, a1, a1, ROR #16     ; a2 = A^C,B^D,C^A,D^B
	BIC	a2, a2, #&ff0000	; a2 = A^C, 0 ,C^A,D^B
	MOV	a1, a1, ROR #8		; a1 = D , A , B , C
	EOR	a1, a1, a2, LSR #8	; a1 = D , C , B , A
d190 1
a190 1
	END
@


4.2
log
@Now 32-bit compatible, in a suitable build environment. In the standard
26-bit build environment it is unchanged, except for a fix in the "Module
Internet cannot be RAM loaded" checker.

Version 5.38. Tagged as 'Internet-5_38'
@
text
@a24 1
XOS_AddCallBack	*	&20054
d38 5
d104 1
a104 1
	LDMNEFD	sp!,{a1-a3,pc}^
d128 3
a130 3
        MRS     a3,CPSR
        ORR     r12,a3,#3
        MSR     CPSR_ctl,r12
d132 1
a132 1
	STMFD	sp!,{lr}		; Save R14_SVC
d139 1
a139 1
        MSR     CPSR_ctl,a3
d141 1
a141 1
	LDMVCFD	sp!,{a1-a3,pc}^
d188 1
a188 5
        [ {CONFIG}=26
	MOVS	pc, lr
        |
	MOV	pc, lr
        ]
@


4.1
log
@Initial revision
@
text
@d67 1
a67 1
	LDMEQFD	sp!,{r0-r2,pc}^
d81 1
a81 1
	LDMEQFD	sp!,{r0-r2,pc}^
d117 1
d123 5
d131 1
d134 3
d150 1
a150 1
	LDMFD	sp!,{a1-a3,pc}^
d184 1
d186 3
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@

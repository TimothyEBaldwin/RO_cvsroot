head	4.5;
access;
symbols
	Internet-5_65:4.5
	Internet-5_64:4.5
	Internet-5_63:4.5
	Internet-5_62:4.5
	Internet-5_61:4.5
	Internet-5_60:4.5
	Internet-5_59:4.5
	Internet-5_58:4.5
	Internet-5_57:4.5
	Internet-5_56:4.5
	Internet-5_55:4.5
	Internet-5_54:4.5
	Internet-5_53:4.5
	Internet-5_52:4.5
	Internet-5_51:4.5
	Internet-5_50:4.5
	RO_5_07:4.5
	Internet-5_49:4.5
	Internet-5_48:4.5
	Internet-5_47:4.5
	Internet-5_46:4.5
	Internet-5_45:4.5
	Internet-5_44:4.5
	Internet-5_43:4.4
	Internet-5_42:4.4
	Internet-5_41:4.4
	Internet-5_40:4.4
	Internet-5_39:4.4
	Internet-5_38:4.4
	Internet-5_37:4.4
	Internet-5_36:4.4
	Internet-5_35:4.4
	Internet-5_34:4.4
	Internet-5_33:4.4
	Internet-5_32:4.4
	Internet-5_31:4.4
	Internet-5_30:4.3
	Internet-5_29:4.3
	Internet-5_27:4.2
	Internet-5_26:4.2
	Internet-5_25:4.2
	Internet-5_24:4.2
	Internet-5_23:4.2
	Internet-5_22:4.2
	Internet-5_21:4.2
	Internet-5_20:4.2
	Internet-5_19:4.2
	Internet-5_18:4.2
	Internet-5_17:4.2
	Internet-5_16:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Internet-5_15:4.2
	Internet-5_14:4.2
	Internet-5_13:4.2
	sforrest_daytona_appflash-0_31:4.2
	Internet-5_12:4.2
	Internet-5_11:4.2
	celkins_Internet-5_10:4.2
	nicke_Internat_25-9-98:4.2
	Internet-5_09:4.2
	blaughto_daytona_appflash-0_30:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rwarren_Internet-5_08:4.2
	Spinner:4.2
	Internet_5_07:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.2
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2000.07.13.10.39.41;	author ahodgkin;	state Exp;
branches;
next	4.4;

4.4
date	99.07.13.11.13.10;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.07.08.15.25.51;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.59.15;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.12;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.12;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.20.39;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.30.50;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.07.15;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.46;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.07.17;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.58;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.39.03;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.37;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@  Econet_InetRxDirect interface extended.
Detail:
  Previously, the SWI didn't care about any return values. The Internet
  module would either free the MBuf passed or send it on to the socket,
  depending on the value of m_len on exit from the SWI. This still works,
  but SWI handlers can now set R1 to zero on exit to claim ownership of
  the MBuf. In this case, the item is neither freed nor passed on to the
  socket, and the new owner must be very careful to make sure that they
  do an appropriate m_free later.
Admin:
  This change was implemented to allow UDPV to point the MPEG system
  directly to the data in the MBuf chains it was passed rather than taking
  a local copy. It has been tested with both new and old UDPV versions and
  both work as expected. Note that any module using the new interface will
  absolutely require it to be present (new UDPV modules built to use the
  interface extension will refuse to start if Internet is too old).

Version 5.44. Tagged as 'Internet-5_44'
@
text
@/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <string.h>

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/domain.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/signalvar.h>

#include "debug.h"
#include "module.h"

#ifdef SOCKBUF_DEBUG
void sbcheck(struct sockbuf *);
#endif

/*
 * Primitive routines for operating on sockets and socket buffers
 */

/* strings for sleep message: */
char	netio[] = "netio";
char	netcon[] = "netcon";
char	netcls[] = "netcls";

u_long	sb_max = SB_MAX;		/* patchable */

static	u_long sb_efficiency = 8;	/* parameter for sbreserve() */

/*
 * Procedures to manipulate state flags of socket
 * and do appropriate wakeups.	Normal sequence from the
 * active (originating) side is that soisconnecting() is
 * called during processing of connect() call,
 * resulting in an eventual call to soisconnected() if/when the
 * connection is established.  When the connection is torn down
 * soisdisconnecting() is called during processing of disconnect() call,
 * and soisdisconnected() is called when the connection to the peer
 * is totally severed.	The semantics of these routines are such that
 * connectionless protocols can call soisconnected() and soisdisconnected()
 * only, bypassing the in-progress calls when setting up a ``connection''
 * takes no time.
 *
 * From the passive side, a socket is created with
 * two queues of sockets: so_q0 for connections in progress
 * and so_q for connections already made and awaiting user acceptance.
 * As a protocol is preparing incoming connections, it creates a socket
 * structure queued on so_q0 by calling sonewconn().  When the connection
 * is established, soisconnected() is called, and transfers the
 * socket structure to so_q, making it available to accept().
 *
 * If a socket is closed with sockets on either
 * so_q0 or so_q, these sockets are dropped.
 *
 * If higher level protocols are implemented in
 * the kernel, the wakeups done here will sometimes
 * cause software-interrupt process scheduling.
 */

void
soisconnecting(so)
	register struct socket *so;
{

	so->so_state &= ~(SS_ISCONNECTED|SS_ISDISCONNECTING);
	so->so_state |= SS_ISCONNECTING;
}

void
soisconnected(so)
	register struct socket *so;
{
	register struct socket *head = so->so_head;

	so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING|SS_ISCONFIRMING);
	so->so_state |= SS_ISCONNECTED;
	if (head && soqremque(so, 0)) {
		soqinsque(head, so, 1);
		sorwakeup(head);
		wakeup((caddr_t)&head->so_timeo);
	} else {
		wakeup((caddr_t)&so->so_timeo);
		sorwakeup(so);
		sowwakeup(so);
	}
}

void
soisdisconnecting(so)
	register struct socket *so;
{

	so->so_state &= ~SS_ISCONNECTING;
	so->so_state |= (SS_ISDISCONNECTING|SS_CANTRCVMORE|SS_CANTSENDMORE);
	wakeup((caddr_t)&so->so_timeo);
	sowwakeup(so);
	sorwakeup(so);
}

void
soisdisconnected(so)
	register struct socket *so;
{

	so->so_state &= ~(SS_ISCONNECTING|SS_ISCONNECTED|SS_ISDISCONNECTING);
	so->so_state |= (SS_CANTRCVMORE|SS_CANTSENDMORE);
	wakeup((caddr_t)&so->so_timeo);
	sowwakeup(so);
	sorwakeup(so);
}

/*
 * When an attempt at a new connection is noted on a socket
 * which accepts connections, sonewconn is called.  If the
 * connection is possible (subject to space constraints, etc.)
 * then we allocate a new structure, propoerly linked into the
 * data structure of the original socket, and return this.
 * Connstatus may be 0, or SO_ISCONFIRMING, or SO_ISCONNECTED.
 *
 * Currently, sonewconn() is defined as sonewconn1() in socketvar.h
 * to catch calls that are missing the (new) second parameter.
 */
struct socket *
sonewconn1(head, connstatus)
	register struct socket *head;
	int connstatus;
{
	register struct socket *so;
	int soqueue = connstatus ? 1 : 0;

	if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
		return ((struct socket *)0);
	MALLOC(so, struct socket *, sizeof(*so), M_SOCKET, M_DONTWAIT);
	if (so == NULL)
		return ((struct socket *)0);
	bzero((caddr_t)so, sizeof(*so));
	so->so_type = head->so_type;
	so->so_options = head->so_options &~ SO_ACCEPTCONN;
	so->so_linger = head->so_linger;
	so->so_state = head->so_state | SS_NOFDREF;
	so->so_proto = head->so_proto;
	so->so_timeo = head->so_timeo;
	so->so_pgid = head->so_pgid;
	(void) soreserve(so, head->so_snd.sb_hiwat, head->so_rcv.sb_hiwat);
	soqinsque(head, so, soqueue);
	if ((*so->so_proto->pr_usrreq)(so, PRU_ATTACH,
	    (struct mbuf *)0, (struct mbuf *)0, (struct mbuf *)0)) {
		(void) soqremque(so, soqueue);
		(void) free((caddr_t)so, M_SOCKET);
		return ((struct socket *)0);
	}
	if (connstatus) {
		sorwakeup(head);
		wakeup((caddr_t)&head->so_timeo);
		so->so_state |= connstatus;
	}
	return (so);
}

void
soqinsque(head, so, q)
	register struct socket *head, *so;
	int q;
{

	register struct socket **prev;
	so->so_head = head;
	if (q == 0) {
		head->so_q0len++;
		so->so_q0 = 0;
		for (prev = &(head->so_q0); *prev; )
			prev = &((*prev)->so_q0);
	} else {
		head->so_qlen++;
		so->so_q = 0;
		for (prev = &(head->so_q); *prev; )
			prev = &((*prev)->so_q);
	}
	*prev = so;
}

int
soqremque(so, q)
	register struct socket *so;
	int q;
{
	register struct socket *head, *prev, *next;

	head = so->so_head;
	prev = head;
	for (;;) {
		next = q ? prev->so_q : prev->so_q0;
		if (next == so)
			break;
		if (next == 0)
			return (0);
		prev = next;
	}
	if (q == 0) {
		prev->so_q0 = next->so_q0;
		head->so_q0len--;
	} else {
		prev->so_q = next->so_q;
		head->so_qlen--;
	}
	next->so_q0 = next->so_q = 0;
	next->so_head = 0;
	return (1);
}

/*
 * Socantsendmore indicates that no more data will be sent on the
 * socket; it would normally be applied to a socket when the user
 * informs the system that no more data is to be sent, by the protocol
 * code (in case PRU_SHUTDOWN).	 Socantrcvmore indicates that no more data
 * will be received, and will normally be applied to the socket by a
 * protocol when it detects that the peer will send no more data.
 * Data queued for reading in the socket may yet be read.
 */

void
socantsendmore(so)
	struct socket *so;
{

	so->so_state |= SS_CANTSENDMORE;
	sowwakeup(so);
}

void
socantrcvmore(so)
	struct socket *so;
{

	so->so_state |= SS_CANTRCVMORE;
	sorwakeup(so);
}

/*
 * Wait for data to arrive at/drain from a socket buffer.
 */
int
sbwait(sb, noblock)
	struct sockbuf *sb;
	int noblock;
{

	sb->sb_flags |= SB_WAIT;
	return (tsleep((caddr_t)&sb->sb_cc,
	    (sb->sb_flags & SB_NOINTR) ? PSOCK : PSOCK | PCATCH, netio,
	    sb->sb_timeo, noblock));
}

/*
 * Lock a sockbuf already known to be locked;
 * return any error returned from sleep (EINTR).
 */
int
sb_lock(sb)
	register struct sockbuf *sb;
{
	int error;

	while (sb->sb_flags & SB_LOCK) {
		sb->sb_flags |= SB_WANT;
		error = tsleep((caddr_t)&sb->sb_flags,
		    (sb->sb_flags & SB_NOINTR) ? PSOCK : PSOCK|PCATCH,
		    netio, 0, 0);
		if (error)
			return (error);
	}
	sb->sb_flags |= SB_LOCK;
	return (0);
}

/*
 * Wakeup processes waiting on a socket buffer.
 * Do asynchronous notification via SIGIO
 * if the socket has the SS_ASYNC flag set.
 */
void
sowakeup(so, sb)
	register struct socket *so;
	register struct sockbuf *sb;
{
	struct proc *p;

#ifdef DEBUG
	/*
	 * XXX
	 *
	 * HACK HACK HACK
	 *
	 * pgid is coded as socket descriptor + 1: use
	 * this feature in the debug output
	 */
	if( DODEBUG(DBGSOCKIP) )
	    Printf("so%cwakeup: socket %d\n",
		   (sb == &(so->so_snd)) ? 'w' : 'r',
		   ((so->so_pgid < 0) ? -(so->so_pgid) : so->so_pgid) - 1);
#endif

	selwakeup(&sb->sb_sel);
	sb->sb_flags &= ~SB_SEL;
	if (sb->sb_flags & SB_WAIT) {
		sb->sb_flags &= ~SB_WAIT;
		wakeup((caddr_t)&sb->sb_cc);
	}
	/*
	 * Under RISC OS, it is important not to send "signals" for sockets
	 * with no socket number
	 */
	if (so->so_state & SS_ASYNC) {
#ifdef DEBUG
		if (DODEBUG(DBGSOCKIP))
		    Printf("sowakeup: %csignal\n",
			   (so->so_pgid < 0) ? 'g' : 'p');
#endif

		if (so->so_pgid < 0)
			gsignal(-so->so_pgid, SIGIO);
		else if (so->so_pgid > 0 && (p = pfind(so->so_pgid)) != 0)
			psignal(p, SIGIO);
	}
}

int
sorxdirect(so, m, sa, laddr, esrc, unit, swinum)
	struct socket *so;
	struct mbuf *m;
	struct sockaddr *sa;
	u_long laddr;
	char *esrc;
	int unit, swinum;
{
	register struct proc *p;
#ifdef QuickMNSAcks
	struct mbuf *udp_setup_ack();
#endif
	struct mbuf *n = 0;

	if (so && so->so_state & SS_RXDIRECT) {
		if (so->so_pgid > 0 && (p = pfind(so->so_pgid)) != 0) {
#ifdef QuickMNSAcks
			if (esrc && m->m_len > 8)
			    n = udp_setup_ack(m, sa, laddr);
#else
			esrc = 0;
#endif
			rsignal(p, &m, sa, esrc, unit, swinum, n);

			/*
			 * Client always gains ownership of 'n' and so is
			 * responsible for freeing it. Client may gain
			 * ownership of 'm' by setting m to 0 before
			 * exitting the RXDirect SWI handling code. If 'm'
			 * is non-zero and m->m_len is also non-zero, then
			 * the data is inserted into the socket. If 'm'
			 * is non-zero and m->m_len is zero, m is freed.
			 */

			if (m == 0)
				return (2); /* 2 = don't free m, don't place in buffer */

			if (m->m_len == 0)
				return (1); /* 1 = free m, don't place in buffer */
		}
	}
	return (0); /* 0 = don't free m, place in buffer */
}

/*
 * Socket buffer (struct sockbuf) utility routines.
 *
 * Each socket contains two socket buffers: one for sending data and
 * one for receiving data.  Each buffer contains a queue of mbufs,
 * information about the number of mbufs and amount of data in the
 * queue, and other fields allowing select() statements and notification
 * on data availability to be implemented.
 *
 * Data stored in a socket buffer is maintained as a list of records.
 * Each record is a list of mbufs chained together with the m_next
 * field.  Records are chained together with the m_nextpkt field. The upper
 * level routine soreceive() expects the following conventions to be
 * observed when placing information in the receive buffer:
 *
 * 1. If the protocol requires each message be preceded by the sender's
 *    name, then a record containing that name must be present before
 *    any associated data (mbuf's must be of type MT_SONAME).
 * 2. If the protocol supports the exchange of ``access rights'' (really
 *    just additional data associated with the message), and there are
 *    ``rights'' to be received, then a record containing this data
 *    should be present (mbuf's must be of type MT_RIGHTS).
 * 3. If a name or rights record exists, then it must be followed by
 *    a data record, perhaps of zero length.
 *
 * Before using a new socket structure it is first necessary to reserve
 * buffer space to the socket, by calling sbreserve().	This should commit
 * some of the available buffer space in the system buffer pool for the
 * socket (currently, it does nothing but enforce limits).  The space
 * should be released by calling sbrelease() when the socket is destroyed.
 */

int
soreserve(so, sndcc, rcvcc)
	register struct socket *so;
	u_long sndcc, rcvcc;
{

	if (sbreserve(&so->so_snd, sndcc) == 0)
		goto bad;
	if (sbreserve(&so->so_rcv, rcvcc) == 0)
		goto bad2;
	if (so->so_rcv.sb_lowat == 0)
		so->so_rcv.sb_lowat = 1;
	if (so->so_snd.sb_lowat == 0)
#ifdef __riscos
		so->so_snd.sb_lowat = 1024;
#else
		so->so_snd.sb_lowat = MCLBYTES;
#endif
	if (so->so_snd.sb_lowat > so->so_snd.sb_hiwat)
		so->so_snd.sb_lowat = so->so_snd.sb_hiwat;
	return (0);
bad2:
	sbrelease(&so->so_snd);
bad:
	return (ENOBUFS);
}

/*
 * Allot mbufs to a sockbuf.
 * Attempt to scale mbmax so that mbcnt doesn't become limiting
 * if buffering efficiency is near the normal case.
 */
int
sbreserve(sb, cc)
	struct sockbuf *sb;
	u_long cc;
{

	if (cc > sb_max)
		return (0);
	sb->sb_hiwat = cc;
	sb->sb_mbmax = min(cc * sb_efficiency, sb_max);
	if (sb->sb_lowat > sb->sb_hiwat)
		sb->sb_lowat = sb->sb_hiwat;
	return (1);
}

/*
 * Free mbufs held by a socket, and reserved mbuf space.
 */
void
sbrelease(sb)
	struct sockbuf *sb;
{

	sbflush(sb);
	sb->sb_hiwat = sb->sb_mbmax = 0;
}

/*
 * Routines to add and remove
 * data from an mbuf queue.
 *
 * The routines sbappend() or sbappendrecord() are normally called to
 * append new mbufs to a socket buffer, after checking that adequate
 * space is available, comparing the function sbspace() with the amount
 * of data to be added.	sbappendrecord() differs from sbappend() in
 * that data supplied is treated as the beginning of a new record.
 * To place a sender's address, optional access rights, and data in a
 * socket receive buffer, sbappendaddr() should be used.  To place
 * access rights and data in a socket receive buffer, sbappendrights()
 * should be used.  In either case, the new data begins a new record.
 * Note that unlike sbappend() and sbappendrecord(), these routines check
 * for the caller that there will be enough space to store the data.
 * Each fails if there is not enough space, or if it cannot find mbufs
 * to store additional information in.
 *
 * Reliable protocols may use the socket send buffer to hold data
 * awaiting acknowledgement.  Data is normally copied from a socket
 * send buffer in a protocol with m_copy for output to a peer,
 * and then removing the data from the socket buffer with sbdrop()
 * or sbdroprecord() when the data is acknowledged by the peer.
 */

/*
 * Append mbuf chain m to the last record in the
 * socket buffer sb.  The additional space associated
 * the mbuf chain is recorded in sb.  Empty mbufs are
 * discarded and mbufs are compacted where possible.
 */
void
sbappend(sb, m)
	struct sockbuf *sb;
	struct mbuf *m;
{
	register struct mbuf *n;

	if (m == 0)
		return;
	n = sb->sb_mb;
	if (n) {
		while (n->m_nextpkt)
			n = n->m_nextpkt;
		do {
			if (n->m_flags & M_EOR) {
				sbappendrecord(sb, m); /* XXXXXX!!!! */
				return;
			}
		} while (n->m_next && (n = n->m_next));
	}
	sbcompress(sb, m, n);
#ifdef SOCKBUF_DEBUG
	sbcheck(sb);
#endif
}

#ifdef SOCKBUF_DEBUG
void
sbcheck(sb)
	register struct sockbuf *sb;
{
	register struct mbuf *m;
	register int len = 0, mbcnt = 0;

	for (m = sb->sb_mb; m; m = m->m_next) {
		len += m->m_len;
		mbcnt += m->m_inilen;
#ifndef __riscos
		if (m->m_flags & M_EXT)
			mbcnt += m->m_ext.ext_size;
#endif
		if (m->m_nextpkt)
			panic("sbcheck nextpkt");
	}
	if (len != sb->sb_cc || mbcnt != sb->sb_mbcnt) {
		Printf("cc %d != %d || mbcnt %d != %d\n", len, sb->sb_cc,
		    mbcnt, sb->sb_mbcnt);
		panic("sbcheck");
	}
}
#endif

/*
 * As above, except the mbuf chain
 * begins a new record.
 */
void
sbappendrecord(sb, m0)
	register struct sockbuf *sb;
	register struct mbuf *m0;
{
	register struct mbuf *m;

	if (m0 == 0)
		return;
	m = sb->sb_mb;
	if (m)
		while (m->m_nextpkt)
			m = m->m_nextpkt;
	/*
	 * Put the first mbuf on the queue.
	 * Note this permits zero length records.
	 */
	sballoc(sb, m0);
	if (m)
		m->m_nextpkt = m0;
	else
		sb->sb_mb = m0;
	m = m0->m_next;
	m0->m_next = 0;
	if (m && (m0->m_flags & M_EOR)) {
		m0->m_flags &= ~M_EOR;
		m->m_flags |= M_EOR;
	}
	sbcompress(sb, m, m0);
#ifdef SOCKBUF_DEBUG
	sbcheck(sb);
#endif
}

#ifndef __riscos /* Not used anywhere! */
/*
 * As above except that OOB data
 * is inserted at the beginning of the sockbuf,
 * but after any other OOB data.
 */
void
sbinsertoob(sb, m0)
	register struct sockbuf *sb;
	register struct mbuf *m0;
{
	register struct mbuf *m;
	register struct mbuf **mp;

	if (m0 == 0)
		return;
	for (mp = &sb->sb_mb; *mp ; mp = &((*mp)->m_nextpkt)) {
	    m = *mp;
	    again:
		switch (m->m_type) {

		case MT_OOBDATA:
			continue;		/* WANT next train */

		case MT_CONTROL:
			m = m->m_next;
			if (m)
				goto again;	/* inspect THIS train further */
		}
		break;
	}
	/*
	 * Put the first mbuf on the queue.
	 * Note this permits zero length records.
	 */
	sballoc(sb, m0);
	m0->m_nextpkt = *mp;
	*mp = m0;
	m = m0->m_next;
	m0->m_next = 0;
	if (m && (m0->m_flags & M_EOR)) {
		m0->m_flags &= ~M_EOR;
		m->m_flags |= M_EOR;
	}
	sbcompress(sb, m, m0);
}
#endif

/*
 * Append address and data, and optionally, control (ancillary) data
 * to the receive queue of a socket.  If present,
 * m0 must include a packet header with total length.
 * Returns 0 if no space in sockbuf or insufficient mbufs.
 */
int
sbappendaddr(sb, asa, m0, control)
	register struct sockbuf *sb;
	struct sockaddr *asa;
	struct mbuf *m0, *control;
{
	register struct mbuf *m, *n;
	int space = asa->sa_len;

if (m0 && (m0->m_flags & M_PKTHDR) == 0) {
panic("sbappendaddr");
return (0);
}
	if (m0)
		space += m0->m_pkthdr.len;
	for (n = control; n; n = n->m_next) {
		space += n->m_len;
		if (n->m_next == 0)	/* keep pointer to last control buf */
			break;
	}
	if (space > sbspace(sb))
		return (0);
	if (asa->sa_len > MINCONTIG)
		return (0);
	MGET(m, M_DONTWAIT, MT_SONAME);
	if (m == 0) {
#ifdef DEBUG
		if (DODEBUG(DBGMMAN))
			Printf("sbappendaddr: ALLOC_S failed\n");
#endif
		return (0);
	}
	m->m_len = asa->sa_len;
	bcopy((caddr_t)asa, mtod(m, caddr_t), asa->sa_len);
	if (n)
		n->m_next = m0;		/* concatenate data to control */
	else
		control = m0;
	m->m_next = control;
#ifdef SOCKBUF_DEBUG
        Printf("sballocing: sb=%x, sb->sb_cc=%d, sb->sb_mbcnt=%d\n", sb, sb->sb_cc, sb->sb_mbcnt);
	for (n = m; n; n = n->m_next) {
	        Printf("sballocing: adding n=%x, n->m_len=%d, n->m_inilen=%d\n", n, n->m_len, n->m_inilen);
		sballoc(sb, n);
	}
        Printf("sballoced:  sb=%x, sb->sb_cc=%d, sb->sb_mbcnt=%d\n", sb, sb->sb_cc, sb->sb_mbcnt);
#else
	for (n = m; n; n = n->m_next)
		sballoc(sb, n);
#endif
	n = sb->sb_mb;
	if (n) {
		while (n->m_nextpkt)
			n = n->m_nextpkt;
		n->m_nextpkt = m;
	} else
		sb->sb_mb = m;
#ifdef SOCKBUF_DEBUG
	sbcheck(sb);
#endif
	return (1);
}

int
sbappendcontrol(sb, m0, control)
	struct sockbuf *sb;
	struct mbuf *control, *m0;
{
	register struct mbuf *m, *n;
	int space = 0;

	if (control == 0) {
		panic("sbappendcontrol");
		return (0);
	}
	for (m = control; ; m = m->m_next) {
		space += m->m_len;
		if (m->m_next == 0)
			break;
	}
	n = m;			/* save pointer to last control buffer */
	for (m = m0; m; m = m->m_next)
		space += m->m_len;
	if (space > sbspace(sb))
		return (0);
	n->m_next = m0;			/* concatenate data to control */
	for (m = control; m; m = m->m_next)
		sballoc(sb, m);
	n = sb->sb_mb;
	if (n) {
		while (n->m_nextpkt)
			n = n->m_nextpkt;
		n->m_nextpkt = control;
	} else
		sb->sb_mb = control;
	return (1);
}

/*
 * Compress mbuf chain m into the socket
 * buffer sb following mbuf n.	If n
 * is null, the buffer is presumed empty.
 */
void
sbcompress(sb, m, n)
	register struct sockbuf *sb;
	register struct mbuf *m, *n;
{
	register int eor = 0;
	register struct mbuf *o;

	while (m) {
		eor |= m->m_flags & M_EOR;
		if (m->m_len == 0 &&
		    (eor == 0 ||
		     (((o = m->m_next) || (o = n)) &&
		      o->m_type == m->m_type))) {
			m = m_freen(m);
			continue;
		}
		if (n && (n->m_flags & M_EOR) == 0 &&
		    (n->m_off + n->m_len + m->m_len) < MAXOFF(n) &&
		    n->m_type == m->m_type) {
			bcopy(mtod(m, caddr_t), mtod(n, caddr_t) + n->m_len,
			    (unsigned)m->m_len);
			n->m_len += m->m_len;
			sb->sb_cc += m->m_len;
			m = m_freen(m);
			continue;
		}
		if (n)
			n->m_next = m;
		else
			sb->sb_mb = m;
		sballoc(sb, m);
		n = m;
		m->m_flags &= ~M_EOR;
		m = m->m_next;
		n->m_next = 0;
	}
	if (eor) {
		if (n)
			n->m_flags |= eor;
		else
			printf("semi-panic: sbcompress\n");
	}
}

/*
 * Free all mbufs in a sockbuf.
 * Check that all resources are reclaimed.
 */
void
sbflush(sb)
	register struct sockbuf *sb;
{

	if (sb->sb_flags & SB_LOCK) {
		panic("sbflush");
		return;
	}
	while (sb->sb_mbcnt)
		sbdrop(sb, (int)sb->sb_cc);
	if (sb->sb_cc || sb->sb_mb)
		panic("sbflush 2");
}

/*
 * Drop data from (the front of) a sockbuf.
 */
void
sbdrop(sb, len)
	register struct sockbuf *sb;
	register int len;
{
	register struct mbuf *m, *mn;
	struct mbuf *next;

	next = (m = sb->sb_mb) ? m->m_nextpkt : 0;
	while (len > 0) {
		if (m == 0) {
			if (next == 0) {
				panic("sbdrop");
				return;
			}
			m = next;
			next = m->m_nextpkt;
			continue;
		}
		if (m->m_len > len) {
			m->m_len -= len;
			m->m_off += len;
			sb->sb_cc -= len;
			break;
		}
		len -= m->m_len;
		sbfree(sb, m);
		MFREE(m, mn);
		m = mn;
	}
	while (m && m->m_len == 0) {
		sbfree(sb, m);
		MFREE(m, mn);
		m = mn;
	}
	if (m) {
		sb->sb_mb = m;
		m->m_nextpkt = next;
	} else
		sb->sb_mb = next;
}

/*
 * Drop a record off the front of a sockbuf
 * and move the next record to the front.
 */
void
sbdroprecord(sb)
	register struct sockbuf *sb;
{
	register struct mbuf *m, *mn;

	m = sb->sb_mb;
	if (m) {
		sb->sb_mb = m->m_nextpkt;
		do {
			sbfree(sb, m);
			MFREE(m, mn);
			m = mn;
		} while (m);
	}
}

/*
 * Create a "control" mbuf containing the specified data
 * with the specified type for presentation on a socket buffer.
 */
struct mbuf *
sbcreatecontrol(p, size, type, level)
	caddr_t p;
	register int size;
	int type, level;
{
	register struct cmsghdr *cp;
	struct mbuf *m;

	if ((m = m_get(M_DONTWAIT, MT_CONTROL)) == NULL)
		return ((struct mbuf *) NULL);
	cp = mtod(m, struct cmsghdr *);
	/* XXX check size? */
	(void)memcpy(CMSG_DATA(cp), p, size);
	size += sizeof(*cp);
	m->m_len = size;
	cp->cmsg_len = size;
	cp->cmsg_level = level;
	cp->cmsg_type = type;
	return (m);
}

/*
 * Create an external-format (``xsocket'') structure using the information
 * in the kernel-format socket structure pointed to by so.  This is done
 * to reduce the spew of irrelevant information over this interface,
 * to isolate user code from changes in the kernel structure, and
 * potentially to provide information-hiding if we decide that
 * some of this information should be hidden from users.
 */
void
sotoxsocket(struct socket *so, struct xsocket *xso)
{
	xso->xso_len = sizeof *xso;
	xso->xso_so = so;
	xso->so_type = so->so_type;
	xso->so_options = so->so_options;
	xso->so_linger = so->so_linger;
	xso->so_state = so->so_state;
	xso->so_pcb = so->so_pcb;
	xso->xso_protocol = so->so_proto->pr_protocol;
	xso->xso_family = so->so_proto->pr_domain->dom_family;
	xso->so_qlen = so->so_qlen;
#if 0
	xso->so_incqlen = so->so_incqlen;
#else
	xso->so_incqlen = so->so_q0len;
#endif
	xso->so_qlimit = so->so_qlimit;
	xso->so_timeo = so->so_timeo;
	xso->so_error = so->so_error;
#ifdef __riscos
	xso->so_pgid = 0;
#else
	xso->so_pgid = so->so_sigio ? so->so_sigio->sio_pgid : 0;
#endif
	xso->so_oobmark = so->so_oobmark;
	sbtoxsockbuf(&so->so_snd, &xso->so_snd);
	sbtoxsockbuf(&so->so_rcv, &xso->so_rcv);
#ifdef __riscos
	xso->so_uid = -1;
#else
	xso->so_uid = so->so_cred ? so->so_cred->pc_ucred->cr_uid : -1;
#endif
}

/*
 * This does the same for sockbufs.  Note that the xsockbuf structure,
 * since it is always embedded in a socket, does not include a self
 * pointer nor a length.  We make this entry point public in case
 * some other mechanism needs it.
 */
void
sbtoxsockbuf(struct sockbuf *sb, struct xsockbuf *xsb)
{
	xsb->sb_cc = sb->sb_cc;
	xsb->sb_hiwat = sb->sb_hiwat;
	xsb->sb_mbcnt = sb->sb_mbcnt;
	xsb->sb_mbmax = sb->sb_mbmax;
	xsb->sb_lowat = sb->sb_lowat;
	xsb->sb_flags = sb->sb_flags;
	xsb->sb_timeo = sb->sb_timeo;
}
@


4.4
log
@Added new FreeBSD sysctl handling using linker magic.
A few new sysctls added as a result.
SO_TIMESTAMP now gives real time, not Internet's internal time.
DHCP/BOOTP parsing picks up URL option and pops it into Inet$URL.
Requires TCPIPLibs 5.25 and link 5.12.

Version 5.31. Tagged as 'Internet-5_31'
@
text
@d391 1
a391 1
			rsignal(p, m, sa, esrc, unit, swinum, n);
d394 7
a400 6
			 * 941207 KWelton
			 *
			 * The mbuf chain should be freed when the client
			 * (i.e. the Net module) makes a direct call into
			 * the device driver, who gains control of the
			 * mbuf chain in the standard fashion
d402 4
a405 10
#if 0
			if (n)
			{
# ifdef OldCode
			    m_freem(n);
# else
			    FREEM(n);
# endif
			}
#endif
d407 1
a407 1
			    return (1);
d410 1
a410 1
	return (0);
@


4.3
log
@* Dynamic ports now assigned in range 49152-65535.
* IP_RECVDSTADDR works for non-unicast packets.
* SO_TIMESTAMP added.
* IP_RECVIF added.
* Various other internal changes merged in from FreeBSD sources.

Version 5.29. Tagged as 'Internet-5_29'
@
text
@d39 1
d941 62
@


4.2
log
@Version Spinner_B7 taken
@
text
@d915 26
@


4.1
log
@Initial revision
@
text
@d1 3
a3 1
/* -*-C-*-
d5 27
a31 2
 * $Header: /ax/networking:Internet/sys/socket1.c:networking  1.3  $
 * $Source: /ax/networking:Internet/sys/socket1.c: $
d33 16
a48 44
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
 *
 * $Log:	socket1.c,v $
 * Revision 1.3  95/03/31  12:04:43  kwelton
 * Added some debugs to sowakeup().
 * 
 * Revision 1.2  94/12/14  16:00:17  kwelton
 * The DCI 4 version of the Net module cedes ownership of the mbuf chain
 * passed to it via rsignal in sorxdirect() to the appropriate device
 * driver, so it is no longer the reponsibility of this module to free
 * the chain.
 * 
 * Revision 1.1  94/12/02  11:47:50  kwelton
 * Initial revision
 * 
 */
/*
 * Copyright (c) 1983, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 */
#include "sys/param.h"
#include "sys/systm.h"
#include "sys/dir.h"
#include "sys/file.h"
#include "sys/buf.h"
#include "sys/user.h"
#include "sys/proc.h"
#include "sys/mbuf.h"
#include "sys/protosw.h"
#include "sys/socket.h"
#include "sys/socketvar.h"
d51 5
d61 9
d100 1
a106 1
	wakeup((caddr_t)&so->so_timeo);
d109 1
d115 3
a117 5
	if (head) {
		if (soqremque(so, 0) == 0) {
			panic("soisconnected");
			return;
		}
d121 4
a125 5
	so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
	so->so_state |= SS_ISCONNECTED;
	wakeup((caddr_t)&so->so_timeo);
	sorwakeup(so);
	sowwakeup(so);
d128 1
d140 1
d158 4
d164 1
a164 1
sonewconn(head)
d166 1
d169 1
a169 1
	register struct mbuf *m;
d172 5
a176 18
		goto bad;
#ifdef OldCode
	m = m_getclr(M_DONTWAIT, MT_SOCKET);
	if (m == NULL)
		goto bad;
#else
	if( (m = ALLOC_C(MINCONTIG, NULL)) == NULL )
	{
#ifdef DEBUG
	    if( DODEBUG(DBGMMAN) )
		Printf("sonewconn: ALLOC_C failed\n");
#endif
	    goto bad;
	}

	m->m_type = MT_SOCKET;
#endif
	so = mtod(m, struct socket *);
d183 3
a185 3
	so->so_pgrp = head->so_pgrp;
	(void) soreserve(so, head->so_snd.sb_hiwat, head->so_snd.sb_hiwat);
	soqinsque(head, so, 0);
d188 8
a195 7
		(void) soqremque(so, 0);
#ifdef OldCode
		(void) m_free(m);
#else
		FREE(m);
#endif
		goto bad;
a197 2
bad:
	return ((struct socket *)0);
d200 1
d206 1
d210 3
a212 2
		so->so_q0 = head->so_q0;
		head->so_q0 = so;
d215 3
a217 2
		so->so_q = head->so_q;
		head->so_q = so;
d219 1
d222 1
d235 1
a235 1
		if (next == head)
d261 1
d270 1
a279 18
 * Socket select/wakeup routines.
 */

/*
 * Queue a process for a select on a socket buffer.
 */
sbselqueue(sb)
	struct sockbuf *sb;
{
	register struct proc *p;

	if ((p = sb->sb_sel) && p->p_wchan == (caddr_t)&selwait)
		sb->sb_flags |= SB_COLL;
	else
		sb->sb_sel = u.u_procp;
}

/*
d282 2
a283 1
int sbwait(sb)
d285 1
a286 1
	int r;
d289 3
a291 4
	r = sleep((caddr_t)&sb->sb_cc, PZERO+1);
	if (r != 0)
		sb->sb_flags &= ~SB_WAIT;
	return (r);
d295 2
a296 1
 * Wakeup processes waiting on a socket buffer.
d298 2
a299 1
sbwakeup(sb)
d302 9
a310 8
	if (sb->sb_sel) {
		selwakeup(sb->sb_sel, sb->sb_flags & SB_COLL);
		sb->sb_sel = 0;
		sb->sb_flags &= ~SB_COLL;
	}
	if (sb->sb_flags & SB_WAIT) {
		sb->sb_flags &= ~SB_WAIT;
		wakeup((caddr_t)&sb->sb_cc);
d312 2
d317 1
a317 1
 * Wakeup socket readers and writers.
d321 1
d324 1
a324 1
	struct sockbuf *sb;
d326 1
a326 1
	register struct proc *p;
d334 1
a334 1
	 * pgrp is coded as socket descriptor + 1: use
d340 1
a340 1
		   ((so->so_pgrp < 0) ? -(so->so_pgrp) : so->so_pgrp) - 1);
d343 10
a352 1
	sbwakeup(sb);
d355 1
a355 1
		if( DODEBUG(DBGSOCKIP) )
d357 1
a357 1
			   (so->so_pgrp < 0) ? 'g' : 'p');
d360 3
a362 3
		if (so->so_pgrp < 0)
			gsignal(-so->so_pgrp, SIGIO);
		else if (so->so_pgrp > 0 && (p = pfind(so->so_pgrp)) != 0)
d367 2
a368 1
int sorxdirect(so, m, sa, laddr, esrc, unit, swinum)
d377 1
d379 1
d383 2
a384 1
		if (so->so_pgrp > 0 && (p = pfind(so->so_pgrp)) != 0) {
d387 4
a390 2
			rsignal(p, (int)m, (int)sa, (int)esrc,
				unit, swinum, (int)n);
d428 1
a428 1
 * field.  Records are chained together with the m_act field. The upper
d449 1
d454 15
a468 2
	(void) sbreserve(&so->so_snd, sndcc);
	(void) sbreserve(&so->so_rcv, rcvcc);
d470 4
d477 3
a479 1
 * Allot mbufs to a sockbuf (void in RISC OS).
d481 1
d486 7
a492 1
	sb->sb_hiwat = sb->sb_mbmax = cc;
d497 1
a497 1
 * Free mbufs held by a socket, and "reserved" mbuf space.
d499 1
d513 1
a513 1
 * append new mbufs to a socket buffer [, after checking that adequate
d515 1
a515 1
 * of data to be added (NOT RISC OS)].	sbappendrecord() differs from sbappend() in
d523 1
a523 1
 * Each fails if [ there is not enough space, or if] it cannot find mbufs
d539 1
d548 10
a557 5
	if (n = sb->sb_mb) {
		while (n->m_list)
			n = n->m_list;
		while (n->m_next)
			n = n->m_next;
d560 28
d589 1
d595 1
d604 4
a607 3
	if (m = sb->sb_mb)
		while (m->m_list)
			m = m->m_list;
d614 1
a614 1
		m->m_list = m0;
d619 4
d624 3
d629 1
d631 3
a633 3
 * Append address and data, and optionally, rights
 * to the receive queue of a socket.  Return 0 if
 * insufficient mbufs.
d635 50
a684 1
sbappendaddr(sb, asa, m0, rights0)
d687 1
a687 1
	struct mbuf *rights0, *m0;
d690 1
d692 15
a706 1
#ifdef OldCode
d708 1
a708 5
	if (m == 0)
		return (0);
#else
	if( (m = ALLOC_S(MINCONTIG, NULL)) == NULL )
	{
d710 2
a711 2
	    if( DODEBUG(DBGMMAN) )
		Printf("sbappendaddr: ALLOC_S failed\n");
d713 1
a713 1
	    return(0);
d715 14
a728 11
	m->m_type = MT_SONAME;
#endif
	*mtod(m, struct sockaddr *) = *asa;
	m->m_len = sizeof (*asa);
	if (rights0 && rights0->m_len) {
#ifdef OldCode
		m->m_next = m_copy(rights0, 0, rights0->m_len);
		if (m->m_next == 0) {
			m_freem(m);
			return (0);
		}
d730 2
a731 9
		if( (m->m_next = COPY_P(rights0, 0, rights0->m_len)) == NULL )
		{
#ifdef DEBUG
		    if( DODEBUG(DBGMMAN) )
			Printf("sbappendaddr: COPY failed\n");
#endif
		    FREEM(m);
		    return(0);
		}
d733 5
a737 7
		sballoc(sb, m->m_next);
	}
	sballoc(sb, m);
	if (n = sb->sb_mb) {
		while (n->m_list)
			n = n->m_list;
		n->m_list = m;
d740 3
a742 4
	if (m->m_next)
		m = m->m_next;
	if (m0)
		sbcompress(sb, m0, m);
d746 2
a747 1
sbappendrights(sb, m0, rights)
d749 1
a749 1
	struct mbuf *rights, *m0;
d752 1
d754 2
a755 2
	if (rights == 0) {
		panic("sbappendrights");
d758 9
a766 3
#ifdef OldCode
	m = m_copy(rights, 0, rights->m_len);
	if (m == 0)
d768 8
a775 9
#else
	if( (m = COPY_P(rights, 0, rights->m_len)) == NULL )
	    return(0);
#endif
	sballoc(sb, m);
	if (n = sb->sb_mb) {
		while (n->m_list)
			n = n->m_list;
		n->m_list = m;
d777 1
a777 3
		sb->sb_mb = m;
	if (m0)
		sbcompress(sb, m0, m);
d786 1
d791 2
d795 6
a800 8
		if (m->m_len == 0) {
#ifdef OldCode
			m = m_free(m);
#else
			struct mbuf *m0 = m;
			m = m0->m_next;
			FREE(m0);
#endif
d803 2
a804 2
		if (n && n->m_off <= MAXOFF(n) && m->m_off <= MAXOFF(n) &&
		    (n->m_off + n->m_len + m->m_len) <= MAXOFF(n) &&
d810 1
a810 9
#ifdef OldCode
			m = m_free(m);
#else
		        {
			    struct mbuf *m0 = m;
			    m = m0->m_next;
			    FREE(m0);
			}
#endif
a812 1
		sballoc(sb, m);
d817 1
d819 1
d823 6
d835 1
d846 1
a846 1
	if (sb->sb_cc || sb->sb_mbcnt || sb->sb_mb)
d853 1
d861 1
a861 1
	next = (m = sb->sb_mb) ? m->m_list : 0;
d869 1
a869 1
			next = m->m_list;
d890 1
a890 1
		m->m_list = next;
d899 1
d907 1
a907 1
		sb->sb_mb = m->m_list;
d911 2
a912 1
		} while (m = mn);
a914 2

/* EOF socket1.c */
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d1 4
a4 3
/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
d6 1
a6 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d8 42
a49 16
 */

#include <string.h>

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/signalvar.h>
a51 5
#include "module.h"

#ifdef SOCKBUF_DEBUG
void sbcheck(struct sockbuf *);
#endif
a56 9
/* strings for sleep message: */
char	netio[] = "netio";
char	netcon[] = "netcon";
char	netcls[] = "netcls";

u_long	sb_max = SB_MAX;		/* patchable */

static	u_long sb_efficiency = 8;	/* parameter for sbreserve() */

a86 1
void
d93 1
a95 1
void
d101 5
a105 3
	so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING|SS_ISCONFIRMING);
	so->so_state |= SS_ISCONNECTED;
	if (head && soqremque(so, 0)) {
a108 4
	} else {
		wakeup((caddr_t)&so->so_timeo);
		sorwakeup(so);
		sowwakeup(so);
d110 5
a116 1
void
a127 1
void
a144 4
 * Connstatus may be 0, or SO_ISCONFIRMING, or SO_ISCONNECTED.
 *
 * Currently, sonewconn() is defined as sonewconn1() in socketvar.h
 * to catch calls that are missing the (new) second parameter.
d147 1
a147 1
sonewconn1(head, connstatus)
a148 1
	int connstatus;
d151 1
a151 1
	int soqueue = connstatus ? 1 : 0;
d154 18
a171 5
		return ((struct socket *)0);
	MALLOC(so, struct socket *, sizeof(*so), M_SOCKET, M_DONTWAIT);
	if (so == NULL)
		return ((struct socket *)0);
	bzero((caddr_t)so, sizeof(*so));
d178 3
a180 3
	so->so_pgid = head->so_pgid;
	(void) soreserve(so, head->so_snd.sb_hiwat, head->so_rcv.sb_hiwat);
	soqinsque(head, so, soqueue);
d183 7
a189 8
		(void) soqremque(so, soqueue);
		(void) free((caddr_t)so, M_SOCKET);
		return ((struct socket *)0);
	}
	if (connstatus) {
		sorwakeup(head);
		wakeup((caddr_t)&head->so_timeo);
		so->so_state |= connstatus;
d192 2
a195 1
void
a200 1
	register struct socket **prev;
d204 2
a205 3
		so->so_q0 = 0;
		for (prev = &(head->so_q0); *prev; )
			prev = &((*prev)->so_q0);
d208 2
a209 3
		so->so_q = 0;
		for (prev = &(head->so_q); *prev; )
			prev = &((*prev)->so_q);
a210 1
	*prev = so;
a212 1
int
d225 1
a225 1
		if (next == 0)
a250 1
void
a258 1
void
d268 18
d288 1
a288 2
int
sbwait(sb, noblock)
a289 1
	int noblock;
d291 1
d294 4
a297 3
	return (tsleep((caddr_t)&sb->sb_cc,
	    (sb->sb_flags & SB_NOINTR) ? PSOCK : PSOCK | PCATCH, netio,
	    sb->sb_timeo, noblock));
d301 1
a301 2
 * Lock a sockbuf already known to be locked;
 * return any error returned from sleep (EINTR).
d303 1
a303 2
int
sb_lock(sb)
d306 8
a313 9
	int error;

	while (sb->sb_flags & SB_LOCK) {
		sb->sb_flags |= SB_WANT;
		error = tsleep((caddr_t)&sb->sb_flags,
		    (sb->sb_flags & SB_NOINTR) ? PSOCK : PSOCK|PCATCH,
		    netio, 0, 0);
		if (error)
			return (error);
a314 2
	sb->sb_flags |= SB_LOCK;
	return (0);
d318 1
a318 1
 * Wakeup processes waiting on a socket buffer.
a321 1
void
d324 1
a324 1
	register struct sockbuf *sb;
d326 1
a326 1
	struct proc *p;
d334 1
a334 1
	 * pgid is coded as socket descriptor + 1: use
d340 1
a340 1
		   ((so->so_pgid < 0) ? -(so->so_pgid) : so->so_pgid) - 1);
d343 1
a343 10
	selwakeup(&sb->sb_sel);
	sb->sb_flags &= ~SB_SEL;
	if (sb->sb_flags & SB_WAIT) {
		sb->sb_flags &= ~SB_WAIT;
		wakeup((caddr_t)&sb->sb_cc);
	}
	/*
	 * Under RISC OS, it is important not to send "signals" for sockets
	 * with no socket number
	 */
d346 1
a346 1
		if (DODEBUG(DBGSOCKIP))
d348 1
a348 1
			   (so->so_pgid < 0) ? 'g' : 'p');
d351 3
a353 3
		if (so->so_pgid < 0)
			gsignal(-so->so_pgid, SIGIO);
		else if (so->so_pgid > 0 && (p = pfind(so->so_pgid)) != 0)
d358 1
a358 2
int
sorxdirect(so, m, sa, laddr, esrc, unit, swinum)
a366 1
#ifdef QuickMNSAcks
a367 1
#endif
d371 1
a371 2
		if (so->so_pgid > 0 && (p = pfind(so->so_pgid)) != 0) {
#ifdef QuickMNSAcks
d374 2
a375 4
#else
			esrc = 0;
#endif
			rsignal(p, m, sa, esrc, unit, swinum, n);
d413 1
a413 1
 * field.  Records are chained together with the m_nextpkt field. The upper
a433 1
int
d438 2
a439 15

	if (sbreserve(&so->so_snd, sndcc) == 0)
		goto bad;
	if (sbreserve(&so->so_rcv, rcvcc) == 0)
		goto bad2;
	if (so->so_rcv.sb_lowat == 0)
		so->so_rcv.sb_lowat = 1;
	if (so->so_snd.sb_lowat == 0)
#ifdef __riscos
		so->so_snd.sb_lowat = 1024;
#else
		so->so_snd.sb_lowat = MCLBYTES;
#endif
	if (so->so_snd.sb_lowat > so->so_snd.sb_hiwat)
		so->so_snd.sb_lowat = so->so_snd.sb_hiwat;
a440 4
bad2:
	sbrelease(&so->so_snd);
bad:
	return (ENOBUFS);
d444 1
a444 3
 * Allot mbufs to a sockbuf.
 * Attempt to scale mbmax so that mbcnt doesn't become limiting
 * if buffering efficiency is near the normal case.
a445 1
int
d450 1
a450 7

	if (cc > sb_max)
		return (0);
	sb->sb_hiwat = cc;
	sb->sb_mbmax = min(cc * sb_efficiency, sb_max);
	if (sb->sb_lowat > sb->sb_hiwat)
		sb->sb_lowat = sb->sb_hiwat;
d455 1
a455 1
 * Free mbufs held by a socket, and reserved mbuf space.
a456 1
void
d470 1
a470 1
 * append new mbufs to a socket buffer, after checking that adequate
d472 1
a472 1
 * of data to be added.	sbappendrecord() differs from sbappend() in
d480 1
a480 1
 * Each fails if there is not enough space, or if it cannot find mbufs
a495 1
void
d504 5
a508 10
	n = sb->sb_mb;
	if (n) {
		while (n->m_nextpkt)
			n = n->m_nextpkt;
		do {
			if (n->m_flags & M_EOR) {
				sbappendrecord(sb, m); /* XXXXXX!!!! */
				return;
			}
		} while (n->m_next && (n = n->m_next));
a510 28
#ifdef SOCKBUF_DEBUG
	sbcheck(sb);
#endif
}

#ifdef SOCKBUF_DEBUG
void
sbcheck(sb)
	register struct sockbuf *sb;
{
	register struct mbuf *m;
	register int len = 0, mbcnt = 0;

	for (m = sb->sb_mb; m; m = m->m_next) {
		len += m->m_len;
		mbcnt += m->m_inilen;
#ifndef __riscos
		if (m->m_flags & M_EXT)
			mbcnt += m->m_ext.ext_size;
#endif
		if (m->m_nextpkt)
			panic("sbcheck nextpkt");
	}
	if (len != sb->sb_cc || mbcnt != sb->sb_mbcnt) {
		Printf("cc %d != %d || mbcnt %d != %d\n", len, sb->sb_cc,
		    mbcnt, sb->sb_mbcnt);
		panic("sbcheck");
	}
a511 1
#endif
a516 1
void
d525 3
a527 4
	m = sb->sb_mb;
	if (m)
		while (m->m_nextpkt)
			m = m->m_nextpkt;
d534 1
a534 1
		m->m_nextpkt = m0;
a538 4
	if (m && (m0->m_flags & M_EOR)) {
		m0->m_flags &= ~M_EOR;
		m->m_flags |= M_EOR;
	}
a539 3
#ifdef SOCKBUF_DEBUG
	sbcheck(sb);
#endif
a541 1
#ifndef __riscos /* Not used anywhere! */
d543 3
a545 3
 * As above except that OOB data
 * is inserted at the beginning of the sockbuf,
 * but after any other OOB data.
d547 1
a547 50
void
sbinsertoob(sb, m0)
	register struct sockbuf *sb;
	register struct mbuf *m0;
{
	register struct mbuf *m;
	register struct mbuf **mp;

	if (m0 == 0)
		return;
	for (mp = &sb->sb_mb; *mp ; mp = &((*mp)->m_nextpkt)) {
	    m = *mp;
	    again:
		switch (m->m_type) {

		case MT_OOBDATA:
			continue;		/* WANT next train */

		case MT_CONTROL:
			m = m->m_next;
			if (m)
				goto again;	/* inspect THIS train further */
		}
		break;
	}
	/*
	 * Put the first mbuf on the queue.
	 * Note this permits zero length records.
	 */
	sballoc(sb, m0);
	m0->m_nextpkt = *mp;
	*mp = m0;
	m = m0->m_next;
	m0->m_next = 0;
	if (m && (m0->m_flags & M_EOR)) {
		m0->m_flags &= ~M_EOR;
		m->m_flags |= M_EOR;
	}
	sbcompress(sb, m, m0);
}
#endif

/*
 * Append address and data, and optionally, control (ancillary) data
 * to the receive queue of a socket.  If present,
 * m0 must include a packet header with total length.
 * Returns 0 if no space in sockbuf or insufficient mbufs.
 */
int
sbappendaddr(sb, asa, m0, control)
d550 1
a550 1
	struct mbuf *m0, *control;
a552 1
	int space = asa->sa_len;
d554 3
a556 12
if (m0 && (m0->m_flags & M_PKTHDR) == 0) {
panic("sbappendaddr");
return (0);
}
	if (m0)
		space += m0->m_pkthdr.len;
	for (n = control; n; n = n->m_next) {
		space += n->m_len;
		if (n->m_next == 0)	/* keep pointer to last control buf */
			break;
	}
	if (space > sbspace(sb))
d558 3
a560 4
	if (asa->sa_len > MINCONTIG)
		return (0);
	MGET(m, M_DONTWAIT, MT_SONAME);
	if (m == 0) {
d562 2
a563 2
		if (DODEBUG(DBGMMAN))
			Printf("sbappendaddr: ALLOC_S failed\n");
d565 1
a565 1
		return (0);
d567 11
a577 14
	m->m_len = asa->sa_len;
	bcopy((caddr_t)asa, mtod(m, caddr_t), asa->sa_len);
	if (n)
		n->m_next = m0;		/* concatenate data to control */
	else
		control = m0;
	m->m_next = control;
#ifdef SOCKBUF_DEBUG
        Printf("sballocing: sb=%x, sb->sb_cc=%d, sb->sb_mbcnt=%d\n", sb, sb->sb_cc, sb->sb_mbcnt);
	for (n = m; n; n = n->m_next) {
	        Printf("sballocing: adding n=%x, n->m_len=%d, n->m_inilen=%d\n", n, n->m_len, n->m_inilen);
		sballoc(sb, n);
	}
        Printf("sballoced:  sb=%x, sb->sb_cc=%d, sb->sb_mbcnt=%d\n", sb, sb->sb_cc, sb->sb_mbcnt);
d579 9
a587 2
	for (n = m; n; n = n->m_next)
		sballoc(sb, n);
d589 7
a595 5
	n = sb->sb_mb;
	if (n) {
		while (n->m_nextpkt)
			n = n->m_nextpkt;
		n->m_nextpkt = m;
d598 4
a601 3
#ifdef SOCKBUF_DEBUG
	sbcheck(sb);
#endif
d605 1
a605 2
int
sbappendcontrol(sb, m0, control)
d607 1
a607 1
	struct mbuf *control, *m0;
a609 1
	int space = 0;
d611 2
a612 2
	if (control == 0) {
		panic("sbappendcontrol");
d615 3
a617 9
	for (m = control; ; m = m->m_next) {
		space += m->m_len;
		if (m->m_next == 0)
			break;
	}
	n = m;			/* save pointer to last control buffer */
	for (m = m0; m; m = m->m_next)
		space += m->m_len;
	if (space > sbspace(sb))
d619 9
a627 8
	n->m_next = m0;			/* concatenate data to control */
	for (m = control; m; m = m->m_next)
		sballoc(sb, m);
	n = sb->sb_mb;
	if (n) {
		while (n->m_nextpkt)
			n = n->m_nextpkt;
		n->m_nextpkt = control;
d629 3
a631 1
		sb->sb_mb = control;
a639 1
void
a643 2
	register int eor = 0;
	register struct mbuf *o;
d646 8
a653 6
		eor |= m->m_flags & M_EOR;
		if (m->m_len == 0 &&
		    (eor == 0 ||
		     (((o = m->m_next) || (o = n)) &&
		      o->m_type == m->m_type))) {
			m = m_freen(m);
d656 2
a657 2
		if (n && (n->m_flags & M_EOR) == 0 &&
		    (n->m_off + n->m_len + m->m_len) < MAXOFF(n) &&
d663 9
a671 1
			m = m_freen(m);
d674 1
a678 1
		sballoc(sb, m);
a679 1
		m->m_flags &= ~M_EOR;
a682 6
	if (eor) {
		if (n)
			n->m_flags |= eor;
		else
			printf("semi-panic: sbcompress\n");
	}
a688 1
void
d699 1
a699 1
	if (sb->sb_cc || sb->sb_mb)
a705 1
void
d713 1
a713 1
	next = (m = sb->sb_mb) ? m->m_nextpkt : 0;
d721 1
a721 1
			next = m->m_nextpkt;
d742 1
a742 1
		m->m_nextpkt = next;
a750 1
void
d758 1
a758 1
		sb->sb_mb = m->m_nextpkt;
d762 1
a762 2
			m = mn;
		} while (m);
d765 2
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@RCS log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d1 6
a6 3
/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
d8 42
a49 44
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)uipc_socket2.c	8.1 (Berkeley) 6/10/93
 * $Id: uipc_socket2.c,v 1.5.4.1 1996/02/16 19:04:52 davidg Exp $
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
//#include <sys/signalvar.h>
a51 5
#include "module.h"

#ifdef SOCKBUF_DEBUG
void sbcheck(struct sockbuf *);
#endif
a56 9
/* strings for sleep message: */
char	netio[] = "netio";
char	netcon[] = "netcon";
char	netcls[] = "netcls";

u_long	sb_max = SB_MAX;		/* patchable */

static	u_long sb_efficiency = 8;	/* parameter for sbreserve() */

a86 1
void
d93 1
a95 1
void
d101 5
a105 3
	so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING|SS_ISCONFIRMING);
	so->so_state |= SS_ISCONNECTED;
	if (head && soqremque(so, 0)) {
a108 4
	} else {
		wakeup((caddr_t)&so->so_timeo);
		sorwakeup(so);
		sowwakeup(so);
d110 5
a116 1
void
a127 1
void
a144 4
 * Connstatus may be 0, or SO_ISCONFIRMING, or SO_ISCONNECTED.
 *
 * Currently, sonewconn() is defined as sonewconn1() in socketvar.h
 * to catch calls that are missing the (new) second parameter.
d147 1
a147 1
sonewconn1(head, connstatus)
a148 1
	int connstatus;
d151 1
a151 1
	int soqueue = connstatus ? 1 : 0;
d154 18
a171 5
		return ((struct socket *)0);
	MALLOC(so, struct socket *, sizeof(*so), M_SOCKET, M_DONTWAIT);
	if (so == NULL)
		return ((struct socket *)0);
	bzero((caddr_t)so, sizeof(*so));
d178 3
a180 3
	so->so_pgid = head->so_pgid;
	(void) soreserve(so, head->so_snd.sb_hiwat, head->so_rcv.sb_hiwat);
	soqinsque(head, so, soqueue);
d183 7
a189 8
		(void) soqremque(so, soqueue);
		(void) free((caddr_t)so, M_SOCKET);
		return ((struct socket *)0);
	}
	if (connstatus) {
		sorwakeup(head);
		wakeup((caddr_t)&head->so_timeo);
		so->so_state |= connstatus;
d192 2
a195 1
void
a200 1
	register struct socket **prev;
d204 2
a205 3
		so->so_q0 = 0;
		for (prev = &(head->so_q0); *prev; )
			prev = &((*prev)->so_q0);
d208 2
a209 3
		so->so_q = 0;
		for (prev = &(head->so_q); *prev; )
			prev = &((*prev)->so_q);
a210 1
	*prev = so;
a212 1
int
d225 1
a225 1
		if (next == 0)
a250 1
void
a258 1
void
d268 18
d288 1
a288 2
int
sbwait(sb, noblock)
a289 1
	int noblock;
d291 1
d294 4
a297 3
	return (tsleep((caddr_t)&sb->sb_cc,
	    (sb->sb_flags & SB_NOINTR) ? PSOCK : PSOCK | PCATCH, netio,
	    sb->sb_timeo, noblock));
d301 1
a301 2
 * Lock a sockbuf already known to be locked;
 * return any error returned from sleep (EINTR).
d303 1
a303 2
int
sb_lock(sb)
d306 8
a313 9
	int error;

	while (sb->sb_flags & SB_LOCK) {
		sb->sb_flags |= SB_WANT;
		error = tsleep((caddr_t)&sb->sb_flags,
		    (sb->sb_flags & SB_NOINTR) ? PSOCK : PSOCK|PCATCH,
		    netio, 0, 0);
		if (error)
			return (error);
a314 2
	sb->sb_flags |= SB_LOCK;
	return (0);
d318 1
a318 1
 * Wakeup processes waiting on a socket buffer.
a321 1
void
d324 1
a324 1
	register struct sockbuf *sb;
d326 1
a326 1
	struct proc *p;
d334 1
a334 1
	 * pgid is coded as socket descriptor + 1: use
d340 1
a340 1
		   ((so->so_pgid < 0) ? -(so->so_pgid) : so->so_pgid) - 1);
d343 1
a343 10
	selwakeup(&sb->sb_sel);
	sb->sb_flags &= ~SB_SEL;
	if (sb->sb_flags & SB_WAIT) {
		sb->sb_flags &= ~SB_WAIT;
		wakeup((caddr_t)&sb->sb_cc);
	}
	/*
	 * Under RISC OS, it is important not to send "signals" for sockets
	 * with no socket number
	 */
d346 1
a346 1
		if (DODEBUG(DBGSOCKIP))
d348 1
a348 1
			   (so->so_pgid < 0) ? 'g' : 'p');
d351 3
a353 3
		if (so->so_pgid < 0)
			gsignal(-so->so_pgid, SIGIO);
		else if (so->so_pgid > 0 && (p = pfind(so->so_pgid)) != 0)
d358 1
a358 2
int
sorxdirect(so, m, sa, laddr, esrc, unit, swinum)
a366 1
#ifdef QuickMNSAcks
a367 1
#endif
d371 1
a371 2
		if (so->so_pgid > 0 && (p = pfind(so->so_pgid)) != 0) {
#ifdef QuickMNSAcks
a373 3
#else
			esrc = 0;
#endif
d413 1
a413 1
 * field.  Records are chained together with the m_nextpkt field. The upper
a433 1
int
d438 2
a439 15

	if (sbreserve(&so->so_snd, sndcc) == 0)
		goto bad;
	if (sbreserve(&so->so_rcv, rcvcc) == 0)
		goto bad2;
	if (so->so_rcv.sb_lowat == 0)
		so->so_rcv.sb_lowat = 1;
	if (so->so_snd.sb_lowat == 0)
#ifdef __riscos
		so->so_snd.sb_lowat = 1024;
#else
		so->so_snd.sb_lowat = MCLBYTES;
#endif
	if (so->so_snd.sb_lowat > so->so_snd.sb_hiwat)
		so->so_snd.sb_lowat = so->so_snd.sb_hiwat;
a440 4
bad2:
	sbrelease(&so->so_snd);
bad:
	return (ENOBUFS);
d444 1
a444 3
 * Allot mbufs to a sockbuf.
 * Attempt to scale mbmax so that mbcnt doesn't become limiting
 * if buffering efficiency is near the normal case.
a445 1
int
d450 1
a450 7

	if (cc > sb_max)
		return (0);
	sb->sb_hiwat = cc;
	sb->sb_mbmax = min(cc * sb_efficiency, sb_max);
	if (sb->sb_lowat > sb->sb_hiwat)
		sb->sb_lowat = sb->sb_hiwat;
d455 1
a455 1
 * Free mbufs held by a socket, and reserved mbuf space.
a456 1
void
d470 1
a470 1
 * append new mbufs to a socket buffer, after checking that adequate
d472 1
a472 1
 * of data to be added.	sbappendrecord() differs from sbappend() in
d480 1
a480 1
 * Each fails if there is not enough space, or if it cannot find mbufs
a495 1
void
d504 5
a508 10
	n = sb->sb_mb;
	if (n) {
		while (n->m_nextpkt)
			n = n->m_nextpkt;
		do {
			if (n->m_flags & M_EOR) {
				sbappendrecord(sb, m); /* XXXXXX!!!! */
				return;
			}
		} while (n->m_next && (n = n->m_next));
a510 3
#ifdef SOCKBUF_DEBUG
	sbcheck(sb);
#endif
a512 26
#ifdef SOCKBUF_DEBUG
void
sbcheck(sb)
	register struct sockbuf *sb;
{
	register struct mbuf *m;
	register int len = 0, mbcnt = 0;

	for (m = sb->sb_mb; m; m = m->m_next) {
		len += m->m_len;
		mbcnt += m->m_inilen;
#ifndef __riscos
		if (m->m_flags & M_EXT)
			mbcnt += m->m_ext.ext_size;
#endif
		if (m->m_nextpkt)
			panic("sbcheck nextpkt");
	}
	if (len != sb->sb_cc || mbcnt != sb->sb_mbcnt) {
		Printf("cc %d != %d || mbcnt %d != %d\n", len, sb->sb_cc,
		    mbcnt, sb->sb_mbcnt);
		panic("sbcheck");
	}
}
#endif

a516 1
void
d525 3
a527 4
	m = sb->sb_mb;
	if (m)
		while (m->m_nextpkt)
			m = m->m_nextpkt;
d534 1
a534 1
		m->m_nextpkt = m0;
a538 54
	if (m && (m0->m_flags & M_EOR)) {
		m0->m_flags &= ~M_EOR;
		m->m_flags |= M_EOR;
	}
	sbcompress(sb, m, m0);
#ifdef SOCKBUF_DEBUG
	sbcheck(sb);
#endif
}

#ifndef __riscos /* Not used anywhere! */
/*
 * As above except that OOB data
 * is inserted at the beginning of the sockbuf,
 * but after any other OOB data.
 */
void
sbinsertoob(sb, m0)
	register struct sockbuf *sb;
	register struct mbuf *m0;
{
	register struct mbuf *m;
	register struct mbuf **mp;

	if (m0 == 0)
		return;
	for (mp = &sb->sb_mb; *mp ; mp = &((*mp)->m_nextpkt)) {
	    m = *mp;
	    again:
		switch (m->m_type) {

		case MT_OOBDATA:
			continue;		/* WANT next train */

		case MT_CONTROL:
			m = m->m_next;
			if (m)
				goto again;	/* inspect THIS train further */
		}
		break;
	}
	/*
	 * Put the first mbuf on the queue.
	 * Note this permits zero length records.
	 */
	sballoc(sb, m0);
	m0->m_nextpkt = *mp;
	*mp = m0;
	m = m0->m_next;
	m0->m_next = 0;
	if (m && (m0->m_flags & M_EOR)) {
		m0->m_flags &= ~M_EOR;
		m->m_flags |= M_EOR;
	}
a540 1
#endif
d543 3
a545 4
 * Append address and data, and optionally, control (ancillary) data
 * to the receive queue of a socket.  If present,
 * m0 must include a packet header with total length.
 * Returns 0 if no space in sockbuf or insufficient mbufs.
d547 1
a547 2
int
sbappendaddr(sb, asa, m0, control)
d550 1
a550 1
	struct mbuf *m0, *control;
a552 1
	int space = asa->sa_len;
d554 3
a556 12
if (m0 && (m0->m_flags & M_PKTHDR) == 0) {
panic("sbappendaddr");
return (0);
}
	if (m0)
		space += m0->m_pkthdr.len;
	for (n = control; n; n = n->m_next) {
		space += n->m_len;
		if (n->m_next == 0)	/* keep pointer to last control buf */
			break;
	}
	if (space > sbspace(sb))
d558 3
a560 4
	if (asa->sa_len > MINCONTIG)
		return (0);
	MGET(m, M_DONTWAIT, MT_SONAME);
	if (m == 0) {
d562 2
a563 2
		if (DODEBUG(DBGMMAN))
			Printf("sbappendaddr: ALLOC_S failed\n");
d565 1
a565 1
		return (0);
d567 11
a577 14
	m->m_len = asa->sa_len;
	bcopy((caddr_t)asa, mtod(m, caddr_t), asa->sa_len);
	if (n)
		n->m_next = m0;		/* concatenate data to control */
	else
		control = m0;
	m->m_next = control;
#ifdef SOCKBUF_DEBUG
        Printf("sballocing: sb=%x, sb->sb_cc=%d, sb->sb_mbcnt=%d\n", sb, sb->sb_cc, sb->sb_mbcnt);
	for (n = m; n; n = n->m_next) {
	        Printf("sballocing: adding n=%x, n->m_len=%d, n->m_inilen=%d\n", n, n->m_len, n->m_inilen);
		sballoc(sb, n);
	}
        Printf("sballoced:  sb=%x, sb->sb_cc=%d, sb->sb_mbcnt=%d\n", sb, sb->sb_cc, sb->sb_mbcnt);
d579 9
a587 2
	for (n = m; n; n = n->m_next)
		sballoc(sb, n);
d589 7
a595 5
	n = sb->sb_mb;
	if (n) {
		while (n->m_nextpkt)
			n = n->m_nextpkt;
		n->m_nextpkt = m;
d598 4
a601 3
#ifdef SOCKBUF_DEBUG
	sbcheck(sb);
#endif
d605 1
a605 2
int
sbappendcontrol(sb, m0, control)
d607 1
a607 1
	struct mbuf *control, *m0;
a609 1
	int space = 0;
d611 2
a612 2
	if (control == 0) {
		panic("sbappendcontrol");
d615 3
a617 9
	for (m = control; ; m = m->m_next) {
		space += m->m_len;
		if (m->m_next == 0)
			break;
	}
	n = m;			/* save pointer to last control buffer */
	for (m = m0; m; m = m->m_next)
		space += m->m_len;
	if (space > sbspace(sb))
d619 9
a627 8
	n->m_next = m0;			/* concatenate data to control */
	for (m = control; m; m = m->m_next)
		sballoc(sb, m);
	n = sb->sb_mb;
	if (n) {
		while (n->m_nextpkt)
			n = n->m_nextpkt;
		n->m_nextpkt = control;
d629 3
a631 1
		sb->sb_mb = control;
a639 1
void
a643 2
	register int eor = 0;
	register struct mbuf *o;
d646 8
a653 6
		eor |= m->m_flags & M_EOR;
		if (m->m_len == 0 &&
		    (eor == 0 ||
		     (((o = m->m_next) || (o = n)) &&
		      o->m_type == m->m_type))) {
			m = m_freen(m);
d656 2
a657 2
		if (n && (n->m_flags & M_EOR) == 0 &&
		    (n->m_off + n->m_len + m->m_len) < MAXOFF(n) &&
d663 9
a671 1
			m = m_freen(m);
d674 1
a678 1
		sballoc(sb, m);
a679 1
		m->m_flags &= ~M_EOR;
a682 6
	if (eor) {
		if (n)
			n->m_flags |= eor;
		else
			printf("semi-panic: sbcompress\n");
	}
a688 1
void
d699 1
a699 1
	if (sb->sb_cc || sb->sb_mb)
a705 1
void
d713 1
a713 1
	next = (m = sb->sb_mb) ? m->m_nextpkt : 0;
d721 1
a721 1
			next = m->m_nextpkt;
d742 1
a742 1
		m->m_nextpkt = next;
a750 1
void
d758 1
a758 1
		sb->sb_mb = m->m_nextpkt;
d762 1
a762 2
			m = mn;
		} while (m);
d765 2
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@

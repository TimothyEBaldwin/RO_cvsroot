head	4.6;
access;
symbols
	Internet-5_65:4.6
	Internet-5_64:4.6
	Internet-5_63:4.6
	Internet-5_62:4.6
	Internet-5_61:4.6
	Internet-5_60:4.6
	Internet-5_59:4.6
	Internet-5_58:4.6
	Internet-5_57:4.6
	Internet-5_56:4.6
	Internet-5_55:4.6
	Internet-5_54:4.6
	Internet-5_53:4.6
	Internet-5_52:4.6
	Internet-5_51:4.6
	Internet-5_50:4.6
	RO_5_07:4.6
	Internet-5_49:4.6
	Internet-5_48:4.6
	Internet-5_47:4.6
	Internet-5_46:4.6
	Internet-5_45:4.6
	Internet-5_44:4.6
	Internet-5_43:4.6
	Internet-5_42:4.6
	Internet-5_41:4.6
	Internet-5_40:4.6
	Internet-5_39:4.5
	Internet-5_38:4.5
	Internet-5_37:4.5
	Internet-5_36:4.5
	Internet-5_35:4.5
	Internet-5_34:4.5
	Internet-5_33:4.5
	Internet-5_32:4.5
	Internet-5_31:4.5
	Internet-5_30:4.4
	Internet-5_29:4.4
	Internet-5_27:4.3
	Internet-5_26:4.3
	Internet-5_25:4.3
	Internet-5_24:4.3
	Internet-5_23:4.3
	Internet-5_22:4.3
	Internet-5_21:4.3
	Internet-5_20:4.3
	Internet-5_19:4.3
	Internet-5_18:4.3
	Internet-5_17:4.3
	Internet-5_16:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3
	Ursula_RiscPC:4.3.0.4
	Internet-5_15:4.3
	Internet-5_14:4.3
	Internet-5_13:4.3
	sforrest_daytona_appflash-0_31:4.3
	Internet-5_12:4.3
	Internet-5_11:4.3
	celkins_Internet-5_10:4.3
	nicke_Internat_25-9-98:4.3
	Internet-5_09:4.3
	blaughto_daytona_appflash-0_30:4.3
	rthornb_UrsulaBuild-19Aug1998:4.3
	UrsulaBuild_FinalSoftload:4.3
	rthornb_UrsulaBuild-12Aug1998:4.3
	aglover_UrsulaBuild-05Aug1998:4.3
	rthornb_UrsulaBuild-29Jul1998:4.3
	rthornb_UrsulaBuild-22Jul1998:4.3
	rwarren_Internet-5_08:4.3
	Spinner:4.3
	Internet_5_07:4.3
	rthornb_UrsulaBuild-15Jul1998:4.3
	rthornb_UrsulaBuild-07Jul1998:4.3
	rthornb_UrsulaBuild-17Jun1998:4.3
	rthornb_UrsulaBuild-03Jun1998:4.3
	rthornb_UrsulaBuild-27May1998:4.3
	rthornb_UrsulaBuild-21May1998:4.3
	Ursula_bp:4.3
	Ursula:4.3.0.2
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.3
	afrost_NC2_Generic:4.1.4.1
	afrost_Funai01-33:4.1.4.1
	Internet_505:4.3
	Spin_old:4.1.7
	Spinner_RCA116:4.1.4.1
	Spinner_B20_2:4.1.4.1
	Spinner_19_3:4.1.4.1
	Spinner_B18:4.1.4.1
	Spinner_B17:4.1.4.1
	Spinner_B15:4.1.4.1
	Spinner_B14:4.1.4.1
	Spinner_B13:4.1.4.1
	Spinner_B12:4.1.4.1
	Spinner_B10:4.1.4.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Spin_merge_12May97:4.1.7.2
	Spinner_B7:4.1.4.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	nturton_inet_4_9:4.1.7.3
	nturton_inet_4_8:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.4.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2000.03.06.16.48.04;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.07.13.11.13.09;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.07.08.15.25.50;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.03.27.12.36.42;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.12.22.59.14;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.12;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.28.12;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.20.38;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.30.49;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.04.11.10.07.14;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.22.14.56.45;	author nturton;	state Exp;
branches;
next	4.1.5.2;

4.1.5.2
date	96.11.25.15.07.15;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.59.57;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.02.20.39.01;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.09.15.27.36;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@  Fixed a 144-byte RMA leak occurring on every socket creation.
Detail:
  Bug was introduced by a faulty merge of new FreeBSD stuff in version
  5.31 (13 Jul 1999).

Version 5.40. Tagged as 'Internet-5_40'
@
text
@/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <string.h>

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/kernel.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#ifndef __riscos
#include <sys/resourcevar.h>
#endif
#include <sys/signalvar.h>
#ifndef __riscos
#include <sys/sysctl.h>
#endif

#include "svcdebug.h"
#include "debug.h"
#include "module.h"

so_gen_t	so_gencnt;	/* generation count for sockets */

static int somaxconn = SOMAXCONN;
#ifdef NotYet
SYSCTL_INT(_kern, KERN_SOMAXCONN, somaxconn, CTLFLAG_RW, &somaxconn, 0, "");
#endif

/*
 * Socket operation routines.
 * These routines are called by the routines in
 * sys_socket.c or from a system process, and
 * implement the semantics of socket operations by
 * switching out to the protocol specific routines.
 *
 */

/*
 * Get a socket structure from our zone, and initialize it.
 * We don't implement `waitok' yet (see comments in uipc_domain.c).
 * Note that it would probably be better to allocate socket
 * and PCB at the same time, but I'm not convinced that all
 * the protocols can be easily modified to do this.
 */
struct socket *
soalloc(waitok)
	int waitok;
{
	struct socket *so;

#if 0
	so = zalloci(socket_zone);
#else
	MALLOC(so, struct socket *, sizeof(*so), M_SOCKET, M_WAIT);
#endif
	if (so) {
		/* XXX race condition for reentrant kernel */
		bzero(so, sizeof *so);
		so->so_gencnt = ++so_gencnt;
#ifndef __riscos
		so->so_zone = socket_zone;
#endif
	}
	return so;
}

/*ARGSUSED*/
int
socreate(dom, aso, type, proto)
	int dom;
	struct socket **aso;
	register int type;
	int proto;
{
	register struct protosw *prp;
	register struct socket *so;
	register int error;

	if (proto)
		prp = pffindproto(dom, proto, type);
	else
		prp = pffindtype(dom, type);
	if (prp == 0 || prp->pr_usrreq == 0)
		return (EPROTONOSUPPORT);
	if (prp->pr_type != type)
		return (EPROTOTYPE);
	so = soalloc(0);
	if (so == 0)
		return (ENOBUFS);
	bzero((caddr_t)so, sizeof(*so));
	so->so_type = type;
        //so->so_options |= SO_DEBUG;
#ifndef __riscos
	if (p->p_ucred->cr_uid == 0)
#endif
		so->so_state = SS_PRIV;
	so->so_proto = prp;
	error =
	    (*prp->pr_usrreq)(so, PRU_ATTACH,
		(struct mbuf *)0, (struct mbuf *)proto, (struct mbuf *)0);
	if (error) {
		so->so_state |= SS_NOFDREF;
		sofree(so);
		return (error);
	}
	*aso = so;
	return (0);
}

int
sobind(so, nam)
	struct socket *so;
	struct mbuf *nam;
{
	int error;

	error =
	    (*so->so_proto->pr_usrreq)(so, PRU_BIND,
		(struct mbuf *)0, nam, (struct mbuf *)0);
	return (error);
}

void
sodealloc(so)
	struct socket *so;
{
	so->so_gencnt = ++so_gencnt;
#ifdef __riscos
	FREE(so, M_SOCKET);
#else
	if (so->so_cred && --so->so_cred->p_refcnt == 0) {
		crfree(so->so_cred->pc_ucred);
		FREE(so->so_cred, M_SUBPROC);
	}
	zfreei(so->so_zone, so);
#endif
}

int
solisten(so, backlog)
	register struct socket *so;
	int backlog;
{
	int error;

	error =
	    (*so->so_proto->pr_usrreq)(so, PRU_LISTEN,
		(struct mbuf *)0, (struct mbuf *)0, (struct mbuf *)0);
	if (error) {
		return (error);
	}
	if (so->so_q == 0)
		so->so_options |= SO_ACCEPTCONN;
	if (backlog < 0 || backlog > somaxconn)
		backlog = somaxconn;
	so->so_qlimit = backlog;
	return (0);
}

void
sofree(so)
	register struct socket *so;
{

	if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
		return;
	if (so->so_head) {
		if (!soqremque(so, 0) && !soqremque(so, 1)) {
			panic("sofree dq");
			return;
		}
		so->so_head = 0;
	}
	sbrelease(&so->so_snd);
	sorflush(so);
	sodealloc(so);
}

/*
 * Close a socket on last file table reference removal.
 * Initiate disconnect if connected.
 * Free socket when disconnect complete.
 */
int
soclose(so)
	register struct socket *so;
{
	int error = 0;

	if (so->so_options & SO_ACCEPTCONN) {
		while (so->so_q0)
			(void) soabort(so->so_q0);
		while (so->so_q)
			(void) soabort(so->so_q);
	}
	if (so->so_pcb == 0)
		goto discard;
	if (so->so_state & SS_ISCONNECTED) {
		if ((so->so_state & SS_ISDISCONNECTING) == 0) {
			error = sodisconnect(so);
			if (error)
				goto drop;
		}
		if (so->so_options & SO_LINGER) {
			if ((so->so_state & SS_ISDISCONNECTING) &&
			    (so->so_state & SS_NBIO))
				goto drop;
			while (so->so_state & SS_ISCONNECTED) {
				error = tsleep((caddr_t)&so->so_timeo,
				    PSOCK | PCATCH, "soclos", so->so_linger,
				    so->so_state & SS_SLEEPTW);
				if (error)
					break;
			}
		}
	}
drop:
	if (so->so_pcb) {
		int error2 =
		    (*so->so_proto->pr_usrreq)(so, PRU_DETACH,
			(struct mbuf *)0, (struct mbuf *)0, (struct mbuf *)0);
		if (error == 0)
			error = error2;
	}
discard:
	if (so->so_state & SS_NOFDREF) {
		panic("soclose: NOFDREF");
		return (EFAULT);
	}
	so->so_state |= SS_NOFDREF;
	sofree(so);
	return (error);
}

/*
 * Must be called at splnet...
 */
int
soabort(so)
	struct socket *so;
{

	return (
	    (*so->so_proto->pr_usrreq)(so, PRU_ABORT,
		(struct mbuf *)0, (struct mbuf *)0, (struct mbuf *)0));
}

int
soaccept(so, nam)
	register struct socket *so;
	struct mbuf *nam;
{
	int error;

	if ((so->so_state & SS_NOFDREF) == 0) {
		panic("soaccept: !NOFDREF");
		return (EFAULT);
	}
	so->so_state &= ~SS_NOFDREF;
	error = (*so->so_proto->pr_usrreq)(so, PRU_ACCEPT,
	    (struct mbuf *)0, nam, (struct mbuf *)0);
	return (error);
}

int
soconnect(so, nam)
	register struct socket *so;
	struct mbuf *nam;
{
	int error;

	if (so->so_options & SO_ACCEPTCONN)
		return (EOPNOTSUPP);
	/*
	 * If protocol is connection-based, can only connect once.
	 * Otherwise, if connected, try to disconnect first.
	 * This allows user to disconnect by connecting to, e.g.,
	 * a null address.
	 */
	if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
	    ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
	    (error = sodisconnect(so))))
		error = EISCONN;
	else
		error = (*so->so_proto->pr_usrreq)(so, PRU_CONNECT,
		    (struct mbuf *)0, nam, (struct mbuf *)0);
	return (error);
}

int
soconnect2(so1, so2)
	register struct socket *so1;
	struct socket *so2;
{
	int error;

	error = (*so1->so_proto->pr_usrreq)(so1, PRU_CONNECT2,
	    (struct mbuf *)0, (struct mbuf *)so2, (struct mbuf *)0);
	return (error);
}

int
sodisconnect(so)
	register struct socket *so;
{
	int error;

	if ((so->so_state & SS_ISCONNECTED) == 0) {
		error = ENOTCONN;
		goto bad;
	}
	if (so->so_state & SS_ISDISCONNECTING) {
		error = EALREADY;
		goto bad;
	}
	error = (*so->so_proto->pr_usrreq)(so, PRU_DISCONNECT,
	    (struct mbuf *)0, (struct mbuf *)0, (struct mbuf *)0);
bad:
	return (error);
}


#define	SBLOCKWAIT(f)	(((f) & MSG_DONTWAIT) ? M_NOWAIT : M_WAITOK)
/*
 * Send on a socket.
 * If send must go all at once and message is larger than
 * send buffering, then hard error.
 * Lock against other senders.
 * If must go all at once and not enough room now, then
 * inform user that this would block and do nothing.
 * Otherwise, if nonblocking, send as much as possible.
 * The data to be sent is described by "uio" if nonzero,
 * otherwise by the mbuf chain "top" (which must be null
 * if uio is not).  Data provided in mbuf chain must be small
 * enough to send all at once.
 *
 * Returns nonzero on error, timeout or signal; callers
 * must check for short counts if EINTR/ERESTART are returned.
 * Data and control buffers are freed on return.
 */
int
sosend(so, addr, uio, top, control, flags)
	register struct socket *so;
	struct mbuf *addr;
	struct uio *uio;
	struct mbuf *top;
	struct mbuf *control;
	int flags;
{
#ifndef __riscos
	struct proc *p = curproc;		/* XXX */
#endif
	struct mbuf **mp;
	register struct mbuf *m;
	register long space, len, resid;
	int clen = 0, error, dontroute, mlen;
	int atomic = sosendallatonce(so) || top;

	if (uio)
		resid = uio->uio_resid;
	else
		resid = top->m_pkthdr.len;
	/*
	 * In theory resid should be unsigned.
	 * However, space must be signed, as it might be less than 0
	 * if we over-committed, and we must use a signed comparison
	 * of space and resid.  On the other hand, a negative resid
	 * causes us to loop sending 0-length segments to the protocol.
	 */
	if (resid < 0)
		return (EINVAL);
	dontroute =
	    (flags & MSG_DONTROUTE) && (so->so_options & SO_DONTROUTE) == 0 &&
	    (so->so_proto->pr_flags & PR_ATOMIC);
#ifndef __riscos
	p->p_stats->p_ru.ru_msgsnd++;
#endif
	if (control)
		clen = control->m_len;
#define	snderr(errno)	{ error = errno; goto release; }

	/* TRACE */
#ifdef DEBUG
	if( DODEBUG(DBGOUTPUT) )
	    Printf("sosend: type = %d\n", so->so_type);
#endif
#ifdef __riscos
/* KJB - believed to be unsafe in boundary conditions, such as sending
 * more than the available buffer space. Disabled for now
 */
#if 0
	/*
	 * Super-hack that saves a data copy using unsafe mbufs. This relies
	 * on
	 *      1) UDP being the only SOCK_DGRAM protocol
	 *      2) IP ensuring_safe anything it doesn't send straight to the
	 *         driver (ie when waiting for ARP resolution)
	 */
	if (so->so_type == SOCK_DGRAM) {
		struct iovec *iov;

		if (so->so_state & SS_CANTSENDMORE)
			snderr(EPIPE);
		if (so->so_error)
		    	snderr(so->so_error);
		if ((so->so_state & SS_ISCONNECTED) == 0) {
			if (so->so_proto->pr_flags & PR_CONNREQUIRED)
				  snderr(ENOTCONN);
			if (addr == 0)
				  snderr(EDESTADDRREQ);
		}
		error = sblock(&so->so_snd, SBLOCKWAIT(flags));
		if (error)
			goto out;
		mp = &top;
		while (uio->uio_iovcnt > 0)
		{
		    iov = uio->uio_iov;

		    if ((m = ALLOC_U(iov->iov_len, iov->iov_base)) == NULL) {
#ifdef DEBUG
			if ( DODEBUG(DBGMMAN))
			    Printf("\021\01sosend: ALLOC_U failed\n");
#endif
			error = ENOBUFS;
			goto release;
		    }
		    m->m_type = MT_DATA;

		    *mp = m;
		    mp = &m->m_next;
		    uio->uio_iov++;
		    uio->uio_iovcnt--;
		}
		top->m_flags = M_PKTHDR;
		top->m_pkthdr.len = resid;
		top->m_pkthdr.rcvif = (struct ifnet *)0;
		if (dontroute)
			so->so_options |= SO_DONTROUTE;
		error = (*so->so_proto->pr_usrreq)(so,
			(flags & MSG_OOB) ? PRU_SENDOOB : PRU_SEND,
			top, addr, control);
		if (dontroute)
			so->so_options &= ~SO_DONTROUTE;
		top = 0;
		uio->uio_resid = 0;
		goto release;
	}
#endif
#endif
restart:
	error = sblock(&so->so_snd, SBLOCKWAIT(flags));
	if (error)
		goto out;
	do {
		if (so->so_state & SS_CANTSENDMORE)
			snderr(EPIPE);
		if (so->so_error)
		    	snderr(so->so_error);
		if ((so->so_state & SS_ISCONNECTED) == 0) {
			/*
			 * `sendto' and `sendmsg' is allowed on a connection-
			 * based socket if it supports implied connect.
			 * Return ENOTCONN if not connected and no address is
			 * supplied.
			 */
			if ((so->so_proto->pr_flags & PR_CONNREQUIRED) &&
			    (so->so_proto->pr_flags & PR_IMPLOPCL) == 0) {
				if ((so->so_state & SS_ISCONFIRMING) == 0 &&
				    !(resid == 0 && clen != 0))
					snderr(ENOTCONN);
			} else if (addr == 0)
			    snderr(so->so_proto->pr_flags & PR_CONNREQUIRED ?
				   ENOTCONN : EDESTADDRREQ);
		}
		space = sbspace(&so->so_snd);
		if (flags & MSG_OOB)
			space += 1024;
		if ((atomic && resid > so->so_snd.sb_hiwat) ||
		    clen > so->so_snd.sb_hiwat)
			snderr(EMSGSIZE);
		if (space < resid + clen && uio &&
		    (atomic || space < so->so_snd.sb_lowat || space < clen)) {
			if (so->so_state & SS_NBIO)
				snderr(EWOULDBLOCK);
			sbunlock(&so->so_snd);
			error = sbwait(&so->so_snd, so->so_state & SS_SLEEPTW);
			if (error)
				goto out;
			goto restart;
		}
		mp = &top;
		space -= clen;
		do {
		    if (uio == NULL) {
			/*
			 * Data is prepackaged in "top".
			 */
			resid = 0;
			if (flags & MSG_EOR)
				top->m_flags |= M_EOR;
		    } else {
		        len = min(resid, space);
			top = ALLOC(len, NULL);
			if (top == 0) {
				m_reclaim();
				top = ALLOC(len, NULL);
				if (top == 0)
					snderr(ENOBUFS);
			}
			top->m_flags = M_PKTHDR;
			top->m_pkthdr.len = len;
			top->m_pkthdr.rcvif = (struct ifnet *)0;
			/*
			 * For datagram protocols, leave room
			 * for protocol headers in first mbuf.
			 */
			if (atomic && len < MLEN(top))
				MH_ALIGN(top, len);
			space -= len;
			for (m = top; m; m = m->m_next) {
				m->m_type = MT_DATA;
				mlen = min(len, MLEN(m));
				uiomove(mtod(m, caddr_t), (int)mlen, uio);
				m->m_len = mlen;
				len -= mlen;
			}
			resid = uio->uio_resid;
			if (resid <= 0)
				if (flags & MSG_EOR)
					top->m_flags |= M_EOR;
		    }
		    if (dontroute)
			    so->so_options |= SO_DONTROUTE;
		    error = (*so->so_proto->pr_usrreq)(so,
			(flags & MSG_OOB) ? PRU_SENDOOB :
			/*
			 * If the user set MSG_EOF, the protocol
			 * understands this flag and nothing left to
			 * send then use PRU_SEND_EOF instead of PRU_SEND.
			 */
			((flags & MSG_EOF) &&
			 (so->so_proto->pr_flags & PR_IMPLOPCL) &&
			 (resid <= 0)) ?
				PRU_SEND_EOF : PRU_SEND,
			top, addr, control);
		    if (dontroute)
			    so->so_options &= ~SO_DONTROUTE;
		    clen = 0;
		    control = 0;
		    top = 0;
		    if (error)
			goto release;
		} while (resid && space > 0);
	} while (resid);

release:
	sbunlock(&so->so_snd);
out:
	if (top)
	    	m_freem(top);
	if (control)
		m_freem(control);
	return(error);
}

/*
 * Implement receive operations on a socket.
 * We depend on the way that records are added to the sockbuf
 * by sbappend*.  In particular, each record (mbufs linked through m_next)
 * must begin with an address if the protocol so specifies,
 * followed by an optional mbuf or mbufs containing ancillary data,
 * and then zero or more mbufs of data.
 * In order to avoid blocking network interrupts for the entire time here,
 * we splx() while doing the actual copy to user space.
 * Although the sockbuf is locked, new data may still be appended,
 * and thus we must maintain consistency of the sockbuf during that time.
 *
 * The caller may receive the data as a single mbuf chain by supplying
 * an mbuf **mp0 for use in returning the chain.  The uio is then used
 * only for the count in uio_resid.
 */
int
soreceive(so, paddr, uio, mp0, controlp, flagsp)
	register struct socket *so;
	struct mbuf **paddr;
	struct uio *uio;
	struct mbuf **mp0;
	struct mbuf **controlp;
	int *flagsp;
{
	register struct mbuf *m, **mp;
	register int flags, len, error, offset;
	struct protosw *pr = so->so_proto;
	struct mbuf *nextrecord;
	int moff, type = 0;
	int orig_resid = uio->uio_resid;

#ifdef DEBUG2
        Printf("soreceive(): so=%x, &so->so_rcv=%x, so->so_rcv.sb_cc=%d, &so->so_snd=%x\n",
                so, &so->so_rcv, so->so_rcv.sb_cc, &so->so_snd);
#endif
	mp = mp0;
	if (paddr)
		*paddr = 0;
	if (controlp)
		*controlp = 0;
	if (flagsp)
		flags = *flagsp &~ MSG_EOR;
	else
		flags = 0;
	if (flags & MSG_OOB) {
		m = m_get(M_WAIT, MT_DATA);
		if (m == NULL) {
		    	error=ENOBUFS;
		    	goto bad;
		}
		error = (*pr->pr_usrreq)(so, PRU_RCVOOB,
		    m, (struct mbuf *)(flags & MSG_PEEK), (struct mbuf *)0);
		if (error)
			goto bad;
		do {
			error = uiomove(mtod(m, caddr_t),
			    (int) min(uio->uio_resid, m->m_len), uio);
			m = m_freen(m);
		} while (uio->uio_resid && error == 0 && m);
bad:
		if (m)
			m_freem(m);
		return (error);
	}
	if (mp)
		*mp = (struct mbuf *)0;
	if (so->so_state & SS_ISCONFIRMING && uio->uio_resid)
		(*pr->pr_usrreq)(so, PRU_RCVD, (struct mbuf *)0,
		    (struct mbuf *)0, (struct mbuf *)0);

restart:
	error = sblock(&so->so_rcv, SBLOCKWAIT(flags));
	if (error)
		return (error);

	m = so->so_rcv.sb_mb;
	/*
	 * If we have less data than requested, block awaiting more
	 * (subject to any timeout) if:
	 *   1. the current count is less than the low water mark, or
	 *   2. MSG_WAITALL is set, and it is possible to do the entire
	 *	receive operation at once if we block (resid <= hiwat).
	 *   3. MSG_DONTWAIT is not set
	 * If MSG_WAITALL is set but resid is larger than the receive buffer,
	 * we have to do the receive in sections, and thus risk returning
	 * a short count if a timeout or signal occurs after we start.
	 */

	if (m == 0 || (((flags & MSG_DONTWAIT) == 0 &&
	    so->so_rcv.sb_cc < uio->uio_resid) &&
	    (so->so_rcv.sb_cc < so->so_rcv.sb_lowat ||
	    ((flags & MSG_WAITALL) && uio->uio_resid <= so->so_rcv.sb_hiwat)) &&
	    m->m_nextpkt == 0 && (pr->pr_flags & PR_ATOMIC) == 0)) {
#ifdef DIAGNOSTIC
		if (m == 0 && so->so_rcv.sb_cc) {
			panic("receive 1");
			return (EFAULT);
		}
#endif
		if (so->so_error) {
			if (m)
				goto dontblock;
			error = so->so_error;
			if ((flags & MSG_PEEK) == 0)
				so->so_error = 0;
			goto release;
		}
		if (so->so_state & SS_CANTRCVMORE) {
			if (m)
				goto dontblock;
			else
				goto release;
		}
		for (; m; m = m->m_next)
			if (m->m_type == MT_OOBDATA  || (m->m_flags & M_EOR)) {
				m = so->so_rcv.sb_mb;
				goto dontblock;
			}
		if ((so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING)) == 0 &&
		    (so->so_proto->pr_flags & PR_CONNREQUIRED)) {
			error = ENOTCONN;
			goto release;
		}
		if (uio->uio_resid == 0)
			goto release;
		if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT)) {
			error = EWOULDBLOCK;
#if 0
                        Printf("soreceive: returning EWOULDBLOCK; so->so_rcv.sb_cc=%d, so->so_rcv.sb_lowat=%d\n", so->so_rcv.sb_cc, so->so_rcv.sb_lowat);
#endif
			goto release;
		}
		sbunlock(&so->so_rcv);
		error = sbwait(&so->so_rcv, so->so_state & SS_SLEEPTW);
		if (error)
			return (error);
		goto restart;
	}
dontblock:
#ifndef __riscos
	if (uio->uio_procp)
		uio->uio_procp->p_stats->p_ru.ru_msgrcv++;
#endif
	nextrecord = m->m_nextpkt;
	if (pr->pr_flags & PR_ADDR) {
#ifdef DIAGNOSTIC
		if (m->m_type != MT_SONAME) {
			panic("receive 1a");
			return (EFAULT);
		}
#endif
		orig_resid = 0;
		if (flags & MSG_PEEK) {
			if (paddr)
				*paddr = m_copy(m, 0, m->m_len);
			m = m->m_next;
		} else {
			sbfree(&so->so_rcv, m);
			if (paddr) {
				*paddr = m;
				so->so_rcv.sb_mb = m->m_next;
				m->m_next = 0;
				m = so->so_rcv.sb_mb;
			} else {
				MFREE(m, so->so_rcv.sb_mb);
				m = so->so_rcv.sb_mb;
			}
		}
	}
	while (m && m->m_type == MT_CONTROL && error == 0) {
		if (flags & MSG_PEEK) {
			if (controlp)
				*controlp = m_copy(m, 0, m->m_len);
			m = m->m_next;
		} else {
			sbfree(&so->so_rcv, m);
			if (controlp) {
				if (pr->pr_domain->dom_externalize &&
				    mtod(m, struct cmsghdr *)->cmsg_type ==
				    SCM_RIGHTS)
				   error = (*pr->pr_domain->dom_externalize)(m);
				*controlp = m;
				so->so_rcv.sb_mb = m->m_next;
				m->m_next = 0;
				m = so->so_rcv.sb_mb;
			} else {
				MFREE(m, so->so_rcv.sb_mb);
				m = so->so_rcv.sb_mb;
			}
		}
		if (controlp) {
			orig_resid = 0;
			controlp = &(*controlp)->m_next;
		}
	}
	if (m) {
		if ((flags & MSG_PEEK) == 0)
			m->m_nextpkt = nextrecord;
		type = m->m_type;
		if (type == MT_OOBDATA)
			flags |= MSG_OOB;
	}
	moff = 0;
	offset = 0;
	while (m && uio->uio_resid > 0 && error == 0) {
		if (m->m_type == MT_OOBDATA) {
			if (type != MT_OOBDATA)
				break;
		} else if (type == MT_OOBDATA)
			break;
#ifdef DIAGNOSTIC
		else if (m->m_type != MT_DATA && m->m_type != MT_HEADER) {
			panic("receive 3");
			return (EFAULT);
		}
#endif
		so->so_state &= ~SS_RCVATMARK;
		len = uio->uio_resid;
		if (so->so_oobmark && len > so->so_oobmark - offset)
			len = so->so_oobmark - offset;
		if (len > m->m_len - moff)
			len = m->m_len - moff;
		/*
		 * If mp is set, just pass back the mbufs.
		 * Otherwise copy them out via the uio, then free.
		 * Sockbuf must be consistent here (points to current mbuf,
		 * it points to next record) when we drop priority;
		 * we must note any additions to the sockbuf when we
		 * block interrupts again.
		 */
		if (mp == 0) {
			error = uiomove(mtod(m, caddr_t) + moff, (int)len, uio);
		} else
			uio->uio_resid -= len;
		if (len == m->m_len - moff) {
			if (m->m_flags & M_EOR)
				flags |= MSG_EOR;
			if (flags & MSG_PEEK) {
				m = m->m_next;
				moff = 0;
			} else {
				nextrecord = m->m_nextpkt;
				sbfree(&so->so_rcv, m);
				if (mp) {
					*mp = m;
					mp = &m->m_next;
					so->so_rcv.sb_mb = m = m->m_next;
					*mp = (struct mbuf *)0;
				} else {
					MFREE(m, so->so_rcv.sb_mb);
					m = so->so_rcv.sb_mb;
				}
				if (m)
					m->m_nextpkt = nextrecord;
			}
		} else {
			if (flags & MSG_PEEK)
				moff += len;
			else {
				if (mp)
					*mp = m_copym(m, 0, len, M_WAIT);
				m->m_off += len;
				m->m_len -= len;
				so->so_rcv.sb_cc -= len;
			}
		}
		if (so->so_oobmark) {
			if ((flags & MSG_PEEK) == 0) {
				so->so_oobmark -= len;
				if (so->so_oobmark == 0) {
					so->so_state |= SS_RCVATMARK;
					break;
				}
			} else {
				offset += len;
				if (offset == so->so_oobmark)
					break;
			}
		}
		if (flags & MSG_EOR)
			break;
		/*
		 * If the MSG_WAITALL flag is set (for non-atomic socket),
		 * we must not quit until "uio->uio_resid == 0" or an error
		 * termination.  If a signal/timeout occurs, return
		 * with a short count but without error.
		 * Keep sockbuf locked against other readers.
		 */
		while (flags & MSG_WAITALL && m == 0 && uio->uio_resid > 0 &&
		    !sosendallatonce(so) && !nextrecord) {
			if (so->so_error || so->so_state & SS_CANTRCVMORE)
				break;
			error = sbwait(&so->so_rcv, so->so_state & SS_SLEEPTW);
			if (error) {
				sbunlock(&so->so_rcv);
				return (0);
			}
			m = so->so_rcv.sb_mb;
			if (m)
				nextrecord = m->m_nextpkt;
		}
	}

	if (m && pr->pr_flags & PR_ATOMIC) {
		flags |= MSG_TRUNC;
		if ((flags & MSG_PEEK) == 0)
			(void) sbdroprecord(&so->so_rcv);
	}
	if ((flags & MSG_PEEK) == 0) {
		if (m == 0)
			so->so_rcv.sb_mb = nextrecord;
		if (pr->pr_flags & PR_WANTRCVD && so->so_pcb)
			(*pr->pr_usrreq)(so, PRU_RCVD, (struct mbuf *)0,
			    (struct mbuf *)flags, (struct mbuf *)0);
	}
	if (orig_resid == uio->uio_resid && orig_resid &&
	    (flags & MSG_EOR) == 0 && (so->so_state & SS_CANTRCVMORE) == 0) {
		sbunlock(&so->so_rcv);
		goto restart;
	}

	if (flagsp)
		*flagsp |= flags;
release:
	sbunlock(&so->so_rcv);
	return (error);
}

int
soshutdown(so, how)
	register struct socket *so;
	register int how;
{
	register struct protosw *pr = so->so_proto;

	how++;
	if (how & FREAD)
		sorflush(so);
	if (how & FWRITE)
		return ((*pr->pr_usrreq)(so, PRU_SHUTDOWN,
		    (struct mbuf *)0, (struct mbuf *)0, (struct mbuf *)0));
	return (0);
}

void
sorflush(so)
	register struct socket *so;
{
	register struct sockbuf *sb = &so->so_rcv;
	register struct protosw *pr = so->so_proto;
	struct sockbuf asb;

	/*
	 * 950111 KWelton
	 *
	 * Under RISC OS, locking the receive buffers here can
	 * cause a deadlock - any receive routines called from
	 * socantrcvmore() will find the receive buffer locked
	 * and the lock will never be removed.
	 *
	 * It may well be possible to remove the locks completely,
	 * but this seems a bit rash, so just don't set the locks
	 * here - there seems to be no justification for putting
	 * them in anyway (if the locks *are* needed, then they
	 * will be created at precisely the point at which the
	 * system locks up without this change.
	 */
#ifndef __riscos
	sb->sb_flags |= SB_NOINTR;
	sblock(sb, M_WAITOK);
#endif
	socantrcvmore(so);

#ifndef __riscos
	sbunlock(sb);
#endif

	asb = *sb;
	bzero((caddr_t)sb, sizeof (*sb));
	if (pr->pr_flags & PR_RIGHTS && pr->pr_domain->dom_dispose)
		(*pr->pr_domain->dom_dispose)(asb.sb_mb);
	sbrelease(&asb);
}

int
sosetopt(so, level, optname, m0)
	register struct socket *so;
	int level, optname;
	struct mbuf *m0;
{
	int error = 0;
	register struct mbuf *m = m0;

	if (level != SOL_SOCKET) {
		if (so->so_proto && so->so_proto->pr_ctloutput)
			return ((*so->so_proto->pr_ctloutput)
				  (PRCO_SETOPT, so, level, optname, &m0));
		error = ENOPROTOOPT;
	} else {
		switch (optname) {

		case SO_LINGER:
			if (m == NULL || m->m_len != sizeof (struct linger)) {
				error = EINVAL;
				goto bad;
			}
			so->so_linger = mtod(m, struct linger *)->l_linger;
			/* fall thru... */

		case SO_DEBUG:
		case SO_KEEPALIVE:
		case SO_DONTROUTE:
		case SO_USELOOPBACK:
		case SO_BROADCAST:
		case SO_REUSEADDR:
		case SO_REUSEPORT:
		case SO_OOBINLINE:
		case SO_TIMESTAMP:
			if (m == NULL || m->m_len < sizeof (int)) {
				error = EINVAL;
				goto bad;
			}
			if (*mtod(m, int *))
				so->so_options |= optname;
			else
				so->so_options &= ~optname;
			break;

		case SO_SNDBUF:
		case SO_RCVBUF:
		case SO_SNDLOWAT:
		case SO_RCVLOWAT:
			if (m == NULL || m->m_len < sizeof (int)) {
				error = EINVAL;
				goto bad;
			}
			switch (optname) {

			case SO_SNDBUF:
			case SO_RCVBUF:
				if (sbreserve(optname == SO_SNDBUF ?
				    &so->so_snd : &so->so_rcv,
				    (u_long) *mtod(m, int *)) == 0) {
					error = ENOBUFS;
					goto bad;
				}
				break;

			case SO_SNDLOWAT:
				so->so_snd.sb_lowat = *mtod(m, int *);
				break;
			case SO_RCVLOWAT:
				so->so_rcv.sb_lowat = *mtod(m, int *);
				break;
			}
			break;

		case SO_SNDTIMEO:
		case SO_RCVTIMEO:
		    {
			struct timeval *tv;
			short val;

			if (m == NULL || m->m_len < sizeof (*tv)) {
				error = EINVAL;
				goto bad;
			}
			tv = mtod(m, struct timeval *);
			if (tv->tv_sec > SHRT_MAX / hz - hz) {
				error = EDOM;
				goto bad;
			}
			val = tv->tv_sec * hz + tv->tv_usec / tick;

			switch (optname) {

			case SO_SNDTIMEO:
				so->so_snd.sb_timeo = val;
				break;
			case SO_RCVTIMEO:
				so->so_rcv.sb_timeo = val;
				break;
			}
			break;
		    }

#ifndef __riscos
		case SO_PRIVSTATE:
			/* we don't care what the parameter is... */
			so->so_state &= ~SS_PRIV;
			break;
#endif

		default:
			error = ENOPROTOOPT;
			break;
		}
		if (error == 0 && so->so_proto && so->so_proto->pr_ctloutput) {
			(void) ((*so->so_proto->pr_ctloutput)
				  (PRCO_SETOPT, so, level, optname, &m0));
			m = NULL;	/* freed by protocol */
		}
	}
bad:
	if (m)
		(void) m_free(m);
	return (error);
}

int
sogetopt(so, level, optname, mp)
	register struct socket *so;
	int level, optname;
	struct mbuf **mp;
{
	register struct mbuf *m;

	if (level != SOL_SOCKET) {
		if (so->so_proto && so->so_proto->pr_ctloutput) {
			return ((*so->so_proto->pr_ctloutput)
				  (PRCO_GETOPT, so, level, optname, mp));
		} else
			return (ENOPROTOOPT);
	} else {
		m = m_get(M_WAIT, MT_SOOPTS);
		if (m == NULL)
			return (ENOBUFS);
		m->m_len = sizeof (int);

		switch (optname) {

		case SO_LINGER:
			m->m_len = sizeof (struct linger);
			mtod(m, struct linger *)->l_onoff =
				so->so_options & SO_LINGER;
			mtod(m, struct linger *)->l_linger = so->so_linger;
			break;

		case SO_USELOOPBACK:
		case SO_DONTROUTE:
		case SO_DEBUG:
		case SO_KEEPALIVE:
		case SO_REUSEADDR:
		case SO_REUSEPORT:
		case SO_BROADCAST:
		case SO_OOBINLINE:
		case SO_TIMESTAMP:
			*mtod(m, int *) = so->so_options & optname;
			break;

#ifndef __riscos
		case SO_PRIVSTATE:
			*mtod(m, int *) = so->so_state & SS_PRIV;
			break;

#endif
		case SO_TYPE:
			*mtod(m, int *) = so->so_type;
			break;

		case SO_ERROR:
			*mtod(m, int *) = so->so_error;
			so->so_error = 0;
			break;

		case SO_SNDBUF:
			*mtod(m, int *) = so->so_snd.sb_hiwat;
			break;

		case SO_RCVBUF:
			*mtod(m, int *) = so->so_rcv.sb_hiwat;
			break;

		case SO_SNDLOWAT:
			*mtod(m, int *) = so->so_snd.sb_lowat;
			break;

		case SO_RCVLOWAT:
			*mtod(m, int *) = so->so_rcv.sb_lowat;
			break;

		case SO_SNDTIMEO:
		case SO_RCVTIMEO:
		    {
			int val = (optname == SO_SNDTIMEO ?
			     so->so_snd.sb_timeo : so->so_rcv.sb_timeo);

			m->m_len = sizeof(struct timeval);
			mtod(m, struct timeval *)->tv_sec = val / hz;
			mtod(m, struct timeval *)->tv_usec =
			    (val % hz) * tick;
			break;
		    }

		default:
			(void)m_free(m);
			return (ENOPROTOOPT);
		}
		*mp = m;
		return (0);
	}
}

void
sohasoutofband(so)
	register struct socket *so;
{
	struct proc *p;

	if (so->so_pgid < 0)
		gsignal(-so->so_pgid, SIGURG);
	else if (so->so_pgid > 0 && (p = pfind(so->so_pgid)) != 0)
		psignal(p, SIGURG);
	selwakeup(&so->so_rcv.sb_sel);
}
@


4.5
log
@Added new FreeBSD sysctl handling using linker magic.
A few new sysctls added as a result.
SO_TIMESTAMP now gives real time, not Internet's internal time.
DHCP/BOOTP parsing picks up URL option and pops it into Inet$URL.
Requires TCPIPLibs 5.25 and link 5.12.

Version 5.31. Tagged as 'Internet-5_31'
@
text
@a125 1
	MALLOC(so, struct socket *, sizeof(*so), M_SOCKET, M_WAIT);
@


4.4
log
@* Dynamic ports now assigned in range 49152-65535.
* IP_RECVDSTADDR works for non-unicast packets.
* SO_TIMESTAMP added.
* IP_RECVIF added.
* Various other internal changes merged in from FreeBSD sources.

Version 5.29. Tagged as 'Internet-5_29'
@
text
@d52 1
d54 1
d60 2
d75 30
d125 1
d162 16
d215 1
a215 1
	FREE(so, M_SOCKET);
@


4.3
log
@Missed some changes in the last checkin
@
text
@d973 1
d1102 1
@


4.2
log
@Version Spinner_B7 taken
@
text
@d376 4
d437 1
@


4.1
log
@Initial revision
@
text
@d1 3
a3 1
/* -*-C-*-
d5 15
a19 2
 * $Header: /ax/networking:Internet/sys/socket.c:networking  1.3  $
 * $Source: /ax/networking:Internet/sys/socket.c: $
d21 11
a31 1
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
a32 13
 * $Log:	socket.c,v $
 * Revision 1.3  95/03/07  16:06:15  kwelton
 * Restored the panic on bad mbuf type in sorecieve().
 * 
 * 
 * Revision 1.2  95/01/11  18:38:30  kwelton
 * Do not lock a socket's receive buffers around the call to
 * socantrcvmore() in sorflush() - see sorflush() for an
 * explanation.
 * 
 * Revision 1.1  94/12/02  11:48:13  kwelton
 * Initial revision
 * 
d34 19
a52 28
/*
 * Copyright (c) 1983, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 */
#include "sys/param.h"
#include "sys/dir.h"
#include "sys/file.h"
#include "sys/uio.h"
#include "sys/user.h"
#include "sys/proc.h"
#include "sys/mbuf.h"
#include "sys/domain.h"
#include "sys/protosw.h"
#include "sys/socket.h"
#include "sys/socketvar.h"
d56 6
a69 4
 * TODO:
 *	test socketpair
 *	clean up async
 *	out-of-band is a kludge
d72 1
d74 1
a80 1
	register struct mbuf *m;
d87 1
a87 1
	if (prp == 0)
d91 2
a92 3
#ifdef OldCode
	m = m_getclr(M_WAIT, MT_SOCKET);
	if (m == 0)
d94 5
a98 6
#else
	if( (m = ALLOC_C(MINCONTIG, NULL)) == NULL )
	{
#ifdef DEBUG
	    if( DODEBUG(DBGMMAN) )
		Printf("socreate: ALLOC_C failed\n");
a99 9
	    return(ENOBUFS);
	}
	m->m_type = MT_SOCKET;
#endif
	so = mtod(m, struct socket *);
	so->so_options = 0;
	so->so_state = 0;
	so->so_type = type;
	if (u.u_uid == 0)
d114 1
d127 1
d140 1
a140 3
	if (so->so_q == 0) {
		so->so_q = so;
		so->so_q0 = so;
d142 3
a144 4
	}
	if (backlog < 0)
		backlog = 0;
	so->so_qlimit = MIN(backlog, SOMAXCONN);
d148 1
d152 1
d164 1
a164 5
#ifdef OldCode
	(void) m_free(dtom(so));
#else
	DTOM_FREE(so);
#endif
d167 6
d179 1
a179 1
		while (so->so_q0 != so)
d181 1
a181 1
		while (so->so_q != so)
d196 7
a202 2
			while (so->so_state & SS_ISCONNECTED)
				sleep((caddr_t)&so->so_timeo, PZERO+1);
d215 1
d223 4
d236 1
d253 1
d278 1
d290 1
d311 20
a330 1
sosend(so, nam, uio, flags, rights)
d332 4
a335 2
	struct mbuf *nam;
	register struct uio *uio;
a336 1
	struct mbuf *rights;
d338 8
a345 4
	struct mbuf *top = 0;
	register struct mbuf *m, **mp;
	int space, len, rlen = 0, error = 0, dontroute, first = 1;
	struct iovec *iov;
d347 13
d363 6
d375 8
d384 2
d387 3
a389 1
			return (EPIPE);
d392 3
a394 3
				  return (ENOTCONN);
			if (nam == 0)
				  return (EDESTADDRREQ);
d396 3
a398 1
		sblock(&so->so_snd);
a401 17
#ifdef OldCode
		    MGET(m, M_WAIT, MT_DATA);
		    if (m == 0)
		    {
			error = ENOBUFS;
			goto release;
		    }
		    iov = uio->uio_iov;
		    m->m_len = iov->iov_len;
		    m->m_datp = iov->iov_base;
		    m->m_indir = 1;
		    m->m_off = 0;
		    *mp = m;
		    mp = &m->m_next;
		    uio->uio_iov++;
		    uio->uio_iovcnt--;
#else
d404 1
a404 2
		    if( (m = ALLOC_U(iov->iov_len, iov->iov_base)) == NULL )
		    {
d406 1
a406 1
			if( DODEBUG(DBGMMAN) )
a417 1
#endif
d419 3
d426 1
a426 1
			top, (caddr_t)nam, rights);
d433 1
a433 6

#define snderr(errno)	{ error = errno; goto release; }
	if (sosendallatonce(so) && uio->uio_resid > so->so_snd.sb_hiwat)
		return (EMSGSIZE);
	if (rights)
		rlen = rights->m_len;
d435 3
a437 1
	sblock(&so->so_snd);
d441 2
a442 5
		if (so->so_error) {
			error = so->so_error;
			so->so_error = 0;			/* ??? */
			goto release;
		}
d444 14
a457 4
			if (so->so_proto->pr_flags & PR_CONNREQUIRED)
				snderr(ENOTCONN);
			if (nam == 0)
				snderr(EDESTADDRREQ);
d459 1
d461 13
a473 16
			space = 1024;
		else {
			space = sbspace(&so->so_snd);
			if (space <= rlen ||
			   (sosendallatonce(so) &&
				space < uio->uio_resid + rlen)) {
				if (so->so_state & SS_NBIO) {
					if (first)
						error = EWOULDBLOCK;
					goto release;
				}
				sbunlock(&so->so_snd);
				if (sbwait(&so->so_snd) != 0)
					so->so_error = EINTR;
				goto restart;
			}
d476 17
a492 7
		space -= rlen;
#ifdef OldCode
		while (space > 0) {
			MGET(m, M_WAIT, MT_DATA);
			if (m == 0) {
				error = ENOBUFS;
				goto release;
d494 9
a502 1
			len = MIN(MIN(OLDMLEN, uio->uio_resid), space);
d504 11
a514 41
			error = uiomove(mtod(m, caddr_t), len, UIO_WRITE, uio);
			m->m_len = len;
			*mp = m;
			if (error)
				goto release;
			mp = &m->m_next;
			if (uio->uio_resid <= 0)
				break;
		}
#else
		len = MIN(uio->uio_resid, space);
		if( (m = ALLOC(len, NULL)) == NULL )
		{
#ifdef DEBUG
		    if( DODEBUG(DBGMMAN) )
			Printf("sosend: ALLOC failed\n");
#endif
		    error = ENOBUFS;
		    goto release;
		}

		*mp = m;

		/*
		 * we have allocated enough mbuf memory,
		 * copy the data in from user space
		 */
		{
		    struct mbuf *n;

		    for( n = m; n; n = n->m_next )
		    {
			n->m_type = MT_DATA;
			space = MIN(len, m->m_inilen);

			if( (error = uiomove(mtod(n, caddr_t), space,
					     UIO_WRITE, uio)) != 0 )
			    goto release;

			n->m_len = space;
			len -= space;
d516 23
a538 16
		}
#endif
		if (dontroute)
			so->so_options |= SO_DONTROUTE;
		error = (*so->so_proto->pr_usrreq)(so,
		    (flags & MSG_OOB) ? PRU_SENDOOB : PRU_SEND,
		    top, (caddr_t)nam, rights);
		if (dontroute)
			so->so_options &= ~SO_DONTROUTE;
		rights = 0;
		rlen = 0;
		top = 0;
		first = 0;
		if (error)
			break;
	} while (uio->uio_resid);
d542 1
d544 4
a547 8
	{
#ifdef OldCode
	    m_freem(top);
#else
	    FREEM(top);
#endif
	}
	return (error);
d550 18
a567 1
soreceive(so, aname, uio, flags, rightsp)
d569 5
a573 4
	struct mbuf **aname;
	register struct uio *uio;
	int flags;
	struct mbuf **rightsp;
d575 2
a576 2
	register struct mbuf *m;
	register int len, error = 0, offset;
d579 2
a580 1
	int moff;
d582 13
a594 4
	if (rightsp)
		*rightsp = 0;
	if (aname)
		*aname = 0;
a595 1
#ifdef OldCode
d597 3
a599 3
		if (m == 0) {
			error = ENOBUFS;
			goto bad;
a600 12
#else
		if( (m = ALLOC_S(MINCONTIG, NULL)) == NULL )
		{
#ifdef DEBUG
		    if( DODEBUG(DBGMMAN) )
			Printf("soreceive: ALLOC_S failed\n");
#endif
		    error = ENOBUFS;
		    goto bad;
		}
		m->m_type = MT_DATA;
#endif
d606 3
a608 14
			len = uio->uio_resid;
			if (len > m->m_len)
				len = m->m_len;
			error =
			    uiomove(mtod(m, caddr_t), (int)len, UIO_READ, uio);
#ifdef OldCode
			m = m_free(m);
#else
			{
			    struct mbuf *m0 = m;
			    m = m0->m_next;
			    FREE(m0);
			}
#endif
d612 1
a612 7
		{
#ifdef OldCode
		    m_freem(m);
#else
		    FREEM(m);
#endif
		}
d615 5
d622 28
a649 2
	sblock(&so->so_rcv);
	if (so->so_rcv.sb_cc == 0) {
d651 2
d654 2
a655 1
			so->so_error = 0;
d658 12
a669 3
		if (so->so_state & SS_CANTRCVMORE)
			goto release;
		if ((so->so_state & SS_ISCONNECTED) == 0 &&
d676 1
a676 1
		if (so->so_state & SS_NBIO) {
d678 3
d684 3
a686 2
		if (sbwait(&so->so_rcv) != 0)
			so->so_error = EINTR;
d689 6
a694 6
	m = so->so_rcv.sb_mb;
	if (m == 0) {
		panic("receive 1");
		return (EFAULT);
	}
	nextrecord = m->m_list;
d696 2
a697 1
		if (m->m_type != MT_SONAME)
d699 4
d704 2
a705 8
			if (aname)
			{
#ifdef OldCode
			    *aname = m_copy(m, 0, m->m_len);
#else
			    *aname = COPY_P(m, 0, m->m_len);
#endif
			}
d709 5
a713 5
			if (aname) {
				*aname = m;
				m = m->m_next;
				(*aname)->m_next = 0;
				so->so_rcv.sb_mb = m;
a717 2
			if (m)
				m->m_list = nextrecord;
d720 1
a720 5
	if (m && m->m_type == MT_RIGHTS) {
		if ((pr->pr_flags & PR_RIGHTS) == 0) {
			panic("receive 2");
			return (EFAULT);
		}
d722 2
a723 8
			if (rightsp)
			{
#ifdef OldCode
			    *rightsp = m_copy(m, 0, m->m_len);
#else
			    *rightsp = COPY_P(m, 0, m->m_len);
#endif
			}
d727 6
a732 2
			if (rightsp) {
				*rightsp = m;
d740 4
a743 2
			if (m)
				m->m_list = nextrecord;
d746 7
d756 2
a757 7
		switch (m->m_type) {
#ifdef OldCode
			case MT_RXDATA:
			case MT_LRXDATA:
#endif /* OldCode */
			case MT_DATA:
			case MT_HEADER:
d759 7
a765 14
			default:
				/* TRACE */
#if 0
				if( 0 )
				{
				    static char poo[80];
				    sprintf(poo,
					    "\021\01receive 3: m_type %d\n",
					    m->m_type);
				    Printf(poo);
				}
#else
				panic("receive 3");
				return (EFAULT);
d767 1
a767 1
		}
a768 1
		so->so_state &= ~SS_RCVATMARK;
d773 12
a784 2
		error =
		    uiomove(mtod(m, caddr_t) + moff, (int)len, UIO_READ, uio);
d786 2
d792 1
a792 1
				nextrecord = m->m_list;
d794 9
a802 2
				MFREE(m, so->so_rcv.sb_mb);
				m = so->so_rcv.sb_mb;
d804 1
a804 1
					m->m_list = nextrecord;
d810 2
d824 1
a824 1
			} else
d826 25
d853 6
a861 2
		else if (pr->pr_flags & PR_ATOMIC)
			(void) sbdroprecord(&so->so_rcv);
d864 1
a864 4
			    (struct mbuf *)0, (struct mbuf *)0);
		if (error == 0 && rightsp && *rightsp &&
		    pr->pr_domain->dom_externalize)
			error = (*pr->pr_domain->dom_externalize)(*rightsp);
d866 8
d879 1
d895 1
d919 2
a920 1
	sblock(sb);
d935 1
d966 1
a981 2
		case SO_SNDTIMEO:
		case SO_RCVTIMEO:
d1004 22
d1027 1
a1027 1
				so->so_snd.sb_timeo = *mtod(m, int *);
d1030 1
a1030 1
				so->so_rcv.sb_timeo = *mtod(m, int *);
d1034 8
d1047 5
d1055 1
a1055 7
	{
#ifdef OldCode
	    (void) m_free(m);
#else
	    FREE(m);
#endif
	}
d1059 1
a1073 1
#ifdef OldCode
d1075 1
a1075 1
		if (m == 0)
a1076 12
#else
		if( (m = ALLOC_S(MINCONTIG, NULL)) == NULL )
		{
#ifdef DEBUG
		    if( DODEBUG(DBGMMAN) )
			Printf("sogetopt: ALLOC_s failed\n");
#endif
		    return(ENOBUFS);
		}

		m->m_type = MT_SOOPTS;
#endif
d1093 1
d1099 6
d1131 4
a1134 2
			*mtod(m, int *) = so->so_snd.sb_timeo;
			break;
d1136 4
a1139 2
		case SO_RCVTIMEO:
			*mtod(m, int *) = so->so_rcv.sb_timeo;
d1141 1
a1143 1
#ifdef OldCode
a1144 3
#else
			FREE(m);
#endif
d1152 1
d1158 3
a1160 3
	if (so->so_pgrp < 0)
		gsignal(-so->so_pgrp, SIGURG);
	else if (so->so_pgrp > 0 && (p = pfind(so->so_pgrp)) != 0)
d1162 1
a1162 5
	if (so->so_rcv.sb_sel) {
		selwakeup(so->so_rcv.sb_sel, so->so_rcv.sb_flags & SB_COLL);
		so->so_rcv.sb_sel = 0;
		so->so_rcv.sb_flags &= ~SB_COLL;
	}
a1163 2

/* EOF socket.c */
@


4.1.4.1
log
@Internet 5.04 merged from Internet 5.03 on Networking source tree with
Internet 4.08 BOOTP extensions from Spinner.
@
text
@d1 21
d23 2
a24 2
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
d26 11
a36 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d39 11
a49 19

#include <string.h>

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/kernel.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#ifndef __riscos
#include <sys/resourcevar.h>
#endif
#include <sys/signalvar.h>
#include <sys/sysctl.h>
a52 6
#include "module.h"

static int somaxconn = SOMAXCONN;
#ifdef NotYet
SYSCTL_INT(_kern, KERN_SOMAXCONN, somaxconn, CTLFLAG_RW, &somaxconn, 0, "");
#endif
d61 4
a66 1
int
a67 1
	int dom;
d74 1
d81 1
a81 1
	if (prp == 0 || prp->pr_usrreq == 0)
d85 3
a87 2
	MALLOC(so, struct socket *, sizeof(*so), M_SOCKET, M_WAIT);
	if (so == 0)
d89 14
a102 1
	bzero((caddr_t)so, sizeof(*so));
d104 1
a104 4
        //so->so_options |= SO_DEBUG;
#ifndef __riscos
	if (p->p_ucred->cr_uid == 0)
#endif
a118 1
int
a130 1
int
d143 3
a145 1
	if (so->so_q == 0)
d147 4
a150 3
	if (backlog < 0 || backlog > somaxconn)
		backlog = somaxconn;
	so->so_qlimit = backlog;
a153 1
void
a156 1

d168 5
a172 1
	FREE(so, M_SOCKET);
a174 6
/*
 * Close a socket on last file table reference removal.
 * Initiate disconnect if connected.
 * Free socket when disconnect complete.
 */
int
d181 1
a181 1
		while (so->so_q0)
d183 1
a183 1
		while (so->so_q)
d198 2
a199 7
			while (so->so_state & SS_ISCONNECTED) {
				error = tsleep((caddr_t)&so->so_timeo,
				    PSOCK | PCATCH, "soclos", so->so_linger,
				    so->so_state & SS_SLEEPTW);
				if (error)
					break;
			}
a211 1
		panic("soclose: NOFDREF");
a218 4
/*
 * Must be called at splnet...
 */
int
a227 1
int
a243 1
int
a267 1
int
a278 1
int
d299 1
a299 20
#define	SBLOCKWAIT(f)	(((f) & MSG_DONTWAIT) ? M_NOWAIT : M_WAITOK)
/*
 * Send on a socket.
 * If send must go all at once and message is larger than
 * send buffering, then hard error.
 * Lock against other senders.
 * If must go all at once and not enough room now, then
 * inform user that this would block and do nothing.
 * Otherwise, if nonblocking, send as much as possible.
 * The data to be sent is described by "uio" if nonzero,
 * otherwise by the mbuf chain "top" (which must be null
 * if uio is not).  Data provided in mbuf chain must be small
 * enough to send all at once.
 *
 * Returns nonzero on error, timeout or signal; callers
 * must check for short counts if EINTR/ERESTART are returned.
 * Data and control buffers are freed on return.
 */
int
sosend(so, addr, uio, top, control, flags)
d301 2
a302 4
	struct mbuf *addr;
	struct uio *uio;
	struct mbuf *top;
	struct mbuf *control;
d304 1
d306 4
a309 8
#ifndef __riscos
	struct proc *p = curproc;		/* XXX */
#endif
	struct mbuf **mp;
	register struct mbuf *m;
	register long space, len, resid;
	int clen = 0, error, dontroute, mlen;
	int atomic = sosendallatonce(so) || top;
a310 13
	if (uio)
		resid = uio->uio_resid;
	else
		resid = top->m_pkthdr.len;
	/*
	 * In theory resid should be unsigned.
	 * However, space must be signed, as it might be less than 0
	 * if we over-committed, and we must use a signed comparison
	 * of space and resid.  On the other hand, a negative resid
	 * causes us to loop sending 0-length segments to the protocol.
	 */
	if (resid < 0)
		return (EINVAL);
a313 6
#ifndef __riscos
	p->p_stats->p_ru.ru_msgsnd++;
#endif
	if (control)
		clen = control->m_len;
#define	snderr(errno)	{ error = errno; goto release; }
a319 8
#ifdef __riscos
	/*
	 * Super-hack that saves a data copy using unsafe mbufs. This relies
	 * on
	 *      1) UDP being the only SOCK_DGRAM protocol
	 *      2) IP ensuring_safe anything it doesn't send straight to the
	 *         driver (ie when waiting for ARP resolution)
	 */
a320 2
		struct iovec *iov;

d322 1
a322 3
			snderr(EPIPE);
		if (so->so_error)
		    	snderr(so->so_error);
d325 3
a327 3
				  snderr(ENOTCONN);
			if (addr == 0)
				  snderr(EDESTADDRREQ);
d329 1
a329 3
		error = sblock(&so->so_snd, SBLOCKWAIT(flags));
		if (error)
			goto out;
d333 17
d352 2
a353 1
		    if ((m = ALLOC_U(iov->iov_len, iov->iov_base)) == NULL) {
d355 1
a355 1
			if ( DODEBUG(DBGMMAN))
d367 1
a368 3
		top->m_flags = M_PKTHDR;
		top->m_pkthdr.len = resid;
		top->m_pkthdr.rcvif = (struct ifnet *)0;
d373 1
a373 1
			top, addr, control);
d380 6
a385 1
#endif
d387 1
a387 3
	error = sblock(&so->so_snd, SBLOCKWAIT(flags));
	if (error)
		goto out;
d391 5
a395 2
		if (so->so_error)
		    	snderr(so->so_error);
d397 4
a400 14
			/*
			 * `sendto' and `sendmsg' is allowed on a connection-
			 * based socket if it supports implied connect.
			 * Return ENOTCONN if not connected and no address is
			 * supplied.
			 */
			if ((so->so_proto->pr_flags & PR_CONNREQUIRED) &&
			    (so->so_proto->pr_flags & PR_IMPLOPCL) == 0) {
				if ((so->so_state & SS_ISCONFIRMING) == 0 &&
				    !(resid == 0 && clen != 0))
					snderr(ENOTCONN);
			} else if (addr == 0)
			    snderr(so->so_proto->pr_flags & PR_CONNREQUIRED ?
				   ENOTCONN : EDESTADDRREQ);
a401 1
		space = sbspace(&so->so_snd);
d403 16
a418 13
			space += 1024;
		if ((atomic && resid > so->so_snd.sb_hiwat) ||
		    clen > so->so_snd.sb_hiwat)
			snderr(EMSGSIZE);
		if (space < resid + clen && uio &&
		    (atomic || space < so->so_snd.sb_lowat || space < clen)) {
			if (so->so_state & SS_NBIO)
				snderr(EWOULDBLOCK);
			sbunlock(&so->so_snd);
			error = sbwait(&so->so_snd, so->so_state & SS_SLEEPTW);
			if (error)
				goto out;
			goto restart;
d421 7
a427 17
		space -= clen;
		do {
		    if (uio == NULL) {
			/*
			 * Data is prepackaged in "top".
			 */
			resid = 0;
			if (flags & MSG_EOR)
				top->m_flags |= M_EOR;
		    } else {
		        len = min(resid, space);
			top = ALLOC(len, NULL);
			if (top == 0) {
				m_reclaim();
				top = ALLOC(len, NULL);
				if (top == 0)
					snderr(ENOBUFS);
d429 1
a429 9
			top->m_flags = M_PKTHDR;
			top->m_pkthdr.len = len;
			top->m_pkthdr.rcvif = (struct ifnet *)0;
			/*
			 * For datagram protocols, leave room
			 * for protocol headers in first mbuf.
			 */
			if (atomic && len < MLEN(top))
				MH_ALIGN(top, len);
d431 41
a471 11
			for (m = top; m; m = m->m_next) {
				m->m_type = MT_DATA;
				mlen = min(len, MLEN(m));
				uiomove(mtod(m, caddr_t), (int)mlen, uio);
				m->m_len = mlen;
				len -= mlen;
			}
			resid = uio->uio_resid;
			if (resid <= 0)
				if (flags & MSG_EOR)
					top->m_flags |= M_EOR;
d473 16
a488 23
		    if (dontroute)
			    so->so_options |= SO_DONTROUTE;
		    error = (*so->so_proto->pr_usrreq)(so,
			(flags & MSG_OOB) ? PRU_SENDOOB :
			/*
			 * If the user set MSG_EOF, the protocol
			 * understands this flag and nothing left to
			 * send then use PRU_SEND_EOF instead of PRU_SEND.
			 */
			((flags & MSG_EOF) &&
			 (so->so_proto->pr_flags & PR_IMPLOPCL) &&
			 (resid <= 0)) ?
				PRU_SEND_EOF : PRU_SEND,
			top, addr, control);
		    if (dontroute)
			    so->so_options &= ~SO_DONTROUTE;
		    clen = 0;
		    control = 0;
		    top = 0;
		    if (error)
			goto release;
		} while (resid && space > 0);
	} while (resid);
a491 1
out:
d493 8
a500 4
	    	m_freem(top);
	if (control)
		m_freem(control);
	return(error);
d503 1
a503 18
/*
 * Implement receive operations on a socket.
 * We depend on the way that records are added to the sockbuf
 * by sbappend*.  In particular, each record (mbufs linked through m_next)
 * must begin with an address if the protocol so specifies,
 * followed by an optional mbuf or mbufs containing ancillary data,
 * and then zero or more mbufs of data.
 * In order to avoid blocking network interrupts for the entire time here,
 * we splx() while doing the actual copy to user space.
 * Although the sockbuf is locked, new data may still be appended,
 * and thus we must maintain consistency of the sockbuf during that time.
 *
 * The caller may receive the data as a single mbuf chain by supplying
 * an mbuf **mp0 for use in returning the chain.  The uio is then used
 * only for the count in uio_resid.
 */
int
soreceive(so, paddr, uio, mp0, controlp, flagsp)
d505 4
a508 5
	struct mbuf **paddr;
	struct uio *uio;
	struct mbuf **mp0;
	struct mbuf **controlp;
	int *flagsp;
d510 2
a511 2
	register struct mbuf *m, **mp;
	register int flags, len, error, offset;
d514 1
a514 2
	int moff, type = 0;
	int orig_resid = uio->uio_resid;
d516 4
a519 13
#ifdef DEBUG2
        Printf("soreceive(): so=%x, &so->so_rcv=%x, so->so_rcv.sb_cc=%d, &so->so_snd=%x\n",
                so, &so->so_rcv, so->so_rcv.sb_cc, &so->so_snd);
#endif
	mp = mp0;
	if (paddr)
		*paddr = 0;
	if (controlp)
		*controlp = 0;
	if (flagsp)
		flags = *flagsp &~ MSG_EOR;
	else
		flags = 0;
d521 1
d523 3
a525 3
		if (m == NULL) {
		    	error=ENOBUFS;
		    	goto bad;
d527 12
d544 14
a557 3
			error = uiomove(mtod(m, caddr_t),
			    (int) min(uio->uio_resid, m->m_len), uio);
			m = m_freen(m);
d561 7
a567 1
			m_freem(m);
a569 5
	if (mp)
		*mp = (struct mbuf *)0;
	if (so->so_state & SS_ISCONFIRMING && uio->uio_resid)
		(*pr->pr_usrreq)(so, PRU_RCVD, (struct mbuf *)0,
		    (struct mbuf *)0, (struct mbuf *)0);
d572 2
a573 28
	error = sblock(&so->so_rcv, SBLOCKWAIT(flags));
	if (error)
		return (error);

	m = so->so_rcv.sb_mb;
	/*
	 * If we have less data than requested, block awaiting more
	 * (subject to any timeout) if:
	 *   1. the current count is less than the low water mark, or
	 *   2. MSG_WAITALL is set, and it is possible to do the entire
	 *	receive operation at once if we block (resid <= hiwat).
	 *   3. MSG_DONTWAIT is not set
	 * If MSG_WAITALL is set but resid is larger than the receive buffer,
	 * we have to do the receive in sections, and thus risk returning
	 * a short count if a timeout or signal occurs after we start.
	 */

	if (m == 0 || (((flags & MSG_DONTWAIT) == 0 &&
	    so->so_rcv.sb_cc < uio->uio_resid) &&
	    (so->so_rcv.sb_cc < so->so_rcv.sb_lowat ||
	    ((flags & MSG_WAITALL) && uio->uio_resid <= so->so_rcv.sb_hiwat)) &&
	    m->m_nextpkt == 0 && (pr->pr_flags & PR_ATOMIC) == 0)) {
#ifdef DIAGNOSTIC
		if (m == 0 && so->so_rcv.sb_cc) {
			panic("receive 1");
			return (EFAULT);
		}
#endif
a574 2
			if (m)
				goto dontblock;
d576 1
a576 2
			if ((flags & MSG_PEEK) == 0)
				so->so_error = 0;
d579 3
a581 12
		if (so->so_state & SS_CANTRCVMORE) {
			if (m)
				goto dontblock;
			else
				goto release;
		}
		for (; m; m = m->m_next)
			if (m->m_type == MT_OOBDATA  || (m->m_flags & M_EOR)) {
				m = so->so_rcv.sb_mb;
				goto dontblock;
			}
		if ((so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING)) == 0 &&
d588 1
a588 1
		if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT)) {
a589 3
#if 0
                        Printf("soreceive: returning EWOULDBLOCK; so->so_rcv.sb_cc=%d, so->so_rcv.sb_lowat=%d\n", so->so_rcv.sb_cc, so->so_rcv.sb_lowat);
#endif
d593 2
a594 3
		error = sbwait(&so->so_rcv, so->so_state & SS_SLEEPTW);
		if (error)
			return (error);
d597 6
a602 6
dontblock:
#ifndef __riscos
	if (uio->uio_procp)
		uio->uio_procp->p_stats->p_ru.ru_msgrcv++;
#endif
	nextrecord = m->m_nextpkt;
d604 1
a604 2
#ifdef DIAGNOSTIC
		if (m->m_type != MT_SONAME) {
d606 7
a612 2
			return (EFAULT);
		}
d614 1
a614 4
		orig_resid = 0;
		if (flags & MSG_PEEK) {
			if (paddr)
				*paddr = m_copy(m, 0, m->m_len);
d618 5
a622 5
			if (paddr) {
				*paddr = m;
				so->so_rcv.sb_mb = m->m_next;
				m->m_next = 0;
				m = so->so_rcv.sb_mb;
d627 2
d631 5
a635 1
	while (m && m->m_type == MT_CONTROL && error == 0) {
d637 8
a644 2
			if (controlp)
				*controlp = m_copy(m, 0, m->m_len);
d648 2
a649 6
			if (controlp) {
				if (pr->pr_domain->dom_externalize &&
				    mtod(m, struct cmsghdr *)->cmsg_type ==
				    SCM_RIGHTS)
				   error = (*pr->pr_domain->dom_externalize)(m);
				*controlp = m;
d657 2
a658 4
		}
		if (controlp) {
			orig_resid = 0;
			controlp = &(*controlp)->m_next;
a660 7
	if (m) {
		if ((flags & MSG_PEEK) == 0)
			m->m_nextpkt = nextrecord;
		type = m->m_type;
		if (type == MT_OOBDATA)
			flags |= MSG_OOB;
	}
d664 7
a670 2
		if (m->m_type == MT_OOBDATA) {
			if (type != MT_OOBDATA)
d672 15
a686 6
		} else if (type == MT_OOBDATA)
			break;
#ifdef DIAGNOSTIC
		else if (m->m_type != MT_DATA && m->m_type != MT_HEADER) {
			panic("receive 3");
			return (EFAULT);
d688 1
a688 1
#endif
a689 1
		len = uio->uio_resid;
d694 2
a695 12
		/*
		 * If mp is set, just pass back the mbufs.
		 * Otherwise copy them out via the uio, then free.
		 * Sockbuf must be consistent here (points to current mbuf,
		 * it points to next record) when we drop priority;
		 * we must note any additions to the sockbuf when we
		 * block interrupts again.
		 */
		if (mp == 0) {
			error = uiomove(mtod(m, caddr_t) + moff, (int)len, uio);
		} else
			uio->uio_resid -= len;
a696 2
			if (m->m_flags & M_EOR)
				flags |= MSG_EOR;
d701 1
a701 1
				nextrecord = m->m_nextpkt;
d703 2
a704 9
				if (mp) {
					*mp = m;
					mp = &m->m_next;
					so->so_rcv.sb_mb = m = m->m_next;
					*mp = (struct mbuf *)0;
				} else {
					MFREE(m, so->so_rcv.sb_mb);
					m = so->so_rcv.sb_mb;
				}
d706 1
a706 1
					m->m_nextpkt = nextrecord;
a711 2
				if (mp)
					*mp = m_copym(m, 0, len, M_WAIT);
d724 1
a724 1
			} else {
a725 25
				if (offset == so->so_oobmark)
					break;
			}
		}
		if (flags & MSG_EOR)
			break;
		/*
		 * If the MSG_WAITALL flag is set (for non-atomic socket),
		 * we must not quit until "uio->uio_resid == 0" or an error
		 * termination.  If a signal/timeout occurs, return
		 * with a short count but without error.
		 * Keep sockbuf locked against other readers.
		 */
		while (flags & MSG_WAITALL && m == 0 && uio->uio_resid > 0 &&
		    !sosendallatonce(so) && !nextrecord) {
			if (so->so_error || so->so_state & SS_CANTRCVMORE)
				break;
			error = sbwait(&so->so_rcv, so->so_state & SS_SLEEPTW);
			if (error) {
				sbunlock(&so->so_rcv);
				return (0);
			}
			m = so->so_rcv.sb_mb;
			if (m)
				nextrecord = m->m_nextpkt;
a727 6

	if (m && pr->pr_flags & PR_ATOMIC) {
		flags |= MSG_TRUNC;
		if ((flags & MSG_PEEK) == 0)
			(void) sbdroprecord(&so->so_rcv);
	}
d731 2
d735 4
a738 1
			    (struct mbuf *)flags, (struct mbuf *)0);
a739 8
	if (orig_resid == uio->uio_resid && orig_resid &&
	    (flags & MSG_EOR) == 0 && (so->so_state & SS_CANTRCVMORE) == 0) {
		sbunlock(&so->so_rcv);
		goto restart;
	}

	if (flagsp)
		*flagsp |= flags;
a744 1
int
a759 1
void
d783 1
a783 2
	sb->sb_flags |= SB_NOINTR;
	sblock(sb, M_WAITOK);
a797 1
int
a827 1
		case SO_REUSEPORT:
d843 2
a866 22
			}
			break;

		case SO_SNDTIMEO:
		case SO_RCVTIMEO:
		    {
			struct timeval *tv;
			short val;

			if (m == NULL || m->m_len < sizeof (*tv)) {
				error = EINVAL;
				goto bad;
			}
			tv = mtod(m, struct timeval *);
			if (tv->tv_sec > SHRT_MAX / hz - hz) {
				error = EDOM;
				goto bad;
			}
			val = tv->tv_sec * hz + tv->tv_usec / tick;

			switch (optname) {

d868 1
a868 1
				so->so_snd.sb_timeo = val;
d871 1
a871 1
				so->so_rcv.sb_timeo = val;
a874 8
		    }

#ifndef __riscos
		case SO_PRIVSTATE:
			/* we don't care what the parameter is... */
			so->so_state &= ~SS_PRIV;
			break;
#endif
a879 5
		if (error == 0 && so->so_proto && so->so_proto->pr_ctloutput) {
			(void) ((*so->so_proto->pr_ctloutput)
				  (PRCO_SETOPT, so, level, optname, &m0));
			m = NULL;	/* freed by protocol */
		}
d883 7
a889 1
		(void) m_free(m);
a892 1
int
d907 1
d909 1
a909 1
		if (m == NULL)
d911 12
a938 1
		case SO_REUSEPORT:
a943 6
#ifndef __riscos
		case SO_PRIVSTATE:
			*mtod(m, int *) = so->so_state & SS_PRIV;
			break;

#endif
d970 3
d974 1
a974 8
		    {
			int val = (optname == SO_SNDTIMEO ?
			     so->so_snd.sb_timeo : so->so_rcv.sb_timeo);

			m->m_len = sizeof(struct timeval);
			mtod(m, struct timeval *)->tv_sec = val / hz;
			mtod(m, struct timeval *)->tv_usec =
			    (val % hz) * tick;
a975 1
		    }
d978 1
d980 3
a989 1
void
d995 3
a997 3
	if (so->so_pgid < 0)
		gsignal(-so->so_pgid, SIGURG);
	else if (so->so_pgid > 0 && (p = pfind(so->so_pgid)) != 0)
d999 5
a1003 1
	selwakeup(&so->so_rcv.sb_sel);
d1005 2
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d3 1
a3 1
 * $Header: /ax/networking:Internet/sys/socket.c:networking  1.4  $
a8 4
 * Revision 1.4  95/06/05  15:56:03  kwelton
 * Fixed sosend() so that the RISC OS equivalent of SIGPIPE is generated when
 * a send is attempted on a disconnected socket.
 * 
a298 2
#define snderr(errno)	{ error = errno; goto release; }

d322 1
a322 1
			snderr(EPIPE);
d381 1
d500 1
a500 19

	/*
	 * 950601 KWelton
	 *
	 * don't know why the sending of SIGPIPE was
	 * removed from the original code; hope it
	 * wasn't an important reason =8)
	 */
	if( error == EPIPE )
	{
	    struct proc *p;

	    if( so->so_pgrp < 0 )
		gsignal(-so->so_pgrp, SIGPIPE);
	    else if( so->so_pgrp > 0 && (p = pfind(so->so_pgrp)) != 0 )
		psignal(p, SIGPIPE);
	}

	return(error);
@


4.1.7.2
log
@RCS log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.7.3
log
@BootP patch incorporated
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@d3 1
a3 1
 * $Header: /ax/networking:Internet/sys/socket.c:networking  1.4  $
a8 4
 * Revision 1.4  95/06/05  15:56:03  kwelton
 * Fixed sosend() so that the RISC OS equivalent of SIGPIPE is generated when
 * a send is attempted on a disconnected socket.
 * 
a298 2
#define snderr(errno)	{ error = errno; goto release; }

d322 1
a322 1
			snderr(EPIPE);
d381 1
d500 1
a500 19

	/*
	 * 950601 KWelton
	 *
	 * don't know why the sending of SIGPIPE was
	 * removed from the original code; hope it
	 * wasn't an important reason =8)
	 */
	if( error == EPIPE )
	{
	    struct proc *p;

	    if( so->so_pgrp < 0 )
		gsignal(-so->so_pgrp, SIGPIPE);
	    else if( so->so_pgrp > 0 && (p = pfind(so->so_pgrp)) != 0 )
		psignal(p, SIGPIPE);
	}

	return(error);
@


4.1.5.2
log
@RCS Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d1 21
d23 2
a24 2
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
d26 11
a36 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a37 14
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)uipc_socket.c	8.3 (Berkeley) 4/15/94
 * $Id: uipc_socket.c,v 1.15 1996/02/13 18:16:20 wollman Exp $
d39 11
a49 17

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/kernel.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#ifndef __riscos
#include <sys/resourcevar.h>
#include <sys/signalvar.h>
#endif
#include <sys/sysctl.h>
a52 6
#include "module.h"

static int somaxconn = SOMAXCONN;
#ifdef NotYet
SYSCTL_INT(_kern, KERN_SOMAXCONN, somaxconn, CTLFLAG_RW, &somaxconn, 0, "");
#endif
d61 4
a66 1
int
a67 1
	int dom;
d74 1
d81 1
a81 1
	if (prp == 0 || prp->pr_usrreq == 0)
d85 3
a87 2
	MALLOC(so, struct socket *, sizeof(*so), M_SOCKET, M_WAIT);
	if (so == 0)
d89 14
a102 1
	bzero((caddr_t)so, sizeof(*so));
d104 1
a104 4
        //so->so_options |= SO_DEBUG;
#ifndef __riscos
	if (p->p_ucred->cr_uid == 0)
#endif
a118 1
int
a130 1
int
d143 3
a145 1
	if (so->so_q == 0)
d147 4
a150 3
	if (backlog < 0 || backlog > somaxconn)
		backlog = somaxconn;
	so->so_qlimit = backlog;
a153 1
void
a156 1

d168 5
a172 1
	FREE(so, M_SOCKET);
a174 6
/*
 * Close a socket on last file table reference removal.
 * Initiate disconnect if connected.
 * Free socket when disconnect complete.
 */
int
d181 1
a181 1
		while (so->so_q0)
d183 1
a183 1
		while (so->so_q)
d198 2
a199 7
			while (so->so_state & SS_ISCONNECTED) {
				error = tsleep((caddr_t)&so->so_timeo,
				    PSOCK | PCATCH, "soclos", so->so_linger,
				    so->so_state & SS_SLEEPTW);
				if (error)
					break;
			}
a211 1
		panic("soclose: NOFDREF");
a218 4
/*
 * Must be called at splnet...
 */
int
a227 1
int
a243 1
int
a267 1
int
a278 1
int
d299 1
a299 20
#define	SBLOCKWAIT(f)	(((f) & MSG_DONTWAIT) ? M_NOWAIT : M_WAITOK)
/*
 * Send on a socket.
 * If send must go all at once and message is larger than
 * send buffering, then hard error.
 * Lock against other senders.
 * If must go all at once and not enough room now, then
 * inform user that this would block and do nothing.
 * Otherwise, if nonblocking, send as much as possible.
 * The data to be sent is described by "uio" if nonzero,
 * otherwise by the mbuf chain "top" (which must be null
 * if uio is not).  Data provided in mbuf chain must be small
 * enough to send all at once.
 *
 * Returns nonzero on error, timeout or signal; callers
 * must check for short counts if EINTR/ERESTART are returned.
 * Data and control buffers are freed on return.
 */
int
sosend(so, addr, uio, top, control, flags)
d301 2
a302 4
	struct mbuf *addr;
	struct uio *uio;
	struct mbuf *top;
	struct mbuf *control;
d304 1
d306 4
a309 8
#ifndef __riscos
	struct proc *p = curproc;		/* XXX */
#endif
	struct mbuf **mp;
	register struct mbuf *m;
	register long space, len, resid;
	int clen = 0, error, dontroute, mlen;
	int atomic = sosendallatonce(so) || top;
a310 13
	if (uio)
		resid = uio->uio_resid;
	else
		resid = top->m_pkthdr.len;
	/*
	 * In theory resid should be unsigned.
	 * However, space must be signed, as it might be less than 0
	 * if we over-committed, and we must use a signed comparison
	 * of space and resid.  On the other hand, a negative resid
	 * causes us to loop sending 0-length segments to the protocol.
	 */
	if (resid < 0)
		return (EINVAL);
a313 6
#ifndef __riscos
	p->p_stats->p_ru.ru_msgsnd++;
#endif
	if (control)
		clen = control->m_len;
#define	snderr(errno)	{ error = errno; goto release; }
a319 8
#ifdef __riscos
	/*
	 * Super-hack that saves a data copy using unsafe mbufs. This relies
	 * on
	 *      1) UDP being the only SOCK_DGRAM protocol
	 *      2) IP ensuring_safe anything it doesn't send straight to the
	 *         driver (ie when waiting for ARP resolution)
	 */
a320 2
		struct iovec *iov;

d322 1
a322 3
			snderr(EPIPE);
		if (so->so_error)
		    	snderr(so->so_error);
d325 3
a327 3
				  snderr(ENOTCONN);
			if (addr == 0)
				  snderr(EDESTADDRREQ);
d329 1
a329 3
		error = sblock(&so->so_snd, SBLOCKWAIT(flags));
		if (error)
			goto out;
d333 17
d352 2
a353 1
		    if ((m = ALLOC_U(iov->iov_len, iov->iov_base)) == NULL) {
d355 1
a355 1
			if ( DODEBUG(DBGMMAN))
d367 1
a368 3
		top->m_flags = M_PKTHDR;
		top->m_pkthdr.len = resid;
		top->m_pkthdr.rcvif = (struct ifnet *)0;
d373 1
a373 1
			top, addr, control);
d380 6
a385 1
#endif
d387 1
a387 3
	error = sblock(&so->so_snd, SBLOCKWAIT(flags));
	if (error)
		goto out;
d391 5
a395 2
		if (so->so_error)
		    	snderr(so->so_error);
d397 4
a400 14
			/*
			 * `sendto' and `sendmsg' is allowed on a connection-
			 * based socket if it supports implied connect.
			 * Return ENOTCONN if not connected and no address is
			 * supplied.
			 */
			if ((so->so_proto->pr_flags & PR_CONNREQUIRED) &&
			    (so->so_proto->pr_flags & PR_IMPLOPCL) == 0) {
				if ((so->so_state & SS_ISCONFIRMING) == 0 &&
				    !(resid == 0 && clen != 0))
					snderr(ENOTCONN);
			} else if (addr == 0)
			    snderr(so->so_proto->pr_flags & PR_CONNREQUIRED ?
				   ENOTCONN : EDESTADDRREQ);
a401 1
		space = sbspace(&so->so_snd);
d403 16
a418 13
			space += 1024;
		if ((atomic && resid > so->so_snd.sb_hiwat) ||
		    clen > so->so_snd.sb_hiwat)
			snderr(EMSGSIZE);
		if (space < resid + clen && uio &&
		    (atomic || space < so->so_snd.sb_lowat || space < clen)) {
			if (so->so_state & SS_NBIO)
				snderr(EWOULDBLOCK);
			sbunlock(&so->so_snd);
			error = sbwait(&so->so_snd, so->so_state & SS_SLEEPTW);
			if (error)
				goto out;
			goto restart;
d421 7
a427 17
		space -= clen;
		do {
		    if (uio == NULL) {
			/*
			 * Data is prepackaged in "top".
			 */
			resid = 0;
			if (flags & MSG_EOR)
				top->m_flags |= M_EOR;
		    } else {
		        len = min(resid, space);
			top = ALLOC(len, NULL);
			if (top == 0) {
				m_reclaim();
				top = ALLOC(len, NULL);
				if (top == 0)
					snderr(ENOBUFS);
d429 1
a429 9
			top->m_flags = M_PKTHDR;
			top->m_pkthdr.len = len;
			top->m_pkthdr.rcvif = (struct ifnet *)0;
			/*
			 * For datagram protocols, leave room
			 * for protocol headers in first mbuf.
			 */
			if (atomic && len < MLEN(top))
				MH_ALIGN(top, len);
d431 41
a471 11
			for (m = top; m; m = m->m_next) {
				m->m_type = MT_DATA;
				mlen = min(len, MLEN(m));
				uiomove(mtod(m, caddr_t), (int)mlen, uio);
				m->m_len = mlen;
				len -= mlen;
			}
			resid = uio->uio_resid;
			if (resid <= 0)
				if (flags & MSG_EOR)
					top->m_flags |= M_EOR;
d473 16
a488 23
		    if (dontroute)
			    so->so_options |= SO_DONTROUTE;
		    error = (*so->so_proto->pr_usrreq)(so,
			(flags & MSG_OOB) ? PRU_SENDOOB :
			/*
			 * If the user set MSG_EOF, the protocol
			 * understands this flag and nothing left to
			 * send then use PRU_SEND_EOF instead of PRU_SEND.
			 */
			((flags & MSG_EOF) &&
			 (so->so_proto->pr_flags & PR_IMPLOPCL) &&
			 (resid <= 0)) ?
				PRU_SEND_EOF : PRU_SEND,
			top, addr, control);
		    if (dontroute)
			    so->so_options &= ~SO_DONTROUTE;
		    clen = 0;
		    control = 0;
		    top = 0;
		    if (error)
			goto release;
		} while (resid && space > 0);
	} while (resid);
a491 1
out:
d493 8
a500 4
	    	m_freem(top);
	if (control)
		m_freem(control);
	return(error);
d503 1
a503 18
/*
 * Implement receive operations on a socket.
 * We depend on the way that records are added to the sockbuf
 * by sbappend*.  In particular, each record (mbufs linked through m_next)
 * must begin with an address if the protocol so specifies,
 * followed by an optional mbuf or mbufs containing ancillary data,
 * and then zero or more mbufs of data.
 * In order to avoid blocking network interrupts for the entire time here,
 * we splx() while doing the actual copy to user space.
 * Although the sockbuf is locked, new data may still be appended,
 * and thus we must maintain consistency of the sockbuf during that time.
 *
 * The caller may receive the data as a single mbuf chain by supplying
 * an mbuf **mp0 for use in returning the chain.  The uio is then used
 * only for the count in uio_resid.
 */
int
soreceive(so, paddr, uio, mp0, controlp, flagsp)
d505 4
a508 5
	struct mbuf **paddr;
	struct uio *uio;
	struct mbuf **mp0;
	struct mbuf **controlp;
	int *flagsp;
d510 2
a511 2
	register struct mbuf *m, **mp;
	register int flags, len, error, offset;
d514 1
a514 2
	int moff, type = 0;
	int orig_resid = uio->uio_resid;
d516 4
a519 13
#ifdef DEBUG2
        Printf("soreceive(): so=%x, &so->so_rcv=%x, so->so_rcv.sb_cc=%d, &so->so_snd=%x\n",
                so, &so->so_rcv, so->so_rcv.sb_cc, &so->so_snd);
#endif
	mp = mp0;
	if (paddr)
		*paddr = 0;
	if (controlp)
		*controlp = 0;
	if (flagsp)
		flags = *flagsp &~ MSG_EOR;
	else
		flags = 0;
d521 1
d523 3
a525 3
		if (m == NULL) {
		    	error=ENOBUFS;
		    	goto bad;
d527 12
d544 14
a557 3
			error = uiomove(mtod(m, caddr_t),
			    (int) min(uio->uio_resid, m->m_len), uio);
			m = m_freen(m);
d561 7
a567 1
			m_freem(m);
a569 5
	if (mp)
		*mp = (struct mbuf *)0;
	if (so->so_state & SS_ISCONFIRMING && uio->uio_resid)
		(*pr->pr_usrreq)(so, PRU_RCVD, (struct mbuf *)0,
		    (struct mbuf *)0, (struct mbuf *)0);
d572 2
a573 28
	error = sblock(&so->so_rcv, SBLOCKWAIT(flags));
	if (error)
		return (error);

	m = so->so_rcv.sb_mb;
	/*
	 * If we have less data than requested, block awaiting more
	 * (subject to any timeout) if:
	 *   1. the current count is less than the low water mark, or
	 *   2. MSG_WAITALL is set, and it is possible to do the entire
	 *	receive operation at once if we block (resid <= hiwat).
	 *   3. MSG_DONTWAIT is not set
	 * If MSG_WAITALL is set but resid is larger than the receive buffer,
	 * we have to do the receive in sections, and thus risk returning
	 * a short count if a timeout or signal occurs after we start.
	 */

	if (m == 0 || (((flags & MSG_DONTWAIT) == 0 &&
	    so->so_rcv.sb_cc < uio->uio_resid) &&
	    (so->so_rcv.sb_cc < so->so_rcv.sb_lowat ||
	    ((flags & MSG_WAITALL) && uio->uio_resid <= so->so_rcv.sb_hiwat)) &&
	    m->m_nextpkt == 0 && (pr->pr_flags & PR_ATOMIC) == 0)) {
#ifdef DIAGNOSTIC
		if (m == 0 && so->so_rcv.sb_cc) {
			panic("receive 1");
			return (EFAULT);
		}
#endif
a574 2
			if (m)
				goto dontblock;
d576 1
a576 2
			if ((flags & MSG_PEEK) == 0)
				so->so_error = 0;
d579 3
a581 12
		if (so->so_state & SS_CANTRCVMORE) {
			if (m)
				goto dontblock;
			else
				goto release;
		}
		for (; m; m = m->m_next)
			if (m->m_type == MT_OOBDATA  || (m->m_flags & M_EOR)) {
				m = so->so_rcv.sb_mb;
				goto dontblock;
			}
		if ((so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING)) == 0 &&
d588 1
a588 1
		if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT)) {
a589 3
#if 0
                        Printf("soreceive: returning EWOULDBLOCK; so->so_rcv.sb_cc=%d, so->so_rcv.sb_lowat=%d\n", so->so_rcv.sb_cc, so->so_rcv.sb_lowat);
#endif
d593 2
a594 3
		error = sbwait(&so->so_rcv, so->so_state & SS_SLEEPTW);
		if (error)
			return (error);
d597 6
a602 6
dontblock:
#ifndef __riscos
	if (uio->uio_procp)
		uio->uio_procp->p_stats->p_ru.ru_msgrcv++;
#endif
	nextrecord = m->m_nextpkt;
d604 1
a604 2
#ifdef DIAGNOSTIC
		if (m->m_type != MT_SONAME) {
d606 7
a612 2
			return (EFAULT);
		}
d614 1
a614 4
		orig_resid = 0;
		if (flags & MSG_PEEK) {
			if (paddr)
				*paddr = m_copy(m, 0, m->m_len);
d618 5
a622 5
			if (paddr) {
				*paddr = m;
				so->so_rcv.sb_mb = m->m_next;
				m->m_next = 0;
				m = so->so_rcv.sb_mb;
d627 2
d631 5
a635 1
	while (m && m->m_type == MT_CONTROL && error == 0) {
d637 8
a644 2
			if (controlp)
				*controlp = m_copy(m, 0, m->m_len);
d648 2
a649 6
			if (controlp) {
				if (pr->pr_domain->dom_externalize &&
				    mtod(m, struct cmsghdr *)->cmsg_type ==
				    SCM_RIGHTS)
				   error = (*pr->pr_domain->dom_externalize)(m);
				*controlp = m;
d657 2
a658 4
		}
		if (controlp) {
			orig_resid = 0;
			controlp = &(*controlp)->m_next;
a660 7
	if (m) {
		if ((flags & MSG_PEEK) == 0)
			m->m_nextpkt = nextrecord;
		type = m->m_type;
		if (type == MT_OOBDATA)
			flags |= MSG_OOB;
	}
d664 7
a670 2
		if (m->m_type == MT_OOBDATA) {
			if (type != MT_OOBDATA)
d672 15
a686 6
		} else if (type == MT_OOBDATA)
			break;
#ifdef DIAGNOSTIC
		else if (m->m_type != MT_DATA && m->m_type != MT_HEADER) {
			panic("receive 3");
			return (EFAULT);
d688 1
a688 1
#endif
a689 1
		len = uio->uio_resid;
d694 2
a695 12
		/*
		 * If mp is set, just pass back the mbufs.
		 * Otherwise copy them out via the uio, then free.
		 * Sockbuf must be consistent here (points to current mbuf,
		 * it points to next record) when we drop priority;
		 * we must note any additions to the sockbuf when we
		 * block interrupts again.
		 */
		if (mp == 0) {
			error = uiomove(mtod(m, caddr_t) + moff, (int)len, uio);
		} else
			uio->uio_resid -= len;
a696 2
			if (m->m_flags & M_EOR)
				flags |= MSG_EOR;
d701 1
a701 1
				nextrecord = m->m_nextpkt;
d703 2
a704 9
				if (mp) {
					*mp = m;
					mp = &m->m_next;
					so->so_rcv.sb_mb = m = m->m_next;
					*mp = (struct mbuf *)0;
				} else {
					MFREE(m, so->so_rcv.sb_mb);
					m = so->so_rcv.sb_mb;
				}
d706 1
a706 1
					m->m_nextpkt = nextrecord;
a711 2
				if (mp)
					*mp = m_copym(m, 0, len, M_WAIT);
d724 1
a724 1
			} else {
a725 25
				if (offset == so->so_oobmark)
					break;
			}
		}
		if (flags & MSG_EOR)
			break;
		/*
		 * If the MSG_WAITALL flag is set (for non-atomic socket),
		 * we must not quit until "uio->uio_resid == 0" or an error
		 * termination.  If a signal/timeout occurs, return
		 * with a short count but without error.
		 * Keep sockbuf locked against other readers.
		 */
		while (flags & MSG_WAITALL && m == 0 && uio->uio_resid > 0 &&
		    !sosendallatonce(so) && !nextrecord) {
			if (so->so_error || so->so_state & SS_CANTRCVMORE)
				break;
			error = sbwait(&so->so_rcv, so->so_state & SS_SLEEPTW);
			if (error) {
				sbunlock(&so->so_rcv);
				return (0);
			}
			m = so->so_rcv.sb_mb;
			if (m)
				nextrecord = m->m_nextpkt;
a727 6

	if (m && pr->pr_flags & PR_ATOMIC) {
		flags |= MSG_TRUNC;
		if ((flags & MSG_PEEK) == 0)
			(void) sbdroprecord(&so->so_rcv);
	}
d731 2
d735 4
a738 1
			    (struct mbuf *)flags, (struct mbuf *)0);
a739 8
	if (orig_resid == uio->uio_resid && orig_resid &&
	    (flags & MSG_EOR) == 0 && (so->so_state & SS_CANTRCVMORE) == 0) {
		sbunlock(&so->so_rcv);
		goto restart;
	}

	if (flagsp)
		*flagsp |= flags;
a744 1
int
a759 1
void
d783 1
a783 2
	sb->sb_flags |= SB_NOINTR;
	sblock(sb, M_WAITOK);
a797 1
int
a827 1
		case SO_REUSEPORT:
d843 2
a866 22
			}
			break;

		case SO_SNDTIMEO:
		case SO_RCVTIMEO:
		    {
			struct timeval *tv;
			short val;

			if (m == NULL || m->m_len < sizeof (*tv)) {
				error = EINVAL;
				goto bad;
			}
			tv = mtod(m, struct timeval *);
			if (tv->tv_sec > SHRT_MAX / hz - hz) {
				error = EDOM;
				goto bad;
			}
			val = tv->tv_sec * hz + tv->tv_usec / tick;

			switch (optname) {

d868 1
a868 1
				so->so_snd.sb_timeo = val;
d871 1
a871 1
				so->so_rcv.sb_timeo = val;
a874 8
		    }

#ifndef __riscos
		case SO_PRIVSTATE:
			/* we don't care what the parameter is... */
			so->so_state &= ~SS_PRIV;
			break;
#endif
a879 5
		if (error == 0 && so->so_proto && so->so_proto->pr_ctloutput) {
			(void) ((*so->so_proto->pr_ctloutput)
				  (PRCO_SETOPT, so, level, optname, &m0));
			m = NULL;	/* freed by protocol */
		}
d883 7
a889 1
		(void) m_free(m);
a892 1
int
d907 1
d909 1
a909 1
		if (m == NULL)
d911 12
a938 1
		case SO_REUSEPORT:
a943 6
#ifndef __riscos
		case SO_PRIVSTATE:
			*mtod(m, int *) = so->so_state & SS_PRIV;
			break;

#endif
d970 3
d974 1
a974 8
		    {
			int val = (optname == SO_SNDTIMEO ?
			     so->so_snd.sb_timeo : so->so_rcv.sb_timeo);

			m->m_len = sizeof(struct timeval);
			mtod(m, struct timeval *)->tv_sec = val / hz;
			mtod(m, struct timeval *)->tv_usec =
			    (val % hz) * tick;
a975 1
		    }
d978 1
d980 3
a989 1
void
d995 3
a997 3
	if (so->so_pgid < 0)
		gsignal(-so->so_pgid, SIGURG);
	else if (so->so_pgid > 0 && (p = pfind(so->so_pgid)) != 0)
d999 5
a1003 1
	selwakeup(&so->so_rcv.sb_sel);
d1005 2
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d8 1
a8 1
 * :RCS Log discontinued:
@

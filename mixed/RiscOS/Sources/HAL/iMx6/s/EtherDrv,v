head	1.10;
access;
symbols
	iMx6-1_01:1.10
	iMx6-1_00:1.9
	iMx6-0_99:1.9
	iMx6-0_98:1.8
	iMx6-0_97:1.7
	iMx6-0_96-1_4_2_12:1.1.1.1.2.4
	iMx6-0_96:1.7
	iMx6-0_90-1_4_2_11:1.1.1.1.2.3
	iMx6-0_95:1.7
	iMx6-0_94:1.6
	iMx6-0_93:1.6
	iMx6-0_92:1.6
	iMx6-0_91:1.6
	iMx6-0_90-1_4_2_10:1.1.1.1.2.3
	iMx6-0_90:1.5
	iMx6-0_87-1_4_2_9:1.1.1.1.2.3
	iMx6-0_89:1.5
	iMx6-0_87-1_4_2_8:1.1.1.1.2.3
	iMx6-0_88:1.5
	iMx6-0_87-1_4_2_7:1.1.1.1.2.3
	iMx6-0_87:1.5
	iMx6-0_82-1_4_2_6:1.1.1.1.2.3
	iMx6-0_86:1.5
	iMx6-0_82-1_4_2_5:1.1.1.1.2.3
	iMx6-0_85:1.5
	iMx6-0_82-1_4_2_4:1.1.1.1.2.3
	iMx6-0_84:1.5
	iMx6-0_83:1.5
	iMx6-0_82-1_4_2_3:1.1.1.1.2.2
	iMx6-0_82:1.4
	iMx6-0_81:1.3
	iMx6-0_80-1_4_2_2:1.1.1.1.2.1
	iMx6-0_80-1_4_2_1:1.1.1.1.2.1
	iMx6-0_80:1.3
	iMx6-0_79:1.2
	SMP:1.1.1.1.0.2
	SMP_bp:1.1.1.1
	iMx6-0_78:1.1.1.1
	iMx6-0_77:1.1.1.1
	iMx6-0_76:1.1.1.1
	iMx6-0_75:1.1.1.1
	Vendor:1.1.1;
locks; strict;
comment	@# @;


1.10
date	2018.08.03.16.03.23;	author jballance;	state Exp;
branches;
next	1.9;
commitid	Ed5fXYSFhc2sUGMA;

1.9
date	2018.07.21.14.22.47;	author jballance;	state Exp;
branches;
next	1.8;
commitid	R8oReQLmQcRRL0LA;

1.8
date	2018.07.20.21.56.56;	author jballance;	state Exp;
branches;
next	1.7;
commitid	NeITGC3Pu4vDjVKA;

1.7
date	2018.06.28.13.46.02;	author jballance;	state Exp;
branches;
next	1.6;
commitid	1dUsazjEHsJ4j3IA;

1.6
date	2018.05.13.22.24.00;	author jballance;	state Exp;
branches;
next	1.5;
commitid	nRyVYjPRWnosEbCA;

1.5
date	2017.08.17.23.05.07;	author jballance;	state Exp;
branches;
next	1.4;
commitid	PKFENWA4mJtEwC3A;

1.4
date	2017.08.04.17.14.41;	author jballance;	state Exp;
branches;
next	1.3;
commitid	kUu5oRdZtEsk0V1A;

1.3
date	2017.07.26.07.36.53;	author jballance;	state Exp;
branches;
next	1.2;
commitid	CyZP0iPCrYQ36I0A;

1.2
date	2017.07.18.12.58.16;	author jballance;	state Exp;
branches;
next	1.1;
commitid	uFhk8BbHvz6h8IZz;

1.1
date	2017.01.20.01.46.53;	author jballance;	state Exp;
branches
	1.1.1.1;
next	;
commitid	SZe1LdhMuDPoaECz;

1.1.1.1
date	2017.01.20.01.46.53;	author jballance;	state Exp;
branches
	1.1.1.1.2.1;
next	;
commitid	SZe1LdhMuDPoaECz;

1.1.1.1.2.1
date	2017.07.29.12.02.16;	author jlee;	state Exp;
branches;
next	1.1.1.1.2.2;
commitid	dFmrZN3Yw5D7t71A;

1.1.1.1.2.2
date	2017.08.08.18.30.46;	author jlee;	state Exp;
branches;
next	1.1.1.1.2.3;
commitid	60vgLLklxfzsir2A;

1.1.1.1.2.3
date	2017.08.30.21.20.19;	author jballance;	state Exp;
branches;
next	1.1.1.1.2.4;
commitid	YZXuPCIXaffNwh5A;

1.1.1.1.2.4
date	2018.07.07.16.18.11;	author jlee;	state Exp;
branches;
next	;
commitid	UfrPnz2V1LPlRdJA;


desc
@@


1.10
log
@  Changes to ethernet phy detection
Detail:
  Recent changes, which used active pin control when releasing the phy
  reset pin, failed to work in the RevD iMx6 boards. Reverted to older method
  for these.
Admin:
  tested in various iMx6 variants

Version 1.01. Tagged as 'iMx6-1_01'
@
text
@; Copyright 2017 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; Initialise ethernet hardware, pins, etc to make device available later

        GET     ListOpts
        GET     Macros
        GET     System
        GET     Machine.<Machine>
        GET     ImageSize.<ImageSize>
        $GetIO

        GET     OSEntries
        GET     HALEntries
        GET     HALDevice
        GET     EtherDevice
        GET     ENET
        GET     Proc

        GET     iMx6q
        GET     StaticWS

        AREA    |Asm$$Code|, CODE, READONLY, PIC
 [ Debug
        IMPORT  DebugHALPrint
        IMPORT  DebugHALPrintReg
        IMPORT  DebugHALPrintByte
 ]
        IMPORT  GPIO_SetAsInput
        IMPORT  GPIO_SetAsOutput
        IMPORT  GPIO_DeviceNumber
        IMPORT  GPIO_SetAndEnableIRQ
        IMPORT  GPIO_DisableIRQ
        IMPORT  GPIO_IRQClear
        IMPORT  GPIO_ReadBit
        IMPORT  GPIO_WriteBit
        IMPORT  GPIO_ReadBitAddr
        IMPORT  memcpy
        IMPORT  udivide

        EXPORT  Ether_Init
        EXPORT  GetIPGClk
        EXPORT  ENET_CheckForPhy

        MACRO
        CallOS  $entry, $tailcall
        ASSERT  $entry <= HighestOSEntry
 [ "$tailcall"=""
        MOV     lr, pc
 |
   [ "$tailcall"<>"tailcall"
        ! 0, "Unrecognised parameter to CallOS"
   ]
 ]
        LDR     pc, OSentries + 4*$entry
        MEND

; For the record this sets up 2 different types of Phy, and accounts for 2 differnt builds
; on iMx6 wandboard  earlier devices had AR8031 phys, but RevD boards use the AR8035
; the CuBox variant also uses the AR8035, but driven through some different pins
; The real 'interest' is in ensuring the Phy config pins are in the correct state when the
; hardware reset pin is released.
; AR8031        AR8035     WandboardB/C pad/GPIO       WandboardD pad/GPIO      CuBox pad/GPIO
; PhyAdd0       PhyAdd0    RGMII_RXD0/6-25             RGMII_RXD0/6-25          RGMII_RXD0/6-25
; PhyAdd1       PhyAdd1    RGMII_RXD1/6-27             RGMII_RXD1/6-27          RGMII_RXD1/6-27
; PhyAdd2       PhyAdd2    LED/ACT                     LED/ACT                  pull down
; Mode0         Mode0      RGMII_RXDV/6-24             RGMII_RXDV/6-24          RGMII_RXDV/6-24
; Mode1         Mode1      RGMII_RXD2/6-28             RGMII_RXD2/6-28          RGMII_RXD2/6-28
; Mode2         Mode2      RGMII_RXClk/6-30            LED1000 pulldown         pull down
; Mode3         Mode3      RGMII_RXD3/6-29             RGMII_RXD3/6-29          RGMII_RXD3/6-29
; IRQSel                   LED1000 pull down           -
;               I/Ovolts                               RGMII_RXClk/6-30         RGMII_RXClk/6-30
;                          
; Additionally, on CuBox  ENET_CRS_DV, ENET_RD0, ENET_RD1 are wired to the config pins, so set as inert

; set up pads and clocks to expose the ethernet hardware
; create the correct HAL device too
Ether_Init
        Entry   "a1-a3"
        ldr     a2, IOMUXC_Base
        bl      Ether_InitPins
        bl      AddEtherTHDevice

        EXIT

; Pin initialisation.. needs done early for Phy config
Ether_InitPins
        Entry   "a1-a3"
        ldr     a2, IOMUXC_Base
 [ CuBox
        ; CuBox phy pad drive is tuned to give best power up config state
        ; for the phy as some strapping isnt provided
        ldr     a3, =IOMuxENETMDIO          ; pad drive stuff
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_MDIO-IOMUXC_BASE_ADDR]     ;
        ldr     a3, =IOMuxENETMDC          ; pad drive stuff
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_MDC-IOMUXC_BASE_ADDR]     ;
        ldr     a3, =IOMuxENETPhyIrq          ; pad drive stuff
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_DI0_PIN2-IOMUXC_BASE_ADDR]
        ldr     a3, =IOMuxENETPhyRST          ; pad drive stuff
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4-IOMUXC_BASE_ADDR]
        ldr     a3, =IOMuxENETHiZPU          ; pad drive stuff
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_CRS_DV-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_RXD0-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_RXD1-IOMUXC_BASE_ADDR]
        ldr     a3, =IOMuxENETRefClkOut          ; pad drive stuff
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_REF_CLK-IOMUXC_BASE_ADDR]  ; enet ref clk ip
        ldr     a3, =IOMuxENETPU          ; pad drive stuff
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD0-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD1-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD2-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD3-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TX_CTL-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]     ;
        ldr     a3, =IOMuxENETPD          ; pad drive stuff
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TXC-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]     ;
 |
        ldr     a3, =IOMuxPadEnet             ; pad drive stuff other ENET
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_MDC-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_MDIO-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_REF_CLK-IOMUXC_BASE_ADDR]  ; enet ref clk ip
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_EIM_D29-IOMUXC_BASE_ADDR]       ; phy nrst
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_GPIO_18-IOMUXC_BASE_ADDR]       ; D1 phy power

        ldr     a3, =IOMuxPadRGMII             ; pad drive stuff RGMII
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD0-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD1-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD2-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD3-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TXC-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TX_CTL-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]     ;
  ]

        mov     a3, #0          ; select daisychain stuff for RGMII mode
        str     a3, [a2,#IOMUXC_ENET_IPP_IND_MAC0_MDIO_SELECT_INPUT-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_ENET_IPP_IND_MAC0_RXCLK_SELECT_INPUT-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_ENET_IPP_IND_MAC0_RXDATA_0_SELECT_INPUT-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_ENET_IPP_IND_MAC0_RXDATA_1_SELECT_INPUT-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_ENET_IPP_IND_MAC0_RXDATA_2_SELECT_INPUT-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_ENET_IPP_IND_MAC0_RXDATA_3_SELECT_INPUT-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_ENET_IPP_IND_MAC0_RXEN_SELECT_INPUT-IOMUXC_BASE_ADDR]

        mov     a3, #1                  ; alt 1, sion off
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_MDIO-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_MDC-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TXC-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TD0-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TD1-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TD2-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TD3-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TX_CTL-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_REF_CLK-IOMUXC_BASE_ADDR]   ; enet tx clk
 [ CuBox
        mov     a3, #&2                  ; alt 2, sion off
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_GPIO_16-IOMUXC_BASE_ADDR]       ; send enet clock
        mov     a3, #SEL_GPIO_16_ALT2
        str     a3, [a2,#IOMUXC_ENET_IPG_CLK_RMII_SELECT_INPUT-IOMUXC_BASE_ADDR]     ;enet clk

        mov     a3, #5
; these are patched across to the rgmii lines, so set as input (hence inert)
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_CRS_DV-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_RXD0-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_RXD1-IOMUXC_BASE_ADDR]
        mov     a1, #(1<<5) + 25
        bl      GPIO_SetAsInput                 ; GPIO1 bit 25 (linked to mode0)
        mov     a1, #(1<<5) + 26
        bl      GPIO_SetAsInput                 ; GPIO1 bit 26 (linked to Phyadd0)
        mov     a1, #(1<<5) + 27
        bl      GPIO_SetAsInput                 ; GPIO1 bit 27 (linked to PhyAdd1)

 |
        mov     a3, #SEL_RGMII_TX_CTL_ALT7
        str     a3, [a2,#IOMUXC_ENET_IPG_CLK_RMII_SELECT_INPUT-IOMUXC_BASE_ADDR]     ;enet clk
 ]
        mov     a3, #5
 [ CuBox
                                        ; alt 5, sion off route RGMII_IRQ to GPIO4_IO18
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_DI0_PIN2-IOMUXC_BASE_ADDR]
                                        ; alt 5 GPIO4_IO15 drives RGMII_nrst  GPIO4_IO15
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4-IOMUXC_BASE_ADDR]
 |
                                        ; alt 5, sion off route RGMII_IRQ to GPIO1_IO28
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_TX_EN-IOMUXC_BASE_ADDR]
                                        ; alt 5 GPIO3_IO29 drives RGMII_nrst
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_EIM_D29-IOMUXC_BASE_ADDR]
                                        ; alt 5 GPIO7_IO13 active low turns on phy on revD1 board
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_GPIO_18-IOMUXC_BASE_ADDR]
 ]

; set phy irq pin as input
 [ CuBox
        mov     a1, #(4<<5) + 18
        bl      GPIO_SetAsInput                 ; GPIO4 bit 18 is irq input
        mov     a1, #(4<<5) + (15) + (0<<8)     ; GPIO4 bit 15 as o/p, val 0 hold reset
        bl      GPIO_SetAsOutput
 |
        mov     a1, #(1<<5) + 28                ; GPIO1 bit 28 is irq input
        bl      GPIO_SetAsInput
        mov     a1, #(3<<5) + (29) + (0<<8)     ; GPIO3 bit 29 as o/p, val 0 hold reset
        bl      GPIO_SetAsOutput
        mov     a1, #(7<<5) + (13) + (1<<8)     ; GPIO7 bit 13 as o/p, val 1 turn off revD1 phy
        bl      GPIO_SetAsOutput
 ]
        mov     a3, #8<<16                      ; 1p2v_io setting
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII-IOMUXC_BASE_ADDR]

        mov     a3, #0                  ; term disabled
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_GRP_RGMII_TERM-IOMUXC_BASE_ADDR]
; enet PLL .. set with care, SATA is dependant on this too
        ldr     a2, CCMAn_Log
        mov     a3, #1<<16              ; bypass pll
        str     a3, [a2,#HW_CCM_ANALOG_PLL_ENET_ADDR]
        mov     a3, #1<<13              ; enable clock o/p, remove bypass
                                        ; (enet ref clk is 25mhz with above)
 [ :LNOT: CuBox
        orr     a3, a3, #1              ; so.. set for 50MHz enet ref clock
 ]
        orr     a3, a3, #1<<20          ; 100MHZ clk en bit (sata)
        str     a3, [a2,#HW_CCM_ANALOG_PLL_ENET_ADDR]
111
        ldr     a3, [a2,#HW_CCM_ANALOG_PLL_ENET_ADDR]
;  DebugReg a3, "pll ready? "
        tst     a3, #1<<31
        beq     %bt111                  ; wait for PLL Lock
        ldr     a2, [sb, #:INDEX:IOMUXC_Base]
        ldr     a3, [a2,#IOMUXC_GPR1-IOMUXC_BASE_ADDR]     ;
        orr     a3, a3, #1<<21                             ; enet ref clock from internal
        str     a3, [a2,#IOMUXC_GPR1-IOMUXC_BASE_ADDR]     ; and o/p signal

        EXIT

; on entry a1 = correct info for GPIO_WriteBit call to clear reset to 1
; assumes sb initialised
PhyResetRelease
        Entry    "a1-a4"
        ldr     a2, IOMUXC_Base
        mov     a4, a1
        eor     a1, a1, #1<<8                             ; toggle to ensure reset asserted
        bl      GPIO_SetAsOutput                          ; ensure we're in reset state
        ; set mode pins to i/o
        mov     a3, #5
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]  ;
; [ CuBox
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]     ; ;;only on cubox. wandboard defaults OK
; ]
        mov     a1, #(6<<5) + (25) + (1<<8)   ; rd0 GPIO6 bit25 as o/p, val 1 hold till Phy reset- Phy address0
        bl      GPIO_SetAsOutput
        mov     a1, #(6<<5) + (27) + (0<<8)   ; rd1 GPIO6 bit27 as o/p, val 0 hold till Phy reset- Phy address1
        bl      GPIO_SetAsOutput
        mov     a1, #(6<<5) + (24) + (0<<8)   ; rxdv GPIO6 bit24  o/p,  val 0 hold till Phy reset- Phy mode0
        bl      GPIO_SetAsOutput
        mov     a1, #(6<<5) + (28) + (0<<8)   ; rd2 GPIO6 bit28 as o/p, val 0 hold till Phy reset- Phy mode1
        bl      GPIO_SetAsOutput
 [ CuBox
        mov     a1, #(6<<5) + (29) + (1<<8)   ; rd3 GPIO6 bit29 as o/p, val 1 hold till Phy reset- Phy mode3
        bl      GPIO_SetAsOutput
        mov     a1, #(6<<5) + (30) + (1<<8)   ; rxc GPIO6 bit30 as o/p, val 1 hold till Phy reset- Phy I/O volts
        bl      GPIO_SetAsOutput
 |
        mov     a1, #(6<<5) + (29) + (0<<8)   ; rd3 GPIO6 bit29 as o/p, val 0 hold till Phy reset- Phy mode3
        bl      GPIO_SetAsOutput
; this pin needs to be 0 for revB and C (ar8033), but 1 for revD (ar8035).
; set for revD if we know its revD, else set for revB/C
;        ldr     a1, BoardDetectInfo           ; phy type flags
;
;        and     a1, a1, #7
;        teq     a1, #1                        ; check for earlier phy type (0)
;
;        moveq   a1, #(6<<5) + (30) + (0<<8)  ; rxc GPIO6 bit30 as o/p, val 0 hold till Phy reset- Phy I/O volts
;        movne   a1, #(6<<5) + (30) + (1<<8)  ; rxc GPIO6 bit30 as o/p, val 1 hold till Phy reset- Phy I/O volts
;        bl      GPIO_SetAsOutput
        ldr     a3, =IOMuxENETHiZPU          ; pad drive stuff
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]
        mov     a1, #(6<<5) + (30)           ; rxc GPIO6 bit30 as i/p, val 1 hold till Phy reset- Phy I/O volts
        bl      GPIO_SetAsInput
 ]
        ; set relevant bits to 0
        ; pause
        ; release reset
        ; revert pins
        Push    "a1-a3"
        MOV     a1, #&1000000                 ; slight delay
1       DMB
        SUBS    a1, a1, #1
        bgt     %bt1                           ; loop a while to let it settle
        Pull    "a1-a3"

        mov     a1, a4                        ; now release the reset pin
        bl      GPIO_SetAsOutput

        Push    "a1-a3"
        MOV     a1, #&1000000                 ; slight delay
1       DMB
        SUBS    a1, a1, #1
        bgt     %bt1                       ; loop a while to let it settle
        Pull    "a1-a3"
        ldr     a2, IOMUXC_Base
        ; revert pins
        ; set relevant bits to i/p
        mov     a1, #(6<<5) + (25)   ; rd0 GPIO6 bit25 as i/p, val 1 hold till Phy reset- Phy address0
        bl      GPIO_SetAsInput
        mov     a1, #(6<<5) + (27)   ; rd1 GPIO6 bit27 as i/p, val 0 hold till Phy reset- Phy address1
        bl      GPIO_SetAsInput
        mov     a1, #(6<<5) + (24)   ; rxdv GPIO6 bit24  i/p,  val 0 hold till Phy reset- Phy mode0
        bl      GPIO_SetAsInput
        mov     a1, #(6<<5) + (28)   ; rd2 GPIO6 bit28 as i/p, val 0 hold till Phy reset- Phy mode1
        bl      GPIO_SetAsInput
        mov     a1, #(6<<5) + (29)   ; rd3 GPIO6 bit29 as i/p, val 1 hold till Phy reset- Phy mode3
        bl      GPIO_SetAsInput
; [ CuBox
        mov     a1, #(6<<5) + (30)   ; rxc GPIO6 bit30 as i/p, val 1 hold till Phy reset- Phy I/O volts
        bl      GPIO_SetAsInput
; ]
 [ :LNOT: CuBox
        ldr     a3, =IOMuxPadRGMII          ; pad drive stuff
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]
 ]
        ; set mode pins to rgmii again
        mov     a3, #1
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]  ;
; [ CuBox
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]     ; ;;only on cubox. wandboard defaults OK
; ]
         EXIT

; See if we can check a RevD board presence by powering up and down the phy
; MUST preserve all registers
; This can be called before any other Ethernet initialisation has taken place..
; need to control all inits...
; assumes sb initialised
ENET_CheckForPhy
        Entry   "a1-a4"
        ldr     a2, IOMUXC_Base
        mov     a1, #01
        str     a1, BoardDetectInfo                        ; init phy type unknown
        bl      Ether_InitPins

; now set all data path pads to GPIO
        mov     a3, #5                  ; alt 5 (GPIO, sion off
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_MDIO-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_MDC-IOMUXC_BASE_ADDR]
 [ CuBox
        mov     a1, #(4<<5) + (15) + (1<<8)    ; val 1, nreset clear
 |
        mov     a1, #(7<<5) + (13) + (0<<8)    ; val 0 turn on revD1 phy
        bl      GPIO_WriteBit

        Push    "a1-a3"
        MOV     a1, #&1000000                  ; slight delay
1       DMB                                 
        SUBS    a1, a1, #1                  
        bgt     %bt1                           ; loop a while to let it settle
        Pull    "a1-a3"

        mov     a1, #(3<<5) + (29) + (1<<8)    ; val 1, nreset clear
 ]
        bl      PhyResetRelease

        ldr     a4, = MDIORdIDL1            ; command to read IDL on phy addr 1
        bl      DoPhyCmd
        ldr     a2, = PhyAR8031
        teq     a2, a4
        moveq   a1, #0
        beq     %ft1
        ldr     a2, = PhyAR8035
        teq     a2, a4
        moveq   a1, #1                     ; flag later Phy detected addr1
        beq     %ft1
        ldr     a4, = MDIORdIDL5           ; command to read IDL on phy addr 5
        bl      DoPhyCmd
        ldr     a2, = PhyAR8031
        teq     a2, a4
        moveq   a1, #5
        beq     %ft1                       ; earlier phy address 5
        ldr     a2, = PhyAR8035
        teq     a2, a4
        moveq   a1, #5                     ; flag later Phy detected addr5
        beq     %ft1
        movne   a1, #7                     ; default later Phy,bad detect addr5

1
        orr     a1, a1, a4, lsl #16
        str     a1, BoardDetectInfo        ; flag appropriately
        and     a1, a1, #4
        add     a1, a1, #1
        str     a1, PhyAddress             ; remember detected address


; restore desired padmux to ethernet
        ldr     a2, IOMUXC_Base
        mov     a3, #1                  ; alt 1, sion off
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_MDIO-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_MDC-IOMUXC_BASE_ADDR]


        EXIT

; Phy address 1
MDIORdIDH1 *     ((2_01)<<30) +((2_10)<<28)+((&1)<<23)+((&2)<<18)+((2_10)<<16) ; ReadID1 (IDH)reg
MDIORdIDL1 *     ((2_01)<<30) +((2_10)<<28)+((&1)<<23)+((&3)<<18)+((2_10)<<16) ; ReadID2 (IDL)reg
; Phy address 5
MDIORdIDH5 *     ((2_01)<<30) +((2_10)<<28)+((&5)<<23)+((&2)<<18)+((2_10)<<16) ; ReadID1 (IDH)reg
MDIORdIDL5 *     ((2_01)<<30) +((2_10)<<28)+((&5)<<23)+((&3)<<18)+((2_10)<<16) ; ReadID2 (IDL)reg

; send command in a4 to Phy, and return response in a4

DoPhyCmd
        Entry   "a1-a3"
        mov     a1, #(1<<5) + (31) + (1<<8)  ; GPIO1 bit 31 val 1 MDC on/hi
        bl      GPIO_SetAsOutput
        mov     a1, #(1<<5) + (22) + (1<<8)  ; GPIO1 bit 22 val 1 MDIO on/hi
        bl      GPIO_SetAsOutput

        mov     a3, #64                    ; need 64 logic 1
11      bl      ClockMDC                   ; rising edge clocks data
        subs    a3, a3, #1
        bgt     %bt11                      ; 64 bit preamble

        mov     a3, #16                    ; 16 bit to write
cmdloop mov     a1, #(1<<5) + (22) + 0<<8  ; GPIO1 bit MDIO databit lo
        movs    a4, a4, lsl #1             ; do we need a 1
        orrcs   a1, a1, #1<<8              ; yes
        bl      GPIO_WriteBit
        bl      ClockMDC                   ; clocked in on rising edge
        subs    a3, a3, #1
        bgt     cmdloop
; now read 16 bits
        mov     a1, #(1<<5) + (22)         ; GPIO1 bit databit as input MDIO
        bl      GPIO_SetAsInput
        mov     a4, #0
        mov     a3, #16
rdloop  mov     a1, #(1<<5) + (22)         ; GPIO1 bit databit as input MDIO
        bl      GPIO_ReadBit               ; returns 1 or 0
        orr     a4, a1, a4, lsl #1         ; build it up
        bl      ClockMDC                   ; rising edge samples data
        subs    a3, a3, #1
        bgt     rdloop
        EXIT


; put out low-hi clock cycle
ClockMDC
        Entry   "a1-a3"
        mov     a1, #(1<<5) + (31) + 0<<8  ; GPIO1 bit 31 val 0  MDC lo
        bl      GPIO_WriteBit
        MOV     a1, #&8                 ; slight delay
13      DMB
        SUBS    a1, a1, #1
        bgt     %bt13                      ; loop a while to let it settle
        mov     a1, #(1<<5) + (31) + 1<<8  ; GPIO1 bit 31 val 1  MDC hi
        bl      GPIO_WriteBit
        MOV     a1, #&8                 ; slight delay
14      DMB
        SUBS    a1, a1, #1
        bgt     %bt14                      ; loop a while to let it settle
        EXIT

; the following 3 entry points are to be invoked from the
; ethernet driver, and have the HAL SB value passed in a2

; a1 = 1 for enable, 0 for disable
; a2 on entry is HAL sb value as taken from the hal device table
EtherTHPhyIRQEn
        Entry   "sb"
        mov     sb, a2
; DebugReg a1, "EPhyIRQa1 "
        teq     a1, #0
 [ CuBox
        mov     a1, #(4<<5) + 18 + (0<<8)       ; active low detect
 |
        mov     a1, #(1<<5) + 28 + (0<<8)       ; active low detect
 ]
        adr     lr, %ft1
        beq     GPIO_DisableIRQ
        b       GPIO_SetAndEnableIRQ
1
        EXIT

EtherTHPhyIRQTest
        Entry   "a1,sb"
        mov     sb, a2
 [ CuBox
        mov     a1, #(4<<5) + 18        ; active low detect
 |
        mov     a1, #(1<<5) + 28        ; active low detect
 ]
        bl      GPIO_ReadBit
        eor     a1, a1, #1                      ; return a 1 if IRQ present
        EXIT

EtherTHPhyIRQClr
        Entry   "sb"
        mov     sb, a2
; DebugTX "EPhyIRQClr"
 [ CuBox
        mov     a1, #(4<<5) + 18        ; active low detect
 |
        mov     a1, #(1<<5) + 28        ; active low detect
 ]
        bl      GPIO_IRQClear
        EXIT

; a1 bit0 = 1 for power enable, 0 for disable
; a1 bit1 = 1 for reset set, 0 for reset clear
; a2 on entry is HAL sb value as taken from the hal device table
; if a1 bit7 set then test call  instead
EtherTHPhyPwrRst
        Entry   "sb"
        mov     sb, a2
        tst     a1, #1<<7
        bne     TestCall
        mov     a3, a1
 [ CuBox
        tst     a3, #1<<1
        movne   a1, #(4<<5) + (15) + (0<<8)       ; val 1, nreset set
        moveq   a1, #(4<<5) + (15) + (1<<8)       ; val 0, nreset clear
        beq     ReleaseReset                      ; more complicated, but done here
 |
        tst     a3, #1<<0
        movne   a1, #(7<<5) + (13) + (0<<8)       ; val 0 turn on revD1 phy
        moveq   a1, #(7<<5) + (13) + (1<<8)       ; val 1 turn off revD1 phy
        bl      GPIO_WriteBit
        tst     a3, #1<<1                         ; resetbit clear request?
        movne   a1, #(3<<5) + (29) + (0<<8)       ; val 1, nreset set
        moveq   a1, #(3<<5) + (29) + (1<<8)       ; val 0, nreset clear
; the 'active' reset release still not happy on wandboard revD
;        beq     ReleaseReset                      ; more complicated, but done here
 ]
        bl      GPIO_WriteBit
        EXIT
; invoke a test call to the Phy Type Presence detect code
TestCall
        bl      ENET_CheckForPhy
        EXIT

; release phy reset pin, ensuring that phy mode pins are correctly held
; a1 = correct info for GPIO_WriteBit call
ReleaseReset
 [ CuBox
        bl      ENET_CheckForPhy   ; check for current phy address
                                   ;  this will release the reset too
 |
        bl      PhyResetRelease
 ]
        EXIT

;
;


AddEtherTHDevice
        Entry   "a3, a4, v1"
        ADRL    v1, EtherTH_Device
        MOV     a1, v1
        ADR     a2, EtherTHDeviceTemplate
        MOV     a3, #HALDevice_ENET_Size
        BL      memcpy
        ldr     a1, ENET_Log
        str     a1, [v1, #ethaddr-EtherTHDeviceTemplate]
 [ CuBox
        mov     a1, #(4<<5) + 18
 |
        mov     a1, #(1<<5) + 28
 ]
        bl      GPIO_DeviceNumber
        str     a1, [v1, #etphyd-EtherTHDeviceTemplate]
 [ CuBox
        mov     a1, #(4<<5)
 |
        mov     a1, #(1<<5)
 ]
        bl      GPIO_ReadBitAddr
        add     a1, a1, #GPIO_ISR_OFFSET-GPIO_DR_OFFSET
        str     a1, [v1, #etrdba-EtherTHDeviceTemplate]
 [ CuBox
        mov     a1, #1<<18      ; create bit test mask
 |
        mov     a1, #1<<28      ; create bit test mask
 ]
        str     a1, [v1, #etrdbn-EtherTHDeviceTemplate]
        bl      GetIPGClk
        str     a1, [v1, #ethclk-EtherTHDeviceTemplate]
        adrl    a1, PhyAddress
        str     a1, [v1, #phyaddr-EtherTHDeviceTemplate]
        str     sb, [v1, #ethws-EtherTHDeviceTemplate]
; DebugReg a1, "Computed Clk  "
; DebugReg v1, "Eth Dev Addr  "
        MOV     a1, #0
        MOV     a2, v1
        CallOS  OS_AddDevice
        EXIT

; Out: a1 = IPG clock rate
GetIPGClk
        Entry   "a2-a4"
        ldr     a1, CCM_Base
        ldr     a4, [a1, #CCM_CBCMR_OFFSET]
        and     a4, a4, #3<<18
        adr     a2, pll2_clocks
        add     a4, a2, a4, lsr #16

        ldr     a2, [a1, #CCM_CBCDR_OFFSET]
; DebugReg a2, "CBCDR  "
; add a1, a1, #CCM_CBCDR_OFFSET
; DebugReg a1, "CBCDR addr  "
        and     a3, a2, #&3<<8          ; ipg_podf bits
        mov     a3, a3, lsr #8
        and     a1, a2, #7<<10          ; ahb_podf bits
        mov     a1, a1, lsr #10
        add     a1, a1, #1
        ldr     a2, [a4]                ; retrieve actual pll2 clock rate
; DebugReg a2, "pll Clk  "
        bl      udivide
; DebugReg a1, "pll Clk 1st div "
        mov     a2, a1
        add     a1, a3, #1
        bl      udivide
        EXIT

pll2_clocks
        DCD     528000000
        DCD     396000000
        DCD     352000000
        DCD     198000000

EtherTHDeviceTemplate
        DCW     HALDeviceType_Comms + HALDeviceComms_EtherNIC
        DCW     HALDeviceID_EtherNIC_IMX6
        DCD     HALDeviceBus_Sys + HALDeviceSysBus_AXI
        DCD     0               ; API version 0
        DCD     EtherTHDevice_Desc
ethaddr DCD     0               ; Address - filled in later
        %       12              ; Reserved
        DCD     EtherTHDevice_Activate
        DCD     EtherTHDevice_Deactivate
        DCD     EtherTHDevice_Reset
        DCD     EtherTHDevice_Sleep
        DCD     IMX_INT_ENET    ; Device interrupt
        DCD     0               ; TestIRQ cannot be called
        DCD     0               ; ClrIRQ cannot be called
        %       4               ; reserved
        ASSERT (. - EtherTHDeviceTemplate) = HALDeviceSize
etphyd  DCD     0                       ; IRQ dev number for phy irq (shared)
        DCD     EtherTHPhyIRQEn         ; phy irq enable/disable
        DCD     EtherTHPhyIRQTest       ; phy irq test active
        DCD     EtherTHPhyIRQClr        ; phy irq acknowledge
                                        ; (still need a HAL_IRQClr)
etrdba  DCD     0                       ; irq active bit test address
etrdbn  DCD     0                       ; irq active bit test bit
ethws   DCD     0               ; HAL workspace pointer - filled in later
ethclk  DCD     0               ; ethernet clock - filled later
        DCD     EtherTHPhyPwrRst        ; phy power enable and reset
phyaddr DCD     0                       ; pointer to Phy address (e.g. 1 or 5)
        ASSERT (. - EtherTHDeviceTemplate) = HALDevice_ENET_Size

EtherTHDevice_Desc
        =       "iMx6 ethernet controller", 0
        ALIGN

EtherTHDevice_Activate
        Entry   "sb"
        MOV     a1, #1
        EXIT

EtherTHDevice_Deactivate
EtherTHDevice_Reset
        MOV     pc, lr

EtherTHDevice_Sleep
        MOV     a1, #0
        MOV     pc, lr




        END
@


1.9
log
@  Cleaned up standard ethernet hal startup
Detail:
  Resolved omission in earlier commit
Admin:
  Tested on iMx6

Version 0.99. Tagged as 'iMx6-0_99'
@
text
@d274 1
a274 1
 [ CuBox
d276 2
a277 2
 ]
        mov     a1, #(6<<5) + (25) + (1<<8)   ; rd0 GPIO6 bit25 as i/p, val 1 hold till Phy reset- Phy address0
d279 1
a279 1
        mov     a1, #(6<<5) + (27) + (0<<8)   ; rd1 GPIO6 bit27 as i/p, val 0 hold till Phy reset- Phy address1
d281 1
a281 1
        mov     a1, #(6<<5) + (24) + (0<<8)   ; rxdv GPIO6 bit24  i/p,  val 0 hold till Phy reset- Phy mode0
d283 1
a283 1
        mov     a1, #(6<<5) + (28) + (0<<8)   ; rd2 GPIO6 bit28 as i/p, val 0 hold till Phy reset- Phy mode1
d286 1
a286 1
        mov     a1, #(6<<5) + (29) + (1<<8)   ; rd3 GPIO6 bit29 as i/p, val 1 hold till Phy reset- Phy mode3
d288 1
a288 1
        mov     a1, #(6<<5) + (30) + (1<<8)   ; rxc GPIO6 bit30 as i/p, val 1 hold till Phy reset- Phy I/O volts
d291 1
a291 1
        mov     a1, #(6<<5) + (29) + (0<<8)   ; rd3 GPIO6 bit29 as i/p, val 0 hold till Phy reset- Phy mode3
d293 14
d319 1
a319 1
        mov     a1, a4
d341 1
a341 1
 [ CuBox
d344 4
d356 1
a356 1
 [ CuBox
d358 1
a358 1
 ]
d369 2
d561 2
a562 1
        beq     ReleaseReset                      ; more complicated, but done here
@


1.8
log
@  Make HAL Ethernet chip detection detect incorrect phy POR address
Detail:
  Some devices do not stabilise one of the phy configuration pins
  whilst the phy is being reset. As a result it might come up with one
  of 2 different addresses. The HAL now detects this and propagates the
  correct phy address via the Ethernet HAL_Device
Admin:
  tested on iMx6

Version 0.98. Tagged as 'iMx6-0_98'
@
text
@a133 2
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_REF_CLK-IOMUXC_BASE_ADDR]  ; enet ref clk ip
        ldr     a3, =IOMuxPadEnet             ; pad drive stuff other ENET
d136 1
d285 1
a287 1
 [ CuBox
d290 3
d553 1
d555 4
a558 1
                                   ;  this will release the reset too 
d667 1
a667 1
phyaddr DCD     0                       ; Phy address, 1 or 5
@


1.7
log
@  Improved Phy detection and hardware reset. More variant awareness.
Detail:
  There are 2 Phy types, AR8031 and AR8035. Each has slightly different
  configuration strappings as reset is released. Manage this appropriately.
Admin:
  Tested in iMx6

Version 0.95. Tagged as 'iMx6-0_95'
@
text
@a28 1
;        GET     NewErrors
d69 17
a85 1

d97 1
a97 1
; Pin initialisation.. needs domne early for Phy config
a100 37
; [ CuBox
;        ; CuBox relies on relevant PU and PD to provide mode strapping for Phy
;        ldr     a3, =IOMuxENETMDIO
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_MDIO-IOMUXC_BASE_ADDR]     ;
;
;        ldr     a3, =IOMuxENETMDC
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_MDC-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_DI0_PIN2-IOMUXC_BASE_ADDR]
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_GPIO_16-IOMUXC_BASE_ADDR]      ; enet clk
;
;        ldr     a3, =IOMuxENETPhyIrq
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4-IOMUXC_BASE_ADDR]     ; phy nrst
;
;        ldr     a3, =IOMuxENETRefClk
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_REF_CLK-IOMUXC_BASE_ADDR]  ; enet ref clk ip
;
;        ldr     a3, =IOMuxENETPD
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TXC-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]     ;
;
;        ldr     a3, =IOMuxENETPU
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD0-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD1-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD2-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD3-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TX_CTL-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]     ;
;        ldr     a3, =IOMuxENETHiZPU
;; these are patched across to the rgmii lines, so set as input (hence inert)
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_CRS_DV-IOMUXC_BASE_ADDR]
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_RXD0-IOMUXC_BASE_ADDR]
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_RXD1-IOMUXC_BASE_ADDR]
; |
d102 30
a131 1
        ldr     a3, =IOMuxENETRefClk             ; pad drive stuff
a133 1
 ]
a137 1
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_REF_CLK-IOMUXC_BASE_ADDR]  ; enet ref clk ip
d154 2
a155 1
; ]
d192 2
a193 4
        mov     a1, #(1<<5) + 24
        bl      GPIO_SetAsInput                 ; GPIO1 bit 25 (to mode0)
        mov     a1, #(1<<5) + 22
        bl      GPIO_SetAsInput                 ; GPIO1 bit 27 (to Phyadd0)
d195 3
a197 1
        bl      GPIO_SetAsInput                 ; GPIO1 bit 26 (to PhyAdd1)
d260 1
a260 1
; on entry a1 = correct info for GPIO_WriteBit call to clear reset
d266 1
a266 1
        eor     a1, a1, #1<<8
d274 1
d276 1
a276 1
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]     ;
d278 13
a290 21
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]     ;
        ; set relevant bits to o/p 0
        mov     a1, #(6<<5) + (25) + (1<<8)  ; rd0 GPIO6 bit25 as o/p, val 1 hold till Phy reset - Phy address0
        bl      GPIO_SetAsOutput                   
        mov     a1, #(6<<5) + (27) + (0<<8)  ; rd1 GPIO6 bit27 as o/p, val 0 hold till Phy reset  - Phy address1
        bl      GPIO_SetAsOutput                   
        mov     a1, #(6<<5) + (24) + (0<<8)  ; rxctl GPIO6 bit24  o/p, val 0 hold till Phy reset - Phy mode0
        bl      GPIO_SetAsOutput                   
        mov     a1, #(6<<5) + (28) + (0<<8)  ; rd2 GPIO6 bit28 as o/p, val 0 hold till Phy reset - Phy mode1
        bl      GPIO_SetAsOutput                   
 [ CuBox                                           
        mov     a1, #(6<<5) + (29) + (1<<8)  ; rxc GPIO6 bit29 as o/p, val 1 hold till Phy reset - Phy I/O volts
        bl      GPIO_SetAsOutput                   
 |
                                             ; rxc GPIO6 bit29 as o/p, val 1 hold till Phy reset - Phy mode2 AR8031
                                             ; rxc GPIO6 bit29 as o/p, val 1 hold till Phy reset - Phy I/O volts AR8035
 ]
  [ CuBox                                           
       mov     a1, #(6<<5) + (30) + (1<<8)  ; rd3 GPIO6 bit30 as o/p, val 1 hold till Phy reset - Phy mode3
 |
       mov     a1, #(6<<5) + (30) + (0<<8)  ; rd3 GPIO6 bit30 as o/p, val 0 hold till Phy reset - Phy mode3
a291 1
        bl      GPIO_SetAsOutput
d304 1
a304 1
        bl      GPIO_WriteBit
d315 1
a315 1
        mov     a1, #(6<<5) + (25)       ; GPIO6 bit25 i/p, - Phy address0
d317 1
a317 1
        mov     a1, #(6<<5) + (27)       ; GPIO6 bit27 i/p,  - Phy address1
d319 1
a319 1
        mov     a1, #(6<<5) + (24)       ; l GPIO6 bit24 i/p,  - Phy mode0
d321 3
a323 1
        mov     a1, #(6<<5) + (28)       ; GPIO6 bit28 i/p,  - Phy mode1
d326 1
a326 1
        mov     a1, #(6<<5) + (29)       ; GPIO6 bit29 i/p,  - Phy mode2
a328 2
        mov     a1, #(6<<5) + (30)       ; GPIO6 bit30 i/p,  - Phy mode3
        bl      GPIO_SetAsInput
a334 1
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]     ;
d336 4
a339 1
        EXIT
a354 8
; [ CuBox
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4-IOMUXC_BASE_ADDR]     ;phy nrst
; |
;                                        ; alt 5 GPIO3_IO29 drives RGMII_nrst
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_EIM_D29-IOMUXC_BASE_ADDR]     ;
;                                        ; alt 5 GPIO7_IO13 active low turns on phy on revD1 board
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_GPIO_18-IOMUXC_BASE_ADDR]      ;
; ]
a370 88
; [ CuBox
;        ; cubox needs to set the state of the mode pins before releasing the reset line, so..
;        ; so..
;        ; set reset on
;        mov     a1, #(4<<5) + (15) + (0<<8)      ; GPIO4 bit15 as o/p, val 0 hold Phy reset
;        bl      GPIO_SetAsOutput
;        ; set mode pins to i/o
;        mov     a3, #5
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]     ;
;
;
;        ; set relevant bits to o/p 0
;        mov     a1, #(6<<5) + (25) + (1<<8)      ; GPIO6 bit25 as o/p, val 1 hold till Phy reset - Phy address0
;        bl      GPIO_SetAsOutput
;        mov     a1, #(6<<5) + (27) + (0<<8)      ; GPIO6 bit27 as o/p, val 0 hold till Phy reset  - Phy address1
;        bl      GPIO_SetAsOutput
;        mov     a1, #(6<<5) + (24) + (0<<8)      ; GPIO6 bit24 as o/p, val 0 hold till Phy reset - Phy mode0
;        bl      GPIO_SetAsOutput
;        mov     a1, #(6<<5) + (28) + (0<<8)      ; GPIO6 bit28 as o/p, val 0 hold till Phy reset - Phy mode1
;        bl      GPIO_SetAsOutput
;        mov     a1, #(6<<5) + (29) + (0<<8)      ; GPIO6 bit29 as o/p, val 0 hold till Phy reset - Phy mode2
;        bl      GPIO_SetAsOutput
;        mov     a1, #(6<<5) + (30) + (0<<8)      ; GPIO6 bit30 as o/p, val 0 hold till Phy reset - Phy mode3
;        bl      GPIO_SetAsOutput
;        ; set relevant bits to 0
;        ; pause
;        ; release reset
;        ; revert pins
; |
;        mov     a1, #(3<<5) + (29) + (0<<8)      ; GPIO3 bit 29 as o/p, val 0 hold Phy reset
;        bl      GPIO_SetAsOutput
;        mov     a1, #(7<<5) + (13) + (0<<8)      ; GPIO7 bit 13 as o/p, val 0 turn on revD1 phy
;        bl      GPIO_SetAsOutput
;
;;        mov     a1, #(7<<5) + (13) + (0<<8)  ; GPIO7 bit 13 val 0 turn on revD1 phy
;;        bl      GPIO_WriteBit           ; **** test temp
; ]
;
;        Push    "a1-a3"
;        MOV     a1, #&1000000                 ; slight delay
;1       DMB
;        SUBS    a1, a1, #1
;        bgt     %bt1                       ; loop a while to let it settle
;        Pull    "a1-a3"
;
; [ CuBox
;        ; release reset
;        mov     a1, #(4<<5) + (15) + 1<<8   ; GPIO4 bit 15 as o/p, val 0-set,1-release Phy reset
;        bl      GPIO_WriteBit
; |
;        mov     a1, #(3<<5) + (29) + 1<<8  ; GPIO3 bit 29 as o/p, val 0-set,1-release Phy reset
;        bl      GPIO_WriteBit
; ]
;        Push    "a1-a3"
;        MOV     a1, #&1000000                 ; slight delay
;1       DMB
;        SUBS    a1, a1, #1
;        bgt     %bt1                       ; loop a while to let it settle
;        Pull    "a1-a3"
; [ CuBox
;        ; revert pins
;        ; set relevant bits to i/p
;        mov     a1, #(6<<5) + (25)       ; GPIO6 bit25 as o/p, val 1 hold till Phy reset - Phy address0
;        bl      GPIO_SetAsInput
;        mov     a1, #(6<<5) + (27)       ; GPIO6 bit27 as o/p, val 0 hold till Phy reset  - Phy address1
;        bl      GPIO_SetAsInput
;        mov     a1, #(6<<5) + (24)       ; GPIO6 bit24 as o/p, val 0 hold till Phy reset - Phy mode0
;        bl      GPIO_SetAsInput
;        mov     a1, #(6<<5) + (28)       ; GPIO6 bit28 as o/p, val 0 hold till Phy reset - Phy mode1
;        bl      GPIO_SetAsInput
;        mov     a1, #(6<<5) + (29)       ; GPIO6 bit29 as o/p, val 0 hold till Phy reset - Phy mode2
;        bl      GPIO_SetAsInput
;        mov     a1, #(6<<5) + (30)       ; GPIO6 bit30 as o/p, val 0 hold till Phy reset - Phy mode3
;        bl      GPIO_SetAsInput
;        ; set mode pins to rgmii again
;        mov     a3, #1
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]  ;
; ]
d372 1
a372 1
        ldr     a4, = MDIORdIDL            ; command to read IDL reg
a373 1
;        str     a4, BoardDetectInfo1       ; check
d380 14
a393 2
        moveq   a1, #1                     ; flag later Phy detected
        movne   a1, #3                     ; default later Phy,bad detect
d397 4
d412 5
a416 2
MDIORdIDH *     ((2_01)<<30) +((2_10)<<28)+((&1)<<23)+((&2)<<18)+((2_10)<<16) ; ReadID1 (IDH)reg
MDIORdIDL *     ((2_01)<<30) +((2_10)<<28)+((&1)<<23)+((&3)<<18)+((2_10)<<16) ; ReadID2 (IDL)reg
d551 2
a552 1
        bl      PhyResetRelease
d591 2
d661 1
@


1.6
log
@  Initial awareness of additional board variant
Detail:
Admin:


Version 0.91. Tagged as 'iMx6-0_91'
@
text
@d77 52
d133 2
a134 6
 [ CuBox
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4-IOMUXC_BASE_ADDR]     ;phy nrst
 |
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_EIM_D29-IOMUXC_BASE_ADDR]     ; phy nrst
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_GPIO_18-IOMUXC_BASE_ADDR]     ; D1 phy power
 ]
a136 4
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]     ;
d143 4
d149 1
a149 1

d174 1
a174 1
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_REF_CLK-IOMUXC_BASE_ADDR]   ; enet clk in
d176 1
a176 1
        mov     a3, #&12                  ; alt 2, sion on
d180 13
a196 1

d202 1
a202 1
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4-IOMUXC_BASE_ADDR]     ;
d207 1
a207 1
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_EIM_D29-IOMUXC_BASE_ADDR]     ;
d209 1
a209 1
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_GPIO_18-IOMUXC_BASE_ADDR]      ;
a211 3


;       ldr     a1, GPIO_Log
d216 1
a216 1
        mov     a1, #(4<<5) + (15) + 0<<8       ; GPIO4 bit 15 as o/p, val 1 hold reset
d221 1
a221 1
        mov     a1, #(3<<5) + (29) + 0<<8       ; GPIO3 bit 29 as o/p, val 1 hold reset
d223 1
a223 1
        mov     a1, #(7<<5) + (13) + 1<<8       ; GPIO7 bit 13 as o/p, val 1 turn off revD1 phy
a230 1

d239 1
a240 1
 ]
a251 2
        bl      AddEtherTHDevice

d254 4
a257 4
; See if we can check a RevD board presence by powering up and down the phy
; MUST preserve all registers
ENET_CheckForPhy
        Entry   "a1-a4"
d259 25
a283 5
        ldr     a3, =IOMuxPadEnet             ; pad drive stuff other ENET
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_MDIO-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_MDC-IOMUXC_BASE_ADDR]     ;
 [ CuBox
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4-IOMUXC_BASE_ADDR]     ;phy nrst
d285 2
a286 2
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_EIM_D29-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_GPIO_18-IOMUXC_BASE_ADDR]     ;
d288 2
a289 7

; now set all data path pads to GPIO
        mov     a3, #5                  ; alt 5 (GPIO, sion off
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_MDIO-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_MDC-IOMUXC_BASE_ADDR]
 [ CuBox
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4-IOMUXC_BASE_ADDR]     ;phy nrst
d291 1
a291 4
                                        ; alt 5 GPIO3_IO29 drives RGMII_nrst
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_EIM_D29-IOMUXC_BASE_ADDR]     ;
                                        ; alt 5 GPIO7_IO13 active low turns on phy on revD1 board
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_GPIO_18-IOMUXC_BASE_ADDR]      ;
a292 2
 [ CuBox
        mov     a1, #(4<<5) + (15) + 0<<8      ; GPIO4 bit15 as o/p, val 0 hold Phy reset
d294 13
a306 8
 |
        mov     a1, #(3<<5) + (29) + 0<<8      ; GPIO3 bit 29 as o/p, val 0 hold Phy reset
        bl      GPIO_SetAsOutput
        mov     a1, #(7<<5) + (13) + 1<<8      ; GPIO7 bit 13 as o/p, val 1 turn off revD1 phy
        bl      GPIO_SetAsOutput
        mov     a1, #(7<<5) + (13) + 0<<8  ; GPIO7 bit 13 val 0 turn on revD1 phy
        bl      GPIO_WriteBit           ; **** test temp
 ]
d314 36
d351 12
d364 1
a364 1
        mov     a1, #(4<<5) + (15) + 1<<8   ; GPIO4 bit 15 as o/p, val 0-set,1-release Phy reset
d366 1
a366 2
        mov     a1, #(3<<5) + (29) + 1<<8  ; GPIO3 bit 29 as o/p, val 0-set,1-release Phy reset
 ]
d368 1
d370 4
a373 4
        MOV     a1, #&1000000                 ; slight delay
1       DMB
        SUBS    a1, a1, #1
        bgt     %bt1                       ; loop a while to let it settle
d376 92
d491 2
d500 1
a500 1
        mov     a1, #(1<<5) + (31) + 1<<8  ; GPIO1 bit 31 val 1 MDC on/hi
d502 1
a502 1
        mov     a1, #(1<<5) + (22) + 1<<8  ; GPIO1 bit 22 val 1 MDIO on/hi
d604 1
d606 3
a608 3
 [ CuBox
        moveq   a1, #(4<<5) + (15) + 1<<8       ; val 0, nreset clear
        movne   a1, #(4<<5) + (15) + 0<<8       ; val 1, nreset set
d610 3
a612 2
        moveq   a1, #(3<<5) + (29) + 1<<8       ; val 0, nreset clear
        movne   a1, #(3<<5) + (29) + 0<<8       ; val 1, nreset set
d614 4
a617 3
        tst     a3, #1<<0
        movne   a1, #(7<<5) + (13) + 0<<8       ; val 0 turn on revD1 phy
        moveq   a1, #(7<<5) + (13) + 1<<8       ; val 1 turn off revD1 phy
a619 1

d626 5
@


1.5
log
@   Early detect Phy ID to explicitly detect Rev D boards
   or earlier
Detail:
   Read Phy IDL register by bit banging the MD interface to the Phy
   Rev D boards have an AR8035 Phy, Earlier revisions AR8031
Admin:
   tested on iMx6 Rev B and D

Version 0.83. Tagged as 'iMx6-0_83'
@
text
@d80 7
a86 3
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_REF_CLK-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_EIM_D29-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_GPIO_18-IOMUXC_BASE_ADDR]     ;
a112 1
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_REF_CLK-IOMUXC_BASE_ADDR]
d126 19
a144 2

        mov     a3, #5                  ; alt 5, sion off route RGMII_IRQ to GPIO1_IO28
d150 1
d156 7
a162 1
        mov     a1, #(1<<5) + 28
d168 1
a168 1

d181 1
d184 1
d194 1
a194 1
        str     a3, [a2,#IOMUXC_GPR1-IOMUXC_BASE_ADDR]     ;
d208 3
d213 1
a213 1

d219 3
d226 5
a230 1

a234 1

d237 1
d246 3
d250 1
a251 1

d271 1
a271 1
        orr a1, a1, a2, lsl #16
d348 3
d352 1
d362 5
a366 1
        mov     a1, #(1<<5) + 28
d375 5
a379 1
        mov     a1, #(1<<5) + 28
d394 4
d404 1
d427 3
d431 1
d434 3
d438 1
d442 3
d446 1
@


1.4
log
@  Resolve I2C error recovery abort
Detail:
  The code for unlocking stuck I2C transaction failed to get the base
  address of the I2C GPIO port. This had caused an AODT if the I2C transaction
  failed. Issue corrected
Admin:


Version 0.82. Tagged as 'iMx6-0_82'
@
text
@d130 3
d177 1
a178 2
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_MDIO-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_REF_CLK-IOMUXC_BASE_ADDR]     ;
a181 15
        ldr     a3, =IOMuxPadRGMII             ; pad drive stuff RGMII
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD0-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD1-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD2-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD3-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TXC-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TX_CTL-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]     ;


a185 1
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_REF_CLK-IOMUXC_BASE_ADDR]
a186 11
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TXC-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TD0-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TD1-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TD2-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TD3-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TX_CTL-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]
d192 1
a192 1
        mov     a1, #(3<<5) + (29) + 0<<8      ; GPIO3 bit 29 as o/p, val 1 hold Phy reset
d197 2
a198 2
        LDR     a2, GPIO_Log
        ADD     a2, a2, #GPIO6_BASE_ADDR-GPIO1_BASE_ADDR
a199 1
; now wait at least 1ms to allow the phy to stabilise after reset asserted
d201 2
a202 3
        MOV     a1, #&100000               ; slight delay
01      LDR     a3, [a2, #GPIO_DR]         ; read
        DMB
d204 1
a204 1
        bgt     %bt01                      ; loop a while to let it settle
d207 2
a208 11
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]
; set GPIO pins 6-19 to 6-30 for input   6-26 - 6-30
ENET_TestBits   * &7ff80000                ; bits to consider in GPIO6
        LDR     a3, [a2, #GPIO_GDIR]
        LDR     a4, = ENET_TestBits
        BIC     a3, a3, a4
        STR     a3, [a2, #GPIO_GDIR]       ; set bits as i/p
        LDR     a4, [a2, #GPIO_DR]         ; and read initial state
        mov     a1, #(7<<5) + (13) + 0<<8  ; GPIO7 bit 13 val 0 turn on revD1 phy
        bl      GPIO_SetAsOutput

d211 2
a212 3
        MOV     a1, #&10000                ; slight delay
1       LDR     a3, [a2, #GPIO_DR]         ; read
        DMB
a215 9
        LDR     a3, [a2, #GPIO_DR]         ; read again
        EOR     a3, a3, a4                 ; 0 if bits the same, else NZ
        LDR     a4, = ENET_TestBits
        ANDS    a3, a3, a4
        movne   a1, #1       ; not the same .. rev D
        moveq   a1, #0       ; the same .. no phy power control so B or C
; mov a1, #1 ; force to rev D
; mov a1, #0 ; force to rev BC
        STR     a1, BoardDetectInfo
d217 21
a237 2
        mov     a1, #(7<<5) + (13) + 1<<8  ; GPIO7 bit 13 val 1 turn off revD1 phy
        bl      GPIO_WriteBit
d240 2
d243 1
d245 6
d252 43
d332 1
d336 2
d349 6
@


1.3
log
@   Resolve I2C differences between RevB and C boards and RevD
Detail:
   RevD boards have put the HDMI EDID I2C lines on I2C2 instead of
   I2C1. This conflicts with the CMOS RAM. A routine has been created
   to detect the RevD board (by the presence of a power swithch on the
   Ethernet Phy), so the HAL can set up appropriately.
Admin:
   Tested on Rev B and Rev D iMx6 boards


Version 0.80. Tagged as 'iMx6-0_80'
@
text
@d222 12
a236 2
        LDR     a2, GPIO_Log
        ADD     a2, a2, #GPIO6_BASE_ADDR-GPIO1_BASE_ADDR
@


1.2
log
@  Added routine to control Ethernet Phy power and reset pins
Detail:
  HAL_EtherDevice now gives access to a routine to control the
  Ethernet Phy power and reset pins. This updated device is present if the
  hal workspace pointer is non zero (bug fix) and GPIO_WriteBit routine
  now writes correctly in all cases.
Admin:
  tested on iMx6 revC2 and revD1


Version 0.79. Tagged as 'iMx6-0_79'
@
text
@d55 1
d76 1
a76 1
        ldr     a2, [sb, #:INDEX:IOMUXC_Base]
d144 1
d168 93
@


1.1
log
@Initial revision
@
text
@d48 1
d81 1
d127 2
d133 3
a135 4
;       ldr     a3, [a1, #4]
;       bic     a3, a3, #1<<28                  ; set as input
;       str     a3, [a1, #4]
        mov     a1, #(3<<5) + (28) + 0<<8       ; GPIO3 bit 28 as o/p, val 0
a136 7
;       add     a1, a1, #GPIO3_BASE_ADDR-GPIO1_BASE_ADDR
; ;now set the gpio pin to output and phy reset
;        mov    a3, #&20000000
;        str    a3, [a1, #4]                    ; direction register
;        ldr    a3, [a1]                        ; data register
;        bic    a3, a3, #&20000000              ; put phy into reset
;        str    a3, [a1]
d198 18
d240 1
d307 1
@


1.1.1.1
log
@Initial import of iMx6 HAL
@
text
@@


1.1.1.1.2.1
log
@Merge in HEAD
Detail:
  Merge in iMx6-0_80 to keep SMP branch up to date
  Files changed: hdr/StaticWS, hdr/iMx6qboard, s/Audio, s/EtherDrv, s/GPIO, s/I2C, s/RTC, s/iMx6qboard
Admin:
  Untested


Version 0.80, 1.4.2.1. Tagged as 'iMx6-0_80-1_4_2_1'
@
text
@a47 1
        IMPORT  GPIO_WriteBit
a53 1
        EXPORT  ENET_CheckForPhy
d74 1
a74 1
        ldr     a2, IOMUXC_Base
a79 1
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_GPIO_18-IOMUXC_BASE_ADDR]     ;
a124 2
                                        ; alt 5 GPIO7_IO13 active low turns on phy on revD1 board
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_GPIO_18-IOMUXC_BASE_ADDR]      ;
d129 4
a132 3
        mov     a1, #(3<<5) + (29) + 0<<8       ; GPIO3 bit 29 as o/p, val 1 hold reset
        bl      GPIO_SetAsOutput
        mov     a1, #(7<<5) + (13) + 1<<8       ; GPIO7 bit 13 as o/p, val 1 turn off revD1 phy
d134 7
a146 1

a169 93
; See if we can check a RevD board presence by powering up and down the phy
; MUST preserve all registers
ENET_CheckForPhy
        Entry   "a1-a4"
        ldr     a2, IOMUXC_Base
        ldr     a3, =IOMuxPadEnet             ; pad drive stuff other ENET
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_MDC-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_MDIO-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_REF_CLK-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_EIM_D29-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_GPIO_18-IOMUXC_BASE_ADDR]     ;

        ldr     a3, =IOMuxPadRGMII             ; pad drive stuff RGMII
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD0-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD1-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD2-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD3-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TXC-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TX_CTL-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]     ;



; now set all data path pads to GPIO
        mov     a3, #5                  ; alt 5 (GPIO, sion off
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_MDIO-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_REF_CLK-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_MDC-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TXC-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TD0-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TD1-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TD2-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TD3-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_TX_CTL-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]
                                        ; alt 5 GPIO3_IO29 drives RGMII_nrst
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_EIM_D29-IOMUXC_BASE_ADDR]     ;
                                        ; alt 5 GPIO7_IO13 active low turns on phy on revD1 board
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_GPIO_18-IOMUXC_BASE_ADDR]      ;

        mov     a1, #(3<<5) + (29) + 0<<8      ; GPIO3 bit 29 as o/p, val 1 hold Phy reset
        bl      GPIO_SetAsOutput
        mov     a1, #(7<<5) + (13) + 1<<8      ; GPIO7 bit 13 as o/p, val 1 turn off revD1 phy
        bl      GPIO_SetAsOutput

;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]
; set GPIO pins 6-19 to 6-30 for input   6-26 - 6-30
ENET_TestBits   * &7ff80000                ; bits to consider in GPIO6
        LDR     a2, GPIO_Log
        ADD     a2, a2, #GPIO6_BASE_ADDR-GPIO1_BASE_ADDR
        LDR     a3, [a2, #GPIO_GDIR]
        LDR     a4, = ENET_TestBits
        BIC     a3, a3, a4
        STR     a3, [a2, #GPIO_GDIR]       ; set bits as i/p
        LDR     a4, [a2, #GPIO_DR]         ; and read initial state
        mov     a1, #(7<<5) + (13) + 0<<8  ; GPIO7 bit 13 val 0 turn on revD1 phy
        bl      GPIO_SetAsOutput


        Push    "a1-a3"
        MOV     a1, #&10000                ; slight delay
1       LDR     a3, [a2, #GPIO_DR]         ; read
        DMB
        SUBS    a1, a1, #1
        bgt     %bt1                       ; loop a while to let it settle
        Pull    "a1-a3"
        LDR     a3, [a2, #GPIO_DR]         ; read again
        EOR     a3, a3, a4                 ; 0 if bits the same, else NZ
        LDR     a4, = ENET_TestBits
        ANDS    a3, a3, a4
        movne   a1, #1       ; not the same .. rev D
        moveq   a1, #0       ; the same .. no phy power control so B or C
; mov a1, #1 ; force to rev D
; mov a1, #0 ; force to rev BC
        STR     a1, BoardDetectInfo

        mov     a1, #(7<<5) + (13) + 1<<8  ; GPIO7 bit 13 val 1 turn off revD1 phy
        bl      GPIO_WriteBit

        EXIT




a201 18

; a1 bit0 = 1 for power enable, 0 for disable
; a1 bit1 = 1 for reset set, 0 for reset clear
; a2 on entry is HAL sb value as taken from the hal device table
EtherTHPhyPwrRst
        Entry   "sb"
        mov     sb, a2
        mov     a3, a1
        tst     a3, #1<<1
        moveq   a1, #(3<<5) + (29) + 1<<8       ; val 0, nreset clear
        movne   a1, #(3<<5) + (29) + 0<<8       ; val 1, nreset set
        bl      GPIO_WriteBit
        tst     a3, #1<<0
        movne   a1, #(7<<5) + (13) + 0<<8       ; val 0 turn on revD1 phy
        moveq   a1, #(7<<5) + (13) + 1<<8       ; val 1 turn off revD1 phy
        bl      GPIO_WriteBit

        EXIT
a225 1
        str     sb, [v1, #ethws-EtherTHDeviceTemplate]
a291 1
        DCD     EtherTHPhyPwrRst        ; phy power enable and reset
@


1.1.1.1.2.2
log
@Merge in changes since iMx6-0_80

Version 0.82, 1.4.2.3. Tagged as 'iMx6-0_82-1_4_2_3'
@
text
@a221 12
        LDR     a2, GPIO_Log
        ADD     a2, a2, #GPIO6_BASE_ADDR-GPIO1_BASE_ADDR

; now wait at least 1ms to allow the phy to stabilise after reset asserted
        Push    "a1-a3"
        MOV     a1, #&100000               ; slight delay
01      LDR     a3, [a2, #GPIO_DR]         ; read
        DMB
        SUBS    a1, a1, #1
        bgt     %bt01                      ; loop a while to let it settle
        Pull    "a1-a3"

d225 2
@


1.1.1.1.2.3
log
@   resync with non SMP version
Detail:
Admin:


Version 0.82, 1.4.2.4. Tagged as 'iMx6-0_82-1_4_2_4'
@
text
@a129 3



d174 1
d176 1
a176 1
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_MDC-IOMUXC_BASE_ADDR]     ;
d180 15
d199 1
d201 11
d217 1
a217 1
        mov     a1, #(3<<5) + (29) + 0<<8      ; GPIO3 bit 29 as o/p, val 0 hold Phy reset
d222 2
a223 2
        mov     a1, #(7<<5) + (13) + 0<<8  ; GPIO7 bit 13 val 0 turn on revD1 phy
        bl      GPIO_WriteBit           ; **** test temp
d225 1
d227 3
a229 2
        MOV     a1, #&1000000                 ; slight delay
1       DMB
d231 1
a231 1
        bgt     %bt1                       ; loop a while to let it settle
d234 11
a244 2
        mov     a1, #(3<<5) + (29) + 1<<8  ; GPIO3 bit 29 as o/p, val 0-set,1-release Phy reset
        bl      GPIO_WriteBit
d247 3
a249 2
        MOV     a1, #&1000000                 ; slight delay
1       DMB
d253 9
d263 2
a264 21
        ldr     a4, = MDIORdIDL            ; command to read IDL reg
        bl      DoPhyCmd
;        str     a4, BoardDetectInfo1       ; check
        ldr     a2, = PhyAR8031
        teq     a2, a4
        moveq   a1, #0
        beq     %ft1
        ldr     a2, = PhyAR8035
        teq     a2, a4
        moveq   a1, #1                     ; flag later Phy detected
        movne   a1, #3                     ; default later Phy,bad detect
1
        orr a1, a1, a2, lsl #16
        str     a1, BoardDetectInfo        ; flag appropriately

; restore desired padmux to ethernet
        ldr     a2, IOMUXC_Base
        mov     a3, #1                  ; alt 1, sion off
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_MDIO-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_MDC-IOMUXC_BASE_ADDR]

a266 2
MDIORdIDH *     ((2_01)<<30) +((2_10)<<28)+((&1)<<23)+((&2)<<18)+((2_10)<<16) ; ReadID1 (IDH)reg
MDIORdIDL *     ((2_01)<<30) +((2_10)<<28)+((&1)<<23)+((&3)<<18)+((2_10)<<16) ; ReadID2 (IDL)reg
a267 1
; send command in a4 to Phy, and return response in a4
a268 6
DoPhyCmd
        Entry   "a1-a3"
        mov     a1, #(1<<5) + (31) + 1<<8  ; GPIO1 bit 31 val 1 MDC on/hi
        bl      GPIO_SetAsOutput
        mov     a1, #(1<<5) + (22) + 1<<8  ; GPIO1 bit 22 val 1 MDIO on/hi
        bl      GPIO_SetAsOutput
a269 43
        mov     a3, #64                    ; need 64 logic 1
11      bl      ClockMDC                   ; rising edge clocks data
        subs    a3, a3, #1
        bgt     %bt11                      ; 64 bit preamble

        mov     a3, #16                    ; 16 bit to write
cmdloop mov     a1, #(1<<5) + (22) + 0<<8  ; GPIO1 bit MDIO databit lo
        movs    a4, a4, lsl #1             ; do we need a 1
        orrcs   a1, a1, #1<<8              ; yes
        bl      GPIO_WriteBit
        bl      ClockMDC                   ; clocked in on rising edge
        subs    a3, a3, #1
        bgt     cmdloop
; now read 16 bits
        mov     a1, #(1<<5) + (22)         ; GPIO1 bit databit as input MDIO
        bl      GPIO_SetAsInput
        mov     a4, #0
        mov     a3, #16
rdloop  mov     a1, #(1<<5) + (22)         ; GPIO1 bit databit as input MDIO
        bl      GPIO_ReadBit               ; returns 1 or 0
        orr     a4, a1, a4, lsl #1         ; build it up
        bl      ClockMDC                   ; rising edge samples data
        subs    a3, a3, #1
        bgt     rdloop
        EXIT


; put out low-hi clock cycle
ClockMDC
        Entry   "a1-a3"
        mov     a1, #(1<<5) + (31) + 0<<8  ; GPIO1 bit 31 val 0  MDC lo
        bl      GPIO_WriteBit
        MOV     a1, #&8                 ; slight delay
13      DMB
        SUBS    a1, a1, #1
        bgt     %bt13                      ; loop a while to let it settle
        mov     a1, #(1<<5) + (31) + 1<<8  ; GPIO1 bit 31 val 1  MDC hi
        bl      GPIO_WriteBit
        MOV     a1, #&8                 ; slight delay
14      DMB
        SUBS    a1, a1, #1
        bgt     %bt14                      ; loop a while to let it settle
        EXIT
a306 1
; if a1 bit7 set then test call  instead
a309 2
        tst     a1, #1<<7
        bne     TestCall
a320 6
; invoke a test call to the Phy Type Presence detect code
TestCall
        bl      ENET_CheckForPhy
        EXIT


@


1.1.1.1.2.4
log
@Merge in latest changes from HEAD

Version 0.96, 1.4.2.12. Tagged as 'iMx6-0_96-1_4_2_12'
@
text
@a76 52
        bl      Ether_InitPins
        bl      AddEtherTHDevice

        EXIT

; Pin initialisation.. needs domne early for Phy config
Ether_InitPins
        Entry   "a1-a3"
        ldr     a2, IOMUXC_Base
; [ CuBox
;        ; CuBox relies on relevant PU and PD to provide mode strapping for Phy
;        ldr     a3, =IOMuxENETMDIO
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_MDIO-IOMUXC_BASE_ADDR]     ;
;
;        ldr     a3, =IOMuxENETMDC
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_MDC-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_DI0_PIN2-IOMUXC_BASE_ADDR]
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_GPIO_16-IOMUXC_BASE_ADDR]      ; enet clk
;
;        ldr     a3, =IOMuxENETPhyIrq
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4-IOMUXC_BASE_ADDR]     ; phy nrst
;
;        ldr     a3, =IOMuxENETRefClk
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_REF_CLK-IOMUXC_BASE_ADDR]  ; enet ref clk ip
;
;        ldr     a3, =IOMuxENETPD
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TXC-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]     ;
;
;        ldr     a3, =IOMuxENETPU
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD0-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD1-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD2-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TD3-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_TX_CTL-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]     ;
;        ldr     a3, =IOMuxENETHiZPU
;; these are patched across to the rgmii lines, so set as input (hence inert)
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_CRS_DV-IOMUXC_BASE_ADDR]
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_RXD0-IOMUXC_BASE_ADDR]
;        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_RXD1-IOMUXC_BASE_ADDR]
; |
 [ CuBox
        ldr     a3, =IOMuxENETRefClk             ; pad drive stuff
 |
        ldr     a3, =IOMuxPadEnet             ; pad drive stuff other ENET
 ]
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_REF_CLK-IOMUXC_BASE_ADDR]  ; enet ref clk ip
d80 3
a82 3
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_ENET_REF_CLK-IOMUXC_BASE_ADDR]  ; enet ref clk ip
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_EIM_D29-IOMUXC_BASE_ADDR]       ; phy nrst
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_GPIO_18-IOMUXC_BASE_ADDR]       ; D1 phy power
d85 4
a94 4
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_PAD_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]     ;
d97 1
a97 1
; ]
d109 1
d123 2
a124 31
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_REF_CLK-IOMUXC_BASE_ADDR]   ; enet tx clk
 [ CuBox
        mov     a3, #&2                  ; alt 2, sion off
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_GPIO_16-IOMUXC_BASE_ADDR]       ; send enet clock
        mov     a3, #SEL_GPIO_16_ALT2
        str     a3, [a2,#IOMUXC_ENET_IPG_CLK_RMII_SELECT_INPUT-IOMUXC_BASE_ADDR]     ;enet clk

        mov     a3, #5
; these are patched across to the rgmii lines, so set as input (hence inert)
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_CRS_DV-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_RXD0-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_RXD1-IOMUXC_BASE_ADDR]
        mov     a1, #(1<<5) + 24
        bl      GPIO_SetAsInput                 ; GPIO1 bit 25 (to mode0)
        mov     a1, #(1<<5) + 22
        bl      GPIO_SetAsInput                 ; GPIO1 bit 27 (to Phyadd0)
        mov     a1, #(1<<5) + 26
        bl      GPIO_SetAsInput                 ; GPIO1 bit 26 (to PhyAdd1)

 |
        mov     a3, #SEL_RGMII_TX_CTL_ALT7
        str     a3, [a2,#IOMUXC_ENET_IPG_CLK_RMII_SELECT_INPUT-IOMUXC_BASE_ADDR]     ;enet clk
 ]
        mov     a3, #5
 [ CuBox
                                        ; alt 5, sion off route RGMII_IRQ to GPIO4_IO18
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_DI0_PIN2-IOMUXC_BASE_ADDR]
                                        ; alt 5 GPIO4_IO15 drives RGMII_nrst  GPIO4_IO15
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4-IOMUXC_BASE_ADDR]
 |
                                        ; alt 5, sion off route RGMII_IRQ to GPIO1_IO28
d127 1
a127 1
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_EIM_D29-IOMUXC_BASE_ADDR]
d129 1
a129 2
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_GPIO_18-IOMUXC_BASE_ADDR]
 ]
d131 3
d135 1
a135 7
 [ CuBox
        mov     a1, #(4<<5) + 18
        bl      GPIO_SetAsInput                 ; GPIO4 bit 18 is irq input
        mov     a1, #(4<<5) + (15) + (0<<8)     ; GPIO4 bit 15 as o/p, val 0 hold reset
        bl      GPIO_SetAsOutput
 |
        mov     a1, #(1<<5) + 28                ; GPIO1 bit 28 is irq input
d137 1
a137 1
        mov     a1, #(3<<5) + (29) + (0<<8)     ; GPIO3 bit 29 as o/p, val 0 hold reset
d139 1
a139 1
        mov     a1, #(7<<5) + (13) + (1<<8)     ; GPIO7 bit 13 as o/p, val 1 turn off revD1 phy
d141 1
a141 1
 ]
d147 1
a153 1
 [ :LNOT: CuBox
a154 1
 ]
d165 3
a167 1
        str     a3, [a2,#IOMUXC_GPR1-IOMUXC_BASE_ADDR]     ; and o/p signal
d171 4
a174 4
; on entry a1 = correct info for GPIO_WriteBit call to clear reset
; assumes sb initialised
PhyResetRelease
        Entry    "a1-a4"
d176 17
a192 34
        mov     a4, a1
        eor     a1, a1, #1<<8
        bl      GPIO_SetAsOutput                          ; ensure we're in reset state
        ; set mode pins to i/o
        mov     a3, #5
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]     ;
 [ CuBox
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]     ;
 ]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]     ;
        ; set relevant bits to o/p 0
        mov     a1, #(6<<5) + (25) + (1<<8)  ; rd0 GPIO6 bit25 as o/p, val 1 hold till Phy reset - Phy address0
        bl      GPIO_SetAsOutput                   
        mov     a1, #(6<<5) + (27) + (0<<8)  ; rd1 GPIO6 bit27 as o/p, val 0 hold till Phy reset  - Phy address1
        bl      GPIO_SetAsOutput                   
        mov     a1, #(6<<5) + (24) + (0<<8)  ; rxctl GPIO6 bit24  o/p, val 0 hold till Phy reset - Phy mode0
        bl      GPIO_SetAsOutput                   
        mov     a1, #(6<<5) + (28) + (0<<8)  ; rd2 GPIO6 bit28 as o/p, val 0 hold till Phy reset - Phy mode1
        bl      GPIO_SetAsOutput                   
 [ CuBox                                           
        mov     a1, #(6<<5) + (29) + (1<<8)  ; rxc GPIO6 bit29 as o/p, val 1 hold till Phy reset - Phy I/O volts
        bl      GPIO_SetAsOutput                   
 |
                                             ; rxc GPIO6 bit29 as o/p, val 1 hold till Phy reset - Phy mode2 AR8031
                                             ; rxc GPIO6 bit29 as o/p, val 1 hold till Phy reset - Phy I/O volts AR8035
 ]
  [ CuBox                                           
       mov     a1, #(6<<5) + (30) + (1<<8)  ; rd3 GPIO6 bit30 as o/p, val 1 hold till Phy reset - Phy mode3
 |
       mov     a1, #(6<<5) + (30) + (0<<8)  ; rd3 GPIO6 bit30 as o/p, val 0 hold till Phy reset - Phy mode3
 ]
d194 6
a199 4
        ; set relevant bits to 0
        ; pause
        ; release reset
        ; revert pins
d204 1
a204 1
        bgt     %bt1                           ; loop a while to let it settle
d207 1
a207 1
        mov     a1, a4
a215 153
        ldr     a2, IOMUXC_Base
        ; revert pins
        ; set relevant bits to i/p
        mov     a1, #(6<<5) + (25)       ; GPIO6 bit25 i/p, - Phy address0
        bl      GPIO_SetAsInput
        mov     a1, #(6<<5) + (27)       ; GPIO6 bit27 i/p,  - Phy address1
        bl      GPIO_SetAsInput
        mov     a1, #(6<<5) + (24)       ; l GPIO6 bit24 i/p,  - Phy mode0
        bl      GPIO_SetAsInput
        mov     a1, #(6<<5) + (28)       ; GPIO6 bit28 i/p,  - Phy mode1
        bl      GPIO_SetAsInput
 [ CuBox
        mov     a1, #(6<<5) + (29)       ; GPIO6 bit29 i/p,  - Phy mode2
        bl      GPIO_SetAsInput
 ]
        mov     a1, #(6<<5) + (30)       ; GPIO6 bit30 i/p,  - Phy mode3
        bl      GPIO_SetAsInput
        ; set mode pins to rgmii again
        mov     a3, #1
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]     ;
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]  ;
        EXIT

; See if we can check a RevD board presence by powering up and down the phy
; MUST preserve all registers
; This can be called before any other Ethernet initialisation has taken place..
; need to control all inits...
; assumes sb initialised
ENET_CheckForPhy
        Entry   "a1-a4"
        ldr     a2, IOMUXC_Base
        bl      Ether_InitPins

; now set all data path pads to GPIO
        mov     a3, #5                  ; alt 5 (GPIO, sion off
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_MDIO-IOMUXC_BASE_ADDR]
        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_ENET_MDC-IOMUXC_BASE_ADDR]
; [ CuBox
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4-IOMUXC_BASE_ADDR]     ;phy nrst
; |
;                                        ; alt 5 GPIO3_IO29 drives RGMII_nrst
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_EIM_D29-IOMUXC_BASE_ADDR]     ;
;                                        ; alt 5 GPIO7_IO13 active low turns on phy on revD1 board
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_GPIO_18-IOMUXC_BASE_ADDR]      ;
; ]
 [ CuBox
        mov     a1, #(4<<5) + (15) + (1<<8)    ; val 1, nreset clear
 |
        mov     a1, #(7<<5) + (13) + (0<<8)    ; val 0 turn on revD1 phy
        bl      GPIO_WriteBit

        Push    "a1-a3"
        MOV     a1, #&1000000                  ; slight delay
1       DMB                                 
        SUBS    a1, a1, #1                  
        bgt     %bt1                           ; loop a while to let it settle
        Pull    "a1-a3"

        mov     a1, #(3<<5) + (29) + (1<<8)    ; val 1, nreset clear
 ]
        bl      PhyResetRelease
; [ CuBox
;        ; cubox needs to set the state of the mode pins before releasing the reset line, so..
;        ; so..
;        ; set reset on
;        mov     a1, #(4<<5) + (15) + (0<<8)      ; GPIO4 bit15 as o/p, val 0 hold Phy reset
;        bl      GPIO_SetAsOutput
;        ; set mode pins to i/o
;        mov     a3, #5
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]     ;
;
;
;        ; set relevant bits to o/p 0
;        mov     a1, #(6<<5) + (25) + (1<<8)      ; GPIO6 bit25 as o/p, val 1 hold till Phy reset - Phy address0
;        bl      GPIO_SetAsOutput
;        mov     a1, #(6<<5) + (27) + (0<<8)      ; GPIO6 bit27 as o/p, val 0 hold till Phy reset  - Phy address1
;        bl      GPIO_SetAsOutput
;        mov     a1, #(6<<5) + (24) + (0<<8)      ; GPIO6 bit24 as o/p, val 0 hold till Phy reset - Phy mode0
;        bl      GPIO_SetAsOutput
;        mov     a1, #(6<<5) + (28) + (0<<8)      ; GPIO6 bit28 as o/p, val 0 hold till Phy reset - Phy mode1
;        bl      GPIO_SetAsOutput
;        mov     a1, #(6<<5) + (29) + (0<<8)      ; GPIO6 bit29 as o/p, val 0 hold till Phy reset - Phy mode2
;        bl      GPIO_SetAsOutput
;        mov     a1, #(6<<5) + (30) + (0<<8)      ; GPIO6 bit30 as o/p, val 0 hold till Phy reset - Phy mode3
;        bl      GPIO_SetAsOutput
;        ; set relevant bits to 0
;        ; pause
;        ; release reset
;        ; revert pins
; |
;        mov     a1, #(3<<5) + (29) + (0<<8)      ; GPIO3 bit 29 as o/p, val 0 hold Phy reset
;        bl      GPIO_SetAsOutput
;        mov     a1, #(7<<5) + (13) + (0<<8)      ; GPIO7 bit 13 as o/p, val 0 turn on revD1 phy
;        bl      GPIO_SetAsOutput
;
;;        mov     a1, #(7<<5) + (13) + (0<<8)  ; GPIO7 bit 13 val 0 turn on revD1 phy
;;        bl      GPIO_WriteBit           ; **** test temp
; ]
;
;        Push    "a1-a3"
;        MOV     a1, #&1000000                 ; slight delay
;1       DMB
;        SUBS    a1, a1, #1
;        bgt     %bt1                       ; loop a while to let it settle
;        Pull    "a1-a3"
;
; [ CuBox
;        ; release reset
;        mov     a1, #(4<<5) + (15) + 1<<8   ; GPIO4 bit 15 as o/p, val 0-set,1-release Phy reset
;        bl      GPIO_WriteBit
; |
;        mov     a1, #(3<<5) + (29) + 1<<8  ; GPIO3 bit 29 as o/p, val 0-set,1-release Phy reset
;        bl      GPIO_WriteBit
; ]
;        Push    "a1-a3"
;        MOV     a1, #&1000000                 ; slight delay
;1       DMB
;        SUBS    a1, a1, #1
;        bgt     %bt1                       ; loop a while to let it settle
;        Pull    "a1-a3"
; [ CuBox
;        ; revert pins
;        ; set relevant bits to i/p
;        mov     a1, #(6<<5) + (25)       ; GPIO6 bit25 as o/p, val 1 hold till Phy reset - Phy address0
;        bl      GPIO_SetAsInput
;        mov     a1, #(6<<5) + (27)       ; GPIO6 bit27 as o/p, val 0 hold till Phy reset  - Phy address1
;        bl      GPIO_SetAsInput
;        mov     a1, #(6<<5) + (24)       ; GPIO6 bit24 as o/p, val 0 hold till Phy reset - Phy mode0
;        bl      GPIO_SetAsInput
;        mov     a1, #(6<<5) + (28)       ; GPIO6 bit28 as o/p, val 0 hold till Phy reset - Phy mode1
;        bl      GPIO_SetAsInput
;        mov     a1, #(6<<5) + (29)       ; GPIO6 bit29 as o/p, val 0 hold till Phy reset - Phy mode2
;        bl      GPIO_SetAsInput
;        mov     a1, #(6<<5) + (30)       ; GPIO6 bit30 as o/p, val 0 hold till Phy reset - Phy mode3
;        bl      GPIO_SetAsInput
;        ; set mode pins to rgmii again
;        mov     a3, #1
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD0-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD1-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD2-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RD3-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RXC-IOMUXC_BASE_ADDR]     ;
;        str     a3, [a2,#IOMUXC_SW_MUX_CTL_PAD_RGMII_RX_CTL-IOMUXC_BASE_ADDR]  ;
; ]
d229 1
a229 1
        orr     a1, a1, a4, lsl #16
a239 2

; Phy address 1
d247 1
a247 1
        mov     a1, #(1<<5) + (31) + (1<<8)  ; GPIO1 bit 31 val 1 MDC on/hi
d249 1
a249 1
        mov     a1, #(1<<5) + (22) + (1<<8)  ; GPIO1 bit 22 val 1 MDIO on/hi
a305 3
 [ CuBox
        mov     a1, #(4<<5) + 18 + (0<<8)       ; active low detect
 |
a306 1
 ]
d316 1
a316 5
 [ CuBox
        mov     a1, #(4<<5) + 18        ; active low detect
 |
        mov     a1, #(1<<5) + 28        ; active low detect
 ]
d325 1
a325 5
 [ CuBox
        mov     a1, #(4<<5) + 18        ; active low detect
 |
        mov     a1, #(1<<5) + 28        ; active low detect
 ]
a338 1
 [ CuBox
d340 3
a342 4
        movne   a1, #(4<<5) + (15) + (0<<8)       ; val 1, nreset set
        moveq   a1, #(4<<5) + (15) + (1<<8)       ; val 0, nreset clear
        beq     ReleaseReset                      ; more complicated, but done here
 |
d344 2
a345 8
        movne   a1, #(7<<5) + (13) + (0<<8)       ; val 0 turn on revD1 phy
        moveq   a1, #(7<<5) + (13) + (1<<8)       ; val 1 turn off revD1 phy
        bl      GPIO_WriteBit
        tst     a3, #1<<1                         ; resetbit clear request?
        movne   a1, #(3<<5) + (29) + (0<<8)       ; val 1, nreset set
        moveq   a1, #(3<<5) + (29) + (1<<8)       ; val 0, nreset clear
        beq     ReleaseReset                      ; more complicated, but done here
 ]
d347 1
a353 5
; release phy reset pin, ensuring that phy mode pins are correctly held
; a1 = correct info for GPIO_WriteBit call
ReleaseReset
        bl      PhyResetRelease
        EXIT
a367 3
 [ CuBox
        mov     a1, #(4<<5) + 18
 |
a368 1
 ]
a370 3
 [ CuBox
        mov     a1, #(4<<5)
 |
a371 1
 ]
a374 3
 [ CuBox
        mov     a1, #1<<18      ; create bit test mask
 |
a375 1
 ]
@



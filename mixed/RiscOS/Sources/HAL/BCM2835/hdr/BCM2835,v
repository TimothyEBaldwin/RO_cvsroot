head	1.31;
access;
symbols
	Pi3APlus_merge:1.29.2.1
	BCM2835-0_75-1:1.29.2.1
	Pi3APlus:1.29.0.2
	Pi3APlus_bp:1.29
	BCM2835-0_76:1.30
	BCM2835-0_75-1_70_2_4:1.27.2.3
	BCM2835-0_75:1.29
	BCM2835-0_74:1.29
	BCM2835-0_73-1_70_2_3:1.27.2.2
	BCM2835-0_73:1.28
	BCM2835-0_72:1.28
	BCM2835-0_71-1_70_2_2:1.27.2.2
	BCM2835-0_71:1.28
	BCM2835-0_70-1_70_2_1:1.27.2.1
	SMP:1.27.0.2
	SMP_bp:1.27
	BCM2835-0_70:1.27
	BCM2835-0_69:1.27
	BCM2835-0_68:1.27
	BCM2835-0_67:1.27
	BCM2835-0_66:1.26
	BCM2835-0_65:1.25
	BCM2835-0_64:1.25
	BCM2835-0_63:1.24
	BCM2835-0_62:1.24
	BCM2835-0_61:1.23
	BCM2835-0_60:1.23
	BCM2835-0_59:1.23
	BCM2835-0_58:1.22
	BCM2835-0_57:1.22
	BCM2835-0_56:1.22
	BCM2835-0_55:1.22
	BCM2835-0_53:1.20
	BCM2835-0_52:1.20
	BCM2835-0_51:1.20
	BCM2835-0_50:1.20
	BCM2835-0_49:1.19
	BCM2835-0_48:1.19
	BCM2835-0_47:1.19
	BCM2835-0_46:1.19
	BCM2835-0_45:1.19
	BCM2835-0_44:1.18
	BCM2835-0_43:1.18
	BCM2835-0_42:1.17
	BCM2835-0_41:1.17
	BCM2835-0_40:1.17
	BCM2835-0_39:1.16
	BCM2835-0_38:1.16
	BCM2835-0_37:1.16
	BCM2835-0_36:1.16
	BCM2835-0_35:1.16
	BCM2835-0_34:1.16
	BCM2835-0_33:1.15
	BCM2835-0_32:1.15
	BCM2835-0_31:1.15
	BCM2835-0_30:1.15
	BCM2835-0_29:1.15
	BCM2835-0_28:1.14
	BCM2835-0_27:1.14
	BCM2835-0_26:1.14
	BCM2835-0_25:1.14
	BCM2835-0_24:1.13
	BCM2835-0_23:1.12
	BCM2835-0_22:1.12
	BCM2835-0_21:1.12
	BCM2835-0_20:1.11
	BCM2835-0_19:1.10
	BCM2835-0_18:1.10
	BCM2835-0_17:1.10
	BCM2835-0_16:1.9
	BCM2835-0_15:1.9
	BCM2835-0_14:1.8
	BCM2835-0_13:1.7
	BCM2835-0_12:1.7
	BCM2835-0_11:1.7
	BCM2835-0_10:1.6
	BCM2835-0_09:1.6
	BCM2835-0_08:1.6
	BCM2835-0_07:1.6
	BCM2835-0_06:1.5
	BCM2835-0_05:1.4
	BCM2835-0_04:1.4
	BCM2835-0_03:1.3
	BCM2835-0_02:1.2
	BCM2835-0_01:1.1.1.1
	initial:1.1.1.1
	Vendor:1.1.1;
locks; strict;
comment	@# @;


1.31
date	2018.10.26.19.37.02;	author bavison;	state Exp;
branches;
next	1.30;
commitid	dalYNopD32JgovXA;

1.30
date	2018.07.07.14.26.21;	author jlee;	state Exp;
branches;
next	1.29;
commitid	VQCRRsJLbDt0fdJA;

1.29
date	2018.03.19.21.03.14;	author jlee;	state Exp;
branches
	1.29.2.1;
next	1.28;
commitid	DXJIfpAlz3WmY6vA;

1.28
date	2017.07.27.20.00.57;	author rsprowson;	state Exp;
branches;
next	1.27;
commitid	977gob8GZGC5bU0A;

1.27
date	2017.02.11.15.29.55;	author rool;	state Exp;
branches
	1.27.2.1;
next	1.26;
commitid	zDDt6chYlHWb1yFz;

1.26
date	2017.01.20.22.11.31;	author jlee;	state Exp;
branches;
next	1.25;
commitid	XiXvH3kRV0JNWKCz;

1.25
date	2016.12.10.13.03.39;	author rool;	state Exp;
branches;
next	1.24;
commitid	K8noJk4vvPEyerxz;

1.24
date	2016.10.22.20.18.02;	author rool;	state Exp;
branches;
next	1.23;
commitid	vT6sSPcBGcAddbrz;

1.23
date	2016.10.09.12.23.47;	author jlee;	state Exp;
branches;
next	1.22;
commitid	AegGZ5wtYn4r0tpz;

1.22
date	2016.03.28.00.59.07;	author jlee;	state Exp;
branches;
next	1.21;
commitid	5C4DqTbsLnd8ul0z;

1.21
date	2016.03.26.21.29.30;	author jlee;	state Exp;
branches;
next	1.20;
commitid	R20Od6NioP8emc0z;

1.20
date	2015.11.15.00.09.54;	author jlee;	state Exp;
branches;
next	1.19;
commitid	oJ6rSmtkg3Ajw7Jy;

1.19
date	2015.07.26.18.58.00;	author jlee;	state Exp;
branches;
next	1.18;
commitid	n3kZvFwWGn3xmPuy;

1.18
date	2015.02.07.02.16.49;	author jlee;	state Exp;
branches;
next	1.17;
commitid	FIaMdabVR7wSf19y;

1.17
date	2015.02.02.13.28.30;	author bavison;	state Exp;
branches;
next	1.16;
commitid	ElEkWbWLEdDg8r8y;

1.16
date	2014.06.19.21.03.15;	author jlee;	state Exp;
branches;
next	1.15;
commitid	EcK8j6AjJmkFYaFx;

1.15
date	2013.01.22.23.28.48;	author jlee;	state Exp;
branches;
next	1.14;
commitid	rTORMrQfEY7XggBw;

1.14
date	2012.09.18.13.49.15;	author jlee;	state Exp;
branches;
next	1.13;
commitid	kPVw3k71agHe71lw;

1.13
date	2012.09.10.21.32.46;	author jlee;	state Exp;
branches;
next	1.12;
commitid	L45O4zI0nGicW1kw;

1.12
date	2012.09.02.20.03.41;	author jlee;	state Exp;
branches;
next	1.11;
commitid	FetF3i2OxxUzHZiw;

1.11
date	2012.08.28.23.12.41;	author bavison;	state Exp;
branches;
next	1.10;
commitid	BMUpqstey7aoUmiw;

1.10
date	2012.08.02.00.43.29;	author jlee;	state Exp;
branches;
next	1.9;
commitid	p73b1WEma91lhUew;

1.9
date	2012.07.22.22.32.51;	author jballance;	state Exp;
branches;
next	1.8;
commitid	6IVuPWq7pOksSBdw;

1.8
date	2012.07.19.10.29.23;	author jballance;	state Exp;
branches;
next	1.7;
commitid	7w2Uohftp8BdY9dw;

1.7
date	2012.07.07.19.46.23;	author jlee;	state Exp;
branches;
next	1.6;
commitid	qeOmpWpRzmnerFbw;

1.6
date	2012.06.03.14.03.39;	author jlee;	state Exp;
branches;
next	1.5;
commitid	xDMdy452l0MpDg7w;

1.5
date	2012.05.24.11.30.06;	author bavison;	state Exp;
branches;
next	1.4;
commitid	ktC5TlFk2flF6Y5w;

1.4
date	2012.05.23.21.45.07;	author bavison;	state Exp;
branches;
next	1.3;
commitid	dyGUTwLbAf3ExT5w;

1.3
date	2012.05.22.23.56.18;	author jballance;	state Exp;
branches;
next	1.2;
commitid	9zrOo5VjFU0EiM5w;

1.2
date	2012.05.20.20.52.48;	author jballance;	state Exp;
branches;
next	1.1;
commitid	2BhE7hfsP23Glv5w;

1.1
date	2012.05.10.14.53.41;	author bavison;	state Exp;
branches
	1.1.1.1;
next	;
commitid	9gwxHjLZncMLBb4w;

1.29.2.1
date	2018.10.26.19.31.36;	author bavison;	state Exp;
branches;
next	;
commitid	HzYe59LD1XidmvXA;

1.27.2.1
date	2017.07.29.11.37.40;	author jlee;	state Exp;
branches;
next	1.27.2.2;
commitid	leIbdlwVfACHk71A;

1.27.2.2
date	2017.07.31.22.18.15;	author jlee;	state Exp;
branches;
next	1.27.2.3;
commitid	VmVokWQ7fiZsOq1A;

1.27.2.3
date	2018.07.07.14.12.54;	author jlee;	state Exp;
branches;
next	;
commitid	rGMJuwVBIwKoadJA;

1.1.1.1
date	2012.05.10.14.53.41;	author bavison;	state Exp;
branches;
next	;
commitid	9gwxHjLZncMLBb4w;


desc
@@


1.31
log
@Merge branch to trunk

Not tagged
@
text
@;
; Copyright (c) 2012, RISC OS Open Ltd
; Copyright (c) 2012, Adrian Lees
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met:
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in the
;       documentation and/or other materials provided with the distribution.
;     * Neither the name of RISC OS Open Ltd nor the names of its contributors
;       may be used to endorse or promote products derived from this software
;       without specific prior written permission.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.
;
; With many thanks to Broadcom Europe Ltd for releasing the source code to
; its Linux drivers, thus making this port possible.
;


        [ :LNOT: :DEF: BCM2835_Hdr
        GBLL BCM2835_Hdr

          ; Debugging in the serial port (HAL_DebugTX, HAL_DebugRX)
          GBLL    Debug
Debug     SETL    {FALSE}

          ; Debug messages from the HAL itself
          GBLL    HALDebug
HALDebug  SETL    {FALSE} :LAND: Debug

          ; Enable JTAG support
          ;
          ; This reconfigures GPIO22-27 into alt4 mode, which maps the ARM JTAG
          ; signals to the following pins on the 40-pin GPIO header that's
          ; found on the B+ and later models:
          ;
          ; GPIO22  ARM_TRST  pin 15
          ; GPIO23  ARM_RTCK  pin 16
          ; GPIO24  ARM_TDO   pin 18
          ; GPIO25  ARM_TCK   pin 22
          ; GPIO26  ARM_TDI   pin 37
          ; GPIO27  ARM_TMS   pin 13
          ;
          ; If you want to debug an older board then you'll have to adjust the
          ; code accordingly (n.b. revision 1 boards for Pi 1B only have ARM_TDI
          ; available via the camera header, which will be awkward to get
          ; access to)
          ;
          ; As a precaution, this setting will also disable registration of the
          ; GPIO HAL device
          GBLL    JTAG
JTAG      SETL    {FALSE}

; RPi ARM11 registers

; 4Gbytes of address space.
; 00000000-0000001F reserved for exception vectors
; FFFFE000-FFFFFFFF allocated to control registers

; Bus memory map, for direct DMA access to devices
; 7e000000-7effffff I/O peripherals for DMA access
; c0000000-???????? SDRAM physical for DMA

; Our physical memory map:
; 00000000-???????? SDRAM  upper bound set at boot
; 20000000-20ffffff IO_Base for peripherals
; 3fffffff          top of physical memory space

; Address window 0 is set to 4K and points to a single page of HAL workspace for the messaging
; unit.


;ROM_Base        *       &00000000
IO_Base_BCM2835     *   &20000000
IO_Base_BCM2836     *   &3F000000           ; it moves in Pi 2
IO_Size         *       &01000000
RAM_Base        *       &00000000           ; try off bottom
Boot_RAM_Base   *       &00000000
DMA_RAM_Base    *       &C0000000           ; base physical address of ram for DMA purposes
GPU_UnCached    *       &c0000000           ; GPU mempry mapping uncached
GPU_L2Conly     *       &80000000           ; GPU L2 Cached (only)
GPU_L2CnonAl    *       &40000000           ; GPU L2 cached non allocating coherent
GPU_L1L2Cac     *       &00000000           ; both L1 and L2 cached GPU side
GPU_CacheMask   *       &c0000000

; Exit CC if ARM11, CS if A7/A53
        MACRO
$label  CPUDetect $reg
$label  MRC     p15, 0, $reg, c0, c0, 0  ; read Main ID Register
        AND     $reg, $reg, #&FF00
        CMP     $reg, #&C000             ; xxxxB76x for ARM1176, xxxxC07x for Cortex-A7
        MEND

; Acquire/release the HAL spinlock
; This is mainly for quad-core devices, but will work with ARMv6 too
        MACRO
        AcquireSpinlock ; Corrupts ip, NZ, stashes old PSR on stack
        MRS     ip, CPSR
        Push    "ip"
        ADD     sb, sb, #:INDEX:Spinlock
        CPSID   if
10
        LDREX   ip, [sb]
        TEQ     ip, #0
        WFENE
        STREXEQ ip, sb, [sb]
        TEQEQ   ip, #0
        BNE     %BT10
        MCR     p15, 0, ip, c7, c10, 5  ; a.k.a DoMemBarrier, but ip already 0
        SUB     sb, sb, #:INDEX:Spinlock
        MEND

        MACRO
        ReleaseSpinlock ; Corrupts ip
        MOV     ip, #0
        MCR     p15, 0, ip, c7, c10, 5  ; a.k.a DoMemBarrier, but ip already 0
        STR     ip, Spinlock            ; Clear spinlock before barrier
        MCR     p15, 0, ip, c7, c10, 4  ; a.k.a DataSyncBarrier, but ip already 0
        SEV
        Pull    "ip"
        MSR     CPSR_c, ip
        MEND

;
; Timer details
;
TIMER_RATE      *       1000000            ; 1MHz

                GBLA    NumTimers
NumTimers       SETA    0

        MACRO
        DeclareTimer    $phys
TimerPhysFromLog$NumTimers      *       $phys
NumTimers                       SETA    NumTimers + 1
        MEND

; List of physical timers (excluding those already used by VideoCore)
; in the order we use them for logical timers
        DeclareTimer 1
        DeclareTimer 3

; An assembly-time variable for looping over all logical timers, since
; the available timers might vary with version of start.elf
        GBLA    Timer


;
; Mailbox
;
; There are two mailboxes; we write to mailbox 1 and read from mailbox 0
;
MB_Base        *       &0000b800     ; offset from IO space start
MB_DBell0      *       &40           ; doorbell 0 (VCHIQ VC -> ARM)
MB_DBell1      *       &44           ; doorbell 1
MB_DBell2      *       &48           ; doorbell 2 (VCHIQ ARM -> VC)
MB_DBell3      *       &4c           ; doorbell 3
MB_ChRd        *       &80           ; normal read - offset from MB_Base
MB_ChWr        *       &a0           ; normal write
MB_ChRWTop     *       &8c           ; 4 word read or write
MB_Pol         *       &90           ; NonPOP read
MB_Snd         *       &94           ; sender read (bottom 2 bits)
MB_Sta         *       &98           ; status read
MB_Cnf         *       &9c           ; config r/w
;
; mailbox register bits
;
; MB_Sta
MB_Sta_Full    *       &80000000     ; mailbox full
MB_Sta_Empty   *       &40000000     ; mailbox empty
MB_Sta_Level   *       &000000ff     ; mailbox content count
; MB_Cnf
MB_Cnf_HDIrqEn *       &00000001     ; mailbox has-data irq enable
MB_Cnf_HSIrqEn *       &00000002     ; mailbox has-space irq enable
MB_Cnf_OpIrqEn *       &00000004     ; mailbox Opp irq en
MB_Cnf_MBClr   *       &00000008     ; write 1 then 0 to clear mailbox
MB_Cnf_HDIrq   *       &00000010     ; mailbox has-data irq pending
MB_Cnf_HSIrq   *       &00000020     ; mailbox has-space irq pending
MB_Cnf_OpIrq   *       &00000040     ; mailbox Opp irq pending
; these flags are reset on any write to this register
MB_Cnf_ErNone  *       &00000100     ; none read error
MB_Cnf_ErWFull *       &00000200     ; Write to full mailbox
MB_Cnf_ErREmty *       &00000400     ; read from empty mailbox

; mem barrier operation; ensures all explicit mem operations completed before
; instruction exits.
; (value 4 is all instructions, value 5 is just mem instructions)
; zeroes $r
        MACRO
$label  DataSyncBarrier $r, $cond
$label  MOV$cond $r, #0
      [ {UAL}
        MCR$cond p15, #0, $r, c7, c10, #4
      |
        MCR$cond p15, 0, $r, c7, c10,4
      ]
        MEND
        MACRO
$label  DoMemBarrier $r, $cond
$label  MOV$cond $r, #0
      [ {UAL}
        MCR$cond p15, #0, $r, c7, c10, #5
      |
        MCR$cond p15, 0, $r, c7, c10,5
      ]
        MEND

        MACRO
$label  FlushDataCacheV6 $tmp
$label  MOV     $tmp, #0
        MCR     p15, 0, $tmp, c7, c14, 0        ; clean and invalidate entire data cache
        MEND

        MACRO
$label  FlushDataCacheV7 $clidr, $loc, $level, $ccsidr, $linelen, $way, $wayshift, $set, $tmp
$label  MRC     p15, 1, $clidr, c0, c0, 1       ; read CLIDR
        ANDS    $loc, $clidr, #&07000000
        MOV     $loc, $loc, LSR #23             ; extract level of coherence * 2
        BEQ     %F99                            ; nothing to do if loc = 0
        MOV     $level, #0                      ; cache level * 2
10      ADD     $tmp, $level, $level, LSR #1    ; cache level * 3
        MOV     $tmp, $clidr, LSR $tmp
        AND     $tmp, $tmp, #7
        CMP     $tmp, #2
        BLT     %FT40                           ; no cache or only instruction cache at this level
        MCR     p15, 2, $level, c0, c0, 0       ; write CSSELR
        ISB                                     ; sync the change to the CCSIDR
        MRC     p15, 1, $ccsidr, c0, c0, 0      ; read current CCSIDR
        AND     $linelen, $ccsidr, #7           ; extract the line length field
        ADD     $linelen, $linelen, #4          ; add 4 for the line length offset (log2 16 bytes)
        UBFX    $way, $ccsidr, #3, #10          ; associativity aka number of ways
        CLZ     $wayshift, $way
20      UBFX    $set, $ccsidr, #13, #15         ; number of sets
30      ORR     $tmp, $level, $way, LSL $wayshift
        ORR     $tmp, $tmp, $set, LSL $linelen
        MCR     p15, 0, $tmp, c7, c14, 2        ; data cache clean and invalidate by set/way
        SUBS    $set, $set, #1
        BGE     %BT30
        SUBS    $way, $way, #1
        BGE     %BT20
        DSB                                     ; Cortex-A7 errata 814220: DSB required when changing cache levels when using set/way operations. This also counts as our end-of-maintenance DSB.
40      ADD     $level, $level, #2
        CMP     $level, $loc
        BLT     %BT10
99
        MEND

        MACRO
$label  FlushDataCache
$label  CPUDetect lr
        BCS     %FA07
        FlushDataCacheV6 lr
        B       %FT99
07      STMFD   r13!, {r4-r9}
        FlushDataCacheV7 r2,r3,r4,r5,r6,r7,r8,r9,lr
        LDMFD   r13!, {r4-r9}
99
        MEND
      
        MACRO
$label  FlushDataCacheRange $startaddr,$endaddr,$cond
$label  BIC$cond $startaddr, $startaddr, #&1f
        BIC$cond $endaddr,   $endaddr,   #&1f
      [ {UAL}
        MCRR$cond p15, #0, $endaddr, $startaddr, c14
      |
        MCRR$cond p15, 0, $endaddr, $startaddr, c14
      ]
        MEND

; Board revision values (pre Pi 2), enumerated scheme
; Ref: https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md
BoardRevision_AorB256_First  * &2          ; } Either an A or B
BoardRevision_AorB256_Last   * &9          ; } various manufacturers
BoardRevision_AorB512_First  * &D          ; } Either an A or B
BoardRevision_AorB512_Last   * &F          ; } various manufacturers
BoardRevision_AorB_First     * &2          ; } Either an A or B, 256MB or 512MB
BoardRevision_AorB_Last      * &F          ; } and various manufacturers
BoardRevision_BPlus_Sony     * &10         ; Significant board revisions
BoardRevision_Compute_Sony   * &11
BoardRevision_APlus_Sony     * &12
BoardRevision_BPlus_Embest   * &13
BoardRevision_Compute_Embest * &14
BoardRevision_APlus_Embest   * &15

; Board revision values (Pi 2 and later), bitfield scheme
BoardRevision_User_Shift    *  24
BoardRevision_User_Mask     * 255 :SHL: BoardRevision_User_Shift
BoardRevision_Warranty      *   1 :SHL: 25 ; if set, warranty void (Pi 2 and later)
BoardRevision_WarrantyOld   *   1 :SHL: 24 ; if set, warranty void (pre Pi 2)
BoardRevision_NewScheme     *   1 :SHL: 23 ; if set, indicates the following are in use
BoardRevision_Mem_Shift     *  20
BoardRevision_Mem_Mask      *   7 :SHL: BoardRevision_Mem_Shift
BoardRevision_Mem_256M      *   0 :SHL: BoardRevision_Mem_Shift
BoardRevision_Mem_512M      *   1 :SHL: BoardRevision_Mem_Shift
BoardRevision_Mem_1G        *   2 :SHL: BoardRevision_Mem_Shift
BoardRevision_Manuf_Shift   *  16
BoardRevision_Manuf_Mask    *  15 :SHL: BoardRevision_Manuf_Shift
BoardRevision_Manuf_Sony    *   0 :SHL: BoardRevision_Manuf_Shift
BoardRevision_Manuf_Egoman  *   1 :SHL: BoardRevision_Manuf_Shift
BoardRevision_Manuf_Embest  *   2 :SHL: BoardRevision_Manuf_Shift
BoardRevision_Manuf_SonyJP  *   3 :SHL: BoardRevision_Manuf_Shift
BoardRevision_Manuf_Embest2 *   4 :SHL: BoardRevision_Manuf_Shift
BoardRevision_Proc_Shift    *  12
BoardRevision_Proc_Mask     *  15 :SHL: BoardRevision_Proc_Shift
BoardRevision_Proc_2835     *   0 :SHL: BoardRevision_Proc_Shift
BoardRevision_Proc_2836     *   1 :SHL: BoardRevision_Proc_Shift
BoardRevision_Proc_2837     *   2 :SHL: BoardRevision_Proc_Shift
BoardRevision_Model_Shift   *   4
BoardRevision_Model_Mask    * 255 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_A       *   0 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_B       *   1 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_APlus   *   2 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_BPlus   *   3 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_B2      *   4 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_Compute *   6 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_B3      *   8 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_Zero    *   9 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_Compute3 * 10 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_ZeroW   *  12 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_B3Plus  *  13 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_A3Plus  *  14 :SHL: BoardRevision_Model_Shift
BoardRevision_Rev_Shift     *   0
BoardRevision_Rev_Mask      *  15 :SHL: BoardRevision_Rev_Shift

; GPIO register set
GPIO_Base    *        &00200000      ; base offset of GPIO regs
GPFSel0      *        &0             ; function sel 0
GPFSel1      *        &4             ; function sel 1
GPFSel2      *        &8             ; function sel 2
GPFSel3      *        &c             ; function sel 3
GPFSel4      *        &10            ; function sel 4
GPFSel5      *        &14            ; function sel 5
GPSet0       *        &1c            ; GPIO Set 0
GPSet1       *        &20            ; GPIO Set 1
GPClr0       *        &28            ; GPIO Clear 0
GPClr1       *        &2c            ; GPIO Clear 1
GPLev0       *        &34            ; GPIO Level 0
GPLev1       *        &38            ; GPIO Level 1
GPPEDS0      *        &40            ; GPIO Pin Event Detect Status 0
GPPEDS1      *        &44            ; GPIO Pin Event Detect Status 1
GPREDE0      *        &4c            ; GPIO rising edge detect enable 0
GPREDE1      *        &50            ; GPIO rising edge detect enable 1
GPFEDE0      *        &58            ; GPIO falling edge detect enable 0
GPFEDE1      *        &5c            ; GPIO falling edge detect enable 1
GPHIDE0      *        &64            ; GPIO High detect enable 0
GPHIDE1      *        &68            ; GPIO High detect enable 1
GPLODE0      *        &70            ; GPIO Low detect enable 0
GPLODE1      *        &74            ; GPIO Low detect enable 1
GPAREDE0     *        &7c            ; GPIO Async rising edge detect enable 0
GPAREDE1     *        &80            ; GPIO Async rising edge detect enable 1
GPAFEDE0     *        &88            ; GPIO Async falling edge detect enable 0
GPAFEDE1     *        &8c            ; GPIO Async falling edge detect enable 1
GPPUPDEN     *        &94            ; GPIO PullUp PullDown Enable
GPPUDCK0     *        &98            ; GPIO PullUp PullDown Clock 0
GPPUDCK1     *        &9c            ; GPIO PullUp PullDown Clock 1

; Auxio peripherals
; MiniUart uses TXD1 and RXD1
; txd1 is GPIO14 alt 5  (010)
; rxd1 is GPIO15 alt 5
; rts1 is GPIO17 alt 5
AUXIO_Base   *        &00215000      ; base of auxio regs
AUXIRQ       *        &0             ; IRQ status
AUXEnables   *        &4             ; AUX enables
AUXMUIO      *        &40            ; MiniUart IO data
AUXMUIER     *        &44            ; MU int enable
AUXMUIIR     *        &48            ; MU int identify
AUXMULCR     *        &4c            ; MU Line Control
AUXMUMCR     *        &50            ; MU Modem Control
AUXMULSR     *        &54            ; MU Line Status
AUXMUMSR     *        &58            ; MU Control Status
AUXMUSCRATCH *        &5c            ; MU Scratch reg
AUXMUCNTL    *        &60            ; MU extra control
AUXMUSTAT    *        &64            ; MU extra status
AUXMUBAUD    *        &68            ; MU Baud rate

AUXSPI0      *        &80            ; Aux SPI0 (aka SPI1) base
AUXSPI1      *        &C0            ; Aux SPI1 (aka SPI2) base
AUXSPICNTL0  *        &0             ; Aux API control 0
AUXSPICNTL1  *        &4             ; Aux SPI control 1
AUXSPISTAT   *        &8             ; Aux API status
AUXSPIIO     *        &10            ; Aux API data
AUXSPIPEEK   *        &14            ; Aux SPI PEEK


; UART TXD0 RXD0
; txd0 is GPIO14 alt 0  (100)
; rxd0 is GPIO15 alt 0
UART_Base    *        &00201000      ; base of uart regs
UART1_offset *        &00004000      ; offset to base of uart1 regs
                                     ; mini uart (above)
UARTDR       *        &0             ; data reg
UARTRSRECR   *        &4             ;
UARTFLAG     *        &18            ;
UARTIBRD     *        &24            ; int baud reg
UARTFBRD     *        &28            ; fract baud reg
UARTLCRH     *        &2c            ; Line Control
UARTCR       *        &30            ; Control Reg
UARTIFLS     *        &34            ; Int FIFO Level
UARTIMSC     *        &38            ; Int Mask set clear
UARTRIS      *        &3c            ; raw int status
UARTMIS      *        &40            ; masked int status
UARTICR      *        &44            ; irq clr
UARTDMACR    *        &40            ; DMA Control
UARTITCR     *        &80            ; test control
UARTITIP     *        &84            ; integr test ip
UARTITOP     *        &88            ; integ test op
UARTTDR      *        &8c            ; test data reg

; GPU System Timer
Timer_Base   *        &00003000      ; base of system timer regs
ST_CS        *        &00            ; control/status
ST_CLO       *        &04            ; counter low
ST_CHI       *        &08            ; counter high
ST_C0        *        &0C            ; compare 0
ST_C1        *        &10            ; compare 1
ST_C2        *        &14            ; compare 2
ST_C3        *        &18            ; compare 3

; ARM Timer
ARM_Timer_Base *      &0000b400      ; base of ARM timer regs

; DMA registers
DMA_Base     *        &00007000

; DMA_CH_Count *        13 ; Allegedly 16 channels, but can only get IRQs from 13 of them?
DMA_CH_Count *        12 ; Was 13, but firmware bug is incorrectly reporting that ch 12 is available

; Message-based parallel host interface
MPHI_Base    *        &00006000

; Power management
PM_Base      *        &00100000      ; power management
PM_Password  *        &5a000000      ; for writes to be accepted
PM_GNRIC     *        &00
PM_AUDIO     *        &04
PM_STATUS    *        &18
PM_RSTC      *        &1c            ; reset control reg
PM_RSTS      *        &20            ; reset status reg
PM_WDOG      *        &24            ; watchdog control reg
; register bits
PM_RSTC_DRCFG_MASK *   &00000003
PM_RSTC_WRCFG_MASK *   &00000030
PM_RSTC_WRCFG_FULLRST * &00000020
PM_RSTC_SRCFG_MASK *   &00000300
PM_RSTC_QRCFG_MASK *   &00003000
PM_RSTC_FRCFG_MASK *   &00030000
PM_RSTC_HRCFG_MASK *   &00300000
PM_RSTS_HADDRQ     *   1:SHL:0
PM_RSTS_HADDRF     *   1:SHL:1
PM_RSTS_HADDRH     *   1:SHL:2
PM_RSTS_HADWRQ     *   1:SHL:4
PM_RSTS_HADWRF     *   1:SHL:5
PM_RSTS_HADWRH     *   1:SHL:6
PM_RSTS_HADSRQ     *   1:SHL:8
PM_RSTS_HADSRF     *   1:SHL:9
PM_RSTS_HADSRH     *   1:SHL:10
PM_RSTS_HADPOR     *   1:SHL:12
PM_WDOG_TIME_MASK  *   &000fffff
;
;
USB_Base     *        &00980000      ; USB
ISP_Base     *        &00a00000      ; ISP
;
; Interrupt handling
;
IRQ_Base           *  &0000B200
IRQ_PENDB          *  &00            ; read: pending basic interrupts (devices 64-95)
IRQ_PEND1          *  &04            ; read: pending interrupts 1 (GPU IRQs 0-31, devices 0-31)
IRQ_PEND2          *  &08            ; read: pending interrupts 2 (GPU IRQs 32-63, devices 32-63)
IRQ_FIQCTL         *  &0C            ; FIQ control register
IRQ_EN1            *  &10            ; read: enabled interrupts 1;     write: bits to OR into enabled interrupts 1
IRQ_EN2            *  &14            ; read: enabled interrupts 2;     write: bits to OR into enabled interrupts 2
IRQ_ENB            *  &18            ; read: enabled basic interrupts; write: bits to OR into enabled basic interrupts
IRQ_DIS1           *  &1C            ; read: enabled interrupts 1;     write: bits to BIC from enabled interrupts 1
IRQ_DIS2           *  &20            ; read: enabled interrupts 2;     write: bits to BIC from enabled interrupts 2
IRQ_DISB           *  &24            ; read: enabled basic interrupts; write: bits to BIC from enabled basic interrupts

; Raspberry Pi interrupt sources.
; Because the pending and enable registers are listed in different orders, there are 2 logical ways to map these onto
; device numbers. However, matching the order of the enable registers has the following advantages:
; * the same device numbers can be used in the FIQ control register without modification
; * the GPU timer interrupts end up with the lowest priority - desirable since we run our counter from them

; devices in register 1  - start at 0
iDev_GPU_Timer0     *     0    ; not on list in datasheet
iDev_GPU_Timer1     *     1    ; not on list in datasheet
iDev_GPU_Timer2     *     2    ; not on list in datasheet
iDev_GPU_Timer3     *     3    ; not on list in datasheet
iDev_GPU_Codec0     *     4    ; not on list in datasheet
iDev_GPU_Codec1     *     5    ; not on list in datasheet
iDev_GPU_Codec2     *     6    ; not on list in datasheet
iDev_GPU_VCJPEG     *     7    ; not on list in datasheet
iDev_GPU_ISP        *     8    ; not on list in datasheet
iDev_GPU_VCUSB      *     9    ; not on list in datasheet
iDev_GPU_VC3D       *     10   ; not on list in datasheet
iDev_GPU_Transp     *     11   ; not on list in datasheet
iDev_GPU_MCSync0    *     12   ; not on list in datasheet
iDev_GPU_MCSync1    *     13   ; not on list in datasheet
iDev_GPU_MCSync2    *     14   ; not on list in datasheet
iDev_GPU_MCSync3    *     15   ; not on list in datasheet
iDev_GPU_DMA0       *     16   ; not on list in datasheet
iDev_GPU_DMA1       *     17   ; not on list in datasheet
iDev_GPU_VCDMA2     *     18   ; not on list in datasheet
iDev_GPU_VCDMA3     *     19   ; not on list in datasheet
iDev_GPU_DMA4       *     20   ; not on list in datasheet
iDev_GPU_DMA5       *     21   ; not on list in datasheet
iDev_GPU_DMA6       *     22   ; not on list in datasheet
iDev_GPU_DMA7       *     23   ; not on list in datasheet
iDev_GPU_DMA8       *     24   ; not on list in datasheet
iDev_GPU_DMA9       *     25   ; not on list in datasheet
iDev_GPU_DMA10      *     26   ; not on list in datasheet
iDev_GPU_DMA11      *     27   ; not on list in datasheet
iDev_GPU_DMA12      *     28   ; not on list in datasheet
iDev_GPU_AuxInt     *     29
iDev_GPU_ARM        *     30   ; not on list in datasheet
iDev_GPU_VPUDMA     *     31   ; not on list in datasheet
; devices in register 2  - start at 32
iDev_GPU_HostPort   *     32   ; not on list in datasheet
iDev_GPU_VidScale   *     33   ; not on list in datasheet
iDev_GPU_CCP2TX     *     34   ; not on list in datasheet
iDev_GPU_SDC        *     35   ; not on list in datasheet
iDev_GPU_DSI0       *     36   ; not on list in datasheet
iDev_GPU_AVE        *     37   ; not on list in datasheet
iDev_GPU_Cam0       *     38   ; not on list in datasheet
iDev_GPU_Cam1       *     39   ; not on list in datasheet
iDev_GPU_HDMI0      *     40   ; not on list in datasheet
iDev_GPU_HDMI1      *     41   ; not on list in datasheet
iDev_GPU_PixVal1    *     42   ; not on list in datasheet
iDev_GPU_I2CSPISlv  *     43
iDev_GPU_DSI1       *     44   ; not on list in datasheet
iDev_GPU_PWA0       *     45
iDev_GPU_PWA1       *     46
iDev_GPU_CPR        *     47   ; not on list in datasheet
iDev_GPU_SMI        *     48
iDev_GPU_GPIO0      *     49
iDev_GPU_GPIO1      *     50
iDev_GPU_GPIO2      *     51
iDev_GPU_GPIO3      *     52
iDev_GPU_I2C        *     53
iDev_GPU_SPI        *     54
iDev_GPU_PCM        *     55
iDev_GPU_SDIO       *     56   ; not on list in datasheet
iDev_GPU_Uart       *     57
iDev_GPU_SlimBus    *     58   ; not on list in datasheet
iDev_GPU_Vec        *     59   ; not on list in datasheet
iDev_GPU_CPG        *     60   ; not on list in datasheet
iDev_GPU_RNG        *     61   ; not on list in datasheet
iDev_GPU_VCSDIO     *     62   ; not on list in datasheet
iDev_GPU_AVSPMON    *     63   ; not on list in datasheet
iDev_ARM_Timer      *     64+0
iDev_ARM_Mbx        *     64+1
iDev_ARM_DBell0     *     64+2
iDev_ARM_DBell1     *     64+3
iDev_ARM_GPU0Hlt    *     64+4
iDev_ARM_GPU1Hlt    *     64+5
iDev_ARM_IllegAcs1  *     64+6
iDev_ARM_IllegAcs0  *     64+7
; Notice that bits 8-31 of the pending basic interrupts cannot be masked. This causes the RISC OS kernel problems,
; because the default action for an unhandled interrupt is to mask it, and if masking doesn't work, we end up with an
; infinite loop. You *could* map these device numbers back to bits in the disable interrupts 1/2 registers, but it's
; not a simple mapping and the same bits appear in the pending interrupts 1/2 registers as well, so they're arguably
; not much use. Is the saving of one or two reads of the pending interrupt registers worth the complexity? I don't know.
; It's also worth noting that these device numbers are not valid for use as FIQs. So for now, I recommend you don't use
; these devices - use the equivalents in the GPU interrupt registers instead.
iDev_ARM_MiscGPU1   *     64+8    ; OR of GPU IRQs 0-31 excluding those listed below
iDev_ARM_MiscGPU2   *     64+9    ; OR of GPU IRQs 32-63 excluding those listed below
iDev_ARM_VCJPEG     *     64+10   ; copy of GPU IRQ 7
iDev_ARM_VCUSB      *     64+11   ; copy of GPU IRQ 9
iDev_ARM_VC3D       *     64+12   ; copy of GPU IRQ 10
iDev_ARM_VCDMA2     *     64+13   ; copy of GPU IRQ 18
iDev_ARM_VCDMA3     *     64+14   ; copy of GPU IRQ 19
iDev_ARM_I2C        *     64+15   ; copy of GPU IRQ 53
iDev_ARM_SPI        *     64+16   ; copy of GPU IRQ 54
iDev_ARM_PCM        *     64+17   ; copy of GPU IRQ 55
iDev_ARM_SDIO       *     64+18   ; copy of GPU IRQ 56
iDev_ARM_Uart       *     64+19   ; copy of GPU IRQ 57
iDev_ARM_VCSDIO     *     64+20   ; copy of GPU IRQ 62

iDev_ARM11_Max      *     64+21

; Extra interrupt sources for QA7
; These are all core-specific interrupts
; Note that the original interrupts (0 - iDev_ARM11_Max) can only be routed to
; one core at a time (although IRQ and FIQ can be routed differently if we
; desire). If iDev_QA7_GPU is firing, it indicates that we are the owner of the
; GPU interrupts and should check its status registers to determine the source.
iDev_QA7_Base       *     iDev_ARM11_Max
                    ^     iDev_QA7_Base
iDev_QA7_CNTPSIRQ   #     4 ; Core-specific
iDev_QA7_CNTPNSIRQ  #     4 ; Core-specific
iDev_QA7_CNTPHPIRQ  #     4 ; Core-specific
iDev_QA7_CNTPVIRQ   #     4 ; Core-specific
iDev_QA7_MBox0      #     4 ; Core-specific
iDev_QA7_MBox1      #     4 ; Core-specific
iDev_QA7_MBox2      #     4 ; Core-specific
iDev_QA7_MBox3      #     4 ; Core-specific
iDev_QA7_GPU        #     4 ; Each of IRQ+FIQ can only be assigned to one core at a time
iDev_QA7_PMU        #     4 ; Core-specific
iDev_QA7_AXI        #     4 ; Can only be IRQ of core 0
iDev_QA7_LocalTimer #     4 ; Can only be assigned to one core (as either IRQ or FIQ)

iDev_QA7_Max        #     0

;IIC0 (BSC0, i.e. Broadcom Serial Controller 0)
IIC_Base0           *     &00205000  ; base of IIC0
;IIC1 (BCS1, i.e. Broadcom Serial Controller 1)
IIC_Base1           *     &00804000
IIC_C               *     &00        ; Control
IIC_S               *     &04        ; Status
IIC_DLEN            *     &08        ; Data Length
IIC_A               *     &0C        ; Slave Address
IIC_FIFO            *     &10        ; Data FIFO
IIC_DIV             *     &14        ; Clock Divider
IIC_DEL             *     &18        ; Data Delay
IIC_CLKT            *     &1C        ; Clock Stretch Timeout

; ARM control registers for quad core chips (BCM2836, BCM2837, etc.)
; ref: https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2836/QA7_rev3.4.pdf
QA7_BASE              * &40000000
QA7_CONTROL               * &0000
QA7_CORE_TIMER_PRESCALE   * &0008
QA7_GPU_INT_ROUTING       * &000C
QA7_PMU_INT_ROUT_SET      * &0010
QA7_PMU_INT_ROUT_CLR      * &0014
QA7_CORE_TIMER_LSW        * &001C
QA7_CORE_TIMER_MSW        * &0020
QA7_LOCAL_INT_ROUTING     * &0024
QA7_AXI_OUTSTANDING_CNT   * &002C
QA7_AXI_OUTSTANDING_IRQ   * &0030
QA7_LOCAL_TIMER_CTRL_STAT * &0034
QA7_LOCAL_TIMER_WRFLAGS   * &0038
QA7_CORE0_TIMER_INT_CTRL  * &0040
QA7_CORE1_TIMER_INT_CTRL  * &0044
QA7_CORE2_TIMER_INT_CTRL  * &0048
QA7_CORE3_TIMER_INT_CTRL  * &004C
QA7_CORE0_MBOX_INT_CTRL   * &0050
QA7_CORE1_MBOX_INT_CTRL   * &0054
QA7_CORE2_MBOX_INT_CTRL   * &0058
QA7_CORE3_MBOX_INT_CTRL   * &005C
QA7_CORE0_IRQ_SOURCE      * &0060
QA7_CORE1_IRQ_SOURCE      * &0064
QA7_CORE2_IRQ_SOURCE      * &0068
QA7_CORE3_IRQ_SOURCE      * &006C
QA7_CORE0_FIQ_SOURCE      * &0070
QA7_CORE1_FIQ_SOURCE      * &0074
QA7_CORE2_FIQ_SOURCE      * &0078
QA7_CORE3_FIQ_SOURCE      * &007C
QA7_CORE0_MBOX0_SET       * &0080 ; Write to set bits in mailbox
QA7_CORE0_MBOX1_SET       * &0084
QA7_CORE0_MBOX2_SET       * &0088
QA7_CORE0_MBOX3_SET       * &008C
QA7_CORE1_MBOX0_SET       * &0090
QA7_CORE1_MBOX1_SET       * &0094
QA7_CORE1_MBOX2_SET       * &0098
QA7_CORE1_MBOX3_SET       * &009C
QA7_CORE2_MBOX0_SET       * &00A0
QA7_CORE2_MBOX1_SET       * &00A4
QA7_CORE2_MBOX2_SET       * &00A8
QA7_CORE2_MBOX3_SET       * &00AC
QA7_CORE3_MBOX0_SET       * &00B0
QA7_CORE3_MBOX1_SET       * &00B4
QA7_CORE3_MBOX2_SET       * &00B8
QA7_CORE3_MBOX3_SET       * &00BC
QA7_CORE0_MBOX0_RDCLR     * &00C0 ; Write to clear bits in mailbox
QA7_CORE0_MBOX1_RDCLR     * &00C4
QA7_CORE0_MBOX2_RDCLR     * &00C8
QA7_CORE0_MBOX3_RDCLR     * &00CC
QA7_CORE1_MBOX0_RDCLR     * &00D0
QA7_CORE1_MBOX1_RDCLR     * &00D4
QA7_CORE1_MBOX2_RDCLR     * &00D8
QA7_CORE1_MBOX3_RDCLR     * &00DC
QA7_CORE2_MBOX0_RDCLR     * &00E0
QA7_CORE2_MBOX1_RDCLR     * &00E4
QA7_CORE2_MBOX2_RDCLR     * &00E8
QA7_CORE2_MBOX3_RDCLR     * &00EC
QA7_CORE3_MBOX0_RDCLR     * &00F0
QA7_CORE3_MBOX1_RDCLR     * &00F4
QA7_CORE3_MBOX2_RDCLR     * &00F8
QA7_CORE3_MBOX3_RDCLR     * &00FC
QA7_SIZE                  * &40000

        ]
                END
@


1.30
log
@Merge SMP branch to trunk
Detail:
  hdr/StaticWS - Reserve workspace for QA7 peripheral address, HAL-wide spinlock, and doorbell device
  Makefile, s/DBell - Add doorbell device implementation
  hdr/BCM2835 - Clean up dead macros, add new macros for spinlock claim/release and basic CPU detection. Define new IRQ numbers for the "QA7" peripheral.
  hdr/CastleMacros, s/Top - Generate two HAL descriptors and entry point tables: One for single-core machines and one for multi-core machines. This avoids some MP-related overheads on ARM11 models of Pi. Implement SMP HAL entry points.
  s/Interrupts - Add support for the QA7 interrupts. Although some interrupts can be flexibly routed to different cores, we currently stick with a static scheme.
  s/Messaging - Use CPUDetect macro
Admin:
  Untested
  Requires Kernel-6_09


Version 0.76. Tagged as 'BCM2835-0_76'
@
text
@d336 1
@


1.29
log
@Fix SD activity LED on 3B+
Detail:
  hdr/BCM2835 - Add some new board revision values
  s/SDIO - Treat the 3B+ the same as the 3B when handling the activity LED. Also detect the Embest-manufactured CM1 and treat it the same as the Sony one.
Admin:
  Tested on Raspberry Pi 3B+


Version 0.74. Tagged as 'BCM2835-0_74'
@
text
@d100 1
a100 25
;
; Timer details
;
TIMER_RATE      *       1000000            ; 1MHz

        MACRO
$label  ReadTMR0 $r,$cond
$label  MRC$cond p6, 0, $r, c0, c1
        MEND
        MACRO
$label  ReadTMR1 $r,$cond
$label  MRC$cond p6, 0, $r, c1, c1
        MEND
        MACRO
$label  ReadTCR0 $r,$cond
$label  MRC$cond p6, 0, $r, c2, c1
        MEND
        MACRO
$label  ReadTCR1 $r,$cond
$label  MRC$cond p6, 0, $r, c3, c1
        MEND
        MACRO
$label  ReadTRR0 $r,$cond
$label  MRC$cond p6, 0, $r, c4, c1
        MEND
d102 23
a124 10
$label  ReadTRR1 $r,$cond
$label  MRC$cond p6, 0, $r, c5, c1
        MEND
        MACRO
$label  ReadTISR $r,$cond
$label  MRC$cond p6, 0, $r, c6, c1
        MEND
        MACRO
$label  ReadWDTCR $r,$cond
$label  MRC$cond p6, 0, $r, c7, c1
d128 8
a135 30
$label  WriteTMR0 $r,$cond
$label  MCR$cond p6, 0, $r, c0, c1
        MEND
        MACRO
$label  WriteTMR1 $r,$cond
$label  MCR$cond p6, 0, $r, c1, c1
        MEND
        MACRO
$label  WriteTCR0 $r,$cond
$label  MCR$cond p6, 0, $r, c2, c1
        MEND
        MACRO
$label  WriteTCR1 $r,$cond
$label  MCR$cond p6, 0, $r, c3, c1
        MEND
        MACRO
$label  WriteTRR0 $r,$cond
$label  MCR$cond p6, 0, $r, c4, c1
        MEND
        MACRO
$label  WriteTRR1 $r,$cond
$label  MCR$cond p6, 0, $r, c5, c1
        MEND
        MACRO
$label  WriteTISR $r,$cond
$label  MCR$cond p6, 0, $r, c6, c1
        MEND
        MACRO
$label  WriteWDTCR $r,$cond
$label  MCR$cond p6, 0, $r, c7, c1
d138 4
d264 1
a264 3
$label  MRC     p15, 0, lr, c0, c0, 0    ; read Main ID Register
        AND     lr, lr, #&FF00
        CMP     lr, #&C000               ; xxxxB76x for ARM1176, xxxxC07x for Cortex-A7
d594 24
a617 1
iDev_Max            *     64+21
d695 1
a695 34

        MACRO
$label  ReadINTCTL $r,$cond
$label  MRC$cond p6, 0, $r, c0, c0
        MEND
        MACRO
$label  ReadINTSTR $r,$cond
$label  MRC$cond p6, 0, $r, c4, c0
        MEND
        MACRO
$label  ReadIINTSRC $r,$cond
$label  MRC$cond p6, 0, $r, c8, c0
        MEND
        MACRO
$label  ReadFINTSRC $r,$cond
$label  MRC$cond p6, 0, $r, c9, c0
        MEND

        MACRO
$label  WriteINTCTL $r,$cond
$label  MCR$cond p6, 0, $r, c0, c0
        MEND
        MACRO
$label  WriteINTSTR $r,$cond
$label  MCR$cond p6, 0, $r, c4, c0
        MEND
        MACRO
$label  WriteIINTSRC $r,$cond
$label  MCR$cond p6, 0, $r, c8, c0
        MEND
        MACRO
$label  WriteFINTSRC $r,$cond
$label  MCR$cond p6, 0, $r, c9, c0
        MEND
@


1.29.2.1
log
@Add support for Pi model 3A+

Tagged as 'BCM2835-0_75-1'
@
text
@a366 1
BoardRevision_Model_A3Plus  *  14 :SHL: BoardRevision_Model_Shift
@


1.28
log
@Typos
:LNOT -> :LNOT:
GPOI -> GPIO
set -> cleared
No code change, not tagged.
@
text
@d317 13
a329 10
; Ref: http://elinux.org/RPi_HardwareHistory#Board_Revision_History
BoardRevision_AorB256_First * &2           ; } Either an A or B
BoardRevision_AorB256_Last  * &9           ; } various manufacturers
BoardRevision_AorB512_First * &D           ; } Either an A or B
BoardRevision_AorB512_Last  * &F           ; } various manufacturers
BoardRevision_AorB_First    * &2           ; } Either an A or B, 256MB or 512MB
BoardRevision_AorB_Last     * &F           ; } and various manufacturers
BoardRevision_BPlus         * &10          ; Significant board revisions
BoardRevision_Compute       * &11
BoardRevision_APlus         * &12
d365 2
@


1.27
log
@Transition Pi HAL to GPIO API 1.00
Detail:
  Move the register accesses for GPIO to the HAL, since they are hardware specific.
  Add recognition of board types for Pi 3, Compute module 3, rev 3 Pi 0's, and the newer Pi 2's with BCM2837 on them.
Admin:
  Based in part on a submission from Tank.
  Tested on a Pi 2. Requires corresponding GPIO module (tag GPIO-1_00-1_11_2_1 or later).

Version 0.67. Tagged as 'BCM2835-0_67'
@
text
@d34 1
a34 1
        [ :LNOT :DEF: BCM2835_Hdr
d379 2
a380 2
GPPEDS0      *        &40            ; GPOI Pin Event Detect Status 0
GPPEDS1      *        &44            ; GPOI Pin Event Detect Status 1
@


1.27.2.1
log
@Initial SMP support
Detail:
  hdr/BCM2835 - Delete unused timer macros. Add basic spinlock claim/release macros. Add CPUDetect macro to encapsulate ARM11 vs. A7/A53 detection. Add definitions for the "QA7" interrupts.
  Makefile, s/DBell - Add doorbell device driver
  hdr/StaticWS - Reserve workspace for doorbell device, QA7 interrupt controller ptr, spinlock
  s/Top, hdr/CastleMacros - Generate two HAL entry point tables, one for ARM11, one for A7/A53. Use CPUDetect macro. Implement new SMP-related HAL entry points.
  s/Interrupts - Implement support for the QA7 interrupt controller and the new IRQ-related HAL entry points
  s/Messaging - Use CPUDetect macro
Admin:
  Tested on Raspberry Pi 1, 2, 3


Version 0.70, 1.70.2.1. Tagged as 'BCM2835-0_70-1_70_2_1'
@
text
@d100 25
a124 1
; Exit CC if ARM11, CS if A7/A53
d126 10
a135 23
$label  CPUDetect $reg
$label  MRC     p15, 0, $reg, c0, c0, 0  ; read Main ID Register
        AND     $reg, $reg, #&FF00
        CMP     $reg, #&C000             ; xxxxB76x for ARM1176, xxxxC07x for Cortex-A7
        MEND

; Acquire/release the HAL spinlock
; This is mainly for quad-core devices, but will work with ARMv6 too
        MACRO
        AcquireSpinlock ; Corrupts ip, NZ, stashes old PSR on stack
        MRS     ip, CPSR
        Push    "ip"
        ADD     sb, sb, #:INDEX:Spinlock
        CPSID   if
10
        LDREX   ip, [sb]
        TEQ     ip, #0
        WFENE
        STREXEQ ip, sb, [sb]
        TEQEQ   ip, #0
        BNE     %BT10
        MCR     p15, 0, ip, c7, c10, 5  ; a.k.a DoMemBarrier, but ip already 0
        SUB     sb, sb, #:INDEX:Spinlock
d139 30
a168 8
        ReleaseSpinlock ; Corrupts ip
        MOV     ip, #0
        MCR     p15, 0, ip, c7, c10, 5  ; a.k.a DoMemBarrier, but ip already 0
        STR     ip, Spinlock            ; Clear spinlock before barrier
        MCR     p15, 0, ip, c7, c10, 4  ; a.k.a DataSyncBarrier, but ip already 0
        SEV
        Pull    "ip"
        MSR     CPSR_c, ip
a170 4
;
; Timer details
;
TIMER_RATE      *       1000000            ; 1MHz
d293 3
a295 1
$label  CPUDetect lr
d620 1
a620 24
iDev_ARM11_Max      *     64+21

; Extra interrupt sources for QA7
; These are all core-specific interrupts
; Note that the original interrupts (0 - iDev_ARM11_Max) can only be routed to
; one core at a time (although IRQ and FIQ can be routed differently if we
; desire). If iDev_QA7_GPU is firing, it indicates that we are the owner of the
; GPU interrupts and should check its status registers to determine the source.
iDev_QA7_Base       *     iDev_ARM11_Max
                    ^     iDev_QA7_Base
iDev_QA7_CNTPSIRQ   #     4 ; Core-specific
iDev_QA7_CNTPNSIRQ  #     4 ; Core-specific
iDev_QA7_CNTPHPIRQ  #     4 ; Core-specific
iDev_QA7_CNTPVIRQ   #     4 ; Core-specific
iDev_QA7_MBox0      #     4 ; Core-specific
iDev_QA7_MBox1      #     4 ; Core-specific
iDev_QA7_MBox2      #     4 ; Core-specific
iDev_QA7_MBox3      #     4 ; Core-specific
iDev_QA7_GPU        #     4 ; Each of IRQ+FIQ can only be assigned to one core at a time
iDev_QA7_PMU        #     4 ; Core-specific
iDev_QA7_AXI        #     4 ; Can only be IRQ of core 0
iDev_QA7_LocalTimer #     4 ; Can only be assigned to one core (as either IRQ or FIQ)

iDev_QA7_Max        #     0
d698 34
a731 1
QA7_SIZE                  * &40000
@


1.27.2.2
log
@Merge in latest HEAD
Detail:
  Merge in changes since BCM2835-0_70 to keep SMP branch up to date
Admin:
  Untested


Version 0.71, 1.70.2.2. Tagged as 'BCM2835-0_71-1_70_2_2'
@
text
@d34 1
a34 1
        [ :LNOT: :DEF: BCM2835_Hdr
d348 2
a349 2
GPPEDS0      *        &40            ; GPIO Pin Event Detect Status 0
GPPEDS1      *        &44            ; GPIO Pin Event Detect Status 1
@


1.27.2.3
log
@Merge latest changes from HEAD

Version 0.75, 1.70.2.4. Tagged as 'BCM2835-0_75-1_70_2_4'
@
text
@d286 10
a295 13
; Ref: https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md
BoardRevision_AorB256_First  * &2          ; } Either an A or B
BoardRevision_AorB256_Last   * &9          ; } various manufacturers
BoardRevision_AorB512_First  * &D          ; } Either an A or B
BoardRevision_AorB512_Last   * &F          ; } various manufacturers
BoardRevision_AorB_First     * &2          ; } Either an A or B, 256MB or 512MB
BoardRevision_AorB_Last      * &F          ; } and various manufacturers
BoardRevision_BPlus_Sony     * &10         ; Significant board revisions
BoardRevision_Compute_Sony   * &11
BoardRevision_APlus_Sony     * &12
BoardRevision_BPlus_Embest   * &13
BoardRevision_Compute_Embest * &14
BoardRevision_APlus_Embest   * &15
a330 2
BoardRevision_Model_ZeroW   *  12 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_B3Plus  *  13 :SHL: BoardRevision_Model_Shift
@


1.26
log
@Add JTAG debugging support
Detail:
  hdr/BCM2835 - Add switch to allow GPIOs 22-27 to be reconfigured for ARM JTAG access
  s/Top - Configure GPIOs for JTAG if switch enabled
  s/GPIO - Disable GPIO HAL device if JTAG enabled (try and avoid any software messing with the pins)
Admin:
  Tested on Raspberry Pi 1 B, B+


Version 0.66. Tagged as 'BCM2835-0_66'
@
text
@d344 1
d361 1
@


1.25
log
@Report POR flag to the kernel
Detail:
  Look at the reset status register and use the HADPOR flag to influence the OSStartFlag_POR value.
  Fixes problem of OS_Byte 253 always reporting a hard reset, never a power on reset.
Admin:
  Tested on a Pi 2.
  Submission for USB bounty.

Version 0.64. Tagged as 'BCM2835-0_64'
@
text
@d45 22
@


1.24
log
@Move the board rev definitions into hdr
Detail:
  Useful if not just SDIO can see the definitions.

Version 0.62. Tagged as 'BCM2835-0_62'
@
text
@d448 1
a448 1
;
d450 7
a456 3
PM_Rstc      *        &1c            ; reset control reg
PM_Rsts      *        &20            ; reset status reg (?)
PM_Wdog      *        &24            ; watchdog control reg
d458 18
a475 7
PM_Wdog_Reset *       &00            ; watchdog reset
PM_Password  *        &5a000000
PM_Wdog_TimeSet *     &000fffff
PM_Rst_WCfgClr *      &ffffffcf
PM_Rst_WCfgSet *      &00000030
PM_Rst_WCfg_FullRst * &00000020
PM_Rst_Reset *        &00000102
@


1.23
log
@Implement HAL UART API. Tidy up debug output.
Detail:
  hdr/BCM2835, hdr/StaticWS, s/Debug, s/Top, s/Video - Fix up the two serial debug switches to work correctly. Disable debug by default.
  s/UART, hdr/UART - Implement HAL UART API, for the PL011 UART.
Admin:
  Tested on Raspberry Pi 1 B
  Requires DualSerial 0.25 to work correctly


Version 0.59. Tagged as 'BCM2835-0_59'
@
text
@d293 48
@


1.22
log
@Put the other cores into a holding pattern
Detail:
  s/Top - On multi-core chips, the ARM boot stub has the other cores sat waiting in a loop near &0. Clearing RAM will inadvertantly break them out of this and most likely cause random crashes later on, so inbetween relocating the ROM and clearing RAM make sure we put the cores into a sleep loop in the HAL. Further mailbox writes can then be used to break them out of this loop, using a similar scheme to that used to break them out of the boot stub loop.
  hdr/BCM2835 - Add some register definitions from the BCM2836 docs
Admin:
  Tested on Pi 2B, 3B
  Not currently dealing with kernel_old=1 case where all cores enter the ROM on startup


Version 0.55. Tagged as 'BCM2835-0_55'
@
text
@a36 3
                GBLL    HALDebug
HALDebug        SETL    {TRUE}

d39 5
a43 1
Debug     SETL    {TRUE}
@


1.21
log
@Fix SD card activity LED on Pi 3B
Detail:
  hdr/BCM2835 - Remove mailbox definitions - use the ones exported by BCMSupport to avoid needless duplication
  hdr/StaticWS, s/Messaging, s/Top - Use the mailbox property interface to request & map in the virtual GPIO buffer (if present)
  s/SDIO - On the Pi 3B, the GPIO that was used for the SD activity GPIO is now used for a different purpose. To control the activity LED we need to go via an I2C attached GPIO extender, which itself is exposed to the ARM via the new "virtual GPIO" buffer
  s/VCHIQ - Update to use BCMSupport mailbox definitions
Admin:
  Tested on Pi 1B, 3B


Version 0.54. Tagged as 'BCM2835-0_54'
@
text
@d547 64
@


1.20
log
@Add basic HAL device for the official DSI display/touchscreen. Delete superfluous code.
Detail:
  Makefile, s/Touch - Basic HAL device for the official touchscreen, which just exposes the address of the buffer which the GPU periodically fills with a register dump of the touchscreen controller.
  hdr/BCM2835 - Remove old comment. Add new tag for getting the touchscreen buffer address.
  hdr/StaticWS - Remove old workspace entries. Add new entries for touchscreen.
  s/Messaging - Remove the messagebox tags which set a screen mode on startup (BCMVideo will handle that for us), and just blank the screen instead (to stop the GPU displaying a coloured square). Add tag to get the touchscreen buffer address.
  s/Top - Register touchscreen HAL device during HAL_InitDevices. Remove more old code.
Admin:
  Tested on Raspberry Pi 1 B


Version 0.50. Tagged as 'BCM2835-0_50'
@
text
@a203 72
;
; mailbox channel numbers
MB_Chan_Pwr    *       0             ; Power channel
MB_Chan_FB     *       1             ; Frame Buffer channel
MB_Chan_VUart  *       2             ; Virtual UART channel
MB_Chan_VCHIQ  *       3             ; VCHIQ channel
MB_Chan_LEDS   *       4             ; LEDS channel
MB_Chan_Btn    *       5             ; Buttons channel
MB_Chan_TSc    *       6             ; TouchScreen channel
MB_Chan_ARM2VC *       8             ; ARM -> VC property channel
MB_Chan_VC2ARM *       9             ; VC -> ARM property channel
; far end replies on the same channel when command done.. e.g.
; command c0000001 gets 00000001 (ie channel1) reply
; Power channel bits
MB_Pwr_SDCard       *  0
MB_Pwr_UART         *  1
MB_Pwr_MiniUART     *  2
MB_Pwr_USB          *  3
MB_Pwr_I2C0         *  4
MB_Pwr_I2C1_MASK    *  5
MB_Pwr_I2C2_MASK    *  6
MB_Pwr_SPI_MASK     *  7
MB_Pwr_CCP2TX_MASK  *  8
; ARM2VC tags
; see https://github.com/raspberrypi/firmware/wiki/Mailbox-property-interface
ARM2VC_Tag_End                   * &00000000 ; End of tag list
ARM2VC_Tag_GetFirmwareVersion    * &00000001 ; return 4 byte firmware version
ARM2VC_Tag_GetBoardModel         * &00010001 ; return 4 byte model
ARM2VC_Tag_GetBoardRevision      * &00010002 ; return 4 byte revision
ARM2VC_Tag_GetBoardMAC           * &00010003 ; return 6 byte MAC
ARM2VC_Tag_GetBoardSerial        * &00010004 ; return 8 byte serial
ARM2VC_Tag_GetARMMemory          * &00010005 ; return ARM mem base + size
ARM2VC_Tag_GetVCMemory           * &00010006 ; return VC mem base + size
ARM2VC_Tag_GetClocks             * &00010007 ; return clock tree
ARM2VC_Tag_GetConfig             * &00050001 ; get kernel boot args string
ARM2VC_Tag_GetDMAChannels        * &00060001 ; get mask of DMA channels usable by ARM
ARM2VC_Tag_GetPowerState         * &00020001 ; get power state of specified MB_Pwr_ device
ARM2VC_Tag_GetPowerTiming        * &00020002 ; get microsecond delay required after power on for indicated device
ARM2VC_Tag_SetPowerState         * &00028001 ; set power state of device
ARM2VC_Tag_GetClockState         * &00030001 ; get power state of clock
ARM2VC_Tag_SetClockState         * &00038001 ; set power state of clock
ARM2VC_Tag_GetClockRate          * &00030002 ; get rate of clock
ARM2VC_Tag_SetClockRate          * &00038002 ; set rate of clock
ARM2VC_Tag_FBAlloc               * &00040001 ; alloc framebuffer at given alignment
ARM2VC_Tag_FBRelease             * &00048001 ; release framebuffer
ARM2VC_Tag_FBBlank               * &00040002 ; blank screen
ARM2VC_Tag_FBGetPhysDimension    * &00040003 ; get physical display width/height
ARM2VC_Tag_FBTestPhysDimension   * &00044003 ; test physical display w/h
ARM2VC_Tag_FBSetPhysDimension    * &00048003 ; set physical display w/h
ARM2VC_Tag_FBGetVirtDimension    * &00040004 ; get virtual display w/h
ARM2VC_Tag_FBTestVirtDimension   * &00044004 ; test virtual display w/h
ARM2VC_Tag_FBSetVirtDimension    * &00048004 ; set virtual display w/h
ARM2VC_Tag_FBGetDepth            * &00040005 ; get display BPP
ARM2VC_Tag_FBTestDepth           * &00044005 ; test display BPP
ARM2VC_Tag_FBSetDepth            * &00048005 ; set display BPP
ARM2VC_Tag_FBGetPixelOrder       * &00040006 ; get RGB/BGR order
ARM2VC_Tag_FBTestPixelOrder      * &00044006 ; test RGB/BGR order
ARM2VC_Tag_FBSetPixelOrder       * &00048006 ; set RGB/BGR order
ARM2VC_Tag_FBGetAlphaMode        * &00040007 ; get alpha mode
ARM2VC_Tag_FBTestAlphaMode       * &00044007 ; test alpha mode
ARM2VC_Tag_FBSetAlphaMode        * &00048007 ; set alpha mode
ARM2VC_Tag_FBGetPitch            * &00040008 ; get row pitch
ARM2VC_Tag_FBGetVirtOffset       * &00040009 ; get X/Y offset of virtual display
ARM2VC_Tag_FBTestVirtOffset      * &00044009 ; test X/Y offset
ARM2VC_Tag_FBSetVirtOffset       * &00048009 ; set X/Y offset
ARM2VC_Tag_FBGetOverscan         * &0004000a ; get overscan values
ARM2VC_Tag_FBTestOverscan        * &0004400a ; test overscan values
ARM2VC_Tag_FBSetOverscan         * &0004800a ; set overscan values
ARM2VC_Tag_FBGetPalette          * &0004000b ; get full palette table
ARM2VC_Tag_FBTestPalette         * &0004400b ; test ranged update of table
ARM2VC_Tag_FBSetPalette          * &0004800b ; do ranged update of table
ARM2VC_Tag_FBGetTouchBuf         * &0004000f ; get address of FT5406 register bank softcopy 
@


1.19
log
@Add basic HAL devices for the SPI controllers
Detail:
  s/SPI - Basic HAL devices for the 3 SPI controllers. These expose the register addresses & IRQ numbers, and (for SPI1 & SPI2) deal with enabling/disabling the hardware and the shared IRQ line. GPIO mapping currently isn't dealt with - we don't know which pin group to use (SPI0 can use two different sets on the compute) or how many chip select lines are desired.
  Makefile - Add SPI source
  hdr/BCM2835 - Add aux SPI registers
  hdr/StaticWS - Reserve workspace for the HAL devices
  s/Top - Register new devices in HAL_InitDevices
Admin:
  Tested on Raspberry Pi B & 2 B


Version 0.45. Tagged as 'BCM2835-0_45'
@
text
@a228 1
; Note - this interface isn't implemented in the GPU firmware yet!
d275 1
a275 1

@


1.18
log
@Add workaround for Cortex-A7 errata 814220
Detail:
  hdr/BCM2835 - Errata 814220 states that the Cortex-A7 set/way cache maintenance operations violate the usual operation ordering rules, such that an L2 maintenance operation which is started after an L1 operation may actually complete before it, causing data corruption if the L1 data was to be evicted to the L2 entry. Implement the suggested workaround of performing a DSB when switching cache levels, rather than just at the end of the combined L1+L2 group of operations.
  Also, fix missing 99 label that would have caused a stack imbalance in the unlikely event of encountering a processor with fully coherent caches
Admin:
  Tested on Raspberry Pi 2


Version 0.43. Tagged as 'BCM2835-0_43'
@
text
@d416 8
a423 1
; etc
@


1.17
log
@  Add support for Raspberry Pi Compute module and Raspberry Pi 2
Detail:
  * Compute module support consists of eMMC support in the SDHCI driver. The
    eMMC chip on the Compute module only works reliably if under-clocked to
    25 MHz.
  * Pi 1 vs Pi 2 differences are selected at runtime by checking the CPU ID,
    so a single ROM image will work with both boards.
  * Added ARMv7 cache maintenance routine for use on Pi 2.
  * The physical address of the peripherals has moved in Pi 2 to make space
    for the 1 GB of RAM.
  * The ARM physical address space is mapped differently onto the GPU
    address space in Pi 2 because the ARM now uses the L2 cache that comes
    with the Cortex-A7 instead of the GPU's L2 cache.
  * Still waiting for confirmation on the board revision ID that will be
    used for Pi 2, so may require further tweaks for production releases.


Version 0.40. Tagged as 'BCM2835-0_40'
@
text
@d334 1
d338 1
a338 1
        DSB
@


1.16
log
@Add support code required for DWCDriver 'FIQ fix'
Detail:
  hdr/BCM2835, hdr/USB, s/USB - Update HAL_USBControllerInfo to return the MPHI address & IRQ number
  s/Interrupts - Add some missing memory barriers. Change FIQ enable/disable calls to not alter IRQ masking of the interrupt - simplifies the code and avoids any ordering issues with code that switches interrupts between IRQ & FIQ
  s/Timers - Add missing memory barrier
Admin:
  Tested on Raspberry Pi
  Requires Kernel-5_35-4_79_2_227 to build


Version 0.34. Tagged as 'BCM2835-0_34'
@
text
@d65 2
a66 1
IO_Base         *       &20000000
d300 7
d308 44
a351 7
$label  FlushDataCache $r, $cond
$label  MOV$cond $r, #0
      [ {UAL}
        MCR$cond p15, #0, $r, c7, c14, #0
      |
        MCR$cond p15, 0, $r, c7, c14,0
      ]
d353 1
@


1.15
log
@Implement HAL_IRQMax
Detail:
  hdr/BCM2835 - Add definition for highest IRQ number
  s/Boot, s/Interrupts - Added HAL_IRQMax implementation, to ensure correct functionality with latest Kernel
Admin:
  Tested on 256MB Pi model B
  Requires Kernel-5_35-4_79_2_182


Version 0.29. Tagged as 'BCM2835-0_29'
@
text
@d415 3
@


1.14
log
@Add a video HAL device to allow BCMVideo to determine which DMA channel it can use for render ops
Detail:
  hdr/StaticWS, s/Top, s/Video - Added a simple VDU HAL device that exposes a DMA channel to BCMVideo for use with GraphicsV_Render
  hdr/BCM2835 - Don't allow DMA channel 12 to be used; latest firmware seems to have a bug which claims its free when in reality it isn't.
  s/Messaging, s/DMA - Adjust DMA init to allow the video device to claim a DMA channel before the DMA devices are initialised
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.25. Tagged as 'BCM2835-0_25'
@
text
@d548 2
@


1.13
log
@Use BCS1 instead of BCS0 for IIC when running on rev 2 boards
Detail:
  hdr/BCM2835, hdr/StaticWS, s/IIC - On rev 2 boards the usage of BSC0 and BSC1 have been swapped, such that BSC1 is now sent to the expansion header instead of BSC0.
  To allow RISC OS to continue to work with clock chips and other hardware fitted to the header, expose BSC1 to RISC OS if on a rev 2 board, or BSC0 if on a rev 1.
Admin:
  Changes received from Dave Higton
  Tested by Dave on rev 1 & rev 2 boards, with IIC devices
  Tested by me on rev 1 board (with no IIC devices fitted)


Version 0.24. Tagged as 'BCM2835-0_24'
@
text
@d412 2
a413 1
DMA_CH_Count *        13 ; Allegedly 16 channels, but can only get IRQs from 13 of them?
@


1.12
log
@Strip out video code & on-screen debug
Detail:
  Makefile, s/Display - Deleted on-screen debug code
  hdr/BCM2835, hdr/StaticWS, s/IIC, s/Messaging, s/Stubs, s/Top, s/UART - Strip out calls to on-screen debug code, and a few bits of video code
  s/Video - Video code removed and replaced with stub functions similar to other HALs. Only remaining useful code is HAL_Video_StartupMode, which in time should probably be moved to BCMVideo as well.
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.21. Tagged as 'BCM2835-0_21'
@
text
@d7 1
a7 1
; modification, are permitted provided that the following conditions are met: 
d16 1
a16 1
; 
d276 1
a276 1
                                      
d311 1
a311 1
        BIC$cond $endaddr,   $endaddr,   #&1f        
d332 2
a333 2
GPPEDS0      *        &40            ; GPOI Pin Event Detect Status 0       
GPPEDS1      *        &44            ; GPOI Pin Event Detect Status 1       
d426 1
a426 1
PM_Rst_Reset *        &00000102        
d430 1
a430 1
ISP_Base     *        &00a00000      ; ISP         
d548 3
a550 1
IIC_Base            *     &00205000  ; base of IIC0
@


1.11
log
@  Addition of I2C support
Detail:
  Implementation of the high-level HAL IIC interface provided by Dave Higton.
Admin:
  Checked it builds and runs at ROOL.

Version 0.20. Tagged as 'BCM2835-0_20'
@
text
@a39 8
                GBLL    ExtFramestore
ExtFramestore   SETL    {TRUE}


                GBLL    SCR32
SCR32           SETL    {TRUE}


@


1.10
log
@Add GPIO & VCHIQ HAL devices. Fix FlushDataCache macro to perform a clean & invalidate instead of just an invalidate.
Detail:
  s/GPIO - Basic implementation of the GPIO HAL device to allow the GPIO module to detect the board type
  s/VCHIQ, hdr/StaticWS - New VCHIQ HAL device which exposes the functionality required by the work-in-progress VCHIQ driver.
  Makefile, s/Top - Hook up the new files/devices
  hdr/BCM2835 - Make the FlushDataCache macro perform a clean & invalidate, to match the behaviour of FlushDataCacheRange
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.17. Tagged as 'BCM2835-0_17'
@
text
@d555 11
@


1.9
log
@Detail:  Frame buffer allocation via message channel almost complete. working
        HAL_MachineID functioning correctly
Admin:


Version 0.15. Tagged as 'BCM2835-0_15'
@
text
@d181 4
d311 1
a311 1
        MCR$cond p15, #0, $r, c7, c6, #0
d313 1
a313 1
        MCR$cond p15, 0, $r, c7, c6,0
@


1.8
log
@
	Various updates to do with the messaging channel, HAL_MachineID, and HAL_Reset

Detail:
	HAL_Reset now causes a complete reboot of the machiine. It isnt yet properly called from
	the kernel.. I've not investigated why yet. Behaviour tested using OS_Hardware call

	HAL_MachineID, with the github start.elf from 18 July 2012 will provide a valid MAC address ..
	i.e. that specific to this machine. The a1 value in HAL_ExtendedID needs to be set 0 for this to be reported
	by OS_ReadSysInfo .. unfortunately, again at this stage, it stalls the boot when set 0, so just for now
	the committed value for a1 in HAL_ExtendedID is not 0 .

	centralised messaging routine added. This is used a fair bit in acquiring the operating environment
	Not yet used in the DMA stuff. probably ought to be. At present the messaging channel this mainly
	handles is not complete, so information from this code is still WIP

Admin:
  (highlight level of testing that has taken place)
  (bugfix number if appropriate)


Version 0.14. Tagged as 'BCM2835-0_14'
@
text
@a32 4
; on the prototype (UseALBlob==TRUE)
; VideoCore sets up the following address windows for use by the ARM core:
; - &08000000 -> &7E000000 : 4MB window granting access to peripherals
; - &08800000 -> &7E800000 : 4MB window granting access to USB peripheral
a52 4
; Delay macro for really short delays



@


1.7
log
@Add DMA driver
Detail:
  s/DMA, hdr/DMA, Makefile - DMA driver, as an implementation of the DMA controller and list type DMA channel HAL devices
  hdr/StaticWS - Added DMA workspace definition
  hdr/BCM2835 - Removed DMA control block definition (now in hdr/DMA). Add definitions for the mailbox property interface, which should be supported by the GPU firmware sometime soon.
  s/Top - Export a couple of the debug functions. Store logical & physical address of NCNB workspace instead of hackily getting phys addr of the (cacheable) HAL workspace. Call DMA_InitDevices in HAL_InitDevices.
Admin:
  Tested in BCM2835 ROM
  DMA driver hasn't received large amounts of testing, lacks support for finite-length circular transfers, and currently only has one DMA channel enabled
  More DMA channels should be available once the mailbox property interface is functional and we know which channels the GPU does and doesn't use.


Version 0.11. Tagged as 'BCM2835-0_11'
@
text
@a46 4
; set TRUE if using the start.elf originally used for development. FALSE otherwise
                GBLL    UseALBlob
UseALBlob       SETL    {FALSE}

a80 4
 [ UseALBlob
IO_Base         *       &08000000
IO_Size         *       &00c00000
 |
a82 1
 ]
a91 14
 [ UseALBlob
; FB_MemBase is the point at which riscos is 'capped'
; valid megabyte boundaries at &1e00000, &1f00000 and &2000000
; FB_Address is the start address of the frame buffer. Valid addresses
; (ideally) anywhere between &1e00000 and &2000000
; FB_Length is max framebuffer length. &800000 is just more than
; required for a 1920*1080 32bpp screen
; conclusions .. at the moment the wimp system/desktop appears to need megabyte ; base alignment
FB_MemBase      *       &01e00000           ; top address of our memory
FB_Address      *       &01e00000;&01f90000;&01f83ea0;
FB_Length       *       &007f8000;&00800000;
      ASSERT    FB_MemBase <= FB_Address          
 |
 ]
d291 1
a291 1
; (value 4 is all insructions, value 5 is just mem instructions)
d428 13
@


1.6
log
@Add USB support
Detail:
  hdr/USB - New header with definition of usbinfo struct that's used by HAL_USBControllerInfo
  hdr/BCM2835 - Add note clarifying how mailboxes are used
  s/Top - Enable power to USB on startup
  s/USB - Implement HAL_USBControllerInfo to expose Synopsys USB controller details to RISC OS
Admin:
  Tested in BCM2835 ROM with Apr 19th start.elf


Version 0.07. Tagged as 'BCM2835-0_07'
@
text
@d247 2
d261 49
d445 1
a445 1
DMA_Base     *        &00007000      ;
d447 1
a447 16
DMA0_CS         *       0
DMA0_CONBLK_AD  *       4
DMA0_DEBUG      *       &20


; DMA control block
                ^       0
DMAcb_info      #       4
DMAcb_src       #       4
DMAcb_dst       #       4
DMAcb_length    #       4
DMAcb_stride    #       4
DMAcb_next      #       4
DMAcb_pad0      #       4
DMAcb_pad1      #       4
sizeof_DMAcb    *       @@
@


1.5
log
@  Whitespace changes
Detail:
  Substituted remaining hard spaces with normal ones and expanded tabs.
  This now matches the de facto standard for other components, and also looks
  better in the CVS web viewer.
Admin:
  No code changes

Version 0.06. Tagged as 'BCM2835-0_06'
@
text
@d207 3
a209 1
; Mailbox 0
@


1.4
log
@  Complete rework of timer and interrupt code
Detail:
 * Moved interrupt and timer code out of s.Stubs - they're not stubs any more.
 * Rewrote timer and counter code to use GPU system timer 1 for our Timer0
   rather than the ARM timer. This is recommended in the Broadcom datasheet
   because it's driven from the APB clock and so its speed will vary in
   reduced or low power mode.
 * HAL_CounterDelay now, well, does a delay!
 * Added a Timer1, driven from GPU system timer 3 - common code with Timer0.
 * Reshuffled device numbers so the GPU interrupts are at the bottom. This
   works better for FIQs and makes Timer0 the lowest priority interrupt.
 * Higher device numbers are now consistently treated as higher priority.
 * Stopped using bits 8-31 of the basic interrupt registers. These can't be
   masked, so they cause the kernel to lock up if generated, which happens
   if the GPU interrupt which they alias is generated (which appears to
   include the timers even though this is not documented).
 * Added definitions for all the interrupts, including those redacted from the
   datasheet - we need them at least for timers, USB and SD.
 * Stopped HAL_IRQClear from doing anything - this interrupt controller
   doesn't do latching. To acknowledge timer interrupts, you should use
   HAL_TimerIRQClear (and HAL_IRQClear too for compatibility with other ports).
 * Implemented HAL_IRQStatus and all the FIQ control routines.
 * Offsets to interrupt controller registers now use symbolic names.
 * Replaced some hard spaces in sources with normal ones.
Admin:
  Tested on a beta Raspberry Pi. Confirmed that interrupt handlers for both
  ARM and GPU sources can both be operational simultaneuosly. However, the FIQ
  code has not been tested. Timer0 is verified as running at the correct
  speed and reporting a count *down* in the correct range (not a count up as
  some previous versions did). HAL_CounterDelay appears correct also.

Version 0.04. Tagged as 'BCM2835-0_04'
@
text
@d38 2
a39 2
	[ :LNOT :DEF: BCM2835_Hdr
	GBLL BCM2835_Hdr
d41 2
a42 2
		GBLL	HALDebug
HALDebug	SETL	{TRUE}
d44 2
a45 2
		GBLL	ExtFramestore
ExtFramestore	SETL	{TRUE}
d394 3
a396 3
DMA0_CS		*	0
DMA0_CONBLK_AD	*	4
DMA0_DEBUG	*	&20
d400 10
a409 10
		^	0
DMAcb_info	#	4
DMAcb_src	#	4
DMAcb_dst	#	4
DMAcb_length	#	4
DMAcb_stride	#	4
DMAcb_next	#	4
DMAcb_pad0	#	4
DMAcb_pad1	#	4
sizeof_DMAcb	*	@@
d566 1
a566 1
		END
@


1.3
log
@   Boots with May17th start.elf
Detail:
   Recent changes in the broadcom startup code now accomodated. frame buffer
   will now determine whether it is L2 cached or not, and be set up accordingly.
   ATAGs not currently read, so ram size defaulted.
  ** note that there will be further updates to this over the following days
  ** trackikng startup code changes.
   added HAL_TimerIRQClear entry
Admin:
  (highlight level of testing that has taken place)
  (bugfix number if appropriate)


Version 0.03. Tagged as 'BCM2835-0_03'
@
text
@d2 1
a2 1
;Copyright(c)2012, RISC OS Open Ltd
d4 1
a4 1
;Allrightsreserved.
d185 21
d266 3
d270 1
d275 3
d279 1
d284 3
d288 1
d294 3
d298 1
d378 1
a378 1
; Timer
d380 9
d419 111
a529 44
; Raspberry Pi interrupt sources.. there are several, with
; odd placing. all convcentrated int 3 32bit registers.
; The bottom 5 bits are the bit within the register, the next 2 the register
; there are a total of 21 interrupts in the main IRQ register
; and 64 possible ones in the GPU registers
; Not all are identified...
; so..
iDev_ARM_Timer      *     0
iDev_ARM_Mbx        *     1
iDev_ARM_DBell0     *     2
iDev_ARM_DBell1     *     3
iDev_ARM_GPU0Hlt    *     4
iDev_ARM_GPU1Hlt    *     5
iDev_ARM_IllegAcs1  *     6
iDev_ARM_IllegAcs0  *     7
iDev_IRQ_Pend1      *     8
iDev_IRQ_Pend2      *     9
iDev_GPU_IRQ7       *     10
iDev_GPU_IRQ9       *     11
iDev_GPU_IRQ10      *     12
iDev_GPU_IRQ18      *     13
iDev_GPU_IRQ19      *     14
iDev_GPU_IRQ53      *     15
iDev_GPU_IRQ54      *     16
iDev_GPU_IRQ55      *     17
iDev_GPU_IRQ56      *     18
iDev_GPU_IRQ57      *     19
iDev_GPU_IRQ62      *     20
; devices in register 1  - start at 32
iDev_GPU_AuxInt     *     32+29
; devices in register 2  - start at 64
iDev_GPU_i2cslv     *     32+43
iDev_GPU_pwa0       *     32+45
iDev_GPU_pwa1       *     32+46
iDev_GPU_smi        *     32+48
iDev_GPU_ioi0       *     32+49
iDev_GPU_ioi1       *     32+50
iDev_GPU_ioi2       *     32+51
iDev_GPU_ioi3       *     32+52
iDev_GPU_i2c        *     32+53
iDev_GPU_spi        *     32+54
iDev_GPU_pcm        *     32+55
iDev_GPU_Uart       *     32+57

@


1.2
log
@
  Update of HAL to incorporate separate development of HAL by J Ballance
  Will now compile against initial developemnt start.elf, and against the
  start.elf in general release at this date. (compile switch UseALBlob in
  hdr.BCM2835). Extended header defs, Updated IRQ stuff, HAL_FramebufferAddress
  Reworked Timers, + a number of other bits. Still work in progress.
Detail:
  (list files and functions that have changed)
Admin:
  Compiled and working - as far as it goes -. Will enable use with the current
  start.elf, and is (subject to any minor changes introduced) ready for use with the
  version due for release shortly which will provide the correct transparency operation,
  and a better aligned frame buffer

Version 0.02. Tagged as 'BCM2835-0_02'
@
text
@d95 5
d226 10
a235 1

d243 3
a245 3
$label  DataSyncBarrier $r
$label  MOV $r, #0
        MCR p15, 0, $r, c7, c10,4
d248 3
a250 3
$label  DoMemBarrier $r
$label  MOV $r, #0
        MCR p15, 0, $r, c7, c10,5
d253 3
a255 3
$label  FlushDataCache $r
$label  MOV $r, #0
        MCR p15, 0, $r, c7, c6,0
d258 4
a261 4
$label  FlushDataCacheRange $startaddr,$endaddr
$label  BIC $startaddr, $startaddr, #&1f
        BIC $endaddr,   $endaddr,   #&1f        
        MCRR p15, 0, $endaddr, $startaddr, c14
@


1.1
log
@Initial revision
@
text
@d33 1
a33 1

d47 283
a329 14
; Peripheral address space
PERI_BASE	*	&08000000
;PERI2_BASE	*	&08800000

; Offsets from peripheral base address
ST_BASE		*	&3000		;System Timer 0
DMA_BASE	*	&7000		;DMA controller
PM_BASE		*	&100000		;Power management
UART0_BASE	*	&201000		;UART 0
UART1_BASE	*	&215000		;UART 1
INTC_BASE	*	&B200		;Interrupt controller
USB_BASE	*	&980000		;USB controller
ISP_BASE	*	&A00000		;ISP

d332 1
d351 86
a436 1
	]
d438 1
@


1.1.1.1
log
@  Initial import of BCM2835 (Raspberry Pi) HAL
Detail:
  Covers the basic functionality, but does require a customised start.elf
  to function. The vast majority is an entirely new implementation and is
  BSD licenced, but 4% (the Makefile and a handful of simple macros) are
  copied from pre-existing Castle-licenced code, so it lives under the
  "mixed" hierarchy. If other HALs are anything to go by, we'll end up
  having to add more Castle code (at least some C runtime functions) so it's
  probably juast as well.
Admin:
  Code received from Adrian Lees
@
text
@@

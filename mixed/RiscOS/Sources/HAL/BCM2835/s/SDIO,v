head	1.15;
access;
symbols
	Pi3APlus_merge:1.14.2.1
	BCM2835-0_75-1:1.14.2.1
	Pi3APlus:1.14.0.2
	Pi3APlus_bp:1.14
	BCM2835-0_76:1.14
	BCM2835-0_75-1_70_2_4:1.13.2.1
	BCM2835-0_75:1.14
	BCM2835-0_74:1.14
	BCM2835-0_73-1_70_2_3:1.13
	BCM2835-0_73:1.13
	BCM2835-0_72:1.13
	BCM2835-0_71-1_70_2_2:1.13
	BCM2835-0_71:1.13
	BCM2835-0_70-1_70_2_1:1.13
	SMP:1.13.0.2
	SMP_bp:1.13
	BCM2835-0_70:1.13
	BCM2835-0_69:1.13
	BCM2835-0_68:1.12
	BCM2835-0_67:1.12
	BCM2835-0_66:1.12
	BCM2835-0_65:1.12
	BCM2835-0_64:1.12
	BCM2835-0_63:1.12
	BCM2835-0_62:1.12
	BCM2835-0_61:1.11
	BCM2835-0_60:1.10
	BCM2835-0_59:1.10
	BCM2835-0_58:1.10
	BCM2835-0_57:1.9
	BCM2835-0_56:1.8
	BCM2835-0_55:1.8
	BCM2835-0_53:1.7
	BCM2835-0_52:1.7
	BCM2835-0_51:1.7
	BCM2835-0_50:1.7
	BCM2835-0_49:1.7
	BCM2835-0_48:1.7
	BCM2835-0_47:1.7
	BCM2835-0_46:1.7
	BCM2835-0_45:1.7
	BCM2835-0_44:1.7
	BCM2835-0_43:1.7
	BCM2835-0_42:1.7
	BCM2835-0_41:1.6
	BCM2835-0_40:1.5
	BCM2835-0_39:1.4
	BCM2835-0_38:1.3
	BCM2835-0_37:1.3
	BCM2835-0_36:1.3
	BCM2835-0_35:1.3
	BCM2835-0_34:1.2
	BCM2835-0_33:1.2
	BCM2835-0_32:1.2
	BCM2835-0_31:1.2
	BCM2835-0_30:1.2
	BCM2835-0_29:1.2
	BCM2835-0_28:1.2
	BCM2835-0_27:1.2
	BCM2835-0_26:1.2
	BCM2835-0_25:1.2
	BCM2835-0_24:1.2
	BCM2835-0_23:1.2
	BCM2835-0_22:1.2
	BCM2835-0_21:1.2
	BCM2835-0_20:1.2
	BCM2835-0_19:1.2
	BCM2835-0_18:1.2
	BCM2835-0_17:1.2
	BCM2835-0_16:1.2
	BCM2835-0_15:1.2
	BCM2835-0_14:1.2
	BCM2835-0_13:1.2
	BCM2835-0_12:1.2
	BCM2835-0_11:1.2
	BCM2835-0_10:1.2
	BCM2835-0_09:1.1;
locks; strict;
comment	@# @;


1.15
date	2018.10.26.19.37.02;	author bavison;	state Exp;
branches;
next	1.14;
commitid	dalYNopD32JgovXA;

1.14
date	2018.03.19.21.03.17;	author jlee;	state Exp;
branches
	1.14.2.1;
next	1.13;
commitid	DXJIfpAlz3WmY6vA;

1.13
date	2017.02.21.22.10.55;	author rsprowson;	state Exp;
branches
	1.13.2.1;
next	1.12;
commitid	vR1YulJPaRxOURGz;

1.12
date	2016.10.22.20.18.05;	author rool;	state Exp;
branches;
next	1.11;
commitid	vT6sSPcBGcAddbrz;

1.11
date	2016.10.15.14.30.26;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	bv5F1PmPdmWUvfqz;

1.10
date	2016.05.09.23.02.14;	author jlee;	state Exp;
branches;
next	1.9;
commitid	dPZR6UQHZXpnsR5z;

1.9
date	2016.04.04.20.52.32;	author jlee;	state Exp;
branches;
next	1.8;
commitid	Lp7avkv10vvCRl1z;

1.8
date	2016.03.26.21.29.33;	author jlee;	state Exp;
branches;
next	1.7;
commitid	R20Od6NioP8emc0z;

1.7
date	2015.02.03.19.16.56;	author bavison;	state Exp;
branches;
next	1.6;
commitid	2aTRhX3DBFvN1B8y;

1.6
date	2015.02.02.20.12.27;	author bavison;	state Exp;
branches;
next	1.5;
commitid	EsDjinl6FelQmt8y;

1.5
date	2015.02.02.13.28.32;	author bavison;	state Exp;
branches;
next	1.4;
commitid	ElEkWbWLEdDg8r8y;

1.4
date	2014.10.30.11.41.25;	author bavison;	state Exp;
branches;
next	1.3;
commitid	6KqMqJ497wNRAdWx;

1.3
date	2014.07.14.09.12.49;	author bavison;	state Exp;
branches;
next	1.2;
commitid	LsZUP34QhmC7fkIx;

1.2
date	2012.07.01.20.26.41;	author bavison;	state Exp;
branches;
next	1.1;
commitid	WH7Fa39f5fh0RTaw;

1.1
date	2012.06.15.14.40.20;	author bavison;	state Exp;
branches;
next	;
commitid	GozidpkBTrLSrO8w;

1.14.2.1
date	2018.10.26.19.31.38;	author bavison;	state Exp;
branches;
next	;
commitid	HzYe59LD1XidmvXA;

1.13.2.1
date	2018.07.07.14.12.57;	author jlee;	state Exp;
branches;
next	;
commitid	rGMJuwVBIwKoadJA;


desc
@@


1.15
log
@Merge branch Pi3APlus to trunk

Not tagged
@
text
@;
; Copyright (c) 2012, RISC OS Open Ltd
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met: 
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in the
;       documentation and/or other materials provided with the distribution.
;     * Neither the name of RISC OS Open Ltd nor the names of its contributors
;       may be used to endorse or promote products derived from this software
;       without specific prior written permission.
; 
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.
;

        EXPORT  SDIO_InitDevices
        IMPORT  memcpy
        IMPORT  HAL_CounterDelay
        IMPORT  HAL_CounterRead

        ; KEEP ; for debugging

        GET     Hdr:ListOpts
        GET     Hdr:CPU.Arch
        GET     Hdr:Macros
        GET     hdr.BCM2835
        GET     hdr.StaticWS

sb      RN      9

; Timings

; How long to wait during GPIO pullup/down register procedure
; This is documented as "150 cycles" but not what these are cycles of!
PUD_DELAY       *       150 ; in us - wild guess

; How long to wait for SDCLK to stabilise, in ms
CLOCKSET_TIMEOUT *      20 ; in ms

; Number of SDCLK cycles that must elapse between writes to registers (chip bug)
REGISTER_WRITE_PACE *   2

; Minimum value SDCLK will be set to, in kHz. Is used to set a safe gap between
; writes while reprogramming SDCLK
MIN_SDCLK       *       400

; Base address of controller as an offset from PeriBase
EMMC_Base       *       &00300000

; GPIO pin assignments
GPIO_DAT3               *       53
GPIO_DAT2               *       52
GPIO_DAT1               *       51
GPIO_DAT0               *       50
GPIO_CMD                *       49  ; needs pull-up iff in ID mode
GPIO_CLK                *       48
GPIO_CD_AB              *       47  ; needs pull-up; active low
GPIO_STATUS_LED_AB      *       16  ; active low
GPIO_STATUS_LED_BPlus   *       47  ; active high

; GPIO function select bitfields
GPIO_FSEL_INPUT  *      0
GPIO_FSEL_OUTPUT *      1
GPIO_FSEL_ALT0   *      2
GPIO_FSEL_ALT1   *      3
GPIO_FSEL_ALT2   *      4
GPIO_FSEL_ALT3   *      5
GPIO_FSEL_ALT4   *      6
GPIO_FSEL_ALT5   *      7
GPIO_FSEL_SHIFT  *      3
GPIO_FSEL_MASK   *      7

; GPIO pull-up/down states
GPIO_PUD_OFF     *      0
GPIO_PUD_DOWN    *      1
GPIO_PUD_UP      *      2

; Selected SD controller registers and bits
ARG1                    *       &08
CMDTM                   *       &0C
CMDTM_CMD_INDEX_SHIFT       *   24
STATUS                  *       &24
STATUS_CMD_INHIBIT          *   1 :SHL: 0
CONTROL1                *       &2C
CONTROL1_CLK_FREQ8_SHIFT    *   8
CONTROL1_CLK_FREQ8_MASK     *   &FF :SHL: CONTROL1_CLK_FREQ8_SHIFT
CONTROL1_CLK_FREQ_MS2_SHIFT *   6
CONTROL1_CLK_FREQ_MS2_MASK  *   3 :SHL: CONTROL1_CLK_FREQ_MS2_SHIFT
CONTROL1_CLK_GENSEL         *   1 :SHL: 5
CONTROL1_CLK_EN             *   1 :SHL: 2
CONTROL1_CLK_STABLE         *   1 :SHL: 1
CONTROL1_CLK_INTLEN         *   1 :SHL: 0
INTERRUPT               *       &30
IRPT_MASK               *       &34
IRQ_CC                      *   1 :SHL: 0

; Capabilities bits
CAP_DDR50S      *       1 :SHL: 34
CAP_SDR104S     *       1 :SHL: 33
CAP_SDR50S      *       1 :SHL: 32
CAP_VS18        *       1 :SHL: 26  ; Voltage support 1.8V
CAP_VS30        *       1 :SHL: 25  ; Voltage support 3.0V
CAP_VS33        *       1 :SHL: 24  ; Voltage support 3.3V
CAP_HSS         *       1 :SHL: 21  ; High speed (52MHz) support
CAP_MBL_SHIFT   *       16
CAP_MBL_512     *       0 :SHL: CAP_MBL_SHIFT  ; 512-byte blocks
CAP_MBL_1024    *       1 :SHL: CAP_MBL_SHIFT  ; 1024-byte blocks
CAP_MBL_2048    *       2 :SHL: CAP_MBL_SHIFT  ; 2048-byte blocks
CAP_MBL_MASK    *       3 :SHL: CAP_MBL_SHIFT


        AREA    |Asm$$Code|, CODE, READONLY, PIC

; Delay in microseconds between writes to SDHCI registers during speed
; measurement. At this point we don't know what the delay actually needs to be
; because we haven't figured out the clock speed yet, but assuming the GPU boot
; code never sets it slower than 25 MHz, this should be long enough for all cases.
MEASURE_DELAY * 5

; Delay to use when waiting for SDCLK to settle. 20 ms is the longest it's
; supposed to take, and because this is a simplified implementation, we always
; wait this long.
MEASURE_LONG_DELAY * 20000

; If the input clock is 25 MHz, this will set SDCLK to approximately 400 kHz,
; and proportionately higher for other inputs.
MEASURE_DIVIDER * 63

; Command to time is CMD7_SELECT_DESELECT_CARD
MEASURE_COMMAND * 7

; Empirically, I have determined that it takes the controller this many cycles
; of SDCLK to complete a deselect card command
MEASURE_SDCLKS * 56

; Round the estimate of the input clock to nearest multiple of this many MHz
MEASURE_ACCURACY * 5

; Routine to estimate the input clock speed to the SDHCI block based upon how
; long it takes to issue a deselect-all-cards command. This command has no
; response, so it doesn't matter that lots of things aren't set up properly yet.
MeasureSpeed ROUT
        Push    "v1-v3,lr"
        LDR     v1, PeriBase
        ADD     v1, v1, #EMMC_Base
        
        ; Switch the clock divider to a known value.
        ; This is a simplified version of the algorithm in SetSDCLK.
        LDR     a1, =MEASURE_DELAY
        BL      HAL_CounterDelay
        LDR     v2, [v1, #CONTROL1]
        BIC     v2, v2, #CONTROL1_CLK_EN ; stop clock going to card
        STR     v2, [v1, #CONTROL1]
        LDR     a1, =MEASURE_DELAY
        BL      HAL_CounterDelay
        BIC     v2, v2, #CONTROL1_CLK_INTLEN ; stop clock
        STR     v2, [v1, #CONTROL1]
        LDR     a1, =MEASURE_DELAY
        BL      HAL_CounterDelay
        BIC     v2, v2, #CONTROL1_CLK_FREQ8_MASK
        BIC     v2, v2, #CONTROL1_CLK_FREQ_MS2_MASK
        ORR     v2, v2, #MEASURE_DIVIDER :SHL: CONTROL1_CLK_FREQ8_SHIFT
        STR     v2, [v1, #CONTROL1]
        LDR     a1, =MEASURE_DELAY
        BL      HAL_CounterDelay
        ORR     v2, v2, #CONTROL1_CLK_INTLEN ; start clock
        STR     v2, [v1, #CONTROL1]
        LDR     a1, =MEASURE_LONG_DELAY
        BL      HAL_CounterDelay
        LDR     v2, [v1, #CONTROL1]
        ORR     v2, v2, #CONTROL1_CLK_EN ; let clock go to card
        STR     v2, [v1, #CONTROL1]
        LDR     a1, =MEASURE_DELAY
        BL      HAL_CounterDelay
        
        ; Wait for command inhibit to be unset
        ; It's really important that this works, we won't be able to boot if
        ; this never happens, so don't bother with a timeout.
01      LDR     v2, [v1, #STATUS]
        TST     v2, #STATUS_CMD_INHIBIT
        BNE     %B01
        
        ; Ensure no interrupts are pending
        MOV     lr, #-1
        STR     lr, [v1, #INTERRUPT]
        LDR     a1, =MEASURE_DELAY
        BL      HAL_CounterDelay
        
        ; Enable the command-complete "interrupt" status bit.
        LDR     v2, =IRQ_CC
        STR     v2, [v1, #IRPT_MASK]
        LDR     a1, =MEASURE_DELAY
        BL      HAL_CounterDelay
        
        ; Use argument 0 to deselect all cards
        MOV     v2, #0
        STR     v2, [v1, #ARG1]
        LDR     a1, =MEASURE_DELAY
        BL      HAL_CounterDelay
        
        ; Wait for the timer to wrap, so we don't have to deal with wrap later
        BL      HAL_CounterRead
02      MOV     v2, a1
        BL      HAL_CounterRead
        CMP     a1, v2
        BLS     %B02
        
        MRS     v3, CPSR
        ORR     lr, v3, #&80
        MSR     CPSR_c, lr ; IRQs off
        
        ; Read start time
        BL      HAL_CounterRead
        MOV     v2, a1
        
        ; Trigger the command (all the other bits in CMDTM are 0)
        MOV     lr, #MEASURE_COMMAND :SHL: CMDTM_CMD_INDEX_SHIFT
        STR     lr, [v1, #CMDTM]
        
        ; Wait for completion
03      LDR     lr, [v1, #INTERRUPT]
        TST     lr, #IRQ_CC
        BEQ     %B03
        
        ; Read finish time
        BL      HAL_CounterRead
        
        ; Acknowledge interrupt
        MOV     lr, #IRQ_CC
        STR     lr, [v1, #INTERRUPT]
        
        MSR     CPSR_c, v3 ; IRQs restored
        
        ; Calculate elapsed time
        SUB     v2, v2, a1
        LDR     a1, =MEASURE_DELAY
        BL      HAL_CounterDelay
        
        ; Calculate input clock frequency
        LDR     a1, =(MEASURE_SDCLKS * MEASURE_DIVIDER) / MEASURE_ACCURACY
        ADD     a1, a1, v2, LSR #1 ; round to nearest
        DivRem  a2, a1, v2, lr
        LDR     a3, =MEASURE_ACCURACY  * 1000
        MUL     a4, a2, a3
        STR     a4, SDHCIInputClock
        
        Pull    "v1-v3,pc"


        MACRO
$class  HALDeviceField $field, $value
        LCLS    myvalue
      [ "$value" = ""
myvalue SETS    "$field"
      |
myvalue SETS    "$value"
      ]
        ASSERT  . - %A0 = HALDevice_$class$field
     [ ?HALDevice_$class$field = 2
        DCW     $myvalue
   ELIF ?HALDevice_$class$field = 4
        DCD     $myvalue
      |
        %       ?HALDevice_$class$field
      ]
        MEND

; Template for device block

Template
0
        HALDeviceField Type,               HALDeviceType_ExpCtl + HALDeviceExpCtl_SDIO
        HALDeviceField ID,                 HALDeviceID_SDIO_SDHCI
        HALDeviceField Location,           HALDeviceBus_Sys + HALDeviceSysBus_AHB ; judging from the name of the unobtainable Arasan spec!
        HALDeviceField Version,            0
        HALDeviceField Description
        HALDeviceField Address,            0 ; patched up at initialisation
        HALDeviceField Reserved1,          0
        HALDeviceField Activate,           0 ; patched up at initialisation
        HALDeviceField Deactivate
        HALDeviceField Reset
        HALDeviceField Sleep
        HALDeviceField Device,             iDev_GPU_SDIO ; unconfirmed
        HALDeviceField TestIRQ
        HALDeviceField ClearIRQ,           0
        HALDeviceField Reserved2,          0
SDHCI   HALDeviceField Flags,              HALDeviceSDHCI_Flag_32bit
SDHCI   HALDeviceField Slots,              1
SDHCI   HALDeviceField SlotInfo,           0 ; patched up at initialisation
SDHCI   HALDeviceField WriteRegister
SDHCI   HALDeviceField GetCapabilities,    0 ; patched up at initialisation
SDHCI   HALDeviceField GetVddCapabilities, 0 ; our fake capabilities register suffices already
SDHCI   HALDeviceField SetVdd
SDHCI   HALDeviceField SetBusMode,         0
SDHCI   HALDeviceField PostPowerOn,        0
SDHCI   HALDeviceField SetBusWidth,        0
SDHCI   HALDeviceField GetMaxCurrent
SDHCI   HALDeviceField SetSDCLK
SDHCI   HALDeviceField GetTMCLK
SDHCI   HALDeviceField SetActivity,        0 ; patched up at initialisation
SDHCI   HALDeviceField GetCardDetect,      0 ; patched up at initialisation
SDHCI   HALDeviceField GetWriteProtect


        ; Init the SDHCI HAL device
SDIO_InitDevices ROUT
        Push    "lr"
        BL      MeasureSpeed
        
        ADR     a1, SDHCIDevice
        ADR     a2, Template
        MOV     a3, #HALDevice_SDHCISize
        BL      memcpy
        
        LDR     a3, Board_Revision
        BIC     a3, a3, #BoardRevision_User_Mask ; mask off overclocking / user bits
        TST     a3, #BoardRevision_NewScheme
        BNE     %FT01
        ASSERT  BoardRevision_AorB_Last < BoardRevision_BPlus_Sony
        CMP     a3, #BoardRevision_BPlus_Sony
        TEQ     a3, #BoardRevision_Compute_Sony
        TEQNE   a3, #BoardRevision_Compute_Embest
        B       %FT02
01      AND     a3, a3, #BoardRevision_Model_Mask
        ASSERT  BoardRevision_Model_A < BoardRevision_Model_APlus 
        ASSERT  BoardRevision_Model_B < BoardRevision_Model_APlus 
        CMP     a3, #BoardRevision_Model_APlus
        TEQ     a3, #BoardRevision_Model_Compute
        TEQNE   a3, #BoardRevision_Model_Compute3
02      ; So now LO => model A or B, EQ => Compute or Compute3, HI => A+, B+ or Pi 2 or Pi 3 or Pi 0
        
        ; Activate
        ADRLO   a1, Activate_AB
        ADRHI   a1, Activate_BPlus
        ADREQ   a1, Activate_Compute
        STR     a1, SDHCIDevice + HALDevice_Activate
        
        ; Address and SlotInfo_StdRegs
        LDR     a1, PeriBase
        ADD     a1, a1, #EMMC_Base
        STR     a1, SDHCIDevice + HALDevice_Address
        STR     a1, SDHCISlotInfo + HALDeviceSDHCI_SlotInfo_StdRegs
        
        ; SlotInfo
        ADRL    a1, SDHCISlotInfo
        STR     a1, SDHCIDevice + HALDevice_SDHCISlotInfo

        ; SlotInfo_Flags
        MOV     a1, #HALDeviceSDHCI_SlotFlag_Bus4Bit
        ORRHI   a1, a1, #HALDeviceSDHCI_SlotFlag_NoCardDetect
        ORREQ   a1, a1, #HALDeviceSDHCI_SlotFlag_IntegratedMem
        BNE     %FT20
        TEQ     a3, #BoardRevision_Model_Compute3
        BNE     %FT10
        LDR     a4, SafetyCatch ; Here iff a Compute Module 3
                                ; Unhelpfully the revision number for both CM3 and CM3L is the same, but we need
                                ; to be sure whether the SDIO attached memory is fixed or removable.
        TEQ     a4, #0
        BICNE   a1, a1, #HALDeviceSDHCI_SlotFlag_IntegratedMem 
10
        MOVS    a4, #0 ; put back EQ status
20
        STR     a1, SDHCISlotInfo + HALDeviceSDHCI_SlotInfo_Flags
        
        ; GetCapabilities
        ADR     a1, GetCapabilities_AB_BPlus
        ADDEQ   a1, a1, #GetCapabilities_Compute - GetCapabilities_AB_BPlus
        STR     a1, SDHCIDevice + HALDevice_SDHCIGetCapabilities

        ; SetActivity and GetCardDetect
        ADRL    a1, SetActivity_AB
        ADDHI   a1, a1, #SetActivity_BPlus - SetActivity_AB
        ADDEQ   a1, a1, #SetActivity_Compute - SetActivity_AB
        ADRL    a2, GetCardDetect_AB
        ADDHS   a2, a2, #GetCardDetect_BPlus_Compute - GetCardDetect_AB
        TEQ     a3, #BoardRevision_Model_B3
        TEQNE   a3, #BoardRevision_Model_B3Plus
        TEQ     a3, #BoardRevision_Model_A3Plus
        ADREQL  a1, SetActivity_B3
        STR     a1, SDHCIDevice + HALDevice_SDHCISetActivity
        STR     a2, SDHCIDevice + HALDevice_SDHCIGetCardDetect
        
        MOV     a1, #0 ; flags
        ADR     a2, SDHCIDevice
        Pull    "lr"
        LDR     pc, OSentries+4*OS_AddDevice ; tail call

        ; a1 = GPIO pin
        ; a2 = function select number
PinMux_SetFunction ROUT
        Push    "lr"
        MOV     ip, #32 / GPIO_FSEL_SHIFT
        DivRem  a3, a1, ip, lr ; a3 = register, a1 = field in register
        ASSERT  GPIO_FSEL_SHIFT = 3
        ADD     a1, a1, a1, LSL #1

        LDR     a4, PeriBase
        ADD     a4, a4, #GPIO_Base
        ADD     a4, a4, #GPFSel0
        MOV     ip, #GPIO_FSEL_MASK
        MOV     ip, ip, LSL a1
        LDR     lr, [a4, a3, LSL #2]
        BIC     lr, lr, ip
        ORR     lr, lr, a2, LSL a1
        STR     lr, [a4, a3, LSL #2]
        Pull    "pc"

        ; a1 = GPIO pin
        ; a2 = pull type
GPIO_SetPull ROUT
        Push    "v1,lr"
        MOV     v1, a1
        LDR     ip, PeriBase
        ADD     ip, ip, #GPIO_Base
        STR     a2, [ip, #GPPUPDEN]
        
        MOV     a1, #PUD_DELAY
        BL      HAL_CounterDelay
        
        LDR     ip, PeriBase
        MOV     lr, #1
        ADD     ip, ip, #GPIO_Base
        ADD     ip, ip, #GPPUDCK0
        AND     a1, v1, #&1F
        MOV     a2, v1, LSR #5
        MOV     lr, lr, LSL a1
        STR     lr, [ip, a2, LSL #2]
        
        MOV     a1, #PUD_DELAY
        BL      HAL_CounterDelay
        
        LDR     ip, PeriBase
        MOV     a1, #0
        ADD     ip, ip, #GPIO_Base
        ADD     ip, ip, #GPPUDCK0
        MOV     a2, v1, LSR #5
        
        ; Manual recommends unsetting registers in this order, but I'm paranoid about an interrupt going off in between
        MRS     lr, CPSR
        ORR     v1, lr, #&C0 ; I and F bits
        MSR     CPSR_c, v1
        STR     a1, [ip, #GPPUPDEN - GPPUDCK0]
        STR     a1, [ip, a2, LSL #2]
        MSR     CPSR_c, lr
        
        Pull    "v1,pc"

        ; a1 = GPIO pin
        ; a2 = value to set (0 or 1)
GPIO_Output ROUT
        LDR     ip, PeriBase
        TEQ     a2, #0
        ADD     ip, ip, #GPIO_Base
        ADDEQ   ip, ip, #GPClr0
        ADDNE   ip, ip, #GPSet0
        MOV     a4, #1
        MOV     a2, a1, LSR #5
        AND     a1, a1, #&1F
        MOV     a4, a4, LSL a1
        STR     a4, [ip, a2, LSL #2]
        MOV     pc, lr

        ; a1 = GPIO pin
        ; on exit, a1 = 0 or 1
GPIO_Input ROUT
        LDR     ip, PeriBase
        MOV     a4, #1
        MOV     a2, a1, LSR #5
        AND     a1, a1, #&1F
        ADD     ip, ip, #GPIO_Base
        ADD     ip, ip, #GPLev0
        LDR     a3, [ip, a2, LSL #2]
        AND     a1, a4, a3, LSR a1
        MOV     pc, lr

Description DATA
        =       "Arasan SD host controller", 0
        ALIGN

NOPEntry ROUT
        MOV     pc, lr

Activate_AB ROUT
        Push    "sb,lr"
        SUB     sb, a1, #:INDEX:SDHCIDevice
        
        MOV     lr, #0
        STR     lr, SDHCILastWriteCount
        
        ; SDCLK has to be set up before any register writes are done - it's not
        ; reasonable to expect SDIODriver to know this requirement
        MOV     a3, #MIN_SDCLK
        BL      SetSDCLK
        
        DoMemBarrier a1 ; switch to GPIO peripheral
        
        ; Set up pin mux registers and GPIO directions
        MOV     a1, #GPIO_CD_AB
        MOV     a2, #GPIO_FSEL_INPUT
        BL      PinMux_SetFunction
        MOV     a1, #GPIO_CD_AB
        MOV     a2, #GPIO_PUD_UP
        BL      GPIO_SetPull
        MOV     a1, #GPIO_STATUS_LED_AB
        MOV     a2, #GPIO_FSEL_OUTPUT
        BL      PinMux_SetFunction
        MOV     a1, #GPIO_STATUS_LED_AB
        MOV     a2, #GPIO_PUD_OFF
        BL      GPIO_SetPull
        B       Activate_Common

Activate_BPlus ROUT
        Push    "sb,lr"
        SUB     sb, a1, #:INDEX:SDHCIDevice
        
        MOV     lr, #0
        STR     lr, SDHCILastWriteCount
        
        ; SDCLK has to be set up before any register writes are done - it's not
        ; reasonable to expect SDIODriver to know this requirement
        MOV     a3, #MIN_SDCLK
        BL      SetSDCLK
        
        DoMemBarrier a1 ; switch to GPIO peripheral
        
        ; Set up pin mux registers and GPIO directions
        MOV     a1, #GPIO_STATUS_LED_BPlus
        MOV     a2, #GPIO_FSEL_OUTPUT
        BL      PinMux_SetFunction
        MOV     a1, #GPIO_STATUS_LED_BPlus
        MOV     a2, #GPIO_PUD_OFF
        BL      GPIO_SetPull
        B       Activate_Common

Activate_Compute ROUT
        Push    "sb,lr"
        SUB     sb, a1, #:INDEX:SDHCIDevice

        MOV     lr, #0
        STR     lr, SDHCILastWriteCount

        ; SDCLK has to be set up before any register writes are done - it's not
        ; reasonable to expect SDIODriver to know this requirement
        MOV     a3, #MIN_SDCLK
        BL      SetSDCLK

        DoMemBarrier a1 ; switch to GPIO peripheral
        ; drop through...
Activate_Common
        MOV     a1, #GPIO_DAT3
        MOV     a2, #GPIO_PUD_UP
        BL      GPIO_SetPull
        MOV     a1, #GPIO_DAT2
        MOV     a2, #GPIO_PUD_UP
        BL      GPIO_SetPull
        MOV     a1, #GPIO_DAT1
        MOV     a2, #GPIO_PUD_UP
        BL      GPIO_SetPull
        MOV     a1, #GPIO_DAT0
        MOV     a2, #GPIO_PUD_UP
        BL      GPIO_SetPull
        MOV     a1, #GPIO_CMD
        MOV     a2, #GPIO_PUD_UP
        BL      GPIO_SetPull
        MOV     a1, #GPIO_CLK
        MOV     a2, #GPIO_PUD_UP
        BL      GPIO_SetPull
        
        DoMemBarrier a1 ; back to SDHCI peripheral
        
        MOV     a1, #1 ; always succeed
        Pull    "sb,pc"

Deactivate * NOPEntry

Reset * NOPEntry ; I don't think there's any way for us to reset the controller

Sleep ROUT
        MOV     a1, #0
        MOV     pc, lr

TestIRQ ROUT
        ; Not a shared interrupt, so it must be our fault
        MOV     a1, #1
        MOV     pc, lr

WriteRegister ROUT
        ; The BCM2835 has a bug which means that we have to leave 2 SDCLK cycles
        ; between each SDHCI register write, except for those to the data port.
        ; This entry point isn't used for data port writes, so there is no need
        ; to filter them out.
        Push    "v1-v4,sb,lr"
        SUB     sb, a1, #:INDEX:SDHCIDevice
        MOV     v3, a3
        MOV     v4, a4
        
        BL      HAL_CounterRead
        LDR     v1, SDHCILastWriteCount ; v1 = upper limit of pause period
        LDR     v2, SDHCIWriteInterval
        SUBS    v2, v1, v2              ; v2 = lower limit of pause period
        BPL     %F30
        
        ; The precise value of the counter frequency is liable to change over
        ; time to correct for clock drift, so if our delay includes the wrap
        ; point then we have to be careful to avoid proportionately large errors.
        ; The approach we take is to wait until a wrap happens, then do an
        ; additional wait for the remainder of the time, starting from the count
        ; we read back from the hardware.
        B       %F20
10      BL      HAL_CounterRead
20      CMP     a1, v1
        BLS     %B10
        MOV     v1, a1
        ADD     v2, v2, v1

        ; Loop while counter <= upper limit and counter > lower limit
30      ADD     v1, v1, #1
        B       %F50
40      BL      HAL_CounterRead
50      CMP     a1, v1
        CMPLO   v2, a1
        BLO     %B40
        
        ; Now we can do the register write
        STR     v4, [v3]
        
        ; Remember the time at which we did the write
        BL      HAL_CounterRead
        STR     a1, SDHCILastWriteCount
        Pull    "v1-v4,sb,pc"

GetCapabilities_AB_BPlus ROUT
        ; Vss is fixed in hardware - see schematics
        ; Eben says high bus speed doesn't work, but Linux seems to manage?
        ; Buffer size is mentioned in the prose in the BCM2835 ARM peripherals datasheet
        LDR     a1, =CAP_VS33 :OR: CAP_HSS :OR: CAP_MBL_1024
        MOV     pc, lr

GetCapabilities_Compute ROUT
        ; The eMMC chip doesn't seem to be compatible with the BCM2835's high bus speed timings.
        ; We get command line conflicts unless we set HostControl1's HSE bit (which we don't
        ; normally do due to compatibility issues with some 50 MHz MMCplus cards and 52 MHz
        ; SD cards, which otherwise function on the Pis with card slots - see SDIODriver.c.probe
        ; for more). But even if we do set HSE, data transfer is too unreliable for practical
        ; use with the eMMC. The easiest workaround is to alter the fake capabilities register
        ; to claim that high speed isn't supported by the controller.
        LDR     a1, =CAP_VS33 :OR: CAP_MBL_1024
        MOV     pc, lr

SetVdd * NOPEntry ; There is no software control of Vdd for this board

GetMaxCurrent ROUT
        ; Can't find any information on this, so just stick with a low value
        MOV     a1, #100
        MOV     pc, lr

        ; In: a1 = requested frequency, kHz
        ; Out: v1 = how many counter ticks we have to see to guarantee 2 SDCLK cycles have passed
        ;      v2 = divider to use
        ;      v3 = actual frequency achieved, kHz
        ;      a2,a4,ip corrupted
CalcTimings ROUT
        ; By experimentation, I've determined that the 40 MHz input clock
        ; can be divided by any integer from 1 to 1023.
        LDR     ip, SDHCIInputClock
        ADD     ip, ip, a1 ; input clock, adjusted to ensure round up
        SUB     ip, ip, #1
        DivRem  v2, ip, a1, a2
        CMP     v2, #1
        MOVLO   v2, #1
        MOV     ip, #1024
        CMP     v2, #1024
        SUBHS   v2, ip, #1
        
        ; v2 now contains the final divisor. Work out what frequency that
        ; corresponds to.
        LDR     ip, SDHCIInputClock
        DivRem  v3, ip, v2, a2
        
        ; Work out how many counter ticks we have to see to guarantee 2 SDCLK cycles
        ; between each register write. This is 2 * (counter-freq / SDCLK-freq)
        ; with a round up, or (2 * counter-freq + SDCLK-freq - 1) / SDCLK-freq
        ; Also add 1 to allow for the fact that when the first count is read, we
        ; don't know how close to the end of that counter period it is.
        MOV     ip, #1000
        MUL     a4, v3, ip
        LDR     ip, =REGISTER_WRITE_PACE * TIMER_RATE - 1
        ADD     ip, ip, a4
        DivRem  v1, ip, a4, a2
        ADD     v1, v1, #1
        MOV     pc, lr

SetSDCLK ROUT
        Push    "v1-v5,sb,lr"
        SUB     sb, a1, #:INDEX:SDHCIDevice
        
        ; Set a long gap between writes while we're fiddling with the SDCLK
        MOV     a1, #MIN_SDCLK
        BL      CalcTimings
        STR     a1, SDHCIWriteInterval
        
        ; Calculate desired values
        MOV     a1, a3
        BL      CalcTimings
        ; v1 = interval, v2 = divider, v3 = freq
        
        ; Program clock control register
        LDR     v5, PeriBase
        ADD     v5, v5, #EMMC_Base
        LDR     v4, [v5, #CONTROL1]!
        
        BIC     v4, v4, #CONTROL1_CLK_EN ; stop clock going to card
        ADR     a1, SDHCIDevice
        MOV     a3, v5
        MOV     a4, v4
        BL      WriteRegister
        
        BIC     v4, v4, #CONTROL1_CLK_INTLEN ; stop clock
        ADR     a1, SDHCIDevice
        MOV     a3, v5
        MOV     a4, v4
        BL      WriteRegister
        
        BIC     v4, v4, #CONTROL1_CLK_FREQ8_MASK
        BIC     v4, v4, #CONTROL1_CLK_FREQ_MS2_MASK
        MOV     a1, v2, LSL #CONTROL1_CLK_FREQ8_SHIFT - 0
        MOV     a2, v2, LSR #8 - CONTROL1_CLK_FREQ_MS2_SHIFT
        AND     a1, a1, #CONTROL1_CLK_FREQ8_MASK
        AND     a2, a2, #CONTROL1_CLK_FREQ_MS2_MASK
        ORR     v4, v4, a1
        ORR     v4, v4, a2
        ADR     a1, SDHCIDevice
        MOV     a3, v5
        MOV     a4, v4
        BL      WriteRegister
        
        ORR     v4, v4, #CONTROL1_CLK_INTLEN ; start clock
        ADR     a1, SDHCIDevice
        MOV     a3, v5
        MOV     a4, v4
        BL      WriteRegister
        
        ; Wait for up to 20 ms for the clock to stabilise
        ; v2 = previous counter value
        ; v4 = time remaining
        BL     HAL_CounterRead
        MOV    v2, a1
        LDR    v4, =(TIMER_RATE * CLOCKSET_TIMEOUT) / 1000
70      LDR    a4, [v5]
        CMP    v4, #0
        BMI    %F80 ; timed out (hope this never happens!)
        TST    a4, #CONTROL1_CLK_STABLE
        BNE    %F80 ; stabilised
        BL     HAL_CounterRead
        SUBS   a2, a1, v2 ; elapsed since last time - if -ve then we have wrap so do nothing
        SUBPL  v4, v4, a2
        MOV    v2, a1
        B      %B70

80      ; Re-enable clock
        ADR     a1, SDHCIDevice
        MOV     a3, v5
        ORR     a4, a4, #CONTROL1_CLK_EN
        BL      WriteRegister
        
        ; Now we can save the final gap
        STR     v1, SDHCIWriteInterval
        ; Return the actual frequency
        MOV     a1, v3
        Pull    "v1-v5,sb,pc"

GetTMCLK ROUT
        ; SDCLK is reused for TMCLK
        Push    "sb,lr"
        SUB     sb, a1, #:INDEX:SDHCIDevice
        LDR     a1, PeriBase
        ADD     a1, a1, #EMMC_Base
        LDR     a2, [a1, #CONTROL1]
        AND     a3, a2, #CONTROL1_CLK_FREQ8_MASK
        AND     a4, a2, #CONTROL1_CLK_FREQ_MS2_MASK
        MOV     a3, a3, LSR #CONTROL1_CLK_FREQ8_SHIFT - 0
        ORR     a3, a3, a4, LSL #8 - CONTROL1_CLK_FREQ_MS2_SHIFT
        LDR     a2, SDHCIInputClock
        DivRem  a1, a2, a3, a4
        Pull    "sb,pc"

SetActivity_AB ROUT
        Push    "sb,lr"
        DoMemBarrier lr ; switch to GPIO peripheral
        SUB     sb, a1, #:INDEX:SDHCIDevice
        
        ; Line is active low
        TEQ     a3, #HALDeviceSDHCI_ActivityOff
        MOVEQ   a2, #1
        MOVNE   a2, #0
        MOV     a1, #GPIO_STATUS_LED_AB
        BL      GPIO_Output
        
        DoMemBarrier lr ; back to SDHCI peripheral
        Pull    "sb,pc"
        
SetActivity_BPlus ROUT
        Push    "sb,lr"
        DoMemBarrier lr ; switch to GPIO peripheral
        SUB     sb, a1, #:INDEX:SDHCIDevice
        
        ; Line is active high
        ASSERT  HALDeviceSDHCI_ActivityOff = 0
        MOVS    a2, a3
        MOVNE   a2, #1
        MOV     a1, #GPIO_STATUS_LED_BPlus
        BL      GPIO_Output
        
        DoMemBarrier lr ; back to SDHCI peripheral
        Pull    "sb,pc"
        
SetActivity_Compute ROUT
        ; No standard way of wiring up the activity LED on Compute
        MOV     pc, lr

SetActivity_B3 ROUT
        Push    "sb,lr"
        SUB     sb, a1, #:INDEX:SDHCIDevice
        LDR     a1, VirtGPIOBuf
        CMP     a1, #0
        Pull    "sb,pc",EQ
        ; The virtual GPIO buffer uses some funny counter system to track enable/disable state changes. If we don't follow its rules, it won't work.
        LDR     a2, [a1]
        SXTH    a4, a2, ROR #16 ; Enable count
        SXTH    a2, a2 ; Disable count
        SUB     lr, a4, a2
        SXTH    lr, lr ; Difference
        TEQ     a3, #HALDeviceSDHCI_ActivityOff
        BEQ     %FT50
        CMP     lr, #0
        Pull    "sb,pc", GT ; Don't update if already on
        ADD     a4, a4, #1
        B       %FT90
50
        CMP     lr, #0
        Pull    "sb,pc", LE ; Don't update if already off
        ADD     a2, a2, #1
90
        PKHBT   a2, a2, a4, LSL #16
        STR     a2, [a1]
        Pull    "sb,pc"

GetCardDetect_AB ROUT
        Push    "sb,lr"
        DoMemBarrier lr ; switch to GPIO peripheral
        SUB     sb, a1, #:INDEX:SDHCIDevice
        
        MOV     a1, #GPIO_CD_AB
        BL      GPIO_Input
        ; Line is active low, so invert
        SUB     a1, a1, #1
        AND     a1, a1, #1
        
        DoMemBarrier lr ; back to SDHCI peripheral
        Pull    "sb,pc"

GetCardDetect_BPlus_Compute ROUT
        ; CD is not connected. This entry shouldn't be called, but just in case
        ; (perhaps someone softloaded old SDFSDriver/SDFS?) report card present
        MOV     a1, #1
        MOV     pc, lr

GetWriteProtect ROUT
        ; WP is not connected, so just have to always report unprotected :-(
        MOV     a1, #0
        MOV     pc, lr

        END
@


1.14
log
@Fix SD activity LED on 3B+
Detail:
  hdr/BCM2835 - Add some new board revision values
  s/SDIO - Treat the 3B+ the same as the 3B when handling the activity LED. Also detect the Embest-manufactured CM1 and treat it the same as the Sony one.
Admin:
  Tested on Raspberry Pi 3B+


Version 0.74. Tagged as 'BCM2835-0_74'
@
text
@d391 1
@


1.14.2.1
log
@Add support for Pi model 3A+

Tagged as 'BCM2835-0_75-1'
@
text
@a390 1
        TEQ     a3, #BoardRevision_Model_A3Plus
@


1.13
log
@Add support for CM3 and CM3L with or without eMMC
The SDIO HAL device reports when it is sure fixed disc media is attached (ie. eMMC soldered on the same PCB) which causes SDFS to report this to FileCore as a fixed disc, skipping the removable safety checks.
However, CM3 and CM3L both return the same board id so we can't work out which is which. Additionally, someone could attach an external eMMC in theory on a custom expansion board (instead of an SD card socket like the CMIO has).
To resolve this, we assign IO expander line 6 of U8 to be a safety catch. If that line is held low, it signifies this is definitely a CM3 - in effect this is a "definitely has eMMC" or "maybe has eMMC" switch.

Tested on CM1, CM3, CM3L, and a suitably modified CM3 with the help of Chris Hall.

Version 0.69. Tagged as 'BCM2835-0_69'
@
text
@d332 4
a335 3
        ASSERT  BoardRevision_AorB_Last < BoardRevision_BPlus  
        CMP     a3, #BoardRevision_BPlus
        TEQ     a3, #BoardRevision_Compute
d390 1
@


1.13.2.1
log
@Merge latest changes from HEAD

Version 0.75, 1.70.2.4. Tagged as 'BCM2835-0_75-1_70_2_4'
@
text
@d332 3
a334 4
        ASSERT  BoardRevision_AorB_Last < BoardRevision_BPlus_Sony
        CMP     a3, #BoardRevision_BPlus_Sony
        TEQ     a3, #BoardRevision_Compute_Sony
        TEQNE   a3, #BoardRevision_Compute_Embest
a388 1
        TEQNE   a3, #BoardRevision_Model_B3Plus
@


1.12
log
@Move the board rev definitions into hdr
Detail:
  Useful if not just SDIO can see the definitions.

Version 0.62. Tagged as 'BCM2835-0_62'
@
text
@d332 1
d337 2
d341 2
a342 1
02      ; So now LO => model A or B, EQ => Compute, HI => A+, B+ or Pi 2
d364 11
@


1.11
log
@Move CMOS settings out of riscos.img
The Pi is unusual in self modifying the ROM image when a CMOS setting was changed (due to there being none on the PCB), with the potential of ending up with a corrupt OS image on disc.
Remove this code and emulate the CMOS using normal RAM, and using the Pi firmware to load the CMOS file in for us (like fatload does on OMAP based designs) by using its ability to load a second arbitrary file at an address, intended in the Linux world to load a disc image.

To use this you will need to add
  ramfsfile=CMOS
  ramfsaddr=0x508000
to config.txt which loads it 5MB (ie. ImageSize) above the default load address (&8000), though as noted in the changes to BCM2835-0_60 we don't really need to load at offset &8000 but generally do since that's the Pi firmware's default.

hdr/StaticWS:
New workspace to hold our CMOS copy.
CMOS.s:
Remove the 2k magic block, add a simple bytewise copy loop implementation.
SDIO.s:
Extend ADR range.
Top.s:
Copy what the Pi firmware loads somewhere safe until the MMU is on, then copy it back (converting from logical to physical order along the way).
Change other values recovered from pre-MMU times using advanced post indexed addressing technology (TM) rather than switching around sb a lot.

Tested on a Pi 3, with and without an initial CMOS file present.

Version 0.61. Tagged as 'BCM2835-0_61'
@
text
@a59 30
; Significant board revisions
BoardRevision_BPlus   * &10
BoardRevision_Compute * &11
BoardRevision_APlus   * &12
; Starting with the Pi 2, board revisions have changed to a bitfield scheme:
BoardRevision_NewScheme     *   1 :SHL: 23 ; if set, indicates the following are in use
BoardRevision_Mem_256M      *   0 :SHL: 20
BoardRevision_Mem_512M      *   1 :SHL: 20
BoardRevision_Mem_1G        *   2 :SHL: 20
BoardRevision_Mem_Mask      *   7 :SHL: 20
BoardRevision_Manuf_Sony    *   0 :SHL: 16
BoardRevision_Manuf_Egoman  *   1 :SHL: 16
BoardRevision_Manuf_Embest  *   2 :SHL: 16
BoardRevision_Manuf_Embest2 *   4 :SHL: 16
BoardRevision_Manuf_Mask    *  15 :SHL: 16
BoardRevision_Proc_2835     *   0 :SHL: 12
BoardRevision_Proc_2836     *   1 :SHL: 12
BoardRevision_Proc_2837     *   2 :SHL: 12
BoardRevision_Proc_Mask     *  15 :SHL: 12
BoardRevision_Model_A       *   0 :SHL: 4
BoardRevision_Model_B       *   1 :SHL: 4
BoardRevision_Model_APlus   *   2 :SHL: 4
BoardRevision_Model_BPlus   *   3 :SHL: 4
BoardRevision_Model_B2      *   4 :SHL: 4
BoardRevision_Model_Compute *   6 :SHL: 4
BoardRevision_Model_B3      *   8 :SHL: 4
BoardRevision_Model_Zero    *   9 :SHL: 4
BoardRevision_Model_Mask    * 255 :SHL: 4
BoardRevision_Rev_Mask      *  15 :SHL: 0

d329 1
a329 1
        BIC     a3, a3, #&FF000000 ; mask off overclocking / user bits
@


1.10
log
@GET Hdr:CPU.Arch
Detail:
  s/SDIO - Add a GET of Hdr:CPU.Arch, as it's now required for use of the DivRem macro
Admin:
  Tested on Raspberry Pi


Version 0.58. Tagged as 'BCM2835-0_58'
@
text
@d383 1
a383 1
        ADR     a1, SDHCISlotInfo
@


1.9
log
@Fix sticky SD activity LED on Pi 3 B
Detail:
  s/SDIO - Signed counter wrap-around once &80007fff was reached was causing the code to think the activity LED was permanently off, resulting in the code only making "turn on" requests. Calculating the difference as a (signed) 16bit value solves the problem.
Admin:
  Tested on Pi 3 B
  Fixes SD activity LED being stuck on after e.g. letting Verify run for a few seconds.


Version 0.57. Tagged as 'BCM2835-0_57'
@
text
@d37 1
@


1.8
log
@Fix SD card activity LED on Pi 3B
Detail:
  hdr/BCM2835 - Remove mailbox definitions - use the ones exported by BCMSupport to avoid needless duplication
  hdr/StaticWS, s/Messaging, s/Top - Use the mailbox property interface to request & map in the virtual GPIO buffer (if present)
  s/SDIO - On the Pi 3B, the GPIO that was used for the SD activity GPIO is now used for a different purpose. To control the activity LED we need to go via an I2C attached GPIO extender, which itself is exposed to the ARM via the new "virtual GPIO" buffer
  s/VCHIQ - Update to use BCMSupport mailbox definitions
Admin:
  Tested on Pi 1B, 3B


Version 0.54. Tagged as 'BCM2835-0_54'
@
text
@d855 2
d859 1
a859 1
        CMP     a4, a2
d864 1
a864 1
        CMP     a4, a2
@


1.7
log
@  Properly supports new board revision scheme for SD source file
Detail:
  Parses the revision ID bitfield for new-style revisions - should provide
  some level of forward compatibility at last. The equivalent code in s.GPIO
  hasn't been tackled yet, mainly because it requires some thought about how
  best to handle the Compute module (given that the daughter card can be
  plugged into any number of devices, each of which will use GPIO differently).
Admin:
  Tested on Compute module and Pi 2 with latest firmware.

Version 0.42. Tagged as 'BCM2835-0_42'
@
text
@d76 1
d84 2
d384 1
a384 1
        
d402 2
d845 25
@


1.6
log
@  Adapt to release version of Raspberry Pi 2 firmware
Detail:
  The board revision scheme has changed since pre-release firmware, so the
  previous version of the SD code would have misidentified a Pi 2 (as well
  as the model A+) as a Compute module. It looks like in future, board
  revisions could be a more meaningful bitfield rather than the order-of-
  release index that's been used up to now, but at this point we can still
  manage with a cunning combination of CMP and TEQ tests. Note that the GPIO
  part of the HAL hasn't yet been updated to be aware of the new board
  revisions.


Version 0.41. Tagged as 'BCM2835-0_41'
@
text
@d63 22
a84 2
; Starting with the Pi 2, board revisions appear to have changed to a bitfield
; scheme. Any bitfield value will significantly exceed these old "enum" revisions.
d355 3
d360 5
a364 1
        ; So now LO => model A or B, EQ => Compute, HI => A+, B+ or Pi 2
@


1.5
log
@  Add support for Raspberry Pi Compute module and Raspberry Pi 2
Detail:
  * Compute module support consists of eMMC support in the SDHCI driver. The
    eMMC chip on the Compute module only works reliably if under-clocked to
    25 MHz.
  * Pi 1 vs Pi 2 differences are selected at runtime by checking the CPU ID,
    so a single ROM image will work with both boards.
  * Added ARMv7 cache maintenance routine for use on Pi 2.
  * The physical address of the peripherals has moved in Pi 2 to make space
    for the 1 GB of RAM.
  * The ARM physical address space is mapped differently onto the GPU
    address space in Pi 2 because the ARM now uses the L2 cache that comes
    with the Cortex-A7 instead of the GPU's L2 cache.
  * Still waiting for confirmation on the board revision ID that will be
    used for Pi 2, so may require further tweaks for production releases.


Version 0.40. Tagged as 'BCM2835-0_40'
@
text
@d60 5
a64 1
BoardRevision_BPlus  *  &10 ; they took away my card detect line!
d336 2
d341 2
a342 2
        ADREQ   a1, Activate_BPlus
        ADRHI   a1, Activate_Compute
d357 2
a358 2
        ORREQ   a1, a1, #HALDeviceSDHCI_SlotFlag_NoCardDetect
        ORRHI   a1, a1, #HALDeviceSDHCI_SlotFlag_IntegratedMem
d363 1
a363 1
        ADDHI   a1, a1, #GetCapabilities_Compute - GetCapabilities_AB_BPlus
d368 2
a369 2
        ADDEQ   a1, a1, #SetActivity_BPlus - SetActivity_AB
        ADDHI   a1, a1, #SetActivity_Compute - SetActivity_AB
@


1.4
log
@Permit HALDevice_SDHCISize to grow in future

Version 0.39. Tagged as 'BCM2835-0_39'
@
text
@d306 1
a306 1
SDHCI   HALDeviceField GetCapabilities
d334 3
a336 2
        ADRCC   a1, Activate_AB
        ADRCS   a1, Activate_BPlus
d351 2
a352 1
        ORRCS   a1, a1, #HALDeviceSDHCI_SlotFlag_NoCardDetect
d355 5
d362 2
a363 1
        ADDCS   a1, a1, #SetActivity_BPlus - SetActivity_AB
d365 1
a365 1
        ADDCS   a2, a2, #GetCardDetect_BPlus - GetCardDetect_AB
d519 15
d618 1
a618 1
GetCapabilities ROUT
d625 11
d803 4
d821 1
a821 1
GetCardDetect_BPlus ROUT
@


1.3
log
@  Support the Raspberry Pi model B+
Detail:
  The activity GPIO pin has been reassigned and its sense is inverted,
  compared to earlier boards. More importantly, the SD card detect pin has
  been removed entirely, so we need to signal to the SD stack to use its
  new timeout-based state machine (rather than polling for card presence).
Admin:
  Already in use in RC12a.

Version 0.35. Tagged as 'BCM2835-0_35'
@
text
@a317 1
        ASSERT  . - %A0 = HALDevice_SDHCISize
@


1.2
log
@  Fixes for SD support
Detail:
  * Engage the GPIO controller's pull-up resistors on SDCLK, CMD and DAT0-DAT3.
    In tests, this seems to address the worst of the unreliability we have
    seen previously.
  * Remove the entry to change the bus between push-pull and open-drain modes.
    The BCM2835 simply doesn't seem to be able to do this. Fortunately, all
    the cards I have tested seem to be OK with the GPIO controller's pull-up
    on the CMD line (however strong that is - it's undocumented) engaged at
    all times.
  * Time a dummy command in order to calculate the speed of the input clock
    to the SD controller block (there doesn't appear to be any way to read
    its speed directly!) This is necessary because recent versions of the
    firmware have not only changed the default clock speed, but even made it
    a user-configurable option in config.txt. It's very important that we
    know how fast it is - if we set the dividers so SDCLK is too slow, then
    the workaround for the register write bug won't work, too fast and we
    overclock the cards, potentially damaging them.
  * Re-enable high speed mode. As long as we don't use the High Speed Enable
    bit in Host Control 1 (see change in SDIODriver 0.03) this seems to work
    for me.
Admin:
  Tested against my collection of test cards on a Raspberry Pi with the
  firmware from the 2012-06-22 commit on github, and with
  init_emmc_clock=100000000 in config.txt (though other values, or the
  absence of that line, or the entire file, should also work). The only
  issues I had appeared to be due to mechanical problems with the SD socket,
  and went away after the card was reseated one or more times.

Version 0.10. Tagged as 'BCM2835-0_10'
@
text
@d59 3
d66 9
a74 8
GPIO_DAT3       *       53
GPIO_DAT2       *       52
GPIO_DAT1       *       51
GPIO_DAT0       *       50
GPIO_CMD        *       49  ; needs pull-up iff in ID mode
GPIO_CLK        *       48
GPIO_CD         *       47  ; needs pull-up; active low
GPIO_STATUS_LED *       16  ; active low
d294 1
a294 1
        HALDeviceField Activate
d315 2
a316 2
SDHCI   HALDeviceField SetActivity
SDHCI   HALDeviceField GetCardDetect
d331 8
d344 1
a344 1

d351 1
d354 8
d462 1
a462 1
Activate ROUT
d477 1
a477 1
        MOV     a1, #GPIO_CD
d480 1
a480 1
        MOV     a1, #GPIO_CD
d483 1
a483 1
        MOV     a1, #GPIO_STATUS_LED
d486 1
a486 1
        MOV     a1, #GPIO_STATUS_LED
d489 15
d505 9
d740 1
a740 1
SetActivity ROUT
d749 16
a764 1
        MOV     a1, #GPIO_STATUS_LED
d770 1
a770 1
GetCardDetect ROUT
d775 1
a775 1
        MOV     a1, #GPIO_CD
d784 6
@


1.1
log
@  SD support, and miscellaneous other changes
Detail:
  * Bugfix to HAL_FIQDisableAll - it wasn't clearing the FIQ register (would
    only have caused trouble in practice if the same device was subsequently
    enabled as an IRQ).
  * Added a load of memory barriers to s.Interrupts and s.Timers to conform
    to the requirement stated in 1.3 of the datasheet.
  * Added a HAL device for the Arasan SDHCI controller. Note that this does
    not currently work reliably, and results vary from card to card. High
    speed support is currently disabled until we are able to verify that it
    works reliably.
  * Added a sprinkling of "GET Hdr:ListOpts" because the space reserved for
    the SDHCI HAL device in hdr.StaticWS is determined by including
    Hdr:HALDevice and Hdr:SDHCIDevice, which need it.
  * When support for saving "CMOS" to the SD card is added, the ROM image
    file (kernel.img) is the only one we can count on the bootloader
    installing in memory, so I think we're going to have to work using the
    table in s.CMOS. Broadcom seems to like messing around with the space
    just after the processor vector table, so rather than adding a pointer
    to the table there, I've opted to mark it using a magic word.
Admin:
  Tested on a Raspberry Pi - as noted above, there are reliability issues.

Version 0.09. Tagged as 'BCM2835-0_09'
@
text
@a51 3
; Frequency of the clock which we divide to produce SDCLK - found experimentally
INPUT_CLK_FREQ_KHZ *    40000 ; in kHz (period = 25 ns)

d90 5
d104 3
d125 136
d305 1
a305 1
SDHCI   HALDeviceField SetBusMode
a318 1

d320 2
d469 19
d555 1
a555 2
;        LDR     a1, =CAP_VS33 :OR: CAP_HSS :OR: CAP_MBL_1024
        LDR     a1, =CAP_VS33 :OR: CAP_MBL_1024 ; until we're confident HS works, stay at standard speed
a559 14
SetBusMode ROUT
        Push    "sb,lr"
        DoMemBarrier lr ; switch to GPIO peripheral
        
        SUB     sb, a1, #:INDEX:SDHCIDevice
        TEQ     a3, #0
        MOVEQ   a2, #GPIO_PUD_OFF
        MOVNE   a2, #GPIO_PUD_UP
        MOV     a1, #GPIO_CMD
        BL      GPIO_SetPull

        DoMemBarrier lr ; back to SDHCI peripheral
        Pull    "sb,pc"

d573 1
a573 1
        LDR     ip, =INPUT_CLK_FREQ_KHZ - 1
d575 1
d585 1
a585 1
        LDR     ip, =INPUT_CLK_FREQ_KHZ
d691 1
a691 1
        LDR     a2, =INPUT_CLK_FREQ_KHZ
d698 1
a698 1
        SUB     sb, a1, #:INDEX:SDHCIDevice        
d713 1
a713 1
        SUB     sb, a1, #:INDEX:SDHCIDevice        
@


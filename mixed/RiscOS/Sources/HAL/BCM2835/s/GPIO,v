head	1.12;
access;
symbols
	Pi3APlus_merge:1.11.2.1
	BCM2835-0_75-1:1.11.2.1
	Pi3APlus:1.11.0.2
	Pi3APlus_bp:1.11
	BCM2835-0_76:1.11
	BCM2835-0_75-1_70_2_4:1.9.2.2
	BCM2835-0_75:1.11
	BCM2835-0_74:1.10
	BCM2835-0_73-1_70_2_3:1.9.2.1
	BCM2835-0_73:1.10
	BCM2835-0_72:1.10
	BCM2835-0_71-1_70_2_2:1.9.2.1
	BCM2835-0_71:1.10
	BCM2835-0_70-1_70_2_1:1.9
	SMP:1.9.0.2
	SMP_bp:1.9
	BCM2835-0_70:1.9
	BCM2835-0_69:1.8
	BCM2835-0_68:1.8
	BCM2835-0_67:1.8
	BCM2835-0_66:1.7
	BCM2835-0_65:1.6
	BCM2835-0_64:1.6
	BCM2835-0_63:1.6
	BCM2835-0_62:1.6
	BCM2835-0_61:1.6
	BCM2835-0_60:1.6
	BCM2835-0_59:1.6
	BCM2835-0_58:1.6
	BCM2835-0_57:1.6
	BCM2835-0_56:1.6
	BCM2835-0_55:1.6
	BCM2835-0_53:1.6
	BCM2835-0_52:1.6
	BCM2835-0_51:1.6
	BCM2835-0_50:1.5
	BCM2835-0_49:1.5
	BCM2835-0_48:1.5
	BCM2835-0_47:1.5
	BCM2835-0_46:1.5
	BCM2835-0_45:1.5
	BCM2835-0_44:1.5
	BCM2835-0_43:1.4
	BCM2835-0_42:1.4
	BCM2835-0_41:1.4
	BCM2835-0_40:1.4
	BCM2835-0_39:1.4
	BCM2835-0_38:1.4
	BCM2835-0_37:1.4
	BCM2835-0_36:1.3
	BCM2835-0_35:1.3
	BCM2835-0_34:1.2
	BCM2835-0_33:1.2
	BCM2835-0_32:1.2
	BCM2835-0_31:1.2
	BCM2835-0_30:1.2
	BCM2835-0_29:1.2
	BCM2835-0_28:1.2
	BCM2835-0_27:1.2
	BCM2835-0_26:1.2
	BCM2835-0_25:1.2
	BCM2835-0_24:1.2
	BCM2835-0_23:1.2
	BCM2835-0_22:1.2
	BCM2835-0_21:1.1
	BCM2835-0_20:1.1
	BCM2835-0_19:1.1
	BCM2835-0_18:1.1
	BCM2835-0_17:1.1;
locks; strict;
comment	@# @;


1.12
date	2018.10.26.19.37.02;	author bavison;	state Exp;
branches;
next	1.11;
commitid	dalYNopD32JgovXA;

1.11
date	2018.03.21.20.59.45;	author rsprowson;	state Exp;
branches
	1.11.2.1;
next	1.10;
commitid	dMUGJ50rw57bTmvA;

1.10
date	2017.07.27.20.01.00;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	977gob8GZGC5bU0A;

1.9
date	2017.05.14.08.17.45;	author rsprowson;	state Exp;
branches
	1.9.2.1;
next	1.8;
commitid	gi5N3Yaapd9zFkRz;

1.8
date	2017.02.11.15.29.57;	author rool;	state Exp;
branches;
next	1.7;
commitid	zDDt6chYlHWb1yFz;

1.7
date	2017.01.20.22.11.34;	author jlee;	state Exp;
branches;
next	1.6;
commitid	XiXvH3kRV0JNWKCz;

1.6
date	2016.01.08.21.37.44;	author jlee;	state Exp;
branches;
next	1.5;
commitid	7xtchPkzB0cvUaQy;

1.5
date	2015.02.16.20.06.55;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	QOtNRBLzpUD3Tgay;

1.4
date	2014.10.09.07.14.18;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	2ULTXIlzcLC4NuTx;

1.3
date	2014.07.14.09.12.49;	author bavison;	state Exp;
branches;
next	1.2;
commitid	LsZUP34QhmC7fkIx;

1.2
date	2012.09.08.12.46.13;	author jlee;	state Exp;
branches;
next	1.1;
commitid	B5V3jq9teWHw5Jjw;

1.1
date	2012.08.02.00.43.32;	author jlee;	state Exp;
branches;
next	;
commitid	p73b1WEma91lhUew;

1.11.2.1
date	2018.10.26.19.31.37;	author bavison;	state Exp;
branches;
next	;
commitid	HzYe59LD1XidmvXA;

1.9.2.1
date	2017.07.31.22.18.17;	author jlee;	state Exp;
branches;
next	1.9.2.2;
commitid	VmVokWQ7fiZsOq1A;

1.9.2.2
date	2018.07.07.14.12.57;	author jlee;	state Exp;
branches;
next	;
commitid	rGMJuwVBIwKoadJA;


desc
@@


1.12
log
@Merge branch Pi3APlus to trunk

Not tagged
@
text
@;
; Copyright (c) 2012, RISC OS Open Ltd
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met: 
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in the
;       documentation and/or other materials provided with the distribution.
;     * Neither the name of RISC OS Open Ltd nor the names of its contributors
;       may be used to endorse or promote products derived from this software
;       without specific prior written permission.
; 
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.
;

        AREA    |ARM$$code|, CODE, READONLY, PIC

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Proc
        GET     hdr.BCM2835
        GET     hdr.StaticWS
        GET     hdr.CastleMacros

        EXPORT  GPIO_InitDevices
        EXPORT  HAL_PlatformName
        IMPORT  memcpy
        IMPORT  HAL_CounterDelay

        MACRO
$class  HALDeviceField $field, $value
        LCLS    myvalue
      [ "$value" = ""
myvalue SETS    "$field"
      |
myvalue SETS    "$value"
      ]
        ASSERT  . - %A0 = HALDevice_$class$field
     [ ?HALDevice_$class$field = 2
        DCW     $myvalue
   ELIF ?HALDevice_$class$field = 4
        DCD     $myvalue
      |
        %       ?HALDevice_$class$field
      ]
        MEND

        MACRO
        FuncSelectTable $limit
        LCLA    pin
        LCLA    grp
        LCLA    reg
pin     SETA    0
        WHILE pin <= $limit 
reg     SETA    pin / 10                ; 10 pins per register
grp     SETA    pin % 10                ; 3 bits per pin
        DCB     grp * 3
        DCB     GPFSel0 + (reg * 4)
pin     SETA    pin + 1
        WEND
        MEND

        GBLA    PinDef_List0
        GBLA    PinDef_List1
        GBLA    PinDef_List2
        GBLA    PinDef_List3
        GBLA    PinDef_List4
        GBLA    PinDef_List5
        GBLA    PinDef_Number
        GBLA    PinDef_List
        GBLA    PinDef_Alts
        ; The BCM2835 has a maximum of 6 alternates
AltGPI  *       2_000
AltGPO  *       2_001
Alt0    *       2_100
Alt1    *       2_101
Alt2    *       2_110
Alt3    *       2_111
Alt4    *       2_011
Alt5    *       2_010

        MACRO
        PinStart $pin, $io
PinDef_Number SETA $pin :AND: &1F
      [ ("$io" = "IO") :LOR: ("$io" = "OI")
PinDef_Number SETA PinDef_Number :OR: GPIOEnumerate_PinFlags_Output :OR: GPIOEnumerate_PinFlags_Input
      ]
      [ "$io" = "I"
PinDef_Number SETA PinDef_Number :OR: GPIOEnumerate_PinFlags_Input
      ]
      [ "$io" = "O"
PinDef_Number SETA PinDef_Number :OR: GPIOEnumerate_PinFlags_Output
      ]
PinDef_List0  SETA GPIOEnumerate_GroupListEnd
PinDef_List1  SETA GPIOEnumerate_GroupListEnd
PinDef_List2  SETA GPIOEnumerate_GroupListEnd
PinDef_List3  SETA GPIOEnumerate_GroupListEnd
PinDef_List4  SETA GPIOEnumerate_GroupListEnd
PinDef_List5  SETA GPIOEnumerate_GroupListEnd
PinDef_List   SETA 0
PinDef_Alts   SETA 0
        MEND

        MACRO
        PinBelongsTo $type, $num, $alt
        ASSERT $alt < 32
        ASSERT $num < 256
        ASSERT $type < 65536
        LCLS var
var     SETS "PinDef_List" :CC: (:STR:PinDef_List:RIGHT:1)
$var    SETA ($num) :OR: ($alt :SHL: 8) :OR: ($type :SHL: 16)
PinDef_List SETA PinDef_List + 1
PinDef_Alts SETA PinDef_Alts :OR (1 :SHL: $alt)
        MEND

        MACRO
        PinEnd
        LCLA count
        LCLS var
count   SETA 0
        ; Private word to make searching easier
        DCD  PinDef_List
        ; Always these words
        DCB  PinDef_Number, 0, 0, 0
        DCD  PinDef_Alts
        ; Then dump up to 6 alternates
        WHILE count < PinDef_List
var     SETS "PinDef_List" :CC: (:STR:count:RIGHT:1)
        DCD $var
count   SETA count + 1
        WEND
        ; Terminator
        DCD  GPIOEnumerate_GroupListEnd
        MEND
 
; GPIO structures
                  ^ 0
                  # HALDevice_GPIO_Size_1_0
WkspType          # 4                   ; GPIORevision_RaspberryPi type
WkspPullEnable    # 4                   ; Soft copies
WkspPullDirection # 4                   ; Soft copies
WkspCopySB        # 4
Wksp_GPIO_Size    # 0
                  ASSERT ?GPIO0Device = Wksp_GPIO_Size
                  ASSERT ?GPIO1Device = Wksp_GPIO_Size

; Template for GPIO interface

GPIOTemplate
0
        HALDeviceField Type,               HALDeviceType_Comms + HALDeviceComms_GPIO
        HALDeviceField ID,                 HALDeviceID_GPIO_BCM2835
        HALDeviceField Location,           HALDeviceBus_Sys + HALDeviceSysBus_AHB ; Guess
        HALDeviceField Version,            &10000 ; API 1.0
        HALDeviceField Description,        0 ; Filled in at runtime
        HALDeviceField Address,            0 ; Filled in at runtime
        HALDeviceField Reserved1,          0
        HALDeviceField Activate,           GPIO_Activate
        HALDeviceField Deactivate,         GPIO_Deactivate
        HALDeviceField Reset,              GPIO_Reset
        HALDeviceField Sleep,              GPIO_Sleep
        HALDeviceField Device,             -1
        HALDeviceField TestIRQ,            0
        HALDeviceField ClearIRQ,           0
        HALDeviceField Reserved2,          0
GPIO    HALDeviceField Ports,              GPIOPorts
GPIO    HALDeviceField Number,             0 ; also overwritten for extra ports
GPIO    HALDeviceField Enumerate,          GPIOEnumerate
GPIO    HALDeviceField SetDataBits,        GPIOSetDataBits
GPIO    HALDeviceField ClearDataBits,      GPIOClearDataBits
GPIO    HALDeviceField ToggleDataBits,     GPIOToggleDataBits
GPIO    HALDeviceField ReadDataBits,       GPIOReadDataBits
GPIO    HALDeviceField DataDirection,      GPIODataDirection
GPIO    HALDeviceField ReadMode,           GPIOReadMode
GPIO    HALDeviceField WriteMode,          GPIOWriteMode
GPIO    HALDeviceField PullControl,        GPIOPullControl
GPIO    HALDeviceField PullDirection,      GPIOPullDirection
GPIO    HALDeviceField EdgeControl,        GPIOEdgeControl
GPIO    HALDeviceField EdgePollStatus,     GPIOEdgePollStatus
        ASSERT  . - %A0 = HALDevice_GPIO_Size_1_0

GPIO_Description_0
        = "Raspberry Pi GPIO interface pins 0-31", 0
        ALIGN
GPIO_Description_1
        = "Raspberry Pi GPIO interface pins 32-63", 0
        ALIGN

                                 ^       0
GPIORevision_RaspberryPi_B_1     #       1 ; Model B Rev 1.0
GPIORevision_RaspberryPi_B_2     #       1 ; Model B Rev 2.0
GPIORevision_RaspberryPi_A_2     #       1 ; Model A Rev 2.0
GPIORevision_RaspberryPi_BPlus   #       1 ; Model B+
GPIORevision_RaspberryPi_C_1     #       1 ; Model CM1
GPIORevision_RaspberryPi_C_3     #       1 ; Model CM3
GPIORevision_RaspberryPi_APlus   #       1 ; Model A+
GPIORevision_RaspberryPi_Mk2_B   #       1 ; Model Pi 2 B
GPIORevision_RaspberryPi_Zero    #       1 ; Model Zero
GPIORevision_RaspberryPi_ZeroW   #       1 ; Model ZeroW
GPIORevision_RaspberryPi_Mk3_B   #       1 ; Model Pi 3 B
GPIORevision_RaspberryPi_Mk3_BPlus #     1 ; Model Pi 3 B+
GPIORevision_RaspberryPi_Mk3_APlus #     1 ; Model Pi 3 A+
GPIORevision_RaspberryPi_Max     #       0

Name_B_1 = "Raspberry Pi B PCB 1.0", 0
Name_B_2 = "Raspberry Pi B PCB 2.0", 0
Name_A_2 = "Raspberry Pi A", 0
Name_BPlus = "Raspberry Pi B+", 0
Name_C_1 = "Raspberry Pi Compute Module 1", 0
Name_C_3 = "Raspberry Pi Compute Module 3", 0
Name_APlus = "Raspberry Pi A+", 0
Name_Mk2_B = "Raspberry Pi 2 Model B", 0
Name_Zero = "Raspberry Pi Zero", 0
Name_ZeroW = "Raspberry Pi Zero W", 0
Name_Mk3_B = "Raspberry Pi 3 Model B", 0
Name_Mk3_BPlus = "Raspberry Pi 3 Model B+", 0
Name_Mk3_APlus = "Raspberry Pi 3 Model A+", 0
Name_Unknown = "Raspberry Pi Unknown", 0
        ALIGN

GPIO_Board_Names_Table ; same order as GPIORevision_RaspberryPi types
        DCD     Name_B_1
        DCD     Name_B_2
        DCD     Name_A_2
        DCD     Name_BPlus
        DCD     Name_C_1
        DCD     Name_C_3
        DCD     Name_APlus
        DCD     Name_Mk2_B
        DCD     Name_Zero
        DCD     Name_ZeroW
        DCD     Name_Mk3_B
        DCD     Name_Mk3_BPlus
        DCD     Name_Mk3_APlus
        ASSERT  (.-GPIO_Board_Names_Table) :SHR: 2 = GPIORevision_RaspberryPi_Max

; Lookup table to determine board type (old style)
; Ref: http://elinux.org/RPi_HardwareHistory#Board_Revision_History
        MACRO
        BoardType $model, $minrev, $maxrev, $type
        DCD $model
        DCD $minrev
        DCD $maxrev
        DCD GPIORevision_RaspberryPi_$type
        MEND

GPIO_BoardTypes
        BoardType 0, &02, &03, B_1
        BoardType 0, &04, &06, B_2
        BoardType 0, &07, &09, A_2
        BoardType 0, &0d, &0f, B_2
        BoardType 0, &10, &10, BPlus
        BoardType 0, &11, &11, C_1
        BoardType 0, &12, &12, APlus
        BoardType 0, &13, &13, BPlus
        BoardType 0, &14, &14, C_1
        BoardType 0, &15, &15, APlus
GPIO_BoardTypes_End

; Lookup table to determine board type (new style)
; Only the memory amount, model, and revision are significant in this table.
GPIO_Board_Conversion_Table
        DCD     BoardRevision_Mem_256M+BoardRevision_Model_B+(1:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_B_1
        DCD     BoardRevision_Mem_256M+BoardRevision_Model_B+(2:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_B_2
        DCD     BoardRevision_Mem_256M+BoardRevision_Model_A+(2:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_A_2
        DCD     BoardRevision_Mem_512M+BoardRevision_Model_B+(2:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_BPlus
        DCD     BoardRevision_Mem_512M+BoardRevision_Model_Compute+(1:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_C_1
        DCD     BoardRevision_Mem_256M+BoardRevision_Model_APlus+(1:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_APlus
        DCD     BoardRevision_Mem_512M+BoardRevision_Model_APlus+(1:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_APlus
        DCD     BoardRevision_Mem_512M+BoardRevision_Model_BPlus+(2:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_BPlus
        DCD     BoardRevision_Mem_1G+BoardRevision_Model_B2+(1:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_Mk2_B
        DCD     BoardRevision_Mem_1G+BoardRevision_Model_B2+(2:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_Mk2_B
        DCD     BoardRevision_Mem_512M+BoardRevision_Model_Zero+(2:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_Zero
        DCD     BoardRevision_Mem_512M+BoardRevision_Model_Zero+(3:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_Zero
        DCD     BoardRevision_Mem_1G+BoardRevision_Model_B3+(2:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_Mk3_B
        DCD     BoardRevision_Mem_1G+BoardRevision_Model_Compute3+(0:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_C_3
        DCD     BoardRevision_Mem_512M+BoardRevision_Model_ZeroW+(1:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_ZeroW
        DCD     BoardRevision_Mem_1G+BoardRevision_Model_B3Plus+(3:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_Mk3_BPlus
        DCD     BoardRevision_Mem_512M+BoardRevision_Model_A3Plus+(0:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_Mk3_APlus
        DCD     &FF

        ; Initialise our HAL devices
GPIO_InitDevices 
        Entry   "v1"

        ; Copy dev struct to WS & fill in the non template items
        ADRL    a1, GPIO0Device
        ADR     a2, GPIOTemplate
        MOV     a3, #HALDevice_GPIO_Size_1_0
        BL      memcpy
        
        MOV     a2, #0
        STR     a2, [a1, #WkspPullEnable]
        STR     a2, [a1, #WkspPullDirection]
        STR     sb, [a1, #WkspCopySB]

        ADRL    a2, GPIO_Description_0
        STR     a2, [a1, #HALDevice_Description]
        LDR     a4, PeriBase
        ADD     a4, a4, #GPIO_Base
        STR     a4, [a1, #HALDevice_Address]
        MOV     a2, #0
        STR     a2, [a1, #HALDevice_GPIONumber]

        ; Copy dev struct to WS & fill in the non template items
        ADRL    a1, GPIO1Device
        ADR     a2, GPIOTemplate
        MOV     a3, #HALDevice_GPIO_Size_1_0
        BL      memcpy
        
        MOV     a2, #0
        STR     a2, [a1, #WkspPullEnable]
        STR     a2, [a1, #WkspPullDirection]
        STR     sb, [a1, #WkspCopySB]

        ADRL    a2, GPIO_Description_1
        STR     a2, [a1, #HALDevice_Description]
        LDR     a4, PeriBase
        ADD     a4, a4, #GPIO_Base
        STR     a4, [a1, #HALDevice_Address]
        MOV     a2, #1
        STR     a2, [a1, #HALDevice_GPIONumber]

        ; Only register if it's a model known to us
        BL      GPIO_Get_Platform
        CMP     a1, #-1
        EXIT    EQ
        MOV     v1, a1

        ; Found a match, add devices to list
        MOV     a1, #0
        ADRL    a2, GPIO0Device
        STR     v1, [a2, #WkspType]
      [ :LNOT: JTAG ; Play it safe, we don't want software messing with the JTAG GPIOs
        CallOS  OS_AddDevice            ; register device0
      ]

        MOV     a1, #0
        ADRL    a2, GPIO1Device
        STR     v1, [a2, #WkspType]
      [ :LNOT: JTAG ; Play it safe, we don't want software messing with the JTAG GPIOs
        CallOS  OS_AddDevice            ; register device1
      ]
        EXIT

GPIO_Activate
        MOV     a1, #1
GPIO_Deactivate
GPIO_Reset
        MOV     pc, lr

GPIO_Sleep
        MOV     a1, #0
        MOV     pc, lr

; Name the platform for debug dumps and similar
; Return a1 = zero terminated string
HAL_PlatformName
        Entry
        BL      GPIO_Get_Platform
        CMP     a1, #-1
        ADREQL  a1, Name_Unknown
        ADRNE   a2, GPIO_Board_Names_Table
        LDRNE   a1, [a2, a1, LSL #2]
        EXIT

; Determine which platform this is
; Return a1 = enumerated platform number (GPIORevision_RaspberryPi type)
;             or -1 if unknown
GPIO_Get_Platform
        Entry   "v1-v5"
        ADR     v1, GPIO_BoardTypes
        LDR     v2, Board_Model
        LDR     v3, Board_Revision
        ADR     ip, GPIO_BoardTypes_End
        ADR     v5, GPIO_Board_Names_Table

        TST     v3, #BoardRevision_NewScheme
        BNE     %FT20                   ; new decode
10
        CMP     v1, ip
        MOVHS   a1, #-1
        EXIT    HS                      ; unknown model, exit
        LDMIA   v1!, {a1-a4}
        CMP     a1, v2                  ; model match?
        BNE     %BT10
        CMP     a2, v3
        CMPLS   v3, a3                  ; revision within range?
        MOVLS   a1, a4
        EXIT    LS                      ; match a1 = GPIORevision_RaspberryPi type
        B       %BT10
20
        ADR     a2, GPIO_Board_Conversion_Table
        LDR     a3, =BoardRevision_Model_Mask+BoardRevision_Mem_Mask+BoardRevision_Rev_Mask
        AND     a1, v3, a3
30
        LDR     a4, [a2], #4
        CMP     a4, #&FF
        MOVEQ   a1, #-1
        EXIT    EQ                      ; unknown model, exit
        CMP     a4, a1
        LDREQ   a1, [a2]
        ADDNE   a2, a2, #4
        EXIT    EQ                      ; match a1 = GPIORevision_RaspberryPi type
        B       %BT30

; int GPIOSetDataBits(struct gpiodevice *, int bits)
; Enter with a1 = device struct pointer
;            a2 = any bit set will cause that pin to be set
; Return     a1 = previous value
GPIOSetDataBits
        MOV     a3, #GPSet0
        B       GPIO_Data_Common        ; tail call

; int GPIOClearDataBits(struct gpiodevice *, int bits)
; Enter with a1 = device struct pointer
;            a2 = any bit set will cause that pin to be cleared
; Return     a1 = previous value
GPIOClearDataBits
        MOV     a3, #GPClr0
        B       GPIO_Data_Common        ; tail call

; int GPIOReadDataBits(struct gpiodevice *)
; Enter with a1 = device struct pointer
; Return     a1 = previous value
GPIOReadDataBits
        MOV     a3, #GPLev0
        B       GPIO_Data_Common        ; tail call

; void GPIOToggleDataBits(struct gpiodevice *, int bits)
; Enter with a1 = device struct pointer
;            a2 = any bit set will cause that pin to be toggled from its current value
GPIOToggleDataBits
        Entry   "v1-v4"
        MOVS    v2, a2
        EXIT    EQ                      ; nothing to do
        MOV     v1, a1

        PHPSEI  v4                      ; go atomic

        BL      GPIOReadDataBits
        MOV     v3, a1

        ANDS    a2, v2, v3              ; only our bits
        MOVNE   a1, v1
        BLNE    GPIOClearDataBits

        MVN     v3, v3                  ; invert bits
        ANDS    a2, v2, v3              ; only our bits
        MOVNE   a1, v1
        BLNE    GPIOSetDataBits

        PLP     v4                      ; restore interrupt state
        EXIT

; int GPIODataDirection(struct gpiodevice *, int pins, int dir)
; Enter with a1 = device struct pointer
;            a2 = bits to change
;            a3 = direction to set the bits to (1=input 0=output)
; Return     a1 = previous data direction bits (or current if pins=0)
GPIODataDirection
        Entry   "v1-v5"

        ; On the Pi the data direction is scattered across multiple 
        ; registers, and changing direction also needs a mode change.
        ; They are, however, individually controllable (groups of 1 pin).
        MOV     v1, a1
        MOV     v2, a2
        MOV     v3, a3

        MOV     v4, #0                  ; pin to change
        MOV     v5, #0                  ; old direction bits
10
        MOV     v5, v5, LSR #1
        MOVS    v2, v2, LSR #1
        MOVCC   a3, #-1
        BCC     %FT20                   ; leave alone

        TST     v3, #1
        MOVNE   a3, #AltGPI             ; input
        MOVEQ   a3, #AltGPO             ; output
20
        MOV     a2, v4
        MOV     a1, v1
        BL      GPIO_Mode_Common
        TEQ     a1, #AltGPI             ; previously input?
        ORREQ   v5, v5, #1:SHL:31
        MOV     v3, v3, LSR #1
        ADD     v4, v4, #1
        CMP     v4, #32
        BNE     %BT10

        MOV     a1, v5
        EXIT

; struct onepin *GPIOEnumerate(struct gpiodevice *, int *carryon)
; Enter with a1 = device struct pointer
;            a2 = pointer to continuation value (0 to start)
; Return     a1 = pointer to pin info for one more pin
;            continuation value updated (-1 if no more)
GPIOEnumerate
        Entry   "v1-v3"
        LDR     v1, [a1, #WkspType]
        LDR     a1, [a1, #HALDevice_GPIONumber]
        ADRL    a4, GPIOFreeToUse
        MOV     ip, #GPIOPorts * 4
        MLA     a4, v1, ip, a4          ; address of GPIOFreeToUse for this type
        LDR     v1, [a4, a1, LSL #2]    ; mask of valid on this port for this target

        LDR     a3, [a2]                ; just use the continuation value as a bit position
        CMP     a3, #32
        BCS     %FT60                   ; invalid always

        CMP     a3, #0
        BNE     %FT20                   ; not the start condition

        MOVS    ip, v1
        BEQ     %FT60                   ; no valid pins
10
        ; find first set
        MOVS    ip, ip, LSR #1          
        ADDCC   a3, a3, #1
        BCC     %BT10
20
        MOV     ip, #1
        TST     v1, ip, LSL a3
        BEQ     %FT60                   ; invalid on this target

        ADRL    v2, GPIOPortTables
        LDR     v2, [v2, a1, LSL #2]    ; start of pin data
        MOV     v3, #0
30
        LDR     ip, [v2], #4            ; fetch & skip private word
        CMP     ip, #-1
        BEQ     %FT60                   ; no more

        TEQ     v3, a3
        MOVEQ   a1, v2
        BEQ     %FT40

        ADD     v2, v2, #GPIOEnumerate_GroupList ; account for fixed items
        ADD     ip, ip, #1              ; account for list terminator
        ASSERT  GPIOGroupList_Size = 4
        ADD     v2, v2, ip, LSL #2      ; account for list entries
        ADD     v3, v3, #1
        B       %BT30
40
        ; find next set
        ADD     v3, v3, #1
        CMP     v3, #32
        MOVNES  v1, v1, LSR v3
        BEQ     %FT70
50
        MOVS    v1, v1, LSR #1
        ADDCC   v3, v3, #1
        BCC     %BT50

        STR     v3, [a2]
        EXIT
60
        MOV     a1, #0                  ; nothing
70
        MOV     ip, #-1                 ; no more
        STR     ip, [a2]
        EXIT

; enum HAL_GPIOReadMode(struct gpiodevice *, int pin)
; Enter with a1 = device struct pointer
;            a2 = pin (singular) to change
; Return     a1 = current mode
GPIOReadMode
        MOV     a3, #-1        
        B       GPIO_Mode_Common        ; tail call

; enum GPIOWriteMode(struct gpiodevice *, int pin, enum useage)
; Enter with a1 = device struct pointer
;            a2 = pin (singular) to change
;            a3 = new mode (opaque value from Enumerate)
; Return     a1 = previous mode
GPIOWriteMode
        B       GPIO_Mode_Common        ; tail call

; int GPIOPullControl(struct gpiodevice *, int pins, int enable)
; Enter with a1 = device struct pointer
;            a2 = bits to change
;            a3 = pull resistor enables for those pins
; Return     a1 = previous pull enable bits (or current if pins=0)
GPIOPullControl
        Entry   "v1"
        LDR     v1, [a1, #WkspPullEnable]
        AND     a3, a3, a2              ; discard spurious set bits
        BIC     a2, v1, a2
        ORR     a2, a3, a2              ; new soft copy
        STR     a2, [a1, #WkspPullEnable]
        TEQ     v1, a2
        MOVEQ   a1, v1                  ; no enables changed
        EXIT    EQ

        LDR     a3, [a1, #WkspPullDirection]
        BL      GPIO_Pull_Common
        MOV     a1, v1
        EXIT

; int GPIOPullDirection(struct gpiodevice *, int pins, int up)
; Enter with a1 = device struct pointer
;            a2 = bits to change
;            a3 = bits to set as pull up else pull down
; Return     a1 = previous pull direction bits (or current if pins=0)
GPIOPullDirection
        Entry   "v1"
        LDR     v1, [a1, #WkspPullDirection]
        AND     a3, a3, a2              ; discard spurious set bits
        BIC     a2, v1, a2
        ORR     a2, a3, a2              ; new soft copy
        STR     a2, [a1, #WkspPullDirection]
        LDR     a4, [a1, #WkspPullEnable]
        AND     a2, a2, a4
        AND     a3, v1, a4
        TEQ     a2, a3
        MOVEQ   a1, v1                  ; no enabled sense change
        EXIT    EQ

        MOV     a3, a2
        MOV     a2, a4
        BL      GPIO_Pull_Common
        MOV     a1, v1
        EXIT

; void GPIOEdgeControl(struct gpiodevice *, int pins, int *enable, int *edge, int *risehigh)
; Enter with a1 = device struct pointer
;            a2 = bits to change
;            a3 = pointer to bits to enable detection on
;            a4 = pointer to bits set for edge mode (else level)
;        [sp+0] = pointer to bits set to detect on rising/high (else falling/low)
GPIOEdgeControl
        LDR     ip, [sp, #0]

        Entry   "v1-v5"
        Push    "a3-a4, ip"

        LDR     v1, [a1, #HALDevice_Address]
        LDR     a1, [a1, #HALDevice_GPIONumber]
        ASSERT  GPREDE0 + 4 = GPREDE1
        ASSERT  GPFEDE0 + 4 = GPFEDE1
        ASSERT  GPHIDE0 + 4 = GPHIDE1
        ASSERT  GPLODE0 + 4 = GPLODE1
        ADD     v1, v1, a1, LSL #2

        LDR     a3, [a3]                ; pick up new values
        LDR     a4, [a4]
        LDR     ip, [ip]

        PHPSEI  v2                      ; go atomic

        LDR     v3, [v1, #GPREDE0]
        LDR     a1, [v1, #GPFEDE0]
        MOV     v5, v3                  ; rising = rising
        ORR     v4, v3, a1              ; OR(rising,falling) = edge
        ORR     v3, v3, a1              ; OR(rising,falling) = edge enable
        LDR     lr, [v1, #GPHIDE0]
        LDR     a1, [v1, #GPLODE0]
        ORR     v5, v5, lr              ; OR(rising,high) = rising/high
        ORR     a1, a1, lr
        ORR     v3, v3, a1              ; OR(edge enable,OR(high,low)) = enable
        TEQ     a2, #0
        BEQ     %FT10

        LDR     a1, [v1, #GPREDE0]
        BIC     a1, a1, a2              ; disable by default
        AND     lr, a3, a4
        AND     lr, lr, ip             
        ORR     a1, a1, lr              ; AND(enable,edge,rising) = rising
        STR     a1, [v1, #GPREDE0]

        LDR     a1, [v1, #GPFEDE0]
        BIC     a1, a1, a2              ; disable by default
        AND     lr, a3, a4
        BIC     lr, lr, ip             
        ORR     a1, a1, lr              ; AND(enable,edge,NOT(rising)) = falling
        STR     a1, [v1, #GPFEDE0]

        LDR     a1, [v1, #GPHIDE0]
        BIC     a1, a1, a2              ; disable by default
        BIC     lr, a3, a4
        AND     lr, lr, ip             
        ORR     a1, a1, lr              ; AND(enable,NOT(edge),rising) = high
        STR     a1, [v1, #GPHIDE0]

        LDR     a1, [v1, #GPLODE0]
        BIC     a1, a1, a2              ; disable by default
        BIC     lr, a3, a4
        BIC     lr, lr, ip             
        ORR     a1, a1, lr              ; AND(enable,NOT(edge),NOT(rising)) = low
        STR     a1, [v1, #GPLODE0]
10
        PLP     v2                      ; restore interrupt state

        Pull    "a3-a4, ip"
        STR     v3, [a3]                ; write out previous values
        STR     v4, [a4]
        STR     v5, [ip]
        EXIT

; int GPIOEdgePollStatus(struct gpiodevice *, int collect)
; Enter with a1 = device struct pointer
;            a2 = clear these bits having polled the status
; Return     a1 = states latched in edge/level since last poll
GPIOEdgePollStatus
        MOV     a3, #GPPEDS0
        B       GPIO_Data_Common        ; tail call

; Pin function selection
; Enter with a1 = device pointer
;            a2 = pin (0-31)
;            a3 = mode to set to (or -1 to just read)
; Return     a1 = previous mode, or -1 if invalid request
GPIO_Mode_Common
        Entry   "v1-v5"
        LDR     v2, [a1, #HALDevice_Address]
        LDR     v1, [a1, #WkspType]
        LDR     a1, [a1, #HALDevice_GPIONumber]
        ADR     a4, GPIOFreeToUse
        MOV     ip, #GPIOPorts * 4
        MLA     a4, v1, ip, a4          ; address of GPIOFreeToUse for this type
        LDR     v1, [a4, a1, LSL #2]    ; mask of valid on this port for this target

        MOV     a4, #1
        MOV     a4, a4, LSL a2
        TST     a4, v1
        MOVEQ   a1, #-1
        EXIT    EQ                      ; not a valid pin to change

        MOV     v3, #2_111
        ADD     v4, a2, a1, LSL #5      ; flatten port and pin to 0-63

        ADR     a4, GPIO_FuncSelect_Table
        ADD     a4, a4, v4, LSL #1
        LDRH    a4, [a4]                ; reg/grp pair
        AND     v4, a4, #255            ; grp
        MOV     lr, #2_111              ; mode mask

        PHPSEI  ip                      ; go atomic

        LDR     a2, [v2, a4, LSR #8]
        CMP     a3, #-1                 ; just reading?
        BICNE   a1, a2, lr, LSL v4
        ORRNE   a1, a1, a3, LSL v4
        DataSyncBarrier a3, NE          ; resync before/after peripheral
        STRNE   a1, [v2, a4, LSR #8]

        PLP     ip

        MOV     a1, a2, LSR v4
        AND     a1, a1, #2_111

        EXIT

; Port wide pull resistor modifier
; Enter with a1 = device pointer
;            a2 = enables
;            a3 = sense
GPIO_Pull_Common
        Entry   "v1-v4, sb"
        LDR     v1, [a1, #HALDevice_Address]
        LDR     sb, [a1, #WkspCopySB]
        LDR     a1, [a1, #HALDevice_GPIONumber]
        ASSERT  GPPUDCK0 + 4 = GPPUDCK1
        MOV     a4, #GPPUDCK0
        ADD     v4, a4, a1, LSL #2
        MOV     v2, a2
        MOV     v3, a3

        MOV     a1, #2_00               ; disable pullup/down
        MVNS    a2, v2                  ; NOT(enable) = disable
        BLNE    %FT10

        MOV     a1, #2_01               ; pull down
        MVN     a2, v3
        ANDS    a2, a2, v2              ; AND(NOT(sense),enable) = pull downs
        BLNE    %FT10

        MOV     a1, #2_10               ; pull up
        ANDS    a2, v3, v2              ; AND(sense,enable) = pull ups
        BLNE    %FT10

        MOV     a1, #0                  ; rest
        STR     a1, [v1, #GPPUPDEN]
        STR     a1, [v1, v2]
        EXIT
10
        Push    "a2, lr"
        STR     a1, [v1, #GPPUPDEN]
        MOV     a1, #50                 ; guess
        BL      HAL_CounterDelay
        Pull    "a2, lr"
        STR     a2, [v1, v2]
        MOV     a1, #50                 ; guess
        B       HAL_CounterDelay

; Port wide pin modifier
; Enter with a1 = device pointer
;            a2 = bit set of pins
;            a3 = GPIO peripheral register offset (or GPLev0 to just read)
; Return     a1 = previous value
GPIO_Data_Common
        Entry   "v1-v2"
        LDR     v2, [a1, #HALDevice_Address]
        LDR     a1, [a1, #HALDevice_GPIONumber]
        ASSERT  GPSet0  + 4 = GPSet1
        ASSERT  GPClr0  + 4 = GPClr1
        ASSERT  GPLev0  + 4 = GPLev1
        ASSERT  GPPEDS0 + 4 = GPPEDS1
        ADD     a4, a3, a1, LSL #2
        ADR     v1, GPIOPORT
        LDR     v1, [v1, a1, LSL #2]    ; mask of invalid

        CMP     a3, #GPLev0
        DataSyncBarrier ip              ; resync before/after peripheral
        LDR     a1, [v2, a4]
        AND     a1, a1, v1
        ANDNE   a2, a2, v1              
        STRNE   a2, [v2, a4]
        DataSyncBarrier ip, NE          ; resync before/after peripheral

        EXIT

; Available pins in the GPIO peripheral
GPIOPORT
        DCD     2_11111111111111111111111111111111      ; 31-0
        DCD     2_00000000001111111111111111111111      ; 53-32
GPIOPORTEND
GPIOPorts       *       (GPIOPORTEND-GPIOPORT):SHR:2

; Function Select register offset/bits lookup table
GPIO_FuncSelect_Table
        FuncSelectTable 53
        ALIGN

      [ {FALSE}
; Alt table 8 bytes per port 1st byte = mode 0 etc, &FF = not available
; Ref: section 6.2 of BCM2835 ARM peripherals datasheet
GPIO_Alt_Table
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF,   &FF,   &FF ; 0
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF,   &FF,   &FF ; 1
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF,   &FF,   &FF ; 2
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF,   &FF,   &FF ; 3
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF,   &FF, 2_010 ; 4
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF,   &FF, 2_010 ; 5
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF,   &FF, 2_010 ; 6
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF,   &FF,   &FF ; 7

        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF,   &FF,   &FF ; 8
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF,   &FF,   &FF ; 9
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF,   &FF,   &FF ; 10
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF,   &FF,   &FF ; 11
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF,   &FF, 2_010 ; 12
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF,   &FF, 2_010 ; 13
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF,   &FF, 2_010 ; 14
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF,   &FF, 2_010 ; 15

        DCB     2_000, 2_001,   &FF, 2_101,   &FF, 2_111, 2_011, 2_010 ; 16
        DCB     2_000, 2_001,   &FF, 2_101,   &FF, 2_111, 2_011, 2_010 ; 17
        DCB     2_000, 2_001,   &FF, 2_101,   &FF, 2_111, 2_011, 2_010 ; 18
        DCB     2_000, 2_001,   &FF, 2_101,   &FF, 2_111, 2_011, 2_010 ; 19
        DCB     2_000, 2_001,   &FF, 2_101,   &FF, 2_111, 2_011, 2_010 ; 20
        DCB     2_000, 2_001,   &FF, 2_101,   &FF, 2_111, 2_011, 2_010 ; 21
        DCB     2_000, 2_001,   &FF, 2_101,   &FF, 2_111, 2_011,   &FF ; 22
        DCB     2_000, 2_001,   &FF, 2_101,   &FF, 2_111, 2_011,   &FF ; 23

        DCB     2_000, 2_001,   &FF, 2_101,   &FF, 2_111, 2_011,   &FF ; 24
        DCB     2_000, 2_001,   &FF, 2_101,   &FF, 2_111, 2_011,   &FF ; 25
        DCB     2_000, 2_001,   &FF,   &FF,   &FF, 2_111, 2_011,   &FF ; 26
        DCB     2_000, 2_001,   &FF,   &FF,   &FF, 2_111, 2_011,   &FF ; 27
        DCB     2_000, 2_001, 2_100, 2_101, 2_110,   &FF,   &FF,   &FF ; 28
        DCB     2_000, 2_001, 2_100, 2_101, 2_110,   &FF,   &FF,   &FF ; 29
        DCB     2_000, 2_001,   &FF, 2_101, 2_110,   &FF,   &FF, 2_010 ; 30
        DCB     2_000, 2_001,   &FF, 2_101, 2_110,   &FF,   &FF, 2_010 ; 31

        DCB     2_000, 2_001, 2_100, 2_101,   &FF, 2_111,   &FF, 2_010 ; 32
        DCB     2_000, 2_001, 2_100, 2_101,   &FF, 2_111,   &FF, 2_010 ; 33
        DCB     2_000, 2_001,   &FF, 2_101,   &FF, 2_111,   &FF, 2_010 ; 34
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF,   &FF,   &FF ; 35
        DCB     2_000, 2_001, 2_100, 2_101, 2_110,   &FF,   &FF,   &FF ; 36
        DCB     2_000, 2_001, 2_100, 2_101, 2_110,   &FF,   &FF,   &FF ; 37
        DCB     2_000, 2_001, 2_100, 2_101, 2_110,   &FF,   &FF,   &FF ; 38
        DCB     2_000, 2_001, 2_100, 2_101, 2_110,   &FF,   &FF,   &FF ; 39

        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF, 2_011, 2_010 ; 40
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF, 2_011, 2_010 ; 41
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF, 2_011, 2_010 ; 42
        DCB     2_000, 2_001, 2_100, 2_101,   &FF,   &FF, 2_011, 2_010 ; 43
        DCB     2_000, 2_001, 2_100, 2_101, 2_110,   &FF, 2_011,   &FF ; 44
        DCB     2_000, 2_001, 2_100, 2_101, 2_110,   &FF, 2_011,   &FF ; 45
        DCB     2_000, 2_001,   &FF,   &FF,   &FF,   &FF,   &FF,   &FF ; 46
        DCB     2_000, 2_001,   &FF,   &FF,   &FF,   &FF,   &FF,   &FF ; 47

        DCB     2_000, 2_001,   &FF,   &FF,   &FF,   &FF,   &FF,   &FF ; 48
        DCB     2_000, 2_001,   &FF,   &FF,   &FF,   &FF,   &FF,   &FF ; 49
        DCB     2_000, 2_001,   &FF,   &FF,   &FF,   &FF,   &FF,   &FF ; 50
        DCB     2_000, 2_001,   &FF,   &FF,   &FF,   &FF,   &FF,   &FF ; 51
        DCB     2_000, 2_001,   &FF,   &FF,   &FF,   &FF,   &FF,   &FF ; 52
        DCB     2_000, 2_001,   &FF,   &FF,   &FF,   &FF,   &FF,   &FF ; 53
        ALIGN
      ]

; Available pins per target board
; Ref: http://elinux.org/RPi_BCM2835_GPIOs 
GPIOFreeToUse
        DCD     2_00000011111001101100111110010011      ; B rev 1
        DCD     2_00000000000000000000000000000000
        DCD     2_00001011110001101100111110011100      ; B rev 2
        DCD     2_00000000000000000000000000000000
        DCD     2_00001011110001101100111110011100      ; A rev 2
        DCD     2_00000000000000000000000000000000
        DCD     2_00001111111111111111111111111111      ; B+
        DCD     2_00000000000000000000000000000000
        DCD     2_11111111111111111111111111111111      ; Compute CM1
        DCD     2_00000000000000000111111111111111
        DCD     2_11111111111111111111111111111111      ; Compute CM3
        DCD     2_00000000000000000011111111111111
        DCD     2_00001111111111111111111111111111      ; A+
        DCD     2_00000000000000000000000000000000
        DCD     2_00001111111111111111111111111111      ; 2B
        DCD     2_00000000000000000000000000000000
        DCD     2_00001111111111111111111111111111      ; Zero
        DCD     2_00000000000000000000000000000000
        DCD     2_00001111111111111111111111111111      ; ZeroW
        DCD     2_00000000000000000000000000000000
        DCD     2_00001111111111111111111111111111      ; 3B
        DCD     2_00000000000000000000000000000000
        DCD     2_00001111111111111111111111111111      ; 3B+
        DCD     2_00000000000000000000000000000000

; Pin enumerations
GPIO_Port0_Table
        PinStart     0, IO
        PinBelongsTo GPIOType_GPIO, 0, AltGPI   ; GPIO
        PinBelongsTo GPIOType_I2C, 0, Alt0      ; I2C0 SDA
        PinEnd
        PinStart     1, IO
        PinBelongsTo GPIOType_GPIO, 1, AltGPI   ; GPIO
        PinBelongsTo GPIOType_I2C, 0, Alt0      ; I2C0 SCL
        PinEnd
        PinStart     2, IO
        PinBelongsTo GPIOType_GPIO, 2, AltGPI   ; GPIO
        PinBelongsTo GPIOType_I2C, 1, Alt0      ; I2C1 SDA
        PinEnd
        PinStart     3, IO
        PinBelongsTo GPIOType_GPIO, 3, AltGPI   ; GPIO
        PinBelongsTo GPIOType_I2C, 1, Alt0      ; I2C1 SCL
        PinEnd
        PinStart     4, IO
        PinBelongsTo GPIOType_GPIO, 4, AltGPI   ; GPIO
        PinBelongsTo GPIOType_GPCLK, 0, Alt0    ; GPCLK0
        PinEnd
        PinStart     5, IO
        PinBelongsTo GPIOType_GPIO, 5, AltGPI   ; GPIO
        PinBelongsTo GPIOType_GPCLK, 1, Alt0    ; GPCLK1
        PinEnd
        PinStart     6, IO
        PinBelongsTo GPIOType_GPIO, 6, AltGPI   ; GPIO
        PinBelongsTo GPIOType_GPCLK, 2, Alt0    ; GPCLK2
        PinEnd
        PinStart     7, IO
        PinBelongsTo GPIOType_GPIO, 7, AltGPI   ; GPIO
        PinBelongsTo GPIOType_SPI, 0, Alt0      ; SPI0 CE1
        PinEnd
        PinStart     8, IO
        PinBelongsTo GPIOType_GPIO, 8, AltGPI   ; GPIO
        PinBelongsTo GPIOType_SPI, 0, Alt0      ; SPI0 CE0
        PinEnd
        PinStart     9, IO
        PinBelongsTo GPIOType_GPIO, 9, AltGPI   ; GPIO
        PinBelongsTo GPIOType_SPI, 0, Alt0      ; SPI0 MISO
        PinEnd
        PinStart     10, IO
        PinBelongsTo GPIOType_GPIO, 10, AltGPI  ; GPIO
        PinBelongsTo GPIOType_SPI, 0, Alt0      ; SPI0 MOSI
        PinEnd
        PinStart     11, IO
        PinBelongsTo GPIOType_GPIO, 11, AltGPI  ; GPIO
        PinBelongsTo GPIOType_SPI, 0, Alt0      ; SPI0 SCLK
        PinEnd
        PinStart     12, IO
        PinBelongsTo GPIOType_GPIO, 12, AltGPI  ; GPIO
        PinBelongsTo GPIOType_PWM, 0, Alt0      ; PWM0
        PinEnd
        PinStart     13, IO
        PinBelongsTo GPIOType_GPIO, 13, AltGPI  ; GPIO
        PinBelongsTo GPIOType_PWM, 1, Alt0      ; PWM1
        PinEnd
        PinStart     14, IO
        PinBelongsTo GPIOType_GPIO, 14, AltGPI  ; GPIO
        PinBelongsTo GPIOType_UART, 0, Alt0     ; UART0 TXD
        PinBelongsTo GPIOType_UART, 1, Alt5     ; UART1 TXD
        PinEnd
        PinStart     15, IO
        PinBelongsTo GPIOType_GPIO, 15, AltGPI  ; GPIO
        PinBelongsTo GPIOType_UART, 0, Alt0     ; UART0 RXD
        PinBelongsTo GPIOType_UART, 1, Alt5     ; UART1 RXD
        PinEnd
        PinStart     16, IO
        PinBelongsTo GPIOType_GPIO, 16, AltGPI  ; GPIO
        PinBelongsTo GPIOType_UART, 0, Alt0     ; UART0 CTS
        PinBelongsTo GPIOType_SPI, 1, Alt4      ; SPI1 CE2
        PinBelongsTo GPIOType_UART, 1, Alt5     ; UART1 CTS
        PinEnd
        PinStart     17, IO
        PinBelongsTo GPIOType_GPIO, 17, AltGPI  ; GPIO
        PinBelongsTo GPIOType_UART, 0, Alt0     ; UART0 RTS
        PinBelongsTo GPIOType_SPI, 1, Alt4      ; SPI1 CE1
        PinBelongsTo GPIOType_UART, 1, Alt5     ; UART1 RTS
        PinEnd
        PinStart     18, IO
        PinBelongsTo GPIOType_GPIO, 18, AltGPI  ; GPIO
        PinBelongsTo GPIOType_PCM, 0, Alt0      ; PCM0 CLK
        PinBelongsTo GPIOType_BSC, 0, Alt3      ; BSC0 SDA/MOSI
        PinBelongsTo GPIOType_SPI, 1, Alt4      ; SPI1 CE0
        PinBelongsTo GPIOType_PWM, 0, Alt5      ; PWM0
        PinEnd
        PinStart     19, IO
        PinBelongsTo GPIOType_GPIO, 19, AltGPI  ; GPIO
        PinBelongsTo GPIOType_PCM, 0, Alt0      ; PCM0 FS
        PinBelongsTo GPIOType_BSC, 0, Alt3      ; BSC0 SCL/SCLK
        PinBelongsTo GPIOType_SPI, 1, Alt4      ; SPI1 MISO
        PinBelongsTo GPIOType_PWM, 1, Alt5      ; PWM1
        PinEnd
        PinStart     20, IO
        PinBelongsTo GPIOType_GPIO, 20, AltGPI  ; GPIO
        PinBelongsTo GPIOType_PCM, 0, Alt0      ; PCM0 DIN
        PinBelongsTo GPIOType_BSC, 0, Alt3      ; BSC0 MISO
        PinBelongsTo GPIOType_SPI, 1, Alt4      ; SPI1 MOSI
        PinBelongsTo GPIOType_GPCLK, 0, Alt5    ; GPCLK0
        PinEnd
        PinStart     21, IO
        PinBelongsTo GPIOType_GPIO, 21, AltGPI  ; GPIO
        PinBelongsTo GPIOType_PCM, 0, Alt0      ; PCM0 DOUT
        PinBelongsTo GPIOType_BSC, 0, Alt3      ; BSC0 CE
        PinBelongsTo GPIOType_SPI, 1, Alt4      ; SPI1 SCLK
        PinBelongsTo GPIOType_GPCLK, 0, Alt5    ; GPCLK1
        PinEnd
        PinStart     22, IO
        PinBelongsTo GPIOType_GPIO, 22, AltGPI  ; GPIO
        PinEnd
        PinStart     23, IO
        PinBelongsTo GPIOType_GPIO, 23, AltGPI  ; GPIO
        PinEnd
        PinStart     24, IO
        PinBelongsTo GPIOType_GPIO, 24, AltGPI  ; GPIO
        PinEnd
        PinStart     25, IO
        PinBelongsTo GPIOType_GPIO, 25, AltGPI  ; GPIO
        PinEnd
        PinStart     26, IO
        PinBelongsTo GPIOType_GPIO, 26, AltGPI  ; GPIO
        PinEnd
        PinStart     27, IO
        PinBelongsTo GPIOType_GPIO, 27, AltGPI  ; GPIO
        PinEnd
        PinStart     28, IO
        PinBelongsTo GPIOType_GPIO, 28, AltGPI  ; GPIO
        PinBelongsTo GPIOType_I2C, 0, Alt0      ; I2C0 SDA
        PinBelongsTo GPIOType_PCM, 0, Alt2      ; PCM0 CLK
        PinEnd
        PinStart     29, IO
        PinBelongsTo GPIOType_GPIO, 29, AltGPI  ; GPIO
        PinBelongsTo GPIOType_I2C, 0, Alt0      ; I2C0 SCL
        PinBelongsTo GPIOType_PCM, 0, Alt2      ; PCM0 FS
        PinEnd
        PinStart     30, IO
        PinBelongsTo GPIOType_GPIO, 30, AltGPI  ; GPIO
        PinBelongsTo GPIOType_PCM, 0, Alt2      ; PCM0 DIN
        PinEnd
        PinStart     31, IO
        PinBelongsTo GPIOType_GPIO, 31, AltGPI  ; GPIO
        PinBelongsTo GPIOType_PCM, 0, Alt2      ; PCM0 DOUT
        PinEnd

        ; Table ends
        DCD     -1

GPIO_Port1_Table
        PinStart     32, IO
        PinBelongsTo GPIOType_GPIO, 32, AltGPI  ; GPIO
        PinBelongsTo GPIOType_GPCLK, 0, Alt0    ; GPCLK0
        PinBelongsTo GPIOType_UART, 0, Alt3     ; UART0 TXD
        PinBelongsTo GPIOType_UART, 0, Alt5     ; UART1 TXD
        PinEnd
        PinStart     33, IO
        PinBelongsTo GPIOType_GPIO, 33, AltGPI  ; GPIO
        PinBelongsTo GPIOType_UART, 0, Alt3     ; UART0 RXD
        PinBelongsTo GPIOType_UART, 0, Alt5     ; UART1 RXD
        PinEnd
        PinStart     34, IO
        PinBelongsTo GPIOType_GPIO, 34, AltGPI  ; GPIO
        PinBelongsTo GPIOType_GPCLK, 0, Alt0    ; GPCLK0
        PinEnd
        PinStart     35, IO
        PinBelongsTo GPIOType_GPIO, 35, AltGPI  ; GPIO
        PinBelongsTo GPIOType_SPI, 0, Alt0      ; SPI0 CE1
        PinEnd
        PinStart     36, IO
        PinBelongsTo GPIOType_GPIO, 36, AltGPI  ; GPIO
        PinBelongsTo GPIOType_SPI, 0, Alt0      ; SPI0 CE0
        PinBelongsTo GPIOType_UART, 0, Alt2     ; UART0 TXD
        PinEnd
        PinStart     37, IO
        PinBelongsTo GPIOType_GPIO, 37, AltGPI  ; GPIO
        PinBelongsTo GPIOType_SPI, 0, Alt0      ; SPI0 MISO
        PinBelongsTo GPIOType_UART, 0, Alt2     ; UART0 RXD
        PinEnd
        PinStart     38, IO
        PinBelongsTo GPIOType_GPIO, 38, AltGPI  ; GPIO
        PinBelongsTo GPIOType_SPI, 0, Alt0      ; SPI0 MOSI
        PinBelongsTo GPIOType_UART, 0, Alt2     ; UART0 RTS
        PinEnd
        PinStart     39, IO
        PinBelongsTo GPIOType_GPIO, 39, AltGPI  ; GPIO
        PinBelongsTo GPIOType_SPI, 0, Alt0      ; SPI0 SCLK
        PinBelongsTo GPIOType_UART, 0, Alt2     ; UART0 CTS
        PinEnd
        PinStart     40, IO
        PinBelongsTo GPIOType_GPIO, 40, AltGPI  ; GPIO
        PinBelongsTo GPIOType_PWM, 0, Alt0      ; PWM0
        PinBelongsTo GPIOType_SPI, 2, Alt4      ; SPI2 MISO
        PinBelongsTo GPIOType_UART, 1, Alt5     ; UART1 TXD
        PinEnd
        PinStart     41, IO
        PinBelongsTo GPIOType_GPIO, 41, AltGPI  ; GPIO
        PinBelongsTo GPIOType_PWM, 1, Alt0      ; PWM1
        PinBelongsTo GPIOType_SPI, 2, Alt4      ; SPI2 MOSI
        PinBelongsTo GPIOType_UART, 1, Alt5     ; UART1 RXD
        PinEnd
        PinStart     42, IO
        PinBelongsTo GPIOType_GPIO, 42, AltGPI  ; GPIO
        PinBelongsTo GPIOType_GPCLK, 1, Alt0    ; GPCLK1
        PinBelongsTo GPIOType_SPI, 2, Alt4      ; SPI2 SCLK
        PinBelongsTo GPIOType_UART, 1, Alt5     ; UART1 RTS
        PinEnd
        PinStart     43, IO
        PinBelongsTo GPIOType_GPIO, 43, AltGPI  ; GPIO
        PinBelongsTo GPIOType_GPCLK, 2, Alt0    ; GPCLK2
        PinBelongsTo GPIOType_SPI, 2, Alt4      ; SPI2 CE0
        PinBelongsTo GPIOType_UART, 1, Alt5     ; UART1 CTS
        PinEnd
        PinStart     44, IO
        PinBelongsTo GPIOType_GPIO, 44, AltGPI  ; GPIO
        PinBelongsTo GPIOType_GPCLK, 1, Alt0    ; GPCLK1
        PinBelongsTo GPIOType_I2C, 0, Alt1      ; I2C0 SDA
        PinBelongsTo GPIOType_I2C, 1, Alt2      ; I2C1 SDA
        PinBelongsTo GPIOType_SPI, 2, Alt4      ; SPI2 CE1
        PinEnd
        PinStart     45, IO
        PinBelongsTo GPIOType_GPIO, 45, AltGPI  ; GPIO
        PinBelongsTo GPIOType_PWM, 1, Alt0      ; PWM1
        PinBelongsTo GPIOType_I2C, 0, Alt1      ; I2C0 SCL
        PinBelongsTo GPIOType_I2C, 1, Alt2      ; I2C1 SCL
        PinBelongsTo GPIOType_SPI, 2, Alt4      ; SPI2 CE2
        PinEnd
        PinStart     46, IO
        PinBelongsTo GPIOType_GPIO, 46, AltGPI  ; GPIO
        PinEnd
        PinStart     47, IO
        PinBelongsTo GPIOType_GPIO, 47, AltGPI  ; GPIO
        PinEnd
        PinStart     48, IO
        PinBelongsTo GPIOType_GPIO, 48, AltGPI  ; GPIO
        PinEnd
        PinStart     49, IO
        PinBelongsTo GPIOType_GPIO, 49, AltGPI  ; GPIO
        PinEnd
        PinStart     50, IO
        PinBelongsTo GPIOType_GPIO, 50, AltGPI  ; GPIO
        PinEnd
        PinStart     51, IO
        PinBelongsTo GPIOType_GPIO, 51, AltGPI  ; GPIO
        PinEnd
        PinStart     52, IO
        PinBelongsTo GPIOType_GPIO, 52, AltGPI  ; GPIO
        PinEnd
        PinStart     53, IO
        PinBelongsTo GPIOType_GPIO, 53, AltGPI  ; GPIO
        PinEnd

        ; Table ends
        DCD     -1

GPIOPortTables
        DCD     GPIO_Port0_Table
        DCD     GPIO_Port1_Table

        END
@


1.11
log
@Safe GPIO pins table updates
Add Pi3 B+ and Zero W.
Split out CM3 from CM1, since the CM3 reuses some high GPIO lines as bit bashed SMPSU IIC bus, so we can't offer those for GPIO like on CM1.

Version 0.75. Tagged as 'BCM2835-0_75'
@
text
@d216 1
d231 1
d248 1
d309 2
@


1.11.2.1
log
@Add support for Pi model 3A+

Tagged as 'BCM2835-0_75-1'
@
text
@a215 1
GPIORevision_RaspberryPi_Mk3_APlus #     1 ; Model Pi 3 A+
a229 1
Name_Mk3_APlus = "Raspberry Pi 3 Model A+", 0
a245 1
        DCD     Name_Mk3_APlus
a305 2
        DCD     BoardRevision_Mem_512M+BoardRevision_Model_A3Plus+(0:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_Mk3_APlus
@


1.10
log
@Typos
:LNOT -> :LNOT:
GPOI -> GPIO
set -> cleared
No code change, not tagged.
@
text
@d208 2
a209 1
GPIORevision_RaspberryPi_C_1     #       1 ; Model Compute Rev 1.0
d211 1
a211 1
GPIORevision_RaspberryPi_Mk2_B_1 #       1 ; Model Pi 2
d213 3
a215 1
GPIORevision_RaspberryPi_Mk3_B_1 #       1 ; Model Pi 3
d222 2
a223 1
Name_C_1 = "Raspberry Pi Compute Module", 0
d225 1
a225 1
Name_Mk2_B_1 = "Raspberry Pi 2 Model B", 0
d227 3
a229 1
Name_Mk3_B_1 = "Raspberry Pi 3 Model B", 0
d239 1
d241 1
a241 1
        DCD     Name_Mk2_B_1
d243 3
a245 1
        DCD     Name_Mk3_B_1
d291 1
a291 1
        DCD     GPIORevision_RaspberryPi_Mk2_B_1
d293 1
a293 1
        DCD     GPIORevision_RaspberryPi_Mk2_B_1
d299 1
a299 1
        DCD     GPIORevision_RaspberryPi_Mk3_B_1
d301 5
a305 1
        DCD     GPIORevision_RaspberryPi_C_1
d943 4
a946 2
        DCD     2_11111111111111111111111111111111      ; Compute rev 1
        DCD     2_00000000000000001111111111111111
d951 3
a953 1
        DCD     2_00001111111111111111111111111111      ; zero
d957 2
@


1.9
log
@Add new scheme ids for A+ and B+ to id table
Apparently there are some A+ 1.1 and B+ 1.2's in the wild not built with their former id's (0x12 and 0x13) but using the newer 24 bit id scheme. Add aliases for these.

Version 0.70. Tagged as 'BCM2835-0_70'
@
text
@d430 1
a430 1
;            a2 = any bit set will cause that pin to be set
@


1.9.2.1
log
@Merge in latest HEAD
Detail:
  Merge in changes since BCM2835-0_70 to keep SMP branch up to date
Admin:
  Untested


Version 0.71, 1.70.2.2. Tagged as 'BCM2835-0_71-1_70_2_2'
@
text
@d430 1
a430 1
;            a2 = any bit set will cause that pin to be cleared
@


1.9.2.2
log
@Merge latest changes from HEAD

Version 0.75, 1.70.2.4. Tagged as 'BCM2835-0_75-1_70_2_4'
@
text
@d208 1
a208 2
GPIORevision_RaspberryPi_C_1     #       1 ; Model CM1
GPIORevision_RaspberryPi_C_3     #       1 ; Model CM3
d210 1
a210 1
GPIORevision_RaspberryPi_Mk2_B   #       1 ; Model Pi 2 B
d212 1
a212 3
GPIORevision_RaspberryPi_ZeroW   #       1 ; Model ZeroW
GPIORevision_RaspberryPi_Mk3_B   #       1 ; Model Pi 3 B
GPIORevision_RaspberryPi_Mk3_BPlus #     1 ; Model Pi 3 B+
d219 1
a219 2
Name_C_1 = "Raspberry Pi Compute Module 1", 0
Name_C_3 = "Raspberry Pi Compute Module 3", 0
d221 1
a221 1
Name_Mk2_B = "Raspberry Pi 2 Model B", 0
d223 1
a223 3
Name_ZeroW = "Raspberry Pi Zero W", 0
Name_Mk3_B = "Raspberry Pi 3 Model B", 0
Name_Mk3_BPlus = "Raspberry Pi 3 Model B+", 0
a232 1
        DCD     Name_C_3
d234 1
a234 1
        DCD     Name_Mk2_B
d236 1
a236 3
        DCD     Name_ZeroW
        DCD     Name_Mk3_B
        DCD     Name_Mk3_BPlus
d282 1
a282 1
        DCD     GPIORevision_RaspberryPi_Mk2_B
d284 1
a284 1
        DCD     GPIORevision_RaspberryPi_Mk2_B
d290 1
a290 1
        DCD     GPIORevision_RaspberryPi_Mk3_B
d292 1
a292 5
        DCD     GPIORevision_RaspberryPi_C_3
        DCD     BoardRevision_Mem_512M+BoardRevision_Model_ZeroW+(1:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_ZeroW
        DCD     BoardRevision_Mem_1G+BoardRevision_Model_B3Plus+(3:SHL:BoardRevision_Rev_Shift)
        DCD     GPIORevision_RaspberryPi_Mk3_BPlus
d930 2
a931 4
        DCD     2_11111111111111111111111111111111      ; Compute CM1
        DCD     2_00000000000000000111111111111111
        DCD     2_11111111111111111111111111111111      ; Compute CM3
        DCD     2_00000000000000000011111111111111
d936 1
a936 3
        DCD     2_00001111111111111111111111111111      ; Zero
        DCD     2_00000000000000000000000000000000
        DCD     2_00001111111111111111111111111111      ; ZeroW
a939 2
        DCD     2_00001111111111111111111111111111      ; 3B+
        DCD     2_00000000000000000000000000000000
@


1.8
log
@Transition Pi HAL to GPIO API 1.00
Detail:
  Move the register accesses for GPIO to the HAL, since they are hardware specific.
  Add recognition of board types for Pi 3, Compute module 3, rev 3 Pi 0's, and the newer Pi 2's with BCM2837 on them.
Admin:
  Based in part on a submission from Tank.
  Tested on a Pi 2. Requires corresponding GPIO module (tag GPIO-1_00-1_11_2_1 or later).

Version 0.67. Tagged as 'BCM2835-0_67'
@
text
@d277 4
@


1.7
log
@Add JTAG debugging support
Detail:
  hdr/BCM2835 - Add switch to allow GPIOs 22-27 to be reconfigured for ARM JTAG access
  s/Top - Configure GPIOs for JTAG if switch enabled
  s/GPIO - Disable GPIO HAL device if JTAG enabled (try and avoid any software messing with the pins)
Admin:
  Tested on Raspberry Pi 1 B, B+


Version 0.66. Tagged as 'BCM2835-0_66'
@
text
@d33 1
d37 1
d42 1
d62 98
d163 1
a163 1
GPIO_Dev
d168 3
a170 3
        HALDeviceField Version,            0
        HALDeviceField Description,        GPIO_Description
        HALDeviceField Address,            0
d180 15
a194 3
GPIO    HALDeviceField Type,               GPIOType_BCM2835_RaspberryPi
GPIO    HALDeviceField Revision,           0 ; Filled in at runtime
        ASSERT  . - %A0 = HALDevice_GPIO_Size
d196 18
a213 2
GPIO_Description
        = "BCM2835 GPIO interface", 0
d218 1
a220 1
Name_BPlus = "Raspberry Pi B+", 0
d223 1
d225 1
d227 11
a237 1
        ALIGN
d239 2
a240 1
; Lookup table to determine board type
a246 1
        DCD Name_$type
a248 4
; The Zero has the same pinout as the 2 B, so there's currently no distinction between the two in the GPIO device
GPIORevision_RaspberryPi_Zero * GPIORevision_RaspberryPi_Mk2_B_1

; Ref: http://elinux.org/RPi_HardwareHistory#Board_Revision_History
d258 2
a259 3
        BoardType 0, &a01041, &a01041, Mk2_B_1
        BoardType 0, &a21041, &a21041, Mk2_B_1
        BoardType 0, &900092, &900092, Zero
d262 29
d292 26
a317 5
GPIO_InitDevices ROUT
        Entry   "v1-v3"
        ADRL    a1, GPIODevice
        ADR     a2, GPIO_Dev
        MOV     a3, #HALDevice_GPIO_Size
d319 24
a342 17
        ADR     v1, GPIO_BoardTypes
        LDR     v2, Board_Model
        LDR     v3, Board_Revision
        ADR     ip, GPIO_BoardTypes_End
10
        CMP     v1, ip
        EXIT    EQ ; Unknown model, give up
        LDMIA   v1!, {a1-a4}
        ADD     v1, v1, #4
        CMP     a1, v2
        BNE     %BT10
        CMP     a2, v3
        CMPLS   v3, a3
        BHI     %BT10
        ; Found a match
        ADRL    a2, GPIODevice
        STR     a4, [a2, #HALDevice_GPIORevision]
d344 3
d348 4
a351 2
        MOV     lr, pc
        LDR     pc, OSentries+4*OS_AddDevice
d365 2
d368 13
a380 1
        Entry   "v1-v3"
d385 4
d391 2
a392 2
        ADREQL  a1, Name_Unknown
        EXIT    EQ ; Unknown model, give up
d394 1
a394 2
        ADD     v1, v1, #4
        CMP     a1, v2
d397 106
a502 4
        CMPLS   v3, a3
        BHI     %BT10
        ; Found a match
        LDR     a1, [v1, #-4]
d504 691
a1194 1
        
@


1.6
log
@Fix build error. Add HAL_PlatformName implementation.
Detail:
  s/Stubs, s/Top - Remove references to deleted HAL ATA calls
  s/GPIO, s/Top - Add implementation of HAL_PlatformName. Located in s/GPIO to allow easy re-use of the board revision table.
Admin:
  Tested on Pi 2 Model B


Version 0.51. Tagged as 'BCM2835-0_51'
@
text
@d150 1
d154 1
@


1.5
log
@Extend the GPIO table to include A+ and Mk2 model B
Note, this scheme remains non future proof as any later model numbers released will be miscategorised as the last table entry.

Version 0.44. Tagged as 'BCM2835-0_44'
@
text
@d38 1
d86 10
d105 1
d108 4
d120 4
a123 1
        BoardType 0, &13, &ffffffff, Mk2_B_1
d141 1
d164 21
@


1.4
log
@Add entry to boardtypes for GPIO for Compute module
There doesn't seem to be a pattern emerging for the allocation of board types, so it's likely that this table will need revisiting again in future as moving the catch all "-1" entry along was identifying a Compute module as a B+.
Submission from TankStage.

Version 0.37. Tagged as 'BCM2835-0_37'
@
text
@d102 3
a104 1
        BoardType 0, &11, &ffffffff, C_1
@


1.3
log
@  Support the Raspberry Pi model B+
Detail:
  The activity GPIO pin has been reassigned and its sense is inverted,
  compared to earlier boards. More importantly, the SD card detect pin has
  been removed entirely, so we need to signal to the SD stack to use its
  new timeout-based state machine (rather than polling for card presence).
Admin:
  Already in use in RC12a.

Version 0.35. Tagged as 'BCM2835-0_35'
@
text
@d101 2
a102 1
        BoardType 0, &10, &ffffffff, BPlus ; Assume anything newer will be compatible so that minor revisions don't trip us up
@


1.2
log
@Read board model, revision, and available DMA channels from messaging channel. Report board revision via GPIO HAL device. Recover lost ROM relocation code.
Detail:
  hdr/StaticWS, s/Messaging, s/Top - Now reads board model, revision and available DMA channels from messaging channel
  hdr/StaticWS, s/GPIO - Updated GPIO HAL device to report board revision instead of a generic response of 'unknown'
  s/Top - Recovered ROM relocation code that got lost during a merge. End of ROM image no longer being corrupted, and RISC OS now sees correct amount of RAM.
  s/DMA - Ditch old code to read available DMA channels and use value read by HAL_QueryPlatform instead.
Admin:
  Tested on Raspberry Pi (B rev 1) with various start.elf sizes & versions
  DMA channel reporting only available with latest firmware (i.e. 8th Sep)
  Board revision number read by messaging channel seems to match that returned by /proc/cpuinfo on Linux


Version 0.22. Tagged as 'BCM2835-0_22'
@
text
@d97 5
a101 2
        BoardType 0, 2, 3, B_1
        BoardType 0, 4, &ffffffff, B_2 ; Only revs 4-6 confirmed so far, but assume anything newer will be compatible so that minor revisions don't trip us up
@


1.1
log
@Add GPIO & VCHIQ HAL devices. Fix FlushDataCache macro to perform a clean & invalidate instead of just an invalidate.
Detail:
  s/GPIO - Basic implementation of the GPIO HAL device to allow the GPIO module to detect the board type
  s/VCHIQ, hdr/StaticWS - New VCHIQ HAL device which exposes the functionality required by the work-in-progress VCHIQ driver.
  Makefile, s/Top - Hook up the new files/devices
  hdr/BCM2835 - Make the FlushDataCache macro perform a clean & invalidate, to match the behaviour of FlushDataCacheRange
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.17. Tagged as 'BCM2835-0_17'
@
text
@a33 1
        GET     Hdr:GPIODevice
d38 1
d79 1
a79 1
GPIO    HALDeviceField Revision,           GPIORevision_RaspberryPi_Unknown
d87 14
d103 21
a123 1
        Entry
a124 1
        ADR     a2, GPIO_Dev
@


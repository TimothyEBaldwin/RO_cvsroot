head	1.14;
access;
symbols
	BCM2835-0_75-1:1.13
	BCM2835-0_76:1.14
	BCM2835-0_75-1_70_2_4:1.12.2.2
	BCM2835-0_75:1.13
	BCM2835-0_74:1.13
	BCM2835-0_73-1_70_2_3:1.12.2.2
	BCM2835-0_73:1.13
	BCM2835-0_72:1.13
	BCM2835-0_71-1_70_2_2:1.12.2.2
	BCM2835-0_71:1.13
	BCM2835-0_70-1_70_2_1:1.12.2.1
	SMP:1.12.0.2
	SMP_bp:1.12
	BCM2835-0_70:1.12
	BCM2835-0_69:1.12
	BCM2835-0_68:1.11
	BCM2835-0_67:1.9
	BCM2835-0_66:1.9
	BCM2835-0_65:1.9
	BCM2835-0_64:1.9
	BCM2835-0_63:1.9
	BCM2835-0_62:1.9
	BCM2835-0_61:1.9
	BCM2835-0_60:1.9
	BCM2835-0_59:1.9
	BCM2835-0_58:1.9
	BCM2835-0_57:1.9
	BCM2835-0_56:1.9
	BCM2835-0_55:1.9
	BCM2835-0_53:1.8
	BCM2835-0_52:1.8
	BCM2835-0_51:1.7
	BCM2835-0_50:1.7
	BCM2835-0_49:1.6
	BCM2835-0_48:1.6
	BCM2835-0_47:1.6
	BCM2835-0_46:1.6
	BCM2835-0_45:1.6
	BCM2835-0_44:1.6
	BCM2835-0_43:1.6
	BCM2835-0_42:1.6
	BCM2835-0_41:1.6
	BCM2835-0_40:1.6
	BCM2835-0_39:1.5
	BCM2835-0_38:1.5
	BCM2835-0_37:1.5
	BCM2835-0_36:1.5
	BCM2835-0_35:1.5
	BCM2835-0_34:1.5
	BCM2835-0_33:1.5
	BCM2835-0_32:1.5
	BCM2835-0_31:1.5
	BCM2835-0_30:1.5
	BCM2835-0_29:1.5
	BCM2835-0_28:1.5
	BCM2835-0_27:1.5
	BCM2835-0_26:1.5
	BCM2835-0_25:1.5
	BCM2835-0_24:1.4
	BCM2835-0_23:1.4
	BCM2835-0_22:1.4
	BCM2835-0_21:1.3
	BCM2835-0_20:1.2
	BCM2835-0_19:1.2
	BCM2835-0_18:1.2
	BCM2835-0_17:1.2
	BCM2835-0_16:1.2
	BCM2835-0_15:1.2
	BCM2835-0_14:1.1;
locks; strict;
comment	@# @;


1.14
date	2018.07.07.14.26.23;	author jlee;	state Exp;
branches;
next	1.13;
commitid	VQCRRsJLbDt0fdJA;

1.13
date	2017.07.31.22.09.53;	author jlee;	state Exp;
branches;
next	1.12;
commitid	xk6viwRsoGpALq1A;

1.12
date	2017.02.21.22.10.54;	author rsprowson;	state Exp;
branches
	1.12.2.1;
next	1.11;
commitid	vR1YulJPaRxOURGz;

1.11
date	2017.02.21.22.00.27;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	5uukDnnvmsVeRRGz;

1.10
date	2017.02.21.21.55.09;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	aGYdSiPibM9QORGz;

1.9
date	2016.03.26.21.29.33;	author jlee;	state Exp;
branches;
next	1.8;
commitid	R20Od6NioP8emc0z;

1.8
date	2016.03.25.19.59.14;	author jlee;	state Exp;
branches;
next	1.7;
commitid	ZKDMXPRZKhDfT30z;

1.7
date	2015.11.15.00.09.57;	author jlee;	state Exp;
branches;
next	1.6;
commitid	oJ6rSmtkg3Ajw7Jy;

1.6
date	2015.02.02.13.28.32;	author bavison;	state Exp;
branches;
next	1.5;
commitid	ElEkWbWLEdDg8r8y;

1.5
date	2012.09.18.13.49.18;	author jlee;	state Exp;
branches;
next	1.4;
commitid	kPVw3k71agHe71lw;

1.4
date	2012.09.08.12.46.13;	author jlee;	state Exp;
branches;
next	1.3;
commitid	B5V3jq9teWHw5Jjw;

1.3
date	2012.09.02.20.03.43;	author jlee;	state Exp;
branches;
next	1.2;
commitid	FetF3i2OxxUzHZiw;

1.2
date	2012.07.22.22.32.53;	author jballance;	state Exp;
branches;
next	1.1;
commitid	6IVuPWq7pOksSBdw;

1.1
date	2012.07.19.10.29.27;	author jballance;	state Exp;
branches;
next	;
commitid	7w2Uohftp8BdY9dw;

1.12.2.1
date	2017.07.29.11.37.43;	author jlee;	state Exp;
branches;
next	1.12.2.2;
commitid	leIbdlwVfACHk71A;

1.12.2.2
date	2017.07.31.22.18.18;	author jlee;	state Exp;
branches;
next	;
commitid	VmVokWQ7fiZsOq1A;


desc
@@


1.14
log
@Merge SMP branch to trunk
Detail:
  hdr/StaticWS - Reserve workspace for QA7 peripheral address, HAL-wide spinlock, and doorbell device
  Makefile, s/DBell - Add doorbell device implementation
  hdr/BCM2835 - Clean up dead macros, add new macros for spinlock claim/release and basic CPU detection. Define new IRQ numbers for the "QA7" peripheral.
  hdr/CastleMacros, s/Top - Generate two HAL descriptors and entry point tables: One for single-core machines and one for multi-core machines. This avoids some MP-related overheads on ARM11 models of Pi. Implement SMP HAL entry points.
  s/Interrupts - Add support for the QA7 interrupts. Although some interrupts can be flexibly routed to different cores, we currently stick with a static scheme.
  s/Messaging - Use CPUDetect macro
Admin:
  Untested
  Requires Kernel-6_09


Version 0.76. Tagged as 'BCM2835-0_76'
@
text
@;
; Copyright (c) 2012, RISC OS Open Ltd
; Copyright (c) 2012, John Ballance
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met: 
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in the
;       documentation and/or other materials provided with the distribution.
;     * Neither the name of RISC OS Open Ltd nor the names of its contributors
;       may be used to endorse or promote products derived from this software
;       without specific prior written permission.
; 
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.
;
;

        AREA    |ARM$$code|, CODE, READONLY, PIC

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:Proc
        GET     Hdr:System
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:BCMSupport
        $GetMEMM
        GET     hdr.BCM2835
        GET     hdr.StaticWS
        GET     hdr.CastleMacros

        IMPORT  workspace

     [ HALDebug
        IMPORT  HAL_DebugTX
        IMPORT  HAL_DebugHexTX4
        IMPORT  HAL_DebugTXStrInline
     ]
        IMPORT  memcpy
        EXPORT  HAL_SendHostMessage
        EXPORT  HAL_QueryPlatform
        EXPORT  GetVCBuffer
        EXPORT  BCMMBox_InitDevices

; Send a message packet to the host and await the reply
; on entry, r0 =  message channel to use and/or wholemessage
;           r1 -> message tag buffer, 16 byte aligned. or 0
;           
; on exit,  r0 = mailbox response word
;          
HAL_SendHostMessage  ROUT
        STMFD   r13!, {r1-r3, lr}
        DoMemBarrier r3
        FlushDataCache ; corrupts r2,r3,lr
        LDR     r3, PeriBase
        ADD     r3, r3, #MB_Base
; check we can send a message
001     LDR     r2,[r3, #MB_Sta]
        TST     r2, #MB_Sta_Full
        BNE     %BT001                ; write channel full
; send message
        TEQ     r1, #0
        BICNE   r1, r1, #&c0000000
;        LDRNE   r2, FB_CacheMode
;        ORRNE   r1, r1, r2
        ORR     r2, r0, r1
        AND     r1, r0, #&f            ; isolate channel number
        STR     r2,[r3, #MB_ChWr]
; await response and check it is ours
002     LDR     r0,[r3, #MB_Sta]
        TST     r0, #MB_Sta_Empty
        BNE     %BT002                ; still empty
        LDR     r0,[r3,#MB_ChRd]
        AND     r2, r0, #&f
        CMP     r2, r1                ; check its is our channel
        BNE     %BT002                ; not our reply
        DoMemBarrier r3
        LDMFD   r13!, {r1-r3, pc}     ; returning composite response in r0

; Interrogate the platform and set up basic machine
; Sets up L2 cache addressing mode
;         ARM_Memory_MB (in Megabytes)
;         Frame buffer base address for 32bit fb
;         Board_MAC address
;         Board_Serial
;         Board model & revision
;         Available DMA channels
;
HAL_QueryPlatform    ROUT
        STMFD   R13!, {r0-r6, lr}
 [ HALDebug
        BL      HAL_DebugTXStrInline
        DCB     "QueryPlatform",10,0
        ALIGN
 ]
        CPUDetect r4
        MOVCC   r4, #GPU_L2CnonAl              ; Pi 1 has L2 cache enabled
        MOVCS   r4, #GPU_UnCached              ; Pi 2 has L2 cache disabled
        STR     r4, FB_CacheMode               ; remember base of bus addresses (i.e. memory accessed by GPU and GPU peripherals like DMA and USB)

        ADRL    r0, tagbuffer
        ADR     r1, tagb
        MOV     r2, #tagslen
        BL      memcpy                         ; copy to workspace buffer

        MOV     r1, r0
        MOV     r0, #MB_Chan_ARM2VC 
        BL      HAL_SendHostMessage            ; ask the questions

        ADRL    r5, tagbuffer                  ; now read the answers
        ADD     r0,r5,#VCbs-tagb               ; VC address and size
        LDMIA   r0, {r1, r2}
        STR     r1, VC_Base
        STR     r2, VC_Size
        ADD     r0,r5,#ARMbs-tagb              ; ARM address and size
        LDMIA   r0, {r1, r2}
        STR     r1, ARM_Base
        STR     r2, ARM_Size
        LDR     r0, [r5, #boardmodel-tagb]
        LDR     r1, [r5, #boardrev-tagb]
        LDR     r2, [r5, #dmachans-tagb]
        STR     r0, Board_Model
        STR     r1, Board_Revision
        ; If no channels are reported as available, use channel 4
        ; (Matches default channel mask from Linux)
        CMP     r2, #0
        MOVEQ   r2, #1<<4
        STR     r2, ARM_DMAChannels

        ; Copy out and construct machine ID from MAC address
        ADRL    a3, tagbuffer
        ADD     a3, a3,#:INDEX:MAClo-:INDEX:tagb
        LDR     lr, [a3, #-4]       ; check if message completed
        TST     lr, #&80000000      ; NE if successful
        MOVEQ   a1, #0
        MOVEQ   a2, #0
        
        LDMNEIA a3, {a1, a2}
        AND     a3, a1, #&ff000000
        MOV     a3, a3, LSR #24
        ORR     a2, a3, a2, LSL #8
        MOV     a1, a1, LSL #8
        ORR     a1, a1, #&81           ; make it look like a Dallas unique id 
        BIC     a2, a2, #&ff000000

        MOV     a3, #0                 ; compute a Dallas unique id CRC
        MOV     a4, #7                 ; number of bytes to do
gbyte                                  ;
        AND     v2, a1, #&ff           ; get next byte. shift reg round 8 byte
        AND     v3, a2, #&ff           ; shift reg round 8 byte
        MOV     v1, v2, lsl #24
        MOV     v3, v3, lsl #24
        ORR     a1, v3, a1,lsr #8      ; shift reg round 8 byte
        ORR     a2, v1, a2,lsr #8      ; shift reg round 8 byte

        EOR     a3, a3, v2             ;                                  
        MOV     v1, #8                 ; number of bits to do
gbit                                   ;                                  
        MOVS    a3, a3, LSR #1         ; shift bit out into carry
        EORCS   a3, a3, #&8C           ; feedback carry into other bits
        SUBS    v1, v1, #1             ; one less bit to do               
        BNE     gbit                   ; loop until done whole byte       
        SUBS    a4, a4, #1             ; one less byte to do
        BNE     gbyte                  ; loop until done all 7 bytes

        AND     v2, a1, #&ff           ; get next byte. shift reg round 8 byte
        AND     v3, a2, #&ff           ; shift reg round 8 byte
        MOV     v1, v2, lsl #24
        MOV     v3, v3, lsl #24
        ORR     a1, v3, a1,lsr #8      ; shift reg round 8 byte
        ORR     a2, v1, a2,lsr #8      ; shift reg round 8 byte

        ORR     a2, a2, a3, lsl #24    ; insert crc into hi byte
        ADRL    lr,MachineID
        STMIA   lr, {a1, a2}        

        ; Check if it's a Compute Module 3, to decide whether to probe CM3 .v. CM3L
        LDR     a4, Board_Revision 
        AND     a4, a4, #BoardRevision_Model_Mask
        CMP     a4, #BoardRevision_Model_Compute3
        BNE     %FT10

        ADRL    a1, tagbuffer
        ADR     a2, tagbcm3
        MOV     a3, #tagslencm3
        BL      memcpy                         ; copy to workspace buffer

        MOV     a2, a1
        MOV     a1, #MB_Chan_ARM2VC 
        BL      HAL_SendHostMessage            ; ask the questions

        ADRL    a4, tagbuffer                  ; now read the answers
        LDR     a1, [a4, #4]
        TEQ     a1, #&80000000                 ; firmware new enough to accept all the tags?
        LDREQ   a1, [a4, #safcat-tagbcm3]
        MOVNE   a1, #-1
        STR     a1, SafetyCatch
10
 [ HALDebug
        BL      HAL_DebugTXStrInline
        DCB     "QueryPlatform done",10,0
        ALIGN
 ]
        LDMFD   R13!, {r0-r6, pc}

; In:
;   a1 = GET tag to fetch buffer for
;   a2 = buffer size
;   a3 = corresponding SET tag
; Out:
;   a1 = buffer logical address, 0 if not present
;   a2-a4, ip corrupt
;
; Query the VC for a data buffer. Historically the VC has dictated the locations
; of these buffers, but at some point the ability was added for the ARM to
; dictate the address to the GPU. With recent firmware versions, use of this
; feature is now mandatory, as on systems with 1GB of RAM the firmware will now
; attempt to make use of the upper 16MB of RAM (which overlaps the ARM's IO
; space, making it inaccessible to the ARM)
;
; Annoyingly, the main tags we're interested in don't follow the usual pattern
; of adding &8000 in order to convert a GET request to a SET, so we require both
; the GET and SET values to be explicitly specified.
GetVCBuffer     ROUT
      [ HALDebug
        STR     lr, [sp, #-4]!
        BL      %FT01
        BL      HAL_DebugHexTX4
        BL      HAL_DebugTXStrInline
        DCB     "log",10,0
        ALIGN
        LDR     pc, [sp], #4
01
      ]
        STMFD   sp!, {a1-a2, lr}
      [ HALDebug
        BL      HAL_DebugHexTX4
        BL      HAL_DebugTXStrInline
        DCB     "GetVCBuffer",10,0
        ALIGN
      ]
        MOV     a1, a3                  ; Start off with the SET request
        ; Reserve space for the buffer in NCNB workspace
        LDR     ip, NCNBPhysAddr
        LDR     a4, NCNBAddr
        MOV     a3, a2
        MOV     lr, #0
10
        SUBS    a3, a3, #4
        STRGE   lr, [a4, a3]            ; Ensure buffer memory is zeroed, just in case ARM/VC is confused by any previous content (like a tag buffer from a previous call to GetVCBuffer). E.g. recent firmware versions will allow you to get/set the FT5406 touchscreen buffer, even if the touchscreen isn't connected.
        BGT     %BT10
        ADD     a3, ip, a2
        ADD     a4, a4, a2
        ; Now construct a message tag block after it
        ADD     a3, a3, #15             ; Align for mailbox use
        ADD     a4, a4, #15
        BIC     a3, a3, #15
        BIC     a4, a4, #15
        STR     a1, [a4, #8]            ; Tag
        MOV     a1, #7*4
        MOV     a2, #0
        STMIA   a4!, {a1, a2}           ; Total length, out flags
        MOV     a1, #4
        MOV     a2, #4
        MOV     lr, #ARM2VC_Tag_End
        STMIB   a4, {a1, a2, ip, lr}    ; Tag length, in length, in data, terminator
        MOV     a2, a3
        MOV     a1, #MB_Chan_ARM2VC
        BL      HAL_SendHostMessage
      [ HALDebug
        LDR     a1, [a4, #-8]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #-4]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #0]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #4]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #8]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #12]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #16]
        BL      HAL_DebugHexTX4
        BL      HAL_DebugTXStrInline
        DCB     "set",10,0
        ALIGN
      ]
        ; On success, firmware should overwrite the address with zero
        LDR     a1, [a4, #12]
        CMP     a1, #0
        BNE     %FT50
        ; Buffer set success; update NCNB claim and return the claimed addr
        LDMIA   sp!, {a1-a2, lr}
        LDR     a1, NCNBAddr
        LDR     ip, NCNBPhysAddr
        ADD     a3, a1, a2
        ADD     ip, ip, a2
        STR     a3, NCNBAddr
        STR     ip, NCNBPhysAddr
        MOV     pc, lr
50
        ; Buffer set failure. Try getting the address instead.
        MOV     a1, #7*4
        MOV     a2, #0
        STMDB   a4, {a1, a2}            ; Total length, out flags
        LDR     a1, [sp]
        MOV     a2, #4
        MOV     ip, #0
        MOV     lr, #0
        STMIA   a4, {a1, a2, ip, lr}    ; Tag, tag length, in length, in data
                                        ; n.b. assuming terminator word still in place!
        MOV     a2, a3
        MOV     a1, #MB_Chan_ARM2VC
        BL      HAL_SendHostMessage
      [ HALDebug
        LDR     a1, [a4, #-8]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #-4]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #0]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #4]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #8]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #12]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #16]
        BL      HAL_DebugHexTX4
        BL      HAL_DebugTXStrInline
        DCB     "get",10,0
        ALIGN
      ]
        ; On success, firmware should write non-zero address
        LDR     a1, [a4, #12]
        BICS    a1, a1, #&c0000000      ; Convert to ARM phys addr
        LDMIA   sp!, {a2-a3, lr}        ; Junk stacked a1-a2, but also loads a2 into correct reg for OS_MapInIO
        MOVEQ   pc, lr
        ; Buffer exists, map it in
        MOV     a2, a1
        MOV     a1, #1:SHL:L1_TEXShift  ; VMSA Normal, non-cacheable
        CallOS  OS_MapInIO, tailcall
        

; Series of VC side query tags.
;
tagb    DCD     tagslen
        DCD     0        

        DCD     ARM2VC_Tag_GetBoardMAC
        DCD     8
        DCD     0        
MAClo   DCD     0        
MAChi   DCD     0        

        DCD     ARM2VC_Tag_GetBoardSerial
        DCD     8
        DCD     0        
SNlo    DCD     0
SNhi    DCD     0        

        DCD     ARM2VC_Tag_GetARMMemory
        DCD     8
        DCD     0        
ARMbs   DCD     0
ARMsz   DCD     0

        DCD     ARM2VC_Tag_GetVCMemory
        DCD     8
        DCD     0        
VCbs    DCD     0
VCsz    DCD     0

        DCD     ARM2VC_Tag_GetBoardModel
        DCD     4
        DCD     0
boardmodel DCD  0

        DCD     ARM2VC_Tag_GetBoardRevision
        DCD     4
        DCD     0
boardrev DCD    0

        DCD     ARM2VC_Tag_GetDMAChannels
        DCD     4
        DCD     0
dmachans DCD    0                                
        DCD     ARM2VC_Tag_FBBlank
        DCD     4
        DCD     4
        DCD     1 ; Start with the screen blanked (avoids firmware displaying an RGB square)
        DCD     ARM2VC_Tag_SetClockRate
        DCD     12
        DCD     12
        DCD     2
        DCD     3000000 ; Reset PL011 UART clock to default (Pi 3 has this set to 48MHz for BT, but currently we want to use it for plain serial)
        DCD     0
        DCD     ARM2VC_Tag_End
tagslen *       . - tagb
        ASSERT  tagslen <= ?tagbuffer

; Extra series of VC side query tags for CM3. 
;
tagbcm3 DCD     tagslencm3
        DCD     0        

        DCD     ARM2VC_Tag_SetExtGPIOConfig
        DCD     24
        DCD     0
        DCD     128+6 ; Expander IO6. Only relevant on Compute 3.
        DCD     0     ; Configure pin on FXL6408 (U8) as input with weak pullup
        DCD     0 
        DCD     1
        DCD     1
        DCD     -1

        DCD     ARM2VC_Tag_GetExtGPIOState
        DCD     8
        DCD     0
        DCD     128+6
safcat  DCD     -1    ; Sampled state, default high

        DCD     ARM2VC_Tag_End
tagslencm3 *    . - tagbcm3
        ASSERT  tagslencm3 <= ?tagbuffer

        MACRO
$class  HALDeviceField $field, $value
        LCLS    myvalue
      [ "$value" = ""
myvalue SETS    "$field"
      |
myvalue SETS    "$value"
      ]
        ASSERT  . - %A0 = HALDevice_$class$field
     [ ?HALDevice_$class$field = 2
        DCW     $myvalue
   ELIF ?HALDevice_$class$field = 4
        DCD     $myvalue
      |
        %       ?HALDevice_$class$field
      ]
        MEND


; Template for mailbox device

BCMMBox_Dev
0
        HALDeviceField Type,               HALDeviceType_Comms + HALDeviceComms_InterProc
        HALDeviceField ID,                 HALDeviceID_InterProc_BCMMBox
        HALDeviceField Location,           HALDeviceBus_Sys + HALDeviceSysBus_AHB ; Guess
        HALDeviceField Version,            0
        HALDeviceField Description,        BCMMBox_Description
        HALDeviceField Address,            0
        HALDeviceField Reserved1,          0
        HALDeviceField Activate,           BCMMBox_Activate
        HALDeviceField Deactivate,         BCMMBox_Deactivate
        HALDeviceField Reset,              BCMMBox_Reset
        HALDeviceField Sleep,              BCMMBox_Sleep
        HALDeviceField Device,             iDev_ARM_Mbx
        HALDeviceField TestIRQ,            0
        HALDeviceField ClearIRQ,           0
        HALDeviceField Reserved2,          0
        ASSERT  . - %A0 = HALDeviceSize

BCMMBox_Description
        = "BCM283x VideoCore mailboxes", 0

        ALIGN

        ; Initialise our HAL devices
BCMMBox_InitDevices ROUT
        Entry
        ADRL    a1, MBoxDevice
        ADR     a2, BCMMBox_Dev
        MOV     a3, #HALDeviceSize
        BL      memcpy
        ADRL    a2, MBoxDevice
        LDR     a1, PeriBase
        ADD     a1, a1, #MB_Base
        STR     a1, [a2, #HALDevice_Address]
        MOV     a1, #0
        MOV     lr, pc
        LDR     pc, OSentries+4*OS_AddDevice
        EXIT

BCMMBox_Activate
        MOV     a1, #1
BCMMBox_Deactivate
BCMMBox_Reset
        MOV     pc, lr

BCMMBox_Sleep
        MOV     a1, #0
        MOV     pc, lr

                END

@


1.13
log
@Fix compatibility with latest firmware
Detail:
  Firmware as of 28th July will allow the GPU to make use of the top 16MB of RAM in 1GB machines. This overlaps the ARM's IO space, essentially making that area of memory inaccessible to us.
  This causes problems because we rely on a couple of buffers which are located in VC memory (virtual GPIO buffer & FT5406 touchscreen buffer)
  At some point extra mailbox messages were added to allow the ARM to dictate the location of these buffers; so make use of those messages wherever possible.
  File changes:
  s/Messaging - Remove VirtGPIOBuf and TouchBuf related tags from the initialisation tag sequence. Add new GetVCBuffer function that can be called post-MMU init to deal with getting/setting the buffer addresses.
  s/Top - Use GetVCBuffer to initialise VirtGPIOBuf
  s/Touch - Use GetVCBuffer to get touchscreen buffer
  hdr/StaticWS - Remove TouchBuf from workspace, no longer needed
Admin:
  Tested on Raspberry Pi 3 with firmware from March 2016 (Set commands not supported), 21st July 2017 (set commands supported, but upper 16MB not used), 28th July 2017 (set commands supported and necessary)


Version 0.71. Tagged as 'BCM2835-0_71'
@
text
@d109 1
a109 3
        MRC     p15, 0, r4, c0, c0, 0          ; read Main ID Register
        AND     r4, r4, #&FF00
        CMP     r4, #&C000                     ; xxxxB76x for ARM1176, xxxxC07x for Cortex-A7
@


1.12
log
@Add support for CM3 and CM3L with or without eMMC
The SDIO HAL device reports when it is sure fixed disc media is attached (ie. eMMC soldered on the same PCB) which causes SDFS to report this to FileCore as a fixed disc, skipping the removable safety checks.
However, CM3 and CM3L both return the same board id so we can't work out which is which. Additionally, someone could attach an external eMMC in theory on a custom expansion board (instead of an SD card socket like the CMIO has).
To resolve this, we assign IO expander line 6 of U8 to be a safety catch. If that line is held low, it signifies this is definitely a CM3 - in effect this is a "definitely has eMMC" or "maybe has eMMC" switch.

Tested on CM1, CM3, CM3L, and a suitably modified CM3 with the help of Chris Hall.

Version 0.69. Tagged as 'BCM2835-0_69'
@
text
@d40 1
d43 1
d55 1
a143 4
        LDR     r0, [r5, #virtgpio-tagb]
        LDR     r1, [r5, #touchbuf-tagb]
        STR     r0, VirtGPIOBuf
        STR     r1, TouchBuf
d221 140
a407 4
        DCD     ARM2VC_Tag_FBGetTouchBuf
        DCD     4
        DCD     0
touchbuf DCD    0
a413 4
        DCD     ARM2VC_Tag_GetVirtGPIOBuf
        DCD     4
        DCD     0
virtgpio DCD    0
@


1.12.2.1
log
@Initial SMP support
Detail:
  hdr/BCM2835 - Delete unused timer macros. Add basic spinlock claim/release macros. Add CPUDetect macro to encapsulate ARM11 vs. A7/A53 detection. Add definitions for the "QA7" interrupts.
  Makefile, s/DBell - Add doorbell device driver
  hdr/StaticWS - Reserve workspace for doorbell device, QA7 interrupt controller ptr, spinlock
  s/Top, hdr/CastleMacros - Generate two HAL entry point tables, one for ARM11, one for A7/A53. Use CPUDetect macro. Implement new SMP-related HAL entry points.
  s/Interrupts - Implement support for the QA7 interrupt controller and the new IRQ-related HAL entry points
  s/Messaging - Use CPUDetect macro
Admin:
  Tested on Raspberry Pi 1, 2, 3


Version 0.70, 1.70.2.1. Tagged as 'BCM2835-0_70-1_70_2_1'
@
text
@d106 3
a108 1
        CPUDetect r4
@


1.12.2.2
log
@Merge in latest HEAD
Detail:
  Merge in changes since BCM2835-0_70 to keep SMP branch up to date
Admin:
  Untested


Version 0.71, 1.70.2.2. Tagged as 'BCM2835-0_71-1_70_2_2'
@
text
@a39 1
        $GetMEMM
a41 1
        GET     hdr.CastleMacros
a52 1
        EXPORT  GetVCBuffer
d139 4
a219 140
; In:
;   a1 = GET tag to fetch buffer for
;   a2 = buffer size
;   a3 = corresponding SET tag
; Out:
;   a1 = buffer logical address, 0 if not present
;   a2-a4, ip corrupt
;
; Query the VC for a data buffer. Historically the VC has dictated the locations
; of these buffers, but at some point the ability was added for the ARM to
; dictate the address to the GPU. With recent firmware versions, use of this
; feature is now mandatory, as on systems with 1GB of RAM the firmware will now
; attempt to make use of the upper 16MB of RAM (which overlaps the ARM's IO
; space, making it inaccessible to the ARM)
;
; Annoyingly, the main tags we're interested in don't follow the usual pattern
; of adding &8000 in order to convert a GET request to a SET, so we require both
; the GET and SET values to be explicitly specified.
GetVCBuffer     ROUT
      [ HALDebug
        STR     lr, [sp, #-4]!
        BL      %FT01
        BL      HAL_DebugHexTX4
        BL      HAL_DebugTXStrInline
        DCB     "log",10,0
        ALIGN
        LDR     pc, [sp], #4
01
      ]
        STMFD   sp!, {a1-a2, lr}
      [ HALDebug
        BL      HAL_DebugHexTX4
        BL      HAL_DebugTXStrInline
        DCB     "GetVCBuffer",10,0
        ALIGN
      ]
        MOV     a1, a3                  ; Start off with the SET request
        ; Reserve space for the buffer in NCNB workspace
        LDR     ip, NCNBPhysAddr
        LDR     a4, NCNBAddr
        MOV     a3, a2
        MOV     lr, #0
10
        SUBS    a3, a3, #4
        STRGE   lr, [a4, a3]            ; Ensure buffer memory is zeroed, just in case ARM/VC is confused by any previous content (like a tag buffer from a previous call to GetVCBuffer). E.g. recent firmware versions will allow you to get/set the FT5406 touchscreen buffer, even if the touchscreen isn't connected.
        BGT     %BT10
        ADD     a3, ip, a2
        ADD     a4, a4, a2
        ; Now construct a message tag block after it
        ADD     a3, a3, #15             ; Align for mailbox use
        ADD     a4, a4, #15
        BIC     a3, a3, #15
        BIC     a4, a4, #15
        STR     a1, [a4, #8]            ; Tag
        MOV     a1, #7*4
        MOV     a2, #0
        STMIA   a4!, {a1, a2}           ; Total length, out flags
        MOV     a1, #4
        MOV     a2, #4
        MOV     lr, #ARM2VC_Tag_End
        STMIB   a4, {a1, a2, ip, lr}    ; Tag length, in length, in data, terminator
        MOV     a2, a3
        MOV     a1, #MB_Chan_ARM2VC
        BL      HAL_SendHostMessage
      [ HALDebug
        LDR     a1, [a4, #-8]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #-4]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #0]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #4]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #8]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #12]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #16]
        BL      HAL_DebugHexTX4
        BL      HAL_DebugTXStrInline
        DCB     "set",10,0
        ALIGN
      ]
        ; On success, firmware should overwrite the address with zero
        LDR     a1, [a4, #12]
        CMP     a1, #0
        BNE     %FT50
        ; Buffer set success; update NCNB claim and return the claimed addr
        LDMIA   sp!, {a1-a2, lr}
        LDR     a1, NCNBAddr
        LDR     ip, NCNBPhysAddr
        ADD     a3, a1, a2
        ADD     ip, ip, a2
        STR     a3, NCNBAddr
        STR     ip, NCNBPhysAddr
        MOV     pc, lr
50
        ; Buffer set failure. Try getting the address instead.
        MOV     a1, #7*4
        MOV     a2, #0
        STMDB   a4, {a1, a2}            ; Total length, out flags
        LDR     a1, [sp]
        MOV     a2, #4
        MOV     ip, #0
        MOV     lr, #0
        STMIA   a4, {a1, a2, ip, lr}    ; Tag, tag length, in length, in data
                                        ; n.b. assuming terminator word still in place!
        MOV     a2, a3
        MOV     a1, #MB_Chan_ARM2VC
        BL      HAL_SendHostMessage
      [ HALDebug
        LDR     a1, [a4, #-8]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #-4]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #0]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #4]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #8]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #12]
        BL      HAL_DebugHexTX4
        LDR     a1, [a4, #16]
        BL      HAL_DebugHexTX4
        BL      HAL_DebugTXStrInline
        DCB     "get",10,0
        ALIGN
      ]
        ; On success, firmware should write non-zero address
        LDR     a1, [a4, #12]
        BICS    a1, a1, #&c0000000      ; Convert to ARM phys addr
        LDMIA   sp!, {a2-a3, lr}        ; Junk stacked a1-a2, but also loads a2 into correct reg for OS_MapInIO
        MOVEQ   pc, lr
        ; Buffer exists, map it in
        MOV     a2, a1
        MOV     a1, #1:SHL:L1_TEXShift  ; VMSA Normal, non-cacheable
        CallOS  OS_MapInIO, tailcall
        

d267 4
d277 4
@


1.11
log
@Refactor early GPU queries
Remove the baffling double indirection of RamAd (and unused exports SerNo and MacAdd), and treat these the same as the other pre-HAL_Init query results.
This means the scope of the tagbuffer is limited to Messaging.s, rather than having to be kept preserved globally.
Use memcpy() to copy tag list to tagbuffer for clarity.
Tested on a Pi 3.

Version 0.68. Tagged as 'BCM2835-0_68'
@
text
@d192 23
d287 25
@


1.10
log
@Fix for register corruption
In HAL_QueryPlatform a mixture of register naming overlooks r6 (aka v3) gets used, but not preserved.
Uppercase opcodes, add a few more comments around the CRC calculation.
@
text
@a53 3
        EXPORT  MacAdd
        EXPORT  RamAd
        EXPORT  SerNo
d116 1
a116 4
lp1     ldr     r3, [r0], #4                   ; copy to workspace buffer
        str     r3, [r1], #4
        subs    r2, r2, #4
        bgt     lp1        
d118 1
a118 1
        adrl    r1, tagbuffer
a124 1
        LDR     r0, [r5, #touchbuf-tagb]
d127 4
a130 1
        STR     r0, TouchBuf
d142 1
d144 1
d146 3
a148 9
        ; copy out and construct machine ID from MAC address
        ADRL    r0, tagbuffer
        ADD     r0, r0,#:INDEX:MAClo-:INDEX:tagb

        ADRL    a3, workspace
        ADRL    lr,MacAdd
        LDR     lr, [lr]
        ADD     a3, a3, lr

a198 5
MacAdd  DCD     :INDEX:MAClo  - :INDEX:tagb + :INDEX:tagbuffer   
RamAd   DCD     :INDEX:ARMbs  - :INDEX:tagb + :INDEX:tagbuffer
SerNo   DCD     :INDEX:SNlo   - :INDEX:tagb + :INDEX:tagbuffer


d203 2
a204 1
tagmac  DCD     ARM2VC_Tag_GetBoardMAC
d209 1
a209 1
tagserial
d215 1
a215 1
tagarmmem
d221 1
a221 1
tagvcmem
d227 1
a227 1
tagboardmodel
d232 1
a232 1
tagboardrev
d237 1
a237 1
tagdmachans
@


1.9
log
@Fix SD card activity LED on Pi 3B
Detail:
  hdr/BCM2835 - Remove mailbox definitions - use the ones exported by BCMSupport to avoid needless duplication
  hdr/StaticWS, s/Messaging, s/Top - Use the mailbox property interface to request & map in the virtual GPIO buffer (if present)
  s/SDIO - On the Pi 3B, the GPIO that was used for the SD activity GPIO is now used for a different purpose. To control the activity LED we need to go via an I2C attached GPIO extender, which itself is exposed to the ARM via the new "virtual GPIO" buffer
  s/VCHIQ - Update to use BCMSupport mailbox definitions
Admin:
  Tested on Pi 1B, 3B


Version 0.54. Tagged as 'BCM2835-0_54'
@
text
@d58 1
a58 2

; send a message packet to the host and await the reply
d103 1
a103 1
        STMFD   R13!, {r0-r5, lr}
d105 2
a106 2
        bl      HAL_DebugTXStrInline
        DCB     "HalQueryPl",10,0
d109 6
a114 6
        mrc     p15, 0, r4, c0, c0, 0          ; read Main ID Register
        and     r4, r4, #&FF00
        cmp     r4, #&C000                     ; xxxxB76x for ARM1176, xxxxC07x for Cortex-A7
        movcc   r4, #GPU_L2CnonAl              ; Pi 1 has L2 cache enabled
        movcs   r4, #GPU_UnCached              ; Pi 2 has L2 cache disabled
        str     r4, FB_CacheMode               ; remember base of bus addresses (i.e. memory accessed by GPU and GPU peripherals like DMA and USB)
d116 3
a118 3
        adrl    r1, tagbuffer
        adr     r0, tagb
        mov     r2, #tagslen
d167 1
a167 1
        ORR     a1, a1, #&81
d169 2
a170 2
; now encapsulate with crc
        MOV     a3, #0                 ;
d201 2
a202 2
        bl      HAL_DebugTXStrInline
        DCB     "HalQueryPldone",10,0
d205 1
a205 1
        LDMFD   R13!, {r0-r5, pc}
d212 1
a212 2
; series of VC side query tags. Using inline code as this is writable at this 
; stage. This means the answers will be encapsulated in rom image!!
@


1.8
log
@Fix Pi 3 UART clock rate. Add HAL device for the GPU mailboxes.
Detail:
  s/Messaging - Ensure the PL011 UART module clock is set to 3MHz on startup, in order to allow the debug terminal to work
  hdr/StaticWS, s/Top - Add a basic HAL device to expose the GPU mailboxes
Admin:
  Tested on Raspberry Pi 1B/2B/3B
  Fixes garbled debug terminal input/output on Pi 3


Version 0.52. Tagged as 'BCM2835-0_52'
@
text
@d34 1
d36 4
d146 2
d270 5
@


1.7
log
@Add basic HAL device for the official DSI display/touchscreen. Delete superfluous code.
Detail:
  Makefile, s/Touch - Basic HAL device for the official touchscreen, which just exposes the address of the buffer which the GPU periodically fills with a register dump of the touchscreen controller.
  hdr/BCM2835 - Remove old comment. Add new tag for getting the touchscreen buffer address.
  hdr/StaticWS - Remove old workspace entries. Add new entries for touchscreen.
  s/Messaging - Remove the messagebox tags which set a screen mode on startup (BCMVideo will handle that for us), and just blank the screen instead (to stop the GPU displaying a coloured square). Add tag to get the touchscreen buffer address.
  s/Top - Register touchscreen HAL device during HAL_InitDevices. Remove more old code.
Admin:
  Tested on Raspberry Pi 1 B


Version 0.50. Tagged as 'BCM2835-0_50'
@
text
@d34 1
d45 1
d48 1
d257 6
d266 44
a309 1
     
d311 25
@


1.6
log
@  Add support for Raspberry Pi Compute module and Raspberry Pi 2
Detail:
  * Compute module support consists of eMMC support in the SDHCI driver. The
    eMMC chip on the Compute module only works reliably if under-clocked to
    25 MHz.
  * Pi 1 vs Pi 2 differences are selected at runtime by checking the CPU ID,
    so a single ROM image will work with both boards.
  * Added ARMv7 cache maintenance routine for use on Pi 2.
  * The physical address of the peripherals has moved in Pi 2 to make space
    for the 1 GB of RAM.
  * The ARM physical address space is mapped differently onto the GPU
    address space in Pi 2 because the ARM now uses the L2 cache that comes
    with the Cortex-A7 instead of the GPU's L2 cache.
  * Still waiting for confirmation on the board revision ID that will be
    used for Pi 2, so may require further tweaks for production releases.


Version 0.40. Tagged as 'BCM2835-0_40'
@
text
@a48 1
        EXPORT  Displ
d124 1
d127 1
a127 10
        ADD     r0,r5,#Dispbs-tagb             ; frame buffer address and size
        LDMIA   r0, {r1, r2}
        STR     r1, FB_Base
        STR     r2, FB_Size
 [ HALDebug
     mov a1,a2
     bl HAL_DebugHexTX4
     mov a1,a3
     bl HAL_DebugHexTX4
 ]
a200 1
Displ   DCD     :INDEX:Dispbs - :INDEX:tagb + :INDEX:tagbuffer
d246 1
a246 25
tagdisplphyswh
        DCD     ARM2VC_Tag_FBSetPhysDimension
        DCD     8
        DCD     8
phyx    DCD     1920
        DCD     1080
tagdisplvirtwh
        DCD     ARM2VC_Tag_FBSetVirtDimension
        DCD     8
        DCD     8
virtx   DCD     1920
        DCD     1080
tagdisplvirtoffset
        DCD     ARM2VC_Tag_FBSetVirtOffset
        DCD     8
        DCD     8
vxoff   DCD     0
        DCD     0
tagdispldepth           
        DCD     ARM2VC_Tag_FBSetDepth
        DCD     4
        DCD     4
dispbpp DCD     32                 ; 32bit
tagdisplpixord           
        DCD     ARM2VC_Tag_FBSetPixelOrder
d249 2
a250 8
        DCD     1                  ; RGB
tagdisplalpha           
        DCD     ARM2VC_Tag_FBSetAlphaMode
        DCD     4
        DCD     4
        DCD     2                  ; channel 1=alpha reversed 2=ignore
taggetpitch           
        DCD     ARM2VC_Tag_FBGetPitch
d253 1
a253 8
dispit  DCD     0
tagdisplalloc           
        DCD     ARM2VC_Tag_FBAlloc
        DCD     8
        DCD     8
Dispbs  DCD     0x100000            ; megabyte aligned
Dispsz  DCD     0           
        DCD     ARM2VC_Tag_End
@


1.5
log
@Add a video HAL device to allow BCMVideo to determine which DMA channel it can use for render ops
Detail:
  hdr/StaticWS, s/Top, s/Video - Added a simple VDU HAL device that exposes a DMA channel to BCMVideo for use with GraphicsV_Render
  hdr/BCM2835 - Don't allow DMA channel 12 to be used; latest firmware seems to have a bug which claims its free when in reality it isn't.
  s/Messaging, s/DMA - Adjust DMA init to allow the video device to claim a DMA channel before the DMA devices are initialised
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.25. Tagged as 'BCM2835-0_25'
@
text
@d61 1
a61 1
        FlushDataCache r3
d103 6
a108 2
        mov     r4, #GPU_L2CnonAl              ; L2 Cache off mode
        str     r4, FB_CacheMode               ; remember
@


1.4
log
@Read board model, revision, and available DMA channels from messaging channel. Report board revision via GPIO HAL device. Recover lost ROM relocation code.
Detail:
  hdr/StaticWS, s/Messaging, s/Top - Now reads board model, revision and available DMA channels from messaging channel
  hdr/StaticWS, s/GPIO - Updated GPIO HAL device to report board revision instead of a generic response of 'unknown'
  s/Top - Recovered ROM relocation code that got lost during a merge. End of ROM image no longer being corrupted, and RISC OS now sees correct amount of RAM.
  s/DMA - Ditch old code to read available DMA channels and use value read by HAL_QueryPlatform instead.
Admin:
  Tested on Raspberry Pi (B rev 1) with various start.elf sizes & versions
  DMA channel reporting only available with latest firmware (i.e. 8th Sep)
  Board revision number read by messaging channel seems to match that returned by /proc/cpuinfo on Linux


Version 0.22. Tagged as 'BCM2835-0_22'
@
text
@d138 4
@


1.3
log
@Strip out video code & on-screen debug
Detail:
  Makefile, s/Display - Deleted on-screen debug code
  hdr/BCM2835, hdr/StaticWS, s/IIC, s/Messaging, s/Stubs, s/Top, s/UART - Strip out calls to on-screen debug code, and a few bits of video code
  s/Video - Video code removed and replaced with stub functions similar to other HALs. Only remaining useful code is HAL_Video_StartupMode, which in time should probably be moved to BCMVideo as well.
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.21. Tagged as 'BCM2835-0_21'
@
text
@d93 2
d133 6
a207 2
; CURRENT ASSIGNED SPACE 256 bytes.. BEWARE
;
d232 16
a247 1
VCsz    DCD     0        
d294 1
a294 1

@


1.2
log
@Detail:  Frame buffer allocation via message channel almost complete. working
        HAL_MachineID functioning correctly
Admin:


Version 0.15. Tagged as 'BCM2835-0_15'
@
text
@d40 1
a40 4
        IMPORT  output_hex8
        IMPORT  output_newline
        IMPORT  output_text
        IMPORT  output_text_at
a43 1

d117 4
a123 1
        STR     r1, mbbase
a124 34
        STR     r2, mbscrsz
 [ HALDebug
     mov a1,a2
     bl HAL_DebugHexTX4
     mov a1,a3
     bl HAL_DebugHexTX4
 ]

        add     r0,r5,#phyx-tagb               ; physical screen dimensions
        LDMIA   r0, {r1, r2}
        STR     r1, mbxres
        STR     r2, mbyres
 [ HALDebug
     mov a1,a2
     bl HAL_DebugHexTX4
     mov a1,a3
     bl HAL_DebugHexTX4
 ]
        
        add     r0,r5,#virtx-tagb               ; virtual screen dimensions
        LDMIA   r0, {r1, r2}
        STR     r1, mbxvres
        STR     r2, mbyvres
 [ HALDebug
     mov a1,a2
     bl HAL_DebugHexTX4
     mov a1,a3
     bl HAL_DebugHexTX4
 ]
        
        add     r0,r5,#vxoff-tagb               ; virtual screen offset
        LDMIA   r0, {r1, r2}
        STR     r1, mbxoff
        STR     r2, mbyoff
a130 14
        
        add     r0,r5,#dispbpp-tagb             ; bits per pixel
        LDR     r0, [r0]
        STR     r0, mbbpp
 [ HALDebug
     bl HAL_DebugHexTX4
 ]

        add     r0,r5,#dispit-tagb              ; display pitch
        LDR     r0, [r0]
        STR     r0, mbpitch
 [ HALDebug
     bl HAL_DebugHexTX4
 ]
d191 4
a194 4
MacAdd  DCD     :INDEX:MAClo - :INDEX:tagb + :INDEX:tagbuffer   
RamAd   DCD     :INDEX:ARMbs - :INDEX:tagb + :INDEX:tagbuffer
SerNo   DCD     :INDEX:SNlo  - :INDEX:tagb + :INDEX:tagbuffer
Displ   DCD     :INDEX:Dispbs  - :INDEX:tagb + :INDEX:tagbuffer
@


1.1
log
@
	Various updates to do with the messaging channel, HAL_MachineID, and HAL_Reset

Detail:
	HAL_Reset now causes a complete reboot of the machiine. It isnt yet properly called from
	the kernel.. I've not investigated why yet. Behaviour tested using OS_Hardware call

	HAL_MachineID, with the github start.elf from 18 July 2012 will provide a valid MAC address ..
	i.e. that specific to this machine. The a1 value in HAL_ExtendedID needs to be set 0 for this to be reported
	by OS_ReadSysInfo .. unfortunately, again at this stage, it stalls the boot when set 0, so just for now
	the committed value for a1 in HAL_ExtendedID is not 0 .

	centralised messaging routine added. This is used a fair bit in acquiring the operating environment
	Not yet used in the DMA stuff. probably ought to be. At present the messaging channel this mainly
	handles is not complete, so information from this code is still WIP

Admin:
  (highlight level of testing that has taken place)
  (bugfix number if appropriate)


Version 0.14. Tagged as 'BCM2835-0_14'
@
text
@d105 4
a108 1
        adrl     r1, tagbuffer
d111 1
a111 1
lp1     ldr     r3, [r0], #4
d115 1
a115 2
        mov     r4, #&40000000                 ; L2 Cache off mode
        str     r4, FB_CacheMode
d118 15
a132 1
        BL      HAL_SendHostMessage
d134 34
a167 2
        ADRL    r0, tagbuffer
        add     r0,r0,#Dispbs-tagb
d169 1
a169 1
;        LDR     r0, Dispbs
d171 1
a171 1
        bl      HAL_DebugHexTX4
d173 2
a174 3
        STR     r0, FB_Base
        ADRL    r0, tagbuffer
        add     r0, r0,#:INDEX:Dispsz-:INDEX:tagb
d176 1
a176 1
;        LDR     r0, Dispsz
d178 1
a178 1
        bl      HAL_DebugHexTX4
d180 53
a237 1

a238 4
        EXPORT MacAdd
        EXPORT RamAd
        EXPORT SerNo
        EXPORT Displ
d280 1
a280 1
        DCD     1920
d286 1
a286 1
        DCD     1920
d292 1
a292 1
        DCD     0
d298 1
a298 1
        DCD     32                 ; 32bit
d313 1
a313 1
        DCD     0                 
@


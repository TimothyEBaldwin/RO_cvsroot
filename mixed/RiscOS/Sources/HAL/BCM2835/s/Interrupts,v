head	1.6;
access;
symbols
	BCM2835-0_75-1:1.5
	BCM2835-0_76:1.6
	BCM2835-0_75-1_70_2_4:1.5.2.1
	BCM2835-0_75:1.5
	BCM2835-0_74:1.5
	BCM2835-0_73-1_70_2_3:1.5.2.1
	BCM2835-0_73:1.5
	BCM2835-0_72:1.5
	BCM2835-0_71-1_70_2_2:1.5.2.1
	BCM2835-0_71:1.5
	BCM2835-0_70-1_70_2_1:1.5.2.1
	SMP:1.5.0.2
	SMP_bp:1.5
	BCM2835-0_70:1.5
	BCM2835-0_69:1.5
	BCM2835-0_68:1.5
	BCM2835-0_67:1.5
	BCM2835-0_66:1.5
	BCM2835-0_65:1.5
	BCM2835-0_64:1.5
	BCM2835-0_63:1.5
	BCM2835-0_62:1.5
	BCM2835-0_61:1.5
	BCM2835-0_60:1.5
	BCM2835-0_59:1.5
	BCM2835-0_58:1.5
	BCM2835-0_57:1.5
	BCM2835-0_56:1.5
	BCM2835-0_55:1.5
	BCM2835-0_53:1.5
	BCM2835-0_52:1.5
	BCM2835-0_51:1.5
	BCM2835-0_50:1.5
	BCM2835-0_49:1.5
	BCM2835-0_48:1.5
	BCM2835-0_47:1.5
	BCM2835-0_46:1.5
	BCM2835-0_45:1.5
	BCM2835-0_44:1.5
	BCM2835-0_43:1.5
	BCM2835-0_42:1.5
	BCM2835-0_41:1.5
	BCM2835-0_40:1.5
	BCM2835-0_39:1.5
	BCM2835-0_38:1.5
	BCM2835-0_37:1.5
	BCM2835-0_36:1.5
	BCM2835-0_35:1.5
	BCM2835-0_34:1.5
	BCM2835-0_33:1.4
	BCM2835-0_32:1.4
	BCM2835-0_31:1.4
	BCM2835-0_30:1.4
	BCM2835-0_29:1.4
	BCM2835-0_28:1.3
	BCM2835-0_27:1.3
	BCM2835-0_26:1.3
	BCM2835-0_25:1.3
	BCM2835-0_24:1.3
	BCM2835-0_23:1.3
	BCM2835-0_22:1.3
	BCM2835-0_21:1.3
	BCM2835-0_20:1.3
	BCM2835-0_19:1.3
	BCM2835-0_18:1.3
	BCM2835-0_17:1.3
	BCM2835-0_16:1.3
	BCM2835-0_15:1.3
	BCM2835-0_14:1.3
	BCM2835-0_13:1.3
	BCM2835-0_12:1.3
	BCM2835-0_11:1.3
	BCM2835-0_10:1.3
	BCM2835-0_09:1.3
	BCM2835-0_08:1.2
	BCM2835-0_07:1.2
	BCM2835-0_06:1.2
	BCM2835-0_05:1.1
	BCM2835-0_04:1.1;
locks; strict;
comment	@# @;


1.6
date	2018.07.07.14.26.23;	author jlee;	state Exp;
branches;
next	1.5;
commitid	VQCRRsJLbDt0fdJA;

1.5
date	2014.06.19.21.03.18;	author jlee;	state Exp;
branches
	1.5.2.1;
next	1.4;
commitid	EcK8j6AjJmkFYaFx;

1.4
date	2013.01.22.23.28.51;	author jlee;	state Exp;
branches;
next	1.3;
commitid	rTORMrQfEY7XggBw;

1.3
date	2012.06.15.14.40.20;	author bavison;	state Exp;
branches;
next	1.2;
commitid	GozidpkBTrLSrO8w;

1.2
date	2012.05.24.11.30.09;	author bavison;	state Exp;
branches;
next	1.1;
commitid	ktC5TlFk2flF6Y5w;

1.1
date	2012.05.23.21.45.10;	author bavison;	state Exp;
branches;
next	;
commitid	dyGUTwLbAf3ExT5w;

1.5.2.1
date	2017.07.29.11.37.43;	author jlee;	state Exp;
branches;
next	;
commitid	leIbdlwVfACHk71A;


desc
@@


1.6
log
@Merge SMP branch to trunk
Detail:
  hdr/StaticWS - Reserve workspace for QA7 peripheral address, HAL-wide spinlock, and doorbell device
  Makefile, s/DBell - Add doorbell device implementation
  hdr/BCM2835 - Clean up dead macros, add new macros for spinlock claim/release and basic CPU detection. Define new IRQ numbers for the "QA7" peripheral.
  hdr/CastleMacros, s/Top - Generate two HAL descriptors and entry point tables: One for single-core machines and one for multi-core machines. This avoids some MP-related overheads on ARM11 models of Pi. Implement SMP HAL entry points.
  s/Interrupts - Add support for the QA7 interrupts. Although some interrupts can be flexibly routed to different cores, we currently stick with a static scheme.
  s/Messaging - Use CPUDetect macro
Admin:
  Untested
  Requires Kernel-6_09


Version 0.76. Tagged as 'BCM2835-0_76'
@
text
@;
; Copyright (c) 2012, RISC OS Open Ltd
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met: 
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in the
;       documentation and/or other materials provided with the distribution.
;     * Neither the name of RISC OS Open Ltd nor the names of its contributors
;       may be used to endorse or promote products derived from this software
;       without specific prior written permission.
; 
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.
;

        EXPORT  Interrupt_Init
        EXPORT  HAL_IRQClear
        EXPORT  HAL_FIQClear

        EXPORT  ARM11_HAL_IRQEnable
        EXPORT  ARM11_HAL_IRQDisable
        EXPORT  ARM11_HAL_IRQSource
        EXPORT  ARM11_HAL_IRQStatus
        EXPORT  ARM11_HAL_FIQEnable
        EXPORT  ARM11_HAL_FIQDisable
        EXPORT  ARM11_HAL_FIQDisableAll
        EXPORT  ARM11_HAL_FIQSource
        EXPORT  ARM11_HAL_FIQStatus
        EXPORT  ARM11_HAL_IRQMax
        EXPORT  ARM11_HAL_IRQProperties

        EXPORT  QA7_HAL_IRQEnable
        EXPORT  QA7_HAL_IRQDisable
        EXPORT  QA7_HAL_IRQSource
        EXPORT  QA7_HAL_IRQStatus
        EXPORT  QA7_HAL_FIQEnable
        EXPORT  QA7_HAL_FIQDisable
        EXPORT  QA7_HAL_FIQDisableAll
        EXPORT  QA7_HAL_FIQSource
        EXPORT  QA7_HAL_FIQStatus
        EXPORT  QA7_HAL_IRQMax
        EXPORT  QA7_HAL_IRQProperties
        EXPORT  QA7_HAL_IRQSetCores
        EXPORT  QA7_HAL_IRQGetCores

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        
        GET     hdr.BCM2835
        GET     hdr.StaticWS


        AREA    |ARM$$code|, CODE, READONLY, PIC


; One-time initialisation
        
Interrupt_Init
        LDR     a1, PeriBase
        ADD     a1, a1, #IRQ_Base
        STR     a1, IRQ_Base_Address      
        MOV     pc, lr


QA7_HAL_IRQEnable ROUT
        CMP     a1, #iDev_QA7_Max
        BHS     ExitZero
        SUBS    a2, a1, #iDev_QA7_Base
        BLT     HAL_IRQEnable_GPU
        MOV     a4, #1                ; Signal this is an IRQ enable event
ToggleIRQ
        AND     a3, a2, #3            ; Extract core number
        MOV     a2, a2, LSR #2        ; Bit/device number
        LDR     a1, QA7_Base
        AcquireSpinlock
        ADD     pc, pc, a2, LSL #2
        NOP
        B       ToggleIRQ_CNTPSIRQ
        B       ToggleIRQ_CNTPNSIRQ
        B       ToggleIRQ_CNTPHPIRQ
        B       ToggleIRQ_CNTPVIRQ
        B       ToggleIRQ_MBox0
        B       ToggleIRQ_MBox1
        B       ToggleIRQ_MBox2     
        B       ToggleIRQ_MBox3     
        B       ToggleIRQ_GPU       
        B       ToggleIRQ_PMU       
        B       ToggleIRQ_AXI       
        B       ToggleIRQ_LocalTimer

ToggleIRQ_MBox0
ToggleIRQ_MBox1
ToggleIRQ_MBox2     
ToggleIRQ_MBox3
        ADD     a1, a1, #QA7_CORE0_MBOX_INT_CTRL-QA7_CORE0_TIMER_INT_CTRL     
ToggleIRQ_CNTPSIRQ
ToggleIRQ_CNTPNSIRQ
ToggleIRQ_CNTPHPIRQ
ToggleIRQ_CNTPVIRQ ROUT
        ; Work out bit number
        AND     a2, a2, #3
        TST     a4, #2
        MOVEQ   ip, #1
        MOVNE   ip, #16
        MOV     ip, ip, LSL a2
        ; Work out the register number
        ADD     a1, a1, a3, LSL #2
        ; Grab the state
        LDR     a2, [a1, #QA7_CORE0_TIMER_INT_CTRL]
        ; Calc new state
        ; Note that this is a trivial implementation which doesn't attempt to do anything special to deal with the case that having FIQ enabled will mask the IRQ
        TST     a4, #1
        BICEQ   a4, a2, ip
        ORRNE   a4, a2, ip
        STR     a4, [a1, #QA7_CORE0_TIMER_INT_CTRL]
        ; Calc old state, ignoring that FIQs will mask IRQs
        AND     a1, a2, ip
        ReleaseSpinlock
        MOV     pc, lr

ToggleIRQ_GPU ROUT
        ; Get old status
        LDR     a2, [a1, #QA7_GPU_INT_ROUTING]
        ; Calc new status (can only claim, not release)
        TST     a4, #1
        BEQ     %FT30
        TST     a4, #2
        MOV     ip, a2
        BFIEQ   ip, a3, #0, #2
        BFINE   ip, a3, #2, #2
        STR     ip, [a1, #QA7_GPU_INT_ROUTING]
30
        ReleaseSpinlock
        ; Calc old state
        TST     a4, #2
        MOVNE   a2, a2, LSR #2
        AND     a2, a2, #3
        CMP     a2, a3
        MOVEQ   a1, #1
        MOVNE   a1, #0
        MOV     pc, lr

ToggleIRQ_PMU ROUT
        ; Grab the old state before we overwrite it
        LDR     a2, [a1, #QA7_PMU_INT_ROUT_CLR]
        ; Calculate the bit to toggle
        ; Note that this is a trivial implementation which doesn't attempt to do anything special to deal with the case that having FIQ enabled will mask the IRQ
        TST     a4, #2
        MOVEQ   ip, #1
        MOVNE   ip, #16
        MOV     ip, ip, LSL a3
        ; Calculate the register to write to
        TST     a4, #1 ; EQ: Disable, NE: Enable
        ADDEQ   a1, a1, #QA7_PMU_INT_ROUT_CLR
        ADDNE   a1, a1, #QA7_PMU_INT_ROUT_SET
        STR     ip, [a1]
        ; Calc old state, ignoring that FIQs will mask IRQs
        AND     a1, a2, ip
        ReleaseSpinlock
        MOV     pc, lr

ToggleIRQ_AXI ROUT
        ; Only supported for core 0 IRQ
        TEQ     a3, #0
        TSTEQ   a4, #2
        BNE     ReleaseExitZero
        LDR     a2, [a1, #QA7_AXI_OUTSTANDING_IRQ]
        MOV     a3, a2
        BFI     a3, a4, #20, #1
        STR     a3, [a1, #QA7_AXI_OUTSTANDING_IRQ]
        AND     a1, a2, #1<<20
        ReleaseSpinlock
        MOV     pc, lr

ToggleIRQ_LocalTimer ROUT
        ; Calculate required routing value
        AND     ip, a4, #2
        ORR     a3, a3, ip, LSL #1
        ; Get old status
        LDR     a2, [a1, #QA7_LOCAL_INT_ROUTING]
        ; Can only claim, not release
        TST     a4, #1
        BEQ     %FT40
        MOV     a4, a2
        BFI     a4, a3, #0, #3
        STR     a4, [a1, #QA7_LOCAL_INT_ROUTING]
40
        ReleaseSpinlock
        ; Calc old state
        AND     a4, a4, #7
        CMP     a4, a3
        MOVEQ   a1, #1
        MOVNE   a1, #0

ARM11_HAL_IRQEnable ROUT
        CMP     a1, #iDev_ARM11_Max
        BHS     ExitZero
HAL_IRQEnable_GPU
        DoMemBarrier ip
        LDR     ip, IRQ_Base_Address
        ADD     ip, ip, #IRQ_EN1
        MOV     a2, #1
        AND     a3, a1, #&1F         ; get bit in register
        MOV     a2, a2, LSL a3       ; bitmask
        MOV     a3, a1, LSR #5       ; shift to get relevant register
        LDR     a4, [ip, a3, LSL #2] ; get old enable mask
        STR     a2, [ip, a3, LSL #2] ; enable our bit
        AND     a1, a2, a4           ; test our bit in old mask
        DoMemBarrier ip
        MOV     pc, lr

ReleaseExitZero
        ReleaseSpinlock
ExitZero
        MOV     a1, #0
        MOV     pc, lr

QA7_HAL_IRQDisable ROUT
        CMP     a1, #iDev_QA7_Max
        BHS     ExitZero
        SUBS    a2, a1, #iDev_QA7_Base
        BLT     HAL_IRQDisable_GPU
        MOV     a4, #0                ; Signal this is an IRQ disable event
        B       ToggleIRQ

ARM11_HAL_IRQDisable
        CMP     a1, #iDev_ARM11_Max
        BHS     ExitZero
HAL_IRQDisable_GPU
        DoMemBarrier ip
        LDR     ip, IRQ_Base_Address
        ADD     ip, ip, #IRQ_DIS1
        MOV     a2, #1
        AND     a3, a1, #&1F         ; get bit in register
        MOV     a2, a2, LSL a3       ; bitmask
        MOV     a3, a1, LSR #5       ; shift to get relevant register
        LDR     a4, [ip, a3, LSL #2] ; get old enable mask
        STR     a2, [ip, a3, LSL #2] ; disable our bit
        AND     a1, a2, a4           ; test our bit in old mask
        DoMemBarrier ip
        MOV     pc, lr

HAL_IRQClear
HAL_FIQClear
        ; There is no latching of interrupts in this interrupt controller,
        ; so nothing to clear
        MOV     pc, lr

QA7_GPU_IRQ_bit * 1<<((iDev_QA7_GPU-iDev_QA7_Base)>>2)

QA7_HAL_IRQSource
        DoMemBarrier ip
        LDR     a2, QA7_Base
        MRC     p15, 0, a1, c0, c0, 5 ; Read MPIDR
        AND     a3, a1, #3            ; Extract core number
        ASSERT  QA7_CORE1_IRQ_SOURCE-QA7_CORE0_IRQ_SOURCE = 4
        ADD     a2, a2, a3, LSL #2
        LDR     a2, [a2, #QA7_CORE0_IRQ_SOURCE]
        ADD     a3, a3, #iDev_QA7_Base
        ; Prioritise core-specific interrupts over general ones
        BIC     a1, a2, #QA7_GPU_IRQ_bit
        CLZ     a1, a1
        RSBS    a1, a1, #31
        ADDPL   a1, a3, a1, LSL #2
        BPL     %FT90
        TST     a2, #QA7_GPU_IRQ_bit
        BEQ     %FT90 ; No GPU interrupt, so must be spurious? (a1 already -1)
        ; Fall through to read GPU interrupt source
ARM11_HAL_IRQSource
        DoMemBarrier ip
        LDR     a2, IRQ_Base_Address
        LDRB    a1, [a2, #IRQ_PENDB]  ; note, LDRB so we ignore bits 8-31
        CLZ     a1, a1
        RSBS    a1, a1, #31
        ADDPL   a1, a1, #iDev_ARM_Timer ; 64
        BPL     %FT90
        LDR     a1, [a2, #IRQ_PEND2]
        CLZ     a1, a1
        RSBS    a1, a1, #31
        ADDPL   a1, a1, #iDev_GPU_HostPort ; 32
        BPL     %FT90
        LDR     a1, [a2, #IRQ_PEND1]
        CLZ     a1, a1
        RSB     a1, a1, #31
90
        DoMemBarrier ip
        MOV     pc, lr

QA7_HAL_IRQStatus ROUT
        CMP     a1, #iDev_QA7_Max
        BHS     ExitZero
        SUBS    a3, a1, #iDev_QA7_Base
        BLT     %FT50
        DoMemBarrier ip
        LDR     a2, QA7_Base
        AND     a1, a3, #3            ; Extract core number
        MOV     a3, a3, LSR #2        ; Bit/device number
        ASSERT  QA7_CORE1_IRQ_SOURCE-QA7_CORE0_IRQ_SOURCE = 4
        ADD     a2, a2, a1, LSL #2
        LDR     a2, [a2, #QA7_CORE0_IRQ_SOURCE]
        MOV     a2, a2, LSR a3
        AND     a2, a2, #1
        DoMemBarrier ip
        MOV     pc, lr        

ARM11_HAL_IRQStatus
        ; This interrupt controller does not allow us to see the status of the interrupt request
        ; lines prior to masking by the interrupt enable register, which is the defined result
        ; of this call. The closest we can do is checking whether the stated device is interrupting.
        CMP     a1, #iDev_ARM11_Max
        BHS     ExitZero
50
        DoMemBarrier ip
        LDR     ip, IRQ_Base_Address
        ASSERT  IRQ_PENDB = 0
        MOV     a2, #1
        AND     a3, a1, #&1F         ; get bit in register
        MOV     a2, a2, LSL a3       ; bitmask
        MOV     a3, a1, LSR #5       ; shift to get relevant register
        SUBS    a3, a3, #2           ; rotate register because pending regs are in a different order
        ADDMI   a3, a3, #3
        LDR     a4, [ip, a3, LSL #2] ; get pending mask
        AND     a1, a2, a4           ; test our bit
        DoMemBarrier ip
        MOV     pc, lr

FIQEnable       *       1<<7
FIQSourceMask   *       &7F

QA7_HAL_FIQEnable ROUT
        CMP     a1, #iDev_QA7_Max
        BHS     ExitZero
        SUBS    a2, a1, #iDev_QA7_Base
        BLT     HAL_FIQEnable_GPU
        MOV     a4, #3                ; Signal this is a FIQ enable event
        B       ToggleIRQ

ARM11_HAL_FIQEnable
        CMP     a1, #iDev_ARM11_Max
        BHS     ExitZero
HAL_FIQEnable_GPU
        DoMemBarrier ip
        LDR     ip, IRQ_Base_Address
        
        LDRB    a3, [ip, #IRQ_FIQCTL]   ; LDRB helpfully masks out bits 8-31 for us
        ORR     a4, a1, #FIQEnable
        TEQ     a3, a4                  ; Z set => FIQs already enabled
        STR     a4, [ip, #IRQ_FIQCTL]
        
        MOVEQ   a1, #1
        MOVNE   a1, #0
        DoMemBarrier ip
        MOV     pc, lr

QA7_HAL_FIQDisable ROUT
        CMP     a1, #iDev_QA7_Max
        BHS     ExitZero
        SUBS    a2, a1, #iDev_QA7_Base
        BLT     HAL_FIQDisable_GPU
        MOV     a4, #2                ; Signal this is a FIQ disable event
        B       ToggleIRQ

ARM11_HAL_FIQDisable
        CMP     a1, #iDev_ARM11_Max
        BHS     ExitZero
HAL_FIQDisable_GPU
        DoMemBarrier ip
        LDR     ip, IRQ_Base_Address
       
        LDRB    a3, [ip, #IRQ_FIQCTL] ; LDRB helpfully masks out bits 8-31 for us
        ORR     a4, a1, #FIQEnable
        TEQ     a3, a4                  ; Z set => FIQs already enabled
        MOV     a4, #0
        STR     a4, [ip, #IRQ_FIQCTL]
        
        MOVEQ   a1, #1
        MOVNE   a1, #0
        DoMemBarrier ip
        MOV     pc, lr

QA7_HAL_FIQDisableAll ROUT
        LDR     a1, QA7_Base
        MRC     p15, 0, a3, c0, c0, 5 ; Read MPIDR
        AND     a3, a3, #3            ; Extract core number
        ; Disable PMU FIQ for this core
        MOV     ip, #16
        MOV     ip, ip, LSR a3
        STR     ip, [a1, #QA7_PMU_INT_ROUT_CLR]
        AcquireSpinlock
        ; Disable timer FIQs for this core
        ADD     ip, a1, a3, LSL #2
        LDR     a4, [ip, #QA7_CORE0_TIMER_INT_CTRL]
        BIC     a4, a4, #&F0
        STR     a4, [ip, #QA7_CORE0_TIMER_INT_CTRL]
        ; Disable mailbox FIQs for this core
        LDR     a4, [ip, #QA7_CORE0_MBOX_INT_CTRL]
        BIC     a4, a4, #&F0
        STR     a4, [ip, #QA7_CORE0_MBOX_INT_CTRL]
        ; If we own the local timer, disable its interrupt bit
        LDR     a4, [a1, #QA7_LOCAL_INT_ROUTING]
        AND     a4, a4, #7
        EOR     a4, a4, a3
        CMP     a4, #4
        BNE     %FT10
        LDR     a4, [a1, #QA7_LOCAL_TIMER_CTRL_STAT]
        TST     a4, #1<<29
        BEQ     %FT10
        BIC     a4, a4, #1<<29
        STR     a4, [a1, #QA7_LOCAL_TIMER_CTRL_STAT]
10
        ; Determine if we own the GPU FIQs
        LDR     a1, [a1, #QA7_GPU_INT_ROUTING]
        ReleaseSpinlock
        UBFX    a1, a1, #2, #2
        CMP     a1, a3
        MOVNE   pc, lr                  ; We're not the owner, so leave them alone
        ; We are the GPU FIQ owner, so fall through to GPU FIQ disable code
        ; (n.b. race condition here if another core tries to claim the GPU FIQs)

ARM11_HAL_FIQDisableAll
        DoMemBarrier ip
        LDR     ip, IRQ_Base_Address
        LDR     a1, [ip, #IRQ_FIQCTL]
        DoMemBarrier a2
        TST     a1, #FIQEnable
        MOVEQ   pc, lr                  ; FIQs weren't enabled
        
        MOV     a4, #0
        STR     a4, [ip, #IRQ_FIQCTL]
        DoMemBarrier ip
        MOV     pc, lr

QA7_HAL_FIQSource
        DoMemBarrier ip
        LDR     a2, QA7_Base
        MRC     p15, 0, a1, c0, c0, 5 ; Read MPIDR
        AND     a3, a1, #3            ; Extract core number
        ASSERT  QA7_CORE1_FIQ_SOURCE-QA7_CORE0_FIQ_SOURCE = 4
        ADD     a2, a2, a3, LSL #2
        LDR     a2, [a2, #QA7_CORE0_FIQ_SOURCE]
        ADD     a3, a3, #iDev_QA7_Base
        ; Prioritise core-specific interrupts over general ones
        BIC     a1, a2, #QA7_GPU_IRQ_bit
        CLZ     a1, a1
        RSBS    a1, a1, #31
        ADDPL   a1, a3, a1, LSL #2
        BPL     %FT90
        TST     a2, #QA7_GPU_IRQ_bit
        BEQ     %FT90 ; No GPU interrupt, so must be spurious? (a1 already -1)
        ; Fall through to read GPU interrupt source
ARM11_HAL_FIQSource
        ; There can only be one, the configured FIQ device
        DoMemBarrier ip
        LDR     ip, IRQ_Base_Address
        LDR     a1, [ip, #IRQ_FIQCTL]
        AND     a1, a1, #FIQSourceMask
90
        DoMemBarrier ip
        MOV     pc, lr

QA7_HAL_FIQStatus ROUT
        CMP     a1, #iDev_QA7_Max
        BHS     ExitZero
        SUBS    a3, a1, #iDev_QA7_Base ; For GPU interrupts just skip straight to reading the pending registers (shouldn't really matter whether we own the GPU FIQ or not)
        BLT     %FT50
        DoMemBarrier ip
        LDR     a2, QA7_Base
        AND     a1, a3, #3            ; Extract core number
        MOV     a3, a3, LSR #2        ; Bit/device number
        ASSERT  QA7_CORE1_FIQ_SOURCE-QA7_CORE0_FIQ_SOURCE = 4
        ADD     a2, a2, a1, LSL #2
        LDR     a2, [a2, #QA7_CORE0_FIQ_SOURCE]
        MOV     a2, a2, LSR a3
        AND     a2, a2, #1
        DoMemBarrier ip
        MOV     pc, lr        

ARM11_HAL_FIQStatus
        ; As per HAL_IRQStatus, we can't see the true status of the interrupt,
        ; only whether it's currently firing.
        CMP     a1, #iDev_ARM11_Max
        BHS     ExitZero
50
        DoMemBarrier ip
        LDR     ip, IRQ_Base_Address
        LDR     a2, [ip, #IRQ_FIQCTL]
        AND     a2, a2, #FIQSourceMask
        CMP     a1, a2
        MOVEQ   a1, #1
        MOVNE   a1, #0
        DoMemBarrier ip
        MOV     pc, lr

ARM11_HAL_IRQMax
        MOV     a1, #iDev_ARM11_Max
        MOV     pc, lr

QA7_HAL_IRQMax
        MOV     a1, #iDev_QA7_Max
        MOV     pc, lr

; In: a1 = device number
; Out: a1 = IRQ mask
;      a2 = FIQ mask
;           bits 0-29 of each register give cores that the interrupt can be
;           assigned to
;           bit 30 = private flag
;           bit 31 = interrupt can be routed to multiple cores at once
QA7_HAL_IRQProperties
        CMP     a1, #iDev_QA7_Max
        MOVHS   a1, #0
        MOVHS   a2, #0
        MOVHS   pc, lr
        SUBS    a2, a1, #iDev_ARM11_Max
        BLO     ARM11_HAL_IRQProperties
        ; For now, just pretend that all the QA7 interrupts are core-specific
        ; In reality some of them can be switched (e.g. local timer)
        AND     a2, a2, #3 ; Get core number
        MOV     a1, #1
        MOV     a1, a1, LSL a2
        MOV     a2, a1
        MOV     pc, lr

ARM11_HAL_IRQProperties
        ; ARM_MiscGPU1 and above can't be used for FIQ
        CMP     a1, #iDev_ARM_MiscGPU1
        MOVHS   a2, #0
        MOVLO   a2, #1
        CMP     a1, #iDev_ARM11_Max
        MOVHS   a1, #0
        MOVLO   a1, #1
        MOV     pc, lr

; In: a1 = device number
;     a2 = desired core mask
; Out: a1 = actual core mask
QA7_HAL_IRQSetCores
QA7_HAL_IRQGetCores ; read-only version of IRQSetCores
        CMP     a1, #iDev_QA7_Max
        BHS     ExitZero
        SUBS    a2, a1, #iDev_ARM11_Max
        MOV     a1, #1
        ANDHS   a2, a2, #3
        MOVHS   a1, a1, LSL a2
        MOV     pc, lr

        END
@


1.5
log
@Add support code required for DWCDriver 'FIQ fix'
Detail:
  hdr/BCM2835, hdr/USB, s/USB - Update HAL_USBControllerInfo to return the MPHI address & IRQ number
  s/Interrupts - Add some missing memory barriers. Change FIQ enable/disable calls to not alter IRQ masking of the interrupt - simplifies the code and avoids any ordering issues with code that switches interrupts between IRQ & FIQ
  s/Timers - Add missing memory barrier
Admin:
  Tested on Raspberry Pi
  Requires Kernel-5_35-4_79_2_227 to build


Version 0.34. Tagged as 'BCM2835-0_34'
@
text
@a29 2
        EXPORT  HAL_IRQEnable
        EXPORT  HAL_IRQDisable
a30 5
        EXPORT  HAL_IRQSource
        EXPORT  HAL_IRQStatus
        EXPORT  HAL_FIQEnable
        EXPORT  HAL_FIQDisable
        EXPORT  HAL_FIQDisableAll
a31 3
        EXPORT  HAL_FIQSource
        EXPORT  HAL_FIQStatus
        EXPORT  HAL_IRQMax
d33 25
d79 77
a155 3
HAL_IRQEnable
        CMN     a1,#1
        MOVEQ   pc,lr
d157 56
d226 18
a243 4
HAL_IRQDisable
        CMN     a1,#1
        MOVEQ   pc,lr

d263 21
a283 1
HAL_IRQSource
d303 18
a320 2
HAL_IRQStatus
HAL_FIQStatus
d324 3
a326 3
        CMN     a1,#1
        MOVEQ   pc,lr

d344 12
a355 4
HAL_FIQEnable
        CMN     a1,#1
        MOVEQ   pc,lr

d369 12
a380 4
HAL_FIQDisable
        CMN     a1,#1
        MOVEQ   pc,lr

d395 40
a434 1
HAL_FIQDisableAll
d447 19
a465 1
HAL_FIQSource
d471 34
d508 6
a513 2
HAL_IRQMax
        MOV     a1, #iDev_Max
d516 44
@


1.5.2.1
log
@Initial SMP support
Detail:
  hdr/BCM2835 - Delete unused timer macros. Add basic spinlock claim/release macros. Add CPUDetect macro to encapsulate ARM11 vs. A7/A53 detection. Add definitions for the "QA7" interrupts.
  Makefile, s/DBell - Add doorbell device driver
  hdr/StaticWS - Reserve workspace for doorbell device, QA7 interrupt controller ptr, spinlock
  s/Top, hdr/CastleMacros - Generate two HAL entry point tables, one for ARM11, one for A7/A53. Use CPUDetect macro. Implement new SMP-related HAL entry points.
  s/Interrupts - Implement support for the QA7 interrupt controller and the new IRQ-related HAL entry points
  s/Messaging - Use CPUDetect macro
Admin:
  Tested on Raspberry Pi 1, 2, 3


Version 0.70, 1.70.2.1. Tagged as 'BCM2835-0_70-1_70_2_1'
@
text
@d30 2
d33 5
d39 3
a42 25
        EXPORT  ARM11_HAL_IRQEnable
        EXPORT  ARM11_HAL_IRQDisable
        EXPORT  ARM11_HAL_IRQSource
        EXPORT  ARM11_HAL_IRQStatus
        EXPORT  ARM11_HAL_FIQEnable
        EXPORT  ARM11_HAL_FIQDisable
        EXPORT  ARM11_HAL_FIQDisableAll
        EXPORT  ARM11_HAL_FIQSource
        EXPORT  ARM11_HAL_FIQStatus
        EXPORT  ARM11_HAL_IRQMax
        EXPORT  ARM11_HAL_IRQProperties

        EXPORT  QA7_HAL_IRQEnable
        EXPORT  QA7_HAL_IRQDisable
        EXPORT  QA7_HAL_IRQSource
        EXPORT  QA7_HAL_IRQStatus
        EXPORT  QA7_HAL_FIQEnable
        EXPORT  QA7_HAL_FIQDisable
        EXPORT  QA7_HAL_FIQDisableAll
        EXPORT  QA7_HAL_FIQSource
        EXPORT  QA7_HAL_FIQStatus
        EXPORT  QA7_HAL_IRQMax
        EXPORT  QA7_HAL_IRQProperties
        EXPORT  QA7_HAL_IRQSetCores
        EXPORT  QA7_HAL_IRQGetCores
d64 3
a66 77
QA7_HAL_IRQEnable ROUT
        CMP     a1, #iDev_QA7_Max
        BHS     ExitZero
        SUBS    a2, a1, #iDev_QA7_Base
        BLT     HAL_IRQEnable_GPU
        MOV     a4, #1                ; Signal this is an IRQ enable event
ToggleIRQ
        AND     a3, a2, #3            ; Extract core number
        MOV     a2, a2, LSR #2        ; Bit/device number
        LDR     a1, QA7_Base
        AcquireSpinlock
        ADD     pc, pc, a2, LSL #2
        NOP
        B       ToggleIRQ_CNTPSIRQ
        B       ToggleIRQ_CNTPNSIRQ
        B       ToggleIRQ_CNTPHPIRQ
        B       ToggleIRQ_CNTPVIRQ
        B       ToggleIRQ_MBox0
        B       ToggleIRQ_MBox1
        B       ToggleIRQ_MBox2     
        B       ToggleIRQ_MBox3     
        B       ToggleIRQ_GPU       
        B       ToggleIRQ_PMU       
        B       ToggleIRQ_AXI       
        B       ToggleIRQ_LocalTimer

ToggleIRQ_MBox0
ToggleIRQ_MBox1
ToggleIRQ_MBox2     
ToggleIRQ_MBox3
        ADD     a1, a1, #QA7_CORE0_MBOX_INT_CTRL-QA7_CORE0_TIMER_INT_CTRL     
ToggleIRQ_CNTPSIRQ
ToggleIRQ_CNTPNSIRQ
ToggleIRQ_CNTPHPIRQ
ToggleIRQ_CNTPVIRQ ROUT
        ; Work out bit number
        AND     a2, a2, #3
        TST     a4, #2
        MOVEQ   ip, #1
        MOVNE   ip, #16
        MOV     ip, ip, LSL a2
        ; Work out the register number
        ADD     a1, a1, a3, LSL #2
        ; Grab the state
        LDR     a2, [a1, #QA7_CORE0_TIMER_INT_CTRL]
        ; Calc new state
        ; Note that this is a trivial implementation which doesn't attempt to do anything special to deal with the case that having FIQ enabled will mask the IRQ
        TST     a4, #1
        BICEQ   a4, a2, ip
        ORRNE   a4, a2, ip
        STR     a4, [a1, #QA7_CORE0_TIMER_INT_CTRL]
        ; Calc old state, ignoring that FIQs will mask IRQs
        AND     a1, a2, ip
        ReleaseSpinlock
        MOV     pc, lr

ToggleIRQ_GPU ROUT
        ; Get old status
        LDR     a2, [a1, #QA7_GPU_INT_ROUTING]
        ; Calc new status (can only claim, not release)
        TST     a4, #1
        BEQ     %FT30
        TST     a4, #2
        MOV     ip, a2
        BFIEQ   ip, a3, #0, #2
        BFINE   ip, a3, #2, #2
        STR     ip, [a1, #QA7_GPU_INT_ROUTING]
30
        ReleaseSpinlock
        ; Calc old state
        TST     a4, #2
        MOVNE   a2, a2, LSR #2
        AND     a2, a2, #3
        CMP     a2, a3
        MOVEQ   a1, #1
        MOVNE   a1, #0
        MOV     pc, lr
a67 56
ToggleIRQ_PMU ROUT
        ; Grab the old state before we overwrite it
        LDR     a2, [a1, #QA7_PMU_INT_ROUT_CLR]
        ; Calculate the bit to toggle
        ; Note that this is a trivial implementation which doesn't attempt to do anything special to deal with the case that having FIQ enabled will mask the IRQ
        TST     a4, #2
        MOVEQ   ip, #1
        MOVNE   ip, #16
        MOV     ip, ip, LSL a3
        ; Calculate the register to write to
        TST     a4, #1 ; EQ: Disable, NE: Enable
        ADDEQ   a1, a1, #QA7_PMU_INT_ROUT_CLR
        ADDNE   a1, a1, #QA7_PMU_INT_ROUT_SET
        STR     ip, [a1]
        ; Calc old state, ignoring that FIQs will mask IRQs
        AND     a1, a2, ip
        ReleaseSpinlock
        MOV     pc, lr

ToggleIRQ_AXI ROUT
        ; Only supported for core 0 IRQ
        TEQ     a3, #0
        TSTEQ   a4, #2
        BNE     ReleaseExitZero
        LDR     a2, [a1, #QA7_AXI_OUTSTANDING_IRQ]
        MOV     a3, a2
        BFI     a3, a4, #20, #1
        STR     a3, [a1, #QA7_AXI_OUTSTANDING_IRQ]
        AND     a1, a2, #1<<20
        ReleaseSpinlock
        MOV     pc, lr

ToggleIRQ_LocalTimer ROUT
        ; Calculate required routing value
        AND     ip, a4, #2
        ORR     a3, a3, ip, LSL #1
        ; Get old status
        LDR     a2, [a1, #QA7_LOCAL_INT_ROUTING]
        ; Can only claim, not release
        TST     a4, #1
        BEQ     %FT40
        MOV     a4, a2
        BFI     a4, a3, #0, #3
        STR     a4, [a1, #QA7_LOCAL_INT_ROUTING]
40
        ReleaseSpinlock
        ; Calc old state
        AND     a4, a4, #7
        CMP     a4, a3
        MOVEQ   a1, #1
        MOVNE   a1, #0

ARM11_HAL_IRQEnable ROUT
        CMP     a1, #iDev_ARM11_Max
        BHS     ExitZero
HAL_IRQEnable_GPU
d81 4
a84 18
ReleaseExitZero
        ReleaseSpinlock
ExitZero
        MOV     a1, #0
        MOV     pc, lr

QA7_HAL_IRQDisable ROUT
        CMP     a1, #iDev_QA7_Max
        BHS     ExitZero
        SUBS    a2, a1, #iDev_QA7_Base
        BLT     HAL_IRQDisable_GPU
        MOV     a4, #0                ; Signal this is an IRQ disable event
        B       ToggleIRQ

ARM11_HAL_IRQDisable
        CMP     a1, #iDev_ARM11_Max
        BHS     ExitZero
HAL_IRQDisable_GPU
d104 1
a104 21
QA7_GPU_IRQ_bit * 1<<((iDev_QA7_GPU-iDev_QA7_Base)>>2)

QA7_HAL_IRQSource
        DoMemBarrier ip
        LDR     a2, QA7_Base
        MRC     p15, 0, a1, c0, c0, 5 ; Read MPIDR
        AND     a3, a1, #3            ; Extract core number
        ASSERT  QA7_CORE1_IRQ_SOURCE-QA7_CORE0_IRQ_SOURCE = 4
        ADD     a2, a2, a3, LSL #2
        LDR     a2, [a2, #QA7_CORE0_IRQ_SOURCE]
        ADD     a3, a3, #iDev_QA7_Base
        ; Prioritise core-specific interrupts over general ones
        BIC     a1, a2, #QA7_GPU_IRQ_bit
        CLZ     a1, a1
        RSBS    a1, a1, #31
        ADDPL   a1, a3, a1, LSL #2
        BPL     %FT90
        TST     a2, #QA7_GPU_IRQ_bit
        BEQ     %FT90 ; No GPU interrupt, so must be spurious? (a1 already -1)
        ; Fall through to read GPU interrupt source
ARM11_HAL_IRQSource
d124 2
a125 18
QA7_HAL_IRQStatus ROUT
        CMP     a1, #iDev_QA7_Max
        BHS     ExitZero
        SUBS    a3, a1, #iDev_QA7_Base
        BLT     %FT50
        DoMemBarrier ip
        LDR     a2, QA7_Base
        AND     a1, a3, #3            ; Extract core number
        MOV     a3, a3, LSR #2        ; Bit/device number
        ASSERT  QA7_CORE1_IRQ_SOURCE-QA7_CORE0_IRQ_SOURCE = 4
        ADD     a2, a2, a1, LSL #2
        LDR     a2, [a2, #QA7_CORE0_IRQ_SOURCE]
        MOV     a2, a2, LSR a3
        AND     a2, a2, #1
        DoMemBarrier ip
        MOV     pc, lr        

ARM11_HAL_IRQStatus
d129 3
a131 3
        CMP     a1, #iDev_ARM11_Max
        BHS     ExitZero
50
d149 4
a152 12
QA7_HAL_FIQEnable ROUT
        CMP     a1, #iDev_QA7_Max
        BHS     ExitZero
        SUBS    a2, a1, #iDev_QA7_Base
        BLT     HAL_FIQEnable_GPU
        MOV     a4, #3                ; Signal this is a FIQ enable event
        B       ToggleIRQ

ARM11_HAL_FIQEnable
        CMP     a1, #iDev_ARM11_Max
        BHS     ExitZero
HAL_FIQEnable_GPU
d166 4
a169 12
QA7_HAL_FIQDisable ROUT
        CMP     a1, #iDev_QA7_Max
        BHS     ExitZero
        SUBS    a2, a1, #iDev_QA7_Base
        BLT     HAL_FIQDisable_GPU
        MOV     a4, #2                ; Signal this is a FIQ disable event
        B       ToggleIRQ

ARM11_HAL_FIQDisable
        CMP     a1, #iDev_ARM11_Max
        BHS     ExitZero
HAL_FIQDisable_GPU
d184 1
a184 40
QA7_HAL_FIQDisableAll ROUT
        LDR     a1, QA7_Base
        MRC     p15, 0, a3, c0, c0, 5 ; Read MPIDR
        AND     a3, a3, #3            ; Extract core number
        ; Disable PMU FIQ for this core
        MOV     ip, #16
        MOV     ip, ip, LSR a3
        STR     ip, [a1, #QA7_PMU_INT_ROUT_CLR]
        AcquireSpinlock
        ; Disable timer FIQs for this core
        ADD     ip, a1, a3, LSL #2
        LDR     a4, [ip, #QA7_CORE0_TIMER_INT_CTRL]
        BIC     a4, a4, #&F0
        STR     a4, [ip, #QA7_CORE0_TIMER_INT_CTRL]
        ; Disable mailbox FIQs for this core
        LDR     a4, [ip, #QA7_CORE0_MBOX_INT_CTRL]
        BIC     a4, a4, #&F0
        STR     a4, [ip, #QA7_CORE0_MBOX_INT_CTRL]
        ; If we own the local timer, disable its interrupt bit
        LDR     a4, [a1, #QA7_LOCAL_INT_ROUTING]
        AND     a4, a4, #7
        EOR     a4, a4, a3
        CMP     a4, #4
        BNE     %FT10
        LDR     a4, [a1, #QA7_LOCAL_TIMER_CTRL_STAT]
        TST     a4, #1<<29
        BEQ     %FT10
        BIC     a4, a4, #1<<29
        STR     a4, [a1, #QA7_LOCAL_TIMER_CTRL_STAT]
10
        ; Determine if we own the GPU FIQs
        LDR     a1, [a1, #QA7_GPU_INT_ROUTING]
        ReleaseSpinlock
        UBFX    a1, a1, #2, #2
        CMP     a1, a3
        MOVNE   pc, lr                  ; We're not the owner, so leave them alone
        ; We are the GPU FIQ owner, so fall through to GPU FIQ disable code
        ; (n.b. race condition here if another core tries to claim the GPU FIQs)

ARM11_HAL_FIQDisableAll
d197 1
a197 19
QA7_HAL_FIQSource
        DoMemBarrier ip
        LDR     a2, QA7_Base
        MRC     p15, 0, a1, c0, c0, 5 ; Read MPIDR
        AND     a3, a1, #3            ; Extract core number
        ASSERT  QA7_CORE1_FIQ_SOURCE-QA7_CORE0_FIQ_SOURCE = 4
        ADD     a2, a2, a3, LSL #2
        LDR     a2, [a2, #QA7_CORE0_FIQ_SOURCE]
        ADD     a3, a3, #iDev_QA7_Base
        ; Prioritise core-specific interrupts over general ones
        BIC     a1, a2, #QA7_GPU_IRQ_bit
        CLZ     a1, a1
        RSBS    a1, a1, #31
        ADDPL   a1, a3, a1, LSL #2
        BPL     %FT90
        TST     a2, #QA7_GPU_IRQ_bit
        BEQ     %FT90 ; No GPU interrupt, so must be spurious? (a1 already -1)
        ; Fall through to read GPU interrupt source
ARM11_HAL_FIQSource
a202 34
90
        DoMemBarrier ip
        MOV     pc, lr

QA7_HAL_FIQStatus ROUT
        CMP     a1, #iDev_QA7_Max
        BHS     ExitZero
        SUBS    a3, a1, #iDev_QA7_Base ; For GPU interrupts just skip straight to reading the pending registers (shouldn't really matter whether we own the GPU FIQ or not)
        BLT     %FT50
        DoMemBarrier ip
        LDR     a2, QA7_Base
        AND     a1, a3, #3            ; Extract core number
        MOV     a3, a3, LSR #2        ; Bit/device number
        ASSERT  QA7_CORE1_FIQ_SOURCE-QA7_CORE0_FIQ_SOURCE = 4
        ADD     a2, a2, a1, LSL #2
        LDR     a2, [a2, #QA7_CORE0_FIQ_SOURCE]
        MOV     a2, a2, LSR a3
        AND     a2, a2, #1
        DoMemBarrier ip
        MOV     pc, lr        

ARM11_HAL_FIQStatus
        ; As per HAL_IRQStatus, we can't see the true status of the interrupt,
        ; only whether it's currently firing.
        CMP     a1, #iDev_ARM11_Max
        BHS     ExitZero
50
        DoMemBarrier ip
        LDR     ip, IRQ_Base_Address
        LDR     a2, [ip, #IRQ_FIQCTL]
        AND     a2, a2, #FIQSourceMask
        CMP     a1, a2
        MOVEQ   a1, #1
        MOVNE   a1, #0
d206 2
a207 6
ARM11_HAL_IRQMax
        MOV     a1, #iDev_ARM11_Max
        MOV     pc, lr

QA7_HAL_IRQMax
        MOV     a1, #iDev_QA7_Max
a209 44
; In: a1 = device number
; Out: a1 = IRQ mask
;      a2 = FIQ mask
;           bits 0-29 of each register give cores that the interrupt can be
;           assigned to
;           bit 30 = private flag
;           bit 31 = interrupt can be routed to multiple cores at once
QA7_HAL_IRQProperties
        CMP     a1, #iDev_QA7_Max
        MOVHS   a1, #0
        MOVHS   a2, #0
        MOVHS   pc, lr
        SUBS    a2, a1, #iDev_ARM11_Max
        BLO     ARM11_HAL_IRQProperties
        ; For now, just pretend that all the QA7 interrupts are core-specific
        ; In reality some of them can be switched (e.g. local timer)
        AND     a2, a2, #3 ; Get core number
        MOV     a1, #1
        MOV     a1, a1, LSL a2
        MOV     a2, a1
        MOV     pc, lr

ARM11_HAL_IRQProperties
        ; ARM_MiscGPU1 and above can't be used for FIQ
        CMP     a1, #iDev_ARM_MiscGPU1
        MOVHS   a2, #0
        MOVLO   a2, #1
        CMP     a1, #iDev_ARM11_Max
        MOVHS   a1, #0
        MOVLO   a1, #1
        MOV     pc, lr

; In: a1 = device number
;     a2 = desired core mask
; Out: a1 = actual core mask
QA7_HAL_IRQSetCores
QA7_HAL_IRQGetCores ; read-only version of IRQSetCores
        CMP     a1, #iDev_QA7_Max
        BHS     ExitZero
        SUBS    a2, a1, #iDev_ARM11_Max
        MOV     a1, #1
        ANDHS   a2, a2, #3
        MOVHS   a1, a1, LSL a2
        MOV     pc, lr
@


1.4
log
@Implement HAL_IRQMax
Detail:
  hdr/BCM2835 - Add definition for highest IRQ number
  s/Boot, s/Interrupts - Added HAL_IRQMax implementation, to ensure correct functionality with latest Kernel
Admin:
  Tested on 256MB Pi model B
  Requires Kernel-5_35-4_79_2_182


Version 0.29. Tagged as 'BCM2835-0_29'
@
text
@d111 1
a111 1
        MOVPL   pc, lr
d116 1
a116 1
        MOVPL   pc, lr
d120 1
a160 7
        ADD     ip, ip, #IRQ_EN1
        MOV     a2, #1
        AND     a3, a1, #&1F            ; get bit in register
        MOV     a2, a2, LSL a3          ; bitmask
        MOV     a3, a1, LSR #5          ; shift to get relevant register
        STR     a2, [ip, a3, LSL #2]    ; enable our bit
        
d172 2
a173 9
        
        ADD     ip, ip, #IRQ_DIS1
        MOV     a2, #1
        AND     a3, a1, #&1F            ; get bit in register
        MOV     a2, a2, LSL a3          ; bitmask
        MOV     a3, a1, LSR #5          ; shift to get relevant register
        STR     a2, [ip, a3, LSL #2]    ; disable our bit
        
        LDRB    a3, [ip, #IRQ_FIQCTL-IRQ_DIS1] ; LDRB helpfully masks out bits 8-31 for us
d177 1
a177 1
        STR     a4, [ip, #IRQ_FIQCTL-IRQ_DIS1]
a191 7
        AND     a1, a1, #FIQSourceMask
        ADD     ip, ip, #IRQ_DIS1
        MOV     a2, #1
        AND     a3, a1, #&1F            ; get bit in register
        MOV     a2, a2, LSL a3          ; bitmask
        MOV     a3, a1, LSR #5          ; shift to get relevant register
        STR     a2, [ip, a3, LSL #2]    ; disable our bit
d193 1
a193 1
        STR     a4, [ip, #IRQ_FIQCTL-IRQ_DIS1]
@


1.3
log
@  SD support, and miscellaneous other changes
Detail:
  * Bugfix to HAL_FIQDisableAll - it wasn't clearing the FIQ register (would
    only have caused trouble in practice if the same device was subsequently
    enabled as an IRQ).
  * Added a load of memory barriers to s.Interrupts and s.Timers to conform
    to the requirement stated in 1.3 of the datasheet.
  * Added a HAL device for the Arasan SDHCI controller. Note that this does
    not currently work reliably, and results vary from card to card. High
    speed support is currently disabled until we are able to verify that it
    works reliably.
  * Added a sprinkling of "GET Hdr:ListOpts" because the space reserved for
    the SDHCI HAL device in hdr.StaticWS is determined by including
    Hdr:HALDevice and Hdr:SDHCIDevice, which need it.
  * When support for saving "CMOS" to the SD card is added, the ROM image
    file (kernel.img) is the only one we can count on the bootloader
    installing in memory, so I think we're going to have to work using the
    table in s.CMOS. Broadcom seems to like messing around with the space
    just after the processor vector table, so rather than adding a pointer
    to the table there, I've opted to mark it using a magic word.
Admin:
  Tested on a Raspberry Pi - as noted above, there are reliability issues.

Version 0.09. Tagged as 'BCM2835-0_09'
@
text
@d41 1
d226 4
@


1.2
log
@  Whitespace changes
Detail:
  Substituted remaining hard spaces with normal ones and expanded tabs.
  This now matches the de facto standard for other components, and also looks
  better in the CVS web viewer.
Admin:
  No code changes

Version 0.06. Tagged as 'BCM2835-0_06'
@
text
@d67 1
d77 1
d84 1
d94 1
d104 1
d119 1
d130 1
d141 1
d151 1
d168 1
d175 1
d193 1
d197 1
d200 1
d211 3
d218 1
d222 1
@


1.1
log
@  Complete rework of timer and interrupt code
Detail:
 * Moved interrupt and timer code out of s.Stubs - they're not stubs any more.
 * Rewrote timer and counter code to use GPU system timer 1 for our Timer0
   rather than the ARM timer. This is recommended in the Broadcom datasheet
   because it's driven from the APB clock and so its speed will vary in
   reduced or low power mode.
 * HAL_CounterDelay now, well, does a delay!
 * Added a Timer1, driven from GPU system timer 3 - common code with Timer0.
 * Reshuffled device numbers so the GPU interrupts are at the bottom. This
   works better for FIQs and makes Timer0 the lowest priority interrupt.
 * Higher device numbers are now consistently treated as higher priority.
 * Stopped using bits 8-31 of the basic interrupt registers. These can't be
   masked, so they cause the kernel to lock up if generated, which happens
   if the GPU interrupt which they alias is generated (which appears to
   include the timers even though this is not documented).
 * Added definitions for all the interrupts, including those redacted from the
   datasheet - we need them at least for timers, USB and SD.
 * Stopped HAL_IRQClear from doing anything - this interrupt controller
   doesn't do latching. To acknowledge timer interrupts, you should use
   HAL_TimerIRQClear (and HAL_IRQClear too for compatibility with other ports).
 * Implemented HAL_IRQStatus and all the FIQ control routines.
 * Offsets to interrupt controller registers now use symbolic names.
 * Replaced some hard spaces in sources with normal ones.
Admin:
  Tested on a beta Raspberry Pi. Confirmed that interrupt handlers for both
  ARM and GPU sources can both be operational simultaneuosly. However, the FIQ
  code has not been tested. Timer0 is verified as running at the correct
  speed and reporting a count *down* in the correct range (not a count up as
  some previous versions did). HAL_CounterDelay appears correct also.

Version 0.04. Tagged as 'BCM2835-0_04'
@
text
@d64 2
a65 2
	CMN	a1,#1
	MOVEQ	pc,lr
d79 2
a80 2
	CMN	a1,#1
	MOVEQ	pc,lr
d121 2
a122 2
	CMN	a1,#1
	MOVEQ	pc,lr
d140 2
a141 2
	CMN	a1,#1
	MOVEQ	pc,lr
d159 1
a159 1
	MOV	pc, lr
d162 2
a163 2
	CMN	a1,#1
	MOVEQ	pc,lr
d182 1
a182 1
	MOV	pc, lr
d197 1
a197 1
	MOV	pc, lr
d204 1
a204 1
	MOV	pc, lr
@


head	1.48;
access;
symbols
	BCM2835-0_75-1:1.47
	BCM2835-0_76:1.48
	BCM2835-0_75-1_70_2_4:1.44.2.4
	BCM2835-0_75:1.47
	BCM2835-0_74:1.46
	BCM2835-0_73-1_70_2_3:1.44.2.3
	BCM2835-0_73:1.46
	BCM2835-0_72:1.46
	BCM2835-0_71-1_70_2_2:1.44.2.2
	BCM2835-0_71:1.45
	BCM2835-0_70-1_70_2_1:1.44.2.1
	SMP:1.44.0.2
	SMP_bp:1.44
	BCM2835-0_70:1.44
	BCM2835-0_69:1.44
	BCM2835-0_68:1.43
	BCM2835-0_67:1.42
	BCM2835-0_66:1.42
	BCM2835-0_65:1.41
	BCM2835-0_64:1.40
	BCM2835-0_63:1.39
	BCM2835-0_62:1.39
	BCM2835-0_61:1.39
	BCM2835-0_60:1.38
	BCM2835-0_59:1.37
	BCM2835-0_58:1.36
	BCM2835-0_57:1.36
	BCM2835-0_56:1.36
	BCM2835-0_55:1.35
	BCM2835-0_53:1.33
	BCM2835-0_52:1.33
	BCM2835-0_51:1.32
	BCM2835-0_50:1.31
	BCM2835-0_49:1.30
	BCM2835-0_48:1.29
	BCM2835-0_47:1.29
	BCM2835-0_46:1.29
	BCM2835-0_45:1.28
	BCM2835-0_44:1.27
	BCM2835-0_43:1.27
	BCM2835-0_42:1.27
	BCM2835-0_41:1.27
	BCM2835-0_40:1.27
	BCM2835-0_39:1.26
	BCM2835-0_38:1.26
	BCM2835-0_37:1.25
	BCM2835-0_36:1.25
	BCM2835-0_35:1.25
	BCM2835-0_34:1.25
	BCM2835-0_33:1.25
	BCM2835-0_32:1.25
	BCM2835-0_31:1.24
	BCM2835-0_30:1.23
	BCM2835-0_29:1.22
	BCM2835-0_28:1.21
	BCM2835-0_27:1.21
	BCM2835-0_26:1.21
	BCM2835-0_25:1.20
	BCM2835-0_24:1.19
	BCM2835-0_23:1.19
	BCM2835-0_22:1.18
	BCM2835-0_21:1.17
	BCM2835-0_20:1.16
	BCM2835-0_19:1.15
	BCM2835-0_18:1.14
	BCM2835-0_17:1.13
	BCM2835-0_16:1.12
	BCM2835-0_15:1.11
	BCM2835-0_14:1.10
	BCM2835-0_13:1.9
	BCM2835-0_12:1.8
	BCM2835-0_11:1.8
	BCM2835-0_10:1.7
	BCM2835-0_09:1.7
	BCM2835-0_08:1.6
	BCM2835-0_07:1.6
	BCM2835-0_06:1.5
	BCM2835-0_05:1.4
	BCM2835-0_04:1.3
	BCM2835-0_03:1.3
	BCM2835-0_02:1.2
	BCM2835-0_01:1.1.1.1
	initial:1.1.1.1
	Vendor:1.1.1;
locks; strict;
comment	@# @;


1.48
date	2018.07.07.14.26.23;	author jlee;	state Exp;
branches;
next	1.47;
commitid	VQCRRsJLbDt0fdJA;

1.47
date	2018.04.10.19.40.00;	author rsprowson;	state Exp;
branches;
next	1.46;
commitid	gS1OguIu1PUdNVxA;

1.46
date	2017.09.09.11.03.34;	author rool;	state Exp;
branches;
next	1.45;
commitid	APWc8oJjayEiNv6A;

1.45
date	2017.07.31.22.09.53;	author jlee;	state Exp;
branches;
next	1.44;
commitid	xk6viwRsoGpALq1A;

1.44
date	2017.02.21.22.10.55;	author rsprowson;	state Exp;
branches
	1.44.2.1;
next	1.43;
commitid	vR1YulJPaRxOURGz;

1.43
date	2017.02.21.22.00.27;	author rsprowson;	state Exp;
branches;
next	1.42;
commitid	5uukDnnvmsVeRRGz;

1.42
date	2017.01.20.22.11.34;	author jlee;	state Exp;
branches;
next	1.41;
commitid	XiXvH3kRV0JNWKCz;

1.41
date	2016.12.12.16.52.11;	author jlee;	state Exp;
branches;
next	1.40;
commitid	eiCssmFhjOiYqIxz;

1.40
date	2016.12.10.13.03.41;	author rool;	state Exp;
branches;
next	1.39;
commitid	K8noJk4vvPEyerxz;

1.39
date	2016.10.15.14.30.26;	author rsprowson;	state Exp;
branches;
next	1.38;
commitid	bv5F1PmPdmWUvfqz;

1.38
date	2016.10.15.14.05.06;	author rsprowson;	state Exp;
branches;
next	1.37;
commitid	YmZHhYYljHDenfqz;

1.37
date	2016.10.09.12.23.49;	author jlee;	state Exp;
branches;
next	1.36;
commitid	AegGZ5wtYn4r0tpz;

1.36
date	2016.03.29.19.17.48;	author jlee;	state Exp;
branches;
next	1.35;
commitid	8ywpPKB7TjU3xz0z;

1.35
date	2016.03.28.00.59.10;	author jlee;	state Exp;
branches;
next	1.34;
commitid	5C4DqTbsLnd8ul0z;

1.34
date	2016.03.26.21.29.33;	author jlee;	state Exp;
branches;
next	1.33;
commitid	R20Od6NioP8emc0z;

1.33
date	2016.03.25.19.59.14;	author jlee;	state Exp;
branches;
next	1.32;
commitid	ZKDMXPRZKhDfT30z;

1.32
date	2016.01.08.21.37.44;	author jlee;	state Exp;
branches;
next	1.31;
commitid	7xtchPkzB0cvUaQy;

1.31
date	2015.11.15.00.09.57;	author jlee;	state Exp;
branches;
next	1.30;
commitid	oJ6rSmtkg3Ajw7Jy;

1.30
date	2015.11.08.17.56.21;	author bavison;	state Exp;
branches;
next	1.29;
commitid	TjPJn9AS0Ro7EjIy;

1.29
date	2015.08.05.22.00.16;	author jlee;	state Exp;
branches;
next	1.28;
commitid	tfiAygPuGDQ738wy;

1.28
date	2015.07.26.18.58.03;	author jlee;	state Exp;
branches;
next	1.27;
commitid	n3kZvFwWGn3xmPuy;

1.27
date	2015.02.02.13.28.32;	author bavison;	state Exp;
branches;
next	1.26;
commitid	ElEkWbWLEdDg8r8y;

1.26
date	2014.10.25.17.57.07;	author rsprowson;	state Exp;
branches;
next	1.25;
commitid	6bl3CCF7UbUHPBVx;

1.25
date	2014.04.13.09.04.25;	author rsprowson;	state Exp;
branches;
next	1.24;
commitid	Xh6TDzI29rgz9vwx;

1.24
date	2013.12.19.01.29.15;	author jlee;	state Exp;
branches;
next	1.23;
commitid	9aIOPJd7daoBkGhx;

1.23
date	2013.12.15.22.16.08;	author jlee;	state Exp;
branches;
next	1.22;
commitid	T2h6gFw85uUkmhhx;

1.22
date	2013.01.22.23.28.51;	author jlee;	state Exp;
branches;
next	1.21;
commitid	rTORMrQfEY7XggBw;

1.21
date	2012.09.18.15.56.19;	author jlee;	state Exp;
branches;
next	1.20;
commitid	Q7RFVaT25YGPO1lw;

1.20
date	2012.09.18.13.49.18;	author jlee;	state Exp;
branches;
next	1.19;
commitid	kPVw3k71agHe71lw;

1.19
date	2012.09.08.23.39.47;	author jlee;	state Exp;
branches;
next	1.18;
commitid	5mzVM9Zii5AKHMjw;

1.18
date	2012.09.08.12.46.13;	author jlee;	state Exp;
branches;
next	1.17;
commitid	B5V3jq9teWHw5Jjw;

1.17
date	2012.09.02.20.03.43;	author jlee;	state Exp;
branches;
next	1.16;
commitid	FetF3i2OxxUzHZiw;

1.16
date	2012.08.28.23.12.44;	author bavison;	state Exp;
branches;
next	1.15;
commitid	BMUpqstey7aoUmiw;

1.15
date	2012.08.24.19.12.56;	author jballance;	state Exp;
branches;
next	1.14;
commitid	S2rvE3qMgEc6IPhw;

1.14
date	2012.08.08.22.51.11;	author jlee;	state Exp;
branches;
next	1.13;
commitid	FaqKbVzpT5yRqNfw;

1.13
date	2012.08.02.00.43.32;	author jlee;	state Exp;
branches;
next	1.12;
commitid	p73b1WEma91lhUew;

1.12
date	2012.07.23.23.06.50;	author jballance;	state Exp;
branches;
next	1.11;
commitid	iPi94JlBTrB72Kdw;

1.11
date	2012.07.22.22.32.53;	author jballance;	state Exp;
branches;
next	1.10;
commitid	6IVuPWq7pOksSBdw;

1.10
date	2012.07.19.10.29.28;	author jballance;	state Exp;
branches;
next	1.9;
commitid	7w2Uohftp8BdY9dw;

1.9
date	2012.07.16.23.30.43;	author jlee;	state Exp;
branches;
next	1.8;
commitid	iGPaMrXamo0goQcw;

1.8
date	2012.07.07.19.46.26;	author jlee;	state Exp;
branches;
next	1.7;
commitid	qeOmpWpRzmnerFbw;

1.7
date	2012.06.15.14.40.20;	author bavison;	state Exp;
branches;
next	1.6;
commitid	GozidpkBTrLSrO8w;

1.6
date	2012.06.03.14.03.42;	author jlee;	state Exp;
branches;
next	1.5;
commitid	xDMdy452l0MpDg7w;

1.5
date	2012.05.24.11.30.09;	author bavison;	state Exp;
branches;
next	1.4;
commitid	ktC5TlFk2flF6Y5w;

1.4
date	2012.05.24.07.18.23;	author jballance;	state Exp;
branches;
next	1.3;
commitid	VRHTZUnHjfOjIW5w;

1.3
date	2012.05.22.23.56.21;	author jballance;	state Exp;
branches;
next	1.2;
commitid	9zrOo5VjFU0EiM5w;

1.2
date	2012.05.20.20.52.51;	author jballance;	state Exp;
branches;
next	1.1;
commitid	2BhE7hfsP23Glv5w;

1.1
date	2012.05.10.14.53.41;	author bavison;	state Exp;
branches
	1.1.1.1;
next	;
commitid	9gwxHjLZncMLBb4w;

1.44.2.1
date	2017.07.29.11.37.43;	author jlee;	state Exp;
branches;
next	1.44.2.2;
commitid	leIbdlwVfACHk71A;

1.44.2.2
date	2017.07.31.22.18.18;	author jlee;	state Exp;
branches;
next	1.44.2.3;
commitid	VmVokWQ7fiZsOq1A;

1.44.2.3
date	2017.09.10.11.28.56;	author jlee;	state Exp;
branches;
next	1.44.2.4;
commitid	4Ldk9lS2jPl0UD6A;

1.44.2.4
date	2018.07.07.14.12.57;	author jlee;	state Exp;
branches;
next	;
commitid	rGMJuwVBIwKoadJA;

1.1.1.1
date	2012.05.10.14.53.41;	author bavison;	state Exp;
branches;
next	;
commitid	9gwxHjLZncMLBb4w;


desc
@@


1.48
log
@Merge SMP branch to trunk
Detail:
  hdr/StaticWS - Reserve workspace for QA7 peripheral address, HAL-wide spinlock, and doorbell device
  Makefile, s/DBell - Add doorbell device implementation
  hdr/BCM2835 - Clean up dead macros, add new macros for spinlock claim/release and basic CPU detection. Define new IRQ numbers for the "QA7" peripheral.
  hdr/CastleMacros, s/Top - Generate two HAL descriptors and entry point tables: One for single-core machines and one for multi-core machines. This avoids some MP-related overheads on ARM11 models of Pi. Implement SMP HAL entry points.
  s/Interrupts - Add support for the QA7 interrupts. Although some interrupts can be flexibly routed to different cores, we currently stick with a static scheme.
  s/Messaging - Use CPUDetect macro
Admin:
  Untested
  Requires Kernel-6_09


Version 0.76. Tagged as 'BCM2835-0_76'
@
text
@;
; Copyright (c) 2012, RISC OS Open Ltd
; Copyright (c) 2012, Adrian Lees
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met: 
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in the
;       documentation and/or other materials provided with the distribution.
;     * Neither the name of RISC OS Open Ltd nor the names of its contributors
;       may be used to endorse or promote products derived from this software
;       without specific prior written permission.
; 
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.
;
; With many thanks to Broadcom Europe Ltd for releasing the source code to
; its Linux drivers, thus making this port possible.
;

        AREA    |!!!ROMStart|, CODE, READONLY, PIC

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:HALSize.<HALSize>
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:BCMSupport

        GET     Hdr:HALEntries

        GET     hdr.BCM2835
        GET     hdr.StaticWS
        GET     hdr.CastleMacros

        IMPORT  Interrupt_Init
        IMPORT  HAL_IRQClear
        IMPORT  HAL_FIQClear
        IMPORT  ARM11_HAL_IRQEnable
        IMPORT  ARM11_HAL_IRQDisable
        IMPORT  ARM11_HAL_IRQSource
        IMPORT  ARM11_HAL_IRQStatus
        IMPORT  ARM11_HAL_FIQEnable
        IMPORT  ARM11_HAL_FIQDisable
        IMPORT  ARM11_HAL_FIQDisableAll
        IMPORT  ARM11_HAL_FIQSource
        IMPORT  ARM11_HAL_FIQStatus
        IMPORT  ARM11_HAL_IRQMax
        IMPORT  ARM11_HAL_IRQProperties
        IMPORT  QA7_HAL_IRQEnable
        IMPORT  QA7_HAL_IRQDisable
        IMPORT  QA7_HAL_IRQSource
        IMPORT  QA7_HAL_IRQStatus
        IMPORT  QA7_HAL_FIQEnable
        IMPORT  QA7_HAL_FIQDisable
        IMPORT  QA7_HAL_FIQDisableAll
        IMPORT  QA7_HAL_FIQSource
        IMPORT  QA7_HAL_FIQStatus
        IMPORT  QA7_HAL_IRQMax
        IMPORT  QA7_HAL_IRQProperties
        IMPORT  QA7_HAL_IRQSetCores
        IMPORT  QA7_HAL_IRQGetCores
                
        IMPORT  Timer_Init      
        IMPORT  HAL_Timers
        IMPORT  HAL_TimerDevice
        IMPORT  HAL_TimerGranularity
        IMPORT  HAL_TimerMaxPeriod
        IMPORT  HAL_TimerSetPeriod
        IMPORT  HAL_TimerPeriod
        IMPORT  HAL_TimerReadCountdown
        IMPORT  HAL_TimerIRQClear
                
        IMPORT  HAL_CounterRate
        IMPORT  HAL_CounterPeriod
        IMPORT  HAL_CounterRead
        IMPORT  HAL_CounterDelay

        IMPORT  IIC_Init                
        IMPORT  HAL_IICBuses
        IMPORT  HAL_IICType
        IMPORT  HAL_IICTransfer
        IMPORT  HAL_IICMonitorTransfer
                
        IMPORT  HAL_NVMemoryType
        IMPORT  HAL_NVMemorySize
        IMPORT  HAL_NVMemoryPageSize
        IMPORT  HAL_NVMemoryProtectedSize
        IMPORT  HAL_NVMemoryProtection
        IMPORT  HAL_NVMemoryRead
        IMPORT  HAL_NVMemoryWrite
                
        IMPORT  HAL_UARTPorts
        IMPORT  HAL_UARTStartUp
        IMPORT  HAL_UARTShutdown
        IMPORT  HAL_UARTFeatures
        IMPORT  HAL_UARTReceiveByte
        IMPORT  HAL_UARTTransmitByte
        IMPORT  HAL_UARTLineStatus
        IMPORT  HAL_UARTInterruptEnable
        IMPORT  HAL_UARTRate
        IMPORT  HAL_UARTFormat
        IMPORT  HAL_UARTFIFOSize
        IMPORT  HAL_UARTFIFOClear
        IMPORT  HAL_UARTFIFOEnable
        IMPORT  HAL_UARTFIFOThreshold
        IMPORT  HAL_UARTInterruptID
        IMPORT  HAL_UARTBreak
        IMPORT  HAL_UARTModemControl
        IMPORT  HAL_UARTModemStatus
        IMPORT  HAL_UARTDevice
        IMPORT  HAL_UARTDefault

 [ Debug
        IMPORT  HAL_DebugRX
        IMPORT  HAL_DebugTX
 ]

        IMPORT  HAL_PlatformName
                
        IMPORT  HAL_KbdScanDependencies

        IMPORT  HAL_USBControllerInfo

        IMPORT  SDIO_InitDevices

        IMPORT  DMA_InitDevices

        IMPORT  GPIO_InitDevices

        IMPORT  VCHIQ_InitDevices

        IMPORT  Video_InitDevices

        IMPORT  RTC_InitDevices

        IMPORT  SPI_InitDevices

        IMPORT  Touch_InitDevices

        IMPORT  BCMMBox_InitDevices

        IMPORT  DBell_InitDevices
        
        IMPORT  HAL_SendHostMessage
        IMPORT  HAL_QueryPlatform
        IMPORT  GetVCBuffer
        
        EXPORT  HAL_Base
        IMPORT  memcpy

     [ HALDebug
        EXPORT  HAL_DebugHexTX4
        EXPORT  HAL_DebugTXStrInline
     ]

        EXPORT  reset
        EXPORT  workspace

        ENTRY

HAL_Base

reset   B       start
undef   B       undefined_instr
swi     B       swi_instr
pabort  B       prefetch_abort
dabort  B       data_abort
irq     B       interrupt
fiq     B       fast_interrupt

        ; exception handlers just for use during HAL init,
        ;   in case something goes wrong
undefined_instr
        B       .
swi_instr
        B       .
prefetch_abort
        B       .
data_abort
        B       .
interrupt
        B       .
fast_interrupt
        B       .

        ALIGN   256

atags   ; list of 'atags' structures constructed here by the loader code
        ; running on VideoCore, describing
        ; - available memory
        ; - command line parameters, including framebuffer parameters

        ALIGN   4096

end_stack
workspace
        %       sizeof_workspace

        ALIGN   32768
        ASSERT  . - HAL_Base = 32768

start
        CPUDetect lr
        BCC     %F02                     ; no MPIDR or HYP mode in ARM1176

        ; Sometimes a secondary CPU gets here (indicates a bug somewhere)
        ; Prevent it doing any further damage if so
        MRC     p15, 0, lr, c0, c0, 5   ; read MPIDR
        TST     lr, #&FF
01      WFINE
        BNE     %BT01

        ; Some versions of the firmware call us in HYP mode, which requires
        ; a secret handshake to drop into SVC mode
        MRS     lr, CPSR
        AND     lr, lr, #M32_bits
        TEQ     lr, #HYP32_mode
        BNE     %F02

        ADR     lr, %F03
        MSR     SPSR_cxsf, #F32_bit+I32_bit+SVC32_mode
        MSR     SPSR_x, #A32_bit
        MSR     elr_hyp, lr
        ERET
02
        MSR     CPSR_c,#F32_bit+I32_bit+SVC32_mode
03
        ADRL    v1, HAL_Base + OSROM_HALSize    ; v1 -> RISC OS image
        LDR     v8, [v1, #OSHdr_Entries]
        ADD     v8, v8, v1                      ; v8 -> RISC OS entry table

        ; Ensure CPU is 'set up' (typically enables ICache)
        MOV     a1, #0
        CallOSM OS_InitARM

        ADRL    sb,workspace
        ADRL    R13,end_stack
        ADRL    r4, reset
        STR     r4, MMUOffBaseAddr
        CPUDetect r4
        LDRCC   r4,=IO_Base_BCM2835
        LDRCS   r4,=IO_Base_BCM2836
        STR     r4,PeriBase

 [ HALDebug
        mov     a1, #0
        bl      HAL_UARTStartUp          ; start early for debug use
        bl      HAL_DebugTXStrInline
        DCB     "HalStartup",10,0
        ALIGN
 ]

 [ JTAG
        ; Configure the GPIO pins used for JTAG
        LDR     a1, PeriBase
        ADD     a1, a1, #GPIO_Base
        LDR     a2, [a1, #GPFSel2]
        LDR     a3, =&3f00003f
        AND     a2, a2, a3 ; Keep settings for 20, 21, 28, 29
        LDR     a3, =(3<<6)+(3<<9)+(3<<12)+(3<<15)+(3<<18)+(3<<21) ; Set 22-27 to alt4
        ORR     a2, a2, a3
        STR     a2, [a1, #GPFSel2]
 ]

        ; Enable USB power
        ; Note - may need changing to enable other devices in future
        ; Looks like we need to write the logical OR of all the devices we want enabled
        MOV     r1, #0
        LDR     r0,=(16:SHL:MB_Pwr_USB)+MB_Chan_Pwr 
        BL      HAL_SendHostMessage

        ; From config.txt we might have loaded some CMOS settings above the ROM,
        ; import those into our workspace (they may subsequently turn out to be junk)
        ADRL    a1, HAL_Base + OSROM_HALSize
        LDR     a3, [a1, #OSHdr_ImageSize]
        ADD     a2, a3, a1              ; loaded immediately after OS image
        ADR     a1, SimulatedCMOS
        LDR     a3, =?SimulatedCMOS
        BL      memcpy

        ; Query the platform
        BL      HAL_QueryPlatform

 [ HALDebug
        bl      HAL_DebugTXStrInline
        DCB     "HalStartup2",10,0
        ALIGN
 ]
        LDR     v3, ARM_Base
        LDR     v4, ARM_Size
      [ HALDebug
        ADRL    a1, reset
        BL      HAL_DebugHexTX4
        MOV     a1, v3
        BL      HAL_DebugHexTX4
        MOV     a1, v4
        BL      HAL_DebugHexTX4
        BL      HAL_DebugTXStrInline
        DCB     "ROM start, RAM start, RAM size", 10, 0
        ALIGN
      ]
relocate_code
        ; Relocate ROM to high end of RAM
        ADRL    v1, HAL_Base + OSROM_HALSize
        LDR     v2, [v1, #OSHdr_ImageSize]
        LDR     lr, [v1, #OSHdr_Flags]
        TST     lr, #OSHdrFlag_SupportsCompression
        LDRNE   lr, [v1, #OSHdr_CompressedSize]
        MOVEQ   lr, v2
        SUB     v1, v1, #OSROM_HALSize ; Start of HAL
        ADD     v2, v2, #OSROM_HALSize ; Size of HAL+OS
        ADD     lr, lr, #OSROM_HALSize ; Size of compressed HAL+OS
        ADD     v5, v1, lr ; End of OS
        ADD     v7, v3, v4 ; End of RAM
        SUB     ip, v7, v2 ; New start address of HAL
        CMP     v1, ip
        BEQ     relocate_10 ; No copy needed
        CMP     v1, v7
        BHI     relocate_20 ; We're in some ROM above RAM. OK to continue with copy.
        CMP     v5, ip
        BLS     relocate_20 ; We're in some ROM/RAM below our copy destination. OK to continue with copy.
        ; Else we currently overlap the area we want to copy ourselves into.
        SUB     ip, v1, lr ; Copy the HAL+OS to just before itself.
relocate_20
        MOV     a1, ip ; Copy dest
        MOV     a2, v1 ; Copy source
        MOV     a3, lr ; Copy length
relocate_30
        LDR     a4, [a2], #4
        SUBS    a3, a3, #4
        STR     a4, [a1], #4
        BGT     relocate_30
        MOV     a1, #0
        MCR     p15, 0, a1, c7, c10, 4 ; drain write buffer
        MCR     p15, 0, a1, c7, c5, 0 ; invalidate I-Cache
        ; Jump to our new copy
        ADR     a1, relocate_code
        SUB     a2, ip, v1
        ADD     a1, a1, a2 ; relocate our branch target
        ADD     v8, v8, a2 ; Update OS entry table ptr
        MOV     pc, a1
relocate_10
        ; Copy completed, reset stack & workspace ptrs
        ADD     sp, v3, #4096 ; Use RAM for stack instead of bits of ROM
        ADRL    sb, workspace ; However workspace is still in ROM :(
      [ HALDebug
        BL      HAL_DebugTXStrInline
        DCB     "ROM relocated", 10, 0
        ALIGN
      ]

        ; If we're a multi-core chip, the other cores should be sat in a boot
        ; stub located at &0, waiting for us to give them the address of some
        ; code to execute. Move them into a holding space in the relocated ROM
        ; so that we don't break them when we overwrite the boot stub.
        CPUDetect lr
        BCC     clear_ram
        LDR     a1, =QA7_BASE
        MVN     a2, #0
        STR     a2, [a1, #QA7_CORE0_MBOX1_RDCLR] ; Clear our mailboxes
        STR     a2, [a1, #QA7_CORE0_MBOX2_RDCLR]
        STR     a2, [a1, #QA7_CORE0_MBOX3_RDCLR]
        DSB
        ADR     a2, holding_pattern
        STR     a2, [a1, #QA7_CORE1_MBOX3_SET] ; Each core is sat waiting for mailbox 3
        STR     a2, [a1, #QA7_CORE2_MBOX3_SET]
        STR     a2, [a1, #QA7_CORE3_MBOX3_SET]
        DSB
        SEV     ; Current boot stub just has the cores in a spin loop, but use SEV just in case future stubs are more power-conscious
        ; Now wait for the cores to acknowledge the request (input via our mailboxes)
        MOV     a3, #1<<20 ; Timeout
        MOV     a4, #QA7_CORE0_MBOX1_RDCLR
10
        SUBS    a3, a3, #1
        BEQ     %FT20
        LDR     a2, [a1, a4]
        CMP     a2, #0
        BEQ     %BT10
        CMP     a4, #QA7_CORE0_MBOX3_RDCLR
        ADDNE   a4, a4, #QA7_CORE0_MBOX2_RDCLR-QA7_CORE0_MBOX1_RDCLR
        BNE     %BT10
      [ HALDebug
        BL      HAL_DebugTXStrInline
        DCB     "Aux cores in holding pattern", 10, 0
        ALIGN
        B       %FT25
      ]
20
      [ HALDebug
        BL       HAL_DebugTXStrInline
        DCB      "Failed waking cores", 10, 0
        ALIGN
25
      ]

clear_ram
        ; Clear RAM
        ; v3 is start of RAM
        ; ip is end of RAM/start of ROM
        ; Note this code will clear the stack, but there shouldn't be anything on it yet anyway
        MOV     a1, ip
        MOV     a2, #0
        MOV     a3, #0
        MOV     a4, #0
        MOV     v1, #0
        MOV     v4, #0
        MOV     v5, #0
        MOV     v7, #0
        MOV     lr, #0

clear_lp1
        STMDB   a1!,{a2-a4,v1,v4,v5,v7,lr}
        STMDB   a1!,{a2-a4,v1,v4,v5,v7,lr}
        STMDB   a1!,{a2-a4,v1,v4,v5,v7,lr}
        STMDB   a1!,{a2-a4,v1,v4,v5,v7,lr}
        CMP     a1, v3
        BHI     clear_lp1
        MOV     a2, v3
        MOV     a3, ip
 [ HALDebug
        BL      HAL_DebugTXStrInline
        DCB     "HalStartup3 .. rst  rend",10,0
        ALIGN
        MOV     a1, a2
        BL      HAL_DebugHexTX4
        MOV     a1, a3
        BL      HAL_DebugHexTX4
 ]
        MVN     a4, #0
        MOV     a1, #0
        STR     a1, [sp, #-4]!  ;reference handle (NULL for first call)
        CallOSM OS_AddRAM

        STR     a1,[sp] ;ref for next call

        ; OS kernel informed of RAM areas

        LDR     a2, PeriBase
        ADD     a2, a2, #PM_Base
        LDR     a2, [a2, #PM_RSTS] ; consider reset status
        TST     a2, #PM_RSTS_HADPOR

        LDR     a4,[sp],#4      ;!!! ref from last AddRAM
        MOV     a1, #OSStartFlag_RAMCleared
        ORRNE   a1, a1, #OSStartFlag_POR
        ADRL    a2, HAL_Base + OSROM_HALSize       ; a2 -> RISC OS image
        CPUDetect a3
        ADRCCL  a3, HALdescriptor
        ADRCSL  a3, QA7_HALdescriptor

        CallOSM OS_Start

        ; OS_Start doesn't return....invokes HAL_Init after MMU activation

holding_pattern
        ; Auxilliary cores arrive here
        ; First, work out who we are
        MRC     p15, 0, a1, c0, c0, 5 ; Read MPIDR
        AND     a1, a1, #3            ; Extract core number (should be 1-3)
      [ HALDebug
        DSB
        LDR     a2, =IO_Base_BCM2836+UART_Base
        ADD     a3, a1, #'0'
        STRB    a3, [a2, #UARTDR]
      ]
        DSB
        ; Clear our mailbox register
        LDR     a2, =QA7_BASE
        ADD     a3, a2, #QA7_CORE0_MBOX0_SET
        ADD     a3, a3, a1, LSL #2    ; Box to reply to core 0 on
        ADD     a4, a2, #QA7_CORE0_MBOX3_RDCLR
        ADD     a4, a4, a1, LSL #4    ; Box to receive instructions via
        MVN     v1, #0
        STR     v1, [a4]
        DSB
        ; Let the master core know that we're here
        STR     pc, [a3]              ; Any non-zero should do
        ; Now wait for further instruction
10
        WFE
        LDR     v1, [a4]
        CMP     v1, #0
        BEQ     %BT10
      [ HALDebug
        DSB
        LDR     a2, =IO_Base_BCM2836+UART_Base
        ADD     a3, a1, #'0'
        STRB    a3, [a2, #UARTDR]
      ]
        ADR     lr, holding_pattern   ; Allow return to the holding pattern to simplify testing
        BX      v1

        LTORG

; Generate two HAL descriptors - one for ARM11 based systems and one for A7/A53
; This allows us to avoid extra overheads in some critical routines
; Entries created using 'QA7Entry' will use either ARM11_$name or QA7_$name

        GBLA    table_idx
        GBLA    entries
        GBLS    descriptor
        GBLS    table

table_idx SETA 0

        WHILE   table_idx < 2

 [ table_idx == 0
descriptor SETS "HALdescriptor"
 |
descriptor SETS "QA7_HALdescriptor"
 ]

table SETS "$descriptor._EntryTable"

$table DATA
        HALEntry HAL_Init

        QA7Entry HAL_IRQEnable
        QA7Entry HAL_IRQDisable
        HALEntry HAL_IRQClear
        QA7Entry HAL_IRQSource
        QA7Entry HAL_IRQStatus
        QA7Entry HAL_FIQEnable
        QA7Entry HAL_FIQDisable
        QA7Entry HAL_FIQDisableAll
        HALEntry HAL_FIQClear
        QA7Entry HAL_FIQSource
        QA7Entry HAL_FIQStatus

        HALEntry HAL_Timers
        HALEntry HAL_TimerDevice
        HALEntry HAL_TimerGranularity
        HALEntry HAL_TimerMaxPeriod
        HALEntry HAL_TimerSetPeriod
        HALEntry HAL_TimerPeriod
        HALEntry HAL_TimerReadCountdown

        HALEntry HAL_CounterRate
        HALEntry HAL_CounterPeriod
        HALEntry HAL_CounterRead
        HALEntry HAL_CounterDelay

        HALEntry HAL_NVMemoryType
        HALEntry HAL_NVMemorySize
        HALEntry HAL_NVMemoryPageSize
        HALEntry HAL_NVMemoryProtectedSize
        HALEntry HAL_NVMemoryProtection
        NullEntry ; HAL_NVMemoryIICAddress
        HALEntry HAL_NVMemoryRead
        HALEntry HAL_NVMemoryWrite

        HALEntry HAL_IICBuses
        HALEntry HAL_IICType
        NullEntry ; HAL_IICSetLines   
        NullEntry ; HAL_IICReadLines  
        NullEntry ; HAL_IICDevice
        HALEntry HAL_IICTransfer
        HALEntry HAL_IICMonitorTransfer

        NullEntry ; HAL_VideoFlybackDevice
        NullEntry ; HAL_VideoSetMode
        NullEntry ; HAL_VideoWritePaletteEntry
        NullEntry ; HAL_VideoWritePaletteEntries
        NullEntry ; HAL_VideoReadPaletteEntry
        NullEntry ; HAL_VideoSetInterlace
        NullEntry ; HAL_VideoSetBlank
        NullEntry ; HAL_VideoSetPowerSave
        NullEntry ; HAL_VideoUpdatePointer
        NullEntry ; HAL_VideoSetDAG
        NullEntry ; HAL_VideoVetMode
        NullEntry ; HAL_VideoPixelFormats
        NullEntry ; HAL_VideoFeatures
        NullEntry ; HAL_VideoBufferAlignment
        NullEntry ; HAL_VideoOutputFormat

        QA7Entry HAL_IRQProperties
      [ table_idx == 0
        NullEntry
        NullEntry
        NullEntry
        NullEntry
        NullEntry
      |
        QA7Entry HAL_IRQSetCores
        QA7Entry HAL_IRQGetCores
        QA7Entry HAL_CPUCount
        QA7Entry HAL_CPUNumber
        QA7Entry HAL_SMPStartup
      ]

        HALEntry HAL_MachineID

        HALEntry HAL_ControllerAddress
        HALEntry HAL_HardwareInfo
        HALEntry HAL_SuperIOInfo
        HALEntry HAL_PlatformInfo
        NullEntry ; HALEntry HAL_CleanerSpace

        HALEntry HAL_UARTPorts
        HALEntry HAL_UARTStartUp
        HALEntry HAL_UARTShutdown
        HALEntry HAL_UARTFeatures
        HALEntry HAL_UARTReceiveByte
        HALEntry HAL_UARTTransmitByte
        HALEntry HAL_UARTLineStatus
        HALEntry HAL_UARTInterruptEnable
        HALEntry HAL_UARTRate
        HALEntry HAL_UARTFormat
        HALEntry HAL_UARTFIFOSize
        HALEntry HAL_UARTFIFOClear
        HALEntry HAL_UARTFIFOEnable
        HALEntry HAL_UARTFIFOThreshold
        HALEntry HAL_UARTInterruptID
        HALEntry HAL_UARTBreak
        HALEntry HAL_UARTModemControl
        HALEntry HAL_UARTModemStatus
        HALEntry HAL_UARTDevice
        HALEntry HAL_UARTDefault        

      [ Debug
        HALEntry HAL_DebugRX
        HALEntry HAL_DebugTX
      |
        NullEntry ; HAL_DebugRX
        NullEntry ; HAL_DebugTX
      ]

        NullEntry ; HAL_PCIFeatures
        NullEntry ; HAL_PCIReadConfigByte
        NullEntry ; HAL_PCIReadConfigHalfword
        NullEntry ; HAL_PCIReadConfigWord
        NullEntry ; HAL_PCIWriteConfigByte
        NullEntry ; HAL_PCIWriteConfigHalfword
        NullEntry ; HAL_PCIWriteConfigWord
        NullEntry ; HAL_PCISpecialCycle
        NullEntry ; HAL_PCISlotTable
        NullEntry ; HAL_PCIAddresses

        HALEntry HAL_PlatformName
        NullEntry
        NullEntry

        HALEntry HAL_InitDevices

        HALEntry HAL_KbdScanDependencies
        NullEntry
        NullEntry
        NullEntry

        HALEntry HAL_PhysInfo

        HALEntry HAL_Reset

        QA7Entry HAL_IRQMax

        HALEntry HAL_USBControllerInfo
        NullEntry ; HAL_USBPortPower
        NullEntry ; HAL_USBPortIRQStatus
        NullEntry ; HAL_USBPortIRQClear
        NullEntry ; HAL_USBPortDevice
        
        HALEntry  HAL_TimerIRQClear
        NullEntry ; HAL_TimerIRQStatus

        HALEntry HAL_ExtMachineID

entries SETA    (.-$table)/4

$descriptor     DATA
        DCD     HALFlag_NCNBWorkspace
        DCD     HAL_Base - $descriptor
        DCD     OSROM_HALSize
        DCD     $table - $descriptor
        DCD     &$entries
        DCD     sizeof_workspace

table_idx SETA table_idx+1
        WEND

;--------------------------------------------------------------------------------------
; HAL Initialisation callback from OS kernel
;--------------------------------------------------------------------------------------

HAL_Init
        Push    "v5, lr"

        MOV     v5, a2
        BL      SetUpOSEntries

        CPUDetect a2
        LDRCC   a2, =IO_Base_BCM2835
        BCC     %FT05

        ; Map in the A7/A53 control logic
        MOV     a1, #0
        LDR     a2, =QA7_BASE
        LDR     a3, =QA7_SIZE
        CallOS  OS_MapInIO
        STR     a1, QA7_Base

        LDR     a2, =IO_Base_BCM2836
05
        ; Map in the main IO region
        MOV     a1, #0
        LDR     a3, =IO_Size
        CallOS  OS_MapInIO
        STR     a1, PeriBase

 [ Debug
        MOV     a1,#0                   ; start the uart ..we use it for debug
        BL      HAL_UARTStartUp         ; restart to capture logical io address
   [ HALDebug
        bl      HAL_DebugTXStrInline
        DCB     "HalStart from OS",10,0
        ALIGN
   ]
 ]
        
        ; Recover various values that are now trapped in ROM from when the workspace
        ; and ROM overlapped prior to relocation. Copy them into RW memory at sb.
        ADRL    a4, workspace           ; where they are post ROM relocation

        LDR     a1, [a4, #:INDEX:FB_CacheMode]             
        STR     a1, FB_CacheMode        ; GPU cache mode

        LDR     a3, [a4, #:INDEX:VC_Size]
        LDR     a2, [a4, #:INDEX:VC_Base]
        LDR     a1, [a4, #:INDEX:ARM_Base]
        LDR     ip, [a4, #:INDEX:ARM_Size]
        STR     a3, VC_Size
        STR     a2, VC_Base
        STR     a1, ARM_Base
        STR     ip, ARM_Size

        LDR     a3, [a4, #:INDEX:Board_Model]
        LDR     a2, [a4, #:INDEX:Board_Revision]
        LDR     a1, [a4, #:INDEX:ARM_DMAChannels]
        LDR     ip, [a4, #:INDEX:SafetyCatch]
        STR     a3, Board_Model
        STR     a2, Board_Revision
        STR     a1, ARM_DMAChannels
        STR     ip, SafetyCatch
        
     [ HALDebug
        LDR     a1, VC_Base
        BL      HAL_DebugHexTX4
        LDR     a1, VC_Size 
        BL      HAL_DebugHexTX4
        BL      HAL_DebugTXStrInline
        DCB     "VC memory",10,0
        ALIGN
     ]

        ; Get the physical address of NCNB workspace
        ; v5 -> start of NCNB workspace
        STR     v5, NCNBAddr

        MOV     a1, v5
        CallOS  OS_LogToPhys
        LDR     a3, FB_CacheMode
        ORR     a1, a1, a3        
        STR     a1, NCNBPhysAddr

        ; Try and initialise virtual GPIO buffer
        LDR     a1, =ARM2VC_Tag_GetVirtGPIOBuf
        MOV     a2, #4096               ; should only need a word, but request a whole page for safety (avoid getting caught out if they make the buffer bigger in future)
        LDR     a3, =ARM2VC_Tag_SetVirtGPIOBuf
        BL      GetVCBuffer
        STR     a1, VirtGPIOBuf

        BL      CMOS_Init
        BL      Interrupt_Init          ; initialise our interrupts
        BL      Timer_Init
        BL      IIC_Init

     [ HALDebug
        BL      HAL_DebugTXStrInline
        DCB     "HAL Init completed",10,0
        ALIGN
     ]

        Pull    "v5, pc"

; Initialise the simulated CMOS.
CMOS_Init ROUT
        Push    "v1, lr"
        ADRL    a1, workspace           ; where it got relocated to
        ADD     v1, a1, #:INDEX:SimulatedCMOS
        LDR     a4, [v1, #?SimulatedCMOS - 4]
        SUB     a4, a4, #500            ; Check version word is from RISC OS 5
        CMP     a4, #100
        BHS     %FT10

        ; Now we need to take the logical CMOS file order and make it physical
        ; The resulting layout from logical is [F0-FF][C0-EF][00-BF][100-END]
        ADR     a1, SimulatedCMOS
        ADD     a2, v1, #&F0
        MOV     a3, #16*1
        BL      memcpy
        ADD     a1, a1, #16*1 
        ADD     a2, v1, #&C0
        MOV     a3, #16*3
        BL      memcpy 
        ADD     a1, a1, #16*3
        ADD     a2, v1, #0
        MOV     a3, #16*12
        BL      memcpy 
        ADD     a1, a1, #16*12
        ADD     a2, v1, #&100
        MOV     a3, #?SimulatedCMOS - 4 - &100
        BL      memcpy 
        Pull    "v1, pc"
10
        ADR     a1, SimulatedCMOS
        MOV     a2, #-1                 ; Zap it to a known blank state
        LDR     a3, =?SimulatedCMOS - 4
20
        STR     a2, [a1, a3]
        SUBS    a3, a3, #4
        BPL     %BT20
        Pull    "v1, pc"

; Initialise and relocate the entry table.
SetUpOSEntries  ROUT
        STR     a1, OSheader
        LDR     a2, [a1, #OSHdr_NumEntries]
        CMP     a2, #HighestOSEntry+1
        MOVHI   a2, #HighestOSEntry+1

        ADRL    a3, OSentries
        LDR     a4, [a1, #OSHdr_Entries]
        ADD     a4, a4, a1

05      SUBS    a2, a2, #1
        LDR     ip, [a4, a2, LSL #2]
        ADD     ip, ip, a4
        STR     ip, [a3, a2, LSL #2]
        BNE     %BT05

        MOV     pc, lr

HAL_ControllerAddress
        MOV     a1, #0
        MOV     pc, lr

HAL_HardwareInfo
        LDR     ip, =&FFFFFF00
        STR     ip, [a1]
        MOV     ip, #0
        STR     ip, [a2]
        LDR     ip, =&00FFFF00
        STR     ip, [a3]
        MOV     pc, lr

HAL_PlatformInfo
        MOV     ip, #2_10000    ; no podules,no PCI cards,no multi CPU,no soft off,and soft ROM
        STR     ip, [a2]
        MOV     ip, #2_11111    ; mask of valid bits
        STR     ip, [a3]
        MOV     pc, lr

HAL_SuperIOInfo
        MOV     ip, #0
        STR     ip, [a1]
        STR     ip, [a2]
        MOV     pc, lr

HAL_MachineID
;        ADR     ip, MachAD
        LDR     ip, MachAD
        LDMIA   ip, {a1, a2}
        mov     pc, lr

MachAD  DCD     :INDEX:workspace + :INDEX:MachineID

HAL_ExtMachineID
        MOVS    ip, a1
        MOV     a1, #0
        MOV     pc, lr
        
HAL_Reset
        MRS     a1, CPSR
        ORR     a1, a1, #I32_bit+F32_bit ; paranoia, don't allow reset to be interrupted
        MSR     CPSR_c, a1
        LDR     a1, PeriBase
        ADD     a1, a1, #PM_Base
        DoMemBarrier a3
        LDR     a2, [a1, #PM_RSTC]
        MOV     a3, #PM_Password
        BIC     a2, a2, #PM_RSTC_WRCFG_MASK
        ORR     a2, a2, #PM_RSTC_WRCFG_FULLRST
        ORR     a2, a2, a3
        ADD     a3, a3, #10
        STR     a3, [a1, #PM_WDOG]
        STR     a2, [a1, #PM_RSTC]
        B       .

HAL_PhysInfo    ROUT
        TEQ     a1, #PhysInfo_GetTableSize
        MOVEQ   a1, #524288 ; Two pages in each byte, so (2^32)/(4096*2)
        STREQ   a1, [a2]
        MVNEQ   a1, #0
        MOVEQ   pc, lr

        TEQ     a1, #PhysInfo_HardROM
        MOVEQ   a1, #0 ; No hard ROM
        MOVEQ   a2, #0
        STMEQIA a3, {a1-a2}
        MVNEQ   a1, #0
        MOVEQ   pc, lr

        TEQ     a1, #PhysInfo_WriteTable
        MOVNE   a1, #0
        MOVNE   pc, lr

        Push    "v1-v5,lr"
        LDR     v1, ARM_Base
        LDR     v2, ARM_Size
        ADD     v2, v1, v2
        STMIA   a3, {v1-v2} ; All RAM the OS knows about will be here
        ; Majority of table is unused, so prefill it
        LDR     v3, =&88888888 ; Unused regions (or RAM)
        MOV     a1, v3
        MOV     a3, v3
        MOV     a4, v3
        ADD     v4, a2, #524288
10
        STMIA   a2!, {a1,a3,a4,v3}
        CMP     a2, v4
        BLO     %BT10
        ; Fill in IO region
        CPUDetect v5
        SUB     a2, a2, #524288-(IO_Base_BCM2835>>13)
        ADDCS   a2, a2, #(IO_Base_BCM2836-IO_Base_BCM2835)>>13
        ORR     a1, a1, a1, LSR #1 ; Pattern for IO regions
        ORR     a3, a3, a3, LSR #1
        ORR     a4, a4, a4, LSR #1
        ORR     v3, v3, v3, LSR #1
        ADD     v5, a2, #IO_Size>>13
        ASSERT  IO_Base_BCM2836+IO_Size = QA7_BASE
        ASSERT  QA7_SIZE :AND: ((2<<17)-1) = 0 ; 2 pages per table byte, 16 table bytes per iteration = 2^17 RAM bytes per iteration
        ADDCS   v5, v5, #QA7_SIZE>>13
20
        STMIA   a2!, {a1,a3,a4,v3}
        CMP     a2, v5
        BLO     %BT20
        ; VC memory is effectively IO, so fill it in as such
        SUB     a2, v4, #524288
        LDR     v1, VC_Base
        LDR     v2, VC_Size
        ADD     a2, a2, v1, LSR #13
        ADD     v5, a2, v2, LSR #13
30
        STMIA   a2!, {a1,a3,a4,v3}
        CMP     a2, v5
        BLO     %BT30
        MVN     a1, #0
        Pull    "v1-v5,pc"
                

HAL_Null
        MOV     pc, lr

HAL_InitDevices
        STR     lr, [sp, #-4]!
        BL      Video_InitDevices ; Must be before DMA_InitDevices
        BL      SDIO_InitDevices
        BL      DMA_InitDevices
        BL      GPIO_InitDevices
        BL      VCHIQ_InitDevices
        BL      RTC_InitDevices
        BL      SPI_InitDevices
        BL      Touch_InitDevices
        BL      BCMMBox_InitDevices
        BL      DBell_InitDevices
        LDR     pc, [sp], #4

; Out: a1 = number of CPU cores
QA7_HAL_CPUCount
        MOV     a1, #4
        MOV     pc, lr

; Out: a1 = number of this core
QA7_HAL_CPUNumber
        MRC     p15, 0, a1, c0, c0, 5
        AND     a1, a1, #3
        MOV     pc, lr

; In: a1 = core number
;     a2 = boot physical address
; Out: Indicated core will be booting (undefined if a1 is current core)
; Assume caller has fully flushed the boot code to RAM (no DSB prior to mbox write)
QA7_HAL_SMPStartup
        LDR     a3, QA7_Base
        ASSERT  QA7_CORE1_MBOX3_SET-QA7_CORE0_MBOX3_SET = 16
        ADD     a3, a3, a1, LSL #4
        STR     a2, [a3, #QA7_CORE0_MBOX3_SET]
        DSB
        SEV
        MOV     pc, lr

 [ HALDebug
; a2-> null terminated string
HAL_DebugTXS    ROUT
        STMFD   sp!, {a1-a4,v1,ip,lr}
        SUB     v1, a2, #1
1       LDRB    a1, [v1,#1]!
        TEQ     a1, #&0
        LDMEQFD sp!, {a1-a4,v1,ip,pc}
        BL      HAL_DebugTX
        B       %BT1

HAL_DebugHexTX
       stmfd    r13!, {r0-r3,ip,lr}
       b        jbdt1
HAL_DebugHexTX2
       stmfd    r13!, {r0-r3,ip,lr}
       b        jbdt2
HAL_DebugHexTX4
       stmfd    r13!, {r0-r3,ip,lr}
       mov      r0,r0,ror #24          ; hi byte
       bl       jbdtxh
       mov      r0,r0,ror #24
       bl       jbdtxh
jbdt2
       mov      r0,r0,ror #24
       bl       jbdtxh
       mov      r0,r0,ror #24
jbdt1
       bl       jbdtxh
       mov      r0,#' '
       bl       HAL_DebugTX
       ldmfd    r13!, {r0-r3,ip,pc}

HAL_DebugTXStrInline
       stmfd    r13!, {a1-a4,v1,ip}    ; lr points to prinstring, immediately
                                       ; following call, null terminated
       sub      v1,lr,#1
1      ldrb     a1,[v1,#1]!            ; pop next char, auto incr
       teq      a1,#0                  ; terminating null
       biceq    lr,v1,#3               ; round down address
       ldmeqfd  r13!,{a1-a4,v1,ip}
       addeq    pc,lr,#4               ; return to next word
       bl       HAL_DebugTX            ; else send, then
       b        %bt1                   ; loop

jbdtxh stmfd    r13!,{a1-a4,v1,ip,lr}  ; print byte as hex
       and      v1,a1,#&f              ; get low nibble
       and      a1,a1,#&f0             ; get hi nibble
       mov      a1,a1,lsr #4           ; shift to low nibble
       cmp      a1,#&9                 ; 9?
       addle    a1,a1,#&30
       addgt    a1,a1,#&37             ; convert letter if needed
       bl       HAL_DebugTX
       cmp      v1,#9
       addle    a1,v1,#&30
       addgt    a1,v1,#&37
       bl       HAL_DebugTX
       ldmfd    r13!,{a1-a4,v1,ip,pc}
 ]

        END
@


1.47
log
@Debug UART typo & clarification
Top.s: HAL_UARTStartUp takes 0's based UART numbers, so the debug setup would go wrong (if HAL_UARTStartUp actually checked the value).
UART.s: Re-express the baud register default value so its origin is clear.
Retagged as BCM2835-0_75 as the (non-debug) version is binary identical.
@
text
@a50 2
        IMPORT  HAL_IRQEnable
        IMPORT  HAL_IRQDisable
a51 5
        IMPORT  HAL_IRQSource
        IMPORT  HAL_IRQStatus
        IMPORT  HAL_FIQEnable
        IMPORT  HAL_FIQDisable
        IMPORT  HAL_FIQDisableAll
d53 24
a76 3
        IMPORT  HAL_FIQSource
        IMPORT  HAL_FIQStatus
        IMPORT  HAL_IRQMax
d156 2
d218 1
a218 3
        MRC     p15, 0, lr, c0, c0, 0    ; read Main ID Register
        AND     lr, lr, #&FF00
        CMP     lr, #&C000               ; xxxxB76x for ARM1176, xxxxC07x for Cortex-A7
d255 1
a255 3
        MRC     p15,0,r4,c0,c0,0         ; read Main ID Register
        AND     r4,r4,#&FF00
        CMP     r4,#&C000                ; xxxxB76x for ARM1176, xxxxC07x for Cortex-A7
d371 1
a371 3
        MRC     p15, 0, lr, c0, c0, 0    ; read Main ID Register
        AND     lr, lr, #&FF00
        CMP     lr, #&C000               ; xxxxB76x for ARM1176, xxxxC07x for Cortex-A7
d462 3
a464 1
        ADR     a3, HALdescriptor
d510 20
a529 7
HALdescriptor   DATA
        DCD     HALFlag_NCNBWorkspace
        DCD     HAL_Base - HALdescriptor
        DCD     OSROM_HALSize
        DCD     HAL_EntryTable - HALdescriptor
        DCD     HAL_Entries
        DCD     sizeof_workspace
d531 1
a531 1
HAL_EntryTable  DATA
d534 2
a535 2
        HALEntry HAL_IRQEnable
        HALEntry HAL_IRQDisable
d537 5
a541 5
        HALEntry HAL_IRQSource
        HALEntry HAL_IRQStatus
        HALEntry HAL_FIQEnable
        HALEntry HAL_FIQDisable
        HALEntry HAL_FIQDisableAll
d543 2
a544 2
        HALEntry HAL_FIQSource
        HALEntry HAL_FIQStatus
d592 14
a605 7
        NullEntry ; HALEntry HAL_MatrixColumns
        NullEntry ; HALEntry HAL_MatrixScan

        NullEntry ; HALEntry HAL_TouchscreenType
        NullEntry ; HALEntry HAL_TouchscreenRead
        NullEntry ; HALEntry HAL_TouchscreenMode
        NullEntry ; HALEntry HAL_TouchscreenMeasure
d670 1
a670 1
        HALEntry HAL_IRQMax
d683 12
a694 1
HAL_Entries     * (.-HAL_EntryTable)/4
d706 1
a706 4
        MOV     a1, #0                   ; map in the IO space
        MRC     p15, 0, a2, c0, c0, 0    ; read Main ID Register
        AND     a2, a2, #&FF00
        CMP     a2, #&C000               ; xxxxB76x for ARM1176, xxxxC07x for Cortex-A7
d708 13
a720 1
        LDRCS   a2, =IO_Base_BCM2836
d948 1
a948 3
        MRC     p15,0,v5,c0,c0,0         ; read Main ID Register
        AND     v5,v5,#&FF00
        CMP     v5,#&C000                ; xxxxB76x for ARM1176, xxxxC07x for Cortex-A7
d956 3
d991 1
d994 4
d999 18
@


1.46
log
@Participate in keyboard scan dependencies
Detail:
  Add keyboard scan code with list of modules that the kernel needs to do the same.
  Reorder the HALEntries to match Kernel-5_89.
  Remove unused stub functions (now KbdScan exists).
Admin:
  Submission for USB bounty.

Version 0.72. Tagged as 'BCM2835-0_72'
@
text
@d249 1
a249 1
        mov     a1, #1
@


1.45
log
@Fix compatibility with latest firmware
Detail:
  Firmware as of 28th July will allow the GPU to make use of the top 16MB of RAM in 1GB machines. This overlaps the ARM's IO space, essentially making that area of memory inaccessible to us.
  This causes problems because we rely on a couple of buffers which are located in VC memory (virtual GPIO buffer & FT5406 touchscreen buffer)
  At some point extra mailbox messages were added to allow the ARM to dictate the location of these buffers; so make use of those messages wherever possible.
  File changes:
  s/Messaging - Remove VirtGPIOBuf and TouchBuf related tags from the initialisation tag sequence. Add new GetVCBuffer function that can be called post-MMU init to deal with getting/setting the buffer addresses.
  s/Top - Use GetVCBuffer to initialise VirtGPIOBuf
  s/Touch - Use GetVCBuffer to get touchscreen buffer
  hdr/StaticWS - Remove TouchBuf from workspace, no longer needed
Admin:
  Tested on Raspberry Pi 3 with firmware from March 2016 (Set commands not supported), 21st July 2017 (set commands supported, but upper 16MB not used), 28th July 2017 (set commands supported and necessary)


Version 0.71. Tagged as 'BCM2835-0_71'
@
text
@d121 2
a122 5
        IMPORT  HAL_KbdScanSetup
        IMPORT  HAL_KbdScan
        IMPORT  HAL_KbdScanFinish
        IMPORT  HAL_KbdScanInterrupt
                
d602 1
a602 2

        HALEntry HAL_Reset
d629 4
a632 4
        HALEntry HAL_KbdScanSetup
        HALEntry HAL_KbdScan
        HALEntry HAL_KbdScanFinish
        HALEntry HAL_KbdScanInterrupt
d636 1
a636 1
        HALEntry HAL_USBControllerInfo
d640 1
a640 2
        NullEntry ; HALEntry HAL_VideoRender

d642 2
a643 1
        NullEntry ; HAL_USBPortStatus
d645 1
a645 3

        NullEntry ; HALEntry HAL_VideoIICOp

a650 6
        NullEntry ; HALEntry HAL_VideoFramestoreAddress

        HALEntry HAL_UARTDefault        

        NullEntry ; HALEntry HAL_VideoStartupMode    

@


1.44
log
@Add support for CM3 and CM3L with or without eMMC
The SDIO HAL device reports when it is sure fixed disc media is attached (ie. eMMC soldered on the same PCB) which causes SDFS to report this to FileCore as a fixed disc, skipping the removable safety checks.
However, CM3 and CM3L both return the same board id so we can't work out which is which. Additionally, someone could attach an external eMMC in theory on a custom expansion board (instead of an SD card socket like the CMIO has).
To resolve this, we assign IO expander line 6 of U8 to be a safety catch. If that line is held low, it signifies this is definitely a CM3 - in effect this is a "definitely has eMMC" or "maybe has eMMC" switch.

Tested on CM1, CM3, CM3L, and a suitably modified CM3 with the help of Chris Hall.

Version 0.69. Tagged as 'BCM2835-0_69'
@
text
@a42 1
        $GetMEMM
d148 1
a699 2
        LDR     a2, [a4, #:INDEX:TouchBuf]
        LDR     a3, [a4, #:INDEX:VirtGPIOBuf]
a700 2
        STR     a2, TouchBuf
        STR     a3, VirtGPIOBuf
d725 3
d740 5
a744 8
        ; Map in virtual GPIO buffer if present
        LDR     a2, VirtGPIOBuf
        BICS    a2, a2, #&C0000000
        STREQ   a2, VirtGPIOBuf
        BEQ     %FT10
        MOV     a1, #1:SHL:L1_TEXShift ; VMSA Normal, non-cacheable
        MOV     a3, #4096
        CallOS  OS_MapInIO
d746 1
a746 1
10
@


1.44.2.1
log
@Initial SMP support
Detail:
  hdr/BCM2835 - Delete unused timer macros. Add basic spinlock claim/release macros. Add CPUDetect macro to encapsulate ARM11 vs. A7/A53 detection. Add definitions for the "QA7" interrupts.
  Makefile, s/DBell - Add doorbell device driver
  hdr/StaticWS - Reserve workspace for doorbell device, QA7 interrupt controller ptr, spinlock
  s/Top, hdr/CastleMacros - Generate two HAL entry point tables, one for ARM11, one for A7/A53. Use CPUDetect macro. Implement new SMP-related HAL entry points.
  s/Interrupts - Implement support for the QA7 interrupt controller and the new IRQ-related HAL entry points
  s/Messaging - Use CPUDetect macro
Admin:
  Tested on Raspberry Pi 1, 2, 3


Version 0.70, 1.70.2.1. Tagged as 'BCM2835-0_70-1_70_2_1'
@
text
@d52 2
d55 5
d61 3
a63 24
        IMPORT  ARM11_HAL_IRQEnable
        IMPORT  ARM11_HAL_IRQDisable
        IMPORT  ARM11_HAL_IRQSource
        IMPORT  ARM11_HAL_IRQStatus
        IMPORT  ARM11_HAL_FIQEnable
        IMPORT  ARM11_HAL_FIQDisable
        IMPORT  ARM11_HAL_FIQDisableAll
        IMPORT  ARM11_HAL_FIQSource
        IMPORT  ARM11_HAL_FIQStatus
        IMPORT  ARM11_HAL_IRQMax
        IMPORT  ARM11_HAL_IRQProperties
        IMPORT  QA7_HAL_IRQEnable
        IMPORT  QA7_HAL_IRQDisable
        IMPORT  QA7_HAL_IRQSource
        IMPORT  QA7_HAL_IRQStatus
        IMPORT  QA7_HAL_FIQEnable
        IMPORT  QA7_HAL_FIQDisable
        IMPORT  QA7_HAL_FIQDisableAll
        IMPORT  QA7_HAL_FIQSource
        IMPORT  QA7_HAL_FIQStatus
        IMPORT  QA7_HAL_IRQMax
        IMPORT  QA7_HAL_IRQProperties
        IMPORT  QA7_HAL_IRQSetCores
        IMPORT  QA7_HAL_IRQGetCores
a145 2

        IMPORT  DBell_InitDevices
d205 3
a207 1
        CPUDetect lr
d244 3
a246 1
        CPUDetect r4
d362 3
a364 1
        CPUDetect lr
d455 1
a455 3
        CPUDetect a3
        ADRCCL  a3, HALdescriptor
        ADRCSL  a3, QA7_HALdescriptor
d501 7
a507 20
; Generate two HAL descriptors - one for ARM11 based systems and one for A7/A53
; This allows us to avoid extra overheads in some critical routines
; Entries created using 'QA7Entry' will use either ARM11_$name or QA7_$name

        GBLA    table_idx
        GBLA    entries
        GBLS    descriptor
        GBLS    table

table_idx SETA 0

        WHILE   table_idx < 2

 [ table_idx == 0
descriptor SETS "HALdescriptor"
 |
descriptor SETS "QA7_HALdescriptor"
 ]

table SETS "$descriptor._EntryTable"
d509 1
a509 1
$table DATA
d512 2
a513 2
        QA7Entry HAL_IRQEnable
        QA7Entry HAL_IRQDisable
d515 5
a519 5
        QA7Entry HAL_IRQSource
        QA7Entry HAL_IRQStatus
        QA7Entry HAL_FIQEnable
        QA7Entry HAL_FIQDisable
        QA7Entry HAL_FIQDisableAll
d521 2
a522 2
        QA7Entry HAL_FIQSource
        QA7Entry HAL_FIQStatus
d570 7
a576 14
        QA7Entry HAL_IRQProperties
      [ table_idx == 0
        NullEntry
        NullEntry
        NullEntry
        NullEntry
        NullEntry
      |
        QA7Entry HAL_IRQSetCores
        QA7Entry HAL_IRQGetCores
        QA7Entry HAL_CPUCount
        QA7Entry HAL_CPUNumber
        QA7Entry HAL_SMPStartup
      ]
d642 1
a642 1
        QA7Entry HAL_IRQMax
d661 1
a661 1
entries SETA    (.-$table)/4
d663 1
a663 10
$descriptor     DATA
        DCD     HALFlag_NCNBWorkspace
        DCD     HAL_Base - $descriptor
        DCD     OSROM_HALSize
        DCD     $table - $descriptor
        DCD     &$entries
        DCD     sizeof_workspace

table_idx SETA table_idx+1
        WEND
d675 4
a678 1
        CPUDetect a2
d680 1
a680 13
        BCC     %FT05

        ; Map in the A7/A53 control logic
        MOV     a1, #0
        LDR     a2, =QA7_BASE
        LDR     a3, =QA7_SIZE
        CallOS  OS_MapInIO
        STR     a1, QA7_Base

        LDR     a2, =IO_Base_BCM2836
05
        ; Map in the main IO region
        MOV     a1, #0
d912 3
a914 1
        CPUDetect v5
a921 3
        ASSERT  IO_Base_BCM2836+IO_Size = QA7_BASE
        ASSERT  QA7_SIZE :AND: ((2<<17)-1) = 0 ; 2 pages per table byte, 16 table bytes per iteration = 2^17 RAM bytes per iteration
        ADDCS   v5, v5, #QA7_SIZE>>13
a953 1
        BL      DBell_InitDevices
a955 4
; Out: a1 = number of CPU cores
QA7_HAL_CPUCount
        MOV     a1, #4
        MOV     pc, lr
a956 18
; Out: a1 = number of this core
QA7_HAL_CPUNumber
        MRC     p15, 0, a1, c0, c0, 5
        AND     a1, a1, #3
        MOV     pc, lr

; In: a1 = core number
;     a2 = boot physical address
; Out: Indicated core will be booting (undefined if a1 is current core)
; Assume caller has fully flushed the boot code to RAM (no DSB prior to mbox write)
QA7_HAL_SMPStartup
        LDR     a3, QA7_Base
        ASSERT  QA7_CORE1_MBOX3_SET-QA7_CORE0_MBOX3_SET = 16
        ADD     a3, a3, a1, LSL #4
        STR     a2, [a3, #QA7_CORE0_MBOX3_SET]
        DSB
        SEV
        MOV     pc, lr
@


1.44.2.2
log
@Merge in latest HEAD
Detail:
  Merge in changes since BCM2835-0_70 to keep SMP branch up to date
Admin:
  Untested


Version 0.71, 1.70.2.2. Tagged as 'BCM2835-0_71-1_70_2_2'
@
text
@d43 1
a164 1
        IMPORT  GetVCBuffer
d750 2
d753 2
a778 3
        BL      HAL_DebugTXStrInline
        DCB     "VC memory",10,0
        ALIGN
d791 8
a798 5
        ; Try and initialise virtual GPIO buffer
        LDR     a1, =ARM2VC_Tag_GetVirtGPIOBuf
        MOV     a2, #4096               ; should only need a word, but request a whole page for safety (avoid getting caught out if they make the buffer bigger in future)
        LDR     a3, =ARM2VC_Tag_SetVirtGPIOBuf
        BL      GetVCBuffer
d800 1
a800 1

@


1.44.2.3
log
@Merge latest changes from main branch

Version 0.73, 1.70.2.3. Tagged as 'BCM2835-0_73-1_70_2_3'
@
text
@d135 5
a139 2
        IMPORT  HAL_KbdScanDependencies

d637 2
a638 1
        HALEntry HAL_UARTDefault        
d665 4
a668 4
        HALEntry HAL_KbdScanDependencies
        NullEntry
        NullEntry
        NullEntry
d672 1
a672 1
        HALEntry HAL_Reset
d676 2
a677 1
        HALEntry HAL_USBControllerInfo
d679 1
a679 2
        NullEntry ; HAL_USBPortIRQStatus
        NullEntry ; HAL_USBPortIRQClear
d681 3
a683 1
        
d689 4
@


1.44.2.4
log
@Merge latest changes from HEAD

Version 0.75, 1.70.2.4. Tagged as 'BCM2835-0_75-1_70_2_4'
@
text
@d261 1
a261 1
        mov     a1, #0
@


1.43
log
@Refactor early GPU queries
Remove the baffling double indirection of RamAd (and unused exports SerNo and MacAdd), and treat these the same as the other pre-HAL_Init query results.
This means the scope of the tagbuffer is limited to Messaging.s, rather than having to be kept preserved globally.
Use memcpy() to copy tag list to tagbuffer for clarity.
Tested on a Pi 3.

Version 0.68. Tagged as 'BCM2835-0_68'
@
text
@d718 1
d722 1
@


1.42
log
@Add JTAG debugging support
Detail:
  hdr/BCM2835 - Add switch to allow GPIOs 22-27 to be reconfigured for ARM JTAG access
  s/Top - Configure GPIOs for JTAG if switch enabled
  s/GPIO - Disable GPIO HAL device if JTAG enabled (try and avoid any software messing with the pins)
Admin:
  Tested on Raspberry Pi 1 B, B+


Version 0.66. Tagged as 'BCM2835-0_66'
@
text
@a150 2
        IMPORT  RamAd
        IMPORT  SerNo
d287 1
a287 1
        ; Query the platform and set up a frame buffer.
d295 2
a296 7
        ADRL    a3, workspace
        ADRL    lr,RamAd
        LDR     lr, [lr]
        ADD     a3, a3, lr
        LDMIA   a3, {v3, v4}       ; v3=base, v4=size
        STR     v3, ARM_Base
        STR     v4, ARM_Size
@


1.41
log
@Fix crash with HALDebug {TRUE}
Detail:
  s/Top - Update internal HAL debug functions to preserve all the required registers; the new HAL_Debug / UART function implementations corrupt more of the caller-save registers than the old ones did
Admin:
  Tested on Raspberry Pi


Version 0.65. Tagged as 'BCM2835-0_65'
@
text
@d260 13
@


1.40
log
@Report POR flag to the kernel
Detail:
  Look at the reset status register and use the HADPOR flag to influence the OSStartFlag_POR value.
  Fixes problem of OS_Byte 253 always reporting a hard reset, never a power on reset.
Admin:
  Tested on a Pi 2.
  Submission for USB bounty.

Version 0.64. Tagged as 'BCM2835-0_64'
@
text
@d953 3
a955 3
        STMFD   sp!, {a1,lr}
        SUB     a2,a2,#1
1       LDRB    a1, [a2,#1]!
d957 1
a957 1
        LDMEQFD sp!, {a2,pc}
d962 1
a962 1
       stmfd    r13!, {r0-r3,lr}
d965 1
a965 1
       stmfd    r13!, {r0-r3,lr}
d968 1
a968 1
       stmfd    r13!, {r0-r3,lr}
d981 1
a981 1
       ldmfd    r13!, {r0-r3,pc}
d984 1
a984 1
       stmfd    r13!, {r0-r3}          ; lr points to prinstring, immediately
d986 5
a990 5
       sub      r3,lr,#1
1      ldrb     r0,[r3,#1]!            ; pop next char, auto incr
       teq      r0,#0                  ; terminating null
       biceq    lr,r3,#3               ; round down address
       ldmeqfd  r13!,{r0-r3}
d995 2
a996 2
jbdtxh stmfd    r13!,{r0-r3,lr}        ; print byte as hex
       and      a4,a1,#&f              ; get low nibble
d1003 3
a1005 3
       cmp      a4,#9
       addle    a1,a4,#&30
       addgt    a1,a4,#&37
d1007 1
a1007 1
       ldmfd    r13!,{r0-r3,pc}
@


1.39
log
@Move CMOS settings out of riscos.img
The Pi is unusual in self modifying the ROM image when a CMOS setting was changed (due to there being none on the PCB), with the potential of ending up with a corrupt OS image on disc.
Remove this code and emulate the CMOS using normal RAM, and using the Pi firmware to load the CMOS file in for us (like fatload does on OMAP based designs) by using its ability to load a second arbitrary file at an address, intended in the Linux world to load a disc image.

To use this you will need to add
  ramfsfile=CMOS
  ramfsaddr=0x508000
to config.txt which loads it 5MB (ie. ImageSize) above the default load address (&8000), though as noted in the changes to BCM2835-0_60 we don't really need to load at offset &8000 but generally do since that's the Pi firmware's default.

hdr/StaticWS:
New workspace to hold our CMOS copy.
CMOS.s:
Remove the 2k magic block, add a simple bytewise copy loop implementation.
SDIO.s:
Extend ADR range.
Top.s:
Copy what the Pi firmware loads somewhere safe until the MMU is on, then copy it back (converting from logical to physical order along the way).
Change other values recovered from pre-MMU times using advanced post indexed addressing technology (TM) rather than switching around sb a lot.

Tested on a Pi 3, with and without an initial CMOS file present.

Version 0.61. Tagged as 'BCM2835-0_61'
@
text
@d440 5
d447 1
d860 1
a860 1
        LDR     a2, [a1, #PM_Rstc]
d862 2
a863 2
        BIC     a2, a2, #PM_Rst_WCfgSet
        ORR     a2, a2, #PM_Rst_WCfg_FullRst
d866 2
a867 2
        STR     a3, [a1, #PM_Wdog]
        STR     a2, [a1, #PM_Rstc]
@


1.38
log
@Groundwork
IIC.s/Stubs.s:
Don't import workspace when it's not used
Top.s:
Move the dead loops to just after the vectors. In practice these are ineffectual because the firmware (now) loads the image at &8000 to please Linux, so we're mostly wasting our time producing ROM images with vectors at the start.
Pad image to &8000 so it can be loaded at 0 (using Kernel_Old=1 in config.txt) or &8000 (default).
Line up/capitalise a few stray mnemonics, use APCS register naming.
Call HAL_DebugTXStrInline for "HAL Init completed" rather than an inline loop, since earlier in the same function we called HAL_DebugTXStrInline happily.

Version 0.60. Tagged as 'BCM2835-0_60'
@
text
@d153 1
a153 1

d267 9
d683 8
a690 7
        MOV     a4, sb                       ; confirm the caching mode in use in GPU
        ADRL    sb, workspace                ; where we remembered it is
        LDR     a1, FB_CacheMode             ; GPU cache mode
        LDR     a2, TouchBuf
        LDR     a3, VirtGPIOBuf
        mov     sb, a4
        STR     a1, FB_CacheMode
d693 5
a697 6
        ADRL    sb, workspace                ; where we remembered it is
        LDR     a3, VC_Size
        LDR     a2, VC_Base
        LDR     a1, ARM_Base
        LDR     ip, ARM_Size
        mov     sb, a4
d702 4
a705 5
        ADRL    sb, workspace                ; where we remembered it is
        LDR     a3, Board_Model
        LDR     a2, Board_Revision
        LDR     a1, ARM_DMAChannels
        mov     sb, a4
a708 3

        LDR     a2, VC_Base
        LDR     a3, VC_Size
d711 1
a711 1
        MOV     a1, a2
d713 1
a713 1
        MOV     a1, a3
d737 1
a737 1

d750 39
@


1.37
log
@Implement HAL UART API. Tidy up debug output.
Detail:
  hdr/BCM2835, hdr/StaticWS, s/Debug, s/Top, s/Video - Fix up the two serial debug switches to work correctly. Disable debug by default.
  s/UART, hdr/UART - Implement HAL UART API, for the PL011 UART.
Admin:
  Tested on Raspberry Pi 1 B
  Requires DualSerial 0.25 to work correctly


Version 0.59. Tagged as 'BCM2835-0_59'
@
text
@a154 1
HAL_Base
d165 2
d175 15
d203 2
a204 22
        LTORG

        ; exception handlers just for use during HAL init,
        ;   in case something goes wrong

interrupt
        B       .

fast_interrupt
        B       .

swi_instr
        B       .

prefetch_abort
        B       .

data_abort
        B       .

undefined_instr
        B       .
d217 1
a217 1
        BNE      %BT01
d267 1
a267 1
; query the platform and set up a frame buffer.
d411 1
a411 1
        mov     a2, v3
d414 1
a414 1
        bl      HAL_DebugTXStrInline
d417 4
a420 4
     mov a1,a2
     bl HAL_DebugHexTX4
     mov a1,a3
     bl HAL_DebugHexTX4
d649 1
a649 1
        STMFD   R13!,{R8,R14}
d651 1
a651 1
        MOV     R8,a2
d670 1
a672 3
        ALIGN


d704 7
a710 6
 [ HALDebug
     mov r0,a2
     bl HAL_DebugHexTX4
     mov r0,a3
     bl HAL_DebugHexTX4
 ]
d713 2
a714 2
        ; R8 -> start of NCNB workspace
        STR     R8, NCNBAddr
d716 1
a716 1
        MOV     a1,R8
d738 2
a739 20
        STR     v1,[sp,#-4]!
        ADRL    v1,hal_init
txloop
txbusylp
        MOV a1,#0
        BL HAL_UARTLineStatus
        TST a1,#&20
        BEQ txbusylp
        MOV a1,#0
        LDRB a2,[v1],#1
        BL HAL_UARTTransmitByte
        LDRB a1,[v1]
        TEQ a1,#0
        BNE txloop
        LDR v1,[sp],#4

        LDMFD   R13!,{R8,PC}

uart_started = " UART started",13,10,0
hal_init     = " HAL Init completed",13,10,0
a740 2
     |
        LDMFD   R13!,{R8,PC}
d743 1
@


1.36
log
@Fix waiting on wrong mailbox address
Detail:
  s/Top - Fix cores sat in the holding pattern waiting on a write to the wrong address. Also, set up lr so we can return to the holding pattern if desired.
Admin:
  Tested on Pi 3 B
  Now possible to launch simple code sequences on the other cores


Version 0.56. Tagged as 'BCM2835-0_56'
@
text
@d113 3
a115 1
                
d118 2
a119 1
                
a443 6
     [ HALDebug
sign_on  =      "BCM2835 Raspberry Pi",13,10,0
start_os =      "Starting OS",13,10,0
        ALIGN
     ]

d591 1
d594 4
d642 1
a642 1
        NullEntry ; HALEntry HAL_UARTDefault        
d668 1
d671 1
a671 1

d674 2
d710 1
d715 1
a981 20

 |

HAL_DebugTX
HAL_DebugS
HAL_DebugHexTX
HAL_DebugHexTX2
HAL_DebugHexTX4
       MOV     pc, lr
HAL_DebugTXStrInline
       stmfd    r13!, {r0-r3}          ; lr points to prinstring, immediately
                                       ; following call, null terminated
       sub      r3,lr,#1
1      ldrb     r0,[r3,#1]!            ; pop next char, auto incr
       teq      r0,#0                  ; terminating null
       biceq    lr,r3,#3               ; round down address
       ldmeqfd  r13!,{r0-r3}
       addeq    pc,lr,#4               ; return to next word
       b        %bt1                   ; loop

@


1.35
log
@Put the other cores into a holding pattern
Detail:
  s/Top - On multi-core chips, the ARM boot stub has the other cores sat waiting in a loop near &0. Clearing RAM will inadvertantly break them out of this and most likely cause random crashes later on, so inbetween relocating the ROM and clearing RAM make sure we put the cores into a sleep loop in the HAL. Further mailbox writes can then be used to break them out of this loop, using a similar scheme to that used to break them out of the boot stub loop.
  hdr/BCM2835 - Add some register definitions from the BCM2836 docs
Admin:
  Tested on Pi 2B, 3B
  Not currently dealing with kernel_old=1 case where all cores enter the ROM on startup


Version 0.55. Tagged as 'BCM2835-0_55'
@
text
@d473 1
a473 1
        LDR     v1, [a2]
d482 1
@


1.34
log
@Fix SD card activity LED on Pi 3B
Detail:
  hdr/BCM2835 - Remove mailbox definitions - use the ones exported by BCMSupport to avoid needless duplication
  hdr/StaticWS, s/Messaging, s/Top - Use the mailbox property interface to request & map in the virtual GPIO buffer (if present)
  s/SDIO - On the Pi 3B, the GPIO that was used for the SD activity GPIO is now used for a different purpose. To control the activity LED we need to go via an I2C attached GPIO extender, which itself is exposed to the ARM via the new "virtual GPIO" buffer
  s/VCHIQ - Update to use BCMSupport mailbox definitions
Admin:
  Tested on Pi 1B, 3B


Version 0.54. Tagged as 'BCM2835-0_54'
@
text
@d344 47
d447 39
@


1.33
log
@Fix Pi 3 UART clock rate. Add HAL device for the GPU mailboxes.
Detail:
  s/Messaging - Ensure the PL011 UART module clock is set to 3MHz on startup, in order to allow the debug terminal to work
  hdr/StaticWS, s/Top - Add a basic HAL device to expose the GPU mailboxes
Admin:
  Tested on Raspberry Pi 1B/2B/3B
  Fixes garbled debug terminal input/output on Pi 3


Version 0.52. Tagged as 'BCM2835-0_52'
@
text
@d40 4
d592 1
d596 1
d633 11
@


1.32
log
@Fix build error. Add HAL_PlatformName implementation.
Detail:
  s/Stubs, s/Top - Remove references to deleted HAL ATA calls
  s/GPIO, s/Top - Add implementation of HAL_PlatformName. Located in s/GPIO to allow easy re-use of the board revision table.
Admin:
  Tested on Pi 2 Model B


Version 0.51. Tagged as 'BCM2835-0_51'
@
text
@d137 2
d808 1
@


1.31
log
@Add basic HAL device for the official DSI display/touchscreen. Delete superfluous code.
Detail:
  Makefile, s/Touch - Basic HAL device for the official touchscreen, which just exposes the address of the buffer which the GPU periodically fills with a register dump of the touchscreen controller.
  hdr/BCM2835 - Remove old comment. Add new tag for getting the touchscreen buffer address.
  hdr/StaticWS - Remove old workspace entries. Add new entries for touchscreen.
  s/Messaging - Remove the messagebox tags which set a screen mode on startup (BCMVideo will handle that for us), and just blank the screen instead (to stop the GPU displaying a coloured square). Add tag to get the touchscreen buffer address.
  s/Top - Register touchscreen HAL device during HAL_InitDevices. Remove more old code.
Admin:
  Tested on Raspberry Pi 1 B


Version 0.50. Tagged as 'BCM2835-0_50'
@
text
@d113 1
a113 1
        IMPORT  HAL_ATAControllerInfo
d515 3
a517 3
        HALEntry HAL_ATAControllerInfo
        NullEntry ; HAL_ATASetModes
        NullEntry ; HAL_ATACableID
@


1.30
log
@  Compatibility with latest Pi firmware
Detail:
  * Recent versions of the firmware call the ROM's entry point in HYP mode
    (except for ARM11 boards which don't have it). Detect this eventuality
    and drop into SVC mode safely if so.
  * Whilst testing this fix, I discovered that occasionally, secondary CPUs
    seem to be being woken up, and start executing the ROM entry point also.
    This shouldn't be happening, but for safety's sake, I'm detecting this
    eventuality and putting any secondary CPUs into a sleep loop.
Admin:
  Tested on Pi 1 and 2. Requires HdrSrc 2.56.

Version 0.49. Tagged as 'BCM2835-0_49'
@
text
@d135 2
a143 1
        IMPORT  Displ
a264 5

        LDR     r3, FB_Base
     mov r0,r3
     bl HAL_DebugHexTX4

a583 2
        LDR     a3, FB_Size
        LDR     a2, FB_Base                  ; effectively part of the ROM image
d585 1
a586 2
        STR     a3, FB_Size                  ; put in our workspace
        STR     a2, FB_Base                  ; for HAL_FramestoreAddress use
d588 1
d590 2
a591 2
        LDR     a3, VC_Size                  ; VC Start
        LDR     a2, VC_Base                  ; VC_Size
d595 2
a596 2
        STR     a3, VC_Size                  ; VC Start
        STR     a2, VC_Base                  ; VC_Size
d805 1
@


1.29
log
@Don't map in VC memory
Detail:
  hdr/StaticWS, s/Top - Removed code to map in all of VC memory. Currently nothing needs it, and the code was broken anyway (debug output would corrupt a1 value given to OS_MapInIO)
Admin:
  Tested on Raspberry Pi


Version 0.46. Tagged as 'BCM2835-0_46'
@
text
@d200 28
a227 2
start   MSR     CPSR_c,#F32_bit+I32_bit+SVC32_mode

@


1.28
log
@Add basic HAL devices for the SPI controllers
Detail:
  s/SPI - Basic HAL devices for the 3 SPI controllers. These expose the register addresses & IRQ numbers, and (for SPI1 & SPI2) deal with enabling/disabling the hardware and the shared IRQ line. GPIO mapping currently isn't dealt with - we don't know which pin group to use (SPI0 can use two different sets on the compute) or how many chip select lines are desired.
  Makefile - Add SPI source
  hdr/BCM2835 - Add aux SPI registers
  hdr/StaticWS - Reserve workspace for the HAL devices
  s/Top - Register new devices in HAL_InitDevices
Admin:
  Tested on Raspberry Pi B & 2 B


Version 0.45. Tagged as 'BCM2835-0_45'
@
text
@a587 3
        MOV     a1, #0                   ; map in the whole of the VC memory as
                                         ; IO to avoid subsequent logical
                                         ; address space fragmentation
a593 5
        CallOS  OS_MapInIO
        STR     a1, VC_Logical
     bl HAL_DebugHexTX4
        

@


1.27
log
@  Add support for Raspberry Pi Compute module and Raspberry Pi 2
Detail:
  * Compute module support consists of eMMC support in the SDHCI driver. The
    eMMC chip on the Compute module only works reliably if under-clocked to
    25 MHz.
  * Pi 1 vs Pi 2 differences are selected at runtime by checking the CPU ID,
    so a single ROM image will work with both boards.
  * Added ARMv7 cache maintenance routine for use on Pi 2.
  * The physical address of the peripherals has moved in Pi 2 to make space
    for the 1 GB of RAM.
  * The ARM physical address space is mapped differently onto the GPU
    address space in Pi 2 because the ARM now uses the L2 cache that comes
    with the Cortex-A7 instead of the GPU's L2 cache.
  * Still waiting for confirmation on the board revision ID that will be
    used for Pi 2, so may require further tweaks for production releases.


Version 0.40. Tagged as 'BCM2835-0_40'
@
text
@d133 2
d792 1
@


1.26
log
@Don't bother providing even dummy implementations of USB port and overcurrent functions
As the flag bit in HAL_USBControllerInfo isn't set, no need to provide them.
Use symbols from Hdr:HALEntries when building the USB info.
Built, but not tested.


Version 0.38. Tagged as 'BCM2835-0_38'
@
text
@d212 5
a216 1
        LDR     r4,=IO_Base
d540 5
a544 1
        LDR     a2, =IO_Base
d751 5
a755 1
        SUB     a2, a2, #524288-(IO_Base>>13)
@


1.25
log
@Use IIC status definitions from HALEntries header
Mark HAL_IICDevice as a null entry, since bit 4 of the flags says we don't support that mode of operation anyway.

Version 0.32. Tagged as 'BCM2835-0_32'
@
text
@a120 3
        IMPORT  HAL_USBPortPower
        IMPORT  HAL_USBPortStatus
        IMPORT  HAL_USBPortIRQ
d506 3
a508 3
        HALEntry HAL_USBPortPower
        HALEntry HAL_USBPortStatus
        HALEntry HAL_USBPortIRQ
@


1.24
log
@Add RTC HAL device
Detail:
  CJE's RTC module uses a DS1307-compatible RTC chip similar to the one used in the Iyonix. Previously the kernel handled talking to it, but now that low-level RTC handling has been moved out of the kernel we need an RTC HAL device in the BCM2835 HAL instead.
  s/RTC - A copy of s.RTC from the Tungsten HAL, relicensed as BSD with permission from Rob Sprowson
  Makefile, hdr/StaticWS, s/Top - Additional changes needed to hook the code into the HAL
Admin:
  Tested on Raspberry Pi, but without an RTC module fitted
  However the similarity of the clock chip to the one in the Iyonix should mean there's little chance of this code failing to work correctly when an RTC is fitted


Version 0.31. Tagged as 'BCM2835-0_31'
@
text
@a78 1
        IMPORT  HAL_IICDevice
d418 1
a418 1
        HALEntry HAL_IICDevice
@


1.23
log
@Remove obsolete stub HAL video API implementation
Detail:
  s/Top, s/Video - Removed obsolete HAL video API implementation. A stub implementation is no longer required for systems that have a GraphicsV driver in a module, and can even cause problems if the OS decides to use the HAL implementation instead of the module one.
Admin:
  Tested in BCM2835 ROM
  Requires Kernel-5_35-4_79_2_203


Version 0.30. Tagged as 'BCM2835-0_30'
@
text
@d135 2
d781 1
@


1.22
log
@Implement HAL_IRQMax
Detail:
  hdr/BCM2835 - Add definition for highest IRQ number
  s/Boot, s/Interrupts - Added HAL_IRQMax implementation, to ensure correct functionality with latest Kernel
Admin:
  Tested on 256MB Pi model B
  Requires Kernel-5_35-4_79_2_182


Version 0.29. Tagged as 'BCM2835-0_29'
@
text
@a90 18
        IMPORT  HAL_VideoFlybackDevice
        IMPORT  HAL_VideoSetMode
        IMPORT  HAL_VideoWritePaletteEntry
        IMPORT  HAL_VideoWritePaletteEntries
        IMPORT  HAL_VideoReadPaletteEntry
        IMPORT  HAL_VideoSetInterlace
        IMPORT  HAL_VideoSetBlank
        IMPORT  HAL_VideoSetPowerSave
        IMPORT  HAL_VideoUpdatePointer
        IMPORT  HAL_VideoSetDAG
        IMPORT  HAL_VideoVetMode
        IMPORT  HAL_VideoPixelFormats
        IMPORT  HAL_VideoFeatures
        IMPORT  HAL_VideoBufferAlignment
        IMPORT  HAL_VideoOutputFormat
        IMPORT  HAL_VideoRender
        IMPORT  HAL_VideoIICOp
                
a125 3
        IMPORT  HAL_VideoFramestoreAddress
        IMPORT  HAL_VideoStartupMode
        
d421 15
a435 15
        HALEntry HAL_VideoFlybackDevice
        HALEntry HAL_VideoSetMode
        HALEntry HAL_VideoWritePaletteEntry
        HALEntry HAL_VideoWritePaletteEntries
        HALEntry HAL_VideoReadPaletteEntry
        HALEntry HAL_VideoSetInterlace
        HALEntry HAL_VideoSetBlank
        HALEntry HAL_VideoSetPowerSave
        HALEntry HAL_VideoUpdatePointer
        HALEntry HAL_VideoSetDAG
        HALEntry HAL_VideoVetMode
        HALEntry HAL_VideoPixelFormats
        HALEntry HAL_VideoFeatures
        HALEntry HAL_VideoBufferAlignment
        HALEntry HAL_VideoOutputFormat
d506 1
a506 1
        HALEntry HAL_VideoRender
d512 1
a512 1
        HALEntry HAL_VideoIICOp
d519 1
a519 1
        HALEntry HAL_VideoFramestoreAddress
d523 1
a523 1
        HALEntry HAL_VideoStartupMode    
@


1.21
log
@Fix building with latest kernel
Detail:
  s/Top, s/Video - Renamed HAL_Video entries to match naming convention used by latest kernel
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.26. Tagged as 'BCM2835-0_26'
@
text
@d59 1
d525 1
a525 1
        NullEntry ;HALEntry HAL_MonitorLeadID
@


1.20
log
@Add a video HAL device to allow BCMVideo to determine which DMA channel it can use for render ops
Detail:
  hdr/StaticWS, s/Top, s/Video - Added a simple VDU HAL device that exposes a DMA channel to BCMVideo for use with GraphicsV_Render
  hdr/BCM2835 - Don't allow DMA channel 12 to be used; latest firmware seems to have a bug which claims its free when in reality it isn't.
  s/Messaging, s/DMA - Adjust DMA init to allow the video device to claim a DMA channel before the DMA devices are initialised
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.25. Tagged as 'BCM2835-0_25'
@
text
@d91 16
a106 16
        IMPORT  HAL_Video_SetMode
        IMPORT  HAL_Video_WritePaletteEntry
        IMPORT  HAL_Video_WritePaletteEntries
        IMPORT  HAL_Video_ReadPaletteEntry
        IMPORT  HAL_Video_SetInterlace
        IMPORT  HAL_Video_SetBlank
        IMPORT  HAL_Video_SetPowerSave
        IMPORT  HAL_Video_UpdatePointer
        IMPORT  HAL_Video_SetDAG
        IMPORT  HAL_Video_VetMode
        IMPORT  HAL_Video_PixelFormats
        IMPORT  HAL_Video_Features
        IMPORT  HAL_Video_BufferAlignment
        IMPORT  HAL_Video_OutputFormat
        IMPORT  HAL_Video_Render
        IMPORT  HAL_Video_IICOp
d143 2
a144 2
        IMPORT  HAL_Video_FramestoreAddress
        IMPORT  HAL_Video_StartupMode
d442 14
a455 14
        HALEntry HAL_Video_SetMode
        HALEntry HAL_Video_WritePaletteEntry
        HALEntry HAL_Video_WritePaletteEntries
        HALEntry HAL_Video_ReadPaletteEntry
        HALEntry HAL_Video_SetInterlace
        HALEntry HAL_Video_SetBlank
        HALEntry HAL_Video_SetPowerSave
        HALEntry HAL_Video_UpdatePointer
        HALEntry HAL_Video_SetDAG
        HALEntry HAL_Video_VetMode
        HALEntry HAL_Video_PixelFormats
        HALEntry HAL_Video_Features
        HALEntry HAL_Video_BufferAlignment
        HALEntry HAL_Video_OutputFormat
d526 1
a526 1
        HALEntry HAL_Video_Render
d532 1
a532 1
        HALEntry HAL_Video_IICOp
d539 1
a539 1
        HALEntry HAL_Video_FramestoreAddress
d543 1
a543 1
        HALEntry HAL_Video_StartupMode    
@


1.19
log
@Implement HAL_PhysInfo. Other misc tweaks.
Detail:
  s/Top - Added HAL_PhysInfo implementation. Tweaked HAL_Reset to reduce chances of failure.
  s/Stubs - Removed obsolete, unused UART stubs. Use KbdFlag_Done instead of magic number.
Admin:
  Tested on Raspberry Pi


Version 0.23. Tagged as 'BCM2835-0_23'
@
text
@d153 2
d794 1
@


1.18
log
@Read board model, revision, and available DMA channels from messaging channel. Report board revision via GPIO HAL device. Recover lost ROM relocation code.
Detail:
  hdr/StaticWS, s/Messaging, s/Top - Now reads board model, revision and available DMA channels from messaging channel
  hdr/StaticWS, s/GPIO - Updated GPIO HAL device to report board revision instead of a generic response of 'unknown'
  s/Top - Recovered ROM relocation code that got lost during a merge. End of ROM image no longer being corrupted, and RISC OS now sees correct amount of RAM.
  s/DMA - Ditch old code to read available DMA channels and use value read by HAL_QueryPlatform instead.
Admin:
  Tested on Raspberry Pi (B rev 1) with various start.elf sizes & versions
  DMA channel reporting only available with latest firmware (i.e. 8th Sep)
  Board revision number read by messaging channel seems to match that returned by /proc/cpuinfo on Linux


Version 0.22. Tagged as 'BCM2835-0_22'
@
text
@d267 2
d582 2
d587 2
d713 3
d718 1
d727 1
a727 2
        MOV     pc, lr

d729 57
a786 1
HAL_PhysInfo
@


1.17
log
@Strip out video code & on-screen debug
Detail:
  Makefile, s/Display - Deleted on-screen debug code
  hdr/BCM2835, hdr/StaticWS, s/IIC, s/Messaging, s/Stubs, s/Top, s/UART - Strip out calls to on-screen debug code, and a few bits of video code
  s/Video - Video code removed and replaced with stub functions similar to other HALs. Only remaining useful code is HAL_Video_StartupMode, which in time should probably be moved to BCMVideo as well.
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.21. Tagged as 'BCM2835-0_21'
@
text
@a261 1
ROMTOP   *  6    <<20
d266 59
a324 4
        LDMIA   a3, {a1, a2}       ; a1=base, a2=size
 [ HALDebug
        bl      HAL_DebugTXStrInline
        DCB     "HalStartup3 .. rst  rsz",10,0
d326 1
a326 9
        bl      HAL_DebugHexTX4   ; ram start
        mov     a1, a2
        bl      HAL_DebugHexTX4   ; ram end
        LDMIA   a3, {a1, a2}
  ]

; debug hack to force 128meg ram and 6meg rom
;        MOV     v2, #ROMTOP     ;start of available RAM, after HAL + OS image
;        MOV     a1, #RAMTOP     ; end of RAM
d328 5
a332 2
        ADD     v2, a1, #ROMTOP   ; start of free ram
        ADD     a1, a2, a1        ; end of RAM
d336 1
a339 1
        MOV     ip, #0
d342 9
a350 16
clear_lp
        STMDB   a1!,{a2-a4,v4,v5,v7,ip,lr}
        STMDB   a1!,{a2-a4,v4,v5,v7,ip,lr}
        STMDB   a1!,{a2-a4,v4,v5,v7,ip,lr}
        STMDB   a1!,{a2-a4,v4,v5,v7,ip,lr}
        CMP     a1, v2
        BHI     clear_lp
        mov     a2, v2
                                       ; a2 now -> first free ram location
        ADRL    a3, workspace
        ADRL    lr,RamAd
        LDR     lr, [lr]
        ADD     lr, a3, lr
        LDR     a3, [lr, #4]    ; size
        SUB     a3, a3, #ROMTOP ; less what is used
        ADD     a3, a3, a2
d583 8
@


1.16
log
@  Addition of I2C support
Detail:
  Implementation of the high-level HAL IIC interface provided by Dave Higton.
Admin:
  Checked it builds and runs at ROOL.

Version 0.20. Tagged as 'BCM2835-0_20'
@
text
@d74 2
a75 2
                
        IMPORT  IIC_Init
d144 1
a164 8
        IMPORT  clear_block
        IMPORT  set_text_colours
        IMPORT  output_char
        IMPORT  output_hex8
        IMPORT  output_newline
        IMPORT  output_regs
        IMPORT  output_text
        IMPORT  output_text_at
d201 1
a201 11
        ADRL    sb,workspace
        ADRL    R13,end_stack
     [ HALDebug
        ADR     R0,irq_text
        MOV     R1,#0
        MOV     R2,#0
        ADR     R14,interrupt
        B       output_text_at
     |
        B       interrupt
     ]
d204 1
a204 11
        ADRL    sb,workspace
        ADRL    R13,end_stack
     [ HALDebug
        ADR     R0,fiq_text
        MOV     R1,#0
        MOV     R2,#0
        ADR     R14,fast_interrupt
        B       output_text_at
     |
        B       fast_interrupt
     ]
d207 1
a207 11
        ADRL    sb,workspace
        ADRL    R13,end_stack
     [ HALDebug
        ADR     R0,swi_text
        MOV     R1,#0
        MOV     R2,#0
        ADR     R14,swi_instr
        B       output_text_at
     |
        B       swi_instr
     ]
d210 1
a210 11
        ADRL    sb,workspace
        ADRL    R13,end_stack
     [ HALDebug
        ADR     R0,pabt_text
        MOV     R1,#0
        MOV     R2,#0
        ADR     R14,prefetch_abort
        B       output_text_at
     |
        B       prefetch_abort
     ]
d213 1
a213 11
        ADRL    sb,workspace
        ADRL    R13,end_stack
     [ HALDebug
        ADR     R0,dabt_text
        MOV     R1,#0
        MOV     R2,#0
        ADR     R14,data_abort
        B       output_text_at
     |
        B       data_abort
     ]
d216 1
a216 21
        ADRL    sb,workspace
        ADRL    R13,end_stack
     [ HALDebug
        ADR     R0,und_text
        MOV     R1,#0
        MOV     R2,#5
        ADR     R14,undefined_instr
        B       output_text_at
     |
        B       undefined_instr
     ]

     [ HALDebug
fiq_text        =       "FIQ",0
irq_text        =       "IRQ",0
swi_text        =       "SWI",0
pabt_text       =       "Prefetch Abort",0
dabt_text       =       "Data Abort",0
und_text        =       "Undefined Instruction",0
        ALIGN
     ]
a251 13
;        ADR     R0, mbram
;        ORR     R2, R0, #GPU_L2CnonAl + MB_Chan_FB;  L2 cache on
;        MOV     R0, R2
;        MOV     r1, #0
;;        BL      HAL_SendHostMessage
;         
;        ldr     r3, mbscrsz
;        str     r3, FB_Size
;     mov r0,r3
;     bl HAL_DebugHexTX4
;        ldr     r3, mbbase
;        bic     r3, r3, #GPU_CacheMask
;        str     r3, FB_Base
a256 46
     [ HALDebug
        STR     R3,ScreenBase     ; for HAL use, remember address we were given
        LDR     r0,mbbpp
        STR     R0,BytesPerChar
        LDR     r3,mbxres
        MUL     r3, r0, r3
        STR     R0,BytesPerRow
        
1002    MOV     R0, R3, LSR #3    
        STR     R0,Columns
        LDR     R0, mbyres
        MOV     R0, r0, lsr #3
        STR     R0,Rows
        MOV     R0,#0
        STR     R0,InvertFont
        STR     R0,OutputX
        STR     R0,OutputY

        LDR     r8, mbbpp
        CMP     r8, #16
        MOVGT   R0,#&FF000000
        MOVGT   R1,#&FF000000
        MVNLE   R0,#0
        MOVLE   R1,#0
        STR     R8,BitsPerPixel
        BL      set_text_colours

        MOV     R0,#0
        MOV     R1,#0
        LDR     R2,Columns
        LDR     R3,Rows
        BL      clear_block

        LDR     r8, mbbpp
        CMP     r8, #16
        MVNGT   R0,#0
        MOVGT   R1,#&FF000000
        MOV     R8,#32
        MOVLE   R0,#&1F<<10
        MOVLE   R1,#0
        BL      set_text_colours

        MOV     R0,#0
        MOV     R1,#0
        ADR     R2,sign_on
        BL      output_text_at
a261 1
     ]
a324 7

  
     [ HALDebug
        ADR     R0,start_os
        BL      output_text
     ]

d495 4
d510 15
d536 2
a537 3
        LDR     a1, mbxres
        LDR     a2, mbyres
        LDR     a3, mbbpp
d539 17
a555 3
        STR     a1, mbxres
        STR     a2, mbyres
        STR     a3, mbbpp
a566 6
        MOV     a1, #0                   ; map in the IO space
        LDR     a2, =IO_Base
        LDR     a3, =IO_Size
        CallOS  OS_MapInIO
        STR     a1, PeriBase

a570 43
        MOV     a1,#0                   ; start the uart ..we use it for debug
        BL      HAL_UARTStartUp         ; restart to capture logical io address

        ; Map in the frame buffer
        ;    and initialise the display driver
        LDR     a3, FB_Size
        LDR     a2, FB_Base                  ; effectively part of the ROM image
     mov r0,a2
     bl HAL_DebugHexTX4
     mov r0,a3
     bl HAL_DebugHexTX4
        MOV     a1, #0
        STR     a1, LastInt
        STR     a1, CurAddr

        CallOS  OS_MapInIO
        STR     a1,ScreenBase
     bl HAL_DebugHexTX4
     
        LDR     a1,mbxres
        LDR     a2,mbbpp   ;=1920*8*4
        STR     a2,BitsPerPixel
        MUL     a1, a2, a1
        STR     a1,BytesPerRow
        STR     a2,BytesPerChar
        LDR     a1,mbxres
        MOV     a1, a1, lsr #3
        STR     a1,Columns
        LDR     a1,mbyres
        MOV     a1, a1, lsr #3
        STR     a1,Rows
        MOV     a1,#0
        STR     a1,InvertFont
        MOV     a1,#4
        STR     a1,OutputX
        STR     a1,OutputY

        CMP     a2, #16
        MOVGT   a1,#-1
        MOVGT   a2,#&FF000000
        MVNLE   a1,#0
        MOVLE   a2,#0
        MOVLE   a1,a1,LSR #17
a571 10
        BL      set_text_colours

        ADR     a1,hal_init
        BL      output_text
     ]

     [ HALDebug
        ADR     a1,uart_started
        BL      output_text
   
a592 1

a595 1
MBAd  DCD     :INDEX:workspace + :INDEX:mbram
@


1.15
log
@Detail:
	changed HAL_ExtMachineID return value to 0 so kernel then calls
	HAL_MachineID and fetches the MAC address correctly

Admin:


Version 0.19. Tagged as 'BCM2835-0_19'
@
text
@d75 1
d687 1
@


1.14
log
@Don't claim that we support soft-off
Detail:
  s/Top - Fix HAL_PlatformInfo to not claim that we support soft-off
Admin:
  Tested in Pi ROM
  Fixes machine restarting after shutdown


Version 0.18. Tagged as 'BCM2835-0_18'
@
text
@d824 1
a824 1
        MOV     a1, #16
@


1.13
log
@Add GPIO & VCHIQ HAL devices. Fix FlushDataCache macro to perform a clean & invalidate instead of just an invalidate.
Detail:
  s/GPIO - Basic implementation of the GPIO HAL device to allow the GPIO module to detect the board type
  s/VCHIQ, hdr/StaticWS - New VCHIQ HAL device which exposes the functionality required by the work-in-progress VCHIQ driver.
  Makefile, s/Top - Hook up the new files/devices
  hdr/BCM2835 - Make the FlushDataCache macro perform a clean & invalidate, to match the behaviour of FlushDataCacheRange
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.17. Tagged as 'BCM2835-0_17'
@
text
@d802 1
a802 1
        MOV     ip, #2_11000    ; no podules,no PCI cards,no multi CPU,no soft off,and soft ROM
@


1.12
log
@Detail: removed a flaw that crept in the last commit which prevented
        correct screen display.
	Now expects a start.elf released 24/7/2012 or later for correct
	display initialisation
Admin:


Version 0.16. Tagged as 'BCM2835-0_16'
@
text
@d147 4
d850 2
@


1.11
log
@Detail:  Frame buffer allocation via message channel almost complete. working
        HAL_MachineID functioning correctly
Admin:


Version 0.15. Tagged as 'BCM2835-0_15'
@
text
@d324 13
a336 13
        ADR     R0, mbram
        ORR     R2, R0, #GPU_L2CnonAl + MB_Chan_FB;  L2 cache on
        MOV     R0, R2
        MOV     r1, #0
        BL      HAL_SendHostMessage
         
        ldr     r3, mbscrsz
        str     r3, FB_Size
     mov r0,r3
     bl HAL_DebugHexTX4
        ldr     r3, mbbase
        bic     r3, r3, #GPU_CacheMask
        str     r3, FB_Base
d338 1
d704 1
a704 1
        STR     R2,BitsPerPixel
@


1.10
log
@
	Various updates to do with the messaging channel, HAL_MachineID, and HAL_Reset

Detail:
	HAL_Reset now causes a complete reboot of the machiine. It isnt yet properly called from
	the kernel.. I've not investigated why yet. Behaviour tested using OS_Hardware call

	HAL_MachineID, with the github start.elf from 18 July 2012 will provide a valid MAC address ..
	i.e. that specific to this machine. The a1 value in HAL_ExtendedID needs to be set 0 for this to be reported
	by OS_ReadSysInfo .. unfortunately, again at this stage, it stalls the boot when set 0, so just for now
	the committed value for a1 in HAL_ExtendedID is not 0 .

	centralised messaging routine added. This is used a fair bit in acquiring the operating environment
	Not yet used in the DMA stuff. probably ought to be. At present the messaging channel this mainly
	handles is not complete, so information from this code is still WIP

Admin:
  (highlight level of testing that has taken place)
  (bugfix number if appropriate)


Version 0.14. Tagged as 'BCM2835-0_14'
@
text
@a151 1
        IMPORT  MacAdd
d321 1
a323 16

        ldr     r1, =1920
        str     r1, mbxres
        str     r1, mbxvres
        ldr     r1, =1080
        str     r1, mbyres
        str     r1, mbyvres
 [ SCR32       
        mov     r1, #32
 |
        MOV     r1, #16
 ]
        str     r1, mbbpp
        ADD     R4, R4, #MB_Base


d325 1
a325 1
        ORR     R2, R0, #GPU_L2CnonAl + MB_Chan_FB; try with L2 cache on
a326 1
10
a334 3
        and     r1, r3, #GPU_CacheMask
        str     r1, FB_CacheMode
     bl HAL_DebugHexTX4
d337 1
a340 2


d342 2
a343 5
        [ SCR32
        LDR     R0,=1920*8*4
        STR     R3,ScreenBase               ; for HAL use, remember address we were given
        STR     R0,BytesPerRow
        MOV     R0,#8*4
d345 2
a346 3
        |
        LDR     R0,=1920*8*2
        STR     R3,ScreenBase
d348 2
a349 4
        MOV     R0,#8*2
        STR     R0,BytesPerChar
        ]
        MOV     R0,#1920/8
d351 2
a352 1
        MOV     R0,#1080/8
d359 6
a364 10
        [ SCR32
        MOV     R0,#&FF000000
        MOV     R1,#&FF000000
        MOV     R8,#32
        |
        MVN     R0,#0
        MOV     R1,#0
        MOV     R0,R0,LSR #17
        MOV     R8,#16
        ]
d374 4
a377 3
        [ SCR32
        MVN     R0,#0
        MOV     R1,#&FF000000
d379 2
a380 5
        |
        MOV     R0,#&1F<<10
        MOV     R1,#0
        MOV     R8,#16
        ]
a393 1
RAMTOP   *  128  <<20
d398 1
a398 1
        LDMIA   a3, {a1, a2}
d400 3
a405 2
        mov     a1, a3
        bl      HAL_DebugHexTX4   ; ram end
d409 6
a414 3
     ; debug hack to force 128meg ram and 6meg rom
        MOV     v2, #ROMTOP     ;start of available RAM, after HAL + OS image
        MOV     a1, #RAMTOP     ; end of RAM
d432 6
a437 1
        ADD     a3, a2, #RAMTOP ; end of RAM
d439 5
d448 1
d654 8
a688 2
;        LDR     a1, FB_CacheMode
;        ORR     a2, a2, a1                   ; combine in the address we need 'the other side'
d700 5
a704 8

        [ SCR32
        LDR     a1,=1920*8*4
        STR     a1,BytesPerRow
        MOV     a1,#8*4
        STR     a1,BytesPerChar
        |
        LDR     a1,=1920*8*2
d706 3
a708 4
        MOV     a1,#8*2
        STR     a1,BytesPerChar
        ]
        MOV     a1,#1920/8
d710 2
a711 1
        MOV     a1,#1080/8
d719 6
a724 11
        [ SCR32
        MOV     a1,#-1
        MOV     a2,#&FF000000
        MOV     R8,#32
        |
        MVN     a1,#0
        MOV     a2,#0
        MOV     a1,a1,LSR #17
        MOV     R8,#16
        ]
        STR     R8,BitsPerPixel
d761 1
d810 4
a813 52
        STMFD   sp!,{a3-a4,v1-v4,lr}
        MOV     a1, #0
        MOV     a2, #0
        ADRL    a3, workspace
        ADRL    lr,MacAdd
        LDR     lr, [lr]
        ADD     a3, a3, lr

        LDR     lr, [a4, #-4]       ; check if message completed
        TST     lr, #&80000000      ; NE if successful
        MOVEQ   a1, #0
        MOVEQ   a2, #0
        LDMEQFD sp!,{a3-a4,v1-v4,pc}; didn't read mac .. exit failed
        
        LDMIA   a3, {a1, a2}
        AND     a3, a1, #&ff000000
        MOV     a3, a3, LSR #24
        ORR     a2, a3, a2, LSL #8
        MOV     a1, a1, LSL #8
        ORR     a1, a1, #&81
        BIC     a2, a2, #&ff000000
; now encapsulate with crc
        MOV     a3, #0                 ;
        MOV     a4, #7                 ; number of bytes to do
gbyte                                  ;
        AND     v2, a1, #&ff           ; get next byte. shift reg round 8 byte
        AND     v3, a2, #&ff           ; shift reg round 8 byte
        MOV     v1, v2, lsl #24
        MOV     v3, v3, lsl #24
        ORR     a1, v3, a1,lsr #8      ; shift reg round 8 byte
        ORR     a2, v1, a2,lsr #8      ; shift reg round 8 byte

        EOR     a3, a3, v2             ;                                  
        MOV     v1, #8                 ; number of bits to do
gbit                                   ;                                  
        MOVS    a3, a3, LSR #1         ; shift bit out into carry
        EORCS   a3, a3, #&8C           ; feedback carry into other bits
        SUBS    v1, v1, #1             ; one less bit to do               
        BNE     gbit                   ; loop until done whole byte       
        SUBS    a4, a4, #1             ; one less byte to do
        BNE     gbyte                  ; loop until done all 7 bytes

        AND     v2, a1, #&ff           ; get next byte. shift reg round 8 byte
        AND     v3, a2, #&ff           ; shift reg round 8 byte
        MOV     v1, v2, lsl #24
        MOV     v3, v3, lsl #24
        ORR     a1, v3, a1,lsr #8      ; shift reg round 8 byte
        ORR     a2, v1, a2,lsr #8      ; shift reg round 8 byte

        ORR     a2, a2, a3, lsl #24    ; insert crc into hi byte

        LDMFD   sp!,{a3-a4,v1-v4,pc}
d815 1
d819 1
a819 1
        MOV     a1, #10                 ; 0 -use HAL_MachineID, 16 -use this 
d821 1
a821 1

@


1.9
log
@Improve RAM detection/setup code. Update mailbox code in DMA driver.
Detail:
  s/Top - Improved RAM detection/setup to not assume that the OS image is at &0000 (current start.elf seems to place it at &8000). New code correctly supports compressed ROMs, and has some basic code implemented to read the RAM setup from the mailbox property interface (currently disabled, pending official firmware rollout + final testing)
  s/DMA - Updated mailbox property interface code to adhere to the current spec. Still needs testing with release firmware (the start.elf I'm using seems to report no DMA channels as being available)
Admin:
  Tested with a release start.elf (July 9th, or thereabouts) as well as a more recent test version containing initial mailbox property interface implementation
  Fixes issue with last 32K of ROM being wiped on startup


Version 0.13. Tagged as 'BCM2835-0_13'
@
text
@d148 3
d152 5
d303 4
a308 2
        LDR     r4,=IO_Base
        STR     r4,PeriBase
a314 2
        LDR     R4,mbox_addr

d318 7
a324 22
        LDR     r3,=(16:SHL:MB_Pwr_USB)+MB_Chan_Pwr
        STR     r3,[r4,#MB_ChWr]
09
        LDR     r1,[r4,#MB_Sta]
        TST     r1,#MB_Sta_Empty
        BNE     %BT09
        LDR     r0,[r4,#MB_ChRd]
        CMP     r0,r3
        BNE     %BT09        
        
 [ UseALBlob
        ; For now, just assume that we have 40MB of memory...
        ; set frame buffer at the top...1920x1080x32bpp requires 8MB
        LDR     R1,=FB_Length
        STR     R1, FB_Size
        LDR     R1,=FB_Address
        STR     R1, FB_Base
        ORR     R3,R1,#DMA_RAM_Base + MB_Chan_FB
        STR     R3,[R4,#MB_ChWr]
        and     r0, r3, #GPU_CacheMask
        str     r0, FB_CacheMode 
 |
d337 13
a349 12
        ADR     r1, mbram
        ORR     R3, R1, #GPU_L2CnonAl + MB_Chan_FB; try with L2 cache on
10      str     r3, [r4, #MB_ChWr]
11      ldr     r0, [r4, #MB_Sta]            ; await response
        tst     r0, #MB_Sta_Empty
        bne     %bt11
        ldr     r0, [r4, #MB_ChRd]
        teq     r0, #MB_Chan_FB
        bne     %bt11                       ; not the response to our request
        ldr     r1, mbscrsz
        str     r1, FB_Size
     mov r0,r1
d351 3
a353 3
        ldr     r1, mbbase
        and     r0, r1, #GPU_CacheMask
        str     r0, FB_CacheMode 
d355 3
a357 6
        teq     r1, #0                      ;did we get an answer
        ORREQ   R3, R3, #GPU_UnCached + MB_Chan_FB; try with L2 cache off
        BEQ     %BT10                       ; 0 size.. try with L2 off
        bic     r1, r1, #GPU_CacheMask
        str     r1, FB_Base
     mov r0,r1
a360 1
 ]
d365 1
a365 1
        STR     R1,ScreenBase               ; for HAL use, remember address we were given
d371 1
a371 1
        STR     R1,ScreenBase
d425 14
a438 34
 [ UseALBlob        ; nolonger used
        ; Traverse list of 'atags' structures
        ; word 0 = size of tag, including header, in words
        ; word 1 = type tag

ATAG_MEM        *       &54410002
ATAG_NONE       *       0

        ADRL    v1, HAL_Base + OSROM_HALSize
        LDR     v2, [v1, #OSHdr_ImageSize]
        ADD     v2, v2, v1      ; End of OS

        ADRL    v3, atags
atags_loop
        LDR     a1, [v3, #4]    ;tag type
        LDR     a2, [v3]        ;size of tag inc header, in words

        SUB     a4, a1, #ATAG_MEM :AND: &FF000000
        SUB     a4, a4, #ATAG_MEM :AND: &00FF0000

        TEQ     a4, #ATAG_MEM :AND: &FFFF
        BNE     atag_next

        ; clear RAM

        LDR     a1, [v3, #8]    ;RAM size
        LDR     lr, [v3, #12]   ;RAM start

  [ UseALBlob
        ;!!! bodge to exclude frame buffer
        LDR     a3, =FB_MemBase   
        CMP     a1, a3
        MOVHI   a1, a3
        STRHI   a1, [v3, #8]
d440 4
a450 1
        ADD     a1, a1, lr      ;end of RAM
d460 3
a462 9

;!!! this assumes single call :)

        LDR     lr, [v3]        ;tag size, words
        LDR     v1, [v3, #8]    ;RAM size
        LDR     a4, [v3, #12]   ;RAM start
        MOV     a2, v2          ;start of available RAM, after HAL + OS image
        ADD     a3, v1, a4      ;end of RAM
        ADD     v3, v3, lr, LSL #2 ;next tag
a473 1
        B       atags_loop
a474 172
atag_next
        TEQ     a1,#ATAG_NONE
        ADDNE   v3, v3, a2, LSL #2
        BNE     atags_loop
 |

        ; Determine how much RAM we have available
  [ {FALSE} ; Below code believed to work OK with a test start.elf, but need to retest with a release version to be sure
        MOV     v7, sp
        BIC     sp, sp, #31
        SUB     sp, sp, #32
        MOV     a1, sp ; buffer for mailbox message
        MOV     a2, #32
        MOV     a3, #0
        LDR     a4, =ARM2VC_Tag_GetARMMemory
        MOV     v1, #8 ; Assume only 1 RAM block (8 byte response buffer)
        MOV     v2, #0
        MOV     v3, #0
        MOV     v4, #0
        MOV     v5, #ARM2VC_Tag_End
        STMIA   a1, {a2-v5}
        DoMemBarrier lr
        ORR     a2, a1, #MB_Chan_ARM2VC
        LDR     a3, FB_CacheMode
        ADD     a2, a2, a3
        LDR     a3, mbox_addr
        STR     a2, [a3, #MB_ChWr] ; send command
getram_01
        LDR     a1, [a3,#MB_Sta]
        TST     a1, #MB_Sta_Empty
        BNE     getram_01
        LDR     a1, [a3,#MB_ChRd]
        CMP     a1, a2
        BNE     getram_01
        ; Default response: 128MB of RAM at &0
        MOV     v3, #0
        MOV     v4, #128<<20
        ; Check response
        DoMemBarrier lr
        MOV     a2, sp
      [ HALDebug
        MOV     a3, #32
getram_04
        LDR     a1, [a2], #4
        BL      HAL_DebugHexTX4
        SUBS    a3, a3, #4
        BNE     getram_04
        BL      HAL_DebugTXStrInline
        DCB     "GetARMMemory response",10,0
        MOV     a2, sp
      ]        
        LDR     a1, [a2, #4]
        CMP     a1, #&80000000
        BNE     getram_09
        ; Scan for our tag in the response
        LDR     a3, [a2], #8
getram_08
        SUBS    a3, a3, #12
        BLE     getram_09 ; No space for a tag
        LDMIA   a2!, {a4,v1,v2}
        CMP     a4, #ARM2VC_Tag_End
        BEQ     getram_09
        LDR     v3, =ARM2VC_Tag_GetARMMemory
        CMP     a4, v3 ; right tag?
        CMPEQ   v2, #&80000008 ; response of right length?
        ADDNE   v1, v1, #3
        BICNE   v1, v1, #3
        ADDNE   a2, a2, v1
        SUBNE   a2, a2, v1
        BNE     getram_08
        LDMIA   a2, {v3,v4}
getram_09
        MOV     sp, v7
  |
        ; Assume 128MB of RAM at &0
        MOV     v3, #0
        MOV     v4, #128<<20
  ]
      [ HALDebug
        ADRL    a1, reset
        BL      HAL_DebugHexTX4
        MOV     a1, v3
        BL      HAL_DebugHexTX4
        MOV     a1, v4
        BL      HAL_DebugHexTX4
        BL      HAL_DebugTXStrInline
        DCB     "ROM start, RAM start, RAM size", 10, 0
      ]
relocate_code
        ; Relocate ROM to high end of RAM
        ADRL    v1, HAL_Base + OSROM_HALSize
        LDR     v2, [v1, #OSHdr_ImageSize]
        LDR     lr, [v1, #OSHdr_Flags]
        TST     lr, #OSHdrFlag_SupportsCompression
        LDRNE   lr, [v1, #OSHdr_CompressedSize]
        MOVEQ   lr, v2
        SUB     v1, v1, #OSROM_HALSize ; Start of HAL
        ADD     v2, v2, #OSROM_HALSize ; Size of HAL+OS
        ADD     lr, lr, #OSROM_HALSize ; Size of compressed HAL+OS
        ADD     v5, v1, lr ; End of OS
        ADD     v7, v3, v4 ; End of RAM
        SUB     ip, v7, v2 ; New start address of HAL
        CMP     v1, ip
        BEQ     relocate_10 ; No copy needed
        CMP     v1, v7
        BHI     relocate_20 ; We're in some ROM above RAM. OK to continue with copy.
        CMP     v5, ip
        BLS     relocate_20 ; We're in some ROM/RAM below our copy destination. OK to continue with copy.
        ; Else we currently overlap the area we want to copy ourselves into.
        SUB     ip, v1, lr ; Copy the HAL+OS to just before itself.
relocate_20
        MOV     a1, ip ; Copy dest
        MOV     a2, v1 ; Copy source
        MOV     a3, lr ; Copy length
relocate_30
        LDR     a4, [a2], #4
        SUBS    a3, a3, #4
        STR     a4, [a1], #4
        BGT     relocate_30
        MOV     a1, #0
        MCR     p15, 0, a1, c7, c10, 4 ; drain write buffer
        MCR     p15, 0, a1, c7, c5, 0 ; invalidate I-Cache
        ; Jump to our new copy
        ADR     a1, relocate_code
        SUB     a2, ip, v1
        ADD     a1, a1, a2 ; relocate our branch target
        ADD     v8, v8, a2 ; Update OS entry table ptr
        MOV     pc, a1
relocate_10
        ; Copy completed, reset stack & workspace ptrs
        ADD     sp, v3, #4096 ; Use RAM for stack instead of bits of ROM
        ADRL    sb, workspace ; However workspace is still in ROM :(
      [ HALDebug
        BL      HAL_DebugTXStrInline
        DCB     "ROM relocated", 10, 0
        ALIGN
      ]

        ; Clear RAM
        ; v3 is start of RAM
        ; ip is end of RAM/start of ROM
        ; Note this code will clear the stack, but there shouldn't be anything on it yet anyway
        MOV     a1, ip
        MOV     a2, #0
        MOV     a3, #0
        MOV     a4, #0
        MOV     v1, #0
        MOV     v4, #0
        MOV     v5, #0
        MOV     v7, #0
        MOV     lr, #0

clear_lp1
        STMDB   a1!,{a2-a4,v1,v4,v5,v7,lr}
        STMDB   a1!,{a2-a4,v1,v4,v5,v7,lr}
        STMDB   a1!,{a2-a4,v1,v4,v5,v7,lr}
        STMDB   a1!,{a2-a4,v1,v4,v5,v7,lr}
        CMP     a1, v3
        BHI     clear_lp1
        mov     a2, v3
        MOV     a3, ip
     mov a1,a2
     bl HAL_DebugHexTX4
     mov a1,a3
     bl HAL_DebugHexTX4
        MVN     a4, #0
        MOV     a1, #0
        STR     a1, [sp, #-4]!  ;reference handle (NULL for first call)
        CallOSM OS_AddRAM

        STR     a1,[sp] ;ref for next call
 ]
a480 24
  [ UseALBlob
 ; fill the frame buffer
   ldr v2, FB_Base
   
   ldr a1, FB_Size
     ; debug hack to force 128meg ram and 6meg rom
        LDR     a2, =&00ffffff
        ldr     a3, =&ffffffff
        ldr     a4, =&00ffffff
        ldr     v4, =&ffffffff
        ldr     v5, =&00ffffff
        ldr     v7, =&ffffffff
        ldr     ip, =&00ffffff
        ADD     a1, v2, a1      ;end of RAM
        MOV     lr, #0

clear_lp12
        STMDB   a1!,{a2-a4,v4,v5,v7,ip,lr}
        STMDB   a1!,{a2-a4,v4,v5,v7,ip,lr}
        STMDB   a1!,{a2-a4,v4,v5,v7,ip,lr}
        STMDB   a1!,{a2-a4,v4,v5,v7,ip,lr}
        CMP     a1, v2
        BHI     clear_lp12
  ] 
a491 3
mbox_addr
        DCD     IO_Base + MB_Base

d816 1
a816 1
        MOV     ip, #2_10000    ; no podules,no PCI cards,no multi CPU,no soft off,and soft ROM
d829 1
d832 50
a881 1
        MOV     pc, lr
d885 14
a898 1
        MOV     a1, #16
d901 2
a903 1
HAL_Reset
@


1.8
log
@Add DMA driver
Detail:
  s/DMA, hdr/DMA, Makefile - DMA driver, as an implementation of the DMA controller and list type DMA channel HAL devices
  hdr/StaticWS - Added DMA workspace definition
  hdr/BCM2835 - Removed DMA control block definition (now in hdr/DMA). Add definitions for the mailbox property interface, which should be supported by the GPU firmware sometime soon.
  s/Top - Export a couple of the debug functions. Store logical & physical address of NCNB workspace instead of hackily getting phys addr of the (cacheable) HAL workspace. Call DMA_InitDevices in HAL_InitDevices.
Admin:
  Tested in BCM2835 ROM
  DMA driver hasn't received large amounts of testing, lacks support for finite-length circular transfers, and currently only has one DMA channel enabled
  More DMA channels should be available once the mailbox property interface is functional and we know which channels the GPU does and doesn't use.


Version 0.11. Tagged as 'BCM2835-0_11'
@
text
@d370 1
a370 1
     ]
d514 138
a651 5
ROMTOP   *  6    <<20
RAMTOP   *  128  <<20 
     ; debug hack to force 128meg ram and 6meg rom
        MOV     v2, #ROMTOP     ;start of available RAM, after HAL + OS image
        MOV     a1, #RAMTOP     ; end of RAM
d655 1
a658 1
        MOV     ip, #0
d662 5
a666 5
        STMDB   a1!,{a2-a4,v4,v5,v7,ip,lr}
        STMDB   a1!,{a2-a4,v4,v5,v7,ip,lr}
        STMDB   a1!,{a2-a4,v4,v5,v7,ip,lr}
        STMDB   a1!,{a2-a4,v4,v5,v7,ip,lr}
        CMP     a1, v2
d668 2
a669 3
        mov     a2, v2
        ADD     a3, a2, #RAMTOP ; end of RAM
        SUB     a3, a3, #ROMTOP ; less what is used
a680 2


@


1.7
log
@  SD support, and miscellaneous other changes
Detail:
  * Bugfix to HAL_FIQDisableAll - it wasn't clearing the FIQ register (would
    only have caused trouble in practice if the same device was subsequently
    enabled as an IRQ).
  * Added a load of memory barriers to s.Interrupts and s.Timers to conform
    to the requirement stated in 1.3 of the datasheet.
  * Added a HAL device for the Arasan SDHCI controller. Note that this does
    not currently work reliably, and results vary from card to card. High
    speed support is currently disabled until we are able to verify that it
    works reliably.
  * Added a sprinkling of "GET Hdr:ListOpts" because the space reserved for
    the SDHCI HAL device in hdr.StaticWS is determined by including
    Hdr:HALDevice and Hdr:SDHCIDevice, which need it.
  * When support for saving "CMOS" to the SD card is added, the ROM image
    file (kernel.img) is the only one we can count on the bootloader
    installing in memory, so I think we're going to have to work using the
    table in s.CMOS. Broadcom seems to like messing around with the space
    just after the processor vector table, so rather than adding a pointer
    to the table there, I've opted to mark it using a magic word.
Admin:
  Tested on a Raspberry Pi - as noted above, there are reliability issues.

Version 0.09. Tagged as 'BCM2835-0_09'
@
text
@d145 2
d160 2
d776 3
a778 2
        ; Get the physical address of the start of our workspace
        ; R8 -> start of the page containing our workspace
a781 1
        MOV     a2, sb, LSL #20
d783 2
a784 3
        ORR     a1, a1, a3;#DMA_RAM_Base
        ORR     a1, a1, a2, LSR #20     ; factor in start offset
        STR     a1, WSPhysAddr
d949 1
@


1.6
log
@Add USB support
Detail:
  hdr/USB - New header with definition of usbinfo struct that's used by HAL_USBControllerInfo
  hdr/BCM2835 - Add note clarifying how mailboxes are used
  s/Top - Enable power to USB on startup
  s/USB - Implement HAL_USBControllerInfo to expose Synopsys USB controller details to RISC OS
Admin:
  Tested in BCM2835 ROM with Apr 19th start.elf


Version 0.07. Tagged as 'BCM2835-0_07'
@
text
@d143 3
d944 3
a946 1
        MOV     pc, lr
@


1.5
log
@  Whitespace changes
Detail:
  Substituted remaining hard spaces with normal ones and expanded tabs.
  This now matches the de facto standard for other components, and also looks
  better in the CVS web viewer.
Admin:
  No code changes

Version 0.06. Tagged as 'BCM2835-0_06'
@
text
@d299 14
a313 3
        MOV     R5,#&80 + MB_Chan_Pwr  ; (looks like turn on USB)
        STR     R5,[R4,#MB_ChWr]

@


1.4
log
@   Corrected booting issues with UseALBlob compile switch
Detail:
   s.Top
Admin:
  tested locally JB
  (highlight level of testing that has taken place)
  (bugfix number if appropriate)


Version 0.05. Tagged as 'BCM2835-0_05'
@
text
@d2 1
a2 1
;Copyright(c)2012, RISC OS Open Ltd
d4 1
a4 1
;Allrightsreserved.
d43 1
a43 1
	GET	hdr.BCM2835
d48 12
a59 12
        IMPORT	HAL_IRQEnable
        IMPORT	HAL_IRQDisable
        IMPORT	HAL_IRQClear
        IMPORT	HAL_IRQSource
        IMPORT	HAL_IRQStatus
        IMPORT	HAL_FIQEnable
        IMPORT	HAL_FIQDisable
        IMPORT	HAL_FIQDisableAll
        IMPORT	HAL_FIQClear
        IMPORT	HAL_FIQSource
        IMPORT	HAL_FIQStatus
              	
d61 7
a67 7
        IMPORT	HAL_Timers
        IMPORT	HAL_TimerDevice
        IMPORT	HAL_TimerGranularity
        IMPORT	HAL_TimerMaxPeriod
        IMPORT	HAL_TimerSetPeriod
        IMPORT	HAL_TimerPeriod
        IMPORT	HAL_TimerReadCountdown
d69 72
a140 72
              	
        IMPORT	HAL_CounterRate
        IMPORT	HAL_CounterPeriod
        IMPORT	HAL_CounterRead
        IMPORT	HAL_CounterDelay
              	
        IMPORT	HAL_IICBuses
        IMPORT	HAL_IICType
        IMPORT	HAL_IICDevice
        IMPORT	HAL_IICTransfer
        IMPORT	HAL_IICMonitorTransfer
              	
        IMPORT	HAL_NVMemoryType
        IMPORT	HAL_NVMemorySize
        IMPORT	HAL_NVMemoryPageSize
        IMPORT	HAL_NVMemoryProtectedSize
        IMPORT	HAL_NVMemoryProtection
        IMPORT	HAL_NVMemoryRead
        IMPORT	HAL_NVMemoryWrite
              	
        IMPORT	HAL_VideoFlybackDevice
        IMPORT	HAL_Video_SetMode
        IMPORT	HAL_Video_WritePaletteEntry
        IMPORT	HAL_Video_WritePaletteEntries
        IMPORT	HAL_Video_ReadPaletteEntry
        IMPORT	HAL_Video_SetInterlace
        IMPORT	HAL_Video_SetBlank
        IMPORT	HAL_Video_SetPowerSave
        IMPORT	HAL_Video_UpdatePointer
        IMPORT	HAL_Video_SetDAG
        IMPORT	HAL_Video_VetMode
        IMPORT	HAL_Video_PixelFormats
        IMPORT	HAL_Video_Features
        IMPORT	HAL_Video_BufferAlignment
        IMPORT	HAL_Video_OutputFormat
        IMPORT	HAL_Video_Render
        IMPORT	HAL_Video_IICOp
              	
        IMPORT	HAL_UARTPorts
        IMPORT	HAL_UARTStartUp
        IMPORT	HAL_UARTShutdown
        IMPORT	HAL_UARTFeatures
        IMPORT	HAL_UARTReceiveByte
        IMPORT	HAL_UARTTransmitByte
        IMPORT	HAL_UARTLineStatus
        IMPORT	HAL_UARTInterruptEnable
        IMPORT	HAL_UARTRate
        IMPORT	HAL_UARTFormat
        IMPORT	HAL_UARTFIFOSize
        IMPORT	HAL_UARTFIFOClear
        IMPORT	HAL_UARTFIFOEnable
        IMPORT	HAL_UARTFIFOThreshold
        IMPORT	HAL_UARTInterruptID
        IMPORT	HAL_UARTBreak
        IMPORT	HAL_UARTModemControl
        IMPORT	HAL_UARTModemStatus
        IMPORT	HAL_UARTDevice
              	
        IMPORT	HAL_DebugRX
        IMPORT	HAL_DebugTX
              	
        IMPORT	HAL_ATAControllerInfo
              	
        IMPORT	HAL_KbdScanSetup
        IMPORT	HAL_KbdScan
        IMPORT	HAL_KbdScanFinish
        IMPORT	HAL_KbdScanInterrupt
              	
        IMPORT	HAL_USBControllerInfo
        IMPORT	HAL_USBPortPower
        IMPORT	HAL_USBPortStatus
        IMPORT	HAL_USBPortIRQ
d143 1
a143 1
	EXPORT	HAL_Base
d147 29
a175 29
	IMPORT	clear_block
	IMPORT	set_text_colours
	IMPORT	output_char
	IMPORT	output_hex8
	IMPORT	output_newline
	IMPORT	output_regs
	IMPORT	output_text
	IMPORT	output_text_at
     ]

	EXPORT	reset
	EXPORT	workspace

	ENTRY

reset	B	start
undef 	B	undefined_instr
swi	B	swi_instr
pabort	B	prefetch_abort
dabort	B	data_abort
irq	B	interrupt
fiq	B	fast_interrupt

	ALIGN	256

atags	; list of 'atags' structures constructed here by the loader code
	; running on VideoCore, describing
	; - available memory
	; - command line parameters, including framebuffer parameters
d177 1
a177 1
	ALIGN	4096
d181 1
a181 1
	%	sizeof_workspace
d183 1
a183 1
	LTORG
d185 2
a186 2
	; exception handlers just for use during HAL init,
	;   in case something goes wrong
d189 2
a190 2
	ADRL	sb,workspace
	ADRL	R13,end_stack
d192 5
a196 5
	ADR	R0,irq_text
	MOV	R1,#0
	MOV	R2,#0
	ADR	R14,interrupt
	B	output_text_at
d202 2
a203 2
	ADRL	sb,workspace
	ADRL	R13,end_stack
d205 5
a209 5
	ADR	R0,fiq_text
	MOV	R1,#0
	MOV	R2,#0
	ADR	R14,fast_interrupt
	B	output_text_at
d215 2
a216 2
	ADRL	sb,workspace
	ADRL	R13,end_stack
d218 5
a222 5
	ADR	R0,swi_text
	MOV	R1,#0
	MOV	R2,#0
	ADR	R14,swi_instr
	B	output_text_at
d228 2
a229 2
	ADRL	sb,workspace
	ADRL	R13,end_stack
d231 5
a235 5
	ADR	R0,pabt_text
	MOV	R1,#0
	MOV	R2,#0
	ADR	R14,prefetch_abort
	B	output_text_at
d241 2
a242 2
	ADRL	sb,workspace
	ADRL	R13,end_stack
d244 5
a248 5
	ADR	R0,dabt_text
	MOV	R1,#0
	MOV	R2,#0
	ADR	R14,data_abort
	B	output_text_at
d254 2
a255 2
	ADRL	sb,workspace
	ADRL	R13,end_stack
d257 5
a261 5
	ADR	R0,und_text
	MOV	R1,#0
	MOV	R2,#5
	ADR	R14,undefined_instr
	B	output_text_at
d267 6
a272 6
fiq_text	=	"FIQ",0
irq_text	=	"IRQ",0
swi_text	=	"SWI",0
pabt_text	=	"Prefetch Abort",0
dabt_text	=	"Data Abort",0
und_text	=	"Undefined Instruction",0
d276 1
a276 1
start	MSR	CPSR_c,#F32_bit+I32_bit+SVC32_mode
d278 3
a280 7
	ADRL	v1, HAL_Base + OSROM_HALSize	; v1 -> RISC OS image
	LDR	v8, [v1, #OSHdr_Entries]
	ADD	v8, v8, v1			; v8 -> RISC OS entry table

	; Ensure CPU is 'set up' (typically enables ICache)
	MOV	a1, #0
	CallOSM	OS_InitARM
d282 6
a287 2
	ADRL	sb,workspace
	ADRL	R13,end_stack
d298 1
a298 1
	LDR	R4,mbox_addr
d355 56
a410 56
	[ SCR32
	LDR	R0,=1920*8*4
	STR	R1,ScreenBase               ; for HAL use, remember address we were given
	STR	R0,BytesPerRow
	MOV	R0,#8*4
	STR	R0,BytesPerChar
	|
	LDR	R0,=1920*8*2
	STR	R1,ScreenBase
	STR	R0,BytesPerRow
	MOV	R0,#8*2
	STR	R0,BytesPerChar
	]
	MOV	R0,#1920/8
	STR	R0,Columns
	MOV	R0,#1080/8
	STR	R0,Rows
	MOV	R0,#0
	STR	R0,InvertFont
	STR	R0,OutputX
	STR	R0,OutputY

	[ SCR32
	MOV	R0,#&FF000000
	MOV	R1,#&FF000000
	MOV	R8,#32
	|
	MVN	R0,#0
	MOV	R1,#0
	MOV	R0,R0,LSR #17
	MOV	R8,#16
	]
	STR	R8,BitsPerPixel
	BL	set_text_colours

	MOV	R0,#0
	MOV	R1,#0
	LDR	R2,Columns
	LDR	R3,Rows
	BL	clear_block

	[ SCR32
	MVN	R0,#0
	MOV	R1,#&FF000000
	MOV	R8,#32
	|
	MOV	R0,#&1F<<10
	MOV	R1,#0
	MOV	R8,#16
	]
	BL	set_text_colours

	MOV	R0,#0
	MOV	R1,#0
	ADR	R2,sign_on
	BL	output_text_at
d418 10
a427 10
	; Traverse list of 'atags' structures
	; word 0 = size of tag, including header, in words
	; word 1 = type tag

ATAG_MEM	*	&54410002
ATAG_NONE	*	0

	ADRL	v1, HAL_Base + OSROM_HALSize
	LDR	v2, [v1, #OSHdr_ImageSize]
	ADD	v2, v2, v1	; End of OS
d429 1
a429 1
	ADRL	v3, atags
d431 2
a432 2
	LDR	a1, [v3, #4]	;tag type
	LDR	a2, [v3]	;size of tag inc header, in words
d434 2
a435 2
	SUB	a4, a1, #ATAG_MEM :AND: &FF000000
	SUB	a4, a4, #ATAG_MEM :AND: &00FF0000
d437 2
a438 2
	TEQ	a4, #ATAG_MEM :AND: &FFFF
	BNE	atag_next
d440 1
a440 1
	; clear RAM
d442 2
a443 2
	LDR	a1, [v3, #8]	;RAM size
	LDR	lr, [v3, #12]	;RAM start
d446 1
a446 1
	;!!! bodge to exclude frame buffer
d450 1
a450 1
	STRHI	a1, [v3, #8]
d452 9
a460 9
	MOV	a2, #0
	MOV	a3, #0
	MOV	a4, #0
	MOV	v4, #0
	MOV	v5, #0
	MOV	v7, #0
	MOV	ip, #0
	ADD	a1, a1, lr	;end of RAM
	MOV	lr, #0
d463 6
a468 6
	STMDB	a1!,{a2-a4,v4,v5,v7,ip,lr}
	STMDB	a1!,{a2-a4,v4,v5,v7,ip,lr}
	STMDB	a1!,{a2-a4,v4,v5,v7,ip,lr}
	STMDB	a1!,{a2-a4,v4,v5,v7,ip,lr}
	CMP	a1, v2
	BHI	clear_lp
d472 6
a477 6
	LDR	lr, [v3]	;tag size, words
	LDR	v1, [v3, #8]	;RAM size
	LDR	a4, [v3, #12]	;RAM start
	MOV	a2, v2		;start of available RAM, after HAL + OS image
	ADD	a3, v1, a4	;end of RAM
	ADD	v3, v3, lr, LSL #2 ;next tag
d482 1
a482 1
	MVN	a4, #0
d485 1
a485 1
	CallOSM	OS_AddRAM
d487 1
a487 1
	STR	a1,[sp]	;ref for next call
d489 1
a489 1
	B	atags_loop
d492 3
a494 3
	TEQ	a1,#ATAG_NONE
	ADDNE	v3, v3, a2, LSL #2
	BNE	atags_loop
d499 10
a508 10
	MOV	v2, #ROMTOP     ;start of available RAM, after HAL + OS image
	MOV	a1, #RAMTOP	; end of RAM
	MOV	a2, #0
	MOV	a3, #0
	MOV	a4, #0
	MOV	v4, #0
	MOV	v5, #0
	MOV	v7, #0
	MOV	ip, #0
	MOV	lr, #0
d511 6
a516 6
	STMDB	a1!,{a2-a4,v4,v5,v7,ip,lr}
	STMDB	a1!,{a2-a4,v4,v5,v7,ip,lr}
	STMDB	a1!,{a2-a4,v4,v5,v7,ip,lr}
	STMDB	a1!,{a2-a4,v4,v5,v7,ip,lr}
	CMP	a1, v2
	BHI	clear_lp1
d518 2
a519 2
	ADD	a3, a2, #RAMTOP	; end of RAM
	SUB     a3, a3, #ROMTOP ; less what is used
d524 1
a524 1
	MVN	a4, #0
d527 1
a527 1
	CallOSM	OS_AddRAM
d529 1
a529 1
	STR	a1,[sp]	;ref for next call
d535 2
a536 2
	ADR	R0,start_os
	BL	output_text
d545 1
a545 1
	LDR	a2, =&00ffffff
d547 7
a553 7
	ldr	a4, =&00ffffff
	ldr	v4, =&ffffffff
	ldr	v5, =&00ffffff
	ldr	v7, =&ffffffff
	ldr	ip, =&00ffffff
	ADD	a1, v2, a1	;end of RAM
	MOV	lr, #0
d556 6
a561 6
	STMDB	a1!,{a2-a4,v4,v5,v7,ip,lr}
	STMDB	a1!,{a2-a4,v4,v5,v7,ip,lr}
	STMDB	a1!,{a2-a4,v4,v5,v7,ip,lr}
	STMDB	a1!,{a2-a4,v4,v5,v7,ip,lr}
	CMP	a1, v2
	BHI	clear_lp12
d563 1
a563 1
	; OS kernel informed of RAM areas
d565 1
a565 1
	LDR	a4,[sp],#4	;!!! ref from last AddRAM
d572 1
a572 1
	; OS_Start doesn't return....invokes HAL_Init after MMU activation
d578 3
a580 3
sign_on	 =	"BCM2835 Raspberry Pi",13,10,0
start_os =	"Starting OS",13,10,0
	ALIGN
d743 1
a743 1
	STMFD	R13!,{R8,R14}
d745 3
a747 3
	MOV	R8,a2
	BL	SetUpOSEntries
	
d758 2
a759 2
	; Get the physical address of the start of our workspace
	; R8 -> start of the page containing our workspace
d761 3
a763 3
	MOV	a1,R8
	CallOS	OS_LogToPhys
	MOV	a2, sb, LSL #20
d766 2
a767 2
	ORR	a1, a1, a2, LSR #20	; factor in start offset
	STR	a1, WSPhysAddr
d781 2
a782 2
	; Map in the frame buffer
	;    and initialise the display driver
d791 3
a793 3
	MOV	a1, #0
	STR	a1, LastInt
	STR	a1, CurAddr
d795 2
a796 2
	CallOS	OS_MapInIO
	STR	a1,ScreenBase
d799 32
a830 32
	[ SCR32
	LDR	a1,=1920*8*4
	STR	a1,BytesPerRow
	MOV	a1,#8*4
	STR	a1,BytesPerChar
	|
	LDR	a1,=1920*8*2
	STR	a1,BytesPerRow
	MOV	a1,#8*2
	STR	a1,BytesPerChar
	]
	MOV	a1,#1920/8
	STR	a1,Columns
	MOV	a1,#1080/8
	STR	a1,Rows
	MOV	a1,#0
	STR	a1,InvertFont
	MOV	a1,#4
	STR	a1,OutputX
	STR	a1,OutputY

	[ SCR32
	MOV	a1,#-1
	MOV	a2,#&FF000000
	MOV	R8,#32
	|
	MVN	a1,#0
	MOV	a2,#0
	MOV	a1,a1,LSR #17
	MOV	R8,#16
	]
	STR	R8,BitsPerPixel
d832 1
a832 1
	BL	set_text_colours
d834 2
a835 2
	ADR	a1,hal_init
	BL	output_text
d842 2
a843 2
	STR 	v1,[sp,#-4]!
	ADRL 	v1,hal_init
d846 11
a856 11
	MOV a1,#0
	BL HAL_UARTLineStatus
	TST a1,#&20
 	BEQ txbusylp
	MOV a1,#0
	LDRB a2,[v1],#1
	BL HAL_UARTTransmitByte
	LDRB a1,[v1]
	TEQ a1,#0
	BNE txloop
	LDR v1,[sp],#4
d858 1
a858 1
	LDMFD	R13!,{R8,PC}
d862 1
a862 1
	ALIGN
d865 1
a865 1
	LDMFD	R13!,{R8,PC}
d902 1
a902 1
        MOV     ip, #2_10000 	; no podules,no PCI cards,no multi CPU,no soft off,and soft ROM
@


1.3
log
@   Boots with May17th start.elf
Detail:
   Recent changes in the broadcom startup code now accomodated. frame buffer
   will now determine whether it is L2 cached or not, and be set up accordingly.
   ATAGs not currently read, so ram size defaulted.
  ** note that there will be further updates to this over the following days
  ** trackikng startup code changes.
   added HAL_TimerIRQClear entry
Admin:
  (highlight level of testing that has taken place)
  (bugfix number if appropriate)


Version 0.03. Tagged as 'BCM2835-0_03'
@
text
@d311 2
d417 1
a417 1
 [ {FALSE}        ; nolonger used
d539 1
a539 1
  [ {FALSE}
@


1.2
log
@
  Update of HAL to incorporate separate development of HAL by J Ballance
  Will now compile against initial developemnt start.elf, and against the
  start.elf in general release at this date. (compile switch UseALBlob in
  hdr.BCM2835). Extended header defs, Updated IRQ stuff, HAL_FramebufferAddress
  Reworked Timers, + a number of other bits. Still work in progress.
Detail:
  (list files and functions that have changed)
Admin:
  Compiled and working - as far as it goes -. Will enable use with the current
  start.elf, and is (subject to any minor changes introduced) ready for use with the
  version due for release shortly which will provide the correct transparency operation,
  and a better aligned frame buffer

Version 0.02. Tagged as 'BCM2835-0_02'
@
text
@d68 1
d300 1
a300 1
        MOV     R5,#&80 + MB_Chan_Pwr
d325 2
a326 2
        ORR     R3, R1, #DMA_RAM_Base + MB_Chan_FB
        str     r3, [r4, #MB_ChWr]
d338 7
a344 1
        bic     r1, r1, #DMA_RAM_Base
d355 1
a355 1
	STR	R1,ScreenBase
d415 1
a415 1

d493 33
d527 5
d536 25
d727 1
a727 1
        NullEntry ; HAL_TimerIRQClear
d745 10
d761 9
a769 8
	MOV	a2,sb,LSL #20
        ORR     a1,a1,#DMA_RAM_Base
	ORR	a1,a1,a2,LSR #20	; factor in start offset
	STR	a1,WSPhysAddr

        MOV     a1,#0                   ; map in the IO space
        LDR     a2,=IO_Base
        LDR     a3,=IO_Size
d771 1
a771 1
        STR     a1,PeriBase
a780 2
        MOV     a4, sb
        ADRL    sb, workspace                ; where we remembered it is
d783 2
a784 3
        mov     sb, a4
        STR     a3, FB_Size                  ; put in our workspace
        STR     a2, FB_Base                  ; for HAL_FramestoreAddress use
d789 3
a791 3
	MOV	a1,#0
	STR	a1,LastInt
	STR	a1,CurAddr
@


1.1
log
@Initial revision
@
text
@d47 1
d60 1
d141 1
d288 9
d298 3
a300 3

	MOV	R5,#&80
	STR	R5,[R4]
d304 39
a342 3
	LDR	R1,=&2000000
     [ :LNOT: ExtFramestore
  MOV R1,#&600000
a343 2
	ORR	R3,R1,#&C0000001
	STR	R3,[R4]
a344 3
	; Setup display driver workspace
	ADRL	sb,workspace
	ADRL	R13,end_stack
d402 5
d436 1
d438 3
a440 2
	CMP	a1,#&2000000
	MOVHI	a1,#&2000000
d442 1
a442 1

a461 2
	MOV	a1, #0
	STR	a1, [sp, #-4]!	;reference handle (NULL for first call)
d469 4
a472 1
;	TEQ	sp, #0
d474 2
a475 1
;	ADDEQ	sp, a2, #4096
d503 1
a503 1
	DCD	&0800B000+&8A0
d662 2
d682 1
a682 1
	ORR	a1,a1,#&C0000000
d686 12
d700 11
a710 1

a714 2
	LDR	a2,=&2000000
	MOV	a3,#&800000
d717 1
a717 6

	MOV	a1,#0
	LDR	a2,=PERI_BASE
	MOV	a3,#&C00000
	CallOS	OS_MapInIO
	STR	a1,PeriBase
a757 3
        MOV     a1,#0
        BL      HAL_UARTStartUp

d780 2
a781 3
set_rate = "UART rate set",0
uart_started = "UART started",0
hal_init =	"HAL Init reached",13,10,0
d846 3
a849 1
HAL_Null
d852 82
@


1.1.1.1
log
@  Initial import of BCM2835 (Raspberry Pi) HAL
Detail:
  Covers the basic functionality, but does require a customised start.elf
  to function. The vast majority is an entirely new implementation and is
  BSD licenced, but 4% (the Makefile and a handful of simple macros) are
  copied from pre-existing Castle-licenced code, so it lives under the
  "mixed" hierarchy. If other HALs are anything to go by, we'll end up
  having to add more Castle code (at least some C runtime functions) so it's
  probably juast as well.
Admin:
  Code received from Adrian Lees
@
text
@@

head	4.3;
access;
symbols
	TCPIPLibs-5_66:4.3
	TCPIPLibs-5_65:4.3
	TCPIPLibs-5_64:4.3
	TCPIPLibs-5_63:4.3
	TCPIPLibs-5_62:4.3
	TCPIPLibs-5_61:4.3
	TCPIPLibs-5_60:4.3
	TCPIPLibs-5_59:4.3
	TCPIPLibs-5_58:4.3
	TCPIPLibs-5_57:4.3
	TCPIPLibs-5_56:4.3
	TCPIPLibs-5_55:4.3
	TCPIPLibs-5_54:4.3
	TCPIPLibs-5_53:4.3
	TCPIPLibs-5_52:4.3
	TCPIPLibs-5_51:4.3
	TCPIPLibs-5_50:4.3
	TCPIPLibs-5_49:4.3
	RO_5_07:4.3
	TCPIPLibs-5_48:4.3
	TCPIPLibs-5_47:4.3
	TCPIPLibs-5_46:4.3
	TCPIPLibs-5_45:4.3
	TCPIPLibs-5_44:4.2
	TCPIPLibs-5_43:4.2
	TCPIPLibs-5_42:4.2
	TCPIPLibs-5_41:4.2
	TCPIPLibs-5_40:4.2
	TCPIPLibs-5_39:4.2
	dellis_autobuild_BaseSW:4.2
	TCPIPLibs-5_38:4.2
	TCPIPLibs-5_37:4.2
	TCPIPLibs-5_36:4.2
	sbrodie_sedwards_16Mar2000:4.2
	TCPIPLibs-5_35:4.2
	TCPIPLibs-5_34:4.2
	TCPIPLibs-5_33:4.2
	TCPIPLibs-5_32:4.2
	TCPIPLibs-5_31:4.2
	dcotton_autobuild_BaseSW:4.2
	TCPIPLibs-5_30:4.2
	TCPIPLibs-5_29:4.2
	TCPIPLibs-5_28:4.2
	TCPIPLibs-5_27:4.2
	TCPIPLibs-5_26:4.1
	TCPIPLibs-5_25:4.1
	TCPIPLibs-5_24:4.1
	TCPIPLibs-5_23:4.1
	TCPIPLibs-5_22:4.1
	TCPIPLibs-5_21:4.1
	TCPIPLibs-5_20:4.1
	TCPIPLibs-5_19:4.1
	TCPIPLibs-5_18:4.1
	TCPIPLibs-5_17:4.1
	TCPIPLibs-5_16:4.1
	TCPIPLibs-5_15:4.1
	TCPIPLibs-5_14:4.1
	TCPIPLibs-5_13:4.1
	TCPIPLibs-5_12:4.1
	TCPIPLibs-5_11:4.1
	TCPIPLibs-5_10:4.1
	TCPIPLibs-5_09:4.1
	TCPIPLibs-5_08:4.1
	TCPIPLibs-5_07:4.1
	TCPIPLibs-5_06:4.1
	TCPIPLibs-5_05:4.1
	TCPIPLibs-5_04:4.1
	TCPIPLibs-5_03:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.10
	TCPIPLibs-5_02:4.1
	TCPIPLibs-5_01:4.1
	nicke_TCPIPLibs_25-9-98:4.1
	TCPIPLibs-5_00:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	Spinner:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.8
	Ursula_19May1998_bp:4.1
	Ursula_19May1998:4.1.0.4
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.4
	RCA:4.1.0.2
	import:4.1.7.1;
locks; strict;
comment	@# @;


4.3
date	2003.01.07.18.58.24;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	99.07.19.12.40.33;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	97.03.06.14.28.00;	author rbuckley;	state Exp;
branches
	4.1.7.1;
next	;

4.1.7.1
date	97.03.06.14.28.00;	author rbuckley;	state Exp;
branches;
next	;


desc
@@


4.3
log
@Addition of 1000 base T and fibre magic constant to DCI spec.
Addition of support for HAL timers
Removed a lingering __P in the resolver header file (and while we're
at it all the others).
Added missing open bracket to vn_opn,reported by D.Ellis.

Version 5.45. Tagged as 'TCPIPLibs-5_45'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* -*-C-*-
 *
 * $Header: /projects2/renaissa/cvsroot/RiscOS/Sources/Lib/TCPIPLibs/unixlib/c/gtimeofday,v 4.2 1999/07/19 12:40:33 kbracey Exp $
 * $Source: /projects2/renaissa/cvsroot/RiscOS/Sources/Lib/TCPIPLibs/unixlib/c/gtimeofday,v $
 *
 * Copyright (c) 1995 Acorn Computers Ltd., Cambridge, England
 *
 * :RCS Log discontinued:
 * Revision 1.1  95/04/20  09:50:18  kwelton
 * Initial revision
 *
 */
#include <sys/time.h>
#include <sys/types.h>
#include <swis.h>
#include <Global/HalEntries.h>
#include "unixlib.h"
#include "asm.h"
#include "stdio.h"

#define secs0070 (((unsigned)86400) * (365 * 70 + 17))	/* less than 2^32 */

typedef struct {unsigned int l,h;} machinetime;

/**********************************************************************/
static long machinetime_to_realtime(machinetime *t, long *csecs)
{
    machinetime bt, w, w2;
    /* to two 3-byte things - for divide */
    w.h = ((t->h & 255) << 8) | (t->l >> 24);
    w.l = t->l & 0xffffff;
    /* turn csecs to secs */
    w2.h = w.h / 100;
    w2.l = ((w.h % 100 << 24) | w.l) / 100;
    if (csecs)
        *csecs = ((w.h % 100L << 24) | w.l) % 100;
    /* back to 8 byte binary */
    bt.h = w2.h >> 8;
    bt.l = (w2.h << 24) | w2.l;
    /* normalise to Jan70 instead of Jan00... */
    if (bt.l < secs0070) bt.h--;
    bt.l -= secs0070;
    /*
     * if high word is non-zero then date
     * is unset/out of unix range...
     */
    return bt.h ? -1 : bt.l;
}

static unsigned int t0_divisor; /* Divisor to convert ticks to usecs */
static unsigned int t0_period;  /* Timer 0 period */
static void       * HAL_TimerReadCountdown_Ptr;
static uint32_t     HAL_TimerReadCountdown_SB;

typedef enum
{
    timer_NOT_CHECKED,
    timer_IOMD,
    timer_HAL,
    timer_NONE
} timer_type;

/**********************************************************************/
/*
 * Return the type of hardware timer this platform has, and perform
 * any necessary initialisation.
 */
static timer_type hw_check()
{
    _kernel_oserror * e;
    unsigned int      granularity;

    /* Try to get Timer 0 granularity from HAL */
    e = _swix(OS_Hardware,
              _IN(0) | _INR(8,9) | _OUT(0),
              0,
              0,
              EntryNo_HAL_TimerGranularity,

              &granularity);

    /*
     * Can only use HAL if this succeeded and granularity is an even
     * number of MHz.
     */
    if (e == NULL && (granularity % 1000000) == 0)
    {
        t0_divisor = granularity / 1000000;

        /* Try to get Timer 0 period from HAL */
        e = _swix(OS_Hardware,
                  _IN(0) | _INR(8,9) | _OUT(0),
                  0,
                  0,
                  EntryNo_HAL_TimerPeriod,
    
                  &t0_period);

        if (e == NULL && t0_divisor != 0 && t0_period != 0)
        {
            /* HAL_TimerReadCountdown counts from (period-1) to 0 */
            t0_period--;

            /* Try to get HAL_TimerReadCountdown pointer from HAL */
            e = _swix(OS_Hardware,
                      _INR(8,9) | _OUTR(0,1),
                      1,
                      EntryNo_HAL_TimerReadCountdown,
        
                      &HAL_TimerReadCountdown_Ptr,
                      &HAL_TimerReadCountdown_SB);

            if (e == NULL)
            {
                /*
                 * OK so far, now make sure HAL_TimerReadCountdown doesn't
                 * always return 0.
                 */

                unsigned long count1, count2;

                count1 = _get_hal_t0_count(HAL_TimerReadCountdown_SB, HAL_TimerReadCountdown_Ptr);
                _swix(OS_Hardware, _IN(0)|_INR(8,9), 2, 0, EntryNo_HAL_CounterDelay);
                count2 = _get_hal_t0_count(HAL_TimerReadCountdown_SB, HAL_TimerReadCountdown_Ptr);

                if (count1 != 0 || count2 != 0)
                {
                    /* Everything worked - use HAL */
                    return timer_HAL;
                }
            }
        }
    }

    /* Couldn't use HAL, look for IOMD instead */

    /* (OS_ReadSysInfo 2 bits 8-15 is I/O chip = 0 or 1 - IOC or IOMD) */
    unsigned int hardware;
    if (_swix(OS_ReadSysInfo, _IN(0)|_OUT(0), 2, &hardware))
        return timer_NONE;
    return (hardware & 0xFF00) <= 0x0100 ? timer_IOMD : timer_NONE;
}

/**********************************************************************/
/*
 * This function is actully reasonably fast - it's between 7 and 8us
 * on a 200MHz StrongARM.
 */
int gettimeofday(struct timeval *tv, struct timezone *tzp)
{
    static timer_type timer_check = timer_NOT_CHECKED;
    machinetime t1, t2;
    unsigned long timer_count;

    /* Only poke the hardware if we're sure it's there :) */
    if (timer_check == timer_NOT_CHECKED)
        timer_check = hw_check();

    t1.l = 3;
    t2.l = 3;
    if (timer_check != timer_NONE)
    {
        /* Check initial time */
        _kernel_osword(14, (int *) &t1);
        /* Read the Timer 0 value */
        if (timer_check == timer_IOMD)
            timer_count = _get_t0_count();
        else
            timer_count = _get_hal_t0_count(HAL_TimerReadCountdown_SB, HAL_TimerReadCountdown_Ptr);
    }
    /* Check new time */
    _kernel_osword(14, (int *) &t2);
    tv->tv_sec = machinetime_to_realtime(&t2, &tv->tv_usec);
    tv->tv_usec *= 10000;
    if (timer_check != timer_NONE && t1.l == t2.l)
    {
        /* Clock didn't tick - add in timer count */
        if (timer_check == timer_IOMD)
        {
            /*
             * IOMD timer counts down from 19999 to 0, the clock tick
             * occurring as it changes from 0 to 19999.
             */
            tv->tv_usec += (19999 - timer_count) / 2;
        }
        else
        {
            tv->tv_usec += (t0_period - timer_count) / t0_divisor;
        }
    }
    else
    {
        /* Clock ticked - let it rest at the 10000us boundary */
    }

    if (tzp)
    {
        struct tm *t_gmt;
        struct tm *t_local;
	t_gmt = gmtime( (time_t *)&tv->tv_sec );
	t_local = localtime( (time_t *)&tv->tv_sec );
	tzp->tz_minuteswest = (int)difftime(mktime(t_gmt),
					    mktime(t_local)) / 60;
	tzp->tz_dsttime = t_local->tm_isdst;
    }
    return(0);
}
/**********************************************************************/
/* EOF gtimeofday.c */
@


4.2
log
@Modified gettimeofday() to return microsecond accuracy, as long as it's
running on an IOC or IOMD system.

Version 5.27. Tagged as 'TCPIPLibs-5_27'
@
text
@d17 1
a17 1
 * $Header: /projects2/renaissa/cvsroot/RiscOS/Sources/Lib/TCPIPLibs/unixlib/c/gtimeofday,v 4.1 1997/03/06 14:28:00 rbuckley Exp $
a26 1

d30 1
a30 1

d33 1
a33 1

a39 1

a42 1

a45 1

a50 1

a53 1

a56 1

d64 13
a77 1

d79 2
a80 2
 * Return 1 if IOC/IOMD is present (OS_ReadSysInfo 2 reports I/O control
 * chip = 0 or 1 - IOC or IOMD).
d82 1
a82 1
static int iomd_present()
d84 68
a152 1

d154 2
a155 3
        return 2;

    return (hardware & 0xFF00) <= 0x0100 ? 1 : 2;
a158 1

d165 1
a165 1
    static int iomd_check;  /* 0 = not checked, 1 = present, 2 = not present */
d168 1
d170 2
a171 2
    if (!iomd_check)
        iomd_check = iomd_present();
d175 1
a175 2

    if (iomd_check == 1)
d179 5
a183 5

        /* Read the Timer 0 value - it counts down from 19999 to 0,
         * the clock tick occurring as it changes from 0 to 19999.
         */
        timer_count = _get_t0_count();
a184 1

a186 1

d189 1
a189 2

    if (iomd_check == 1 && t1.l == t2.l)
d192 12
a203 1
        tv->tv_usec += (19999 - timer_count) / 2;
d210 1
a210 1
    if ( tzp )
a213 1

a219 1

a221 1

a222 1

@


4.1
log
@Initial revision
@
text
@d17 2
a18 2
 * $Header: /ax/networking:libs/unixlib/gtimeofday.c:networking  1.1  $
 * $Source: /ax/networking:libs/unixlib/gtimeofday.c: $
a26 1
#include <time.h>
d28 3
a30 1
#include "kernel.h"
d32 2
a33 8
/*
 * YUCK YUCK YUCK
 *
 * time_t and clock_t are defined in <time.h>, stop their
 * re-definition in "sys/types.h"
 */
#define __time_t
#define __clock_t
a34 4
#include "sys/time.h"
#include "sys/types.h"

#include "unixlib.h"
d42 1
a42 1
static long realtime(long *csecs)
a43 4
    /*
     * this is time(), recoded here to avoid the absurd 6ms delay
     * in the RISC OS 3 Shared C Library (penalty is timezone())
     */
a45 7
    /*
     * read timer as 5 byte integer
     * centiseconds since 1/1/1900
     */
    bt.l = 3;				/* presumably 'request time' arg */
    _kernel_osword(14, (int *)&bt);

d47 2
a48 2
    w.h = ((bt.h & 255) << 8) | (bt.l >> 24);
    w.l = bt.l & 0xffffff;
d54 1
a54 1
        *csecs = ((w.h % 100 << 24) | w.l) % 100;
d73 20
d95 6
a100 2
    struct tm *t_gmt;
    struct tm *t_local;
d102 18
a119 1
    tv->tv_sec = realtime(&tv->tv_usec);
d122 10
d134 3
@


4.1.7.1
log
@Imported from Babel
@
text
@@

head	4.1;
access;
symbols
	TCPIPLibs-5_66:4.1
	TCPIPLibs-5_65:4.1
	TCPIPLibs-5_64:4.1
	TCPIPLibs-5_63:4.1
	TCPIPLibs-5_62:4.1
	TCPIPLibs-5_61:4.1
	TCPIPLibs-5_60:4.1
	TCPIPLibs-5_59:4.1
	TCPIPLibs-5_58:4.1
	TCPIPLibs-5_57:4.1
	TCPIPLibs-5_56:4.1
	TCPIPLibs-5_55:4.1
	TCPIPLibs-5_54:4.1
	TCPIPLibs-5_53:4.1
	TCPIPLibs-5_52:4.1
	TCPIPLibs-5_51:4.1
	TCPIPLibs-5_50:4.1
	TCPIPLibs-5_49:4.1
	RO_5_07:4.1
	TCPIPLibs-5_48:4.1
	TCPIPLibs-5_47:4.1
	TCPIPLibs-5_46:4.1
	TCPIPLibs-5_45:4.1
	TCPIPLibs-5_44:4.1
	TCPIPLibs-5_43:4.1
	TCPIPLibs-5_42:4.1
	TCPIPLibs-5_41:4.1
	TCPIPLibs-5_40:4.1
	TCPIPLibs-5_39:4.1
	dellis_autobuild_BaseSW:4.1
	TCPIPLibs-5_38:4.1
	TCPIPLibs-5_37:4.1
	TCPIPLibs-5_36:4.1
	sbrodie_sedwards_16Mar2000:4.1
	TCPIPLibs-5_35:4.1
	TCPIPLibs-5_34:4.1
	TCPIPLibs-5_33:4.1
	TCPIPLibs-5_32:4.1
	TCPIPLibs-5_31:4.1
	dcotton_autobuild_BaseSW:4.1
	TCPIPLibs-5_30:4.1
	TCPIPLibs-5_29:4.1
	TCPIPLibs-5_28:4.1
	TCPIPLibs-5_27:4.1
	TCPIPLibs-5_26:4.1
	TCPIPLibs-5_25:4.1
	TCPIPLibs-5_24:4.1
	TCPIPLibs-5_23:4.1
	TCPIPLibs-5_22:4.1
	TCPIPLibs-5_21:4.1
	TCPIPLibs-5_20:4.1
	TCPIPLibs-5_19:4.1
	TCPIPLibs-5_18:4.1
	TCPIPLibs-5_17:4.1
	TCPIPLibs-5_16:4.1
	TCPIPLibs-5_15:4.1
	TCPIPLibs-5_14:4.1
	TCPIPLibs-5_13:4.1
	TCPIPLibs-5_12:4.1
	TCPIPLibs-5_11:4.1
	TCPIPLibs-5_10:4.1
	TCPIPLibs-5_09:4.1
	TCPIPLibs-5_08:4.1
	TCPIPLibs-5_07:4.1
	TCPIPLibs-5_06:4.1
	TCPIPLibs-5_05:4.1
	TCPIPLibs-5_04:4.1
	TCPIPLibs-5_03:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.10
	TCPIPLibs-5_02:4.1
	TCPIPLibs-5_01:4.1
	nicke_TCPIPLibs_25-9-98:4.1
	TCPIPLibs-5_00:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	Spinner:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.8
	Ursula_19May1998_bp:4.1
	Ursula_19May1998:4.1.0.4
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.4
	RCA:4.1.0.2
	import:4.1.7.1;
locks; strict;
comment	@# @;


4.1
date	97.03.06.14.27.55;	author rbuckley;	state Exp;
branches
	4.1.7.1;
next	;

4.1.7.1
date	97.03.06.14.27.55;	author rbuckley;	state Exp;
branches;
next	;


desc
@@



4.1
log
@Initial revision
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <rpc/rpc.h>
#include "nfs_prot.h"


bool_t
xdr_nfsstat(xdrs, objp)
        XDR *xdrs;
        nfsstat *objp;
{
        if (!xdr_enum(xdrs, (enum_t *)objp)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_ftype(xdrs, objp)
        XDR *xdrs;
        ftype *objp;
{
        if (!xdr_enum(xdrs, (enum_t *)objp)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_nfs_fh(xdrs, objp)
        XDR *xdrs;
        nfs_fh *objp;
{
        if (!xdr_opaque(xdrs, objp->data, NFS_FHSIZE)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_nfstime(xdrs, objp)
        XDR *xdrs;
        nfstime *objp;
{
        if (!xdr_u_int(xdrs, &objp->seconds)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->useconds)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_fattr(xdrs, objp)
        XDR *xdrs;
        fattr *objp;
{
        if (!xdr_ftype(xdrs, &objp->type)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->mode)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->nlink)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->uid)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->gid)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->size)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->blocksize)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->rdev)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->blocks)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->fsid)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->fileid)) {
                return (FALSE);
        }
        if (!xdr_nfstime(xdrs, &objp->atime)) {
                return (FALSE);
        }
        if (!xdr_nfstime(xdrs, &objp->mtime)) {
                return (FALSE);
        }
        if (!xdr_nfstime(xdrs, &objp->ctime)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_sattr(xdrs, objp)
        XDR *xdrs;
        sattr *objp;
{
        if (!xdr_u_int(xdrs, &objp->mode)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->uid)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->gid)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->size)) {
                return (FALSE);
        }
        if (!xdr_nfstime(xdrs, &objp->atime)) {
                return (FALSE);
        }
        if (!xdr_nfstime(xdrs, &objp->mtime)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_filename(xdrs, objp)
        XDR *xdrs;
        filename *objp;
{
        if (!xdr_string(xdrs, objp, NFS_MAXNAMLEN)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_nfspath(xdrs, objp)
        XDR *xdrs;
        nfspath *objp;
{
        if (!xdr_string(xdrs, objp, NFS_MAXPATHLEN)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_attrstat(xdrs, objp)
        XDR *xdrs;
        attrstat *objp;
{
        if (!xdr_nfsstat(xdrs, &objp->status)) {
                return (FALSE);
        }
        switch (objp->status) {
        case NFS_OK:
                if (!xdr_fattr(xdrs, &objp->attrstat_u.attributes)) {
                        return (FALSE);
                }
                break;
        }
        return (TRUE);
}




bool_t
xdr_sattrargs(xdrs, objp)
        XDR *xdrs;
        sattrargs *objp;
{
        if (!xdr_nfs_fh(xdrs, &objp->file)) {
                return (FALSE);
        }
        if (!xdr_sattr(xdrs, &objp->attributes)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_diropargs(xdrs, objp)
        XDR *xdrs;
        diropargs *objp;
{
        if (!xdr_nfs_fh(xdrs, &objp->dir)) {
                return (FALSE);
        }
        if (!xdr_filename(xdrs, &objp->name)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_diropokres(xdrs, objp)
        XDR *xdrs;
        diropokres *objp;
{
        if (!xdr_nfs_fh(xdrs, &objp->file)) {
                return (FALSE);
        }
        if (!xdr_fattr(xdrs, &objp->attributes)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_diropres(xdrs, objp)
        XDR *xdrs;
        diropres *objp;
{
        if (!xdr_nfsstat(xdrs, &objp->status)) {
                return (FALSE);
        }
        switch (objp->status) {
        case NFS_OK:
                if (!xdr_diropokres(xdrs, &objp->diropres_u.diropres)) {
                        return (FALSE);
                }
                break;
        }
        return (TRUE);
}




bool_t
xdr_readlinkres(xdrs, objp)
        XDR *xdrs;
        readlinkres *objp;
{
        if (!xdr_nfsstat(xdrs, &objp->status)) {
                return (FALSE);
        }
        switch (objp->status) {
        case NFS_OK:
                if (!xdr_nfspath(xdrs, &objp->readlinkres_u.data)) {
                        return (FALSE);
                }
                break;
        }
        return (TRUE);
}




bool_t
xdr_readargs(xdrs, objp)
        XDR *xdrs;
        readargs *objp;
{
        if (!xdr_nfs_fh(xdrs, &objp->file)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->offset)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->count)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->totalcount)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_readokres(xdrs, objp)
        XDR *xdrs;
        readokres *objp;
{
        if (!xdr_fattr(xdrs, &objp->attributes)) {
                return (FALSE);
        }
        if (!xdr_bytes(xdrs, (char **)&objp->data.data_val, (u_int *)&objp->data.data_len, NFS_MAXDATA)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_readres(xdrs, objp)
        XDR *xdrs;
        readres *objp;
{
        if (!xdr_nfsstat(xdrs, &objp->status)) {
                return (FALSE);
        }
        switch (objp->status) {
        case NFS_OK:
                if (!xdr_readokres(xdrs, &objp->readres_u.reply)) {
                        return (FALSE);
                }
                break;
        }
        return (TRUE);
}




bool_t
xdr_writeargs(xdrs, objp)
        XDR *xdrs;
        writeargs *objp;
{
        if (!xdr_nfs_fh(xdrs, &objp->file)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->beginoffset)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->offset)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->totalcount)) {
                return (FALSE);
        }
        if (!xdr_bytes(xdrs, (char **)&objp->data.data_val, (u_int *)&objp->data.data_len, NFS_MAXDATA)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_createargs(xdrs, objp)
        XDR *xdrs;
        createargs *objp;
{
        if (!xdr_diropargs(xdrs, &objp->where)) {
                return (FALSE);
        }
        if (!xdr_sattr(xdrs, &objp->attributes)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_renameargs(xdrs, objp)
        XDR *xdrs;
        renameargs *objp;
{
        if (!xdr_diropargs(xdrs, &objp->from)) {
                return (FALSE);
        }
        if (!xdr_diropargs(xdrs, &objp->to)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_linkargs(xdrs, objp)
        XDR *xdrs;
        linkargs *objp;
{
        if (!xdr_nfs_fh(xdrs, &objp->from)) {
                return (FALSE);
        }
        if (!xdr_diropargs(xdrs, &objp->to)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_symlinkargs(xdrs, objp)
        XDR *xdrs;
        symlinkargs *objp;
{
        if (!xdr_diropargs(xdrs, &objp->from)) {
                return (FALSE);
        }
        if (!xdr_nfspath(xdrs, &objp->to)) {
                return (FALSE);
        }
        if (!xdr_sattr(xdrs, &objp->attributes)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_nfscookie(xdrs, objp)
        XDR *xdrs;
        nfscookie objp;
{
        if (!xdr_opaque(xdrs, objp, NFS_COOKIESIZE)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_readdirargs(xdrs, objp)
        XDR *xdrs;
        readdirargs *objp;
{
        if (!xdr_nfs_fh(xdrs, &objp->dir)) {
                return (FALSE);
        }
        if (!xdr_nfscookie(xdrs, objp->cookie)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->count)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_entry(xdrs, objp)
        XDR *xdrs;
        entry *objp;
{
        if (!xdr_u_int(xdrs, &objp->fileid)) {
                return (FALSE);
        }
        if (!xdr_filename(xdrs, &objp->name)) {
                return (FALSE);
        }
        if (!xdr_nfscookie(xdrs, objp->cookie)) {
                return (FALSE);
        }
        if (!xdr_pointer(xdrs, (char **)&objp->nextentry, sizeof(entry), xdr_entry)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_dirlist(xdrs, objp)
        XDR *xdrs;
        dirlist *objp;
{
lightweight_printf( "xdr_dirlist: doing an xdr_pointer\n" );
        if (!xdr_pointer(xdrs, (char **)&objp->entries, sizeof(entry), xdr_entry)) {
lightweight_printf( "xdr_dirlist: xdr_pointer failed\n" );
                return (FALSE);
        }
lightweight_printf( "xdr_dirlist: xdr_pointer worked, doing an xdr_bool\n" );
        if (!xdr_bool(xdrs, &objp->eof)) {
lightweight_printf( "xdr_dirlist: xdr_bool failed\n" );
                return (FALSE);
        }
lightweight_printf( "xdr_dirlist: xdr_bool worked\n" );
        return (TRUE);
}




bool_t
xdr_readdirres(xdrs, objp)
        XDR *xdrs;
        readdirres *objp;
{
lightweight_printf( "doing a xdr_nfsstat\n" );
        if (!xdr_nfsstat(xdrs, &objp->status)) {
                return (FALSE);
        }
lightweight_printf( "xdr_nfsstat finished ok\n" );
        switch (objp->status) {
        case NFS_OK:
lightweight_printf( "doing a xdr_dirlist\n" );
                if (!xdr_dirlist(xdrs, &objp->readdirres_u.reply)) {
lightweight_printf( "xdr_dirlist finished but failed\n" );
                        return (FALSE);
                }
lightweight_printf( "xdr_dirlist finished and succeeded\n" );
                break;
        }
        return (TRUE);
}




bool_t
xdr_statfsokres(xdrs, objp)
        XDR *xdrs;
        statfsokres *objp;
{
        if (!xdr_u_int(xdrs, &objp->tsize)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->bsize)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->blocks)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->bfree)) {
                return (FALSE);
        }
        if (!xdr_u_int(xdrs, &objp->bavail)) {
                return (FALSE);
        }
        return (TRUE);
}




bool_t
xdr_statfsres(xdrs, objp)
        XDR *xdrs;
        statfsres *objp;
{
        if (!xdr_nfsstat(xdrs, &objp->status)) {
                return (FALSE);
        }
        switch (objp->status) {
        case NFS_OK:
                if (!xdr_statfsokres(xdrs, &objp->statfsres_u.reply)) {
                        return (FALSE);
                }
                break;
        }
        return (TRUE);
}


@


4.1.7.1
log
@Imported from Babel
@
text
@@

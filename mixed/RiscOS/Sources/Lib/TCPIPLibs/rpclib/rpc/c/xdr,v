head	4.6;
access;
symbols
	TCPIPLibs-5_66:4.6
	TCPIPLibs-5_65:4.6
	TCPIPLibs-5_64:4.6
	TCPIPLibs-5_63:4.6
	TCPIPLibs-5_62:4.6
	TCPIPLibs-5_61:4.6
	TCPIPLibs-5_60:4.6
	TCPIPLibs-5_59:4.6
	TCPIPLibs-5_58:4.6
	TCPIPLibs-5_57:4.6
	TCPIPLibs-5_56:4.6
	TCPIPLibs-5_55:4.6
	TCPIPLibs-5_54:4.6
	TCPIPLibs-5_53:4.6
	TCPIPLibs-5_52:4.6
	TCPIPLibs-5_51:4.6
	TCPIPLibs-5_50:4.6
	TCPIPLibs-5_49:4.6
	RO_5_07:4.6
	TCPIPLibs-5_48:4.6
	TCPIPLibs-5_47:4.6
	TCPIPLibs-5_46:4.6
	TCPIPLibs-5_45:4.6
	TCPIPLibs-5_44:4.6
	TCPIPLibs-5_43:4.6
	TCPIPLibs-5_42:4.6
	TCPIPLibs-5_41:4.6
	TCPIPLibs-5_40:4.6
	TCPIPLibs-5_39:4.6
	dellis_autobuild_BaseSW:4.6
	TCPIPLibs-5_38:4.6
	TCPIPLibs-5_37:4.4
	TCPIPLibs-5_36:4.4
	sbrodie_sedwards_16Mar2000:4.3
	TCPIPLibs-5_35:4.3
	TCPIPLibs-5_34:4.3
	TCPIPLibs-5_33:4.3
	TCPIPLibs-5_32:4.3
	TCPIPLibs-5_31:4.3
	dcotton_autobuild_BaseSW:4.6
	TCPIPLibs-5_30:4.3
	TCPIPLibs-5_29:4.3
	TCPIPLibs-5_28:4.3
	TCPIPLibs-5_27:4.3
	TCPIPLibs-5_26:4.3
	TCPIPLibs-5_25:4.3
	TCPIPLibs-5_24:4.3
	TCPIPLibs-5_23:4.3
	TCPIPLibs-5_22:4.3
	TCPIPLibs-5_21:4.3
	TCPIPLibs-5_20:4.3
	TCPIPLibs-5_19:4.3
	TCPIPLibs-5_18:4.3
	TCPIPLibs-5_17:4.3
	TCPIPLibs-5_16:4.3
	TCPIPLibs-5_15:4.3
	TCPIPLibs-5_14:4.3
	TCPIPLibs-5_13:4.3
	TCPIPLibs-5_12:4.3
	TCPIPLibs-5_11:4.3
	TCPIPLibs-5_10:4.3
	TCPIPLibs-5_09:4.3
	TCPIPLibs-5_08:4.3
	TCPIPLibs-5_07:4.2
	TCPIPLibs-5_06:4.1
	TCPIPLibs-5_05:4.1
	TCPIPLibs-5_04:4.1
	TCPIPLibs-5_03:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.10
	TCPIPLibs-5_02:4.1
	TCPIPLibs-5_01:4.1
	nicke_TCPIPLibs_25-9-98:4.1
	TCPIPLibs-5_00:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	Spinner:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.8
	Ursula_19May1998_bp:4.1
	Ursula_19May1998:4.1.0.4
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.4
	RCA:4.1.0.2
	import:4.1.7.1;
locks; strict;
comment	@# @;


4.6
date	2000.05.04.12.36.53;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2000.05.04.10.59.17;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	2000.05.03.10.35.03;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	99.03.19.16.49.28;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	99.03.16.16.25.29;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	97.03.06.14.27.53;	author rbuckley;	state Exp;
branches
	4.1.7.1;
next	;

4.1.7.1
date	97.03.06.14.27.53;	author rbuckley;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Replaced lost open comment line. Re-tagged TCPIPLibs-5_38
@
text
@/* @@(#)xdr.c    2.1 88/07/29 4.0 RPCSRC */
/*
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 *
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 *
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 *
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 *
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 *
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
 */
#if !defined(lint) && defined(SCCSIDS)
static char sccsid[] = "@@(#)xdr.c 1.35 87/08/12";
#endif

/*
 * xdr.c, Generic XDR routines implementation.
 *
 * Copyright (C) 1986, Sun Microsystems, Inc.
 *
 * These are the "generic" xdr routines used to serialize and de-serialize
 * most common data items.  See xdr.h for more info on the interface to
 * xdr.
 */

#include <stdio.h>
#include <stdlib.h>
/*char *malloc();*/

#include <rpc/types.h>
#include <rpc/xdr.h>

/*
 * constants specific to the xdr "protocol"
 */
#define XDR_FALSE       ((long) 0)
#define XDR_TRUE        ((long) 1)
#define LASTUNSIGNED    ((u_int) 0-1)

/*
 * for unit alignment
 */
static char xdr_zero[BYTES_PER_XDR_UNIT] = { 0, 0, 0, 0 };

/*
 * Free a data structure using XDR
 * Not a filter, but a convenient utility nonetheless
 */
void
xdr_free(proc, objp)
        xdrproc_t proc;
        char *objp;
{
        XDR x;

        x.x_op = XDR_FREE;
        (*proc)(&x, objp);
}

/*
 * XDR nothing
 */
bool_t
xdr_void(/* xdrs, addr */)
        /* XDR *xdrs; */
        /* caddr_t addr; */
{

        return (TRUE);
}

/*
 * XDR integers
 */
bool_t
xdr_int(xdrs, ip)
        XDR *xdrs;
        int *ip;
{

#ifdef lint
        (void) (xdr_short(xdrs, (short *)ip));
        return (xdr_long(xdrs, (long *)ip));
#else
        if (sizeof (int) == sizeof (long)) {
                return (xdr_long(xdrs, (long *)ip));
        } else {
                return (xdr_short(xdrs, (short *)ip));
        }
#endif
}

/*
 * XDR unsigned integers
 */
bool_t
xdr_u_int(xdrs, up)
        XDR *xdrs;
        u_int *up;
{

#ifdef lint
        (void) (xdr_short(xdrs, (short *)up));
        return (xdr_u_long(xdrs, (u_long *)up));
#else
        if (sizeof (u_int) == sizeof (u_long)) {
                return (xdr_u_long(xdrs, (u_long *)up));
        } else {
                return (xdr_short(xdrs, (short *)up));
        }
#endif
}

/*
 * XDR long integers
 * same as xdr_u_long - open coded to save a proc call!
 */
bool_t
xdr_long(xdrs, lp)
        register XDR *xdrs;
        long *lp;
{

        if (xdrs->x_op == XDR_ENCODE)
                return (XDR_PUTLONG(xdrs, lp));

        if (xdrs->x_op == XDR_DECODE)
                return (XDR_GETLONG(xdrs, lp));

        if (xdrs->x_op == XDR_FREE)
                return (TRUE);

        return (FALSE);
}

/*
 * XDR unsigned long integers
 * same as xdr_long - open coded to save a proc call!
 */
bool_t
xdr_u_long(xdrs, ulp)
        register XDR *xdrs;
        u_long *ulp;
{

        if (xdrs->x_op == XDR_DECODE)
                return (XDR_GETLONG(xdrs, (long *)ulp));
        if (xdrs->x_op == XDR_ENCODE)
                return (XDR_PUTLONG(xdrs, (long *)ulp));
        if (xdrs->x_op == XDR_FREE)
                return (TRUE);
        return (FALSE);
}

/*
 * XDR short integers
 */
bool_t
xdr_short(xdrs, sp)
        register XDR *xdrs;
        short *sp;
{
        long l;

        switch (xdrs->x_op) {

        case XDR_ENCODE:
                l = (long) *sp;
                return (XDR_PUTLONG(xdrs, &l));

        case XDR_DECODE:
                if (!XDR_GETLONG(xdrs, &l)) {
                        return (FALSE);
                }
                *sp = (short) l;
                return (TRUE);

        case XDR_FREE:
                return (TRUE);
        }
        return (FALSE);
}

/*
 * XDR unsigned short integers
 */
bool_t
xdr_u_short(xdrs, usp)
        register XDR *xdrs;
        u_short *usp;
{
        u_long l;

        switch (xdrs->x_op) {

        case XDR_ENCODE:
                l = (u_long) *usp;
                return (XDR_PUTLONG(xdrs, &l));

        case XDR_DECODE:
                if (!XDR_GETLONG(xdrs, &l)) {
                        return (FALSE);
                }
                *usp = (u_short) l;
                return (TRUE);

        case XDR_FREE:
                return (TRUE);
        }
        return (FALSE);
}


/*
 * XDR a char
 */
bool_t
xdr_char(xdrs, cp)
        XDR *xdrs;
        char *cp;
{
        int i;

        i = (*cp);
        if (!xdr_int(xdrs, &i)) {
                return (FALSE);
        }
        *cp = i;
        return (TRUE);
}

/*
 * XDR an unsigned char
 */
bool_t
xdr_u_char(xdrs, cp)
        XDR *xdrs;
        char *cp;
{
        u_int u;

        u = (*cp);
        if (!xdr_u_int(xdrs, &u)) {
                return (FALSE);
        }
        *cp = u;
        return (TRUE);
}

/*
 * XDR booleans
 */
bool_t
xdr_bool(xdrs, bp)
        register XDR *xdrs;
        bool_t *bp;
{
        long lb;

        switch (xdrs->x_op) {

        case XDR_ENCODE:
                lb = *bp ? XDR_TRUE : XDR_FALSE;
                return (XDR_PUTLONG(xdrs, &lb));

        case XDR_DECODE:
                if (!XDR_GETLONG(xdrs, &lb)) {
                        return (FALSE);
                }
                *bp = (lb == XDR_FALSE) ? FALSE : TRUE;
                return (TRUE);

        case XDR_FREE:
                return (TRUE);
        }
        return (FALSE);
}

/*
 * XDR enumerations
 */
bool_t
xdr_enum(xdrs, ep)
        XDR *xdrs;
        enum_t *ep;
{
#ifndef lint
        enum sizecheck { SIZEVAL };     /* used to find the size of an enum */
        (void) SIZEVAL;
        /*
         * enums are treated as ints
         */
        if (sizeof (enum sizecheck) == sizeof (long)) {
                return (xdr_long(xdrs, (long *)ep));
        } else if (sizeof (enum sizecheck) == sizeof (short)) {
                return (xdr_short(xdrs, (short *)ep));
        } else {
                return (FALSE);
        }
#else
        (void) (xdr_short(xdrs, (short *)ep));
        return (xdr_long(xdrs, (long *)ep));
#endif
}

/*
 * XDR opaque data
 * Allows the specification of a fixed size sequence of opaque bytes.
 * cp points to the opaque object and cnt gives the byte length.
 */
bool_t
xdr_opaque(xdrs, cp, cnt)
        register XDR *xdrs;
        caddr_t cp;
        register u_int cnt;
{
        register u_int rndup;
        static crud[BYTES_PER_XDR_UNIT];

        /*
         * if no data we are done
         */
        if (cnt == 0)
                return (TRUE);

        /*
         * round byte count to full xdr units
         */
        rndup = cnt % BYTES_PER_XDR_UNIT;
        if (rndup > 0)
                rndup = BYTES_PER_XDR_UNIT - rndup;

        if (xdrs->x_op == XDR_DECODE) {
                if (!XDR_GETBYTES(xdrs, cp, cnt)) {
                        return (FALSE);
                }
                if (rndup == 0)
                        return (TRUE);
                return (XDR_GETBYTES(xdrs, crud, rndup));
        }

        if (xdrs->x_op == XDR_ENCODE) {
                if (!XDR_PUTBYTES(xdrs, cp, cnt)) {
                        return (FALSE);
                }
                if (rndup == 0)
                        return (TRUE);
                return (XDR_PUTBYTES(xdrs, xdr_zero, rndup));
        }

        if (xdrs->x_op == XDR_FREE) {
                return (TRUE);
        }

        return (FALSE);
}

/*
 * XDR counted bytes
 * *cpp is a pointer to the bytes, *sizep is the count.
 * If *cpp is NULL maxsize bytes are allocated
 */
bool_t
xdr_bytes(xdrs, cpp, sizep, maxsize)
        register XDR *xdrs;
        char **cpp;
        register u_int *sizep;
        u_int maxsize;
{
        register char *sp = *cpp;  /* sp is the actual string pointer */
        register u_int nodesize;

        /*
         * first deal with the length since xdr bytes are counted
         */
        if (! xdr_u_int(xdrs, sizep)) {
                return (FALSE);
        }
        nodesize = *sizep;
        if ((nodesize > maxsize) && (xdrs->x_op != XDR_FREE)) {
                return (FALSE);
        }

        /*
         * now deal with the actual bytes
         */
        switch (xdrs->x_op) {

        case XDR_DECODE:
                if (nodesize == 0) {
                        return (TRUE);
                }
                if (sp == NULL) {
                        *cpp = sp = (char *)mem_alloc(nodesize);
                }
                if (sp == NULL) {
#ifndef RISCOS
                        (void) fprintf(stderr, "xdr_bytes: out of memory\n");
#endif
                        return (FALSE);
                }
                /* fall into ... */

        case XDR_ENCODE:
                return (xdr_opaque(xdrs, sp, nodesize));

        case XDR_FREE:
                if (sp != NULL) {
                        mem_free(sp, nodesize);
                        *cpp = NULL;
                }
                return (TRUE);
        }
        return (FALSE);
}

/*
 * Implemented here due to commonality of the object.
 */
bool_t
xdr_netobj(xdrs, np)
        XDR *xdrs;
        struct netobj *np;
{

        return (xdr_bytes(xdrs, &np->n_bytes, &np->n_len, MAX_NETOBJ_SZ));
}

/*
 * XDR a descriminated union
 * Support routine for discriminated unions.
 * You create an array of xdrdiscrim structures, terminated with
 * an entry with a null procedure pointer.  The routine gets
 * the discriminant value and then searches the array of xdrdiscrims
 * looking for that value.  It calls the procedure given in the xdrdiscrim
 * to handle the discriminant.  If there is no specific routine a default
 * routine may be called.
 * If there is no specific or default routine an error is returned.
 */
bool_t
xdr_union(xdrs, dscmp, unp, choices, dfault)
        register XDR *xdrs;
        enum_t *dscmp;          /* enum to decide which arm to work on */
        char *unp;              /* the union itself */
        struct xdr_discrim *choices;    /* [value, xdr proc] for each arm */
        xdrproc_t dfault;       /* default xdr routine */
{
        register enum_t dscm;

        /*
         * we deal with the discriminator;  it's an enum
         */
        if (! xdr_enum(xdrs, dscmp)) {
                return (FALSE);
        }
        dscm = *dscmp;

        /*
         * search choices for a value that matches the discriminator.
         * if we find one, execute the xdr routine for that value.
         */
        for (; choices->proc != NULL_xdrproc_t; choices++) {
                if (choices->value == dscm)
                        return ((*(choices->proc))(xdrs, unp, LASTUNSIGNED));
        }

        /*
         * no match - execute the default xdr routine if there is one
         */
        return ((dfault == NULL_xdrproc_t) ? FALSE :
            (*dfault)(xdrs, unp, LASTUNSIGNED));
}


/*
 * Non-portable xdr primitives.
 * Care should be taken when moving these routines to new architectures.
 */


/*
 * XDR null terminated ASCII strings
 * xdr_string deals with "C strings" - arrays of bytes that are
 * terminated by a NULL character.  The parameter cpp references a
 * pointer to storage; If the pointer is null, then the necessary
 * storage is allocated.  The last parameter is the max allowed length
 * of the string as specified by a protocol.
 */
bool_t
xdr_string(xdrs, cpp, maxsize)
        register XDR *xdrs;
        char **cpp;
        u_int maxsize;
{
        register char *sp = *cpp;  /* sp is the actual string pointer */
        u_int size;
        u_int nodesize;

        /*
         * first deal with the length since xdr strings are counted-strings
         */
        switch (xdrs->x_op) {
        case XDR_FREE:
                if (sp == NULL) {
                        return(TRUE);   /* already free */
                }
                /* fall through... */
        case XDR_ENCODE:
                size = strlen(sp);
                break;
        }
        if (! xdr_u_int(xdrs, &size)) {
                return (FALSE);
        }
        if (size > maxsize) {
                return (FALSE);
        }
        nodesize = size + 1;

        /*
         * now deal with the actual bytes
         */
        switch (xdrs->x_op) {

        case XDR_DECODE:
                if (nodesize == 0) {
                        return (TRUE);
                }
                if (sp == NULL)
                        *cpp = sp = (char *)mem_alloc(nodesize);
                if (sp == NULL) {
#ifndef RISCOS
                        (void) fprintf(stderr, "xdr_string: out of memory\n");
#endif
                        return (FALSE);
                }
                sp[size] = 0;
                /* fall into ... */

        case XDR_ENCODE:
                return (xdr_opaque(xdrs, sp, size));

        case XDR_FREE:
                mem_free(sp, nodesize);
                *cpp = NULL;
                return (TRUE);
        }
        return (FALSE);
}

/*
 * Wrapper for xdr_string that can be called directly from
 * routines like clnt_call
 */
bool_t
xdr_wrapstring(xdrs, cpp)
        XDR *xdrs;
        char **cpp;
{
        if (xdr_string(xdrs, cpp, LASTUNSIGNED)) {
                return (TRUE);
        }
        return (FALSE);
}

/*
 * XDR signed 64-bit integers
 * (sbrodie; 03/03/1999)
 */
bool_t
xdr_int64_t(xdrs, llp)
	XDR *xdrs;
	int64_t *llp;
{
        if (!xdr_long(xdrs, &llp->high))
                return (FALSE);
        if (!xdr_u_long(xdrs, &llp->low))
                return (FALSE);
        return (TRUE);
}
/*
 * XDR unsigned 64-bit integers
 * (sbrodie; 03/03/1999)
 */
bool_t
xdr_u_int64_t(xdrs, ullp)
	XDR *xdrs;
	u_int64_t *ullp;
{
        if (!xdr_u_long(xdrs, &ullp->high))
                return (FALSE);
        if (!xdr_u_long(xdrs, &ullp->low))
                return (FALSE);
        return (TRUE);
}
@


4.5
log
@Removed dependency on DebugLib

Version 5.38. Tagged as 'TCPIPLibs-5_38'
@
text
@d51 1
@


4.4
log
@  Minor modification to check that re_errno falls within the bounds
  0..sys_nerr-1 before attempting to dereference sys_errlist array
  with it.
Admin:
  Built.
  Should tidy up the output on RPC send failures (fault #1635)

Version 5.36. Tagged as 'TCPIPLibs-5_36'
@
text
@a50 8
#define DEBUGLIB
#define BOOL_DEFINED
#ifndef BOOL
#define BOOL bool_t
#endif
#include "DebugLib/DebugLib.h"

/*
a341 2

        dprintf(("xdr_1", "xdr_opaque(...%p,%d)\n", cp, cnt));
@


4.3
log
@  Macro correction Makefile
  64-bit XDR routines fixed.
Detail:
  Makefile now defines COMPAT_INET4 not DOMPAT_INET4 (!)
  Makefile no longer lists the ALF file contents after building them.
  64-bit bit XDR routines now pass pointers to the fields in the 64-bit
    structure, not the fields themselves.  Previously this meant that
    attempting to XDR_DECODE any 64-bit quantity would cause a data
    abort.
Admin:
  Tested as underlying support library for updated NFS module which
    implements NFSv3.

Version 5.08. Tagged as 'TCPIPLibs-5_08'
@
text
@d45 2
a46 1
char *malloc();
d51 7
d350 2
@


4.2
log
@  64-bit type support in RPC.
  Port discovery function now prototyped!
Detail:
  64-bit support has been added to XDR for any protocols that might
    need it (eg. NFS3)
  getrpcport now has a prototype (rpc/netdb.h)
Admin:
  Tested by building the NFS3 lower-level support files from the
    protocol definition file and verified that the rpcgen generated
    code would compile and link without error.
  This version represents issue 1 of 1215,201/DR and 1215,202/DR.
  This version (5.07) is associated with AMR 5201.

Version 5.07. Tagged as 'TCPIPLibs-5_07'
@
text
@d306 1
a306 1

d592 1
a592 1
        if (!xdr_long(xdrs, llp->high))
d594 1
a594 1
        if (!xdr_u_long(xdrs, llp->low))
d607 1
a607 1
        if (!xdr_u_long(xdrs, ullp->high))
d609 1
a609 1
        if (!xdr_u_long(xdrs, ullp->low))
@


4.1
log
@Initial revision
@
text
@d9 1
a9 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
 * 
d21 1
a21 1
 * 
d25 1
a25 1
 * 
d72 1
a72 1
        
d568 2
a569 2
/* 
 * Wrapper for xdr_string that can be called directly from 
d581 31
@


4.1.7.1
log
@Imported from Babel
@
text
@@

head	4.6;
access;
symbols
	TCPIPLibs-5_66:4.6
	TCPIPLibs-5_65:4.6
	TCPIPLibs-5_64:4.6
	TCPIPLibs-5_63:4.5
	TCPIPLibs-5_62:4.5
	TCPIPLibs-5_61:4.5
	TCPIPLibs-5_60:4.5
	TCPIPLibs-5_59:4.5
	TCPIPLibs-5_58:4.5
	TCPIPLibs-5_57:4.5
	TCPIPLibs-5_56:4.5
	TCPIPLibs-5_55:4.5
	TCPIPLibs-5_54:4.5
	TCPIPLibs-5_53:4.5
	TCPIPLibs-5_52:4.5
	TCPIPLibs-5_51:4.5
	TCPIPLibs-5_50:4.5
	TCPIPLibs-5_49:4.5
	RO_5_07:4.5
	TCPIPLibs-5_48:4.5
	TCPIPLibs-5_47:4.5
	TCPIPLibs-5_46:4.5
	TCPIPLibs-5_45:4.5
	TCPIPLibs-5_44:4.5
	TCPIPLibs-5_43:4.5
	TCPIPLibs-5_42:4.5
	TCPIPLibs-5_41:4.5
	TCPIPLibs-5_40:4.5
	TCPIPLibs-5_39:4.5
	dellis_autobuild_BaseSW:4.5
	TCPIPLibs-5_38:4.5
	TCPIPLibs-5_37:4.5
	TCPIPLibs-5_36:4.5
	sbrodie_sedwards_16Mar2000:4.5
	TCPIPLibs-5_35:4.5
	TCPIPLibs-5_34:4.5
	TCPIPLibs-5_33:4.5
	TCPIPLibs-5_32:4.5
	TCPIPLibs-5_31:4.5
	dcotton_autobuild_BaseSW:4.5
	TCPIPLibs-5_30:4.5
	TCPIPLibs-5_29:4.5
	TCPIPLibs-5_28:4.5
	TCPIPLibs-5_27:4.5
	TCPIPLibs-5_26:4.5
	TCPIPLibs-5_25:4.5
	TCPIPLibs-5_24:4.4
	TCPIPLibs-5_23:4.4
	TCPIPLibs-5_22:4.4
	TCPIPLibs-5_21:4.4
	TCPIPLibs-5_20:4.4
	TCPIPLibs-5_19:4.3
	TCPIPLibs-5_18:4.3
	TCPIPLibs-5_17:4.3
	TCPIPLibs-5_16:4.3
	TCPIPLibs-5_15:4.3
	TCPIPLibs-5_14:4.3
	TCPIPLibs-5_13:4.2
	TCPIPLibs-5_12:4.2
	TCPIPLibs-5_11:4.2
	TCPIPLibs-5_10:4.2
	TCPIPLibs-5_09:4.2
	TCPIPLibs-5_08:4.2
	TCPIPLibs-5_07:4.2
	TCPIPLibs-5_06:4.2
	TCPIPLibs-5_05:4.2
	TCPIPLibs-5_04:4.2
	TCPIPLibs-5_03:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.6
	TCPIPLibs-5_02:4.2
	TCPIPLibs-5_01:4.2
	nicke_TCPIPLibs_25-9-98:4.2
	TCPIPLibs-5_00:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	Spinner:4.2
	Internet_5_07:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.4
	Ursula_19May1998_bp:4.2
	Ursula_19May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Internet_505:4.2
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Spin_merge:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.4
	RCA:4.1.0.2
	import:4.1.7.1;
locks; strict;
comment	@# @;


4.6
date	2018.04.28.09.12.14;	author rool;	state Exp;
branches;
next	4.5;
commitid	e1VdAVmHG5cJKbAA;

4.5
date	99.07.13.10.46.11;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.06.30.13.20.47;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.06.03.12.25.31;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.05.21.03.16.52;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	97.03.06.14.27.41;	author rbuckley;	state Exp;
branches
	4.1.7.1;
next	;

4.1.7.1
date	97.03.06.14.27.41;	author rbuckley;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Strip out insecure T/TCP support
Detail:
  RFC6247 moved T/TCP to historic status due to security concerns, this change actively removes the code (where previously we disabled it through sysctl).

  headers/netinet/tcp_var.h: remove T/TCP support (per FreeBSD revision 137139).
  headers/netinet/tcp.h: remove T/TCP support (per FreeBSD revision 137139).
  headers/netinet/tcp_seq.h: remove T/TCP support (per FreeBSD revision 137139).
  LibraryDoc: removed references to T/TCP, updated MIB variables section, added
              socketstat() and fstat() details.
Admin:
  Submission for TCP/IP bounty.

Version 5.64. Tagged as 'TCPIPLibs-5_64'
@
text
@/*
 * Copyright (c) 1982, 1986, 1993, 1994, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tcp_var.h	8.4 (Berkeley) 5/24/95
 */

#ifndef _NETINET_TCP_VAR_H_
#define _NETINET_TCP_VAR_H_
/*
 * Kernel variables for tcp.
 */

/*
 * Tcp control block, one per tcp; fields:
 */
struct tcpcb {
        struct  tcpiphdr *seg_next;     /* sequencing queue */
        struct  tcpiphdr *seg_prev;
        int     t_state;                /* state of this connection */
        int     t_timer[TCPT_NTIMERS];  /* tcp timers */
        int     t_rxtshift;             /* log(2) of rexmt exp. backoff */
        int     t_rxtcur;               /* current retransmit value */
        int     t_dupacks;              /* consecutive dup acks recd */
        u_int   t_maxseg;               /* maximum segment size */
        u_int   t_maxopd;               /* mss plus options */
        int     t_force;                /* 1 if forcing out a byte */
        u_int   t_flags;
#define TF_ACKNOW       0x00001          /* ack peer immediately */
#define TF_DELACK       0x00002          /* ack, but try to delay it */
#define TF_NODELAY      0x00004          /* don't delay packets to coalesce */
#define TF_NOOPT        0x00008          /* don't use tcp options */
#define TF_SENTFIN      0x00010          /* have sent FIN */
#define	TF_REQ_SCALE	0x00020		/* have/will request window scaling */
#define	TF_RCVD_SCALE	0x00040		/* other side has requested scaling */
#define	TF_REQ_TSTMP	0x00080		/* have/will request timestamps */
#define	TF_RCVD_TSTMP	0x00100		/* a timestamp was received in SYN */
#define	TF_SACK_PERMIT	0x00200		/* other side said I could SACK */
#define TF_NEEDSYN	0x00400		/* send SYN (implicit state) */
#define TF_NEEDFIN	0x00800		/* send FIN (implicit state) */
#define TF_NOPUSH	0x01000		/* don't push */
#define	TF_MORETOCOME	0x10000		/* More data to be appended to sock */

        struct  tcpiphdr *t_template;   /* skeletal packet for transmit */
        struct  inpcb *t_inpcb;         /* back pointer to internet pcb */
/*
 * The following fields are used as in the protocol specification.
 * See RFC783, Dec. 1981, page 21.
 */
/* send sequence variables */
        tcp_seq snd_una;                /* send unacknowledged */
        tcp_seq snd_nxt;                /* send next */
        tcp_seq snd_up;                 /* send urgent pointer */
        tcp_seq snd_wl1;                /* window update seg seq number */
        tcp_seq snd_wl2;                /* window update seg ack number */
        tcp_seq iss;                    /* initial send sequence number */
        u_long  snd_wnd;                /* send window */
/* receive sequence variables */
        u_long  rcv_wnd;                /* receive window */
        tcp_seq rcv_nxt;                /* receive next */
        tcp_seq rcv_up;                 /* receive urgent pointer */
        tcp_seq irs;                    /* initial receive sequence number */
/*
 * Additional variables for this implementation.
 */
/* receive variables */
        tcp_seq rcv_adv;                /* advertised window */
/* retransmit variables */
        tcp_seq snd_max;                /* highest sequence number sent;
                                         * used to recognize retransmits
                                         */
/* congestion control (for slow start, source quench, retransmit after loss) */
        u_long  snd_cwnd;               /* congestion-controlled window */
        u_long  snd_ssthresh;           /* snd_cwnd size threshold for
                                         * for slow start exponential to
                                         * linear switch
                                         */
/*
 * transmit timing stuff.  See below for scale of srtt and rttvar.
 * "Variance" is actually smoothed difference.
 */
        u_int   t_idle;                 /* inactivity time */
        int     t_rtt;                  /* round trip time */
        tcp_seq t_rtseq;                /* sequence number being timed */
        int     t_srtt;                 /* smoothed round-trip time */
        int     t_rttvar;               /* variance in round-trip time */
	u_int	t_rttmin;		/* minimum rtt allowed */
        u_long  max_sndwnd;             /* largest window peer has offered */

/* out-of-band data */
        char    t_oobflags;             /* have some */
        char    t_iobc;                 /* input character */
#define TCPOOB_HAVEDATA 0x01
#define TCPOOB_HADDATA  0x02
    	int 	t_softerror;            /* possible error not yet reported */

/* RFC 1323 variables */
	u_char	snd_scale;		/* window scaling for send window */
	u_char	rcv_scale;		/* window scaling for recv window */
	u_char	request_r_scale;	/* pending window scaling */
	u_char	requested_s_scale;
	u_long	ts_recent;		/* timestamp echo data */
	u_long	ts_recent_age;		/* when last updated */
	tcp_seq	last_ack_sent;
	u_long	t_duration;		/* connection duration */

/* More RTT stuff */
	u_long	t_rttupdated;		/* number of times rtt sampled */
};

/*
 * Structure to hold TCP options that are only used during segment
 * processing (in tcp_input), but not held in the tcpcb.
 * It's basically used to reduce the number of parameters
 * to tcp_dooptions.
 */
struct tcpopt {
	u_long	to_flag;		/* which options are present */
#define TOF_TS		0x0001		/* timestamp */
	u_long	to_tsval;
	u_long	to_tsecr;
};

#define intotcpcb(ip)   ((struct tcpcb *)(ip)->inp_ppcb)
#define sototcpcb(so)   (intotcpcb(sotoinpcb(so)))

/*
 * The smoothed round-trip time and estimated variance
 * are stored as fixed point numbers scaled by the values below.
 * For convenience, these scales are also used in smoothing the average
 * (smoothed = (1/scale)sample + ((scale-1)/scale)smoothed).
 * With these scales, srtt has 3 bits to the right of the binary point,
 * and thus an "ALPHA" of 0.875.  rttvar has 2 bits to the right of the
 * binary point, and is smoothed with an ALPHA of 0.75.
 */
#define	TCP_RTT_SCALE		32	/* multiplier for srtt; 3 bits frac. */
#define	TCP_RTT_SHIFT		5	/* shift for srtt; 3 bits frac. */
#define	TCP_RTTVAR_SCALE	16	/* multiplier for rttvar; 2 bits */
#define	TCP_RTTVAR_SHIFT	4	/* shift for rttvar; 2 bits */
#define	TCP_DELTA_SHIFT		2	/* see tcp_input.c */

/*
 * The initial retransmission should happen at rtt + 4 * rttvar.
 * Because of the way we do the smoothing, srtt and rttvar
 * will each average +1/2 tick of bias.  When we compute
 * the retransmit timer, we want 1/2 tick of rounding and
 * 1 extra tick because of +-1/2 tick uncertainty in the
 * firing of the timer.  The bias will give us exactly the
 * 1.5 tick we need.  But, because the bias is
 * statistical, we have to test that we don't drop below
 * the minimum feasible timer (which is 2 ticks).
 * This version of the macro adapted from a paper by Lawrence
 * Brakmo and Larry Peterson which outlines a problem caused
 * by insufficient precision in the original implementation,
 * which results in inappropriately large RTO values for very
 * fast networks.
 */
#define	TCP_REXMTVAL(tp) \
	max((tp)->t_rttmin, (((tp)->t_srtt >> (TCP_RTT_SHIFT - TCP_DELTA_SHIFT))  \
	  + (tp)->t_rttvar) >> TCP_DELTA_SHIFT)

/* XXX
 * We want to avoid doing m_pullup on incoming packets but that
 * means avoiding dtom on the tcp reassembly code.  That in turn means
 * keeping an mbuf pointer in the reassembly queue (since we might
 * have a cluster).  As a quick hack, the source & destination
 * port numbers (which are no longer needed once we've located the
 * tcpcb) are overlayed with an mbuf pointer.
 */
#define REASS_MBUF(ti) (*(struct mbuf **)&((ti)->ti_t))

/*
 * TCP statistics.
 * Many of these should be kept per connection,
 * but that's inconvenient at the moment.
 */
struct  tcpstat {
        u_long  tcps_connattempt;       /* connections initiated */
        u_long  tcps_accepts;           /* connections accepted */
        u_long  tcps_connects;          /* connections established */
        u_long  tcps_drops;             /* connections dropped */
        u_long  tcps_conndrops;         /* embryonic connections dropped */
        u_long  tcps_closed;            /* conn. closed (includes drops) */
        u_long  tcps_segstimed;         /* segs where we tried to get rtt */
        u_long  tcps_rttupdated;        /* times we succeeded */
        u_long  tcps_delack;            /* delayed acks sent */
        u_long  tcps_timeoutdrop;       /* conn. dropped in rxmt timeout */
        u_long  tcps_rexmttimeo;        /* retransmit timeouts */
        u_long  tcps_persisttimeo;      /* persist timeouts */
        u_long  tcps_keeptimeo;         /* keepalive timeouts */
        u_long  tcps_keepprobe;         /* keepalive probes sent */
        u_long  tcps_keepdrops;         /* connections dropped in keepalive */

        u_long  tcps_sndtotal;          /* total packets sent */
        u_long  tcps_sndpack;           /* data packets sent */
        u_long  tcps_sndbyte;           /* data bytes sent */
        u_long  tcps_sndrexmitpack;     /* data packets retransmitted */
        u_long  tcps_sndrexmitbyte;     /* data bytes retransmitted */
        u_long  tcps_sndacks;           /* ack-only packets sent */
        u_long  tcps_sndprobe;          /* window probes sent */
        u_long  tcps_sndurg;            /* packets sent with URG only */
        u_long  tcps_sndwinup;          /* window update-only packets sent */
        u_long  tcps_sndctrl;           /* control (SYN|FIN|RST) packets sent */

        u_long  tcps_rcvtotal;          /* total packets received */
        u_long  tcps_rcvpack;           /* packets received in sequence */
        u_long  tcps_rcvbyte;           /* bytes received in sequence */
        u_long  tcps_rcvbadsum;         /* packets received with ccksum errs */
        u_long  tcps_rcvbadoff;         /* packets received with bad offset */
        u_long  tcps_rcvshort;          /* packets received too short */
        u_long  tcps_rcvduppack;        /* duplicate-only packets received */
        u_long  tcps_rcvdupbyte;        /* duplicate-only bytes received */
        u_long  tcps_rcvpartduppack;    /* packets with some duplicate data */
        u_long  tcps_rcvpartdupbyte;    /* dup. bytes in part-dup. packets */
        u_long  tcps_rcvoopack;         /* out-of-order packets received */
        u_long  tcps_rcvoobyte;         /* out-of-order bytes received */
        u_long  tcps_rcvpackafterwin;   /* packets with data after window */
        u_long  tcps_rcvbyteafterwin;   /* bytes rcvd after window */
        u_long  tcps_rcvafterclose;     /* packets rcvd after "close" */
        u_long  tcps_rcvwinprobe;       /* rcvd window probe packets */
        u_long  tcps_rcvdupack;         /* rcvd duplicate acks */
        u_long  tcps_rcvacktoomuch;     /* rcvd acks for unsent data */
        u_long  tcps_rcvackpack;        /* rcvd ack packets */
        u_long  tcps_rcvackbyte;        /* bytes acked by rcvd acks */
        u_long  tcps_rcvwinupd;         /* rcvd window update packets */
	u_long	tcps_pawsdrop;		/* segments dropped due to PAWS */
	u_long	tcps_predack;		/* times hdr predict ok for acks */
	u_long	tcps_preddat;		/* times hdr predict ok for data pkts */
	u_long	tcps_pcbcachemiss;
	u_long	tcps_cachedrtt;		/* times cached RTT in route updated */
	u_long	tcps_cachedrttvar;	/* times cached rttvar updated */
	u_long	tcps_cachedssthresh;	/* times cached ssthresh updated */
	u_long	tcps_usedrtt;		/* times RTT initialized from route */
	u_long	tcps_usedrttvar;	/* times RTTVAR initialized from rt */
	u_long	tcps_usedssthresh;	/* times ssthresh initialized from rt*/
	u_long	tcps_persistdrop;	/* timeout in persist state */
	u_long	tcps_badsyn;		/* bogus SYN, e.g. premature ACK */
	u_long	tcps_mturesent;		/* resends due to MTU discovery */
	u_long	tcps_listendrop;	/* listen queue overflows */
};

/*
 * TCB structure exported to user-land via sysctl(3).
 * Evil hack: declare only if in_pcb.h and sys/socketvar.h have been
 * included.  Not all of our clients do.
 */
#if defined(_NETINET_IN_PCB_H_) && defined(_SYS_SOCKETVAR_H_)
struct	xtcpcb {
	size_t	xt_len;
	struct	inpcb	xt_inp;
	struct	tcpcb	xt_tp;
	struct	xsocket	xt_socket;
	u_quad_t	xt_alignment_hack;
};
#endif

/*
 * Names for TCP sysctl objects
 */
#define	TCPCTL_DO_RFC1323	1	/* use RFC-1323 extensions */
#define	TCPCTL_MSSDFLT		3	/* MSS default */
#define TCPCTL_STATS		4	/* statistics (read-only) */
#define	TCPCTL_RTTDFLT		5	/* default RTT estimate */
#define	TCPCTL_KEEPIDLE		6	/* keepalive idle timer */
#define	TCPCTL_KEEPINTVL	7	/* interval to send keepalives */
#define	TCPCTL_SENDSPACE	8	/* send buffer space */
#define	TCPCTL_RECVSPACE	9	/* receive buffer space */
#define	TCPCTL_KEEPINIT		10	/* receive buffer space */
#define	TCPCTL_PCBLIST		11	/* list of all outstanding PCBs */
#define TCPCTL_MAXID		12

#define TCPCTL_NAMES { \
	{ 0, 0 }, \
	{ "rfc1323", CTLTYPE_INT }, \
	{ "mssdflt", CTLTYPE_INT }, \
	{ "stats", CTLTYPE_STRUCT }, \
	{ "rttdflt", CTLTYPE_INT }, \
	{ "keepidle", CTLTYPE_INT }, \
	{ "keepintvl", CTLTYPE_INT }, \
	{ "sendspace", CTLTYPE_INT }, \
	{ "recvspace", CTLTYPE_INT }, \
	{ "keepinit", CTLTYPE_INT }, \
	{ "pcblist", CTLTYPE_STRUCT }, \
}

#ifdef KERNEL
#ifdef SYSCTL_DECL
SYSCTL_DECL(_net_inet_tcp);
#endif

extern	struct inpcbhead tcb;		/* head of queue of active tcpcb's */
extern	struct inpcbinfo tcbinfo;
extern  struct  tcpstat tcpstat; /* tcp statistics */
extern	int tcp_mssdflt;	 /* XXX */
extern	int tcp_minmss;
extern	u_long tcp_now;		 /* for RFC 1323 timestamps */
extern  u_short tcp_lastport;	 /* last assigned port */

void	 tcp_canceltimers(struct tcpcb *);
struct tcpcb *
	 tcp_close(struct tcpcb *);
void	 tcp_ctlinput(int, struct sockaddr *, void *);
int	 tcp_ctloutput(int, struct socket *, int, int, struct mbuf **);
struct tcpcb *
	 tcp_drop(struct tcpcb *, int);
void	 tcp_drain(void);
void	 tcp_fasttimo(void);
void	 tcp_init(void);
void	 tcp_input(struct mbuf *, int);
void	 tcp_mss(struct tcpcb *, int);
int	 tcp_mssopt(struct tcpcb *);
void	 tcp_mtudisc(struct inpcb *, int);
#ifdef __riscos
tcp_seq  tcp_newisn(void);	/* tcp initial send seq # */
#endif
struct tcpcb *
	 tcp_newtcpcb(struct inpcb *);
int	 tcp_output(struct tcpcb *);
void	 tcp_quench(struct inpcb *, int);
void	 tcp_respond(struct tcpcb *,
	    struct tcpiphdr *, struct mbuf *, tcp_seq, tcp_seq, int);
struct rtentry *
	 tcp_rtlookup(struct inpcb *);
void	 tcp_setpersist(struct tcpcb *);
void	 tcp_slowtimo(void);
int	 tcp_sysctl(int *, u_int, void *, size_t *, void *, size_t);
struct tcpiphdr *
	 tcp_template(struct tcpcb *);
struct tcpcb *
	 tcp_timers(struct tcpcb *, int);
void	 tcp_trace(int, int, struct tcpcb *, struct tcpiphdr *, int);
int	 tcp_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *);

extern	u_long tcp_sendspace;
extern	u_long tcp_recvspace;

#endif /* KERNEL */

#endif /* _NETINET_TCP_VAR_H_ */
@


4.5
log
@Added err_set_silent() to unixlib err() functions.
Added strdup() to unixlib.
Added sysctlbyname() to inetlib.
All the header file changes for Internet 5.31.

Version 5.25. Tagged as 'TCPIPLibs-5_25'
@
text
@a69 3
#define TF_REQ_CC	0x02000		/* have/will request CC */
#define	TF_RCVD_CC	0x04000		/* a CC was received in SYN */
#define TF_SENDCCNEW	0x08000		/* send CCnew instead of CC in SYN */
a132 3
/* RFC 1644 variables */
	tcp_cc	cc_send;		/* send connection count */
	tcp_cc	cc_recv;		/* receive connection count */
a147 3
#define TOF_CC		0x0002		/* CC and CCnew are exclusive */
#define TOF_CCNEW	0x0004
#define	TOF_CCECHO	0x0008
a149 2
	tcp_cc	to_cc;		/* holds CC or CCnew */
	tcp_cc	to_ccecho;
a151 17
/*
 * The TAO cache entry which is stored in the protocol family specific
 * portion of the route metrics.
 */
struct rmxp_tao {
	tcp_cc	tao_cc;			/* latest CC in valid SYN */
	tcp_cc	tao_ccsent;		/* latest CC sent to peer */
	u_short	tao_mssopt;		/* peer's cached MSS */
#ifdef notyet
	u_short	tao_flags;		/* cache status flags */
#define	TAOF_DONT	0x0001		/* peer doesn't understand rfc1644 */
#define	TAOF_OK		0x0002		/* peer does understand rfc1644 */
#define	TAOF_UNDEF	0		/* we don't know yet */
#endif /* notyet */
};
#define rmx_taop(r)	((struct rmxp_tao *)(r).rmx_filler)

a288 1
#define	TCPCTL_DO_RFC1644	2	/* use RFC-1644 extensions */
a302 1
	{ "rfc1644", CTLTYPE_INT }, \
d323 1
a335 2
struct rmxp_tao *
	 tcp_gettaocache(struct inpcb *);
@


4.4
log
@Header changes required by Internet 5.27. Note that these changes affect
the layout of several structures peeked by such tools as InetStat. These will
need recompiling for Internet 5.27.

Version 5.20. Tagged as 'TCPIPLibs-5_20'
@
text
@d299 15
d327 1
a327 2
#define	TCPCTL_PATH_MTU_DISC	12	/* do path MTU discovery */
#define TCPCTL_MAXID		13
a341 1
	{ "path_mtu_discovery", CTLTYPE_INT }, \
d345 4
a351 2
extern	int tcp_do_rfc1323;	 /* XXX */
extern	int tcp_do_rfc1644;	 /* XXX */
a353 1
extern	int tcp_rttdflt;	 /* XXX */
@


4.3
log
@  TCP sequence number definition changes.
Detail:
  A new function has been declared for generating initial sequence
    numbers for the Internet module's TCP implementation.  More details
    in Internet module logs.
Admin:
  Required by Internet 5.22
    (CVS: RiscOS/Sources/Networking/AUN/Internet  tag: Internet-5_22)

Version 5.14. Tagged as 'TCPIPLibs-5_14'
@
text
@d57 17
a73 16
#define TF_ACKNOW       0x0001          /* ack peer immediately */
#define TF_DELACK       0x0002          /* ack, but try to delay it */
#define TF_NODELAY      0x0004          /* don't delay packets to coalesce */
#define TF_NOOPT        0x0008          /* don't use tcp options */
#define TF_SENTFIN      0x0010          /* have sent FIN */
#define	TF_REQ_SCALE	0x0020		/* have/will request window scaling */
#define	TF_RCVD_SCALE	0x0040		/* other side has requested scaling */
#define	TF_REQ_TSTMP	0x0080		/* have/will request timestamps */
#define	TF_RCVD_TSTMP	0x0100		/* a timestamp was received in SYN */
#define	TF_SACK_PERMIT	0x0200		/* other side said I could SACK */
#define TF_NEEDSYN	0x0400		/* send SYN (implicit state) */
#define TF_NEEDFIN	0x0800		/* send FIN (implicit state) */
#define TF_NOPUSH	0x1000		/* don't push */
#define TF_REQ_CC	0x2000		/* have/will request CC */
#define	TF_RCVD_CC	0x4000		/* a CC was received in SYN */
#define TF_SENDCCNEW	0x8000		/* send CCnew instead of CC in SYN */
a140 2
/* TUBA stuff */
	caddr_t	t_tuba_pcb;		/* next level down pcb for TCP over z */
d215 1
a215 1
	((((tp)->t_srtt >> (TCP_RTT_SHIFT - TCP_DELTA_SHIFT)) \
d310 4
a313 1
#define TCPCTL_MAXID		10
d326 3
d366 1
a366 1
	    struct tcpiphdr *, struct mbuf *, u_long, u_long, int);
@


4.2
log
@Spinner branch merged.
$Id, $Source and $Header markers removed.
@
text
@d353 3
@


4.1
log
@Initial revision
@
text
@a33 1
 * 	$Id: tcp_var.h,v 1.33 1996/06/05 16:57:38 wollman Exp $
@


4.1.7.1
log
@Imported from Babel
@
text
@@

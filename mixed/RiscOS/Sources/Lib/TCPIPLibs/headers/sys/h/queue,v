head	4.5;
access;
symbols
	TCPIPLibs-5_66:4.5
	TCPIPLibs-5_65:4.5
	TCPIPLibs-5_64:4.5
	TCPIPLibs-5_63:4.5
	TCPIPLibs-5_62:4.4
	TCPIPLibs-5_61:4.4
	TCPIPLibs-5_60:4.3
	TCPIPLibs-5_59:4.3
	TCPIPLibs-5_58:4.3
	TCPIPLibs-5_57:4.3
	TCPIPLibs-5_56:4.3
	TCPIPLibs-5_55:4.3
	TCPIPLibs-5_54:4.3
	TCPIPLibs-5_53:4.3
	TCPIPLibs-5_52:4.3
	TCPIPLibs-5_51:4.3
	TCPIPLibs-5_50:4.3
	TCPIPLibs-5_49:4.3
	RO_5_07:4.3
	TCPIPLibs-5_48:4.3
	TCPIPLibs-5_47:4.3
	TCPIPLibs-5_46:4.2
	TCPIPLibs-5_45:4.2
	TCPIPLibs-5_44:4.2
	TCPIPLibs-5_43:4.2
	TCPIPLibs-5_42:4.2
	TCPIPLibs-5_41:4.2
	TCPIPLibs-5_40:4.2
	TCPIPLibs-5_39:4.2
	dellis_autobuild_BaseSW:4.2
	TCPIPLibs-5_38:4.2
	TCPIPLibs-5_37:4.2
	TCPIPLibs-5_36:4.2
	sbrodie_sedwards_16Mar2000:4.2
	TCPIPLibs-5_35:4.2
	TCPIPLibs-5_34:4.2
	TCPIPLibs-5_33:4.2
	TCPIPLibs-5_32:4.2
	TCPIPLibs-5_31:4.2
	dcotton_autobuild_BaseSW:4.2
	TCPIPLibs-5_30:4.2
	TCPIPLibs-5_29:4.2
	TCPIPLibs-5_28:4.2
	TCPIPLibs-5_27:4.2
	TCPIPLibs-5_26:4.2
	TCPIPLibs-5_25:4.2
	TCPIPLibs-5_24:4.1
	TCPIPLibs-5_23:4.1
	TCPIPLibs-5_22:4.1
	TCPIPLibs-5_21:4.1
	TCPIPLibs-5_20:4.1
	TCPIPLibs-5_19:4.1
	TCPIPLibs-5_18:4.1
	TCPIPLibs-5_17:4.1
	TCPIPLibs-5_16:4.1
	TCPIPLibs-5_15:4.1
	TCPIPLibs-5_14:4.1
	TCPIPLibs-5_13:4.1
	TCPIPLibs-5_12:4.1
	TCPIPLibs-5_11:4.1
	TCPIPLibs-5_10:4.1
	TCPIPLibs-5_09:4.1
	TCPIPLibs-5_08:4.1
	TCPIPLibs-5_07:4.1
	TCPIPLibs-5_06:4.1
	TCPIPLibs-5_05:4.1
	TCPIPLibs-5_04:4.1
	TCPIPLibs-5_03:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.10
	TCPIPLibs-5_02:4.1
	TCPIPLibs-5_01:4.1
	nicke_TCPIPLibs_25-9-98:4.1
	TCPIPLibs-5_00:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	Spinner:4.1
	Internet_5_07:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Ursula_19May1998_bp:4.1
	Ursula_19May1998:4.1.0.8
	rthornb_UrsulaBuild_01May1998:4.1
	celkins_Internet_506:4.1
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Internet_505:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Spin_merge:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.4
	RCA:4.1.0.2
	import:4.1.7.1;
locks; strict;
comment	@# @;


4.5
date	2018.01.13.09.51.44;	author rool;	state Exp;
branches;
next	4.4;
commitid	hGNWLSSZDOOxlHmA;

4.4
date	2016.03.22.23.00.53;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	8v01Uun2E1gyZGZy;

4.3
date	2004.01.21.15.15.20;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	99.07.13.10.46.22;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	97.03.06.14.27.44;	author rbuckley;	state Exp;
branches
	4.1.7.1;
next	;

4.1.7.1
date	97.03.06.14.27.44;	author rbuckley;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Updates to queue.h macros
Detail:
  Add safe _FOREACH iterators to the rest of the queue.h types (from FreeBSD revision 118904).
  Retire CIRCLEQ. Use TAILQ instead, it provides the same functionality (from FreeBSD revision 70469).

Version 5.63. Tagged as 'TCPIPLibs-5_63'
@
text
@/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)queue.h	8.5 (Berkeley) 8/20/94
 * FreeBSD: 118904 2003/08/14 14:49:26
 */

#ifndef _SYS_QUEUE_H_
#define	_SYS_QUEUE_H_

/*
 * This file defines four types of data structures: singly-linked lists,
 * singly-linked tail queues, lists and tail queues.
 *
 * A singly-linked list is headed by a single forward pointer. The elements
 * are singly linked for minimum space and pointer manipulation overhead at
 * the expense of O(n) removal for arbitrary elements. New elements can be
 * added to the list after an existing element or at the head of the list.
 * Elements being removed from the head of the list should use the explicit
 * macro for this purpose for optimum efficiency. A singly-linked list may
 * only be traversed in the forward direction.  Singly-linked lists are ideal
 * for applications with large datasets and few or no removals or for
 * implementing a LIFO queue.
 *
 * A singly-linked tail queue is headed by a pair of pointers, one to the
 * head of the list and the other to the tail of the list. The elements are
 * singly linked for minimum space and pointer manipulation overhead at the
 * expense of O(n) removal for arbitrary elements. New elements can be added
 * to the list after an existing element, at the head of the list, or at the
 * end of the list. Elements being removed from the head of the tail queue
 * should use the explicit macro for this purpose for optimum efficiency.
 * A singly-linked tail queue may only be traversed in the forward direction.
 * Singly-linked tail queues are ideal for applications with large datasets
 * and few or no removals or for implementing a FIFO queue.
 *
 * A simple queue is equivalent to a singly-linked tail queue, and is
 * provided for compatibility with NetBSD source code.
 *
 * A list is headed by a single forward pointer (or an array of forward
 * pointers for a hash table header). The elements are doubly linked
 * so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before
 * or after an existing element or at the head of the list. A list
 * may only be traversed in the forward direction.
 *
 * A tail queue is headed by a pair of pointers, one to the head of the
 * list and the other to the tail of the list. The elements are doubly
 * linked so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before or
 * after an existing element, at the head of the list, or at the end of
 * the list. A tail queue may be traversed in either direction.
 *
 * For details on the use of these macros, see the queue(3) manual page.
 *
 *
 *				SLIST	LIST	STAILQ	TAILQ
 * _HEAD			+	+	+	+
 * _HEAD_INITIALIZER		+	+	+	+
 * _ENTRY			+	+	+	+
 * _INIT			+	+	+	+
 * _EMPTY			+	+	+	+
 * _FIRST			+	+	+	+
 * _NEXT			+	+	+	+
 * _PREV			-	-	-	+
 * _LAST			-	-	+	+
 * _FOREACH			+	+	+	+
 * _FOREACH_SAFE		+	+	+	+
 * _INSERT_HEAD			+	+	+	+
 * _INSERT_BEFORE		-	+	-	+
 * _INSERT_AFTER		+	+	+	+
 * _INSERT_TAIL			-	-	+	+
 * _REMOVE_HEAD			+	-	+	-
 * _REMOVE			+	+	+	+
 *
 */

/*
 * Singly-linked List declarations.
 */
#define SLIST_HEAD(name, type)						\
struct name {								\
	struct type *slh_first;	/* first element */			\
}

#define SLIST_HEAD_INITIALIZER(head)					\
	{ NULL }
 
#define SLIST_ENTRY(type)						\
struct {								\
	struct type *sle_next;	/* next element */			\
}
 
/*
 * Singly-linked List functions.
 */
#define	SLIST_EMPTY(head)	((head)->slh_first == NULL)

#define	SLIST_FIRST(head)	((head)->slh_first)

#define SLIST_FOREACH(var, head, field)					\
	for((var) = (head)->slh_first; (var); (var) = (var)->field.sle_next)

#define	SLIST_FOREACH_SAFE(var, head, field, tvar)			\
	for ((var) = SLIST_FIRST((head));				\
	    (var) && ((tvar) = SLIST_NEXT((var), field), 1);		\
	    (var) = (tvar))

#define SLIST_INIT(head) {						\
	(head)->slh_first = NULL;					\
}

#define SLIST_INSERT_AFTER(slistelm, elm, field) do {			\
	(elm)->field.sle_next = (slistelm)->field.sle_next;		\
	(slistelm)->field.sle_next = (elm);				\
} while (0)

#define SLIST_INSERT_HEAD(head, elm, field) do {			\
	(elm)->field.sle_next = (head)->slh_first;			\
	(head)->slh_first = (elm);					\
} while (0)

#define SLIST_NEXT(elm, field)	((elm)->field.sle_next)

#define SLIST_REMOVE_HEAD(head, field) do {				\
	(head)->slh_first = (head)->slh_first->field.sle_next;		\
} while (0)

#define SLIST_REMOVE(head, elm, type, field) do {			\
	if ((head)->slh_first == (elm)) {				\
		SLIST_REMOVE_HEAD((head), field);			\
	}								\
	else {								\
		struct type *curelm = (head)->slh_first;		\
		while( curelm->field.sle_next != (elm) )		\
			curelm = curelm->field.sle_next;		\
		curelm->field.sle_next =				\
		    curelm->field.sle_next->field.sle_next;		\
	}								\
} while (0)

/*
 * Singly-linked Tail queue declarations.
 */
#define STAILQ_HEAD(name, type)						\
struct name {								\
	struct type *stqh_first;/* first element */			\
	struct type **stqh_last;/* addr of last next element */		\
}

#define STAILQ_HEAD_INITIALIZER(head)					\
	{ NULL, &(head).stqh_first }

#define STAILQ_ENTRY(type)						\
struct {								\
	struct type *stqe_next;	/* next element */			\
}

/*
 * Singly-linked Tail queue functions.
 */
#define STAILQ_EMPTY(head) ((head)->stqh_first == NULL)

#define	STAILQ_INIT(head) do {						\
	(head)->stqh_first = NULL;					\
	(head)->stqh_last = &(head)->stqh_first;			\
} while (0)

#define STAILQ_FIRST(head)	((head)->stqh_first)
#define STAILQ_LAST(head)	(*(head)->stqh_last)

#define STAILQ_FOREACH(var, head, field)				\
	for((var) = (head)->stqh_first; (var); (var) = (var)->field.stqe_next)


#define	STAILQ_FOREACH_SAFE(var, head, field, tvar)			\
	for ((var) = STAILQ_FIRST((head));				\
	    (var) && ((tvar) = STAILQ_NEXT((var), field), 1);		\
	    (var) = (tvar))

#define STAILQ_INSERT_HEAD(head, elm, field) do {			\
	if (((elm)->field.stqe_next = (head)->stqh_first) == NULL)	\
		(head)->stqh_last = &(elm)->field.stqe_next;		\
	(head)->stqh_first = (elm);					\
} while (0)

#define STAILQ_INSERT_TAIL(head, elm, field) do {			\
	(elm)->field.stqe_next = NULL;					\
	*(head)->stqh_last = (elm);					\
	(head)->stqh_last = &(elm)->field.stqe_next;			\
} while (0)

#define STAILQ_INSERT_AFTER(head, tqelm, elm, field) do {		\
	if (((elm)->field.stqe_next = (tqelm)->field.stqe_next) == NULL)\
		(head)->stqh_last = &(elm)->field.stqe_next;		\
	(tqelm)->field.stqe_next = (elm);				\
} while (0)

#define STAILQ_NEXT(elm, field)	((elm)->field.stqe_next)

#define STAILQ_REMOVE_HEAD(head, field) do {				\
	if (((head)->stqh_first =					\
	     (head)->stqh_first->field.stqe_next) == NULL)		\
		(head)->stqh_last = &(head)->stqh_first;		\
} while (0)


#define STAILQ_REMOVE(head, elm, type, field) do {			\
	if ((head)->stqh_first == (elm)) {				\
		STAILQ_REMOVE_HEAD(head, field);			\
	}								\
	else {								\
		struct type *curelm = (head)->stqh_first;		\
		while( curelm->field.stqe_next != (elm) )		\
			curelm = curelm->field.stqe_next;		\
		if((curelm->field.stqe_next =				\
		    curelm->field.stqe_next->field.stqe_next) == NULL)	\
			(head)->stqh_last = &(curelm)->field.stqe_next;	\
	}								\
} while (0)

/*
 * Simple queue definitions.
 */
#define SIMPLEQ_HEAD             STAILQ_HEAD
#define SIMPLEQ_HEAD_INITIALIZER STAILQ_HEAD_INITIALIZER
#define SIMPLEQ_ENTRY            STAILQ_ENTRY

/*
 * Simple queue functions.
 */
#define SIMPLEQ_EMPTY            STAILQ_EMPTY
#define SIMPLEQ_INIT             STAILQ_INIT
#define SIMPLEQ_FIRST            STAILQ_FIRST
#define SIMPLEQ_LAST             STAILQ_LAST
#define SIMPLEQ_FOREACH          STAILQ_FOREACH
#define SIMPLEQ_INSERT_HEAD      STAILQ_INSERT_HEAD
#define SIMPLEQ_INSERT_TAIL      STAILQ_INSERT_TAIL
#define SIMPLEQ_INSERT_AFTER     STAILQ_INSERT_AFTER
#define SIMPLEQ_NEXT             STAILQ_NEXT
#define SIMPLEQ_REMOVE_HEAD      STAILQ_REMOVE_HEAD
#define SIMPLEQ_REMOVE           STAILQ_REMOVE

/*
 * List declarations.
 */
#define LIST_HEAD(name, type)						\
struct name {								\
	struct type *lh_first;	/* first element */			\
}

#define LIST_HEAD_INITIALIZER(head)					\
	{ NULL }

#define LIST_ENTRY(type)						\
struct {								\
	struct type *le_next;	/* next element */			\
	struct type **le_prev;	/* address of previous next element */	\
}

/*
 * List functions.
 */

#define	LIST_EMPTY(head) ((head)->lh_first == NULL)

#define LIST_FIRST(head)	((head)->lh_first)

#define LIST_FOREACH(var, head, field)					\
	for((var) = (head)->lh_first; (var); (var) = (var)->field.le_next)

#define	LIST_FOREACH_SAFE(var, head, field, tvar)			\
	for ((var) = LIST_FIRST((head));				\
	    (var) && ((tvar) = LIST_NEXT((var), field), 1);		\
	    (var) = (tvar))

#define	LIST_INIT(head) do {						\
	(head)->lh_first = NULL;					\
} while (0)

#define LIST_INSERT_AFTER(listelm, elm, field) do {			\
	if (((elm)->field.le_next = (listelm)->field.le_next) != NULL)	\
		(listelm)->field.le_next->field.le_prev =		\
		    &(elm)->field.le_next;				\
	(listelm)->field.le_next = (elm);				\
	(elm)->field.le_prev = &(listelm)->field.le_next;		\
} while (0)

#define LIST_INSERT_BEFORE(listelm, elm, field) do {			\
	(elm)->field.le_prev = (listelm)->field.le_prev;		\
	(elm)->field.le_next = (listelm);				\
	*(listelm)->field.le_prev = (elm);				\
	(listelm)->field.le_prev = &(elm)->field.le_next;		\
} while (0)

#define LIST_INSERT_HEAD(head, elm, field) do {				\
	if (((elm)->field.le_next = (head)->lh_first) != NULL)		\
		(head)->lh_first->field.le_prev = &(elm)->field.le_next;\
	(head)->lh_first = (elm);					\
	(elm)->field.le_prev = &(head)->lh_first;			\
} while (0)

#define LIST_NEXT(elm, field)	((elm)->field.le_next)

#define LIST_REMOVE(elm, field) do {					\
	if ((elm)->field.le_next != NULL)				\
		(elm)->field.le_next->field.le_prev = 			\
		    (elm)->field.le_prev;				\
	*(elm)->field.le_prev = (elm)->field.le_next;			\
} while (0)

/*
 * Tail queue declarations.
 */
#define TAILQ_HEAD(name, type)						\
struct name {								\
	struct type *tqh_first;	/* first element */			\
	struct type **tqh_last;	/* addr of last next element */		\
}

#define TAILQ_HEAD_INITIALIZER(head)					\
	{ NULL, &(head).tqh_first }

#define TAILQ_ENTRY(type)						\
struct {								\
	struct type *tqe_next;	/* next element */			\
	struct type **tqe_prev;	/* address of previous next element */	\
}

/*
 * Tail queue functions.
 */
#define	TAILQ_EMPTY(head) ((head)->tqh_first == NULL)

#define TAILQ_FOREACH(var, head, field)					\
	for (var = TAILQ_FIRST(head); var; var = TAILQ_NEXT(var, field))

#define	TAILQ_FOREACH_SAFE(var, head, field, tvar)			\
	for ((var) = TAILQ_FIRST((head));				\
	    (var) && ((tvar) = TAILQ_NEXT((var), field), 1);		\
	    (var) = (tvar))

#define	TAILQ_FIRST(head) ((head)->tqh_first)

#define	TAILQ_LAST(head, headname) \
	(*(((struct headname *)((head)->tqh_last))->tqh_last))

#define	TAILQ_NEXT(elm, field) ((elm)->field.tqe_next)

#define TAILQ_PREV(elm, headname, field) \
	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))

#define	TAILQ_INIT(head) do {						\
	(head)->tqh_first = NULL;					\
	(head)->tqh_last = &(head)->tqh_first;				\
} while (0)

#define TAILQ_INSERT_HEAD(head, elm, field) do {			\
	if (((elm)->field.tqe_next = (head)->tqh_first) != NULL)	\
		(head)->tqh_first->field.tqe_prev =			\
		    &(elm)->field.tqe_next;				\
	else								\
		(head)->tqh_last = &(elm)->field.tqe_next;		\
	(head)->tqh_first = (elm);					\
	(elm)->field.tqe_prev = &(head)->tqh_first;			\
} while (0)

#define TAILQ_INSERT_TAIL(head, elm, field) do {			\
	(elm)->field.tqe_next = NULL;					\
	(elm)->field.tqe_prev = (head)->tqh_last;			\
	*(head)->tqh_last = (elm);					\
	(head)->tqh_last = &(elm)->field.tqe_next;			\
} while (0)

#define TAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
	if (((elm)->field.tqe_next = (listelm)->field.tqe_next) != NULL)\
		(elm)->field.tqe_next->field.tqe_prev = 		\
		    &(elm)->field.tqe_next;				\
	else								\
		(head)->tqh_last = &(elm)->field.tqe_next;		\
	(listelm)->field.tqe_next = (elm);				\
	(elm)->field.tqe_prev = &(listelm)->field.tqe_next;		\
} while (0)

#define TAILQ_INSERT_BEFORE(listelm, elm, field) do {			\
	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;		\
	(elm)->field.tqe_next = (listelm);				\
	*(listelm)->field.tqe_prev = (elm);				\
	(listelm)->field.tqe_prev = &(elm)->field.tqe_next;		\
} while (0)

#define TAILQ_REMOVE(head, elm, field) do {				\
	if (((elm)->field.tqe_next) != NULL)				\
		(elm)->field.tqe_next->field.tqe_prev = 		\
		    (elm)->field.tqe_prev;				\
	else								\
		(head)->tqh_last = (elm)->field.tqe_prev;		\
	*(elm)->field.tqe_prev = (elm)->field.tqe_next;			\
} while (0)


#ifdef _KERNEL

/*
 * XXX insque() and remque() are an old way of handling certain queues.
 * They bogusly assumes that all queue heads look alike.
 */

struct quehead {
	struct quehead *qh_link;
	struct quehead *qh_rlink;
};

#ifdef	__GNUC__

static __inline void
insque(void *a, void *b)
{
	struct quehead *element = (struct quehead *)a,
		 *head = (struct quehead *)b;

	element->qh_link = head->qh_link;
	element->qh_rlink = head;
	head->qh_link = element;
	element->qh_link->qh_rlink = element;
}

static __inline void
remque(void *a)
{
	struct quehead *element = (struct quehead *)a;

	element->qh_link->qh_rlink = element->qh_rlink;
	element->qh_rlink->qh_link = element->qh_link;
	element->qh_rlink = 0;
}

#else /* !__GNUC__ */

void	insque(void *a, void *b);
void	remque(void *a);

#endif /* __GNUC__ */

#endif /* _KERNEL */

#endif /* !_SYS_QUEUE_H_ */
@


4.4
log
@Add missing singularly linked list initialiser
Macros merged from FreeBSD SVN revision 51955.

Version 5.61. Tagged as 'TCPIPLibs-5_61'
@
text
@d34 1
a34 1
 * FreeBSD: 51955 1999/10/05 20:35:32
d41 2
a42 2
 * This file defines five types of data structures: singly-linked lists,
 * slingly-linked tail queues, lists, tail queues, and circular queues.
d80 1
a80 9
 * the list. A tail queue may only be traversed in the forward direction.
 *
 * A circle queue is headed by a pair of pointers, one to the head of the
 * list and the other to the tail of the list. The elements are doubly
 * linked so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before or after
 * an existing element, at the head of the list, or at the end of the list.
 * A circle queue may be traversed in either direction, but has a more
 * complex end of list detection.
d85 18
a102 16
 *			SLIST	LIST	STAILQ	TAILQ	CIRCLEQ
 * _HEAD		+	+	+	+	+
 * _ENTRY		+	+	+	+	+
 * _INIT		+	+	+	+	+
 * _EMPTY		+	+	+	+	+
 * _FIRST		+	+	+	+	+
 * _NEXT		+	+	+	+	+
 * _PREV		-	-	-	+	+
 * _LAST		-	-	+	+	+
 * _FOREACH		+	+	+	+	+
 * _INSERT_HEAD		+	+	+	+	+
 * _INSERT_BEFORE	-	+	-	+	+
 * _INSERT_AFTER	+	+	+	+	+
 * _INSERT_TAIL		-	-	+	+	+
 * _REMOVE_HEAD		+	-	+	-	-
 * _REMOVE		+	+	+	+	+
d107 1
a107 1
 * Singly-linked List definitions.
d132 5
d171 1
a171 1
 * Singly-linked Tail queue definitions.
d203 6
d273 1
a273 1
 * List definitions.
d300 5
d341 1
a341 1
 * Tail queue definitions.
d366 5
a428 90
/*
 * Circular queue definitions.
 */
#define CIRCLEQ_HEAD(name, type)					\
struct name {								\
	struct type *cqh_first;		/* first element */		\
	struct type *cqh_last;		/* last element */		\
}

#define CIRCLEQ_ENTRY(type)						\
struct {								\
	struct type *cqe_next;		/* next element */		\
	struct type *cqe_prev;		/* previous element */		\
}

/*
 * Circular queue functions.
 */
#define CIRCLEQ_EMPTY(head) ((head)->cqh_first == (void *)(head))

#define CIRCLEQ_FIRST(head) ((head)->cqh_first)

#define CIRCLEQ_FOREACH(var, head, field)				\
	for((var) = (head)->cqh_first;					\
	    (var) != (void *)(head);					\
	    (var) = (var)->field.cqe_next)

#define	CIRCLEQ_INIT(head) do {						\
	(head)->cqh_first = (void *)(head);				\
	(head)->cqh_last = (void *)(head);				\
} while (0)

#define CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
	(elm)->field.cqe_next = (listelm)->field.cqe_next;		\
	(elm)->field.cqe_prev = (listelm);				\
	if ((listelm)->field.cqe_next == (void *)(head))		\
		(head)->cqh_last = (elm);				\
	else								\
		(listelm)->field.cqe_next->field.cqe_prev = (elm);	\
	(listelm)->field.cqe_next = (elm);				\
} while (0)

#define CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do {		\
	(elm)->field.cqe_next = (listelm);				\
	(elm)->field.cqe_prev = (listelm)->field.cqe_prev;		\
	if ((listelm)->field.cqe_prev == (void *)(head))		\
		(head)->cqh_first = (elm);				\
	else								\
		(listelm)->field.cqe_prev->field.cqe_next = (elm);	\
	(listelm)->field.cqe_prev = (elm);				\
} while (0)

#define CIRCLEQ_INSERT_HEAD(head, elm, field) do {			\
	(elm)->field.cqe_next = (head)->cqh_first;			\
	(elm)->field.cqe_prev = (void *)(head);				\
	if ((head)->cqh_last == (void *)(head))				\
		(head)->cqh_last = (elm);				\
	else								\
		(head)->cqh_first->field.cqe_prev = (elm);		\
	(head)->cqh_first = (elm);					\
} while (0)

#define CIRCLEQ_INSERT_TAIL(head, elm, field) do {			\
	(elm)->field.cqe_next = (void *)(head);				\
	(elm)->field.cqe_prev = (head)->cqh_last;			\
	if ((head)->cqh_first == (void *)(head))			\
		(head)->cqh_first = (elm);				\
	else								\
		(head)->cqh_last->field.cqe_next = (elm);		\
	(head)->cqh_last = (elm);					\
} while (0)

#define CIRCLEQ_LAST(head) ((head)->cqh_last)

#define CIRCLEQ_NEXT(elm,field) ((elm)->field.cqe_next)

#define CIRCLEQ_PREV(elm,field) ((elm)->field.cqe_prev)

#define	CIRCLEQ_REMOVE(head, elm, field) do {				\
	if ((elm)->field.cqe_next == (void *)(head))			\
		(head)->cqh_last = (elm)->field.cqe_prev;		\
	else								\
		(elm)->field.cqe_next->field.cqe_prev =			\
		    (elm)->field.cqe_prev;				\
	if ((elm)->field.cqe_prev == (void *)(head))			\
		(head)->cqh_first = (elm)->field.cqe_next;		\
	else								\
		(elm)->field.cqe_prev->field.cqe_next =			\
		    (elm)->field.cqe_next;				\
} while (0)
d430 1
a430 1
#ifdef KERNEL
d447 2
a448 1
	struct quehead *element = a, *head = b;
d459 1
a459 1
	struct quehead *element = a;
d473 1
a473 1
#endif /* KERNEL */
@


4.3
log
@  Added some NetBSDisms to help with the USB2 porting work.
Detail:
  * Added macro __KERNEL_RCSID to sys/cdefs.h
  * Added SIMPLEQ macros to sys/queue.h as aliases for FreeBSD's STAILQ
    macros
  * Added STAILQ/SIMPLEQ_FOREACH macro, since it's found inthe latest
    versions of both the FreeBSD and NetBSD sources
Admin:
  Tested against current USB2 sources.

Version 5.47. Tagged as 'TCPIPLibs-5_47'
@
text
@d34 1
a34 1
 * FreeBSD: 1.25 1999/04/20 22:37:17
d120 3
d127 1
a127 1

d201 2
a202 4
#define	STAILQ_FOREACH(var, head, field)				\
	for((var) = STAILQ_FIRST((head));				\
	   (var);							\
	   (var) = STAILQ_NEXT((var), field))
@


4.2
log
@Added err_set_silent() to unixlib err() functions.
Added strdup() to unixlib.
Added sysctlbyname() to inetlib.
All the header file changes for Internet 5.31.

Version 5.25. Tagged as 'TCPIPLibs-5_25'
@
text
@d65 3
d102 1
a102 1
 * _FOREACH		+	+	-	+	+
d198 5
d243 22
@


4.1
log
@Initial revision
@
text
@d33 2
a34 1
 *	@@(#)queue.h	8.4 (Berkeley) 1/4/94
d37 1
a37 1
#ifndef	_SYS_QUEUE_H_
d41 23
a63 2
 * This file defines three types of data structures: lists, tail queues,
 * and circular queues.
d68 3
a70 3
 * traverse the list. New elements can be added to the list after
 * an existing element or at the head of the list. A list may only be
 * traversed in the forward direction.
d75 3
a77 3
 * traverse the list. New elements can be added to the list after
 * an existing element, at the head of the list, or at the end of the
 * list. A tail queue may only be traversed in the forward direction.
d88 79
d168 67
d244 3
d256 9
a264 1
#define	LIST_INIT(head) {						\
d266 1
a266 1
}
d268 1
a268 1
#define LIST_INSERT_AFTER(listelm, elm, field) {			\
d274 8
a281 1
}
d283 1
a283 1
#define LIST_INSERT_HEAD(head, elm, field) {				\
d288 3
a290 1
}
d292 1
a292 1
#define LIST_REMOVE(elm, field) {					\
d297 1
a297 1
}
d308 3
d320 16
a335 1
#define	TAILQ_INIT(head) {						\
d338 1
a338 1
}
d340 1
a340 1
#define TAILQ_INSERT_HEAD(head, elm, field) {				\
d342 1
a342 1
		(elm)->field.tqe_next->field.tqe_prev =			\
d348 1
a348 1
}
d350 1
a350 1
#define TAILQ_INSERT_TAIL(head, elm, field) {				\
d355 1
a355 1
}
d357 1
a357 1
#define TAILQ_INSERT_AFTER(head, listelm, elm, field) {			\
d365 8
a372 1
}
d374 1
a374 1
#define TAILQ_REMOVE(head, elm, field) {				\
d381 1
a381 1
}
d401 10
a410 1
#define	CIRCLEQ_INIT(head) {						\
d413 1
a413 1
}
d415 1
a415 1
#define CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) {		\
d423 1
a423 1
}
d425 1
a425 1
#define CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) {		\
d433 1
a433 1
}
d435 1
a435 1
#define CIRCLEQ_INSERT_HEAD(head, elm, field) {				\
d443 1
a443 1
}
d445 1
a445 1
#define CIRCLEQ_INSERT_TAIL(head, elm, field) {				\
d453 7
a459 1
}
d461 1
a461 1
#define	CIRCLEQ_REMOVE(head, elm, field) {				\
d472 35
d508 11
a518 1
#endif	/* !_SYS_QUEUE_H_ */
@


4.1.7.1
log
@Imported from Babel
@
text
@@

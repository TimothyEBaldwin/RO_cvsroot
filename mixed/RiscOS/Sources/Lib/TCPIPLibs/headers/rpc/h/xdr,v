head	4.5;
access;
symbols
	TCPIPLibs-5_66:4.5
	TCPIPLibs-5_65:4.5
	TCPIPLibs-5_64:4.5
	TCPIPLibs-5_63:4.5
	TCPIPLibs-5_62:4.5
	TCPIPLibs-5_61:4.5
	TCPIPLibs-5_60:4.5
	TCPIPLibs-5_59:4.5
	TCPIPLibs-5_58:4.5
	TCPIPLibs-5_57:4.5
	TCPIPLibs-5_56:4.5
	TCPIPLibs-5_55:4.5
	TCPIPLibs-5_54:4.5
	TCPIPLibs-5_53:4.5
	TCPIPLibs-5_52:4.5
	TCPIPLibs-5_51:4.5
	TCPIPLibs-5_50:4.5
	TCPIPLibs-5_49:4.5
	RO_5_07:4.5
	TCPIPLibs-5_48:4.5
	TCPIPLibs-5_47:4.5
	TCPIPLibs-5_46:4.5
	TCPIPLibs-5_45:4.5
	TCPIPLibs-5_44:4.5
	TCPIPLibs-5_43:4.5
	TCPIPLibs-5_42:4.5
	TCPIPLibs-5_41:4.5
	TCPIPLibs-5_40:4.5
	TCPIPLibs-5_39:4.5
	dellis_autobuild_BaseSW:4.5
	TCPIPLibs-5_38:4.5
	TCPIPLibs-5_37:4.5
	TCPIPLibs-5_36:4.5
	sbrodie_sedwards_16Mar2000:4.5
	TCPIPLibs-5_35:4.5
	TCPIPLibs-5_34:4.5
	TCPIPLibs-5_33:4.5
	TCPIPLibs-5_32:4.5
	TCPIPLibs-5_31:4.5
	dcotton_autobuild_BaseSW:4.5
	TCPIPLibs-5_30:4.5
	TCPIPLibs-5_29:4.5
	TCPIPLibs-5_28:4.5
	TCPIPLibs-5_27:4.5
	TCPIPLibs-5_26:4.5
	TCPIPLibs-5_25:4.5
	TCPIPLibs-5_24:4.5
	TCPIPLibs-5_23:4.5
	TCPIPLibs-5_22:4.5
	TCPIPLibs-5_21:4.5
	TCPIPLibs-5_20:4.5
	TCPIPLibs-5_19:4.5
	TCPIPLibs-5_18:4.5
	TCPIPLibs-5_17:4.5
	TCPIPLibs-5_16:4.5
	TCPIPLibs-5_15:4.5
	TCPIPLibs-5_14:4.5
	TCPIPLibs-5_13:4.5
	TCPIPLibs-5_12:4.5
	TCPIPLibs-5_11:4.5
	TCPIPLibs-5_10:4.5
	TCPIPLibs-5_09:4.5
	TCPIPLibs-5_08:4.5
	TCPIPLibs-5_07:4.5
	TCPIPLibs-5_06:4.4
	TCPIPLibs-5_05:4.4
	TCPIPLibs-5_04:4.3
	TCPIPLibs-5_03:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.6
	TCPIPLibs-5_02:4.2
	TCPIPLibs-5_01:4.2
	nicke_TCPIPLibs_25-9-98:4.2
	TCPIPLibs-5_00:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	Spinner:4.2
	Internet_5_07:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.4
	Ursula_19May1998_bp:4.2
	Ursula_19May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	celkins_Internet_506:4.2
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Internet_505:4.2
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Spin_merge:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.4
	RCA:4.1.0.2
	import:4.1.7.1;
locks; strict;
comment	@# @;


4.5
date	99.03.16.16.25.25;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	98.11.30.15.36.42;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	98.11.27.15.40.15;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.05.21.03.17.09;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	97.03.06.14.27.42;	author rbuckley;	state Exp;
branches
	4.1.7.1;
next	;

4.1.7.1
date	97.03.06.14.27.42;	author rbuckley;	state Exp;
branches;
next	;


desc
@@


4.5
log
@  64-bit type support in RPC.
  Port discovery function now prototyped!
Detail:
  64-bit support has been added to XDR for any protocols that might
    need it (eg. NFS3)
  getrpcport now has a prototype (rpc/netdb.h)
Admin:
  Tested by building the NFS3 lower-level support files from the
    protocol definition file and verified that the rpcgen generated
    code would compile and link without error.
  This version represents issue 1 of 1215,201/DR and 1215,202/DR.
  This version (5.07) is associated with AMR 5201.

Version 5.07. Tagged as 'TCPIPLibs-5_07'
@
text
@/* -*-C-*-
 *
 * Copyright (c) 1995 Acorn Computers Ltd., Cambridge, England
 *
 * :RCS Log discontinued:
 * Revision 1.1  95/01/11  10:18:38  kwelton
 * Initial revision
 *
 */

/* @@(#)xdr.h	2.2 88/07/29 4.0 RPCSRC */
/*
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 *
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 *
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 *
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 *
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 *
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
 */
/*      @@(#)xdr.h 1.19 87/04/22 SMI      */

/*
 * xdr.h, External Data Representation Serialization Routines.
 *
 * Copyright (C) 1984, Sun Microsystems, Inc.
 */

#ifndef __XDR_HEADER__
#define __XDR_HEADER__

/*
 * XDR provides a conventional way for converting between C data
 * types and an external bit-string representation.  Library supplied
 * routines provide for the conversion on built-in C data types.  These
 * routines and utility routines defined here are used to help implement
 * a type encode/decode routine for each user-defined type.
 *
 * Each data type provides a single procedure which takes two arguments:
 *
 *	bool_t
 *	xdrproc(xdrs, argresp)
 *		XDR *xdrs;
 *		<type> *argresp;
 *
 * xdrs is an instance of a XDR handle, to which or from which the data
 * type is to be converted.  argresp is a pointer to the structure to be
 * converted.  The XDR handle contains an operation field which indicates
 * which of the operations (ENCODE, DECODE * or FREE) is to be performed.
 *
 * XDR_DECODE may allocate space if the pointer argresp is null.  This
 * data can be freed with the XDR_FREE operation.
 *
 * We write only one procedure per data type to make it easy
 * to keep the encode and decode procedures for a data type consistent.
 * In many cases the same code performs all operations on a user defined type,
 * because all the hard work is done in the component type routines.
 * decode as a series of calls on the nested data types.
 */

/*
 * Xdr operations.  XDR_ENCODE causes the type to be encoded into the
 * stream.  XDR_DECODE causes the type to be extracted from the stream.
 * XDR_FREE can be used to release the space allocated by an XDR_DECODE
 * request.
 */
enum xdr_op {
	XDR_ENCODE=0,
	XDR_DECODE=1,
	XDR_FREE=2
};

/*
 * This is the number of bytes per unit of external data.
 */
#define BYTES_PER_XDR_UNIT	(4)
#define RNDUP(x)  ((((x) + BYTES_PER_XDR_UNIT - 1) / BYTES_PER_XDR_UNIT) \
		    * BYTES_PER_XDR_UNIT)


/*
 * This is the advance type definition required for xdrproc_t
 */
struct XDR;
#ifndef __cplusplus
typedef struct XDR XDR;
#endif

/*
 * A xdrproc_t exists for each data type which is to be encoded or decoded.
 *
 * The second argument to the xdrproc_t is a pointer to an opaque pointer.
 * The opaque pointer generally points to a structure of the data type
 * to be decoded.  If this pointer is 0, then the type routines should
 * allocate dynamic storage of the appropriate size and return it.
 * bool_t	(*xdrproc_t)(XDR *, caddr_t *);
 */


#ifdef __cplusplus
typedef bool_t (*xdrproc_t)(XDR *, void *);
#else
#ifdef __STDC__
typedef bool_t	(*xdrproc_t)(); /* For Backward compatibility */
#else
typedef	bool_t (*xdrproc_t)();
#endif
#endif

/*
 * The XDR handle.
 * Contains operation which is being applied to the stream,
 * an operations vector for the paticular implementation (e.g. see xdr_mem.c),
 * and two private fields for the use of the particular impelementation.
 */
struct XDR {
	enum xdr_op	x_op;		/* operation; fast additional param */
	struct xdr_ops {
#ifdef __STDC__
		bool_t	(*x_getlong)(struct XDR *, long *);
		/* get a long from underlying stream */
		bool_t	(*x_putlong)(struct XDR *, long *);
		/* put a long to " */
		bool_t	(*x_getbytes)(struct XDR *, caddr_t, int);
		/* get some bytes from " */
		bool_t	(*x_putbytes)(struct XDR *, caddr_t, int);
		/* put some bytes to " */
		u_int	(*x_getpostn)(struct XDR *);
		/* returns bytes off from beginning */
		bool_t  (*x_setpostn)(struct XDR *, u_int);
		/* lets you reposition the stream */
		long *	(*x_inline)(struct XDR *, int);
		/* buf quick ptr to buffered data */
		void	(*x_destroy)(struct XDR *);
#else
		bool_t	(*x_getlong)();	/* get a long from underlying stream */
		bool_t	(*x_putlong)();			  /* put a long to " */
		bool_t	(*x_getbytes)();	    /* get some bytes from " */
		bool_t	(*x_putbytes)();	/* put some bytes to " */
		u_int	(*x_getpostn)(); /* returns bytes off from beginning */
		bool_t  (*x_setpostn)();   /* lets you reposition the stream */
		long *	(*x_inline)();	   /* buf quick ptr to buffered data */
		void	(*x_destroy)();	 /* free privates of this xdr_stream */
#endif
	} *x_ops;
	caddr_t 	x_public;	/* users' data */
	caddr_t		x_private;	/* pointer to private data */
	caddr_t 	x_base;		/* private used for position info */
	int		x_handy;	/* extra private word */
};

/*
 * Operations defined on a XDR handle
 *
 * XDR		*xdrs;
 * long		*longp;
 * caddr_t	 addr;
 * u_int	 len;
 * u_int	 pos;
 */
#define XDR_GETLONG(xdrs, longp)			\
	(*(xdrs)->x_ops->x_getlong)(xdrs, longp)
#define xdr_getlong(xdrs, longp)			\
	(*(xdrs)->x_ops->x_getlong)(xdrs, longp)

#define XDR_PUTLONG(xdrs, longp)			\
	(*(xdrs)->x_ops->x_putlong)(xdrs, longp)
#define xdr_putlong(xdrs, longp)			\
	(*(xdrs)->x_ops->x_putlong)(xdrs, longp)

#define XDR_GETBYTES(xdrs, addr, len)			\
	(*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)
#define xdr_getbytes(xdrs, addr, len)			\
	(*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)

#define XDR_PUTBYTES(xdrs, addr, len)			\
	(*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)
#define xdr_putbytes(xdrs, addr, len)			\
	(*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)

#define XDR_GETPOS(xdrs)				\
	(*(xdrs)->x_ops->x_getpostn)(xdrs)
#define xdr_getpos(xdrs)				\
	(*(xdrs)->x_ops->x_getpostn)(xdrs)

#define XDR_SETPOS(xdrs, pos)				\
	(*(xdrs)->x_ops->x_setpostn)(xdrs, pos)
#define xdr_setpos(xdrs, pos)				\
	(*(xdrs)->x_ops->x_setpostn)(xdrs, pos)

#define	XDR_INLINE(xdrs, len)				\
	(*(xdrs)->x_ops->x_inline)(xdrs, len)
#define	xdr_inline(xdrs, len)				\
	(*(xdrs)->x_ops->x_inline)(xdrs, len)

#define	XDR_DESTROY(xdrs)				\
	if ((xdrs)->x_ops->x_destroy) 			\
		(*(xdrs)->x_ops->x_destroy)(xdrs)
#define	xdr_destroy(xdrs)				\
	if ((xdrs)->x_ops->x_destroy) 			\
		(*(xdrs)->x_ops->x_destroy)(xdrs)

/*
 * Support struct for discriminated unions.
 * You create an array of xdrdiscrim structures, terminated with
 * a entry with a null procedure pointer.  The xdr_union routine gets
 * the discriminant value and then searches the array of structures
 * for a matching value.  If a match is found the associated xdr routine
 * is called to handle that part of the union.  If there is
 * no match, then a default routine may be called.
 * If there is no match and no default routine it is an error.
 */
#define NULL_xdrproc_t ((xdrproc_t)0)
struct xdr_discrim {
	int	value;
	xdrproc_t proc;
};

/*
 * In-line routines for fast encode/decode of primitve data types.
 * Caveat emptor: these use single memory cycles to get the
 * data from the underlying buffer, and will fail to operate
 * properly if the data is not aligned.  The standard way to use these
 * is to say:
 *	if ((buf = XDR_INLINE(xdrs, count)) == NULL)
 *		return (FALSE);
 *	<<< macro calls >>>
 * where ``count'' is the number of bytes of data occupied
 * by the primitive data types.
 *
 * N.B. and frozen for all time: each data type here uses 4 bytes
 * of external representation.
 */
#define IXDR_GET_LONG(buf)		((long)ntohl((u_long)*(buf)++))
#define IXDR_PUT_LONG(buf, v)		(*(buf)++ = (long)htonl((u_long)v))

#define IXDR_GET_BOOL(buf)		((bool_t)IXDR_GET_LONG(buf))
#define IXDR_GET_ENUM(buf, t)		((t)IXDR_GET_LONG(buf))
#define IXDR_GET_U_LONG(buf)		((u_long)IXDR_GET_LONG(buf))
#define IXDR_GET_SHORT(buf)		((short)IXDR_GET_LONG(buf))
#define IXDR_GET_U_SHORT(buf)		((u_short)IXDR_GET_LONG(buf))

#define IXDR_PUT_BOOL(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
#define IXDR_PUT_ENUM(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
#define IXDR_PUT_U_LONG(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
#define IXDR_PUT_SHORT(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
#define IXDR_PUT_U_SHORT(buf, v)	IXDR_PUT_LONG((buf), ((long)(v)))

/*
 * These are the "generic" xdr routines.
 */
#ifdef __STDC__
extern bool_t	xdr_void(void);
extern bool_t	xdr_int(XDR *, int *);
extern bool_t	xdr_u_int(XDR *, u_int *);
extern bool_t	xdr_long(XDR *, long *);
extern bool_t	xdr_u_long(XDR *, u_long *);
extern bool_t	xdr_int64_t(XDR *, int64_t *);
extern bool_t	xdr_u_int64_t(XDR *, u_int64_t *);
extern bool_t	xdr_short(XDR *, short *);
extern bool_t	xdr_u_short(XDR *, u_short *);
extern bool_t	xdr_bool(XDR *, bool_t *);
extern bool_t	xdr_enum(XDR *, enum_t *);
extern bool_t	xdr_array(XDR *, caddr_t *, u_int *, const u_int,
		    const u_int, const xdrproc_t);
extern bool_t	xdr_bytes(XDR *, char **, u_int *, const u_int);
extern bool_t	xdr_opaque(XDR *, caddr_t, const u_int);
extern bool_t	xdr_string(XDR *, char **, const u_int);
extern bool_t	xdr_union(XDR *, enum_t *, char *,
		    const struct xdr_discrim *, const xdrproc_t);
extern bool_t	xdr_char(XDR *, char *);

extern bool_t	xdr_u_char(XDR *, u_char *);
extern bool_t	xdr_vector(XDR *, char *, const u_int, const u_int, const
xdrproc_t);
extern bool_t	xdr_float(XDR *, float *);
extern bool_t	xdr_double(XDR *, double *);
extern bool_t	xdr_reference(XDR *, caddr_t *, u_int, const xdrproc_t);
extern bool_t	xdr_pointer(XDR *, char **, u_int, const xdrproc_t);
extern bool_t	xdr_wrapstring(XDR *, char **);
extern void     xdr_free(xdrproc_t proc, void *objp);
#else
extern bool_t	xdr_void();
extern bool_t	xdr_int();
extern bool_t	xdr_u_int();
extern bool_t	xdr_long();
extern bool_t	xdr_u_long();
extern bool_t	xdr_int64_t();
extern bool_t	xdr_u_int64_t();
extern bool_t	xdr_short();
extern bool_t	xdr_u_short();
extern bool_t	xdr_bool();
extern bool_t	xdr_enum();
extern bool_t	xdr_array();
extern bool_t	xdr_bytes();
extern bool_t	xdr_opaque();
extern bool_t	xdr_string();
extern bool_t	xdr_union();
extern bool_t	xdr_char();
extern bool_t	xdr_u_char();
extern bool_t	xdr_vector();
extern bool_t	xdr_float();
extern bool_t	xdr_double();
extern bool_t	xdr_reference();
extern bool_t	xdr_pointer();
extern bool_t	xdr_wrapstring();
extern void     xdr_free();
#endif

/*
 * Common opaque bytes objects used by many rpc protocols;
 * declared here due to commonality.
 */
#define MAX_NETOBJ_SZ 1024
struct netobj {
	u_int	n_len;
	char	*n_bytes;
};
typedef struct netobj netobj;
#ifdef __STDC__
extern bool_t   xdr_netobj(XDR *, netobj *);
#else
extern bool_t   xdr_netobj();
#endif

/*
 * These are the public routines for the various implementations of
 * xdr streams.
 */
#ifdef __STDC__
extern void   xdrmem_create(XDR *, const caddr_t, const u_int, const enum
xdr_op);
	/* XDR using memory buffers */
extern void   xdrstdio_create(XDR *, FILE *, const enum xdr_op);
/* XDR using stdio library */
extern void   xdrrec_create(XDR *, const u_int, const u_int, const caddr_t,
int (*) (void *, caddr_t, int), int (*) (void *, caddr_t, int));
/* XDR pseudo records for tcp */
extern bool_t xdrrec_endofrecord(XDR *, bool_t);
/* make end of xdr record */
extern bool_t xdrrec_skiprecord(XDR *);
/* move to beginning of next record */
extern bool_t xdrrec_eof(XDR *);
/* true if no more input */
#else
extern void   xdrmem_create();
extern void   xdrstdio_create();
extern void   xdrrec_create();
extern bool_t xdrrec_endofrecord();
extern bool_t xdrrec_skiprecord();
extern bool_t xdrrec_eof();
#endif

#endif

/* EOF xdr.h */
@


4.4
log
@  Fixed rpc/svc.h to be ANSI and C++ compatible.
Detail:
  rpc/rpc.h now wraps all the sub-includes with C++ protection.
  rpc/svc.h prototypes ANSI-ised (rpc/rpc.h includes it, so despite services
    not being supported under RISC OS, it still needs to be there)
  rpc/xdr.h declares struct XDR as equivalent to XDR.
Admin:
  At least this version is required by code generated by rpcgen.

Version 5.05. Tagged as 'TCPIPLibs-5_05'
@
text
@d277 2
d307 2
@


4.3
log
@  Prototypes upgraded to ANSI-style.  This is required so that C++ source code
    can include them (third party needs this)
  Removed duplicate headers from inside rpclib - now uses the exported headers
    which should avoid inconsistencies developing.
  No longer uses cc400 during builds.
Detail:
  Nearly every header is changed.  Parameter prototypes cross-checked against
    actual source code, Solaris 2.6 headers, and comments in the rpclib headers.
  Build improvement: no longer uses "cc400" to compile clnt_udp.c.  Previously
    this was done because newer compilers were alleged to generate broken code.
    The example quoted was the NFS module's free display.  The fault actually
    lies in the NFS module passing the wrong parameters to xdr_string!  Future
    builds of NFS will require TCPIPLibs-5_04 or later.
Admin:
  Built.  Tested by building NFS against it.  Verified free space display works
    properly (needs NFS 2.36).  Tested inclusion of all RPC headers from C++
    source file worked without warnings or errors.

Version 5.04. Tagged as 'TCPIPLibs-5_04'
@
text
@d99 9
d117 2
a118 2
struct _xdr_structure;
typedef struct _xdr_structure XDR;
d135 1
a135 1
struct _xdr_structure {
@


4.2
log
@Spinner branch merged.
$Id, $Source and $Header markers removed.
@
text
@d8 1
a8 1
 * 
d19 1
a19 1
 * 
d23 1
a23 1
 * 
d27 1
a27 1
 * 
d31 1
a31 1
 * 
d35 1
a35 1
 * 
d108 8
d117 2
d126 1
a126 1
typedef struct {
d129 17
d147 8
a154 7
		bool_t	(*x_putlong)();	/* put a long to " */
		bool_t	(*x_getbytes)();/* get some bytes from " */
		bool_t	(*x_putbytes)();/* put some bytes to " */
		u_int	(*x_getpostn)();/* returns bytes off from beginning */
		bool_t  (*x_setpostn)();/* lets you reposition the stream */
		long *	(*x_inline)();	/* buf quick ptr to buffered data */
		void	(*x_destroy)();	/* free privates of this xdr_stream */
d160 1
a160 1
} XDR;
d262 29
d313 2
d320 1
a320 1
#define MAX_NETOBJ_SZ 1024 
d326 3
d330 1
d336 23
a358 6
extern void   xdrmem_create();		/* XDR using memory buffers */
extern void   xdrstdio_create();	/* XDR using stdio library */
extern void   xdrrec_create();		/* XDR pseudo records for tcp */
extern bool_t xdrrec_endofrecord();	/* make end of xdr record */
extern bool_t xdrrec_skiprecord();	/* move to beginning of next record */
extern bool_t xdrrec_eof();		/* true if no more input */
d360 1
a360 1
#endif !__XDR_HEADER__
@


4.1
log
@Initial revision
@
text
@a2 3
 * $Header: /ax/networking:include/rpc/xdr.h:networking  1.1  $
 * $Source: /ax/networking:include/rpc/xdr.h: $
 *
@


4.1.7.1
log
@Imported from Babel
@
text
@@

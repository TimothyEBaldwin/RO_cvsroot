head	4.8;
access;
symbols
	TCPIPLibs-5_66:4.8
	TCPIPLibs-5_65:4.7
	TCPIPLibs-5_64:4.7
	TCPIPLibs-5_63:4.7
	TCPIPLibs-5_62:4.7
	TCPIPLibs-5_61:4.7
	TCPIPLibs-5_60:4.7
	TCPIPLibs-5_59:4.7
	TCPIPLibs-5_58:4.7
	TCPIPLibs-5_57:4.7
	TCPIPLibs-5_56:4.7
	TCPIPLibs-5_55:4.7
	TCPIPLibs-5_54:4.7
	TCPIPLibs-5_53:4.7
	TCPIPLibs-5_52:4.7
	TCPIPLibs-5_51:4.7
	TCPIPLibs-5_50:4.7
	TCPIPLibs-5_49:4.7
	RO_5_07:4.7
	TCPIPLibs-5_48:4.7
	TCPIPLibs-5_47:4.7
	TCPIPLibs-5_46:4.7
	TCPIPLibs-5_45:4.7
	TCPIPLibs-5_44:4.6
	TCPIPLibs-5_43:4.6
	TCPIPLibs-5_42:4.6
	TCPIPLibs-5_41:4.6
	TCPIPLibs-5_40:4.6
	TCPIPLibs-5_39:4.6
	dellis_autobuild_BaseSW:4.6
	TCPIPLibs-5_38:4.6
	TCPIPLibs-5_37:4.6
	TCPIPLibs-5_36:4.6
	sbrodie_sedwards_16Mar2000:4.6
	TCPIPLibs-5_35:4.6
	TCPIPLibs-5_34:4.6
	TCPIPLibs-5_33:4.6
	TCPIPLibs-5_32:4.6
	TCPIPLibs-5_31:4.6
	dcotton_autobuild_BaseSW:4.6
	TCPIPLibs-5_30:4.6
	TCPIPLibs-5_29:4.6
	TCPIPLibs-5_28:4.6
	TCPIPLibs-5_27:4.6
	TCPIPLibs-5_26:4.6
	TCPIPLibs-5_25:4.6
	TCPIPLibs-5_24:4.6
	TCPIPLibs-5_23:4.6
	TCPIPLibs-5_22:4.5
	TCPIPLibs-5_21:4.5
	TCPIPLibs-5_20:4.5
	TCPIPLibs-5_19:4.5
	TCPIPLibs-5_18:4.5
	TCPIPLibs-5_17:4.5
	TCPIPLibs-5_16:4.4
	TCPIPLibs-5_15:4.3
	TCPIPLibs-5_14:4.3
	TCPIPLibs-5_13:4.3
	TCPIPLibs-5_12:4.3
	TCPIPLibs-5_11:4.3
	TCPIPLibs-5_10:4.3
	TCPIPLibs-5_09:4.2
	TCPIPLibs-5_08:4.2
	TCPIPLibs-5_07:4.2
	TCPIPLibs-5_06:4.2
	TCPIPLibs-5_05:4.2
	TCPIPLibs-5_04:4.2
	TCPIPLibs-5_03:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.10
	TCPIPLibs-5_02:4.1
	TCPIPLibs-5_01:4.1
	nicke_TCPIPLibs_25-9-98:4.1
	TCPIPLibs-5_00:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	Spinner:4.1
	Internet_5_07:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Ursula_19May1998_bp:4.1
	Ursula_19May1998:4.1.0.8
	rthornb_UrsulaBuild_01May1998:4.1
	celkins_Internet_506:4.1
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Internet_505:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Spin_merge:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Spinner_B7:4.1.7.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.4
	RCA:4.1.0.2
	import:4.1.7.1;
locks; strict;
comment	@# @;


4.8
date	2018.08.25.19.53.44;	author rool;	state Exp;
branches;
next	4.7;
commitid	0Awdheg8IUUDtxPA;

4.7
date	2003.01.07.18.58.22;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.07.08.15.10.32;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.06.23.10.07.53;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.06.22.16.17.44;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.03.30.10.35.37;	author blaughto;	state Exp;
branches;
next	4.2;

4.2
date	98.11.25.19.31.18;	author celkins;	state Exp;
branches;
next	4.1;

4.1
date	97.03.06.14.27.39;	author rbuckley;	state Exp;
branches
	4.1.7.1;
next	;

4.1.7.1
date	97.03.06.14.27.39;	author rbuckley;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Add support for RFC2553
Detail:
  headers/net/if.h: new defines, structs, prototypes per RFC2553.
  headers/netdb.h: new defines, structs, prototypes per RFC2553 (from FreeBSD revision 102227).
  headers/sys/socket.h: portability sockaddr_storage struct, extend list of PF_ and AF_ defines (from FreeBSD revision 102227).
  headers/netinet/in.h: new defines, structs, prototypes per RFC2553 (from FreeBSD in6.h revision 102227)
  inetlib/if_indextoname.c
          if_nameindex.c
          if_nametoindex.c: import of new interface functions (from FreeBSD revision 100138).
          in6addr.c: constant structs for in6addr_any and in6addr_loopback per RFC2553.
          getnainfo.c: import of new function (from FreeBSD revision 158790).
          getipnode.c: new (with hostentdup based on _hpcopy from FreeBSD revision 103335).
          getadinfo.c: new (with portions based on FreeBSD revision 103640).
  LibraryDoc: updated with summaries of the new functions in Inetlib.
Admin:
  Test harness in test/rfc2553.c exercises most of the new functionality.
  Submission for TCP/IP bounty.

Version 5.66. Tagged as 'TCPIPLibs-5_66'
@
text
@/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if.h	8.1 (Berkeley) 6/10/93
 * FreeBSD: 1.54 1999/06/19 18:42:27
 */

#ifndef _NET_IF_H_
#define	_NET_IF_H_

/*
 * <net/if.h> does not depend on <sys/time.h> on most other systems.  This
 * helps userland compatability.  (struct timeval ifi_lastchange)
 */
#ifndef KERNEL
#include <sys/time.h>
#endif

/*
 * Length of interface external name, including terminating '\0'.
 * Note: this is the same size as a generic device's external name.
 */
#define		IF_NAMESIZE	16
#define		IFNAMSIZ	IF_NAMESIZE

/*
 * Structure describing information about an interface
 * which may be of interest to management entities.
 */
struct	if_data {
	/* generic interface information */
	u_char	ifi_type;		/* ethernet, tokenring, etc */
	u_char	ifi_physical; 		/* e.g., AUI, Thinnet, 10base-T, etc */
	u_char	ifi_addrlen;		/* media address length */
	u_char	ifi_hdrlen;		/* media header length */
	u_char	ifi_recvquota;		/* polling quota for receive intrs */
	u_char	ifi_xmitquota;		/* polling quota for xmit intrs */
	u_long	ifi_mtu;		/* maximum transmission unit */
	u_long	ifi_metric;		/* routing metric (external only) */
	u_long	ifi_baudrate;		/* linespeed */
	/* volatile statistics */
	u_long	ifi_ipackets;		/* packets received on interface */
	u_long	ifi_ierrors;		/* input errors on interface */
	u_long	ifi_opackets;		/* packets sent on interface */
	u_long	ifi_oerrors;		/* output errors on interface */
	u_long	ifi_collisions;		/* collisions on csma interfaces */
	u_long	ifi_ibytes;		/* total number of octets received */
	u_long	ifi_obytes;		/* total number of octets sent */
	u_long	ifi_imcasts;		/* packets received via multicast */
	u_long	ifi_omcasts;		/* packets sent via multicast */
	u_long	ifi_iqdrops;		/* dropped on input, this interface */
	u_long	ifi_noproto;		/* destined for unsupported protocol */
	u_long	ifi_recvtiming;		/* usec spent receiving when timing */
	u_long	ifi_xmittiming;		/* usec spent xmitting when timing */
	struct	timeval ifi_lastchange;	/* time of last administrative change */
};

#define IFF_UP		0x1		/* interface is up */
#define IFF_BROADCAST	0x2		/* broadcast address valid */
#define IFF_DEBUG	0x4		/* turn on debugging */
#define IFF_LOOPBACK	0x8		/* is a loopback net */
#define IFF_POINTOPOINT 0x10		/* interface is point-to-point link */
#define	IFF_SMART	0x20		/* interface manages own routes */
#define IFF_RUNNING	0x40		/* resources allocated */
#define IFF_NOARP	0x80		/* no address resolution protocol */
#define IFF_PROMISC	0x100		/* receive all packets */
#define IFF_ALLMULTI	0x200		/* receive all multicast packets */
#define	IFF_OACTIVE	0x400		/* transmission in progress */
#define	IFF_SIMPLEX	0x800		/* can't hear own transmissions */
#define	IFF_LINK0	0x1000		/* per link layer defined bit */
#define	IFF_LINK1	0x2000		/* per link layer defined bit */
#define	IFF_LINK2	0x4000		/* per link layer defined bit */
#define	IFF_ALTPHYS	IFF_LINK2	/* use alternate physical connection */
#define	IFF_MULTICAST	0x8000		/* supports multicast */

#ifdef __riscos
/*
 * flags specific to RISC OS Internet driver
 */
# define IFF_SRCSUPPLIED 0x10000
# define IFF_NEED_IPADDR 0x20000
# define IFF_NEED_MASK	 0x40000
# define IFF_NODRIVER	 0x80000
/* flags set internally only: */
#define	IFF_CANTCHANGE \
	(IFF_BROADCAST|IFF_POINTOPOINT|IFF_RUNNING|IFF_OACTIVE|\
	    IFF_SIMPLEX|IFF_MULTICAST|IFF_ALLMULTI|IFF_SMART|\
	    IFF_SRCSUPPLIED|IFF_NEED_IPADDR|IFF_NEED_MASK|IFF_NODRIVER)
#else
/* flags set internally only: */
#define	IFF_CANTCHANGE \
	(IFF_BROADCAST|IFF_POINTOPOINT|IFF_RUNNING|IFF_OACTIVE|\
	    IFF_SIMPLEX|IFF_MULTICAST|IFF_ALLMULTI|IFF_SMART)
#endif

#define IFQ_MAXLEN	100		/* Increased from 50 CE - 981125 */
#define IFNET_SLOWHZ	1		/* granularity is 1 second */

/*
 * Message format for use in obtaining information about interfaces
 * from getkerninfo and the routing socket
 */
struct if_msghdr {
	u_short	ifm_msglen;	/* to skip over non-understood messages */
	u_char	ifm_version;	/* future binary compatability */
	u_char	ifm_type;	/* message type */
	int	ifm_addrs;	/* like rtm_addrs */
	int	ifm_flags;	/* value of if_flags */
	u_short	ifm_index;	/* index for associated ifp */
	struct	if_data ifm_data;/* statistics and other data about if */
};

/*
 * Message format for use in obtaining information about interface addresses
 * from getkerninfo and the routing socket
 */
struct ifa_msghdr {
	u_short	ifam_msglen;	/* to skip over non-understood messages */
	u_char	ifam_version;	/* future binary compatability */
	u_char	ifam_type;	/* message type */
	int	ifam_addrs;	/* like rtm_addrs */
	int	ifam_flags;	/* value of ifa_flags */
	u_short	ifam_index;	/* index for associated ifp */
	int	ifam_metric;	/* value of ifa_metric */
};

/*
 * Message format for use in obtaining information about multicast addresses
 * from the routing socket
 */
struct ifma_msghdr {
	u_short	ifmam_msglen;	/* to skip over non-understood messages */
	u_char	ifmam_version;	/* future binary compatability */
	u_char	ifmam_type;	/* message type */
	int	ifmam_addrs;	/* like rtm_addrs */
	int	ifmam_flags;	/* value of ifa_flags */
	u_short	ifmam_index;	/* index for associated ifp */
};

/*
 * Interface request structure used for socket
 * ioctl's.  All interface ioctl's must have parameter
 * definitions which begin with ifr_name.  The
 * remainder may be interface specific.
 */
struct	ifreq {
	char	ifr_name[IFNAMSIZ];		/* if name, e.g. "en0" */
	union {
		struct	sockaddr ifru_addr;
		struct	sockaddr ifru_dstaddr;
		struct	sockaddr ifru_broadaddr;
		short	ifru_flags[2];
		int	ifru_metric;
		int	ifru_mtu;
		int	ifru_phys;
		int	ifru_media;
		caddr_t ifru_data;
	} ifr_ifru;
#define ifr_addr	ifr_ifru.ifru_addr	/* address */
#define ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-to-p link */
#define ifr_broadaddr	ifr_ifru.ifru_broadaddr /* broadcast address */
#define	ifr_flags	ifr_ifru.ifru_flags[0]	/* flags */
#define	ifr_prevflags	ifr_ifru.ifru_flags[1]	/* flags */
#define ifr_metric	ifr_ifru.ifru_metric	/* metric */
#define	ifr_mtu		ifr_ifru.ifru_mtu	/* mtu */
#define ifr_phys	ifr_ifru.ifru_phys	/* physical wire */
#define ifr_media	ifr_ifru.ifru_media	/* physical media */
#define ifr_data	ifr_ifru.ifru_data	/* for use by interface */
};

#ifdef COMPAT_INET4
struct	nifreq {
#else
struct	oifreq {
#endif
	char	ifr_name[IFNAMSIZ];		/* if name, e.g. "en0" */
	union {
#ifdef COMPAT_INET4
		struct	nsockaddr ifru_addr;
		struct	nsockaddr ifru_dstaddr;
		struct	nsockaddr ifru_broadaddr;
#else
		struct	osockaddr ifru_addr;
		struct	osockaddr ifru_dstaddr;
		struct	osockaddr ifru_broadaddr;
#endif
		short	ifru_flags[2];
		int	ifru_metric;
		int	ifru_mtu;
		int	ifru_phys;
		int	ifru_media;
		caddr_t ifru_data;
	} ifr_ifru;
};

#define	_SIZEOF_ADDR_IFREQ(ifr) \
	((ifr).ifr_addr.sa_len > sizeof(struct sockaddr) ? \
	 (sizeof(struct ifreq) - sizeof(struct sockaddr) + \
	  (ifr).ifr_addr.sa_len) : sizeof(struct ifreq))

struct ifaliasreq {
	char	ifra_name[IFNAMSIZ];		/* if name, e.g. "en0" */
#ifdef COMPAT_INET4
	struct	nsockaddr ifra_addr;
	struct	nsockaddr ifra_broadaddr;
	struct	nsockaddr ifra_mask;
#else
	struct	sockaddr ifra_addr;
	struct	sockaddr ifra_broadaddr;
	struct	sockaddr ifra_mask;
#endif
};

struct ifmediareq {
	char	ifm_name[IFNAMSIZ];	/* if name, e.g. "en0" */
	int	ifm_current;		/* current media options */
	int	ifm_mask;		/* don't care mask */
	int	ifm_status;		/* media status */
	int	ifm_active;		/* active options */
	int	ifm_count;		/* # entries in ifm_ulist array */
	int	*ifm_ulist;		/* media words */
};

/*
 * Structure used to retrieve aux status data from interfaces.
 * kernel suppliers to this interface should respect the formatting
 * needed by ifconfig(8): each line starts with a TAB and ends with
 * a newline.  The canonical example to copy&past is in if_tun.c
 */

#define IFSTATMAX	800		/* 10 lines of text */
struct ifstat {
	char	ifs_name[IFNAMSIZ];		/* if name, e.g. "en0" */
	char ascii[IFSTATMAX+1];
};

/*
 * Structure used in SIOCGIFCONF request.
 * Used to retrieve interface configuration
 * for machine (useful for programs which
 * must know all networks accessible).
 */
struct	ifconf {
	int	ifc_len;		/* size of associated buffer */
	union {
		caddr_t ifcu_buf;
		struct	ifreq *ifcu_req;
	} ifc_ifcu;
#define ifc_buf ifc_ifcu.ifcu_buf	/* buffer address */
#define ifc_req ifc_ifcu.ifcu_req	/* array of structures returned */
};

#ifdef COMPAT_INET4
struct	nifconf {
	int	ifc_len;		/* size of associated buffer */
	union {
		caddr_t ifcu_buf;
		struct	nifreq *ifcu_req;
	} ifc_ifcu;
};
#else
struct	oifconf {
	int	ifc_len;		/* size of associated buffer */
	union {
		caddr_t ifcu_buf;
		struct	oifreq *ifcu_req;
	} ifc_ifcu;
};
#endif

#ifdef KERNEL
#ifdef MALLOC_DECLARE
MALLOC_DECLARE(M_IFADDR);
MALLOC_DECLARE(M_IFMADDR);
#endif
#endif

#ifdef KERNEL
#include <net/if_var.h>
#else
struct if_nameindex {
	unsigned int	if_index;	/* 1, 2, ... */
	char		*if_name;	/* null terminated name: "le0", ... */
};

void			 if_freenameindex(struct if_nameindex *);
char			*if_indextoname(unsigned int, char *);
struct if_nameindex	*if_nameindex(void);
unsigned int		 if_nametoindex(const char *);
#endif

#endif /* !_NET_IF_H_ */
@


4.7
log
@Addition of 1000 base T and fibre magic constant to DCI spec.
Addition of support for HAL timers
Removed a lingering __P in the resolver header file (and while we're
at it all the others).
Added missing open bracket to vn_opn,reported by D.Ellis.

Version 5.45. Tagged as 'TCPIPLibs-5_45'
@
text
@d49 7
a175 1
#define IFNAMSIZ	16
a307 5
#ifndef __riscos
struct proc;
int	prison_if(struct proc *p, struct sockaddr *sa);
/* XXX - this should go away soon */
#endif
d309 10
@


4.6
log
@Assorted changes from FreeBSD. Might be some slight compatibility hiccoughs
with some sources - might need to #include a bit more before <net/if.h>.

Version 5.23. Tagged as 'TCPIPLibs-5_23'
@
text
@d304 1
a304 1
int	prison_if __P((struct proc *p, struct sockaddr *sa));
@


4.5
log
@if_multiaddrs moved to end of struct ifnet to save binary compatibility
grief with all those horrid little progs like inetstat and ifconfig that
inspect the Internet module's internal structures directly.

Version 5.17. Tagged as 'TCPIPLibs-5_17'
@
text
@d34 1
d41 2
a42 22
 * Structures defining a network interface, providing a packet
 * transport mechanism (ala level 0 of the PUP protocols).
 *
 * Each interface accepts output datagrams of a specified maximum
 * length, and provides higher level routines with input datagrams
 * received from its medium.
 *
 * Output occurs when the routine if_output is called, with three parameters:
 *	(*ifp->if_output)(ifp, m, dst, rt)
 * Here m is the mbuf chain to be sent and dst is the destination address.
 * The output routine encapsulates the supplied datagram if necessary,
 * and then transmits it on its medium.
 *
 * On input, each interface unwraps the data received by it, and either
 * places it on the input queue of a internetwork datagram routine
 * and posts the associated software interrupt, or passes the datagram to a raw
 * packet input routine.
 *
 * Routines exist for locating interfaces by their addresses
 * or for locating a interface on a certain network, as well as more general
 * routing and gateway routines maintaining information used to locate
 * interfaces.  These routines live in the files if.c and route.c
d44 1
a44 4

#include <sys/socket.h>			/* for struct sockaddr */

#ifndef _TIME_ /*  XXX fast fix for SNMP, going away soon */
a48 8
 * Forward structure declarations for function prototypes [sic].
 */
struct	mbuf;
struct	proc;
struct	rtentry;
struct	socket;
struct	ether_header;
/*
d54 9
a62 7
	u_char	ifi_type;	/* ethernet, tokenring, etc */
	u_char	ifi_physical; 	/* e.g., AUI, Thinnet, 10base-T, etc */
	u_char	ifi_addrlen;	/* media address length */
	u_char	ifi_hdrlen;	/* media header length */
	u_long	ifi_mtu;	/* maximum transmission unit */
	u_long	ifi_metric;	/* routing metric (external only) */
	u_long	ifi_baudrate;	/* linespeed */
d64 14
a77 12
	u_long	ifi_ipackets;	/* packets received on interface */
	u_long	ifi_ierrors;	/* input errors on interface */
	u_long	ifi_opackets;	/* packets sent on interface */
	u_long	ifi_oerrors;	/* output errors on interface */
	u_long	ifi_collisions;	/* collisions on csma interfaces */
	u_long	ifi_ibytes;	/* total number of octets received */
	u_long	ifi_obytes;	/* total number of octets sent */
	u_long	ifi_imcasts;	/* packets received via multicast */
	u_long	ifi_omcasts;	/* packets sent via multicast */
	u_long	ifi_iqdrops;	/* dropped on input, this interface */
	u_long	ifi_noproto;	/* destined for unsupported protocol */
	struct	timeval ifi_lastchange;/* last updated */
a79 83
#ifdef __riscos
/*
 * Structure defining list of multicast addresses we've requested
 * from the DCI driver.
 */
struct if_multi {
	struct if_multi	*ifm_next;
	struct sockaddr	ifm_addr;
	u_int		ifm_refcount;
};
#endif

/*
 * Structure defining a queue for a network interface.
 *
 * (Would like to call this struct ``if'', but C isn't PL/1.)
 */
struct ifnet {
	unsigned if_swibase;		/* base of driver's SWI chunk */
	void	*if_dib;		/* pointer to struct dib for unit */
	char	*if_name;		/* name, e.g. ``en'' or ``lo'' */
	struct	ifnet *if_next;		/* all struct ifnets are chained */
	struct	ifaddr *if_addrlist;	/* linked list of addresses per if */
        int	if_pcount;		/* number of promiscuous listeners */
	caddr_t	if_bpf;			/* packet filter structure */
	u_short	if_index;		/* numeric abbreviation for this if  */
	short	if_unit;		/* sub-unit for lower level driver */
#ifdef __riscos
	int	if_timer;		/* time 'til if_watchdog called */
	int	if_flags;		/* up/down, broadcast, etc. */
#else
	short	if_timer;		/* time 'til if_watchdog called */
	short	if_flags;		/* up/down, broadcast, etc. */
#endif
	struct	if_data if_data;
/* procedure handles */
	int	(*if_init)		/* init routine */
		(int);
	int	(*if_output)		/* output routine */
		(struct ifnet *, struct mbuf *, struct sockaddr *,
		 struct rtentry *);
	void	(*if_start)		/* initiate output routine */
		(struct ifnet *);
	int	(*if_done)		/* output complete routine */
		(struct ifnet *);	/* (XXX not used; fake prototype) */
	int	(*if_ioctl)		/* ioctl routine */
		(struct ifnet *, int, caddr_t);
	void	(*if_reset)
		(int);			/* new autoconfig will permit removal */
	void	(*if_watchdog)		/* timer routine */
		(int);
	struct	ifqueue {
		struct	mbuf *ifq_head;
		struct	mbuf *ifq_tail;
		int	ifq_len;
		int	ifq_maxlen;
		int	ifq_drops;
	} if_snd;			/* output queue */
#ifdef __riscos
	struct	if_multi *if_multiaddrs;/* list of claimed addresses */
#endif
};
#define	if_mtu		if_data.ifi_mtu
#define	if_type		if_data.ifi_type
#define if_physical	if_data.ifi_physical
#define	if_addrlen	if_data.ifi_addrlen
#define	if_hdrlen	if_data.ifi_hdrlen
#define	if_metric	if_data.ifi_metric
#define	if_baudrate	if_data.ifi_baudrate
#define	if_ipackets	if_data.ifi_ipackets
#define	if_ierrors	if_data.ifi_ierrors
#define	if_opackets	if_data.ifi_opackets
#define	if_oerrors	if_data.ifi_oerrors
#define	if_collisions	if_data.ifi_collisions
#define	if_ibytes	if_data.ifi_ibytes
#define	if_obytes	if_data.ifi_obytes
#define	if_imcasts	if_data.ifi_imcasts
#define	if_omcasts	if_data.ifi_omcasts
#define	if_iqdrops	if_data.ifi_iqdrops
#define	if_noproto	if_data.ifi_noproto
#define	if_lastchange	if_data.ifi_lastchange
#define if_rawoutput(if, m, sa) if_output(if, m, sa, (struct rtentry *)0)

d85 1
a85 1
#define IFF_NOTRAILERS	0x20		/* avoid use of trailers */
d109 2
a110 2
	    IFF_SIMPLEX|IFF_MULTICAST|IFF_ALLMULTI|IFF_SRCSUPPLIED|\
	    IFF_NEED_IPADDR|IFF_NEED_MASK|IFF_NODRIVER)
d115 1
a115 1
	    IFF_SIMPLEX|IFF_MULTICAST|IFF_ALLMULTI)
a117 44

/*
 * These really don't belong here, but there's no other obviously appropriate
 * location.
 */
#define IFP_AUI		0
#define IFP_10BASE2	1
#define IFP_10BASET	2
/* etc. */

/*
 * Output queues (ifp->if_snd) and internetwork datagram level (pup level 1)
 * input routines have queues of messages stored on ifqueue structures
 * (defined above).  Entries are added to and deleted from these structures
 * by these macros, which should be called with ipl raised to splimp().
 */
#define IF_QFULL(ifq)		((ifq)->ifq_len >= (ifq)->ifq_maxlen)
#define IF_DROP(ifq)		((ifq)->ifq_drops++)
#define IF_ENQUEUE(ifq, m) { \
	(m)->m_nextpkt = 0; \
	if ((ifq)->ifq_tail == 0) \
		(ifq)->ifq_head = m; \
	else \
		(ifq)->ifq_tail->m_nextpkt = m; \
	(ifq)->ifq_tail = m; \
	(ifq)->ifq_len++; \
}
#define IF_PREPEND(ifq, m) { \
	(m)->m_nextpkt = (ifq)->ifq_head; \
	if ((ifq)->ifq_tail == 0) \
		(ifq)->ifq_tail = (m); \
	(ifq)->ifq_head = (m); \
	(ifq)->ifq_len++; \
}
#define IF_DEQUEUE(ifq, m) { \
	(m) = (ifq)->ifq_head; \
	if (m) { \
		if (((ifq)->ifq_head = (m)->m_nextpkt) == 0) \
			(ifq)->ifq_tail = 0; \
		(m)->m_nextpkt = 0; \
		(ifq)->ifq_len--; \
	} \
}

a121 24
 * The ifaddr structure contains information about one address
 * of an interface.  They are maintained by the different address families,
 * are allocated and attached when an address is set, and are linked
 * together so all addresses for an interface can be located.
 */
struct ifaddr {
	struct	sockaddr *ifa_addr;	/* address of interface */
	struct	sockaddr *ifa_dstaddr;	/* other end of p-to-p link */
#define	ifa_broadaddr	ifa_dstaddr	/* broadcast address interface */
	struct	sockaddr *ifa_netmask;	/* used to determine subnet */
	struct	ifnet *ifa_ifp;		/* back-pointer to interface */
	struct	ifaddr *ifa_next;	/* next address for interface */
	void	(*ifa_rtrequest)	/* check or clean routes (+ or -)'d */
		(int, struct rtentry *, struct sockaddr *);
	u_short	ifa_flags;		/* mostly rt_flags for cloning */
	short	ifa_refcnt;		/* extra to malloc for link info */
	int	ifa_metric;		/* cost of going out this interface */
#ifdef notdef
	struct	rtentry *ifa_rt;	/* XXXX for ROUTETOIF ????? */
#endif
};
#define	IFA_ROUTE	RTF_UP		/* route installed */

/*
d150 13
d175 1
a175 1
		short	ifru_flags;
d179 1
d185 2
a186 1
#define ifr_flags	ifr_ifru.ifru_flags	/* flags */
d190 1
d210 1
a210 1
		short	ifru_flags;
d214 1
d219 5
d237 23
a293 2
#include <net/if_arp.h>

d295 3
a297 22
#define	IFAFREE(ifa) \
	if ((ifa)->ifa_refcnt <= 0) \
		ifafree(ifa); \
	else \
		(ifa)->ifa_refcnt--;

extern struct	ifnet	*ifnet;
extern struct	ifnet	loif[];

void	ether_ifattach(struct ifnet *);
void	ether_input(struct ifnet *, struct ether_header *, struct mbuf *);
int	ether_output(struct ifnet *,
	   struct mbuf *, struct sockaddr *, struct rtentry *);
char	*ether_sprintf(u_char *);

void	if_attach(struct ifnet *);
void	if_down(struct ifnet *);
void	if_qflush(struct ifqueue *);
void	if_slowtimo(void *);
void	if_up(struct ifnet *);
#ifdef vax
void	ifubareset(int);
a298 6
int	ifconf(int, caddr_t);
/*void	ifinit(void);*/ /* declared in systm.h for main() */
#ifdef __riscos
int	ifioctl(struct socket *, int, caddr_t);
#else
int	ifioctl(struct socket *, int, caddr_t, struct proc *);
a299 2
int	ifpromisc(struct ifnet *, int);
struct	ifnet *ifunit(char *);
d301 7
a307 25
struct	ifaddr *ifa_ifwithaddr(struct sockaddr *);
struct	ifaddr *ifa_ifwithaf(int);
struct	ifaddr *ifa_ifwithdstaddr(struct sockaddr *);
struct	ifaddr *ifa_ifwithnet(struct sockaddr *);
struct	ifaddr *ifa_ifwithroute(int, struct sockaddr *,
					struct sockaddr *);
struct	ifaddr *ifaof_ifpforaddr(struct sockaddr *, struct ifnet *);
void	ifafree(struct ifaddr *);
void	link_rtrequest(int, struct rtentry *, struct sockaddr *);

int	loioctl(struct ifnet *, int, caddr_t);
void	loopattach(void);
int	looutput(struct ifnet *,
	   struct mbuf *, struct sockaddr *, struct rtentry *);
void	lortrequest(int, struct rtentry *, struct sockaddr *);
#endif /* KERNEL */


#ifdef __riscos
/* whoami.whoami.c */
/* whether a Net module variant is using us and whether client or Gateway */
#define AUN_INACTIVE 0
#define AUN_CLIENT   1
#define AUN_GATEWAY  2
extern int AUN_state;
@


4.4
log
@Added if_multiaddrs member to struct ifnet to allow Internet module to keep
track of required multicast addresses. Similar to ac_multiaddrs in struct
arpcom, but we require logical addresses, not just MAC addresses, for DCI.

Version 5.16. Tagged as 'TCPIPLibs-5_16'
@
text
@a135 1
	struct	if_multi *if_multiaddrs;/* list of claimed addresses */
d164 3
@


4.3
log
@Summary
    Updated net/if.h and sys/mbuf.h to work when used with C++.
Detail
    In net/if.h struct if_data was defined within struct ifnet, but also
    referred to later outside of struct ifnet.  This is fine in C since
    the scope of strutures persists to the end of the translation unit, but
    in C++ it persists until the end of the block.

    This problem is solved by moving the definition of struct if_data out
    of struct ifnet and into the outermost level, as it is in the current
    FreeBSD sources.

    In sys/mbuf.h there were two defintions of struct mbuf; one was for ANSI C
    and one was for K&R C, and the appropriate one was chosen by testing whether
    __STDC__ was defined or not.  The ANSI C version of the structure has
    const members in it, which C++ does not allow unless the structure/class
    has a constructor (since const members can only be initialised in a
    constructor's initialiser-list).  The C++ standard says that use of
    __STDC__ is implementation defined, which means we can't rely on picking up
    the non-ANSI C version of the structure in C++ code.

    A third definition of the structure has been added, which is used if
    __cplusplus is defined.  It retains the const members, but declares a
    private constructor, which keeps the compiler happy with respect to the
    const members.  Under the terms of the C++ standard, this is still a
    'P.O.D.' (Plain Old Data) structure, so it is guaranteed to have the same
    storage layout as the C one.  In addition, the m_sys* members have been
    made private, since the client should never access these.
Admin
    Tested with the ATM driver to verify the the changes work with C++.
    Tested with PPP to ensure that things still work for C.
    Version incremented to 5.10 and tagged.

Version 5.10. Tagged as 'TCPIPLibs-5_10'
@
text
@d106 12
d136 1
@


4.2
log
@Increased default maximum size of interface receive queue from 50 to 100
entries, since this has been causing data to be discarded in STB systems.
@
text
@d82 24
d128 1
a128 23
	struct	if_data {
/* generic interface information */
		u_char	ifi_type;	/* ethernet, tokenring, etc */
		u_char	ifi_physical; 	/* e.g., AUI, Thinnet, 10base-T, etc */
		u_char	ifi_addrlen;	/* media address length */
		u_char	ifi_hdrlen;	/* media header length */
		u_long	ifi_mtu;	/* maximum transmission unit */
		u_long	ifi_metric;	/* routing metric (external only) */
		u_long	ifi_baudrate;	/* linespeed */
/* volatile statistics */
		u_long	ifi_ipackets;	/* packets received on interface */
		u_long	ifi_ierrors;	/* input errors on interface */
		u_long	ifi_opackets;	/* packets sent on interface */
		u_long	ifi_oerrors;	/* output errors on interface */
		u_long	ifi_collisions;	/* collisions on csma interfaces */
		u_long	ifi_ibytes;	/* total number of octets received */
		u_long	ifi_obytes;	/* total number of octets sent */
		u_long	ifi_imcasts;	/* packets received via multicast */
		u_long	ifi_omcasts;	/* packets sent via multicast */
		u_long	ifi_iqdrops;	/* dropped on input, this interface */
		u_long	ifi_noproto;	/* destined for unsupported protocol */
		struct	timeval ifi_lastchange;/* last updated */
	}	if_data;
@


4.1
log
@Initial revision
@
text
@d254 1
a254 1
#define IFQ_MAXLEN	50
@


4.1.7.1
log
@Imported from Babel
@
text
@@

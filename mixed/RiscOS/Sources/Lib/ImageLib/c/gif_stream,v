head	1.21;
access;
symbols
	ImageLib-0_09:1.21
	ImageLib-0_08:1.21
	ImageLib-0_07:1.21
	ImageLib-0_06:1.21
	ImageLib-0_05:1.21
	ImageLib-0_04:1.21
	ImageLib-0_03:1.21
	ImageLib-0_02:1.21
	ImageLib-0_01:1.21
	dcotton_autobuild_BaseSW:1.21
	ahodgkin_207release:1.21
	ahodgkin_206release:1.21
	ahodgkin_205release:1.20
	ahodgkin_133beta:1.19
	kbracey_126beta:1.18
	kbracey_AW97patch:1.18
	ahodgkin_AW97:1.16;
locks; strict;
comment	@# @;


1.21
date	98.06.17.09.43.24;	author kbracey;	state Exp;
branches;
next	1.20;

1.20
date	98.03.31.12.28.24;	author kbracey;	state Exp;
branches;
next	1.19;

1.19
date	97.11.06.18.00.48;	author kbracey;	state Exp;
branches;
next	1.18;

1.18
date	97.10.23.16.22.24;	author kbracey;	state Exp;
branches;
next	1.17;

1.17
date	97.10.21.15.47.20;	author kbracey;	state Exp;
branches;
next	1.16;

1.16
date	97.10.14.17.45.48;	author kbracey;	state Exp;
branches;
next	1.15;

1.15
date	97.10.08.12.35.37;	author kbracey;	state Exp;
branches;
next	1.14;

1.14
date	97.10.07.16.28.02;	author rleggett;	state Exp;
branches;
next	1.13;

1.13
date	97.10.07.09.49.43;	author kbracey;	state Exp;
branches;
next	1.12;

1.12
date	97.10.07.09.46.41;	author kbracey;	state Exp;
branches;
next	1.11;

1.11
date	97.09.23.14.17.14;	author kbracey;	state Exp;
branches;
next	1.10;

1.10
date	97.09.23.10.40.31;	author kbracey;	state Exp;
branches;
next	1.9;

1.9
date	97.09.22.15.40.45;	author kbracey;	state Exp;
branches;
next	1.8;

1.8
date	97.09.22.14.47.48;	author rleggett;	state Exp;
branches;
next	1.7;

1.7
date	97.09.18.15.49.00;	author dbrown;	state Exp;
branches;
next	1.6;

1.6
date	97.09.18.09.14.44;	author rleggett;	state Exp;
branches;
next	1.5;

1.5
date	97.09.12.13.20.32;	author rleggett;	state Exp;
branches;
next	1.4;

1.4
date	97.09.10.09.57.55;	author rleggett;	state Exp;
branches;
next	1.3;

1.3
date	97.09.05.13.17.04;	author rleggett;	state Exp;
branches;
next	1.2;

1.2
date	97.08.27.13.17.28;	author kbracey;	state Exp;
branches;
next	1.1;

1.1
date	97.07.21.12.24.31;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Fixed check for global colour table.
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*---------------------------------------------------------------------------------------------------------*/
/* File:    c.gif_stream                                                                                   */
/* Purpose: GIF plotting routines                                                                          */
/* Author:  Richard Leggett (adapted from Kevin Bracey's original GIF image library code)                  */
/* History: 03-Feb-97: RML: Created by chopping the relevant sections from KB's GIF image library code.    */
/*                          The idea is to turn this code into a module which will make use of the         */
/*                          direct to screen plotting code being developed alongside. As a result, a       */
/*                          fair ammount of KB's code has been cut, output has been directed to the        */
/*                          renderer code, rather than to a sprite, and the 'Image' structure (from        */
/*                          imagetrans) has been abandoned.                                                */
/*          04-Feb-97: RML: Added interface routines which are more like what the module routines will be. */
/*          11-Feb-97: RML: Added some (temporary) code to try and access multiple images in animated GIFs */
/*                          This involves some completely new code to read in GIF headers, extensions etc. */
/*                          (ie. not KB's routines), but old code still used for non animated GIFs.        */
/*          12-Feb-97: RML: Animated GIF code correctly identifies images.                                 */
/*          14-Feb-97: RML: More animated GIF stuff.                                                       */
/*          20-Feb-97: RML: More animated GIF stuff.                                                       */
/*          06-Mar-97: RML: Tidied up error handling, made functions return _kernel_oserrors               */
/*          13-Mar-97: RML: Fixed some flexy problems (lost anchors etc.)                                  */
/*          18-Mar-97: RML: Fixed bug where flex can get confused if picture is deleted before it has      */
/*                          finished being fetched.                                                        */
/*          25-Mar-97: RML: Fixed a bug with mutable_mask (interlaced + transparent images)                */
/*          11-Apr-97: RML: Implemented gradual loading of animated GIFs, via the load->state variable     */
/*                          which defines which stage of the decoding a particular animation is at.        */
/*          15-Apr-97: RML: Improved error trapping.                                                       */
/*          22-Apr-97: RML: Properly merged together animated and still GIF code so they are transparent   */
/*                          to the gifstream's client (ie. the c.gif component)                            */
/*          24-Apr-97: RML: Corrected bug which corrupted sprite palette on mode changes.                  */
/*          09-May-97: RML: Tidied up, removed a few redundant routines.                                   */
/*          23-May-97: RML: If IMAGE_FAST flag set, then only get first frame of an animation.             */
/*          27-Aug-97: KJB: mutable_mask was being set erroneously (checking for load->transparent != 0    */
/*                          rather than != -1).                                                            */
/*          09-Sep-97: RML: Made use of flex_set_budge to avoid stack problems on pre-RPC                  */
/*                          machines.                                                                      */
/*          18-Sep-97: RML: Added flex_deferred_compaction in gifstream_plot.                              */
/*          22-Sep-97: RML: Fixed problem with npixels not being updated sometimes in lzw decoder, so      */
/*                          imagelib thinks image is corrupted.                                            */
/*          22-Sep-97: KJB: Copes with there being no clear code at the start of the LZW stream.           */
/*          23-Sep-97: KJB: Would fail big-time if the LZW minimum code size wasn't the same as the global */
/*                          colour map size.                                                               */
/*                          Would restrict colour values to the size of the global colour map, so if an    */
/*                          image in an animated GIF had 128 colours while the global map had 64 colours,  */
/*                          it would fail (although this was masked by the above bug - as such an image    */
/*                          would necessarily have a minimum code size > the global colour map size).      */
/*                          Reduced memory usage by 32K per stream by turning the Prefix array into        */
/*                          shorts, and Suffix and OutCode into chars.                                     */
/*                          Fixed spelling of "colour" in various places.                                  */
/*                          Added support for the number of repeats field in the Netscape looping          */
/*                          extension.                                                                     */
/*          07-Oct-97: KJB: Ensured unnecessary debug code not put in unless TRACE defined.                */
/*                          Adjust screen size of a GIF if the first image doesn't fit.                    */
/*          07-Oct-97: RML: The background colour provided to render_animate_new_frame is now a palette    */
/*                          entry and not a palette index.                                                 */
/*          21-Oct-97: KJB: Optimised various stuff in Render.                                             */
/*                          Ignore screen size for GIF87 files.                                            */
/*          17-Jun-98: KJB: Fixed check for global colour table - would often fail if not present!         */
/*---------------------------------------------------------------------------------------------------------*/
/* To do :                                                                                                 */
/*     Can the other lzw routines be speeded up and have memory usage reduced? They're far more general    */
/*     purpose than these, and hence slower. Kind of ironic given that they're used for the direct         */
/*     plotting.                                                                                           */
/*---------------------------------------------------------------------------------------------------------*/


#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include "kernel.h"
#include "swis.h"
#include "wimp.h"
#include "imagetrans.h"
#include "internal.h"
#include "defines.h"
#include "datastruct.h"
#include "gif_stream.h"
#include "sprite.h"
#include "flex.h"
#include "lzw_comp.h"
#include "lzw_decomp.h"
#include "render.h"
#include "rml_misc.h"

/*---------------------------------------------------------------------------------------------------------*/

#define SKIPBYTE (dataptr++)
#define NEXTBYTE (*dataptr++)
#define EXTENSION     0x21
#define IMAGESEP      0x2c
#define TRAILER       0x3b

#define PutSpriteScaled 52
#define PutSpriteScaled_UseMask 0x08
#define PutSpriteScaled_UsePalette 0x10
#define PutSpriteScaled_WideTable 0x20
#define PutSpriteScaled_Dithered 0x40
#define GenerateTable_WideTable 0x10

#define MaxPics 256

#define gifError imgtrnsError

#define max(a, b) (a>b ? a : b)
#define min(a, b) (a<b ? a : b)

#define NETSCAPE_ID 1

#define State_ReadGifSignature      1
#define State_ReadScreenDescriptor  2
#define State_ReadGlobalColourMap   3
#define State_InventGlobalColourMap 4
#define State_ReadExtensionBlock    5
#define State_ReadImageDescriptor   6
#define State_ReadLocalColourMap    7
#define State_PreImageData          8
#define State_NoMoreFrames          9
#define State_ReportWriteLine       10
#define State_ReadApplicationExt    11
#define State_ReadGraphicControlExt 12
#define State_ReadDataBlock         13
#define State_ReadImageData         14
#define State_EndImageData          15

#define Type_InternalLZW     1
#define Type_AnimatedSprites 2

/*---------------------------------------------------------------------------------------------------------*/

static const int EGApalette[16][3] = {
  {0,0,0},       {0,0,128},     {0,128,0},     {0,128,128},
  {128,0,0},     {128,0,128},   {128,128,0},   {200,200,200},
  {100,100,100}, {100,100,255}, {100,255,100}, {100,255,255},
  {255,100,100}, {255,100,255}, {255,255,100}, {255,255,255} };


typedef struct gif_loaddata
{
    int         BitOffset,		    /* Bit Offset of next code                    */
                XC, YC,		            /* Output X and Y coords of current pixel     */
                Pass,			    /* Used by output routine if interlaced pic   */
                BitsPerPixel,		    /* Bits per pixel, read from GIF header       */
                ColourMapSize,		    /* number of colours                          */
                Background,		    /* background colour                          */
                CodeSize,		    /* Code size, read from GIF header            */
                InitCodeSize,		    /* Starting code size, used during Clear      */
                Code,			    /* Value returned by ReadCode                 */
                MaxCode,		    /* limiting value for current code size       */
                ClearCode,		    /* GIF clear code                             */
                EOFCode,		    /* GIF end-of-information code                */
                CurCode, OldCode, InCode,   /* Decompressor variables                     */
                JustHadClearCode,           /* Last code was a clear code                 */
                FirstFree,		    /* First free code, generated per GIF spec    */
                FreeCode,		    /* Decompressor,next free slot in hash table  */
                FinChar,		    /* Decompressor variable                      */
                BitMask,		    /* current AND mask for data size             */
                ReadMask,		    /* Code AND mask for current code size        */
                Misc;                       /* miscellaneous bits (interlace, local cmap) */
    int         gif89;                      /* &5c                                        */
    boolean     Interlace, HasColourmap;
    int         state;
    byte       *origptr;
    int         aspect;
    const byte *dataptr, *dataend;
    int         bytes_so_far_in_section;
    byte        temp[320];                  /* 80  */
    byte        palette[256*3];             /* 180 */
    int         npixels, maxpixels;         /* 484 */
    byte       *ptr;                        /* 48C */
    int         transparent;
    int         readimagestate;
    int         loadinto;
    int         blocksize;                  /* 4A0 */
    short      *Prefix;                     /* Hash table used by decompressor */
    char       *Suffix;
    char       *OutCode;                    /* Output array used by the decompressor */

    /* Fields added to structure by RML */
    render_flags  flags;                      // Bitfield containing various flags (see. h.render)
    char         *spr_buff;                   // Pointer to single row sprite
    int           pn;                         // Pointer to current column in sprite
    int           last_row;                   // Last full row decompressed
    int           last_bounded;               // value of last_row when last bounding box returned
    int           width;                      // width (from Image)
    int           height;                     // height (from Image)
    int           render_handle;              // handle for render code
    int           substage;                   // used by the extension block decoding routines
    int           substage_size;              // used by the extension block decoding routines
    int           app_ext_id;                 // Last application extension ID read.
    int           last_full_frame;            // The last frame which has been fully processed.
    int           screen_width;               // Screen width (in GIF terms, not OS terms)
    int           screen_height;              // Screen height
    unsigned int  loops;                      // As specified in the "NETSCAPE2.0" extension
    int           current_frame;              // Current frame being decoded
    int           top;                        // Position in screen, offset from top
    int           left;                       // Position in screen, offset from left
    int           delay;                      // Delay before displaying next screen
    int           disposal;                   // Disposal method for this image (see GIF spec)
    int           image_bpp;                  // Bits per pixel of the current image

    FillerFunction *fill_fn;                  // Pointer to function to call to fill the image background
    void           *handle1;                  // Data to be passed to filler function
    int            *handle2;                  // Data to be passed to filler function

    char        local_pal[256*3];             // Local palette data
} GIFloaddata;

static GIFloaddata* store[MaxPics];           // Store of pointers to image data for each image
static int          gif_initialised;          // Set if gifstream_initialised has been called

#ifdef TRACE
static char         report_temp[255];         // Temporary - for debugging purposes.
#endif

/*------------------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_still_image(GIFloaddata *load);
static int              gifstream_ReadCode(GIFloaddata *load, int CodeSize, int ReadMask);
static void             gifstream_abandon_image(int handle);
static _kernel_oserror* gifstream_error(char *s);
static int              gifstream_valid_handle(int handle);
static void             gifstream_initialise(void);
static void             gifstream_add_palette(GIFloaddata *load);
static _kernel_oserror* gifstream_read_image_data(GIFloaddata *load, BBox *changed);
static _kernel_oserror* gifstream_read_gif_signature(GIFloaddata *load);
static _kernel_oserror* gifstream_read_screen_descriptor(GIFloaddata *load);
static _kernel_oserror* gifstream_read_global_colour_map(GIFloaddata *load);
static _kernel_oserror* gifstream_invent_global_colour_map(GIFloaddata *load);
static _kernel_oserror* gifstream_read_image_descriptor(GIFloaddata *load);
static _kernel_oserror* gifstream_read_local_colour_map(GIFloaddata *load);
static _kernel_oserror* gifstream_read_extension_block(GIFloaddata *load);
static _kernel_oserror* gifstream_read_application_extension(GIFloaddata *load);
static _kernel_oserror* gifstream_read_graphic_control_extension(GIFloaddata *load);
static _kernel_oserror* gifstream_read_data_block(GIFloaddata *load);
static _kernel_oserror* gifstream_pre_image_data(GIFloaddata *load, int frame);
static _kernel_oserror* gifstream_end_image_data(GIFloaddata *load);
static _kernel_oserror* gifstream_make_animation(GIFloaddata *load);
static _kernel_oserror* gifstream_animated_load(int handle, char *buffer, int size, BBox *changed);
static _kernel_oserror* gifstream_animated_plot(int handle, int x, int y, scale_factor scale);

#define copyline(to)  if (y+to < ymax) \
                      {memcpy(sptr+linesize*(y+to), sptr+linesize*y, linesize);\
                      if (mptr)\
                          memcpy(mptr+linesize*(y+to), mptr+linesize*y, linesize);}

/*------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------*
 * gifstream_begin                                                                            *
 *                                                                                            *
 * Called at the beginning of the load/fetching process for a GIF.                            *
 *                                                                                            *
 * In: flags            - as specified by imagetrans (currently, only bit 0 for IMAGE_FAST)   *
 *     return_gifhandle - pointer to integer to store this image's handle (identifier to be   *
 *                        used for aÌll future gifstream calls).                               *
 *                                                                                            *
 * Returns: error if one occurred, else NULL.                                                 *
 *          return_gifhandle updated.                                                         *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* gifstream_begin(int *return_gifhandle, int flags)
{
   int          i, n=-1;

   debug_print("    gifstream_begin");

   gifstream_initialise();

   /* Find a slot for the data */
   for (i=0; i<MaxPics; i++) {
     if (store[i]==0) n=i;
     if (n>=0) break;
   }

   if (n<0) return gifstream_error("Can't get an array slot for data.");

   /* Claim memory to store structure */
   store[n]=malloc(sizeof(GIFloaddata));
   if (!store[n]) return gifstream_error("Can't get memory for GIF structure.");

   /* Clear the whole structure */
   memset(store[n], 0, sizeof *store[n]);

   /* Get memory for various tables */
   if (!flex_alloc((flex_ptr) &store[n]->Prefix, 4097 *sizeof(short)))
   {
       free(store[n]);
       return gifstream_error("Can't get memory for prefix table.");
   }

   if (!flex_alloc((flex_ptr) &store[n]->Suffix, 4097 *sizeof(char)))
   {
       flex_free((flex_ptr) &store[n]->Prefix);
       free(store[n]);
       return gifstream_error("Can't get memory for suffix table.");
   }

   if (!flex_alloc((flex_ptr) &store[n]->OutCode, 4097 *sizeof(char)))
   {
       flex_free((flex_ptr) &store[n]->Prefix);
       flex_free((flex_ptr) &store[n]->Suffix);
       free(store[n]);
       return gifstream_error("Can't get memory for outcode table.");
   }

   /* Clear tables */
   memset(store[n]->Prefix, 0, sizeof(short)*4096);
   memset(store[n]->Suffix, 0, sizeof(char)*4096);
   memset(store[n]->OutCode, 0, sizeof(char)*4096);

   store[n]->transparent             = -1;
   store[n]->width                   = -1;
   store[n]->height                  = -1;
   store[n]->render_handle           = -1;
   store[n]->state                   = State_ReadGifSignature;
   store[n]->bytes_so_far_in_section = 0;
   store[n]->current_frame           = 0;
   store[n]->last_full_frame         = -1;
   store[n]->flags.render_type       = Type_InternalLZW;

   /* Set flags */
   store[n]->flags.image_fast          = 0;
   store[n]->flags.background          = 0;
   store[n]->flags.looping             = 0;
   store[n]->flags.client_stream_ended = 0;
   store[n]->flags.regen_tables        = 0;
   store[n]->flags.mutable_mask        = 0;
   store[n]->flags.load_ended          = 0;
   store[n]->flags.render_type         = Type_InternalLZW;
   store[n]->flags.lpb                 = 0;
   store[n]->flags.unused              = 0;

   if (flags && IMAGE_FAST) store[n]->flags.image_fast = 1;

   *return_gifhandle = n;

   return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_initialise                                                                       *
 *                                                                                            *
 * Called to initialise the array of data structures.                                         *
 *--------------------------------------------------------------------------------------------*/

static void gifstream_initialise(void)
{
   int n;

   /* If already initialised, return */
   if (gif_initialised) return;

   /* Reset the store of GIFloddata structures */
   for (n=0; n<MaxPics; n++) store[n]=0;

   /* Set a flag to say we've initialised */
   gif_initialised=1;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_end                                                                              *
 *                                                                                            *
 * Called when all data has been fetched/loaded.                                              *
 *                                                                                            *
 * In: handle - identifier for the image.                                                     *
 *                                                                                            *
 * Returns: error if one occurred, else NULL.                                                 *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* gifstream_end(int handle)
{
    _kernel_oserror *e = NULL;
    GIFloaddata     *load = store[handle];

    /* If not a valid handle, return */
    if (!gifstream_valid_handle(handle)) return NULL;

    if (load->flags.render_type == Type_AnimatedSprites)
    {
        if (!load->flags.client_stream_ended) gifstream_end_image_data(load);
        e=render_animate_end(load->render_handle);
        if (e) return e;
    }

    /* Free the tables used by the GIF decompressor */
    if (store[handle]->Prefix) flex_free((flex_ptr) &store[handle]->Prefix);
    if (store[handle]->Suffix) flex_free((flex_ptr) &store[handle]->Suffix);
    if (store[handle]->OutCode) flex_free((flex_ptr) &store[handle]->OutCode);

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_delete                                                                           *
 *                                                                                            *
 * Called when an image is no longer required, removes all data associated with it.           *
 *                                                                                            *
 * In: handle - identifier for the image.                                                     *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* gifstream_delete(int handle)
{
   _kernel_oserror *e;
   GIFloaddata     *load = store[handle];

   /* If not a valid handle, return */
   if (!gifstream_valid_handle(handle)) return NULL;

   /* If gif end hasn't been called, do the stuff that it would do */
   if (store[handle]->Prefix)  flex_free((flex_ptr) &store[handle]->Prefix);
   if (store[handle]->Suffix)  flex_free((flex_ptr) &store[handle]->Suffix);
   if (store[handle]->OutCode) flex_free((flex_ptr) &store[handle]->OutCode);

   /* Tell c.render to delete it's data */
   if (load->flags.render_type==Type_InternalLZW) e=render_delete(load->render_handle);
   else e=render_animate_delete(load->render_handle);

   /* Free array entry */
   if (store[handle]) free(store[handle]);
   store[handle]=0;

   return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_load                                                                             *
 *                                                                                            *
 * Called each time a block of data has been fetched/loaded, to decode a bit more of the      *
 * image.                                                                                     *
 *                                                                                            *
 * In: handle        - identifier for the image.                                              *
 *     buffer        - location of fetched data                                               *
 *     size          - bytes of data loaded/fetched                                           *
 *     changed       - pointer to bounding box to put details of which part of the image has  *
 *                     changed, once decoding of the data has happened.                       *
 *     return_width  - pointer to integer to store width of the image if read from file yet,  *
 *                     else -1.                                                               *
 *     return_height - pointer to integer to store height of the image if read from file yet, *
 *                     else -1.                                                               *
 *     return_mask   - value of mutable_mask, if calculated yet, else -1.                     *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *          return_width, return_height, return_mask updated.                                 *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* gifstream_load(int handle, char *buffer, int size, BBox *changed,
                                int *return_width, int *return_height, int* return_mask, int* return_anim)
{
   _kernel_oserror *e;
   int              w,h;

   changed->xmin = changed->xmax = changed->ymin = changed->ymax = 0;

   /* If not a valid handle, return */
   if (!gifstream_valid_handle(handle)) return NULL;

   e=gifstream_animated_load(handle, buffer, size, changed);
   if (e) {
     gifstream_abandon_image(handle);
     return e;
   }

   w=-1; h=-1;
   if (store[handle]->width>0) {
     w=store[handle]->screen_width;
     h=store[handle]->screen_height;
   }

   if (store[handle]->flags.render_type==Type_AnimatedSprites)
       store[handle]->flags.mutable_mask = 0;

   *return_width  = w;
   *return_height = h;
   *return_mask   = store[handle]->flags.mutable_mask;
   *return_anim   = store[handle]->flags.render_type - 1;

   return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_plot                                                                             *
 *                                                                                            *
 * Called to plot the image to the screen.                                                    *
 *                                                                                            *
 * In: handle - identifier for the image.                                                     *
 *     x      - x co-ordinate to plot at.                                                     *
 *     y      - y co-ordinate to plot at.                                                     *
 *     scale  - scaling structure holding x and y divisors/multipliers                        *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* gifstream_plot(int handle, int x, int y, scale_factor scale)
{
    GIFloaddata     *load = store[handle];
    _kernel_oserror *e=NULL;
    int              old_budge_state, old_deferred_state;

    /* If not a valid handle, return */
    if (!gifstream_valid_handle(handle)) return NULL;

    /* Set budge state and deferred compaction state */
    old_budge_state=flex_set_budge(0);
    old_deferred_state = flex_set_deferred_compaction(0);

    /* Plot the image */
    if (load->flags.render_type==Type_InternalLZW) e=render_whole_scaled(load->render_handle,x,y,scale);
    else e=gifstream_animated_plot(handle, x, y, scale);
    if (e) gifstream_abandon_image(handle);

    /* Reset budge and deferred compaction state to their old values */
    flex_set_deferred_compaction(old_deferred_state);
    flex_set_budge(old_budge_state);

    return e;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_add_palette                                                                      *
 *                                                                                            *
 * Copies the image's palette into the image's sprite's palette.                              *
 *                                                                                            *
 * In: handle - identifier for the image.                                                     *
 *--------------------------------------------------------------------------------------------*/

void gifstream_add_palette(GIFloaddata *load)
{
   sprite_area   *spr        = (sprite_area*) render_return_sprite_address(load->render_handle);
   sprite_header *spr_header = (sprite_header*) ((char*)spr + sizeof(sprite_area));
   int            i;

   report_value("Adding palette, colourmap ", load->HasColourmap);

   for (i=0; i<256; i++) {
     if (load->HasColourmap)
        spr_header->palette[i*2] = spr_header->palette[i*2+1] = (load->local_pal[i*3]<<8)+
                                                                (load->local_pal[i*3+1]<<16)+
                                                                (load->local_pal[i*3+2]<<24);
     else
        spr_header->palette[i*2] = spr_header->palette[i*2+1] = (load->palette[i*3]<<8)+
                                                                (load->palette[i*3+1]<<16)+
                                                                (load->palette[i*3+2]<<24);
   }
}



_kernel_oserror* gifstream_mode_change(int handle)
{
   GIFloaddata     *load = store[handle];
   _kernel_oserror *e=NULL;

   if (load->flags.render_type==Type_InternalLZW) e=render_mode_change(load->render_handle);
   else e=render_animate_mode_change(load->render_handle);
   if (e) gifstream_abandon_image(handle);

   return e;
}


/*---------------------------------------------------------------------------------------------------------------*/
/*                                                Animated GIF stuff                                             */
/*---------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------*
 * gifstream_need_redraw                                                                      *
 *                                                                                            *
 * Checks if a specified animation needs redrawing (due to frame having changed).             *
 *                                                                                            *
 * In: handle - identifier for this animation.                                                *
 *                                                                                            *
 * Returns: 1 if redraw needed, else 0.                                                       *
 *--------------------------------------------------------------------------------------------*/

int gifstream_need_redraw(int handle, BBox *changed)
{
    GIFloaddata *load = store[handle];

    if (load->flags.render_type==Type_InternalLZW) return 1;

    return render_animate_need_redraw(store[handle]->render_handle, changed);
}


/*--------------------------------------------------------------------------------------------*
 * gif_animated_load                                                                          *
 *                                                                                            *
 * Called when some data has been loaded/fetched, to decode it.                               *
 *                                                                                            *
 * In: handle  - identifier for this animation.                                               *
 *     buffer  - pointer to data.                                                             *
 *     size    - size of data.                                                                *
 *     changed - pointer to bounding box to put details of the changed area                   *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_animated_load(int handle, char *buffer, int size, BBox *changed)
{
    _kernel_oserror *e=NULL;
    GIFloaddata     *load = store[handle];
    int              more_frames=1;
    int              oldstate;

    report_string("gifstream_animated_load");

    load->dataptr = (byte*)buffer;
    load->origptr = (byte*)buffer;
    load->dataend = (byte*)buffer + size;

    while ((load->dataptr < load->dataend) && (!e) && (more_frames))
    {
        switch (load->state)
        {
            case State_ReadGifSignature:
                e=gifstream_read_gif_signature(load);
                break;
            case State_ReadScreenDescriptor:
                e=gifstream_read_screen_descriptor(load);
                break;
            case State_ReadGlobalColourMap:
                e=gifstream_read_global_colour_map(load);
                break;
            case State_InventGlobalColourMap:
                e=gifstream_invent_global_colour_map(load);
                break;
            case State_ReportWriteLine:
                report_string("--------------------------------------------------------------------------------");
                report_value("frame", load->current_frame); report_string("");
                load->state=State_ReadExtensionBlock;
                break;
            case State_ReadExtensionBlock:
                e=gifstream_read_extension_block(load);
                break;
            case State_ReadApplicationExt:
               e=gifstream_read_application_extension(load);
               break;
            case State_ReadGraphicControlExt:
               e=gifstream_read_graphic_control_extension(load);
               break;
            case State_ReadDataBlock:
               e=gifstream_read_data_block(load);
               break;
            case State_ReadImageDescriptor:
               e=gifstream_read_image_descriptor(load);
               break;
            case State_ReadLocalColourMap:
               e=gifstream_read_local_colour_map(load);
               break;
            case State_PreImageData:
               e=gifstream_pre_image_data(load, load->current_frame);
               break;
            case State_ReadImageData:
               oldstate=flex_set_budge(0);
               e=gifstream_read_image_data(load, changed);
               flex_set_budge(oldstate);
               break;
            case State_EndImageData:
               e=gifstream_end_image_data(load);
               break;
            case State_NoMoreFrames:
               more_frames=0;
               break;
            default:
               report_value("\n\nError - State ",load->state);
               _swi(OS_WriteI + 4, 0);
               _swi(OS_WriteI + 26, 0);
               printf("Error in gif_stream - strange state %d\n",load->state);
               exit(0);
               break;
        }
    }

#if ReportErrorsToScreen
    if (e)
    {
        _swi(OS_WriteI + 4, 0);
        _swi(OS_WriteI + 26, 0);
        printf("gifstream_animated_load error %s\n",e->errmess);
    }
#endif

    if (e) gifstream_abandon_image(handle);

    return e;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_gif_signature                                                               *
 *                                                                                            *
 * Reads the GIF signature from the datastream.                                               *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_gif_signature(GIFloaddata *load)
{
    int len = min(6-load->bytes_so_far_in_section, load->dataend-load->dataptr);

    memcpy(load->temp + load->bytes_so_far_in_section, load->dataptr, len);
    load->dataptr+=len;
    load->bytes_so_far_in_section+=len;

    if (load->bytes_so_far_in_section == 6)
    {
        if      (strncmp(load->temp,"GIF89a",6)==0) load->gif89 = 1;
        else if (strncmp(load->temp,"GIF87a",6)==0) load->gif89 = 0;
        else return gifstream_error("Not a GIF file.");

        load->state = State_ReadScreenDescriptor;
        load->bytes_so_far_in_section=0;
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_screen_descriptor                                                           *
 *                                                                                            *
 * Reads the GIF screen descriptor from the datastream.                                       *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_screen_descriptor(GIFloaddata *load)
{
    const byte      *dataptr=load->dataptr;
    int              crpixel;
    int              len = min(7 - load->bytes_so_far_in_section, load->dataend - load->dataptr);

    memcpy(load->temp + load->bytes_so_far_in_section, dataptr, len);
    load->dataptr+=len;
    load->bytes_so_far_in_section+=len;

    if (load->bytes_so_far_in_section == 7)
    {
        dataptr=load->temp;

        /*
         * Only use these for GIF89 images - there are lots of GIF87 images with bogus
         * screen sizes. The later code to check that the screen is as large as the
         * first image will sort it out.
         */
        if (load->gif89)
        {
            load->screen_width  = dataptr[0] + (dataptr[1] * 256);
            load->screen_height = dataptr[2] + (dataptr[3] * 256);
        }
        crpixel             = dataptr[4];
        load->Background    = dataptr[5];
        load->aspect        = dataptr[6];

        load->BitsPerPixel  = (crpixel & 7) + 1;
        load->ColourMapSize = 1 << load->BitsPerPixel;
        load->delay         = -1;

        report_string("\nScreen descriptor");
        report_value ("  screen_x  ", load->screen_width);
        report_value ("  screen_y  ", load->screen_height);
        report_value ("  background", load->Background);

        if (crpixel & 128) load->state = State_ReadGlobalColourMap;
        else load->state = State_InventGlobalColourMap;

        load->bytes_so_far_in_section=0;
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_global_colour_map                                                           *
 *                                                                                            *
 * Reads the GIF global colour map from the datastream.                                       *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_global_colour_map(GIFloaddata *load)
{
    int         size_of_map = load->ColourMapSize * 3;
    int         len         = min(size_of_map - load->bytes_so_far_in_section, load->dataend - load->dataptr);

    memcpy(load->palette + load->bytes_so_far_in_section, load->dataptr, len);
    load->dataptr+=len;
    load->bytes_so_far_in_section+=len;

    if (load->bytes_so_far_in_section == size_of_map)
    {
        report_string("Reading Global Colour Table");
        load->state = State_ReportWriteLine;
        load->bytes_so_far_in_section=0;
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_invent_global_colour_map                                                         *
 *                                                                                            *
 * For images without a defined global colourmap, creates a standard EGA palette.             *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_invent_global_colour_map(GIFloaddata *load)
{
    int i, to;

    to = 1 << load->BitsPerPixel;

    report_string("Global palette is standard EGA palette");
    for (i=0; i<to; i++)
    {
        load->palette[i*3]   = EGApalette[i&15][0];
        load->palette[i*3+1] = EGApalette[i&15][1];
        load->palette[i*3+2] = EGApalette[i&15][2];
    }

    load->Background = -1;
    load->state = State_ReportWriteLine;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_image_descriptor                                                            *
 *                                                                                            *
 * Reads an image descriptor from the datastream.                                             *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_image_descriptor(GIFloaddata *load)
{
    _kernel_oserror *e;
    const byte      *dataptr = load->dataptr;
    int              len = min(10 - load->bytes_so_far_in_section, load->dataend - load->dataptr);
    int              comma;

    memcpy(load->temp + load->bytes_so_far_in_section, dataptr, len);
    load->dataptr+=len;
    load->bytes_so_far_in_section+=len;

    if (load->bytes_so_far_in_section == 10)
    {
        dataptr=load->temp;

        if (dataptr[0]==59)
        {
            load->state = State_NoMoreFrames;
            return NULL;
        }

        /* If this is the second frame, then the render needs to be told that we're now doing an animation */
        if (load->current_frame==1)
        {
            e=gifstream_make_animation(load);
            if (e) return e;
        }

        if (dataptr[0]!=44)
        {
            report_string("*** WARNING - Corrupt GIF file ***");
            load->state = State_NoMoreFrames;
            return NULL;
        }

        comma        = dataptr[0];
        load->left   = dataptr[1] + (dataptr[2] * 256);
        load->top    = dataptr[3] + (dataptr[4] * 256);
        load->width  = dataptr[5] + (dataptr[6] * 256);
        load->height = dataptr[7] + (dataptr[8] * 256);
        load->Misc   = dataptr[9];

        if (load->current_frame == 0)
        {
            if (load->flags.image_fast)
            {
                load->screen_width = load->width;
                load->screen_height = load->height;
            }
            else
            {
                if (load->left + load->width > load->screen_width)
                    load->screen_width = load->left + load->width;

                if (load->top + load->height > load->screen_height)
                    load->screen_height = load->top + load->height;
            }
        }

        load->image_bpp    = (load->Misc & 7) +1;
        load->HasColourmap = load->Misc & 128;
        load->Interlace    = load->Misc & 64;

        if (load->Interlace && (load->transparent!=-1)) load->flags.mutable_mask=true;

        report_string("Read image descriptor");
        report_value("  comma          ",comma);
        report_value("  left           ",load->left);
        report_value("  top            ",load->top);
        report_value("  width          ",load->width);
        report_value("  height         ",load->height);
        report_value("  load->Misc     ",load->Misc);
        report_value("  colourmap      ",load->HasColourmap);
        report_value("  image bpp      ",load->image_bpp);

        if (load->HasColourmap) load->state = State_ReadLocalColourMap;
        else load->state = State_PreImageData;

        load->bytes_so_far_in_section = 0;
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_local_colour_map                                                            *
 *                                                                                            *
 * Reads a local colour map from the datastream.                                              *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_local_colour_map(GIFloaddata *load)
{
    int size        = 1<<load->image_bpp;
    int size_of_map = size * 3;
    int len         = min(size_of_map - load->bytes_so_far_in_section, load->dataend - load->dataptr);

    memcpy(load->local_pal + load->bytes_so_far_in_section, load->dataptr, len);
    load->dataptr+=len;
    load->bytes_so_far_in_section+=len;

    if (load->bytes_so_far_in_section == size_of_map)
    {
        report_string("Reading local colour map");
        load->state = State_PreImageData;
        load->bytes_so_far_in_section = 0;
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_extension_block                                                             *
 *                                                                                            *
 * Reads an extension block from the datastream.                                              *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_extension_block(GIFloaddata *load)
{
    const byte* dataptr = load->dataptr;
    int         introducer, code;
    int         len = min(2 - load->bytes_so_far_in_section, load->dataend - load->dataptr);

    memcpy(load->temp + load->bytes_so_far_in_section, dataptr, len);
    load->dataptr+=len;
    load->bytes_so_far_in_section+=len;

    if (load->bytes_so_far_in_section == 2)
    {
        dataptr=load->temp;

        introducer = *dataptr++;
        code       = *dataptr++;

        if (introducer!=33)
        {
            load->state = State_ReadImageDescriptor;
            return NULL;
        }

        report_value("Reading extension",code);

        if      (code==0xFF) load->state = State_ReadApplicationExt;    /* Application extension     */
        else if (code==0xF9) load->state = State_ReadGraphicControlExt; /* Graphic control extension */
        else if (code==0xFE) load->state = State_ReadDataBlock;         /* Comment extension         */
        else if (code==0x01) load->state = State_ReadDataBlock;         /* Plain text extension      */
        else                 load->state = State_ReadDataBlock;         /* Unrecognised extension    */

        load->substage = 0;
        load->bytes_so_far_in_section = 0;
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_application_extension                                                       *
 *                                                                                            *
 * Reads an application extension block from the datastream.                                  *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_application_extension(GIFloaddata *load)
{
    const byte* dataptr = load->dataptr;
    int         size, len;
    char        authent[3];
    char        id[8];

    /* Reading an application extension is two stages:           */
    /*  - First, a header block with the application identifier. */
    /*  - Then, any number of data blocks.                       */

    /* The header block size isn't necessarily 12 */
    if (load->substage == 0)
    {
        load->substage_size = *load->dataptr++;
        load->bytes_so_far_in_section = 0;
        load->substage = 1;
    }

    /* So, if we're at the first stage, then we need a 12 byte header block */
    else if (load->substage == 1)
    {
        len = min(load->substage_size - load->bytes_so_far_in_section, load->dataend - load->dataptr);
        memcpy(load->temp + load->bytes_so_far_in_section, dataptr, len);
        load->dataptr+=len;
        load->bytes_so_far_in_section+=len;

        /* If we've managed to get all 12 bytes, then process the information */
        if (load->bytes_so_far_in_section == load->substage_size)
        {
            report_string("  Reading application extension");
            dataptr = load->temp;
            load->app_ext_id = 0;
            if (load->substage_size >= 11)
            {
                strncpy(id,      dataptr, 8); dataptr+=8;
                strncpy(authent, dataptr, 3); dataptr+=3;
                if (strncmp(id,"NETSCAPE",8)==0)
                    load->app_ext_id=NETSCAPE_ID;
            }
            #ifdef TRACE
            sprintf(report_temp,"  id %s",id); report_string(report_temp);
            #endif
            load->substage = 2;
            load->bytes_so_far_in_section = 0;
        }
    }

    /* For the later stages, we read in the data blocks checking for any extensions we */
    /* recognise - currently only the Netscape one which makes an animation repeat.    */
    /* This block reading stage is further divided into two stages - the first reads   */
    /* the size of the block, the second actually reads the block data. It seems quite */
    /* an involved process, but this is necessary because of the gradual fetching that */
    /* processes involved.                                                             */

    /* So, to read the block size */
    else if (load->substage == 2)
    {
        load->substage      = 3;
        load->substage_size = load->dataptr[0];
        load->dataptr++;

        report_value("  blocksize",load->substage_size);

        if (load->substage_size==0)
        {
            load->bytes_so_far_in_section=0;
            load->state = State_ReadExtensionBlock;
            report_string("  end block");
            return NULL;
        }
    }

    /* Now, to read the block data */
    else
    {
        size = load->substage_size;

        len = min(size - load->bytes_so_far_in_section, load->dataend-load->dataptr);
        memcpy(load->temp + load->bytes_so_far_in_section, dataptr, len);
        load->dataptr+=len;
        load->bytes_so_far_in_section+=len;

        if (load->bytes_so_far_in_section == size)
        {
            dataptr = load->temp;
            load->bytes_so_far_in_section = 0;
            load->substage = 2;

            if ((load->app_ext_id==NETSCAPE_ID) && (size==3) && (*dataptr==1))
            {
                load->flags.looping = 1;
                load->loops         = dataptr[1] | dataptr[2] << 8;

                report_string("NETSCAPE looping extension");
            }
        }
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_graphic_control_extension                                                   *
 *                                                                                            *
 * Reads a graphic control extension block from the datastream.                               *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_graphic_control_extension(GIFloaddata *load)
{
    _kernel_oserror *e;
    const byte      *dataptr = load->dataptr;
    int              blocksize, stuff, terminate, use_transparency;
    int              len = min(6 - load->bytes_so_far_in_section, load->dataend - load->dataptr);

    memcpy(load->temp + load->bytes_so_far_in_section, dataptr, len);
    load->dataptr+=len;
    load->bytes_so_far_in_section+=len;

    if (load->bytes_so_far_in_section == 6)
    {
        dataptr = load->temp;

        /* If this is the second frame, then the render needs to be told that we're now doing an animation */
        if (load->current_frame==1)
        {
            e=gifstream_make_animation(load);
            if (e) return e;
        }

        report_string("Reading graphic control extension");

        load->bytes_so_far_in_section = 0;
        load->state = State_ReadExtensionBlock;

        if (load->delay>-1)
        {
            report_string("Another graphic control extension - ignoring.");
            dataptr+=6;
            return NULL;
        }

        blocksize         = dataptr[0];
        stuff             = dataptr[1];
        load->delay       = dataptr[2] + (dataptr[3] * 256);
        load->transparent = dataptr[4];
        terminate         = dataptr[5];
        load->disposal    = (stuff & 0x1C) >>2;
        use_transparency  = (stuff & 1);

        report_value("  blocksize",blocksize);
        report_value("  stuff    ",stuff);
        report_value("  delay    ",load->delay);
        report_value("  transp   ",load->transparent);
        report_value("  terminate",terminate);
        report_value("  disposal ",load->disposal);
        report_value("  use trans",use_transparency);

        if (!use_transparency) load->transparent=-1;
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_data_block                                                                  *
 *                                                                                            *
 * Reads a data block and ignores the data (eg. for a comment extension)                      *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_data_block(GIFloaddata *load)
{
    const byte* dataptr = load->dataptr;
    int         size;
    int         len;

    /* The process of reading a data block is divided into two substages - the first reads the */
    /* size of the block, the next reads the block. This is necessary because of the gradual   */
    /* fetching processes involved.                                                            */

    /* So, firstly, to read the block size */
    if (load->substage == 0)
    {
        load->substage      = 1;
        load->substage_size = load->dataptr[0];

        report_value("  substage size ",load->substage_size);

        load->dataptr++;

        if (load->substage_size==0)
        {
            load->bytes_so_far_in_section=0;
            load->state = State_ReadExtensionBlock;
            return NULL;
        }
    }

    /* Now to read the block data (and ignore it!) */
    else
    {
        size = load->substage_size;

        len = min(size - load->bytes_so_far_in_section, load->dataend - load->dataptr);
        memcpy(load->temp + load->bytes_so_far_in_section, dataptr, len);
        load->dataptr+=len;
        load->bytes_so_far_in_section+=len;

        if (load->bytes_so_far_in_section == size)
        {
            load->bytes_so_far_in_section = 0;
            load->substage = 0;
        }
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_pre_image_data                                                                   *
 *                                                                                            *
 * Reads an image from the datastream and sends it to the render code                         *
 *                                                                                            *
 * In: load  - pointer to GIFloaddata structure which contains information about the GIF file *
 *     frame - the number of the frame we're reading.                                         *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_pre_image_data(GIFloaddata *load, int frame)
{
    _kernel_oserror *e;
    frame_str        fr;
    int             *put_palette;
    int              n, oldstate, background_entry;

    frame=frame;

    /* Reset the tables in preperation */
    memset(load->Prefix, 0, sizeof(short)*4096);
    memset(load->Suffix, 0, sizeof(char)*4096);
    memset(load->OutCode, 0, sizeof(char)*4096);
    load->BitOffset=0;

    load->CodeSize = *load->dataptr++;

    /* Setup some variables for the decompression */
    if (load->Interlace && load->transparent != -1) load->flags.mutable_mask=true;

    load->ClearCode = (1 << load->CodeSize);
    load->EOFCode   = load->ClearCode+1;
    load->FreeCode  = load->FirstFree = load->ClearCode + 2;
    load->CodeSize++;

    if (load->HasColourmap)
        load->BitMask = (1 << load->image_bpp) - 1;
    else
        load->BitMask = load->ColourMapSize - 1;

    load->InitCodeSize              = load->CodeSize;
    load->MaxCode                   = (1 << load->CodeSize);
    load->ReadMask                  = load->MaxCode - 1;
    load->JustHadClearCode          = 1;
    load->npixels                   = 0;
    load->maxpixels                 = load->width * load->height;
    load->readimagestate            = 0;
    load->loadinto                  = 0;
    load->bytes_so_far_in_section   = 0;
    load->XC                        = 0;
    load->YC                        = 0;
    load->flags.client_stream_ended = 0;

    fr.delay        = load->delay;
    fr.width        = load->width;
    fr.height       = load->height;
    fr.left         = load->left;
    fr.top          = load->top;
    fr.transparency = load->transparent;
    fr.disposal     = load->disposal;
    fr.interlace    = load->Interlace;

    if (load->flags.render_type==Type_InternalLZW)
    {
        int handle;

        e=render_start('G', load->width, load->height, load->Interlace,
                          load->transparent, load->flags, &handle, &load->spr_buff);
        if (e) return e;
        load->render_handle = handle;
    }
    else
    {
        oldstate=flex_set_budge(0);
        background_entry = (load->palette[load->Background*3]   << 8)+
                           (load->palette[load->Background*3+1] << 16)+
                           (load->palette[load->Background*3+2] << 24);
        e=render_animate_new_frame(load->render_handle, fr, background_entry, &load->spr_buff);
        flex_set_budge(oldstate);
        if (e) return e;
    }

    load->pn = 0;

    /* Supply render with the local palette */
    oldstate=flex_set_budge(0);
    if (load->flags.render_type==Type_AnimatedSprites)
    {
        put_palette = (int*)render_animate_add_local_palette(load->render_handle, 8);

        for (n=0; n<256; n++)
        {
            if (load->HasColourmap)
                put_palette[n*2] = put_palette[n*2+1] = (load->local_pal[n*3]  <<8)+
                                                        (load->local_pal[n*3+1]<<16)+
                                                        (load->local_pal[n*3+2]<<24);
            else
                put_palette[n*2] = put_palette[n*2+1] = (load->palette[n*3]  <<8)+
                                                        (load->palette[n*3+1]<<16)+
                                                        (load->palette[n*3+2]<<24);
        }
    }
    flex_set_budge(oldstate);

    report_string("About to decode...");

    load->state = State_ReadImageData;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_end_image_data                                                                   *
 *                                                                                            *
 * Ends reading of the image data and tells render that the frame is finished.                *
 *                                                                                            *
 * In: load  - pointer to GIFloaddata structure which contains information about the GIF file *
 *     frame - the number of the frame we're reading.                                         *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_end_image_data(GIFloaddata *load)
{
    _kernel_oserror *e;
    int              oldstate;

    if (load->flags.render_type==Type_InternalLZW)
    {
        oldstate=flex_set_budge(0);
        e=render_end(load->render_handle);
        flex_set_budge(oldstate);
        if (e) return e;
    }
    else
    {
        oldstate=flex_set_budge(0);
        e=render_animate_done_frame(load->render_handle);
        flex_set_budge(oldstate);
        load->delay=-1;
        if (e) return e;
    }

    load->last_full_frame++;
    load->dataptr++;
    load->state = State_ReportWriteLine;
    load->current_frame++;
    load->bytes_so_far_in_section = 0;
    load->flags.client_stream_ended=1;

    if (load->npixels!=load->maxpixels)
    {
        //printf("Corrupt frame!");
        if (load->flags.render_type==Type_AnimatedSprites) render_mark_corrupt_frame(load->render_handle);
        //_swi(OS_ReadC,0);
    }

    if (load->flags.image_fast) load->state = State_NoMoreFrames;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_image_data                                                                  *
 *                                                                                            *
 * Decodes some more image data and passes it to the still (inanimate) part of render.        *
 *                                                                                            *
 * In: load    - pointer to GIFloaddata structure which contains information about the file   *
 *     changed - pointer to bounding box to store area of the 'screen' which is changed.      *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror *gifstream_read_image_data(GIFloaddata *load, BBox *changed)
{
    _kernel_oserror *e;
    char     *spr_buff;
    const int ClearCode = load->ClearCode, EOFCode=load->EOFCode;
    const int BitMask = load->BitMask;
    int       i;
    int       len, now_to;
    int       CodeSize = load->CodeSize, MaxCode=load->MaxCode;
    int       ReadMask = load->ReadMask, FreeCode=load->FreeCode;
    int       CurCode = load->CurCode, OldCode=load->OldCode;
    int       FinChar = load->FinChar;
    int       npixels = load->npixels, InCode=load->InCode, Code=load->Code;
    int       OutCount=0;

    if (load->flags.render_type==Type_InternalLZW)
    {
        e = gifstream_read_still_image(load);
        now_to = load->last_row;
        render_changed(load->render_handle, load->last_bounded, now_to, load->Interlace, changed);
        load->last_bounded = now_to;
        return e;
    }

    spr_buff = load->spr_buff = render_animate_return_spr_address(load->render_handle);

restart:
    if (load->bytes_so_far_in_section == 0)
    {
        /* Need to start a new block */
        load->bytes_so_far_in_section = *load->dataptr++;

        if (load->bytes_so_far_in_section == 0)
        {
            load->dataptr--;
            load->npixels = npixels;  /* So this can be inspected by gifstream_end_image_data() */
            load->state = State_EndImageData;
            return NULL;
        }
        if (load->dataptr==load->dataend)
            goto exit;
    }

    len=min(load->dataend-load->dataptr, load->bytes_so_far_in_section);

    memcpy(load->temp+load->loadinto, load->dataptr, len);

    load->blocksize=len+load->loadinto;

    load->dataptr+=len;
    load->bytes_so_far_in_section-=len;

    /* Right, we've got some more of the block in temp */

    //picptr=(byte *)this->private_data2+this->private_data2[12] + 16
    //                  + load->YC * load->spritewidth + load->XC;

    switch (load->readimagestate)
    {
        case 2:
            goto stage2;
        case 3:
            goto stage3;
    }

  /* Decompress the file, continuing until you see the GIF EOF code.
   * One obvious enhancement is to add checking for corrupt files here.
   */

stage3:
    Code = gifstream_ReadCode(load, CodeSize, ReadMask);

    if (Code==-1)
    {
        load->readimagestate=3;
        if (load->dataptr < load->dataend)
            goto restart;
        else
            goto exit;
    }


    while (Code != EOFCode)
    {
        /* Clear code sets everything back to its initial value, then reads the
         * immediately subsequent code as uncompressed data.
         */

        if (Code == ClearCode)
        {
            CodeSize = load->InitCodeSize;
            MaxCode = (1 << CodeSize);
            ReadMask = MaxCode - 1;
            FreeCode = load->FirstFree;
            load->JustHadClearCode = 1;
        }
        else
        {
            /* If not a clear code, must be data: save same as CurCode and InCode */

            /* if we're at maxcode and didn't get a clear, stop loading */
            if (FreeCode>=4096)
                return gifError("freecode blew up");

            CurCode = InCode = Code;

            if (!load->JustHadClearCode)
            {

                /* If greater or equal to FreeCode, not in the hash table yet;
                 * repeat the last character decoded
                 */

                if (CurCode >= FreeCode)
                {
    	            CurCode = OldCode;
    	            if (OutCount > 4096)
    	                return gifError("outcount1 blew up");
    	            load->OutCode[OutCount++] = FinChar;
                }

                /* Unless this code is raw data, pursue the chain pointed to by CurCode
                 * through the hash table to its end; each code in the chain puts its
                 * associated output code on the output queue.
                 */

                while (CurCode > EOFCode)
                {
    	            if (OutCount > 4096) break;   /* corrupt file */
    	            load->OutCode[OutCount++] = load->Suffix[CurCode];
    	            CurCode = load->Prefix[CurCode];
                }

                if (OutCount > 4096) { return gifError("outcount blew up"); }

            }

            /* The last code in the chain is treated as raw data. */

            FinChar = CurCode & BitMask;
            load->OutCode[OutCount++] = FinChar;

            /* Now we put the data out to the Output routine.
             * It's been stacked LIFO, so deal with it that way...
             */

            /* safety thing:  prevent exceeding range of 'pic8' */
            if (npixels + OutCount > load->maxpixels)
                OutCount = load->maxpixels-npixels;

            npixels += OutCount;

            for (i=OutCount-1; i>=0; i--)
            {
                // *picptr = load->OutCode[i];

                spr_buff[load->pn++] = load->OutCode[i];

                //putpixel(load, load->OutCode[i]);
                //if (load->OutCode[i]==transparent) spr_mask[(load->pn)-1]=0;
                //else spr_mask[(load->pn)-1]=255;

                if (++load->XC == load->width) {
                  load->spr_buff = render_animate_row(load->render_handle);
                  spr_buff = load->spr_buff;
                  load->pn = 0;
                  load->XC=0;
                  load->YC++;
                }

                //if (transparent >= 0 && spr_buff[load->pn] != transparent)
                //  spr_mask[load->pn-1]=255;
                //else spr_buff[load->pn-1]=5; //spr_mask[load->pn-1]=0;
                //    *(picptr+load->maskoffset)=255;
                //picptr++;
                //if (++load->XC == this->width)
                //{
                //    load->XC=0;
                //    load->YC++;
                //    picptr+=load->spritewidth-this->width;
                //}
            }

            OutCount = 0;

            /* Build the hash table on-the-fly. No table is stored in the file. */

            if (load->JustHadClearCode)
                load->JustHadClearCode = 0;
            else
            {
                load->Prefix[FreeCode] = OldCode;
                load->Suffix[FreeCode] = FinChar;

                /* Point to the next slot in the table.  If we exceed the current
                 * MaxCode value, increment the code size unless it's already 12.  If it
                 * is, do nothing: the next code decompressed better be CLEAR
                 */

                if (++FreeCode >= MaxCode)
                {
    	            if (CodeSize < 12)
    	            {
    	                CodeSize++;
    	                MaxCode *= 2;
    	                ReadMask = (1 << CodeSize) - 1;
    	            }
                }
            }
            OldCode = InCode;
        }
stage2:
        Code = gifstream_ReadCode(load, CodeSize, ReadMask);

        if (Code == -1)
        {
            load->readimagestate=2;
            if (load->dataptr < load->dataend)
                goto restart;
            else
                goto exit;
        }
        if (npixels >= load->maxpixels) break;
    }
    load->state = State_EndImageData;

exit:

    load->CodeSize=CodeSize; load->MaxCode=MaxCode;
    load->ReadMask=ReadMask; load->FreeCode=FreeCode;
    load->npixels=npixels;
    load->OldCode=OldCode;
    load->FinChar=FinChar;

    load->CurCode=CurCode;
    load->InCode=InCode; load->Code=Code;

    report_value("  XC       ",load->XC);
    report_value("  YC       ",load->YC);
    report_value("  npixels  ",load->npixels);
    report_value("  maxpixels",load->maxpixels);

    render_animate_changed(load->render_handle, changed);

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_still_image                                                                 *
 *                                                                                            *
 * Continues the decoding of the image data (not the header) - called by gifstream_load.      *
 *                                                                                            *
 * In: load    - structure containing details about the current image.                        *
 *                                                                                            *
 * Returns: Error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror *gifstream_read_still_image(GIFloaddata *load)
{
    _kernel_oserror *e;
    char     *spr_buff;
    int       i;
    int       len;
    int       CodeSize = load->CodeSize, MaxCode=load->MaxCode;
    int       ReadMask = load->ReadMask, FreeCode=load->FreeCode;
    int       CurCode  = load->CurCode, OldCode=load->OldCode;
    int       FinChar  = load->FinChar;
    int       npixels  = load->npixels, InCode=load->InCode, Code=load->Code;
    int       OutCount = 0;
    const int ClearCode = load->ClearCode, EOFCode=load->EOFCode;
    const int BitMask=load->BitMask;

    load->spr_buff=render_return_address_for_rgb_data(load->render_handle);
    spr_buff=load->spr_buff;

    if (npixels==0) gifstream_add_palette(load);

restart:
    if (load->bytes_so_far_in_section == 0)
    {
        /* Need to start a new block */
        load->bytes_so_far_in_section = *load->dataptr++;

        if (load->bytes_so_far_in_section == 0)
        {
            load->dataptr--;
            load->npixels = npixels;  /* So this can be inspected by gifstream_end_image_data() */
            load->state = State_EndImageData;
            return NULL;
        }
        if (load->dataptr==load->dataend)
            goto exit;
    }

    len=min(load->dataend-load->dataptr, load->bytes_so_far_in_section);

    memcpy(load->temp+load->loadinto, load->dataptr, len);

    load->blocksize=len+load->loadinto;

    load->dataptr+=len;
    load->bytes_so_far_in_section-=len;

    /* Right, we've got some more of the block in temp */

    //picptr=(byte *)this->private_data2+this->private_data2[12] + 16
    //                  + load->YC * load->spritewidth + load->XC;

    switch (load->readimagestate)
    {
        case 2:
            goto stage2;
        case 3:
            goto stage3;
    }

  /* Decompress the file, continuing until you see the GIF EOF code.
   * One obvious enhancement is to add checking for corrupt files here.
   */

stage3:
    Code = gifstream_ReadCode(load, CodeSize, ReadMask);

    if (Code==-1)
    {
        load->readimagestate=3;
        if (load->dataptr < load->dataend)
            goto restart;
        else
            goto exit;
    }


    while (Code != EOFCode)
    {
        /* Clear code sets everything back to its initial value, then reads the
         * immediately subsequent code as uncompressed data.
         */

        if (Code == ClearCode)
        {
            CodeSize = load->InitCodeSize;
            MaxCode = (1 << CodeSize);
            ReadMask = MaxCode - 1;
            FreeCode = load->FirstFree;
            load->JustHadClearCode = 1;
        }
        else
        {
            /* If not a clear code, must be data: save same as CurCode and InCode */

            /* if we're at maxcode and didn't get a clear, stop loading */
            if (FreeCode>=4096)
                return gifError("freecode blew up");

            CurCode = InCode = Code;

            if (!load->JustHadClearCode)
            {

                /* If greater or equal to FreeCode, not in the hash table yet;
                 * repeat the last character decoded
                 */

                if (CurCode >= FreeCode)
                {
    	            CurCode = OldCode;
    	            if (OutCount > 4096)
    	                return gifError("outcount1 blew up");
    	            load->OutCode[OutCount++] = FinChar;
                }

                /* Unless this code is raw data, pursue the chain pointed to by CurCode
                 * through the hash table to its end; each code in the chain puts its
                 * associated output code on the output queue.
                 */

                while (CurCode > EOFCode)
                {
    	            if (OutCount > 4096) break;   /* corrupt file */
    	            load->OutCode[OutCount++] = load->Suffix[CurCode];
    	            CurCode = load->Prefix[CurCode];
                }

                if (OutCount > 4096) return gifError("outcount blew up");
            }

            /* The last code in the chain is treated as raw data. */

            FinChar = CurCode & BitMask;
            load->OutCode[OutCount++] = FinChar;

            /* Now we put the data out to the Output routine.
             * It's been stacked LIFO, so deal with it that way...
             */

            /* safety thing:  prevent exceeding range of 'pic8' */
            if (npixels + OutCount > load->maxpixels)
                OutCount = load->maxpixels-npixels;

            npixels += OutCount;

            //if (!Interlace)
            //{
                for (i=OutCount-1; i>=0; i--)
                {
                    // *picptr = load->OutCode[i];

                    spr_buff[load->pn++] = load->OutCode[i];

                    if (load->pn==load->width) {
                      int inc;
                      e=render_row(load->render_handle, &spr_buff, &inc);
                      if (e) return e;
                      load->last_row+=inc;
                      load->pn=0;
                      //if (load->last_row > load->height) printf("extra one %d    \n",load->last_row);
                    }

                    //if (transparent >= 0 && *picptr != transparent)
                    //    *(picptr+load->maskoffset)=255;
                    //picptr++;
                    //if (++load->XC == this->width)
                    //{
                    //    load->XC=0;
                    //    load->YC++;
                    //    picptr+=load->spritewidth-this->width;
                    //}
                }
            //}
            //else
            //    for (i=OutCount-1; i>=0; i--)
            //        DoInterlace(this, load->OutCode[i], transparent);

            OutCount = 0;

            if (load->JustHadClearCode)
                load->JustHadClearCode = 0;
            else
            {
                /* Build the hash table on-the-fly. No table is stored in the file. */

                load->Prefix[FreeCode] = OldCode;
                load->Suffix[FreeCode] = FinChar;

                /* Point to the next slot in the table.  If we exceed the current
                 * MaxCode value, increment the code size unless it's already 12.  If it
                 * is, do nothing: the next code decompressed better be CLEAR
                 */

                if (++FreeCode >= MaxCode)
                {
    	            if (CodeSize < 12)
    	            {
    	                CodeSize++;
    	                MaxCode *= 2;
    	                ReadMask = (1 << CodeSize) - 1;
    	            }
                }
            }
            OldCode = InCode;
        }
stage2:
        Code = gifstream_ReadCode(load, CodeSize, ReadMask);
        if (Code == -1)
        {
            load->readimagestate=2;
            if (load->dataptr < load->dataend)
                goto restart;
            else
                goto exit;
        }
        if (npixels >= load->maxpixels) break;
    }
    load->state = State_EndImageData;

exit:

    load->CodeSize=CodeSize; load->MaxCode=MaxCode;
    load->ReadMask=ReadMask; load->FreeCode=FreeCode;
    load->npixels=npixels;
    load->OldCode=OldCode;
    load->FinChar=FinChar;

    load->CurCode=CurCode;
    load->InCode=InCode; load->Code=Code;

    return NULL;
}


/* Fetch the next code from the raster data stream.  The codes can be
 * any length from 3 to 12 bits, packed into 8-bit bytes, so we have to
 * maintain our location in the Raster array as a BIT Offset.  We compute
 * the byte Offset into the raster array by dividing this by 8, pick up
 * three bytes, compute the bit Offset into our 24-bit chunk, shift to
 * bring the desired code to the bottom, then mask it off and return it.
 */

static int gifstream_ReadCode(GIFloaddata *load, int CodeSize, int ReadMask)
{
  int RawCode, ByteOffset;

  ByteOffset = load->BitOffset / 8;

  if (load->BitOffset + CodeSize > 8*load->blocksize)
  {
      /* About to bite off more than we can chew. */
      if (load->blocksize - ByteOffset >= 1)
          load->temp[0]=load->temp[ByteOffset];
      if (load->blocksize - ByteOffset >= 2)
          load->temp[1]=load->temp[ByteOffset+1];
      load->BitOffset-=ByteOffset*8;
      load->loadinto=load->blocksize-ByteOffset;
      return -1;
  }
  RawCode = load->temp[ByteOffset] + (load->temp[ByteOffset + 1] << 8);
  if (CodeSize > 8)
    RawCode += ( load->temp[ByteOffset + 2] << 16);
  RawCode >>= (load->BitOffset % 8);
  load->BitOffset += CodeSize;

  return RawCode & ReadMask;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_abandon_image                                                                    *
 *                                                                                            *
 * Remove all data, structures, memory allocations etc. associated with an image.             *
 *                                                                                            *
 * In: handle - identifier for this image (different to the handle used by c.render)          *
 *--------------------------------------------------------------------------------------------*/

static void gifstream_abandon_image(int handle)
{
    gifstream_delete(handle);
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_error                                                                            *
 *                                                                                            *
 * Takes a string in and returns a kernel_oserror.                                            *
 *                                                                                            *
 * In: s - string containing an error message.                                                *
 *                                                                                            *
 * Returns: kernel_oserror block containing the string as the error message                   *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_error(char *s)
{
    static _kernel_oserror e;

    e.errnum=MiscErrorNum;
    sprintf(e.errmess,"Error from GIF stream: %s\n",s);

    return &e;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_valid_handle                                                                     *
 *                                                                                            *
 * Checks to see if a given handle is currently valid.                                        *
 *                                                                                            *
 * In: handle - identifier for the image.                                                     *
 *                                                                                            *
 * Returns: 1 (handle is valid) or 0 (handle not valid)                                       *
 *--------------------------------------------------------------------------------------------*/

static int gifstream_valid_handle(int handle)
{
    if (handle<0)
    {
        debug_print("*** INVALID GIF HANDLE ***");
        return 0;
    }

    if (handle>MaxPics)
    {
        debug_print("*** INVALID GIF HANDLE ***");
        return 0;
    }

    if (!store[handle])
    {
        debug_print("*** INVALID GIF HANDLE ***");
        return 0;
    }

    return 1;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_animated_plot                                                                    *
 *                                                                                            *
 * Plot the current (next) frame of animation on the screen.                                  *
 *                                                                                            *
 * In: handle - identifier for this animation                                                 *
 *     x, y   - co-ordinates to plot at                                                       *
 *     scale  - % scale to plot at                                                            *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_animated_plot(int handle, int x, int y, scale_factor scale)
{
    _kernel_oserror *e;
    GIFloaddata     *load = store[handle];

    e=render_animate_plot(load->render_handle, x, y, scale);

    return e;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_register_filler                                                                  *
 *                                                                                            *
 * Called by client to register a background filler routine for animations. This is called    *
 * before each frame is plotted and will fill in the background.                              *
 *                                                                                            *
 * In: handle - identifier for this animation                                                 *
 *              fill_fn - function to call to fill background                                 *
 *              handle1, handle2 - handles to pass to filler function.                        *
 *                                                                                            *
 * Returns: a handle which will be passed to the filler routine when it is called.            *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* gifstream_register_filler(int handle, FillerFunction *fill_fn, void* handle1, int* handle2)
{
    GIFloaddata *load = store[handle];

    load->fill_fn = fill_fn;
    load->handle1 = handle1;
    load->handle2 = handle2;

    if (store[handle]->flags.render_type==Type_AnimatedSprites)
        render_register_filler(load->render_handle, load->fill_fn, load->handle1, load->handle2);

    return 0;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_make_animation                                                                   *
 *                                                                                            *
 * Called when decoder realises that there's more than one frame (ie. it's an animation).     *
 * Informs render of this.                                                                    *
 *                                                                                            *
 * In: load - structure for this image/animation                                              *
 *                                                                                            *
 * Returns: error, if one occurred, else NULL                                                 *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_make_animation(GIFloaddata *load)
{
    _kernel_oserror *e;
    frame_str        fr;
    int              an_handle, oldstate;

    if (load->flags.render_type!=Type_InternalLZW) return NULL;

    fr.frame_off    = 0;
    fr.delay        = load->delay;
    fr.width        = load->width;
    fr.height       = load->height;
    fr.left         = load->left;
    fr.top          = load->top;
    fr.transparency = load->transparent;
    fr.disposal     = load->disposal;
    fr.haspalette   = 0;
    fr.interlace    = load->Interlace;
    fr.trtab        = 0;

    oldstate=flex_set_budge(0);
    e = render_make_animation(load->render_handle, fr, load->Background,
                              load->screen_width, load->screen_height, load->loops,
                              &an_handle);
    flex_set_budge(oldstate);
    if (e) return e;

    load->flags.render_type = Type_AnimatedSprites;
    load->render_handle     = an_handle;

    e = render_register_filler(load->render_handle, load->fill_fn, load->handle1, load->handle2);
    if (e) return e;

    load->delay=-1;

    return NULL;
}


_kernel_oserror* gifstream_export_sprite(int handle, char* filename)
{
    _kernel_oserror *e = NULL;

    /* If not a valid handle, return */
    if (!gifstream_valid_handle(handle)) return NULL;

    if (store[handle]->flags.render_type==Type_InternalLZW)
        e=render_export_sprite(store[handle]->render_handle, filename);
    else e=render_export_animated_sprites(store[handle]->render_handle, filename);

    return e;
}
@


1.20
log
@Some moron at Adobe has been outputting GIFs containing Application
Extensions with a block size of 10. This is presumably the same moron
that put Adobe APP14 markers in front of JFIF APP0 markers.

ImageLib now copes with this. Sigh.
@
text
@d70 1
d789 1
a789 1
        if (crpixel && 128) load->state = State_ReadGlobalColourMap;
@


1.19
log
@More optimisations - in particular background GIFs are now converted into
the current mode and palette.
Sprite plotter (used for backgrounds) sped up.
Background chunk now read correctly and gamma corrected in PNGs (for
sprite output and use as page backgrounds).
Support for PNG pHYS chunk added.
<8bpp greyscale PNGs where no gamma correction was done didn't work.
@
text
@d1047 1
a1047 1
    int         blocksize, size, len;
d1055 8
d1064 1
a1064 1
    if (load->substage == 0)
d1066 1
a1066 1
        len = min(12 - load->bytes_so_far_in_section, load->dataend - load->dataptr);
d1072 1
a1072 1
        if (load->bytes_so_far_in_section == 12)
d1076 8
a1083 5
            blocksize = *dataptr++;
            strncpy(id,      dataptr, 8); dataptr+=8;
            strncpy(authent, dataptr, 3); dataptr+=3;
            if (strncmp(id,"NETSCAPE",8)==0) load->app_ext_id=NETSCAPE_ID;
            else load->app_ext_id=0;
d1087 1
a1087 1
            load->substage = 1;
d1100 1
a1100 1
    else if (load->substage == 1)
d1102 1
a1102 1
        load->substage      = 2;
d1131 1
a1131 1
            load->substage = 1;
@


1.18
log
@Progressive rendering _really_ fixed - only progressively renders 8 lines
at a time.
@
text
@a2147 11

_kernel_oserror* gifstream_background_colour(int handle, int* bgcol)
{
    if (!gifstream_valid_handle(handle))
    {
        *bgcol = -2;
        return NULL;
    }

    return render_find_background_colour(store[handle]->render_handle, bgcol);
}
@


1.17
log
@Stripped down lzw_[de]comp into a lean, mean compressing machine.
Converted it to 11-bit LZW to save memory in compression tables.
Fixed lots of redraw errors in the GIF code.
Stopped PNG code attempting to do alpha processing on RISC OS 3.1 (we
don't have a ColourTrans to supply the inverse table).
@
text
@d1850 2
a1851 1
                      e=render_row(load->render_handle, &spr_buff);
d1853 1
a1854 1
                      load->last_row++;
@


1.16
log
@Implemented background colour determination for JPEGs and GIFs.
Made basic BGCol routine work on 16 and 32 bpp sprites.
@
text
@d68 2
d229 1
a229 1
static _kernel_oserror* gifstream_read_still_image(GIFloaddata *load, BBox *changed);
d765 10
a774 2
        load->screen_width  = dataptr[0] + (dataptr[1] * 256);
        load->screen_height = dataptr[2] + (dataptr[3] * 256);
d1455 2
a1456 2
        e = gifstream_read_still_image(load, changed);
        now_to = load->last_row - 2;
a1691 2
 *     changed - pointer to bouding box to put the area of the image that has changed as a    *
 *               result of the decoding.                                                      *
d1696 1
a1696 1
static _kernel_oserror *gifstream_read_still_image(GIFloaddata *load, BBox *changed)
@


1.15
log
@Changed a (stuff & 28) to (stuff & 0x1c). Picky, eh?
@
text
@d912 1
a912 1

d2138 11
@


1.14
log
@Fixed crash which can result if a frame overlaps bottom of GIF screen (illegal)
@
text
@d1175 1
a1175 1
        load->disposal    = (stuff & 28) >>2;
@


1.13
log
@Updated change logs for last check-in
@
text
@d66 2
d903 13
a915 5
            if (load->left + load->width > load->screen_width)
                load->screen_width = load->left + load->width;

            if (load->top + load->height > load->screen_height)
                load->screen_height = load->top + load->height;
d1268 1
a1268 2
    int              n;
    int              oldstate;
d1327 4
a1330 1
        e=render_animate_new_frame(load->render_handle, fr, load->Background, &load->spr_buff);
@


1.12
log
@Ensured unnecessary debug code not put in unless TRACE defined.
Adjusts screen size of a GIF if the first frame doesn't fit.
@
text
@d64 2
@


1.11
log
@Added support for the number of repeats field in the Netscape looping
extension.
@
text
@d217 1
d219 1
d680 2
a681 2
               _swi(OS_WriteC, _IN(0), 4);
               _swi(OS_WriteC, _IN(0), 26);
d691 2
a692 2
        _swi(OS_WriteC,_IN(0),4);
        _swi(OS_WriteC,_IN(0),26);
d897 9
d1051 1
d1053 1
@


1.10
log
@Would fail big-time if the LZW minimum code size wasn't the same as the global
colour map size.

Would restrict colour values to the size of the global colour map, so if an
image in an animated GIF had 128 colours while the global map had 64 colours,
it would fail (although this was masked by the above bug - as such an image
would necessarily have a minimum code size > the global colour map size).

Reduced memory usage by 32K per stream by turning the Prefix array into
shorts, and Suffix and OutCode into chars.

Fixed spelling of "colour" in various places.
@
text
@d62 2
d199 1
d328 1
a328 1
   store[n]->flags.loop_forever        = 0;
d1089 3
a1091 1
                load->flags.loop_forever = 1;
d2082 2
a2083 1
                              load->screen_width, load->screen_height, &an_handle);
@


1.9
log
@Made the LZW decompressor cope with streams that don't start with a clear
code.
@
text
@d53 9
d64 3
a66 1
/*                                                                                                         */
a95 2
#define INTERLACEMASK 0x40
#define COLORMAPMASK  0x80
d147 2
a148 2
                ColorMapSize,		    /* number of colors                           */
                Background,		    /* background color                           */
d160 1
a160 1
                BitMask,		    /* AND mask for data size                     */
d164 1
a164 1
    boolean     Interlace, HasColormap;
d178 3
a180 3
    int        *Prefix;                     /* Hash table used by decompressor */
    int        *Suffix;
    int        *OutCode;                    /* Output array used by the decompressor */
d286 1
a286 1
   if (!flex_alloc((flex_ptr) &store[n]->Prefix, 4097 *sizeof(int)))
d292 1
a292 1
   if (!flex_alloc((flex_ptr) &store[n]->Suffix, 4097 *sizeof(int)))
d299 1
a299 1
   if (!flex_alloc((flex_ptr) &store[n]->OutCode, 4097 *sizeof(int)))
d308 3
a310 3
   memset(store[n]->Prefix, 0, sizeof(int)*4096);
   memset(store[n]->Suffix, 0, sizeof(int)*4096);
   memset(store[n]->OutCode, 0, sizeof(int)*4096);
d541 1
a541 1
   report_value("Adding palette, colourmap ", load->HasColormap);
d544 1
a544 1
     if (load->HasColormap)
d761 1
a761 2
        load->ColorMapSize  = 1 << load->BitsPerPixel;
        load->BitMask       = load->ColorMapSize - 1;
d791 1
a791 1
    int         size_of_map = load->ColorMapSize * 3;
d892 3
a894 3
        load->image_bpp   = (load->Misc & 7) +1;
        load->HasColormap = load->Misc & 128;
        load->Interlace   = load->Misc & 64;
d905 1
a905 1
        report_value("  colormap       ",load->HasColormap);
d908 1
a908 1
        if (load->HasColormap) load->state = State_ReadLocalColourMap;
d1244 3
a1246 3
    memset(load->Prefix, 0, sizeof(int)*4096);
    memset(load->Suffix, 0, sizeof(int)*4096);
    memset(load->OutCode, 0, sizeof(int)*4096);
d1259 5
a1271 1
    load->ColorMapSize              = (1 << ((load->Misc &7)+1));
d1313 1
a1313 1
            if (load->HasColormap)
d1522 1
a1522 1
                while (CurCode > BitMask)
d1776 1
a1776 1
                while (CurCode > BitMask)
@


1.8
log
@Correction of bug in LZW decoder which fails to keep track of npixels (pixels output), resulting in imagelib assuming image corruption
@
text
@d49 1
a49 1
/*          18-Sep-97: RML: Added flex_deferred_compaction in gifstream_plot.                              */
d52 1
d147 1
d371 1
a371 1

d604 1
a604 1

d1254 1
a1444 2
        case 1:
            goto stage1;
d1478 1
a1478 43
stage1:
            Code = gifstream_ReadCode(load, CodeSize, ReadMask);

            if (Code==-1)
            {
                load->readimagestate=1;
                if (load->dataptr < load->dataend)
                    goto restart;
                else
                    goto exit;
            }

            CurCode = OldCode = Code;
            FinChar = CurCode & BitMask;

            // *picptr++ = FinChar;
            spr_buff[load->pn++] = FinChar;

            //putpixel(load,FinChar);
            //if (FinChar==transparent) spr_mask[(load->pn)-1]=0;
            //else spr_mask[(load->pn)-1]=255;

            if (++load->XC == load->width) {
              load->spr_buff = render_animate_row(load->render_handle);
              spr_buff = load->spr_buff;
              load->pn = 0;
              load->XC=0;
              load->YC++;
            }

            //if (transparent >= 0 && FinChar != transparent)
            //     spr_mask[load->pn-1]=255;
            //else spr_buff[load->pn-1]=5; //spr_mask[load->pn-1]=0;
            //   *(picptr-1+load->maskoffset)=255;

            //if (++load->XC == this->width)
            //{
            //    load->XC=0;
            //    load->YC++;
            //    picptr+=load->spritewidth-this->width;
            //}

            npixels++;
d1490 19
a1508 3
            /* If greater or equal to FreeCode, not in the hash table yet;
             * repeat the last character decoded
             */
d1510 6
a1515 7
            if (CurCode >= FreeCode)
            {
	        CurCode = OldCode;
	        if (OutCount > 4096)
	            return gifError("outcount1 blew up");
	        load->OutCode[OutCount++] = FinChar;
            }
d1517 1
a1517 4
            /* Unless this code is raw data, pursue the chain pointed to by CurCode
             * through the hash table to its end; each code in the chain puts its
             * associated output code on the output queue.
             */
a1518 5
            while (CurCode > BitMask)
            {
	        if (OutCount > 4096) break;   /* corrupt file */
	        load->OutCode[OutCount++] = load->Suffix[CurCode];
	        CurCode = load->Prefix[CurCode];
a1520 2
            if (OutCount > 4096) { return gifError("outcount blew up"); }

d1571 6
a1576 3
            load->Prefix[FreeCode] = OldCode;
            OldCode = InCode;
            load->Suffix[FreeCode] = FinChar;
d1578 4
a1581 4
            /* Point to the next slot in the table.  If we exceed the current
             * MaxCode value, increment the code size unless it's already 12.  If it
             * is, do nothing: the next code decompressed better be CLEAR
             */
d1583 9
a1591 8
            if (++FreeCode >= MaxCode)
            {
	        if (CodeSize < 12)
	        {
	            CodeSize++;
	            MaxCode *= 2;
	            ReadMask = (1 << CodeSize) - 1;
	        }
d1593 1
a1698 2
        case 1:
            goto stage1;
d1732 1
a1732 39
stage1:
            Code = gifstream_ReadCode(load, CodeSize, ReadMask);
            if (Code==-1)
            {
                load->readimagestate=1;
                if (load->dataptr < load->dataend)
                    goto restart;
                else
                    goto exit;
            }

            CurCode = OldCode = Code;
            FinChar = CurCode & BitMask;
            //if (!Interlace)
            //{
                // *picptr++ = FinChar;
                spr_buff[load->pn++] = FinChar;

                if (load->pn==load->width) {
                  e=render_row(load->render_handle, &spr_buff);
                  if (e) return e;
                  load->pn=0;
                  load->last_row++;
                  //if (load->last_row > load->height) printf("extra one %d    \n",load->last_row);
                }

                //if (transparent >= 0 && FinChar != transparent)
                //    *(picptr-1+load->maskoffset)=255;

                //if (++load->XC == this->width)
                //{
                //    load->XC=0;
                //    load->YC++;
                //    picptr+=load->spritewidth-this->width;
                //}
            //}
            //else
            //    DoInterlace(this, FinChar, transparent);
            npixels++;
d1744 14
a1757 3
            /* If greater or equal to FreeCode, not in the hash table yet;
             * repeat the last character decoded
             */
d1759 4
a1762 7
            if (CurCode >= FreeCode)
            {
	        CurCode = OldCode;
	        if (OutCount > 4096)
	            return gifError("outcount1 blew up");
	        load->OutCode[OutCount++] = FinChar;
            }
d1764 6
a1769 4
            /* Unless this code is raw data, pursue the chain pointed to by CurCode
             * through the hash table to its end; each code in the chain puts its
             * associated output code on the output queue.
             */
d1771 1
a1771 5
            while (CurCode > BitMask)
            {
	        if (OutCount > 4096) break;   /* corrupt file */
	        load->OutCode[OutCount++] = load->Suffix[CurCode];
	        CurCode = load->Prefix[CurCode];
a1773 2
            if (OutCount > 4096) return gifError("outcount blew up");

d1822 5
a1826 1
            /* Build the hash table on-the-fly. No table is stored in the file. */
d1828 2
a1829 3
            load->Prefix[FreeCode] = OldCode;
            OldCode = InCode;
            load->Suffix[FreeCode] = FinChar;
d1831 4
a1834 4
            /* Point to the next slot in the table.  If we exceed the current
             * MaxCode value, increment the code size unless it's already 12.  If it
             * is, do nothing: the next code decompressed better be CLEAR
             */
d1836 9
a1844 8
            if (++FreeCode >= MaxCode)
            {
	        if (CodeSize < 12)
	        {
	            CodeSize++;
	            MaxCode *= 2;
	            ReadMask = (1 << CodeSize) - 1;
	        }
d1846 1
d2091 1
a2091 1

@


1.7
log
@Altered to support new flex_init API
@
text
@d50 2
a54 1
/* render_read_still_image & render_read_animated_image appear to be the wrong way around!                 */
d103 19
d207 1
a207 1
static _kernel_oserror* gifstream_read_animated_image(GIFloaddata *load, BBox *changed);
d214 1
a214 1
static _kernel_oserror* gifstream_read_still_image(GIFloaddata *load, BBox *changed);
d305 1
a305 1
   store[n]->state                   = 1;
d309 1
a309 1
   store[n]->flags.render_type       = 1;
d319 1
a319 1
   store[n]->flags.render_type         = 1;
d370 1
a370 1
    if (load->flags.render_type==2)
d410 1
a410 1
   if (load->flags.render_type==1) e=render_delete(load->render_handle);
d465 1
a465 1
   if (store[handle]->flags.render_type==2)
d504 1
a504 1
    if (load->flags.render_type==1) e=render_whole_scaled(load->render_handle,x,y,scale);
d551 1
a551 1
   if (load->flags.render_type==1) e=render_mode_change(load->render_handle);
d577 1
a577 1
    if (load->flags.render_type==1) return 1;
a610 1
        //printf("state %d\n",load->state);
d613 1
a613 1
            case 1:
d616 1
a616 1
            case 2:
d619 1
a619 1
            case 3:
d622 1
a622 1
            case 4:
d625 1
a625 1
            case 10:
d628 1
a628 1
                load->state=5;
d630 1
a630 1
            case 5:
d633 1
a633 1
            case 11:
d636 1
a636 1
            case 12:
d639 1
a639 1
            case 13:
d642 1
a642 1
            case 6:
d645 1
a645 1
            case 7:
d648 1
a648 1
            case 8:
d651 1
a651 1
            case 14:
d653 1
a653 1
               e=gifstream_read_still_image(load, changed);
d656 1
a656 1
            case 15:
d659 1
a659 1
            case 9:
d711 1
a711 1
        load->state=2;
d759 2
a760 2
        if (crpixel && 128) load->state=3;
        else load->state=4;
d791 1
a791 1
        load->state=10;
d824 1
a824 1
    load->state = 10;
d857 1
a857 1
            load->state=9;
d871 1
a871 1
            load->state=9;
d898 2
a899 2
        if (load->HasColormap) load->state=7;
        else load->state=8;
d931 1
a931 1
        load->state=8;
d968 1
a968 1
            load->state=6;
d974 5
a978 5
        if      (code==0xFF) load->state = 11;   /* Application extension     */
        else if (code==0xF9) load->state = 12;   /* Graphic control extension */
        else if (code==0xFE) load->state = 13;   /* Comment extension         */
        else if (code==0x01) load->state = 13;   /* Plain text extension      */
        else                 load->state = 13;   /* Unrecognised extension    */
d1052 1
a1052 1
            load->state=5;
d1121 1
a1121 1
        load->state = 5;
d1186 1
a1186 1
            load->state=5;
d1271 1
a1271 1
    if (load->flags.render_type==1)
d1292 1
a1292 1
    if (load->flags.render_type==2)
d1312 1
a1312 1
    load->state = 14;
d1334 1
a1334 1
    if (load->flags.render_type==1)
d1352 1
a1352 1
    load->state = 10;
d1360 1
a1360 1
        if (load->flags.render_type==2) render_mark_corrupt_frame(load->render_handle);
d1364 1
a1364 1
    if (load->flags.image_fast) load->state=9;
d1371 1
a1371 1
 * gifstream_read_still_image                                                                 *
d1381 1
a1381 1
_kernel_oserror *gifstream_read_still_image(GIFloaddata *load, BBox *changed)
d1396 1
a1396 1
    if (load->flags.render_type==1)
d1398 1
a1398 1
        e = gifstream_read_animated_image(load, changed);
a1406 6
    /*
    if (this->private_data2==NULL)
        return gifError("Insufficient memory");
    load->ptr = (byte *)this->private_data2+this->private_data2[12] + 16 + load->YC * load->spritewidth + load->XC;
    */

d1416 2
a1417 1
            load->state=15;
d1639 1
a1639 4
    load->state=15;

    report_value("  EOFCode  ",EOFCode);
    report_value("  code     ",Code);
d1664 1
a1664 1
 * gifstream_read_animated_image                                                              *
d1675 1
a1675 1
static _kernel_oserror *gifstream_read_animated_image(GIFloaddata *load, BBox *changed)
a1694 6
    /*
    if (this->private_data2==NULL)
        return gifError("Insufficient memory");
    load->ptr = (byte *)this->private_data2+this->private_data2[12] + 16 + load->YC * load->spritewidth + load->XC;
    */

d1704 2
a1705 1
            load->state=15;
d1922 1
a1922 1
    load->state=15;
a1925 63
/*
    if (!Interlace)
    {
        if (load->YC > OrigYC)
        {
            changed->xmax=this->width_os;
            changed->ymax=(this->height-OrigYC)*this->height_os/this->height;
            changed->ymin=(this->height-load->YC)*this->height_os/this->height;
        }
    }
    else
    {
        if (load->YC != OrigYC)
        {
            byte *sptr=(byte *)this->private_data2+this->private_data2[12] + 16;
            byte *mptr=(transparent>=0)?sptr+load->maskoffset:NULL;
            int linesize=load->spritewidth;

            changed->xmax=this->width_os;
            if (load->YC >= OrigYC && load->Pass >= OrigPass+1 ||
                load->YC <= OrigYC && load->Pass >= OrigPass+2)
            {
                changed->ymax=this->height_os;
                changed->ymin=0;
            }
            else
            {
                changed->ymax=(this->height-OrigYC)*this->height_os/this->height;
                changed->ymin=(this->height-load->YC)*this->height_os/this->height;
                switch (load->Pass)
                {
                  case 1:
                    changed->ymin-=3*this->height_os/this->height;
                    break;
                  case 2:
                    changed->ymin-=1*this->height_os/this->height;

                    break;
                }
            }
 */
            /* Now to fill in the interlaced bits */
    //        if (OrigPass==load->Pass)
                /* We're on the same pass */
    //            FillInInterlace(sptr, mptr, OrigYC, load->YC, OrigPass-1, OrigPass, linesize, this->height);
    //        else if (OrigYC > load->YC)
    //        {
                /* We're on a later pass, above the previous end point */
    //            FillInInterlace(sptr, mptr, 0, load->YC, OrigPass, load->Pass, linesize, this->height);
    //            FillInInterlace(sptr, mptr, load->YC, OrigYC, OrigPass, load->Pass-1, linesize, this->height);
    //            FillInInterlace(sptr, mptr, OrigYC, this->height, OrigPass-1, load->Pass-1, linesize, this->height);
    //        }
    //        else
    //        {
                /* We're on a later pass, below the previous end point */
    //            FillInInterlace(sptr, mptr, 0, OrigYC, OrigPass, load->Pass, linesize, this->height);
    //            FillInInterlace(sptr, mptr, OrigYC, load->YC, OrigPass-1, load->Pass, linesize, this->height);
    //            FillInInterlace(sptr, mptr, load->YC, this->height, OrigPass-1, load->Pass-1, linesize, this->height);
    //        }
    //    }
    //}


a1934 3
    //report_value("npixels   ",load->npixels);
    //report_value("maxpixels ",load->maxpixels);

d2087 1
a2087 1
    if (store[handle]->flags.render_type==2)
d2111 1
a2111 1
    if (load->flags.render_type!=1) return NULL;
d2131 1
a2131 1
    load->flags.render_type = 2;
d2150 2
a2151 1
    if (store[handle]->flags.render_type==1) e=render_export_sprite(store[handle]->render_handle, filename);
@


1.6
log
@Changes for flex_deferred_compaction to work
@
text
@d481 1
a481 1
    old_deferred_state = flex_deferred_compaction(0);
d489 1
a489 1
    flex_deferred_compaction(old_deferred_state);
@


1.5
log
@DumpSprite for GIFs now implemented
@
text
@d49 1
d474 1
a474 1
    int              oldstate;
d479 3
a481 1
    oldstate=flex_set_budge(0);
d483 2
a484 1
    if (load->flags.render_type==1)  e=render_whole_scaled(load->render_handle,x,y,scale);
a485 1

d488 3
a490 1
    flex_set_budge(oldstate);
@


1.4
log
@Fixed problem with changed areas returned by LoadGIF for interlacad images
@
text
@d480 1
a480 1
    if (load->flags.render_type==1) e=render_whole_scaled(load->render_handle,x,y,scale);
d482 1
d2195 14
@


1.3
log
@EndLoad now returns a BBox; Corrected flex problems on 3.1 machines; Corrected 16 colour mode bug.
@
text
@d577 2
d1358 12
a1369 15
    //GIFloaddata *load=(GIFloaddata *) this->private_data;
    //byte *picptr;
    int i;
    int len;
    int CodeSize=load->CodeSize, MaxCode=load->MaxCode,
        ReadMask=load->ReadMask, FreeCode=load->FreeCode,
        CurCode=load->CurCode, OldCode=load->OldCode,
        FinChar=load->FinChar,
        npixels=load->npixels, InCode=load->InCode, Code=load->Code;
    int OutCount=0;
    const int ClearCode=load->ClearCode, EOFCode=load->EOFCode,
            //transparent=load->transparent, Interlace=load->Interlace,
            BitMask=load->BitMask;
    //int OrigYC=load->YC, OrigPass=load->Pass;
    char *spr_buff;
d1371 8
a1378 1
    if (load->flags.render_type==1) return gifstream_read_animated_image(load, changed);
d1382 5
a1386 3
    //if (this->private_data2==NULL)
    //    return gifError("Insufficient memory");
    //load->ptr = (byte *)this->private_data2+this->private_data2[12] + 16 + load->YC * load->spritewidth + load->XC;
d1661 11
a1671 20
    //GIFloaddata *load=(GIFloaddata *) this->private_data;
    //byte *picptr;
    int i;
    int len;
    int CodeSize=load->CodeSize, MaxCode=load->MaxCode,
        ReadMask=load->ReadMask, FreeCode=load->FreeCode,
        CurCode=load->CurCode, OldCode=load->OldCode,
        FinChar=load->FinChar,
        npixels=load->npixels, InCode=load->InCode, Code=load->Code;

    int OutCount=0;

    const int ClearCode=load->ClearCode, EOFCode=load->EOFCode,
            //transparent=load->transparent, Interlace=load->Interlace,
            BitMask=load->BitMask;
    //int OrigYC=load->YC, OrigPass=load->Pass;
    char *spr_buff;
    int now_to;

    //printf("gifstream_read_image - bytes so far %d\n", load->bytes_so_far_in_section);
d1678 5
a1682 3
    //if (this->private_data2==NULL)
    //    return gifError("Insufficient memory");
    //load->ptr = (byte *)this->private_data2+this->private_data2[12] + 16 + load->YC * load->spritewidth + load->XC;
a1984 6


    /* RML */
    now_to = load->last_row - 2;
    render_changed(load->render_handle, load->last_bounded, now_to, changed);
    load->last_bounded = now_to;
@


1.2
log
@mutable_mask in the GIF code was being erroneously set
@
text
@d47 2
a231 1
   GIFloaddata *load;
a249 2
   load=store[n];

d251 1
a251 1
   memset(load, 0, sizeof *load);
d254 1
a254 1
   if (!flex_alloc((flex_ptr) &load->Prefix, 4097 *sizeof(int)))
d260 1
a260 1
   if (!flex_alloc((flex_ptr) &load->Suffix, 4097 *sizeof(int)))
d262 1
a262 1
       flex_free((flex_ptr) &load->Prefix);
d267 1
a267 1
   if (!flex_alloc((flex_ptr) &load->OutCode, 4097 *sizeof(int)))
d269 2
a270 2
       flex_free((flex_ptr) &load->Prefix);
       flex_free((flex_ptr) &load->Suffix);
d276 13
a288 12
   memset(load->Prefix, 0, sizeof(int)*4096);
   memset(load->Suffix, 0, sizeof(int)*4096);
   memset(load->OutCode, 0, sizeof(int)*4096);

   load->transparent             = -1;
   load->width=load->height      = -1;
   load->render_handle           = -1;
   load->state                   = 1;
   load->bytes_so_far_in_section = 0;
   load->current_frame           = 0;
   load->last_full_frame         = -1;
   load->flags.render_type       = 1;
d291 10
a300 10
   load->flags.image_fast          = 0;
   load->flags.background          = 0;
   load->flags.loop_forever        = 0;
   load->flags.client_stream_ended = 0;
   load->flags.regen_tables        = 0;
   load->flags.mutable_mask        = 0;
   load->flags.load_ended          = 0;
   load->flags.render_type         = 1;
   load->flags.lpb                 = 0;
   load->flags.unused              = 0;
d302 1
a302 1
   if (flags && IMAGE_FAST) load->flags.image_fast = 1;
d343 2
a344 2
   _kernel_oserror *e = NULL;
   GIFloaddata     *load = store[handle];
d346 9
a354 2
   /* If not a valid handle, return */
   if (!gifstream_valid_handle(handle)) return NULL;
d356 4
a359 6
   if (load->flags.render_type==2)
   {
     if (!load->flags.client_stream_ended) gifstream_end_image_data(load);
     e=render_animate_end(load->render_handle);
     if (e) return e;
   }
d361 1
a361 6
   /* Free the tables used by the GIF decompressor */
   if (store[handle]->Prefix) flex_free((flex_ptr) &store[handle]->Prefix);
   if (store[handle]->Suffix) flex_free((flex_ptr) &store[handle]->Suffix);
   if (store[handle]->OutCode) flex_free((flex_ptr) &store[handle]->OutCode);

   return NULL;
a395 2
   //if (e) return e;

a423 1
   GIFloaddata     *load = store[handle];
d427 2
d439 3
a441 3
   if (load->width>0) {
     w=load->screen_width;
     h=load->screen_height;
d444 2
a445 2
   if (load->flags.render_type==2)
       load->flags.mutable_mask = 0;
d449 2
a450 2
   *return_mask   = load->flags.mutable_mask;
   *return_anim   = load->flags.render_type - 1;
d471 6
a476 2
   GIFloaddata     *load = store[handle];
   _kernel_oserror *e;
d478 1
a478 2
   /* If not a valid handle, return */
   if (!gifstream_valid_handle(handle)) return NULL;
d480 3
a482 2
   if (load->flags.render_type==1) e=render_whole_scaled(load->render_handle,x,y,scale);
   else e=gifstream_animated_plot(handle, x, y, scale);
d484 1
a484 5
   if (e)
   {
       gifstream_abandon_image(handle);
       return e;
   }
d486 1
a486 1
   return NULL;
d523 1
a523 1
   _kernel_oserror *e;
d527 1
d529 1
a529 7
   if (e)
   {
       gifstream_abandon_image(handle);
       return e;
   }

   return NULL;
d575 2
a576 1

d625 1
d627 1
d672 1
a672 2
    const byte *dataptr=load->dataptr;
    int         len = min(6-load->bytes_so_far_in_section, load->dataend-load->dataptr);
d674 1
a674 1
    memcpy(load->temp + load->bytes_so_far_in_section, dataptr, len);
a845 9
            //int n;
            //return gifstream_error("Corrupt GIF file.");
            //dataptr-=10;
            //for (n=0; n<1000; n++) printf("%d ",dataptr[n]);
            //dataptr+=10;
            //printf("\n\n");
            //printf("data    %d\n",(int)load->dataptr);
            //printf("dataend %d\n",(int)load->dataend);
            //_swi(OS_ReadC,0);
d1202 1
d1255 1
d1257 1
d1264 1
d1281 1
d1305 1
d1309 1
d1311 1
d1316 1
d1318 1
d1991 2
a1992 2
    report_value("npixels   ",load->npixels);
    report_value("maxpixels ",load->maxpixels);
d2168 1
a2168 1
    int              an_handle;
d2184 1
d2187 1
@


1.1
log
@First commit to CVS
@
text
@d45 2
d161 1
a161 1
    int           screen_width;               // Screen width (in GIF terms, not OS terms)
d452 1
a452 1

d486 1
a486 1

d511 1
a511 1
                                                                (load->local_pal[i*3+2]<<24);
d805 1
a805 1

d839 1
a839 1
        if (load->current_frame==1)
d858 1
a858 1
            //_swi(OS_ReadC,0);
d1059 1
a1059 1

d1064 1
a1064 1
            }
d1164 1
a1164 1

d1227 1
a1227 1
    if (load->Interlace && load->transparent) load->flags.mutable_mask=true;
d1694 1
a1694 1
            load->dataptr--;
d1738 1
a1738 1
        else
d2068 1
a2068 1
}
d2174 1
a2174 1

d2196 1
a2196 1

d2198 1
a2198 1

d2200 1
a2200 1
}
@

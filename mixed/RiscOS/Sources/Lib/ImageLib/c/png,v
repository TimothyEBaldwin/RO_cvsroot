head	1.29;
access;
symbols
	ImageLib-0_09:1.29
	ImageLib-0_08:1.29
	ImageLib-0_07:1.29
	ImageLib-0_06:1.29
	ImageLib-0_05:1.29
	ImageLib-0_04:1.29
	ImageLib-0_03:1.28
	ImageLib-0_02:1.28
	ImageLib-0_01:1.28
	dcotton_autobuild_BaseSW:1.28
	ahodgkin_207release:1.27
	ahodgkin_206release:1.27
	ahodgkin_205release:1.27
	ahodgkin_133beta:1.24
	kbracey_126beta:1.15
	kbracey_AW97patch:1.11
	ahodgkin_AW97:1.9;
locks; strict;
comment	@# @;


1.29
date	2006.03.13.22.03.47;	author ahodgkin;	state Exp;
branches;
next	1.28;

1.28
date	99.03.09.14.20.55;	author kbracey;	state Exp;
branches;
next	1.27;

1.27
date	98.03.23.13.29.20;	author kbracey;	state Exp;
branches;
next	1.26;

1.26
date	98.03.06.12.29.33;	author kbracey;	state Exp;
branches;
next	1.25;

1.25
date	98.03.03.11.32.08;	author kbracey;	state Exp;
branches;
next	1.24;

1.24
date	98.02.04.18.09.36;	author kbracey;	state Exp;
branches;
next	1.23;

1.23
date	98.01.30.16.24.09;	author kbracey;	state Exp;
branches;
next	1.22;

1.22
date	98.01.29.17.51.49;	author kbracey;	state Exp;
branches;
next	1.21;

1.21
date	97.11.27.12.35.45;	author kbracey;	state Exp;
branches;
next	1.20;

1.20
date	97.11.25.10.22.40;	author kbracey;	state Exp;
branches;
next	1.19;

1.19
date	97.11.12.11.15.02;	author kbracey;	state Exp;
branches;
next	1.18;

1.18
date	97.11.07.15.12.35;	author kbracey;	state Exp;
branches;
next	1.17;

1.17
date	97.11.06.18.00.50;	author kbracey;	state Exp;
branches;
next	1.16;

1.16
date	97.11.04.15.27.45;	author kbracey;	state Exp;
branches;
next	1.15;

1.15
date	97.10.30.16.25.47;	author kbracey;	state Exp;
branches;
next	1.14;

1.14
date	97.10.30.09.38.08;	author kbracey;	state Exp;
branches;
next	1.13;

1.13
date	97.10.29.14.19.58;	author kbracey;	state Exp;
branches;
next	1.12;

1.12
date	97.10.27.18.14.34;	author kbracey;	state Exp;
branches;
next	1.11;

1.11
date	97.10.22.16.57.34;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	97.10.21.15.47.26;	author kbracey;	state Exp;
branches;
next	1.9;

1.9
date	97.10.15.12.54.46;	author kbracey;	state Exp;
branches;
next	1.8;

1.8
date	97.10.15.12.23.51;	author kbracey;	state Exp;
branches;
next	1.7;

1.7
date	97.10.14.17.45.51;	author kbracey;	state Exp;
branches;
next	1.6;

1.6
date	97.10.14.13.45.55;	author kbracey;	state Exp;
branches;
next	1.5;

1.5
date	97.10.10.20.10.09;	author kbracey;	state Exp;
branches;
next	1.4;

1.4
date	97.09.12.14.07.54;	author rleggett;	state Exp;
branches;
next	1.3;

1.3
date	97.09.05.15.19.09;	author rleggett;	state Exp;
branches;
next	1.2;

1.2
date	97.09.05.13.17.21;	author rleggett;	state Exp;
branches;
next	1.1;

1.1
date	97.07.21.12.24.39;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.29
log
@  API extension. Save area fix. Draw file dump fix.
Detail:
  API extension: DumpToCache for Draw files will dump the original Draw
  file, officially. "is_drawfile" flag in info structure accompanies it.
  Save area fix: All redirections to sprites failed to use save areas,
  so if output was already redirected there could be dire consequences.
  Local save areas now used throughout. Draw file dumping: Would only
  work for < 32K colour modes that could be mapped to old mode numbers
  and used current colour depth. Now always outputs in 16M colours.
  RISC OS 3.1 support therefore compromised, but ChangeFSI can cope.
Admin:
  Tested with Browse. New facilities work as expected. Countless other
  bugs remain (particularly with the Export facilities).

Version 0.04. Tagged as 'ImageLib-0_04'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*-------------------------------------------------------------------------------------------*/
/* File:    c.png                                                                            */
/* Purpose: PNG plotting component of the image library.                                     */
/* Author:  Kevin Bracey                                                                     */
/* History: 06-May-97: RML: Modified Render routine to take an x and y size to scale to,     */
/*                          instead of a percentage.                                         */
/*          21-Oct-97: KJB: Stopped attempting alpha processing on pre-RISC OS 3.5 machines. */
/*-------------------------------------------------------------------------------------------*/

/*
 * Copyright (c) 1996 Acorn RISC Technologies. All rights reserved.
 */

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>

#include "swis.h"

#include "imagetrans.h"
#include "defines.h"
#include "datastruct.h"
#include "internal.h"
#include "sprite.h"

#include "PNG/png.h"

#include "png.h"

#include "riscospal.h"

typedef unsigned char bool;
#define false 0
#define true 1

#define SCREEN_GAMMA 2.2

#define DITHERING

/*#define GIVE_WARNINGS*/

#define MODE(t,x,y) (((t) << 27) | ((x) << 14) | ((y) << 1) | 1)

#define PutSprite 34
#define PutSpriteScaled 52
#define PutSpriteScaled_UseMask 0x08
#define PutSpriteScaled_UsePalette 0x10
#define PutSpriteScaled_WideTable 0x20
#define PutSpriteScaled_Dithered 0x40
#define GenerateTable_WideTable 0x10

#define pngError imgtrnsError

#define max(a, b) (a>b ? a : b)
#define min(a, b) (a<b ? a : b)

static int osver;
static int log2bpp;
static png_bytep screen_to_1, screen_from_1;
static int ct32k_buffer[3];
static char *ro310_2nd_table;

static _kernel_oserror *LoadPNG(Image *this, const char *data, int len, BBox *changed);
static _kernel_oserror *EndLoad(Image *this, BBox *changed);
static _kernel_oserror *Delete(Image *this);
static _kernel_oserror *RenderPNG(Image *this, int x, int y, int scale, int x_size, int y_size);
static _kernel_oserror *ModeChangePNG(Image *this);
static _kernel_oserror *DumpToCache(Image *this, const char *filename, int *justuseorig);
static _kernel_oserror *LoadFromCache(Image *this, const char *filename);
static _kernel_oserror *StartExportPNG(Image *this, int *size);
static _kernel_oserror *BGColPNG(Image *this, int *bgcol, int dontoverride);
static _kernel_oserror *RegisterFiller(Image *this, FillerFunction *fill_fn, void *handle1, int *handle2);
static _kernel_oserror *SaveSpriteAlphaPNG(Image *this, const char *filename, int maxbpp);

typedef struct png_loaddata
{
    int spritewidth;
    int maskwidth;
    unsigned int finished:1;
    unsigned int eightbpphack:1; /* Processing 8bpp + alpha data */
    unsigned int have_bkgd:1;
    unsigned int have_bkgd_index:1;
    unsigned int isreally32bit:1;
    unsigned int convto16bit:1;
    unsigned int removemask:1;
    unsigned int bkgd;           /* Background colour (BBGGRRNN in file gamma, NN=palette number) */
    #ifdef TRACE
    FILE *trace;
    #endif
    png_struct *png_ptr;
    png_info *info_ptr;
    int sprite_offset;
    int mask_offset;
    int available_rows;
    const char *errmess;
    BBox changed;
    png_byte *temp;
    int color_type;
    png_bytep file_to_1;
    png_bytep file_to_screen;
    FillerFunction *filler;
    void *filler_handle1;
    int *filler_handle2;

} PNGloaddata;

static void info_callback(png_struct *, png_info *);
static void row_callback(png_struct *, png_byte *, png_uint_32, int);
static void end_callback(png_struct *, png_info *);
static void png_premultiply_and_gamma_correct(png_structp png_ptr, png_row_infop row_info, png_bytep row);

static void my_error_fn(png_struct *png_ptr, png_const_charp errmess)
{
    *(const char **)png_get_error_ptr(png_ptr) = errmess;
}

#ifdef GIVE_WARNINGS
static void my_warn_fn(png_struct *png_ptr, png_const_charp errmess)
{
    _kernel_oserror er;
    er.errnum = 1;
    strcpy(er.errmess, errmess);
    wimp_report_error(&er, 0, "LibPNG");
}
#endif

/*
 * Used on RISC OS 3.1, whose ColourTrans can't give us this table.
 */
static void load_inversetable(void)
{
    char fname[256];
    extern void colour_table_leaf_to_path(char *path, const char *leaf);
    _kernel_oserror *e;
    char *itable;

    colour_table_leaf_to_path(fname, "8desktop");

    itable = malloc(32768);
    if (!itable)
        return;

    e = _swix(OS_File, _INR(0,3), 16, fname, itable, 0);
    if (e)
    {
        free(itable);
        return;
    }

    ct32k_buffer[0] = 0x2E4B3233;
    ct32k_buffer[1] = (int) itable;
    ct32k_buffer[2] = 0x2E4B3233;
}

int NewPNG(Image *im)
{
    PNGloaddata *load;
    png_info *info_ptr;
    png_struct *png_ptr;
    int oldbudge;

    oldbudge = flex_set_budge(1);

    load=(PNGloaddata *)(im->private_data=malloc(sizeof(PNGloaddata)));

    if (!load)
        goto abort1;

    memset(load, 0, sizeof *load);

    /* Sort out error functions */
#ifdef GIVE_WARNINGS
    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, &load->errmess, my_error_fn, my_warn_fn);
#else
    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, &load->errmess, my_error_fn, NULL);
#endif
    if (!png_ptr)
        goto abort2;

    info_ptr = png_create_info_struct(png_ptr);
    if (!info_ptr)
        goto abort3;

    png_set_progressive_read_fn(png_ptr, im, info_callback, row_callback, end_callback);

#ifdef GIVE_WARNINGS
    png_set_crc_action(png_ptr, PNG_CRC_WARN_USE, PNG_CRC_WARN_DISCARD);
#else
    png_set_crc_action(png_ptr, PNG_CRC_ERROR_QUIT, PNG_CRC_WARN_DISCARD);
#endif

    if (osver==0)
        _swix(OS_Byte, _INR(0,2)|_OUT(1), 129, 0, 255, &osver);

    im->Load=LoadPNG;
    im->DumpSprite=SaveSpritePNG;
    im->EndLoad=EndLoad;
    im->Delete=Delete;
    im->Render=RenderPNG;
    /*im->ModeChange=ModeChange;*/
    im->LoadFromCache=LoadFromCache;
    im->DumpToCache=DumpToCache;
    im->StartExport=StartExportPNG;
    im->Export=Export;
    im->EndExport=EndExport;
    im->BGCol=BGColPNG;
    im->NeedRedraw=0;
    im->RegisterFiller=RegisterFiller;

    im->table=NULL;
    im->private_data2=NULL;
    im->width=im->height=im->width_os=im->height_os=-1;
    im->animated=0;

    memset(im->factors, 0, sizeof im->factors);

    im->transparent=0;
    im->mutable_mask=0;
    im->private_data=load;

    load->png_ptr = png_ptr;
    load->info_ptr = info_ptr;

    #ifdef TRACE
    {
        char name[256];
        sprintf(name, "ADFS::4.$.Trace.Lib.%p", im);
        load->trace=fopen(name, "w");
    }
    #endif

    flex_set_budge(oldbudge);

    return 0;

  abort3:
    png_destroy_read_struct(&png_ptr, (png_infopp) NULL, (png_infopp) NULL);
  abort2:
    free(load);
  abort1:
    flex_set_budge(oldbudge);
    return -1;
}

static int hourglass_on;

/*****************************/
static _kernel_oserror *LoadPNG(Image *this, const char *data, int len, BBox *changed)
{
    PNGloaddata *load=(PNGloaddata *) this->private_data;
    volatile int oldbudge = -1;

    if (changed)
        memset(changed, 0, sizeof(BBox));

    load->changed.xmin = 0;
    load->changed.ymin = 0x10000000;
    load->changed.xmax = 0;
    load->changed.ymax = 0;

    if (setjmp(load->png_ptr->jmpbuf))
    {
        flex_set_budge(oldbudge);
        if (hourglass_on)
        {
            _swix(Hourglass_Off, 0);
            hourglass_on = 0;
        }

        return pngError(load->errmess);
    }

    oldbudge = flex_set_budge(-1);

    png_process_data(load->png_ptr, load->info_ptr, (png_byte *) data, len);

    flex_set_budge(oldbudge);

    if (changed)
    	*changed = load->changed;

    return NULL;
}

static png_bytep make_gamma_table(png_struct *png_ptr, double g)
{
    png_bytep table;
    int i;

    table = malloc(256);
    if (!table)
        png_error(png_ptr, "Insufficient memory");

    for (i = 1; i <= 254; i++)
    {
       table[i] = (png_byte)(pow((double)i / 255.0, g) * 255.0 + .5);
    }
    table[0] = 0;
    table[255] = 255;

    return table;
}

/*
 * This routine is called as soon as the PNG library has received
 * everything up to the first image data chunk.
 */
void info_callback(png_struct *png_ptr, png_info *info)
{
    Image *this = (Image *) png_get_progressive_ptr(png_ptr);
    PNGloaddata *load = (PNGloaddata *) this->private_data;
    int mem;
    unsigned int mode;
    int pal_entries;
    _kernel_oserror *e;
    int r1, r2, r3;
    png_colorp palette;
    int num_palette;
    bool have_mask;
    int riscos_rowbytes;
    png_bytep trans = NULL;
    int num_trans = 0;
    png_color_16p trans_values = NULL;
    png_uint_32 width, height;
    int bit_depth, color_type, interlace_type;
    png_color_16p background;
    #ifdef DO_pHYs
    png_uint_32 res_x = 1, res_y = 1;
    int unit_type = PNG_RESOLUTION_UNKNOWN;
    #endif

    /*
     * Get the basic image information from the library
     */
    png_get_IHDR(png_ptr, info, &width, &height, &bit_depth, &color_type, &interlace_type, NULL, NULL);
    png_get_PLTE(png_ptr, info, &palette, &num_palette);

    /*
     * First, decide if we're going to do full alpha processing (ie
     * manual compositing onto the background). If the image has an
     * alpha channel, then we do. Also, if the image is paletted
     * with some palette entries semi-transparent, then we need
     * to composite. This choice affects how we set up the library
     * later.
     */
    if (color_type & PNG_COLOR_MASK_ALPHA)
    {
        this->full_alpha = 1;
    }
    else if (color_type == PNG_COLOR_TYPE_PALETTE)
    {
        if (png_get_tRNS(png_ptr, info, &trans, &num_trans, &trans_values))
        {
            int i;
            for (i = 0; i < num_trans; i++)
                if (trans[i] != 0 && trans[i] != 255)
                {
                    this->full_alpha = 1;
                    break;
                }
        }
    }

    /*
     * If we're compositing, we will need to make ourselves some lovely gamma
     * tables. Maybe pnglib could be persuaded to do these?
     *
     * We also generate them if we have a background chunk - one
     * of the tables is used below.
     */
    if (this->full_alpha || png_get_valid(png_ptr, info, PNG_INFO_bKGD))
    {
        /* Make some extra gamma tables... */
        double g;
        int i;

        /*
         * file gamma -> linear
         */
        if (png_get_gAMA(png_ptr, info, &g))
            g = 1.0 / g;
        else
            g = SCREEN_GAMMA;

        load->file_to_1 = make_gamma_table(png_ptr, g);

        /*
         * file gamma -> screen gamma
         */
        if (png_get_gAMA(png_ptr, info, &g))
            g = 1.0 / (g * SCREEN_GAMMA);
        else
            g = 1.0;

        load->file_to_screen = make_gamma_table(png_ptr, g);

        /*
         * screen gamma -> linear
         */
        if (!screen_from_1)
            screen_from_1 = make_gamma_table(png_ptr, 1.0 / SCREEN_GAMMA);

        /*
         * linear -> screen gamma
         */
        if (!screen_to_1)
            screen_to_1 = make_gamma_table(png_ptr, SCREEN_GAMMA);
    }

    /*
     * If it's got 16-bits per channel (ie GG, RRGGBB or RRGGBBAA) we
     * tell pnglib to strip it down to 8-bits per channel
     */
    if (bit_depth == 16)
        png_set_strip_16(png_ptr);

    /*
     * If it's got less than 8-bits per channel, then if we're
     * compositing, tell the library to unpack it to one pixel
     * per byte - this makes our lives easier. If we're not
     * compositing, then we keep it packed, but reverse the
     * pixel order to match RISC OS sprites
     */
    if (bit_depth < 8)
    {
        if (this->full_alpha)
            png_set_packing(png_ptr);
        else
            png_set_packswap(png_ptr);
    }

    /*
     * If it's a true-colour image and we're not compositing, and
     * we're on RISC OS 3.5 or later, check the sBIT chunk. If
     * all channels contain 5-bits of data or less, we will
     * output a 16-bpp sprite instead of a 32-bpp sprite. Pnglib
     * can't do this, so we will do it ourselves in row_callback.
     */
    if ((color_type == PNG_COLOR_TYPE_RGB ||
         color_type == PNG_COLOR_TYPE_RGB_ALPHA) && osver >= 0xA5)
    {
        png_color_8p sig_bit;

        if (!this->full_alpha && png_get_sBIT(png_ptr, info, &sig_bit))
        {
            if (sig_bit->red <= 5 && sig_bit->green <= 5 && sig_bit->blue <= 5)
                load->convto16bit=1;
        }
    }

    /*
     * If it's a RGB image, then the data will come out as RR GG BB. For
     * a RISC OS sprite we need it to be RR GG BB 00. If we're converting
     * to 16-bit later, we get the library to use 0xFF as the filler.
     * This simplifies mask handling later.
     */
    if (color_type == PNG_COLOR_TYPE_RGB)
        png_set_filler(png_ptr, load->convto16bit ? 255 : 0, PNG_FILLER_AFTER);

    /*
     * Can't handle RGB data with transparency - need to know data
     * values pre-gamma to handle the tRNS chunk. So we get the library
     * to turn it into RGBA. Also, 16-bit greyscale will have to be turned into
     * grey+alpha, because we've lost the least-significant byte of the
     * pixel data. Greyscale of <=8bpp can be handled because we don't
     * gamma-correct the data.
     */
    if (png_get_valid(png_ptr, info, PNG_INFO_tRNS))
    {
        if (color_type == PNG_COLOR_TYPE_RGB ||
            color_type == PNG_COLOR_TYPE_GRAY && bit_depth == 16)
            png_set_expand(png_ptr);
    }

    /*
     * If it's a colour image, and we're not compositing, tell the
     * library what gamma to use. If it's greyscale or we're
     * compositing, we handle gamma ourselves, by correcting
     * the palette or in png_premultiply_***, respectively.
     */
    if (!this->full_alpha)
    {
        if (color_type & PNG_COLOR_MASK_COLOR) /* We do greyscale ourselves */
        {
            double gamma;

            if (png_get_gAMA(png_ptr, info, &gamma))
                png_set_gamma(png_ptr, SCREEN_GAMMA, gamma);
            else
                png_set_gamma(png_ptr, SCREEN_GAMMA, 1.0 / SCREEN_GAMMA);
        }
    }
    else
    {
        if (color_type != PNG_COLOR_TYPE_PALETTE)
            png_set_read_user_transform_fn(png_ptr, png_premultiply_and_gamma_correct);
    }

    /*
     * The PNG library won't currently transform the background chunk for
     * us, so we have to do it ourselves. Extract a RISC OS palette
     * word, plus entry number, if applicable.
     */
    if (png_get_bKGD(png_ptr, info, &background))
    {
        unsigned int bg_r = background->red;
        unsigned int bg_g = background->green;
        unsigned int bg_b = background->blue;
        unsigned int bg_m = background->gray;
        unsigned int bg_i = 0x100;

        switch (color_type)
        {
          case PNG_COLOR_TYPE_GRAY:
          case PNG_COLOR_TYPE_GRAY_ALPHA:
            /* bKGD contains a greyscale value in [0 .. 2^bit_depth-1] */
            bg_i = bg_m;
            switch (bit_depth)
            {
              case 1:
                bg_m *= 0xFF;
                break;
              case 2:
                bg_m *= 0x55;
                break;
              case 4:
                bg_m *= 0x11;
                break;
              case 16:
                bg_m >>= 8;
                break;
            }
            bg_r = bg_g = bg_b = bg_m;
            break;

          case PNG_COLOR_TYPE_PALETTE:
            /* bKGD contains a palette index */
            bg_i = background->index;
            bg_r = palette[bg_i].red;
            bg_g = palette[bg_i].green;
            bg_b = palette[bg_i].blue;
            break;

          case PNG_COLOR_TYPE_RGB:
          case PNG_COLOR_TYPE_RGB_ALPHA:
            /* bKGD contains R,G,B values in [0 .. 2^bit_depth-1] */
            if (bit_depth == 16)
            {
                bg_r >>= 8;
                bg_g >>= 8;
                bg_b >>= 8;
            }
            break;
        }

        load->bkgd = (bg_b << 24) | (bg_g << 16) | (bg_r << 8) | (bg_i & 0xFF);
        load->have_bkgd = 1;
        if (bg_i != 0x100) load->have_bkgd_index = 1;
    }

    /*
     * Get the library to handle interlacing for us
     */
    png_set_interlace_handling(png_ptr);

    /*
     * We've declared all the transformations - prepare the library and
     * update the info structure to describe the transformed data
     * format.
     */
    png_read_update_info(png_ptr, info);

    /*
     * We will now be getting data in one of these formats:
     *            1 bpp paletted/greyscale }
     *            2 bpp paletted/greyscale } only if no alpha in palette
     *            4 bpp paletted/greyscale }
     *            8 bpp paletted/greyscale
     *            8 bpp greyscale + alpha (=> 2 bytes per pixel)
     *           24 bpp colour (with or without alpha, 32 bit packed)
     *
     * Read the new properties.
     */
    png_get_IHDR(png_ptr, info, &width, &height, &bit_depth, &color_type, &interlace_type, NULL, NULL);

    if (color_type == PNG_COLOR_TYPE_RGB ||
        color_type == PNG_COLOR_TYPE_RGB_ALPHA)
    {
        if (osver >= 0xA5)
        {
            if (load->convto16bit)
                mode = MODE(5,90,90);
            else
                mode = MODE(6,90,90);
        }
        else
        {
            if (!ct32k_buffer[1])
            {
                load_inversetable();
                if (!ct32k_buffer[1])
                    png_error(png_ptr, "Insufficient memory");
            }

            if (this->full_alpha)
                mode = MODE(6,90,90);
            else
                mode = 28;
        }
    }
    else
    {
        switch (bit_depth)
        {
            case 1: mode = 25; break;
            case 2: mode = 26; break;
            case 4: mode = 27; break;
            case 8: mode = 28; break;
        }
    }

    this->width = width;
    this->height = height;

    #ifdef DO_pHYs
    /* Don't support the pHYs chunk - it sucks */
    png_get_pHYs(png_ptr, info, &res_x, &res_y, &unit_type);

    switch (unit_type)
    {
      case PNG_RESOLUTION_METER:
        if (this->width_os==-1)
            this->width_os = width * 180.0F / (res_x * 0.0254F);
        if (this->height_os==-1)
            this->height_os = height * 180.0F / (res_y * 0.0254F);
        break;

      default:
        if (this->width_os==-1)
        {
            if (res_x > res_y)
                this->width_os = width * 2;
            else
                this->width_os = width * 2 * res_y / res_x;
        }
        if (this->height_os==-1)
        {
            if (res_x > res_y)
                this->height_os = height * 2 * res_x / res_y;
            else
                this->height_os = height * 2;
        }
        break;
    }
    #else
    if (this->width_os==-1)
        this->width_os = width * 2;
    if (this->height_os==-1)
        this->height_os = height * 2;
    #endif

    if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
        riscos_rowbytes = width;
    else if (color_type == PNG_COLOR_TYPE_RGB || color_type == PNG_COLOR_TYPE_RGB_ALPHA)
    {
        if (osver < 0xA5 && !this->full_alpha)
            riscos_rowbytes = width;
        else if (load->convto16bit)
            riscos_rowbytes = width * 2;
        else
            riscos_rowbytes = width * 4;
    }
    else
        riscos_rowbytes = png_get_rowbytes(png_ptr, info);

    mem = 16  /* Sprite area header size */
         +44; /* Sprite header size */

    if ((color_type&~PNG_COLOR_MASK_ALPHA) == PNG_COLOR_TYPE_GRAY && !this->full_alpha)
        num_palette = pal_entries = 1 << bit_depth;
    else if (color_type == PNG_COLOR_TYPE_PALETTE)
    {
        png_get_PLTE(png_ptr, info, &palette, &num_palette);
        pal_entries = 1 << bit_depth;
    }
    else if (osver < 0xA5 && color_type == PNG_COLOR_TYPE_RGB)
    {
        num_palette = 0;
        pal_entries = 256;
    }
    else
        num_palette = pal_entries = 0;

    mem += 8 * pal_entries;

    load->spritewidth = (riscos_rowbytes+3)&~3;

    mem += load->spritewidth * height;

    if (!this->full_alpha || color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
    {
       if (mode > 28)
          load->maskwidth = ((width + 31) &~ 31) / 8;
       else
          load->maskwidth = load->spritewidth;

       mem += load->maskwidth * height;

       have_mask = true;

       if (!this->full_alpha)
       {
           this->transparent = 1;
           if (!(color_type & PNG_COLOR_MASK_ALPHA) && !png_get_valid(png_ptr, info, PNG_INFO_tRNS))
           {
               if (this->flags & IMAGE_FAST)
               {
                   /* don't bother */
                   mem -= load->maskwidth * height;
                   load->maskwidth = 0;
                   have_mask = false;
                   this->transparent = 0;
               }
               else
                   load->removemask = 1;
           }
       }
    }
    else
       have_mask = false;

  trywithoutmask:
    if (!flex_alloc((flex_ptr)&this->private_data2, mem + SprExtendBonus))
    {
        if (load->removemask)
        {
            mem -= load->maskwidth * height;
            have_mask = false;
            load->removemask = 0;
            this->transparent = 0;
            goto trywithoutmask;
        }

        load->errmess = "Insufficient memory";
        longjmp(png_ptr->jmpbuf, 1);
    }

    /* Create the sprite now */
    this->private_data2[0] = mem;
    this->private_data2[2] = 16;
    e=_swix(OS_SpriteOp, _INR(0,1), 256+9, this->private_data2);
    if (e)
        goto error;

    if (osver < 0xA5 && mode == MODE(6,90,90))
    {
        e=_swix(OS_SpriteOp, _INR(0,6), 256+15, this->private_data2, "png", 0,
                                                this->width * 4, this->height, 28);
        load->isreally32bit = 1;
    }
    else
    {
        e=_swix(OS_SpriteOp, _INR(0,6), 256+15, this->private_data2, "png", 0,
                                                this->width, this->height, mode);
    }
    if (e)
        goto error;

    /* Sort out the mask */
    if (have_mask)
    {
        e=_swix(OS_SpriteOp, _INR(0,2), 256+29, this->private_data2, "png");
        if (e)
            goto error;


    	/* Clear the mask */
    	_swix(OS_SpriteOp, _INR(0,3)|_OUTR(1,3), 256+61, this->private_data2, "png", 0,
    	    	    	    	    	     	&r1, &r2, &r3);
    	_swix(OS_SetColour, _INR(0,1), 0x10, 0);
    	_swix(OS_WriteI + 16, 0);
    	_swix(OS_SpriteOp, _INR(0,3), 256+61, r1, r2, r3);
    }

    /* Create and fill in the palette */
    if (pal_entries)
    {
        int i, c;

        e=_swix(OS_SpriteOp, _INR(0,3), 256+37, this->private_data2, "png",
                                        pal_entries == 256 ? (1U<<31) + 1 : 1);
        if (e)
            goto error;

        if (num_palette == 0)
            goto leave_default_palette;

        /* If full_alpha, must be palette data with hard tRNS chunk */
        if (this->full_alpha && color_type == PNG_COLOR_TYPE_PALETTE)
        {
            /* We manipulate the palette (har har har).
             * 255 alpha -> colour gamma corrected ready for screen
             * other alpha -> linearise and premultiply
             */
            for (i = 0; i < num_palette; i++)
            {
                int r, g, b, a;

                if (i < num_trans) a = trans[i]; else a = 255;
                r = palette[i].red;
                g = palette[i].green;
                b = palette[i].blue;

                if (a == 255)
                {
                    r = load->file_to_screen[r];
                    g = load->file_to_screen[g];
                    b = load->file_to_screen[b];
                }
                else
                {
                    int a256 = a + (a >> 7);
                    r = (load->file_to_1[r] * a256) >> 8;
                    g = (load->file_to_1[g] * a256) >> 8;
                    b = (load->file_to_1[b] * a256) >> 8;
                }
                c = (b << 24) | (g << 16) | (r << 8) | a;
                this->private_data2[15 + i * 2] =
                this->private_data2[15 + i * 2 + 1] = c;
            }

            /* Any spare palette entries are set to opaque black */
            for ( ; i < pal_entries; i++)
                this->private_data2[15 + i * 2] =
                this->private_data2[15 + i * 2 + 1] = 0x000000FF;

        }
        else
        {
            if (color_type == PNG_COLOR_TYPE_GRAY ||
                color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
            {
                if (!this->full_alpha)
                {
                    /* Need a gamma corrected palette */
                    int g, end, step, do_gamma;
                    double gamma;

                    if (png_get_gAMA(png_ptr, info, &gamma))
                    {
                        gamma = 1.0 / (gamma * SCREEN_GAMMA);
                        /* If the gamma difference < 0.05, don't bother doing correction */
                        do_gamma = fabs(gamma - 1.0) >= 0.05;
                    }
                    else
                        do_gamma = 0;

                    this->private_data2[15] = this->private_data2[16] = 0;

                    end = (1 << bit_depth) - 1;
                    step = 255 / end;

                    for (i = 1, g = step; i < end; i++, g += step)
                    {
                        if (do_gamma)
                            c = (png_byte)(pow((double)g / 255.0, gamma) * 255.0 + .5);
                        else
                            c = g;
                        c = (c << 24) | (c << 16) | (c << 8);

                        this->private_data2[15 + i * 2] =
                        this->private_data2[15 + i * 2 + 1] = c;
                    }

                    this->private_data2[15 + i * 2] = this->private_data2[15 + i * 2 + 1] = 0xFFFFFF00;
                }
            }
            else
            {
                /* Normal palette - phew */
                for (i = 0; i < num_palette; i++)
                {
                    c = (palette[i].blue << 24) |
                        (palette[i].green << 16) |
                        (palette[i].red << 8);
                    this->private_data2[15 + i * 2] =
                    this->private_data2[15 + i * 2 + 1] = c;
                }

                /* Any spare palette entries are zeroed */
                for ( ; i < pal_entries; i++)
                    this->private_data2[15 + i * 2] =
                    this->private_data2[15 + i * 2 + 1] = 0;
            }
        }
    }

  leave_default_palette:

    if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
    {
        if (!flex_alloc((flex_ptr) &load->temp, width * 2))
        {
            load->errmess = "Insufficient memory";
            longjmp(png_ptr->jmpbuf, 1);
        }
    }
    else if ((osver < 0xA5 && (color_type == PNG_COLOR_TYPE_RGB || color_type == PNG_COLOR_TYPE_RGB_ALPHA) && !this->full_alpha)
                  || load->convto16bit)
    {
        if (!flex_alloc((flex_ptr) &load->temp, width * 4))
        {
            load->errmess = "Insufficient memory";
            longjmp(png_ptr->jmpbuf, 1);
        }
    }

    load->sprite_offset = 16 + this->private_data2[12];
    if (have_mask)
    {
        load->mask_offset=16 + this->private_data2[13];
        if (interlace_type == 1 && !load->removemask)
            this->mutable_mask = true;
    }

    load->color_type = color_type;


    if (load->have_bkgd)
    {
        if (!(osver < 0xA5 && mode==MODE(6,90,90)))
        {
            /* Clear the background */
            _swix(OS_SpriteOp, _INR(0,3)|_OUTR(1,3), 256+60, this->private_data2, "png", 0,
            	    	    	    	    	     &r1, &r2, &r3);
            if (load->have_bkgd_index)
                _swix(OS_SetColour, _INR(0,1), 0x10, load->bkgd & 0xFF);
            else
            {
                unsigned int bg, bg_r, bg_g, bg_b;
                bg_r = load->file_to_screen[(load->bkgd >> 8) & 0xFF];
                bg_g = load->file_to_screen[(load->bkgd >> 16) & 0xFF];
                bg_b = load->file_to_screen[load->bkgd >> 24];
                bg = (bg_b << 24) | (bg_g << 16) | (bg_r << 8);
                _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), bg, 128, 0);
            }
            _swix(OS_WriteI + 16, 0);
            _swix(OS_SpriteOp, _INR(0,3), 256+60, r1, r2, r3);
        }
    }

    return;

  error:
    load->errmess = e->errmess;
    longjmp(png_ptr->jmpbuf, 1);
}

static void convert_32bit_alpha_to_mask(const png_bytep row, png_bytep mask_row, png_uint_32 width);
static void convert_row_24bit_to_8bit(const png_byte *row, png_byte *data, png_byte *mask, const char *itable, unsigned int width);
static void convert_row_8bit_to_24bit(png_byte *row, const png_byte *data, const png_byte *mask, const unsigned int *palette, unsigned int width);
static void convert_row_24bit_to_15bit(const png_byte *row, png_byte *data, unsigned int width);
static void convert_row_15bit_to_24bit(png_byte *row, const png_byte *data, unsigned int width);

void row_callback(png_struct *png_ptr, png_byte *new_row, png_uint_32 row_num, int pass)
{
    Image *this = (Image *) png_get_progressive_ptr(png_ptr);
    PNGloaddata *load = (PNGloaddata *) this->private_data;
    png_info *info = load->info_ptr;
    png_byte *row, *mask_row, *our_row;
    png_bytep trans;
    int num_trans;
    png_color_16p trans_values;
    int y, color_type;

    int oldbudge = flex_set_budge(0);

    color_type = png_get_color_type(png_ptr, info);

    /* Increase apparent height of sprite if necessary */
    if (row_num >= load->available_rows)
    {
        load->available_rows = row_num + 1;

        /* If now got one complete pass, take off the temporary mask */
        if (load->available_rows == this->height && load->removemask)
        {
            if (!_swix(OS_SpriteOp, _INR(0,2), 256+30, this->private_data2, "png"))
            {
                flex_extend((flex_ptr) &this->private_data2, load->mask_offset);
                this->private_data2[0] = load->mask_offset;
                load->mask_offset = 0;
                load->removemask = 0;
                this->transparent = 0;
            }
        }
    }

         row = (png_byte *) this->private_data2 +
                            load->sprite_offset +
                            load->spritewidth * row_num;

    if (load->mask_offset)
    {
        mask_row = (png_byte *) this->private_data2 +
                                 load->mask_offset +
                                 load->maskwidth * row_num;
        if (load->removemask)
        {
            memset(mask_row, 255, load->maskwidth);
            mask_row = NULL;
        }
    }
    else
        mask_row = NULL;

    /* Expand our separate mask + color data into the interleaved format the library
       expects... */
    if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
    {
        int i;
        png_byte *dp, *sp, *mp;

        sp = row;
        mp = mask_row;
        dp = load->temp;
        for (i = this->width; i; i--)
        {
            *dp++ = *sp++;
            *dp++ = *mp++;
        }

        our_row = row;
        row = load->temp;
    }
    else if (load->convto16bit)
    {
        convert_row_15bit_to_24bit(load->temp, row, this->width);
        our_row = row;
        row = load->temp;
    }
    else if (osver < 0xA5 && (color_type == PNG_COLOR_TYPE_RGB || color_type == PNG_COLOR_TYPE_RGB_ALPHA) && !this->full_alpha)
    {
        convert_row_8bit_to_24bit(load->temp, row, mask_row, (unsigned int *) this->private_data2 + 15, this->width);
        our_row = row;
        row = load->temp;
    }

    png_progressive_combine_row(png_ptr, row, new_row);

    if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
    {
        /* And remerge... */
        int i;
        png_byte *dp, *sp, *mp;

        row = our_row;

        sp = load->temp;
        mp = mask_row;
        dp = row;
        if (this->full_alpha)
        {
            for (i = this->width; i; i--)
            {
                *dp++ = *sp++;
                *mp++ = *sp++;
            }
        }
        else
        {
            for (i = this->width; i; i--)
            {
                *dp++ = *sp++;
                *mp++ = *sp++ ? 255 : 0;
            }
        }
    }
    else if (load->convto16bit)
    {
        row = our_row;
        if (mask_row)
            convert_32bit_alpha_to_mask(load->temp, mask_row, this->width);
        convert_row_24bit_to_15bit(load->temp, row, this->width);
    }
    else if (color_type == PNG_COLOR_TYPE_RGB || color_type == PNG_COLOR_TYPE_RGB_ALPHA)
    {
        if (!this->full_alpha)
        {
            if (osver >= 0xA5 && color_type == PNG_COLOR_TYPE_RGB_ALPHA)
                convert_32bit_alpha_to_mask(row, mask_row, this->width);
            else if (osver < 0xA5)
            {
                row = our_row;
                convert_row_24bit_to_8bit(load->temp, row, mask_row, (char *)ct32k_buffer[1], this->width);
            }
        }
    }
    else if (png_get_tRNS(png_ptr, info, &trans, &num_trans, &trans_values))
    {
        if (!this->full_alpha)
            convert_trns_to_mask(row, mask_row, this->width, png_get_bit_depth(png_ptr, info), trans, num_trans, trans_values, color_type);
    }

    flex_set_budge(oldbudge);

    load->changed.xmax = this->width_os;

    y = (this->height - row_num - 1) * 2;

    if (y + 2 > load->changed.ymax)
    	load->changed.ymax = y + 2;

    if (y < load->changed.ymin)
    	load->changed.ymin = y;
}

void end_callback(png_struct *png_ptr, png_info *info)
{
    Image *this = (Image *) png_get_progressive_ptr(png_ptr);
    PNGloaddata *load = (PNGloaddata *) this->private_data;

    load->finished = 1;
}

/*
 * process_transparency - deal with transparency specified by the tRNS chunk
 */
void convert_trns_to_mask(const png_bytep row, png_bytep mask_row, png_uint_32 width, int depth, png_bytep trans, int num_trans, const png_color_16 *trans_values, int color_type)
{
    int i;
    png_uint_32 mask1, mask2;
    png_byte *dp, *sp;
    int s_start, s_inc, shift;
    png_byte alpha;

    switch (depth)
    {
      case 1:
        shift = (width-1) & 7;
        s_start = 7;
        s_inc = -1;
        mask1 = 0x7f7f;
        mask2 = 1;
        break;

      case 2:
        shift = ((width-1) & 3) * 2;
        s_start = 6;
        s_inc = -2;
        mask1 = 0x3f3f;
        mask2 = 3;
        break;

      case 4:
        shift = ((width-1) & 1) * 4;
        s_start = 4;
        s_inc = -4;
        mask1 = 0xf0f;
        mask2 = 0xf;
        break;

      default:
        shift = s_start = 0;
        s_inc = 0;
        mask1 = 0;
        mask2 = 0xff;
        break;
    }

    sp =      row + (width - 1) * depth/8;
    dp = mask_row + (width - 1) * depth/8;

    if (color_type == PNG_COLOR_TYPE_PALETTE)
    {
        for (i = width; i; i--)
        {
            int pix;

            pix = (*sp >> shift) & mask2;
            if (pix < num_trans && trans[pix] == 0)
                alpha = 0;
            else
                alpha = mask2;

            *dp &= (png_byte)((mask1 >> (s_start - shift)) & 0xff);
            *dp |= (png_byte)(alpha << shift);

            if (shift == 0)
            {
                shift = s_start;
                dp--;
                sp--;
            }
            else
                shift += s_inc;
        }
    }
    else /* color_type == PNG_COLOR_TYPE_GRAY */
    {
        for (i = width; i; i--)
        {
            int pix;

            pix = (*sp >> shift) & mask2;
            if (pix == trans_values->gray)
                alpha = 0;
            else
                alpha = mask2;

            *dp &= (png_byte)((mask1 >> (s_start - shift)) & 0xff);
            *dp |= (png_byte)(alpha << shift);

            if (shift == 0)
            {
                shift = s_start;
                dp--;
                sp--;
            }
            else
                shift += s_inc;
        }
    }
}

/*
 * Given a row in AABBGGRR format, fill in the 1-bpp mask information
 */
static void convert_32bit_alpha_to_mask(const png_bytep row, png_bytep mask_row, png_uint_32 width)
{
    png_bytep sp;
    png_bytep dp;
    png_uint_32 i, shift, alpha;

    sp = row + (width - 1) * 4 + 3;
    dp = mask_row + ((width - 1) >> 3);

    shift = (width + 7) & 7;

    for (i = width; i; i--)
    {
        alpha = *sp ? 1 : 0;

        *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
        *dp |= (png_byte)(alpha << shift);

        if (shift == 0)
        {
            shift = 7;
            dp--;
        }
        else
            shift--;

        sp -= 4;
    }
}

/*
 * Turn 32-bit RGBA data into 8-bit paletted data with mask.
 */
static void convert_row_24bit_to_8bit(const png_byte *row, png_byte *data, png_byte *mask, const char *itable, unsigned int width)
{
    unsigned int x;
    unsigned int r, g, b, a, col;

    for (x = width; x; x--)
    {
        r = *row++; g = *row++; b = *row++; a = *row++;
        col = itable[((b >> 3) << 10) | ((g >> 3) << 5) | (r >> 3)];
        *data++ = col;
        if (mask)
            *mask++ = a ? 255 : 0;
    }
}

/*
 * Turn 8-bit paletted data into 32-bit RGBA.
 */
static void convert_row_8bit_to_24bit(png_byte *row, const png_byte *data, const png_byte *mask, const unsigned int *palette, unsigned int width)
{
    unsigned int x;
    unsigned int col;

    for (x = width; x; x--)
    {
        col = palette[*data++ * 2] >> 8;
        if (mask)
            col |= *mask++ << 24;

        *(unsigned int *)row = col;
        row += 4;
    }
}

/*
 * Turn 32-bit RGBA into 16-bit RGBM
 */
void convert_row_24bit_to_15bit(const png_byte *row, png_byte *data, unsigned int width)
{
    unsigned int x;
    unsigned int r, g, b, a, col;

    for (x = width; x; x--)
    {
        r = *row++; g = *row++; b = *row++; a = *row++;
        col = ((b >> 3) << 10) | ((g >> 3) << 5) | (r >> 3);
        if (a==0) col |= 0x8000;
        *(unsigned short *) data = col;
        data += 2;
    }
}

/*
 * Convert 16-bit RGBM into 32-bit RGBA.
 */
void convert_row_15bit_to_24bit(png_byte *row, const png_byte *data, unsigned int width)
{
    unsigned int x;
    unsigned int col;

    /*
     * Only need to do this approximately as we're just going to munge the
     * data back into 15 bits anyway.
     */
    for (x = width; x; x--)
    {
        col = *(unsigned int *) data;
        data += 2;
        *row++ = col << 3;
        *row++ = col >> 2;
        *row++ = col >> 7;
        *row++ = col & 0x8000 ? 0 : 255;
    }
}

static void png_premultiply_and_gamma_correct(png_structp png_ptr, png_row_infop row_info, png_bytep row)
{
    Image *this = (Image *) png_get_progressive_ptr(png_ptr);
    PNGloaddata *load = (PNGloaddata *) this->private_data;
    int a, r, g, b;
    png_uint_32 x;

    png_bytep file_to_1 = load->file_to_1;
    png_bytep file_to_screen = load->file_to_screen;

    if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
    {
        for (x = row_info->width ; x; x--)
        {
            r = *row++;
            g = *row++;
            b = *row++;
            a = *row++;

            if (a == 255)
            {
                row[-4] = file_to_screen[r];
                row[-3] = file_to_screen[g];
                row[-2] = file_to_screen[b];
            }
            else if (a == 0)
            {
                row[-4] = 0;
                row[-3] = 0;
                row[-2] = 0;
            }
            else
            {
                int a256 = a + (a >> 7);
                r = (file_to_1[r] * a256) >> 8;
                g = (file_to_1[g] * a256) >> 8;
                b = (file_to_1[b] * a256) >> 8;
                row[-4] = r;
                row[-3] = g;
                row[-2] = b;
            }
        }
    }
    else
    {
        for (x = row_info->width ; x; x--)
        {
            g = *row++;
            a = *row++;

            if (a == 255)
                row[-2] = file_to_screen[g];
            else if (a == 0)
                row[-2] = 0;
            else
            {
                int a256 = a + (a >> 7);
                g = (file_to_1[g] * a256) >> 8;
                row[-2] = g;
            }
        }
    }
}

/*****************************/


_kernel_oserror *SaveSpritePNG(Image *this, const char *filename, int maxbpp)
{
    _kernel_oserror *e;
    PNGloaddata *load = (PNGloaddata *) this->private_data;

    if (this->full_alpha)
        return SaveSpriteAlphaPNG(this, filename, maxbpp);

    if (load->isreally32bit)
        this->private_data2[14] = MODE(6,90,90);

    e = _swix(OS_SpriteOp, _INR(0,2), 256+12, this->private_data2, filename);

    if (load->isreally32bit)
        this->private_data2[14] = 28;

    return e;
}

static _kernel_oserror *SaveSpriteAlphaPNG(Image *this, const char *filename, int maxbpp)
{
    _kernel_oserror *e;
    PNGloaddata *load = (PNGloaddata *) this->private_data;
    int *temppal, i, j;
    unsigned int bg_r, bg_g, bg_b, r, g, b, a, sprwidth, gap;
    FILE *file;
    png_byte *p, *m;
    char *cttable = (char *)ct32k_buffer[1];

    struct
    {
        int number;   // Number of sprites
        int sproff;   // Offset to first sprite
        int freeoff;  // Offset to first free byte
        int  next;          // Offset to next sprite
        char name[12];      // Sprite name
        int  width;         // Width in words-1      (0..639)
        int  height;        // Height in scanlines-1 (0..255/511)
        int  lbit;          // First bit used (left end of row)
        int  rbit;          // Last bit used (right end of row)
        int  image;         // Offset to sprite image
        int  mask;          // Offset to transparency mask
        int  mode;          // Mode sprite was defined in
    } fileheader;


    if (load->have_bkgd)
    {
        bg_r = (load->bkgd & 0xFF00) >> 8;
        bg_g = (load->bkgd & 0xFF0000) >> 16;
        bg_b = load->bkgd >> 24;
    }
    else
        bg_r = bg_g = bg_b = 0xFF;

    switch (load->color_type)
    {
      case PNG_COLOR_TYPE_PALETTE:
        /*
         * We have an 8bpp sprite with true colour palette - just convert the palette
         * entries and save.
         */
        temppal = malloc(256*2*4);
        if (!temppal) return pngError("Insufficient memory");
        memcpy(temppal, this->private_data2+15, 256*2*4);
        for (i = 0; i < 256; i++)
        {
            unsigned int r, g, b, a, c;
            c = this->private_data2[15 + i * 2];
            b = c >> 24;
            g = (c & 0xFF0000) >> 16;
            r = (c & 0xFF00) >> 8;
            a = c & 0xFF;

            if (a == 255)
                continue;

            if (a == 0)
            {
                r = load->file_to_screen[bg_r];
                g = load->file_to_screen[bg_g];
                b = load->file_to_screen[bg_b];
            }
            else
            {
                a = 256 - (a + (a >> 7)); /* Rescale to 256..0 */
                r += (load->file_to_1[bg_r] * a) >> 8;
                g += (load->file_to_1[bg_g] * a) >> 8;
                b += (load->file_to_1[bg_b] * a) >> 8;
                r = screen_from_1[r];
                g = screen_from_1[g];
                b = screen_from_1[b];
            }

            c = (b << 24) | (g << 16) | (r << 8);
            this->private_data2[15 + i * 2] =
            this->private_data2[15 + i * 2 + 1] = c;
        }
        e = _swix(OS_SpriteOp, _INR(0,2), 256+12, this->private_data2, filename);
        memcpy(this->private_data2+15, temppal, 256*2*4);
        free(temppal);
        return e;
      case PNG_COLOR_TYPE_GRAY_ALPHA:
        file = fopen(filename, "wb");
        if (!file) return pngError("Unable to open output file");
        memset(&fileheader, 0, sizeof fileheader);
        fileheader.number = 1;
        fileheader.sproff = 16;
        fileheader.freeoff = load->mask_offset + 256*2*4;
        fileheader.next = load->mask_offset + 256*2*4 - 16;
        strcpy(fileheader.name, "png");
        fileheader.width = this->private_data2[8];
        fileheader.height = this->private_data2[9];
        fileheader.lbit = 0;
        fileheader.rbit = this->private_data2[11];
        fileheader.image = 0x82C;
        fileheader.mask = 0x82C;
        fileheader.mode = 28;
        if (fwrite(&fileheader, sizeof fileheader, 1, file) < 1)
            goto file_error;
        for (i = 0; i < 256; i++)
        {
            int pal[2];
            pal[0] = pal[1] = (i<<24)|(i<<16)|(i<<8);
            if (fwrite(pal, sizeof pal[0], 2, file) < 2)
                goto file_error;
        }

        p = (png_byte *) this->private_data2 + load->sprite_offset;
        m = (png_byte *) this->private_data2 + load->mask_offset;
        for (i = load->spritewidth * this->height; i; i--)
        {
            g = *p++; a = *m++;

            if (a != 255)
            {
                a = 256 - (a + (a >> 7));
                g += (load->file_to_1[bg_g] * a) >> 8;
                g = screen_from_1[g];
            }
            if (putc(g, file) == EOF)
                goto file_error;
        }
        fclose(file);
        return _swix(OS_File, _INR(0,2), 18, filename, 0xFF9);
      case PNG_COLOR_TYPE_RGB_ALPHA:
        file = fopen(filename, "wb");
        if (!file) return pngError("Unable to open output file");
        if (osver < 0xA5)
           sprwidth = ((this->width + 3) >> 2) - 1;
        else
           sprwidth = this->private_data2[8];
        memset(&fileheader, 0, sizeof fileheader);
        fileheader.number = 1;
        fileheader.sproff = 16;
        fileheader.freeoff = 16 +44 + (sprwidth+1) * 4 * this->height;
        fileheader.next = 44 + (sprwidth+1) * 4 * this->height;
        strcpy(fileheader.name, "png");
        fileheader.width = sprwidth;
        fileheader.height = this->private_data2[9];
        fileheader.lbit = 0;
        gap = osver < 0xA5 ? (fileheader.width+1)*4-this->width : 0;
        fileheader.rbit = osver < 0xA5 ? (this->width * 8 - 1) & 31
                                       : 31;
        fileheader.image = 0x2C;
        fileheader.mask = 0x2C;
        fileheader.mode = osver < 0xA5 ? 28 : MODE(6,90,90);
        if (fwrite(&fileheader, sizeof fileheader, 1, file) < 1)
            goto file_error;

        p = (png_byte *) this->private_data2 + load->sprite_offset;
        for (i = this->height; i; i--)
        {
            for (j = this->width; j; j--)
            {
                r = *p++; g = *p++; b = *p++; a = *p++;

                if (a != 255)
                {
                    a = 256 - (a + (a >> 7));
                    r += (load->file_to_1[bg_r] * a) >> 8;
                    g += (load->file_to_1[bg_g] * a) >> 8;
                    b += (load->file_to_1[bg_b] * a) >> 8;
                    r = screen_from_1[r];
                    g = screen_from_1[g];
                    b = screen_from_1[b];
                }
                if (osver < 0xA5)
                {
                    unsigned int c = ((b >> 3) << 10) |
                                     ((g >> 3) << 5) |
                                     (r >> 3);

                    if (putc(cttable[c], file) == EOF)
                        goto file_error;
                }
                else
                {
                    if (putc(r, file) == EOF || putc(g, file) == EOF ||
                        putc(b, file) == EOF || putc(0, file) == EOF)
                        goto file_error;
                }
            }
            if (gap)
            {
                char zero[4] = { 0 };
                if (fwrite(&zero, 1, gap, file) < gap)
                    goto file_error;
            }
        }
        fclose(file);
        return _swix(OS_File, _INR(0,2), 18, filename, 0xFF9);
    }

  file_error:
    fclose(file);
    remove(filename);
    return pngError("Error writing file");
}

static _kernel_oserror *DumpToCache(Image *this, const char *filename, int *justuseorig)
{
    *justuseorig=0;
    return SaveSpritePNG(this, filename, -1);
}

static _kernel_oserror *LoadFromCache(Image *this, const char *filename)
{
    _kernel_oserror *e;
    int length, transparent;

    e=_swix(OS_File, _INR(0,1)|_OUT(4), 20, filename, &length);

    if (!e)
    {
        if (!flex_alloc((flex_ptr)&this->private_data2, length+4+SprExtendBonus))
            return pngError("Insufficient memory");
    }

    if (!e)
    {
        this->private_data2[0]=length+4;
        this->private_data2[2]=16;
        e=_swix(OS_SpriteOp, _INR(0,1), 256+9, this->private_data2);
    }

    if (!e)
        e=_swix(OS_SpriteOp, _INR(0,2), 256+10, this->private_data2, filename);

    transparent = this->transparent;
    if (!e)
        e=_swix(OS_SpriteOp, _INR(0,2)|_OUTR(3,5), 256+40, this->private_data2, filename,
                                                   &this->width, &this->height,
                                                   &transparent);
    this->transparent = transparent;

    if (!e)
    {
        this->mutable_mask=0;
        if (this->width_os==-1)
            this->width_os=2*this->width;
        if (this->height_os==-1)
            this->height_os=2*this->height;
    }

    return e;
}

static _kernel_oserror *EndLoad(Image *this, BBox *changed)
{
    PNGloaddata *load=(PNGloaddata *) this->private_data;
    #ifdef TRACE
    if (load->trace)
        fclose(load->trace);
    #endif

    memset(changed, 0, sizeof(BBox));

    png_destroy_read_struct(&load->png_ptr, &load->info_ptr, NULL);

    if (load->temp)
        flex_free((flex_ptr) &load->temp);

    /*free(this->private_data);
    this->private_data=NULL;*/

    if (this->width_os==-1)
        this->width_os=2*this->width; /*180*this->width/xres;*/
    if (this->height_os==-1)
        this->height_os=2*this->height; /*180*this->height/yres;*/

    return NULL;
}

static _kernel_oserror *Delete(Image *this)
{
    PNGloaddata *load;

    if (!this)
        return NULL;

    load=(PNGloaddata *) this->private_data;
    if (load)
    {
        if (load->png_ptr)
    	    png_destroy_read_struct(&load->png_ptr, &load->info_ptr, NULL);

        free(load->file_to_1);
        free(load->file_to_screen);
        free(load);
    }

    if (this->private_data2)
        flex_free((flex_ptr) &this->private_data2);

    free(this);

    return NULL;
}

static _kernel_oserror *ModeChangePNG(Image *this)
{
    _kernel_oserror *e=0;
    int bufsize;
    int xeig, yeig;
    int printing=0;

    _swix(PDriver_CurrentJob, _OUT(0), &printing);

    e=_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 9, &log2bpp);
    if (e) return e;

    if (osver >= 0xA5)
        ct32k_buffer[0] = 0;
    else if (log2bpp < 3)
    {
        if (!ro310_2nd_table)
            ro310_2nd_table = malloc(256);
        if (!ro310_2nd_table)
            return pngError("Insufficient memory");

        e = _swix(ColourTrans_GenerateTable, _INR(0,5), 28, 0, -1, -1, ro310_2nd_table, 0);
        if (e) return e;
    }

    /*don't need a table if going into 16 or 32bpp*/

    if (!this)
        return NULL;

    if (log2bpp <= 3 || printing)
    {
        if (!e)
        e=_swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4), this->private_data2,
                                                              this->private_data2+4, -1, -1,
                                                    0, 1, &bufsize);

        if (!e)
        {
            free(this->table);
            this->table=NULL;
            if (bufsize)
            {
                this->table=malloc(bufsize);
                if (!this->table)
                    e=pngError("Insufficient memory");

                if (!e)
                    e=_swix(ColourTrans_GenerateTable, _INR(0,5), this->private_data2,
                                                                  this->private_data2+4, -1, -1,
                                                                  this->table, 1);
            }
        }

    }

    if (!e)
    e = _swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 4, &xeig);
    if (!e)
    e = _swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 5, &yeig);

    if (!e)
    {
        this->factors[0]=this->width_os<<xeig;
        this->factors[1]=this->height_os<<yeig;
        this->factors[2]=this->width<<2;
        this->factors[3]=this->height<<2;
    }
    return e;
}

static _kernel_oserror *RenderWithAlpha(Image *this, int x, int y, int scale, int x_size, int y_size, int log2bpp, int printing);

static _kernel_oserror *RenderPNG(Image *this, int x, int y, int scale, int x_size, int y_size)
{
    _kernel_oserror *e=NULL;
    PNGloaddata *load = (PNGloaddata *)this->private_data;
    int fac[4];
    int job = 0;

    if (!this || !this->private_data2)
        return pngError("Broken PNG");

    if (this->width <= 0)
    {
        e=_swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), 0, 0, 0);
        if (!e)
            e=_swix(OS_Plot, _INR(0,2), 4, x, y);
        if (!e)
            e=_swix(OS_Plot, _INR(0,2), 0x60 | 1, this->width_os*scale/100-1,
                                                  this->height_os*scale/100-1);
        return e;
    }

    _swix(PDriver_CurrentJob, _OUT(0), &job);

    if (this->modechanged || !this->factors[0] || job)
    {
        e=ModeChangePNG(this);
        if (e) return e;
        this->modechanged = 0;
    }

    if (this->full_alpha)
        return RenderWithAlpha(this, x, y, scale, x_size, y_size, job ? (osver >= 0xA5 ? 5 : 3) : log2bpp, job);

    if (load->isreally32bit)
        return pngError("Unable to render this image in this screen mode");

    memcpy(fac, this->factors, sizeof fac);

    if ((x_size>0) && (y_size>0))
    {
        int xos, yos;

        xos = 1 << _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 4);
        yos = 1 << _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);

        fac[0]=x_size;
        fac[1]=y_size;
        fac[2]=this->width*xos;
        fac[3]=this->height*yos;
    }
    else if (scale != 100)
    {
        fac[0]*=scale;
        fac[1]*=scale;
        fac[2]*=100;
        fac[3]*=100;
    }

    if (e) return e;

    if (log2bpp <= 3 && this->table == NULL && fac[0] == fac[2] && fac[1] == fac[3] && !job)
        e=_swix(OS_SpriteOp, _INR(0,5), 512+PutSprite,
                                        this->private_data2,
                                        this->private_data2+4,
                                        x, y,
                                        PutSpriteScaled_UseMask);
    else
        e=_swix(OS_SpriteOp, _INR(0,7), 512+PutSpriteScaled,
                                        this->private_data2,
                                        this->private_data2+4,
                                        x, y,
                                        osver >= 0xa5 ? PutSpriteScaled_UsePalette |
                                                        PutSpriteScaled_UseMask
                                                      : PutSpriteScaled_UseMask,
                                        fac,
                                        log2bpp <=3 ? this->table : 0);

    return e;
}

static void blend_image(int width, int height, char *sprdata, char *maskdata, int *palette, int type, int rowwidth, char *bgsprdata, int bgrowwidth, int *bgpalette, int bglog2bpp);

static _kernel_oserror *RenderWithAlpha(Image *this, int x, int y, int scale, int x_size, int y_size, int log2bpp, int printing)
{
    int bgwidth;
    int mode;
    void *table = 0;
    int fac[4];
    _kernel_oserror *e;
    int oldbudge;
    int *bgpal, bglog2bpp;
    char *bgptr;
    PNGloaddata *load=(PNGloaddata *) this->private_data;
    int width = this->width, height = this->height, rowstoblend = load->available_rows;
    int clipoffset = 0, xo = 0, yo = 0;

    if (!printing)
    {
        static const int vdu_list[] = { 128,129,130,131,4,5,136,137,-1 };
        struct
        {
            BBox clip;
            int xeig, yeig;
            int ox, oy;
        } var;

        e = _swix(OS_ReadVduVariables, _INR(0,1), vdu_list, &var);
        if (e) return e;

        if (x_size > 0 && y_size > 0)
        {
            if (width * 2 != x_size ||
                height * 2 != y_size)
                goto dont_clip;
        }
        else if (scale != 100)
            goto dont_clip;
        else
        {
            x_size = width * 2;
            y_size = height * 2;
        }

        /* var.clip = graphics window in external coordinates */
        var.clip.xmin = (var.clip.xmin << var.xeig) + var.ox;
        var.clip.ymin = (var.clip.ymin << var.yeig) + var.oy;
        var.clip.xmax = ((var.clip.xmax+1) << var.xeig) + var.ox;
        var.clip.ymax = ((var.clip.ymax+1) << var.yeig) + var.oy;

        /* If graphics window is totally outside available image, return */
        if (var.clip.xmax < x || var.clip.xmin >= x + x_size ||
            var.clip.ymax < y + y_size - load->available_rows * 2 || var.clip.ymin >= y + y_size)
            return NULL;

        if (var.clip.xmin < x) var.clip.xmin = x;
        if (var.clip.xmax > x + x_size) var.clip.xmax = x + x_size;
        if (var.clip.ymin < y + y_size - load->available_rows * 2) var.clip.ymin = y + y_size - load->available_rows * 2;
        if (var.clip.ymax > y + y_size) var.clip.ymax = y + y_size;

        var.clip.xmin -= x; var.clip.ymin -= y;
        var.clip.xmax -= x; var.clip.ymax -= y;

        var.clip.xmin >>= 1;
        var.clip.ymin >>= 1;
        var.clip.xmax = (var.clip.xmax + 1) >> 1;
        var.clip.ymax = (var.clip.ymax + 1) >> 1;

        width = var.clip.xmax - var.clip.xmin;
        height = var.clip.ymax - var.clip.ymin;
        if (width <= 0 || height <= 0)
            return NULL;

        if (height < 4)
        {
            if (var.clip.ymin >= 4)
                var.clip.ymin -= 4 - height;
            else
                var.clip.ymax += 4 - height;
            height = 4;
        }
        if (width < 4)
        {
            if (var.clip.xmin >= 4)
                var.clip.xmin -= 4 - width;
            else
                var.clip.xmax += 4 - width;
            width = 4;
        }
        xo = -2 * var.clip.xmin;
        yo = -2 * var.clip.ymin;
        clipoffset = var.clip.xmin;
        if (load->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            clipoffset *= 4;
        clipoffset += (this->height - var.clip.ymax) * load->spritewidth;

        rowstoblend = height;
        if (this->height - var.clip.ymin > load->available_rows)
            rowstoblend = load->available_rows - (this->height - var.clip.ymax);
    }

  dont_clip:

    if (printing)
    {
        mode      = osver >= 0xA5 ? MODE(6, 90, 90) : 28;
        bglog2bpp = osver >= 0xA5 ? 5               : 3 ;
    }
    else
    {
        switch (log2bpp)
        {
            case 0: mode = 25;              break;
            case 1: mode = 26;              break;
            case 2: mode = 27;              break;
            case 3: mode = 28;              break;
            case 4: mode = MODE(5, 90, 90); break;
            case 5: mode = MODE(6, 90, 90); break;
        }
        bglog2bpp = log2bpp;
    }

    e = MakeBufferSprite((void *) mode, width, height, &bgpal);
    if (e) return e;

    e = SwitchToBufferSprite();
    if (e) goto error2;

    {
        static const int list[] = { 6, 148, -1 };
        int out[2];

        e = _swix(OS_ReadVduVariables, _INR(0,1), list, out);
        if (e) goto error2;
        bgwidth = out[0];
        bgptr = (char *) out[1];
    }

    if (xo != 0 || yo != 0)
    {
        char cmd[5];
        cmd[0] = 29;
        cmd[1] = xo & 0xFF;
        cmd[2] = xo >> 8;
        cmd[3] = yo & 0xFF;
        cmd[4] = yo >> 8;
        e = _swix(OS_WriteN, _INR(0,1), cmd, 5);
    }

    if (!e)
    {
        if (load->filler)
            e = load->filler(load->filler_handle1, load->filler_handle2);
        else
        {
            unsigned int bg_r, bg_g, bg_b, bg;
            if (load->have_bkgd)
            {
                bg_r = load->file_to_screen[(load->bkgd >> 8) & 0xFF];
                bg_g = load->file_to_screen[(load->bkgd >> 16) & 0xFF];
                bg_b = load->file_to_screen[load->bkgd >> 24];
                bg = (bg_b << 24) | (bg_g << 16) | (bg_r << 8);
            }
            else
                bg = 0xFFFFFF00;
            _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), bg, 128, 0);
            _swix(OS_WriteI + 16, 0);
        }
    }

    e = SwitchFromBufferSprite();
    if (e) goto error2;

    if (!ct32k_buffer[0] && osver < 0xA5)
    {
        load_inversetable();
        if (!ct32k_buffer[0])
            goto error2;
    }

    oldbudge = flex_set_budge(0);

    blend_image(width, rowstoblend,
                (char *) this->private_data2 + load->sprite_offset + clipoffset,
                (char *) this->private_data2 + load->mask_offset + clipoffset,
                this->private_data2 + 4 + 11,
                load->color_type,
                load->spritewidth,
                bgptr,
                bgwidth,
                bgpal,
                bglog2bpp);

    flex_set_budge(oldbudge);

    memcpy(fac, this->factors, sizeof fac);

    if ((x_size>0) && (y_size>0))
    {
        int xos, yos;

        xos = 1 << _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 4);
        yos = 1 << _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);

        fac[0]=x_size;
        fac[1]=y_size;
        fac[2]=this->width*xos;
        fac[3]=this->height*yos;
    }
    else if (scale != 100)
    {
        fac[0]*=scale;
        fac[1]*=scale;
        fac[2]*=100;
        fac[3]*=100;
    }

    /* Selection table should be unnecessary for the screen... One exception
     * is an A4 in mode 28 in LCD, as the screen palette won't be that in
     * the 8desktop file, but this isn't worth worrying about. They should
     * be using mode 27 anyway.
     */
    if (printing)
    {
        int bufsize;

        e=BufferSprite_TableSize(&bufsize);
        if (e) goto error2;

        if (bufsize)
        {
            table = malloc(bufsize);
            if (!table)
            {
                e=pngError("Insufficient memory");
                goto error2;
            }

            e=BufferSprite_GenerateTable(table);
            if (e) goto error2;
        }
    }

    e=BufferSprite_PlotScaled(x - xo, y - yo, osver >= 0xa5 ? PutSpriteScaled_UsePalette : 0, fac, table);

    free(table);
 error2:
    FreeBufferSprite();

    return e;
}

static _kernel_oserror *StartExportPNG(Image *this, int *size)
{
    *size=this->private_data2[0]-4;

    return StartExport((flex_ptr) &this->private_data2, this->private_data2[0]-4, 4);
}

static _kernel_oserror *bgfiller(void *h, int *bg)
{
    /* Set background colour */
    _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), *bg, 128, 0);
    /* CLG */
    _swix(OS_WriteI+16, 0);

    return NULL;
}

static _kernel_oserror *BGColPNG(Image *this, int *bgcol, int dontoverride)
{
    _kernel_oserror *e;
    int size, *sphead;
    void *mode;
    Spriteloaddata *l;
    char temp[16];
    int fac[4];
    int r1, r2, r3;
    PNGloaddata *load = (PNGloaddata *) this->private_data;
    int nw, nh, log2bpp;
    unsigned int bg = *bgcol;
    int *newarea;
    int copy_row;
    size_t savesize;

    if (!(this->flags & IMAGE_FAST))
       return BGCol(this->private_data2, bgcol);

    ModeChangePNG(this);
    this->modechanged = 0;

    l = (Spriteloaddata *)malloc(sizeof *l);
    if (!l)
        return NULL;

    this->flags &= ~IMAGE_FAST;
    /*
     * Right, this is obviously a background image, so lets munge it into
     * a sprite of the current mode and palette!
     */
    _swix(OS_Byte, _IN(0)|_OUT(2), 135, &mode);
    log2bpp=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), mode, 9);

    /* Find first sprite */
    e=_swix(OS_SpriteOp, _INR(0,4), 256+13, this->private_data2, temp, sizeof temp, 1);
    if (e)
        return NULL;

    /* Get pointer to it */
    e=_swix(OS_SpriteOp, _INR(0,2)|_OUT(2), 256+24, this->private_data2, temp, &sphead);
    if (e)
        return NULL;

    /* Get scale factors */
    _swix(Wimp_ReadPixTrans, _INR(0,2) |_INR(6,7), 0x200, this->private_data2, sphead, fac, 0);
    nw=this->width * fac[0] / fac[2];
    nh=this->height * fac[1] / fac[3];

    if (nw == 0) nw=1;
    if (nh == 0) nh=1;

    /* SpriteExtend bodge */
    if (nh==1) {
      nh=8;
      this->height*=8;
      this->height_os*=8;
      copy_row=1;
    }

    size = SpriteAreaSize(mode, nw, nh);
    if (log2bpp <= 3)
        /* Add the palette... */
        size += 8 << (1 << log2bpp);

    newarea = malloc(size);
    if (!newarea)
        return NULL;

    newarea[0] = size;
    newarea[2] = 16;
    /* Initialise sprite area */
    _swix(OS_SpriteOp, _INR(0,1), 256+9, newarea);

    /* Create sprite */
    e=_swix(OS_SpriteOp, _INR(0,6), 256+15, newarea, "sprite",
                                    0, nw, nh, mode);

    /* Add the palette */
    if (!e && log2bpp <= 3)
    {
        void *palette;
        e=_swix(OS_SpriteOp, _INR(0,3), 0x125, newarea, "sprite", (1U<<31)+1);
        if (!e)
            e=_swix(OS_SpriteOp, _INR(0,3)|_OUT(4), 0x125, newarea, "sprite", -1, &palette);
        if (!e)
            e=_swix(ColourTrans_ReadPalette, _INR(0,4), -1, -1, palette, 8<<(1<<log2bpp), 2);
    }
    if (e)
    {
        free(newarea);
        return NULL;
    }

    /* Read save area size */
    e=_swix(OS_SpriteOp, _INR(0,2)|_OUT(3), 0x13E, newarea, "sprite",
                                               &savesize);

    int savearea[savesize]; /* One of the main reasons C99 rocks */
    savearea[0] = 0;

    /* Switch output to it */
    e=_swix(OS_SpriteOp, _INR(0,3)|_OUTR(1,3), 0x13C, newarea, "sprite", savearea,
                                               &r1, &r2, &r3);
    if (e)
    {
        free(newarea);
        return NULL;
    }

    /* What background colour? */
    if (!dontoverride && load->have_bkgd)
    {
        unsigned int bg_r, bg_g, bg_b;
        bg_r = load->file_to_screen[(load->bkgd >> 8) & 0xFF];
        bg_g = load->file_to_screen[(load->bkgd >> 16) & 0xFF];
        bg_b = load->file_to_screen[load->bkgd >> 24];
        bg = (bg_b << 24) | (bg_g << 16) | (bg_r << 8);
    }

    /* Set background colour */
    _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), bg, 128, 0);
    /* CLG */
    _swix(OS_WriteI+16, 0);

    this->RegisterFiller(this, bgfiller, this, (int *) &bg);

    /* Plot the image */
    RenderPNG(this, 0, 0, 100, -1, -1);

    /* Unswitch output */
    _swix(OS_SpriteOp, _INR(0,3), 0x13c, r1, r2, r3);

    /* If it was a one row PNG, copy the one row to the other seven. */
    if (copy_row)
    {
      int          *sprite_area;
      int          *sprite_header;
      char         *sprite_data;
      int           n, sw, widthinwords;

      widthinwords = ((this->width << log2bpp) + 31) / 32;

      sw = widthinwords * 4;

      sprite_area   = (int*) newarea;
      sprite_header = (int*) ((char*)sprite_area + sprite_area[2]);
      sprite_data   = (char*) ((char*)sprite_header + sprite_header[8]);

      for (n=0; n<7; n++) memcpy(sprite_data + (n*sw), sprite_data + (7*sw), sw);
    }

    BGCol(newarea, bgcol);

    if (flex_extend((flex_ptr) &this->private_data2, size) == 0)
    {
        free(newarea);
        return NULL;
    }
    memcpy(this->private_data2, newarea, size);
    free(newarea);

    if (load)
    {
        if (load->png_ptr)
    	    png_destroy_read_struct(&load->png_ptr, &load->info_ptr, NULL);
        free(load->file_to_1);
        free(load->file_to_screen);
        free(load);
    }
    free(this->table);

    this->DumpSprite=SpriteDumpSprite;
    this->Render=RenderSprite;
    this->DumpToCache=DumpToCacheSprite;
    this->StartExport=StartExportSprite;
    this->Export=Export;
    this->EndExport=EndExport;
    this->Delete=DeleteSprite;
    this->private_data=l;
    this->transparent=0;
    this->mutable_mask=0;
    this->width=nw;
    this->height=nh;
    this->NeedRedraw=0;
    this->RegisterFiller=0;

    l->memory=size;
    l->xeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), mode, 4);
    l->yeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), mode, 5);
    l->bpp =_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), mode, 9);
    {
        int *pal;
        _swi(OS_SpriteOp, _INR(0,3)|_OUTR(3,4), 256+37, this->private_data2, "sprite", -1, &l->palsize, &pal);
        if (pal)
            l->paloffset = pal - this->private_data2;
        else
            l->paloffset = 0;
    }
    this->table = 0;
    this->factors[0]=this->factors[1]=this->factors[2]=this->factors[3]=1;
    strcpy(l->name, "sprite");
    return NULL;
}

static _kernel_oserror *RegisterFiller(Image *this, FillerFunction *fill_fn, void *handle1, int *handle2)
{
    PNGloaddata *load = (PNGloaddata *) this->private_data;

    load->filler = fill_fn;
    load->filler_handle1 = handle1;
    load->filler_handle2 = handle2;

    return 0;
}

#define blend(dest, alpha_dest, src)               \
          {                                        \
              if (dest) dest *= (alpha_dest);      \
              dest = (dest >> 8) + src;            \
          }

static void blend_image(int width, int height, char *sprdata, char *maskdata, int *palette, int type, int rowwidth, char *bgsprdata, int bgrowwidth, int *bgpalette, int bglog2bpp)
{
    unsigned int bgdepth = 1 << bglog2bpp;
    int red, green, blue;
    int bgred, bggreen, bgblue;
    unsigned int fg, bg, c;
    int alpha, bg_alpha;
    int x, y, bbit;
    char *s, *m, *b;
    char *cttable;
    #ifdef DITHERING
    int dir=1;
    unsigned int result;
    int truered, truegreen, trueblue, result_red, result_green, result_blue;
    int error_red, error_green, error_blue;
    #endif

    if (bgdepth <= 8 && osver >= 0xA5)
    {
        _kernel_oserror *e;

        /* Get the magic "table" from ColourTrans ( { '32K.', table_ptr, '32K.' } ) */
        e = _swix(ColourTrans_GenerateTable, _INR(0,5), MODE(5, 90, 90), -1, -1, -1, ct32k_buffer, 0);
        if (e) return;
    }
    cttable = (char *)ct32k_buffer[1];

    for (y = height; y; y--)
    {
        s = sprdata;   sprdata   += rowwidth;
        m = maskdata;  maskdata  += rowwidth;
        b = bgsprdata; bgsprdata += bgrowwidth;
        bbit = 0;

        #ifdef DITHERING
        if (dir == -1)
        {
            if (type == PNG_COLOR_TYPE_RGB_ALPHA)
                s += (width-1) * 4;
            else
                s += width-1;
            m += width-1;
            b += ((width-1) * bgdepth) >> 3;
            bbit = ((width-1) * bgdepth) & 7;
        }

        error_red = error_green = error_blue = 0;
        #endif

        for (x = width; x; x--)
        {
            switch (type)
            {
              case PNG_COLOR_TYPE_PALETTE:
                #ifdef DITHERING
                fg = palette[*s * 2];
                s += dir;
                #else
                fg = palette[*s++ * 2];
                #endif
                alpha = fg & 0xFF;
                if (alpha == 0)
                    goto leave_background;
                blue = fg >> 24;
                green = (fg >> 16) & 0xFF;
                red = (fg >> 8) & 0xFF;
                break;

              case PNG_COLOR_TYPE_GRAY_ALPHA:
                #ifdef DITHERING
                alpha = *m;
                m += dir;
                #else
                alpha = *m++;
                #endif
                if (alpha == 0)
                {
                    #ifdef DITHERING
                    s += dir;
                    #else
                    s++;
                    #endif
                    goto leave_background;
                }
                #ifdef DITHERING
                red = green = blue = *s;
                s += dir;
                #else
                red = green = blue = *s++;
                #endif
                break;

              case PNG_COLOR_TYPE_RGB_ALPHA:
                fg = *((int *) s);
                #ifdef DITHERING
                s += 4 * dir;
                #else
                s += 4;
                #endif
                alpha = fg >> 24;
                if (alpha == 0)
                {
                  leave_background:
                    #ifdef DITHERING
                    error_red = error_green = error_blue = 0;
                    if (bgdepth >= 8)
                    {
                        if (dir == 1)
                            b += bgdepth >> 3;
                        else
                            b -= bgdepth >> 3;
                    }
                    else
                    {
                        if (dir == 1)
                        {
                            if ((bbit += bgdepth) == 8)
                            {
                                bbit = 0;
                                b++;
                            }
                        }
                        else
                        {
                            if ((bbit -= bgdepth) < 0)
                            {
                                bbit = 8-bgdepth;
                                b--;
                            }
                        }
                    }
                    #else
                    if (bgdepth >= 8)
                        b += bgdepth;
                    else
                    {
                        if ((bbit += bgdepth) == 8)
                        {
                            bbit = 0;
                            b++;
                        }
                    }
                    #endif
                    continue;
                }
                blue = (fg >> 16) & 0xFF;
                green = (fg >> 8) & 0xFF;
                red = fg & 0xFF;
                break;
            }

            if (alpha != 255)
            {
                switch (bgdepth)
                {
                  case 1:
                    bg = (*b >> bbit) & 1;
                    goto read_palette;

                  case 2:
                    bg = (*b >> bbit) & 3;
                    goto read_palette;

                  case 4:
                    bg = (*b >> bbit) & 0xF;
                    goto read_palette;

                  case 8:
                    bg = *b;
                  read_palette:
                    bg = bgpalette[bg * 2];
                    bgblue = bg >> 24;
                    bggreen = (bg >> 16) & 0xFF;
                    bgred = (bg >> 8) & 0xFF;
                    break;

                  case 16:
                  {
                    bg = *((unsigned short *) b);
                    bgred   = (bg << 3) & 0xF8; bgred   |= bgred   >> 5;
                    bggreen = (bg >> 2) & 0xF8; bggreen |= bggreen >> 5;
                    bgblue  = (bg >> 7) & 0xF8; bgblue  |= bgblue  >> 5;
                    break;
                  }

                  case 32:
                    bg = *((unsigned int *) b);
                    bgblue = (bg >> 16) & 0xFF;
                    bggreen = (bg >> 8) & 0xFF;
                    bgred = bg & 0xFF;
                    break;
                }

                alpha = alpha + (alpha >> 7);   /* Rescale to 0..256 */
                bg_alpha = 256 - alpha;

                /*
                 * The background we captured is gamma adjusted for the
                 * screen - get back to linear before we do the maths
                 */
                bgblue  = screen_to_1[bgblue];
                bggreen = screen_to_1[bggreen];
                bgred   = screen_to_1[bgred];

                /*
                 * (Partially opaque colours in the image are already
                 * linear)
                 */

                blend(bgblue,  bg_alpha, blue);
                blend(bggreen, bg_alpha, green);
                blend(bgred,   bg_alpha, red);

                bgblue  = screen_from_1[bgblue];
                bggreen = screen_from_1[bggreen];
                bgred   = screen_from_1[bgred];
            }
            else
            {
                /*
                 * Fully opaque case - we "cheat" by stored fully screen
                 * gamma corrected data in this case only!
                 */
                bgblue = blue;
                bggreen = green;
                bgred = red;
            }

            #ifdef DITHERING
            bgblue += error_blue;
            bggreen += error_green;
            bgred += error_red;
            if (bgblue < 0) bgblue = 0; else if (bgblue > 255) bgblue = 255;
            if (bggreen < 0) bggreen = 0; else if (bggreen > 255) bggreen = 255;
            if (bgred < 0) bgred = 0; else if (bgred > 255) bgred = 255;
            truered = bgred;
            truegreen = bggreen;
            trueblue = bgblue;
            #endif

            if (bgdepth != 32)
                bg = ((bgblue & 0xF8) << 7) | ((bggreen & 0xF8) << 2) | (bgred >> 3);
            else
                bg = (bgblue << 16) | (bggreen << 8) | bgred;

            switch (bgdepth)
            {
              case 1:
                c = cttable[bg];
                if (osver < 0xA5)
                    c = ro310_2nd_table[c];
                *b = (*b &~ (1 << bbit)) | (c << bbit);
                goto advance_bit;

              case 2:
                c = cttable[bg];
                if (osver < 0xA5)
                    c = ro310_2nd_table[c];
                *b = (*b &~ (3 << bbit)) | (c << bbit);
                goto advance_bit;

              case 4:
                c = cttable[bg];
                if (osver < 0xA5)
                    c = ro310_2nd_table[c];
                *b = (*b &~ (0xF << bbit)) | (c << bbit);
              advance_bit:
                #ifdef DITHERING
                if (dir == 1)
                {
                    if ((bbit += bgdepth) == 8)
                    {
                        bbit = 0;
                        b++;
                    }
                }
                else
                {
                    if ((bbit -= bgdepth) < 0)
                    {
                        bbit = 8 - bgdepth;
                        b--;
                    }
                }
                goto get_result;
                #else
                if ((bbit += bgdepth) == 8)
                {
                    bbit = 0;
                    b++;
                }
                #endif
                break;

              case 8:
                c = cttable[bg];
                #ifdef DITHERING
                *b = c;
                if (dir == 1)
                    b++;
                else
                    b--;
              get_result:
                result = bgpalette[c * 2];
                result_blue = result >> 24;
                result_green = (result >> 16) & 0xFF;
                result_red = (result >> 8) & 0xFF;
                #else
                *b++ = c;
                #endif
                break;

              case 16:
                *(unsigned short *) b = bg;
                #ifdef DITHERING
                if (dir == 1)
                    b += 2;
                else
                    b -= 2;
                result_red = (bgred & 0xF8) | (bgred >> 5);
                result_green = (bggreen & 0xF8) | (bggreen >> 5);
                result_blue = (bgblue & 0xF8) | (bgblue >> 5);
                #else
                b += 2;
                #endif
                break;
              case 32:
                *(unsigned int *) b = bg;
                #ifdef DITHERING
                if (dir == 1)
                    b += 4;
                else
                    b -= 4;
                #else
                b += 4;
                #endif
                continue;
            }

            #ifdef DITHERING
            error_red = truered - result_red;
            error_green = truegreen - result_green;
            error_blue = trueblue - result_blue;
            #endif

        } /* end x loop */

        dir = -dir;

    } /* end y loop */

}
@


1.28
log
@Fixed _swix calls
@
text
@d2174 1
d2254 7
d2262 1
a2262 1
    e=_swix(OS_SpriteOp, _INR(0,3)|_OUTR(1,3), 0x13C, newarea, "sprite", 0,
@


1.27
log
@Now links in IJG 6a code - can either use SpriteExtend or do it itself
@
text
@d1826 1
a1826 1
            e=_swix(OS_Plot, 4, x, y);
d1828 2
a1829 2
            e=_swix(OS_Plot, 0x60 | 1, this->width_os*scale/100-1,
                                       this->height_os*scale/100-1);
@


1.26
log
@Updated to pnglib-0.99f. Some code in ImageLib/png.c tidied up and
commented better.
@
text
@d514 5
a518 1
    /* Extract the background colour in a useful form */
d531 1
d552 1
d561 1
d564 3
a566 3
              bg_r >>= 8;
              bg_g >>= 8;
              bg_b >>= 8;
d576 3
a578 1
    /* Enable filling in of interlace */
d581 5
d589 1
a589 1
     * Okay, we will now be getting data in one of these formats:
d596 2
a598 2

    /* Get the transformed properties */
@


1.25
log
@Updated to libpng-0.99e and zlib-1.1.1
@
text
@d31 1
a40 1
#define PNG_INTERNAL  /* Give ourselves slightly more intimate access */
d74 1
a74 1
static png_bytep screen_to_1, screen_from_1, hack_to_screen, hack_to_1;
d125 1
a289 6
    /*
     * Set these up for our hacky premultiply routine...
     */
    hack_to_1 = load->file_to_1;
    hack_to_screen = load->file_to_screen;

d300 23
d332 1
a332 1
    png_color *palette;
d339 13
d353 9
a361 3
    /* First decide if we're going to do alpha processing */
    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
        info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
d365 1
a365 1
    else if (info->valid & PNG_INFO_tRNS)
d367 1
a367 2
        png_get_tRNS(png_ptr, info, &trans, &num_trans, &trans_values);
        if (info->color_type == PNG_COLOR_TYPE_PALETTE)
a370 1
            {
a375 1
            }
d379 8
a386 1
    if (this->full_alpha || info->valid & PNG_INFO_bKGD)
d395 2
a396 2
        if (info->valid & PNG_INFO_gAMA)
            g = 1.0 / info->gamma;
d400 1
a400 11
        load->file_to_1 = malloc(256);
        if (!load->file_to_1)
            png_error(png_ptr, "Insufficient memory");

        for (i = 1; i <= 254; i++)
        {
           load->file_to_1[i] = (png_byte)(pow((double)i / 255.0,
              g) * 255.0 + .5);
        }
        load->file_to_1[0] = 0;
        load->file_to_1[255] = 255;
d405 2
a406 2
        if (info->valid & PNG_INFO_gAMA)
            g = 1.0 / (info->gamma * SCREEN_GAMMA);
d410 1
a410 11
        load->file_to_screen = malloc(256);
        if (!load->file_to_screen)
            png_error(png_ptr, "Insufficient memory");

        for (i = 1; i <= 254; i++)
        {
            load->file_to_screen[i] = (png_byte)(pow((double)i / 255.0,
               g) * 255.0 + .5);
        }
        load->file_to_screen[0] = 0;
        load->file_to_screen[255] = 255;
d416 1
a416 15
        {
            screen_from_1 = malloc(256);
            if (!screen_from_1)
                png_error(png_ptr, "Insufficient memory");

            g = 1.0 / SCREEN_GAMMA;

            for (i = 1; i <= 254; i++)
            {
               screen_from_1[i] = (png_byte)(pow((double)i / 255.0,
                  g) * 255.0 + .5);
            }
            screen_from_1[0] = 0;
            screen_from_1[255] = 255;
        }
d422 1
a422 18
        {
            screen_to_1 = (png_bytep) malloc(256);
            if (!screen_to_1)
                png_error(png_ptr, "Insufficient memory");

            g = SCREEN_GAMMA;

            for (i = 1; i <= 254; i++)
            {
                screen_to_1[i] = (png_byte)(pow((double)i / 255.0,
                   g) * 255.0 + .5);
            }
            screen_to_1[0] = 0;
            screen_to_1[255] = 255;
        }

        hack_to_1 = load->file_to_1;
        hack_to_screen = load->file_to_screen;
d425 5
a429 2
    /* Only 8 bits per channel under RISC OS */
    if (info->bit_depth == 16)
d432 8
a439 1
    if (info->bit_depth < 8)
a441 2
        {
            /* Need 8bpp data for blending code */
a442 1
        }
d447 9
a455 2
    if ((info->color_type == PNG_COLOR_TYPE_RGB ||
         info->color_type == PNG_COLOR_TYPE_RGB_ALPHA) && osver >= 0xA5)
d457 3
a459 1
        if (!this->full_alpha && (info->valid & PNG_INFO_sBIT))
d461 1
a461 1
            if (info->sig_bit.red <= 5 && info->sig_bit.green <= 5 && info->sig_bit.blue <= 5)
d466 7
a472 1
    if (info->color_type == PNG_COLOR_TYPE_RGB)
d475 3
a477 2
    /* Can't handle RGB data with transparency - need to know data
     * values pre-gamma for palette/greyscale trick to work - get the library
d479 3
a481 1
     * grey+alpha...
d483 1
a483 1
    if (info->valid & PNG_INFO_tRNS)
d485 2
a486 2
        if (info->color_type == PNG_COLOR_TYPE_RGB ||
            info->color_type == PNG_COLOR_TYPE_GRAY && info->bit_depth == 16)
d490 6
d498 1
a498 1
        if (info->color_type & PNG_COLOR_MASK_COLOR) /* We do greyscale ourselves */
d500 4
a503 2
            if (info->valid & PNG_INFO_gAMA)
                png_set_gamma(png_ptr, SCREEN_GAMMA, info->gamma);
d510 2
a511 2
        if (info->color_type != PNG_COLOR_TYPE_PALETTE)
            png_set_premultiply_alpha(png_ptr);
d515 1
a515 1
    if (info->valid & PNG_INFO_bKGD)
d517 4
a520 4
        unsigned int bg_r = info->background.red;
        unsigned int bg_g = info->background.green;
        unsigned int bg_b = info->background.blue;
        unsigned int bg_m = info->background.gray;
d523 1
a523 1
        switch (png_ptr->color_type)
d528 1
a528 1
            switch (info->bit_depth)
d547 4
a550 4
            bg_i = info->background.index;
            bg_r = info->palette[bg_i].red;
            bg_g = info->palette[bg_i].green;
            bg_b = info->palette[bg_i].blue;
d555 1
a555 1
            if (info->bit_depth == 16)
d584 5
a588 2
    if (info->color_type == PNG_COLOR_TYPE_RGB ||
        info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
d614 1
a614 1
        switch (info->bit_depth)
d623 6
a628 2
    this->width = info->width;
    this->height = info->height;
d630 1
a630 3
    #if 0
    /* Don't support the pHYS chunk - it sucks */
    if ((info->valid & PNG_INFO_pHYs) && info->phys_unit_type < PNG_RESOLUTION_LAST)
d632 9
a640 1
        switch (info->phys_unit_type)
d642 11
a652 23
          case PNG_RESOLUTION_UNKNOWN:
            if (this->width_os==-1)
            {
                if (info->x_pixels_per_unit > info->y_pixels_per_unit)
                    this->width_os = info->width * 2;
                else
                    this->width_os = info->width * 2 * info->y_pixels_per_unit / info->x_pixels_per_unit;
            }
            if (this->height_os==-1)
            {
                if (info->x_pixels_per_unit > info->y_pixels_per_unit)
                    this->height_os = info->height * 2 * info->x_pixels_per_unit / info->y_pixels_per_unit;
                else
                    this->height_os = info->height * 2;
            }
            break;

          case PNG_RESOLUTION_METER:
            if (this->width_os==-1)
                this->width_os = info->width * 180.0F / (info->x_pixels_per_unit * 0.0254F);
            if (this->height_os==-1)
                this->height_os = info->height * 180.0F / (info->y_pixels_per_unit * 0.0254F);
            break;
d654 1
d656 5
a660 1
    else
a661 6
    {
        if (this->width_os==-1)
            this->width_os = info->width * 2;
        if (this->height_os==-1)
            this->height_os = info->height * 2;
    }
d663 3
a665 3
    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
        riscos_rowbytes = info->width;
    else if (info->color_type == PNG_COLOR_TYPE_RGB || info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
d668 1
a668 1
            riscos_rowbytes = info->width;
d670 1
a670 1
            riscos_rowbytes = info->width * 2;
d672 1
a672 1
            riscos_rowbytes = info->width * 4;
d675 1
a675 1
        riscos_rowbytes = info->rowbytes;
d680 3
a682 3
    if ((info->color_type&~PNG_COLOR_MASK_ALPHA) == PNG_COLOR_TYPE_GRAY && !this->full_alpha)
        num_palette = pal_entries = 1 << info->bit_depth;
    else if (info->color_type == PNG_COLOR_TYPE_PALETTE)
d684 2
a685 2
        num_palette = info->num_palette;
        pal_entries = 1 << info->bit_depth;
d687 1
a687 1
    else if (osver < 0xA5 && info->color_type == PNG_COLOR_TYPE_RGB)
d699 1
a699 1
    mem += load->spritewidth * info->height;
d701 1
a701 1
    if (!this->full_alpha || info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
d704 1
a704 1
          load->maskwidth = ((info->width + 31) &~ 31) / 8;
d708 1
a708 1
       mem += load->maskwidth * info->height;
d715 1
a715 1
           if (!(info->color_type & PNG_COLOR_MASK_ALPHA) && !(info->valid & PNG_INFO_tRNS))
d720 1
a720 1
                   mem -= load->maskwidth * info->height;
d738 1
a738 1
            mem -= load->maskwidth * info->height;
a795 2
        palette = info->palette;

d800 1
a800 1
        if (this->full_alpha && info->color_type == PNG_COLOR_TYPE_PALETTE)
d841 2
a842 2
            if (info->color_type == PNG_COLOR_TYPE_GRAY ||
                info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
d850 1
a850 1
                    if (info->valid & PNG_INFO_gAMA)
d852 3
a854 2
                        gamma = 1.0 / (info->gamma * SCREEN_GAMMA);
                        do_gamma = fabs(gamma - 1.0) >= PNG_GAMMA_THRESHOLD;
d861 1
a861 1
                    end = (1 << info->bit_depth) - 1;
d901 1
a901 1
    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
d903 1
a903 1
        if (!flex_alloc((flex_ptr) &load->temp, info->width * 2))
d909 1
a909 1
    else if ((osver < 0xA5 && (info->color_type == PNG_COLOR_TYPE_RGB || info->color_type == PNG_COLOR_TYPE_RGB_ALPHA) && !this->full_alpha)
d912 1
a912 1
        if (!flex_alloc((flex_ptr) &load->temp, info->width * 4))
d923 1
a923 1
        if (info->interlace_type == 1 && !load->removemask)
d927 1
a927 1
    load->color_type = info->color_type;
d972 4
a975 1
    int y;
d979 2
d1020 1
a1020 1
    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
d1028 1
a1028 1
        for (i = info->width; i; i--)
d1039 1
a1039 1
        convert_row_15bit_to_24bit(load->temp, row, info->width);
d1043 1
a1043 1
    else if (osver < 0xA5 && (info->color_type == PNG_COLOR_TYPE_RGB || info->color_type == PNG_COLOR_TYPE_RGB_ALPHA) && !this->full_alpha)
d1045 1
a1045 1
        convert_row_8bit_to_24bit(load->temp, row, mask_row, (unsigned int *) this->private_data2 + 15, info->width);
d1052 1
a1052 1
    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
d1065 1
a1065 1
            for (i = info->width; i; i--)
d1073 1
a1073 1
            for (i = info->width; i; i--)
d1084 2
a1085 2
            convert_32bit_alpha_to_mask(load->temp, mask_row, info->width);
        convert_row_24bit_to_15bit(load->temp, row, info->width);
d1087 1
a1087 1
    else if (info->color_type == PNG_COLOR_TYPE_RGB || info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
d1091 2
a1092 2
            if (osver >= 0xA5 && info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
                convert_32bit_alpha_to_mask(row, mask_row, info->width);
d1096 1
a1096 1
                convert_row_24bit_to_8bit(load->temp, row, mask_row, (char *)ct32k_buffer[1], info->width);
d1100 1
a1100 1
    else if (info->valid & PNG_INFO_tRNS)
d1103 1
a1103 1
            convert_trns_to_mask(row, mask_row, info->width, info->bit_depth, info->trans, info->num_trans, &info->trans_values, info->color_type);
d1338 1
a1338 1
void png_premultiply_and_gamma_correct(png_row_infop row_info, png_bytep row)
d1340 2
d1345 2
a1346 2
    png_bytep file_to_1 = hack_to_1;
    png_bytep file_to_screen = hack_to_screen;
@


1.24
log
@Subtle litte PNG problem fixed: images of 4bpp or less with simple
transparency would sometimes have a couple of columns of pixels at the
left incorrectly transparent.
@
text
@a29 1
#ifdef TRACE
a30 1
#endif
@


1.23
log
@Printing fixed a bit more
@
text
@d1116 2
a1117 1
        shift = s_start = 7;
d1124 2
a1125 1
        shift = s_start = 6;
d1132 2
a1133 1
        shift = s_start = 4;
@


1.22
log
@Lots of printing problems fixed
@
text
@d84 1
a84 1
static _kernel_oserror *ModeChange(Image *this);
d1695 1
a1695 1
static _kernel_oserror *ModeChange(Image *this)
d1789 3
a1791 1
    if (this->modechanged || !this->factors[0])
d1793 1
a1793 1
        e=ModeChange(this);
a1797 2
    _swix(PDriver_CurrentJob, _OUT(0), &job);

d1828 2
a1829 2
    if (log2bpp <= 3 && this->table == NULL && fac[0] == fac[2] && fac[1] == fac[3])
        e=_swix(OS_SpriteOp, _INR(0,5), 256+PutSprite,
d1831 1
a1831 1
                                        "png",
d1835 1
a1835 1
        e=_swix(OS_SpriteOp, _INR(0,7), 256+PutSpriteScaled,
d1837 1
a1837 1
                                        "png",
d2134 1
a2134 1
    ModeChange(this);
@


1.21
log
@1-pixel high backgrounds occasionally got scrambled
@
text
@d1699 4
d1725 1
a1725 1
    if (log2bpp <= 3)
d1728 3
a1730 2
        e=_swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4), this->private_data2, "png", -1, -1,
                                                    0, 0, &bufsize);
d1735 1
d1743 3
a1745 2
                    e=_swix(ColourTrans_GenerateTable, _INR(0,5), this->private_data2, "png", -1, -1,
                                                                  this->table, 0);
d1752 3
a1754 2
    e=_swix(Wimp_ReadPixTrans, _INR(0,2)|_INR(6,7), 256, this->private_data2, "png",
                                                    this->factors, 0);
d1758 4
a1761 4
        this->factors[0]*=this->width_os;
        this->factors[1]*=this->height_os;
        this->factors[2]*=this->width*2;
        this->factors[3]*=this->height*2;
d1858 1
a1858 1
    int *bgpal;
d1950 1
a1950 1
    switch (log2bpp)
d1952 15
a1966 6
        case 0: mode = 25;              break;
        case 1: mode = 26;              break;
        case 2: mode = 27;              break;
        case 3: mode = 28;              break;
        case 4: mode = MODE(5, 90, 90); break;
        case 5: mode = MODE(6, 90, 90); break;
d2038 1
a2038 1
                log2bpp);
@


1.20
log
@One pixel high background PNGs and GIFs fixed (again).
@
text
@d2230 1
a2230 1
      int           n, sw, bpp, widthinbytes;
d2232 1
a2232 1
      bpp = 1<< log2bpp;
d2234 1
a2234 4
      widthinbytes = (this->width * bpp) / 8;
      if (this->width % bpp) widthinbytes++;

      sw = (widthinbytes+3)&~3;
@


1.19
log
@Stripped down libpng a bit more.
Withdrew PNG pHYs support (it sucked).
Made spare palette entries of alpha images opaque black instead of transparent.
More fixes for greyscale palettes.
Made export of alpha PNGs work (for real this time).
Made transparent GIF backgrounds work.
@
text
@d2112 1
d2147 11
d2223 22
@


1.18
log
@Improved display during first pass of PNGs.
Fixed saving of greyscale+alpha and true-colour+alpha PNGs as sprites.
Background filled in for alpha PNGs if no filler function registered.
ImageTest updated to work again.
@
text
@a39 1
#include "png.h"
d45 2
d602 2
d634 1
d659 2
a660 2
    if ((info->color_type &~ PNG_COLOR_MASK_ALPHA) == PNG_COLOR_TYPE_GRAY)
        num_palette = pal_entries = 1 << min(info->bit_depth, 8);
d666 1
a666 1
    else if (osver < 0xA5 && (info->color_type == PNG_COLOR_TYPE_RGB || info->color_type == PNG_COLOR_TYPE_RGB_ALPHA) && !this->full_alpha)
d814 1
a814 1
            /* Any spare palette entries are zeroed */
d817 1
a817 1
                this->private_data2[15 + i * 2 + 1] = 0;
d825 1
a825 11
                if (this->full_alpha || !(info->valid & PNG_INFO_gAMA))
                {
                    /* Palette not important - just fill a simple one in anyway */
                    for (i = 0; i < num_palette; i++)
                    {
                        c = (i << 24) | (i << 16) | (i << 8);
                        this->private_data2[15 + i * 2] =
                        this->private_data2[15 + i * 2 + 1] = c;
                    }
                }
                else
d829 1
a829 1
                    double gamma = 1.0 / (info->gamma * SCREEN_GAMMA);
d831 7
a837 1
                    do_gamma = fabs(gamma - 1.0) >= PNG_GAMMA_THRESHOLD;
a939 1
static void convert_trns_to_mask(const png_bytep row, png_bytep mask_row, png_uint_32 width, int depth, png_bytep trans, int num_trans, const png_color_16 *trans_values, int color_type);
d1105 1
a1105 1
static void convert_trns_to_mask(const png_bytep row, png_bytep mask_row, png_uint_32 width, int depth, png_bytep trans, int num_trans, const png_color_16 *trans_values, int color_type)
d1483 2
a1484 2
        fileheader.freeoff = load->mask_offset;
        fileheader.next = load->mask_offset - 16;
d1530 2
a1531 2
        fileheader.freeoff = 16 +44 + sprwidth * this->height;
        fileheader.next = 44 + sprwidth * this->height;
d1537 1
a1537 1
        fileheader.rbit = osver < 0xA5 ? (this->width & 3) * 8 - 1
@


1.17
log
@More optimisations - in particular background GIFs are now converted into
the current mode and palette.
Sprite plotter (used for backgrounds) sped up.
Background chunk now read correctly and gamma corrected in PNGs (for
sprite output and use as page backgrounds).
Support for PNG pHYS chunk added.
<8bpp greyscale PNGs where no gamma correction was done didn't work.
@
text
@d82 1
a82 1
static _kernel_oserror *Render(Image *this, int x, int y, int scale, int x_size, int y_size);
d101 1
d110 1
d214 1
a214 1
    im->Render=Render;
d676 1
a676 3
    if (!this->full_alpha &&
            ((info->color_type & PNG_COLOR_MASK_ALPHA) || (info->valid & PNG_INFO_tRNS))
        || info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
d688 1
d690 14
d708 1
d711 9
d903 1
a903 1
        if (info->interlace_type == 1)
d957 19
d981 1
d983 8
a990 2
                                load->mask_offset +
                                load->maskwidth * row_num;
d1399 22
a1420 2
    int *temppal, i;
    unsigned int bg_r, bg_g, bg_b;
d1429 1
a1429 1
        bg_r = bg_g = bg_b = 0;
d1474 4
a1477 1
        break;
d1479 42
a1520 1
        break;
d1522 30
a1551 4
        if (load->isreally32bit)
            this->private_data2[14] = MODE(6, 90, 90);
        break;
    }
d1553 15
a1567 1
    e = _swix(OS_SpriteOp, _INR(0,2), 256+12, this->private_data2, filename);
d1569 19
a1587 12
    switch (load->color_type)
    {
      case PNG_COLOR_TYPE_PALETTE:
        memcpy(this->private_data2+15, temppal, 256*2*4);
        free(temppal);
        break;
      case PNG_COLOR_TYPE_GRAY_ALPHA:
        break;
      case PNG_COLOR_TYPE_RGB_ALPHA:
        if (load->isreally32bit)
            this->private_data2[14] = 28;
        break;
d1589 5
a1593 1
    return e;
d1634 1
a1634 1
        this->mutable_mask=this->transparent;
d1761 1
a1761 1
static _kernel_oserror *Render(Image *this, int x, int y, int scale, int x_size, int y_size)
d1766 1
d1789 2
a1791 3
    {
        int job = 0;
        _swix(PDriver_CurrentJob, _OUT(0), &job);
a1792 1
    }
d1854 1
a1854 1
    int width = this->width, height = this->height;
d1884 1
d1890 1
d1892 1
a1892 1
            var.clip.ymax < y || var.clip.ymin >= y + y_size)
d1897 1
a1897 1
        if (var.clip.ymin < y) var.clip.ymin = y;
d1935 4
d1980 20
a1999 1
    if (!e) e = load->filler(load->filler_handle1, load->filler_handle2);
d2013 1
a2013 1
    blend_image(width, height,
d2208 1
a2208 1
    this->Render(this, 0, 0, 100, -1, -1);
@


1.16
log
@Removed lots of compilation warnings in PNG stuff.
Added some "fast plot without translation" optimisations.
Convert RGB PNGs with <=5 significant bits on every channel into 16bpp sprites.
Fixed a few RGB/greyscale tRNS anomalies.
Made sure no gamma correction occurs if no gAMA chunk in PNG.
Ensured that values 0 and 255 in alpha blending gamma tables are correct.
Made < 8bpp paletted PNGs with complex transparency work.
Made n bpp paletted PNGs with <n^(1/2) palette entries work. (eg 8bpp images
with 8 palette entries (yuck)).
Ensured spare palette entries in PNGs cleared.
Added support for saving paletted transparent PNGs as sprites composited onto the PNG
background colour.
Added support for alpha blending in < 8bpp modes.
@
text
@d98 1
d101 1
a101 1
    unsigned int bkgd;
d344 1
a344 12
    //if (/*this->flags & IMAGE_FAST ||*/ osver < 0xA5)
       // this->full_alpha = 0;

    /*if (this->full_alpha)
    {
        ModeChange(NULL);

        if (log2bpp < 3)
            this->full_alpha = 0;
    }*/

    if (this->full_alpha)
d490 55
d599 36
a634 4
    if (this->width_os==-1)
        this->width_os = info->width * 2;
    if (this->height_os==-1)
        this->height_os = info->height * 2;
a798 1
                  dont_bother_with_gray_gamma:
d809 1
a809 1
                    int g, end, step;
d812 1
a812 2
                    if (fabs(gamma - 1.0) < PNG_GAMMA_THRESHOLD)
                        goto dont_bother_with_gray_gamma;
d821 4
a824 1
                        c = (png_byte)(pow((double)g / 255.0, gamma) * 255.0 + .5);
d884 2
a885 1
    if (info->valid & PNG_INFO_bKGD)
a886 5
        load->bkgd = ((info->background.blue>>(info->bit_depth-8))<<24) |
                     ((info->background.green>>(info->bit_depth-8))<<16) |
                     ((info->background.red>>(info->bit_depth-8))<<8);
        load->have_bkgd = 1;

d892 11
a902 1
            _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), load->bkgd, 128, 0);
d1626 1
a1626 2
        //if (job || log2bpp >= 3)
            return RenderWithAlpha(this, x, y, scale, x_size, y_size, job ? (osver >= 0xA5 ? 5 : 3) : log2bpp, job);
a1677 3
/*
 * Assumes : log2bpp = 3,4,5
 */
d2002 7
a2008 1
        bg = load->bkgd;
a2044 1
    this->ModeChange=ModeChangeSprite;
d2062 8
a2069 1
    l->pal =0;
@


1.15
log
@Did major sorting out of 24 bit PNG images on RISC OS 3.1.
Implemented alpha blending on RISC OS 3.1.
@
text
@a54 1
/*#define GAMMA_DITHER*/
d60 1
d77 1
d89 1
d99 1
d317 1
a317 1
    int num_trans = 0, useropal = 0;
d346 1
a346 1
    if (this->full_alpha)
d352 1
a352 1
    }
d363 1
a363 1
        if (info->gamma)
d366 1
a366 1
            g = 1.0 / 0.45;
d372 1
a372 1
        for (i = 0; i < 256; i++)
d377 2
d383 1
a383 1
        if (info->gamma)
d386 1
a386 1
            g = 1.0 / (0.45 * SCREEN_GAMMA);
d392 1
a392 1
        for (i = 0; i < 256; i++)
d397 2
d411 1
a411 1
            for (i = 0; i < 256; i++)
d416 2
d431 1
a431 1
            for (i = 0; i < 256; i++)
d436 2
d453 1
a453 1
            png_set_expand(png_ptr);
d459 2
a460 2
    if (info->color_type == PNG_COLOR_TYPE_RGB ||
        info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
d462 1
a462 5
        /* Add a filler if alpha missing */
        if (info->color_type == PNG_COLOR_TYPE_RGB)
            png_set_filler(png_ptr, 0, PNG_FILLER_AFTER);

        if (osver >= 0xA5)
d464 2
a465 1
            mode = MODE(6,90,90);
d467 1
a467 8
        else
        {
            if (!ct32k_buffer[1])
            {
                load_inversetable();
                if (!ct32k_buffer[1])
                    png_error(png_ptr, "Insufficient memory");
            }
d469 2
a470 17
            if (this->full_alpha)
                mode = MODE(6,90,90);
            else
                mode = 28;
        }
    }
    else
    {
        switch (info->bit_depth)
        {
            case 1:  mode = 25; break;
            case 2:  mode = 26; break;
            case 4:  mode = 27; break;
            case 8:
            case 16: mode = 28; break;
        }
    }
d472 5
a476 1
    /* Can't handle 16bpp data with transparency - turn it into 8bpp with alpha */
d479 2
a480 1
        if (info->bit_depth == 16 || info->color_type == PNG_COLOR_TYPE_RGB)
d486 7
a492 4
        if (info->valid & PNG_INFO_gAMA)
            png_set_gamma(png_ptr, SCREEN_GAMMA, info->gamma);
        else
            png_set_gamma(png_ptr, SCREEN_GAMMA, 0.45);
a499 1

d515 36
d565 2
d581 1
a581 4
        if (num_palette > 16)     pal_entries = 256;
        else if (num_palette > 4) pal_entries = 16;
        else if (num_palette > 2) pal_entries = 4;
        else                      pal_entries = 2;
d669 1
a669 10
        if (info->color_type == PNG_COLOR_TYPE_GRAY ||
            info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
        {
            palette = png_malloc(png_ptr, num_palette * sizeof(png_color));
            png_build_grayscale_palette(min(info->bit_depth, 8), palette);
            png_correct_palette(png_ptr, palette, num_palette);
            png_ptr->transformations &= ~PNG_GAMMA;
        }
        else
            palette = info->palette;
d675 1
a675 1
        if (this->full_alpha)
d681 1
a681 1
            for (i = 0; i < pal_entries; i++)
a691 5
                    #ifdef GAMMA_DITHER
                    r = load->file_to_1[r];
                    g = load->file_to_1[g];
                    b = load->file_to_1[b];
                    #else
a694 1
                    #endif
d707 6
d716 2
a717 1
            for (i = 0; i < pal_entries; i++)
d719 36
a754 5
                c = (palette[i].blue << 24) |
                    (palette[i].green << 16) |
                    (palette[i].red << 8);
                this->private_data2[15 + i * 2] =
                this->private_data2[15 + i * 2 + 1] = c;
d756 11
a766 1
        }
d768 5
a772 4
        if (info->color_type == PNG_COLOR_TYPE_GRAY ||
            info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
        {
            png_free(png_ptr, palette);
d786 2
a787 1
    else if (osver < 0xA5 && (info->color_type == PNG_COLOR_TYPE_RGB || info->color_type == PNG_COLOR_TYPE_RGB_ALPHA) && !this->full_alpha)
d806 1
a806 1
    if (info->valid & PNG_INFO_bKGD && !(osver < 0xA5 && mode==MODE(6,90,90)))
a807 1
        /* Clear the background */
d811 1
d813 9
a821 7
        _swix(OS_SpriteOp, _INR(0,3)|_OUTR(1,3), 256+60, this->private_data2, "png", 0,
        	    	    	    	    	     &r1, &r2, &r3);
        _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), load->bkgd, 128, 0);
        _swix(OS_WriteI + 16, 0);
        _swix(OS_SpriteOp, _INR(0,3), 256+60, r1, r2, r3);

        load->have_bkgd = 1;
d835 2
d878 6
d921 7
d1038 1
a1038 1
    else if (color_type == PNG_COLOR_TYPE_GRAY)
a1062 33
    else /* color_type == PNG_COLOR_TYPE_RGB && bit_depth == 8 */
    {
        unsigned int trans_col = (trans_values->blue << 16) |
                                 (trans_values->green << 8) |
                                 trans_values->red;

        dp = mask_row + ((width - 1) >> 3);
        shift = 7;

        for (i = width; i; i--)
        {
            int pix;

            pix = *(int *) sp;
            if (pix & 0x00ffffff == trans_col)
                alpha = 0;
            else
                alpha = 1;

            *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
            *dp |= (png_byte)(alpha << shift);

            if (shift == 0)
            {
                shift = 7;
                dp--;
            }
            else
                shift--;

            sp -= 4;
        }
    }
d1072 1
a1072 2
    int shift, alpha, i;
    unsigned int pix;
d1135 41
d1178 3
a1180 1
    int a, r, g, b, x;
d1246 3
d1260 86
d1451 3
d1456 6
d1463 3
a1465 2
    e=_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 9, &log2bpp);
    if (e) return e;
d1481 10
a1490 3
            this->table=malloc(bufsize);
            if (!this->table)
                e=pngError("Insufficient memory");
a1492 3
        if (!e)
        e=_swix(ColourTrans_GenerateTable, _INR(0,5), this->private_data2, "png", -1, -1,
                                                    this->table, 0);
d1542 1
a1542 1
        if (job || log2bpp >= 3)
d1571 18
a1588 10
    if (!e)
    e=_swix(OS_SpriteOp, _INR(0,7), 256+PutSpriteScaled,
                                    this->private_data2,
                                    "png",
                                    x, y,
                                    osver >= 0xa5 ? PutSpriteScaled_UsePalette |
                                                    PutSpriteScaled_UseMask
                                                  : PutSpriteScaled_UseMask,
                                    fac,
                                    log2bpp <=3 ? this->table : 0);
a1599 1
    int bgmem;
d1602 1
a1602 4
    sprite_area *bgarea;
    int oldsw0, oldsw1, oldsw2, oldsw3;
    int savesize;
    void *table = 0, *savearea = 0;
d1605 1
a1605 2
    int oldbudge, oldcompact;
    int *palette = 0;
a1608 1
    static int imageno;
d1694 3
a1701 3
    bgwidth = width * (1 << (log2bpp - 3));
    bgwidth = (bgwidth + 3) &~ 3;

d1778 6
a1783 1
    if (log2bpp == 3 || printing)
d1790 1
a1790 2
        table = malloc(bufsize);
        if (!table)
d1792 9
a1800 2
            e=pngError("Insufficient memory");
            goto error2;
a1801 3

        e=BufferSprite_GenerateTable(table);
        if (e) goto error2;
a1807 1
 error1:
a1836 1
    int bufsiz;
d2003 1
a2003 1
    int bgdepth = 1 << (bglog2bpp - 3);
d2006 1
a2006 1
    unsigned int fg, bg;
d2008 1
a2008 1
    int x, y;
d2018 1
a2018 1
    if (bgdepth == 1 & !ct32k_buffer[0] && osver >= 0xA5)
d2022 1
a2022 1
        /* Get the magic "table" from ColourTrans ( { '32K.', table_ptr, '32K. } ) */
d2033 1
d2043 2
a2044 1
            b += (width-1) * bgdepth;
d2063 1
a2063 12
                {
                    #ifdef DITHERING
                    error_red = error_green = error_blue = 0;
                    if (dir == 1)
                        b += bgdepth;
                    else
                        b -= bgdepth;
                    #else
                    b += bgdepth;
                    #endif
                    continue;
                }
d2083 1
a2083 10
                    #ifdef DITHERING
                    error_red = error_green = error_blue = 0;
                    if (dir == 1)
                        b += bgdepth;
                    else
                        b -= bgdepth;
                    #else
                    b += bgdepth;
                    #endif
                    continue;
d2103 1
d2106 28
a2133 1
                    if (dir == 1)
d2136 7
a2142 3
                        b -= bgdepth;
                    #else
                    b += bgdepth;
d2157 15
a2171 1
                    bg = bgpalette[*b * 2];
d2177 1
a2177 1
                  case 2:
d2186 1
a2186 1
                  case 4:
a2213 12
                #if defined(DITHERING) && defined(GAMMA_DITHER)
                bgblue += error_blue;
                bggreen += error_green;
                bgred += error_red;
                if (bgblue < 0) bgblue = 0; else if (bgblue > 255) bgblue = 255;
                if (bggreen < 0) bggreen = 0; else if (bggreen > 255) bggreen = 255;
                if (bgred < 0) bgred = 0; else if (bgred > 255) bgred = 255;
                truered = bgred;
                truegreen = bggreen;
                trueblue = bgblue;
                #endif

a2223 14
                #ifdef GAMMA_DITHER
                blue += error_blue;
                green += error_green;
                red += error_red;
                if (blue < 0) blue = 0; else if (blue > 255) blue = 255;
                if (green < 0) green = 0; else if (green > 255) green = 255;
                if (red < 0) red = 0; else if (red > 255) red = 255;
                truered = red;
                truegreen = green;
                trueblue = blue;
                bgblue  = screen_from_1[blue];
                bggreen = screen_from_1[green];
                bgred   = screen_from_1[red];
                #else
a2226 1
                #endif
d2229 1
a2229 1
            #if defined(DITHERING) && !defined(GAMMA_DITHER)
d2241 1
a2241 1
            if (bgdepth != 4)
d2249 48
a2296 2
              {
                int c = cttable[bg];
d2303 1
d2312 2
a2313 2
              }
              case 2:
d2327 1
a2327 1
              case 4:
a2340 5
            #ifdef GAMMA_DITHER
            error_red = truered - screen_to_1[result_red];
            error_green = truegreen - screen_to_1[result_green];
            error_blue = trueblue - screen_to_1[result_blue];
            #else
a2343 1
            #endif
@


1.14
log
@Stopped RISC OS 3.1 machines going pleueh and leaving the hourglass on
when confronted with 24/48 bit PNGs. Still doesn't handle 24/48 bit PNGs
with transparency (simple or alpha).
@
text
@d96 1
d136 28
d340 2
a341 2
    if (/*this->flags & IMAGE_FAST ||*/ osver < 0xA5)
        this->full_alpha = 0;
d451 4
a456 4
            /* Add a filler if alpha missing */
            if (info->color_type == PNG_COLOR_TYPE_RGB)
                png_set_filler(png_ptr, 0, PNG_FILLER_AFTER);

d461 1
a461 4
            /* If on an old OS, get it to spit out 8bpp data :-( */
            _swix(Hourglass_On, 0);
            hourglass_on = 1;
            if (png_get_valid(png_ptr, info, PNG_INFO_PLTE))
d463 3
a465 3
                png_uint_16p histogram = NULL;
                png_get_hIST(png_ptr, info, &histogram);
                png_set_dither(png_ptr, info->palette, info->num_palette, 256, histogram, 1);
d467 3
d471 1
a471 7
            {
                png_set_dither(png_ptr, riscospal, 256, 256, NULL, 1);
                useropal=1;
            }
            _swix(Hourglass_Off, 0);
            hourglass_on = 0;
            mode = 28;
d533 6
a538 1
        riscos_rowbytes = info->width * 4;
d549 1
a549 4
        if (useropal)
            num_palette = 256;
        else
            num_palette = info->num_palette;
d555 5
d601 11
a611 2
    e=_swix(OS_SpriteOp, _INR(0,6), 256+15, this->private_data2, "png", 0,
                                            this->width, this->height, mode);
a648 2
        else if (useropal)
            palette = riscospal;
d652 2
d714 2
d717 1
d723 9
a731 1

d743 1
a743 1
    if (info->valid & PNG_INFO_bKGD)
d768 2
d785 6
a790 3
    mask_row = (png_byte *) this->private_data2 +
                            load->mask_offset +
                            load->maskwidth * row_num;
d811 6
d848 1
a848 1
    else if (info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
d851 9
a859 1
            convert_32bit_alpha_to_mask(row, mask_row, info->width);
d1052 37
d1154 12
a1165 1
    return _swix(OS_SpriteOp, _INR(0,2), 256+12, this->private_data2, filename);
d1273 2
a1274 1
    ct32k_buffer[0] = 0;
d1322 1
d1354 3
a1413 4
  #if 0
    #define imagename "image"
  #endif
    /*char imagename[12];*/
a1493 5

        /*_swix(OS_WriteI + 4, 0);
        _swix(OS_WriteI + 30, 0);
        printf("width = %d, height = %d, xo = %d, yo = %d, clipoffset = %x                ", width, height, xo, yo, clipoffset);
        _swix(OS_WriteI + 5, 0);*/
a1497 55
  #if 0
    bgmem = 16 + 44;
    bgwidth = width * (1 << (log2bpp - 3));
    bgwidth = (bgwidth + 3) &~ 3;
    bgmem += bgwidth * height;
    if (log2bpp == 3) bgmem += 2*4*256;

    if (!flex_alloc((flex_ptr)&bgarea, bgmem + SprExtendBonus))
    /*bgarea = malloc(bgmem);
    if (!bgarea)*/
        return pngError("Can't get memory for background image.");

    oldbudge = flex_set_budge(0);
    oldcompact = flex_set_deferred_compaction(0);

    switch (log2bpp)
    {
        case 3: mode = 28;              break;
        case 4: mode = MODE(5, 90, 90); break;
        case 5: mode = MODE(6, 90, 90); break;
    }

    /*sprintf(imagename, "%x", imageno++);*/

    bgarea->size   = bgmem;
    bgarea->sproff = sizeof(sprite_area);
    e = _swix(OS_SpriteOp, _INR(0,1), 256+SprInitArea, bgarea);
    if (e) goto error1;
    e = _swix(OS_SpriteOp, _INR(0,6), 256+SprCreateSprite, bgarea, imagename,
                                      0, width, height,
                                      mode);
    if (e) goto error1;

    if (log2bpp == 3)
    {
        e = _swix(OS_SpriteOp, _INR(0,3), 256+SprAddPalette, bgarea, imagename, (1U<<31)+1);
        if (e) goto error1;
        e = _swix(OS_SpriteOp, _INR(0,3)|_OUT(4), 256+SprAddPalette, bgarea, imagename, -1, &palette);
        if (e) goto error1;
        e = _swix(ColourTrans_ReadPalette, _INR(0,4), -1, -1, palette, 256*4*2, 2);
        if (e) goto error1;
    }

    e =_swix(OS_SpriteOp, _INR(0,2)|_OUT(3), 256+SprSaveAreaSize, bgarea, imagename, &savesize);
    if (e) goto error1;

    savearea = calloc(savesize, 1);

    e = _swix(OS_SpriteOp, _INR(0,3)|_OUTR(0,3), 256+SprSwitchVdu, bgarea, imagename, savearea,
                                                 &oldsw0, &oldsw1, &oldsw2, &oldsw3);
    if (e) goto error2;

    bgptr = (char *) (bgarea + 1) + ((sprite_header *)(bgarea + 1))->image;
    bgpal = (int *) ((char *) bgarea + 16 + 44)
  #else
a1522 1
  #endif
d1535 1
a1535 3
    #ifdef RANDOM_BG
    e = _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), rand() << 8, 0x180, 0);
    if (e) goto error2;
d1537 1
a1537 1
    e = _swix(OS_WriteI + 16, 0); /* CLG */
a1538 1
    #else
d1540 6
a1545 2
    if (!e) e = load->filler(load->filler_handle1, load->filler_handle2);
    #endif
d1547 1
a1547 7
  #if 0
    _swix(OS_SpriteOp, _INR(0,3), oldsw0, oldsw1, oldsw2, oldsw3);
  #else
    e = SwitchFromBufferSprite();
  #endif

    if (e) goto error2;
d1560 2
a1605 3
  #if 0
    free(savearea);
  #endif
a1606 6
  #if 0
    flex_set_budge(oldbudge);
    flex_set_deferred_compaction(oldcompact);

    flex_free((flex_ptr) &bgarea);
  #else
a1607 1
  #endif
d1818 1
a1818 1
    if (bgdepth == 1 & !ct32k_buffer[0])
@


1.13
log
@Fixed silly memory corruption in background PNG code.
Made reload of background PNG after mode change work first time.
Oh, and the last checkin fixed a bug in transparent background image
processing that caused a maths overflow when working out the background
colour.
@
text
@d225 2
d244 5
d253 1
a253 1
    oldbudge = flex_set_budge(0);
d434 1
d447 1
@


1.12
log
@Rendering in filler functions in non-EX1 EY1 modes should now work.
PNG background images with alpha now handled properly.
@
text
@d309 1
a309 1
        if (!log2bpp) ModeChange(NULL);
a1583 1
    void *colbuf;
a1628 8
    #if 0
    if (flex_midextend((flex_ptr) &this->private_data2, 0, size) == 0)
        return NULL;

    sphead=(int *)((char *)sphead + size);
    this->private_data2[0]=size;
    this->private_data2[2]=16;
    #else
a1634 1
    #endif
a1635 3
    #if 0
    _swix(OS_SpriteOp, _INR(0,1), 256+9, this->private_data2);
    #else
d1637 1
a1637 1
    #endif
a1638 4
    #if 0
    e=_swix(OS_SpriteOp, _INR(0,6), 256+15, this->private_data2, "sprite",
                                    0, nw, nh, mode);
    #else
d1641 1
a1641 1
    #endif
a1645 3
        #if 0
        e=_swix(OS_SpriteOp, _INR(0,3), 0x125, this->private_data2, "sprite", (1U<<31)+1);
        #else
a1646 1
        #endif
a1647 3
            #if 0
            e=_swix(OS_SpriteOp, _INR(0,3)|_OUT(4), 0x125, this->private_data2, "sprite", -1, &palette);
            #else
a1648 1
            #endif
a1653 22
        #if 0
        flex_midextend((flex_ptr) &this->private_data2, size, -size);
        #else
        free(newarea);
        #endif
        return NULL;
    }
#if 0
#define ORIG ((int *)((char *)this->private_data2+size))
#else
#define ORIG (this->private_data2)
#endif

    _swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4),
                                     ORIG, sphead, -1, -1, 0, 1, &bufsiz);

    colbuf = malloc(bufsiz);
    if (!colbuf)
    {
        #if 0
        flex_midextend((flex_ptr) &this->private_data2, size, -size);
        #else
a1654 1
        #endif
a1657 2
    _swix(ColourTrans_GenerateTable, _INR(0,5), ORIG, sphead, -1, -1, colbuf, 1);

a1658 4
    #if 0
    e=_swix(OS_SpriteOp, _INR(0,3)|_OUTR(1,3), 0x13C, this->private_data2, "sprite", 0,
                                               &r1, &r2, &r3);
    #else
a1660 1
    #endif
a1662 3
        #if 0
        flex_midextend((flex_ptr) &this->private_data2, size, -size);
        #else
a1663 1
        #endif
d1678 1
a1679 2
    /* Plot sprite */
    /*_swix(OS_SpriteOp, _INR(0,7), 512+52, ORIG, sphead, 0, 0, 8+16, fac, colbuf);*/
d1684 1
a1684 1
    free(colbuf);
a1685 3
    #if 0
    flex_midextend((flex_ptr) &this->private_data2, size+ORIG[0], -ORIG[0]);
    #else
a1692 1
    #endif
d1696 5
a1700 1
        free(this->private_data);
a1703 2
    BGCol(this->private_data2, bgcol);

d1706 1
a1706 1
    /*this->ModeChange=ModeChangeSprite;*/
d1717 2
@


1.11
log
@Corrected OS version check for deep PNGs
@
text
@d86 1
a86 1
static _kernel_oserror *BGColPNG(Image *this, int *bgcol);
d95 2
a272 1
    int background;
d304 1
a304 1
    if (this->flags & IMAGE_FAST || osver < 0xA5)
d684 15
a698 10
    /* Clear the background */
    background = ((info->background.blue>>(info->bit_depth-8))<<24) |
                 ((info->background.green>>(info->bit_depth-8))<<16) |
                 ((info->background.red>>(info->bit_depth-8))<<8);

    _swix(OS_SpriteOp, _INR(0,3)|_OUTR(1,3), 256+60, this->private_data2, "png", 0,
    	    	    	    	    	     &r1, &r2, &r3);
    _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), background, 128, 0);
    _swix(OS_WriteI + 16, 0);
    _swix(OS_SpriteOp, _INR(0,3), 256+60, r1, r2, r3);
d1280 2
d1283 1
d1285 1
d1312 5
d1376 1
d1428 30
d1480 1
d1482 3
d1494 1
a1494 1
                (char *) (bgarea + 1) + ((sprite_header *)(bgarea + 1))->image,
d1496 1
a1496 1
                (int *) ((char *) bgarea + 16 + 44),
d1525 1
a1525 2
        e=_swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4), bgarea, imagename, -1, -1,
                                           0, 0, &bufsize);
d1535 1
a1535 2
        e=_swix(ColourTrans_GenerateTable, _INR(0,5), bgarea, imagename, -1, -1,
                                           table, 0);
d1539 1
a1539 8
    e=_swix(OS_SpriteOp, _INR(0,7), 256+PutSpriteScaled,
                                    bgarea,
                                    imagename,
                                    x - xo, y - yo,
                                    osver >= 0xa5 ? PutSpriteScaled_UsePalette
                                                  : 0,
                                    fac,
                                    table);
d1543 1
d1545 1
d1547 1
d1552 3
d1566 11
a1576 1
static _kernel_oserror *BGColPNG(Image *this, int *bgcol)
d1589 2
d1592 2
a1593 3
    e=BGCol(this->private_data2, bgcol);
    if (e)
        return e;
d1595 2
a1596 2
    if (!(this->flags & IMAGE_FAST))
        return NULL;
d1630 1
d1637 8
d1646 5
a1650 1
    _swix(OS_SpriteOp, _INR(0,1), 0x109, this->private_data2);
d1652 2
a1653 1
    e=_swix(OS_SpriteOp, _INR(0,6), 0x10f, this->private_data2, "sprite",
d1655 4
d1663 1
d1665 3
d1669 1
d1671 3
d1679 1
d1681 3
d1686 1
d1688 3
d1698 1
d1700 3
d1709 1
d1712 4
d1718 1
d1720 3
d1726 4
d1731 1
a1731 1
    _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), *bgcol, 128, 0);
d1735 3
d1739 1
a1739 1
    _swix(OS_SpriteOp, _INR(0,7), 512+52, ORIG, sphead, 0, 0, 8+16, fac, colbuf);
d1746 1
d1748 9
d1764 2
d1768 1
a1768 1
    this->ModeChange=ModeChangeSprite;
@


1.10
log
@Stripped down lzw_[de]comp into a lean, mean compressing machine.
Converted it to 11-bit LZW to save memory in compression tables.
Fixed lots of redraw errors in the GIF code.
Stopped PNG code attempting to do alpha processing on RISC OS 3.1 (we
don't have a ColourTrans to supply the inverse table).
@
text
@d414 1
a414 1
        if (this->full_alpha)
@


1.9
log
@Made png.c alloc a bit more to avoid SpriteExtend bug
@
text
@d21 1
d303 1
a303 1
    if (this->flags & IMAGE_FAST)
d414 1
a414 1
        if (osver >= 0xA5 || this->full_alpha)
@


1.8
log
@Made PNGs put palette on background PNGs so colour determination works.
@
text
@d547 1
a547 1
    if (!flex_alloc((flex_ptr)&this->private_data2, mem))
d1050 1
a1050 1
        if (!flex_alloc((flex_ptr)&this->private_data2, length+4))
d1366 1
a1366 1
    if (!flex_alloc((flex_ptr)&bgarea, bgmem))
@


1.7
log
@Implemented background colour determination for JPEGs and GIFs.
Made basic BGCol routine work on 16 and 32 bpp sprites.
@
text
@d1530 1
a1530 1
    int nw, nh;
d1549 1
d1567 3
d1582 10
@


1.6
log
@Made RGB PNGs work on RISC OS 3.1 (but slowly!)
Added dithering to PNGs with alpha.
Made ModeChange delay action until image is next rendered.
@
text
@a104 1
    int log2bpp;
d1394 3
a1396 1
        e = _swix(OS_SpriteOp, _INR(0,3), 256+SprAddPalette, bgarea, imagename, 1U<<31);
a1397 1
        palette = (int *) ((char *) bgarea + 16 + 44);
d1529 1
a1529 1
    PNGloaddata *load;
d1532 1
a1532 1
    e=BGCol(this->private_data2, 3, bgcol);
a1620 1
    load=(PNGloaddata *) this->private_data;
@


1.5
log
@PNG alpha support added, with some hackery to pnglib.
JPEGs told not to render if < 8 pixels wide.
@
text
@d53 3
d178 1
a178 1
    im->ModeChange=ModeChange;
d277 1
a277 1
    int num_trans = 0;
d414 1
a414 1
        if (osver >= 0xA5)
a417 1
            {
a418 1
            }
d425 13
a437 1
            png_set_dither(png_ptr, riscospal, 256, 256, NULL, 0);
d511 4
a514 1
        num_palette = info->num_palette;
d541 3
d600 2
d624 5
d632 1
d701 1
a701 1
static void convert_palette_trns_to_mask(const png_bytep row, png_bytep mask_row, png_uint_32 width, int depth, png_bytep trans, int num_trans, const png_color_16 *trans_values, int color_type);
d777 1
a777 1
    else if (info->color_type == PNG_COLOR_TYPE_PALETTE && info->valid & PNG_INFO_tRNS)
d780 1
a780 1
            convert_palette_trns_to_mask(row, mask_row, info->width, info->bit_depth, info->trans, info->num_trans, &info->trans_values, info->color_type);
d807 1
a807 1
static void convert_palette_trns_to_mask(const png_bytep row, png_bytep mask_row, png_uint_32 width, int depth, png_bytep trans, int num_trans, const png_color_16 *trans_values, int color_type)
a848 1
    #if 0
a850 1
    #endif
a872 1
    #if 0
a931 1
    #endif
d1205 1
a1205 1
    if (!this->factors[0])
d1209 1
d1296 2
a1297 2
            if (width << var.xeig != x_size ||
                height << var.yeig != y_size)
d1680 6
d1703 14
d1722 4
d1727 1
d1731 7
d1739 1
d1748 4
d1753 1
d1756 3
d1760 8
d1769 1
d1772 4
d1777 1
d1782 3
d1786 1
d1790 7
d1798 1
d1851 15
a1865 3
                blend(bgblue,  bg_alpha, blue/*,  alpha*/);
                blend(bggreen, bg_alpha, green/*, alpha*/);
                blend(bgred,   bg_alpha, red/*,   alpha*/);
d1877 14
d1894 1
d1897 12
d1917 15
a1931 1
                *b++ = cttable[bg];
d1933 1
d1936 9
d1946 1
d1950 6
d1957 2
a1958 1
                break;
d1961 12
d1974 2
@


1.4
log
@Problems with DumpSprite for IMAGE_FAST images corrected.
@
text
@d36 2
d51 2
d71 2
d83 1
d101 8
d183 1
a183 1
    im->RegisterFiller=0;
d243 6
d273 26
d300 92
a394 1
    {
a395 1
    }
d398 9
a406 1
        png_set_packswap(png_ptr);
d443 1
a443 2
        if (info->bit_depth == 16 || info->color_type == PNG_COLOR_TYPE_RGB ||
                                     info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
d447 7
a453 2
    if (info->valid & PNG_INFO_gAMA)
        png_set_gamma(png_ptr, 2.5, info->gamma);
d455 5
a459 1
    	png_set_gamma(png_ptr, 2.5, 0.45);
d468 3
a470 3
     *            1 bpp paletted/greyscale
     *            2 bpp paletted/greyscale
     *            4 bpp paletted/greyscale
d478 1
a478 1
    
d513 3
a515 1
    if ((info->color_type & PNG_COLOR_MASK_ALPHA) || (info->valid & PNG_INFO_tRNS))
d518 1
a518 1
          load->maskwidth = (load->spritewidth / 32 + 3) &~ 3;
d578 2
d584 3
a586 1
        for (i = 0; i < pal_entries; i++)
d588 41
a628 5
            c = (palette[i].blue << 24) |
                (palette[i].green << 16) |
                (palette[i].red << 8);
            this->private_data2[15 + i * 2] =
            this->private_data2[15 + i * 2 + 1] = c;
d654 2
d674 2
a675 2
static void process_transparency(const png_bytep row, png_bytep mask_row, png_uint_32 width, int depth, png_bytep trans, int num_trans, const png_color_16 *trans_values, int color_type);
static void process_alpha(const png_bytep row, png_bytep mask_row, png_uint_32 width);
d702 3
a704 3
        sp = row + (info->width - 1);
        mp = mask_row + (info->width - 1);
        dp = load->temp + (info->width - 1) * 2;
d707 2
a708 4
            *dp = *sp;
            *(dp + 1) = *mp;
            dp-=2;
            sp--; mp--;
d725 12
a736 4
        sp = load->temp + (info->width - 1) * 2;
        mp = mask_row + (info->width - 1);
        dp = row + (info->width - 1);
        for (i = info->width; i; i--)
d738 5
a742 4
            *dp = *sp;
            *mp = *(sp + 1) ? 255 : 0;
            sp-=2;
            dp--; mp--;
d746 9
a754 3
        process_alpha(row, mask_row, info->width);
    else if (info->valid & PNG_INFO_tRNS)
        process_transparency(row, mask_row, info->width, info->bit_depth, info->trans, info->num_trans, &info->trans_values, info->color_type);
d780 1
a780 1
static void process_transparency(const png_bytep row, png_bytep mask_row, png_uint_32 width, int depth, png_bytep trans, int num_trans, const png_color_16 *trans_values, int color_type)
d822 1
d825 1
d848 1
d908 1
d911 4
a914 1
static void process_alpha(const png_bytep row, png_bytep mask_row, png_uint_32 width)
d945 60
d1076 2
a1077 2
    free(this->private_data);
    this->private_data=NULL;
d1097 1
a1097 1
        if (load->png_ptr);
d1100 2
d1118 2
d1121 1
d1125 3
d1161 2
d1183 1
d1185 10
d1200 9
a1208 9
      int xos, yos;
      
      xos = 1 << _swi(OS_ReadModeVariable,_IN(0)|_IN(1)|_RETURN(2),-1,4);
      yos = 1 << _swi(OS_ReadModeVariable,_IN(0)|_IN(1)|_RETURN(2),-1,5);

      fac[0]=x_size;
      fac[1]=y_size;
      fac[2]=this->width*xos;
      fac[3]=this->height*yos;
d1210 1
a1210 1
    else if (scale!=100)
d1232 255
d1627 176
@


1.3
log
@Fixed problem with BBox returned by EndLoad for non GIF and JPEG images
@
text
@d1051 1
@


1.2
log
@EndLoad now returns a BBox; Corrected flex problems on 3.1 machines; Corrected 16 colour mode bug.
@
text
@d792 1
a792 1
    changed=NULL;
@


1.1
log
@First commit to CVS
@
text
@d69 1
a69 1
static _kernel_oserror *EndLoad(Image *this);
d784 1
a784 1
static _kernel_oserror *EndLoad(Image *this)
d791 2
@

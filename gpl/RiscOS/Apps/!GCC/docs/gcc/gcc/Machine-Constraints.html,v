head	1.1;
branch	1.1.1;
access;
symbols
	GCC-4_7_4_r3:1.1.1.2
	GCC-4_1_2_r2:1.1.1.1
	MAIN:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2013.07.29.22.46.16;	author jlee;	state Exp;
branches
	1.1.1.1;
next	;
commitid	Uxh7I3IiWVY2YpZw;

1.1.1.1
date	2013.07.29.22.46.16;	author jlee;	state Exp;
branches;
next	1.1.1.2;
commitid	Uxh7I3IiWVY2YpZw;

1.1.1.2
date	2017.04.15.15.12.21;	author jlee;	state Exp;
branches;
next	;
commitid	Kx60weqAWGeJSDNz;


desc
@@


1.1
log
@Initial revision
@
text
@<html lang="en">
<head>
<title>Machine Constraints - Using the GNU Compiler Collection (GCC)</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Using the GNU Compiler Collection (GCC)">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Constraints.html#Constraints" title="Constraints">
<link rel="prev" href="Modifiers.html#Modifiers" title="Modifiers">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Funding
Free Software'', the Front-Cover texts being (a) (see below), and with
the Back-Cover Texts being (b) (see below).  A copy of the license is
included in the section entitled ``GNU Free Documentation License''.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Machine-Constraints"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="Modifiers.html#Modifiers">Modifiers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Constraints.html#Constraints">Constraints</a>
<hr>
</div>

<h4 class="subsection">5.35.4 Constraints for Particular Machines</h4>

<p><a name="index-machine-specific-constraints-1945"></a><a name="index-constraints_002c-machine-specific-1946"></a>
Whenever possible, you should use the general-purpose constraint letters
in <code>asm</code> arguments, since they will convey meaning more readily to
people reading your code.  Failing that, use the constraint letters
that usually have very similar meanings across architectures.  The most
commonly used constraints are &lsquo;<samp><span class="samp">m</span></samp>&rsquo; and &lsquo;<samp><span class="samp">r</span></samp>&rsquo; (for memory and
general-purpose registers respectively; see <a href="Simple-Constraints.html#Simple-Constraints">Simple Constraints</a>), and
&lsquo;<samp><span class="samp">I</span></samp>&rsquo;, usually the letter indicating the most common
immediate-constant format.

 <p>For each machine architecture, the
<samp><span class="file">config/</span><var>machine</var><span class="file">/</span><var>machine</var><span class="file">.h</span></samp> file defines additional
constraints.  These constraints are used by the compiler itself for
instruction generation, as well as for <code>asm</code> statements; therefore,
some of the constraints are not particularly interesting for <code>asm</code>. 
The constraints are defined through these macros:

     <dl>
<dt><code>REG_CLASS_FROM_LETTER</code><dd>Register class constraints (usually lowercase).

     <br><dt><code>CONST_OK_FOR_LETTER_P</code><dd>Immediate constant constraints, for non-floating point constants of
word size or smaller precision (usually uppercase).

     <br><dt><code>CONST_DOUBLE_OK_FOR_LETTER_P</code><dd>Immediate constant constraints, for all floating point constants and for
constants of greater than word size precision (usually uppercase).

     <br><dt><code>EXTRA_CONSTRAINT</code><dd>Special cases of registers or memory.  This macro is not required, and
is only defined for some machines. 
</dl>

 <p>Inspecting these macro definitions in the compiler source for your
machine is the best way to be certain you have the right constraints. 
However, here is a summary of the machine-dependent constraints
available on some particular machines.

     <dl>
<dt><em>ARM family&mdash;</em><samp><span class="file">arm.h</span></samp><dd>
          <dl>
<dt><code>f</code><dd>Floating-point register

          <br><dt><code>w</code><dd>VFP floating-point register

          <br><dt><code>F</code><dd>One of the floating-point constants 0.0, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0
or 10.0

          <br><dt><code>G</code><dd>Floating-point constant that would satisfy the constraint &lsquo;<samp><span class="samp">F</span></samp>&rsquo; if it
were negated

          <br><dt><code>I</code><dd>Integer that is valid as an immediate operand in a data processing
instruction.  That is, an integer in the range 0 to 255 rotated by a
multiple of 2

          <br><dt><code>J</code><dd>Integer in the range &minus;4095 to 4095

          <br><dt><code>K</code><dd>Integer that satisfies constraint &lsquo;<samp><span class="samp">I</span></samp>&rsquo; when inverted (ones complement)

          <br><dt><code>L</code><dd>Integer that satisfies constraint &lsquo;<samp><span class="samp">I</span></samp>&rsquo; when negated (twos complement)

          <br><dt><code>M</code><dd>Integer in the range 0 to 32

          <br><dt><code>Q</code><dd>A memory reference where the exact address is in a single register
(`&lsquo;<samp><span class="samp">m</span></samp>&rsquo;' is preferable for <code>asm</code> statements)

          <br><dt><code>R</code><dd>An item in the constant pool

          <br><dt><code>S</code><dd>A symbol in the text segment of the current file

          <br><dt><code>Uv</code><dd>A memory reference suitable for VFP load/store insns (reg+constant offset)

          <br><dt><code>Uy</code><dd>A memory reference suitable for iWMMXt load/store instructions.

          <br><dt><code>Uq</code><dd>A memory reference suitable for the ARMv4 ldrsb instruction. 
</dl>

     <br><dt><em>AVR family&mdash;</em><samp><span class="file">avr.h</span></samp><dd>
          <dl>
<dt><code>l</code><dd>Registers from r0 to r15

          <br><dt><code>a</code><dd>Registers from r16 to r23

          <br><dt><code>d</code><dd>Registers from r16 to r31

          <br><dt><code>w</code><dd>Registers from r24 to r31.  These registers can be used in &lsquo;<samp><span class="samp">adiw</span></samp>&rsquo; command

          <br><dt><code>e</code><dd>Pointer register (r26&ndash;r31)

          <br><dt><code>b</code><dd>Base pointer register (r28&ndash;r31)

          <br><dt><code>q</code><dd>Stack pointer register (SPH:SPL)

          <br><dt><code>t</code><dd>Temporary register r0

          <br><dt><code>x</code><dd>Register pair X (r27:r26)

          <br><dt><code>y</code><dd>Register pair Y (r29:r28)

          <br><dt><code>z</code><dd>Register pair Z (r31:r30)

          <br><dt><code>I</code><dd>Constant greater than &minus;1, less than 64

          <br><dt><code>J</code><dd>Constant greater than &minus;64, less than 1

          <br><dt><code>K</code><dd>Constant integer 2

          <br><dt><code>L</code><dd>Constant integer 0

          <br><dt><code>M</code><dd>Constant that fits in 8 bits

          <br><dt><code>N</code><dd>Constant integer &minus;1

          <br><dt><code>O</code><dd>Constant integer 8, 16, or 24

          <br><dt><code>P</code><dd>Constant integer 1

          <br><dt><code>G</code><dd>A floating point constant 0.0
</dl>

     <br><dt><em>CRX Architecture&mdash;</em><samp><span class="file">crx.h</span></samp><dd>
          <dl>
<dt><code>b</code><dd>Registers from r0 to r14 (registers without stack pointer)

          <br><dt><code>l</code><dd>Register r16 (64-bit accumulator lo register)

          <br><dt><code>h</code><dd>Register r17 (64-bit accumulator hi register)

          <br><dt><code>k</code><dd>Register pair r16-r17. (64-bit accumulator lo-hi pair)

          <br><dt><code>I</code><dd>Constant that fits in 3 bits

          <br><dt><code>J</code><dd>Constant that fits in 4 bits

          <br><dt><code>K</code><dd>Constant that fits in 5 bits

          <br><dt><code>L</code><dd>Constant that is one of -1, 4, -4, 7, 8, 12, 16, 20, 32, 48

          <br><dt><code>G</code><dd>Floating point constant that is legal for store immediate
</dl>

     <br><dt><em>PowerPC and IBM RS6000&mdash;</em><samp><span class="file">rs6000.h</span></samp><dd>
          <dl>
<dt><code>b</code><dd>Address base register

          <br><dt><code>f</code><dd>Floating point register

          <br><dt><code>v</code><dd>Vector register

          <br><dt><code>h</code><dd>&lsquo;<samp><span class="samp">MQ</span></samp>&rsquo;, &lsquo;<samp><span class="samp">CTR</span></samp>&rsquo;, or &lsquo;<samp><span class="samp">LINK</span></samp>&rsquo; register

          <br><dt><code>q</code><dd>&lsquo;<samp><span class="samp">MQ</span></samp>&rsquo; register

          <br><dt><code>c</code><dd>&lsquo;<samp><span class="samp">CTR</span></samp>&rsquo; register

          <br><dt><code>l</code><dd>&lsquo;<samp><span class="samp">LINK</span></samp>&rsquo; register

          <br><dt><code>x</code><dd>&lsquo;<samp><span class="samp">CR</span></samp>&rsquo; register (condition register) number 0

          <br><dt><code>y</code><dd>&lsquo;<samp><span class="samp">CR</span></samp>&rsquo; register (condition register)

          <br><dt><code>z</code><dd>&lsquo;<samp><span class="samp">FPMEM</span></samp>&rsquo; stack memory for FPR-GPR transfers

          <br><dt><code>I</code><dd>Signed 16-bit constant

          <br><dt><code>J</code><dd>Unsigned 16-bit constant shifted left 16 bits (use &lsquo;<samp><span class="samp">L</span></samp>&rsquo; instead for
<code>SImode</code> constants)

          <br><dt><code>K</code><dd>Unsigned 16-bit constant

          <br><dt><code>L</code><dd>Signed 16-bit constant shifted left 16 bits

          <br><dt><code>M</code><dd>Constant larger than 31

          <br><dt><code>N</code><dd>Exact power of 2

          <br><dt><code>O</code><dd>Zero

          <br><dt><code>P</code><dd>Constant whose negation is a signed 16-bit constant

          <br><dt><code>G</code><dd>Floating point constant that can be loaded into a register with one
instruction per word

          <br><dt><code>Q</code><dd>Memory operand that is an offset from a register (&lsquo;<samp><span class="samp">m</span></samp>&rsquo; is preferable
for <code>asm</code> statements)

          <br><dt><code>R</code><dd>AIX TOC entry

          <br><dt><code>S</code><dd>Constant suitable as a 64-bit mask operand

          <br><dt><code>T</code><dd>Constant suitable as a 32-bit mask operand

          <br><dt><code>U</code><dd>System V Release 4 small data area reference
</dl>

     <br><dt><em>MorphoTech family&mdash;</em><samp><span class="file">mt.h</span></samp><dd>
          <dl>
<dt><code>I</code><dd>Constant for an arithmetic insn (16-bit signed integer).

          <br><dt><code>J</code><dd>The constant 0.

          <br><dt><code>K</code><dd>Constant for a logical insn (16-bit zero-extended integer).

          <br><dt><code>L</code><dd>A constant that can be loaded with <code>lui</code> (i.e. the bottom 16
bits are zero).

          <br><dt><code>M</code><dd>A constant that takes two words to load (i.e. not matched by
<code>I</code>, <code>K</code>, or <code>L</code>).

          <br><dt><code>N</code><dd>Negative 16-bit constants other than -65536.

          <br><dt><code>O</code><dd>A 15-bit signed integer constant.

          <br><dt><code>P</code><dd>A positive 16-bit constant. 
</dl>

     <br><dt><em>Intel 386&mdash;</em><samp><span class="file">i386.h</span></samp><dd>
          <dl>
<dt><code>q</code><dd>&lsquo;<samp><span class="samp">a</span></samp>&rsquo;, <code>b</code>, <code>c</code>, or <code>d</code> register for the i386. 
For x86-64 it is equivalent to &lsquo;<samp><span class="samp">r</span></samp>&rsquo; class (for 8-bit instructions that
do not use upper halves).

          <br><dt><code>Q</code><dd>&lsquo;<samp><span class="samp">a</span></samp>&rsquo;, <code>b</code>, <code>c</code>, or <code>d</code> register (for 8-bit instructions,
that do use upper halves).

          <br><dt><code>R</code><dd>Legacy register&mdash;equivalent to <code>r</code> class in i386 mode. 
(for non-8-bit registers used together with 8-bit upper halves in a single
instruction)

          <br><dt><code>A</code><dd>Specifies the &lsquo;<samp><span class="samp">a</span></samp>&rsquo; or &lsquo;<samp><span class="samp">d</span></samp>&rsquo; registers.  This is primarily useful
for 64-bit integer values (when in 32-bit mode) intended to be returned
with the &lsquo;<samp><span class="samp">d</span></samp>&rsquo; register holding the most significant bits and the
&lsquo;<samp><span class="samp">a</span></samp>&rsquo; register holding the least significant bits.

          <br><dt><code>f</code><dd>Floating point register

          <br><dt><code>t</code><dd>First (top of stack) floating point register

          <br><dt><code>u</code><dd>Second floating point register

          <br><dt><code>a</code><dd>&lsquo;<samp><span class="samp">a</span></samp>&rsquo; register

          <br><dt><code>b</code><dd>&lsquo;<samp><span class="samp">b</span></samp>&rsquo; register

          <br><dt><code>c</code><dd>&lsquo;<samp><span class="samp">c</span></samp>&rsquo; register

          <br><dt><code>C</code><dd>Specifies constant that can be easily constructed in SSE register without
loading it from memory.

          <br><dt><code>d</code><dd>&lsquo;<samp><span class="samp">d</span></samp>&rsquo; register

          <br><dt><code>D</code><dd>&lsquo;<samp><span class="samp">di</span></samp>&rsquo; register

          <br><dt><code>S</code><dd>&lsquo;<samp><span class="samp">si</span></samp>&rsquo; register

          <br><dt><code>x</code><dd>&lsquo;<samp><span class="samp">xmm</span></samp>&rsquo; SSE register

          <br><dt><code>y</code><dd>MMX register

          <br><dt><code>I</code><dd>Constant in range 0 to 31 (for 32-bit shifts)

          <br><dt><code>J</code><dd>Constant in range 0 to 63 (for 64-bit shifts)

          <br><dt><code>K</code><dd>&lsquo;<samp><span class="samp">0xff</span></samp>&rsquo;

          <br><dt><code>L</code><dd>&lsquo;<samp><span class="samp">0xffff</span></samp>&rsquo;

          <br><dt><code>M</code><dd>0, 1, 2, or 3 (shifts for <code>lea</code> instruction)

          <br><dt><code>N</code><dd>Constant in range 0 to 255 (for <code>out</code> instruction)

          <br><dt><code>Z</code><dd>Constant in range 0 to <code>0xffffffff</code> or symbolic reference known to fit specified range. 
(for using immediates in zero extending 32-bit to 64-bit x86-64 instructions)

          <br><dt><code>e</code><dd>Constant in range &minus;2147483648 to 2147483647 or symbolic reference known to fit specified range. 
(for using immediates in 64-bit x86-64 instructions)

          <br><dt><code>G</code><dd>Standard 80387 floating point constant
</dl>

     <br><dt><em>Intel IA-64&mdash;</em><samp><span class="file">ia64.h</span></samp><dd>
          <dl>
<dt><code>a</code><dd>General register <code>r0</code> to <code>r3</code> for <code>addl</code> instruction

          <br><dt><code>b</code><dd>Branch register

          <br><dt><code>c</code><dd>Predicate register (&lsquo;<samp><span class="samp">c</span></samp>&rsquo; as in &ldquo;conditional&rdquo;)

          <br><dt><code>d</code><dd>Application register residing in M-unit

          <br><dt><code>e</code><dd>Application register residing in I-unit

          <br><dt><code>f</code><dd>Floating-point register

          <br><dt><code>m</code><dd>Memory operand. 
Remember that &lsquo;<samp><span class="samp">m</span></samp>&rsquo; allows postincrement and postdecrement which
require printing with &lsquo;<samp><span class="samp">%Pn</span></samp>&rsquo; on IA-64. 
Use &lsquo;<samp><span class="samp">S</span></samp>&rsquo; to disallow postincrement and postdecrement.

          <br><dt><code>G</code><dd>Floating-point constant 0.0 or 1.0

          <br><dt><code>I</code><dd>14-bit signed integer constant

          <br><dt><code>J</code><dd>22-bit signed integer constant

          <br><dt><code>K</code><dd>8-bit signed integer constant for logical instructions

          <br><dt><code>L</code><dd>8-bit adjusted signed integer constant for compare pseudo-ops

          <br><dt><code>M</code><dd>6-bit unsigned integer constant for shift counts

          <br><dt><code>N</code><dd>9-bit signed integer constant for load and store postincrements

          <br><dt><code>O</code><dd>The constant zero

          <br><dt><code>P</code><dd>0 or &minus;1 for <code>dep</code> instruction

          <br><dt><code>Q</code><dd>Non-volatile memory for floating-point loads and stores

          <br><dt><code>R</code><dd>Integer constant in the range 1 to 4 for <code>shladd</code> instruction

          <br><dt><code>S</code><dd>Memory operand except postincrement and postdecrement
</dl>

     <br><dt><em>FRV&mdash;</em><samp><span class="file">frv.h</span></samp><dd>
          <dl>
<dt><code>a</code><dd>Register in the class <code>ACC_REGS</code> (<code>acc0</code> to <code>acc7</code>).

          <br><dt><code>b</code><dd>Register in the class <code>EVEN_ACC_REGS</code> (<code>acc0</code> to <code>acc7</code>).

          <br><dt><code>c</code><dd>Register in the class <code>CC_REGS</code> (<code>fcc0</code> to <code>fcc3</code> and
<code>icc0</code> to <code>icc3</code>).

          <br><dt><code>d</code><dd>Register in the class <code>GPR_REGS</code> (<code>gr0</code> to <code>gr63</code>).

          <br><dt><code>e</code><dd>Register in the class <code>EVEN_REGS</code> (<code>gr0</code> to <code>gr63</code>). 
Odd registers are excluded not in the class but through the use of a machine
mode larger than 4 bytes.

          <br><dt><code>f</code><dd>Register in the class <code>FPR_REGS</code> (<code>fr0</code> to <code>fr63</code>).

          <br><dt><code>h</code><dd>Register in the class <code>FEVEN_REGS</code> (<code>fr0</code> to <code>fr63</code>). 
Odd registers are excluded not in the class but through the use of a machine
mode larger than 4 bytes.

          <br><dt><code>l</code><dd>Register in the class <code>LR_REG</code> (the <code>lr</code> register).

          <br><dt><code>q</code><dd>Register in the class <code>QUAD_REGS</code> (<code>gr2</code> to <code>gr63</code>). 
Register numbers not divisible by 4 are excluded not in the class but through
the use of a machine mode larger than 8 bytes.

          <br><dt><code>t</code><dd>Register in the class <code>ICC_REGS</code> (<code>icc0</code> to <code>icc3</code>).

          <br><dt><code>u</code><dd>Register in the class <code>FCC_REGS</code> (<code>fcc0</code> to <code>fcc3</code>).

          <br><dt><code>v</code><dd>Register in the class <code>ICR_REGS</code> (<code>cc4</code> to <code>cc7</code>).

          <br><dt><code>w</code><dd>Register in the class <code>FCR_REGS</code> (<code>cc0</code> to <code>cc3</code>).

          <br><dt><code>x</code><dd>Register in the class <code>QUAD_FPR_REGS</code> (<code>fr0</code> to <code>fr63</code>). 
Register numbers not divisible by 4 are excluded not in the class but through
the use of a machine mode larger than 8 bytes.

          <br><dt><code>z</code><dd>Register in the class <code>SPR_REGS</code> (<code>lcr</code> and <code>lr</code>).

          <br><dt><code>A</code><dd>Register in the class <code>QUAD_ACC_REGS</code> (<code>acc0</code> to <code>acc7</code>).

          <br><dt><code>B</code><dd>Register in the class <code>ACCG_REGS</code> (<code>accg0</code> to <code>accg7</code>).

          <br><dt><code>C</code><dd>Register in the class <code>CR_REGS</code> (<code>cc0</code> to <code>cc7</code>).

          <br><dt><code>G</code><dd>Floating point constant zero

          <br><dt><code>I</code><dd>6-bit signed integer constant

          <br><dt><code>J</code><dd>10-bit signed integer constant

          <br><dt><code>L</code><dd>16-bit signed integer constant

          <br><dt><code>M</code><dd>16-bit unsigned integer constant

          <br><dt><code>N</code><dd>12-bit signed integer constant that is negative&mdash;i.e. in the
range of &minus;2048 to &minus;1

          <br><dt><code>O</code><dd>Constant zero

          <br><dt><code>P</code><dd>12-bit signed integer constant that is greater than zero&mdash;i.e. in the
range of 1 to 2047.

     </dl>

     <br><dt><em>Blackfin family&mdash;</em><samp><span class="file">bfin.h</span></samp><dd>
          <dl>
<dt><code>a</code><dd>P register

          <br><dt><code>d</code><dd>D register

          <br><dt><code>z</code><dd>A call clobbered P register.

          <br><dt><code>D</code><dd>Even-numbered D register

          <br><dt><code>W</code><dd>Odd-numbered D register

          <br><dt><code>e</code><dd>Accumulator register.

          <br><dt><code>A</code><dd>Even-numbered accumulator register.

          <br><dt><code>B</code><dd>Odd-numbered accumulator register.

          <br><dt><code>b</code><dd>I register

          <br><dt><code>B</code><dd>B register

          <br><dt><code>f</code><dd>M register

          <br><dt><code>c</code><dd>Registers used for circular buffering, i.e. I, B, or L registers.

          <br><dt><code>C</code><dd>The CC register.

          <br><dt><code>x</code><dd>Any D, P, B, M, I or L register.

          <br><dt><code>y</code><dd>Additional registers typically used only in prologues and epilogues: RETS,
RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and USP.

          <br><dt><code>w</code><dd>Any register except accumulators or CC.

          <br><dt><code>Ksh</code><dd>Signed 16 bit integer (in the range -32768 to 32767)

          <br><dt><code>Kuh</code><dd>Unsigned 16 bit integer (in the range 0 to 65535)

          <br><dt><code>Ks7</code><dd>Signed 7 bit integer (in the range -64 to 63)

          <br><dt><code>Ku7</code><dd>Unsigned 7 bit integer (in the range 0 to 127)

          <br><dt><code>Ku5</code><dd>Unsigned 5 bit integer (in the range 0 to 31)

          <br><dt><code>Ks4</code><dd>Signed 4 bit integer (in the range -8 to 7)

          <br><dt><code>Ks3</code><dd>Signed 3 bit integer (in the range -3 to 4)

          <br><dt><code>Ku3</code><dd>Unsigned 3 bit integer (in the range 0 to 7)

          <br><dt><code>P</code><var>n</var><dd>Constant <var>n</var>, where <var>n</var> is a single-digit constant in the range 0 to 4.

          <br><dt><code>M1</code><dd>Constant 255.

          <br><dt><code>M2</code><dd>Constant 65535.

          <br><dt><code>J</code><dd>An integer constant with exactly a single bit set.

          <br><dt><code>L</code><dd>An integer constant with all bits set except exactly one.

          <br><dt><code>H</code>
<br><dt><code>Q</code><dd>Any SYMBOL_REF. 
</dl>

     <br><dt><em>M32C&mdash;</em><samp><span class="file">m32c.c</span></samp>
<br><dt><em>Rsp</em><dt><em>Rfb</em><dt><em>Rsb</em><dd>&lsquo;<samp><span class="samp">$sp</span></samp>&rsquo;, &lsquo;<samp><span class="samp">$fb</span></samp>&rsquo;, &lsquo;<samp><span class="samp">$sb</span></samp>&rsquo;.

     <br><dt><em>Rcr</em><dd>Any control register, when they're 16 bits wide (nothing if control
registers are 24 bits wide)

     <br><dt><em>Rcl</em><dd>Any control register, when they're 24 bits wide.

     <br><dt><em>R0w</em><dt><em>R1w</em><dt><em>R2w</em><dt><em>R3w</em><dd>$r0, $r1, $r2, $r3.

     <br><dt><em>R02</em><dd>$r0 or $r2, or $r2r0 for 32 bit values.

     <br><dt><em>R13</em><dd>$r1 or $r3, or $r3r1 for 32 bit values.

     <br><dt><em>Rdi</em><dd>A register that can hold a 64 bit value.

     <br><dt><em>Rhl</em><dd>$r0 or $r1 (registers with addressable high/low bytes)

     <br><dt><em>R23</em><dd>$r2 or $r3

     <br><dt><em>Raa</em><dd>Address registers

     <br><dt><em>Raw</em><dd>Address registers when they're 16 bits wide.

     <br><dt><em>Ral</em><dd>Address registers when they're 24 bits wide.

     <br><dt><em>Rqi</em><dd>Registers that can hold QI values.

     <br><dt><em>Rad</em><dd>Registers that can be used with displacements ($a0, $a1, $sb).

     <br><dt><em>Rsi</em><dd>Registers that can hold 32 bit values.

     <br><dt><em>Rhi</em><dd>Registers that can hold 16 bit values.

     <br><dt><em>Rhc</em><dd>Registers chat can hold 16 bit values, including all control
registers.

     <br><dt><em>Rra</em><dd>$r0 through R1, plus $a0 and $a1.

     <br><dt><em>Rfl</em><dd>The flags register.

     <br><dt><em>Rmm</em><dd>The memory-based pseudo-registers $mem0 through $mem15.

     <br><dt><em>Rpi</em><dd>Registers that can hold pointers (16 bit registers for r8c, m16c; 24
bit registers for m32cm, m32c).

     <br><dt><em>Rpa</em><dd>Matches multiple registers in a PARALLEL to form a larger register. 
Used to match function return values.

     <br><dt><em>Is3</em><dd>-8 <small class="dots">...</small> 7

     <br><dt><em>IS1</em><dd>-128 <small class="dots">...</small> 127

     <br><dt><em>IS2</em><dd>-32768 <small class="dots">...</small> 32767

     <br><dt><em>IU2</em><dd>0 <small class="dots">...</small> 65535

     <br><dt><em>In4</em><dd>-8 <small class="dots">...</small> -1 or 1 <small class="dots">...</small> 8

     <br><dt><em>In5</em><dd>-16 <small class="dots">...</small> -1 or 1 <small class="dots">...</small> 16

     <br><dt><em>In4</em><dd>-8 <small class="dots">...</small> -1 or 1 <small class="dots">...</small> 8

     <br><dt><em>IM2</em><dd>-65536 <small class="dots">...</small> -1

     <br><dt><em>Ilb</em><dd>An 8 bit value with exactly one bit set.

     <br><dt><em>Ilw</em><dd>A 16 bit value with exactly one bit set.

     <br><dt><em>Sd</em><dd>The common src/dest memory addressing modes.

     <br><dt><em>Sa</em><dd>Memory addressed using $a0 or $a1.

     <br><dt><em>Si</em><dd>Memory addressed with immediate addresses.

     <br><dt><em>Ss</em><dd>Memory addressed using the stack pointer ($sp).

     <br><dt><em>Sf</em><dd>Memory addressed using the frame base register ($fb).

     <br><dt><em>Ss</em><dd>Memory addressed using the small base register ($sb).

     <br><dt><em>S1</em><dd>$r1h

     <br><dt><em>MIPS&mdash;</em><samp><span class="file">mips.h</span></samp><dd>
          <dl>
<dt><code>d</code><dd>General-purpose integer register

          <br><dt><code>f</code><dd>Floating-point register (if available)

          <br><dt><code>h</code><dd>&lsquo;<samp><span class="samp">Hi</span></samp>&rsquo; register

          <br><dt><code>l</code><dd>&lsquo;<samp><span class="samp">Lo</span></samp>&rsquo; register

          <br><dt><code>x</code><dd>&lsquo;<samp><span class="samp">Hi</span></samp>&rsquo; or &lsquo;<samp><span class="samp">Lo</span></samp>&rsquo; register

          <br><dt><code>y</code><dd>General-purpose integer register

          <br><dt><code>z</code><dd>Floating-point status register

          <br><dt><code>I</code><dd>Signed 16-bit constant (for arithmetic instructions)

          <br><dt><code>J</code><dd>Zero

          <br><dt><code>K</code><dd>Zero-extended 16-bit constant (for logic instructions)

          <br><dt><code>L</code><dd>Constant with low 16 bits zero (can be loaded with <code>lui</code>)

          <br><dt><code>M</code><dd>32-bit constant which requires two instructions to load (a constant
which is not &lsquo;<samp><span class="samp">I</span></samp>&rsquo;, &lsquo;<samp><span class="samp">K</span></samp>&rsquo;, or &lsquo;<samp><span class="samp">L</span></samp>&rsquo;)

          <br><dt><code>N</code><dd>Negative 16-bit constant

          <br><dt><code>O</code><dd>Exact power of two

          <br><dt><code>P</code><dd>Positive 16-bit constant

          <br><dt><code>G</code><dd>Floating point zero

          <br><dt><code>Q</code><dd>Memory reference that can be loaded with more than one instruction
(&lsquo;<samp><span class="samp">m</span></samp>&rsquo; is preferable for <code>asm</code> statements)

          <br><dt><code>R</code><dd>Memory reference that can be loaded with one instruction
(&lsquo;<samp><span class="samp">m</span></samp>&rsquo; is preferable for <code>asm</code> statements)

          <br><dt><code>S</code><dd>Memory reference in external OSF/rose PIC format
(&lsquo;<samp><span class="samp">m</span></samp>&rsquo; is preferable for <code>asm</code> statements)
</dl>

     <br><dt><em>Motorola 680x0&mdash;</em><samp><span class="file">m68k.h</span></samp><dd>
          <dl>
<dt><code>a</code><dd>Address register

          <br><dt><code>d</code><dd>Data register

          <br><dt><code>f</code><dd>68881 floating-point register, if available

          <br><dt><code>I</code><dd>Integer in the range 1 to 8

          <br><dt><code>J</code><dd>16-bit signed number

          <br><dt><code>K</code><dd>Signed number whose magnitude is greater than 0x80

          <br><dt><code>L</code><dd>Integer in the range &minus;8 to &minus;1

          <br><dt><code>M</code><dd>Signed number whose magnitude is greater than 0x100

          <br><dt><code>G</code><dd>Floating point constant that is not a 68881 constant
</dl>

     <br><dt><em>Motorola 68HC11 &amp; 68HC12 families&mdash;</em><samp><span class="file">m68hc11.h</span></samp><dd>
          <dl>
<dt><code>a</code><dd>Register `a'

          <br><dt><code>b</code><dd>Register `b'

          <br><dt><code>d</code><dd>Register `d'

          <br><dt><code>q</code><dd>An 8-bit register

          <br><dt><code>t</code><dd>Temporary soft register _.tmp

          <br><dt><code>u</code><dd>A soft register _.d1 to _.d31

          <br><dt><code>w</code><dd>Stack pointer register

          <br><dt><code>x</code><dd>Register `x'

          <br><dt><code>y</code><dd>Register `y'

          <br><dt><code>z</code><dd>Pseudo register `z' (replaced by `x' or `y' at the end)

          <br><dt><code>A</code><dd>An address register: x, y or z

          <br><dt><code>B</code><dd>An address register: x or y

          <br><dt><code>D</code><dd>Register pair (x:d) to form a 32-bit value

          <br><dt><code>L</code><dd>Constants in the range &minus;65536 to 65535

          <br><dt><code>M</code><dd>Constants whose 16-bit low part is zero

          <br><dt><code>N</code><dd>Constant integer 1 or &minus;1

          <br><dt><code>O</code><dd>Constant integer 16

          <br><dt><code>P</code><dd>Constants in the range &minus;8 to 2

     </dl>

     <br><dt><em>SPARC&mdash;</em><samp><span class="file">sparc.h</span></samp><dd>
          <dl>
<dt><code>f</code><dd>Floating-point register on the SPARC-V8 architecture and
lower floating-point register on the SPARC-V9 architecture.

          <br><dt><code>e</code><dd>Floating-point register.  It is equivalent to &lsquo;<samp><span class="samp">f</span></samp>&rsquo; on the
SPARC-V8 architecture and contains both lower and upper
floating-point registers on the SPARC-V9 architecture.

          <br><dt><code>c</code><dd>Floating-point condition code register.

          <br><dt><code>d</code><dd>Lower floating-point register.  It is only valid on the SPARC-V9
architecture when the Visual Instruction Set is available.

          <br><dt><code>b</code><dd>Floating-point register.  It is only valid on the SPARC-V9 architecture
when the Visual Instruction Set is available.

          <br><dt><code>h</code><dd>64-bit global or out register for the SPARC-V8+ architecture.

          <br><dt><code>I</code><dd>Signed 13-bit constant

          <br><dt><code>J</code><dd>Zero

          <br><dt><code>K</code><dd>32-bit constant with the low 12 bits clear (a constant that can be
loaded with the <code>sethi</code> instruction)

          <br><dt><code>L</code><dd>A constant in the range supported by <code>movcc</code> instructions

          <br><dt><code>M</code><dd>A constant in the range supported by <code>movrcc</code> instructions

          <br><dt><code>N</code><dd>Same as &lsquo;<samp><span class="samp">K</span></samp>&rsquo;, except that it verifies that bits that are not in the
lower 32-bit range are all zero.  Must be used instead of &lsquo;<samp><span class="samp">K</span></samp>&rsquo; for
modes wider than <code>SImode</code>

          <br><dt><code>O</code><dd>The constant 4096

          <br><dt><code>G</code><dd>Floating-point zero

          <br><dt><code>H</code><dd>Signed 13-bit constant, sign-extended to 32 or 64 bits

          <br><dt><code>Q</code><dd>Floating-point constant whose integral representation can
be moved into an integer register using a single sethi
instruction

          <br><dt><code>R</code><dd>Floating-point constant whose integral representation can
be moved into an integer register using a single mov
instruction

          <br><dt><code>S</code><dd>Floating-point constant whose integral representation can
be moved into an integer register using a high/lo_sum
instruction sequence

          <br><dt><code>T</code><dd>Memory address aligned to an 8-byte boundary

          <br><dt><code>U</code><dd>Even register

          <br><dt><code>W</code><dd>Memory address for &lsquo;<samp><span class="samp">e</span></samp>&rsquo; constraint registers

          <br><dt><code>Y</code><dd>Vector zero

     </dl>

     <br><dt><em>TMS320C3x/C4x&mdash;</em><samp><span class="file">c4x.h</span></samp><dd>
          <dl>
<dt><code>a</code><dd>Auxiliary (address) register (ar0-ar7)

          <br><dt><code>b</code><dd>Stack pointer register (sp)

          <br><dt><code>c</code><dd>Standard (32-bit) precision integer register

          <br><dt><code>f</code><dd>Extended (40-bit) precision register (r0-r11)

          <br><dt><code>k</code><dd>Block count register (bk)

          <br><dt><code>q</code><dd>Extended (40-bit) precision low register (r0-r7)

          <br><dt><code>t</code><dd>Extended (40-bit) precision register (r0-r1)

          <br><dt><code>u</code><dd>Extended (40-bit) precision register (r2-r3)

          <br><dt><code>v</code><dd>Repeat count register (rc)

          <br><dt><code>x</code><dd>Index register (ir0-ir1)

          <br><dt><code>y</code><dd>Status (condition code) register (st)

          <br><dt><code>z</code><dd>Data page register (dp)

          <br><dt><code>G</code><dd>Floating-point zero

          <br><dt><code>H</code><dd>Immediate 16-bit floating-point constant

          <br><dt><code>I</code><dd>Signed 16-bit constant

          <br><dt><code>J</code><dd>Signed 8-bit constant

          <br><dt><code>K</code><dd>Signed 5-bit constant

          <br><dt><code>L</code><dd>Unsigned 16-bit constant

          <br><dt><code>M</code><dd>Unsigned 8-bit constant

          <br><dt><code>N</code><dd>Ones complement of unsigned 16-bit constant

          <br><dt><code>O</code><dd>High 16-bit constant (32-bit constant with 16 LSBs zero)

          <br><dt><code>Q</code><dd>Indirect memory reference with signed 8-bit or index register displacement

          <br><dt><code>R</code><dd>Indirect memory reference with unsigned 5-bit displacement

          <br><dt><code>S</code><dd>Indirect memory reference with 1 bit or index register displacement

          <br><dt><code>T</code><dd>Direct memory reference

          <br><dt><code>U</code><dd>Symbolic address

     </dl>

     <br><dt><em>S/390 and zSeries&mdash;</em><samp><span class="file">s390.h</span></samp><dd>
          <dl>
<dt><code>a</code><dd>Address register (general purpose register except r0)

          <br><dt><code>c</code><dd>Condition code register

          <br><dt><code>d</code><dd>Data register (arbitrary general purpose register)

          <br><dt><code>f</code><dd>Floating-point register

          <br><dt><code>I</code><dd>Unsigned 8-bit constant (0&ndash;255)

          <br><dt><code>J</code><dd>Unsigned 12-bit constant (0&ndash;4095)

          <br><dt><code>K</code><dd>Signed 16-bit constant (&minus;32768&ndash;32767)

          <br><dt><code>L</code><dd>Value appropriate as displacement.
               <dl>
       <dt><code>(0..4095)</code><dd>       for short displacement
       <br><dt><code>(-524288..524287)</code><dd>       for long displacement
</dl>

          <br><dt><code>M</code><dd>Constant integer with a value of 0x7fffffff.

          <br><dt><code>N</code><dd>Multiple letter constraint followed by 4 parameter letters.
               <dl>
         <dt><code>0..9:</code><dd>         number of the part counting from most to least significant
         <br><dt><code>H,Q:</code><dd>         mode of the part
         <br><dt><code>D,S,H:</code><dd>         mode of the containing operand
         <br><dt><code>0,F:</code><dd>         value of the other parts (F&mdash;all bits set)
</dl>
          The constraint matches if the specified part of a constant
has a value different from it's other parts.

          <br><dt><code>Q</code><dd>Memory reference without index register and with short displacement.

          <br><dt><code>R</code><dd>Memory reference with index register and short displacement.

          <br><dt><code>S</code><dd>Memory reference without index register but with long displacement.

          <br><dt><code>T</code><dd>Memory reference with index register and long displacement.

          <br><dt><code>U</code><dd>Pointer with short displacement.

          <br><dt><code>W</code><dd>Pointer with long displacement.

          <br><dt><code>Y</code><dd>Shift count operand.

     </dl>

     <br><dt><em>Xstormy16&mdash;</em><samp><span class="file">stormy16.h</span></samp><dd>
          <dl>
<dt><code>a</code><dd>Register r0.

          <br><dt><code>b</code><dd>Register r1.

          <br><dt><code>c</code><dd>Register r2.

          <br><dt><code>d</code><dd>Register r8.

          <br><dt><code>e</code><dd>Registers r0 through r7.

          <br><dt><code>t</code><dd>Registers r0 and r1.

          <br><dt><code>y</code><dd>The carry register.

          <br><dt><code>z</code><dd>Registers r8 and r9.

          <br><dt><code>I</code><dd>A constant between 0 and 3 inclusive.

          <br><dt><code>J</code><dd>A constant that has exactly one bit set.

          <br><dt><code>K</code><dd>A constant that has exactly one bit clear.

          <br><dt><code>L</code><dd>A constant between 0 and 255 inclusive.

          <br><dt><code>M</code><dd>A constant between &minus;255 and 0 inclusive.

          <br><dt><code>N</code><dd>A constant between &minus;3 and 0 inclusive.

          <br><dt><code>O</code><dd>A constant between 1 and 4 inclusive.

          <br><dt><code>P</code><dd>A constant between &minus;4 and &minus;1 inclusive.

          <br><dt><code>Q</code><dd>A memory reference that is a stack push.

          <br><dt><code>R</code><dd>A memory reference that is a stack pop.

          <br><dt><code>S</code><dd>A memory reference that refers to a constant address of known value.

          <br><dt><code>T</code><dd>The register indicated by Rx (not implemented yet).

          <br><dt><code>U</code><dd>A constant that is not between 2 and 15 inclusive.

          <br><dt><code>Z</code><dd>The constant 0.

     </dl>

     <br><dt><em>Xtensa&mdash;</em><samp><span class="file">xtensa.h</span></samp><dd>
          <dl>
<dt><code>a</code><dd>General-purpose 32-bit register

          <br><dt><code>b</code><dd>One-bit boolean register

          <br><dt><code>A</code><dd>MAC16 40-bit accumulator register

          <br><dt><code>I</code><dd>Signed 12-bit integer constant, for use in MOVI instructions

          <br><dt><code>J</code><dd>Signed 8-bit integer constant, for use in ADDI instructions

          <br><dt><code>K</code><dd>Integer constant valid for BccI instructions

          <br><dt><code>L</code><dd>Unsigned constant valid for BccUI instructions

     </dl>

 </dl>

<!-- Each of the following nodes are wrapped in separate -->
<!-- "@@ifset INTERNALS" to work around memory limits for the default -->
<!-- configuration in older tetex distributions.  Known to not work: -->
<!-- tetex-1.0.7, known to work: tetex-2.0.2. -->
 </body></html>

@


1.1.1.1
log
@  Initial import of GCC 4
Detail:
  This is a standard copy of GCC 4.1.2 r2, straight from the packages available on riscos.info
  Installed packages are:
  * GCC4 4.1.2-Rel2-1
  * GCC4-C++ 4.1.2-Rel2-1
Admin:
  Tagged as GCC-4_1_2_r2
@
text
@@


1.1.1.2
log
@GCC 4.7.4 release 3
Detail:
  This is a copy of GCC 4.7.4 release 3, composed from the following packages available from riscos.info:
  * GCC4 4.7.4-Rel3-1
  Note that to avoid bloating CVS there's no C++ compiler this time, and some of the extraneous libraries (e.g. VFP/NEON optimised libs) have been deleted
Admin:
  Tagged as GCC-4_7_4_r3
@
text
@d1 13
a13 5
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,
1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
2010 Free Software Foundation, Inc.
d16 1
a16 1
under the terms of the GNU Free Documentation License, Version 1.3 or
d18 4
a21 4
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".
d25 1
a25 1
A GNU Manual
d29 1
a29 1
You have freedom to copy and modify this GNU Manual, like GNU
d31 13
a43 47
     funds for GNU development. -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Using the GNU Compiler Collection (GCC): Machine Constraints</title>

<meta name="description" content="Using the GNU Compiler Collection (GCC): Machine Constraints">
<meta name="keywords" content="Using the GNU Compiler Collection (GCC): Machine Constraints">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Option-Index.html#Option-Index" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Constraints.html#Constraints" rel="up" title="Constraints">
<link href="Asm-Labels.html#Asm-Labels" rel="next" title="Asm Labels">
<link href="Modifiers.html#Modifiers" rel="prev" title="Modifiers">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


d45 2
a46 2

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
a47 1
<div class="header">
d49 3
a51 1
Previous: <a href="Modifiers.html#Modifiers" accesskey="p" rel="prev">Modifiers</a>, Up: <a href="Constraints.html#Constraints" accesskey="u" rel="up">Constraints</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html#Option-Index" title="Index" rel="index">Index</a>]</p>
a52 5
<hr>
<a name="Constraints-for-Particular-Machines"></a>
<h4 class="subsection">6.42.4 Constraints for Particular Machines</h4>
<a name="index-machine-specific-constraints"></a>
<a name="index-constraints_002c-machine-specific"></a>
d54 4
a57 1
<p>Whenever possible, you should use the general-purpose constraint letters
d61 1
a61 1
commonly used constraints are &lsquo;<samp>m</samp>&rsquo; and &lsquo;<samp>r</samp>&rsquo; (for memory and
d63 1
a63 1
&lsquo;<samp>I</samp>&rsquo;, usually the letter indicating the most common
d65 34
a98 24
</p>
<p>Each architecture defines additional constraints.  These constraints
are used by the compiler itself for instruction generation, as well as
for <code>asm</code> statements; therefore, some of the constraints are not
particularly useful for <code>asm</code>.  Here is a summary of some of the
machine-dependent constraints available on some particular machines;
it includes both constraints that are useful for <code>asm</code> and
constraints that aren&rsquo;t.  The compiler source file mentioned in the
table heading for each architecture is the definitive reference for
the meanings of that architecture&rsquo;s constraints.
</p>
<dl compact="compact">
<dt><em>ARM family&mdash;<samp>config/arm/arm.h</samp></em></dt>
<dd><dl compact="compact">
<dt><code>f</code></dt>
<dd><p>Floating-point register
</p>
</dd>
<dt><code>w</code></dt>
<dd><p>VFP floating-point register
</p>
</dd>
<dt><code>F</code></dt>
<dd><p>One of the floating-point constants 0.0, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0
d100 2
a101 4
</p>
</dd>
<dt><code>G</code></dt>
<dd><p>Floating-point constant that would satisfy the constraint &lsquo;<samp>F</samp>&rsquo; if it
d103 2
a104 4
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>Integer that is valid as an immediate operand in a data processing
d107 21
a127 42
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>Integer in the range -4095 to 4095
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>Integer that satisfies constraint &lsquo;<samp>I</samp>&rsquo; when inverted (ones complement)
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>Integer that satisfies constraint &lsquo;<samp>I</samp>&rsquo; when negated (twos complement)
</p>
</dd>
<dt><code>M</code></dt>
<dd><p>Integer in the range 0 to 32
</p>
</dd>
<dt><code>Q</code></dt>
<dd><p>A memory reference where the exact address is in a single register
(&lsquo;&lsquo;<samp>m</samp>&rsquo;&rsquo; is preferable for <code>asm</code> statements)
</p>
</dd>
<dt><code>R</code></dt>
<dd><p>An item in the constant pool
</p>
</dd>
<dt><code>S</code></dt>
<dd><p>A symbol in the text segment of the current file
</p>
</dd>
<dt><code>Uv</code></dt>
<dd><p>A memory reference suitable for VFP load/store insns (reg+constant offset)
</p>
</dd>
<dt><code>Uy</code></dt>
<dd><p>A memory reference suitable for iWMMXt load/store instructions.
</p>
</dd>
<dt><code>Uq</code></dt>
<dd><p>A memory reference suitable for the ARMv4 ldrsb instruction.
</p></dd>
d130 41
a170 86
</dd>
<dt><em>AVR family&mdash;<samp>config/avr/constraints.md</samp></em></dt>
<dd><dl compact="compact">
<dt><code>l</code></dt>
<dd><p>Registers from r0 to r15
</p>
</dd>
<dt><code>a</code></dt>
<dd><p>Registers from r16 to r23
</p>
</dd>
<dt><code>d</code></dt>
<dd><p>Registers from r16 to r31
</p>
</dd>
<dt><code>w</code></dt>
<dd><p>Registers from r24 to r31.  These registers can be used in &lsquo;<samp>adiw</samp>&rsquo; command
</p>
</dd>
<dt><code>e</code></dt>
<dd><p>Pointer register (r26&ndash;r31)
</p>
</dd>
<dt><code>b</code></dt>
<dd><p>Base pointer register (r28&ndash;r31)
</p>
</dd>
<dt><code>q</code></dt>
<dd><p>Stack pointer register (SPH:SPL)
</p>
</dd>
<dt><code>t</code></dt>
<dd><p>Temporary register r0
</p>
</dd>
<dt><code>x</code></dt>
<dd><p>Register pair X (r27:r26)
</p>
</dd>
<dt><code>y</code></dt>
<dd><p>Register pair Y (r29:r28)
</p>
</dd>
<dt><code>z</code></dt>
<dd><p>Register pair Z (r31:r30)
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>Constant greater than -1, less than 64
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>Constant greater than -64, less than 1
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>Constant integer 2
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>Constant integer 0
</p>
</dd>
<dt><code>M</code></dt>
<dd><p>Constant that fits in 8 bits
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>Constant integer -1
</p>
</dd>
<dt><code>O</code></dt>
<dd><p>Constant integer 8, 16, or 24
</p>
</dd>
<dt><code>P</code></dt>
<dd><p>Constant integer 1
</p>
</dd>
<dt><code>G</code></dt>
<dd><p>A floating point constant 0.0
</p>
</dd>
<dt><code>Q</code></dt>
<dd><p>A memory address based on Y or Z pointer with displacement.
</p></dd>
d173 19
a191 81
</dd>
<dt><em>Epiphany&mdash;<samp>config/epiphany/constraints.md</samp></em></dt>
<dd><dl compact="compact">
<dt><code>U16</code></dt>
<dd><p>An unsigned 16-bit constant.
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>An unsigned 5-bit constant.
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>A signed 11-bit constant.
</p>
</dd>
<dt><code>Cm1</code></dt>
<dd><p>A signed 11-bit constant added to -1.
Can only match when the <samp>-m1reg-<var>reg</var></samp> option is active.
</p>
</dd>
<dt><code>Cl1</code></dt>
<dd><p>Left-shift of -1, i.e., a bit mask with a block of leading ones, the rest
being a block of trailing zeroes.
Can only match when the <samp>-m1reg-<var>reg</var></samp> option is active.
</p>
</dd>
<dt><code>Cr1</code></dt>
<dd><p>Right-shift of -1, i.e., a bit mask with a trailing block of ones, the
rest being zeroes.  Or to put it another way, one less than a power of two.
Can only match when the <samp>-m1reg-<var>reg</var></samp> option is active.
</p>
</dd>
<dt><code>Cal</code></dt>
<dd><p>Constant for arithmetic/logical operations.
This is like <code>i</code>, except that for position independent code,
no symbols / expressions needing relocations are allowed.
</p>
</dd>
<dt><code>Csy</code></dt>
<dd><p>Symbolic constant for call/jump instruction.
</p>
</dd>
<dt><code>Rcs</code></dt>
<dd><p>The register class usable in short insns.  This is a register class
constraint, and can thus drive register allocation.
This constraint won&rsquo;t match unless <samp>-mprefer-short-insn-regs</samp> is
in effect.
</p>
</dd>
<dt><code>Rsc</code></dt>
<dd><p>The the register class of registers that can be used to hold a
sibcall call address.  I.e., a caller-saved register.
</p>
</dd>
<dt><code>Rct</code></dt>
<dd><p>Core control register class.
</p>
</dd>
<dt><code>Rgs</code></dt>
<dd><p>The register group usable in short insns.
This constraint does not use a register class, so that it only
passively matches suitable registers, and doesn&rsquo;t drive register allocation.
</p>

</dd>
<dt><code>Rra</code></dt>
<dd><p>Matches the return address if it can be replaced with the link register.
</p>
</dd>
<dt><code>Rcc</code></dt>
<dd><p>Matches the integer condition code register.
</p>
</dd>
<dt><code>Sra</code></dt>
<dd><p>Matches the return address if it is in a stack slot.
</p>
</dd>
<dt><code>Cfm</code></dt>
<dd><p>Matches control register values to switch fp mode, which are encapsulated in
<code>UNSPEC_FP_MODE</code>.
</p></dd>
d194 19
a212 43
</dd>
<dt><em>CR16 Architecture&mdash;<samp>config/cr16/cr16.h</samp></em></dt>
<dd><dl compact="compact">
<dt><code>b</code></dt>
<dd><p>Registers from r0 to r14 (registers without stack pointer)
</p>
</dd>
<dt><code>t</code></dt>
<dd><p>Register from r0 to r11 (all 16-bit registers)
</p>
</dd>
<dt><code>p</code></dt>
<dd><p>Register from r12 to r15 (all 32-bit registers)
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>Signed constant that fits in 4 bits
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>Signed constant that fits in 5 bits
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>Signed constant that fits in 6 bits
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>Unsigned constant that fits in 4 bits
</p>
</dd>
<dt><code>M</code></dt>
<dd><p>Signed constant that fits in 32 bits
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>Check for 64 bits wide constants for add/sub instructions
</p>
</dd>
<dt><code>G</code></dt>
<dd><p>Floating point constant that is legal for store immediate
</p></dd>
</dl>
d214 1
a214 93
</dd>
<dt><em>Hewlett-Packard PA-RISC&mdash;<samp>config/pa/pa.h</samp></em></dt>
<dd><dl compact="compact">
<dt><code>a</code></dt>
<dd><p>General register 1
</p>
</dd>
<dt><code>f</code></dt>
<dd><p>Floating point register
</p>
</dd>
<dt><code>q</code></dt>
<dd><p>Shift amount register
</p>
</dd>
<dt><code>x</code></dt>
<dd><p>Floating point register (deprecated)
</p>
</dd>
<dt><code>y</code></dt>
<dd><p>Upper floating point register (32-bit), floating point register (64-bit)
</p>
</dd>
<dt><code>Z</code></dt>
<dd><p>Any register
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>Signed 11-bit integer constant
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>Signed 14-bit integer constant
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>Integer constant that can be deposited with a <code>zdepi</code> instruction
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>Signed 5-bit integer constant
</p>
</dd>
<dt><code>M</code></dt>
<dd><p>Integer constant 0
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>Integer constant that can be loaded with a <code>ldil</code> instruction
</p>
</dd>
<dt><code>O</code></dt>
<dd><p>Integer constant whose value plus one is a power of 2
</p>
</dd>
<dt><code>P</code></dt>
<dd><p>Integer constant that can be used for <code>and</code> operations in <code>depi</code>
and <code>extru</code> instructions
</p>
</dd>
<dt><code>S</code></dt>
<dd><p>Integer constant 31
</p>
</dd>
<dt><code>U</code></dt>
<dd><p>Integer constant 63
</p>
</dd>
<dt><code>G</code></dt>
<dd><p>Floating-point constant 0.0
</p>
</dd>
<dt><code>A</code></dt>
<dd><p>A <code>lo_sum</code> data-linkage-table memory operand
</p>
</dd>
<dt><code>Q</code></dt>
<dd><p>A memory operand that can be used as the destination operand of an
integer store instruction
</p>
</dd>
<dt><code>R</code></dt>
<dd><p>A scaled or unscaled indexed memory operand
</p>
</dd>
<dt><code>T</code></dt>
<dd><p>A memory operand for floating-point loads and stores
</p>
</dd>
<dt><code>W</code></dt>
<dd><p>A register indirect memory operand
</p></dd>
</dl>
d216 1
a216 50
</dd>
<dt><em>picoChip family&mdash;<samp>picochip.h</samp></em></dt>
<dd><dl compact="compact">
<dt><code>k</code></dt>
<dd><p>Stack register.
</p>
</dd>
<dt><code>f</code></dt>
<dd><p>Pointer register.  A register which can be used to access memory without
supplying an offset.  Any other register can be used to access memory,
but will need a constant offset.  In the case of the offset being zero,
it is more efficient to use a pointer register, since this reduces code
size.
</p>
</dd>
<dt><code>t</code></dt>
<dd><p>A twin register.  A register which may be paired with an adjacent
register to create a 32-bit register.
</p>
</dd>
<dt><code>a</code></dt>
<dd><p>Any absolute memory address (e.g., symbolic constant, symbolic
constant + offset).
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>4-bit signed integer.
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>4-bit unsigned integer.
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>8-bit signed integer.
</p>
</dd>
<dt><code>M</code></dt>
<dd><p>Any constant whose absolute value is no greater than 4-bits.
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>10-bit signed integer
</p>
</dd>
<dt><code>O</code></dt>
<dd><p>16-bit signed integer.
</p>
</dd>
</dl>
d218 1
a218 69
</dd>
<dt><em>PowerPC and IBM RS6000&mdash;<samp>config/rs6000/rs6000.h</samp></em></dt>
<dd><dl compact="compact">
<dt><code>b</code></dt>
<dd><p>Address base register
</p>
</dd>
<dt><code>d</code></dt>
<dd><p>Floating point register (containing 64-bit value)
</p>
</dd>
<dt><code>f</code></dt>
<dd><p>Floating point register (containing 32-bit value)
</p>
</dd>
<dt><code>v</code></dt>
<dd><p>Altivec vector register
</p>
</dd>
<dt><code>wd</code></dt>
<dd><p>VSX vector register to hold vector double data
</p>
</dd>
<dt><code>wf</code></dt>
<dd><p>VSX vector register to hold vector float data
</p>
</dd>
<dt><code>ws</code></dt>
<dd><p>VSX vector register to hold scalar float data
</p>
</dd>
<dt><code>wa</code></dt>
<dd><p>Any VSX register
</p>
</dd>
<dt><code>h</code></dt>
<dd><p>&lsquo;<samp>MQ</samp>&rsquo;, &lsquo;<samp>CTR</samp>&rsquo;, or &lsquo;<samp>LINK</samp>&rsquo; register
</p>
</dd>
<dt><code>q</code></dt>
<dd><p>&lsquo;<samp>MQ</samp>&rsquo; register
</p>
</dd>
<dt><code>c</code></dt>
<dd><p>&lsquo;<samp>CTR</samp>&rsquo; register
</p>
</dd>
<dt><code>l</code></dt>
<dd><p>&lsquo;<samp>LINK</samp>&rsquo; register
</p>
</dd>
<dt><code>x</code></dt>
<dd><p>&lsquo;<samp>CR</samp>&rsquo; register (condition register) number 0
</p>
</dd>
<dt><code>y</code></dt>
<dd><p>&lsquo;<samp>CR</samp>&rsquo; register (condition register)
</p>
</dd>
<dt><code>z</code></dt>
<dd><p>&lsquo;<samp>XER[CA]</samp>&rsquo; carry bit (part of the XER register)
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>Signed 16-bit constant
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>Unsigned 16-bit constant shifted left 16 bits (use &lsquo;<samp>L</samp>&rsquo; instead for
d220 14
a233 28
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>Unsigned 16-bit constant
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>Signed 16-bit constant shifted left 16 bits
</p>
</dd>
<dt><code>M</code></dt>
<dd><p>Constant larger than 31
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>Exact power of 2
</p>
</dd>
<dt><code>O</code></dt>
<dd><p>Zero
</p>
</dd>
<dt><code>P</code></dt>
<dd><p>Constant whose negation is a signed 16-bit constant
</p>
</dd>
<dt><code>G</code></dt>
<dd><p>Floating point constant that can be loaded into a register with one
d235 11
a245 81
</p>
</dd>
<dt><code>H</code></dt>
<dd><p>Integer/Floating point constant that can be loaded into a register using
three instructions
</p>
</dd>
<dt><code>m</code></dt>
<dd><p>Memory operand.
Normally, <code>m</code> does not allow addresses that update the base register.
If &lsquo;<samp>&lt;</samp>&rsquo; or &lsquo;<samp>&gt;</samp>&rsquo; constraint is also used, they are allowed and
therefore on PowerPC targets in that case it is only safe
to use &lsquo;<samp>m&lt;&gt;</samp>&rsquo; in an <code>asm</code> statement if that <code>asm</code> statement
accesses the operand exactly once.  The <code>asm</code> statement must also
use &lsquo;<samp>%U<var>&lt;opno&gt;</var></samp>&rsquo; as a placeholder for the &ldquo;update&rdquo; flag in the
corresponding load or store instruction.  For example:
</p>
<div class="smallexample">
<pre class="smallexample">asm (&quot;st%U0 %1,%0&quot; : &quot;=m&lt;&gt;&quot; (mem) : &quot;r&quot; (val));
</pre></div>

<p>is correct but:
</p>
<div class="smallexample">
<pre class="smallexample">asm (&quot;st %1,%0&quot; : &quot;=m&lt;&gt;&quot; (mem) : &quot;r&quot; (val));
</pre></div>

<p>is not.
</p>
</dd>
<dt><code>es</code></dt>
<dd><p>A &ldquo;stable&rdquo; memory operand; that is, one which does not include any
automodification of the base register.  This used to be useful when
&lsquo;<samp>m</samp>&rsquo; allowed automodification of the base register, but as those are now only
allowed when &lsquo;<samp>&lt;</samp>&rsquo; or &lsquo;<samp>&gt;</samp>&rsquo; is used, &lsquo;<samp>es</samp>&rsquo; is basically the same
as &lsquo;<samp>m</samp>&rsquo; without &lsquo;<samp>&lt;</samp>&rsquo; and &lsquo;<samp>&gt;</samp>&rsquo;.
</p>
</dd>
<dt><code>Q</code></dt>
<dd><p>Memory operand that is an offset from a register (it is usually better
to use &lsquo;<samp>m</samp>&rsquo; or &lsquo;<samp>es</samp>&rsquo; in <code>asm</code> statements)
</p>
</dd>
<dt><code>Z</code></dt>
<dd><p>Memory operand that is an indexed or indirect from a register (it is
usually better to use &lsquo;<samp>m</samp>&rsquo; or &lsquo;<samp>es</samp>&rsquo; in <code>asm</code> statements)
</p>
</dd>
<dt><code>R</code></dt>
<dd><p>AIX TOC entry
</p>
</dd>
<dt><code>a</code></dt>
<dd><p>Address operand that is an indexed or indirect from a register (&lsquo;<samp>p</samp>&rsquo; is
preferable for <code>asm</code> statements)
</p>
</dd>
<dt><code>S</code></dt>
<dd><p>Constant suitable as a 64-bit mask operand
</p>
</dd>
<dt><code>T</code></dt>
<dd><p>Constant suitable as a 32-bit mask operand
</p>
</dd>
<dt><code>U</code></dt>
<dd><p>System V Release 4 small data area reference
</p>
</dd>
<dt><code>t</code></dt>
<dd><p>AND masks that can be performed by two rldic{l, r} instructions
</p>
</dd>
<dt><code>W</code></dt>
<dd><p>Vector constant that does not require memory
</p>
</dd>
<dt><code>j</code></dt>
<dd><p>Vector constant that is all zeros.
</p>
</dd>
d248 83
a330 144
</dd>
<dt><em>Intel 386&mdash;<samp>config/i386/constraints.md</samp></em></dt>
<dd><dl compact="compact">
<dt><code>R</code></dt>
<dd><p>Legacy register&mdash;the eight integer registers available on all
i386 processors (<code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>,
<code>si</code>, <code>di</code>, <code>bp</code>, <code>sp</code>).
</p>
</dd>
<dt><code>q</code></dt>
<dd><p>Any register accessible as <code><var>r</var>l</code>.  In 32-bit mode, <code>a</code>,
<code>b</code>, <code>c</code>, and <code>d</code>; in 64-bit mode, any integer register.
</p>
</dd>
<dt><code>Q</code></dt>
<dd><p>Any register accessible as <code><var>r</var>h</code>: <code>a</code>, <code>b</code>,
<code>c</code>, and <code>d</code>.
</p>

</dd>
<dt><code>a</code></dt>
<dd><p>The <code>a</code> register.
</p>
</dd>
<dt><code>b</code></dt>
<dd><p>The <code>b</code> register.
</p>
</dd>
<dt><code>c</code></dt>
<dd><p>The <code>c</code> register.
</p>
</dd>
<dt><code>d</code></dt>
<dd><p>The <code>d</code> register.
</p>
</dd>
<dt><code>S</code></dt>
<dd><p>The <code>si</code> register.
</p>
</dd>
<dt><code>D</code></dt>
<dd><p>The <code>di</code> register.
</p>
</dd>
<dt><code>A</code></dt>
<dd><p>The <code>a</code> and <code>d</code> registers.  This class is used for instructions
that return double word results in the <code>ax:dx</code> register pair.  Single
word values will be allocated either in <code>ax</code> or <code>dx</code>.
For example on i386 the following implements <code>rdtsc</code>:
</p>
<div class="smallexample">
<pre class="smallexample">unsigned long long rdtsc (void)
{
  unsigned long long tick;
  __asm__ __volatile__(&quot;rdtsc&quot;:&quot;=A&quot;(tick));
  return tick;
}
</pre></div>

<p>This is not correct on x86_64 as it would allocate tick in either <code>ax</code>
or <code>dx</code>.  You have to use the following variant instead:
</p>
<div class="smallexample">
<pre class="smallexample">unsigned long long rdtsc (void)
{
  unsigned int tickl, tickh;
  __asm__ __volatile__(&quot;rdtsc&quot;:&quot;=a&quot;(tickl),&quot;=d&quot;(tickh));
  return ((unsigned long long)tickh &lt;&lt; 32)|tickl;
}
</pre></div>


</dd>
<dt><code>f</code></dt>
<dd><p>Any 80387 floating-point (stack) register.
</p>
</dd>
<dt><code>t</code></dt>
<dd><p>Top of 80387 floating-point stack (<code>%st(0)</code>).
</p>
</dd>
<dt><code>u</code></dt>
<dd><p>Second from top of 80387 floating-point stack (<code>%st(1)</code>).
</p>
</dd>
<dt><code>y</code></dt>
<dd><p>Any MMX register.
</p>
</dd>
<dt><code>x</code></dt>
<dd><p>Any SSE register.
</p>
</dd>
<dt><code>Yz</code></dt>
<dd><p>First SSE register (<code>%xmm0</code>).
</p>

</dd>
<dt><code>I</code></dt>
<dd><p>Integer constant in the range 0 &hellip; 31, for 32-bit shifts.
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>Integer constant in the range 0 &hellip; 63, for 64-bit shifts.
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>Signed 8-bit integer constant.
</p>
</dd>
<dt><code>L</code></dt>
<dd><p><code>0xFF</code> or <code>0xFFFF</code>, for andsi as a zero-extending move.
</p>
</dd>
<dt><code>M</code></dt>
<dd><p>0, 1, 2, or 3 (shifts for the <code>lea</code> instruction).
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>Unsigned 8-bit integer constant (for <code>in</code> and <code>out</code>
instructions).
</p>

</dd>
<dt><code>G</code></dt>
<dd><p>Standard 80387 floating point constant.
</p>
</dd>
<dt><code>C</code></dt>
<dd><p>Standard SSE floating point constant.
</p>
</dd>
<dt><code>e</code></dt>
<dd><p>32-bit signed integer constant, or a symbolic reference known
to fit that range (for immediate operands in sign-extending x86-64
instructions).
</p>
</dd>
<dt><code>Z</code></dt>
<dd><p>32-bit unsigned integer constant, or a symbolic reference known
to fit that range (for immediate operands in zero-extending x86-64
instructions).
</p>
</dd>
d333 42
a374 82
</dd>
<dt><em>Intel IA-64&mdash;<samp>config/ia64/ia64.h</samp></em></dt>
<dd><dl compact="compact">
<dt><code>a</code></dt>
<dd><p>General register <code>r0</code> to <code>r3</code> for <code>addl</code> instruction
</p>
</dd>
<dt><code>b</code></dt>
<dd><p>Branch register
</p>
</dd>
<dt><code>c</code></dt>
<dd><p>Predicate register (&lsquo;<samp>c</samp>&rsquo; as in &ldquo;conditional&rdquo;)
</p>
</dd>
<dt><code>d</code></dt>
<dd><p>Application register residing in M-unit
</p>
</dd>
<dt><code>e</code></dt>
<dd><p>Application register residing in I-unit
</p>
</dd>
<dt><code>f</code></dt>
<dd><p>Floating-point register
</p>
</dd>
<dt><code>m</code></dt>
<dd><p>Memory operand.  If used together with &lsquo;<samp>&lt;</samp>&rsquo; or &lsquo;<samp>&gt;</samp>&rsquo;,
the operand can have postincrement and postdecrement which
require printing with &lsquo;<samp>%Pn</samp>&rsquo; on IA-64.
</p>
</dd>
<dt><code>G</code></dt>
<dd><p>Floating-point constant 0.0 or 1.0
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>14-bit signed integer constant
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>22-bit signed integer constant
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>8-bit signed integer constant for logical instructions
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>8-bit adjusted signed integer constant for compare pseudo-ops
</p>
</dd>
<dt><code>M</code></dt>
<dd><p>6-bit unsigned integer constant for shift counts
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>9-bit signed integer constant for load and store postincrements
</p>
</dd>
<dt><code>O</code></dt>
<dd><p>The constant zero
</p>
</dd>
<dt><code>P</code></dt>
<dd><p>0 or -1 for <code>dep</code> instruction
</p>
</dd>
<dt><code>Q</code></dt>
<dd><p>Non-volatile memory for floating-point loads and stores
</p>
</dd>
<dt><code>R</code></dt>
<dd><p>Integer constant in the range 1 to 4 for <code>shladd</code> instruction
</p>
</dd>
<dt><code>S</code></dt>
<dd><p>Memory operand except postincrement and postdecrement.  This is
now roughly the same as &lsquo;<samp>m</samp>&rsquo; when not used together with &lsquo;<samp>&lt;</samp>&rsquo;
or &lsquo;<samp>&gt;</samp>&rsquo;.
</p></dd>
d377 7
a383 13
</dd>
<dt><em>FRV&mdash;<samp>config/frv/frv.h</samp></em></dt>
<dd><dl compact="compact">
<dt><code>a</code></dt>
<dd><p>Register in the class <code>ACC_REGS</code> (<code>acc0</code> to <code>acc7</code>).
</p>
</dd>
<dt><code>b</code></dt>
<dd><p>Register in the class <code>EVEN_ACC_REGS</code> (<code>acc0</code> to <code>acc7</code>).
</p>
</dd>
<dt><code>c</code></dt>
<dd><p>Register in the class <code>CC_REGS</code> (<code>fcc0</code> to <code>fcc3</code> and
d385 4
a388 8
</p>
</dd>
<dt><code>d</code></dt>
<dd><p>Register in the class <code>GPR_REGS</code> (<code>gr0</code> to <code>gr63</code>).
</p>
</dd>
<dt><code>e</code></dt>
<dd><p>Register in the class <code>EVEN_REGS</code> (<code>gr0</code> to <code>gr63</code>).
d391 4
a394 8
</p>
</dd>
<dt><code>f</code></dt>
<dd><p>Register in the class <code>FPR_REGS</code> (<code>fr0</code> to <code>fr63</code>).
</p>
</dd>
<dt><code>h</code></dt>
<dd><p>Register in the class <code>FEVEN_REGS</code> (<code>fr0</code> to <code>fr63</code>).
d397 4
a400 8
</p>
</dd>
<dt><code>l</code></dt>
<dd><p>Register in the class <code>LR_REG</code> (the <code>lr</code> register).
</p>
</dd>
<dt><code>q</code></dt>
<dd><p>Register in the class <code>QUAD_REGS</code> (<code>gr2</code> to <code>gr63</code>).
d403 10
a412 20
</p>
</dd>
<dt><code>t</code></dt>
<dd><p>Register in the class <code>ICC_REGS</code> (<code>icc0</code> to <code>icc3</code>).
</p>
</dd>
<dt><code>u</code></dt>
<dd><p>Register in the class <code>FCC_REGS</code> (<code>fcc0</code> to <code>fcc3</code>).
</p>
</dd>
<dt><code>v</code></dt>
<dd><p>Register in the class <code>ICR_REGS</code> (<code>cc4</code> to <code>cc7</code>).
</p>
</dd>
<dt><code>w</code></dt>
<dd><p>Register in the class <code>FCR_REGS</code> (<code>cc0</code> to <code>cc3</code>).
</p>
</dd>
<dt><code>x</code></dt>
<dd><p>Register in the class <code>QUAD_FPR_REGS</code> (<code>fr0</code> to <code>fr63</code>).
d415 25
a439 49
</p>
</dd>
<dt><code>z</code></dt>
<dd><p>Register in the class <code>SPR_REGS</code> (<code>lcr</code> and <code>lr</code>).
</p>
</dd>
<dt><code>A</code></dt>
<dd><p>Register in the class <code>QUAD_ACC_REGS</code> (<code>acc0</code> to <code>acc7</code>).
</p>
</dd>
<dt><code>B</code></dt>
<dd><p>Register in the class <code>ACCG_REGS</code> (<code>accg0</code> to <code>accg7</code>).
</p>
</dd>
<dt><code>C</code></dt>
<dd><p>Register in the class <code>CR_REGS</code> (<code>cc0</code> to <code>cc7</code>).
</p>
</dd>
<dt><code>G</code></dt>
<dd><p>Floating point constant zero
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>6-bit signed integer constant
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>10-bit signed integer constant
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>16-bit signed integer constant
</p>
</dd>
<dt><code>M</code></dt>
<dd><p>16-bit unsigned integer constant
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>12-bit signed integer constant that is negative&mdash;i.e. in the
range of -2048 to -1
</p>
</dd>
<dt><code>O</code></dt>
<dd><p>Constant zero
</p>
</dd>
<dt><code>P</code></dt>
<dd><p>12-bit signed integer constant that is greater than zero&mdash;i.e. in the
a440 3
</p>
</dd>
</dl>
d442 33
a474 78
</dd>
<dt><em>Blackfin family&mdash;<samp>config/bfin/constraints.md</samp></em></dt>
<dd><dl compact="compact">
<dt><code>a</code></dt>
<dd><p>P register
</p>
</dd>
<dt><code>d</code></dt>
<dd><p>D register
</p>
</dd>
<dt><code>z</code></dt>
<dd><p>A call clobbered P register.
</p>
</dd>
<dt><code>q<var>n</var></code></dt>
<dd><p>A single register.  If <var>n</var> is in the range 0 to 7, the corresponding D
register.  If it is <code>A</code>, then the register P0.
</p>
</dd>
<dt><code>D</code></dt>
<dd><p>Even-numbered D register
</p>
</dd>
<dt><code>W</code></dt>
<dd><p>Odd-numbered D register
</p>
</dd>
<dt><code>e</code></dt>
<dd><p>Accumulator register.
</p>
</dd>
<dt><code>A</code></dt>
<dd><p>Even-numbered accumulator register.
</p>
</dd>
<dt><code>B</code></dt>
<dd><p>Odd-numbered accumulator register.
</p>
</dd>
<dt><code>b</code></dt>
<dd><p>I register
</p>
</dd>
<dt><code>v</code></dt>
<dd><p>B register
</p>
</dd>
<dt><code>f</code></dt>
<dd><p>M register
</p>
</dd>
<dt><code>c</code></dt>
<dd><p>Registers used for circular buffering, i.e. I, B, or L registers.
</p>
</dd>
<dt><code>C</code></dt>
<dd><p>The CC register.
</p>
</dd>
<dt><code>t</code></dt>
<dd><p>LT0 or LT1.
</p>
</dd>
<dt><code>k</code></dt>
<dd><p>LC0 or LC1.
</p>
</dd>
<dt><code>u</code></dt>
<dd><p>LB0 or LB1.
</p>
</dd>
<dt><code>x</code></dt>
<dd><p>Any D, P, B, M, I or L register.
</p>
</dd>
<dt><code>y</code></dt>
<dd><p>Additional registers typically used only in prologues and epilogues: RETS,
d476 31
a506 72
</p>
</dd>
<dt><code>w</code></dt>
<dd><p>Any register except accumulators or CC.
</p>
</dd>
<dt><code>Ksh</code></dt>
<dd><p>Signed 16 bit integer (in the range -32768 to 32767)
</p>
</dd>
<dt><code>Kuh</code></dt>
<dd><p>Unsigned 16 bit integer (in the range 0 to 65535)
</p>
</dd>
<dt><code>Ks7</code></dt>
<dd><p>Signed 7 bit integer (in the range -64 to 63)
</p>
</dd>
<dt><code>Ku7</code></dt>
<dd><p>Unsigned 7 bit integer (in the range 0 to 127)
</p>
</dd>
<dt><code>Ku5</code></dt>
<dd><p>Unsigned 5 bit integer (in the range 0 to 31)
</p>
</dd>
<dt><code>Ks4</code></dt>
<dd><p>Signed 4 bit integer (in the range -8 to 7)
</p>
</dd>
<dt><code>Ks3</code></dt>
<dd><p>Signed 3 bit integer (in the range -3 to 4)
</p>
</dd>
<dt><code>Ku3</code></dt>
<dd><p>Unsigned 3 bit integer (in the range 0 to 7)
</p>
</dd>
<dt><code>P<var>n</var></code></dt>
<dd><p>Constant <var>n</var>, where <var>n</var> is a single-digit constant in the range 0 to 4.
</p>
</dd>
<dt><code>PA</code></dt>
<dd><p>An integer equal to one of the MACFLAG_XXX constants that is suitable for
use with either accumulator.
</p>
</dd>
<dt><code>PB</code></dt>
<dd><p>An integer equal to one of the MACFLAG_XXX constants that is suitable for
use only with accumulator A1.
</p>
</dd>
<dt><code>M1</code></dt>
<dd><p>Constant 255.
</p>
</dd>
<dt><code>M2</code></dt>
<dd><p>Constant 65535.
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>An integer constant with exactly a single bit set.
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>An integer constant with all bits set except exactly one.
</p>
</dd>
<dt><code>H</code></dt>
<dt><code>Q</code></dt>
<dd><p>Any SYMBOL_REF.
</p></dd>
d509 4
a512 11
</dd>
<dt><em>M32C&mdash;<samp>config/m32c/m32c.c</samp></em></dt>
<dd><dl compact="compact">
<dt><code>Rsp</code></dt>
<dt><code>Rfb</code></dt>
<dt><code>Rsb</code></dt>
<dd><p>&lsquo;<samp>$sp</samp>&rsquo;, &lsquo;<samp>$fb</samp>&rsquo;, &lsquo;<samp>$sb</samp>&rsquo;.
</p>
</dd>
<dt><code>Rcr</code></dt>
<dd><p>Any control register, when they&rsquo;re 16 bits wide (nothing if control
d514 30
a543 63
</p>
</dd>
<dt><code>Rcl</code></dt>
<dd><p>Any control register, when they&rsquo;re 24 bits wide.
</p>
</dd>
<dt><code>R0w</code></dt>
<dt><code>R1w</code></dt>
<dt><code>R2w</code></dt>
<dt><code>R3w</code></dt>
<dd><p>$r0, $r1, $r2, $r3.
</p>
</dd>
<dt><code>R02</code></dt>
<dd><p>$r0 or $r2, or $r2r0 for 32 bit values.
</p>
</dd>
<dt><code>R13</code></dt>
<dd><p>$r1 or $r3, or $r3r1 for 32 bit values.
</p>
</dd>
<dt><code>Rdi</code></dt>
<dd><p>A register that can hold a 64 bit value.
</p>
</dd>
<dt><code>Rhl</code></dt>
<dd><p>$r0 or $r1 (registers with addressable high/low bytes)
</p>
</dd>
<dt><code>R23</code></dt>
<dd><p>$r2 or $r3
</p>
</dd>
<dt><code>Raa</code></dt>
<dd><p>Address registers
</p>
</dd>
<dt><code>Raw</code></dt>
<dd><p>Address registers when they&rsquo;re 16 bits wide.
</p>
</dd>
<dt><code>Ral</code></dt>
<dd><p>Address registers when they&rsquo;re 24 bits wide.
</p>
</dd>
<dt><code>Rqi</code></dt>
<dd><p>Registers that can hold QI values.
</p>
</dd>
<dt><code>Rad</code></dt>
<dd><p>Registers that can be used with displacements ($a0, $a1, $sb).
</p>
</dd>
<dt><code>Rsi</code></dt>
<dd><p>Registers that can hold 32 bit values.
</p>
</dd>
<dt><code>Rhi</code></dt>
<dd><p>Registers that can hold 16 bit values.
</p>
</dd>
<dt><code>Rhc</code></dt>
<dd><p>Registers chat can hold 16 bit values, including all control
d545 8
a552 16
</p>
</dd>
<dt><code>Rra</code></dt>
<dd><p>$r0 through R1, plus $a0 and $a1.
</p>
</dd>
<dt><code>Rfl</code></dt>
<dd><p>The flags register.
</p>
</dd>
<dt><code>Rmm</code></dt>
<dd><p>The memory-based pseudo-registers $mem0 through $mem15.
</p>
</dd>
<dt><code>Rpi</code></dt>
<dd><p>Registers that can hold pointers (16 bit registers for r8c, m16c; 24
d554 2
a555 4
</p>
</dd>
<dt><code>Rpa</code></dt>
<dd><p>Matches multiple registers in a PARALLEL to form a larger register.
d557 78
a634 69
</p>
</dd>
<dt><code>Is3</code></dt>
<dd><p>-8 &hellip; 7
</p>
</dd>
<dt><code>IS1</code></dt>
<dd><p>-128 &hellip; 127
</p>
</dd>
<dt><code>IS2</code></dt>
<dd><p>-32768 &hellip; 32767
</p>
</dd>
<dt><code>IU2</code></dt>
<dd><p>0 &hellip; 65535
</p>
</dd>
<dt><code>In4</code></dt>
<dd><p>-8 &hellip; -1 or 1 &hellip; 8
</p>
</dd>
<dt><code>In5</code></dt>
<dd><p>-16 &hellip; -1 or 1 &hellip; 16
</p>
</dd>
<dt><code>In6</code></dt>
<dd><p>-32 &hellip; -1 or 1 &hellip; 32
</p>
</dd>
<dt><code>IM2</code></dt>
<dd><p>-65536 &hellip; -1
</p>
</dd>
<dt><code>Ilb</code></dt>
<dd><p>An 8 bit value with exactly one bit set.
</p>
</dd>
<dt><code>Ilw</code></dt>
<dd><p>A 16 bit value with exactly one bit set.
</p>
</dd>
<dt><code>Sd</code></dt>
<dd><p>The common src/dest memory addressing modes.
</p>
</dd>
<dt><code>Sa</code></dt>
<dd><p>Memory addressed using $a0 or $a1.
</p>
</dd>
<dt><code>Si</code></dt>
<dd><p>Memory addressed with immediate addresses.
</p>
</dd>
<dt><code>Ss</code></dt>
<dd><p>Memory addressed using the stack pointer ($sp).
</p>
</dd>
<dt><code>Sf</code></dt>
<dd><p>Memory addressed using the frame base register ($fb).
</p>
</dd>
<dt><code>Ss</code></dt>
<dd><p>Memory addressed using the small base register ($sb).
</p>
</dd>
<dt><code>S1</code></dt>
<dd><p>$r1h
</p></dd>
d637 19
a655 131
</dd>
<dt><em>MeP&mdash;<samp>config/mep/constraints.md</samp></em></dt>
<dd><dl compact="compact">
<dt><code>a</code></dt>
<dd><p>The $sp register.
</p>
</dd>
<dt><code>b</code></dt>
<dd><p>The $tp register.
</p>
</dd>
<dt><code>c</code></dt>
<dd><p>Any control register.
</p>
</dd>
<dt><code>d</code></dt>
<dd><p>Either the $hi or the $lo register.
</p>
</dd>
<dt><code>em</code></dt>
<dd><p>Coprocessor registers that can be directly loaded ($c0-$c15).
</p>
</dd>
<dt><code>ex</code></dt>
<dd><p>Coprocessor registers that can be moved to each other.
</p>
</dd>
<dt><code>er</code></dt>
<dd><p>Coprocessor registers that can be moved to core registers.
</p>
</dd>
<dt><code>h</code></dt>
<dd><p>The $hi register.
</p>
</dd>
<dt><code>j</code></dt>
<dd><p>The $rpc register.
</p>
</dd>
<dt><code>l</code></dt>
<dd><p>The $lo register.
</p>
</dd>
<dt><code>t</code></dt>
<dd><p>Registers which can be used in $tp-relative addressing.
</p>
</dd>
<dt><code>v</code></dt>
<dd><p>The $gp register.
</p>
</dd>
<dt><code>x</code></dt>
<dd><p>The coprocessor registers.
</p>
</dd>
<dt><code>y</code></dt>
<dd><p>The coprocessor control registers.
</p>
</dd>
<dt><code>z</code></dt>
<dd><p>The $0 register.
</p>
</dd>
<dt><code>A</code></dt>
<dd><p>User-defined register set A.
</p>
</dd>
<dt><code>B</code></dt>
<dd><p>User-defined register set B.
</p>
</dd>
<dt><code>C</code></dt>
<dd><p>User-defined register set C.
</p>
</dd>
<dt><code>D</code></dt>
<dd><p>User-defined register set D.
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>Offsets for $gp-rel addressing.
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>Constants that can be used directly with boolean insns.
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>Constants that can be moved directly to registers.
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>Small constants that can be added to registers.
</p>
</dd>
<dt><code>M</code></dt>
<dd><p>Long shift counts.
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>Small constants that can be compared to registers.
</p>
</dd>
<dt><code>O</code></dt>
<dd><p>Constants that can be loaded into the top half of registers.
</p>
</dd>
<dt><code>S</code></dt>
<dd><p>Signed 8-bit immediates.
</p>
</dd>
<dt><code>T</code></dt>
<dd><p>Symbols encoded for $tp-rel or $gp-rel addressing.
</p>
</dd>
<dt><code>U</code></dt>
<dd><p>Non-constant addresses for loading/saving coprocessor registers.
</p>
</dd>
<dt><code>W</code></dt>
<dd><p>The top half of a symbol&rsquo;s value.
</p>
</dd>
<dt><code>Y</code></dt>
<dd><p>A register indirect address without offset.
</p>
</dd>
<dt><code>Z</code></dt>
<dd><p>Symbolic references to the control bus.
</p>
</dd>
d658 27
a684 12
</dd>
<dt><em>MicroBlaze&mdash;<samp>config/microblaze/constraints.md</samp></em></dt>
<dd><dl compact="compact">
<dt><code>d</code></dt>
<dd><p>A general register (<code>r0</code> to <code>r31</code>).
</p>
</dd>
<dt><code>z</code></dt>
<dd><p>A status register (<code>rmsr</code>, <code>$fcc1</code> to <code>$fcc7</code>).
</p>
</dd>
</dl>
d686 1
a686 86
</dd>
<dt><em>MIPS&mdash;<samp>config/mips/constraints.md</samp></em></dt>
<dd><dl compact="compact">
<dt><code>d</code></dt>
<dd><p>An address register.  This is equivalent to <code>r</code> unless
generating MIPS16 code.
</p>
</dd>
<dt><code>f</code></dt>
<dd><p>A floating-point register (if available).
</p>
</dd>
<dt><code>h</code></dt>
<dd><p>Formerly the <code>hi</code> register.  This constraint is no longer supported.
</p>
</dd>
<dt><code>l</code></dt>
<dd><p>The <code>lo</code> register.  Use this register to store values that are
no bigger than a word.
</p>
</dd>
<dt><code>x</code></dt>
<dd><p>The concatenated <code>hi</code> and <code>lo</code> registers.  Use this register
to store doubleword values.
</p>
</dd>
<dt><code>c</code></dt>
<dd><p>A register suitable for use in an indirect jump.  This will always be
<code>$25</code> for <samp>-mabicalls</samp>.
</p>
</dd>
<dt><code>v</code></dt>
<dd><p>Register <code>$3</code>.  Do not use this constraint in new code;
it is retained only for compatibility with glibc.
</p>
</dd>
<dt><code>y</code></dt>
<dd><p>Equivalent to <code>r</code>; retained for backwards compatibility.
</p>
</dd>
<dt><code>z</code></dt>
<dd><p>A floating-point condition code register.
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>A signed 16-bit constant (for arithmetic instructions).
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>Integer zero.
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>An unsigned 16-bit constant (for logic instructions).
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>A signed 32-bit constant in which the lower 16 bits are zero.
Such constants can be loaded using <code>lui</code>.
</p>
</dd>
<dt><code>M</code></dt>
<dd><p>A constant that cannot be loaded using <code>lui</code>, <code>addiu</code>
or <code>ori</code>.
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>A constant in the range -65535 to -1 (inclusive).
</p>
</dd>
<dt><code>O</code></dt>
<dd><p>A signed 15-bit constant.
</p>
</dd>
<dt><code>P</code></dt>
<dd><p>A constant in the range 1 to 65535 (inclusive).
</p>
</dd>
<dt><code>G</code></dt>
<dd><p>Floating-point zero.
</p>
</dd>
<dt><code>R</code></dt>
<dd><p>An address that can be used in a non-macro load or store.
</p></dd>
</dl>
d688 1
a688 116
</dd>
<dt><em>Motorola 680x0&mdash;<samp>config/m68k/constraints.md</samp></em></dt>
<dd><dl compact="compact">
<dt><code>a</code></dt>
<dd><p>Address register
</p>
</dd>
<dt><code>d</code></dt>
<dd><p>Data register
</p>
</dd>
<dt><code>f</code></dt>
<dd><p>68881 floating-point register, if available
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>Integer in the range 1 to 8
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>16-bit signed number
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>Signed number whose magnitude is greater than 0x80
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>Integer in the range -8 to -1
</p>
</dd>
<dt><code>M</code></dt>
<dd><p>Signed number whose magnitude is greater than 0x100
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>Range 24 to 31, rotatert:SI 8 to 1 expressed as rotate
</p>
</dd>
<dt><code>O</code></dt>
<dd><p>16 (for rotate using swap)
</p>
</dd>
<dt><code>P</code></dt>
<dd><p>Range 8 to 15, rotatert:HI 8 to 1 expressed as rotate
</p>
</dd>
<dt><code>R</code></dt>
<dd><p>Numbers that mov3q can handle
</p>
</dd>
<dt><code>G</code></dt>
<dd><p>Floating point constant that is not a 68881 constant
</p>
</dd>
<dt><code>S</code></dt>
<dd><p>Operands that satisfy &rsquo;m&rsquo; when -mpcrel is in effect
</p>
</dd>
<dt><code>T</code></dt>
<dd><p>Operands that satisfy &rsquo;s&rsquo; when -mpcrel is not in effect
</p>
</dd>
<dt><code>Q</code></dt>
<dd><p>Address register indirect addressing mode
</p>
</dd>
<dt><code>U</code></dt>
<dd><p>Register offset addressing
</p>
</dd>
<dt><code>W</code></dt>
<dd><p>const_call_operand
</p>
</dd>
<dt><code>Cs</code></dt>
<dd><p>symbol_ref or const
</p>
</dd>
<dt><code>Ci</code></dt>
<dd><p>const_int
</p>
</dd>
<dt><code>C0</code></dt>
<dd><p>const_int 0
</p>
</dd>
<dt><code>Cj</code></dt>
<dd><p>Range of signed numbers that don&rsquo;t fit in 16 bits
</p>
</dd>
<dt><code>Cmvq</code></dt>
<dd><p>Integers valid for mvq
</p>
</dd>
<dt><code>Capsw</code></dt>
<dd><p>Integers valid for a moveq followed by a swap
</p>
</dd>
<dt><code>Cmvz</code></dt>
<dd><p>Integers valid for mvz
</p>
</dd>
<dt><code>Cmvs</code></dt>
<dd><p>Integers valid for mvs
</p>
</dd>
<dt><code>Ap</code></dt>
<dd><p>push_operand
</p>
</dd>
<dt><code>Ac</code></dt>
<dd><p>Non-register operands allowed in clr
</p>
</dd>
</dl>
d690 1
a690 24
</dd>
<dt><em>Moxie&mdash;<samp>config/moxie/constraints.md</samp></em></dt>
<dd><dl compact="compact">
<dt><code>A</code></dt>
<dd><p>An absolute address
</p>
</dd>
<dt><code>B</code></dt>
<dd><p>An offset address
</p>
</dd>
<dt><code>W</code></dt>
<dd><p>A register indirect memory operand
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>A constant in the range of 0 to 255.
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>A constant in the range of 0 to -255.
</p>
</dd>
</dl>
d692 1
a692 62
</dd>
<dt><em>PDP-11&mdash;<samp>config/pdp11/constraints.md</samp></em></dt>
<dd><dl compact="compact">
<dt><code>a</code></dt>
<dd><p>Floating point registers AC0 through AC3.  These can be loaded from/to
memory with a single instruction.
</p>
</dd>
<dt><code>d</code></dt>
<dd><p>Odd numbered general registers (R1, R3, R5).  These are used for
16-bit multiply operations.
</p>
</dd>
<dt><code>f</code></dt>
<dd><p>Any of the floating point registers (AC0 through AC5).
</p>
</dd>
<dt><code>G</code></dt>
<dd><p>Floating point constant 0.
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>An integer constant that fits in 16 bits.
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>An integer constant whose low order 16 bits are zero.
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>An integer constant that does not meet the constraints for codes
&lsquo;<samp>I</samp>&rsquo; or &lsquo;<samp>J</samp>&rsquo;.
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>The integer constant 1.
</p>
</dd>
<dt><code>M</code></dt>
<dd><p>The integer constant -1.
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>The integer constant 0.
</p>
</dd>
<dt><code>O</code></dt>
<dd><p>Integer constants -4 through -1 and 1 through 4; shifts by these
amounts are handled as multiple single-bit shifts rather than a single
variable-length shift.
</p>
</dd>
<dt><code>Q</code></dt>
<dd><p>A memory reference which requires an additional word (address or
offset) after the opcode.
</p>
</dd>
<dt><code>R</code></dt>
<dd><p>A memory reference that is encoded within the opcode.
</p>
</dd>
</dl>
d694 1
a694 131
</dd>
<dt><em>RL78&mdash;<samp>config/rl78/constraints.md</samp></em></dt>
<dd><dl compact="compact">
<dt><code>Int3</code></dt>
<dd><p>An integer constant in the range 1 &hellip; 7.
</p></dd>
<dt><code>Int8</code></dt>
<dd><p>An integer constant in the range 0 &hellip; 255.
</p></dd>
<dt><code>J</code></dt>
<dd><p>An integer constant in the range -255 &hellip; 0
</p></dd>
<dt><code>K</code></dt>
<dd><p>The integer constant 1.
</p></dd>
<dt><code>L</code></dt>
<dd><p>The integer constant -1.
</p></dd>
<dt><code>M</code></dt>
<dd><p>The integer constant 0.
</p></dd>
<dt><code>N</code></dt>
<dd><p>The integer constant 2.
</p></dd>
<dt><code>O</code></dt>
<dd><p>The integer constant -2.
</p></dd>
<dt><code>P</code></dt>
<dd><p>An integer constant in the range 1 &hellip; 15.
</p></dd>
<dt><code>Qbi</code></dt>
<dd><p>The built-in compare types&ndash;eq, ne, gtu, ltu, geu, and leu.
</p></dd>
<dt><code>Qsc</code></dt>
<dd><p>The synthetic compare types&ndash;gt, lt, ge, and le.
</p></dd>
<dt><code>Wab</code></dt>
<dd><p>A memory reference with an absolute address.
</p></dd>
<dt><code>Wbc</code></dt>
<dd><p>A memory reference using <code>BC</code> as a base register, with an optional offset.
</p></dd>
<dt><code>Wca</code></dt>
<dd><p>A memory reference using <code>AX</code>, <code>BC</code>, <code>DE</code>, or <code>HL</code> for the address, for calls.
</p></dd>
<dt><code>Wcv</code></dt>
<dd><p>A memory reference using any 16-bit register pair for the address, for calls.
</p></dd>
<dt><code>Wd2</code></dt>
<dd><p>A memory reference using <code>DE</code> as a base register, with an optional offset.
</p></dd>
<dt><code>Wde</code></dt>
<dd><p>A memory reference using <code>DE</code> as a base register, without any offset.
</p></dd>
<dt><code>Wfr</code></dt>
<dd><p>Any memory reference to an address in the far address space.
</p></dd>
<dt><code>Wh1</code></dt>
<dd><p>A memory reference using <code>HL</code> as a base register, with an optional one-byte offset.
</p></dd>
<dt><code>Whb</code></dt>
<dd><p>A memory reference using <code>HL</code> as a base register, with <code>B</code> or <code>C</code> as the index register.
</p></dd>
<dt><code>Whl</code></dt>
<dd><p>A memory reference using <code>HL</code> as a base register, without any offset.
</p></dd>
<dt><code>Ws1</code></dt>
<dd><p>A memory reference using <code>SP</code> as a base register, with an optional one-byte offset.
</p></dd>
<dt><code>Y</code></dt>
<dd><p>Any memory reference to an address in the near address space.
</p></dd>
<dt><code>A</code></dt>
<dd><p>The <code>AX</code> register.
</p></dd>
<dt><code>B</code></dt>
<dd><p>The <code>BC</code> register.
</p></dd>
<dt><code>D</code></dt>
<dd><p>The <code>DE</code> register.
</p></dd>
<dt><code>R</code></dt>
<dd><p><code>A</code> through <code>L</code> registers.
</p></dd>
<dt><code>S</code></dt>
<dd><p>The <code>SP</code> register.
</p></dd>
<dt><code>T</code></dt>
<dd><p>The <code>HL</code> register.
</p></dd>
<dt><code>Z08W</code></dt>
<dd><p>The 16-bit <code>R8</code> register.
</p></dd>
<dt><code>Z10W</code></dt>
<dd><p>The 16-bit <code>R10</code> register.
</p></dd>
<dt><code>Zint</code></dt>
<dd><p>The registers reserved for interrupts (<code>R24</code> to <code>R31</code>).
</p></dd>
<dt><code>a</code></dt>
<dd><p>The <code>A</code> register.
</p></dd>
<dt><code>b</code></dt>
<dd><p>The <code>B</code> register.
</p></dd>
<dt><code>c</code></dt>
<dd><p>The <code>C</code> register.
</p></dd>
<dt><code>d</code></dt>
<dd><p>The <code>D</code> register.
</p></dd>
<dt><code>e</code></dt>
<dd><p>The <code>E</code> register.
</p></dd>
<dt><code>h</code></dt>
<dd><p>The <code>H</code> register.
</p></dd>
<dt><code>l</code></dt>
<dd><p>The <code>L</code> register.
</p></dd>
<dt><code>v</code></dt>
<dd><p>The virtual registers.
</p></dd>
<dt><code>w</code></dt>
<dd><p>The <code>PSW</code> register.
</p></dd>
<dt><code>x</code></dt>
<dd><p>The <code>X</code> register.
</p>
</dd>
</dl>
d696 1
a696 33
</dd>
<dt><em>RX&mdash;<samp>config/rx/constraints.md</samp></em></dt>
<dd><dl compact="compact">
<dt><code>Q</code></dt>
<dd><p>An address which does not involve register indirect addressing or
pre/post increment/decrement addressing.
</p>
</dd>
<dt><code>Symbol</code></dt>
<dd><p>A symbol reference.
</p>
</dd>
<dt><code>Int08</code></dt>
<dd><p>A constant in the range -256 to 255, inclusive.
</p>
</dd>
<dt><code>Sint08</code></dt>
<dd><p>A constant in the range -128 to 127, inclusive.
</p>
</dd>
<dt><code>Sint16</code></dt>
<dd><p>A constant in the range -32768 to 32767, inclusive.
</p>
</dd>
<dt><code>Sint24</code></dt>
<dd><p>A constant in the range -8388608 to 8388607, inclusive.
</p>
</dd>
<dt><code>Uint04</code></dt>
<dd><p>A constant in the range 0 to 15, inclusive.
</p>
</dd>
</dl>
d698 3
a700 5
</dd>
<dt><em>SPARC&mdash;<samp>config/sparc/sparc.h</samp></em></dt>
<dd><dl compact="compact">
<dt><code>f</code></dt>
<dd><p>Floating-point register on the SPARC-V8 architecture and
d702 2
a703 4
</p>
</dd>
<dt><code>e</code></dt>
<dd><p>Floating-point register.  It is equivalent to &lsquo;<samp>f</samp>&rsquo; on the
d706 4
a709 8
</p>
</dd>
<dt><code>c</code></dt>
<dd><p>Floating-point condition code register.
</p>
</dd>
<dt><code>d</code></dt>
<dd><p>Lower floating-point register.  It is only valid on the SPARC-V9
d711 2
a712 4
</p>
</dd>
<dt><code>b</code></dt>
<dd><p>Floating-point register.  It is only valid on the SPARC-V9 architecture
d714 8
a721 20
</p>
</dd>
<dt><code>h</code></dt>
<dd><p>64-bit global or out register for the SPARC-V8+ architecture.
</p>
</dd>
<dt><code>D</code></dt>
<dd><p>A vector constant
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>Signed 13-bit constant
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>Zero
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>32-bit constant with the low 12 bits clear (a constant that can be
d723 7
a729 13
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>A constant in the range supported by <code>movcc</code> instructions
</p>
</dd>
<dt><code>M</code></dt>
<dd><p>A constant in the range supported by <code>movrcc</code> instructions
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>Same as &lsquo;<samp>K</samp>&rsquo;, except that it verifies that bits that are not in the
lower 32-bit range are all zero.  Must be used instead of &lsquo;<samp>K</samp>&rsquo; for
d731 8
a738 16
</p>
</dd>
<dt><code>O</code></dt>
<dd><p>The constant 4096
</p>
</dd>
<dt><code>G</code></dt>
<dd><p>Floating-point zero
</p>
</dd>
<dt><code>H</code></dt>
<dd><p>Signed 13-bit constant, sign-extended to 32 or 64 bits
</p>
</dd>
<dt><code>Q</code></dt>
<dd><p>Floating-point constant whose integral representation can
d741 2
a742 4
</p>
</dd>
<dt><code>R</code></dt>
<dd><p>Floating-point constant whose integral representation can
d745 2
a746 4
</p>
</dd>
<dt><code>S</code></dt>
<dd><p>Floating-point constant whose integral representation can
d749 87
a835 18
</p>
</dd>
<dt><code>T</code></dt>
<dd><p>Memory address aligned to an 8-byte boundary
</p>
</dd>
<dt><code>U</code></dt>
<dd><p>Even register
</p>
</dd>
<dt><code>W</code></dt>
<dd><p>Memory address for &lsquo;<samp>e</samp>&rsquo; constraint registers
</p>
</dd>
<dt><code>Y</code></dt>
<dd><p>Vector zero
</p>
</dd>
d838 8
a845 91
</dd>
<dt><em>SPU&mdash;<samp>config/spu/spu.h</samp></em></dt>
<dd><dl compact="compact">
<dt><code>a</code></dt>
<dd><p>An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is treated as a 64 bit value.
</p>
</dd>
<dt><code>c</code></dt>
<dd><p>An immediate for and/xor/or instructions.  const_int is treated as a 64 bit value.
</p>
</dd>
<dt><code>d</code></dt>
<dd><p>An immediate for the <code>iohl</code> instruction.  const_int is treated as a 64 bit value.
</p>
</dd>
<dt><code>f</code></dt>
<dd><p>An immediate which can be loaded with <code>fsmbi</code>.
</p>
</dd>
<dt><code>A</code></dt>
<dd><p>An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is treated as a 32 bit value.
</p>
</dd>
<dt><code>B</code></dt>
<dd><p>An immediate for most arithmetic instructions.  const_int is treated as a 32 bit value.
</p>
</dd>
<dt><code>C</code></dt>
<dd><p>An immediate for and/xor/or instructions.  const_int is treated as a 32 bit value.
</p>
</dd>
<dt><code>D</code></dt>
<dd><p>An immediate for the <code>iohl</code> instruction.  const_int is treated as a 32 bit value.
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>A constant in the range [-64, 63] for shift/rotate instructions.
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>An unsigned 7-bit constant for conversion/nop/channel instructions.
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>A signed 10-bit constant for most arithmetic instructions.
</p>
</dd>
<dt><code>M</code></dt>
<dd><p>A signed 16 bit immediate for <code>stop</code>.
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>An unsigned 16-bit constant for <code>iohl</code> and <code>fsmbi</code>.
</p>
</dd>
<dt><code>O</code></dt>
<dd><p>An unsigned 7-bit constant whose 3 least significant bits are 0.
</p>
</dd>
<dt><code>P</code></dt>
<dd><p>An unsigned 3-bit constant for 16-byte rotates and shifts
</p>
</dd>
<dt><code>R</code></dt>
<dd><p>Call operand, reg, for indirect calls
</p>
</dd>
<dt><code>S</code></dt>
<dd><p>Call operand, symbol, for relative calls.
</p>
</dd>
<dt><code>T</code></dt>
<dd><p>Call operand, const_int, for absolute calls.
</p>
</dd>
<dt><code>U</code></dt>
<dd><p>An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is sign extended to 128 bit.
</p>
</dd>
<dt><code>W</code></dt>
<dd><p>An immediate for shift and rotate instructions.  const_int is treated as a 32 bit value.
</p>
</dd>
<dt><code>Y</code></dt>
<dd><p>An immediate for and/xor/or instructions.  const_int is sign extended as a 128 bit.
</p>
</dd>
<dt><code>Z</code></dt>
<dd><p>An immediate for the <code>iohl</code> instruction.  const_int is sign extended to 128 bit.
</p>
</dd>
d847 38
d886 21
a906 41
</dd>
<dt><em>S/390 and zSeries&mdash;<samp>config/s390/s390.h</samp></em></dt>
<dd><dl compact="compact">
<dt><code>a</code></dt>
<dd><p>Address register (general purpose register except r0)
</p>
</dd>
<dt><code>c</code></dt>
<dd><p>Condition code register
</p>
</dd>
<dt><code>d</code></dt>
<dd><p>Data register (arbitrary general purpose register)
</p>
</dd>
<dt><code>f</code></dt>
<dd><p>Floating-point register
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>Unsigned 8-bit constant (0&ndash;255)
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>Unsigned 12-bit constant (0&ndash;4095)
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>Signed 16-bit constant (-32768&ndash;32767)
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>Value appropriate as displacement.
</p><dl compact="compact">
<dt><code>(0..4095)</code></dt>
<dd><p>for short displacement
</p></dd>
<dt><code>(-524288..524287)</code></dt>
<dd><p>for long displacement
</p></dd>
</dl>
d908 1
a908 54
</dd>
<dt><code>M</code></dt>
<dd><p>Constant integer with a value of 0x7fffffff.
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>Multiple letter constraint followed by 4 parameter letters.
</p><dl compact="compact">
<dt><code>0..9:</code></dt>
<dd><p>number of the part counting from most to least significant
</p></dd>
<dt><code>H,Q:</code></dt>
<dd><p>mode of the part
</p></dd>
<dt><code>D,S,H:</code></dt>
<dd><p>mode of the containing operand
</p></dd>
<dt><code>0,F:</code></dt>
<dd><p>value of the other parts (F&mdash;all bits set)
</p></dd>
</dl>
<p>The constraint matches if the specified part of a constant
has a value different from its other parts.
</p>
</dd>
<dt><code>Q</code></dt>
<dd><p>Memory reference without index register and with short displacement.
</p>
</dd>
<dt><code>R</code></dt>
<dd><p>Memory reference with index register and short displacement.
</p>
</dd>
<dt><code>S</code></dt>
<dd><p>Memory reference without index register but with long displacement.
</p>
</dd>
<dt><code>T</code></dt>
<dd><p>Memory reference with index register and long displacement.
</p>
</dd>
<dt><code>U</code></dt>
<dd><p>Pointer with short displacement.
</p>
</dd>
<dt><code>W</code></dt>
<dd><p>Pointer with long displacement.
</p>
</dd>
<dt><code>Y</code></dt>
<dd><p>Shift count operand.
</p>
</dd>
</dl>
d910 1
a910 91
</dd>
<dt><em>Score family&mdash;<samp>config/score/score.h</samp></em></dt>
<dd><dl compact="compact">
<dt><code>d</code></dt>
<dd><p>Registers from r0 to r32.
</p>
</dd>
<dt><code>e</code></dt>
<dd><p>Registers from r0 to r16.
</p>
</dd>
<dt><code>t</code></dt>
<dd><p>r8&mdash;r11 or r22&mdash;r27 registers.
</p>
</dd>
<dt><code>h</code></dt>
<dd><p>hi register.
</p>
</dd>
<dt><code>l</code></dt>
<dd><p>lo register.
</p>
</dd>
<dt><code>x</code></dt>
<dd><p>hi + lo register.
</p>
</dd>
<dt><code>q</code></dt>
<dd><p>cnt register.
</p>
</dd>
<dt><code>y</code></dt>
<dd><p>lcb register.
</p>
</dd>
<dt><code>z</code></dt>
<dd><p>scb register.
</p>
</dd>
<dt><code>a</code></dt>
<dd><p>cnt + lcb + scb register.
</p>
</dd>
<dt><code>c</code></dt>
<dd><p>cr0&mdash;cr15 register.
</p>
</dd>
<dt><code>b</code></dt>
<dd><p>cp1 registers.
</p>
</dd>
<dt><code>f</code></dt>
<dd><p>cp2 registers.
</p>
</dd>
<dt><code>i</code></dt>
<dd><p>cp3 registers.
</p>
</dd>
<dt><code>j</code></dt>
<dd><p>cp1 + cp2 + cp3 registers.
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>High 16-bit constant (32-bit constant with 16 LSBs zero).
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>Unsigned 5 bit integer (in the range 0 to 31).
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>Unsigned 16 bit integer (in the range 0 to 65535).
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>Signed 16 bit integer (in the range -32768 to 32767).
</p>
</dd>
<dt><code>M</code></dt>
<dd><p>Unsigned 14 bit integer (in the range 0 to 16383).
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>Signed 14 bit integer (in the range -8192 to 8191).
</p>
</dd>
<dt><code>Z</code></dt>
<dd><p>Any SYMBOL_REF.
</p></dd>
</dl>
d912 1
a912 92
</dd>
<dt><em>Xstormy16&mdash;<samp>config/stormy16/stormy16.h</samp></em></dt>
<dd><dl compact="compact">
<dt><code>a</code></dt>
<dd><p>Register r0.
</p>
</dd>
<dt><code>b</code></dt>
<dd><p>Register r1.
</p>
</dd>
<dt><code>c</code></dt>
<dd><p>Register r2.
</p>
</dd>
<dt><code>d</code></dt>
<dd><p>Register r8.
</p>
</dd>
<dt><code>e</code></dt>
<dd><p>Registers r0 through r7.
</p>
</dd>
<dt><code>t</code></dt>
<dd><p>Registers r0 and r1.
</p>
</dd>
<dt><code>y</code></dt>
<dd><p>The carry register.
</p>
</dd>
<dt><code>z</code></dt>
<dd><p>Registers r8 and r9.
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>A constant between 0 and 3 inclusive.
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>A constant that has exactly one bit set.
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>A constant that has exactly one bit clear.
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>A constant between 0 and 255 inclusive.
</p>
</dd>
<dt><code>M</code></dt>
<dd><p>A constant between -255 and 0 inclusive.
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>A constant between -3 and 0 inclusive.
</p>
</dd>
<dt><code>O</code></dt>
<dd><p>A constant between 1 and 4 inclusive.
</p>
</dd>
<dt><code>P</code></dt>
<dd><p>A constant between -4 and -1 inclusive.
</p>
</dd>
<dt><code>Q</code></dt>
<dd><p>A memory reference that is a stack push.
</p>
</dd>
<dt><code>R</code></dt>
<dd><p>A memory reference that is a stack pop.
</p>
</dd>
<dt><code>S</code></dt>
<dd><p>A memory reference that refers to a constant address of known value.
</p>
</dd>
<dt><code>T</code></dt>
<dd><p>The register indicated by Rx (not implemented yet).
</p>
</dd>
<dt><code>U</code></dt>
<dd><p>A constant that is not between 2 and 15 inclusive.
</p>
</dd>
<dt><code>Z</code></dt>
<dd><p>The constant 0.
</p>
</dd>
</dl>
d914 3
a916 86
</dd>
<dt><em>TI C6X family&mdash;<samp>config/c6x/constraints.md</samp></em></dt>
<dd><dl compact="compact">
<dt><code>a</code></dt>
<dd><p>Register file A (A0&ndash;A31).
</p>
</dd>
<dt><code>b</code></dt>
<dd><p>Register file B (B0&ndash;B31).
</p>
</dd>
<dt><code>A</code></dt>
<dd><p>Predicate registers in register file A (A0&ndash;A2 on C64X and
higher, A1 and A2 otherwise).
</p>
</dd>
<dt><code>B</code></dt>
<dd><p>Predicate registers in register file B (B0&ndash;B2).
</p>
</dd>
<dt><code>C</code></dt>
<dd><p>A call-used register in register file B (B0&ndash;B9, B16&ndash;B31).
</p>
</dd>
<dt><code>Da</code></dt>
<dd><p>Register file A, excluding predicate registers (A3&ndash;A31,
plus A0 if not C64X or higher).
</p>
</dd>
<dt><code>Db</code></dt>
<dd><p>Register file B, excluding predicate registers (B3&ndash;B31).
</p>
</dd>
<dt><code>Iu4</code></dt>
<dd><p>Integer constant in the range 0 &hellip; 15.
</p>
</dd>
<dt><code>Iu5</code></dt>
<dd><p>Integer constant in the range 0 &hellip; 31.
</p>
</dd>
<dt><code>In5</code></dt>
<dd><p>Integer constant in the range -31 &hellip; 0.
</p>
</dd>
<dt><code>Is5</code></dt>
<dd><p>Integer constant in the range -16 &hellip; 15.
</p>
</dd>
<dt><code>I5x</code></dt>
<dd><p>Integer constant that can be the operand of an ADDA or a SUBA insn.
</p>
</dd>
<dt><code>IuB</code></dt>
<dd><p>Integer constant in the range 0 &hellip; 65535.
</p>
</dd>
<dt><code>IsB</code></dt>
<dd><p>Integer constant in the range -32768 &hellip; 32767.
</p>
</dd>
<dt><code>IsC</code></dt>
<dd><p>Integer constant in the range <em>-2^{20}</em> &hellip; <em>2^{20} - 1</em>.
</p>
</dd>
<dt><code>Jc</code></dt>
<dd><p>Integer constant that is a valid mask for the clr instruction.
</p>
</dd>
<dt><code>Js</code></dt>
<dd><p>Integer constant that is a valid mask for the set instruction.
</p>
</dd>
<dt><code>Q</code></dt>
<dd><p>Memory location with A base register.
</p>
</dd>
<dt><code>R</code></dt>
<dd><p>Memory location with B base register.
</p>
</dd>
<dt><code>Z</code></dt>
<dd><p>Register B14 (aka DP).
</p>
</dd>
</dl>
d918 1
a918 96
</dd>
<dt><em>TILE-Gx&mdash;<samp>config/tilegx/constraints.md</samp></em></dt>
<dd><dl compact="compact">
<dt><code>R00</code></dt>
<dt><code>R01</code></dt>
<dt><code>R02</code></dt>
<dt><code>R03</code></dt>
<dt><code>R04</code></dt>
<dt><code>R05</code></dt>
<dt><code>R06</code></dt>
<dt><code>R07</code></dt>
<dt><code>R08</code></dt>
<dt><code>R09</code></dt>
<dt><code>R10</code></dt>
<dd><p>Each of these represents a register constraint for an individual
register, from r0 to r10.
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>Signed 8-bit integer constant.
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>Signed 16-bit integer constant.
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>Unsigned 16-bit integer constant.
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>Integer constant that fits in one signed byte when incremented by one
(-129 &hellip; 126).
</p>
</dd>
<dt><code>m</code></dt>
<dd><p>Memory operand.  If used together with &lsquo;<samp>&lt;</samp>&rsquo; or &lsquo;<samp>&gt;</samp>&rsquo;, the
operand can have postincrement which requires printing with &lsquo;<samp>%In</samp>&rsquo;
and &lsquo;<samp>%in</samp>&rsquo; on TILE-Gx.  For example:
</p>
<div class="smallexample">
<pre class="smallexample">asm (&quot;st_add %I0,%1,%i0&quot; : &quot;=m&lt;&gt;&quot; (*mem) : &quot;r&quot; (val));
</pre></div>

</dd>
<dt><code>M</code></dt>
<dd><p>A bit mask suitable for the BFINS instruction.
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>Integer constant that is a byte tiled out eight times.
</p>
</dd>
<dt><code>O</code></dt>
<dd><p>The integer zero constant.
</p>
</dd>
<dt><code>P</code></dt>
<dd><p>Integer constant that is a sign-extended byte tiled out as four shorts.
</p>
</dd>
<dt><code>Q</code></dt>
<dd><p>Integer constant that fits in one signed byte when incremented
(-129 &hellip; 126), but excluding -1.
</p>
</dd>
<dt><code>S</code></dt>
<dd><p>Integer constant that has all 1 bits consecutive and starting at bit 0.
</p>
</dd>
<dt><code>T</code></dt>
<dd><p>A 16-bit fragment of a got, tls, or pc-relative reference.
</p>
</dd>
<dt><code>U</code></dt>
<dd><p>Memory operand except postincrement.  This is roughly the same as
&lsquo;<samp>m</samp>&rsquo; when not used together with &lsquo;<samp>&lt;</samp>&rsquo; or &lsquo;<samp>&gt;</samp>&rsquo;.
</p>
</dd>
<dt><code>W</code></dt>
<dd><p>An 8-element vector constant with identical elements.
</p>
</dd>
<dt><code>Y</code></dt>
<dd><p>A 4-element vector constant with identical elements.
</p>
</dd>
<dt><code>Z0</code></dt>
<dd><p>The integer constant 0xffffffff.
</p>
</dd>
<dt><code>Z1</code></dt>
<dd><p>The integer constant 0xffffffff00000000.
</p>
</dd>
</dl>
d920 1
a920 85
</dd>
<dt><em>TILEPro&mdash;<samp>config/tilepro/constraints.md</samp></em></dt>
<dd><dl compact="compact">
<dt><code>R00</code></dt>
<dt><code>R01</code></dt>
<dt><code>R02</code></dt>
<dt><code>R03</code></dt>
<dt><code>R04</code></dt>
<dt><code>R05</code></dt>
<dt><code>R06</code></dt>
<dt><code>R07</code></dt>
<dt><code>R08</code></dt>
<dt><code>R09</code></dt>
<dt><code>R10</code></dt>
<dd><p>Each of these represents a register constraint for an individual
register, from r0 to r10.
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>Signed 8-bit integer constant.
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>Signed 16-bit integer constant.
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>Nonzero integer constant with low 16 bits zero.
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>Integer constant that fits in one signed byte when incremented by one
(-129 &hellip; 126).
</p>
</dd>
<dt><code>m</code></dt>
<dd><p>Memory operand.  If used together with &lsquo;<samp>&lt;</samp>&rsquo; or &lsquo;<samp>&gt;</samp>&rsquo;, the
operand can have postincrement which requires printing with &lsquo;<samp>%In</samp>&rsquo;
and &lsquo;<samp>%in</samp>&rsquo; on TILEPro.  For example:
</p>
<div class="smallexample">
<pre class="smallexample">asm (&quot;swadd %I0,%1,%i0&quot; : &quot;=m&lt;&gt;&quot; (mem) : &quot;r&quot; (val));
</pre></div>

</dd>
<dt><code>M</code></dt>
<dd><p>A bit mask suitable for the MM instruction.
</p>
</dd>
<dt><code>N</code></dt>
<dd><p>Integer constant that is a byte tiled out four times.
</p>
</dd>
<dt><code>O</code></dt>
<dd><p>The integer zero constant.
</p>
</dd>
<dt><code>P</code></dt>
<dd><p>Integer constant that is a sign-extended byte tiled out as two shorts.
</p>
</dd>
<dt><code>Q</code></dt>
<dd><p>Integer constant that fits in one signed byte when incremented
(-129 &hellip; 126), but excluding -1.
</p>
</dd>
<dt><code>T</code></dt>
<dd><p>A symbolic operand, or a 16-bit fragment of a got, tls, or pc-relative
reference.
</p>
</dd>
<dt><code>U</code></dt>
<dd><p>Memory operand except postincrement.  This is roughly the same as
&lsquo;<samp>m</samp>&rsquo; when not used together with &lsquo;<samp>&lt;</samp>&rsquo; or &lsquo;<samp>&gt;</samp>&rsquo;.
</p>
</dd>
<dt><code>W</code></dt>
<dd><p>A 4-element vector constant with identical elements.
</p>
</dd>
<dt><code>Y</code></dt>
<dd><p>A 2-element vector constant with identical elements.
</p>
</dd>
</dl>
d922 1
a922 32
</dd>
<dt><em>Xtensa&mdash;<samp>config/xtensa/constraints.md</samp></em></dt>
<dd><dl compact="compact">
<dt><code>a</code></dt>
<dd><p>General-purpose 32-bit register
</p>
</dd>
<dt><code>b</code></dt>
<dd><p>One-bit boolean register
</p>
</dd>
<dt><code>A</code></dt>
<dd><p>MAC16 40-bit accumulator register
</p>
</dd>
<dt><code>I</code></dt>
<dd><p>Signed 12-bit integer constant, for use in MOVI instructions
</p>
</dd>
<dt><code>J</code></dt>
<dd><p>Signed 8-bit integer constant, for use in ADDI instructions
</p>
</dd>
<dt><code>K</code></dt>
<dd><p>Integer constant valid for BccI instructions
</p>
</dd>
<dt><code>L</code></dt>
<dd><p>Unsigned constant valid for BccUI instructions
</p>
</dd>
</dl>
d924 1
a924 2
</dd>
</dl>
d926 1
d928 1
d930 1
a930 5
<hr>
<div class="header">
<p>
Previous: <a href="Modifiers.html#Modifiers" accesskey="p" rel="prev">Modifiers</a>, Up: <a href="Constraints.html#Constraints" accesskey="u" rel="up">Constraints</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html#Option-Index" title="Index" rel="index">Index</a>]</p>
</div>
d932 1
d934 5
a939 2
</body>
</html>
@


head	1.16;
access;
symbols
	modsqz-3_18:1.16
	modsqz-3_17:1.15
	modsqz-3_16:1.15
	modsqz-3_15:1.14
	modsqz-3_14-2:1.14
	modsqz-3_14:1.13
	modsqz-3_13:1.12
	modsqz-3_12:1.11
	modsqz-3_11:1.10
	modsqz-3_10:1.9
	modsqz-3_09:1.8
	modsqz-3_08:1.7
	modsqz-3_07:1.6
	modsqz-3_06:1.5
	modsqz-3_05:1.4
	modsqz-3_04:1.3
	modsqz-3_03:1.2
	modsqz-3_02:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.16
date	2018.08.19.09.37.11;	author rsprowson;	state Exp;
branches;
next	1.15;
commitid	Z743IK4eJQ26gIOA;

1.15
date	2015.03.26.08.14.01;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	uuUELhPlSEWKI5fy;

1.14
date	2010.05.19.16.09.19;	author bavison;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.02.18.31.46;	author srevill;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.05.16.59.03;	author srevill;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.02.13.51.15;	author sbrodie;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.01.11.03.15;	author sbrodie;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.14.12.24.50;	author sbrodie;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.11.11.51.20;	author srevill;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.17.11.04.48;	author sbrodie;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.05.17.00.08;	author sbrodie;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.20.16.26.32;	author sbrodie;	state Exp;
branches;
next	1.4;

1.4
date	99.11.19.14.27.16;	author sbrodie;	state Exp;
branches;
next	1.3;

1.3
date	99.08.23.14.20.22;	author sbrodie;	state Exp;
branches;
next	1.2;

1.2
date	98.11.11.13.23.54;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	98.11.11.12.39.08;	author sbrodie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.11.12.39.08;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Fix memory leak when incompressable
Don't leak longs and shorts when skipping compression.
Found by cppcheck static analysis.
Added explicit (void)s to sort some compiler warnings.

Version 3.18. Tagged as 'modsqz-3_18'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Title:     modsqz - compression of relocatable modules
 * Authors:   RCC, TMD
 * Copyright: (C) 1987, Acorn Computers Ltd, Cambridge, England.
 * Date:      03-Nov-87
 * LastEdit:  28-Mar-88
              19-Jul-88 just to change the version to 1.00, and date (JSutton)
              21-Jul-88 remove reference to xpand in help text (JRS)
              28-Feb-90 modify for squeezing relocatable modules
              16-Jan-91 add help string to dummy module header (for version number detection)
 */

#define DEBUGGING  0

#include "VersionNum"

#include <assert.h>
#include <limits.h>
#ifdef __STDC__
#  include <string.h>
#  include <stdlib.h>
#else
#  include <strings.h>
#endif
#define  DATE      Module_Date
#include <stdio.h>
#include <time.h>
#include <signal.h>

#define int32 unsigned int
#include "CLX/host.h"
#include "CLX/hash.h"
#include "CLX/err.h"
#include "CLX/wholefls.h"
#include "CLX/bytesex.h"

#ifdef __riscos
#  include "swis.h"
#  ifndef FileType_Module
#    define FileType_Module                          0x00000FFA
#  endif
#endif


/*
 * squeeze takes a RISC OS relocatable module and compresses it for use with
 * RISC OS 2.05 or later.
 *
 * For details of the compression scheme, see doc.squeeze.  Briefly,
 * the image is treated as a sequence of 32-bit words, and each word
 * is encoded in one of four ways, specified by a 4-bit nibble:
 *   zero -> nibble 0
 *   the 7*256 most common word values are encoded with one byte extra as
 *   an index into a table
 *   the 7*256 most common upper-3-byte values are encoded with one byte
 *   extra as index into another table, with the low byte separate
 *   anything else is given in full as 4 bytes.
 *
 * The tables of common values are sorted into ascending order
 * and encoded in a devious way.
 */

#define VSN        Module_MajorVersion
#define BRIEF      "compress a relocatable module"
#define SELF       "modsqz"
#define HASHSIZE   (32*1024)
#define CHUNKSIZE  (32*1024)

static int verbose;
static int debug;
static int force;

static clock_t lastticks;

static int ticks(void)
{ int last;
  last = lastticks; lastticks = clock();
  return((100*(lastticks-last))/CLOCKS_PER_SEC);
}

/*
 * Declarations of nibble values for the encoding.
 */

#define NSHORTS 7
#define NLONGS  (14-NSHORTS)
#define MAXTAB  (7*256)

#define ZERO    0
#define LITERAL 1
#define LONG    2
#define SHORT   (LONG+NLONGS)

/*
 * Data structure declarations.
 */

typedef unsigned int word;

typedef struct datahdr {
    word  startoffset;
    word  initoffset;
    word  dieoffset;
    word  serviceoffset;
    word  titleoffset;
    word  helpoffset;
    word  commandtable;
    word  swichunk;
    word  swihandler;
    word  switable;
    word  swicode;
    word  intlmsgs;
    word  flagsoffset;
    char  titlestring [1];
} datahdr;

static const struct datahdr fred;

#define DATAWORDS ((word *)(fred.titlestring)-(word *)&fred)
#define DATABYTES (DATAWORDS * 4)
/* TITHELPWORDS is a reasonable number of words to allocate for the title
 * and help strings of the module
 */
#define TITHELPWORDS 128
#define TITHELPBYTES (TITHELPWORDS * 4)
/* NOFLAGSSAVE is the number of bytes we save if there are no flags words.
 * We can remove everything from swichunk onwards if this offset is going
 * to be zero.
 */
#define NOFLAGSSAVEWORDS ((word *)(fred.titlestring)-&fred.swichunk)
#define NOFLAGSSAVEBYTES (4*(NOFLAGSSAVEWORDS))

/*
 * The Info structure is really a 3-word thing, but we are keen to save
 * space, so pack together the pointer to the next element in the list
 * and the count of number of occurrences of this value into a single
 * word.  To get as many bits as possible for the count, we constrain
 * all Info structures to be 8-byte aligned (freeing 3 low bits) and
 * take the top 8 bits of the address off.  This will only work if we
 * are in the low 16MBytes of address space, but it leaves us 11 bits
 * for the count, which is nearly always enough.
 *
 * Later on, we use these same records to build hash tables mapping
 * word values -> index in table of common values, for fast encoding.
 * Fortunately, the tables are of size 7*256 < 2**11, so the same
 * packing dodge still works.  I'm afraid this is all a bit tweaky,
 * but making it fast and small is worth the effort.
 *
 * The alternative is to look up each word by binary search, but that
 * would be slower (I think), viz 10 iterations for each table.
 */

/* SNB: we need a Solaris build of this tool.
 * All the messing around in the macros is done to avoid having to
 * change the rest of the code, though.  The next assignment in inccount
 * is retained to preserve previous version's semantics only.
 */

typedef struct Info Info;
struct Info {
  Info *next;
  word count;
  word value;
};

#define MAXCOUNT  (UINT_MAX)

#define unpack(p,n,c)     { (n) = (p)->next; (c) = (p)->count; }

#define pack(p,n,c)       { (p)->next = (n); (p)->count = (c); }

#define inccount(p,n,c)   { ++(c); assert((c) != 0); (p)->count = (c); (p)->next = (n); }


typedef Info *HashTab[HASHSIZE];

typedef struct VTable { /* sorted vector of common values */
  int nhits;        /* sum of frequencies of words in this table */
  Info *misses;     /* list of (freq, word) pairs not in this table */
  int size;         /* number of els in the table */
  word els[MAXTAB]; /* table els: [0..size-1] are valid */
} VTable;

typedef struct Freqs { /* list of (value, frequency) pairs */
  int nzeros;       /* no of zero words */
  int maxfreq;      /* max frequency in list - useful for sorting */
  Info *freqs;      /* list of (value, frequency) */
} Freqs;

/*
 * Some ugly stuff to allocate 2-word Info structures efficiently with
 * correct (8-byte) alignment.
 */

typedef struct InfoChunk {
  struct InfoChunk *next;
  Info *free;
  Info *limit;
  Info chunks[(CHUNKSIZE-12)/sizeof(Info)];
} InfoChunk;

#ifdef USE_DODGY_ALIGN_CODE
static Info *align(Info *p, int n)
{ int x = (int)p;
  x += (n - 1); x -= (x % n); return (Info *)x;
}
#endif

#if DEBUGGING
static char *heaplwm;
static char *heaphwm;
#endif

static void *xalloc(int bytes, const char *what)
{ void *p = malloc(bytes);
  if (p == NULL) err_fail("no more room");
/*  if ((int)p < 0) err_fail("storage corruption (%d)", (int)p); */
#if DEBUGGING
  if (debug) fprintf(stderr, "-- alloc(%d, %s) -> &%x\n", bytes, what, (int)p);
  if ((char *)p + bytes > heaphwm) heaphwm = (char *)p + bytes;
  if ((char *)p < heaplwm) heaplwm = (char *)p;
#else
  what = NULL;
#endif
  return(p);
}

static void xfree(void *p)
{
#if DEBUGGING
  if (debug) fprintf(stderr, "-- free(&%x)\n", (int)p);
#endif
  free(p);
}

static InfoChunk *curchunk;

static void freechunks(void)
{ InfoChunk *p, *next;
  for (p = curchunk; p != NULL; p = next) { next = p->next; xfree(p); }
  curchunk = NULL;
}

static Info *newinfo(Info *next, word v)
{ InfoChunk *chunk;
  Info *p;

  chunk = curchunk;
  if ((chunk == NULL) || ((p = chunk->free) >= chunk->limit)) {
    chunk = (InfoChunk *)xalloc(CHUNKSIZE, "InfoChunk");
    chunk->next  = curchunk;
#ifdef USE_DODGY_ALIGN_CODE
    chunk->free  = p = align(chunk->chunks, 8);
    chunk->limit = (Info *)(((int)chunk) + CHUNKSIZE - sizeof(Info));
#else
    chunk->free  = p = chunk->chunks;
    chunk->limit = p + (sizeof(chunk->chunks)/sizeof(chunk->chunks[0]));
#endif
    curchunk = chunk;
  }
  chunk->free = (p + 1);
  pack(p, next, 1); p->value = v;
  return(p);
}

static void countwords(word *code, word *limit, Freqs *ans)
/*
 * Counts number of occurrences of each word value in the specified block
 * of code [code, limit), and returns list of (value, freqency) pairs.
 */
{ HashTab *hash;
  Info **list;
  Info *p, *next, *freqs;
  int j, nzeros, maxfreq;
  word w;

  hash = xalloc(sizeof(HashTab), "HashTab");
  for (j = 0; j < HASHSIZE; ++j) (*hash)[j] = NULL;
  nzeros = 0;
  while (code < limit) {
    w = bytesex_hostval(*code++);
    if (w == 0) { ++nzeros; continue; }
    j = (w + (w >> 11) + (w >> 22)) % HASHSIZE; /* simple hash function */
    list = &((*hash)[j]);
    p = *list;
    while (1) {
      if (p == NULL) { *list = newinfo(*list, w); break; }
      unpack(p, next, j);
      if (w == p->value) { inccount(p, next, j); break; }
      p = next;
    }
  } /* while code < limit */
  /*
   * Now flatten the hash table into a single list, and free the vector.
   */
  freqs = NULL; maxfreq = 0;
  for (j = 0; j < HASHSIZE; ++j) {
    for (p = (*hash)[j]; p != NULL; p = next) {
      unpack(p, next, w); pack(p, freqs, w); freqs = p;
      if (w > maxfreq) maxfreq = w; /* keep track of max frequency */
    }
  }
  ans->nzeros  = nzeros;
  ans->maxfreq = maxfreq;
  ans->freqs   = freqs;
  xfree(hash);
}

static int comparewords(const void *a, const void *b)
/*
 * This proc is passed to the library qsort for sorting table elements.
 * We know that all table elements are distinct, so can cheat a little.
 * sbrodie (2003/04/30):  Wrong - qsort seems to pass a==b sometimes!
 */
{ word x = *(word *)a;
  word y = *(word *)b;
  if (x == y) return 0;
  if (x > y) return(+1);
  return(-1);
}

static void maketable(Freqs *freqs, int maxsize, int wantmisses, VTable *tab)
/*
 * Builds a VTable of the most common values in the list freqs,
 * taking at most maxsize of them, destroying the freqs list
 * in the process, and leaving the remnants hung off the VTable
 * record.
 */
{ Info **withfreq = xalloc((freqs->maxfreq+1) * sizeof(Info *), "withfreq");
  Info **list;
  Info *p, *next, *misses;
  int  freq, nhits, size;

  /*
   * It is easy to sort things by frequency, as frequency range is
   * limited to 1..freqs->maxfreq.  So just build a vector of lists.
   */
  for (list = withfreq + freqs->maxfreq; list >= withfreq; *list-- = NULL);

  for (p = freqs->freqs; p != NULL; p = next) { /* put p into bucket */
    unpack(p, next, freq);
    assert(freq <= freqs->maxfreq);
    pack(p, (withfreq[freq]), freq);
    withfreq[freq] = p;
  }
  freqs->freqs = NULL;

  nhits  = 0;
  misses = NULL;
  size   = 0;
  for (list = withfreq + freqs->maxfreq; list >= withfreq; --list) {
    for (p = *list; p != NULL; p = next) {
      unpack(p, next, freq);
      if (size < maxsize) {                        /* add to table */
        tab->els[size++] = p->value; nhits += freq;
      } else {                                     /* add to misses list */
        if (!wantmisses) break;
        pack(p, misses, freq); misses = p;
      }
    }
  }
  tab->nhits  = nhits;
  tab->misses = misses;
  tab->size   = size;
  xfree(withfreq);
  qsort((void *)(tab->els), size, sizeof(word), &comparewords);
  if (verbose > 1) printf("-- built table in %d csec\n", ticks());
}

static void masklowbyte(Info *list, Freqs *ans)
/*
 * Take a list of (value, frequency) of 4-byte values, merge values
 * with the same low byte to produce list of 3-byte values.
 */
#define VECBITS 12
#define VECSIZE (1<<VECBITS)
{ Info **vec = xalloc(VECSIZE * sizeof(Info *), "mergevec");
  Info **pp;
  Info *p, *next;
  Info *q, *qnext, *qprev;
  int freq, qfreq, qprevfreq, maxfreq;
  word val, qval;

  for (pp = vec + VECSIZE-1; pp >= vec; *pp-- = NULL);
  for (p = list; p != NULL; p = next) {
    unpack(p, next, freq);
    val = (p->value >> 8); p->value = val;
    pp = vec + ((val + (val >> 9) + (val >> 12)) % VECSIZE);
    /*
     * Now insert p in the ascending-value sorted list pp.
     * This is tricky because of the packing of the nextandcount field,
     * so have to handle start of list specially.
     */
    q = *pp;
    if (q == NULL) { pack(p, NULL, freq); *pp = p; continue; }
    unpack(q, qnext, qfreq); qval = q->value;
    if (val < qval) { pack(p, q, freq); *pp = p; continue; }
    if (val == qval) {
      qfreq += freq; if (qfreq > MAXCOUNT) qfreq = MAXCOUNT;
      pack(q, qnext, qfreq); continue;
    }
    while (1) {
      qprev = q; qprevfreq = qfreq; q = qnext;
      if (q == NULL) {   /* end of list: add it here */
        pack(p, NULL, freq); pack(qprev, p, qprevfreq); break;
      }
      unpack(q, qnext, qfreq); qval = q->value;
      if (val < qval) {  /* not in list: add it */
        pack(p, q, freq); pack(qprev, p, qprevfreq); break;
      }
      if (val == qval) { /* value matches: add frequency */
        qfreq += freq; if (qfreq > MAXCOUNT) qfreq = MAXCOUNT;
        pack(q, qnext, qfreq); break;
      }
    }
  }
  /*
   * Phew! That should keep the register allocator busy.
   * Now we have a vector of sorted lists: just have to flatten it.
   */
  q = NULL; maxfreq = 0;
  for (pp = vec + VECSIZE-1; pp >= vec; --pp) {
    for (p = *pp; p != NULL; p = next) {
      unpack(p, next, freq); pack(p, q, freq); q = p;
      if (freq > maxfreq) maxfreq = freq;
    }
  }
  ans->maxfreq = maxfreq;
  ans->freqs   = q;
  xfree(vec);
}

#define FASTSIZE 4096
#define FASTHASH(v) ((v + (v >> 7) + (v >> 15)) % FASTSIZE)

static Info **fasttab(VTable *tab)
/*
 * Builds a hash table for translating value -> index in table.
 */
{ Info **vec = xalloc(FASTSIZE * sizeof(Info *), "fasthash");
  Info **pp;
  int idx;
  word val;
  Info *p;

  for (pp = vec + FASTSIZE; pp > vec; *--pp = NULL);

  for (idx = 0; idx < tab->size; ++idx) {
    val = tab->els[idx];
    pp = vec + FASTHASH(val);
    /*
     * Values in table are unique, so just add it to chain.
     */
    p = newinfo(NULL, val); pack(p, *pp, idx); *pp = p;
  }
  return(vec);
}

static int lookup(Info **fast, word val)
{ Info *p, *next;
  int idx;

  for (p = fast[FASTHASH(val)]; p != NULL; p = next) {
    unpack(p, next, idx);
    if (val == p->value) return(idx);
  }
  return(-1);
}

typedef struct Header {
  int decodedsize;
  int encodedsize;
  int encodedtabs;
  int nshorts;
  int nlongs;
} Header;

#define TOPBYTE(n) ((n)>>24)
#define LOWBYTE(n) ((n)&0xff)
#define PUTLOWBYTE(p, n) (*p++ = (n)) /* relies on store masking low byte */

#define ENCODEVALUE(w, nibble, p) \
    if (w == 0) {                                             \
      nibble = ZERO;                                          \
    } else if ((idx = lookup(fshorts, w)) >= 0) {             \
      PUTLOWBYTE(p, idx);                                     \
      nibble = SHORT + (idx >> 8);                            \
    } else if ((idx = lookup(flongs, w>>8)) >= 0) {           \
      PUTLOWBYTE(p, w); PUTLOWBYTE(p, idx);                   \
      nibble = LONG + (idx >> 8);                             \
    } else {                                                  \
      *p++ = TOPBYTE(w); w <<= 8; *p++ = TOPBYTE(w); w <<= 8; \
      *p++ = TOPBYTE(w); w <<= 8; *p++ = TOPBYTE(w);          \
      nibble = LITERAL;                                       \
    }

#define ENCSIZE 1000000

/*
 * We encode a pair of words at a time.  To avoid unnecessary copying of data,
 * things are done in a rather curious order, not quite the opposite of the
 * optimal decoding order.  I can't quite convince myself that this is optimal,
 * but I think it is quite good.
 */

static char *encode(word *base, word *limit, Info **fshorts, Info **flongs,
             Header *h)
/*
 * Returns pointer to byte after the encoded data.
 */
{ word *code;
  word w;
  int idx, nib0, nib1;
  char *buf, *p;
  int size = (limit - base) * sizeof(word);
  int encsize;

  buf = xalloc(size, "encodebuf"); p = buf;

  h->decodedsize = ((char *)limit - (char *)base);
  for (code = base; code < limit; code += 2) {
    w = bytesex_hostval(code[1]); ENCODEVALUE(w, nib1, p);
    w = bytesex_hostval(code[0]); ENCODEVALUE(w, nib0, p);
    *p++ = (nib0 | (nib1 << 4));
    if (p >= (buf + size))
      err_fail("pathological file - can't cope");
  }
  encsize = p - buf;
  if (encsize > size)
    err_fail("pathological file is larger after squeezing - can't cope");
  memcpy(base + 1, buf, encsize);
  h->encodedsize = encsize;
  p = encsize + (char *) (base + 1);
  xfree(buf);
  return(p);
}

static char *encodetable(VTable *tab, int threebytes, char *out)
/*
 * Encode the table of 3 or 4 byte values, starting at address p,
 * return pointer to first free byte after table.
 */
{ word *p, *limit;
  word prev, w;
  int ones;
  unsigned delta;

  ones = 0; prev = (word)(-1);
  p = tab->els; limit = p + tab->size;
  while (p < limit) {
    w = *p++; delta = (w - prev); prev = w;
    if (delta == 1) ++ones;
    if ((ones > 0) && ((delta != 1) || (ones >= 9))) {
      *out++ = ones; ones = 0;
    }
    if (delta < 2) {  /* dealt with above: no zeros, ones are peepholed */ }
    else if (delta <= 91-10) { *out++ = delta+10; }
    else if (delta < 82*256) {
      *out++ = (delta>>8)+92; *out++ = LOWBYTE(delta);
    }
    else if (delta < 82*256*256) {
      *out++ = (delta>>16)+174;
      *out++ = LOWBYTE(delta); delta >>= 8;
      *out++ = LOWBYTE(delta);
    }
    else {
      *out++ = 0;
      *out++ = LOWBYTE(delta); delta >>= 8;
      *out++ = LOWBYTE(delta); delta >>= 8;
      *out++ = LOWBYTE(delta);
      if (!threebytes) { delta >>= 8; *out++ = delta; }
    }
  } /* end loop over values in table */
  if (ones > 0) *out++ = ones;
  return(out);
}

static char *compresscode(word *code, int size)
/*
 * Returns NULL if no compression, else pointer to top of compressed thing.
 */
{ Freqs  freqs;
  word   *limit;
  VTable *shorts, *longs;
  Info **fshorts, **flongs;
  int    nwords, guess, nliterals;
  Header header;
  char *pos, *tabstart;

  size += 7; size &= ~7; /* round up to an even number of words */
  limit = (word *)((char *)code + size);
  countwords(code, limit, &freqs);
  if (verbose > 1) printf("-- counted %d bytes in %d csec\n", size, ticks());
  /*
   * Allocate the VTables here to avoid nasty storage interactions, which
   * can lose us some chunks if we're not careful.
   */
  shorts = xalloc(sizeof(VTable), "shorts");
  longs  = xalloc(sizeof(VTable), "longs");
  maketable(&freqs, NSHORTS*256, 1, shorts);
  masklowbyte(shorts->misses, &freqs);
  if (verbose > 1) printf("-- masklowbyte took %d csec\n", ticks());
  maketable(&freqs, NLONGS*256, 0, longs);
  freechunks();
  /*
   * Now guess what the size of the compressed thing would be.
   * The estimates of size of encoded data are exact, but the
   * estimates of encoded table size are a guess, so we over-estimate
   * the size of the decompression code to be on the safe side.
   */
  nwords    = (size / sizeof(word));
  nliterals = nwords - freqs.nzeros - shorts->nhits - longs->nhits;

  guess     =   (nwords / 2)           /* 0.5 bytes per word of original */
              + (1 * shorts->nhits)    /* 1 more byte for each short */
              + (2 * longs->nhits)     /* 2 for each long */
              + (4 * nliterals)        /* 4 for each literal */
              + (2 * shorts->size)     /* rough size of shorts table */
              + (2 * longs->size)      /* rough size of longs table */
              + 1024;                  /* decompression code + safety margin */

  if (verbose)
          fprintf(stderr, "-- encoding stats (0,1,2,4) %d%% %d%% %d%% %d%%\n",
          (freqs.nzeros  * 100) / nwords,
          (shorts->nhits * 100) / nwords,
          (longs->nhits  * 100) / nwords,
          (nliterals     * 100) / nwords);

  if (guess > (9*size)/10) { /* not much squeeze to be had */
    if ((!force) || (guess > size)) {
      xfree(shorts);
      xfree(longs);
      return(NULL);
    }
  }

  /*
   * Now can actually start encoding stuff.
   */
  fshorts = fasttab(shorts);
  flongs  = fasttab(longs);
  if (verbose > 1) fprintf(stderr, "-- built speedup tables in %d csec\n", ticks());
  pos = encode(code, limit, fshorts, flongs, &header);
  xfree(flongs);
  xfree(fshorts);
  freechunks();
  if (verbose > 1)
    fprintf(stderr, "-- encode gives %d in %d csec\n", header.encodedsize, ticks());
  tabstart = pos;
  pos = encodetable(shorts, 0, pos); header.nshorts = shorts->size; xfree(shorts);
  pos = encodetable(longs,  1, pos); header.nlongs  = longs->size;  xfree(longs);
  /* now word-align before the header words */
  while (((int)pos & 3) != 0) *pos++ = 0;
  header.encodedtabs = (pos - tabstart);
  if (verbose > 1)
    fprintf(stderr, "-- decode tables occupy %d bytes\n", header.encodedtabs);
  if (bytesex_reversing()) {
    header.decodedsize = bytesex_hostval(header.decodedsize);
    header.encodedsize = bytesex_hostval(header.encodedsize);
    header.encodedtabs = bytesex_hostval(header.encodedtabs);
    header.nshorts = bytesex_hostval(header.nshorts);
    header.nlongs = bytesex_hostval(header.nlongs);
  }
  memcpy(pos, &header, sizeof(Header)); pos += sizeof(Header);
  /*
   * The word at 'code' was previously used for the branch instruction to the decode
   * code. This is not used in my system, but it's simpler to leave it in. I must initialise
   * it to a known value, however.
   */
  *code = 0;
  return(pos);
}

static int modsqz_valid_header_offset(int size, int value, int aligned)
{
  value = bytesex_hostval(value);
  if ((aligned && value & 3) || value > size) return 0;
  return 1;
}

static int modsqz_is_a_riscos_module(datahdr *header, int size)
{
  return
   (size >= 32) &&
   (modsqz_valid_header_offset(size, header->initoffset, 1)) &&
   (modsqz_valid_header_offset(size, header->dieoffset, 1)) &&
   (modsqz_valid_header_offset(size, header->serviceoffset, 1)) &&
   (modsqz_valid_header_offset(size, header->commandtable, 0)) &&
   (modsqz_valid_header_offset(size, header->titleoffset, 0)) && header->titleoffset &&
   (modsqz_valid_header_offset(size, header->helpoffset, 0));
}

static int squeeze(char *in, char *out)
{
  int rc, size, t, squeezed, titlen, helplen, flagswords, savedbytes;
  datahdr *d1, *d2;
  word *code, *block;
  char *top, *p, *titleptr, *helpptr;

  if (verbose) fprintf(stderr, "-- squeezing '%s' to '%s'\n", in, out);
  squeezed = 0;

  if (verbose > 1) fprintf(stderr, "-- bytesex reversal is %sactive\n", bytesex_reversing() ? "" : "in");

  size = (int) wf_filesize(in);
  if (size == -1) err_fail("'%s' does not exist or cannot be read", in);
  if (size < 0) err_fail("'%s' is too large to be processed", in); /* SNB: Safest to trap this */
  if ((!force) && (strcmp(in, out) == 0)) {
    /* Check quickly to see if worth loading */
    if (size < 2048) {
      err_report("'%s' is too small to squeeze", in);
      return(0);
    }
  }
  code = xalloc(DATABYTES+TITHELPBYTES+size+8, "code"); /* Pad to even no of words */
  block = code;                                         /* Save copy so we can free it */
  top = (char *)code + DATABYTES+TITHELPBYTES;
  for (p = (char *)code; p < top; *p++ = 0);            /* Clear out new module header */
  code += (DATAWORDS+TITHELPWORDS);                     /* This is where code will be loaded to */
  top = ((char *)code) + size+8;
  for (p = top-8; p < top; *p++ = 0);                   /* Clear the padding space */
  if (wf_load(in, code, size) == -1) err_fail("can't load '%s'", in);
  if (verbose > 1) fprintf(stderr, "-- loaded %d bytes in %d csec\n", size, ticks());
  t = clock();

  d1 = (datahdr *) code;                                /* d1 is the unsqueezed module header */
  if (!modsqz_is_a_riscos_module(d1, size)) err_fail("'%s' is not a module", in);

  if (bytesex_hostval(d1->initoffset) & 0x80000000) err_fail("'%s' is already squeezed", in);

  d1->dieoffset |= bytesex_hostval(0x80000000);         /* set 'RMClear invincibility' bit */

  titleptr = (char *)d1 +bytesex_hostval(d1->titleoffset);
  titlen = (strlen(titleptr) + 1 + 3) & ~3;             /* titlen is length of title string, (+1 for null) */
                                                        /* rounded up to a whole number of words      */
  if (d1->helpoffset == 0) {
    helpptr = (char *)&(d1->helpoffset);                /* no help string so point to zero byte */
  } else {
    helpptr = (char *)d1 + bytesex_hostval(d1->helpoffset);              /* point to help string */
  }
  helplen = (strlen(helpptr) + 1 + 3) & ~3;             /* helplen is length of title string, (+1 for null) */
                                                        /* rounded up to a whole number of words      */

  flagswords = 0;
  if (((bytesex_hostval(d1->swichunk) & 0xFF02003F) == 0) &&
      modsqz_valid_header_offset(size, d1->swihandler, 1) &&
      modsqz_valid_header_offset(size, d1->switable, 0) &&
      modsqz_valid_header_offset(size, d1->swicode, 1) &&
      modsqz_valid_header_offset(size, d1->intlmsgs, 0) &&
      modsqz_valid_header_offset(size, d1->flagsoffset, 1))
  {
    word offset = bytesex_hostval(d1->flagsoffset), *pflags;
    pflags = (word *) (((char *)code) + offset);
    if (offset) for (;;) {
      flagswords++;
      if (bytesex_hostval(*pflags) & (1u<<31)) {
        ++pflags;
      }
      else {
        break;
      }
    }
    if (verbose) fprintf(stderr, "-- flags words counted (%d)\n", flagswords);
  }

  if (!flagswords) {
    savedbytes = NOFLAGSSAVEBYTES;
  }
  else {
    savedbytes = 0;
  }

  /* d2 is the dummy header */
  d2 = (datahdr *) ((char *)code - titlen - helplen - flagswords * 4 - DATABYTES + savedbytes);
  strcpy(d2->titlestring - savedbytes, titleptr);                    /* copy title string to new header */
  strcpy((char *)(d2->titlestring-savedbytes)+titlen, helpptr);    /* copy help string to new header */

  d2->titleoffset = (char *)(d2->titlestring-savedbytes)-(char *)d2; /* set up offset to titlestring in new header */
  d2->helpoffset = d2->titleoffset + titlen;            /* set up offset to helpstring in new header */

  if (flagswords) {
    d2->flagsoffset = d2->helpoffset + helplen;
    memcpy(((char *)d2) + d2->flagsoffset, ((char *)d1) + bytesex_hostval(d1->flagsoffset), 4 * flagswords);
  }

  top = compresscode(code, size);                       /* squeeze the code (in place) */

  if (top != NULL) {
    t = clock() - t;
    code = (word *) d2;
    rc = (top - (char *)code);
    d2->initoffset = bytesex_hostval(rc | 0x80000000);  /* init offset of squeezed module = length OR &80000000 */
    if (verbose) {
      fprintf(stderr, "-- compressed size %d is %d%% of %d\n", rc, (rc*100)/size, size);
      fprintf(stderr, "-- compression took %d csec, %d bytes/cpusec\n", t, t ? (size*100)/t : size);
    }
    size = rc;
    d2->titleoffset = bytesex_hostval(d2->titleoffset);
    d2->helpoffset = bytesex_hostval(d2->helpoffset);
    if (flagswords) {
      d2->flagsoffset = bytesex_hostval(d2->flagsoffset);
    }
    squeezed = 1;
  } else {
    if (verbose) err_report("can't compress '%s', will copy", in);
  }
  if (squeezed || (strcmp(in, out) != 0)) { /* Write it out */
    if (wf_save(out, code, size) == -1) err_fail("failed to write '%s'", out);
#ifdef __riscos
    ;; (void) _swix(OS_File, _INR(0,2), 18, out, FileType_Module);
#endif
  }
  xfree(block);
#if DEBUGGING
  if (debug) {
    printf("-- heaphwm = &%x = &8000+%d\n",(int)heaphwm,(int)heaphwm-0x8000);
    printf("-- heaplwm = &%x, range = %d\n", (int)heaplwm, heaphwm - heaplwm);
  }
#endif
  return(0);
}

static void help(void)
{ char ch = host_dir_sep_char();
  fprintf(stderr, "\n%s vsn %s [%s] %s- %s\n", SELF, VSN, DATE, Module_MinorVersion, BRIEF);
  fprintf(stderr, "\n%s [options] unsqueezed-file [squeezed-file]\n", SELF);
  fprintf(stderr, "\nOptions:-\n");
  fprintf(stderr, "-f   try harder to squeeze unpleasant things\n");
  fprintf(stderr, "-v   output messages and compression statistics\n");
  fprintf(stderr, "\nExamples:-\n");
  fprintf(stderr, "     %s myprog      %s -v myprog squozen%cmyprog\n", SELF, SELF, ch);
  exit(EXIT_SUCCESS);
}

static void handle_escape(int signo)
{
  signal(signo, handle_escape);
  exit(EXIT_FAILURE);
}

static void initialise(void)
{
  signal(SIGINT, handle_escape);
  host_init();
  err_init(SELF);
  debug = 0; force = 0; verbose = 0;
  curchunk = NULL;
  ticks();
  bytesex_reverse_auto(bytesex_WANT_LITTLE_ENDIAN);
}

int main(int argc, char *argv[])
{ int j;
  char *arg;
  char *a = NULL;
  char *b = NULL;
  int skip_arg = 0;

  initialise();
  assert((unsigned long)UINT_MAX > (1UL<<31UL));

  /* parse help or identify args */
  for (j = 1;  j < argc;  ++j) {
    arg = argv[j];
    if (hash_cistrcmp("-help", arg) == 0 || hash_cistrcmp("-h", arg) == 0) {
      help();
    }
  }

  /* parse args */
  for (j = 1; j < argc; ++j) {
    arg = argv[j];
    if (skip_arg) {
      b = arg;
      continue;
    }
    if (arg[0] == '-') {
      int i = 1;
      while (arg[i]) {
        switch (arg[i]) {
          case 'f':
          case 'F': ++force; break;
          case 'v':
          case 'V': ++verbose; break;
#if DEBUGGING
          case 'z':
          case 'Z': ++debug; break;
#endif
          case 'o': skip_arg = 1; break;
          default : err_fail("flag '%c' not recognised", arg[i]);
        }
        ++i;
      }
    } else { /* a filename */
      if      (a == NULL) a = arg;
      else if (b == NULL) b = arg;
      else err_fail("too many filename arguments '%s'\n", arg);
    }
  }
  if (a == NULL) err_fail("missing filename");
  if (b == NULL) b = a; /* squeeze it to itself */

#if DEBUGGING
  if (debug) { heaplwm = (char *)0x03ffffff; heaphwm = NULL; }
#endif

  return(squeeze(a, b));
}
@


1.15
log
@Change assumption about clock()
Don't assume clock() counts in cs, so that the times come out right on a cross compiled Unix system.

Version 3.16. Tagged as 'modsqz-3_16'
@
text
@d89 1
a89 1
static int ticks()
d228 1
a228 1
static void *xalloc(int bytes, char *what)
d644 5
a648 1
    if ((!force) || (guess > size)) return(NULL);
d837 1
a837 1
static void help()
@


1.14
log
@  Changes to facilitate platform independence.
Detail:
  * Added shell-script make wrapper
  * Uses shared makefile fragments and one master makefile for all variants
  * #includes use CLX path explicitly
Admin:
   No functional change, so version not incremented

Tagged as 'modsqz-3_14-2'

Version 3.14. Not tagged
@
text
@d91 2
a92 1
  last = lastticks; lastticks = clock(); return(lastticks-last);
@


1.13
log
@  Fixed bug when in verbose mode
Detail:
  When modsqz completed in under one centisecond, the verbose output
  would bomb-out with a divide by zero error. Fixed.
Admin:
  Tested with the rest of Library-1_28 and now works. This should be built
  and put into Library.

Version 3.14. Tagged as 'modsqz-3_14'
@
text
@d45 5
a49 5
#include "host.h"
#include "hash.h"
#include "err.h"
#include "wholefls.h"
#include "bytesex.h"
d51 1
a51 1
#ifdef SQUEEZING_ON_RISCOS
d818 1
a818 1
#ifdef SQUEEZING_ON_RISCOS
@


1.12
log
@Change merged from Pace repository:
> Summary:
>   Fixed bad table encoding bug.
> Detail:
>   The delta value between entries in the shorts/longs tables was being
>     stored as a signed int but was assumed to never be negative in the
>     test code that followed the calculation.  This caused incorrect
>     encoding of the tables, which caused a sample module we were given
>     to encode incorrectly.  No idea why we've never seen this before:
>     most likely it is because of the nature of the data in the module (it
>     was a ResourceFS baseline module containing a lot of text).  The fix
>     is to just make delta an unsigned int instead of a signed int.
> Admin:
>   Tested on Linux and RISC OS - fixes Bugzilla bug #16805
>   Module now compresses and decompressed back to what it started out as.

Version 3.13. Tagged as 'modsqz-3_13'
@
text
@d804 1
a804 1
      fprintf(stderr, "-- compression took %d csec, %d bytes/cpusec\n", t, (size*100)/t);
@


1.11
log
@  Update to Makefile to tidy up the exported Desc file.
  Updated !Run file to ensure the latest modules.
Admin:
  Requires BuildSys 3.01 or later.
  Co-dependent with Library 0.67 or later

Version 3.12. Tagged as 'modsqz-3_12'
@
text
@d215 1
d220 1
d265 1
d268 4
d326 1
d330 1
d355 1
d558 2
a559 1
  int delta, ones;
@


1.10
log
@  Reports the compression stats correctly.
Detail:
  Previously a variable holding the original size of the module being
    compressed would be updated with the compressed size just before
    it was needed as part of the stats reporting code.  Now the update
    occurs *after* the stats reporting code.
Admin:
  Reported by Robin.Watts@@wss.co.uk.
  Fixes Bugzilla bug #131
  Tested.

Version 3.11. Tagged as 'modsqz-3_11'
@
text
@d855 1
d871 4
d887 1
@


1.9
log
@  Module flags words are duplicated into squeezed module.
Detail:
  If present, the module flags word(s) are copied to the squeezed header
    of the module to ensure that the kernel can recognise any special
    requirements (e.g. that the module is 32-bit compatible).
Admin:
  Tested on RISC OS and SPARC Solaris - identical output is produced.

Version 3.10. Tagged as 'modsqz-3_10'
@
text
@a789 1
    size = rc;
d795 1
@


1.8
log
@  Fixed module check rules.
Detail:
  modsqz was being a litttle over-zealous with it's checks for module
  header validity. The module's command table offset does not have to
  be word-aligned; it is an offset to a string. The PRM states only
  that offsets to code must be word-aligned.
Admin:
  This will allow modules like: MPEGTransport, MPEGSystem and
  NHTwitter to be squeezed.

Version 3.09. Tagged as 'modsqz-3_09'
@
text
@d125 2
a136 1

d139 6
a186 1
/* XXX: SNB portability OK below here */
d693 1
a693 1
  int rc, size, t, squeezed, titlen, helplen;
d701 1
a701 1
  if (verbose > 1) fprintf(stderr, "-- %saving sex\n", bytesex_reversing() ? "H" : "Not h");
d742 33
a774 3
  d2 = (datahdr *) ((char *)code - titlen - helplen - DATABYTES);     /* d2 is the dummy header */
  strcpy(d2->titlestring, titleptr);                    /* copy title string to new header */
  strcpy((char *)(d2->titlestring)+titlen, helpptr);    /* copy help string to new header */
d776 1
a776 1
  d2->titleoffset = (char *)(d2->titlestring)-(char *)d2; /* set up offset to titlestring in new header */
d779 5
d798 3
a838 13
static void init_sex(void)
{
  /* Determine sex of machine.  Relies on memory encoding of integers */
  union {
    char c[sizeof(unsigned int)];
    unsigned int i;
  } gross_ugly_hack;
  gross_ugly_hack.i = 1;
  /* If that statement sets c[0], this is little endian and we don't need
   * sexing.  Only need sexing if we are big endian */
  bytesex_reverse(gross_ugly_hack.c[0] != 1);
}

d847 1
a847 1
  init_sex();
@


1.7
log
@  Doesn't use the silly buffer re-use method any more.
Detail:
  Instead of having a "clever" memory re-use method, we simply malloc
    enough memory to hold the compressed module separately.  Should
    finally get rid of the pathological file errors.
Admin:
  Tested on a baseline 4.07 archive.

Version 3.08. Tagged as 'modsqz-3_08'
@
text
@d680 1
a680 1
   (modsqz_valid_header_offset(size, header->commandtable, 1)) &&
@


1.6
log
@  Another increase in buffer sizes for baseline 406.
Detail:
  More pathological baseline archives have turned up.
Admin:
  This version has NOT been tested on anything but Solaris.
  The increased memory requirements may cause problems on
    RISC OS builds.

Version 3.07. Tagged as 'modsqz-3_07'
@
text
@d512 2
d515 1
a515 1
  buf = xalloc(ENCSIZE, "encodebuf"); p = buf;
d522 2
a523 15
    if (buf != NULL) {
      idx = ((int)code - (int)base - 12 - (p - buf));
      if ((idx > 163840) || (p - buf > ENCSIZE - 16)) {
        /*
         * Swap from encoding into buf to encoding on top of old stuff
         * once we get 256 bytes clear, or run out of buf space.
         */
        /* printf("%d, %p, %p, %d, %d\n", idx, p, buf, p - buf, ENCSIZE - 16); */
        memcpy(base+1, buf, p-buf); p = (p-buf) + (char *)(base+1);
        xfree(buf); buf = NULL;
      }
    } else {
      if (p >= (char *)(code-2))
        err_fail("pathological file - can't cope");
    }
d525 7
a531 1
  h->encodedsize = p - (char *)(base+1);
@


1.5
log
@  Increased internal work buffer sizes.
Detail:
  The 8K buffer is insufficient to cope with some of the baseline
   archives being generated for the STB-400.  The 8K buffer has
   been increased to 300K.  This allows the archive to build and
   leaves quite a lot of extra spare space to cope with large
   modules.
Admin:
  Only tested Intel Solaris build.
  Fixes bug #1775

Version 3.06. Tagged as 'modsqz-3_06'
@
text
@d494 1
a494 1
#define ENCSIZE 300000
d522 1
a522 1
      if ((idx > 1024) || (p - buf > ENCSIZE - 16)) {
@


1.4
log
@  modsqz no longer requires the SWI chunk to be valid.
Detail:
  Previously modsqz would refuse to squeeze a module if the SWI
    chunk was not valid (modsqz 3.03 and 3.04 only, it is thought)
    It now no longer imposes this incorrect restriction.
Admin:
  Tested Solaris and RISC OS builds.

Version 3.05. Tagged as 'modsqz-3_05'
@
text
@d494 1
a494 1
#define ENCSIZE 8192
d522 1
a522 1
      if ((idx > 256) || (p - buf > ENCSIZE - 16)) {
d527 1
@


1.3
log
@  Made modsqz portable.
Detail:
  Removed byte-order assumptions.
  Removed memory address location assumptions.
  Updated to use CLX's sexing functions where necessary.
  Fixed usage of dynamic memory which had been free()'d.
Admin:
  Tested by building for SPARC Solaris, x86 Solaris and RISC OS and
    verifying that the output of all three versions was byte identical
    for a test module (IPConfig 0.19), and that RISC OS was capable of
    loading and decompressing the module and that unmodsqz was able
    to resurrect the original unsqueezed module.
  Requires CLX build for target host.
  Requires CLXPATH environment variable to point to installed CLX.

Version 3.04. Tagged as 'modsqz-3_04'
@
text
@d686 1
a686 2
   (modsqz_valid_header_offset(size, header->helpoffset, 0)) &&
   (bytesex_hostval(header->swichunk) & 63);
a739 1
fprintf(stderr, "-- Module is %s, help is %s\n", titleptr, helpptr);
@


1.2
log
@  No longer aborts when attempting to squeezed already squeezed modules.
Detail:
  modsqz was detecting that the module was already squeezed, but then
  failing to pass sufficient parameters to the err_fail variadic fn
  that reported the error.  The filename parameter is now supplied as
  the format string required.
  Version numbers and dates etc. are now all sourced from the VersionNum
  file;
  -Wp flag removed now it includes "kernel.h" and not <kernel.h>
Admin:
  Built from clean, with CLX-1_04, and it generated modules with which
  the kernel is satisfied.

Version 3.03. Tagged as 'modsqz-3_03'
@
text
@d31 2
a32 1
#
d43 2
a44 1
#include "kernel.h"
d48 10
d78 1
a78 1
#define BRIEF      "compress a relocatable module for use with RISC OS 2.05 or later"
d80 2
a81 2
#define HASHSIZE   (8*1024)
#define CHUNKSIZE  (16*1024)
a112 4
#define MODTYPE 0xfffffa00      /* module file type */
#define SQUEEZED MODTYPE        /* the file type of the output image */
#define UNSQUEEZED MODTYPE      /* the file type of the input image */

d128 1
a128 1
static datahdr fred;
d159 10
a168 2
typedef struct Info {
  word nextandcount;
d170 1
a170 1
} Info;
d172 1
a172 2
#define COUNTBITS 11
#define MAXCOUNT  ((1<<COUNTBITS)-1)
d174 1
a174 3
#define unpack(p,n,c)     { word t = p->nextandcount;                 \
                            n = (Info *)((t>>COUNTBITS)<<3);          \
                            c = t & MAXCOUNT; }
d176 1
a176 2
#define pack(p,n,c)       { word t = (((word)n)<<(COUNTBITS-3)) | c;  \
                            p->nextandcount = t; }
d178 3
a180 2
#define inccount(p,n,c)   { if (c < MAXCOUNT) ++c;                    \
                            p->nextandcount = (((word)n)<<(COUNTBITS-3)) | c; }
a240 11
/*
 * Veneer on file-handling.
 */

#define SAVE      0
#define WRITEINFO 1
#define READINFO  5
#define LOAD      0xff

#define FILEFOUND  1

d281 1
a281 1
    w = *code++;
d517 2
a518 2
    w = code[1]; ENCODEVALUE(w, nib1, p);
    w = code[0]; ENCODEVALUE(w, nib0, p);
d646 2
a647 4
  pos = encodetable(shorts, 0, pos); xfree(shorts);
  pos = encodetable(longs,  1, pos); xfree(longs);
  header.nshorts = shorts->size;
  header.nlongs  = longs->size;
d653 7
d670 20
d691 1
a691 1
{ _kernel_osfile_block info;
d699 6
a704 2
  if (_kernel_osfile(READINFO, in, &info) != FILEFOUND) err_fail("'%s' does not exist", in);
  size = info.start;
d719 1
a719 3
  info.load = (int)code; info.exec = 0;
  if (_kernel_osfile(LOAD, in, &info) != FILEFOUND) err_fail("can't load '%s'", in);
  if ((info.load & 0xffffff00) != UNSQUEEZED) err_fail("'%s' is not a module", in);
d724 1
a724 1
  if ((d1->initoffset) & 0x80000000) err_fail("'%s' is already squeezed", in);
d726 1
a726 1
  d1->dieoffset |= 0x80000000;                          /* set 'RMClear invincibility' bit */
d728 3
a730 1
  titleptr = (char *)d1 + d1->titleoffset;
d736 1
a736 1
    helpptr = (char *)d1 + d1->helpoffset;              /* point to help string */
d741 1
a753 1
    info.load = SQUEEZED | (info.load & 0xff);
d755 2
a756 1
    d2->initoffset = rc | 0x80000000;                   /* init offset of squeezed module = length OR &80000000 */
d761 2
a764 1
    top = (char *)code + size;
d768 4
a771 2
    info.start = (int)code; info.end = (int)top;
    if (_kernel_osfile(SAVE, out, &info) < 0) err_fail("failed to write '%s'", out);
d801 14
a814 1
static void initialise()
d822 1
d832 1
@


1.1
log
@Initial revision
@
text
@a36 1
/* extern char *malloc(); */
d42 1
a42 1
#include <kernel.h>
d65 1
a65 1
#define VSN        "3.02"
d695 1
a695 1
  if ((d1->initoffset) & 0x80000000) err_fail("'%s' is already squeezed");
d750 1
a750 1
  fprintf(stderr, "\n%s vsn %s [%s] - %s\n", SELF, VSN, DATE, BRIEF);
@


1.1.1.1
log
@* Import of modsqz tool to CVS.
Changes:
* VersionNum file added manually and fixed with version name and
  date of these sources, plus DATE macro is initialised from the
  VersionNum file instead of __DATE__.
* Makefile replaced with cleaner more standard version.
Admin:
* Sourced from TDobson's old A440.
* Requires CLX-1_04

@
text
@@

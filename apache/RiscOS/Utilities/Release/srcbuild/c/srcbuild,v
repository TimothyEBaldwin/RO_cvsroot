head	1.35;
access;
symbols
	srcbuild-0_51:1.35
	srcbuild-0_50:1.35
	srcbuild-0_49:1.35
	srcbuild-0_48:1.35
	srcbuild-0_47:1.34
	srcbuild-0_46:1.34
	srcbuild-0_45:1.33
	srcbuild-0_44:1.32
	srcbuild-0_43:1.31
	srcbuild-0_42:1.31
	srcbuild-0_41:1.31
	srcbuild-0_40:1.30
	srcbuild-0_39:1.30
	srcbuild-0_38:1.30
	srcbuild-0_37:1.29
	srcbuild-0_36:1.29
	srcbuild-0_35:1.28
	srcbuild-0_34:1.28
	srcbuild-0_33:1.27
	srcbuild-0_32:1.27
	srcbuild-0_31:1.27
	srcbuild-0_30:1.26
	srcbuild-0_29:1.26
	srcbuild-0_28:1.26
	srcbuild-0_27:1.26
	srcbuild-0_26:1.25
	srcbuild-0_25:1.24
	srcbuild-0_24-1_23_2_4:1.23.2.2
	srcbuild-0_24-1_23_2_3:1.23.2.1
	srcbuild-0_24-1_23_2_2:1.23.2.1
	srcbuild-0_24-1_23_2_1:1.23.2.1
	sbrodie_BBE:1.23.0.2
	sbrodie_BBE_bp:1.23
	srcbuild-0_24:1.23
	srcbuild-0_23:1.22
	srcbuild-0_22:1.22
	srcbuild-0_21:1.22
	srcbuild-0_20:1.21
	srcbuild-0_19:1.20
	srcbuild-0_18:1.19
	srcbuild-0_17:1.18
	srcbuild-0_16:1.18
	srcbuild-0_15:1.17
	srcbuild-0_14:1.16
	srcbuild-0_13:1.15
	srcbuild-0_12:1.14
	srcbuild-0_11:1.14
	srcbuild-0_10:1.13
	srcbuild-0_09:1.13
	srcbuild-0_08:1.12
	srcbuild-0_07:1.11
	srcbuild-0_06:1.11
	srcbuild-0_05:1.11
	srcbuild-0_04:1.11
	srcbuild-0_03:1.10
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.35
date	2010.01.30.16.14.55;	author jlee;	state Exp;
branches;
next	1.34;

1.34
date	2009.07.12.22.44.20;	author srevill;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.31.00.29.26;	author srevill;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.11.12.53.20;	author srevill;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.12.16.54.31;	author srevill;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.08.14.44.10;	author srevill;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.02.16.35.12;	author sbrodie;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.08.15.29.01;	author sbrodie;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.22.13.20.19;	author sbrodie;	state Exp;
branches;
next	1.26;

1.26
date	2001.02.02.11.22.11;	author sbrodie;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.25.16.16.53;	author sbrodie;	state Exp;
branches;
next	1.24;

1.24
date	2000.12.15.16.26.51;	author sbrodie;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.16.11.08.37;	author kbracey;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2000.06.12.12.04.24;	author dcotton;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.08.17.44.36;	author dcotton;	state Exp;
branches;
next	1.20;

1.20
date	2000.05.22.12.22.25;	author dcotton;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.27.13.41.08;	author dcotton;	state Exp;
branches;
next	1.18;

1.18
date	99.09.10.10.49.20;	author dcotton;	state Exp;
branches;
next	1.17;

1.17
date	99.09.09.12.54.10;	author nbingham;	state Exp;
branches;
next	1.16;

1.16
date	99.07.06.14.18.11;	author dcotton;	state Exp;
branches;
next	1.15;

1.15
date	99.05.07.12.37.25;	author kbracey;	state Exp;
branches;
next	1.14;

1.14
date	99.04.30.08.23.19;	author dcotton;	state Exp;
branches;
next	1.13;

1.13
date	98.10.27.10.38.47;	author blaughto;	state Exp;
branches;
next	1.12;

1.12
date	98.10.27.09.40.13;	author kbracey;	state Exp;
branches;
next	1.11;

1.11
date	97.09.25.15.43.23;	author rbuckley;	state Exp;
branches;
next	1.10;

1.10
date	97.09.25.11.24.51;	author rbuckley;	state Exp;
branches;
next	1.9;

1.9
date	97.09.22.16.55.06;	author rbuckley;	state Exp;
branches;
next	1.8;

1.8
date	97.09.12.14.12.24;	author rbuckley;	state Exp;
branches;
next	1.7;

1.7
date	97.09.09.09.41.14;	author rbuckley;	state Exp;
branches;
next	1.6;

1.6
date	97.09.08.17.17.03;	author rbuckley;	state Exp;
branches;
next	1.5;

1.5
date	97.09.08.17.15.45;	author rbuckley;	state Exp;
branches;
next	1.4;

1.4
date	97.09.05.12.56.04;	author rbuckley;	state Exp;
branches;
next	1.3;

1.3
date	97.09.04.13.33.09;	author rbuckley;	state Exp;
branches;
next	1.2;

1.2
date	97.08.22.16.16.53;	author rbuckley;	state Exp;
branches;
next	1.1;

1.1
date	97.08.21.16.44.55;	author rbuckley;	state Exp;
branches
	1.1.1.1;
next	;

1.23.2.1
date	2000.12.07.17.03.43;	author sbrodie;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2000.12.15.15.33.30;	author sbrodie;	state Exp;
branches;
next	;

1.1.1.1
date	97.08.21.16.44.55;	author rbuckley;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Fix srcbuild's handling of options strings
Detail:
  c/srcbuild - Now correctly handles the case where option strings have been removed from compnent files (i.e. it forces a clean of the component)
  Handling of null option strings has also been fixed; previously if a line ended in '-options' then the force clean flag would be set, but the option string pointer would be null - resulting in no options being written out to the shadow file, and thus the component would be cleaned on every single build.
Admin:
  Tested running on Iyonix RO5.12, while building OMAP3 ROM.
  Fixes bug #208


Version 0.48. Tagged as 'srcbuild-0_48'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <stdarg.h>

/* CLX */
#include "host.h"
#include "prgname.h"
#include "err.h"

/* Local */

#include "srcbuild.h"
#include "build.h"
#include "parse.h"
#include "riscos.h"


/* local variables */
static char *base_address = NULL;

/*
 * globals
 */
char progname[32]; /* Magic number required by CLX library */
char *build_name = NULL;
char *build_dir = NULL;
char *image_filename = NULL;
char *log_filename = NULL;
char *messages_filename = NULL;
char *joiner = NULL;
char *joiner_format = NULL;
char *image_size = NULL;
char *territories = NULL;
podule_info_t podule_info =
{NULL, NULL, NULL, NULL, NULL, NULL, NULL};
char *sigstr = NULL;
char *signum = NULL;
char *module_type_names[] =
{ALL_MODULE_TYPES(ARRAY_ENTRY)};
char *image_type_names[] = {
  "rom", "exprom", "extrom", "other"
};
int verbose = FALSE;
int strict = FALSE;

#define MAX_JOIN_ENTRIES 256
HashTable join_db;
HashId join_entries[256];
int join_db_hwm = 0;

image_type_t image_type = image_type_unset;


/* Create an array in which territories defined in the Env file can be stored.
 * Extra entry allows to BBE builds to add UK to the resource list.
 */
char* supported_territories[MAX_TERRITORIES + 1] = { NULL };
unsigned int num_of_territories = 0;

/* Create some linked lists... */
module_entry_t *module_database = NULL;
component_entry_t *component_database = NULL;     /* Pointer to list head */
component_entry_t *component_database_end = NULL; /* Pointer to list tail */
error_entry_t *error_database = NULL;

static const action_t action_tbl[] =
{
  { build_clean, "clean", "clean the build" },
  { build_clean_all, "clean_all", "full clean for major libraries" },
  { build_export_hdrs, "export_hdrs", "export headers" },
  { build_export_libs, "export_libs", "export libraries" },
  { build_resources, "resources", "export resources" },
  { build_bbe, "bbe", "export binary build structure" },
  { build_rom, "rom", "make modules for rom" },
  { build_install_rom, "install_rom", "install components" },
  { build_install, "install", "create RAM versions of the components" },
  { build_join, "join", "join modules to construct rom" },
  { build_list, "list", "list all modules to appear in rom" },
  { build_release_autobuild, "release_autobuild", "release the results of this build to the autobuild system" },
  { 0, 0, 0 }
};

static void show_phases_csv(void)
{
  const action_t *action;

  for (action = &action_tbl[0]; action->call; action++)
    sb_printf("%s,%s\n", action->name, action->help);
}

/*
 * Set the system variables as appropriate on program finalisation.
 */
void set_sys_vars(int success)
{
#ifdef RISCOS
  char buffer[BUFFER_LEN];
  sb_buildfilename(BUFFER_LEN, buffer, build_dir, BUILDSYS_DIR, LOGS_DIR, log_filename, NULL);
  sb_setenv(ENV_LOGFILE_LOCATION, buffer);
  sb_buildfilename(BUFFER_LEN, buffer, build_dir, IMAGES_DIR, image_filename, NULL);
  sb_setenv(ENV_IMAGE_LOCATION, buffer);
  sprintf(buffer, "%d", success);
  sb_setenv(ENV_RETURN_CODE, buffer);
#else
  /* Pointless - environment variables are not visible to parent processes */
  (void) success;
#endif
}



/*
 * send error message to stderr
 */
void
error(int fatal, char *format,...)
{
  va_list list;
  char buffer[BUFFER_LEN];
  error_entry_t *entry, *this;

  va_start(list, format);
  vsprintf(buffer, format, list);
  va_end(list);

  if ((this = malloc(sizeof(error_entry_t))) == NULL)
    error(1, "%s: memory allocation error.", progname);

  this->message = sb_strdup(buffer);
  this->next = NULL;
  sb_printf("Error %s\n", this->message);

  if (error_database == NULL)
    error_database = this;
  else {
    entry = error_database;
    while (entry->next)
      entry = entry->next;
    entry->next = this;
  }

  if (fatal || strict) {
    sb_fprintf(stderr, "Fatal error ");
    strcat(buffer, "\n");
    sb_fprintf(stderr, buffer);
    exit(EXIT_FAILURE);
  }

}

/*
 * look an entry by name and return its structure
 */
module_entry_t *
lookup_module(char *name)
{
  module_entry_t *entry = module_database;

  while (entry) {
    if (strcmp(entry->name, name) == 0)
      return (entry);
    entry = entry->next;
  }


  return (NULL);
}

/*
 * look an component entry by name and return its structure
 */
component_entry_t *
lookup_component(char *name)
{
  component_entry_t *entry = component_database;

  while (entry) {
    if (strcmp(entry->name, name) == 0)
      return (entry);
    entry = entry->next;
  }

  return (NULL);
}

///*
// * look an component entry by name and return its structure
// * - this checks the components list from tail to head
// */
//component_entry_t *
//reverse_lookup_component(char *name)
//{
//  component_entry_t *entry = component_database_end;
//
//  while (entry) {
//    if (strcmp(entry->name, name) == 0)
//      return (entry);
//    entry = entry->prev;
//  }
//
//  return (NULL);
//}

static void srcbuild_rewrite_path_in_host_syntax(char **path)
{
  const char dir_sep = host_dir_sep_char();
  char *newpath;
  char *rpath = *path;
  size_t length = strlen(rpath);
  size_t i, j;

  /* On RISC OS, the directory separator will be correct - otherwise we have to fix it */
  if (dir_sep == '.') return;

  if (strchr(rpath, '^')) {
    /* Oh dear - parent directory specifiers - need to reallocate the memory */
    newpath = malloc(2*length);
    if (!newpath)
      error(1, "Unable to allocate memory for component path");
  }
  else {
    newpath = rpath;
  }

  for (i = j = 0; i <= length; ++i, ++j) {
    newpath[j] = rpath[i];
    if (newpath[j] == '.') {
      newpath[j] = dir_sep;
    }
    else if (newpath[j] == '^') {
      newpath[j++] = '.';
      newpath[j] = '.';
    }
  }

  if (newpath != rpath) {
    free(rpath);
    *path = realloc(newpath, 1 + strlen(newpath));
  }
}

/*
 * read the database into a linked list of records.
 */
int
read_module_database(void)
{
  FILE *file = NULL;
  char buffer[BUFFER_LEN];
  char *cp, *word = NULL;
  module_entry_t *entry, *this;
  int i, line_number = 0;

  /*
   * work out filename
   */
  sb_buildfilename(BUFFER_LEN, buffer, build_dir, BUILDSYS_DIR, MODULE_DB_FILE, NULL);
  if ((file = fopen(buffer, "r")) == NULL)
    error(1, "cannot open module database file %s.", buffer);

  if (verbose)
    sb_printf("Using module database '%s'.\n", buffer);

  while (!feof(file)) {
    fgets(buffer, sizeof(buffer), file);
    if (!feof(file)) {
      line_number++;
      chop_newline(buffer);
      if (buffer[0] != '#') {   /* ignore comments */
        cp = buffer;
        cp = extract_word(cp, &word, FALSE);    /* extract the name */
        if (word != NULL) {     /* ignore null lines */
          if (lookup_module(word) != NULL) {
            error(1, "duplicate '%s' entry in module database line %d.",
                  word, line_number);
          }
          /* allocate a new entry */
          if ((this = malloc(sizeof(module_entry_t))) == NULL)
            error(1, "memory allocation error.");

          this->name = word;
          word = NULL;
          this->path = NULL;
          this->output = NULL;
          this->filename = NULL;
          this->switch_on = NULL;
          this->type = UNDEF;
          this->next = module_database;
          module_database = this;
          entry = this;

          cp = extract_word(cp, &word, FALSE);
          for (i = 0; i < sizeof(module_type_names) / sizeof(char *); i++) {
            if (cstrcmp(word, module_type_names[i]) == 0) {
              entry->type = (module_type_t) i;
              free(word);
              word = NULL;
              break;
            }
          }
          if (word != NULL) {   /* module type not found */
            error(1, "unknown module type '%s' in module database line %d.",
                  word, line_number);
          }
          cp = extract_word(cp, &(entry->path), FALSE);
          cp = extract_word(cp, &(entry->output), FALSE);
          cp = extract_word(cp, &(entry->filename), FALSE);
          cp = extract_word(cp, &(entry->switch_on), TRUE);

          srcbuild_rewrite_path_in_host_syntax(&(entry->path));
        }
      }
    }
  }

  if (file)
    fclose(file);
  if (word)
    free(word);

  return (0);
}

/*
 * read the shadow components file
 */
int
read_shadow_component_database(char *filename)
{
  FILE *file;
  char buffer[BUFFER_LEN];
  char *cp;
  char *name = NULL;
  char *options = NULL;
  char *switch_on = NULL;
  char *word = NULL;
  int options_same;
  int switch_same;
  component_entry_t *component;
  module_entry_t *module;

  /*
   * work out shadow components filename
   */
  sb_buildfilename(BUFFER_LEN, buffer, build_dir, BUILDSYS_DIR, SHADOW_DIR, filename, NULL);
  if ((file = fopen(buffer, "r")) == NULL)
    return (0);

  if (verbose)
    sb_printf("Using shadow components file '%s'.\n", buffer);

  while (!feof(file)) {
    fgets(buffer, sizeof(buffer), file);
    if (!feof(file)) {
      name = options = switch_on = NULL;

      chop_newline(buffer);
      cp = buffer;
      cp = extract_word(cp, &name, FALSE);      /* extract the name */

      if ((component = lookup_component(name)) != NULL) {

        while (cp) {            /* while there is still text on line */
          /* get the options word */
          cp = extract_word(cp, &word, FALSE);
          if (cstrcmp(word, "-options") == 0) {
            options = sb_strdup(cp);    /* rest of line */
          } else if (cstrcmp(word, "-switch") == 0) {
            cp = extract_word(cp, &switch_on, TRUE);
          }
        }

        options_same = FALSE;
        switch_same = FALSE;
        /* do we have any options */
        if (!component->options && !options)
          options_same = TRUE;

        /* check out options first */
        if (component->options)
          if (cstrcmp(component->options, options) == 0)
            options_same = TRUE;

        /* now check out switches */
        if (component->switch_on) {
          if (cstrcmp(component->switch_on, switch_on) == 0)
            switch_same = TRUE;
        } else {
          if ((module = lookup_module(name)) != NULL) {
            if (module->switch_on) {
              if (cstrcmp(component->switch_on, switch_on) == 0)
                switch_same = TRUE;
            } else {
              if (!switch_on)
                switch_same = TRUE;
            }
          }
        }
        /* mark the module for not needing clean */
        if (!component->always_clean && switch_same && options_same)
          component->force_clean = FALSE;
          
        /* If there were options, and now there are none, we must clean */
        if (!component->options && options)
          component->force_clean = TRUE;
      }
    }
  }
  fclose(file);

  if (name)
    free(name);
  if (options)
    free(options);
  if (switch_on)
    free(switch_on);
  if (word)
    free(word);

  return (0);
}


static image_type_t srcbuild_parse_format(const char *f)
{
  int i;

  for (i=0; (i+1)<(sizeof(image_type_names)/sizeof(*image_type_names)); ++i) {
    if (cstrcmp(f, image_type_names[i]) == 0) break;
  }

  return (image_type_t) i;
}

static void srcbuild_add_option(char *option, char *value)
{
  if (!hash_enter(join_db, option, &join_entries[join_db_hwm])) {
    free(hash_value(join_db, join_entries[join_db_hwm]));
  }
  hash_assoc(join_db, join_entries[join_db_hwm], value);
  if (++join_db_hwm == MAX_JOIN_ENTRIES) {
    error(1, "Too many joiner options in components file");
  }
}

/*
 * read the components file into a linked list of records.
 */
int
read_component_database(char *filename)
{
  FILE *file;
  char buffer[BUFFER_LEN];
  char *cp, *word = NULL, *dependancy = NULL;
  component_entry_t *entry, *this, *prev = NULL;
  int i, dup, line_number = 0, component_count = 0;

  /*
   * work out components filename
   */
  sb_buildfilename(BUFFER_LEN, buffer, build_dir, BUILDSYS_DIR, COMPONENTS_DIR, filename, NULL);
  if ((file = fopen(buffer, "r")) == NULL)
    error(1, "cannot open component database file '%s'.", buffer);

  if (verbose)
    sb_printf("Using components file '%s'.\n", buffer);

  if (1) {
    while (fgets(buffer, sizeof(buffer), file)) {
      line_number++;
      chop_newline(buffer);
      if (buffer[0] != '#') {   /* ignore comments */
        dependancy = NULL;

        cp = extract_word(buffer, &word, FALSE);      /* extract the name */

        if (word != NULL) {     /* ignore null lines */
          if (cstrcmp(word, "%log") == 0) {     /* deal with log file */
            cp = extract_word(cp, &log_filename, TRUE);
          } else if (cstrcmp(word, "%image") == 0) {
            /* deal with image file */
            cp = extract_word(cp, &image_filename, TRUE);
          } else if (cstrcmp(word, "%messages") == 0) {
            /* deal with messages */
            cp = extract_word(cp, &messages_filename, FALSE);
            if (messages_filename) {
              srcbuild_rewrite_path_in_host_syntax(&messages_filename);
            }
          } else if (cstrcmp(word, "%joiner") == 0) {
            /* deal with BigSplit et al */
            cp = extract_word(cp, &joiner, FALSE);
          } else if (cstrcmp(word, "%joinerformat") == 0) {
            /* deal with format */
            cp = extract_word(cp, &joiner_format, FALSE);
          } else if (cstrcmp(word, "%include") == 0) {
            /* deal with includes */
            cp = extract_word(cp, &word, FALSE);
            if (cstrcmp(word, filename) == 0)
              error(1, "cannot recursively include '%s'.", filename);
            if (read_component_database(word))  /* recurse */
              goto exit_gracefully;
          } else if (cstrcmp(word, "%format") == 0) {
            cp = extract_word(cp, &word, FALSE);
            image_type = srcbuild_parse_format(word);
          } else if (*word == '%') {
            /* Pass this option to romlinker */
            char *data = NULL, *full = sb_strdup(cp);
            cp = extract_word(cp, &data, FALSE);
            srcbuild_add_option(word + 1, data?data:"");
            if (cstrcmp(word, "%poduleproduct") == 0) {
              podule_info.product = data;
            } else if (cstrcmp(word, "%poduledescription") == 0) {
              podule_info.descript = full;
              full = NULL;
            } else if (cstrcmp(word, "%poduleserial") == 0) {
              podule_info.serial = data;
            } else if (cstrcmp(word, "%podulestatus") == 0) {
              podule_info.status = data;
            } else if (cstrcmp(word, "%podulemanufacture") == 0) {
              podule_info.manuf = data;
            } else if (cstrcmp(word, "%podulepart") == 0) {
              podule_info.part = data;
            } else if (cstrcmp(word, "%poduledate") == 0) {
              podule_info.date = data;
            } else if (cstrcmp(word, "%sigstr") == 0) {
              /* deal with the signature word+1 eg NCOS */
              sigstr = data;
              if (signum && sigstr) {
                error(0, "dual signature declaration, using sigstr.");
              }
            } else if (cstrcmp(word, "%signum") == 0) {
              signum = data;
              if (signum && sigstr) {
                error(0, "dual signature declaration, using sigstr.");
              }
            } else if (cstrcmp(word, "%baseaddress") == 0) {
              base_address = data;
              rom_base_address = strtoul(base_address, NULL, 0);
              if (rom_base_address == 0) {
                rom_base_address = 0x03800000;
              }
            }
            else {
              /* Don't free data - we've got a hash table pointer to it */
            }
            free(full);
          } else {
            if ((dependancy = strchr(word, ':')) != NULL) {
              *dependancy = 0;
              dependancy++;
              if (lookup_component(dependancy) == NULL) {
                error(1, "attempt to depend '%s' on a non existent component "
                      "'%s' (line %d).", word, dependancy, line_number);
              }
            }
            if (word[0] == '-') {       /* module to remove */
              component_entry_t *last = NULL;
              if ((entry = lookup_component(word + 1)) == NULL) {
                error(1, "attempt to remove non existent component '%s' "
                      "(line %d).", word + 1, line_number);
              }
              entry = component_database;
              last = NULL;
              while (strcmp(entry->name, word + 1) != 0) {
                last = entry;
                entry = entry->next;
              }

              if (last == NULL)
                component_database = entry->next;
              else
                last->next = entry->next;

              if (entry->next == NULL) prev = entry->prev;

              release_component(entry);

            } else {
              if (lookup_module(word) == NULL) {
                error(1, "'%s' entry (line %d) not found in module database.",
                      word, line_number);
              }

              /* look to see if entry exists already */
              dup = 0;
              if ((entry = lookup_component(word)) != NULL) {
                if (image_type == image_type_other) {
                  /* Perhaps we don't want to warn about this */
                }
                else {
                  /* This warning is no longer much use, commented-out
                   error(0, "srcbuild: Duplicate component detected: %s", entry->name);
                   */
                  dup = 1;
                }
              }

              /* allocate a new entry */
              if ((this = malloc(sizeof(component_entry_t))) == NULL)
                error(1, "memory allocation error.");

              this->name = word;
              this->options = NULL;
              this->switch_on = NULL;
              this->install = NULL;
              this->next = NULL;
              this->type = UNDEF;
              this->prev = prev;
              this->next = NULL;
              this->duplicate = dup;
              this->always_clean = FALSE;             /* default state */
              this->force_clean = FALSE;              /* default state */
              this->no_component_sources = false;     /* default state */
              this->install_after_rom    = false;     /* default state */
              this->created_bbe_makefile = false;     /* default state */
              this->force_position = 0;
              /* Set the Resources directory inside Messages to use for this component */
              this->resource_sfx         = (component_count++ / 64) + 1;

              /* This feature isn't used in any components file I can find... ho hum */
              if (dependancy) {                       /* we have some dependancy */
                component_entry_t *follow, *tmp = lookup_component(dependancy);
                /* The new component gets inserted into the list just
                 * after the first instance of the component upon which
                 * it is dependent.
                 */
                follow     = tmp->next;
                this->next = follow;
                tmp->next  = this;
                this->prev = tmp;
                if (follow == NULL) {
                  prev = this;
                } else {
                  follow->prev = this;
                }
              } else {
                if (component_database == NULL) {
                  component_database = this;
                } else {
                  prev->next = this;
                }
                prev = this;
              }
              entry = this;
              word  = NULL;

              while (cp) {      /* while there is still text on line */
                /* get the options word */
                cp = extract_word(cp, &word, FALSE);
                if ((cstrcmp(word, "-options") == 0) && (cp)) {
                  entry->options = sb_strdup(cp);       /* rest of line */
                  entry->force_clean = TRUE;
                } else if (cstrcmp(word, "-switch") == 0) {
                  cp = extract_word(cp, &(entry->install), TRUE);
                  entry->force_clean = TRUE;
                } else if (cstrcmp(word, "-clean") == 0) {
                  entry->always_clean = TRUE;
                } else if (cstrcmp(word, "-nosources") == 0) {
                  entry->no_component_sources = true;
                } else if (cstrcmp(word, "-install_after_rom") == 0) {
                  entry->install_after_rom = true;
                } else if (cstrcmp(word, "-nosources") == 0) {
                  entry->no_component_sources = true;
                } else if (cstrcmp(word, "-install") == 0) {
                  cp = extract_word(cp, &(entry->install), TRUE);
                  if (entry->install) {
                    srcbuild_rewrite_path_in_host_syntax(&(entry->install));
                  }
                } else if (cstrcmp(word, "-type") == 0) {
                  cp = extract_word(cp, &word, FALSE);
                  for (i = 0; i < sizeof(module_type_names) / sizeof(char *); i++) {
                    if (cstrcmp(word, module_type_names[i]) == 0) {
                      entry->type = (module_type_t) i;
                      free(word);
                      word = NULL;
                      break;
                    }
                  }
                  if (word != NULL) {   /* module type not found */
                    error(1, "unknown module type '%s' in module database "
                          "line %d.", word, line_number);
                  }
                } else if (cstrcmp(word, "-address") == 0) {
                  cp = extract_word(cp, &word, FALSE);
                  entry->force_position = (unsigned) strtoul(word, NULL, 16);
                  if (entry->force_position)
                    entry->type = DATA;
                } else if (cstrcmp(word, "-at") == 0) {
                  cp = extract_word(cp, &word, FALSE);
                  entry->force_position = (unsigned) strtoul(word, NULL, 16);
                }
              }
            }
          }
        } /* if (word != NULL) */
      } /* if (buffer[0] != '#') */
    } /* while */
    component_database_end = prev;
  } /* if (1) */

exit_gracefully:
  if (file)
    fclose(file);
  if (word)
    free(word);

  return (0);
}

/*
 * make sure the force_clean flag hasn't been cleared for any
 * component which had -clean specified in the components file
 */
void
update_force_clean_states(void)
{
  component_entry_t *entry = component_database;

  while (entry)
  {
    if (entry->always_clean) entry->force_clean = TRUE;
    entry = entry->next;
  }
}

/*
 * free up any mallocs
 */
void
release_module_database(void)
{
  module_entry_t *entry, *this;

  entry = module_database;
  while (entry) {
    if (entry->name)
      free(entry->name);
    if (entry->path)
      free(entry->path);
    if (entry->output)
      free(entry->output);
    if (entry->filename)
      free(entry->filename);
    if (entry->switch_on)
      free(entry->switch_on);
    this = entry;
    entry = entry->next;
    free(this);
  }
}

void
release_component(component_entry_t * entry)
{
  if (entry->name)
    free(entry->name);
  if (entry->options)
    free(entry->options);
  if (entry->switch_on)
    free(entry->switch_on);
  if (entry->install)
    free(entry->install);
}

void
release_component_database(void)
{
  component_entry_t *entry, *this;

  entry = component_database;
  while (entry) {
    release_component(entry);
    this = entry;
    entry = entry->next;
    free(this);
  }
}

void
release_error_database(void)
{
  error_entry_t *entry, *this;

  entry = error_database;
  while (entry) {
    if (entry->message)
      free(entry->message);
    this = entry;
    entry = entry->next;
    free(this);
  }
}

/*
 * print a banner of characters
 */
void
banner(char c)
{
  char buffer[BUFFER_LEN];
  memset(buffer, c, BUFFER_LEN);
  buffer[78] = 0;
  sb_printf("%s\n", buffer);
}

/*
 * display usage info
 */
void
usage(void)
{
  const action_t *action;

  sb_printf("Pace '%s' version " APP_VERSION "\n\n", progname);

  sb_printf("Usage: %s [options] <action>\n", progname);
  sb_printf("Options:\n");
  sb_printf("   -h, -help    : display this message\n");
  sb_printf("   -v, -verbose : display more progress info\n");
  sb_printf("   -s, -strict  : abort on non-fatal errors\n");
  sb_printf("   -p, -phases  : show phases supported by this build\n");
  sb_printf("Actions:\n");

  for (action = &action_tbl[0]; action->call; action++)
    sb_printf("   %-12s : %s\n", action->name, action->help);
}

/*
 * tidy up before quiting
 */
void
doexit(void)
{
  error_entry_t *entry;
  int error = 0;

  release_module_database();
  release_component_database();

  entry = error_database;
  while (entry) {
    if (error == 0)
      sb_printf("Batched errors...\n");
    error++;
    sb_printf("Error %s\n", entry->message);
    entry = entry->next;
  }

  if (error)
  {
    banner('-');
    set_sys_vars(0); /* Inform other programs that the build failed */
  }
  else
  {
    set_sys_vars(1); /* Inform other programs that the build was successful */
  }

  spool_close(log_filename);

  release_error_database();
  if (build_name)
    free(build_name);
  if (build_dir)
    free(build_dir);
  if (image_filename)
    free(image_filename);
  if (log_filename)
    free(log_filename);
  if (image_size)
    free(image_size);
  if (sigstr)
    free(sigstr);
  if (signum)
    free(signum);
  if (messages_filename)
    free(messages_filename);
  if (joiner)
    free(joiner);
  if (joiner_format)
    free(joiner_format);
  if (base_address)
    free(base_address);

  if (podule_info.product)
    free(podule_info.product);
  if (podule_info.descript)
    free(podule_info.descript);
  if (podule_info.serial)
    free(podule_info.serial);
  if (podule_info.status)
    free(podule_info.status);
  if (podule_info.manuf)
    free(podule_info.manuf);
  if (podule_info.part)
    free(podule_info.part);
  if (podule_info.date)
    free(podule_info.date);
}




int main(int argc, char *argv[])
{
  const action_t *action;
  time_t now;
  int i, found, first;
  char* locale_list = NULL;
  int loop = 0;
  char* sys_var = NULL;

  /* Core CLX library initialisation is done immediately to ensure that all
   * the host-specific values are set correctly.
   */
  err_init(program_name(argv[0], progname, sizeof(progname)));
  host_init();
  sb_init();
  join_db = hash_new(MAX_JOIN_ENTRIES);
  for (i=0; i<sizeof(join_entries)/sizeof(*join_entries); ++i) {
    join_entries[i] = NULL;
  }

  atexit(doexit);

  /*
   * sort out flags etc
   */
  for (i = 1; i < argc; i++) {
    if (argv[i][0] != '-')
      break;
    if ((cstrcmp(argv[i], "-h") == 0) || (cstrcmp(argv[i], "-help") == 0)) {
      usage();
      exit(EXIT_FAILURE);
    } else if ((cstrcmp(argv[i], "-v") == 0) || (cstrcmp(argv[i], "-verbose") == 0))
      verbose = TRUE;
    else if ((cstrcmp(argv[i], "-s") == 0) || (cstrcmp(argv[i], "-strict") == 0))
      strict = TRUE;
    else if ((cstrcmp(argv[i], "-p") == 0) || (cstrcmp(argv[i], "-phases") == 0)) {
      show_phases_csv();
      exit(EXIT_SUCCESS);
    }
  }

  /*
   * check for action
   */
  if (argc < 2 || i >= argc) {
    usage();
    exit(EXIT_FAILURE);
  }
  first = i;                    /* record first non flag argument */

  /* If we don't have a list, but do have a single locale, set the locale list to be the single locale */
  if (!sb_getenv(ENV_LOCALE_LIST) && sb_getenv(ENV_LOCALE)) {
    sb_setenv(ENV_LOCALE_LIST, sb_getenv(ENV_LOCALE));
  }

  /* We need to see if a locale_list has been defined. If it has, we need to split it into a list of locales. */
  if ((locale_list = sb_strdup(sb_getenv(ENV_LOCALE_LIST))) != NULL)
  {
    if (!parse_territories(locale_list))
    {
      /* An error occured whilst parsing the locale list. */
      error (0, "Malformed Locale list detected.");
    }
    free (locale_list);
    locale_list = NULL; /* locale_list is no longer needed */
  }

  /* Create a system variable based on the country codes. */
  /* Allocate 2 bytes per territory plus one forthe terminator */
  if ((sys_var = malloc((MAX_TERRITORIES)*2+1)) == NULL)
  {
    error (1, "Could not allocate memory for temporary list.");
  }
  *sys_var = '\0';
  for (loop=0; loop < num_of_territories; loop++)
  {
    int num = 0;
    char *varname;
    char tempstr[5];
    num = sb_return_country_number(supported_territories[loop]);
    sb_printf("Country %s has a code of %d\n", supported_territories[loop], num);
    if (num < 0)
    {
      error (1, "Country %s is not a recognised territory.", supported_territories[loop]);
    }
    if (num > 99)
    {
      error (1, "Country %s has a territory number which is too high (%d > 99)", num);
    }
    sprintf(tempstr, "%02d", num);
    strcat(sys_var, tempstr);
    sprintf(tempstr, "%d", num);
    varname = malloc(strlen(supported_territories[loop]) + sizeof(TERR_NUM_PFX));
    if (varname)
    {
      sprintf(varname, "%s%s", TERR_NUM_PFX, supported_territories[loop]);
      sb_setenv(varname, tempstr);
      sprintf(varname, "%s%s", TERR_NAME_PFX, tempstr);
      sb_setenv(varname, supported_territories[loop]);
      free(varname);
    }
  }
  sb_setenv(ENV_NUM_LOCALE, sys_var);
  sb_printf("Numeric territory string is %s\n", sys_var);
  free (sys_var);
  sys_var=NULL;

  /*
   * we need to know Build$Dir and Build environment variables
   */
  if ((build_dir = sb_strdup(sb_getenv(ENV_BUILD_DIR))) == NULL)
    error(1, "cannot locate build directory, please run a !Env file.");

  if ((build_name = sb_strdup(sb_getenv(ENV_BUILD_NAME))) == NULL)
    error(1, "cannot identify build name, please run a !Env file.");

  if ((image_size = sb_strdup(sb_getenv(ENV_IMAGE_SIZE))) == NULL)
    error(1, "cannot establish a image size, please run a !Env file.");

  /* Call an initialision function for the build sequence */
  build_init();


  /*
   * read in our main files
   */
  read_module_database();
  read_component_database(build_name);
  if (image_type == image_type_unset) {
    image_type = image_type_main_rom;
  }
  read_shadow_component_database(build_name);
  update_force_clean_states();
  build_dirs();
  /*
   * start spooling
   */
  spool_open(log_filename);
  banner('-');

  /*
   * display some banner info
   */
  now = time(NULL);
  sb_printf("Started %s build : %s", build_name, asctime(localtime(&now)));


  if (verbose) {
    sb_printf("Log filename       : %s\n", CHK_STR(log_filename));
    sb_printf("Image filename     : %s\n", CHK_STR(image_filename));
    sb_printf("Messages location  : %s\n", CHK_STR(messages_filename));
    sb_printf("Image size         : %s\n", CHK_STR(image_size));
    sb_printf("Joiner application : %s\n", CHK_STR(joiner));
    sb_printf("Joiner format      : %s\n", CHK_STR(joiner_format));
    if (cstrcmp(joiner_format, "makeexprom") == 0) {
      sb_printf("Podule info ...\n");
      sb_printf("  Product code         : %s\n", CHK_STR(podule_info.product));
      sb_printf("  Description          : %s\n", CHK_STR(podule_info.descript));
      sb_printf("  Serial               : %s\n", CHK_STR(podule_info.serial));
      sb_printf("  Mod Status           : %s\n", CHK_STR(podule_info.status));
      sb_printf("  Place of manufacture : %s\n", CHK_STR(podule_info.manuf));
      sb_printf("  Part number          : %s\n", CHK_STR(podule_info.part));
      sb_printf("  Date                 : %s\n", CHK_STR(podule_info.date));
    }
  }
  /*
   * dispatch the action
   */
  banner('-');
  for (i = first; i < argc; i++) {
    found = FALSE;
    for (action = &action_tbl[0]; action->call; action++) {
      if (cstrcmp(action->name, argv[i]) == 0) {
        found = TRUE;
        break;
      }
    }
    if (!found) {
      usage();
      exit(EXIT_FAILURE);
    }
    sb_printf("Starting phase %s ...\n", action->name);
    (*(action->call)) ();
    banner('=');
  }

  now = time(NULL);
  sb_printf("Finished %s build : %s", build_name, asctime(localtime(&now)));
  banner('-');

  return (0);
}



@


1.34
log
@Added support for a new release_autobuild phase.

This new phase will initially only be required by a very small subset of
components which do some additional functionality at the very end of a
build process in order to wrap-up the build ready for the autobuilder to
do what it wants with the results.

Admin:
  Tested on Iyonix
Author:
  srevill

Version 0.46. Tagged as 'srcbuild-0_46'
@
text
@d429 4
d677 1
a677 1
                if (cstrcmp(word, "-options") == 0) {
@


1.33
log
@  Stopped errors about duplicate components.
Detail:
  This is something which is of particular annoyance with the "install"
  phase often meaning builds have the same component built multiple
  times (often with different options).
Admin:
  Works as expected.

Version 0.45. Tagged as 'srcbuild-0_45'
@
text
@d106 1
d615 1
a615 1
                   error(0, "srcbuild: Duplicate component detected: %s", entry->name); 
@


1.32
log
@  Bug fix/new feature.
Detail:
  When the same component is included in a build multiple times with
  different options, you can end up in a situation where the second time
  you do a build, the first instance of it isn't cleaned so you end up
  with the (incorrect) last set of options from the previous build and
  that's not good.

  Now, you can specify -clean in the components file for any component
  which you want to forcibly clean.

  I've also made some minor efficiency improvements by making the
  components list doubly-linked rather than singly-linked.
Admin:
  Tested in baseline 517 build and appears to do the job.

Version 0.44. Tagged as 'srcbuild-0_44'
@
text
@d613 3
a615 1
                  error(0, "srcbuild: Duplicate component detected: %s", entry->name);
@


1.31
log
@  Fixed some bugs.
Detail:
  The previous check-in broke Baseline builds (or any other build which
  has a components file within a subdirectory of the BuildSys/Components
  directory). Fixed.

  Also, where a build includes multiple instances of the same component
  to be built with dfferent options, the force clean rule was not being
  invoked if the build itself included a clean (or clean_all) phase.

  This meant that object files from the first time the component was built
  would still be resident for the next version(s). Now, duplicate components
  are flagged internally as being duplicate so their force_clean flag is not
  cleared during the clean or clean_all phases.
Admin:
  Tested in early Baseline 500 builds on Iyonix.

Version 0.41. Tagged as 'srcbuild-0_41'
@
text
@d89 2
a90 1
component_entry_t *component_database = NULL;
d212 18
d295 40
a334 40
      if (buffer[0] != '#') {	/* ignore comments */
	cp = buffer;
	cp = extract_word(cp, &word, FALSE);	/* extract the name */
	if (word != NULL) {	/* ignore null lines */
	  if (lookup_module(word) != NULL) {
	    error(1, "duplicate '%s' entry in module database line %d.",
		  word, line_number);
	  }
	  /* allocate a new entry */
	  if ((this = malloc(sizeof(module_entry_t))) == NULL)
	    error(1, "memory allocation error.");

	  this->name = word;
	  word = NULL;
	  this->path = NULL;
	  this->output = NULL;
	  this->filename = NULL;
	  this->switch_on = NULL;
	  this->type = UNDEF;
	  this->next = module_database;
	  module_database = this;
	  entry = this;

	  cp = extract_word(cp, &word, FALSE);
	  for (i = 0; i < sizeof(module_type_names) / sizeof(char *); i++) {
	    if (cstrcmp(word, module_type_names[i]) == 0) {
	      entry->type = (module_type_t) i;
	      free(word);
	      word = NULL;
	      break;
	    }
	  }
	  if (word != NULL) {	/* module type not found */
	    error(1, "unknown module type '%s' in module database line %d.",
		  word, line_number);
	  }
	  cp = extract_word(cp, &(entry->path), FALSE);
	  cp = extract_word(cp, &(entry->output), FALSE);
	  cp = extract_word(cp, &(entry->filename), FALSE);
	  cp = extract_word(cp, &(entry->switch_on), TRUE);
d385 1
a385 1
      cp = extract_word(cp, &name, FALSE);	/* extract the name */
d388 40
a427 39
	while (cp) {		/* while there is still text on line */
	  /* get the options word */
	  cp = extract_word(cp, &word, FALSE);
	  if (cstrcmp(word, "-options") == 0) {
	    options = sb_strdup(cp);	/* rest of line */
	  } else if (cstrcmp(word, "-switch") == 0) {
	    cp = extract_word(cp, &switch_on, TRUE);
	  }
	}

	options_same = FALSE;
	switch_same = FALSE;
	/* do we have any options */
	if (!component->options && !options)
	  options_same = TRUE;

	/* check out options first */
	if (component->options)
	  if (cstrcmp(component->options, options) == 0)
	    options_same = TRUE;

	/* now check out switches */
	if (component->switch_on) {
	  if (cstrcmp(component->switch_on, switch_on) == 0)
	    switch_same = TRUE;
	} else {
	  if ((module = lookup_module(name)) != NULL) {
	    if (module->switch_on) {
	      if (cstrcmp(component->switch_on, switch_on) == 0)
		switch_same = TRUE;
	    } else {
	      if (!switch_on)
		switch_same = TRUE;
	    }
	  }
	}
	/* mark the module for not needing clean */
	if (switch_same && options_same)
	  component->force_clean = FALSE;
d477 1
a477 1
  component_entry_t *entry, *this;
d494 2
a495 2
      if (buffer[0] != '#') {	/* ignore comments */
	dependancy = NULL;
d499 9
a507 9
	if (word != NULL) {	/* ignore null lines */
	  if (cstrcmp(word, "%log") == 0) {	/* deal with log file */
	    cp = extract_word(cp, &log_filename, TRUE);
	  } else if (cstrcmp(word, "%image") == 0) {
	    /* deal with image file */
	    cp = extract_word(cp, &image_filename, TRUE);
	  } else if (cstrcmp(word, "%messages") == 0) {
	    /* deal with messages */
	    cp = extract_word(cp, &messages_filename, FALSE);
d511 6
a516 6
	  } else if (cstrcmp(word, "%joiner") == 0) {
	    /* deal with BigSplit et al */
	    cp = extract_word(cp, &joiner, FALSE);
	  } else if (cstrcmp(word, "%joinerformat") == 0) {
	    /* deal with format */
	    cp = extract_word(cp, &joiner_format, FALSE);
d569 36
a604 33
	  } else {
	    if ((dependancy = strchr(word, ':')) != NULL) {
	      *dependancy = 0;
	      dependancy++;
	      if (lookup_component(dependancy) == NULL) {
		error(1, "attempt to depend '%s' on a non existent component "
		      "'%s' (line %d).", word, dependancy, line_number);
	      }
	    }
	    if (word[0] == '-') {	/* module to remove */
	      component_entry_t *last = NULL;
	      if ((entry = lookup_component(word + 1)) == NULL) {
		error(1, "attempt to remove non existent component '%s' "
		      "(line %d).", word + 1, line_number);
	      }
	      entry = component_database;
	      last = NULL;
	      while (strcmp(entry->name, word + 1) != 0) {
		last = entry;
		entry = entry->next;
	      }

	      if (last == NULL)
		component_database = entry->next;
	      else
		last->next = entry->next;
	      release_component(entry);

	    } else {
	      if (lookup_module(word) == NULL) {
		error(1, "'%s' entry (line %d) not found in module database.",
		      word, line_number);
	      }
d628 1
d631 1
d640 1
d642 14
a655 3
                component_entry_t *tmp = lookup_component(dependancy);
                this->next = tmp->next;
                tmp->next = this;
d657 1
a657 1
                if (component_database == NULL)
d659 2
a660 5
                else {
                  entry = component_database;
                  while (entry->next)
                    entry = entry->next;
                  entry->next = this;
d662 1
d665 55
a719 1
              word = NULL;
a720 50
	      while (cp) {	/* while there is still text on line */
		/* get the options word */
		cp = extract_word(cp, &word, FALSE);
		if (cstrcmp(word, "-options") == 0) {
		  entry->options = sb_strdup(cp);	/* rest of line */
		  entry->force_clean = TRUE;
		} else if (cstrcmp(word, "-switch") == 0) {
		  cp = extract_word(cp, &(entry->install), TRUE);
		  entry->force_clean = TRUE;
		} else if (cstrcmp(word, "-nosources") == 0) {
		  entry->no_component_sources = true;
		} else if (cstrcmp(word, "-install_after_rom") == 0) {
		  entry->install_after_rom = true;
		} else if (cstrcmp(word, "-nosources") == 0) {
		  entry->no_component_sources = true;
		} else if  (cstrcmp(word, "-install") == 0) {
		  cp = extract_word(cp, &(entry->install), TRUE);
		  if (entry->install) {
		    srcbuild_rewrite_path_in_host_syntax(&(entry->install));
		  }
		} else if (cstrcmp(word, "-type") == 0) {
		  cp = extract_word(cp, &word, FALSE);
		  for (i = 0; i < sizeof(module_type_names) / sizeof(char *); i++) {
		    if (cstrcmp(word, module_type_names[i]) == 0) {
		      entry->type = (module_type_t) i;
		      free(word);
		      word = NULL;
		      break;
		    }
		  }
		  if (word != NULL) {	/* module type not found */
		    error(1, "unknown module type '%s' in module database "
			  "line %d.", word, line_number);
		  }
		} else if (cstrcmp(word, "-address") == 0) {
		  cp = extract_word(cp, &word, FALSE);
		  entry->force_position = (unsigned) strtoul(word, NULL, 16);
		  if (entry->force_position)
		    entry->type = DATA;
		} else if (cstrcmp(word, "-at") == 0) {
		  cp = extract_word(cp, &word, FALSE);
		  entry->force_position = (unsigned) strtoul(word, NULL, 16);
		}
	      }
	    }
	  }
	}
      }
    }
  }
d731 16
d972 1
a972 1
  first = i;			/* record first non flag argument */
d1056 1
d1097 2
a1098 2
	found = TRUE;
	break;
@


1.30
log
@  * Added support for the clean_all phase.
  * Slight tweak to (ram) install phase.
  * Corrected utterly insignificant comment in clean phase.
Detail:
  * Some of the major libraries (i.e. Desk and RISC_OSLib) do not really clean
    themselves in their 'clean' phase; you have to run 'clean_all' on them to
    do this. This is a pain in the proverbial for Baseline builds because you
    have to export from libraries twice - once 26bit and once 32bit. You MUST
    fully 'clean_all' libraries or you get objects of the wrong APCS exported.

    Soooo, rather than having to go through all my libraries running both
    'clean' and 'clean_all' on each manually, I've added the 'clean_all'
    option to srcbuild (and !Builder), separate from a simple 'clean'.

  * If "INSTDIR=" is one of the options passed from a Components file in the
    '-options' for a component, the install phase does not add "INSTDIR=foo"
    onto the amu command line itself (resulting in two, the latter being
    valid). This results in shorter command lines (which aren't in themselves
    much of a problem) that are a little easier to read.
Admin:
  Tested in Baseline builds.

Version 0.38. Tagged as 'srcbuild-0_38'
@
text
@d458 1
a458 1
  int i, line_number = 0, component_count = 0;
d584 1
d591 1
d606 1
@


1.29
log
@  Passes the options *after* all other options when running amu.
Detail:
  If you don't, you can't override defaults by specifying them in the
    -options part of the components file.
Admin:
  Built.


Version 0.36. Tagged as 'srcbuild-0_36'
@
text
@d95 1
@


1.28
log
@  messages_filename is no longer permitted to be an environment variable.
Detail:
  Fixes for Linux version.
Admin:
  Work in progress - checkin point.


Version 0.33. Not tagged
@
text
@d94 11
a104 11
  build_clean, "clean", "clean the build",
  build_export_hdrs, "export_hdrs", "export headers",
  build_export_libs, "export_libs", "export libraries",
  build_resources, "resources", "export resources",
  build_bbe, "bbe", "export binary build structure",
  build_rom, "rom", "make modules for rom",
  build_install_rom, "install_rom", "install components",
  build_install, "install", "create RAM versions of the components",
  build_join, "join", "join modules to construct rom",
  build_list, "list", "list all modules to appear in rom",
  0, 0, 0, 0
@


1.27
log
@  Several little updates.
Detail:
  The RESDIR setting passed down to components is now fixed to be
    <Resource$Dir>.Resources for the first 64 components,
    <Resource$Dir>.Resources2 for the next 64,
    <Resource$Dir>.Resources3 for the next 64 etc.
    Currently most components explicitly override srcbuild's suggestion,
    but this is dangerous (could cause weird resource problems on old
    build machines).  64 chosen since it is comfortably less than 77.
  If a component appears twice in the components file(s), it is warned
    about.
  The default selection of image type (rom, exprom, extrom, other) is
    delayed until all components files are parsed - previously the choice
    would have been made at the end of any included file.
  BBE builds can cope with components that host multiple targets - notably
    the territory modules.  This used to fail previously (and required the
    entire sources of the component to be shipped) since only one target,
    the last to be processed, would be written into the BBE Makefile.
Admin:
  Tested briefly with various builds.

Version 0.31. Tagged as 'srcbuild-0_31'
@
text
@d486 1
a486 1
	    cp = extract_word(cp, &messages_filename, TRUE);
@


1.26
log
@  More wide-ranging changes to srcbuild for portability and romlinker.
Detail:
  The romlinker joiner format is now defined and implemented by srcbuild.
    This means that srcbuild can invoke romlinker to join main ROMs,
    expansion ROMs or extension ROMs depending on a switch in a product's
    components file (the %format directive should specify a value of one
    of rom extrom or exprom).
  Any %-directives that are not srcbuild directives are passed through to
    romlinker as command-line options.  All target image sizes are passed
    through in bytes - see romlinker documentation for full details of the
    interfaces.
  Environment variables are set to represent the territory mappings.  This
    is done on all targets so that other tools can rely on retrieving the
    information via getenv() and not needing to prod the International
    module directly.
  extern declarations removed from .c files into .h files to remove chance
    of mismatched multiple declarations.
  Some spelling corrections in comments, system call synchronisation calls
    added, although sb_system does not implement parallel makes yet.
  Documentation added on the portability aspects, environmental aspects and
    the territory mapping stuff.  A program is provided (MkDefaults) to
    run under RISC OS to generate up-to-date source code for srcbuild's
    territory information database.
  srcbuild now keeps note of the type of image that it is generating, rather
    than relying on reverse-engineering it from the joiner and joiner format
    strings (set by %format in the component file, defaults to main ROM)
  Many comments updated to reflect the actual code, some obsolete code
    removed.
Admin:
  This version should represent a functionally complete version capable of
    running cross-compiled builds on UNIX systems.
  Tested on RISC OS.

Version 0.27. Tagged as 'srcbuild-0_27'
@
text
@d457 1
a457 1
  int i, line_number = 0;
d553 1
a553 1
		error(1, "attempt to depend '%s' on a non existant component "
d560 1
a560 1
		error(1, "attempt to remove non existant component '%s' "
a580 32
	      /* look to see if entry exists already */
//	      if ((entry = lookup_component(word)) == NULL) {
		/* allocate a new entry */
		if ((this = malloc(sizeof(component_entry_t))) == NULL)
		  error(1, "memory allocation error.");

		this->name = word;
		this->options = NULL;
		this->switch_on = NULL;
		this->install = NULL;
		this->next = NULL;
		this->type = UNDEF;
		this->next = NULL;
		this->force_clean = FALSE;              /* default state */
		this->no_component_sources = false;     /* default state */
		this->install_after_rom    = false;     /* default state */
		this->force_position = 0;

		if (dependancy) {	/* we have some dependancy */
		  component_entry_t *tmp = lookup_component(dependancy);
		  this->next = tmp->next;
		  tmp->next = this;
		} else {
		  if (component_database == NULL)
		    component_database = this;
		  else {
		    entry = component_database;
		    while (entry->next)
		      entry = entry->next;
		    entry->next = this;
		  }
		}
d582 45
a626 3
		entry = this;
//	      }
	      word = NULL;
d645 3
a683 4
  if (image_type == image_type_unset) {
    image_type = image_type_main_rom;
  }

d950 4
d993 3
@


1.25
log
@  Portable version of srcbuild.
  Has initial knowledge of the romlinker tool - work incomplete.
Detail:
  This is a portable version of srcbuild.  It is no longer tied to various
    RISC OS concepts such as: global shared environment namespace;
    *Spool; . as directory separator (host's directory separator is read
    during program startup).
  UNIX version stores the "system variables" in a hash table and exports
    the contents of the environment hash table to new processes which it
    forks.  UNIX version does not parallelise builds currently - in theory
    with a little more intelligence in sb_system to manage the log file
    coherently, it should be possible to parallelise some actions during
    builds (because it will avoid blocking srcbuild when waiting for I/O,
    and because changing the environment in the parent srcbuild process
    won't affect any children that are still running)
  A lot of things have changed in this version - many functions have been
    renamed to avoid clashes with UNIX system calls (most calls in riscos.c
    in fact); printf/fprintf(stderr...) are no longer used directly -
    sb_printf/sb_fprintf is used instead to ensure data is copied to the
    log file.
  ROM joining works on Solaris if you supply the Install/<Build> directory
    fully populated with files from a RISC OS build which comprise the
    ROM image.  Identical images are produced (with: romlinker -format rom).
  This version of srcbuild cannot use romlinker to build anything other
    than ROM images - syntax for specifying expansion/extension images
    is yet to be implemented.  To test, set %Joiner and %JoinerFormat to
    romlinker in your Components file (and put romlinker in your library
    directory if you do not have a RiscOS/Library/Build which includes it)
  Removed some duplicated code that calculated ROM positions when an install_rom
    phase had not been run but a join had been requested - build_install_rom
    is now parameterised to enable the BBE generator, join phase and normal
    install_rom activities to be done by one function instead of three nearly
    identical bits of code.
  Anything other than list or join requires a compatible Makefile in each
    component in the build.
Admin:
  Tested, although not exhaustively, under RISC OS.
  Tested list & join phases on Intel Solaris.
  romlinker integration tested briefly.

Version 0.26. Tagged as 'srcbuild-0_26'
@
text
@d67 3
d73 7
a376 4
/*         sb_printf("found option %s\n",CHK_STR(options)); */
/*         sb_printf("found switch %s\n",CHK_STR(switch_on)); */
/*         sb_printf("comp  option %s\n",CHK_STR(component->options)); */
/*         sb_printf("comp  switch %s\n",CHK_STR(component->switch_on)); */
d424 23
d469 2
a470 3
  while (!feof(file)) {
    fgets(buffer, sizeof(buffer), file);
    if (!feof(file)) {
d476 2
a477 2
	cp = buffer;
	cp = extract_word(cp, &word, FALSE);	/* extract the name */
d496 52
a547 40
	  } else if (cstrcmp(word, "%poduleproduct") == 0) {
	    /* deal with podule bits */
	    cp = extract_word(cp, &(podule_info.product), FALSE);
	  } else if (cstrcmp(word, "%poduledescription") == 0) {
	    podule_info.descript = sb_strdup(cp);
	  } else if (cstrcmp(word, "%poduleserial") == 0) {
	    cp = extract_word(cp, &(podule_info.serial), FALSE);
	  } else if (cstrcmp(word, "%podulestatus") == 0) {
	    cp = extract_word(cp, &(podule_info.status), FALSE);
	  } else if (cstrcmp(word, "%podulemanufacture") == 0) {
	    cp = extract_word(cp, &(podule_info.manuf), FALSE);
	  } else if (cstrcmp(word, "%podulepart") == 0) {
	    cp = extract_word(cp, &(podule_info.part), FALSE);
	  } else if (cstrcmp(word, "%poduledate") == 0) {
	    cp = extract_word(cp, &(podule_info.date), FALSE);
	  } else if (cstrcmp(word, "%sigstr") == 0) {
	    /* deal with the signature word eg NCOS */
	    cp = extract_word(cp, &sigstr, FALSE);
	    if (signum && sigstr) {
	      error(0, "dual signature declaration, using sigstr.");
	    }
	  } else if (cstrcmp(word, "%signum") == 0) {
	    cp = extract_word(cp, &signum, FALSE);
	    if (signum && sigstr) {
	      error(0, "dual signature declaration, using sigstr.");
	    }
	  } else if (cstrcmp(word, "%include") == 0) {
	    /* deal with includes */
	    cp = extract_word(cp, &word, FALSE);
	    if (cstrcmp(word, filename) == 0)
	      error(1, "cannot recursively include '%s'.", filename);

	    if (read_component_database(word))	/* recurse */
	      goto exit_gracefully;
	  } else if (cstrcmp(word, "%baseaddress") == 0) {
	    cp = extract_word(cp, &base_address, FALSE);
	    rom_base_address = strtoul(base_address, NULL, 0);
	    if (rom_base_address == 0) {
	      rom_base_address = 0x3800000;
	    }
d671 4
d871 4
d906 6
a911 1
  /* We need to see if a locale_list has been defined. If it has, we need to split it into a lit of locales. */
d916 1
a916 1
      /* An error occured whilst parsing the loale list. */
a921 17
  else
  {
    /* There was no locale list, so use the locale env instead. */
    char* locale = NULL;
    if ((locale = sb_strdup(sb_getenv(ENV_LOCALE))) != NULL)
    {
      supported_territories[num_of_territories++] = sb_strdup(locale);
    }
    /* The rest of the system expects the ENV_LOCALE_LIST var to be set. Set it to be the same as the locale. */
    sb_setenv(ENV_LOCALE_LIST, locale);

    if (locale) /* Usual memory-tidying gubbins */
    {
      free (locale);
      locale = NULL;
    }
  }
d933 1
d943 10
d973 1
@


1.24
log
@  BBE phase added.
Detail:
  Lots of code changed - see branch logs for details.
Admin:
  The Binary Build Environment development has been done on a branch
    and is now considered stable for merge to the trunk.
  Tested in BBE.

Version 0.25. Tagged as 'srcbuild-0_25'
@
text
@d31 8
d44 4
d51 1
a51 1
char *progname = NULL;
a64 1
char *base_address = NULL;
d70 5
a74 2
/* Create an array in which territories defined in the Env file can be stored. */
char* supported_territories[MAX_TERRITORIES] = NULL;
d102 1
a102 1
    printf("%s,%s\n", action->name, action->help);
d110 1
d112 4
a115 4
  sprintf(buffer, "%s.%s.%s.%s", build_dir, BUILDSYS_DIR, LOGS_DIR, log_filename);
  setenv("SrcBuild$LogfileLocation", buffer);
  sprintf(buffer, "%s.%s.%s", build_dir, IMAGES_DIR, image_filename);
  setenv("SrcBuild$ImageLocation", buffer);
d117 5
a121 1
  setenv("SrcBuild$ReturnCode", buffer);
d143 1
a143 1
  this->message = strdup(buffer);
d145 1
a145 1
  printf("Error %s\n", this->message);
d157 1
a157 1
    fprintf(stderr, "Fatal error ");
d159 1
a159 1
    fprintf(stderr, buffer);
d200 38
d253 1
a253 1
  sprintf(buffer, "%s.%s.%s", build_dir, BUILDSYS_DIR, MODULE_DB_FILE);
d258 1
a258 1
    printf("Using module database '%s'.\n", buffer);
d305 3
a307 1
	}
d341 1
a341 1
  sprintf(buffer, "%s.%s.%s.%s", build_dir, BUILDSYS_DIR, SHADOW_DIR, filename);
d346 1
a346 1
    printf("Using shadow components file '%s'.\n", buffer);
d362 1
a362 1
	    options = strdup(cp);	/* rest of line */
d367 4
a370 4
/*         printf("found option %s\n",CHK_STR(options)); */
/*         printf("found switch %s\n",CHK_STR(switch_on)); */
/*         printf("comp  option %s\n",CHK_STR(component->options)); */
/*         printf("comp  switch %s\n",CHK_STR(component->switch_on)); */
d433 1
a433 1
  sprintf(buffer, "%s.%s.%s.%s", build_dir, BUILDSYS_DIR, COMPONENTS_DIR, filename);
d438 1
a438 1
    printf("Using components file '%s'.\n", buffer);
d459 3
d472 1
a472 1
	    podule_info.descript = strdup(cp);
d498 1
a498 1
	      error(1, "cannot recursivly include '%s'.", filename);
d504 4
d582 1
a582 1
		  entry->options = strdup(cp);	/* rest of line */
d711 1
a711 1
  printf("%s\n", buffer);
d722 1
a722 1
  printf("Pace '%s' version " APP_VERSION "\n\n", progname);
d724 7
a730 7
  printf("Usage: %s [options] <action>\n", progname);
  printf("Options:\n");
  printf("   -h, -help    : display this message\n");
  printf("   -v, -verbose : display more progress info\n");
  printf("   -s, -strict  : abort on non-fatal errors\n");
  printf("   -p, -phases  : show phases supported by this build\n");
  printf("Actions:\n");
d733 1
a733 1
    printf("   %-12s : %s\n", action->name, action->help);
d751 1
a751 1
      printf("Batched errors...\n");
d753 1
a753 1
    printf("Error %s\n", entry->message);
d821 7
a827 1
  progname = argv[0];
d859 1
a859 1
  if ((locale_list = read_env(ENV_LOCALE_LIST)) != NULL)
d873 1
a873 1
    if ((locale = read_env(ENV_LOCALE)) != NULL)
d875 1
a875 1
      supported_territories[num_of_territories++] = strdup(locale);
d878 1
a878 1
    setenv(ENV_LOCALE_LIST, locale);
d888 2
a889 1
  if ((sys_var = malloc(30)) == NULL) /* Choose 30, as numbers are 2 digits, and we allow up to 10 territories per build. 21 *should* be beough in theory. */
d893 1
a893 1
  strcpy(sys_var,"");
d898 2
a899 2
    num = return_country_number(supported_territories[loop]);
    printf("Country %s has a code of %d\n", supported_territories[loop], num);
d907 4
a910 7
  setenv(ENV_NUM_LOCALE, sys_var);
  printf("Numeric territory string is %s\n", sys_var);
  if (sys_var)
  {
    free (sys_var);
    sys_var=NULL;
  }
d915 1
a915 1
  if ((build_dir = read_env(ENV_BUILD_DIR)) == NULL)
d918 1
a918 1
  if ((build_name = read_env(ENV_BUILD_NAME)) == NULL)
d921 1
a921 1
  if ((image_size = read_env(ENV_IMAGE_SIZE)) == NULL)
d944 1
a944 1
  printf("Started %s build : %s", build_name, asctime(localtime(&now)));
d948 6
a953 6
    printf("Log filename       : %s\n", CHK_STR(log_filename));
    printf("Image filename     : %s\n", CHK_STR(image_filename));
    printf("Messages location  : %s\n", CHK_STR(messages_filename));
    printf("Image size         : %s\n", CHK_STR(image_size));
    printf("Joiner application : %s\n", CHK_STR(joiner));
    printf("Joiner format      : %s\n", CHK_STR(joiner_format));
d955 8
a962 8
      printf("Podule info ...\n");
      printf("  Product code         : %s\n", CHK_STR(podule_info.product));
      printf("  Description          : %s\n", CHK_STR(podule_info.descript));
      printf("  Serial               : %s\n", CHK_STR(podule_info.serial));
      printf("  Mod Status           : %s\n", CHK_STR(podule_info.status));
      printf("  Place of manufacture : %s\n", CHK_STR(podule_info.manuf));
      printf("  Part number          : %s\n", CHK_STR(podule_info.part));
      printf("  Date                 : %s\n", CHK_STR(podule_info.date));
d981 1
a981 1
    printf("Starting phase %s ...\n", action->name);
d987 1
a987 1
  printf("Finished %s build : %s", build_name, asctime(localtime(&now)));
@


1.23
log
@First attempt to allow a HAL/bootloader to be placed at the bottom of the
ROM; new component type is "HAL".
Performing a Join only when DATA components are in the build should now
work again.

Version 0.24. Tagged as 'srcbuild-0_24'
@
text
@d74 1
d83 3
d87 3
d656 1
a656 1
  printf("Acorn '%s' version " APP_VERSION "\n\n", progname);
d663 1
d771 4
@


1.23.2.1
log
@  Intermediate development version of the Binary Build Environment support.
Detail:
  A new action 'bbe' has been created which generates a binary build
    environment in the Install.BBE directory.  This directory contains a
    self-contained environment in which ROM builds can be performed using
    only the pre-built binaries of modules and the parts of the modules'
    resources required for a particular project.
Admin:
  Requires BuildSys 2.81 or later (RiscOS/BuildSys; tag: BuildSys-2_81)
  Requires Library 0.60 or later (RiscOS/Library; tag: Library-0_60)

  Work in progress - checkpoint only.

Version 0.24, 1.23.2.1. Tagged as 'srcbuild-0_24-1_23_2_1'
@
text
@a73 1
  build_bbe, "bbe", "export binary build structure",
@


1.23.2.2
log
@  More BBE changes.
Detail:
  New CLI option: -p outputs a CSV file containing the supported phases
    and their help strings.
  Pluralises territory correctly in output messages.
  Removes BBE_Res and BBE_ROM directories from installed BBE.
Admin:
  Tested in BBE.

Version 0.24, 1.23.2.4. Tagged as 'srcbuild-0_24-1_23_2_4'
@
text
@a82 3
static void show_phases_csv(void)
{
  const action_t *action;
a83 3
  for (action = &action_tbl[0]; action->call; action++)
    printf("%s,%s\n", action->name, action->help);
}
d650 1
a650 1
  printf("Pace '%s' version " APP_VERSION "\n\n", progname);
a656 1
  printf("   -p, -phases  : show phases supported by this build\n");
a763 4
    else if ((cstrcmp(argv[i], "-p") == 0) || (cstrcmp(argv[i], "-phases") == 0)) {
      show_phases_csv();
      exit(EXIT_SUCCESS);
    }
@


1.22
log
@  Now works without LocaleList env variable being set.
Detail:
  If the LocaleList system variable is unset, then srcbuild now sets it to
the value contained in the Locale Env var. This is because other parts of the
system (particulalry the Messages makefile) rely on LocaleList being set.
Admin:
  Tested on a Lazarus build without LocaleList beig set.

Version 0.21. Tagged as 'srcbuild-0_21'
@
text
@d538 1
a538 1
		  entry->force_position = (unsigned) strtol(word, NULL, 16);
d541 3
@


1.21
log
@	Fixed an 'OflaOfla bug.'
	Resource directory ordering changed.

Detail:
	Fixed a bug where directories called 'oflaofla...' were being created
in the Install directory. Srcbuild iterates through all the components in the
components file, and attempts to create the relevant install directory.
Unfortunatley, many components (e.g. HdrSrc) do not have an install directory
in the ModuleDB. This was causing a string to be printed with a NULL pointer,
causing oflaofla to be created as part of the directory leaf.
	As part of the work to allow multiple territories to be present in
one build, we are altering the resource directories so they are now held in the
following manner:
	Used to be : Messages.Resources.<locale>.<build>
	Is now :     Messages.Resources.<build>.<numeric terriory list>.<locale>
	Where the numeric territory list is a list of all the territories
held in the resources directory, eg. 000106 for Common, UK and France. The
Common directory holds all resources that are common to the other territories
and is generated by the Messages module. Note that if there are three
territories, then there will be four directories held in resources, one for
each territory and one for the Common directory.

Admin:
	Used in some Lazarus builds
	Very much work in progress. Use at your peril. Being checked in early
due to the anticiapted CVS server changes.
	Obbiously when you use this latest version, you will need to run the
resources phase because the formatting has changed.

Version 0.20. Tagged as 'srcbuild-0_20'
@
text
@d786 1
a786 1
    if ((locale = read_env(ENV_LOCALE_LIST)) != NULL)
d790 3
@


1.20
log
@	* Initial support for multiple territories in one build.

Admin:
	For the Bethany project we need to be able to build multiple resource
(territory) sets into one ROM build. The system variable LocaleList is read
and, if set, is parsed for a comma-seperated list of countries. The resources
phase is then called once for each of these countries. If the LocaleList flag
is unset then is should build the territory as set in the Locale in the Env
file.
	If the LocaleList flag is set then after the resources phase has been
run there should be one directory in the Internet.Messages path for each
territory mentioned in the LocaleList.
	To allow this to work the Common and Env files also need altering. If
the Env file does not have a LocaleList then it should have en explicit Unset
LocaleList. The common file also needs to have every *Set that references
<Locale> to be changed to a *SetMacro.

Admin:
	Work in progress for Bethany project. Only partially tested. A binary
checkin will follow after more work and testing.

Version 0.19. Tagged as 'srcbuild-0_19'
@
text
@d63 1
d153 1
d732 4
a735 2
int
main(int argc, char *argv[])
d741 2
d781 41
@


1.19
log
@	Each component can now havw a -nosources flag.

Detail:
 	There is a requirement for a customer to get a binary-only build
where they can change resources and do their own builds. To allow this we
will be providing them with a prebuilt disc image for the project with almost
all the sources deleted.
	To allow them to build images, have added the functionality to
SrcBuild whereby adding a -nosources flag to a component in the components
file causes clean, export_hdrs, export_libs and rom phases to have no effect.
This allows the client to build with resources, install_rom and join phases
and thus get an image with any changed resources in.
 	This change should only affect components that have a -nsources flag
in the component file.

Admin:
	Tested in a Lazarus build.

Version 0.18. Tagged as 'srcbuild-0_18'
@
text
@d48 1
d59 4
d467 1
a467 1
	      if ((entry = lookup_component(word)) == NULL) {
d479 3
a481 2
		this->force_clean = FALSE;	/* default state */
		this->no_component_sources = false;     /*default state */
d500 1
a500 1
	      }
d514 4
d736 1
d765 12
d857 2
@


1.18
log
@	Changed handling of amu_machine in srcbuild.

Details:
	Changed way in which srcbuild uses amu_machine to get around RISC OS
3.7 limitions on command line length.  Now expands amu_machine alias
internally, which means that long command lines in builds will now work
correcltly.

	Tidied build system to create and clean up its "o" folder correctly,
and to clean it's dynamic dependencies.

Admin:
	Tested on several Lazarus builds. Committed on behalf of JBeranek

Version 0.16. Tagged as 'srcbuild-0_16'
@
text
@d475 1
d506 2
@


1.17
log
@Summary
  *  Added support for install: targets
  *  Added support for podule ROM builds.

Detail
  *  Added support to pass 'install' as a valid parameter.  This allows
     disc builds and podule rom builds to be completed.
  *  Added knowledge of MakeExpROM as a valid joiner app.
Admin
  *  Tested install: work using a dummy Baseline 3 build.
  *  Tested MakeExpROM work using RiscOS/BuildSys/EtherI16E as a basis.
     srcbuild produces an indentical ROM to the old-style build system for
     populated roms and roms only containing podule ID information.

Version 0.15. Tagged as 'srcbuild-0_15'
@
text
@d763 3
@


1.16
log
@ 	Fixed a bug in srcbuild where a fatal error caused the
SrcBuild$ReturnCode system variable to be set to 1 (representing a successful
build) instead of 0 (representing a failed build).

Details:
	Whether the build was successful or not is determined by whether an
error is present in the error table. If the error was flagged as being a
fatal one, then exit() was being called *before* the error was added to the
error table. Hence when the atexit()-registered routine was called, there were
no errors in the error table and the system variable was being set as 1.
	Fixed by moving the exit() call that occurs in the error() routine
past the code that enters the error into the error table.

Admin:
	Tested in a deliberately-botched Customer M build.

Version 0.14. Tagged as 'srcbuild-0_14'
@
text
@d70 1
d470 1
d503 1
a503 1
		  cp = extract_word(cp, &(entry->switch_on), TRUE);
d505 2
d578 2
d790 1
a790 1
    if (cstrcmp(joiner_format, "podule") == 0) {
d792 7
a798 7
      printf("  Product code        : %s\n", CHK_STR(podule_info.product));
      printf("  Description         : %s\n", CHK_STR(podule_info.descript));
      printf("  Serial              : %s\n", CHK_STR(podule_info.serial));
      printf("  Mod Status          : %s\n", CHK_STR(podule_info.status));
      printf("  Pace of manufacture : %s\n", CHK_STR(podule_info.manuf));
      printf("  Part number         : %s\n", CHK_STR(podule_info.part));
      printf("  Date                : %s\n", CHK_STR(podule_info.date));
@


1.15
log
@Introduced the idea of a "DATA" module.

Version 0.13. Tagged as 'srcbuild-0_13'
@
text
@a106 6
  if (fatal || strict) {
    fprintf(stderr, "Fatal error ");
    strcat(buffer, "\n");
    fprintf(stderr, buffer);
    exit(EXIT_FAILURE);
  }
d122 8
@


1.14
log
@Altered the code to set three system variables on program exit:
SrcBuild$ImageLocation		The location of the build image.
SrcBuild$LogfileLocation	The location of the build logfile.
SrcBuild$ReturnCode		Whether the build was successful or not.

 Also altered the install phase to install the executable in library.build instead of library, making it install into the correct place for the new library structure.
 Altered the exit(1) calls to be exit(EXIT_FAILURE)


Version 0.11. Tagged as 'srcbuild-0_11'
@
text
@d518 2
@


1.13
log
@Summary
    Committing a couple of changes made long ago for Daytona but forgotten
    about:
      * Name of Messages module no longer hardwired.  Assumes Messages module
        is same name as leaf of Messages tag is the build's components file.
      * New 'BaseAddress' tag for components file allows base address of image
        to be specified e.g. for Daytona appflash.
Admin
    Sources compiled.
    A version merged with recent sources (version 0.07) has been tested in a
    couple of ROM builds.

Version 0.09. Tagged as 'srcbuild-0_09'
@
text
@d75 18
d111 1
a111 1
    exit(1);
d656 1
d658 6
d725 1
a725 1
      exit(1);
d737 1
a737 1
    exit(1);
d805 1
a805 1
      exit(1);
a811 1

d818 1
@


1.12
log
@Added "-address <n>" option to place a component at a fixed address (for
nefarious purposes - it won't be linked into the module chain, so only useful
for some sort of embedded data).

Version 0.08. Tagged as 'srcbuild-0_08'
@
text
@d52 1
d405 2
d663 2
@


1.11
log
@Allow multiple words for the -options field.
Support the new flags for BigSplit2 for ROM signature.

Version 0.04. Tagged as 'srcbuild-0_04'
@
text
@d36 1
a36 1
/* 
d74 1
a74 1
/* 
d111 1
a111 1
/* 
d128 1
a128 1
/* 
d145 1
a145 1
/* 
d157 1
a157 1
  /* 
d225 1
a225 1
/* 
d243 1
a243 1
  /* 
d323 1
a323 1
/* 
d335 1
a335 1
  /* 
d450 1
d494 3
d580 1
a580 1
/* 
d592 1
a592 1
/* 
d613 1
a613 1
/* 
d687 1
a687 1
  /* 
d702 1
a702 1
  /* 
d711 1
a711 1
  /* 
d723 1
a723 1
  /* 
d730 1
a730 1
  /* 
d736 1
a736 1
  /* 
d761 1
a761 1
  /* 
@


1.10
log
@Modified sources to use VersionNum scheme.

Version 0.03. Tagged as 'srcbuild-0_03'
@
text
@d39 33
a71 28
char *progname=NULL;
char *build_name=NULL;
char *build_dir=NULL;
char *image_filename=NULL;
char *log_filename=NULL;
char *messages_filename=NULL;
char *joiner=NULL;
char *joiner_format=NULL;
char *image_size=NULL;
podule_info_t podule_info = {NULL,NULL,NULL,NULL,NULL,NULL,NULL};
char *module_type_names[]={ALL_MODULE_TYPES(ARRAY_ENTRY)};
int  verbose=FALSE;
int  strict =FALSE;

module_entry_t    *module_database=NULL;
component_entry_t *component_database=NULL;
error_entry_t     *error_database=NULL;

static const action_t action_tbl[] = {
 build_clean,		"clean",	"clean the build",
 build_export_hdrs,	"export_hdrs",	"export headers",
 build_export_libs,	"export_libs",	"export libraries",
 build_resources,	"resources",	"export resources",
 build_rom,		"rom",		"make modules for rom",
 build_install_rom,	"install_rom",	"install components",
 build_join,		"join",		"join modules to construct rom",
 build_list,		"list",		"list all modules to appear in rom",
 0,0,0,0
d78 1
a78 1
error(int fatal, char *format, ...)
d82 3
a84 3
  error_entry_t *entry,*this;
  
  va_start (list, format);
d87 5
a91 6
  
  if (fatal || strict)
  {
    fprintf(stderr,"Fatal error ");
    strcat(buffer,"\n");
    fprintf(stderr,buffer);
d94 3
a96 4
  
  if ((this=malloc(sizeof(error_entry_t)))==NULL)
    error(1,"%s: memory allocation error.",progname);
    
d99 3
a101 3
  printf("Error %s\n",this->message);
  
  if (error_database==NULL)
d103 1
a103 2
  else
  {
d106 1
a106 1
       entry=entry->next;
d117 1
a117 1
  module_entry_t *entry=module_database;
d119 2
a120 3
  while (entry)
  {
    if (strcmp(entry->name,name)==0)
d122 1
a122 1
    entry=entry->next;
d124 1
a124 1
  
d134 1
a134 1
  component_entry_t *entry=component_database;
d136 2
a137 3
  while (entry)
  {
    if (strcmp(entry->name,name)==0)
d139 1
a139 1
    entry=entry->next;
d141 1
a141 1
    
d151 1
a151 1
  FILE *file=NULL;
d153 4
a156 4
  char *cp,*word;
  module_entry_t *entry,*this;
  int i,line_number=0;
  
d160 3
a162 3
  sprintf(buffer,"%s.%s.%s",build_dir,BUILDSYS_DIR,MODULE_DB_FILE);
  if ((file=fopen(buffer,"r"))==NULL)
    error(1,"cannot open module database file %s.",buffer);
d165 5
a169 7
    printf("Using module database '%s'.\n",buffer);
  
  while (!feof(file))
  {
    fgets(buffer,sizeof(buffer),file);
    if (!feof(file))
    {
d172 41
a212 48
      if (buffer[0] != '#')  /* ignore comments */
      {
        cp=buffer;
        cp = extract_word(cp,&word,FALSE);  		/* extract the name */
        if (word!=NULL)					/* ignore null lines */
        {
          if (lookup_module(word)!=NULL)
          {
            error(1,"duplicate '%s' entry in module database line %d.",
            	word,line_number);
          }

          /* allocate a new entry */
          if ((this=malloc(sizeof(module_entry_t)))==NULL)
            error(1,"memory allocation error.");

    	  this->name = word;
  	  word=NULL;
          this->path      = NULL;
          this->output    = NULL;
          this->filename  = NULL;
          this->switch_on = NULL;
          this->type 	  = UNDEF;
          this->next      = module_database;
          module_database = this;
          entry = this;

          cp = extract_word(cp,&word,FALSE);
          for (i=0; i<sizeof(module_type_names)/sizeof(char*); i++)
          {
            if (cstrcmp(word,module_type_names[i])==0)
            {
              entry->type = (module_type_t)i;
              free(word);
              word=NULL;
              break;
            }
          }
          if (word!=NULL)		/* module type not found */
          {
            error(1,"unknown module type '%s' in module database line %d.",
            	word,line_number);
          }
          cp = extract_word(cp,&(entry->path),FALSE);
          cp = extract_word(cp,&(entry->output),FALSE);
          cp = extract_word(cp,&(entry->filename),FALSE);
          cp = extract_word(cp,&(entry->switch_on),TRUE);
        }
d234 4
a237 3
  char *name=NULL;
  char *options=NULL;
  char *switch_on=NULL;
d241 2
a242 2
  module_entry_t    *module;
  
d246 2
a247 2
  sprintf(buffer,"%s.%s.%s.%s",build_dir,BUILDSYS_DIR,SHADOW_DIR,filename);
  if ((file=fopen(buffer,"r"))==NULL)
d251 5
a255 10
    printf("Using shadow components file '%s'.\n",buffer);
      
  while (!feof(file))
  {
    fgets(buffer,sizeof(buffer),file);
    if (!feof(file))
    {
      if (name)      free(name);
      if (options)   free(options);
      if (switch_on) free(switch_on);
d257 1
a257 1
      
d260 12
a271 16
      cp = extract_word(cp,&name,FALSE);  		/* extract the name */
      
      if ((component = lookup_component(name))!=NULL)
      {
        cp = extract_word(cp,&options,FALSE);
        if (cstrcmp(options,"-")==0);
        {
          free(options);
          options=NULL;
        }
        cp = extract_word(cp,&switch_on,FALSE);
        if (cstrcmp(switch_on,"-")==0)
        {
          free(switch_on);
          switch_on=NULL;
        }
d277 3
a279 3
        options_same=FALSE;
        switch_same=FALSE;
        /* do we have any options */
d281 1
a281 1
	  options_same=TRUE;
d283 23
a305 23
        /* check out options first */
        if (component->options)
          if (cstrcmp(component->options,options)==0)
            options_same=TRUE;

        /* now check out switches */
        if (component->switch_on) {
          if (cstrcmp(component->switch_on,switch_on)==0)
            switch_same=TRUE;
        } else {
          if ((module=lookup_module(name))!=NULL) {
            if (module->switch_on) {
              if (cstrcmp(component->switch_on,switch_on)==0)
                switch_same=TRUE;
            } else {
              if (!switch_on)
                switch_same=TRUE;
            }
          }            
        }
        /* mark the module for not needing clean */
        if (switch_same && options_same)
          component->force_clean=FALSE;
d310 11
a320 6
  
  if (name)      free(name);
  if (options)   free(options);
  if (switch_on) free(switch_on);
  
  return(0);
d331 4
a334 4
  char *cp,*word=NULL,*dependancy=NULL;
  component_entry_t *entry,*this;
  int i,line_number=0;
  
d338 3
a340 3
  sprintf(buffer,"%s.%s.%s.%s",build_dir,BUILDSYS_DIR,COMPONENTS_DIR,filename);
  if ((file=fopen(buffer,"r"))==NULL)
    error(1,"cannot open component database file '%s'.",buffer);
d343 5
a347 7
    printf("Using components file '%s'.\n",buffer);
      
  while (!feof(file))
  {
    fgets(buffer,sizeof(buffer),file);
    if (!feof(file))
    {
d350 148
a497 201
      if (buffer[0] != '#')  /* ignore comments */
      {
        if (word)
          free(word);
        dependancy=NULL;
          
        cp=buffer;
        cp = extract_word(cp,&word,FALSE);  		/* extract the name */
        if (word != NULL)				/* ignore null lines */
        {
          if (cstrcmp(word,"%log")==0)		/* deal with log file */
          {
            if (log_filename) free(log_filename);
            cp = extract_word(cp,&log_filename,TRUE);
          }
          else if (cstrcmp(word,"%image")==0)	/* deal with image file */
          {
            if (image_filename) free(image_filename);
            cp = extract_word(cp,&image_filename,TRUE);
          }
          else if (cstrcmp(word,"%messages")==0)/* deal with messages */
          {
            if (messages_filename) free(messages_filename);
            cp = extract_word(cp,&messages_filename,TRUE);
          }
          else if (cstrcmp(word,"%joiner")==0)	/* deal with BigSplit et al */
          {
            if (joiner) free(joiner);
            cp = extract_word(cp,&joiner,FALSE);
          }
          else if (cstrcmp(word,"%joinerformat")==0)/* deal with format */
          {
            if (joiner_format) free(joiner_format);
            cp = extract_word(cp,&joiner_format,FALSE);
          }
          else if (cstrcmp(word,"%poduleproduct")==0)/* deal with podule bits */
          {
            if (podule_info.product)  free(podule_info.product);
            cp = extract_word(cp,&(podule_info.product),FALSE);
          }
          else if (cstrcmp(word,"%poduledescription")==0)
          {
            if (podule_info.descript)  free(podule_info.descript);
            podule_info.descript = strdup(cp);
          }
          else if (cstrcmp(word,"%poduleserial")==0)
          {
            if (podule_info.serial)  free(podule_info.serial);
            cp = extract_word(cp,&(podule_info.serial),FALSE);
          }
          else if (cstrcmp(word,"%podulestatus")==0)
          {
            if (podule_info.status)  free(podule_info.status);
            cp = extract_word(cp,&(podule_info.status),FALSE);
          }
          else if (cstrcmp(word,"%podulemanufacture")==0)
          {
            if (podule_info.manuf)  free(podule_info.manuf);
            cp = extract_word(cp,&(podule_info.manuf),FALSE);
          }
          else if (cstrcmp(word,"%podulepart")==0)
          {
            if (podule_info.part)  free(podule_info.part);
            cp = extract_word(cp,&(podule_info.part),FALSE);
          }
          else if (cstrcmp(word,"%poduledate")==0)
          {
            if (podule_info.date)  free(podule_info.date);
            cp = extract_word(cp,&(podule_info.date),FALSE);
          }
          else if (cstrcmp(word,"%include")==0)	/* deal with includes */
          {
            free(word);
            cp = extract_word(cp,&word,FALSE);
            if (cstrcmp(word,filename)==0)
              error(1,"cannot recursivly include '%s'.",filename);

            if (read_component_database(word))	/* recurse */
              goto exit_gracefully;
          }
          else
          {
            if ((dependancy=strchr(word,':'))!=NULL)
            {
              *dependancy=0;
              dependancy++;
              if (lookup_component(dependancy)==NULL)
              {
                error(1,"attempt to depend '%s' on a non existant component "
                	"'%s' (line %d).",word,dependancy,line_number);
              }
            }
            if (word[0]=='-')		/* module to remove */
            {
              component_entry_t *last=NULL;
              if ((entry=lookup_component(word+1))==NULL)
              {
                error(1,"attempt to remove non existant component '%s' "
                	"(line %d).",word+1,line_number);
              }
              entry = component_database;
              last  = NULL;
	      while (strcmp(entry->name,word+1)!=0)
	      {
                last=entry;
                entry=entry->next;
              }

              if (last==NULL)
                component_database = entry->next;
              else
                last->next = entry->next;
              release_component(entry);
              
            }
            else
            {
              if (lookup_module(word)==NULL)
              {
                error(1,"'%s' entry (line %d) not found in module database.",
              		word,line_number);
              }
              /* look to see if entry exists already */
              if ((entry=lookup_component(word))==NULL)
              {
                /* allocate a new entry */
                if ((this=malloc(sizeof(component_entry_t)))==NULL)
                  error(1,"memory allocation error.");
  
      	        this->name        = word;
                this->options     = NULL;
                this->switch_on   = NULL;
                this->next        = NULL;
                this->type        = UNDEF;    
      	        this->next 	  = NULL;
      	        this->force_clean = FALSE;	/* default state */
      	        
      	        if (dependancy)			/* we have some dependancy */
      	        {
      	          component_entry_t *tmp=lookup_component(dependancy);
      	          this->next = tmp->next;
      	          tmp->next = this;
      	        }
      	        else
      	        {
        	  if (component_database==NULL)
      	            component_database = this;
      	          else
      	          {
      	            entry = component_database;
      	            while (entry->next)
      	              entry=entry->next;
                    entry->next = this;
                  }
      	        }
                  
                entry = this;
              }
              else
              {
                free(word);
              }
  	      word=NULL;
	    
      	      while (cp)		/* while there is still text on line */
      	      {
                cp = extract_word(cp,&word,FALSE);  /* get the options word */
        	if (cstrcmp(word,"-options")==0)
        	{
        	  cp = extract_word(cp,&(entry->options),FALSE);
        	  entry->force_clean = TRUE;
        	}
        	else if (cstrcmp(word,"-switch")==0)
                {
        	  cp = extract_word(cp,&(entry->switch_on),TRUE);
        	  entry->force_clean = TRUE;
        	}
        	else if (cstrcmp(word,"-type")==0)
        	{
                  free(word);			/* finished with this string */
                  cp = extract_word(cp,&word,FALSE);
                  for (i=0; i<sizeof(module_type_names)/sizeof(char*); i++)
                  {
                    if (cstrcmp(word,module_type_names[i])==0)
                    {
                      entry->type = (module_type_t)i;
                      free(word);
                      word=NULL;
                      break;
                    }
                  }
                  if (word!=NULL)		/* module type not found */
                  {
                    error(1,"unknown module type '%s' in module database "
                    	"line %d.",word,line_number);
                  }
                }      
              }
            }
          }
        }
d516 2
a517 2
  module_entry_t *entry,*this;
  
d519 11
a529 7
  while (entry)
  {
    if (entry->name)      free(entry->name);
    if (entry->path)      free(entry->path);
    if (entry->output)    free(entry->output);
    if (entry->filename)  free(entry->filename);
    if (entry->switch_on) free(entry->switch_on);
d531 1
a531 1
    entry=entry->next;
d537 1
a537 1
release_component(component_entry_t *entry)
d539 6
a544 3
  if (entry->name)      free(entry->name);
  if (entry->options)   free(entry->options);
  if (entry->switch_on) free(entry->switch_on);
d550 2
a551 2
  component_entry_t *entry,*this;
  
d553 1
a553 2
  while (entry)
  {
d556 1
a556 1
    entry=entry->next;
d564 2
a565 2
  error_entry_t *entry,*this;
  
d567 3
a569 3
  while (entry)
  {
    if (entry->message) free(entry->message);
d571 1
a571 1
    entry=entry->next;
d583 3
a585 3
  memset(buffer,c,BUFFER_LEN);
  buffer[78]=0;
  printf("%s\n",buffer);
d596 3
a598 3
  printf("Acorn '%s' version " APP_VERSION "\n\n",progname);
  
  printf("Usage: %s [options] <action>\n",progname);
d604 1
a604 1
  
d616 2
a617 2
  int error=0;
  
d620 1
a620 1
  
d622 2
a623 3
  while (entry)
  {
    if (error==0)
d626 2
a627 2
    printf("Error %s\n",entry->message);
    entry=entry->next;
d629 1
a629 1
  
d632 1
a632 1
    
d634 1
a634 1
    
d636 35
a670 16
  if (build_name)           free(build_name);
  if (build_dir)            free(build_dir);
  if (image_filename)       free(image_filename);
  if (log_filename)         free(log_filename);
  if (image_size)           free(image_size);
  if (messages_filename)    free(messages_filename);
  if (joiner)               free(joiner);
  if (joiner_format)        free(joiner_format);
  
  if (podule_info.product)  free(podule_info.product);
  if (podule_info.descript) free(podule_info.descript);
  if (podule_info.serial)   free(podule_info.serial);
  if (podule_info.status)   free(podule_info.status);
  if (podule_info.manuf)    free(podule_info.manuf);
  if (podule_info.part)     free(podule_info.part);
  if (podule_info.date)     free(podule_info.date);
d678 2
a679 2
  int i,found,first;
  
d682 1
a682 1
  
d686 1
a686 2
  for (i=1; i<argc; i++)
  {
d689 1
a689 2
    if ((cstrcmp(argv[i],"-h")==0) || (cstrcmp(argv[i],"-help")==0))
    {
d692 4
a695 5
    }
    else if ((cstrcmp(argv[i],"-v")==0) || (cstrcmp(argv[i],"-verbose")==0))
      verbose=TRUE;
    else if ((cstrcmp(argv[i],"-s")==0) || (cstrcmp(argv[i],"-strict")==0))
      strict=TRUE;
d697 1
a697 1
  
d701 1
a701 2
  if (argc<2 || i>=argc)
  {
d705 2
a706 2
  first = i; /* record first non flag argument */
  
d710 2
a711 2
  if ((build_dir=read_env(ENV_BUILD_DIR))==NULL)
    error(1,"cannot locate build directory, please run a !Env file.");
d713 5
a717 2
  if ((build_name=read_env(ENV_BUILD_NAME))==NULL)
    error(1,"cannot identify build name, please run a !Env file.");
a718 3
  if ((image_size=read_env(ENV_IMAGE_SIZE))==NULL)
    error(1,"cannot establish a image size, please run a !Env file.");
   
d731 1
a731 1
  
d736 1
a736 1
  printf("Started %s build : %s",build_name,asctime(localtime(&now)));
d738 9
a746 11
  
  if (verbose)
  {
    printf("Log filename       : %s\n",CHK_STR(log_filename));
    printf("Image filename     : %s\n",CHK_STR(image_filename));
    printf("Messages location  : %s\n",CHK_STR(messages_filename));
    printf("Image size         : %s\n",CHK_STR(image_size));
    printf("Joiner application : %s\n",CHK_STR(joiner));
    printf("Joiner format      : %s\n",CHK_STR(joiner_format));
    if (cstrcmp(joiner_format,"podule")==0)
    {
d748 7
a754 7
      printf("  Product code        : %s\n",CHK_STR(podule_info.product));
      printf("  Description         : %s\n",CHK_STR(podule_info.descript));
      printf("  Serial              : %s\n",CHK_STR(podule_info.serial));
      printf("  Mod Status          : %s\n",CHK_STR(podule_info.status));
      printf("  Pace of manufacture : %s\n",CHK_STR(podule_info.manuf));
      printf("  Part number         : %s\n",CHK_STR(podule_info.part));
      printf("  Date                : %s\n",CHK_STR(podule_info.date));
a756 1

d761 6
a766 9
  for (i=first; i<argc; i++)
  {
    found=FALSE;
    for (action = &action_tbl[0]; action->call; action++)
    {
      if (cstrcmp(action->name, argv[i])==0)
      {
        found=TRUE;
        break;
d769 1
a769 2
    if (!found)
    {
d773 2
a774 2
    printf("Starting phase %s ...\n",action->name);
    (*(action->call))();
d778 1
a778 1
  
d780 1
a780 1
  printf("Finished %s build : %s",build_name,asctime(localtime(&now)));
d782 1
a782 1
    
@


1.9
log
@Now look for components files in directory BuildSys.Components.
@
text
@d657 1
a657 1
  printf("Acorn '%s' version $Revision: 1.6 $ ($Date: 1997/09/08 17:17:03 $)\n\n",progname);
@


1.8
log
@When doing a make resources phase, clean the messages module first.
@
text
@d350 1
a350 1
  sprintf(buffer,"%s.%s.%s",build_dir,BUILDSYS_DIR,filename);
@


1.7
log
@Changed behaviour for modules not found in the shadow file. Force clean is
only performed for modules with switch or options set and it is only these
modules which are logged in the shadow file.
@
text
@@


1.6
log
@Looks like $Date$ is case sensitive.
@
text
@d293 1
d499 1
a499 1
      	        this->force_clean = TRUE;	/* default state */
d532 1
d534 2
d537 1
d539 2
d657 1
a657 1
  printf("Acorn '%s' version $Revision: 1.5 $ ($Date$)\n\n",progname);
@


1.5
log
@Added revision number and copied to renaissa/Build/Library.
@
text
@d650 1
a650 1
  printf("Acorn '%s' version $Revision$ ($DATE$)\n\n",progname);
@


1.4
log
@Misc changes following testing, mainly along the lines of getting the same
sequence of events happening under srcbuild as with existing system.
Built a ROM which didn't work :-(.
@
text
@d649 2
@


1.3
log
@Completed functionality, committed to repository prior to extensive
testing.
@
text
@d51 1
d61 1
a61 1
 build_resources,	"resporces",	"export resources",
d83 1
a83 1
  if (fatal)
d654 1
d731 2
@


1.2
log
@Added my latest sources prior to going on holiday.
@
text
@a41 1
char *source_dir=NULL;
d63 2
d159 1
a159 1
  sprintf(buffer,"%s.%s.%s",build_dir,BUILD_SYS,MODULE_DB);
d253 1
a253 1
  sprintf(buffer,"%s.%s.%s",build_dir,SHADOW_DIR,filename);
d277 5
d283 9
a291 1
      
d294 4
d308 2
a309 2
          if ((module=lookup_module(name))!=NULL)
            if (module->switch_on)
d312 5
d348 1
a348 1
  sprintf(buffer,"%s.%s.%s",build_dir,BUILD_SYS,filename);
d636 1
a636 1
  memset(buffer,c,77);
d666 1
a670 1
  printf("Batched errors...\n");
d674 3
d681 3
a683 1
  banner('-');
d687 8
a694 9
  if (build_name)     free(build_name);
  if (build_dir)      free(build_dir);
  if (source_dir)     free(source_dir);
  if (image_filename) free(image_filename);
  if (log_filename)   free(log_filename);
  if (image_size)     free(image_size);
  if (messages_filename) free(messages_filename);
  if (joiner)         free(joiner);
  if (joiner_format)  free(joiner_format);
d744 1
a744 1
  if ((build_dir=read_env(BUILD_DIR))==NULL)
d747 1
a747 1
  if ((build_name=read_env(BUILD_NAME))==NULL)
d750 1
a750 1
  if ((image_size=read_env(IMAGE_SIZE))==NULL)
a751 4
    
  if ((source_dir=read_env(SOURCE_DIR))==NULL)
    error(1,"cannot locate source directory, please run a !Env file.");

@


1.1
log
@Initial revision
@
text
@d46 2
d49 1
d83 1
d267 1
d351 1
a351 2
            if (log_filename)			/* allow overide of previous */
              free(log_filename);
d356 1
a356 2
            if (image_filename)			/* allow overide of previous */
              free(image_filename);
d361 1
a361 2
            if (messages_filename)
              free(messages_filename);
d364 45
d666 10
d729 1
a729 6
  /* 
   * start spooling
   */
  spool_open(log_filename);
  banner('-');
  
d736 6
d752 17
a768 3
    printf("Log filename   : %s\n",CHK_STR(log_filename));
    printf("Image filename : %s\n",CHK_STR(image_filename));
    printf("Image size     : %s\n",CHK_STR(image_size));
@


1.1.1.1
log
@First added for safe keeping.
@
text
@@

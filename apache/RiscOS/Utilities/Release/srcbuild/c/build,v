head	1.49;
access;
symbols
	srcbuild-0_53:1.49
	srcbuild-0_52:1.48
	srcbuild-0_51:1.47
	srcbuild-0_50:1.47
	srcbuild-0_49:1.46
	srcbuild-0_48:1.45
	srcbuild-0_47:1.45
	srcbuild-0_46:1.44
	srcbuild-0_45:1.43
	srcbuild-0_44:1.43
	srcbuild-0_43:1.43
	srcbuild-0_42:1.42
	srcbuild-0_41:1.41
	srcbuild-0_40:1.40
	srcbuild-0_39:1.39
	srcbuild-0_38:1.38
	srcbuild-0_37:1.37
	srcbuild-0_36:1.36
	srcbuild-0_35:1.35
	srcbuild-0_34:1.34
	srcbuild-0_33:1.34
	srcbuild-0_32:1.33
	srcbuild-0_31:1.32
	srcbuild-0_30:1.31
	srcbuild-0_29:1.30
	srcbuild-0_28:1.29
	srcbuild-0_27:1.29
	srcbuild-0_26:1.28
	srcbuild-0_25:1.27
	srcbuild-0_24-1_23_2_4:1.26.2.4
	srcbuild-0_24-1_23_2_3:1.26.2.3
	srcbuild-0_24-1_23_2_2:1.26.2.2
	srcbuild-0_24-1_23_2_1:1.26.2.1
	sbrodie_BBE:1.26.0.2
	sbrodie_BBE_bp:1.26
	srcbuild-0_24:1.26
	srcbuild-0_23:1.25
	srcbuild-0_22:1.24
	srcbuild-0_21:1.24
	srcbuild-0_20:1.23
	srcbuild-0_19:1.22
	srcbuild-0_18:1.21
	srcbuild-0_17:1.20
	srcbuild-0_16:1.19
	srcbuild-0_15:1.18
	srcbuild-0_14:1.17
	srcbuild-0_13:1.17
	srcbuild-0_12:1.16
	srcbuild-0_11:1.15
	srcbuild-0_10:1.15
	srcbuild-0_09:1.14
	srcbuild-0_08:1.13
	srcbuild-0_07:1.12
	srcbuild-0_06:1.11
	srcbuild-0_05:1.10
	srcbuild-0_04:1.9
	srcbuild-0_03:1.8
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.49
date	2018.11.17.09.35.56;	author rool;	state Exp;
branches;
next	1.48;
commitid	FPFAIJHBZmOjmh0B;

1.48
date	2018.11.17.09.27.16;	author rool;	state Exp;
branches;
next	1.47;
commitid	fhoX8Rh7h2Vkjh0B;

1.47
date	2014.10.01.23.54.35;	author jlee;	state Exp;
branches;
next	1.46;
commitid	qNhLvnugBRabAySx;

1.46
date	2011.03.17.19.13.48;	author srevill;	state Exp;
branches;
next	1.45;
commitid	fnYulYGnMGmFCecv;

1.45
date	2009.07.13.19.36.03;	author srevill;	state Exp;
branches;
next	1.44;

1.44
date	2009.07.12.22.44.20;	author srevill;	state Exp;
branches;
next	1.43;

1.43
date	2004.11.12.14.23.26;	author bavison;	state Exp;
branches;
next	1.42;

1.42
date	2004.11.09.15.43.52;	author bavison;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.12.16.54.31;	author srevill;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.16.20.28.57;	author bavison;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.11.16.32.28;	author bavison;	state Exp;
branches;
next	1.38;

1.38
date	2002.05.08.14.44.10;	author srevill;	state Exp;
branches;
next	1.37;

1.37
date	2002.02.28.20.51.08;	author srevill;	state Exp;
branches;
next	1.36;

1.36
date	2001.11.02.16.35.12;	author sbrodie;	state Exp;
branches;
next	1.35;

1.35
date	2001.10.19.12.44.34;	author srevill;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.18.09.32.36;	author nbingham;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.27.13.04.03;	author sbrodie;	state Exp;
branches;
next	1.32;

1.32
date	2001.03.22.13.20.19;	author sbrodie;	state Exp;
branches;
next	1.31;

1.31
date	2001.03.12.14.10.47;	author sbrodie;	state Exp;
branches;
next	1.30;

1.30
date	2001.02.08.13.39.01;	author sbrodie;	state Exp;
branches;
next	1.29;

1.29
date	2001.02.02.11.22.11;	author sbrodie;	state Exp;
branches;
next	1.28;

1.28
date	2001.01.25.16.16.53;	author sbrodie;	state Exp;
branches;
next	1.27;

1.27
date	2000.12.15.16.26.51;	author sbrodie;	state Exp;
branches;
next	1.26;

1.26
date	2000.11.16.11.08.37;	author kbracey;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2000.10.16.10.58.32;	author sbrodie;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.12.12.04.24;	author dcotton;	state Exp;
branches;
next	1.23;

1.23
date	2000.06.08.17.44.36;	author dcotton;	state Exp;
branches;
next	1.22;

1.22
date	2000.05.22.12.22.25;	author dcotton;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.27.13.41.07;	author dcotton;	state Exp;
branches;
next	1.20;

1.20
date	99.11.09.10.02.40;	author dcotton;	state Exp;
branches;
next	1.19;

1.19
date	99.09.10.10.49.19;	author dcotton;	state Exp;
branches;
next	1.18;

1.18
date	99.09.09.12.54.09;	author nbingham;	state Exp;
branches;
next	1.17;

1.17
date	99.05.07.12.37.24;	author kbracey;	state Exp;
branches;
next	1.16;

1.16
date	99.05.06.11.07.36;	author kbracey;	state Exp;
branches;
next	1.15;

1.15
date	98.10.28.17.47.51;	author nturton;	state Exp;
branches;
next	1.14;

1.14
date	98.10.27.10.38.46;	author blaughto;	state Exp;
branches;
next	1.13;

1.13
date	98.10.27.09.40.11;	author kbracey;	state Exp;
branches;
next	1.12;

1.12
date	98.07.30.09.42.48;	author rbuckley;	state Exp;
branches;
next	1.11;

1.11
date	98.01.13.13.32.15;	author rbuckley;	state Exp;
branches;
next	1.10;

1.10
date	97.10.31.13.40.55;	author rbuckley;	state Exp;
branches;
next	1.9;

1.9
date	97.09.25.15.43.21;	author rbuckley;	state Exp;
branches;
next	1.8;

1.8
date	97.09.25.11.24.50;	author rbuckley;	state Exp;
branches;
next	1.7;

1.7
date	97.09.12.14.12.23;	author rbuckley;	state Exp;
branches;
next	1.6;

1.6
date	97.09.09.09.41.12;	author rbuckley;	state Exp;
branches;
next	1.5;

1.5
date	97.09.08.17.09.56;	author rbuckley;	state Exp;
branches;
next	1.4;

1.4
date	97.09.05.12.56.03;	author rbuckley;	state Exp;
branches;
next	1.3;

1.3
date	97.09.04.13.33.07;	author rbuckley;	state Exp;
branches;
next	1.2;

1.2
date	97.08.22.16.16.51;	author rbuckley;	state Exp;
branches;
next	1.1;

1.1
date	97.08.21.16.44.55;	author rbuckley;	state Exp;
branches
	1.1.1.1;
next	;

1.26.2.1
date	2000.12.07.17.03.43;	author sbrodie;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2000.12.13.17.31.33;	author sbrodie;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2000.12.14.17.41.50;	author sbrodie;	state Exp;
branches;
next	1.26.2.4;

1.26.2.4
date	2000.12.15.15.33.30;	author sbrodie;	state Exp;
branches;
next	;

1.1.1.1
date	97.08.21.16.44.55;	author rbuckley;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Fix potential buffer overflow, report error return code
Detail:
  srcbuild.c: Follow standard practice and return a non-zero return code if the build fails.
  build.c: Space not allowed for null terminator; correct out-by-1 error.
Admin:
  Submission from Timothy Baldwin.

Version 0.53. Tagged as 'srcbuild-0_53'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

/* Please note:
 *
 *
 *  This source file has been modified such that it can operate independently of the
 *  host operating system - notably, it is independent of the character that is being
 *  used as the directory delimiter.  Please do not break this.  Really.
 *
 *
 */

/* ANSI Includes */
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <assert.h>

/* RISC OS Includes */
#ifdef RISCOS
#  include "kernel.h"
#  include "swis.h"
#endif

/* CLX */
#include "host.h"

/* Local includes */
#include "srcbuild.h"
#include "parse.h"
#include "riscos.h"
#include "build.h"

/* Some bits for command line options which set environment variables */
#define ENVVAR_BUF_LEN 32
#define LOCALE_STR     "Locale"
#define LOCALE_TMP     "Locale$tmp"
#define USERIF_STR     "UserIF"
#define USERIF_TMP     "UserIF$tmp"
#define MACHINE_STR    "Machine"
#define MACHINE_TMP    "Machine$tmp"
#define ASCII_LowerCase(c) if ((c >= 'A') && ('Z' >= c)) c += 'a' - 'A'
#define ASCII_UpperCase(c) if ((c >= 'a') && ('z' >= c)) c -= 'a' - 'A'
static void override_envvar(const char *, const char *, const char *);
void copy_env(const char *, const char *);

/* The base address of a ROM image */
unsigned long rom_base_address = 0x03800000ul;

/* The contents of Alias$amu_machine */
static char *amu_machine = NULL;
static void get_amu_machine(void);


static const char corporate_copyright_for_bbe[] = "#"
  "\n# Copyright © 2001, Castle Technology Ltd. All rights reserved."
  "\n#";


typedef enum {
  build_install_rom_normal,
  build_install_rom_bbe_script,
  build_install_rom_size_calculation
} build_install_rom_reason_code;

typedef enum {
  build_resources_normal,
  build_resources_bbe_script
} build_resources_reason_code;

/* Internal function invoked by build_install, build_bbe and the joiners (if install_rom phase wasn't run) */
static int build_install_rom_(build_install_rom_reason_code);

/* Some string handling functions */
unsigned int strcasecmp(const char *xs, const char *ys);
const char *strstr_ci(const char *source, const char *substr);


/*
 * perform a amu_machine call with printf style parameter passing
 */
#ifdef __CC_NORCROFT
#pragma check_printf_formats
#endif
static int
amu_machinef(char *format, ...)
{
  char *full_format;
  char buffer[BUFFER_LEN];
  va_list list;
  int ret = 0;

  /* Create the full format string from the system call, by adding together the
     contents of Alias$amu_machine, and the format string passed into the function */
  full_format = malloc (strlen (amu_machine) + 1 + strlen (format) + 1);
  if (full_format)
  {
    size_t used = strlen(buffer);

    strcpy (full_format, amu_machine);
    strcat (full_format, " ");
    strcat (full_format, format);

    /* Take the format string and extract the arguments used in the format string */
    va_start (list, format);
    used += vsnprintf(buffer + used, sizeof(buffer) - used, format, list);
    va_end(list);
    if (verbose) {
      sb_printf("%s\n",buffer);
    }
    if (used >= sizeof(buffer) - 1) {
      sb_printf("ABORT: Overflow of command string buffer (%d)\n", used);
      exit(EXIT_FAILURE);
    }
    /* Free the temporary buffer */
    free (full_format);

    /* Allow command line options to override certain environment variables */
    override_envvar(buffer, LOCALE_STR,  LOCALE_TMP);
    override_envvar(buffer, USERIF_STR,  USERIF_TMP);
    override_envvar(buffer, MACHINE_STR, MACHINE_TMP);

    /* Call the command */
    ret = sb_system(buffer);

    /* Restore the environment variables to their defaults (as set in the Env file) */
    copy_env(LOCALE_STR,  LOCALE_TMP);
    copy_env(USERIF_STR,  USERIF_TMP);
    copy_env(MACHINE_STR, MACHINE_TMP);
  }
  else
  {
    /* Malloc failed, print an error message and quit */
    sb_printf ("Malloc failed, memory exhausted. Exiting...\n");
    exit (EXIT_FAILURE);
  }

  return ret;
}
#ifdef __CC_NORCROFT
#pragma -v0
#endif

/* Prints out that a component is about to be processed, and changes the current directory
 * to be that of the module specified.  Returns 0 on failure, 1 on success.
 */
static int build_select_module_directory(component_entry_t *component, module_entry_t *module)
{
  int result;
  char buffer[BUFFER_LEN];

  sb_printf("\n%s (%s)...\n", component->name, module->path);
  sb_buildfilename(BUFFER_LEN, buffer, build_dir, module->path, NULL);
  result = sb_chdir(buffer);
  if (result) {
    error(0, "cannot locate '%s'", buffer);
  }
  return !result;
}


/* Sets up Resource$Dir and Locale environment variables for the given locale,
 * and re-initialises the amu_machine alias to reflect the new values.
 */
static int build_select_locale(const char *locale)
{
  char *num_locale = sb_getenv(ENV_NUM_LOCALE);
  char buffer[BUFFER_LEN];

  sb_buildfilename(BUFFER_LEN, buffer, build_dir, messages_filename, RESOURCES_DIR, build_name, num_locale, locale, NULL);
  sb_setenv(ENV_RES_DIR, buffer);
  sb_setenv(ENV_LOCALE, locale);
  get_amu_machine(); /* Reset amu_machine to include the new values */
  if (verbose)
  {
    sb_printf ("Set Locale (%s) and Resource$Dir to %s\n", locale, buffer);
  }

  return 1;
}

/*
 * check for existance of a directory before creating it, prefix all dirs
 * with build_dir.
 */
static int
_check_dir(char *prefix, char *filename)
{
  char buffer[BUFFER_LEN], *p;

  strcpy(buffer, build_dir);
  p = strchr(buffer, '\0');
  if (prefix) {
    *p++ = host_dir_sep_char();
    p = strchr(strcpy(p, prefix), '\0');
  }
  if (filename) {
    *p++ = host_dir_sep_char();
    strcpy(p, filename);
  }

  if (sb_mkdir(buffer, 0755) == -1)
    error(1, "creating directory '%s'.", buffer);

  return 0;
}

/*
 * check for existance of a directory before creating it, prefix all dirs
 * with build_dir.
 */
static int
_check_dir_p(char *prefix, char *filename)
{
  char buffer[BUFFER_LEN], *p;

  strcpy(buffer, prefix);
  if (filename)
  {
    p    = strchr(buffer, '\0');
    *p++ = host_dir_sep_char();
    strcpy(p, filename);
  }

  if (sb_mkdir_p(buffer, 0755) == -1)
    error(1, "creating directory '%s'.", buffer);

  return 0;
}

/* Construct a set of directories, one level at a time. Each arg is parsed for directory
 * separators too to enable arbitrary paths to be easily created.
 */
static int
_check_dir_v(const char *prefix, ...)
{
  va_list ap;
  const char *arg;
  const char dir_sep = host_dir_sep_char();
  char dir_sep_str[2];
  char buffer[BUFFER_LEN];

  buffer[0] = '\0';
  dir_sep_str[0] = dir_sep;
  dir_sep_str[1] = '\0';

  va_start(ap, prefix);
  for (arg = prefix; arg; arg = va_arg(ap, const char *)) {
      const char *next, *p;
      for (p = arg, next = NULL; *p; p = next)
      {
        char *eobuffer = strchr(buffer, '\0');
        if (*buffer) {
          *eobuffer++ = dir_sep;
        }
        next = p + strcspn(p, dir_sep_str);
        *eobuffer = '\0';
        strncat(eobuffer, p, next - p);
        _check_dir(NULL, buffer);
        if (*next) ++next;
      }
  }
  va_end(ap);
  return 0;
}

/*
 * Call the recursive directory creation routine to create everything
 * upto the parent directory of the specified object.
 */
static int
_check_parent(char *prefix, char *directory, char *build)
{
  char buffer[BUFFER_LEN], *p;

  strcpy(buffer, build);
  p = strrchr(buffer, host_dir_sep_char());
  if (p) *p = '\0';
  _check_dir_v(prefix, directory, p?buffer:p, NULL);

  return 0;
}

/*
 * create the directories required by the build process
 */
int build_dirs(void)
{
  component_entry_t *component;
  module_entry_t *module;
  int max_resource_suffix = 0;
  char buffer[BUFFER_LEN];
  char build[BUFFER_LEN];
  char numeric[BUFFER_LEN];

  strcpy(build, CHK_STR(sb_getenv(ENV_BUILD_NAME)));
  strcpy(numeric, CHK_STR(sb_getenv(ENV_NUM_LOCALE)));

  sb_chdir(build_dir);
  _check_dir(NULL, IMAGES_DIR);
  _check_dir(NULL, EXPORT_DIR);
  _check_dir_p(INSTALL_DIR, build_name);
  _check_dir(BUILDSYS_DIR, LOGS_DIR);
  _check_parent(BUILDSYS_DIR, SHADOW_DIR, build);

  /* If APCS is not defined, we get right result as the NULL terminates the path! */
  sb_buildfilename(BUFFER_LEN, buffer, "Export", sb_getenv("APCS"), NULL);
  _check_dir_v(buffer, "Hdr", "Global", NULL);
  _check_dir_v(buffer, "Hdr", "Interface", NULL);
  _check_dir_v(buffer, "Hdr", "Interface2", NULL);
  _check_dir_v(buffer, "Lib", NULL);

  build_select_locale(supported_territories[0]);

  component = component_database;
  while (component)
  {
    module = lookup_module(component->name);
    if (module->output != NULL) /* Ensure we don't try to create oflaofla directories... ;-) */
    {
      _check_dir_v(INSTALL_DIR, build_name, module->output, NULL);
    }
    max_resource_suffix = component->resource_sfx;
    component = component->next;
  }

  if (num_of_territories > 0)
  {
    unsigned int loop, dirs;
    for (loop=0; loop < num_of_territories; loop++)
    {
      _check_dir_v(messages_filename, RESOURCES_DIR, build, numeric, supported_territories[loop], "Apps", NULL);
      _check_dir_v(messages_filename, RESOURCES_DIR, build, numeric, supported_territories[loop], RESOURCES_DIR, NULL);
      for (dirs = 2; dirs <= max_resource_suffix; ++dirs)
      {
        sprintf(buffer, RESOURCES_DIR "%d", dirs);
        _check_dir_v(messages_filename, RESOURCES_DIR, build, numeric, supported_territories[loop], buffer, NULL);
      }
    }
  }

  return 0;
}


int build_clean(void)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (!component->no_component_sources) /* We do not wish to do a clean phase of a component if we do not have any sources... */
    {
      switch (type) {
        case RES:
        case ASM:
        case C:
        case BAS:
        case KERNEL:
        case HAL:
        case EXP:
        case DATA:
        case LOADER:
        if (build_select_module_directory(component, module))
          if (amu_machinef("-k clean COMPONENT=%s %s%s %s",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"",
  		component->options ? component->options:"") != 0)
                  error(0, "running make clean on module '%s'.", component->name);
  	/*
  	 * no need for force clean now
  	 */
  	if (component->duplicate == 0) component->force_clean = FALSE;
      }
    }
    else
    {
      sb_printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running clean phase on this component.\n", component->name, component->name);
    }

    component = component->next;
  }

  sb_system_sync();

  return 0;
}



int build_clean_all(void)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (!component->no_component_sources) /* We do not wish to do a clean_all phase of a component if we do not have any sources... */
    {
      switch (type) {
        case RES:
        case ASM:
        case C:
        case BAS:
        case KERNEL:
        case HAL:
        case EXP:
        case DATA:
        case LOADER:
        if (build_select_module_directory(component, module))
        {
          if (amu_machinef("-k clean_all COMPONENT=%s %s%s %s",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"",
  		component->options ? component->options:"") != 0)
                  error(0, "running make clean_all on module '%s'.", component->name);
          if (sb_system("stripdepnd") != 0)
                  error(0, "running stripdepnd on module '%s'.", component->name);
        }
  	/*
  	 * no need for force clean now
  	 */
  	if (component->duplicate == 0) component->force_clean = FALSE;
      }
    }
    else
    {
      sb_printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running clean_all phase on this component.\n", component->name, component->name);
    }

    component = component->next;
  }

  sb_system_sync();

  return 0;
}



/* This routine handles both export_hdrs and export_libs.  It invokes the export
 * rule with PHASE set appropriately.
 */
static int build_export(const char *phase)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;

  sb_system_sync();

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    /* We do not wish to do an export phase of a component if we do not have any sources... */
    if (!component->no_component_sources)
    {
      switch (type)
      {
        case ASM:
        case LOADER:
        case C:
        case BAS:
        case KERNEL:
        case HAL:
        case DATA:
        case EXP:
          if (build_select_module_directory(component, module)) {
            if (amu_machinef("-k export PHASE=%s COMPONENT=%s %s%s %s",
              phase,
              component->name,
              module->filename?"TARGET=":"",
              module->filename?module->filename:"",
              component->options ? component->options:"") != 0)
            error(0, "running make export (%s) on module '%s'.", phase, component->name);
          }
          break;
      }
    }
    else
    {
      sb_printf("\n%s...\nComponent %s: nosources flag passed in, "
        "therefore not running export_%s phase on this component.\n",
        component->name, component->name, phase);
    }
    component = component->next;
  }

  sb_system_sync();

  return 0;
}

int build_export_hdrs(void)
{
  return build_export("hdrs");
}

int build_export_libs(void)
{
  return build_export("libs");
}



/* Executes a resources phase - or not as the parameter may be.  If reason_code is build_resources_normal,
 * then it is a real resource export.  If it is build_resources_bbe_script, then it is assumed to be a
 * resource export command discovery being done by build_bbe to generate the script filenames for the
 * resource exports.
 */
static int build_resources_(build_resources_reason_code reason_code)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  char bbe_dir[BUFFER_LEN];
  char scriptfilename[BUFFER_LEN];
  module_type_t type;
  char *locale = NULL;
  char *res_dir = NULL;
  const char dir_sep = host_dir_sep_char();


  if (reason_code == build_resources_normal)
  {
    /* Read the numeric locale list */
    if ((locale = sb_strdup(sb_getenv(ENV_NUM_LOCALE))) == NULL)
    {
      error(1, "Could not read the numeric locale list system variable. */");
    }

    /*
     * Force a make clean on the messages module. Note that this is independent
     * of any settings in the module database or component database, apart from %messages.
     * We are assuming quite a lot about the Messages module here...
     */
    sb_printf("\nCleaning Messages...\n");
    sb_buildfilename(BUFFER_LEN, buffer, build_dir, messages_filename, NULL);

    if (sb_chdir(buffer))
      error(0, "cannot locate '%s'", buffer);
    else
    {
      sprintf(buffer,"-k clean COMPONENT=Messages TARGET=Messages NUMLOCALE=%s", locale);
      sb_system_sync();
      if (amu_machinef(buffer) != 0)
        error(0, "running make clean on module 'Messages'.");
    }

    /* Free the numeric locale list sys var memory. */
    if (locale) /* Usual memory-tidying gubbins */
    {
      free (locale);
      locale = NULL;
    }

    /* Build all the resource directories that are required. Can only be done after they have been cleaned as above. */
    build_dirs();
  }

  sb_system_sync();

  /*
   * now get on with rest
   */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case C:
      case ASM:
      case LOADER:
      case BAS:
      case KERNEL:
      case HAL:
      case DATA:
      case RES:
        if (build_select_module_directory(component, module))
        {
          /* We have been given a list of territories - iterate down them. */
          unsigned int loop;
          const char *const target = module->filename ? module->filename : component->name;
          char component_resource_dir[sizeof(RESOURCES_DIR) + sizeof("99")];

          for (loop = 0; loop < num_of_territories; ++loop)
          {
            if (reason_code == build_resources_bbe_script)
            {
              sb_buildfilename(BUFFER_LEN, bbe_dir, INSTALL_DIR, build_name, BBE_DIR, module->path, BBE_TMP_RES, target, NULL);
              sb_buildfilename(BUFFER_LEN - 3, scriptfilename + 3, build_dir, bbe_dir, supported_territories[loop], NULL);
              remove(scriptfilename + 3);
              memcpy(scriptfilename, "-o ", 3);
              _check_dir_v(bbe_dir, NULL);
            }
            else
            {
              *scriptfilename = '\0';
            }
            /* set the Resource$Dir and Locale environment variable to the current */
            build_select_locale(supported_territories[loop]);
#ifdef RISCOS
            res_dir = "<" ENV_RES_DIR ">";
#else
            res_dir = sb_strdup(sb_getenv(ENV_RES_DIR));
#endif
            if (component->resource_sfx > 1) {
              sprintf(component_resource_dir, RESOURCES_DIR "%d", component->resource_sfx);
            }
            else {
              strcpy(component_resource_dir, RESOURCES_DIR);
            }

            if (amu_machinef("-k resources %s RESDIR=%s%c%s COMPONENT=%s %s%s %s",
                  scriptfilename,
                  res_dir,
                  dir_sep,
                  component_resource_dir,
                  component->name,
                  module->filename?"TARGET=":"",
                  module->filename?module->filename:"",
                  component->options ? component->options : "") != 0)
              error(0, "running make resources on module '%s'.", component->name);

#ifndef RISCOS
            free(res_dir);
#endif
          }
        }
        break;
    }
    component = component->next;
  }

  sb_system_sync();

  /* Finally change the locale back to the default one (the first in the list). */
  build_select_locale(supported_territories[0]);

  return 0;
}

int build_resources(void)
{
  return build_resources_(build_resources_normal);
}



/* Copy lines from 'source' to 'dest', indenting each line with a tab if 'with_tab' is non-zero */
static void line_by_line_copy(FILE *dest, FILE *source, int with_tab)
{
  char buffer[BUFFER_LEN * 2];

  while (fgets(buffer, sizeof(buffer), source) != NULL) {
    if (with_tab) fputc('\t', dest);
    if (strncmp("echo", buffer, sizeof("echo")-1) == 0)
    {
      fputc('@@', dest);
    }
    fputs(buffer, dest);
  }
}

/* After the BBE phase has invoked the faked rom_link phase, parse the resultant script looking for
 * the line which does the link.  We need to know where the partially linked ROM module is, and which
 * abssym file it wants - then we throw the script away and write the rule cleanly ourselves.
 */
static void copy_rom_link_rules(FILE *dest, FILE *source, const char *aof_target, const char *targetname)
{
  char buffer[BUFFER_LEN * 2];
  char link_args[BUFFER_LEN];
  int skip_next;
  enum skip_flags {
    skip_read = 0,
    skip_ignore = 1,
    skip_copy = 2,
    skip_copy_and_ignore = (skip_ignore | skip_copy)
  };
  const char dir_sep = host_dir_sep_char();

  sprintf(link_args, "link -o linked%c${TARGET} -rmf -base ${ADDRESS} " AOF_DIR "%c${TARGET}", dir_sep, dir_sep);

  while (fgets(buffer, sizeof(buffer), source) != NULL) {
    char *next, *p, *source_file = NULL;
    if (!isspace(buffer[4])) continue;
    buffer[4] = '\0';
    if (cstrcmp("link", buffer)) continue;
    buffer[4] = ' ';

    /* Parse this link command to determine where the source file is and what abssym file it is linking against */
    buffer[strcspn(buffer, "\r\n")] = '\0'; /* strip eol - zero terminate */
    skip_next = skip_ignore;
    for (p = buffer, next = NULL; *p; p = next) {
      next = p;
      while (*next && !isspace(*next)) ++next;
      if (*next) *next++ = '\0';
      while (*next && isspace(*next)) ++next;
      if (skip_next != skip_read)
      {
        if (skip_next & skip_copy)
        {
          strcat(link_args, p);
        }
        skip_next = 0;
        continue;
      }
      if (*p == '-') {
        if (cstrcmp(p+1, "base") == 0 || cstrcmp(p+1, "o") == 0 || cstrcmp(p+1, "linkversion") == 0) {
          skip_next = skip_ignore;
        }
        else if (cstrcmp(p+1, "symdefs") == 0 || cstrcmp(p+1, "S") == 0 || cstrcmp(p+1, "syms") == 0 || cstrcmp(p+1, "symbols") == 0) {
          sprintf(strchr(link_args, '\0'), " %s ", p);
          skip_next = skip_copy_and_ignore;
        }
        continue;
      }
      if (*p == '>')
      {
        skip_next = p[1] ? skip_read : skip_ignore;
        continue;
      }

      if (source_file == NULL)
      {
        source_file = p;
      }
      else
      {
        strcat(link_args, " ");
        strcat(link_args, p);
      }
    }

    sb_copy_objects(aof_target, source_file);
    fprintf(dest,
      "rom_link-%s:\n"
      "\t${MKDIR} linked\n\t%s\n"
      "\t@@${CP} linked%c${TARGET} ${LINKDIR}%c${TARGET} ${CPFLAGS}\n\n",
      targetname,
      link_args,
      dir_sep,
      dir_sep);
  }
}

/*
 * Write the resources phases into the target BBE Makefile.  Each locale is copied in as a
 * separate rule.
 *
 * NOTE: Parameter 'bbe_dir' must be pointer to array with enough space to hold locale names
 * tacked on the end of it.
 *
 */
static void copy_locale_resources(FILE *makefile, char *bbe_dir /* see comment above */, const char *name)
{
  FILE *resources_file;
  char *end_bbe_dir = strchr(bbe_dir, '\0');
  char *locale;
  unsigned int loop;


  for (loop=0; loop < num_of_territories; loop++)
  {
    /* set the Resource$Dir and Locale environment variable to the current */
    locale = supported_territories[loop];

    /* Now read the locale script */
    strcpy(end_bbe_dir, locale);
    resources_file = fopen(bbe_dir, "r");
    /* Write out the rules for generating this locale's resource export */
    fprintf(makefile, "resources-%s-%s:\n", name, locale);
    if (resources_file)
    {
      /* Not an error if it doesn't exist - but need the rule in the Makefile anyway.
       * Copy file line by line, inserting TABs.
       */
      line_by_line_copy(makefile, resources_file, 1);
    }
    /* Need this line to ensure that there is at least one command for this target */
    fprintf(makefile, "\t@@| End of resource export for locale %s\n\n", locale);
    fclose(resources_file);
  }
}

/*
 * This routine searches for earlier (different) components which define targets in duplicate
 * directories.  The BBE routines need to know whether resource export rules should be
 * appended to an existing Makefile or not.
 *
 * Returns true if an earlier component also used sources in the same directory, false otherwise.
 */
static bool build_duplicate_directory(component_entry_t *component, module_entry_t *module)
{
  component_entry_t *c;

  for (c = component_database; c != component; c = c->next)
  {
    if (
      strcmp(c->name, component->name) != 0 &&
      c->created_bbe_makefile &&
      strcmp(module->path, lookup_module(c->name)->path) == 0
      )
    {
      return true;
    }
  }

  return false;
}

/* BBE phase.
 */
int build_bbe(void)
{
  component_entry_t *component;
  module_entry_t *module;
  const char dir_sep = host_dir_sep_char();
  const char target_sep = dir_sep; /* XXX: target_dir_sep_char(); */
  char bbe_dir[BUFFER_LEN];
  char aof_target[BUFFER_LEN];
  char rom_link_name[BUFFER_LEN];
  char *end_bbe_dir = NULL;
  char *end_rom_link_name = NULL;
  int  rom_link_line_by_line;
  module_type_t type;
  FILE *makefile;
  FILE *rom_link_file;
  int fake_uk_territory;
  /* The following variable is used for debugging only */
  const enum {
    bbe_real,
    bbe_debugging
  } bbe_debug = bbe_real;

  (void) bbe_debugging; /* avoid compiler warning */
  (void) bbe_real; /* avoid compiler warning */

  if (bbe_debug == bbe_real)
  {
    /* Generate BBE_Res and BBE_ROM contents (debug builds assume this is already there to save time). */
    build_resources_(build_resources_bbe_script);
    build_install_rom_(build_install_rom_bbe_script);
  }

  /* Find out if we are going to need to fake the UK territory for this to work
   * NOTE: We add UK to the territory list to avoid special casing it in the loop
   * in the switch statement, so we must remember to remove the entry again at
   * the end of the function (in fact, simply decrementing num_of_territories will do).
   */
  {
    unsigned int loop;
    fake_uk_territory = 1;
    for (loop = 0; loop < num_of_territories; ++loop) {
      if (strcmp(supported_territories[loop], "UK") == 0) fake_uk_territory = 0;
    }
    if (fake_uk_territory) {
      supported_territories[num_of_territories++] = "UK";
    }
  }

  /*
   * now get on with rest
   */
  component = component_database;
  while (component) {
    const char *target;
    bool already_processed_directory;
    module = lookup_module(component->name);
    target = module->filename ? module->filename : component->name;
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    already_processed_directory = build_duplicate_directory(component, module);

    switch (type) {
      case C:
      case ASM:
      case LOADER:
      case BAS:
      case KERNEL:
      case HAL:
      case DATA:
      case RES:
      case BBE:
        if (build_select_module_directory(component, module)) {
          unsigned int loop;

          /* Be VERY careful with the ordering here.  Paths are constructed from partial paths held in other
           * buffers.  Some paths have build_dir on the front, others do not (so you can pass them to _check_dir*)
           */

          /* Construct the "aof" directory in the BBE install directory ready to receive partially linked output */
          sb_buildfilename(BUFFER_LEN, aof_target, INSTALL_DIR, build_name, BBE_DIR, module->path, NULL);
          if (type == C)
          {
            _check_dir_v(aof_target, AOF_DIR, NULL);
          }
          _check_dir_v(aof_target, BBE_TMP_ROM, target, NULL);

          /* Using "aof_target" (holds the BBE install directory for this component), construct the full pathname
           * to that directory into bbe_dir.  Remember where the final terminator is so we can easily tack things
           * onto the end of the path as we need them.
           */
          sb_buildfilename(BUFFER_LEN, bbe_dir, build_dir, aof_target, NULL);
          end_bbe_dir = strchr(bbe_dir, '\0');
          /* Construct the actual target name of the AOF file */
          sb_buildfilename(BUFFER_LEN, aof_target, bbe_dir, AOF_DIR, target, NULL);
          /* Construct the actual name of the BBE Makefile and delete it */
          sb_buildfilename(BUFFER_LEN, rom_link_name /* NOTE: temporary use of this buffer */, bbe_dir, "Makefile", NULL);
          /* Only delete it if wasn't created by us whilst processing a previous component though! */
          if (!already_processed_directory) {
            remove(rom_link_name);
          }
          /* Construct the actual name of the rom_link script file */
          sb_buildfilename(BUFFER_LEN, rom_link_name, bbe_dir, BBE_TMP_ROM, target, "rom_link", NULL);
          end_rom_link_name = strchr(rom_link_name, '\0');

          /* We have been given a list of territories - iterate down them */
          for (loop=0; loop < num_of_territories; loop++)
          {
            build_select_locale(supported_territories[loop]);
            *end_bbe_dir = '\0';

            if (amu_machinef("-k -f %s bbe COMPONENTTYPE=%s VERBATIMROMLINK=%s_v BBEDIR=%s COMPONENT=%s %s%s %s",
                  BBE_BS_MAKEFILE,
                  module_type_names[type],
                  rom_link_name,
                  bbe_dir,
                  component->name,
                  module->filename?"TARGET=":"",
                  module->filename?module->filename:"",
                  component->options ? component->options : "") != 0)
              error(0, "running make bbe on module '%s'.", component->name);

          }
        }
        sb_system_sync();
        strcpy(end_rom_link_name, "_v");
        rom_link_file = fopen(rom_link_name, "r");
        if (rom_link_file)
        {
          rom_link_line_by_line = 1;
        }
        else
        {
          *end_rom_link_name = '\0';
          rom_link_file = fopen(rom_link_name, "r");
          rom_link_line_by_line = 0;
        }
        if (type != BBE)
        {
          sprintf(end_bbe_dir, "%cMakefile", host_dir_sep_char());
          makefile = fopen(bbe_dir, "r");
        }
        if (type == BBE)
        {
          /* Don't create a Makefile for BBE-only components */
          makefile = NULL;
        }
        else if (makefile && already_processed_directory)
        {
          makefile = freopen(bbe_dir, "a", makefile);
        }
        else if (makefile)
        {
          /* The component has exported a Makefile - allow it to override us */
          fclose(makefile);
          makefile = NULL;
        }
        else
        {
          makefile = fopen(bbe_dir, "w");
          if (makefile == NULL)
          {
            error(0, "Unable to create BBE makefile '%s'", bbe_dir);
          }
          else if (type != EXP)
          {
            time_t now;
            time(&now);
            fprintf(makefile,
              "#\n"
              "# Binary Build Environment Makefile for %s\n"
              "#\n"
              "%s\n"
              "\n"
              "include %s\n"
              "\n"
              "all:\n"
              "\t@@| Do nothing by default\n"
              "\n"
              "install_rom:\n"
              "\t${CP} rm%c${TARGET} ${INSTDIR}%c${TARGET} ${CPFLAGS}\n"
              "\t@@echo ${COMPONENT}: installed\n"
              "\n"
              "# Resource export phases\n"
              "\n"
              "resources: resources-${TARGET}-${LOCALE}\n"
              "\t@@echo ${COMPONENT}: ${LOCALE} resources exported\n"
              "\n"
              "\n"
              "rom_link: rom_link-${TARGET}\n"
              "\t@@echo ${COMPONENT}: rom_link complete\n"
              "\n"
              "\n",
              component->name,
              corporate_copyright_for_bbe,
              BBE_BS_TOOLS,
              target_sep,
              target_sep);
              component->created_bbe_makefile = true;
          }
          else
          {
            fclose(makefile);
            makefile = NULL;
          }
        }
        if (makefile)
        {
          sprintf(end_bbe_dir, "%c" BBE_TMP_RES "%c%s%c", dir_sep, dir_sep, target, dir_sep);
          copy_locale_resources(makefile, bbe_dir, target);
          if (rom_link_file)
          {
            if (rom_link_line_by_line)
            {
                line_by_line_copy(makefile, rom_link_file, 0);
            }
            else
            {
              copy_rom_link_rules(makefile, rom_link_file, aof_target, target);
            }
          }
          fclose(makefile);
          makefile = NULL;
        }
        if (rom_link_file)
        {
          fclose(rom_link_file);
          rom_link_file = NULL;
        }
    }
    component = component->next;
  }

  if (bbe_debug == bbe_real)
  {
    /* Delete the generated BBE_Res and BBE_ROM dirs (debug builds don't to help debugging and save time)
     * NOTE: This must NOT be done as we loop through the components, because some components are used
     * multiple times (e.g. territory modules) for different targets and this could cause problems.
     */

    component = component_database;
    while (component) {
      module = lookup_module(component->name);
      type = component->type;
      if (type == UNDEF)
        type = module->type;

      switch (type) {
        case C:
        case ASM:
        case LOADER:
        case BAS:
        case KERNEL:
        case HAL:
        case DATA:
        case RES:
        case BBE:
          build_select_module_directory(component, module);
          sb_buildfilename(BUFFER_LEN, bbe_dir, build_dir, INSTALL_DIR, build_name, BBE_DIR, module->path, NULL);
          end_bbe_dir = strchr(bbe_dir, '\0');
          *end_bbe_dir++ = dir_sep;
          strcpy(end_bbe_dir, BBE_TMP_RES);
          sb_wipe_objects(bbe_dir, 1);
          strcpy(end_bbe_dir, BBE_TMP_ROM);
          sb_wipe_objects(bbe_dir, 1);
          /* strcpy(end_bbe_dir, AOF_DIR); */
          /* sb_wipe_objects(bbe_dir, 0);  */
          break;
      }
      component = component->next;
    }
  }

  /* If we had temporarily added an extra territory to ensure UK export, remove it
   * from the list again - we used a string literal, so no need to free the array
   * entry.
   */
  num_of_territories -= fake_uk_territory;

  /* Finally change the locale back to the default one (the first in the list). */
  build_select_locale(supported_territories[0]);

  return 0;
}



int build_rom(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  FILE *fh_shadow = NULL;
  char *switch_on = NULL;
  module_type_t type;

  sb_buildfilename(BUFFER_LEN, buffer, build_dir, BUILDSYS_DIR, SHADOW_DIR, build_name, NULL);
  if ((fh_shadow = fopen(buffer, "w")) == NULL)
    error(1, "cannot open shadow file '%s'.", buffer);

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;
    if (!component->no_component_sources) /* We do not wish to do a rom phase of a component if we do not have any sources... */
    {
      switch (type) {
        case C:
        case ASM:
        case LOADER:
        case BAS:
        case KERNEL:
        case HAL:
        case DATA:
        if (build_select_module_directory(component, module)) {
  	  /*
  	   * do we want to force a clean build due to changes
  	   */
  	  if (component->force_clean) {
            sb_printf("Forcing a clean build due to switch/option changes...\n");
  	    if (amu_machinef("-k clean COMPONENT=%s %s%s %s",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"",
  		component->options ? component->options : "") != 0)
  	      error(0, "running make clean on module '%s'.", component->name);
  	  }
  	  /*
  	   * find out what we are switching this module on
  	   */
  	  switch_on = NULL;
  	  if (component->switch_on)
  	    switch_on = component->switch_on;
  	  else if (module->switch_on)
  	    switch_on = module->switch_on;

  	  if (component->options || switch_on) {
  	    fprintf(fh_shadow, "%s ", component->name);
  	    if (switch_on) {
  	      fprintf(fh_shadow, "-switch %s ", switch_on);
  	    }
  	    if (component->options) {
  	      fprintf(fh_shadow, "-options %s", component->options);
  	    }
  	    fprintf(fh_shadow, "\n");
  	  }

  	  if (amu_machinef("-k rom COMPONENT=%s %s%s %s",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"",
  		component->options ? component->options : "") != 0)
  	    error(0, "running make rom on module '%s'.", component->name);
  	}
      }
    }
    else
    {
      sb_printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running ROM phase on this component.\n", component->name, component->name);
    }
    component = component->next;
  }

  if (fh_shadow)
    fclose(fh_shadow);

  return 0;
}

static long build_get_filesize(const char *path, const char *name)
{
  long size;
  char buffer[BUFFER_LEN];

  sb_buildfilename(BUFFER_LEN, buffer, path, name, NULL);
  if ((size = sb_file_size(buffer)) == -1) {
    error(1, "cannot stat '%s'.", buffer);
  }
  return size;
}

static int ran_install_rom;

int
build_install_rom_(build_install_rom_reason_code reason_code)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;
  unsigned long int position_in_rom = rom_base_address;
  const char dir_sep = host_dir_sep_char();
  long size;
  const int quiet = (reason_code == build_install_rom_size_calculation); /* No need to report stuff again */
  int number_of_modules;
  int position_forced = 0;
  char output_path[BUFFER_LEN];
  char scriptdirname[BUFFER_LEN];
  char scriptfilename[BUFFER_LEN];
  char forcefilename[BUFFER_LEN];

  sb_system_sync();

  if (reason_code == build_install_rom_bbe_script)
  {
    FILE *f;
    sb_buildfilename(BUFFER_LEN, forcefilename, build_dir, INSTALL_DIR, build_name, BBE_DIR, "force", NULL);
    remove(forcefilename);
    f = fopen(forcefilename, "w");
    if (f) fclose(f);
  }
  else
  {
    *forcefilename = 0;
  }

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    sb_buildfilename(BUFFER_LEN, output_path, build_dir, INSTALL_DIR, build_name, module->output, NULL);

    switch (type) {
      case C:
      case ASM:
      case LOADER:
      case BAS:
      case KERNEL:
      case HAL:
      case DATA:
        if (module->filename == NULL) {
          if (!quiet) sb_printf("No output file for this component\n");
        }
        else if (build_select_module_directory(component, module)) {
          if (position_forced && type != DATA) {
            if (!quiet) sb_printf("Component not linked into module chain\n");
          }
          else if (type == DATA) {
            if (!component->force_position)
              component->force_position = position_in_rom;
            if (component->force_position < position_in_rom)
              error(0, "component overlaps previous data");
            else {
              position_forced = 1;
              position_in_rom = component->force_position;
            }
          }
          else if (type == KERNEL) {
            if (component->force_position) {
              if (component->force_position < position_in_rom)
                error(0, "component overlaps previous data");
                position_in_rom = component->force_position;
            }
          }

          if (reason_code == build_install_rom_bbe_script) {
            sb_buildfilename(BUFFER_LEN, scriptdirname, INSTALL_DIR, build_name, BBE_DIR, module->path, BBE_TMP_ROM, module->filename, NULL);
            _check_dir_v(scriptdirname, NULL);
            sprintf(scriptfilename, "-o %s%c%s%crom_link ADDRESS=Address FORCEROMLINK=%s", build_dir, dir_sep, scriptdirname, dir_sep, forcefilename);
            if (type != C)
            {
              sb_buildfilename(BUFFER_LEN, scriptdirname, INSTALL_DIR, build_name, BBE_DIR, module->path, "rm", NULL);
              _check_dir_v(scriptdirname, NULL);
              sb_buildfilename(BUFFER_LEN, scriptdirname, build_dir, INSTALL_DIR, build_name, BBE_DIR, module->path, "rm", NULL);
            }
          }
          else if (reason_code == build_install_rom_normal) {
            sprintf(scriptfilename, "ADDRESS=%lu", position_in_rom);
          }

          /* Unless this was the fake call from the join phase to calculate the ROM positions, actually
           * attempt the installation for this component.
           */
          if (reason_code != build_install_rom_size_calculation) {
            switch (type) {
	      case C:
		/* if module is C, link things correctly */
		if (amu_machinef("rom_link %s LINKDIR=%s COMPONENT=%s %s%s %s",
                        scriptfilename,
			output_path,
			component->name,
			module->filename?"TARGET=":"",
			module->filename?module->filename:"",
			component->options ? component->options : "") != 0)
		  error(1, "running make rom_link on module '%s'.",
			component->name);

		break;

	      default:
		if (amu_machinef("install_rom INSTDIR=%s COMPONENT=%s %s%s %s",
                        (reason_code == build_install_rom_normal) ? output_path : scriptdirname,
		 	component->name,
			module->filename?"TARGET=":"",
			module->filename?module->filename:"",
			component->options ? component->options : "") != 0)
		  error(1, "running make install_rom on module '%s'.",
			component->name);

		break;
            }
          }

          /* Need to stat the module file, display position in ROM */
          sb_system_sync();
          size = build_get_filesize(output_path, module->filename);

	  /* keep record of things for later */
	  component->position = position_in_rom;
	  component->size = size;

	  /* calculate position of next module in ROM */
	  position_in_rom += (((unsigned long int) size + 3UL) & ~3UL);
	  if (type != KERNEL && type != HAL)	/* add some magic if not kernel */
	    position_in_rom += 4;
	}
    }
    component = component->next;
  }

  if (reason_code == build_install_rom_bbe_script) {
    remove(forcefilename);
  }

  /* display the ROM entries - but only ever do this once */
  if (!ran_install_rom) {
    banner('-');
    sb_printf("\nSummary of linked ROM contents...\n\n");
    sb_printf("Module name                Position in ROM  Module size\n");
    sb_printf("-----------                ---------------  -----------\n");
    component = component_database;
    number_of_modules = 0;
    while (component) {
      module = lookup_module(component->name);
      type = component->type;
      if (type == UNDEF)
        type = module->type;

      switch (type) {
        case ASM:
        case C:
        case BAS:
        case KERNEL:
        case LOADER:
        case HAL:
        case DATA:
          if (module->filename != NULL) {
            number_of_modules++;
            sb_printf("%-25s  %08lX         %08lX\n", component->name, component->position, component->size);
          }
          break;
      }
      component = component->next;
    }
    sb_printf("\nTotal of %d modules.\n", number_of_modules);

    ran_install_rom = (reason_code == build_install_rom_normal);
  }

  sb_system_sync();

  return 0;
}

int
build_install_rom(void)
{
  return build_install_rom_(build_install_rom_normal);
}

static char *build_generate_installed_name(int buflen, char *buffer, module_entry_t *module)
{
  sb_buildfilename(buflen, buffer, build_dir, INSTALL_DIR, build_name, module->output, module->filename, NULL);
  return buffer;
}

/*
 * write stuff out to the given file in the format required by BigSplit
 */
static int joiner_format_bigsplit(FILE * fh)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;
  int hal_count = 0;
  int kernel_count = 0;
  int size_printed = 0;
  unsigned long base = rom_base_address;
  char buffer[BUFFER_LEN];

  if (!ran_install_rom) {
    build_install_rom_(build_install_rom_size_calculation);
  }

  /* look for kernel */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (type == HAL) {
      fprintf(fh, "HAL:%s\n", build_generate_installed_name(BUFFER_LEN, buffer, module));
      hal_count++;
    }
    else if (type == KERNEL) {
      if (component->force_position)
        fprintf(fh, "%lu\n", component->force_position - base);
      fprintf(fh, "%s\n", build_generate_installed_name(BUFFER_LEN, buffer, module));
      kernel_count++;
    }
    else if (type == LOADER) {
      error(0, "you appear to have an extension ROM/expansion card loader in this ROM");
    }

    if (hal_count + kernel_count == 1 && !size_printed) {
      /* write out the image filename */
      sb_buildfilename(BUFFER_LEN, buffer, build_dir, IMAGES_DIR, image_filename, NULL);
      fprintf(fh, "%s\n", buffer);

      /* write out the image size and misc newline (for "extra information") */
      fprintf(fh, "%d\n\n", atoi(image_size) * 1024);

      size_printed = 1;
    }
    component = component->next;
  }

  /* warn if things are not ok */
  if (kernel_count > 1)
    error(0, "you appear to have more than one kernel in this ROM");
  else if (kernel_count < 1)
    error(0, "you seem to be missing a kernel in this ROM");

  if (hal_count > 1)
    error(0, "you appear to have more than one HAL in this ROM");

  /* now write out the other modules in order */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case LOADER:
        if (module->filename != NULL) {
          fprintf(fh, "LOADER:");
        }
        /*FALLTHROUGH*/
      case ASM:
      case C:
      case BAS:
      case DATA:
        if (module->filename != NULL) {
          if (type == DATA)
            fprintf(fh, "%lu\n", component->position - base);
          fprintf(fh, "%s\n", build_generate_installed_name(BUFFER_LEN, buffer, module));
        }
        break;
    }
    component = component->next;
  }
  fprintf(fh, "\n");

  return 0;
}

/*
 * write stuff out to the given file in the format required by MakeExpROM
 */
static int joiner_format_makeexprom(FILE * fh)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;
  int kernel_count = 0;
  int hal_count = 0;
  char buffer[BUFFER_LEN];

  /* look for kernel */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (type == KERNEL) {
      kernel_count++;
    }
    if (type == HAL) {
      hal_count++;
    }
    component = component->next;
  }

  /* warn if things are not ok */
  if (kernel_count >= 1)
    error(1, "you appear to have a kernel in an expansion ROM!");

  if (hal_count >= 1)
    error(1, "you appear to have a HAL in an expansion ROM!");

  /* write out the image filename */
  sb_buildfilename(BUFFER_LEN, buffer, build_dir, IMAGES_DIR, image_filename, NULL);
  fprintf(fh, "%s\n", buffer);

  /* write out the image size */
  fprintf(fh, "%d\n", atoi(image_size));

  /* write out podule product code */
  fprintf(fh, "%s\n", podule_info.product?podule_info.product:"");

  /* write out podule description */
  fprintf(fh, "%s\n", podule_info.descript?podule_info.descript:"");

  /* write out podule serial number */
  fprintf(fh, "%s\n", podule_info.serial?podule_info.serial:"");

  /* write out podule status bit */
  fprintf(fh, "%s\n", podule_info.status?podule_info.status:"");

  /* write out podule manufacturer */
  fprintf(fh, "%s\n", podule_info.manuf?podule_info.manuf:"");

  /* write out podule part number */
  fprintf(fh, "%s\n", podule_info.part?podule_info.part:"");

  /* write out podule date */
  fprintf(fh, "%s\n", podule_info.date?podule_info.date:"");

  /* now write out the other modules in order */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case LOADER:
        if (module->filename != NULL) {
          fprintf(fh, "LOADER:");
        }
        /*FALLTHROUGH*/
      case ASM:
      case C:
      case BAS:
      case DATA:
        if (module->filename != NULL) {
          if (type == DATA)
            fprintf(fh, "%ld\n", component->position - rom_base_address);
          fprintf(fh, "%s\n", build_generate_installed_name(BUFFER_LEN, buffer, module));
        }
        break;
    }
    component = component->next;
  }
  fprintf(fh, "\n");

  return 0;
}

/*
 * write stuff out to the given file in the format required by romlinker
 */
static int joiner_format_romlinker(FILE * fh)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;
  component_entry_t *hal = NULL;
  component_entry_t *kernel = NULL;
  component_entry_t *loader = NULL;
  int i;
  unsigned long base = rom_base_address;
  unsigned long image_size_num;
  char buffer[BUFFER_LEN];

  /* We need to know the size information for each component */
  if (!ran_install_rom && image_type == image_type_main_rom) {
    build_install_rom_(build_install_rom_size_calculation);
  }

  image_size_num = strtoul(image_size, NULL, 0);
  if (image_type == image_type_extension_rom && (image_size_num & 3)) {
    error(1, "Extension ROMs must be a multiple of 4K long");
  }
  image_size_num *= 1024ul;

  fprintf(fh, "-format\n%s\n", image_type_names[image_type]);

  sb_buildfilename(BUFFER_LEN, buffer, build_dir, IMAGES_DIR, image_filename, NULL);
  fprintf(fh, "-imagename\n%s\n-imagesize\n%lu\n", buffer, image_size_num);

  for (i = 0; i < join_db_hwm; ++i) {
    fprintf(fh, "-%s\n%s\n",
      (const char *)hash_key(join_db, join_entries[i]), (const char *) hash_value(join_db, join_entries[i]));
  }

  /* look for kernel */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (type == HAL) {
      if (hal) {
        error(1, "you appear to have more than one HAL in this ROM");
      }
      if (image_type == image_type_extension_rom || image_type == image_type_expansion_rom) {
        error(1, "you appear to have a kernel in an expansion ROM/expansion card!");
      }
      hal = component;
    }
    else if (type == KERNEL) {
      if (kernel) {
        error(1, "you appear to have more than one kernel in this ROM");
      }
      if (image_type == image_type_extension_rom || image_type == image_type_expansion_rom) {
        error(1, "you appear to have a kernel in an expansion ROM/expansion card!");
      }
      kernel = component;
    }
    else if (type == LOADER) {
      if (loader) {
        error(1, "you appear to have more than one loader in this ROM");
      }
      if (image_type == image_type_main_rom) {
        error(0, "you appear to have an expansion card/extension ROM loader in this ROM");
      }
      loader = component;
    }

    component = component->next;
  }

  if (hal) {
    fprintf(fh, "HAL:%s\n", build_generate_installed_name(BUFFER_LEN, buffer, lookup_module(hal->name)));
  }

  if (kernel) {
    if (kernel->force_position)
      fprintf(fh, "%lu\n", kernel->force_position - base);
    fprintf(fh, "%s\n", build_generate_installed_name(BUFFER_LEN, buffer, lookup_module(kernel->name)));
  }

  if (loader) {
    fprintf(fh, "LOADER:%s\n", build_generate_installed_name(BUFFER_LEN, buffer, lookup_module(loader->name)));
  }

  /* now write out the other modules in order */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case ASM:
      case C:
      case BAS:
      case DATA:
        if (module->filename != NULL) {
          if (type == DATA)
            fprintf(fh, "%lu\n", component->position - base);
          fprintf(fh, "%s\n", build_generate_installed_name(BUFFER_LEN, buffer, module));
        }
        break;
    }
    component = component->next;
  }

  return 0;
}


int
build_join(void)
{
  char filename[BUFFER_LEN];
  char buffer[BUFFER_LEN];
  FILE *fh = NULL;
  char *redir_start = " < ";
  char *redir_end = " ";
  int system_result;

#ifdef RISCOS
  if (host_system() == _kernel_ARTHUR) {
    /* This hack can be removed once srcbuild uses the new romlinker tool which is
     * written in C and can hence accept UNIX-style redirection unlike the BASIC
     * joiners we have used in the past.
     */
    redir_start = " { < ";
    redir_end = " } ";
  }
#endif

  /* get a temp filename */
  assert(BUFFER_LEN >= L_tmpnam);
  tmpnam(filename);

  if ((fh = fopen(filename, "w")) == NULL)
    error(1, "cannot open temporary file '%s' for joiner data file.", filename);

  /* contruct the joiner file */
  if (cstrcmp(joiner_format, "BigSplit") == 0)
    joiner_format_bigsplit(fh);
  else if (cstrcmp(joiner_format, "MakeExpROM") == 0)
    joiner_format_makeexprom(fh);
  else if (cstrcmp(joiner_format, "romlinker") == 0)
    joiner_format_romlinker(fh);
  else
    error(1, "Unknown joiner file format '%s'", joiner_format);

  fclose(fh);

  /* check which joiner we are using */
  if (cstrcmp(joiner, "bigsplit") == 0) {
    sprintf(buffer, "%s %s %s %s", joiner, redir_start, filename, redir_end);
  } else if (cstrcmp(joiner, "bigsplit2") == 0) {
    /* we have some options to deal with */
    if (sigstr) {
      sprintf(buffer, "%s -sigstr %s ", joiner, sigstr);
    } else if (signum) {
      sprintf(buffer, "%s -sigstr %s ", joiner, signum);
    } else {
      sprintf(buffer, "%s -nosig ", joiner);
    }
    strcat(buffer, filename);
  }
  else if (cstrcmp(joiner, "makeexprom") == 0) {
    /* we have some options to deal with */
    sprintf(buffer, "%s %s %s %s", joiner, redir_start, filename, redir_end);
  }
  else if (cstrcmp(joiner, "romlinker") == 0) {
    sprintf(buffer, "%s -via %s", joiner, filename);
  }
  else {
    error(1, "Unknown joiner '%s'", joiner);
  }


  /* dispatch the joiner */
  sb_system_sync();
  system_result = sb_system(buffer);
  sb_system_sync();
  remove(filename);

  if (system_result != 0) {
    error(1, "running joiner '%s' with file '%s'.", joiner, filename);
  }

  return 0;
}

/*
 * generate a list of all modules to be included in a ROM
 */
int
build_list(void)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    sb_printf("%-25s %-10s %s\n", component->name, module_type_names[(int) type],
      component->options ? component->options : "");
    component = component->next;
  }
  return 0;
}


static void get_amu_machine(void)
{
  char *s;

  if (amu_machine)
  {
    free (amu_machine);
  }

  /* Grab the sysvar */
  amu_machine = sb_strdup(sb_getenv(AMUMACHINEVAR));

  if (verbose > 2)
  {
    sb_printf("amu_machine now = %s\n", amu_machine);
  }

#ifdef RISCOS
  /* Remove the trailing %*0 */
  if ((s = strrchr (amu_machine, '%')) != NULL)
    *s = '\0';

  /* gstrans it... */
  {
    char buffer[512];
    _swix(OS_GSTrans, _INR(0,3), amu_machine, buffer, sizeof(buffer), 0);
    free(amu_machine);
    amu_machine = sb_strdup(buffer);
  }

  if (verbose > 2)
  {
    sb_printf("amu_machine now = %s\n", amu_machine);
  }
#endif
}



/*
 * Function to initialise the build system, currently only extracts the value of
 * Alias$amu_machine and stores it internally in the correct form for use in
 * amu_machinef() */
void build_init(void)
{
  get_amu_machine();
}


/*
 * do RAM install phase
 * Added by NB (Mon 09th August 1999).
 */
int
build_install(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  char output_path[BUFFER_LEN];
  FILE *fh_shadow = NULL;
  char *switch_on = NULL;
  module_type_t type;

  sb_buildfilename(BUFFER_LEN, buffer, build_dir, BUILDSYS_DIR, SHADOW_DIR, build_name, NULL);
  if ((fh_shadow = fopen(buffer, "w")) == NULL)
    error(1, "cannot open shadow file '%s'.", buffer);

  sb_system_sync();

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case C:
      case ASM:
      case BAS:
      case RES:
      case LOADER:
      case KERNEL:
      case HAL:
      case DATA:
        if (build_select_module_directory(component, module)) {
	  /*
	   * do we want to force a clean build due to changes
	   */
	  if (component->force_clean) {
            sb_printf("Forcing a clean build due to switch/option changes...\n");
	    if (amu_machinef("-k clean COMPONENT=%s %s",
		component->name,
		component->options ? component->options : "") != 0)
	      error(0, "running make clean on module '%s'.", component->name);
              sb_system_sync();
	  }
	  /*
	   * find out what we are switching this module on
	   */
	  switch_on = NULL;
	  if (component->switch_on)
	    switch_on = component->switch_on;
	  else if (module->switch_on)
	    switch_on = module->switch_on;

	  if (component->options || switch_on) {
	    fprintf(fh_shadow, "%s ", component->name);
	    if (switch_on) {
	      fprintf(fh_shadow, "-switch %s ", switch_on);
	    }
	    if (component->options) {
	      fprintf(fh_shadow, "-options %s", component->options);
	    }
	    fprintf(fh_shadow, "\n");
	  }

          /* Setup Install Dir */
          if (component->install == NULL)
          {
            sb_buildfilename(BUFFER_LEN, output_path, build_dir, INSTALL_DIR, build_name, module->output, NULL);
          }
          else
          {
            /* -install has been set for this component in the Components file, so add the contents to install dir */
            sb_buildfilename(BUFFER_LEN, output_path, build_dir, INSTALL_DIR, build_name, component->install, NULL);
          }

          if ((component->options != NULL)
               &&
              (strstr_ci(component->options, "INSTDIR=") != NULL))
          {
            if (amu_machinef("install COMPONENT=%s %s%s %s",
                             component->name,
                             module->filename?"TARGET=":"",
                             module->filename?module->filename:"",
                             component->options ? component->options : "")
                != 0) error(1, "running make install on module '%s'.", component->name);
          }
          else
          {
            if (amu_machinef("install COMPONENT=%s %s%s INSTDIR=%s %s",
                             component->name,
                             module->filename?"TARGET=":"",
                             module->filename?module->filename:"",
                             output_path,
                             component->options ? component->options : "")
                != 0) error(1, "running make install on module '%s'.", component->name);
          }
       }

    }
    component = component->next;
  }

  if (fh_shadow)
    fclose(fh_shadow);

  sb_system_sync();

  return 0;
}



/*
 * do release_autobuild phase
 * Added by SAR (12th Jul 2009).
 */
int
build_release_autobuild(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  char output_path[BUFFER_LEN];
  FILE *fh_shadow = NULL;
  char *switch_on = NULL;
  module_type_t type;

  sb_buildfilename(BUFFER_LEN, buffer, build_dir, BUILDSYS_DIR, SHADOW_DIR, build_name, NULL);
  if ((fh_shadow = fopen(buffer, "w")) == NULL)
    error(1, "cannot open shadow file '%s'.", buffer);

  sb_system_sync();

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case C:
      case ASM:
      case BAS:
      case RES:
      case LOADER:
      case KERNEL:
      case HAL:
      case DATA:
        if (build_select_module_directory(component, module)) {
          /*
           * find out what we are switching this module on
           */
          switch_on = NULL;
          if (component->switch_on)
            switch_on = component->switch_on;
          else if (module->switch_on)
            switch_on = module->switch_on;

          if (component->options || switch_on) {
            fprintf(fh_shadow, "%s ", component->name);
            if (switch_on) {
              fprintf(fh_shadow, "-switch %s ", switch_on);
            }
            if (component->options) {
              fprintf(fh_shadow, "-options %s", component->options);
            }
            fprintf(fh_shadow, "\n");
          }

          /* Setup Install Dir */
          if (component->install == NULL)
          {
            sb_buildfilename(BUFFER_LEN, output_path, build_dir, INSTALL_DIR, build_name, module->output, NULL);
          }
          else
          {
            /* -install has been set for this component in the Components file, so add the contents to install dir */
            sb_buildfilename(BUFFER_LEN, output_path, build_dir, INSTALL_DIR, build_name, component->install, NULL);
          }

          if ((component->options != NULL)
               &&
              (strstr_ci(component->options, "INSTDIR=") != NULL))
          {
            if (amu_machinef("-k release_autobuild COMPONENT=%s %s%s %s",
                             component->name,
                             module->filename?"TARGET=":"",
                             module->filename?module->filename:"",
                             component->options ? component->options : "")
                != 0) error(0, "running make release_autobuild on module '%s'.", component->name);
          }
          else
          {
            if (amu_machinef("-k release_autobuild COMPONENT=%s %s%s INSTDIR=%s %s",
                             component->name,
                             module->filename?"TARGET=":"",
                             module->filename?module->filename:"",
                             output_path,
                             component->options ? component->options : "")
                != 0) error(0, "running make release_autobuild on module '%s'.", component->name);
          }
       }

    }
    component = component->next;
  }

  if (fh_shadow)
    fclose(fh_shadow);

  sb_system_sync();

  return 0;
}



/************************************************************
 *
 * FUNC: strcasecmp()
 *
 * IN:  const char*   - pointer to first string
 *      const char*   - pointer to second string
 *
 * OUT: unsigned int  - zero = strings matched, else didn't match
 *
 * USE:
 *
 *   Compare two ASCII strings, irrespective of case. Will return zero if they
 *   match and non-zero if they do not.
 */
unsigned int strcasecmp(const char *xs, const char *ys)
{
  unsigned char xc;
  unsigned char yc;

  if (*ys == '\0') return(0);
  do
  {
    xc = *xs++;
    yc = *ys++;
    ASCII_LowerCase(xc);
    ASCII_LowerCase(yc);
    if (xc != yc) return(1);
  } while (*ys != '\0');

  return (0);
}
/************************************************************
 *
 * FUNC: strstr_ci()
 *
 * IN:   const char*  - pointer to string to search in
 *       const char*  - pointer to substring to search for
 *
 * OUT:  char*        - pointer to first matched substring (NULL if not found)
 *
 * USE:
 *
 *   Look for a substring within an ASCII string, irrespective of case. Will
 *   return a pointer to the start of the first matching substring or NULL if
 *   no matches were found.
 */
const char *strstr_ci(const char *source, const char *substr)
{
  unsigned int len = strlen(source);

  do
  {
    if (strcasecmp(source, substr) == 0) return(source);
    source++;
  } while (len--);

  return(0);
}


/************************************************************
 *
 * FUNC: last_strstr_ci()
 *
 * IN:   const char*  - pointer to string to search in
 *       const char*  - pointer to substring to search for
 *
 * OUT:  char*        - pointer to last matched substring (NULL if not found)
 *
 * USE:
 *
 *   Look for a substring within an ASCII string, irrespective of case. Will
 *   return a pointer to the start of the last matching substring or NULL if
 *   no matches were found.
 */
static const char *last_strstr_ci(const char *source, const char *substr)
{
  const char *sub = NULL;
  const char *nxt = strstr_ci(source, substr);

  while (nxt)
  {
    sub = nxt++;
    nxt = strstr_ci(nxt, substr);
  }

  return(sub);
}


/************************************************************
 *
 * FUNC: copy_env()
 *
 * IN:   const char *  - pointer to environment variable to write
 *       const char *  - pointer to environment variable to read
 *
 * OUT:  None.
 *
 * USE:
 *
 *   Set an environment variable to contain a copy of the contents of another.
 *   This will create the variable to write if it does not already exist. It
 *   will not do anything if the variable to read does not exist.
 */
void copy_env(const char *env_wr, const char *env_rd)
{
  const char *val = sb_getenv(env_rd);

  if (val) sb_setenv(env_wr, val);
}


/************************************************************
 *
 * FUNC: override_envvar()
 *
 * IN:   const char*  - options string passed to amu_machine
 *       const char*  - option/variable to look for (i.e. "Locale", "UserIF", "Machine")
 *       const char*  - temporary variable to copy variable into (i.e. "Locale$tmp")
 *
 * OUT:  None.
 *
 * USE:
 *
 *   Various options are traditionally set in environment variables, which a
 *   component can then use in its Makefile. These variables usually have an
 *   associated parameter which can be passed as an option to amu. This routine
 *   will ensure that the environment variables reflect the value of any option
 *   (taking the last instance if it is multiply defined).
 *
 *   For example, with a command line of:
 *
 *     "amu_machine install Locale=UK INSTDIR=<Install$Dir> Locale=Taiwan"
 *
 *   and the variable to scan for is "Locale", the assignment we find will be
 *   "Locale=Taiwan". Thus, we set "Locale$tmp" to "<Locale>" and then set
 *   "Locale" to "Taiwan".
 */
void override_envvar(const char *source, const char *var, const char *tmpvar)
{
  char buffer[ENVVAR_BUF_LEN];
  const char *end;
  const char *sub = last_strstr_ci(source, var);
  unsigned int len;

  /* Copy the value of the specified variable into its tmp partner */
  copy_env(tmpvar, var);

  /* If we didn't find this var in the options list, simply exit */
  if (sub == 0) return;

  /* If the match doesn't start with a space, discard it */
  if (*(sub - 1) != ' ') return;

  /* Given the last 'var=val' assignment in the options list for
   * the variable specified to this function, look for what value
   * it is to be set to */
  sub += strlen(var);

  /* Exit if the assignment is missing the '=' sign */
  if (*sub++ != '=') return;

  /* Find the end of the  */
  len = strlen(sub);
  end = strchr(sub, ' ');
  if (end != NULL) len = (end - sub);

  /* If the 'var=' assignment is empty, exit */
  if (len == 0) return;

  /* Set the specified variable to the assigned value */
  assert(ENVVAR_BUF_LEN >= len);
  strncpy(buffer, sub, len);
  *(buffer+len) = '\0';
  sb_setenv(var, buffer);
}
@


1.48
log
@Suppress compiler warnings
Detail:
  * Make several variables and functions static.
  * Initialise variables.
  * Add missing return statement.
  * Add missing header include.
  * Delete declaration of non-existant static function.
Admin:
  Submission from Timothy Baldwin.

Version 0.52. Tagged as 'srcbuild-0_52'
@
text
@d123 2
d131 1
a131 1
    vsprintf(buffer,full_format, list);
d136 2
a137 2
    if (strlen(buffer) >= sizeof(buffer)) {
      sb_printf("ABORT: Overwrite of command string buffer (%d)\n", strlen(buffer));
@


1.47
log
@Treat install build phase errors as fatal
Detail:
  c/build - Instead of ignoring install build phase errors, treat them as fatal. Should help to avoid the autobuilder spitting out bad disc/!System builds.
Admin:
  Tested with performing BuildHostDev, DiscDev, PlingSystem builds


Version 0.50. Tagged as 'srcbuild-0_50'
@
text
@d57 1
a98 3
/* Internal function invoked by build_resources and build_bbe */
static int build_resources_(build_resources_reason_code);

d868 2
a869 2
  char *end_bbe_dir;
  char *end_rom_link_name;
d2198 1
a2198 1
const char *last_strstr_ci(const char *source, const char *substr)
@


1.46
log
@Modified to not assume all source code is in a "Sources" directory (or relative
to that location).
Also cleaned up the makefile's clean phase.

Admin: THIS VERSION OF SRCCOMMIT WILL BREAK EXISTING BUILDS!

Version 0.49. Tagged as 'srcbuild-0_49'
@
text
@d1986 1
a1986 1
            if (amu_machinef("-k install COMPONENT=%s %s%s %s",
d1991 1
a1991 1
                != 0) error(0, "running make install on module '%s'.", component->name);
d1995 1
a1995 1
            if (amu_machinef("-k install COMPONENT=%s %s%s INSTDIR=%s %s",
d2001 1
a2001 1
                != 0) error(0, "running make install on module '%s'.", component->name);
@


1.45
log
@Doh! Forgot to rename some instances of "autobuild".

I knew the debate over whether the new phase should be called
"release_autobuild" after the fact I had already finished
implementing it as just "autobuild" would come back and bite
me on the ass. And it did. Top.

Version 0.47. Tagged as 'srcbuild-0_47'
@
text
@d177 2
a178 2
  sb_printf("\n%s...\n", component->name);
  sb_buildfilename(BUFFER_LEN, buffer, build_dir, SOURCE_DIR, module->path, NULL);
d637 1
a637 1
              sb_buildfilename(BUFFER_LEN, bbe_dir, INSTALL_DIR, build_name, BBE_DIR, SOURCE_DIR, module->path, BBE_TMP_RES, target, NULL);
d942 1
a942 1
          sb_buildfilename(BUFFER_LEN, aof_target, INSTALL_DIR, build_name, BBE_DIR, SOURCE_DIR, module->path, NULL);
d1120 1
a1120 1
          sb_buildfilename(BUFFER_LEN, bbe_dir, build_dir, INSTALL_DIR, build_name, BBE_DIR, SOURCE_DIR, module->path, NULL);
d1322 1
a1322 1
            sb_buildfilename(BUFFER_LEN, scriptdirname, INSTALL_DIR, build_name, BBE_DIR, SOURCE_DIR, module->path, BBE_TMP_ROM, module->filename, NULL);
d1327 1
a1327 1
              sb_buildfilename(BUFFER_LEN, scriptdirname, INSTALL_DIR, build_name, BBE_DIR, SOURCE_DIR, module->path, "rm", NULL);
d1329 1
a1329 1
              sb_buildfilename(BUFFER_LEN, scriptdirname, build_dir, INSTALL_DIR, build_name, BBE_DIR, SOURCE_DIR, module->path, "rm", NULL);
@


1.44
log
@Added support for a new release_autobuild phase.

This new phase will initially only be required by a very small subset of
components which do some additional functionality at the very end of a
build process in order to wrap-up the build ready for the autobuilder to
do what it wants with the results.

Admin:
  Tested on Iyonix
Author:
  srevill

Version 0.46. Tagged as 'srcbuild-0_46'
@
text
@d2092 1
a2092 1
            if (amu_machinef("-k autobuild COMPONENT=%s %s%s %s",
d2097 1
a2097 1
                != 0) error(0, "running make autobuild on module '%s'.", component->name);
d2101 1
a2101 1
            if (amu_machinef("-k autobuild COMPONENT=%s %s%s INSTDIR=%s %s",
d2107 1
a2107 1
                != 0) error(0, "running make autobuild on module '%s'.", component->name);
@


1.43
log
@  Smoothed some rough edges in BBE exports; also corrects an apparent
  oversight in the clean phases.
Detail:
  * New type of component introduced, "BBE", for which only the BBE phase
    is executed, and for which no Makefile is exported to the BBE. Intended
    for use with BuildApps, BuildEnv etc.
  * Only creates "aof" subdirectory in BBE exports for "C" type components.
  * Doesn't create "rm" subdirectory in BBE exports for components of types
    "C", "RES" and "BBE".
  * Will now run clean and clean_all phases on "RES" type components.
Admin:
  Tested on a Tungsten BBE build.

Version 0.43. Tagged as 'srcbuild-0_43'
@
text
@d80 1
a80 1
  "\n# Copyright © 2001-2004 Castle Technology Ltd. All rights reserved."
d2019 106
@


1.42
log
@  Changes to get the BBE working again.
Detail:
  * During the changes for cross-compilation, the code that reconstructed
    the pathname for ${BBE_DIR}.BBE_ROM.rom_link in order to read it back
    was broken, with the result that all C components didn't even export
    the partially-linked code to the BBE (except the few that exported it
    explicitly).
  * The auto-generated makefiles were generating phony targets for the
    rom_link phase using ${COMPONENT} instead of ${TARGET} (as used by the
    hard-coded forwarding rule). This prevented C modules from being
    installed unless the two strings were identical.
  * Changed copyright statement in auto-generated makefiles to refer to
    Castle instead of Pace; removed the auto-generated date to make life
    easier if we attempt to keep built BBEs under change control.
Admin:
  Tested on a Tungsten BBE build.

Version 0.42. Tagged as 'srcbuild-0_42'
@
text
@d387 1
d440 1
d933 1
d943 4
a946 1
          _check_dir_v(aof_target, AOF_DIR, NULL);
d999 11
a1009 4
        sprintf(end_bbe_dir, "%cMakefile", host_dir_sep_char());
        makefile = fopen(bbe_dir, "r");

        if (makefile && already_processed_directory)
d1118 1
d1325 6
a1330 3
            sb_buildfilename(BUFFER_LEN, scriptdirname, INSTALL_DIR, build_name, BBE_DIR, SOURCE_DIR, module->path, "rm", NULL);
            _check_dir_v(scriptdirname, NULL);
            sb_buildfilename(BUFFER_LEN, scriptdirname, build_dir, INSTALL_DIR, build_name, BBE_DIR, SOURCE_DIR, module->path, "rm", NULL);
@


1.41
log
@  Fixed some bugs.
Detail:
  The previous check-in broke Baseline builds (or any other build which
  has a components file within a subdirectory of the BuildSys/Components
  directory). Fixed.

  Also, where a build includes multiple instances of the same component
  to be built with dfferent options, the force clean rule was not being
  invoked if the build itself included a clean (or clean_all) phase.

  This meant that object files from the first time the component was built
  would still be resident for the next version(s). Now, duplicate components
  are flagged internally as being duplicate so their force_clean flag is not
  cleared during the clean or clean_all phases.
Admin:
  Tested in early Baseline 500 builds on Iyonix.

Version 0.41. Tagged as 'srcbuild-0_41'
@
text
@d80 1
a80 7
  "\n# Copyright [2001] Pace Micro Technology PLC.  All rights reserved."
  "\n#"
  "\n# The copyright in this material is owned by Pace Micro Technology PLC"
  "\n# (\"Pace\").  This material is regarded as a highly confidential trade secret"
  "\n# of Pace.  It may not be reproduced, used, sold or in any other way exploited"
  "\n# or transferred to any third party without the prior written permission of"
  "\n# Pace."
a864 1
  char buffer[BUFFER_LEN];
d958 1
a958 1
          sb_buildfilename(BUFFER_LEN, rom_link_name, BBE_TMP_ROM, target, "rom_link", NULL);
a960 3
          /* Set up the path to the source of this component */
          sb_buildfilename(BUFFER_LEN, buffer, build_dir, SOURCE_DIR, module->path, NULL);

a1021 3
              "#\n"
              "# Automatically generated: last update at %s"
              "#\n"
a1043 1
              ctime(&now),
d1067 1
a1067 1
              copy_rom_link_rules(makefile, rom_link_file, aof_target, component->name);
@


1.40
log
@Now runs stripdepnd after every clean_all.

Version 0.40. Tagged as 'srcbuild-0_40'
@
text
@a238 1
#if 0
a260 1
#endif
d330 1
d333 1
a333 2
  _check_dir(NULL, INSTALL_DIR);
  _check_dir(INSTALL_DIR, build_name);
d411 1
a411 1
  	component->force_clean = FALSE;
d467 1
a467 1
  	component->force_clean = FALSE;
@


1.39
log
@No longer goes around creating Install.<Build> directories in the CSD
whenever a build is started!

Version 0.39. Tagged as 'srcbuild-0_39'
@
text
@d456 1
d463 3
@


1.38
log
@  * Added support for the clean_all phase.
  * Slight tweak to (ram) install phase.
  * Corrected utterly insignificant comment in clean phase.
Detail:
  * Some of the major libraries (i.e. Desk and RISC_OSLib) do not really clean
    themselves in their 'clean' phase; you have to run 'clean_all' on them to
    do this. This is a pain in the proverbial for Baseline builds because you
    have to export from libraries twice - once 26bit and once 32bit. You MUST
    fully 'clean_all' libraries or you get objects of the wrong APCS exported.

    Soooo, rather than having to go through all my libraries running both
    'clean' and 'clean_all' on each manually, I've added the 'clean_all'
    option to srcbuild (and !Builder), separate from a simple 'clean'.

  * If "INSTDIR=" is one of the options passed from a Components file in the
    '-options' for a component, the install phase does not add "INSTDIR=foo"
    onto the amu command line itself (resulting in two, the latter being
    valid). This results in shorter command lines (which aren't in themselves
    much of a problem) that are a little easier to read.
Admin:
  Tested in Baseline builds.

Version 0.38. Tagged as 'srcbuild-0_38'
@
text
@d239 1
d262 1
d334 2
a335 1
  _check_dir_p(INSTALL_DIR, build_name);
@


1.37
log
@  Now sets environment variables based upon options.
Detail:
  You can now rely on the options passed in the components file to
  adjust the "Locale", "UserIF" and "Machine" environment variables
  for a component. This allows you to build components which use
  paths like "LocalRes:", "LocalUserIFRes:" in their Makefiles and
  get the correct resources out.

  I also fixed the install rule in the Makefile.
Admin:
  Builds and quite thoroughly tested.

  As an aside, I do occasionally see data aborts during builds, but
  this has been seen for a couple of years and on various build
  machines. An example is:

  INSTDIR = 'ADFS::Slayer2.$.Builds.Baseline.InstallAMU: *** Internal
  error: abort on data transfer at &0380D278 ***

  (line split for clarity). I don't know if this is amu's fault or
  scrbuild not terminating strings correctly. This is always where
  things seem to fail, i.e. the Kernel outputting a string which
  aborts before reaching the terminator - at the byte which should
  be it. Maybe it is the OS_NewLine code triggers callbacks in a
  task window which occasionally causes some nasty abort?

Version 0.37. Tagged as 'srcbuild-0_37'
@
text
@d107 4
d389 1
a389 1
    if (!component->no_component_sources) /* We do not wish to do a ROM phase of a component if we do not have any sources... */
d428 51
d1974 23
a1996 8
	  if (amu_machinef("-k install COMPONENT=%s %s%s INSTDIR=%s %s",
		component->name,
		module->filename?"TARGET=":"",
		module->filename?module->filename:"",
		output_path,
		component->options ? component->options : "") != 0)
	    error(0, "running make install on module '%s'.", component->name);
	}
d2008 1
@


1.36
log
@  Passes the options *after* all other options when running amu.
Detail:
  If you don't, you can't override defaults by specifying them in the
    -options part of the components file.
Admin:
  Built.


Version 0.36. Tagged as 'srcbuild-0_36'
@
text
@d58 13
d145 5
d152 5
d1602 1
a1602 1
    fprintf(fh, "-%s\n%s\n", 
d1937 179
@


1.35
log
@  srcbuild changes.
Detail:
  srcbuild utility modfied to cope with the Env files and Components files
  being nested inside sub-directories. This had a small impact upon the
  directory creation code.
Admin:
  Required by Builder-0_14

Version 0.35. Tagged as 'srcbuild-0_35'
@
text
@d280 4
a283 4
  sprintf(buffer, "%s%c%s", directory, host_dir_sep_char(), build);
  p  = strrchr(buffer, host_dir_sep_char());
  *p = '\0';
  _check_dir_v(prefix, buffer, NULL);
d374 1
a374 2
          if (amu_machinef("-k clean %s COMPONENT=%s %s%s",
  		component->options ? component->options:"",
d377 2
a378 1
  		module->filename?module->filename:"") != 0)
d434 1
a434 2
            if (amu_machinef("-k export %s PHASE=%s COMPONENT=%s %s%s",
              component->options ? component->options:"",
d438 2
a439 1
              module->filename?module->filename:"") != 0)
d582 1
a582 1
            if (amu_machinef("-k resources %s %s RESDIR=%s%c%s COMPONENT=%s %s%s",
a583 1
                  component->options ? component->options : "",
d589 2
a590 1
                  module->filename?module->filename:"") != 0)
d894 1
a894 1
            if (amu_machinef("-k -f %s bbe COMPONENTTYPE=%s %s VERBATIMROMLINK=%s_v BBEDIR=%s COMPONENT=%s %s%s",
a896 1
                  component->options ? component->options : "",
d901 2
a902 1
                  module->filename?module->filename:"") != 0)
d1101 1
a1101 2
  	    if (amu_machinef("-k clean %s COMPONENT=%s %s%s",
  		component->options ? component->options : "",
d1104 2
a1105 1
  		module->filename?module->filename:"") != 0)
d1128 1
a1128 2
  	  if (amu_machinef("-k rom %s COMPONENT=%s %s%s",
  		component->options ? component->options : "",
d1131 2
a1132 1
  		module->filename?module->filename:"") != 0)
d1257 1
a1257 1
		if (amu_machinef("rom_link %s LINKDIR=%s %s COMPONENT=%s %s%s",
a1259 1
			component->options ? component->options : "",
d1262 2
a1263 1
			module->filename?module->filename:"") != 0)
d1270 1
a1270 1
		if (amu_machinef("install_rom INSTDIR=%s %s COMPONENT=%s %s%s",
a1271 1
		 	component->options ? component->options : "",
d1274 2
a1275 1
			module->filename?module->filename:"") != 0)
d1579 2
a1580 1
    fprintf(fh, "-%s\n%s\n", hash_key(join_db, join_entries[i]), hash_value(join_db, join_entries[i]));;
d1859 3
a1861 3
	    if (amu_machinef("-k clean %s COMPONENT=%s",
		component->options ? component->options : "",
		component->name) != 0)
d1896 1
a1896 2
	  if (amu_machinef("-k install %s COMPONENT=%s %s%s INSTDIR=%s",
		component->options ? component->options : "",
d1900 2
a1901 1
		output_path) != 0)
@


1.34
log
@  Fixed bug in 'install' target support.
Detail:
  Install behaviour broken in srcbuild-0_26.  <Install$Dir> was no longer
  being passed as part of INSTDIR, and '-inst' flag in components file was
  being ignored.  Fault affected disc builds (i.e. STB baselines) and
  podule/extension ROMS.
Admin:
  Tested on RISC OS using test product.
  Portable change, although untested on Unix.

Version 0.33. Tagged as 'srcbuild-0_33'
@
text
@d212 23
d272 17
a303 1
  _check_dir(NULL, INSTALL_DIR);
d305 1
a305 2
  _check_dir(INSTALL_DIR, build_name);
  _check_dir(BUILDSYS_DIR, SHADOW_DIR);
d307 1
@


1.33
log
@  Recursive deletion now used.
Detail:
  The previous change to support multiple target BBE exports broke the
    deleting of BBE_Rom and BBE_Res directories because the recursion
    option was not specifed to OS_FSControl 27 (*Wipe)
Admin:
  Tested.

Version 0.32. Tagged as 'srcbuild-0_32'
@
text
@a1789 1
  char *end_of_path;
d1846 1
a1846 5
          sb_buildfilename(BUFFER_LEN, output_path, INSTALL_DIR, build_name, NULL);
          end_of_path = strchr(output_path, '\0');
          *end_of_path++ = host_dir_sep_char();
          /* If -install is set then add it to install dir */
          if (component->install != NULL)
d1848 1
a1848 1
            strcpy(end_of_path, component->install);
d1852 2
a1853 11
            /* Some components don't have an Output dir.  If it isn't specified then install to
             * <install$dir>.<build>.component->name
             */
            if (module->output != NULL)
            {
              strcpy(output_path, module->output);
            }
            else
            {
              strcpy(output_path, component->name);
            }
d1862 1
a1862 1
	    error(0, "running make rom on module '%s'.", component->name);
@


1.32
log
@  Several little updates.
Detail:
  The RESDIR setting passed down to components is now fixed to be
    <Resource$Dir>.Resources for the first 64 components,
    <Resource$Dir>.Resources2 for the next 64,
    <Resource$Dir>.Resources3 for the next 64 etc.
    Currently most components explicitly override srcbuild's suggestion,
    but this is dangerous (could cause weird resource problems on old
    build machines).  64 chosen since it is comfortably less than 77.
  If a component appears twice in the components file(s), it is warned
    about.
  The default selection of image type (rom, exprom, extrom, other) is
    delayed until all components files are parsed - previously the choice
    would have been made at the end of any included file.
  BBE builds can cope with components that host multiple targets - notably
    the territory modules.  This used to fail previously (and required the
    entire sources of the component to be shipped) since only one target,
    the last to be processed, would be written into the BBE Makefile.
Admin:
  Tested briefly with various builds.

Version 0.31. Tagged as 'srcbuild-0_31'
@
text
@d1002 1
a1002 1
          sb_wipe_objects(bbe_dir);
d1004 3
a1006 1
          sb_wipe_objects(bbe_dir);
@


1.31
log
@  C+P is evil.
Detail:
  Now outputs kernel->force_position and not component->force_position when
    using a HAL (ie. fixed position kernel).
Admin:
  Tested on Customer L build machine.

Version 0.30. Tagged as 'srcbuild-0_30'
@
text
@d174 1
a174 1
  sb_buildfilename(BUFFER_LEN, buffer, build_dir, messages_filename, "Resources", build_name, num_locale, locale, NULL);
d255 1
a276 11
  if (num_of_territories > 0)
  {
    unsigned int loop;
    for (loop=0; loop < num_of_territories; loop++)
    {
      _check_dir_v(messages_filename, "Resources", build, numeric, supported_territories[loop], "Apps", NULL);
      _check_dir_v(messages_filename, "Resources", build, numeric, supported_territories[loop], "Resources", NULL);
      _check_dir_v(messages_filename, "Resources", build, numeric, supported_territories[loop], "Resources2", NULL);
    }
  }

d287 1
d290 16
d512 2
d519 1
a519 1
              sb_buildfilename(BUFFER_LEN, bbe_dir, INSTALL_DIR, build_name, "BBE", SOURCE_DIR, module->path, NULL);
d523 1
a523 1
              _check_dir_v(bbe_dir, "BBE_Res", NULL);
d536 6
d543 1
a543 1
            if (amu_machinef("-k resources %s %s RESDIR=%s%cResources COMPONENT=%s %s%s",
d548 1
d598 1
a598 1
static void copy_rom_link_rules(FILE *dest, FILE *source, const char *aof_target, const char *componentname)
d611 1
a611 1
  sprintf(link_args, "link -o linked%c${TARGET} -rmf -base ${ADDRESS} aof%c${TARGET}", dir_sep, dir_sep);
d666 1
a666 1
      "rom_link:\n"
d669 1
d689 1
a689 1
  unsigned int loop, done_uk = 0;
d695 1
a695 9
    if (!done_uk) {
      locale = "UK";
      done_uk = 1;
      --loop;
    }
    else {
      locale = supported_territories[loop];
      if (strcmp(locale, "UK") == 0) continue;
    }
d701 1
a701 1
    fprintf(makefile, "resources-%s:\n", locale);
d715 26
d797 2
d800 1
d805 2
d825 2
a826 2
          _check_dir_v(aof_target, "aof", NULL);
          _check_dir_v(aof_target, "BBE_ROM", NULL);
d835 1
a835 1
          sb_buildfilename(BUFFER_LEN, aof_target, bbe_dir, "aof", module->filename?module->filename:component->name, NULL);
d838 4
a841 1
          remove(rom_link_name);
d843 1
a843 1
          sb_buildfilename(BUFFER_LEN, rom_link_name, "BBE_ROM", "rom_link", NULL);
d883 6
a888 1
        if (makefile)
d925 6
a930 2
              "resources: resources-${LOCALE}\n"
              "\t@@echo ${COMPONENT}: resources exported\n"
d939 1
d949 2
a950 2
          sprintf(end_bbe_dir, "%cBBE_Res%c", dir_sep, dir_sep);
          copy_locale_resources(makefile, bbe_dir, component->name);
d1001 1
a1001 1
          strcpy(end_bbe_dir, "BBE_Res");
d1003 1
a1003 1
          strcpy(end_bbe_dir, "BBE_ROM");
d1198 1
a1198 1
            sb_buildfilename(BUFFER_LEN, scriptdirname, INSTALL_DIR, build_name, BBE_DIR, SOURCE_DIR, module->path, "BBE_ROM", NULL);
@


1.30
log
@  A handful of fixes to resolve problems introduced during recent work.
Detail:
  RESDIR is passed down as <Resource$Dir>.Resources (RISCOS) builds, as
    expanding the system variable causes command line buffer overflows
    in LazarusUI (without expansion the line is 249 bytes long - the
    limit is 255).
  Additionally, RESDIR is also passed as <path>/Resources - previously
    Resources was missing and resulted in the resources being exported
    to the wrong directories.
  Export.<APCS>.Lib is explicitly created (safety feature, because HdrSrc
    creates it anyway, but realistically it should be done here)
  Command-line buffer created during amu_machinef is now length checked
    to abort srcbuild if data has been overwritten.
Admin:
  Tested in Laz1UK build - fixes problems in earlier versions.

Version 0.29. Tagged as 'srcbuild-0_29'
@
text
@d1533 1
a1533 1
      fprintf(fh, "%lu\n", component->force_position - base);
@


1.29
log
@  More wide-ranging changes to srcbuild for portability and romlinker.
Detail:
  The romlinker joiner format is now defined and implemented by srcbuild.
    This means that srcbuild can invoke romlinker to join main ROMs,
    expansion ROMs or extension ROMs depending on a switch in a product's
    components file (the %format directive should specify a value of one
    of rom extrom or exprom).
  Any %-directives that are not srcbuild directives are passed through to
    romlinker as command-line options.  All target image sizes are passed
    through in bytes - see romlinker documentation for full details of the
    interfaces.
  Environment variables are set to represent the territory mappings.  This
    is done on all targets so that other tools can rely on retrieving the
    information via getenv() and not needing to prod the International
    module directly.
  extern declarations removed from .c files into .h files to remove chance
    of mismatched multiple declarations.
  Some spelling corrections in comments, system call synchronisation calls
    added, although sb_system does not implement parallel makes yet.
  Documentation added on the portability aspects, environmental aspects and
    the territory mapping stuff.  A program is provided (MkDefaults) to
    run under RISC OS to generate up-to-date source code for srcbuild's
    territory information database.
  srcbuild now keeps note of the type of image that it is generating, rather
    than relying on reverse-engineering it from the joiner and joiner format
    strings (set by %format in the component file, defaults to main ROM)
  Many comments updated to reflect the actual code, some obsolete code
    removed.
Admin:
  This version should represent a functionally complete version capable of
    running cross-compiled builds on UNIX systems.
  Tested on RISC OS.

Version 0.27. Tagged as 'srcbuild-0_27'
@
text
@d125 4
d274 1
d440 1
d522 3
d526 1
d528 1
a528 1
            if (amu_machinef("-k resources %s%s RESDIR=%s COMPONENT=%s %s%s",
d532 1
d538 1
d540 1
@


1.28
log
@  Portable version of srcbuild.
  Has initial knowledge of the romlinker tool - work incomplete.
Detail:
  This is a portable version of srcbuild.  It is no longer tied to various
    RISC OS concepts such as: global shared environment namespace;
    *Spool; . as directory separator (host's directory separator is read
    during program startup).
  UNIX version stores the "system variables" in a hash table and exports
    the contents of the environment hash table to new processes which it
    forks.  UNIX version does not parallelise builds currently - in theory
    with a little more intelligence in sb_system to manage the log file
    coherently, it should be possible to parallelise some actions during
    builds (because it will avoid blocking srcbuild when waiting for I/O,
    and because changing the environment in the parent srcbuild process
    won't affect any children that are still running)
  A lot of things have changed in this version - many functions have been
    renamed to avoid clashes with UNIX system calls (most calls in riscos.c
    in fact); printf/fprintf(stderr...) are no longer used directly -
    sb_printf/sb_fprintf is used instead to ensure data is copied to the
    log file.
  ROM joining works on Solaris if you supply the Install/<Build> directory
    fully populated with files from a RISC OS build which comprise the
    ROM image.  Identical images are produced (with: romlinker -format rom).
  This version of srcbuild cannot use romlinker to build anything other
    than ROM images - syntax for specifying expansion/extension images
    is yet to be implemented.  To test, set %Joiner and %JoinerFormat to
    romlinker in your Components file (and put romlinker in your library
    directory if you do not have a RiscOS/Library/Build which includes it)
  Removed some duplicated code that calculated ROM positions when an install_rom
    phase had not been run but a join had been requested - build_install_rom
    is now parameterised to enable the BBE generator, join phase and normal
    install_rom activities to be done by one function instead of three nearly
    identical bits of code.
  Anything other than list or join requires a compatible Makefile in each
    component in the build.
Admin:
  Tested, although not exhaustively, under RISC OS.
  Tested list & join phases on Intel Solaris.
  romlinker integration tested briefly.

Version 0.26. Tagged as 'srcbuild-0_26'
@
text
@a57 15
extern char *build_name;
extern char *build_dir;
extern char *image_filename;
extern char *log_filename;
extern char *image_size;
extern char *messages_filename;
extern char *module_type_names[];
extern char *joiner;
extern char *joiner_format;
extern char *sigstr;
extern char *signum;
extern int verbose;
extern module_entry_t *module_database;
extern component_entry_t *component_database;

d63 2
a64 1
void get_amu_machine(void);
a93 1
extern podule_info_t podule_info;
d343 2
d360 2
d403 2
d420 4
a423 3
/* Executes a resources phase - or not as the parameter may be.  If generate_script is non-zero, then
 * it is assumed to be a resource export command discovery being done by build_bbe to generate the
 * script filenames for the resource exports, otherwise it is a real resource export.
d458 1
d474 2
d535 2
d812 1
d1074 2
d1177 1
d1232 2
d1374 1
a1374 1
    error(0, "you appear to have a kernel in an expansion ROM!");
d1377 1
a1377 1
    error(0, "you appear to have a HAL in an expansion ROM!");
d1447 4
a1450 3
  int hal_count = 0;
  int kernel_count = 0;
  int size_printed = 0;
d1452 1
d1455 2
a1456 2
  /* Only if it's a ROM target though :-/ */
  if (!ran_install_rom) {
d1460 15
d1484 7
a1490 2
      fprintf(fh, "HAL:%s\n", build_generate_installed_name(BUFFER_LEN, buffer, module));
      hal_count++;
d1493 7
a1499 4
      if (component->force_position)
        fprintf(fh, "%lu\n", component->force_position - base);
      fprintf(fh, "%s\n", build_generate_installed_name(BUFFER_LEN, buffer, module));
      kernel_count++;
d1502 7
a1508 1
      error(0, "you appear to have an extension ROM/expansion card loader in this ROM");
d1511 2
a1512 4
    if (hal_count + kernel_count == 1 && !size_printed) {
      /* write out the image filename */
      sb_buildfilename(BUFFER_LEN, buffer, build_dir, IMAGES_DIR, image_filename, NULL);
      fprintf(fh, "%s\n", buffer);
d1514 3
a1516 2
      /* write out the image size and misc newline (for "extra information") */
      fprintf(fh, "%d\n\n", atoi(image_size) * 1024);
d1518 4
a1521 3
      size_printed = 1;
    }
    component = component->next;
d1524 3
a1526 8
  /* warn if things are not ok */
  if (kernel_count > 1)
    error(0, "you appear to have more than one kernel in this ROM");
  else if (kernel_count < 1)
    error(0, "you seem to be missing a kernel in this ROM");

  if (hal_count > 1)
    error(0, "you appear to have more than one HAL in this ROM");
a1536 5
      case LOADER:
        if (module->filename != NULL) {
          fprintf(fh, "LOADER:");
        }
        /*FALLTHROUGH*/
a1549 1
  fprintf(fh, "\n");
d1563 1
d1581 1
a1581 1
    error(1, "cannot open temp file '%s'.", filename);
d1603 1
a1603 1
      sprintf(buffer, "%s -sigstr %s ", joiner, sigstr);
d1614 1
a1614 5
    sprintf(buffer, "%s -format rom -modules %s", joiner, filename);
    if (sigstr) {
      strcat(buffer, " -sigstr ");
      strcat(buffer, sigstr);
    }
d1620 1
d1622 6
a1627 1
  if (sb_system(buffer) != 0)
d1629 1
a1629 2

  remove(filename);
d1659 1
a1659 1
void get_amu_machine(void)
a1661 1
  char buffer[300];
d1671 1
a1671 1
  if (DEBUG)
d1682 6
a1687 4
  _swix (OS_GSTrans, _INR(0,3),
           amu_machine, buffer, 300, 0);
  strcpy (amu_machine, buffer);

d1689 1
a1689 1
  if (DEBUG)
d1728 2
d1756 1
d1816 2
@


1.27
log
@  BBE phase added.
Detail:
  Lots of code changed - see branch logs for details.
Admin:
  The Binary Build Environment development has been done on a branch
    and is now considered stable for merge to the trunk.
  Tested in BBE.

Version 0.25. Tagged as 'srcbuild-0_25'
@
text
@d25 10
d42 1
d45 7
a51 2
#include "kernel.h"
#include "swis.h"
a57 1
extern char *progname;
a68 1
extern char *base_address;
d73 3
d81 1
a81 1
  "\n# Copyright [2000] Pace Micro Technology PLC.  All rights reserved."
a89 14
/* Internal function invoked by build_install and build_bbe */
static int build_install_rom_(int generate_script);

/* Internal function invoked by build_resources and build_bbe */
static int build_resources_(int generate_script);

/*
 * A nice veneer to OS_ReadVarVal
 */
static void misc_getenv (const char *variable, char *buffer, int buffer_size, int *nbytes)
{
  if (buffer == NULL)
  {
    _kernel_swi_regs r;
d91 10
a100 21
     r.r[0] = (int)variable;
     r.r[1] = NULL;
     r.r[2] = -1;
     r.r[3] = 0;
     r.r[4] = 0;

     _kernel_swi (OS_ReadVarVal, &r, &r);

     if (nbytes != NULL)
     {
       if (r.r[2] == 0)
         *nbytes = 0;
       else
       {
         *nbytes = ~r.r[2] + 1;
       }
     }
  }
  else
  {
    int len;
d102 2
a103 3
    _swix (OS_ReadVarVal, _INR(0,4) | _OUT(2),
           variable, buffer, buffer_size, 0, 0,
           &len);
d105 2
a106 30
    buffer[len] = '\0';

    if (nbytes != NULL)
    {
      *nbytes = len + 1;
    }
  }
}


/*
 * Veneer to OS_ReadVarVal that does it's own memory allocation, uses misc_getenv
 */
static char *misc_getenv_malloc (const char *variable)
{
  char *str;
  int len;

  misc_getenv (variable, NULL, 0, &len);

  if (len == 0)
    return NULL;
  else
  {
    str = malloc (len);
    misc_getenv (variable, str, len, &len);

    return str;
  }
}
d113 1
d115 1
d126 1
a126 1
  full_format = malloc (strlen (amu_machine) + strlen (format) + 1);
d130 1
d138 1
a138 1
      printf("%s\n",buffer);
d144 1
a144 1
    ret = system(buffer);
d149 1
a149 1
    printf ("Malloc failed, memory exhausted. Exitting...\n");
d155 1
d157 1
d159 37
d204 1
a204 1
  char buffer[BUFFER_LEN];
d207 1
a207 1
  strcat(buffer, ".");
d209 6
a214 2
    strcat(buffer, prefix);
    strcat(buffer, ".");
a215 1
  strcat(buffer, filename);
d217 3
a219 8
  switch (file_exists(buffer)) {
    case 0:
      if (mkdir(buffer, 0) == -1)
	error(1, "creating directory '%s'.", buffer);
      break;
    case 1:
      error(1, "found file %s when it should be a directory.", buffer);
  }
d227 1
a227 1
_check_dir_v(char *prefix, ...)
d231 2
d236 2
d244 7
a250 3
        if (*buffer) strcat(buffer, ".");
        next = p + strcspn(p, ".");
        strncat(strchr(buffer, '\0'), p, next - p);
d267 5
a271 2
  char *apcs = getenv("APCS");
  char *exportdir = apcs ? "Export.<APCS>" : "Export";
d275 1
d279 7
a285 7
  _check_dir(NULL, "Export");
  if (apcs) _check_dir(NULL, exportdir);
  _check_dir(exportdir, "Hdr");
  _check_dir(exportdir, "Hdr.Global");
  _check_dir(exportdir, "Hdr.Interface");
  _check_dir(exportdir, "Hdr.Interface2");
  _check_dir(NULL, "Export.Lib");
d291 3
a293 12
      char temp_string[255]; /* Nasty hard-coded value */
      _check_dir(messages_filename, "Resources");
      _check_dir(messages_filename, "Resources.<Build>");
      _check_dir(messages_filename, "Resources.<Build>.<Build$LocaleListNumeric>");
      sprintf (temp_string, "Resources.<Build>.<Build$LocaleListNumeric>.%s", supported_territories[loop]);
      _check_dir(messages_filename, temp_string);
      sprintf (temp_string, "Resources.<Build>.<Build$LocaleListNumeric>.%s.Resources2", supported_territories[loop]);
      _check_dir(messages_filename, temp_string);
      sprintf (temp_string, "Resources.<Build>.<Build$LocaleListNumeric>.%s.Resources", supported_territories[loop]);
      _check_dir(messages_filename, temp_string);
      sprintf (temp_string, "Resources.<Build>.<Build$LocaleListNumeric>.%s.Apps", supported_territories[loop]);
      _check_dir(messages_filename, temp_string);
d297 1
a297 4
  /* set the Resource$Dir environment variable */
  sprintf(buffer, "%s.%s."RESDIR".^",
	  build_dir, messages_filename, supported_territories[0]);
  setenv("Resource$Dir", buffer);
a298 1
  _check_dir(NULL, INSTALL_DIR);
d305 1
a305 2
      sprintf(buffer, "%s.%s", build_name, module->output);
      _check_dir(INSTALL_DIR, buffer);
a312 2


a316 1
  char buffer[BUFFER_LEN];
d336 3
a338 5
  	printf("\n%s...\n", component->name);
  	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
  	if (chdir(buffer))
  	  error(0, "cannot locate '%s'", buffer);
  	else if (amu_machinef("-k clean %s COMPONENT=%s %s%s",
d343 1
a343 1
  	  error(0, "running make clean on module '%s'.", component->name);
d352 1
a352 1
      printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running clean phase on this component.\n", component->name, component->name);
d364 4
a367 2

int build_export_hdrs(void)
a370 1
  char buffer[BUFFER_LEN];
d380 2
a381 1
    if (!component->no_component_sources) /* We do not wish to do an export_hdrs phase of a component if we do not have any sources... */
d386 1
d393 10
a402 13
  	printf("\n%s...\n", component->name);
  	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
  	if (chdir(buffer))
  	  error(0, "cannot locate '%s'", buffer);
  	else if (amu_machinef("-k export %s PHASE=hdrs COMPONENT=%s %s%s",
  		component->options ? component->options:"",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"") != 0) {
  	  error(0, "running make export (hdrs) on module '%s'.",
  		component->name);
  	}
  	break;
d407 3
a409 1
      printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running export_hdrs phase on this component.\n", component->name, component->name);
d417 4
a420 1

d424 1
a424 46
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (!component->no_component_sources) /* We do not wish to do an export_libs phase of a component if we do not have any sources... */
    {
      switch (type)
      {
        case ASM:
        case C:
        case BAS:
        case KERNEL:
        case HAL:
        case DATA:
        case EXP:
  	printf("\n%s...\n", component->name);
  	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
  	if (chdir(buffer))
  	  error(0, "cannot locate '%s'", buffer);
  	else if (amu_machinef("-k export %s PHASE=libs COMPONENT=%s %s%s",
  		component->options ? component->options:"",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"")  != 0) {
  	  error(0, "running make export (libs) on module '%s'.",
  		component->name);
  	}
  	break;
      }
    }
    else
    {
      printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running export_libs phase on this component.\n", component->name, component->name);
    }
    component = component->next;
  }

  return 0;
d429 5
a433 2

static int build_resources_(int generate_script)
d441 2
a442 1
  char* locale = NULL;
d445 1
a445 1
  if (!generate_script)
d448 1
a448 1
    if ((locale = read_env(ENV_NUM_LOCALE)) == NULL)
d450 1
a450 1
      error(1, "Could not read the numeric lcoale list system variable. */");
d458 2
a459 2
    printf("\nCleaning Messages...\n");
    sprintf(buffer, "%s.%s", build_dir, messages_filename);
d461 1
a461 2
    printf("\nCleaning Messages directory %s...\n", buffer);
    if (chdir(buffer))
d494 1
d500 1
a500 7
	printf("\n%s...\n", component->name);
	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	if (chdir(buffer))
	{
	  error(0, "cannot locate '%s'", buffer);
	}
	else
d502 4
a505 1
          if (num_of_territories > 0)
d507 9
a515 3
            /* We have been given a list of territories - iterate down them */
            unsigned int loop;
            for (loop=0; loop < num_of_territories; loop++)
d517 1
a517 25
              if (generate_script)
              {
                sprintf(bbe_dir, "%s.%s.BBE.%s.%s", INSTALL_DIR, build_name, SOURCE_DIR, module->path);
                sprintf(scriptfilename, "-o %s.%s.BBE_Res.%s ", build_dir, bbe_dir, supported_territories[loop]);
                remove(scriptfilename + 3);
                _check_dir_v(bbe_dir, "BBE_Res", NULL);
              }
              else
              {
                *scriptfilename = '\0';
              }
              /* set the Resource$Dir and Locale environment variable to the current */
              sprintf(buffer, "%s", supported_territories[loop]);
              setenv("Locale", buffer);
              sprintf(buffer, "%s.%s.Resources."RESDIR, build_dir, messages_filename, supported_territories[loop]);
              setenv("Resource$Dir", buffer);
              get_amu_machine(); /* Reset amu_machine to include the new values */

              if (amu_machinef("-k resources %s%s RESDIR=<Resource$Dir>.Resources COMPONENT=%s %s%s",
                    scriptfilename,
		    component->options ? component->options : "",
		    component->name,
		    module->filename?"TARGET=":"",
		    module->filename?module->filename:"") != 0)
	      error(0, "running make resources on module '%s'.", component->name);
d519 14
d535 1
d541 1
a541 8
  sprintf(buffer, "%s", supported_territories[0]);
  setenv("Locale", buffer);
  sprintf(buffer, "%s.%s.Resources."RESDIR, build_dir, messages_filename, supported_territories[0]);
  setenv("Resource$Dir", buffer);
  if (verbose)
  {
    printf ("Set Locale and Resource$Dir to %s\n", buffer);
  }
d548 1
a548 1
  return build_resources_(0);
d583 1
d585 1
a585 1
  strcpy(link_args, "link -o linked.${TARGET} -rmf -base ${ADDRESS} aof.${TARGET}");
d638 1
a638 1
    copy_objects(aof_target, source_file);
d642 4
a645 2
      "\t@@${CP} linked.${TARGET} ${LINKDIR}.${TARGET} ${CPFLAGS}\n\n",
      link_args);
d702 2
d714 1
d727 18
a744 2
    build_resources_(1);
    build_install_rom_(1);
d760 1
d766 30
a795 22
        printf("\n%s...\n", component->name);
        sprintf(bbe_dir, "%s.%s.BBE.%s.%s", INSTALL_DIR, build_name, SOURCE_DIR, module->path);
        end_bbe_dir = strchr(bbe_dir, '\0');
        _check_dir_v(bbe_dir, "aof", NULL);
        sprintf(aof_target, "%s.%s", build_dir, bbe_dir);
        strcpy(bbe_dir, aof_target);
        end_bbe_dir = strchr(bbe_dir, '\0');
        strcpy(aof_target, bbe_dir);
        strcat(aof_target, ".aof.");
        strcat(aof_target, module->filename?module->filename:component->name);
        strcpy(end_bbe_dir, ".Makefile");
        remove(bbe_dir);
        strcpy(end_bbe_dir, ".BBE_ROM.rom_link");
        strcpy(rom_link_name, bbe_dir);
        end_rom_link_name = strchr(rom_link_name, '\0');
        sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
        if (chdir(buffer))
        {
          error(0, "cannot locate '%s'", buffer);
        }
        else
        {
a796 5
          unsigned int loop, done_uk = 0;
          for (loop=0; loop < num_of_territories && !done_uk; loop++)
          {
            if (strcmp(supported_territories[loop], "UK") == 0) done_uk = 1;
          }
d799 1
a799 12
            char *locale;
            /* set the Resource$Dir and Locale environment variable to the current */
            if (!done_uk) {
              locale = "UK";
              done_uk = 1;
              --loop;
            }
            else {
              locale = supported_territories[loop];
            }
            setenv("Locale", locale);
            get_amu_machine(); /* Reset amu_machine to include the new values */
d802 2
a803 1
            if (amu_machinef("-k -f Makefiles:BBEExport bbe COMPONENTTYPE=%s %s VERBATIMROMLINK=%s_v BBEDIR=%s COMPONENT=%s %s%s",
d827 1
a827 1
        strcpy(end_bbe_dir, ".Makefile");
d855 1
a855 1
              "include Makefiles:StdTools\n"
d861 1
a861 1
              "\t${CP} rm.${TARGET} ${INSTDIR}.${TARGET} ${CPFLAGS}\n"
d872 4
a875 1
              ctime(&now));
d885 1
a885 1
          strcpy(end_bbe_dir, ".BBE_Res.");
d927 1
d933 2
a934 2
          printf("\n%s...\n", component->name);
          sprintf(bbe_dir, "%s.%s.%s.BBE.%s.%s.", build_dir, INSTALL_DIR, build_name, SOURCE_DIR, module->path);
d936 1
d938 1
a938 1
          wipe_objects(bbe_dir);
d940 2
a941 1
          wipe_objects(bbe_dir);
d947 6
d954 1
a954 8
  sprintf(buffer, "%s", supported_territories[0]);
  setenv("Locale", buffer);
  sprintf(buffer, "%s.%s.Resources."RESDIR, build_dir, messages_filename, supported_territories[0]);
  setenv("Resource$Dir", buffer);
  if (verbose)
  {
    printf ("Set Locale and Resource$Dir to %s\n", buffer);
  }
d970 1
a970 4
  sprintf(buffer, "%s.%s.%s.%s", build_dir, BUILDSYS_DIR, SHADOW_DIR, build_name);

//  printf("DBG: shadow file: %s\n", buffer);

d980 1
a980 1
    if (!component->no_component_sources) /* We do not wish to do a clean phase of a component if we do not have any sources... */
d985 1
d990 1
a990 5
  	printf("\n%s...\n", component->name);
  	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
  	if (chdir(buffer))
  	  error(0, "cannot locate '%s'", buffer);
  	else {
d995 1
a995 1
  	    printf("Forcing a clean build due to switch/option changes...\n");
d1034 1
a1034 1
      printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running ROM phase on this component.\n", component->name, component->name);
d1045 12
d1060 1
a1060 1
build_install_rom_(int generate_script)
d1065 4
a1068 2
  unsigned long int position_in_rom = 0x03800000;
  int size;
a1070 1
  char buffer[BUFFER_LEN];
d1076 1
a1076 5
  if (base_address) {
    position_in_rom = strtoul (base_address, NULL, 0);
  }

  if (generate_script)
d1079 1
a1079 1
    sprintf(forcefilename, "%s.%s.%s.BBE.%s", build_dir, INSTALL_DIR, build_name, "force");
d1096 1
a1096 2
    sprintf(output_path, "%s.%s.%s.%s", build_dir,
	    INSTALL_DIR, build_name, module->output);
d1101 1
d1106 15
a1120 36
	printf("\n%s...\n", component->name);
	if (module->filename == NULL) {
	  printf("No output file for this component\n");
	} else {
	  sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	  if (chdir(buffer))
	    error(0, "cannot locate '%s'", buffer);
	  else {
	    if (position_forced && type != DATA) {
	      printf("Component not linked into module chain\n");
	    }
	    else if (type == DATA) {
	      if (!component->force_position)
	        component->force_position = position_in_rom;
	      if (component->force_position < position_in_rom)
	        error(0, "component overlaps previous data");
	      else {
  	        position_forced = 1;
    	        position_in_rom = component->force_position;
    	      }
	    }
	    else if (type == KERNEL) {
	      if (component->force_position) {
	        if (component->force_position < position_in_rom)
	          error(0, "component overlaps previous data");
    	        position_in_rom = component->force_position;
    	      }
    	    }
            if (generate_script)
            {
              sprintf(scriptdirname, "%s.%s.BBE.%s.%s.%s", INSTALL_DIR, build_name, SOURCE_DIR, module->path, "BBE_ROM");
              _check_dir_v(scriptdirname, NULL);
              sprintf(scriptfilename, "-o %s.%s.rom_link ADDRESS=Address FORCEROMLINK=%s", build_dir, scriptdirname, forcefilename);
              sprintf(scriptdirname, "%s.%s.BBE.%s.%s.%s", INSTALL_DIR, build_name, SOURCE_DIR, module->path, "rm");
              _check_dir_v(scriptdirname, NULL);
              sprintf(scriptdirname, "%s.%s.%s.BBE.%s.%s.%s", build_dir, INSTALL_DIR, build_name, SOURCE_DIR, module->path, "rm");
d1122 6
a1127 3
            else
            {
              sprintf(scriptfilename, "ADDRESS=%lu", position_in_rom);
d1129 19
a1147 1
	    switch (type) {
d1164 1
a1164 1
		 	generate_script ? scriptdirname : output_path,
d1173 2
a1174 4
	    }
	  }
	  /* Need to stat the module file, display position in ROM */
	  sprintf(buffer, "%s.%s", output_path, module->filename);
d1176 2
a1177 2
	  if ((size = file_size(buffer)) == -1)
	    error(1, "cannot stat file '%s'.", buffer);
d1192 1
a1192 2
  if (generate_script)
  {
d1196 13
a1208 12
  /* display the ROM entries */
  banner('-');
  printf("\nSummary of linked ROM contents...\n\n");
  printf("Module name                Position in ROM  Module size\n");
  printf("-----------                ---------------  -----------\n");
  component = component_database;
  number_of_modules = 0;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;
d1210 15
a1224 13
    switch (type) {
      case ASM:
      case C:
      case BAS:
      case KERNEL:
      case HAL:
      case DATA:
	if (module->filename != NULL) {
	  number_of_modules++;
	  printf("%-25s  %08lX         %08X\n", component->name,
		 component->position, component->size);
	}
	break;
d1226 3
a1228 1
    component = component->next;
a1229 3
  printf("\nTotal of %d modules.\n", number_of_modules);

  ran_install_rom = 1;
d1237 7
a1243 1
  return build_install_rom_(0);
d1257 2
a1258 5
  unsigned long base = 0x03800000;

  if (base_address) {
    base = strtoul (base_address, NULL, 0);
  }
d1261 1
a1261 58
    unsigned long int position_in_rom;
    int size;
    int position_forced = 0;
    char buffer[BUFFER_LEN];
    char output_path[BUFFER_LEN];

    /* Scan the sizes of the files to get positions */
    position_in_rom = base;

    component = component_database;
    while (component) {
      module = lookup_module(component->name);
      type = component->type;
      if (type == UNDEF)
        type = module->type;

      sprintf(output_path, "%s.%s.%s.%s", build_dir,
  	    INSTALL_DIR, build_name, module->output);

      switch (type) {
        case C:
        case ASM:
        case BAS:
        case KERNEL:
        case HAL:
        case DATA:
        if (module->filename != NULL)
        {
	  if (position_forced && type != DATA) {
	  }
	  else if (type == DATA) {
	    if (!component->force_position)
	      component->force_position = position_in_rom;
  	    position_forced = 1;
    	    position_in_rom = component->force_position;
	  }
	  else if (type == KERNEL) {
	    if (component->force_position)
              position_in_rom = component->force_position;
    	  }
  	  /* Need to stat the module file, display position in ROM */
  	  sprintf(buffer, "%s.%s", output_path, module->filename);

  	  if ((size = file_size(buffer)) == -1)
  	    error(1, "cannot stat file '%s'.", buffer);

  	  /* keep record of things for later */
  	  component->position = position_in_rom;
  	  component->size = size;

  	  /* calculate position of next module in ROM */
  	  position_in_rom += (((unsigned long int) size + 3UL) & ~3UL);
  	  if (type != KERNEL && type != HAL)	/* add some magic if not kernel */
  	    position_in_rom += 4;
        }
      }
      component = component->next;
    }
d1273 1
a1273 2
      fprintf(fh, "HAL:%s.%s.%s.%s.%s\n", build_dir,
	      INSTALL_DIR, build_name, module->output, module->filename);
d1279 1
a1279 2
      fprintf(fh, "%s.%s.%s.%s.%s\n", build_dir,
	      INSTALL_DIR, build_name, module->output, module->filename);
d1282 3
d1288 2
a1289 1
      fprintf(fh, "%s.%s.%s\n", build_dir, IMAGES_DIR, image_filename);
d1291 1
a1291 1
      /* write out the image size and misc newline */
d1317 5
d1326 4
a1329 5
	if (module->filename != NULL) {
	  if (type == DATA)
	    fprintf(fh, "%lu\n", component->position - base);
	  fprintf(fh, "%s.%s.%s.%s.%s\n", build_dir,
		  INSTALL_DIR, build_name, module->output, module->filename);
d1331 1
a1331 1
	break;
d1349 2
d1363 3
d1373 3
d1377 2
a1378 1
  fprintf(fh, "%s.%s.%s\n", build_dir, IMAGES_DIR, image_filename);
d1413 5
d1422 4
a1425 5
	if (module->filename != NULL) {
	  if (type == DATA)
	    fprintf(fh, "%ld\n", component->position - 0x03800000);
	  fprintf(fh, "%s.%s.%s.%s.%s\n", build_dir,
		  INSTALL_DIR, build_name, module->output, module->filename);
d1427 96
a1522 1
	break;
d1538 13
d1553 2
a1554 1
  strcpy(filename, tmpnam(NULL));
d1564 2
d1573 1
a1573 1
    sprintf(buffer, "%s { < %s }", joiner, filename);
d1587 11
a1597 1
    sprintf(buffer, "%s { < %s }", joiner, filename);
d1599 1
d1601 1
a1601 1
  if (system(buffer) != 0)
d1626 2
a1627 2
    printf("%-25s %-10s %s\n", component->name, module_type_names[(int) type],
	   component->options ? component->options : "");
d1645 1
a1645 1
  amu_machine = misc_getenv_malloc ("Alias$amu_machine");
d1649 1
a1649 1
    printf("amu_machine now = %s\n", amu_machine);
d1652 1
d1665 1
a1665 1
    printf("amu_machine now = %s\n", amu_machine);
d1667 1
a1667 1

d1684 1
a1684 1
 * Added by SNB (Mon 09th August 1999).
d1696 1
d1698 1
a1698 1
  sprintf(buffer, "%s.%s.%s.%s", build_dir, BUILDSYS_DIR, SHADOW_DIR, build_name);
a1708 34

//  printf("DBG: build_dir: %s\n", build_dir);
//  printf("DBG: install_dir: %s\n", INSTALL_DIR);
//  printf("DBG: build_name: %s\n", build_name);
//
//  if (module->name == NULL)
//    printf("DBG: module_name: NULL\n");
//  else
//    printf("DBG: module_name: %s\n", module->name);
//  if (module->path == NULL)
//    printf("DBG: module_path: NULL\n");
//  else
//    printf("DBG: module_path: %s\n", module->path);
//  if (module->output == NULL)
//    printf("DBG: module_output: NULL\n");
//  else
//    printf("DBG: module_output: %s\n", module->output);
//  if (module->filename == NULL)
//    printf("DBG: module_filename: NULL\n");
//  else
//    printf("DBG: module_filename: %s\n", module->filename);
//  if (component->name == NULL)
//    printf("DBG: component_name: NULL\n");
//  else
//    printf("DBG: component_name: %s\n", component->name);
//  if (component->options == NULL)
//    printf("DBG: component_options: NULL\n");
//  else
//    printf("DBG: component_options: %s\n", component->options);
//  if (component->install == NULL)
//    printf("DBG: component_install: NULL\n");
//  else
//    printf("DBG: component_install: %s\n", component->install);

d1714 1
d1718 1
a1718 5
	printf("\n%s...\n", component->name);
	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	if (chdir(buffer))
	  error(0, "cannot locate '%s'", buffer);
	else {
d1723 1
a1723 1
	    printf("Forcing a clean build due to switch/option changes...\n");
d1750 3
a1752 1
          sprintf(output_path, "<Install$Dir>.%s", build_name);
d1756 1
a1756 2
            strcat(output_path, ".");
            strcat(output_path, component->install);
d1765 1
a1765 2
              strcat(output_path, ".");
              strcat(output_path, module->output);
d1769 1
a1769 2
              strcat(output_path, ".");
              strcat(output_path, component->name);
a1771 7

/* 	  printf("DBG: amu_machine -k install %s COMPONENT=%s %s%s INSTDIR=%s\n", */
/* 		component->options ? component->options : "", */
/* 		component->name, */
/* 		module->filename?"TARGET=":"", */
/* 		module->filename?module->filename:"", */
/* 		output_path); */
@


1.26
log
@First attempt to allow a HAL/bootloader to be placed at the bottom of the
ROM; new component type is "HAL".
Performing a Join only when DATA components are in the build should now
work again.

Version 0.24. Tagged as 'srcbuild-0_24'
@
text
@d30 2
d63 15
d150 1
d189 1
d220 28
d474 1
a474 1
int build_resources(void)
d479 2
d484 2
a485 2
  /* Read the numeric locale list */
  if ((locale = read_env(ENV_NUM_LOCALE)) == NULL)
d487 5
a491 2
    error(1, "Could not read the numeric lcoale list system variable. */");
  }
d493 17
a509 7
  /*
   * Force a make clean on the messages module. Note that this is independent
   * of any settings in the module database or component database, apart from %messages.
   * We are assuming quite a lot about the Messages module here...
   */
  printf("\nCleaning Messages...\n");
  sprintf(buffer, "%s.%s", build_dir, messages_filename);
d511 6
a516 9
  printf("\nCleaning Messages directory %s...\n", buffer);
  if (chdir(buffer))
    error(0, "cannot locate '%s'", buffer);
  else
  {
    sprintf(buffer,"-k clean COMPONENT=Messages TARGET=Messages NUMLOCALE=%s", locale);
    if (amu_machinef(buffer) != 0)
      error(0, "running make clean on module 'Messages'.");
  }
d518 2
a519 5
  /* Free the numeric locale list sys var memory. */
  if (locale) /* Usual memory-tidying gubbins */
  {
    free (locale);
    locale = NULL;
a521 3
  /* Build all the resource directories that are required. Can only be done after they have been cleaned as above. */
  build_dirs();

d547 1
a547 1
	{
d554 11
d572 2
a573 1
              if (amu_machinef("-k resources %s RESDIR=<Resource$Dir>.Resources COMPONENT=%s %s%s",
d581 330
d913 18
a930 7
            /* Use the original locale as set in the env file */
	    if (amu_machinef("-k resources %s RESDIR=<Resource$Dir>.Resources COMPONENT=%s %s%s",
		  component->options ? component->options : "",
		  component->name,
		  module->filename?"TARGET=":"",
		  module->filename?module->filename:"") != 0)
	    error(0, "running make resources on module '%s'.", component->name);
d932 8
a939 1
	}
d944 34
d1086 1
a1086 1
build_install_rom(void)
a1089 2
  char buffer[BUFFER_LEN];
  char output_path[BUFFER_LEN];
d1095 5
d1105 13
d1163 13
d1179 3
a1181 2
		if (amu_machinef("rom_link ADDRESS=%lu LINKDIR=%s %s COMPONENT=%s %s%s",
			position_in_rom, output_path,
d1193 1
a1193 1
		 	output_path,
d1223 5
d1264 6
d1590 1
a1590 1
  if (verbose)
d1605 1
a1605 1
  if (verbose)
@


1.26.2.1
log
@  Intermediate development version of the Binary Build Environment support.
Detail:
  A new action 'bbe' has been created which generates a binary build
    environment in the Install.BBE directory.  This directory contains a
    self-contained environment in which ROM builds can be performed using
    only the pre-built binaries of modules and the parts of the modules'
    resources required for a particular project.
Admin:
  Requires BuildSys 2.81 or later (RiscOS/BuildSys; tag: BuildSys-2_81)
  Requires Library 0.60 or later (RiscOS/Library; tag: Library-0_60)

  Work in progress - checkpoint only.

Version 0.24, 1.23.2.1. Tagged as 'srcbuild-0_24-1_23_2_1'
@
text
@a29 2
#include <ctype.h>
#include <time.h>
a132 1
#pragma check_printf_formats
a170 1
#pragma -v0
a200 28
/* Construct a set of directories, one level at a time. Each arg is parsed for directory
 * separators too to enable arbitrary paths to be easily created.
 */
static int
_check_dir_v(char *prefix, ...)
{
  va_list ap;
  const char *arg;
  char buffer[BUFFER_LEN];

  buffer[0] = '\0';

  va_start(ap, prefix);
  for (arg = prefix; arg; arg = va_arg(ap, const char *)) {
      const char *next, *p;
      for (p = arg, next = NULL; *p; p = next)
      {
        if (*buffer) strcat(buffer, ".");
        next = p + strcspn(p, ".");
        strncat(strchr(buffer, '\0'), p, next - p);
        _check_dir(NULL, buffer);
        if (*next) ++next;
      }
  }
  va_end(ap);
  return 0;
}

d427 1
a427 1
int build_resources_(int generate_script)
a431 2
  char bbe_dir[BUFFER_LEN];
  char scriptfilename[BUFFER_LEN];
d435 2
a436 2

  if (!generate_script)
d438 2
a439 5
    /* Read the numeric locale list */
    if ((locale = read_env(ENV_NUM_LOCALE)) == NULL)
    {
      error(1, "Could not read the numeric lcoale list system variable. */");
    }
d441 7
a447 17
    /*
     * Force a make clean on the messages module. Note that this is independent
     * of any settings in the module database or component database, apart from %messages.
     * We are assuming quite a lot about the Messages module here...
     */
    printf("\nCleaning Messages...\n");
    sprintf(buffer, "%s.%s", build_dir, messages_filename);

    printf("\nCleaning Messages directory %s...\n", buffer);
    if (chdir(buffer))
      error(0, "cannot locate '%s'", buffer);
    else
    {
      sprintf(buffer,"-k clean COMPONENT=Messages TARGET=Messages NUMLOCALE=%s", locale);
      if (amu_machinef(buffer) != 0)
        error(0, "running make clean on module 'Messages'.");
    }
d449 9
a457 6
    /* Free the numeric locale list sys var memory. */
    if (locale) /* Usual memory-tidying gubbins */
    {
      free (locale);
      locale = NULL;
    }
d459 5
a463 2
    /* Build all the resource directories that are required. Can only be done after they have been cleaned as above. */
    build_dirs();
d466 3
d494 1
a494 1
        {
a500 11
              if (generate_script)
              {
                sprintf(bbe_dir, "%s.%s.BBE.%s.%s", INSTALL_DIR, build_name, SOURCE_DIR, module->path);
                sprintf(scriptfilename, "-o %s.%s.BBE_Res.%s ", build_dir, bbe_dir, supported_territories[loop]);
                remove(scriptfilename + 3);
                _check_dir_v(bbe_dir, "BBE_Res", NULL);
              }
              else
              {
                *scriptfilename = '\0';
              }
d508 1
a508 2
              if (amu_machinef("-k resources %s%s RESDIR=<Resource$Dir>.Resources COMPONENT=%s %s%s",
                    scriptfilename,
d516 1
a516 247
        }
    }
    component = component->next;
  }

  /* Finally change the locale back to the default one (the first in the list). */
  sprintf(buffer, "%s", supported_territories[0]);
  setenv("Locale", buffer);
  sprintf(buffer, "%s.%s.Resources."RESDIR, build_dir, messages_filename, supported_territories[0]);
  setenv("Resource$Dir", buffer);
  if (verbose)
  {
    printf ("Set Locale and Resource$Dir to %s\n", buffer);
  }

  return 0;
}

int build_resources(void)
{
  return build_resources_(0);
}

static void line_by_line_copy(FILE *dest, FILE *source)
{
  char buffer[BUFFER_LEN * 2];

  while (fgets(buffer, sizeof(buffer), source) != NULL) {
    fputc('\t', dest);
    if (strncmp("echo", buffer, sizeof("echo")-1) == 0)
    {
      fputc('@@', dest);
    }
    fputs(buffer, dest);
  }
}

static void copy_file(const char *destination, const char *source)
{
  _swix(OS_FSControl, _INR(0,3), 26, source, destination, 1<<1 /* force */);
}

static void copy_rom_link_rules(FILE *dest, FILE *source, const char *aof_target, const char *componentname)
{
  char buffer[BUFFER_LEN * 2];
  char link_args[BUFFER_LEN];
  int skip_next;
  enum skip_flags {
    skip_read = 0,
    skip_ignore = 1,
    skip_copy = 2,
    skip_copy_and_ignore = (skip_ignore | skip_copy)
  };

  strcpy(link_args, "link -o linked.${TARGET} -rmf -base ${ADDRESS} aof.${TARGET}");

  while (fgets(buffer, sizeof(buffer), source) != NULL) {
    char *next, *p, *source_file = NULL;
    if (!isspace(buffer[4])) continue;
    buffer[4] = '\0';
    if (cstrcmp("link", buffer)) continue;
    buffer[4] = ' ';

    /* Parse this link command to determine where the source file is and what abssym file it is linking against */
    buffer[strcspn(buffer, "\r\n")] = '\0'; /* strip eol - zero terminate */
    skip_next = skip_ignore;
    for (p = buffer, next = NULL; *p; p = next) {
      next = p;
      while (*next && !isspace(*next)) ++next;
      if (*next) *next++ = '\0';
      while (*next && isspace(*next)) ++next;
      if (skip_next != skip_read)
      {
        if (skip_next & skip_copy)
        {
          strcat(link_args, p);
        }
        skip_next = 0;
        continue;
      }
      if (*p == '-') {
        if (cstrcmp(p+1, "base") == 0 || cstrcmp(p+1, "o") == 0 || cstrcmp(p+1, "linkversion") == 0) {
          skip_next = skip_ignore;
        }
        else if (cstrcmp(p+1, "symdefs") == 0 || cstrcmp(p+1, "S") == 0 || cstrcmp(p+1, "syms") == 0 || cstrcmp(p+1, "symbols") == 0) {
          sprintf(strchr(link_args, '\0'), " %s ", p);
          skip_next = skip_copy_and_ignore;
        }
        continue;
      }
      if (*p == '>')
      {
        skip_next = p[1] ? skip_read : skip_ignore;
        continue;
      }

      if (source_file == NULL)
        source_file = p;

      strcat(link_args, " ");
      strcat(link_args, p);
    }

    copy_file(aof_target, source_file);
    fprintf(dest,
      "rom_link:\n"
      "\t${MKDIR} linked\n\t%s\n"
      "\t@@${CP} linked.${TARGET} ${LINKDIR}.${TARGET} ${CPFLAGS}\n\n",
      link_args);
  }
}


int
build_install_rom_(int generate_script);

int build_bbe(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  char bbe_dir[BUFFER_LEN];
  char aof_target[BUFFER_LEN];
  char rom_link_name[BUFFER_LEN];
  char *end_bbe_dir;
  module_type_t type;
  FILE *makefile;
  FILE *rom_link_file;
  FILE *resources_file;

  build_resources_(1);
  build_install_rom_(1);

  /*
   * now get on with rest
   */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case C:
      case ASM:
      case BAS:
      case KERNEL:
      case DATA:
      case RES:
        printf("\n%s...\n", component->name);
        sprintf(bbe_dir, "%s.%s.BBE.%s.%s", INSTALL_DIR, build_name, SOURCE_DIR, module->path);
        end_bbe_dir = strchr(bbe_dir, '\0');
        _check_dir_v(bbe_dir, "aof", NULL);
        sprintf(aof_target, "%s.%s", build_dir, bbe_dir);
        strcpy(bbe_dir, aof_target);
        end_bbe_dir = strchr(bbe_dir, '\0');
        strcpy(aof_target, bbe_dir);
        strcat(aof_target, ".aof.");
        strcat(aof_target, module->filename?module->filename:component->name);
        strcpy(end_bbe_dir, ".Makefile");
        makefile = fopen(bbe_dir, "w");
        if (makefile != NULL)
        {
          time_t now;
          time(&now);
          fprintf(makefile,
            "# Binary Build Environment Makefile for %s\n"
            "#\n"
            "# Generated at %s"
            "#\n"
            "\n"
            "include Makefiles:StdTools\n"
            "\n"
            "resources: resources-${LOCALE}\n"
            "\t@@echo ${COMPONENT}: resources exported\n"
            "\n"
            "\n",
            component->name,
            ctime(&now));
        }
        strcpy(end_bbe_dir, ".BBE_ROM.rom_link");
        strcpy(rom_link_name, bbe_dir);
        sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
        if (makefile == NULL)
        {
          error(0, "cannot open BBE makefile");
        }
        else if (chdir(buffer))
        {
          error(0, "cannot locate '%s'", buffer);
        }
        else
        {
          /* We have been given a list of territories - iterate down them */
          unsigned int loop, done_uk = 0;
          for (loop=0; loop < num_of_territories && !done_uk; loop++)
          {
            if (strcmp(supported_territories[loop], "UK") == 0) done_uk = 1;
          }
          for (loop=0; loop < num_of_territories; loop++)
          {
            char *locale;
            /* set the Resource$Dir and Locale environment variable to the current */
            if (!done_uk) {
              locale = "UK";
              done_uk = 1;
              --loop;
            }
            else {
              locale = supported_territories[loop];
            }
            setenv("Locale", locale);
            get_amu_machine(); /* Reset amu_machine to include the new values */
            *end_bbe_dir = '\0';

            if (amu_machinef("-k -f Makefiles:BBEExport bbe COMPONENTTYPE=%s %s BBEDIR=%s COMPONENT=%s %s%s",
                  module_type_names[type],
                  component->options ? component->options : "",
                  bbe_dir,
                  component->name,
                  module->filename?"TARGET=":"",
                  module->filename?module->filename:"") != 0)
              error(0, "running make bbe on module '%s'.", component->name);

            /* Now read the locale script */
            strcpy(end_bbe_dir, ".BBE_Res.");
            strcat(end_bbe_dir, locale);
            resources_file = fopen(bbe_dir, "r");
            if (resources_file == NULL)
            {
              error(0, "loading BBE resource phase on module '%s'.", component->name);
            }
            else
            {
              /* Write out the rules for generating this locale's resource export */
              fprintf(makefile, "resources-%s:\n", locale);
              line_by_line_copy(makefile, resources_file);
              fprintf(makefile, "\t@@| End of resource export for locale %s\n\n", locale);
              fclose(resources_file);
            }
          }
        }
        rom_link_file = fopen(rom_link_name, "r");
        if (makefile)
        {
          if (rom_link_file)
d518 7
a524 1
            copy_rom_link_rules(makefile, rom_link_file, aof_target, component->name);
d526 1
a526 8
          fclose(makefile);
          makefile = NULL;
        }
        if (rom_link_file)
        {
          fclose(rom_link_file);
          rom_link_file = NULL;
        }
d639 1
a639 1
build_install_rom_(int generate_script)
a644 2
  char scriptdirname[BUFFER_LEN];
  char scriptfilename[BUFFER_LEN];
a699 10
            if (generate_script)
            {
              sprintf(scriptdirname, "%s.%s.BBE.%s.%s.%s", INSTALL_DIR, build_name, SOURCE_DIR, module->path, "BBE_ROM");
              _check_dir_v(scriptdirname, NULL);
              sprintf(scriptfilename, "-o %s.%s.rom_link ADDRESS=<Address>", build_dir, scriptdirname);
            }
            else
            {
              sprintf(scriptfilename, "ADDRESS=%lu", position_in_rom);
            }
d703 2
a704 3
		if (amu_machinef("rom_link %s LINKDIR=%s %s COMPONENT=%s %s%s",
                        scriptfilename,
			output_path,
a779 6
}

int
build_install_rom(void)
{
  return build_install_rom_(0);
@


1.26.2.2
log
@  Another checkpoint check-in.
Detail:
  This version appears to work as desired but is now being tested.
Admin:
  Undergoing testing.

Version 0.24, 1.23.2.2. Tagged as 'srcbuild-0_24-1_23_2_2'
@
text
@a62 9
static const char corporate_copyright_for_bbe[] = "#"
  "\n# Copyright [2000] Pace Micro Technology PLC.  All rights reserved."
  "\n#"
  "\n# The copyright in this material is owned by Pace Micro Technology PLC"
  "\n# (\"Pace\").  This material is regarded as a highly confidential trade secret"
  "\n# of Pace.  It may not be reproduced, used, sold or in any other way exploited"
  "\n# or transferred to any third party without the prior written permission of"
  "\n# Pace."
  "\n#";
d589 1
a589 1
static void line_by_line_copy(FILE *dest, FILE *source, int with_tab)
d594 1
a594 1
    if (with_tab) fputc('\t', dest);
a662 1
      {
d664 3
a666 6
      }
      else
      {
        strcat(link_args, " ");
        strcat(link_args, p);
      }
a677 39
/* NOTE: Parameter must be pointer to array with enough space to hold locale names
 * tacked on the end of it.
 */
static void copy_locale_resources(FILE *makefile, char *bbe_dir /* see comment above */, const char *name)
{
  FILE *resources_file;
  char *end_bbe_dir = strchr(bbe_dir, '\0');
  char *locale;
  unsigned int loop, done_uk = 0;


  for (loop=0; loop < num_of_territories; loop++)
  {
    /* set the Resource$Dir and Locale environment variable to the current */
    if (!done_uk) {
      locale = "UK";
      done_uk = 1;
      --loop;
    }
    else {
      locale = supported_territories[loop];
      if (strcmp(locale, "UK") == 0) continue;
    }

    /* Now read the locale script */
    strcpy(end_bbe_dir, locale);
    resources_file = fopen(bbe_dir, "r");
    /* Write out the rules for generating this locale's resource export */
    fprintf(makefile, "resources-%s:\n", locale);
    if (resources_file)
    {
      /* Not an error if it doesn't exist - but need the rule in the Makefile anyway */
      line_by_line_copy(makefile, resources_file, 1);
    }
    fprintf(makefile, "\t@@| End of resource export for locale %s\n\n", locale);
    fclose(resources_file);
  }
}

a690 2
  char *end_rom_link_name;
  int  rom_link_line_by_line;
d694 1
a713 1
      case HAL:
a715 1
      case EXP:
d727 20
a746 1
        remove(bbe_dir);
a748 1
        end_rom_link_name = strchr(rom_link_name, '\0');
d750 5
a754 1
        if (chdir(buffer))
d782 1
a782 1
            if (amu_machinef("-k -f Makefiles:BBEExport bbe COMPONENTTYPE=%s %s VERBATIMROMLINK=%s_v BBEDIR=%s COMPONENT=%s %s%s",
a784 1
                  rom_link_name,
d791 16
a808 1
        strcpy(end_rom_link_name, "_v");
a809 63
        if (rom_link_file)
        {
          rom_link_line_by_line = 1;
        }
        else
        {
          *end_rom_link_name = '\0';
          rom_link_file = fopen(rom_link_name, "r");
          rom_link_line_by_line = 0;
        }
        strcpy(end_bbe_dir, ".Makefile");
        makefile = fopen(bbe_dir, "r");
        if (makefile)
        {
          /* The component has exported a Makefile - allow it to override us */
          fclose(makefile);
          makefile = NULL;
        }
        else
        {
          makefile = fopen(bbe_dir, "w");
          if (makefile == NULL)
          {
            error(0, "Unable to create BBE makefile '%s'", bbe_dir);
          }
          else if (type != EXP)
          {
            time_t now;
            time(&now);
            fprintf(makefile,
              "#\n"
              "# Binary Build Environment Makefile for %s\n"
              "#\n"
              "%s\n"
              "#\n"
              "# Automatically generated: last update at %s"
              "#\n"
              "\n"
              "include Makefiles:StdTools\n"
              "\n"
              "all:\n"
              "\t@@| Do nothing by default\n"
              "\n"
              "install_rom:\n"
              "\t${CP} rm.${TARGET} ${INSTDIR}.${TARGET} ${CPFLAGS}\n"
              "\t@@echo ${COMPONENT}: installed\n"
              "\n"
              "# Resource export phases\n"
              "\n"
              "resources: resources-${LOCALE}\n"
              "\t@@echo ${COMPONENT}: resources exported\n"
              "\n"
              "\n",
              component->name,
              corporate_copyright_for_bbe,
              ctime(&now));
          }
          else
          {
            fclose(makefile);
            makefile = NULL;
          }
        }
a811 2
          strcpy(end_bbe_dir, ".BBE_Res.");
          copy_locale_resources(makefile, bbe_dir, component->name);
d814 1
a814 8
            if (rom_link_line_by_line)
            {
                line_by_line_copy(makefile, rom_link_file, 0);
            }
            else
            {
              copy_rom_link_rules(makefile, rom_link_file, aof_target, component->name);
            }
a1003 3
              sprintf(scriptdirname, "%s.%s.BBE.%s.%s.%s", INSTALL_DIR, build_name, SOURCE_DIR, module->path, "rm");
              _check_dir_v(scriptdirname, NULL);
              sprintf(scriptdirname, "%s.%s.%s.BBE.%s.%s.%s", build_dir, INSTALL_DIR, build_name, SOURCE_DIR, module->path, "rm");
d1026 1
a1026 1
		 	generate_script ? scriptdirname : output_path,
@


1.26.2.3
log
@  More BBE changes.
Detail:
  More fixes and improvements.
Admin:
  This is now a release candidate.

Version 0.24, 1.23.2.3. Tagged as 'srcbuild-0_24-1_23_2_3'
@
text
@d770 1
d1031 4
a1039 5
  char buffer[BUFFER_LEN];
  char output_path[BUFFER_LEN];
  char scriptdirname[BUFFER_LEN];
  char scriptfilename[BUFFER_LEN];
  char forcefilename[BUFFER_LEN];
a1044 13
  if (generate_script)
  {
    FILE *f;
    sprintf(forcefilename, "%s.%s.%s.BBE.%s", build_dir, INSTALL_DIR, build_name, "force");
    remove(forcefilename);
    f = fopen(forcefilename, "w");
    if (f) fclose(f);
  }
  else
  {
    *forcefilename = 0;
  }

d1094 1
a1094 2
              sprintf(scriptfilename, "-o %s.%s.rom_link ADDRESS=Address FORCEROMLINK=%s", build_dir, scriptdirname, forcefilename);
              if (module->filename && 0 == strcmp(module->filename, "FTP")) strcat(scriptfilename, " -x");
a1149 5
  if (generate_script)
  {
    remove(forcefilename);
  }

d1512 1
a1512 1
  if (DEBUG)
d1527 1
a1527 1
  if (DEBUG)
@


1.26.2.4
log
@  More BBE changes.
Detail:
  New CLI option: -p outputs a CSV file containing the supported phases
    and their help strings.
  Pluralises territory correctly in output messages.
  Removes BBE_Res and BBE_ROM directories from installed BBE.
Admin:
  Tested in BBE.

Version 0.24, 1.23.2.4. Tagged as 'srcbuild-0_24-1_23_2_4'
@
text
@a72 6
/* Internal function invoked by build_install and build_bbe */
static int build_install_rom_(int generate_script);

/* Internal function invoked by build_resources and build_bbe */
static int build_resources_(int generate_script);

d468 1
a468 1
static int build_resources_(int generate_script)
a597 3


/* Copy lines from 'source' to 'dest', indenting each line with a tab if 'with_tab' is non-zero */
d612 5
a616 4
/* After the BBE phase has invoked the faked rom_link phase, parse the resultant script looking for
 * the line which does the link.  We need to know where the partially linked ROM module is, and which
 * abssym file it wants - then we throw the script away and write the rule cleanly ourselves.
 */
d682 1
a682 1
    copy_objects(aof_target, source_file);
d691 1
a691 5
/*
 * Write the resources phases into the target BBE Makefile.  Each locale is copied in as a
 * separate rule.
 *
 * NOTE: Parameter 'bbe_dir' must be pointer to array with enough space to hold locale names
a692 1
 *
d722 1
a722 3
      /* Not an error if it doesn't exist - but need the rule in the Makefile anyway.
       * Copy file line by line, inserting TABs.
       */
a724 1
    /* Need this line to ensure that there is at least one command for this target */
d730 4
a733 2
/* BBE phase.
 */
a747 8
  /* The following variable is used for debugging only */
  const enum {
    bbe_real,
    bbe_debugging
  } bbe_debug = bbe_real;

  (void) bbe_debugging; /* avoid compiler warning */
  (void) bbe_real; /* avoid compiler warning */
d749 2
a750 6
  if (bbe_debug == bbe_real)
  {
    /* Generate BBE_Res and BBE_ROM contents (debug builds assume this is already there to save time). */
    build_resources_(1);
    build_install_rom_(1);
  }
a917 34
  if (bbe_debug == bbe_real)
  {
    /* Delete the generated BBE_Res and BBE_ROM dirs (debug builds don't to help debugging and save time)
     * NOTE: This must NOT be done as we loop through the components, because some components are used
     * multiple times (e.g. territory modules) for different targets and this could cause problems.
     */

    component = component_database;
    while (component) {
      module = lookup_module(component->name);
      type = component->type;
      if (type == UNDEF)
        type = module->type;

      switch (type) {
        case C:
        case ASM:
        case BAS:
        case KERNEL:
        case HAL:
        case DATA:
        case RES:
          printf("\n%s...\n", component->name);
          sprintf(bbe_dir, "%s.%s.%s.BBE.%s.%s.", build_dir, INSTALL_DIR, build_name, SOURCE_DIR, module->path);
          end_bbe_dir = strchr(bbe_dir, '\0');
          strcpy(end_bbe_dir, "BBE_Res");
          wipe_objects(bbe_dir);
          strcpy(end_bbe_dir, "BBE_ROM");
          wipe_objects(bbe_dir);
      }
      component = component->next;
    }
  }

d1108 1
@


1.25
log
@  Spool opening and closing does nothing if spooling is already on.
  Uncommented a remove call that should not have been commented.
Detail:
  spool_open now calls OS_Byte 199 to find out whether spooling is
    already happening to avoid screwing up any higher level redirection
    that is taking place.  This should enable more meaningful log
    messages to be generated.
Admin:
  Built.

Version 0.23. Tagged as 'srcbuild-0_23'
@
text
@d288 1
d344 1
d396 1
d484 1
d575 1
d636 2
d670 1
d693 7
d739 1
a739 1
	  if (type != KERNEL)	/* add some magic if not kernel */
d764 1
d776 3
d790 1
d792 67
d868 8
a875 1
    if (type == KERNEL) {
d880 10
d899 2
a900 5
  /* write out the image filename */
  fprintf(fh, "%s.%s.%s\n", build_dir, IMAGES_DIR, image_filename);

  /* write out the image size and misc newline */
  fprintf(fh, "%d\n\n", atoi(image_size) * 1024);
d917 1
a917 1
	    fprintf(fh, "%ld\n", component->position - 0x03800000);
d1202 1
@


1.24
log
@  Now works without LocaleList env variable being set.
Detail:
  If the LocaleList system variable is unset, then srcbuild now sets it to
the value contained in the Locale Env var. This is because other parts of the
system (particulalry the Messages makefile) rely on LocaleList being set.
Admin:
  Tested on a Lazarus build without LocaleList beig set.

Version 0.21. Tagged as 'srcbuild-0_21'
@
text
@d958 1
a958 1
//  remove(filename);
@


1.23
log
@	Fixed an 'OflaOfla bug.'
	Resource directory ordering changed.

Detail:
	Fixed a bug where directories called 'oflaofla...' were being created
in the Install directory. Srcbuild iterates through all the components in the
components file, and attempts to create the relevant install directory.
Unfortunatley, many components (e.g. HdrSrc) do not have an install directory
in the ModuleDB. This was causing a string to be printed with a NULL pointer,
causing oflaofla to be created as part of the directory leaf.
	As part of the work to allow multiple territories to be present in
one build, we are altering the resource directories so they are now held in the
following manner:
	Used to be : Messages.Resources.<locale>.<build>
	Is now :     Messages.Resources.<build>.<numeric terriory list>.<locale>
	Where the numeric territory list is a list of all the territories
held in the resources directory, eg. 000106 for Common, UK and France. The
Common directory holds all resources that are common to the other territories
and is generated by the Messages module. Note that if there are three
territories, then there will be four directories held in resources, one for
each territory and one for the Common directory.

Admin:
	Used in some Lazarus builds
	Very much work in progress. Use at your peril. Being checked in early
due to the anticiapted CVS server changes.
	Obbiously when you use this latest version, you will need to run the
resources phase because the formatting has changed.

Version 0.20. Tagged as 'srcbuild-0_20'
@
text
@d532 4
@


1.22
log
@	* Initial support for multiple territories in one build.

Admin:
	For the Bethany project we need to be able to build multiple resource
(territory) sets into one ROM build. The system variable LocaleList is read
and, if set, is parsed for a comma-seperated list of countries. The resources
phase is then called once for each of these countries. If the LocaleList flag
is unset then is should build the territory as set in the Locale in the Env
file.
	If the LocaleList flag is set then after the resources phase has been
run there should be one directory in the Internet.Messages path for each
territory mentioned in the LocaleList.
	To allow this to work the Common and Env files also need altering. If
the Env file does not have a LocaleList then it should have en explicit Unset
LocaleList. The common file also needs to have every *Set that references
<Locale> to be changed to a *SetMacro.

Admin:
	Work in progress for Bethany project. Only partially tested. A binary
checkin will follow after more work and testing.

Version 0.19. Tagged as 'srcbuild-0_19'
@
text
@a189 3
/*   if (verbose) */
/*     printf("Check '%s'.\n",buffer); */

d204 1
a204 2
int
build_dirs(void)
d229 1
a229 1
      char temp_string[255];
d231 3
a233 3
      sprintf (temp_string, "Resources.%s", supported_territories[loop]);
      _check_dir(messages_filename, temp_string);
      sprintf (temp_string, "Resources.%s.<Build>", supported_territories[loop]);
d235 1
a235 1
      sprintf (temp_string, "Resources.%s.<Build>.Resources2", supported_territories[loop]);
d237 1
a237 1
      sprintf (temp_string, "Resources.%s.<Build>.Resources", supported_territories[loop]);
d239 1
a239 1
      sprintf (temp_string, "Resources.%s.<Build>.Apps", supported_territories[loop]);
a242 10
  else
  {
    /* Just do it with the default locale from the envirobment file. */
    _check_dir(messages_filename, "Resources");
    _check_dir(messages_filename, "Resources.<Locale>");
    _check_dir(messages_filename, "Resources.<Locale>.<Build>");
    _check_dir(messages_filename, "Resources.<Locale>.<Build>.Resources");
    _check_dir(messages_filename, "Resources.<Locale>.<Build>.Resources2");
    _check_dir(messages_filename, "Resources.<Locale>.<Build>.Apps");
  }
d245 2
a246 2
  sprintf(buffer, "%s.%s.Resources.<Locale>.<Build>",
	  build_dir, messages_filename);
d251 2
a252 1
  while (component) {
d254 5
a258 3

    sprintf(buffer, "%s.%s", build_name, module->output);
    _check_dir(INSTALL_DIR, buffer);
d264 4
a267 2
int
build_clean(void)
d317 5
a321 2
int
build_export_hdrs(void)
d370 3
a372 2
int
build_export_libs(void)
d421 4
a424 2
int
build_resources(void)
d430 7
d445 2
d449 6
a454 2
  else if (amu_machinef("-k clean COMPONENT=Messages TARGET=Messages" ) != 0)
    error(0, "running make clean on module 'Messages'.");
d456 8
d497 1
a497 1
              /* set the Resource$Dir and Locale environment variable */
d500 1
a500 1
              sprintf(buffer, "%s.%s.Resources.<Locale>.<Build>", build_dir, messages_filename);
d526 7
d536 3
a538 2
int
build_rom(void)
@


1.21
log
@	Each component can now havw a -nosources flag.

Detail:
 	There is a requirement for a customer to get a binary-only build
where they can change resources and do their own builds. To allow this we
will be providing them with a prebuilt disc image for the project with almost
all the sources deleted.
	To allow them to build images, have added the functionality to
SrcBuild whereby adding a -nosources flag to a component in the components
file causes clean, export_hdrs, export_libs and rom phases to have no effect.
This allows the client to build with resources, install_rom and join phases
and thus get an image with any changed resources in.
 	This change should only affect components that have a -nsources flag
in the component file.

Admin:
	Tested in a Lazarus build.

Version 0.18. Tagged as 'srcbuild-0_18'
@
text
@d59 1
d228 29
a256 6
  _check_dir(messages_filename, "Resources");
  _check_dir(messages_filename, "Resources.<Locale>");
  _check_dir(messages_filename, "Resources.<Locale>.<Build>");
  _check_dir(messages_filename, "Resources.<Locale>.<Build>.Resources");
  _check_dir(messages_filename, "Resources.<Locale>.<Build>.Resources2");
  _check_dir(messages_filename, "Resources.<Locale>.<Build>.Apps");
d443 1
a443 1
  else if (amu_machinef("-k clean COMPONENT=Messages TARGET=Messages") != 0)
d468 1
d470 35
a504 6
	else if (amu_machinef("-k resources %s RESDIR=<Resource$Dir>.Resources COMPONENT=%s %s%s",
		component->options ? component->options : "",
		component->name,
		module->filename?"TARGET=":"",
		module->filename?module->filename:"") != 0)
	  error(0, "running make resources on module '%s'.", component->name);
a533 1

d590 1
a590 1
      printf("\n%s...\nComponent %s: norom flag passed in, therefore not running ROM phase on this component.\n", component->name, component->name);
d736 1
a736 2
static int
joiner_format_bigsplit(FILE * fh)
d802 1
a802 2
static int
joiner_format_makeexprom(FILE * fh)
d957 2
a958 6
/*
 * Function to initialise the build system, currently only extracts the value of
 * Alias$amu_machine and stores it internally in the correct form for use in
 * amu_machinef() */
void
build_init(void)
d961 2
d964 1
d966 2
d970 6
d979 23
@


1.20
log
@	Allowed APCS export directories to be created.

Detail:
	As part of the 32-bit OS work, if the APCS system variable is set
then srcbuild creates the export directories in Export.<APCS>, not Export.
This is part of the work-in-progress of the 32-bit support.

Admin:
	Tested in a Lazarus Omega build.

Version 0.17. Tagged as 'srcbuild-0_17'
@
text
@d266 28
a293 21
    switch (type) {
      case ASM:
      case C:
      case BAS:
      case KERNEL:
      case EXP:
      case DATA:
	printf("\n%s...\n", component->name);
	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	if (chdir(buffer))
	  error(0, "cannot locate '%s'", buffer);
	else if (amu_machinef("-k clean %s COMPONENT=%s %s%s",
		component->options ? component->options:"",
		component->name,
		module->filename?"TARGET=":"",
		module->filename?module->filename:"") != 0)
	  error(0, "running make clean on module '%s'.", component->name);
	/*
	 * no need for force clean now
	 */
	component->force_clean = FALSE;
d295 1
d317 28
a344 20
    switch (type) {
      case ASM:
      case C:
      case BAS:
      case KERNEL:
      case DATA:
      case EXP:
	printf("\n%s...\n", component->name);
	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	if (chdir(buffer))
	  error(0, "cannot locate '%s'", buffer);
	else if (amu_machinef("-k export %s PHASE=hdrs COMPONENT=%s %s%s",
		component->options ? component->options:"",
		component->name,
		module->filename?"TARGET=":"",
		module->filename?module->filename:"") != 0) {
	  error(0, "running make export (hdrs) on module '%s'.",
		component->name);
	}
	break;
d367 28
a394 20
    switch (type) {
      case ASM:
      case C:
      case BAS:
      case KERNEL:
      case DATA:
      case EXP:
	printf("\n%s...\n", component->name);
	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	if (chdir(buffer))
	  error(0, "cannot locate '%s'", buffer);
	else if (amu_machinef("-k export %s PHASE=libs COMPONENT=%s %s%s",
		component->options ? component->options:"",
		component->name,
		module->filename?"TARGET=":"",
		module->filename?module->filename:"")  != 0) {
	  error(0, "running make export (libs) on module '%s'.",
		component->name);
	}
	break;
d481 57
a537 50
    switch (type) {
      case C:
      case ASM:
      case BAS:
      case KERNEL:
      case DATA:
	printf("\n%s...\n", component->name);
	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	if (chdir(buffer))
	  error(0, "cannot locate '%s'", buffer);
	else {
	  /*
	   * do we want to force a clean build due to changes
	   */
	  if (component->force_clean) {
	    printf("Forcing a clean build due to switch/option changes...\n");
	    if (amu_machinef("-k clean %s COMPONENT=%s %s%s",
		component->options ? component->options : "",
		component->name,
		module->filename?"TARGET=":"",
		module->filename?module->filename:"") != 0)
	      error(0, "running make clean on module '%s'.", component->name);
	  }
	  /*
	   * find out what we are switching this module on
	   */
	  switch_on = NULL;
	  if (component->switch_on)
	    switch_on = component->switch_on;
	  else if (module->switch_on)
	    switch_on = module->switch_on;

	  if (component->options || switch_on) {
	    fprintf(fh_shadow, "%s ", component->name);
	    if (switch_on) {
	      fprintf(fh_shadow, "-switch %s ", switch_on);
	    }
	    if (component->options) {
	      fprintf(fh_shadow, "-options %s", component->options);
	    }
	    fprintf(fh_shadow, "\n");
	  }

	  if (amu_machinef("-k rom %s COMPONENT=%s %s%s",
		component->options ? component->options : "",
		component->name,
		module->filename?"TARGET=":"",
		module->filename?module->filename:"") != 0)
	    error(0, "running make rom on module '%s'.", component->name);
	}
@


1.19
log
@	Changed handling of amu_machine in srcbuild.

Details:
	Changed way in which srcbuild uses amu_machine to get around RISC OS
3.7 limitions on command line length.  Now expands amu_machine alias
internally, which means that long command lines in builds will now work
correcltly.

	Tidied build system to create and clean up its "o" folder correctly,
and to clean it's dynamic dependencies.

Admin:
	Tested on several Lazarus builds. Committed on behalf of JBeranek

Version 0.16. Tagged as 'srcbuild-0_16'
@
text
@d212 2
d221 5
a225 4
  _check_dir(NULL, "Export.Hdr");
  _check_dir(NULL, "Export.Hdr.Global");
  _check_dir(NULL, "Export.Hdr.Interface");
  _check_dir(NULL, "Export.Hdr.Interface2");
@


1.18
log
@Summary
  *  Added support for install: targets
  *  Added support for podule ROM builds.

Detail
  *  Added support to pass 'install' as a valid parameter.  This allows
     disc builds and podule rom builds to be completed.
  *  Added knowledge of MakeExpROM as a valid joiner app.
Admin
  *  Tested install: work using a dummy Baseline 3 build.
  *  Tested MakeExpROM work using RiscOS/BuildSys/EtherI16E as a basis.
     srcbuild produces an indentical ROM to the old-style build system for
     populated roms and roms only containing podule ID information.

Version 0.15. Tagged as 'srcbuild-0_15'
@
text
@d24 2
d30 6
d56 71
d130 1
a130 1
 * perform a system call with printf style parameter passing
d132 2
a133 2
int
systemf(char *format, ...)
d135 1
d138 1
d140 20
a159 5
  va_start (list, format);
  vsprintf(buffer,format, list);
  va_end(list);
  if (verbose) {
    printf("%s\n",buffer);
d161 8
a168 1
  return (system(buffer));
d171 1
d274 1
a274 1
	else if (systemf("amu_machine -k clean %s COMPONENT=%s %s%s",
d317 1
a317 1
	else if (systemf("amu_machine -k export %s PHASE=hdrs COMPONENT=%s %s%s",
d359 1
a359 1
	else if (systemf("amu_machine -k export %s PHASE=libs COMPONENT=%s %s%s",
d392 1
a392 1
  else if (system("amu_machine -k clean COMPONENT=Messages TARGET=Messages") != 0)
d418 1
a418 1
	else if (systemf("amu_machine -k resources %s RESDIR=<Resource$Dir>.Resources COMPONENT=%s %s%s",
d470 1
a470 1
	    if (systemf("amu_machine -k clean %s COMPONENT=%s %s%s",
d497 1
a497 1
	  if (systemf("amu_machine -k rom %s COMPONENT=%s %s%s",
d571 1
a571 1
		if (systemf("amu_machine rom_link ADDRESS=%lu LINKDIR=%s %s COMPONENT=%s %s%s",
d583 1
a583 1
		if (systemf("amu_machine install_rom INSTDIR=%s %s COMPONENT=%s %s%s",
d872 17
d967 1
a967 1
	    if (systemf("amu_machine -k clean %s COMPONENT=%s",
d1024 1
a1024 1
	  if (systemf("amu_machine -k install %s COMPONENT=%s %s%s INSTDIR=%s",
@


1.17
log
@Introduced the idea of a "DATA" module.

Version 0.13. Tagged as 'srcbuild-0_13'
@
text
@d48 1
d337 3
d609 85
d710 2
d731 4
d739 1
a739 1
  remove(filename);
d765 153
@


1.16
log
@Adjusted clean of Messages module to cope with its new multiple component
wackyness.

Version 0.12. Tagged as 'srcbuild-0_12'
@
text
@d164 1
d206 1
d248 1
d307 1
d351 1
d438 1
d447 1
a447 1
	    if (position_forced && !component->force_position) {
d450 3
a452 1
	    else if (component->force_position) {
d524 1
d589 1
d591 2
a592 2
	  if (component->force_position)
	    fprintf(fh, "%d\n", component->force_position - 0x03800000);
@


1.15
log
@Export modules are cleaned.  Options passed down during clean phase.

Version 0.10. Tagged as 'srcbuild-0_10'
@
text
@a272 1
  char *messages_leafname;
d276 3
a278 3
   * Force a make clean on the messages module.
   * Assumes that the leafname of the messages location is
   * the same as the component name of the messages.
d280 7
a286 22
  messages_leafname = strrchr (messages_filename, '.');
  if (messages_leafname)
  {
    ++messages_leafname;    /* point to <leafname>, not .<leafname> */
    component = component_database;
    while (component) {
      if (cstrcmp(component->name, messages_leafname) == 0) {
        module = lookup_module(component->name);
        printf("\nCleaning %s...\n", component->name);
        sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
        if (chdir(buffer))
	error(0, "cannot locate '%s'", buffer);
      else if (systemf("amu_machine -k clean %s COMPONENT=%s %s%s",
		component->options ? component->options:"",
		component->name,
		module->filename?"TARGET=":"",
		module->filename?module->filename:"") != 0)
	error(0, "running make clean on module '%s'.", component->name);
      }
      component = component->next;
    }
  }
@


1.14
log
@Summary
    Committing a couple of changes made long ago for Daytona but forgotten
    about:
      * Name of Messages module no longer hardwired.  Assumes Messages module
        is same name as leaf of Messages tag is the build's components file.
      * New 'BaseAddress' tag for components file allows base address of image
        to be specified e.g. for Daytona appflash.
Admin
    Sources compiled.
    A version merged with recent sources (version 0.07) has been tested in a
    couple of ROM builds.

Version 0.09. Tagged as 'srcbuild-0_09'
@
text
@d163 1
d373 2
a374 1
	    if (systemf("amu_machine -k clean COMPONENT=%s %s%s",
@


1.13
log
@Added "-address <n>" option to place a component at a fixed address (for
nefarious purposes - it won't be linked into the module chain, so only useful
for some sort of embedded data).

Version 0.08. Tagged as 'srcbuild-0_08'
@
text
@d44 1
d272 1
d276 3
a278 1
   * Force a make clean on the messages module
d280 11
a290 7
  component = component_database;
  while (component) {
    if (cstrcmp(component->name, "Messages") == 0) {
      module = lookup_module(component->name);
      printf("\nCleaning %s...\n", component->name);
      sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
      if (chdir(buffer))
d298 2
a300 1
    component = component->next;
d423 1
a423 1
  int position_in_rom = 0x03800000;
d428 4
d469 1
a469 1
		if (systemf("amu_machine rom_link ADDRESS=%d LINKDIR=%s %s COMPONENT=%s %s%s",
d504 1
a504 1
	  position_in_rom += ((size + 3) & ~3);
d532 1
a532 1
	  printf("%-25s  %08X         %08X\n", component->name,
@


1.12
log
@Summary
    Allow ROM build option flags to be passed to all phases
Detail
    Phases clean, export hdrs, export libs now have component options
    passed down.
Admin
    Sources compiled, functionality tested on a build tree.

Version 0.07. Tagged as 'srcbuild-0_07'
@
text
@d48 1
a48 1
/* 
d66 1
a66 1
/* 
d97 1
a97 1
/* 
d172 1
a172 1
	/* 
d273 1
a273 1
  /* 
d295 1
a295 1
  /* 
d358 1
a358 1
	  /* 
d369 1
a369 1
	  /* 
d417 1
d442 11
d530 1
a530 1
/* 
d581 3
a583 1
	if (module->filename != NULL)
d586 1
a586 1

d640 1
a640 1
/* 
@


1.11
log
@Now passes options down to makefile during resources phase.

Version 0.06. Tagged as 'srcbuild-0_06'
@
text
@d166 2
a167 1
	else if (systemf("amu_machine -k clean COMPONENT=%s %s%s",
d208 2
a209 1
	else if (systemf("amu_machine -k export PHASE=hdrs COMPONENT=%s %s%s",
d249 2
a250 1
	else if (systemf("amu_machine -k export PHASE=libs COMPONENT=%s %s%s",
d284 2
a285 1
      else if (systemf("amu_machine -k clean COMPONENT=%s %s%s",
@


1.10
log
@Addition of makefile variables COMPONENT and TARGET (if it exists) for all
amu calls. Enable verbose output if you want to actually see the command
line that is contructed and executed.

Version 0.05. Tagged as 'srcbuild-0_05'
@
text
@d311 2
a312 1
	else if (systemf("amu_machine -k resources RESDIR=<Resource$Dir>.Resources COMPONENT=%s %s%s",
@


1.9
log
@Allow multiple words for the -options field.
Support the new flags for BigSplit2 for ROM signature.

Version 0.04. Tagged as 'srcbuild-0_04'
@
text
@d25 1
d48 17
d166 4
a169 1
	else if (system("amu_machine -k clean") != 0)
d207 4
a210 1
	else if (system("amu_machine -k export PHASE=hdrs") != 0) {
d247 4
a250 1
	else if (system("amu_machine -k export PHASE=libs") != 0) {
d281 4
a284 1
      else if (system("amu_machine -k clean") != 0)
d311 4
a314 1
	else if (system("amu_machine -k resources RESDIR=<Resource$Dir>.Resources") != 0)
d358 4
a361 1
	    if (system("amu_machine -k clean") != 0)
a382 2
	  sprintf(buffer, "amu_machine -k rom %s",
		  component->options ? component->options : "");
d384 5
a388 1
	  if (system(buffer) != 0)
d439 1
a439 1
		sprintf(buffer, "amu_machine rom_link ADDRESS=%d LINKDIR=%s %s",
d441 4
a444 3
			component->options ? component->options : "");

		if (system(buffer) != 0)
d451 6
a456 4
		sprintf(buffer, "amu_machine install_rom INSTDIR=%s %s",
		 output_path, component->options ? component->options : "");

		if (system(buffer) != 0)
d600 1
a600 1
    sprintf(buffer, "%s %s", joiner, filename);
@


1.8
log
@Modified sources to use VersionNum scheme.

Version 0.03. Tagged as 'srcbuild-0_03'
@
text
@d41 4
a44 2
extern int  verbose;
extern module_entry_t    *module_database;
d56 6
a61 7
  
  strcpy(buffer,build_dir);
  strcat(buffer,".");
  if (prefix)
  {
    strcat(buffer,prefix);
    strcat(buffer,".");
d63 2
a64 2
  strcat(buffer,filename);
  
d67 5
a71 6
    
  switch (file_exists(buffer))
  {
    case 0 :
      if (mkdir(buffer,0)==-1)
        error(1,"creating directory '%s'.",buffer);
d73 4
a76 4
    case 1 :
      error(1,"found file %s when it should be a directory.",buffer);
  }  
  return 0;  
d86 1
a86 1
  module_entry_t    *module;
d89 11
a99 11
  _check_dir(NULL,		IMAGES_DIR);
  _check_dir(NULL,		INSTALL_DIR);
  _check_dir(INSTALL_DIR,	build_name);
  _check_dir(BUILDSYS_DIR,	SHADOW_DIR);
  _check_dir(BUILDSYS_DIR,	LOGS_DIR);
  _check_dir(NULL,   		"Export");
  _check_dir(NULL,   		"Export.Hdr");
  _check_dir(NULL,   		"Export.Hdr.Global");
  _check_dir(NULL,   		"Export.Hdr.Interface");
  _check_dir(NULL,   		"Export.Hdr.Interface2");
  _check_dir(NULL,   		"Export.Lib");
d108 12
a119 13
  sprintf(buffer,"%s.%s.Resources.<Locale>.<Build>",
  	build_dir,messages_filename);
  setenv("Resource$Dir",buffer);

  _check_dir(NULL,        	INSTALL_DIR);
  component = component_database;
  while (component)
  {
    module = lookup_module(component->name);
    
    sprintf(buffer,"%s.%s",build_name,module->output);
    _check_dir(INSTALL_DIR,buffer);
    component=component->next;
d128 1
a128 1
  module_entry_t    *module;
d131 1
a131 1
  
d133 1
a133 2
  while (component)
  {
d138 16
a153 15
      
    switch (type)
    {
      case ASM : case C : case BAS : case KERNEL :
        printf("\n%s...\n",component->name);
        sprintf(buffer,"%s.%s.%s",build_dir,SOURCE_DIR,module->path);
        if (chdir(buffer))
          error(0,"cannot locate '%s'",buffer);
        else
          if (system("amu_machine -k clean")!=0)
            error(0,"running make clean on module '%s'.",component->name);
        /* 
         * no need for force clean now
         */
        component->force_clean = FALSE;
d155 1
a155 1
    component=component->next;
d165 1
a165 1
  module_entry_t    *module;
d170 1
a170 2
  while (component)
  {
d175 16
a190 15
      
    switch (type)
    {
      case ASM : case C : case BAS : case KERNEL : case EXP :
        printf("\n%s...\n",component->name);
        sprintf(buffer,"%s.%s.%s",build_dir,SOURCE_DIR,module->path);
        if (chdir(buffer))
          error(0,"cannot locate '%s'",buffer);
        else
          if (system("amu_machine -k export PHASE=hdrs")!=0)
          {
            error(0,"running make export (hdrs) on module '%s'.",
            	component->name);
          }
        break;
d192 1
a192 1
    component=component->next;
d202 1
a202 1
  module_entry_t    *module;
d207 1
a207 2
  while (component)
  {
d212 16
a227 15
      
    switch (type)
    {
      case ASM : case C : case BAS : case KERNEL : case EXP :
        printf("\n%s...\n",component->name);
        sprintf(buffer,"%s.%s.%s",build_dir,SOURCE_DIR,module->path);
        if (chdir(buffer))
          error(0,"cannot locate '%s'",buffer);
        else
          if (system("amu_machine -k export PHASE=libs")!=0)
          {
            error(0,"running make export (libs) on module '%s'.",
            	component->name);
          }
        break;
d229 1
a229 1
    component=component->next;
d239 1
a239 1
  module_entry_t    *module;
d247 2
a248 4
  while (component)
  {
    if (cstrcmp(component->name,"Messages")==0)
    {
d250 2
a251 2
      printf("\nCleaning %s...\n",component->name);
      sprintf(buffer,"%s.%s.%s",build_dir,SOURCE_DIR,module->path);
d253 3
a255 4
        error(0,"cannot locate '%s'",buffer);
      else
        if (system("amu_machine -k clean")!=0)
          error(0,"running make clean on module '%s'.",component->name);
d257 1
a257 1
    component=component->next;
d265 1
a265 2
  while (component)
  {
d270 13
a282 11
      
    switch (type)
    {
      case C : case ASM : case BAS :  case KERNEL : case RES :
        printf("\n%s...\n",component->name);
        sprintf(buffer,"%s.%s.%s",build_dir,SOURCE_DIR,module->path);
        if (chdir(buffer))
          error(0,"cannot locate '%s'",buffer);
        else
          if (system("amu_machine -k resources RESDIR=<Resource$Dir>.Resources")!=0)
            error(0,"running make resources on module '%s'.",component->name);
d284 2
a285 2
    component=component->next;
  }  
d293 1
a293 1
  module_entry_t    *module;
d295 2
a296 2
  FILE *fh_shadow=NULL;
  char *switch_on=NULL;
d299 4
a302 4
  sprintf(buffer,"%s.%s.%s.%s",build_dir,BUILDSYS_DIR,SHADOW_DIR,build_name);
  if ((fh_shadow=fopen(buffer,"w"))==NULL)
    error(1,"cannot open shadow file '%s'.",buffer);
    
d304 1
a304 2
  while (component)
  {
d309 44
a352 42
      
    switch (type)
    {
      case C : case ASM : case BAS :  case KERNEL :
        printf("\n%s...\n",component->name);
        sprintf(buffer,"%s.%s.%s",build_dir,SOURCE_DIR,module->path);
        if (chdir(buffer))
          error(0,"cannot locate '%s'",buffer);
        else
        {
          /* 
           * do we want to force a clean build due to changes
           */
          if (component->force_clean)
          {
            printf("Forcing a clean build due to switch/option changes...\n");
            if (system("amu_machine -k clean")!=0)
              error(0,"running make clean on module '%s'.",component->name);
          }
          
          /* 
           * find out what we are switching this module on
           */
          switch_on=NULL;
          if (component->switch_on)
            switch_on = component->switch_on;
          else if (module->switch_on)
            switch_on = module->switch_on;
          
          if (component->options || switch_on)
          {
            fprintf(fh_shadow,"%s %s %s\n",component->name,
          		component->options?component->options:"-",
          		switch_on?switch_on:"-");
          }
          
          sprintf(buffer,"amu_machine -k rom %s",
          	component->options?component->options:"");
          	
          if (system(buffer)!=0)
            error(0,"running make rom on module '%s'.",component->name);
        }
d354 1
a354 1
    component=component->next;
d367 1
a367 1
  module_entry_t    *module;
d374 1
a374 1
  
d376 1
a376 2
  while (component)
  {
d381 60
a440 63
    
    sprintf(output_path,"%s.%s.%s.%s",build_dir,
        INSTALL_DIR,build_name,module->output);
    
    switch (type)
    {
      case C : case ASM : case BAS : case KERNEL :
        printf("\n%s...\n",component->name);
        if (module->filename==NULL)
        {
          printf("No output file for this component\n");
        }
        else
        {
          sprintf(buffer,"%s.%s.%s",build_dir,SOURCE_DIR,module->path);      
          if (chdir(buffer))
            error(0,"cannot locate '%s'",buffer);
          else
          {
            switch (type)
            {
              case C :
                /* if module is C, link things correctly */
                sprintf(buffer,"amu_machine rom_link ADDRESS=%d LINKDIR=%s %s",
                  position_in_rom,output_path,
                  component->options?component->options:"");
                  
                if (system(buffer)!=0)
                  error(1,"running make rom_link on module '%s'.",
                    component->name); 
                    
                break;
                
              default :
                sprintf(buffer,"amu_machine install_rom INSTDIR=%s %s",
            	output_path,component->options?component->options:"");

                if (system(buffer)!=0)
                  error(1,"running make install_rom on module '%s'.",
              	  component->name); 
              	  
                break;
            }
          }
          /* Need to stat the module file, display position in ROM */
          sprintf(buffer,"%s.%s",output_path,module->filename);
          
          if ((size=file_size(buffer))==-1)
            error(1,"cannot stat file '%s'.",buffer);
  
    	  /* keep record of things for later */
  	  component->position = position_in_rom;
  	  component->size     = size;        	

  	  /* calculate position of next module in ROM */
          position_in_rom += ((size+3) & ~3);
          if (type!=KERNEL)		/* add some magic if not kernel */
            position_in_rom += 4;
        }
    }
    component=component->next;
  }  
  
d447 2
a448 3
  number_of_modules=0;
  while (component)
  {
d453 16
a468 15
      
    switch (type)
    {
      case ASM : case C : case BAS : case KERNEL :
        if (module->filename!=NULL)
        {
          number_of_modules++;
          printf("%-25s  %08X         %08X\n",component->name,
    	    component->position,component->size);
    	}
    	break;
    }
    component=component->next;
  }  
  printf("\nTotal of %d modules.\n",number_of_modules);
d476 1
a476 1
joiner_format_bigsplit(FILE *fh)
d479 1
a479 1
  module_entry_t    *module;
d481 2
a482 2
  int kernel_count=0;
  
d485 1
a485 2
  while (component)
  {
d490 4
a493 5
      
    if (type == KERNEL)
    {
      fprintf(fh,"%s.%s.%s.%s.%s\n",build_dir,
        INSTALL_DIR,build_name,module->output,module->filename);
d496 1
a496 1
    component=component->next;
d498 1
a498 1
  
d500 5
a504 5
  if (kernel_count>1)
    error(0,"you appear to have more than one kernel in this ROM");
  else if (kernel_count<1)
    error(0,"you seem to be missing a kernel in this ROM");
  
d506 2
a507 2
  fprintf(fh,"%s.%s.%s\n",build_dir,IMAGES_DIR,image_filename);
  
d509 1
a509 1
  fprintf(fh,"%d\n\n",atoi(image_size)*1024);
d513 1
a513 2
  while (component)
  {
d518 10
a527 9
      
    switch (type)
    {
      case ASM : case C : case BAS :
        if (module->filename!=NULL)
          fprintf(fh,"%s.%s.%s.%s.%s\n",build_dir,
            INSTALL_DIR,build_name,module->output,module->filename);
        
        break;
d529 1
a529 1
    component=component->next;
d531 2
a532 2
  fprintf(fh,"\n");
  
d541 2
a542 2
  FILE *fh=NULL;
  
d544 4
a547 1
  strcpy(filename,tmpnam(NULL));
a548 3
  if ((fh=fopen(filename,"w"))==NULL)
    error(1,"cannot open temp file '%s'.",filename);
  
d550 1
a550 1
  if (cstrcmp(joiner_format,"BigSplit")==0) 
d553 1
a553 1
    error(1,"Unknown joiner file format '%s'",joiner_format);
d556 15
a570 1
    
d572 3
a574 4
  sprintf(buffer,"%s %s",joiner,filename);
  if (system(buffer)!=0)
    error(1,"running joiner '%s' with file '%s'.",joiner,filename);
  
d576 1
a576 1
  
d587 1
a587 1
  module_entry_t    *module;
d589 1
a589 1
  
d591 1
a591 2
  while (component)
  {
d596 4
a599 4
    
    printf("%-25s %-10s %s\n",component->name,module_type_names[(int)type],
      component->options?component->options:"");
    component=component->next;
@


1.7
log
@When doing a make resources phase, clean the messages module first.
@
text
@d407 3
a409 2
                sprintf(buffer,"amu_machine rom_link ADDRESS=%d LINKDIR=%s",
                  position_in_rom,output_path);
d418 2
a419 2
                sprintf(buffer,"amu_machine install_rom INSTDIR=%s",
            	output_path);
d593 2
a594 1
    printf("%-25s %s\n",component->name,module_type_names[(int)type]);
@


1.6
log
@Changed behaviour for modules not found in the shadow file. Force clean is
only performed for modules with switch or options set and it is only these
modules which are logged in the shadow file.
@
text
@d244 24
d351 1
d409 1
a409 1
  
d419 1
a419 1
            	
@


1.5
log
@Was calculating the position in ROM slightly wrong. For modules other than
the kernel, you should add 4 bytes to position after word aligning the file
size. Now correctly builds main ROMs, tested with Acorn Generic.
@
text
@d318 3
a320 1
          fprintf(fh_shadow,"%s %s %s\n",component->name,
d323 1
@


1.4
log
@Misc changes following testing, mainly along the lines of getting the same
sequence of events happening under srcbuild as with existing system.
Built a ROM which didn't work :-(.
@
text
@d408 1
a408 1
          
d410 3
a412 1
          position_in_rom += (size+3) & ~3;
@


1.3
log
@Completed functionality, committed to repository prior to extensive
testing.
@
text
@d107 5
d178 1
a178 1
    if (type == EXP)
d180 12
a191 7
      printf("\n%s...\n",component->name);
      sprintf(buffer,"%s.%s.%s",build_dir,SOURCE_DIR,module->path);
      if (chdir(buffer))
        error(0,"cannot locate '%s'",buffer);
      else
        if (system("amu_machine -k export PHASE=hdrs")!=0)
          error(0,"running make export (hdrs) on module '%s'.",component->name);
d215 1
a215 1
    if (type == EXP)
d217 12
a228 7
      printf("\n%s...\n",component->name);
      sprintf(buffer,"%s.%s.%s",build_dir,SOURCE_DIR,module->path);
      if (chdir(buffer))
        error(0,"cannot locate '%s'",buffer);
      else
        if (system("amu_machine -k export PHASE=libs")!=0)
          error(0,"running make export (libs) on module '%s'.",component->name);
d254 1
a254 1
      case C : case ASM : case BAS :  case KERNEL :/* do we really need BAS ? */
d260 1
a260 1
          if (system("amu_machine -k resources")!=0)
d347 1
a359 2
    printf("\n%s...\n",component->name);
    
d363 5
a367 4
      
        sprintf(buffer,"%s.%s.%s",build_dir,SOURCE_DIR,module->path);      
        if (chdir(buffer))
          error(0,"cannot locate '%s'",buffer);
d370 4
a373 1
          switch (type)
d375 23
a397 20
            case C :
              /* if module is C, link things correctly */
              sprintf(buffer,"amu_machine rom_link ADDRESS=%d LINKDIR=%s",
                position_in_rom,output_path);

              if (system(buffer)!=0)
                error(1,"running make rom_link on module '%s'.",
                  component->name); 
                  
              break;
              
            default :
              sprintf(buffer,"amu_machine install_rom INSTDIR=%s",
          	output_path);
          	
              if (system(buffer)!=0)
                error(1,"running make install_rom on module '%s'.",
            	  component->name); 
            	  
              break;
d399 12
a411 12
        /* Need to stat the module file, display position in ROM */
        sprintf(buffer,"%s.%s",output_path,module->filename);
        
        if ((size=file_size(buffer))==-1)
          error(1,"cannot stat file '%s'.",buffer);

	/* keep record of things for later */
	component->position = position_in_rom;
	component->size     = size;        	
        
	/* calculate position of next module in ROM */
        position_in_rom += (size+3) & ~3;
d422 1
d425 16
a440 2
    printf("%-25s  %08X         %08X\n",component->name,
    	component->position,component->size);
d443 1
a443 1
  
d500 3
a502 2
        fprintf(fh,"%s.%s.%s.%s.%s\n",build_dir,
          INSTALL_DIR,build_name,module->output,module->filename);
@


1.2
log
@Added my latest sources prior to going on holiday.
@
text
@d28 1
a33 1
extern char *source_dir;
d39 2
d47 2
a48 1
 * check for existance of a directory before creating it
d55 2
a56 1
  strcpy(buffer,"");
d64 2
a65 2
  if (verbose)
    printf("Checking directory '%s'.\n",buffer);
d85 32
a116 15
  _check_dir(NULL,        	"<Install$Dir>");
  _check_dir(build_dir,		SHADOW_DIR);
  _check_dir(build_dir,		LOGS_DIR);
  _check_dir(build_dir,   	"Export");
  _check_dir(build_dir,   	"Export.Hdr");
  _check_dir(build_dir,   	"Export.Hdr.Global");
  _check_dir(build_dir,   	"Export.Hdr.Interface");
  _check_dir(build_dir,   	"Export.Hdr.Interface2");
  _check_dir(build_dir,   	"Export.Lib");
  _check_dir(messages_filename,"Resources");
  _check_dir(messages_filename,"Resources.<Locale>");
  _check_dir(messages_filename,"Resources.<Locale>.<Build>");
  _check_dir(messages_filename,"Resources.<Locale>.<Build>.Resources");
  _check_dir(messages_filename,"Resources.<Locale>.<Build>.Resources2");
  _check_dir(messages_filename,"Resources.<Locale>.<Build>.Apps");
d138 1
a138 1
      case ASM : case C : case BAS :
d140 1
a140 1
        sprintf(buffer,"%s.%s",source_dir,module->path);
d144 1
a144 1
          if (system("amu -k clean")!=0)
d176 1
a176 1
      sprintf(buffer,"%s.%s",source_dir,module->path);
d180 1
a180 1
        if (system("amu -k export PHASE=hdrs")!=0)
d208 1
a208 1
      sprintf(buffer,"%s.%s",source_dir,module->path);
d212 1
a212 1
        if (system("amu -k export PHASE=libs")!=0)
d239 1
a239 1
      case C : case ASM : case BAS :	/* do we really need BAS ? */
d241 1
a241 1
        sprintf(buffer,"%s.%s",source_dir,module->path);
d245 1
a245 1
          if (system("amu -k resources")!=0)
d263 1
a263 1
  sprintf(buffer,"%s.%s.%s",build_dir,SHADOW_DIR,build_name);
d277 1
a277 1
      case C : case ASM : case BAS :	/* do we really need BAS ? */
d279 1
a279 1
        sprintf(buffer,"%s.%s",source_dir,module->path);
d290 1
a290 1
            if (system("amu clean")!=0)
d304 2
a305 2
          		component->options?component->options:"",
          		switch_on?switch_on:"");
d307 2
a308 1
          sprintf(buffer,"amu rom %s",component->options?component->options:"");
d328 1
d330 3
a332 1

d340 6
a345 1
      
d348 3
a350 3
      case C : case ASM : case BAS :	/* do we really need BAS ? */
        printf("\n%s...\n",component->name);
        sprintf(buffer,"%s.%s",source_dir,module->path);
d355 23
a377 4
          sprintf(buffer,"amu -k install_rom INSTDIR=<Install$Dir>.%s",
          	build_name);
          if (system(buffer)!=0)
            error(0,"running make install_rom on module '%s'.",component->name);
d379 12
d394 134
@


1.1
log
@Initial revision
@
text
@d59 4
a62 1

d66 2
a67 1
      mkdir(buffer,0);
d78 2
a79 2
static int
_create_dirs(void)
d82 2
a89 1
  _check_dir(build_dir,	SHADOW_DIR);
a207 1
  _create_dirs();
a241 2
  _create_dirs();
  
a307 1
  _create_dirs();
d324 4
a327 1
          if (system("amu -k install_rom")!=0)
d329 1
@


1.1.1.1
log
@First added for safe keeping.
@
text
@@

head	4.13;
access;
symbols
	Freeway-0_41:4.13
	Freeway-0_40:4.12
	Freeway-0_39:4.12
	Freeway-0_38:4.11
	Freeway-0_37:4.10
	Freeway-0_36:4.9
	Freeway-0_35:4.8
	RO_5_07:4.8
	Freeway-0_34:4.8
	Freeway-0_33:4.7
	Freeway-0_32:4.6
	Freeway-0_31:4.5
	Freeway-0_30:4.4
	Freeway-0_29:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3
	Ursula_RiscPC:4.3.0.4
	rthornb_UrsulaBuild-19Aug1998:4.3
	UrsulaBuild_FinalSoftload:4.3
	rthornb_UrsulaBuild-12Aug1998:4.3
	aglover_UrsulaBuild-05Aug1998:4.3
	rthornb_UrsulaBuild-29Jul1998:4.3
	rthornb_UrsulaBuild-22Jul1998:4.3
	rthornb_UrsulaBuild-15Jul1998:4.3
	rthornb_UrsulaBuild-07Jul1998:4.3
	rthornb_UrsulaBuild-17Jun1998:4.3
	Ursula_bp:4.3
	Ursula:4.3.0.2
	celkins_Freeway-0_28:4.3
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	Daytona:4.2.0.4
	Daytona_bp:4.2
	RO_3_71:4.1.3.1
	MergeFiles:4.1.3.2
	RO_3_70:4.1.3.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.13
date	2017.05.26.08.29.28;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	pOdxanHnslTElSSz;

4.12
date	2015.06.17.21.14.11;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	66uUt1H17KKXmPpy;

4.11
date	2013.08.26.10.28.55;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	5t2rCCsxEEOV0X2x;

4.10
date	2013.04.06.06.44.30;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	RiXDM7HRu9lVkGKw;

4.9
date	2012.07.19.10.52.58;	author rgriffin;	state Exp;
branches;
next	4.8;
commitid	RkurLk6qX14k6adw;

4.8
date	2003.03.11.21.23.33;	author rsprowson;	state Exp;
branches;
next	4.7;

4.7
date	2003.02.27.15.02.34;	author rsprowson;	state Exp;
branches;
next	4.6;

4.6
date	2002.12.13.20.41.18;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2001.11.13.14.44.54;	author dellis;	state Exp;
branches;
next	4.4;

4.4
date	99.08.16.15.11.46;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	98.06.16.15.57.09;	author celkins;	state Exp;
branches;
next	4.2;

4.2
date	97.05.13.11.38.32;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.26.40;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1;
next	;

4.1.1.1
date	96.11.05.09.26.40;	author nturton;	state Exp;
branches;
next	4.1.1.2;

4.1.1.2
date	96.11.05.16.16.37;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.58.44;	author nturton;	state Exp;
branches;
next	4.1.3.2;

4.1.3.2
date	96.11.08.17.19.52;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.13
log
@Keep messages open when dormant
When Freeway concludes it has no interfaces, it called fw_final() & closed the messages file. In turn any errors reported from SWIs or *commands came out as untranslated tokens.
Move the release_msgs() to when the module finalises in fw_module_final(), not just when it's given up trying.
Also close the messages if fw_init() returns an error - there was one case where that would not happen and leave MessageTrans/ResourceFS pointing at some old RMA.

Replaced a few magic numbers with defines from the appropriate headers.

Tested in a machine with no network interface, which used to say "FWNoInet" in response to *FWShow.

Version 0.41. Tagged as 'Freeway-0_41'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Freeway (module.c)
 *
 * Copyright (C) Acorn Computers Ltd. 1991-9
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"

#include "Global/Services.h"
#include "Global/CMOS.h"
#include "Global/OsBytes.h"
#include "Global/ModHand.h"
#include "AsmUtils/irqs.h"

#include "sys/types.h"
#include "sys/uio.h"
#include "sys/socket.h"
#include "sys/time.h"
#include "sys/ioctl.h"
#include "sys/errno.h"
#include "sys/dcistructs.h"
#include "netinet/in.h"
#include "net/if.h"
#include "net/ethernet.h"

#include "socklib.h"
#include "inetlib.h"
#include "module.h"

#include "FreewayHdr.h"

static void fw_final(void);
static void release_msgs(int *);
static int is_from_us(u_long src);

static _kernel_oserror *FreewayStatus(_kernel_swi_regs *r);
static _kernel_oserror *FreewaySerial(_kernel_swi_regs *r);
static _kernel_oserror *init_msgs(char *filename, int *fd);
static _kernel_oserror *fw_evenable(void);

/*
 * declare global variables
 */
struct fw fw = { 0 };
struct serial_if serial_if = { 0 };
u_long local_adr = 0;

static void *module_wsp = 0;

static int msg_fd[5] = { 0 }; /* 1st word is "open" flag */

static struct eblk error_blocks[] = {
    { 0, 0 },
    { 0x809f00, "FWType" },
    { 0x809f01, "FWOExt" },
    { 0x809f02, "FWONEx" },
    { 0x809f03, "FWDBuf" },
    { 0x809f04, "FWNBuf" },
    { 0x809f05, "FWNMem" },
    { 0x809f06, "FWOUnk" },
    { 0x809f07, "FWNNet" },
    { 0x809f08, "FWLStr" },
    { 0x809f09, "FWNLoc" },
    { 0x809f0a, "FWNAut" },
    { 0x809f0b, "FWNoInet" },
    { 0x809f0c, "FWStatusMsg" },
    { 0x809f0d, "FWInvalSWI" },
    { 0x809f0e, "FWSNoInt" },
    { 0x809f0f, "FWSBadParam" }
    };


struct swient
{
    _kernel_oserror *(*swi_call)();         /* swi handler */
};

static struct swient fw_ent[] = {
    RegisterType,
    WriteObject,
    ReadObject,
    EnumerateObjects,
    FreewayStatus,
    FreewaySerial,
};

static _kernel_oserror *fw_show(const char *, int);
static _kernel_oserror *fw_add_net(const char *);
static _kernel_oserror *fw_conf_auto_address(const char *, int);

static _kernel_oserror *calleverytick(void (*fun)(void)), *fw_claimv(void);
static _kernel_oserror *fw_real_init(void);
static int inet_present(void);

static const char protocol_name[] = "Internet";

static int dostart = 0;
static int startup_done = 0;
static int setting_address = 0;

int doobjects = 0;

extern void readdevice_entry(void);

/* Read and write the CMOS bit for controlled auto-address setting
 * This routine returns non-zero if address setting is *enabled*
 */
static int auto_address_cmos_read(void)
{
    unsigned int byte;
    (void) _swix(OS_Byte, _INR(0,1)|_OUT(2), OsByte_ReadCMOS, SparrowMarker, &byte);
    return !(byte & FreewayNoAutoAddress);
}

static void auto_address_cmos_write(int enable)
{
    unsigned int byte;
    (void) _swix(OS_Byte, _INR(0,1)|_OUT(2), OsByte_ReadCMOS, SparrowMarker, &byte);
    if (enable) {
    	byte &= ~FreewayNoAutoAddress;
    }
    else {
            byte |= FreewayNoAutoAddress;
    }
    (void) _swix(OS_Byte, _INR(0,2), OsByte_WriteCMOS, SparrowMarker, byte);
}

/**********************************************************************
 * This is used to set the environment variables to indicate local
 * addresses.
 */

static void setadrvar(int ifcnt, char *adr)
{
    char varname[32];

    /*
     * Is it the 1st usable interface? If not, add a count to the name.
     */
    if( ifcnt == 0 )
        sprintf(varname, "%s", "Inet$LocalAddr");
    else
        sprintf(varname, "%s%d", "Inet$LocalAddr", ifcnt);

    dprintf(("module", "Setting \"%s\" to \"%s\"\n", varname, adr));
    (void) _kernel_setenv(varname, adr);
}

/**********************************************************************/

/*
 * rmafree - return some claimed memory to RMA
 */
static void rmafree(void *mem)
{
    (void) _swix(OS_Module, _IN(0)|_IN(2), ModHandReason_Free, mem);
}

/**********************************************************************
 * This code reads back the DIB for the DCI drivers that are known
 * (the loopback device isnt read) and attempts to work out the
 * device address in order to make up an address for freeway to use
 * on the device.
 */

static void read_device_name(char *buf, char *etheradr)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;
    ChDibRef chd, chdnext;
    struct ifreq ifreq;
    int s;

    dprintf(("module", "RD> Reading device information\n"));

    /*
     * error "return" is a null string in buf
     */
    buf[0] = '\0';


    r.r[0] = NULL;
    r.r[1] = Service_EnumerateNetworkDrivers;

    if( (e = _kernel_swi(OS_ServiceCall, &r, &r)) != NULL )
        return;

    if( (chd = (struct chaindib *)(r.r[0])) == NULL )
        return;

    /*
     * open a socket so we can read some interface details
     */
    if( (s = socket(PF_INET, SOCK_DGRAM, 0)) < 0 )
        return;

    /*
     * 950322 KWelton
     *
     * this routine has been restructured so that
     * only "suitable" interfaces are selected to
     * have their address set. "Suitable" means
     *
     * a)  Interface must support broadcast. This
     *     is a standard Freeway requirement.
     *
     * b)  Interface must support ARP.  If the i/f
     *     doesn't support ARP, then the chances
     *     are pretty good that it doesn't have a
     *     "unique" hardware address we can use to
     *     generate an interface address from
     */
    while( chd )
    {
        dprintf(("module", "RD> Reading %s's ether address\n", buf));
        /*
        dprintf(("module", "RD> Address is %s\n",
               ether_sprintf(chd->chd_dib->dib_address));
        */

        sprintf(ifreq.ifr_name, "%.*s%d",
                sizeof(ifreq.ifr_name) - 2,
                chd->chd_dib->dib_name, chd->chd_dib->dib_unit);

        /*
         * check that Internet knows about this interface and
         * that the interface features are acceptable.
         */
        if( (socketioctl(s, SIOCGIFFLAGS, (caddr_t)&ifreq) == 0 &&
             (ifreq.ifr_flags & IFF_BROADCAST) &&
             !(ifreq.ifr_flags & IFF_NOARP)) )
        {
            int i;

            strcpy(buf, ifreq.ifr_name);

            for( i = 0; i < ETHER_ADDR_LEN; i++ )
                etheradr[i] = chd->chd_dib->dib_address[i];

            break;
        }

        /*
         * this interface is no good, free it here and now
         * and try the next one.
         */
        chdnext = chd->chd_next;
        rmafree(chd);
        chd = chdnext;
    }

    /*
     * 950308 KWelton
     *
     * As the initiator of Service_EnumerateNetworkDrivers,
     * we have a responsibility to free the RMA claimed
     * during the service call
     */
    while( chd )
    {
        chdnext = chd->chd_next;
        rmafree(chd);
        chd = chdnext;
    }

    /*
     * finished - close the socket and go away
     */
    socketclose(s);
    return;
}

/**********************************************************************
 * This is the main part of the initialisation. It tries to evaluate
 * all known ether drivers and see what if any are suitable for freeway
 * to use. It does this by looking to see if the device is able to
 * broadcast, isnt the loopback device and is able to be configured
 * at the software level to the settings that freeway requires.
 *
 * This routine may be called on many occasions when new drivers start
 * up. In this case it should find the last known suitable driver in the
 * fw structure, then skip down the list that is avaliable from the INET
 * module until it finds that one. Then it should start testing from there
 * since no record is kept of failed interfaces. This is probably the
 * most efficient way of doing this. [ Not Implemented yet ]
 */
static int read_ifs(void)
{
    char buf[512], name[16];
    struct ifconf ifc;
    struct ifreq ifreq, *ifr;
    struct sockaddr_in *sin = NULL;
    int s, n, flags;

    char etheradr[ETHER_ADDR_LEN];
    int retried = 0;
    u_long byte0, byte1, byte2;

    /* extern struct in_addr inet_makeaddr(int net, int host); */

    fw.fw_ifcnt = 0;    /* Reset count of interfaces, since we're about to
                         * re-enumerate them
                         */

    /*
     * Open a socket in order to read back the info from the drivers.
     * This is a UDP based application. If we can't open the socket
     * abort.
     */
      dprintf(("module", "IC> Opening socket...."));

    if( (s = socket(AF_INET, SOCK_DGRAM, 0)) < 0 )
    {
      dprintf(("module", "Failed - aborting\n"));
    return -1;
    }

      dprintf(("module", "Succeeded (temp socket=%d)\n",s));

    again: /* UGHHH! - used for found an interface without an IP address */

    /*
     * Initialise things, including reading back the way that the
     * interface is currently set up.
     */
    ifc.ifc_len = sizeof(buf);
    ifc.ifc_buf = buf;

      dprintf(("module", "IC> Reading Interface(s) config (SIOCGIFCONF)..."));

    if( socketioctl(s, SIOCGIFCONF, (char *)&ifc) < 0 )
    {
        dprintf(("module", "Failed - aborting\n"));
      socketclose(s);
      return -1;
    }

      dprintf(("module", "Succeeded\n"));

    ifr = ifc.ifc_req;

    /* 96/11/29 - CE
     * Removed the 'skip over known usable interfaces guff'
     * simply keep all interfaces in table, and mark those which are unusable
     * as such ; need to take care in case order in chain changes (likely).
     *
     */
    if (ifr == NULL)
    {
        dprintf(("module", "IC> Skipped all known interfaces - aborting\n"));
      return fw.fw_ifcnt;
    }

    /*
     * Loop around the possible devices evaluating each one.
     */
    for (n = ifc.ifc_len / sizeof (struct ifreq); n > 0; n--, ifr++)
    {
       ifreq = *ifr;

        dprintf(("module", "IC> Evaluating found interface: (%s) :",ifreq.ifr_name));

         /*
          * KJB - fix to prevent each interface being marked twice until
          * 4.4BSD Internet module (each interface also has an AF_LINK address)
          */
       if (((struct sockaddr *)&ifreq.ifr_addr)->sa_family != AF_INET)
       {
           dprintf(("module", "not an AF_INET address - skipping\n"));
         continue;
       }

       /*
        * Check to see if its the loop back device. We dont want this
        */
       if ((socketioctl(s, SIOCGIFFLAGS, (char *)&ifreq) < 0) || (ifreq.ifr_flags & IFF_LOOPBACK))
       {
            dprintf(("module", "loopback device - skipping\n"));
          continue;
       }

       /*
        * The interface needs to be able to broadcast, or to be a desired
        * point to point link, in which case, we'll fudge 'broadcast'
        */
       flags = ifreq.ifr_flags;
       /*
        * Get the address of the interface
        */
      if (socketioctl(s, SIOCGIFADDR, (char *)&ifreq) < 0)
      {
            dprintf(("module", "cant get interface address - skipping\n"));
          continue;
      }

      sin = (struct sockaddr_in *)&ifreq.ifr_addr;

      /*
       * If we dont currently know the local address, set it to
       * the one we just found.
       */
      if (local_adr == 0)
      {
        local_adr = sin->sin_addr.s_addr;
          dprintf(("module", "setting local_adr=%lx...", local_adr));
      }

      sprintf(name, "%lx", (unsigned long) sin->sin_addr.s_addr);

      dprintf(("module", "Storing interface info.\n"));
      setadrvar(fw.fw_ifcnt, name);
      strncpy(&fw.fw_ifunit[fw.fw_ifcnt][0],ifreq.ifr_name,16);
      fw.fw_ifaddrs[fw.fw_ifcnt] = sin->sin_addr.s_addr;

      /*
       * Find out the broadcast address. If we cant get it then
       * check if it's a point to point interface.
       */
      if ((flags & IFF_BROADCAST) == IFF_BROADCAST)
      {
        if (socketioctl(s, SIOCGIFBRDADDR, (char *)&ifreq) < 0)
         {
             dprintf(("module", "Cant get broadcast address - unsetting local_addr\n"));
           local_adr = 0;
           fw.fw_ifbcast[(fw.fw_ifcnt)] = INADDR_NONE;
         }
         else
         {
           /*
            * Keep account of this card since it meets the requirements.
            */
           sin = (struct sockaddr_in *)&ifreq.ifr_broadaddr;
           fw.fw_ifbcast[(fw.fw_ifcnt)] = sin->sin_addr.s_addr;
         }
      }
      else
      if ((flags & IFF_POINTOPOINT) == IFF_POINTOPOINT)
      {
        if (serial_if.serial_if_request == 0)
        {
            dprintf(("module", "Serial support not requested - unsetting local_addr\n"));
          local_adr = 0;
          fw.fw_ifbcast[(fw.fw_ifcnt)] = INADDR_NONE;
        }
        else
        if (socketioctl(s,SIOCGIFDSTADDR, (char *)&ifreq) < 0)
        {
            dprintf(("module", "Unable to get destination address - unsetting local_addr\n"));
          local_adr = 0;
          fw.fw_ifbcast[(fw.fw_ifcnt)] = INADDR_NONE;
        }
        else
        {
          /*
           * Keep account of this card since it meets the requirements, and
           * we're requested to use this serial interface.
           */
          sin = (struct sockaddr_in *)&ifreq.ifr_dstaddr;
          fw.fw_ifbcast[(fw.fw_ifcnt)] = sin->sin_addr.s_addr;
        }
      }
      if ((flags & IFF_UP) != IFF_UP)
      {
          dprintf(("module", "Interface is marked down - clearing broadaddr\n"));
        fw.fw_ifbcast[(fw.fw_ifcnt)] = INADDR_NONE;
      }
      fw.fw_ifcnt++;
    }

    /*
     * We havent found a valid interface. Make up an address etc.
     * and use that instead (if we can find an ether driver.
     */
    if (fw.fw_ifcnt == 0 && !retried && auto_address_cmos_read())
    {
        dprintf(("module", "IC> No usable devices found. Trying to make up an address\n"));

      read_device_name(name, etheradr);

        dprintf(("module", "IC> Try using name: %s...",name));

      if (name[0] != 0 )
      {
        int retc;
        int irqstatus;

           dprintf(("module", "Making up ether address..."));
        byte0 = (u_char)etheradr[5];
        byte1 = (u_char)etheradr[4];
        byte2 = (u_char)name[1];
          dprintf(("module", "Address derived from: %ld %ld %ld...", byte0, byte1, byte2));
        sin = (struct sockaddr_in *)&ifreq.ifr_addr;

        /* next line modified 25/7/94 gw */
        /*
         * 20120718 Changed by RG to assign a valid private IP
         * address of 10.a.b.c.
        */
        sin->sin_addr = inet_makeaddr(10, (byte0 | byte1 << 8UL | byte2 << 16UL));
        sin->sin_family = AF_INET;

        strncpy(ifreq.ifr_name, name, sizeof(ifreq.ifr_name));

        irqstatus = ensure_irqs_off();
        ++setting_address;
        restore_irqs(irqstatus);
        retc = socketioctl(s, SIOCSIFADDR, (caddr_t)&ifreq);
        irqstatus = ensure_irqs_off();
        --setting_address;
        restore_irqs(irqstatus);

        if( retc >= 0 )
        {
            dprintf(("module", "Seeing if this setup works.\n"));
          retried = 1;
          goto again;
        }
          dprintf(("module", "Unable to setup address.\n"));
      }
    }

    /*
     * If we have found a valid interface....
     */
    if( fw.fw_ifcnt > 0 )
    {
      _kernel_swi_regs r;
      _kernel_oserror *e;
      struct address_q *q;
      u_long ipadr;

        dprintf(("module", "IC> Found valid interface. Looking at Econet_EnumerateMap:"));

      r.r[4] = 0;
      for(;;)
      {
        e = _kernel_swi(Econet_EnumerateMap,&r, &r);
          dprintf(("module", "r4 = %d",r.r[4]));
        if (e || r.r[4] == -1)
        {
          dprintf(("module", "\n"));
        break;
        }

        q = (struct address_q *)malloc(sizeof(struct address_q));
        if (!q)
        {
            dprintf(("module", "No more Found\n"));
          break;
        }

        ipadr = (u_long)r.r[3];
          dprintf(("module", "Found: %s, adding. ", (char *) r.r[3]));
        q->q_bcast.s_addr = ipadr | 0xffff0000;
        q->q_next = fw.fw_netadrs;
        fw.fw_netadrs = q;
      }
    }

    /*
     * Tidy up and return
     */
      dprintf(("module", "IC> Done\n"));

    socketclose(s);
      dprintf(("module", "IC> fw struct at %p\n",&fw));
    return fw.fw_ifcnt;
}

/**********************************************************************/

static int do_getsock(int port, int inputsocket)
{
    struct sockaddr_in addr;
    int sock, on = 1;

    if( (sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
        dprintf(("module", "DGS> Failed to open a socket - aborting\n"));
        return (-1);
        }
    dprintf(("module", "DGS> Opened socket %d - ", sock));

    if( socketioctl(sock, FIONBIO, &on) < 0 ||
       socketioctl(sock, FIOASYNC, &on) < 0 )
    {
        dprintf(("module", "Cannot set FIONBIO and/or FIOASYNC.. Aborting\n"));
        socketclose (sock);
        return (-1);
    }
    dprintf(("module", "FIONBIO..FIOASYNC.."));


    if( setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &on, sizeof (on)) < 0 )
    {
        dprintf(("module", "Unable to toggle SO_BROADCAST.. Aborting\n"));
        socketclose(sock);
        return (-1);
    }
    dprintf(("module", "SO_BROADCAST.."));


    if( inputsocket )
    {
        addr.sin_family      = AF_INET;
        addr.sin_addr.s_addr = htonl(INADDR_ANY);
        addr.sin_port        = htons((u_short)port);
        dprintf(("module", "Input socket, binding to %d..", port));

        if( bind(sock, (struct sockaddr *)&addr, sizeof (addr)) < 0 )
        {
            dprintf(("module", "Bind failed - aborting\n"));
            socketclose(sock);
            return (-1);
        }
    }

    dprintf(("module", "Bound.\n"));

    return(sock);
}

/**********************************************************************/

static int callback(void (*func)())
{
    _kernel_swi_regs r;

    r.r[0] = (int)func;
    r.r[1] = (int)module_wsp;
    return(_kernel_swi(OS_AddCallBack, &r, &r) != 0 ? -1 : 0);
}

/**********************************************************************/

static void clear_callback(void (*func)())
{
    _kernel_swi_regs r;

    r.r[0] = (int)func;
    r.r[1] = (int)module_wsp;
    (void)_kernel_swi(OS_RemoveCallBack, &r, &r);
}

/**********************************************************************/

extern void callb_entry(void);
static volatile int callbackflag = 0;
static volatile int readdevice_callback = 0;
#ifdef OldCode
static volatile int rscallbackflag = 0;
#endif

void setcallback(void)
{
    dprintf(("module", "SCB> setcallback (flag = %d)", callbackflag));

    if( callbackflag == 0 )
    {
        callbackflag = 1;

        if( callback(callb_entry) != 0 ) {
            dprintf(("module", "Failed\n"));
            callbackflag = 0;
        }
    }

    dprintf(("module", "Ok!\n"));

}

/**********************************************************************/

/*
 * fw_prime - prepare module for start/restart
 */
static void fw_prime(void)
{
    dprintf(("module", "FWP> In Freeway Prime\n"));

    /*
     * clear down the main Freeway information structure.
     */
    memset((char *)&fw, 0, sizeof(fw));

    /*
     * we currently have no sockets open
     */
    fw.fw_rssock = fw.fw_rssock1 = -1;

    /*
     * we no longer have a local address
     */
    local_adr = 0;

    /*
     * we have not yet completed a full startup
     */
    startup_done = 0;
}

/**********************************************************************/

/*ARGSUSED*/
_kernel_oserror *fw_init(const char *cmd_tail, int pbase, void *pw)
{
    _kernel_oserror *e;
    module_wsp = pw;

    /* shut the compiler up */
    (void) cmd_tail;
    (void) pbase;

    debug_initialise("Freeway", "", "");
    debug_atexit();
    debug_set_options(0, 0, 0);
    debug_output_device(PRINTF_OUTPUT);

#ifdef TRACE_ENABLED
    debug_initialise_trace (PRINTF_OUTPUT, "");
#endif
    e = init_msgs(Module_MessagesFile, msg_fd);
    if (e)
        return (e);

    fw_prime();

    /*
     * Look to see if the internet modules are present. If so
     * continue with initialisation.
     */
    dprintf(("module", "IN> Attempting to find the Internet module\n"));

    if (inet_present() == 0)
    {
        dprintf(("module", "IN> Returning Internet not found\n"));
        return NULL;
    }

    e = fw_real_init();
    if (e)
    {
        dprintf(("module", "IN> real init returned %s\n", e->errmess));
        release_msgs(msg_fd);
        return (e);
    }

    return NULL;
}

/*
 * Set up the various even handlers.
 */
static _kernel_oserror *fw_setup_events(void)
{
    _kernel_oserror *e;

    /*
     * Set up a claim on an event vector (EventV)
     */
    dprintf(("module", "FWE> Looking to claim: EventV..."));

    e = fw_claimv();

    if (e)
    {
        dprintf(("module", "Failed.\n"));

        fw_final();
        return(e);
    }

    /*
     * Set up a claim on another event vector (Event_Internet)
     * to enable early trapping of read signals on sockets.
     */
     dprintf(("module", "OK.. Event_Internet..."));

    e = fw_evenable();

    if (e)
    {
        dprintf(("module", "Failed.\n"));
        fw_final();
        return(e);
    }

    /*
     * Set up a claim on an event vector (TickerV)
     * to be called every 10ms
     */
    dprintf(("module", "OK.. TickerV..."));

    e = calleverytick(tick_entry);

    if (e)
    {
        dprintf(("module", "Failed\n"));

        fw_final();
        return(e);
    }

    dprintf(("module", "Ok.\n"));
    return NULL;
}

/**********************************************************************
 * This routine gets called once Internet has started. There is either
 * no point in doing some of these things before then (event handling)
 * or we cant do it (Device Driver evaluation). This can be called
 * from one of 2 places. Either the fw_init() if FW is initialising
 * after Internet and the DDs have loaded, or else from a SWI handle
 * when the required modules have been loaded.
 */
static _kernel_oserror *fw_real_init(void)
{
    _kernel_oserror *e;
    int s;

    /*
     * Look to see what (if any) suitable DD are present.
     */
    fw.fw_ifcnt = 0;

    dprintf(("module", "RI> Doing interface count\n"));

    read_ifs();
    if (fw.fw_ifcnt == 0)
    {
        /*
         * Internet has started, but no device drivers are present so
         * we should wait until some are.
         */
        return NULL;
    }

    /*
     * Now set up event handlers
     */
    dprintf(("module", "RI> Setting up event handlers\n"));

    e = fw_setup_events();
    if (e)
        goto out;

    /*
     * If we found no suitable interfaces or cannot open the required
     * socket, abort here.
     */

    s = do_getsock(FWPORT, 1); /* Don't make an assignment to fw_rssock yet! */
    if( (fw.fw_ifcnt <= 0) || (s < 0) )
    {
        /* Couldn't get the desired socket.Iff we already had some lingering close them too */
        if (fw.fw_rssock >= 0)  socketclose(fw.fw_rssock);
        if (fw.fw_rssock1 >= 0) socketclose(fw.fw_rssock1);
        fw.fw_rssock = fw.fw_rssock1 = -1;
        e = fw_error(Err_FWNNet);
        goto out;
    }
    fw.fw_rssock = s; /* Success,now make an assignment */
    dprintf(("module", "RI> Opened Socket (Unauth socket) - %d\n", fw.fw_rssock));

    /*
     * Again, if we cant open the required socket, abort.
     */
    s = do_getsock(FWPORT1, 1); /* Don't make an assignment to fw_rssock1 yet! */
    if (s < 0)
    {
        /* Couldn't get the other desired socket,clear up any lingering sockets */
        socketclose(fw.fw_rssock);
        if (fw.fw_rssock1 >= 0) socketclose(fw.fw_rssock1);
        fw.fw_rssock = fw.fw_rssock1 = -1;
        e = fw_error(Err_FWNNet);
        goto out;
    }
    fw.fw_rssock1 = s; /* Success,now make an assignment */
    dprintf(("module", "RI> Opened Socket1 (Auth Socket) - %d\n", fw.fw_rssock1));

    /*
     * Notify that we have started.
     */
    dprintf(("module", "RI> Initialisation succeded\n"));
    dostart = 1;
    startup_done = 1;
    setcallback();
    return NULL;

out:
    dprintf(("module", "RI> Initialisation failed\n"));
    fw_final();
    return(e);
}

/**********************************************************************
 * Notify an interest in the main event vector.
 */
static _kernel_oserror *fw_claimv(void)
{
    _kernel_swi_regs r;

    r.r[0] = EventV;
    r.r[1] = (int)fw_event_entry;
    r.r[2] = (int)module_wsp;
    dprintf(("module", ":FWC: Claiming EventV.."));
    return(_kernel_swi(OS_Claim, &r, &r));
}

/*
 * 950330 KWelton
 *
 * Keep a count of event enables
 */
static volatile int nenables = 0;

/**********************************************************************
 * Lookout for Internet based Events. (SIGIO, SIGPIPE etc).
 */
_kernel_oserror *fw_evenable(void)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    r.r[0] = OsByte_EnableEvent;
    r.r[1] = Event_Internet;
    dprintf(("module", ":FEV: Enabling Event_Internet.."));

    if( (e = _kernel_swi(OS_Byte, &r, &r)) == NULL )
    {
        int s = ensure_irqs_off();
        ++nenables;
        restore_irqs(s);
    }

    return(e);
}

/**********************************************************************
 * Release event handlers
 */
static void fw_releasev(void)
{
    _kernel_swi_regs r;

    dprintf(("module", "FWR> Releasing Event_Internet (nenables = %d)...", nenables));

    r.r[0] = OsByte_DisableEvent;

    while( nenables > 0 )
    {
        r.r[1] = Event_Internet;

        if( _kernel_swi(OS_Byte, &r, &r) == NULL )
        {
            int s = ensure_irqs_off();
            --nenables;
            restore_irqs(s);
        }
        else
        {
            /*
             * make the best of a very bad job
             */
            nenables = 0;
            continue;                           /* XXX */
        }
    }

    dprintf(("module", "EventV\n"));

    r.r[0] = EventV;
    r.r[1] = (int)fw_event_entry;
    r.r[2] = (int)module_wsp;
    (void)_kernel_swi(OS_Release, &r, &r);
}

/**********************************************************************
 * Attempt to open the message file.
 */

_kernel_oserror *init_msgs(char *filename, int *fd)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

#ifndef ROM
    /*
     * Place the messages into ResourceFS
     */
    r.r[0] = (int)Resources();
    e = _kernel_swi(ResourceFS_RegisterFiles, &r, &r);
    if (e)
        return e;
#endif

    /*
     * Look to see if the messages file exists. If it doesnt,
     * there isnt much point in continuing.
     */
    r.r[1] = (int)filename;
    e = _kernel_swi(MessageTrans_FileInfo, &r, &r);
    if (e)
        return (e);

    /*
     * If we can get file information then we should be able to open it
     * so look to see if we can.
     */
    r.r[0] = (int)(fd+1);
    r.r[1] = (int)filename;
    r.r[2] = 0;
    e = _kernel_swi(MessageTrans_OpenFile, &r, &r);
    fd[0] = e == NULL;
    return (e);
}

/**********************************************************************
 * Close the messages file
 */

static void release_msgs(int *fd)
{
    _kernel_swi_regs r;

    if (fd) {
        r.r[0] = (int)(fd+1);
        (void)_kernel_swi(MessageTrans_CloseFile, &r, &r);
        fd[0] = 0;
#ifndef ROM
        r.r[0] = (int)Resources();
        (void)_kernel_swi(ResourceFS_DeregisterFiles, &r, &r);
#endif
    }
}

/**********************************************************************
 * Lookup a non error message
 */

const char *fw_lookup(const char *token)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;
    static char string[64];

    if (msg_fd) {
        r.r[0] = (int)(msg_fd+1);
        r.r[1] = (int)token;
        r.r[2] = (int)string;
        r.r[3] = sizeof(string);
        r.r[4] = r.r[5] = r.r[6] = r.r[7] = 0; /* No params */
        e = _kernel_swi(MessageTrans_Lookup, &r, &r);
        if (e == NULL)
            return string;
    }
    return "";
}

/**********************************************************************
 * Error handler
 */

_kernel_oserror *fw_error(int error)
{
    static _kernel_oserror ebuf;
    _kernel_swi_regs r;

    if( !error )
        return NULL;

    ebuf.errnum = error_blocks[error].err_nbr;
    strcpy(ebuf.errmess, error_blocks[error].err_token);
    if (!msg_fd[0]) return (_kernel_oserror *)&ebuf;
    memset ((char *)&r, 0, sizeof(r));
    r.r[0] = (int)&ebuf;
    r.r[1] = (int)(msg_fd+1);
    return _kernel_swi(MessageTrans_ErrorLookup, &r, &r);
}

/**********************************************************************
 * Command line interface handler...
 */

/*ARGSUSED*/
_kernel_oserror *fw_cli_handler(const char *arg_string, int arg_count,
                                int cmd_no, void *pw)
{
    _kernel_oserror *error = NULL;

    /* shut the compiler up */
    (void) pw;
    switch (cmd_no) {
        default:
            break;
        case CMD_FwShow:
            if (startup_done) {
                error = fw_show(arg_string, arg_count);
            }
            else {
                error = fw_error(Err_FWNoInet);
            }
            break;
        case CMD_FwAddNet:
            error = fw_add_net (arg_string);
            break;
        case CMD_FreewayAutoAddress:
            error = fw_conf_auto_address(arg_string, arg_count);
            break;
    }

    return(error);
}


/**********************************************************************
 * FreewayAutoAddress configuration command.
 *
 */
static void fw_conf_syntax(const char *suffix)
{
    _swix(OS_Write0, _IN(0), "FreewayAutoAddress ");
    _swix(OS_Write0, _IN(0), suffix);
    _swix(OS_NewLine, 0);
}

static _kernel_oserror *fw_conf_auto_address(const char *a, int b)
{
    (void) b;

    if (a == arg_CONFIGURE_SYNTAX) {
        fw_conf_syntax("On|Off");
    }
    else if (a == arg_STATUS) {
        fw_conf_syntax(auto_address_cmos_read() ? "On" : "Off");
    }
    else {
        _kernel_oserror *e;
        union {
            char *args[2];
            char bytes[24];
        } buffer;
        e = _swix(OS_ReadArgs, _INR(0,3), ",", a, &buffer, sizeof(buffer));
        if (e != NULL) {
            return e;
        }
        if (buffer.args[1] != NULL) {
            return configure_TOO_MANY_PARAMS;
        }
        if (buffer.args[0] == NULL) {
            return configure_BAD_OPTION;
        }
        else {
            char *arg;
            for (arg = buffer.args[0]; *arg; ++arg) {
                *arg = tolower(*arg);
            }
            arg = buffer.args[0];
            if (strcmp(arg, "on") == 0) {
                auto_address_cmos_write(1);
            }
            else if (strcmp(arg, "off") == 0) {
                auto_address_cmos_write(0);
            }
            else {
                return configure_BAD_OPTION;
            }
        }
    }

    return NULL;
}

/**********************************************************************
 * FWShow command. This lists all known access hosts and discs that
 * can be shared. -- Added in the definitions of DOMAIN_DISC and
 * DOMAIN_HOST (PWain).
 *
 * 96/12/03 - CE
 * Have removed specific knowledge of types - now added by client.
 */

/*ARGSUSED*/
static _kernel_oserror *fw_show(const char *a, int b)
{
    struct fwtype *f;
    struct object_q *rl;
    struct address_q *q;

    /* shut the compiler up */
    (void) a;
    (void) b;

    /*
     * Display any remote networks known about.
     */
    if( fw.fw_netadrs == NULL )
        printf("%s\n", fw_lookup("NoRNet"));
    else
    {
        printf("%s:\n", fw_lookup("RNet"));
        for( q = fw.fw_netadrs; q; q = q->q_next )
            printf("    %s\n", inet_ntoa(q->q_bcast));
    }

    /*
     * Gap before the types (if any)
     */
    if( fw.fw_types != NULL )
        printf("\n");

    /*
     * Display information about Freeway types that are known.
     */
    for (f = fw.fw_types; f; f = f->fw_next)
    {
        printf("%s %u: ", fw_lookup("ShowT" /* Type */), f->fw_number);
        if (f->fw_name[0])
            printf("(%s)\n",f->fw_name);
        else
            printf("\n");

        for (rl = f->fw_remobj; rl; rl = rl->r_next)
        {
            /*
             * If this entry isnt in use ignore it.
             */
            if (!rl->r_inuse)
                continue;

            /*
             * Show entry. Local ones are prefixed with a "*"
             */
            printf("   %c%s=%-10s ", 
                   rl->r_local ? '*' : ' ',
                   fw_lookup("ShowN" /* Name */), 
                   rl->r_title);
            printf("%s=%s\n", 
                   fw_lookup("ShowH" /* Holder */), 
                   inet_ntoa(rl->r_ip));
        }

        if (f->fw_next)
            printf("\n");
    }

    return NULL;
}

/**********************************************************************
 * FwAddNet command. This adds a remote network for freeway to broadcast
 * on.  The broadcast address of the remote network must be specified
 */

static _kernel_oserror* fw_add_net (const char* args)
{
    struct address_q *q;
    u_long ipadr = 0, hostmask;
    int netbits;
    char buf[256], *p = buf;

    /* copy the string so that it's null terminated */
    while ((*p++ = *args++) > ' ' && p - buf < 254);
    *--p = 0;

    if ((netbits = inet_net_pton (AF_INET, buf, &ipadr, sizeof ipadr)) < 0)
        return fw_error (Err_FWLStr);
    ipadr = ntohl (ipadr);

    q = (struct address_q *)malloc(sizeof(struct address_q));
    if (!q)
    {
        dprintf(("module", "No more Found\n"));
        return fw_error (Err_FWNMem);
    }

    hostmask = (1ul << (32 - netbits)) - 1ul;
    if (!(ipadr & hostmask)) ipadr |= hostmask;

    q->q_bcast.s_addr = htonl (ipadr);
    q->q_next = fw.fw_netadrs;
    fw.fw_netadrs = q;

    return 0;
}

/**********************************************************************/

static void fw_servicecall(int sc)
{
    _kernel_swi_regs r;

    dprintf(("module", "FSC> Sending service call: %x\n",sc));
    r.r[1] = sc;
    (void) _kernel_swi(OS_ServiceCall, &r, &r);
}

/**********************************************************************/

void fw_upcall(int upc, int type, struct object_q *rq)
{
    _kernel_swi_regs r;

#ifdef DEBUGLIB
    switch(upc) {
        case FW_ADDED: dprintf(("module", "FWU> Upcall: added ")); break;
        case FW_REMOVED: dprintf(("module", "FWU> Upcall: removed ")); break;
        case FW_CHANGED: dprintf(("module", "FWU> Upcall: changed ")); break;
        case FW_DELETED: dprintf(("module", "FWU> Upcall: deleted ")); break;
        default: dprintf(("module", "FWU> Upcall: operation: %d ",upc)); break;
        }
    switch(type) {
        case DOMAIN_DISC: dprintf(("module", "disc ")); break;
        case DOMAIN_HOST: dprintf(("module", "host ")); break;
        case DOMAIN_PRINTER: dprintf(("module", "printer ")); break;
        default: dprintf(("module", "type=%d",type)); break;
        }
    dprintf(("module", "Name: %s, Address: %x\n", rq->r_title , rq->r_ip.s_addr));
#endif/* DEBUGLIB */

    r.r[0] = UpCall_Freeway;
    r.r[1] = upc;
    r.r[2] = type;
    r.r[3] = (int)rq->r_title;
    r.r[4] = rq->r_desclen;
    r.r[5] = (int)rq->r_desc;
    r.r[6] = (u_int)rq->r_ip.s_addr;
    (void)_kernel_swi(OS_UpCall, &r, &r);
}

/**********************************************************************
 * The main SWI handler. This basically looks up and calls the desired
 * (real) handler.
 */
_kernel_oserror *fw_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
    struct swient *callp;

    /* shut the compiler up */
    pw = pw;

    /* range check the SWI number */
    if( swinum >= (sizeof(fw_ent) / sizeof(fw_ent[0])) )
        return(fw_error(Err_FWInvalSWI));

    if (startup_done || (swinum == (Freeway_Status - Freeway_00)) )
    {
        /*
         * Call the desired SWI handler.
         */
#ifdef DEBUGLIB
        switch(swinum) {
            case 0: dprintf(("module", "FWS> Handling SWI: Freeway_Register\n")); break;
            case 1: dprintf(("module", "FWS> Handling SWI: Freeway_Write\n")); break;
            case 2: dprintf(("module", "FWS> Handling SWI: Freeway_Read\n")); break;
            case 3: dprintf(("module", "FWS> Handling SWI: Freeway_Enumerate\n")); break;
            case 4: dprintf(("module", "FWS> Handling SWI: Freeway_Status\n")); break;
            case 5: dprintf(("module", "FWS> handling SWI: Freeway_Serial\n")); break;
            default: dprintf(("module", "FWS> Handling SWI: %d\n", swinum)); break;
            }
#endif /* DEBUGLIB */
        callp = &fw_ent[swinum];
        return((_kernel_oserror *)((callp->swi_call)(r)));
    }

    /*
     * Note: if we had done startup, a return would have been
     * encountered by this point so we can safely do the rest
     * without needing to test. This removes a compiler warning.
     * (No return from function)
     */
    return(fw_error(Err_FWNoInet));
}

/**********************************************************************/

struct fwtype *gettype(int type)
{
    struct fwtype *f;

    for( f = fw.fw_types; f != 0; f = f->fw_next )
        if( f->fw_number == type )
            return(f);

    return ((struct fwtype *)0);
}

/**********************************************************************/

int type_id(char *str)
{
    int type = atoi(str);

    if (type > 0)
        return(type);

    return(-1);
}

/**********************************************************************/

_kernel_oserror *callb_handler(_kernel_swi_regs *r, void *pw)
{
    (void) r;
    (void) pw;
    dprintf(("module", "CBH> In callback handler: "));

    if( callbackflag == 0 ) {
        dprintf(("module", "No callbacks to do - aborting\n"));
        return NULL;
        }

    callbackflag = 0;

    if( dostart )
    {
        dostart = 0;
        dprintf(("module", "Send FreewayStarting service call..\n"));
        fw_servicecall(Service_FreewayStarting);
    }

    if( doobjects )
    {
        dprintf(("module", "Calling do_objects_on_callback.\n"));

        doobjects = 0;
        do_objects_on_callback();
    }

    dprintf(("module", "\n"));

    return (NULL);
}

/**********************************************************************/

static _kernel_oserror *calleverytick(void (*fun)(void))
{
    _kernel_oserror *e;
    _kernel_swi_regs r;

    r.r[0] = TickerV;
    r.r[1] = (int)fun;
    r.r[2] = (int)module_wsp;
    e = _kernel_swi(OS_Claim, &r, &r);
    if (e)
        return (e);

    return NULL;
}

/**********************************************************************/

static void removetickerevent(void (*fun)(void))
{
    _kernel_swi_regs r;

    r.r[0] = TickerV;
    r.r[1] = (int)fun;
    r.r[2] = (int)module_wsp;
    (void)_kernel_swi(OS_Release, &r, &r);
}

/**********************************************************************/

_kernel_oserror *tick_handler(_kernel_swi_regs *r, void *pw)
{
    struct fwtype *f;

/*
 * This produces WAY too much stuff
 *
    dprintf(("module", "FTH> In tickerV handler. Checking all objects.\n"));
 */

    (void) r;
    (void) pw;

    for( f = fw.fw_types; f != 0; f = f->fw_next )
        check_objects(f);

    return (NULL);
}

/**********************************************************************/

_kernel_oserror *fw_module_final(int fatal, int podule, void *pw)
{
    (void) fatal;
    (void) podule;
    (void) pw;
    fw_final();
    dprintf(("module", "FWMF> Closing messages\n"));
    release_msgs(msg_fd);

    return NULL;
}

static void fw_final(void)
{
    struct fwtype *f, *fnext;
    struct address_q *q, *qnext;
    struct object_q *oq, *oqnext;
    struct authreq_q *aq, *aqnext;


    for( f = fw.fw_types, fw.fw_types = 0; f != 0; f = fnext )
    {
#if 0
        do_protocol(f, INADDR_BROADCAST, 0, REMOVE);
#else
        /*
         * XXX - the wrong number of parameters are passed
         * in the version above: make a *guess* at passing
         * it the correct values.
         */
#ifdef DEBUGLIB
        switch(f->fw_number) {
            case DOMAIN_DISC: dprintf(("module", "Discs..")); break;
            case DOMAIN_PRINTER: dprintf(("module", "Printers..")); break;
            case DOMAIN_HOST: dprintf(("module", "Hosts..")); break;
            default: dprintf(("module", "type: %d..", f->fw_number)); break;
            }
#endif /* DEBUGLIB */
        do_protocol(f, INADDR_BROADCAST, 0, REMOVE, 0, 0, 1);
#endif
       /* Now go free all the blocks malloc'd earlier */
       dprintf(("module", "Free fwtype at %08X\n", (int)f));
       fnext = f->fw_next;
       for(oq = f->fw_remobj; oq != 0; oq = oqnext)
          {
          oqnext = oq->r_next;
          free(oq->r_title);
          free(oq->r_desc);
          free(oq);
          }
#if 0
       for(oq = f->fw_locobj; oq != 0; oq = oqnext)
          {
          oqnext = oq->r_next;
          free(oq->r_title);
          free(oq->r_desc);
          free(oq);
          }
#endif
       for(aq = f->fw_authreq; aq != 0; aq = aqnext)
          {
          aqnext = aq->a_next;
          free(aq);
          }
       free(f);
    }

    dprintf(("module", "Events...\n"));
    fw_releasev();

    if( fw.fw_rssock >= 0 )
    {
        dprintf(("module", "FWF> Closing: Socket.."));
        socketclose(fw.fw_rssock);
        fw.fw_rssock = -1;
    }

    if( fw.fw_rssock1 >= 0 )
    {
        dprintf(("module", "Socket1.."));
        socketclose(fw.fw_rssock1);
        fw.fw_rssock1 = -1;
    }

    dprintf(("module", "Ticker events.."));
    removetickerevent(tick_entry);

    dprintf(("module", "Sending termination call\n"));
    fw_servicecall(Service_FreewayTerminating);

    /*
     * 950331 KWelton
     *
     * clear any pending callbacks
     */
    if( callbackflag != 0 )
    {
        clear_callback(callb_entry);
        callbackflag = 0;
    }

    if( readdevice_callback != 0 )
    {
        clear_callback(readdevice_entry);
        readdevice_callback = 0;
    }

    /* free the structures malloc'ed by read_ifs() */
    dprintf(("module", "FWF> Freeing memory\n"));

    for( q = fw.fw_netadrs, fw.fw_netadrs = 0; q; q = qnext )
    {
        qnext = q->q_next;
        free(q);
    }
}

/**********************************************************************/

static void rs_process_input(int format)
{
    struct sockaddr_in from;
    int fromlen, r;
    char inbuf[1024];

    dprintf(("rpi", "RPI> Reading network activity (%sauth):-\n", format == 0 ? "un" : ""));

    for(;;)
    {
        fromlen = sizeof (from);
        r = recvfrom(format == 0 ? fw.fw_rssock : fw.fw_rssock1,
                     inbuf, sizeof(inbuf), 0,
                     (struct sockaddr *)(&from), &fromlen);

        if( r < 0 || fromlen != sizeof(struct sockaddr_in) ) {
            dprintf(("rpi", "RPI: read failed. r=%d, errno=%d\n", r, errno));
            break;
            }

       dprintf(("rpi", "RPI: read %d bytes from %s\n", r,
        inet_ntoa (from.sin_addr)));

        if( !is_from_us(from.sin_addr.s_addr) )
            process_message(from.sin_addr.s_addr, (struct rs_msg *)inbuf,
                            r, format);
    }
}

/**********************************************************************/

int fw_event_handler(_kernel_swi_regs *r, void *pw)
{
    int s, format;

    (void) pw;

    dprintf(("event", "FEH> r0=%s r1=%s ",
         r->r[0]==Event_Internet ? "Internet_Event" : "Other Event" ,
         r->r[1]==SocketIO ? "SIGIO" : "SIGOther"));

    if (r->r[2]==fw.fw_rssock) {
        dprintf(("event", "r2=Socket(unauth) "));
        }
    else if (r->r[2]==fw.fw_rssock1) {
        dprintf(("event", "r2=Socket1(auth) "));
        }
    else dprintf(("event", "r2=%d ",r->r[2]));

    if( r->r[0] == Event_Internet && r->r[1] == SocketIO )
    {
        if( r->r[2] == fw.fw_rssock )
            format = 0;
        else if( r->r[2] == fw.fw_rssock1 )
            format = 1;
        else
            return (1);

        dprintf(("event", "Format=%s\n", format==0 ? "Unauth" : "Auth"));

        s = ensure_irqs_on();
        rs_process_input(format);
        restore_irqs(s);
        return(0);
    }

    return(1);
}

/**********************************************************************/

static int is_from_us(u_long src)
{
    int i;

    for( i = 0; i < fw.fw_ifcnt; i++ )
        if( fw.fw_ifaddrs[i] == src )
            return (1);

    return (0);
}

/**********************************************************************
 * To see if the Internet module is present do a lookup on its name.
 * This will succeed if it is loaded :) Much simpler than the old
 * method.
 */
static int inet_present(void)
{
    _kernel_oserror *err;

    dprintf(("module", "IP>> Looking for module: %s\n", protocol_name));
    err = _swix(OS_Module, _INR(0,1), 18, protocol_name);

    if (!err)
    {
        dprintf(("module", "IP>> Found Internet module!\n"));
        return 1;
    }

    dprintf(("module", "IP>> Found error : %s\n",err->errmess));
    dprintf(("module", "IP>> Found error : %x\n",err->errnum));

    return 0;
}

/*
 * This is the main entry point that we have for picking up if new
 * devices come on line. DCI4 has service calls that announce them
 * for us. Other events may (or maynot) be worth watching for.
 */
void fw_service(int service_number, _kernel_swi_regs *r, void *pw)
{
    /* shut the compiler up */
    pw = pw;

    switch( service_number )
    {
#ifndef ROM
      case Service_ResourceFSStarting:
        /* Reregister the messages */
        (*(void (*)(void *, void *, void *, void *))r->r[2])(Resources(), 0, 0, (void *)r->r[3]);
        break;
#endif
        /*
         * If we get a device driver status call we need to update
         * our own count of the drivers present and see if its one
         * that we are going to use.
         */
      case Service_DCIDriverStatus:
        dprintf(("module", "DD> Received Driver status request\n"));
        dprintf(("module", "DD> Device: %s\n", ((struct dib *)r->r[0])->dib_name));
        /*
         * 950315 KWelton
         *
         * we are only interested in device
         * drivers that are starting up
         */
        if( r->r[2] == DCIDRIVER_STARTING )
        {
            readdevice_callback = 1;
            callback(readdevice_entry);
        }

        break;

        /*
         * DCIProtocol calls are done when any protocol (eg internet)
         * startup.
         */
      case Service_DCIProtocolStatus:
        /*
         * we are only interested in the internet module
         */
        if( !strncmp((char *)r->r[4], (char *)protocol_name,
                     sizeof(protocol_name) + 1) )
        {
            /*
             * it's internet - check its status
             */
            if (r->r[2] == DCIPROTOCOL_STARTING)
            {
                /* internet is starting */
                dprintf(("module", "PP> Internet startup\n"));

                /*
                 * 950306 KWelton
                 *
                 * we don't need to worry if we have already initialised
                 */
                if( startup_done )
                    break;

                dprintf(("module", "PP> Looking to start up Freeway.\n"));

                (void)fw_real_init();
            }
            else if( r->r[2] == DCIPROTOCOL_DYING )
            {
                /*
                 * internet is terminating - shut freeway
                 * down, then prepare it for restart
                 */
                dprintf(("module", "PP> Internet termination\n"));
                fw_final();
                fw_prime();
            }
        }

        break;

      case Service_InternetStatus:
        dprintf(("module", "Service_InternetStatus: reason %d subreason %d (setting_address = %d)\n",
               r->r[0], r->r[2], setting_address));

        switch( r->r[0] )
        {
          case InternetStatus_AddressChanged:
          case InternetStatus_NetMapChanged:
          case InternetStatus_InterfaceUpDown:
            serial_if.serial_if_action = r->r[2];
            /*
             * an internet interface has had its address
             * changed - shutdown and restart Freeway as
             * long as it's not us that set the address.
             */
            if( !setting_address )
            {
                fw_final();
                fw_prime();
                fw_real_init();
            }

            break;

          default:
            break;
        }

        break;

      default:
        break;
    }

    return;
}

_kernel_oserror *readdevice_handler(_kernel_swi_regs *r, void *pw)
{
    (void) r;
    (void) pw;

    if (startup_done == 0) {
        /*
         * This is the 1st interface we know of that we can use so
         * we should try and finish the initialisation.
         */
        dprintf(("module", "CB> Calling real initialisation.\n"));
        (void)fw_real_init();
        }
    else {
        /*
         * Otherwise just add the interface to the list.
         */
        dprintf(("module", "CB> Calling interface count\n"));
        (void)read_ifs();
        }
    return NULL;
}

/*
 * FreewayStatus added 16-02-95. Status request is:
 *
 * calling:
 *
 * r0 == reason code.
 * all other registers reserved.
 *
 * return
 *
 * if r0 = 0  status request
 *
 * r1 = 0 freeway loaded but idle - eg no ether drivers
 * r1 = 1 freeway running.
 * all other registers reserved.
 *
 */
static _kernel_oserror *FreewayStatus(_kernel_swi_regs *r)
{
    switch(r->r[0])
    {
      case 0:
        /* status request - return startup flag */
        r->r[1] = startup_done;
        return(NULL);

        /*NOTREACHED*/
        break;

      default:
        return(fw_error(Err_FWStatus));
    }
}


/*
 * FreewaySerial SWI handler added 96/12/02 - CE
 * To provide support for use of serial interface
 * for freeway/sharefs link
 *
 * In : r0 : 0 => disable serial support
 *           1 => enable serial support
 *      r2 : pointer to unit name
 *
 */
static _kernel_oserror *FreewaySerial(_kernel_swi_regs *r)
{
  int i;

    dprintf(("serial", "FWSer> reason %d",r->r[0]));
    if (r->r[2])
      dprintf(("serial", " unit (%s)",(char *) r->r[2]));
    else
      dprintf(("serial", "\n"));

  switch(r->r[0])
  {
    case 0:     /* serial - remove serial support */
      serial_if.serial_if_request = 0;
      break;
    case 1:     /* serial - add serial support */
      serial_if.serial_if_request = 1;
      break;

    default:
      return(fw_error(Err_FWSerParam));
  }
  if (r->r[2])
  {
    /* strncpy(serial_if.serial_if_name, (char *) r->r[2], 16); */
    for (i=0; i < fw.fw_ifcnt; i++)
    {
      if (strcmp((char *) r->r[2], &fw.fw_ifunit[i][0]) == 0)
      {
        dprintf(("serial", "\nMatched unit %s - restarting freeway\n\n", (char *) r->r[2]));
        fw_final();
        fw_prime();
        fw_real_init();
        break;
      }
    }
  }
  else
    return(fw_error(Err_FWSerNoInt));

  return(NULL);
}
/**********************************************************************/

/* EOF module.c */
@


4.12
log
@Have Freeway look after its own messages
Remove faulty logic for Service_MessageFileClosed, MessageTrans reopens the file, so no need to do it again locally.
Usual register/deregister/reregister code for ResourceFS.
Replace clumsy casts of (_kernel_oserror *)0 with NULLs.

Version 0.39. Tagged as 'Freeway-0_39'
@
text
@d31 1
d43 1
d52 1
a52 1

d175 1
a175 1
    (void) _swix(OS_Module, _IN(0)|_IN(2), 7, mem);
d256 1
a256 1
            for( i = 0; i < 6; i++ )
d314 1
a314 1
    char etheradr[6];
d533 1
a533 1
            dprintf(("module", "Seeing if this settup works.\n"));
d760 3
d764 1
d823 1
a823 1
    return(_kernel_oserror *) 0;
d1364 1
a1364 1
    if (startup_done || (swinum == 4) )
d1511 3
a1619 3

    dprintf(("module", "FWF> Closing messages\n"));
    release_msgs(msg_fd);
d1762 1
a1762 1
        if( r->r[2] == 0 )
d1784 1
a1784 1
            if (r->r[2] == 0)
d1801 1
a1801 1
            else if( r->r[2] == 1 )
d1862 1
a1862 1
        dprintf(("module", "CB> Calling reall initialisation.\n"));
@


4.11
log
@Internationalised non error strings
Freeway looked up its error messages via MessageTrans but for some reason used baked in english everywhere else.
* New function fw_lookup() looks up a token
* Removed Err_FWCAASyn since it had the wrong error number, and (using the Wimp as precedence) can just return configure_BAD_OPTION instead
* Lined up remote nets in *FwShow with remote objects
* Help and Syntax taken from messages file (requires RISC OS 3.60+)
* Other strings now looked up too

Tested with 1 printer, 1 disc, 1 host, 2 remote nets, and brief check of help.
Requires AUNMsgs-0_23.

Version 0.38. Tagged as 'Freeway-0_38'
@
text
@a696 2
    (void)init_msgs(MSG_FILE, msg_fd);

d738 4
d753 1
a753 1
        return (_kernel_oserror *)0;
d760 1
a760 1
    return (_kernel_oserror *)0;
d847 1
a847 1
        return((_kernel_oserror *)0);
d900 1
a900 1
    return((_kernel_oserror *)0);
d999 10
d1042 5
a1046 1
        }
d1461 1
a1461 1
    return((_kernel_oserror *)0);
d1736 4
a1739 2
      case Service_MessageFileClosed:
        (void)init_msgs(MSG_FILE, msg_fd);
d1741 1
a1741 1

@


4.10
log
@Makefile recreated from fragments
Usual drill
* Rename CMHG file to be the auto generated one
* Cast away some warnings
* Swap a few header files around, use defs from central headers where available
Also, add hdr/Freeway which in turn will be exported and end up in <swis.h>.

Participated in a ROM build, but not functionally tested.

Version 0.37. Tagged as 'Freeway-0_37'
@
text
@a66 6
static struct
{
    int  e_nbr;
    char e_string[252];
} ebuf = { 0 };

d86 1
a86 2
    { 0x809f0f, "FWSBadParam" },
    { 0x808f10, "FWCAASyn:Syntax: FreewayAutoAddress On|Off" },
d1034 23
d1062 1
a1063 1
    _kernel_oserror *e;
d1066 1
a1066 1
        return((_kernel_oserror *)0);
d1068 2
a1069 2
    ebuf.e_nbr = error_blocks[error].err_nbr;
    strcpy(ebuf.e_string, error_blocks[error].err_token);
d1074 1
a1074 2
    e = _kernel_swi(MessageTrans_ErrorLookup, &r, &r);
    return(e ? e : (_kernel_oserror *)&ebuf);
d1147 1
a1147 1
            return fw_error(Err_FWCAASyn);
d1162 1
a1162 1
                return fw_error(Err_FWCAASyn);
d1171 2
a1172 2
 * FWShow command. This lists all known access hosts and disks that
 * can be shared. -- Added in the definitions of DOMAIN_DISK and
a1190 2
     * printf("Interfaces found: %d\n\n",fw.fw_ifcnt);
     *
d1193 2
a1194 2
    if( fw.fw_netadrs == 0 )
        printf("No remote nets\n");
d1197 1
a1197 1
        printf("Net addresses:\n");
d1199 1
a1199 1
            printf("%s\n", inet_ntoa(q->q_bcast));
d1201 6
a1206 1
    printf("\n");
d1213 1
a1213 11
        /* if (f->fw_number == DOMAIN_DISK)
             printf("Type %d: (Discs)\n", DOMAIN_DISK);
        else if (f->fw_number == DOMAIN_HOST)
             printf("Type %d: (Hosts)\n", DOMAIN_HOST);
        else if (f->fw_number == DOMAIN_PRINTER)
             printf("Type %d: (Printers)\n", DOMAIN_PRINTER);
        else printf("Type %d:\n", f->fw_number);
        *
        * Old way of doing it... CE-27/11/96
        */
        printf("Type %d: ", f->fw_number);
d1215 1
a1215 1
          printf("(%s)\n",f->fw_name);
d1217 1
a1217 2
          printf("\n");

d1230 1
a1230 1
            printf("   %cName=%-10s Holder=%s\n",
d1232 5
a1236 1
                   rl->r_title, inet_ntoa(rl->r_ip));
d1309 1
a1309 1
        case DOMAIN_DISK: dprintf(("module", "disc ")); break;
d1492 1
a1492 1
void fw_final(void)
d1512 1
a1512 1
            case DOMAIN_DISK: dprintf(("module", "Discs..")); break;
@


4.9
log
@Changed auto assigned IP address to be a valid private one in
the 10.x.y.z range.

Version 0.36. Tagged as 'Freeway-0_36'
@
text
@d30 2
d47 1
a47 1
#include "FwHdr.h"
d135 1
a135 1
    (void) _swix(OS_Byte, _INR(0,1)|_OUT(2), ReadCMOS, SparrowMarker, &byte);
d142 1
a142 1
    (void) _swix(OS_Byte, _INR(0,1)|_OUT(2), ReadCMOS, SparrowMarker, &byte);
d149 1
a149 1
    (void) _swix(OS_Byte, _INR(0,2), WriteCMOS, SparrowMarker, byte);
d791 1
a791 1
     * Set up a claim on another event vector (Internet_Event)
d794 1
a794 1
     dprintf(("module", "OK.. Internet_Event..."));
d942 3
a944 3
    r.r[0] = Event_Enable;
    r.r[1] = Internet_Event;
    dprintf(("module", ":FEV: Enabling Internet_Events.."));
d963 1
a963 1
    dprintf(("module", "FWR> Releasing Internet_event (nenables = %d)...", nenables));
d965 1
a965 1
    r.r[0] = Event_Disable;
d969 1
a969 1
        r.r[1] = Internet_Event;
d1303 1
a1303 1
    dprintf(("module", "Name: %s, Address: %lx\n", rq->r_title , rq->r_ip.s_addr));
d1612 1
a1612 1
        inet_ntoa (from.sin_addr.s_addr)));
d1629 1
a1629 1
         r->r[0]==Internet_Event ? "Internet_Event" : "Other Event" ,
d1640 1
a1640 1
    if( r->r[0] == Internet_Event && r->r[1] == SocketIO )
@


4.8
log
@Fix from Kevin for keeping tabs on when the message file block is
valid (all those free()s added in 0.33 meant the RMA got shuffled
and when a message was required caused an abort in MessageTrans).
Added "date-string" to CMHG file.
More stringent checking on socket closing,in some circumstances with
LanManFS set to IP mode Freeway would try to reinit but gave up as
it found only one socket open - trouble is it was Freeway's fault for
only closing one of them.

Version 0.34. Tagged as 'Freeway-0_34'
@
text
@d517 5
a521 1
        sin->sin_addr = inet_makeaddr(1, (byte0 | byte1 << 8UL | byte2 << 16UL));
@


4.7
log
@Wasn't freeing the fw_types structures leading to a whopper memory leak
provoked by REPEAT:OSCLI"RMReinit Freeway":WAIT:WAIT:UNTIL 0.

Version 0.33. Tagged as 'Freeway-0_33'
@
text
@d53 1
a53 1
static _kernel_oserror *init_msgs(char *filename, char *fd);
d71 1
a71 1
static char msg_fd[16] = { 0 };
d291 1
a291 1
    (void)socketclose(s);
d430 1
a430 1
      sprintf(name, "%lx", sin->sin_addr.s_addr);
a740 1

d830 1
d863 2
a864 1
    if( fw.fw_ifcnt <= 0 || (fw.fw_rssock = do_getsock(FWPORT, 1)) < 0 )
d866 4
d873 1
d879 2
a880 1
    if( (fw.fw_rssock1 = do_getsock(FWPORT1, 1)) < 0 )
d882 1
d884 2
d889 1
d993 1
a993 1
_kernel_oserror *init_msgs(char *filename, char *fd)
d1011 1
a1011 1
    r.r[0] = (int)fd;
d1015 1
d1023 1
a1023 1
static void release_msgs(char *fd)
d1027 2
a1028 2
    if (fd!=(char *)0) {
        r.r[0] = (int)fd;
d1030 1
d1048 1
d1051 1
a1051 1
    r.r[1] = (int)msg_fd;
d1217 3
a1219 6
            if (rl->r_local)
                printf("   *Name=%-10s Holder=%s\n",
                       rl->r_title, inet_ntoa(rl->r_ip));
            else
                printf("    Name=%-10s Holder=%s\n",
                       rl->r_title, inet_ntoa(rl->r_ip));
a1481 3
    dprintf(("module", "FWF> In freeway finalisation. Closing down: Messages.."));

    release_msgs(msg_fd);
d1483 1
a1483 1
    for( f = fw.fw_types; f != 0; f = f->fw_next )
a1502 4
    }

    for(f = fw.fw_types; f != 0; f = fnext)
       {
d1504 1
d1509 2
a1510 2
          if (oq->r_title) free(oq->r_title);
          if (oq->r_desc)  free(oq->r_desc);
d1517 2
a1518 2
          if (oq->r_title) free(oq->r_title);
          if (oq->r_desc)  free(oq->r_desc);
d1528 1
a1528 1
       }
d1546 1
a1546 1
       
d1570 1
a1570 5
    /*
     * 950308 KWelton
     *
     * free the structures malloc'ed by read_ifs()
     */
d1573 1
a1573 1
    for( q = fw.fw_netadrs; q; q = qnext )
d1576 1
a1576 1
        (void)free(q);
d1578 3
@


4.6
log
@Changed tab to a space and capitalised on and off to On and Off.
Fixes report that "Freewayautoaddress" status is garbled in a task
window.

Version 0.32. Tagged as 'Freeway-0_32'
@
text
@d297 1
a297 1
 * all know ether drivers and see what if any are suitable for freeway
d432 1
a432 1
        dprintf(("module", "Storing interface info.\n"));
d1466 1
a1466 1
    struct fwtype *f;
d1468 2
d1497 28
d1541 1
a1541 1

@


4.5
log
@  - Added command to add a remote subnet.

Detail:
  Freeway will interrogate an AUN server to discover subnets on which it
should broadcast.  However there was no other way to explicitly add another
subnet on which freeway should broadcast.

  The new *command FWAddnet will do this.  This allows ShareFS to talk to a
RISC OS machine on a different subet, e.g. between an STB and a RiscPC on the
engineering and house networks.  If the intervening router doesn't allow
directed broadcasts (as is quite often the case), you can specify a specific
host on the other network.

Admin:
  Tested on a DSL4000 and RiscPC on the house and engineering networks.


Version 0.31. Tagged as 'Freeway-0_31'
@
text
@d91 1
a91 1
    { 0x808f10, "FWCAASyn:Syntax: FreewayAutoAddress on|off" },
d1083 1
a1083 1
    _swix(OS_Write0, _IN(0), "FreewayAutoAddress\t");
d1096 1
a1096 1
        fw_conf_syntax(auto_address_cmos_read() ? "on" : "off");
@


4.4
log
@  Much tidying up, and support for new CMOS bit to prevent Freeway setting
    default addresses on interfaces.
Detail:
  Removed obsolete source files and headers.
  CMHG file pulls in details from global header files and VersionNum.
  CMHG uses proper veneers for functions and generates the header file
    for module.c to relieve it from having to mis-declare the veneer
    functions.
  Debugging is now entirely DebugLib based.
  Fixed short buffer which would cause the machine to die with aborts
    if an error message was just a bit too long for it.
Admin:
  Requires HdrSrc-0_28 or later.
  Tested in Ursula ROM build.

Version 0.29. Tagged as 'Freeway-0_29'
@
text
@d91 1
a91 1
    { 0x808f10, "FWCAASyn:Syntax: FreewayAutoAddress On|Off" },
d110 1
d207 1
a207 1
    if( (e = _kernel_swi(XOS_Bit | OS_ServiceCall, &r, &r)) != NULL )
d555 1
a555 1
        e = _kernel_swi(XOS_Bit | Econet_EnumerateMap,&r, &r);
d648 1
a648 1
    return(_kernel_swi(XOS_Bit | OS_AddCallBack, &r, &r) != 0 ? -1 : 0);
d659 1
a659 1
    (void)_kernel_swi(XOS_Bit | OS_RemoveCallBack, &r, &r);
d907 1
a907 1
    return(_kernel_swi(XOS_Bit | OS_Claim, &r, &r));
d929 1
a929 1
    if( (e = _kernel_swi(XOS_Bit | OS_Byte, &r, &r)) == NULL )
d975 1
a975 1
    (void)_kernel_swi(XOS_Bit | OS_Release, &r, &r);
d992 1
a992 1
    e = _kernel_swi(XOS_Bit | MessageTrans_FileInfo, &r, &r);
d1003 1
a1003 1
    e = _kernel_swi(XOS_Bit | MessageTrans_OpenFile, &r, &r);
d1017 1
a1017 1
        (void)_kernel_swi(XOS_Bit | MessageTrans_CloseFile, &r, &r);
d1038 1
a1038 1
    e = _kernel_swi(XOS_Bit | MessageTrans_ErrorLookup, &r, &r);
d1065 3
d1218 37
d1263 1
a1263 1
    (void) _kernel_swi(XOS_Bit | OS_ServiceCall, &r, &r);
d1296 1
a1296 1
    (void)_kernel_swi(XOS_Bit | OS_UpCall, &r, &r);
d1413 1
a1413 1
    e = _kernel_swi(XOS_Bit | OS_Claim, &r, &r);
d1429 1
a1429 1
    (void)_kernel_swi(XOS_Bit | OS_Release, &r, &r);
d1571 2
a1572 1
       dprintf(("rpi", "RPI: read %d bytes from %lx\n", r, from.sin_addr.s_addr));
@


4.3
log
@Unfortunately, this logs changes that were made some time ago.

Added facility for clients to register a descriptive string for a type.
(Printers are still special cased, since I've not modified the client code).
Added support for use of a single point to point interface.

Removed local copies of standard library functions, and linked against
library instead.
@
text
@d15 2
a16 141
/* -*-C-*-
 *
 * $Header: /ax/networking:Starling/Freeway/module.c:networking  1.20  $
 * $Source: /ax/networking:Starling/Freeway/module.c: $
 *
 * Copyright (c) 1995 Acorn Computers Ltd., Cambridge, England
 *
 * 96/12/02 - CE
 * Added :	revised interface detection ; less optimised, but
 *		should be more general purpose.
 *		new SWI 'FreewaySerial' for serial support.
 * 96/11/27 - CE
 * Added :	support for clients registering a name for types
 *
 *
 * $Log:	module.c,v $
 *
 * Revision 1.21  96/04/07  09:52:15  kbracey
 * Fix to ignore address families other than AF_INET in read_ifs(), as the
 * 4.4BSD Internet module gives each interface an AF_LINK address.
 *
 * Revision 1.20  95/03/31  11:04:15  kwelton
 * Two main changes:
 *
 * 1)  When Paul fixed my inappropriate use of splimp() and splx(), he used
 *     ensure_irqs_on() to replace splimp(); it should have been
 *     ensure_irqs_off().
 *
 * 2)  All pending callbacks are removed during module finalisation.
 *
 * Revision 1.19  95/03/30  16:22:50  pwain
 * Changed some splimp() and splx() calls tp
 * ensure_irqs_on and restore_irqs
 *
 * Revision 1.18  95/03/30  16:14:12  kwelton
 * Three significant changes:
 *
 * 1)  Error token FWONex should be FWONEx (tokens are case significant)
 *
 * 2)  Socket descriptors in struct fw should be initialised to -1, this
 *     stops them being erroneously closed in fw_final().
 *
 * 3)  Internet Event enables are counted - this is some perfectly healthy
 *     paranoia to prevent disabling events that haven't been enabled.
 *
 * Revision 1.17  95/03/30  15:25:26  pwain
 * Added stacks of debug (more meaningful) for
 * Black Rom problem solving.
 *
 * Revision 1.16  95/03/30  09:30:38  kwelton
 * fw_final() resets socket descriptors to an invalid number after calling
 * socketclose().
 *
 * Revision 1.15  95/03/22  15:48:27  kwelton
 * Argh!  Went through the previous changes with Paul, spotted a small
 * piece of redundant code, and forgot to save my emacs session before
 * checking the new version in.
 *
 * Revision 1.14  95/03/22  15:42:15  kwelton
 * read_ifs() was not ignoring unwanted interfaces (e.g. Slip) when
 * looking for an interface to set an address on.  This has been
 * fixed by a fairly hefty rewrite of read_device_name().
 *
 * Revision 1.13  95/03/19  17:58:36  kwelton
 * A number of changes:
 *
 * 1)  The internet module now issues a service call (Service_InternetStatus)
 *     every time an SIOCSIFFADDR ioctl() is raised.  This is caught and,
 *     provided it was not this module that made the ioctl() call, the
 *     module is restarted which is the easiest way of coping with the
 *     changed Internet address.
 *
 * 2)  Notice is now taken of the service call issued when the internet
 *     module finalises - this module shuts itself down as well.
 *
 * 3)  The message file is reinitialised when a Service_MessageFileClosed
 *     is issued.
 *
 * 4)  Service_DCIDriverStatus is checked to see whether the driver is
 *     initialising, or finalising.
 *
 * 5)  Some of the functionality of fw_init() has been moved into a
 *     separate function (fw_prime()) for use when the module is about
 *     to be restarted.
 *
 * Revision 1.12  95/03/10  18:06:06  kwelton
 * Found and plugged a significant number of memory leaks; added range
 * checking on SWI numbers.
 *
 * Revision 1.11  95/03/07  20:53:10  kwelton
 * Main change is a bugfix in fw_service() where protocol startup messages
 * from the internet module are ignored if the module has already fully
 * initialised.
 *
 * Also fixed a minor bug (CSD-190207) where *fwshow was producing an
 * inappropriate message; this message has also been internationalised.
 *
 * Revision 1.10  95/03/05  16:04:00  kwelton
 * Tidied up scope and declarations of both functions and
 * variables; the module now compiles cleanly with -ffah.
 *
 * Revision 1.9  95/03/01  09:08:28  pwain
 * Fixed a typo. Added Domain disks
 *
 * Revision 1.8  95/02/16  15:36:43  pwain
 * Added SWI "Freeway_Status". With the reson code 0 in R0 this will
 * return 1 if Freeway is running and accepting SWIs or 0 if it is
 * dormant in R1.
 *
 * Revision 1.7  95/02/15  14:14:58  pwain
 * Fixed bug in SWI handler which caused Freeway to data abort
 * when the Internet module was not fully initilised. Basically
 * it was trying to pass back a local pointer to the global
 * environment.
 *
 * Revision 1.6  95/02/02  08:57:57  pwain
 * Changed pickup point for DCI structures from module.h
 * to "sys/dcistructs.h".
 *
 * Revision 1.5  95/02/01  19:05:05  pwain
 * Changed function names of callback routines that deal with
 * additional drivers coming on line.
 *
 * Revision 1.4  95/02/01  17:57:40  pwain
 * Fixed random-ish generation of IP numbers (reworked
 * read_device_name() and read_ifs). Now uses last 2
 * digits of ether address and last letter of name.
 *
 * Revision 1.3  95/02/01  15:23:07  pwain
 * Added in more debug Printf()s.
 * Changed the way the internet module is 1st checked for to use a searc
 * on its name. (OS Module 18 call)
 *
 * Revision 1.2  95/01/26  09:42:12  pwain
 * Added in support for loading from system ROM (unordered startup)
 * Debugging of startup using TML cards (CFLAGS = -DDEBUG)
 * General code tidy up to change DCI2-isms to DCI4
 * Tidy of module header (correct declaration of exit routines)
 *
 * Revision 1.1  95/01/03  18:57:14  kwelton
 * Initial revision
d18 1
d25 6
a37 2


d41 3
a43 2
#include "kernel.h"
#include "swis.h"
d45 1
a45 2
#include "module.h"
#include "stubs.h"
d47 1
a47 1
void fw_final(void);
d67 2
a68 2
    int	 e_nbr;
    char e_string[36];
d73 1
a73 1
static struct eblk error_blocks[20] = {
d91 1
a93 5
#ifdef OldCode
static u_long auto_adr = 0;
#endif

#define MAXSWI 7
d97 1
a97 1
    _kernel_oserror *(*swi_call)();	    /* swi handler */
d100 1
a100 1
static struct swient fw_ent[MAXSWI] = {
a106 6
    0,
};

struct client
{
    int (*cli_call)();	    /* cli handler */
d109 2
a110 1
#define MAXCLIENT 2
d112 1
a112 8
static void fw_show(char *a, int b);

static struct client fw_cli_call[2] = {
    (int (*)())fw_show,
    0,
};

static _kernel_oserror *calleverytick(int (*fun)()), *fw_claimv(void);
d126 23
a155 1
    _kernel_swi_regs r;
d162 1
a162 1
	sprintf(varname, "%s", "Inet$LocalAddr");
d164 1
a164 1
	sprintf(varname, "%s%d", "Inet$LocalAddr", ifcnt);
d166 2
a167 10
#ifdef DEBUG
    Printf("Setting \"%s\" to \"%s\"\n", varname, adr);
#endif /* DEBUG */

    r.r[0] = (int)varname;
    r.r[1] = (int)adr;
    r.r[2] = strlen(adr)+1;
    r.r[3] = 0;
    r.r[4] = 0;
    (void)_kernel_swi(XOS_Bit | OS_SetVarVal, &r, &r);
d177 1
a177 5
    _kernel_swi_regs r;

    r.r[0] = 7;
    r.r[2] = (int)mem;
    (void)_kernel_swi(XOS_Bit | OS_Module, &r, &r);
d195 2
a201 3
#ifdef DEBUG
    Printf("RD> Reading device information\n");
#endif
d207 1
a207 1
	return;
d210 1
a210 1
	return;
d215 2
a216 2
    if( (s = socket(AF_INET, SOCK_DGRAM, 0)) < 0 )
	return;
d236 27
a262 7
#ifdef DEBUG
	Printf("RD> Reading %s's ether address\n", buf);
	/*
	Printf("RD> Address is %s\n",
	       ether_sprintf(chd->chd_dib->dib_address));
	*/
#endif
d264 7
a270 29
	sprintf(ifreq.ifr_name, "%.*s%d",
		sizeof(ifreq.ifr_name) - 2,
		chd->chd_dib->dib_name, chd->chd_dib->dib_unit);

	/*
	 * check that Internet knows about this interface and
	 * that the interface features are acceptable.
	 */
	if( (socketioctl(s, SIOCGIFFLAGS, (caddr_t)&ifreq) == 0 &&
	     (ifreq.ifr_flags & IFF_BROADCAST) &&
	     !(ifreq.ifr_flags & IFF_NOARP)) )
	{
	    int i;

	    strcpy(buf, ifreq.ifr_name);

	    for( i = 0; i < 6; i++ )
		etheradr[i] = chd->chd_dib->dib_address[i];

	    break;
	}

	/*
	 * this interface is no good, free it here and now
	 * and try the next one.
	 */
	chdnext = chd->chd_next;
	rmafree(chd);
	chd = chdnext;
d282 3
a284 3
	chdnext = chd->chd_next;
	rmafree(chd);
	chd = chdnext;
a314 1
    u_long last_bcast;
d318 1
a318 1
    u_char byte0, byte1, byte2;
d322 3
a324 3
    fw.fw_ifcnt = 0;	/* Reset count of interfaces, since we're about to
    			 * re-enumerate them
    			 */
d331 1
a331 3
    #ifdef DEBUG
      Printf("IC> Opening socket....");
    #endif
d335 1
a335 3
    #ifdef DEBUG
      Printf("Failed - aborting\n");
    #endif
d339 1
a339 3
    #ifdef DEBUG
      Printf("Succeeded (temp socket=%d)\n",s);
    #endif/* DEBUG */
d350 1
a350 3
    #ifdef DEBUG
      Printf("IC> Reading Interface(s) config (SIOCGIFCONF)...");
    #endif
d354 1
a354 3
      #ifdef DEBUG
	Printf("Failed - aborting\n");
      #endif
d359 1
a359 3
    #ifdef DEBUG
      Printf("Succeeded\n");
    #endif/* DEBUG */
d371 1
a371 3
      #ifdef DEBUG
	Printf("IC> Skipped all known interfaces - aborting\n");
      #endif
d382 1
a382 3
       #ifdef DEBUG
 	Printf("IC> Evaluating found interface: (%s) :",ifreq.ifr_name);
       #endif
d390 1
a390 3
         #ifdef DEBUG
           Printf("not an AF_INET address - skipping\n");
         #endif
d399 2
a400 4
         #ifdef DEBUG
	    Printf("loopback device - skipping\n");
         #endif
	  continue;
d413 2
a414 4
	  #ifdef DEBUG
	    Printf("cant get interface address - skipping\n");
	  #endif
	  continue;
d426 1
a426 3
        #ifdef DEBUG
          Printf("setting local_adr=%x...", local_adr);
        #endif
d431 1
a431 3
      #ifdef DEBUG
        Printf("Storing interface info.\n");
      #endif
d443 13
a455 15
	 {
	   #ifdef DEBUG
	     Printf("Cant get broadcast address - unsetting local_addr\n");
	   #endif
	   local_adr = 0;
	   fw.fw_ifbcast[(fw.fw_ifcnt)] = INADDR_NONE;
	 }
	 else
	 {
	   /*
	    * Keep account of this card since it meets the requirements.
	    */
	   sin = (struct sockaddr_in *)&ifreq.ifr_broadaddr;
	   fw.fw_ifbcast[(fw.fw_ifcnt)] = sin->sin_addr.s_addr;
	 }
d462 20
a481 24
      	  #ifdef DEBUG
      	    Printf("Serial support not requested - unsetting local_addr\n");
      	  #endif
      	  local_adr = 0;
      	  fw.fw_ifbcast[(fw.fw_ifcnt)] = INADDR_NONE;
      	}
      	else
      	if (socketioctl(s,SIOCGIFDSTADDR, (char *)&ifreq) < 0)
      	{
      	  #ifdef DEBUG
      	    Printf("Unable to get destination address - unsetting local_addr\n");
      	  #endif
      	  local_adr = 0;
      	  fw.fw_ifbcast[(fw.fw_ifcnt)] = INADDR_NONE;
      	}
      	else
      	{
      	  /*
      	   * Keep account of this card since it meets the requirements, and
      	   * we're requested to use this serial interface.
      	   */
      	  sin = (struct sockaddr_in *)&ifreq.ifr_dstaddr;
      	  fw.fw_ifbcast[(fw.fw_ifcnt)] = sin->sin_addr.s_addr;
      	}
d485 2
a486 4
        #ifdef DEBUG
      	  Printf("Interface is marked down - clearing broadaddr\n");
      	#endif
      	fw.fw_ifbcast[(fw.fw_ifcnt)] = INADDR_NONE;
d495 1
a495 1
    if (fw.fw_ifcnt == 0 && !retried)
d497 1
a497 3
      #ifdef DEBUG
	Printf("IC> No usable devices found. Trying to make up an address\n");
      #endif
d501 1
a501 3
      #ifdef DEBUG
	Printf("IC> Try using name: %s...",name);
      #endif
d508 24
a531 30
        #ifdef DEBUG
	   Printf("Making up ether address...");
        #endif
	byte0 = (u_char)etheradr[5];
	byte1 = (u_char)etheradr[4];
	byte2 = (u_char)name[1];
        #ifdef DEBUG
	  Printf("Address derived from: %d %d %d...", byte0, byte1, byte2);
        #endif
	sin = (struct sockaddr_in *)&ifreq.ifr_addr;

	/* next line modified 25/7/94 gw */
	sin->sin_addr = inet_makeaddr(1, (byte0 | byte1 << 8 | byte2 << 16));
	sin->sin_family = AF_INET;

	strncpy(ifreq.ifr_name, name, sizeof(ifreq.ifr_name));

	irqstatus = ensure_irqs_off();
	++setting_address;
	restore_irqs(irqstatus);
	retc = socketioctl(s, SIOCSIFADDR, (caddr_t)&ifreq);
	irqstatus = ensure_irqs_off();
	--setting_address;
	restore_irqs(irqstatus);

	if( retc >= 0 )
	{
          #ifdef DEBUG
	    Printf("Seeing if this settup works.\n");
          #endif
d534 2
a535 4
	}
        #ifdef DEBUG
	  Printf("Unable to setup address.\n");
        #endif
d549 1
a549 3
      #ifdef DEBUG
	Printf("IC> Found valid interface. Looking at Econet_EnumerateMap:");
      #endif/* DEBUG */
d555 5
a559 9
        #ifdef DEBUG
	  Printf("r4 = %d",r.r[4]);
        #endif/* DEBUG */
	if (e || r.r[4] == -1)
	{
        #ifdef DEBUG
	  Printf("\n");
        #endif/* DEBUG */
	break;
d563 3
a565 5
	if (!q)
	{
          #ifdef DEBUG
            Printf("No more Found\n");
          #endif/* DEBUG */
d570 2
a571 4
      	#ifdef DEBUG
      	  Printf("Found: %s, adding. ",r.r[3]);
      	#endif/* DEBUG */
      	q->q_bcast.s_addr = ipadr | 0xffff0000;
d580 1
a580 3
    #ifdef DEBUG
      Printf("IC> Done\n");
    #endif/* DEBUG */
d583 1
a583 3
    #ifdef DEBUG
      Printf("IC> fw struct at %x\n",&fw);
    #endif
d595 4
a598 8
#ifdef DEBUG
	Printf("DGS> Failed to open a socket - aborting\n");
#endif/* DEBUG */
	return (-1);
	}
#ifdef DEBUG
    Printf("DGS> Opened socket %d - ", sock);
#endif/* DEBUG */
d603 5
a607 9
#ifdef DEBUG
	Printf("Cannot set FIONBIO and/or FIOASYNC.. Aborting\n");
#endif/* DEBUG */
	socketclose (sock);
	return (-1);
    }
#ifdef DEBUG
    Printf("FIONBIO..FIOASYNC..");
#endif/* DEBUG */
d612 5
a616 9
#ifdef DEBUG
	Printf("Unable to toggle SO_BROADCAST.. Aborting\n");
#endif/* DEBUG */
	socketclose(sock);
	return (-1);
    }
#ifdef DEBUG
    Printf("SO_BROADCAST..");
#endif/* DEBUG */
d621 14
a634 20
	addr.sin_family	     = AF_INET;
	addr.sin_addr.s_addr = htonl(INADDR_ANY);
	addr.sin_port	     = htons((u_short)port);
#ifdef DEBUG
        Printf("Input socket, binding to %d..", port);
#endif/* DEBUG */

	if( bind(sock, (struct sockaddr *)&addr, sizeof (addr)) < 0 )
	{
#ifdef DEBUG
	    Printf("Bind failed - aborting\n");
#endif/* DEBUG */
	    socketclose(sock);
	    return (-1);
	}
    }

#ifdef DEBUG
    Printf("Bound.\n");
#endif/* DEBUG */
d672 1
a672 3
#ifdef DEBUG
    Printf("SCB> setcallback (flag = %d)", callbackflag);
#endif/* DEBUG */
d676 1
a676 1
	callbackflag = 1;
d678 4
a681 6
	if( callback(callb_entry) != 0 ) {
#ifdef DEBUG
	    Printf("Failed\n");
#endif/* DEBUG */
	    callbackflag = 0;
	}
d684 1
a684 3
#ifdef DEBUG
    Printf("Ok!\n");
#endif/* DEBUG */
d695 1
a695 3
#ifdef DEBUG
    Printf("FWP> In Freeway Prime\n");
#endif/* DEBUG */
d723 1
a723 1
_kernel_oserror *fw_init(char *cmd_tail, int pbase, void *pw)
d729 11
a739 2
    cmd_tail = cmd_tail;
    pbase = pbase;
d747 1
a747 3
#ifdef DEBUG
    Printf("IN> Attempting to find the Internet module\n");
#endif
d751 1
a751 3
#ifdef DEBUG
	Printf("IN> Returning Internet not found\n");
#endif
d757 1
a757 1
	return (e);
d772 1
a772 3
#ifdef DEBUG
    Printf("FWE> Looking to claim: EventV...");
#endif/* DEBUG */
d778 1
a778 3
#ifdef DEBUG
	Printf("Failed.\n");
#endif/* DEBUG */
d780 2
a781 2
	fw_final();
	return(e);
d788 1
a788 3
#ifdef DEBUG
     Printf("OK.. Internet_Event...");
#endif/* DEBUG */
d794 1
a794 4
#ifdef DEBUG
        Printf("Failed.\n");
#endif/* DEBUG */

d803 1
a803 3
#ifdef DEBUG
    Printf("OK.. TickerV...");
#endif/* DEBUG */
d809 1
a809 3
#ifdef DEBUG
        Printf("Failed\n");
#endif/* DEBUG */
d815 1
a815 3
#ifdef DEBUG
    Printf("Ok.\n");
#endif/* DEBUG */
d836 1
a836 3
#ifdef DEBUG
    Printf("RI> Doing interface count\n");
#endif
d841 5
a845 5
	/*
	 * Internet has started, but no device drivers are present so
	 * we should wait until some are.
	 */
	return((_kernel_oserror *)0);
d851 1
a851 3
#ifdef DEBUG
    Printf("RI> Setting up event handlers\n");
#endif
d855 1
a855 1
	goto out;
d864 2
a865 2
	e = fw_error(Err_FWNNet);
	goto out;
d867 1
a867 3
#ifdef DEBUG
    Printf("RI> Opened Socket (Unauth socket) - %d\n", fw.fw_rssock);
#endif/* DEBUG */
d874 5
a878 7
	socketclose(fw.fw_rssock);
	e = fw_error(Err_FWNNet);
	goto out;
    }
#ifdef DEBUG
    Printf("RI> Opened Socket1 (Auth Socket) - %d\n", fw.fw_rssock1);
#endif/* DEBUG */
d883 1
a883 3
#ifdef DEBUG
    Printf("RI> Initialisation succeded\n");
#endif
d890 1
a890 3
#ifdef DEBUG
    Printf("RI> Initialisation failed\n");
#endif
d905 1
a905 3
#ifdef DEBUG
    Printf(":FWC: Claiming EventV..");
#endif/* DEBUG */
d926 1
a926 3
#ifdef DEBUG
    Printf(":FEV: Enabling Internet_Events..");
#endif/* DEBUG */
d930 3
a932 3
	int s = ensure_irqs_off();
	++nenables;
	restore_irqs(s);
d945 1
a945 3
#ifdef DEBUG
    Printf("FWR> Releasing Internet_event (nenables = %d)...", nenables);
#endif/* DEBUG */
d951 1
a951 1
	r.r[1] = Internet_Event;
d953 17
a969 19
	if( _kernel_swi(OS_Byte, &r, &r) == NULL )
	{
	    int s = ensure_irqs_off();
	    --nenables;
	    restore_irqs(s);
	}
	else
	{
	    /*
	     * make the best of a very bad job
	     */
	    nenables = 0;
	    continue;				/* XXX */
	}
    }

#ifdef DEBUG
    Printf("EventV\n");
#endif/* DEBUG */
d993 1
a993 1
	return (e);
d1017 1
a1017 1
	}
d1030 1
a1030 1
	return((_kernel_oserror *)0);
d1042 1
a1042 1
 * Command line interface handler... just *fwshow
d1046 2
a1047 2
_kernel_oserror *fw_cli_handler(char *arg_string, int arg_count,
				int cmd_no, void *pw)
a1048 1
    struct client *callp;
d1052 35
a1086 1
    pw = pw;
d1088 38
a1125 4
    if (startup_done)
    {
        callp = &fw_cli_call[cmd_no];
        (*(callp->cli_call))(arg_string, arg_count);
a1126 2
    else
	error = fw_error(Err_FWNoInet);
d1128 1
a1128 1
    return(error);
d1141 1
a1141 1
static void fw_show(char *a, int b)
d1148 2
a1149 2
    a = a;
    b = b;
d1157 1
a1157 1
	printf("No remote nets\n");
d1160 3
a1162 3
	printf("Net addresses:\n");
	for( q = fw.fw_netadrs; q; q = q->q_next )
	    printf("%s\n", inet_ntoa(q->q_bcast));
d1171 16
a1186 35
	/* if (f->fw_number == DOMAIN_DISK)
	     printf("Type %d: (Discs)\n", DOMAIN_DISK);
	else if (f->fw_number == DOMAIN_HOST)
	     printf("Type %d: (Hosts)\n", DOMAIN_HOST);
	else if (f->fw_number == DOMAIN_PRINTER)
	     printf("Type %d: (Printers)\n", DOMAIN_PRINTER);
	else printf("Type %d:\n", f->fw_number);
	*
	* Old way of doing it... CE-27/11/96
	*/
	printf("Type %d: ", f->fw_number);
	if (f->fw_name[0])
	  printf("(%s)\n",f->fw_name);
	else
	  printf("\n");


	for (rl = f->fw_remobj; rl; rl = rl->r_next)
	{
	    /*
	     * If this entry isnt in use ignore it.
	     */
	    if (!rl->r_inuse)
		continue;

	    /*
	     * Show entry. Local ones are prefixed with a "*"
	     */
	    if (rl->r_local)
		printf("   *Name=%-10s Holder=%s\n",
		       rl->r_title, inet_ntoa(rl->r_ip));
	    else
		printf("    Name=%-10s Holder=%s\n",
		       rl->r_title, inet_ntoa(rl->r_ip));
	}
d1188 21
a1208 2
	if (f->fw_next)
	    printf("\n");
d1210 2
d1220 1
a1220 3
#ifdef DEBUG
    Printf("FSC> Sending service call: %x\n",sc);
#endif
d1231 1
a1231 1
#ifdef DEBUG
d1233 6
a1238 6
	case FW_ADDED: Printf("FWU> Upcall: added "); break;
	case FW_REMOVED: Printf("FWU> Upcall: removed "); break;
	case FW_CHANGED: Printf("FWU> Upcall: changed "); break;
	case FW_DELETED: Printf("FWU> Upcall: deleted "); break;
	default: Printf("FWU> Upcall: operation: %d ",upc); break;
	}
d1240 7
a1246 7
	case DOMAIN_DISK: Printf("disc "); break;
	case DOMAIN_HOST: Printf("host "); break;
	case DOMAIN_PRINTER: Printf("printer "); break;
	default: Printf("type=%d",type); break;
	}
    Printf("Name: %s, Address: %x\n", rq->r_title , rq->r_ip.s_addr);
#endif/* DEBUG */
d1271 1
a1271 1
	return(fw_error(Err_FWInvalSWI));
d1278 11
a1288 11
#ifdef DEBUG
	switch(swinum) {
	    case 0: Printf("FWS> Handling SWI: Freeway_Register\n"); break;
	    case 1: Printf("FWS> Handling SWI: Freeway_Write\n"); break;
	    case 2: Printf("FWS> Handling SWI: Freeway_Read\n"); break;
	    case 3: Printf("FWS> Handling SWI: Freeway_Enumerate\n"); break;
	    case 4: Printf("FWS> Handling SWI: Freeway_Status\n"); break;
	    case 5: Printf("FWS> handling SWI: Freeway_Serial\n"); break;
	    default: Printf("FWS> Handling SWI: %d\n", swinum); break;
	    }
#endif
d1309 2
a1310 2
	if( f->fw_number == type )
	    return(f);
d1322 1
a1322 1
	return(type);
d1329 1
a1329 1
int callb_handler(void)
d1331 3
a1333 3
#ifdef DEBUG
    Printf("CBH> In callback handler: ");
#endif/* DEBUG */
d1336 3
a1338 5
#ifdef DEBUG
        Printf("No callbacks to do - aborting\n");
#endif/* DEBUG */
	return (1);
	}
d1344 3
a1346 5
	dostart = 0;
#ifdef DEBUG
	Printf("Send FreewayStarting service call..\n");
#endif
	fw_servicecall(Service_FreewayStarting);
d1351 1
a1351 3
#ifdef DEBUG
        Printf("Calling do_objects_on_callback.\n");
#endif/* DEBUG */
d1353 2
a1354 2
	doobjects = 0;
	do_objects_on_callback();
d1357 1
a1357 3
#ifdef DEBUG
    Printf("\n");
#endif/* DEBUG */
d1359 1
a1359 1
    return (1);
d1364 1
a1364 1
static _kernel_oserror *calleverytick(int (*fun)())
d1374 1
a1374 1
	return (e);
d1381 1
a1381 1
static void removetickerevent(int (*fun)())
d1393 1
a1393 1
int tick_handler(void)
d1400 1
a1400 3
#ifdef DEBUG
    Printf("FTH> In tickerV handler. Checking all objects.\n");
#endif
d1403 2
d1407 1
a1407 1
	check_objects(f);
d1409 1
a1409 1
    return (1);
d1414 9
d1428 1
a1428 3
#ifdef DEBUG
    Printf("FWF> In freeway finalisation. Closing down: Messages..");
#endif/* DEBUG */
d1435 1
a1435 1
	do_protocol(f, INADDR_BROADCAST, 0, REMOVE);
d1437 14
a1450 14
	/*
	 * XXX - the wrong number of parameters are passed
	 * in the version above: make a *guess* at passing
	 * it the correct values.
	 */
#ifdef DEBUG
	switch(f->fw_number) {
	    case DOMAIN_DISK: Printf("Discs.."); break;
	    case DOMAIN_PRINTER: Printf("Printers.."); break;
	    case DOMAIN_HOST: Printf("Hosts.."); break;
	    default: Printf("type: %d.."); break;
	    }
#endif /* DEBUG */
	do_protocol(f, INADDR_BROADCAST, 0, REMOVE, 0, 0, 1);
d1454 1
a1454 3
#ifdef DEBUG
    Printf("Events...\n");
#endif/* DEBUG */
d1459 3
a1461 5
#ifdef DEBUG
        Printf("FWF> Closing: Socket..");
#endif/* DEBUG */
	socketclose(fw.fw_rssock);
	fw.fw_rssock = -1;
d1466 3
a1468 5
#ifdef DEBUG
        Printf("Socket1..");
#endif/* DEBUG */
	socketclose(fw.fw_rssock1);
	fw.fw_rssock1 = -1;
d1471 1
a1471 3
#ifdef DEBUG
    Printf("Ticker events..");
#endif/* DEBUG */
d1474 1
a1474 3
#ifdef DEBUG
    Printf("Sending termination call\n");
#endif/* DEBUG */
d1484 2
a1485 2
	clear_callback(callb_entry);
	callbackflag = 0;
d1490 2
a1491 2
	clear_callback(readdevice_entry);
	readdevice_callback = 0;
d1499 1
a1499 3
#ifdef DEBUG
    Printf("FWF> Freeing memory\n");
#endif/* DEBUG */
d1503 2
a1504 2
	qnext = q->q_next;
	(void)free(q);
d1516 1
a1516 4
#ifdef DEBUGRPI
    Printf("RPI> Reading network activity (%s):-\n", format == 0 ? "unauth" :
		"auth");
#endif/* DEBUG */
d1520 15
a1534 19
	fromlen = sizeof (from);
	r = recvfrom(format == 0 ? fw.fw_rssock : fw.fw_rssock1,
		     inbuf, sizeof(inbuf), 0,
		     (struct sockaddr *)(&from), &fromlen);

	if( r < 0 || fromlen != sizeof(struct sockaddr_in) ) {
#ifdef DEBUGRPI
	    Printf("RPI: read failed. r=%d, errno=%d\n", r, errno);
#endif/* DEBUG */
	    break;
	    }

#ifdef DEBUGRPI
       Printf("RPI: read %d bytes from %x\n", r, from.sin_addr.s_addr);
#endif/* DEBUG */

	if( !is_from_us(from.sin_addr.s_addr) )
	    process_message(from.sin_addr.s_addr, (struct rs_msg *)inbuf,
			    r, format);
d1540 1
a1540 1
int fw_event_handler(int *r)
d1544 29
a1572 31
#ifdef DEBUGEVENT
    Printf("FEH> r0=%s r1=%s ",
   	 r[0]==Internet_Event ? "Internet_Event" : "Other Event" ,
	 r[1]==SocketIO ? "SIGIO" : "SIGOther");

    if (r[2]==fw.fw_rssock) {
	Printf("r2=Socket(unauth) ");
	}
    else if (r[2]==fw.fw_rssock1) {
	Printf("r2=Socket1(auth) ");
	}
    else Printf("r2=%d ",r[2]);
#endif/* DEBUG */

    if( r[0] == Internet_Event && r[1] == SocketIO )
    {
	if( r[2] == fw.fw_rssock )
	    format = 0;
	else if( r[2] == fw.fw_rssock1 )
	    format = 1;
	else
	    return (1);

#ifdef DEBUGEVENT
	Printf("Format=%s\n", format==0 ? "Unauth" : "Auth");
#endif/* DEBUG */

	s = ensure_irqs_on();
	rs_process_input(format);
	restore_irqs(s);
	return(0);
d1585 2
a1586 2
	if( fw.fw_ifaddrs[i] == src )
	    return (1);
a1597 1
    _kernel_swi_regs r;
d1600 2
a1601 6
#ifdef DEBUG
    Printf("IP>> Looking for module: %s\n", protocol_name);
#endif
    r.r[0] = 18;
    r.r[1] = (int)protocol_name;
    err = _kernel_swi(XOS_Bit | OS_Module, &r, &r);
d1605 2
a1606 4
#ifdef DEBUG
	Printf("IP>> Found Internet module!\n");
#endif
	return 1;
d1609 2
a1610 4
#ifdef DEBUG
    Printf("IP>> Found error : %s\n",err->errmess);
    Printf("IP>> Found error : %x\n",err->errnum);
#endif
d1628 2
a1629 2
	(void)init_msgs(MSG_FILE, msg_fd);
	break;
d1631 5
a1635 5
	/*
	 * If we get a device driver status call we need to update
	 * our own count of the drivers present and see if its one
	 * that we are going to use.
	 */
d1637 20
a1656 22
#ifdef DEBUG
	Printf("DD> Received Driver status request\n");
	Printf("DD> Device: %s\n", ((struct dib *)r->r[0])->dib_name);
#endif
	/*
	 * 950315 KWelton
	 *
	 * we are only interested in device
	 * drivers that are starting up
	 */
	if( r->r[2] == 0 )
	{
	    readdevice_callback = 1;
	    callback(readdevice_entry);
	}

	break;

	/*
	 * DCIProtocol calls are done when any protocol (eg internet)
	 * startup.
	 */
d1658 37
a1694 15
	/*
	 * we are only interested in the internet module
	 */
	if( !strncmp((char *)r->r[4], (char *)protocol_name,
		     sizeof(protocol_name) + 1) )
	{
	    /*
	     * it's internet - check its status
	     */
	    if (r->r[2] == 0)
	    {
		/* internet is starting */
#ifdef DEBUG
		Printf("PP> Internet startup\n");
#endif
d1696 1
a1696 7
		/*
		 * 950306 KWelton
		 *
		 * we don't need to worry if we have already initialised
		 */
		if( startup_done )
		    break;
d1698 3
a1700 3
#ifdef DEBUG
		Printf("PP> Looking to start up Freeway.\n");
#endif
d1702 17
a1718 15
		(void)fw_real_init();
	    }
	    else if( r->r[2] == 1 )
	    {
		/*
		 * internet is terminating - shut freeway
		 * down, then prepare it for restart
		 */
#ifdef DEBUG
		Printf("PP> Internet termination\n");
#endif
		fw_final();
		fw_prime();
	    }
	}
d1720 1
a1720 1
	break;
d1722 3
a1724 29
      case Service_InternetStatus:
#ifdef DEBUG
	Printf("Service_InternetStatus: reason %d subreason %d (setting_address = %d)\n",
	       r->r[0], r->r[2], setting_address);
#endif

	switch( r->r[0] )
	{
	  case InternetStatus_AddressChanged:
	  case InternetStatus_NetMapChanged:
	  case InternetStatus_InterfaceUpDown:
	    serial_if.serial_if_action = r->r[2];
	    /*
	     * an internet interface has had its address
	     * changed - shutdown and restart Freeway as
	     * long as it's not us that set the address.
	     */
	    if( !setting_address )
	    {
		fw_final();
		fw_prime();
		fw_real_init();
	    }

	    break;

	  default:
	    break;
	}
d1726 1
a1726 1
	break;
d1729 1
a1729 1
	break;
d1735 1
a1735 1
int readdevice_handler(void)
d1737 2
a1738 1

d1741 5
a1745 7
	/*
	 * This is the 1st interface we know of that we can use so
	 * we should try and finish the initialisation.
	 */
#ifdef DEBUG
        Printf("CB> Calling reall initialisation.\n");
#endif
d1747 1
a1747 1
	}
d1749 4
a1752 6
	/*
	 * Otherwise just add the interface to the list.
	 */
#ifdef DEBUG
        Printf("CB> Calling interface count\n");
#endif
d1754 2
a1755 2
	}
    return 1;
d1780 3
a1782 3
	/* status request - return startup flag */
	r->r[1] = startup_done;
	return(NULL);
d1784 2
a1785 2
	/*NOTREACHED*/
	break;
d1788 1
a1788 1
	return(fw_error(Err_FWStatus));
d1798 1
a1798 1
 * In :	r0 : 0 => disable serial support
d1807 1
a1807 2
  #ifdef DEBUGSER
    Printf("FWSer> reason %d",r->r[0]);
d1809 1
a1809 1
      Printf(" unit (%s)",r->r[2]);
d1811 1
a1811 2
      Printf("\n");
  #endif
d1815 1
a1815 1
    case 0:	/* serial - remove serial support */
d1818 1
a1818 1
    case 1:	/* serial - add serial support */
d1832 1
a1832 3
        #ifdef DEBUGSER
          Printf("\nMatched unit %s - restarting freeway\n\n",r->r[2]);
        #endif
@


4.2
log
@Version RO_3_71 taken
@
text
@d17 2
a18 2
 * $Header: /projects2/renaissa/cvsroot/RiscOS/Sources/Networking/AUN/Access/Freeway/c/module,v 4.1.3.2 1996/11/08 17:19:52 nturton Exp $
 * $Source: /projects2/renaissa/cvsroot/RiscOS/Sources/Networking/AUN/Access/Freeway/c/module,v $
d22 9
a30 1
 * :RCS Log discontinued:
d171 1
d186 1
d194 1
d207 1
a207 1
static struct eblk error_blocks[15] = {
d223 2
d231 1
a231 1
#define MAXSWI 6
d244 1
d457 1
a457 1
    int s, n;
d464 5
a468 1
    extern struct in_addr inet_makeaddr(int net, int host);
d475 3
a477 3
#ifdef DEBUG
    Printf("IC> Opening socket....");
#endif
d481 4
a484 4
#ifdef DEBUG
	Printf("Failed - aborting\n");
#endif
	return -1;
d487 3
a489 3
#ifdef DEBUG
    Printf("Succeeded (temp socket=%d)\n",s);
#endif/* DEBUG */
d491 1
a491 1
  again: /* UGHHH! */
d500 3
a502 3
#ifdef DEBUG
    Printf("IC> Reading Interface(s) config (SIOCGIFCONF)...");
#endif
d506 1
a506 1
#ifdef DEBUG
d508 3
a510 3
#endif
	socketclose(s);
	return -1;
d513 3
a515 3
#ifdef DEBUG
   Printf("Succeeded\n");
#endif/* DEBUG */
d519 5
a523 3
    /*
     * Check here to eliminate devices we have already seen.
     * We know if we have seen any by looking at the count.
a524 71
#ifdef DEBUG
    Printf("IC> Checking for known usable interfaces...");
#endif

    if (fw.fw_ifcnt != 0)
    {
#ifdef DEBUG
	Printf("Found some - skipping %d\n",fw.fw_ifcnt);
#endif

	last_bcast = fw.fw_ifbcast[(fw.fw_ifcnt)];

	for( n = ifc.ifc_len / sizeof (struct ifreq); n > 0; n--, ifr++ )
	{
	    /*
	     * loop around the known interfaces.
	     */
	    ifreq = *ifr;

            /*
             * KJB - fix to prevent each interface being marked twice until
             * 4.4BSD Internet module (each interface also has an AF_LINK address)
             */
            if (((struct sockaddr *)&ifreq.ifr_addr)->sa_family != AF_INET)
            {
#ifdef DEBUG
            Printf("not an AF_INET address - skipping\n");
#endif
                continue;
            }

	    /*
	     * We are just checking for broadcast addresses here
	     * since we know that if we cant do it, it doesnt
	     * matter, and if we can then all we need to do is compare
	     * against the last known broadcast address.
	     */
	    if( socketioctl(s, SIOCGIFBRDADDR, (char *)&ifreq) < 0 )
		continue;
	    else
	    {
		/*
		 * Make the address usable.
		 */
		sin = (struct sockaddr_in *)&ifreq.ifr_addr;

		/*
		 * If this address matches the last known one,
		 * move on to finding the new devices
		 */
		if (last_bcast == sin->sin_addr.s_addr)
		{
		    /*
		     * Since we know this interface we can
		     * skip it.
		     */
#ifdef DEBUG
		    Printf("Found last known interface - evaluating rest\n");
#endif/* DEBUG */

		    ifr++;
		    break;
		}
	    }
	}
    }
#ifdef DEBUG
    else
	Printf("None known - evaluating rest\n");
#endif

d527 1
a527 1
#ifdef DEBUG
d529 2
a530 2
#endif
	return fw.fw_ifcnt;
d536 1
a536 1
    for( n = ifc.ifc_len / sizeof (struct ifreq); n > 0; n--, ifr++ )
d538 1
a538 17
	ifreq = *ifr;

#ifdef DEBUG
	Printf("IC> Evaluating found interface: ");
#endif

        /*
         * KJB - fix to prevent each interface being marked twice until
         * 4.4BSD Internet module (each interface also has an AF_LINK address)
         */
        if (((struct sockaddr *)&ifreq.ifr_addr)->sa_family != AF_INET)
        {
#ifdef DEBUG
            Printf("not an AF_INET address - skipping\n");
#endif
            continue;
        }
d540 22
a561 7
	/*
	 * Check to see if its the loop back device. We dont want this
	 */
	if( socketioctl(s, SIOCGIFFLAGS, (char *)&ifreq) < 0 ||
	   ifreq.ifr_flags & IFF_LOOPBACK )
	{
#ifdef DEBUG
d563 15
a577 23
#endif
	    continue;
	}

	/*
	 * The card also needs to be able to broadcast
	 */
	if( (ifreq.ifr_flags & (IFF_BROADCAST | IFF_UP ))
	   != (IFF_BROADCAST | IFF_UP ) )
	{
#ifdef DEBUG
	    Printf("device bcast or up failure (flags = %x)\n",
		   ifreq.ifr_flags);
#endif
	    continue;
	}

	/*
	 * Get the address of the interface
	 */
	if( socketioctl(s, SIOCGIFADDR, (char *)&ifreq) < 0 )
	{
#ifdef DEBUG
d579 88
a666 54
#endif
	    continue;
	}

	/*
	 * If we dont currently know the local address, set it to
	 * the one we just found.
	 */
	if( local_adr == 0 )
	{
	    sin = (struct sockaddr_in *)&ifreq.ifr_addr;
	    local_adr = sin->sin_addr.s_addr;

#ifdef DEBUG
	    Printf("setting local_adr=%x...", sin->sin_addr.s_addr);
#endif/* DEBUG */

	}

#if 0
	/*
	 * I think this would give nicer output, but it is
	 * much too close to freeze to do at the moment
	 */
	sprintf(name, "%s", inet_ntoa(sin->sin_addr));
#else
	sprintf(name, "%lx", sin->sin_addr.s_addr);
#endif

	setadrvar(fw.fw_ifcnt, name);
	fw.fw_ifaddrs[fw.fw_ifcnt] = sin->sin_addr.s_addr;

	/*
	 * Find out the broadcast address. If we cant get it then
	 * we dont want this device so retry from the start skipping
	 * this address.
	 */
	if( socketioctl(s, SIOCGIFBRDADDR, (char *)&ifreq) < 0 )
	{
#ifdef DEBUG
	    Printf("Cant get broadcast address - unsetting local_addr\n");
#endif
	    local_adr = 0;
	    continue;
	}

	/*
	 * Keep account of this card since it meets the requirements.
	 */
#ifdef DEBUG
	Printf("Storing interface info.\n");
#endif
	sin = (struct sockaddr_in *)&ifreq.ifr_addr;
	fw.fw_ifbcast[(fw.fw_ifcnt)++] = sin->sin_addr.s_addr;
d673 1
a673 1
    if( fw.fw_ifcnt == 0 && !retried )
d675 1
a675 1
#ifdef DEBUG
d677 1
a677 1
#endif
d679 1
a679 1
	read_device_name(name, etheradr);
d681 1
a681 1
#ifdef DEBUG
d683 1
a683 1
#endif
d685 15
a699 4
	if( name[0] != 0 )
	{
	    int retc;
	    int irqstatus;
d701 13
a713 10
#ifdef DEBUG
	    Printf("Making up ether address...");
#endif
	    byte0 = (u_char)etheradr[5];
	    byte1 = (u_char)etheradr[4];
	    byte2 = (u_char)name[1];
#ifdef DEBUG
	    Printf("Address derived from: %d %d %d...", byte0, byte1, byte2);
#endif
	    sin = (struct sockaddr_in *)&ifreq.ifr_addr;
d715 12
a726 27
	    /* next line modified 25/7/94 gw */
	    sin->sin_addr = inet_makeaddr(1, (byte0 | byte1 << 8 |
					      byte2 << 16));
	    sin->sin_family = AF_INET;

	    strncpy(ifreq.ifr_name, name, sizeof(ifreq.ifr_name));

	    irqstatus = ensure_irqs_off();
	    ++setting_address;
	    restore_irqs(irqstatus);
	    retc = socketioctl(s, SIOCSIFADDR, (caddr_t)&ifreq);
	    irqstatus = ensure_irqs_off();
	    --setting_address;
	    restore_irqs(irqstatus);

	    if( retc >= 0 )
	    {
#ifdef DEBUG
	        Printf("Seeing if this settup works.\n");
#endif
		retried = 1;
		goto again;
	    }
#ifdef DEBUG
	    Printf("Unable to setup address.\n");
#endif
	}
d734 4
a737 4
	_kernel_swi_regs r;
	_kernel_oserror *e;
	struct address_q *q;
	u_long ipadr;
d739 1
a739 1
#ifdef DEBUG
d741 1
a741 1
#endif/* DEBUG */
d743 8
a750 2
	r.r[4] = 0;
	for(;;)
d752 5
a756 10
	    e = _kernel_swi(XOS_Bit | Econet_EnumerateMap,&r, &r);
#ifdef DEBUG
	    Printf("r4 = %d",r.r[4]);
#endif/* DEBUG */
	    if (e || r.r[4] == -1) {
#ifdef DEBUG
	        Printf("\n");
#endif/* DEBUG */
		break;
		}
d758 8
a765 7
	    q = (struct address_q *)malloc(sizeof(struct address_q));
	    if (!q) {
#ifdef DEBUG
		Printf("No more Found\n");
#endif/* DEBUG */
		break;
		}
d767 8
a774 8
	    ipadr = (u_long)r.r[3];
#ifdef DEBUG
	    Printf("Found: %s, adding. ",r.r[3]);
#endif/* DEBUG */
	    q->q_bcast.s_addr = ipadr | 0xffff0000;
	    q->q_next = fw.fw_netadrs;
	    fw.fw_netadrs = q;
	}
d780 3
a782 3
#ifdef DEBUG
    Printf("IC> Done\n");
#endif/* DEBUG */
d785 3
d1330 3
d1355 1
a1355 1
	printf("net addresses:\n");
d1364 1
a1364 1
    for( f = fw.fw_types; f; f = f->fw_next )
d1366 1
a1366 1
	if (f->fw_number == DOMAIN_DISK)
d1373 9
d1383 1
a1383 1
	for( rl = f->fw_remobj; rl; rl = rl->r_next )
d1388 1
a1388 1
	    if( !rl->r_inuse )
d1394 1
a1394 1
	    if( rl->r_local )
d1402 1
a1402 1
	if( f->fw_next )
d1480 1
d1724 1
a1724 1
#ifdef DEBUG
d1737 1
a1737 1
#ifdef DEBUG
d1743 1
a1743 1
#ifdef DEBUG
d1759 1
a1759 1
#ifdef DEBUG
d1782 1
a1782 1
#ifdef DEBUG
d1934 2
a1935 2
	Printf("Service_InternetStatus: reason %d (setting_address = %d)\n",
	       r->r[0], setting_address);
d1942 2
d2031 57
@


4.1
log
@Initial revision
@
text
@d16 3
a18 3
 * 
 * $Header: /ax/networking:Starling/Freeway/module.c:networking  1.20  $
 * $Source: /ax/networking:Starling/Freeway/module.c: $
d22 6
a27 1
 * $Log:	module.c,v $
d30 1
a30 1
 * 
d34 1
a34 1
 * 
d36 1
a36 1
 * 
d40 1
a40 1
 * 
d43 1
a43 1
 * 
d45 1
a45 1
 * 
d48 1
a48 1
 * 
d51 1
a51 1
 * 
d55 1
a55 1
 * 
d59 1
a59 1
 * 
d64 1
a64 1
 * 
d69 1
a69 1
 * 
d72 1
a72 1
 * 
d78 1
a78 1
 * 
d81 1
a81 1
 * 
d84 1
a84 1
 * 
d87 1
a87 1
 * 
d91 1
a91 1
 * 
d95 1
a95 1
 * 
d100 1
a100 1
 * 
d103 1
a103 1
 * 
d107 1
a107 1
 * 
d110 1
a110 1
 * 
d112 1
a112 1
 * Added SWI "Freeway_Status". With the reson code 0 in R0 this will 
d115 1
a115 1
 * 
d121 1
a121 1
 * 
d125 1
a125 1
 * 
d127 1
a127 1
 * Changed function names of callback routines that deal with 
d129 1
a129 1
 * 
d134 1
a134 1
 * 
d139 1
a139 1
 * 
d145 1
a145 1
 * 
d148 1
a148 1
 * 
d524 12
d537 1
a537 1
	     * We are just checking for broadcast addresses here 
d546 1
a546 1
		/* 
d557 1
a557 1
		    /* 
d595 12
d695 1
a695 1
    /* 
d1085 1
a1085 1
 * from one of 2 places. Either the fw_init() if FW is initialising 
d1342 1
a1342 1
    else 
d1350 1
a1350 1
 * can be shared. -- Added in the definitions of DOMAIN_DISK and 
d1385 1
a1385 1
	if (f->fw_number == DOMAIN_DISK) 
d1387 1
a1387 1
	else if (f->fw_number == DOMAIN_HOST) 
d1389 1
a1389 1
	else if (f->fw_number == DOMAIN_PRINTER) 
d1609 1
a1609 1
/* 
d1728 1
a1728 1
{		 
d1774 1
a1774 1
	Printf("r2=Socket(unauth) "); 
d1777 1
a1777 1
	Printf("r2=Socket1(auth) "); 
d1779 1
a1779 1
    else Printf("r2=%d ",r[2]); 
d1950 1
d2011 1
a2011 1
 * 
d2014 1
a2014 1
 * if r0 = 0  status request 
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d16 1
a16 1
 *
a22 5
 *
 * Revision 1.21  96/04/07  09:52:15  kbracey
 * Fix to ignore address families other than AF_INET in read_ifs(), as the
 * 4.4BSD Internet module gives each interface an AF_LINK address.
 *
d25 1
a25 1
 *
d29 1
a29 1
 *
d31 1
a31 1
 *
d35 1
a35 1
 *
d38 1
a38 1
 *
d40 1
a40 1
 *
d43 1
a43 1
 *
d46 1
a46 1
 *
d50 1
a50 1
 *
d54 1
a54 1
 *
d59 1
a59 1
 *
d64 1
a64 1
 *
d67 1
a67 1
 *
d73 1
a73 1
 *
d76 1
a76 1
 *
d79 1
a79 1
 *
d82 1
a82 1
 *
d86 1
a86 1
 *
d90 1
a90 1
 *
d95 1
a95 1
 *
d98 1
a98 1
 *
d102 1
a102 1
 *
d105 1
a105 1
 *
d107 1
a107 1
 * Added SWI "Freeway_Status". With the reson code 0 in R0 this will
d110 1
a110 1
 *
d116 1
a116 1
 *
d120 1
a120 1
 *
d122 1
a122 1
 * Changed function names of callback routines that deal with
d124 1
a124 1
 *
d129 1
a129 1
 *
d134 1
a134 1
 *
d140 1
a140 1
 *
d143 1
a143 1
 *
a518 12
            /*
             * KJB - fix to prevent each interface being marked twice until
             * 4.4BSD Internet module (each interface also has an AF_LINK address)
             */
            if (((struct sockaddr *)&ifreq.ifr_addr)->sa_family != AF_INET)
            {
#ifdef DEBUG
            Printf("not an AF_INET address - skipping\n");
#endif
                continue;
            }

d520 1
a520 1
	     * We are just checking for broadcast addresses here
d529 1
a529 1
		/*
d540 1
a540 1
		    /*
a577 12
        /*
         * KJB - fix to prevent each interface being marked twice until
         * 4.4BSD Internet module (each interface also has an AF_LINK address)
         */
        if (((struct sockaddr *)&ifreq.ifr_addr)->sa_family != AF_INET)
        {
#ifdef DEBUG
            Printf("not an AF_INET address - skipping\n");
#endif
            continue;
        }

d666 1
a666 1
    /*
d1056 1
a1056 1
 * from one of 2 places. Either the fw_init() if FW is initialising
d1313 1
a1313 1
    else
d1321 1
a1321 1
 * can be shared. -- Added in the definitions of DOMAIN_DISK and
d1356 1
a1356 1
	if (f->fw_number == DOMAIN_DISK)
d1358 1
a1358 1
	else if (f->fw_number == DOMAIN_HOST)
d1360 1
a1360 1
	else if (f->fw_number == DOMAIN_PRINTER)
d1580 1
a1580 1
/*
d1699 1
a1699 1
{
d1745 1
a1745 1
	Printf("r2=Socket(unauth) ");
d1748 1
a1748 1
	Printf("r2=Socket1(auth) ");
d1750 1
a1750 1
    else Printf("r2=%d ",r[2]);
a1920 1
	  case InternetStatus_NetMapChanged:
d1981 1
a1981 1
 *
d1984 1
a1984 1
 * if r0 = 0  status request
@


4.1.3.2
log
@RCS Log keyword removed
@
text
@d22 1
a22 1
 * :RCS Log discontinued:
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@


4.1.1.2
log
@Log keyword removed
@
text
@d22 1
a22 1
 * :RCS Log discontinued:
@

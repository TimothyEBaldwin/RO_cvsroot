head	4.6;
access;
symbols
	Net-6_26:4.6
	Net-6_25:4.6
	Net-6_24:4.5
	Net-6_23:4.4
	Net-6_22:4.4
	Net-6_21:4.4
	RO_5_07:4.3
	Net-6_20:4.3
	Net-6_19:4.2
	Net-6_18:4.2
	Ursula_merge:4.2
	Ursula_13May1998_merge:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.6
	Ursula_13May1998_bp:4.2
	Ursula_13May1998:4.2.0.2
	rthornb_UrsulaBuild_01May1998:4.2
	Daytona:4.2.0.4
	Daytona_bp:4.2
	RO_3_71:4.1.3.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2015.05.29.19.28.57;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	2VVHsW5ULMhIonny;

4.5
date	2013.03.04.21.40.12;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	6nodLtD9YevXlwGw;

4.4
date	2011.11.17.21.30.11;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	XC2A8g249mgcvJHv;

4.3
date	2003.12.03.19.21.59;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	97.05.13.11.25.24;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.28.23;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1;
next	;

4.1.1.1
date	96.11.05.09.28.23;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.22.31.11;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Have Net look after its own messages
Net was trying to share some messages with the Econet module, though on balance this wasn't particularly useful as it then needed to duplicate message handling code to keep 2 files open. Because those messages were held in AUNMsgs they didn't get tokenised in ROM, overall ending up taking more space.

Register in ResourcesFS at run time for RAM targets, add tokenisation directives for ROM targets, removed redundant !Configure related strings.
Changed the messages fd to be int's to ensure word alignment.
Removed inappropriate Service_MessageFileClosed handler, MessageTrans reopens the files (since the fd is in the RMA) so no need to reopen them a second time. This service call is intended to recache direct pointers to tokens, but none are ever taken.
Save time by just making textbuf a zero length string rather than memset()ing the whole buffer.
Resolved a couple more compiler warnings (but NetG still doesn't compile).
Fix bug where a failure to enable the internet event would decrement the internet event count for any other modules interested in that event.
Use CMHG finalisation rather than atexit().
Error "AUN not configured" now uses a non zero trappable error number.
Error number for BadSWI corrected from 0x111 to 0x110.

Requires HdrSrc-2_51 for the error number.

Version 6.25. Tagged as 'Net-6_25'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* mnsi.c
 *
 * Author: Keith Ruttle (Acorn)
 *
 * Description
 * ===========
 * Module code
 *
 * Environment
 * ===========
 * Acorn RISC OS 3.11 or later.
 *
 * Compiler
 * ========
 * Acorn Archimedes C release 5.06 or later.
 *
 * Change record
 * =============
 *
 * JPD  Jem Davies (Cambridge Systems Design)
 *
 *
 * 09-Dec-94  17:41  JPD  Version 1.00
 * First version with change record. Modified: #includes to be ANSI-compliant,
 * other constructs to remove compiler warnings, code to cope with DCI-4 and
 * new mbuf structure.  Added changes from KRuttle's 6.03 version (different
 * to RISC OS SrcFiler 6.03 version!)
 *
 * 13-Jan-95  15:44  JPD  Version 1.01
 * Issue Service_ReAllocatePorts on reinitialisation (now done on callback).
 *
 * 25-Jan-95  09:58  JPD  Version 1.02
 * Added NetworkParameters SWI. Reinitialise properly when Econet is killed.
 *
 * 10-Feb-95  16:18  JPD  Version 1.03
 * Added special pleading to force reinitialisation when Internet starting
 * service call is received after Internet was thought to be present.
 * Initialise connected_econet to -1 not 0. This seems sensible anyway, but
 * has the added bonus that when NetFS is started by the BootNet module
 * before Callbacks have gone off, allowing the Net module is properly
 * initialised, the NetFS initialisation does not fail. Tighten lock
 * checking in setting of callbacks. Add removal of any callbacks set on
 * finalisation.
 *
 * 28-Feb-95  12:52  JPD  Version 1.04
 * Removed OldCode. Pass out-of-range SWIs on to Econet module, if present,
 * to maximise chance of a change to Econet module not requiring change to
 * Net module. Corrected error in SWI despatch allowing a slightly
 * out-of-range SWI to cause a branch through zero exception. Corrected
 * error message produced for other out-of-range SWIs. Added returning of
 * different values for peek machine type depending on what machine we are
 * running on. Simplify service call reinitialisation stategy.
 *
 * 14-Mar-95  15:37  JPD  Version 1.05
 * Moved some code to mnscommon.c. Now compilable -fah. Keep *Addmaps info
 * across a self_imposed reinitialisation.
 *
 * 21-Mar-95  18:17  JPD  Version 1.06
 * Moved mns_sc_handler() and reset_is_soft() to mnscommon.c.
 *
 * 04-Oct-95  10:05  JPD  Version 1.07
 * Corrected some extern declarations: added #include <string.h>, had to add
 * a cast to correct compiler warning as a consequence. Corrected some
 * comments: should not change code.
 *
 * 06-Oct-95  10:34  JPD  Version 1.03
 * Moved machine_type and modules_present to mnscommon.c.
 *
 *
 **End of change record*
 */

#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdio.h>

#include "kernel.h"
#include "swis.h"

#include "socklib.h"
#include "sys/types.h"
#include "sys/uio.h"
#include "sys/socket.h"
#include "sys/time.h"
#include "sys/ioctl.h"
#include "netinet/in.h"
#include "net/if.h"
#include "sys/dcistructs.h"

#include "configure.h"
#include "netasm.h"
#include "module.h"
#include "mns.h"
#include "io.h"
#include "mnscommon.h"
#include "debug.h"
#include "text.h"
#include "swicode.h"
#include "NetIHdr.h" /* From CMHG */

extern char *inet_ntoa();

struct mns mns = { 0 };
int connected_econet = -1;
int econet_transport_type = 0;
int econet_not_present = 0;

static void mns_showmap(int argc, char **argv);
static void mns_addmap(int argc, char **argv);
static void mns_showif(int argc, char **argv);
static void mns_info(int all);

#ifndef DEBUG
struct client mns_cli_call[5] =
{
   mns_addmap,
   mns_showmap,
   mns_showif,
   mns_ping,
   0,
};
#else
static void mns_showcbs(int argc, char **argv);
static void mns_showports(int argc, char **argv);

struct client mns_cli_call[7] =
{
   mns_addmap,
   mns_showmap,
   mns_showif,
   mns_ping,
   mns_showcbs,
   mns_showports,
   0,
};
#endif

#define MAXSWI 33
struct swient
{
   _kernel_oserror *(*swi_call)(_kernel_swi_regs *);      /* SWI handler */
};

static _kernel_oserror *EnumMapNull(_kernel_swi_regs *r);

static struct swient mns_ent[MAXSWI+1] =
{
   CreateReceive,  ExamineReceive, ReadReceive,
   AbandonReceive, WaitForReception, EnumerateReceive,
   StartTransmit, PollTransmit, AbandonTransmit,
   DoTransmit, ReadLocalStationAndNet,
   ConvertStatusToString, ConvertStatusToError,
   ReadProtection, SetProtection, ReadStationNumber,
   PrintBanner, ReadTransportType, ReleasePort, AllocatePort,
   DeAllocatePort, ClaimPort, StartImmediate,
   DoImmediate, AbandonAndReadReceive, Version, NetworkState,
   PacketSize, ReadTransportName, InetRxDirect, EnumMapNull,
   EnumerateTransmit, HardwareAddresses, NetworkParameters,
};

static void read_ifs(int print, int all);
static void atp_add_newitem(struct atp_block *a);
int init_sockets(void);

static u_long inet_addr(register char *cp);

static void namtomodule(char *nm);

/******************************************************************************/

_kernel_oserror *mns_init(const char *cmd_tail, int pbase, void *pw)
{
/*
 * cmhg module initialisation entry
 *
 * Parameters:
 *    cmd_tail : pointer to command line tail
 *    pbase    : 0 unless code invoked from a podule
 *    pw       : "R12" value established by module initialisation
 *
 * Returns:
 *     0 : => successfully initialised
 *    !0 : => a problem, pointer to standard RISC OS error block
 */

   _kernel_oserror *e;

   UNUSED(pbase);
   UNUSED(cmd_tail);

   /* take note of our workspace pointer for future use */
   module_wsp = pw;

   DEBUGP1("\n\r#module initialisation\n\r");

   xDEBUGP2("#pbase = %08X\n\r", pbase);

   xDEBUGP5("#-- 1: %08X, %08X, %08X, %08X\n\r",
                   *(unsigned int *)0x01c00000, *(unsigned int *)0x01c00004,
                   ((*((unsigned int **)pw)))[1],((*((unsigned int **)pw)))[2]);

   /* This must really be done now, cannot wait for do_mns_init() */
   memset((char *)&mns, 0, sizeof(mns));
   mns.mns_rxdsock = -1;
   mns.mns_txdsock = -1;
   mns.mns_atpsock = -1;
   mns.mns_routedsock = -1;

   /* Open message file for us */
   e = init_msgs(Module_MessagesFile, msg_fd_mns);
   if (e)
      return e;

   /* Install ticker code */
   e = calleverytick(tick_entry);
   if (e)
      goto out3;

   /* check machine type we are running on for later machine type peek */
   check_machine_type();

   /* Find real Econet module so SWIs can be handed on to it */
   e = init_econet();
   if (e)
      econet_not_present = 1;

   do_mns_init(1);

  /* set flag and set a Callback, so that the service call to say that
   * "Econet" has been reinitialised will be issued on a Callback after this
   * initialisation has completed.
   */
   restarting = 1;
   setcallback();

   return NULL; /* return OK */

out3:
   release_msgs(msg_fd_mns);

   return e;

} /* mns_init() */

/******************************************************************************/

int do_mns_init(int booting)
{
/*
 * Perform initialisation
 *
 * Parameters:
 *    booting : !0 => initialisation for first time
 *               0 => reinitialisation as result of service call
 *
 * Returns:
 *    !0 : => successfully initialised
 *     0 : => either a problem, or reinitialised
 */

   _kernel_swi_regs r;
   int no_econet_clock = 0;
   int rxd, txd, atp, routed;
   struct address_q *q;

   rxd = booting ? -1 : mns.mns_rxdsock;
   txd = booting ? -1 : mns.mns_txdsock;
   atp = booting ? -1 : mns.mns_atpsock;
   routed = booting ? -1 : mns.mns_routedsock;
   q = mns.mns_mapq;

   memset((char *)&mns, 0, sizeof(mns));
   mns.mns_rxdsock    = rxd;
   mns.mns_txdsock    = txd;
   mns.mns_atpsock    = atp;
   mns.mns_routedsock = routed;
   mns.mns_txhandle   = MNS_HANDLE_BASE;
   mns.mns_rxhandle   = MNS_HANDLE_BASE;
   mns.mns_nextport   = 1;
   mns.mns_mapq       = q;

   if (!booting)
      return 0;

   mns.mns_stationnumber = read_device_info(mns.mns_device, mns.mns_module,
                                            &connected_econet, &no_econet_clock,
                                            &mns.mns_segsize);
   if (connected_econet != -1)
   {
      mns.mns_states[connected_econet] |= ECONET_IS_CONNECTED;
      mns.mns_netnumber = connected_econet;
   }
   else
      mns.mns_stationnumber = 0;

#ifdef R1COMPAT
   mns.mns_segsize = DFT_SEGSIZE;
#endif

   /* Read the actual transport type for the "Econet" */
   r.r[0] = 0;
   r.r[1] = 2;
   econet_transport_type =
                         call_econet(Econet_ReadTransportType, &r) ? 2 : r.r[2];
   read_ifs(0, 0);

   if (mns.mns_ifcnt > 0)
      init_sockets();

   return 0;

} /* do_mns_init() */

/******************************************************************************/

_kernel_oserror *mns_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
/* cmhg module SWI handler
 *
 * Parameters:
 *    swinum : SWI number within our SWI chunk
 *    r      : pointer to registers structure
 *    pw     : "R12" value
 *
 * Returns:
 *    0 => all OK
 *   !0 => some error occurred (pointer to RISC OS error block)
 *
 */

   struct swient *callp;
   _kernel_oserror *e = 0;
   int oldstate;

   UNUSED(pw);

   if (swinum < 0 || swinum > 63)
      return error_BAD_SWI;

   if (swinum > MAXSWI)
   {
      if (connected_econet != -1)
         return call_econet(swinum, r);
      else
         return error_BAD_SWI;
   }

   callp = &mns_ent[swinum];
   oldstate = ensure_irqs_off();
   e = (_kernel_oserror *)(*(callp->swi_call))(r);
   restore_irqs(oldstate);

   return e;
}

/******************************************************************************/

static void mns_addmap(int argc, char **argv)
{
/*
 * *AddMap code
 *
 * Parameters:
 *    argc : }
 *    argv : } command line parms
 *
 * Returns:
 *    None
 */

   struct atp_block ablock;

   UNUSED(argc);

   memset(ablock.atpb_sitename, 0, 16);
   memset(ablock.atpb_netname, 0, 16);
   ablock.atpb_ipadr   = inet_addr(argv[0]) & ~0xff000000;
   ablock.atpb_net     = (u_char)atoi(argv[1]);
   ablock.atpb_station = 0;
   atp_add_newitem(&ablock);

   return;

} /* mns_addmap() */

/******************************************************************************/

static void mns_showif(int argc, char **argv)
{
/*
 * *NetStat code
 *
 * Parameters:
 *    argc : }
 *    argv : } command line parms
 *
 * Returns:
 *    None
 */

   int all = 0;

   UNUSED(argv);

   if (!mns.mns_flags)
      return;

   if (argc > 0)
      all = 1;

   read_ifs(1, all);

   mns_info(all);

   return;

} /* mns_showif() */

/******************************************************************************/

static void mns_showmap(int argc, char **argv)
{
/*
 * *NetMap code: show mapping from pseudo-Econet numbers to Internet addresses
 *
 * Parameters:
 *    argc : }
 *    argv : } command line parms (optional net number)
 *
 * Returns:
 *    None
 */

   struct address_q *q;
   char abuf[32];
   int n;

   UNUSED(argc);
   UNUSED(argv);

   for (q = mns.mns_mapq; q; q = q->q_next)
   {
      sprintf(abuf, "%s", inet_ntoa(q->q_ip));
      if (n = strlen(abuf))
      {
         abuf[n - 1] = 'x';
         printf("%3d.x <==> %s\n", q->q_net, abuf);
      }
   }

   return;

} /* mns_showmap() */

/******************************************************************************/

#ifdef DEBUG
static void mns_showcbs(int argc, char **argv)
{
   struct rxcb *rx;
   struct txcb *tx;

   UNUSED(argc);
   UNUSED(argv);

   printf("receive blocks:\n");
   for (rx = mns.mns_rxlist; rx; rx = rx->rx_next)
   {
      printf("    station=%d.%d, port=%x, buffer=%x, bufsize=%d, handle=%x, status=%x\n",
            rx->rx_network, rx->rx_station, rx->rx_port, rx->rx_buf,
            rx->rx_bufsize, rx->rx_handle, rx->rx_status);
   }

   for (rx = mns.mns_rxwild; rx; rx = rx->rx_next)
   {
      printf("    station=%d.%d, port=%x, buffer=%x, bufsize=%d, handle=%x, status=%x\n",
            rx->rx_network, rx->rx_station, rx->rx_port, rx->rx_buf,
            rx->rx_bufsize, rx->rx_handle, rx->rx_status);
   }
   printf("\ntransmit blocks:\n");
   for (tx = mns.mns_txlist; tx; tx = tx->tx_next)
   {
      printf("    station=%d.%d, port=%x, buffer=%x, bufsize=%d, handle=%x, status=%x\n",
            tx->tx_network, tx->tx_station, tx->tx_port, tx->tx_buf,
            tx->tx_bufsize, tx->tx_handle, tx->tx_status);
   }

   return;

} /* mns_showcbs() */

/******************************************************************************/

static void mns_showports(int argc, char **argv)
{
   int i;

   UNUSED(argc);
   UNUSED(argv);

   printf("Next portnumber is %x\n\n", mns.mns_nextport);

   for (i = 1; i < 255; i++)
   {
      if ((mns.mns_states[i] & (PORTALLOCATED | PORTCLAIMED)) == 0)
         continue;

      if (mns.mns_states[i] & PORTALLOCATED)
         printf("Port %x is allocated\n", i);

      if (mns.mns_states[i] & PORTCLAIMED)
         printf("Port %x is claimed\n", i);
   }

   return;

} /* mns_showports() */

#endif

/******************************************************************************/


int tick_handler(_kernel_swi_regs *r, void *pw)
{
/*
 * cmhg ticker interrupt handler
 *
 * Parameters:
 *    r  : pointer to registers block
 *    pw : "R12" value established by module initialisation
 *
 * Returns:
 *    0 => interrupt "claimed"
 *   !0 => interrupt not "claimed"
 */


   UNUSED(r);
   UNUSED(pw);

   check_rxcbs();
   check_txcbs();

   return 1;

} /* tick_handler() */

/******************************************************************************/

_kernel_oserror *mns_final(int fatal, int podule, void *pw)
{
/* Finalisation code
 *
 * Parameters:
 *    None
 *
 * Returns:
 *    None
 */

   DEBUGP1("#module finalisation\n\r");

   UNUSED(fatal);
   UNUSED(podule);
   UNUSED(pw);

  /* One could argue about the order of releasing the vectors and closing
   * the sockets, but this is the way it was.
   */

   /* Close sockets */
   free_sockets();

   /* remove the installed ticker handler */
   removetickerevent(tick_entry);

   /* remove any added transient callback */
   removecallback();

   /* Close MessageTrans message files */
   release_msgs(msg_fd_mns);

   return NULL;

} /* mns_final() */

/******************************************************************************/

static void read_ifs(int print, int all)
{
/*
 * Obtain information about the network interfaces
 *
 * Parameters:
 *    print : !0 => display details of interfaces
 *    all   : !0 => print full information
 *
 * Returns:
 *    None
 */

   int s, n, eco, no_econet_clock;
   char buf[512], name[12];
   struct ifconf ifc;
   struct ifreq ifreq, *ifr;
   struct sockaddr_in *sin;
   u_long addr;
   int inmap, net, station, first = 1;

   DEBUGP3("#read_ifs(%d, %d)\n\r", print, all);

   /* open a socket to use to obtain details */
   if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
       return;

   ifc.ifc_len = sizeof (buf);
   ifc.ifc_buf = buf;

   /* get the interface info list from the Internet module */
   if (socketioctl(s, OSIOCGIFCONF, (char *)&ifc) < 0)
   {
      socketclose(s);
      return;
   }

   /* if connected to Econet, get Econet info */
   if (print && connected_econet != -1)
   {
      (void) read_eco_info(&connected_econet, &no_econet_clock);
      printf("%-18s", mns_str(Str_NtvEco));
      printf("%d.%d", connected_econet, mns.mns_stationnumber);
      if (no_econet_clock)
         printf(" (%s)", mns_str(Str_Noclck));
      printf("\n\n");
   }

   mns.mns_ifcnt = 0;
   mns.mns_econetipadr = 0;
   ifr = ifc.ifc_req;

   /* step forwards through interface info list */
   for (n = ifc.ifc_len / sizeof (struct ifreq); n > 0; n--, ifr++)
   {
      if (((struct osockaddr *)&ifr->ifr_addr)->sa_family != AF_INET)
         continue;

      ifreq = *ifr;
      /* Ignore the loopback interface */
      if (socketioctl(s, SIOCGIFFLAGS, (char *)&ifreq) < 0 ||
                                                 ifreq.ifr_flags & IFF_LOOPBACK)
         continue;

      if (print)
      {
         if (!first)
            printf("\n");
         /* Print "Interface" */
         printf("\n%-18s", mns_str(Str_IfType));
      }

      eco = strcmp(ifreq.ifr_name, "ec0") == 0 ? 1 : 0;

      if (print)
      {
         strcpy(name, ifreq.ifr_name);
         name[strlen(name) - 1] = 0;
         namtomodule(name);
         printf("%s ", name);
      }

      if ((ifreq.ifr_flags & (IFF_BROADCAST|IFF_UP)) != (IFF_BROADCAST|IFF_UP))
      {
         if (print)
            printf("(%s)\n", mns_str(Str_Down));
         goto next;
      }

      if (print)
         printf("\n");

      /* get interface Internet address */
      if (socketioctl(s, SIOCGIFADDR, (char *)&ifreq) < 0)
         goto next;

      sin = (struct sockaddr_in *)&ifreq.ifr_addr;
      addr = ntohl(sin->sin_addr.s_addr);
      inmap = ip_to_mns(sin->sin_addr.s_addr, &net, &station);
      if (inmap && station != 0 && station != ALL_ONES)
      {
         if (mns.mns_stationnumber == 0)
         {
            mns.mns_stationnumber = station;
            mns.mns_netnumber = net;
         }
         if (print)
            printf("%-18s%d.%d\n", mns_str(Str_StaNum), net, station);
      }

      if (print && all)
         printf("%-18s%s\n", mns_str(Str_FullAd),
                                        inet_ntoa(*((u_long *)&sin->sin_addr)));

      /* get Internet broadcast address for interface */
      if (socketioctl(s, SIOCGIFBRDADDR, (char *)&ifreq) < 0)
          goto next;

      sin = (struct sockaddr_in *)&ifreq.ifr_addr;
      if (print && all)
          printf("%-18s%s\n", mns_str(Str_BrdCst), inet_ntoa(sin->sin_addr));
      mns.mns_ifaddrs[(mns.mns_ifcnt)++] = sin->sin_addr.s_addr;
next:
      first = 0;
   }

   socketclose(s);
   return;

} /* read_ifs() */

/******************************************************************************/

static void atp_add_newitem(struct atp_block *a)
{
   struct address_q *q;
   struct address_q **p;

   p = &(mns.mns_mapq);
   while (*p)
   {
      if ((*p)->q_ip == a->atpb_ipadr)
         return;
      p = &((*p)->q_next);
   }

   if ((*p) == 0)
   {
      q = (struct address_q *)malloc (sizeof(struct address_q));
      if (q == (struct address_q *)0)
         return;

      q->q_bcast = 0;
      q->q_next = (struct address_q *)0;
      *p = q;
   }

   q->q_net = a->atpb_net;
   q->q_ip  = a->atpb_ipadr;
   memcpy(q->q_sitename, a->atpb_sitename, ITEM_NAMELEN);
   memcpy(q->q_netname, a->atpb_netname, ITEM_NAMELEN);

   if ((mns.mns_states[q->q_net] & ECONET_IS_CONNECTED) == 0)
      mns.mns_states[q->q_net] |= MNS_IS_CONNECTED;
   if (mns.mns_stationnumber == 0)
      read_ifs(0, 0);

   return;

} /* atp_add_newitem() */


/******************************************************************************/

int init_sockets(void)
{
   if (mns.mns_flags & MNS_SOCKET)
      return 0;

   mns.mns_rxdsock = do_getsock(MNSDATAPORT, 1, 1);
   if (mns.mns_rxdsock < 0)
      return -1;

   mns.mns_txdsock = do_getsock(MNSDATAPORT, 0, 0);
   mns.mns_flags |= MNS_SOCKET;

   return 0;

} /* init_sockets() */

/******************************************************************************/

void free_sockets(void)
{
   if (mns.mns_rxdsock != -1)
      (void) socketclose(mns.mns_rxdsock);

   if (mns.mns_txdsock != -1)
      (void) socketclose(mns.mns_txdsock);

   return;

} /* free_sockets() */

/******************************************************************************/

static void mns_info(int all)
{
    int i, found = 0;

    printf("\n%-18s", mns_str(Str_AccNet));
    for (i = 1; i < 256; i++) {
        if (mns.mns_states[i] & (ECONET_IS_CONNECTED|MNS_IS_CONNECTED)) {
            if ((++found % 8) == 0)
                printf("\n%-18s", " ");
            if (mns.mns_states[i] & ECONET_IS_CONNECTED)
                printf("*%-5d", i);
            else if (mns.mns_ifcnt > 0)
                printf("%-6d", i);
        }
    }
    printf("\n");
    if (!all)
        return;
    printf("\n%-18s", mns_str(Str_TxStat));
    printf("%s=%d, ", mns_str(Str_Data), mns.mns_txcnt);
    printf("%s=%d, ", mns_str(Str_Immedt), mns.mns_tximmcnt);
    printf("%s=%d, ", mns_str(Str_ImmRep), mns.mns_tximmrcnt);
    printf("%s=%d\n",mns_str(Str_Retry), mns.mns_txretry);
    printf("%-18s", " ");
    printf("%s=%d, ", mns_str(Str_Error), mns.mns_txerrs);
    printf("%s=%d, ", mns_str(Str_DtaAck), mns.mns_txacks);
    printf("%s=%d, ", mns_str(Str_DtaRej), mns.mns_txrej);
    printf("%s=%d\n", mns_str(Str_BrdCst), mns.mns_txbccnt);
    printf("%-18s", " ");
    printf("(%s=%d, ", mns_str(Str_Local), mns.mns_txlbc);
    printf("%s=%d)\n", mns_str(Str_Global), mns.mns_txgbc);
    printf("\n%-18s", mns_str(Str_RxStat));
    printf("%s=%d, ", mns_str(Str_Data), mns.mns_rxcnt);
    printf("%s=%d, ", mns_str(Str_Immedt), mns.mns_rximmcnt);
    printf("%s=%d, ", mns_str(Str_BrdCst), mns.mns_rxbc);
    printf("%s=%d\n", mns_str(Str_Dscard), mns.mns_rxdiscard);
    printf("%-18s", " ");
    printf("%s=%d, ", mns_str(Str_Retry), mns.mns_rxretries);
    printf("%s=%d, ", mns_str(Str_Error), mns.mns_rxerrs);
    printf("%s=%d, ", mns_str(Str_DtaAck), mns.mns_rxacks);
    printf("%s=%d\n", mns_str(Str_DtaRej), mns.mns_rxrej);
    printf("%-18s", " ");
    printf("%s=%d, ", mns_str(Str_ImmRep), mns.mns_rximreply);
    printf("%s=%d\n", mns_str(Str_InvRep), mns.mns_rxackdiscard);
    printf("\n%-18s", mns_str(Str_ModSts));
    printf("0%o", mns.mns_flags);
    printf("\n");
}

/******************************************************************************/

int ip_to_mns(u_long addr, int *net, int *station)
{
   struct address_q *q;
   u_long i, m;

   i = ntohl(addr);
   m = i & ~0xff;
   for (q = mns.mns_mapq; q; q = q->q_next)
   {
      if (m == htonl(q->q_ip)) {
         *station = i & 0xff;
         *net = (int)q->q_net;
         return 1;
      }
   }
   *net = (u_int)addr;
   *station = ALL_ONES;

   return 1;

} /* ip_to_mns() */

/******************************************************************************/

int src_is_ok(struct rxcb *rx, int net, int station)
{
    if (rx->rx_station == ALL_ONES && rx->rx_network == ALL_ONES)
        return (1);
    if (((rx->rx_network > 0 && rx->rx_network < ANY_NETWORK) && net != rx->rx_network) ||
        ((rx->rx_station > 0 && rx->rx_station < ANY_STATION) && station != rx->rx_station))
        return (0);
    return (1);
}

u_long mns_to_ip(int net, int station)
{
    struct address_q *q;

    if (station == ALL_ONES)
        return ((u_long)net);

    if (net == 0)
        net = local_net();

    if ((mns.mns_states[net] & ECONET_IS_CONNECTED) != 0)
        return ((u_long)0);

    for (q = mns.mns_mapq; q; q = q->q_next) {
        if (net == q->q_net)
            return((q->q_ip | htonl(station)));
    }
    return ((connected_econet != -1) ? (u_long) 0 : (u_long) -1);
}

/******************************************************************************/

int msg_broadcast(u_char flag, u_char port, char *data, int len, int local)
{
   int i;

   for (i = 0; i < mns.mns_ifcnt; i++)
      (void) msg_transmit(mns.mns_ifaddrs[i], flag, 0, port, data, len,
                                                       BROADCAST_DATA_FRAME, 0);
   if (local)
      mns.mns_txlbc++;
   else
      mns.mns_txgbc++;
   mns.mns_txbccnt++;

   return 0;

} /* msg_broadcast() */

/******************************************************************************/

static void namtomodule(char *nm)
{
/*
 * Get the module name relating to a device name
 *
 * Parameters:
 *    nm : pointer to a string holding the device name without the number,
 *         e.g. "en"
 *
 * Returns:
 *    None
 *    nm : still points to the string, now holding the module name,
 *         e.g. "Ether2"
 */

   _kernel_swi_regs r;
   _kernel_oserror *e;
   struct dib *d;
   struct chaindib *chdp, *n;

   r.r[0] = 0;         /* initialise to zero so that we can detect a response */
   r.r[1] = Service_EnumerateNetworkDrivers;
   /* Issue service call to find all DCI4 drivers */
   e = _kernel_swi(OS_ServiceCall, &r, &r);


   /* if no error issuing service call and received a response */
   if ((e == 0) && (chdp = (struct chaindib *)(r.r[0]), chdp != 0))
   {
      n = chdp->chd_next;
      d = chdp->chd_dib;

      while (d != 0)
      {
         if (strcmp((char *)d->dib_name, nm) == 0)
         {
            r.r[0] = 0;
            e = _kernel_swi(d->dib_swibase + DCI4Version, &r, &r);
            if (!e && r.r[1] >= MINIMUM_DCI_VERSION)
               strncpy(nm, (char *)d->dib_module, 24);
            break;
         }
         else
         {
            if (n == 0)
               break;

            /* step on */
            d = n->chd_dib;
            n = n->chd_next;
         }
      }

      /* Now, free all the chaindibs returned to us */
      while (chdp != 0)
      {
         r.r[0] = 7;      /* reason code Free */
         r.r[2] = (int) chdp;
         chdp = chdp->chd_next;
         if (e = _kernel_swi(OS_Module, &r, &r), e != 0);
            /* if any error, probably should not continue freeing blocks */
            break;
      }
   }

   return;

} /* namtomodule() */

/******************************************************************************/

int in_local_aun_network(int net)
{
   UNUSED(net);

   return 0;

}  /* in_local_aun_network() */

/******************************************************************************/

_kernel_oserror *range_check(int port, int station, int net)
{
   if (port < 0 || port > 255)
      return mns_error(Err_BadPort);

   if (station != ALL_ONES && (station < 0 || station > 255))
      return mns_error(Err_BadStn);

   if (station != ALL_ONES && (net < 0 || net > 255))
      return mns_error(Err_BadNet);

   return NULL;

} /* range_check() */

/******************************************************************************/

int is_wild(int port, int station, int network)
{
    if (station == ALL_ONES)
        return (network == ALL_ONES ? 1 : 0);
/* Insert KRuttle's 6.03 changes */
    return ((network == ANY_NETWORK || station == ANY_STATION ||
            (network == 0 && station == 0) ||
             port == ANY_PORT || port == 0) ? 1 : 0);
}

/******************************************************************************/

static u_long inet_addr(register char *cp)
{
/*
 * Internet address interpretation routine.
 * The value returned is in network order.
 */

   u_long val, base, n;
   char c;
   u_long parts[4], *pp = parts;

again:

  /*
   * Collect number up to ``.''.
   * Values are specified as for C:
   * 0x=hex, 0=octal, other=decimal.
   */
   val = 0; base = 10;
   if (*cp == '0')
      base = 8, cp++;
   if (*cp == 'x' || *cp == 'X')
      base = 16, cp++;

   while (c = *cp)
   {
      if (isdigit(c)) {
         val = (val * base) + (c - '0');
         cp++;
         continue;
      }
      if (base == 16 && isxdigit(c))
      {
         val = (val << 4) + (c + 10 - (islower(c) ? 'a' : 'A'));
         cp++;
         continue;
      }
      break;
   }

   if (*cp == '.')
   {
      /*
       * Internet format:
       *      a.b.c.d
       *      a.b.c   (with c treated as 16-bits)
       *      a.b     (with b treated as 24 bits)
       */
      if (pp >= parts + 4)
         return -1;

      *pp++ = val, cp++;
      goto again;
   }

   /* Check for trailing characters */
   if (*cp && !isspace(*cp))
      return -1;

   *pp++ = val;

   /* Concoct the address according to the number of parts specified */
   n = pp - parts;
   switch (n)
   {
      case 1:                         /* a -- 32 bits */
         val = parts[0];
         break;

      case 2:                         /* a.b -- 8.24 bits */
         val = (parts[0] << 24) | (parts[1] & 0xffffff);
         break;

      case 3:                         /* a.b.c -- 8.8.16 bits */
         val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
               (parts[2] & 0xffff);
         break;

      case 4:                         /* a.b.c.d -- 8.8.8.8 bits */
         val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
              ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
         break;

      default:
         return -1;
   }

   val = htonl(val);

   return val;

} /* inet_addr() */

/******************************************************************************/

static _kernel_oserror *EnumMapNull(_kernel_swi_regs *r)
{
   r->r[4] = -1;

   return 0;

} /* EnumMapNull() */

/******************************************************************************/

/* EOF mnsi.c */
@


4.5
log
@Makefile recreated from fragments
Reduce proliferation of cmhg files by passing in international help switch
Remove use of module name in MNS (using cmhg's magic no-such-swi return value)

Version 6.24. Tagged as 'Net-6_24'
@
text
@d114 1
a115 2
static void mns_final(void);
extern int tick_entry();
d186 1
a186 1
_kernel_oserror *mns_init(char *cmd_tail, int pbase, void *pw)
d224 2
a225 2
   /* Install ticker code */
   e = calleverytick(tick_entry);
d229 2
a230 2
   /* Open message file for Econet */
   e = init_msgs(MSG_FILE, msg_fd_eco);
d232 1
a232 6
      goto out;

   /* Open message file for us */
   e = init_msgs(MSG_FILE1, msg_fd_mns);
   if (e)
      goto out;
a243 3
   /* Install code to tidy up on exit */
   atexit(mns_final);

d251 1
a251 1
   return (_kernel_oserror *)0;  /* return OK */
d253 2
a254 2
out:
   mns_final();
d566 1
a566 1
static void mns_final(void)
d568 1
a568 1
/* Finalisation code registered with atexit()
d579 4
a586 4
   /* Close MessageTrans message files */
   release_msgs(msg_fd_eco);
   release_msgs(msg_fd_mns);

d596 4
a599 1
   return;
d811 1
a811 2
static void mns_info(all)
int all;
d886 1
a886 4
int
src_is_ok(rx, net, station)
struct rxcb *rx;
int net, station;
d896 1
a896 3
u_long
mns_to_ip(net, station)
int net, station;
d1029 1
a1029 1
   return (_kernel_oserror *)0;
d1035 1
a1035 3
int
is_wild(port, station, network)
int port, station, network;
@


4.4
log
@Fix up a few missing header files.
Now NetI compiles as well as Net, but NetG still broken.
Trim makefile to remove dead wood, and use shared 'StdTools' and 'ModuleLibs'.
Compiles, but not tested.

Version 6.21. Tagged as 'Net-6_21'
@
text
@a114 6
#ifdef EDDS
#define MODULE_NAME "NetE"
#else
#define MODULE_NAME "NetI"
#endif

d362 1
a362 1
      return mns_error_parm(Err_BadSWI, MODULE_NAME);
d369 1
a369 1
         return mns_error_parm(Err_BadSWI, MODULE_NAME);
@


4.3
log
@ANSIized.

Version 6.20. Tagged as 'Net-6_20'
@
text
@d88 3
d95 1
d109 1
d123 1
d133 1
a133 1
static void mns_ping(int argc, char **argv);
d823 1
a823 1
mns_info(all)
@


4.2
log
@Version RO_3_71 taken
@
text
@d101 1
d179 1
d785 1
a785 1
int init_sockets()
@


4.1
log
@Initial revision
@
text
@d29 1
a29 1
 * Acorn Archimedes C release 5.02 or later.
a47 1
 *
d67 16
a82 1

d87 1
d101 1
d103 2
d106 2
a116 6
extern _kernel_oserror *call_econet();
extern _kernel_oserror *do_econet();
extern int *swi_code, *swi_data;
unsigned char machine_type = MACHINE_TYPE_ARC;

void *module_wsp = 0;
a117 1
int restarting = 0;
d123 4
a126 20
extern char *message_strs[];
extern struct eblk error_blocks[];

struct
{
   int  e_nbr;
   char e_string[36];
} ebuf = { 0 };

char textbuf[64] = { 0 };
char msg_fd_eco[16] = { 0 };
char msg_fd_mns[16] = { 0 };

struct client
{
   int (*cli_call)();      /* cli handler */
};

int mns_addmap();
int mns_showmap(), mns_showif(), mns_ping();
d138 2
a139 1
int mns_showcbs(), mns_showports();
d153 4
a156 2
struct swient {
        int (*swi_call)();      /* swi handler */
d159 1
a159 12
extern int CreateReceive(), ExamineReceive(), ReadReceive();
extern int AbandonReceive(), WaitForReception(), EnumerateReceive();
extern int StartTransmit(), PollTransmit(), AbandonTransmit();
extern int DoTransmit(), ReadLocalStationAndNet();
extern int ConvertStatusToString(), ConvertStatusToError();
extern int ReadProtection(), SetProtection(), ReadStationNumber();
extern int PrintBanner(), ReadTransportType(), ReleasePort(), AllocatePort();
extern int DeAllocatePort(), ClaimPort(), StartImmediate();
extern int DoImmediate(), AbandonAndReadReceive(), Version(), NetworkState();
extern int PacketSize(), ReadTransportName(), InetRxDirect(), EnumMapNull();
extern int EnumerateTransmit(), HardwareAddresses(), NetworkParameters();
#define MAXSWI 33
d161 1
a161 1
struct swient mns_ent[MAXSWI+1] =
d176 2
a177 1
static _kernel_oserror *mns_error_parm(int error, void *parmp);
d179 1
a179 4
extern _kernel_oserror *mns_error(), *init_econet(), *init_msgs();
extern _kernel_oserror *calleverytick(), *mns_claimv(), *mns_evenable();
extern u_long htonl(), inet_makeaddr();
extern char *inet_ntoa(), *mns_str(), *strchr();
d181 3
a183 2
static void setcallback(void);
void namtomodule(char *nm);
d185 14
a198 2
/* whether necessary modules (DCI driver and Internet) are present and OK */
static int modules_present = 0;
d200 1
a200 2
/* whether reinitialising on a callback due to a service call */
static int reinit_on_callback = 0;
d202 2
d205 2
a206 1
/******************************************************************************/
d208 1
a208 8
/*ARGS_USED*/
_kernel_oserror *
mns_init(cmd_tail, pbase, pw)
char *cmd_tail;
int pbase;
void *pw;
{
    _kernel_oserror *e = 0;
d210 27
a236 10
    module_wsp = pw;
    e = calleverytick(tick_entry);
    if (e)
        return (e);
    e = init_msgs(MSG_FILE, msg_fd_eco);
    if (e)
        goto out;
    e = init_msgs(MSG_FILE1, msg_fd_mns);
    if (e)
        goto out;
d238 1
a238 1
   /* check machine type we are running on */
d241 19
a259 8
    e = init_econet();
    if (e)
        econet_not_present = 1;
    do_mns_init(1);
    atexit(mns_final);
    restarting = 1;
    setcallback();
    return ((_kernel_oserror *)0);
d261 7
a267 3
    mns_final();
    return (e);
}
d269 1
a269 1
notify_users()
d271 11
a281 1
    _kernel_swi_regs r;
d283 34
a316 3
    r.r[1] = Service_ReAllocatePorts;
    (void) _kernel_swi(XOS_Bit | OS_ServiceCall, &r, &r);
}
a317 30
do_mns_init(booting)
int booting;
{
    _kernel_swi_regs r;
    int no_econet_clock = 0;
    int rxd, txd, atp, routed;

    rxd = booting ? -1 : mns.mns_rxdsock;
    txd = booting ? -1 : mns.mns_txdsock;
    atp = booting ? -1 : mns.mns_atpsock;
    routed = booting ? -1 : mns.mns_routedsock;
    memset((char *)&mns, 0, sizeof(mns));
    mns.mns_rxdsock    = rxd;
    mns.mns_txdsock    = txd;
    mns.mns_atpsock    = atp;
    mns.mns_routedsock = routed;
    mns.mns_txhandle   = MNS_HANDLE_BASE;
    mns.mns_rxhandle   = MNS_HANDLE_BASE;
    mns.mns_nextport   = 1;
    if (!booting)
        return;
    mns.mns_stationnumber = read_device_info(mns.mns_device, mns.mns_module,
                                             &connected_econet, &no_econet_clock,
                                             &mns.mns_segsize);
    if (connected_econet != -1) {
        mns.mns_states[connected_econet] |= ECONET_IS_CONNECTED;
        mns.mns_netnumber = connected_econet;
    }
    else
        mns.mns_stationnumber = 0;
d319 1
a319 1
    mns.mns_segsize = DFT_SEGSIZE;
d321 14
a334 6
    r.r[0] = 0; r.r[1] = 2;
    econet_transport_type = call_econet(Econet_ReadTransportType, &r) ? 2 : r.r[2];
    read_ifs(0, 0);
    if (mns.mns_ifcnt > 0)
        init_sockets();
}
d380 1
a380 53
/*ARGSUSED*/
_kernel_oserror *
mns_cli_handler(arg_string, arg_count, cmd_no, pw)
char *arg_string;
int arg_count, cmd_no;
void *pw;
{
    struct client *callp;
    int margc;
    char *margv[10];
    char *cp;
    char **argp = margv;

    margc = 0;
    cp = arg_string;
    while (*cp && arg_count-- > 0) {
        while (isspace(*cp))
            cp++;
        if (*cp == '\0')
            break;
        *argp++ = cp;
        margc++;
        while (*cp != '\0' && !isspace(*cp))
            cp++;
        if (*cp == '\0')
            break;
        *cp++ = '\0';
    }
    *argp++ = 0;
    callp = &mns_cli_call[cmd_no];
    (void)(*(callp->cli_call))(margc, margv);
    return ((_kernel_oserror *)0);
}

/*ARGSUSED*/
mns_addmap(argc, argv)
int argc;
char **argv;
{
    struct atp_block ablock;
    u_long inet_addr();

    memset(ablock.atpb_sitename, 0, 16);
    memset(ablock.atpb_netname, 0, 16);
    ablock.atpb_ipadr   = inet_addr(argv[0]) & ~0xff000000;
    ablock.atpb_net     = (u_char)atoi(argv[1]);
    ablock.atpb_station = 0;
    (void) atp_add_newitem(&ablock);
}

mns_showif(argc, argv)
int argc;
char **argv;
d382 10
a391 1
    int all = 0;
d393 1
a393 7
    if (!mns.mns_flags)
        return;
    if (argc > 0)
        all = 1;
    read_ifs(1, all);
    mns_info(all);
}
d395 1
a395 8
/*ARGSUSED*/
mns_showmap(argc, argv)
int argc;
char **argv;
{
    struct address_q *q;
    char abuf[32];
    int n;
d397 6
a402 65
    for (q = mns.mns_mapq; q; q = q->q_next) {
        sprintf(abuf, "%s", inet_ntoa(q->q_ip));
        if (n = strlen(abuf)) {
            abuf[n - 1] = 'x';
            printf("%3d.x <==> %s\n", q->q_net, abuf);
        }
    }
}

#ifdef OldCode
/*ARGSUSED*/
mns_ping(argc, argv)
int argc;
char **argv;
{
    _kernel_swi_regs r;
    int station, net;
    char b[6];

    memset(b, 0, 6);
    r.r[1] = (int)argv[0];
    if (!ReadStationNumber(&r)) {
        station = r.r[2];
        net     = r.r[3] == -1 ? 0 : r.r[3];
        r.r[0]  = 8;   /* MachinePeek */
        r.r[1]  = 0;
        r.r[2]  = station;
        r.r[3]  = net;
        r.r[4]  = (int)b;
        r.r[5]  = sizeof(b);
        r.r[6]  = 2;
        r.r[7]  = 100;
        printf("%s\n", (DoImmediate(&r) == 0 && r.r[0] == Status_Transmitted) ?
                       mns_str(Str_TxOk) : mns_str(Str_NotAcc));
        return;
    }
    printf("%s\n", mns_str(Str_GtwSta));
}
#else
mns_ping(int argc, char **argv)
{
   _kernel_swi_regs r;
   int station, net;
   char b[6];             /* <<< why not 4 bytes? */

   memset(b, 0, 6);
   r.r[1] = (int)argv[0];

   if (!ReadStationNumber(&r)) /* if sensible address on command line */
   {
      station = r.r[2];
      net     = r.r[3] == -1 ? 0 : r.r[3]; /* use 0 if no net number */
      r.r[0]  = 8;   /* MachinePeek */
      r.r[1]  = 0;
      r.r[2]  = station;
      r.r[3]  = net;
      r.r[4]  = (int)b;
      r.r[5]  = sizeof(b);
      r.r[6]  = 2;
      r.r[7]  = 100;
      printf("%s\n", (DoImmediate(&r) == 0 && r.r[0] == Status_Transmitted) ?
                       mns_str(Str_TxOk) : mns_str(Str_NotAcc));
      return;
   }
   printf("%s\n", mns_str(Str_GtwSta));    /* else print "Bad station number" */
d406 1
a406 1
} /* mns_ping() */
d408 1
a408 1
#endif
d410 1
a410 29
#ifdef DEBUG
/*ARGSUSED*/
mns_showcbs(argc, argv)
int argc;
char **argv;
{
    struct rxcb *rx;
    struct txcb *tx;

    printf("receive blocks:\n");
    for (rx = mns.mns_rxlist; rx; rx = rx->rx_next) {
        printf("    station=%d.%d, port=%x, buffer=%x, bufsize=%d, handle=%x, status=%x\n",
               rx->rx_network, rx->rx_station, rx->rx_port, rx->rx_buf,
               rx->rx_bufsize, rx->rx_handle, rx->rx_status);
    }
    for (rx = mns.mns_rxwild; rx; rx = rx->rx_next) {
        printf("    station=%d.%d, port=%x, buffer=%x, bufsize=%d, handle=%x, status=%x\n",
               rx->rx_network, rx->rx_station, rx->rx_port, rx->rx_buf,
               rx->rx_bufsize, rx->rx_handle, rx->rx_status);
    }
    printf("\ntransmit blocks:\n");
    for (tx = mns.mns_txlist; tx; tx = tx->tx_next) {
        printf("    station=%d.%d, port=%x, buffer=%x, bufsize=%d, handle=%x, status=%x\n",
               tx->tx_network, tx->tx_station, tx->tx_port, tx->tx_buf,
               tx->tx_bufsize, tx->tx_handle, tx->tx_status);
    }
}

mns_showports(int argc, char **argv)
d412 10
a421 15
   int i;

   printf("Next portnumber is %x\n\n", mns.mns_nextport);

   for (i = 1; i < 255; i++)
   {
      if ((mns.mns_states[i] & (PORTALLOCATED | PORTCLAIMED)) == 0)
         continue;

      if (mns.mns_states[i] & PORTALLOCATED)
         printf("Port %x is allocated\n", i);

      if (mns.mns_states[i] & PORTCLAIMED)
         printf("Port %x is claimed\n", i);
    }
d423 1
a423 1
} /* mns_showports() */
d425 1
a425 1
#endif
d427 2
a428 1
/******************************************************************************/
d430 2
a431 4
_kernel_oserror *mns_error(int error)
{
   _kernel_swi_regs r;
   _kernel_oserror *e;
d433 1
a433 2
   if (!error)
      return (_kernel_oserror *)0;
d435 1
a435 2
   ebuf.e_nbr = error_blocks[error].err_nbr;
   strcpy(ebuf.e_string, error_blocks[error].err_token);
d437 1
a437 2
   /* prevent unwanted parameter substitution */
   memset ((char *)&r, 0, sizeof(r));
d439 1
a439 8
   r.r[0] = (int)&ebuf;
   r.r[1] = ((error == Err_Fatal) || (error == Err_NotConf)) ?
                                              (int)msg_fd_mns : (int)msg_fd_eco;
   e = _kernel_swi(XOS_Bit | MessageTrans_ErrorLookup, &r, &r);

   return (e ? e : (_kernel_oserror *)&ebuf);

} /* mns_error() */
d443 1
a443 1
static _kernel_oserror *mns_error_parm(int error, void *parmp)
d445 10
a454 2
   _kernel_swi_regs r;
   _kernel_oserror *e;
d456 3
a458 2
   if (!error)
      return (_kernel_oserror *)0;
d460 2
a461 10
   ebuf.e_nbr = error_blocks[error].err_nbr;
   strcpy(ebuf.e_string, error_blocks[error].err_token);
   memset ((char *)&r, 0, sizeof(r));
   r.r[0] = (int)&ebuf;
   r.r[1] = ((error == Err_Fatal) || (error == Err_NotConf)) ?
                                              (int)msg_fd_mns : (int)msg_fd_eco;
   r.r[2] = (int)textbuf;
   r.r[3] = sizeof(textbuf);
   r.r[4] = (int)parmp;     /* parameter to substitute for %0 */
   e = _kernel_swi(XOS_Bit | MessageTrans_ErrorLookup, &r, &r);
d463 9
a471 1
   return (e ? e : (_kernel_oserror *)&ebuf);
d473 1
a473 18
} /* mns_error_parm() */

/******************************************************************************/

char *mns_str(int strnbr)
{
   _kernel_swi_regs r;
   _kernel_oserror *e;

   /* prevent unwanted parameter substitution */
   memset((char *)&r, 0, sizeof(r));

   memset (textbuf, 0, sizeof(textbuf));
   r.r[0] = (int)msg_fd_mns;
   r.r[1] = (int)message_strs[strnbr];
   r.r[2] = (int)textbuf;
   r.r[3] = sizeof(textbuf);
   e = _kernel_swi(XOS_Bit | MessageTrans_Lookup, &r, &r);
d475 1
a475 3
   return (e ? message_strs[strnbr] : textbuf);

} /* mns_str() */
d479 2
a480 2
generate_event(rx, handle, status, port)
int rx, handle, status, port;
d482 2
a483 1
    _kernel_swi_regs r;
d485 2
a486 6
    r.r[0] = rx ? Event_Econet_Rx : Event_Econet_Tx;
    r.r[1] = handle;
    r.r[2] = status;
    r.r[3] = port;
    (void) _kernel_swi(XOS_Bit | OS_GenerateEvent, &r, &r);
}
d488 7
a494 1
/******************************************************************************/
d496 8
a503 11
extern int callb_entry();
static volatile int callbackflag = 0;

/******************************************************************************/

static void setcallback(void)
{
   int oldstate = ensure_irqs_off();

   DEBUGP1("#setcallback()\n\r");
   if (callbackflag == 0)
d505 3
a507 5
      callbackflag = 1;

      if (callback(callb_entry) != 0)
         callbackflag = 0;
      restore_irqs(oldstate);
a508 2
   else
      restore_irqs(oldstate);
d512 1
a512 1
} /* setcallback() */
d516 1
a516 1
static void removecallback(void)
d518 1
a518 8
/* Remove any added transient callback
 *
 * Parameters:
 *    None
 *
 * Returns:
 *    None
 */
d520 2
a521 1
   _kernel_swi_regs regs;
d523 1
a523 1
   int oldstate = ensure_irqs_off();
d525 1
a525 3
   DEBUGP1("#removecallback()\n\r");

   if (callbackflag != 0)
d527 2
a528 1
      callbackflag = 0;
d530 2
a531 2
      regs.r[0] = (int) callb_entry;
      regs.r[1] = (int) module_wsp;
d533 2
a534 4
      /* Ignore any error. This will only work on RISC OS 3 or later */
      _kernel_swi(XOS_Bit | OS_RemoveCallBack, &regs, &regs);

      restore_irqs(oldstate);
a535 2
   else
      restore_irqs(oldstate);
d539 3
a541 1
} /* removecallback() */
a544 6
generate_event_on_callback(tx)
struct txcb *tx;
{
    tx->tx_callb = 1;
    setcallback();
}
d546 1
a546 20
retransmit_on_callback(tx)
struct txcb *tx;
{
    tx->tx_callb = 2;
    setcallback();
}

int callback(func)
void (* func)();
{
    _kernel_swi_regs r;

    r.r[0] = (int)func;
    r.r[1] = (int)module_wsp;
    return (_kernel_swi(XOS_Bit | OS_AddCallBack, &r, &r) != 0 ? -1 : 0);
}

/******************************************************************************/

int callb_handler(const _kernel_swi_regs *rr)
d549 1
a549 1
 * Transient Callback handler
d552 2
a553 1
 *    rr : pointer to regs structure
d556 2
a557 1
 *    Non-0 to indicate call "not processed"
a559 3
   struct txcb *tx;
   int cval = 0; /* keep compiler quiet */
   int oldstate = ensure_irqs_off();
d561 2
a562 1
   UNUSED(rr);
d564 2
a565 58
   xDEBUGP3("#-- A: %08X, %08X\n\r",
                      *(unsigned int *)0x01c00000, *(unsigned int *)0x01c00004);

   if (callbackflag == 0)
   {
      restore_irqs(oldstate);
      return 1;
   }

   callbackflag = 0;
   restore_irqs(oldstate);

   if (restarting)
   {
      restarting = 0;
      notify_users();
   }

   if (reinit_on_callback)
   {
      DEBUGP1("#reinitialising on callback\n\r");
      reinit_on_callback = 0;
      free_sockets();
      (void) do_mns_init(1);
      notify_users();
   }

   for (;;)
   {
      oldstate = ensure_irqs_off();
      for (tx = mns.mns_txlist; tx; tx = tx->tx_next)
      {
         if ((cval = tx->tx_callb) != 0)
         {
            tx->tx_callb = 0;
            break;
         }
      }
      restore_irqs(oldstate);

      if (tx == (struct txcb *)0)
         break;

      switch (cval)
      {
         case 1:
            if (tx->tx_status != Status_Free)
               generate_event(0, tx->tx_handle, tx->tx_status, tx->tx_port);
            break;

         case 2:
            retry_tx(tx);
            break;

         default:
            break;
      }
   }
d569 1
a569 70
} /* callb_handler() */

/******************************************************************************/

_kernel_oserror *
calleverytick(fun)
int (*fun)();
{
    _kernel_oserror *e;
    _kernel_swi_regs r;

    r.r[0] = TickerV;
    r.r[1] = (int)fun;
    r.r[2] = (int)module_wsp;
    e = _kernel_swi(XOS_Bit | OS_Claim, &r, &r);
    if (e)
        return (e);
    return ((_kernel_oserror *)0);
}

removetickerevent(fun)
int (*fun)();
{
    _kernel_swi_regs r;

    r.r[0] = TickerV;
    r.r[1] = (int)fun;
    r.r[2] = (int)module_wsp;
    (void) _kernel_swi(XOS_Bit | OS_Release, &r, &r);
}

tick_handler(r, pw)
int *r;
void *pw;
{
    check_rxcbs();
    check_txcbs();
    return (1);
}

int
do_getsock(port, inputsocket, direct)
int port, inputsocket, direct;
{
    struct sockaddr_in addr;
    int sock, arg, on = 1;

    if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        return (-1);
    }
    arg = direct ? Econet_InetRxDirect : 1;
    if (socketioctl(sock, FIONBIO, &on) < 0 || socketioctl(sock, direct ? FIORXDIR : FIOASYNC, &arg) < 0) {
        socketclose (sock);
        return (-1);
    }
    if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &on, sizeof (on)) < 0) {
        socketclose(sock);
        return (-1);
    }
    if (inputsocket) {
        addr.sin_family      = AF_INET;
        addr.sin_addr.s_addr = htonl(INADDR_ANY);
        addr.sin_port        = htons((u_short)port);
        if (bind(sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {
            socketclose(sock);
            return (-1);
        }
    }
    return (sock);
}
d609 1
a609 1
void mns_sc_handler(int sn, _kernel_swi_regs *r)
d612 1
a612 1
 * cmhg module service call handler
d615 2
a616 2
 *    sn : service call number
 *    r  : pointer to registers block
d622 16
a637 1
   DEBUGP2("#Service_handler: &%X\r\n", r->r[1]);
d639 2
a640 1
   switch (sn)
d642 55
a696 7
      case Service_MessageFileClosed:
         if (r->r[0] == (int)msg_fd_eco)
            (void) init_msgs(MSG_FILE, msg_fd_eco);
         else if (r->r[0] == (int)msg_fd_mns)
            (void) init_msgs(MSG_FILE1, msg_fd_mns);
         return;
         break;
d698 2
d701 10
a710 7
      case Service_DCIDriverStatus:
         DEBUGP2("#Service_DCIDriverStatus: %d\n\r", r->r[2]);
        /* whether it is our driver, or not, whether starting or stopping,
         * if there are now suitable modules present, reinitialise and
         * connect to them, else reinitialise unconnected.
         */
         if (modules_present = check_present(), modules_present)
d712 2
a713 3
            reinit_on_callback = 1;
            setcallback();
            return;
d715 24
a738 6
         else
         {
            (void) do_mns_init(0);
            return;
         }
         break;
d740 1
a740 26
     case Service_DCIProtocolStatus:
         DEBUGP2("#Service_DCIProtocolStatus: %d\n\r", r->r[2]);
         /* If it's not the Internet module, do nothing */
         if (strcmp((char *)r->r[4], INTERNET_MODULE_NAME) != 0)
            return;
        /* else it is the Internet module. If starting, reinitialise if device
         * driver present as well
         */
         if (r->r[2] == 0)
         {
            if (modules_present = check_present(), modules_present)
            {
               reinit_on_callback = 1;
               setcallback();
               return;
            }
         }
         else
            if (r->r[2] == 1)
            {
               /* Internet is dying, so go dormant */
               modules_present = 0;
               (void) do_mns_init(0);
               return;
            }
         break;
d742 4
d747 4
a750 7
      case Service_Reset:
         /* Post-reset: if a soft reset, reinitialise, else do nothing */
         DEBUGP1("#Service_reset\n\r");
         if (!reset_is_soft())
            return;
         DEBUGP1("#Service_reset, was a soft reset, reinitialising\n\r");
         (void) do_mns_init(0);
d752 2
a753 1
         break;
d755 4
a758 7

      case Service_EconetDying:
         /* The real Econet module is dying, reinitialise */
         econet_not_present = 1;
         connected_econet = -1;
         reinit_on_callback = 1;
         setcallback();
a759 1
         break;
d761 4
d766 9
a774 5
      default:
         /* shouldn't really get here, but do nothing */
         return;
         break;
    }
d778 2
a779 1
} /* mns_sc_handler() */
d783 1
a783 1
int reset_is_soft()
d785 2
a786 1
    _kernel_swi_regs r;
d788 8
a795 5
    r.r[0] = 253;
    r.r[1] = 0;
    r.r[2] = 255;
    return ((_kernel_swi(XOS_Bit | OS_Byte, &r, &r) != 0 || r.r[1] == 0) ? 1 : 0);
}
d797 1
a797 10
read_ifs(print, all)
int print, all;
{
    int s, n, eco, no_econet_clock;
    char buf[512], name[12];
    struct ifconf ifc;
    struct ifreq ifreq, *ifr;
    struct sockaddr_in *sin;
    u_long addr;
    int inmap, net, station, first = 1;
d799 1
a799 69
    if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
        return;
    ifc.ifc_len = sizeof (buf);
    ifc.ifc_buf = buf;
    if (socketioctl(s, SIOCGIFCONF, (char *)&ifc) < 0) {
        socketclose(s);
        return;
    }
    if (print && connected_econet != -1) {
        (void) read_eco_info(&connected_econet, &no_econet_clock);
        printf("%-18s", mns_str(Str_NtvEco));
        printf("%d.%d", connected_econet, mns.mns_stationnumber);
        if (no_econet_clock)
            printf(" (%s)", mns_str(Str_Noclck));
        printf("\n\n");
    }
    mns.mns_ifcnt = 0;
    mns.mns_econetipadr = 0;
    ifr = ifc.ifc_req;
    for (n = ifc.ifc_len / sizeof (struct ifreq); n > 0; n--, ifr++) {
        ifreq = *ifr;
        if (socketioctl(s, SIOCGIFFLAGS, (char *)&ifreq) < 0 || ifreq.ifr_flags & IFF_LOOPBACK)
            continue;
        if (print) {
            if (!first)
                printf("\n");
            printf("\n%-18s", mns_str(Str_IfType));
        }
        eco = strcmp(ifreq.ifr_name, "ec0") == 0 ? 1 : 0;
        if (print) {
            strcpy(name, ifreq.ifr_name);
            name[strlen(name) - 1] = 0;
            namtomodule(name);
            printf("%s ", name);
        }
        if ((ifreq.ifr_flags & (IFF_BROADCAST|IFF_UP)) != (IFF_BROADCAST|IFF_UP)) {
            if (print)
                printf("(%s)\n", mns_str(Str_Down));
            goto next;
        }
        if (print)
            printf("\n");
        if (socketioctl(s, SIOCGIFADDR, (char *)&ifreq) < 0)
            goto next;
        sin = (struct sockaddr_in *)&ifreq.ifr_addr;
        addr = ntohl(sin->sin_addr.s_addr);
        inmap = ip_to_mns(sin->sin_addr.s_addr, &net, &station);
        if (inmap && station != 0 && station != ALL_ONES) {
            if (mns.mns_stationnumber == 0) {
                mns.mns_stationnumber = station;
                mns.mns_netnumber = net;
            }
            if (print)
               printf("%-18s%d.%d\n", mns_str(Str_StaNum), net, station);
        }
        if (print && all)
               printf("%-18s%s\n", mns_str(Str_FullAd), inet_ntoa(sin->sin_addr));
        if (socketioctl(s, SIOCGIFBRDADDR, (char *)&ifreq) < 0)
            goto next;
        sin = (struct sockaddr_in *)&ifreq.ifr_addr;
        if (print && all)
            printf("%-18s%s\n", mns_str(Str_BrdCst), inet_ntoa(sin->sin_addr));
        mns.mns_ifaddrs[(mns.mns_ifcnt)++] = sin->sin_addr.s_addr;
next:
        first = 0;
    }
    socketclose(s);
    return;
}
d801 1
a801 3
int
atp_add_newitem(a)
struct atp_block *a;
d803 2
a804 3
    struct address_q *q;
    char *malloc();
    struct address_q **p;
d806 2
a807 24
    p = &(mns.mns_mapq);
    while (*p) {
        if ((*p)->q_ip == a->atpb_ipadr)
            return(0);
        p = &((*p)->q_next);
    }
    if ((*p) == 0) {
        q = (struct address_q *)malloc (sizeof(struct address_q));
        if (q == (struct address_q *)0)
            return (-1);
        q->q_bcast = 0;
        q->q_next = (struct address_q *)0;
        *p = q;
    }
    q->q_net     = a->atpb_net;
    q->q_ip      = a->atpb_ipadr;
    memcpy(q->q_sitename, a->atpb_sitename, ITEM_NAMELEN);
    memcpy(q->q_netname, a->atpb_netname, ITEM_NAMELEN);
    if ((mns.mns_states[q->q_net] & ECONET_IS_CONNECTED) == 0)
        mns.mns_states[q->q_net] |= MNS_IS_CONNECTED;
    if (mns.mns_stationnumber == 0)
        read_ifs(0, 0);
    return (0);
}
d809 1
d811 1
a811 11
int init_sockets()
{
    if (mns.mns_flags & MNS_SOCKET)
        return (0);
    mns.mns_rxdsock = do_getsock(MNSDATAPORT, 1, 1);
    if (mns.mns_rxdsock < 0)
        return (-1);
    mns.mns_txdsock = do_getsock(MNSDATAPORT, 0, 0);
    mns.mns_flags |= MNS_SOCKET;
    return (0);
}
d813 1
a813 7
free_sockets()
{
    if (mns.mns_rxdsock != -1)
        (void) socketclose(mns.mns_rxdsock);
    if (mns.mns_txdsock != -1)
        (void) socketclose(mns.mns_txdsock);
}
d865 3
a867 5
int
ip_to_mns(addr, net, station)
u_long addr;
u_int *net;
int *station;
d869 19
a887 2
    struct address_q *q;
    u_long i, m;
d889 1
a889 13
    i = ntohl(addr);
    m = i & ~0xff;
    for (q = mns.mns_mapq; q; q = q->q_next) {
        if (m == htonl(q->q_ip)) {
            *station = i & 0xff;
            *net = (int)q->q_net;
            return(1);
        }
    }
    *net = (u_int)addr;
    *station = ALL_ONES;
    return (1);
}
d926 18
a943 17
int
msg_broadcast(flag, port, data, len, local)
u_char flag, port;
char *data;
int len, local;
{
    int i;

    for (i = 0; i < mns.mns_ifcnt; i++)
        (void) msg_transmit(mns.mns_ifaddrs[i], flag, 0, port, data, len, BROADCAST_DATA_FRAME, 0);
    if (local)
        mns.mns_txlbc++;
    else
        mns.mns_txgbc++;
    mns.mns_txbccnt++;
    return (0);
}
d958 2
a959 1
 *    nm : still points to the string, now holding the module name
d965 1
a965 1
   struct chaindib *chdp;
d969 6
a974 2
   e = _kernel_swi(XOS_Bit | OS_ServiceCall, &r, &r);
   if (e == 0 && (chdp = (struct chaindib *)(r.r[0])) != (struct chaindib *)0)
d976 1
d978 2
a979 1
      if (strcmp(d->dib_name, nm) == 0)
d981 17
a997 4
         r.r[0] = 0;
         e = _kernel_swi(XOS_Bit | (d->dib_swibase + DCI4Version), &r, &r);
         if (!e && r.r[1] >= CURRENT_DCI_VERSION)
         strncpy(nm, d->dib_module, 24);
d999 1
d1006 1
a1006 1
         if (e = _kernel_swi(XOS_Bit | OS_Module, &r, &r), e != 0);
d1018 11
a1028 3
int
in_local_aun_network(net)
int net;
d1030 12
a1041 2
    return (0);
}
d1043 1
a1043 12
_kernel_oserror *
range_check(port, station, net)
int port, station, net;
{
    if (port < 0 || port > 255)
        return(mns_error(Err_BadPort));
    if (station != ALL_ONES && (station < 0 || station > 255))
        return(mns_error(Err_BadStn));
    if (station != ALL_ONES && (net < 0 || net > 255))
        return(mns_error(Err_BadNet));
    return ((_kernel_oserror *)0);
}
d1057 4
d1065 4
a1068 7
u_long
inet_addr(cp)
        register char *cp;
{
        u_long val, base, n;
        char c;
        u_long parts[4], *pp = parts;
a1070 65
        /*
         * Collect number up to ``.''.
         * Values are specified as for C:
         * 0x=hex, 0=octal, other=decimal.
         */
        val = 0; base = 10;
        if (*cp == '0')
                base = 8, cp++;
        if (*cp == 'x' || *cp == 'X')
                base = 16, cp++;
        while (c = *cp) {
                if (isdigit(c)) {
                        val = (val * base) + (c - '0');
                        cp++;
                        continue;
                }
                if (base == 16 && isxdigit(c)) {
                        val = (val << 4) + (c + 10 - (islower(c) ? 'a' : 'A'));
                        cp++;
                        continue;
                }
                break;
        }
        if (*cp == '.') {
                /*
                 * Internet format:
                 *      a.b.c.d
                 *      a.b.c   (with c treated as 16-bits)
                 *      a.b     (with b treated as 24 bits)
                 */
                if (pp >= parts + 4)
                        return (-1);
                *pp++ = val, cp++;
                goto again;
        }
        /*
         * Check for trailing characters.
         */
        if (*cp && !isspace(*cp))
                return (-1);
        *pp++ = val;
        /*
         * Concoct the address according to
         * the number of parts specified.
         */
        n = pp - parts;
        switch (n) {

        case 1:                         /* a -- 32 bits */
                val = parts[0];
                break;

        case 2:                         /* a.b -- 8.24 bits */
                val = (parts[0] << 24) | (parts[1] & 0xffffff);
                break;

        case 3:                         /* a.b.c -- 8.8.16 bits */
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                        (parts[2] & 0xffff);
                break;

        case 4:                         /* a.b.c.d -- 8.8.8.8 bits */
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                      ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
                break;
d1072 81
a1152 6
        default:
                return (-1);
        }
        val = htonl(val);
        return (val);
}
d1154 1
a1154 2
int EnumMapNull(r)
_kernel_swi_regs *r;
d1156 5
a1160 3
    r->r[4] = -1;
    return (0);
}
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d29 1
a29 1
 * Acorn Archimedes C release 5.06 or later.
d48 1
d68 1
a68 16
 *
 * 14-Mar-95  15:37  JPD  Version 1.05
 * Moved some code to mnscommon.c. Now compilable -fah. Keep *Addmaps info
 * across a self_imposed reinitialisation.
 *
 * 21-Mar-95  18:17  JPD  Version 1.06
 * Moved mns_sc_handler() and reset_is_soft() to mnscommon.c.
 *
 * 04-Oct-95  10:05  JPD  Version 1.07
 * Corrected some extern declarations: added #include <string.h>, had to add
 * a cast to correct compiler warning as a consequence. Corrected some
 * comments: should not change code.
 *
 * 06-Oct-95  10:34  JPD  Version 1.03
 * Moved machine_type and modules_present to mnscommon.c.
 *
a72 1
#include <string.h>
a85 1
#include "netasm.h"
a86 2
#include "mns.h"
#include "mnscommon.h"
a87 2
#include "text.h"
#include "swicode.h"
d97 6
d104 1
d110 20
a129 4
static void mns_showmap(int argc, char **argv);
static void mns_addmap(int argc, char **argv);
static void mns_showif(int argc, char **argv);
static void mns_ping(int argc, char **argv);
d141 1
a141 2
static void mns_showcbs(int argc, char **argv);
static void mns_showports(int argc, char **argv);
d155 2
a156 4
#define MAXSWI 33
struct swient
{
   _kernel_oserror *(*swi_call)(_kernel_swi_regs *);      /* SWI handler */
d159 12
a170 1
static _kernel_oserror *EnumMapNull(_kernel_swi_regs *r);
d172 1
a172 1
static struct swient mns_ent[MAXSWI+1] =
d187 1
a187 2
static void read_ifs(int print, int all);
static void atp_add_newitem(struct atp_block *a);
d189 4
a192 1
static u_long inet_addr(register char *cp);
d194 2
a195 3
static void namtomodule(char *nm);

/******************************************************************************/
d197 2
a198 14
_kernel_oserror *mns_init(char *cmd_tail, int pbase, void *pw)
{
/*
 * cmhg module initialisation entry
 *
 * Parameters:
 *    cmd_tail : pointer to command line tail
 *    pbase    : 0 unless code invoked from a podule
 *    pw       : "R12" value established by module initialisation
 *
 * Returns:
 *     0 : => successfully initialised
 *    !0 : => a problem, pointer to standard RISC OS error block
 */
d200 2
a201 1
   _kernel_oserror *e;
a202 2
   UNUSED(pbase);
   UNUSED(cmd_tail);
d204 1
a204 2
   /* take note of our workspace pointer for future use */
   module_wsp = pw;
d206 8
a213 1
   DEBUGP1("\n\r#module initialisation\n\r");
d215 10
a224 27
   xDEBUGP2("#pbase = %08X\n\r", pbase);

   xDEBUGP5("#-- 1: %08X, %08X, %08X, %08X\n\r",
                   *(unsigned int *)0x01c00000, *(unsigned int *)0x01c00004,
                   ((*((unsigned int **)pw)))[1],((*((unsigned int **)pw)))[2]);

   /* This must really be done now, cannot wait for do_mns_init() */
   memset((char *)&mns, 0, sizeof(mns));
   mns.mns_rxdsock = -1;
   mns.mns_txdsock = -1;
   mns.mns_atpsock = -1;
   mns.mns_routedsock = -1;

   /* Install ticker code */
   e = calleverytick(tick_entry);
   if (e)
      return e;

   /* Open message file for Econet */
   e = init_msgs(MSG_FILE, msg_fd_eco);
   if (e)
      goto out;

   /* Open message file for us */
   e = init_msgs(MSG_FILE1, msg_fd_mns);
   if (e)
      goto out;
d226 1
a226 1
   /* check machine type we are running on for later machine type peek */
d229 8
a236 19
   /* Find real Econet module so SWIs can be handed on to it */
   e = init_econet();
   if (e)
      econet_not_present = 1;

   do_mns_init(1);

   /* Install code to tidy up on exit */
   atexit(mns_final);

  /* set flag and set a Callback, so that the service call to say that
   * "Econet" has been reinitialised will be issued on a Callback after this
   * initialisation has completed.
   */
   restarting = 1;
   setcallback();

   return (_kernel_oserror *)0;  /* return OK */

d238 3
a240 1
   mns_final();
d242 3
a244 1
   return e;
d246 3
a248 1
} /* mns_init() */
d250 2
a251 3
/******************************************************************************/

int do_mns_init(int booting)
d253 27
a279 47
/*
 * Perform initialisation
 *
 * Parameters:
 *    booting : !0 => initialisation for first time
 *               0 => reinitialisation as result of service call
 *
 * Returns:
 *    !0 : => successfully initialised
 *     0 : => either a problem, or reinitialised
 */

   _kernel_swi_regs r;
   int no_econet_clock = 0;
   int rxd, txd, atp, routed;
   struct address_q *q;

   rxd = booting ? -1 : mns.mns_rxdsock;
   txd = booting ? -1 : mns.mns_txdsock;
   atp = booting ? -1 : mns.mns_atpsock;
   routed = booting ? -1 : mns.mns_routedsock;
   q = mns.mns_mapq;

   memset((char *)&mns, 0, sizeof(mns));
   mns.mns_rxdsock    = rxd;
   mns.mns_txdsock    = txd;
   mns.mns_atpsock    = atp;
   mns.mns_routedsock = routed;
   mns.mns_txhandle   = MNS_HANDLE_BASE;
   mns.mns_rxhandle   = MNS_HANDLE_BASE;
   mns.mns_nextport   = 1;
   mns.mns_mapq       = q;

   if (!booting)
      return 0;

   mns.mns_stationnumber = read_device_info(mns.mns_device, mns.mns_module,
                                            &connected_econet, &no_econet_clock,
                                            &mns.mns_segsize);
   if (connected_econet != -1)
   {
      mns.mns_states[connected_econet] |= ECONET_IS_CONNECTED;
      mns.mns_netnumber = connected_econet;
   }
   else
      mns.mns_stationnumber = 0;

d281 1
a281 1
   mns.mns_segsize = DFT_SEGSIZE;
d283 6
a288 14

   /* Read the actual transport type for the "Econet" */
   r.r[0] = 0;
   r.r[1] = 2;
   econet_transport_type =
                         call_econet(Econet_ReadTransportType, &r) ? 2 : r.r[2];
   read_ifs(0, 0);

   if (mns.mns_ifcnt > 0)
      init_sockets();

   return 0;

} /* do_mns_init() */
d334 53
a386 1
static void mns_addmap(int argc, char **argv)
d388 1
a388 10
/*
 * *AddMap code
 *
 * Parameters:
 *    argc : }
 *    argv : } command line parms
 *
 * Returns:
 *    None
 */
d390 7
a396 1
   struct atp_block ablock;
d398 8
a405 1
   UNUSED(argc);
d407 65
a471 6
   memset(ablock.atpb_sitename, 0, 16);
   memset(ablock.atpb_netname, 0, 16);
   ablock.atpb_ipadr   = inet_addr(argv[0]) & ~0xff000000;
   ablock.atpb_net     = (u_char)atoi(argv[1]);
   ablock.atpb_station = 0;
   atp_add_newitem(&ablock);
d475 53
a527 1
} /* mns_addmap() */
d531 1
a531 1
static void mns_showif(int argc, char **argv)
d533 16
a548 10
/*
 * *NetStat code
 *
 * Parameters:
 *    argc : }
 *    argv : } command line parms
 *
 * Returns:
 *    None
 */
d550 1
a550 1
   int all = 0;
d552 1
a552 1
   UNUSED(argv);
d554 1
a554 2
   if (!mns.mns_flags)
      return;
d556 4
a559 2
   if (argc > 0)
      all = 1;
d561 2
a562 1
   read_ifs(1, all);
d564 10
a573 1
   mns_info(all);
d575 1
a575 1
   return;
d577 1
a577 1
} /* mns_showif() */
d581 1
a581 1
static void mns_showmap(int argc, char **argv)
d583 14
a596 10
/*
 * *NetMap code: show mapping from pseudo-Econet numbers to Internet addresses
 *
 * Parameters:
 *    argc : }
 *    argv : } command line parms (optional net number)
 *
 * Returns:
 *    None
 */
d598 1
a598 3
   struct address_q *q;
   char abuf[32];
   int n;
d600 1
a600 2
   UNUSED(argc);
   UNUSED(argv);
d602 11
a612 9
   for (q = mns.mns_mapq; q; q = q->q_next)
   {
      sprintf(abuf, "%s", inet_ntoa(q->q_ip));
      if (n = strlen(abuf))
      {
         abuf[n - 1] = 'x';
         printf("%3d.x <==> %s\n", q->q_net, abuf);
      }
   }
d614 1
a614 1
   return;
d616 2
a617 1
} /* mns_showmap() */
d621 1
a621 2
#ifdef DEBUG
static void mns_showcbs(int argc, char **argv)
d623 1
a623 2
   struct rxcb *rx;
   struct txcb *tx;
d625 2
a626 5
   UNUSED(argc);
   UNUSED(argv);

   printf("receive blocks:\n");
   for (rx = mns.mns_rxlist; rx; rx = rx->rx_next)
d628 1
a628 4
      printf("    station=%d.%d, port=%x, buffer=%x, bufsize=%d, handle=%x, status=%x\n",
            rx->rx_network, rx->rx_station, rx->rx_port, rx->rx_buf,
            rx->rx_bufsize, rx->rx_handle, rx->rx_status);
   }
d630 3
a632 12
   for (rx = mns.mns_rxwild; rx; rx = rx->rx_next)
   {
      printf("    station=%d.%d, port=%x, buffer=%x, bufsize=%d, handle=%x, status=%x\n",
            rx->rx_network, rx->rx_station, rx->rx_port, rx->rx_buf,
            rx->rx_bufsize, rx->rx_handle, rx->rx_status);
   }
   printf("\ntransmit blocks:\n");
   for (tx = mns.mns_txlist; tx; tx = tx->tx_next)
   {
      printf("    station=%d.%d, port=%x, buffer=%x, bufsize=%d, handle=%x, status=%x\n",
            tx->tx_network, tx->tx_station, tx->tx_port, tx->tx_buf,
            tx->tx_bufsize, tx->tx_handle, tx->tx_status);
d634 2
d639 1
a639 1
} /* mns_showcbs() */
d643 1
a643 1
static void mns_showports(int argc, char **argv)
d645 10
a654 1
   int i;
d656 1
a656 2
   UNUSED(argc);
   UNUSED(argv);
d658 1
a658 1
   printf("Next portnumber is %x\n\n", mns.mns_nextport);
d660 1
a660 1
   for (i = 1; i < 255; i++)
d662 4
a665 2
      if ((mns.mns_states[i] & (PORTALLOCATED | PORTCLAIMED)) == 0)
         continue;
d667 2
a668 2
      if (mns.mns_states[i] & PORTALLOCATED)
         printf("Port %x is allocated\n", i);
d670 1
a670 2
      if (mns.mns_states[i] & PORTCLAIMED)
         printf("Port %x is claimed\n", i);
d672 2
d677 22
a698 1
} /* mns_showports() */
d700 4
a703 1
#endif
d707 1
a707 2

int tick_handler(_kernel_swi_regs *r, void *pw)
d710 1
a710 1
 * cmhg ticker interrupt handler
d713 1
a713 2
 *    r  : pointer to registers block
 *    pw : "R12" value established by module initialisation
d716 1
a716 2
 *    0 => interrupt "claimed"
 *   !0 => interrupt not "claimed"
d719 5
d725 49
a773 2
   UNUSED(r);
   UNUSED(pw);
d775 8
a782 2
   check_rxcbs();
   check_txcbs();
d786 70
a855 1
} /* tick_handler() */
d895 1
a895 1
static void read_ifs(int print, int all)
d898 1
a898 1
 * Obtain information about the network interfaces
d901 2
a902 2
 *    print : !0 => display details of interfaces
 *    all   : !0 => print full information
d908 1
a908 16
   int s, n, eco, no_econet_clock;
   char buf[512], name[12];
   struct ifconf ifc;
   struct ifreq ifreq, *ifr;
   struct sockaddr_in *sin;
   u_long addr;
   int inmap, net, station, first = 1;

   DEBUGP3("#read_ifs(%d, %d)\n\r", print, all);

   /* open a socket to use to obtain details */
   if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
       return;

   ifc.ifc_len = sizeof (buf);
   ifc.ifc_buf = buf;
d910 1
a910 2
   /* get the interface info list from the Internet module */
   if (socketioctl(s, OSIOCGIFCONF, (char *)&ifc) < 0)
d912 7
a918 3
      socketclose(s);
      return;
   }
a919 10
   /* if connected to Econet, get Econet info */
   if (print && connected_econet != -1)
   {
      (void) read_eco_info(&connected_econet, &no_econet_clock);
      printf("%-18s", mns_str(Str_NtvEco));
      printf("%d.%d", connected_econet, mns.mns_stationnumber);
      if (no_econet_clock)
         printf(" (%s)", mns_str(Str_Noclck));
      printf("\n\n");
   }
d921 18
a938 33
   mns.mns_ifcnt = 0;
   mns.mns_econetipadr = 0;
   ifr = ifc.ifc_req;

   /* step forwards through interface info list */
   for (n = ifc.ifc_len / sizeof (struct ifreq); n > 0; n--, ifr++)
   {
      if (((struct osockaddr *)&ifr->ifr_addr)->sa_family != AF_INET)
         continue;

      ifreq = *ifr;
      /* Ignore the loopback interface */
      if (socketioctl(s, SIOCGIFFLAGS, (char *)&ifreq) < 0 ||
                                                 ifreq.ifr_flags & IFF_LOOPBACK)
         continue;

      if (print)
      {
         if (!first)
            printf("\n");
         /* Print "Interface" */
         printf("\n%-18s", mns_str(Str_IfType));
      }

      eco = strcmp(ifreq.ifr_name, "ec0") == 0 ? 1 : 0;

      if (print)
      {
         strcpy(name, ifreq.ifr_name);
         name[strlen(name) - 1] = 0;
         namtomodule(name);
         printf("%s ", name);
      }
d940 9
a948 20
      if ((ifreq.ifr_flags & (IFF_BROADCAST|IFF_UP)) != (IFF_BROADCAST|IFF_UP))
      {
         if (print)
            printf("(%s)\n", mns_str(Str_Down));
         goto next;
      }

      if (print)
         printf("\n");

      /* get interface Internet address */
      if (socketioctl(s, SIOCGIFADDR, (char *)&ifreq) < 0)
         goto next;

      sin = (struct sockaddr_in *)&ifreq.ifr_addr;
      addr = ntohl(sin->sin_addr.s_addr);
      inmap = ip_to_mns(sin->sin_addr.s_addr, &net, &station);
      if (inmap && station != 0 && station != ALL_ONES)
      {
         if (mns.mns_stationnumber == 0)
d950 6
a955 2
            mns.mns_stationnumber = station;
            mns.mns_netnumber = net;
d957 9
a965 3
         if (print)
            printf("%-18s%d.%d\n", mns_str(Str_StaNum), net, station);
      }
a966 15
      if (print && all)
         printf("%-18s%s\n", mns_str(Str_FullAd),
                                        inet_ntoa(*((u_long *)&sin->sin_addr)));

      /* get Internet broadcast address for interface */
      if (socketioctl(s, SIOCGIFBRDADDR, (char *)&ifreq) < 0)
          goto next;

      sin = (struct sockaddr_in *)&ifreq.ifr_addr;
      if (print && all)
          printf("%-18s%s\n", mns_str(Str_BrdCst), inet_ntoa(sin->sin_addr));
      mns.mns_ifaddrs[(mns.mns_ifcnt)++] = sin->sin_addr.s_addr;
next:
      first = 0;
   }
d968 9
a976 2
   socketclose(s);
   return;
a977 1
} /* read_ifs() */
d979 8
a986 1
/******************************************************************************/
a987 4
static void atp_add_newitem(struct atp_block *a)
{
   struct address_q *q;
   struct address_q **p;
d989 2
a990 4
   p = &(mns.mns_mapq);
   while (*p)
   {
      if ((*p)->q_ip == a->atpb_ipadr)
d992 2
a993 23
      p = &((*p)->q_next);
   }

   if ((*p) == 0)
   {
      q = (struct address_q *)malloc (sizeof(struct address_q));
      if (q == (struct address_q *)0)
         return;

      q->q_bcast = 0;
      q->q_next = (struct address_q *)0;
      *p = q;
   }

   q->q_net = a->atpb_net;
   q->q_ip  = a->atpb_ipadr;
   memcpy(q->q_sitename, a->atpb_sitename, ITEM_NAMELEN);
   memcpy(q->q_netname, a->atpb_netname, ITEM_NAMELEN);

   if ((mns.mns_states[q->q_net] & ECONET_IS_CONNECTED) == 0)
      mns.mns_states[q->q_net] |= MNS_IS_CONNECTED;
   if (mns.mns_stationnumber == 0)
      read_ifs(0, 0);
d997 1
a997 2
} /* atp_add_newitem() */

d1001 1
a1001 1
int init_sockets()
d1003 1
a1003 2
   if (mns.mns_flags & MNS_SOCKET)
      return 0;
d1005 5
a1009 3
   mns.mns_rxdsock = do_getsock(MNSDATAPORT, 1, 1);
   if (mns.mns_rxdsock < 0)
      return -1;
d1011 10
a1020 2
   mns.mns_txdsock = do_getsock(MNSDATAPORT, 0, 0);
   mns.mns_flags |= MNS_SOCKET;
d1022 69
a1090 1
   return 0;
d1092 3
a1094 5
} /* init_sockets() */

/******************************************************************************/

void free_sockets(void)
d1096 3
a1098 2
   if (mns.mns_rxdsock != -1)
      (void) socketclose(mns.mns_rxdsock);
d1100 24
a1123 2
   if (mns.mns_txdsock != -1)
      (void) socketclose(mns.mns_txdsock);
a1124 1
   return;
d1126 11
a1136 1
} /* free_sockets() */
d1138 7
a1144 1
/******************************************************************************/
d1196 5
a1200 3
/******************************************************************************/

int ip_to_mns(u_long addr, int *net, int *station)
d1202 2
a1203 2
   struct address_q *q;
   u_long i, m;
d1205 13
a1217 18
   i = ntohl(addr);
   m = i & ~0xff;
   for (q = mns.mns_mapq; q; q = q->q_next)
   {
      if (m == htonl(q->q_ip)) {
         *station = i & 0xff;
         *net = (int)q->q_net;
         return 1;
      }
   }
   *net = (u_int)addr;
   *station = ALL_ONES;

   return 1;

} /* ip_to_mns() */

/******************************************************************************/
d1254 17
a1270 18
/******************************************************************************/

int msg_broadcast(u_char flag, u_char port, char *data, int len, int local)
{
   int i;

   for (i = 0; i < mns.mns_ifcnt; i++)
      (void) msg_transmit(mns.mns_ifaddrs[i], flag, 0, port, data, len,
                                                       BROADCAST_DATA_FRAME, 0);
   if (local)
      mns.mns_txlbc++;
   else
      mns.mns_txgbc++;
   mns.mns_txbccnt++;

   return 0;

} /* msg_broadcast() */
d1285 1
a1285 2
 *    nm : still points to the string, now holding the module name,
 *         e.g. "Ether2"
d1291 1
a1291 1
   struct chaindib *chdp, *n;
d1295 2
a1296 6
   /* Issue service call to find all DCI4 drivers */
   e = _kernel_swi(OS_ServiceCall, &r, &r);


   /* if no error issuing service call and received a response */
   if ((e == 0) && (chdp = (struct chaindib *)(r.r[0]), chdp != 0))
a1297 1
      n = chdp->chd_next;
d1299 1
a1299 2

      while (d != 0)
d1301 4
a1304 17
         if (strcmp((char *)d->dib_name, nm) == 0)
         {
            r.r[0] = 0;
            e = _kernel_swi(d->dib_swibase + DCI4Version, &r, &r);
            if (!e && r.r[1] >= MINIMUM_DCI_VERSION)
               strncpy(nm, (char *)d->dib_module, 24);
            break;
         }
         else
         {
            if (n == 0)
               break;

            /* step on */
            d = n->chd_dib;
            n = n->chd_next;
         }
a1305 1

d1312 1
a1312 1
         if (e = _kernel_swi(OS_Module, &r, &r), e != 0);
d1324 3
a1326 1
int in_local_aun_network(int net)
d1328 2
a1329 1
   UNUSED(net);
d1331 12
a1342 22
   return 0;

}  /* in_local_aun_network() */

/******************************************************************************/

_kernel_oserror *range_check(int port, int station, int net)
{
   if (port < 0 || port > 255)
      return mns_error(Err_BadPort);

   if (station != ALL_ONES && (station < 0 || station > 255))
      return mns_error(Err_BadStn);

   if (station != ALL_ONES && (net < 0 || net > 255))
      return mns_error(Err_BadNet);

   return (_kernel_oserror *)0;

} /* range_check() */

/******************************************************************************/
a1355 4
/******************************************************************************/

static u_long inet_addr(register char *cp)
{
d1360 7
a1366 4

   u_long val, base, n;
   char c;
   u_long parts[4], *pp = parts;
d1369 65
d1435 6
a1440 64
  /*
   * Collect number up to ``.''.
   * Values are specified as for C:
   * 0x=hex, 0=octal, other=decimal.
   */
   val = 0; base = 10;
   if (*cp == '0')
      base = 8, cp++;
   if (*cp == 'x' || *cp == 'X')
      base = 16, cp++;

   while (c = *cp)
   {
      if (isdigit(c)) {
         val = (val * base) + (c - '0');
         cp++;
         continue;
      }
      if (base == 16 && isxdigit(c))
      {
         val = (val << 4) + (c + 10 - (islower(c) ? 'a' : 'A'));
         cp++;
         continue;
      }
      break;
   }

   if (*cp == '.')
   {
      /*
       * Internet format:
       *      a.b.c.d
       *      a.b.c   (with c treated as 16-bits)
       *      a.b     (with b treated as 24 bits)
       */
      if (pp >= parts + 4)
         return -1;

      *pp++ = val, cp++;
      goto again;
   }

   /* Check for trailing characters */
   if (*cp && !isspace(*cp))
      return -1;

   *pp++ = val;

   /* Concoct the address according to the number of parts specified */
   n = pp - parts;
   switch (n)
   {
      case 1:                         /* a -- 32 bits */
         val = parts[0];
         break;

      case 2:                         /* a.b -- 8.24 bits */
         val = (parts[0] << 24) | (parts[1] & 0xffffff);
         break;

      case 3:                         /* a.b.c -- 8.8.16 bits */
         val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
               (parts[2] & 0xffff);
         break;
d1442 2
a1443 18
      case 4:                         /* a.b.c.d -- 8.8.8.8 bits */
         val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
              ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
         break;

      default:
         return -1;
   }

   val = htonl(val);

   return val;

} /* inet_addr() */

/******************************************************************************/

static _kernel_oserror *EnumMapNull(_kernel_swi_regs *r)
d1445 3
a1447 5
   r->r[4] = -1;

   return 0;

} /* EnumMapNull() */
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

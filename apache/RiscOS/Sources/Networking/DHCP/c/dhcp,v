head	1.16;
access;
symbols
	DHCP-0_27:1.16
	DHCP-0_26:1.16
	DHCP-0_25:1.16
	DHCP-0_24:1.15
	DHCP-0_23:1.14
	DHCP-0_22:1.12
	RO_5_07:1.11
	DHCP-0_21:1.11
	DHCP-0_20:1.11
	DHCP-0_19:1.11
	DHCP-0_18:1.11
	dellis_autobuild_BaseSW:1.11
	DHCP-0_17:1.11
	DHCP-0_16:1.11
	DHCP-0_15:1.10
	sbrodie_sedwards_16Mar2000:1.10
	DHCP-0_14:1.10
	DHCP-0_13:1.9
	DHCP-0_12:1.9
	dcotton_autobuild_BaseSW:1.11
	DHCP-0_11:1.9
	DHCP-0_10:1.9
	DHCP-0_09:1.7
	DHCP-0_08:1.7
	DHCP-0_07:1.7
	DHCP-0_06:1.6
	DHCP-0_05:1.5
	DHCP-0_04:1.4
	DHCP-0_03:1.3
	DHCP-0_02:1.2
	DHCP-0_01:1.2
	DHCP-0_00:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.16
date	2013.09.05.19.23.06;	author rsprowson;	state Exp;
branches;
next	1.15;
commitid	U4CSaZZlAOLfEh4x;

1.15
date	2013.09.04.07.10.38;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	Mw18urjsIckYC54x;

1.14
date	2012.09.15.10.27.17;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	axcbDoyNNXkO5Ckw;

1.13
date	2012.07.20.11.12.21;	author rgriffin;	state Exp;
branches;
next	1.12;
commitid	Me55MBo8gjiOaidw;

1.12
date	2012.07.19.10.27.42;	author rgriffin;	state Exp;
branches;
next	1.11;
commitid	MFH9W84jn7sEX9dw;

1.11
date	2000.04.27.09.49.29;	author sbrodie;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.14.12.45.41;	author sbrodie;	state Exp;
branches;
next	1.9;

1.9
date	99.07.22.16.00.48;	author kbracey;	state Exp;
branches;
next	1.8;

1.8
date	99.07.09.09.27.20;	author kbracey;	state Exp;
branches;
next	1.7;

1.7
date	99.06.28.14.04.03;	author kbracey;	state Exp;
branches;
next	1.6;

1.6
date	99.06.25.14.01.11;	author kbracey;	state Exp;
branches;
next	1.5;

1.5
date	99.06.25.13.24.45;	author sbrodie;	state Exp;
branches;
next	1.4;

1.4
date	99.06.11.15.45.50;	author sbrodie;	state Exp;
branches;
next	1.3;

1.3
date	99.06.10.12.08.56;	author sbrodie;	state Exp;
branches;
next	1.2;

1.2
date	99.03.30.12.41.14;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	99.03.26.16.10.18;	author sbrodie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.03.26.16.10.18;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Internationalised

Version 0.25. Tagged as 'DHCP-0_25'
@
text
@/* Copyright 1999 Element 14 Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 *  DHCP (dhcp.c)
 *
 * Copyright (C) Element 14 Ltd. 1999
 *
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <stdbool.h>
#include "kernel.h"
#include "swis.h"

#include "sys/types.h"
#include "sys/socket.h"
#include "sys/dcistructs.h"
#include "net/if.h"
#include "protocols/dhcp.h"
#include "netinet/in.h"
#include "arpa/inet.h"

#include "dhcpintern.h"
#include "interfaces.h"
#include "packets.h"
#include "consts.h"
#include "module.h"
#include "sockets.h"
#include "dhcpinform.h"
#include "iparp.h"
#include "voting.h"


/* This routine is called whenever we receive the dynamic boot start
 * service call from the Internet module.  We try to decide what to
 * do with it, and if we intend to usurp the Internet module's BOOTP
 * and upgrade it to DHCP, we claim the service call.  Internet 5.20
 * or later is required to ensure Internet's full co-operation in this.
 *
 * We must remember to be careful because we issue this service call
 * too - and we don't want a nasty loop to develop.
 */
int dhcp_prepare_request(dhcp_start_params *dsp, void *private_word)
{
        u_char *options;
        dhcp_interface *di;

	options = dhcp_find_option(dsp->request, OPTION_END);
	if ((&dsp->request->options[dsp->request_max] - options) < 4) {
	        /* No room to insert the DHCP message type option!
	         * The best we can really do is to ignore the request :-(
	         */
	        return dhcp_IGNORE;
	}

	di = interfaces_create(dsp);
	if (di == NULL) {
	        /* Unable to create new interface structure - let's just
	         * leave things and hope that the Internet module manages
	         * to get things done.  If we already know the interface
	         * quoted, we are given the existing dhcp_interface back.
	         */
	        return dhcp_IGNORE;
	}

	if (&di->di_dhcp == dsp->request) {
	        /* This was our own service call.  We'd better ignore it */
	        return dhcp_IGNORE;
	}

        if (dhcp_find_option(dsp->request, OPTION_DHCPMESSAGETYPE) != NULL) {
                /* There is already a DHCP message type option!  We'd
                 * better ignore this message.
                 */
                return dhcp_IGNORE;
        }

	/* The returned interface may or may not be new, but we are going
	 * to take control of this one away from the Internet module.  All
	 * returns after this point must return dhcp_CLAIM.
	 */

	switch (di->state) {
		case dhcpstate_INIT:
		case dhcpstate_INITREBOOT:
		        /* A new request, so copy the packet options */
		        di->binding = *dsp->request;
		        break;

	        default:
		case dhcpstate_REBOOTING:
	        case dhcpstate_BOUND:
		case dhcpstate_REQUESTING:
	        case dhcpstate_RENEWING:
		case dhcpstate_REBINDING:
		case dhcpstate_SELECTING:
	                /* Not really interested, frankly - everything is
	                 * under control and is bouncing along merrily.
	                 */
	                break;
	}

	/* Prod the timers - at least we can claim to have done something
	 * whatever state we were in at the time this call was made.
	 */
	interfaces_reschedule(private_word);

	/* Need to block here waiting for the expiration of a timeout or
	 * the arrival of a packet.  The caller will almost certainly be
	 * the IPConfig module, so behaviour with IPConfig must be
	 * verified.
	 */
	module_idle(mir_IDLE);


	if (di->state == dhcpstate_BOUND) {
	        /* We should indicate that the interface has been
	         * successfully configured.
	         */
	        dsp->ifname = 0;
		trace(("service call intercepter: i/f is bound!\n"));
	}

	/* Tell Internet module not to bother with this request */
        return dhcp_CLAIM;
}

/* Callback routine invoked by sockets module when it has read a DHCP
 * packet from its listening datagram socket.  This routine has to work
 * out whether we need it and if so for which interface it was destined.
 * Basic integrity is guaranteed (packet is long enough, is a
 * BOOTREPLY, options well-terminated, contains a valid magic cookie).
 */
void dhcp_deliver_incoming_packet(DHCP *d, void *private_word)
{
        dhcp_interface *di = interfaces_find_by_xid(d->xid);

	/* Release the block on the original caller, thus enforcing a timeout
	 * or wakeup (in this case, a wakeup) so that the original caller's
	 * retry algorithms can function correctly.
	 */

        if (di == NULL) {
                /* Couldn't match this packet on the transaction ID */
		if (dhcpinform_deliver_incoming_packet(d, private_word)) {
		        #ifdef TRACE
		        trace(("DHCP: INFORM handler dealt with this packet\n"));
		        #endif
		}
		else {
			#ifdef TRACE
			struct in_addr a;
			memcpy(&a, &d->yiaddr, 4);
	                trace(("DHCP: unable to match ID %ld with yiaddr %s\n", d->xid, inet_ntoa(a)));
        	        #endif
		}
        }
        else if (memcmp(di->dib->dib_address, d->chaddr, d->hlen) != 0) {
                /* Cross-check the h/w address against the driver failed */
                trace(("DHCP: h/w address mismatch (%s)\n", di->di_name));
        }
        else {
                dhcp_reply_params p;
                p.ifname = di->di_name;
                p.dib = di->dib;
                p.reply = d;
                p.reply_len = sizeof(*d);
                dhcp_interpret_reply(di, &p, private_word);
        }
}

/* Second stage dispatch - we've matched up the interfaces and remembered
 * the details of the incoming packet in a convenient structure.  Now we
 * need to find the DHCP message type option so we can dispatch it to the
 * appropriate handler.
 */
void dhcp_interpret_reply(dhcp_interface *di, dhcp_reply_params *drp, void *private_word)
{
        u_char *msgtype;

	if (drp->reply == &di->binding) {
	        /* We sent this service call! Therefore this function is
	         * almost certainly currently threaded (through dhcp_ack)
	         * so we need to ignore this.
	         */
	        return;
	}

#ifdef TRACE
	else {
	        struct in_addr ia;
		(void) dhcp_find_server_identifier(drp->reply, &ia);
		trace(("Incoming DHCP message from %s\n", inet_ntoa(ia)));
	}
#endif

        msgtype = dhcp_find_option(drp->reply, OPTION_DHCPMESSAGETYPE);
	if (msgtype == NULL) {
        	/* Reply does not contain a valid DHCP message type option.
        	 * What we do with it depends on what state we're in.
	         */
	        bootp_ack(di, drp);
	}
	else if (msgtype[1] < 1) {
	        /* Corrupted message?  Length field should not be zero! */
	        return;
	}
	else switch (msgtype[2]) {
                case DHCPOFFER:
                        /* May get several of these.  We never claim
                         * these messages as that would put the Internet
                         * module into a loop.  But we have to make sure
                         * that there is an outstanding DHCPDISCOVER for
                         * the specified interface.
                         */
                        dhcp_offer(di, drp);
	                break;

                case DHCPACK:
                        /* OK - the server has accepted our DHCPREQUEST
                         * and we can now tidy up the conversation and
                         * forget about it (for dynamic leases we need
                         * to remember it for future renegotiation, but
                         * we don't do those yet)
                         */
                        dhcp_ack(di, drp);
                	break;

                case DHCPNAK:
                        /* Oh dear - the server has changed its mind about
                         * letting us have the previously suggested IP
                         * address.
                         */
                        dhcp_nak(di, drp);
                	break;

		/* The remaining message types are of no interest to us
                 * because we're just a client.
                 */
                case DHCPDISCOVER:
                case DHCPREQUEST:
                case DHCPDECLINE:
                case DHCPRELEASE:
                default:
                        break;
	}

	/* Prod the timers - at least we can claim to have done something. */
	interfaces_reschedule(private_word);
	if (di->state == dhcpstate_BOUND) {
	        module_idle(mir_WAKEUP);
	}
}

void dhcp_discover(dhcp_interface *di)
{
	/* Send the DHCP discover datagram for this interface */
        dhcp_time desired_lease = di->request_lease;
        trace(("DHCP Discover for interface %s\n", di->di_name));

        /* We need to remember that we haven't seen any offers yet */
        di->offer.op = BOOTREQUEST; /* Mark offer buffer as unused */
        di->binding.yiaddr = htonl(INADDR_ANY);

	dhcp_init_packet(di, &di->binding, DHCPDISCOVER);
	if (desired_lease != dhcp_any_lease) {
		dhcp_add_time_option(&di->di_dhcp, desired_lease, OPTION_IPADDRLEASETIME);
	}
	if (di->preferred_ip.s_addr != INADDR_ANY) {
		dhcp_add_option(&di->di_dhcp, OPTION_REQUESTEDIPADDR, sizeof(struct in_addr), &di->preferred_ip);
	}
	module_notify_dynamic_boot_start(di);
	di->first_send = interfaces_current_time();
	di->interval = discover_INITIAL_RETRY;
	di->t1 = di->first_send;
	di->t2 = di->first_send + discover_TOTAL_TIMEOUT;
	di->kill_if = dhcp_infinite_lease;
        di->state = dhcpstate_SELECTING;
        dhcp_transmit(di);
}

void dhcp_offer(dhcp_interface *di, dhcp_reply_params *drp)
{
        /* We have received an offer of an address allocation service
         * Ideally, we should remember two or three of these messages if
         * they arrive in case we get a DHCPNAK in response to the DHCPREQUEST
         * message that we are about to send, but as it is we'll just
         * hold on to the "best" offer we get until we timeout.
         */

#ifdef TRACE
	trace(("DHCPOFFER message\n"));
#endif

	if (di->state != dhcpstate_SELECTING) {
	        /* then we weren't expecting any more offers.  Of course,
	         * this may just be a "late" offer arriving - so ignore it.
	         * If we are getting the DHCP packets from our own socket,
	         * we may well be triggered by the Internet module too,
	         * so we'll take the first one that comes, thanks.
	         */
	        return;
	}
	else {
	        /* At this point, we can examine any previously arrived
	         * DHCPOFFER messages and see if it or the newly arrived one
	         * is the best one to keep.  If we prefer the one we've already
	         * got, ignore the newly arrived offer.  If we prefer it, take
	         * a copy of it.  The xid has already been matched by the
	         * dispatcher, so we are safe on that front.
	         */
	        if (dhcp_vote(di, drp->reply) == vote_PREFER) {
	                if (module_notify_dhcp_offer(di, drp->reply)) {
	                        dhcp_time limit = interfaces_current_time() + selecting_TIME_LIMIT_AFTER_FIRST_OFFER;
				di->offer = *drp->reply;
				/* Check how much longer we are expecting to wait for offers.  If it
				 * is too far into the future, then bring forward the deadline to the
				 * delay specified.
				 */
				if (di->t2 > limit) {
				        di->t2 = limit;
				}
	                }
	        }
	}
}

void dhcp_request(dhcp_interface *di, dhcp_state next_state, enum dhcprequest_opts reset_t2)
{
        /* The time has arrived to send a DHCPREQUEST message down an
         * interface.  Once we've sent the message, we go into next_state
         * to wait for replies.  next_state will be dhcpstate_REQUESTING
         * dhcpstate_REBINDING, dhcpstate_RENEWING or dhcpstate_REBOOTING.
         * The server to address is that which is in the interface's DHCP packet buffer,
         * but the request is still broadcast.  Servers recognise themselves
         * through the server identifier option.
         */
        dhcp_time desired_lease = di->request_lease;

        trace(("DHCP Request message for interface %s\n", di->di_name));

        /* The DHCPOFFER message we have chosen is in di->offer */

	di->first_send = interfaces_current_time();

        if (next_state == dhcpstate_REBOOTING) {
                dhcp_init_packet(di, NULL, DHCPREQUEST);
		dhcp_add_option(&di->di_dhcp, OPTION_REQUESTEDIPADDR, sizeof(struct in_addr), &di->preferred_ip);
		di->interval = initreboot_INITIAL_RETRY;
		di->t1 = di->first_send;
        }
        else {
	        di->temp = di->di_dhcp;
		dhcp_init_packet(di, &di->temp, DHCPREQUEST);
		if (desired_lease != dhcp_any_lease) {
			dhcp_add_time_option(&di->di_dhcp, desired_lease, OPTION_IPADDRLEASETIME);
		}
		if (next_state == dhcpstate_REQUESTING) {
			dhcp_copy_option(&di->di_dhcp, &di->offer, OPTION_SERVERIDENTIFIER);
			dhcp_add_option(&di->di_dhcp, OPTION_REQUESTEDIPADDR, sizeof(di->offer.yiaddr), &di->offer.yiaddr);
			di->di_dhcp.secs = di->temp.secs;
		}
		else {
			di->di_dhcp.secs = 0;
		}
	        di->di_dhcp.xid = di->offer.xid;
		di->interval = request_INITIAL_RETRY;
		di->t1 = di->first_send;
        }

	if (di->state == dhcpstate_SELECTING || 1) {
	        /* Only send this service call around if we are in the SELECTING state,
	         * because if we are simply attempting a renew or rebind, we already
	         * have the information.
	         */
	        /* XXX: Is that true now that we have a separate call for identifying
	         * requests?  Added the || 1 to make this call always happen
	         */
		module_notify_dhcp_request(di);
	}

	if (next_state == dhcpstate_RENEWING || next_state == dhcpstate_REBINDING) {
	        di->di_dhcp.ciaddr = di->binding.yiaddr;
	}

	if (reset_t2 == dhcprequest_set_T2) {
	        if (next_state == dhcpstate_REBINDING) {
	                di->t2 = di->kill_if;
	        }
	        else if (next_state == dhcpstate_REBOOTING) {
	                di->t2 = di->first_send + initreboot_TOTAL_TIMEOUT;
	        }
	        else {
	                di->t2 = di->first_send + request_TOTAL_TIMEOUT;
	        }
	}
        di->state = next_state;
        dhcp_transmit(di);
}

/* This routine takes two time values - they are both in centiseconds and
 * return the result in centiseconds.  If 't' is the infinite lease, the
 * result is the infinite lease.
 */
static dhcp_time dhcp_add_dhcp_time(dhcp_time t, dhcp_time base)
{
        if (t == dhcp_infinite_lease) {
                return t;
        }
        else {
                dhcp_time result = t + base;
                if (result < t || result == dhcp_infinite_lease) {
                        /* Overflow */
                        return dhcp_maximum_lease;
                }
                else {
                        return result;
                }
	}
}

void bootp_ack(dhcp_interface *di, dhcp_reply_params *drp)
{
        /* A BOOTP server has answered us.  We need to pretend that it was
         * a DHCPACK message and handle it appropriately.
         */
	trace(("BOOTP REPLY message received in state %s\n", dhcp_state_name(di)));

	switch (di->state) {
		default:
		case dhcpstate_INIT:
		case dhcpstate_INITREBOOT:
		case dhcpstate_BOUND:
			/* Not looking for an address at this point. Ignore it. */
			break;
		case dhcpstate_SELECTING:
			/* Treat this as a (not very good) DHCPOFFER for now. If no DHCP
			 * servers respond, we'll reprocess it as a DHCPACK.
			 */
			dhcp_offer(di, drp);
			break;
		case dhcpstate_REQUESTING:
			/* We want our DHCP server to respond. Ignore the non-DHCP server. */
			break;
		case dhcpstate_RENEWING:
			/* Ignore BOOTP responses at this stage. Keep trying to talk to our
			 * DHCP server until we get to the rebind point.
			 */
			break;
		case dhcpstate_REBINDING:
		case dhcpstate_REBOOTING: {
			/* We're getting kind of desperate, so if they're offering us the
			 * address we want, we'll take it. If not, hold out until we drop
			 * back to the INIT state, at which point we'll reluctantly accept
			 * a BOOTP offer.
			 */
			struct in_addr requested_ip;
			if (dhcp_find_ip_address(&di->di_dhcp, &requested_ip, OPTION_REQUESTEDIPADDR)) {
				if (drp->reply->yiaddr == requested_ip.s_addr) {
					dhcp_ack(di, drp);
				}
			} else {
				/* Something's very odd. Do nothing and hope it goes away. */
			}
			break;
		}
	}
}

void dhcp_accept_offer(dhcp_interface *di)
{
	/* Tell the voting engine what we've done */
	dhcp_vote_notify_offer_accepted(di);

	if (!dhcp_find_option(&di->offer, OPTION_DHCPMESSAGETYPE)) {
		/* We've accepted an "offer" from a BOOTP server.
		 * Just process the offer as if it were an ACK.
		 */
		dhcp_reply_params drp;
		drp.ifname = di->di_name;
		drp.dib = di->dib;
		drp.reply = &di->offer;
		drp.reply_len = sizeof(DHCP);
		di->state = dhcpstate_REQUESTING;
		dhcp_ack(di, &drp);
	}
	else {
	       	dhcp_request(di, dhcpstate_REQUESTING, dhcprequest_set_T2);
	}
}

void dhcp_ack(dhcp_interface *di, dhcp_reply_params *drp)
{
	bool is_bootp;
	enum ioctl_flags_for_sockets_transmit_BITFIELD flags = st_ACK_RECEIVED;
	struct in_addr server;

        /* Server has acknowledged a request for use of an IP address.
         * Hooray!  Let's update the interface details we've got stored.
         * We really ought to attempt an ARP resolution for our new address
         * and send a declination message if we fail ... so we'll ask the
         * iparp module to do one (accepting that it might not actually
         * do it ... see the iparp module to see if it does)
         */

	trace(("DHCPACK message received in state %s\n", dhcp_state_name(di)));

	/* This may be a non-DHCP BOOTP response, rather than a DHCPACK.
	 * Other levels will have only passed it to us if appropriate, so
	 * just make a note of it.
	 */
	is_bootp = !dhcp_find_option(drp->reply, OPTION_DHCPMESSAGETYPE);
	if (!is_bootp) {
		struct in_addr wanted_server = { INADDR_ANY };
		if (!dhcp_find_server_identifier(drp->reply, &server)) {
			trace(("Server identifier missing from the DHCPACK message!\n"));
			dhcp_decline(di, "Server Identifier missing in DHCPACK");
			return;
		}
		dhcp_find_server_identifier(&di->di_dhcp, &wanted_server);
		if (wanted_server.s_addr != server.s_addr && wanted_server.s_addr != INADDR_ANY) {
			trace(("Unexpected DHCPACK from %s\n", inet_ntoa(server)));
			return;
		}
	}

	if (di->state == dhcpstate_BOUND) {
	        /* Already bound.  Discard this message completely. */
	        return;
	}

	if (di->state != dhcpstate_REQUESTING &&
	    di->state != dhcpstate_REBOOTING &&
	    di->state != dhcpstate_REBINDING &&
	    di->state != dhcpstate_RENEWING) {
		/* Not prepared to receive DHCKACKs in this state. Ignore it. */
        	return;
	}

	/* Need to calculate the re-acquisition timer real event times now */

	/* First, get the fields out of the packet - as centisecond relative
	 * to the first send time.
	 */
	if (is_bootp) {
		trace(("BOOTP response - setting infinite lease\n"));
		di->t1 = di->t2 = di->kill_if = dhcp_infinite_lease;
	}
	else {
		if (!dhcp_find_lease_expiry(drp->reply, &di->kill_if, OPTION_IPADDRLEASETIME)) {
			di->offer = *drp->reply;
			trace(("Lease expiry option missing from the DHCPACK message!\n"));
			dhcp_decline(di, "IP Address Lease Time missing in DHCPACK");
			return;
		}

		if (!dhcp_find_lease_expiry(drp->reply, &di->t1, OPTION_RENEWALTIME)) {
		        trace(("Defaulting the renewal time\n"));
		        if (di->kill_if == dhcp_infinite_lease) {
		                di->t1 = di->kill_if;
		        }
		        else {
		                di->t1 = di->kill_if >> 1;
		        }
		}

		if (!dhcp_find_lease_expiry(drp->reply, &di->t2, OPTION_REBINDINGTIME)) {
		        trace(("Defaulting the rebind time\n"));
		        if (di->kill_if == dhcp_infinite_lease) {
		                di->t2 = di->kill_if;
		        }
		        else {
			        di->t2 = ((di->kill_if) >> 3) * 7;
	        	}
	    	}
	}

	trace(("Time now is %#08x\n", interfaces_current_time()));
	trace(("Base time is %#08x\n", di->first_send));

	trace(("T1 (rel) is %#08x (%10d)\n", di->t1, di->t1));
	trace(("T2 (rel) is %#08x (%10d)\n", di->t2, di->t2));
	trace(("KI (rel) is %#08x (%10d)\n", di->kill_if, di->kill_if));

	/* Add in the base time that we sent the DISCOVER message */
	di->t1 = dhcp_add_dhcp_time(di->t1, di->first_send);
	di->t2 = dhcp_add_dhcp_time(di->t2, di->first_send);
	di->kill_if = dhcp_add_dhcp_time(di->kill_if, di->first_send);

	trace(("T1 (abs) is %#08x (%10d)\n", di->t1, di->t1));
	trace(("T2 (abs) is %#08x (%10d)\n", di->t2, di->t2));
	trace(("KI (abs) is %#08x (%10d)\n", di->kill_if, di->kill_if));

	/* Correct ordering to ensure renew before rebind before death */
	if (di->t2 > di->kill_if) {
	        di->t2 = di->kill_if;
	}
	if (di->t1 > di->t2) {
	        di->t1 = di->t2;
	}

	if (di->t1 <= interfaces_current_time()) {
	        /* Address lease has already expired! */
	        di->offer = *drp->reply;
	        trace(("Renew time is earlier than time now!\n"));
	        dhcp_decline(di, "Lease already expired");
	        return;
	}

	/* Perform ARP search verification for proposed IP address */
	if (arp_for_ip(di->dib, drp->reply->yiaddr) < 0) {
	        /* ARP cache has detected a duplicate IP address in its cache
	         * and so believes that initialising this interface with this
	         * address would cause havoc - the Internet module usually
	         * panics in this circumstance.  Therefore, we send back a
	         * message declining to use the offered IP address.
	         */
	        di->offer = *drp->reply;
		dhcp_decline(di, "Local ARP cache detects address in use elsewhere");
	        return;
	}

	/* Everything was OK - record the rest of the data */
	di->state = dhcpstate_BOUND;
	di->di_dhcp = *drp->reply;
	di->binding = di->di_dhcp;

	/* Remember initial values for *DHCPInfo output */
	di->orig_t1 = di->t1;
	di->orig_t2 = di->t2;
	if (di->preferred_ip.s_addr == di->binding.yiaddr) {
	        /* Same IP address as our current setting.  Don't set the
	         * interface details in the Internet module
	         */
	        flags = st_ACK_INFORM;
	}
	else {
	        sockets_set_preferred_ip_address(di, di->binding.yiaddr);
	}

	/* Inform Internet module and ask it to parse the standard options
	 * and then send around the service call announcing the interface
	 * dynamic boot has succeeded.
	 */
	sockets_transmit(di, flags);
}

void dhcp_nak(dhcp_interface *di, dhcp_reply_params *drp)
{
        /* Server rejected our request for the use of an IP address.
         * We are stuffed.  We need to re-enter the initialisation state
         * and send a new discovery request.
         */
        struct in_addr rejected_server;

	trace(("DHCPNAK message received\n"));
        module_idle(mir_WAKEUP);

	switch (di->state) {
	        default:
	                break;

	        case dhcpstate_BOUND:
	        case dhcpstate_RENEWING:
	        case dhcpstate_REBINDING:
                        if (dhcp_find_server_identifier(&di->binding, &rejected_server)) {
		                dhcp_add_to_blacklist(di, rejected_server);
	                }
	                break;

	        case dhcpstate_SELECTING:
	        case dhcpstate_REQUESTING:
	                if (di->offer.op == BOOTREPLY) {
	                        if (dhcp_find_server_identifier(&di->offer, &rejected_server)) {
			                dhcp_add_to_blacklist(di, rejected_server);
		                }
	                }
	                break;
	}

	/* Ensure that we cancel memory of any binding */
	di->binding = *drp->reply;
	di->di_dhcp = di->binding;

	/* Inform Internet that we are abandonning the boot attempt, and that
	 * it should restore the interface state if it had previously had to
	 * initialise it.  This is fine, because when the discovery occurs
	 * again in a moment, it will reclaim the frames again.
	 */
	sockets_transmit(di, st_NAK_AND_RELEASE);

	di->state = dhcpstate_INIT;
	di->t1 = dhcp_immediate_action;
	di->orig_t1 = dhcp_infinite_lease;
	di->orig_t2 = dhcp_infinite_lease;
}

void dhcp_decline(dhcp_interface *di, const char *reason)
{
	struct in_addr offering_server;

        /* We need to tell the server we weren't happy with the lease */
        trace(("DHCPDECLINE: We are declining the proposed lease\n"));

	if (dhcp_find_server_identifier(&di->offer, &offering_server)) {
		dhcp_add_to_blacklist(di, offering_server);
	}
        dhcp_init_packet(di, NULL, DHCPDECLINE);
	dhcp_add_option(&di->di_dhcp, OPTION_SERVERIDENTIFIER, sizeof(offering_server), &offering_server);
	dhcp_add_option(&di->di_dhcp, OPTION_REQUESTEDIPADDR, sizeof(di->offer.yiaddr), &di->offer.yiaddr);
	if (reason) {
	        /* The reason isn't internationalised, it's only for the server admin */
	        dhcp_add_option(&di->di_dhcp, OPTION_MESSAGE, strlen(reason), reason);
	}
	di->preferred_ip.s_addr = INADDR_ANY;
        di->binding.yiaddr = INADDR_ANY;
	di->first_send = interfaces_current_time();
	di->interval = decline_QUIET_DELAY;
	di->t1 = di->first_send + di->interval;
	di->t2 = di->t1;
	di->orig_t1 = dhcp_infinite_lease;
	di->orig_t2 = dhcp_infinite_lease;
        di->state = dhcpstate_INIT;
        dhcp_transmit(di);
        module_idle(mir_WAKEUP);
}

void dhcp_release(dhcp_interface *di, const char *reason)
{
        /* We need to tell the server we weren't happy with the lease */
        trace(("DHCPRELEASE: We are releasing the currently held lease\n"));

        dhcp_init_packet(di, NULL, DHCPRELEASE);
        di->di_dhcp.ciaddr = di->offer.yiaddr;
	dhcp_copy_option(&di->di_dhcp, &di->offer, OPTION_SERVERIDENTIFIER);
	if (reason) {
	        dhcp_add_option(&di->di_dhcp, OPTION_MESSAGE, strlen(reason), reason);
	}
	di->first_send = interfaces_current_time();
	di->interval = release_QUIET_DELAY;
	di->t1 = di->first_send + di->interval;
	di->t2 = di->t1;
	di->orig_t1 = dhcp_infinite_lease;
	di->orig_t2 = dhcp_infinite_lease;
        di->state = dhcpstate_INIT;
        dhcp_transmit(di);
        module_idle(mir_WAKEUP);
}


/* The following functions provide the gateway between the external SWI
 * interface, and the internal DHCP parsing routines.
 */
_kernel_oserror *dhcp_swi_getstate(_kernel_swi_regs *r)
{
        struct dhcp_swi_getstate_regs {
                int flags;
                const char *if_name;
                dhcp_state out_status;
                char *buffer;
                int inout_size;
        } *args = (struct dhcp_swi_getstate_regs *) r;
	dhcp_interface *di;
	DHCP *d;

	di = interfaces_find(args->if_name);
	if (di == NULL) {
	        return module_make_error(ErrorNumber_DHCP_NoSuchInterface);
	}
	args->out_status = di->state;
	if (di->state == dhcpstate_BOUND ||
	    di->state == dhcpstate_REBINDING ||
	    di->state == dhcpstate_RENEWING) {
            	d = &di->binding;
	}
    	else {
            	d = &di->di_dhcp;
        }

        if (args->buffer != NULL) {
		if (args->inout_size >= sizeof(*d)) {
	                (void) memcpy(args->buffer, d, sizeof(*d));
	        }
		else {
		        if (args->inout_size != 0) {
		                (void) memcpy(args->buffer, d, args->inout_size);
		        }
	        }
	}

        args->inout_size -= sizeof(*d);

        return NULL;
}

_kernel_oserror *dhcp_swi_getoption(_kernel_swi_regs *r)
{
        struct dhcp_swi_getoption_regs {
                int flags;
                union {
                	const char *if_name;
                	DHCP       *d;
                } r1;
                union {
                        u_int      option;
                	dhcp_state out_status;
                } r2;
                char *buffer;
                int inout_size;
        } *args = (struct dhcp_swi_getoption_regs *) r;
	dhcp_interface *di;
	DHCP *d;
	u_char *option;
	u_int option_id = args->r2.option;

	if (option_id == OPTION_PAD || option_id == OPTION_END ||
	    option_id > 0xFFFF && (option_id >> 16 != OPTION_EXTENSION)) {
	        return module_make_error(ErrorNumber_DHCP_BadOption);
	}

	if (args->flags & 1) {
	        d = args->r1.d;
	        di = interfaces_find_by_xid(d->xid);
	        if (di != NULL) {
	                args->r2.out_status = di->state;
	        }
	}
	else {
		di = interfaces_find(args->r1.if_name);
		if (di == NULL) {
			return module_make_error(ErrorNumber_DHCP_NoSuchInterface);
		}
		if (di->state == dhcpstate_BOUND ||
		    	di->state == dhcpstate_REBINDING ||
	    		di->state == dhcpstate_RENEWING) {
            		d = &di->binding;
		}
    		else {
            		d = &di->di_dhcp;
        	}
		args->r2.out_status = di->state;
	}

	option = dhcp_find_option(d, option_id);
	if (option == NULL) {
	        return module_make_error(ErrorNumber_DHCP_OptionNotPresent);
	}

	if (args->buffer != NULL) {
		if (args->inout_size >= option[1]) {
		        if (option[1] != 0) {
			        (void) memcpy(args->buffer, option + 2, option[1]);
		        }
	        }
		else {
		        if (args->inout_size != 0) {
		        	(void) memcpy(args->buffer, option + 2, args->inout_size);
		        }
		}
	}

	args->inout_size -= option[1];

        return NULL;
}

_kernel_oserror *dhcp_swi_setoption(_kernel_swi_regs *r)
{
        struct dhcp_swi_setoption_regs {
                int flags;
                union {
                	const char *if_name;
                	DHCP       *d;
                } r1;
                union {
                        u_char     option;
                	dhcp_state out_status;
                } r2;
                char *buffer;
                unsigned size;
        } *args = (struct dhcp_swi_setoption_regs *) r;
	dhcp_interface *di;
	DHCP *d;
	u_char *option = (u_char *)1; /* Initialise to ensure NULL return in the delete case */
	u_char option_id = args->r2.option;

	if (args->r2.option == OPTION_PAD || args->r2.option == OPTION_END || args->size > UCHAR_MAX) {
	        return module_make_error(ErrorNumber_DHCP_BadOption);
	}

	if (args->flags & 1) {
	        d = args->r1.d;
	        di = interfaces_find_by_xid(d->xid);
	        if (di != NULL) {
	                args->r2.out_status = di->state;
	        }
	}
	else {
		di = interfaces_find(args->r1.if_name);
		if (di == NULL) {
			return module_make_error(ErrorNumber_DHCP_NoSuchInterface);
		}
		d = &di->di_dhcp;
		args->r2.out_status = di->state;
	}

        dhcp_delete_option(d, option_id);
        if (args->buffer != NULL) {
                /* Effect is to delete if buffer pointer is passed as NULL */
		option = dhcp_add_option(d, args->r2.option, args->size, args->buffer);
        }
	if (option != NULL) {
	        /* We did manage to add it */
	        return NULL;
	}

        return module_make_error(ErrorNumber_DHCP_OptionNotAdded);
}

_kernel_oserror *dhcp_swi_execute(_kernel_swi_regs *r, void *private_word)
{
        dhcp_swi_execute_regs *args = (dhcp_swi_execute_regs *) r;
	dhcp_interface *di;

	di = interfaces_find(args->if_name);
	if (di == NULL) {
        	/* New work - prod Internet module into causing a dynamic boot.  When
        	 * it sends around the service call initialising boot, we'll trap it
        	 */
        	sockets_trigger_internet_dhcp(args->if_name);
        	di = interfaces_find(args->if_name);
        	if (di == NULL) {
                        return module_make_error(ErrorNumber_DHCP_NoSuchInterface);
                }
                if (args->flags & dse_IMMEDIATE_START) {
                        if (di->state == dhcpstate_INIT || di->state == dhcpstate_INITREBOOT) {
                                di->t1 = interfaces_current_time() + 10 + (rand() % 128);
                                interfaces_reschedule(private_word);
                        }
                }
                /*
                 * Only certain flags are copied to the interface struct
                 */
                di->flags = args->flags & (dse_BLOCKING_MODE | dse_ASSIGN_PRIVATE_IP);
	}
        args->out_status = di->state;

        if (di->state == dhcpstate_ABANDON) {
          unsigned int flags = di->flags;
          Dib dib = *di->dib; /* Copy the driver information block */
          struct in_addr del = di->preferred_ip;

          /*
           * We only reach dhcpstate_ABANDON if the assign private IP flag is set
           * but check the flag anyway to be sure.
           */

          trace(("dhcp_swi_execute: abandon %s\n", args->if_name));
          interfaces_forget(di);

          if (flags & dse_ASSIGN_PRIVATE_IP) {
            sockets_delete_address(&dib, &del);
            module_apply_private_ip(&dib);
          }

        }

      	return NULL;
}

_kernel_oserror *dhcp_swi_inform(_kernel_swi_regs *r)
{
        struct dhcp_swi_inform_regs {
                int flags;
                const char *ipaddress;
                u_char *req_list;
                int len_req_list;
        } *args = (struct dhcp_swi_inform_regs *) r;
	struct in_addr ia;

	if (args->flags & 1) {
		if (inet_aton(args->ipaddress, &ia) == 0) {
		}
	}
	else {
	        ia = *(struct in_addr *) args->ipaddress;
	}

	(void) dhcpinform_execute(ia, args->req_list, (u_char) args->len_req_list);

      	return NULL;
}
@


1.15
log
@Makefile recreated from fragments
Renamed dhcpextern.h to DHCP.h so the shared makefiles can export it without needing a different source and target filename.

Version 0.24. Tagged as 'DHCP-0_24'
@
text
@a38 1
#include "dhcperrors.h"
d726 1
d782 1
a782 1
	        return dhcperror_no_such_interface();
d832 1
a832 1
	        return dhcperror_bad_option();
d845 1
a845 1
	        	return dhcperror_no_such_interface();
d860 1
a860 1
	        return dhcperror_option_not_present();
d902 1
a902 1
	        return dhcperror_bad_option();
d915 1
a915 1
	        	return dhcperror_no_such_interface();
d931 1
a931 1
        return dhcperror_option_cannot_add();
d947 1
a947 1
                        return dhcperror_no_such_interface();
d977 1
a977 1
            apply_private_ip(&dib);
@


1.14
log
@Line up a few comments
No code changes, retagged as DHCP-0_23.
@
text
@d37 1
a37 1
#include "dhcp.h"
@


1.13
log
@Fixed data abort on RPi when setting private IP address.
Delete existing address from interface before setting a private one.

Version 0.23. Tagged as 'DHCP-0_23'
@
text
@d942 2
a943 1
        	 * it sends around the service call initialising boot, we'll trap it */
d957 1
a957 1
                */
d964 1
a964 1
          Dib dib = *di->dib;		// copy the driver information block
d970 1
a970 1
          */
@


1.12
log
@Added -p switch to DHCPExecute command, that causes DHCP to assign
a private IP address in the event of DHCP discovery timing out.
Changed DHCP discovery timeout from 10 minutes to 20 seconds.

Version 0.22. Tagged as 'DHCP-0_22'
@
text
@d964 6
d975 1
@


1.11
log
@  Tells Internet module not to delete and reassign interface addresses
    when the address hasn't changed.
Detail:
  Previously, after a RENEWING or REBINDING state has been resolved by
    the reception of a DHCPACK, the Internet module was shown the packet
    in order to enable it to extract the information it wanted and to
    send it round in a service call for all other modules in the system
    to look at.  This no longer happens, as it causes the Internet module
    to lose the IGMP memberships for the interface, causing multicast
    data, including video streams on STBs, to stop.
Admin:
  Tested on STB-400 and desktop machine.

Version 0.16. Tagged as 'DHCP-0_16'
@
text
@d626 1
a626 1
	if (arp_for_ip(di, drp->reply) < 0) {
d954 4
d960 14
@


1.10
log
@  Initial delays are vastly reduced when the DHCP process is invoked
    via *DHCPExecute.
Detail:
  Without this change, it takes an age for desktop machines to boot.
  Particularly my test machine with its three interfaces, each one having
    a random delay of up to 10 seconds before anything actually happens.
Admin:
  Tested in Risc PC.  Does not affect STB builds.

Version 0.14. Tagged as 'DHCP-0_14'
@
text
@d510 1
d646 9
a654 1
	sockets_set_preferred_ip_address(di, di->binding.yiaddr);
d660 1
a660 1
	sockets_transmit(di, st_ACK_RECEIVED);
@


1.9
log
@Tweaked to build with latest TCPIPLibs
@
text
@d23 1
d925 1
a925 1
_kernel_oserror *dhcp_swi_execute(_kernel_swi_regs *r)
d938 6
@


1.8
log
@* Ignores DHCPACKS from incorrect servers.
* DHCP_GetOption and associated internal calls support sub-options and
  extended options.
* Random time intervals more uniformly spread.
* Time reports in *DHCPInfo were incorrect when real-time clock had changed
  since module initialisation.
* Server priority option supported.
* CMHG file optimised - syntax not duplicated.

Version 0.10. Tagged as 'DHCP-0_10'
@
text
@d29 2
a32 1
#include "sys/dcistructs.h"
@


1.7
log
@* Added initial delay in INIT-REBOOT state to match INIT state.
* Stopped extra DHCPREQUESTs being generated by ioctl calls in REBOOTING state.
* Don't reject BOOTP packets just because they don't have a cookie. Treat
  those without the correct cookie as containing no options.
* Reject BOOTP packets < 300 bytes, as per RFC 1542.
* Treat BOOTP responses in a more considered fashion - old versions would go
  nuts as soon as they saw any non-DHCP response. BOOTP replies now treated as
  (not very good) offers. BOOTP responses with correct address also accepted
  in REBINDING state.
* Decline DHCPACKs with no server identifier.
* Add server to blacklist if its offer ended up being DHCPDECLINEd for any
  reason.
* Add server to blacklist if we timeout requests.
* Initial boot delay now better randomised (seeded on MAC address), and in the
  range 1-10 seconds, as per RFC 2131.
* Corrected REBOOTING and REQUESTING back-off timers - first retransmission
  was too slow.
* DHCPREQUEST packets now have secs filled in correctly in REBOOTING state.
* Voting rules extended - prefer DHCP servers to BOOTP servers and prefer
  servers providing vendor options to those who don't.

Version 0.07. Tagged as 'DHCP-0_07'
@
text
@d526 1
d532 5
d808 1
a808 1
                        u_char     option;
d817 1
a817 1
	u_char option_id = args->r2.option;
d819 2
a820 1
	if (args->r2.option == OPTION_PAD || args->r2.option == OPTION_END) {
@


1.6
log
@Fixed some RFC 2131 violations in the "secs" field output:
    DHCPDECLINE and DHCPRELEASE now set secs to 0.
    DHCPREQUESTs now have the same secs value as the last DHCPDISCOVER.

Version 0.06. Tagged as 'DHCP-0_06'
@
text
@d24 1
d97 1
a98 10
		case dhcpstate_REBOOTING:
		        /* Hmm.  I doubt that RISC OS will ever get into
		         * these states, but it's basically needing to send
		         * a request again, so let's just re-initialise the
		         * interface back to basics and start again.
		         */
		        dhcp_request(di, dhcpstate_REBOOTING, dhcprequest_set_T2);
		        break;

		case dhcpstate_INIT:
d104 1
d144 2
a145 2
 * Basic integrity is guaranteed (packet is long enough, well-terminated,
 * contains a valid magic cookie).
d212 2
a213 4
        	/* Reply does not contain a valid DHCP message type option,
	         * hence we must pass it to the Internet module for interpretation.
	         * Internet will not get to see it through its internal hooks into
	         * the UDP code because of our socket "claiming" it.
a361 1
		di->di_dhcp.secs = 0;
d363 1
a363 1
		di->t1 = di->first_send + initreboot_INITIAL_RETRY;
d381 1
a381 1
		di->t1 = di->first_send + request_INITIAL_RETRY;
d440 1
a440 1
	trace(("BOOTP ACK message received in state %s\n", dhcp_state_name(di)));
d442 38
a479 3
	if (di->state == dhcpstate_BOUND) {
	        /* Already bound.  Discard this message completely. */
	        return;
d481 6
d488 11
a498 5
	if (di->state != dhcpstate_SELECTING &&
	    di->state != dhcpstate_REBINDING &&
	    di->state != dhcpstate_RENEWING) {
		/* Not prepared to receive BOOTP ACKs in this state. Ignore it. */
        	return;
d500 2
a501 15

	/* No need to calculate the re-acquisition timer real event times now */
	di->t1 = dhcp_infinite_lease;
	di->t2 = dhcp_infinite_lease;
	di->kill_if = dhcp_infinite_lease;

	/* Perform ARP search verification for proposed IP address */
	if (arp_for_ip(di, drp->reply) < 0) {
	        /* ARP cache has detected a duplicate IP address in its cache
	         * and so believes that initialising this interface with this
	         * address would cause havoc - the Internet module usually
	         * panics in this circumstance.  Therefore, we ignore this
	         * message.
	         */
	        return;
a502 11

	/* Everything was OK - record the rest of the data */
	di->state = dhcpstate_BOUND;
	di->di_dhcp = *drp->reply;
	di->binding = di->di_dhcp;

	/* Inform Internet module and ask it to parse the standard options
	 * and then send around the service call announcing the interface
	 * dynamic boot has succeeded.
	 */
	sockets_transmit(di, st_ACK_RECEIVED);
d507 3
d520 13
d551 3
a553 5
	if (!dhcp_find_lease_expiry(drp->reply, &di->kill_if, OPTION_IPADDRLEASETIME)) {
		di->offer = *drp->reply;
		trace(("Lease expiry option missing from the DHCPACK message!\n"));
		dhcp_decline(di, "IP Address Lease Time missing in DHCPACK");
		return;
d555 7
d563 19
a581 8
	if (!dhcp_find_lease_expiry(drp->reply, &di->t1, OPTION_RENEWALTIME)) {
	        trace(("Defaulting the renewal time\n"));
	        if (di->kill_if == dhcp_infinite_lease) {
	                di->t1 = di->kill_if;
	        }
	        else {
	                di->t1 = di->kill_if >> 1;
	        }
a583 10
	if (!dhcp_find_lease_expiry(drp->reply, &di->t2, OPTION_REBINDINGTIME)) {
	        trace(("Defaulting the rebind time\n"));
	        if (di->kill_if == dhcp_infinite_lease) {
	                di->t2 = di->kill_if;
	        }
	        else {
		        di->t2 = ((di->kill_if) >> 3) * 7;
	        }
    	}

d625 1
a625 1
	        dhcp_decline(di, "Local ARP cache detects address in use elsewhere");
d698 2
d703 3
d707 1
a707 1
	dhcp_copy_option(&di->di_dhcp, &di->offer, OPTION_SERVERIDENTIFIER);
@


1.5
log
@  Support for DHCPINFORM
  Dynamic leasing behaviour brought in line with DHCP specification
Detail:
  New *-command *DHCPExecute to enable CLI launching of DHCP interface
    control.
  Output of *DHCPInfo tidied up and irrevelant timer info is suppressed.
  The algorithm for deciding which offer to accept (where multiple offers
    are received) has been significantly enhanced (and moved to voting.c)
    If a previous offer from a server has been DHCPNAK'd by something else
    then the server offering the dodgy IP address is blacklisted and will
    no longer be preferred to a server which isn't blacklisted.
  DHCP module will request and prefer offers of an existing IP address
    configuration wherever possible.
  DHCP module will initialise an interface into the INITREBOOT/REBOOTING
    states if it is asked to take control of an interface which has
    already been configured externally.
  IP lease length suggestions are no longer sent in appropriate messages.
    The server is trusted to choose an appropriate value.
  The DHCP module is more careful to insert appropriate options into each
    message.  It is no longer in breach of RFC2131 in this respect.
  Timer values for renew and rebind times are now inferred automatically
    where necessary (server doesn't have to send them) and are now correct.
  DHCPRELEASE and DHCPDECLINE now include a textual message indicating the
    reason for the message's generation.
  Where allowed, outgoing messages contain a client class identifier to
    enable the server to vary configuration information depending on the
    client hardware/software type.  Currently, this information is the
    output of OS_Byte 0.
  In the SWI interface for examining DHCP packets, a pointer to a specific
    packet to examine may be supplied instead of an interface identifier
    (depending on a flag bit)
  New SWI DHCP_Inform for sending DHCPINFORM messages to arbitrary servers
    in order to enable retrieval of configuration information when the IP
    address has been established via other means (eg. from NVRAM).
  DHCP module is now capable of deleting IP addresses from interfaces.
  DHCP module will cede control of an interface if something else changes
    the interface's address and send a message to the server indicating
    that the lease is being relinquished.
  DHCP will trap the Internet (5.26 and later) module's panic service call
    when a duplicate IP address is detected on the network, and resolve
    the situation (send the server DHCPDECLINE and deconfigure the interface
    and restart address discovery) if it was controlling that interface.
  Transaction ID generation improved (uses interface MAC address to
    reduce chance of duplication with other hosts)
  MAC address discovery code added.
  DHCP module attempts to unicast packets wherever possible.
  Retry delays adjusted to conform more closely to spec (RFC2131)
  Possible hole in state table that IPConfig triggered which caused several
    DHCPDISCOVER messages to be sent in succession very quickly has been
    closed.
  Co-operates with Internet 5.26 to ensure that callers of the Internet
    module's BOOTP ioctl are returned sensible error values so that they
    no longer need to probe the DHCP module independently to discover
    whether an interface has been configured successfully or not.
Admin:
  Requires Internet 5.26
  Requires TCPIPLibs 5.19

Version 0.05. Tagged as 'DHCP-0_05'
@
text
@d384 4
a388 1
		di->di_dhcp.secs = di->temp.secs;
a673 1
	di->di_dhcp.secs = di->temp.secs;
@


1.4
log
@  BOOTP server interaction policy change and fix.
Detail:
  If a BOOTP response is received in reply to a DHCPDISCOVER message,
    the DHCP module will no longer ignore it or try to palm it off to
    the Internet module, but will accept it as a valid response (ie.
    as if it were a DHCPACK with an infinite lease offer).
Admin:
  Tested in MPT Ethernet ROM.

Version 0.04. Tagged as 'DHCP-0_04'
@
text
@d41 1
d43 1
d78 5
a89 5
	if (&di->di_dhcp == dsp->request) {
	        /* This was our own service call.  We'd better ignore it */
	        return dhcp_IGNORE;
	}

d111 2
a112 11
		case dhcpstate_SELECTING:
	        	/* It was either new, or a retry from some software
	        	 * that was prodding the Internet module.  Resend
	        	 * our broadcasts and tell the Internet module's
	        	 * caller to go away.
		         */
		        di->state = dhcpstate_INIT;
		        di->t1 = dhcp_immediate_action;
		        break;

		default:
a113 1
	        case dhcpstate_BOUND:
d116 1
d135 9
d150 2
a151 2
 * out whether we need it and if so for which interface it was for.
 * Basic intergrity is guaranteed (packet is long enough, well-terminated,
d165 12
a176 5
		#ifdef TRACE
		struct in_addr a;
		memcpy(&a, &d->yiaddr, 4);
                trace(("DHCP: unable to match ID %ld with yiaddr %s\n", d->xid, inet_ntoa(a)));
                #endif
d209 8
d285 1
d288 6
a293 1
	dhcp_add_time_option(&di->di_dhcp, desired_lease, OPTION_IPADDRLEASETIME);
d313 3
a315 1
	trace(("DHCPOFFER message received\n"));
d334 1
a334 34
	        if (di->offer.op == BOOTREPLY) {
	                /* We have already had a reply - use some kind of
	                 * logic to decide whether we like it or not.  We'll
	                 * choose the offer that offers the longest lease.
	                 */
	                dhcp_time new_expiry;
	                dhcp_time current_expiry;
	                int prefer_it = 0;

			if (dhcp_find_lease_expiry(drp->reply, &new_expiry, OPTION_IPADDRLEASETIME) == NULL) {
			        /* new message didn't have an expiry date suggestion! */
			        return;
			}

			if (dhcp_find_lease_expiry(&di->offer, &current_expiry, OPTION_IPADDRLEASETIME) == NULL) {
			        /* Current reply didn't have an expiry suggestion! */
			        prefer_it = 1;
			}
			else if (new_expiry > current_expiry) {
			        /* This was a longer lease offer - prefer it */
			        prefer_it = 1;
			}

			if (prefer_it) {
			        /* And check nobody else objects to it ... */
			        if (module_notify_dhcp_offer(di, drp->reply)) {
					di->offer = *drp->reply;
			        }
			}
	        }
	        else {
	                /* This is the first one, and therefore the best.  Remember it as long as
	                 * nobody else objects.
	                 */
d336 1
d338 7
d366 25
a390 6
        di->temp = di->di_dhcp;
	dhcp_init_packet(di, &di->temp, DHCPREQUEST);
	dhcp_add_time_option(&di->di_dhcp, desired_lease, OPTION_IPADDRLEASETIME);
	dhcp_copy_option(&di->di_dhcp, &di->offer, OPTION_SERVERIDENTIFIER);
	dhcp_add_option(&di->di_dhcp, OPTION_REQUESTEDIPADDR, sizeof(di->offer.yiaddr), &di->offer.yiaddr);
	di->di_dhcp.secs = di->temp.secs;
d401 5
a405 3
	di->first_send = interfaces_current_time();
	di->interval = request_INITIAL_RETRY;
	di->t1 = di->first_send + request_INITIAL_RETRY;
d407 9
a415 1
	        di->t2 = di->first_send + request_TOTAL_TIMEOUT;
d519 33
a551 3
	dhcp_find_lease_expiry(drp->reply, &di->t1, OPTION_RENEWALTIME);
	dhcp_find_lease_expiry(drp->reply, &di->t2, OPTION_REBINDINGTIME);
	dhcp_find_lease_expiry(drp->reply, &di->kill_if, OPTION_IPADDRLEASETIME);
d558 4
d563 3
d567 1
a567 4
	        di->t2 = di->t1;
	}
	if (di->t2 > di->kill_if) {
	        di->kill_if = di->t2;
d574 1
a574 1
	        dhcp_decline(di);
d587 1
a587 1
	        dhcp_decline(di);
d596 5
d614 1
d619 22
d653 3
a655 1
	di->t1 = 0;
d658 1
a658 1
void dhcp_decline(dhcp_interface *di)
a659 2
        dhcp_time desired_lease = dhcp_infinite_lease; /* Default in case read from offer fails */

d663 1
a663 3
        dhcp_init_packet(di, &di->offer, DHCPDECLINE);
	dhcp_find_lease_expiry(&di->offer, &desired_lease, OPTION_IPADDRLEASETIME);
	dhcp_add_time_option(&di->di_dhcp, desired_lease, OPTION_IPADDRLEASETIME);
d666 5
d673 27
a699 3
	di->interval = decline_INITIAL_RETRY;
	di->t1 = di->first_send + decline_INITIAL_RETRY;
	di->t2 = di->first_send + decline_TOTAL_TIMEOUT;
d755 4
a758 1
                const char *if_name;
d769 1
d775 6
a780 3
	di = interfaces_find(args->if_name);
	if (di == NULL) {
	        return dhcperror_no_such_interface();
d782 14
a795 4
	if (di->state == dhcpstate_BOUND ||
	    di->state == dhcpstate_REBINDING ||
	    di->state == dhcpstate_RENEWING) {
            	d = &di->binding;
a796 3
    	else {
            	d = &di->di_dhcp;
        }
d798 1
a798 2
	option = dhcp_find_option(d, args->r2.option);
	args->r2.out_status = di->state;
d825 4
a828 1
                const char *if_name;
d837 1
d839 1
d845 14
a858 3
	di = interfaces_find(args->if_name);
	if (di == NULL) {
	        return dhcperror_no_such_interface();
d861 1
a861 1
        dhcp_delete_option(&di->di_dhcp, args->r2.option);
d864 1
a864 1
		option = dhcp_add_option(&di->di_dhcp, args->r2.option, args->size, args->buffer);
a865 1
	args->r2.out_status = di->state;
d876 1
a876 5
        struct dhcp_swi_execute_regs {
                int flags;
                const char *if_name;
               	dhcp_state out_status;
        } *args = (struct dhcp_swi_execute_regs *) r;
d890 23
@


1.3
log
@  DHCP module behaviour when presented with a BOOTP response to one of
    its requests has been fixed.
Detail:
  If the DHCP module received a response from the BOOTP server rather
    than a DHCP server, it would discard the packet silently.  Since
    the Internet module only uses its own hooks into the UDP packet
    delivery code if no socket is bound to the BOOTP/DHCP port, the
    Internet module didn't see the response either.  This case is now
    trapped and delivered to the Internet module like a DHCPACK message
    would usually be (via sockets_transmit), except that we then forget
    about the interface to avoid having to deal with it any more.
  Fixed Makefile to use Do to call awk so that we can use the C library
    redirection and hence avoid getting lots of CRs in the header file
    which is exported to RiscOS.Export.C.h.DHCP
  Debug output on sockets_transmit altered to avoid dereferencing a
    NULL pointer when noting the DHCP message type of the packet being
    passed to the Internet module.
Admin:

Version 0.03. Tagged as 'DHCP-0_03'
@
text
@a182 12
/* Inform the Internet module that we received a BOOTP response to our
 * DHCP request.  Destroy our record of this interface immediately
 * afterwards to avoid interfering in the future.  The lease will be
 * infinite by virtue of the response being BOOTP and not DHCP.
 */
static void bootp_offer(dhcp_interface *di, dhcp_reply_params *drp)
{
	di->di_dhcp = *drp->reply;
        sockets_transmit(di, st_ACK_RETAIN_NO_XMIT);
        interfaces_forget(di);
}

d201 1
a201 1
	if (msgtype == NULL || msgtype[1] < 1) {
d207 4
a210 1
	        bootp_offer(di, drp);
d213 1
a213 2

	switch (msgtype[2]) {
d411 47
@


1.2
log
@  Integration with IPConfig completed.
  Header export added.
Detail:
  Blocking added to enable IPConfig to work correctly.
  Header file exported containing states and SWI identifiers.
  Brings loopback interface up so that it can bind to the DHCP client
    port (failure to have any AF_INET interfaces configured causes
    the bind() call to fail, even when INADDR_ANY is specified)
  Failure to read ARP cache now treated as a go-ahead to accept the
    IP address rather than a rejection.
  Keeps a copy of Internet BOOTP requests so that the options can
    be copied across to the DHCPDISCOVER if required.
Admin:
  Header export required by Internet 5.21 and IPConfig 0.15
  Requires Internet 5.21.
  Requires TCPIPLibs 5.11.
  Requires IPConfig 0.15.
  Add module after all other expansion card networking modules and
    any attempt to BOOTP will be transparently upgraded to DHCP.


Version 0.01. Tagged as 'DHCP-0_01'
@
text
@d183 12
d215 3
a217 1
	         * hence we must ignore it.
d219 1
@


1.1
log
@Initial revision
@
text
@d105 4
d135 4
a138 4
	/* XXX: Need to block here waiting for the expiration of a timeout?
	 *      Or do we return and rely on Internet's caller to do this.
	 *      The caller will almost certainly be the IPConfig module, so
	 *      it should be OK, but behaviour needs to be verified.
d140 1
d156 5
d250 3
d367 1
a367 1
	if (di->state == dhcpstate_SELECTING) {
d372 4
a375 1
		module_notify_dynamic_boot_start(di);
d418 1
a418 1
	trace(("DHCPACK message received\n"));
d458 1
d496 1
d518 1
d532 1
@


1.1.1.1
log
@  Fully functional DHCP client.
Detail:
  Implements the Dynamic Host Configuration Protocol (RFC2131 and RFC2132)
  This module usurps the Internet module's implementation of BOOTP in order
    to use the superior DHCP protocol.
Admin:
  Requires Internet 5.20 or later.
    (RiscOS/Sources/Networking/AUN/Internet  tag: Internet-5_20)
  Requires TCPIPLibs 5.09 or later.
    (RiscOS/Sources/Libs/TCPIPLibs  tag: TCPIPLibs-5_09)
  

Tagged as DHCP-0_00

@
text
@@

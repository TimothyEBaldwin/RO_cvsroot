head	1.2;
access;
symbols
	Ether1-4_01:1.2
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2000.12.05.20.37.22;	author blaughto;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.13.16.59.07;	author blaughto;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.13.16.59.07;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.2
log
@  DCI-4 compatible.
  32-bit compatible.
  Fixed timing problem causing instablility on fast machines.
Details:
  Bits in mbuf header fields were being set that shouldn't, which is why it
  didn't work with Internet5 - Kevin found this one.

  Made assembler 32-bit compatible - now uses AsmUtils for some stuff and
  based the rest on the 32-bit compatible poduleirq code in EtherI.

  Setting DCI-4 filters causes the hardware to be reconfigured.  On fast
  (StrongARM) machines, a second DCI-4 filter call could occur before the
  hardware had finished dealing with the first reconfigure command.  The
  reconfigure command structure would be overwritten and linked back to
  itself, causing an infinite loop in the ISR.  Fixed by adding a busy flag
  to the command structures which is polled until clear before constructing
  a command and sending it to the hardware.
Admin:
  Tested on and off over several months.  Performance may degrade on Internet 5
  because card is put into promiscuous mode due to an inadequecy in its
  hardware multicast filtering (no easy way to tell it to receive all multicast
  addresses).  This might be work-aroundable by discovering the hashing
  algorithm that the card uses and finding a canned list of addresses that fills
  in all the bits in the table, but probably isn't worth the effort.

  Still appear to be some timing related problems if you reload the driver
  after the interface has been configured.  Doesn't crash, but get hardware
  timeouts that it doesn't recover from - will look at.

  Briefly tested 26bit/32bit stuff - appears to work for both.

Version 4.01. Tagged as 'Ether1-4_01'
@
text
@/* Copyright 2000 Pace Micro Technology plc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"

#include <AsmUtils/irqs.h>
#include <DebugLib/DebugLib.h>
#include <Global/RISCOS.h>

#include <xcb.h>
#include <int_hndlr.h>

#include <sys/types.h>
#include <sys/dcistructs.h>
#include <sys/errno.h>
#include <sys/mbuf.h>

#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <net/if.h>
#include <netinet/if_ether.h>

#include "e1module.h"
#include "if_et.h"
#include "EtHdr.h"
#include "mbuf.h"
#include "poduleirqs.h"
#include "support.h"

/*
 * XXX
 *
 * a really cheesy test for broadcast addresses - relies
 * on character buffers being word aligned.
 */
#define IS_BROADCAST(x) (*(u_int *)(x) == 0xffffffff && \
                         *(u_short *)((x) + 4) == 0xffff)

/*
 * XXX
 *
 * cannot find an unambiguous definition for multicast addresses,
 * the best we have is a statement that "all multicast addresses
 * have an MSB of 1" without any clarification whether `B' means
 * bit or byte.  This test *assumes* that it stands for bit.
 */
#define IS_MULTICAST(x) ((*(u_char *)(x) & 0x80) && \
                         (*(u_char *)(x)) != 0xff)

struct swient
{
    static int (*swi_call)();                   /* swi handler */
};

struct client
{
    static _kernel_oserror *(*cli_call)(int argc, char **argv);
};

static int et_version(_kernel_swi_regs *r);
static int et_inquire(_kernel_swi_regs *r);
static int et_getmtu(_kernel_swi_regs *r);
static int et_setmtu(_kernel_swi_regs *r);
static int et_filter(_kernel_swi_regs *r);

static struct swient et_ent[] =
{
    et_version,
    et_inquire,
    et_getmtu,
    et_setmtu,
    et_transmit,
    et_filter,
    et_stats
};

static _kernel_oserror *do_etinfo(int argc, char **argv);
static _kernel_oserror *do_ettest(int argc, char **argv);

static struct client et_cli_call[] =
{
    do_etinfo,
    do_etinfo,
    do_ettest
};

void *module_wsp = 0;

static struct
{
    int  e_num;
    char e_mess[16];
} _et_errblk = { 0 };

static _kernel_oserror *et_error(int error);
static void callback (void (*f) (void), void *pw);
static _kernel_oserror *calleverytick (void (*fun) (void));
static int removetickerevent(void (*fun)(void));


/*
 * arrays of filtering information, sorted per unit,
 * a separate array for each filter level.
 */
FilterSingleRef ieeefilter[4];
FilterSingleRef e2monitor[4];
FilterSingleRef e2sink[4];
FilterChainRef e2specific[4];

/*
 * function pointer used to select the most efficient
 * address filtering function for current hardware
 * address level
 */
int (*address_filter[4])(u_int level, u_char *pack_hdr, u_char *mac_addr);

/*
 * array of Driver information Blocks, one per unit
 */
DibRef dibs[4];

static int managerstarted = 0;
static int finalising = 0;

/**********************************************************************/

/*
 * check_addrlevel - check that address level for a filter SWI
 * is valid. returns 1 if valid, else 0.
 */
static int check_addrlevel(u_int level)
{
    if( (int)level < ADDRLVL_SPECIFIC || (int)level > ADDRLVL_PROMISCUOUS )
        return(0);
    else
        return(1);
}

/**********************************************************************/

/*
 * af_reject - filtering function used to reject *all* received packets
 */
static int af_reject(u_int level, u_char *pack_hdr, u_char *mac_addr)
{
    UNUSED (level);
    UNUSED (pack_hdr);
    UNUSED (mac_addr);

    return(1);
}

/**********************************************************************/

/*
 * af_specific - filtering function used when only specifically
 * addressed packets are enabled in hardware.
 */
static int af_specific(u_int level, u_char *pack_hdr, u_char *mac_addr)
{
    /*
     * the hardware does *all* the filtering for us
     */
    UNUSED (level);
    UNUSED (pack_hdr);
    UNUSED (mac_addr);

    return(0);
}

/**********************************************************************/


/*
 * af_normal - filtering function used when hardware packet
 * filtering accepts specific and broadcast packets.  returns
 * 1 if packet should be filtered out, else 0
 */
static int af_normal(u_int level, u_char *pack_hdr, u_char *mac_addr)
{
    UNUSED (mac_addr);

    if( level == ADDRLVL_SPECIFIC && IS_BROADCAST(pack_hdr) )
        return(1);
    else
        return(0);
}

#if 0
/**********************************************************************/

/*
 * af_multicast - filtering function used when hardware packet
 * filtering accepts specific, broadcast, and multicast
 * packets.  returns 1 if packet should be filtered out, else 0
 */
static int af_multicast(u_int level, u_char *pack_hdr, u_char *mac_addr)
{
    switch( level )
    {
      case ADDRLVL_SPECIFIC:
        if( IS_BROADCAST(pack_hdr) )
            /* filter it out */
            return(1);

        /* fall through case */

      case ADDRLVL_NORMAL:
        if( IS_MULTICAST(pack_hdr) )
            /* don't want it */
            return(1);

        /* fall through case */

      case ADDRLVL_MULTICAST:
      default:
        /* protocol wants this packet */
        return(0);

        /*NOTREACHED*/
        break;
    }
}
#endif

/**********************************************************************/

/*
 * af_promiscuous - filtering function used when hardware packet
 * filtering accepts all packets.  returns 1 if packet should be
 * filtered out, else 0
 */
static int af_promiscuous(u_int level, u_char *pack_hdr, u_char *mac_addr)
{
    int isbroadcast = IS_BROADCAST(pack_hdr);
    int ismulticast = IS_MULTICAST(pack_hdr);

    switch( level )
    {
      case ADDRLVL_SPECIFIC:
        if( isbroadcast )
            /* filter it out */
            return(1);

        /* fall through case */

      case ADDRLVL_NORMAL:
        if( ismulticast )
            /* don't want it */
            return(1);

        /* fall through case */

      case ADDRLVL_MULTICAST:
        /*
         * reject all packets that aren't broadcast or
         * multicast, and which don't match the MAC address
         */
        if( !isbroadcast && !ismulticast )
        {
            int i;

            for( i = 0; i < 6; ++i )
                if( pack_hdr[i] != mac_addr[i] )
                    return(1);
        }

        /* fall through case */

      case ADDRLVL_PROMISCUOUS:
      default:
        /* protocol wants this packet */
        return(0);

        /*NOTREACHED*/
        break;
    }
}

/**********************************************************************/

/*
 * update_addrlevel - find most general address level for all
 * active filters on a given unit, and ask for hardware to
 * be set to that level.
 */
static void update_addrlevel(int unit)
{
    static AddressFilter filters[] =
    {
        af_reject,
        af_specific,
        af_normal,
        af_promiscuous,       /* Haven't gotten card to do filtering for us */
        af_promiscuous
    };

    int level = -1;
    FilterChainRef fc;
    AddressFilter *filtersp = filters + 1;

    if( ieeefilter[unit] != NULL )
        level = MAX(level, (int)ieeefilter[unit]->fs_addrlevel);

    if( e2monitor[unit] != NULL )
        level = MAX(level, (int)e2monitor[unit]->fs_addrlevel);

    if( e2sink[unit] != NULL )
        level = MAX(level, (int)e2sink[unit]->fs_addrlevel);

    for( fc = e2specific[unit]; fc; fc = fc->fc_next )
        level = MAX(level, (int)fc->fc_addrlevel);

    set_receive_level(unit, level);

    /*
     * set appropriate filtering function
     */
    address_filter[unit] = filtersp[level];
}

/**********************************************************************/

/*
 * send_frametypefree - raise a service call to let protocol modules
 * know that a given frame type has been freed
 */
static void send_frametypefree(u_int unit, u_int type, FilterSingleRef fs)
{
    _swix(OS_ServiceCall, _INR(0,4), dibs[unit], Service_DCIFrameTypeFree,
                                     type, fs->fs_addrlevel, fs->fs_errlevel);
}

/**********************************************************************/

/*
 * undo_chainfilter - stop filtering on a filter level that
 * chains multiple frame types iff the recipient protocol module
 * has a private word pointer that matches the one given
 */
static void undo_chainfilter(u_int unit, u_int pwp, u_int level,
                             FilterChainRef *fcrptr)
{
    FilterChainRef *fcprev = fcrptr;
    FilterChainRef fc = *fcrptr;

    while( fc )
    {
        if( fc->fc_pwptr == pwp )
        {
            u_int ftype = 0;
            SET_FRAMETYPE(ftype, fc->fc_type);
            SET_FRAMELEVEL(ftype, level);

            /*
             * unchain this entry, send service call
             * indicating it is free, and free it
             */
            *fcprev = fc->fc_next;
            send_frametypefree(unit, ftype, &(fc->fc_filter));
            (void)free(fc);

            /*
             * previous entry is the same,
             * advance the current pointer
             */
            fc = *fcprev;
        }
        else
        {
            /*
             * move both pointers down the list
             */
            fc = fc->fc_next;
            fcprev = (FilterChainRef *)(*fcprev);
        }
    }
}

/**********************************************************************/

/*
 * undo_singlefilter - stop filtering on a filter level that does
 * not chain multiple frame types iff the recipient protocol module
 * has a private word pointer that matches the one given
 */
static void undo_singlefilter(u_int unit, u_int pwp, u_int level,
                              FilterSingleRef *fsrptr)
{
    FilterSingleRef fs = *fsrptr;

    if( fs && fs->fs_pwptr == pwp )
    {
        /*
         * we have a match - send a service call round
         * to let protocol modules know about new claims
         * available.
         */
        u_int ftype = 0;
        SET_FRAMELEVEL(ftype, level);
        send_frametypefree(unit, ftype, fs);
        (void)free(fs);
        *fsrptr = NULL;
    }
}

/**********************************************************************/

/*
 * filtersoff - disable filtering for the module
 * with the given private word pointer.
 */
static void filtersoff(u_int pwp)
{
    int unit;

    /*
     * loop over all active units looking for the module
     */
    for( unit = 0; unit < etcnt; ++unit )
    {
        /*
         * start with the chained filter level
         */
        undo_chainfilter(unit, pwp, FRMLVL_E2SPECIFIC, &e2specific[unit]);

        /*
         * now the unique filter levels
         */
        undo_singlefilter(unit, pwp, FRMLVL_E2SINK, e2sink + unit);
        undo_singlefilter(unit, pwp, FRMLVL_E2MONITOR, e2monitor + unit);
        undo_singlefilter(unit, pwp, FRMLVL_IEEE, ieeefilter + unit);

        /*
         * check whether receiver can be disabled
         */
        update_addrlevel(unit);
    }
}

/**********************************************************************/

/*
 * do_chainfilter - handle a claim or release on a
 * filter level that chains multiple frame types.
 */
static int do_chainfilter(_kernel_swi_regs *r,
                          FilterChainRef *fcrptr,
                          FilterSingleRef *antagonist)
{
    FilterChainRef fc, *fcprev;
    int unit = r->r[1];

    /*
     * search down the FilterChain, looking for this frametype
     */
    for( fcprev = fcrptr, fc = *fcrptr;
        fc && fc->fc_type != GET_FRAMETYPE(r->r[2]);
        fc = fc->fc_next, fcprev = (FilterChainRef *)*fcprev )
        /* do nothing */
        ;

    dprintf (("", "do_chainfilter(%x, %x): fcrptr = %p, fc = %p\n",
           r->r[0], r->r[2], fcrptr, fc));

    /*
     * is this a claim or a release
     */
    if( r->r[0] & FILTER_RELEASE )
    {
        if( !fc )
            /*
             * trying to free a non-existent claim
             */
            return(EINVAL);

        if( fc->fc_handler != (void (*)())r->r[6] || fc->fc_pwptr != r->r[5] )
            /*
             * trying to release somebody else's claim
             */
            return(EPERM);

        dprintf(("", "releasing claim on frame type %x (fcprev = %p)\n",
               GET_FRAMETYPE(r->r[2]), *fcprev));

        /*
         * OK, this is a legitimate free, do it
         */
        *fcprev = fc->fc_next;
        send_frametypefree(unit, r->r[2], &(fc->fc_filter));
        (void)free(fc);

        /*
         * check whether receiver can be disabled
         */
        update_addrlevel(unit);
    }
    else
    {
        int error;
        struct et_softc *et = et_softc[unit];

        /*
         * claiming
         */
        if( fc || *antagonist )
        {
            /*
             * this frame type is already claimed in some fashion,
             * check that this is not an erroneous reclaim
             */
            if( (et->et_flags & ET_DUPCLAIMEXPECTED) &&
               fc &&
               fc->fc_type == GET_FRAMETYPE(r->r[2]) &&
               fc->fc_addrlevel == r->r[3] &&
               fc->fc_errlevel == r->r[4] &&
               fc->fc_handler == (void (*)())r->r[6] &&
               fc->fc_pwptr == r->r[5] )
            {
                /*
                 * its a legitimate reclaim - need to check that
                 * we can bring the card up live once again.
                 */
                if( (error = etioctl(unit, 1, 1)) != 0 )
                    /*
                     * return an error, but *do not* free the structure
                     */
                    return(error);

                /*
                 * set receive level for this unit to the
                 * loosest address filtering necessary.
                 */
                update_addrlevel(unit);

                return(0);
            }
            else
                return(INETERR_FILTERGONE);
        }

        if( (fc = (FilterChainRef)malloc(sizeof(*fc))) == NULL )
            /*
             * cannot claim memory for this structure
             */
            return(ENOMEM);

        /*
         * check that we can bring the card up live
         */
        if( (error = etioctl(unit, 1, 1)) != 0 )
        {
            (void)free(fc);
            return(error);
        }

        /*
         * fill out the fields
         */
        fc->fc_type = GET_FRAMETYPE(r->r[2]);
        fc->fc_addrlevel = r->r[3];
        fc->fc_errlevel = r->r[4];
        fc->fc_handler = (void (*)())r->r[6];
        fc->fc_pwptr = r->r[5];

        /*
         * chain this structure onto the list
         */
        fc->fc_next = *fcprev;
        *fcprev = fc;

        /*
         * set receive level for this unit to the
         * loosest address filtering necessary.
         */
        update_addrlevel(unit);
    }

    /* all done */
    return(0);
}

/**********************************************************************/

/*
 * do_singlefilter - handle a claim or release on a filter level
 * that does not chain multiple frame types.
 */
static int do_singlefilter(_kernel_swi_regs *r,
                           FilterSingleRef *level,
                           FilterSingleRef *antagonist)
{
    FilterSingleRef fs = *level;
    int unit = r->r[1];

    /*
     * check whether claiming or releasing
     */
    if( (r->r[0] & FILTER_RELEASE) )
    {
        if( !fs )
            /*
             * trying to free a non-existent claim
             */
            return(EINVAL);

        if( fs->fs_handler != (void (*)())r->r[6] || fs->fs_pwptr != r->r[5] )
            /*
             * trying to release somebody else's claim
             */
            return(EPERM);

        /*
         * everything checks out, do the free
         */
        send_frametypefree(unit, r->r[2], fs);
        (void)free(fs);
        *level = NULL;

        /*
         * check whether receiver can be disabled
         */
        update_addrlevel(unit);
    }
    else
    {
        int error;
        struct et_softc *et = et_softc[unit];

        /*
         * it's a claim - most values have been range checked, but
         * take a look at frame type (which *must* be zero)
         */
        if( GET_FRAMETYPE(r->r[2]) != 0 )
            return(EINVAL);

        if( fs || *antagonist )
        {
            if( (et->et_flags & ET_DUPCLAIMEXPECTED) &&
               fs &&
               fs->fs_addrlevel == r->r[3] &&
               fs->fs_errlevel == r->r[4] &&
               fs->fs_handler == (void (*)())r->r[6] &&
               fs->fs_pwptr == r->r[5] )
            {
                /*
                 * its a legitimate reclaim - need to check that
                 * we can bring the card up live once again.
                 */
                if( (error = etioctl(unit, 1, 1)) != 0 )
                    /*
                     * return an error, but *do not* free the structure
                     */
                    return(error);

                /*
                 * set receive level for this unit to the
                 * loosest address filtering necessary.
                 */
                update_addrlevel(unit);

                return(0);
            }
            else
                /*
                 * this frame level is already claimed in some fashion
                 */
                return(INETERR_FILTERGONE);
        }

        if( (fs = (FilterSingleRef)malloc(sizeof(*fs))) == NULL )
            /*
             * cannot claim memory for this structure
             */
            return(ENOMEM);

        /*
         * check that we can bring the card up live
         */
        if( (error = etioctl(unit, 1, 1)) != 0 )
        {
            (void)free(fs);
            return(error);
        }

        /*
         * everything checks out OK, initialise the structure
         */
        fs->fs_addrlevel = r->r[3];
        fs->fs_errlevel = r->r[4];
        fs->fs_handler = (void (*)())r->r[6];
        fs->fs_pwptr = r->r[5];

        *level = fs;

        /*
         * set receive level for this unit to the
         * loosest address filtering necessary.
         */
        update_addrlevel(unit);
    }

    /* all OK */
    return(0);
}

/**********************************************************************/

static int et_filter(_kernel_swi_regs *r)
{
    int error = 0;
    u_int unit = r->r[1];
    void *dummy = NULL;

    dprintf (("", "Et_Filter: flags=%x, unit=%d, frame type=%x, address level=%x, error level=%x, pwp=%p, handler=%p\n",
              r->r[0], r->r[1], r->r[2], r->r[3], r->r[4], r->r[5], r->r[6]));
    /*
     * range checking
     */
    if( r->r[0] >= FILTER_1STRESERVED ||
       !check_addrlevel(r->r[3]) ||
       !check_errlevel(r->r[4]) )
    {
        return(EINVAL);
    }


    switch( GET_FRAMELEVEL( r->r[2]) )
    {
      case FRMLVL_E2SPECIFIC:
        error = do_chainfilter(r, e2specific + unit, e2monitor + unit);
        break;

      case FRMLVL_E2SINK:
        error = do_singlefilter(r, e2sink + unit, e2monitor + unit);
        break;

      case FRMLVL_E2MONITOR:
        if( e2specific[unit] != NULL )
            /*
             * already have some specific frames claimed,
             * therefore monitor is invalid
             */
            error = EAGAIN;
        else
            error = do_singlefilter(r, e2monitor + unit, e2sink + unit);

        break;

      case FRMLVL_IEEE:
        error = do_singlefilter(r, ieeefilter + unit,
                                (FilterSingleRef *)(&dummy));
        break;

      default:
        error = EINVAL;
        break;
    }

    /* that's all */
    return(error);
}

/**********************************************************************/

static int et_version(_kernel_swi_regs *r)
{
    if( r->r[0] )
        return(EINVAL);

    r->r[1] = DCIVERSION;
    return (0);
}

/**********************************************************************/

static int et_inquire(_kernel_swi_regs *r)
{
    if( r->r[0] )
        return(EINVAL);

    r->r[2] = dibs[r->r[1]]->dib_inquire;

    return(0);
}

/**********************************************************************/

static int et_getmtu(_kernel_swi_regs *r)
{
    if( r->r[0] )
        return(EINVAL);

    r->r[2] = ETHERMTU;
    return(0);
}

/**********************************************************************/

static int et_setmtu(_kernel_swi_regs *r)
{
    UNUSED (r);
    return(ENOTTY);
}

/**********************************************************************/

/*
 * Module Initialisation code.
 */
_kernel_oserror *et_initialise(const char *cmd_tail, int pbase, void *pw)
{
    _kernel_oserror *e;
    int unit;
    DibRef dib;
    const char location_string[] = "Expansion slot %d";

    module_wsp = pw;

    UNUSED (cmd_tail);
    UNUSED (pbase);

    debug_initialise ("", "", NULL);
    debug_set_options (0, 0, 0);
    debug_output_device (TML_OUTPUT);
    /*debug_initialise_trace (TML_OUTPUT, "tick_handler");*/

    e = calleverytick(tick_entry);
    if (e)
        return (e);

    et_init();

    if (etcnt == 0)
        return((_kernel_oserror *)0);

    /*
     * Initialize Driver Information Blocks
     */
    for( unit = 0; unit < etcnt; unit++ )
    {
        if( (dib = (DibRef)malloc(sizeof(*dib))) == NULL )
            return(et_error(ENOMEM));

        dibs[unit] = dib;

        dib->dib_swibase = ET_SWI_BASE;
        dib->dib_name = (unsigned char *)"et";
        dib->dib_unit = unit;
        dib->dib_address = et_addresses(unit);
        dib->dib_module = (unsigned char *)"Ether1";
        dib->dib_inquire = (INQ_MULTICAST | INQ_PROMISCUOUS | INQ_HWADDRVALID | INQ_HASSTATS);

        if( (dib->dib_location =
             (unsigned char *)malloc(sizeof(location_string))) == NULL )
        {
            (void)free(dib);
            return(et_error(ENOMEM));
        }
        else
        {
            sprintf((char *)dib->dib_location, location_string, xblock[unit].slot);
            dib->dib_slot.sl_slotid = xblock[unit].slot;
            dib->dib_slot.sl_minor = 0;
            dib->dib_slot.sl_pcmciaslot = 0;
            dib->dib_slot.sl_mbz = 0;
        }

        /*
         * do not bring the card up live yet - set an internal flag
         * to force a power-on self-test when the card is actually
         * brought up via the filter SWI.
         */
        et_softc[unit]->et_flags |= ET_FORCEPOST;

        /*
         * set intial address filter
         */
        address_filter[unit] = af_reject;
    }

    /*
     * check whether the mbuf manager module is loaded yet
     */
    if( !managerstarted && mb_present() )
    {
        /*
         * mbuf manager is loaded - initialise entry points
         */
        if( (e = mb_entryinit()) != NULL )
            return(e);

        /*
         * OK - set a callback to issue Service_DCIDriverStatus
         */
        callback(callb_entry, pw);

        managerstarted = 1;
    }

    return(NULL);
}

/**********************************************************************/

/*
 * Module Finalization code
 */
_kernel_oserror *et_quit(int fatal, int podule, void *pw)
{
    int i;

    UNUSED (fatal);
    UNUSED (podule);
    UNUSED (pw);

    finalising = 1;

    for( i = 0; i < etcnt; ++i )
        send_driverstatus(dibs[i], 1);

    et_final();

    removetickerevent(tick_entry);

    /*
     * finish session with mbuf manager, ignore any
     * errors (they don't mean much, since session
     * *may* still be closed, despite any errors
     * returned)
     */
    (void)mb_closesession();

    debug_terminate ();

    return(NULL);
}

/**********************************************************************/

/*
 * handle_managerstatus - deal with a MbufManagerStatus service call
 */
static void handle_managerstatus(_kernel_swi_regs *r)
{
    switch( r->r[0] )
    {
      case MbufManagerStatus_Started:
        if( !managerstarted )
        {
            /*
             * mbuf manager has appeared - initialise entry points
             */
            if( mb_entryinit() == NULL )
            {
                /*
                 * mbuf system initialised, set a callback
                 * to announce our presence
                 */
                managerstarted = 1;
                callback(callb_entry, module_wsp);
            }
        }

        break;

      case MbufManagerStatus_Stopping:
        /*
         * should only ever see this message if we are
         * finalising our own module, otherwise something
         * has gone terribly wrong (the mbuf manager should
         * only stop when all its clients have closed their
         * sessions)
         */
        if( !finalising )
            panic("Mbuf manager has stopped");

        break;

      case MbufManagerStatus_Scavenge:
        /* do nothing */
        break;

      default:
        break;
    }
}

/**********************************************************************/

/* Module Service Call handler */
void et_sc_handler(int sn, _kernel_swi_regs *r, void *  pw)
{
    int i;

    UNUSED (pw);

    /*
     * ignore nearly all calls until the
     * mbuf manager has been initialised
     */
    if( !managerstarted )
    {
        if( sn == Service_MbufManagerStatus)
            /* best not to ignore this one */
            handle_managerstatus(r);
    }
    else
    {
        switch( sn )
        {
          case Service_EnumerateNetworkDrivers:
            for( i = 0; i < etcnt; ++i )
            {
                ChDibRef chd;

                if( (chd = (ChDibRef)malloc(sizeof(*chd))) == NULL )
                    /*
                     * failed to claim memory - return as
                     * much information as possible
                     */
                    break;

                chd->chd_dib = dibs[i];
                chd->chd_next = (ChDibRef)r->r[0];
                r->r[0] = (int)chd;
            }

            break;

          case Service_DCIProtocolStatus:
            if( r->r[3] == DCIVERSION )
            {
                dprintf(("", "\021\02et: Protocol '%s' is %sing\021\07\n",
                       r->r[4], r->r[2] ? "dy" : "start"));
                /*
                 * only interested in termination calls
                 */
                if( r->r[2] == 1 )
                    filtersoff(r->r[0]);
            }

            break;

          default:
            break;
        }
    }
}

/**********************************************************************/

/*
 * Module SWI handler
 */
_kernel_oserror *et_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
    struct swient *callp;
    int error, oldstate;

    UNUSED (pw);

    /*
     * XXX
     *
     * we *assume* that, since service calls are not active
     * until the mbuf manager has been started, nobody can
     * find out our swibase, and therefore cannot raise any
     * SWIS.  if this is not true (i.e. someone looks up our
     * particular SWI number, then they deserve all the trouble
     * which they are probably likely to receive.
     */
    if( swinum >= (sizeof(et_ent) / sizeof(et_ent[0])) )
        return(et_error(ENOTTY));

    /*
     * check that a correct unit number has been
     * given for all SWIs other than Version
     */
    if( swinum != DCI4Version && r->r[1] >= etcnt  )
        return(et_error(ENXIO));

    dprintf(("", "\021\06SWI %x...", swinum & 63));
    callp = &et_ent[swinum];
    oldstate = ensure_irqs_on();
    error = (*(callp->swi_call))(r);
    restore_irqs(oldstate);

    dprintf(("", "error %d\021\07\n", error));

    return(et_error(error));
}

/**********************************************************************/

static _kernel_oserror *do_etinfo(int argc, char **argv)
{
    UNUSED (argc);
    UNUSED (argv);

    printf("%-18s", "DCI Version");
    printf("%d.%02d\n\n", DCIVERSION / 100, DCIVERSION % 100);

    if (etcnt == 0)
        printf("No Ether1 expansion cards installed\n");
    else
        pretstats(0);

    return ((_kernel_oserror *)0);
}

/**********************************************************************/

static _kernel_oserror *do_ettest(int argc, char **argv)
{
    int unit;

    UNUSED (argc);

    if( (unit = atoi(*argv)) == 0 && **argv != '0' )
    {
        _et_errblk.e_num = 2;
        sprintf(_et_errblk.e_mess, "EtTest: bad unit number '%s'", *argv);
        return((_kernel_oserror *)&_et_errblk);
    }

    if( unit >= etcnt )
    {
        _et_errblk.e_num = 3;
        sprintf(_et_errblk.e_mess, "EtTest: invalid unit number: %d", unit);
        return((_kernel_oserror *)&_et_errblk);
    }

    et_runtest(unit);
    return(NULL);
}

/**********************************************************************/

_kernel_oserror *et_cli_handler(const char *arg_string, int arg_count,
                                int cmd_no, void *pw)
{
    struct client *callp;
    int margc;
    char *margv[20];
    char *cp;
    char **argp = margv;

    UNUSED (pw);

    if( cmd_no >= sizeof(et_cli_call) / sizeof(et_cli_call[0]) )
    {
        _et_errblk.e_num = 1;
        sprintf(_et_errblk.e_mess, "EtInfo: bad command number: %d\n",
                cmd_no);
        return((_kernel_oserror *)&_et_errblk);
    }

    if( arg_count > 20 )
        /* limit set by size of margv array */
        arg_count = 20;

    margc = 0;
    cp = (char *) arg_string;
    while (*cp && arg_count-- > 0)
    {
        while (*cp == ' ' || *cp == '\t')
            cp++;

        if (*cp < ' ')
        {
            *cp = '\0';
            break;
        }

        *argp++ = cp;
        margc++;
        while (*cp >= ' ' && *cp != ' ' && *cp != '\t')
            cp++;

        if (*cp < ' ')
        {
            *cp = '\0';
            break;
        }

        *cp++ = '\0';
    }

    *argp++ = 0;

    callp = &et_cli_call[cmd_no];
    return(callp->cli_call(margc, margv));
}

static _kernel_oserror *calleverytick (void (*fun) (void))
{
    return _swix(OS_Claim, _INR(0,2), TickerV, fun, module_wsp);
    return(NULL);
}

static int removetickerevent(void (*fun)(void))
{
    return (_swix(OS_Release, _INR(0,2), TickerV, fun, module_wsp) ? -1 : 0);
}

_kernel_oserror *  tick_handler (_kernel_swi_regs *  r,
                                 void *              pw)
{
    struct et_softc *et;
    int unit;

    UNUSED (r);
    UNUSED (pw);

    for(unit = 0; unit < etcnt; unit++) {
        et = et_softc[unit];
        if ((et->et_flags & ET_RUNNING) == 0)
            continue;
        if (et->et_watch.timer > 0 && --et->et_watch.timer == 0) {
            etwatch(unit);
            et->et_watch.timer = ET_WATCHTIME * 100;
        }
    }
    return(NULL);
}

/**********************************************************************/

/*
 * send_driverstatus - send a DCIDriverStatus service
 * call for given dib
 */
void send_driverstatus(DibRef dib, int status)
{
    _swix(OS_ServiceCall, _INR(0,3), dib, Service_DCIDriverStatus,
                                     status, DCIVERSION);
}

/**********************************************************************/

/*
 * callb_handler - handler for callback primed by initialisation
 * routine: send round DCIDriverStatus service call for all units
 */
_kernel_oserror *  callb_handler (_kernel_swi_regs *  r,
                                  void *              pw)
{
    int i;
    int s = splimp();

    UNUSED (r);
    UNUSED (pw);

    for( i = 0; i < etcnt; ++i )
        send_driverstatus(dibs[i], 0);

    splx(s);

    return NULL;
}

/**********************************************************************/

static void callback (void (*f) (void), void *pw)
{
    _swix(OS_AddCallBack, _INR(0,1), f, pw);
}

/**********************************************************************/

static _kernel_oserror *et_error(int error)
{
    if (error)
    {
        if( error >= 0x80 )
            _et_errblk.e_num = error;
        else
            REALLYSETDCI4ERRNO(_et_errblk.e_num, error);

        strcpy(_et_errblk.e_mess, "Et module error");
        return ((_kernel_oserror *)&_et_errblk);
    }
    else
        return ((_kernel_oserror *)0);
}

/**********************************************************************/

/* EOF e2module.c */
@


1.1
log
@Initial revision
@
text
@d17 1
a20 2
#include "xcb.h"
#include "int_hndlr.h"
d22 17
a38 5
#include "sys/dcistructs.h"
#include "sys/errno.h"
#include "sys/mbuf.h"

#include "netinet/if_ether.h"
d42 4
d53 2
a54 2
#define IS_BROADCAST(x)	(*(u_int *)(x) == 0xffffffff && \
			 *(u_short *)((x) + 4) == 0xffff)
d64 2
a65 2
#define IS_MULTICAST(x)	((*(u_char *)(x) & 0x80) && \
			 (*(u_char *)(x)) != 0xff)
d69 1
a69 1
    static int (*swi_call)();			/* swi handler */
d77 5
a81 9
extern unsigned char *et_addresses();
extern int et_start();
extern int et_transmit();
extern int et_stats();
extern int etcnt;
static int et_version(), et_setmtu(), et_getmtu();
static int et_filter(), et_inquire();
extern int callb_entry(), tick_entry();
extern _kernel_oserror *calleverytick();
d83 1
a83 1
struct swient et_ent[] =
a94 1
#if 0
a95 1
#endif
d97 1
a97 1
struct client et_cli_call[] =
a100 1
# if 0
a101 1
# endif
d106 1
a106 1
struct
d108 1
a108 1
    int	 e_num;
d112 4
a115 4
#define ET_WATCHTIME  5

extern _kernel_oserror *et_error();
extern int etcnt;
a116 4
extern void callback(int (*f)(), void *pw);
/*extern void set_receive_level(int unit, int addrlevel);*/

extern struct et_softc *et_softc[];
a143 18
static _kernel_oserror *et_error(int error)
{
    if (error)
    {
	if( error >= 0x80 )
	    _et_errblk.e_num = error;
	else
	    REALLYSETDCI4ERRNO(_et_errblk.e_num, error);

	strcpy(_et_errblk.e_mess, "Et module error");
	return ((_kernel_oserror *)&_et_errblk);
    }
    else
	return ((_kernel_oserror *)0);
}

/**********************************************************************/

d151 1
a151 1
	return(0);
d153 1
a153 1
	return(1);
d161 1
a161 1
int af_reject(u_int level, u_char *pack_hdr, u_char *mac_addr)
d163 4
d181 4
d198 2
d201 1
a201 1
	return(1);
d203 1
a203 1
	return(0);
d219 3
a221 3
	if( IS_BROADCAST(pack_hdr) )
	    /* filter it out */
	    return(1);
d223 1
a223 1
	/* fall through case */
d226 3
a228 3
	if( IS_MULTICAST(pack_hdr) )
	    /* don't want it */
	    return(1);
d230 1
a230 1
	/* fall through case */
d234 2
a235 2
	/* protocol wants this packet */
	return(0);
d237 2
a238 2
	/*NOTREACHED*/
	break;
d258 3
a260 3
	if( isbroadcast )
	    /* filter it out */
	    return(1);
d262 1
a262 1
	/* fall through case */
d265 3
a267 3
	if( ismulticast )
	    /* don't want it */
	    return(1);
d269 1
a269 1
	/* fall through case */
d272 12
a283 12
	/*
	 * reject all packets that aren't broadcast or
	 * multicast, and which don't match the MAC address
	 */
	if( !isbroadcast && !ismulticast )
	{
	    int i;

	    for( i = 0; i < 6; ++i )
		if( pack_hdr[i] != mac_addr[i] )
		    return(1);
	}
d285 1
a285 1
	/* fall through case */
d289 2
a290 2
	/* protocol wants this packet */
	return(0);
d292 2
a293 2
	/*NOTREACHED*/
	break;
d308 5
a312 5
	af_reject,
	af_specific,
	af_normal,
	af_promiscuous,       // Haven't gotten card to do filtering for us
	af_promiscuous
d320 1
a320 1
	level = MAX(level, (int)ieeefilter[unit]->fs_addrlevel);
d323 1
a323 1
	level = MAX(level, (int)e2monitor[unit]->fs_addrlevel);
d326 1
a326 1
	level = MAX(level, (int)e2sink[unit]->fs_addrlevel);
d329 1
a329 1
	level = MAX(level, (int)fc->fc_addrlevel);
d359 1
a359 1
			     FilterChainRef *fcrptr)
d366 28
a393 28
	if( fc->fc_pwptr == pwp )
	{
	    u_int ftype;
	    SET_FRAMETYPE(ftype, fc->fc_type);
	    SET_FRAMELEVEL(ftype, level);

	    /*
	     * unchain this entry, send service call
	     * indicating it is free, and free it
	     */
	    *fcprev = fc->fc_next;
	    send_frametypefree(unit, ftype, &(fc->fc_filter));
	    (void)free(fc);

	    /*
	     * previous entry is the same,
	     * advance the current pointer
	     */
	    fc = *fcprev;
	}
	else
	{
	    /*
	     * move both pointers down the list
	     */
	    fc = fc->fc_next;
	    fcprev = (FilterChainRef *)(*fcprev);
	}
d405 1
a405 1
			      FilterSingleRef *fsrptr)
d411 10
a420 10
	/*
	 * we have a match - send a service call round
	 * to let protocol modules know about new claims
	 * available.
	 */
	u_int ftype = 0;
	SET_FRAMELEVEL(ftype, level);
	send_frametypefree(unit, ftype, fs);
	(void)free(fs);
	*fsrptr = NULL;
d439 16
a454 16
	/*
	 * start with the chained filter level
	 */
	undo_chainfilter(unit, pwp, FRMLVL_E2SPECIFIC, &e2specific[unit]);

	/*
	 * now the unique filter levels
	 */
	undo_singlefilter(unit, pwp, FRMLVL_E2SINK, e2sink + unit);
	undo_singlefilter(unit, pwp, FRMLVL_E2MONITOR, e2monitor + unit);
	undo_singlefilter(unit, pwp, FRMLVL_IEEE, ieeefilter + unit);

	/*
	 * check whether receiver can be disabled
	 */
	update_addrlevel(unit);
d465 2
a466 2
			  FilterChainRef *fcrptr,
			  FilterSingleRef *antagonist)
d475 7
a481 9
	fc && fc->fc_type != GET_FRAMETYPE(r->r[2]);
	fc = fc->fc_next, fcprev = (FilterChainRef *)*fcprev )
	/* do nothing */
	;

#ifdef DEBUG
    Printf("do_chainfilter(%x, %x): fcrptr = %x, fc = %x\n",
	   r->r[0], r->r[2], fcrptr, fc);
#endif
d488 21
a508 16
	if( !fc )
	    /*
	     * trying to free a non-existent claim
	     */
	    return(EINVAL);

	if( fc->fc_handler != (void (*)())r->r[6] || fc->fc_pwptr != r->r[5] )
	    /*
	     * trying to release somebody else's claim
	     */
	    return(EPERM);

#ifdef DEBUG
	Printf("releasing claim on frame type %x (fcprev = %x)\n",
	       GET_FRAMETYPE(r->r[2]), *fcprev);
#endif
d510 4
a513 11
	/*
	 * OK, this is a legitimate free, do it
	 */
	*fcprev = fc->fc_next;
	send_frametypefree(unit, r->r[2], &(fc->fc_filter));
	(void)free(fc);

	/*
	 * check whether receiver can be disabled
	 */
	update_addrlevel(unit);
d517 56
a572 2
	int error;
	struct et_softc *et = et_softc[unit];
d574 20
a593 72
	/*
	 * claiming
	 */
	if( fc || *antagonist )
	{
	    /*
	     * this frame type is already claimed in some fashion,
	     * check that this is not an erroneous reclaim
	     */
	    if( (et->et_flags & ET_DUPCLAIMEXPECTED) &&
	       fc &&
	       fc->fc_type == GET_FRAMETYPE(r->r[2]) &&
	       fc->fc_addrlevel == r->r[3] &&
	       fc->fc_errlevel == r->r[4] &&
	       fc->fc_handler == (void (*)())r->r[6] &&
	       fc->fc_pwptr == r->r[5] )
	    {
		/*
		 * its a legitimate reclaim - need to check that
		 * we can bring the card up live once again.
		 */
		if( (error = etioctl(unit, 1, 1)) != 0 )
		    /*
		     * return an error, but *do not* free the structure
		     */
		    return(error);

		/*
		 * set receive level for this unit to the
		 * loosest address filtering necessary.
		 */
		update_addrlevel(unit);

		return(0);
	    }
	    else
		return(INETERR_FILTERGONE);
	}

	if( (fc = (FilterChainRef)malloc(sizeof(*fc))) == NULL )
	    /*
	     * cannot claim memory for this structure
	     */
	    return(ENOMEM);

	/*
	 * check that we can bring the card up live
	 */
	if( (error = etioctl(unit, 1, 1)) != 0 )
	{
	    (void)free(fc);
	    return(error);
	}

	/*
	 * chain this structure onto the
	 * list, and fill out the fields
	 */
	fc->fc_next = *fcprev;
	*fcprev = fc;

	fc->fc_type = GET_FRAMETYPE(r->r[2]);
	fc->fc_addrlevel = r->r[3];
	fc->fc_errlevel = r->r[4];
	fc->fc_handler = (void (*)())r->r[6];
	fc->fc_pwptr = r->r[5];

	/*
	 * set receive level for this unit to the
	 * loosest address filtering necessary.
	 */
	update_addrlevel(unit);
d607 2
a608 2
			   FilterSingleRef *level,
			   FilterSingleRef *antagonist)
d618 23
a640 23
	if( !fs )
	    /*
	     * trying to free a non-existent claim
	     */
	    return(EINVAL);

	if( fs->fs_handler != (void (*)())r->r[6] || fs->fs_pwptr != r->r[5] )
	    /*
	     * trying to release somebody else's claim
	     */
	    return(EPERM);

	/*
	 * everything checks out, do the free
	 */
	send_frametypefree(unit, r->r[2], fs);
	(void)free(fs);
	*level = NULL;

	/*
	 * check whether receiver can be disabled
	 */
	update_addrlevel(unit);
d644 68
a711 2
	int error;
	struct et_softc *et = et_softc[unit];
d713 5
a717 70
	/*
	 * it's a claim - most values have been range checked, but
	 * take a look at frame type (which *must* be zero)
	 */
	if( GET_FRAMETYPE(r->r[2]) != 0 )
	    return(EINVAL);

	if( fs || *antagonist )
	{
	    if( (et->et_flags & ET_DUPCLAIMEXPECTED) &&
	       fs &&
	       fs->fs_addrlevel == r->r[3] &&
	       fs->fs_errlevel == r->r[4] &&
	       fs->fs_handler == (void (*)())r->r[6] &&
	       fs->fs_pwptr == r->r[5] )
	    {
		/*
		 * its a legitimate reclaim - need to check that
		 * we can bring the card up live once again.
		 */
		if( (error = etioctl(unit, 1, 1)) != 0 )
		    /*
		     * return an error, but *do not* free the structure
		     */
		    return(error);

		/*
		 * set receive level for this unit to the
		 * loosest address filtering necessary.
		 */
		update_addrlevel(unit);

		return(0);
	    }
	    else
		/*
		 * this frame level is already claimed in some fashion
		 */
		return(INETERR_FILTERGONE);
	}

	if( (fs = (FilterSingleRef)malloc(sizeof(*fs))) == NULL )
	    /*
	     * cannot claim memory for this structure
	     */
	    return(ENOMEM);

	/*
	 * check that we can bring the card up live
	 */
	if( (error = etioctl(unit, 1, 1)) != 0 )
	{
	    (void)free(fs);
	    return(error);
	}

	/*
	 * everything checks out OK, initialise the structure
	 */
	*level = fs;
	fs->fs_addrlevel = r->r[3];
	fs->fs_errlevel = r->r[4];
	fs->fs_handler = (void (*)())r->r[6];
	fs->fs_pwptr = r->r[5];

	/*
	 * set receive level for this unit to the
	 * loosest address filtering necessary.
	 */
	update_addrlevel(unit);
d732 2
a733 1
//printf("Et_Filter: flags=%x, unit=%d, frame type=%x, address level=%x, error level=%x, pwp=%p, handler=%p\n", r->r[0], r->r[1], r->r[2], r->r[3], r->r[4], r->r[5], r->r[6]);
d740 4
a743 1
	return(EINVAL);
d748 2
a749 2
	error = do_chainfilter(r, e2specific + unit, e2monitor + unit);
	break;
d752 2
a753 2
	error = do_singlefilter(r, e2sink + unit, e2monitor + unit);
	break;
d756 8
a763 8
	if( e2specific[unit] != NULL )
	    /*
	     * already have some specific frames claimed,
	     * therefore monitor is invalid
	     */
	    error = EAGAIN;
	else
	    error = do_singlefilter(r, e2monitor + unit, e2sink + unit);
d765 1
a765 1
	break;
d768 3
a770 3
	error = do_singlefilter(r, ieeefilter + unit,
				(FilterSingleRef *)(&dummy));
	break;
d773 2
a774 2
	error = EINVAL;
	break;
d786 1
a786 1
	return(EINVAL);
d797 1
a797 1
	return(EINVAL);
d809 1
a809 1
	return(EINVAL);
d819 1
a824 42
static void callback(int (*f)(), void *pw)
{
    _swix(OS_AddCallBack, _INR(0,1), f, pw);
}

/**********************************************************************/

/*
 * send_driverstatus - send a DCIDriverStatus service
 * call for given dib
 */
void send_driverstatus(DibRef dib, int status)
{
    _swix(OS_ServiceCall, _INR(0,3), dib, Service_DCIDriverStatus,
                                     status, DCIVERSION);
}

/**********************************************************************/

/*
 * callb_handler - handler for callback primed by initialisation
 * routine: send round DCIDriverStatus service call for all units
 */
int callb_handler(void)
{
    int i;
    int s = splimp();

    for( i = 0; i < etcnt; ++i )
	send_driverstatus(dibs[i], 0);

    splx(s);

    /*
     * finished - return a non-zero value so
     * the cmhg veneers take the correct exit
     */
    return(1);
}

/**********************************************************************/

d828 1
a828 1
_kernel_oserror *et_initialise(char *cmd_tail, int pbase, void *pw)
d837 8
d852 1
a852 1
	return((_kernel_oserror *)0);
d859 2
a860 2
	if( (dib = (DibRef)malloc(sizeof(*dib))) == NULL )
	    return(et_error(ENOMEM));
d862 1
a862 1
	dibs[unit] = dib;
d864 28
a891 28
	dib->dib_swibase = ET_SWI_BASE;
	dib->dib_name = (unsigned char *)"et";
	dib->dib_unit = unit;
	dib->dib_address = et_addresses(unit);
	dib->dib_module = (unsigned char *)"Ether1";
	dib->dib_inquire = (INQ_MULTICAST | INQ_PROMISCUOUS | INQ_HWADDRVALID | INQ_HASSTATS);

	if( (dib->dib_location =
	     (unsigned char *)malloc(sizeof(location_string))) == NULL )
	{
	    (void)free(dib);
	    return(et_error(ENOMEM));
	}
	else
	{
	    sprintf((char *)dib->dib_location, location_string, xblock[unit].slot);
	    dib->dib_slot.sl_slotid = xblock[unit].slot;
	    dib->dib_slot.sl_minor = 0;
	    dib->dib_slot.sl_pcmciaslot = 0;
	    dib->dib_slot.sl_mbz = 0;
	}

	/*
	 * do not bring the card up live yet - set an internal flag
	 * to force a power-on self-test when the card is actually
	 * brought up via the filter SWI.
	 */
	et_softc[unit]->et_flags |= ET_FORCEPOST;
d904 10
a913 10
	/*
	 * mbuf manager is loaded - initialise entry points
	 */
	if( (e = mb_entryinit()) != NULL )
	    return(e);

	/*
	 * OK - set a callback to issue Service_DCIDriverStatus
	 */
	callback(callb_entry, pw);
d915 1
a915 1
	managerstarted = 1;
d918 1
a918 1
    return ((_kernel_oserror *)0);
d926 1
a926 1
_kernel_oserror *et_quit(void)
d930 4
d937 1
a937 1
	send_driverstatus(dibs[i], 1);
d951 2
d966 15
a980 15
	if( !managerstarted )
	{
	    /*
	     * mbuf manager has appeared - initialise entry points
	     */
	    if( mb_entryinit() == NULL )
	    {
		/*
		 * mbuf system initialised, set a callback
		 * to announce our presence
		 */
		managerstarted = 1;
		callback(callb_entry, module_wsp);
	    }
	}
d982 1
a982 1
	break;
d985 9
a993 9
	/*
	 * should only ever see this message if we are
	 * finalising our own module, otherwise something
	 * has gone terribly wrong (the mbuf manager should
	 * only stop when all its clients have closed their
	 * sessions)
	 */
	if( !finalising )
	    panic("Mbuf manager has stopped");
d995 1
a995 1
	break;
d998 2
a999 2
	/* do nothing */
	break;
d1002 1
a1002 1
	break;
d1009 1
a1009 1
void et_sc_handler(int sn, _kernel_swi_regs *r)
d1013 2
d1021 3
a1023 3
	if( sn == Service_MbufManagerStatus)
	    /* best not to ignore this one */
	    handle_managerstatus(r);
d1027 38
a1064 40
	switch( sn )
	{
	  case Service_EnumerateNetworkDrivers:
	    for( i = 0; i < etcnt; ++i )
	    {
		ChDibRef chd;

		if( (chd = (ChDibRef)malloc(sizeof(*chd))) == NULL )
		    /*
		     * failed to claim memory - return as
		     * much information as possible
		     */
		    break;

		chd->chd_dib = dibs[i];
		chd->chd_next = (ChDibRef)r->r[0];
		r->r[0] = (int)chd;
	    }

	    break;

	  case Service_DCIProtocolStatus:
	    if( r->r[3] == DCIVERSION )
	    {
#ifdef DEBUG
		Printf("\021\02et: Protocol '%s' is %sing\021\07\n",
		       r->r[4], r->r[2] ? "dy" : "start");
#endif
		/*
		 * only interested in termination calls
		 */
		if( r->r[2] == 1 )
		    filtersoff(r->r[0]);
	    }

	    break;

	  default:
	    break;
	}
d1078 2
d1091 1
a1091 1
	return(et_error(ENOTTY));
d1098 1
a1098 1
	return(et_error(ENXIO));
d1100 1
a1100 3
#ifdef DEBUG
    Printf("\021\06SWI %x...", swinum & 63);
#endif
d1106 1
a1106 3
#ifdef DEBUG
    Printf("error %d\021\07\n", error);
#endif
d1115 3
d1122 1
a1122 1
	printf("No Ether1 expansion cards installed\n");
d1124 1
a1124 1
	pretstats(0);
a1128 1
#if 0
d1135 3
a1137 1
    if( (unit = strtol(*argv, NULL, 10)) == 0 && **argv != '0' )
d1139 3
a1141 3
	_et_errblk.e_num = 2;
	sprintf(_et_errblk.e_mess, "EtTest: bad unit number '%s'", *argv);
	return((_kernel_oserror *)&_et_errblk);
d1146 3
a1148 3
	_et_errblk.e_num = 3;
	sprintf(_et_errblk.e_mess, "EtTest: invalid unit number: %d", unit);
	return((_kernel_oserror *)&_et_errblk);
a1153 1
#endif
d1157 2
a1158 2
_kernel_oserror *et_cli_handler(char *arg_string, int arg_count,
				int cmd_no, void *pw)
d1166 2
d1170 4
a1173 4
	_et_errblk.e_num = 1;
	sprintf(_et_errblk.e_mess, "EtInfo: bad command number: %d\n",
		cmd_no);
	return((_kernel_oserror *)&_et_errblk);
d1177 2
a1178 2
	/* limit set by size of margv array */
	arg_count = 20;
d1181 1
a1181 1
    cp = arg_string;
d1184 2
a1185 2
	while (*cp == ' ' || *cp == '\t')
	    cp++;
d1187 5
a1191 16
	if (*cp < ' ')
	{
	    *cp = '\0';
	    break;
	}

	*argp++ = cp;
	margc++;
	while (*cp >= ' ' && *cp != ' ' && *cp != '\t')
	    cp++;

	if (*cp < ' ')
	{
	    *cp = '\0';
	    break;
	}
d1193 12
a1204 1
	*cp++ = '\0';
d1213 1
a1213 3
#define TickerV 0x1C

_kernel_oserror *calleverytick(int (*fun)())
d1216 1
d1219 1
a1219 1
int removetickerevent(int (*fun)())
d1224 2
a1225 1
int tick_handler(int *r, void *pw)
d1230 3
d1242 61
a1302 1
    return (1);
@


1.1.1.1
log
@Initial import of Ether1 into CVS.  These sources will not even compile with
current libraries, and are just here to act as a reference point for imminent
changes.
@
text
@@

head	1.2;
access;
symbols
	Ether1-4_01:1.2
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2000.12.05.20.37.22;	author blaughto;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.13.16.59.07;	author blaughto;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.13.16.59.07;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.2
log
@  DCI-4 compatible.
  32-bit compatible.
  Fixed timing problem causing instablility on fast machines.
Details:
  Bits in mbuf header fields were being set that shouldn't, which is why it
  didn't work with Internet5 - Kevin found this one.

  Made assembler 32-bit compatible - now uses AsmUtils for some stuff and
  based the rest on the 32-bit compatible poduleirq code in EtherI.

  Setting DCI-4 filters causes the hardware to be reconfigured.  On fast
  (StrongARM) machines, a second DCI-4 filter call could occur before the
  hardware had finished dealing with the first reconfigure command.  The
  reconfigure command structure would be overwritten and linked back to
  itself, causing an infinite loop in the ISR.  Fixed by adding a busy flag
  to the command structures which is polled until clear before constructing
  a command and sending it to the hardware.
Admin:
  Tested on and off over several months.  Performance may degrade on Internet 5
  because card is put into promiscuous mode due to an inadequecy in its
  hardware multicast filtering (no easy way to tell it to receive all multicast
  addresses).  This might be work-aroundable by discovering the hashing
  algorithm that the card uses and finding a canned list of addresses that fills
  in all the bits in the table, but probably isn't worth the effort.

  Still appear to be some timing related problems if you reload the driver
  after the interface has been configured.  Doesn't crash, but get hardware
  timeouts that it doesn't recover from - will look at.

  Briefly tested 26bit/32bit stuff - appears to work for both.

Version 4.01. Tagged as 'Ether1-4_01'
@
text
@/* Copyright 2000 Pace Micro Technology plc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <DebugLib/DebugLib.h>

#include <sys/errno.h>
#include <sys/types.h>
#include <sys/mbuf.h>
#include <sys/dcistructs.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <net/if.h>
#include <netinet/if_ether.h>

#include <int_hndlr.h>
#include <xcb.h>
#include <ioc.h>
#include <delay.h>

#include "e1module.h"
#include "if_et.h"
#include "EtHdr.h"
#include "poduleirqs.h"

#define RBUF_SIZE MINCONTIG   /* receive buffer size  (same size as mbufs) */
#define TBUF_SIZE ETHERMTU  /* transmit buffer size */
#define NRFD 45             /* no of receive buffers descriptors (rx packets) */
#define NRBD 175            /* no of receive buffers */
#define NXMT 12             /* no of transmit buffers */

#define pageno(addr) (((int)(addr) >> PAGESHIFT) & TOPPAGE)


#define iowrite(where, value) where = ((unsigned)(value) << 16)
/*
This one doesn't work yet, but should be used.
#define iowrite(where, value) where = (((unsigned)(value) << 16)|(u_short)value)
*/

static void etintr (int unit);
static void et_shutdown (int);
static void etsetup (int);
static void setup_tx_bufs (struct et_softc *);
static void setup_rx_bufs (struct et_softc *);
static void wait_scb (struct et_softc *);
static void issue_cmd (struct et_softc *, struct obj_cb *);
static void et_cmd_done (struct et_softc *etp);
static void selectpage (struct et_softc *et, int n);
static void etread (struct et_softc *et, struct obj_rfd *rfd);
static void stats_init (struct et_softc *et);
static lanceaddr alloc_struct (struct et_softc *et, int size);
static lanceaddr alloc_buffer (struct et_softc *et, int bufsize);
static struct mbuf *if_rdbuf (lanceaddr rxbuf, int buflen, struct et_softc *et);

static caddr_t ARMaddress (struct et_softc *et, lanceaddr lanceptr);
static lanceaddr LANCEaddress (struct et_softc * et, caddr_t ioaddr);

static struct obj_cfg *make_cfg (struct et_softc *et, int int_loop, int ext_loop, int s);
static struct obj_ias *make_ias (struct et_softc *et);
static struct obj_dia *make_dia (struct et_softc *et);
#ifdef  ET_TDR
static struct obj_tdr *make_tdr (et_softc * et);
#endif /* ET_TDR */
extern char *ether_sprintf(register u_char *ap);


struct et_softc *et_softc[4];

int etcnt = 0;
struct xcb_block xblock[4];

extern caddr_t acopy_io_out (caddr_t ioaddr, caddr_t buffer, int count);
extern caddr_t acopy_io_in (caddr_t ioaddr, caddr_t buffer, int count);
#define copy_io_out acopy_io_out
#define copy_io_in  acopy_io_in

extern void et_irq_entry1 (void);
extern void et_init_high (int  unit);
extern void et_init_low (int unit, int irqs);

extern void callproto (Dib *, struct mbuf *, void (*)(), unsigned int);
static int etmem_test (int unit);
static int tx_mbufs (struct et_softc *et, struct mbuf *m0, u_char *edst, u_int type);


extern int (*address_filter[4]) (u_int level, u_char * pack_hdr, u_char * mac_addr);

static char et_lastlog[64] = { 0 };
static char et_lasterr[64] = { 0 };

static struct stats st = { 0 };

#define ET_TYPE    3

#define MEMCADDR  (0x112)
#define MEMCBIT   1

void et_init (void)
{
    int i, d;
    int ncards;
    u_char buffer[16];
    int s;
    u_int addr;

    if (_swix (Podule_ReturnNumber, _OUT (0), &ncards))
        return;

    s = splet ();
    for (i = 0; i < ncards; i++)
    {
        if (_swix (Podule_ReadID, _IN (3) | _OUT (0), i, &d) == NULL && d == 0)
        {
            if (_swix (Podule_ReadHeader, _INR (2, 3), buffer, i) == NULL)
            {
                if (((buffer[3]) | (buffer[4] << 8)) == ET_TYPE)
                {
                    _swix (Podule_HardwareAddress, _IN (3) | _OUT (3), i, &addr);
                    addr &= 0xFFEFFC00;         /* Extract fast address */
                    xblock[etcnt].address = (u_char *) addr;
                    xblock[etcnt].unit = etcnt;
                    xblock[etcnt].slot = i;
                    xblock[etcnt].wsp = module_wsp;
                    et_init_high (etcnt++);
                }
            }
        }
    }
    if (etcnt == 0)
    {
        splx (s);
        return;
    }
    for (i = 0; i < 4; i++)
    {
        if (xblock[i].address)
        {
            et_init_low (i, 0);
        }
    }
    splx (s);
    for (i = 0; i < 4; i++)
    {
        if (xblock[i].address)
        {
            et_init_low (i, 1);
        }
    }

    _swix (OS_SetVarVal, _INR (0, 4), "Inet$EtCount", &etcnt, 4, 0, 1);

    _swix (OS_SetVarVal, _INR (0, 4), "Inet$EtherType", "et0", 3, 0, 0);
}

int et_transmit (_kernel_swi_regs* r)
{
    u_int flags = r->r[0];
    u_int unit = r->r[1];
    u_int type = r->r[2];
    struct et_softc *et = et_softc[unit];
    int error = 0;
    u_char *edst = (u_char *) (r->r[4]);
    struct mbuf *m, *m0 = (struct mbuf *) (r->r[3]);

    dprintf (("", "et_transmit: unit=%d, flags=%x, type=%x, m0=%p\n",
              unit, flags, type, m0));

    if (flags >= TX_1STRESERVED)
    {
        error = EINVAL;
    }

    /*
     * run down the supplied mbuf list, transmitting each
     * chain, until an error is flagged.  all mbuf chains
     * not transmitted before an error condition arises
     * are silently dropped
     */
    while (m0)
    {
        m = m0;
        m0 = m0->m_list;

        if (!error)
        {
            error = tx_mbufs (et, m, edst, type);
        }
        dprintf (("", "error=%d\n", error));
        if (!(flags & TX_PROTOSDATA))
        {
            m_freem (m);
        }
    }

    return (error);
}

static void claim_device_interrupt (int unit)
{
    _swix (OS_ClaimDeviceVector, _INR (0, 4), 13, et_irq_entry1, &xblock[unit],
           xblock[unit].address,
           1);
}

static void release_device_interrupt (int unit)
{
    _swix (OS_ReleaseDeviceVector, _INR (0, 4), 13, et_irq_entry1, &xblock[unit],
           xblock[unit].address,
           1);
}

void et_final (void)
{
    int i;

    for (i = 0; i < 4; i++)
    {
        if (xblock[i].address)
        {
            et_shutdown (i);
            release_device_interrupt (i);
        }
    }
}

/* R0 is set up from the xblocks in et_irq_entry1 */
_kernel_oserror *et_irq_handler (_kernel_swi_regs *r, void *pw)
{
    UNUSED (pw);

    set_irqsareoff ();
    etintr (r->r[0]);
    clear_irqsareoff ();

    return (NULL);
}

unsigned char *et_addresses (int unit)
{
    return et_softc[unit]->et_addr;
}


extern int pretstats (int flag)
{
    struct et_softc *et;
    int unit;
    int first = 1;
    int filters_active;

    UNUSED (flag);

    for (unit = 0; unit < 4; unit++)
    {
        if (xblock[unit].address)
        {
            et = et_softc[unit];
            filters_active = 0;

            if (et->et_flags & ET_FAULTY)
            {
                printf ("Unit %d is FAULTY. Try machine reset to clear\n", unit);
                continue;
            }
            if (first)
            {
                first = 0;
            }
            else
            {
                printf ("\n");
            }

            if (etcnt > 1)
            {
                printf ("%s %d\n\n", "Unit", unit);
            }
            printf ("%-18s", "Card Info");
            printf ("Slot=%d, Ethernet address=%s\n\n", xblock[unit].slot, ether_sprintf (&et->et_addr[0]));
            printf ("%-18s", "I/O Stats");
            printf ("Rxframes=%ld, Rxerrs=%ld, Txframes=%ld, Txerrs=%ld\n",
                    et->et_st_rx_frames,
                    et->et_st_rx_general_errors,
                    et->et_st_tx_frames,
                    et->et_st_tx_general_errors);
            printf ("%-18s", " ");
            printf ("Collisions=%ld, Unwanted frames=%ld\n",
                    et->et_st_collisions, et->et_st_unwanted_frames);
            printf ("Active Filters:\n");

            if (ieeefilter[unit])
            {
                ++filters_active;
                printf ("%-18s: handler @@%p, r12 = %08x\n", "IEEE",
                        (ieeefilter[unit])->fs_handler,
                        (ieeefilter[unit])->fs_pwptr);
            }

            if (e2monitor[unit])
            {
                ++filters_active;
                printf ("%-18s: handler @@%p, r12 = %08x\n", "Ethernet2 Monitor",
                        (e2monitor[unit])->fs_handler,
                        (e2monitor[unit])->fs_pwptr);
            }

            if (e2sink[unit])
            {
                ++filters_active;
                printf ("%-18s: handler @@%p, r12 = %08x\n", "Ethernet2 Sink",
                        (e2sink[unit])->fs_handler,
                        (e2sink[unit])->fs_pwptr);
            }

            if (e2specific[unit])
            {
                FilterChainRef fc = e2specific[unit];
                char *firstline = "Specific Types";

                ++filters_active;

                while (fc)
                {
                    printf ("%-18s: type %x, level %x, handler @@%p, r12 = %08x\n",
                            firstline, fc->fc_type, fc->fc_addrlevel, fc->fc_handler, fc->fc_pwptr);

                    firstline = "";
                    fc = fc->fc_next;
                }
            }

            if (!filters_active)
            {
                printf ("(no filters active)\n");
            }

            if (et_lastlog[0])
            {
                printf ("\n%-18s%s\n", "Driver Info", et_lastlog);
                et_lastlog[0] = 0;
            }
            if (et_lasterr[0])
            {
                printf ("%-18s%s\n", "Driver Error", et_lasterr);
                et_lasterr[0] = 0;
            }
        }
    }

    return (1);
}

static void etcard_reset (int unit)
{
    /*
     * Compute the card registers' address - note that we always
     * access the card at FAST speed.
     */
    struct et_registers *regs = (struct et_registers *) xblock[unit].address;

    /* Reset the card and check this succeeded */
    iowrite (regs->control, RESET);
    if ((((XCBIDRef) regs)->id0 & XCB_ID0_IRQ) != 0)
    {
        sprintf (et_lasterr, "Ethernet card in slot %d: reset failed\n", xblock[unit].slot);
        iowrite (regs->control, 0);
    }
}


/*
 * High-priority XCB card initialisation.  Reset this card.
 */
void et_init_high (int unit)
{
    etcard_reset (unit);
}


/*
 * This is the XCB card second/third phase entry point (called by the
 * xcb manager at spl0) to check hardware and inform upper layers of
 * networking software that interfaces are available.  The xcb manager
 * is informed of the routine to handle interrupts for each configured
 * card.  This implementation does not provide a working if_reset
 * or if_init routine in the interface structure.  This decision was
 * taken after a search of the code failed to find any use of this
 * routines at the network/interface level. They have been replaced by
 * panic() calls in case they are used by other parts of networking
 * layers at a later date.  Unusually for a network interface, the main
 * card initialisation is done with interrupts enabled since this
 * allows the interrupt handler to perform its natural function. The
 * LANCE is designed to be driven by interrupts and the complexity of
 * the code is reduced.
 */
void et_init_low (int unit, int irqs)
{
    struct et_softc *et;
    struct et_registers *regs;

    if (irqs == 0)
    {
        /*
         * Phase 2 xcb initialisation - check hardware and
         * declare interrupts etc if all OK.
         */
        int i;

        /* Allocate a software control structure */
        et = (struct et_softc *) malloc (sizeof (struct et_softc));
        memset ((char *) et, 0, sizeof (struct et_softc));

        et_softc[unit] = et;
        et->et_unit = unit;
        regs = (struct et_registers *) xblock[unit].address;
        et->et_registers = regs;
        et->et_slot = xblock[unit].slot;
        /*
         * Copy the pcb revision from the rom - this is stored
         * in the LSB of the 8th word of ROM space, 0th element
         * of the generalised "data" field of an XCBID.
         */
        et->et_pcb_issue = ((XCBIDRef) regs)->data[0].d_uchar[0];
        /*
         * We can't handle old-issue boards, even if xcbman actually
         * manages to detect their presence...
         */
        if (et->et_pcb_issue == 0x0c || et->et_pcb_issue == 0xf3)
        {
            et->et_flags = ET_FAULTY;
            sprintf (et_lasterr, "Ethernet card in slot %d ignored: *OBSOLETE issue %X*\n",
                     et->et_slot, et->et_pcb_issue);
            return;
        }
        /*
         * Get unique station ethernet hardware adddress from
         * card ROM, LSB of words 9 thru' E.
         */
        for (i = 0; i < 6; i++)
            et->et_addr[i] = ((XCBIDRef) regs)->data[1 + i].d_uchar[0];

        et->et_dpram = (caddr_t) ((u_int) xblock[unit].address | (1 << 13));
        et->et_flags = 0;

        stats_init (et);
        /*
         * Declare the card to the xcb manager
         */
        claim_device_interrupt (unit);
    }
    else
    {
        /*
         * XCB init phase 3: further tests - declare unit to system if OK
         *
         * Give the LANCE a prod by releasing RESET+CA
         */
        et = et_softc[unit];
        if (et->et_flags & ET_FAULTY)
            return;                    /* ignore faulty units */
        regs = et->et_registers;
        iowrite (regs->control, RESET);
        iowrite (regs->control, 0);
        /* Check out the memory - etmem_test prints diags for us */
        if (!etmem_test (unit))
        {
            int s = splet ();

            et->et_flags |= ET_FAULTY; /* mark failure */
            iowrite (regs->control, RESET);     /* leave board disabled */
            splx (s);
            return;
        }
        et->et_st_link_status |= ST_STATUS_OK;
        et->et_st_link_polarity = 1;
        /*
         * We have a working ethernet unit, folks.
         *
         * Initialise control structures in LANCE memory and
         * get proceedings underway.
         */
        etsetup (unit);
    }
}


/*
 * XCB interface entry point for system reboot/halt time - close
 * down the card, and ensure it's in reset state.  etcard_reset
 * does all the work for us.
 */
static void et_shutdown (int unit)
{
    etcard_reset (unit);
}


static void etsetup (int unit)
{
    register struct et_softc *et = et_softc[unit];
    register struct obj_scp *scp;
    register struct obj_iscp *iscp;
    register struct obj_scb *scb;
    register lanceaddr la;
    register int i;
    int s = splet ();

    et->et_backoff = 60;                                                    /* Start at 1 minute and increase */
    et->et_watch.cmd = 0;
    et->et_watch.tdr = 0;
    et->et_flags = 0;
    iowrite (et->et_registers->control, RESET);
    iowrite (et->et_registers->control, 0);
    et->next_buffer = (lanceaddr) 0;
    et->cfg = (struct obj_cfg *) 0;
    et->ias = (struct obj_ias *) 0;
    et->dia = (struct obj_dia *) 0;
    et->tdr = (struct obj_tdr *) 0;
    /* set up SCP AND ISCP */
    selectpage (et, TOPPAGE);                                               /* all control structures are in TOPPAGE, recv & xmt buffers elsewhere */
    scp = (struct obj_scp *) ARMaddress (et, 0xFFFFF6);                     /* SCP is at fixed address 0x0FFFFF6, the top byte gets ignored */
    et->last_struct = LANCEaddress (et, (caddr_t) scp);
    iowrite (scp->sysbus, 0);                                               /* 16 bit bus */
    la = alloc_struct (et, SZ_ISCP);
    iowrite (scp->iscpaddr, la);
    iowrite (scp->iscptopaddr, 0);
    iscp = (struct obj_iscp *) ARMaddress (et, la);
    iowrite (iscp->busy, 1);                                                /* cleared by LANCE when it has completed initialisation */
    la = alloc_struct (et, SZ_SCB);
    iowrite (iscp->scb_offset, la);
    iowrite (iscp->scb_base[0], 0);
    iowrite (iscp->scb_base[1], 0);                                         /* base address of 64K segment */
    /* set up SCB */
    scb = (struct obj_scb *) ARMaddress (et, la);
    iowrite (scb->status, 0);
    iowrite (scb->command, 0);
    iowrite (scb->cbl, LANCE_NULL);
    iowrite (scb->rfa, LANCE_NULL);
    iowrite (scb->crcerrs, 0);                                              /* clear error counts */
    iowrite (scb->alnerrs, 0);
    iowrite (scb->rscerrs, 0);
    iowrite (scb->ovrnerrs, 0);
    et->scb = scb;                                                          /* save scb pointer */
    et->cmd_tail = NULL;
    setup_tx_bufs (et);
    setup_rx_bufs (et);
    attention (et, CA);                                                     /* init LANCE: RESET,CA -> read SCP */
    for (i = 0; i < 3; i++)
    {
        MICRODELAY (1000);
        if ((scb->status & 0xffff) == (SCB_CX | SCB_CNA))
            break;
    }
    if ((scb->status & 0xffff) != (SCB_CX | SCB_CNA))
    {
        sprintf (et_lastlog, "Unit %d: can't initialise, status 0x%x\n",
                 unit, scb->status & 0xffff);
        et->et_flags |= ET_FAULTY;
        iowrite (et->et_registers->control, RESET);                         /* Leave board disabled */
        splx (s);
        return;
    }
    splx (s);
    issue_cmd (et, (struct obj_cb *) make_cfg (et, 0, 0, ST_STATUS_BROADCAST));
    issue_cmd (et, (struct obj_cb *) make_ias (et));
    issue_cmd (et, (struct obj_cb *) make_dia (et));
}

#define O(n) (1 << n)
#define Z(n) (O(n) ^ 0xffff)

static int etmem_test (int unit)
{
    struct et_softc *et = et_softc[unit];
    unsigned pattern[34];
    unsigned pat, *addr, val, offset, page;
    register int i, j;

    iowrite (et->et_registers->control, RESET);
    iowrite (et->et_registers->control, 0);
    for (i = 0; i < 16; i++)
    {
        pattern[i] = O (i);
    }
    pattern[16] = 0;
    for (i = 0; i < 16; i++)
    {
        pattern[17 + i] = Z (i);
    }
    pattern[17 + 16] = 0xffff;
    for (i = 0; i < 34; i += 17)
    {
        /* The complete test takes too long, just do 1s and 0s. */
        offset = i;
        for (page = 0; page <= TOPPAGE; page++)
        {
            selectpage (et, page);
            addr = (unsigned *) et->et_dpram;
            for (j = 0; j < PAGESIZE; j += 2, addr++)
            {
                pat = pattern[offset];
                iowrite (*addr, pat);
                if (++offset == 34)
                {
                    offset = 0;
                }
            }
        }
        offset = i;
        for (page = 0; page <= TOPPAGE; page++)
        {
            selectpage (et, page);
            addr = (unsigned *) et->et_dpram;
            for (j = 0; j < PAGESIZE; j += 2, addr++)
            {
                pat = pattern[offset];
                val = *addr & 0xffff;
                if (val != pat)
                {
                    sprintf (et_lasterr, "Unit %d: slot %d: RAM fault: addr 0x%04x, w:0x%04x r:0x%04x\n",
                             unit, et->et_slot, page * PAGESIZE + j, pat, val);
                    return (0);
                }
                if (++offset == 34)
                {
                    offset = 0;
                }
            }
        }
    }
    return (1);
}


/* Use transmit buffers large enough to hold a whole ethernet package. We
 * have enough memory to avoid the added complication of buffer chaining.
 * Allocate an array of TCBs, each one pointing to one TBD in TOPPAGE, which
 * in turn points to one data buffer in any page but TOPPAGE.
 */
static void setup_tx_bufs (struct et_softc *et)
{
    register struct obj_tbd *tbd;
    register struct obj_tcb *tcb;
    register struct obj_nop *nop;
    register lanceaddr tcbla, la, nopla, temp;
    register int i;

    /*
    ** TransmitControlBlocks are always used with one NOP command following
    ** so that the EL bit can be left clear on a transmit command to allow
    ** chaining to work.
    **      +-----------+                   +-----------+
    **      |   T C B   +------------------>|   N O P   +--------->   etc
    **      +-----+-----+                   +-----------+
    **            |
    **            |         +-----------+
    **            +-------> |   T B D   |
    **                      +-----+-----+
    **                            |
    **                            |
    **                            |         +---------------+
    **                            +-------> |  B u f f e r  |
    **                                      |               |
    **                                      |               |
    **                                      |               |
    */
    tcbla = alloc_struct (et, SZ_TCB);
    et->tcb_free = (struct obj_tcb *) ARMaddress (et, tcbla);
    nopla = alloc_struct (et, SZ_NOP);
    et->nop_free = (struct obj_nop *) ARMaddress (et, nopla);
    for (i = 0; i <= NXMT - 1; i++)
    {
        tcb = (struct obj_tcb *) ARMaddress (et, tcbla);
        nop = (struct obj_nop *) ARMaddress (et, nopla);
        iowrite (tcb->status, 0);
        iowrite (nop->status, 0);
        iowrite (tcb->command, CB_XMT);
        iowrite (nop->command, CB_NOP);
        if (i == NXMT - 1)
        {
            iowrite (tcb->link, LANCE_NULL);
            iowrite (nop->link, LANCE_NULL);
        }
        else
        {
            tcbla = alloc_struct (et, SZ_TCB);
            nopla = alloc_struct (et, SZ_NOP);
            iowrite (tcb->link, tcbla);
            iowrite (nop->link, nopla);
        }
        la = alloc_struct (et, SZ_TBD);
        iowrite (tcb->tbd, la);
        tbd = (struct obj_tbd *) ARMaddress (et, la);
        iowrite (tbd->next_tbd, LANCE_NULL);
        temp = alloc_buffer (et, TBUF_SIZE);
        iowrite (tbd->buffer, temp);
        iowrite (tbd->buffer_hi, 0);   /* buffer address is 24 bit */
    }
}

/* Allocate a circular linked list of RFDs and a circular linked list of RBDs
 * in top page, each RBD pointing to one buffer elsewhere.  Each buffer is
 * the size of a mbuf, since the LANCE does scatter/gather DMA and it makes
 * better use of the buffer memory. The limiting factor is RBDs in the
 * TOPPAGE not the actual buffer space.
 */
static void setup_rx_bufs (struct et_softc *et)
{
    register struct obj_rfd *rfd;
    register struct obj_rbd *rbd;
    lanceaddr head, temp;
    register lanceaddr la;
    register int i;

    /* circular list of RFDs */
    head = la = alloc_struct (et, SZ_RFD);
    for (i = 0; i <= NRFD - 1; i++)
    {
        rfd = (struct obj_rfd *) ARMaddress (et, la);
        iowrite (rfd->status, 0);
        iowrite (rfd->rbd, LANCE_NULL);
        if (i != (NRFD - 1))
        {
            la = alloc_struct (et, SZ_RFD);
            iowrite (rfd->command, 0);
            iowrite (rfd->link, la);
        }
        else
        {
            iowrite (rfd->command, RFD_EL);
            iowrite (rfd->link, head);
        }
    }
    et->rfd_head = (struct obj_rfd *) ARMaddress (et, head);
    et->rfd_tail = rfd;
    /* put pointer to rfa in scb */
    iowrite (et->scb->rfa, head);

    /* circular list of RBDs */
    head = la = alloc_struct (et, SZ_RBD);
    iowrite (et->rfd_head->rbd, head);
    for (i = 0; i <= NRBD - 1; i++)
    {
        rbd = (struct obj_rbd *) ARMaddress (et, la);
        iowrite (rbd->status, 0);
        temp = alloc_buffer (et, RBUF_SIZE);
        iowrite (rbd->buffer, temp);
        iowrite (rbd->buffer_hi, 0);
        if (i != NRBD - 1)
        {
            la = alloc_struct (et, SZ_RBD);
            iowrite (rbd->size, RBUF_SIZE);
            iowrite (rbd->next, la);
        }
        else
        {
            iowrite (rbd->size, RBD_EL | RBUF_SIZE);
            iowrite (rbd->next, head);
        }
    }
    et->rbd_tail = rbd;
}


static int etbringup (int unit)
{
    register struct et_softc *et = et_softc[unit];
    int s;


    if (et->et_flags & ET_RUNNING)
        return (1);
    etsetup (unit);
    if (et->et_flags & ET_FAULTY)
        return (0);
    s = splet ();
    et->et_flags |= ET_RUNNING;

    /* start receive unit */
    wait_scb (et);
    iowrite (et->scb->command, RU (START));
    if ((et->scb->cbl & 0xffff) != LANCE_NULL)
    {
        iowrite (et->scb->command, et->scb->command | CU (START));
        et->et_watch.cmd = 3;
    }
    attention (et, CA);
    et->et_watch.timer = ET_WATCHTIME * 100;
    splx (s);
    return (1);
}


int etioctl (int unit, int cmd, int flag)
{
    register struct et_softc *et;
    register struct obj_scb *scb;

    dprintf (("", "etioctl: unit=%d, cmd=%d, flag=%d\n", unit, cmd, flag));

    if (unit < 0 || unit > 4)
        return (1);
    et = et_softc[unit];

    switch (cmd)
    {

        case 0:
            if ((et->et_flags & ET_FAULTY) || !etbringup (unit))
                return (1);
            break;

        case 1:
            scb = et->scb;
            et->et_flags &= ~ET_SQEINFORMED;    /* Will print message on next SQE error */
            if (et->et_flags & ET_FAULTY)
            {
                /* Reset the card to disable it - no rx */
                iowrite (et->et_registers->control, RESET);
                break;
            }
            if (flag == 0 && et->et_flags & ET_RUNNING)
            {
                /* Reset the card to disable it - no rx */
                iowrite (et->et_registers->control, RESET);
                et->et_flags &= ~ET_RUNNING;
            }
            else if (flag && (et->et_flags & ET_RUNNING) == 0)
            {
                if (!etbringup (unit))
                    return (1);
            }
#ifdef  ET_TDR
            et->et_watch.tdr = 5;
            issue_cmd (et, make_tdr (et));
#endif /* ET_TDR */
        default:
            break;


    }
    return (0);
}


#define CFG_FIFO_LIM(n) ((n)<<8)
#define CFG_BYTE_CNT(n) (n)

#define CFG_SRDY(tf) ((tf)<<6)
#define CFG_SAV_BF(tf) ((tf)<<7)
#define CFG_ADDR_LEN(n) ((n)<<8)
#define CFG_AL_LOC(tf) ((tf)<<11)
#define CFG_PREAM_LEN(n) ((n)<<12)
#define CFG_INT_LPBCK(tf) ((tf)<<14)
#define CFG_EXT_LPBCK(tf) ((tf)<<15)

#define CFG_LIN_PRIO(n) (n)
#define CFG_ACR(n) ((n)<<4)
#define CFG_BOF_MET(tf) ((tf)<<7)
#define CFG_IFRM_SPACE(n) ((n)<<8)

#define CFG_SLOT_TIME(n) (n)
#define CFG_RETRY_NUM(n) ((n)<<12)

/*#define CFG_PRM(tf) (tf)*/
#define CFG_PRM(tf) (1)
#define CFG_BC_DIS(tf) ((tf)<<1)
#define CFG_MANCH(tf) ((tf)<<2)
#define CFG_TONO_CRS(tf) ((tf)<<3)
#define CFG_NCRC_INS(tf) ((tf)<<4)
#define CFG_CRC_16(tf) ((tf)<<5)
#define CFG_BT_STF(tf) ((tf)<<6)
#define CFG_PAD(tf) ((tf)<<7)
#define CFG_CRSF(n) ((n)<<8)
#define CFG_CRS_SRC(tf) ((tf)<<11)
#define CFG_CDTF(n) ((n)<<12)
#define CFG_CDT_SRC(tf) ((tf)<<15)

#define CFG_MIN_FRM_LEN(n) (n)

static struct obj_cfg *make_cfg (struct et_softc *et, int int_loop, int ext_loop, int s)
{
    register struct obj_cfg *cfg = et->cfg;

    if (cfg == NULL)
    {
        et->cfg = cfg = (struct obj_cfg *) ARMaddress (et, alloc_struct (et, SZ_CFG));
    }
    else
    {
        while ((et->et_flags & ET_DOING_CFG) != 0)
        {
            /* Busy-wait until the previous configure command has been
             * processed.  If you don't do this then you can end up overwriting
             * the previous command structure if this routine gets called again
             * before the previous one has finished.  This will cause the
             * configure command structure's next pointer to point back to the
             * same command, so the interrupt handler will go into an infinite
             * loop.
             *
             * This is what was causing the problems with StrongARM - it
             * wasn't a 'StrongARM bug' per se, but the StrongARM is
             * sufficiently quick that the DCI4 Filter SWI (which is mostly
             * what causes this routine to be called) can be issued again before
             * the previous one has been fully dealt with.
             */
        }
    }

    et->et_flags |= ET_DOING_CFG;

    int_loop &= 1;
    ext_loop &= 1;
    iowrite (cfg->status, 0);
    iowrite (cfg->command, CB_EL | CB_CFG);
    iowrite (cfg->link, LANCE_NULL);
    iowrite (cfg->param[0], CFG_FIFO_LIM (8) | CFG_BYTE_CNT (10));
                                       /* Change BYTE_CNT if altering more
                                        * parameters */
    iowrite (cfg->param[1], CFG_SRDY (1) | CFG_SAV_BF (0) |
             CFG_ADDR_LEN (6) | CFG_AL_LOC (0) | CFG_PREAM_LEN (2) |
             CFG_INT_LPBCK (int_loop) | CFG_EXT_LPBCK (int_loop | ext_loop));
    iowrite (cfg->param[2], CFG_LIN_PRIO (0) | CFG_ACR (0) | CFG_BOF_MET (0) |
             CFG_IFRM_SPACE (96));
    iowrite (cfg->param[3], CFG_SLOT_TIME (512) | CFG_RETRY_NUM (15));
    iowrite (cfg->param[4], CFG_PRM (s == ST_STATUS_PROMISCUOUS) |
             CFG_BC_DIS (s == ST_STATUS_DIRECT) |
             CFG_MANCH (0) | CFG_TONO_CRS (0) | CFG_NCRC_INS (0) |
             CFG_CRC_16 (0) | CFG_BT_STF (0) | CFG_PAD (0) |
             CFG_CRSF (0) | CFG_CRS_SRC (0) | CFG_CDTF (0) |
             CFG_CDT_SRC (0));
    return (cfg);
}


static struct obj_ias *make_ias (struct et_softc *et)
{
    register struct obj_ias *ias = et->ias;

    if (ias == NULL)
    {
        et->ias = ias = (struct obj_ias *) ARMaddress (et, alloc_struct (et, SZ_IAS));
    }
    else
    {
        while ((et->et_flags & ET_DOING_IAS) != 0)
        {
            /* Busy-wait until the previous configure command has been
             * processed.
             */
        }
    }

    et->et_flags |= ET_DOING_IAS;

    iowrite (ias->status, 0);
    iowrite (ias->command, CB_EL | CB_IAS);
    iowrite (ias->link, LANCE_NULL);
    copy_io_out ((caddr_t) et->et_addr, (caddr_t) & ias->address[0], 6);
    return (ias);
}

static struct obj_dia *make_dia (struct et_softc *et)
{
    register struct obj_dia *dia = et->dia;

    if (dia == NULL)
    {
        et->dia = dia = (struct obj_dia *) ARMaddress (et, alloc_struct (et, SZ_DIA));
    }
    else
    {
        while ((et->et_flags & ET_DOING_DIA) != 0)
        {
            /* Busy-wait until the previous configure command has been
             * processed.
             */
        }
    }

    et->et_flags |= ET_DOING_DIA;

    iowrite (dia->status, 0);
    iowrite (dia->command, CB_EL | CB_DIA);
    iowrite (dia->link, LANCE_NULL);
    return (dia);
}


#ifdef  ET_TDR
static struct obj_tdr *make_tdr (et_softc * et)
{
    register struct obj_tdr *tdr = et->tdr;

    if (tdr == NULL)
    {
        et->tdr = tdr = (struct obj_tdr *) ARMaddress (et, alloc_struct (et, SZ_TDR));
    }
    else
    {
        while ((et->et_flags & ET_DOING_TDR) != 0)
        {
            /* Busy-wait until the previous configure command has been
             * processed.
             */
        }
    }

    et->et_flags |= ET_DOING_TDR;

    iowrite (tdr->status, 0);
    iowrite (tdr->command, CB_EL | CB_TDR);
    iowrite (tdr->link, LANCE_NULL);
    return (tdr);
}
#endif /* ET_TDR */


static int tx_mbufs (struct et_softc *et, struct mbuf *m0, u_char *edst, u_int type)
{
    struct mbuf *m;
    struct obj_tcb *tcb;
    struct obj_tbd *tbd;
    struct obj_nop *nop;
    u_int datalen = 0;
    caddr_t buffer;
    int s, page;
    u_int temp;

    for (m = m0; m; m = m->m_next)
        datalen += m->m_len;
    dprintf (("", "et:tx_mbufs: datalen=%x\n", datalen));

    s = splet ();
    /* check there is a free tcb + nop and update free pointers */
    tcb = et->tcb_free;
    if (tcb == NULL)
    {
        splx (s);
        dprintf (("", "et:tx_mbufs returning ENOBUFS\n"));
        return ENOBUFS;
    }
    et->et_st_tx_bytes += (u_long) datalen + PACK_HDR_LEN;
    nop = et->nop_free;
    et->tcb_free = (struct obj_tcb *) ARMaddress (et, tcb->link);
    et->nop_free = (struct obj_nop *) ARMaddress (et, nop->link);
    splx (s);
    iowrite (tcb->status, 0);
    iowrite (tcb->command, CB_XMT);
    iowrite (tcb->link, LANCEaddress (et, (caddr_t) nop));
    iowrite (nop->status, 0);
    iowrite (nop->command, CB_EL | CB_NOP);
    iowrite (nop->link, LANCE_NULL);

    /* fill in destination address and packet type */
    copy_io_out ((caddr_t) edst, (caddr_t) tcb->destaddr, 6);

    temp = htons (type);
    iowrite (tcb->type, temp);
    tbd = (struct obj_tbd *) ARMaddress (et, tcb->tbd);

    /* set count of data bytes and EOF bit in TBD */
    temp = MAX (datalen, ETHERMIN) | TBD_EOF;
    iowrite (tbd->status, temp);

    buffer = (caddr_t) ARMaddress (et, tbd->buffer);
    page = pageno (tbd->buffer);
    while (m0)
    {
        s = splet ();
        selectpage (et, page);
        buffer = copy_io_out (mtod (m0, caddr_t), buffer, m0->m_len);
        selectpage (et, TOPPAGE);
        splx (s);
        m0 = m0->m_next;
    }
    /* put the tcb + nop on the end of the command list */
    issue_cmd (et, (struct obj_cb *) tcb);
    return (0);
}


static void etrecv (struct et_softc *et)
{
    register struct obj_rfd *rfd = et->rfd_head;
    register struct obj_rbd *rbd;
    register unsigned status = rfd->status;

    dprintf (("", "rc\n"));
    while (status & RFD_C)
    {
        et->et_watch.reset = 0;        /* Reset did something useful */
        et->et_backoff = 60;           /* Reset reset backoff to 1 minute */
        et->et_st_rx_frames++;
        if (status & RFD_OK)
        {
            etread (et, rfd);
        }
        else
        {
            et->et_st_rx_general_errors++;
        }
        /* free RBD */
        rbd = (struct obj_rbd *) ARMaddress (et, rfd->rbd);
        if (rbd)
        {
            do
            {
                status = rbd->status;
                /* Chain this rbd on to the tail of the list, and mark the old tail as not endlist */
                /* The order is vital, since the LANCE is active on this chain */
                iowrite (rbd->size, RBD_EL | RBUF_SIZE);
                iowrite (et->rbd_tail->size, RBUF_SIZE);
                et->rbd_tail = rbd;
                rbd = (struct obj_rbd *) ARMaddress (et, rbd->next);
            }
            while ((status & RBD_EOF) == 0);
        }
        /* free RFD */
        iowrite (rfd->status, 0);
        iowrite (rfd->command, RFD_EL);
        iowrite (rfd->rbd, LANCE_NULL);
        iowrite (et->rfd_tail->command, 0);
        et->rfd_tail = rfd;
        rfd = (struct obj_rfd *) ARMaddress (et, rfd->link);
        status = rfd->status;
    }
    et->rfd_head = rfd;
}

static void etread (struct et_softc *et, struct obj_rfd *rfd)
{
    struct mbuf *m, *m0;
    struct obj_rbd *rbd;
    struct obj_rbd *rbd_next;
    unsigned status, type;
    u_int unit = et->et_unit;
    RxHdr *hdr;
    FilterSingleRef fs = NULL;
    int i;
    struct hwaddr
    {
        u_char addr[HW_ADDR_LEN];
    } src, dst;

    dprintf (("", "rd\n"));

    type = ntohs (rfd->type & 0xffff);

    /*
     * 1st discrimination of frame type - is it
     * an IEEE 802.3 or an Ethernet 2.0 frame?
     */
    if (type <= ETHERMTU)
    {
        fs = ieeefilter[unit];
    }

    /*
     * it's an Ethernet 2.0 frame, do we have
     * specific or sink filters active?
     */
    else if (e2specific[unit] || e2sink[unit])
    {
        FilterChainRef fc;

        /*
         * start by trying to match specific frame types
         */
        for (fc = e2specific[unit]; fc; fc = fc->fc_next)
            if (fc->fc_type == type)
            {
                fs = &fc->fc_filter;
                break;
            }

        /*
         * default to sink filter if no specific matches
         */
        if (!fc)
        {
            fs = e2sink[unit];
        }
    }

    /*
     * all we have left is the Ethernet 2.0 monitor
     */
    else
    {
        fs = e2monitor[unit];
    }

    /*
     * pass the packet along if it is wanted
     */
    if (fs)
    {
        extern void read_six_from_card (u_char *, u_char *);

        /* First copy in header */
        read_six_from_card (src.addr, (u_char *) rfd->sourceaddr);
        read_six_from_card (dst.addr, (u_char *) rfd->destaddr);

        *(struct hwaddr *) (et->et_st_last_src_addr) = src;
        *(struct hwaddr *) (et->et_st_last_dest_addr) = dst;

        /* for (i=0; i < PACK_HDR_LEN/2; i++) ((u_short
         * *)pack_hdr)[i]=((u_short *)rfd->destaddr)[i*2+1]; */

#ifdef DEBUGLIB
        {
            char temp[32];

            strcpy (temp, ether_sprintf (src.addr));
            /*sprintf (et_lastlog, "%s -> %s (type %04x)", temp, ether_sprintf (dst.addr), type);*/
            dprintf (("", "%s -> %s (type %04x)\n", temp, ether_sprintf (dst.addr), type));
        }
#endif

        /*
         * use the filtering routine appropriate to
         * the current level of packet reception
         */
        if (address_filter[unit] (fs->fs_addrlevel, dst.addr, (u_char *) et->et_addr))
        {
            et->et_st_unwanted_frames++;
            return;
        }
    }
    else
    {
        /*
         * no protocols want this frame
         */
        et->et_st_unwanted_frames++;
        return;
    }

    rbd = (struct obj_rbd *) ARMaddress (et, rfd->rbd);

    m0 = m = ALLOC_S (MINCONTIG, NULL);
    if (m == 0)
    {
        return;
    }
    m->m_type = MT_HEADER;
    hdr = mtod (m0, RxHdr *);
    m0->m_len = sizeof (RxHdr);
    dprintf (("", "LANCE rfd address %x\n", (int) rfd));
    *(struct hwaddr *) (hdr->rx_src_addr) = src;
    *(struct hwaddr *) (hdr->rx_dst_addr) = dst;
    hdr->_spad[0] = hdr->_spad[1] = 0;
    hdr->_dpad[0] = hdr->_dpad[1] = 0;
    hdr->rx_tag = 0;
    hdr->rx_frame_type = type;
    hdr->rx_error_level = 0;
    do
    {
        int length;

        status = rbd->status;
        if ((status & RBD_F) == 0)
        {
            sprintf (et_lastlog, "Unit %d: etread: incomplete receive\n", et->et_unit);
            type = 0;
            et->et_st_runt_frames++;
            break;
        }
        length = status & RBD_ACTCOUNT;
        et->et_st_rx_bytes += length;
        m->m_next = if_rdbuf (rbd->buffer, length, et);
        if (m->m_next == 0)
        {
            type = 0;
            break;
        }
        m = m->m_next;
        rbd_next = (struct obj_rbd *) ARMaddress (et, rbd->next);
        rbd = rbd_next;
        i++;
    } while ((status & RBD_EOF) == 0);

    dprintf (("", "callproto: dib=%p, m0=%p, handler=%p, pw=%08x\n",
              dibs[unit], m0, fs->fs_handler, fs->fs_pwptr));

    callproto (dibs[unit], m0, fs->fs_handler, fs->fs_pwptr);
}


/* Rx buffer chains are MLEN bytes each, so one fits exactly in a mbuf */
static struct mbuf *if_rdbuf (lanceaddr rxbuf, int buflen, struct et_softc *et)
{
    register struct mbuf *m = ALLOC_S (MINCONTIG, NULL);

    if (m == 0)
        return (0);
    m->m_type = MT_DATA;
    selectpage (et, pageno (rxbuf));
    copy_io_in ((caddr_t) ARMaddress (et, rxbuf), mtod (m, caddr_t), buflen);
    m->m_len = buflen;
    selectpage (et, TOPPAGE);
    return (m);
}


void wait_scb (struct et_softc *et)
{
    register int i;

    for (i = 0; i <= 0xfffff; i++)
    {
        if ((et->scb->command & 0xffff) == 0)
        {
            return;
        }
    }
    sprintf (et_lastlog, "Unit %d: scb failed to clear status 0x%x command 0x%x\n",
             et->et_unit, et->scb->status & 0xffff, et->scb->command & 0xffff);
}


void issue_cmd (struct et_softc *et, struct obj_cb *cmd)
{
    register struct obj_scb *scb = et->scb;
    register struct obj_cb *tail = cmd;
    lanceaddr temp;
    int s = splet (), was_idle;

    wait_scb (et);
    while ((tail->link & 0xffff) != LANCE_NULL)
    {
        /* If there's a chain of commands, clear the End Of List bit
         * on all but the last command in the chain.
         */
        iowrite (tail->command, tail->command & ~CB_EL);
        tail = (struct obj_cb *) ARMaddress (et, tail->link);
    }

    /* Ensure last command (possibly in chain) has End Of List bit set */
    iowrite (tail->command, tail->command | CB_EL);
    et->et_watch.cmd = 3;              /* Set up watchdog in case command hangs */
    if (et->cmd_tail == NULL)
    {
        /* No commands currently in list.
         * Make new command(s) the list.
         */
        temp = LANCEaddress (et, (caddr_t) cmd);
        iowrite (scb->cbl, temp);
        was_idle = 1;
    }
    else
    {
        register struct obj_cb *cmd_tail = et->cmd_tail;

        /* Already commands in list.
         * Attach new command(s) to end of list.
         */
        temp = LANCEaddress (et, (caddr_t) cmd);
        iowrite (cmd_tail->link, temp);
        iowrite (cmd_tail->command, cmd_tail->command & ~CB_EL);
        was_idle = 0;
    }
    et->cmd_tail = tail;
    if (was_idle)
    {
        /* Activate the Command Unit */
        iowrite (scb->command, CU (START));
        attention (et, CA);
    }
    splx (s);
}



/* called every ET_WATCHTIME seconds to check that things have happened */

extern void etwatch (int unit)
{
    register struct et_softc *et = et_softc[unit];
    int s = splet ();

    if (et->et_watch.cmd && (--et->et_watch.cmd == 0))
    {
        sprintf (et_lastlog, "Unit %d: Hardware timed out during command, resetting\n", unit);
        goto hung;
    }
#ifdef  ET_TDR
    if (et->et_watch.tdr && (--et->et_watch.tdr == 0))
    {
        sprintf (et_lastlog, "Unit %d: TDR not available on this hardware\n", unit);
    }
#endif /* ET_TDR */
    if (et->et_watch.reset && (--et->et_watch.reset == 0))
    {
        sprintf (et_lastlog, "Unit %d: device hung and will not reset\n", unit);
        et->et_flags |= ET_FAULTY;
        iowrite (et->et_registers->control, RESET);     /* Leave the card reset
                                                         */
        et->et_watch.timer = 0;
    }
    splx (s);
    return;

  hung:
    splx (s);
    et->et_watch.reset = et->et_backoff / ET_WATCHTIME;
    et->et_backoff = (et->et_backoff * 3) / 2;
    etsetup (unit);
    (void) etbringup (unit);
}


static void etintr (int unit)
{
    register struct et_softc *et = et_softc[unit];
    register struct obj_scb *scb = et->scb;
    unsigned status, ack;
    lanceaddr temp;

    /* Determine type of interrupt and acknowledge before modifying
     * structures. Any interrupting event that occurs while we are
     * processing will then still generate an interrupt even though
     * we will have handled it already. This is OK, whereas missing
     * an interrupt would cause us to hang!
     */
    dprintf (("", "i\n"));
    wait_scb (et);
    status = scb->status;
    ack = status & (SCB_CX | SCB_CNA | SCB_FR | SCB_RNR);
    if (ack)
    {
        iowrite (scb->command, ack);
        attention (et, CA | ACK);
    }
    else
    {
        /* The Ethernet card can have a latched interrupt pending left over
         * from the previous INTEL chip interrupt. We must clear it just in
         * the PAL since the INTEL chip says there is no work to be done.
         * (Else it just comes back until the next Ethernet packet arrives
         * BUG 2127) */
        attention (et, ACK);
        return;
    }
    if (status & SCB_FR)
    {
        etrecv (et);
    }
    if (status & SCB_RNR)
    {
        wait_scb (et);
        iowrite (et->rfd_head->rbd, et->rbd_tail->next);
        temp = LANCEaddress (et, (caddr_t) et->rfd_head);
        iowrite (scb->rfa, temp);
        iowrite (scb->command, RU (START));
        attention (et, CA);
    }
    if (status & SCB_CX)
    {
        et_cmd_done (et);
    }
    if (status & SCB_CNA)
    {
        et_cmd_done (et);
        if ((scb->cbl & 0xffff) != LANCE_NULL)
        {
            iowrite (scb->command, CU (START));
            attention (et, CA);
        }
    }
}


void et_cmd_done (struct et_softc *etp)
{
    register struct et_softc *et = etp;
    register struct obj_scb *scb = et->scb;
    struct obj_cb *cb = (struct obj_cb *) ARMaddress (et, scb->cbl), *cbn;
    unsigned unit = et->et_unit;
    lanceaddr temp;

    while (cb != NULL)
    {
        cbn = (struct obj_cb *) ARMaddress (et, cb->link);
        if ((cb->status & CB_C) == 0)
        {
            return;
        }
        et->et_watch.reset = 0;        /* Reset did something useful */
        iowrite (scb->cbl, cb->link);
        if (cb == et->cmd_tail)
        {
            et->cmd_tail = NULL;
        }
        if (cbn == NULL)
        {
            et->et_watch.cmd = 0;      /* All commands have completed */
        }
        switch (cb->command & CB_CMD)
        {
            case CB_XMT:
            {
                register struct obj_tcb *tcb = (struct obj_tcb *) cb;
                register unsigned status = tcb->status;
                register int ncoll;

                et->et_st_tx_frames++;
                if ((status & CB_OK) == 0)
                {
                    et->et_st_tx_general_errors++;
                }
                if ((et->et_flags & ET_SQETEST) &&
                    ((status & (TCB_COLL | TCB_NCOLL)) == 0) &&
                    ((status & TCB_SQE) == 0))
                {
                    if ((et->et_flags & ET_SQEINFORMED) == 0)
                    {
                        sprintf (et_lasterr, "Unit %d: SQE (is the AUI cable connected?)\n", unit);
                        et->et_flags |= ET_SQEINFORMED;
                    }
                }
                ncoll = status & TCB_NCOLL;

                /* test for abort due to excessive collisions */
                if (status & TCB_COLL)
                {
                    if (ncoll == 0)
                    {
                        ncoll = 16;         /* Encoded in only 4 bits */
                    }
                    et->et_st_collisions += ncoll;
                    et->et_flags &= ~ET_SQETEST;    /* If aborted due to collisions, no SQE test next time */
                }
                else
                {
                    /* no. of collisions may still be non-zero:
                     * TCB_COLL is only set when *excessive*
                     * collisions have occured
                     */
                    if (ncoll)
                    {
                        et->et_st_collisions += ncoll;
                    }

                    et->et_flags |= ET_SQETEST;
                }
                /* free transmit buffer */
                temp = LANCEaddress (et, (caddr_t) et->tcb_free);
                iowrite (tcb->link, temp);
                et->tcb_free = tcb;
                break;
            }

            case CB_NOP:
                temp = LANCEaddress (et, (caddr_t) et->nop_free);
                iowrite (cb->link, temp);
                et->nop_free = (struct obj_nop *) cb;
            case CB_CFG:
            case CB_IAS:
            case CB_DIA:
                switch (cb->command & CB_CMD)
                {
                    case CB_CFG:
                        et->et_flags &= ~ET_DOING_CFG;
                        break;

                    case CB_IAS:
                        et->et_flags &= ~ET_DOING_IAS;
                        break;

                    case CB_DIA:
                        et->et_flags &= ~ET_DOING_DIA;
                        break;

                    default:
                        break;
                }
                dprintf (("", "c=%d, s=%x\n", cb->command & CB_CMD, cb->status & 0xffff));
                if ((cb->status & CB_OK) == 0)
                {
                    sprintf (et_lastlog, "Unit %d: hardware problem: cmd=%d, status=0x%x\n",
                             unit, cb->command & CB_CMD, cb->status & 0xffff);
                    dprintf (("", "Unit %d: hardware problem: cmd=%d, status=0x%x\n",
                             unit, cb->command & CB_CMD, cb->status & 0xffff));
                }
                break;

#ifdef  ET_TDR
            case CB_TDR:
                et->et_watch.tdr = 0;
                if ((cb->status & CB_OK) == 0)
                {
                    if (cb->status & CB_BUSY)
                    {
                        /* The SIA is not an INTEL part */
                        sprintf (et_lastlog, "Unit %d: SIA cannot perform TDR\n", unit);
                        break;
                    }
                    sprintf (et_lastlog, "Unit %d: hardware problem: cmd=%d, status=0x%x\n",
                             unit, cb->command & CB_CMD, cb->status & 0xffff);
                }
                else
                {
                    struct obj_tdr *tdr = (struct obj_tdr *) cb;
                    register unsigned result = tdr->result;

                    if ((result & TDR_LNKOK) == 0)
                    {
                        register unsigned time = result & TDR_TIME;
                        unsigned tu = time / 10, tf = time % 10;

                        if (result & TDR_XCVR)
                        {
                            sprintf (et_lastlog,
                                     "Unit %d: TDR implies transceiver problem\n", unit);
                        }
                        if (result & TDR_OPEN)
                        {
                            sprintf (et_lastlog,
                                     "Unit %d: TDR implies cable open-circuit at %d.%d uS\n",
                                     unit, tu, tf);
                        }
                        if (result & TDR_SHORT)
                        {
                            sprintf (et_lastlog,
                                     "Unit %d: TDR implies cable short-circuit at %d.%d uS\n",
                                     unit, tu, tf);
                        }
                    }
                    else
                    {
                        sprintf (et_lastlog, "Unit %d: TDR implies cable is OK\n", unit);
                    }
                }
                et->et_flags &= ~ET_DOING_TDR;
                break;
#endif /* ET_TDR */

            default:
                sprintf (et_lastlog, "Unit %d: unexpected command %d interrupt, status %x\n",
                         unit, cb->command & CB_CMD, cb->status);
                break;

        }
        cb = cbn;
    }
}


void selectpage (struct et_softc *et, int n)
{
    iowrite (et->et_registers->page, n);
}


static caddr_t ARMaddress (struct et_softc *et, lanceaddr lanceptr)     /* lanceptr must be even */
{
    caddr_t ioaddr;

    if (((unsigned) lanceptr & 0xffff) == LANCE_NULL)
    {
        return (NULL);
    }
    ioaddr = (caddr_t) ((((unsigned) lanceptr & PAGEMASK) << 1) + (unsigned) et->et_dpram);
    return (ioaddr);
}


/* LANCEaddress for top page addresses */
lanceaddr LANCEaddress (struct et_softc * et, caddr_t ioaddr)
{
    if (ioaddr != NULL)
    {
        register unsigned offset = ioaddr - et->et_dpram;

        return ((lanceaddr) ((offset >> 1) | (TOPPAGE << PAGESHIFT)));
    }
    else
    {
        return (LANCE_NULL);
    }
}


/* allocate size bytes in TOPPAGE */
lanceaddr alloc_struct (struct et_softc *et, int size)
{
    lanceaddr nextstruct = et->last_struct - size;

    et->last_struct = nextstruct;
    return (nextstruct);
}


/* allocate buffer of bufsize, make sure it doesn't cross page boundary */
lanceaddr alloc_buffer (struct et_softc * et, int bufsize)
{
    lanceaddr nextfree = et->next_buffer;

    if (pageno (nextfree + bufsize - 1) != pageno (nextfree))
    {
        nextfree = ((pageno (nextfree) + 1)) << PAGESHIFT;
    }
    et->next_buffer = nextfree + bufsize;
    return (nextfree);
}


/**********************************************************************/

int et_stats (_kernel_swi_regs * r)
{
    struct stats *sptr;

    switch (r->r[0])
    {
        case 0:
            sptr = &st;
            break;

        case 1:
            sptr = &(et_softc[r->r[1]]->et_stats);
            break;

        default:
            return (EINVAL);
    }

    (void) memcpy ((char *) (r->r[2]), (char *) sptr, sizeof (*sptr));
    return (0);
}

/**********************************************************************/

/*
 * stats_init - initialise stats structures
 */
void stats_init (struct et_softc *et)
{
    int i;

    /*
     * actual statistics structure is easy - only one field to set
     */
    et->et_st_interface_type = ST_TYPE_10BASE5N2;

    /*
     * now fill in struct st which describes
     * the stats. this interface supports.
     */
    st.st_interface_type = 0xff;
    st.st_link_status = 0xff;
    st.st_link_polarity = 0;
    st.st_blank1 = 0;
    st.st_link_failures = 0;
    st.st_network_collisions = 0;
    st.st_collisions = ~0;
    st.st_excess_collisions = 0;
    st.st_heartbeat_failures = 0;
    st.st_not_listening = 0;
#if 0
    st.st_net_error = 0;
#endif
    st.st_tx_frames = ~0;
    st.st_tx_bytes = ~0;
    st.st_tx_general_errors = ~0;
    st.st_crc_failures = 0;
    st.st_frame_alignment_errors = 0;
    st.st_dropped_frames = 0;
    st.st_runt_frames = ~0;
    st.st_overlong_frames = 0;
    st.st_jabbers = 0;
    st.st_late_events = 0;
    st.st_unwanted_frames = ~0;
    st.st_rx_frames = ~0;
    st.st_rx_bytes = ~0;
    st.st_rx_general_errors = ~0;

    for (i = 0; i < 6; ++i)
    {
        st.st_last_dest_addr[i] = 0xff;
        st.st_last_src_addr[i] = 0xff;
    }

    do
    {
        st.st_last_dest_addr[i] = 0;
        st.st_last_src_addr[i] = 0;
        ++i;
    }
    while (++i < sizeof (st.st_last_dest_addr));
}

/**********************************************************************/

extern void et_runtest (int unit)
{
    struct et_softc *et = et_softc[unit];

    /*
     * only bother if the card is not already diagnosed as faulty
     */
    if (!(et->et_flags & ET_FAULTY))
    {
        /*
         * pretend driver is disappearing while tests are performed
         */
        send_driverstatus (dibs[unit], 1);

        /*
         * driver will no longer be running after POST
         */
        et->et_flags &= ~ET_RUNNING;

        et_init_low (unit, 1);

        /*
         * XXX
         *
         * we're back!  the pretence that the driver has
         * disappeared while the tests were being run will
         * have confused the protocol modules which, when
         * they receive the `startup' service call will
         * try to reclaim the filters they already hold.
         */
        et->et_flags |= ET_DUPCLAIMEXPECTED;
        send_driverstatus (dibs[unit], 0);

        /*
         * if protocol modules have not reclaimed yet, then
         * they have lost the chance to do so
         */
        et->et_flags &= ~ET_DUPCLAIMEXPECTED;
    }

    /*
     * analyse and print results
     */
    printf ("Driver et%d is ", unit);
    if (et->et_flags & ET_FAULTY)
    {
        printf ("faulty: %s\n", et_lasterr);
    }
    else
    {
        printf ("OK\n");
    }
}

/**********************************************************************/

/*
 * set_receive_level - either turn the hardware for the unit off
 * (if addrlevel = -1), or enable appropriate levels of packet
 * reception
 */



void set_receive_level (int unit, int addrlevel)
{
    struct et_softc *et = et_softc[unit];

    et->et_st_link_status &= ~(ST_STATUS_RXMASK);

    if (addrlevel == -1)
    {
        /* take the hardware down */
        etioctl (unit, 1, 0);

        et->et_st_link_status &= ~ST_STATUS_ACTIVE;
    }
    else
    {
        u_char status = ST_STATUS_DIRECT;

        if (addrlevel >= ADDRLVL_NORMAL)
        {
            /* broadcasts are OK */
            status = ST_STATUS_BROADCAST;
        }

        if (addrlevel >= ADDRLVL_MULTICAST)
        {
            /* multicasts are OK */
            status = ST_STATUS_PROMISCUOUS;
        }

        dprintf (("", "set_receive_level: addrlevel=%x\n", addrlevel));

        et->et_st_link_status |= (status | ST_STATUS_ACTIVE);
        issue_cmd (et, (struct obj_cb *) make_cfg (et, 0, 0, status));
    }
}
@


1.1
log
@Initial revision
@
text
@d15 22
a37 9
#include "types.h"
#include "errno.h"
#include "sys/mbuf.h"
#include "int_hndlr.h"
#include "xcb.h"
#include "ioc.h"
#include "delay.h"
#include "sys/dcistructs.h"
#include "netinet/if_ether.h"
d40 2
a41 4

#include "kernel.h"
#include "swis.h"

a48 2
#define ET_WATCHTIME 5

d53 26
a78 26
//This one doesn't work yet, but should be used.
//#define iowrite(where, value) where = (((unsigned)(value) << 16)|value)

void etintr();
int etinit(), etioctl(), etreset();
static void et_shutdown(int);
static void etsetup(int);
static void setup_tx_bufs(struct et_softc *);
static void setup_rx_bufs(struct et_softc *);
void wait_scb(struct et_softc *);
void issue_cmd(struct et_softc *, struct obj_cb *);
void etwatch(int unit);
void et_cmd_done(struct et_softc *etp);
void selectpage(struct et_softc *et, int n);
void copy_io_in(caddr_t ioaddr, caddr_t buffer, int count);
void etread(struct et_softc *et, struct obj_rfd *rfd);
void stats_init(struct et_softc *et);
lanceaddr alloc_struct(struct et_softc *et, int size);
lanceaddr alloc_buffer(struct et_softc *et, int bufsize);
struct mbuf *if_rdbuf();
int timeout();
caddr_t copy_io_out(), ARMaddress();
lanceaddr LANCEaddress();
struct obj_cfg *make_cfg();
struct obj_ias *make_ias();
struct obj_dia *make_dia();
d80 3
a82 2
struct obj_tdr *make_tdr();
#endif  ET_TDR
a86 3
extern int acopy_io_out();
extern int acopy_io_in();
extern void *module_wsp;
a88 11
extern int et_irq_entry1();
extern void enable_podule_irqs();
extern void disable_podule_irqs();
extern void et_init_high();
extern void et_init_low();
extern DibRef dibs[];

extern FilterSingleRef ieeefilter[4];
extern FilterSingleRef e2monitor[4];
extern FilterSingleRef e2sink[4];
extern FilterChainRef e2specific[4];
d90 12
a101 1
extern int (*address_filter[4])(u_int level, u_char *pack_hdr, u_char *mac_addr);
d103 5
a107 2
char et_lastlog[64] = { 0 };
char et_lasterr[64] = { 0 };
d116 1
a116 1
void et_init(void)
d124 1
a124 1
    if (_swix(Podule_ReturnNumber, _OUT(0), &ncards))
d127 1
a127 1
    s = splet();
d130 1
a130 1
        if (_swix(Podule_ReadID, _IN(3)|_OUT(0), i, &d) == NULL && d==0)
d132 1
a132 1
            if (_swix(Podule_ReadHeader, _INR(2,3), buffer, i) == NULL)
d134 1
a134 1
                if (((buffer[3]) | (buffer[4]<<8)) == ET_TYPE)
d136 2
a137 2
                    _swix(Podule_HardwareAddress, _IN(3)|_OUT(3), i, &addr);
                    addr &= 0xFFEFFC00; /* Extract fast address */
d142 1
a142 1
                    et_init_high(etcnt++);
d147 3
a149 2
    if (etcnt == 0) {
        splx(s);
d152 14
a165 2
    for (i = 0; i < 4; i++) {
        if (xblock[i].address) et_init_low(i, 0);
a166 4
    splx(s);
    for (i = 0; i < 4; i++) {
        if (xblock[i].address) et_init_low(i, 1);
     }
d168 1
a168 1
    _swix(OS_SetVarVal, _INR(0,4), "Inet$EtCount", &etcnt, 4, 0, 1);
d170 1
a170 1
    _swix(OS_SetVarVal, _INR(0,4), "Inet$EtherType", "et0", 3, 0, 0);
d173 1
a173 1
int et_transmit(_kernel_swi_regs *r)
d180 2
a181 2
    char *edst = (char *)(r->r[4]);
    struct mbuf *m, *m0 = (struct mbuf *)(r->r[3]);
d183 2
a184 1
    //printf("et_transmit:unit %d flags %x type %x m0 %x\n",unit,flags,type,m0);
d186 4
a189 2
    if( flags >= TX_1STRESERVED )
	error = EINVAL;
d197 1
a197 1
    while( m0 )
d199 2
a200 2
	m = m0;
	m0 = m0->m_list;
d202 9
a210 7
	if( !error )
	    error = tx_mbufs(et, m, edst, type);
        //printf("error=%d\n", error);
	if( !(flags & TX_PROTOSDATA) )
	{
	    FREEM(m);
	}
d216 1
a216 1
void claim_device_interrupt(int unit)
d218 3
a220 3
    _swix(OS_ClaimDeviceVector, _INR(0,4), 13, et_irq_entry1, &xblock[unit],
                                           xblock[unit].address,
                                           1);
d223 1
a223 1
void release_device_interrupt(int unit)
d225 3
a227 3
    _swix(OS_ReleaseDeviceVector, _INR(0,4), 13, et_irq_entry1, &xblock[unit],
                                             xblock[unit].address,
                                             1);
d230 1
a230 1
void et_final(void)
d234 2
a235 1
    for (i = 0; i < 4; i++) {
d239 1
a239 1
            release_device_interrupt(i);
d245 1
a245 1
int et_irq_handler(_kernel_swi_regs *r, void *pw)
d247 1
a247 3
    set_irqsareoff();
    etintr(r->r[0]);
    clear_irqsareoff();
d249 5
a253 1
    return 1;
d256 1
a256 1
char *et_addresses(int unit)
d262 1
a262 1
int pretstats(int flag)
d269 1
a269 3
    for (unit = 0; unit < 4; unit++) if (xblock[unit].address) {
        et = et_softc[unit];
        filters_active = 0;
d271 6
a276 10
        /*printf("Address = %p, Slot = %d\n", xblock[unit].address, xblock[unit].slot);
        printf("Ram address = %p\n", et->et_dpram);*/
        if (et->et_flags & ET_FAULTY) {
            printf("Unit %d is FAULTY. Try machine reset to clear\n", unit);
            continue;
        }
        if (first)
            first = 0;
        else
            printf("\n");
d278 13
a290 14
        if (etcnt > 1)
            printf("%s %d\n\n", "Unit", unit);
        printf("%-18s", "Card Info");
        printf("Slot=%d, Ethernet address=%s\n\n", xblock[unit].slot, ether_sprintf(&et->et_addr[0]));
        printf("%-18s", "I/O Stats");
        printf("Rxframes=%d, Rxerrs=%d, Txframes=%d, Txerrs=%d\n",
                et->et_st_rx_frames,
                et->et_st_rx_general_errors,
                et->et_st_tx_frames,
                et->et_st_tx_general_errors);
        printf("%-18s", " ");
        printf("Collisions=%d, Unwanted frames=%d\n",
                et->et_st_collisions, et->et_st_unwanted_frames);
        printf("Active Filters:\n");
d292 24
a315 7
        if( ieeefilter[unit] )
        {
            ++filters_active;
            printf("%-18s: handler @@%x, r12 = %x\n", "IEEE",
        	   (ieeefilter[unit])->fs_handler,
        	   (ieeefilter[unit])->fs_pwptr);
        }
d317 7
a323 7
        if( e2monitor[unit] )
        {
            ++filters_active;
            printf("%-18s: handler @@%x, r12 = %x\n", "Ethernet2 Monitor",
        	   (e2monitor[unit])->fs_handler,
        	   (e2monitor[unit])->fs_pwptr);
        }
d325 7
a331 7
        if( e2sink[unit] )
        {
            ++filters_active;
            printf("%-18s: handler @@%x, r12 = %x\n", "Ethernet2 Sink",
        	   (e2sink[unit])->fs_handler,
        	   (e2sink[unit])->fs_pwptr);
        }
d333 4
a336 4
        if( e2specific[unit] )
        {
            FilterChainRef fc = e2specific[unit];
            char *firstline = "Specific Types";
d338 1
a338 1
            ++filters_active;
d340 4
a343 4
            while( fc )
            {
                printf("%-18s: type %x, handler @@%x, r12 = %x\n",
                    firstline, fc->fc_type, fc->fc_handler, fc->fc_pwptr);
d345 3
a347 2
                firstline = "";
                fc = fc->fc_next;
a348 1
        }
d350 4
a353 2
        if( !filters_active )
            printf("(no filters active)\n");
d355 10
a364 7
        if (et_lastlog[0]) {
            printf("\n%-18s%s\n", "Driver Info", et_lastlog);
            et_lastlog[0] = 0;
        }
        if (et_lasterr[0]) {
            printf("%-18s%s\n", "Driver Error", et_lasterr);
            et_lasterr[0] = 0;
a367 1

d371 1
a371 1
void etcard_reset(int unit)
d377 2
a378 1
    struct et_registers *regs = (struct et_registers *)xblock[unit].address;
d380 2
a381 2
    iowrite(regs->control, RESET);
    if ((((XCBIDRef)regs)->id0 & XCB_ID0_IRQ) != 0)
d383 2
a384 2
        sprintf(et_lasterr, "Ethernet card in slot %d: reset failed\n", xblock[unit].slot);
        iowrite(regs->control, 0);
d392 1
a392 1
void et_init_high(int unit)
d394 1
a394 1
    etcard_reset(unit);
d414 1
a414 1
void et_init_low(int unit, int irqs)
d418 1
d428 3
a430 2
        et = (struct et_softc *)malloc (sizeof (struct et_softc));
        memset ((char *) et , 0, sizeof (struct et_softc));
d433 1
a433 1
        regs = (struct et_registers *)xblock[unit].address;
d441 1
a441 1
        et->et_pcb_issue = ((XCBIDRef)regs)->data[0].d_uchar[0];
d450 1
a450 1
                    et->et_slot, et->et_pcb_issue);
d458 1
a458 1
            et->et_addr[i] = ((XCBIDRef)regs)->data[1+i].d_uchar[0];
d460 1
a460 1
        et->et_dpram = (caddr_t)((u_int)xblock[unit].address | (1 << 13));
d463 1
a463 1
        stats_init(et);
d467 1
a467 1
        claim_device_interrupt(unit);
d478 1
a478 1
            return;                             /* ignore faulty units */
d485 3
a487 2
            int s = splet();
            et->et_flags |= ET_FAULTY;          /* mark failure */
d510 1
a510 1
static void et_shutdown(int unit)
d512 1
a512 1
    etcard_reset(unit);
d516 1
a516 1
static void etsetup(int unit)
d518 67
a584 64
        register struct et_softc *et = et_softc[unit];
        register struct obj_scp *scp;
        register struct obj_iscp *iscp;
        register struct obj_scb *scb;
        register lanceaddr la;
        register int i;
        int s = splet();

        et->et_backoff = 60;            /* Start at 1 minute and increase */
        et->et_watch.cmd = 0;
        et->et_watch.tdr = 0;
        et->et_flags = 0;
        iowrite(et->et_registers->control, RESET);
        iowrite(et->et_registers->control, 0);
        et->next_buffer = (lanceaddr)0;
        et->cfg = (struct obj_cfg *)0;
        et->ias = (struct obj_ias *)0;
        et->dia = (struct obj_dia *)0;
        et->tdr = (struct obj_tdr *)0;
        /* set up SCP AND ISCP */
        selectpage(et, TOPPAGE);                        /* all control structures are in TOPPAGE, recv & xmt buffers elsewhere */
        scp = (struct obj_scp *)ARMaddress(et, 0xFFFFF6);/* SCP is at fixed address 0x0FFFFF6, the top byte gets ignored */
        et->last_struct = LANCEaddress(et, scp);
        iowrite(scp->sysbus, 0);                        /* 16 bit bus */
        la = alloc_struct(et, SZ_ISCP);
        iowrite(scp->iscpaddr, la);
        iowrite(scp->iscptopaddr, 0);
        iscp = (struct obj_iscp *)ARMaddress(et, la);
        iowrite(iscp->busy, 1);                         /* cleared by LANCE when it has completed initialisation */
        la = alloc_struct(et, SZ_SCB);
        iowrite(iscp->scb_offset, la);
        iowrite(iscp->scb_base[0], 0);
        iowrite(iscp->scb_base[1], 0);                  /* base address of 64K segment */
        /* set up SCB */
        scb = (struct obj_scb *)ARMaddress(et, la);
        iowrite(scb->status, 0);
        iowrite(scb->command, 0);
        iowrite(scb->cbl, LANCE_NULL);
        iowrite(scb->rfa, LANCE_NULL);
        iowrite(scb->crcerrs, 0);               /* clear error counts */
        iowrite(scb->alnerrs, 0);
        iowrite(scb->rscerrs, 0);
        iowrite(scb->ovrnerrs, 0);
        et->scb = scb;                          /* save scb pointer */
        et->cmd_tail = NULL;
        setup_tx_bufs(et);
        setup_rx_bufs(et);
        attention(et, CA);                      /* init LANCE: RESET,CA -> read SCP */
        for (i = 0; i < 3; i++) {
                MICRODELAY (1000);
                if ((scb->status & 0xffff) == (SCB_CX|SCB_CNA)) break;
        }
        if ((scb->status & 0xffff) != (SCB_CX|SCB_CNA)) {
                sprintf(et_lastlog, "Unit %d: can't initialise, status 0x%x\n",
                    unit, scb->status & 0xffff);
                et->et_flags |= ET_FAULTY;
                iowrite(et->et_registers->control, RESET); /* Leave board disabled */
                splx(s);
                return;
        }
        splx(s);
        issue_cmd(et, (struct obj_cb *) make_cfg(et, 0, 0, ST_STATUS_BROADCAST));
        issue_cmd(et, (struct obj_cb *) make_ias(et));
        issue_cmd(et, (struct obj_cb *) make_dia(et));
d590 1
a590 1
etmem_test(int unit)
d597 6
a602 3
    iowrite(et->et_registers->control, RESET);
    iowrite(et->et_registers->control, 0);
    for (i = 0; i < 16; i++) pattern[i] = O(i);
d604 5
a608 2
    for (i = 0; i < 16; i++) pattern[17+i] = Z(i);
    pattern[17+16] = 0xffff;
d615 2
a616 2
            selectpage(et, page);
            addr = (unsigned *)et->et_dpram;
d620 5
a624 2
                iowrite(*addr, pat);
                if (++offset == 34) offset = 0;
d630 2
a631 2
            selectpage(et, page);
            addr = (unsigned *)et->et_dpram;
d639 1
a639 1
                            unit, et->et_slot, page*PAGESIZE+j, pat, val);
d642 4
a645 1
                if (++offset == 34) offset = 0;
d653 4
a656 5
/*
 *      Use transmit buffers large enough to hold a whole ethernet package.
 *      We have enough memory to avoid the added complication of buffer chaining.
 *      Allocate an array of TCBs, each one pointing to one TBD in TOPPAGE, which in turn points to
 *      one data buffer in any page but TOPPAGE.
d658 1
a658 1
static void setup_tx_bufs(struct et_softc *et)
d660 5
a664 5
        register struct obj_tbd *tbd;
        register struct obj_tcb *tcb;
        register struct obj_nop *nop;
        register lanceaddr tcbla, la, nopla, temp;
        register int i;
d666 35
a700 46
        /*
        ** TransmitControlBlocks are always used with one NOP command following
        ** so that the EL bit can be left clear on a transmit command to allow
        ** chaining to work.
        **      +-----------+                   +-----------+
        **      |   T C B   +------------------>|   N O P   +--------->   etc
        **      +-----+-----+                   +-----------+
        **            |
        **            |         +-----------+
        **            +-------> |   T B D   |
        **                      +-----+-----+
        **                            |
        **                            |
        **                            |         +---------------+
        **                            +-------> |  B u f f e r  |
        **                                      |               |
        **                                      |               |
        **                                      |               |
        */
        tcbla = alloc_struct(et, SZ_TCB);
        et->tcb_free = (struct obj_tcb *)ARMaddress(et, tcbla);
        nopla = alloc_struct(et, SZ_NOP);
        et->nop_free = (struct obj_nop *)ARMaddress(et, nopla);
        for (i = 0; i <= NXMT - 1; i++) {
                tcb = (struct obj_tcb *)ARMaddress(et, tcbla);
                nop = (struct obj_nop *)ARMaddress(et, nopla);
                iowrite(tcb->status, 0);
                iowrite(nop->status, 0);
                iowrite(tcb->command, CB_XMT);
                iowrite(nop->command, CB_NOP);
                if (i == NXMT - 1) {
                        iowrite(tcb->link, LANCE_NULL);
                        iowrite(nop->link, LANCE_NULL);
                } else  {
                        tcbla=alloc_struct(et, SZ_TCB);
                        nopla=alloc_struct(et, SZ_NOP);
                        iowrite(tcb->link, tcbla);
                        iowrite(nop->link, nopla);
                }
                la = alloc_struct(et, SZ_TBD);
                iowrite(tcb->tbd, la);
                tbd = (struct obj_tbd *)ARMaddress(et, la);
                iowrite(tbd->next_tbd, LANCE_NULL);
                temp=alloc_buffer(et, TBUF_SIZE);
                iowrite(tbd->buffer, temp);
                iowrite(tbd->buffer_hi, 0);     /* buffer address is 24 bit */
d702 15
d719 5
a723 6
/*
 *      Allocate a circular linked list of RFDs and a circular linked list of
 *      RBDs in top page, each RBD pointing to one buffer elsewhere.  Each
 *      buffer is the size of a mbuf, since the LANCE does scatter/gather DMA
 *      and it makes better use of the buffer memory. The limiting factor is
 *      RBDs in the TOPPAGE not the actual buffer space.
d725 1
a725 1
static void setup_rx_bufs(struct et_softc *et)
d727 45
a771 20
        register struct obj_rfd *rfd;
        register struct obj_rbd *rbd;
        lanceaddr head, temp;
        register lanceaddr la;
        register int i;

        /* circular list of RFDs */
        head = la = alloc_struct(et, SZ_RFD);
        for (i = 0; i <= NRFD - 1; i++) {
                rfd = (struct obj_rfd *)ARMaddress(et, la);
                iowrite(rfd->status, 0);
                iowrite(rfd->rbd, LANCE_NULL);
                if (i != (NRFD - 1)) {
                        la = alloc_struct(et, SZ_RFD);
                        iowrite(rfd->command, 0);
                        iowrite(rfd->link, la);
                } else {
                        iowrite(rfd->command, RFD_EL);
                        iowrite(rfd->link, head);
                }
d773 4
a776 22
        et->rfd_head = (struct obj_rfd *)ARMaddress(et, head);
        et->rfd_tail = rfd;
        /* put pointer to rfa in scb */
        iowrite(et->scb->rfa, head);

        /* circular list of RBDs */
        head = la = alloc_struct(et, SZ_RBD);
        iowrite(et->rfd_head->rbd, head);
        for (i = 0; i <= NRBD - 1; i++) {
                rbd = (struct obj_rbd *)ARMaddress(et, la);
                iowrite(rbd->status, 0);
                temp=alloc_buffer(et, RBUF_SIZE);
                iowrite(rbd->buffer, temp);
                iowrite(rbd->buffer_hi, 0);
                if (i != NRBD - 1) {
                        la = alloc_struct(et, SZ_RBD);
                        iowrite(rbd->size, RBUF_SIZE);
                        iowrite(rbd->next, la);
                } else {
                        iowrite(rbd->size, RBD_EL | RBUF_SIZE);
                        iowrite(rbd->next, head);
                }
d778 2
a779 1
        et->rbd_tail = rbd;
d783 1
a783 1
int etbringup(int unit)
d785 2
a786 2
        register struct et_softc *et = et_softc[unit];
        int s;
d789 1
a789 18
        if (et->et_flags & ET_RUNNING)
                return (1);
        etsetup(unit);
        if (et->et_flags & ET_FAULTY)
                return (0);
        s = splet();
        et->et_flags |= ET_RUNNING;

        /* start receive unit */
        wait_scb(et);
        iowrite(et->scb->command, RU(START));
        if ((et->scb->cbl & 0xffff) != LANCE_NULL) {
                iowrite(et->scb->command, et->scb->command | CU(START));
                et->et_watch.cmd = 3;
        }
        attention(et, CA);
        et->et_watch.timer = ET_WATCHTIME * 100;
        splx(s);
d791 18
d812 1
a812 1
int etioctl(int unit, int cmd, int flag)
d814 2
a815 2
        register struct et_softc *et;
        register struct obj_scb *scb;
d817 1
a817 1
        //printf("etioctl(%d,%d,%d)\n", unit, cmd, flag);
d819 3
a821 3
        if (unit < 0 || unit > 4)
            return (1);
        et = et_softc[unit];
d823 2
a824 1
        switch (cmd) {
d827 3
a829 3
                if ((et->et_flags & ET_FAULTY) || !etbringup(unit))
                    return (1);
                break;
d832 19
a850 15
                scb = et->scb;
                et->et_flags &= ~ET_SQEINFORMED; /* Will print message on next SQE error */
                if (et->et_flags & ET_FAULTY) {
                    /* Reset the card to disable it - no rx */
                    iowrite(et->et_registers->control, RESET);
                    break;
                }
                if (flag == 0 && et->et_flags & ET_RUNNING) {
                    /* Reset the card to disable it - no rx */
                        iowrite(et->et_registers->control, RESET);
                        et->et_flags &= ~ET_RUNNING;
                } else if (flag && (et->et_flags & ET_RUNNING) == 0) {
                        if (!etbringup(unit))
                            return (1);
                }
d852 5
a856 5
                et->et_watch.tdr = 5;
                issue_cmd(et, make_tdr(et));
#endif  ET_TDR
            default:
                break;
d859 2
a860 2
        }
        return (0);
d883 2
a884 1
#define CFG_PRM(tf) (tf)
d899 56
a954 1
struct obj_cfg *make_cfg(struct et_softc *et, int int_loop, int ext_loop, int s)
d956 1
a956 1
        register struct obj_cfg *cfg = et->cfg;
d958 21
a978 21
        if (cfg == NULL)
                        et->cfg = cfg = (struct obj_cfg *)ARMaddress(et, alloc_struct(et, SZ_CFG));
        int_loop &= 1;
        ext_loop &= 1;
        iowrite(cfg->status, 0);
        iowrite(cfg->command, CB_EL | CB_CFG);
        iowrite(cfg->link, LANCE_NULL);
        iowrite(cfg->param[0], CFG_FIFO_LIM(8) | CFG_BYTE_CNT(10));  /* Change BYTE_CNT if altering more parameters */
        iowrite(cfg->param[1], CFG_SRDY(1) | CFG_SAV_BF(0) |
                CFG_ADDR_LEN(6) | CFG_AL_LOC(0) | CFG_PREAM_LEN(2) |
                CFG_INT_LPBCK(int_loop) | CFG_EXT_LPBCK(int_loop | ext_loop));
        iowrite(cfg->param[2], CFG_LIN_PRIO(0) | CFG_ACR(0) | CFG_BOF_MET(0) |
                               CFG_IFRM_SPACE(96));
        iowrite(cfg->param[3], CFG_SLOT_TIME(512) | CFG_RETRY_NUM(15));
        iowrite(cfg->param[4], CFG_PRM(s == ST_STATUS_PROMISCUOUS) |
                               CFG_BC_DIS(s == ST_STATUS_DIRECT) |
                               CFG_MANCH(0) | CFG_TONO_CRS(0) | CFG_NCRC_INS(0) |
                               CFG_CRC_16(0) | CFG_BT_STF(0) | CFG_PAD(0) |
                               CFG_CRSF(0) | CFG_CRS_SRC(0) | CFG_CDTF(0) |
                               CFG_CDT_SRC(0));
        return (cfg);
d981 19
d1001 4
a1004 23
struct obj_ias *make_ias(struct et_softc *et)
{
        register struct obj_ias *ias = et->ias;

        if (ias == NULL)
                et->ias = ias = (struct obj_ias *)ARMaddress(et, alloc_struct(et, SZ_IAS));
        iowrite(ias->status, 0);
        iowrite(ias->command, CB_EL | CB_IAS);
        iowrite(ias->link, LANCE_NULL);
        copy_io_out((caddr_t)et->et_addr, (caddr_t)&ias->address[0], 6);
        return (ias);
}

struct obj_dia *make_dia(struct et_softc *et)
{
        register struct obj_dia *dia = et->dia;

        if (dia == NULL)
                et->dia = dia = (struct obj_dia *)ARMaddress(et, alloc_struct(et, SZ_DIA));
        iowrite(dia->status, 0);
        iowrite(dia->command, CB_EL | CB_DIA);
        iowrite(dia->link, LANCE_NULL);
        return (dia);
d1009 1
a1009 1
struct obj_tdr *make_tdr(et_softc *et)
d1011 1
a1011 1
        register struct obj_tdr *tdr = et->tdr;
d1013 11
a1023 65
        if (tdr == NULL)
                et->tdr = tdr = (struct obj_tdr *)ARMaddress(et, alloc_struct(et, SZ_TDR));
        iowrite(tdr->status, 0);
        iowrite(tdr->command, CB_EL | CB_TDR);
        iowrite(tdr->link, LANCE_NULL);
        return (tdr);
}
#endif  ET_TDR


int tx_mbufs(struct et_softc *et, struct mbuf *m0, u_char edst[6], int type)
{
        struct mbuf *m;
        struct obj_tcb *tcb;
        struct obj_tbd *tbd;
        struct obj_nop *nop;
        int datalen = 0;
        caddr_t buffer;
        int s, page;
        u_int temp;

        for (m = m0; m; m = m->m_next)
                datalen += m->m_len;
//printf("et:tx_mbufs: datalen=%x\n",datalen);

        s = splet();
        /* check there is a free tcb + nop and update free pointers */
        tcb = et->tcb_free;
        if (tcb == NULL) {
                splx(s);
                //printf("et:tx_mbufs returning ENOBUFS");
                return ENOBUFS;
        }
        et->et_st_tx_bytes+=datalen+PACK_HDR_LEN;
        nop = et->nop_free;
        et->tcb_free = (struct obj_tcb *)ARMaddress(et, tcb->link);
        et->nop_free = (struct obj_nop *)ARMaddress(et, nop->link);
        splx(s);
        iowrite(tcb->status, 0);
        iowrite(tcb->command, CB_XMT);
        iowrite(tcb->link, LANCEaddress(et, nop));
        iowrite(nop->status, 0);
        iowrite(nop->command, CB_EL | CB_NOP);
        iowrite(nop->link, LANCE_NULL);

        /* fill in destination address and packet type */
        copy_io_out((caddr_t)edst, (caddr_t)tcb->destaddr, 6);

        temp=htons(type);
        iowrite(tcb->type, temp);
        tbd = (struct obj_tbd *)ARMaddress(et, tcb->tbd);

        /* set count of data bytes and EOF bit in TBD */
        temp=MAX(datalen, ETHERMIN) | TBD_EOF;
        iowrite(tbd->status, temp);

        buffer = (caddr_t)ARMaddress(et, tbd->buffer);
        page = pageno(tbd->buffer);
        while (m0) {
                s = splet();
                selectpage(et, page);
                buffer = copy_io_out(mtod(m0, caddr_t), buffer, m0->m_len);
                selectpage(et, TOPPAGE);
                splx(s);
                m0 = m0->m_next;
d1025 73
a1097 3
        /* put the tcb + nop on the end of the command list */
        issue_cmd(et, (struct obj_cb *) tcb);
        return (0);
d1101 1
a1101 1
void etrecv(struct et_softc *et)
d1103 21
a1123 49
        register struct obj_rfd *rfd = et->rfd_head;
        register struct obj_rbd *rbd;
        register unsigned status = rfd->status;

        //printf("rc");
        while (status & RFD_C) {
                et->et_watch.reset = 0;                         /* Reset did something useful */
                et->et_backoff = 60;                            /* Reset reset backoff to 1 minute */
                et->et_st_rx_frames++;
                if (status & RFD_OK) {
                        etread(et, rfd);
                }
                else {
                        et->et_st_rx_general_errors++;
                }
                /* free RBD */
                rbd = (struct obj_rbd *)ARMaddress(et, rfd->rbd);
                do {
                        status = rbd->status;
                        /* Chain this rbd on to the tail of the list, and mark the old tail as not endlist */
                        /* The order is vital, since the LANCE is active on this chain */
                        iowrite(rbd->size, RBD_EL | RBUF_SIZE);
                        iowrite(et->rbd_tail->size, RBUF_SIZE);
                        et->rbd_tail = rbd;
                        rbd = (struct obj_rbd *)ARMaddress(et, rbd->next);
                } while ((status & RBD_EOF) == 0);
                /* free RFD */
                iowrite(rfd->status, 0);
                iowrite(rfd->command, RFD_EL);
                iowrite(rfd->rbd, LANCE_NULL);
                iowrite(et->rfd_tail->command, 0);
                et->rfd_tail = rfd;
                rfd = (struct obj_rfd *)ARMaddress(et, rfd->link);
                status = rfd->status;
        }
        et->rfd_head = rfd;
}

void etread(struct et_softc *et, struct obj_rfd *rfd)
{
        struct mbuf *m, *m0;
        struct obj_rbd *rbd;
        struct obj_rbd *rbd_next;
        unsigned status, type;
        u_int unit=et->et_unit;
        RxHdr *hdr;
        FilterSingleRef fs = NULL;
        int i;
        struct hwaddr
d1125 23
a1147 2
            u_char addr[HW_ADDR_LEN];
        } src, dst;
d1149 14
a1162 1
        //printf("rd");
d1164 3
a1166 2
        type = ntohs(rfd->type & 0xffff);
        //sprintf(et_lastlog, "rfd=%p, type=%x", rfd, type);
d1172 1
a1172 1
    if( type <= ETHERMTU )
d1174 1
a1174 2
	fs = ieeefilter[unit];
	SET_FRAMELEVEL(type, FRMLVL_IEEE);
d1181 1
a1181 1
    else if( e2specific[unit] || e2sink[unit] )
d1183 1
a1183 1
	FilterChainRef fc;
d1185 17
a1201 19
	/*
	 * start by trying to match specific frame types
	 */
	for( fc = e2specific[unit]; fc; fc = fc->fc_next )
	    if( fc->fc_type == type )
	    {
		fs = &fc->fc_filter;
		SET_FRAMELEVEL(type, FRMLVL_E2SPECIFIC);
		break;
	    }

	/*
	 * default to sink filter if no specific matches
	 */
	if( !fc )
	{
	    fs = e2sink[unit];
	    SET_FRAMELEVEL(type, FRMLVL_E2SINK);
	}
d1209 1
a1209 2
	fs = e2monitor[unit];
	SET_FRAMELEVEL(type, FRMLVL_E2MONITOR);
d1215 1
a1215 1
    if( fs )
d1217 1
a1217 1
        extern void read_six_from_card(u_char *, u_char *);
d1220 2
a1221 2
        read_six_from_card(src.addr, (u_char *)rfd->sourceaddr);
        read_six_from_card(dst.addr, (u_char *)rfd->destaddr);
d1223 2
a1224 2
        *(struct hwaddr *)(et->et_st_last_src_addr) = src;
        *(struct hwaddr *)(et->et_st_last_dest_addr) = dst;
d1226 12
a1237 2
        /*for (i=0; i < PACK_HDR_LEN/2; i++)
            ((u_short *)pack_hdr)[i]=((u_short *)rfd->destaddr)[i*2+1];*/
d1239 9
a1247 16
#       if 0
        { char temp[32];
        strcpy(temp, ether_sprintf(src.addr));
        sprintf(et_lastlog, "%s -> %s (type %04x)", temp, ether_sprintf(dst.addr), type);
        }
#       endif

	/*
	 * use the filtering routine appropriate to
	 * the current level of packet reception
	 */
	if(address_filter[unit](fs->fs_addrlevel, dst.addr, (u_char *)et->et_addr) )
	{
	    et->et_st_unwanted_frames++;
	    return;
	}
d1251 50
a1300 43
	/*
	 * no protocols want this frame
	 */
	et->et_st_unwanted_frames++;
	return;
    }

        rbd = (struct obj_rbd *)ARMaddress(et, rfd->rbd);

        m0 = m = ALLOC_S(MINCONTIG, NULL);
        if (m == 0) {
                return;
        }
        m->m_type=MT_DATA;
        hdr=mtod(m0, RxHdr *);
        m0->m_len=sizeof(RxHdr);
/*Printf("LANCE rfd address %x\n",(int)rfd);*/
        *(struct hwaddr *)(hdr->rx_src_addr) = src;
        *(struct hwaddr *)(hdr->rx_dst_addr) = dst;
        hdr->rx_tag=0;
        hdr->rx_frame_type=type;
        hdr->rx_error_level=0;
        do {
                int length;
                status = rbd->status;
                if ((status & RBD_F) == 0) {
                        sprintf(et_lastlog, "Unit %d: etread: incomplete receive\n", et->et_unit);
                        type = 0;
                        et->et_st_runt_frames++;
                        break;
                }
                length = status & RBD_ACTCOUNT;
                et->et_st_rx_bytes+=length;
                m->m_next = if_rdbuf(rbd->buffer, length, et);
                if (m->m_next == 0) {
                        type = 0;
                        break;
                }
                m = m->m_next;
                rbd_next = (struct obj_rbd *)ARMaddress(et, rbd->next);
                rbd = rbd_next;
                i++;
        } while ((status & RBD_EOF) == 0);
d1302 2
a1303 2
/*        Printf("\ncallproto: d = %x m0 = %x handler addr = %x r12 = %x\n\n",
               d, m0, p->pi_handler, p->pi_handle);*/
d1305 1
a1305 1
        callproto(dibs[unit], m0, fs->fs_handler, fs->fs_pwptr);
d1310 1
a1310 1
struct mbuf *if_rdbuf(lanceaddr rxbuf, int buflen, struct et_softc *et)
d1312 1
a1312 1
        register struct mbuf *m = ALLOC_S(MINCONTIG, NULL);
d1314 8
a1321 8
        if (m == 0)
                return (0);
        m->m_type=MT_DATA;
        selectpage(et, pageno(rxbuf));
        copy_io_in((caddr_t)ARMaddress(et, rxbuf), mtod(m, caddr_t), buflen);
        m->m_len = buflen;
        selectpage(et, TOPPAGE);
        return (m);
d1325 1
a1325 1
void wait_scb(struct et_softc *et)
d1327 7
a1333 5
        register int i;
        for (i = 0; i <= 0xfffff; i++) {
                if ((et->scb->command & 0xffff) == 0) {
                        return;
                }
d1335 3
a1337 2
        sprintf(et_lastlog, "Unit %d: scb failed to clear status 0x%x command 0x%x\n",
            et->et_unit, et->scb->status&0xffff, et->scb->command&0xffff);
d1341 1
a1341 1
void issue_cmd(struct et_softc *et, struct obj_cb *cmd)
d1343 47
a1389 30
        register struct obj_scb *scb = et->scb;
        register struct obj_cb  *tail = cmd;
        lanceaddr temp;
        int s = splet(), was_idle;

        wait_scb(et);
        while ((tail->link & 0xffff) != LANCE_NULL) {
                iowrite(tail->command, tail->command & ~CB_EL);
                tail = (struct obj_cb *)ARMaddress(et, tail->link);
        }
        iowrite(tail->command, tail->command | CB_EL);
        et->et_watch.cmd = 3;           /* Set up watchdog in case command hangs */
        if (et->cmd_tail == NULL) {
                temp=LANCEaddress(et, cmd);
                iowrite(scb->cbl, temp);
                was_idle = 1;
        } else {
                register struct obj_cb *cmd_tail = et->cmd_tail;

                temp=LANCEaddress(et, cmd);
                iowrite(cmd_tail->link, temp);
                iowrite(cmd_tail->command, cmd_tail->command & ~CB_EL);
                was_idle = 0;
        }
        et->cmd_tail = tail;
        if (was_idle) {
                iowrite(scb->command, CU(START));
                attention(et, CA);
        }
        splx(s);
d1396 1
a1396 1
void etwatch(int unit)
d1398 2
a1399 2
        register struct et_softc *et = et_softc[unit];
        int s = splet();
d1401 5
a1405 4
        if (et->et_watch.cmd && (--et->et_watch.cmd == 0)) {
                sprintf(et_lastlog, "Unit %d: Hardware timed out during command, resetting\n", unit);
                goto hung;
        }
d1407 15
a1421 12
        if (et->et_watch.tdr && (--et->et_watch.tdr == 0)) {
                sprintf(et_lastlog, "Unit %d: TDR not available on this hardware\n", unit);
        }
#endif  ET_TDR
        if (et->et_watch.reset && (--et->et_watch.reset == 0)) {
                sprintf(et_lastlog, "Unit %d: device hung and will not reset\n", unit);
                et->et_flags |= ET_FAULTY;
                iowrite(et->et_registers->control, RESET); /* Leave the card reset */
                et->et_watch.timer = 0;
        }
        splx(s);
        return;
d1423 6
a1428 6
hung:
        splx(s);
        et->et_watch.reset = et->et_backoff / ET_WATCHTIME;
        et->et_backoff = (et->et_backoff * 3) / 2;
        etsetup(unit);
        (void) etbringup(unit);
d1432 56
a1487 49
void etintr(int unit)
{
        register struct et_softc *et = et_softc[unit];
        register struct obj_scb *scb = et->scb;
        unsigned status, ack;
        lanceaddr temp;
        /*
         * Determine type of interrupt and acknowledge before modifying
         * structures. Any interrupting event that occurs while we are
         * processing will then still generate an interrupt even though
         * we will have handled it already. This is OK, whereas missing
         * an interrupt would cause us to hang!
         */
#ifdef DEBUG
Printf("i");
#endif
        wait_scb(et);
        status = scb->status;
        ack = status & (SCB_CX | SCB_CNA | SCB_FR | SCB_RNR);
        if (ack) {
                iowrite(scb->command, ack);
                attention(et, CA|ACK);
        } else {
             /* The Ethernet card can have a latched interrupt pending left over from the
              * previous INTEL chip interrupt. We must clear it just in the PAL since the
              * INTEL chip says there is no work to be done. (Else it just comes back until the
              * next Ethernet packet arrives BUG 2127)
              */
                attention(et,    ACK);
                return;
        }
        if (status & SCB_FR)
                etrecv(et);
        if (status & SCB_RNR) {
                wait_scb(et);
                iowrite(et->rfd_head->rbd, et->rbd_tail->next);
                temp=LANCEaddress(et, et->rfd_head);
                iowrite(scb->rfa, temp);
                iowrite(scb->command, RU(START));
                attention(et, CA);
        }
        if (status & SCB_CX)
                et_cmd_done(et);
        if (status & SCB_CNA) {
                et_cmd_done(et);
                if ((scb->cbl & 0xffff) != LANCE_NULL) {
                        iowrite(scb->command, CU(START));
                        attention(et, CA);
                }
d1489 1
d1493 1
a1493 1
void et_cmd_done(struct et_softc *etp)
d1495 57
a1551 10
        register struct et_softc *et = etp;
        register struct obj_scb *scb = et->scb;
        struct obj_cb *cb = (struct obj_cb *)ARMaddress(et, scb->cbl), *cbn;
        unsigned unit = et->et_unit;
        lanceaddr temp;

        while (cb != NULL) {
                cbn = (struct obj_cb *)ARMaddress(et, cb->link);
                if ((cb->status & CB_C) == 0) {
                        return;
d1553 12
a1564 4
                et->et_watch.reset = 0;                 /* Reset did something useful */
                iowrite(scb->cbl, cb->link);
                if (cb == et->cmd_tail) {
                        et->cmd_tail = NULL;
d1566 15
a1580 4
                if (cbn == NULL)
                        et->et_watch.cmd = 0;           /* All commands have completed */
                switch (cb->command & CB_CMD) {
                case CB_XMT:
d1582 11
a1592 15
                        register struct obj_tcb *tcb = (struct obj_tcb *)cb;
                        register unsigned status = tcb->status;
                        register int ncoll;
                        et->et_st_tx_frames++;
                        if ((status & CB_OK) == 0)
                                et->et_st_tx_general_errors++;
                        if ((et->et_flags & ET_SQETEST) &&
                            ((status & (TCB_COLL|TCB_NCOLL)) == 0) &&
                            ((status & TCB_SQE) == 0)) {
                                if ((et->et_flags & ET_SQEINFORMED) == 0) {
                                        sprintf(et_lasterr, "Unit %d: SQE (is the AUI cable connected?)\n", unit);
                                        et->et_flags |= ET_SQEINFORMED;
                                }
                        }
                        ncoll = status & TCB_NCOLL;
d1594 12
a1605 18
                        /*
                         * test for abort due to excessive collisions
                         */
                        if (status & TCB_COLL) {
                            if (ncoll == 0) ncoll = 16; /* Encoded in only 4 bits */
                            et->et_st_collisions += ncoll;
                            et->et_flags &= ~ET_SQETEST; /* If aborted due to collisions, no SQE test next time */
                        } else
                        {
                            /*
                             * no. of collisions may still be non-zero:
                             * TCB_COLL is only set when *excessive*
                             * collisions have occured
                             */
                            if( ncoll )
                            {
                                et->et_st_collisions += ncoll;
                            }
d1607 9
a1615 6
                            et->et_flags |= ET_SQETEST;
                        }
                        /* free transmit buffer */
                        temp=LANCEaddress(et, et->tcb_free);
                        iowrite(tcb->link, temp);
                        et->tcb_free = tcb;
d1617 3
d1621 4
d1626 9
a1634 10
                case CB_NOP:
                        temp=LANCEaddress(et, et->nop_free);
                        iowrite(cb->link, temp);
                        et->nop_free = (struct obj_nop *)cb;
                case CB_CFG:
                case CB_IAS:
                case CB_DIA:
                        if ((cb->status & CB_OK) == 0) {
                                sprintf(et_lastlog, "Unit %d: hardware problem: cmd=%d, status=0x%x\n",
                                       unit, cb->command & CB_CMD, cb->status & 0xffff);
d1636 5
a1640 12
                        break;
#ifdef  ET_TDR
                case CB_TDR:
                        et->et_watch.tdr = 0;
                        if ((cb->status & CB_OK) == 0) {
                                if (cb->status & CB_BUSY) {
                                        /* The SIA is not an INTEL part */
                                        sprintf(et_lastlog, "Unit %d: SIA cannot perform TDR\n", unit);
                                        break;
                                }
                                sprintf(et_lastlog, "Unit %d: hardware problem: cmd=%d, status=0x%x\n",
                                    unit, cb->command & CB_CMD, cb->status & 0xffff);
d1642 1
a1642 1
                        else
d1644 3
a1646 20
                            struct obj_tdr *tdr = (struct obj_tdr *)cb;
                            register unsigned result = tdr->result;
                            if ((result & TDR_LNKOK) == 0)
                            {
                                register unsigned time = result & TDR_TIME;
                                unsigned tu = time/10, tf = time%10;
                                if (result & TDR_XCVR)
                                    sprintf (et_lastlog,
                                         "Unit %d: TDR implies transceiver problem\n", unit);
                                if (result & TDR_OPEN)
                                    sprintf (et_lastlog,
                                         "Unit %d: TDR implies cable open-circuit at %d.%d uS\n",
                                         unit, tu, tf);
                                if (result & TDR_SHORT)
                                    sprintf (et_lastlog,
                                         "Unit %d: TDR implies cable short-circuit at %d.%d uS\n",
                                         unit, tu, tf);
                            }
                            else
                                sprintf (et_lastlog, "Unit %d: TDR implies cable is OK\n", unit);
d1648 9
d1658 4
a1661 6
                        break;
#endif  ET_TDR

                default:
                        sprintf (et_lastlog, "Unit %d: unexpected command %d interrupt, status %x\n",
                             unit, cb->command & CB_CMD, cb->status);
a1662 2
                }
                cb = cbn;
d1664 2
d1669 1
a1669 1
void selectpage(struct et_softc *et, int n)
d1671 1
a1671 1
    iowrite(et->et_registers->page, n);
d1675 1
a1675 1
caddr_t ARMaddress(struct et_softc *et, lanceaddr lanceptr)   /* lanceptr must be even */
d1677 8
a1684 5
        caddr_t ioaddr;
        if (((unsigned)lanceptr & 0xffff) == LANCE_NULL)
                return (NULL);
        ioaddr = (caddr_t)((((unsigned)lanceptr & PAGEMASK) << 1) + (unsigned)et->et_dpram);
        return (ioaddr);
d1689 1
a1689 1
lanceaddr LANCEaddress(struct et_softc *et, caddr_t ioaddr)
d1691 10
a1700 5
        if (ioaddr != NULL) {
                register unsigned offset = ioaddr - et->et_dpram;
                return ((lanceaddr)((offset >> 1 ) | (TOPPAGE << PAGESHIFT)));
        } else
                return (LANCE_NULL);
d1704 2
a1705 2
/* copy count bytes from half populated iobus */
void copy_io_in(caddr_t ioaddr, caddr_t buffer, int count)
d1707 1
a1707 2
    acopy_io_in ((int)ioaddr, (int)buffer, count);
}
d1709 2
a1710 4
/* copy count bytes to top half of iobus */
caddr_t copy_io_out(caddr_t buffer, caddr_t ioaddr, int count)
{
    return((caddr_t) acopy_io_out ((int)buffer, (int)(ioaddr), count));
d1714 4
d1719 6
a1724 17
lanceaddr alloc_struct(struct et_softc *et, int size)
{       /* allocate size bytes in TOPPAGE */
        lanceaddr nextstruct = et->last_struct - size;

        et->last_struct = nextstruct;
        return (nextstruct);
}


lanceaddr alloc_buffer(struct et_softc *et, int bufsize)
{       /* allocate buffer of bufsize, make sure it doesn't cross page boundary */
        lanceaddr nextfree = et->next_buffer;

        if (pageno(nextfree + bufsize - 1) != pageno(nextfree))
                nextfree = ((pageno(nextfree) + 1)) << PAGESHIFT;
        et->next_buffer = nextfree + bufsize;
        return (nextfree);
d1730 1
a1730 1
int et_stats(_kernel_swi_regs *r)
d1734 1
a1734 1
    switch( r->r[0] )
d1736 3
a1738 3
      case 0:
	sptr = &st;
	break;
d1740 3
a1742 3
      case 1:
	sptr = &(et_softc[r->r[1]]->et_stats);
	break;
d1744 2
a1745 2
      default:
	return(EINVAL);
d1748 2
a1749 2
    (void)memcpy((char *)(r->r[2]), (char *)sptr, sizeof(*sptr));
    return(0);
d1757 1
a1757 1
void stats_init(struct et_softc *et)
d1770 2
a1771 2
    st.st_interface_type = ~0;
    st.st_link_status = ~0;
d1798 1
a1798 1
    for( i = 0; i < 6; ++i )
d1800 2
a1801 2
	st.st_last_dest_addr[i] = 0xff;
	st.st_last_src_addr[i] = 0xff;
d1806 5
a1810 4
	st.st_last_dest_addr[i] = 0;
	st.st_last_src_addr[i] = 0;
	++i;
    } while( ++i < sizeof(st.st_last_dest_addr) );
a1812 1
#if 0
d1815 1
a1815 1
void et_runtest(int unit)
d1822 1
a1822 1
    if( !(et->et_flags & ET_FAULTY) )
d1824 29
a1852 29
	/*
	 * pretend driver is disappearing while tests are performed
	 */
	send_driverstatus(dibs[unit], 1);

	/*
	 * driver will no longer be running after POST
	 */
	et->et_flags &= ~ET_RUNNING;

        et_init_low(unit, 1);

	/*
	 * XXX
	 *
	 * we're back!  the pretence that the driver has
	 * disappeared while the tests were being run will
	 * have confused the protocol modules which, when
	 * they receive the `startup' service call will
	 * try to reclaim the filters they already hold.
	 */
	et->et_flags |= ET_DUPCLAIMEXPECTED;
	send_driverstatus(dibs[unit], 0);

	/*
	 * if protocol modules have not reclaimed yet, then
	 * they have lost the chance to do so
	 */
	et->et_flags &= ~ET_DUPCLAIMEXPECTED;
d1858 1
a1858 1
    printf("Driver et%d is ", unit);
d1860 3
a1862 1
	printf("faulty: %s\n", et_lasterr);
d1864 3
a1866 1
	printf("OK\n");
d1868 1
a1868 1
#endif
d1876 4
a1879 1
void set_receive_level(int unit, int addrlevel)
d1885 1
a1885 1
    if( addrlevel == -1 )
d1887 2
a1888 4
	/*
	 * take the hardware down
	 */
	etioctl(unit, 1, 0);
d1890 1
a1890 1
	et->et_st_link_status &= ~ST_STATUS_ACTIVE;
d1894 1
a1894 1
	u_char status = ST_STATUS_DIRECT;
d1896 5
a1900 3
	if( addrlevel >= ADDRLVL_NORMAL )
	{
	    /* broadcasts are OK */
d1902 5
a1906 6
	    status = ST_STATUS_BROADCAST;
	}

	if( addrlevel >= ADDRLVL_MULTICAST )
	{
	    /* multicasts are OK */
d1908 1
a1908 8
	    status = ST_STATUS_PROMISCUOUS;
	}


#ifdef DEBUG
	Printf("\021\06set_receive_level: rcr = %x (addrlevel = %x)\021\07\n",
	       rcrbits, addrlevel);
#endif
d1910 2
a1911 2
	et->et_st_link_status |= (status | ST_STATUS_ACTIVE);
	issue_cmd(et, (struct obj_cb *) make_cfg(et, 0, 0, status));
@


1.1.1.1
log
@Initial import of Ether1 into CVS.  These sources will not even compile with
current libraries, and are just here to act as a reference point for imminent
changes.
@
text
@@

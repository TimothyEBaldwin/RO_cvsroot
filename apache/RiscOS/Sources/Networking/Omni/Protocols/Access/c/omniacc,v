head	1.3;
access;
symbols
	Access-0_17:1.3
	Access-0_16:1.2
	Access-0_15:1.2
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2017.05.21.08.31.51;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	2jRxmxbHPdFoweSz;

1.2
date	99.11.29.20.00.56;	author blaughto;	state Exp;
branches;
next	1.1;

1.1
date	99.11.29.18.45.57;	author blaughto;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.11.29.18.45.57;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.3
log
@OmniAccess brought up to date
* Makefile recreated from fragments
* 32 bit compatible (see support.s)
* Rewrote several pointless assembler routines in C
* Get defines from Interface/OmniClient.h, rather than local copies
* Internationalised
* Removed unused string header file
Tested sharing and unsharing some drives between a Risc PC (26 bit) and Titanium (32 bit, high vectors).

Version 0.17. Tagged as 'Access-0_17'
@
text
@/* Copyright 1999 Pace Micro Technology plc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* -*-C-*-
 *
 * omniacc.c    OmniClient interface for Access and Access+
 *
 * Previously (C) ANT Limited 1994. All rights reserved.
 * (C) Acorn Computers Ltd 1996. All rights reserved.
 *
 * Borris, December 1994.
 *
 * 30-03-95 Borris  Serious hackings to get authenticated objects both
 *                  working and appearing as Access+ presents them, which
 *                  isn't entirely straightforward.
 * 31-03-95 Borris  Polishing.
 * 25-05-95 Borris  Removed requirement for Access+ logins having a
 *                  password, as this is thought awkward by Acorn.
 *                  (Acorn bug ID NET-00761)
 * 26-01-96 Borris  Changes so last interest in an authenticated mount
 *                  disappearing cause deregistration of the interest
 *                  with FreeWay.
 * 31-01-96 Borris  Unauthentication changes done in accordance with new
 * 	    	    specification - provide a new entry point to cause
 *		    authentication interests to be deregistered.
 * 01-02-96 Borris  Added new SWI call through to above register stuff.
 * 02-02-96 Borris  Minor presentation changes.
 * 11-06-96 NAS     Minor changes to bring up to SWI_Spec v1.01 for domain
 * 		    logon.
 * 12-06-96 NAS     SWI_Spec 1.02, removed _Reset SWI and supports OmniOp,17
 * 		    instead.
 * 26-06-96 NAS     SWI_Spec 1.03, errors for FreeSpace and InactiveMount
 */

typedef unsigned int uint;

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>        /* For sig_atomic_t only - I don't use signals! */
#include <ctype.h>
#include "kernel.h"
#include "swis.h"

#include "Global/RISCOS.h"
#include "Global/Services.h"
#include "Global/Upcall.h"
#include "Global/ModHand.h"
#include "Interface/HighFSI.h"
#include "Interface/OmniClient.h"

#include "AsmUtils/irqs.h"

#include "DebugLib/DebugLib.h"

#include "AccessHdr.h"
#include "freeway.h"
#include "omni.h"
#include "omniacc.h"

static Error resources_register(void);
static void resources_deregister(void);
static Error messages_open(void);
static void messages_close(void);
static Error claim_omni(void);
static void release_omni(void);
static Error claim_freeway(void);
static void release_freeway(void);
static Error claim_sharefs(void);
static void release_sharefs(void);
static Error claim_free(void);
static void release_free(void);
static Error claim_upcall(void);
static void release_upcall(void);

static Error schedule (uint reasons);


/* global buffer, shared by many things. */
/* ensure no re-entrancy conflicts possible */

#define GSIZE   256

static char gbuf[GSIZE];
static Error gerr = NoError;


static ClaimPair connect_list[] =
{
    {   resources_register,          resources_deregister       },
    {   messages_open,               messages_close             },
    {   claim_omni,                  release_omni               },
    {   claim_freeway,               release_freeway            },
    {   claim_sharefs,               release_sharefs            },
    {   claim_free,                  release_free               },
    {   claim_upcall,                release_upcall             },
    {   NULL,                        NULL                       }
};

#ifdef DEBUG
static char *act_names[4] = { "ARRIVAL", "DEPARTURE", "CHANGED", "DELETED" };
#endif

static int msg_struct[4];
static int module_private_word;
static volatile uint state;
static struct authlist *auths;

static volatile uint flags;

extern const char *developed = "\n Developed by ANT Limited <sales@@ant.co.uk> \n";

/*****************************************************************************
 *
 * The Upcall handler adds items to this list during the upcall and schedules
 * the callback handler to complete the processing.
 */

static struct up_action *pending_actions;

/*****************************************************************************/

static server for_pseudo_accessplus =
{
    NULL,                   /* next server - none */
    NULL,                   /* omnireg * - Fill in later */

    (FreewayDescrip) 0u,    /* not really applicable */
    (unsigned char) 0u,     /* flags */
    0,                      /* at_offset */

    NULL,                   /* objname - Fill in later */
    NO_AUTHENT,
    (IPaddress) 0,

    "Access+",
    "Access+",
    NULL,                   /* server_description - Fill in later */

    NULL,
    NULL,
    NULL
};


/*****************************************************************************/

static omnireg access_servers =
{
    OmniAccess_00 + 0,
    OmniRegisterFlag_FilingSystem | OmniRegisterFlag_AnonymousMounts,
    "04a900", /* Sprite name */
    0u, /* Site ID (ignored) */
    "Share", /* FS name prefix */
    NULL /* List of servers */
};

/*****************************************************************************/

static omnireg pseudo_accessplus =
{
    OmniAccess_00 + 1,
    OmniRegisterFlag_SpecialAuth |
    OmniRegisterFlag_NeedPass |      /* 25/5/95: borris: permit empty password */
    OmniRegisterFlag_NeedAuth |      /* 11/6/96: NAS: request 'domain name' v1.01 spec */
    OmniRegisterFlag_FilingSystem | OmniRegisterFlag_AnonymousMounts,
    "04a901", /* Sprite name */
    0u, /* Site ID (ignored) */
    "Share+", /* FS name prefix */
    NULL /* List of servers */
};


/*****************************************************************************/




/*****************************************************************************
 *
 */

#ifdef DEBUG

static void note_error(Error err)
{
    if ( err == NoError )
        return;

    dprintf(("", "Error %s\n", err->errmess));
}

#else

#define note_error(e)

#endif

static Error omni_error1(int num, const char *arg)
{
    return _swix(Omni_MessageLookup, _INR(0,1), num, arg);
}

static Error omni_error(int num)
{
    return _swix(Omni_MessageLookup, _IN(0), num);
}

/*****************************************************************************
 *
 * Internationalisation
 */

static Error resources_register(void)
{
    return _swix(ResourceFS_RegisterFiles, _IN(0), Resources());
}

static void resources_deregister(void)
{
    _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());
}

static Error messages_open(void)
{
    return _swix(MessageTrans_OpenFile, _INR(0,2), msg_struct,
                 "Resources:$.ThirdParty.OmniClient.OmniAccess.Messages", 0); 
}

static void messages_close(void)
{
    _swix(MessageTrans_CloseFile, _IN(0), msg_struct);
}

static const char *intl_lookup(const char *token, const char *arg1)
{
    Error err;
    static char string[64];
  
    err = _swix(MessageTrans_Lookup, _INR(0,7),
                msg_struct, token, string, sizeof(string),
                arg1, NULL, NULL, NULL);
    if (err)
    {
        return "???";
    }
    return (const char *)string;
}

/*****************************************************************************
 *
 */

#ifdef PARANOID

static void panic(char *msg, ...)
{
    static char buffer[1024];

    va_list arg;
    va_start(arg, msg);

    strcpy(buffer, "Panic: ");

    vsprintf(buffer + strlen(buffer), msg, arg);

    fputs(buffer, stdout);

    sprintf(buffer, "\n");

    fputs(buffer, stdout);
    fflush(stdout);

    va_end(arg);

    exit(1);
}

#endif

/*****************************************************************************/

static Error mycli(const char *str)
{
    Error err;

    dprintf(("", "CLI: %s", str));

    err = _swix(OS_CLI, _IN(0), str);

    if (err != NoError)
    {
        dprintf(("", "Got error %s", err->errmess));
    }

    return err;
}

/*****************************************************************************/

/* These two functions come from Acorn and are the magic routines for   */
/* converting a password string to a freeway authentication value.      */
/* There is no ABI/API to access these. They are not defined. We have   */
/* to ensure either they never change or we keep up to date with Acorn  */
/* on any changes they make. How repulsive!                             */

static int encode_psw_char(char c)
{
    int i;
    c = toupper(c);
    if (isdigit(c))
        i = ((int) c - (int) '0') + 1;
    else
    if (isalpha(c))
        i = ((int) c - (int) 'A') + 11;
    else
        i = 0;
    return i;
}

static FreewayAuthent password_to_authent(char *buf)
{
    FreewayAuthent pin = 0;

    if (buf != NULL)
        for (; *buf; buf++)
        {
            pin *= 37;
            pin += encode_psw_char(*buf);
        }

    return pin;
}

/*****************************************************************************
 *
 *
 */

static Error cause_server_enum(int client)
{
    return _swix(Omni_EnumerateMounts, _INR(0,1),
                 client, OmniEnumerateMounts_Servers);
}

static Error cause_mounts_enum(int client)
{
    return _swix(Omni_EnumerateMounts, _INR(0,1),
                 client, OmniEnumerateMounts_ActiveMounts);
}

/*****************************************************************************
 *
 *
 */

static void commit_suicide(void)
{
    dprintf(("", "Commiting suicide"));

    suicide("OmniAccess");   /* Module title, as in rmkill OmniAccess */
}


/*****************************************************************************/

static char * strdup (const char *str)
{
    char *new;

    if (str == NULL)
        return NULL;

    new = (char *) malloc( strlen(str) + 1 );

    if (new == NULL)
        return NULL;

    return strcpy(new, str);
}

/*****************************************************************************
 *
 *
 */

static char * strndup (const char *str, int n)
{
    char *new;

    if (str == NULL)
        return NULL;

    new = (char *) malloc( n + 1 );

    if (new == NULL)
        return NULL;

    new[n] = '\0';

    return strncpy(new, str, n);
}

/*****************************************************************************
 *
 */

static int strieq(const char *a, const char *b)
{
    if (a == b)
        return 1;

    if (a == NULL || b == NULL)
        return 0;

    while (*a != 0 && *b != 0)
    {
        if (toupper(*a) != toupper(*b))
            return 0;
        a++;
        b++;
    }

    return toupper(*a) == toupper(*b);
}

static int strieqn(const char *a, const char *b, int len)
{
    if (a == b || len <= 0)
        return 1;

    if (a == NULL || b == NULL)
        return 0;

    while (*a != 0 && *b != 0 && len-- > 0)
    {
        if (toupper(*a) != toupper(*b))
            return 0;
        a++;
        b++;
    }

    return (len == 0) ? 1 : toupper(*a) == toupper(*b);
}



/*****************************************************************************
 *
 * Ensure that an association between a user name and a Freeway authentication
 * value exists in our dictionary.
 */


static struct authlist * find_authentN(FreewayAuthent auth, char *mntpre, int len)
{
    struct authlist *ap = auths;

    /*dprintf(("", "Searching for %*s:%x in authlist", len, mntpre, auth));*/

    if (len == 0)
        return NULL;

    while (ap != NULL)
    {
        if ( ap->authent == auth && ap->len == len && strieqn(mntpre, ap->users_name, len) )
            return ap;
        ap = ap->next;
    }

    return NULL;
}

#if 0
static struct authlist * find_authent(FreewayAuthent auth, char *mntpre)
{
    return find_authentN(auth, mntpre, strlen(mntpre));
}
#endif

static struct authlist * stash_authent(FreewayAuthent auth, char *mntpre)
{
    struct authlist *ap = find_authentN(auth, mntpre, strlen(mntpre));
    args_FreewayRegister args;
    Error err;

    if (ap != NULL)
    {
        dprintf(("", "Found authlist entry for %s:%x in authlist", ap->users_name, ap->authent));
        return ap;
    }

    /* Don't have an entry yet, try to create one */

    ap = calloc(sizeof(struct authlist), 1);

    if (ap == NULL || (ap->users_name = strdup(mntpre)) == NULL)
    {
        dprintf(("", "Ran out of memory creating authlist entry"));

        if (ap != NULL)
            free(ap);

        return NULL;
    }

    args.flags = 2;                      /* Register authenticated interest*/
    args.type = FREEOBJ_DISCS;
    ap->authent = args.authent = auth;
    ap->len = strlen(ap->users_name);

    dprintf(("", "Registering interest in authenticated objects for %s:%x", mntpre, auth));

    err = SWIX(Freeway_Register, &args, &args);

    if (err != NoError)
    {
        free(ap->users_name);
        free(ap);
        dprintf(("", "Error %s when trying to register interest", err->errmess));
        return NULL;
    }

    {DISABLE_IRQS;
        ap->next = auths;
        auths = ap;
    RESTORE_IRQS;}

    return ap;
}


/*****************************************************************************
 *
 * 0 - don't mount this mount
 * 1 - mount this mount
 */

static int consider_accessplus_mount_name(server *sp)
{
    int rc;

    /* Acorn only get mounts if they tie up with the user's entered mount name */

    if (sp->at_offset == 0)
    {
        /* always permits unauthenticated objects through this filter */
        rc = 1;
    }
    else if (sp->authent == NO_AUTHENT)
    {
        /* Cannot yet determine if this should be displayed or not, so hide it */
        rc = 0;
    }
    else
    {
        /* Permit to be displayed if can find matching auth/prefix pair */
        rc = NULL != find_authentN(sp->authent, sp->objname, sp->at_offset);
    }

    if (rc)
        sp->flags |= SERVER_YES;
    else
        sp->flags &= ~ SERVER_YES;

    return rc;
}
/*****************************************************************************
 *
 * Calculate how many bytes of buffer space are required to enumerate the
 * supplied active mount.
 */

static uint bytes_to_enum_active_mount (server *sp)
{
    uint x = sizeof(server *) + sizeof(server *) + strlen(sp->mount_mountname) + 1 + 3;

    return x & ~ 3;
}

/*****************************************************************************
 *
 * Calculate how many bytes of buffer space are required to enumerate the
 * supplied mount.
 */

#if 0
static uint bytes_to_enum_mount (server *sp)
{
    uint x = sizeof(server *) + strlen(sp->mount_shortname) + strlen(sp->mount_fullname) + 1+1 + 3;

    return x & ~ 3;
}
#endif

/*****************************************************************************
 *
 * Calculate how many bytes of buffer space are required to enumerate the
 * supplied server.
 */

static uint bytes_to_enum_server (server *sp)
{
    uint x = sizeof(server *)
             + strlen(sp->server_shortname)
             + strlen(sp->server_fullname)
             + strlen(sp->server_description)
             + 1+1+1 + 3;

    return x & ~ 3;
}


/*****************************************************************************
 *
 */

static char * gen_server_shortname (up_action *up)
{
    char *cp = strndup(up->objname, 24);

    return cp;
}

/*****************************************************************************
 *
 */

static char * gen_server_fullname (up_action *up)
{
    char *cp = strndup(up->objname, 64);

    return cp;
}

/*****************************************************************************
 *
 * Coded for little endian processor!
 */

static char * gen_server_description (up_action *up)
{
    char *cp = (char *) malloc(64), *cp2 = (char *) (&up->address);

    if (cp == NULL)
        return NULL;

    sprintf(cp, "%d.%d.%d.%d\n%s", cp2[0], cp2[1], cp2[2], cp2[3],
                                   intl_lookup("Server", NULL));

    return cp;
}

/*****************************************************************************
 *
 */

static char * gen_mount_shortname (up_action *up)
{
    char *cp = strndup(up->objname, 24);

    return cp;
}

/*****************************************************************************
 *
 */

static char * gen_mount_fullname (up_action *up)
{
    char *cp = strndup(up->objname, 64);

    return cp;
}

/*****************************************************************************
 *
 */

static char * gen_mount_mountname (up_action *up)
{
    char *cp = strndup(up->objname, 16);

    return cp;
}

/*****************************************************************************
 *
 *
 */

#ifdef PARANOID

static volatile sig_atomic_t gbuf_sema;

static void claim_gbuf (void)
{
    DISABLE_IRQS;

    if (gbuf_sema == 0)
    {
        gbuf_sema = 1;
    }
    else
    {
               dprintf(("", "Global buffer claim error\n"));
    }

    RESTORE_IRQS;

    return;
}

#else

#define claim_gbuf()

#endif

/*****************************************************************************
 *
 *
 */

#ifdef PARANOID

static void release_gbuf (void)
{
    DISABLE_IRQS;

    if (gbuf_sema == 1)
    {
        gbuf_sema = 0;
    }
    else
    {
        dprintf(("", "Global buffer free error\n"));
    }

    RESTORE_IRQS;

    return;
}

#else

#define release_gbuf()

#endif

/*****************************************************************************
 *
 * Free a server structure. Assume it is not currently linked into any chains.
 */

static void free_server (server *sp)
{
    if (sp == NULL)
        return;

    if (sp->objname != NULL)
        free(sp->objname);

    if (sp->server_shortname != NULL)
        free(sp->server_shortname);

    if (sp->server_fullname != NULL)
        free(sp->server_fullname);

    if (sp->server_description != NULL)
        free(sp->server_description);

    if (sp->mount_shortname != NULL)
        free(sp->mount_shortname);

    if (sp->mount_fullname != NULL)
        free(sp->mount_fullname);

    if (sp->mount_mountname != NULL)
        free(sp->mount_mountname);

    free(sp);
}

static void free_server_list(server *sp)
{
    while (sp != NULL)
    {
        server *tp = sp->next;
        free_server(sp);
        sp = tp;
    }
}

/*****************************************************************************/


static void remove_dead_servers(void)
{
    DISABLE_IRQS;

    server *sp = access_servers.servers;

    while ( sp != NULL && (sp->flags & SERVER_GONE) != 0 )
    {
        access_servers.servers = sp->next;
        dprintf(("", "Removing dead server %s:%x", sp->objname, sp->authent));
        free_server(sp);
        sp = access_servers.servers;
        cause_server_enum(access_servers.client_id);
    }

    if (sp != NULL)
    {
        while (sp->next != NULL)
        {
            if (sp->next->flags & SERVER_GONE)
            {
                server *tp = sp->next->next;
                dprintf(("", "Removing dead server %s:%x", sp->objname, sp->authent));
                free_server(sp->next);
                sp->next = tp;
                cause_server_enum(access_servers.client_id);
            }
            else
                sp = sp->next;
        }
    }

    RESTORE_IRQS;
}


/*****************************************************************************/


static void sharefsify(char *a, char *b)
{
    gbuf[0] = 0;

    if (a != NULL)
    {
        strcpy(gbuf, a);
        strcat(gbuf, " ");
    }

    strcat(gbuf, "Share::");
    strcat(gbuf, b);
    strcat(gbuf, ".$");
}

/*****************************************************************************/

/* static int visible_servers(void)
{
    server *sp;
    int vis = 0;

    for (sp = access_servers.servers; sp != NULL; sp = sp->next)
        if ( (sp->flags & SERVER_HIDDEN) == 0)
            vis += 1;

    return vis;
} */

static server *server_from_objname(server *sp, char *objname)
{
    while (sp != NULL)
    {
        if ( strieq(sp->objname, objname) )
        {
            return sp;
        }
        sp = sp->next;
    }

    return NULL;
}


/*****************************************************************************/

static server * create_server_from_upaction(up_action *up)
{
    server *sp = (server *) calloc(sizeof(server),1);
    char *cp;

    dprintf(("", "Create server for %s", up->objname));

    if (sp == NULL)
        return sp;

    sp->objname = strdup(up->objname);
    sp->server_shortname = gen_server_shortname(up);
    sp->server_fullname  = gen_server_fullname(up);
    sp->server_description = gen_server_description(up);
    sp->mount_shortname = gen_mount_shortname(up);
    sp->mount_fullname = gen_mount_fullname(up);
    sp->mount_mountname = gen_mount_mountname(up);

    if (sp->objname == NULL
    || sp->server_shortname == NULL
    || sp->server_fullname == NULL
    || sp->server_description == NULL
    || sp->mount_shortname == NULL
    || sp->mount_fullname == NULL
    || sp->mount_mountname == NULL )
    {
        free_server(sp);
        return NULL;
    }

    cp = strchr(sp->objname, '@@');
    sp->flags = 0;
    sp->descriptor = up->descriptor;
    sp->authent = up->authent;
    sp->address = up->address;

    if (cp == NULL)
    {
        sp->at_offset = 0;
    }
    else
    {
        sp->at_offset = cp - sp->objname;
        sp->flags |= SERVER_ACCESSPLUS | SERVER_HIDDEN;

        if (sp->authent == NO_AUTHENT)
        {
            /*dprintf(("", "Triggering enumeration due to creation of '@@' server with no authent"));*/
            schedule(DO_ENUM_FREEWAY);
        }

        if ( consider_accessplus_mount_name(sp) )
            sp->flags &= ~ SERVER_HIDDEN;
    }

    return sp;
}


/*****************************************************************************/

static void free_upaction(up_action *up)
{
    if (up == NULL)
        return;

    if (up->objname != NULL)
        free(up->objname);

    free(up);
}

/*****************************************************************************/

static server * server_from_fullname(server *sp, char *fullname)
{
    while (sp != NULL)
    {
        if (strieq(sp->server_fullname, fullname))
            return sp;

        sp = sp->next;
    }

    return NULL;
}

/*****************************************************************************/

static void add_up_action(up_action *up)
{
    if (up != NULL)
    {
        DISABLE_IRQS;

            up->next = pending_actions;
            pending_actions = up;

            schedule(DO_UPCALL_ACTION);

        RESTORE_IRQS;

        dprintf(("", "Added up action %s for %s:%x", act_names[up->action], up->objname, up->authent));
    }
}

/*****************************************************************************
 *
 * Start interacting with the Free module.
 */

static Error claim_free (void)
{
    return NoError;
}

/*****************************************************************************
 *
 * Release interaction with the Free module.
 */

static void release_free (void)
{
    return;
}

/*****************************************************************************
 *
 * Register an interest in unauthenticated disc objects. Registration for
 * authenticated objects is performed when we are supplied the user,key pairs
 * via the pseudo server.
 */

static Error claim_freeway(void)
{
    args_FreewayRegister args;

    args.flags = 0;             /* Register interest */
    args.type = FREEOBJ_DISCS;
    args.authent = NO_AUTHENT;

    dprintf(("", "claiming freeway"));

    return SWIX(Freeway_Register, &args, &args);
}

/*****************************************************************************
 *
 * Deregister all interest in Freeway objects. This includes both
 * authenticated and unauthenticated disc objects. Memory is not actually
 * freed by this routine (see post_final). Remember that a given authent
 * value can occur multiply, and that
 * a particular authent value should only be de-registered once.
 */

static void deregister_authenticated(struct authlist *ap)
{
    args_FreewayRegister args;
    Error err;

    args.flags = 3;                             /* Deregister authenticated*/
    args.type = FREEOBJ_DISCS;
    args.authent = ap->authent;

    dprintf(("", "Releasing freeway interest in %s:%x", ap->users_name, ap->authent));

    err = SWIX(Freeway_Register, &args, &args);

#ifdef PARANOID
    if (err != NULL)
        dprintf(("", "Error %s when deregistering freeway interest", err->errmess));
#endif
}

static void release_freeway(void)
{
    args_FreewayRegister args;
    Error err;
    struct authlist *ap;

    if (flags & LOST_FREEWAY)
        return;

    dprintf(("", "Releasing all Freeway registrations"));

    args.flags = 1;                           /* Deregister unauthenticated*/
    args.type = FREEOBJ_DISCS;
    args.authent = NO_AUTHENT;

    err = SWIX(Freeway_Register, &args, &args);

#ifdef PARANOID
    if (err != NoError)
        dprintf(("", "Error %s when de-registering unauthenticated interest", err->errmess));
#endif

    for (ap = auths; ap != NULL; ap = ap->next)
    {
        deregister_authenticated(ap);
    }

    return;
}

/*****************************************************************************
 *
 *
 */

static Error claim_upcall(void)
{
   dprintf(("", "Claiming upcalls"));

   return _swix(OS_Claim, _INR(0,2), UpCallV, upcall_veneer, module_private_word);
}

/*****************************************************************************
 *
 *
 */

static void release_upcall(void)
{
   dprintf(("", "Releasing Upcalls"));

   _swix(OS_Claim, _INR(0,2), UpCallV, upcall_veneer, module_private_word);
}

/*****************************************************************************
 *
 * No claiming actions currently known for ShareFS, but hook provided.
 */

static Error claim_sharefs(void)
{
    dprintf(("", "Claiming ShareFS - no actions"));

    return NoError;
}

/*****************************************************************************
 *
 * No releasing actions currently known for ShareFS, but hook provided.
 */

static void release_sharefs(void)
{
    dprintf(("", "Releasing ShareFS"));

    if (flags & LOST_SHAREFS)
        return;

    return;
}

/*****************************************************************************
 *
 * We place two connections to OmniClient for Access, and another two for
 * Access+, if present. The first of each of these connections is where a
 * new disc object appears. The second is present for pseudo server purpose,
 * to give us something to log on through.
 */

static Error claim_omni2(omnireg *orp, const char *token)
{
    args_OmniRegisterClient args;
    Error err;
    char titlebar[24];  /* Title bar - 24 max */
    char infobox[3*32]; /* Info box - 3x32 max */

    strcpy(titlebar, intl_lookup("_Version", NULL)); /* Temp copy */
    sprintf(infobox, "%s\n"
                     "\xA9 Acorn Computers Ltd, 1997\n"
                     "%s",
                     intl_lookup(token, NULL), titlebar);
    strncpy(titlebar, intl_lookup("DispName", NULL), sizeof(titlebar));
  
    args.client_id = orp->client_id;
    args.client_flags = orp->client_flags;
    args.sprite_name = orp->sprite_name;
    args.client_name = titlebar;
    args.client_description = infobox;
    args.site_word = orp->site_word;
    args.fs_name = orp->fs_name;

    err = SWIX(Omni_RegisterClient, &args, &args);

    note_error(err);

    return err;
}

static Error claim_omni(void)
{
    Error err;

    dprintf(("", "Claiming OmniClient"));

    mycli("IconSprites Resources:$.ThirdParty.OmniClient.OmniAccess.Sprites");

    if ( ( err = claim_omni2(&access_servers, "WhoAcc") ) == NULL )
    {
        flag_set(REGISTERED_0);
    }

    if (err != NoError || (flags & HAVE_AUTHENTICATION) == 0)
        return err;

    if ( ( err = claim_omni2(&pseudo_accessplus, "WhoAccPlus") ) == NULL )
    {
        flag_set(REGISTERED_1);
    }


    return err;
}

/*****************************************************************************
 *
 * Deregister all our claims with OmniClient.
 */

static void release_omni(void)
{
    uint f;

    args_OmniDeregisterClient args;

    dprintf(("", "Releasing OmniClient"));

    if (flags & LOST_OMNI)
        return;

    f  = flag_clr(REGISTERED_0 | REGISTERED_1  );
    f &=          REGISTERED_0 | REGISTERED_1   ;

    if (f & REGISTERED_0)
    {
        args.client_id = access_servers.client_id;
        (void) SWIX(Omni_DeregisterClient, &args, &args);
    }

    if (f & REGISTERED_1)
    {
        args.client_id = pseudo_accessplus.client_id;
        (void) SWIX(Omni_DeregisterClient, &args, &args);
    }

    return;
}

/*****************************************************************************
 *
 * Release a set of claims from a list.
 */

static void release_from_list (ClaimPair *list)
{
    ClaimPair *ptr = list;

    dprintf(("", "Releasing from list"));

    while (ptr->release != NULL)
    {
        ptr += 1;
    }

    while (ptr != list)
    {
        ptr -= 1;

        (*ptr->release) ();
    }

    dprintf(("", "Released from list"));

    return;
}

/*****************************************************************************
 *
 * Run down a ClaimPair list, claiming facilities. If an error occurs,
 * backtrack and execute the release functions and return the error. Returns
 * NoError if all the claim functions successfully terminated. The higher
 * index end of the table is denotated through a pair of NULL entries.
 */

static Error claim_from_list (ClaimPair *list)
{
    ClaimPair *ptr = list;
    Error e = NoError;

    dprintf(("", "Starting to claim from list"));

    do
    {
        e = (*ptr->claim) ();

        ptr += 1;
    } while ( e == NoError && ptr->claim != NULL );

    if ( e == NoError )
    {
        dprintf(("", "Successfully claimed from list\n"));

        return e;
    }

    dprintf(("", "Failed to claim from list - reversing claims"));

    while (ptr != list)
    {
        ptr -= 1;

        (*ptr->release) ();
    }

    dprintf(("", "Finished reversing claims - idle state restored"));

    return e;
}

/*****************************************************************************
 *
 * This routine determines if the required modules are present. This must be
 * done in a fashion without side effects.
 *
 * We use OS_Module to perform a lookup on the desired module's name. For
 * Freeway and ShareFS we also use the version number to decide whether we
 * have a system capable of supporting Freeway authentication.
 */

static int necessary_modules_present (int std)
{
    static char *table [] =
    {
        "Freeway",      /* first checked */
        "ShareFS",      /* second checked */
        "OmniClient",
        "ResourceFS",
        "Free"
    };

    int i;
    int no_auth = 0;

    for (i = 0; i < sizeof(table) / sizeof(table[0]); i++)
    {
        _kernel_oserror *ep;
        char *cp;
        int n, base;

        ep = _swix(OS_Module, _INR(0,1) | _OUT(3),
                   ModHandReason_LookupName, table[i], &base);

        if (ep != NULL)
        {
            dprintf(("", "Module %s not present yet", table[i]));

            return 0;
        }

        switch (i)
        {
            case 0:
                if (!std)
                    flag_set(SEEN_FREEWAY);
                break;

            case 1:
                if (!std)
                    flag_set(SEEN_SHAREFS);
                break;
/*
            case 2:
                if (!std)
                    flag_set(SEEN_OMNI);
                break;
*/
        }

        if (i > 1)
            continue;

        n = base;

        n += ((int *)n) [Module_HelpStr / sizeof(int) ];

        cp = (char *) n;
/*
        dprintf(("", "Checking modules: %s", cp));
*/
        cp = strchr(cp, '(');

        if (cp == NULL || cp[-4] != '.')
            continue;

        n  = (cp[-5] - '0') * 100;
        n += (cp[-3] - '0') * 10;
        n += (cp[-2] - '0') * 1;
/*
        dprintf(("", "Got version of %d", n));
*/
        if (i == 0 && n < MAGIC_FREEWAY_VERSION)
            no_auth = 1;

        if (i == 1 && n < MAGIC_SHAREFS_VERSION)
            no_auth = 1;
    }

    dprintf(("", "All necessary modules present"));

    if (no_auth)
        flag_clr(HAVE_AUTHENTICATION);
    else
        flag_set(HAVE_AUTHENTICATION);

    return 1;
}
/*****************************************************************************
 *
 * Perform whatever close down type actions are necessary to cease using
 * a server. This includes dismounting it and closing its windows.
 */

static Error shutdown_server(server *sp, uint flags)
{
    Error err = NULL;

    if (sp == NULL)
        return ENOSERVER;

    if (sp->flags & SERVER_MOUNTED)
    {
        dprintf(("", "OmniOp_Dismount server '%s', %x", sp->mount_fullname, flags));
        claim_gbuf();
        if (flags & SHUT_CLOSEDIR)
        {
            sharefsify("filer_closedir", sp->objname);
            err = mycli(gbuf);
            note_error(err);
        }
        if (flags & SHUT_DISMOUNT)
        {
            strcpy(gbuf, "share:dismount :");
            strcat(gbuf, sp->objname);
            err = mycli(gbuf);
            note_error(err);
        }
        release_gbuf();
        sp->flags &= ~ SERVER_MOUNTED;
        if (state == RUNNING && (flags & SHUT_ENUMERATE) != 0)
        {
            cause_mounts_enum(sp->context->client_id);
            cause_server_enum(sp->context->client_id);
        }
    }
    else
    {
          dprintf(("", "Not mounted: %s", sp->objname));
          err = ENOSUCHSERVER(sp->objname);
    }

    return err;
}

/*****************************************************************************
 *
 * Perform the upcall actions currently queued up. This will only be called
 * when upcall action processing is not suspended. This can trigger OmniClient
 * enumeration requests. If these arrive during this processing, then maybe
 * things won't work quite so well!
 */

static void perform_upcall_actions (void)
{
    struct up_action *curr = NULL, *revd = NULL;
    server *sp;

    /* Atomically remove currently queued actions */

    DISABLE_IRQS;
        struct up_action *acts = pending_actions;
        pending_actions = NULL;
    RESTORE_IRQS;

    dprintf(("", "Performing queued upcall actions"));

    /* Reverse action list to get requests in correct order */

    while (acts != NULL)
    {
        struct up_action *next = acts->next;

        acts->next = NULL;

        if (curr == NULL)
        {
            curr = revd = acts;
        }
        else
        {
            curr->next = acts;
            curr = acts;
        }

        acts = next;
    }

    /* Process correctly ordered actions list */

    while (revd != NULL)
    {
        up_action *next = revd->next;
        sp = server_from_objname(access_servers.servers, revd->objname);

        switch (revd->action)
        {
            case FREEACT_ARRIVAL:
                if (sp == NULL)
                {
                    sp = create_server_from_upaction(revd);

                    if (sp == NULL)
                    {
                        flag_set(HIDDEN_ERROR);
                        dprintf(("", "Failed to create server for %s:%x", revd->objname, revd->authent));
                    }
                    else
                    {
                        omnireg *rp = &access_servers;/* omnireg_from_authent(revd->authent);*/

                        DISABLE_IRQS;
                            sp->next = rp->servers;
                            sp->context = rp;
                            rp->servers = sp;
                        RESTORE_IRQS;

                        cause_server_enum(rp->client_id);

                        dprintf(("", "Added new object %s:%x", revd->objname, revd->authent));
                    }
                }
                else
                {
                    dprintf(("", "Already got object %s:%x - rescheduling as change", sp->objname, sp->authent));

                    revd->action = FREEACT_CHANGED;

                    add_up_action(revd);
                    revd = NULL;
                }
                break;

            case FREEACT_DEPARTURE:
            case FREEACT_DELETED:
                if (sp == NULL)
                {
                    dprintf(("", "Object %s:%x not exist - force freeway enumeration", revd->objname, revd->authent));

                    schedule(DO_ENUM_FREEWAY);
                }
                else
                {
                    if (sp->flags & SERVER_MOUNTED)
                    {
                        shutdown_server(sp, SHUT_ENUMERATE | SHUT_DISMOUNT);
                    }

                    sp->flags |= SERVER_GONE | SERVER_HIDDEN;

                    cause_server_enum(sp->context->client_id);

                    dprintf(("", "Freeway object departure/deletion %s:%x", sp->objname, sp->authent));
                }
                break;

            case FREEACT_CHANGED:
                if ( sp != NULL )
                {
                    int old = 0, new = 0;

                    old |= (sp->descriptor & OBJDESC_HIDDEN) ? 1 : 0;
                    old |= (sp->flags & SERVER_YES) ? 2 : 0;

                    sp->descriptor = revd->descriptor;

                    if (revd->authent != NO_AUTHENT)
                    {
                        if (sp->authent != revd->authent)
                        {
                            dprintf(("", "Latched onto %x as authent value for %s", revd->authent, sp->objname));
                            sp->authent = revd->authent;
                            new |= 4;
                        }
                    }

                    new |= (sp->descriptor & OBJDESC_HIDDEN) ? 1 : 0;
                    new |= consider_accessplus_mount_name(sp) ? 2 : 0;

                    if ( new != old )
                    {
                        dprintf(("", "Change information: new %x, old %x", new, old));

                        sp->flags &= ~ SERVER_MOUNTED;
                        sp->flags |= SERVER_HIDDEN;

                        if ( (revd->descriptor & OBJDESC_HIDDEN) == 0 && consider_accessplus_mount_name(sp) )
                            sp->flags &= ~ SERVER_HIDDEN;

                        dprintf(("", "Causing server enum due to %s:%x", sp->objname, sp->authent));

                        cause_server_enum(sp->context->client_id);
                    }
                    else
                        dprintf(("", "%s:%x - noted nothing significant in %x", sp->objname, sp->authent, new));
                }
                else
                {
                    dprintf(("", "Object %s:%x has changed but not found - force freeway enum", revd->objname, revd->authent));

                    schedule(DO_ENUM_FREEWAY);
                }
                break;
        }

        free_upaction(revd);    /* Maybe NULL */

        revd = next;
    }

    return;
}


/*****************************************************************************
 *
 * Assume disc objects only.
 */

static up_action *make_up_action
(
    uint act,
    char *name,
    FreewayDescrip descrip,
    IPaddress addr,
    FreewayAuthent auth
)
{
    up_action *up = (up_action *) malloc(sizeof(*up));

    if (up == NULL)
        return NULL;

    if ( (up->objname = strdup(name)) == NULL)
    {
        free(up);
        return NULL;
    }

    up->next = NULL;
    up->action = act;
    up->type = FREEOBJ_DISCS;
    up->descriptor = descrip;
    up->address = addr;
    up->authent = auth;

    return up;
}


/*****************************************************************************
 *
 * Enumerate all available Freeway objects and ensure that our view of the
 * current objects ties up with Freeway's. This can cause object deletion,
 * addition and changing, just like the upcall.
 */

static void enumerate_access(void)
{
    server *sp;
    up_action *up;
    Error err;
    int f;

    args_FreewayEnumerate args;

    /* if (flag_clr(SEEN_SHAREFS) || flag_clr(SEEN_FREEWAY)) return; */
    claim_gbuf();

    args.flags = 0;         /* Unauth objects */
    args.type = FREEOBJ_DISCS;
    args.name_buffer = & gbuf[0];
    args.descriptor_buffer = & gbuf[GSIZE / 2];
    args.context = 0;
    args.authent = NO_AUTHENT;

    for (sp = access_servers.servers; sp != NULL; sp = sp->next)
    {
        /* Catch only Access servers */
        if ( (sp->flags & SERVER_ACCESSPLUS) == 0)
            sp->flags |= SERVER_FLAG;
        else
            sp->flags &= ~ SERVER_FLAG;
    }

    do
    {
        args.name_length = GSIZE / 2;
        args.descriptor_length = GSIZE / 2;

        err = SWIX(Freeway_Enumerate, &args, &args);

        f = (err == NoError && args.context != -1);

#ifdef PARANOID
        if (err != NULL)
            dprintf(("", "Error %s when enumerating access", err->errmess));
#endif

        if (f)
        {
            /* Either this server is previously unknown or it has changed */

            /*dprintf(("", "Access enumeration found %s:%x", args.name_buffer, args.authent));*/

            sp = server_from_objname(access_servers.servers, args.name_buffer);

            if (sp != NULL)
                sp->flags &= ~ SERVER_FLAG;     /* Note still exists */

            up = make_up_action(sp == NULL ? FREEACT_ARRIVAL : FREEACT_CHANGED,
                                args.name_buffer,
                                (FreewayDescrip) args.descriptor_buffer[0],
                                args.address,
                                NO_AUTHENT);

            if (up == NULL)
            {
                f = 0;
                flag_set(HIDDEN_ERROR);
            }
            else
                add_up_action(up);
        }
    } while (f);

    for (sp = access_servers.servers; sp != NULL; sp = sp->next)
    {
        /* Will only look for Access servers - not Access+ servers */

        if (sp->flags & SERVER_FLAG)
        {
            /* Server has disappeared since our last observations */

            dprintf(("", "Server seems to have disappeared %s:%x", sp->objname, sp->authent));

            up = make_up_action(FREEACT_DEPARTURE, sp->objname, sp->descriptor, sp->address, sp->authent);

            if (up == NULL)
            {
                flag_set(HIDDEN_ERROR);
            }
            else
                add_up_action(up);
        }
    }

    release_gbuf();

    return;
}

/*****************************************************************************
 *
 * Enumerate all available freeway authenticated disc objects and ensure we
 * are up to date with them.
 */

static void enumerate_accessplus(void)
{
    struct authlist *ap;
    server *sp;
    up_action *up;
    args_FreewayEnumerate args;
    int f;
    Error err;

    /* if (flag_clr(SEEN_SHAREFS) || flag_clr(SEEN_FREEWAY)) return; */
    claim_gbuf();

    for (sp = access_servers.servers; sp != NULL; sp = sp->next)
    {
        /* Only catch Access+ servers */
        if ( (sp->flags & SERVER_ACCESSPLUS) == SERVER_ACCESSPLUS )
        {
            sp->flags |= SERVER_FLAG;
        }
        else
        {
            sp->flags &= ~ SERVER_FLAG;
        }
    }

    for (ap = auths; ap != NULL; ap = ap->next)
    {
        args.flags = 1;         /* Auth objects only */
        args.type = FREEOBJ_DISCS;
        args.name_buffer = & gbuf[0];
        args.descriptor_buffer = & gbuf[GSIZE / 2];
        args.context = 0;
        args.authent = ap->authent;

        /* Will do more work than necessary when have same key for different */
        /* 'users name' values. */

        dprintf(("", "Enumerating on authentication value of %s:%x", ap->users_name, ap->authent));

        do
        {
            args.name_length = GSIZE / 2;
            args.descriptor_length = GSIZE / 2;

            err = SWIX(Freeway_Enumerate, &args, &args);

            f = (err == NoError && args.context != -1);

#ifdef PARANOID
            if (err != NULL)
                dprintf(("", "Error %s enumerating Access+", err->errmess));
#endif

            if (f)
            {
                /*dprintf(("", "Access+ enumeration found %s:%x", args.name_buffer, args.authent));*/

                /* Either this server is previously unknown or it has changed */

                sp = server_from_objname(access_servers.servers, args.name_buffer);

                if (sp != NULL)
                {
                    sp->flags &= ~ SERVER_FLAG;     /* Note still exists */
                    /*dprintf(("", "Cancelled server flag on %s:%x", sp->objname, sp->authent));*/
#ifdef PARANOID
                    if (args.authent != ap->authent)
                        dprintf(("", "SWI has overridden %x with %x", ap->authent, args.authent));

                    if ( sp->authent != NO_AUTHENT && sp->authent != ap->authent )
                        dprintf(("", "Auth %x appears to override %x for %s", ap->authent, sp->authent, sp->objname));

                    if ( strchr(sp->objname, '@@') == NULL )
                        dprintf(("", "%s:%x doesn't appear to be an authenticated object?", sp->objname, sp->authent));
#endif
                    if (sp->authent == NO_AUTHENT)
                    {
#ifdef PARANOID
                        if ( (sp->flags & SERVER_HIDDEN) == 0)
                            dprintf(("", "Server %s not hidden when would expect it to be", sp->objname));
#endif
                        dprintf(("", "Now got authent %x for %s", ap->authent, sp->objname));
                        sp->authent = ap->authent;
                        if ( consider_accessplus_mount_name(sp) )
                            sp->flags &= ~ SERVER_HIDDEN;
                    }
                }

                up = make_up_action(sp == NULL ? FREEACT_ARRIVAL : FREEACT_CHANGED,
                                    args.name_buffer,
                                    (FreewayDescrip) args.descriptor_buffer[0],
                                    args.address,
                                    ap->authent);

                if (up == NULL)
                {
                    f = 0;
                    flag_set(HIDDEN_ERROR);
                }
                else
                    add_up_action(up);
            }
        } while (f);
    }

    for (sp = access_servers.servers; sp != NULL; sp = sp->next)
    {
        /* Will only catch Access+ servers - not Access servers */

        if (sp->flags & SERVER_FLAG)
        {
            /* Server has disappeared since our last observations */

            dprintf(("", "Server %s:%x seems to have disappeared", sp->objname, sp->authent));

            up = make_up_action(FREEACT_DEPARTURE, sp->objname, sp->descriptor, sp->address, sp->authent);

            if (up == NULL)
            {
                flag_set(HIDDEN_ERROR);
            }
            else
                add_up_action(up);
        }
    }

    release_gbuf();

    return;
}

/*****************************************************************************/

static void ripple_any_changes(void)
{
    do
    {
        enumerate_access();
        if (flags & HAVE_AUTHENTICATION)
            enumerate_accessplus();

        perform_upcall_actions();
    } while ( flag_clr(DO_ENUM_FREEWAY) & DO_ENUM_FREEWAY );
}

/*****************************************************************************
 *
 * The necessary modules are present and we have successfully established
 * the necessary connections to them. We are now in a position to create the
 * necessary servers and pseudo servers. Whether the current version of
 * Freeway and Access support authenticated objects is also now known.
 *
 * The necessary structure for the pseudo servers has pre-initialised - we
 * just have to ensure they get enumerated.
 */

static Error create_initial_servers (void)
{
    args_OmniEnumerateMounts args;
    Error err;
    char desc[64];

    dprintf(("", "Internationalise pseudo logon server"));

    sprintf(desc, "%s\n \n ", intl_lookup("XtrLogon", NULL));
    for_pseudo_accessplus.objname = strdup(intl_lookup("DispName", NULL));
    for_pseudo_accessplus.server_description = strdup(desc);

    dprintf(("", "Create initial servers"));

    args.type = OmniEnumerateMounts_Servers;

    if (flags & REGISTERED_0)
    {
        args.client_id = access_servers.client_id;
        err = SWIX(Omni_EnumerateMounts, &args, &args);
        if (err != NoError)
            return err;
        else
            dprintf(("", "Registered Access server successfully"));
    }

    if (flags & REGISTERED_1)
    {
        args.client_id = pseudo_accessplus.client_id;
        err = SWIX(Omni_EnumerateMounts, &args, &args);
        if (err != NoError)
            return err;
        else
            dprintf(("", "Registered Access+ server successfully"));
    }

    /* Pick up existing servers with the standard enumeration */

    return schedule(DO_ENUM_FREEWAY);
}

/*****************************************************************************/

_kernel_oserror *module_finalise(int fatal, int podule, void *pw)
{
    server *sp;
    struct authlist *ap;
    up_action *up;

    dprintf(("", "\nModule finalise - hidden error is %s", flags & HIDDEN_ERROR ? "YES" : "NO"));

    {
        DISABLE_IRQS;

        if (flags & CALLBACK_SCHEDULED)
        {
            _swix(OS_RemoveCallBack, _INR(0,1), bounce_cb, module_private_word);

            flags &= ~CALLBACK_SCHEDULED;
        }

        RESTORE_IRQS;
    }

    if (state == RUNNING)
    {
        state = DYING;

        for (sp = access_servers.servers; sp != NULL; sp = sp->next)
            (void) shutdown_server(sp, SHUT_DISMOUNT | SHUT_CLOSEDIR);

        release_from_list( connect_list );
    }

    free_server_list(access_servers.servers);

    free(for_pseudo_accessplus.objname);
    free(for_pseudo_accessplus.server_description);

    for (ap = auths; ap != NULL; )
    {
        struct authlist *tp = ap->next;
        free(ap->users_name);
        free(ap);
        ap = tp;
    }

    for (up = pending_actions; up != NULL; )
    {
        struct up_action *tp = up->next;
        free(up->objname);
        free(up);
        up = tp;
    }

    dprintf(("", "Post final - freeing servers"));
    UNUSED(pw);
    UNUSED(podule);
    UNUSED(fatal);

    return NULL;
}

/*****************************************************************************
 *
 * Schedule the happening of various actions. Currently, these happen from
 * within a callback.
 * [The use of a callback gives us more stack, makes actions occur when the
 * OS is not currently threaded and schedules actions so that presence/
 * absence of SWIs, etc is more defined.]
 */

static Error schedule (uint reasons)
{
    Error ep = NoError;

    DISABLE_IRQS;

    if ( flags & CALLBACK_SCHEDULED )
    {
        flags |= reasons;
    }
    else
    {
        if (_swix(OS_AddCallBack, _INR(0,1),
                  bounce_cb, module_private_word) == NoError)
        {
            flags |= reasons | CALLBACK_SCHEDULED;
        }
        else
        {
            dprintf(("", "\nFAILED TO SCHEDULE 0X%X\n", reasons));
            flags |= HIDDEN_ERROR;
        }
    }

    RESTORE_IRQS;

    return ep;
}

/*****************************************************************************
 *
 * UPcall handler
 *
 * We are not notified of the authentication value associated with authenticated
 * objects via the UpCall (an Acorn design bug, IMHO), so any change on what
 * appears to be an authenticated object (has an '@@' character in the name!)
 * triggers an enumeration of the Access+ object list in it's entirety. This
 * is potentially grossly inefficient (verging on N*N overhead), but there's not
 * much we can do.
 */


int  upcall_handler(_kernel_swi_regs *regs, void *pw)
{
    up_action *up;
    enum
    {
        CLAIM,
        DONT_CLAIM
    };

    dprintf(("", "%s upcall for %s of type %d (r1=%x, r6=%x, r7=%x",
        act_names[regs->r[1]],
        (char *) regs->r[3],
        regs->r[2],
        regs->r[1],
        regs->r[6],
        regs->r[7]
       ));

    if ( (FreewayType) regs->r[2] == FREEOBJ_DISCS && (flags & DONT_QUEUE_ACTIONS) == 0 )
    {
        up = make_up_action((uint) regs->r[1],
                            (char *) regs->r[3],
                            * (FreewayDescrip *) regs->r[5],
                            (IPaddress) regs->r[6],
                            NO_AUTHENT );

        if ( up != NULL )
        {
            DISABLE_IRQS;

                /* Add at head for ease - means must reverse list later */
                up->next = pending_actions;
                pending_actions = up;
                schedule(DO_UPCALL_ACTION);
            RESTORE_IRQS;
        }
        else
        {
            flag_set(HIDDEN_ERROR);
        }
    }
    UNUSED(pw);
    
    return DONT_CLAIM;
}

/*****************************************************************************
 *
 * Attempt to connect to the necessary modules and go active.
 */

_kernel_oserror *callback_handler(_kernel_swi_regs *regs, void *pw)
{
    Error err;

    flag_clr(CALLBACK_SCHEDULED);

    if (flag_clr(DO_CONNECT) & DO_CONNECT)
    {
        if ( necessary_modules_present(1) && (flags & MUST_SEE) == MUST_SEE )
        {
            if ( (err = claim_from_list( connect_list )) == NoError )
            {
                if ( (err = create_initial_servers()) == NoError )
                {
                    state = RUNNING;
                    dprintf(("", "State now running\n"));
                    flag_clr(DONT_QUEUE_ACTIONS | ACTIONS_SUSPENDED);
                }
                else
                {
                    dprintf(("", "Error creating initial servers\n"));
                    note_error(err);
                    release_from_list( connect_list );
                    flag_set(HIDDEN_ERROR);
                }
            }
            else
            {
                note_error(err);
                flag_set(HIDDEN_ERROR);
            }
        }
    }


    if ( (flags & ACTIONS_SUSPENDED) == 0 && (flag_clr(DO_ENUM_FREEWAY) & DO_ENUM_FREEWAY) != 0 )
    {
        enumerate_access();

        if (flags & HAVE_AUTHENTICATION)
            enumerate_accessplus();
    }


    if (! (flags & ACTIONS_SUSPENDED) && (flag_clr(DO_UPCALL_ACTION) & DO_UPCALL_ACTION) )
    {
        perform_upcall_actions();
    }


    /* if (flag_clr(DO_DISCONNECT) & DO_DISCONNECT)
    {
        commit_suicide();
    } */
    UNUSED(pw);
    UNUSED(regs);
    
    return NULL;
}

/*****************************************************************************/

extern _kernel_oserror *module_initialise(const char *cmd_tail, int pbase, void *pw)
{
    debug_initialise ("", "OmniAccess", NULL);
    debug_set_options (0, 0, 0);
    debug_output_device (TML_OUTPUT);

    flags = DONT_QUEUE_ACTIONS | ACTIONS_SUSPENDED;
    state = WAITING;
    module_private_word = (int) pw;

    /* Make circular refs - last bit must be runtime initd! */


    for_pseudo_accessplus.context = &pseudo_accessplus;
    pseudo_accessplus.servers = &for_pseudo_accessplus;

    if (necessary_modules_present(0))
    {
        /* Assume present before us, so immediately usable */

        flags |= MUST_SEE;
    }

    dprintf(("", "OmniClient Access+ Client loaded\n"));

#ifdef PARANOID
    dprintf(("", "Paranoia code is active"));
#endif
    UNUSED(pbase);
    UNUSED(cmd_tail);

    return schedule(DO_CONNECT);
}


/***************************************************************************/

#if 0
/* For each registered authenticated FreeWay interest, if there are no */
/* longer any servers using it, deregister the interest. */

static void check_authenticated_interests(void)
{
        server *sp;
        struct authlist *ap, **app;

        for (ap = auths; ap != NULL; ap = ap->next)
                ap->used = 0;

        for (sp = access_servers.servers; sp != NULL; sp = sp->next)
        {
                if ( (sp->flags & SERVER_ACCESSPLUS) == 0 )
                        continue;
                /* Might not be entirely correct - could we have an */
                /* authenticated mount that we choose to hide?      */
                if ( (sp->flags & (SERVER_GONE | SERVER_HIDDEN)) == 0 )
                        continue;
                ap = find_authentN(sp->authent, sp->objname, sp->at_offset);
                if (ap != NULL)
                        ap->used = 1;
        }

        for (app = &auths; (ap = *app) != NULL; )
        {
                if (ap->used == 0)
                {
                        *app = ap->next;
                        deregister_authenticated(ap);
                        free(ap);
                }
                else
                {
                        app = &ap->next;
                }
        }
}
#endif


/* deregister interest in all currently known authentications */

static _kernel_oserror * deregister_swi(_kernel_swi_regs *regs)
{
  struct authlist *auth;
  uint oldflags = flag_set(ACTIONS_SUSPENDED);

  for (auth = auths; auth; )
  {
    struct authlist *next = auth->next;
    deregister_authenticated(auth);
    free(auth);
    auth = next;
  }
  auths = NULL;
  /* This is dubious - want counter and only have latch */

  if ( (oldflags & ACTIONS_SUSPENDED) == 0)
      flag_clr(ACTIONS_SUSPENDED);
  UNUSED(regs);

  return NoError;
}


/*****************************************************************************
 *
 * Perform the Omni actions. Somewhat blunt approach to implementation.
 * Given the context (client_id / swi number) we're operating in via the
 * orp parameter.
 */

static _kernel_oserror * normal_swi(uint swinum, _kernel_swi_regs *rp, omnireg *orp)
{
    Error err = NoError;
    server *sp;

    gerr = NoError;

    switch (rp->r[0])
    {
        case OmniOp_Mount:
            if ((flags & LOST_FREEWAY) || (flags & LOST_SHAREFS))
            {
               err = ENOSERVER;
               rp->r[1] = 0;
               break;
            }
            {
                args_OmniOpMount *args = (args_OmniOpMount *) rp;
                char *name = args->u.server;

                sp = server_from_fullname(orp->servers, name);
                dprintf(("", "OmniOp_Mount: server name '%s'", name));
                switch (swinum)
                {
                    /* Access: */

                    case 0: /* Access */
                        if (sp == NULL)
                        {
                            claim_gbuf();

                            dprintf(("", "Going ahunting for the server"));

                            sharefsify(NULL, name);

                            err = _swix(OS_File, _INR(0,1), OSFile_ReadNoPath, gbuf);

                            release_gbuf();

                            if (err == NoError)
                            {
                                /* Mount looks like it is available - try tickling */
                                /* things into it existing suitably for us */

                                uint oldflags = flag_set(ACTIONS_SUSPENDED);

                                dprintf(("", "Forcing enumeration and upcall processing"));

                                enumerate_access();
                                if (flags & HAVE_AUTHENTICATION)
                                    enumerate_accessplus();

                                perform_upcall_actions();

                                dprintf(("", "Forced enums - hunting again"));

                                sp = server_from_fullname(orp->servers, name);

                                if (sp == NULL)
                                    err = ENOSUCHSERVER(name);

                                /* This is dubious - want counter and only have latch */

                                if ( (oldflags & ACTIONS_SUSPENDED) == 0)
                                    flag_clr(ACTIONS_SUSPENDED);
                            }
                            else
                            {
                                dprintf(("", "Got error hunting: %s", err->errmess));
                            }
                        }

                        if (sp != NULL && err == NoError)
                        {
                            if ( (sp->flags & SERVER_MOUNTED) == 0)
                            {
                                sp->flags |= SERVER_MOUNTED;
                                dprintf(("", "Mounted it"));
                            }
                            else
                            {
                                dprintf(("", "It was already mounted"));
                                err = ECONNECTED;
                                sp = NULL;
                            }
                        }
                	if (err != NoError)
                	    sp = NULL;
                	args->u.mount_id = sp;                       /* NULL or not*/
                        break;


                    case 1: /* Access+ Pseudo Server */
                        {
                            uint oldflags = flag_set(ACTIONS_SUSPENDED);
                            /* 25/5/95: Borris - permit empty password */
                            FreewayAuthent auth = args->password == NULL ? 0
                                           : password_to_authent(args->password);
                            struct authlist *ap;

                            if (args->u.server == NULL || strlen(args->u.server) == 0)
                            {
                                char *cp = args->u.server;
                                if (cp == NULL)
                                    cp = "";
                                err = ENOSUCHSERVER(cp);
                            }
#if 0
                            else if (args->password == NULL||strlen(args->password) == 0)
                            {
                                err = EPASSWD;
                            }
#endif
                            else if ( (ap = stash_authent(auth, args->u.server)) == NULL )
                            {
                                dprintf(("", "Stashing authentication key failed"));
                                err = ENOMEM;
                            }
                            else
                            {
                                /*int vis = 0, oldvis = visible_servers();*/

                                dprintf(("", "Access+ login with name %s, password %s and authent %x",
                                    args->u.server, args->password, auth));

                                enumerate_access();
                                enumerate_accessplus();
                                perform_upcall_actions();
#if 0
                                vis = visible_servers();

                                if (vis == oldvis)
                                    err = EPASSWD;
#endif
                                dprintf(("", "Forced enumeration of Access+"));
                            }

                            /* This is dubious - want counter and only have latch */

                            if ( (oldflags & ACTIONS_SUSPENDED) == 0)
                                flag_clr(ACTIONS_SUSPENDED);

                            /* Indicate want connection window closed */
                            if (err == NoError)
                                sp = access_servers.servers;
                        }

			/* 17-01-97: NAS: Correct return values to close window,
			 * since we don't know for many seconds if the auth login is valid
			 * or not, we always say "yea" unless an error.
			 */
                	if (err == NoError) args->u.mount_id = (void *) 1;
                	  else args->u.mount_id = 0;
                        break;
                }
            }
            break;


        case OmniOp_Dismount:
            if ((flags & LOST_FREEWAY) || (flags & LOST_SHAREFS))
            {
               err = ENOSERVER;
               break;
            }
            {
                args_OmniOpDismount *args = (args_OmniOpDismount *) rp;

                err = shutdown_server(args->mount_id, SHUT_DISMOUNT | SHUT_CLOSEDIR);
                /*check_authenticated_interests();*/
            }
            break;


        case OmniOp_EnumerateServers:
            if ((flags & LOST_FREEWAY) || (flags & LOST_SHAREFS))
            {
               rp->r[3] = NULL;
               break;
            }
            {
                args_OmniOpEnumerateServers *args = (args_OmniOpEnumerateServers *) rp;
                register server *sp = args->server_id;
                uint x;
                register char *cp;

                dprintf(("", "OmniOp_EnumerateServers: %s", orp->fs_name));

                if (sp == NULL)
                {
                    START_ENUMERATION;
                    ripple_any_changes();
                    sp = orp->servers;
                }

                while (1)
                {
                    if (sp == NULL)
                    {
                        args->server_id = NULL;
                        DONE_ENUMERATION;
                        remove_dead_servers();
                        break;
                    }

                    if (sp->flags & SERVER_HIDDEN)
                    {
                        sp = sp->next;
                        continue;
                    }

                    if ( (x = bytes_to_enum_server(sp)) > args->size)
                    {
                        args->server_id = sp;
                        break;
                    }

                    dprintf(("", "Enumerating server %s:%x", sp->server_fullname, sp->authent));

                    cp = args->buffer;
                    ((server **) cp)[0] = sp;
                    cp += sizeof(server *);
                    strcpy(cp, sp->server_shortname);
                    cp += strlen(cp) + 1;
                    strcpy(cp, sp->server_fullname);
                    cp += strlen(cp) + 1;
                    strcpy(cp, sp->server_description);
                    args->size -= x;
                    args->buffer += x;
                    sp = sp->next;
                }
            }
            break;


        case OmniOp_EnumerateMountsOnServer:
            if ((flags & LOST_FREEWAY) || (flags & LOST_SHAREFS))
            {
               rp->r[3] = NULL;
               break;
            }
            {
                args_OmniOpEnumerateMounts *args = (args_OmniOpEnumerateMounts *) rp;
/*                server *sp = args->server_id;*/
/*                char *cp = args->server_name;*/
/*                uint x;*/

                dprintf(("", "OmniOp_EnumerateMountsOnServer:"));

                args->mount_id = NULL;      /* Always finished! */
#if 0
                if (sp == NULL
                && (cp == NULL || (sp = server_from_fullname(orp->servers, cp)) == NULL) )
                {
                    if (args->server_id == NULL || cp == NULL)
                        err = ENOSERVER;
                    else
                        err = ENOSUCHSERVER(cp);
                    break;
                }

                if ( (sp->flags & SERVER_HIDDEN) != 0
                || (sp->flags & SERVER_MOUNTED) == 0
                || (x = bytes_to_enum_mount (sp) ) > args->size )
                    break;

                dprintf(("", "OmniOp_EnumerateMountsOnServer on server %s", sp->server_fullname));

                cp = args->buffer;
                ((server **) cp)[0] = sp;
                cp += sizeof(server *);
                strcpy(cp, sp->mount_shortname);
                cp += strlen(cp) + 1;
                strcpy(cp, sp->mount_fullname);
                args->buffer += x;
                args->size -= x;
#endif
            }
            break;


        case OmniOp_EnumerateActiveMounts:
            dprintf(("", "OmniOp_EnumerateActiveMounts"));
            if ((flags & LOST_FREEWAY) || (flags & LOST_SHAREFS))
            {
               rp->r[3] = NULL;
               break;
            }
            {
                args_OmniOpEnumerateActiveMounts *args = (args_OmniOpEnumerateActiveMounts *) rp;
                server *sp = args->mount_id;
                char *cp;
                uint x;

                if (sp == NULL)
                {
                    START_ENUMERATION;
                    ripple_any_changes();
                    sp = orp->servers;
                }

                while (1)
                {
                    if (sp == NULL)
                    {
                        args->mount_id = NULL;
                        DONE_ENUMERATION;
                        remove_dead_servers();
                        break;
                    }

                    if ( (sp->flags & SERVER_HIDDEN) != 0 || (sp->flags & SERVER_MOUNTED) == 0 )
                    {
                        sp = sp->next;
                        continue;
                    }

                    if ( (x = bytes_to_enum_active_mount (sp) ) > args->size )
                    {
                        dprintf(("", "More room needed for %s", sp->objname));
                        args->mount_id = sp;
                        break;
                    }

                    dprintf(("", "Enumerating active mount %s:%x", sp->mount_fullname, sp->authent));

                    cp = args->buffer;
                    ((server **) cp)[0] = sp;
                    cp += sizeof(server *);
                    ((server **) cp)[0] = sp;
                    cp += sizeof(server *);
                    strcpy(cp, sp->mount_mountname);
                    args->buffer += x;
                    args->size -= x;

                    sp = sp->next;
                }
            }
            dprintf(("", "Finished enumerating active mounts\n"));

            break;


        case OmniOp_OpenRoot:
        case OmniOp_OpenUserRoot:
            dprintf(("", "OmniOp_Open(User)Root"));
            if ((flags & LOST_FREEWAY) || (flags & LOST_SHAREFS))
            {
                err = ENOSERVER;
                break;
            }
            {
                args_OmniOpOpenRoot *args = (args_OmniOpOpenRoot *) rp;
                server *sp = args->mount_id;

                claim_gbuf();

                sharefsify("filer_opendir", sp->objname);
                err = mycli(gbuf);

                release_gbuf();
            }
            break;


        case OmniOp_GetActiveMountInfo:
            dprintf(("", "OmniOp_GetActiveMountInfo"));
            if ((flags & LOST_FREEWAY) || (flags & LOST_SHAREFS))
            {
                err = ENOSERVER;
                break;
            }
            {
                args_OmniOpGetActiveMountInfo *args = (args_OmniOpGetActiveMountInfo *) rp;
                server *sp = args->u.mount_id;

                if (sp == NULL)
                {
                    err = ENOSERVER;
                    break;
                }
                args->u.server = sp->server_fullname;
                args->user_id = NULL; /*user_name_from_authent(sp->authent);*/
                args->mount_name = sp->mount_mountname;
                args->mount_path = NULL;
                args->authenticator = NULL;
                args->server_id = sp;
            }
            break;


        case OmniOp_DomainLogout:
            dprintf(("", "OmniOp_DomainLogout"));
            deregister_swi(rp);
            break;

        case OmniOp_Free:
        case OmniOp_GetInactiveMountInfo:
        case OmniOp_CreatePrintJob:
        case OmniOp_SendPrintJobData:
        case OmniOp_EndPrintJob:
        case OmniOp_AbortPrintJob:
        case OmniOp_GetPrintJobInfo:
        case OmniOp_ClearPrintJob:
        case OmniOp_EnumeratePrinters:
        default:
            err = EBADCALL;
            break;
    }

    note_error(err);

    return err;
}

/*****************************************************************************
 *
 * SWI handler.
 *
 */

extern _kernel_oserror *swi_handler(int swinum, _kernel_swi_regs *regs, void *pw)
{
#ifdef DEBUG
    static char *opnames[] =
    {
        "Mount",
        "Dismount",
        "Free",
        "Enumerate servers",
        "Enumerate mounts on server",
        "Enumerate active mounts",
        "Open root",
        "Open user root",
        "Get inactive mount info",
        "Get active mount info",
        "Create print job",
        "Send print job data",
        "End print job",
        "Abort print job",
        "Get print job info",
        "Clear print job",
        "Enumerate printers",
        "Domain logout"
    };

    dprintf(("", "\n\n      SWI %s\n\n", opnames[ regs->r[0] ] ));
#endif

    switch (swinum)
    {
        case 0:
            return normal_swi(swinum, regs, &access_servers);
            break;

        case 1:
            return normal_swi(swinum, regs, &pseudo_accessplus);
            break;
    }
    UNUSED(pw);

    return EBADCALL;
}

/*****************************************************************************
 *
 * Service call handler.
 *
 */

void service_call_handler(int sn, _kernel_swi_regs *r, void *pw)
{
    dprintf(("", "ServiceCall 0x%x", sn));

    switch (sn)
    {
        case Service_OmniAction:
            {
                args_OmniServiceCall *args = (args_OmniServiceCall *) r;

                switch (args->action)
                {
                    case Service_OmniAction_Starting:
                        flag_setclr(SEEN_OMNI, LOST_OMNI);
                        dprintf(("", "omniclient arrived"));
                        if (state == WAITING)
                        {
                            schedule(DO_CONNECT);
                        }
                        else
                        {
                            /* As per 0.996 and greater versions of the spec. */
                            (void) claim_omni();
                        }
                        break;

                    case Service_OmniAction_Died:
                        flag_setclr(LOST_OMNI, SEEN_OMNI | DO_CONNECT);
                        dprintf(("", "omniclient gone"));
                        commit_suicide();
                        break;

                    default:                         /* Unexpected - ignore*/
                        dprintf(("", "Unknown omni service action %x", args->action));
                        break;
                }
            }
            break;

        case Service_ResourceFSStarting:
            /* Reregister with ResourceFS */
            (*(void (*)(void *, void *, void *, void *))r->r[2])(Resources(), 0, 0, (void *)r->r[3]);
            break;

        case Service_FreewayStarting:
            flag_setclr(SEEN_FREEWAY, LOST_FREEWAY);
            dprintf(("", "freeway arrived"));
            if (state == WAITING)
            {
                schedule(DO_CONNECT);
            }
            break;


        case Service_FreewayTerminating:
            flag_setclr(LOST_FREEWAY, SEEN_FREEWAY | DO_CONNECT);
            dprintf(("", "freeway gone"));
            release_sharefs();
            release_freeway();
            break;

        case Service_ShareDStarting:
            flag_setclr(SEEN_SHAREFS, LOST_SHAREFS | DO_CONNECT);
            dprintf(("", "sharefs arrived"));
            if (state == WAITING)
            {
                schedule(DO_CONNECT);
            }
            break;

        case Service_ShareDTerminating:
            flag_setclr(LOST_SHAREFS, SEEN_SHAREFS | DO_CONNECT);
            dprintf(("", "sharefs gone"));
            release_sharefs();
            release_freeway();
            break;

        default:                    /* Unexpected - ignore */
            break;
    }
    UNUSED(pw);
}

/*****************************************************************************/

/* eof omniacc.c */

@


1.2
log
@  * Further rationalisations to fit into our build system.
Detail:
  * Altered to use auto-generated or centralised declarations, constants etc.
    whereever possible.
  * Altered to use some library routines instead of local equivalents.
  * Debug build uses DebugLib.
  * Modified to use SrcCommit.
Admin:
  * Removed entire contents of hdr directory; macros now obtained from HdrSrc.
  * Contains assembler code that has 32 bit ARM 'issues' (TEQPs).
  * Requires AsmUtils 0.02 or later.
  * Both builds compiled.

Version 0.15. Tagged as 'Access-0_15'
@
text
@d53 2
a54 1
#include <stdarg.h>
d56 6
a61 2
#include <kernel.h>
#include <swis.h>
d63 1
a63 3
#include <Global/RISCOS.h>
#include <Global/Services.h>
#include <Global/Upcall.h>
d65 1
a65 1
#include <AsmUtils/irqs.h>
d67 1
a67 3
#include <DebugLib/DebugLib.h>

#include "modhdr.h"
a70 1
#include "VersionNum"
d72 4
a85 2
/* static Error claim_timer(void);
static void release_timer(void); */
d102 1
a107 1
/*    {   claim_timer,                 release_timer              },*/
d115 1
d120 1
a120 1
volatile uint flags;
d122 1
a122 1
extern char *developed = "\n Developed by ANT Limited <sales@@ant.co.uk> \n";
d134 1
a134 1
server for_pseudo_accessplus =
d143 1
a143 1
    "Pseudo Access+ Object",
d149 1
a149 1
    "Logon Network\nRISC OS\n",
d159 1
a159 1
omnireg access_servers =
d162 5
a166 7
    OMNI_SUPPORT_FILING  | OMNI_NOTREQUIRE_MOUNT,
    "04a900",
    "Acorn Access",
    "Acorn Access\n Acorn Computers Ltd, 1997\n" Module_FullVersion " " Module_Date,
    0u,
    "Share",
    NULL
d171 1
a171 1
omnireg pseudo_accessplus =
d174 8
a181 14
        OMNI_PSEUDO_SERVER |
        OMNI_SUPPORT_FILING |
        /*OMNI_REQUIRE_USERID |*/
        OMNI_REQUIRE_PASSWORD |      /* 25/5/95: borris: permit empty password */
        OMNI_REQUIRE_AUTHENT  |      /* 11/6/96: NAS: request 'domain name' v1.01 spec */
        OMNI_NOTREQUIRE_MOUNT
/*        (ACORN * OMNI_REQUIRE_MOUNTPATH)*/
    ,
    "04a901",
    "Acorn Access+",
    "Acorn Access+\n Acorn Computers Ltd, 1997\n" Module_FullVersion " " Module_Date,
    0u,
    "Share+",
    NULL
d210 50
d294 1
a294 3
#ifdef DEBUG

static Error mycli(char *str)
d300 1
a300 1
    err = mycli_(str);
a309 6
#else

#define mycli   mycli_

#endif

d346 16
d378 1
a378 1
static char * strdup (char *str)
d398 1
a398 1
static char * strndup (char *str, int n)
d419 1
a419 1
static int strieq(char *a, char *b)
d438 1
a438 1
static int strieqn(char *a, char *b, int len)
d659 2
a660 1
    sprintf(cp, "%d.%d.%d.%d\nRISC OS", cp2[0], cp2[1], cp2[2], cp2[3]);
a1102 38
/* static Error claim_timer(void)
{
   _kernel_swi_regs r;

   r.r[0] = TickerV;
   r.r[1] = (int) timer_veneer;
   r.r[2] = (int) module_private_word;

   dprintf(("", "Claiming timer"));

   return SWIX(OS_Claim, &r, &r);
} */

/*****************************************************************************
 *
 *
 */

/* static void release_timer(void)
{
   _kernel_swi_regs r;

   r.r[0] = TickerV;
   r.r[1] = (int) timer_veneer;
   r.r[2] = (int) module_private_word;

   dprintf(("", "Releasing timer"));

   (void) SWIX(OS_Release, &r, &r);

   return;
} */

/*****************************************************************************
 *
 *
 */

a1104 6
   _kernel_swi_regs r;

   r.r[0] = UpCallV;
   r.r[1] = (int) upcall_veneer;
   r.r[2] = (int) module_private_word;

d1107 1
a1107 1
   return SWIX(OS_Claim, &r, &r);
a1116 6
   _kernel_swi_regs r;

   r.r[0] = UpCallV;
   r.r[1] = (int) upcall_veneer;
   r.r[2] = (int) module_private_word;

d1119 1
a1119 3
   (void) SWIX(OS_Release, &r, &r);

   return;
d1157 1
a1157 1
static Error claim_omni2(omnireg *orp)
d1161 2
d1164 7
d1174 2
a1175 2
    args.client_name = orp->client_name;
    args.client_description = orp->client_description;
d1192 3
a1194 1
    if ( ( err = claim_omni2(&access_servers) ) == NULL )
d1202 1
a1202 1
    if ( ( err = claim_omni2(&pseudo_accessplus) ) == NULL )
a1341 1
        _kernel_swi_regs r;
d1344 1
a1344 4
        int n;

        r.r[0] = 18;        /* Lookup module name */
        r.r[1] = (int) table[i];
d1346 2
a1347 1
        ep = _kernel_swi(XOS_Bit + OS_Module, &r, &r);
d1378 1
a1378 1
        n = r.r[3];
d1380 1
a1380 1
        n += ((int *)n) [0x14 / sizeof(int) ];
d1421 1
a1421 1
    Error err;
d1933 3
d1937 3
a1939 1
    args.type = 0;                  /* Enumerate servers/mounts */
d1943 2
a1971 7
_kernel_oserror *timer_handler (_kernel_swi_regs *regs, void *pw)
{
    return NULL;
}

/*****************************************************************************/

d1985 1
a1985 5
            _kernel_swi_regs r;
            r.r[0] = (int) /* callback_veneer */ bounce_cb;
            r.r[1] = module_private_word;

            (void) _kernel_swi(XOS_Bit + OS_RemoveCallBack, &r, &r);
d2005 3
d2025 3
a2042 1
    _kernel_swi_regs r;
d2053 2
a2054 4
        r.r[0] = (int) /* callback_veneer */ bounce_cb;
        r.r[1] = module_private_word;

        if (_kernel_swi(XOS_Bit + OS_AddCallBack, &r, &r) == NoError)
d2074 1
a2074 1
 * We are not notified of the authentication value associated with autheneticated
d2124 2
a2125 1

d2188 3
a2190 1

d2224 2
d2294 1
a2325 1
                _kernel_swi_regs r;
d2341 2
a2342 3
                            r.r[0] = 17;
                            r.r[1] = (int) gbuf;
                            err = SWIX(OS_File, &r, &r);
d2542 1
a2542 1
        case OmniOp_EnumerateMounts:
d2554 1
a2554 1
                dprintf(("", "OmniOp_EnumerateMounts:"));
d2573 1
a2573 1
                dprintf(("", "OmniOp_EnumerateMounts on server %s", sp->server_fullname));
d2698 2
a2699 2
        case OmniOp_Reset:
            dprintf(("", "OmniOp_Reset"));
d2703 1
a2703 1
        case OmniOp_FreeSpace:
d2706 1
a2706 1
        case OmniOp_SendPrintJob:
d2710 1
a2710 1
        case OmniOp_ClearPrintJobs:
a2725 2
 * We support two SWIs: one for OmniClient access and the other for DCI4
 * statistic access (the latter is not yet implemented).
d2737 1
a2737 1
        "Enumerate mounts",
d2744 1
a2744 1
        "Send print data",
d2750 1
a2750 1
        "Reset"
a2762 1
/*            return normal_swi(swinum, regs, &access_servers);*/
a2764 4

	/* case 2:
	    return deregister_swi(regs);
	    break; */
d2766 1
d2771 5
a2775 1
/*****************************************************************************/
d2789 1
a2789 1
                    case 0:         /* OmniClient module has started */
d2803 1
a2803 1
                    case 1:                /* OmniClient module is/has died*/
d2816 5
d2857 1
@


1.1
log
@Initial revision
@
text
@d55 12
a66 2
#include "kernel.h"
#include "swis.h"
d70 1
d109 1
a109 1
#if DEBUG
d158 1
a158 1
    SWI_BASE + 0,
d162 1
a162 1
    "Acorn Access\n Acorn Computers Ltd, 1997\n" VERSION " (17-Jan-97)",
d172 1
a172 1
    SWI_BASE + 1,
d183 1
a183 1
    "Acorn Access+\n Acorn Computers Ltd, 1997\n" VERSION " (17-Jan-97)",
d199 1
a199 25
#if DEBUG

FILE *debugfile;

static void debugrtn(char *msg, ...)
{
    static char buffer[1024];

    va_list arg;
    va_start(arg, msg);

/*    sprintf(buffer, "%08x: ", *(int*)0x10c);*/
    buffer[0] = 0;

    vsprintf(buffer + strlen(buffer), msg, arg);

    fputs(buffer, debugfile);

    sprintf(buffer, "\n");

    fputs(buffer, debugfile);
    fflush(debugfile);

    va_end(arg);
}
d206 1
a206 1
    dbg(("Error %s\n", err->errmess));
a214 112
/*****************************************************************************
 *
 */


#if DEBUG
#if 0 
static void dump_state(char *ctx)
{
    server *sp;
    uint f = flags;

    dbg(("\nState dump: %s\n", ctx));

    dbg(("Flags: %x\n", f));

    if (f & HAVE_AUTHENTICATION)
        dbg(("HAVE AUTHENTICATION"));

    if (f & ACTIONS_SUSPENDED)
        dbg(("ACTIONS SUSPENDED"));

    if (f & CALLBACK_SCHEDULED)
        dbg(("CALLBACK SCHEDULED"));

    if (f & DONT_QUEUE_ACTIONS)
        dbg(("DONT QUEUE ACTIONS"));

    if (f & HIDDEN_ERROR)
        dbg(("HIDDEN ERROR"));

    if (f & LOST_OMNI)
        dbg(("LOST OMNI"));

    if (f & LOST_FREEWAY)
        dbg(("LOST FREEWAY"));

    if (f & LOST_SHAREFS)
        dbg(("LOST SHAREFS"));

    if (f & SEEN_OMNI)
        dbg(("SEEN OMNI"));

    if (f & SEEN_FREEWAY)
        dbg(("SEEN FREEWAY"));

    if (f & SEEN_SHAREFS)
        dbg(("SEEN SHAREFS"));

    if (f & REGISTERED_0)
        dbg(("REGISTERED 0"));

    if (f & REGISTERED_1)
        dbg(("REGISTERED 1"));

    if (f & REGISTERED_2)
        dbg(("REGISTERED 2"));

    /* if (f & DO_DISCONNECT)
        dbg(("DO DISCONNECT")); */

    if (f & DO_CONNECT)
        dbg(("DO CONNECT"));

    if (f & DO_ENUM_FREEWAY)
        dbg(("DO ENUM FREEWAY"));

    if (f & DO_UPCALL_ACTION)
        dbg(("DO UPCALL ACTION"));


    dbg(("Servers:"));

    for (sp = access_servers.servers; sp != NULL; sp = sp->next)
    {
/*
        dbg(("Server %p, next %p, context %p, descrip %x, flags %x",
            sp,
            sp->next,
            sp->context,
            sp->descriptor,
            sp->flags));
*/
        if (sp->flags & SERVER_GONE)
            dbg(("SERVER GONE"));

        if (sp->flags & SERVER_HIDDEN)
            dbg(("SERVER HIDDEN"));

        if (sp->flags & SERVER_MOUNTED)
            dbg(("SERVER MOUNTED"));

        if (sp->flags & SERVER_FLAG)
            dbg(("SERVER FLAG"));

        if (sp->flags & SERVER_PSEUDO)
            dbg(("SERVER PSEUDO"));

        if (sp->flags & SERVER_ACCESSPLUS)
            dbg(("SERVER ACCESSPLUS"));

        dbg(("    objname %s, authent %x, addr %x", sp->objname, sp->authent, sp->address));
/*
        dbg(("short %s, full %s, description %s", sp->server_shortname, sp->server_fullname, sp->server_description));
        dbg(("short %s, full %s, mount name  %s\n", sp->mount_shortname, sp->mount_fullname, sp->mount_mountname));
*/
    }

    dbg(("*****************************************************************************"));
}
#endif
#endif
d220 1
a220 1
#if PARANOID
d249 1
a249 1
#if DEBUG
d255 1
a255 1
    dbg(("CLI: %s", str));
d261 1
a261 1
        dbg(("Got error %s", err->errmess));
d317 1
a317 1
    dbg(("Commiting suicide"));
d417 1
a417 1
    /*dbg(("Searching for %*s:%x in authlist", len, mntpre, auth));*/
d447 1
a447 1
        dbg(("Found authlist entry for %s:%x in authlist", ap->users_name, ap->authent));
d457 1
a457 1
        dbg(("Ran out of memory creating authlist entry"));
d470 1
a470 1
    dbg(("Registering interest in authenticated objects for %s:%x", mntpre, auth));
d478 1
a478 1
        dbg(("Error %s when trying to register interest", err->errmess));
a500 9
#if ANT

    static int WARNING_the_ANT_option_isnt_properly_tried_yet;

    /* We never apply authentication restrictions on object display */
    rc = 1;

#else

a518 10
#endif

#if 0
    dbg(("Consider mountname on %s:%x gives %s",
        sp->objname,
        sp->authent,
        rc ? "YES" : "NO"
       ));
#endif

d649 1
a649 1
#if PARANOID
d663 1
a663 1
               dbg(("Global buffer claim error\n"));
d682 1
a682 1
#if PARANOID
d694 1
a694 1
        dbg(("Global buffer free error\n"));
d764 1
a764 1
        dbg(("Removing dead server %s:%x", sp->objname, sp->authent));
d777 1
a777 1
                dbg(("Removing dead server %s:%x", sp->objname, sp->authent));
d845 1
a845 1
    dbg(("Create server for %s", up->objname));
d887 1
a887 1
            /*dbg(("Triggering enumeration due to creation of '@@' server with no authent"));*/
d942 1
a942 1
        dbg(("Added up action %s for %s:%x", act_names[up->action], up->objname, up->authent));
d981 1
a981 1
    dbg(("claiming freeway"));
d1004 1
a1004 1
    dbg(("Releasing freeway interest in %s:%x", ap->users_name, ap->authent));
d1008 1
a1008 1
#if PARANOID
d1010 1
a1010 1
        dbg(("Error %s when deregistering freeway interest", err->errmess));
d1023 1
a1023 1
    dbg(("Releasing all Freeway registrations"));
d1031 1
a1031 1
#if PARANOID
d1033 1
a1033 1
        dbg(("Error %s when de-registering unauthenticated interest", err->errmess));
d1057 1
a1057 1
   dbg(("Claiming timer"));
d1075 1
a1075 1
   dbg(("Releasing timer"));
d1091 1
a1091 1
   r.r[0] = UpcallV;
d1095 1
a1095 1
   dbg(("Claiming upcalls"));
d1109 1
a1109 1
   r.r[0] = UpcallV;
d1113 1
a1113 1
   dbg(("Releasing Upcalls"));
d1127 1
a1127 1
    dbg(("Claiming ShareFS - no actions"));
d1139 1
a1139 1
    dbg(("Releasing ShareFS"));
d1179 1
a1179 1
    dbg(("Claiming OmniClient"));
d1209 1
a1209 1
    dbg(("Releasing OmniClient"));
d1241 1
a1241 1
    dbg(("Releasing from list"));
d1255 1
a1255 1
    dbg(("Released from list"));
d1273 1
a1273 1
    dbg(("Starting to claim from list"));
d1284 1
a1284 1
        dbg(("Successfully claimed from list\n"));
d1289 1
a1289 1
    dbg(("Failed to claim from list - reversing claims"));
d1298 1
a1298 1
    dbg(("Finished reversing claims - idle state restored"));
d1341 1
a1341 1
            dbg(("Module %s not present yet", table[i]));
d1374 1
a1374 1
        dbg(("Checking modules: %s", cp));
d1385 1
a1385 1
        dbg(("Got version of %d", n));
d1394 1
a1394 1
    dbg(("All necessary modules present"));
d1418 1
a1418 1
        dbg(("OmniOp_Dismount server '%s', %x", sp->mount_fullname, flags));
d1443 1
a1443 1
          dbg(("Not mounted: %s", sp->objname));
d1470 1
a1470 1
    dbg(("Performing queued upcall actions"));
d1510 1
a1510 1
                        dbg(("Failed to create server for %s:%x", revd->objname, revd->authent));
d1524 1
a1524 1
                        dbg(("Added new object %s:%x", revd->objname, revd->authent));
d1529 1
a1529 1
                    dbg(("Already got object %s:%x - rescheduling as change", sp->objname, sp->authent));
d1542 1
a1542 1
                    dbg(("Object %s:%x not exist - force freeway enumeration", revd->objname, revd->authent));
d1557 1
a1557 1
                    dbg(("Freeway object departure/deletion %s:%x", sp->objname, sp->authent));
d1575 1
a1575 1
                            dbg(("Latched onto %x as authent value for %s", revd->authent, sp->objname));
d1586 1
a1586 1
                        dbg(("Change information: new %x, old %x", new, old));
d1594 1
a1594 1
                        dbg(("Causing server enum due to %s:%x", sp->objname, sp->authent));
d1599 1
a1599 1
                        dbg(("%s:%x - noted nothing significant in %x", sp->objname, sp->authent, new));
d1603 1
a1603 1
                    dbg(("Object %s:%x has changed but not found - force freeway enum", revd->objname, revd->authent));
d1699 1
a1699 1
#if PARANOID
d1701 1
a1701 1
            dbg(("Error %s when enumerating access", err->errmess));
d1708 1
a1708 1
            /*dbg(("Access enumeration found %s:%x", args.name_buffer, args.authent));*/
d1739 1
a1739 1
            dbg(("Server seems to have disappeared %s:%x", sp->objname, sp->authent));
d1800 1
a1800 1
        dbg(("Enumerating on authentication value of %s:%x", ap->users_name, ap->authent));
d1811 1
a1811 1
#if PARANOID
d1813 1
a1813 1
                dbg(("Error %s enumerating Access+", err->errmess));
d1818 1
a1818 1
                /*dbg(("Access+ enumeration found %s:%x", args.name_buffer, args.authent));*/
d1827 2
a1828 2
                    /*dbg(("Cancelled server flag on %s:%x", sp->objname, sp->authent));*/
#if PARANOID
d1830 1
a1830 1
                        dbg(("SWI has overridden %x with %x", ap->authent, args.authent));
d1833 1
a1833 1
                        dbg(("Auth %x appears to override %x for %s", ap->authent, sp->authent, sp->objname));
d1836 1
a1836 1
                        dbg(("%s:%x doesn't appear to be an authenticated object?", sp->objname, sp->authent));
d1840 1
a1840 1
#if PARANOID
d1842 1
a1842 1
                            dbg(("Server %s not hidden when would expect it to be", sp->objname));
d1844 1
a1844 1
                        dbg(("Now got authent %x for %s", ap->authent, sp->objname));
d1876 1
a1876 1
            dbg(("Server %s:%x seems to have disappeared", sp->objname, sp->authent));
d1926 1
a1926 1
    dbg(("Create initial servers"));
d1935 1
a1935 1
            dbg(("Registered Access server successfully"));
d1945 1
a1945 1
            dbg(("Registered Access+ server successfully"));
d1955 1
a1955 1
extern RETURNMETHOD timer_handler (_kernel_swi_regs *regs, void *pw)
d1957 1
a1957 1
    return VIAR14;
d1962 1
a1962 1
static void module_finalise(void)
d1968 1
a1968 1
    dbg(("\nModule finalise - hidden error is %s", flags & HIDDEN_ERROR ? "YES" : "NO"));
d2015 1
a2015 1
    dbg(("Post final - freeing servers"));
d2017 1
a2017 6
#if DEBUG
    fflush(debugfile);
    fclose(debugfile);
#endif

    return;
d2051 1
a2051 1
            dbg(("\nFAILED TO SCHEDULE 0X%X\n", reasons));
d2074 1
a2074 1
extern RETURNMETHOD upcall_handler(_kernel_swi_regs *regs, void *pw)
d2077 14
d2092 1
a2092 1
    if (regs->r[0] == UPCALL_FREEWAY)
d2094 19
a2112 31
        dbg(("%s upcall for %s of type %d (r1=%x, r6=%x, r7=%x",
            act_names[regs->r[1]],
            (char *) regs->r[3],
            regs->r[2],
            regs->r[1],
            regs->r[6],
            regs->r[7]
           ));

        if ( (FreewayType) regs->r[2] == FREEOBJ_DISCS && (flags & DONT_QUEUE_ACTIONS) == 0 )
        {
            up = make_up_action((uint) regs->r[1],
                                (char *) regs->r[3],
                                * (FreewayDescrip *) regs->r[5],
                                (IPaddress) regs->r[6],
                                NO_AUTHENT );

            if ( up != NULL )
            {
                DISABLE_IRQS;

                    /* Add at head for ease - means must reverse list later */
                    up->next = pending_actions;
                    pending_actions = up;
                    schedule(DO_UPCALL_ACTION);
                RESTORE_IRQS;
            }
            else
            {
                flag_set(HIDDEN_ERROR);
            }
d2116 1
a2116 1
    return VIAR14;
d2124 1
a2124 1
extern RETURNMETHOD callback_handler(_kernel_swi_regs *regs, void *pw)
d2139 1
a2139 1
                    dbg(("State now running\n"));
d2144 1
a2144 1
                    dbg(("Error creating initial servers\n"));
d2179 1
a2179 3
    /* Is this correct? MOVS or MOV ? */

    return VIAR14;
d2184 1
a2184 1
extern _kernel_oserror *module_initialise(char *cmd_tail, int pbase, void *pw)
d2186 3
a2188 10
#if DEBUG
    debugfile = fopen("<omni$dir>.!OmniAcc", "w"); /* 17-01-97 NAS from adfs::4.$. */

    if (debugfile == NULL)
    {
        fprintf(stderr, "Failed to open debug file!\n");
        return EINTERNAL;
    }

#endif
d2207 1
a2207 3
    atexit( &module_finalise );

    dbg(("OmniClient Access+ Client loaded\n"));
d2209 2
a2210 2
#if PARANOID
    dbg(("Paranoia code is active"));
d2314 1
a2314 1
                dbg(("OmniOp_Mount: server name '%s'", name));
d2324 1
a2324 1
                            dbg(("Going ahunting for the server"));
d2340 1
a2340 1
                                dbg(("Forcing enumeration and upcall processing"));
d2348 1
a2348 1
                                dbg(("Forced enums - hunting again"));
d2362 1
a2362 1
                                dbg(("Got error hunting: %s", err->errmess));
d2371 1
a2371 1
                                dbg(("Mounted it"));
d2375 1
a2375 1
                                dbg(("It was already mounted"));
d2409 1
a2409 1
                                dbg(("Stashing authentication key failed"));
d2416 1
a2416 1
                                dbg(("Access+ login with name %s, password %s and authent %x",
d2428 1
a2428 1
                                dbg(("Forced enumeration of Access+"));
d2440 1
a2440 1
                        
d2480 1
a2480 1
                dbg(("OmniOp_EnumerateServers: %s", orp->fs_name));
d2511 1
a2511 1
                    dbg(("Enumerating server %s:%x", sp->server_fullname, sp->authent));
d2541 1
a2541 1
                dbg(("OmniOp_EnumerateMounts:"));
d2560 1
a2560 1
                dbg(("OmniOp_EnumerateMounts on server %s", sp->server_fullname));
d2576 1
a2576 1
            dbg(("OmniOp_EnumerateActiveMounts"));
d2613 1
a2613 1
                        dbg(("More room needed for %s", sp->objname));
d2618 1
a2618 1
                    dbg(("Enumerating active mount %s:%x", sp->mount_fullname, sp->authent));
d2632 1
a2632 1
            dbg(("Finished enumerating active mounts\n"));
d2639 1
a2639 1
            dbg(("OmniOp_Open(User)Root"));
d2660 1
a2660 1
            dbg(("OmniOp_GetActiveMountInfo"));
d2686 1
a2686 1
            dbg(("OmniOp_Reset"));
d2717 1
a2717 1
extern _kernel_oserror *swi_handler(uint swinum, _kernel_swi_regs *regs, void *pw)
d2719 1
a2719 1
#if DEBUG
d2742 1
a2742 1
    dbg(("\n\n      SWI %s\n\n", opnames[ regs->r[0] ] ));
d2766 1
a2766 1
extern void service_call_handler(register int sn, _kernel_swi_regs *r)
d2768 1
a2768 1
    dbg(("ServiceCall 0x%x", sn));
d2780 1
a2780 1
                        dbg(("omniclient arrived"));
d2794 1
a2794 1
                        dbg(("omniclient gone"));
d2799 1
a2799 1
                        dbg(("Unknown omni service action %x", args->action));
d2807 1
a2807 1
            dbg(("freeway arrived"));
d2817 1
a2817 1
            dbg(("freeway gone"));
d2822 1
a2822 1
        case Service_ShareFSStarting:
d2824 1
a2824 1
            dbg(("sharefs arrived"));
d2831 1
a2831 1
        case Service_ShareFSTerminating:
d2833 1
a2833 1
            dbg(("sharefs gone"));
@


1.1.1.1
log
@  Initial import of OmniClient Access protocol into CVS.

Detail:
  Only build structure currently changed - sources unaltered.

Admin:
  Compiled.  Not tested.
@
text
@@

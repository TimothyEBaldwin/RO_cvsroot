head	1.5;
access;
symbols
	NetFiler-1_19:1.5
	NetFiler-1_18:1.4
	NetFiler-1_17:1.3
	NetFiler-1_16:1.2
	NetFiler-1_15:1.2
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.5
date	2016.09.11.09.50.00;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	7QglAyKtQE4s3Rlz;

1.4
date	2016.09.11.09.46.53;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	VaOPZAzSo4qp2Rlz;

1.3
date	2016.09.11.09.43.11;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	gUipW5QlWRk71Rlz;

1.2
date	99.12.07.20.36.33;	author blaughto;	state Exp;
branches;
next	1.1;

1.1
date	99.12.07.19.04.36;	author blaughto;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.12.07.19.04.36;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Internationalised
Add a Messages file, register this with the sprites from C (remove the assembler copy).
Internationalised the date in the Omni menu, and error strings from former MakeErrors.
Expanded the list of known machine types and look those up via Messages too.

Version 1.19. Tagged as 'NetFiler-1_19'
@
text
@/* Copyright 1999 Pace Micro Technology plc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Program:	Filer.c - core module routines
 *
 * Project:	NetFiler Omni project
 *
 * Author:	Nick Smith
 *              ANT Limited
 *              Cambridge
 *              Internet: nas@@ant.co.uk
 *
 * Date:	2 November 1994
 * Last Edited:	23 November 1994
 *
 * Copyright 1994 by ANT Limited
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "AsmUtils/rminfo.h"

#include "DebugLib/DebugLib.h"

#include "Desk/LinkList.h"
#include "Desk/SWI.h"

#include "Global/Services.h"
#include "Interface/OmniClient.h"

#include "NetFiler.h"
#include "Lists.h"
#include "NetFilerHdr.h"
#include "Net.h"
#include "Print.h"

static int		msg_struct[4];
static Desk_bool	client_running = Desk_bool_FALSE;	/* Desk_bool_TRUE if registered & running OK */
extern Desk_linklist_header	mount_anchor = {NULL, NULL};	/* List of active mount records */
extern Desk_linklist_header	mlist_anchor = {NULL, NULL};	/* List of network server records */
extern Desk_linklist_header	plist_anchor = {NULL, NULL};	/* List of network print records */
extern Desk_linklist_header	print_anchor = {NULL, NULL};	/* List of active print records */
extern Desk_bool		block_service = Desk_bool_FALSE;		/* Block out the service call? */

extern void suicide(char *Desk_module_title);
extern void *Resources(void); /* From ResGen */
static _kernel_oserror *omni_register(void);


/*  Clear out mlist struct from RMA.
 */
extern void mlist_clean(void)
{
  mlist_rec *mr = (mlist_rec *) mlist_anchor.next;
  while (mr)
  {
    mlist_rec *mr_tmp = (mlist_rec *) mr->header.next;
    MountDeleteList(mr);
    mr = mr_tmp;
  }
  Desk_LinkList_Init(&mlist_anchor);
}


/*  Clear out mount struct from RMA.
 */
extern void mount_clean(void)
{
  mount_rec *mr = (mount_rec *) mount_anchor.next;
  while (mr)
  {
    mount_rec *mr_tmp = (mount_rec *) mr->header.next;
    MountDelete(mr);
    mr = mr_tmp;
  }
  Desk_LinkList_Init(&mount_anchor);
}


/*  Clear out print struct from RMA.
 */
extern void print_clean(void)
{
  print_rec *pr = (print_rec *) print_anchor.next;
  while (pr)
  {
    print_rec *pr_tmp = (print_rec *) pr->header.next;
    PrintDelete(pr);
    pr = pr_tmp;
  }
  Desk_LinkList_Init(&print_anchor);
}


/*  Clear out plist struct from RMA.
 */
extern void plist_clean(void)
{
  plist_rec *pr = (plist_rec *) plist_anchor.next;
  while (pr)
  {
    plist_rec *pr_tmp = (plist_rec *) pr->header.next;
    PrintDeleteList(pr);
    pr = pr_tmp;
  }
  Desk_LinkList_Init(&plist_anchor);
}


/*  This is the finalisation code
 */
_kernel_oserror *fs_finalise(int fatal, int podule, void *pw)
{
  _kernel_swi_regs r;

  M_UNUSED (fatal);
  M_UNUSED (podule);
  M_UNUSED (pw);

  mlist_clean();
  mount_clean();
  print_clean();
  plist_clean();
  if (client_running)
  {
    r.r[0] = client_ID;
    _kernel_swi(Omni_DeregisterClient, &r, &r);
    client_running = Desk_bool_FALSE;
  }

  r.r[0] = (int) msg_struct;
  _kernel_swi(MessageTrans_CloseFile, &r, &r);

  r.r[0] = (int) Resources();
  _kernel_swi(ResourceFS_DeregisterFiles, &r, &r);

  debug_terminate();

  return NULL;
}


/*  International support functions
 */
const char *intl_lookup(const char *token, const char *arg1)
{
  _kernel_oserror *err;
  _kernel_swi_regs r;
  static char string[64];

  r.r[0] = (int) msg_struct;
  r.r[1] = (int) token;
  r.r[2] = (int) string;
  r.r[3] = sizeof(string);
  r.r[4] = (int) arg1;
  r.r[5] = r.r[6] = r.r[7] = 0;
  err = _kernel_swi(MessageTrans_Lookup, &r, &r);
  if (err)
  {
    return "???";
  }
  return (const char *)string;
}


_kernel_oserror *intl_error(err_number_type which)
{
  struct
  {
    int  errnum;
    char token[8];
  } interrblk;
  static _kernel_oserror errblk;
  _kernel_swi_regs r;

  sprintf(interrblk.token, "E%02x", which - client_ERRBASE);
  interrblk.errnum = which;
  r.r[0] = (int) &interrblk;
  r.r[1] = (int) msg_struct;
  r.r[2] = (int) &errblk;
  r.r[3] = sizeof(errblk);
  r.r[4] = r.r[5] = r.r[6] = r.r[7] = 0;
  return _kernel_swi(MessageTrans_ErrorLookup, &r, &r);
}


/*  This is the initialisation code
 */
_kernel_oserror *fs_initialise(const char *cmd_tail, int podule_base, void *private_word)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs r;

  /* These keep the compiler quiet. */
  M_UNUSED (cmd_tail);
  M_UNUSED (podule_base);
  M_UNUSED (private_word);

  /* Register messages */
  r.r[0] = (int) Resources();
  err = _kernel_swi(ResourceFS_RegisterFiles, &r, &r);
  if (err)
    return(err);

  debug_initialise ("", "NetFiler", NULL);
  debug_set_options (0, 0, 0);
  debug_output_device (TML_OUTPUT);

  /* Open messages */
  r.r[0] = (int) msg_struct;
  r.r[1] = (int) "Resources:$.ThirdParty.OmniClient.NetFiler.Messages";
  r.r[2] = 0;
  err = _kernel_swi(MessageTrans_OpenFile, &r, &r);
  if (err)
    goto msg_dereg;

  /* See if Network is present */
  if ((err = _kernel_swi(NetFS_ReadFSNumber, &r, &r)) != NULL)
  {
    err = intl_error(err_NONET);
    goto msg_close;
  }

  /* Init structures */
  Desk_LinkList_Init(&mount_anchor);
  Desk_LinkList_Init(&mlist_anchor);
  Desk_LinkList_Init(&plist_anchor);
  Desk_LinkList_Init(&print_anchor);

  _kernel_oscli("IconSprites Resources:$.ThirdParty.OmniClient.NetFiler.Sprites");
  omni_register();
  return(NULL);

msg_close:
  r.r[0] = (int) msg_struct;
  _kernel_swi(MessageTrans_CloseFile, &r, &r);
msg_dereg:
  r.r[0] = (int) Resources();
  _kernel_swi(ResourceFS_DeregisterFiles, &r, &r);
  debug_terminate();
  return(err);
}


/*  Attempt to register with the filer module.
 */
static _kernel_oserror *omni_register(void)
{
  _kernel_swi_regs r;
  _kernel_oserror *err = NULL;
  char titlebar[24];  /* Title bar - 24 max */
  char infobox[3*32]; /* Info box - 3x32 max */

  strcpy(titlebar, intl_lookup("_Version", NULL)); /* Temp copy */
  sprintf(infobox, "%s\n"
                   "\xA9 Acorn Computers Ltd, 1995\n"
                   "%s",
                   intl_lookup("WhoNet", NULL), titlebar);
  strncpy(titlebar, intl_lookup("DispName", NULL), sizeof(titlebar));                   

  r.r[0] = client_ID;
  r.r[1] = client_FLAGS;
  r.r[2] = (int) "04a540"; /* Sprite name - 12 max */
  r.r[3] = (int) titlebar; /* Title bar - 24 max */
  r.r[4] = (int) infobox;  /* Info box - 3x32 max */;
  r.r[5] = client_LIMIT;   /* Site ID (ignored) */
  r.r[6] = (int) "Net";    /* FS name prefix */
  if ((err = _kernel_swi(Omni_RegisterClient, &r, &r)) == NULL)
    client_running = Desk_bool_TRUE;
  else
    client_running = Desk_bool_FALSE;
  return(err);
}


/* SERVICE omni_base+0 "Service_OmniAction"
 *	On entry, R0 = action word;
 *		        0 = OmniClient module has just started up
 *		        1 = OmniClient module has died or quit due to "Death"
 *			    packet (see document [Site_SpecN])
 *		       >1 = *reserved*
 *		  R1 = Service_OmniAction
 *	All registers preserved on exit
 *
 *	This Service call is used to inform client modules that the desktop
 *	filer has just been run, or just been killed. Appropriate action
 *	when (R0 = 0) is to call the SWI Omni_RegisterClient, to register
 *	themselves in the case where the OmniClient module is loaded *after*
 *	the client modules.
 *      Upon reception of (R0 = 1), it is *required* of clients that they
 *      close down any open files, abort any file transfer operations,
 *      and then die. This is to ensure that users to not loose any data
 *      as a result of running more copies than they are licensed to use.
 *      (see document [Site_SpecN] for more details).
 *      Since client modules rely on services provided by the filer module,
 *      they should quit if the filer module dies for any reason.
 */
static void OmniAction(_kernel_swi_regs *r)
{
  /* Fiddling to get a Desk_module_title pointer */
  char *Desk_module_base = (char *) Image_RO_Base;
  char *Desk_module_title = (char *) (Desk_module_base + *((int *) (Desk_module_base + 0x10)));

  switch (r->r[0])
  {
    case Service_OmniAction_Starting:
      /* OmniClient module has just started up, so if we aren't already
       * registered, do so now.
       */
      omni_register();
      break;
    case Service_OmniAction_Died:
      /* OmniClient module has died.
       * Insert your code here to close all open file handles, and abort any
       * data transfer operations.
       */

      /* We mark as not registered (no point in calling Omni_DeregisterClient!)
       * and quit this module.
       */
      client_running = Desk_bool_FALSE;
      suicide(Desk_module_title);
      break;
    default:
      break;
  }
}


/* Service call handler
 */
void fs_service(int service_number, _kernel_swi_regs *r, void *private_word)
{
  private_word = private_word;
  switch (service_number)
  {
    case Service_OmniAction:
      OmniAction(r);
      break;
    case Service_ResourceFSStarting:
      /* Reregister with ResourceFS */
      (*(void (*)(void *, void *, void *, void *))r->r[2])(Resources(), 0, 0, (void *)r->r[3]);
      break;
    case Service_NetFS:
      /* There has been a Mount connection or disconnection - rescan our active mounts */
      if ((client_running) && (!block_service))
        Desk_SWI(2, 0, Omni_EnumerateMounts, client_ID, OmniEnumerateMounts_ActiveMounts);
      block_service = Desk_bool_FALSE;
      break;
    case Service_NetFSDying:
      /* NetFS has died - rescan our mounts & network servers */
      if (client_running) Desk_SWI(2, 0, Omni_EnumerateMounts, client_ID, OmniEnumerateMounts_Servers);
      break;
  }
}


/* SWI server_id+0 "XXXX_OmniOp"
 *	On entry, R0 = reason code;
 *			0 = Mount
 *			1 = Dismount
 *			2 = Free
 *			3 = Enumerate servers
 *			4 = Enumerate mounts on a server
 *			5 = Enumerate active mounts
 *			6 = Open Root
 *			7 = Open User Root
 *			8 = Get Mount Info
 *			9 = Get Active Mount Info
 * 		       10 = Create Print Job
 * 	               11 = Send data in Print Job
 * 	               12 = End Print Job
 * 	               13 = Abort Print Job(s)
 * 	               14 = Get Print Job Info
 *		       15 = Clear Print Job(s)
 *		       16 = Enumerate printers
 *                    >16 = *reserved*
 *                  Other registers as required for given reason code
 *      On exit,  Registers set as required for given reason code
 *	All other registers preserved on exit
 *
 *      This SWI provides an entry point for the OmniClient to call
 *      individual client modules that have registered with it.
 */


/*	Reason code 0 - Mount server
 *        	On entry, R1 = ptr to Server string
 *        		  R2 = ptr to UserID string (optional)
 *        		  R3 = ptr to Password string (optional)
 *        		  R4 = ptr to Mount name string
 *        		  R5 = ptr to Mount path string (optional)
 *        		  R6 = ptr to Authentication server str (optional)
 *		On exit,  R1 = mount_id, or 0 if failed
 *
 *		Operation to mount a server (in fact a given 'mount' on a
 *		particular server).
 *		Strings are null terminated. Pointers are 0 if fields
 *		are not required for a given Client module. Strings not
 *		guaranteed by caller to be static across multiple calls.
 *		See comments about unique mount_id's in 'Terminology'
 *		section above.
 */
static _kernel_oserror *Op_Mount(_kernel_swi_regs *r)
{
  dprintf(("", "NetFiler.Mount:\n"));
  MountCreate(r);
  dprintf(("", "NetFiler.Mount: %x %x\n", r->r[0], r->r[1]));
  return((_kernel_oserror *) r->r[0]);
}


/*	Reason code 1 - Dismount server
 *		On entry, R1 = mount_id
 *
 *		Operation to dismount a previously mounted server (in fact a
 *		given 'mount' on a particular server).
 */
static _kernel_oserror *Op_Dismount(_kernel_swi_regs *r)
{
  mount_rec *mr = MountFind(r->r[1], -1);
  char buf[48];

  dprintf(("", "NetFiler.Dismount: %x %x\n", r->r[1], (int) mr));
  if (!mr) return(intl_error(err_BADMOUNT));

  /* Attempt a Bye command */
  if (strlen(mr->serveraddr) < 1)
    strcpy(buf, "Net:Bye\n");
  else
    sprintf(buf, "Net:Bye :%s\n", mr->serveraddr);

  /* Execute command - trap for errors */
  block_service = Desk_bool_TRUE;
  MountDelete(mr);
  if (_kernel_oscli(buf) <= 0) return(_kernel_last_oserror());
  return(NULL);
}


/*	Reason code 2 - Freespace on mount
 *		On entry, R1 = mount_id
 *		On exit,  R1 = user free space on mount (bytes)
 *		          R2 = user used space on mount (bytes)
 *		          R3 = total size of mount (bytes)
 *
 *		Returns freespace. Numbers are unsigned 32-bit integers. If
 *		any value is greater than (2^32 - 1) (=4Gbytes!) then simply
 *		return the maximum (0xFFFFFFFF).
 *              The exact interpretation of 'user freespace' and 'total
 *              size' is client dependent, however R1+R2 >= R3.
 */
static _kernel_oserror *Op_Free(_kernel_swi_regs *r)
{
  M_UNUSED(r);
  dprintf(("", "NetFiler.Free: %x\n", r->r[1]));
  /* We don't have information about this anyway :-( */
  return(intl_error(err_NOTSUPPORTED));
}


/*	Reason code 3 - Enumerate all servers on network
 *		On entry, R1 = ptr to buffer for servers list
 *		          R2 = size of buffer (words * 4)
 *		          R3 = 0, start enumerating servers
 *		               not 0, continue enumerating servers
 *		On exit,  R1 = ptr to last byte written to buffer
 *		          R3 = 0, operation complete
 *		               not 0, buffer full, call again with this R3
 *
 *		Operation scans visible network and returns block filled
 *		with Server records for every possible server, in the
 *		following format;
 *
 *		+0	server_id
 *		$4	shortname (no more than 16 characters, 0-terminated)
 *			fullname (no more than 32 characters, 0-terminated)
 *			description (some additional string, <= 64 chars)
 *
 *		+n	server_id
 *		$n+4	shortname/fullname/description
 *		...
 *
 *		Where n is the number of bytes, aligned upwards to a word
 *		boundary.
 *
 *		'shortname' is a short description of the server for Large
 *		and Small icon filer displays. eg, "server"
 *		'fullname' is a full description of the server for Full info
 *		filer displays. eg, "server.subnet.net"
 *              'description' is some textual field for tacking on the end
 *              of Full info filer displays. [We should discuss the sort of
 *              things that might go in here].
 *
 *		If R3 is not 0 on exit, then the enumeration is not complete
 *		(buffer full), and the reason code is called again with the
 *		new R3 value. This process continues until the enumeration
 *		is complete.
 */
static _kernel_oserror *Op_Servers(_kernel_swi_regs *r)
{
  mlist_rec *mr = NULL;

  if (r->r[3] == 0)
  {
    /* ReScan NetFS for servers on network */
    NetServers();
    mr = (mlist_rec *) mlist_anchor.next;
  } else mr = (mlist_rec *) r->r[3];
  if (MountList((char **) &r->r[1], &mr, r->r[2])) r->r[3] = 0;
    else r->r[3] = (int) mr;
  return(NULL);
}


/*	Reason code 4 - Enumerate all mounts on a server
 *		On entry, R1 = ptr to buffer for mounts list
 *		          R2 = size of buffer (words * 4)
 *		          R3 = 0, start enumerating mounts
 *		               not 0, continue enumerating mounts
 *		          R4 = server_id (or 0 if not known)
 *	          	  R5 = ptr to Server name, or 0
 *		On exit,  R1 = ptr to last byte written to buffer
 *		          R3 = 0, operation complete
 *		               not 0, buffer full, call again with this R3
 *
 *		Operation scans visible network and returns block filled
 *		with Mount records for every possible mount on the given
 *		server, in the following format;
 *
 *		+0	mount_id (or 0 if not connected)
 *		$4	shortname (no more than 16 characters, 0-terminated)
 *			fullname (no more than 32 characters, 0-terminated)
 *			description (some additional string, <= 64 chars)
 *
 *		+n	mount_id
 *		$n+4	shortname/fullname/description
 *		...
 *
 *		Where n is the number of bytes, aligned upwards to a word
 *		boundary.
 *
 *		'shortname' is a short description of the mount for Large
 *		and Small icon filer displays. eg, "leafdir"
 *		'fullname' is a full description of the mount for Full info
 *		filer displays. eg, "dir1.dir2.leafdir"
 *              'description' is some textual field for tacking on the end
 *              of Full info filer displays. We should discuss the sort of
 *              things that might go in here.
 *
 *		If R3 is not 0 on exit, then the enumeration is not complete
 *		(buffer full), and the reason code is called again with the
 *		new R3 value. This process continues until the enumeration
 *		is complete.
 */
static _kernel_oserror *Op_Mounts(_kernel_swi_regs *r)
{
  /* No concept of mount points in this filing system */
  r->r[3] = 0;
  return(NULL);
}


/*	Reason code 5 - Enumerate active (connected) mounts
 *		On entry, R1 = ptr to buffer for mounts list
 *		          R2 = size of buffer (words * 4)
 *		          R3 = 0, start enumerating mounts
 *		               not 0, continue enumerating mounts
 *		On exit,  R1 = ptr to last byte written to buffer
 *		          R3 = 0, operation complete
 *		               not 0, buffer full, call again with this R3
 *
 *		Operation returns buffer filled with Mount records for every
 *		active (connected) mount on a server, in the following format;
 *
 *		+0	server_id
 *		+4	mount_id
 *		$8 	mount name (no more than 16 chars, 0-terminated)
 *
 *		+n	server_id
 *		...
 *
 *		Where n is the number of bytes, aligned upwards to a word
 *		boundary.
 *
 *		'mount name' is the mount name, as passed in the Mount
 *		(reason code = 0) OmniOp SWI call.
 *
 *		If R3 is not 0 on exit, then the enumeration is not complete
 *		(buffer full), and the reason code is called again with the
 *		new R3 value. This process continues until the enumeration
 *		is complete.
 */
static _kernel_oserror *Op_ActiveMounts(_kernel_swi_regs *r)
{
  mount_rec *mr = NULL;

  if (r->r[3] == 0)
  {
    /* ReScan NetFS for active mounts */
    NetMounts();
    mr = (mount_rec *) mount_anchor.next;
  } else mr = (mount_rec *) r->r[3];
  if (ActiveMountList((char **) &r->r[1], &mr, r->r[2])) r->r[3] = 0;
    else r->r[3] = (int) mr;
  return(NULL);
}


/*	Reason code 6 - Open Root of mount
 *		On entry, R1 = mount_id
 *
 *		Trigger a Filer_OpenDir on the highest point available
 *		in mount's visible directory tree. eg, '$'
 */
static _kernel_oserror *Op_Root(_kernel_swi_regs *r)
{
  mount_rec *mr = MountFind(r->r[1], -1);
  char buf[64];

  dprintf(("", "NetFiler.Root: %x %x\n", r->r[1], (int) mr));
  if (!mr) return(intl_error(err_BADMOUNT));
  sprintf(buf, "Filer_OpenDir Net::%s.$", mr->serveraddr);
  if (_kernel_oscli(buf) <= 0) return(_kernel_last_oserror());
  return(NULL);
}


/*	Reason code 7 - Open User Root of mount
 *		On entry, R1 = mount_id
 *
 *		Trigger a Filer_OpenDir on the current user's 'home'
 *		directory, or the highest point available in mount's
 *		visible directory tree if not applicable. eg, '/homes/nas'
 *		or '$'
 */
static _kernel_oserror *Op_UserRoot(_kernel_swi_regs *r)
{
  mount_rec *mr = MountFind(r->r[1], -1);
  char buf[64];

  dprintf(("", "NetFiler.UserRoot: %x %x\n", r->r[1], (int) mr));
  if (!mr) return(intl_error(err_BADMOUNT));
  sprintf(buf, "Filer_OpenDir Net::%s.&", mr->serveraddr);
  if (_kernel_oscli(buf) <= 0) return(_kernel_last_oserror());
  return(NULL);
}


/*	Reason code 8 - Get (inactive/not-connected) Mount Info
 *		On entry, R1 = mount_id (of active mount)
 *			  R2 = ptr to new Mount path string
 *		On exit,  R1 = new mount facilities flags word;
 *			       bit 0 = 1, mount does need User identifier
 *			       bit 1 = 1, mount does need Password string
 *                             bits 2..31 = *reserved* zero
 *
 *		This reason code allows for the possibility of changing
 *		authentication once a mount to a given server is made.
 *		mount_id is the existing connection to a server (possibly
 *		one of several) and the new mount name/path strings are the
 *		new mount to that server. Some clients (eg, LAN Manager)
 *		allow unauthenticated new mounts, once an authenticated
 *		mount is performed.
 */
static _kernel_oserror *Op_MountInfo(_kernel_swi_regs *r)
{
  M_UNUSED(r);
  dprintf(("", "NetFiler.GetMountInfo: %x\n", r->r[1]));
  return(intl_error(err_NOTSUPPORTED));
}


/*	Reason code 9 - Get (active/connected) Mount Info
 *		On entry, R1 = mount_id (of active mount)
 *		On exit,  R1 = ptr to Server string
 *        		  R2 = ptr to UserID string
 *        		  R3 = ptr to Mount name string
 *        		  R4 = ptr to Mount path string
 *        		  R5 = ptr to Authentication server string
 *			  R6 = server_id
 *
 *		Operation to get information about an active mount.
 *		Strings are null terminated. Pointers are 0 if fields
 *		are not available for a given mount. Strings do not need to
 *		be guaranteed to be static across multiple calls.
 *              The Server string (R1) should be the 'full name' as supplied
 *              by OmniOp reason code 3 (Enumerate all servers).
 */
static _kernel_oserror *Op_ActiveMountInfo(_kernel_swi_regs *r)
{
  mount_rec *mr = MountFind(r->r[1], -1);

  dprintf(("", "NetFiler.GetActiveInfo: %x %x\n", r->r[1], (int) mr));
  if (!mr) return(intl_error(err_BADMOUNT));
  r->r[1] = (int) mr->serveraddr;
  r->r[2] = (int) mr->userid;
  r->r[3] = (int) mr->mount;
  r->r[4] = 0;
  r->r[5] = 0;
  r->r[6] = mr->server_id;
  return(NULL);
}


/* 	Reason code 10 - Create Print Job
 *		On entry, R1 = ptr to server name
 *	                  R2 = ptr to printer name
 *	                  R3 = ptr to user name, or NULL
 *	                  R4 = ptr to password string, or NULL
 *	                  R5 = ptr to options string, or NULL
 *			  R6 = size of print job (bytes), or 0 if not known
 *		On exit,  R1 = pjob_id, or 0 if failed
 * 		All other registers preserved on exit
 *
 *        	Submit a new job for network printing. The user name,
 *        	password and options string are optional, and may be NULL
 *        	pointers. See comments about unique pjob_id's in 'Terminology'
 *		section above.
 *
 *              Some printing protocols require that the total size of the
 *              job is known before printing starts. If this is the case, they
 *              should be registered with OmniClient as requiring this.
 */
static _kernel_oserror *Op_CreateJob(_kernel_swi_regs *r)
{
  /* printf("OmniOp_CreateJob:\n"); */
  if (PrintCreate(r)) return(NULL);
    else return((_kernel_oserror *) r->r[0]);
}


/* 	Reason code 11 - Send data in Print Job
 * 		On entry, R1 = pjob_id
 * 		          R2 = ptr to data block to send
 * 		          R3 = size of data block to send
 * 		On exit,  R3 = number of bytes not sent, or 0 for all done
 * 		All other registers preserved on exit
 *
 *         	Send a block of data down network printer stream for a given
 *         	active pjob_id word.
 */
static _kernel_oserror *Op_SendJob(_kernel_swi_regs *r)
{
  print_rec *pr = NULL;
   _kernel_oserror *err = NULL;

  /* Check for a valid print job */
  if ((pr = PrintFind(r->r[1])) == NULL) return(intl_error(err_BADPRINT));

  /* Do OS_GBPB call to write bytes out to network driver */
  err = (_kernel_oserror *) Desk_SWI(4, 4, OS_GBPB, 2, pr->handle, r->r[2], r->r[3],
    NULL, NULL, NULL, &r->r[3]);
  return(err);
}


/* 	Reason code 11 - End Print Job
 * 		On entry, R1 = pjob_id
 * 		All registers preserved on exit
 *
 *         	End a specified print job normally (ie, all data
 *         	transmitted).
 */
static _kernel_oserror *Op_EndJob(_kernel_swi_regs *r)
{
  print_rec *pr = NULL;
   _kernel_oserror *err = NULL;

  /* Check for a valid print job */
  if ((pr = PrintFind(r->r[1])) == NULL) return(intl_error(err_BADPRINT));

  /* Do OS_Find call to close job */
  if (pr->handle == 0) return(NULL); /* Already closed */
  err = (_kernel_oserror *) Desk_SWI(2, 0, OS_Find, 0, pr->handle);
  if (!err)
  {
    pr->status = (Desk_print_STATUS | Desk_print_COMPLETE);
    pr->handle = 0;
  }
  return(err);
}


/* 	Reason code 12 - Abort Print Job(s)
 * 		On entry, R1 = pjob_id, or
 * 		             = 0, to abort all jobs
 * 		All registers preserved on exit
 *
 *         	Abort a specified print job, or all current jobs.
 */
static _kernel_oserror *Op_AbortJob(_kernel_swi_regs *r)
{
  print_rec *pr = NULL;
   _kernel_oserror *err = NULL;

  if (r->r[1] == 0)
  {
    /* Abort all print jobs */
    pr = (print_rec *) print_anchor.next;
    while (pr != NULL)
    {
      print_rec *pr_tmp = (print_rec *) pr->header.next;
      /* Do OS_Find call to close job */
      if (pr->handle != 0)
      {
        err = (_kernel_oserror *) Desk_SWI(2, 0, OS_Find, 0, pr->handle);
        if (!err) pr->handle = 0;
      }
      /* Set status */
      pr->status = (Desk_print_STATUS | Desk_print_ERROR);
      pr = pr_tmp;
    }
  }
  else
  {
    /* Abort a single print job */
    if ((pr = PrintFind(r->r[1])) == NULL) return(intl_error(err_BADPRINT));
    /* Do OS_Find call to close job */
    if (pr->handle == 0) return(NULL); /* Already closed */
    err = (_kernel_oserror *) Desk_SWI(2, 0, OS_Find, 0, pr->handle);
    if (!err)
    {
      pr->handle = 0;
      pr->status = (Desk_print_STATUS | Desk_print_ERROR);
    }
  }
  return(err);
}


/* 	Reason code 13 - Get Print Job Info
 * 		On entry, R1 = pjob_id
 * 		On exit,  R1 = local job status word
 * 			  R2 = local job # bytes sent
 * 			  R3 = error/status block ptr, or 0
 * 			  R4 = remote job status word
 * 			  R5 = remote job # bytes printed
 * 			  R6 = error/status block ptr, or 0
 * 		All other registers preserved on exit
 *
 *         	Get information on a specified print job. The status word
 *         	(R1, R3) is defined above in SWI Omni_JobStatus.
 */
static _kernel_oserror *Op_GetJobInfo(_kernel_swi_regs *r)
{
  print_rec *pr = NULL;
   _kernel_oserror *err = NULL;

  if ((pr = PrintFind(r->r[1])) == NULL) return(intl_error(err_BADPRINT));
  r->r[1] = pr->status;
  if (pr->handle > 0)
  {
    err = (_kernel_oserror *) Desk_SWI(2, 3, OS_Args, 2, pr->handle, NULL, NULL, &r->r[2]);
    if (err) r->r[2] = 0;
  } else r->r[2] = 0;
  r->r[3] = 0;
  r->r[4] = 0;
  r->r[5] = 0;
  r->r[6] = 0;
  return(NULL);
}


/*
 *	Reason code 15 - Clear Print Job(s)
 *		On entry, R1 = pjob_id, or
 *		             = 0, to clear all inactive jobs
 *		All registers preserved on exit
 *
 *        	Clear a specified print job, or all inactive jobs. OmniClient
 *        	will make this call when the print job submitter indicates,
 *        	by calling SWI Omni_ClearJob, longer requires status information
 *        	about that job. The status of a print job should reside in
 *        	memory forever if this reason code is not called.
 *              'Inactive' in this case means either 'transfer complete' (3) or
 *              'job has terminal error' (5).
 */
static _kernel_oserror *Op_ClearJob(_kernel_swi_regs *r)
{
  print_rec *pr = NULL;
   _kernel_oserror *err = NULL;

  if (r->r[1] == 0)
  {
    /* Free inactive print jobs */
    pr = (print_rec *) print_anchor.next;
    while (pr != NULL)
    {
      print_rec *pr_tmp = (print_rec *) pr->header.next;
      if ((pflagSET(pr->status, Desk_print_COMPLETE)) || (pflagSET(pr->status, Desk_print_ERROR)))
        PrintDelete(pr);
      pr = pr_tmp;
    }
  }
  else
  {
    /* Abort a single print job */
    if ((pr = PrintFind(r->r[1])) == NULL) return(intl_error(err_BADPRINT));
    if ((pflagSET(pr->status, Desk_print_COMPLETE)) || (pflagSET(pr->status, Desk_print_ERROR)))
      PrintDelete(pr);
  }
  return(err);
}


/*
 *	Reason code 16 - Enumerate all printers on network
 *		On entry, R1 = ptr to buffer for printers list (word aligned)
 *		          R2 = size of buffer (words * 4)
 *		          R3 = 0, start enumerating printers
 *		               not 0, continue enumerating printers
 *		On exit,  R1 = ptr to next free byte in buffer, word aligned
 *		          R3 = 0, operation complete
 *		               not 0, buffer full, call again with this R3
 *
 *		Operation scans visible network and returns block filled
 *		with Printer records for every possible printer, in the
 *		following format;
 *
 *		+0	flags word (see below)
 *		$4	printer (no more than 24 chars, 0-terminated)
 *                      server (no more than 64 chars, 0-terminated)
 *
 *		+n	flags
 *		$n+4	name
 *		...
 *
 *		Where n is the number of bytes, aligned upwards to a word
 *		boundary.
 *
 *		'printer' is a description of the printer for Large/Small and
 *		Full info filer displays. eg, "laser printer".
 *		'server' is a full description of the server, as returned by
 *		OmniOp 3. eg, "server.subnet.net"
 *              'flags' is a set of bit fields that describe the printer type
 *              and facilities provided (see PRM 3-595, SWI Omni_PrinterInfo).
 *
 *              In the case where the printer sits directly upon a network,
 *              with no server, it should give a 'dummy' server name the
 *              same as the printer name.
 *
 *		If R3 is not 0 on exit, then the enumeration is not complete
 *		(buffer full), and the reason code is called again with the
 *		new R3 value. This process continues until the enumeration
 *		is complete.
 */
static _kernel_oserror *Op_Printers(_kernel_swi_regs *r)
{
  plist_rec *mr = NULL;

  if (r->r[3] == 0)
  {
    /* ReScan NetFS for printers on network */
    NetPrinters();
    mr = (plist_rec *) plist_anchor.next;
  } else mr = (plist_rec *) r->r[3];
  if (PrintList((char **) &r->r[1], &mr, r->r[2])) r->r[3] = 0;
    else r->r[3] = (int) mr;
  return(NULL);
}


/*  User SWI call handler.
 */
_kernel_oserror *fs_swi(int Desk_swi_no, _kernel_swi_regs *r, void *private_word)
{
  M_UNUSED(private_word);

  if (!client_running) return(intl_error(err_NOOMNI));
  switch (Desk_swi_no)
  {
    case NetFiler_OmniOp - NetFiler_00:
      switch (r->r[0])
      {
        case OmniOp_Mount:
          return Op_Mount(r);
        case OmniOp_Dismount:
          return Op_Dismount(r);
        case OmniOp_Free:
          return Op_Free(r);
        case OmniOp_EnumerateServers:
          return Op_Servers(r);
        case OmniOp_EnumerateMountsOnServer:
          return Op_Mounts(r);
        case OmniOp_EnumerateActiveMounts:
          return Op_ActiveMounts(r);
        case OmniOp_OpenRoot:
          return Op_Root(r);
        case OmniOp_OpenUserRoot:
          return Op_UserRoot(r);
        case OmniOp_GetInactiveMountInfo:
          return Op_MountInfo(r);
        case OmniOp_GetActiveMountInfo:
          return Op_ActiveMountInfo(r);
        case OmniOp_CreatePrintJob:
          return Op_CreateJob(r);
        case OmniOp_SendPrintJobData:
          return Op_SendJob(r);
        case OmniOp_EndPrintJob:
          return Op_EndJob(r);
        case OmniOp_AbortPrintJob:
          return Op_AbortJob(r);
        case OmniOp_GetPrintJobInfo:
          return Op_GetJobInfo(r);
        case OmniOp_ClearPrintJob:
          return Op_ClearJob(r);
        case OmniOp_EnumeratePrinters:
          return Op_Printers(r);
        default:
          return(intl_error(err_NOTSUPPORTED));
      }
      break;

    default:
      return error_BAD_SWI;
  }

  /* Return with no error */
  return(NULL);
}
@


1.4
log
@Change local defines to OmniClient's exports
Requires Omni-2_22 for its exported header.

Version 1.18. Tagged as 'NetFiler-1_18'
@
text
@a50 1
#include "MakeError.h"
d55 1
a56 9
static client_rec	client =
			  { client_SWIBASE,
			    client_FLAGS,
			    "04a540",
			    "Level 4",
			    "AUN Econet/Level 4\n© Acorn Computers Ltd, 1995\n" Module_VersionString " (" Module_Date ")",
			    client_LIMIT,
			    "Net"
                          };
a60 1
extern _kernel_oserror  omni_errblk = {0, ""}; 		/* Global error block */
a62 3
extern _kernel_oserror *resources_register(void);
extern _kernel_oserror *resources_deregister(void);
extern void resources_starting(int calladdr, int worksp);
d64 2
a65 1

d132 2
a141 1
  resources_deregister();
d144 1
a144 2
    _kernel_swi_regs r;
    r.r[0] = client.client_id;
d146 1
a146 1
   client_running = Desk_bool_FALSE;
d149 6
d161 1
a161 1
/*  Attempt to register with the filer module.
d163 22
a184 1
static _kernel_oserror *omni_register(void)
d186 6
a192 1
  _kernel_oserror *err = NULL;
d194 8
a201 10
  r.r[0] = client.client_id;
  r.r[1] = client.flags;
  r.r[2] = (int) &client.sprite;
  r.r[3] = (int) &client.name;
  r.r[4] = (int) &client.desc;
  r.r[5] = client.site_id;
  r.r[6] = (int) &client.fsname;
  if ((err = _kernel_swi(Omni_RegisterClient, &r, &r)) == NULL) client_running = Desk_bool_TRUE;
    else client_running = Desk_bool_FALSE;
  return(err);
d212 11
d227 14
a240 4
  /* These keep the compiler quiet. */
  M_UNUSED (cmd_tail);
  M_UNUSED (podule_base);
  M_UNUSED (private_word);
d242 1
a242 1
  /* Init test structures */
a247 4
  /* See if Network is present */
  if ((err = _kernel_swi(NetFS_ReadFSNumber, &r, &r)) != NULL) return(MakeError(err_NONET));

  resources_register();
d250 40
d359 2
a360 1
      resources_starting(r->r[2], r->r[3]);
a361 1
    /* Handle other service calls here */
d365 1
a365 1
        Desk_SWI(2, 0, Omni_EnumerateMounts, client.client_id, OmniEnumerateMounts_ActiveMounts);
d370 1
a370 1
      if (client_running) Desk_SWI(2, 0, Omni_EnumerateMounts, client.client_id, OmniEnumerateMounts_Servers);
d443 1
a443 1
  if (!mr) return(MakeError(err_BADMOUNT));
d476 1
a476 1
  return(MakeError(err_NOTSUPPORTED));
d640 1
a640 1
  if (!mr) return(MakeError(err_BADMOUNT));
d661 1
a661 1
  if (!mr) return(MakeError(err_BADMOUNT));
d688 1
a688 1
  return(MakeError(err_NOTSUPPORTED));
d713 1
a713 1
  if (!mr) return(MakeError(err_BADMOUNT));
d767 1
a767 1
  if ((pr = PrintFind(r->r[1])) == NULL) return(MakeError(err_BADPRINT));
d789 1
a789 1
  if ((pr = PrintFind(r->r[1])) == NULL) return(MakeError(err_BADPRINT));
d836 1
a836 1
    if ((pr = PrintFind(r->r[1])) == NULL) return(MakeError(err_BADPRINT));
d868 1
a868 1
  if ((pr = PrintFind(r->r[1])) == NULL) return(MakeError(err_BADPRINT));
d917 1
a917 1
    if ((pr = PrintFind(r->r[1])) == NULL) return(MakeError(err_BADPRINT));
d988 1
a988 1
  if (!client_running) return(MakeError(err_NOOMNI));
d1029 1
a1029 1
          return(MakeError(err_NOTSUPPORTED));
@


1.3
log
@Makefile recreated from fragments
Untangle headers in the C source files.
Expand tabs in Resources.s, 32 bit a ^, and use Push/Pull macros.
Builds, but not tested.

Version 1.17. Tagged as 'NetFiler-1_17'
@
text
@d47 1
d249 1
a249 1
    case 0:
d255 1
a255 1
    case 1:
d290 1
a290 1
        Desk_SWI(2, 0, Omni_EnumerateMounts, client.client_id, 1);
d295 1
a295 1
      if (client_running) Desk_SWI(2, 0, Omni_EnumerateMounts, client.client_id, 0);
d347 1
a347 1
static _kernel_oserror *OmniOp_Mount(_kernel_swi_regs *r)
d362 1
a362 1
static _kernel_oserror *OmniOp_Dismount(_kernel_swi_regs *r)
d396 1
a396 1
static _kernel_oserror *OmniOp_Free(_kernel_swi_regs *r)
d443 1
a443 1
static _kernel_oserror *OmniOp_Servers(_kernel_swi_regs *r)
d499 1
a499 1
static _kernel_oserror *OmniOp_Mounts(_kernel_swi_regs *r)
d537 1
a537 1
static _kernel_oserror *OmniOp_ActiveMounts(_kernel_swi_regs *r)
d559 1
a559 1
static _kernel_oserror *OmniOp_Root(_kernel_swi_regs *r)
d580 1
a580 1
static _kernel_oserror *OmniOp_UserRoot(_kernel_swi_regs *r)
d609 1
a609 1
static _kernel_oserror *OmniOp_MountInfo(_kernel_swi_regs *r)
d633 1
a633 1
static _kernel_oserror *OmniOp_ActiveMountInfo(_kernel_swi_regs *r)
d668 1
a668 1
static _kernel_oserror *OmniOp_CreateJob(_kernel_swi_regs *r)
d686 1
a686 1
static _kernel_oserror *OmniOp_SendJob(_kernel_swi_regs *r)
d708 1
a708 1
static _kernel_oserror *OmniOp_EndJob(_kernel_swi_regs *r)
d735 1
a735 1
static _kernel_oserror *OmniOp_AbortJob(_kernel_swi_regs *r)
d788 1
a788 1
static _kernel_oserror *OmniOp_GetJobInfo(_kernel_swi_regs *r)
d822 1
a822 1
static _kernel_oserror *OmniOp_ClearJob(_kernel_swi_regs *r)
d891 1
a891 1
static _kernel_oserror *OmniOp_Printers(_kernel_swi_regs *r)
d916 1
a916 1
    case 0: /* NetFiler_OmniOp */
d919 34
a952 51
        case 0: /* Mount */
          return(OmniOp_Mount(r));
          break;
        case 1: /* Dismount */
          return(OmniOp_Dismount(r));
          break;
        case 2: /* Free */
          return(OmniOp_Free(r));
          break;
        case 3: /* Enumerate servers */
          return(OmniOp_Servers(r));
          break;
        case 4: /* Enumerate mounts on a server */
          return(OmniOp_Mounts(r));
          break;
        case 5: /* Enumerate active mounts on a server */
          return(OmniOp_ActiveMounts(r));
          break;
        case 6: /* Open Root */
          return(OmniOp_Root(r));
          break;
        case 7: /* Open User Root */
          return(OmniOp_UserRoot(r));
          break;
        case 8: /* Get Mount Info */
          return(OmniOp_MountInfo(r));
          break;
        case 9: /* Get Active Mount Info */
          return(OmniOp_ActiveMountInfo(r));
          break;
        case 10: /* Create Print Job */
          return(OmniOp_CreateJob(r));
          break;
        case 11: /* Send Data to Print Job */
          return(OmniOp_SendJob(r));
          break;
        case 12: /* End Print Job */
          return(OmniOp_EndJob(r));
          break;
        case 13: /* Abort Print Job(s) */
          return(OmniOp_AbortJob(r));
          break;
        case 14: /* Get Print Job Info */
          return(OmniOp_GetJobInfo(r));
          break;
        case 15: /* Clear Print Job(s) */
          return(OmniOp_ClearJob(r));
          break;
        case 16: /* Enumerate Printers */
          return(OmniOp_Printers(r));
          break;
@


1.2
log
@Summary
  * Further rationalisations to fit into our build system.
Detail
  * Altered to use auto-generated or centralised declarations, constants etc.
    wherever possible.
  * Altered to use some library routines instead of local equivalents.
  * Debug build uses DebugLib.
  * Modified to use SrcCommit.
  * Got rid of warnings.
Admin
  * Removed entire contents of hdr directory; macros now obtained from HdrSrc.
  * Debug.h, ModuleWrap.h and Base.s removed.
  * Requires AsmUtils.
  * Both builds compiled.

Version 1.15. Tagged as 'NetFiler-1_15'
@
text
@d36 2
a37 2
#include <kernel.h>
#include <swis.h>
d39 1
a39 1
#include <AsmUtils/rminfo.h>
d41 1
a41 1
#include <DebugLib/DebugLib.h>
d43 2
a44 2
#include <Desk/LinkList.h>
#include <Desk/SWI.h>
d46 1
a46 1
#include <Global/Services.h>
d48 1
d51 1
a51 1
#include "ModHdr.h"
a52 1
#include "NetFiler.h"
a54 2
#include "VersionNum"

d61 1
a61 1
			    "AUN Econet/Level 4\n© Acorn Computers Ltd, 1995\n" Module_FullVersion " (" Module_Date ")",
@


1.1
log
@Initial revision
@
text
@d37 5
d46 6
a52 2
#include "ModuleWrap.h"
#include "Lists.h"
a53 3
#include "Net.h"
#include "MakeError.h"
#include "Debug.h"
d55 4
a58 2
extern Desk_bool 		client_running = Desk_bool_FALSE;	/* Desk_bool_TRUE if registered & running OK */
extern client_rec	client =
d63 1
a63 1
			    "AUN Econet/Level 4\n© Acorn Computers Ltd, 1995\n1.14 (26-Jun-95)",
d70 1
a70 1
extern Desk_linklist_header	Desk_print_anchor = {NULL, NULL};	/* List of active print records */
a72 7
#ifdef DEBUG
extern FILE		*omniout = NULL;
#endif

extern char		*developed = "\n Developed by ANT Limited <sales@@ant.co.uk> \n";

extern int *Image__RO_Base;
d113 1
a113 1
extern void Desk_print_clean(void)
d115 1
a115 1
  print_rec *pr = (print_rec *) Desk_print_anchor.next;
d122 1
a122 1
  Desk_LinkList_Init(&Desk_print_anchor);
d143 1
a143 1
static void fs_finalise(void)
d145 4
d151 1
a151 1
  Desk_print_clean();
d161 4
d170 1
a170 1
_kernel_oserror *omni_register(void)
d190 1
a190 1
_kernel_oserror *fs_initialise(char *cmd_tail, int podule_base, void *private_word)
d195 4
d200 3
a202 3
  cmd_tail = cmd_tail;
  podule_base = podule_base;
  private_word = private_word;
d208 1
a208 1
  Desk_LinkList_Init(&Desk_print_anchor);
a212 6
#ifdef DEBUG
  /* Debug trace file? */
  if ((err = _kernel_swi(Omni_TraceFile, &r, &r)) == NULL) omniout = (FILE *) r.r[0];
#endif

  atexit(fs_finalise);
d242 1
a242 1
void OmniAction(_kernel_swi_regs *r)
d245 1
a245 1
  char *Desk_module_base = (char *) Image__RO_Base;
d348 1
a348 1
_kernel_oserror *OmniOp_Mount(_kernel_swi_regs *r)
d350 1
a350 1
  TRACE("NetFiler.Mount:\n");
d352 1
a352 1
  TRACE2("NetFiler.Mount: %x %x\n", r->r[0], r->r[1]);
d363 1
a363 1
_kernel_oserror *OmniOp_Dismount(_kernel_swi_regs *r)
d368 1
a368 1
  TRACE2("NetFiler.Dismount: %x %x\n", r->r[1], (int) mr);
d397 1
a397 1
_kernel_oserror *OmniOp_Free(_kernel_swi_regs *r)
d399 2
a400 1
  TRACE1("NetFiler.Free: %x\n", r->r[1]);
d444 1
a444 1
_kernel_oserror *OmniOp_Servers(_kernel_swi_regs *r)
d500 1
a500 1
_kernel_oserror *OmniOp_Mounts(_kernel_swi_regs *r)
d538 1
a538 1
_kernel_oserror *OmniOp_ActiveMounts(_kernel_swi_regs *r)
d560 1
a560 1
_kernel_oserror *OmniOp_Root(_kernel_swi_regs *r)
d565 1
a565 1
  TRACE2("NetFiler.Root: %x %x\n", r->r[1], (int) mr);
d581 1
a581 1
_kernel_oserror *OmniOp_UserRoot(_kernel_swi_regs *r)
d586 1
a586 1
  TRACE2("NetFiler.UserRoot: %x %x\n", r->r[1], (int) mr);
d610 1
a610 1
_kernel_oserror *OmniOp_MountInfo(_kernel_swi_regs *r)
d612 2
a613 1
  TRACE1("NetFiler.GetMountInfo: %x\n", r->r[1]);
d634 1
a634 1
_kernel_oserror *OmniOp_ActiveMountInfo(_kernel_swi_regs *r)
d638 1
a638 1
  TRACE2("NetFiler.GetActiveInfo: %x %x\n", r->r[1], (int) mr);
d669 1
a669 1
_kernel_oserror *OmniOp_CreateJob(_kernel_swi_regs *r)
d687 1
a687 1
 _kernel_oserror *OmniOp_SendJob(_kernel_swi_regs *r)
d695 2
a696 2
  /* Do Desk_OS_GBPB call to write bytes out to network driver */
  err = (_kernel_oserror *) Desk_SWI(4, 4, Desk_OS_GBPB, 2, pr->handle, r->r[2], r->r[3],
d709 1
a709 1
_kernel_oserror *OmniOp_EndJob(_kernel_swi_regs *r)
d717 1
a717 1
  /* Do Desk_OS_Find call to close job */
d719 1
a719 1
  err = (_kernel_oserror *) Desk_SWI(2, 0, Desk_OS_Find, 0, pr->handle);
d736 1
a736 1
_kernel_oserror *OmniOp_AbortJob(_kernel_swi_regs *r)
d744 1
a744 1
    pr = (print_rec *) Desk_print_anchor.next;
d748 1
a748 1
      /* Do Desk_OS_Find call to close job */
d751 1
a751 1
        err = (_kernel_oserror *) Desk_SWI(2, 0, Desk_OS_Find, 0, pr->handle);
d763 1
a763 1
    /* Do Desk_OS_Find call to close job */
d765 1
a765 1
    err = (_kernel_oserror *) Desk_SWI(2, 0, Desk_OS_Find, 0, pr->handle);
d789 1
a789 1
_kernel_oserror *OmniOp_GetJobInfo(_kernel_swi_regs *r)
d798 1
a798 1
    err = (_kernel_oserror *) Desk_SWI(2, 3, Desk_OS_Args, 2, pr->handle, NULL, NULL, &r->r[2]);
d823 1
a823 1
_kernel_oserror *OmniOp_ClearJob(_kernel_swi_regs *r)
d831 1
a831 1
    pr = (print_rec *) Desk_print_anchor.next;
d892 1
a892 1
_kernel_oserror *OmniOp_Printers(_kernel_swi_regs *r)
d912 1
a912 1
  static _kernel_oserror fs_error = {0x1e6, "Bad SWI call"};
d977 1
a977 1
      return(&fs_error);
@


1.1.1.1
log
@Summary
  * Initial import of NetFiler.

Details
  * Revamped build structure.
  * Modified sources to use Desk instead of ANT's proprietary version of
    DeskLib; only uses linked list handling, SWI veneer and time code, so
    don't expect this shouldn't cause any significant problem.

Admin
  * Compiled.
  * Untested.
@
text
@@

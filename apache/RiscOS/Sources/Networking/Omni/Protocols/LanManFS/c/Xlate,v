head	1.23;
access;
symbols
	LanManFS-2_62:1.23
	LanManFS-2_61:1.22
	LanManFS-2_60:1.21
	LanManFS-2_59:1.20
	LanManFS-2_58:1.20
	LanManFS-2_57:1.20
	LanManFS-2_56:1.19
	LanManFS-2_55:1.19
	LanManFS-2_54:1.19
	LanManFS-2_53:1.19
	LanManFS-2_52:1.19
	LanManFS-2_51:1.19
	LanManFS-2_50:1.19
	LanManFS-2_49:1.19
	LanManFS-2_48:1.19
	LanManFS-2_47:1.19
	LanManFS-2_46:1.19
	LanManFS-2_45:1.18
	LanManFS-2_44:1.17
	LanManFS-2_43:1.17
	LanManFS-2_42:1.17
	LanManFS-2_41:1.17
	LanManFS-2_40:1.17
	LanManFS-2_39:1.16
	LanManFS-2_38:1.15
	LanManFS-2_37:1.15
	LanManFS-2_36:1.14
	LanManFS-2_35:1.13
	LanManFS-2_34:1.13
	LanManFS-2_33:1.12
	LanManFS-2_32:1.11
	LanManFS-2_31:1.10
	RO_5_07:1.10
	LanManFS-2_30:1.10
	LanManFS-2_29:1.10
	LanManFS-2_28:1.9
	LanManFS-2_27:1.8
	LanManFS-2_26:1.7
	LanManFS-2_25:1.7
	LanManFS-2_24:1.6
	LanManFS-2_23:1.5
	LanManFS-2_22:1.4
	LanManFS-2_21:1.4
	LanManFS-2_20:1.4
	LanManFS-2_19:1.4
	LanManFS-2_18:1.4
	LanManFS-2_17:1.4
	LanManFS-2_16:1.4
	LanManFS-2_15:1.4
	LanManFS-2_14:1.4
	LanManFS-2_13:1.4
	LanManFS-2_12:1.4
	LanManFS-2_11:1.4
	LanManFS-2_10:1.4
	LanManFS-2_09:1.3
	LanManFS-2_08:1.3
	LanManFS-2_07:1.3
	LanManFS-2_06:1.3
	LanManFS-2_05:1.2
	LanManFS-2_04:1.2
	LanManFS-2_03:1.2
	LanManFS-2_02:1.2
	LanManFS-2_01:1.2
	LanManFS-2_00:1.2
	LanManFS-1_87-1_1_1_1_2_13:1.1.1.1.2.7
	LanManFS-1_87-1_1_1_1_2_12:1.1.1.1.2.7
	LanManFS-1_87-1_1_1_1_2_11:1.1.1.1.2.7
	LanManFS-1_87-1_1_1_1_2_10:1.1.1.1.2.7
	LanManFS-1_87-1_1_1_1_2_9:1.1.1.1.2.6
	LanManFS-1_87-1_1_1_1_2_8:1.1.1.1.2.5
	LanManFS-1_87-1_1_1_1_2_7:1.1.1.1.2.4
	LanManFS-1_87-1_1_1_1_2_6:1.1.1.1.2.4
	LanManFS-1_87-1_1_1_1_2_5:1.1.1.1.2.4
	LanManFS-1_87-1_1_1_1_2_4:1.1.1.1.2.3
	LanManFS-1_87-1_1_1_1_2_3:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_2:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_1:1.1.1.1
	sbrodie_LanManFS_dev:1.1.1.1.0.2
	sbrodie_LanManFS_dev_bp:1.1.1.1
	LanManFS-1_87:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.23
date	2018.08.04.09.23.39;	author rool;	state Exp;
branches;
next	1.22;
commitid	eZmYQ5vaFQjlFMMA;

1.22
date	2018.01.03.22.06.37;	author rsprowson;	state Exp;
branches;
next	1.21;
commitid	2mvsrxqgkH3zJtlA;

1.21
date	2017.01.23.21.45.39;	author jballance;	state Exp;
branches;
next	1.20;
commitid	RH8H0PLaJmMWH8Dz;

1.20
date	2016.08.18.17.55.48;	author rsprowson;	state Exp;
branches;
next	1.19;
commitid	FuPEeIHqczGXvOiz;

1.19
date	2014.07.14.20.46.59;	author rsprowson;	state Exp;
branches;
next	1.18;
commitid	Kon1Pj6s0Ihf5oIx;

1.18
date	2014.05.31.13.49.47;	author rsprowson;	state Exp;
branches;
next	1.17;
commitid	tnhZS9XNlOrObHCx;

1.17
date	2013.10.03.07.27.09;	author rsprowson;	state Exp;
branches;
next	1.16;
commitid	iTaBDwF1woaPMO7x;

1.16
date	2013.09.30.19.47.04;	author rsprowson;	state Exp;
branches;
next	1.15;
commitid	MoU9V9JbMV2FYu7x;

1.15
date	2012.09.21.19.33.23;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	ZjhU3ErxFvpjVqlw;

1.14
date	2012.04.14.20.57.32;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	W1UWVt811sQ2xS0w;

1.13
date	2009.08.01.08.10.27;	author rsprowson;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.19.22.25.06;	author rsprowson;	state Exp;
branches;
next	1.11;

1.11
date	2009.04.15.16.00.08;	author bavison;	state Exp;
branches;
next	1.10;
commitid	GhZBwZ2GN8lg58Kt;

1.10
date	2004.01.09.11.28.01;	author bavison;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.07.13.38.49;	author bavison;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.19.17.18.38;	author bavison;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.16.18.14.17;	author rsprowson;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.16.10.22.03;	author rsprowson;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.14.13.51.16;	author rsprowson;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.21.11.31.40;	author sbrodie;	state Exp;
branches;
next	1.3;

1.3
date	99.04.19.15.27.09;	author sbrodie;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.12.52.17;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	98.12.03.13.54.46;	author sbrodie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.12.03.13.54.46;	author sbrodie;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	98.12.11.17.26.30;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	98.12.14.14.57.36;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.01.08.14.04.24;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.4;

1.1.1.1.2.4
date	99.01.11.15.35.24;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.5;

1.1.1.1.2.5
date	99.01.22.16.02.41;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.6;

1.1.1.1.2.6
date	99.02.03.12.51.41;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.7;

1.1.1.1.2.7
date	99.02.05.15.57.21;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Fix for double name translation, header ordering
Detail:
  Xlate.c: Directory names containing characters requiring translation (eg. "AcornC/C++", "A B/C") would be translated twice, leading to a 'Directory not found' error when trying to open a file within. Submission from Colin Granville.
  TCPIP.h: Order the headers so that 'netdb.h' comes after its dependents. Submission for TCP/IP bounty.
Admin:
  Test case test/Contentious run, passed OK.

Version 2.62. Tagged as 'LanManFS-2_62'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
*  Lan Manager client
*
*  Xlate.C --  DOS to  RISCOS name & attrib mapping
*
*  Versions
*  07-03-94 INH Original
*
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "swis.h"
#include "Interface/MimeMap.h"

#include "stdtypes.h"
#include "LanMan.h"
#include "Xlate.h"
#include "Attr.h"
#include "Omni.h"
#include "LMVars.h"
#include "SMB.h"
#include "Transact.h"
#include "NameCache.h"

#ifdef LONGNAMES
#define FileChar_TypedNamePrefix        ','
#define FileString_DeadFile             "xxx"
#define FileString_UntypedFile          "lxa"

/* Magic value used to indicate an incomplete file - used by the Filer,
 * for example, when writing a new file
 */
static const int deaddead = (int)0xDEADDEAD;
#endif

/* Macro returns non-zero if the specific load address is indicative of
 * a filetyped object.   Rather than checking for the top 12 bits being
 * set, it's much quicker to arithmetic shift it right 20 bits and test
 * for -1.  (Norcroft generates:  MVN rn, #0: TEQ rn, ra, ASR #20)
 */
#define IS_FILETYPED(load_addr) ((((signed int)(load_addr)) >> 20) == -1)

/* Extracts the filetype from a load address.  Assumes that IS_FILETYPED
 * would return non-zero.  In isolation, Norcroft generates:
 * MOV ra, ra, LSL #12: MOV ra, ra, LSR #20.
 */
#define GET_FILETYPE(load_addr) ((((unsigned int)(load_addr)) << 12) >> 20)

/* Encodes a filetype into a load address - Norcroft compiler makes a
 * nice job of this macro (result in load): ORR rn, load, #0xf0000000
 * ORR rn, rn, #0x0FF00000: MOV load,load,LSL #12:
 * EOR load, type, load LSR #20: EOR load,rn,load LSL #8
 */
#define ENCODE_FILETYPE(load,type) (((load)|0xFFF00000)^((GET_FILETYPE(load)^(type))<<8))



/* stricmp(): ignore-case string compare ------------------------ */
/* returns 0 if they match, > 0 if s1 > s2, < 0 if s1 < s2 */

/* Function to compare two strings case insensitively
 *
 * Originally: sbrodie
 *
 * Parameters: matches those of strcmp.
 * Result: matches the exit conditions of strcmp.
 *
 *
 * The conversions to unsigned int stop the compiler messing around with
 * shifts all over the place whilst trying to promote the chars to int
 * whilst retaining the sign.
 *
 * Problems: Choice of return value when strings do not match is based
 *           upon character number rather than any alphabetic sorting.
 *
 */
int stricmp(const char *first, const char *second)
{
  for (;;) {
    unsigned int a = *first++;
    unsigned int b = *second++;
  
    if (a == 0) return -b;
    if (a != b) {
      unsigned int c = (unsigned int) tolower(a);
      unsigned int d = (unsigned int) tolower(b);
      signed int result = c - d;
      if (result != 0) return result;
    }
  }
}

/* strcpyn(): copies a string with given max length. Note that
    unlike strncpy(), this will always correctly put terminating
    zeros on the end. len is the max number of characters including
    terminating zero to copy (= length of buffer where result is to
    be put).
*/

void strcpyn ( char *d, const char *s, int len )
{
#ifdef OLD_SLOW_METHOD
  while ( --len > 0 && *s != 0 )
    *d++ = *s++;
  *d = 0;
#else
  *d = 0;
  (void) strncat(d, s, len);
#endif
}

/* strcpyn_upper(): copies a string making all characters uppercase --- */

void strcpyn_upper ( char *d, const char *s, int len )
{
  while ( --len > 0 && *s != 0 )
   *d++ = toupper (*s++);

  *d=0;
}

/* strcpyn_lower(): doubtless you can guess --- */

void strcpyn_lower ( char *d, const char *s, int len )
{
  while ( --len > 0 && *s != 0 )
   *d++ = tolower (*s++);

  *d=0;
}

/* -------------------------- */

static const ushort daycount[13] =
{
  0,
  0,      /* Jan=31 */
  31,     /* Feb=28 */
  59,     /* Mar=31 */
  90,     /* Apr=30 */
  120,    /* May=31 */
  151,    /* Jun=30 */
  181,    /* Jul=31 */
  212,    /* Aug=31 */
  243,    /* Sep=30 */
  273,    /* Oct=31 */
  304,    /* Nov=30 */
  334     /* Dec=31 */
};

/* --------------------------- */

/* Directory entries, as returned from the 'search' command
   have the time & date returned in a packed-binary DD/MM/YY
   HH:MM:SS format. This routine converts it to 'Utime',
   which is the format used in other DOS calls.
*/

static uint DMYtoUtime ( int dtime, int ddate )
{
  uint x, dd, mm, yy, hrs, min, sec;

  dd = ddate & 31;
  mm = (ddate >> 5) & 15;
  yy = ((ddate >> 9) & 127); /* Years since 1980 */
  sec = (dtime & 31) << 1;
  min = (dtime >> 5) & 63;
  hrs = (dtime >> 11) & 31;

  /*
  debug2("%08x %08x => ", dtime, ddate);
  debug3("HH:MM:SS => %02d:%02d:%02d   ", hrs, min, sec);
  debug3("DD:MM:YY => %02d:%02d:%04d \n", dd, mm, yy + 1980);
  */

  /* Calc. no. of days since 1-1-70 */
  x = 3652 + (yy*365) + ((yy+3)/4);
  x += daycount[mm] + (dd-1);
  if ( mm >= 3 && ((yy & 3)==0) ) /* March or later, in leap year */
    x++;

  return ((x*24+hrs)*60+min)*60 + sec;
}



/* ----------------------- */

/* Xlt_CnvDOStoRO translates DOS attributes into RISCOS attributes;
   it is used by a variety of read-info calls. Flags can be passed
   to specify whether the date/time or the 'flags' are to be converted.

   The file type filled in the 'load address' and 'exec address' is a
   default value; if this is important, Attr_GetInfo() should be
   called to fill this in accurately.

*/

void Xlt_CnvDOStoRO ( DOS_ATTRIBS *pDA, RISCOS_ATTRIBS *pRA, int flags )
{
  uint thi, tlo;

/* The "load address" attribute used by RISCOS is equal to
   0xFFFtttdd, where ttt is a 12-bit file type and dd is
   bits 32..39 of the time stamp. This is defined as the number
   of centiseconds since 01-Jan-1900.

   DOS deals (in the main) with time as 'Utime' - the number of seconds
   since 01-Jan-1970, which is to be RISCOS time 0x33 6E99 6A00.
   Hence the conversion is relatively simple.
     RISCOS time = 336E996A00h + 100*Utime
*/

  if ( flags & CNV_DATETIME )
  {
    thi = 0x336E99 + (pDA->utime >> 16) * 100;
    tlo = 0x6A00 + (pDA->utime & 0xFFFF) * 100;

    /* Total = (thi << 16)+tlo; */

    pRA->loadaddr = 0xFFF00000 + ( (thi+ (tlo >> 16) ) >> 16) +
                       (LM_Vars.default_type << 8); /* Default type */
    pRA->execaddr = (thi << 16) + tlo;
  }


  if ( flags & CNV_ATTRIBS )
  {
    if ( pDA->attr & ATTR_DIR )
    {
      pRA->flags = (pDA->attr & ATTR_RO) ? ROA_LOCKED :0;
    }
    else
    {
      pRA->flags = (pDA->attr & ATTR_RO) ? ROA_READ | ROA_LOCKED :
                       ROA_READ | ROA_WRITE;
    }
  }
}

/* --------------------------- */

/* Xlt_CnvROtoDOS converts RISCOS attributes to DOS attributes;
   this is usually prior to some set-attributes call.
*/

void Xlt_CnvROtoDOS ( RISCOS_ATTRIBS *pRA, DOS_ATTRIBS *pDA, int flags )
{
  uint x, res;
  /* Here, we convert RISCOS time to DOS Utime. Here,
     Utime = (RISCOStime - 0x336E996A00h) / 100 */

  if ( flags & CNV_DATETIME )
  {
    if ( !IS_FILETYPED(pRA->loadaddr) )
    {
      /* If this is not a time/date/type-stamped file... */
      pDA->utime = 0;
    }
    else
    {
      x = ((pRA->loadaddr & 0xFF) << 24) + (pRA->execaddr >> 8);
      /* Clip these values to DOS range */
      if ( x < 0x336E996A )
        x = 0;
      else
        x -= 0x336E996A;

      if ( x >= 100 * 0xFFFFFF ) x = 100*0xFFFFFF;
      res = x/100;
      x = ((x - res*100) << 8) + (pRA->execaddr & 0xFF);
      res = (res << 8) + (x / 100);
      pDA->utime = res;
    }
  }

  if ( flags & CNV_ATTRIBS )
  {
    if ( (pRA->flags & ROA_WRITE) == 0 &&
         (pRA->flags & ROA_LOCKED)  != 0
       )
      pDA->attr = ATTR_ARC | ATTR_RO;
    else
      pDA->attr = ATTR_ARC;
  }
}

/* --------------------------- */

/* Xlt_Jumble() and Xlt_Unjumble() are used to avoid keeping passwords
   lying round in plain text in memory; it's hardly invincible,
   but it'll stop people spotting passwords simply by dumping memory.

   All strings passed to Jumble & Unjumble should be NAME_LIMIT bytes
   long.
*/

void Xlt_Jumble ( char *str )
{
  int i;
  uint key = (uint) str | 0x40000;

  for ( i=0; i < NAME_LIMIT; i++ )
  {
    key <<= 1;
    if ( key & 0x80000 )
      key ^= 39;
    *str -= (key ^ 0x40);
    str++;
  }
}

/* ------------------- */

void Xlt_Unjumble ( char *str )
{
  int i;
  uint key = (uint) str | 0x40000;

  for ( i=0; i < NAME_LIMIT; i++ )
  {
    key <<= 1;
    if ( key & 0x80000 )
      key ^= 39;
    *str += (key ^ 0x40);
    str++;
  }
}

/* Name conversion, etc =========================================== */

static char Xlt_DefaultDrv = 'A';

/* Wildcards, it seems, are not in fact used:
   A 'delete' operation reads directory entries
   first, and passes us individual filenames to
   delete. A 'rename' operation tries to do a
   'get file info' function on the wildcarded
   filename, then complains when it fails. ADFS
   doesn't allow wildcarded renames (although it
   does allow "move to new directory" renames), so
   we won't either. This means we can dispense with
   all wildcards in filenames.
*/

/* Character translate table ------------- */

#define CH_END  0
#define CH_ERR  1
#define CH_WILD 2
#define CH_PATH 3
#define CH_SEP  4
#define CH_DUD '_'

/*
  Illegal in DOS names:    SPACE / < > ? + , ; = [ ] : * \ " | DEL
  Illegal in RISCOS names: SPACE . $ ^ # &   % @@     : * \ " | DEL
  Additionally:
    All control characters are bad
    All top bit set characters are swapped for _
*/
static const char xlt_RO2DOS[256] =
{
  CH_END, CH_ERR, CH_ERR, CH_ERR, CH_ERR, CH_ERR, CH_ERR, CH_ERR, /* 00-07 */
  CH_ERR, CH_ERR, CH_END, CH_ERR, CH_ERR, CH_END, CH_ERR, CH_ERR, /* 08-0F */
  CH_ERR, CH_ERR, CH_ERR, CH_ERR, CH_ERR, CH_ERR, CH_ERR, CH_ERR, /* 10-17 */
  CH_ERR, CH_ERR, CH_ERR, CH_ERR, CH_ERR, CH_ERR, CH_ERR, CH_ERR, /* 17-1F */

/* SPACE   !       "       #       $       %       &       '         20-27 */
  CH_ERR, '!',    CH_ERR, CH_WILD,CH_ERR, CH_ERR, CH_ERR, '\'',
/* (       )       *       +       ,       -       .       /         28-2F */
  '(',    ')',    CH_WILD,'&',    CH_ERR, '-',    CH_PATH,CH_SEP,
/* 0       1       2       3       4       5       6       7         30-37 */
  '0',    '1',    '2',    '3',    '4',    '5',    '6',    '7',
/* 8       9       :       ;       <       =       >       ?         38-3F */
  '8',    '9',    CH_ERR, '%',    '$',    '@@',    '^',    '#',
/* @@       A       B       C       D       E       F       G         40-47 */
  CH_ERR, 'A',    'B',    'C',    'D',    'E',    'F',    'G',
  'H',    'I',    'J',    'K',    'L',    'M',    'N',    'O',
  'P',    'Q',    'R',    'S',    'T',    'U',    'V',    'W',
/* X       Y       Z       [       \       ]       ^       _         58-5F */
  'X',    'Y',    'Z',    CH_ERR, CH_ERR, CH_ERR, CH_ERR, '_',
/* `       a       b       c       d       e       f       g         60-67 */
  '`',    'A',    'B',    'C',    'D',    'E',    'F',    'G',
  'H',    'I',    'J',    'K',    'L',    'M',    'N',    'O',
  'P',    'Q',    'R',    'S',    'T',    'U',    'V',    'W',
/* x       y       z       {       |       }       ~       DEL       78-7F */
  'X',    'Y',    'Z',    '{',    CH_ERR, '}',    '~',    CH_ERR,

  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,

  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,

  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,

  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD
};

static const char xlt_DOS2RO[256] =
{
  CH_END, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, /* 00-07 */
  CH_DUD, CH_DUD, CH_END, CH_DUD, CH_DUD, CH_END, CH_DUD, CH_DUD, /* 08-1F */
  CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, /* 10-17 */
  CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, /* 17-1F */

/* SPACE   !       "       #       $       %       &       '         20-27 */
  CH_DUD, '!',    CH_DUD, '?',    '<',    ';',    '+',    '\'',
/* (       )       *       +       ,       -       .       /         28-2F */
  '(',    ')',    CH_DUD, CH_DUD, CH_DUD, '-',    CH_SEP, CH_DUD,
/* 0       1       2       3       4       5       6       7         30-37 */
  '0',    '1',    '2',    '3',    '4',    '5',    '6',    '7',
/* 8       9       :       ;       <       =       >       ?         38-3F */
  '8',    '9',    CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD,
/* @@       A       B       C       D       E       F       G         40-47 */
  '=',    'A',    'B',    'C',    'D',    'E',    'F',    'G',
  'H',    'I',    'J',    'K',    'L',    'M',    'N',    'O',
  'P',    'Q',    'R',    'S',    'T',    'U',    'V',    'W',
/* X       Y       Z       [       \       ]       ^       _         58-5F */
  'X',    'Y',    'Z',    CH_DUD, CH_DUD, CH_DUD, '>',    '_',
/* `       a       b       c       d       e       f       g         60-67 */
  '`',    'a',    'b',    'c',    'd',    'e',    'f',    'g',
  'h',    'i',    'j',    'k',    'l',    'm',    'n',    'o',
  'p',    'q',    'r',    's',    't',    'u',    'v',    'w',
/* x       y       z       {       |       }       ~       DEL       78-7F */
  'x',    'y',    'z',    '{',    CH_DUD, '}',    '~',     CH_DUD,

  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,

  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,

  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,

  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD
};

static err_t nameROtoDOS ( char *dst, char *src )
{
  int ch;
  int o_name= 0;
  int o_ext = 0;

  while (1)  /* Process as many chars as we can */
  {
    ch = xlt_RO2DOS[(*src++) & 0xFF];

    /* o_name counts the number of characters in the
       'name' part which we have output, in the range 0..8;
       it is set to 9 when we are outputting the 'ext' part.
       o_ext counts the number of characters in the 'ext'
       part which we have output.
    */

    switch( ch )
    {
      case CH_END:      /* End of string */
        *dst = 0;
        return OK;

      case CH_ERR:      /* No-good chars */
        return EBADNAME;

      case CH_WILD:
        return ENOWILDCARD;

      case CH_PATH:      /* RISCOS pathname separator */
        *dst++ = '\\';
        o_name = 0;
        o_ext = 0;
        continue;

      case CH_SEP:      /* Separator for name/ext */
        if ( o_name >= 1 && o_name <= 8 )
        {
          *dst++ = '.';
          o_name = 9;   /* Stop any more */
        }
        continue;

      default:
        if ( o_name == 8 ) /* Time for a separator? */
        {
          *dst++ = '.';
          *dst++ = '~';
          *dst++ = ch;
          o_name = 9;
          o_ext  = 2;
        }
        else if ( o_name < 8 )
        {
          *dst++ = ch;
          o_name++;
        }
        else if ( o_ext < 3 )
        {
          *dst++ = ch;
          o_ext++;
        }

        continue;
    }
  }

}



/* -------------------------- */

void Xlt_NameDOStoRO ( char *dst, char *src )
{
  int i, c;
  int lcl_name_mode = LM_Vars.namemode & (NM_LOWERCASE | NM_FIRSTCAPS | NM_PRESERVED);

  for ( i=0; i<12; i++ )      /* Up to 12 chars in 8.3 name */
  {
    c = xlt_DOS2RO[src[i] & 0xFF];

    if ( c == CH_END )
      break;

    if ( c == CH_SEP ) /* Name/ext separator */
    {
      if ( i == 8 && src[9] == '~' ) /* Skip ".~" */
        i=9;
      else
        *dst++ = '/';
    }
    else switch (lcl_name_mode)
    {
      case NM_LOWERCASE:
        *dst++ = tolower(c);
        break;

      case NM_FIRSTCAPS:
        if ( isalpha(c) )
        {
          *dst++ = toupper(c);
          lcl_name_mode = NM_LOWERCASE;
          break;
        }
        /* else drop through into */
      case NM_PRESERVED:
      default:
        *dst++ = c;
        break;

    }
  }

  *dst = 0;
}

#ifdef LONGNAMES

/* OK, the mappings for long filename discs are different.
 *
 * They are:
 *
 *       DOS     ->     RISC OS         ->       DOS
 *
 *        *                *                      *    (wildcard)
 *        ?                #                      ?    (wildcard)
 *        #                ?                      #    (swap match for above)
 *
 *        :                :                      :    (won't be seen)
 *        \                .                      \    (dir sep)
 *        .                /                      .
 *
 *        &                +                    + or &
 *        +                +                    & or +
 *        @@                =                    @@ or =
 *        =                =                    = or @@
 *        %                >                    % or >
 *        >                >                    > or %
 *        $                <                    $ or <
 *        <                <                    < or $
 *        ^                ,                    ^ or ,  (don't like this map)
 *        ,                , (or extn)          , or ^
 *      space          hard space               space or hard space
 *    hard space       hard space               hard space or space
 *
 */
static const char lanmanfs_lookup_table[257]=
     "________________________________"
     "\xa0!\"?<>+'()*+,-/_0123456789:;<=>#"
     "=ABCDEFGHIJKLMNOPQRSTUVWXYZ[.],_"
     "`abcdefghijklmnopqrstuvwxyz{|}~_"
     "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü"
     "\xa0°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø"
     "¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ"
     "‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ";

static const char lanmanfs_inverse_lookup_table[257]=
     "________________________________"
     "\x20!\"?$%+'()*+,-\\.0123456789:;<=>#"
     "=ABCDEFGHIJKLMNOPQRSTUVWXYZ[.],_"
     "`abcdefghijklmnopqrstuvwxyz{|}~_"
     "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü"
     "\x20°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø"
     "¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ"
     "‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ";


/* These two structures MUST be kept in step in order to allow the
 * wildcard resolution code to function correctly.
 */
static const char lanmanfs_contentious_characters[]=
     "+=><,\x20";
static const char lanmanfs_contentious_pairing[]=
     "&@@%$^\xa0";

/* Translate DOS names to RISC OS names using the translation table
 *
 * This routine translates the given DOS filename into the RISC OS filename,
 * stripping the file extension if there is one and setting up the pRA
 * structure with the type details of the file.
 */
static void Xlt_NameDOStoROX2 ( char *dst, char *src, RISCOS_ATTRIBS *pRA )
{
  int i;
  char *odst = dst;

  for ( i=0; i<(DOS_NAME_LEN-1); i++ )      /* Length limit is 255 chars */
  {
    int c = src[i] & 0xFF;
    if (c == 0) break; /* Found the terminator */
    *dst++ = lanmanfs_lookup_table[c];
  }

  *dst = 0;
  dst = strrchr(odst, '.');
  if (dst == NULL) dst = odst; else ++dst;
  if (dst != NULL) {
    if (Xlt_SplitLeafnameX2 ( dst, pRA, &dst ) == OK) {
      /* Strip off the extension */
      *dst = 0;
    }
  }
}

/* This function copies the string src to dst.  Once it gets past the
 * level'th character, it maps each character through the RISC OS->DOS
 * character conversion table.
 *
 * This means that partially converted filenames can be copied verbatim
 * and the not-yet-done portions translated as required.
 */
static void Xlt_CopyViaInverseTable( char *dst, const char *src, int level )
{
  int i;

  for ( i=0; i<(DOS_NAME_LEN-1); i++ )
  {
    int c = src[i] & 0xFF;
    if (c == 0) break;
    if (level != 0) { /* Whole path has already been through  */
      dst[i] = c;     /* inverse lookup table when level != 0 */
    }
    else {
      dst[i] = lanmanfs_inverse_lookup_table[c];
    }
  }
  dst[i] = 0;
}

/* Temporary state data structure for the filename mangling */
typedef struct {
        char *dstcpy;
        char dstcpybuf[DOS_NAME_LEN + 4];
        char matchbuf[DOS_NAME_LEN + 4];
} Xlt_NXCX2_Data;


/* Xlt_ContentiousCharCheck
 *
 * Checks contentious characters. Returns the actual remote char if
 * the chars are not equal but match under the contentious char table.
 * Returns '\0' if no match is found.
 */
static char Xlt_ContentiousCharCheck(char e, char d)
{
   int i;

   for (i=0; lanmanfs_contentious_characters[i]; ++i) {
     if ((e == lanmanfs_contentious_characters[i] ||
          e == lanmanfs_contentious_pairing[i]) &&
         (d == lanmanfs_contentious_characters[i] ||
          d == lanmanfs_contentious_pairing[i])) {
            return e;
          }
   }

   return '\0';
}

/* An unusual routine.  The SMB_ReadDirectoryEntriesX2 routine calls this
 * function back in order to process each directory entry as it is
 * discovered whilst we are searching for filename matches.  In order to
 * get that routine to stop when we have found a match, we return it a
 * value of EOUTOFMEM.  If we want it to continue, we return OK.  The
 * private handle (_dst) is actually a pointer to the state structure
 * and that structure is updated with the real filename once a match
 * has been found.  The format parameter should always be 1.
 */
static err_t Xlt_NameXlateCallbackX2 ( BYTE *entry, int format, bool *taken, void *_dst )
{
    Xlt_NXCX2_Data *dst = _dst;
    char *eptr = (char *) (entry + 23);
    char *dptr = 1 + strrchr(dst->matchbuf, '\\');
    err_t res = OK;

    (void) format; /* Unused */
    *taken = true;

    if (dst->dstcpy[0] != '*') {
      return EOUTOFMEM;
    }

    for (;;) {
      char e = *eptr++;
      char d = *dptr++;

      if (e == d || toupper(e) == toupper(d)) {
        if (e) continue;
        /* We have a match */
        res = EOUTOFMEM;
        break;
      }
      else if (e == ',' && d == 0) {
        /* Might have been a filetype suffix */
        int type, num;
        if ((sscanf(eptr, "%x%n", &type, &num) == 1 && num == 3)
          || strcmp(eptr, FileString_DeadFile) == 0
          || strcmp(eptr, FileString_UntypedFile) == 0) {
          /* It was */
          res = EOUTOFMEM;
          break;
        }
      }
      else {
        if (!Xlt_ContentiousCharCheck(e, d)) {
          /* No match */
          return OK;
        }
      }
    }

    if (res == EOUTOFMEM) {
      /* Update stored leafname */
      if (dst->dstcpy[0] == '*') {
         dst->dstcpy[0] = '\0';
         NameCache_Add(dst->dstcpybuf, entry);
      }
      strcpy(dst->dstcpy, (char *) entry+23);
    }
    return res;
}

/* Map RISC OS names onto DOS names.  Complicated by the need to
 * resolve the duplicate mapped characters.  All lookups invoke a
 * directory search at the remote end, looking for the actual object
 * name.  If any of the path components have nasty characters in them,
 * then sub-searches are performed to resolve those too.  Only a single
 * level of recursion is required (and supported).
 */
static err_t Xlt_NameROtoDOSX2_sub ( char *dst, char *src, int level )
{
  static Xlt_NXCX2_Data private;
  static Transact_SearchContext con;
  char *inptr;
  int   i;
  err_t status;

  private.matchbuf[0] = dst[0];
  private.matchbuf[1] = dst[1];
  Xlt_CopyViaInverseTable(private.matchbuf + 2, src, level);
  debug0("\n\n");
  debug1("Xlt_NameROtoDOSX2: `%s'\n", src);
  debug1("Xlt_CopyViaInverseTable -> `%s'\n", private.matchbuf);

  /* Construct the search pathname buffer, by taking the parent directory
   * and ensuring that the name ends \*
   * private.dstcpy must point at the * character so that the callback
   * function can write the matched target name straight in
   */
#if 0 /* No side effects */
  (void) NameCache_Locate(private.matchbuf);
#endif
  strcpy(private.dstcpybuf, private.matchbuf);
  private.dstcpy = strrchr(private.dstcpybuf, '\\');
  if (private.dstcpy) {
    strcpy(++private.dstcpy, "*");
  }
  else {
    private.dstcpy = strchr(private.dstcpybuf, '\0');
    strcpy(private.dstcpy, "\\*");
  }

  debug1("Xlt_NameROtoDOSX2 initiates a dir search of `%s'\n",
    private.dstcpybuf);

  if (level == 0)
  for (inptr = private.dstcpybuf + 2 + level; inptr != private.dstcpy; ++inptr) {
    if (Xlt_ContentiousCharCheck(*inptr, *inptr)) {
      /* We have a problem - there are contentious characters in the
       * path leading to the actual object we are going to seek!
       * We now have to mess about doing sub-searching for the required
       * contentious directory names, remembering to patch back the
       * private.matchbuf with the matched name so that if any search
       * component fails (eg. the top-level one when the object does
       * not exist (consider *Cdir or *Create)) does remember the path
       * did exist.
       */
      static Xlt_NXCX2_Data sub_search;
      static char srccpy[DOS_NAME_LEN];
      char *ptr, preserved, *okptr;
      size_t len;

      /* Preserve existing state whilst sub-search is performed */
      sub_search = private;

      /* Duplicate source string and truncate it appropriately for
       * the sub-search target
       */
      strcpy(srccpy, private.matchbuf + 2);
      okptr = srccpy + (inptr - (private.dstcpybuf + 2));
      while (okptr != srccpy && *okptr != '\\') --okptr;
      ptr = srccpy + (inptr - (private.dstcpybuf + 2));
      while (*ptr != '\0' && *ptr != '\\') ++ptr;
      preserved = ptr[0];
      ptr[0] = '\0';
      /* Search for the name.  Don't worry about failures, dst will be
       * safe to use whatever the result
       */
      Xlt_NameROtoDOSX2_sub(dst, srccpy, okptr - srccpy + 1);
      len = strlen(dst);
      ptr[0] = preserved;
      /* Restore state, update matchbuf (answer on fail), and dstcpybuf
       * (current copy buffer).
       */
      private = sub_search;
      memcpy(private.dstcpybuf, dst, len);
      memcpy(private.matchbuf, dst, len);
      /* Skip to next component - we've already tried to resolve this
       * one and, with success or failure, we already have the best we
       * can do for this component
       */
      inptr = private.dstcpybuf + len;
    }
  }

  debug1("Xlt_NameROtoDOSX2 initiates a dir search of `%s' (post-mangle)\n",
    private.dstcpybuf);

  /* Repeatedly search the directory until we find a match, or there are
   * no more entries to be read back
   */
  con.resume_key = 0;
  for (status = OK, inptr = private.dstcpybuf; status == OK; inptr = NULL) {
    status = SMB_ReadDirEntries(inptr, 32, Xlt_NameXlateCallbackX2,
                                &private, &con);
    switch (status) {
      case OK:
        /* More entries to read, and no match found yet */
        break;

      case EOUTOFMEM:
        /* Found it */
        strcpy(dst, private.dstcpybuf);
        debug1("**RIGHT.  Got a match: `%s'\n", dst);
        break;

      default:
        /* Definitely didn't find it - revert to original filename
         * or at least filename with nasties resolved as far as possible
         */
        strcpy(dst, private.matchbuf);
        debug1("**WRONG.  Not got a match. Reverting to `%s'\n", dst);
        break;
    }
  }

  /* Go back and respect the case given regardless of the case on the
   * server so that "*RENAME Test TEST" does something
   */
  i = 0;
  while (src[i]) {
    if (isalpha(src[i])) dst[i + 2] = src[i];
    i++;
  }

  return OK;
}

/* Kicks off the RISC OS to DOS name conversion process - setting up the
 * number of already-translated characters as zero.
 */
static err_t Xlt_NameROtoDOSX2 ( char *dst, char *src )
{
  if (strchr(src, '*') != NULL) return ENOWILDCARD; /* As per nameROtoDOS() */
  return Xlt_NameROtoDOSX2_sub(dst, src, 0);
}

#endif

/* --------------------------- */


err_t Xlt_SetDefaultDrv ( char *dospath )
{
  Xlt_DefaultDrv = dospath[0];
  return OK;
}

/* --------------------------- */

static char mount_name[20];

err_t Xlt_ConvertPath ( char *name_in, char *name_out )
{
  int i;
  char drvc = Xlt_DefaultDrv;

  if ( name_in[0] == ':' )  /* Mount name is given */
  {
    name_in++;
    for (i=0; i<19; i++)
    {
      mount_name[i] = name_in[i];
      if ( name_in[i] < ' ' )  /* Premature end of name */
        return EBADNAME;

      if ( name_in[i] == '.' )
        break;
    }

    mount_name[i] = 0;
    drvc = Omni_GetDrvLetter(mount_name);
    if ( drvc == 0 )
      return EBADDRV;

    name_in += (i+1); /* Skip '.' */
  }

  if ( name_in[0] != '$' )
    return EBADNAME;

  name_out[0] = drvc;
  name_out[1] = ':';

  if ( name_in[1] < ' ' ) /* Just '$' as pathname */
  {
    strcpy(name_out+2, "\\");
    return OK;
  }
  else if ( name_in[1] == '.' )
  {
#ifdef LONGNAMES
    /* We use a different system for long filename shares.  Call
     * the long name resolution routine if necessary
     */
    if (SMB_IsLongNameFS( name_out )) {
      return ( Xlt_NameROtoDOSX2 ( name_out, name_in+1 ) );
    }
#endif
    return ( nameROtoDOS ( name_out+2, name_in+1 ) );
  }

  name_out[0] = 0;
  return EBADNAME;
}

/* --------------------------- */

/* Gets a leaf name from a RISC OS name */

char *Xlt_GetRISCOSLeafName ( char *name_in )
{
  char *tmp;
  tmp = strrchr ( name_in, '.' );
  return ( tmp == NULL ) ? name_in : tmp + 1;
}

/* Directory entry conversion ================================== */

err_t Xlt_ExpandSearchEntry ( BYTE *entry, char *path_base,
            char *name_out,
            DOS_ATTRIBS *da_out,
            RISCOS_ATTRIBS *ra_out )
{
  /* Old SMBsearch format.  For reference, entry points to the following
   * structure (treat strictly as byte array with no padding except where
   * stated:
   *  BYTE find_buf_attr;
   *  WORD find_buf_time;
   *  WORD find_buf_date;
   *  WORD find_buf_size_l;
   *  WORD find_buf_size_h;
   *  BYTE find_buf_pname[13];  ASCII - NUL terminated
   * =====
   *   22  bytes.
   */
  DOS_ATTRIBS da;

  if ( entry == NULL )
    return EBADPARAM;

  if ( name_out != NULL )
  {
    Xlt_NameDOStoRO ( name_out, (char *)entry+9 );
  }

  if ( da_out != NULL || ra_out != NULL )
  {
    da.attr   = entry[0];
    da.utime  = DMYtoUtime ( entry[1] + (entry[2] << 8),
                          entry[3] + (entry[4] << 8) );
    da.length = entry[5] + (entry[6]<<8) +
                       (entry[7]<<16) + (entry[8]<<24);

    if ( da_out != NULL )
      *da_out = da;

    if ( ra_out != NULL )
    {
      Xlt_CnvDOStoRO ( &da, ra_out, CNV_DATETIME+CNV_ATTRIBS );
      Attr_GetInfo ( path_base, (char *)entry+9, ra_out );
    }
  }

  return OK;
}

#ifdef LONGNAMES
err_t Xlt_ExpandSearchEntryX2 ( BYTE *entry, char *path_base,
            char *name_out,
            DOS_ATTRIBS *da_out,
            RISCOS_ATTRIBS *ra_out )
{
  /* New TRANSACT2/FINDFIRST format.  For reference, entry points to the
   * following structure (treat strictly as byte array with no padding
   * except where stated:   (SMB_DATE and SMB_TIME are actually WORD)
   *
   * WORD   CreationDate
   * WORD   CreationTime
   * WORD   LastAccessDate
   * WORD   LastAccessTime
   * WORD   LastWriteDate
   * WORD   LastWriteTime
   * DWORD  DataSize
   * DWORD  AllocationSize
   * WORD   Attributes
   * BYTE   FilenameLength
   * STRING FileName
   * =====
   */
  DOS_ATTRIBS da;
  RISCOS_ATTRIBS ra_name;

  (void) path_base; /* Unused */
  
  if ( entry == NULL )
    return EBADPARAM;

  if ( name_out != NULL )
  {
    Xlt_NameDOStoROX2 ( name_out, (char *)entry+23, &ra_name );
  }
  else
  {
    char *dst;
    if (Xlt_SplitLeafnameX2 ( (char *)entry+23, &ra_name, &dst ) == OK) {
      *dst = 0;
    }
  }

  if ( da_out != NULL || ra_out != NULL )
  {
    da.attr   = entry[20];
    da.utime  = DMYtoUtime ( entry[10] + (entry[11] << 8),
                          entry[8] + (entry[9] << 8) );
    da.length = entry[12] + (entry[13]<<8) +
                       (entry[14]<<16) + (entry[15]<<24);

    if ( da_out != NULL )
      *da_out = da;

    if ( ra_out != NULL )
    {
      /* Always populate the access attributes of ra_out */
      Xlt_CnvDOStoRO ( &da, ra_out, CNV_DATETIME+CNV_ATTRIBS );
      if (IS_FILETYPED(ra_name.loadaddr))
      {
        /* Mix the filetype in with the date and time from Xlt_CnvDOStoRO */
        ra_out->loadaddr = (ra_out->loadaddr & 0xFFF000FF) | (ra_name.loadaddr & 0x000FFF00);
      }
      else
      {
        /* Unstamped, so force back to those discovered by Xlt_SplitLeafnameX2 */
        ra_out->loadaddr = ra_name.loadaddr;
        ra_out->execaddr = ra_name.execaddr;
      }
    }
  }

  return OK;
}

/* Xlt_SplitLeafname2
 *
 * This routine examines the supplied leafname/pathname and looks to
 * see if it has a type suffix.  If it does, then the type suffix is
 * decoded and the RISCOS_ATTRIBS structure is updated to hold the
 * load/exec address data, a pointer to the type suffix separator (the
 * comma) is stored in *terminator and the function returns OK.  The
 * caller can strip the suffix by zeroing the byte pointed to by
 * *terminator.  If there was no type suffix, ENOTPRESENT is returned
 * and NULL is stored in *terminator.
 *
 */
err_t Xlt_SplitLeafnameX2 ( char *leafname, RISCOS_ATTRIBS *pRA,
  char **terminator)
{
  int type, len;
  char *term, *oldname;
  err_t res = ENOTPRESENT;
  _kernel_swi_regs rset;

  *terminator = NULL;
  if (leafname == NULL) 
    {
    /* Oh dear - don't understand this - just claim it's text */
    pRA->loadaddr = ENCODE_FILETYPE(pRA->loadaddr, 0xFFF);
    return res;
    }

  debug1("Xlt_SplitLeafnameX2('%s',...)\n", leafname);

  term = strchr(leafname, '\0');
  oldname = leafname;
  if ((term - leafname) > 4)
     {
     /* Ah good,it's at least 5 letters long */
     leafname = term - 4;
     if (leafname[0] == FileChar_TypedNamePrefix) 
        {
        /* At least 5 letters long and of the form ",ttt" */
        if (stricmp(leafname+1, FileString_UntypedFile) == 0) 
           {
           debug0("File is untyped (,lxa)\n");
           pRA->loadaddr = pRA->execaddr = LM_Vars.untyped_address;
           *terminator = leafname;
           res = OK;
           }
        else 
           {
           if (stricmp(leafname+1, FileString_DeadFile) == 0) 
              {
              debug0("File is DEADDEAD\n");
              pRA->loadaddr = pRA->execaddr = deaddead;
              *terminator = leafname;
              res = OK;
              }
           else
              { 
              if (sscanf(leafname+1, "%x%n", &type, &len) == 1 && len == 3) 
                 {
                 /* note.  sscanf returns the number of conversions which were
                  * successfully performed.  the %n conversion never fails and
                  * does not count towards the total number of conversions, but
                  * holds the number of characters consumed from the source
                  * string.  Therefore, provided that len was 3, then we have
                  * consumed three hex digits.
                  */
                 pRA->loadaddr = ENCODE_FILETYPE(pRA->loadaddr, type);
                 *terminator = leafname;
                 debug3("Filetype is %#03x; load/exec=%#08x %#08x\n", type,
                         pRA->loadaddr, pRA->execaddr);
                 res = OK;
                 }
              }
           }
        }
     }

  if (res != OK)
     {
     /* No ",ttt" was found,try the mimemap for ".ext" */
     leafname = oldname;
     /* This function can get called with "A:\dosname.txt" paths or "riscosname/txt" leafs */
     if (leafname[1] == ':')
        {
        term = strrchr(leafname, '.');  /* strrchr catches names like "file.tar.gz" */
        }
     else
        {
        term = strrchr(leafname, '/');  /* strrchr catches names like "file/tar/gz" */
        }
     
     if (term != NULL)
        {
        /* A dot was found so try to lookup the dos style extension */
        term++;  /* Skip '.' */
        rset.r[0] = MMM_TYPE_DOT_EXTN;
        rset.r[1] = (int)term;
        rset.r[2] = MMM_TYPE_RISCOS;
        if (_kernel_swi(MimeMap_Translate, &rset, &rset) == NULL)
           {
           pRA->loadaddr = ENCODE_FILETYPE(pRA->loadaddr, rset.r[3]);
           debug2("Mimemap gave type %X for '%s'\n", rset.r[3], leafname );
           *terminator = strchr(leafname, '\0'); /* Safe to point to that null on exit */
           res = OK;
           }
        }
     }

  if (res != OK)
     {
     /* No ",ttt" and no mimemap lookup - mark as default type */
     pRA->loadaddr = ENCODE_FILETYPE(pRA->loadaddr, LM_Vars.default_type);
     } 

return res;
}
#endif

/* ------------------------------- */

#ifdef LONGNAMES
/* Trims the optional ",ttt" extension from 'name'
 * and returns the updated string
 */
err_t Xlt_RemoveROType ( char *name )
{
  RISCOS_ATTRIBS RA;
  char          *nterm;

  if (Xlt_SplitLeafnameX2( name, &RA, &nterm ) != OK) {
    /* No type information - nothing to do */
  }
  else {
    /* Poke a terminator to get just the base name */
    *nterm = '\0';
  }

  return OK;
}
#endif

/* ------------------------------- */

#ifdef LONGNAMES
/* Adds the type suffix for a RISC OS filename.  The type is extracted
 * from the passed load address, unless DOS name is sufficient
 */
int Xlt_AddROType ( char *leafname, uint loadaddr )
{
   RISCOS_ATTRIBS RA;
   char *nterm, *term;
   char typebuf[8],ftypebuf[8];
   int ftype;

   typebuf[0] = FileChar_TypedNamePrefix;
   if (loadaddr == deaddead) {
     strcpy(typebuf+1, FileString_DeadFile);
   }
   else if (!IS_FILETYPED(loadaddr)) {
     strcpy(typebuf+1, FileString_UntypedFile);
   }
   else {
     const int type = GET_FILETYPE(loadaddr);
     sprintf(typebuf+1, "%03x", type);
   }

   /* Strip any acorn filetype suffix */
   if (Xlt_SplitLeafnameX2 ( leafname, &RA, &nterm ) != OK) {
     /* No type information - find end of string */
     nterm = strchr(leafname, '\0');
   }
   else {
     /* Strip old type information in case source didn't have any either */
     *nterm = '\0';
   }
   /* Check leaf for DOS file type, else add acorn extra... */
   if (leafname[1] == ':') {
     term = strrchr(leafname, '.');  /* strrchr catches names like "file.tar.gz" */
   }
   else {
     term = strrchr(leafname, '/');  /* strrchr catches names like "file/tar/gz" */
   }

   if (term) {
     /* Found a DOS type so check the mimemap */
     if (!_swix(MimeMap_Translate, _INR(0,2)|_OUT(3),
                MMM_TYPE_DOT_EXTN, term,
                MMM_TYPE_RISCOS, &ftype)) {
        /* Got a name valid in RISCOS */
        sprintf(ftypebuf, ",%03x", ftype);
        if (!strcmp(typebuf, ftypebuf)) return 1;
     }
   }
   /* Don't append ,xxx filetype if its the default */
   sprintf(ftypebuf,",%03x",LM_Vars.default_type);
   if (strcmp(typebuf,ftypebuf)) strcat(leafname, typebuf);
   return 1;
}
#endif

/* ------------------------------- */
@


1.22
log
@Name resolution, wildcarded FSEntry_File 5 & 9, and buffer overrun fixes
Make SMB_RxWords a bit bigger per static anaylsis
  https://www.riscosopen.org/forum/forums/4/topics/9503
when LONGNAMES is undefined, since NT LM 0.12 dialect is allowed at the same time as short names.

A change to name translation in LanManFS-2_60 broke all forms of nested contentious name resolution, ie. where a leafname containing a contentious character was itself in a directory containing one.
The cited problem names ('1 2/3' and '1 /s') can both be resolved at one level only, no 2nd pass is required. The resolution function walks along the elements of the path one at a time to reach the leaf (ie. no element is processed twice). A test case has been created to allow some regression testing when making future changes in this area.

When building tboxlibint
  Copy h.* <Lib$Dir>.tboxlibint.h.*
when the directory is empty FileSwitch checks the destination ending in ...\h\* which the short names translation would error with ENOWILDCARD, but the long names translation attempts to resolve it by finding the trailing '\' and appending a '*' (ie. not doing anything), this returns no results and is passed back unfaulted. The special check in fsentry_file() for ENOWILDCARD for the two ReadCatalogueInformation thus doesn't trigger, and an attempt to FileGetAttribs() is made on the still wildcarded path. This is rejected by the server when in SMB_GetAttribsX2() does a TRANSACT2_QUERYPATHINFORMATION, which expects a non wildcarded object (on Windows servers at least), propagating an error back up to the user.
This stopped a ROM build from completing the exports phase via LanManFS on a Windows share.

Const-ify a few things.

Changed files
  Xlate.c: Revert change from revision 1.21, return ENOWILDCARD when appropriate.
  SMC.c: Increase MAX_WCT buffer size to 17.
  UK/CmdHelp: Add some missing chevrons round the command syntax for required parameters.
  test/Contentious: Test case for nested contentious character resolution code.

Version 2.61. Tagged as 'LanManFS-2_61'
@
text
@d697 2
a698 2
    if (i < level) {
      dst[i] = c;
@


1.21
log
@Resolved issue where RISC OS name '1 2/3' gets wrongly translated.
Detail:
The translate routine that converts contentious characters in  a RiscOS
file name to equivalent DOS ones was being invoked a second time. Normally
this wouldn't be critical, but a / in riscos was converted to the . in DOS,
correctly , then converted back again. This error mode with more than one
contentious character in (particularly) a directory name had recently
come to light.
Admin:
Tested by building a RiscOS rom image on a pc based LanManFS mount without
errors.

Version 2.60. Tagged as 'LanManFS-2_60'
@
text
@a842 6
#if 0
// if I'm not mistaken, the previous translate gets all the contentious chars
// so if the result contains translated chars that would then be contentious
// in riscos, they get retranslated to give incorrect result.
// e.g. riscos '.1 /s' becomes 'A:\1 .s' as expected.
// Second pass takes it to 'A:\1 \s' which is incorrect.
d892 1
a892 1
#endif
d941 1
@


1.20
log
@Fix out-by-1 error reporting monitor name
For *OPT1,2 the FS is supposed to report the leafname. LanManFS uses strrchr() to find the dot but hadn't incremented past it when returning the pointer.

Version 2.57. Tagged as 'LanManFS-2_57'
@
text
@d843 6
d898 1
a898 1

@


1.19
log
@Sync up the error messages
Due to an inability to count to 10 accurately, all the error tokens were wrong, leading to some inappropriate error messages.
Fixes problem "Message token E13 not found" when the SMB server gives a DOS error back.

Version 2.46. Tagged as 'LanManFS-2_46'
@
text
@d1015 1
a1015 1
/* Gets a leaf name from a DOS name */
d1021 1
a1021 1
  return ( tmp == NULL ) ? name_in : tmp;
@


1.18
log
@Ammendments to short name translation table
The table was ambiguously translating () to () and also [] to (). Now, we error names containing ,[] in the same manner as DOSFS.
The substitutions for ^% have also been changed to match DOSFS so copying from one to the other doesn't give two representations if viewed on a PC.
Marked both tables as const to save 512B of RMA.
This change is slightly academic since most of the time the long filename resolution is in use.

Tested against WinXP SP3 with a build with long filename support turned off.

Version 2.45. Tagged as 'LanManFS-2_45'
@
text
@d51 1
d53 1
a53 1
/* Macro returns non-zero if the specific load addressis indicative of
a71 1
#endif
d272 1
a272 1
    if ( (pRA->loadaddr & 0xFFF00000) != 0xFFF00000 )
@


1.17
log
@Internationalised
Unused LMFiler put in the attic.
As LanMan has historically put its resources into ThirdPart/OmniClient this component has no ROM resources phase - it still registers the resources at run time.

Version 2.40. Tagged as 'LanManFS-2_40'
@
text
@d373 5
a377 5
  Illegal in DOS names:    / < > ? + , ; = [ ] : * \ " | DEL
  Illegal in RISCOS names: . $ % # & ^   @@     : * \ " | DEL

  All control characters and space are bad
  All top bit set characters are swapped for _
d379 1
a379 1
static char xlt_RO2DOS[256] =
d386 1
d388 3
a390 1
  '(',    ')',    CH_WILD,'&',    '^',    '-',    CH_PATH,CH_SEP,
d392 3
a394 2
  '8',    '9',    CH_ERR, CH_DUD, '$',    '@@',    '%',    '#',

d398 3
a400 2
  'X',    'Y',    'Z',    '(',    CH_ERR, ')',    CH_ERR, '_',

d404 1
d428 1
a428 1
static char xlt_DOS2RO[256] =
d435 5
a439 2
  CH_DUD, '!',    CH_DUD, '?',    '<',    '>',    '+',    '\'',
  '(',    ')',    CH_DUD, '+',    ',',    '-',    CH_SEP, '/',
d441 3
a443 2
  '8',    '9',    CH_DUD, ';',    '<',    '=',    '>',    '?',

d447 3
a449 2
  'X',    'Y',    'Z',    '[',    CH_DUD, ']',    ',',    '_',

d453 1
d646 1
a646 1
 * wildcard resolution code function correctly.
@


1.16
log
@Makefile recreated from fragments
Fixed up a couple of trivial warnings with the stricter checking.
Removed OmniS_FastMultiply64 and rewrote the function in C, this allows the compiler to spot and use UMULL on architectures supporting that instruction.
Tested in a RAM build against a WinXP SP3 server with a drive > 4GB.

Version 2.39. Tagged as 'LanManFS-2_39'
@
text
@d32 1
a33 1
#include "stdtypes.h"
a1135 3
#endif

/* Error translation =========================================== */
a1136 38
extern _kernel_oserror *Err_XltTable[MAX_ERRS+1];

static _kernel_oserror *Xlt_OS_Error;

/* ------------------------------- */

err_t Xlt_SetOSError ( _kernel_oserror *err )
/* This is used when an error generated by RISCOS has to be
   returned as if it was one of ours - most notably, errors
   returned from processing a command line. We use a special
   error number, EXT_OS_ERROR, to denote this. */
{
  Xlt_OS_Error = err;

  if ( err == NULL )
    return OK;

  return EXT_OS_ERROR;
}

/* ------------------------------- */

_kernel_oserror *Xlt_Error ( err_t err )
{
  if ( err==0 ) return NULL;

  if ( err==EXT_OS_ERROR && Xlt_OS_Error != NULL )
    return Xlt_OS_Error;       /* Else, drop through to mysterious error */

  if ( err < 0 || err > MAX_ERRS ) /* Use 'mysterious error' */
    err=0;

  return Err_XltTable[err];
}

/* ------------------------------- */

#ifdef LONGNAMES
@


1.15
log
@Fix reporting of unstamped file info
When a file ended in ',xxx' (unfinished DEADDEAD) or ',lxa' (load/execution addresses) LanManFS was correctly identifying these internally but at the last moment OR'd the result unconditionally with 0xFFF00000 when calculating the date stamp/access attributes.
Now, an unstamped file will propagate the load & exec addresses properly.
Tested with WinXP SP3 and a variety of hand constructed examples, plus copying a large file with the filer showed the incomplete file icon until done.

Version 2.37. Tagged as 'LanManFS-2_37'
@
text
@d741 1
d1088 2
@


1.14
log
@Replace 2 (!) local definitions with MimeMap header

Version 2.36. Tagged as 'LanManFS-2_36'
@
text
@d52 1
a52 1
/* Macro returns non-zero if the specifiec load addressis indicative of
d1115 1
d1117 11
a1127 1
      ra_out->loadaddr ^= ((ra_name.loadaddr ^ ra_out->loadaddr) & (0xFFF00));
@


1.13
log
@Fix for renames where only the case has changed.
Detail:
 Added an extra check after the Xlate path resolution code so that
 the case of the path given to resolve is honoured. This now means that
 the strcmp() done in SMB_Rename fails and the rename is actually sent to
 the server. Before "*rename test Test" would have the path resolved and
 since 'test' already existed both names would be the same, in this example
 something like "*rename A:\test A:\test" would result.
Admin:
 Made the non LONGNAMES version compile again (not tested).
 Removed local definitions of FSControl reason codes, uses Interface header
 now.
 Made the case of #includes match CVS to allow future compilation on a case
 sensitive system.
 Deleted unused "Version" header.

Version 2.34. Tagged as 'LanManFS-2_34'
@
text
@d29 2
a33 1
#include "swis.h"
@


1.12
log
@Workaround for NTFS returning resume keys of zero.
Detail:
  When the underlying FS is NTFS, eg. WinXP Pro, the requested
  resume keys for a directory search are always zero - this is passed
  back via OSGBPB and on the next call it triggers a new search. So
  we get stuck in an infinite loop.
  Now checks for a resume key stuck at zero, and makes a fake one static
  to the search context then sets the continuation bit in the SMB_FIND_NEXT
  call because the server returning the duff key remembers the position.
  Dir_CallbackFn could return with "taken" undefined. Move a few lines
  higher.
  Missing "#else" added to CHECK_ARMBOOT_EXISTS so if this is disabled
  no further attempt is made to find !ArmBoot.
  Couple of typos corrected.
  Spelling of "disk" changed to "disc" in an error message.
Admin:
  Tested with XP Pro SP3 with NTFS, directories which previously hung
  the filer now open correctly. Checked with XP Home SP3 with FAT32 to
  verify behaviour unchanged from 2.32.
  Note, with large directories the initial path translation triggers a
  dir search too which takes ages compared with the actual number of
  entries returned. This could be cached to make counting far faster.

Version 2.33. Tagged as 'LanManFS-2_33'
@
text
@a24 1

d30 1
d34 3
a36 3
#include "attr.h"
#include "omni.h"
#include "lmvars.h"
d798 1
d910 9
d1187 1
a1187 1
    pRA->loadaddr |= 0xFFFFFF00;
d1205 1
a1205 2
           pRA->loadaddr = LM_Vars.untyped_address;
           pRA->execaddr = LM_Vars.untyped_address;
d1213 1
a1214 1
              debug0("File is DEADDEAD\n");
d1284 2
a1285 4
/* Copies the filetype information from one name to another.
 * Called by "rename object" and "create directory", note
 * thie routine can be called with src and dst the same
 * to simply remove an extension. This must continue to function.
d1287 1
a1287 1
err_t Xlt_CnvRenameX2 ( char *src, char *dst )
d1290 1
a1290 2
  char *terminator, *nterm;
  int cnvq = strcmp( src, dst );
d1292 2
a1293 3
  if (Xlt_SplitLeafnameX2( dst, &RA, &nterm ) != OK) {
    /* No type information - find end of string */
    nterm = strchr(dst, '\0');
d1296 1
a1296 1
    /* Strip destination's type information in case source didn't have any either */
a1299 5
  if (Xlt_SplitLeafnameX2( src, &RA, &terminator ) && cnvq) {
    /* If dst and src names truly differ apply src's type to dst */
    Xlt_AddROType(dst, RA.loadaddr);
  }

@


1.11
log
@  Multiple fixes.
Detail:
  Too many to list here: see doc/RPSChanges.
Admin:
  Received from Rob Sprowson approx 2009-02-08. Builds, but not tested by ROOL.

Version 2.32. Tagged as 'LanManFS-2_32'
@
text
@d741 1
d912 1
a912 1
/* Kicks off the DOS to RISC OS name conversion process - setting up the
@


1.10
log
@  Changes from John.
Detail:
  > Default filetype now text
  >
  > Default type given to any file that has neither a dos extent, nor a
  > ',xxx' riscos extent at the server
  >
  > Ensure that files given the default type never have a ',xxx' riscos
  > extent appended.
  >
  > Add environment variable 'LMDefaultType' which checked for a default
  > type on module initialisation .. thus setting this to (e.g.) dos, then
  > rmreinitting LanManFS will change the default type to (e.g.) dos.
Admin:
  Not tested here yet.

Version 2.29. Tagged as 'LanManFS-2_29'
@
text
@a30 1
#include "kernel.h"
a32 1

a35 1
#include "LanMan.h"
d38 1
a50 7
/* For the moment, untyped files have these invented load/exec addresses.
 * They ensure that if such a file is *Load'ed or *Run'ed, then a data
 * abort will occur
 */
static const int untyped_load = 0x03800000;
static const int untyped_exec = 0x03800000;

d69 1
a69 2
#define ENCODE_FILETYPE(load,type) \
	(((load)|0xFFF00000)^((GET_FILETYPE(load)^(type))<<8))
d95 12
a106 12
	for (;;) {
		unsigned int a = *first++;
		unsigned int b = *second++;

		if (a == 0) return -b;
		if (a != b) {
			unsigned int c = (unsigned int) tolower(a);
			unsigned int d = (unsigned int) tolower(b);
			signed int result = c - d;
			if (result != 0) return result;
		}
	}
d150 1
a150 1
static int daycount[13] =
d238 1
a238 1
                       (Default_FileType << 8); /* Default type = 'Text' */
a368 1

d371 3
a373 15
/* Current tables set


  DOS   RISCOS
  #      ?
  $      <
  %      >
  &      +
  @@      =
  ^      ,

  Illegal in RISCOS names: space * " : \ | # $ % & @@ ^ DLE

  Also: RISCOS { and [ map to DOS (, } and ] to ),
    ; and top-bit-set chars to _
d375 2
a377 1

d398 1
a398 1
  'X',    'Y',    'Z',    '(',    CH_ERR, ')',    '~',    CH_ERR,
d421 42
a532 44
/* -------------------------- */

static char xlt_DOS2RO[256] =
{
  CH_END, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, /* 00-07 */
  CH_DUD, CH_DUD, CH_END, CH_DUD, CH_DUD, CH_END, CH_DUD, CH_DUD, /* 08-1F */
  CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, /* 00-07 */
  CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, CH_DUD, /* 00-07 */

  CH_DUD, '!',    CH_DUD, '?',    '<',    '>',    '+',    '\'',
  '(',    ')',    CH_DUD, '+',    ',',    '-',    CH_SEP, '/',
  '0',    '1',    '2',    '3',    '4',    '5',    '6',    '7',
  '8',    '9',    CH_DUD, ';',    '<',    '=',    '>',    '?',

  '=',    'A',    'B',    'C',    'D',    'E',    'F',    'G',
  'H',    'I',    'J',    'K',    'L',    'M',    'N',    'O',
  'P',    'Q',    'R',    'S',    'T',    'U',    'V',    'W',
  'X',    'Y',    'Z',    '[',    CH_DUD, ']',    ',',    '_',

  '`',    'a',    'b',    'c',    'd',    'e',    'f',    'g',
  'h',    'i',    'j',    'k',    'l',    'm',    'n',    'o',
  'p',    'q',    'r',    's',    't',    'u',    'v',    'w',
  'x',    'y',    'z',    '{',    CH_DUD, '}',    '~',     CH_DUD,

  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,

  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,

  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,

  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD,
  CH_DUD, CH_DUD, CH_DUD, CH_DUD,  CH_DUD, CH_DUD, CH_DUD, CH_DUD
};
d540 1
a540 1
  int lcl_name_mode = LM_Vars.namemode & 3;
d733 1
a733 1
static err_t Xlt_NameXlateCallbackX2 ( BYTE *entry, int format, void *_dst )
d740 1
a744 5
    debug3("Xlt_NameXlateCallbackX2: checking `%s', against `%s' in `%s'\n",
        (char *) entry + 23,
        dptr,
    	dst->dstcpybuf);

d795 1
d811 1
d813 1
d883 1
d886 1
a886 1
      &private, NULL);
d891 1
d895 1
a895 1
        debug1("\n**RIGHT.  Got a match: `%s'\n", dst);
d897 1
d903 1
a903 1
        debug1("\n**WRONG.  Not got a match. Reverting to `%s'\n", dst);
d916 1
a916 1
        return Xlt_NameROtoDOSX2_sub(dst, src, 0);
d1194 2
a1195 2
           pRA->loadaddr = untyped_load;
           pRA->execaddr = untyped_exec;
d1263 2
a1264 2
     /* No ",ttt" and no mimemap lookup - mark as a Text file */
     pRA->loadaddr = ENCODE_FILETYPE(pRA->loadaddr, Default_FileType);
d1275 3
a1277 6
 * Note that the file saving routine actually uses this
 * routine to strip filetype information by passing both
 * parameters the same.  This must continue to function.
 * JB 18/12/2003 .. make sure the ,xxx is only removed IF
 * both names are NOT (identical and contains .xxx) 
 * (function only seen in file renaming so far JB)
d1282 2
a1283 2
  char  *nterm;  // *terminator
  int cnvq=strcmp(src,dst); // check if just need to strip..
d1285 1
a1285 7
  // if src and dst are same, check if it should have the ,xxx appended
  // if so, ensure it still is...
//  if(!cnvq)             // just strip...
//  {
//    if((strlen(dst)>4) && (dst[strlen(dst)-4] == ',')) cnvq++;
//  }
  if (Xlt_SplitLeafnameX2 ( dst, &RA, &nterm ) != OK) {
d1290 1
a1290 1
    /* Strip old type information in case source didn't have any either */
d1293 6
a1298 3
  Xlt_SplitLeafnameX2 ( src, &RA, &nterm ) ; // recover source's filetype
  // if not identical strings.. add type if not in dos name
  if (cnvq)Xlt_AddROType (dst,RA.loadaddr);  
d1307 1
a1307 1
 * from the passed load address. unless DOS name is sufficient
d1328 1
a1328 1
   // strip any acorn filetype suffix
d1337 2
a1338 3
   // check leaf for dos file type, else add acorn extra...
   if (leafname[1] == ':')
   {
d1341 1
a1341 2
   else
   {
d1345 9
a1353 9
   if(term)
   {                                                // found a DOS type
     if(!_swix(MimeMap_Translate,_INR(0,2)|_OUT(3), // so check the mimemap
                     MMM_TYPE_DOT_EXTN,term,
                     MMM_TYPE_RISCOS,&ftype))
     {                                              // got a name valid in RISCOS
        sprintf(ftypebuf,",%03x",ftype);       
        if(!strcmp(typebuf,ftypebuf)) return 1;     // its OK.. no need to append type
     }                 
d1355 3
a1357 2
   // Don't append ,xxx filetype if its the default
   if(strcmp(typebuf,Default_FileTName))strcat(leafname, typebuf);
@


1.9
log
@Update from John:
> Further mods to make sure that directory naming/renaming cannot attach
> the ,xxx filetyping.

Version 2.28. Tagged as 'LanManFS-2_28'
@
text
@a32 1
#include "Global/FileTypes.h"
d38 1
d248 1
a248 1
                       0xFE400; /* Default type = 'DOS' */
d1285 2
a1286 2
     /* No ",ttt" and no mimemap lookup - mark as a DOS file */
     pRA->loadaddr = ENCODE_FILETYPE(pRA->loadaddr, FileType_MSDOS);
d1385 2
a1386 1
   strcat(leafname, typebuf);
@


1.8
log
@Update from jwb - no longer appends ,xxx to filenames on server if the
filetype can already be determined from the file extension.

Version 2.27. Tagged as 'LanManFS-2_27'
@
text
@d1312 4
a1315 4
  if(!cnvq)
  {
    if((strlen(dst)>4) && (dst[strlen(dst)-4] == ',')) cnvq++;
  }
@


1.7
log
@Directory rename fixed - the mask being passed by the rename routine didn't
have the ATTR_DIR bit set.Discovered this after reading lots of the spec
which is also now included here in /doc.
Copying files out of LanManFS filer "forgot" their filetype even though
they appeared right in the filer,fixed.
A stray debugging printf removed,along with one compiler warning.
New sprites (yuck) to match !Omni.
Reordered the shutdown in two places,first Omni_Shutdown bins the mounts
lists which SMB_Shutdown uses.Second in NetBEUI mode the announcement that
a protocol has terminated goes *after* the shutdown - otherwise you sit
around for about 20s wondering where the link has gone.

Version 2.25. Tagged as 'LanManFS-2_25'
@
text
@d34 1
d1300 3
d1307 2
a1308 1
  char *terminator, *nterm;
d1310 6
d1324 3
a1326 5

  if (Xlt_SplitLeafnameX2 ( src, &RA, &terminator ) == OK) {
    (void) strcpy(nterm, terminator);
  }

d1335 1
a1335 1
 * from the passed load address.
d1340 3
a1342 2
   char *terminator;
   char typebuf[8];
d1356 4
a1359 4
   if (Xlt_SplitLeafnameX2 ( leafname, &RA, &terminator) == OK) {
     int extn_add_or_remove = (*terminator != *typebuf);
     strcpy(terminator, typebuf);
     return (RA.loadaddr >> 8) != (loadaddr >> 8) || (extn_add_or_remove);
d1362 22
a1383 2
     strcat(leafname, typebuf);
     return 1;
d1385 2
@


1.6
log
@Removed some dubious filetyping logic.
On saving a file if the type was text no filetype information was
saved and instead it relied on the default for unknown filetypes being
text.
The default unknown filetype is now &FE4,plus the above logic would
have conflicted with the MimeMap code if for example a file of type
text was saved but which had an extension which was in the mimemap of
type something other than text.

Version 2.24. Tagged as 'LanManFS-2_24'
@
text
@d50 1
a50 1
static const int deaddead = 0xDEADDEAD;
d1255 10
a1264 1
     term = strchr(leafname, '/');
@


1.5
log
@LanmanFS help syntax corrected and tidied
Change lmls command to ListFS in line with NFS
Supress LF when ListFS is issued but there are no servers present.
Cast a few things to shut some compiler warnings up.
Addition of MimeMap lookups where the file has no ",ttt" style type
appended.Previously any such files were all reported as text files so
viewing a machine would typically show whole directories full of
identical filetypes.

Version 2.23. Tagged as 'LanManFS-2_23'
@
text
@d1334 1
a1334 2
     if (type == 0xFFF) *typebuf = '\0';
     else sprintf(typebuf+1, "%03x", type);
@


1.4
log
@  More tolerance has been added of files found on the remote server
    which have unexpected extensions.
Detail:
  LanManFS does not like it if you create (independently, using a PC or
    otherwise) files with names like "myfile,fff" which you intend to
    be displayed as files with type &FFF (ie. Text) on a RISC OS machine.
    If you tried to access the file for reading it, such as loading it
    into an editor, that worked due to the name matching resolution.
    However, any attempt to update the file caused LanManFS to attempt
    to write the file without the extension and not notice that a file
    with a ,fff extension already existed (Text files are special cased
    in the current implementation of name translation - see LanManFS
    Functional Specification for details and rationale).  Attempts to
    save typically succeed (giving you two files: myfile and myfile,fff)
    but generate "Operation not permitted" or such like.  This stemmed
    from the attempt being made by LanManFS to rename a file to the same
    name.  SMB_Rename now traps that and tells its caller that the rename
    succeeded.  The Xlate.c code now indicates correctly that the filename
    extension has been altered when a ,fff extension has to be chopped off.
Admin:
  Tested briefly on desktop build against art-work's SAMBA server.
  Bug reported by TopCat engineers.

Version 2.10. Tagged as 'LanManFS-2_10'
@
text
@d33 2
d1189 1
a1189 1
  char *term;
d1191 1
d1194 2
a1195 1
  if (leafname == NULL) {
d1199 4
a1202 2
  }
  debug1("Xlt_SplitLeafnameX2(\"%s\",....)\n", leafname);
d1204 76
a1279 39
  if ((term - leafname) < 5) {
    /* Name too short?  Must be text. */
    pRA->loadaddr |= 0xFFFFFF00;
    return res;
  }
  leafname = term - 4;
  if (leafname[0] != FileChar_TypedNamePrefix) {
    /* Not an extension?  Must be text */
    pRA->loadaddr |= 0xFFFFFF00;
    return res;
  }
  if (stricmp(leafname+1, FileString_UntypedFile) == 0) {
    debug0("File is untyped (,lxa)\n");
    pRA->loadaddr = untyped_load;
    pRA->execaddr = untyped_exec;
    *terminator = leafname;
    res = OK;
  }
  else if (stricmp(leafname+1, FileString_DeadFile) == 0) {
    pRA->loadaddr = pRA->execaddr = deaddead;
    debug0("File is DEADDEAD\n");
    *terminator = leafname;
    res = OK;
  }
  else if (sscanf(leafname+1, "%x%n", &type, &len) == 1 && len == 3) {
  /* note.  sscanf returns the number of conversions which were
   * successfully performed.  the %n conversion never fails and
   * does not count towards the total number of conversions, but
   * holds the number of characters consumed from the source
   * string.  Therefore, provided that len was 3, then we have
   * consumed three hex digits.
   */
    pRA->loadaddr = ENCODE_FILETYPE(pRA->loadaddr, type);
    *terminator = leafname;
    debug3("Filetype is %#03x; load/exec=%#08x %#08x\n", type,
    	pRA->loadaddr, pRA->execaddr);
    res = OK;
  }
  return res;
@


1.3
log
@  Socket leak fixed.
  Name mapping table modified to prefer mapping hard space to space.
Detail:
  Fixes hard space->space mismapping.
  Doesn't leak sockets during startup if driver isn't ready.
Admin:
  Check-in of previously uncommitted bug fixes to get final version number


Version 2.06. Tagged as 'LanManFS-2_06'
@
text
@d1296 1
d1298 1
a1298 1
     return (RA.loadaddr >> 8) != (loadaddr >> 8);
@


1.2
log
@  Support for long filename.
  Support for spaces in machine names.
  Merge of sbrodie_LanManFS_dev branch to trunk.
Detail:
  LanManFS 2.00 supports the "NT LM 0.12" protocol, enabling it to
    use long filenames on mounted shares.
Admin:
  Supporting documentation:
    1215,256/FS: LanManFS Software Functional Specification.
  Same as LanManFS-1_87_1_1_1_1_2_13.

Version 2.00. Tagged as 'LanManFS-2_00'
@
text
@d644 1
a644 1
     "\xa0!\"?$%+'()*+,-\\.0123456789:;<=>#"
d648 1
a648 1
     "\xa0°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø"
d657 1
a657 1
     "+=><,\xa0";
d659 1
a659 1
     "&@@%$^\x20";
@


1.1
log
@Initial revision
@
text
@d28 1
d37 43
d84 17
a100 1
int stricmp ( const char *s1, const char *s2 )
d102 12
a113 6
  while ( toupper(*s1) == toupper(*s2) )
  {
    if ( *s1 == 0 ) return 0;
    s1++, s2++;
  }
  return toupper(*s1) - toupper(*s2);
d125 1
a127 1

d129 4
d193 6
d532 1
a532 1
  'c',    'y',    'z',    '{',    CH_DUD, '}',    '~',     CH_DUD,
d602 338
d992 8
d1025 12
d1068 63
d1170 137
@


1.1.1.1
log
@
LanManFS moved into Omni subdirectory.  Previous version in
RiscOS/Sources/Networking/LanManFS is now locked out.

The rest of Omni will be imported at a later date.

Version 1.87, tagged as LanManFS-1_87

@
text
@@


1.1.1.1.2.1
log
@  First cut at long filenames in LanManFS.  *Cat and *Ex work.
  Pretty much nothing else does.
Detail:
  Now uses long filenames if available, and switches to the advanced
    SMB protocol and Transact2 commands to do work with long filenames.
Admin:
  Work in progress.  End of week's work checkin point only.  Do not use.

Version 1.87, 1.1.1.1.2.2. Tagged as 'LanManFS-1_87-1_1_1_1_2_2'
@
text
@d456 1
a456 1
  'x',    'y',    'z',    '{',    CH_DUD, '}',    '~',     CH_DUD,
a525 41
#ifdef LONGNAMES
/* Originally, this came from NFS(pathmunge.c):move_nfsname_to_riscos_name */
static const char nfs_lookup_table[257]=
                                    "________________________________"
                                    "†!\"_<__'()_+,-//0123456789_;<=>?"
                                    "_ABCDEFGHIJKLMNOPQRSTUVWXYZ[_]__"
                                    "`abcdefghijklmnopqrstuvwxyz{|}~_"
                                    "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü"
                                    "†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø"
                                    "¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ"
                                    "‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ";

void Xlt_NameDOStoROX2 ( char *dst, char *src )
{
  int i;

  for ( i=0; i<255; i++ )      /* No limit on length, except 255 chars */
  {
    int c = src[i] & 0xFF;
    if (c == 0) break;
    *dst++ = nfs_lookup_table[c];
  }

  *dst = 0;
}

//void Xlt_NameROtoDOSX2 ( char *dst, char *src )
//{
//  int i, c;
//
//  for ( i=0; i<255; i++ )      /* No limit on length, except 255 chars */
//  {
//    c = src[i] & 0xFF;
//    if (c == 0) break;
//    *dst++ = nfs_lookup_inverse_table[c];
//  }
//
//  *dst = 0;
//}
#endif

a602 12
  /* Old SMBsearch format.  For reference, entry points to the following
   * structure (treat strictly as byte array with no padding except where
   * stated:
   *  BYTE find_buf_attr;
   *  WORD find_buf_time;
   *  WORD find_buf_date;
   *  WORD find_buf_size_l;
   *  WORD find_buf_size_h;
   *  BYTE find_buf_pname[13];  ASCII - NUL terminated
   * =====
   *   22  bytes.
   */
a632 56

#ifdef LONGNAMES
err_t Xlt_ExpandSearchEntryX2 ( BYTE *entry, char *path_base,
            char *name_out,
            DOS_ATTRIBS *da_out,
            RISCOS_ATTRIBS *ra_out )
{
  /* New TRANSACT2/FINDFIRST format.  For reference, entry points to the
   * following structure (treat strictly as byte array with no padding
   * except where stated:   (SMB_DATE and SMB_TIME are actually WORD)
   *
   * WORD   CreationDate
   * WORD   CreationTime
   * WORD   LastAccessDate
   * WORD   LastAccessTime
   * WORD   LastWriteDate
   * WORD   LastWriteTime
   * DWORD  DataSize
   * DWORD  AllocationSize
   * WORD   Attributes
   * BYTE   FilenameLength
   * STRING FileName
   * =====
   */
  DOS_ATTRIBS da;

  if ( entry == NULL )
    return EBADPARAM;

  if ( name_out != NULL )
  {
    Xlt_NameDOStoROX2 ( name_out, (char *)entry+23 );
  }

  if ( da_out != NULL || ra_out != NULL )
  {
    da.attr   = entry[20];
    da.utime  = DMYtoUtime ( 0, //entry[8] + (entry[9] << 8),
                          entry[10] + (entry[11] << 8) );
    da.length = entry[12] + (entry[13]<<8) +
                       (entry[14]<<16) + (entry[15]<<24);

    if ( da_out != NULL )
      *da_out = da;

    if ( ra_out != NULL )
    {
      Xlt_CnvDOStoRO ( &da, ra_out, CNV_DATETIME+CNV_ATTRIBS );
      Attr_GetInfo ( path_base, (char *)entry+23, ra_out );

    }
  }

  return OK;
}
#endif
@


1.1.1.1.2.2
log
@  Another intermediate checkin now that *FileInfo works.  I believe this
    means that nearly all the core functionality is in place for long
    filename support.
Detail:
  According to Microsoft's documentation, several of the file lookup type
    transactions return the file information in a common format buffer.
    However, what the docs fail to mention, is that in *some* of those
    commands, the time & date fields are reversed.  FindFirst2/FindNext2
    return "date, time, ...".  QPathInformation returns "time, date, ..."
    Grrr.
  There remains a problem with occasional "server error" results from
    some requests.  The reason for these is unknown ... the documentation is
    unhelpful, describing this as "non-specific error code".  Simply repeating
    the command often results in success, sometimes it has to be repeated a
    few times.
  Also fixed filename mapping which caused any 'x' characters at the remote
    server end to be mapped to 'c' at the RISC OS end(!)  This didn't affect
    it before because servers wouldn't return the old module any filenames
    which contained lower case letters (LanManFS used to make the characters
    lower-case itself if the appropriate name style mode was set).
Admin:
  Tested - still seems to work.  Filename completion from LineEditor works
    nicely.  I can open and close files, and read data from them (*Dump
    used to test this).  *Cat, *Ex and *FileInfo all work.  *Dir works.
  Filename character translations to and from RISC OS format need to be
    verified.  The translation table DOS->RISC OS has been ripped out of
    the NFS module so should be pretty accurate.  The reverse mapping has
    not.

Version 1.87, 1.1.1.1.2.3. Tagged as 'LanManFS-1_87-1_1_1_1_2_3'
@
text
@a35 1
#include "SMB.h"
a122 4
  debug2("%08x %08x => ", dtime, ddate);
  debug3("HH:MM:SS => %02d:%02d:%02d   ", hrs, min, sec);
  debug3("DD:MM:YY => %02d:%02d:%04d \n", dd, mm, yy + 1980);

a537 10
static const char nfs_lookup_inverse_table[257]=
                                    "________________________________"
                                    "†!\"_<__'()_+,-/.0123456789_;<=>?"
                                    "_ABCDEFGHIJKLMNOPQRSTUVWXYZ[_]__"
                                    "`abcdefghijklmnopqrstuvwxyz{|}~_"
                                    "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü"
                                    "†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø"
                                    "¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ"
                                    "‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ";

d552 13
a564 14
static err_t Xlt_NameROtoDOSX2 ( char *dst, char *src )
{
  int i, c;

  for ( i=0; i<(DOS_NAME_LEN-1); i++ )
  {
    c = src[i] & 0xFF;
    if (c == 0) break;
    *dst++ = nfs_lookup_inverse_table[c];
  }

  *dst = 0;
  return OK;
}
a618 5
#ifdef LONGNAMES
    if (SMB_IsLongNameFS( name_out )) {
      return ( Xlt_NameROtoDOSX2 ( name_out+2, name_in+1 ) );
    }
#endif
d723 2
a724 2
    da.utime  = DMYtoUtime ( entry[10] + (entry[11] << 8),
                          entry[8] + (entry[9] << 8) );
d735 1
@


1.1.1.1.2.3
log
@  A few more battles have been won.  War finally starting to go my way.
Detail:
  LanManFS now uses ,xxx type notation on long filename shares.
  Character mappings improved (necessary because Windows allows so
    many extra daft characters to appear in filenames) and one-to-many
    mappings for awkward charcacters in the RISC OS->DOS world have
    been added.
  Directory searching improved so that the wildcard matching can be
    done properly.  Only Microsoft could provide you an API call to
    discover information about a filename specified with wildcards and
    NOT tell you which filename it matched. :-/
  Things remaining unimplemented so far:
    Setting filetypes.
    Creating files with specific types
    Renaming.
  All those outstanding things relate to the work done by Attr_SetInfo
    which should be the final major piece of hacking required.
Admin:
  Tested by connecting to a long filename share from both a RISC OS
    machine and a Windows NT machine.  All behaviour of the RISC OS
    machine has been verified against what the NT machine is seeing
    happening.  No surprises.  One-to-many character mappings are
    being matched correctly.
  Also tested using the Filer at the RISC OS end to navigate, run,
    and edit things on the remote share.

Version 1.87, 1.1.1.1.2.4. Tagged as 'LanManFS-1_87-1_1_1_1_2_4'
@
text
@a27 1
#include <stdlib.h>
a37 10

#ifdef LONGNAMES
//#include "NFSConsts.h"
#define FileChar_TypedNamePrefix        ','
#define FileString_DeadFile             "xxx"
#define FileString_UntypedFile          "lxa"
#endif



d41 8
a48 30
/* Function to compare two strings case insensitively
 *
 * Originally: sbrodie
 *
 * Parameters: matches those of strcmp.
 * Result: matches the exit conditions of strcmp.
 *
 *
 * The conversions to unsigned int stop the compiler messing around with
 * shifts all over the place whilst trying to promote the chars to int
 * whilst retaining the sign.
 *
 * Problems: Choice of return value when strings do not match is based
 *           upon character number rather than any alphabetic sorting.
 *
 */
int stricmp(const char *first, const char *second)
{
	for (;;) {
		unsigned int a = *first++;
		unsigned int b = *second++;

		if (a == 0) return -b;
		if (a != b) {
			unsigned int c = (unsigned int) tolower(a);
			unsigned int d = (unsigned int) tolower(b);
			signed int result = c - d;
			if (result != 0) return result;
		}
	}
a59 1
#ifdef OLD_SLOW_METHOD
d62 1
a63 4
#else
  *d = 0;
  (void) strncat(d, s, len);
#endif
a123 1
  /*
a126 1
  */
d532 20
d553 1
a553 55
/* OK, the mappings for long filename discs are different.
 *
 * They are:
 *
 *       DOS     ->     RISC OS         ->       DOS
 *
 *        *                *                      *    (wildcard)
 *        ?                #                      ?    (wildcard)
 *        #                ?                      #    (swap match for above)
 *
 *        :                :                      :    (won't be seen)
 *        \                .                      \    (dir sep)
 *        .                /                      .
 *
 *        &                +                    + or &
 *        +                +                    & or +
 *        @@                =                    @@ or =
 *        =                =                    = or @@
 *        %                >                    % or >
 *        >                >                    > or %
 *        $                <                    $ or <
 *        <                <                    < or $
 *        ^                ,                    ^ or ,  (don't like this map)
 *        ,                , (or extn)          , or ^
 *      space          hard space               space or hard space
 *    hard space       hard space               hard space or space
 *
 */
static const char lanmanfs_lookup_table[257]=
     "________________________________"
     "\xa0!\"?<>+'()*+,-/_0123456789:;<=>#"
     "=ABCDEFGHIJKLMNOPQRSTUVWXYZ[.],_"
     "`abcdefghijklmnopqrstuvwxyz{|}~_"
     "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü"
     "\xa0°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø"
     "¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ"
     "‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ";

static const char lanmanfs_inverse_lookup_table[257]=
     "________________________________"
     "\xa0!\"?<>+'()*+,-\\.0123456789:;<=>#"
     "=ABCDEFGHIJKLMNOPQRSTUVWXYZ[.],_"
     "`abcdefghijklmnopqrstuvwxyz{|}~_"
     "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü"
     "\xa0°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø"
     "¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ"
     "‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ";


static const char lanmanfs_contentious_characters[]=
     "+=><,\xa0";
//static const char lanmanfs_contentious_pairing[]=
//     "&@@%$^\x20";

static void Xlt_NameDOStoROX2 ( char *dst, char *src, RISCOS_ATTRIBS *pRA )
a555 1
  char *odst = dst;
d557 1
a557 1
  for ( i=0; i<255; i++ )      /* Length limit is 255 chars */
d560 2
a561 2
    if (c == 0) break; /* Found the terminator */
    *dst++ = lanmanfs_lookup_table[c];
a564 8
  dst = strrchr(odst, '.');
  if (dst == NULL) dst = odst; else ++dst;
  if (dst != NULL) {
    if (Xlt_SplitLeafnameX2 ( dst, pRA, &dst ) == OK) {
      /* Strip off the extension */
      *dst = 0;
    }
  }
d567 1
a567 13
/* This is slightly more complicated now by the ,xxx naming scheme.
 *
 * This function returns ENOWILDCARD if the file exists remotely and
 * has exactly the same name as was requested.  This implies that it
 * was a text file or a directory.
 *
 * If it returns OK, then it means that the file exists but requires
 * a wildcard lookup.
 *
 * If it returns ENOTPRESENT, then it means that the file definitely
 * is not there.
 */
static int Xlt_CopyViaInverseTable( char *dst, const char *src, int blat )
d569 1
a569 1
  int wild_count = 0, c, i;
d575 1
a575 8
    if (strchr(lanmanfs_contentious_characters, c)) {
      ++wild_count;
      if (blat) {
        dst[i] = '?';
        continue;
      }
    }
    dst[i] = lanmanfs_inverse_lookup_table[c];
a576 3
  dst[i] = 0;
  return wild_count;
}
d578 1
a578 84
static err_t Xlt_LookupNameROtoDOSX2 ( char *dst, char *src )
{
  static char NameBuf[DOS_NAME_LEN + 4];
  DOS_ATTRIBS dos_attr;
  int i, wild_count;
  char *eos;
  int already_has_extn = 0;

  eos = strchr(src, '\0');
  if ((eos - src) >= 5) {
    int len, type;
    if (sscanf(eos-4, ",%x%n", &type, &len) == 1 && len == 3) {
      already_has_extn = 1;
    }
  }

  NameBuf[0] = *dst++; /* Copy the A: bit of the name */
  NameBuf[1] = *dst++;
  wild_count = Xlt_CopyViaInverseTable(NameBuf+2, src, 0);
  strcpy(dst, NameBuf+2);

  debug1("Looking for %s\n", NameBuf);

  if (SMB_GetAttribs(NameBuf, &dos_attr) == OK) {
    debug0("Found verbatim\n");
    return OK;
  }

  eos = strchr(NameBuf, '\0');
  if (!already_has_extn) {
    strcpy(eos, ",???");
    debug1("Looking for %s\n", NameBuf);
    if (SMB_GetAttribs(NameBuf, &dos_attr) == OK) {
      strcpy(dst, NameBuf+2);
      debug0("Had a type\n");
      return OK;
    }
  }

  *eos = '\0';
  if (wild_count == 0) return OK;

  Xlt_CopyViaInverseTable(NameBuf+2, src, 1); /* Blat with wildcards */

  debug1("Looking for %s\n", NameBuf);
  if (SMB_GetAttribs(NameBuf, &dos_attr) != OK) {
    if (!already_has_extn) {
      Xlt_CopyViaInverseTable(dst, src, 0);
      return ENOTPRESENT;
    }
    strcpy(NameBuf+i, ",???");
    debug1("Looking for %s\n", NameBuf);
    if (SMB_GetAttribs(NameBuf, &dos_attr) != OK) {
      Xlt_CopyViaInverseTable(dst, src, 0); /* Unblat */
      return ENOTPRESENT;
    }
    debug0("Had a type\n");
  }
  debug0("Had contentious characters\n");
  strcpy(dst, NameBuf+2);
  return OK;
}

static err_t Xlt_NameXlateCallbackX2 ( BYTE *entry, int format, void *dst )
{
    strcpy(dst, (char *) entry+23);
    debug1("Xlt_NameXlateCallbackX2: `%s'\n", dst);
    return EOUTOFMEM; /* Match first only */
}

static err_t Xlt_NameROtoDOSX2 ( char *dst, char *src )
{
  debug1("Xlt_NameROtoDOSX2: `%s'\n", src);
  if (Xlt_LookupNameROtoDOSX2 ( dst, src ) == OK) {
    /* Need to perform a search to find the exact name now */
    static char dstcpy[DOS_NAME_LEN];
    err_t res;
    debug1("Searching for a match for `%s'\n", dst);
    strcpy(dstcpy, dst); /* Copy the wildcarded filespec */
    res = SMB_ReadDirEntries(dstcpy, 1, Xlt_NameXlateCallbackX2,
      1 + strrchr(dstcpy, '\\'));
    strcpy(dst, dstcpy);
    debug1("End of search for a match - result `%s'\n", dst);
  }
d637 1
a637 1
      return ( Xlt_NameROtoDOSX2 ( name_out, name_in+1 ) );
a731 1
  RISCOS_ATTRIBS ra_name;
d738 1
a738 8
    Xlt_NameDOStoROX2 ( name_out, (char *)entry+23, &ra_name );
  }
  else
  {
    char *dst;
    if (Xlt_SplitLeafnameX2 ( (char *)entry+23, &ra_name, &dst ) == OK) {
      *dst = 0;
    }
d755 1
a755 2
      ra_out->loadaddr &= ~0xFFF00;
      ra_out->loadaddr |= (ra_name.loadaddr & (0xFFF00));
a801 49
#ifdef LONGNAMES
err_t Xlt_SplitLeafnameX2 ( char *leafname, RISCOS_ATTRIBS *pRA,
  char **terminator)
{
  int type, len;
  char *term;
  err_t res = ENOTPRESENT;
  const int fff00 = 0xFFF00;


  pRA->loadaddr = pRA->loadaddr | (fff00) | 0xFFF00000;
  *terminator = NULL;
  if (leafname == NULL) {
    return res;
  }
  debug1("Xlt_SplitLeafnameX2(%s,....)\n", leafname);
  term = strchr(leafname, '\0');
  if ((term - leafname) < 5) return res;
  leafname = term - 4;
  if (leafname[0] != FileChar_TypedNamePrefix) return res;
  if (stricmp(leafname+1, FileString_UntypedFile) == 0) {
    pRA->loadaddr = pRA->execaddr = 0;
    *terminator = leafname;
    res = OK;
  }
  else if (stricmp(leafname+1, FileString_DeadFile) == 0) {
    pRA->loadaddr = pRA->execaddr = 0xDEADDEAD;
    *terminator = leafname;
    res = OK;
  }
  else if (sscanf(leafname+1, "%x%n", &type, &len) == 1 && len == 3) {
  /* note.  sscanf returns the number of conversions which were
   * successfully performed.  the %n conversion never fails and
   * does not count towards the total number of conversions, but
   * holds the number of characters consumed from the source
   * string.  Therefore, provided that len was 3, then we have
   * consumed three hex digits.
   */
    pRA->loadaddr = pRA->loadaddr ^ (((~type) << 8) & fff00);
    *terminator = leafname;
    debug3("Filetype is %#03x; load/exec=%#08x %#08x\n", type,
    	pRA->loadaddr, pRA->execaddr);
    res = OK;
  }
  return res;
}
#endif

/* ------------------------------- */
@


1.1.1.1.2.4
log
@  First version which should contain everything required for full
    long filename support of SMB shares.
Detail:
  Renaming works; setting filetypes results in a rename occurring;
  setting load/exec/attributes works - causing a rename where
  appropriate; creation of files to overwrite existing objects of
  different types causes old file to be deleted first.
Admin:
  Tested briefly and everything seems happy both at the command-line
    and from the RISC OS Filer.  More thorough development testing can
    now commence properly.

Version 1.87, 1.1.1.1.2.5. Tagged as 'LanManFS-1_87-1_1_1_1_2_5'
@
text
@a1046 63

#ifdef LONGNAMES
/* Copies the filetype information from one name to another.
 * Note that the file saving routine actually uses this
 * routine to strip filetype information by passing both
 * parameters the same.  This must continue to function.
 */
err_t Xlt_CnvRenameX2 ( char *src, char *dst )
{
  RISCOS_ATTRIBS RA;
  char *terminator, *nterm;

  if (Xlt_SplitLeafnameX2 ( dst, &RA, &nterm ) != OK) {
    /* No type information - find end of string */
    nterm = strchr(dst, '\0');
  }
  else {
    /* Strip old type information in case source didn't have any either */
    *nterm = '\0';
  }

  if (Xlt_SplitLeafnameX2 ( src, &RA, &terminator ) == OK) {
    (void) strcpy(nterm, terminator);
  }

  return OK;
}
#endif

/* ------------------------------- */

#ifdef LONGNAMES
int Xlt_AddROType ( char *leafname, uint loadaddr )
{
   RISCOS_ATTRIBS RA;
   char *terminator;
   char typebuf[8];

   typebuf[0] = FileChar_TypedNamePrefix;
   if (loadaddr == 0xDEADDEAD) {
     strcpy(typebuf+1, FileString_DeadFile);
   }
   else if ((loadaddr & 0xFFF00000) != 0xFFF00000) {
     strcpy(typebuf+1, FileString_UntypedFile);
   }
   else {
     int type = (loadaddr << 12) >> 20;
     if (type == 0xFFF) *typebuf = '\0';
     else sprintf(typebuf+1, "%03x", (loadaddr << 12) >> 20);
   }

   if (Xlt_SplitLeafnameX2 ( leafname, &RA, &terminator) == OK) {
     strcpy(terminator, typebuf);
     return (RA.loadaddr >> 8) != (loadaddr >> 8);
   }
   else {
     strcat(leafname, typebuf);
     return 1;
   }
}
#endif

/* ------------------------------- */
@


1.1.1.1.2.5
log
@  Now works against Windows NT 4.0 servers.
Detail:
  NT 4.0 Lan Manager appears not to like single character wildcards being
    used in some circumstances.  So I've thrown away all the code which
    handles this and replaced it with code which simply performs a complete
    directory search and doing the matching myself.  This also reduces the
    number of SMB transactions required to do a name translation to 1
    instead of 5 (except in the case of a directory containing an awful
    lot of entries)
  Contentious character handling fixed.  Previously if a doubly-mapped
    character was used, it would match any character instead of just
    itself and its partner.  eg. q+a would match qua instead of just
    q+a and q&a.
Admin:
  Checked desktop usage against STYX (NT 4 test machine) and against a
    Windows 98 server to confirm that support for that hasn't been affected
    by these changes.

Version 1.87, 1.1.1.1.2.8. Tagged as 'LanManFS-1_87-1_1_1_1_2_8'
@
text
@a620 3
/* These two structures MUST be kept in step in order to allow the
 * wildcard resolution code function correctly
 */
d623 2
a624 2
static const char lanmanfs_contentious_pairing[]=
     "&@@%$^\x20";
d682 1
a682 13
typedef struct {
        char *dstcpy;
        char dstcpybuf[DOS_NAME_LEN + 4];
        char matchbuf[DOS_NAME_LEN + 4];
} Xlt_NXCX2_Data;

/* An unusual routine.  The SMB_ReadDirectoryEntriesX2 routine calls this
 * function back in order to process each directory entry as it is
 * discovered whilst we are searching for filename matches.  In order to
 * get that routine to stop when we have found a match, we return it a
 * value of EOUTOFMEM.  If we want it to continue, we return OK.
 */
static err_t Xlt_NameXlateCallbackX2 ( BYTE *entry, int format, void *_dst )
d684 25
a708 33
    Xlt_NXCX2_Data *dst = _dst;
    char *eptr = (char *) (entry + 23);
    char *dptr = 1 + strrchr(dst->matchbuf, '\\');
    err_t res = OK;

    debug3("Xlt_NameXlateCallbackX2: checking `%s', against `%s' in `%s'\n",
        (char *) entry + 23,
        dptr,
    	dst->dstcpybuf);

    for (;;) {
      char e = *eptr++;
      char d = *dptr++;

      if (e == d || toupper(e) == toupper(d)) {
        if (e) continue;
        /* We have a match */
        res = EOUTOFMEM;
        break;
      }
      else if (e == ',' && d == 0) {
        /* Might have been a filetype suffix */
        int type, num;
        if ((sscanf(eptr, "%x%n", &type, &num) == 1 && num == 3)
          || strcmp(eptr, FileString_DeadFile) == 0
          || strcmp(eptr, FileString_UntypedFile) == 0) {
          /* It was */
          res = EOUTOFMEM;
          break;
        }
      }
      else {
        int i;
d710 8
a717 10
        for (i=0; lanmanfs_contentious_characters[i]; ++i) {
          if ((e == lanmanfs_contentious_characters[i] ||
               e == lanmanfs_contentious_pairing[i]) &&
              (d == lanmanfs_contentious_characters[i] ||
               d == lanmanfs_contentious_pairing[i])) {
            break; /* OK! */
          }
        }
        if (lanmanfs_contentious_characters[i] == 0) return OK;
      }
d719 4
d724 13
a736 2
    if (res == EOUTOFMEM) {
      strcpy(dst->dstcpy, (char *) entry+23);
d738 12
a749 1
    return res;
a753 8
  static Xlt_NXCX2_Data private;
  char *inptr;
  err_t status;

  private.matchbuf[0] = dst[0];
  private.matchbuf[1] = dst[1];
  Xlt_CopyViaInverseTable(private.matchbuf + 2, src, 0);
  debug0("\n\n");
d755 10
a764 31
  debug1("Xlt_CopyViaInverseTable -> `%s'\n", private.matchbuf);
  strcpy(private.dstcpybuf, private.matchbuf);
  private.dstcpy = strrchr(private.dstcpybuf, '\\');
  if (private.dstcpy) {
    strcpy(++private.dstcpy, "*");
  }
  else {
    private.dstcpy = strchr(private.dstcpybuf, '\0');
    strcpy(private.dstcpy, "\\*");
  }

  debug1("Xlt_NameROtoDOSX2 initiates a dir search of `%s'\n",
    private.dstcpybuf);

  for (status = OK, inptr = private.dstcpybuf; status == OK; inptr = NULL) {
    status = SMB_ReadDirEntries(inptr, 512, Xlt_NameXlateCallbackX2,
      &private);
    switch (status) {
      case OK:
        break;
      case EOUTOFMEM:
        /* Found it */
        strcpy(dst, private.dstcpybuf);
        debug1("\n**RIGHT.  Got a match: `%s'\n", dst);
        break;
      default:
        /* Definitely didn't find it - revert to original filename */
        strcpy(dst, private.matchbuf);
        debug1("\n**WRONG.  Not got a match. Reverting to `%s'\n", dst);
        break;
    }
a765 1

d1007 1
d1013 1
a1013 1
  debug1("Xlt_SplitLeafnameX2(\"%s\",....)\n", leafname);
d1019 1
a1019 1
    pRA->loadaddr = pRA->execaddr = 0x03800000;
@


1.1.1.1.2.6
log
@  Fixed most dodgy pathname problems.
  All *LM... commands are now filing system commands.
  *Connect and *Disconnect renamed to *LMConnect and *LMDisconnect.
Detail:
  When translating RISC OS to DOS filenames, a loop could develop if
    any path component contained a dodgy character.  This is now fixed
    with the exception of problems when both < and > characters appear
    in pathnames since that confuses FileSwitch.  New mappings will be
    need to be agreed for these characters (and remappings for $ and %
    which overload < and > respectively)
  All *LM... commands are now filing system commands, which means that
    you need to prefix them with LanMan: unless LanManFS is the current
    filesystem (following spec review).
  *Connect and *Disconnect renamed to *LMConnect and *LMDisconnect
    (following spec review).
  Trace builds allow "*LanMan:LMNameMode 4" to enable display of system
    and hidden files on the remote filesystem.
Admin:
  Tested briefly against Windows 98 and Windows NT 4 SP3.
  If a directory name contains a dodgy character, repeated searches will
    be made on the remote filesystem.  This is inefficient and a name
    cache would alleviate this.  There is no name cacheing in the current
    version.

Version 1.87, 1.1.1.1.2.9. Tagged as 'LanManFS-1_87-1_1_1_1_2_9'
@
text
@d41 1
a44 33

/* Magic value used to indicate an incomplete file - used by the Filer,
 * for example, when writing a new file
 */
static const int deaddead = 0xDEADDEAD;

/* For the moment, untyped files have these invented load/exec addresses.
 * They ensure that if such a file is *Load'ed or *Run'ed, then a data
 * abort will occur
 */
static const int untyped_load = 0x03800000;
static const int untyped_exec = 0x03800000;

/* Macro returns non-zero if the specifiec load addressis indicative of
 * a filetyped object.   Rather than checking for the top 12 bits being
 * set, it's much quicker to arithmetic shift it right 20 bits and test
 * for -1.  (Norcroft generates:  MVN rn, #0: TEQ rn, ra, ASR #20)
 */
#define IS_FILETYPED(load_addr) ((((signed int)(load_addr)) >> 20) == -1)

/* Extracts the filetype from a load address.  Assumes that IS_FILETYPED
 * would return non-zero.  In isolation, Norcroft generates:
 * MOV ra, ra, LSL #12: MOV ra, ra, LSR #20.
 */
#define GET_FILETYPE(load_addr) ((((unsigned int)(load_addr)) << 12) >> 20)

/* Encodes a filetype into a load address - Norcroft compiler makes a
 * nice job of this macro (result in load): ORR rn, load, #0xf0000000
 * ORR rn, rn, #0x0FF00000: MOV load,load,LSL #12:
 * EOR load, type, load LSR #20: EOR load,rn,load LSL #8
 */
#define ENCODE_FILETYPE(load,type) \
	(((load)|0xFFF00000)^((GET_FILETYPE(load)^(type))<<8))
d612 1
a612 1
     "\xa0!\"?$%+'()*+,-\\.0123456789:;<=>#"
d622 1
a622 1
 * wildcard resolution code function correctly.
a628 6
/* Translate DOS names to RISC OS names using the translation table
 *
 * This routine translates the given DOS filename into the RISC OS filename,
 * stripping the file extension if there is one and setting up the pRA
 * structure with the type details of the file.
 */
d634 1
a634 1
  for ( i=0; i<(DOS_NAME_LEN-1); i++ )      /* Length limit is 255 chars */
d652 8
a659 3
/* This function copies the string src to dst.  Once it gets past the
 * level'th character, it maps each character through the RISC OS->DOS
 * character conversion table.
d661 2
a662 2
 * This means that partially converted filenames can be copied verbatim
 * and the not-yet-done portions translated as required.
d664 1
a664 1
static void Xlt_CopyViaInverseTable( char *dst, const char *src, int level )
d666 1
a666 1
  int i;
d670 1
a670 1
    int c = src[i] & 0xFF;
d672 6
a677 5
    if (i < level) {
      dst[i] = c;
    }
    else {
      dst[i] = lanmanfs_inverse_lookup_table[c];
d679 1
d682 1
a684 1
/* Temporary state data structure for the filename mangling */
a690 23

/* Xlt_ContentiousCharCheck
 *
 * Checks contentious characters. Returns the actual remote char if
 * the chars are not equal but match under the contentious char table.
 * Returns '\0' if no match is found.
 */
static char Xlt_ContentiousCharCheck(char e, char d)
{
   int i;

   for (i=0; lanmanfs_contentious_characters[i]; ++i) {
     if ((e == lanmanfs_contentious_characters[i] ||
          e == lanmanfs_contentious_pairing[i]) &&
         (d == lanmanfs_contentious_characters[i] ||
          d == lanmanfs_contentious_pairing[i])) {
            return e;
          }
   }

   return '\0';
}

d695 1
a695 4
 * value of EOUTOFMEM.  If we want it to continue, we return OK.  The
 * private handle (_dst) is actually a pointer to the state structure
 * and that structure is updated with the real filename once a match
 * has been found.  The format parameter should always be 1.
d731 9
a739 3
        if (!Xlt_ContentiousCharCheck(e, d)) {
          /* No match */
          return OK;
d741 1
a745 1
      /* Update stored leafname */
d751 1
a751 8
/* Map RISC OS names onto DOS names.  Complicated by the need to
 * resolve the duplicate mapped characters.  All lookups invoke a
 * directory search at the remote end, looking for the actual object
 * name.  If any of the path components have nasty characters in them,
 * then sub-searches are performed to resolve those too.  Only a single
 * level of recursion is required (and supported).
 */
static err_t Xlt_NameROtoDOSX2_sub ( char *dst, char *src, int level )
d759 1
a759 1
  Xlt_CopyViaInverseTable(private.matchbuf + 2, src, level);
a762 6

  /* Construct the search pathname buffer, by taking the parent directory
   * and ensuring that the name ends \*
   * private.dstcpy must point at the * character so that the callback
   * function can write the matched target name straight in
   */
a775 56
  if (level == 0)
  for (inptr = private.dstcpybuf + 2 + level; inptr != private.dstcpy; ++inptr) {
    if (Xlt_ContentiousCharCheck(*inptr, *inptr)) {
      /* We have a problem - there are contentious characters in the
       * path leading to the actual object we are going to seek!
       * We now have to mess about doing sub-searching for the required
       * contentious directory names, remembering to patch back the
       * private.matchbuf with the matched name so that if any search
       * component fails (eg. the top-level one when the object does
       * not exist (consider *Cdir or *Create)) does remember the path
       * did exist.
       */
      static Xlt_NXCX2_Data sub_search;
      static char srccpy[DOS_NAME_LEN];
      char *ptr, preserved, *okptr;
      size_t len;

      /* Preserve existing state whilst sub-search is performed */
      sub_search = private;

      /* Duplicate source string and truncate it appropriately for
       * the sub-search target
       */
      strcpy(srccpy, private.matchbuf + 2);
      okptr = srccpy + (inptr - (private.dstcpybuf + 2));
      while (okptr != srccpy && *okptr != '\\') --okptr;
      ptr = srccpy + (inptr - (private.dstcpybuf + 2));
      while (*ptr != '\0' && *ptr != '\\') ++ptr;
      preserved = ptr[0];
      ptr[0] = '\0';
      /* Search for the name.  Don't worry about failures, dst will be
       * safe to use whatever the result
       */
      Xlt_NameROtoDOSX2_sub(dst, srccpy, okptr - srccpy + 1);
      len = strlen(dst);
      ptr[0] = preserved;
      /* Restore state, update matchbuf (answer on fail), and dstcpybuf
       * (current copy buffer).
       */
      private = sub_search;
      memcpy(private.dstcpybuf, dst, len);
      memcpy(private.matchbuf, dst, len);
      /* Skip to next component - we've already tried to resolve this
       * one and, with success or failure, we already have the best we
       * can do for this component
       */
      inptr = private.dstcpybuf + len;
    }
  }

  debug1("Xlt_NameROtoDOSX2 initiates a dir search of `%s' (post-mangle)\n",
    private.dstcpybuf);

  /* Repeatedly search the directory until we find a match, or there are
   * no more entries to be read back
   */
d777 2
a778 2
    status = SMB_ReadDirEntries(inptr, 32, Xlt_NameXlateCallbackX2,
      &private, NULL);
a780 1
        /* More entries to read, and no match found yet */
d788 1
a788 3
        /* Definitely didn't find it - revert to original filename
         * or at least filename with nasties resolved as far as possible
         */
a796 9

/* Kicks off the DOS to RISC OS name conversion process - setting up the
 * number of already-translated characters as zero.
 */
static err_t Xlt_NameROtoDOSX2 ( char *dst, char *src )
{
        return Xlt_NameROtoDOSX2_sub(dst, src, 0);
}

a851 3
    /* We use a different system for long filename shares.  Call
     * the long name resolution routine if necessary
     */
d979 2
a980 1
      ra_out->loadaddr ^= ((ra_name.loadaddr ^ ra_out->loadaddr) & (0xFFF00));
a1027 12
/* Xlt_SplitLeafname2
 *
 * This routine examines the supplied leafname/pathname and looks to
 * see if it has a type suffix.  If it does, then the type suffix is
 * decoded and the RISCOS_ATTRIBS structure is updated to hold the
 * load/exec address data, a pointer to the type suffix separator (the
 * comma) is stored in *terminator and the function returns OK.  The
 * caller can strip the suffix by zeroing the byte pointed to by
 * *terminator.  If there was no type suffix, ENOTPRESENT is returned
 * and NULL is stored in *terminator.
 *
 */
d1034 1
d1036 1
a1038 2
    /* Oh dear - don't understand this - just claim it's text */
    pRA->loadaddr |= 0xFFFFFF00;
d1043 1
a1043 5
  if ((term - leafname) < 5) {
    /* Name too short?  Must be text. */
    pRA->loadaddr |= 0xFFFFFF00;
    return res;
  }
d1045 1
a1045 5
  if (leafname[0] != FileChar_TypedNamePrefix) {
    /* Not an extension?  Must be text */
    pRA->loadaddr |= 0xFFFFFF00;
    return res;
  }
d1047 1
a1047 3
    debug0("File is untyped (,lxa)\n");
    pRA->loadaddr = untyped_load;
    pRA->execaddr = untyped_exec;
d1052 1
a1052 2
    pRA->loadaddr = pRA->execaddr = deaddead;
    debug0("File is DEADDEAD\n");
d1064 1
a1064 1
    pRA->loadaddr = ENCODE_FILETYPE(pRA->loadaddr, type);
a1106 3
/* Adds the type suffix for a RISC OS filename.  The type is extracted
 * from the passed load address.
 */
d1114 1
a1114 1
   if (loadaddr == deaddead) {
d1117 1
a1117 1
   else if (!IS_FILETYPED(loadaddr)) {
d1121 1
a1121 1
     const int type = GET_FILETYPE(loadaddr);
d1123 1
a1123 1
     else sprintf(typebuf+1, "%03x", type);
@


1.1.1.1.2.7
log
@  End of week checkin.  No bug fixes.  Some performance improvements.
Detail:
  Added a basic name cacheing facility.  For safety this is flushed
    every time the module returns to FileSwitch.  This does at least
    help reduce the name of directory searches required during a
    name translation.  NameCache.c comes with a test program built-in
    for stressing the cache manager.
Admin:
  Free space display doesn't work yet.
  Anti-idleout measures not implemented yet.

Version 1.87, 1.1.1.1.2.10. Tagged as 'LanManFS-1_87-1_1_1_1_2_10'
@
text
@d38 1
a38 1
#include "NameCache.h"
a760 4
    if (dst->dstcpy[0] != '*') {
      return EOUTOFMEM;
    }

a796 4
      if (dst->dstcpy[0] == '*') {
         dst->dstcpy[0] = '\0';
         NameCache_Add(dst->dstcpybuf, entry);
      }
a826 1
  (void) NameCache_Locate(private.matchbuf);
@

head	1.24;
access;
symbols
	LanManFS-2_62:1.24
	LanManFS-2_61:1.24
	LanManFS-2_60:1.23
	LanManFS-2_59:1.23
	LanManFS-2_58:1.22
	LanManFS-2_57:1.22
	LanManFS-2_56:1.22
	LanManFS-2_55:1.21
	LanManFS-2_54:1.21
	LanManFS-2_53:1.21
	LanManFS-2_52:1.21
	LanManFS-2_51:1.20
	LanManFS-2_50:1.20
	LanManFS-2_49:1.19
	LanManFS-2_48:1.18
	LanManFS-2_47:1.18
	LanManFS-2_46:1.18
	LanManFS-2_45:1.18
	LanManFS-2_44:1.18
	LanManFS-2_43:1.18
	LanManFS-2_42:1.18
	LanManFS-2_41:1.18
	LanManFS-2_40:1.18
	LanManFS-2_39:1.17
	LanManFS-2_38:1.17
	LanManFS-2_37:1.16
	LanManFS-2_36:1.16
	LanManFS-2_35:1.16
	LanManFS-2_34:1.15
	LanManFS-2_33:1.14
	LanManFS-2_32:1.13
	LanManFS-2_31:1.12
	RO_5_07:1.11
	LanManFS-2_30:1.11
	LanManFS-2_29:1.10
	LanManFS-2_28:1.10
	LanManFS-2_27:1.10
	LanManFS-2_26:1.10
	LanManFS-2_25:1.10
	LanManFS-2_24:1.9
	LanManFS-2_23:1.9
	LanManFS-2_22:1.9
	LanManFS-2_21:1.9
	LanManFS-2_20:1.9
	LanManFS-2_19:1.9
	LanManFS-2_18:1.9
	LanManFS-2_17:1.9
	LanManFS-2_16:1.8
	LanManFS-2_15:1.8
	LanManFS-2_14:1.8
	LanManFS-2_13:1.8
	LanManFS-2_12:1.8
	LanManFS-2_11:1.7
	LanManFS-2_10:1.6
	LanManFS-2_09:1.5
	LanManFS-2_08:1.5
	LanManFS-2_07:1.5
	LanManFS-2_06:1.4
	LanManFS-2_05:1.4
	LanManFS-2_04:1.4
	LanManFS-2_03:1.3
	LanManFS-2_02:1.3
	LanManFS-2_01:1.2
	LanManFS-2_00:1.2
	LanManFS-1_87-1_1_1_1_2_13:1.1.1.1.2.9
	LanManFS-1_87-1_1_1_1_2_12:1.1.1.1.2.8
	LanManFS-1_87-1_1_1_1_2_11:1.1.1.1.2.7
	LanManFS-1_87-1_1_1_1_2_10:1.1.1.1.2.6
	LanManFS-1_87-1_1_1_1_2_9:1.1.1.1.2.5
	LanManFS-1_87-1_1_1_1_2_8:1.1.1.1.2.4
	LanManFS-1_87-1_1_1_1_2_7:1.1.1.1.2.4
	LanManFS-1_87-1_1_1_1_2_6:1.1.1.1.2.4
	LanManFS-1_87-1_1_1_1_2_5:1.1.1.1.2.3
	LanManFS-1_87-1_1_1_1_2_4:1.1.1.1.2.3
	LanManFS-1_87-1_1_1_1_2_3:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_2:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_1:1.1.1.1
	sbrodie_LanManFS_dev:1.1.1.1.0.2
	sbrodie_LanManFS_dev_bp:1.1.1.1
	LanManFS-1_87:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.24
date	2018.01.03.22.06.37;	author rsprowson;	state Exp;
branches;
next	1.23;
commitid	2mvsrxqgkH3zJtlA;

1.23
date	2017.01.21.11.05.27;	author rsprowson;	state Exp;
branches;
next	1.22;
commitid	wTlByCHIpddjePCz;

1.22
date	2016.05.14.12.55.14;	author rool;	state Exp;
branches;
next	1.21;
commitid	MC8JaBywHOhbWr6z;

1.21
date	2015.08.09.10.42.51;	author rool;	state Exp;
branches;
next	1.20;
commitid	TYF5qIOL7WOKaAwy;

1.20
date	2015.07.12.09.20.35;	author rool;	state Exp;
branches;
next	1.19;
commitid	XUshYt2oKrUkCYsy;

1.19
date	2015.07.05.07.57.49;	author rsprowson;	state Exp;
branches;
next	1.18;
commitid	5VZfrDqvkhYTn4sy;

1.18
date	2013.10.03.07.27.09;	author rsprowson;	state Exp;
branches;
next	1.17;
commitid	iTaBDwF1woaPMO7x;

1.17
date	2012.11.11.20.43.15;	author rsprowson;	state Exp;
branches;
next	1.16;
commitid	3D5DE5lr2isCFZrw;

1.16
date	2011.10.15.07.30.16;	author rsprowson;	state Exp;
branches;
next	1.15;
commitid	HPAQrxWHCl3LUpDv;

1.15
date	2009.08.01.08.10.27;	author rsprowson;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.19.22.25.05;	author rsprowson;	state Exp;
branches;
next	1.13;

1.13
date	2009.04.15.16.00.08;	author bavison;	state Exp;
branches;
next	1.12;
commitid	GhZBwZ2GN8lg58Kt;

1.12
date	2009.04.15.15.51.34;	author bavison;	state Exp;
branches;
next	1.11;
commitid	nfMCLS8WEvrk28Kt;

1.11
date	2004.02.16.15.47.05;	author kbracey;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.16.18.14.17;	author rsprowson;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.09.17.09.31;	author sbrodie;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.08.09.12.19;	author sbrodie;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.04.11.39.18;	author sbrodie;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.21.11.31.39;	author sbrodie;	state Exp;
branches;
next	1.5;

1.5
date	99.04.29.14.27.42;	author sbrodie;	state Exp;
branches;
next	1.4;

1.4
date	99.03.09.15.07.37;	author sbrodie;	state Exp;
branches;
next	1.3;

1.3
date	99.02.18.16.45.51;	author sbrodie;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.12.52.14;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	98.12.03.13.54.46;	author sbrodie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.12.03.13.54.46;	author sbrodie;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	98.12.11.17.26.28;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	98.12.14.14.57.34;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.01.08.14.04.22;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.4;

1.1.1.1.2.4
date	99.01.15.15.58.36;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.5;

1.1.1.1.2.5
date	99.02.03.12.51.39;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.6;

1.1.1.1.2.6
date	99.02.05.15.57.19;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.7;

1.1.1.1.2.7
date	99.02.10.14.55.53;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.8;

1.1.1.1.2.8
date	99.02.12.17.18.23;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.9;

1.1.1.1.2.9
date	99.02.16.12.34.06;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Name resolution, wildcarded FSEntry_File 5 & 9, and buffer overrun fixes
Make SMB_RxWords a bit bigger per static anaylsis
  https://www.riscosopen.org/forum/forums/4/topics/9503
when LONGNAMES is undefined, since NT LM 0.12 dialect is allowed at the same time as short names.

A change to name translation in LanManFS-2_60 broke all forms of nested contentious name resolution, ie. where a leafname containing a contentious character was itself in a directory containing one.
The cited problem names ('1 2/3' and '1 /s') can both be resolved at one level only, no 2nd pass is required. The resolution function walks along the elements of the path one at a time to reach the leaf (ie. no element is processed twice). A test case has been created to allow some regression testing when making future changes in this area.

When building tboxlibint
  Copy h.* <Lib$Dir>.tboxlibint.h.*
when the directory is empty FileSwitch checks the destination ending in ...\h\* which the short names translation would error with ENOWILDCARD, but the long names translation attempts to resolve it by finding the trailing '\' and appending a '*' (ie. not doing anything), this returns no results and is passed back unfaulted. The special check in fsentry_file() for ENOWILDCARD for the two ReadCatalogueInformation thus doesn't trigger, and an attempt to FileGetAttribs() is made on the still wildcarded path. This is rejected by the server when in SMB_GetAttribsX2() does a TRANSACT2_QUERYPATHINFORMATION, which expects a non wildcarded object (on Windows servers at least), propagating an error back up to the user.
This stopped a ROM build from completing the exports phase via LanManFS on a Windows share.

Const-ify a few things.

Changed files
  Xlate.c: Revert change from revision 1.21, return ENOWILDCARD when appropriate.
  SMC.c: Increase MAX_WCT buffer size to 17.
  UK/CmdHelp: Add some missing chevrons round the command syntax for required parameters.
  test/Contentious: Test case for nested contentious character resolution code.

Version 2.61. Tagged as 'LanManFS-2_61'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
*
*  SMB.C  -- SMB Server routines
*
*  14-02-94 INH  Original
*                No WriteRaw
*  17-08-94      No 'drv' numbers passed
*  12-09-94      New NetBIOS interface
*  22-09-95      Tracks Uids & session keys. Uses "DOS LM1.2X002"
*                  protocol to keep Lan Manager happy.
*  26-03-97      SMB_GetAttribs call replaced for NT 4.0 bug workround
*  21-04-97      SMB_SetAttribs sets time/date using Open/Close on Windows95
*
*  04-12-98      sbrodie: started adding long filename support - controlled
*                  by LONGNAMES macro.
*  08-12-98      sbrodie: Added SMB_Transact2 with full support for setup
*                  words and the like (present only for LONGNAMES build)
*                  Several new functions added to support long filename
*                  compatible versions of some calls,  These functions have
*                  the same name as the function they upgrade with an X2 suffix
*                  added.
*/

/* A word about 'drive letters':

   Each connection from us to a shared directory or printer on a server
   is given a drive letter (starting at 'A' and working up). This is
   essentially a handle to a (server_name, share_name) pair, but it
   is made a character to allow it to be passed as the first character
   in filename strings to the SMB_xxx functions.

   LanManFS itself will allow disk-type network connections to be
   given 'mount names' so RISCOS file names take the form
     LanMan::MountName.$.<filespec>

   We never see these mount names; they are handled in c.Omni. When
   a RISCOS filename is passed to Xlt_ConvertPath, it uses
   Omni_GetDrvLetter() to convert the mount name to an SMB drive letter.

   We could allow SMB to deal directly in mount names, but (i) we'd
   have to create nonconflicting names for all the anonymous mounts
   like printers and RPC connections, (ii) the Omni module has to
   deal with mount names anyway, & has a perfectly good set of list-
   management routines there already; we'd only have to duplicate
   them & write an interface (iii) legal characters & case
   sensitivity for mount names may be different to DOS filenames,
   making a composite name a pain in the bum to validate.

   SMB treats drives, printers and the IPC$ share used for remote
   procedure call as alike; a different set of operations
   is allowed on each one, but they are all connected with
   SMB_CreateShare() & SMB_DeleteShare(), and they all have a
   'drive letter'. Hence you will find references to
   drive letters in the printer and RPC code - panic not, they
   are just connection identifiers.
*/


/* Standard includes */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include "kernel.h"
#include "swis.h"

/* Our includes */

#include "stdtypes.h"
#include "LanMan.h"
#include "BufLib.h"
#include "NetBIOS.h"
#include "SMB.h"
#include "Transact.h"
#ifdef LONGNAMES
#include "NameCache.h" /* for the directory entry cache */
#endif
#include "LMVars.h"
#include "Attr.h"   /* For InvalidateDrive */
#include "Xlate.h"  /* For string functions */
#include "Auth.h"

/* Definitions ===================================================== */

/* Our definitions */

#define MAX_SERVERS  (MAX_DRIVES + 4)
#define MAX_SHARES   (MAX_DRIVES + 4)

/* Tuning parameters */

#define MAX_RX_BLOCK_SIZE (3*1452)  /* Windows clients' default, see [MS-CIFS].pdf note 91 (p709) */
#define MAX_CORE_TX_BLOCK_SIZE 1024 /* Core dialect doesn't send MaxBufferSize value */
#define RDRAW_BLOCK_SIZE  32768
#define WRRAW_BLOCK_SIZE  16384
#define PRN_BLOCK_SIZE    1024

/* This structure relies on Norcroft C packing the bytes & words
   properly!
 */
typedef struct
{
  BYTE id[4];
  BYTE command;
  BYTE errclass;
  BYTE reh;
  BYTE errlo;
  BYTE errhi;
  BYTE flg;
  WORD flg2;
  WORD rsvd[6];

  WORD tid;
  WORD pid;
  WORD uid;
  WORD mid;
  BYTE wct;  /* Word count */

} SMBHDR;

/* Size of above structure - sizeof() may round to word boundary! */
#define SMBHDR_SIZE 33

/* Maximum number of word params - 14 is used by Transact */
#ifdef LONGNAMES
/* Transact2 (LONGNAMES build only) requires extra setup words.
 * The NT LM 0.12 negprot response requires 17.
 */
#define MAX_WCT (17+(MAX_SETUPWORDS)+1)
#else
#define MAX_WCT 17
#endif

/* Max number of significant characters in a shared drive
   or printer name */
#define SHARENAME_LEN 16

#define DATA_BLOCK      1
#define DATA_DIALECT    2
#define DATA_PATHNAME   3
#define DATA_ASCII      4
#define DATA_VARBLK     5

#define ECLASS_DOS      1
#define ECLASS_SRV      2
#define ECLASS_HARD     3


#define SMBmkdir      0x00   /* create directory */
#define SMBrmdir      0x01   /* delete directory */
#define SMBopen       0x02   /* open file */
#define SMBcreate     0x03   /* create file */
#define SMBclose      0x04   /* close file */
#define SMBflush      0x05   /* flush file */
#define SMBunlink     0x06   /* delete file */
#define SMBmv         0x07   /* rename file */
#define SMBgetatr     0x08   /* get file attributes */
#define SMBsetatr     0x09   /* set file attributes */
#define SMBread       0x0A   /* read from file */
#define SMBwrite      0x0B   /* write to file */
#define SMBlock       0x0C   /* lock byte range */
#define SMBunlock     0x0D   /* unlock byte range */
#define SMBctemp      0x0E   /* create temporary file */
#define SMBmknew      0x0F   /* make new file */
#define SMBchkpth     0x10   /* check directory path */
#define SMBexit       0x11   /* process exit */
#define SMBlseek      0x12   /* seek */
#define SMBreadBraw   0x1A   /* Read block raw */
#define SMBwriteBraw  0x1D   /* Write block raw */
#define SMBtransact   0x25   /* RPC transaction */
#define SMBtcon       0x70   /* tree connect */
#define SMBtdis       0x71   /* tree disconnect */
#define SMBnegprot    0x72   /* negotiate protocol */
#define SMBsesssetup  0x73   /* Session setup and X */
#define SMBdskattr    0x80   /* get disk attributes */
#define SMBsearch     0x81   /* search directory */
#define SMBsplopen    0xC0   /* open print spool file */
#define SMBsplwr      0xC1   /* write to print spool file */
#define SMBsplclose   0xC2   /* close print spool file */
#define SMBsplretq    0xC3   /* return print queue */
#define SMBsends      0xD0   /* send single block message */
#define SMBsendb      0xD1   /* send broadcast message */
#define SMBfwdname    0xD2   /* forward user name */
#define SMBcancelf    0xD3   /* cancel forward */
#define SMBgetmac     0xD4   /* get machine name */
#define SMBsendstrt   0xD5   /* send start of multi-block message */
#define SMBsendend    0xD6   /* send end of multi-block message */
#define SMBsendtxt    0xD7   /* send text of multi-block message */

#ifdef LONGNAMES
/* The following are only available with LANMAN 2.0 Extended File Sharing
 * Protocol as defined in "SMB F. S. P. Extensions Version 3.0", document
 * version 1.11, June 19, 1990.
 */
#define SMBtrans2     0x32   /* transaction2 */
#define SMBtranss2    0x33   /* transaction2 (secondary request/response) */
#define SMBfindclose2 0x34   /* terminates a TRANSACT2_FIND_FIRST/NEXT */
#define SMBecho       0x2B

/* And now the sub-commands for SMBtrans2 */
#define TRANSACT2_FINDFIRST   0x01
#define TRANSACT2_FINDNEXT    0x02
#define TRANSACT2_QUERYFSINFORMATION 0x03
#define TRANSACT2_QUERYPATHINFORMATION 0x05
#endif

#define SUCCESS   0
#define ERRDOS 0x01
#define ERRSRV 0x02
#define ERRHRD 0x03
#define ERRCMD 0xFF


#define SEARCH_TOT_SIZE 43
#define SEARCH_COUNT 10

#define PROT_USERLOGON   1
#define PROT_ENCRYPT     2
#define PROT_READRAW     4
#define PROT_WRITERAW    8
#define PROT_RWMULTI     16
#define PROT_SETDATETIME 32
#define PROT_HAVE_GUID   64

#define SMB_CASELESS   8

#ifdef LONGNAMES
#define SMB_KNOWS_LONG_NAMES	(1)
#define SMB_IS_LONG_NAME	(0x40)
#define SMB_UNICODE		(0x8000)

#define T2FLAGS_LONGNAMES	(1)
#define T2FLAGS_SWAPDATETIME	(2)
#define T2FLAGS_TESTEDSWAP	(4)

#define CAP_EXTENDED_SECURITY	(0x80000000)
#endif

/* Private structures */

#define FREE         0   /* 'flags' values: */
#define ALLOCATED    1   /* True whenever this slot is allocated */
#define CONNECTED    2   /* True if share is connected, to the best of
                             our knowledge */

/* Password fields are strewn around here as mild hacker discouragement */

struct ActiveServer
{
  int      flags;
  time_t   last_xact;

  hSESSION hSession;    /* Only valid if status is IN_USE */
  char     password[NAME_LIMIT];

  int      Uid;        /* User identifier */
  int      Sesskey;    /* Session key */
  int      ProtFlags;  /* USERLOGON/ENCRYPT etc */
  int      SMB_flg;    /* Flags to pass in SMB_flg field */
#ifdef LONGNAMES
  int      SMB_flg2;   /* Flags to pass in SMB_flg2 field */
  int      t2flags;
#endif
  int      prot;       /* which protocol was nogitated */
  char     guid[16];   /* GUID returned from NT negprot commands */
  int      bloblen;
  BYTE     *blob;
  char     servname[NAME_LIMIT]; /* upper case */
  char     username[NAME_LIMIT]; /* case preserved */
  unsigned int maxTxBufferSize; /* maximum SMB message size the server can receive */
};

typedef struct ActiveServer *hSERVER;

struct ActiveShare
{
  int     flags;

  char    password[NAME_LIMIT];
  hSERVER hServer;  /* Only valid if status is IN_USE */
  int     sharetype;

  int     Tid;          /* Tree ID */
  int     Uid;          /* User ID */
  int     Datasize;
  int     FH_base;    /* Base number for file handles */
  char    drvletter;  /* Letter for identifying 'drive' */
  char    sharename[SHARENAME_LEN];  /* upper case */
};


#define GetFid(FH) ((FH) & 0xFFFF)
#define MakeFH(pS,FID) ((pS)->FH_base | (FID & 0xFFFF) )

#ifdef LONGNAMES
static err_t SMB_Transact2 ( hSHARE hS, struct TransactParms *pT );
#endif

/* SMB globals ======================================================== */

static SMBHDR SMB_TxHdr;
static WORD   SMB_TxWords [MAX_WCT+1];

static SMBHDR SMB_RxHdr;
static WORD   SMB_RxWords [MAX_WCT];
static WORD   SMB_RxByteCount;
static int    SMB_RxWordCount;

static struct ActiveServer SMB_Servers[MAX_SERVERS];
static struct ActiveShare  SMB_Shares[MAX_SHARES];

BYTE          SMB_WorkBuf[SMBWORKBUF_SIZE];

/* SMB routines ======================================================== */

static int DOS_Errs[] =
{
  18, ENOMOREFILES,
  2,  EFILENOTFOUND,
  12, ENOTPRESENT,  /* Returned by OS2-Connect from SetAttrib */
  50, ENOTPRESENT,  /* Returned by W4WG from SetAttrib call */
  110, EFILENOTFOUND, /* Returned by OS2 servers for hidden files */
  3,  EPATHNOTFOUND,
  1,  EBADPARAM,
  5,  ENOACCESS,
  16, ESHARING,     /* Attempt to remove current dir on server */
  80, EFILEEXISTS,
  32, ESHARING,     /* Normal sharing violation */
  67, ENOSUCHSHARE, /* Returned by NT3.5 for bad share names */
  112, EDISCFULL,   /* Returned by NT3.5 when disk full */
  65, ENOACCESS,    /* Returned by W4WG on set-attribs on CDROM */
  145, EDIRNOTEMPTY, /* Attempt to remove non-empty directory */
  -1, EDOSERROR
};

/* --------------------------- */

static int SMB_Errs[] =
{
  2,  EBADPASSWD,
  4,  ENOACCESS,
  6,  ENOSUCHSHARE,
  5,  ENOACCESS,     /* Returned by W4WG when password changed */
  2239, EACCDISABLED,
  -1, ESERVERROR
};

/* --------------------------- */

static err_t Err_Translate ( int class, int code )
{
  int *p1;

  debug2(" SMB-Err class %d number %d\n", class, code );

  if ( class == 0 )
    return OK;
  else if ( class == ECLASS_DOS )
    p1 = DOS_Errs;
  else if ( class == ECLASS_SRV )
    p1 = SMB_Errs;
  else if ( class == ECLASS_HARD )
    return EHARDERROR;
  else
    return EPROTOCOLERR;

  while ( *p1 >= 0 && *p1 != code )
    p1 += 2;

  debug1(" Unknown err code %d\n", code );
  return p1[1];
}


/* --------------------- */

static BUFCHAIN MkDataBlock ( BUFCHAIN pB, int type,
                                    BYTE *ptr, int len, bool indirect )
{
  BYTE   hdrblk[4];

  if ( len > 0 )
  {
    if ( indirect )
      pB = AddChainIndirect ( pB, ptr, len );
    else
      pB = AddChain ( pB, ptr, len );

    if ( pB == NULL ) return NULL;
  }

  hdrblk[0] = type;
  hdrblk[1] = len & 0xFF;
  hdrblk[2] = len >> 8;

  return AddChain ( pB, hdrblk, 3 );
}

/* --------------------- */

/* This routine takes an ASCII string and encodes it into Unicode by
 * inserting extra zero bytes between each character and at the end
 * It adds the resulting string to the given BUFCHAIN.  It optimises
 * for strings up to AUSTC_SKIP chars long.
 */
#if 0
static BUFCHAIN AddUnicodeStringToChain ( BUFCHAIN pB, char *str )
{
#define AUSTC_SKIP 18
        int len = strlen(str)+1, skiplen, cp;
        char ucbuf[AUSTC_SKIP*2];

	skiplen = len % AUSTC_SKIP;
	len -= skiplen;

        do {
                for (cp = skiplen - 1; cp>=0; --cp) {
                        ucbuf[cp*2] = str[len + cp];
                        ucbuf[cp*2+1] = '\0';
                }
                pB = AddChain(pB, ucbuf, skiplen * 2);
                skiplen = AUSTC_SKIP;
                len -= skiplen;
        } while (pB && len >= 0);

        return pB;
}
#endif

/* --------------------- */

static BUFCHAIN MkDataString ( BUFCHAIN pB, int type, const char *ptr )
{
  BYTE   hdrblk[4];

  pB = AddChain ( pB, (void *)ptr, strlen(ptr)+1 );

  if ( pB == NULL ) return NULL;

  hdrblk[0] = type;

  return AddChain ( pB, hdrblk, 1 );
}


/* --------------------------- */

#define DumpBuffer(ptr, len) ddumpbuf("smb_1", ptr, len, 0)

#ifdef DEBUG
static BUFCHAIN DumpChain(BUFCHAIN pB)
{
        static char membuf[32768];
        int len = ChainLen(pB);

        GetData ( pB, membuf, len);
        FreeChain(pB);
        pB = AddChain ( NULL, membuf, len);
        if (pB == NULL)
                return NULL;
        DumpBuffer(membuf, len);
        return pB;
}
#else
#define DumpChain(pB) (pB)
#endif

#ifdef DEBUG
typedef struct {
        const char *name;
        int size;
} DumpVarStr;
#define DVS_MK(name,type) {name, sizeof(type)}
#define DVS_END {0,0}

DumpVarStr dvs_NTnegprot[] = {
	DVS_MK("dialect", WORD),
	DVS_MK("securitymode", BYTE),
	DVS_MK("maxmpx", WORD),
	DVS_MK("maxvcs", WORD),
	DVS_MK("maxbuffersize", DWORD),
	DVS_MK("maxrawsize", DWORD),
	DVS_MK("sessionkey", DWORD),
	DVS_MK("capabilities", DWORD),
	DVS_MK("systimelo", DWORD),
	DVS_MK("systimehi", DWORD),
	DVS_MK("servertimezone", WORD),
	DVS_MK("securitybloblen", BYTE),
	DVS_END
};

DumpVarStr dvs_negprot[] = {
	DVS_MK("dialect", WORD),
	DVS_MK("securitymode", WORD),
	DVS_MK("maxbuffersize", DWORD),
	DVS_MK("maxmpx", WORD),
	DVS_MK("maxvcs", WORD),
	DVS_MK("rawmode", WORD),
	DVS_MK("sessionkey", DWORD),
	DVS_MK("systime", WORD),
	DVS_MK("sysdate", WORD),
	DVS_MK("challengelen", WORD),
	DVS_MK("reserved (MBZ)", WORD),
	DVS_END
};

static void *DumpVar(void *ptr, const char *name, unsigned long sz)
{
        static const char *sizestr[] = { "<NULL>", "UCHAR", "USHORT", "????", "ULONG" };
	BYTE *bptr = ptr;
	unsigned long value = 0;
	unsigned long s;

	for (s=0; s<sz; ++s) {
	        value |= ((unsigned long)(*bptr++) << (s<<3UL));
	}
	dprintf(("%6s %s: %#lx (%ld)\n", sizestr[sz], name, value, value));
	return bptr;

}

static void DumpStruct(void *ptr, const DumpVarStr *dvs)
{
        while (dvs->size) {
                ptr = DumpVar(ptr, dvs->name, dvs->size);
                ++dvs;
        }
}
#else
#define DumpVar(ptr, name, sz) ((void *)(((char *)ptr)+sz))
#define DumpStruct(ptr, str) ((void)0)
#endif

/* Does one SMB command (send & reply).

   hS is the connection handle to do it on (MUST BE VALIDATED!)
   cmd is the command byte value
   wct_in is the number of Tx Words to be sent
   pB_in is any Tx Bytes to be sent afterwards, or NULL
   ppB_out is the address of a variable in which to store a pointer
        to any received bytes. If this is NULL, any received bytes
        will be discarded. If it isn't, either a pointer will be
        stored here (which MUST be freed after use), or NULL will
        be stored if there is any error.

   It will leave results in SMB_RxWords, SMB_RxWordCount and
    SMB_RxByteCount.
*/

/* sbrodie (15 Jan 1999)
 *
 * This function has been split into two parts so that SMB_Transact2 can share the
 * packet response code (now in Do_SMBResponse) with that used by Do_SMB.  SMB_Transact2
 * can have multiple response packets if the data is very large.
 */
static err_t Do_SMBResponse(hSHARE hS, int cmd, BUFCHAIN *ppB_out )
{
  int wct_rx;
  err_t res;
  BUFCHAIN pB_rx;

  if (cmd == SMBchkpth) {
    /* This was just the keep-alive message */
    debug0("Not waiting for response to SMBchkpth request\n");
    return OK;
  }

  /* Get reply */
  res = NB_GetData ( hS->hServer->hSession, &pB_rx, REPLY_TIMEOUT );
  if ( res != OK )
    return res;

  /* Extract received data */
  dprintf(("smb_2", "Do_SMB (cmd=0x%x) - NB_GetData => %d bytes\n", cmd, ChainLen(pB_rx)));

  SMB_RxHdr.wct = 0;
  SMB_RxByteCount = 0;
  SMB_RxWordCount = 0;

  pB_rx = GetData ( pB_rx, &SMB_RxHdr, SMBHDR_SIZE );
  wct_rx = SMB_RxHdr.wct;

/* sbrodie: moved this from just above "OK - all was well" comment */
  /* Process errors back from server */
  if ( SMB_RxHdr.errclass != 0 )
  {
    dprintf(("", "Do_SMB: errclass was %d\n", SMB_RxHdr.errclass));
    FreeChain(pB_rx);
    return Err_Translate ( SMB_RxHdr.errclass,
        SMB_RxHdr.errlo + (SMB_RxHdr.errhi << 8) );
  }

  if ( wct_rx > MAX_WCT )  /* Dispose of extra word results */
  {
    pB_rx = GetData ( pB_rx, SMB_RxWords, MAX_WCT*2 );
    pB_rx = GetData ( pB_rx, NULL, (wct_rx-MAX_WCT)*2 );
  }
  else if ( wct_rx > 0 )
  {
    pB_rx = GetData ( pB_rx, SMB_RxWords, wct_rx*2 );
  }

  pB_rx = GetData(pB_rx, &SMB_RxByteCount, 2); /* Get byte count */

  if ( pB_rx == NULL ) /* It's all gone horribly wrong! */
    return EDATALEN;

  /* OK - all was well */
#ifdef DEBUG
  if (cmd == SMBnegprot) debug2("Protocol negotiation returned %d words and %d bytes\n",
          wct_rx, SMB_RxByteCount);
#endif

  if (SMB_RxHdr.command == SMBchkpth) {
    /* Discard the 'ping' response */
    dprintf(("smb_1", "This response was actually to the previous chkpth call\n"));
    ppB_out = NULL;
  }

  SMB_RxWordCount = wct_rx;

  if ( ppB_out != NULL )
    *ppB_out = pB_rx;     /* Hand over ownership */
  else
    FreeChain(pB_rx);
  return OK;
}

static err_t Do_SMB_threadsafe ( hSHARE hS, int cmd, int wct_in, BUFCHAIN pB_in,
                      BUFCHAIN *ppB_out )
{
  err_t res;
  hSESSION hSess;

  (void) time(&hS->hServer->last_xact);

  if ( ppB_out != NULL ) /* If early exit, leave NULL in result */
    *ppB_out = NULL;

  hSess = hS->hServer->hSession;

  /* Fill in parameters for this connection */

  SMB_TxHdr.tid = hS->Tid;
  SMB_TxHdr.uid = hS->hServer->Uid;
  SMB_TxHdr.flg = hS->hServer->SMB_flg;
#ifdef LONGNAMES
  SMB_TxHdr.flg2 = hS->hServer->SMB_flg2;
#endif

  /* Add byte count */

  SMB_TxWords[wct_in] = ChainLen(pB_in);

  /* Add parameter words */

  pB_in = AddChain ( pB_in, SMB_TxWords, (wct_in*2) + 2 );
  if ( pB_in == NULL )
    return EOUTOFMEM;

  /* Prepare & add header */

  SMB_TxHdr.command = cmd;
  SMB_TxHdr.wct     = wct_in;

  pB_in = AddChain ( pB_in, &SMB_TxHdr, SMBHDR_SIZE );
  if ( pB_in == NULL )
    return EOUTOFMEM;

  /* Send data */

  res = NB_ClearRxQueue ( hSess );
  if (res != OK) {
    debug0("****************** NB_ClearRxQueue says there was stuff pending!!!!!!!!\n");
  }

  res = NB_SendData ( hSess, pB_in );
  if ( res != OK )
    return res;

  do {
    /* MUST avoid recursive calls to Do_SMBResponse */
    res = Do_SMBResponse(hS, cmd, ppB_out);
  } while (res == OK && SMB_RxHdr.command == SMBchkpth);

  return res;
}

static err_t Do_SMB ( hSHARE hS, int cmd, int wct_in, BUFCHAIN pB_in,
                      BUFCHAIN *ppB_out )
{
  static volatile int threaded = 0;

  if (threaded) {
    return ELANMANFSINUSE;
  }
  else {
    err_t res;
    ++threaded;
    res = Do_SMB_threadsafe(hS, cmd, wct_in, pB_in, ppB_out);
    --threaded;
    return res;
  }
}


/* ---------------------------- */

/* This attempts to do a ReadRaw on a given file. If there are any errors,
   or we're at end of file, it returns 0. Assume 'hS' etc. has been
   validated.
*/


static uint SMB_ReadRaw ( hSHARE hS,
                     int fid, uint offset, uint len, BYTE *where )
{
  err_t res;
  BUFCHAIN pB;
  hSESSION hSess = hS->hServer->hSession;;

  if (len>RDRAW_BLOCK_SIZE) len=RDRAW_BLOCK_SIZE;

  SMB_TxWords[0] = fid;
  SMB_TxWords[1] = (offset & 0xFFFF);
  SMB_TxWords[2] = (offset >> 16 );
  SMB_TxWords[3] = len;
  SMB_TxWords[4] = 0; /* Minimum returned byte count */

  SMB_TxWords[5] = 0xFFFF; /* Timeout */
  SMB_TxWords[6] = 0xFFFF;

  SMB_TxWords[7] = 0; /* Reserved */
  SMB_TxWords[8] = 0; /* Following byte count */

  pB = AddChain( NULL, SMB_TxWords, 18 );
  if ( pB == NULL )
    return 0;

  SMB_TxHdr.tid = hS->Tid;
  SMB_TxHdr.uid = hS->hServer->Uid;

  SMB_TxHdr.command = SMBreadBraw;
  SMB_TxHdr.wct     = 8; /* Word count */

  pB = AddChain ( pB, &SMB_TxHdr, SMBHDR_SIZE );
  if ( pB == NULL )
    return 0;

  /* Send data */

  NB_ClearRxQueue ( hSess ); /* Ensure reply is correct */

  res = NB_SendData ( hSess, pB );
  if ( res != OK )
  {
    debug1("Send data failed, %d\n", res);
    return 0;
  }

  /* Get reply (raw data block) */

  res = NB_GetBlockData ( hSess, where, &len, REPLY_TIMEOUT );
  if ( res != OK )
    return 0;

  return len;
}

/* ---------------------------- */

static err_t SMB_WriteRaw ( hSHARE hS, int fid, uint offset,
                    uint len, BYTE *where )
{
  err_t res;

  SMB_TxWords[0] = fid;
  SMB_TxWords[1] = len;
  SMB_TxWords[2] = 0;
  SMB_TxWords[3] = (offset & 0xFFFF);
  SMB_TxWords[4] = (offset >> 16 );
  SMB_TxWords[5] = 0xFFFF; /* Timeout */
  SMB_TxWords[6] = 0xFFFF;

  SMB_TxWords[7] = 0; /* Write mode: write-through */
  SMB_TxWords[8] = 0; /* Reserved */
  SMB_TxWords[9] = 0; /* Reserved */
  SMB_TxWords[10] = 0; /* # of data bytes immediately following */
  SMB_TxWords[11] = 0; /* Offset to immediate data bytes */

  res = Do_SMB ( hS, SMBwriteBraw, 12, NULL, NULL );
  if ( res != OK )
    return res;

  /* If no error, just send the data in a large block. Any errors
     will be picked up on the next write or close operation. If
     we get to this stage, we can assume 'drv' is validated. */

  return NB_SendBlockData ( hS->hServer->hSession, where, len );

}

/* sbrodie: Abstract the dialect strings here - means debug version can
 * call this function to find out which protocol was accepted.  The
 * offsets within the array of each string are vital to SMB_Negotiate.
 */
static const char *dialects[] = {
                "PC NETWORK PROGRAM 1.0",
                "DOS LM1.2X002",
                "LM1.2X002",
                "NT LM 0.12"
};
#define MAX_DIALECT ((sizeof(dialects)/sizeof(*dialects))-1)
#define DIALECT_BASIC 0
#define DIALECT_LM12X002 1
#define DIALECT_NT 3
static const char *SMB_Dialect(unsigned int num)
{
        if (num <= MAX_DIALECT) return dialects[num];
        return "";
}

/* ---------------------------- */

static err_t SMB_Negotiate( hSHARE hS )
{
  err_t res;
  unsigned int dcount;
  BUFCHAIN pB;

  pB = NULL;

  /* Must be entered in reverse order */
  for (dcount = MAX_DIALECT; ; --dcount) {
    pB = MkDataString( pB, DATA_DIALECT, SMB_Dialect(dcount));
    if (pB == NULL || dcount == 0) break;
  }

  if ( pB == NULL )
    return EOUTOFMEM;

  res = Do_SMB ( hS, SMBnegprot, 0, pB, &pB );
  if ( res != OK )
    return res;


  debug1("Negotiated protocol `%s'\n", SMB_Dialect(SMB_RxWords[0]));
  hS->hServer->prot = SMB_RxWords[0];
  if ( SMB_RxWords[0] >= DIALECT_LM12X002 )
  {
    if (SMB_RxWords[0] >= DIALECT_NT) {
      /* grr - different response format */
      hS->hServer->maxTxBufferSize = (SMB_RxWords[3] >> 8) | (SMB_RxWords[4] << 8) | (SMB_RxWords[5] << 24);
      hS->hServer->ProtFlags = PROT_RWMULTI + PROT_SETDATETIME +
         (SMB_RxWords[9] & 0x100 ? PROT_READRAW+PROT_WRITERAW : 0 ) +
         (SMB_RxWords[1] & 1 ? PROT_USERLOGON : 0 ) +
         (SMB_RxWords[1] & 2 ? PROT_ENCRYPT : 0 );
      if (SMB_RxWords[11] & 0x80) {
        /* CAP_EXTENDED_SECURITY */
        hS->hServer->ProtFlags |= PROT_HAVE_GUID;
        GetData(pB, hS->hServer->guid, 16);
        debug0("Found a GUID block in the data section\n");
      }
      else {
        /* No bit */
        debug0("No extended security - no GUID in the data block\n");
      }
      hS->hServer->bloblen = SMB_RxWords[16] >> 8;
      hS->hServer->Sesskey = (SMB_RxWords[7] >> 8) | (SMB_RxWords[8] << 8) | (SMB_RxWords[9] << 24);
    }
    else {
      hS->hServer->maxTxBufferSize = SMB_RxWords[2];
      hS->hServer->ProtFlags = PROT_RWMULTI + PROT_SETDATETIME +
         (SMB_RxWords[1] & 1 ? PROT_USERLOGON : 0 ) +
         (SMB_RxWords[1] & 2 ? PROT_ENCRYPT : 0 ) +
         (SMB_RxWords[5] & 1 ? PROT_READRAW : 0 ) +
         (SMB_RxWords[5] & 2 ? PROT_WRITERAW : 0 );
      hS->hServer->bloblen = SMB_RxWords[11];
      hS->hServer->Sesskey = SMB_RxWords[6] | (SMB_RxWords[7] << 16);
    }
    hS->hServer->SMB_flg = SMB_CASELESS;
#ifdef LONGNAMES
    debug0("Enabling long filenames on this share\n");
    hS->hServer->SMB_flg2 = SMB_KNOWS_LONG_NAMES; /* | SMB_IS_LONG_NAME;*/
    hS->hServer->t2flags = T2FLAGS_LONGNAMES;
#endif
    if (hS->hServer->bloblen > 0) {
      free(hS->hServer->blob);
      hS->hServer->blob = malloc(hS->hServer->bloblen);
      if (hS->hServer->blob != NULL) {
        GetData(pB, hS->hServer->blob, hS->hServer->bloblen);
      }
    }
    else {
      hS->hServer->blob = 0;
    }
  }
  else
  {
    hS->hServer->maxTxBufferSize = MAX_CORE_TX_BLOCK_SIZE;
    hS->hServer->ProtFlags = PROT_SETDATETIME;
    hS->hServer->SMB_flg = 0;
#ifdef LONGNAMES
    hS->hServer->t2flags = 0;
    hS->hServer->SMB_flg2 = 0;
#endif
  }
  FreeChain(pB);
  debug1("%s-level security\n", hS->hServer->ProtFlags & PROT_USERLOGON ? "User" : "Share");
  return OK;
}

/* ------------------------------- */

/* Session setup logs the user on with a given name and password */

static err_t SMB_SessSetup ( hSHARE hS, char *userid, char *passwd )
{
  BUFCHAIN pB;
  err_t res;

  SMB_TxWords[0] = 0x00FF; /* No additional command */
  SMB_TxWords[1] = 0;      /* Offset to next cmd */
  SMB_TxWords[2] = MAX_RX_BLOCK_SIZE; /* Maximum SMB message size we can receive */
  SMB_TxWords[3] = 1;      /* Max pending requests */
  SMB_TxWords[4] = 0;      /* First & only VC */
  SMB_TxWords[5] = hS->hServer->Sesskey & 0xFFFF;
  SMB_TxWords[6] = hS->hServer->Sesskey >> 16;

  if (hS->hServer->prot < DIALECT_NT) {
    pB = AddChain ( NULL, userid, strlen(userid)+1 );
    if ( pB != NULL ) pB = AddChain ( pB, passwd, strlen(passwd)+1 );
    if ( pB == NULL )
      return EOUTOFMEM;

    SMB_TxWords[7] = strlen ( passwd ) + 1;
    SMB_TxWords[8] = 0;
    SMB_TxWords[9] = 0;

    res = Do_SMB ( hS, SMBsesssetup, 10, pB, NULL );
  }
  else if (hS->hServer->ProtFlags & PROT_HAVE_GUID) {
    /* CAP_EXTENDED_SECURITY is supported by the server - setup session accordingly */
    SMB_TxWords[7] = hS->hServer->bloblen;
    SMB_TxWords[8] = SMB_TxWords[9] = 0; /* reserved */
    SMB_TxWords[10] = SMB_TxWords[11] = 0; /* client capabilities */
    pB = AddChain (NULL, "CIFS", sizeof("CIFS"));
    if (pB) pB = AddChain ( pB, "RISCOS", sizeof("RISCOS"));
    if (pB) pB = AddChain ( pB, hS->hServer->blob, hS->hServer->bloblen );
    if (pB == NULL )
      return EOUTOFMEM;
    res = Do_SMB ( hS, SMBsesssetup, 12, pB, NULL );
  }
  else {
    /* Server does not support extended security */
    if (hS->hServer->ProtFlags & PROT_ENCRYPT)
    {
      unsigned char lmowfv2digest[16];
      unsigned char challengeResponse[24];

      if (strlen( passwd ) != 0)
      {
        Auth_LMOWFv2( (const char *)passwd, strlen( passwd ),
                      (const char *)userid, strlen( userid ),
                      (const char *)userid, 0, /* no domain */
                      lmowfv2digest );
        Auth_LMv2ChallengeResponse( lmowfv2digest, (void *)hS->hServer->blob, challengeResponse );
        SMB_TxWords[7] = sizeof(challengeResponse);
      }
      else
      {
        SMB_TxWords[7] = 0;
      }
      SMB_TxWords[8] = 0;
      SMB_TxWords[9] = SMB_TxWords[10] = 0; /* Reserved */
      SMB_TxWords[11] = SMB_TxWords[12] = 0; /* client capabilities */
      pB = AddChain( NULL, "CIFS", sizeof("CIFS") );
      if (pB) pB = AddChain( pB, "\0RISCOS", sizeof("\0RISCOS") );
      if (pB) pB = AddChain( pB, userid, strlen(userid) + 1 );
      if (pB && (SMB_TxWords[7] != 0)) pB = AddChain( pB, challengeResponse, sizeof(challengeResponse) );
      if (pB) pB = DumpChain( pB );
      if (pB == NULL)
        return EOUTOFMEM;
    }
    else
    {
      SMB_TxWords[7] = strlen ( passwd );
      SMB_TxWords[8] = 0;
      SMB_TxWords[9] = SMB_TxWords[10] = 0; /* Reserved */
      SMB_TxWords[11] = SMB_TxWords[12] = 0; /* client capabilities */
      pB = AddChain( NULL, "CIFS", sizeof("CIFS") );
      if (pB) pB = AddChain( pB, "\0RISCOS", sizeof("\0RISCOS") );
      if (pB) pB = AddChain( pB, userid, strlen(userid) + 1 );
      if (pB) pB = AddChain( pB, passwd, strlen(passwd) );
      if (pB) pB = DumpChain( pB );
      if (pB == NULL)
        return EOUTOFMEM;
    }
    res = Do_SMB ( hS, SMBsesssetup, 13, pB, NULL );
  }
  if ( res != OK )
    return res;

  hS->hServer->Uid = SMB_RxHdr.uid;

  return OK;
}

/* ---------------------------- */

/* Keep in step with #defines in H.SMB ! */

static char *sharetype_str[4] =
{
  "A:", "LPT1:", "COMM", "IPC"
};

/* ConnectShare connects to a given share, with share name & type &
   password as given in the hSHARE structure. hS->hServer is
   assumed to be valid & connected
*/

static err_t ConnectShare ( hSHARE hS )
{
  BUFCHAIN pB;
  err_t res;

  /* Mild sanity check */

  if ( hS==NULL || hS->hServer==NULL ||
       hS->sharetype < 0 || hS->sharetype > 3 )
    return EBADPARAM;

  debug3("Connect share %c to \\\\%s\\%s\n", hS->drvletter,
            hS->hServer->servname, hS->sharename );

  pB = MkDataString( NULL, DATA_ASCII, sharetype_str[hS->sharetype] );

  if ( pB == NULL ) return EOUTOFMEM;

  /* For user-based logon schemes, there is not a password for
      tree connect */

  if ( hS->hServer->ProtFlags & PROT_USERLOGON )
    pB = MkDataString ( pB, DATA_ASCII, "" );
  else
  {
    Xlt_Unjumble ( hS->password );
    pB = MkDataString ( pB, DATA_ASCII, hS->password );
    Xlt_Jumble ( hS->password );
  }

  if ( pB == NULL ) return EOUTOFMEM;

  /* Path name is of the form \\SERVER\SHARENAME */

  sprintf( (char*)SMB_WorkBuf, "\\\\%s\\%s", hS->hServer->servname,
                                             hS->sharename );
  pB = MkDataString ( pB, DATA_ASCII, (char *)SMB_WorkBuf );

  if ( pB == NULL ) return EOUTOFMEM;

  /* Do connection */

  res = Do_SMB ( hS, SMBtcon, 0, pB, NULL );

  if ( res == OK )
  {
    hS->Tid      = SMB_RxWords[1];
    hS->Datasize = SMB_RxWords[0];
    hS->flags   |= CONNECTED;     /* Clear CONN_LOST flag */
  }

  return res;
}



/* ----------------------------- */

static err_t DisconnectShare ( hSHARE hS )
{
  if ( hS==NULL )       /* Shouldn't happen, but make sure */
    return EBADPARAM;

  debug3("Disconnect share %c from \\\\%s\\%s\n", hS->drvletter,
            hS->hServer->servname, hS->sharename );

  /* Say connection has been broken; if the operation fails it's
     probably been broken already */

  hS->flags &= ~CONNECTED;

  /* Do SMB Tree disconnect operation */
  return Do_SMB ( hS, SMBtdis, 0, NULL, NULL );
}

/* ------------------------------ */

/* ConnectServer attempts to connect to a given server. It is actually
   passed an hSHARE handle for internal reasons. It it assumed that
   hS->hServer has been set up to point to a valid server, and that
   the server name, user name & password are set up correctly.
*/

static err_t ConnectServer ( hSHARE hS )
{
  NETNAME nnserver;
  hSERVER hSrv;
  err_t res;

  if ( hS == NULL || (hSrv=hS->hServer, hSrv == NULL) )
    return EBADPARAM;

  debug1("Connect server %s\n", hSrv->servname);

  /* Set initial values */

  hSrv->ProtFlags = 0;
  hSrv->SMB_flg = 0;
  hSrv->Uid = 0;
  hSrv->Sesskey = 0;
  hSrv->hSession = NULL;

  /* Try to contact server */

  debug0("NB_FormatName..\n");
  res = NB_FormatName ( ntSERVER, hSrv->servname, &nnserver );
  if ( res != OK )
    return res;

  /* Try to contact server */

  debug0("NB_OpenSession..\n");
  res = NB_OpenSession( NB_MachineName, &nnserver, &(hSrv->hSession) );
  if ( res != OK )
    return res;

  /* Establish protocol */

  debug0("SMB_Negotiate..\n");
  res = SMB_Negotiate ( hS );
  if ( res != OK )
    goto abort_server;

  /* Logon user, if it's that sort of server */

  if (hSrv->ProtFlags & PROT_USERLOGON)
  {
    Xlt_Unjumble(hSrv->password);
  debug0("SMB_SessSetup..\n");
    res = SMB_SessSetup ( hS, hSrv->username, hSrv->password );
    Xlt_Jumble(hSrv->password);

    if ( res != OK ) goto abort_server;
  }

  debug0("ConnectServer succeeds\n");

  return OK;

abort_server:
  NB_CloseSession(hSrv->hSession);
  hSrv->hSession = NULL;
  return res;
}

/* ------------------------------ */

static err_t DisconnectServer ( hSERVER hSrv )
{
  int i;
  hSHARE hS;

  if ( hSrv == NULL )
    return EBADPARAM;

  debug1("Disconnect server %s\n", hSrv->servname);

  /* Disconnect Server implicity closes all shares using it;
     fortunately, the server will do all this if we drop the
     link. All we have to do is mark the relevant shares as being
     disconnected.
  */

  hS = SMB_Shares;
  for ( i=0; i < MAX_SHARES; i++ )
  {
    if ( (hS->flags & ALLOCATED) &&
         (hS->hServer == hSrv )     )
      hS->flags &= ~CONNECTED;

    hS++;
  }

  /* Close NetBIOS session */
  if ( hSrv->hSession != NULL )
  {
    NB_CloseSession(hSrv->hSession);
    hSrv->hSession = NULL;
  }
  return OK;
}

/* As a general rule, the routines above don't perform
   any allocation/deallocation functions, only the network
   transactions themselves. These are dealt with in the following
   bits.
*/

/* ==========================================  */

static hSERVER AllocServer ( void )
{
  hSERVER hS;
  int i;

  for ( hS = SMB_Servers, i=0; i < MAX_SERVERS; hS++, i++ )
    if ( (hS->flags & ALLOCATED)==0 )
    {
      hS->flags = ALLOCATED;
      hS->hSession = 0;
      hS->blob = 0;
#ifdef LONGNAMES
      hS->t2flags = 0;
#endif
      return hS;
    }

  return NULL;
}

/* ----------------------------------- */

static hSHARE AllocShare ( void )
{
  hSHARE hS;
  int i;

  for ( hS = SMB_Shares, i=0; i < MAX_SHARES; hS++, i++ )
    if ( (hS->flags & ALLOCATED)== 0 )
    {
      hS->flags = ALLOCATED;
      hS->hServer = NULL;
      hS->Tid=0;
      hS->Datasize=0;
      return hS;
    }

  return NULL;
}

/* ----------------------------------- */

static bool ServerInUse ( hSERVER hServ )
{
  int i;
  hSHARE hS;

  for ( hS=SMB_Shares, i=0; i<MAX_SHARES; hS++, i++ )
  {
    if ( hS->hServer == hServ && (hS->flags & ALLOCATED)  )
      return true;
  }

  return false;
}

/* ----------------------------------- */

static hSERVER FindServer ( char *serv_name )
{
  hSERVER hS;
  int i;

  for ( hS = SMB_Servers, i=0; i < MAX_SERVERS; hS++, i++ )
  {
    if ( (hS->flags & ALLOCATED) &&
         stricmp ( hS->servname, serv_name ) == 0
       )
      return hS;
  }

  return NULL;
}

/* ----------------------------------- */

static hSHARE FindShare ( hSERVER hServ, char *share_name )
{
  hSHARE hS;
  int i;

  for ( hS = SMB_Shares, i=0; i < MAX_SHARES; hS++, i++ )
  {
    if ( hS->hServer == hServ && (hS->flags & ALLOCATED) &&
         stricmp ( hS->sharename, share_name ) == 0
       )
      return hS;
  }

  return NULL;
}


/* ----------------------------------- */

static void FreeServer ( hSERVER hS )
{
  if (hS->flags != FREE) {
    free(hS->blob);
    hS->blob = NULL;
  }
  hS->flags = FREE;
}

/* ----------------------------------- */

static void FreeShare ( hSHARE hS )
{
  hS->flags = FREE;
}

/* =======================================  */

/* Validates a share, given a filename (the first character being the
   drive letter). If the link to the server has failed, it will
   attempt to reconnect it before returning.

   Unlike most routines, it returns an hSHARE as a result and an error
   via a pointer. The hSHARE will be non-Null if & only if the result is
   OK; it is acceptable to test either.
*/

static hSHARE GetShare ( const char *filename, err_t *pRes )
{
  uint tmp;
  hSHARE hS;
  err_t res;

  /* Is drive letter in range & in use? */

  tmp = filename[0] - 'A';
  if ( tmp >= MAX_SHARES ||
        (hS=&SMB_Shares[tmp], (hS->flags & ALLOCATED)==0) )
  {
    *pRes = EBADDRV;
    return NULL;
  }

  /* Can we still talk to the server */

  if ( !NB_LinkOK ( hS->hServer->hSession ) )
  {
    DisconnectServer(hS->hServer);      /* Drop links, deallocate stuff */

    res = ConnectServer(hS);   /* Try to reconnect to server */
    if ( res != OK )
    {
      *pRes = res;
      return NULL;
    }
  }

  /* Server works, now see if we need reconnecting */

  if ( (hS->flags & CONNECTED) == 0 )
  {
    res = ConnectShare(hS);
    if ( res != OK )
    {
      *pRes = res;
      return NULL;
    }
  }

  *pRes = OK;
  return hS;
}


/* ---------------------------- */

/* GetShareNoConn() is used to validate a drive letter when
    we aren't bothered if the connection is lost (e.g. for
    the GetConnInfo or DisconnectShare calls)
*/
static hSHARE GetShareNoConn ( uint letter )
{
  letter -= 'A';
  if ( (letter < MAX_SHARES) &&
       (SMB_Shares[letter].flags & ALLOCATED) )
    return &SMB_Shares[letter];

  return NULL;
}


/* ---------------------------- */

#ifdef LONGNAMES
/* SMB_IsLongNameFS() returns true if the path refers to a share which is
 * using long filenames.  Xlate.c needs to know this in order to determine
 * which set of file mappings is to be used.
 */
bool SMB_IsLongNameFS( const char * path)
{
  hSHARE hS;

  hS = GetShareNoConn(*path);
  if (hS != NULL && (hS->hServer->t2flags & T2FLAGS_LONGNAMES)) return true;
  return false;
}
#endif  

/* --------------------- */

/* When trying to get a share ID from a file handle, there's
   no point reconnecting, because the handle wouldn't be valid
   anyway.
*/

static hSHARE GetShareFromFH ( uint FH, err_t *pRes )
{
  FH = (FH >> 16);  /* Get share identifier from file handle */
  if ( FH < MAX_SHARES )
  {
    hSHARE hS=&SMB_Shares[FH];

    if ( (hS->flags & (ALLOCATED|CONNECTED))  == (ALLOCATED|CONNECTED) )
      return hS;
  }

  *pRes = EFILEHANDLE;
  return NULL;
}

/* ----------------------------- */

static err_t SMB_SingleOp ( int op, char *path )
{
  BUFCHAIN pB;
  hSHARE hS;
  err_t res;

  hS = GetShare (path, &res);
  if ( hS == NULL )
    return res;

  pB = MkDataString( NULL, DATA_ASCII, path+2 );
  if ( pB == NULL )
    return EOUTOFMEM;

  return Do_SMB ( hS, op, 0, pB, NULL );
}

/* Public Connect/disconnect operations ====================== */

/* CreateShare can do about five different things, depending on
    the current state of the system. See SMB.H for full
    description of the parameters. Scenarios include
    - connection to a new share on a new server
    - if we're already connected to the given server and the
        given user name is blank or the same, connect to a new
        share on the same server.
    - if we're already connected to the given server and the
        given user name is different, reconnect to the server;
        the share name may be the same as an existing name (in
        which case we're just changing user ID) or it may be
        a new one (in which case it needs adding)
    - if all of (server name, user name, share name) are the
        same, return the drive letter corresponding to this
        connection.

    This is all a bit of a logical nightmare, especially as we
    have to back out gracefully if any bit fails, so I've written
    it out using flags which get set as each thing needs to be
    done.

*/

static bool IsBlank ( char *str )
{
  while ( isspace(*str) ) str++;  /* Skip leading spaces */

  if ( iscntrl(*str) )            /* If it's the end, it's blank */
    return true;

  return false;
}

#define ALLOC_SERVER   1
#define ALLOC_SHARE    2
#define DISCONN_SERVER 4
#define CONN_SERVER    8

err_t SMB_CreateShare (  int sharetype_in,
                         int style,
                         char *servname_in, char *sharename_in,
                         char *username_in, char *password_in,
                         char *drv_letter_out )
{
  hSHARE hShare;
  hSERVER hServ;
  char uc_sharename[SHARENAME_LEN];
  char uc_servname [NAME_LIMIT];
  char plain_password[NAME_LIMIT];
  int to_do, done;
  err_t res;

  /* Validate & format parameters */
#ifdef TRACE
  debug2("Server name %p; share name %p\n", servname_in, sharename_in);
  debug2("Server name `%s'; share name `%s'\n", servname_in, sharename_in);
#endif

  if ( servname_in == NULL || sharename_in==NULL )
    return EBADPARAM;

  strcpyn_upper ( uc_sharename, sharename_in, SHARENAME_LEN);
  strcpyn_upper ( uc_servname,  servname_in, NAME_LIMIT);

  if ( username_in == NULL ) username_in = "";
  if ( password_in == NULL ) password_in = "";

  /* Work out a list of what we have to do ------------ */

  to_do = 0;

  hServ = FindServer ( uc_servname );

  if ( hServ == NULL )  /* New server */
  {
    hShare = NULL;
    to_do |= (ALLOC_SERVER | ALLOC_SHARE | CONN_SERVER);

    /* If both names are blank, use logon names */
    if ( IsBlank(username_in) && IsBlank(password_in) )
    {
      username_in = LM_Vars.username;
      Xlt_Unjumble ( LM_Vars.password_ptr );
      strcpyn ( plain_password, LM_Vars.password_ptr, NAME_LIMIT );
      Xlt_Jumble ( LM_Vars.password_ptr );
      password_in = plain_password;
    }
  }
  else
  {
    /* Already have connection to server */
    hShare = FindShare(hServ, uc_sharename);

    if ( hShare == NULL ) /* New share on existing server */
      to_do |= (ALLOC_SHARE);

    /* Check if user name is being given. If not,
       disconnect and reconnect to force name change */

    if ( (style & CREATE_NEW_USER) && !IsBlank (username_in)  )
      to_do |= (DISCONN_SERVER | CONN_SERVER);
  }

  /* Check that's OK with the given style ----- */

  if ( (style & CREATE_NEW_SHARE) && !(to_do & ALLOC_SHARE) )
  {
    /* If the share already exists, and the 'insist it's something
       new' bit is set,  we fail the call and say  which drive letter
       it is. Otherwise, we drop through the rest of the code - the
       only thing that might happen is a disconnect/reconnect to
       change user ID */
    *drv_letter_out = hShare->drvletter;
    return ECONNEXISTS;
  }

  /* Now do each bit ----------------------- */

  done = 0;

  /* Ensure hServ is allocated */
  if ( to_do & ALLOC_SERVER )
  {
    hServ = AllocServer();
    if ( hServ == NULL )
    {
      res = ECONNLIMIT;
      goto fail;
    }
    strcpy  ( hServ->servname, uc_servname );
    done |= ALLOC_SERVER;
  }

  /* Ensure hShare is allocated & set up */
  if ( to_do & ALLOC_SHARE )
  {
    hShare = AllocShare();
    if ( hShare == NULL )
    {
      res = ECONNLIMIT;
      goto fail;
    }

    /* Assume flags don't have CONNECTED set */
    hShare->hServer = hServ;
    hShare->sharetype = sharetype_in;
    strcpy  ( hShare->sharename, uc_sharename );
    strcpyn ( hShare->password, password_in, NAME_LIMIT );
    Xlt_Jumble(hShare->password);
    done |= ALLOC_SHARE;
  }

  /* Clear attribute-file cache for the drive */

  Attr_InvalidateDrive ( hShare->drvletter );

  /* Disconnect server if new user */

  if ( to_do & DISCONN_SERVER )
  {
    /* For a change of user, disconnect the server. It will mark
       all attached shares as being disconnected */
    DisconnectServer ( hServ );
    done |= DISCONN_SERVER;
  }

  /* (re)connect to server */

  if ( to_do & CONN_SERVER )
  {
    /* Set up new server details */
    strcpyn_upper ( hServ->username, username_in, NAME_LIMIT );
    strncpy ( hServ->password, password_in, NAME_LIMIT );
    Xlt_Jumble(hServ->password);

    res = ConnectServer ( hShare );
    if ( res != OK )
      goto fail;

    done |= CONN_SERVER;
  }

  /* Connect to share ------------------- */

  /* Reconnect share, & reconnect link if it's down */
  if ( GetShare ( &(hShare->drvletter), &res ) == NULL )
    goto fail;

  *drv_letter_out = hShare->drvletter;
  return OK;

  /* Back out if something goes wrong */

fail:
  if ( done & ALLOC_SHARE )   /* If it was a new share */
    FreeShare(hShare);        /*   free it */

  if ( done & ALLOC_SERVER )  /* If it was a new server... */
  {
    if ( done & CONN_SERVER )  /* Disconnect it if it was */
      DisconnectServer(hServ); /* connected */

    FreeServer(hServ);
  }

  return res;
}

/* --------------------------- */

err_t SMB_DeleteShare ( char drvlettr )
{
  hSHARE  hS;
  hSERVER hSrv;

  hS = GetShareNoConn(drvlettr);
  if ( hS == NULL )
    return EBADDRV;

  hSrv = hS->hServer;

  /* Do Tree disconnect */

  DisconnectShare(hS);
  FreeShare(hS);

  /* If there are no shares left on this server, drop link */

  if ( !ServerInUse(hSrv) )
  {
    DisconnectServer(hSrv);
    FreeServer(hSrv);
  }

  return OK;
}

/* Public file/directory routines ================================ */

static err_t SMB_ChkPath ( char *path )
{
  return SMB_SingleOp( SMBchkpth, path );
}

/* ----------------------------- */

err_t SMB_MkDir ( char *path )
{
  return SMB_SingleOp( SMBmkdir, path );
}

/* ----------------------------- */

err_t SMB_RmDir ( char *path )
{
  return SMB_SingleOp( SMBrmdir, path );
}

/* ----------------------------- */

err_t SMB_Delete ( char *path )
{
  BUFCHAIN pB;
  hSHARE hS;
  err_t res;

  hS = GetShare (path, &res);
  if ( hS == NULL )
    return res;

  pB = MkDataString( NULL, DATA_ASCII, path+2 );
  if ( pB == NULL )
    return EOUTOFMEM;

  SMB_TxWords[0] = ATTR_NORM;

  return Do_SMB ( hS, SMBunlink, 1, pB, NULL );
}


/* ----------------------------- */

err_t SMB_Rename ( char *oldpath, char *newpath )
{
  BUFCHAIN pB;
  hSHARE hS;
  err_t res;

  if ( oldpath[0] != newpath[0] )  /* Different drives! */
    return EBADRENAME;

  debug2("SMB_Rename: %s %s\n", oldpath+1, newpath+1);
  if (strcmp(oldpath+1, newpath+1) == 0)
    return OK;

  hS = GetShare (oldpath, &res);
  if ( hS == NULL )
    return res;

  pB = MkDataString( NULL, DATA_ASCII, newpath+2 );
  if ( pB != NULL ) pB = MkDataString ( pB, DATA_ASCII, oldpath+2 );

  if ( pB == NULL )
    return EOUTOFMEM;

  SMB_TxWords[0] = ATTR_NORM | ATTR_DIR; /* Permit both file and dir renaming */

  return Do_SMB ( hS, SMBmv, 1, pB, NULL );
}

/* --------------------------- */

#ifdef LONGNAMES

/* Some Microsoft servers not sending them in the documented order */
static void swap_time_date(BYTE *p)
{
        BYTE swp;

        swp = p[0];
        p[0] = p[2];
        p[2] = swp;

        swp = p[1];
        p[1] = p[3];
        p[3] = swp;
}

static err_t SMB_GetAttribsX2 (hSHARE hS, char *filename, DOS_ATTRIBS *pAttr )
{
  err_t res;
  BYTE *resb;
  static struct TransactParms tp;

  debug1("SMB_GetAttribs: %s\n", filename);
  resb = NameCache_Locate(filename);
  if (resb != NULL) {
    Transact_init(&tp, 1 * 2);           /* need to initialise tp.data_out_buf!! */
    memcpy( tp.data_out_buf, resb, 23);
    strcpy( (char *) tp.data_out_buf + 23, (char *) resb + 23);
    return Xlt_ExpandSearchEntryX2 ( tp.data_out_buf, NULL, NULL, pAttr, NULL);
  }

  if (!(hS->hServer->t2flags & T2FLAGS_TESTEDSWAP))
  {
    /* Need to test whether we have to swap the date/time fields */
    char        fnbuffer[8];
    DOS_ATTRIBS aattrbuf;
    DOS_ATTRIBS sattrbuf;

    hS->hServer->t2flags |= T2FLAGS_TESTEDSWAP;
    fnbuffer[0] = *filename;
    fnbuffer[1] = ':';
    fnbuffer[2] = '\\';
    fnbuffer[3] = '\0';
    debug1("Looking up `%s' to test buffer format\n", fnbuffer);
    if (SMB_GetAttribsX2 ( hS, fnbuffer, &aattrbuf ) == OK)
    {
      fnbuffer[3] = '\0';
      Transact_init(&tp, 6 * 2);           /* will accept 6 WORD return params */
      Transact_addsetupword(&tp, TRANSACT2_FINDFIRST);
      if (LM_Vars.namemode & NM_INTERNAL)
      {                                    /* findfirst_Attribute */
        Transact_addword(&tp, ATTR_DIR | ATTR_SYS | ATTR_HID);
      }
      else
      {
        Transact_addword(&tp, ATTR_DIR);     
      }
      Transact_addword(&tp, 1);            /* findfirst_SearchCount = 1 please */
      Transact_addword(&tp, 1);            /* findfirst_Flags = auto close after this query */
      Transact_addword(&tp, 1);            /* Search level = standard level  */
      Transact_addlong(&tp, 0L);           /* reserved, MBZ */
      Transact_addstring(&tp, fnbuffer+2); /* findfirst_FileName[] */
      debug1("Looking for `%s'\n", fnbuffer+2);
      res = SMB_Transact2(hS, &tp);
      if (res == OK)
      {
        debug0("SMB_Transact2 worked\n");
        SMB_TxWords[0] = Transact_getword(tp.parms_out_buf);
        if (Transact_getword(tp.parms_out_buf + 2) == 1)
        {
          debug1("Filename was `%s'\n", tp.data_out_buf + 23);
          res = Xlt_ExpandSearchEntryX2 ( tp.data_out_buf, NULL, NULL, &sattrbuf, NULL);
          if (res == OK)
          {
            if (sattrbuf.utime != aattrbuf.utime)
            {
               debug0("Might need to swap date/time\n");
               swap_time_date(tp.data_out_buf+0);
               swap_time_date(tp.data_out_buf+4);
               swap_time_date(tp.data_out_buf+8);
               Xlt_ExpandSearchEntryX2 ( tp.data_out_buf, NULL, NULL, &sattrbuf, NULL);
               if (sattrbuf.utime != aattrbuf.utime)
               {
                 debug0("Even after swapping they don't match\n");
               }
               else
               {
                 hS->hServer->t2flags |= T2FLAGS_SWAPDATETIME;
                 debug0("Tested and verified!\n");
               }
            }
            else
            {
               debug0("Don't need to swap date/time!\n");
            }
          }
        }
      }
      else
      {
        debug0("SMB_Transact2 failed\n");
      }
    }
  }

  Transact_init(&tp, 1 * 2);
  Transact_addsetupword(&tp, TRANSACT2_QUERYPATHINFORMATION);
  Transact_addword(&tp, 1);  /* information level */
  Transact_addlong(&tp, 0L); /* Reserved */
  Transact_addstring(&tp, filename+2);
  res = SMB_Transact2(hS, &tp);
  if (res != OK)
    return res;
  /*
   * OK.  Who decided that this call should return data in a different
   * format than the FindFirst/FindNext calls.  Need to reverse the times
   * and dates of the file before calling Xlt to expand them ... but only
   * if the remote server has this bug.
   */
  if (hS->hServer->t2flags & T2FLAGS_SWAPDATETIME)
  {
    swap_time_date(tp.data_out_buf);
    swap_time_date(tp.data_out_buf+4);
    swap_time_date(tp.data_out_buf+8);
  }
  /* end workaround */
  strcpy((char *)tp.data_out_buf+23, filename); /* Xlt_ExpandSearchEntryX2 relies on this */
  return Xlt_ExpandSearchEntryX2 ( tp.data_out_buf, NULL, NULL, pAttr, NULL);
}
#endif /* LONGNAMES */

/* --------------------------- */

#if 0
err_t SMB_GetAttribs ( char *filename, DOS_ATTRIBS *pAttr )
{
  err_t res;
  BUFCHAIN pB;
  hSHARE hS;

  hS = GetShare (filename, &res);
  if ( hS == NULL )
    return res;

  pB = MkDataString ( NULL, DATA_ASCII, filename+2 );
  if ( pB == NULL )
    return EOUTOFMEM;

  res = Do_SMB ( hS, SMBgetatr, 0, pB, NULL );

  if ( res == OK )
  {
    pAttr->attr  = SMB_RxWords[0];
    pAttr->utime = SMB_RxWords[1] + (SMB_RxWords[2] << 16);
    pAttr->length = SMB_RxWords[3] + (SMB_RxWords[4] << 16);
  }

  return res;
}
#else
/* THIS IS A BODGE!!
   The SMB_GetAtr command in NT4.0 returns rubbish the file time;
     it renders this command basically unusable. We have to get the
     same information out via a directory search command instead.
*/

err_t SMB_GetAttribs ( char *filename, DOS_ATTRIBS *pAttr )
{
  err_t res;
  BUFCHAIN pB, pBres;
  hSHARE hS;

  hS = GetShare (filename, &res);
  if ( hS == NULL )
    return res;

#ifdef LONGNAMES
  if (hS->hServer->t2flags & T2FLAGS_LONGNAMES)
    return SMB_GetAttribsX2 (hS, filename, pAttr );
#endif

  pB = MkDataBlock ( NULL, DATA_VARBLK, NULL, 0, false );
  if ( pB != NULL )
    pB = MkDataString ( pB, DATA_ASCII, filename+2 );

  if ( pB == NULL )
    return EOUTOFMEM;

  SMB_TxWords[0] = 1; /* Count of entries to return */
  SMB_TxWords[1] = ATTR_DIR; /* Return files & directories info */

  res = Do_SMB ( hS, SMBsearch, 2, pB, &pBres );

  if ( res == ENOMOREFILES )
    return EFILENOTFOUND;

  if ( res != OK )
    return res;

  /* Extract all data  */

  FreeChain( GetData ( pBres, SMB_WorkBuf, SMB_RxByteCount ) );

  if ( SMB_RxWords[0] < 1 ) /* No files read */
    return EFILENOTFOUND;

  return Xlt_ExpandSearchEntry ( SMB_WorkBuf+3+SEARCH_ST_SIZE,
               NULL, NULL, pAttr, NULL );

}
#endif

/* --------------------------- */

static err_t SMB_SetDateTimeAttr ( char *filename, DOS_ATTRIBS *pAttr,
                                         int flags )
{
  BUFCHAIN pB;
  hSHARE hS;
  err_t res;

  hS = GetShare (filename, &res);
  if ( hS == NULL )
    return res;

  pB = MkDataString ( NULL, DATA_ASCII, "" );
  if ( pB != NULL )
    pB = MkDataString ( pB, DATA_ASCII, filename+2 );
  if ( pB == NULL )
    return EOUTOFMEM;

  SMB_TxWords[0] = pAttr->attr;
  if ( flags & PROT_SETDATETIME )
  {
    SMB_TxWords[1] = pAttr->utime & 0xFFFF;
    SMB_TxWords[2] = pAttr->utime >> 16;
  }
  else
  {
    SMB_TxWords[1] = 0;
    SMB_TxWords[2] = 0;
  }
  SMB_TxWords[3] = 0;
  SMB_TxWords[4] = 0;
  SMB_TxWords[5] = 0;
  SMB_TxWords[6] = 0;
  SMB_TxWords[7] = 0;

  return Do_SMB ( hS, SMBsetatr, 8, pB, NULL );
}

/* ------------------------------------------ */

err_t SMB_SetAttribs ( char *filename, DOS_ATTRIBS *pAttr )
{
  err_t res;

  /* W4WG / Windows 95 barfs if we try to set a file time with this call */
  /* but they can set other attributes, so we have to retry */

  res = SMB_SetDateTimeAttr ( filename, pAttr, PROT_SETDATETIME );
  if ( res != ENOTPRESENT )
    return res;

  /* 1997.04.21 - try really hard to set file attributes first, then
                  date & time by opening and closing the file */

  res = SMB_SetDateTimeAttr ( filename, pAttr, 0 );
  if ( res != OK )
    return res;

  if ( pAttr->utime != 0 && (pAttr->attr & ATTR_DIR) == 0 )
  {
    int FH, tmp;
    DOS_ATTRIBS da;

    res = SMB_Open ( MODE_RD, filename, &da, &FH, &tmp );
    if ( res == OK )
    {
      da.utime = pAttr->utime;
      SMB_Close( FH, &da );
    }
    /* Swallow errors, as this is a bit of a bodge! */
  }

  return OK;
}

/* --------------------------- */

#ifdef LONGNAMES
static err_t SMB_GetFreeSpaceX2 ( hSHARE hS, struct disk_size_response *pDSR  )
{
  err_t res;
  static struct TransactParms tp;
  BYTE *p;
  DWORD sectors_per_alloc, total_allocs, total_avail_allocs;
  WORD bytes_per_sector;

  Transact_init(&tp, 1 * 2);
  Transact_addsetupword(&tp, TRANSACT2_QUERYFSINFORMATION);
  Transact_addword(&tp, 1);  /* information level */
  res = SMB_Transact2(hS, &tp);
  if (res != OK)
    return res;
  p = tp.data_out_buf + 4;
  sectors_per_alloc = Transact_getlong(p), p += 4;
  total_allocs = Transact_getlong(p), p += 4;
  total_avail_allocs = Transact_getlong(p), p += 4;
  bytes_per_sector = Transact_getword(p);

  pDSR->blksize = bytes_per_sector * sectors_per_alloc;
  pDSR->freeblks =  total_avail_allocs;
  pDSR->totalblks = total_allocs;

  return OK;
}
#endif

err_t SMB_GetFreeSpace ( char lettr, struct disk_size_response *pDSR  )
{
  err_t res;
  hSHARE hS;

  hS = GetShare (&lettr, &res);
  if ( hS == NULL )
    return res;

#ifdef LONGNAMES
  if (hS->hServer->t2flags & T2FLAGS_LONGNAMES)
  {
    return SMB_GetFreeSpaceX2(hS, pDSR);
  }
#endif

  res = Do_SMB ( hS, SMBdskattr, 0, NULL, NULL );

  if ( res == OK )
  {
    pDSR->blksize = SMB_RxWords[1] * SMB_RxWords[2];
    pDSR->freeblks = SMB_RxWords[3];
    pDSR->totalblks = SMB_RxWords[0];
  }

  return res;
}


/* ------------------------------- */

#ifdef LONGNAMES
enum {
  ffirst_FORCE_CLOSE = 1,
  ffirst_CLOSE_IF_DONE = 2, /* Note close_if_done doesn't seem to work (at least on NT 4.0 SP3) */
  ffirst_RETURN_KEYS = 4,
  fnext_CONTINUE = 8, /* This bit allows continuation without the need to use resume keys */
  ffirst_BACKUP_INTENT = 16
};

static err_t SMB_AbandonFind2( hSHARE hS, WORD dir_handle )
{
  debug1("Terminating search op (dir_handle = %x)\n", dir_handle);
  SMB_TxWords[0] = dir_handle;
  return Do_SMB(hS, SMBfindclose2, 1, NULL, NULL);
}

/* Implement directory searching via TRANSACT2/FINDFIRST/FINDNEXT */
static err_t SMB_ReadDirEntriesX2 ( hSHARE hS, char *path, int count,
                                    ENUM_DIR_FN dirfn, void *private,
                                    Transact_SearchContext *con )
{
  err_t res;
  BYTE *p;
  int n_read = 0;
  int eos;
  int i;
  DWORD actual_resume_key;
  const int first_flags = ffirst_RETURN_KEYS;
  const int stuck_flags = ffirst_RETURN_KEYS | fnext_CONTINUE;
  const int next_flags  = ffirst_RETURN_KEYS;
  bool path_changed = false;
  bool taken;
  
  /* Despite having a resume key it may be necessary to restart */
  if ( (path != NULL) && (strcmp( path, con->dir_path ) != 0) )
    path_changed = true;

  if ( path_changed || (con->resume_key == 0) ) {
    /* Path changed due to recursion or new search */
    if (con->dir_handle_valid) {
      debug1("SMB_ReadDirEntriesX2 -> abandon old search of dir handle %x\n", con->dir_handle);
      (void) SMB_AbandonFind2( hS, con->dir_handle );
      con->dir_handle_valid = false;
    }
    strcpy( con->dir_path, path );
    con->resume_key_encountered = (con->resume_key == 0) ? true : false;

    /* For a new search, ensure the request allows for "." and ".." which are
     * always given and would therefore end up oscillating with 0 useful files
     * found and a resume key of 0 again
     */
    count = max( count, 3 );

    /* Initial search - note we accept SIX return parameters - contrary to
     * Microsoft's own document - because it doesn't work if you only pass 5. Grr.
     */
    Transact_init(&con->tp, 6 * 2);                /* will accept 6 WORD return params */
    Transact_addsetupword(&con->tp, TRANSACT2_FINDFIRST);
    if (LM_Vars.namemode & NM_INTERNAL) {          /* findfirst_Attribute */
      Transact_addword(&con->tp, ATTR_DIR | ATTR_SYS | ATTR_HID);
    }
    else {
      Transact_addword(&con->tp, ATTR_DIR);        
    }
    Transact_addword(&con->tp, count);             /* findfirst_SearchCount */
    Transact_addword(&con->tp, first_flags);       /* findfirst_flags */
    Transact_addword(&con->tp, 1);                 /* Search level  */
    Transact_addlong(&con->tp, 0L);                /* reserved, MBZ */
    Transact_addstring(&con->tp, path+2);          /* findfirst_FileName[] */
    res = SMB_Transact2(hS, &con->tp);
    if (res != OK)
      return res;
    p = con->tp.parms_out_buf;
    con->dir_handle = Transact_getword(p); p += 2;
    con->dir_handle_valid = true;
    con->resume_fake = 0;
    con->resume_key_stuck = false;
    con->resume_file_name[0] = 0;
    debug1("SMB_ReadDirEntriesX2 -> new dir handle %x\n", con->dir_handle);
  }
  else {
    /* Continuation */
    Transact_init(&con->tp, 4 * 2);                /* will accept 4 WORD return params */
    Transact_addsetupword(&con->tp, TRANSACT2_FINDNEXT);
    Transact_addword(&con->tp, con->dir_handle);   /* findnext_DirHandle */
    Transact_addword(&con->tp, count);             /* findnext_SearchCount */
    Transact_addword(&con->tp, 1);                 /* Search level  */
    Transact_addlong(&con->tp, con->actual_resume_key);   /* Resume key from previous */
    Transact_addword(&con->tp, next_flags);               /* Jump to place using the resume key */
    Transact_addstring(&con->tp, con->resume_file_name);
    debug1("SMB_ReadDirEntriesX2 -> continue with key %08x\n", con->resume_key);
    res = SMB_Transact2(hS, &con->tp);
    if (res != OK)
      return res;
    p = con->tp.parms_out_buf;
  }
  /* Remainder of response handling is common to both sub-commands */
  n_read = Transact_getword(p); p += 2;
  eos = Transact_getword(p); p += 2;
  if (eos)
    debug0(">> Server said it was the end of the search operation\n");
  p = con->tp.data_out_buf;
  if (n_read == 0)
    return ENOMOREFILES;

  /* At this point, p is pointing to the start of the returned data
   * buffer, n_read contains the number of files known to be in the
   * return buffer, eos is non-zero if the search is completed.
   */
  for (i = 1; i <= n_read; i++) {
    int length;
    DWORD next_resume_key;

    /* Get next resume key */
    next_resume_key = Transact_getlong(p); p += 4;
    length = p[22];
    con->resume_fake++;

    /* Special case . and .. so the duff resume key detection doesn't see them */
    if ( ((p[22] == 1) && (p[23] == '.') && (p[24] == 0)) ||
         ((p[22] == 2) && (p[24] == '.') && (p[25] == 0) && (p[23] == '.')) ) {
      p += 23 + length + 1;
      continue;
    }

    actual_resume_key = next_resume_key;

    /* Workaround for NTFS always returning zero */
    con->resume_key_stuck = (next_resume_key == 0) ? true : false;
    if (con->resume_key_stuck) next_resume_key = con->resume_fake; 

    /* Either consume the name or keep waiting for sync */
    if ( con->resume_key_encountered ) {
      debug1("SMB_ReadDirEntriesX2 -> call back with key %08x\n", next_resume_key);
      res = dirfn(p, 1, &taken, private);

      if (taken) {
        con->resume_key = next_resume_key;
        con->actual_resume_key = actual_resume_key;
        memcpy(con->resume_file_name, p + 23, length + 1);
      }
      else {
        con->resume_fake--;
      }

      if (res != OK) {
        /* Entry expander must have run out of space! */
        debug0("SMB_ReadDirEntriesX2 -> caller ran out of space (or could be name xlate code)\n");
        return EOUTOFMEM;
      }
    }
    else {
      debug2("SMB_ReadDirEntriesX2 -> awaiting key %08x (got %08x)\n", con->resume_key, next_resume_key);
      con->actual_resume_key = actual_resume_key;
      memcpy(con->resume_file_name, p + 23, length + 1);
      if ( next_resume_key == con->resume_key )
        con->resume_key_encountered = true;
    }
    p += 23 + length + 1;
  }

  if (eos)
    debug0(">> Server said it was the end of the search operation\n");

  return eos ? ENOMOREFILES : OK;
}
#endif

err_t SMB_ReadDirEntries ( char *path, int count,
                           ENUM_DIR_FN dirfn, void *private, void *context )
{
  err_t res;
  int i, n_read, eos;
  BYTE *p;
  BUFCHAIN pB, pBres;
  Transact_SearchContext *con;
  bool path_changed = false;
  bool taken;

  /* Don't be silly */
  if (count < 0) return ENOMOREFILES;

  con = (Transact_SearchContext *)context;
  if (con->resume_key == 0) {
    /* Start search */
    con->search_drive = GetShare(path, &res);
    if ( con->search_drive == NULL )
      return res;
  }
  else {
    /* Continue search */
    if ( con->search_drive == NULL )
      return ENOMOREFILES;
  }

#ifdef LONGNAMES
  if ( con->search_drive->hServer->t2flags & T2FLAGS_LONGNAMES ) {
    /* Long names enabled */
    return SMB_ReadDirEntriesX2(con->search_drive, path, count, dirfn, private, con);
  }
#endif

  /* Despite having a resume key it may be necessary to restart */
  if ( (path != NULL) && (strcmp( path, con->dir_path ) != 0) )
    path_changed = true;

  if (con->resume_key == 0) {
    /* New search */
    strcpy( con->dir_path, path );
    con->resume_key_encountered = true;
    con->dir_handle_valid = false;

    /* For a new search, ensure the request allows for "." and ".." which are
     * always given and would therefore end up oscillating with 0 useful files
     * found and a resume key of 0 again
     */
    count = max( count, 3 );
  
    /* Initial search */
    pB = MkDataBlock ( NULL, DATA_VARBLK, NULL, 0, false );
    if ( pB != NULL )
      pB = MkDataString( pB, DATA_ASCII, path+2 );
    debug1("SMB_ReadDirEntries -> new search of %s\n", path);
  }
  else {
    /* Continuation */
    debug1("SMB_ReadDirEntries -> continue with key %08x\n", con->resume_key);

    if (!path_changed && con->dir_handle_valid &&
       ((WORD)con->resume_key == con->dir_handle)) {
      /* Path is the same, search key non zero, state valid */
      debug0("SMB_ReadDirEntries -> hyperspace\n");
      con->resume_key_encountered = true;
      pB = MkDataBlock (NULL, DATA_VARBLK, con->resume_state,
                        SEARCH_ST_SIZE, false);
      if ( pB != NULL)
        pB = MkDataString( pB, DATA_ASCII, "" );
    }
    else {
      /* Emulate the state resumption, slow but infrequent */
      debug0("SMB_ReadDirEntries -> emulation\n");

      con->resume_key_encountered = false;
      pB = MkDataBlock ( NULL, DATA_VARBLK, NULL, 0, false );
      if ( pB != NULL )
        pB = MkDataString( pB, DATA_ASCII, path+2 );

      while (!con->resume_key_encountered) {
        /* Do search */
        if ( pB == NULL )
          return EOUTOFMEM;
        SMB_TxWords[0] = max( count, SEARCH_COUNT );
        SMB_TxWords[1] = ATTR_DIR /* | ATTR_SYS | ATTR_HID */;
        res = Do_SMB( con->search_drive, SMBsearch, 2, pB, &pBres );
        if ( res != OK )
          return res;
        FreeChain( GetData( pBres, SMB_WorkBuf, SMB_RxByteCount ) );
        
        /* Scan for a match */
        n_read = SMB_RxWords[0];
        eos = (n_read < count);
        if (eos)
          debug0(">> Server said it was the end of the search operation\n");
        
        p = SMB_WorkBuf+3;
        /* At this point, p is pointing to the start of the returned data
         * buffer, n_read contains the number of files known to be in the
         * return buffer, eos is non-zero if the search is completed.
         */
        if (n_read == 0)
          return ENOMOREFILES;
        
        for (i = 1; i <= n_read; i++) {
          DWORD next_resume_key;

          /* Prep resumption */
          memcpy( con->resume_state, p, SEARCH_ST_SIZE );

          /* Get next resume key */
          _swix(OS_CRC, _INR(0,3)|_OUT(0), 0, p+30, p+SEARCH_TOT_SIZE, 1, &next_resume_key);
          if (next_resume_key == con->resume_key) {
            strcpy( con->dir_path, path );
            con->resume_key_encountered = true;
            break;
          }

          p += SEARCH_TOT_SIZE;
        }

        /* Again again... */
        pB = MkDataBlock (NULL, DATA_VARBLK, con->resume_state,
                          SEARCH_ST_SIZE, false);
        if ( pB != NULL)
          pB = MkDataString( pB, DATA_ASCII, "" );
      }
    }
  }

  /* Do search */
  if ( pB == NULL )
    return EOUTOFMEM;
  count = min( count, SEARCH_COUNT ); 
  SMB_TxWords[0] = count;
  SMB_TxWords[1] = ATTR_DIR /* | ATTR_SYS | ATTR_HID */;
  res = Do_SMB( con->search_drive, SMBsearch, 2, pB, &pBres );
  if ( res != OK )
    return res;
  FreeChain( GetData( pBres, SMB_WorkBuf, SMB_RxByteCount ) );

  /* Remainder of response handling is common to both sub-commands */
  n_read = SMB_RxWords[0];
  eos = (n_read < count);
  if (eos)
    debug0(">> Server said it was the end of the search operation\n");

  p = SMB_WorkBuf+3;
  /* At this point, p is pointing to the start of the returned data
   * buffer, n_read contains the number of files known to be in the
   * return buffer, eos is non-zero if the search is completed.
   */
  if (n_read == 0)
    return ENOMOREFILES;
  
  for (i = 1; i <= n_read; i++) {
    DWORD next_resume_key;

    /* Get next resume key */
    _swix(OS_CRC, _INR(0,3)|_OUT(0), 0, p+30, p+SEARCH_TOT_SIZE, 1, &next_resume_key);
    p[SEARCH_TOT_SIZE - 1] = 0;

    debug1("SMB_ReadDirEntries -> call back with key %08x\n", next_resume_key);
    res = dirfn(p+SEARCH_ST_SIZE, 0, &taken, private);
    if (taken) {
      con->resume_key = next_resume_key;
      memcpy( con->resume_state, p, SEARCH_ST_SIZE );
      con->dir_handle = (WORD)next_resume_key;
      con->dir_handle_valid = true;
    }
    if (res != OK) {
      /* Entry expander must have run out of space! */
      debug0("SMB_ReadDirEntries -> caller ran out of space (or could be name xlate code)\n");
      return EOUTOFMEM;
    }

    p += SEARCH_TOT_SIZE;
  }

  if (eos)
    debug0(">> Server said it was the end of the search operation\n");

  return eos ? ENOMOREFILES : OK;
}

/* Public file read/write operations ============================= */


err_t SMB_Create ( char *filename, DOS_ATTRIBS *pInAttr,
                   int *pOutFH )
{
  err_t res;
  BUFCHAIN pB;
  hSHARE hS;

  hS = GetShare(filename, &res);
  if ( hS == NULL )
    return res;

  pB = MkDataString ( NULL, DATA_ASCII, filename+2 );
  if ( pB == NULL )
    return EOUTOFMEM;

  SMB_TxWords[0] = (pInAttr->attr) & (ATTR_RO|ATTR_SYS|ATTR_HID);
  SMB_TxWords[1] = (pInAttr->utime) & 0xFFFF;
  SMB_TxWords[2] = (pInAttr->utime) >> 16;

  res = Do_SMB ( hS, SMBcreate, 3, pB, NULL );
  if ( res == OK )
    *pOutFH = MakeFH(hS, SMB_RxWords[0]);

  return res;
}

/* ---------------- */

static int ModeXlate[4] = { MODE_RD, MODE_WR, MODE_RDWR, 0 };

err_t SMB_Open ( int mode, char *filename,
      DOS_ATTRIBS *pOutAttr, int *pOutFH, int *pOutModes )
{
  err_t res;
  BUFCHAIN pB;
  hSHARE hS;

  hS = GetShare(filename, &res);
  if ( hS == NULL )
    return res;

  pB = MkDataString ( NULL, DATA_ASCII, filename+2 );
  if ( pB == NULL )
    return EOUTOFMEM;

  SMB_TxWords[0] = mode;  /* Exclusive access */
  SMB_TxWords[1] = ATTR_RO | ATTR_HID | ATTR_SYS; /* Attribute */

  res = Do_SMB ( hS, SMBopen, 2, pB, NULL );
  if ( res == OK )
  {
    *pOutFH = MakeFH(hS, SMB_RxWords[0]);

    if ( pOutAttr != NULL )
    {
      pOutAttr->attr    = SMB_RxWords[1];
      pOutAttr->utime   = SMB_RxWords[2] + (SMB_RxWords[3] << 16);
      pOutAttr->length  = SMB_RxWords[4] + (SMB_RxWords[5] << 16);
    }

    if ( pOutModes != NULL )
      *pOutModes = ModeXlate[SMB_RxWords[6] & 3];
  }
  return res;
}

/* ---------------- */

err_t SMB_GetLength ( int FH, uint *pOutLen )
{
  err_t res;
  hSHARE hS = GetShareFromFH(FH, &res);
  if ( hS == NULL )
    return res;

  SMB_TxWords[0] = GetFid(FH);
  SMB_TxWords[1] = 2;  /* SEEK from end */
  SMB_TxWords[2] = 0;  /* Offset 0: Relative to end */
  SMB_TxWords[3] = 0;

  res = Do_SMB ( hS, SMBlseek, 4, NULL, NULL );
  if ( res == OK )
  {
    *pOutLen = SMB_RxWords[0] + (SMB_RxWords[1] << 16);
  }

  return res;
}

/* ---------------- */


err_t SMB_Read ( int FH, uint offset, uint len, BYTE *where,
    uint *pOutLen )
{
  uint len_left, n_read;
  int  fid;
  hSHARE hS;
  BUFCHAIN pB_res;
  err_t res = OK;

  len_left = len;
  hS = GetShareFromFH(FH, &res);
  if ( hS == NULL )
    return res;

  fid = GetFid(FH);

  /* Can a raw block read help us ? */

  if ( hS->hServer->ProtFlags & PROT_READRAW )
  {
    while ( len_left > MAX_RX_BLOCK_SIZE )
    {
      n_read = SMB_ReadRaw ( hS, fid, offset, len_left, where );
      if ( n_read == 0 )  /* Didn't work? Find out why */
        break;

      len_left -= n_read;
      where    += n_read;
      offset   += n_read;
    }
  }

  /* Conventional read command */

  while ( len_left > 0 )
  {
    SMB_TxWords[0] = fid;
    SMB_TxWords[1] = min(len_left, MAX_RX_BLOCK_SIZE);
    SMB_TxWords[2] = offset & 0xFFFF;
    SMB_TxWords[3] = (offset >> 16 );
    SMB_TxWords[4] = (len_left);

    res = Do_SMB ( hS, SMBread, 5, NULL, &pB_res );
    if ( res != OK )
      break;

    n_read = SMB_RxWords[0];

    if ( n_read > 0 )
    {
      pB_res = GetData(pB_res, NULL, 3 ); /* Data header */
      pB_res = GetData(pB_res, where, n_read );

      if ( pB_res == NULL )  /* Read failed */
      {
        res = EDATALEN;
        break;
      }

      len_left -= n_read;
      where    += n_read;
      offset   += n_read;
    }

    FreeChain(pB_res);

    if ( n_read < MAX_RX_BLOCK_SIZE )  /* Reached end of file */
      break;
  }

  if ( pOutLen != NULL ) *pOutLen = len-len_left;
  return res;
}

/* ---------------- */

err_t SMB_Truncate ( int FH, uint length )
{
  BUFCHAIN pB;
  err_t res;
  hSHARE hS;

  hS = GetShareFromFH(FH, &res);
  if ( hS == NULL )
    return res;

  /* Do a truncate with a write of length zero */
  SMB_TxWords[0] = GetFid(FH);
  SMB_TxWords[1] = 0 /* Byte count to write */;
  SMB_TxWords[2] = length & 0xFFFF;
  SMB_TxWords[3] = (length >> 16 );
  SMB_TxWords[4] = 0;

  pB = MkDataBlock ( NULL, DATA_BLOCK, NULL, 0, false );
  if ( pB == NULL )
    return EOUTOFMEM;

  return Do_SMB ( hS, SMBwrite, 5, pB, NULL );
}

/* ---------------- */

err_t SMB_Write ( int FH, uint offset, uint len, BYTE *where,
    uint *pOutLen )
{
  BUFCHAIN pB;
  uint len_left, n_written, n_count;
  int  fid;
  hSHARE hS;

  err_t res=OK;

  hS = GetShareFromFH(FH, &res);
  if ( hS == NULL )
    return res;

  fid = GetFid(FH);
  len_left = len;

  /* Can we do it with raw writes? */

  if ( hS->hServer->ProtFlags & PROT_WRITERAW )
  {
    while ( len_left >= WRRAW_BLOCK_SIZE )
    {
      n_written = WRRAW_BLOCK_SIZE;
      res = SMB_WriteRaw ( hS, fid, offset, n_written, where );
      if ( res != OK )
        goto finish;

      len_left -= n_written;
      where    += n_written;
      offset   += n_written;
    }
  }

  while ( len_left > 0 )
  {
    n_count = min(0xFFFF, min(len_left, hS->hServer->maxTxBufferSize));
    SMB_TxWords[0] = fid;
    SMB_TxWords[1] = n_count;
    SMB_TxWords[2] = (WORD)offset;
    SMB_TxWords[3] = (WORD)(offset >> 16);
    SMB_TxWords[4] = min(0xFFFF, len_left); /* Estimate of remainder */

    pB = MkDataBlock ( NULL, DATA_BLOCK, where, n_count, true );
    if ( pB == NULL )
    {
      res = EOUTOFMEM;
      break;
    }

    res = Do_SMB ( hS, SMBwrite, 5, pB, NULL );
    if ( res != OK )
      break;

    n_written = SMB_RxWords[0];
    len_left -= n_written;
    where    += n_written;
    offset   += n_written;

    if ( n_written < n_count )  /* Server has insufficient resources */
      break;
  }

finish:
  if ( pOutLen != NULL ) *pOutLen = len-len_left;
  return res;

}

/* ---------------- */

err_t SMB_Flush ( int FH )
{
  err_t res;
  hSHARE hS;

  hS = GetShareFromFH(FH, &res);
  if ( hS == NULL )
    return res;

  SMB_TxWords[0] = GetFid(FH);
  return Do_SMB ( hS, SMBflush, 1, NULL, NULL );
}

/* ---------------- */

err_t SMB_Close ( int FH, DOS_ATTRIBS *pAttr )
{
  err_t res;
  hSHARE hS;

  hS = GetShareFromFH(FH, &res);
  if ( hS == NULL )
    return res;

  SMB_TxWords[0] = GetFid(FH);
  SMB_TxWords[1] = pAttr->utime & 0xFFFF;
  SMB_TxWords[2] = pAttr->utime >> 16;

  return Do_SMB ( hS, SMBclose, 3, NULL, NULL );
}


/* Printing routines ================================== */

err_t SMB_OpenPrinter ( char drvlettr, char *idstring, int *ph_out )
{
  err_t res;
  BUFCHAIN pB;
  hSHARE hS;

  hS = GetShare(&drvlettr, &res);
  if ( hS == NULL )
    return res;

  pB = MkDataString ( NULL, DATA_ASCII, idstring );
  if ( pB == NULL )
    return EOUTOFMEM;

  SMB_TxWords[0] = 0;  /* Length of printer setup data */
  SMB_TxWords[1] = 1;  /* Graphics mode */

  res = Do_SMB ( hS, SMBsplopen, 2, pB, NULL );

  if ( res == OK )
    *ph_out = MakeFH(hS, SMB_RxWords[0]);

  return res;
}

/* -------------- */

err_t SMB_WritePrinter ( int PH, BYTE *data, int datalen )
{
  BUFCHAIN pB;
  hSHARE hS;
  int len;
  err_t res=OK;

  hS = GetShareFromFH(PH, &res);
  if ( hS == NULL )
    return res;

  while ( datalen > 0 )
  {
    len = ( datalen > PRN_BLOCK_SIZE ) ? PRN_BLOCK_SIZE : datalen;
    SMB_TxWords[0] = GetFid(PH);

    pB = MkDataBlock ( NULL, DATA_BLOCK, data, len, true );
    if ( pB == NULL )
    {
      res = EOUTOFMEM;
      break;
    }

    res = Do_SMB ( hS, SMBsplwr, 1, pB, NULL );
    if ( res != OK )
      break;

    datalen -= len;
    data += len;
  }

  return res;
}

/* ---------------- */

err_t SMB_ClosePrinter ( int PH )
{
  err_t res;
  hSHARE hS;

  hS = GetShareFromFH(PH, &res);
  if ( hS == NULL )
    return res;

  SMB_TxWords[0] = GetFid(PH);
  return Do_SMB ( hS, SMBsplclose, 1, NULL, NULL );
}

/* "Transact" (Remote-procedure-call) operations =========== */

/* For the time being, we limit each transmission to one
   packet's worth (1500 bytes). This might cause Tx failures
   if we exceed it.

   Also, we don't allow any 'setup words' (cos I've never seen them
   used & don't know what they do!).

*/

err_t SMB_Transact ( char drvlettr, char *name, struct TransactParms *pT )
{
  BUFCHAIN pB, pBres;
  err_t res;
  int   a, padbytes;    /* Temp variable */
  hSHARE hS;

  hS = GetShare(&drvlettr, &res);
  if ( hS == NULL )
    return res;

  a = SMBHDR_SIZE + (14*2) + 2 + strlen(name) + 1;
      /* Size of SMB header, 14 word params, 2 byte data length,
            plus the transaction name inc. zero terminator */

  SMB_TxWords[0]  = pT->parms_in_len; /* Total length */
  SMB_TxWords[1]  = pT->data_in_len; /* Total length */
  SMB_TxWords[2]  = pT->parms_out_maxlen;
  SMB_TxWords[3]  = pT->data_out_maxlen;
  SMB_TxWords[4]  = 0; /* Setup words to return */
  SMB_TxWords[5]  = 0; /* Flags - normal */
  SMB_TxWords[6]  = TRANSACT_TIMEOUT; /* Timeout LSW */
  SMB_TxWords[7]  = 0; /* Timeout MSW */
  SMB_TxWords[8]  = 0; /* Reserved */
  SMB_TxWords[9]  = pT->parms_in_len; /* Length this buffer */
  SMB_TxWords[10] = a;  /* Offset from SMB header to parm bytes */
  SMB_TxWords[11] = pT->data_in_len; /* Length this buffer */
  SMB_TxWords[12] = a + pT->parms_in_len;  /* Offset to data bytes */
  SMB_TxWords[13] = 0; /* Setup words being sent */

  pB = NULL;

  /* Make up data chain */

  if ( pT->data_in_len != 0 )
  {
    pB = AddChain ( pB, pT->data_in, pT->data_in_len );
    if ( pB == NULL )
      return EOUTOFMEM;
  }

  if ( pT->parms_in_len != 0 )
  {
    pB = AddChain ( pB, pT->parms_in, pT->parms_in_len );
    if ( pB == NULL )
      return EOUTOFMEM;
  }

  pB = AddChain ( pB, name, strlen(name)+1 );

  res = Do_SMB ( hS, SMBtransact, 14, pB, &pBres );

  if ( res != OK )
    return res;

  /* Now extract results */

  if ( SMB_RxWordCount < 10 )
  {
    FreeChain(pBres);
    return EDATALEN;
  }

  a = SMBHDR_SIZE + (SMB_RxWordCount)*2 + 2;
  /* Size of SMBHDR plus returned rx words plus byte count
     = offset of data in pBres from start of header */

  pT->parms_out_len = min(SMB_RxWords[3], pT->parms_out_maxlen);
                          /* Parm bytes being returned */
  pT->data_out_len  = min(SMB_RxWords[6], pT->data_out_maxlen);
                          /* Data bytes being returned */

  if ( pT->parms_out_len > 0 )         /* Get parms_out */
  {
    padbytes = SMB_RxWords[4] - a;     /* RxWords[4] is offset;
                                          Get number of pad bytes */

    if ( padbytes > 0 )
      pBres = GetData(pBres, NULL, padbytes);
    pBres = GetData(pBres, pT->parms_out_buf, pT->parms_out_len);
    a += padbytes + pT->parms_out_len; /* New offset value */
  }

  if ( pT->data_out_len > 0 )        /* Get parms_out */
  {
    padbytes = SMB_RxWords[7] - a;     /* Number of pad bytes */

    if ( padbytes > 0 )
      pBres = GetData(pBres, NULL, padbytes);
    pBres = GetData(pBres, pT->data_out_buf, pT->data_out_len);
  }

  if ( pBres == NULL )  /* Oh no! Techo fear! */
    return EDATALEN;

  FreeChain(pBres);
  return OK;
}

#ifdef LONGNAMES
/* 14 is the number of words common to all Transact2 commands.  The
 * number of setup words is then added to that value.  The 14 passed
 * to Do_SMB has the number of setup words added to it as this doubles
 * as the header length limiter and the pointer to where to write the
 * total data+param size field (what the Microsoft docs call smb_bcc).
 * This is why you cannot just AddChain the setup word blocks like the
 * data and parameters are handled.
 */
static err_t SMB_Transact2 ( hSHARE hS, struct TransactParms *pT )
{
  BUFCHAIN pB, pBres;
  err_t res;
  int iter = 0; /* Response iteration number */
  int a = SMBHDR_SIZE + ((14 + pT->setup_in_len)*2) + 2;
  int pda = ((a + 3) & ~3);
      /* SMB header size, 14 params + setup words + 2 byte data length
       */
  int   padbytes;    /* Temp variable */
  int   sc;
  int   retry = 3;
  int   tot_data_rcvd = 0, tot_param_rcvd = 0;

retry_transact2:
  debug2("SMB_Transact2: processing (Tid = %#04x, sub-cmd=%#04x)...\n", hS->Tid,
    pT->setup_in[0]);

  SMB_TxWords[0]  = pT->parms_in_len; /* Total length */
  SMB_TxWords[1]  = pT->data_in_len; /* Total length */
  SMB_TxWords[2]  = pT->parms_out_maxlen;
  SMB_TxWords[3]  = pT->data_out_maxlen;
  SMB_TxWords[4]  = 0; /* Setup words to return */
  SMB_TxWords[5]  = 0; /* Flags - normal */
  SMB_TxWords[6]  = TRANSACT2_TIMEOUT; /* Timeout LSW */
  SMB_TxWords[7]  = 0; /* Timeout MSW */
  SMB_TxWords[8]  = 0; /* Reserved */
  SMB_TxWords[9]  = pT->parms_in_len; /* Length this buffer */
  SMB_TxWords[10] = pda;  /* Offset from SMB header to parm bytes */
  SMB_TxWords[11] = pT->data_in_len; /* Length this buffer */
  SMB_TxWords[12] = pda + pT->parms_in_len;  /* Offset to data bytes */
  SMB_TxWords[13] = pT->setup_in_len; /* Setup words being sent */

  debug2("%d bytes of parameters at offset %#x\n", pT->parms_in_len, pda);
  debug2("%d bytes of data at offset %#x\n", pT->data_in_len, SMB_TxWords[12]);

  for (sc = 0; sc < pT->setup_in_len; ++sc)
    SMB_TxWords[14 + sc] = pT->setup_in[sc];

  pB = NULL;

  /* Make up data chain */

  if ( pT->data_in_len != 0 )
  {
    pB = AddChain ( pB, pT->data_in, pT->data_in_len );
    if ( pB == NULL )
      return EOUTOFMEM;
  }

  if ( pT->parms_in_len != 0 )
  {
    pB = AddChain ( pB, pT->parms_in, pT->parms_in_len );
    if ( pB == NULL )
      return EOUTOFMEM;
  }

  /* Add the null string - pda-a must be 1 or 3.  "D " added because
   * that's what SAMBA does (because that's what OS/2 does) */
  pB = AddChain ( pB, "\0D ", pda - a );
  if (pB == NULL )
    return EOUTOFMEM;

  res = Do_SMB ( hS, SMBtrans2, 14 + pT->setup_in_len, pB, &pBres );

  if ( res != OK ) {
    if (SMB_RxHdr.errclass == ERRSRV && SMB_RxHdr.errlo == 1 && SMB_RxHdr.errhi == 0 && retry)
    {
       --retry;
       debug0("SMB_Transact2: retrying request\n");
       goto retry_transact2;
    }
    debug0("SMB_Transact2: Do_SMB failed\n");
    DumpBuffer(&SMB_RxHdr, SMBHDR_SIZE);
    return res;
  }

  /* Now extract results - note that there may be 1 of these.  OTOH, there may be several
   * if the data didn't fit into the negotiated buffer sizes ... */
  for (iter = 0; ; ++iter) {

    if ( SMB_RxWordCount < 10 )
    {
      FreeChain(pBres);
      return EDATALEN;
    }

    a = SMBHDR_SIZE + (SMB_RxWordCount)*2 + 2;
    /* Size of SMBHDR plus returned rx words plus byte count
       = offset of data in pBres from start of header */

    if (iter == 0) {
      /* First response will tell us how much is coming */
      pT->parms_out_len = min(SMB_RxWords[0], pT->parms_out_maxlen);
                              /* Parm bytes being returned */
      pT->data_out_len  = min(SMB_RxWords[1], pT->data_out_maxlen);
                              /* Data bytes being returned */
      pT->setup_out_len = min(SMB_RxWords[9] & 0xFF, pT->setup_out_maxlen);

      /* setup words must come in the first packet */
      if (pT->setup_out_len > 0 )          /* Get setup_out */
      {
        memcpy(pT->setup_out, &SMB_RxWords[14], 2 * pT->setup_out_len);
      }
    }

    if ( pT->parms_out_len > 0 && SMB_RxWords[3])         /* Get parms_out */
    {
      padbytes = SMB_RxWords[4] - a;     /* RxWords[4] is offset;
                                            Get number of pad bytes */

      if ( padbytes > 0 )
        pBres = GetData(pBres, NULL, padbytes);
      pBres = GetData(pBres, pT->parms_out_buf + SMB_RxWords[5], SMB_RxWords[3]);
      a += padbytes + pT->parms_out_len; /* New offset value */
      tot_param_rcvd += SMB_RxWords[3];
    }

    if ( pT->data_out_len > 0 && SMB_RxWords[6] > 0)        /* Get data_out */
    {
      padbytes = SMB_RxWords[7] - a;     /* Number of pad bytes */
      if ( padbytes > 0 )
        pBres = GetData(pBres, NULL, padbytes);
      pBres = GetData(pBres, pT->data_out_buf + SMB_RxWords[8], SMB_RxWords[6]);
      tot_data_rcvd += SMB_RxWords[6];
      if (pT->setup_in[0] == TRANSACT2_QUERYPATHINFORMATION)
        DumpBuffer(pT->data_out_buf, pT->data_out_len);
    }

    if ( pBres == NULL ) {  /* Oh no! Techo fear! */
      debug0("SMB_Transact2: pBres was NULL\n");
      return EDATALEN;
    }

    FreeChain(pBres);

    if (tot_data_rcvd < pT->data_out_len || tot_param_rcvd < pT->parms_out_len) {

      do {
        /* MUST avoid recursive calls to Do_SMBResponse */
        res = Do_SMBResponse(hS, SMBtrans2, &pBres);
      } while (res == OK && SMB_RxHdr.command == SMBchkpth);

      if (res != OK)
        return res;
      /* Extract received data */
      debug1("Transact2 (2ndary response) - returned %d bytes\n", ChainLen(pBres));
    }
    else break;
  }

  return OK;
}
#endif

/* Utility routines ============================================ */

const char *SMB_GetConnInfo ( char drvletter, int infotype )
{
  static char nouser[10];
  static char sharetype[20];
  char   token[8];
  hSHARE hS = GetShareNoConn(drvletter);

  if ( hS == NULL )
    return NULL;

  switch ( infotype )
  {
    case GCI_SERVER:
      return hS->hServer->servname;

    case GCI_USER:
      if ( hS->hServer->ProtFlags & PROT_USERLOGON )
      {
        return hS->hServer->username;
      }
      else
      {
        strncpy(nouser, MsgLookup("NoUser"), sizeof(nouser));
        return nouser;
      }

    case GCI_SHARE:
      return hS->sharename;

    case GCI_LOGONTYPE:
      if ( hS->hServer->ProtFlags & PROT_USERLOGON )
        return "U"; /* User level authentication */
      else
        return "S"; /* Share level authentication */

    case GCI_SHARETYPE:
      sprintf(token, "Type%u", hS->sharetype);
      strncpy(sharetype, MsgLookup(token), sizeof(sharetype));
      return sharetype;

    case GCI_SERVERINFO:
      return NB_DescribeLink( hS->hServer->hSession );
  }

  return "";
}

/* Init routines ================================================ */

bool SMB_Init( void )
{
  int i;

  for ( i=0; i<MAX_SHARES; i++ )
  {
    SMB_Servers[i].flags = FREE;
  }

  for ( i=0; i<MAX_SHARES; i++ )
  {
    SMB_Shares[i].flags = FREE;
    SMB_Shares[i].drvletter = 'A' + i;
    SMB_Shares[i].FH_base = (i << 16);
  }

  SMB_TxHdr.id[0] = 0xFF;
  SMB_TxHdr.id[1] = 'S';
  SMB_TxHdr.id[2] = 'M';
  SMB_TxHdr.id[3] = 'B';

  SMB_TxHdr.mid = 0;  /* Multiplex ID: not used */
  SMB_TxHdr.pid = 1;  /* Process ID: dummy value */
  SMB_TxHdr.tid = 0;  /* Tree ID: set later */
#ifdef LONGNAMES
  SMB_TxHdr.flg2 = SMB_KNOWS_LONG_NAMES; /*| SMB_IS_LONG_NAME;*/
#else
  SMB_TxHdr.flg2 = 0;
#endif
#ifdef LONGNAMES
  NameCache_Init();
#endif
  return true;
}


/* ----------------------------------------- */

/* Shutdown will disconnect all logged-on drives */

err_t SMB_Shutdown ( void )
{
  int i;
  for ( i=0; i < MAX_SHARES; i++ )
    SMB_DeleteShare ( 'A'+i );

  return OK;
}

/* ---------------------------- */

/* SMB_AntiIdle() is used to stop idle-outs on shares.
 * Each call, it moves onto the next share in order to
 * "ping" the server to keep it awake.
 */
void SMB_AntiIdle ( void )
{
  static uint letter = -1;
  hSHARE hS;

  ++letter;
  if (letter >= MAX_SHARES) letter = 0;
  hS = GetShareNoConn('A' + letter);
  if (hS == NULL) {
    return;
  }
  else {
    time_t t;
    (void) time(&t);
    if (t > (hS->hServer->last_xact + 60 * 10)) {
      char echodat[sizeof("A:\\")];
      (void) sprintf(echodat, "%c:\\", 'A' + letter);
      dprintf(("idle_1", "Anti idle-out measure: %s\n", echodat));
      if (ELANMANFSINUSE == SMB_ChkPath(echodat)) {
        dprintf(("idle_1", "Re-entrancy due to idle-out check prevented\n"));
      }
    }
  }
}
@


1.23
log
@Fix for truncating writes to servers that declare MaxBufferSize >= 64k
smb.c, lines 2726 onwards: when chopping up the next buffer, make sure the size sent still fits in the SMB_COM_WRITE count field (16 bits). For completeness, make sure the estimate of bytes remaining is similarly saturated too.
smb.c, lines 2711-2713: cifs-v1-spec-02 section 5.27 says the server always expects to receive up to 65535 bytes, so this test should not be subject to the negotiated MaxBufferSize, and is expected to often exceed it. Currently we use 32k, if this is ever increased we really ought to take into account MaxRawSize that the server tells us.

Tested with a handful of files of power-of-2 sizes and odd sizes. Inspection in Wireshark looks OK. Variation of a diagnosis by Will Ling https://www.riscosopen.org/forum/forums/4/topics/8966

Version 2.59. Tagged as 'LanManFS-2_59'
@
text
@d142 1
a142 1
/* Transact2 (LONGNAMES build only) requires 14 plus setup words
d147 1
a147 1
#define MAX_WCT 14
d448 1
a448 1
static BUFCHAIN MkDataString ( BUFCHAIN pB, int type, char *ptr )
d452 1
a452 1
  pB = AddChain ( pB, ptr, strlen(ptr)+1 );
d823 1
a823 1
static char *dialects[] = {
d833 1
a833 1
static char *SMB_Dialect(unsigned int num)
@


1.22
log
@[419] LanManFS does not see all visible files
Detail:
  When the number of files read from the server didn't fit in the OS_GBPB buffer, continuation of the enumeration would fail.
  Resume key *and* filename used when resuming a directory enumeration to the same directory.
Admin:
  Submission from Colin Granville.

Version 2.56. Tagged as 'LanManFS-2_56'
@
text
@d2691 1
a2691 1
  uint len_left, n_written;
d2708 1
a2708 1
    while ( len_left > hS->hServer->maxTxBufferSize )
d2710 1
a2710 1
      n_written = min(len_left,WRRAW_BLOCK_SIZE);
d2723 1
a2723 1
    n_written = min(len_left, hS->hServer->maxTxBufferSize);
d2725 4
a2728 4
    SMB_TxWords[1] = n_written;
    SMB_TxWords[2] = offset & 0xFFFF;
    SMB_TxWords[3] = (offset >> 16 );
    SMB_TxWords[4] = (len_left);
d2730 1
a2730 1
    pB = MkDataBlock ( NULL, DATA_BLOCK, where, n_written, true );
d2746 1
a2746 1
    if ( n_written < hS->hServer->maxTxBufferSize )  /* End of data */
@


1.21
log
@Add support for NTLM authenticated logins
SMB.c:
Line 875 don't free chain pB that early it is (and was being) used later on.
Fixes to correct which SMB_RxWords the Sesskey and bloblen are retrieved from, for each of the dialects supported.
Call the new auth code when the protocol flags require it.
Don't uppercase passwords all the time, the server may require case sensitivity.
md5c.c/md4c.c:
Verbatim copies of the RSA reference implementations of MD4 and MD5 from the respective RFC's.
Auth.c:
Implementation of the hash/mash/reply that Microsoft requires. Define AUTHTEST of this file to build a simple application that verifies the algorithms.

Tested against a Win7 install, inspecting in Wireshark that the passwords are no longer sent in the clear.
Implements ticket #332.
Submission from Colin Granville.

Version 2.52. Tagged as 'LanManFS-2_52'
@
text
@d2163 1
d2214 1
d2224 3
a2226 9
    Transact_addlong(&con->tp, con->resume_key);   /* Resume key from previous */
    if (con->resume_key_stuck) {
      Transact_addword(&con->tp, stuck_flags);     /* Set continuation bit as NTFS maintains the position */
    }
    else {
      Transact_addword(&con->tp, next_flags);      /* Jump to place using the resume key */
      con->resume_key_encountered = true;
    }
    Transact_addstring(&con->tp, "");              /* no name needed */
d2262 2
d2272 10
a2281 1
      if (taken) con->resume_key = next_resume_key;
d2290 2
@


1.20
log
@Be more efficient with buffers
Take note of, and use, the MaxBufferSize that the server tells us during negotiation rather than a fixed value.
If the server doesn't say, use 1k as the default as before.
Submission from Colin Granville.

Version 2.50. Tagged as 'LanManFS-2_50'
@
text
@d97 1
a861 12
#ifdef DEBUG
  debug1("Data length on negprot is %d\n", ChainLen(pB));
  {
          static char buf[4096];
          void *ptr = SMB_RxWords;
          int len = ChainLen(pB);
          GetData(pB, buf, len);
          DumpBuffer(buf, len);
          DumpStruct(ptr, (SMB_RxWords[0] >= DIALECT_NT) ? dvs_NTnegprot : dvs_negprot);
  }
#endif
  FreeChain(pB);
a867 2
      unsigned char *buf = ((unsigned char *)SMB_RxWords) + 7;

d869 1
a869 1
      hS->hServer->maxTxBufferSize = (buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24));
d885 1
a887 1
      hS->hServer->bloblen = SMB_RxWords[11];
d894 2
a902 1
    hS->hServer->Sesskey = SMB_RxWords[6] | (SMB_RxWords[7] << 16);
d924 1
d941 1
a941 1
  SMB_TxWords[3] = 0;      /* Max pending requests */
d972 43
a1014 11
    SMB_TxWords[7] = strlen ( passwd );
    SMB_TxWords[8] = 0;
    SMB_TxWords[9] = SMB_TxWords[10] = 0; /* Reserved */
    SMB_TxWords[11] = SMB_TxWords[12] = 0; /* client capabilities */
    pB = AddChain(NULL, "CIFS", sizeof("CIFS"));
    if (pB) pB = AddChain(pB, "\0RISCOS", sizeof("\0RISCOS"));
    if (pB) pB = AddChain(pB, userid, strlen(userid) + 1);
    if (pB) pB = AddChain(pB, passwd, strlen(passwd));
    if (pB) pB = DumpChain(pB);
    if (pB == NULL)
      return EOUTOFMEM;
d1622 1
a1622 1
    strcpyn_upper ( hShare->password, password_in, NAME_LIMIT );
d1647 1
a1647 1
    strcpyn_upper ( hServ->password, password_in, NAME_LIMIT );
@


1.19
log
@Fix for null pointer assignment
Can't zero the t2flags having just set hServer to NULL.

Version 2.49. Tagged as 'LanManFS-2_49'
@
text
@d107 5
a111 4
#define FILE_BLOCK_SIZE 1024
#define RDRAW_BLOCK_SIZE 32768
#define WRRAW_BLOCK_SIZE 16384
#define PRN_BLOCK_SIZE  1024
d285 1
d879 2
d882 1
d901 1
d928 1
d951 1
a951 1
  SMB_TxWords[2] = 4096;   /* Our buffer size */
d2575 1
a2575 1
    while ( len_left > FILE_BLOCK_SIZE )
d2592 1
a2592 1
    SMB_TxWords[1] = min(len_left,FILE_BLOCK_SIZE);
d2621 1
a2621 1
    if ( n_read < FILE_BLOCK_SIZE )  /* Reached end of file */
d2678 1
a2678 1
    while ( len_left > FILE_BLOCK_SIZE )
d2693 1
a2693 1
    n_written = min(len_left,FILE_BLOCK_SIZE);
d2716 1
a2716 1
    if ( n_written < FILE_BLOCK_SIZE )  /* End of data */
@


1.18
log
@Internationalised
Unused LMFiler put in the attic.
As LanMan has historically put its resources into ThirdPart/OmniClient this component has no ROM resources phase - it still registers the resources at run time.

Version 2.40. Tagged as 'LanManFS-2_40'
@
text
@d1212 3
a1234 3
#ifdef LONGNAMES
      hS->hServer->t2flags = 0;
#endif
@


1.17
log
@Fix and speed up EXT#handle=number doing nothing when number is beyond 2GB
Internally LanManFS was representing file offsets and data lengths as signed numbers, while in general this doesn't matter (they are passed through opaquely as just numbers and not manipulated) in a couple of places they were being used as while () loop exit conditions.
Function WriteZeroes (used when extending a file via OS_Args) therefore never performed the call to SMB_Write when beyond 2G because the loop condition was never met.
Additionally, it was literally transferring buffers of zeros across the network which is unnecessary as the server is documented as doing a zero fill itself, this represents at least a x40 speed up (on a slow 1MB/s drive write speed at the server end) or more.
Changed offset & lengths from int to uint.
Added the earlier CIFS spec (the later copy is missing section 5 for some reason) to docs.

Version 2.38. Tagged as 'LanManFS-2_38'
@
text
@d85 1
a86 1
#include "stdtypes.h"
d3107 1
a3107 3
static char *sharetype_name[4] = { "Disc", "Printer", "Comms", "IPC" };

char *SMB_GetConnInfo ( char drvletter, int infotype )
d3109 3
d3124 1
d3126 1
d3128 4
a3131 1
        return "(none)";
d3138 1
a3138 1
        return "User";
d3140 1
a3140 1
        return "Share";
d3143 3
a3145 1
      return sharetype_name[ hS->sharetype ];
@


1.16
log
@Fix for *INFO dates not matching *EX dates
These two displays take different code paths, and *INFO goes via a check to workaround a bug in Win98 servers. Unfortunately, the check no longer works because Microsoft don't return the '.' and '..' entries in SMB Trans2 FIND_FIRST, and the logic previously always set the "need to frig the dates" flag. Now, the flag is only set if something comes back and after doing a test swap the results are also correct.
Turned on the 'auto close Trans2 FIND_FIRST' flag in the request block to save having to do a second transaction to close it.
Swapped the LDMFD/STMFD for Push and Pull in the assembler.
Tested against WinXP SP3, dates are no longer bonkers.

Version 2.35. Tagged as 'LanManFS-2_35'
@
text
@a99 17
/* Timeouts * */

/* Reply timeout, in cs */

#ifdef LONGNAMES
#define REPLY_TIMEOUT 4000
#else
#define REPLY_TIMEOUT 1200
#endif

/* Timeout to put in 'Transact' params, in ms */

#define TRANSACT_TIMEOUT 5000
#ifdef LONGNAMES
#define TRANSACT2_TIMEOUT 10000
#endif

d334 1
a334 1
  50, ENOTPRESENT,  /* Return~ed by W4WG from SetAttrib call */
d343 1
a343 1
  112, EDISKFULL,   /* Returned by NT3.5 when disk full */
d728 2
a729 2
static int SMB_ReadRaw ( hSHARE hS,
                     int fid, int offset, int len, BYTE *where )
d785 2
a786 2
static err_t SMB_WriteRaw ( hSHARE hS, int fid, int offset,
                    int len, BYTE *where )
d2524 1
a2524 1
err_t SMB_GetLength ( int FH, int *pOutLen )
d2548 2
a2549 2
err_t SMB_Read ( int FH, int offset, int len, BYTE *where,
    int *pOutLen )
d2551 2
a2552 1
  int len_left, n_read, fid;
d2571 1
a2571 1
      if ( n_read <= 0 )  /* Didn't work? Find out why */
d2624 1
a2624 1
err_t SMB_Truncate ( int FH, int length )
d2650 2
a2651 2
err_t SMB_Write ( int FH, int offset, int len, BYTE *where,
    int *pOutLen )
d2654 2
a2655 1
  int len_left, n_written, fid;
@


1.15
log
@Fix for renames where only the case has changed.
Detail:
 Added an extra check after the Xlate path resolution code so that
 the case of the path given to resolve is honoured. This now means that
 the strcmp() done in SMB_Rename fails and the rename is actually sent to
 the server. Before "*rename test Test" would have the path resolved and
 since 'test' already existed both names would be the same, in this example
 something like "*rename A:\test A:\test" would result.
Admin:
 Made the non LONGNAMES version compile again (not tested).
 Removed local definitions of FSControl reason codes, uses Interface header
 now.
 Made the case of #includes match CVS to allow future compilation on a case
 sensitive system.
 Deleted unused "Version" header.

Version 2.34. Tagged as 'LanManFS-2_34'
@
text
@d1807 2
a1808 1
  if (!(hS->hServer->t2flags & T2FLAGS_TESTEDSWAP)) {
d1810 1
a1810 1
    char fnbuffer[8];
d1812 2
d1820 2
a1821 1
    if (SMB_GetAttribsX2 ( hS, fnbuffer, &aattrbuf ) == OK) {
a1822 1
      fnbuffer[4] = '\0';
d1825 3
a1827 2
      if (LM_Vars.namemode & NM_INTERNAL) {
        Transact_addword(&tp, ATTR_DIR | ATTR_SYS | ATTR_HID);     /* findfirst_Attribute */
d1829 3
a1831 2
      else {
        Transact_addword(&tp, ATTR_DIR);     /* findfirst_Attribute */
d1833 3
a1835 3
      Transact_addword(&tp, 1);            /* findfirst_SearchCount */
      Transact_addword(&tp, 0);            /* findfirst_flags */
      Transact_addword(&tp, 1);            /* Search level  */
d1840 2
a1841 1
      if (res == OK) {
d1844 2
a1845 2
        if (Transact_getword(tp.parms_out_buf + 2) == 1) {
          DOS_ATTRIBS sattrbuf;
d1848 6
a1853 5
          if (res == OK) {
            if (sattrbuf.utime != aattrbuf.utime) {
               debug0("Need to swap date/time!\n");
               hS->hServer->t2flags |= T2FLAGS_SWAPDATETIME;
               swap_time_date(tp.data_out_buf);
d1857 3
a1859 2
               if (sattrbuf.utime != aattrbuf.utime) {
                 debug0("Didnt get the right thing anyway\n");
d1861 3
a1863 1
               else {
d1867 2
a1868 1
            else {
a1872 1
      	(void) Do_SMB(hS, SMBfindclose2, 1, NULL, NULL);
d1874 2
a1875 1
      else {
d1895 2
a1896 1
  if (hS->hServer->t2flags & T2FLAGS_SWAPDATETIME) {
@


1.14
log
@Workaround for NTFS returning resume keys of zero.
Detail:
  When the underlying FS is NTFS, eg. WinXP Pro, the requested
  resume keys for a directory search are always zero - this is passed
  back via OSGBPB and on the next call it triggers a new search. So
  we get stuck in an infinite loop.
  Now checks for a resume key stuck at zero, and makes a fake one static
  to the search context then sets the continuation bit in the SMB_FIND_NEXT
  call because the server returning the duff key remembers the position.
  Dir_CallbackFn could return with "taken" undefined. Move a few lines
  higher.
  Missing "#else" added to CHECK_ARMBOOT_EXISTS so if this is disabled
  no further attempt is made to find !ArmBoot.
  Couple of typos corrected.
  Spelling of "disk" changed to "disc" in an error message.
Admin:
  Tested with XP Pro SP3 with NTFS, directories which previously hung
  the filer now open correctly. Checked with XP Home SP3 with FAT32 to
  verify behaviour unchanged from 2.32.
  Note, with large directories the initial path translation triggers a
  dir search too which takes ages compared with the actual number of
  entries returned. This could be cached to make counting far faster.

Version 2.33. Tagged as 'LanManFS-2_33'
@
text
@d85 1
d87 4
a90 3
#include "buflib.h"
#include "netbios.h"
#include "smb.h"
a91 1
#include "Transact.h" /* for transaction structure building helpers */
d94 3
a96 4
#include "lmvars.h"
#include "attr.h"   /* For InvalidateDrive */
#include "xlate.h"  /* For string functions */

d876 1
a876 1
  #ifdef DEBUG
d886 1
a886 1
  #endif
d1406 4
a1409 3
/* SMB_IsLongNameFS() returns true if the path refers to a share which is using long
    filenames.  Xlate.c needs to know this in order to determine which set of file
    mappings is to be used.
d1419 1
a1419 1

d1676 1
a1676 1
  hSHARE  hShare;
d1679 2
a1680 2
  hShare = GetShareNoConn(drvlettr);
  if ( hShare == NULL )
d1683 1
a1683 1
  hSrv = hShare->hServer;
d1687 2
a1688 2
  DisconnectShare(hShare);
  FreeShare(hShare);
@


1.13
log
@  Multiple fixes.
Detail:
  Too many to list here: see doc/RPSChanges.
Admin:
  Received from Rob Sprowson approx 2009-02-08. Builds, but not tested by ROOL.

Version 2.32. Tagged as 'LanManFS-2_32'
@
text
@a2113 6

/* Note.
 *
 * Requesting close_if_done doesn't seem to work (at least on NT 4.0 SP3)
 *
 */
d2116 1
a2116 1
  ffirst_CLOSE_IF_DONE = 2,
a2138 1
  int flags;
d2140 1
d2168 1
a2168 2
    flags = first_flags;
    Transact_init(&con->tp, 6 * 2);           /* will accept 6 WORD return params */
d2170 2
a2171 2
    if (LM_Vars.namemode & NM_INTERNAL) {
      Transact_addword(&con->tp, ATTR_DIR | ATTR_SYS | ATTR_HID);     /* findfirst_Attribute */
d2174 1
a2174 1
      Transact_addword(&con->tp, ATTR_DIR);   /* findfirst_Attribute */
d2176 5
a2180 5
    Transact_addword(&con->tp, count);        /* findfirst_SearchCount */
    Transact_addword(&con->tp, first_flags);  /* findfirst_flags */
    Transact_addword(&con->tp, 1);            /* Search level  */
    Transact_addlong(&con->tp, 0L);           /* reserved, MBZ */
    Transact_addstring(&con->tp, path+2);     /* findfirst_FileName[] */
d2187 2
a2192 2
    con->resume_key_encountered = true;
    flags = next_flags;
d2199 7
a2205 1
    Transact_addword(&con->tp, next_flags);        /* findnext_flags */
d2218 3
a2221 1
  p = con->tp.data_out_buf;
a2225 3
  if (n_read == 0)
    return ENOMOREFILES;

d2233 12
d2246 1
@


1.12
log
@  Compatibility change for Microsoft security fix MS09-001.
Detail:
  Security fix MS09-001 (detailed in Microsoft Knowledge base article KB958687)
  fixes some vulnerabilities in the SMB protocol which LanManFS uses. This
  highlighted an error in SMB_WriteRaw which reported zero data bytes but then
  supplied an offset to the non existant bytes: this is now faulted by Windows.
  As there are no data bytes, the offset should also be zero.
Admin:
  Fix received from Rob Sprowson 2009-01-19.

Version 2.31. Tagged as 'LanManFS-2_31'
@
text
@d23 1
a23 1
*  22-09-95	 Tracks Uids & session keys. Uses "DOS LM1.2X002"
d26 1
a26 1
*  21-04-97	 SMB_SetAttribs sets time/date using Open/Close on Windows95
d81 1
d102 1
a102 1
/* Reply timeout (12s) */
d342 1
a342 2
BYTE   SMB_WorkBuf[SMBWORKBUF_SIZE];

d728 5
a732 5
     err_t res;
     ++threaded;
     res = Do_SMB_threadsafe(hS, cmd, wct_in, pB_in, ppB_out);
     --threaded;
     return res;
d1821 6
a1826 6
    if (LM_Vars.namemode & 4) {
      Transact_addword(&tp, ATTR_DIR | ATTR_SYS | ATTR_HID);     /* findfirst_Attribute */
    }
    else {
      Transact_addword(&tp, ATTR_DIR);     /* findfirst_Attribute */
    }
a2077 7
  /*
  debug2("S/A %10d %#08x\n", sectors_per_alloc, sectors_per_alloc);
  debug2("T A %10d %#08x\n", total_allocs, total_allocs);
  debug2("TAA %10d %#08x\n", total_avail_allocs, total_avail_allocs);
  debug2("B?S %10d %#08x\n", (DWORD) bytes_per_sector, (DWORD) bytes_per_sector);
  */

d2121 5
a2125 4
        ffirst_FORCE_CLOSE = 1,
        ffirst_CLOSE_IF_DONE = 2,
        ffirst_RETURN_KEYS = 4,
        fnext_CONTINUE = 8
a2127 4
#ifdef DEBUGLIB
static int SIDS=0;
#endif

d2130 3
a2132 4
        dprintf(("SID", "Terminating search op (dir_handle = 0x%04x) (%d open)\n",
        	dir_handle, --SIDS));
        SMB_TxWords[0] = dir_handle;
        return Do_SMB(hS, SMBfindclose2, 1, NULL, NULL);
d2135 1
d2137 2
a2138 2
                               ENUM_DIR_FN dirfn, void *private,
                               struct Transact2_SearchContext *con )
a2139 1
  char *ptr_last_filename;
a2143 1
  int lastname;
a2144 2
  const int first_flags = /*ffirst_CLOSE_IF_DONE |*/ ffirst_RETURN_KEYS;
  const int next_flags  = /*ffirst_CLOSE_IF_DONE |*/ ffirst_RETURN_KEYS;// | fnext_CONTINUE;
d2146 8
d2155 9
a2163 11
  if (path != NULL && con->t1.NextSearchOK == true || count < 0) {
     /* We need to abandon the current search attached to dir_handle.
      * Ignore errors.
      */
     debug3("SMB_ReadDirEntriesX2 -> path (%p) NextSearchOK (%d) count (%d)\n",
       path, con->t1.NextSearchOK, count);
     if (con->dir_handle_valid) {
       (void) SMB_AbandonFind2( hS, con->dir_handle );
       con->dir_handle_valid = false;
     }
  }
d2165 5
a2169 2
  con->t1. NextSearchOK = false;
  if (count < 0) return ENOMOREFILES;
a2170 4
  //count = min (count, 10);

  /* Implement directory searching via TRANSACT2/FINDFIRST/FINDNEXT */
  if (path != NULL) {
a2173 5
    if (con->dir_handle_valid) {
      SMB_AbandonFind2( hS, con->dir_handle);
      con->dir_handle_valid = false;
    }
    con->resume_key = 0;
d2177 1
a2177 1
    if (LM_Vars.namemode & 4) {
d2194 1
a2194 1
    dprintf(("SID", "SID = 0x%04hx (%d open)\n", con->dir_handle, ++SIDS));
d2197 2
a2198 1
    /* continuation */
d2200 1
a2200 1
    Transact_init(&con->tp, 4 * 2);           /* will accept 4 WORD return params */
d2203 2
a2204 2
    Transact_addword(&con->tp, count);        /* findnext_SearchCount */
    Transact_addword(&con->tp, 1);            /* Search level  */
d2206 3
a2208 2
    Transact_addword(&con->tp, next_flags);   /* findnext_flags */
    Transact_addstring(&con->tp, con->last_filename); /* resumption filename */
d2217 2
a2218 12
  p += 2; /* skip error offset */
  lastname = Transact_getword(p);
  if (lastname == 0) {
    ptr_last_filename = NULL;
  }
  else {
    ptr_last_filename = (char *) con->tp.data_out_buf + lastname;
  }

  if (eos) {
          debug0(">> Server said it was the end of the search operation\n");
  }
d2228 1
a2228 1
  for (i=1; i <= n_read; ++i) {
d2231 3
a2233 3
    if (flags & ffirst_RETURN_KEYS) {
            next_resume_key = Transact_getlong(p); p += 4;
    }
d2235 10
a2244 24
    //debug2("ding - got one (length = %d) `%s'\n", length, p+23);
    //DumpBuffer(p, 2 + 2 + 2 + 2 +2 +2 + 4 + 4 +2 + 1 + length);
    res = dirfn(p, 1, private);
    if (res != OK) {
      /* Entry expander must have run out of space!  Remember where the
       * search was at, and try to rewind it a bit by using the resume
       * key and the last_filename
       */
      /* If the search said this was the end of the search though, it will
       * have already terminated the search, so NextSearchOK becomes false
       * and it will have to restart the search next time around.
       */
       //NextSearchOK = eos ? false : true;
       debug0("Bugger.  Looks like client ran out of space (or could be name xlate code)\n");
       if (eos) {
         (void) SMB_AbandonFind2( hS, con->dir_handle );
         con->dir_handle_valid = false;
       }
       else {
         int j;
         con->t1.NextSearchOK = true;
         for (j=i; j<n_read; ++j) dirfn(p, 1, private);
       }
       return EOUTOFMEM;
d2247 3
a2249 4
       con->resume_key = next_resume_key;
       ptr_last_filename = (char *) p + 23;
       (void) strncpy(con->last_filename, ptr_last_filename?ptr_last_filename:"",
         sizeof(con->last_filename));
a2251 10
    if ( i == count )  /* By implication, if n_read >= count */
    {
      debug3("i = %3d; count = %3d; n_read = %3d\n", i, count, n_read);
      debug0("OK - there are more to come later; ");
      if (flags & ffirst_RETURN_KEYS) {
        debug1("Resume key is 0x%08x; ", con->resume_key);
      }
      debug1("Next filename is `%s'\n", con->last_filename);
      con->t1.NextSearchOK = true;
    }
d2254 2
a2255 4
  if (eos) {
          debug0(">> Server said it was the end of the search operation\n");
          con->t1.NextSearchOK = false;
  }
d2257 1
a2257 1
  return con->t1.NextSearchOK ? OK : ENOMOREFILES;
d2262 1
a2262 1
                               ENUM_DIR_FN dirfn, void *private, Transact_SearchContext *conp )
d2265 2
a2266 2
  int i, n_read;
  BYTE *entry;
d2268 3
a2270 2
  static Transact_SearchContext rde_context;
  struct Transact1_SearchContext *con;
d2272 2
a2273 2
  con = (conp == NULL) ? &rde_context.t1 : &conp->t1;
  /* Start or continue search? */
d2275 5
a2279 4
  if ( path != NULL ) /* Start search */
  {
    con->SearchDrive = GetShare(path, &res);
    if ( con->SearchDrive == NULL )
d2282 3
a2284 3
  else
  {
    if ( !con->NextSearchOK || con->SearchDrive == NULL )
d2289 3
a2291 4
  if (con->SearchDrive->hServer->t2flags & T2FLAGS_LONGNAMES)
  {
     struct Transact2_SearchContext *const t2sc = (conp == NULL) ? &rde_context.t2 : &conp->t2;
     return SMB_ReadDirEntriesX2(con->SearchDrive, path, count, dirfn, private, t2sc);
d2295 3
a2297 1
  /* Check 'count' */
d2299 5
a2303 2
  if ( count <= 0 )
    return ENOMOREFILES;
d2305 7
a2311 4
  count = min ( count, SEARCH_COUNT ); /* Don't do more than is convenient */

  if ( path != NULL ) /* Starting search */
  {
d2315 1
d2317 72
a2388 6
  else                /* Continue search */
  {
    pB = MkDataBlock (NULL, DATA_VARBLK, con->SearchState,
                                      SEARCH_ST_SIZE, false);
    if ( pB != NULL)
      pB = MkDataString( pB, DATA_ASCII, "" );
d2391 1
d2394 1
a2394 3

  /* Do search */

d2397 1
a2397 4
  con->NextSearchOK = false;

  res = Do_SMB ( con->SearchDrive, SMBsearch, 2, pB, &pBres );

d2400 1
d2402 5
a2406 1
  /* Extract all data  */
d2408 10
a2417 1
  FreeChain( GetData ( pBres, SMB_WorkBuf, SMB_RxByteCount ) );
d2419 17
a2435 3
  /* Process it */
  n_read = SMB_RxWords[0];
  entry = SMB_WorkBuf+3;
d2437 1
a2437 10
  for ( i=1; i<=n_read; i++ )
  {
    entry[42] = 0;
    dirfn ( entry+SEARCH_ST_SIZE, 0, private );
    if ( i == count )  /* By implication, if n_read >= count */
    {
      con->NextSearchOK = true;
      memcpy ( con->SearchState, entry, SEARCH_ST_SIZE );
    }
    entry += SEARCH_TOT_SIZE;
d2440 4
a2443 2
  /* Return OK, or 'no more' */
  return con->NextSearchOK ? OK : ENOMOREFILES;
d3098 1
a3098 1
static char *sharetype_name[4] = { "Disk", "Printer", "Comms", "IPC" };
a3136 7
/* --------------------------- */

bool SMB_ConnectedTo ( char *server )
{
  return (bool)( FindServer ( server ) != NULL );
}

@


1.11
log
@Fixed uninitialised variable bug that revealed itself with cc 5.55.

Version 2.30. Tagged as 'LanManFS-2_30'
@
text
@d819 1
a819 1
  SMB_TxWords[11] = 0x3C; /* Offset to immediate data bytes */
@


1.10
log
@Directory rename fixed - the mask being passed by the rename routine didn't
have the ATTR_DIR bit set.Discovered this after reading lots of the spec
which is also now included here in /doc.
Copying files out of LanManFS filer "forgot" their filetype even though
they appeared right in the filer,fixed.
A stray debugging printf removed,along with one compiler warning.
New sprites (yuck) to match !Omni.
Reordered the shutdown in two places,first Omni_Shutdown bins the mounts
lists which SMB_Shutdown uses.Second in NetBEUI mode the announcement that
a protocol has terminated goes *after* the shutdown - otherwise you sit
around for about 20s wondering where the link has gone.

Version 2.25. Tagged as 'LanManFS-2_25'
@
text
@d997 1
a997 1
    pB = AddChain(pB, "CIFS", sizeof("CIFS"));
@


1.9
log
@  Fixed bug in parsing of the protocol negotiation.
Detail:
  The wrong bit was being checked to see if we were using the extended
    security model (CAP_EXTENDED_SECURITY).  Thus the wrong format was
    being used in SMBsesssetup, which meant that we couldn't connect
    to Windows 2000.
  Much better debugging added to the name resolution code - this helped
    diagnose the faulty photocopier problem and is left in case anything
    like that happens again!
Admin:
  Tested - I can now connect to Win 2000 shares.

Version 2.17. Tagged as 'LanManFS-2_17'
@
text
@d1768 1
a1768 1
  SMB_TxWords[0] = ATTR_NORM;
@


1.8
log
@  Fixed machine stiff if connection left idle too long.
Detail:
  SVC stack overflow occurred due to the recursive method used to
    discard the idle-out prevention responses.  This no longer
    happens.
  Fixed a bit of debugging which caused data aborts!
  Optimised a select() call to pass s + 1 as the first parameter to
    save Internet time in processing the fd_set.
Admin:
  Tested on desktop build, with the idle timers set to send idle outs
    every second (so we don't have to wait 100 hours for the problem
    to occur).  No longer get problems with the machine stiffing.


Version 2.12. Tagged as 'LanManFS-2_12'
@
text
@d899 1
a899 1
      if (SMB_RxWords[10] & 0x80) {
d984 3
a986 1
    pB = AddChain ( NULL, hS->hServer->blob, hS->hServer->bloblen );
@


1.7
log
@  Fixed use of uninitialised pointer.
  Now doesn't require that the !ArmBoot object is a directory
Detail:
  The code in Omni.c was carefully checking that !ARMBOOT existed
    before attempting to run the boot file.  Unfortunately, it was
    using a method which bypassed the filename resolution (that does
    the ,xxx filetype name mapping), so it did not find the new Obey
    file in the 400 series baseline.  The check has been removed.
  The code in SMB.c was being caught out on an uninitialised variable
    usage when the attribute cache already held details of the object
    being sought.  The variable would have been initialised on a non-
    cached lookup, but the special case of booting a machine via LanManFS
    manages to get a cached lookup without having run through the routine
    before, resulting in a strcpy() with a destination of 0.
Admin:
  Tested on Risc PC.
  Fixes fault 1511 (STB-400 Generic)

Version 2.11. Tagged as 'LanManFS-2_11'
@
text
@d478 1
a478 37
#ifdef DEBUG
static void DumpBuffer(void *ptr, int len)
{
        static char DumpBuf[256];
        const char *membuf = ptr;
        char *db;
        int i,j;
        db = DumpBuf;
        *db = 0;
        for (i=0; i<((len+31)&~31); ++i) {
                if (!(i & 31)) {
                        db += sprintf(db, "  ");
                        if (i) for (j = i - 32; j != i; ++j) {
                                db += sprintf(db, "%c", (membuf[j]>=32 && membuf[j] != 0x7f) ?
                                membuf[j] : '.');
                        }
                        dprintf(("BufferDump", "%s\n", DumpBuf));
                        db = DumpBuf;
                        db += sprintf(db, "%04x: ", i);
                }
                if (i>=len) {
                        db += sprintf(db, "  ");
                        if ((i & 1)) db += sprintf(db, " ");
                }
                else {
                        db += sprintf(db, "%02x", membuf[i]);
                        if ((i & 1)) db += sprintf(db, " ");
                }
        }
        if (i) for (db += sprintf(db, "  "), j = i - 32; j != i; ++j) db += sprintf(db, "%c",
            j>=len ? ' ' : (membuf[j]>=32 && membuf[j] != 0x7f) ?
            membuf[j] : '.');
	dprintf(("BufferDump", "%s\n", DumpBuf));
}
#else
#define DumpBuffer(ptr, len) ((void)0)
#endif
d604 1
a604 4
  debug2("Do_SMB (cmd=0x%x) - NB_GetData returned %d bytes\n", cmd, ChainLen(pB_rx));
#ifdef DEBUG
  if (cmd == SMBwriteBraw) pB_rx = DumpChain(pB_rx);
#endif
a612 7
  if (SMB_RxHdr.command == SMBchkpth) {
    /* Discard the 'ping' response */
    debug0("This response was actually to the previous chkpth call\n");
    FreeChain(pB_rx);
    return Do_SMBResponse(hS, cmd, ppB_out);
  }

d617 1
a617 1
    debug1("Do_SMB: errclass was %d\n", SMB_RxHdr.errclass);
d644 6
d711 6
a716 1
  return Do_SMBResponse(hS, cmd, ppB_out);
a999 1
// FreeChain(pB); return EOUTOFMEM;
d3032 6
a3037 1
      res = Do_SMBResponse(hS, SMBtrans2, &pBres);
d3172 1
a3172 2
      debug1("Anti idle-out measure: %s\n", echodat);
#ifdef TRACE
d3174 1
a3174 1
        debug0("Re-entrancy due to idle-out check prevented\n");
a3175 3
#else
      (void) SMB_ChkPath(echodat);
#endif
@


1.6
log
@  More tolerance has been added of files found on the remote server
    which have unexpected extensions.
Detail:
  LanManFS does not like it if you create (independently, using a PC or
    otherwise) files with names like "myfile,fff" which you intend to
    be displayed as files with type &FFF (ie. Text) on a RISC OS machine.
    If you tried to access the file for reading it, such as loading it
    into an editor, that worked due to the name matching resolution.
    However, any attempt to update the file caused LanManFS to attempt
    to write the file without the extension and not notice that a file
    with a ,fff extension already existed (Text files are special cased
    in the current implementation of name translation - see LanManFS
    Functional Specification for details and rationale).  Attempts to
    save typically succeed (giving you two files: myfile and myfile,fff)
    but generate "Operation not permitted" or such like.  This stemmed
    from the attempt being made by LanManFS to rename a file to the same
    name.  SMB_Rename now traps that and tells its caller that the rename
    succeeded.  The Xlate.c code now indicates correctly that the filename
    extension has been altered when a ,fff extension has to be chopped off.
Admin:
  Tested briefly on desktop build against art-work's SAMBA server.
  Bug reported by TopCat engineers.

Version 2.10. Tagged as 'LanManFS-2_10'
@
text
@d1831 1
d1834 1
@


1.5
log
@  Now uses DebugLib.
  Fixed search handle haemorrhaging.
Detail:
  The directory lookup routines cached directory search handles to avoid
    hammering the server with repeated requests to open directories.
    Unfortunately, it was possible for these to be forgotten without
    being freed up leading to resource loss at the server end.  Eventually,
    the server gives up servicing you and reports errors.  This will only
    occur once a significant number of accesses have been performed (the
    number depends entirely on server configuration).  This leak is now
    fixed.
Admin:
  Tested against Cerium - debug reports that no handles are being leaked.

Version 2.07. Tagged as 'LanManFS-2_07'
@
text
@d1788 4
@


1.4
log
@  Changed idle-out strategy.
  Introduced new error message for re-entrancy prevention trap to use.
Detail:
  When 'pinging' an SMB server, LanManFS does not wait for any response
    but the response reading routine knows to just throw away any old
    SMBchkpth responses that it gets and try reading again.
  Re-entrancy trap now has its own error "LanManFS in use" &1663E, which
    means you no longer see "!Armboot files nested too deeply" which is
    confusing.  The only way you can provoke this message is if you use
    Alt-Break whilst the NetBIOS/IP code is executing.  The error plays
    the same part as "FileCore in use" does for FileCore.
Admin:
  Verified module still works and the anti idle-out features still work.

Version 2.04. Tagged as 'LanManFS-2_04'
@
text
@d481 1
d483 1
d485 2
d489 1
a489 1
                        printf("  ");
d491 1
a491 1
                                printf("%c", (membuf[j]>=32 && membuf[j] != 0x7f) ?
d494 3
a496 1
                        printf("\n%04x: ", i);
d499 2
a500 2
                        printf("  ");
                        if ((i & 1)) printf(" ");
d503 2
a504 2
                        printf("%02x", membuf[i]);
                        if ((i & 1)) printf(" ");
d507 1
a507 1
        if (i) for (printf("  "), j = i - 32; j != i; ++j) printf("%c",
d510 1
a510 1
	printf("\n");
d583 1
a583 1
	printf("%6s %s: %#lx (%ld)\n", sizestr[sz], name, value, value);
d642 1
a642 1
  if (cmd == SMBsesssetup) pB_rx = DumpChain(pB_rx);
d2162 4
d2168 2
a2169 1
        debug1("Terminating search op (dir_handle = 0x%04x)\n", dir_handle);
d2195 4
a2198 1
     (void) SMB_AbandonFind2( hS, con->dir_handle );
d2211 4
d2235 2
a2236 1
    debug1("SID = 0x%04hx\n", con->dir_handle);
d2301 1
@


1.3
log
@  Protocol negotiated features need to be per-server, not per-share.
Detail:
  Long filename flag tarnsferred to be a server property rather than
    a share property, otherwise subsequent shares to the same server
    do not get long filenames (because the subsequent shares don't
    have to go through the connection negotiation phase)
Admin:
  Tested on by mounting lots of drives through desktop Omni frontend.

Version 2.02. Tagged as 'LanManFS-2_02'
@
text
@d79 1
a236 1

d281 1
a609 5
#ifdef LONGNAMES
//#define RETRYONERROR
//#define PINGFIRST
#endif

d622 6
d629 1
a629 1
  res = NB_GetData ( hS->hServer->hSession, &pB_rx, cmd == SMBchkpth ? 400 : REPLY_TIMEOUT );
d646 7
a658 6
#ifdef RETRYONERROR
    if (SMB_RxHdr.errclass == ERRSRV && SMB_RxHdr.errlo == 1 && SMB_RxHdr.errhi == 0 && retry) {
      --retry;
      goto do_smb_retry;
    }
#endif
a695 10
#ifdef RETRYONERROR
  static const int xmit_size = SMBWORKBUF_SIZE + SMBHDR_SIZE + MAX_WCT * 2;
  static BYTE SMB_XmitMemory[SMBWORKBUF_SIZE + SMBHDR_SIZE + MAX_WCT * 2];
  int len, retry;
#endif
#ifdef PINGFIRST
  BUFCHAIN ping_in;
  BUFCHAIN pB_rx;
  static SMBHDR ping_hdr;
#endif
d699 2
a733 31
#ifdef RETRYONERROR
  len = ChainLen(pB_in);
  GetData ( pB_in, SMB_XmitMemory, xmit_size );
  retry = 1; /* number of retries to attempt */
do_smb_retry:
  pB_in = AddChain ( NULL, SMB_XmitMemory, len );
  if ( pB_in == NULL )
  return EOUTOFMEM;
#endif

#ifdef PINGFIRST
  NB_ClearRxQueue ( hSess );
  ping_hdr = SMB_TxHdr;
  ping_hdr.command = SMBecho;
  ping_hdr.wct = 1;
  ping_hdr.tid = 0;
  ping_hdr.mid = 2;
  ping_in = AddChain ( NULL, "\x01\x00\x02\x00\xA8\x00", 6 );
  if (ping_in) ping_in = AddChain( ping_in , &ping_hdr, SMBHDR_SIZE );
  if (ping_in) {
    res = NB_SendData ( hSess, ping_in );
    if ( res != OK )
      return res;
    res = NB_GetData ( hSess, &pB_rx, REPLY_TIMEOUT );
    if (res != OK)
      return res;
    GetData ( pB_rx, NULL, SMBHDR_SIZE + 6 );
    FreeChain ( pB_rx );
  }
#endif

d754 1
a754 1
    return EBOOTREENTRY;
d1730 1
a1730 1
err_t SMB_ChkPath ( char *path )
d3172 14
a3185 4
    char echodat[4];
    sprintf(echodat, "%c:\\", 'A' + letter);
    debug1("Anti idle-out measure: %s\n", echodat);
    (void) SMB_ChkPath(echodat);
a3187 1

@


1.2
log
@  Support for long filename.
  Support for spaces in machine names.
  Merge of sbrodie_LanManFS_dev branch to trunk.
Detail:
  LanManFS 2.00 supports the "NT LM 0.12" protocol, enabling it to
    use long filenames on mounted shares.
Admin:
  Supporting documentation:
    1215,256/FS: LanManFS Software Functional Specification.
  Same as LanManFS-1_87_1_1_1_1_2_13.

Version 2.00. Tagged as 'LanManFS-2_00'
@
text
@d291 1
a314 3
#ifdef LONGNAMES
  int     t2flags;
#endif
d988 1
a988 1
    hS->t2flags = T2FLAGS_LONGNAMES;
d1007 1
a1007 1
    hS->t2flags = 0;
d1314 1
a1314 1
      hS->t2flags = 0;
d1479 1
a1479 1
  if (hS != NULL && (hS->t2flags & T2FLAGS_LONGNAMES)) return true;
d1864 1
a1864 1
  if (!(hS->t2flags & T2FLAGS_TESTEDSWAP)) {
d1868 1
a1868 1
    hS->t2flags |= T2FLAGS_TESTEDSWAP;
d1902 1
a1902 1
               hS->t2flags |= T2FLAGS_SWAPDATETIME;
d1941 1
a1941 1
  if (hS->t2flags & T2FLAGS_SWAPDATETIME) {
d1998 1
a1998 1
  if (hS->t2flags & T2FLAGS_LONGNAMES)
d2157 1
a2157 1
  if (hS->t2flags & T2FLAGS_LONGNAMES)
d2380 1
a2380 1
  if (con->SearchDrive->t2flags & T2FLAGS_LONGNAMES)
@


1.1
log
@Initial revision
@
text
@d27 9
d87 4
d102 3
d106 1
d111 3
d154 6
d161 1
d219 17
a243 1
#define SEARCH_ST_SIZE  21
d253 1
d257 12
d289 7
d311 1
d314 3
a316 1

a320 1
typedef struct ActiveShare  *hSHARE;
d325 3
a327 1

d352 1
a352 1
  50, ENOTPRESENT,  /* Returned by W4WG from SetAttrib call */
d432 31
d479 116
d611 82
a692 1
static err_t Do_SMB ( hSHARE hS, int cmd, int wct_in, BUFCHAIN pB_in,
d695 10
a705 2
  int  wct_rx;
  BUFCHAIN pB_rx;
d718 3
d741 31
d774 4
a777 1
  NB_ClearRxQueue ( hSess );
d783 2
a784 4
  /* Get reply */
  res = NB_GetData ( hSess, &pB_rx, REPLY_TIMEOUT );
  if ( res != OK )
    return res;
d786 4
a789 8
  /* Extract received data */

  SMB_RxHdr.wct = 0;
  SMB_RxByteCount = 0;
  SMB_RxWordCount = 0;

  pB_rx = GetData ( pB_rx, &SMB_RxHdr, SMBHDR_SIZE );
  wct_rx = SMB_RxHdr.wct;
d791 2
a792 4
  if ( wct_rx > MAX_WCT )  /* Dispose of extra word results */
  {
    pB_rx = GetData ( pB_rx, SMB_RxWords, MAX_WCT*2 );
    pB_rx = GetData ( pB_rx, NULL, (wct_rx-MAX_WCT)*2 );
d794 6
a799 3
  else if ( wct_rx > 0 )
  {
    pB_rx = GetData ( pB_rx, SMB_RxWords, wct_rx*2 );
d801 1
a802 24
  pB_rx = GetData(pB_rx, &SMB_RxByteCount, 2); /* Get byte count */

  if ( pB_rx == NULL ) /* It's all gone horribly wrong! */
    return EDATALEN;

  /* Process errors back from server */

  if ( SMB_RxHdr.errclass != 0 )
  {
    FreeChain(pB_rx);
    return Err_Translate ( SMB_RxHdr.errclass,
        SMB_RxHdr.errlo + (SMB_RxHdr.errhi << 8) );
  }

  /* OK - all was well */

  SMB_RxWordCount = wct_rx;

  if ( ppB_out != NULL )
    *ppB_out = pB_rx;     /* Hand over ownership */
  else
    FreeChain(pB_rx);
  return OK;
}
d900 20
d925 1
a925 1

d928 1
a928 2
  pB = MkDataString( NULL, DATA_DIALECT,
            "DOS LM1.2X002" );    /* Change for v1.60 */
d930 5
a934 2
  if ( pB != NULL ) pB = MkDataString( pB, DATA_DIALECT,
            "PC NETWORK PROGRAM 1.0" );
d939 1
a939 1
  res = Do_SMB ( hS, SMBnegprot, 0, pB, NULL );
d943 2
a944 1
  if ( SMB_RxWords[0] == 1 ) /* LanMan 1.0 protocol */
d946 40
a985 5
    hS->hServer->ProtFlags = PROT_RWMULTI + PROT_SETDATETIME +
       (SMB_RxWords[1] & 1 ? PROT_USERLOGON : 0 ) +
       (SMB_RxWords[1] & 2 ? PROT_ENCRYPT : 0 ) +
       (SMB_RxWords[5] & 1 ? PROT_READRAW : 0 ) +
       (SMB_RxWords[5] & 2 ? PROT_WRITERAW : 0 );
d987 5
d993 10
d1008 4
d1013 1
a1025 5
  pB = AddChain ( NULL, userid, strlen(userid)+1 );
  if ( pB != NULL ) pB = AddChain ( pB, passwd, strlen(passwd)+1 );
  if ( pB == NULL )
    return EOUTOFMEM;

a1032 3
  SMB_TxWords[7] = strlen ( passwd ) + 1;
  SMB_TxWords[8] = 0;
  SMB_TxWords[9] = 0;
d1034 38
a1071 1
  res = Do_SMB ( hS, SMBsesssetup, 10, pB, NULL );
d1198 1
d1205 1
d1212 1
d1222 1
d1229 2
d1294 1
d1315 3
d1381 4
d1406 1
a1406 1
static hSHARE GetShare ( char *filename, err_t *pRes )
d1452 1
d1469 17
d1582 4
d1837 119
d1999 5
d2113 36
d2158 7
d2180 20
a2199 2
/* State which is held from one call to the next of
   SMB_EnumerateDir */
d2201 154
a2354 3
static bool NextSearchOK;
static BYTE SearchState[SEARCH_ST_SIZE];
static hSHARE SearchDrive;
d2357 1
a2357 1
                               ENUM_DIR_FN dirfn, void *private )
d2363 25
d2396 1
a2396 3
  /* Start or continue search? */

  if ( path != NULL ) /* Start search */
a2397 4
    SearchDrive = GetShare(path, &res);
    if ( SearchDrive == NULL )
      return res;

d2404 1
a2404 4
    if ( !NextSearchOK || SearchDrive == NULL )
      return ENOMOREFILES;

    pB = MkDataBlock (NULL, DATA_VARBLK, SearchState,
d2417 1
a2417 1
  NextSearchOK = false;
d2419 1
a2419 1
  res = Do_SMB ( SearchDrive, SMBsearch, 2, pB, &pBres );
d2435 1
a2435 1
    dirfn ( entry+SEARCH_ST_SIZE, private );
d2438 2
a2439 2
      NextSearchOK = true;
      memcpy ( SearchState, entry, SEARCH_ST_SIZE );
d2445 1
a2445 1
  return NextSearchOK ? OK : ENOMOREFILES;
d2934 159
d3167 8
a3174 1

d3190 25
@


1.1.1.1
log
@
LanManFS moved into Omni subdirectory.  Previous version in
RiscOS/Sources/Networking/LanManFS is now locked out.

The rest of Omni will be imported at a later date.

Version 1.87, tagged as LanManFS-1_87

@
text
@@


1.1.1.1.2.1
log
@  First cut at long filenames in LanManFS.  *Cat and *Ex work.
  Pretty much nothing else does.
Detail:
  Now uses long filenames if available, and switches to the advanced
    SMB protocol and Transact2 commands to do work with long filenames.
Admin:
  Work in progress.  End of week's work checkin point only.  Do not use.

Version 1.87, 1.1.1.1.2.2. Tagged as 'LanManFS-1_87-1_1_1_1_2_2'
@
text
@a26 5
*
*  04-12-98      sbrodie: started adding long filename support - controlled
*                  by LONGNAMES macro.
*  08-12-98      sbrodie: Added SMB_Transact2 with full support for setup
*                  words and the like (present only for LONGNAMES build)
a80 3
#ifdef LONGNAMES
#include "Transact.h" /* for transaction structure building helpers */
#endif
a88 3
#ifdef LONGNAMES
#define REPLY_TIMEOUT 4000
#else
a89 1
#endif
a93 3
#ifdef LONGNAMES
#define TRANSACT2_TIMEOUT 10000
#endif
a133 4
#ifdef LONGNAMES
/* Transact2 (LONGNAMES build only) requires 14 plus setup words */
#define MAX_WCT (14+(MAX_SETUPWORDS)+1)
#else
a134 1
#endif
a191 15
#ifdef LONGNAMES
/* The following are only available with LANMAN 2.0 Extended File Sharing
 * Protocol as defined in "SMB F. S. P. Extensions Version 3.0", document
 * version 1.11, June 19, 1990.
 */
#define SMBtrans2     0x32   /* transaction2 */
#define SMBtranss2    0x33   /* transaction2 (secondary request/response) */
#define SMBfindclose2 0x34   /* terminates a TRANSACT2_FIND_FIRST/NEXT */
#define SMBecho       0x2B

/* And now the sub-commands for SMBtrans2 */
#define TRANSACT2_FINDFIRST   0x01
#define TRANSACT2_FINDNEXT    0x02
#endif

a212 6
#ifdef LONGNAMES
#define SMB_KNOWS_LONG_NAMES	(1)
#define SMB_IS_LONG_NAME	(0x40)
#define SMB_UNICODE		(0x8000)
#endif

a232 3
#ifdef LONGNAMES
  int      SMB_flg2;   /* Flags to pass in SMB_flg2 field */
#endif
d250 1
a250 3
#ifdef LONGNAMES
  int     use_t2;
#endif
d260 1
a260 3
#ifdef LONGNAMES
static err_t SMB_Transact2 ( hSHARE hS, struct TransactParms *pT );
#endif
a380 32
#ifdef DEBUG
static void DumpBuffer(void *ptr, int len)
{
        const char *membuf = ptr;
        int i,j;
        for (i=0; i<((len+31)&~31); ++i) {
                if (!(i & 31)) {
                        printf("  ");
                        if (i) for (j = i - 32; j != i; ++j) {
                                printf("%c", (membuf[j]>=32 && membuf[j] != 0x7f) ?
                                membuf[j] : '.');
                        }
                        printf("\n%04x: ", i);
                }
                if (i>=len) {
                        printf("  ");
                        if ((i & 1)) printf(" ");
                }
                else {
                        printf("%02x", membuf[i]);
                        if ((i & 1)) printf(" ");
                }
        }
        if (i) for (printf("  "), j = i - 32; j != i; ++j) printf("%c",
            j>=len ? ' ' : (membuf[j]>=32 && membuf[j] != 0x7f) ?
            membuf[j] : '.');
	printf("\n");
}
#else
#define DumpBuffer(ptr, len) ((void)0)
#endif

a414 3
#ifdef LONGNAMES
  SMB_TxHdr.flg2 = hS->hServer->SMB_flg2;
#endif
a434 13
#ifdef DEBUG
if (cmd == SMBtrans2 && SMB_TxWords[14] == 2) {
        static char membuf[4192];
        int len = ChainLen(pB_in);

        GetData ( pB_in, membuf, len);
        pB_in = AddChain ( NULL, membuf, len);
        if (pB_in == NULL)
                return EOUTOFMEM;
        DumpBuffer(membuf, len);
}
#endif

a448 1
  debug1("Do_SMB - NB_GetData returned %d bytes\n", ChainLen(pB_rx));
a456 10
/* sbrodie: moved this from just above "OK - all was well" comment */
  /* Process errors back from server */
  if ( SMB_RxHdr.errclass != 0 )
  {
    debug1("Do_SMB: errclass was %d\n", SMB_RxHdr.errclass);
    FreeChain(pB_rx);
    return Err_Translate ( SMB_RxHdr.errclass,
        SMB_RxHdr.errlo + (SMB_RxHdr.errhi << 8) );
  }

d472 9
a587 13
/* sbrodie: Abstract the dialect strings here - means debug version can
 * can this function to find out which protocol was accepted.
 */
static char *SMB_Dialect(int num)
{
        if (num == 0) return "PC NETWORK PROGRAM 1.0";
        if (num == 1) return "DOS LM1.2X002";
        if (num == 2) return "LM1.2X002";
        if (num == 3) return "NT LM 0.12";
        return "";
}
#define MAX_DIALECT 3

a592 1
  int dcount;
d596 2
a597 1
  pB = NULL;
d599 2
a600 5
  /* Must be entered in reverse order */
  for (dcount = MAX_DIALECT; dcount >= 0; --dcount) {
    pB = MkDataString( pB, DATA_DIALECT, SMB_Dialect(dcount));
    if (pB == NULL) break;
  }
d609 1
a609 2
  debug1("Negotiated protocol `%s'\n", SMB_Dialect(SMB_RxWords[0]));
  if ( SMB_RxWords[0] >= 1 )
a616 5
#ifdef LONGNAMES
    debug0("Enabling long filenames on this share\n");
    hS->hServer->SMB_flg2 = SMB_KNOWS_LONG_NAMES; /* | SMB_IS_LONG_NAME;*/
    hS->use_t2 = 1;
#endif
a622 4
#ifdef LONGNAMES
    hS->use_t2 = 0;
    hS->hServer->SMB_flg2 = 0;
#endif
a888 3
#ifdef LONGNAMES
      hS->use_t2 = 0;
#endif
a1564 169
#ifdef LONGNAMES

enum {
        ffirst_FORCE_CLOSE = 1,
        ffirst_CLOSE_IF_DONE = 2,
        ffirst_RETURN_KEYS = 4,
        fnext_CONTINUE = 8
};

static err_t SMB_AbandonFind2( hSHARE hS, WORD dir_handle )
{
        debug1("Terminating search op (dir_handle = 0x%04x)\n", dir_handle);
        SMB_TxWords[0] = dir_handle;
        return Do_SMB(hS, SMBfindclose2, 1, NULL, NULL);
}

static err_t SMB_ReadDirEntriesX2 ( hSHARE hS, char *path, int count,
                               ENUM_DIR_FN dirfn, void *private )
{
  static struct TransactParms tp;
  static DWORD resume_key;
  static WORD  dir_handle;
  static char  last_filename[DOS_NAME_LEN];
  char *ptr_last_filename;
  err_t res;
  BYTE *p;
  int n_read = 0;
  int eos;
  int lastname;
  int i;
  const int first_flags = /*ffirst_CLOSE_IF_DONE |*/ ffirst_RETURN_KEYS;
  const int next_flags  = /*ffirst_CLOSE_IF_DONE |*/ ffirst_RETURN_KEYS;// | fnext_CONTINUE;
  int flags;

  if (path != NULL && NextSearchOK == true || count < 0) {
     /* We need to abandon the current search attached to dir_handle.
      * Ignore errors.
      */
     debug3("SMB_ReadDirEntriesX2 -> path (%p) NextSearchOK (%d) count (%d)\n",
       path, NextSearchOK, count);
     (void) SMB_AbandonFind2( hS, dir_handle );
  }

  NextSearchOK = false;
  if (count < 0) return ENOMOREFILES;

  //count = min (count, 10);

  /* Implement directory searching via TRANSACT2/FINDFIRST/FINDNEXT */
  if (path != NULL) {
    /* Initial search - note we accept SIX return parameters - contrary to
     * Microsoft's own document - because it doesn't work if you only pass 5. Grr.
     */
    resume_key = 0;
    flags = first_flags;
    Transact_init(&tp, 6 * 2);           /* will accept 6 WORD return params */
    Transact_addsetupword(&tp, TRANSACT2_FINDFIRST);
    Transact_addword(&tp, ATTR_DIR);     /* findfirst_Attribute */
    Transact_addword(&tp, count);        /* findfirst_SearchCount */
    Transact_addword(&tp, first_flags);  /* findfirst_flags */
    Transact_addword(&tp, 1);            /* Search level  */
    Transact_addlong(&tp, 0L);           /* reserved, MBZ */
    Transact_addstring(&tp, path+2);     /* findfirst_FileName[] */
    res = SMB_Transact2(hS, &tp);
    if (res != OK)
      return res;
    p = tp.parms_out_buf;
    dir_handle = Transact_getword(p); p += 2;
    debug1("SID = 0x%04hx\n", dir_handle);
  }
  else {
    /* continuation */
    flags = next_flags;
    Transact_init(&tp, 4 * 2);           /* will accept 4 WORD return params */
    Transact_addsetupword(&tp, TRANSACT2_FINDNEXT);
    Transact_addword(&tp, dir_handle);   /* findnext_DirHandle */
    Transact_addword(&tp, count);        /* findnext_SearchCount */
    Transact_addword(&tp, 1);            /* Search level  */
    Transact_addlong(&tp, resume_key);   /* Resume key from previous */
    Transact_addword(&tp, next_flags);   /* findnext_flags */
    Transact_addstring(&tp, last_filename); /* resumption filename */
    res = SMB_Transact2(hS, &tp);
    if (res != OK)
      return res;
    p = tp.parms_out_buf;
  }
  /* Remainder of response handling is common to both sub-commands */
  n_read = Transact_getword(p); p += 2;
  eos = Transact_getword(p); p += 2;
  p += 2; /* skip error offset */
  lastname = Transact_getword(p);
  if (lastname == 0) {
    ptr_last_filename = NULL;
  }
  else {
    ptr_last_filename = (char *) tp.data_out_buf + lastname;
  }

  if (eos) {
          debug0(">> Server said it was the end of the search operation\n");
  }

  p = tp.data_out_buf;
  /* At this point, p is pointing to the start of the returned data
   * buffer, n_read contains the number of files known to be in the
   * return buffer, eos is non-zero if the search is completed.
   */
  if (n_read == 0)
    return ENOMOREFILES;

  for (i=1; i <= n_read; ++i) {
    int length;
    DWORD next_resume_key;
    if (flags & ffirst_RETURN_KEYS) {
            next_resume_key = Transact_getlong(p); p += 4;
    }
    length = p[22];
    //debug2("ding - got one (length = %d) `%s'\n", length, p+23);
    //DumpBuffer(p, 2 + 2 + 2 + 2 +2 +2 + 4 + 4 +2 + 1 + length);
    res = dirfn(p, 1, private);
    if (res != OK) {
      /* Entry expander must have run out of space!  Remember where the
       * search was at, and try to rewind it a bit by using the resume
       * key and the last_filename
       */
      /* If the search said this was the end of the search though, it will
       * have already terminated the search, so NextSearchOK becomes false
       * and it will have to restart the search next time around.
       */
       //NextSearchOK = eos ? false : true;
       debug0("Bugger.  Looks like client ran out of space\n");
       if (eos) {
         (void) SMB_AbandonFind2( hS, dir_handle );
       }
       else {
         int j;
         NextSearchOK = true;
         for (j=i; j<n_read; ++j) dirfn(p, 1, private);
       }
       return EOUTOFMEM;
    }
    else {
       resume_key = next_resume_key;
       ptr_last_filename = (char *) p + 23;
       (void) strncpy(last_filename, ptr_last_filename?ptr_last_filename:"",
         sizeof(last_filename));
    }
    p += 23 + length + 1;
    if ( i == count )  /* By implication, if n_read >= count */
    {
      debug3("i = %3d; count = %3d; n_read = %3d\n", i, count, n_read);
      debug0("OK - there are more to come later; ");
      if (flags & ffirst_RETURN_KEYS) {
        debug1("Resume key is 0x%08x; ", resume_key);
      }
      debug1("Next filename is `%s'\n", last_filename);
      NextSearchOK = true;
    }
  }

  if (eos) {
          debug0(">> Server said it was the end of the search operation\n");
          NextSearchOK = false;
  }

  return NextSearchOK ? OK : ENOMOREFILES;
}
#endif

d1573 7
a1586 15
  }
  else
  {
    if ( !NextSearchOK || SearchDrive == NULL )
      return ENOMOREFILES;
  }

#ifdef LONGNAMES
  if (SearchDrive->use_t2)
  {
     return SMB_ReadDirEntriesX2(SearchDrive, path, count, dirfn, private);
  }
#endif

  /* Check 'count' */
a1587 7
  if ( count <= 0 )
    return ENOMOREFILES;

  count = min ( count, SEARCH_COUNT ); /* Don't do more than is convenient */

  if ( path != NULL ) /* Starting search */
  {
d1594 3
d1628 1
a1628 1
    dirfn ( entry+SEARCH_ST_SIZE, 0, private );
a2126 136
#ifdef LONGNAMES
/* 14 is the number of words common to all Transact2 commands.  The
 * number of setup words is then added to that value.  The 14 passed
 * to Do_SMB has the number of setup words added to it as this doubles
 * as the header length limiter and the pointer to where to write the
 * total data+param size field (what the Microsoft docs call smb_bcc).
 * This is why you cannot just AddChain the setup word blocks like the
 * data and parameters are handled.
 */
static err_t SMB_Transact2 ( hSHARE hS, struct TransactParms *pT )
{
  BUFCHAIN pB, pBres;
  err_t res;
  int   a = SMBHDR_SIZE + ((14 + pT->setup_in_len)*2) + 2;
  int pda = ((a + 3) & ~3);
      /* SMB header size, 14 params + setup words + 2 byte data length
       */
  int   padbytes;    /* Temp variable */
  int   sc;

  debug1("SMB_Transact2: processing (Tid = %#04x)...\n", hS->Tid);

  SMB_TxWords[0]  = pT->parms_in_len; /* Total length */
  SMB_TxWords[1]  = pT->data_in_len; /* Total length */
  SMB_TxWords[2]  = pT->parms_out_maxlen;
  SMB_TxWords[3]  = pT->data_out_maxlen;
  SMB_TxWords[4]  = 0; /* Setup words to return */
  SMB_TxWords[5]  = 0; /* Flags - normal */
  SMB_TxWords[6]  = TRANSACT2_TIMEOUT; /* Timeout LSW */
  SMB_TxWords[7]  = 0; /* Timeout MSW */
  SMB_TxWords[8]  = 0; /* Reserved */
  SMB_TxWords[9]  = pT->parms_in_len; /* Length this buffer */
  SMB_TxWords[10] = pda;  /* Offset from SMB header to parm bytes */
  SMB_TxWords[11] = pT->data_in_len; /* Length this buffer */
  SMB_TxWords[12] = pda + pT->parms_in_len;  /* Offset to data bytes */
  SMB_TxWords[13] = pT->setup_in_len; /* Setup words being sent */

  debug2("%d bytes of parameters at offset %#x\n", pT->parms_in_len, pda);
  debug2("%d bytes of data at offset %#x\n", pT->data_in_len, SMB_TxWords[12]);

  for (sc = 0; sc < pT->setup_in_len; ++sc)
    SMB_TxWords[14 + sc] = pT->setup_in[sc];

  pB = NULL;

  /* Make up data chain */

  if ( pT->data_in_len != 0 )
  {
    pB = AddChain ( pB, pT->data_in, pT->data_in_len );
    if ( pB == NULL )
      return EOUTOFMEM;
  }

  if ( pT->parms_in_len != 0 )
  {
    pB = AddChain ( pB, pT->parms_in, pT->parms_in_len );
    if ( pB == NULL )
      return EOUTOFMEM;
  }

  /* Add the null string - pda-a must be 1 or 3.  "D " added because
   * that's what SAMBA does (because that's what OS/2 does) */
  pB = AddChain ( pB, "\0D ", pda - a );
  if (pB == NULL )
    return EOUTOFMEM;

  res = Do_SMB ( hS, SMBtrans2, 14 + pT->setup_in_len, pB, &pBres );

  if ( res != OK ) {
    debug0("SMB_Transact2: Do_SMB failed\n");
    DumpBuffer(&SMB_RxHdr, SMBHDR_SIZE);
    return res;
  }

  /* Now extract results */

  if ( SMB_RxWordCount < 10 )
  {
    debug1("SMB_Transact2: SMB_RxWordCount was %d\n", SMB_RxWordCount);
    FreeChain(pBres);
    return EDATALEN;
  }

  a = SMBHDR_SIZE + (SMB_RxWordCount)*2 + 2;
  /* Size of SMBHDR plus returned rx words plus byte count
     = offset of data in pBres from start of header */

#ifdef DEBUG
  if (SMB_RxWords[1] != SMB_RxWords[6]) {
    int i; for (i=0; i<20; ++i) debug0("***********************\n");
    debug2("Total data: %d; this data %d\n", SMB_RxWords[1], SMB_RxWords[6]);
  }
#endif

  pT->parms_out_len = min(SMB_RxWords[3], pT->parms_out_maxlen);
                          /* Parm bytes being returned */
  pT->data_out_len  = min(SMB_RxWords[6], pT->data_out_maxlen);
                          /* Data bytes being returned */
  pT->setup_out_len = min(SMB_RxWords[9], pT->setup_out_maxlen);

  if (pT->setup_out_len > 0 )          /* Get setup_out */
  {
    memcpy(pT->setup_out, &SMB_RxWords[14], 2 * pT->setup_out_len);
  }

  if ( pT->parms_out_len > 0 )         /* Get parms_out */
  {
    padbytes = SMB_RxWords[4] - a;     /* RxWords[4] is offset;
                                          Get number of pad bytes */

    if ( padbytes > 0 )
      pBres = GetData(pBres, NULL, padbytes);
    pBres = GetData(pBres, pT->parms_out_buf, pT->parms_out_len);
    a += padbytes + pT->parms_out_len; /* New offset value */
  }

  if ( pT->data_out_len > 0 )        /* Get data_out */
  {
    padbytes = SMB_RxWords[7] - a;     /* Number of pad bytes */
    if ( padbytes > 0 )
      pBres = GetData(pBres, NULL, padbytes);
    pBres = GetData(pBres, pT->data_out_buf, pT->data_out_len);
    //DumpBuffer(pT->data_out_buf, pT->data_out_len);
  }

  if ( pBres == NULL ) {  /* Oh no! Techo fear! */
    debug0("SMB_Transact2: pBres was NULL\n");
    return EDATALEN;
  }

  FreeChain(pBres);
  return OK;
}
#endif

d2201 1
a2201 5
#ifdef LONGNAMES
  SMB_TxHdr.flg2 = SMB_KNOWS_LONG_NAMES; /*| SMB_IS_LONG_NAME;*/
#else
  SMB_TxHdr.flg2 = 0;
#endif
@


1.1.1.1.2.2
log
@  Another intermediate checkin now that *FileInfo works.  I believe this
    means that nearly all the core functionality is in place for long
    filename support.
Detail:
  According to Microsoft's documentation, several of the file lookup type
    transactions return the file information in a common format buffer.
    However, what the docs fail to mention, is that in *some* of those
    commands, the time & date fields are reversed.  FindFirst2/FindNext2
    return "date, time, ...".  QPathInformation returns "time, date, ..."
    Grrr.
  There remains a problem with occasional "server error" results from
    some requests.  The reason for these is unknown ... the documentation is
    unhelpful, describing this as "non-specific error code".  Simply repeating
    the command often results in success, sometimes it has to be repeated a
    few times.
  Also fixed filename mapping which caused any 'x' characters at the remote
    server end to be mapped to 'c' at the RISC OS end(!)  This didn't affect
    it before because servers wouldn't return the old module any filenames
    which contained lower case letters (LanManFS used to make the characters
    lower-case itself if the appropriate name style mode was set).
Admin:
  Tested - still seems to work.  Filename completion from LineEditor works
    nicely.  I can open and close files, and read data from them (*Dump
    used to test this).  *Cat, *Ex and *FileInfo all work.  *Dir works.
  Filename character translations to and from RISC OS format need to be
    verified.  The translation table DOS->RISC OS has been ripped out of
    the NFS module so should be pretty accurate.  The reverse mapping has
    not.

Version 1.87, 1.1.1.1.2.3. Tagged as 'LanManFS-1_87-1_1_1_1_2_3'
@
text
@a31 4
*                  Several new functions added to support long filename
*                  compatible versions of some calls,  These functions have
*                  the same name as the function they upgrade with an X2 suffix
*                  added.
a224 1
#define TRANSACT2_QUERYPATHINFORMATION 0x05
d333 1
a333 1
  50, ENOTPRESENT,  /* Return~ed by W4WG from SetAttrib call */
a476 5
#ifdef LONGNAMES
//#define RETRYONERROR
//#define PINGFIRST
#endif

a479 9
#ifdef RETRYONERROR
  static const int xmit_size = SMBWORKBUF_SIZE + SMBHDR_SIZE + MAX_WCT * 2;
  static BYTE SMB_XmitMemory[SMBWORKBUF_SIZE + SMBHDR_SIZE + MAX_WCT * 2];
  int len, retry;
#endif
#ifdef PINGFIRST
  BUFCHAIN ping_in;
  static SMBHDR ping_hdr;
#endif
d531 1
a531 9
#ifdef RETRYONERROR
  len = ChainLen(pB_in);
  GetData ( pB_in, SMB_XmitMemory, xmit_size );
  retry = 1; /* number of retries to attempt */
do_smb_retry:
  pB_in = AddChain ( NULL, SMB_XmitMemory, len );
  if ( pB_in == NULL )
  return EOUTOFMEM;
#endif
a532 1
#ifdef PINGFIRST
a533 25
  ping_hdr = SMB_TxHdr;
  ping_hdr.command = SMBecho;
  ping_hdr.wct = 1;
  ping_hdr.tid = 0;
  ping_hdr.mid = 2;
  ping_in = AddChain ( NULL, "\x01\x00\x02\x00\xA8\x00", 6 );
  if (ping_in) ping_in = AddChain( ping_in , &ping_hdr, SMBHDR_SIZE );
  if (ping_in) {
    res = NB_SendData ( hSess, ping_in );
    if ( res != OK )
      return res;
    res = NB_GetData ( hSess, &pB_rx, REPLY_TIMEOUT );
    if (res != OK)
      return res;
    GetData ( pB_rx, NULL, SMBHDR_SIZE + 6 );
    FreeChain ( pB_rx );
  }
#endif

  /* Send data */

  res = NB_ClearRxQueue ( hSess );
  if (res != OK) {
    debug0("****************** NB_ClearRxQueue says there was stuff pending!!!!!!!!\n");
  }
d545 1
a545 1
  debug2("Do_SMB (cmd=0x%x) - NB_GetData returned %d bytes\n", cmd, ChainLen(pB_rx));
a559 6
#ifdef RETRYONERROR
    if (SMB_RxHdr.errclass == ERRSRV && SMB_RxHdr.errlo == 1 && SMB_RxHdr.errhi == 0 && retry) {
      --retry;
      goto do_smb_retry;
    }
#endif
d1100 1
a1100 1
static hSHARE GetShare ( const char *filename, err_t *pRes )
a1145 18

/* ---------------------------- */

/* SMB_IsLongNameFS() returns true if the path refers to a share which is using long
    filenames.  Xlate.c needs to know this in order to determine which set of file
    mappings is to be used.
 */
bool SMB_IsLongNameFS( const char * path)
{
  err_t e;
  hSHARE hS;

  hS = GetShare(path, &e);
  if (e != OK) return false;
  if (hS->use_t2) return true;
  return false;
}

a1508 44
#ifdef LONGNAMES

/* Microsoft servers not sending them in the documented order */
static void swap_time_date(BYTE *p)
{
        BYTE swp;

        swp = p[0];
        p[0] = p[2];
        p[2] = swp;

        swp = p[1];
        p[1] = p[3];
        p[3] = swp;
}

static err_t SMB_GetAttribsX2 (hSHARE hS, char *filename, DOS_ATTRIBS *pAttr )
{
  err_t res;
  static struct TransactParms tp;

  Transact_init(&tp, 1 * 2);
  Transact_addsetupword(&tp, TRANSACT2_QUERYPATHINFORMATION);
  Transact_addword(&tp, 1);  /* information level */
  Transact_addlong(&tp, 0L); /* Reserved */
  Transact_addstring(&tp, filename+2);
  res = SMB_Transact2(hS, &tp);
  if (res != OK)
    return res;
  /*
   * OK.  Who decided that this call should return data in a different
   * format than the FindFirst/FindNext calls.  Need to reverse the times
   * and dates of the file before calling Xlt to expand them ...
   */
  swap_time_date(tp.data_out_buf);
  swap_time_date(tp.data_out_buf+4);
  swap_time_date(tp.data_out_buf+8);
  /* end workaround */
  return Xlt_ExpandSearchEntryX2 ( tp.data_out_buf, NULL, NULL, pAttr, NULL);
}
#endif /* LONGNAMES */

/* --------------------------- */

a1551 5
#ifdef LONGNAMES
  if (hS->use_t2)
    return SMB_GetAttribsX2 (hS, filename, pAttr );
#endif

a1693 5
/* Note.
 *
 * Requesting close_if_done doesn't seem to work (at least on NT 4.0 SP3)
 *
 */
d2455 1
a2455 2
  debug2("SMB_Transact2: processing (Tid = %#04x, sub-cmd=%#04x)...\n", hS->Tid,
    pT->setup_in[0]);
d2534 1
a2534 1
  pT->setup_out_len = min(SMB_RxWords[9] & 0xFF, pT->setup_out_maxlen);
d2558 1
a2558 1
    //if (pT->setup_in[0] == 5) DumpBuffer(pT->data_out_buf, pT->data_out_len);
@


1.1.1.1.2.3
log
@  A few more battles have been won.  War finally starting to go my way.
Detail:
  LanManFS now uses ,xxx type notation on long filename shares.
  Character mappings improved (necessary because Windows allows so
    many extra daft characters to appear in filenames) and one-to-many
    mappings for awkward charcacters in the RISC OS->DOS world have
    been added.
  Directory searching improved so that the wildcard matching can be
    done properly.  Only Microsoft could provide you an API call to
    discover information about a filename specified with wildcards and
    NOT tell you which filename it matched. :-/
  Things remaining unimplemented so far:
    Setting filetypes.
    Creating files with specific types
    Renaming.
  All those outstanding things relate to the work done by Attr_SetInfo
    which should be the final major piece of hacking required.
Admin:
  Tested by connecting to a long filename share from both a RISC OS
    machine and a Windows NT machine.  All behaviour of the RISC OS
    machine has been verified against what the NT machine is seeing
    happening.  No surprises.  One-to-many character mappings are
    being matched correctly.
  Also tested using the Filer at the RISC OS end to navigate, run,
    and edit things on the remote share.

Version 1.87, 1.1.1.1.2.4. Tagged as 'LanManFS-1_87-1_1_1_1_2_4'
@
text
@d748 1
a748 8
static char *dialects[] = {
                "PC NETWORK PROGRAM 1.0",
                "DOS LM1.2X002",
                "LM1.2X002",
                "NT LM 0.12"
};
#define MAX_DIALECT ((sizeof(dialects)/sizeof(*dialects))-1)
static char *SMB_Dialect(unsigned int num)
d750 4
a753 1
        if (num <= MAX_DIALECT) return dialects[num];
d756 1
d763 1
a763 1
  unsigned int dcount;
d770 1
a770 1
  for (dcount = MAX_DIALECT; ; --dcount) {
d772 1
a772 1
    if (pB == NULL || dcount == 0) break;
d1218 2
a1219 1
  if (e == OK && hS->use_t2) return true;
a1623 1
  strcpy((char *)tp.data_out_buf+23, filename); /* Xlt_ExpandSearchEntryX2 relies on this */
d1953 1
a1953 1
       debug0("Bugger.  Looks like client ran out of space (or could be name xlate code)\n");
a2584 1
  int   retry = 3;
a2585 1
retry_transact2:
a2636 6
    if (SMB_RxHdr.errclass == ERRSRV && SMB_RxHdr.errlo == 1 && SMB_RxHdr.errhi == 0 && retry)
    {
       --retry;
       debug0("SMB_Transact2: retrying request\n");
       goto retry_transact2;
    }
d2690 1
a2690 2
    if (pT->setup_in[0] == TRANSACT2_QUERYPATHINFORMATION)
      DumpBuffer(pT->data_out_buf, pT->data_out_len);
@


1.1.1.1.2.4
log
@  Fixed logon behaviour against NT4 servers.
  Added automatic bug detection code.
Detail:
  NT4 servers use differently formatted buffer to response to the logon
    requests and this was confusing the code which only knew about the
    oldest format of this buffer.  The code now knows about all three
    different possible response formats and processes them all properly.
  Windows 95/98 servers contain a bug which cause them to reverse the
    order of the date and time fields in QPathInformation transactions.
    My earlier workaround for this was to always reverse the time/date
    pairs - which causes it to fail when talking to Windows NT servers.
    On the first QPathInformation request on a given share, the request
    is first done on the root directory, and then the (non-broken) dir
    search transaction is executed and the results compared to determine
    whether the server is broken or not.  This means that it should
    interwork with NT, 95, 98 and also with Samba (which has a build
    option for emulating this bug or not!)
  Transact2 processing code is now aware of the multiple response packet
    options and can cope with the server sending secondary responses.
  Directory search entry per call limiter re-introduced to prevent these
    from secondary responses occurring anyway as they are still a pain to
    process efficiently.
Admin:
  Tested against Windows 98 and Windows NT 4.

Version 1.87, 1.1.1.1.2.6. Tagged as 'LanManFS-1_87-1_1_1_1_2_6'
@
text
@d154 2
a155 4
/* Transact2 (LONGNAMES build only) requires 14 plus setup words
 * The NT LM 0.12 negprot response requires 17.
 */
#define MAX_WCT (17+(MAX_SETUPWORDS)+1)
a249 1
#define PROT_HAVE_GUID   64
a256 6

#define T2FLAGS_LONGNAMES	(1)
#define T2FLAGS_SWAPDATETIME	(2)
#define T2FLAGS_TESTEDSWAP	(4)

#define CAP_EXTENDED_SECURITY	(0x80000000)
a281 4
  int      prot;       /* which protocol was nogitated */
  char     guid[16];   /* GUID returned from NT negprot commands */
  int      bloblen;
  BYTE     *blob;
a296 1
  int     Uid;          /* User ID */
d300 1
a300 1
  int     t2flags;
a417 31
/* This routine takes an ASCII string and encodes it into Unicode by
 * inserting extra zero bytes between each character and at the end
 * It adds the resulting string to the given BUFCHAIN.  It optimises
 * for strings up to AUSTC_SKIP chars long.
 */
#if 0
static BUFCHAIN AddUnicodeStringToChain ( BUFCHAIN pB, char *str )
{
#define AUSTC_SKIP 18
        int len = strlen(str)+1, skiplen, cp;
        char ucbuf[AUSTC_SKIP*2];

	skiplen = len % AUSTC_SKIP;
	len -= skiplen;

        do {
                for (cp = skiplen - 1; cp>=0; --cp) {
                        ucbuf[cp*2] = str[len + cp];
                        ucbuf[cp*2+1] = '\0';
                }
                pB = AddChain(pB, ucbuf, skiplen * 2);
                skiplen = AUSTC_SKIP;
                len -= skiplen;
        } while (pB && len >= 0);

        return pB;
}
#endif

/* --------------------- */

a465 84
#ifdef DEBUG
static BUFCHAIN DumpChain(BUFCHAIN pB)
{
        static char membuf[32768];
        int len = ChainLen(pB);

        GetData ( pB, membuf, len);
        FreeChain(pB);
        pB = AddChain ( NULL, membuf, len);
        if (pB == NULL)
                return NULL;
        DumpBuffer(membuf, len);
        return pB;
}
#else
#define DumpChain(pB) (pB)
#endif

#ifdef DEBUG
typedef struct {
        const char *name;
        int size;
} DumpVarStr;
#define DVS_MK(name,type) {name, sizeof(type)}
#define DVS_END {0,0}

DumpVarStr dvs_NTnegprot[] = {
	DVS_MK("dialect", WORD),
	DVS_MK("securitymode", BYTE),
	DVS_MK("maxmpx", WORD),
	DVS_MK("maxvcs", WORD),
	DVS_MK("maxbuffersize", DWORD),
	DVS_MK("maxrawsize", DWORD),
	DVS_MK("sessionkey", DWORD),
	DVS_MK("capabilities", DWORD),
	DVS_MK("systimelo", DWORD),
	DVS_MK("systimehi", DWORD),
	DVS_MK("servertimezone", WORD),
	DVS_MK("securitybloblen", BYTE),
	DVS_END
};

DumpVarStr dvs_negprot[] = {
	DVS_MK("dialect", WORD),
	DVS_MK("securitymode", WORD),
	DVS_MK("maxbuffersize", DWORD),
	DVS_MK("maxmpx", WORD),
	DVS_MK("maxvcs", WORD),
	DVS_MK("rawmode", WORD),
	DVS_MK("sessionkey", DWORD),
	DVS_MK("systime", WORD),
	DVS_MK("sysdate", WORD),
	DVS_MK("challengelen", WORD),
	DVS_MK("reserved (MBZ)", WORD),
	DVS_END
};

static void *DumpVar(void *ptr, const char *name, unsigned long sz)
{
        static const char *sizestr[] = { "<NULL>", "UCHAR", "USHORT", "????", "ULONG" };
	BYTE *bptr = ptr;
	unsigned long value = 0;
	unsigned long s;

	for (s=0; s<sz; ++s) {
	        value |= ((unsigned long)(*bptr++) << (s<<3UL));
	}
	printf("%6s %s: %#lx (%ld)\n", sizestr[sz], name, value, value);
	return bptr;

}

static void DumpStruct(void *ptr, const DumpVarStr *dvs)
{
        while (dvs->size) {
                ptr = DumpVar(ptr, dvs->name, dvs->size);
                ++dvs;
        }
}
#else
#define DumpVar(ptr, name, sz) ((void *)(((char *)ptr)+sz))
#define DumpStruct(ptr, str) ((void)0)
#endif

a486 77
/* sbrodie (15 Jan 1999)
 *
 * This function has been split into two parts so that SMB_Transact2 can share the
 * packet response code (now in Do_SMBResponse) with that used by Do_SMB.  SMB_Transact2
 * can have multiple response packets if the data is very large.
 */
static err_t Do_SMBResponse(hSHARE hS, int cmd, BUFCHAIN *ppB_out )
{
  int wct_rx;
  err_t res;
  BUFCHAIN pB_rx;

  /* Get reply */
  res = NB_GetData ( hS->hServer->hSession, &pB_rx, REPLY_TIMEOUT );
  if ( res != OK )
    return res;

  /* Extract received data */
  debug2("Do_SMB (cmd=0x%x) - NB_GetData returned %d bytes\n", cmd, ChainLen(pB_rx));
#ifdef DEBUG
  if (cmd == SMBsesssetup) pB_rx = DumpChain(pB_rx);
#endif

  SMB_RxHdr.wct = 0;
  SMB_RxByteCount = 0;
  SMB_RxWordCount = 0;

  pB_rx = GetData ( pB_rx, &SMB_RxHdr, SMBHDR_SIZE );
  wct_rx = SMB_RxHdr.wct;

/* sbrodie: moved this from just above "OK - all was well" comment */
  /* Process errors back from server */
  if ( SMB_RxHdr.errclass != 0 )
  {
    debug1("Do_SMB: errclass was %d\n", SMB_RxHdr.errclass);
    FreeChain(pB_rx);
#ifdef RETRYONERROR
    if (SMB_RxHdr.errclass == ERRSRV && SMB_RxHdr.errlo == 1 && SMB_RxHdr.errhi == 0 && retry) {
      --retry;
      goto do_smb_retry;
    }
#endif
    return Err_Translate ( SMB_RxHdr.errclass,
        SMB_RxHdr.errlo + (SMB_RxHdr.errhi << 8) );
  }

  if ( wct_rx > MAX_WCT )  /* Dispose of extra word results */
  {
    pB_rx = GetData ( pB_rx, SMB_RxWords, MAX_WCT*2 );
    pB_rx = GetData ( pB_rx, NULL, (wct_rx-MAX_WCT)*2 );
  }
  else if ( wct_rx > 0 )
  {
    pB_rx = GetData ( pB_rx, SMB_RxWords, wct_rx*2 );
  }

  pB_rx = GetData(pB_rx, &SMB_RxByteCount, 2); /* Get byte count */

  if ( pB_rx == NULL ) /* It's all gone horribly wrong! */
    return EDATALEN;

  /* OK - all was well */
#ifdef DEBUG
  if (cmd == SMBnegprot) debug2("Protocol negotiation returned %d words and %d bytes\n",
          wct_rx, SMB_RxByteCount);
#endif

  SMB_RxWordCount = wct_rx;

  if ( ppB_out != NULL )
    *ppB_out = pB_rx;     /* Hand over ownership */
  else
    FreeChain(pB_rx);
  return OK;
}


a496 1
  BUFCHAIN pB_rx;
d500 2
d537 13
d592 55
a646 1
  return Do_SMBResponse(hS, cmd, ppB_out);
a648 1

d746 1
a746 2
 * call this function to find out which protocol was accepted.  The
 * offsets within the array of each string are vital to SMB_Negotiate.
a754 3
#define DIALECT_BASIC 0
#define DIALECT_LM12X002 1
#define DIALECT_NT 3
d767 1
d781 1
a781 1
  res = Do_SMB ( hS, SMBnegprot, 0, pB, &pB );
a784 13
  #ifdef DEBUG
  debug1("Data length on negprot is %d\n", ChainLen(pB));
  {
          static char buf[4096];
          void *ptr = SMB_RxWords;
          int len = ChainLen(pB);
          GetData(pB, buf, len);
          DumpBuffer(buf, len);
          DumpStruct(ptr, (SMB_RxWords[0] >= DIALECT_NT) ? dvs_NTnegprot : dvs_negprot);
  }
  #endif
  FreeChain(pB);

d786 1
a786 2
  hS->hServer->prot = SMB_RxWords[0];
  if ( SMB_RxWords[0] >= DIALECT_LM12X002 )
d788 5
a792 26
    if (SMB_RxWords[0] >= DIALECT_NT) {
      /* grr - different response format */
      hS->hServer->ProtFlags = PROT_RWMULTI + PROT_SETDATETIME +
         (SMB_RxWords[9] & 0x100 ? PROT_READRAW+PROT_WRITERAW : 0 ) +
         (SMB_RxWords[1] & 1 ? PROT_USERLOGON : 0 ) +
         (SMB_RxWords[1] & 2 ? PROT_ENCRYPT : 0 );
      if (SMB_RxWords[10] & 0x80) {
        /* CAP_EXTENDED_SECURITY */
        hS->hServer->ProtFlags |= PROT_HAVE_GUID;
        GetData(pB, hS->hServer->guid, 16);
        debug0("Found a GUID block in the data section\n");
      }
      else {
        /* No bit */
        debug0("No extended security - no GUID in the data block\n");
      }
      hS->hServer->bloblen = SMB_RxWords[16] >> 8;
    }
    else {
      hS->hServer->bloblen = SMB_RxWords[11];
      hS->hServer->ProtFlags = PROT_RWMULTI + PROT_SETDATETIME +
         (SMB_RxWords[1] & 1 ? PROT_USERLOGON : 0 ) +
         (SMB_RxWords[1] & 2 ? PROT_ENCRYPT : 0 ) +
         (SMB_RxWords[5] & 1 ? PROT_READRAW : 0 ) +
         (SMB_RxWords[5] & 2 ? PROT_WRITERAW : 0 );
    }
d797 1
a797 1
    hS->t2flags = T2FLAGS_LONGNAMES;
a799 10
    if (hS->hServer->bloblen > 0) {
      free(hS->hServer->blob);
      hS->hServer->blob = malloc(hS->hServer->bloblen);
      if (hS->hServer->blob != NULL) {
        GetData(pB, hS->hServer->blob, hS->hServer->bloblen);
      }
    }
    else {
      hS->hServer->blob = 0;
    }
d806 1
a806 1
    hS->t2flags = 0;
a809 1
  debug1("%s-level security\n", hS->hServer->ProtFlags & PROT_USERLOGON ? "User" : "Share");
d822 5
d834 3
d838 1
a838 38
  if (hS->hServer->prot < DIALECT_NT) {
    pB = AddChain ( NULL, userid, strlen(userid)+1 );
    if ( pB != NULL ) pB = AddChain ( pB, passwd, strlen(passwd)+1 );
    if ( pB == NULL )
      return EOUTOFMEM;

    SMB_TxWords[7] = strlen ( passwd ) + 1;
    SMB_TxWords[8] = 0;
    SMB_TxWords[9] = 0;

    res = Do_SMB ( hS, SMBsesssetup, 10, pB, NULL );
  }
  else if (hS->hServer->ProtFlags & PROT_HAVE_GUID) {
    /* CAP_EXTENDED_SECURITY is supported by the server - setup session accordingly */
    SMB_TxWords[7] = hS->hServer->bloblen;
    SMB_TxWords[8] = SMB_TxWords[9] = 0; /* reserved */
    SMB_TxWords[10] = SMB_TxWords[11] = 0; /* client capabilities */
    pB = AddChain ( NULL, hS->hServer->blob, hS->hServer->bloblen );
    if (pB == NULL )
      return EOUTOFMEM;
    res = Do_SMB ( hS, SMBsesssetup, 12, pB, NULL );
  }
  else {
    /* Server does not support extended security */
    SMB_TxWords[7] = strlen ( passwd );
    SMB_TxWords[8] = 0;
    SMB_TxWords[9] = SMB_TxWords[10] = 0; /* Reserved */
    SMB_TxWords[11] = SMB_TxWords[12] = 0; /* client capabilities */
    pB = AddChain(pB, "CIFS", sizeof("CIFS"));
    if (pB) pB = AddChain(pB, "\0RISCOS", sizeof("\0RISCOS"));
    if (pB) pB = AddChain(pB, userid, strlen(userid) + 1);
    if (pB) pB = AddChain(pB, passwd, strlen(passwd));
    if (pB) pB = DumpChain(pB);
// FreeChain(pB); return EOUTOFMEM;
    if (pB == NULL)
      return EOUTOFMEM;
    res = Do_SMB ( hS, SMBsesssetup, 13, pB, NULL );
  }
a1054 1
      hS->blob = 0;
d1076 1
a1076 1
      hS->t2flags = 0;
a1140 4
  if (hS->flags != FREE) {
    free(hS->blob);
    hS->blob = NULL;
  }
d1221 1
a1221 1
  if (e == OK && (hS->t2flags & T2FLAGS_LONGNAMES)) return true;
d1590 1
a1590 1
/* Some Microsoft servers not sending them in the documented order */
a1608 58
  if (!(hS->t2flags & T2FLAGS_TESTEDSWAP)) {
    /* Need to test whether we have to swap the date/time fields */
    char fnbuffer[8];
    DOS_ATTRIBS aattrbuf;
    hS->t2flags |= T2FLAGS_TESTEDSWAP;
    fnbuffer[0] = *filename;
    fnbuffer[1] = ':';
    fnbuffer[2] = '\\';
    fnbuffer[3] = '\0';
    debug1("Looking up `%s' to test buffer format\n", fnbuffer);
    if (SMB_GetAttribsX2 ( hS, fnbuffer, &aattrbuf ) == OK) {
      fnbuffer[3] = '\0';
      fnbuffer[4] = '\0';
      Transact_init(&tp, 6 * 2);           /* will accept 6 WORD return params */
      Transact_addsetupword(&tp, TRANSACT2_FINDFIRST);
      Transact_addword(&tp, ATTR_DIR);     /* findfirst_Attribute */
      Transact_addword(&tp, 1);            /* findfirst_SearchCount */
      Transact_addword(&tp, 0);            /* findfirst_flags */
      Transact_addword(&tp, 1);            /* Search level  */
      Transact_addlong(&tp, 0L);           /* reserved, MBZ */
      Transact_addstring(&tp, fnbuffer+2); /* findfirst_FileName[] */
      debug1("Looking for `%s'\n", fnbuffer+2);
      res = SMB_Transact2(hS, &tp);
      if (res == OK) {
        debug0("SMB_Transact2 worked\n");
        SMB_TxWords[0] = Transact_getword(tp.parms_out_buf);
        if (Transact_getword(tp.parms_out_buf + 2) == 1) {
          DOS_ATTRIBS sattrbuf;
          debug1("Filename was `%s'\n", tp.data_out_buf + 23);
          res = Xlt_ExpandSearchEntryX2 ( tp.data_out_buf, NULL, NULL, &sattrbuf, NULL);
          if (res == OK) {
            if (sattrbuf.utime != aattrbuf.utime) {
               debug0("Need to swap date/time!\n");
               hS->t2flags |= T2FLAGS_SWAPDATETIME;
               swap_time_date(tp.data_out_buf);
               swap_time_date(tp.data_out_buf+4);
               swap_time_date(tp.data_out_buf+8);
               Xlt_ExpandSearchEntryX2 ( tp.data_out_buf, NULL, NULL, &sattrbuf, NULL);
               if (sattrbuf.utime != aattrbuf.utime) {
                 debug0("Didnt get the right thing anyway\n");
               }
               else {
                 debug0("Tested and verified!\n");
               }
            }
            else {
               debug0("Don't need to swap date/time!\n");
            }
          }
        }
      	(void) Do_SMB(hS, SMBfindclose2, 1, NULL, NULL);
      }
      else {
        debug0("SMB_Transact2 failed\n");
      }
    }
  }

d1620 1
a1620 2
   * and dates of the file before calling Xlt to expand them ... but only
   * if the remote server has this bug.
d1622 3
a1624 5
  if (hS->t2flags & T2FLAGS_SWAPDATETIME) {
    swap_time_date(tp.data_out_buf);
    swap_time_date(tp.data_out_buf+4);
    swap_time_date(tp.data_out_buf+8);
  }
d1677 1
a1677 1
  if (hS->t2flags & T2FLAGS_LONGNAMES)
d2018 1
a2018 1
  if (SearchDrive->t2flags & T2FLAGS_LONGNAMES)
d2582 1
a2582 2
  int iter = 0; /* Response iteration number */
  int a = SMBHDR_SIZE + ((14 + pT->setup_in_len)*2) + 2;
a2588 1
  int   tot_data_rcvd = 0, tot_param_rcvd = 0;
d2653 1
a2653 3
  /* Now extract results - note that there may be 1 of these.  OTOH, there may be several
   * if the data didn't fit into the negotiated buffer sizes ... */
  for (iter = 0; ; ++iter) {
d2655 6
a2660 5
    if ( SMB_RxWordCount < 10 )
    {
      FreeChain(pBres);
      return EDATALEN;
    }
d2662 3
a2664 11
    a = SMBHDR_SIZE + (SMB_RxWordCount)*2 + 2;
    /* Size of SMBHDR plus returned rx words plus byte count
       = offset of data in pBres from start of header */

    if (iter == 0) {
      /* First response will tell us how much is coming */
      pT->parms_out_len = min(SMB_RxWords[0], pT->parms_out_maxlen);
                              /* Parm bytes being returned */
      pT->data_out_len  = min(SMB_RxWords[1], pT->data_out_maxlen);
                              /* Data bytes being returned */
      pT->setup_out_len = min(SMB_RxWords[9] & 0xFF, pT->setup_out_maxlen);
d2666 6
a2671 6
      /* setup words must come in the first packet */
      if (pT->setup_out_len > 0 )          /* Get setup_out */
      {
        memcpy(pT->setup_out, &SMB_RxWords[14], 2 * pT->setup_out_len);
      }
    }
d2673 5
a2677 4
    if ( pT->parms_out_len > 0 && SMB_RxWords[3])         /* Get parms_out */
    {
      padbytes = SMB_RxWords[4] - a;     /* RxWords[4] is offset;
                                            Get number of pad bytes */
d2679 4
a2682 6
      if ( padbytes > 0 )
        pBres = GetData(pBres, NULL, padbytes);
      pBres = GetData(pBres, pT->parms_out_buf + SMB_RxWords[5], SMB_RxWords[3]);
      a += padbytes + pT->parms_out_len; /* New offset value */
      tot_param_rcvd += SMB_RxWords[3];
    }
d2684 4
a2687 10
    if ( pT->data_out_len > 0 && SMB_RxWords[6] > 0)        /* Get data_out */
    {
      padbytes = SMB_RxWords[7] - a;     /* Number of pad bytes */
      if ( padbytes > 0 )
        pBres = GetData(pBres, NULL, padbytes);
      pBres = GetData(pBres, pT->data_out_buf + SMB_RxWords[8], SMB_RxWords[6]);
      tot_data_rcvd += SMB_RxWords[6];
      if (pT->setup_in[0] == TRANSACT2_QUERYPATHINFORMATION)
        DumpBuffer(pT->data_out_buf, pT->data_out_len);
    }
d2689 5
a2693 4
    if ( pBres == NULL ) {  /* Oh no! Techo fear! */
      debug0("SMB_Transact2: pBres was NULL\n");
      return EDATALEN;
    }
d2695 9
a2703 1
    FreeChain(pBres);
d2705 3
a2707 8
    if (tot_data_rcvd < pT->data_out_len || tot_param_rcvd < pT->parms_out_len) {
      res = Do_SMBResponse(hS, SMBtrans2, &pBres);
      if (res != OK)
        return res;
      /* Extract received data */
      debug1("Transact2 (2ndary response) - returned %d bytes\n", ChainLen(pBres));
    }
    else break;
d2710 1
@


1.1.1.1.2.5
log
@  Fixed most dodgy pathname problems.
  All *LM... commands are now filing system commands.
  *Connect and *Disconnect renamed to *LMConnect and *LMDisconnect.
Detail:
  When translating RISC OS to DOS filenames, a loop could develop if
    any path component contained a dodgy character.  This is now fixed
    with the exception of problems when both < and > characters appear
    in pathnames since that confuses FileSwitch.  New mappings will be
    need to be agreed for these characters (and remappings for $ and %
    which overload < and > respectively)
  All *LM... commands are now filing system commands, which means that
    you need to prefix them with LanMan: unless LanManFS is the current
    filesystem (following spec review).
  *Connect and *Disconnect renamed to *LMConnect and *LMDisconnect
    (following spec review).
  Trace builds allow "*LanMan:LMNameMode 4" to enable display of system
    and hidden files on the remote filesystem.
Admin:
  Tested briefly against Windows 98 and Windows NT 4 SP3.
  If a directory name contains a dodgy character, repeated searches will
    be made on the remote filesystem.  This is inefficient and a name
    cache would alleviate this.  There is no name cacheing in the current
    version.

Version 1.87, 1.1.1.1.2.9. Tagged as 'LanManFS-1_87-1_1_1_1_2_9'
@
text
@d87 3
a92 3
#include "lmvars.h"
#include "attr.h"   /* For InvalidateDrive */
#include "xlate.h"  /* For string functions */
d242 1
d320 1
a1845 4
    if (LM_Vars.namemode & 4) {
      Transact_addword(&tp, ATTR_DIR | ATTR_SYS | ATTR_HID);     /* findfirst_Attribute */
    }
    else {
a1846 1
    }
d2097 7
d2126 1
a2126 2
                               ENUM_DIR_FN dirfn, void *private,
                               struct Transact2_SearchContext *con )
d2128 4
d2143 1
a2143 1
  if (path != NULL && con->t1.NextSearchOK == true || count < 0) {
d2148 2
a2149 2
       path, con->t1.NextSearchOK, count);
     (void) SMB_AbandonFind2( hS, con->dir_handle );
d2152 1
a2152 1
  con->t1. NextSearchOK = false;
d2162 1
a2162 1
    con->resume_key = 0;
d2164 9
a2172 14
    Transact_init(&con->tp, 6 * 2);           /* will accept 6 WORD return params */
    Transact_addsetupword(&con->tp, TRANSACT2_FINDFIRST);
    if (LM_Vars.namemode & 4) {
      Transact_addword(&con->tp, ATTR_DIR | ATTR_SYS | ATTR_HID);     /* findfirst_Attribute */
    }
    else {
      Transact_addword(&con->tp, ATTR_DIR);   /* findfirst_Attribute */
    }
    Transact_addword(&con->tp, count);        /* findfirst_SearchCount */
    Transact_addword(&con->tp, first_flags);  /* findfirst_flags */
    Transact_addword(&con->tp, 1);            /* Search level  */
    Transact_addlong(&con->tp, 0L);           /* reserved, MBZ */
    Transact_addstring(&con->tp, path+2);     /* findfirst_FileName[] */
    res = SMB_Transact2(hS, &con->tp);
d2175 3
a2177 3
    p = con->tp.parms_out_buf;
    con->dir_handle = Transact_getword(p); p += 2;
    debug1("SID = 0x%04hx\n", con->dir_handle);
d2182 9
a2190 9
    Transact_init(&con->tp, 4 * 2);           /* will accept 4 WORD return params */
    Transact_addsetupword(&con->tp, TRANSACT2_FINDNEXT);
    Transact_addword(&con->tp, con->dir_handle);   /* findnext_DirHandle */
    Transact_addword(&con->tp, count);        /* findnext_SearchCount */
    Transact_addword(&con->tp, 1);            /* Search level  */
    Transact_addlong(&con->tp, con->resume_key);   /* Resume key from previous */
    Transact_addword(&con->tp, next_flags);   /* findnext_flags */
    Transact_addstring(&con->tp, con->last_filename); /* resumption filename */
    res = SMB_Transact2(hS, &con->tp);
d2193 1
a2193 1
    p = con->tp.parms_out_buf;
d2204 1
a2204 1
    ptr_last_filename = (char *) con->tp.data_out_buf + lastname;
d2211 1
a2211 1
  p = con->tp.data_out_buf;
d2241 1
a2241 1
         (void) SMB_AbandonFind2( hS, con->dir_handle );
d2245 1
a2245 1
         con->t1.NextSearchOK = true;
d2251 1
a2251 1
       con->resume_key = next_resume_key;
d2253 2
a2254 2
       (void) strncpy(con->last_filename, ptr_last_filename?ptr_last_filename:"",
         sizeof(con->last_filename));
d2262 1
a2262 1
        debug1("Resume key is 0x%08x; ", con->resume_key);
d2264 2
a2265 2
      debug1("Next filename is `%s'\n", con->last_filename);
      con->t1.NextSearchOK = true;
d2271 1
a2271 1
          con->t1.NextSearchOK = false;
d2274 1
a2274 1
  return con->t1.NextSearchOK ? OK : ENOMOREFILES;
d2279 1
a2279 1
                               ENUM_DIR_FN dirfn, void *private, Transact_SearchContext *conp )
a2284 2
  static Transact_SearchContext rde_context;
  struct Transact1_SearchContext *con;
a2285 1
  con = (conp == NULL) ? &rde_context.t1 : &conp->t1;
d2290 2
a2291 2
    con->SearchDrive = GetShare(path, &res);
    if ( con->SearchDrive == NULL )
d2296 1
a2296 1
    if ( !con->NextSearchOK || con->SearchDrive == NULL )
d2301 1
a2301 1
  if (con->SearchDrive->t2flags & T2FLAGS_LONGNAMES)
d2303 1
a2303 2
     struct Transact2_SearchContext *const t2sc = (conp == NULL) ? &rde_context.t2 : &conp->t2;
     return SMB_ReadDirEntriesX2(con->SearchDrive, path, count, dirfn, private, t2sc);
d2322 1
a2322 1
    pB = MkDataBlock (NULL, DATA_VARBLK, con->SearchState,
d2335 1
a2335 1
  con->NextSearchOK = false;
d2337 1
a2337 1
  res = Do_SMB ( con->SearchDrive, SMBsearch, 2, pB, &pBres );
d2356 2
a2357 2
      con->NextSearchOK = true;
      memcpy ( con->SearchState, entry, SEARCH_ST_SIZE );
d2363 1
a2363 1
  return con->NextSearchOK ? OK : ENOMOREFILES;
@


1.1.1.1.2.6
log
@  End of week checkin.  No bug fixes.  Some performance improvements.
Detail:
  Added a basic name cacheing facility.  For safety this is flushed
    every time the module returns to FileSwitch.  This does at least
    help reduce the name of directory searches required during a
    name translation.  NameCache.c comes with a test program built-in
    for stressing the cache manager.
Admin:
  Free space display doesn't work yet.
  Anti-idleout measures not implemented yet.

Version 1.87, 1.1.1.1.2.10. Tagged as 'LanManFS-1_87-1_1_1_1_2_10'
@
text
@a88 1
#include "NameCache.h" /* for the directory entry cache */
a1826 1
  BYTE *resb;
a1828 7
  resb = NameCache_Locate(filename);
  if (resb != NULL) {
    memcpy( tp.data_out_buf, resb, 23);
    strcpy( (char *) tp.data_out_buf + 23, (char *) resb + 23);
    return Xlt_ExpandSearchEntryX2 ( tp.data_out_buf, NULL, NULL, pAttr, NULL);
  }

a3090 3
#endif
#ifdef LONGNAMES
  NameCache_Init();
@


1.1.1.1.2.7
log
@  Boot behaviour fixes.
  More debug added.
Detail:
  Trapped Service_InternetStatus reason code 0 as a tipoff to try
    to continue a pending boot operation.  Internet module is not
    sending the expected reason code 2 to indicate that the interface
    has come up when it is also having its address changed.
  Holding down SHIFT when a new connection is made prevents execution
    of !ArmBoot on the newly connected share.
  Several more debug statements added to track progress through the
    booting.
  IPConfig's internal logging system imported.  *LanMan:Free shows
    the contents of the log.
  Free space information still seems to be broken against Windows 95/98.
    Works against NT4SP4 though.
  *Free filesystem-specific command added.
Admin:
  This version managed to boot an STB22 from our NT4 server which
    was supplying it with baseline 303.
  *LanMan:Free is not yet implemented and in debug builds, shows
     the debug log instead.
  Anti-idleout work still pending.

Version 1.87, 1.1.1.1.2.11. Tagged as 'LanManFS-1_87-1_1_1_1_2_11'
@
text
@a1180 1
  debug0("NB_FormatName..\n");
a1186 1
  debug0("NB_OpenSession..\n");
a1192 1
  debug0("SMB_Negotiate..\n");
a1201 1
  debug0("SMB_SessSetup..\n");
a1207 2
  debug0("ConnectServer succeeds\n");

a1557 4
#ifdef TRACE
  debug2("Server name %p; share name %p\n", servname_in, sharename_in);
  debug2("Server name `%s'; share name `%s'\n", servname_in, sharename_in);
#endif
@


1.1.1.1.2.8
log
@  Free space now 64-bit aware plus *-command implemented.
  Anti-idleout measures implemented.
  Boot behaviour sanitised.
Detail:
  Free space code now knows about 64-bit versions of the various
    calls that can be made to it (OS_FSControl and Free module's i/f)
  *Free implemented.
  CallEvery set up to periodically ping each share to stop buggy
    Microsoft servers going to sleep on it.
  The filesystem does not get deregistered from FileSwitch whenever
    any interface on the machine changes(!)   More subtle changes
    are still required to finalise things in this area though.
Admin:
  Requires TCPIPLibs 5.06 or later
    (CVS: RiscOS/Sources/Libs/TCPIPLibs  tag: TCPIPLibs-5_06)
  Tested by booting an STB22 against an NT4SP4 machine.

Version 1.87, 1.1.1.1.2.12. Tagged as 'LanManFS-1_87-1_1_1_1_2_12'
@
text
@a231 1
#define TRANSACT2_QUERYFSINFORMATION 0x03
d691 2
a692 1
static err_t Do_SMB_threadsafe ( hSHARE hS, int cmd, int wct_in, BUFCHAIN pB_in,
a785 17
static err_t Do_SMB ( hSHARE hS, int cmd, int wct_in, BUFCHAIN pB_in,
                      BUFCHAIN *ppB_out )
{
  static volatile int threaded = 0;

  if (threaded) {
    return EBOOTREENTRY;
  }
  else {
     err_t res;
     ++threaded;
     res = Do_SMB_threadsafe(hS, cmd, wct_in, pB_in, ppB_out);
     --threaded;
     return res;
  }
}

d1438 16
a1467 17

/* ---------------------------- */

/* SMB_IsLongNameFS() returns true if the path refers to a share which is using long
    filenames.  Xlate.c needs to know this in order to determine which set of file
    mappings is to be used.
 */
bool SMB_IsLongNameFS( const char * path)
{
  hSHARE hS;

  hS = GetShareNoConn(*path);
  if (hS != NULL && (hS->t2flags & T2FLAGS_LONGNAMES)) return true;
  return false;
}


a2094 36
#ifdef LONGNAMES
static err_t SMB_GetFreeSpaceX2 ( hSHARE hS, struct disk_size_response *pDSR  )
{
  err_t res;
  static struct TransactParms tp;
  BYTE *p;
  DWORD sectors_per_alloc, total_allocs, total_avail_allocs;
  WORD bytes_per_sector;

  Transact_init(&tp, 1 * 2);
  Transact_addsetupword(&tp, TRANSACT2_QUERYFSINFORMATION);
  Transact_addword(&tp, 1);  /* information level */
  res = SMB_Transact2(hS, &tp);
  if (res != OK)
    return res;
  p = tp.data_out_buf + 4;
  sectors_per_alloc = Transact_getlong(p), p += 4;
  total_allocs = Transact_getlong(p), p += 4;
  total_avail_allocs = Transact_getlong(p), p += 4;
  bytes_per_sector = Transact_getword(p);

  pDSR->blksize = bytes_per_sector * sectors_per_alloc;
  pDSR->freeblks =  total_avail_allocs;
  pDSR->totalblks = total_allocs;

  /*
  debug2("S/A %10d %#08x\n", sectors_per_alloc, sectors_per_alloc);
  debug2("T A %10d %#08x\n", total_allocs, total_allocs);
  debug2("TAA %10d %#08x\n", total_avail_allocs, total_avail_allocs);
  debug2("B?S %10d %#08x\n", (DWORD) bytes_per_sector, (DWORD) bytes_per_sector);
  */

  return OK;
}
#endif

a2103 7
#ifdef LONGNAMES
  if (hS->t2flags & T2FLAGS_LONGNAMES)
  {
    return SMB_GetFreeSpaceX2(hS, pDSR);
  }
#endif

a3128 25
}

/* ---------------------------- */

/* SMB_AntiIdle() is used to stop idle-outs on shares.
 * Each call, it moves onto the next share in order to
 * "ping" the server to keep it awake.
 */
void SMB_AntiIdle ( void )
{
  static uint letter = -1;
  hSHARE hS;

  ++letter;
  if (letter >= MAX_SHARES) letter = 0;
  hS = GetShareNoConn('A' + letter);
  if (hS == NULL) {
    return;
  }
  else {
    char echodat[4];
    sprintf(echodat, "%c:\\", 'A' + letter);
    debug1("Anti idle-out measure: %s\n", echodat);
    (void) SMB_ChkPath(echodat);
  }
@


1.1.1.1.2.9
log
@  Added multiple boot server capability.
  Decreased timeout on anti-idle trap.
  Removed obsolete header file.
Detail:
  Multiple boot server capability added,  Uses Inet$ServerName2 (and ..3
    etc.) until a connection to a share is made.  Use boot mount path
    in BOOTP/DHCP responses to set this variable.
  Using the standard 40 second timeout is silly on the anti-idle trap.
    Now uses a 4 second timeout and ignores errors.  Any later replies
    will be discarded automatically when the next transaction is made.
  DCI4.h is obsolete - TCPIPLibs:sys/dcistructs.h has been used for
    ages instead.
Admin:
  Tested in STB22.  Boots from backup boot server when given a silly
    name for the primary.

Version 1.87, 1.1.1.1.2.13. Tagged as 'LanManFS-1_87-1_1_1_1_2_13'
@
text
@d629 1
a629 1
  res = NB_GetData ( hS->hServer->hSession, &pB_rx, cmd == SMBchkpth ? 400 : REPLY_TIMEOUT );
@

head	1.10;
access;
symbols
	LanManFS-2_62:1.10
	LanManFS-2_61:1.10
	LanManFS-2_60:1.10
	LanManFS-2_59:1.10
	LanManFS-2_58:1.10
	LanManFS-2_57:1.10
	LanManFS-2_56:1.10
	LanManFS-2_55:1.10
	LanManFS-2_54:1.10
	LanManFS-2_53:1.10
	LanManFS-2_52:1.10
	LanManFS-2_51:1.10
	LanManFS-2_50:1.10
	LanManFS-2_49:1.10
	LanManFS-2_48:1.10
	LanManFS-2_47:1.10
	LanManFS-2_46:1.10
	LanManFS-2_45:1.10
	LanManFS-2_44:1.10
	LanManFS-2_43:1.10
	LanManFS-2_42:1.10
	LanManFS-2_41:1.10
	LanManFS-2_40:1.9
	LanManFS-2_39:1.8
	LanManFS-2_38:1.8
	LanManFS-2_37:1.7
	LanManFS-2_36:1.7
	LanManFS-2_35:1.7
	LanManFS-2_34:1.7
	LanManFS-2_33:1.6
	LanManFS-2_32:1.6
	LanManFS-2_31:1.5
	RO_5_07:1.5
	LanManFS-2_30:1.5
	LanManFS-2_29:1.5
	LanManFS-2_28:1.5
	LanManFS-2_27:1.5
	LanManFS-2_26:1.5
	LanManFS-2_25:1.5
	LanManFS-2_24:1.5
	LanManFS-2_23:1.5
	LanManFS-2_22:1.5
	LanManFS-2_21:1.5
	LanManFS-2_20:1.5
	LanManFS-2_19:1.5
	LanManFS-2_18:1.5
	LanManFS-2_17:1.4
	LanManFS-2_16:1.4
	LanManFS-2_15:1.4
	LanManFS-2_14:1.4
	LanManFS-2_13:1.3
	LanManFS-2_12:1.2
	LanManFS-2_11:1.2
	LanManFS-2_10:1.2
	LanManFS-2_09:1.2
	LanManFS-2_08:1.2
	LanManFS-2_07:1.2
	LanManFS-2_06:1.2
	LanManFS-2_05:1.2
	LanManFS-2_04:1.2
	LanManFS-2_03:1.2
	LanManFS-2_02:1.2
	LanManFS-2_01:1.2
	LanManFS-2_00:1.2
	LanManFS-1_87-1_1_1_1_2_13:1.1.1.1.2.3
	LanManFS-1_87-1_1_1_1_2_12:1.1.1.1.2.3
	LanManFS-1_87-1_1_1_1_2_11:1.1.1.1.2.3
	LanManFS-1_87-1_1_1_1_2_10:1.1.1.1.2.3
	LanManFS-1_87-1_1_1_1_2_9:1.1.1.1.2.3
	LanManFS-1_87-1_1_1_1_2_8:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_7:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_6:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_5:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_4:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_3:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_2:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_1:1.1.1.1.2.1
	sbrodie_LanManFS_dev:1.1.1.1.0.2
	sbrodie_LanManFS_dev_bp:1.1.1.1
	LanManFS-1_87:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.10
date	2013.10.03.07.46.13;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	BeiPxSOMs39oTO7x;

1.9
date	2013.10.03.07.27.08;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	iTaBDwF1woaPMO7x;

1.8
date	2012.11.11.20.43.15;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	3D5DE5lr2isCFZrw;

1.7
date	2009.08.01.08.10.27;	author rsprowson;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.15.16.00.08;	author bavison;	state Exp;
branches;
next	1.5;
commitid	GhZBwZ2GN8lg58Kt;

1.5
date	2001.01.15.12.49.48;	author sbrodie;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.11.15.55.01;	author sbrodie;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.08.15.50.16;	author sbrodie;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.12.52.06;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	98.12.03.13.54.45;	author sbrodie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.12.03.13.54.45;	author sbrodie;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	98.12.04.11.37.33;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	99.01.19.14.24.46;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.02.03.12.51.36;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Removed verbose mode
With LanManFS in ROM it's not actually possible to enable verbose mode, since it relies on command arguments being passed to it on initialisation. Since RMREINIT doesn't allow that you can't ever pass '-v'. Even the RAM loaded case isn't that useful, since the verbose text is output via printf() which doesn't appear in the desktop (with OmniClient).
Swap the few uses of verbose mode to route via DebugLib instead, controlled via the 'DEBUG' predefine.
Also
  Makefile ammended so debug version has a rule to make the resources area.
Built, but not tested.

Version 2.41. Tagged as 'LanManFS-2_41'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
*
*  NETBIOS.C  -- NetBIOS name-service functions
*
*  14-02-94 INH  Original
*                AcksNeeded altered
*
*
*/

/* Standard includes */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "kernel.h"

/* Our includes */

#ifndef NO_NETBEUI

#include "stdtypes.h"
#include "LanMan.h"
#include "BufLib.h"
#include "Stats.h"
#include "LLC.h"
#include "NetBIOS.h"
#include "LMVars.h"

#define EXPORT static

/* Timeouts ************ */

#define ADD_NAME_TIME     50
#define ADD_NAME_TRIES     3
#define FIND_NAME_TIME    50
#define FIND_NAME_TRIES    5
#define OPEN_SESS_TIME  1000
#define ACK_SEND_TIME     50   /* Timeout before sending ACK */
#define ACK_WAIT_TIME   1000   /* Time to wait for ACK before failing */


/* Frame types ***************** */

#define ADD_GROUP_NAME_QUERY 0x00
#define ADD_NAME_QUERY       0x01
#define NAME_IN_CONFLICT     0x02
#define STATUS_QUERY         0x03
#define DATAGRAM             0x08
#define DATAGRAM_BROADCAST   0x09
#define NAME_QUERY           0x0A
#define ADD_NAME_RESPONSE    0x0D
#define NAME_RECOGNISED      0x0E
#define STATUS_RESPONSE      0x0F
#define DATA_ACK             0x14
#define DATA_FIRST_MIDDLE    0x15
#define DATA_ONLY_LAST       0x16
#define SESSION_CONFIRM      0x17
#define SESSION_END          0x18
#define SESSION_INITIALISE   0x19
#define NO_RECEIVE           0x1A
#define RECEIVE_OUTSTANDING  0x1B
#define RECEIVE_CONTINUE     0x1C
#define SESSION_ALIVE        0x1F

#define NETBIOS_SAP 0xF0

/* Private structures / definitions ************ */

/* ---------------- */

struct status_resp  /* Structure used to process STATUS_RESPONSE */
{
  int    nt_search;           /* Name-type to respond to */
  struct FindName_res *pRes;  /* Pointer to result buf */
  int    spaces_left;         /* Space left in result buf */
};


/* Entries in name table: datagram-type packets come from and and
   directed at these names */

/* Status values */

#define NS_FREE      0
#define NS_AWAIT_ADD 1
#define NS_NAME_OK   2
#define NS_ADD_FAIL  4
#define NS_RECEIVING 8   /* Able to receive datagrams */

struct _NBsession; /* ... is coming up soon */

typedef struct
{
  int       Status;
  NETNAME   Name;

  struct _NBsession  *pS_call;   /* For when we're calling & awaiting
                                   reply from far end */
  struct _NBsession  *pS_listen; /* For when we're waiting for a call
             	    		   from someone else */

  struct status_resp *pStatResp;  /* Status-response state */

  BUFQUEUE  DatagramQ;            /* Queue for incoming datagrams */
}
  NAME_ENTRY;

/* Entry in session table: there is one session for each connection
   between us and another end */

#define SS_FREE         0
#define SS_CALLING      1  /* Calling far end */
#define SS_CALL_WAIT    2  /* Done NAME_RESPONSE, await LLC connect */
#define SS_LISTENING    4  /* Waiting for call from far end */
#define SS_LISTEN_RDY   8  /* Done NAME_QUERY, ready for LLC connect */
#define SS_CONNECTED    16 /* Connected */


typedef struct _NBsession
{
  /* General session state */
  int         Status;

  NAME_ENTRY *LclName;       /* Local name at this end */
  int         LclLSN;

  NETADDR     RmtAddr;       /* Address of far end */
  NETNAME     RmtName;       /* Name at far end */
  int         RmtLSN;

  HCONN       hconn;          /* LLC connection handle */

  /* Connection/sequencing status */
  int         xmitsize;       /* Max transmit size in one pkt */
  BUFCHAIN    PartialRcv;     /* Used for assembling larger pkts */
  BUFQUEUE    RcvQ;           /* Complete receive messages */
  int         next_resp;      /* Next 'response' value to use */
  int         next_xmit;      /* Next 'xmit' value to send */
  bool        ack_pending;    /* True if we need to send data ack */
  struct Timer AckTimer;      /* Timer for sending DATA_ACK */
  bool        ack_required;   /* True if we should wait for DATA_ACK
                                   before sending any more data */
} NBSESSION;


/* ------------------------------------ */

/* Note: These structures are sailing reasonably close to the
   wind by assuming that the compiler will pack the BYTEs and
   WORDs properly. All groups of bytes, 16-bit words and
   network names do start on longword boundaries, so it isn't
   technically incorrect.
*/
typedef struct
{
  WORD len;
  WORD delim;

  BYTE cmd;
  BYTE opt1;
  BYTE opt2lo;
  BYTE opt2hi;

  WORD resp;
  WORD xmit;

  BYTE dst_sn;       /* Remote session number */
  BYTE src_sn;       /* Local session  number */
}
  NB_SHORTHDR;

typedef struct
{
  WORD len;
  WORD delim;

  BYTE cmd;
  BYTE opt1;
  BYTE opt2lo;
  BYTE opt2hi;

  WORD resp;
  WORD xmit;

  NETNAME dst_name;       /* Remote session number */
  NETNAME src_name;       /* Local session  number */
}
  NB_LONGHDR;

/* Globals =========================================== */

static NETADDR Multi_Addr = { 0x03, 0x00, 0x00, 0x00, 0x00, 0x01 };

#define MAX_NAMES 16
static NAME_ENTRY NB_NameTable[MAX_NAMES];

#define MAX_SESSIONS 16
static NBSESSION NB_SessionTbl[MAX_SESSIONS];

static NB_SHORTHDR SHdr;
static NB_LONGHDR  LHdr;
static int NB_MaxSize;

/* Support functions ======================================== */

#ifdef DEBUG
static void debug_name ( NETNAME *nn )
{
  char lclbuf[17];
  memcpy (lclbuf, nn, 16);
  lclbuf[16] = 0;
  debug1("<%s>", lclbuf);
}
#else
#define debug_name(a)
#endif

/* ----------------- */

static NBSESSION *LSNtoSession (int LSN)
{
  if ( LSN <= 0 || LSN > MAX_SESSIONS ) return NULL;

  return &NB_SessionTbl [LSN-1];
}

/* ----------------- */

static NAME_ENTRY *ValidatehName( hNAME hName )
{
  NAME_ENTRY *pN = (NAME_ENTRY *)hName;
  if ( pN != NULL && pN->Status == NS_NAME_OK )
    return pN;

  return NULL;
}
/* ----------------- */

static NBSESSION *ValidatehSession( hSESSION hSess )
{
  NBSESSION *pN = (NBSESSION *)hSess;
  if ( pN != NULL && pN->Status == SS_CONNECTED )
    return pN;

  return NULL;
}

/* Exported procedures ------------------------------------ */

EXPORT bool _NB_LinkOK ( hSESSION hS )
{
  NBSESSION *pN = (NBSESSION *)hS;
  return (bool) ( pN != NULL && pN->Status == SS_CONNECTED &&
             LLC_LinkOK (pN->hconn) );
}

/* -------------------- */

EXPORT bool _NB_MatchName ( NETNAME *nn1, NETNAME *nn2 )
{
  return (bool) ( nn1->c4[0] == nn2->c4[0] &&
           nn1->c4[1] == nn2->c4[1] &&
           nn1->c4[2] == nn2->c4[2] &&
           nn1->c4[3] == nn2->c4[3] );
}

/* -------------------- */

static NAME_ENTRY *FindName ( NETNAME *nn, int flags )
{
  int i;

  if ( flags == NS_FREE )
  {
    for ( i=0; i < MAX_NAMES; i++ )
      if ( NB_NameTable[i].Status == NS_FREE )
        return &NB_NameTable[i];
  }
  else
  {
    for ( i=0; i < MAX_NAMES; i++ )
      if ( (NB_NameTable[i].Status & flags) != 0    &&
           _NB_MatchName ( nn, &NB_NameTable[i].Name ) )
        return &NB_NameTable[i];
  }

  return NULL;
}

/* --------------------- */

EXPORT err_t _NB_FormatName ( nametype_t nt, char *name, NETNAME *res )
{
  int i;

  for ( i=0; i<15; i++)
  {
    if ( name[i] < 0x20 ) break;
    if (name[i] == '\xA0') res->b[i] = ' ';
    else res->b[i] = toupper(name[i]);
  }

  while (i<15)
    res->b[i++] = 0x20;

  res->b[15] = nt;
  return OK;
}

/* --------------------- */

EXPORT nametype_t _NB_DecodeName ( NETNAME *pnn, char *buf )
{
  BYTE *p = pnn->b;
  char *last_nonsp = buf;
  int i;

  for (i=0; i<15 && *p >= 0x20; ++i)
    *buf++ = *p++;

  *buf = 0;

  while (--buf > last_nonsp) {
    if (*buf == ' ') *buf = 0;
  }

  return (nametype_t) (pnn->b[15]);
}

/* ----------------------- */

static void SendDatagram (int Cmd, NETADDR *pnaDest,
        NETNAME *pnnDest, NETNAME *pnnSource, int Opt1, int Opt2,
        int Resp )
{
  BUFCHAIN pB;

  debug1("SendDatagram called: command %x\n",Cmd);

  LHdr.len   = 0x002C;
  LHdr.delim = 0xEFFF;
  LHdr.cmd   = Cmd;
  LHdr.opt1  = Opt1;
  LHdr.opt2lo= Opt2 & 0xFF;
  LHdr.opt2hi= Opt2 >> 8;
  LHdr.resp  = Resp;
  LHdr.xmit  = 0;
  if ( pnnSource != NULL )
    LHdr.src_name  = *pnnSource;
  if ( pnnDest != NULL )
    LHdr.dst_name  = *pnnDest;

  pB = AddChain ( NULL, &LHdr, 0x2C );
  if ( pB != NULL )
    UI_SendData ( pnaDest, NETBIOS_SAP, pB );
}

/* ----------------------- */

static void ProcessStatusResp ( struct status_resp *pSR,
   int nnames, BUFCHAIN pData )
{
  BYTE buf[18];

  /* Strip off header */
  pData = GetData ( pData, NULL, 0x3C );

  while ( pSR->spaces_left > 0 &&
          nnames -- > 0 )
  {
    pData = GetData ( pData, buf, 0x12 );
    if ( pData == NULL ) break;

    if ( pSR->nt_search == ANY_NAME_TYPE ||
         pSR->nt_search == buf[15] )
    {
      memcpy ( &(pSR->pRes->name), buf, 16 );
      pSR->pRes->type = (nametype_t) buf[15];
      pSR->pRes->flags = buf[17];
      pSR->spaces_left--;
      pSR->pRes++;
    }
  }

  FreeChain(pData);
}

/* NetBIOS name management functions ============================== */

static void NB_ReceiveDatagram ( NETADDR *src, BUFCHAIN Data, void *pw )
{
  NAME_ENTRY *pDN;
  static NB_LONGHDR  RLHdr;

  (void) pw;

  /* Read in header & check format */

  Data = GetData ( Data, &RLHdr, 0x2C );
  if ( Data == NULL )
    return;

  if ( RLHdr.len != 0x2C || RLHdr.delim != 0xEFFF )
    goto DumpIt;

  /* Deal with command */

  switch ( RLHdr.cmd )
  {
    case DATAGRAM:
    case DATAGRAM_BROADCAST:
      pDN = FindName ( &RLHdr.dst_name, NS_NAME_OK );
      if ( pDN != NULL && (pDN->Status & NS_RECEIVING) )
      {
        /* This facility is currently unused by the rest of
           LanManFS. In fact just sticking 'Data' in a queue
           is a pretty poor way of doing it, because we don't
           carry the name of the sender of the data along with
           us. */
        QueueAdd( &(pDN->DatagramQ), Data );
        return;  /* Don't need to free chain! */
      }

      break;

    case NAME_QUERY:  /* Trying to call us */
      pDN = FindName ( &RLHdr.dst_name, NS_NAME_OK );
      if ( pDN != NULL && pDN->pS_listen != NULL )
      {
        NBSESSION *pS = pDN->pS_listen;

        if ( pS->Status & SS_LISTENING )
        {
          pS->RmtAddr = *src;
          pS->RmtName = RLHdr.src_name;
          pS->RmtLSN  = RLHdr.opt2lo;

          SendDatagram ( NAME_RECOGNISED, src, &RLHdr.src_name,
                 &(pDN->Name), 0, pS->LclLSN, RLHdr.xmit );

          pS->Status = SS_LISTEN_RDY;
        } /* We don't do any more of this at present; need to
             add code to LLC to accept incoming calls */
      }
      break;

    case NAME_RECOGNISED:  /* Response to a name query */
      pDN = FindName ( &RLHdr.dst_name, NS_NAME_OK );
      if ( pDN != NULL && pDN->pS_call != NULL )
      {
        NBSESSION *pS = pDN->pS_call;

        if ( !_NB_MatchName ( &RLHdr.src_name, &pS->RmtName ) )
          break;  /* Crank call? */

        if ( pS->Status & SS_CALLING )
        {
          pS->RmtAddr= *src;
          pS->RmtLSN = RLHdr.opt2lo;  /* Copy session number */
          pS->Status = SS_CALL_WAIT;
        }
      }
      break;

    case ADD_GROUP_NAME_QUERY:  /* Does any other machine have this name? */
    case ADD_NAME_QUERY:
      pDN = FindName (&RLHdr.src_name, NS_NAME_OK | NS_AWAIT_ADD);
      if ( pDN != NULL )
        SendDatagram( ADD_NAME_RESPONSE, src, &RLHdr.src_name,
             &RLHdr.src_name, 0, 0, RLHdr.xmit ) ;
      break;

    case NAME_IN_CONFLICT:    /* Reply to ADD_NAME_QUERY: we can't use */
    case ADD_NAME_RESPONSE:   /* this name */
      pDN = FindName (&RLHdr.dst_name, NS_AWAIT_ADD);
      if ( pDN != NULL )
        pDN->Status = NS_ADD_FAIL;
      break;

    case STATUS_RESPONSE:
      pDN = FindName ( &RLHdr.dst_name, NS_NAME_OK );
      if ( pDN != NULL && pDN->pStatResp != NULL )
      {
        ProcessStatusResp ( pDN->pStatResp, RLHdr.opt1, Data );
        return;
      }
      break;

    case STATUS_QUERY:
      debug0("Status query");
      break;

    default:
      break;
  }

DumpIt:
  FreeChain ( Data );

}

/* ---------------------- */

static bool CheckNameUnique ( NAME_ENTRY *pN )
{
  int Timer;

  pN->Status = NS_AWAIT_ADD;
  SendDatagram ( ADD_NAME_QUERY, &Multi_Addr, NULL, &pN->Name, 0, 0, 0 );

  Timer = LLC_TickerTime;

  /* Wait 1 second for reply */

  do
  {
    LLC_BackgroundProcess();
    if ( pN->Status == NS_ADD_FAIL )
    {
      pN->Status = NS_FREE;
      return false;
    }
  }
  while ((LLC_TickerTime-Timer) < ADD_NAME_TIME);

  return true;
}

/* NB_AddLocalName() --------------------------------------------

   Adds a local name, and checks with the network that it is unique.
*/

EXPORT err_t _NB_AddLocalName ( nametype_t nt, char *name, hNAME *phName )
{
  NAME_ENTRY *pN;
  NETNAME  myname;
  int i;

  _NB_FormatName (  nt, name, &myname ); /* Convert to 16-byte format */

  pN = FindName ( &myname, NS_NAME_OK );
  if ( pN != NULL )
    return ENAMEEXISTS;

  pN = FindName ( NULL, NS_FREE );
  if ( pN == NULL )
    return ENOHANDLES;

  pN->Name = myname;

  for (i=0; i<3; i++)
  {
    if ( !CheckNameUnique(pN) )
    {
      debug0("  Name already exists\n");
      return ENAMEEXISTS;
    }
  }

  pN->Status  = NS_NAME_OK;
  pN->pS_call    = NULL;
  pN->pS_listen  = NULL;
  pN->pStatResp  = NULL;
  pN->DatagramQ.Head = NULL;
  pN->DatagramQ.Last = NULL;
  *phName = (hNAME) pN;

  return OK;
}

/* NB_RemoveLocalName() --------------------------------------------

   Removes a local name from the table.
   Any connections to this name get vaped!
*/
EXPORT err_t _NB_CloseSession ( hSESSION hSession ); /* Forward reference */

EXPORT err_t _NB_RemoveLocalName ( hNAME hName )
{
  int i;
  NBSESSION *pS;
  NAME_ENTRY *pN = ValidatehName(hName);

  if ( pN == NULL )
    return EBADPARAM;

  for ( i=1; i<=MAX_SESSIONS; i++ )
  {
    pS = LSNtoSession(i);
    if ( (pS->Status == SS_CONNECTED)  &&
         (pS->LclName == pN)
       )
    {
      _NB_CloseSession(pS);
    }
  }

  QueueFlush(&(pN->DatagramQ));

  pN->Status = NS_FREE;
  return OK;
}


/* NB_FindNames () ----------------------------------------- */

EXPORT int _NB_FindNames (   NETNAME *pnnFind,
                     nametype_t ntFind,
                     struct FindName_res *pResults,
                     int results_max,
                     int timeout )
{
  struct status_resp SR;
  int    Timer;
  NAME_ENTRY *pN = ValidatehName ( NB_MachineName );

  if ( pN == NULL )
    return 0;

  SR.nt_search   = ntFind;
  SR.pRes        = pResults;
  SR.spaces_left = results_max;

  pN->pStatResp = &SR;
  SendDatagram ( STATUS_QUERY, &Multi_Addr, pnnFind, &pN->Name,
     0x1, 0x15C, 0 );

  Timer = LLC_TickerTime;

  do
  {
    LLC_BackgroundProcess();
  }
    while ( (SR.spaces_left > 0)  &&
            ((LLC_TickerTime - Timer) < timeout ) );

  pN->pStatResp = NULL;
  return results_max - SR.spaces_left;
}

/* Connection-oriented functions =================================== */

static void ClearUp ( NBSESSION *pS )
{
  QueueFlush ( &pS->RcvQ );
  TimerClear ( &pS->AckTimer );
  if ( pS->PartialRcv != NULL )
    FreeChain(pS->PartialRcv);
  pS->PartialRcv = NULL;
}

/* ----------------- */

static void SendAlive ( NBSESSION *pS )
{
  BUFCHAIN pB;

  SHdr.len   = 0x0E;
  SHdr.delim = 0xEFFF;
  SHdr.cmd   = SESSION_ALIVE;
  SHdr.opt1  = 0;
  SHdr.opt2lo= 0;
  SHdr.opt2hi= 0;
  SHdr.resp  = 0;
  SHdr.xmit  = 0;
  SHdr.dst_sn = pS->RmtLSN;
  SHdr.src_sn  = pS->LclLSN;

  pB = AddChain ( NULL, &SHdr, 0x0E );

  if ( pB != NULL )
    LLC_SendData ( pS->hconn, pB );
}

/* ----------------------- */

static bool EnsureAcks ( NBSESSION *pS )
{
  BUFCHAIN pB;

  if ( !pS->ack_pending )
    return true;

  /* Send ACK to far end */

  SHdr.len   = 0x0E;
  SHdr.delim = 0xEFFF;
  SHdr.cmd   = DATA_ACK;
  SHdr.opt1  = 0;
  SHdr.opt2lo= 0;
  SHdr.opt2hi= 0;
  SHdr.resp  = pS->next_resp;
  SHdr.xmit  = 0;
  SHdr.dst_sn = pS->RmtLSN;
  SHdr.src_sn = pS->LclLSN;

  pB = AddChain ( NULL, &SHdr, 0x0E );

  if ( pB != NULL &&
       LLC_SendData( pS->hconn, pB ) == OK )
  {
    pS->ack_pending = false;
    pS->next_resp = 0;
    return true;
  }

  debug0 (" Couldn't send ack! ");
  return false;
}

/* --------------------- */

/* This is called when a data ack timer expires */

static void AckTimerCallback ( void *data )
{
  NBSESSION *pS = (NBSESSION *)data;

  /* This will retry indefinitely if EnsureAcks fails */

  if ( pS->Status == SS_CONNECTED )
  {
    if ( !EnsureAcks(pS) )
      TimerStart ( &pS->AckTimer, ACK_SEND_TIME );
  }
}

/* --------------------- */

/* This waits for an ACK from the other end, if it is needed */

static bool WaitForAck ( NBSESSION *pS )
{
  int t = LLC_TickerTime;

  while ( pS->ack_required )
  {
    LLC_BackgroundProcess();

    if ( LLC_TickerTime - t > ACK_WAIT_TIME )
      return false;
  }

  return true;
}

/* ----------------------------------------- */

/* LinkRxFn processes incoming data on a link. */

static void NB_LinkRxFn ( HCONN hc, BUFCHAIN Data, void *private )
{
  static NB_SHORTHDR RSHdr;
  NBSESSION *pS;
  (void) hc;
  (void) private;

  Data = GetData ( Data, &RSHdr, 0x0E );
  if ( Data == NULL )  /* Barf! */
    return;

  if ( RSHdr.delim != 0xEFFF )
    goto DumpIt;

  pS = LSNtoSession(RSHdr.dst_sn);
  if ( pS == NULL ||
       (pS->Status & (SS_CONNECTED | SS_CALL_WAIT)) == 0 )
    goto DumpIt;

  debug1(" Rx-NB-%X", RSHdr.cmd );

  switch ( RSHdr.cmd )
  {
    case SESSION_CONFIRM:
      pS->RmtLSN = RSHdr.src_sn; /* Should be already! */
      pS->xmitsize = RSHdr.opt2lo + (RSHdr.opt2hi << 8);
      if ( pS->xmitsize == 0 || pS->xmitsize > NB_MaxSize )
        pS->xmitsize = NB_MaxSize;

      pS->Status = SS_CONNECTED;
      break;

    case DATA_FIRST_MIDDLE:
      pS->PartialRcv = ConcatChain ( pS->PartialRcv, Data );
      return; /* Don't deallocate */

    case DATA_ONLY_LAST:
      pS->next_resp = RSHdr.xmit;
      pS->ack_pending = true;
      pS->ack_required = false;
      TimerStart ( &pS->AckTimer, ACK_SEND_TIME );
      QueueAdd ( &pS->RcvQ, ConcatChain( pS->PartialRcv, Data ) );
      pS->PartialRcv = NULL;

      return; /* Don't deallocate buffers */

    case SESSION_ALIVE:
      SendAlive(pS);
      break;

    case DATA_ACK:
      pS->ack_required = false;
      break;

    default:
      break;
  }

DumpIt:
  FreeChain ( Data );
}
/* -------------------------------- */

/* FindRemoteName does a network name query for a given name;
   this will find its network address, and also exchange
   Local Session Numbers prior to making a connection.
*/

static err_t FindRemoteName ( NBSESSION *pS )
{
  int i, Timer;

  pS->Status = SS_CALLING;

  for ( i=0; i< FIND_NAME_TRIES; i++ )
  {
    Timer = LLC_TickerTime;
    SendDatagram ( NAME_QUERY, &Multi_Addr, &(pS->RmtName),
                     &(pS->LclName->Name), 0, pS->LclLSN, 0 );

    do
    {
      LLC_BackgroundProcess();
      /* Wait for return datagram to fill in address & RmtLSN */
      if ( pS->Status == SS_CALL_WAIT )
        return OK;
    }
      while ( (LLC_TickerTime - Timer) < FIND_NAME_TIME );
  }

  /* Failed to find name */
  return ECANTFINDNAME;
}

/* ------------------------------------ */

EXPORT err_t _NB_OpenSession ( hNAME hThisEnd, NETNAME *pnnFarEnd,
                             hSESSION *phSession )
{
  err_t   res;
  HCONN   hc;
  int     i, timer;

  BUFCHAIN pB;
  NBSESSION *pS;
  NAME_ENTRY *pnLcl = ValidatehName(hThisEnd);

  if ( pnLcl == NULL || pnnFarEnd == NULL )
    return EBADPARAM;

  /* (ii) Find a suitable session number */

  for ( i=1; i <= MAX_SESSIONS; i++ )
  {
    pS = LSNtoSession(i);
    if ( pS->Status == SS_FREE )
      goto GotSession;
  }
  return ENOHANDLES;

GotSession:
  /* (iii) Do a network find-name query */

  NB_MaxSize = LLC_GetMTU() - 14;

  debug0("Call: "); debug_name(&(pnLcl->Name));
  debug0("--> "); debug_name(pnnFarEnd);

  pS->RmtName = *pnnFarEnd;
  pS->LclName = pnLcl;
  pnLcl->pS_call = pS;

  res = FindRemoteName ( pS );
  pnLcl->pS_call = NULL;

  if ( res != OK )
    goto abort_find;

  /* (iv) Try to open an LLC connection */

  res = LLC_OpenLink ( &pS->RmtAddr, NETBIOS_SAP, NB_LinkRxFn,
              NULL, &hc );

  if ( res != OK )
    goto abort_find;

  /* Initialise fields */

  pS->hconn = hc;
  pS->next_xmit = 1;
  pS->next_resp = 0;
  pS->ack_pending = false;
  pS->ack_required = false;
  ClearUp ( pS );  /* Clear queues, etc, just in case */

  /* Send SESSION_INIT to other end */

  SHdr.len   = 0x0E;
  SHdr.delim = 0xEFFF;
  SHdr.cmd   = SESSION_INITIALISE;
  SHdr.opt1  = 0x8F;         /* Various flags - ?? */
  SHdr.opt2lo= NB_MaxSize & 0xFF;
  SHdr.opt2hi= NB_MaxSize >> 8;
  SHdr.resp  = 0;
  SHdr.xmit  = 0;
  SHdr.dst_sn = pS->RmtLSN;
  SHdr.src_sn  = pS->LclLSN;

  pB = AddChain ( NULL, &SHdr, 0x0E );
  if ( pB == NULL )
  {
    res = EOUTOFMEM;
    goto abort_conn;
  }

  res = LLC_SendData ( hc, pB );
  if ( res != OK )
    goto abort_conn;

  /* Wait for SESSION_CONFIRM */

  timer = LLC_TickerTime;

  while ( pS->Status != SS_CONNECTED )
  {
    LLC_BackgroundProcess();
    if ( !LLC_LinkOK(hc) )
    {
      res = ELINKFAILED;
      goto abort_conn;
    }

    if ( (LLC_TickerTime-timer) > OPEN_SESS_TIME )
    {
      res = ETIMEOUT;
      goto abort_conn;
    }
  }

  /* We win! */
  *phSession = (hSESSION) pS;
  return OK;

abort_conn:
   LLC_CloseLink(hc);
abort_find:
   pS->Status = SS_FREE;
   return res;
}

/* ----------------------- */

EXPORT err_t _NB_SendData ( hSESSION hSession, BUFCHAIN pB )
{
  NBSESSION *pS = ValidatehSession(hSession);
  err_t res;

  if ( pS == NULL )
  {
    FreeChain(pB);
    return ENOCONN;
  }

  if ( !WaitForAck(pS) )
  {
    FreeChain(pB);
    return ETIMEOUT;
  }

  /* Send DATA_ONLY_LAST data to far end */

  SHdr.len   = 0x0E;
  SHdr.delim = 0xEFFF;
  SHdr.cmd   = DATA_ONLY_LAST;
  SHdr.opt1  = pS->ack_pending ? 0x0C : 0x04;
  SHdr.opt2lo= 0;
  SHdr.opt2hi= 0;
  SHdr.resp  = pS->next_resp;
  SHdr.xmit  = pS->next_xmit;
  SHdr.dst_sn = pS->RmtLSN;
  SHdr.src_sn = pS->LclLSN;

  pB = AddChain ( pB, &SHdr, 0x0E );

  if ( pB == NULL )
    return EOUTOFMEM;

  /* Send packet */

  res = LLC_SendData( pS->hconn, pB );
  if ( res == OK )
  {
    pS->ack_pending = false;
    pS->next_resp = 0;
    pS->next_xmit++;
    pS->ack_required = true;
  }
  return res;
}

/* ----------------------- */

EXPORT err_t _NB_SendBlockData ( hSESSION hSession, BYTE *data, uint datalen )
{
  BUFCHAIN pB;
  err_t res;
  int n;
  NBSESSION *pS = ValidatehSession(hSession);

  if ( pS == NULL )
    return ENOCONN;

  if ( !WaitForAck(pS) )
    return ETIMEOUT;

  while ( datalen > 0 )
  {
    if ( datalen > pS->xmitsize )
    {
      n = pS->xmitsize;
      SHdr.cmd   = DATA_FIRST_MIDDLE;
    }
    else
    {
      n = datalen;
      SHdr.cmd   = DATA_ONLY_LAST;
    }

    SHdr.len   = 0x0E;
    SHdr.delim = 0xEFFF;
    SHdr.opt1  = pS->ack_pending ? 0x0C : 0x04;
    SHdr.opt2lo= 0;
    SHdr.opt2hi= 0;
    SHdr.resp  = pS->next_resp;
    SHdr.xmit  = pS->next_xmit;
    SHdr.dst_sn = pS->RmtLSN;
    SHdr.src_sn = pS->LclLSN;

    pB = AddChainIndirect ( NULL, data, n );
    if ( pB != NULL ) pB = AddChain ( pB, &SHdr, 0x0E );
    if ( pB == NULL )
      return EOUTOFMEM;

    /* Send packet */

    pS->ack_pending = false;
    pS->next_resp = 0;

    if ( (res=LLC_SendData( pS->hconn, pB )), res != OK )
      return res;

    datalen -= n;
    data += n;

  }

  pS->next_xmit++;
  pS->ack_required = true;

  return OK;
}

/* ----------------------- */

EXPORT err_t _NB_ClearRxQueue ( hSESSION hSession )
{
  NBSESSION *pS = ValidatehSession(hSession);

  if ( pS == NULL )
    return ENOCONN;

  QueueFlush ( &pS->RcvQ );
  FreeChain(pS->PartialRcv);
  pS->PartialRcv = NULL;
  return OK;
}


/* ----------------------- */

EXPORT err_t _NB_GetData ( hSESSION hSession, BUFCHAIN *pOutData, int timeout )
{
  int timer;
  BUFCHAIN pB;
  NBSESSION *pS = ValidatehSession(hSession);

  if ( pS == NULL )
    return ENOCONN;


  timer = LLC_TickerTime;
  do
  {
    pB = QueueGet(&pS->RcvQ);

    if ( pB != NULL )
    {
      *pOutData = pB;
      return OK;
    }

    LLC_BackgroundProcess();

    if ( !LLC_LinkOK(pS->hconn) )
      return ELINKFAILED;
  }
    while ( (LLC_TickerTime - timer) < timeout );

  return ETIMEOUT;
}

/* ----------------------- */

/* This is used chiefly by SMB_ReadRaw. The len_in_out parameter passes
   an advisory maximum block length in, and receives the received
   data count out. It is only set if OK is returned, and is unchanged
   otherwise!
   This routine was added because other transports (e.g. TCP/IP) may
   optimise a large data read differently. Indeed, keen people may want
   to try to optimise this further.
*/

EXPORT err_t _NB_GetBlockData ( hSESSION hSession, BYTE *where, uint *len_in_out,
                             int timeout )
{
  int timer;
  BUFCHAIN pB;
  NBSESSION *pS = ValidatehSession(hSession);

  if ( pS == NULL )
    return ENOCONN;

  timer = LLC_TickerTime;
  do
  {
    pB = QueueGet(&pS->RcvQ);

    if ( pB != NULL )
    {
      *len_in_out = GetAllData(pB, where);
      FreeChain(pB);
      return OK;
    }

    LLC_BackgroundProcess();

    if ( !LLC_LinkOK(pS->hconn) )
      return ELINKFAILED;
  }
    while ( (LLC_TickerTime - timer) < timeout );

  return ETIMEOUT;
}

/* -------------------------------- */

EXPORT err_t _NB_CloseSession ( hSESSION hSession )
{
  BUFCHAIN pB;
  NBSESSION *pS = ValidatehSession(hSession);

  if ( pS == NULL )
    return ENOCONN;

  EnsureAcks ( pS );

  /* Send SESSION_END to far end */

  SHdr.len   = 0x0E;
  SHdr.delim = 0xEFFF;
  SHdr.cmd   = SESSION_END;
  SHdr.opt1  = 0;
  SHdr.opt2lo= 0;
  SHdr.opt2hi= 0;
  SHdr.resp  = 0;
  SHdr.xmit  = 0;
  SHdr.dst_sn = pS->RmtLSN;
  SHdr.src_sn = pS->LclLSN;

  pB = AddChain ( NULL, &SHdr, 0x0E );

  /* Send command */

  if ( pB != NULL )
    LLC_SendData ( pS->hconn, pB );

  /* Finish up on link */

  LLC_CloseLink(pS->hconn);

  /* Clean up */

  ClearUp ( pS );
  pS->Status = SS_FREE;
  return OK;

}

/* ----------------------- */

EXPORT char *_NB_DescribeLink ( hSESSION hS )
{
  static char namebuf[40];
  NBSESSION *pS = ValidatehSession(hS);

  if ( pS == NULL )
    return NULL;

  sprintf( namebuf, "%02X:%02X:%02X:%02X:%02X:%02X",
       pS->RmtAddr.b[0], pS->RmtAddr.b[1],
       pS->RmtAddr.b[2], pS->RmtAddr.b[3],
       pS->RmtAddr.b[4], pS->RmtAddr.b[5] );

  return namebuf;
}

/* ----------------------- */

EXPORT err_t _NB_Startup(void)
{
  int i;
  err_t res;
  NBSESSION *pS;
  NAME_ENTRY *pN;

  debug0("Initialising NetBEUI transport\n");

  /* First, clear out all our session & name tables */

  for ( i=1; i <= MAX_SESSIONS; i++ )
  {
    pS = LSNtoSession(i);
    pS->Status  = SS_FREE;
    pS->LclLSN  = i;
    pS->RcvQ.Head  = NULL;
    pS->RcvQ.Last  = NULL;
    pS->PartialRcv = NULL;
    TimerInit ( &pS->AckTimer, AckTimerCallback, pS );
  }

  for ( i=0; i < MAX_NAMES; i++ )
  {
    pN = &NB_NameTable[i];
    pN->Status = NS_FREE;
  }

  Stat_ClassMask |= SCLASS_NETBEUI;

  /* Initialise LLC layer */

  if ( !LLC_Init() )
    return EINITFAILED;

  /* Now find network driver */

  debug1("Looking for driver '%s'\n", LM_Vars.drivername);

  res = LLC_AttachDriver(LM_Vars.drivername, &Multi_Addr);
  if ( res != OK )
  {
    LLC_Shutdown();
    return res;
  }

  /* Now set our machine name */

  UI_SetReceiver( NETBIOS_SAP, NB_ReceiveDatagram, NULL);

  if ( LM_Vars.machinename[0] == 0 )
  {
    BYTE *p = LLC_MachineAddress.b;
    sprintf( LM_Vars.machinename, "ARM%02X%02X%02X%02X%02X%02X",
       p[0], p[1], p[2], p[3], p[4], p[5] );
  }

  debug1( "Setting machine name to '%s'\n", LM_Vars.machinename );

  res = _NB_AddLocalName( ntMACHINE, LM_Vars.machinename, &NB_MachineName );
  if (res != OK)
  {
    LLC_Shutdown();
  }

  return res;
}

/* ----------------------- */

EXPORT void _NB_Shutdown(void)
{
  int i;

  /* Clear up all active sessions */

  for ( i=1; i <= MAX_SESSIONS; i++ )
    ClearUp(LSNtoSession(i));

  for ( i=0; i < MAX_NAMES; i++ )
    if ( NB_NameTable[i].Status != NS_FREE )
    {
      QueueFlush(&(NB_NameTable[i].DatagramQ));
      NB_NameTable[i].Status = NS_FREE;
    }

  LLC_Shutdown(); /* Detach driver & turn off timers, etc */
}

/* NB_InternetGone() --------------------------- */

static void _NB_InternetGone(void)
{
  /* We don't care - we're the protocol module? */
}


/* NB_InternetGone() --------------------------- */

static void _NB_InternetInit(void)
{
  /* We don't care - we're the protocol module? */
}


/* Setup routine ------------------------------- */

static struct NETBIOS_TRANSPORT NetBEUI_Transport;

void NB_NetBEUI_Setup ( void )
{
  struct NETBIOS_TRANSPORT *p;
  NB_ActiveTransport = p = &NetBEUI_Transport;

  p->pfnStartup	 = _NB_Startup;
  p->pfnShutdown = _NB_Shutdown;
  p->pfnFormatName = _NB_FormatName;
  p->pfnDecodeName = _NB_DecodeName;
  p->pfnMatchName = _NB_MatchName;
  p->pfnAddLocalName = _NB_AddLocalName;
  p->pfnRemoveLocalName = _NB_RemoveLocalName;
  p->pfnOpenSession = _NB_OpenSession;
  p->pfnSendData = _NB_SendData;
  p->pfnSendBlockData = _NB_SendBlockData;
  p->pfnClearRxQueue = _NB_ClearRxQueue;
  p->pfnGetData = _NB_GetData;
  p->pfnGetBlockData = _NB_GetBlockData;
  p->pfnLinkOK = _NB_LinkOK;
  p->pfnCloseSession = _NB_CloseSession;
  p->pfnFindNames = _NB_FindNames;
  p->pfnDescribeLink = _NB_DescribeLink;
  p->pfnInternetGone = _NB_InternetGone;
  p->pfnInternetInit = _NB_InternetInit;
}
#endif
@


1.9
log
@Internationalised
Unused LMFiler put in the attic.
As LanMan has historically put its resources into ThirdPart/OmniClient this component has no ROM resources phase - it still registers the resources at run time.

Version 2.40. Tagged as 'LanManFS-2_40'
@
text
@d1253 1
a1253 2
  if ( LM_Vars.verbose )
    printf("  Initialising NetBEUI transport\n");
d1283 1
a1283 2
  if ( LM_Vars.verbose )
    printf("  Looking for driver '%s'\n", LM_Vars.drivername);
d1303 1
a1303 2
  if ( LM_Vars.verbose )
    printf("  Setting machine name to '%s'\n", LM_Vars.machinename );
@


1.8
log
@Fix and speed up EXT#handle=number doing nothing when number is beyond 2GB
Internally LanManFS was representing file offsets and data lengths as signed numbers, while in general this doesn't matter (they are passed through opaquely as just numbers and not manipulated) in a couple of places they were being used as while () loop exit conditions.
Function WriteZeroes (used when extending a file via OS_Args) therefore never performed the call to SMB_Write when beyond 2G because the loop condition was never met.
Additionally, it was literally transferring buffers of zeros across the network which is unnecessary as the server is documented as doing a zero fill itself, this represents at least a x40 speed up (on a slow 1MB/s drive write speed at the server end) or more.
Changed offset & lengths from int to uint.
Added the earlier CIFS spec (the later copy is missing section 5 for some reason) to docs.

Version 2.38. Tagged as 'LanManFS-2_38'
@
text
@d37 1
a38 1
#include "stdtypes.h"
@


1.7
log
@Fix for renames where only the case has changed.
Detail:
 Added an extra check after the Xlate path resolution code so that
 the case of the path given to resolve is honoured. This now means that
 the strcmp() done in SMB_Rename fails and the rename is actually sent to
 the server. Before "*rename test Test" would have the path resolved and
 since 'test' already existed both names would be the same, in this example
 something like "*rename A:\test A:\test" would result.
Admin:
 Made the non LONGNAMES version compile again (not tested).
 Removed local definitions of FSControl reason codes, uses Interface header
 now.
 Made the case of #includes match CVS to allow future compilation on a case
 sensitive system.
 Deleted unused "Version" header.

Version 2.34. Tagged as 'LanManFS-2_34'
@
text
@d1030 1
a1030 1
EXPORT err_t _NB_SendBlockData ( hSESSION hSession, BYTE *data, int datalen )
d1150 1
a1150 1
EXPORT err_t _NB_GetBlockData ( hSESSION hSession, BYTE *where, int *len_in_out,
@


1.6
log
@  Multiple fixes.
Detail:
  Too many to list here: see doc/RPSChanges.
Admin:
  Received from Rob Sprowson approx 2009-02-08. Builds, but not tested by ROOL.

Version 2.32. Tagged as 'LanManFS-2_32'
@
text
@a26 1

d37 1
d39 5
a43 6
#include "buflib.h"
#include "stats.h"
#include "llc.h"
#include "netbios.h"
#include "lmvars.h"

@


1.5
log
@  Experimental change to handle Internet modules in flash.
Detail:
  This module was ignoring the possibility of the Internet module being
    re-initialised underneath it - something which can happen if there
    is an Internet module in flash as well as main ROM.  This is an
    experimental fix for this problem.
Admin:
  Not tested.

Version 2.18. Tagged as 'LanManFS-2_18'
@
text
@d88 1
a88 1
struct status_resp  /* Structure used to process STATUS_RESPOMSE */
@


1.4
log
@  New build option to exclude NetBEUI support.
Detail:
  Pass OPTIONS=-DNO_NETBEUI from the Components file if you do not need
    NetBEUI support, and LanManFS will be 12K smaller.
  In NetBEUI mode, LanManFS sends Service_DCIProtocolStatus as required.
  In IP mode, LanManFS notices Service_DCIProtocolStatus from the Internet
    module when it dies and marks all its sockets as needing reconnection.
  Booting behaviour changed to look for !ArmBoot again and not attempt
    the boot if it is missing.  Removed lots of grotty backdoor hacks
    that used to be used to determine this.
Admin:
  Not tested at all.  This will need very thorough testing before it can
    be considered for release.

Version 2.14. Tagged as 'LanManFS-2_14'
@
text
@d1347 8
d1382 1
@


1.3
log
@  Calls LLC_Shutdown if NetBIOS's _NB_Startup is going to fail.
Detail:
  NB_Startup was failing to stop the LLC timers if the function
    was going to fail after hooking onto TickerV.  This meant that
    if LanManFS never found an appropriate driver for NetBIOS use,
    then killing the module resulted in repeated aborts when the
    TickerV handler has invoked.
Admin:
  Untested.
  Fixes Bugzilla bug #26

Version 2.13. Tagged as 'LanManFS-2_13'
@
text
@d27 1
d36 2
d45 1
d1339 8
d1373 1
d1375 1
a1375 3



@


1.2
log
@  Support for long filename.
  Support for spaces in machine names.
  Merge of sbrodie_LanManFS_dev branch to trunk.
Detail:
  LanManFS 2.00 supports the "NT LM 0.12" protocol, enabling it to
    use long filenames on mounted shares.
Admin:
  Supporting documentation:
    1215,256/FS: LanManFS Software Functional Specification.
  Same as LanManFS-1_87_1_1_1_1_2_13.

Version 2.00. Tagged as 'LanManFS-2_00'
@
text
@d1286 2
d1289 1
d1305 7
a1311 1
  return _NB_AddLocalName( ntMACHINE, LM_Vars.machinename, &NB_MachineName );
@


1.1
log
@Initial revision
@
text
@d311 3
a313 2
    if ( name[i] <= 0x20 ) break;
    res->b[i] = toupper(name[i]);
d328 2
d331 1
a331 1
  while ( *p > 0x20 )
d336 4
d1284 1
a1284 1
  res = LLC_AttachDriver(LM_Vars.drivername);
@


1.1.1.1
log
@
LanManFS moved into Omni subdirectory.  Previous version in
RiscOS/Sources/Networking/LanManFS is now locked out.

The rest of Omni will be imported at a later date.

Version 1.87, tagged as LanManFS-1_87

@
text
@@


1.1.1.1.2.1
log
@  Implemented h/w multicast filtering.
  Uses our DCI4 header file.
Detail:
  Now uses DCI4 MulticastRequest SWIs to selectively receive NetBEUI specific
    multicast IEEE frames.
  LLC_AttachDriver now takes an additional multicast MAC address parameter
    which is automatically claimed when the frames are claimed.
  Uses sys/dcistructs.h instead of its private ancient DCI4.h.  Some of the
    constants are different (old header shifted some numbers into correct
    positions for various calls - notably FRMLVL_* definitions).  Code modified
    to use the proper macros to construct these constants.
Admin:
  Build and tested briefly.  EHInfo reports MAR for IEEE frames has been set
    as expected, and *LanMan:LMLogon seems to work.

Version 1.87, 1.1.1.1.2.1. Tagged as 'LanManFS-1_87-1_1_1_1_2_1'
@
text
@d1277 1
a1277 1
  res = LLC_AttachDriver(LM_Vars.drivername, &Multi_Addr);
@


1.1.1.1.2.2
log
@  Check-in of all files comprising this development build of LanManFS
  Spaces in NetBIOS names are now allowed.
Detail:
  Now supports NetBIOS hostnames which contain spaces.  Use hardspaces
    in the Omni frontend or at the command-line (unless you can get
    away with a normal space without confusing the CLI parser)
Admin:
  Tested by attempting to connect to machines with spaces in their
    names.  Got the expected response from the target machine, so
    this aspect is working.
  It appears that several files did not get checked in due to datestamp
    problems when LanManFS's location in CVS was changed.  This is now
    fixed.

Version 1.87, 1.1.1.1.2.7. Tagged as 'LanManFS-1_87-1_1_1_1_2_7'
@
text
@d311 2
a312 3
    if ( name[i] < 0x20 ) break;
    if (name[i] == '\xA0') res->b[i] = ' ';
    else res->b[i] = toupper(name[i]);
a326 1
  char *last_nonsp = buf;
d328 1
a328 1
  while ( *p >= 0x20 )
a331 4

  while (--buf > last_nonsp) {
    if (*buf == ' ') *buf = 0;
  }
@


1.1.1.1.2.3
log
@  Fixed most dodgy pathname problems.
  All *LM... commands are now filing system commands.
  *Connect and *Disconnect renamed to *LMConnect and *LMDisconnect.
Detail:
  When translating RISC OS to DOS filenames, a loop could develop if
    any path component contained a dodgy character.  This is now fixed
    with the exception of problems when both < and > characters appear
    in pathnames since that confuses FileSwitch.  New mappings will be
    need to be agreed for these characters (and remappings for $ and %
    which overload < and > respectively)
  All *LM... commands are now filing system commands, which means that
    you need to prefix them with LanMan: unless LanManFS is the current
    filesystem (following spec review).
  *Connect and *Disconnect renamed to *LMConnect and *LMDisconnect
    (following spec review).
  Trace builds allow "*LanMan:LMNameMode 4" to enable display of system
    and hidden files on the remote filesystem.
Admin:
  Tested briefly against Windows 98 and Windows NT 4 SP3.
  If a directory name contains a dodgy character, repeated searches will
    be made on the remote filesystem.  This is inefficient and a name
    cache would alleviate this.  There is no name cacheing in the current
    version.

Version 1.87, 1.1.1.1.2.9. Tagged as 'LanManFS-1_87-1_1_1_1_2_9'
@
text
@a328 1
  int i;
d330 1
a330 1
  for (i=0; i<15 && *p >= 0x20; ++i)
@

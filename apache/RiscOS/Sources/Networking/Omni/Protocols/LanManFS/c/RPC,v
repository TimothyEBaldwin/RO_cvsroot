head	1.9;
access;
symbols
	LanManFS-2_62:1.9
	LanManFS-2_61:1.9
	LanManFS-2_60:1.9
	LanManFS-2_59:1.9
	LanManFS-2_58:1.9
	LanManFS-2_57:1.9
	LanManFS-2_56:1.9
	LanManFS-2_55:1.9
	LanManFS-2_54:1.9
	LanManFS-2_53:1.9
	LanManFS-2_52:1.8
	LanManFS-2_51:1.8
	LanManFS-2_50:1.8
	LanManFS-2_49:1.8
	LanManFS-2_48:1.8
	LanManFS-2_47:1.8
	LanManFS-2_46:1.8
	LanManFS-2_45:1.8
	LanManFS-2_44:1.8
	LanManFS-2_43:1.8
	LanManFS-2_42:1.8
	LanManFS-2_41:1.8
	LanManFS-2_40:1.7
	LanManFS-2_39:1.6
	LanManFS-2_38:1.6
	LanManFS-2_37:1.6
	LanManFS-2_36:1.6
	LanManFS-2_35:1.6
	LanManFS-2_34:1.6
	LanManFS-2_33:1.5
	LanManFS-2_32:1.5
	LanManFS-2_31:1.5
	RO_5_07:1.5
	LanManFS-2_30:1.5
	LanManFS-2_29:1.5
	LanManFS-2_28:1.4
	LanManFS-2_27:1.4
	LanManFS-2_26:1.4
	LanManFS-2_25:1.4
	LanManFS-2_24:1.4
	LanManFS-2_23:1.4
	LanManFS-2_22:1.3
	LanManFS-2_21:1.3
	LanManFS-2_20:1.3
	LanManFS-2_19:1.3
	LanManFS-2_18:1.3
	LanManFS-2_17:1.3
	LanManFS-2_16:1.3
	LanManFS-2_15:1.3
	LanManFS-2_14:1.3
	LanManFS-2_13:1.3
	LanManFS-2_12:1.3
	LanManFS-2_11:1.3
	LanManFS-2_10:1.3
	LanManFS-2_09:1.3
	LanManFS-2_08:1.3
	LanManFS-2_07:1.3
	LanManFS-2_06:1.3
	LanManFS-2_05:1.3
	LanManFS-2_04:1.3
	LanManFS-2_03:1.3
	LanManFS-2_02:1.2
	LanManFS-2_01:1.2
	LanManFS-2_00:1.2
	LanManFS-1_87-1_1_1_1_2_13:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_12:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_11:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_10:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_9:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_8:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_7:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_6:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_5:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_4:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_3:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_2:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_1:1.1.1.1
	sbrodie_LanManFS_dev:1.1.1.1.0.2
	sbrodie_LanManFS_dev_bp:1.1.1.1
	LanManFS-1_87:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2016.03.17.08.37.20;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	UFtCQdgsAJ2fnYYy;

1.8
date	2013.10.03.19.20.08;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	nWGzdAD9s5kFIS7x;

1.7
date	2013.10.03.07.27.09;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	iTaBDwF1woaPMO7x;

1.6
date	2009.08.01.08.10.27;	author rsprowson;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.09.11.28.01;	author bavison;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.14.13.51.16;	author rsprowson;	state Exp;
branches;
next	1.3;

1.3
date	99.03.01.16.58.28;	author sbrodie;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.12.52.11;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	98.12.03.13.54.45;	author sbrodie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.12.03.13.54.45;	author sbrodie;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	98.12.11.17.26.26;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Fix for garbled translation
One too many %s's in the code, one too few in the messages file. This resulted in diagnostics messages (eg. at the bottom of *ListFS) to show a %s that hadn't got substituted.

Version 2.53. Tagged as 'LanManFS-2_53'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
*
*  RPC.C  -- Remote procedure call routines for
*              interrogating servers
*
*  02-02-95 INH  Original
*  	    	 Added Transact SWI interface
*  25-07-96      Added GetUserHomeDir
*/

#define OMIT_UNUSED_FNS

/* Standard includes */

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <ctype.h>
#include "kernel.h"

/* Our includes */

#include "stdtypes.h"
#include "LanMan.h"
#include "BufLib.h"
#include "NetBIOS.h"
#include "SMB.h"
#include "Xlate.h"  /* For string functions */
#include "Omni.h"
#include "LMVars.h"
#include "RPC.h"

/* Globals ---------------------------- */

char RPC_DebugMsg[100];
int  RPC_ErrorCount=0;

/* Debug routine */

typedef enum
{
  DE_ENUMSHARESNOLOGON = 0,
  DE_ENUMSHARESCALLTO,
  DE_NOMASTERBROWSER,
  DE_ENUMSERVERSNOLOGON,
  DE_ENUMSERVERSCALLTO,
  DE_LOGONUSERNOCONN,
  DE_NETGETUSERINFO
} debug_errs_t;

static err_t debug_err ( err_t res, debug_errs_t token, char *name )
{
  char text[100];

  if ( res != OK )
  {
    sprintf(text, "D%02u", token);
    strcpy(text, MsgLookup(text));
    strcat(text, ": %s"); /* Append the error */
    RPC_ErrorCount++;
    sprintf( RPC_DebugMsg, text, name, MsgError(res)->errmess );
  }
  return res;
}

/* Parameter-assembly subroutines -------------------- */

static struct TransactParms TP;

/* ---------- */

static void addword ( int value )
{
  BYTE *p = TP.parms_in + TP.parms_in_len;
  p[0] = (value & 0xFF);
  p[1] = (value >> 8 );
  TP.parms_in_len+=2;
}

/* ---------- */

static void addlong ( int value )
{
  BYTE *p = TP.parms_in + TP.parms_in_len;
  p[0] = (value & 0xFF);
  p[1] = (value >> 8 );
  p[2] = (value >> 16 );
  p[3] = (value >> 24 );
  TP.parms_in_len+=4;
}

/* ---------- */

static void addstring ( char *str )
{
  BYTE *p = TP.parms_in + TP.parms_in_len;
  int l = strlen(str)+1;
  memcpy ( p, str, l );
  TP.parms_in_len += l;
}

/* ---------- */

static void StartParams ( int func_code, char *in_format, char *out_format,
                           int ret_param_len )
{
  TP.parms_in = SMB_WorkBuf;
  TP.parms_in_len = 0;
  TP.data_in = NULL;
  TP.data_in_len = 0;

  TP.parms_out_buf = SMB_WorkBuf;
  TP.parms_out_maxlen = min(ret_param_len, SMBWORKBUF_SIZE);
  TP.data_out_buf  = SMB_WorkBuf + TP.parms_out_maxlen;
  TP.data_out_maxlen = SMBWORKBUF_SIZE-TP.parms_out_maxlen;

  addword ( func_code );
  addstring ( in_format );
  addstring ( out_format );
}

/* Parameter-return subroutines ====================== */

static int getword ( BYTE *p )
{
  return ( p[0] + (p[1] << 8));
}

/* ----------------- */
#if 0
static int getlong ( BYTE *p )
{
  return ( p[0] + (p[1] << 8) + (p[2] << 16)+ (p[3] << 24));
}
#endif

/* ----------------- */

static BYTE *getpointer ( BYTE *p )
{
  int ptrval;

  ptrval = getword(p) + TP.data_out_len - TP.data_out_maxlen;
  if ( ptrval <= 0 || ptrval >= TP.data_out_len )
    return NULL;

  return TP.data_out_buf + ptrval;
}

/* ============================================ */

static bool check_hidden ( char *name )
{
  while ( *name != 0 )
  {
    if ( name[0] == '$' && name[1] == 0 )
      return false;  /* Name is hidden */
    name++;
  }
  return true;
}

/* ---------------------------- */

static err_t RPC_EnumSharesOnConnection ( char drv, char *server )
{
  BYTE *p;
  int i, co;
  err_t res;

  /* Assemble parameters for RPC call */

  StartParams( 0x0000, "WrLeh", "B13BWz", 8 ); /* NetShareEnum */
  addword (0x0001);  /* Detail level */
  addword (TP.data_out_maxlen); /* Return buf size */

  /* Make call */

  res = SMB_Transact ( drv, "\\PIPE\\LANMAN", &TP );
  if ( res != OK )
    return res;

  if ( TP.parms_out_len < 8 )
    return EDATALEN;

  /* Decode returned params */
  p = TP.parms_out_buf;

  if ( getword(p) != 0 )   /* API return code; 0 = success */
    return ERPCERROR;            /* Otherwise, call it 'generic' error */

  co = getword(p+2);  /* Comment offset adjustment - ( why?? ) */

  i = getword(p+4);        /* Number of records returned */
  if ( i*20 > TP.data_out_len )  /* Silly values! */
    return EDATALEN;

  /* Process returned records */

  p = TP.data_out_buf;

  while ( i-- > 0 )
  {
    /* p is the start of the record. The first 13 bytes
       are a share name + null termination. If the share name
       ends in '$', it is hidden and should not be listed.
       [sbrodie: ... except if it's an IPC share, I've decided.  Also
       we store the comments too for *lanman:listfs to display.  Why is there
       a mystical word in the returned param block which is subtracted from
       the offset field? Dunno, but SAMBA does it and Windows 98 needs it.]
    */
    int shrtype = getword(p+14);
    int commoffset = getword(p+16);
    char *comment = commoffset ? ((char *) TP.data_out_buf + commoffset - co) : 0;

    if ( shrtype == SHR_IPC || check_hidden( (char *)p) )
    {
      if ( shrtype == SHR_DISK )
        Omni_AddInfo ( OAI_DISK, server, (char *)p, comment );
      else if ( shrtype == SHR_PRINTER )
        Omni_AddInfo ( OAI_PRINTER, server, (char *)p, comment );
      else if ( shrtype == SHR_IPC )
        Omni_AddInfo ( OAI_IPC, server, (char *)p, comment );
      else if ( shrtype == SHR_COMM )
        Omni_AddInfo ( OAI_DEVICE, server, (char *)p, comment );
    }
    p += 20;
  }

  return OK;
}

/* ---------------------------- */

static err_t RPC_EnumServersOnConnection ( char drv, char *domain )
{
  err_t res;
  BYTE *p;
  int co;
  int i;

  /* NetServerEnum2 */
  StartParams ( 0x0068, "WrLehDz", "B16BBDz", 8 );
  addword (0x0001);  /* Detail level */
  addword (TP.data_out_maxlen); /* Return buf size */
  addlong ((int)0xFFFFFFFF); /* Return all server types */
  addstring ( domain ); /* Domain name */

  /* Make call */

  res = SMB_Transact ( drv, "\\PIPE\\LANMAN", &TP );
  if ( res != OK )
    return res;

  if ( TP.parms_out_len < 8 )
    return EDATALEN;

  /* Decode returned params */
  p = TP.parms_out_buf;

  if ( getword(p) != 0 )   /* API return code; 0 = success */
    return ERPCERROR;

  co = getword(p+2);

  i = getword(p+4);        /* Number of records returned */
  if ( i*26 > TP.data_out_len )  /* Silly values! */
    return EDATALEN;

  /* Process returned records */

  p = TP.data_out_buf;

  while ( i-- > 0 )
  {
    /* p is the start of the record. The first 16 bytes
       are a server name + null termination.
    */
    int commoffset = getword(p+22);
    char *comment = commoffset ? ((char *) TP.data_out_buf + commoffset - co) : 0;

    Omni_AddInfo ( OAI_SERVER, (char *)p, comment, NULL );
    p += 26;
  }

  return OK;
}

/* ---------------------------- */

err_t RPC_EnumerateShares ( char *server  )
{
  char  drv;                /* Connection identifier */
  err_t res;

  /* (i) Connect to IPC share */

  res = SMB_CreateShare ( SHR_IPC, CREATE_NORMAL,
                            server, "IPC$", NULL, NULL, &drv );

  if ( res != OK )
    return debug_err( res, DE_ENUMSHARESNOLOGON, server );

  Omni_AddInfo ( OAI_SERVER, server, SMB_GetConnInfo(drv, GCI_SERVERINFO), NULL );

  res = RPC_EnumSharesOnConnection ( drv, server );

  SMB_DeleteShare ( drv );
  return debug_err( res, DE_ENUMSHARESCALLTO, server );
}


/* ---------------------------------------- */

static char *GetMasterBrowser (char *wg_name)
{
  NETNAME MBname;
  struct FindName_res fnr;
  static char namebuf[16];

  NB_FormatName ( ntMBROWSER, wg_name, &MBname );

  /* Have a 1.5-sec timeout */
  if ( NB_FindNames ( &MBname, ntSERVER, &fnr, 1, 150 ) == 0)
    return NULL;

  NB_DecodeName ( &(fnr.name), namebuf );
  return namebuf;
}

/* ---------------------------------------- */

char *RPC_GetDomainController (char *domain_name)
{
  NETNAME DCname;
  struct FindName_res fnr;
  static char namebuf[16];

  NB_FormatName ( ntPRIMARYDC, domain_name, &DCname );

  /* Have quick 1.5-sec timeout */
  if ( NB_FindNames ( &DCname, ntSERVER, &fnr, 1, 150 ) == 0)
    return NULL;

  NB_DecodeName ( &(fnr.name), namebuf );
  return namebuf;
}


/* ---------------------------- */


err_t RPC_EnumerateServers ( char *workgroup )
{
  char  drv;                /* Connection identifier */
  err_t res;
  char *server;

  /* (i) Connect to IPC share */

  server = GetMasterBrowser ( workgroup );

  if ( server == NULL )
    server = RPC_GetDomainController ( workgroup );

  if ( server == NULL )
    return debug_err( ECANTFINDNAME, DE_NOMASTERBROWSER, workgroup);

  res = SMB_CreateShare ( SHR_IPC, CREATE_NORMAL,
               server, "IPC$", NULL, NULL, &drv );

  if ( res != OK )
    return debug_err( res, DE_ENUMSERVERSNOLOGON, server );

  res = RPC_EnumServersOnConnection ( drv, workgroup );

  SMB_DeleteShare ( drv );
  return debug_err( res, DE_ENUMSERVERSCALLTO, server );
}

/* ---------------------------- */

err_t RPC_LogonUser ( char *server, char *user, char *password,
                         char **pHomeDir )
{
  err_t res;
  char drv;

  /* Trying to connect to the IPC share is as good a method of
     password validation as any */

  res = SMB_CreateShare ( SHR_IPC, CREATE_NEW_USER,
               server, "IPC$", user, password, &drv );

  if ( res != OK )
    return debug_err(res, DE_LOGONUSERNOCONN, user );

  /* NetUserGetInfo */
  StartParams ( 0x0038, "zWrLh",
               "B21BzzzWDDzzDDWWzWzDWb21W", 6 );

  addstring (user);
  addword (11);  /* Detail level */
  addword (TP.data_out_maxlen); /* Return buf size */

  /* Make call */

  res = SMB_Transact ( drv, "\\PIPE\\LANMAN", &TP );

  if ( res == OK )
  {
    if ( TP.parms_out_len < 6 )
      res = EDATALEN;
    else
    {
      switch ( getword ( TP.parms_out_buf ) ) /* return code */
      {
        case 0:
          *pHomeDir = (char *)getpointer( TP.data_out_buf+44 );
          res = OK;
          break;
        case 5: case 65: /* Access denied */
          res = ENOACCESS;
          break;
        case 2221: /* User not found */
          res = EUSERUNKNOWN;
          break;
        case 2239: /* Account disabled */
          res = EACCDISABLED;
          break;
        default:
          res = ERPCERROR;
          break;
      }
    }
  }

  SMB_DeleteShare ( drv );

  return debug_err(res, DE_NETGETUSERINFO, user );
}


/* ---------------------------- */

err_t RPC_NameOp ( int reason, char *name_in, char *buf_out )
{
  char *s;
  /* We assume buf_out can hold a 16-character name including last 0 */

  switch ( reason )
  {
    case NAMEOP_GETLOCAL:
      s = LM_Vars.machinename;
      break;

    case NAMEOP_GETWG:
      s = LM_Vars.workgroup;
      break;

    case NAMEOP_GETBROWSER:
      if ( name_in == NULL ) name_in = LM_Vars.workgroup;

      s = GetMasterBrowser ( name_in );
      if ( s == NULL )
        return ECANTFINDNAME;
      break;

    case NAMEOP_GETDC:
      if ( name_in == NULL ) name_in = LM_Vars.workgroup;

      s = RPC_GetDomainController ( name_in );
      if ( s == NULL )
        return ECANTFINDNAME;
      break;

    default:
      return EBADPARAM;
  }

  strcpy ( buf_out, s );
  return OK;
}

/* ------------------------- */

err_t RPC_Transact ( char *servername, char *pipename, void *pvParmBlk )
{
  char drv;
  err_t res;
  struct TransactParms t;

  /* Connect to IPC share using default user ID/password */

  res = SMB_CreateShare ( SHR_IPC, CREATE_NORMAL,
                            servername, "IPC$", NULL, NULL, &drv );

  if ( res != OK )
    return res;

  memcpy(&t, pvParmBlk, sizeof_TransactParms_external);
#ifdef LONGNAMES
  t.setup_in_len = 0;
  t.setup_out_maxlen = 0;
#endif
  res = SMB_Transact ( drv, pipename, &t );
  SMB_DeleteShare ( drv );
  return res;
}

/* ------------------------- */

bool RPC_Init ( void )
{
  RPC_ErrorCount = 0;
  RPC_DebugMsg[0] = 0;
  return true;
}


@


1.8
log
@Wrap stats report in DEBUG switch
Missed in earlier internationalisation but spotted in the binary - the stats report function is only called from a debug command, but the linker wasn't spotting that and removing the table of stats names.
Translate the descriptive text in debug_err in RPC.c.
Retagged as LanManFS-2_41.
@
text
@d74 1
d76 1
a76 2
    sprintf( RPC_DebugMsg, "%s %s: %s",
            text, name, MsgError(res)->errmess );
@


1.7
log
@Internationalised
Unused LMFiler put in the attic.
As LanMan has historically put its resources into ThirdPart/OmniClient this component has no ROM resources phase - it still registers the resources at run time.

Version 2.40. Tagged as 'LanManFS-2_40'
@
text
@d55 1
a55 1
static err_t debug_err ( err_t res, char *text, char *name )
d57 13
d72 2
d317 1
a317 1
    return debug_err( res, "(EnumShares) could not log on to", server );
d324 1
a324 1
  return debug_err( res, "EnumShares call on", server );
d382 1
a382 3
    return debug_err( ECANTFINDNAME,
       "Can't find master browser or domain controller for",
                        workgroup );
d388 1
a388 1
    return debug_err( res, "(EnumServers) could not log on to", server );
d393 1
a393 1
  return debug_err( res, "EnumServers call on", server );
d411 1
a411 2
    return debug_err(res, "LogonUser: connect to DC failed, user name",
                            user );
d455 1
a455 1
  return debug_err(res, "NetGetUserInfo() call failed, user name", user );
@


1.6
log
@Fix for renames where only the case has changed.
Detail:
 Added an extra check after the Xlate path resolution code so that
 the case of the path given to resolve is honoured. This now means that
 the strcmp() done in SMB_Rename fails and the rename is actually sent to
 the server. Before "*rename test Test" would have the path resolved and
 since 'test' already existed both names would be the same, in this example
 something like "*rename A:\test A:\test" would result.
Admin:
 Made the non LONGNAMES version compile again (not tested).
 Removed local definitions of FSControl reason codes, uses Interface header
 now.
 Made the case of #includes match CVS to allow future compilation on a case
 sensitive system.
 Deleted unused "Version" header.

Version 2.34. Tagged as 'LanManFS-2_34'
@
text
@d38 1
a39 1
#include "stdtypes.h"
d61 1
a61 1
            text, name, Xlt_Error(res)->errmess );
@


1.5
log
@  Changes from John.
Detail:
  > Default filetype now text
  >
  > Default type given to any file that has neither a dos extent, nor a
  > ',xxx' riscos extent at the server
  >
  > Ensure that files given the default type never have a ',xxx' riscos
  > extent appended.
  >
  > Add environment variable 'LMDefaultType' which checked for a default
  > type on module initialisation .. thus setting this to (e.g.) dos, then
  > rmreinitting LanManFS will change the default type to (e.g.) dos.
Admin:
  Not tested here yet.

Version 2.29. Tagged as 'LanManFS-2_29'
@
text
@d38 1
d40 1
a40 1
#include "buflib.h"
d42 5
a46 5
#include "smb.h"
#include "xlate.h"  /* For string functions */
#include "omni.h"
#include "lmvars.h"
#include "rpc.h"
@


1.4
log
@LanmanFS help syntax corrected and tidied
Change lmls command to ListFS in line with NFS
Supress LF when ListFS is issued but there are no servers present.
Cast a few things to shut some compiler warnings up.
Addition of MimeMap lookups where the file has no ",ttt" style type
appended.Previously any such files were all reported as text files so
viewing a machine would typically show whole directories full of
identical filetypes.

Version 2.23. Tagged as 'LanManFS-2_23'
@
text
@d245 1
a245 1
  addlong (0xFFFFFFFF); /* Return all server types */
@


1.3
log
@  New *LMLS command.
  Fix for ./.. files in short filename shares.
  Long multiply now provided in assembler.
Detail:
  *LMLS is a new filesystem-specific command which performs the same
    task as "smbclient -L" does under UNIX - ie. listing all the shares
    available on the specified host.
  When enumerating the shares on a remote server, LanManFS now remembers
    all the printers, IPC, device and disc shares (for *LMLS to output).
  The 32x32->64 multiply routine is now provided in assembler instead of
    the previous huge amount of obscure C taken from NSPRLib.  This is
    more understandable (and almost certainly far smaller and quicker
    and doesn't need a hack to stop the compiler mis-optimising it!)
  Old short filename shares still had problems with the . and .. file
    filtering.  Programmer fault there - should've let the compiler do
    the optimisations :-)
  Server info string fixed to byte-reverse the port numbers when printing
    the string into the info buffer.  Now claims to be talking to port 139
    as it should.
Admin:
  Tested in general desktop use for several days, plus experimental versions
    tested in other boot ROMs.

Version 2.03. Tagged as 'LanManFS-2_03'
@
text
@d207 1
a207 1
       we store the comments too for *lanman:lmls to display.  Why is there
@


1.2
log
@  Support for long filename.
  Support for spaces in machine names.
  Merge of sbrodie_LanManFS_dev branch to trunk.
Detail:
  LanManFS 2.00 supports the "NT LM 0.12" protocol, enabling it to
    use long filenames on mounted shares.
Admin:
  Supporting documentation:
    1215,256/FS: LanManFS Software Functional Specification.
  Same as LanManFS-1_87_1_1_1_1_2_13.

Version 2.00. Tagged as 'LanManFS-2_00'
@
text
@d129 1
a129 1
#ifndef OMIT_UNUSED_FNS
d135 1
d167 1
a167 1
  int i;
d191 2
d206 4
d212 2
d215 1
a215 1
    if ( check_hidden( (char *)p) )
d218 1
a218 1
        Omni_AddInfo ( OAI_DISK, server, (char *)p );
d220 5
a224 1
        Omni_AddInfo ( OAI_PRINTER, server, (char *)p );
d238 1
d263 2
d278 2
d281 1
a281 1
    Omni_AddInfo ( OAI_SERVER, (char *)p, NULL );
d303 1
a303 1
  Omni_AddInfo ( OAI_SERVER, server, SMB_GetConnInfo(drv, GCI_SERVERINFO) );
@


1.1
log
@Initial revision
@
text
@d31 1
d475 1
d485 6
a490 1
  res = SMB_Transact ( drv, pipename, (struct TransactParms *) pvParmBlk );
@


1.1.1.1
log
@
LanManFS moved into Omni subdirectory.  Previous version in
RiscOS/Sources/Networking/LanManFS is now locked out.

The rest of Omni will be imported at a later date.

Version 1.87, tagged as LanManFS-1_87

@
text
@@


1.1.1.1.2.1
log
@  First cut at long filenames in LanManFS.  *Cat and *Ex work.
  Pretty much nothing else does.
Detail:
  Now uses long filenames if available, and switches to the advanced
    SMB protocol and Transact2 commands to do work with long filenames.
Admin:
  Work in progress.  End of week's work checkin point only.  Do not use.

Version 1.87, 1.1.1.1.2.2. Tagged as 'LanManFS-1_87-1_1_1_1_2_2'
@
text
@a30 1
#include <stddef.h>
a473 1
  struct TransactParms t;
d483 1
a483 6
  memcpy(&t, pvParmBlk, sizeof_TransactParms_external);
#ifdef LONGNAMES
  t.setup_in_len = 0;
  t.setup_out_maxlen = 0;
#endif
  res = SMB_Transact ( drv, pipename, &t );
@

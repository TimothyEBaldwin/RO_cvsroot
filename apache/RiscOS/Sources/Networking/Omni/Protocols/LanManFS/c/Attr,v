head	1.10;
access;
symbols
	LanManFS-2_62:1.10
	LanManFS-2_61:1.10
	LanManFS-2_60:1.10
	LanManFS-2_59:1.10
	LanManFS-2_58:1.10
	LanManFS-2_57:1.10
	LanManFS-2_56:1.10
	LanManFS-2_55:1.10
	LanManFS-2_54:1.10
	LanManFS-2_53:1.10
	LanManFS-2_52:1.10
	LanManFS-2_51:1.10
	LanManFS-2_50:1.10
	LanManFS-2_49:1.10
	LanManFS-2_48:1.10
	LanManFS-2_47:1.10
	LanManFS-2_46:1.10
	LanManFS-2_45:1.10
	LanManFS-2_44:1.10
	LanManFS-2_43:1.10
	LanManFS-2_42:1.10
	LanManFS-2_41:1.10
	LanManFS-2_40:1.10
	LanManFS-2_39:1.10
	LanManFS-2_38:1.10
	LanManFS-2_37:1.9
	LanManFS-2_36:1.9
	LanManFS-2_35:1.8
	LanManFS-2_34:1.7
	LanManFS-2_33:1.6
	LanManFS-2_32:1.6
	LanManFS-2_31:1.5
	RO_5_07:1.5
	LanManFS-2_30:1.5
	LanManFS-2_29:1.5
	LanManFS-2_28:1.4
	LanManFS-2_27:1.4
	LanManFS-2_26:1.4
	LanManFS-2_25:1.4
	LanManFS-2_24:1.3
	LanManFS-2_23:1.3
	LanManFS-2_22:1.2
	LanManFS-2_21:1.2
	LanManFS-2_20:1.2
	LanManFS-2_19:1.2
	LanManFS-2_18:1.2
	LanManFS-2_17:1.2
	LanManFS-2_16:1.2
	LanManFS-2_15:1.2
	LanManFS-2_14:1.2
	LanManFS-2_13:1.2
	LanManFS-2_12:1.2
	LanManFS-2_11:1.2
	LanManFS-2_10:1.2
	LanManFS-2_09:1.2
	LanManFS-2_08:1.2
	LanManFS-2_07:1.2
	LanManFS-2_06:1.2
	LanManFS-2_05:1.2
	LanManFS-2_04:1.2
	LanManFS-2_03:1.2
	LanManFS-2_02:1.2
	LanManFS-2_01:1.2
	LanManFS-2_00:1.2
	LanManFS-1_87-1_1_1_1_2_13:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_12:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_11:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_10:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_9:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_8:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_7:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_6:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_5:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_4:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_3:1.1.1.1
	LanManFS-1_87-1_1_1_1_2_2:1.1.1.1
	LanManFS-1_87-1_1_1_1_2_1:1.1.1.1
	sbrodie_LanManFS_dev:1.1.1.1.0.2
	sbrodie_LanManFS_dev_bp:1.1.1.1
	LanManFS-1_87:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.10
date	2012.11.11.20.43.15;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	3D5DE5lr2isCFZrw;

1.9
date	2012.04.14.20.57.32;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	W1UWVt811sQ2xS0w;

1.8
date	2011.12.14.11.02.49;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	CGImv1wEytvZ99Lv;

1.7
date	2009.08.01.08.10.26;	author rsprowson;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.15.16.00.08;	author bavison;	state Exp;
branches;
next	1.5;
commitid	GhZBwZ2GN8lg58Kt;

1.5
date	2004.01.09.11.28.01;	author bavison;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.16.18.14.17;	author rsprowson;	state Exp;
branches;
next	1.3;

1.3
date	2002.12.14.13.51.16;	author rsprowson;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.12.51.51;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	98.12.03.13.54.44;	author sbrodie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.12.03.13.54.44;	author sbrodie;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	99.01.08.14.04.18;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	99.01.11.15.35.22;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Fix and speed up EXT#handle=number doing nothing when number is beyond 2GB
Internally LanManFS was representing file offsets and data lengths as signed numbers, while in general this doesn't matter (they are passed through opaquely as just numbers and not manipulated) in a couple of places they were being used as while () loop exit conditions.
Function WriteZeroes (used when extending a file via OS_Args) therefore never performed the call to SMB_Write when beyond 2G because the loop condition was never met.
Additionally, it was literally transferring buffers of zeros across the network which is unnecessary as the server is documented as doing a zero fill itself, this represents at least a x40 speed up (on a slow 1MB/s drive write speed at the server end) or more.
Changed offset & lengths from int to uint.
Added the earlier CIFS spec (the later copy is missing section 5 for some reason) to docs.

Version 2.38. Tagged as 'LanManFS-2_38'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
*  Lan Manager client
*
*  Attr.C --  RISCOS file-type subsystem
*
*  Versions
*  18-08-94 INH Original
*
*/

/* System includes */

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "Interface/MimeMap.h"
#include "Global/FileTypes.h"

/* Our includes */

#include "stdtypes.h"

#include "Attr.h"
#include "SMB.h"
#include "Xlate.h"
#include "Omni.h"
#include "LanMan.h"
#include "LMVars.h"

/* "Default" filetype logic ------------------------------------- */

/* This is used when the file-type logic can't provide
   RISCOS attributes for the given filename (e.g. when they're
   DOS files, or someone's deleted the RISCOS.EA file).
*/

struct ext_type
{
  char *ext;
  int   type;
};

static const struct ext_type FTypes[] =
{
  { "TXT", 0xFFF },  /* Text */
  { "C",   0xFFF },
  { "H",   0xFFF },
  { "ASM", 0xFFF },
  { "JPG", 0xC85 },  /* JPEG */
  { "PS",  0xFF5 },  /* Postscript */
  { NULL,  0     }
};

/* ---------------- */

static void GetDefaultType ( char *leafname, RISCOS_ATTRIBS *ra )
{
  const struct ext_type *pET;
  int ftype;
  _kernel_swi_regs rset ;
  
  /* See if OmniFiler can help us */

  if ( Omni_GetDefaultType(leafname, &ftype) == OK )
  {
    debug2("Omni gave default type %X for '%s'\n", ftype, leafname );
    ra->loadaddr = (ra->loadaddr & 0xFFF000FF) |
                   ((ftype << 8) & 0x000FFF00);
    return;
  }

  leafname = strchr(leafname, '.');
  if ( leafname == NULL )  /* No extension */
  {
    debug2("Assuming filetype %03x for '%s' due to no suffix\n", LM_Vars.default_type, leafname );
    ra->loadaddr = (ra->loadaddr & 0xFFF000FF) |
                   (LM_Vars.default_type << 8);
    return;
  }

  leafname++;  /* Skip '.' */

  /* Have a look in the mimemap */
  rset.r[0] = MMM_TYPE_DOT_EXTN;
  rset.r[1] = (int)leafname;
  rset.r[2] = MMM_TYPE_RISCOS;
  if (_kernel_swi(MimeMap_Translate, &rset, &rset) == NULL)
  {
    ra->loadaddr = (ra->loadaddr & 0xFFF000FF) |
                   (rset.r[3] << 8);
    debug2("Mimemap gave type %X for '%s'\n", rset.r[3], leafname );
    return;
  }

  /* Look through the feable small table */
  for ( pET = FTypes; pET->ext != NULL; pET++ )
  {
    if ( strcmp ( pET->ext, leafname ) == 0 )
    {
      ra->loadaddr = (ra->loadaddr & 0xFFF000FF) |
                     (pET->type << 8);
      return;
    }
  }
}

/* Attribute-file logic --------------------------- */

/* We keep RISCOS attributes in a file "RISCOS.EA" in each
   directory. This consists of one or more 'ATTR_REC'
   structures as defined below.
*/

#define ATTR_FILENAME  "RISCOS.EA"

typedef struct
{
  char           name[16];
  RISCOS_ATTRIBS attr;
}
  ATTR_REC;

#define ATTR_REC_SIZE sizeof(ATTR_REC)


/* We also keep a cache of the attributes file, to avoid
   continual network traffic when reading a whole directory.
*/

#define CACHE_SIZE 128

/* This is set so that typically a whole RISCOS directory's
   worth (77 files) can be kept in the cache.
   13/6/96: change from 80 to 128 so that it's a whole number of
   disk sectors.
*/

static char     AttrFileName[DOS_NAME_LEN];
                               /* Name of file for which AttrCache
                                  holds entries */
static ATTR_REC AttrCache[CACHE_SIZE];
static int      AttrCacheLen;  /* Number of valid entries in cache */
static int      AttrCacheStart; /* Offset (in records) of first
                                   record in cache */

static bool     AttrAllInCache; /* This is set if the entire attrib file
                                is held in the cache, or if there is no
                                attrib. file. This cuts out a lot of
                                network activity when it is set. */

#define LEAFNAME_SIZE 16
static char AttrLeafName[LEAFNAME_SIZE];

/* ---------------------- */

/* SetFileName makes sure AttrFileName is the name of the
   attribute file for the file name given. If this involves
   a change to AttrFileName, the cache is invalidated.

   The name should always be in upper-case (as supplied by
   the Xlate conversion functions) to ensure the match works.
*/

static err_t SetFileName ( char *name )
{
  char *tmp;
  int path_len;  /* Length of file's pathname */

  tmp = strrchr(name, '\\'); /* Get pathname */
  if ( tmp == NULL )         /* Shouldn't actually happen! */
    return EBADNAME;

  strcpyn_upper ( AttrLeafName, tmp+1, LEAFNAME_SIZE );
  path_len = (tmp-name)+1; /* Length including last '\' */

  if ( strncmp ( AttrFileName, name, path_len ) == 0 &&
       strcmp ( AttrFileName+path_len, ATTR_FILENAME ) == 0
     )
    return OK;  /* Still in cache! */

  AttrCacheLen=0;  /* Invalidate cache */
  AttrAllInCache = false;

  /* Form filename */
  strncpy ( AttrFileName, name, path_len );
  strcpy ( AttrFileName+path_len, ATTR_FILENAME );
  return OK;
}



/* ----------------------------------------- */

static int GetEntryPos ( char *name )
{
  int i;
  char ch = name[0];   /* Used as speedup */

  for ( i=0; i<AttrCacheLen; i++ )
    if ( ch == AttrCache[i].name[0] &&
         strcmp ( name, AttrCache[i].name ) == 0 )
      return i;

  return -1;
}


/* ----------------------------- */

static int SearchFileForEntry ( int FH, char *name )
{
  uint len;
  int  pos;
  AttrCacheStart = 0;
  AttrAllInCache = false;

  while(1)
  {
    len = 0;
    SMB_Read ( FH, AttrCacheStart*ATTR_REC_SIZE,
                     CACHE_SIZE * ATTR_REC_SIZE,
               (BYTE *)AttrCache, &len );

    AttrCacheLen = len / ATTR_REC_SIZE;

    if ( AttrCacheStart == 0 && AttrCacheLen < CACHE_SIZE )
      AttrAllInCache = true;

    pos = GetEntryPos(name);
    if ( pos >= 0 )
      return pos;

    if ( AttrCacheLen < CACHE_SIZE ) /* No more file */
       return -1;

    AttrCacheStart+= AttrCacheLen;
  }
}

/* --------------------------- */

static bool CacheEmpty (void)
{
  int i;
  for ( i=0; i<AttrCacheLen; i++)
  {
    if (AttrCache[i].name[0] != 0)
      return false;
  }
  return true;
}

/* --------------------------- */

static void FileDataMove( int FH, uint from, uint to )
{
  /* ONLY WORKS IF FROM > TO */
  uint req_len, len;

  if (from <= to) return;
  req_len = from - to;

  do
  {
    len = 0;

    SMB_Read ( FH, from, req_len, (BYTE *)AttrCache, &len );
    if ( len != 0 )
      SMB_Write ( FH, to, len, (BYTE *)AttrCache, NULL );

    from += len;
    to += len;
  }
    while ( len == req_len );

  SMB_Truncate ( FH, to );
  AttrCacheLen = len / ATTR_REC_SIZE;
  AttrAllInCache = false;  /* Can't be sure, so assume not! */
}

/* ------------------------------------------------------ */

/* This routine determines which of the saved attributes are
   read back from the RISCOS.EA file, and which are still
   generated by converting from DOS.
*/

static void InsertAttribs ( RISCOS_ATTRIBS *src, RISCOS_ATTRIBS *dst )
{
  if ( (src->loadaddr & 0xFFF00000) != 0xFFF00000 )
  {
    /* If it's a load/exec address rather than time/date stamp */
    dst->loadaddr = src->loadaddr;
    dst->execaddr = src->execaddr;
  }
  else
  {
    /* Preserve time & date stamp given by DOS */
    dst->loadaddr = (dst->loadaddr & 0xFFF000FF) |
                    (src->loadaddr & 0x000FFF00);
  }
}

/* Attr_InvalidateDrive() --------------------------------- */

/* Called when the meaning of a drive letter changes, so that
   we can invalidate the cache.
*/

void Attr_InvalidateDrive( char drvletter )
{
  (void) drvletter; /* Ignore it */
  AttrCacheLen=0;  /* Invalidate cache */
  AttrAllInCache = false;
  AttrFileName[0] = 0;
}

/* Attr_GetInfo() ----------------------------------------- */

/*
   This attempts to fill in the RISCOS_ATTRIBS structure
   for the file given in 'filename'. As a convenience to the
   'read-directory' routine, it allows the leaf name to be passed
   in separately.
*/

#ifdef LONGNAMES
static err_t Attr_GetInfoX2 ( char *filename, char *leafname,
      RISCOS_ATTRIBS *pRA )
{
  char *lastcomma;
  if (Xlt_SplitLeafnameX2 ( (leafname != NULL) ? leafname : filename, pRA, &lastcomma ) != OK) {
    /* Something asked using a RISC OS name.  Need to do a lookup
     * for the file.
     */
    //GetDefaultType ( leafname, pRA );
    //return EATTRIBREAD;
  }
  return OK;
}
#endif

err_t Attr_GetInfo ( char *filename, char *leafname,
      RISCOS_ATTRIBS *pRA )
{
  int Attr_FH;  /* File handle for attrib file */
  int pos;
  DOS_ATTRIBS da;

#ifdef LONGNAMES
  if (SMB_IsLongNameFS(filename))
    return Attr_GetInfoX2 ( filename, leafname, pRA );
#endif

  if ( SetFileName(filename) != OK )
    return EBADNAME;

  if ( leafname != NULL )
    strcpyn_upper(AttrLeafName, leafname, LEAFNAME_SIZE);

  /* Is it already in cache? */

  pos = GetEntryPos(AttrLeafName);
  if ( pos >= 0 )
    goto got_pos;

  if ( AttrAllInCache )
    goto get_failed;

  /* Else, try to read from file */

  if ( SMB_Open ( MODE_RD, AttrFileName, &da, &Attr_FH, NULL ) == OK )
  {
    pos = SearchFileForEntry ( Attr_FH, AttrLeafName );
    SMB_Close (Attr_FH, &da);

    if ( pos >= 0 )
      goto got_pos;
  }
  else
  {
    AttrCacheLen = 0;
    AttrAllInCache = true;
  }

get_failed:
  GetDefaultType ( AttrLeafName, pRA );
  return EATTRIBREAD;

got_pos:
  InsertAttribs ( &AttrCache[pos].attr, pRA );


  return OK;
}

/* Note:

   This particular technique will leave behind data in the
   attrib. cache after the file has been closed. Potentially,
   another user could then change the contents of the attrib
   file, and when the cache is next used it will have stale data
   in. I don't think this is too much of a problem, however,
   as most actions will flush the cache, and updates to type
   information are relatively infrequent.

*/

/* ------------------------------------------ */

/* For the 'Delete' and 'Set' calls, we do not make use of data
   in the cache, as it is potentially stale and the consequences
   of using it are more severe.

   'Delete' works as follows:

   First, the block of the .EA file containing the record to be
   deleted is read into the cache. If no such record exists, we
   finish now. The record is then deleted by writing zeros over
   its 'name' field: this change is written back to disk.
   However, if all the entries in this cache block now contain
   zeroed names, the file is compacted by removing the whole
   cache block from the file.
*/

err_t Attr_DeleteInfo ( char *pathname )
{
  int Attr_FH;  /* File handle for attrib file */
  int pos;
  DOS_ATTRIBS da;

#ifdef LONGNAMES
  if (SMB_IsLongNameFS(pathname))
    return OK;
#endif

  if ( SetFileName(pathname) != OK )
    return EBADNAME;

  AttrAllInCache = false;

  /* Try to read/write the file */

  if ( SMB_Open ( MODE_RDWR, AttrFileName, &da, &Attr_FH, NULL ) != OK )
    return EATTRIBWRITE;

  /* Find position of entry */

  pos = SearchFileForEntry ( Attr_FH, AttrLeafName );

  if ( pos < 0 ) /* Can't find it: don't worry! */
    goto close_file;

  /* Found entry: zero it out */

  AttrCache[pos].name[0] = 0;

  if ( !CacheEmpty() )   /* Just update this one */
  {
    SMB_Write ( Attr_FH, (AttrCacheStart+pos)*ATTR_REC_SIZE,
                 ATTR_REC_SIZE,
               (BYTE *)&AttrCache[pos], NULL );
  }
  else
  {
    FileDataMove ( Attr_FH, (AttrCacheStart+AttrCacheLen) * ATTR_REC_SIZE,
                        AttrCacheStart * ATTR_REC_SIZE );
  }

close_file:
  SMB_Close(Attr_FH, &da);
  return OK;
}

/* ---------------------- */

/* Attr_SetInfo():

   Saves the RISCOS attribs for a given file. If the attrib. file
   doesn't exist it is created, & the new data is written to the
   end. Otherwise, we search through the file looking for a 'free'
   slot (with a 0 byte at the start of 'name'), which is filled
   in.
*/
extern err_t Attr_SetInfo ( char *pathname, RISCOS_ATTRIBS *pRA )
{
  err_t err;
  int Attr_FH;  /* File handle for attrib file */
  int pos;
  DOS_ATTRIBS da;

  debug1("SetInfo for '%s'\n", pathname);

#ifdef LONGNAMES
  /* Wonderfully enough, we don't actually need an implementation
   * of this at all!
   */
  if (SMB_IsLongNameFS(pathname))
    return OK;
#endif


  if ( SetFileName(pathname) != OK )
    return EBADNAME;

  AttrAllInCache = false;

  /* Try to read/write the file */

  err = SMB_Open ( MODE_RDWR, AttrFileName, &da, &Attr_FH, NULL );

  if ( err == OK )   /* File exists */
  {
    /* Look for existing entry - if there is one, amend it */
    pos = SearchFileForEntry ( Attr_FH, AttrLeafName );
    if ( pos >= 0 )
    {
      debug0("Found existing entry");
      goto write_new;
    }

    /* Look for free entry - if there is one, use it */
    pos = GetEntryPos ( "" );
    if ( pos >= 0 )
    {
      debug0("Found in-cache free entry");
      goto write_new;
    }

    pos = SearchFileForEntry ( Attr_FH, "" );
    if ( pos >= 0 )
    {
      debug0("Found file free entry");
      goto write_new;
    }

    /* Else, add new entry */

    if ( AttrCacheLen == CACHE_SIZE )
    {
      debug0("Adding new block to file");
      pos = 0;
      AttrCacheStart += AttrCacheLen;
      AttrCacheLen = 1;
    }
    else
    {
      debug0("Extending file");
      pos = AttrCacheLen;
      AttrCacheLen++;
    }
    goto write_new;
  }
  /* If attrib file doesn't exist, create one */
  else if ( err == EFILENOTFOUND )
  {
    da.utime = 0;
    da.attr = ATTR_HID | ATTR_NORM | ATTR_ARC;
    da.length = 0;
    err = SMB_Create ( AttrFileName, &da, &Attr_FH );
    debug1("Create attr file, res %d\n", err);
    if ( err == OK )
    {
      AttrCacheStart = 0;   /* Write new info at beginning of file */
      AttrCacheLen = 1;
      pos = 0;
      goto write_new;
    }
  }
  else
    debug2("Open '%s' gave error %d\n", AttrFileName, err);

  /* All attempts have failed! */
  return EATTRIBWRITE;

write_new:
  debug2(" - new entry at base %d pos %d", AttrCacheStart, pos );
  AttrAllInCache = false;
  strcpy(AttrCache[pos].name, AttrLeafName);
  AttrCache[pos].attr = *pRA;

  SMB_Write ( Attr_FH, (AttrCacheStart+pos)*ATTR_REC_SIZE,
                 ATTR_REC_SIZE,
               (BYTE *)&AttrCache[pos], NULL );

  SMB_Close(Attr_FH, &da);
  return OK;
}

/* ---------------------------------- */

/* This will remove the RISCOS.EA file from the given
   dir if it's effectively redundant. It's called before
   a 'delete directory' command, to make sure it doesn't
   fail because the RISCOS.EA file is still there!

   It works as follows: we read through RISCOS.EA, to see
   if any of the files it refers to actually exist. If
   none do, RISCOS.EA is deleted.

   Note that we use the 'AttrFileName' buffer for this;
   we clear it after use, because its must stay in step
   with the contents of the cache, as checked by
   SetFileName().
*/

void Attr_CheckEmptyDir (char *dirname)
{
  int  i, FH;
  uint pos, len;
  DOS_ATTRIBS da, da2;

  AttrAllInCache = false;
  AttrCacheLen = 0;

#ifdef LONGNAMES
  /* Shouldn't be any RISCOS.EA file present - user must delete it if
   * there is one - we're not hiding it away on long filename shares
   */
  if (SMB_IsLongNameFS(dirname))
    return;
#endif

  /* Open Attr file */

  sprintf ( AttrFileName, "%s\\%s", dirname, ATTR_FILENAME );

  if ( SMB_Open ( MODE_RD, AttrFileName, &da, &FH, NULL ) != OK )
    return;

  pos = 0;

  do
  {
    len = 0;
    SMB_Read ( FH, pos*ATTR_REC_SIZE,
                     CACHE_SIZE * ATTR_REC_SIZE,
               (BYTE *)AttrCache, &len );

    len /= ATTR_REC_SIZE;

    /* Try to find a file which exists */
    for ( i=0; i<len; i++ )
    {
      if ( AttrCache[i].name[0] != 0 )
      {
        sprintf ( AttrFileName, "%s\\%s", dirname, AttrCache[i].name );
        if (SMB_GetAttribs ( AttrFileName, &da2 ) == OK )
        {
          SMB_Close ( FH, &da );
          AttrFileName[0] = 0;
          return;
        }
      }
    }

    pos += len;
  }
    while ( len == CACHE_SIZE );

  /* If it doesn't, delete the attrib file */

  SMB_Close ( FH, &da );
  sprintf ( AttrFileName, "%s\\%s", dirname, ATTR_FILENAME );
  debug1("Deleting %s", AttrFileName);

  da.utime = 0;
  da.attr  = 0;  /* Reset hidden attribute */
  SMB_SetAttribs ( AttrFileName, &da );
  SMB_Delete ( AttrFileName );
  AttrFileName[0] = 0;
}


@


1.9
log
@Replace 2 (!) local definitions with MimeMap header

Version 2.36. Tagged as 'LanManFS-2_36'
@
text
@d228 2
a229 1
  int len, pos;
d271 1
a271 1
static void FileDataMove( int FH, int from, int to )
d274 1
a274 2
  int req_len;
  int len;
d276 2
a277 2
  req_len = (from-to);
  if ( req_len <= 0 ) return;
d284 1
a284 1
    if ( len > 0 )
d625 2
a626 1
  int i, FH, pos, len;
@


1.8
log
@CollectCallbacks -> usermode_donothing() the preferred AsmUtils name.
Retagged.
@
text
@a29 1

d31 2
@


1.7
log
@Fix for renames where only the case has changed.
Detail:
 Added an extra check after the Xlate path resolution code so that
 the case of the path given to resolve is honoured. This now means that
 the strcmp() done in SMB_Rename fails and the rename is actually sent to
 the server. Before "*rename test Test" would have the path resolved and
 since 'test' already existed both names would be the same, in this example
 something like "*rename A:\test A:\test" would result.
Admin:
 Made the non LONGNAMES version compile again (not tested).
 Removed local definitions of FSControl reason codes, uses Interface header
 now.
 Made the case of #includes match CVS to allow future compilation on a case
 sensitive system.
 Deleted unused "Version" header.

Version 2.34. Tagged as 'LanManFS-2_34'
@
text
@d256 1
a256 1
static bool CacheEmpty ()
@


1.6
log
@  Multiple fixes.
Detail:
  Too many to list here: see doc/RPSChanges.
Admin:
  Received from Rob Sprowson approx 2009-02-08. Builds, but not tested by ROOL.

Version 2.32. Tagged as 'LanManFS-2_32'
@
text
@d38 4
a41 4
#include "attr.h"
#include "smb.h"
#include "xlate.h"
#include "omni.h"
d347 1
a347 1
  if (Xlt_SplitLeafnameX2 ( leafname?leafname:filename, pRA, &lastcomma ) != OK) {
d510 1
a510 1
  /* Wonderfully ehough, we don't actually need an implementation
@


1.5
log
@  Changes from John.
Detail:
  > Default filetype now text
  >
  > Default type given to any file that has neither a dos extent, nor a
  > ',xxx' riscos extent at the server
  >
  > Ensure that files given the default type never have a ',xxx' riscos
  > extent appended.
  >
  > Add environment variable 'LMDefaultType' which checked for a default
  > type on module initialisation .. thus setting this to (e.g.) dos, then
  > rmreinitting LanManFS will change the default type to (e.g.) dos.
Admin:
  Not tested here yet.

Version 2.29. Tagged as 'LanManFS-2_29'
@
text
@d43 1
d58 1
a58 1
static struct ext_type FTypes[] =
d64 1
a64 2
  { "ARC", 0xDDC },  /* Spark */
  { "TIF", 0xFF0 },  /* TIFF File */
d73 1
a73 1
  struct ext_type *pET;
d89 6
a94 5
     {
     debug1("No suffix,assuming Text filetype for '%s'\n", leafname );
     ra->loadaddr = Default_FileType << 8;
     return;
     }
d103 6
a108 5
   {
   ra->loadaddr = rset.r[3] << 8;
   debug2("Mimemap gave type %X for '%s'\n", rset.r[3], leafname );
   return;
   }
d116 1
a116 1
                       (pET->type << 8);
a369 1

@


1.4
log
@Directory rename fixed - the mask being passed by the rename routine didn't
have the ATTR_DIR bit set.Discovered this after reading lots of the spec
which is also now included here in /doc.
Copying files out of LanManFS filer "forgot" their filetype even though
they appeared right in the filer,fixed.
A stray debugging printf removed,along with one compiler warning.
New sprites (yuck) to match !Omni.
Reordered the shutdown in two places,first Omni_Shutdown bins the mounts
lists which SMB_Shutdown uses.Second in NetBEUI mode the announcement that
a protocol has terminated goes *after* the shutdown - otherwise you sit
around for about 20s wondering where the link has gone.

Version 2.25. Tagged as 'LanManFS-2_25'
@
text
@d42 1
d90 2
a91 2
     debug1("No suffix,assuming DOS filetype for '%s'\n", leafname );
     ra->loadaddr = FileType_MSDOS << 8;
@


1.3
log
@LanmanFS help syntax corrected and tidied
Change lmls command to ListFS in line with NFS
Supress LF when ListFS is issued but there are no servers present.
Cast a few things to shut some compiler warnings up.
Addition of MimeMap lookups where the file has no ",ttt" style type
appended.Previously any such files were all reported as text files so
viewing a machine would typically show whole directories full of
identical filetypes.

Version 2.23. Tagged as 'LanManFS-2_23'
@
text
@a343 1

@


1.2
log
@  Support for long filename.
  Support for spaces in machine names.
  Merge of sbrodie_LanManFS_dev branch to trunk.
Detail:
  LanManFS 2.00 supports the "NT LM 0.12" protocol, enabling it to
    use long filenames on mounted shares.
Admin:
  Supporting documentation:
    1215,256/FS: LanManFS Software Functional Specification.
  Same as LanManFS-1_87_1_1_1_1_2_13.

Version 2.00. Tagged as 'LanManFS-2_00'
@
text
@d32 1
d74 2
a75 1

d80 1
a80 1
    debug1("Omni gave default type %X\n", ftype );
a84 4
  else
    debug1("Omni wouldn't translate '%s'", leafname );

  /* Get extension */
d88 5
a92 1
    return;
d96 12
@


1.1
log
@Initial revision
@
text
@d325 16
d349 6
d432 5
a484 1

d494 9
d614 8
@


1.1.1.1
log
@
LanManFS moved into Omni subdirectory.  Previous version in
RiscOS/Sources/Networking/LanManFS is now locked out.

The rest of Omni will be imported at a later date.

Version 1.87, tagged as LanManFS-1_87

@
text
@@


1.1.1.1.2.1
log
@  A few more battles have been won.  War finally starting to go my way.
Detail:
  LanManFS now uses ,xxx type notation on long filename shares.
  Character mappings improved (necessary because Windows allows so
    many extra daft characters to appear in filenames) and one-to-many
    mappings for awkward charcacters in the RISC OS->DOS world have
    been added.
  Directory searching improved so that the wildcard matching can be
    done properly.  Only Microsoft could provide you an API call to
    discover information about a filename specified with wildcards and
    NOT tell you which filename it matched. :-/
  Things remaining unimplemented so far:
    Setting filetypes.
    Creating files with specific types
    Renaming.
  All those outstanding things relate to the work done by Attr_SetInfo
    which should be the final major piece of hacking required.
Admin:
  Tested by connecting to a long filename share from both a RISC OS
    machine and a Windows NT machine.  All behaviour of the RISC OS
    machine has been verified against what the NT machine is seeing
    happening.  No surprises.  One-to-many character mappings are
    being matched correctly.
  Also tested using the Filer at the RISC OS end to navigate, run,
    and edit things on the remote share.

Version 1.87, 1.1.1.1.2.4. Tagged as 'LanManFS-1_87-1_1_1_1_2_4'
@
text
@a324 18
#ifdef LONGNAMES
static err_t Attr_GetInfoX2 ( char *filename, char *leafname,
      RISCOS_ATTRIBS *pRA )
{
  char *lastcomma;

  (void) leafname;

  if (Xlt_SplitLeafnameX2 ( leafname?leafname:filename, pRA, &lastcomma ) != OK) {
    /* Something asked using a RISC OS name.  Need to do a lookup
     * for the file.
     */
    //GetDefaultType ( leafname, pRA );
    //return EATTRIBREAD;
  }
  return OK;
}
#endif
a332 6
#ifdef LONGNAMES
  if (SMB_IsLongNameFS(filename))
    return Attr_GetInfoX2 ( filename, leafname, pRA );
#endif


a409 5
#ifdef LONGNAMES
  if (SMB_IsLongNameFS(pathname))
    return OK;
#endif

a458 6
#ifdef LONGNAMES
static err_t Attr_SetInfoX2 ( char *pathname, RISCOS_ATTRIBS *pRA )
{
}
#endif

a467 6
#ifdef LONGNAMES
  if (SMB_IsLongNameFS(pathname))
    return Attr_SetInfoX2 ( pathname, pRA );
#endif


a578 8

#ifdef LONGNAMES
  /* Shouldn't be any RISCOS.EA file present - user must delete it if
   * there is one - we're not hiding it away on long filename shares
   */
  if (SMB_IsLongNameFS(dirname))
    return;
#endif
@


1.1.1.1.2.2
log
@  First version which should contain everything required for full
    long filename support of SMB shares.
Detail:
  Renaming works; setting filetypes results in a rename occurring;
  setting load/exec/attributes works - causing a rename where
  appropriate; creation of files to overwrite existing objects of
  different types causes old file to be deleted first.
Admin:
  Tested briefly and everything seems happy both at the command-line
    and from the RISC OS Filer.  More thorough development testing can
    now commence properly.

Version 1.87, 1.1.1.1.2.5. Tagged as 'LanManFS-1_87-1_1_1_1_2_5'
@
text
@d331 2
d487 7
a503 3
  /* Wonderfully ehough, we don't actually need an implementation
   * of this at all!
   */
d505 1
a505 1
    return OK;
@

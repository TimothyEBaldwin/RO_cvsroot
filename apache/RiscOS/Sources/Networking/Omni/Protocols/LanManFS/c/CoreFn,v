head	1.14;
access;
symbols
	LanManFS-2_62:1.14
	LanManFS-2_61:1.14
	LanManFS-2_60:1.14
	LanManFS-2_59:1.14
	LanManFS-2_58:1.14
	LanManFS-2_57:1.14
	LanManFS-2_56:1.14
	LanManFS-2_55:1.14
	LanManFS-2_54:1.14
	LanManFS-2_53:1.14
	LanManFS-2_52:1.14
	LanManFS-2_51:1.14
	LanManFS-2_50:1.14
	LanManFS-2_49:1.14
	LanManFS-2_48:1.14
	LanManFS-2_47:1.14
	LanManFS-2_46:1.14
	LanManFS-2_45:1.14
	LanManFS-2_44:1.14
	LanManFS-2_43:1.13
	LanManFS-2_42:1.13
	LanManFS-2_41:1.13
	LanManFS-2_40:1.13
	LanManFS-2_39:1.12
	LanManFS-2_38:1.11
	LanManFS-2_37:1.10
	LanManFS-2_36:1.10
	LanManFS-2_35:1.10
	LanManFS-2_34:1.10
	LanManFS-2_33:1.9
	LanManFS-2_32:1.8
	LanManFS-2_31:1.7
	RO_5_07:1.7
	LanManFS-2_30:1.7
	LanManFS-2_29:1.7
	LanManFS-2_28:1.7
	LanManFS-2_27:1.6
	LanManFS-2_26:1.5
	LanManFS-2_25:1.5
	LanManFS-2_24:1.4
	LanManFS-2_23:1.4
	LanManFS-2_22:1.4
	LanManFS-2_21:1.4
	LanManFS-2_20:1.4
	LanManFS-2_19:1.4
	LanManFS-2_18:1.4
	LanManFS-2_17:1.4
	LanManFS-2_16:1.4
	LanManFS-2_15:1.4
	LanManFS-2_14:1.4
	LanManFS-2_13:1.4
	LanManFS-2_12:1.4
	LanManFS-2_11:1.4
	LanManFS-2_10:1.4
	LanManFS-2_09:1.4
	LanManFS-2_08:1.4
	LanManFS-2_07:1.4
	LanManFS-2_06:1.4
	LanManFS-2_05:1.4
	LanManFS-2_04:1.4
	LanManFS-2_03:1.4
	LanManFS-2_02:1.3
	LanManFS-2_01:1.3
	LanManFS-2_00:1.2
	LanManFS-1_87-1_1_1_1_2_13:1.1.1.1.2.7
	LanManFS-1_87-1_1_1_1_2_12:1.1.1.1.2.7
	LanManFS-1_87-1_1_1_1_2_11:1.1.1.1.2.7
	LanManFS-1_87-1_1_1_1_2_10:1.1.1.1.2.6
	LanManFS-1_87-1_1_1_1_2_9:1.1.1.1.2.5
	LanManFS-1_87-1_1_1_1_2_8:1.1.1.1.2.4
	LanManFS-1_87-1_1_1_1_2_7:1.1.1.1.2.4
	LanManFS-1_87-1_1_1_1_2_6:1.1.1.1.2.4
	LanManFS-1_87-1_1_1_1_2_5:1.1.1.1.2.3
	LanManFS-1_87-1_1_1_1_2_4:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_3:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_2:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_1:1.1.1.1
	sbrodie_LanManFS_dev:1.1.1.1.0.2
	sbrodie_LanManFS_dev_bp:1.1.1.1
	LanManFS-1_87:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.14
date	2014.01.19.16.21.15;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	0F8wGrpzbdHQgKlx;

1.13
date	2013.10.03.07.27.08;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	iTaBDwF1woaPMO7x;

1.12
date	2013.09.30.19.47.04;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	MoU9V9JbMV2FYu7x;

1.11
date	2012.11.11.20.43.15;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	3D5DE5lr2isCFZrw;

1.10
date	2009.08.01.08.10.27;	author rsprowson;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.19.22.24.58;	author rsprowson;	state Exp;
branches;
next	1.8;

1.8
date	2009.04.15.16.00.08;	author bavison;	state Exp;
branches;
next	1.7;
commitid	GhZBwZ2GN8lg58Kt;

1.7
date	2004.01.07.13.38.49;	author bavison;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.19.17.18.38;	author bavison;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.16.18.14.17;	author rsprowson;	state Exp;
branches;
next	1.4;

1.4
date	99.03.01.16.58.16;	author sbrodie;	state Exp;
branches;
next	1.3;

1.3
date	99.02.18.09.41.02;	author sbrodie;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.12.51.53;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	98.12.03.13.54.44;	author sbrodie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.12.03.13.54.44;	author sbrodie;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	98.12.11.17.26.25;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	99.01.08.14.04.20;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.01.11.15.35.23;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.4;

1.1.1.1.2.4
date	99.01.15.15.58.35;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.5;

1.1.1.1.2.5
date	99.02.03.12.51.31;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.6;

1.1.1.1.2.6
date	99.02.05.15.57.14;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.7;

1.1.1.1.2.7
date	99.02.10.14.55.47;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Make name cache flush unconditional
CoreFn.c:
The size returned by OS_File 5 might not match the size shown in the Filer viewer (or via *EX) because the last cached version was being returned. This would manifest itself as an error from !Edit if the file on the server had grown since last queried, when loading the file the amount of memory reserved was for the smaller (stale cache copy size).
The name cache is now always flushed on exit from the FileSwitch functions, this doesn't alter performance because the size was already being queried across the network, it was just that the result was overridden by the cached copy.
LanMan.c:
Be more robust and only capture the default driver name when it starts up.
This could be a problem if LanManFS starts after the ethernet driver, and the value of Inet$EtherType is unset. When the driver dies LanManFS would have taken that name as the default - leading to "Bad parameter" when trying to connect to a share.

Tested on IOMD with WinXP SP3.

Version 2.44. Tagged as 'LanManFS-2_44'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
*   C.CoreFn -- C core functions for new filing system
*
*
*   28-02-94 INH Original, derived from FSinC
*   1997.04.21 INH  Don't pass time of 0 to SMB_Close, fixes W95 bug
*
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"
#include "stdtypes.h"

#include "LanMan.h"
#include "Params.h"
#include "CoreFn.h"
#include "Xlate.h"
#include "Attr.h"
#include "SMB.h"
#include "Omni.h"
#include "Transact.h"
#include "NameCache.h"


#define NAMEBUF_LEN (2*DOS_NAME_LEN)
#define name_R(x) ((char *)R[x])

static char DOSnamebuf[NAMEBUF_LEN];
static err_t FileGetAttribs ( char *filename, DOS_ATTRIBS *pda,
    RISCOS_ATTRIBS *pra );

/* Read-directory subroutines ======================================= */
static int   RD_Reason;
static char *RD_BufPtr;
static int   RD_BufLen;
static int   RD_ReqCount;  /* No. of entries required */
static int   RD_CurCount;  /* No. of entries given */

/* Write one directory entry to the supplied buffer
 * The directory entries can take one of three forms, taking up
 * a variable degree of space
 */
static char *WriteEntry ( int reason, char *ptr, BYTE *entry, int format )
{
  static char namebuf[DOS_NAME_LEN];
  int name_len;
  int rec_len;
  DOS_ATTRIBS    da;
  RISCOS_ATTRIBS ra;
  int *IntPtr;

#ifndef LONGNAMES
  (void) format;
#else
  if (format == 1) {
    Xlt_ExpandSearchEntryX2(entry, DOSnamebuf, namebuf, &da, &ra);
  }
  else
#endif
    Xlt_ExpandSearchEntry(entry, DOSnamebuf, namebuf, &da, &ra);

  name_len = strlen(namebuf) + 1;
  debug1("WriteEntry (%s)\n", namebuf);
  
  switch ( reason )
  {
    case FSEntry_Func_Reason_ReadDirectoryEntries:
      rec_len = name_len;
      if (rec_len <= RD_BufLen) {
        memcpy(ptr, namebuf, name_len);
      }
      break;

    case FSEntry_Func_Reason_ReadDirectoriesAndInformation:
      rec_len = (20+name_len+3) & ~3;  /* Round up to whole word */
      if (rec_len <= RD_BufLen) {
        IntPtr = (int *)ptr;
        IntPtr[0] = ra.loadaddr;
        IntPtr[1] = ra.execaddr;
        IntPtr[2] = da.length;
        IntPtr[3] = ra.flags;
        IntPtr[4] = (da.attr & ATTR_DIR) ? 2 : 1;
        memcpy(ptr+20, namebuf, name_len);
      }
      break;

    case FSEntry_Func_Reason_ReadDirectoryEntriesAndInformation:
      rec_len = (29+name_len)+3 & ~3; /* Round up to whole word */
      if (rec_len <= RD_BufLen) {
        IntPtr = (int *)ptr;
        IntPtr[0] = ra.loadaddr;
        IntPtr[1] = ra.execaddr;
        IntPtr[2] = da.length;
        IntPtr[3] = ra.flags;
        IntPtr[4] = (da.attr & ATTR_DIR) ? 2 : 1;
        IntPtr[5] = 0;
        IntPtr[6] = ra.execaddr;
        ptr[28] = ra.loadaddr & 0xFF;
        memcpy(ptr+29, namebuf, name_len);
      }
      break;

    default:      /* Shouldn't get here */
      return ptr;
  }

  if (rec_len > RD_BufLen) {
    debug2("WriteEntry detects a buffer overflow (%d > %d)\n",
            rec_len, RD_BufLen);
    RD_BufLen = -1;
    return NULL;
  }

  RD_BufLen -= rec_len;
  return (ptr+rec_len);
}

/* ------------------------------ */

static err_t Dir_CallbackFn ( BYTE *entry, int format, bool *taken, void *pw )
{
  (void) pw;

  *taken = false;

#ifdef LONGNAMES
  /* Insert check for . and .. here */
  if (format == 1) {
    if (entry[23] == '.') {
      if (entry[22] == 1 || entry[24] == '\0') {
        return OK;
      }
      if (entry[24] == '.' && (entry[22] == 2 || entry[25] == '\0')) {
        return OK;
      }
    }
  }
  else
#endif
  if ( entry[9] == '.' ) {
    /* Ignore '.' and '..' directories */
    if (entry[10] == '.' && entry[11] == '\0' || entry[10] == '\0') {
      return OK;
    }
  }

  if ( RD_ReqCount > 0 ) {
    char *w_result = WriteEntry ( RD_Reason, RD_BufPtr, entry, format );
    if (w_result != NULL) {
      RD_BufPtr = w_result;
      RD_ReqCount--;
      RD_CurCount++;
      *taken = true;
    }
    else {
      debug0("Oh dear - client ran out of buffer space!\n");
      return EOUTOFMEM;
    }
  }

  return OK;
}

/* ----------------- */

/* Called in 2 situations
 *   - starting a search from scratch (dir_offset = 0)
 *   - continuing a search (dir_offset != 0)
 * The underlying SMB routine must track whether it has been called
 * recursively or from within Xlt_NameROtoDOSX2_sub and deal with
 * abandoning searches appropriately.
 */
static err_t Func_ReadDir ( int reason, char *path_name, char *buffer,
       int n_names, int dir_offset, int buflen, int *pOutNread,
       int *pOutNextOffset )
{
  static Transact_SearchContext con;
  int    one_name;
  err_t  res;

  debug2 ( "\n\n>> ReadDir reason %d path %s", reason, path_name );
  debug2 ( " offset %d count %d", dir_offset, n_names );
  debug1 ( " buflen %d\n", buflen);

  /* Make sure the number of names we read will fit into buffer */
  one_name = (reason == FSEntry_Func_Reason_ReadDirectoryEntries) ? 16 :
             (reason == FSEntry_Func_Reason_ReadDirectoriesAndInformation) ? 36 : 44;

#ifdef LONGNAMES
  /* Of course, the above calculation assumes that the filename is at most
   * 16 characters long (8 + '.' + 3 + \0 + 3 bytes pad).  This is
   * useless for long filename shares and so the n_names parameter is
   * accepted in place, and the buffer writer updated to be able to
   * avoid and flag buffer overflow.  In the worst case, this may mean
   * multiple searches are required, however, as long as the directory
   * reading function SMB_ReadDirEntriesX2 is intelligent, it can remember
   * the resume keys and last successful filename data for the search and
   * attempt to keep our caller in step with the remote server.
   *
   * The limit is still performed as it is still useful for avoiding
   * unnecessary buffer overruns - especially when there are not very
   * many files with long names or even no files with long names.
   */
#endif
  if ( (n_names * one_name) > buflen ) n_names = buflen/one_name;
  if ( n_names <= 0 ) return EBADPARAM;
  debug1( "Adjusted count=%d\n", n_names );
  RD_Reason = reason;
  RD_BufPtr = buffer;
  RD_BufLen = buflen;
  RD_CurCount = 0;
  RD_ReqCount = n_names;

  /* Convert path adding wildcard search spec */
  res = Xlt_ConvertPath( path_name, DOSnamebuf );
  if ( res != OK ) return res;
  if ( DOSnamebuf[strlen( DOSnamebuf ) - 1] != '\\' )
    strcat( DOSnamebuf, "\\");
#ifdef LONGNAMES
  strcat( DOSnamebuf, "*" );
#else
  strcat( DOSnamebuf, "????????.???" );
#endif

  /* Start a new search? */
  if (dir_offset == 0)
  {
    debug2( ">> Start search (%s) count %d\n", DOSnamebuf, RD_ReqCount);
    con.resume_key = 0;
    res = SMB_ReadDirEntries ( DOSnamebuf, RD_ReqCount,
                               Dir_CallbackFn, NULL, &con );
  }
  else {
    con.resume_key = dir_offset;
    res = OK;
  }

  /* Continue search, if needs be */
  while ( res == OK  &&     /* More names available */
          RD_ReqCount > 0 ) /* More names wanted */
  {
    debug3( ">> Continue search (%s) count %d resume %08x\n", DOSnamebuf, RD_ReqCount, con.resume_key);
    res = SMB_ReadDirEntries ( DOSnamebuf, RD_ReqCount,
                               Dir_CallbackFn, NULL, &con );
  }

  /* Process results */
  if (res == EOUTOFMEM && RD_BufLen == -1) {
    /* Special result when client buffer space exhausted */
    debug0("Client buffer space was exhausted\n");
    res = OK;
  }
  debug2("End search, res=%d RD_ReqCount=%d\n", res, RD_ReqCount);

  if ( res != OK ) {  /* Ran out of files, or error */
    *pOutNextOffset = -1;
  }
  else
    *pOutNextOffset = con.resume_key;

  *pOutNread = RD_CurCount;
  if ( res == ENOMOREFILES )
    return OK;

  return res;
}

/* Func ============================================================= */

_kernel_oserror *fsentry_func ( int *R )
{
  err_t err;

  debug1("FS_func(%d)", R[0] );

  switch ( R[0] )
  {
    case FSEntry_Func_Reason_SetCurrentDirectory:
      /* Although we don't maintain a current directory,
         we use this to keep track of the current drive */

      err = Xlt_ConvertPath( name_R(1), DOSnamebuf);
      if ( err == OK ) Xlt_SetDefaultDrv ( DOSnamebuf );
      break;

    case FSEntry_Func_Reason_SetLibraryDirectory:
    case FSEntry_Func_Reason_CatalogueDirectory:
    case FSEntry_Func_Reason_ExamineCurrentDirectory:
    case FSEntry_Func_Reason_CatalogueLibraryDirectory:
    case FSEntry_Func_Reason_ExamineLibraryDirectory:
    case FSEntry_Func_Reason_ExamineObjects:
    case FSEntry_Func_Reason_ReadCurrentDirectoryNameAndPrivilegeByte:
    case FSEntry_Func_Reason_ReadLibraryDirectoryNameAndPrivilegeByte:
    case FSEntry_Func_Reason_SetDirectoryContexts:
    case FSEntry_Func_Reason_AccessObjects:
    case FSEntry_Func_Reason_OutputFullInformationOnObjects:
      err = ENORISCOS2;
      break;

    case FSEntry_Func_Reason_RenameObject:
      err = Xlt_ConvertPath( name_R(1), DOSnamebuf);
      if ( err == OK ) err = Xlt_ConvertPath( name_R(2), DOSnamebuf+DOS_NAME_LEN );
#ifdef LONGNAMES
      {
        DOS_ATTRIBS    da;
        RISCOS_ATTRIBS ra;

        err = FileGetAttribs ( DOSnamebuf, &da, &ra );
        if ( err == EFILENOTFOUND || err == EPATHNOTFOUND )
        {
          err = OK;
        }

        if ( err == OK )
        {
          /* Trim any RO extension and append the ones from the source instead */
          Xlt_RemoveROType ( DOSnamebuf + DOS_NAME_LEN );
          if ((da.attr & ATTR_DIR) == 0)
          {
            Xlt_AddROType ( DOSnamebuf + DOS_NAME_LEN, ra.loadaddr );
          }
        }
      }
#endif
      if ( err == OK )
      {
        err = SMB_Rename ( DOSnamebuf, DOSnamebuf+DOS_NAME_LEN );
      }

#ifdef LONGNAMES
      if (SMB_IsLongNameFS(DOSnamebuf + DOS_NAME_LEN))
      {
         if ( err == EBADRENAME )
         {
           R[1] = 1;
           err = OK;
         }
         else
         {
           R[1] = 0;
         }
         break;
      }
      /* Don't bother with any of this rubbish for long filename discs */
#endif

      if ( err == OK )  /* If rename worked, swap attribs */
      {
        RISCOS_ATTRIBS ra;
        ra.loadaddr = 0xFFF00000;
        ra.execaddr = 0;
        ra.flags = ROA_READ | ROA_WRITE;   
        if ( Attr_GetInfo ( DOSnamebuf, NULL, &ra ) == OK )
        {
          Attr_DeleteInfo ( DOSnamebuf );
          Attr_SetInfo ( DOSnamebuf + DOS_NAME_LEN, &ra );
        }
        R[1] = 0;
      }
      else if ( err == EBADRENAME )
      {
        R[1] = 1; /* Indicate failure */
        err = OK;
      }
      break;

    case FSEntry_Func_Reason_SetFilingSystemOptions:
    case FSEntry_Func_Reason_ReadNameAndBootOptionOfDisc:
      err = ENOTPRESENT;
      break;

    /* SNB 980225.  Must identify and boot on request from OS! */
    case FSEntry_Func_Reason_PrintStartUpBanner:
      (void) _swix(OS_Write0, _IN(0), "Acorn LanManFS\n\r");
      err = OK;
      break;

    case FSEntry_Func_Reason_BootFilingSystem:
      LM_Boot();
      err = OK;
      break;

    case FSEntry_Func_Reason_ShutDown:
      /* On shutdown, disconnect all drives */
      err = SMB_Shutdown();
      break;

    case FSEntry_Func_Reason_ReadDirectoryEntries:
    case FSEntry_Func_Reason_ReadDirectoriesAndInformation:
    case FSEntry_Func_Reason_ReadDirectoryEntriesAndInformation:
      err = Func_ReadDir ( R[0], name_R(1), name_R(2),
               R[3], R[4], R[5], &R[3], &R[4] );
      break;

    default:
      err = EBADPARAM;
      break;
  }

#ifdef LONGNAMES
  NameCache_Flush(ncf_FSFUNC_EXIT);
#endif

  return MsgError(err);
}


/* File  =================================================== */

static err_t FileGetAttribs ( char *filename, DOS_ATTRIBS *pda,
    RISCOS_ATTRIBS *pra )
{
  err_t err;

  debug1("FileGetAttribs(%s) ... \n", filename);
  err = SMB_GetAttribs ( filename, pda );
  if ( err == OK )
  {
    Xlt_CnvDOStoRO ( pda, pra, CNV_DATETIME | CNV_ATTRIBS );
    Attr_GetInfo ( filename, NULL, pra );
  }
  return err;
}

/* ------------------- */

_kernel_oserror *fsentry_file( int *R )
{
  err_t err;
  int FH;
  int tmp;
  DOS_ATTRIBS    da;
  RISCOS_ATTRIBS ra;
  
  debug1("FS_file(%d)", R[0] );

  err = Xlt_ConvertPath ( name_R(1), DOSnamebuf );

  /* This is a bodge to stop cmd-line 'copies' with wildcards
     not working! */

  if ( err == ENOWILDCARD  &&
       (R[0] == FSEntry_File_Reason_ReadCatalogueInformationNoLength ||
        R[0] == FSEntry_File_Reason_ReadCatalogueInformation )
     )
  {
    R[0] = 0;
    return MsgError(OK);
  }

  if ( err != OK )
    return MsgError(err);

  switch ( R[0] )
  {
    case FSEntry_File_Reason_CreateFile:
    case FSEntry_File_Reason_SaveFile:
      ra.loadaddr = R[2];
      ra.execaddr = R[3];
      ra.flags    = ROA_READ | ROA_WRITE;
      Xlt_CnvROtoDOS(&ra, &da, CNV_DATETIME | CNV_ATTRIBS );
#ifdef LONGNAMES
      strncpy(DOSnamebuf + DOS_NAME_LEN, DOSnamebuf, DOS_NAME_LEN);
      if (Xlt_AddROType(DOSnamebuf, ra.loadaddr)) {
        /* We changed the filetype - therefore delete old file */
        err = SMB_Delete(DOSnamebuf + DOS_NAME_LEN);
        if (err != OK && err != EFILENOTFOUND) {
           /* Oh dear - looks likely the create would fail anyway! */
           break;
        }
      }
#endif

      err = SMB_Create ( DOSnamebuf, &da, &FH );
      if ( err == OK )
      {
        if ( R[0] == FSEntry_File_Reason_SaveFile )
        {
          err = SMB_Write ( FH, 0, /* Offset */
                            R[5]-R[4], /* Len */
                   (BYTE *)(R[4]),     /* Where */
                            NULL );
        }
        else if ( R[0] == FSEntry_File_Reason_CreateFile )
        {
          err = SMB_Truncate ( FH, R[5]-R[4] );
        }
        SMB_Close ( FH, &da );

        Attr_SetInfo ( DOSnamebuf, &ra );
      }

      R[6] = (int) Xlt_GetRISCOSLeafName(name_R(1));
      break;

    case FSEntry_File_Reason_LoadFile:
      err = SMB_Open ( MODE_RD, DOSnamebuf, &da, &FH, &tmp );

      if ( err == OK )
      {
        err = SMB_Read ( FH, 0, da.length, (BYTE *)(R[2]), NULL );
        SMB_Close ( FH, &da);

        Xlt_CnvDOStoRO( &da, &ra, CNV_DATETIME | CNV_ATTRIBS );
        Attr_GetInfo ( DOSnamebuf, NULL, &ra );
        R[2] = ra.loadaddr;
        R[3] = ra.execaddr;
        R[4] = da.length;
        R[5] = ra.flags;
      }

      R[6] = (int) Xlt_GetRISCOSLeafName(name_R(1));
      break;


    /* Read/write file attribute calls ------------------- */

    case FSEntry_File_Reason_WriteLoadAddress:
    case FSEntry_File_Reason_WriteExecutionAddress:
    case FSEntry_File_Reason_WriteAttributes:
      /* Get current attributes */
      err = FileGetAttribs ( DOSnamebuf, &da, &ra );
      if ( err == EFILENOTFOUND || err == EPATHNOTFOUND )
      {
        err = OK;
        break;
      }

      if ( R[0] == FSEntry_File_Reason_WriteLoadAddress )
      {
        ra.loadaddr = R[2];
        Xlt_CnvROtoDOS ( &ra, &da, CNV_DATETIME );
#ifdef LONGNAMES
      {
        if (da.attr & ATTR_DIR)
                ;
        else {
          strncpy(DOSnamebuf + DOS_NAME_LEN, DOSnamebuf, DOS_NAME_LEN);
          if (Xlt_AddROType(DOSnamebuf + DOS_NAME_LEN, ra.loadaddr)) {
            err = SMB_Rename(DOSnamebuf, DOSnamebuf + DOS_NAME_LEN);
            if (err != OK) break;
            strcpy(DOSnamebuf, DOSnamebuf + DOS_NAME_LEN);
          }
        }
      }
#endif
      }
      else if ( R[0] == FSEntry_File_Reason_WriteExecutionAddress )
      {
        ra.execaddr = R[3];
        Xlt_CnvROtoDOS ( &ra, &da, CNV_DATETIME );
      }
      else if ( R[0] == FSEntry_File_Reason_WriteAttributes )
      {
        ra.flags = R[5];
        Xlt_CnvROtoDOS ( &ra, &da, CNV_ATTRIBS );
      }

      Attr_SetInfo ( DOSnamebuf, &ra );
      err = SMB_SetAttribs ( DOSnamebuf, &da );
      break;

    case FSEntry_File_Reason_WriteCatalogueInformation:
      ra.loadaddr = R[2];
      ra.execaddr = R[3];
      ra.flags = R[5];

#ifdef LONGNAMES
      {
        RISCOS_ATTRIBS test_ra;
        err = FileGetAttribs ( DOSnamebuf, &da, &test_ra );
        if (err == OK && (da.attr & ATTR_DIR))
                ;
        else {
          strncpy(DOSnamebuf + DOS_NAME_LEN, DOSnamebuf, DOS_NAME_LEN);
          if (Xlt_AddROType(DOSnamebuf + DOS_NAME_LEN, ra.loadaddr)) {
            err = SMB_Rename(DOSnamebuf, DOSnamebuf + DOS_NAME_LEN);
            if (err != OK) break;
            strcpy(DOSnamebuf, DOSnamebuf + DOS_NAME_LEN);
          }
        }
      }
#endif

      Xlt_CnvROtoDOS ( &ra, &da, CNV_ATTRIBS | CNV_DATETIME );
      Attr_SetInfo ( DOSnamebuf, &ra );
      err = SMB_SetAttribs ( DOSnamebuf, &da );
      break;

    case FSEntry_File_Reason_DeleteObject:
      err = FileGetAttribs ( DOSnamebuf, &da, &ra );
      if ( err == OK )
      {
        R[2] = ra.loadaddr;
        R[3] = ra.execaddr;
        R[4] = da.length;
        R[5] = ra.flags;

        if ( da.attr & ATTR_DIR )
        {
          R[0] = 2;
          Attr_CheckEmptyDir ( DOSnamebuf );
          err = SMB_RmDir ( DOSnamebuf );
        }
        else
        {
          R[0] = 1;
          err = SMB_Delete ( DOSnamebuf );
        }

        if ( err==OK )
          Attr_DeleteInfo ( DOSnamebuf );
      }
      break;

    case FSEntry_File_Reason_CreateDirectory:
#ifdef LONGNAMES
      Xlt_RemoveROType ( DOSnamebuf );
#endif
      err = SMB_MkDir ( DOSnamebuf );
      break;

    /* Read information calls ---------------------------- */

    case FSEntry_File_Reason_ReadCatalogueInformationNoLength:
    case FSEntry_File_Reason_ReadCatalogueInformation:
      err = FileGetAttribs ( DOSnamebuf, &da, &ra );
      if ( err == OK )
      {
        if ( da.attr & ATTR_DIR )
          R[0] = 2;
        else
          R[0] = 1;

        R[2] = ra.loadaddr;
        R[3] = ra.execaddr;
        R[4] = da.length;
        R[5] = ra.flags;
      }
      else if ( err == EFILENOTFOUND || err == EPATHNOTFOUND )
      {
        R[0] = 0;
        err = OK;
      }
      break;

    default:
      err = EBADPARAM;
      break;
  }

#ifdef LONGNAMES
  NameCache_Flush(ncf_FSFILE_EXIT);
#endif

  return MsgError(err);
}

/* Open/Close subroutines --------------------------------------- */

#define MAXFILES 30

static struct FileInfo
{
  bool Free;        /* -1 indicates this file not in use */
  int SMB_FH;       /* File handle for SMB use */

  DOS_ATTRIBS da;
  int filesw_id;    /* Fileswitch handle for the file */

}
  FileTbl[MAXFILES];

static int NextHandle;

/* --------------- */

static int NewHandle(void)
{
  int i;

  if ( NextHandle >= MAXFILES ) NextHandle = 0;

  if ( FileTbl[NextHandle].Free )
    return NextHandle++;

  for ( i=0; i<MAXFILES; i++)
  {
    if (FileTbl[i].Free)
    {
      NextHandle=i+1;
      return i;
    }
  }

  return -1;
}


/* Open  =================================================== */

_kernel_oserror *fsentry_open( int *R )
{
  err_t err;
  int fid;
  int modes=0;
  struct FileInfo *pFI;
  RISCOS_ATTRIBS ra;

  debug1("FS_open(%d)", R[0]);

  /* Convert to DOS name & allocate handle */

  err = Xlt_ConvertPath ( name_R(1), DOSnamebuf );

  if ( err != OK )
    return MsgError(err);

  fid = NewHandle();
  if ( fid < 0 )
    return MsgError(ENOHANDLES);

  pFI = &FileTbl[fid];
  pFI->filesw_id = R[3];

  switch ( R[0]  )
  {
    case FSEntry_Open_Reason_OpenRead:
      err = SMB_Open ( MODE_RD, DOSnamebuf,
            &pFI->da, &pFI->SMB_FH, &modes );
      break;

    case FSEntry_Open_Reason_Update:
      err = SMB_Open ( MODE_RDWR, DOSnamebuf,
              &pFI->da, &pFI->SMB_FH, &modes );

      if ( err == ENOACCESS )
      {
        err = SMB_Open ( MODE_RD, DOSnamebuf,
                &pFI->da, &pFI->SMB_FH, &modes );
      }

      break;

    case FSEntry_Open_Reason_CreateUpdate:
      ra.execaddr = 0;  /* Not called by RISCOS 3?? */
      ra.loadaddr = 0;  /* If so, should be the current time */
      ra.flags  = ROA_READ | ROA_WRITE;
      Xlt_CnvROtoDOS ( &ra, &pFI->da, CNV_DATETIME | CNV_ATTRIBS );
      err = SMB_Create ( DOSnamebuf, &pFI->da, &pFI->SMB_FH );
      pFI->da.length = 0;
      modes = MODE_RDWR;
      break;

    default:
      err = EBADPARAM;
      break;

  }

  if ( err == OK )
  {
    pFI -> Free = false;
    R[0] = (modes == MODE_RD ) ? OPEN_Readable :
           (modes == MODE_RDWR ) ? OPEN_Readable | OPEN_Writable :
           (modes == MODE_WR ) ? OPEN_Writable : 0;

    R[1] = fid+1;
    R[2] = 512; /* Buffer size - doesn't really matter */
    R[3] = pFI->da.length;
    R[4] = (R[3] + 511) & ~511;

  }
  else
  {
    R[1] = 0;
#ifdef LONGNAMES
    /* Take a risk to enhance cacheing :-) */
    NameCache_Flush(ncf_FSOPEN_EXIT);
#endif
  }
  return MsgError(err);
}

/* GetBytes  =================================================== */

_kernel_oserror *fsentry_getbytes( int *R )
{
  int fid = R[1]-1;

  if ( fid < 0 || fid >= MAXFILES || FileTbl[fid].Free )
    return MsgError(EBADPARAM);

  return MsgError( SMB_Read (FileTbl[fid].SMB_FH,
                      R[4],      /* Offset */
                      R[3],      /* Length */
             (BYTE *)(R[2]),     /* Where */
                      NULL ) );

}

/* PutBytes  =================================================== */

_kernel_oserror *fsentry_putbytes( int *R )
{
  int fid = R[1]-1;

  if ( fid < 0 || fid >= MAXFILES || FileTbl[fid].Free )
    return MsgError(EBADPARAM);

  return MsgError ( SMB_Write (FileTbl[fid].SMB_FH,
                      R[4],      /* Offset */
                      R[3],      /* Length */
             (BYTE *)(R[2]),     /* Where */
                      NULL ) );
}

/* GBPB  =================================================== */

_kernel_oserror *fsentry_gbpb( int *R )
{
  (void)R;
  return MsgError(ENOGBPB);
}

/* Close  =================================================== */

_kernel_oserror *fsentry_close( int *R )
{
  err_t err;
  RISCOS_ATTRIBS ra;

  int fid = R[1]-1;

  if ( fid < 0 || fid >= MAXFILES || FileTbl[fid].Free )
    return MsgError(EBADPARAM);

  /* On entry, R2/R3 contain new timestamp for file.
     This call will be unable to alter the file-type as
     recorded by Attr_SetInfo: we don't know the file name */

  if ( R[2] != 0 || R[3] != 0 )
  {
    /* IH: Windows 95 doesn't recognise a NULL timestamp field. */
    ra.loadaddr = R[2];
    ra.execaddr = R[3];
    Xlt_CnvROtoDOS ( &ra, &FileTbl[fid].da, CNV_DATETIME );
  }

  err=SMB_Close( FileTbl[fid].SMB_FH, &FileTbl[fid].da);
  FileTbl[fid].Free = true;
  return MsgError(err);
}

/* Args ========================================== */

static err_t WriteZeros ( int FH, uint offset, uint len )
{
  uint  tmp;
  err_t res=OK;

  memset ( DOSnamebuf, 0, NAMEBUF_LEN );

  while ( len > 0 )
  {
#if 0
    tmp = min(NAMEBUF_LEN, len);
    res = SMB_Write ( FH, offset, tmp, (BYTE *)DOSnamebuf, NULL );
#else
    /* SMB_Write uses the write bytes command (v1-spec-02 section 5.22)
     * which states that any bytes between the previous EOF and the new
     * one are filled to zero by the server - so don't waste time
     * sending them over the network. However, very large extends can
     * end up with a timeout, so the extend is chopped up a bit assuming
     * the server can write at least 1MB/s to the disc.
     * SMB_Truncate pends all the zero filling which leads to a timeout
     * when closing the file, so we just write 1 byte of 0 each jump.
     */
    tmp = min(1024 * 1024 * (REPLY_TIMEOUT / 100), len);
    if ( offset == 0 )
      res = SMB_Write ( FH, 0, 1, (BYTE *)DOSnamebuf, NULL );
    else
      res = SMB_Write ( FH, offset - 1, 1, (BYTE *)DOSnamebuf, NULL );
#endif
    if ( res != OK ) break;
    offset += tmp;
    len -= tmp;
  }
  return res;
}

/* --------------------- */

_kernel_oserror *fsentry_args( int *R )
{
  err_t err=OK;
  int fid = R[1]-1;
  uint tmp;

  debug1("FS_args(%d)\n", R[0]);

  if ( fid < 0 || fid >= MAXFILES || FileTbl[fid].Free )
    return MsgError(EBADPARAM);

  switch( R[0] )
  {
    case FSEntry_Args_Reason_ReadSequentialFilePointer:
    case FSEntry_Args_Reason_WriteSequentialFilePointer:
    case FSEntry_Args_Reason_ReadFileExtent:
    case FSEntry_Args_Reason_EOFCheck:
      err = ENOUNBUFF;
      break;

    case FSEntry_Args_Reason_WriteFileExtent:
      err = SMB_Truncate ( FileTbl[fid].SMB_FH, R[2] );
      break;

    /* We ignore this call - WriteFileExtent is used to truncate */

    case FSEntry_Args_Reason_EnsureFileSize:
      err = OK;
      break;

    case FSEntry_Args_Reason_ReadSizeAllocatedToFile:
      err = SMB_GetLength ( FileTbl[fid].SMB_FH, &tmp );
      if ( err == OK )
        R[2] = tmp;
      break;

    case FSEntry_Args_Reason_FlushFileBuffer:
      err = SMB_Flush ( FileTbl[fid].SMB_FH );
      break;

    case FSEntry_Args_Reason_WriteZerosToFile:
      err = WriteZeros ( FileTbl[fid].SMB_FH,
                         (uint)R[2], /* Offset */
                         (uint)R[3]  /* Length */  );
      break;

    case FSEntry_Args_Reason_ReadFileDateStamp:
      {
        /* This call will be unable to correctly get the file type */
        /* If this is needed, it must be done when the file is opened */
        RISCOS_ATTRIBS ra;
        Xlt_CnvDOStoRO ( &FileTbl[fid].da, &ra, CNV_DATETIME );

        R[2] = ra.loadaddr;
        R[3] = ra.execaddr;
      }
      err = OK;
      break;

    default:
      err = EBADPARAM;
      break;
  }

  return MsgError(err);
}

/* Init --------------------------------- */

bool FS_Init(void)
{
  int i;
  for ( i=0; i<MAXFILES; i++ )
    FileTbl[i].Free = true;
  NextHandle = 0;

  return true;
}

@


1.13
log
@Internationalised
Unused LMFiler put in the attic.
As LanMan has historically put its resources into ThirdPart/OmniClient this component has no ROM resources phase - it still registers the resources at run time.

Version 2.40. Tagged as 'LanManFS-2_40'
@
text
@a289 1
  bool  flushnames = false;
a344 1
        flushnames = true;
a397 1
      flushnames = true;
a402 1
      flushnames = true;
d418 1
a418 1
  if (flushnames) NameCache_Flush(ncf_FSFUNC_EXIT);
a450 1
  bool flushnames = false;
a478 1
      flushnames = true;
a545 1
      flushnames = true;
a583 1
      flushnames = true;
a614 1
        flushnames = true;
a637 1
      flushnames = true;
d670 1
a670 1
  if (flushnames) NameCache_Flush(ncf_FSFILE_EXIT);
@


1.12
log
@Makefile recreated from fragments
Fixed up a couple of trivial warnings with the stricter checking.
Removed OmniS_FastMultiply64 and rewrote the function in C, this allows the compiler to spot and use UMULL on architectures supporting that instruction.
Tested in a RAM build against a WinXP SP3 server with a drive > 4GB.

Version 2.39. Tagged as 'LanManFS-2_39'
@
text
@d425 1
a425 1
  return Xlt_Error(err);
d470 1
a470 1
    return Xlt_Error(OK);
d474 1
a474 1
    return Xlt_Error(err);
d683 1
a683 1
  return Xlt_Error(err);
d744 1
a744 1
    return Xlt_Error(err);
d748 1
a748 1
    return Xlt_Error(ENOHANDLES);
d809 1
a809 1
  return Xlt_Error(err);
d819 1
a819 1
    return Xlt_Error(EBADPARAM);
d821 1
a821 1
  return Xlt_Error( SMB_Read (FileTbl[fid].SMB_FH,
d836 1
a836 1
    return Xlt_Error(EBADPARAM);
d838 1
a838 1
  return Xlt_Error ( SMB_Write (FileTbl[fid].SMB_FH,
d850 1
a850 1
  return Xlt_Error(ENOGBPB);
d863 1
a863 1
    return Xlt_Error(EBADPARAM);
d879 1
a879 1
  return Xlt_Error(err);
d930 1
a930 1
    return Xlt_Error(EBADPARAM);
d985 1
a985 1
  return Xlt_Error(err);
@


1.11
log
@Fix and speed up EXT#handle=number doing nothing when number is beyond 2GB
Internally LanManFS was representing file offsets and data lengths as signed numbers, while in general this doesn't matter (they are passed through opaquely as just numbers and not manipulated) in a couple of places they were being used as while () loop exit conditions.
Function WriteZeroes (used when extending a file via OS_Args) therefore never performed the call to SMB_Write when beyond 2G because the loop condition was never met.
Additionally, it was literally transferring buffers of zeros across the network which is unnecessary as the server is documented as doing a zero fill itself, this represents at least a x40 speed up (on a slow 1MB/s drive write speed at the server end) or more.
Changed offset & lengths from int to uint.
Added the earlier CIFS spec (the later copy is missing section 5 for some reason) to docs.

Version 2.38. Tagged as 'LanManFS-2_38'
@
text
@a284 43
#if 0 /* Never called */
static err_t Func_ReadFreeSpace ( int sixtyfourbit, char *name, int *R )
{
  _kernel_swi_regs r;
  _kernel_oserror *err;

  if (sixtyfourbit)
  {
    fspc_64 dsr[3];

    r.r[0] = 4;
    r.r[2] = (int) &dsr;
    r.r[3] = (int) name;
    err = Omni_FreeOp_SWI(&r);
    if (err != NULL)
      return ENOTPRESENT;

    R[0] = dsr[1].lo;
    R[1] = dsr[1].hi;
    R[2] = 0x7FFFFFFF;
    R[3] = dsr[0].lo;
    R[4] = dsr[0].hi;
  }
  else
  {
    struct disk_size_response dsr;

    r.r[0] = 2;
    r.r[2] = (int) &dsr;
    r.r[3] = (int) name;
    err = Omni_FreeOp_SWI(&r);
    if (err != NULL)
      return ENOTPRESENT;

    R[0] = dsr.freeblks;
    R[1] = 0x7FFFFFFF;
    R[2] = dsr.totalblks;
  }

  return OK;
}
#endif

@


1.10
log
@Fix for renames where only the case has changed.
Detail:
 Added an extra check after the Xlate path resolution code so that
 the case of the path given to resolve is honoured. This now means that
 the strcmp() done in SMB_Rename fails and the rename is actually sent to
 the server. Before "*rename test Test" would have the path resolved and
 since 'test' already existed both names would be the same, in this example
 something like "*rename A:\test A:\test" would result.
Admin:
 Made the non LONGNAMES version compile again (not tested).
 Removed local definitions of FSControl reason codes, uses Interface header
 now.
 Made the case of #includes match CVS to allow future compilation on a case
 sensitive system.
 Deleted unused "Version" header.

Version 2.34. Tagged as 'LanManFS-2_34'
@
text
@d927 1
a927 1
static err_t WriteZeros ( int FH, int offset, int len )
d929 1
a929 1
  int tmp;
d936 2
a937 1
    tmp = (len > NAMEBUF_LEN) ? NAMEBUF_LEN : len;
d939 16
d968 1
a968 1
  int tmp;
d1006 2
a1007 2
                          R[2], /* Offset */
                          R[3]  /* Length */  );
@


1.9
log
@Workaround for NTFS returning resume keys of zero.
Detail:
  When the underlying FS is NTFS, eg. WinXP Pro, the requested
  resume keys for a directory search are always zero - this is passed
  back via OSGBPB and on the next call it triggers a new search. So
  we get stuck in an infinite loop.
  Now checks for a resume key stuck at zero, and makes a fake one static
  to the search context then sets the continuation bit in the SMB_FIND_NEXT
  call because the server returning the duff key remembers the position.
  Dir_CallbackFn could return with "taken" undefined. Move a few lines
  higher.
  Missing "#else" added to CHECK_ARMBOOT_EXISTS so if this is disabled
  no further attempt is made to find !ArmBoot.
  Couple of typos corrected.
  Spelling of "disk" changed to "disc" in an error message.
Admin:
  Tested with XP Pro SP3 with NTFS, directories which previously hung
  the filer now open correctly. Checked with XP Home SP3 with FAT32 to
  verify behaviour unchanged from 2.32.
  Note, with large directories the initial path translation triggers a
  dir search too which takes ages compared with the actual number of
  entries returned. This could be cached to make counting far faster.

Version 2.33. Tagged as 'LanManFS-2_33'
@
text
@d31 1
a31 1
#include "lanman.h"
d33 4
a36 4
#include "corefn.h"
#include "xlate.h"
#include "attr.h"
#include "smb.h"
d363 1
a363 2
      if ( err == OK )
        err = Xlt_ConvertPath( name_R(2), DOSnamebuf+DOS_NAME_LEN );
d377 6
a382 5
          (void) Xlt_CnvRenameX2 ( DOSnamebuf, DOSnamebuf + DOS_NAME_LEN );
        }
        if (da.attr & ATTR_DIR)     // force strip RO extent from dir name
        {
          Xlt_CnvRenameX2 ( DOSnamebuf+DOS_NAME_LEN,DOSnamebuf+DOS_NAME_LEN);
d386 2
a387 1
      if ( err == OK ) {
d390 1
a390 1
        }
d393 2
a394 1
      if (SMB_IsLongNameFS(DOSnamebuf + DOS_NAME_LEN)) {
d686 3
a688 1
      Xlt_CnvRenameX2 ( DOSnamebuf, DOSnamebuf );
@


1.8
log
@  Multiple fixes.
Detail:
  Too many to list here: see doc/RPSChanges.
Admin:
  Received from Rob Sprowson approx 2009-02-08. Builds, but not tested by ROOL.

Version 2.32. Tagged as 'LanManFS-2_32'
@
text
@d140 3
d164 1
a164 3
  *taken = false;
  if ( RD_ReqCount > 0 )
  {
@


1.7
log
@Update from John:
> Further mods to make sure that directory naming/renaming cannot attach
> the ,xxx filetyping.

Version 2.28. Tagged as 'LanManFS-2_28'
@
text
@a41 2
/* Some globals ================================== */

d43 1
d45 1
a45 2

static char DOSnamebuf  [NAMEBUF_LEN];
d49 1
a49 23
#define name_R(x) ((char *)R[x])



/* Func subroutines=============================================== */

#define NAMES_ONLY 14
#define MOST_INFO  15
#define ALL_INFO   19

/* Read-directory subroutines --------- */

/* The directory entries can take one of three forms, taking up
   a variable degree of space

   NAMES_ONLY - 16 bytes (12 bytes of name, plus 0 terminator, plus
                          word rounding).
   MOST_INFO  - 36 bytes
   ALL_INFO   - 44 bytes

*/

static char  RD_CurrentPath[DOS_NAME_LEN];
d53 2
d56 3
a58 11
static int   RD_ReqCount;  /* No. of entries required */
static int   RD_ReqOffset; /* Offset of currently required dir entry */
static int   RD_CurOffset; /* Offset of next entry to be given to
                                Dir_CallbackFn */

/* ---------------- */

/* SNB: the blocks being written are those required by:
 *    NAMES_ONLY =>  OS_GBPB 9   =>  (FSEntry_Func 14)
 *    MOST_INFO  =>  OS_GBPB 10  =>  (FSEntry_Func 15)
 *    ALL_INFO   =>  OS_GBPB 11  =>  (FSEntry_Func 19)
d70 1
a70 1
    (void) format;
d80 2
a81 1

d84 1
a84 1
    case NAMES_ONLY:
d91 1
a91 1
    case MOST_INFO:
d104 1
a104 1
    case ALL_INFO:
d125 1
a125 1
          debug2("WriteEntry detects a buffer overflow (%d > %d)\n",
d127 2
a128 2
          RD_BufLen = -1;
          return NULL;
d137 1
a137 1
static err_t Dir_CallbackFn ( BYTE *entry, int format, void *pw )
d161 2
a162 4
//  debug3 ("Entry: current %d req %d count %d\n",
//            RD_CurOffset, RD_ReqOffset, RD_ReqCount );

  if ( RD_ReqOffset == RD_CurOffset )
d164 10
a173 13
    if ( RD_ReqCount > 0 )
    {
      char *w_result = WriteEntry ( RD_Reason, RD_BufPtr, entry, format );
      if (w_result != NULL) {
        RD_BufPtr = w_result;
        RD_ReqCount--;
        RD_ReqOffset++;
      }
      else {
        debug0("Oh dear - client ran out of buffer space!\n");
        RD_CurOffset++;
        return EOUTOFMEM;
      }
a176 1
  RD_CurOffset++;
d182 7
d193 3
a195 3
  static Transact_SearchContext scon;
  int tmp;
  err_t res;
d198 2
a199 3
  debug2 ( " offset %d count %d\n", dir_offset, n_names );

  /* Make sure the number of names we read will fit into buffer ---- */
d201 3
a203 2
  tmp = (reason == NAMES_ONLY) ? 16 :
        (reason == MOST_INFO) ? 36 : 44;
a219 2

  /* There is no code inside this #ifdef - it just marks my comment. */
d221 1
a221 1
  if ( n_names*tmp > buflen ) n_names = buflen/tmp;
d223 1
a223 1

d227 1
a228 3
  RD_ReqOffset = dir_offset;

  debug1("Actual count=%d\n", n_names );
a230 1

d233 2
a234 2

  tmp = strlen(DOSnamebuf);
d236 1
a236 4
  if ( DOSnamebuf[tmp-1] == '\\' )
    strcpy( DOSnamebuf+tmp, "*" );
  else
    strcpy( DOSnamebuf+tmp, "\\*" );
d238 1
a238 4
  if ( DOSnamebuf[tmp-1] == '\\' )
    strcpy( DOSnamebuf+tmp, "????????.???" );
  else
    strcpy( DOSnamebuf+tmp, "\\????????.???" );
d241 2
a242 6
  /* Start a new search? ----------------------------------- */


  if ( RD_ReqOffset == 0 || /* New start */
       RD_ReqOffset < RD_CurOffset || /* Going back in search */
       strcmp(DOSnamebuf, RD_CurrentPath) != 0 ) /* New directory */
d244 4
a247 5
    debug1("\n>> Start search (%s)\n", DOSnamebuf);
    strcpy ( RD_CurrentPath, DOSnamebuf);
    RD_CurOffset = 0;
    res = SMB_ReadDirEntries ( DOSnamebuf, RD_ReqCount+RD_ReqOffset,
                                      Dir_CallbackFn, NULL, &scon );
d249 2
a250 1
  else
d252 1
a254 1

d258 3
a260 3
    debug0("\n>> Continue search\n");
    res = SMB_ReadDirEntries ( NULL, RD_ReqCount+RD_ReqOffset-RD_CurOffset,
                                      Dir_CallbackFn, NULL, &scon );
a263 1

a268 1

d271 1
a271 3
  if ( res != OK )   /* Ran out of files, or error */
  {
    RD_CurrentPath[0] = 0;  /* Stop any repeat searches */
d275 1
a275 13
  {
    if (RD_BufLen < 0) {
      /* OK - was out of buffer space, force restart */
      *pOutNextOffset = RD_ReqOffset;
      //RD_CurOffset = 0;
      //RD_CurrentPath[0] = 0;
    }
    else {
      *pOutNextOffset = RD_ReqOffset;
    }
  }

  *pOutNread = RD_ReqOffset-dir_offset;
d277 1
d284 1
a288 1
  struct disk_size_response dsr;
d290 13
a302 10
  r.r[0] = 2;
  r.r[2] = (int) &dsr;
  r.r[3] = (int) name;
  err = Omni_FreeOp_SWI(&r);
  if (err != NULL)
    return ENOTPRESENT;

  R[0] = dsr.freeblks;
  if (sixtyfourbit) {
    R[1] = R[4] = 0;
d304 2
a305 1
    R[3] = dsr.totalblks;
d307 12
a318 1
  else {
d325 1
d332 1
d385 1
a385 1
      if ( err == OK )
d387 2
d440 1
d444 4
a447 3
       /* On shutdown, disconnect all drives */
       err = SMB_Shutdown();
       break;
a453 6
        break;

    case FSEntry_Func_Reason_ResolveWildcard:
      /* Tell FileSwitch to do it itself */
      R[4] = -1;
      err = OK;
a455 7
    case FSEntry_Func_Reason_ReadFreeSpace:
      err = Func_ReadFreeSpace ( 0, name_R(1), R );
        break;
    case FSEntry_Func_Reason_ReadFreeSpace64:
      err = Func_ReadFreeSpace ( 1, name_R(1), R );
        break;

d462 1
a462 1
  NameCache_Flush(ncf_FSFUNC_EXIT);
d495 2
a496 1

d524 1
d592 1
d631 1
d663 1
d683 3
a685 2
     Xlt_CnvRenameX2 ( DOSnamebuf, DOSnamebuf );
     err = SMB_MkDir ( DOSnamebuf );
d718 1
a718 1
  NameCache_Flush(ncf_FSFILE_EXIT);
d1017 1
@


1.6
log
@Update from jwb - no longer appends ,xxx to filenames on server if the
filetype can already be determined from the file extension.

Version 2.27. Tagged as 'LanManFS-2_27'
@
text
@d728 2
a729 1
      err = SMB_MkDir ( DOSnamebuf );
@


1.5
log
@Directory rename fixed - the mask being passed by the rename routine didn't
have the ATTR_DIR bit set.Discovered this after reading lots of the spec
which is also now included here in /doc.
Copying files out of LanManFS filer "forgot" their filetype even though
they appeared right in the filer,fixed.
A stray debugging printf removed,along with one compiler warning.
New sprites (yuck) to match !Omni.
Reordered the shutdown in two places,first Omni_Shutdown bins the mounts
lists which SMB_Shutdown uses.Second in NetBEUI mode the announcement that
a protocol has terminated goes *after* the shutdown - otherwise you sit
around for about 20s wondering where the link has gone.

Version 2.25. Tagged as 'LanManFS-2_25'
@
text
@d48 2
a49 1

a405 1
      if ( err == OK )
d407 17
a423 1
        (void) Xlt_CnvRenameX2 ( DOSnamebuf, DOSnamebuf + DOS_NAME_LEN );
@


1.4
log
@  New *LMLS command.
  Fix for ./.. files in short filename shares.
  Long multiply now provided in assembler.
Detail:
  *LMLS is a new filesystem-specific command which performs the same
    task as "smbclient -L" does under UNIX - ie. listing all the shares
    available on the specified host.
  When enumerating the shares on a remote server, LanManFS now remembers
    all the printers, IPC, device and disc shares (for *LMLS to output).
  The 32x32->64 multiply routine is now provided in assembler instead of
    the previous huge amount of obscure C taken from NSPRLib.  This is
    more understandable (and almost certainly far smaller and quicker
    and doesn't need a hack to stop the compiler mis-optimising it!)
  Old short filename shares still had problems with the . and .. file
    filtering.  Programmer fault there - should've let the compiler do
    the optimisations :-)
  Server info string fixed to byte-reverse the port numbers when printing
    the string into the info buffer.  Now claims to be talking to port 139
    as it should.
Admin:
  Tested in general desktop use for several days, plus experimental versions
    tested in other boot ROMs.

Version 2.03. Tagged as 'LanManFS-2_03'
@
text
@a346 2
printf("Read free space\n");

d434 1
a434 1
        ra.flags = ROA_READ | ROA_WRITE;
@


1.3
log
@  Bad check for . and .. fixed.
Detail:
  Any filename starting with . was being hidden.
Admin:
  Tested.  Confirmed . and .. are not there but files such as .rhosts
    are visible.

Version 2.01. Tagged as 'LanManFS-2_01'
@
text
@d184 1
a184 1
    if (entry[10] == '.' && entry[10] == '\0' || entry[11] == '\0') {
@


1.2
log
@  Support for long filename.
  Support for spaces in machine names.
  Merge of sbrodie_LanManFS_dev branch to trunk.
Detail:
  LanManFS 2.00 supports the "NT LM 0.12" protocol, enabling it to
    use long filenames on mounted shares.
Admin:
  Supporting documentation:
    1215,256/FS: LanManFS Software Functional Specification.
  Same as LanManFS-1_87_1_1_1_1_2_13.

Version 2.00. Tagged as 'LanManFS-2_00'
@
text
@d171 8
a178 1
    if (entry[23] == '.') return OK;
d182 6
a187 2
  if ( entry[9] == '.' )  /* Ignore '.' and '..' directories */
    return OK;
@


1.1
log
@Initial revision
@
text
@d37 3
d75 1
d84 6
a89 1
static char *WriteEntry ( int reason, char *ptr, BYTE *entry )
d91 2
d98 12
d113 4
a116 2
      Xlt_ExpandSearchEntry ( entry, DOSnamebuf, ptr, NULL, NULL );
      rec_len = strlen(ptr)+1;
d120 10
a129 9
      Xlt_ExpandSearchEntry (entry, DOSnamebuf, ptr+20, &da, &ra );
      IntPtr = (int *)ptr;
      IntPtr[0] = ra.loadaddr;
      IntPtr[1] = ra.execaddr;
      IntPtr[2] = da.length;
      IntPtr[3] = ra.flags;
      IntPtr[4] = (da.attr & ATTR_DIR) ? 2 : 1;
      rec_len = 20+strlen(ptr+20)+1;
      rec_len = (rec_len+3) & ~3; /* Round up to whole word */
d133 13
a145 12
      Xlt_ExpandSearchEntry (entry, DOSnamebuf, ptr+29, &da, &ra );
      IntPtr = (int *)ptr;
      IntPtr[0] = ra.loadaddr;
      IntPtr[1] = ra.execaddr;
      IntPtr[2] = da.length;
      IntPtr[3] = ra.flags;
      IntPtr[4] = (da.attr & ATTR_DIR) ? 2 : 1;
      IntPtr[5] = 0;
      IntPtr[6] = ra.execaddr;
      ptr[28] = ra.loadaddr & 0xFF;
      rec_len = 29+strlen(ptr+29)+1;
      rec_len = (rec_len+3) & ~3; /* Round up to whole word */
d152 8
d165 1
a165 1
static void Dir_CallbackFn ( BYTE *entry, void *pw )
a166 1

d168 7
d176 1
a176 1
    return;
d178 2
a179 2
  debug3 ("Entry: current %d req %d count %d\n",
            RD_CurOffset, RD_ReqOffset, RD_ReqCount );
d185 11
a195 3
      RD_BufPtr = WriteEntry ( RD_Reason, RD_BufPtr, entry );
      RD_ReqCount--;
      RD_ReqOffset++;
d200 1
d209 1
d213 1
a213 1
  debug2 ( "\nReadDir reason %d path %s", reason, path_name );
d221 18
a239 1

d244 1
d248 1
a248 1
  debug1("Actual count=%d", n_names );
d256 6
d266 1
d275 1
a275 1
    debug0("Start search\n");
d279 1
a279 1
                                      Dir_CallbackFn, NULL );
d289 1
a289 1
    debug0("Continue search\n");
d291 1
a291 1
                                      Dir_CallbackFn, NULL );
d296 7
a302 1
  debug2("End search, res=%d count=%d\n", res, RD_ReqCount);
d311 9
a319 1
    *pOutNextOffset = RD_CurOffset;
d330 29
d395 6
d404 16
d468 13
d486 4
d501 1
d506 1
a506 1
    Attr_GetInfo ( DOSnamebuf, NULL, pra );
d548 11
d619 14
d654 17
d735 4
d858 1
d860 5
a864 1

@


1.1.1.1
log
@
LanManFS moved into Omni subdirectory.  Previous version in
RiscOS/Sources/Networking/LanManFS is now locked out.

The rest of Omni will be imported at a later date.

Version 1.87, tagged as LanManFS-1_87

@
text
@@


1.1.1.1.2.1
log
@  First cut at long filenames in LanManFS.  *Cat and *Ex work.
  Pretty much nothing else does.
Detail:
  Now uses long filenames if available, and switches to the advanced
    SMB protocol and Transact2 commands to do work with long filenames.
Admin:
  Work in progress.  End of week's work checkin point only.  Do not use.

Version 1.87, 1.1.1.1.2.2. Tagged as 'LanManFS-1_87-1_1_1_1_2_2'
@
text
@a71 1
static int   RD_BufLen;
d80 1
a80 6
/* SNB: the blocks being written are those required by:
 *    NAMES_ONLY =>  OS_GBPB 9   =>  (FSEntry_Func 14)
 *    MOST_INFO  =>  OS_GBPB 10  =>  (FSEntry_Func 15)
 *    ALL_INFO   =>  OS_GBPB 11  =>  (FSEntry_Func 19)
 */
static char *WriteEntry ( int reason, char *ptr, BYTE *entry, int format )
a81 2
  static char namebuf[DOS_NAME_LEN];
  int name_len;
a86 8
  if (format == 1) {
    Xlt_ExpandSearchEntryX2(entry, DOSnamebuf, namebuf, &da, &ra);
  }
  else {
    Xlt_ExpandSearchEntry(entry, DOSnamebuf, namebuf, &da, &ra);
  }
  name_len = strlen(namebuf) + 1;

d90 2
a91 4
      rec_len = name_len;
      if (rec_len <= RD_BufLen) {
        memcpy(ptr, namebuf, name_len);
      }
d95 9
a103 10
      rec_len = (20+name_len+3) & ~3;  /* Round up to whole word */
      if (rec_len <= RD_BufLen) {
        IntPtr = (int *)ptr;
        IntPtr[0] = ra.loadaddr;
        IntPtr[1] = ra.execaddr;
        IntPtr[2] = da.length;
        IntPtr[3] = ra.flags;
        IntPtr[4] = (da.attr & ATTR_DIR) ? 2 : 1;
        memcpy(ptr+20, namebuf, name_len);
      }
d107 12
a118 13
      rec_len = (29+name_len)+3 & ~3; /* Round up to whole word */
      if (rec_len <= RD_BufLen) {
        IntPtr = (int *)ptr;
        IntPtr[0] = ra.loadaddr;
        IntPtr[1] = ra.execaddr;
        IntPtr[2] = da.length;
        IntPtr[3] = ra.flags;
        IntPtr[4] = (da.attr & ATTR_DIR) ? 2 : 1;
        IntPtr[5] = 0;
        IntPtr[6] = ra.execaddr;
        ptr[28] = ra.loadaddr & 0xFF;
        memcpy(ptr+29, namebuf, name_len);
      }
a124 8
  if (rec_len > RD_BufLen) {
          debug2("WriteEntry detects a buffer overflow (%d > %d)\n",
            rec_len, RD_BufLen);
          RD_BufLen = -1;
          return NULL;
  }

  RD_BufLen -= rec_len;
d130 1
a130 1
static err_t Dir_CallbackFn ( BYTE *entry, int format, void *pw )
d132 1
a133 7
#ifdef LONGNAMES
  /* Insert check for . and .. here */
  if (format == 1) {
    if (entry[23] == '.') return OK;
  }
  else
#endif
d135 1
a135 1
    return OK;
d137 2
a138 2
//  debug3 ("Entry: current %d req %d count %d\n",
//            RD_CurOffset, RD_ReqOffset, RD_ReqCount );
d144 3
a146 11
      char *w_result = WriteEntry ( RD_Reason, RD_BufPtr, entry, format );
      if (w_result != NULL) {
        RD_BufPtr = w_result;
        RD_ReqCount--;
        RD_ReqOffset++;
      }
      else {
        debug0("Oh dear - client ran out of buffer space!\n");
        RD_CurOffset++;
        return EOUTOFMEM;
      }
a150 1
  return OK;
d162 1
a162 1
  debug2 ( "\n\n>> ReadDir reason %d path %s", reason, path_name );
d170 1
a170 15
#ifdef LONGNAMES
  /* Of course, the above calculation assumes that the filename is at most
   * 16 characters long (8 + '.' + 3 + \0 + 3 bytes pad).  This is
   * useless for long filename shares and so the n_names parameter is
   * accepted in place, and the buffer writer updated to be able to
   * avoid and flag buffer overflow.  In the worst case, this may mean
   * multiple searches are required, however, as long as the directory
   * reading function SMB_ReadDirEntriesX2 is intelligent, it can remember
   * the resume keys and last successful filename data for the search and
   * attempt to keep our caller in step with the remote server.
   *
   * The limit is still performed as it is still useful for avoiding
   * unnecessary buffer overruns - especially when there are not very
   * many files with long names or even no files with long names.
   */
a171 4
  /* There is no code inside this #ifdef - it just marks my comment. */
#else
  if ( n_names*tmp > buflen ) n_names = buflen/tmp;
#endif
a175 1
  RD_BufLen = buflen;
d179 1
a179 1
  debug1("Actual count=%d\n", n_names );
a186 6
#ifdef LONGNAMES
  if ( DOSnamebuf[tmp-1] == '\\' )
    strcpy( DOSnamebuf+tmp, "*" );
  else
    strcpy( DOSnamebuf+tmp, "\\*" );
#else
a190 1
#endif
d199 1
a199 1
    debug0("\n>> Start search\n");
d213 1
a213 1
    debug0("\n>> Continue search\n");
d220 1
a220 7
  if (res == EOUTOFMEM && RD_BufLen == -1) {
    /* Special result when client buffer space exhausted */
    debug0("Client buffer space was exhausted\n");
    res = OK;
  }

  debug2("End search, res=%d RD_ReqCount=%d\n", res, RD_ReqCount);
d229 1
a229 9
    if (RD_BufLen < 0) {
      /* OK - was out of buffer space, force restart */
      *pOutNextOffset = RD_ReqOffset;
      //RD_CurOffset = 0;
      //RD_CurrentPath[0] = 0;
    }
    else {
      *pOutNextOffset = RD_ReqOffset;
    }
@


1.1.1.1.2.2
log
@  A few more battles have been won.  War finally starting to go my way.
Detail:
  LanManFS now uses ,xxx type notation on long filename shares.
  Character mappings improved (necessary because Windows allows so
    many extra daft characters to appear in filenames) and one-to-many
    mappings for awkward charcacters in the RISC OS->DOS world have
    been added.
  Directory searching improved so that the wildcard matching can be
    done properly.  Only Microsoft could provide you an API call to
    discover information about a filename specified with wildcards and
    NOT tell you which filename it matched. :-/
  Things remaining unimplemented so far:
    Setting filetypes.
    Creating files with specific types
    Renaming.
  All those outstanding things relate to the work done by Attr_SetInfo
    which should be the final major piece of hacking required.
Admin:
  Tested by connecting to a long filename share from both a RISC OS
    machine and a Windows NT machine.  All behaviour of the RISC OS
    machine has been verified against what the NT machine is seeing
    happening.  No surprises.  One-to-many character mappings are
    being matched correctly.
  Also tested using the Filer at the RISC OS end to navigate, run,
    and edit things on the remote share.

Version 1.87, 1.1.1.1.2.4. Tagged as 'LanManFS-1_87-1_1_1_1_2_4'
@
text
@a94 3
#ifndef LONGNAMES
    (void) format;
#else
d98 1
a98 2
  else
#endif
d100 1
a100 1

a361 5
#ifdef LONGNAMES
      if (SMB_IsLongNameFS(DOSnamebuf + DOS_NAME_LEN)) break;
      /* Don't bother with any of this rubbish for long filename discs */
#endif

a425 1
  debug1("FileGetAttribs(%s) ... \n", filename);
d430 1
a430 1
    Attr_GetInfo ( filename, NULL, pra );
@


1.1.1.1.2.3
log
@  First version which should contain everything required for full
    long filename support of SMB shares.
Detail:
  Renaming works; setting filetypes results in a rename occurring;
  setting load/exec/attributes works - causing a rename where
  appropriate; creation of files to overwrite existing objects of
  different types causes old file to be deleted first.
Admin:
  Tested briefly and everything seems happy both at the command-line
    and from the RISC OS Filer.  More thorough development testing can
    now commence properly.

Version 1.87, 1.1.1.1.2.5. Tagged as 'LanManFS-1_87-1_1_1_1_2_5'
@
text
@a362 6
#ifdef LONGNAMES
      if ( err == OK )
      {
        (void) Xlt_CnvRenameX2 ( DOSnamebuf, DOSnamebuf + DOS_NAME_LEN );
      }
#endif
d367 1
a367 12
      if (SMB_IsLongNameFS(DOSnamebuf + DOS_NAME_LEN)) {
         if ( err == EBADRENAME )
         {
           R[1] = 1;
           err = OK;
         }
         else
         {
           R[1] = 0;
         }
         break;
      }
a481 11
#ifdef LONGNAMES
      strncpy(DOSnamebuf + DOS_NAME_LEN, DOSnamebuf, DOS_NAME_LEN);
      if (Xlt_AddROType(DOSnamebuf, ra.loadaddr)) {
        /* We changed the filetype - therefore delete old file */
        err = SMB_Delete(DOSnamebuf + DOS_NAME_LEN);
        if (err != OK && err != EFILENOTFOUND) {
           /* Oh dear - looks likely the create would fail anyway! */
           break;
        }
      }
#endif
a541 8
#ifdef LONGNAMES
        strncpy(DOSnamebuf + DOS_NAME_LEN, DOSnamebuf, DOS_NAME_LEN);
        if (Xlt_AddROType(DOSnamebuf + DOS_NAME_LEN, ra.loadaddr)) {
          err = SMB_Rename(DOSnamebuf, DOSnamebuf + DOS_NAME_LEN);
          if (err != OK) break;
          strcpy(DOSnamebuf, DOSnamebuf + DOS_NAME_LEN);
        }
#endif
a561 9

#ifdef LONGNAMES
      strncpy(DOSnamebuf + DOS_NAME_LEN, DOSnamebuf, DOS_NAME_LEN);
      if (Xlt_AddROType(DOSnamebuf + DOS_NAME_LEN, ra.loadaddr)) {
        err = SMB_Rename(DOSnamebuf, DOSnamebuf + DOS_NAME_LEN);
        if (err != OK) break;
        strcpy(DOSnamebuf, DOSnamebuf + DOS_NAME_LEN);
      }
#endif
@


1.1.1.1.2.4
log
@  Fixed logon behaviour against NT4 servers.
  Added automatic bug detection code.
Detail:
  NT4 servers use differently formatted buffer to response to the logon
    requests and this was confusing the code which only knew about the
    oldest format of this buffer.  The code now knows about all three
    different possible response formats and processes them all properly.
  Windows 95/98 servers contain a bug which cause them to reverse the
    order of the date and time fields in QPathInformation transactions.
    My earlier workaround for this was to always reverse the time/date
    pairs - which causes it to fail when talking to Windows NT servers.
    On the first QPathInformation request on a given share, the request
    is first done on the root directory, and then the (non-broken) dir
    search transaction is executed and the results compared to determine
    whether the server is broken or not.  This means that it should
    interwork with NT, 95, 98 and also with Samba (which has a build
    option for emulating this bug or not!)
  Transact2 processing code is now aware of the multiple response packet
    options and can cope with the server sending secondary responses.
  Directory search entry per call limiter re-introduced to prevent these
    from secondary responses occurring anyway as they are still a pain to
    process efficiently.
Admin:
  Tested against Windows 98 and Windows NT 4.

Version 1.87, 1.1.1.1.2.6. Tagged as 'LanManFS-1_87-1_1_1_1_2_6'
@
text
@d234 2
a236 1
  if ( n_names*tmp > buflen ) n_names = buflen/tmp;
d272 1
a272 1
    debug1("\n>> Start search (%s)\n", DOSnamebuf);
d571 5
a575 10
      {
        if (da.attr & ATTR_DIR)
                ;
        else {
          strncpy(DOSnamebuf + DOS_NAME_LEN, DOSnamebuf, DOS_NAME_LEN);
          if (Xlt_AddROType(DOSnamebuf + DOS_NAME_LEN, ra.loadaddr)) {
            err = SMB_Rename(DOSnamebuf, DOSnamebuf + DOS_NAME_LEN);
            if (err != OK) break;
            strcpy(DOSnamebuf, DOSnamebuf + DOS_NAME_LEN);
          }
a576 1
      }
d600 5
a604 13
      {
        RISCOS_ATTRIBS test_ra;
        err = FileGetAttribs ( DOSnamebuf, &da, &test_ra );
        if (err == OK && (da.attr & ATTR_DIR))
                ;
        else {
          strncpy(DOSnamebuf + DOS_NAME_LEN, DOSnamebuf, DOS_NAME_LEN);
          if (Xlt_AddROType(DOSnamebuf + DOS_NAME_LEN, ra.loadaddr)) {
            err = SMB_Rename(DOSnamebuf, DOSnamebuf + DOS_NAME_LEN);
            if (err != OK) break;
            strcpy(DOSnamebuf, DOSnamebuf + DOS_NAME_LEN);
          }
        }
@


1.1.1.1.2.5
log
@  Fixed most dodgy pathname problems.
  All *LM... commands are now filing system commands.
  *Connect and *Disconnect renamed to *LMConnect and *LMDisconnect.
Detail:
  When translating RISC OS to DOS filenames, a loop could develop if
    any path component contained a dodgy character.  This is now fixed
    with the exception of problems when both < and > characters appear
    in pathnames since that confuses FileSwitch.  New mappings will be
    need to be agreed for these characters (and remappings for $ and %
    which overload < and > respectively)
  All *LM... commands are now filing system commands, which means that
    you need to prefix them with LanMan: unless LanManFS is the current
    filesystem (following spec review).
  *Connect and *Disconnect renamed to *LMConnect and *LMDisconnect
    (following spec review).
  Trace builds allow "*LanMan:LMNameMode 4" to enable display of system
    and hidden files on the remote filesystem.
Admin:
  Tested briefly against Windows 98 and Windows NT 4 SP3.
  If a directory name contains a dodgy character, repeated searches will
    be made on the remote filesystem.  This is inefficient and a name
    cache would alleviate this.  There is no name cacheing in the current
    version.

Version 1.87, 1.1.1.1.2.9. Tagged as 'LanManFS-1_87-1_1_1_1_2_9'
@
text
@a36 1
#include "Transact.h"
a205 1
  static Transact_SearchContext scon;
d275 1
a275 1
                                      Dir_CallbackFn, NULL, &scon );
d287 1
a287 1
                                      Dir_CallbackFn, NULL, &scon );
@


1.1.1.1.2.6
log
@  End of week checkin.  No bug fixes.  Some performance improvements.
Detail:
  Added a basic name cacheing facility.  For safety this is flushed
    every time the module returns to FileSwitch.  This does at least
    help reduce the name of directory searches required during a
    name translation.  NameCache.c comes with a test program built-in
    for stressing the cache manager.
Admin:
  Free space display doesn't work yet.
  Anti-idleout measures not implemented yet.

Version 1.87, 1.1.1.1.2.10. Tagged as 'LanManFS-1_87-1_1_1_1_2_10'
@
text
@a36 1
#include "Omni.h"
a37 1
#include "NameCache.h"
a327 29
static err_t Func_ReadFreeSpace ( int sixtyfourbit, char *name, int *R )
{
  _kernel_swi_regs r;
  _kernel_oserror *err;
  struct disk_size_response dsr;

printf("Read free space\n");

  r.r[0] = 2;
  r.r[2] = (int) &dsr;
  r.r[3] = (int) name;
  err = Omni_FreeOp_SWI(&r);
  if (err != NULL)
    return ENOTPRESENT;

  R[0] = dsr.freeblks;
  if (sixtyfourbit) {
    R[1] = R[4] = 0;
    R[2] = 0x7FFFFFFF;
    R[3] = dsr.totalblks;
  }
  else {
    R[1] = 0x7FFFFFFF;
    R[2] = dsr.totalblks;
  }

  return OK;
}

a436 13
    case FSEntry_Func_Reason_ResolveWildcard:
      /* Tell FileSwitch to do it itself */
      R[4] = -1;
      err = OK;
      break;

    case FSEntry_Func_Reason_ReadFreeSpace:
      err = Func_ReadFreeSpace ( 0, name_R(1), R );
        break;
    case FSEntry_Func_Reason_ReadFreeSpace64:
      err = Func_ReadFreeSpace ( 1, name_R(1), R );
        break;

a441 4
#ifdef LONGNAMES
  NameCache_Flush(ncf_FSFUNC_EXIT);
#endif

a686 4
#ifdef LONGNAMES
  NameCache_Flush(ncf_FSFILE_EXIT);
#endif

a807 3
#ifdef LONGNAMES
  NameCache_Flush(ncf_FSOPEN_EXIT);
#endif
@


1.1.1.1.2.7
log
@  Boot behaviour fixes.
  More debug added.
Detail:
  Trapped Service_InternetStatus reason code 0 as a tipoff to try
    to continue a pending boot operation.  Internet module is not
    sending the expected reason code 2 to indicate that the interface
    has come up when it is also having its address changed.
  Holding down SHIFT when a new connection is made prevents execution
    of !ArmBoot on the newly connected share.
  Several more debug statements added to track progress through the
    booting.
  IPConfig's internal logging system imported.  *LanMan:Free shows
    the contents of the log.
  Free space information still seems to be broken against Windows 95/98.
    Works against NT4SP4 though.
  *Free filesystem-specific command added.
Admin:
  This version managed to boot an STB22 from our NT4 server which
    was supplying it with baseline 303.
  *LanMan:Free is not yet implemented and in debug builds, shows
     the debug log instead.
  Anti-idleout work still pending.

Version 1.87, 1.1.1.1.2.11. Tagged as 'LanManFS-1_87-1_1_1_1_2_11'
@
text
@a857 1
  {
d859 1
d861 1
a861 2
    /* Take a risk to enhance cacheing :-) */
    NameCache_Flush(ncf_FSOPEN_EXIT);
a862 1
  }
@

head	1.23;
access;
symbols
	LanManFS-2_62:1.23
	LanManFS-2_61:1.23
	LanManFS-2_60:1.23
	LanManFS-2_59:1.23
	LanManFS-2_58:1.23
	LanManFS-2_57:1.22
	LanManFS-2_56:1.22
	LanManFS-2_55:1.22
	LanManFS-2_54:1.21
	LanManFS-2_53:1.21
	LanManFS-2_52:1.21
	LanManFS-2_51:1.21
	LanManFS-2_50:1.21
	LanManFS-2_49:1.21
	LanManFS-2_48:1.21
	LanManFS-2_47:1.21
	LanManFS-2_46:1.21
	LanManFS-2_45:1.21
	LanManFS-2_44:1.21
	LanManFS-2_43:1.20
	LanManFS-2_42:1.19
	LanManFS-2_41:1.18
	LanManFS-2_40:1.17
	LanManFS-2_39:1.16
	LanManFS-2_38:1.15
	LanManFS-2_37:1.15
	LanManFS-2_36:1.15
	LanManFS-2_35:1.15
	LanManFS-2_34:1.15
	LanManFS-2_33:1.14
	LanManFS-2_32:1.14
	LanManFS-2_31:1.13
	RO_5_07:1.13
	LanManFS-2_30:1.13
	LanManFS-2_29:1.13
	LanManFS-2_28:1.12
	LanManFS-2_27:1.12
	LanManFS-2_26:1.12
	LanManFS-2_25:1.11
	LanManFS-2_24:1.10
	LanManFS-2_23:1.10
	LanManFS-2_22:1.9
	LanManFS-2_21:1.8
	LanManFS-2_20:1.8
	LanManFS-2_19:1.8
	LanManFS-2_18:1.8
	LanManFS-2_17:1.7
	LanManFS-2_16:1.7
	LanManFS-2_15:1.7
	LanManFS-2_14:1.6
	LanManFS-2_13:1.5
	LanManFS-2_12:1.5
	LanManFS-2_11:1.5
	LanManFS-2_10:1.5
	LanManFS-2_09:1.5
	LanManFS-2_08:1.5
	LanManFS-2_07:1.5
	LanManFS-2_06:1.4
	LanManFS-2_05:1.4
	LanManFS-2_04:1.3
	LanManFS-2_03:1.3
	LanManFS-2_02:1.2
	LanManFS-2_01:1.2
	LanManFS-2_00:1.2
	LanManFS-1_87-1_1_1_1_2_13:1.1.1.1.2.6
	LanManFS-1_87-1_1_1_1_2_12:1.1.1.1.2.5
	LanManFS-1_87-1_1_1_1_2_11:1.1.1.1.2.4
	LanManFS-1_87-1_1_1_1_2_10:1.1.1.1.2.3
	LanManFS-1_87-1_1_1_1_2_9:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_8:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_7:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_6:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_5:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_4:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_3:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_2:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_1:1.1.1.1.2.1
	sbrodie_LanManFS_dev:1.1.1.1.0.2
	sbrodie_LanManFS_dev_bp:1.1.1.1
	LanManFS-1_87:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.23
date	2016.10.23.14.31.30;	author rsprowson;	state Exp;
branches;
next	1.22;
commitid	tIsBRIH0cb7mghrz;

1.22
date	2016.04.14.20.11.22;	author jlee;	state Exp;
branches;
next	1.21;
commitid	7HMIjBU2kKlAjD2z;

1.21
date	2014.01.19.16.21.16;	author rsprowson;	state Exp;
branches;
next	1.20;
commitid	0F8wGrpzbdHQgKlx;

1.20
date	2013.11.22.18.44.39;	author rsprowson;	state Exp;
branches;
next	1.19;
commitid	DXYB6F4orjnCViex;

1.19
date	2013.10.04.21.00.08;	author rsprowson;	state Exp;
branches;
next	1.18;
commitid	eiQDL9obBhdLf18x;

1.18
date	2013.10.03.07.46.13;	author rsprowson;	state Exp;
branches;
next	1.17;
commitid	BeiPxSOMs39oTO7x;

1.17
date	2013.10.03.07.27.08;	author rsprowson;	state Exp;
branches;
next	1.16;
commitid	iTaBDwF1woaPMO7x;

1.16
date	2013.09.30.19.47.04;	author rsprowson;	state Exp;
branches;
next	1.15;
commitid	MoU9V9JbMV2FYu7x;

1.15
date	2009.08.01.08.10.27;	author rsprowson;	state Exp;
branches;
next	1.14;

1.14
date	2009.04.15.16.00.08;	author bavison;	state Exp;
branches;
next	1.13;
commitid	GhZBwZ2GN8lg58Kt;

1.13
date	2004.01.09.11.28.01;	author bavison;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.11.20.49.01;	author kbracey;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.16.18.14.17;	author rsprowson;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.14.13.51.16;	author rsprowson;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.08.15.17.16;	author srevill;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.15.12.49.48;	author sbrodie;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.25.17.03.34;	author sbrodie;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.11.15.55.01;	author sbrodie;	state Exp;
branches;
next	1.5;

1.5
date	99.04.29.14.27.37;	author sbrodie;	state Exp;
branches;
next	1.4;

1.4
date	99.03.16.14.49.49;	author sbrodie;	state Exp;
branches;
next	1.3;

1.3
date	99.03.01.16.58.18;	author sbrodie;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.12.51.59;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	98.12.03.13.54.45;	author sbrodie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.12.03.13.54.45;	author sbrodie;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	98.12.04.11.37.33;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	99.02.03.12.51.33;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.02.05.15.57.16;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.4;

1.1.1.1.2.4
date	99.02.10.14.55.49;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.5;

1.1.1.1.2.5
date	99.02.12.17.18.19;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.6;

1.1.1.1.2.6
date	99.02.16.12.34.04;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Correction to configure syntax help
The args to LMTransport are mandatory, so should be in <> brackets rather than [].

Version 2.58. Tagged as 'LanManFS-2_58'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
*
*  LanMan.C -- Lan Manager network client main module
*
*  Versions
*
*  28-02-94 INH Derived from FSinC (added c.Statics)
*
*
*/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <locale.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"
#include "Global/Services.h"
#include "Global/FileTypes.h"
#include "Global/NewErrors.h"
#include "Interface/HighFSI.h"

#include "sys/dcistructs.h"
#include "sys/types.h"
#include "netinet/in.h"
#include "arpa/inet.h"

#include "stdtypes.h"
#include "LanMan.h"
#include "LMVars.h"
#include "Params.h"
#include "CoreFn.h"
#include "BufLib.h"
#include "NetBIOS.h"
#include "SMB.h"
#include "Xlate.h"
#include "VersionNum"
#include "Omni.h"
#include "Printers.h"
#include "RPC.h"
#include "Stats.h"
#include "Logon.h"
#include "LanMan_MH.h"

/* ---------------------------------- */

extern void *Resources(void);

#define DEFAULT_ETHER_TYPE 	"_default_"

typedef void (*pfnShutdown)(void);
typedef void (*pfnTransportInit)(void);

enum {
        LMInitState_Uninitialised,
        LMInitState_PreInit,
        LMInitState_FullyInited,
        LMInitState_Boot
};

static void startcallbacks(void);
static void stopcallbacks(void);

static _kernel_oserror *LM_init_phase_2(void);

/* ---------------------------------- */

struct LMvars LM_Vars;
static volatile int callbackflag = 0;
static int msg_struct[4]; /* MessageTrans block */
static _kernel_oserror msg_buff; /* MessageTrans buffer */
static _kernel_oserror *msg_oserr;
int    LM_pw;          /* Our module's private word */
struct NETBIOS_TRANSPORT *NB_ActiveTransport; /* Selected net transport */
static pfnTransportInit NB_InitedTransport; /* Identify active transport */
static bool LM_Declared;  /* True if we're registered as a filing system */

/* ---------------------------------- */

#define CMOS_FSNUMBER   5
/* Contains number of FS to be booted */
#define CMOS_FSFLAGS    16
/* Contains flags, bit 4 is set if booting is enabled */
#define FSF_BOOT        0x10

#define CMOS_FSSTAT     1 /* NAS 11/Feb/97 */
#define CMOS_FSERVER1   2 /* NAS 11/Feb/97 */
#define CMOS_FSERVER    158 /* NAS 11/Feb/97 */
#define FSERVER_LEN     (172-159+1)
/* Locations in CMOS containing file server name.
   It's assumed this is less than NAME_LIMIT. If it's not, put FSERVER_LEN
   at NAME_LIMIT-1, and it'll have to be truncated. */

#define CMOS_NB_TYPE    0x6F
#define	NBTYPE_IP_BIT	(1<<0)

/* ------------------ */

const char *MsgLookup(const char *token)
{
  if (_swix(MessageTrans_Lookup, _INR(0,7),
            msg_struct, token, &msg_buff, sizeof(msg_buff), 0, 0, 0, 0) != NULL)
  {
    return "";
  }
  return (const char *)&msg_buff;
}

/* ------------------ */

err_t MsgSetOSError (_kernel_oserror *err)
{
  /* Record the last OS error, and translate that into a LanMan
   * error number so we can retrieve the actual error later in MsgError().
   */
  msg_oserr = err;
  if (err == NULL)
    return OK;

  return EUSELASTSETOSERR; /* Hint hint */
}

/* ------------------ */

_kernel_oserror *MsgError(int which)
{
  struct {
    int errnum;
    char errmess[8];
  } token;

  if (which == OK) return NULL; /* No error */

  if (which == EUSELASTSETOSERR)
  {
    /* An OS error outside this module */
    if (msg_oserr != NULL) return msg_oserr;
    which = EHOWDTHATHAPPEN;
  }
  
  sprintf(token.errmess, "E%02u", which);
  if ((which == EDIRNOTEMPTY) || (which == ENOACCESS))
  {
      /* Fudge for Filer_Action which expects a FileCore
       * style specific error return code
       */
      which = ErrorNumber_DirNotEmpty;
  }
  token.errnum = Our_Error_Base + which;
  return _swix(MessageTrans_ErrorLookup, _INR(0,3),
            &token, msg_struct, &msg_buff, sizeof(msg_buff));
}

/* ------------------ */

int RdCMOS ( int addr )
{
  return (_kernel_osbyte ( 161, addr, 0 ) & 0xFF00 ) >> 8;
}

/* ------------------ */

static void WrCMOS ( int addr, unsigned int data )
{
  _kernel_osbyte ( 162, addr, data );
}

/* --------------------- */

static void SetFSName(char *buf_in)
{
  int i, t;

  WrCMOS(CMOS_FSSTAT, 0);
  WrCMOS(CMOS_FSERVER1, buf_in[0]);
  if (buf_in[0] == 0) return;

  for (i=1; i < FSERVER_LEN; i++)
  {
    /* NAS 11/Feb/97 */
    t = buf_in[i];
    if (t <= 0x20 || t > 0x7F) t = 0;
    WrCMOS ( CMOS_FSERVER+i-1, t);
    if (t == 0) break;
  }
}

/* --------------------- */

static void GetFSName ( char *buf_out )
{
  int i;

  if (!_kernel_getenv("Inet$ServerName", buf_out, CMOS_FSERVER)) {
          return;
  }

  if ( RdCMOS ( CMOS_FSSTAT ) == 0 )
  {
    /* NAS 11/Feb/97 */
    *buf_out++ = RdCMOS ( CMOS_FSERVER1 );
    for ( i=1; i < FSERVER_LEN; i++ )
      *buf_out++ = RdCMOS ( CMOS_FSERVER+i-1 );
  }

  *buf_out = 0;
}

/* --------------------- */

static void lanman_announce_lanmanfs(int r2, void *pw)
{
#ifndef NO_NETBEUI
  /* Send the service call announcing the presence/absence of a protocol module */
  if (NB_InitedTransport == NB_NetBEUI_Setup)
    (void) _swix(OS_ServiceCall, _INR(0,4), pw,
      Service_DCIProtocolStatus, r2, DCIVERSION, Module_Title);
#endif
}

/* Finalisation code ------------------------------------ */

static void LM_Undeclare ( void )
{
  _kernel_swi_regs r;

  if ( LM_Declared )
  {
    r.r[0] = FSControl_RemoveFS;
    r.r[1] = (int)FilingSystemName;

    _kernel_swi( XOS_Bit | OS_FSControl, &r, &r );
    LM_Declared = false;
  }
}

/* ------------------ */

static void LM_GracefulClosedown(void)
{
  stopcallbacks();
  SMB_Shutdown();            /* Dismounts all SMB mounts first as */
  Omni_Shutdown();           /* Omni_Shutdown zeros the Mounts lists */
  Prn_Shutdown();            /* Free print jobs */
  NB_Shutdown();             /* Also calls LLC_Shutdown */
  Buf_Shutdown();            /* Tell MBufManager we're done */
  LM_Vars.initialised = LMInitState_PreInit;
}

_kernel_oserror * LM_Finalise (int fatal, int podule, void *pw)
{
  debug0("Finalise\n");
  (void) fatal;
  (void) podule;

  /* Dismount all (NB.Before announcing we're done with the protocol) */
  LM_GracefulClosedown();
  /* Tell the DCI driver the NetBEUI protocol is gone */
  lanman_announce_lanmanfs(DCIPROTOCOL_DYING, pw);
  /* Now mark this filing system as gone */
  LM_Undeclare();

  _swix(MessageTrans_CloseFile, _IN(0), msg_struct);
  _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());

  return NULL;
}


/* LM_declare ------------------------------------------ */

static _kernel_oserror *LM_Declare ( void )
{
  _kernel_oserror *err;
  int InfoBlk[12];

  LM_Declared = false;

  InfoBlk[0] = (int)FilingSystemName             - (int)Image_RO_Base;
  InfoBlk[1] = -1; /* Self-ident - request call FSFunc_PrintStartupBanner */
  InfoBlk[2] = (int) veneer_fsentry_open         - (int)Image_RO_Base;
  InfoBlk[3] = (int) veneer_fsentry_getbytes     - (int)Image_RO_Base;
  InfoBlk[4] = (int) veneer_fsentry_putbytes     - (int)Image_RO_Base;
  InfoBlk[5] = (int) veneer_fsentry_args         - (int)Image_RO_Base;
  InfoBlk[6] = (int) veneer_fsentry_close        - (int)Image_RO_Base;
  InfoBlk[7] = (int) veneer_fsentry_file         - (int)Image_RO_Base;
  InfoBlk[8] = Information_Word;
  InfoBlk[9] = (int) veneer_fsentry_func         - (int)Image_RO_Base;
  InfoBlk[10] = (int)veneer_fsentry_gbpb         - (int)Image_RO_Base;
  InfoBlk[11] = Information2_Word;

  err = _swix(OS_FSControl, _INR(0,3), FSControl_AddFS, Image_RO_Base,
    (int)InfoBlk - (int)Image_RO_Base, LM_pw);
  if ( err == NULL )
    LM_Declared = true;

  return err;
}


/* *Command processor ------------------------------------ */

#define MAX_ARGS    20
#define MAX_CMDLEN  256

static char Cmdbuf[ MAX_CMDLEN ];

/* --------------------- */

static int GetArgs ( const char *args, char *argv_out[], int maxargs )
{
  /* Splits "args" into a number of separate arguments. Each one is
     copied into Cmdbuf so it is held statically. Pointers to the
     start of each one are put in argv_out. Any unused spaces in
     argv_out are set to NULL for convenience. Returns the number
     of arguments actually found.  */

  int i, argc;

  for (i=0; i < maxargs; i++ ) argv_out[i] = NULL;

  i=0; /* In this loop, i counts characters in Cmdbuf */
  argc=0;

  do
  {
    while ( *args == ' ' ) /* Skip spaces */
      args++;

    if ( *args < ' ' )  /* The end */
      break;

    /* Got one */

    if ( argc >= maxargs )  /* Too many! */
      break;

    argv_out[argc++] = Cmdbuf+i;

    while ( i < MAX_CMDLEN-1 && *args > ' ' ) /* Copy it */
      Cmdbuf[i++] = *args++;

    Cmdbuf[i++] = 0;     /* Terminate it */
  }
    while ( i < MAX_CMDLEN-1 );

  return argc;
}

/* --------------------- */

static _kernel_oserror *Cmd_LanMan ( const char *args )
{
  /* No args! */
  _kernel_swi_regs r;
  (void) args;

  r.r[0] = FSControl_SelectFS;
  r.r[1] = (int)FilingSystemName;

  return _kernel_swi( XOS_Bit | OS_FSControl, &r, &r );
}

/* --------------------- */

static _kernel_oserror *Cmd_Free ( const char *args )
{
  _kernel_swi_regs r;
  _kernel_oserror *e;
  int values[6];
  char *argv[1];

  if (GetArgs(args, argv, sizeof(argv)/sizeof(*argv)) == 0)
    argv[0] = getenv("FileSwitch$" FilingSystemName "$CSD");

  if (argv[0] == NULL)
    return MsgError( EBADDRV );

  r.r[0] = 4; /* 64-bit free space - will not fail! */
  r.r[1] = Our_FS_Number;
  r.r[2] = (int) values;
  r.r[3] = (int) argv[0];
  e = Omni_FreeOp_SWI(&r);

  if (e == NULL) {
    if (values[3] == 0 && values[5] == 0) {
      printf("%s &%08X\n", MsgLookup("Free"), values[2] );
      if (values[4] != -1) {
        printf("%s &%08X\n", MsgLookup("Used"), values[4] );
      }
      else {
        printf("%s\n", MsgLookup("UsedUK")); /* Unknown */
      }
    }
    else {
      printf("%s &%08X%08X\n", MsgLookup("Free"), values[3], values[2] );
      if (values[4] != -1) {
        printf("%s &%08X%08X\n", MsgLookup("Used"), values[5], values[4] );
      }
      else {
        printf("%s\n", MsgLookup("UsedUK")); /* Unknown */
      }
    }
  }

  return e;
}

/* --------------------- */
static _kernel_oserror *Cmd_ListFS ( const char *args )
{
  char *argv[1];

  if (GetArgs(args, argv, sizeof(argv)/sizeof(*argv)) == 0) {
    return Omni_DumpServers();
  }
  else {
    return Omni_DumpShares(argv[0]);
  }
}

/* --------------------- */

static _kernel_oserror *Cmd_LMConnect ( const char *args )
{
  char *argv[5];
  err_t res;
  int   tmp;

  if ( GetArgs ( args, argv, 5 ) < 3 )
    return MsgError(EBADPARAM);

  /* Convert '-' user name to NULL */

  if ( argv[3] != NULL    &&
       argv[3][0] == '-'  &&
       argv[3][1] == 0 )
    argv[3] = NULL;

  res =  Omni_MountServer ( argv[1],  /* Server */
          argv[3], /* User name or NULL */
          argv[4], /* password or NULL */
          argv[0], /* Mountname */
          argv[2], /* Drive name */
          &tmp ); /* MountID_out */

  Omni_RecheckInfo ( RI_MOUNTS );
  return MsgError(res);
}

/* --------------------- */

static _kernel_oserror *Cmd_LMDisconnect ( const char *args )
{
  char *argv[1];
  int mountID;
  err_t res;

  if ( GetArgs( args, argv, 1 ) < 1 )
    return MsgError(EBADPARAM);

  mountID = Omni_GetMountID(argv[0]);
  if ( mountID == 0 ) return MsgError ( EBADDRV );

  res = Omni_DismountServer(mountID);
  Omni_RecheckInfo ( RI_MOUNTS );
  return MsgError (res);
}


/* --------------------- */

static void LanMan_InitTransport(pfnTransportInit i)
{
        NB_InitedTransport = i;
        (*i)();
}

static void SetDefaultVars ( void )
{
  char *name;
  char fs_name [ FSERVER_LEN+1 ];

  LM_Vars.initialised = LMInitState_Uninitialised;
  LM_Vars.namemode = NM_FIRSTCAPS;

  /* See where IP packets are going to be sent */
  name = getenv("Inet$EtherType");
  strcpyn ( LM_Vars.drivername,
                (name==NULL) ? DEFAULT_ETHER_TYPE : name, NAME_LIMIT );

  name = getenv("Inet$HostName");
  /* Trap added to catch 'ARM_NoName', as set by STB OS */
  if ((name == NULL) || (stricmp(name,"ARM_NoName")==0))
    strcpy ( LM_Vars.machinename,   "" );
  else
  {
    strcpyn_upper ( LM_Vars.machinename, name, NAME_LIMIT );
    /* Truncate at first dot - it might be a full domain name */
    name = strchr ( LM_Vars.machinename, '.' );
    if ( name != NULL ) *name = 0;
  }

  /* See if the user has overridden the default filetype */
  name = getenv("LanMan$DefaultType");
  if (name != NULL)
  {
    _swix(OS_FSControl, _INR(0,1)|_OUT(2), 31, name, &LM_Vars.default_type);
  }
  else
  {  
    LM_Vars.default_type = CNV_DEFAULT_TYPE;
  }

  /* Read the base of the OS ROM so there's an address to use for
   * untyped load/exec address, ensuring they would abort if used
   */
  _swix(OS_Module, _INR(0,2)|_OUT(3), 12, 0, 0, &LM_Vars.untyped_address);
  LM_Vars.untyped_address = LM_Vars.untyped_address & ~((1<<20) - 1);

  /* Following 'get from CMOS' bits added 980127:RCE
   * to address user complaints that it has to be typed in every time
   */
  Lgn_Init();
  GetFSName(fs_name);
  if (fs_name[0] != '\0')
  {
    strcpy(LM_Vars.workgroup,fs_name);
  }

  /* Set transport type from CMOS, unless overridden on command line */
#ifdef NO_NETBEUI
  LanMan_InitTransport(NB_NBIP_Setup);
#else
  LanMan_InitTransport(RdCMOS ( CMOS_NB_TYPE ) & NBTYPE_IP_BIT  ?
    NB_NBIP_Setup : NB_NetBEUI_Setup);
#endif
}

/* --------------------- */

static _kernel_oserror *Cmd_LMLogoff( const char *args )
{
  (void) args;
  Lgn_Logoff();
  return NULL;
}

/* --------------------- */

static _kernel_oserror *Cmd_LMLogon( const char *args )
{
  char *argv[3];
  if ( GetArgs(args, argv, 3) < 2 )
    return MsgError(EBADPARAM);

  /* argv[2] may be NULL for blank password */

  return MsgError (Lgn_Logon ( argv[0], argv[1], argv[2] ) );
}

/* --------------------- */

#ifdef DEBUG
static char *LM_Status(void)
{
        switch (LM_Vars.initialised) {
        case LMInitState_Uninitialised: return "Dormant";
        case LMInitState_PreInit: return "Waiting for driver";
        case LMInitState_FullyInited: return "Active";
        case LMInitState_Boot: return "Waiting to boot";
        default: return "Dead";
        }
}
#endif

/* --------------------- */

static _kernel_oserror *Cmd_LMInfo ( const char *args )
{
  (void) args;
  Omni_Debug();
#ifdef DEBUG
  debug1("Status: %s\n", LM_Status());
  Stat_Show();
#endif
  return NULL;
}

/* --------------------- */

static _kernel_oserror *Cmd_LMNameMode ( const char *args )
{
  char *argv[1];
  int tmp;

  if ( GetArgs( args, argv, 1 ) < 1 ||
       sscanf( argv[0], "%d", &tmp) != 1 ||
       tmp < 0 ||
#ifdef TRACE
       0
#else
       tmp > 2
#endif
     )
    return MsgError (EBADPARAM);

  LM_Vars.namemode = tmp;
  return NULL;
}

/* --------------------- */

static _kernel_oserror *Cmd_LMServer ( const char *args )
{
  char *argv[MAX_ARGS];
  int i;

  if ( GetArgs( args, argv, MAX_ARGS ) < 1 )
    return MsgError ( EBADPARAM );

  if ( argv[1] == NULL ) /* Just name of server */
  {
    Omni_AddInfo ( OAI_SERVER, argv[0], NULL, NULL );
  }
  else
  {
    for ( i=1; i < MAX_ARGS && argv[i] != NULL; i++ )
      Omni_AddInfo ( OAI_DISK, argv[0], argv[i], NULL );
  }

  Omni_RecheckInfo (RI_SERVERS);
  return NULL;
}

/* --------------------- */

static _kernel_oserror *Cmd_LMPrinters ( const char *args )
{
  char *argv[MAX_ARGS];
  int i;

  if ( GetArgs( args, argv, MAX_ARGS ) < 1 )
    return MsgError ( EBADPARAM );

  if ( argv[1] == NULL ) /* Just name of server */
  {
    Omni_AddInfo ( OAI_SERVER, argv[0], NULL, NULL );
  }
  else
  {
    for ( i=1; i < MAX_ARGS && argv[i] != NULL; i++ )
      Omni_AddInfo ( OAI_PRINTER, argv[0], argv[i], NULL );
  }

  Omni_RecheckInfo (RI_SERVERS);
  Omni_RecheckInfo (RI_PRINTERS);
  return NULL;
}

/* --------------------- */

static _kernel_oserror *Cmd_FS ( const char *args )
{
  /* This is a *Configure/Status command handler - it's therefore unusual */
  char *argv[1];

  if ( (int) args == 0 ) /* Show 'Configure' options */
  {                      /* Syntax corrected 980127 RCE */
    printf("FS           %s\n", MsgLookup("ConfFS"));
    return NULL;
  }
  else if ( (int) args == 1 ) /* Show FS status */
  {
    char buf[NAME_LIMIT];
    GetFSName(buf);
    printf("FS           %s\n", buf[0] ? buf : MsgLookup("NoHome"));
    return NULL;
  }

  if ( GetArgs( args, argv, 1 ) < 1 )
    return MsgError ( EBADPARAM );

  SetFSName(argv[0]);
  return NULL;
}

/* --------------------- */

static _kernel_oserror *Cmd_LMTransport ( const char *args )
{
  /* This is a *Configure/Status command handler */
  char *argv[1];
  static const char *tp1 = "IP";

#ifdef NO_NETBEUI
  if (args == arg_CONFIGURE_SYNTAX || args == arg_STATUS)
  {
    printf("LMTransport  IP\n");
    return NULL;
  }
#else
  static const char *tp0 = "NetBEUI";
  if ( args == arg_CONFIGURE_SYNTAX ) /* Show 'Configure' options */
  {
    printf("LMTransport  <%s | %s>\n", tp0, tp1);
    return NULL;
  }
  else if ( args == arg_STATUS ) /* Show FS status */
  {
    printf("LMTransport  %s\n",
      (RdCMOS(CMOS_NB_TYPE) & NBTYPE_IP_BIT) ? tp1:tp0);
    return NULL;
  }
#endif
  if ( GetArgs( args, argv, 1 ) < 1 )
    return MsgError ( EBADPARAM );

#ifndef NO_NETBEUI
  if ( stricmp ( argv[0], tp0 ) == 0 )
    WrCMOS(CMOS_NB_TYPE, RdCMOS(CMOS_NB_TYPE) & ~NBTYPE_IP_BIT );
  else
#endif
  if ( stricmp ( argv[0], tp1 ) == 0 )
    WrCMOS(CMOS_NB_TYPE, RdCMOS(CMOS_NB_TYPE) | NBTYPE_IP_BIT );
  else
    return configure_BAD_OPTION;

  return NULL;
}

/* --------------------- */
static _kernel_oserror *Cmd_LMNameServer( const char *args )
{
  /* This is a *Configure/Status command handler - it's therefore unusual */
  char *argv[1];
  struct in_addr address;
  int result;

  if ( args == arg_CONFIGURE_SYNTAX ) /* Show 'Configure' options */
  {
    printf("LMNameServer xx.xx.xx.xx\n");
    return NULL;
  }
  else if ( args == arg_STATUS ) /* Show FS status */
  {
    int b0, b1, b2, b3;

    b0 = RdCMOS(NBNSIPCMOS0);
    b1 = RdCMOS(NBNSIPCMOS1);
    b2 = RdCMOS(NBNSIPCMOS2);
    b3 = RdCMOS(NBNSIPCMOS3);

    if ( ((b0 != 0) && (b0 != 127) && (b0 <= 223))  &&  ((b3 != 0) && (b3 != 255)) )
    {
      printf("LMNameServer %d.%d.%d.%d\n", b0,b1,b2,b3);
    }
    else
    {
      printf("LMNameServer %s\n", MsgLookup("NoHome"));
    }
    return NULL;
  }
  else if (GetArgs(args,argv,1) == 1)
  {
    result = inet_aton(argv[0],&address);
    if (result)
    {
      unsigned char b0, b1, b2, b3;

      b0 = (unsigned char)(address.s_addr >> 0);
      b1 = (unsigned char)(address.s_addr >> 8);
      b2 = (unsigned char)(address.s_addr >> 16);
      b3 = (unsigned char)(address.s_addr >> 24);

      if ( ((b0 != 127) && (b0 <= 223))  &&  ((b3 != 255)) )
      {
        WrCMOS(NBNSIPCMOS0,(int) b0);
        WrCMOS(NBNSIPCMOS1,(int) b1);
        WrCMOS(NBNSIPCMOS2,(int) b2);
        WrCMOS(NBNSIPCMOS3,(int) b3);
        return NULL;
      }
    }
  }
  return MsgError(EBADPARAM);
}

/* --------------------- */

typedef _kernel_oserror * (*CommandFnPtr) ( const char *args );

#define CmdEntry(X) [CMD_##X] = Cmd_##X
static CommandFnPtr Cmd_Dispatch[] =
{
  CmdEntry(LanMan),
  CmdEntry(LMConnect),
  CmdEntry(LMDisconnect),
  CmdEntry(LMLogon),
  CmdEntry(LMInfo),
  CmdEntry(LMNameMode),
  CmdEntry(LMLogoff),
  CmdEntry(LMServer),
  CmdEntry(LMPrinters),
  CmdEntry(FS),
  CmdEntry(LMTransport),
  CmdEntry(LMNameServer),
  CmdEntry(Free),
  CmdEntry(ListFS)
};

#define MAX_CMDS (sizeof Cmd_Dispatch / sizeof Cmd_Dispatch[0])

/* --------------------- */

_kernel_oserror *LM_Command ( const char *args, int argc, int cmd_no, void *pw )
{
  (void) pw;
  (void) argc;

  if ( cmd_no < 0 || cmd_no >= MAX_CMDS )
    return MsgError(ENOTPRESENT);

  return Cmd_Dispatch[cmd_no](args);
}

/* Service call handler --------------------------------- */
static void LM_check_driver_status(_kernel_swi_regs *r);
static void LM_check_internet_status(_kernel_swi_regs *r);
static void LM_check_protocol_status(_kernel_swi_regs *r);

void LM_Service ( int service_number, _kernel_swi_regs *r, void *pw )
{
  (void) pw;
  /* Any changes to list of service calls?  Must mirror in cmhg inputfile too! */

  switch(service_number)
  {
    case Service_FSRedeclare:
      LM_Declare();
      break;

    case Service_OmniAction:
      Omni_ServiceCall (r);
      break;

    case Service_ResourceFSStarting:
      /* Reregister with ResourceFS */
      (*(void (*)(void *, void *, void *, void *))r->r[2])(Resources(), 0, 0, (void *)r->r[3]);
      break;

    case Service_DCIDriverStatus:
      LM_check_driver_status(r);
      break;

    case Service_DCIProtocolStatus:
      LM_check_protocol_status(r);
      break;

    case Service_InternetStatus:
      if (NB_InitedTransport == NB_NBIP_Setup) {
          LM_check_internet_status(r);
      }
      break;

    default:
      break;
  }
}

/* SWI handler ------------------------------------------ */

_kernel_oserror *LM_Swi( int swi_ofs, _kernel_swi_regs *r, void *pw )
{
  (void) pw;  /* Not used */
  switch ( swi_ofs )
  {
    case LanMan_OmniOp - LanMan_00:
      return OmniOp_SWI(r);

    case LanMan_LogonOp - LanMan_00:
      return Lgn_LogonOp_SWI(r);

    case LanMan_FreeOp - LanMan_00:
      return Omni_FreeOp_SWI(r);

    case LanMan_NameOp - LanMan_00:
      return MsgError(RPC_NameOp(r->r[0], /* reason code */
                                  (char *)(r->r[1]), /* name in */
                                  (char *)(r->r[2])  /* buffer out */
                                   ));
    case LanMan_Transact - LanMan_00:
      return MsgError(RPC_Transact((char *)(r->r[0]), /* server */
                                    (char *)(r->r[1]), /* share name */
                                    (void *)(r->r[2]) /* params */
                                     ));

    default:
      return MsgError(ENOTPRESENT);
  }

  return NULL;
}

/* Initialisation code ---------------------------------- */

static char *copy_space ( char *dst, char *src, int maxlen )
{
  while ( *src > ' ' )
  {
    if ( --maxlen > 0 )
      *dst++ = *src;
    src++;
  }

  *dst = 0;
  return src;
}

/* ------------------------------- */

static err_t ProcessCmdLine ( const char *_line )
{
  char cli[256];
  char *end;
  char *line;

  /* This code relies on NB_xxx_Setup() only setting variables, not
     allocating anything. Multiple NB_xxx_Setup()'s may be called if
     the user is being perverse */

  /* NAS 20/3/97 - RO doesn't pass a 0-terminated string, but a ctrl-terminated one */
  strncpy(cli, _line, 255);
  line = end = cli;
  while (*end >= ' ') end++;
  *end = '\0';

  while ((line = strchr(line, '-')) != NULL)
  {
    line++;
    switch ( toupper(*line) )
    {
      case 'D': /* -d<driver_name> specify driver name */
         line = copy_space ( LM_Vars.drivername, line+1, NAME_LIMIT );
         break;

      case 'N': /* -n disable network browsing */
         Lgn_Logoff();
         break;

      case 'M': /* -m<name> use name as the advertised NETBIOS name */
         line = copy_space( LM_Vars.machinename, line+1, NAME_LIMIT );
         strcpyn_upper( LM_Vars.machinename,LM_Vars.machinename,NAME_LIMIT );
         break;

      case 'I': /* -i use NBIP */
         LanMan_InitTransport(NB_NBIP_Setup);
         break;

#ifndef NO_NETBEUI
      case 'T': /* -t use NetBEUI */
         LanMan_InitTransport(NB_NetBEUI_Setup);
         break;
#endif

      default:
         return ECMDLINE;
    }
  }

  return OK;
}


/* ------------------------------- */

void LM_Boot(void)
{
  int tries=1;
  int tmp;
  err_t res;
  char *serv_name;
  char fs_name [ FSERVER_LEN+1 ];

  if (LM_Vars.initialised < LMInitState_FullyInited) {
    debug1("LM_Boot called, but cannot comply: %s\n", LM_Status());
    LM_Vars.initialised = LMInitState_Boot;
    return;
  }

  GetFSName(fs_name);

  if ( strlen(fs_name) == 0 )
  {
    debug0("Auto-boot: server name has not been set...\n");
    return;
  }

  /* Ready to go... */

  for (;;) {
    serv_name = RPC_GetDomainController(fs_name);
    if ( serv_name == NULL )
      serv_name = fs_name;

    debug1( "Server name '%s'\n", serv_name );

    /* Wash'n'go... */

    res =  Omni_MountServer ( serv_name,  /* Server */
            "ARMBOOT", "", /* User name & password */
            "BOOT",        /* Mountname */
            "ARMBOOT",     /* Drive name */
            &tmp );          /* MountID_out */

    if ( res != OK )
    {
      printf("%s '%s' - ", MsgLookup("BootBad"), serv_name);
      printf("%s", MsgError(res)->errmess);
      /* tmp will be zero unless the share was successfully created */
      if (tmp == 0)
      {
        char var_name[sizeof("Inet$ServerName12")];
        sprintf(var_name, "Inet$ServerName%d", ++tries);
        if (!_kernel_getenv(var_name, fs_name, FSERVER_LEN))
          continue; /* Try next server */
      }
    }
    break;
  }
}


/* ------------------------------- */


/* SNB 980224.
 *
 *
 *  This function has been split into two as it is inappropriate for some
 *  parts of this code to be executed during a service call.  The initialised
 *  member of LM_Vars has been promoted to 'int' type so that it can hold any
 *  of the values in the anonymous enum at the top of this file.  This is used
 *  to control the execution of the LM_init_phase_2 function.
 *
 *
 */

_kernel_oserror *LM_Initialise(const char *cmd_tail, int pod_base, void *pw)
{
  _kernel_oserror *err;
  _kernel_swi_regs R;

  debug_initialise("LanManFS", "", "");
  debug_atexit();
  debug_set_options(0,0,0);
  debug_output_device(DEBUGIT_OUTPUT);
  LM_Vars.initialised = LMInitState_Uninitialised;

  (void)pod_base;
  if (pw != NULL)
  {
    LM_pw = (int)pw;
  }

  err = _swix(ResourceFS_RegisterFiles, _IN(0), Resources());
  if (err != NULL) return err;
  err = _swix(MessageTrans_OpenFile, _INR(0,2),
              msg_struct, "Resources:$.ThirdParty.OmniClient.LanManFS.Messages", 0);
  if (err != NULL) goto initdereg;

  SetDefaultVars();

  R.r[0] = 129;
  R.r[1] = 0;
  R.r[2] = 255;
  _kernel_swi(OS_Byte, &R, &R);
  if (R.r[1] < 0xA2)
  {
    err = MsgError(ERISCOSVER);
    goto initclose;
  }

  if (cmd_tail != NULL)
  {
    err = MsgError(ProcessCmdLine(cmd_tail));
    if (err != NULL) goto initclose;
  }

  err = LM_Declare();
  if (err != NULL) goto initclose;

  LM_Vars.initialised = LMInitState_PreInit;

  (void) LM_init_phase_2();

#ifndef NO_NETBEUI
  /* Cheap way to set a callback ;-) Send service call announcing ourselves */
  if (NB_InitedTransport == NB_NetBEUI_Setup) {
    callevery_handler(&R, pw);
    callbackflag = 2;
  }
#endif

  return NULL;

initclose:
  _swix(MessageTrans_CloseFile, _IN(0), msg_struct);
initdereg:
  _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());
  return err; 
}

static _kernel_oserror *LM_init_phase_2(void)
{
  /* Initialise various modules */

  enum { MAXEXITS = 4 };
  pfnShutdown shutdowns[MAXEXITS];
  int ctr = 0;
  int want_boot;
  int oldstate = LM_Vars.initialised;
  _kernel_oserror *err;

  want_boot = (LM_Vars.initialised == LMInitState_Boot);

  debug0("Initialising...\n");

  if (!FS_Init() || !SMB_Init()) goto initfailed;
  shutdowns[ctr++] = (pfnShutdown) SMB_Shutdown;
  if (!RPC_Init() || !Prn_Init()) goto initfailed;
  shutdowns[ctr++] = (pfnShutdown) Prn_Shutdown;
  if (!Stat_Init()) goto initfailed;

  err = MsgError(Buf_Init());
  if (err != NULL) goto abort;

  shutdowns[ctr++] = (pfnShutdown) Buf_Shutdown;

  /* Try to start various modules */

  debug0("Starting network transport...\n");

  err = MsgError( NB_Startup() );
  if (err != NULL)
  {
    debug2(    "Error - NB_Startup() returned %d (%s)\n",err->errnum,err->errmess);
    goto abort;
  }

#if 0
  debug0("Starting filing system...\n");

  err = LM_Declare();
  if (err != NULL) {
          debug1("LanManFS: %s\n", err->errmess);
          NB_Shutdown();
          goto abort;
  }
#endif

  startcallbacks();

  /* We have now managed to fully initialise everything that we need - whee! */
  LM_Vars.initialised = LMInitState_FullyInited;
  ctr=0; /* Forget destructors */

  _kernel_oscli("IconSprites Resources:$.ThirdParty.OmniClient.LanManFS.Sprites");

  Omni_StartUp();  /* Try to contact OmniFiler */

  /*LM_StartupBoot();*/
  if (want_boot) {
          debug0("Booting...\n");
          LM_Boot();
  }

  debug0("All done...\n");

  return NULL;

initfailed:
  err = MsgError(EINITFAILED);
  debug2("LanManFS: %s (%s)\n", err->errmess, LM_Status());
  while (--ctr >= 0) (shutdowns[ctr])();
  return err;

abort:
  LM_Vars.initialised = oldstate;
  while (--ctr >= 0) (shutdowns[ctr])();
  debug1("LanManFS: %s\n", LM_Status());
  return NULL;

/* abort used to use this, but that assumes deterministic module startup,   *
 * which can't be assumed under DCI4, so now it just sits around waiting    *
 * for an appropriate set of service calls to wake it up.  RCE 980212       *

abort:
  LM_Finalise();
  return err;
 */
}

/* SNB 980224 added this function to verify the actual contents of the
 * Service_DCIDriverStatus service call
 */
static void LM_check_driver_status(_kernel_swi_regs *r)
{
        char if_name[16];
        Dib *dib = (Dib *) (r->r[0]);

        sprintf(if_name, "%-.8s%d", dib->dib_name, dib->dib_unit);

#ifdef TRACE
        printf ("Service_DCIDriverStatus called (interface %s%d is %sing)\n"
        	"  Driver supports DCI version %d.%02d\n",
        	dib->dib_name, dib->dib_unit, r->r[2] ? "dy" : "start",
		r->r[3] / 100, r->r[3] % 100
                );

        printf ("We are looking for driver `%s' - got `%s'\n", LM_Vars.drivername,
        	if_name);

#endif
        if ((strcmp(LM_Vars.drivername, DEFAULT_ETHER_TYPE) == 0) &&
            (r->r[2] == DCIDRIVER_STARTING) &&
            (if_name[0] != 'l')) {
                /* Capture the first interface to start which isn't loopback */
                (void) strncpy(LM_Vars.drivername, if_name, NAME_LIMIT);
        }

#ifndef NO_NETBEUI
        if (NB_InitedTransport != NB_NetBEUI_Setup) {
                return;
        }

        if (stricmp(LM_Vars.drivername, if_name) == 0) {
                debug0("Ding!  This was our interface\n");
		if (r->r[2] == DCIDRIVER_STARTING) {
		        /*if (LM_Vars.initialised ==  LMInitState_FullyInited)*/ {
                        	LM_GracefulClosedown();
		        }
	                LM_init_phase_2();
		}
		else if (r->r[2] == DCIDRIVER_DYING) {
		        LM_GracefulClosedown();
		}
        }
#endif
}

static void LM_check_protocol_status(_kernel_swi_regs *r)
{
  /* A protocol module came or went (could be us in NetBEUI mode!)
   * Inform our transport layer if we find it was Internet leaving.
   */
  const char *proto = (char *) r->r[4];

  if (r->r[2] == DCIPROTOCOL_DYING && strcmp(proto, "Internet") == 0) {
    NB_InternetGone();
  }
  else if (r->r[2] == DCIPROTOCOL_STARTING && strcmp(proto, "Internet") == 0) {
    NB_InternetInit();
  }
}


#ifdef TRACE

static void DumpBuffer(void *ptr, int len)
{
        static char db[512];
        char *p = db;

        const char *membuf = ptr;
        int i,j;
	db[0] = '\0';
        for (i=0; i<((len+31)&~31); ++i) {
                if (!(i & 31)) {
                        p += sprintf (p, "  ");
                        if (i) for (j = i - 32; j != i; ++j) {
                                p+=sprintf(p, "%c", (membuf[j]>=32 && membuf[j] != 0x7f) ?
                                membuf[j] : '.');
                        }
                        printf("$%s\n", db);
                        p=db+sprintf(db,"%04x: ", i);
                }
                if (i>=len) {
                        p+=sprintf (p,"  ");
                        if (3==(i & 3)) p+=sprintf (p," ");
                }
                else {
                        p+=sprintf (p,"%02x", membuf[i]);
                        if (3==(i & 3)) p+=sprintf (p," ");
                }
        }
        if (i) for ( p+=sprintf (p,"  "), j = i - 32; j != i; ++j) p+=sprintf (p,"%c",
            j>=len ? ' ' : (membuf[j]>=32 && membuf[j] != 0x7f) ?
            membuf[j] : '.');
        printf("$%s\n", db);
}
#endif

/* SNB 981029 added this function to verify the contents of the Service_InternetStatus
 * service call to determine whether we were waiting for the interface to go up so
 * that we could boot
 */
static void LM_check_internet_status(_kernel_swi_regs *r)
{
        char *cp = (char *) r->r[3];

	if (r->r[0] == InternetStatus_AddressChanged) {
	  if (LM_Vars.initialised != LMInitState_PreInit &&
	      LM_Vars.initialised != LMInitState_Boot) {
            return;
	  }
	  /* An interface address was set - almost certainly ours! */
	}
#ifdef TRACE
	else if (r->r[0] == InternetStatus_DynamicBootReply) {
	  DumpBuffer((void *)r->r[4], r->r[5]);
	}
	else if (r->r[0] == InternetStatus_DynamicBootStart) {
	  DumpBuffer((void *)r->r[4], r->r[5]);
	}
#endif
        else {
          /* Were we actually waiting for the driver to appear */
    	  if (LM_Vars.initialised != LMInitState_PreInit &&
              LM_Vars.initialised != LMInitState_Boot) return;
     	  /* Was it the right reason code? */
	  if (r->r[0] != InternetStatus_InterfaceUpDown) return;
	  /* Was it the right interface? */
	  if (stricmp(LM_Vars.drivername, cp) != 0) return;
	  /* was the interface coming up? */
	  if (r->r[2] != 1) return;
        }

	/*if (LM_Vars.initialised == LMInitState_FullyInited)*/ {
	        /* Should never happen nowadays ?? */
	        LM_GracefulClosedown();
	}
	LM_init_phase_2();
}

#ifdef TRACE
/* Debugging routine.  If str is NULL, then the log is printed to 'f' (or stderr
 * if f was NULL).  If f is NULL, the message is added to the log but not displayed
 * on the screen.  If neither f nor str was NULL, the screen characteristcs are set
 * to useful things (text window is reset, default colours restored and text origin
 * restored to 0,0, and the message is printed to the screen and copied to tne log.
 * A monotonic coumnter is incremented for each debug message logged.  Timestamps
 * are stored in the log buffer too.
 */
#include <stdarg.h>
int module_printf(const char *str, ...)
{
	static int callcount = 0;
	static char pbuffer[65536];
	static int pbufferptr = 0;
	va_list ap;
	int inblock[2];
	FILE *f;

	f=stderr;

	if (f != NULL || str == NULL)  {
		inblock[1] = -1;
		inblock[0] = 132;
		_swix(OS_ReadVduVariables, _INR(0,1), inblock, inblock);
		_swix(OS_WriteC, _IN(0), 6);
		if (inblock[0] > 20) {
			int i;
			for (i=0; i<0; ++i) (void) _kernel_osbyte(19,0,0);
			_swix(OS_WriteN, _INR(0,1), "\x1a\x0c", 2);
		}
		_swix(OS_WriteC, _IN(0), 20);
	}

	if (!str) {
		if (pbufferptr > 0) fprintf(f?f:stderr, "%s\n", pbuffer);
		return 0;
	}

	++callcount;
	if (*str != '$' && f != NULL) {
		va_start(ap, str);
		vfprintf(f, str, ap);
		va_end(ap);
	}
	va_start(ap, str);
	_swix(OS_ReadMonotonicTime, _OUT(0), inblock);
	if (*str == '$') ++str; else
	pbufferptr += sprintf(pbuffer + pbufferptr, "(%8d) (%4d) ", inblock[0], callcount);
	pbufferptr += vsprintf(pbuffer + pbufferptr, str, ap);
	if (pbufferptr > 60000) pbufferptr = 0;
	return 0;
}
#endif


/* ========== Callback code ========== */

/* Callback management.  Some servers tend to idle-out connections.  This code stops
 * that happening.
 */

_kernel_oserror *callback_handler(_kernel_swi_regs *r, void *pw)
{
	(void) r;
	switch (callbackflag) {
	  case 2:
                /* Re-entrancy on this code is OK - announce we are starting */
                callbackflag = 0;
                lanman_announce_lanmanfs(DCIPROTOCOL_STARTING, pw);
                break;
	  case 1:
	        debug0("Anti IdleOut Callback entered\n");
	        SMB_AntiIdle();
		callbackflag = 0;
	}
	return 0;
}

static void clearcallback(void)
{
	if (callbackflag != 0) {
		(void) _swix(OS_RemoveCallBack, _INR(0,1), callback_entry, LM_pw);
		callbackflag = 0;
	}
}

_kernel_oserror *callevery_handler(_kernel_swi_regs *r, void *pw)
{
        (void) r;
	if (callbackflag == 0) {
		if (_swix(OS_AddCallBack, _INR(0,1), callback_entry, pw) == NULL) {
			callbackflag = 1;
			debug0(Module_Title ": (setcallback) just set a callback\n");
		}
	}
	return 0;
}

static void startcallbacks(void)
{
        /* Remember that as the SMB_AntiIdle routine rotates through all the shares,
         * each share will only be every pinged MAX_SHARES * 100 * 45 seconds.
         */
        (void) _swix(OS_CallEvery, _INR(0,2), (100*45) - 1, callevery_entry, LM_pw);
}

static void stopcallbacks(void)
{
        (void) _swix(OS_RemoveTickerEvent, _INR(0,1), callevery_entry, LM_pw);
        clearcallback();
}
@


1.22
log
@Don't pass silly error numbers to MsgTrans
Detail:
  c/LanMan - Don't pass silly error numbers to MessageTrans_ErrorLookup - the kernel will now fault them.
Admin:
  Tested on Raspberry Pi 3
  Fixes "bad error pointer" message when e.g. failing to log on to a share:
  https://www.riscosopen.org/forum/forums/4/topics/5264


Version 2.55. Tagged as 'LanManFS-2_55'
@
text
@d710 1
a710 1
  char *tp1 = "IP";
d719 1
a719 1
  char *tp0 = "NetBEUI";
d722 1
a722 1
    printf("LMTransport  [%s | %s]\n", tp0, tp1);
@


1.21
log
@Make name cache flush unconditional
CoreFn.c:
The size returned by OS_File 5 might not match the size shown in the Filer viewer (or via *EX) because the last cached version was being returned. This would manifest itself as an error from !Edit if the file on the server had grown since last queried, when loading the file the amount of memory reserved was for the smaller (stale cache copy size).
The name cache is now always flushed on exit from the FileSwitch functions, this doesn't alter performance because the size was already being queried across the network, it was just that the result was overridden by the cached copy.
LanMan.c:
Be more robust and only capture the default driver name when it starts up.
This could be a problem if LanManFS starts after the ethernet driver, and the value of Inet$EtherType is unset. When the driver dies LanManFS would have taken that name as the default - leading to "Bad parameter" when trying to connect to a share.

Tested on IOMD with WinXP SP3.

Version 2.44. Tagged as 'LanManFS-2_44'
@
text
@d143 4
a146 2
  char token[12];
  _kernel_oserror *e;
d157 2
a158 4
  sprintf(token, "@@@@@@@@E%02u", which);
  e = _swix(MessageTrans_ErrorLookup, _INR(0,3),
            token, msg_struct, &msg_buff, sizeof(msg_buff));
  if (e->errnum == 0x40404040)
d160 8
a167 11
    /* Same error number out as went in, looked up OK */
    if ((which == EDIRNOTEMPTY) || (which == ENOACCESS))
    {
        /* Fudge for Filer_Action which expects a FileCore
         * style specific error return code
         */
        which = ErrorNumber_DirNotEmpty;
    }
    msg_buff.errnum = Our_Error_Base + which;
  }
  return(e);
@


1.20
log
@Insert default sprites into Wimp pool prior to registering with OmniClient

Version 2.43. Tagged as 'LanManFS-2_43'
@
text
@d1244 5
a1248 4
        if (strcmp(LM_Vars.drivername, DEFAULT_ETHER_TYPE) == 0) {
                if (if_name[0] != 'l') {
                	(void) strncpy(LM_Vars.drivername, if_name, NAME_LIMIT);
                }
d1256 1
a1256 6

        if (stricmp(LM_Vars.drivername, if_name) != 0) {
                /* printf("Not interested\n"); */
                return;
        }
        else {
d1258 1
a1258 1
		if (r->r[2] == 0) {
d1264 1
a1264 1
		else if (r->r[2] == 1) {
@


1.19
log
@Fix for converting "OK" into "Internal error"
Whose bright idea was it to use 0 for both? Fixes problem reported
  http://www.riscosopen.org/forum/forums/4/topics/2122

Version 2.42. Tagged as 'LanManFS-2_42'
@
text
@d1187 2
a1190 2
  _kernel_oscli("IconSprites Resources:$.ThirdParty.OmniClient.LanManFS.Sprites");

@


1.18
log
@Removed verbose mode
With LanManFS in ROM it's not actually possible to enable verbose mode, since it relies on command arguments being passed to it on initialisation. Since RMREINIT doesn't allow that you can't ever pass '-v'. Even the RAM loaded case isn't that useful, since the verbose text is output via printf() which doesn't appear in the desktop (with OmniClient).
Swap the few uses of verbose mode to route via DebugLib instead, controlled via the 'DEBUG' predefine.
Also
  Makefile ammended so debug version has a rule to make the resources area.
Built, but not tested.

Version 2.41. Tagged as 'LanManFS-2_41'
@
text
@d146 2
d152 1
a152 1
    which = 0; /* Internal error! */
@


1.17
log
@Internationalised
Unused LMFiler put in the attic.
As LanMan has historically put its resources into ThirdPart/OmniClient this component has no ROM resources phase - it still registers the resources at run time.

Version 2.40. Tagged as 'LanManFS-2_40'
@
text
@a500 6
#ifdef DEBUG
  LM_Vars.verbose = true; /* DEBUG NAS */
#else
  LM_Vars.verbose = false;
#endif

d581 1
d592 1
d600 4
a603 5
  if (LM_Vars.verbose)
  {
    printf("Status: %s\n", LM_Status());
    Stat_Show();
  }
a963 4
      case 'V': /* -v enable verbose mode */
         LM_Vars.verbose = true;
         break;

d1003 1
a1003 3
  if (LM_Vars.verbose) {
          printf("LanManFS: LM_Boot called, but cannot comply: %s\n", LM_Status());
  }
d1012 1
a1012 3
    if (LM_Vars.verbose) {
      printf("Auto-boot: server name has not been set...\n");
    }
d1023 1
a1023 2
    if ( LM_Vars.verbose )
      printf("  Server name '%s'\n", serv_name );
d1144 1
a1144 2
  if (LM_Vars.verbose)
    printf("Initialising...\n");
d1159 1
a1159 2
  if (LM_Vars.verbose)
    printf("Starting network transport...\n");
d1169 1
a1169 2
  if (LM_Vars.verbose)
    printf( "Starting filing system...\n");
d1173 1
a1173 1
          if (LM_Vars.verbose) printf("LanManFS: %s\n", err->errmess);
d1191 1
a1191 1
          if (LM_Vars.verbose) printf("Booting...\n");
d1195 1
a1195 2
  if ( LM_Vars.verbose )
    printf("All done...\n");
d1201 1
a1201 5
#ifdef DEBUG
  if (LM_Vars.verbose) {
          printf("LanManFS: %s (%s)\n", err->errmess, LM_Status());
  }
#endif
d1208 1
a1208 5
#ifdef DEBUG
  if (LM_Vars.verbose) {
          printf("LanManFS: %s\n", LM_Status());
  }
#endif
@


1.16
log
@Makefile recreated from fragments
Fixed up a couple of trivial warnings with the stricter checking.
Removed OmniS_FastMultiply64 and rewrote the function in C, this allows the compiler to spot and use UMULL on architectures supporting that instruction.
Tested in a RAM build against a WinXP SP3 server with a drive > 4GB.

Version 2.39. Tagged as 'LanManFS-2_39'
@
text
@d34 5
a42 2
#include "Global/FileTypes.h"
#include "Interface/HighFSI.h"
a60 2
static volatile int callbackflag = 0;

d63 1
a63 2
/* Added SNB 980224 */
extern char *LM_Status(void);
d82 1
a82 1
/* --------------------- */
d85 5
a89 4

/* ---------------------------------- */

int  LM_pw;          /* Our module's private word */
d94 1
a94 1

d113 32
a144 2
/* Can select IP or NetBEUI transport with this bit in CMOS. It's 0 if
   we should use NetBEUI, 1 if IP */
d146 24
d228 1
a228 6
enum dps_reason {
  protocolstatus_STARTING,
  protocolstatus_TERMINATING
};

static void lanman_announce_lanmanfs(enum dps_reason r2, void *pw)
a237 1

a260 1
  OmniS_ResourceShutdown();
d276 1
a276 1
  lanman_announce_lanmanfs(protocolstatus_TERMINATING, pw);
d280 3
d394 1
a394 1
    return Xlt_Error( EBADDRV );
d404 1
a404 1
      printf("Bytes free &%08X\n", values[2] );
d406 1
a406 1
        printf("Bytes used &%08X\n", values[4] );
d409 1
a409 1
        printf("Bytes used unavailable\n");
d413 1
a413 1
      printf("Bytes free &%08X%08X\n", values[3], values[2] );
d415 1
a415 1
        printf("Bytes used &%08X%08X\n", values[5], values[4] );
d418 1
a418 1
        printf("Bytes used unavailable\n");
d448 1
a448 1
    return Xlt_Error(EBADPARAM);
d465 1
a465 1
  return Xlt_Error(res);
d477 1
a477 1
    return Xlt_Error(EBADPARAM);
d480 1
a480 1
  if ( mountID == 0 ) return Xlt_Error ( EBADDRV );
d484 1
a484 1
  return Xlt_Error (res);
d578 1
a578 1
    return Xlt_Error(EBADPARAM);
d582 1
a582 1
  return Xlt_Error (Lgn_Logon ( argv[0], argv[1], argv[2] ) );
d585 12
d628 1
a628 1
    return Xlt_Error (EBADPARAM);
d642 1
a642 1
    return Xlt_Error ( EBADPARAM );
d666 1
a666 1
    return Xlt_Error ( EBADPARAM );
d692 1
a692 1
    printf("FS           <domain-name> | <file-server>\n");
d699 1
a699 1
    printf("FS           %s\n", buf[0] ? buf : "<unset>");
d704 1
a704 1
    return Xlt_Error ( EBADPARAM );
d739 1
a739 1
    return Xlt_Error ( EBADPARAM );
d749 1
a749 1
    printf("'%s' isn't a supported option\n", argv[0] );
d782 1
a782 1
      printf("LMNameServer <unset>\n");
d791 1
a791 1
      unsigned long b0, b1, b2, b3;
d793 4
a796 4
      b0 = (unsigned long)(address.s_addr & 0x000000ff);
      b1 = (unsigned long)(address.s_addr & 0x0000ff00) >>  8;
      b2 = (unsigned long)(address.s_addr & 0x00ff0000) >> 16;
      b3 = (unsigned long)(address.s_addr & 0xff000000) >> 24;
d808 1
a808 1
  return Xlt_Error(EBADPARAM);
d844 1
a844 1
    return Xlt_Error(ENOTPRESENT);
d870 2
a871 1
      OmniS_ResFSStarting(r->r[2], r->r[3]);
d910 1
a910 1
      return Xlt_Error(RPC_NameOp(r->r[0], /* reason code */
d915 1
a915 1
      return Xlt_Error(RPC_Transact((char *)(r->r[0]), /* server */
d921 1
a921 1
      return Xlt_Error(ENOTPRESENT);
d965 1
a965 1
      case 'D':    /* Specify driver name ************ */
d969 1
a969 16
      case 'H':
      case '?':
         printf( "SMB client for RISCOS, version " Module_FullVersion
                 "\nWritten by Ian Harvey 1994-1996\nUse:\n"
                 "\t-dea0\tto use 'ea0' for network driver (etc)\n"
                 "\t-n\tto disable network browsing\n"
                 "\t-mMYNAME\tto set machine name to MYNAME\n"
                 "\t-i\tto use NetBIOS-over-IP transport\n"
#ifndef NO_NETBEUI
                 "\t-t\tto use NetBEUI transport\n"
#endif
                 "\t-v\tto show progress information on startup\n"
                 "\t-?\tto display this help\n" );
         return ENOTINSTALLED;

      case 'V':
d973 1
a973 1
      case 'N':
d977 1
a977 1
      case 'M':
d982 1
a982 1
      case 'I':
d987 1
a987 1
      case 'T':
a992 2
         printf("\nCommand line switch '-%c' not recognised\n", line[0] );
         printf("Use '-?' to show available options\n");
a993 1

a994 1

d1049 2
a1050 1
      printf("  Error during boot: %s\n", Xlt_Error(res)->errmess);
d1097 6
a1108 1

d1110 4
a1113 1
    return Xlt_Error(ERISCOSVER);
d1115 1
a1115 1
if (cmd_tail != NULL)
d1117 2
a1118 3
    err = Xlt_Error(ProcessCmdLine(cmd_tail));
    if (err != NULL)
      return err;
d1122 1
a1122 3

  if (err != NULL)
      return err;
d1137 6
a1155 1

d1167 1
a1167 1
  err = Xlt_Error(Buf_Init());
d1177 1
a1177 1
  err = Xlt_Error( NB_Startup() );
d1204 1
a1204 3
  OmniS_ResourceInit();

  _kernel_oscli("IconSprites Resources:$.ThirdParty.OmniClient.LanMan.Sprites");
d1218 1
a1218 1
  err = Xlt_Error(EINITFAILED);
d1306 1
a1306 1
  if (r->r[2] == protocolstatus_TERMINATING && strcmp(proto, "Internet") == 0) {
d1309 1
a1309 1
  else if (r->r[2] == protocolstatus_STARTING && strcmp(proto, "Internet") == 0) {
a1392 12

char *LM_Status(void)
{
        switch (LM_Vars.initialised) {
        case LMInitState_Uninitialised: return "Dormant";
        case LMInitState_PreInit: return "Waiting for driver";
        case LMInitState_FullyInited: return "Active";
        case LMInitState_Boot: return "Waiting to boot";
        default: return "Dead";
        }
}

d1462 1
a1462 1
                lanman_announce_lanmanfs(protocolstatus_STARTING, pw);
@


1.15
log
@Fix for renames where only the case has changed.
Detail:
 Added an extra check after the Xlate path resolution code so that
 the case of the path given to resolve is honoured. This now means that
 the strcmp() done in SMB_Rename fails and the rename is actually sent to
 the server. Before "*rename test Test" would have the path resolved and
 since 'test' already existed both names would be the same, in this example
 something like "*rename A:\test A:\test" would result.
Admin:
 Made the non LONGNAMES version compile again (not tested).
 Removed local definitions of FSControl reason codes, uses Interface header
 now.
 Made the case of #includes match CVS to allow future compilation on a case
 sensitive system.
 Deleted unused "Version" header.

Version 2.34. Tagged as 'LanManFS-2_34'
@
text
@d209 8
a216 10
  /*if (LM_Vars.initialised == LMInitState_FullyInited)*/ {
    stopcallbacks();
    SMB_Shutdown();            /* Dismounts all SMB mounts first as */
    Omni_Shutdown();           /* Omni_Shutdown zeros the Mounts lists */
    OmniS_ResourceShutdown();
    Prn_Shutdown();            /* Free print jobs */
    NB_Shutdown();             /* Also calls LLC_Shutdown */
    Buf_Shutdown();            /* Tell MBufManager we're done */
    LM_Vars.initialised = LMInitState_PreInit;
  }
a371 4
#ifdef TRACE
  module_printf(NULL);
#endif

@


1.14
log
@  Multiple fixes.
Detail:
  Too many to list here: see doc/RPSChanges.
Admin:
  Received from Rob Sprowson approx 2009-02-08. Builds, but not tested by ROOL.

Version 2.32. Tagged as 'LanManFS-2_32'
@
text
@d34 6
a40 1
#include "Global/FileTypes.h"
d42 2
a43 2
#include "lanman.h"
#include "lmvars.h"
d45 3
a47 4
#include "corefn.h"

#include "buflib.h"
#include "netbios.h"
d49 1
a49 1
#include "xlate.h"
d51 2
a52 2
#include "omni.h"
#include "printers.h"
d54 2
a55 8
#include "stats.h"
#include "logon.h"
#include "sys/dcistructs.h"

#include "sys/types.h"
#include "netinet/in.h"
#include "arpa/inet.h"

d197 1
a197 1
    r.r[0] = FSControl_RemoveFilingSystem;
d243 1
a243 1
  int InfoBlk [ Information_Block_Size ];
d260 1
a260 1
  err = _swix(OS_FSControl, _INR(0,3), FSControl_AddFilingSystem, Image_RO_Base,
d263 1
a263 1
    LM_Declared=true;
d326 1
a326 1
  r.r[0] = FSControl_SelectFilingSystem;
@


1.13
log
@  Changes from John.
Detail:
  > Default filetype now text
  >
  > Default type given to any file that has neither a dos extent, nor a
  > ',xxx' riscos extent at the server
  >
  > Ensure that files given the default type never have a ',xxx' riscos
  > extent appended.
  >
  > Add environment variable 'LMDefaultType' which checked for a default
  > type on module initialisation .. thus setting this to (e.g.) dos, then
  > rmreinitting LanManFS will change the default type to (e.g.) dos.
Admin:
  Not tested here yet.

Version 2.29. Tagged as 'LanManFS-2_29'
@
text
@d46 1
a46 1
#include "version.h"
a94 7
/* ------------------------------- */
char Default_FileTName[6];
int  Default_FileType;

/* ------------------------------- */


a335 15
#if 0
static char *(LM_local_num)(char *buf)
{
  char *sep, *map, *space = buf;
  if (_swix(Territory_ReadSymbols, _INR(0,1)|_OUT(0), -1, 1, &sep)) return buf;
  if (_swix(Territory_ReadSymbols, _INR(0,1)|_OUT(0), -1, 2, &map)) return buf;

  while (space && *sep) {
    space = strchr(space, ' ');
    if (space) *space = *sep;
  }
  return buf;
}
#endif

d357 1
a357 1
      printf("Bytes free &%08x\n", values[2] );
d359 1
a359 1
        printf("Bytes used &%08x\n", values[4] );
d366 1
a366 1
      printf("Bytes free &%08x%08x\n", values[3], values[2] );
d368 1
a368 1
        printf("Bytes used &%08x%08x\n", values[5], values[4] );
d459 1
a459 1
    LM_Vars.verbose = true; /* DEBUG NAS */
d461 1
a461 1
    LM_Vars.verbose = false;
d465 3
d484 13
a496 2
  /* Following 'get from CMOS' bits added 980127:RCE                *
   * to address user complain that it has to be typed in every time *
d498 2
d501 3
a510 14
  LM_Vars.namemode  = NM_FIRSTCAPS;
  
  // load and convert default filetype to textual HEX
  if(name = getenv(DefaultTypeEnvVar),name)
  {
    _swix(OS_FSControl,_INR(0,1)|_OUT(2),31,name,&Default_FileType);
  }
  else
  {  
    Default_FileType=Default_File_Type_Number;
  }

  sprintf(Default_FileTName,",%03x",Default_FileType);

d550 4
a553 1
          printf("Status: %s\n", LM_Status());
a629 9
static _kernel_oserror *Cmd_LMStats ( const char *args )
{
  (void) args;
  Stat_Show();
  return NULL;
}

/* --------------------- */

a771 1
  CmdEntry(LMStats),
d915 1
a915 1
         printf( "Lan Man client for RISCOS, version " VERSION_STRING
d1162 1
a1162 1
          if (LM_Vars.verbose) printf("Booting ...\n");
@


1.12
log
@Tightened up checking of when sockets get opened and closed in an
attempt to work out why Freeway gets upset when LanManFS is
configured in IP mode.
Changed app date that OmniClient shows to be dd-mmm-yy
Added ability to include slimmer ROMSPRITES and deleted the resources
phase from the makefile: the sprites were being included once in
ResourceFS and again embedded in the module.
If the FS is unset it says so in *status rather than a blank line.

Version 2.26. Tagged as 'LanManFS-2_26'
@
text
@d35 1
d96 7
d515 12
@


1.11
log
@Directory rename fixed - the mask being passed by the rename routine didn't
have the ATTR_DIR bit set.Discovered this after reading lots of the spec
which is also now included here in /doc.
Copying files out of LanManFS filer "forgot" their filetype even though
they appeared right in the filer,fixed.
A stray debugging printf removed,along with one compiler warning.
New sprites (yuck) to match !Omni.
Reordered the shutdown in two places,first Omni_Shutdown bins the mounts
lists which SMB_Shutdown uses.Second in NetBEUI mode the announcement that
a protocol has terminated goes *after* the shutdown - otherwise you sit
around for about 20s wondering where the link has gone.

Version 2.25. Tagged as 'LanManFS-2_25'
@
text
@d210 1
a210 1
  if (LM_Vars.initialised == LMInitState_FullyInited) {
d234 1
a234 1
  
d647 1
a647 1
    printf("FS           %s\n", buf);
a1054 1

d1245 1
a1245 1
		        if (LM_Vars.initialised ==  LMInitState_FullyInited) {
d1344 1
a1344 1
	if (LM_Vars.initialised == LMInitState_FullyInited) {
@


1.10
log
@LanmanFS help syntax corrected and tidied
Change lmls command to ListFS in line with NFS
Supress LF when ListFS is issued but there are no servers present.
Cast a few things to shut some compiler warnings up.
Addition of MimeMap lookups where the file has no ",ttt" style type
appended.Previously any such files were all reported as text files so
viewing a machine would typically show whole directories full of
identical filetypes.

Version 2.23. Tagged as 'LanManFS-2_23'
@
text
@d212 2
a213 1
    Omni_Shutdown();
d215 3
a217 4
    Prn_Shutdown();
    SMB_Shutdown();
    NB_Shutdown();
    Buf_Shutdown();
a226 1
  (void) pw;
d228 3
d232 1
a232 2

  LM_GracefulClosedown();
d234 1
d1264 1
@


1.9
log
@  Utterly insignificant CallEvery change.
Detail:
  Now happens every 4500 cs rather than every 4501. Big deal.
Admin:
  Untested - will work.
  I'm bored.

Version 2.22. Tagged as 'LanManFS-2_22'
@
text
@d319 1
a319 1
static _kernel_oserror *Cmd_LANMAN ( const char *args )
d348 1
a348 1
static _kernel_oserror *Cmd_FREE ( const char *args )
d396 1
a396 1
static _kernel_oserror *Cmd_LMLS ( const char *args )
d410 1
a410 1
static _kernel_oserror *Cmd_CONNECT ( const char *args )
d439 1
a439 1
static _kernel_oserror *Cmd_DISCONNECT ( const char *args )
d517 1
a517 1
static _kernel_oserror *Cmd_LOGOFF( const char *args )
d526 1
a526 1
static _kernel_oserror *Cmd_LOGON( const char *args )
d540 1
a540 1
static _kernel_oserror *Cmd_LMINFO ( const char *args )
d551 1
a551 1
static _kernel_oserror *Cmd_LMNAMEMODE ( const char *args )
d573 1
a573 1
static _kernel_oserror *Cmd_LMSERVER ( const char *args )
d597 1
a597 1
static _kernel_oserror *Cmd_LMPRINTERS ( const char *args )
d622 1
a622 1
static _kernel_oserror *Cmd_LMSTATS ( const char *args )
d658 1
a658 1
static _kernel_oserror *Cmd_LMTRANSPORT ( const char *args )
a683 1

d701 1
a701 1
static _kernel_oserror *Cmd_NBNSIP( const char *args )
d739 4
a742 4
      b0 = (address.s_addr & 0x000000ff);
      b1 = (address.s_addr & 0x0000ff00) >>  8;
      b2 = (address.s_addr & 0x00ff0000) >> 16;
      b3 = (address.s_addr & 0xff000000) >> 24;
d761 2
a762 2
#define MAX_CMDS 15
static CommandFnPtr Cmd_Dispatch[MAX_CMDS] =
d764 15
a778 15
  Cmd_LANMAN,
  Cmd_CONNECT,
  Cmd_DISCONNECT,
  Cmd_LOGON,
  Cmd_LMINFO,
  Cmd_LMNAMEMODE,
  Cmd_LOGOFF,
  Cmd_LMSERVER,
  Cmd_LMPRINTERS,
  Cmd_LMSTATS,
  Cmd_FS,
  Cmd_LMTRANSPORT,
  Cmd_NBNSIP,
  Cmd_FREE,
  Cmd_LMLS
d781 1
a781 26
#ifdef TRACE
static void chk_a_command(CommandFnPtr ptr, int num)
{
        if (Cmd_Dispatch[num] != ptr) {
           fprintf(stderr, "Command-table error (%d)\n", num);
        }
}
static void chk_commands(void)
{
  chk_a_command(Cmd_LANMAN, CMD_LanMan);
  chk_a_command(Cmd_CONNECT, CMD_LMConnect);
  chk_a_command(Cmd_DISCONNECT, CMD_LMDisconnect);
  chk_a_command(Cmd_LOGON, CMD_LMLogon);
  chk_a_command(Cmd_LMINFO, CMD_LMInfo);
  chk_a_command(Cmd_LMNAMEMODE, CMD_LMNameMode);
  chk_a_command(Cmd_LOGOFF, CMD_LMLogoff);
  chk_a_command(Cmd_LMSERVER, CMD_LMServer);
  chk_a_command(Cmd_LMPRINTERS, CMD_LMPrinters);
  chk_a_command(Cmd_LMSTATS, CMD_LMStats);
  chk_a_command(Cmd_FS, CMD_FS);
  chk_a_command(Cmd_LMTRANSPORT, CMD_LMTransport);
  chk_a_command(Cmd_NBNSIP, CMD_LMNameServer);
  chk_a_command(Cmd_FREE, CMD_Free);
  chk_a_command(Cmd_LMLS, CMD_LMls);
}
#endif
a1071 4
#ifdef TRACE
  chk_commands();
#endif

d1080 1
d1085 1
@


1.8
log
@  Experimental change to handle Internet modules in flash.
Detail:
  This module was ignoring the possibility of the Internet module being
    re-initialised underneath it - something which can happen if there
    is an Internet module in flash as well as main ROM.  This is an
    experimental fix for this problem.
Admin:
  Not tested.

Version 2.18. Tagged as 'LanManFS-2_18'
@
text
@d1493 1
a1493 1
        (void) _swix(OS_CallEvery, _INR(0,2), 100*45, callevery_entry, LM_pw);
@


1.7
log
@  Fixed some incorrect symbol names.
Detail:
  Some symbol names were wrong which only showed up in ROM builds.
Admin:
  Tested in Ursula ROM build, and tested RAM build.

Version 2.15. Tagged as 'LanManFS-2_15'
@
text
@d1293 3
@


1.6
log
@  New build option to exclude NetBEUI support.
Detail:
  Pass OPTIONS=-DNO_NETBEUI from the Components file if you do not need
    NetBEUI support, and LanManFS will be 12K smaller.
  In NetBEUI mode, LanManFS sends Service_DCIProtocolStatus as required.
  In IP mode, LanManFS notices Service_DCIProtocolStatus from the Internet
    module when it dies and marks all its sockets as needing reconnection.
  Booting behaviour changed to look for !ArmBoot again and not attempt
    the boot if it is missing.  Removed lots of grotty backdoor hacks
    that used to be used to determine this.
Admin:
  Not tested at all.  This will need very thorough testing before it can
    be considered for release.

Version 2.14. Tagged as 'LanManFS-2_14'
@
text
@d183 1
a183 1
  if (NB_InitedTransport == NB_NetBEUI_Startup)
d1118 1
a1118 1
  if (LM_InitedTransport == NB_NetBEUI_Startup) {
@


1.5
log
@  Now uses DebugLib.
  Fixed search handle haemorrhaging.
Detail:
  The directory lookup routines cached directory search handles to avoid
    hammering the server with repeated requests to open directories.
    Unfortunately, it was possible for these to be forgotten without
    being freed up leading to resource loss at the server end.  Eventually,
    the server gives up servicing you and reports errors.  This will only
    occur once a significant number of accesses have been performed (the
    number depends entirely on server configuration).  This leak is now
    fixed.
Admin:
  Tested against Cerium - debug reports that no handles are being leaked.

Version 2.07. Tagged as 'LanManFS-2_07'
@
text
@d59 1
d172 18
d229 2
d507 3
d511 2
a512 1
  	NB_NBIP_Setup : NB_NetBEUI_Setup);
a661 1
  char *tp0 = "NetBEUI";
d664 9
a672 1
  if ( (int) args == 0 ) /* Show 'Configure' options */
d677 1
a677 1
  else if ( (int) args == 1 ) /* Show FS status */
d683 1
d688 1
d691 3
a693 1
  else if ( stricmp ( argv[0], tp1 ) == 0 )
d709 1
a709 1
  if ( (int)args == 0 ) /* Show 'Configure' options */
d714 1
a714 1
  else if ( (int) args == 1 ) /* Show FS status */
d825 1
d850 4
d949 1
d951 1
d973 1
d977 1
d1115 9
d1259 1
d1281 12
d1295 1
a1446 1
static volatile int callbackflag = 0;
d1451 7
a1457 2
	(void) pw;
	if (callbackflag != 0) {
@


1.4
log
@  No longer assumes that it should attach itself to eh0 if it cannot
    find a driver.
Detail:
  The module used to have specific knowledge of the driver to which it
    was supposed to bind if it was unable to find any active drivers at
    the time that LanManFS was initialised.  This meant that if the
    LanManFS module was placed in ROM (eg. in STB3) and the drivers
    hadn't initialised by the time that LanManFS was initialised, it
    would sit and wait for EtherH to arrive - which doesn't happen
    for ATM solutions, and doesn't happen for Ethernet in STB3 because
    we no longer use EtherH!
Admin:
  Tested in STB22 expansion cards, and in STB3 ROM builds for both
    Ethernet and ATM solutions.

Version 2.05. Tagged as 'LanManFS-2_05'
@
text
@a948 26
#if 0
static void LM_StartupBoot ( void )
{

  /* Checks to see if we need to boot (by reading the CMOS RAM).
     If so, it

     i)   Gets the workgroup/domain name from CMOS RAM
     ii)  Tries to find a DC for the given name. If so, it uses this
           as the server name.
     iii) Attempts to mount "ARMBOOT", with user ARMBOOT and no password.

  */

  if ( RdCMOS(CMOS_FSNUMBER) != Our_FS_Number )
    return;

  if ( (RdCMOS(CMOS_FSFLAGS) & FSF_BOOT) == 0 )
    return;

  #ifdef AUTOBOOT_ON_INIT
  LM_Boot();
  #endif
}
#endif

d1029 5
@


1.3
log
@  New *LMLS command.
  Fix for ./.. files in short filename shares.
  Long multiply now provided in assembler.
Detail:
  *LMLS is a new filesystem-specific command which performs the same
    task as "smbclient -L" does under UNIX - ie. listing all the shares
    available on the specified host.
  When enumerating the shares on a remote server, LanManFS now remembers
    all the printers, IPC, device and disc shares (for *LMLS to output).
  The 32x32->64 multiply routine is now provided in assembler instead of
    the previous huge amount of obscure C taken from NSPRLib.  This is
    more understandable (and almost certainly far smaller and quicker
    and doesn't need a hack to stop the compiler mis-optimising it!)
  Old short filename shares still had problems with the . and .. file
    filtering.  Programmer fault there - should've let the compiler do
    the optimisations :-)
  Server info string fixed to byte-reverse the port numbers when printing
    the string into the info buffer.  Now claims to be talking to port 139
    as it should.
Admin:
  Tested in general desktop use for several days, plus experimental versions
    tested in other boot ROMs.

Version 2.03. Tagged as 'LanManFS-2_03'
@
text
@d65 1
a65 1
#define DEFAULT_ETHER_TYPE 	"eh0"
d810 1
a810 3
      if (NB_InitedTransport == NB_NetBEUI_Setup) {
          LM_check_driver_status(r);
      }
d1218 1
d1220 10
@


1.2
log
@  Support for long filename.
  Support for spaces in machine names.
  Merge of sbrodie_LanManFS_dev branch to trunk.
Detail:
  LanManFS 2.00 supports the "NT LM 0.12" protocol, enabling it to
    use long filenames on mounted shares.
Admin:
  Supporting documentation:
    1215,256/FS: LanManFS Software Functional Specification.
  Same as LanManFS-1_87_1_1_1_1_2_13.

Version 2.00. Tagged as 'LanManFS-2_00'
@
text
@d82 4
d375 13
a434 3
/* --------------------- */

struct LMvars LM_Vars;
d558 1
a558 1
    Omni_AddInfo ( OAI_SERVER, argv[0], NULL );
d563 1
a563 1
      Omni_AddInfo ( OAI_DISK, argv[0], argv[i] );
d582 1
a582 1
    Omni_AddInfo ( OAI_SERVER, argv[0], NULL );
d587 1
a587 1
      Omni_AddInfo ( OAI_PRINTER, argv[0], argv[i] );
d726 1
a726 1
#define MAX_CMDS 14
d742 2
a743 1
  Cmd_FREE
d769 1
@


1.1
log
@Initial revision
@
text
@d29 1
d51 1
a51 1
#include "DCI4.h"
d57 2
d68 1
d77 3
d86 1
d121 1
a121 1
static void WrCMOS ( int addr, int data )
d152 4
d185 1
a185 1
_kernel_oserror * LM_Finalise (int fatal, int podule, void *pw)
a186 4
  debug0("Finalise\n");
  (void) fatal;
  (void) podule;
  (void) pw;
d188 1
d197 1
d199 8
a215 1
  _kernel_swi_regs r;
d222 1
a222 1
  InfoBlk[1] = -1; /*(int)"Lan Man network connection" - (int)Image_RO_Base;*/
d232 1
d234 2
a235 7
  r.r[0] = FSControl_AddFilingSystem;
  r.r[1] = (int)Image_RO_Base;
  r.r[2] = (int)InfoBlk - (int)Image_RO_Base;
  r.r[3] = (int)LM_pw;


  err = _kernel_swi( XOS_Bit | OS_FSControl, &r, &r );
d252 1
a252 1
static int GetArgs ( char *args, char *argv_out[], int maxargs )
d294 1
a294 1
static _kernel_oserror *Cmd_LANMAN ( char *args )
d308 65
a372 1
static _kernel_oserror *Cmd_CONNECT ( char *args )
d401 1
a401 1
static _kernel_oserror *Cmd_DISCONNECT ( char *args )
d424 6
d472 2
a473 6

  if ( RdCMOS ( CMOS_NB_TYPE ) & NBTYPE_IP_BIT )
    NB_NBIP_Setup();
  else
    NB_NetBEUI_Setup();

d478 1
a478 1
static _kernel_oserror *Cmd_LOGOFF( char *args )
d487 1
a487 1
static _kernel_oserror *Cmd_LOGON( char *args )
d501 1
a501 1
static _kernel_oserror *Cmd_LMINFO ( char *args )
d512 1
a512 1
static _kernel_oserror *Cmd_LMNAMEMODE ( char *args )
d520 3
d524 1
d534 1
a534 1
static _kernel_oserror *Cmd_LMSERVER ( char *args )
d558 1
a558 1
static _kernel_oserror *Cmd_LMPRINTERS ( char *args )
d583 1
a583 1
static _kernel_oserror *Cmd_LMSTATS ( char *args )
d592 1
a592 1
static _kernel_oserror *Cmd_FS ( char *args )
d619 1
a619 1
static _kernel_oserror *Cmd_LMTRANSPORT ( char *args )
d652 1
a652 1
static _kernel_oserror *Cmd_NBNSIP(char *args)
d688 1
a688 1
      int b0, b1, b2, b3;
d697 4
a700 4
        WrCMOS(NBNSIPCMOS0,b0);
        WrCMOS(NBNSIPCMOS1,b1);
        WrCMOS(NBNSIPCMOS2,b2);
        WrCMOS(NBNSIPCMOS3,b3);
d710 1
a710 1
typedef _kernel_oserror * (*CommandFnPtr) ( char *args );
d712 1
a712 1
#define MAX_CMDS 13
d727 2
a728 1
  Cmd_NBNSIP
d731 26
d759 1
a759 1
_kernel_oserror *LM_Command ( char *args, int argc, int cmd_no, void *pw )
d772 1
d794 9
a802 1
      LM_check_driver_status(r);
d815 1
a815 1
  switch ( LanMan_SWI_base + swi_ofs )
d817 1
a817 1
    case SWI_LanMan_OmniOp:
d820 1
a820 1
    case SWI_LanMan_LogonOp:
d823 1
a823 1
    case SWI_LanMan_FreeOp:
d826 1
a826 1
    case SWI_LanMan_NameOp:
d831 1
a831 1
    case SWI_LanMan_Transact:
d861 1
a861 1
static err_t ProcessCmdLine ( char *line )
d864 2
a865 1
  char *end = line;
d872 1
a872 1
  strncpy(cli, line, 255);
d913 1
a913 1
         NB_NBIP_Setup();
d917 1
a917 1
         NB_NetBEUI_Setup();
d963 1
d981 3
a983 1
    printf("Auto-boot: server name has not been set...\n");
d989 15
a1003 3
  serv_name = RPC_GetDomainController(fs_name);
  if ( serv_name == NULL )
    serv_name = fs_name;
d1005 13
a1017 14
  if ( LM_Vars.verbose )
    printf("  Server name '%s'\n", serv_name );

  /* Wash'n'go... */

  res =  Omni_MountServer ( serv_name,  /* Server */
          "ARMBOOT", "", /* User name & password */
          "BOOT",        /* Mountname */
          "ARMBOOT",     /* Drive name */
          &tmp );          /* MountID_out */

  if ( res != OK )
  {
    printf("  Error during boot: %s\n", Xlt_Error(res)->errmess);
d1021 1
d1037 1
a1037 1
_kernel_oserror *LM_Initialise(char *cmd_tail, int pod_base, void *pw)
d1060 5
a1064 1
  if (cmd_tail != NULL)
d1132 1
a1132 1
  /*atexit(LM_Finalise); Somebody appears to have a lack of confidence in CMHG..? */
d1191 1
a1191 1
        dci4_dib *dib = (dci4_dib *) (r->r[0]);
d1195 2
a1196 2
	/*
        printf("Service_DCIDriverStatus called (interface %s%d is %sing)\n"
d1202 1
a1202 1
        printf("We are looking for driver `%s' - got `%s'\n", LM_Vars.drivername,
d1204 1
a1204 1
        */
d1211 1
a1211 1
                /* printf("Ding!  This was our interface\n"); */
d1214 1
a1214 1
		                LM_Finalise(0,0,0);
d1219 1
a1219 1
	                LM_Finalise(0,0,0);
d1224 78
d1312 109
@


1.1.1.1
log
@
LanManFS moved into Omni subdirectory.  Previous version in
RiscOS/Sources/Networking/LanManFS is now locked out.

The rest of Omni will be imported at a later date.

Version 1.87, tagged as LanManFS-1_87

@
text
@@


1.1.1.1.2.1
log
@  Implemented h/w multicast filtering.
  Uses our DCI4 header file.
Detail:
  Now uses DCI4 MulticastRequest SWIs to selectively receive NetBEUI specific
    multicast IEEE frames.
  LLC_AttachDriver now takes an additional multicast MAC address parameter
    which is automatically claimed when the frames are claimed.
  Uses sys/dcistructs.h instead of its private ancient DCI4.h.  Some of the
    constants are different (old header shifted some numbers into correct
    positions for various calls - notably FRMLVL_* definitions).  Code modified
    to use the proper macros to construct these constants.
Admin:
  Build and tested briefly.  EHInfo reports MAR for IEEE frames has been set
    as expected, and *LanMan:LMLogon seems to work.

Version 1.87, 1.1.1.1.2.1. Tagged as 'LanManFS-1_87-1_1_1_1_2_1'
@
text
@d50 1
a50 1
#include "sys/dcistructs.h"
a55 2
#include "LanMan_MH.h"

a64 1
typedef void (*pfnTransportInit)(void);
a78 1
static pfnTransportInit NB_InitedTransport; /* Identify active transport */
d113 1
a113 1
static void WrCMOS ( int addr, unsigned int data )
a143 4
  if (!_kernel_getenv("Inet$ServerName", buf_out, CMOS_FSERVER)) {
          return;
  }

d239 1
a239 1
static int GetArgs ( const char *args, char *argv_out[], int maxargs )
d281 1
a281 1
static _kernel_oserror *Cmd_LANMAN ( const char *args )
d295 1
a295 1
static _kernel_oserror *Cmd_CONNECT ( const char *args )
d324 1
a324 1
static _kernel_oserror *Cmd_DISCONNECT ( const char *args )
a346 6
static void LanMan_InitTransport(pfnTransportInit i)
{
        NB_InitedTransport = i;
        (*i)();
}

d389 6
a394 2
  LanMan_InitTransport(RdCMOS ( CMOS_NB_TYPE ) & NBTYPE_IP_BIT  ?
  	NB_NBIP_Setup : NB_NetBEUI_Setup);
d399 1
a399 1
static _kernel_oserror *Cmd_LOGOFF( const char *args )
d408 1
a408 1
static _kernel_oserror *Cmd_LOGON( const char *args )
d422 1
a422 1
static _kernel_oserror *Cmd_LMINFO ( const char *args )
d433 1
a433 1
static _kernel_oserror *Cmd_LMNAMEMODE ( const char *args )
d451 1
a451 1
static _kernel_oserror *Cmd_LMSERVER ( const char *args )
d475 1
a475 1
static _kernel_oserror *Cmd_LMPRINTERS ( const char *args )
d500 1
a500 1
static _kernel_oserror *Cmd_LMSTATS ( const char *args )
d509 1
a509 1
static _kernel_oserror *Cmd_FS ( const char *args )
d536 1
a536 1
static _kernel_oserror *Cmd_LMTRANSPORT ( const char *args )
d569 1
a569 1
static _kernel_oserror *Cmd_NBNSIP( const char *args )
d605 1
a605 1
      unsigned long b0, b1, b2, b3;
d614 4
a617 4
        WrCMOS(NBNSIPCMOS0,(int) b0);
        WrCMOS(NBNSIPCMOS1,(int) b1);
        WrCMOS(NBNSIPCMOS2,(int) b2);
        WrCMOS(NBNSIPCMOS3,(int) b3);
d627 1
a627 1
typedef _kernel_oserror * (*CommandFnPtr) ( const char *args );
d649 1
a649 1
_kernel_oserror *LM_Command ( const char *args, int argc, int cmd_no, void *pw )
a661 1
static void LM_check_internet_status(_kernel_swi_regs *r);
d683 1
a683 9
      if (NB_InitedTransport == NB_NetBEUI_Setup) {
          LM_check_driver_status(r);
      }
      break;

    case Service_InternetStatus:
      if (NB_InitedTransport == NB_NBIP_Setup) {
          LM_check_internet_status(r);
      }
d696 1
a696 1
  switch ( swi_ofs )
d698 1
a698 1
    case LanMan_OmniOp - LanMan_00:
d701 1
a701 1
    case LanMan_LogonOp - LanMan_00:
d704 1
a704 1
    case LanMan_FreeOp - LanMan_00:
d707 1
a707 1
    case LanMan_NameOp - LanMan_00:
d712 1
a712 1
    case LanMan_Transact - LanMan_00:
d742 1
a742 1
static err_t ProcessCmdLine ( const char *_line )
d745 1
a745 2
  char *end;
  char *line;
d752 1
a752 1
  strncpy(cli, _line, 255);
d793 1
a793 1
         LanMan_InitTransport(NB_NBIP_Setup);
d797 1
a797 1
         LanMan_InitTransport(NB_NetBEUI_Setup);
d902 1
a902 1
_kernel_oserror *LM_Initialise(const char *cmd_tail, int pod_base, void *pw)
d1052 1
a1052 1
        Dib *dib = (Dib *) (r->r[0]);
a1082 21
}

/* SNB 981029 added this function to verify the contents of the Service_InternetStatus
 * service call to determine whether we were waiting for the interface to go up so
 * that we could boot
 */
static void LM_check_internet_status(_kernel_swi_regs *r)
{
        char *cp = (char *) r->r[3];

	/* Was it the right reason code? */
	if (r->r[0] != InternetStatus_InterfaceUpDown) return;
	/* Was it the right interface? */
	if (stricmp(LM_Vars.drivername, cp) != 0) return;
	/* was the interface coming up? */
	if (r->r[2] != 1) return;

	if (LM_Vars.initialised == LMInitState_FullyInited) {
	        LM_Finalise(0,0,0);
	}
	LM_init_phase_2();
@


1.1.1.1.2.2
log
@  Fixed most dodgy pathname problems.
  All *LM... commands are now filing system commands.
  *Connect and *Disconnect renamed to *LMConnect and *LMDisconnect.
Detail:
  When translating RISC OS to DOS filenames, a loop could develop if
    any path component contained a dodgy character.  This is now fixed
    with the exception of problems when both < and > characters appear
    in pathnames since that confuses FileSwitch.  New mappings will be
    need to be agreed for these characters (and remappings for $ and %
    which overload < and > respectively)
  All *LM... commands are now filing system commands, which means that
    you need to prefix them with LanMan: unless LanManFS is the current
    filesystem (following spec review).
  *Connect and *Disconnect renamed to *LMConnect and *LMDisconnect
    (following spec review).
  Trace builds allow "*LanMan:LMNameMode 4" to enable display of system
    and hidden files on the remote filesystem.
Admin:
  Tested briefly against Windows 98 and Windows NT 4 SP3.
  If a directory name contains a dodgy character, repeated searches will
    be made on the remote filesystem.  This is inefficient and a name
    cache would alleviate this.  There is no name cacheing in the current
    version.

Version 1.87, 1.1.1.1.2.9. Tagged as 'LanManFS-1_87-1_1_1_1_2_9'
@
text
@a450 3
#ifdef TRACE
       0
#else
a451 1
#endif
a656 25
#ifdef TRACE
static void chk_a_command(CommandFnPtr ptr, int num)
{
        if (Cmd_Dispatch[num] != ptr) {
           fprintf(stderr, "Command-table error (%d)\n", num);
        }
}
static void chk_commands(void)
{
  chk_a_command(Cmd_LANMAN, CMD_LanMan);
  chk_a_command(Cmd_CONNECT, CMD_LMConnect);
  chk_a_command(Cmd_DISCONNECT, CMD_LMDisconnect);
  chk_a_command(Cmd_LOGON, CMD_LMLogon);
  chk_a_command(Cmd_LMINFO, CMD_LMInfo);
  chk_a_command(Cmd_LMNAMEMODE, CMD_LMNameMode);
  chk_a_command(Cmd_LOGOFF, CMD_LMLogoff);
  chk_a_command(Cmd_LMSERVER, CMD_LMServer);
  chk_a_command(Cmd_LMPRINTERS, CMD_LMPrinters);
  chk_a_command(Cmd_LMSTATS, CMD_LMStats);
  chk_a_command(Cmd_FS, CMD_FS);
  chk_a_command(Cmd_LMTRANSPORT, CMD_LMTransport);
  chk_a_command(Cmd_NBNSIP, CMD_LMNameServer);
}
#endif

d945 1
a945 5
#ifdef TRACE
  chk_commands();
#endif

if (cmd_tail != NULL)
@


1.1.1.1.2.3
log
@  End of week checkin.  No bug fixes.  Some performance improvements.
Detail:
  Added a basic name cacheing facility.  For safety this is flushed
    every time the module returns to FileSwitch.  This does at least
    help reduce the name of directory searches required during a
    name translation.  NameCache.c comes with a test program built-in
    for stressing the cache manager.
Admin:
  Free space display doesn't work yet.
  Anti-idleout measures not implemented yet.

Version 1.87, 1.1.1.1.2.10. Tagged as 'LanManFS-1_87-1_1_1_1_2_10'
@
text
@d206 1
d213 1
a213 1
  InfoBlk[1] = -1; /* Self-ident - request call FSFunc_PrintStartupBanner */
a222 1
  InfoBlk[11] = Information2_Word;
d224 7
a230 2
  err = _swix(OS_FSControl, _INR(0,3), FSControl_AddFilingSystem, Image_RO_Base,
    (int)InfoBlk - (int)Image_RO_Base, LM_pw);
@


1.1.1.1.2.4
log
@  Boot behaviour fixes.
  More debug added.
Detail:
  Trapped Service_InternetStatus reason code 0 as a tipoff to try
    to continue a pending boot operation.  Internet module is not
    sending the expected reason code 2 to indicate that the interface
    has come up when it is also having its address changed.
  Holding down SHIFT when a new connection is made prevents execution
    of !ArmBoot on the newly connected share.
  Several more debug statements added to track progress through the
    booting.
  IPConfig's internal logging system imported.  *LanMan:Free shows
    the contents of the log.
  Free space information still seems to be broken against Windows 95/98.
    Works against NT4SP4 though.
  *Free filesystem-specific command added.
Admin:
  This version managed to boot an STB22 from our NT4 server which
    was supplying it with baseline 303.
  *LanMan:Free is not yet implemented and in debug builds, shows
     the debug log instead.
  Anti-idleout work still pending.

Version 1.87, 1.1.1.1.2.11. Tagged as 'LanManFS-1_87-1_1_1_1_2_11'
@
text
@a296 12
static _kernel_oserror *Cmd_FREE ( const char *args )
{
  (void) args;
  printf("Not immplemented yet\n");
#ifdef TRACE
  module_printf(NULL);
#endif

  return NULL;
}

/* --------------------- */
d638 1
a638 1
#define MAX_CMDS 14
d653 1
a653 2
  Cmd_NBNSIP,
  Cmd_FREE
a677 1
  chk_a_command(Cmd_FREE, CMD_Free);
d1104 2
a1105 2
#ifdef TRACE
        printf ("Service_DCIDriverStatus called (interface %s%d is %sing)\n"
d1111 1
a1111 1
        printf ("We are looking for driver `%s' - got `%s'\n", LM_Vars.drivername,
d1113 1
a1113 1
#endif
d1120 1
a1120 1
                debug0("Ding!  This was our interface\n");
a1123 1
		                LM_Declare();
a1128 1
	                LM_Declare();
a1140 6
	printf ("InternetStatus: %d %d %d %p %s\n", r->r[0], r->r[1], r->r[2], cp, cp);

	if (r->r[0] == InternetStatus_AddressChanged) {
	  goto testjump;
	}

d1147 1
a1147 1
testjump:
a1149 1
                LM_Declare();
a1164 55

#ifdef TRACE
/* Debugging routine.  If str is NULL, then the log is printed to 'f' (or stderr
 * if f was NULL).  If f is NULL, the message is added to the log but not displayed
 * on the screen.  If neither f nor str was NULL, the screen characteristcs are set
 * to useful things (text window is reset, default colours restored and text origin
 * restored to 0,0, and the message is printed to the screen and copied to tne log.
 * A monotonic coumnter is incremented for each debug message logged.  Timestamps
 * are stored in the log buffer too.
 */
#include <stdarg.h>
int module_printf(const char *str, ...)
{
	static int callcount = 0;
	static char pbuffer[65536];
	static int pbufferptr = 0;
	va_list ap;
	int inblock[2];
	FILE *f;

	f=stderr;

	if (f != NULL || str == NULL)  {
		inblock[1] = -1;
		inblock[0] = 132;
		_swix(OS_ReadVduVariables, _INR(0,1), inblock, inblock);
		_swix(OS_WriteC, _IN(0), 6);
		if (inblock[0] > 20) {
			int i;
			for (i=0; i<0; ++i) (void) _kernel_osbyte(19,0,0);
			_swix(OS_WriteN, _INR(0,1), "\x1a\x0c", 2);
		}
		_swix(OS_WriteC, _IN(0), 20);
	}

	if (!str) {
		if (pbufferptr > 0) fprintf(f?f:stderr, "%s\n", pbuffer);
		return 0;
	}

	++callcount;
	if (f != NULL) {
		fprintf(f, "(%4d) ", callcount);
		va_start(ap, str);
		vfprintf(f, str, ap);
		va_end(ap);
	}
	va_start(ap, str);
	_swix(OS_ReadMonotonicTime, _OUT(0), inblock);
	pbufferptr += sprintf(pbuffer + pbufferptr, "(%8d) (%4d) ", inblock[0], callcount);
	pbufferptr += vsprintf(pbuffer + pbufferptr, str, ap);
	if (pbufferptr > 60000) pbufferptr = 0;
	return 0;
}
#endif
@


1.1.1.1.2.5
log
@  Free space now 64-bit aware plus *-command implemented.
  Anti-idleout measures implemented.
  Boot behaviour sanitised.
Detail:
  Free space code now knows about 64-bit versions of the various
    calls that can be made to it (OS_FSControl and Free module's i/f)
  *Free implemented.
  CallEvery set up to periodically ping each share to stop buggy
    Microsoft servers going to sleep on it.
  The filesystem does not get deregistered from FileSwitch whenever
    any interface on the machine changes(!)   More subtle changes
    are still required to finalise things in this area though.
Admin:
  Requires TCPIPLibs 5.06 or later
    (CVS: RiscOS/Sources/Libs/TCPIPLibs  tag: TCPIPLibs-5_06)
  Tested by booting an STB22 against an NT4SP4 machine.

Version 1.87, 1.1.1.1.2.12. Tagged as 'LanManFS-1_87-1_1_1_1_2_12'
@
text
@a28 1
#include <locale.h>
a75 3
static void startcallbacks(void);
static void stopcallbacks(void);

d181 1
a181 1
static void LM_GracefulClosedown(void)
d183 4
a187 1
    stopcallbacks();
a195 8
}

_kernel_oserror * LM_Finalise (int fatal, int podule, void *pw)
{
  debug0("Finalise\n");
  (void) fatal;
  (void) podule;
  (void) pw;
a196 1
  LM_GracefulClosedown();
a296 16

#if 0
static char *(LM_local_num)(char *buf)
{
  char *sep, *map, *space = buf;
  if (_swix(Territory_ReadSymbols, _INR(0,1)|_OUT(0), -1, 1, &sep)) return buf;
  if (_swix(Territory_ReadSymbols, _INR(0,1)|_OUT(0), -1, 2, &map)) return buf;

  while (space && *sep) {
    space = strchr(space, ' ');
    if (space) *space = *sep;
  }
  return buf;
}
#endif

d299 2
a300 38
  _kernel_swi_regs r;
  _kernel_oserror *e;
  int values[6];
  char *argv[1];

  if (GetArgs(args, argv, sizeof(argv)/sizeof(*argv)) == 0)
    argv[0] = getenv("FileSwitch$" FilingSystemName "$CSD");

  if (argv[0] == NULL)
    return Xlt_Error( EBADDRV );

  r.r[0] = 4; /* 64-bit free space - will not fail! */
  r.r[1] = Our_FS_Number;
  r.r[2] = (int) values;
  r.r[3] = (int) argv[0];
  e = Omni_FreeOp_SWI(&r);

  if (e == NULL) {
    if (values[3] == 0 && values[5] == 0) {
      printf("Bytes free &%08x\n", values[2] );
      if (values[4] != -1) {
        printf("Bytes used &%08x\n", values[4] );
      }
      else {
        printf("Bytes used unavailable\n");
      }
    }
    else {
      printf("Bytes free &%08x%08x\n", values[3], values[2] );
      if (values[4] != -1) {
        printf("Bytes used &%08x%08x\n", values[5], values[4] );
      }
      else {
        printf("Bytes used unavailable\n");
      }
    }
  }

d305 1
a305 1
  return e;
d918 1
a918 3
    if (LM_Vars.verbose) {
      printf("Auto-boot: server name has not been set...\n");
    }
a944 1

d1055 1
a1055 1
  startcallbacks();
d1137 2
a1138 1
                        	LM_GracefulClosedown();
d1143 2
a1144 1
		        LM_GracefulClosedown();
a1148 36
#ifdef TRACE

static void DumpBuffer(void *ptr, int len)
{
        static char db[512];
        char *p = db;

        const char *membuf = ptr;
        int i,j;
	db[0] = '\0';
        for (i=0; i<((len+31)&~31); ++i) {
                if (!(i & 31)) {
                        p += sprintf (p, "  ");
                        if (i) for (j = i - 32; j != i; ++j) {
                                p+=sprintf(p, "%c", (membuf[j]>=32 && membuf[j] != 0x7f) ?
                                membuf[j] : '.');
                        }
                        printf("$%s\n", db);
                        p=db+sprintf(db,"%04x: ", i);
                }
                if (i>=len) {
                        p+=sprintf (p,"  ");
                        if (3==(i & 3)) p+=sprintf (p," ");
                }
                else {
                        p+=sprintf (p,"%02x", membuf[i]);
                        if (3==(i & 3)) p+=sprintf (p," ");
                }
        }
        if (i) for ( p+=sprintf (p,"  "), j = i - 32; j != i; ++j) p+=sprintf (p,"%c",
            j>=len ? ' ' : (membuf[j]>=32 && membuf[j] != 0x7f) ?
            membuf[j] : '.');
        printf("$%s\n", db);
}
#endif

d1157 2
d1160 1
a1160 9
	  if (LM_Vars.initialised != LMInitState_PreInit &&
	      LM_Vars.initialised != LMInitState_Boot) {
            return;
	  }
	  /* An interface address was set - almost certainly ours! */
	}
#ifdef TRACE
	else if (r->r[0] == InternetStatus_DynamicBootReply) {
	  DumpBuffer((void *)r->r[4], r->r[5]);
a1161 15
	else if (r->r[0] == InternetStatus_DynamicBootStart) {
	  DumpBuffer((void *)r->r[4], r->r[5]);
	}
#endif
        else {
          /* Were we actually waiting for the driver to appear */
    	  if (LM_Vars.initialised != LMInitState_PreInit &&
              LM_Vars.initialised != LMInitState_Boot) return;
     	  /* Was it the right reason code? */
	  if (r->r[0] != InternetStatus_InterfaceUpDown) return;
	  /* Was it the right interface? */
	  if (stricmp(LM_Vars.drivername, cp) != 0) return;
	  /* was the interface coming up? */
	  if (r->r[2] != 1) return;
        }
d1163 7
d1171 2
a1172 2
	        /* Should never happen nowadays ?? */
	        LM_GracefulClosedown();
d1229 2
a1230 1
	if (*str != '$' && f != NULL) {
a1236 1
	if (*str == '$') ++str; else
a1242 54


/* ========== Callback code ========== */

/* Callback management.  Some servers tend to idle-out connections.  This code stops
 * that happening.
 */
static volatile int callbackflag = 0;

_kernel_oserror *callback_handler(_kernel_swi_regs *r, void *pw)
{
	(void) r;
	(void) pw;
	if (callbackflag != 0) {
	        debug0("Anti IdleOut Callback entered\n");
	        SMB_AntiIdle();
		callbackflag = 0;
	}
	return 0;
}

static void clearcallback(void)
{
	if (callbackflag != 0) {
		(void) _swix(OS_RemoveCallBack, _INR(0,1), callback_entry, LM_pw);
		callbackflag = 0;
	}
}

_kernel_oserror *callevery_handler(_kernel_swi_regs *r, void *pw)
{
        (void) r;
	if (callbackflag == 0) {
		if (_swix(OS_AddCallBack, _INR(0,1), callback_entry, pw) == NULL) {
			callbackflag = 1;
			debug0(Module_Title ": (setcallback) just set a callback\n");
		}
	}
	return 0;
}

static void startcallbacks(void)
{
        /* Remember that as the SMB_AntiIdle routine rotates through all the shares,
         * each share will only be every pinged MAX_SHARES * 100 * 45 seconds.
         */
        (void) _swix(OS_CallEvery, _INR(0,2), 100*45, callevery_entry, LM_pw);
}

static void stopcallbacks(void)
{
        (void) _swix(OS_RemoveTickerEvent, _INR(0,1), callevery_entry, LM_pw);
        clearcallback();
}
@


1.1.1.1.2.6
log
@  Added multiple boot server capability.
  Decreased timeout on anti-idle trap.
  Removed obsolete header file.
Detail:
  Multiple boot server capability added,  Uses Inet$ServerName2 (and ..3
    etc.) until a connection to a share is made.  Use boot mount path
    in BOOTP/DHCP responses to set this variable.
  Using the standard 40 second timeout is silly on the anti-idle trap.
    Now uses a 4 second timeout and ignores errors.  Any later replies
    will be discarded automatically when the next transaction is made.
  DCI4.h is obsolete - TCPIPLibs:sys/dcistructs.h has been used for
    ages instead.
Admin:
  Tested in STB22.  Boots from backup boot server when given a silly
    name for the primary.

Version 1.87, 1.1.1.1.2.13. Tagged as 'LanManFS-1_87-1_1_1_1_2_13'
@
text
@a962 1
  int tries=1;
d988 18
a1005 29
  for (;;) {
    serv_name = RPC_GetDomainController(fs_name);
    if ( serv_name == NULL )
      serv_name = fs_name;

    if ( LM_Vars.verbose )
      printf("  Server name '%s'\n", serv_name );

    /* Wash'n'go... */

    res =  Omni_MountServer ( serv_name,  /* Server */
            "ARMBOOT", "", /* User name & password */
            "BOOT",        /* Mountname */
            "ARMBOOT",     /* Drive name */
            &tmp );          /* MountID_out */

    if ( res != OK )
    {
      printf("  Error during boot: %s\n", Xlt_Error(res)->errmess);
      /* tmp will be zero unless the share was successfully created */
      if (tmp == 0)
      {
        char var_name[sizeof("Inet$ServerName12")];
        sprintf(var_name, "Inet$ServerName%d", ++tries);
        if (!_kernel_getenv(var_name, fs_name, FSERVER_LEN))
          continue; /* Try next server */
      }
    }
    break;
@

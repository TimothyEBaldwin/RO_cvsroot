head	1.15;
access;
symbols
	LanManFS-2_62:1.15
	LanManFS-2_61:1.15
	LanManFS-2_60:1.15
	LanManFS-2_59:1.15
	LanManFS-2_58:1.15
	LanManFS-2_57:1.15
	LanManFS-2_56:1.15
	LanManFS-2_55:1.15
	LanManFS-2_54:1.15
	LanManFS-2_53:1.14
	LanManFS-2_52:1.14
	LanManFS-2_51:1.14
	LanManFS-2_50:1.14
	LanManFS-2_49:1.14
	LanManFS-2_48:1.14
	LanManFS-2_47:1.14
	LanManFS-2_46:1.13
	LanManFS-2_45:1.13
	LanManFS-2_44:1.13
	LanManFS-2_43:1.13
	LanManFS-2_42:1.13
	LanManFS-2_41:1.13
	LanManFS-2_40:1.13
	LanManFS-2_39:1.12
	LanManFS-2_38:1.11
	LanManFS-2_37:1.11
	LanManFS-2_36:1.11
	LanManFS-2_35:1.11
	LanManFS-2_34:1.11
	LanManFS-2_33:1.10
	LanManFS-2_32:1.9
	LanManFS-2_31:1.8
	RO_5_07:1.8
	LanManFS-2_30:1.8
	LanManFS-2_29:1.8
	LanManFS-2_28:1.7
	LanManFS-2_27:1.7
	LanManFS-2_26:1.7
	LanManFS-2_25:1.6
	LanManFS-2_24:1.6
	LanManFS-2_23:1.6
	LanManFS-2_22:1.5
	LanManFS-2_21:1.5
	LanManFS-2_20:1.5
	LanManFS-2_19:1.5
	LanManFS-2_18:1.5
	LanManFS-2_17:1.5
	LanManFS-2_16:1.5
	LanManFS-2_15:1.5
	LanManFS-2_14:1.5
	LanManFS-2_13:1.4
	LanManFS-2_12:1.4
	LanManFS-2_11:1.4
	LanManFS-2_10:1.3
	LanManFS-2_09:1.3
	LanManFS-2_08:1.3
	LanManFS-2_07:1.3
	LanManFS-2_06:1.3
	LanManFS-2_05:1.3
	LanManFS-2_04:1.3
	LanManFS-2_03:1.3
	LanManFS-2_02:1.2
	LanManFS-2_01:1.2
	LanManFS-2_00:1.2
	LanManFS-1_87-1_1_1_1_2_13:1.1.1.1.2.3
	LanManFS-1_87-1_1_1_1_2_12:1.1.1.1.2.3
	LanManFS-1_87-1_1_1_1_2_11:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_10:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_9:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_8:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_7:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_6:1.1.1.1
	LanManFS-1_87-1_1_1_1_2_5:1.1.1.1
	LanManFS-1_87-1_1_1_1_2_4:1.1.1.1
	LanManFS-1_87-1_1_1_1_2_3:1.1.1.1
	LanManFS-1_87-1_1_1_1_2_2:1.1.1.1
	LanManFS-1_87-1_1_1_1_2_1:1.1.1.1
	sbrodie_LanManFS_dev:1.1.1.1.0.2
	sbrodie_LanManFS_dev_bp:1.1.1.1
	LanManFS-1_87:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.15
date	2016.04.03.07.55.59;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	ETcR60kdLmCcB91z;

1.14
date	2014.08.06.20.57.20;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	ZDoXXBFnai2XolLx;

1.13
date	2013.10.03.07.27.08;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	iTaBDwF1woaPMO7x;

1.12
date	2013.09.30.19.47.04;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	MoU9V9JbMV2FYu7x;

1.11
date	2009.08.01.08.10.27;	author rsprowson;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.19.22.25.01;	author rsprowson;	state Exp;
branches;
next	1.9;

1.9
date	2009.04.15.16.00.08;	author bavison;	state Exp;
branches;
next	1.8;
commitid	GhZBwZ2GN8lg58Kt;

1.8
date	2004.01.09.11.28.01;	author bavison;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.11.20.49.01;	author kbracey;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.14.13.51.16;	author rsprowson;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.11.15.55.01;	author sbrodie;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.04.11.39.18;	author sbrodie;	state Exp;
branches;
next	1.3;

1.3
date	99.03.01.16.58.26;	author sbrodie;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.12.52.09;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	98.12.03.13.54.45;	author sbrodie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.12.03.13.54.45;	author sbrodie;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	99.01.19.14.24.47;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	99.02.10.14.55.52;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.02.12.17.18.21;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Fix for buffer overrun
The PRM entry for Free reason 1 is very vague, it requires the length of the drive name including a terminator, not strlen() of the drive name. Free uses this directly to allocate RMA to copy into (though for drive names that aren't a multiple of 8 we're saved by OS_Module rounding up claims).
Also use Free SWI values from headers rather than defining them again locally.

Version 2.54. Tagged as 'LanManFS-2_54'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
*  Lan Manager client
*
*  Omni.C -- OmniFiler interface portions
*
*  Versions
*  13-10-94 INH Original
*  02-07-96     Changes to OmniOp 8
*
*/

/* This manages the following bits:

  (i) Keeps a list of all the server names we have seen,
   in order to provide some server_ids.

  (ii) Keeps a list of all the mount paths we have seen,
   to provide an enumerate-mounts function.

  (iii) Keeps a list of all the current drives (mounts) to
   enable mount name->drive number conversion

  (iv) Does the interface to the Free module

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"

#include "stdtypes.h"
#include "SMB.h"
#include "RPC.h"
#include "LanMan.h"
#include "Printers.h"
#include "VersionNum"
#include "Xlate.h"
#include "LMVars.h"
#include "Stats.h"
#include "Logon.h"
#include "Omni.h"
#include "LanMan_MH.h"

#define INFO_STR_LEN 64
/* Length of info string kept about servers & mounts */

/* ------------------------ */

/* Information on a known mount path or printer name.
   New versions of this have one set of generic list
   handler routines  */

/* Tag for a valid disk name */
#define D_VALID_TAG 0x834EBE92
/* Tag for a valid printer name */
#define P_VALID_TAG 0x945EBE93
/* Tag for a valid server name */
#define S_VALID_TAG 0x4938EE2B
/* Tag for a valid current mount */
#define M_VALID_TAG 0x9384EBE2
/* Tag for an IPC mount */
#define I_VALID_TAG 0x24435049
/* Tag for comms device mount */
#define C_VALID_TAG 0x314D4F43

typedef struct namelist NAMELIST;  /* Our general holds-everything list */

/* Information on a server */
struct server_extra_info
{
  NAMELIST *known_disks;  /* -> list of D_VALID_TAG records */
  NAMELIST *known_printers;  /* -> list of P_VALID_TAG records */
  NAMELIST *known_ipc;  /* list of I_VALID_TAG records */
  NAMELIST *known_comms; /* list of C_VALID_TAG records */
  char      info_string[INFO_STR_LEN];
};

/* Information on a current connection */
struct mount_extra_info
{
  NAMELIST *servername;       /* Server ID -> S_VALID_TAG record*/
  NAMELIST *diskname;        /* Mount path -> D_VALID_TAG record */
  char smb_lettr;   /* SMB deals in drive letters */
  char connected;     /* Non-zero as soon as it is mounted */
};

/* Information on a share */
struct share_extra_info
{
  char      info_string[INFO_STR_LEN];
};

/* Multipurpose name-list structure */
struct namelist
{
  int    tag;                 /* One or other VALID_TAG */
  struct namelist *next;
  char   name[NAME_LIMIT];

  union
  {
    struct mount_extra_info  mount;
    struct server_extra_info server;
    struct share_extra_info share;
  } u;

  struct namelist *master_link;
};

static NAMELIST *MasterList = NULL; /* List of everything we've malloc'd */
static NAMELIST *FreeList = NULL;   /* Used for deleted items */
static NAMELIST *MountsList = NULL; /* Current mounts */
static NAMELIST *ServerList = NULL; /* Known servers (known disks/printers
                                       hang off the side of this list) */

/* Name-list functions ============================================= */

static NAMELIST *alloc_nl(void)
{
  NAMELIST *pNL;

  if ( FreeList != NULL )          /* Salvage deleted items */
  {
    NAMELIST *pLinkSave;

    pNL = FreeList;                /* Recycle one from free list */
    FreeList = FreeList->next;

    pLinkSave = pNL->master_link;  /* Clear everything except master_link */
    memset (pNL, 0, sizeof(NAMELIST));
    pNL->master_link = pLinkSave;
  }
  else
  {
    pNL = (NAMELIST *)malloc(sizeof(NAMELIST));
    if ( pNL == NULL ) /* Bum! */
      return NULL;
    memset (pNL, 0, sizeof(NAMELIST));

    pNL->master_link = MasterList; /* Add it to the master list */
    MasterList = pNL;
  }

  return pNL;
}

/* FreeAllLists() ---------------------------------*/
/* This frees everything we've allocated; it also does some
   heavy deletion of things to prevent grief if it gets called
   twice, etc.
*/
static void FreeAllLists(void)
{
  NAMELIST *pNL, *pNL2;

  pNL = MasterList;
  FreeList = NULL;
  MasterList = NULL;

  while ( pNL != NULL )
  {
    pNL2 = pNL->master_link;
    memset (pNL, 0, sizeof(NAMELIST));
    free(pNL);
    pNL = pNL2;
  }

}

/* AddToList() ------------------------------------*/
/* This adds a given name to a list, and returns a pointer to
   the item. If an item of the same name already exists on
   the list, no allocation is performed; the existing item
   is returned. New allocations have all their 'extra_info'
   fields set to zero.
*/
static NAMELIST *AddToList( NAMELIST **pListHead, int valid_tag,
                              const char *name_in )
{
  NAMELIST *pNL, *pNLprev, *pNLnew;
  int c;
  char namebuf[NAME_LIMIT];

  /* Truncate name appropriately */
  strcpyn ( namebuf, name_in, NAME_LIMIT );

  /* Traverse list */
  for ( pNL= *pListHead, pNLprev = NULL;
        pNL != NULL;
        pNLprev = pNL, pNL = pNL->next )
  {
     c = stricmp ( pNL->name, namebuf );
     if ( c == 0 ) return pNL;  /* Exact match */
     if ( c > 0 )  /* Item goes after pNLprev and before pNL */
       break;
  }

  /* Need to insert item before pNL and after pNLprev.
     pNLprev is NULL if it goes at the head of the list. */

  pNLnew = alloc_nl();

  if ( pNLnew == NULL )  /* Bummer! Failed! */
    return NULL;

  pNLnew->tag = valid_tag;
  strcpy(pNLnew->name, namebuf);
  pNLnew->next = pNL;

  if ( pNLprev == NULL )
    *pListHead = pNLnew;
  else
    pNLprev->next = pNLnew;

  return pNLnew;
}

/* FindInList() -----------------------------------*/
static NAMELIST *FindInList ( NAMELIST *ListHead, const char *name_in )
{
  NAMELIST *pNL;
  int c;
  char namebuf[NAME_LIMIT];

  /* Truncate name appropriately */
  strcpyn ( namebuf, name_in, NAME_LIMIT );

  /* Traverse list */
  for ( pNL= ListHead; pNL != NULL; pNL = pNL->next )
  {
     c = stricmp ( pNL->name, namebuf );
     if ( c == 0 ) return pNL;  /* Exact match */
     if ( c > 0 )  /* Gone past end */
       break;
  }

  return NULL;     /* Not found */
}

/* DeleteFromList() -------------------------------*/
static void DeleteFromList( NAMELIST **pListHead, NAMELIST *item )
{
  NAMELIST *pNL;

  if ( *pListHead == item )  /* First in list */
  {
    *pListHead = item->next;
  }
  else                       /* Search for it in list */
  for ( pNL = *pListHead; pNL != NULL; pNL = pNL->next )
  {
    if ( pNL->next == item )
    {
      pNL->next = item->next;
      break;
    }
  }

  /* Add to freelist */
  item->next = FreeList;
  item->tag  = 0;
  FreeList = item;
}

/* Main Routines =================================================== */

/* FindActiveMount() ------------------------------*/
/* Given a disk (D_VALID_TAG) record, finds out if it is the current
   active mounts list. If so, returns a NAMELIST * for the corresponding
   entry in the list.
   If not, returns NULL.
*/
static NAMELIST *FindActiveMount ( NAMELIST *pD )
{
  NAMELIST *pNL;

  for ( pNL = MountsList; pNL != NULL; pNL = pNL->next )
    if ( pNL->u.mount.diskname == pD )
      return pNL;

  return NULL;
}

/* Validate() -------------------------------------*/
static NAMELIST *Validate(int id, int validtag)
{
  NAMELIST *pNL;
  if ( id != 0 && ((id & 3)== 0) ) /* Aligned pointer check! */
  {
    pNL = (NAMELIST *)id;
    if ( pNL->tag == validtag )
      return pNL;
  }
  return NULL;
}

static char work_buf[80];
static char name_buf[NAME_LIMIT+16];

/* DoCLIop() --------------------------------------*/
/* This does a CLI operation on the given mount. The command
   string should contain a %s at the point where the mount
   name should be put, it will be replaced by "LanMan::mountname"
*/
static err_t DoCLIop ( char *command, int mount_id )
{
  _kernel_swi_regs R;

  NAMELIST *pNL = Validate(mount_id, (int)M_VALID_TAG);

  if ( pNL == NULL )
    return EBADPARAM;

  sprintf( name_buf, FilingSystemName "::%s", pNL->name );
  sprintf( work_buf, command, name_buf );
  R.r[0] = (int) work_buf;
  return MsgSetOSError( _kernel_swi ( XOS_Bit | OS_CLI, &R, &R ));
}

/* MountNameCpy() ---------------------------------*/
static void MountNameCpy ( char *d, char *s )
{
  int n_written=0, c;

  while ( n_written < (NAME_LIMIT-1) )
  {
    c = *s++;
    if ( c==' ' || c=='/' || c=='\\')
      continue;  /* Skip spaces */
    if ( c <' ' || c=='.' || c=='*' || c=='$' )
      break;
    *d++ = c;
    n_written++;
  }

  *d = 0;
}

static int ReentryCount = 0;

/* BootMount() ------------------------------------ */
/* Runs the !ArmBoot file, if such a thing exists. The !ArmBoot file
   may contain perfectly valid *Connect commands, and so this bit
   will be reentrant. The laws are therefore this: nothing following
   the call to DoCLIop must rely on any static variables/buffers which
   are able to be modified by any *command or SWI. As a safeguard, we
   limit the number of times this can be reentered (the limit is
   MAX_DRIVES)
*/
#ifdef CHECK_ARMBOOT_EXISTS
static err_t BootMount_check_file ( NAMELIST *pNLmount, const char *leaf )
{
  int type;
  static char filename[80];
  err_t e;

  sprintf ( filename, FilingSystemName "::%s.$.%s", pNLmount->name, leaf );
  e = MsgSetOSError(_swix(OS_File, _INR(0,1)|_OUT(0), 23, filename, &type));
  if (e == OK) {
    if (type == 0) e = ECANTFINDNAME;
  }
  return e;
}
#endif

static err_t BootMount ( NAMELIST *pNLmount )
{
  _kernel_swi_regs R;
  err_t res;

  /* Attempts to run a !ArmBoot file or applicationn, if it exists */

  if ((_kernel_osbyte(129, 255, 255) & 0xFF00) == 0xFF00) {
     /* SHIFT was depressed, or an error occurred */
     return OK;
  }


#ifdef TRACE
  debug1("BootMount looking for %s\n", work_buf);
#endif

  /* If no such file or directory, we can stop now */
#ifdef CHECK_ARMBOOT_EXISTS
  if (BootMount_check_file(pNLmount, "!ARMBOOT") != OK)
    return OK;
#else
  return OK;
#endif

  /* Safety check */
  if ( ReentryCount >= MAX_DRIVES )
    return EBOOTREENTRY;

  ++ReentryCount;
  R.r[0] = 0; /* Are we running in desktop? */
  if ( _kernel_swi ( XOS_Bit | Wimp_ReadSysInfo, &R, &R ) == NULL &&
       R.r[0] > 0 )
  {
    /* Yes? Filer_run it */
    res = DoCLIop ("Filer_run %s.$.!ArmBoot", (int) pNLmount );
  }
  else
  {
    res = DoCLIop ("Run %s.$.!ArmBoot", (int) pNLmount );
  }
  --ReentryCount;

  /* To avoid confusion, use a different error for !ArmBoot errors */
  if ( res != OK )
    return EBOOTERROR;

  return res;
}

/* Omni_MountServer() ------------------------------- */
/* Makes a connection to a server;
   it is the XXXX_OmniOp 0 SWI.
*/
err_t Omni_MountServer ( char *servname, char *userID, char *passwd,
         char *mountname, char *mountpath, int *mount_id_out )
{
  err_t res;
  char namebuf[NAME_LIMIT];
  NAMELIST *pNLmount, *pNLsrv;

  *mount_id_out = 0;

#ifdef TRACE
  debug3("Omni_MountServer: %p %p %p\n", mountname, servname, mountpath);
#endif

  if ( mountname == NULL || servname == NULL || mountpath == NULL )
    return EBADPARAM;

  MountNameCpy ( namebuf, mountname );

  /* Check for mount with same name */

  pNLmount = AddToList ( &MountsList, (int)M_VALID_TAG, namebuf );

  if ( pNLmount == NULL )    /* Out of memory -oops! */
    return ECONNLIMIT;

  if ( pNLmount->u.mount.connected != 0 )
  {
    /* Mount name exists - delete it so we can reuse it */
    SMB_DeleteShare (pNLmount->u.mount.smb_lettr);
  }

  /* Connect or amend connection details */

  res = SMB_CreateShare ( SHR_DISK, CREATE_NEW_USER | CREATE_NEW_SHARE,
              servname, mountpath, userID, passwd,
              &(pNLmount->u.mount.smb_lettr) );

  if ( res != OK ) /* Didn't work. Forget it */
  {
#ifdef TRACE
    debug0("SMB_CreateShare failed\n");
#endif
    DeleteFromList ( &MountsList, pNLmount );
    return res;
  }

  /* Yes, it worked: update our known-server & known-shares lists */

  pNLmount->u.mount.connected  = 1;

  pNLsrv = AddToList ( &ServerList, S_VALID_TAG, servname );
  pNLmount->u.mount.servername = pNLsrv;

  if ( pNLsrv != NULL )
  {
    pNLmount->u.mount.diskname =
      AddToList ( &pNLsrv->u.server.known_disks, (int)D_VALID_TAG, mountpath );
  }
  else                /* Out of memory - carry on anyway */
  {
    pNLmount->u.mount.diskname  = NULL;
  }

  /* Indicate success to !Omni. This is now independent of whether we
     return an error or not */

  *mount_id_out = (int) (pNLmount);

  /* The connection to the server might have changed & new browse
      info might be available */

  Omni_RecheckInfo(RI_SERVERS);
  Omni_RecheckInfo(RI_PRINTERS);

  /* Done - try to run !ArmBoot file */

  return BootMount ( pNLmount );
}

/* Omni_DismountServer() --------------------------*/
/* Does XXXX_OmniOp 1 */
err_t Omni_DismountServer ( int mount_id )
{
  NAMELIST *pNL = Validate(mount_id, (int)M_VALID_TAG);

  if ( pNL == NULL )
    return EBADPARAM;

  /* Disregard errors! Disconnect anyway! */

  DoCLIop ("Filer_CloseDir %s.$", mount_id );
  SMB_DeleteShare (pNL->u.mount.smb_lettr);
  DeleteFromList(&MountsList, pNL);
  return OK;
}

/* Omni_FreeSpace() -------------------------------*/
/* Does XXXX_OmniOp 2 */
static uint size_clip ( uint val, uint limit, uint blksize )
{
  return (val > limit) ? 0xFFFFFFFFU : val * blksize;
}

static err_t Omni_DetermineFreeSpace ( int mount_id,
       struct disk_size_response *DSR)
{
  NAMELIST *pNL = Validate(mount_id, (int)M_VALID_TAG);

  if ( pNL == NULL )
    return EBADPARAM;

  return SMB_GetFreeSpace ( pNL->u.mount.smb_lettr, DSR );
}

static err_t Omni_FreeSpace ( int mount_id,
       int *freespace_out, int *usedspace_out, int *totspace_out )
{
  struct disk_size_response DSR;
  uint blklimit;
  err_t res;

  res = Omni_DetermineFreeSpace ( mount_id, &DSR );
  if ( res != OK )
    return res;

  /* Make sure we don't overflow.
     Free space in bytes is DSR.blksize * DSR.freeblks */

  blklimit = 0xFFFFFFFFU / DSR.blksize;

  *freespace_out = size_clip( DSR.freeblks, blklimit, DSR.blksize );
  *totspace_out  = size_clip( DSR.totalblks, blklimit, DSR.blksize );
  *usedspace_out  = size_clip( DSR.totalblks-DSR.freeblks,
                                             blklimit, DSR.blksize );

  return OK;
}

/* Omni_FreeSpace64() ------------------------------*/
/* Does XXXX_OmniOp 4 */
static err_t Omni_FreeSpace64 ( int mount_id, int *success,
       QWORD *freespace_out, QWORD *usedspace_out, QWORD *totspace_out )
{
  struct disk_size_response DSR;
  err_t res;
  uint  used;
  
  res = Omni_DetermineFreeSpace ( mount_id, &DSR );
  if ( res != OK )
    return res;

  /* DWORD*DWORD => QWORD result */
  *freespace_out = (QWORD)DSR.freeblks * DSR.blksize;
  *totspace_out = (QWORD)DSR.totalblks * DSR.blksize;
  used = DSR.totalblks - DSR.freeblks; 
  *usedspace_out = (QWORD)used * DSR.blksize;
  *success = 0;

  return OK;
}

/* Subroutines to help enumeration routines ======================== */
static char *enum_ptr;
static int   enum_bytes_left;

static bool enum_align_ptr(void)
{
  int p = (int) enum_ptr;
  p = (-p) & 3; /* Number of bytes needed to align pointer to a word */

  if ( enum_bytes_left < p )
    return false;

  enum_bytes_left -= p;
  enum_ptr += p;
  return true;
}

static bool enum_write_word( int val )
{
  if ( enum_bytes_left < 4 )
    return false;

  *((int *)enum_ptr) = val;

  enum_bytes_left -= 4;
  enum_ptr += 4;
  return true;
}

static bool enum_write_string( char *str, int maxlen )
  /* maxlen is maximum length including null terminator */
{
  int len = strlen(str)+1;
  if ( len > maxlen ) len = maxlen;

  if ( enum_bytes_left < len )
    return false;

  memcpy ( enum_ptr, str, len );
  enum_ptr[len-1] = 0;
  enum_bytes_left -= len;
  enum_ptr += len;
  return true;
}

/* Omni_ListServers() -----------------------------*/
/* Does XXXX_OmniOp 3 */
static err_t Omni_ListServers ( char *buf_ptr, int buf_size, int token_in,
              const char **pNextByte_out, int *pToken_out )
{
  /* If token_in is 0 we start from the beginning of the list;
     if not it should be a pToken_out which we previously
     supplied. Our tokens will be pointers to entries in
     the server list */

  NAMELIST *pNL;
  char *next_byte_written;

  /* Check token_in */

  if ( token_in == 0 )
  {
    if ( LM_Vars.logged_on )
      RPC_EnumerateServers( LM_Vars.workgroup );
    pNL = ServerList;
  }
  else
  {
    pNL = Validate(token_in, S_VALID_TAG );
    if ( pNL == NULL )
      return EBADPARAM;
  }

  /* Write data */

  enum_ptr = buf_ptr;
  enum_bytes_left = buf_size;
  next_byte_written = buf_ptr;

  while ( pNL != NULL )
  {
    if ( enum_write_word( (int) pNL ) &&
         enum_write_string ( pNL->name, 16 ) &&
         enum_write_string ( pNL->name, 32 ) &&
         enum_write_string ( pNL->u.server.info_string, 64 ) &&
         enum_align_ptr()
       )
    {
      /* Record written OK */
      next_byte_written = enum_ptr;
      pNL = pNL->next;
    }
    else /* Can't fit this record in! */
      break;
  }

  /* Done! pNL is the next record which would have been
     written, or NULL if we're all done */

  *pNextByte_out = next_byte_written;
  *pToken_out = (int) pNL;
  return OK;
}

/* Omni_ListMounts() ------------------------------*/
/* Does XXXX_OmniOp 4 */
static err_t Omni_ListMounts (
     char *buf_ptr, int buf_size, int token_in,
     int server_id, char *server_name,
     const char **pNextByte_out, int *pToken_out )
{
  /* If token_in is 0 we start from the beginning of the list;
     if not it should be a pToken_out which we previously
     supplied. Here, tokens will be pointers to entries on the
     known_disks list for each server. */

  NAMELIST *pNLsrv;
  NAMELIST *pNLdisk;
  char *next_byte_written;


  /* If token_in is non-NULL, we're in the middle */

  if ( token_in != 0 )
  {
    pNLdisk = Validate(token_in, (int)D_VALID_TAG);
    if ( pNLdisk == NULL )
      return EBADPARAM;
  }
  else if ( server_id != 0 ) /* Use given server ID */
  {
    pNLsrv = Validate(server_id, S_VALID_TAG);
    if ( pNLsrv == NULL )
      return EBADPARAM;

    /* Get disk/printer shares for this server */
    if ( LM_Vars.logged_on )
      RPC_EnumerateShares ( pNLsrv->name );

    pNLdisk = pNLsrv->u.server.known_disks;
  }
  else /* Use given server name */
  {
    /* Attempt to contact server - it will be added to list if OK */
    if ( LM_Vars.logged_on )
      RPC_EnumerateShares ( server_name );

    pNLsrv = FindInList(ServerList, server_name);
    if ( pNLsrv == NULL )  /* Not found - give zero results */
      pNLdisk = NULL;
    else
      pNLdisk = pNLsrv->u.server.known_disks;
  }

  /* Now list known mounts ------------ */

  enum_ptr = buf_ptr;
  enum_bytes_left = buf_size;
  next_byte_written = buf_ptr;

  while ( pNLdisk != NULL )
  {
    if ( enum_write_word( (int) FindActiveMount(pNLdisk) ) &&
         enum_write_string ( pNLdisk->name, 16 ) &&
         enum_write_string ( pNLdisk->name, 32 ) &&
         enum_align_ptr()
       )
    {
      /* Record written OK */
      next_byte_written = enum_ptr;
      pNLdisk = pNLdisk->next;
    }
    else /* Can't fit this record in! */
      break;
  }

  /* Done ! pNLdisk is the next record which would have been
     written, or NULL if we're all done */

  *pNextByte_out = next_byte_written;
  *pToken_out = (int) pNLdisk;
  return OK;
}

/* Omni_ListActiveMounts() ------------------------*/
/* Does XXXX_OmniOp 5 */
static err_t Omni_ListActiveMounts ( char *buf_ptr, int buf_size,
    int token_in, const char **pNextByte_out, int *pToken_out )
{
  /* Here, the token_in/token_out numbers will pointers to entries in
     the MountsList list.
  */

  char *next_byte_written;
  NAMELIST *pNL;


  if ( token_in == 0 )
    pNL = MountsList;
  else
  {
    pNL = Validate(token_in, (int)M_VALID_TAG);
    if ( pNL == NULL )
      return EBADPARAM;
  }

  enum_ptr = buf_ptr;
  enum_bytes_left = buf_size;
  next_byte_written = buf_ptr;

  while ( pNL != NULL )
  {
    if ( enum_write_word ( (int) (pNL->u.mount.servername) ) && /* Server ID */
         enum_write_word ( (int) pNL ) && /* Mount ID */
         enum_write_string ( pNL->name, 16 ) &&
         enum_align_ptr()
       )
    {
      next_byte_written = enum_ptr; /* Written OK */
      pNL = pNL->next;
    }
    else /* Record wouldn't fit */
      break;
  }

  /* Search complete if pNL == NULL, or pNL = next record if not */

  *pNextByte_out = next_byte_written;
  *pToken_out = (int) pNL;
  return OK;
}

/* Omni_ListPrinters() ------------------------*/
/* Does XXXX_OmniOp 16 */
static err_t Omni_ListPrinters ( char *buf_ptr, int buf_size,
    int token_in, const char **pNextByte_out, int *pToken_out )
{
  /* Here, the token_in/token_out numbers will be pointers
     to an entry on the known_printers list for each
     server. Unfortunately, we have to flatten the servers/
     printers list, hence this may get a little slow.
  */

  NAMELIST *pNLsrv;    /* Pointer in servers list */
  NAMELIST *pNLprn;    /* Current printer */
  NAMELIST *pNLstart;  /* Printer at which to start enumerating */

  char *next_byte_written;

  /* Check token_in */

  if ( token_in == 0 )
    pNLstart = NULL;
  else
  {
    pNLstart = Validate ( token_in, (int)P_VALID_TAG );
    if ( pNLstart == NULL )
      return EBADPARAM;
  }

  /* ------- */

  enum_ptr = buf_ptr;
  enum_bytes_left = buf_size;
  next_byte_written = buf_ptr;
  pNLprn = NULL;  /* In case no servers! */

  for ( pNLsrv = ServerList; pNLsrv != NULL; pNLsrv = pNLsrv->next )
    for ( pNLprn = pNLsrv->u.server.known_printers; pNLprn != NULL;
                                            pNLprn = pNLprn->next )
    {
      if ( pNLstart == NULL || pNLprn == pNLstart )
      {
        /* Write record */
        if ( enum_write_word( 0 ) &&  /* Flags */
             enum_write_string ( pNLprn->name, 24 ) && /* Printer name */
             enum_write_string ( pNLsrv->name, 64 ) && /* Server name */
             enum_align_ptr()
           )
        {
          next_byte_written = enum_ptr;
        }
        else
          goto out_of_buffer;

        /* Record written OK */
      }
    }

  /* Done ! pNLprn is NULL if we finished OK, or a pointer to the
     printer record which we were about to write when we ran out
     of buffer */

out_of_buffer:
  *pNextByte_out = next_byte_written;
  *pToken_out = (int) pNLprn;
  return OK;
}

/* Omni_OpenRoot () -------------------------------*/
/* Triggers a filer_opendir on the root directory for a given mount */

static err_t Omni_OpenRoot ( int mount_id )
{
  return DoCLIop ("Filer_OpenDir %s.$", mount_id );
}

/* Omni_OpenUserRoot () ---------------------------*/
/* Triggers a filer_opendir on the user's home directory for a given mount */
static err_t Omni_OpenUserRoot ( int mount_id )
{
  return DoCLIop ("Filer_OpenDir %s.$", mount_id );
}

/* Omni_GetNewMountInfo() -------------------------*/
/* Works out whether a new password or userID will be needed for
   a new mount on an existing server.

   (02-07-96) This is called when a user double-clicks on an icon in
   the available-mounts window for a particular server. This is called
   with the server id and the (as I understand it) short name of the
   mount, and we get to say whether we have all the information we
   need to mount it.
*/
static err_t Omni_GetNewMountInfo ( int server_id, char *MountPath,
                                       int *pFlags_out )
{
  const char *flags;
  NAMELIST *pSrv, *pNL;

  (void) MountPath;

  pSrv = Validate(server_id, S_VALID_TAG);

  if ( pSrv == NULL )
    return EBADPARAM;

  for ( pNL = MountsList; pNL != NULL; pNL = pNL->next )
  {
    if ( pNL->u.mount.servername == pSrv )
    {
      /* This server is connected somewhere */
      flags = SMB_GetConnInfo( pNL->u.mount.smb_lettr, GCI_LOGONTYPE );

      if ( flags == NULL ) /* Never heard of it */
        return EBADPARAM;

      if ( flags[0] == GCIF_USERLOGON ) /* Doesn't need userID or passwd */
        *pFlags_out = RC_NEEDS_MOUNTPATH | RC_DOES_FILES;
      else                /* WFWG-type machine */
        *pFlags_out = RC_NEEDS_PASSWD | RC_NEEDS_MOUNTPATH | RC_DOES_FILES;
                          /* Needs password per share attached */

      return OK;
    }
  }

  /* No, we're not connected. Are we logged on ? */
  if ( LM_Vars.logged_on )
  {
    *pFlags_out = RC_NEEDS_MOUNTPATH | RC_DOES_FILES;
  }
  else
  {
    *pFlags_out = RC_NEEDS_USERID | RC_NEEDS_PASSWD | RC_NEEDS_MOUNTPATH |
                RC_DOES_FILES;
  }
  return OK;
}

/* Omni_GetMountInfo() ----------------------------*/
/* Gets info about an existing mount */
err_t Omni_GetMountInfo ( int mount_id, const char **pServName,
     const char **pUserName, const char **pMountName, const char **pMountPath, int *pServerID )
{
  char smbletter;
  NAMELIST *pNL = Validate(mount_id, (int)M_VALID_TAG);

  if ( pNL == NULL )
    return EBADPARAM;

  *pMountName = pNL->name;
  *pServerID = (int) (pNL->u.mount.servername);

  smbletter = pNL->u.mount.smb_lettr;

  *pServName = SMB_GetConnInfo ( smbletter, GCI_SERVER );
  *pUserName = SMB_GetConnInfo ( smbletter, GCI_USER );
  *pMountPath = SMB_GetConnInfo ( smbletter, GCI_SHARE );

  return OK;
}

/* Exported functions ============================================== */

static bool Omni_Registered = false;

/* Omni_GetDrvLetter() ----------------------------*/
/* Gets an SMB drive letter given a mount name.
   Returns 0 if not found. 'Name' should be not contain
   spaces or invalid chars, otherwise it won't be found.
*/
char Omni_GetDrvLetter ( char *name )
{
  NAMELIST *pNL = FindInList ( MountsList, name );

  if ( pNL != NULL )
    return pNL->u.mount.smb_lettr;

  return 0;
}


/* Omni_GetMountID() ------------------------------*/
/* This should be used when the mount name is from dodgy
   sources, as it will do 'MountNameCpy' processing on it first.
*/
int Omni_GetMountID ( char *name )
{
  char lclname[NAME_LIMIT];
  MountNameCpy(lclname, name);
  return (int) FindInList(MountsList, lclname);
}

/* Omni_GetDefaultType() --------------------------*/
/* Attempts to ask OmniFiler for the type for a given file name */
err_t Omni_GetDefaultType ( char *name, int * pType_out )
{
  _kernel_swi_regs R;
  _kernel_oserror *pE;

  char tmpbuf  [NAME_LIMIT];
  char tmpbuf2 [NAME_LIMIT];

  if ( !Omni_Registered )
    return ENOTPRESENT;

  R.r[0] = LanMan_OmniOp; /* Client ID */
  R.r[1] = (int) name;
  R.r[2] = (int) tmpbuf;  /* We ignore the name it returns! */
  R.r[3] = (int) tmpbuf2; /* Flags string */
  pE = _kernel_swi ( SWI_Omni_ConvertClientToAcorn, &R, &R );
  if ( pE != NULL )
    return ENOTPRESENT;

  if ( R.r[0] < 0 )
    return ENOTPRESENT;

  *pType_out = R.r[0];
  return OK;
}

/* OmniOp_SWI() -----------------------------------*/
/* Provides the LanMan_OmniOp SWI handler */
_kernel_oserror *OmniOp_SWI ( _kernel_swi_regs *R )
{
  err_t res;

  debug1(" Omni Op(%d):", R->r[0]);

#define Rin_int(a)   (R->r[a])
#define Rout_int(a) &(R->r[a])
#define Rin_chr(a)   (char *)(R->r[a])
#define Rout_chr(a)  (const char **)&(R->r[a])

  switch ( R->r[0] )
  {
    case 0:  /* Mount */
      res = Omni_MountServer ( Rin_chr(1),
                               Rin_chr(2),
                               Rin_chr(3),
                               Rin_chr(4),
                               Rin_chr(5),
                               Rout_int(1) );
      break;

    case 1:  /* Dismount */
      res = Omni_DismountServer ( Rin_int(1) );
      break;

    case 2:  /* Freespace */
      res = Omni_FreeSpace ( Rin_int(1),
                             Rout_int(1), Rout_int(2), Rout_int(3) );
      break;

    case 3:  /* Enumerate servers */
      res = Omni_ListServers ( Rin_chr(1),
                               Rin_int(2),
                               Rin_int(3),
                               Rout_chr(1),
                               Rout_int(3) );
      break;

    case 4:  /* Enumerate mounts */
      res = Omni_ListMounts  ( Rin_chr(1),
                               Rin_int(2),
                               Rin_int(3),
                               Rin_int(4),
                               Rin_chr(5),
                               Rout_chr(1),
                               Rout_int(3) );
      break;

    case 5:  /* Enumerate active mounts */
      res = Omni_ListActiveMounts  ( Rin_chr(1),
                               Rin_int(2),
                               Rin_int(3),
                               Rout_chr(1),
                               Rout_int(3) );
      break;

    case 6:  /* Open root of mount */
      res = Omni_OpenRoot ( Rin_int(1) );
      break;

    case 7:  /* Open user root of mount */
      res = Omni_OpenUserRoot ( Rin_int(1) );
      break;

    case 8:  /* Get new mount info */
      res = Omni_GetNewMountInfo ( Rin_int(1),
                                   Rin_chr(2),
                                   Rout_int(1) );
      break;

    case 9:  /* Get active mount info */
      res = Omni_GetMountInfo ( Rin_int(1),
                                Rout_chr(1),
                                Rout_chr(2),
                                Rout_chr(3),
                                Rout_chr(4),
                                Rout_int(6) );
      R->r[5] = (int)""; /* Auth server */
      break;

    case 10: /* Create print job */
      res = Prn_CreateJob ( Rin_chr(1),  /* Server name */
                            Rin_chr(2),  /* Printer name */
                            Rin_chr(3),  /* User name */
                            Rin_chr(4),  /* Password */
                            Rout_int(1)); /* Job handle */
      break;

    case 11: /* Send to print job */
      res = Prn_WriteData ( Rin_int(1), /* Job ID */
                            Rin_chr(2), /* data pointer */
                            Rin_int(3) ); /* Data length */

      if ( res == OK ) R->r[3] = 0;
      break;

    case 12: /* End print job */
      res = Prn_CloseJob ( Rin_int(1), /* Job ID */
                           false );
      break;

    case 13: /* Abort print job */
      res = Prn_CloseJob ( Rin_int(1), /* Job ID */
                           true );
      break;

    case 14: /* Get print job info */
      res = Prn_GetJobStatus ( Rin_int(1), /* Job ID */
                (struct JobStatus *) &(R->r[1]) );
                /* Fill in R1 through R6 */
      break;


    case 15: /* Clear print job */
      res = Prn_ClearJob ( Rin_int(1) ); /* Job ID */
      break;

    case 16: /* Enumerate printers */
      res = Omni_ListPrinters ( Rin_chr(1),
                                Rin_int(2),
                                Rin_int(3),
                                Rout_chr(1),
                                Rout_int(3) );
      break;

    default:
      res = ENOTPRESENT;
  }

  return MsgError(res);
}

/* Omni_FreeOp_SWI() ------------------------------*/
/* This is not strictly OmniClient. Instead it is for use by
   the Free module. On exit, set R1 to 0 if we want the Z
   bit set on return.
*/
static char *ExtractName ( char * s )
{
  char *p = strrchr(s, ':');   /* Finds last ':' in name */
  if ( p != NULL )
    return p+1;
  else
    return s;
}

_kernel_oserror *Omni_FreeOp_SWI (_kernel_swi_regs *R )
{
  switch ( R->r[0] )
  {
    case 0:  /* Bizarre no-op */
      return NULL;

    case 1: /* Get Device Name */
      /* On entry R->r[3] points to a "device name/id" string
         It seems we have to return a copy of the device name.
         As I don't know what this is supposed to be for, I'm
         just going to copy the name. */
      {
        char *s = (char *)(R->r[3]);
        char *d = (char *)(R->r[2]);
        sprintf ( d, FilingSystemName "::%s", s );
        R->r[0] = strlen(d) + 1 /* Terminator */;
        return NULL;
      }

    case 2:   /* Get free space on device */
      /* R->r[3] on entry points to a device name.
         Methinks this is the same as returned from
         case 1 */
      {
        int m_id = Omni_GetMountID ( ExtractName( (char *)(R->r[3]) ));
        if ( m_id == 0 )
          return MsgError(EBADDRV);

        return MsgError ( Omni_FreeSpace ( m_id,
           (int *)(R->r[2]+4) /* freespace_out */,
           (int *)(R->r[2]+8) /* usedspace_out */,
           (int *)(R->r[2])   /* totspace_out */ ) );
      }

    case 3:   /* Compare device */
      /* I think we're given a file name & have to work out
         if it's on our device. Return R->r[1] = 1 if not, R->r[1] = 0
         if so. */
      {
        char *s, *d;
        R->r[1] = 1;  /* Assume failure */

        s = ExtractName( (char *)(R->r[2]) ); /* File name */
        d = ExtractName( (char *)(R->r[3]) ); /* Our device name */

        while ( toupper(*s) == toupper(*d) ) s++, d++;

        if ( *d == 0 && (*s == 0 || *s == '.') )
          R->r[1] = 0;

        return NULL;
      }

    case 4:   /* Get free space on device (64 bit) */
      /* R->r[3] on entry points to a device name.
         Methinks this is the same as returned from
         case 1 */
      /* This code can be entered directly by Cmd_FREE */
      {
        int m_id = Omni_GetMountID ( ExtractName( (char *)(R->r[3]) ));
        if ( m_id == 0 )
          return MsgError(EBADDRV);

        return MsgError ( Omni_FreeSpace64 ( m_id,
           (int *)&(R->r[0]),       /* zero it on success */
           (QWORD *)(R->r[2]+8)  /* freespace_out */,
           (QWORD *)(R->r[2]+16) /* usedspace_out */,
           (QWORD *)(R->r[2]+0)  /* totspace_out */ ) );
      }

    default:
      break;
  }

  return MsgError(EBADPARAM);
}

/* Omni_RecheckInfo() -----------------------------*/
/* This is called after *Commands or other actions which
   might change the available mounts or network information.
   It basically calls Omni_EnumerateMounts.
*/
void Omni_RecheckInfo( int flags )
{
  _kernel_swi_regs R;

  if ( Omni_Registered )
  {
    R.r[0] = LanMan_OmniOp; /* Client ID */
    R.r[1] = flags;  /* Enumerate servers/mounts */;
    _kernel_swi ( SWI_Omni_EnumerateMounts, &R, &R );
  }
}

/* Omni_Register() --------------------------------*/
static void Omni_Register(void)
{
  char titlebar[24];  /* Title bar - 24 max */
  char infobox[3*32]; /* Info box - 3x32 max */

  strcpy( titlebar, MsgLookup("_Version") ); /* Temp copy */
  sprintf( infobox, "%s\n"
                    "\xA9 Acorn Computers Ltd, 1997\n"
                    "%s",
                    ( Stat_ClassMask & SCLASS_IP ) ? MsgLookup("WhoTCPIP")
                                                   : MsgLookup("WhoBEUI"),
                    titlebar );
  strncpy( titlebar, MsgLookup("DispName"), sizeof(titlebar) );

  if ( _swix( SWI_Omni_RegisterClient, _INR(0,6),
              LanMan_OmniOp, /* Client ID */
              RC_NEEDS_USERID | RC_NEEDS_PASSWD | RC_NEEDS_MOUNTPATH |
              RC_DOES_FILES | RC_EXTN_CHAR('.') |
              RC_DOES_PRINT | RC_NEEDS_PRINTPWD,
              "lmicon", /* Sprite name - 12 max */
              titlebar, /* Title bar - 24 max */
              infobox,  /* Info box - 3x32 max */
              0, /* Site ID (ignored) */
              FilingSystemName ) == NULL )
    Omni_Registered = true;
}

/* Omni_Free_Register() ---------------------------*/
static void Omni_Free_Register(bool OnNotOff)
{
  _kernel_swi_regs R;

  R.r[0] = Our_FS_Number;
  R.r[1] = (int) Free_ServiceRoutine;  /* Exported by s.Interface */
  R.r[2] = 0;  /* R12 value, don't care */

  if ( OnNotOff )
    _kernel_swi ( Free_Register, &R, &R );
  else
    _kernel_swi ( Free_DeRegister, &R, &R );
}

/* Omni_StartUp() ---------------------------------*/
/* Attempts to register us with OmniFiler and the
   Free module. Called when the module loads.
*/
void Omni_StartUp ( void )
{
  if ( !Omni_Registered )
    Omni_Register();

  Omni_Free_Register(true);
}

/* Omni_Shutdown() --------------------------------*/
/* This is called if we're about to die.
   If so, we should deregister ourselves with OmniFiler, and
   free any alloc'd memory.
*/
void Omni_Shutdown ( void )
{
  _kernel_swi_regs R;

  /* Free memory */

  FreeAllLists();
  ServerList = NULL;
  MountsList = NULL;

  /* De-register if we're registered */

  if ( Omni_Registered )
  {
    R.r[0] = LanMan_OmniOp;
    _kernel_swi ( SWI_Omni_DeregisterClient, &R, &R );
    Omni_Registered = false;
  }

  Omni_Free_Register(false);
}

/* Omni_ClearLists() ------------------------------*/
/* This is called when a *LMLOGOFF or similar is done,
   and deletes all servers which we don't currently have
   a connection to */
void Omni_ClearLists ( void )
{
  NAMELIST *pNLsrv, *pNLdisk, *pNLtmp;

  pNLsrv = ServerList;
  while ( pNLsrv != NULL )
  {
    /* Free disks that aren't in use */

    pNLdisk = pNLsrv->u.server.known_disks;
    while ( pNLdisk != NULL )
    {
      if ( FindActiveMount ( pNLdisk ) == NULL )
      {
        pNLtmp = pNLdisk->next;
        DeleteFromList ( &pNLsrv->u.server.known_disks, pNLdisk );
        pNLdisk = pNLtmp;
      }
      else
        pNLdisk = pNLdisk->next;
    }

    /* Free printers from list (keep deleting them 'til they don't
       come back) */
    while ( pNLsrv->u.server.known_printers != NULL )
      DeleteFromList ( &(pNLsrv->u.server.known_printers),
                         pNLsrv->u.server.known_printers );

    while ( pNLsrv->u.server.known_ipc != NULL )
      DeleteFromList ( &(pNLsrv->u.server.known_ipc),
                         pNLsrv->u.server.known_ipc );

    while ( pNLsrv->u.server.known_comms != NULL )
      DeleteFromList ( &(pNLsrv->u.server.known_comms),
                         pNLsrv->u.server.known_comms );

    /* If the server has no active mounts left, delete it too */

    if ( pNLsrv->u.server.known_disks == NULL )
    {
      pNLtmp = pNLsrv->next;
      DeleteFromList ( &ServerList, pNLsrv );
      pNLsrv = pNLtmp;
    }
    else
      pNLsrv = pNLsrv->next;
  }

}

/* Omni_ServiceCall() -----------------------------*/
void Omni_ServiceCall ( _kernel_swi_regs *R )
{
  switch ( R->r[0] )
  {
    case 0:  /* OmniFiler is starting up */
      Omni_Register();
      Lgn_Register();
      break;

    case 1: /* Filer is dying. We should do so too */
      Omni_Registered = false;
      OmniS_Suicide("LanManFS");
      break;

    default:
      break;
  }
}

/* Omni_AddInfo()----------------------------------*/
void Omni_AddInfo ( int flags, const char *serv_name, const char *string, const char *comment )
{
  NAMELIST *pNLsrv, **list;
  int tag = 0;

  pNLsrv = AddToList ( &ServerList, S_VALID_TAG, serv_name );
  if ( pNLsrv == NULL )  /* Couldn't add it */
    return;

  switch ( flags )
  {
    case OAI_SERVER:
      /* Amend information about server */
      if ( string != NULL )
        strcpyn ( pNLsrv->u.server.info_string, string, INFO_STR_LEN );
      return;

    case OAI_DISK:
      tag = (int)D_VALID_TAG;
      list = &pNLsrv->u.server.known_disks;
      break;

    case OAI_PRINTER:
      tag = (int)P_VALID_TAG;
      list = &pNLsrv->u.server.known_printers;
      break;

    case OAI_IPC:
      tag = (int)I_VALID_TAG;
      list = &pNLsrv->u.server.known_ipc;
      break;

    case OAI_DEVICE:
      tag = (int)C_VALID_TAG;
      list = &pNLsrv->u.server.known_comms;
      break;

    default:
      return;
  }

  AddToList ( list, tag, string );
  pNLsrv = FindInList(*list, string);
  if (pNLsrv != NULL) {
    if (comment != NULL) {
      strcpyn ( pNLsrv->u.share.info_string, comment, INFO_STR_LEN );
    }
    else {
      pNLsrv->u.share.info_string[0] = '\0';
    }
  }
}

/* Omni_DumpServers() -----------------------------*/
_kernel_oserror *Omni_DumpServers(void)
{
        err_t res;
        int token;
        const char *eptr;
        res = Omni_ListServers(0,0,0,&eptr,&token);
        if (res != OK) return MsgError(res);
        Omni_Debug();
        return NULL;
}

/* Omni_DumpSharesPrint() -------------------------*/
static void Omni_DumpSharesPrint(NAMELIST *pNL, const char *type)
{
  for (; pNL != NULL; pNL = pNL->next) {
    printf("  %-16s  %-10s  %s\n", pNL->name, type, pNL->u.share.info_string);
  }
}

/* Omni_DumpServersPrint() ------------------------*/
static void Omni_DumpServersPrint(NAMELIST *pNL)
{
  for (; pNL != NULL; pNL = pNL->next) {
    printf("  %-16s  %s\n", pNL->name, pNL->u.server.info_string);
  }
}

/* Omni_DumpShares() ------------------------------*/
_kernel_oserror *Omni_DumpShares(char *server_name)
{
        err_t res;
        int token;
        char heading[2+16/* Name */+2+10/* Type */+2+16/* Notes */+1/* Term */];
        char *score;
        const char *eptr;
        NAMELIST *pserv;

        /* Don't give a XXXX about getting the info back - just force the RPC
         * call to execute and stuff all the data into the data structures and
         * we'll go through the data structures ourselves, tvm.
         */
        res = Omni_ListMounts(0, 0, 0, 0, server_name, &eptr, &token);
        if (res != OK) return MsgError(res);

        pserv = FindInList(ServerList, server_name);
        if (pserv != NULL && pserv->tag == S_VALID_TAG) {
                /* Keep in sync with Omni_DumpSharesPrint() spacing */
                sprintf(heading, "  %s", MsgLookup("HdrShares"));
                printf("%s\n", heading);
                score = heading; /* Replace text with underscore */
                while (*score) {
                  if (*score != ' ') *score = '-';
                  score++;
                }
                printf("%s\n", heading);

                Omni_DumpSharesPrint(pserv->u.server.known_disks, MsgLookup("Type0"));
                Omni_DumpSharesPrint(pserv->u.server.known_printers, MsgLookup("Type1"));
                Omni_DumpSharesPrint(pserv->u.server.known_ipc, MsgLookup("Type3"));
                Omni_DumpSharesPrint(pserv->u.server.known_comms, MsgLookup("Type2"));

                /* Keep in sync with Omni_DumpServersPrint() spacing */
                sprintf(heading, "  %s", MsgLookup("HdrServrs"));
                printf("\n%s\n", heading);
                score = heading; /* Replace text with underscore */
                while (*score) {
                  if (*score != ' ') *score = '-';
                  score++;
                }
                printf("%s\n", heading);

                Omni_DumpServersPrint(ServerList);
        }
        return NULL;
}

/* Omni_Debug() -----------------------------------*/
static void showname ( NAMELIST *pNL )
{
  if ( pNL == NULL )
    printf("%s ", MsgLookup("NoUser"));
  else
    printf("'%s' ", pNL->name);
}

static void showlist ( NAMELIST *pNL )
{
  while (1)
  {
    showname( pNL ); /* Show something if pNL is NULL on entry */
    if (pNL == NULL) break;
    pNL = pNL->next;
    if (pNL == NULL) break;
  }
}

void Omni_Debug ( void )
{
  NAMELIST *pNL;
  char fmt[12];
  char temp[20];

  sprintf(fmt, "%%-%ds : %%s\n", strlen(MsgLookup("NameL")));

  printf(fmt, MsgLookup("NameH"), LM_Vars.machinename);
  printf(fmt, MsgLookup("NameD"), LM_Vars.drivername);
  sprintf(temp, "%d", LM_Vars.namemode);
  printf(fmt, MsgLookup("NameM"), temp);
  strcpy(temp, Omni_Registered ? MsgLookup("Start")
                               : MsgLookup("NotStart"));
  printf(fmt, MsgLookup("NameO"), temp);
  strcpy(temp, LM_Vars.logged_on ? LM_Vars.workgroup
                                 : MsgLookup("NotLogon"));  
  printf(fmt, MsgLookup("NameW"), temp);

  if ( LM_Vars.logged_on )
  {
    /* Extra info for a logged on domain */
    printf(fmt, MsgLookup("NameU"), LM_Vars.username);

    if ( Lgn_PrimaryDCName[0] != 0 )
    {
      printf(fmt, MsgLookup("NameP"), Lgn_PrimaryDCName);
    }

    strcpy(temp, MsgLookup("NoHome"));
    printf(fmt, MsgLookup("NamHD"), (Lgn_HomeDirName[0] != 0) ? Lgn_HomeShareName
                                                              : temp);
    if ( Lgn_HomeDirName[0] != 0 )
    {
      printf(fmt, MsgLookup("NamHS"), Lgn_HomeServerName);
      printf(fmt, MsgLookup("NamHP"), Lgn_HomeDirName);
    }
  }

  for ( pNL = ServerList; pNL != NULL; pNL = pNL->next )
  {
    printf("\n%s '%s': '%s'", MsgLookup("Serv"), pNL->name,
           pNL->u.server.info_string);
    printf("\n  %s : ", MsgLookup("Drvs"));
    showlist(pNL->u.server.known_disks);
    printf("\n  %s : ", MsgLookup("Prns"));
    showlist(pNL->u.server.known_printers);
  }
  if (ServerList != NULL) printf("\n");

  for ( pNL = MountsList; pNL != NULL; pNL = pNL->next )
  {
    printf("\n%s '%s': ", MsgLookup("Mnt"), pNL->name);
    showname( pNL->u.mount.diskname );
    printf("%s ", MsgLookup("On"));
    showname( pNL->u.mount.servername );
    printf("%s '%s'",
            MsgLookup("User"),
            SMB_GetConnInfo ( pNL->u.mount.smb_lettr, GCI_USER ) );
  }
  if (MountsList != NULL) printf("\n");

#ifdef DEBUG
  {
    int i;

    printf("\n");
    for ( i='A'; i <= 'Z'; i++ )
      if ( SMB_GetConnInfo(i, GCI_SERVER) != NULL )
      {
        printf("Connection %c: %s share on \\\\%s\\%s, user %s\n",
          i, SMB_GetConnInfo(i, GCI_SHARETYPE),
             SMB_GetConnInfo(i, GCI_SERVER),
             SMB_GetConnInfo(i, GCI_SHARE),
             SMB_GetConnInfo(i, GCI_USER) );
      }
  }
#endif

  if ( RPC_ErrorCount > 0 )
  {
    printf("\n%d %s\n", RPC_ErrorCount, MsgLookup("LocProb"));
    printf("%s - %s\n", MsgLookup("LocDesc"), RPC_DebugMsg);
  }
}
@


1.14
log
@Get version number from messages file
Also, rationalise the two Omni_RegisterClient calls to both use _swix since they're virtually the same function repeated twice.

Version 2.47. Tagged as 'LanManFS-2_47'
@
text
@a64 5
/* SWI definitions */

#define SWI_Free_Register 0x444C0
#define SWI_Free_Deregister 0x444C1

d1216 1
a1216 1
        R->r[0] = strlen(d);
d1333 1
a1333 1
    _kernel_swi ( SWI_Free_Register, &R, &R );
d1335 1
a1335 1
    _kernel_swi ( SWI_Free_Deregister, &R, &R );
@


1.13
log
@Internationalised
Unused LMFiler put in the attic.
As LanMan has historically put its resources into ThirdPart/OmniClient this component has no ROM resources phase - it still registers the resources at run time.

Version 2.40. Tagged as 'LanManFS-2_40'
@
text
@a1302 1
  _kernel_swi_regs R;
d1306 1
a1306 1
  strncpy( titlebar, MsgLookup("DispName"), sizeof(titlebar) );
d1309 1
a1309 1
                    Module_FullVersion " (" Module_ApplicationDate ")",
d1311 3
a1313 11
                                                   : MsgLookup("WhoBEUI") );

  R.r[0] = LanMan_OmniOp; /* Client ID */
  R.r[1] = RC_NEEDS_USERID | RC_NEEDS_PASSWD | RC_NEEDS_MOUNTPATH |
             RC_DOES_FILES | RC_EXTN_CHAR('.') |
             RC_DOES_PRINT | RC_NEEDS_PRINTPWD;
  R.r[2] = (int) "lmicon"; /* Sprite name - 12 max */
  R.r[3] = (int) titlebar;
  R.r[4] = (int) infobox;
  R.r[5] = 0; /* Site ID word. Ignore this! */
  R.r[6] = (int) FilingSystemName;
d1315 10
a1324 1
  if ( _kernel_swi( SWI_Omni_RegisterClient, &R, &R ) == NULL )
@


1.12
log
@Makefile recreated from fragments
Fixed up a couple of trivial warnings with the stricter checking.
Removed OmniS_FastMultiply64 and rewrote the function in C, this allows the compiler to spot and use UMULL on architectures supporting that instruction.
Tested in a RAM build against a WinXP SP3 server with a drive > 4GB.

Version 2.39. Tagged as 'LanManFS-2_39'
@
text
@d201 1
a201 1
                              char *name_in )
d242 1
a242 1
static NAMELIST *FindInList ( NAMELIST *ListHead, char *name_in )
d340 1
a340 1
  return Xlt_SetOSError( _kernel_swi ( XOS_Bit | OS_CLI, &R, &R ));
d381 1
a381 1
  e = Xlt_SetOSError(_swix(OS_File, _INR(0,1)|_OUT(0), 23, filename, &type));
d652 1
a652 1
              char * *pNextByte_out, int *pToken_out )
d713 1
a713 1
     char * *pNextByte_out, int *pToken_out )
d791 1
a791 1
    int token_in, char * *pNextByte_out, int *pToken_out )
d839 1
a839 1
    int token_in, char * *pNextByte_out, int *pToken_out )
d931 1
a931 1
  char *flags;
d976 2
a977 2
err_t Omni_GetMountInfo ( int mount_id, char **pServName,
     char **pUserName, char **pMountName, char **pMountPath, int *pServerID )
d1067 1
a1067 1
#define Rout_chr(a)  (char **)&(R->r[a])
d1188 1
a1188 1
  return Xlt_Error(res);
d1220 1
a1220 1
        sprintf ( d, "LanMan::%s", s );
d1232 1
a1232 1
          return Xlt_Error(EBADDRV);
d1234 1
a1234 1
        return Xlt_Error ( Omni_FreeSpace ( m_id,
d1267 1
a1267 1
          return Xlt_Error(EBADDRV);
d1269 1
a1269 1
        return Xlt_Error ( Omni_FreeSpace64 ( m_id,
d1280 1
a1280 1
  return Xlt_Error(EBADPARAM);
d1304 9
d1318 3
a1320 18

  R.r[2] = (int) "lmicon";
  R.r[3] = (int) "LAN Manager";

  /* Mild bodge, assumes things about Stats module */
  if ( Stat_ClassMask & SCLASS_IP )
  {
    R.r[4] = (int) "Lan Manager/TCPIP client\n"
                   "\xA9 Acorn Computers Ltd, 1997\n"
                   Module_FullVersion " ("Module_ApplicationDate")";
  }
  else
  {
    R.r[4] = (int) "Lan Manager/NetBEUI client\n"
                   "\xA9 Acorn Computers Ltd, 1997\n"
                   Module_FullVersion " ("Module_ApplicationDate")";
  }

d1457 1
a1457 1
void Omni_AddInfo ( int flags, char *serv_name, char *string, char *comment )
d1515 1
a1515 1
        char *eptr;
d1517 1
a1517 1
        if (res != OK) return Xlt_Error(res);
d1526 1
a1526 1
    printf("  %-16s  %-10s %s\n", pNL->name, type, pNL->u.share.info_string);
d1543 3
a1545 1
        char *eptr;
d1553 1
a1553 1
        if (res != OK) return Xlt_Error(res);
d1557 24
a1580 6
                printf("  Sharename         Type       Comment\n"
                       "  ---------         ----       -------\n\n");
                Omni_DumpSharesPrint(pserv->u.server.known_disks, "Disk");
                Omni_DumpSharesPrint(pserv->u.server.known_printers, "Printer");
                Omni_DumpSharesPrint(pserv->u.server.known_ipc, "IPC");
                Omni_DumpSharesPrint(pserv->u.server.known_comms, "Comms");
a1581 2
                printf("\n  Server            Comment\n"
                         "  ------            -------\n");
d1591 1
a1591 1
    printf("(none) ");
d1598 1
a1598 3
  if ( pNL == NULL ) printf("(none) ");

  while ( pNL != NULL )
d1600 2
a1601 1
    printf("'%s' ", pNL->name);
d1603 1
d1610 2
d1613 12
a1624 6
  printf("Machine name : %s\n"
         "Driver name  : %s\n"
         "OmniClient   : %sstarted\n",
         LM_Vars.machinename,
         LM_Vars.drivername,
         Omni_Registered ? "" : "not " );
d1628 2
a1629 4
    printf( "Logged on to workgroup/domain '%s' as user '%s'\n",
            LM_Vars.workgroup,
            LM_Vars.username
          );
d1632 3
a1634 1
      printf("Primary DC is %s\n", Lgn_PrimaryDCName );
d1636 3
d1641 2
a1642 2
      printf("Home directory is '%s' on '%s', path %s\n",
        Lgn_HomeShareName, Lgn_HomeServerName, Lgn_HomeDirName );
a1643 2
    else
      printf("No home directory set\n");
a1644 4
  else
    printf("Not logged on\n");

  printf("Name mode %d\n", LM_Vars.namemode );
d1648 3
a1650 2
    printf("\nServer '%s': '%s'\n  Drives   : ", pNL->name,
           pNL->u.server.info_string );
d1652 1
a1652 1
    printf("\n  Printers : ");
d1655 1
a1655 2

  if (ServerList != NULL) printf("\n\n");
d1659 1
a1659 1
    printf("Mount '%s': ", pNL->name);
d1661 1
a1661 1
    printf("on ");
d1663 2
a1664 1
    printf("user '%s'\n",
d1667 1
a1667 1

d1687 4
a1690 3
    printf("\n%d error(s) locating network resources:\nLast error - %s\n",
       RPC_ErrorCount,  RPC_DebugMsg );

@


1.11
log
@Fix for renames where only the case has changed.
Detail:
 Added an extra check after the Xlate path resolution code so that
 the case of the path given to resolve is honoured. This now means that
 the strcmp() done in SMB_Rename fails and the rename is actually sent to
 the server. Before "*rename test Test" would have the path resolved and
 since 'test' already existed both names would be the same, in this example
 something like "*rename A:\test A:\test" would result.
Admin:
 Made the non LONGNAMES version compile again (not tested).
 Removed local definitions of FSControl reason codes, uses Interface header
 now.
 Made the case of #includes match CVS to allow future compilation on a case
 sensitive system.
 Deleted unused "Version" header.

Version 2.34. Tagged as 'LanManFS-2_34'
@
text
@d584 1
a584 1
       fspc_64 *freespace_out, fspc_64 *usedspace_out, fspc_64 *totspace_out )
d588 2
a589 1

d594 6
a599 6
  /* OmniS_FastMultiply64 does a 32x32 bit multiply and stores the 64-bit
   * result in the supplied pointer (1st param)
   */
  OmniS_FastMultiply64(freespace_out, DSR.freeblks, DSR.blksize);
  OmniS_FastMultiply64(totspace_out, DSR.totalblks, DSR.blksize);
  OmniS_FastMultiply64(usedspace_out, DSR.totalblks - DSR.freeblks, DSR.blksize);
a600 1
  *success = 0;
d1271 3
a1273 3
           (fspc_64 *)(R->r[2]+8)  /* freespace_out */,
           (fspc_64 *)(R->r[2]+16) /* usedspace_out */,
           (fspc_64 *)(R->r[2])    /* totspace_out */ ) );
@


1.10
log
@Workaround for NTFS returning resume keys of zero.
Detail:
  When the underlying FS is NTFS, eg. WinXP Pro, the requested
  resume keys for a directory search are always zero - this is passed
  back via OSGBPB and on the next call it triggers a new search. So
  we get stuck in an infinite loop.
  Now checks for a resume key stuck at zero, and makes a fake one static
  to the search context then sets the continuation bit in the SMB_FIND_NEXT
  call because the server returning the duff key remembers the position.
  Dir_CallbackFn could return with "taken" undefined. Move a few lines
  higher.
  Missing "#else" added to CHECK_ARMBOOT_EXISTS so if this is disabled
  no further attempt is made to find !ArmBoot.
  Couple of typos corrected.
  Spelling of "disk" changed to "disc" in an error message.
Admin:
  Tested with XP Pro SP3 with NTFS, directories which previously hung
  the filer now open correctly. Checked with XP Home SP3 with FAT32 to
  verify behaviour unchanged from 2.32.
  Note, with large directories the initial path translation triggers a
  dir search too which takes ages compared with the actual number of
  entries returned. This could be cached to make counting far faster.

Version 2.33. Tagged as 'LanManFS-2_33'
@
text
@d50 4
a53 4
#include "smb.h"
#include "rpc.h"
#include "lanman.h"
#include "printers.h"
d55 5
a59 6
#include "xlate.h"
#include "lmvars.h"
#include "stats.h"
#include "logon.h"

#include "omni.h"
@


1.9
log
@  Multiple fixes.
Detail:
  Too many to list here: see doc/RPSChanges.
Admin:
  Received from Rob Sprowson approx 2009-02-08. Builds, but not tested by ROOL.

Version 2.32. Tagged as 'LanManFS-2_32'
@
text
@d411 2
@


1.8
log
@  Changes from John.
Detail:
  > Default filetype now text
  >
  > Default type given to any file that has neither a dos extent, nor a
  > ',xxx' riscos extent at the server
  >
  > Ensure that files given the default type never have a ',xxx' riscos
  > extent appended.
  >
  > Add environment variable 'LMDefaultType' which checked for a default
  > type on module initialisation .. thus setting this to (e.g.) dos, then
  > rmreinitting LanManFS will change the default type to (e.g.) dos.
Admin:
  Not tested here yet.

Version 2.29. Tagged as 'LanManFS-2_29'
@
text
@d54 1
a54 1
#include "version.h"
a92 1

a101 2
/* ------------------------ */

a102 1

a117 1

a133 3

/* ------------------------------------- */

d136 3
d140 1
a140 8
/* Name-list functions ***************************** */

/* This adds a given name to a list, and returns a pointer to
   the item. If an item of the same name already exists on
   the list, no allocation is performed; the existing item
   is returned. New allocations have all their 'extra_info'
   fields set to zero.
*/
d171 1
a171 2
/* ----------------------- */

a175 1

d194 7
a200 2
/* =========================================== */

d242 1
a242 2
/* ------------------ */

d264 1
a264 2
/* ------------------------- */

a288 3



d291 2
a292 9
static NAMELIST *MountsList = NULL; /* Current mounts */
static NAMELIST *ServerList = NULL; /* Known servers (known disks/printers
                                hang off the side of this list) */

/* ---------------------------- */

/* FindActiveMount()

   Given a disk (D_VALID_TAG) record, finds out if it is the current
a296 1

d308 1
a308 3

/* ---------------------------- */

d321 2
a322 1
/* ---------------------------- */
d324 1
a328 4

static char work_buf[80];
static char name_buf[NAME_LIMIT+16];

d344 1
a344 2
/* ------------------------------------ */

d363 2
a365 1

d372 2
a373 4
   MAX_DRIVES) */

static int ReentryCount = 0;

a413 1

d438 2
a439 1
/* Omni_MountServer makes a connection to a server; --------
a441 1

d521 2
a522 2
/* Omni_DismountServer does XXXX_OmniOp 1 ------------ */

d538 2
a539 2
/* Omni_FreeSpace does XXXX_OmniOp 2 ------------------- */

a544 2
/* ------------------ */

d580 2
a581 4
typedef struct fspc_64  {
        unsigned lo, hi;
} fspc_64;

d603 1
a603 3

/* Subroutines to help enumeration routines ----------------------- */

d648 2
a649 2
/* Omni_ListServers does XXXX_OmniOp 3 -------------------------- */

d707 2
a708 2
/* Omni_ListMounts does XXXX_OmniOp 4 -------------------------- */

d787 2
a788 3

/* Omni_ListActiveMounts does XXXX_OmniOp 5 -------------------------- */

d835 2
a836 2
/* Omni_ListPrinters does XXXX_OmniOp 16 -------------------------- */

d902 2
a903 4
/* Omni_OpenRoot () -------------------

  Triggers a filer_opendir on the root directory for a given mount
*/
d910 2
a911 5
/* Omni_OpenUserRoot () -------------------

  Triggers a filer_opendir on the user's home directory for a given mount
*/

d917 2
a918 3
/* Omni_GetNewMountInfo() -------------------

   Works out whether a new password or userID will be needed for
a925 1

a926 2


d973 2
a974 6
/* Omni_GetMountInfo() ----------------------

   Gets info about an existing mount.

*/

d996 1
a996 10
/* -------------------- */

static err_t Omni_NotDoneYet(void)
{
  return ENOTPRESENT;
}

/* Exported functions ========================================== */

bool Omni_Registered = false;
d998 1
a998 1
/* Omni_GetDrvLetter() ----------------------------------
d1000 4
a1003 3
  Gets an SMB drive letter given a mount name.
  Returns 0 if not found. 'Name' should be not contain
  spaces or invalid chars, otherwise it won't be found.
a1004 1

d1016 1
a1016 2
/* Omni_GetMountID () --------------- */

a1018 1

d1027 2
a1028 5
/* Omni_GetDefaultType() ---------------

   Attempts to ask OmniFiler for the type for a given file name.
*/

d1055 2
a1056 6
/* OmniOp_SWI() ---------------------------

   Provides the LanMan_OmniOp SWI handler.

*/

d1182 1
d1184 1
a1184 1
      res = Omni_NotDoneYet();
d1190 2
a1191 3
/* Omni_FreeOp_SWI() --------------------------------------

   This is not strictly OmniClient. Instead it is for use by
a1193 1

a1194 3

static char logstring[200];

d1282 5
a1286 2
/* ----------------------------------------------- */

a1288 4
  /* This is called after *Commands or other actions which
     might change the available mounts or network information.
     It basically calls Omni_EnumerateMounts.
  */
d1299 1
a1299 2
/* =============================================== */

d1317 1
a1317 1
                   VERSION_STRING;
d1323 1
a1323 1
                   VERSION_STRING;
d1333 1
a1333 2
/* ---------------------------------------- */

d1348 2
a1349 3
/* Omni_StartUp() -------------------------

   Attempts to register us with OmniFiler and the
a1351 1

d1360 1
a1360 2
/* ------------------------- */

a1361 1

a1364 1

d1387 1
a1387 2
/* Omni_ClearLists() --------------------------------- */

a1390 1

d1441 1
a1441 2
/* Omni_ServiceCall() -------------------------------- */

d1461 1
a1461 24
/* Omni_Debug() ------------------------------------- */

static void showname ( NAMELIST *pNL )
{
  if ( pNL == NULL )
    printf("(none) ");
  else
    printf("'%s' ", pNL->name);
}

static void showlist ( NAMELIST *pNL )
{
  if ( pNL == NULL ) printf("(none) ");

  while ( pNL != NULL )
  {
    printf("'%s' ", pNL->name);
    pNL = pNL->next;
  }
}


/* ------------------------------ */

d1515 1
d1527 1
d1535 1
d1543 1
d1551 4
a1554 4
	/* Don't give a XXXX about getting the info back - just force the RPC
	 * call to execute and stuff all the data into the data structures and
	 * we'll go through the data structures ourselves, tvm.
	 */
d1574 19
a1592 1
/* ------------------- */
@


1.7
log
@Tightened up checking of when sockets get opened and closed in an
attempt to work out why Freeway gets upset when LanManFS is
configured in IP mode.
Changed app date that OmniClient shows to be dd-mmm-yy
Added ability to include slimmer ROMSPRITES and deleted the resources
phase from the makefile: the sprites were being included once in
ResourceFS and again embedded in the module.
If the FS is unset it says so in *status rather than a blank line.

Version 2.26. Tagged as 'LanManFS-2_26'
@
text
@d359 1
a359 1
  NAMELIST *pNL = Validate(mount_id, M_VALID_TAG);
d491 1
a491 1
  pNLmount = AddToList ( &MountsList, M_VALID_TAG, namebuf );
d527 1
a527 1
      AddToList ( &pNLsrv->u.server.known_disks, D_VALID_TAG, mountpath );
d554 1
a554 1
  NAMELIST *pNL = Validate(mount_id, M_VALID_TAG);
d579 1
a579 1
  NAMELIST *pNL = Validate(mount_id, M_VALID_TAG);
d763 1
a763 1
    pNLdisk = Validate(token_in, D_VALID_TAG);
d840 1
a840 1
    pNL = Validate(token_in, M_VALID_TAG);
d894 1
a894 1
    pNLstart = Validate ( token_in, P_VALID_TAG );
d1028 1
a1028 1
  NAMELIST *pNL = Validate(mount_id, M_VALID_TAG);
@


1.6
log
@LanmanFS help syntax corrected and tidied
Change lmls command to ListFS in line with NFS
Supress LF when ListFS is issued but there are no servers present.
Cast a few things to shut some compiler warnings up.
Addition of MimeMap lookups where the file has no ",ttt" style type
appended.Previously any such files were all reported as text files so
viewing a machine would typically show whole directories full of
identical filetypes.

Version 2.23. Tagged as 'LanManFS-2_23'
@
text
@d1681 3
a1683 5
  printf("LanManFS version " VERSION_STRING
         "\nOmniClient %sstarted\n"
            "Machine name    : %s\n"
            "Driver name     : %s\n",
         Omni_Registered ? "" : "not ",
d1685 2
a1686 1
         LM_Vars.drivername );
@


1.5
log
@  New build option to exclude NetBEUI support.
Detail:
  Pass OPTIONS=-DNO_NETBEUI from the Components file if you do not need
    NetBEUI support, and LanManFS will be 12K smaller.
  In NetBEUI mode, LanManFS sends Service_DCIProtocolStatus as required.
  In IP mode, LanManFS notices Service_DCIProtocolStatus from the Internet
    module when it dies and marks all its sockets as needing reconnection.
  Booting behaviour changed to look for !ArmBoot again and not attempt
    the boot if it is missing.  Removed lots of grotty backdoor hacks
    that used to be used to determine this.
Admin:
  Not tested at all.  This will need very thorough testing before it can
    be considered for release.

Version 2.14. Tagged as 'LanManFS-2_14'
@
text
@d1585 1
a1585 1
      tag = D_VALID_TAG;
d1590 1
a1590 1
      tag = P_VALID_TAG;
d1595 1
a1595 1
      tag = I_VALID_TAG;
d1600 1
a1600 1
      tag = C_VALID_TAG;
d1720 2
a1721 1
  printf("\n\n");
a1754 1
  printf("\n");
@


1.4
log
@  Fixed use of uninitialised pointer.
  Now doesn't require that the !ArmBoot object is a directory
Detail:
  The code in Omni.c was carefully checking that !ARMBOOT existed
    before attempting to run the boot file.  Unfortunately, it was
    using a method which bypassed the filename resolution (that does
    the ,xxx filetype name mapping), so it did not find the new Obey
    file in the 400 series baseline.  The check has been removed.
  The code in SMB.c was being caught out on an uninitialised variable
    usage when the attribute cache already held details of the object
    being sought.  The variable would have been initialised on a non-
    cached lookup, but the special case of booting a machine via LanManFS
    manages to get a cached lookup without having run through the routine
    before, resulting in a strcpy() with a destination of 0.
Admin:
  Tested on Risc PC.
  Fixes fault 1511 (STB-400 Generic)

Version 2.11. Tagged as 'LanManFS-2_11'
@
text
@d403 1
a403 1
static err_t BootMount_check_file ( char drive )
d405 10
a414 4
  DOS_ATTRIBS dummy;

  sprintf ( work_buf, "%c\\!ARMBOOT", drive );
  return SMB_GetAttribs ( work_buf, &dummy );
d425 3
a427 7
  if (1) {
    int key;
    (void) _swix(OS_Byte, _INR(0,2)|_OUT(1), 129, 255, 255, &key);
    if (key == 255) {
       /* SHIFT was depressed */
       return OK;
    }
d437 1
a437 2
  /* Only works if !ARMBOOT is a directory! */
  if (BootMount_check_file(pNLmount->u.mount.smb_lettr) != OK)
@


1.3
log
@  New *LMLS command.
  Fix for ./.. files in short filename shares.
  Long multiply now provided in assembler.
Detail:
  *LMLS is a new filesystem-specific command which performs the same
    task as "smbclient -L" does under UNIX - ie. listing all the shares
    available on the specified host.
  When enumerating the shares on a remote server, LanManFS now remembers
    all the printers, IPC, device and disc shares (for *LMLS to output).
  The 32x32->64 multiply routine is now provided in assembler instead of
    the previous huge amount of obscure C taken from NSPRLib.  This is
    more understandable (and almost certainly far smaller and quicker
    and doesn't need a hack to stop the compiler mis-optimising it!)
  Old short filename shares still had problems with the . and .. file
    filtering.  Programmer fault there - should've let the compiler do
    the optimisations :-)
  Server info string fixed to byte-reverse the port numbers when printing
    the string into the info buffer.  Now claims to be talking to port 139
    as it should.
Admin:
  Tested in general desktop use for several days, plus experimental versions
    tested in other boot ROMs.

Version 2.03. Tagged as 'LanManFS-2_03'
@
text
@d402 10
a414 1
  DOS_ATTRIBS dummy;
a427 1
  sprintf ( work_buf, "%c\\!ARMBOOT", pNLmount->u.mount.smb_lettr );
d434 3
a436 1
  if ( SMB_GetAttribs ( work_buf, &dummy ) != OK )
d438 1
@


1.2
log
@  Support for long filename.
  Support for spaces in machine names.
  Merge of sbrodie_LanManFS_dev branch to trunk.
Detail:
  LanManFS 2.00 supports the "NT LM 0.12" protocol, enabling it to
    use long filenames on mounted shares.
Admin:
  Supporting documentation:
    1215,256/FS: LanManFS Software Functional Specification.
  Same as LanManFS-1_87_1_1_1_1_2_13.

Version 2.00. Tagged as 'LanManFS-2_00'
@
text
@d63 1
a63 1
#define INFO_STR_LEN 32
d85 4
d98 2
d115 6
d133 1
a602 56
/* Multiply macro taken from NSPRLib */
#define LL_MUL(r, a, b) { \
    fspc_64 _a, _b; \
    _a = a; _b = b; \
    LL_MUL32(r, _a.lo, _b.lo); \
    (r).hi += _a.hi * _b.lo + _a.lo * _b.hi; \
}

#define PR_BIT(n)       ((unsigned)1 << (n))
#define PR_BITMASK(n)   (PR_BIT(n) - 1)

#define _lo16(a)        ((a) & PR_BITMASK(16))
#define _hi16(a)        ((a) >> 16)

#define LL_MUL32(r, a, b) { \
     unsigned _a1, _a0, _b1, _b0, _y0, _y1, _y2, _y3; \
     _a1 = _hi16(a), _a0 = _lo16(a); \
     _b1 = _hi16(b), _b0 = _lo16(b); \
     _y0 = _a0 * _b0; \
     _y1 = _a0 * _b1; \
     _y2 = _a1 * _b0; \
     _y3 = _a1 * _b1; \
     _y1 += _hi16(_y0);                         /* can't carry */ \
     _y1 += _y2;                                /* might carry */ \
     if (_y1 < _y2)    \
        _y3 += (unsigned)(PR_BIT(16));  /* propagate */ \
     (r).lo = (_lo16(_y1) << 16) + _lo16(_y0); \
     (r).hi = _y3 + _hi16(_y1); \
}

#ifdef __CC_NORCROFT
/* No way of checking version number though.
 * Version 5.11 of the compiler should be OK because I fixed this bug
 * in that version [sbrodie]
 */
static void _Omni_ForceCSESync(void) {}
#else
#  define _Omni_ForceCSESync() ((void)0)
#endif

#ifdef __CC_NORCROFT
/* May as well optimise this a bit */
__value_in_regs
#endif
static fspc_64 Omni_Multiply64(uint plo1, uint plo2)
{
        fspc_64 p1, p2, res;
        p1.hi = p2.hi = 0;
        p1.lo = plo1;
        p2.lo = plo2;
        _Omni_ForceCSESync();
        LL_MUL(res, p1, p2);
        _Omni_ForceCSESync();
        return res;
}

d613 6
a618 3
  *freespace_out = Omni_Multiply64(DSR.freeblks, DSR.blksize);
  *totspace_out = Omni_Multiply64(DSR.totalblks, DSR.blksize);
  *usedspace_out = Omni_Multiply64(DSR.totalblks - DSR.freeblks, DSR.blksize);
d1488 8
d1555 1
a1555 1
void Omni_AddInfo ( int flags, char *serv_name, char *string )
d1557 2
a1558 1
  NAMELIST *pNLsrv;
d1570 1
a1570 1
      break;
d1573 2
a1574 2
      AddToList ( &(pNLsrv->u.server.known_disks),
                                                D_VALID_TAG, string);
d1578 12
a1589 2
      AddToList ( &(pNLsrv->u.server.known_printers),
                                                P_VALID_TAG, string );
d1591 14
d1608 54
@


1.1
log
@Initial revision
@
text
@d61 1
a61 1

d397 9
d408 4
d455 4
d485 3
d551 11
a567 4
  NAMELIST *pNL = Validate(mount_id, M_VALID_TAG);

  if ( pNL == NULL )
    return EBADPARAM;
d569 1
a569 1
  res = SMB_GetFreeSpace ( pNL->u.mount.smb_lettr, &DSR );
d586 78
d1131 1
a1131 1
  R.r[0] = SWI_LanMan_OmniOp; /* Client ID */
d1357 17
d1393 1
a1393 1
    R.r[0] = SWI_LanMan_OmniOp; /* Client ID */
d1405 1
a1405 1
  R.r[0] = SWI_LanMan_OmniOp; /* Client ID */
d1486 1
a1486 1
    R.r[0] = SWI_LanMan_OmniOp;
@


1.1.1.1
log
@
LanManFS moved into Omni subdirectory.  Previous version in
RiscOS/Sources/Networking/LanManFS is now locked out.

The rest of Omni will be imported at a later date.

Version 1.87, tagged as LanManFS-1_87

@
text
@@


1.1.1.1.2.1
log
@  Check-in of all files comprising this development build of LanManFS
  Spaces in NetBIOS names are now allowed.
Detail:
  Now supports NetBIOS hostnames which contain spaces.  Use hardspaces
    in the Omni frontend or at the command-line (unless you can get
    away with a normal space without confusing the CLI parser)
Admin:
  Tested by attempting to connect to machines with spaces in their
    names.  Got the expected response from the target machine, so
    this aspect is working.
  It appears that several files did not get checked in due to datestamp
    problems when LanManFS's location in CVS was changed.  This is now
    fixed.

Version 1.87, 1.1.1.1.2.7. Tagged as 'LanManFS-1_87-1_1_1_1_2_7'
@
text
@d61 1
a61 1
#include "LanMan_MH.h"
d1026 1
a1026 1
  R.r[0] = LanMan_OmniOp; /* Client ID */
d1271 1
a1271 1
    R.r[0] = LanMan_OmniOp; /* Client ID */
d1283 1
a1283 1
  R.r[0] = LanMan_OmniOp; /* Client ID */
d1364 1
a1364 1
    R.r[0] = LanMan_OmniOp;
@


1.1.1.1.2.2
log
@  Boot behaviour fixes.
  More debug added.
Detail:
  Trapped Service_InternetStatus reason code 0 as a tipoff to try
    to continue a pending boot operation.  Internet module is not
    sending the expected reason code 2 to indicate that the interface
    has come up when it is also having its address changed.
  Holding down SHIFT when a new connection is made prevents execution
    of !ArmBoot on the newly connected share.
  Several more debug statements added to track progress through the
    booting.
  IPConfig's internal logging system imported.  *LanMan:Free shows
    the contents of the log.
  Free space information still seems to be broken against Windows 95/98.
    Works against NT4SP4 though.
  *Free filesystem-specific command added.
Admin:
  This version managed to boot an STB22 from our NT4 server which
    was supplying it with baseline 303.
  *LanMan:Free is not yet implemented and in debug builds, shows
     the debug log instead.
  Anti-idleout work still pending.

Version 1.87, 1.1.1.1.2.11. Tagged as 'LanManFS-1_87-1_1_1_1_2_11'
@
text
@a396 9
  if (1) {
    int key;
    (void) _swix(OS_Byte, _INR(0,2)|_OUT(1), 129, 255, 255, &key);
    if (key == 255) {
       /* SHIFT was depressed */
       return OK;
    }
  }

a398 4
#ifdef TRACE
  debug1("BootMount looking for %s\n", work_buf);
#endif

a441 4
#ifdef TRACE
  debug3("Omni_MountServer: %p %p %p\n", mountname, servname, mountpath);
#endif

a467 3
#ifdef TRACE
    debug0("SMB_CreateShare failed\n");
#endif
@


1.1.1.1.2.3
log
@  Free space now 64-bit aware plus *-command implemented.
  Anti-idleout measures implemented.
  Boot behaviour sanitised.
Detail:
  Free space code now knows about 64-bit versions of the various
    calls that can be made to it (OS_FSControl and Free module's i/f)
  *Free implemented.
  CallEvery set up to periodically ping each share to stop buggy
    Microsoft servers going to sleep on it.
  The filesystem does not get deregistered from FileSwitch whenever
    any interface on the machine changes(!)   More subtle changes
    are still required to finalise things in this area though.
Admin:
  Requires TCPIPLibs 5.06 or later
    (CVS: RiscOS/Sources/Libs/TCPIPLibs  tag: TCPIPLibs-5_06)
  Tested by booting an STB22 against an NT4SP4 machine.

Version 1.87, 1.1.1.1.2.12. Tagged as 'LanManFS-1_87-1_1_1_1_2_12'
@
text
@a550 11
static err_t Omni_DetermineFreeSpace ( int mount_id,
       struct disk_size_response *DSR)
{
  NAMELIST *pNL = Validate(mount_id, M_VALID_TAG);

  if ( pNL == NULL )
    return EBADPARAM;

  return SMB_GetFreeSpace ( pNL->u.mount.smb_lettr, DSR );
}

d557 1
d559 4
a562 1
  res = Omni_DetermineFreeSpace ( mount_id, &DSR );
a578 78
typedef struct fspc_64  {
        unsigned lo, hi;
} fspc_64;

/* Multiply macro taken from NSPRLib */
#define LL_MUL(r, a, b) { \
    fspc_64 _a, _b; \
    _a = a; _b = b; \
    LL_MUL32(r, _a.lo, _b.lo); \
    (r).hi += _a.hi * _b.lo + _a.lo * _b.hi; \
}

#define PR_BIT(n)       ((unsigned)1 << (n))
#define PR_BITMASK(n)   (PR_BIT(n) - 1)

#define _lo16(a)        ((a) & PR_BITMASK(16))
#define _hi16(a)        ((a) >> 16)

#define LL_MUL32(r, a, b) { \
     unsigned _a1, _a0, _b1, _b0, _y0, _y1, _y2, _y3; \
     _a1 = _hi16(a), _a0 = _lo16(a); \
     _b1 = _hi16(b), _b0 = _lo16(b); \
     _y0 = _a0 * _b0; \
     _y1 = _a0 * _b1; \
     _y2 = _a1 * _b0; \
     _y3 = _a1 * _b1; \
     _y1 += _hi16(_y0);                         /* can't carry */ \
     _y1 += _y2;                                /* might carry */ \
     if (_y1 < _y2)    \
        _y3 += (unsigned)(PR_BIT(16));  /* propagate */ \
     (r).lo = (_lo16(_y1) << 16) + _lo16(_y0); \
     (r).hi = _y3 + _hi16(_y1); \
}

#ifdef __CC_NORCROFT
/* No way of checking version number though.
 * Version 5.11 of the compiler should be OK because I fixed this bug
 * in that version [sbrodie]
 */
static void _Omni_ForceCSESync(void) {}
#else
#  define _Omni_ForceCSESync() ((void)0)
#endif

#ifdef __CC_NORCROFT
/* May as well optimise this a bit */
__value_in_regs
#endif
static fspc_64 Omni_Multiply64(uint plo1, uint plo2)
{
        fspc_64 p1, p2, res;
        p1.hi = p2.hi = 0;
        p1.lo = plo1;
        p2.lo = plo2;
        _Omni_ForceCSESync();
        LL_MUL(res, p1, p2);
        _Omni_ForceCSESync();
        return res;
}

static err_t Omni_FreeSpace64 ( int mount_id, int *success,
       fspc_64 *freespace_out, fspc_64 *usedspace_out, fspc_64 *totspace_out )
{
  struct disk_size_response DSR;
  err_t res;

  res = Omni_DetermineFreeSpace ( mount_id, &DSR );
  if ( res != OK )
    return res;

  *freespace_out = Omni_Multiply64(DSR.freeblks, DSR.blksize);
  *totspace_out = Omni_Multiply64(DSR.totalblks, DSR.blksize);
  *usedspace_out = Omni_Multiply64(DSR.totalblks - DSR.freeblks, DSR.blksize);

  *success = 0;
  return OK;
}

a1269 17
      }

    case 4:   /* Get free space on device (64 bit) */
      /* R->r[3] on entry points to a device name.
         Methinks this is the same as returned from
         case 1 */
      /* This code can be entered directly by Cmd_FREE */
      {
        int m_id = Omni_GetMountID ( ExtractName( (char *)(R->r[3]) ));
        if ( m_id == 0 )
          return Xlt_Error(EBADDRV);

        return Xlt_Error ( Omni_FreeSpace64 ( m_id,
           (int *)&(R->r[0]),       /* zero it on success */
           (fspc_64 *)(R->r[2]+8)  /* freespace_out */,
           (fspc_64 *)(R->r[2]+16) /* usedspace_out */,
           (fspc_64 *)(R->r[2])    /* totspace_out */ ) );
@

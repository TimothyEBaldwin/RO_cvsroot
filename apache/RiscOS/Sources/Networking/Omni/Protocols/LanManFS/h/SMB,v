head	1.6;
access;
symbols
	LanManFS-2_62:1.6
	LanManFS-2_61:1.6
	LanManFS-2_60:1.6
	LanManFS-2_59:1.6
	LanManFS-2_58:1.6
	LanManFS-2_57:1.6
	LanManFS-2_56:1.6
	LanManFS-2_55:1.6
	LanManFS-2_54:1.6
	LanManFS-2_53:1.6
	LanManFS-2_52:1.6
	LanManFS-2_51:1.6
	LanManFS-2_50:1.6
	LanManFS-2_49:1.6
	LanManFS-2_48:1.6
	LanManFS-2_47:1.6
	LanManFS-2_46:1.6
	LanManFS-2_45:1.6
	LanManFS-2_44:1.6
	LanManFS-2_43:1.6
	LanManFS-2_42:1.6
	LanManFS-2_41:1.6
	LanManFS-2_40:1.6
	LanManFS-2_39:1.5
	LanManFS-2_38:1.5
	LanManFS-2_37:1.4
	LanManFS-2_36:1.4
	LanManFS-2_35:1.4
	LanManFS-2_34:1.4
	LanManFS-2_33:1.4
	LanManFS-2_32:1.4
	LanManFS-2_31:1.3
	RO_5_07:1.3
	LanManFS-2_30:1.3
	LanManFS-2_29:1.3
	LanManFS-2_28:1.3
	LanManFS-2_27:1.3
	LanManFS-2_26:1.3
	LanManFS-2_25:1.3
	LanManFS-2_24:1.3
	LanManFS-2_23:1.3
	LanManFS-2_22:1.3
	LanManFS-2_21:1.3
	LanManFS-2_20:1.3
	LanManFS-2_19:1.3
	LanManFS-2_18:1.3
	LanManFS-2_17:1.3
	LanManFS-2_16:1.3
	LanManFS-2_15:1.3
	LanManFS-2_14:1.3
	LanManFS-2_13:1.3
	LanManFS-2_12:1.3
	LanManFS-2_11:1.3
	LanManFS-2_10:1.3
	LanManFS-2_09:1.3
	LanManFS-2_08:1.3
	LanManFS-2_07:1.3
	LanManFS-2_06:1.3
	LanManFS-2_05:1.3
	LanManFS-2_04:1.3
	LanManFS-2_03:1.2
	LanManFS-2_02:1.2
	LanManFS-2_01:1.2
	LanManFS-2_00:1.2
	LanManFS-1_87-1_1_1_1_2_13:1.1.1.1.2.4
	LanManFS-1_87-1_1_1_1_2_12:1.1.1.1.2.4
	LanManFS-1_87-1_1_1_1_2_11:1.1.1.1.2.3
	LanManFS-1_87-1_1_1_1_2_10:1.1.1.1.2.3
	LanManFS-1_87-1_1_1_1_2_9:1.1.1.1.2.3
	LanManFS-1_87-1_1_1_1_2_8:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_7:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_6:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_5:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_4:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_3:1.1.1.1.2.2
	LanManFS-1_87-1_1_1_1_2_2:1.1.1.1.2.1
	LanManFS-1_87-1_1_1_1_2_1:1.1.1.1
	sbrodie_LanManFS_dev:1.1.1.1.0.2
	sbrodie_LanManFS_dev_bp:1.1.1.1
	LanManFS-1_87:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2013.10.03.07.27.13;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	iTaBDwF1woaPMO7x;

1.5
date	2012.11.11.20.43.20;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	3D5DE5lr2isCFZrw;

1.4
date	2009.04.15.16.00.08;	author bavison;	state Exp;
branches;
next	1.3;
commitid	GhZBwZ2GN8lg58Kt;

1.3
date	99.03.09.15.07.39;	author sbrodie;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.12.52.31;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	98.12.03.13.54.47;	author sbrodie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.12.03.13.54.47;	author sbrodie;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	98.12.11.17.26.31;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	98.12.14.14.57.38;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.02.03.12.51.43;	author sbrodie;	state Exp;
branches;
next	1.1.1.1.2.4;

1.1.1.1.2.4
date	99.02.12.17.18.25;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Internationalised
Unused LMFiler put in the attic.
As LanMan has historically put its resources into ThirdPart/OmniClient this component has no ROM resources phase - it still registers the resources at run time.

Version 2.40. Tagged as 'LanManFS-2_40'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
*
*  SMB.H  -- Header for SMB functions
*
*  26-02-94 INH  Original
*
*
*/

#define DIRENTRY_SIZE 22

typedef err_t (*ENUM_DIR_FN) ( BYTE *entry, int format, bool *taken, void *private );

struct disk_size_response
{
  uint blksize;
  uint freeblks;
  uint totalblks;
};

#define MODE_RD   0x20  /* Read, deny write to others */
#define MODE_WR   0x11  /* Write, deny read/write to others */
#define MODE_RDWR 0x12  /* Read/Write, deny read/write to others */

#ifdef LONGNAMES
/* Note.  As per the June 19 1990 document (doc vsn 1.11, prot vsn 3.0),
 * the maximum value for this needs to be 4 + (maximum route name length
 * + 2)/2 for the TRANSACT2_FSCTL call (6.0.1.1.10, page 41).  However,
 * TRANSACT2_IOCTL needs this to be 4 too, so it is left at four for the
 * moment.  You will get a debug output message if you try to add too
 * many setup words.
 */
#define MAX_SETUPWORDS	(4)
#endif

struct TransactParms
{
  int   parms_in_len;
  BYTE *parms_in;
  int   data_in_len;
  BYTE *data_in;

  int   parms_out_maxlen;
  BYTE *parms_out_buf;
  int   parms_out_len;

  int   data_out_maxlen;
  BYTE *data_out_buf;
  int   data_out_len;
#ifdef LONGNAMES
  /* WARNING:  These fields MUST lie at the end because LanManFS provides
   *           a SWI call which takes a pointer to one of these structures.
   *           The user structure is now copied to a local variable, the
   *           size of which is given by the #define just below.
   */
  int   setup_in_len;
  WORD  setup_in[MAX_SETUPWORDS];
  int   setup_out_len;
  int   setup_out_maxlen;
  WORD  setup_out[MAX_SETUPWORDS];
#endif
};

#ifdef LONGNAMES
#  define sizeof_TransactParms_external (offsetof(struct TransactParms, setup_in_len))
#else
#  define sizeof_TransactParms_external (sizeof(struct TransactParms))
#endif

/* Directory functions */
extern err_t SMB_MkDir ( char *path );
extern err_t SMB_RmDir ( char *path );
extern err_t SMB_Delete ( char *path );
extern err_t SMB_Rename ( char *oldpath, char *newpath );
extern err_t SMB_GetAttribs ( char *filename, DOS_ATTRIBS *pAttr );
extern err_t SMB_SetAttribs ( char *filename, DOS_ATTRIBS *pAttr );
extern err_t SMB_ReadDirEntries ( char *path, int max_count,
               ENUM_DIR_FN dirfn, void *private, void *context);
extern err_t SMB_GetFreeSpace ( char lettr, struct disk_size_response
                                              * pDSR );

/* File functions */
extern err_t SMB_Create ( char *filename, DOS_ATTRIBS *pInAttr,
     int *pOutFH );

extern err_t SMB_Open ( int mode, char *filename,
      DOS_ATTRIBS *pOutAttr, int *pOutFH, int *pOutMode  );

extern err_t SMB_GetLength ( int fh, uint *pOutLen );

extern err_t SMB_Read ( int fh, uint offset, uint len, BYTE *where,
    uint *pOutLen ) ;
extern err_t SMB_Write ( int fh, uint offset, uint len, BYTE *where,
    uint *pOutLen ) ;
extern err_t SMB_Truncate ( int fh, uint length );
extern err_t SMB_Flush ( int fh ) ;
extern err_t SMB_Close ( int fh, DOS_ATTRIBS *pAttr );

/* Printer functions */
extern err_t SMB_OpenPrinter ( char drvlettr, char *printid, int *ph_out );
extern err_t SMB_WritePrinter ( int PH, BYTE *data, int datalen );
extern err_t SMB_ClosePrinter ( int PH );

/* Transaction (RPC) functions */
extern err_t SMB_Transact ( char drvlettr, char *trans_name,
                              struct TransactParms *pT );

/* Connect/disconnect functions */
extern err_t SMB_CreateShare ( int service_type,
                               int style,
                        char *serv_name, char *drv_name,
                        char *user_name, char *passwd,
                        char *share_lettr_out );
#define SHR_DISK    0
#define SHR_PRINTER 1
#define SHR_COMM    2
#define SHR_IPC     3

#define CREATE_NORMAL      0
#define CREATE_NEW_SHARE   1
#define CREATE_NEW_USER    2

/*
   CreateShare() is a monster routine to cope with everything
     related to connecting to the server. The main input variables
     are server name, share name and user name; CreateShare will
     attempt to create a share matching all of these parameters, doing
     all the necessary jiggering to make it work. The precise actions
     depend on whether these strings are the same as or different to
     previous values:

     Server Name -

     if a new server name, a new connection to the server will be
       created, the given user will be logged on & the given share
       will be connected. If any of this fails, the connections are
       closed.

     if the same as a server which is already connected:
       i ) if the user name is different to the user currently logged
            on at the server, the current user is logged off and the
            new one is logged on. This will only happen if CREATE_NEW_
            USER is set in the 'style' parameter, otherwise the user
            name is ignored.

       ii) if the share name is a different to any currently connected
            shares on the server, a new 'drive letter' is allocated
            and the new share is connected. If the CREATE_NEW_SHARE
            bit is set and the share name *isn't* new, the error
            ECONNEXISTS will be returned and *share_lettr_out will
            be set to the drive letter of this drive.

       if an error occurs during (i), we've lost the connection to
       the server and all other shares on the server will give
       failure errors when we try to use them. If an error occurs
       during ii), the new share is not created and an error is
       returned.

   The user name and password may optionally be NULL. If the user name
     is blank (NULL pointer, null string or white space), the re-logon
     process in (i) above will not happen, equivalent to CREATE_NEW_USER
     being clear. If a new server is being connected, and both the
     user name and password fields are blank, the user name and password
     fields are taken from LM_Vars. This might theoretically create a
     problem if a server insists on both these fields being blank, but
     in practice NT won't put up with blank user names and WFWG can't be
     made to insist on a blank password.
*/

extern err_t SMB_DeleteShare ( char share_lettr );

extern const char *SMB_GetConnInfo ( char drvlettr, int type );
#define GCI_SERVER 0     /* Server name */
#define GCI_SHARE  1
#define GCI_LOGONTYPE 2
/* Returns "User" or "Share" */
#define GCI_SHARETYPE 3
/* Returns "Disc" "Printer" "Comms" or "IPC" */

#define GCI_SERVERINFO 4 /* Description of server */
#define GCI_USER   5     /* User name */

#define GCIF_USERLOGON  'U'
#define GCIF_SHARELOGON 'S'
#define GCIF_DISKTYPE   'D'
#define GCIF_PRNTYPE    'P'
#define GCIF_COMMTYPE   'C'
#define GCIF_IPCTYPE    'I'


/* Test if we're connected to a given server */
extern bool SMB_ConnectedTo ( char *server );

/* Implement idle out protection for broken Microsoft servers */
extern void SMB_AntiIdle ( void );

/* Timeouts * */

/* Reply timeout, in cs */

#ifdef LONGNAMES
#define REPLY_TIMEOUT 4000
#else
#define REPLY_TIMEOUT 1200
#endif

/* Timeout to put in 'Transact' params, in ms */

#define TRANSACT_TIMEOUT 5000
#ifdef LONGNAMES
#define TRANSACT2_TIMEOUT 10000
#endif

/* Startup/shutdown */

extern bool  SMB_Init(void);
extern err_t SMB_Shutdown ( void );

/* SMB_WorkBuf **** */

/* This is a temporary buffer, made public on the following strict
   conditions:

   (i) Its contents may become corrupted across any SMB_xxxx calls.
       The main exception is the SMB_Transact call: this buffer is
       intended for use as the return parameter/data buffer.

   (ii) It must not be used by anything which may be called during
        an SMB call (transmit/receive processing functions, timer
        callbacks, SMB_EnumerateDir callbacks etc). This probably
        means anything in Network, LLC, and NetBIOS.

   (iii) Any other C source file may use it freely. In
         general, it should be assumed corrupted across calls
         between modules.
*/
#ifdef LONGNAMES
/* Need a much larger buffer */
#define SMBWORKBUF_SIZE 16384
#define SMBXMITMEM_SIZE SMBWORKBUF_SIZE
#else
#define SMBWORKBUF_SIZE 1500
#endif
extern BYTE SMB_WorkBuf[SMBWORKBUF_SIZE];

#ifdef LONGNAMES
extern bool SMB_IsLongNameFS( const char * path);
#endif
@


1.5
log
@Fix and speed up EXT#handle=number doing nothing when number is beyond 2GB
Internally LanManFS was representing file offsets and data lengths as signed numbers, while in general this doesn't matter (they are passed through opaquely as just numbers and not manipulated) in a couple of places they were being used as while () loop exit conditions.
Function WriteZeroes (used when extending a file via OS_Args) therefore never performed the call to SMB_Write when beyond 2G because the loop condition was never met.
Additionally, it was literally transferring buffers of zeros across the network which is unnecessary as the server is documented as doing a zero fill itself, this represents at least a x40 speed up (on a slow 1MB/s drive write speed at the server end) or more.
Changed offset & lengths from int to uint.
Added the earlier CIFS spec (the later copy is missing section 5 for some reason) to docs.

Version 2.38. Tagged as 'LanManFS-2_38'
@
text
@d186 1
a186 1
extern char * SMB_GetConnInfo ( char drvlettr, int type );
d192 1
a192 1
/* Returns "Disk" "Printer" "Comms" or "IPC" */
@


1.4
log
@  Multiple fixes.
Detail:
  Too many to list here: see doc/RPSChanges.
Admin:
  Received from Rob Sprowson approx 2009-02-08. Builds, but not tested by ROOL.

Version 2.32. Tagged as 'LanManFS-2_32'
@
text
@d103 1
a103 1
extern err_t SMB_GetLength ( int fh, int *pOutLen );
d105 5
a109 5
extern err_t SMB_Read ( int fh, int offset, int len, BYTE *where,
    int *pOutLen ) ;
extern err_t SMB_Write ( int fh, int offset, int len, BYTE *where,
    int *pOutLen ) ;
extern err_t SMB_Truncate ( int fh, int length );
d211 16
@


1.3
log
@  Changed idle-out strategy.
  Introduced new error message for re-entrancy prevention trap to use.
Detail:
  When 'pinging' an SMB server, LanManFS does not wait for any response
    but the response reading routine knows to just throw away any old
    SMBchkpth responses that it gets and try reading again.
  Re-entrancy trap now has its own error "LanManFS in use" &1663E, which
    means you no longer see "!Armboot files nested too deeply" which is
    confusing.  The only way you can provoke this message is if you use
    Alt-Break whilst the NetBIOS/IP code is executing.  The error plays
    the same part as "FileCore in use" does for FileCore.
Admin:
  Verified module still works and the anti idle-out features still work.

Version 2.04. Tagged as 'LanManFS-2_04'
@
text
@d26 1
a26 1
typedef err_t (*ENUM_DIR_FN) ( BYTE *entry, int format, void *private );
a49 3
typedef union Transact_SearchContext Transact_SearchContext;


a83 4
/* Exported routines ================ */



a84 1

d92 1
a92 1
               ENUM_DIR_FN dirfn, void *private, Transact_SearchContext *);
a96 1

a113 1

a118 2


d122 1
a122 2
/* Connect/disconnect functions  ----------------------- */

d224 1
a224 1
      intended for use as the return parameter/data buffer.
d227 7
a233 7
          an SMB call (transmit/receive processing functions, timer
          callbacks, SMB_EnumerateDir callbacks etc). This probably
          means anything in Network, LLC, and NetBIOS.

   (iii) Any other module (=C source file) may use it freely. In
          general, it should be assumed corrupted across calls
          between modules.
@


1.2
log
@  Support for long filename.
  Support for spaces in machine names.
  Merge of sbrodie_LanManFS_dev branch to trunk.
Detail:
  LanManFS 2.00 supports the "NT LM 0.12" protocol, enabling it to
    use long filenames on mounted shares.
Admin:
  Supporting documentation:
    1215,256/FS: LanManFS Software Functional Specification.
  Same as LanManFS-1_87_1_1_1_1_2_13.

Version 2.00. Tagged as 'LanManFS-2_00'
@
text
@a92 1
extern err_t SMB_ChkPath ( char *path );
@


1.1
log
@Initial revision
@
text
@d26 1
a26 1
typedef void (*ENUM_DIR_FN) ( BYTE *entry, void *private );
d39 13
d67 12
d81 6
d101 1
a101 1
               ENUM_DIR_FN dirfn, void *private );
d222 2
d249 5
a253 1

d255 1
d258 3
@


1.1.1.1
log
@
LanManFS moved into Omni subdirectory.  Previous version in
RiscOS/Sources/Networking/LanManFS is now locked out.

The rest of Omni will be imported at a later date.

Version 1.87, tagged as LanManFS-1_87

@
text
@@


1.1.1.1.2.1
log
@  First cut at long filenames in LanManFS.  *Cat and *Ex work.
  Pretty much nothing else does.
Detail:
  Now uses long filenames if available, and switches to the advanced
    SMB protocol and Transact2 commands to do work with long filenames.
Admin:
  Work in progress.  End of week's work checkin point only.  Do not use.

Version 1.87, 1.1.1.1.2.2. Tagged as 'LanManFS-1_87-1_1_1_1_2_2'
@
text
@d26 1
a26 1
typedef err_t (*ENUM_DIR_FN) ( BYTE *entry, int format, void *private );
a38 10
#ifdef LONGNAMES
/* Note.  As per the June 19 1990 document (doc vsn 1.11, prot vsn 3.0),
 * the maximum value for this needs to be 4 + (maximum route name length
 * + 2)/2 for the TRANSACT2_FSCTL call (6.0.1.1.10, page 41).  However,
 * TRANSACT2_IOCTL needs this to be 4 too, so it is left at four for the
 * moment.  You will get a debug output message if you try to add too
 * many setup words.
 */
#define MAX_SETUPWORDS	(4)
#endif
a53 12
#ifdef LONGNAMES
  /* WARNING:  These fields MUST lie at the end because LanManFS provides
   *           a SWI call which takes a pointer to one of these structures.
   *           The user structure is now copied to a local variable, the
   *           size of which is given by the #define just below.
   */
  int   setup_in_len;
  WORD  setup_in[MAX_SETUPWORDS];
  int   setup_out_len;
  int   setup_out_maxlen;
  WORD  setup_out[MAX_SETUPWORDS];
#endif
a55 6
#ifdef LONGNAMES
#  define sizeof_TransactParms_external (offsetof(struct TransactParms, setup_in_len))
#else
#  define sizeof_TransactParms_external (sizeof(struct TransactParms))
#endif

d216 1
a216 5
#ifdef LONGNAMES
/* Need a much larger buffer */
#define SMBWORKBUF_SIZE 16384
extern BYTE SMB_WorkBuf[SMBWORKBUF_SIZE];
#else
d219 1
a219 1
#endif
@


1.1.1.1.2.2
log
@  Another intermediate checkin now that *FileInfo works.  I believe this
    means that nearly all the core functionality is in place for long
    filename support.
Detail:
  According to Microsoft's documentation, several of the file lookup type
    transactions return the file information in a common format buffer.
    However, what the docs fail to mention, is that in *some* of those
    commands, the time & date fields are reversed.  FindFirst2/FindNext2
    return "date, time, ...".  QPathInformation returns "time, date, ..."
    Grrr.
  There remains a problem with occasional "server error" results from
    some requests.  The reason for these is unknown ... the documentation is
    unhelpful, describing this as "non-specific error code".  Simply repeating
    the command often results in success, sometimes it has to be repeated a
    few times.
  Also fixed filename mapping which caused any 'x' characters at the remote
    server end to be mapped to 'c' at the RISC OS end(!)  This didn't affect
    it before because servers wouldn't return the old module any filenames
    which contained lower case letters (LanManFS used to make the characters
    lower-case itself if the appropriate name style mode was set).
Admin:
  Tested - still seems to work.  Filename completion from LineEditor works
    nicely.  I can open and close files, and read data from them (*Dump
    used to test this).  *Cat, *Ex and *FileInfo all work.  *Dir works.
  Filename character translations to and from RISC OS format need to be
    verified.  The translation table DOS->RISC OS has been ripped out of
    the NFS module so should be pretty accurate.  The reverse mapping has
    not.

Version 1.87, 1.1.1.1.2.3. Tagged as 'LanManFS-1_87-1_1_1_1_2_3'
@
text
@d247 1
a247 1
#define SMBXMITMEM_SIZE SMBWORKBUF_SIZE
a249 1
#endif
a250 3

#ifdef LONGNAMES
extern bool SMB_IsLongNameFS( const char * path);
@


1.1.1.1.2.3
log
@  Fixed most dodgy pathname problems.
  All *LM... commands are now filing system commands.
  *Connect and *Disconnect renamed to *LMConnect and *LMDisconnect.
Detail:
  When translating RISC OS to DOS filenames, a loop could develop if
    any path component contained a dodgy character.  This is now fixed
    with the exception of problems when both < and > characters appear
    in pathnames since that confuses FileSwitch.  New mappings will be
    need to be agreed for these characters (and remappings for $ and %
    which overload < and > respectively)
  All *LM... commands are now filing system commands, which means that
    you need to prefix them with LanMan: unless LanManFS is the current
    filesystem (following spec review).
  *Connect and *Disconnect renamed to *LMConnect and *LMDisconnect
    (following spec review).
  Trace builds allow "*LanMan:LMNameMode 4" to enable display of system
    and hidden files on the remote filesystem.
Admin:
  Tested briefly against Windows 98 and Windows NT 4 SP3.
  If a directory name contains a dodgy character, repeated searches will
    be made on the remote filesystem.  This is inefficient and a name
    cache would alleviate this.  There is no name cacheing in the current
    version.

Version 1.87, 1.1.1.1.2.9. Tagged as 'LanManFS-1_87-1_1_1_1_2_9'
@
text
@a49 3
typedef union Transact_SearchContext Transact_SearchContext;


d98 1
a98 1
               ENUM_DIR_FN dirfn, void *private, Transact_SearchContext *);
@


1.1.1.1.2.4
log
@  Free space now 64-bit aware plus *-command implemented.
  Anti-idleout measures implemented.
  Boot behaviour sanitised.
Detail:
  Free space code now knows about 64-bit versions of the various
    calls that can be made to it (OS_FSControl and Free module's i/f)
  *Free implemented.
  CallEvery set up to periodically ping each share to stop buggy
    Microsoft servers going to sleep on it.
  The filesystem does not get deregistered from FileSwitch whenever
    any interface on the machine changes(!)   More subtle changes
    are still required to finalise things in this area though.
Admin:
  Requires TCPIPLibs 5.06 or later
    (CVS: RiscOS/Sources/Libs/TCPIPLibs  tag: TCPIPLibs-5_06)
  Tested by booting an STB22 against an NT4SP4 machine.

Version 1.87, 1.1.1.1.2.12. Tagged as 'LanManFS-1_87-1_1_1_1_2_12'
@
text
@a221 2
/* Implement idle out protection for broken Microsoft servers */
extern void SMB_AntiIdle ( void );
@

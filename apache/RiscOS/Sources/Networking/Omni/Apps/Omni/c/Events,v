head	1.12;
access;
symbols
	Omni-2_30:1.12
	Omni-2_29:1.11
	Omni-2_28:1.11
	Omni-2_27:1.11
	Omni-2_26:1.11
	Omni-2_25:1.11
	Omni-2_24:1.11
	Omni-2_23:1.9
	Omni-2_22:1.9
	Omni-2_21:1.9
	Omni-2_20:1.9
	Omni-2_19:1.8
	Omni-2_18:1.8
	Omni-2_17:1.8
	Omni-2_16:1.8
	Omni-2_15:1.8
	Omni-2_14:1.8
	Omni-2_13:1.8
	Omni-2_12:1.7
	Omni-2_11:1.6
	Omni-2_10:1.6
	Omni-2_09:1.6
	Omni-2_08:1.5
	Omni-2_07:1.4
	Omni-2_06:1.3
	Omni-2_05:1.2
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.12
date	2018.09.20.21.05.41;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	ljMsoSQjcEAv2TSA;

1.11
date	2016.09.25.11.33.01;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	irJdd5IbGkQFaFnz;

1.10
date	2016.09.24.10.58.39;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	vqcfLpgQE8f71xnz;

1.9
date	2014.08.06.20.53.55;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	BqXL5wzJunJLnlLx;

1.8
date	2004.09.02.22.46.09;	author jballance;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.18.14.32.03;	author srevill;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.17.09.37.44;	author blaughto;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.16.18.28.04;	author blaughto;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.12.17.06.27;	author blaughto;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.23.17.44.10;	author blaughto;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.19.24.14;	author blaughto;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.02.19.41.33;	author blaughto;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.03.02.19.41.33;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Various fixes
Events.c: refactor ActiveMounts() to not return a pointer to a local buffer array; avoid potential NULL pointer issue on 'ir'.
FileType.c: avoid undefined sprintf() when destination appears as one of the args
List.c: defer dereferencing 'wr' until checked for NULL
Print.c: don't leak 'tmp' on error
Parse.c: defer dereferencing 'wr' until checked for NULL, tweak dprintf() to avoid potential NULL pointer read in debug output
Found by cppcheck static analysis.

Version 2.30. Tagged as 'Omni-2_30'
@
text
@/* Copyright 2000 Pace Micro Technology plc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Program:	Events.c - wimp event handler routines
 *
 * Project:	!Omni OmniClient(tm) project
 *
 * Author:	Nick Smith
 *              ANT Limited
 *              Cambridge
 *              Internet: nas@@ant.co.uk
 *
 * Date:	13 July 1994
 * Last Edited: 26 June 1996
 *
 * Copyright 1994,1995,1996 by ANT Limited
 */

#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <Desk/DragASpr.h>
#include <Desk/Hourglass.h>
#include <Desk/File.h>
#include <Desk/Icon.h>
#include <Desk/KeyCodes.h>
#include <Desk/Kbd.h>
#include <Desk/Menu.h>
#include <Desk/Msgs.h>
#include <Desk/MsgTrans.h>
#include <Desk/Resource.h>
#include <Desk/Str.h>
#include <Desk/Template.h>
#include <Desk/Time.h>
#include <Desk/Window.h>

#include "Global/Variables.h"
#include "AsmUtils/osvarlen.h"

#include <DebugLib/DebugLib.h>

#include "Client.h"
#include "Close.h"
#include "Core.h"
#include "CoreInit.h"
#include "Defs.h"
#include "Events.h"
#include "Expert.h"
#include "ExtLib.h"
#include "Filer.h"
#include "FileType.h"
#include "Heap.h"
#include "List.h"
#include "Mount.h"
#include "Parse.h"
#include "Sort.h"

Desk_menu_ptr 	menu_icon  	= NULL;      	/* Pointer to our icon menu     */
Desk_menu_ptr 	menu_icon_i  	= NULL;
Desk_menu_ptr 	menu_icon_d  	= NULL;
Desk_menu_ptr 	menu_icon_m  	= NULL;
Desk_menu_ptr 	menu_icon_mo  	= NULL;
Desk_menu_ptr 	menu_icon_q  	= NULL;
Desk_menu_ptr 	menu_main  	= NULL;
Desk_menu_ptr 	menu_main_d  	= NULL;

void 		*menuwindow	= NULL;		/* */
mlist_record 	*mountwindow	= NULL;		/* */
client_record   *clientwindow   = NULL;

int		select_item	= 0;
Desk_window_handle	select_wind 	= NULL;
bool		select_transient = false;

bool		all_predone	= false;

static int cycle_time 		= 0;		/* For ADJUST-click protocol cycles */
static int cycle_item 		= 0;
static int cycle_icon 		= 0;
static Desk_wimp_point openlast 	= {-1, -1};	/* Last position mount dbox opened */

/*  ************************** Private functions *****************************
 */


/*  Create & open info dbox
 *  Return false if cannot create, else true
 */
static bool CreateInfo(void)
{
  if (wind_info == NULL)
  { char tmp[30];
    Desk_msgtrans_filedesc *desc;
    char resloc[96];

    wind_info = Desk_Window_Create("progInfo", Desk_template_TITLEMIN);
    if (wind_info == NULL) return false;

    /* The build system doesn't use <group.tag> style tags in Messages
     * so get down and boogie with MsgTrans for the version string.
     */
    sprintf(resloc, "%sMessages", Desk_resource_pathname);
    Desk_MsgTrans_LoadFile(&desc, resloc);
    Desk_MsgTrans_Lookup(desc, "_Version", tmp, sizeof (tmp) - 1);
    Desk_MsgTrans_LoseFile(desc);
    Desk_Icon_SetText(wind_info, info_version, tmp);

    /* The other messages can use the Msgs scheme */
    Desk_Msgs_Lookup("app.copy:", tmp, sizeof (tmp) - 1);
    Desk_Icon_SetText(wind_info, info_copy, tmp);
#ifdef SITE_LICENSE
    Desk_Msgs_Lookup("app.license:", tmp, sizeof (tmp) - 1);
#else
    Desk_Msgs_Lookup("app.licensee:", tmp, sizeof (tmp) - 1);
#endif
    Desk_Icon_SetText(wind_info, info_license, tmp);
  }
  Window_ShowDialogue(wind_info, Desk_FALSE);
  return true;
}


/*  Create & open client dbox
 *  Return false if cannot create, else true
 */
static bool CreateClient(int item)
{
  client_record *cr = NULL;
  char buf[64];

  dprintf (("", "CreateClient: %d\n", item));
  if (wind_client) Desk_Window_Delete(wind_client);
  wind_client = Desk_Window_Create("clientInfo", Desk_template_TITLEMIN);
  if (!wind_client) return false;
  item = item - 1; /* Rescale to start at 0 */
  if (item < 0) return false;
  if ((cr = ClientFind(-1, NULL, item, NULL)) == NULL) return false;

  /* Update title bar */
  strcpy(buf, "");
  if ((flagSET(cr, flag_FS)) && (!flagSET(cr, flag_PRINT)))
    Desk_Msgs_Lookup("cinfo.fs:", buf, sizeof (buf) - 1);
  if ((!flagSET(cr, flag_FS)) && (flagSET(cr, flag_PRINT)))
    Desk_Msgs_Lookup("cinfo.print:", buf, sizeof (buf) - 1);
  if ((flagSET(cr, flag_FS)) && (flagSET(cr, flag_PRINT)))
    Desk_Msgs_Lookup("cinfo.fsprint:", buf, sizeof (buf) - 1);
  if (strlen(buf) > 0) Desk_Window_SetTitle(wind_client, buf);

  /* Turn description string into 3 fields */
  if (cr->clientdesc != NULL)
  {
    char *line = NULL;
    char tmp[256];

    strncpy(tmp, cr->clientdesc, 255);
    line = strtok(tmp, "\n");
    Desk_Icon_SetText(wind_client, client_name, line ? line : "");
    line = strtok(NULL, "\n");
    Desk_Icon_SetText(wind_client, client_author, line ? line : "");
    line = strtok(NULL, "\n");
    Desk_Icon_SetText(wind_client, client_version, line ? line : "");
  }
  Window_ShowDialogue(wind_client, Desk_FALSE);
  return true;
}


/*  Return default user name for a given protocol module, or NULL.
 *  Reads from Omni$User<FSName> variable, see 'docs.GUI_Spec'.
 */
static char *UserName(client_record *cr)
{
  char buf[32];
  char *s = NULL;

  if ((cr == NULL) || (cr->fsname == NULL)) return(omni_getenv("Omni$User"));
  sprintf(buf, "Omni$User%s", cr->fsname);
  if ((s = omni_getenv(buf)) == NULL) s = omni_getenv("Omni$User");
  return(s);
}


/*  Find item in linked list from window handle
 */
static mwind_record *MountWindFind(Desk_window_handle w)
{
  mwind_record *mr = (mwind_record *) mwind_anchor.next;
  int searchtype = 0;

  dprintf (("", "MountWindFind:\n"));
  while (mr != NULL)
  {
    switch (searchtype)
    {
      case 0: if (mr->w == w) return(mr);
              break;
      default:
        break;
    }
    mr = (mwind_record *) mr->header.next;
  }
  return(NULL);
}


/*  Returns Desk_TRUE if all possible fields are filled in.
 */
static bool DboxFilled(Desk_window_handle w, client_record *cr, int flags)
{
  bool filled = true;
  char *s;
  int old_flags = cr ? cr->flags : -1;

  if (flags > -1) cr->flags = flags;

  s = Icon_GetTextPtr(w, mount_mount);
  dprintf (("", "DboxFilled: '%s' %d\n", s, strlen(s)));
  if (strlen(s) == 0) filled = false;

  if (Icon_IsEmpty (w, mount_server)) filled = false;
  if ((flagSET(cr, flag_PATH)) && Icon_IsEmpty (w, mount_path))   filled = false;
  if ((flagSET(cr, flag_USER)) && Icon_IsEmpty (w, mount_user))   filled = false;
  if ((flagSET(cr, flag_PW)) && Icon_IsEmpty (w, mount_password)) filled = false;
  if ((flagSET(cr, flag_AUTH)) && Icon_IsEmpty(w, mount_auth))    filled = false;

  if (flags > -1) cr->flags = old_flags;

  return filled;
}


/*  Returns Desk_TRUE if all possible fields are filled in.
 */
static bool DomainFilled(Desk_window_handle w, client_record *cr)
{
  if ((flagSET(cr, flag_AUTH)) && Icon_IsEmpty(w, domain_domain))   return false;
  if ((flagSET(cr, flag_USER)) && Icon_IsEmpty(w, domain_user))     return false;
  if ((flagSET(cr, flag_PW))   && Icon_IsEmpty(w, domain_password)) return false;

  return true;
}


/*  Set the caret in the correct position of the uppermost static mount
 *  dbox.
 */
static void MountCaret(mwind_record *mw)
{
  mwind_record *mwl = NULL;

  if (!mw) return;
  mwl = MountWindFind(mw->caret.window);
  if (!mwl) return;
  Desk_Wimp_SetCaretPosition(&mw->caret);
}


/*  Shared code to update mount_LIST/mount_WINDOW (from alias)
 */
static int CreateDomainList(Desk_window_handle w, mlist_record *mr, client_record *cr)
{
  char *s;
  int i = domain_domain;

  Desk_Icon_SetText(w, domain_domain, (mr->server && flagSET(cr, flag_AUTH)) ? mr->server : "");
  Desk_Icon_SetText(w, domain_user, (mr->user && flagSET(cr, flag_USER)) ? mr->user : "");
  if (!mr->user)
  {
    s = UserName(cr);
    Desk_Icon_SetText(w, domain_user, ((s) && (flagSET(cr, flag_USER))) ? s : "");
  } else s = mr->user;
  Desk_Icon_SetText(w, domain_password,
    ((mr->passwd) && (flagSET(cr, flag_PW))) ? mr->passwd : "");
  if ((!mr->passwd) && (flagSET(cr, flag_PW))) i = domain_password;
  if ((!s) && (flagSET(cr, flag_USER))) i = domain_user;
  if (!mr->server) i = domain_domain;
  return(i);
}


/*  Shared code to update mount_LIST/mount_WINDOW (from alias)
 */
static int CreateMountList(Desk_window_handle w, mlist_record *mr, client_record *cr)
{
  char *s;
  int i = mount_mount;

  Desk_Icon_SetText(w, mount_server, mr->server ? mr->server : "");
  Desk_Icon_SetText(w, mount_user, ((mr->user) && (flagSET(cr, flag_USER))) ? mr->user : "");
  if (!mr->user)
  {
    if (cr->client_id != 0x49240) s = UserName(cr);
      else s = NULL;
    Desk_Icon_SetText(w, mount_user, ((s) && (flagSET(cr, flag_USER))) ? s : "");
  } else s = mr->user;
  Desk_Icon_SetText(w, mount_password,
    ((mr->passwd) && (flagSET(cr, flag_PW))) ? mr->passwd : "");
  Desk_Icon_SetText(w, mount_mount, mr->mount ? mr->mount : "");
  Desk_Icon_SetText(w, mount_path, ((mr->path) && (flagSET(cr, flag_PATH))) ? mr->path : "");
  Desk_Icon_SetText(w, mount_auth, ((mr->auth) && (flagSET(cr, flag_AUTH))) ? mr->auth : "");
  if ((!mr->auth) && (flagSET(cr, flag_AUTH))) i = mount_auth;
  if ((!mr->passwd) && (flagSET(cr, flag_PW))) i = mount_password;
  if ((!s) && (flagSET(cr, flag_USER))) i = mount_user;
  if ((!mr->path) && (flagSET(cr, flag_PATH))) i = mount_path;
  if (!mr->server) i = mount_server;
  if ((!mr->mount) && (!flagSET(cr, flag_MOUNT))) i = mount_mount;
  Desk_Icon_SetSelect(w, mount_open, mr->open);
  return(i);
}


/*  Create & open [static] domain dbox
 *  Return Desk_FALSE if cannot create, else Desk_TRUE.
 */
static bool CreateDomain(int src, int item, bool dynamic)
{
  client_record *cr = NULL;
  mlist_record *mr = NULL;
  mwind_record *mw = NULL;
  item_record *ir = NULL;
  wind_record *wr = NULL;
  char title[96];
  Desk_icon_handle i = domain_domain;
  char *s;
  int flagwrite = Desk_iconbtype_WRITABLE * Desk_icon_BUTTONTYPE;
  Desk_window_handle w;
  Desk_window_state wstate;
  int width, h;
  bool result = true;
  bool ok = false;

  dprintf (("", "CreateDomain: %d %d\n", src, item));
  dprintf (("", "CreateDomain: dynamic %s\n", (dynamic) ? "YES" : "NO"));
  mountwindow = NULL;

  if (!dynamic)
    w = Desk_Window_Create("domain", Desk_template_TITLEMIN);
  else
  {
    w = wind_mountdom;
    if (!w) w = wind_mountdom = Desk_Window_Create("domain", Desk_template_TITLEMIN);
  }
  if (!w) return false;
  if (!dynamic)
  {
    mw = (mwind_record *) heap_alloc(sizeof(mwind_record));
    if (!mw)
    {
      Desk_Window_Delete(w);
      return false;
    }
    mw->w = w;
    mw->ml = NULL;
    mw->domain = Desk_TRUE;
    Desk_LinkList_AddToTail(&mwind_anchor, &(mw->header));
  }
  switch (src)
  {
    case mount_EMPTY:
    case mount_CLIENT:
      clientwindow = NULL;
      if (!dynamic) return false;
      if (src == mount_CLIENT)
        { if ((cr = ClientFind(item, NULL, -1, NULL)) == NULL) return false; }
      else
        { if ((cr = ClientFind(-1, NULL, item, NULL)) == NULL) return false; }
      dprintf (("", "CreateDomain: found ok\n"));
      clientwindow = cr;
      Desk_Icon_SetText(w, domain_domain, "");
      s = UserName(cr);
      Desk_Icon_SetText(w, domain_user, ((s) && (flagSET(cr, flag_USER))) ? s : "");
      Desk_Icon_SetText(w, domain_password, "");
      Desk_Wimp_SetIconState(w, domain_DELETE, Desk_icon_DELETED, Desk_icon_DELETED);
      break;
    case mount_MLIST:
    case mount_MLISTSEL:
    case mount_MLISTREC:
      clientwindow = NULL;
      if ((!dynamic) && (src == mount_MLISTSEL)) return false;
      if (src == mount_MLISTREC)
      {
        /* Horrible cast! */
        mr = (mlist_record *) item;
      }
      else
      {
        item = item - 2; /* Rescale to start at 0 */
        if (item < 0) return false;
        if ((mr = MountFind(-1, NULL, item, -1)) == NULL) return false;
      }
      if ((cr = ClientFind(mr->client_id, NULL, -1, NULL)) == NULL) return false;
      clientwindow = cr;
      i = CreateDomainList(w, mr, cr);
      Desk_Wimp_SetIconState(w, domain_DELETE, (dynamic) ? 0 : Desk_icon_DELETED, Desk_icon_DELETED);
      mountwindow = mr;
      break;
    case mount_WINDOW:
      if (!dynamic) return false;
      item = select_item;
      if (item <= 0) return false;
      if (!clientwindow) return false;
      if ((cr = ClientFind(clientwindow->client_id, NULL, -1, NULL)) != clientwindow)
        return false;
      wr = FilerFind(select_wind, -1, -1, -1);
      dprintf (("", "CreateDomain: post filerfind wr %x select_wind %x\n",(int) wr, (int) select_wind));
      ir = ItemFind(wr, select_item);
      dprintf (("", "CreateDomain: post itemfind ir %x select_item %x\n",(int) ir, (int) select_item));
      if (ir)
      {
        mr = MountFind(-1, ir->shortname, -1, ir->client_id);
      }
      if (wr && ir && (select_wind != wind_filer.w) && ir->alias && mr != NULL)
      {
        i = CreateDomainList(w, mr, cr);
      }
      else
      {
        Desk_Icon_SetText(w, domain_domain, "");
        s = UserName(cr);
        Desk_Icon_SetText(w, domain_user, ((s) && (flagSET(cr, flag_USER))) ? s : "");
        Desk_Icon_SetText(w, domain_password, "");
        if (!flagSET(cr, flag_AUTH))
        {
          if (flagSET(cr, flag_PW)) i = domain_password;
          if ((!s) && (flagSET(cr, flag_USER))) i = domain_user;
        }
      }
      Desk_Wimp_SetIconState(w, domain_DELETE, Desk_icon_DELETED, Desk_icon_DELETED);
      break;
    default:
      clientwindow = NULL;
      return false;
      break;
  }
  Desk_Msgs_printf(title, "domain.title", cr->clientname);
  Desk_Window_SetTitle(w, title);
  Desk_Wimp_SetIconState(w, domain_domain, flagSET(cr, flag_AUTH) ? flagwrite : 0,
    flagwrite);
  Icon_SetValid(w, domain_domain, !flagSET(cr, flag_AUTH));
  Icon_SetGreyShade(w, domain_tdomain, !flagSET(cr, flag_AUTH), Desk_iconbtype_NEVER);
  Desk_Wimp_SetIconState(w, domain_user, flagSET(cr, flag_USER) ? flagwrite : 0,
    flagwrite);
  Icon_SetValid(w, domain_user, !flagSET(cr, flag_USER));
  Icon_SetGreyShade(w, domain_tuser, !flagSET(cr, flag_USER), Desk_iconbtype_NEVER);
  Icon_SetValid(w, domain_password, !flagSET(cr, flag_PW));
  Desk_Wimp_SetIconState(w, domain_password, flagSET(cr, flag_PW) ? flagwrite : 0,
    flagwrite);
  Icon_SetGreyShade(w, domain_tpassword, !flagSET(cr, flag_PW), Desk_iconbtype_NEVER);

  dprintf (("", "CreateDomain: show dialogue\n"));
  if (!dynamic)
  {
    if (openlast.x == -1)
    {
      openlast.y = 500;
      openlast.x = 220;
    } else openlast.x += 32;
    Desk_Wimp_GetWindowState(w, &wstate);
    wstate.openblock.behind = -1;    			    /* open in front */
    width = wstate.openblock.screenrect.max.x - wstate.openblock.screenrect.min.x;
    h = wstate.openblock.screenrect.max.y - wstate.openblock.screenrect.min.y;
    wstate.openblock.screenrect.min.x = openlast.x;
    wstate.openblock.screenrect.max.y = openlast.y;
    wstate.openblock.screenrect.max.x = wstate.openblock.screenrect.min.x + width;
    wstate.openblock.screenrect.min.y = wstate.openblock.screenrect.max.y - h;
    Desk_Wimp_GetCaretPosition(&mw->caret);
    mw->ml = mountwindow;
    Desk_Wimp_OpenWindow(&wstate.openblock);
  } else Window_ShowDialogue(w, ((src != mount_MLIST) && (src != mount_MLISTSEL)));
  Desk_Icon_SetCaret(w, i);

  /* If all possible fields filled-in, and mount_WINDOW, or mount_MLIST from a select
   * click from the submenu (not a menu warning) ...
   */
  if (dynamic) ok = (src == mount_WINDOW) || (src == mount_MLISTSEL);
    else ok = Desk_TRUE;

  /* If all possible fields filled, then do connect operation ?*/
  if ((ok) && (DomainFilled(w, cr)))
  {
    dprintf (("", "CreateDomain: connection attempt!\n"));
    result = MountConnect(mr, w);
    if ((result) && (!dynamic))
    {
      Desk_Window_Delete(mw->w);
      Desk_LinkList_Unlink(&mwind_anchor, &(mw->header));
      FREE(mw);
    }
    if ((result) && (dynamic))
    {
      Menu_Close();
      Desk_menu_currentopen = NULL;
    }
  }
  return (result);
}


/*  Create & open [static] mount dbox
 *  Return Desk_FALSE if cannot create, else Desk_TRUE.
 */
extern bool CreateMount(int src, int item, bool dynamic)
{
  client_record *cr = NULL;
  mlist_record *mr = NULL;
  mwind_record *mw = NULL;
  item_record *ir = NULL;
  wind_record *wr = NULL;
  char title[128];
  Desk_icon_handle i = mount_mount;
  char *s;
  int flagwrite = Desk_iconbtype_WRITABLE * Desk_icon_BUTTONTYPE;
  Desk_window_handle w;
  Desk_window_state wstate;
  int width, h;
  bool result = true;
  bool ok = false;
  int flags = -1;

  dprintf (("", "CreateMount: %d %d\n", src, item));
  dprintf (("", "CreateMount: dynamic %s\n", (dynamic) ? "YES" : "NO"));

  /* Need to switch between Mount dbox and Domain dbox - messier than we would like */
  switch (src)
  {
    case mount_EMPTY:
    case mount_CLIENT:
      if (!dynamic) return false;
      if (src == mount_CLIENT)
        { if ((cr = ClientFind(item, NULL, -1, NULL)) == NULL) return false; }
      else
        { if ((cr = ClientFind(-1, NULL, item, NULL)) == NULL) return false; }
      break;

    case mount_MLIST:
    case mount_MLISTSEL:
    case mount_MLISTREC:
      clientwindow = NULL;
      if ((!dynamic) && (src == mount_MLISTSEL)) return false;
      if (src == mount_MLISTREC)
      {
        /* Horrible cast! */
        mr = (mlist_record *) item;
      }
      else
      {
        item = item - 2; /* Rescale to start at 0 */
        if (item < 0) return false;
        if ((mr = MountFind(-1, NULL, item, -1)) == NULL) return false;
        item = item + 2;
      }
      if ((cr = ClientFind(mr->client_id, NULL, -1, NULL)) == NULL) return false;
      break;

    case mount_WINDOW:
      if (!dynamic) return false;
      item = select_item;
      if (item <= 0) return false;
      if (!clientwindow) return false;
      if ((cr = ClientFind(clientwindow->client_id, NULL, -1, NULL)) != clientwindow)
        return false;
      break;

    default:
      return false;
      break;
  }
  if (flagSET(cr, flag_SPECIAL)) return (CreateDomain(src, item, dynamic));

  /* Open a real mount dbox */
  mountwindow = NULL;
  if (!dynamic)
    w = Desk_Window_Create("mount", Desk_template_TITLEMIN);
  else
  {
    w = wind_mounttmp;
    if (!w) w = wind_mounttmp = Desk_Window_Create("mount", Desk_template_TITLEMIN);
  }
  if (!w) return false;
  if (!dynamic)
  {
    mw = (mwind_record *) heap_alloc(sizeof(mwind_record));
    if (!mw)
    {
      Desk_Window_Delete(w);
      return false;
    }
    mw->w = w;
    mw->ml = NULL;
    mw->domain = false;
    Desk_LinkList_AddToTail(&mwind_anchor, &(mw->header));
  }
  switch (src)
  {
    case mount_EMPTY:
    case mount_CLIENT:
      clientwindow = NULL;
      if (!dynamic) return false;
      if (src == mount_CLIENT)
        { if ((cr = ClientFind(item, NULL, -1, NULL)) == NULL) return false; }
      else
        { if ((cr = ClientFind(-1, NULL, item, NULL)) == NULL) return false; }
      dprintf (("", "CreateMount: found ok\n"));
      clientwindow = cr;
      Desk_Icon_SetText(w, mount_server, "");
      if (cr->client_id != 0x49240) s = UserName(cr);
        else s = NULL;
      Desk_Icon_SetText(w, mount_user, ((s) && (flagSET(cr, flag_USER))) ? s : "");
      Desk_Icon_SetText(w, mount_password, "");
      Desk_Icon_SetText(w, mount_mount, "");
      Desk_Icon_SetText(w, mount_path, "");
      Desk_Icon_SetText(w, mount_auth, "");
      Desk_Icon_SetSelect(w, mount_open, Desk_FALSE);
      Desk_Wimp_SetIconState(w, mount_DELETE, Desk_icon_DELETED, Desk_icon_DELETED);
      break;
    case mount_MLIST:
    case mount_MLISTSEL:
    case mount_MLISTREC:
      clientwindow = NULL;
      if ((!dynamic) && (src == mount_MLISTSEL)) return false;
      if (src == mount_MLISTREC)
      {
        /* Horrible cast! */
        mr = (mlist_record *) item;
      }
      else
      {
        item = item - 2; /* Rescale to start at 0 */
        if (item < 0) return false;
        if ((mr = MountFind(-1, NULL, item, -1)) == NULL) return false;
      }
      if ((cr = ClientFind(mr->client_id, NULL, -1, NULL)) == NULL) return false;
      clientwindow = cr;
      i = CreateMountList(w, mr, cr);
      Desk_Wimp_SetIconState(w, mount_DELETE, (dynamic) ? 0 : Desk_icon_DELETED, Desk_icon_DELETED);
      mountwindow = mr;
      break;

    case mount_WINDOW:
      if (!dynamic) return false;
      item = select_item;
      if (item <= 0) return false;
      if (!clientwindow) return false;
      if ((cr = ClientFind(clientwindow->client_id, NULL, -1, NULL)) != clientwindow)
        return false;
      wr = FilerFind(select_wind, -1, -1, -1);
      dprintf (("", "CreateMount: post filerfind wr %x select_wind %x\n", (int) wr, (int) select_wind));
      ir = ItemFind(wr, select_item);
      dprintf (("", "CreateMount: post itemfind ir %x select_item %x\n", (int) ir, (int) select_item));
      if ((!wr) || (!ir)) return false;

      /* Call OmniOp,8 to see if flags for this protocol have changed */
      if (ClientGetInactiveMountInfo (cr->client_id,
                                      ir->server_id, ir->fullname,
                                      &flags) != NULL)
      {
        flags = -1;
      }

      if (select_wind != wind_filer.w)
      {
        /* Mount window */

        if (ir->alias)
        {
          mr = MountFind(-1, ir->shortname, -1, ir->client_id);
          if (mr)
          {
            /* From an alias entry! Get the mlist pointer */
            dprintf (("", "CreateMount: from alias!\n"));
            i = CreateMountList(w, mr, cr);
            Desk_Wimp_SetIconState(w, mount_DELETE, Desk_icon_DELETED, Desk_icon_DELETED);
            if (MountIconFind(-1, ir->shortname, -1, Desk_TRUE, -1))
            {
              /* We already have a connected mount with this alias, reset */
              Desk_Icon_SetText(w, mount_mount, "");
              i = mount_mount;
            }
            break;
          }
        }
        Desk_Icon_SetText(w, mount_path,
          ((ir->fullname) && (flagSET(cr, flag_PATH))) ? ir->fullname : "");
        ir = ItemFind(&wind_filer, wr->item);
        Desk_Icon_SetText(w, mount_server, ir->fullname);
        /* Hack for LanMan! Most sensible to have share name as mount name, not
         * server name.
         */
        if (cr->client_id == 0x49240)
        {
          Desk_Icon_GetText(w, mount_path, title);
          if (strlen(title) && MountFind(-1, title, -1, -1)) strcpy(title, "");
          Desk_Icon_SetText(w, mount_mount, title);
        }
        else if (flagSET(cr, flag_MOUNT) && MountFind(-1, ir->shortname, -1, -1))
        {
          /* Hack for Access/NetFS - *can't* have login with same server name, because
           * these protocols insist on having the same mount/server names.
           */
          Desk_Msgs_Report(0, "mount.exists");
          return false;
        }
        else
        {
          if (!MountFind(-1, ir->shortname, -1, -1)) strcpy(title, ir->shortname);
            else strcpy(title, "");
          if ((s = strchr(title, '.')) != NULL) *s = '\0';
          Desk_Icon_SetText(w, mount_mount, title);
          dprintf (("", "CreateMount: title '%s' ir->shortname '%s'\n", title, ir->shortname));
        }
      }
      else
      {
        /* Server window */
        Desk_Icon_SetText(w, mount_server, ir->fullname);
        Desk_Icon_SetText(w, mount_path, "");

        /* Hack for Access/NetFS - *can't* have login with same server name, because
         * these protocols insist on having the same mount/server names.
         */
        if (flagSET(cr, flag_MOUNT) && MountFind(-1, ir->shortname, -1, -1))
        {
          Desk_Msgs_Report(0, "mount.exists");
          return false;
        }
        if (!MountFind(-1, ir->shortname, -1, -1)) strcpy(title, ir->shortname);
          else strcpy(title, "");
        if ((s = strchr(title, '.')) != NULL) *s = '\0';
        Desk_Icon_SetText(w, mount_mount, title);
        dprintf (("", "CreateMount: title '%s' ir->shortname '%s'\n", title, ir->shortname));
      }
      if (cr->client_id != 0x49240) s = UserName(cr);
        else s = NULL;
      Desk_Icon_SetText(w, mount_user, ((s) && (flagSET(cr, flag_USER))) ? s : "");
      Desk_Icon_SetText(w, mount_password, "");
      Desk_Icon_SetText(w, mount_auth, "");
      if (flagSET(cr, flag_AUTH)) i = mount_auth;
      if (flagSET(cr, flag_PW)) i = mount_password;
      if ((!s) && (flagSET(cr, flag_USER))) i = mount_user;
      if ((select_wind == wind_filer.w) && (flagSET(cr, flag_PATH))) i = mount_path;
      if (flagSET(cr, flag_SPECIAL)) i = mount_server;
      if ((strlen(title) == 0) && (!flagSET(cr, flag_MOUNT))) i = mount_mount;
      Desk_Wimp_SetIconState(w, mount_DELETE, Desk_icon_DELETED, Desk_icon_DELETED);
      break;
    default:
      clientwindow = NULL;
      return false;
      break;
  }
  Desk_Msgs_printf(title, "mount.title", cr->clientname);
  Desk_Window_SetTitle(w, title);
  Desk_Wimp_SetIconState(w, mount_user, flagSET(cr, flag_USER) ? flagwrite : 0,
    flagwrite);
  Icon_SetValid(w, mount_user, !flagSET(cr, flag_USER));
  Icon_SetValid(w, mount_password, !flagSET(cr, flag_PW));
  Icon_SetValid(w, mount_path, !flagSET(cr, flag_PATH));
  Icon_SetValid(w, mount_auth, !flagSET(cr, flag_AUTH));
  Icon_SetGreyShade(w, mount_tuser, !flagSET(cr, flag_USER), Desk_iconbtype_NEVER);
  Desk_Wimp_SetIconState(w, mount_password, flagSET(cr, flag_PW) ? flagwrite : 0,
    flagwrite);
  Icon_SetGreyShade(w, mount_tpassword, !flagSET(cr, flag_PW), Desk_iconbtype_NEVER);
  Desk_Wimp_SetIconState(w, mount_path, flagSET(cr, flag_PATH) ? flagwrite : 0,
    flagwrite);
  Icon_SetGreyShade(w, mount_tpath, !flagSET(cr, flag_PATH), Desk_iconbtype_NEVER);
  Desk_Wimp_SetIconState(w, mount_auth, flagSET(cr, flag_AUTH) ? flagwrite : 0,
    flagwrite);
  Icon_SetGreyShade(w, mount_tauth, !flagSET(cr, flag_AUTH), Desk_iconbtype_NEVER);
  dprintf (("", "CreateMount: flags %x flag_AUTH %d\n", cr->flags, flagSET(cr, flag_AUTH)));

  dprintf (("", "CreateMount: show dialogue\n"));
  if (!dynamic)
  {
    if (openlast.x == -1)
    {
      openlast.y = 500;
      openlast.x = 220;
    } else openlast.x += 32;
    Desk_Wimp_GetWindowState(w, &wstate);
    wstate.openblock.behind = -1;    			    /* open in front */
    width = wstate.openblock.screenrect.max.x - wstate.openblock.screenrect.min.x;
    h = wstate.openblock.screenrect.max.y - wstate.openblock.screenrect.min.y;
    wstate.openblock.screenrect.min.x = openlast.x;
    wstate.openblock.screenrect.max.y = openlast.y;
    wstate.openblock.screenrect.max.x = wstate.openblock.screenrect.min.x + width;
    wstate.openblock.screenrect.min.y = wstate.openblock.screenrect.max.y - h;
    Desk_Wimp_GetCaretPosition(&mw->caret);
    mw->ml = mountwindow;
    Desk_Wimp_OpenWindow(&wstate.openblock);
  } else Window_ShowDialogue(w, ((src != mount_MLIST) && (src != mount_MLISTSEL)));
  Desk_Icon_SetCaret(w, i);

  /* If all possible fields filled-in, and mount_WINDOW, or mount_MLIST from a select
   * click from the submenu (not a menu warning) ...
   */
  if (dynamic) ok = (src == mount_WINDOW) || (src == mount_MLISTSEL);
    else ok = Desk_TRUE;

  /* NetFS hack for pre-authenticated connections */
  if ((dynamic) && (src == mount_WINDOW) && (cr->client_id == 0x4a540) && (ir->server_id != 1))
  {
    /* Search current NetFS connections for the same server_id */
    dprintf (("", "CreateMount: NetFS hack!\n"));
    if (MountIconFind(cr->client_id, NULL, -1, Desk_TRUE, ir->server_id))
    {
      char buf[96];

      /* Do a Filer_OpenDir command */
      sprintf(buf, "Filer_OpenDir Net::%s.$", ir->fullname);
      dprintf (("", "CreateMount: NetFS found item '%s'\n", buf));
      if (_swix (OS_CLI, _IN (0), buf) != NULL)
      {
        result = false;
      }

      /* Clean up and die */
      Menu_Close();
      Desk_menu_currentopen = NULL;
      return (result);
    }
  }

  /* If all possible fields filled, then do connect operation ?*/
  if ((ok) && (DboxFilled(w, cr, flags)))
  {
    dprintf (("", "CreateMount: connection attempt!\n"));
    result = MountConnect(mr, w);
    if ((result) && (!dynamic))
    {
      Desk_Window_Delete(mw->w);
      Desk_LinkList_Unlink(&mwind_anchor, &(mw->header));
      FREE(mw);
    }
    if ((result) && (dynamic))
    {
      Menu_Close();
      Desk_menu_currentopen = NULL;
    }
  }
  return (result);
}



/*  Create & open mount info dbox
 *  Return Desk_FALSE if cannot create, else Desk_TRUE.
 */
static bool CreateMountInfo(mount_record *mr)
{
  char *r1, *r2, *r3, *r4, *r5;
  char title[96];
  client_record *cr = NULL;

  if (!mr) return false;
  if ((cr = ClientFind(mr->client_id, NULL, -1, NULL)) == NULL) return false;
  if (wind_mountinfo == NULL)
  {
    wind_mountinfo = Desk_Window_Create("mountInfo", Desk_template_TITLEMIN);
    if (wind_mountinfo == NULL) return false;
  }
  dprintf (("", "CreateMountInfo: %x %x\n", (int) mr, mr->mount_id));

  Desk_Error2_Try
  {
    _swi (cr->client_id, _INR (0, 1) | _OUTR (1, 5),
          9, mr->mount_id,
          &r1, &r2, &r3, &r4, &r5);

    Desk_Msgs_printf(title, "mount.about", cr->clientname);
    Desk_Window_SetTitle(wind_mountinfo, title);
    Desk_Icon_SetText(wind_mountinfo, minfo_server, r1 ? r1 : "");
    Desk_Icon_SetText(wind_mountinfo, minfo_user, ((r2) && (flagSET(cr, flag_USER))) ? r2 : "");
    Desk_Icon_SetText(wind_mountinfo, minfo_mount, r3 ? r3 : "");
    Desk_Icon_SetText(wind_mountinfo, minfo_path, ((r4) && (flagSET(cr, flag_PATH))) ? r4 : "");
    Desk_Icon_SetText(wind_mountinfo, minfo_auth, ((r5) && (flagSET(cr, flag_AUTH))) ? r5 : "");
    Icon_SetGreyShade(wind_mountinfo, minfo_tpath, !flagSET(cr, flag_PATH), Desk_iconbtype_NEVER);
    Icon_SetGreyShade(wind_mountinfo, minfo_tuser, !flagSET(cr, flag_USER), Desk_iconbtype_NEVER);
    Icon_SetGreyShade(wind_mountinfo, minfo_tauth, !flagSET(cr, flag_AUTH), Desk_iconbtype_NEVER);
    Window_ShowDialogue(wind_mountinfo, Desk_FALSE);
  }
  Desk_Error2_Catch
  {
    Desk_os_error *e = Desk_Error2_ConvertToOS2 ();
    Desk_Error_Report(e->errnum, e->errmess);
    return false;
  }
  Desk_Error2_EndCatch

  return true;
}


/*  Return menu position from client_id.
 */
static int ClientItem(int client_id)
{
  client_record *cr = (client_record *) client_anchor.next;
  int loop = 0;

  dprintf (("", "ClientItem:\n"));
  while (cr != NULL)
  {
    if (cr->client_id == client_id) return(loop);
    loop++;
    cr = (client_record *) cr->header.next;
  }
  return(0);
}


/*  ************************* Event handlers *********************************
 */


/*  Handler attached to all button click events.
 *  If no other handler specifically handles the click, and it was a menu
 *  click, we will pop up our menu in an appropriate position.
 */
extern Desk_bool ButtonClick(Desk_event_pollblock *event, mount_record *mr)
{
  int ypos;
  Desk_icon_handle   i = event->data.mouse.icon;
  Desk_window_handle w = event->data.mouse.window;
  Desk_button_state  b;
  bool               test_select, test_adjust;
  mwind_record  *mw = MountWindFind(w);

  dprintf (("", "ButtonClick: 1 mw %p mw->domain %d mr %p\n", mw, mw ? mw->domain : -1, mr));
  if (w == NULL) return(Desk_FALSE);
  b.value = event->data.mouse.button.value;
  if (w == Desk_window_ICONBAR)
  {
    if (mr == NULL) return(Desk_FALSE);
    if (i != mr->icon) return(Desk_FALSE);
    openlast.x = -1;
    openlast.y = -1;
    if (b.data.menu)    			/* is a MENU click */
    {
      bool connect = (mr->icon_state != ISTATE_OK);
      bool connections = (MountCount() > 1);
      char tmp[32];

      ypos = -1;                        	/* Over the iconbar */
      menuwindow = (void *) mr;
      Desk_Menu_SetFlags(menu_icon, imenu_MOUNTINFO, Desk_FALSE, connect);
      Desk_Menu_SetFlags(menu_icon, imenu_OPENROOT, Desk_FALSE, connect);
      Desk_Menu_SetFlags(menu_icon, imenu_FREE, Desk_FALSE, connect);
      Desk_Menu_AddSubMenu(menu_icon, imenu_DISMOUNT, (connections && prog_config.expert) ?
          menu_icon_d : NULL);
#ifdef EXPERT
      if (prog_config.expert)
      {
        Desk_Menu_AddSubMenu(menu_icon, imenu_QUIT, menu_icon_q);
        Desk_Msgs_Lookup((!connect || connections) ? "icon.dismount" : "icon.reset", tmp, 31);
        Desk_Menu_SetText(menu_icon, imenu_DISMOUNT, tmp);
        Desk_Menu_SetFlags(menu_icon, imenu_DISMOUNT, Desk_FALSE, Desk_FALSE);
      }
      else
#endif
      {
        Desk_Msgs_Lookup("icon.dismount", tmp, 31);
        Desk_Menu_SetText(menu_icon, imenu_DISMOUNT, tmp);
        Desk_Menu_SetFlags(menu_icon, imenu_DISMOUNT, Desk_FALSE, connect);
      }
      Desk_Menu_AddSubMenu(menu_icon, imenu_OPENROOT, ((mr->menu) && (!connect)) ? mr->menu : NULL);
      Desk_Menu_Show(menu_icon, event->data.mouse.pos.x, ypos);
      return(Desk_TRUE);
    }

#ifdef EXPERT
    test_select = (prog_config.expert) ? (b.data.select) : ((b.data.select) || (b.data.adjust));
    test_adjust = (prog_config.expert) ? (b.data.adjust) : Desk_FALSE;
#else
    test_select = ((b.data.select) || (b.data.adjust));
    test_adjust = Desk_FALSE;
#endif
#ifdef EXPERT
    if ((prog_config.expert) && (b.data.select) && (Desk_Kbd_KeyDown(Desk_inkey_SHIFT)))
    {
      /* Open servers list */
      if ((wind_filer.w) && (!Desk_Window_IsOpen(wind_filer.w))) ParseLists(0);
      FilerCreate(0, 0);
      return(Desk_TRUE);
    }
#endif
    if (test_select)
    {
      /* If connected, do a Filer_OpenDir, else open servers list ... */
      if ((mr->icon_state == ISTATE_OK) && (b.data.select))
      {
        /* Filer_OpenDir on root of mount */
        Desk_Error_Check (ClientOpenUserRoot (mr->client_id, mr->mount_id));
      }
      else
      {
        dprintf (("", "Opening servers list\n"));
        /* Open servers list */
        if ((wind_filer.w) && (!Desk_Window_IsOpen(wind_filer.w))) ParseLists(0);
        FilerCreate(0, 0);
      }
      return(Desk_TRUE);
    }
    if (test_adjust)
    {
      if (mr->icon == cycle_icon)
      {
        /* Do mount open on some protocol */
        if (Desk_Time_Monotonic() >= cycle_time + 200) cycle_item = ClientItem(mr->client_id);
        if (ClientFind(-1, NULL, cycle_item, NULL) == NULL) cycle_item = 0;
        CreateMount(mount_EMPTY, cycle_item++, Desk_TRUE);
      }
      else
      {
         cycle_icon = mr->icon;
         if (mr->icon_state == ISTATE_OK) cycle_item = ClientItem(mr->client_id);
           else cycle_item = 0;
        CreateMount(mount_EMPTY, cycle_item++, Desk_TRUE);
      }
      cycle_time = Desk_Time_Monotonic();
      return(Desk_TRUE);
    }
  }

  dprintf (("", "ButtonClick: mw %p mw->domain %d\n", mw, mw ? mw->domain : -1));
  if (w == wind_mounttmp)
  {
    if ((b.data.select) || (b.data.adjust))
    {
      switch (i)
      {
        case mount_DELETE:
          /* Delete from menu list */
          MountDeleteList(mountwindow);
          Menu_Close();
          Desk_menu_currentopen = NULL;
          break;
        case mount_CANCEL:
          if (b.data.select)
          {
            Menu_Close();
            Desk_menu_currentopen = NULL;
          }
          else
          {
            /* Restore default/previous fields */



          }
          break;
        case mount_CONNECT:
          /* Attempt a connection */
          dprintf (("", "mount tmp_connect button click\n"));
          if ((MountConnect(mountwindow, w)) && (b.data.select))
          {
            dprintf (("", "about to Menu_Close\n"));
            Menu_Close();
            Desk_menu_currentopen = NULL;
          }
          dprintf (("", "done mount_CONNECT\n"));
          break;
        default:
          break;
      }
    }
    return(Desk_TRUE);
  }

  if (w == wind_mountdom)
  {
    if ((b.data.select) || (b.data.adjust))
    {
      switch (i)
      {
        case domain_DELETE:
          /* Delete from menu list */
          MountDeleteList(mountwindow);
          Menu_Close();
          Desk_menu_currentopen = NULL;
          break;
        case domain_CANCEL:
          if (b.data.select)
          {
            Menu_Close();
            Desk_menu_currentopen = NULL;
          }
          else
          {
            /* Restore default/previous fields */



          }
          break;
        case domain_CONNECT:
          /* Attempt a connection */
          dprintf (("", "domain tmp_Connect button click\n"));
          if ((DomainConnect(mountwindow, w)) && (b.data.select))
          {
            Menu_Close();
            Desk_menu_currentopen = NULL;
          }
          break;
        default:
          break;
      }
    }
    return(Desk_TRUE);
  }

  if (mw && !mw->domain)
  {
    if ((b.data.select) || (b.data.adjust))
    {
      switch (i)
      {
        case mount_DELETE:
          break;
        case mount_CANCEL:
          if (b.data.select)
          {
            if (Desk_LinkList_ListLength(&mwind_anchor) > 1) MountCaret(mw);
            Desk_Window_Delete(mw->w);
            Desk_LinkList_Unlink(&mwind_anchor, &(mw->header));
            FREE(mw);
          }
          else
          {
            /* Restore default/previous fields */



          }
          break;
        case mount_CONNECT:
          /* Attempt a connection */
          dprintf (("", "mount_connect button click\n"));
          if ((MountConnect(mw->ml, mw->w)) && (b.data.select))
          {
            if (Desk_LinkList_ListLength(&mwind_anchor) > 1) MountCaret(mw);
            Desk_Window_Delete(mw->w);
            Desk_LinkList_Unlink(&mwind_anchor, &(mw->header));
            FREE(mw);
          }
          break;
        default:
          break;
      }
    }
    return(Desk_TRUE);
  }

  if (mw && mw->domain)
  {
    if ((b.data.select) || (b.data.adjust))
    {
      switch (i)
      {
        case domain_DELETE:
          break;
        case domain_CANCEL:
          if (b.data.select)
          {
            if (Desk_LinkList_ListLength(&mwind_anchor) > 1) MountCaret(mw);
            Desk_Window_Delete(mw->w);
            Desk_LinkList_Unlink(&mwind_anchor, &(mw->header));
            FREE(mw);
          }
          else
          {
            /* Restore default/previous fields */



          }
          break;
        case domain_CONNECT:
          /* Attempt a connection */
          dprintf (("", "domain_connect button click %p %p\n", mw, mw->ml));
          if ((DomainConnect(mw->ml, mw->w)) && (b.data.select))
          {
            if (Desk_LinkList_ListLength(&mwind_anchor) > 1) MountCaret(mw);
            Desk_Window_Delete(mw->w);
            Desk_LinkList_Unlink(&mwind_anchor, &(mw->header));
            FREE(mw);
          }
          break;
        default:
          break;
      }
    }
    return(Desk_TRUE);
  }
  return(Desk_FALSE);
}


/*  A DataSave attempt to our iconbar icon(s) ?
 */
static Desk_bool DataSave(Desk_message_block msg, void *ref)
{
  char buf[256], var[64];
  size_t len;
  client_record *cr;
  mount_record *mr;

  UNUSED (ref);
  dprintf (("", "DataSave:\n"));
  if (msg.data.datasave.window != Desk_window_ICONBAR) return(Desk_FALSE);
  
  /* Lookup mount that the iconbar icon maps to */ 
  mr = MountIconFind(-1, NULL, msg.data.datasave.icon, Desk_TRUE, -1);
  if (mr == NULL) return(Desk_FALSE);
  dprintf (("", "DataSave: valid icon %x\n", (int) mr));
  cr = ClientFind(mr->client_id, NULL, -1, NULL);
  if (cr == NULL) return(Desk_FALSE);

  /* Formulate a full name */
  len = sprintf(buf, "%s::%s.$", cr->fsname, mr->mount);
  sprintf(var, "%sFiler$DefaultDir", cr->fsname);
  if (osvarlen(var, VarType_Expanded) > 0)
  {
    len = len + sprintf(var, ".%s", omni_getenv(var));
    strcat(buf, var);
  }
  buf[len++] = '.'; buf[len] = 0;
  strncat(buf, msg.data.datasave.leafname, sizeof(buf) - len - 1);

  /* Reply with a DataSaveAck message */
  msg.data.datasaveack.filename[0] = 0;
  strncat(msg.data.datasaveack.filename, buf, sizeof(msg.data.datasaveack.filename) - 1);
  dprintf (("", "DataSave: '%s'\n", msg.data.datasaveack.filename));
  msg.header.size = ((strlen(msg.data.datasaveack.filename) + 1 + 3) & ~3) + 44;
  msg.header.yourref = msg.header.myref;
  msg.header.action = Desk_message_DATASAVEOK;
  Desk_Wimp_SendMessage(Desk_event_SEND, &msg,msg.header.sender, NULL);
  return(Desk_TRUE);
}


/*  A DataLoad attempt to our iconbar icon(s) ?
 */
static Desk_bool DataLoad(Desk_message_block msg, void *ref)
{
  char buf[256], var[64];
  size_t len;
  client_record *cr;
  mount_record *mr;

  UNUSED (ref);
  dprintf (("", "DataLoad:\n"));
  if (msg.data.dataload.window != Desk_window_ICONBAR) return(Desk_FALSE);

  /* Lookup mount that the iconbar icon maps to */ 
  mr = MountIconFind(-1, NULL, msg.data.dataload.icon, Desk_TRUE, -1);
  if (mr == NULL) return(Desk_FALSE);
  dprintf (("", "DataLoad: valid icon %x\n", (int) mr));
  cr = ClientFind(mr->client_id, NULL, -1, NULL);
  if (cr == NULL) return(Desk_FALSE);

  /* Formulate a dir name */
  len = sprintf(buf, "%s::%s.$", cr->fsname, mr->mount);
  sprintf(var, "%sFiler$DefaultDir", cr->fsname);
  if (osvarlen(var, VarType_Expanded) > 0)
  {
    len = len + sprintf(var, ".%s", omni_getenv(var));
    strcat(buf, var);
  }

  if (msg.header.yourref)
  {
    /* Continuation of the exchange started in DataSave(), above */
    dprintf (("", "DataLoad: load from application - file transfer complete\n"));
    msg.header.yourref = msg.header.myref;
    msg.header.action = Desk_message_DATALOADOK;
    Desk_Wimp_SendMessage(Desk_event_SEND, &msg, msg.header.sender, NULL);
  }
  else
  {
    /* New selection dropped, tell Filer where to stick it */
    dprintf (("", "DataLoad: selection requires Filer device path\n"));
    msg.data.bytes[0] = 0;
    strncat(msg.data.bytes, buf, sizeof(msg.data.bytes) - 1);
    msg.header.size = ((strlen(msg.data.bytes) + 1 + 3) & ~3) + 20;
    msg.header.yourref = msg.header.myref;
    msg.header.action = Desk_message_FILERDEVICEPATH;
    Desk_Wimp_SendMessage(Desk_event_SEND, &msg, msg.header.sender, NULL);
  }

  /* Open directory viewer */
  buf[len] = 0; /* Trim off the leaf again */
  sprintf(var, "%%Filer_OpenDir %s", buf);
  _swix(OS_CLI, _IN(0), var);

  return(Desk_TRUE);
}


/*  Logoff any Access+/LanMan domains and reload mounts file.
 */
static void Reset(void)
{
  client_record *cr = (client_record *) client_anchor.next;

  /* Kill off the existing mounts file in memory */
  mlist_clean();

  /* Load default mounts file off disc */
  MountLoadFile(NULL);

  /* Call any domain logon protocols with OmniOp,17 to logout */
  while (cr)
  {
    if (flagSET(cr, flag_SPECIAL))
    {
      /* Ignore any errors */
      dprintf (("", "Reset: calling OmniOp for '%s'\n", cr->fsname));
      ClientDomainLogout (cr->client_id);
    }
    cr = (client_record *) cr->header.next;
  }

  /* Unauthenticate from Access+ domains - ignore any errors */
  /* _swix (OmniAccess_Reset, 0); */
}


/*  Dismount all active mounts.
 */
static void Dismount(mount_record *mr)
{
  client_record *cr = NULL;
  char          buf[64];
  bool		all = (!mr);

  /* Use Omni_Op SWI call to dismount all active mounts */
  dprintf (("", "Dismount: %x\n", (int) mr));
  Desk_Hourglass_Start(5);
  if (!mr) mr = (mount_record *) mount_anchor.next;
  while (mr != NULL)
  {
    mount_record *mr_tmp = (mount_record *) mr->header.next;

    /* Do Filer_CloseDir on root of mount, to close any filer windows */
    cr = ClientFind(mr->client_id, NULL, -1, NULL);
    if (cr)
    {
      if (cr->client_id != 0x4a900)
      {
        sprintf(buf, "Filer_CloseDir %s::%s.$", cr->fsname, mr->mount);
        dprintf (("", "CLOSEDIR: %s\n", buf));
        _swix (OS_CLI, _IN (0), buf);
      }
      /* Display any errors, but we still destroy the mount icon */
      Desk_Error_Check (ClientDismount (mr->client_id, mr->mount_id));
      MountDelete(mr);
    }
    mr = mr_tmp;
    if (!all) break;
  }
  /* Argh! horrible hack to close connected HIDDEN mlist items */
  if (all)
  {
    mlist_record *mrl = (mlist_record *) mlist_anchor.next;
    while (mrl)
    {
      if ((mrl->hidden) && (mrl->connected))
      {
        /* Do Filer_CloseDir on root of mount, to close any filer windows */
        cr = ClientFind(mr->client_id, NULL, -1, NULL);
        if (cr)
        {
          if (cr->client_id != 0x4a900)
          {
            sprintf(buf, "Filer_CloseDir %s::%s.$", cr->fsname, mr->mount);
            dprintf (("", "CLOSEDIR: (hidden mlist) %s\n", buf));
            _swix (OS_CLI, _IN (0), buf);
          }
          ClientDismount (mr->client_id, mr->mount_id);
        }
      }
      mrl = (mlist_record *) mrl->header.next;
    }
  }

  Desk_Hourglass_Off();
}


/*  Handler to take care of the user's IconBar menu choices.
 */
static Desk_bool IconMenuChoice(Desk_event_pollblock *event, mount_record *mr)
{
  Desk_mouse_block 	ptr;
  char          buf[64];
  client_record *cr = NULL;

  Desk_Wimp_GetPointerInfo(&ptr);

  #if 0
  if (mr == NULL) return(Desk_FALSE);
  if (mr != (mount_record *) menuwindow) return(Desk_FALSE);
  #else
  mr = (mount_record *) menuwindow;
  #endif

  switch(event->data.selection[0])
  {
    case imenu_INFO:
      /* Info dbox or submenu */
      switch(event->data.selection[1])
      {
        /* progInfo dbox */
        case -1:
        case iimenu_INFO:
          if (!ptr.button.data.adjust) CreateInfo();
          break;
        default:
          if (!ptr.button.data.adjust) CreateClient(event->data.selection[1]);
          break;
      }
      break;
    case imenu_SHOWALL:
      /* Show all... operation */
      if ((wind_filer.w) && (!Desk_Window_IsOpen(wind_filer.w))) ParseLists(0);
      FilerCreate(0, 0);
      break;
    case imenu_MOUNTS:
      switch(event->data.selection[1])
      {
        case -1:
          break;
        case immenu_OTHER:
          /* Create a connect dbox for a given protocol */
          if ((event->data.selection[2] != -1) && (!ptr.button.data.adjust))
            CreateMount(mount_EMPTY, event->data.selection[2], Desk_TRUE);
          break;
        case immenu_SAVE:
          /* Save configuration to disc */
          MountSaveFile();
          break;
        default:
          /* Create a connect dbox for list item */
          if (!ptr.button.data.adjust)
            CreateMount(mount_MLISTSEL, event->data.selection[1], Desk_TRUE);
          break;
      }
      break;
    case imenu_MOUNTINFO:
      if (!ptr.button.data.adjust) CreateMountInfo(mr);
      break;
    case imenu_OPENROOT:
      switch(event->data.selection[1])
      {
        case -1:
          if (mr->icon_state == ISTATE_OK)
          {
            /* Filer_OpenDir on root of mount */
            Desk_Error_Check(ClientOpenRoot(mr->client_id, mr->mount_id));
          }
          break;
        default:
          /* Filer_OpenDir on root of shared disc 'N' */
          if (mr->menu)
          {
            char open[96];
            char *s;

            Desk_Wimp_DecodeMenu((struct Desk_menu_block *) mr->menu, (int *) &event->data.selection[1],
              (char *) &buf);
            s = strip(buf);
            s = strchr(s, '\x0d');
            if (s) *s = '\0';
            sprintf(open, "Filer_OpenDir Net::%s.$", buf);
            dprintf (("", "OpenRoot: '%s'\n", open));
            Desk_Error_Check(_swix(OS_CLI, _IN (0), open));
          }
          break;
      }
      break;
    case imenu_FREE:
      /* Show free current */
      /* *ShowFree -FS fsname mountname */
      cr = ClientFind(mr->client_id, NULL, -1, NULL);
      sprintf(buf, "ShowFree -FS %s %s", cr->fsname, mr->mount);
      /* Hack for limitations of NetFS */
      if (mr->client_id == 0x4a540) sprintf(buf, "ShowFree -FS %s :%s", cr->fsname, mr->mount);
      /* Hack for Access (long share names) */
      if (mr->client_id == 0x4a900)
      {
        mlist_record *mrl = MountFind(-1, mr->mount, -1, -1);
        if (mrl) sprintf(buf, "ShowFree -FS %s :%s", cr->fsname, mrl->server);
      }
      dprintf (("", "FREE: %s\n", buf));
      Desk_Error_Check(_swix(OS_CLI, _IN (0), buf));
      break;
    case imenu_DISMOUNT:
      /* Dismount */
      switch(event->data.selection[1])
      {
        case -1:
          if (!mr || mr->icon_state != ISTATE_OK) Reset();
        case idmenu_MOUNT:
          Dismount(mr);
          break;
        case idmenu_ALL:
          Dismount(NULL);
          break;
        default:
          break;
      }
      break;
    case imenu_QUIT:
      /* Quit */
#ifdef EXPERT
      if (prog_config.expert)
      {
        dprintf (("", "quit selection %d\n", event->data.selection[1]));
        switch(event->data.selection[1])
        {
          case -1:
          case iqmenu_FILER:
            global_run_state = RunState_ExitFiler;
            break;
          case iqmenu_ALL:
            global_run_state = RunState_ExitAll;
            Dismount(NULL);
            break;
          default:
            break;
        }
      }
      else
#endif
      {
        if ((mr && mr->icon_state != ISTATE_OK) || Close(closetype_BYE, Desk_TRUE, NULL))
        {
          Dismount(NULL);
          Reset();
        }
      }
      break;
    default:
      break;
  }
						/* If ADJUST was used to select, */
  if (ptr.button.data.adjust)              	/* then we keep the menu open.   */
    if (Desk_menu_currentopen != NULL) Desk_Menu_ShowLast();

  return(Desk_TRUE);
}


/*  Handler to take care of the user's Main menu choices.
 */
static Desk_bool MainMenuChoice(Desk_event_pollblock *event, mount_record *mr)
{
  Desk_mouse_block 	ptr;
  wind_record 	*r = (wind_record *) menuwindow;

  Desk_Wimp_GetPointerInfo(&ptr);
  #if 0
  if (mr == NULL) return(Desk_FALSE);
  #else
  UNUSED(mr);
  #endif
  if (r == NULL) return(Desk_FALSE);
  if ((r = FilerFind(r->w, 0, -1, -1)) == NULL) return(Desk_FALSE);
						/* If ADJUST was used to select, */
  switch(event->data.selection[0])
  {
    case mmenu_CONNECT:
      /* Connect submenu */
      if (ptr.button.data.adjust)
      {
        if (Desk_menu_currentopen != NULL) Desk_Menu_ShowLast();
        return(Desk_FALSE);
      }
      switch(event->data.selection[1])
      {
        case -1:
          /* Create a connect dbox for a given protocol */
          if (!clientwindow) return (Desk_FALSE);
          if (select_item > 0) return ((Desk_bool) CreateMount(mount_WINDOW, -1, Desk_TRUE));
            else return ((Desk_bool) CreateMount(mount_CLIENT, clientwindow->client_id, Desk_TRUE));
	  break;
        default:
          /* Create a connect dbox for a given protocol */
          return ((Desk_bool) CreateMount(mount_EMPTY, event->data.selection[1], Desk_TRUE));
          break;
      }
      break;

    case mmenu_DISPLAY:
      /* Display submenu */
      switch(event->data.selection[1])
      {
        case mdmenu_LARGE:
        case mdmenu_SMALL:
        case mdmenu_FULL:
          prog_config.display = event->data.selection[1];
          ConfigWrite();
          if (r->display != event->data.selection[1])
          {
            int loop;
            r->display = event->data.selection[1];
            for (loop = mdmenu_LARGE; loop <= mdmenu_FULL; loop++)
              Desk_Menu_SetFlags(menu_main_d, loop, (r->display == loop), Desk_FALSE);
	    /* Sort messages */
 	    SortMessages(r, r->sort);
            /* Redraw window */
            FilerDisplay(r);
          }
          break;
        case mdmenu_NAME:
        case mdmenu_TYPE:
          prog_config.sort = event->data.selection[1]-2;
          ConfigWrite();
          if (r->sort != event->data.selection[1]-2)
          {
            r->sort = event->data.selection[1]-2;
            Desk_Menu_SetFlags(menu_main_d, mdmenu_NAME, (r->sort == sort_NAME), Desk_FALSE);
            Desk_Menu_SetFlags(menu_main_d, mdmenu_TYPE, (r->sort == sort_PROTOCOL), Desk_FALSE);
	    /* Sort messages */
 	    SortMessages(r, r->sort);
            /* Redraw window */
            FilerDisplay(r);
          }
          break;
        case -1:
        default:
          break;
      }
      break;
    default:
      break;
  }

  if (ptr.button.data.adjust)              	/* then we keep the menu open.   */
    if (Desk_menu_currentopen != NULL) Desk_Menu_ShowLast();

  return(Desk_TRUE);
}


/*  Handler to take care of the user's menu choices.
 *  Because the Menu event is 'non window-related' according to DeskLib, we
 *  can only have one event handler for all menus used.
 */
extern Desk_bool MenuChoice(Desk_event_pollblock *event, mount_record *mr)
{
  Desk_bool result = Desk_FALSE;

  if (Desk_menu_currentopen == menu_icon)
  {
    result = IconMenuChoice(event, mr);
  }
  else if (Desk_menu_currentopen == menu_main)
  {
    result = MainMenuChoice(event, mr);
  }

  if (select_transient)
  {
    FilerSelection();
  }
  return(result);
}


/*  Handler to take care of the user's key presses.
 */
extern Desk_bool KeyPress(Desk_event_pollblock *event, mount_record *mr)
{
  Desk_window_handle w = event->data.key.caret.window;
  mwind_record *mw = MountWindFind(w);

  UNUSED (mr);

  if (w == wind_mounttmp && event->data.key.code == Desk_keycode_RETURN)
  {
    /* Attempt a connection */
    dprintf (("", "KeyPress: mountconnect:connect %p %x\n", mountwindow,w));
    if (MountConnect(mountwindow, w))
    {
      Menu_Close();
      Desk_menu_currentopen = NULL;
    }
    return(Desk_TRUE);
  }
  if (w == wind_mountdom && event->data.key.code == Desk_keycode_RETURN)
  {
    /* Attempt a connection */
    dprintf (("", "KeyPress: domainconnect %p\n", mountwindow));
    if (DomainConnect(mountwindow, w))
    {
      Menu_Close();
      Desk_menu_currentopen = NULL;
    }
    return(Desk_TRUE);
  }
  if ((mw) && (event->data.key.code == Desk_keycode_RETURN))
  {
    /* Attempt a connection */
    if (!mw->domain && MountConnect(mw->ml, mw->w))
    {
      if (Desk_LinkList_ListLength(&mwind_anchor) > 1) MountCaret(mw);
      Desk_Window_Delete(mw->w);
      Desk_LinkList_Unlink(&mwind_anchor, &(mw->header));
      FREE(mw);
    }
    dprintf (("", "KeyPress: domainconnect %p %p\n", mw, mw->ml));
    if ((mw) && mw->domain && DomainConnect(mw->ml, mw->w))
    {
      if (Desk_LinkList_ListLength(&mwind_anchor) > 1) MountCaret(mw);
      Desk_Window_Delete(mw->w);
      Desk_LinkList_Unlink(&mwind_anchor, &(mw->header));
      FREE(mw);
    }
    return(Desk_TRUE);
  }
  /* Not caught - pass to next handler */
  Desk_Wimp_ProcessKey(event->data.key.code);
  return(Desk_TRUE);
}


/*  PollWord Non-Zero message handler
 */
extern Desk_bool PollWordNZ(Desk_event_pollblock *e, mount_record *mr)
{
  _kernel_oserror *err = NULL;

  UNUSED (mr);

  dprintf (("", "PollWordNZ: %d %d\n", pollword, e->data.pollword.contents));

  #if 0
  if (pollword != e->data.words[1]) return(Desk_FALSE);
  #else
  UNUSED (e);
  #endif

  if ((pollword & pollword_ENUMERATE) == pollword_ENUMERATE)
  {
    /* Possibly update the icons on the iconbar */
    dprintf (("", "EnumerateMounts pollword:\n"));
    /* Update icons on iconbar (active mounts) */
    err = ParseMounts(pollword_r0);
  }
  if ((pollword & pollword_ENUMERATENET) == pollword_ENUMERATENET)
  {
    /* Redraw servers window (if open)  */
    dprintf (("", "EnumerateMounts Network pollword:\n"));
    /* Update filer windows (if open) */
    err = ParseLists(pollword_r0);
  }
  if ((pollword & pollword_ENUMERATEPRINT) == pollword_ENUMERATEPRINT)
  {
    /* Update internal copy of printers on network */
    dprintf (("", "EnumeratePrinters Network pollword:\n"));
    err = ParsePrinters(pollword_r0);
  }
  if ((pollword & pollword_REGISTER) == pollword_REGISTER)
  {
    dprintf (("", "RegisterClients pollword:\n"));
    /* Possibly update the icons on the iconbar */
    err = ParseMounts(pollword_r0);
    FileType_Load();
    err = ParseLists(pollword_r0);
  }
  if ((pollword & pollword_DEREGISTER) == pollword_DEREGISTER)
  {
    /* No action required currently */
    dprintf (("", "DeregisterClients pollword:\n"));
    err = ParseMounts(pollword_r0);
    err = ParseLists(pollword_r0);
  }
  if ((pollword & pollword_MOUNTCLI) == pollword_MOUNTCLI)
  {
    /* Do MountCLI calls for real now */
    dprintf (("", "MountCLI pollword:\n"));
    if (pollword_str) MountCLI(pollword_str, true);
    RMAFREE(pollword_str);
  }
  pollword = pollword_NONE;
  pollword_r0 = -1;
  return(Desk_TRUE);
}


/*  MenuWarning message handler for IconBar menu
 */
static Desk_bool IconMenuWarn(Desk_event_pollblock *e, mount_record *mr)
{
  Desk_message_menuwarn *m = &e->data.message.data.menuwarn;
  Desk_menu_ptr open = NULL;

  /* 2000-03-02: BAL
   * Added the following line of code to aid the conversion of Omni to Desk.
   * ANT created a EventMsg_ReleaseRef routine in their DeskLib, whereas
   * the 'mainstream' DeskLib only has EventMsg_Release.
   *
   * The Omni code used to register an EventMsg handler for MenuWarn messages
   * for *every* iconbar icon, using a pointer to the mount_record for
   * that icon as the 'user data' (the Ref bit).  This means that when a
   * MenuWarn message occured, any one of these handlers may get called.  The
   * start of this handler used to check whether it was the 'right' one by
   * comparing the mr value to the menuwindow global variable, which is always
   * set to point to a data structure describing the last thing that a menu
   * was opened for (either a mount_record or wind_record - wind_record things
   * are syphoned off in the main MenuWarn hander before this sub-routine is
   * called).
   *
   * This check is clearly pretty pointless; you might just as well use the
   * value of menuwindow straight off (unless you *completely* distrust your
   * library's event dispatch system, in which case you shouldn't be using it
   * anyway).  This also avoids us having to put ANT's EventMsg_ReleaseRef
   * customisation into our Desk, which is nice.
   */
  mr = menuwindow;

  dprintf (("", "IconMenuWarn: %d %d\n", (int) mr, m->selection[0]));
  /* if (mr != menuwindow) return(Desk_FALSE); */
  dprintf (("", "IconMenuWarn: mr ok\n"));
  switch (m->selection[0])
  {
    case imenu_INFO:
      switch (m->selection[1])
      {
	case iimenu_INFO:	return((Desk_bool) CreateInfo());
				break;

        case -1:       		menu_icon_i = ClientMakeInfoMenu(menu_icon_i);
    				if (menu_icon_i != NULL)
    				{
  				  Desk_Menu_AddSubMenu(menu_icon, imenu_INFO, menu_icon_i);
        			  open = menu_icon_i;
    				} else return((Desk_bool) CreateInfo());
      				break;

      	default:		return((Desk_bool) CreateClient(m->selection[1]));
      				break;
      }
      break;
    case imenu_MOUNTS:
      dprintf (("", "IconMenuWarn: mounts %d\n", m->selection[1]));
      switch (m->selection[1])
      {
        case immenu_OTHER:      menu_icon_mo = ClientMakeMenu(menu_icon_mo);
  				Desk_Menu_AddSubMenu(menu_icon_m, immenu_OTHER, menu_icon_mo);
        			open = menu_icon_mo;
        			break;


        case -1:		if (menu_icon_m) menu_icon_mo = NULL;
        			menu_icon_m = MountMakeMenu(menu_icon_m);
          			Desk_Menu_AddSubMenu(menu_icon, imenu_MOUNTS, menu_icon_m);
        			open = menu_icon_m;
                  		break;

        default:		return ((Desk_bool) CreateMount(mount_MLIST, m->selection[1], Desk_TRUE));
        			break;
      }
      break;

    case imenu_MOUNTINFO:return ((Desk_bool) CreateMountInfo(mr));
    			break;

    case imenu_OPENROOT:open = mr->menu;
      			break;

    case imenu_DISMOUNT:open = menu_icon_d;
      			break;

    case imenu_QUIT:	open = menu_icon_q;
      			break;

    default: 		break;
  }

  if (open == NULL) return(Desk_FALSE);
  Desk_Wimp_CreateSubMenu(open, m->openpos.x, m->openpos.y);
  return(Desk_TRUE);
}


/*  MenuWarning message handler for Main menu
 */
static Desk_bool MainMenuWarn(Desk_event_pollblock *e, mount_record *mr)
{
  Desk_message_menuwarn 	*m = &e->data.message.data.menuwarn;
  Desk_menu_ptr 		open = NULL;
  wind_record 		*r = (wind_record *) menuwindow;

  UNUSED (mr);

  if (r == NULL) return(Desk_FALSE);
  if ((r = FilerFind(r->w, 0, -1, -1)) == NULL) return(Desk_FALSE);
  switch (m->selection[0])
  {
    case mmenu_DISPLAY: open = menu_main_d;
      			break;

    case mmenu_CONNECT: menu_icon_mo = ClientMakeMenu(menu_icon_mo);
  			Desk_Menu_AddSubMenu(menu_main, mmenu_CONNECT, menu_icon_mo);
        		open = menu_icon_mo;
        		break;

    default: 		break;
  }

  if (open == NULL) return(Desk_FALSE);
  Desk_Wimp_CreateSubMenu(open, m->openpos.x, m->openpos.y);
  return(Desk_TRUE);
}


/*  MenuWarning message handler for menus
 */
extern Desk_bool MenuWarn(Desk_event_pollblock *e, mount_record *mr)
{
  if (Desk_menu_currentopen == menu_icon) return(IconMenuWarn(e, mr));
  if (Desk_menu_currentopen == menu_main) return(MainMenuWarn(e, mr));
  return(Desk_FALSE);
}


/*  Send a help message.
 */
static Desk_bool HelpSend(Desk_event_pollblock *event, char *s)
{
  /* Lookup message tag, and attempt help message reply */
  dprintf (("", "HelpSend: '%s'\n", s));
  if (Desk_Msgs_Lookup(s, event->data.message.data.helpreply.text, 200))
  {
    dprintf (("", "HelpSend: sending '%s'\n", event->data.message.data.helpreply.text));
    event->data.message.header.yourref = event->data.message.header.myref;
    event->data.message.header.action = Desk_message_HELPREPLY;
    event->data.message.header.size = 256;
    Desk_Wimp_SendMessage(Desk_event_SENDWANTACK, &event->data.message,
      event->data.message.header.sender, 0);
    return(Desk_TRUE);  /* Only claim message event if successfully reply to it */
  }
  return(Desk_FALSE);
}


/*  Help message handler.
 */
extern Desk_bool HelpHandler(Desk_event_pollblock *event, void *reference)
{
  Desk_menu_ptr 	m = Desk_menu_currentopen;
  Desk_window_handle w = event->data.message.data.helprequest.where.window;
  Desk_icon_handle 	i = event->data.message.data.helprequest.where.icon;
  char 		prefix[16];
  int		buf[25];
  mwind_record 	*mwl = NULL;

  UNUSED (reference);

  /* Look for a matching menu, in case we have interactive help on one of our menus */
  if ((w <= 0) && (w != Desk_window_ICONBAR)) return(Desk_FALSE);
  if ((w == wind_info) || (w == wind_client) || (w == wind_mountinfo)) return(Desk_FALSE);
  if (event->data.message.header.action != Desk_message_HELPREQUEST) return(Desk_FALSE);
  if (w == wind_mounttmp && clientwindow)
  {
    /* Mount dbox - we want context sensitive help here */
    dprintf (("", "HelpHandler: mount client %x icon %d\n", clientwindow->client_id, i));
    sprintf(prefix, "m%s.%d", clientwindow->fsname, i);
    return(HelpSend(event, prefix));
  }
  mwl = MountWindFind(w);
  if (mwl && mwl->ml)
  {
    client_record *cr = ClientFind(mwl->ml->client_id, NULL, -1, NULL);

    /* Mount dbox - we want context sensitive help here */
    dprintf (("", "HelpHandler: mount client %x icon %d\n", cr->client_id, i));
    sprintf(prefix, "m%s.%d", cr->fsname, i);
    return(HelpSend(event, prefix));
  }
  if (w == Desk_window_ICONBAR)
  {
    mount_record *mr = MountIconFind(-1, NULL, i, Desk_TRUE, -1);

    /* Iconbar - one of our icons ? */
    dprintf (("", "HelpHandler: iconbar mr %x icon %d\n", (int) mr, i));
    if (!mr) return(Desk_FALSE);
    if (mr->icon_state != ISTATE_OK) strcpy(prefix, "iconbar.s");
      else strcpy(prefix, "iconbar.f");
    if (prog_config.expert) strcat(prefix, "e");
  }
  else
  {
    /* Fill up buffer to current position - deals with not our menu, menu closed, etc, etc */
    _swi (Wimp_GetMenuState, _INR (0, 3), 1, &buf[0], w, i);
    if (buf[0] == -1) return(Desk_FALSE);
    strcpy(prefix, "");

    /* A valid menu ? */
    if (m == menu_icon)
    {
      switch (buf[0])
      {
        case imenu_INFO: 	if (buf[1] != -1) sprintf(prefix, "miconi.%d", buf[1]);
                          	  else sprintf(prefix, "micon.%d", buf[0]);
                	        break;
        case imenu_MOUNTS:
          switch (buf[1])
          {
            case immenu_OTHER:	if (buf[2] != -1)
            			{
            			  sprintf(prefix, "miconmo.%d", buf[2]);
     				  if (Desk_Icon_GetShade(w,i)) strcpy(prefix, "miconmo.g");
     				  if (ClientCount() == 0) strcpy(prefix, "miconmo.b");
                          	} else sprintf(prefix, "miconm.%d", buf[1]);
                	        break;
            case -1:		sprintf(prefix, "micon.%d", buf[0]);
            			break;
            default:		sprintf(prefix, "miconm.%d", buf[1]);
            			break;
          }
          break;
        case imenu_OPENROOT:	if (buf[1] != -1) sprintf(prefix, "micono.%d", buf[1]);
                            	  else sprintf(prefix, "micon.%d", buf[0]);
        			if (Desk_Icon_GetShade(w,i)) strcat(prefix, "b");
                	        break;
        case imenu_DISMOUNT:	if (buf[1] != -1) sprintf(prefix, "micond.%d", buf[1]);
                            	  else sprintf(prefix, "micon.%d", buf[0]);
#ifdef EXPERT
      				if (prog_config.expert)
      				{
      				  mount_record *mr = (mount_record *) mount_anchor.next;
      				  if (!mr || mr->icon_state != ISTATE_OK) strcat(prefix, "r");
      				}
#endif
				if (Desk_Icon_GetShade(w,i)) strcat(prefix, "b");
                	        break;
        case imenu_QUIT:
#ifdef EXPERT
				if (prog_config.expert)
				{
         			  if (buf[1] != -1) sprintf(prefix, "miconq.%d", buf[1]);
                            	    else sprintf(prefix, "micon.%d", buf[0]);
				}
				else
#endif
				{
				  sprintf(prefix, "micon.%da", buf[0]);
				}
                	        break;
        default:
          sprintf(prefix, "micon.%d", buf[0]);
  	  if (Desk_Icon_GetShade(w,i)) strcat(prefix, "b");
          break;
      }
    }
    if (m == menu_main)
    {
      switch (buf[0])
      {
        case mmenu_DISPLAY:	if (buf[1] != -1) sprintf(prefix, "mmaind.%d", buf[1]);
                            	  else sprintf(prefix, "mmain.%d", buf[0]);
                	        break;
        case mmenu_CONNECT:	if (buf[1] == -1)
        			{
                            	  sprintf(prefix, "mmain.%d", buf[0]);
        			  if ((prog_config.expert) && (select_item == 0))
      				    strcat(prefix, "e");
    				  if (Desk_Icon_GetShade(w,i)) strcat(prefix, "b");
                                }
                                else
                                {
            			  sprintf(prefix, "miconmo.%d", buf[1]);
     				  if (Desk_Icon_GetShade(w,i)) strcpy(prefix, "miconmo.g");
     				  if (ClientCount() == 0) strcpy(prefix, "miconmo.b");
  				}
                	        break;
        default:
          sprintf(prefix, "mmain.%d", buf[0]);
          break;
      }
    }
  }

  /* Lookup message tag, and attempt help message reply */
  if (strlen(prefix) <= 1) return(Desk_FALSE);
  return(HelpSend(event, prefix));
}


/*  General wimp message event handler
 */
extern Desk_bool GenEvent(Desk_event_pollblock *e, void *reference)
{
  UNUSED (reference);

  /* dprintf (("", "GenEvent: %d 0x%x\n", e->type, e->data.message.header.action)); */

  switch (e->data.message.header.action)
  {
   case Desk_message_CLOSEDOWN:
     dprintf (("", "Desk_message_QUIT\n"));
     /* MountDisconnectAll(); */
     global_run_state = RunState_ExitFiler;
     break;

    case Desk_message_DATASAVE:		/* start data save */
      return(DataSave(e->data.message, reference));
      break;

    case Desk_message_DATALOAD:		/* start data load */
      return(DataLoad(e->data.message, reference));
      break;

    case Desk_message_PREQUIT:     		/* give us the chance to object to quit */
      dprintf (("", "Desk_message_PREQUIT\n"));
      if (all_predone) return(Desk_TRUE);
      { int flag;

        /* New RISC OS 3.xx prequit message - take note of flag word */
        if (e->data.message.header.size < 24) flag = 0;
          else flag = (e->data.message.data.words[0] & 0x01);
        /* Desktop quit */
        Dismount(NULL);
      }
      return(Desk_TRUE);
      break;

    case Desk_message_SAVEDESK: 		/* RISC OS 3 'Desktop save' feature */
      { int 	fh = e->data.message.data.words[0];
        char 	buf[256];
        mount_record *mr = (mount_record *) mount_anchor.next;
        
        /* Save configuration to disc */
        MountSaveFile();
        sprintf(buf, "Set "app_DIR"$Path %s\n", omni_getenv(app_DIR"$Path"));
        Desk_File_WriteBytes(fh, buf, strlen(buf));
        sprintf(buf, "Set "app_DIR"$Options %s\n", omni_getenv(app_DIR"$Options"));
        Desk_File_WriteBytes(fh, buf, strlen(buf));
        sprintf(buf, "Run %s", omni_getenv(app_DIR"$Dir"));
        Desk_File_WriteBytes(fh, buf, strlen(buf));
        buf[0] = '\0';
        while (mr != NULL)
        {
          client_record *cr = ClientFind(mr->client_id, NULL, -1, NULL);
          if (cr)
          {
            strcat(buf, " ");
            strcat(buf, mr->mount);
          }
          mr = (mount_record *) mr->header.next;
        }
        strcat(buf, "\n");
        Desk_File_WriteBytes(fh, buf, strlen(buf));
        dprintf (("", "GenEvent: SAVEDESK\n"));
        return(Desk_TRUE);
      }
      break;

    case Desk_message_WINDOWINFO:		/* to work with window Iconizers (eg, Pinboard) */
      {
        Desk_window_handle w = e->data.message.data.words[0];

        dprintf (("", "GenEvent: WINDOWINFO\n"));
        strcpy((char *) &e->data.message.data.words[2], "Omni");
        if (w == wind_filer.w) strcpy((char *) &e->data.message.data.words[4], "Servers");
          else strcpy((char *) &e->data.message.data.words[4], "Mounts");
        e->data.message.header.size = 64;
        e->data.message.header.yourref = e->data.message.header.myref;
        Desk_Wimp_SendMessage(Desk_event_SEND, &(e->data.message),
          e->data.message.header.sender, 0);
      }
      /* _kernel_oscli("Save XXX 8000 +c000"); */
      break;

    case Desk_message_INITTASK:		/* may have to kill off a new 'ShareFS' task */
      dprintf (("", "GenEvent: INITTASK\n"));
      if ((!strcmp((char *) &e->data.message.data.bytes[8], "ShareFS")) &&
          (ClientFind(-1, NULL, -1, "Share")))
      {
        dprintf (("", "GenEvent: kill ShareFS %x\n", e->data.message.header.sender));
        e->data.message.header.size = 20;
        e->data.message.header.yourref = 0;
        e->data.message.header.action = Desk_message_QUIT;
        Desk_Wimp_SendMessage(Desk_event_SEND, &(e->data.message),
          e->data.message.header.sender, 0);
        dprintf (("", "GenEvent: kill ShareFS OK\n"));
        return(Desk_TRUE);
      }
      break;

    case Desk_message_MENUSDELETED: 		/* may have to deselect a transient selection */
      dprintf (("", "GenEvent: MENUSDELETED\n"));
      if (select_transient) FilerSelection();
      break;

    default:
      break;
  }
  return(Desk_FALSE);
}
@


1.11
log
@Build fix
Change was written before AsmUtils-0_19 was fixed to require osvarlen() to have 2 parameters.
Retagged as Omni-2_24.
@
text
@d424 4
a427 1
      mr = MountFind(-1, ir->shortname, -1, ir->client_id);
a1404 22
/*  Return list of mounts.
 */
static char *ActiveMounts(void)
{
  mount_record *mr = (mount_record *) mount_anchor.next;
  char buf[256];

  strcpy(buf, "");
  while (mr != NULL)
  {
    client_record *cr = ClientFind(mr->client_id, NULL, -1, NULL);
    if (cr)
    {
      strcat(buf, mr->mount);
      strcat(buf, " ");
    }
    mr = (mount_record *) mr->header.next;
  }
  return(&buf[0]);
}


d2149 2
a2150 1

d2157 1
a2157 1
        sprintf(buf, "Run %s ", omni_getenv(app_DIR"$Dir"));
d2159 12
a2170 1
        sprintf(buf, "%s\n", ActiveMounts());
@


1.10
log
@Add support for drag-to-iconbar for all of Omni's clients
The bones of support for this were already present, but disabled by the 'EXPERT' switch.
Since the other filers have supported the operation since Ursula, enable & refactor the code to use the same protocol the other filers use.
Allow a non root destinate to be used if the variable 'FSTitle + Filer$DefaultDir' is set.
Remove dead UserDrag code.
Tested with LanManFS and (Omni) NetFiler.

Version 2.24. Tagged as 'Omni-2_24'
@
text
@d53 1
d1233 1
a1233 1
  if (osvarlen(var) > 0)
d1276 1
a1276 1
  if (osvarlen(var) > 0)
@


1.9
log
@Get version number from messages file

Version 2.20. Tagged as 'Omni-2_20'
@
text
@d53 2
a95 11
static int icondrag		= 0;		/* Drag type, 0=none, 1=copy, 2=move */
static bool dragging		= false;	/* DragASprite dragging ? */
#ifdef EXPERT
static bool maydataload		= false;	/* DataLoad via scrap file */
static mount_record *drag_mount = NULL;		/* Mount currently being dragged */
#endif

/* FilerAction WIMP Messages */
#define message_FILERSELECTIONDIRECTORY	0x403
#define message_FILERADDSELECTION    	0x404
#define message_FILERACTION        	0x405
a921 119
/*  Performs a simple xfersend() type operation upon dragging file icon.
 */
#ifdef EXPERT
static void ourxfersend(mount_record *mr)
{
  Desk_drag_block dr;
  Desk_window_state wstate;
  Desk_icon_block icon;
  Desk_mouse_block mouse_str;
  int x_limit = 32768, y_limit = 32768;
  int screen_x0, screen_y0, mouse_x, mouse_y, x0, y0, x1, y1;
  int y;

  /* Desk_Wimp_GetPointerInfo */
  dprintf (("", "ourxfersend: %x\n", (int) mr));
  Desk_Wimp_GetPointerInfo(&mouse_str);
  mouse_x = mouse_str.pos.x;
  mouse_y = mouse_str.pos.y;

  /* Desk_Wimp_GetWindState */
  Desk_Wimp_GetWindowState(mouse_str.window, &wstate);
  screen_x0 = wstate.openblock.screenrect.min.x - wstate.openblock.scroll.x;
  screen_y0 = wstate.openblock.screenrect.max.y - wstate.openblock.scroll.y;

  /* Desk_Wimp_GetIconInfo */
  Desk_Wimp_GetIconState(mouse_str.window, mouse_str.icon, &icon);

  /* Drag from iconbar? */
  if (mouse_str.window != -2) return;
  x0 = screen_x0 + icon.workarearect.min.x - 8;
  y0 = screen_y0 + icon.workarearect.min.y + 32;
  x1 = screen_x0 + icon.workarearect.max.x + 8;
  y1 = screen_y0 + icon.workarearect.max.y + 4;
  dprintf (("", "ourxfersend: %d %d\n", x0, x1));
  if (Desk_Kbd_KeyDown(Desk_inkey_SHIFT)) icondrag = 2;
    else icondrag = 1;
  drag_mount = mr;

  /* RISC OS 3.00 or later, we have DragASprite - test solid drag bit in CMOS */
  dprintf (("", "ourxfersend: drag attempt\n"));
  _swi (OS_Byte, _INR (0, 2) | _OUT (2),
        161, 0x1c, 0,
        &y);
  if ((y & 2) == 2)
  {
    char name[12];
    Desk_wimp_rect b1, b2;

    /* DragASprite bit set, go for it ! */
    dprintf (("", "ourxfersend: drag with dragasprite\n"));
    strcpy(name, (char *) &mr->icon_create.icondata.data.indirecttext.validstring[1]);
    /* strcpy(name, "file_fff"); */
    b1.min.x = x0; b1.max.x = x1;
    b1.min.y = y0; b1.max.y = y1;
    dprintf (("", "ourxfersend: %d %d ", b1.min.x, b1.max.x));
    dprintf (("", "%d %d\n", b1.min.y, b1.max.y));
    Desk_DragASprite_Start(197, (void *) 1, name, &b1, &b2);
    dragging = true;
  }
  else
  {
    /* Set up outline drag */
    dprintf (("", "ourxfersend: drag with outline\n"));
    dr.window    	= -2; 			/* Not relevant */
    dr.type      	= Desk_drag_FIXEDBOX;
    dr.screenrect.min.x	= x0;
    dr.screenrect.min.y = y0;
    dr.screenrect.max.x = x1;
    dr.screenrect.max.y = y1;
    dr.parent.min.x 	= x0 - mouse_x; 	/* Expanded parent by box overlap */
    dr.parent.min.y 	= y0 - mouse_y;
    dr.parent.max.x 	= x1 - mouse_x + x_limit;
    dr.parent.max.y 	= y1 - mouse_y + y_limit;
    Desk_Wimp_DragBox(&dr);
    dragging = false;
  }
  dprintf (("", "ourxfersend: drag started ok\n"));
}
#endif


/*  Filer_Action copy/move messages */
static bool filer_action(void)
{
#ifdef EXPERT
  Desk_mouse_block mousestr;
  Desk_message_block msg;

  /* Desk_Wimp_GetPointerInfo */
  dprintf (("", "filer_action: %x\n", (int) drag_mount));
  Desk_Wimp_GetPointerInfo(&mousestr);

  /* Not completely sure what to do in this case - perhaps we should only
   * fail on drags to our own source icon ?
   */
  if (!drag_mount) return false;
  if ((mousestr.window == -2) && (mousestr.icon == drag_mount->icon)) return false;
  dprintf (("", "filer_action: drag somewhere ok\n"));

  msg.header.size = sizeof(Desk_message_header) + sizeof(Desk_message_datasave);
  msg.header.sender = mousestr.window;
  msg.header.yourref = 0;
  msg.header.action = Desk_message_DATASAVE;
  msg.data.datasave.window = mousestr.window;
  msg.data.datasave.icon = mousestr.icon;
  msg.data.datasave.pos.x = mousestr.pos.x;
  msg.data.datasave.pos.y = mousestr.pos.y;
  msg.data.datasave.filetype = 0xFFF;
  msg.data.datasave.estsize = 0;
  strcpy(msg.data.datasave.leafname, "x");

  Desk_Wimp_SendMessage(Desk_event_SEND, &msg, mousestr.window, mousestr.icon);
  Menu_Close();
#endif

  return false;
}


a988 12
    if ((prog_config.expert) && (Desk_Kbd_KeyDown(Desk_inkey_CTRL)))
    {
      /* Drag out icon on iconbar for copy/move ? */
      if ((!b.data.dragselect) || (mr->icon_state != ISTATE_OK)) return(Desk_FALSE);
      dprintf (("", "Drag attempt!\n"));
      icondrag = 0;
      maydataload = false;
      dragging = false;
      drag_mount = NULL;
      ourxfersend(mr);
      return(Desk_TRUE);
    }
a1208 2
#ifdef EXPERT

d1213 4
a1216 3
  char buf[256];
  client_record *cr = NULL;
  mount_record *mr = NULL;
d1218 1
a1218 1
  /* Reply with a DataSaveAck message */
d1220 3
a1222 1
  if (msg.data.datasave.window != -2) return(Desk_FALSE);
d1228 15
a1242 3
  sprintf(buf, "%s::%s.$.", cr->fsname, mr->mount);
  strcat(buf,msg.data.datasaveack.filename);
  strncpy(msg.data.datasaveack.filename, buf, 211);
d1244 1
a1244 1
  msg.header.size = (strlen(msg.data.datasaveack.filename) | 3)+1+44;
a1247 1
  maydataload = true;
d1252 1
a1252 1
/*
d1254 1
a1254 1
static Desk_bool DataSaveAck(Desk_message_block msg, void *ref)
d1256 8
a1263 7
  int handle = Wimp_NewTask("Filer_Action");
  int tail;
  int rename = 0;
  char dir[256];
  client_record *cr = NULL;
  char root[64];
  _kernel_swi_regs r;
d1265 5
a1269 4
  dprintf (("", "DataSaveAck: %x %x\n", handle, (int) drag_mount));
  if (handle == 0) return(Desk_FALSE);
  if (!drag_mount) return(Desk_FALSE);
  cr = ClientFind(drag_mount->client_id, NULL, -1, NULL);
a1270 39
  dprintf (("", "DataSaveAck: '%s'\n", msg.data.datasaveack.filename));
  if (!Desk_stricmp(msg.data.datasaveack.filename, "<Wimp$Scrap>.x")) return(Desk_FALSE);
  if (!Desk_stricmp(msg.data.datasaveack.filename, "<Wimp$ScrapDir>.x")) return(Desk_FALSE);

  /* If a move operation, FilerAction operation 6 */
  if (icondrag == 2) rename = 6;
  tail = strlen(msg.data.datasaveack.filename);
  strncpy(dir, msg.data.datasaveack.filename, tail-2);
  dir[tail-2] = '\0';
  msg.header.yourref = 0;
  msg.header.action = (Desk_message_action) Desk_message_FILERSELECTIONDIRECTORY;
  sprintf(root, "%s::%s.$\0", cr->fsname, drag_mount->mount);
  strcpy((char *) &msg.data.words[0], root);
  Desk_Wimp_SendMessage(Desk_event_SEND, &msg, handle, NULL);

  /* Add file selection (tricky!) */
  msg.header.yourref = 0;
  msg.header.action = (Desk_message_action) Desk_message_FILERADDSELECTION;
  r.r[0] = 9;
  r.r[1] = (int) root;
  r.r[2] = (int) &msg.data.words[0];
  r.r[3] = 1;
  r.r[4] = 0;
  r.r[5] = 64;
  r.r[6] = 0;
  do
  {
    _kernel_swi(OS_GBPB, &r, &r);
    if (r.r[3] != 0) Desk_Wimp_SendMessage(Desk_event_SEND, &msg, handle, NULL);
  } while (r.r[4] != -1);
  msg.data.words[0] = rename;
  msg.data.words[1] = 1;
  strcpy((char *) &msg.data.words[2], dir);
  msg.header.yourref = 0;
  msg.header.action = (Desk_message_action) Desk_message_FILERACTION;
  Desk_Wimp_SendMessage(Desk_event_SEND, &msg, handle, NULL);
  icondrag = 0;
  return(Desk_TRUE);
}
d1272 8
d1281 1
a1281 6
/*
 */
static Desk_bool DataLoad(Desk_message_block msg, void *ref)
{
  dprintf (("", "DataLoad:\n"));
  if (maydataload)
d1283 1
a1283 1
    /* Load from application */
a1287 1
    maydataload = false;
d1291 5
a1295 19
    int handle = Wimp_NewTask("Filer_Action");
    int tail;
    Desk_bool rename;
    char dir[256];
    char leaf[32];
    char *name = msg.data.dataload.filename;
    client_record *cr = NULL;
    mount_record *mr = NULL;

    /* Load from file/directory
       Setup some cunning filer_action move/copy action with messages */
    dprintf (("", "DataLoad: load from filer\n"));
    if (handle == 0) return(Desk_FALSE);;
    mr = MountIconFind(-1, NULL, msg.data.dataload.icon, Desk_TRUE, -1);
    if (mr == NULL) return(Desk_FALSE);
    cr = ClientFind(mr->client_id, NULL, -1, NULL);
    if (cr == NULL) return(Desk_FALSE);

    /* Send ack to application (filer) */
d1297 1
a1297 1
    msg.header.action = Desk_message_DATALOADOK;
a1298 22

    rename = Desk_Kbd_KeyDown(Desk_inkey_SHIFT);
    tail = strlen(name);
    while (tail > 0 && name[tail-1] != '.' && name[tail-1] != ':') tail--;
    strncpy(dir, name, tail-1);
    dir[tail-1] = '\0';
    strcpy(leaf, &name[tail]);

    msg.header.yourref = 0;
    msg.header.action = (Desk_message_action) Desk_message_FILERSELECTIONDIRECTORY;
    strcpy((char *) &msg.data.words[0], dir);
    Desk_Wimp_SendMessage(Desk_event_SEND, &msg, handle, NULL);
    msg.header.yourref = 0;
    msg.header.action = (Desk_message_action) Desk_message_FILERADDSELECTION;
    strcpy((char *) &msg.data.words[0], leaf);
    Desk_Wimp_SendMessage(Desk_event_SEND, &msg, handle, NULL);
    msg.data.words[0] = rename;
    msg.data.words[1] = 1;
    sprintf((char *) &msg.data.words[2], "%s::%s.$\0", cr->fsname, mr->mount);
    msg.header.yourref = 0;
    msg.header.action = (Desk_message_action) Desk_message_FILERACTION;
    Desk_Wimp_SendMessage(Desk_event_SEND, &msg, handle, NULL);
a1299 3
  return(Desk_TRUE);
}

d1301 4
a1304 10
/*  A DataLoad attempt to our iconbar icon(s) ?
 */
static Desk_bool DataLoadAck(Desk_message_block m, void *ref)
{
  /* Redundant stage - we don't care if receiver died or not */
  dprintf (("", "DataLoadAck:\n"));
  return(Desk_FALSE);
}

#endif /* EXPERT */
a1305 16

/*  User Drag message handler
 */
extern Desk_bool UserDrag(Desk_event_pollblock *e, mount_record *mr)
{
  UNUSED (e);
  UNUSED (mr);

  dprintf (("", "UserDrag:\n"));
  if (dragging)
  {
    /* Clean up DragASprite workspace */
    Desk_DragASprite_Stop();
    dragging = false;
  }
  if (icondrag > 0) filer_action();
d1996 1
a1996 1
  if ((w <= 0) && (w != -2)) return(Desk_FALSE);
d2016 1
a2016 1
  if (w == -2)
a2141 1
#ifdef EXPERT
a2145 4
    case Desk_message_DATASAVEACK:		/* data save ack */
      return(DataSaveAck(e->data.message, reference));
      break;

a2149 5
    case Desk_message_DATALOADACK:		/* data load ack */
      return(DataLoadAck(e->data.message, reference));
      break;
#endif

@


1.8
log
@  2 bug fixes to avoid AODT failures

Detail:
  c.FileType c. 298 .. initialise strings to null
  c.Event c.line 1943 .. dont use mw if it has been freed

Admin:
  tested at castle
  castle added ip


Version 2.13. Tagged as 'Omni-2_13'
@
text
@d46 2
a70 2
#include "VersionNum"

d117 2
d122 11
a132 1
    Desk_Icon_SetText(wind_info, info_version, Module_FullVersion " (" Module_ApplicationDate ")");
@


1.7
log
@Adds BASIC version of houron and houroff so it'll run on machines with
old HourGlass modules (no *HON *HOFF).
Enlarged tiddy little buttons in connection dialogue.
Reorganised iconbar menu so it makes sense,and changed help.
Increased RMEnsure to require Utility module 3.5 due to use of MSR/MRS.

Version 2.12. Tagged as 'Omni-2_12'
@
text
@d1928 1
d1958 1
a1958 1
    if (mw->domain && DomainConnect(mw->ml, mw->w))
@


1.6
log
@  * Fixed Omni$Running system variable bug introduced in previous revision.
  * Fixed bug where Quit->All in expert mode would only quit the filer and
    not the whole filing system.
  * Fixed bug where just quitting the filer and attempting to re-run OmniClient
    would produce the error "Some protocols in the mounts file are not
    available, and have been ignored".
  * Added resources and fleshed-out install phase.
Detail:
  * An internal error would be generated every time the Omni$Running system
    variable was read.  This was my fault, due to a change I made when removing
    the s.Base file in the previous revision .  The code variable block used
    to reference a location defined in s.Base, in which to store the generated
    string in.  I changed this to store it in the code variable block directly,
    but forgot to change an LDR to an ADR at the same time.

  * The application cleanup code was calling InitVars to reset global variables
    to their initial state, thus trashing the global_run_state variable which
    indicated that the entire filing system should be killed.  This was
    overly paranoid, as InitVars is always called on initialisation, which is
    perfectly adequete.  c.corefini removed as a result, as all it did was
    call InitVars.

  * The failure to restart cleanly on every 2nd attempt was caused by a
    horrible interaction between OmniClient's finalisation code, it's !Run
    file, callbacks and service calls.  It's too complicated to explain here,
    so if you're interested then ask me.  It's been hackily fixed for now by
    placing a call to Inet:Utils.TriggerCBs in Omni's !Run file, between the
    place where it kills the OmniClient module and reloads it (if it detects
    that the module is still running, but the task is not).  A cleaner solution
    should be implemented by making OmniClient able to restart its task in an
    intelligent manner, without requiring the module to be killed.

  * Previously, only Messages, Templates and Templates3D resource files were
    present, and nothing was done with them.  Added the remaining resources
    and fleshed-out the install phase to contruct the full application
    distribution instead of just copying the OmniClient module.
Admin:
  Tested on a Risc PC.

Version 2.09. Tagged as 'Omni-2_09'
@
text
@d120 1
a120 1
    Desk_Icon_SetText(wind_info, info_version, Module_FullVersion " (" Module_Date ")");
d1076 1
a1076 1
        menu_icon_d : NULL);
d1809 2
d1984 2
@


1.5
log
@  * Fixed Bugzilla ID 21, where typing *RMKill OmniClient from the command
    line would cause the error "free failed, (heap overwritten)" if task part
    of the OmniClient module task was running at the time, rendering
    OmniClient unusable and unloadable until the next reboot.
  * Fixed Bugzilla ID 19, where killing a protocol module when OmniClient was
    already loaded would cause an "Invalid Wimp Operation In This Context"
    error.

  * Miscellaneous bug fixes and tidy-ups.
Detail:
  * The "free failed, (heap overwritten)" error is due to a bug in the
    SharedCLibrary, triggered by OmniClient calling getenv in the C library
    from its task.  The bug results from the implementation of getenv calling
    malloc - see Bugzilla ID 28 for further details.  This has been worked
    around by copying the C Library's getenv routine into OmniClient,
    renaming it to omni_getenv, and making all calls to getenv call
    omni_getenv instead; if the malloc happens from within the task rather
    than from within the C library, then things are fine.
  * The "Invalid Wimp Operation In This Context" error is caused by OmniClient
    calling Wimp_CreateMenu with R0=-1 from within the SWI handler that deals
    with protocol module deregistration.  The reasoning for this is that if,
    for example, you have the Mounts menu open, it becomes invalid at this point
    as all of the dying protocol module's mounts become unavailable.  However,
    it is not legal to call Wimp_CreateMenu at this point as you are not in
    your Wimp task context!

    The call to Wimp_CreateMenu has simply been removed.  This doesn't appear
    to cause a problem if you have a menu open with mounts belonging to the
    dying protocol module - attemping to perform an operation on one causes a
    sensible error to be reported.  A possible future enhancement would be to
    use OmniClient's pollword mechanism to cause the task to close any open
    menus on the module's behalf.

    The reason it never occurred before is that it used to call the X-bit-set
    form of the SWI and didn't check the error returned.  When I modified
    OmniClient to use Desk instead of DeskLib, I changed most SWI calls from
    the task part to be non-X-bit-set calls, and used Desk's psuedo-exception
    system to catch and report all errors at the top level of the
    application.

  * Uses AsmUtils to obtain Image$$RO$$Base.

  * Potential write through null pointer fixed in string duplication routines
    cpystr and cpyrma - they weren't checking the result of their allocation
    calls.

  * Replaced the somewhat confusing all_done variable, which could take (magic)
    values between 0 and 2 inclusive to cause different sorts of quit, with
    an enumerated type called RunState.

  * Issuing of Service_OmniClient (dying) in module finalisation made
    unconditional (was previously conditional on the value of all_done), as it's
    most definitely always dying if the finalisation routine is called.  I
    think this was a hangover from when the module finalisation code was
    implemented as an atexit handler.

  * Exit code in the task does not issue Service_OmniClient (dying) if the
    entire filing system is being killed off - this will happen in module
    finalisation, which will be called as a result of the task calling
    OS_ExitAndDie.  This can only happen in "expert" builds.

  * Fixed allocation of too much memory in ItemParse routine!  It dynamically
    creates an array of pointers to structures, but was allocating enough space
    for an array of structures.

  * Fixed potential memory leak in PrintListServers routine - was calling
    realloc and assigning the result directly to the original pointer, instead
    of assigning it to a temporary and only updating the original poiiner if
    the realloc succeeds.

  * Fixed potential null pointer dereference in SortMessages routine - had a
    check for a null pointer parameter at the start, but managed to dereference
    the pointer before the check as part of a variable initialisation.

  * Added all documents from ANT's Docs directory into ours.

Admin:
  Tested on a Risc PC.
  Fixes Bugzilla bugs 19 & 21.

Version 2.08. Tagged as 'Omni-2_08'
@
text
@d1763 1
@


1.4
log
@  Fixed a bug where submenus would sometimes not open.
Detail:
  More fallout from the modifications to use Desk's standard event handling
  mechanisms rather that ANT's customised one.

  Releasing Wimp message event claims in Desk releases all handlers
  registered for that message, not just one.  The Omni code was
  (re)registering the event handlers for all new mounts, so if you had more
  than one mount active and did a dismount, the message event handler would
  be deregistered for all the other active mounts as well.  This means you'd
  no longer revceive MenuWarn messages, so submenus wouldn't be opened.

  All mount event handlers with the exception of the ButtonClick handler are
  now only registered once, irrespective of the number of active mounts, and
  only deregistered once there are no active mounts.  Non-message event
  handlers do not suffer the problem described above, so the ButtonClick
  handler is safe.  The reason it is still registered for each mount is that
  the handler actually uses the user-supplied data for context, whereas none
  of the other handlers did; they obtain it from global variables instead -
  lovely.
Admin:
  Compiled and tested on a Risc PC.

Version 2.07. Tagged as 'Omni-2_07'
@
text
@d188 1
a188 1
  if ((cr == NULL) || (cr->fsname == NULL)) return(getenv("Omni$User"));
d190 1
a190 1
  if ((s = getenv(buf)) == NULL) s = getenv("Omni$User");
d1767 1
a1767 1
            all_done = 1;
d1770 1
a1770 1
            all_done = 2;
d2345 1
a2345 1
     all_done = 1;
d2386 1
a2386 1
        sprintf(buf, "Set "app_DIR"$Path %s\n", getenv(app_DIR"$Path"));
d2388 1
a2388 1
        sprintf(buf, "Set "app_DIR"$Options %s\n", getenv(app_DIR"$Options"));
d2390 1
a2390 1
        sprintf(buf, "Run %s ", getenv(app_DIR"$Dir"));
@


1.3
log
@  * Fixed bug which I introduced in previous version, where errors that
    occurred when trying to connect to a mount would cause two errors to be
    reported.
Detail:
  * When I went through blindly changing all _kernel_swi or Desk_SWI calls
    to _swix, I failed to notice that one or two of the calls rely on the
    output parameters being filled in even if an error occurs - _swix does not
    do this.  I've now created a set of type safe C veneers for all calls to
    client modules, which use _swix or _kernel_swi as necessary.  This has the
    additional benefit of making the code more readable and getting rid of
    quite a few uses of magic numbers.
Admin:
  * Compiled and tested on a Risc PC.

Version 2.06. Tagged as 'Omni-2_06'
@
text
@d1055 1
a1055 1
  dprintf (("", "ButtonClick: 1 mw %p mw->domain %d\n", mw, mw ? mw->domain : -1));
d1644 2
d1648 3
d1794 1
a1794 1
  return(Desk_FALSE);
d1806 1
d1808 1
d1884 1
a1884 1
  return(Desk_FALSE);
d1895 14
a1908 3
  if (Desk_menu_currentopen == menu_icon) result = IconMenuChoice(event, mr);
    else if (Desk_menu_currentopen == menu_main) result = MainMenuChoice(event, mr);
  if (select_transient) FilerSelection();
d1977 3
a1979 1
  dprintf (("", "PollWordNZ: %d %d\n", pollword, e->data.words[1]));
d1981 2
d2027 1
a2027 1
  return(Desk_FALSE);
@


1.2
log
@  Several major bugfixes and further tidying to make Omni fit into our
  build environment better.
Detail:
  * Bug fix: ClientList function (Client.c) creates a textual menu desription
    for a list of clients (Info and Mounts submenus).  The description was
    generated on the stack and a pointer to it was returned.  The buffer is now
    static.
  * Bug fix: select or adjust clicks on the Omni icon just after it's loaded
    would kill the task part of Omni.  FilerCreate function (List.c) always
    calls FilerDelete, which would always attempt to close any existing filer
    window.  However, on the first call, no window exists so it passes the Wimp
    a 0 window handle.  This only appeared to happen on RISC OS 4, but I suspect
    this is to do with RISC OS 4's stricter protection of zero page.  Current
    fix is for FilerDelete to check if window handle is 0 before closing it;
    this is not very elegant - would be nicer to only call FilerDelete when the
    window was actually closed.
  * Bug fix: writable icon handling overhauled completely.  Many of the buffers
    which Omni would read the contents of writable icons into were too short
    to hold the maximum amount of text allowed in the icon.  New Icon_GetText
    call added (ExtLib.c) to allow Omni to work directly on indirected icon
    buffers wherever possible, thus removing the whole issue.
  * Stripped commented-out code from several places.
  * Changed use of Desk_bool to bool in most places.  This is a bit grim, but
    the way Desk_bool is implemented means you need to cast it in many places,
    which is even more grim.
  * Removed a few error assignements(!) because
    a) they weren't even being checked
    b) Desk's psuedo-exception system should now catch them
  * Got rid of home-grown strcasecmp calls and used Desk's instead.
  * Removed many local constants definitions and get them from system header
    files instead.
  * Removed Hdrs.h which would include *every* header file in *every* C file
    in the interests of compilation times.  C files now only include what they
    need.
  * Reimplemented the fully recursive Menu_Dispose along the lines of the
    non-recursive Desk_Menu_Dispose, which had changed since ANT's DeskLib
    split-off.
  * Altered quite a bit of code to prevent compiler warnings (mainly
    "use of '=' in condition context" and "variable declared but not used").
  * Uses 'proper' module finalisation instead of atexit in the interests of
    consistency and symmetry.
  * Added MemCheck support.
  * Reimplemented rma_alloc and rma_free in C (side effect of MemCheck support).
  * Altered assembler to use system header files instead of local ones.
  * Omni previously used a seeming random mixture of _kernel_swi and Desk_SWI
    SWI veneers.  All have now been changed to use _swix/_swi as appropriate.
  * Converted to use srccommit.
Admin:
  Files removed:
   c.Error
   c.StrCaseCmp
   h.Debug
   h.Hdrs
   h.ModuleWrap
   h.OmniClient
   h.StrCaseCmp
   hdr.Macros
   hdr.RegDefs
   hdr.SwiNos

  Files added:
   Docs.DeskLibDiffs
   Docs.EventHandling
   h.Omni

  * Compiled.
  * All windows, menus checked to make sure they at least display.
  * Played around with a new NFS and LanMan mounts.
  * Basically, there shouldn't be any showstoppers, but the change from a very
    old DeskLib to Desk is a large one.  I'd be surprised if there aren't a
    few problems and this should definitely be thrashed a bit by people
    willing to do so before anyone has any confidence in it.



Version 2.05. Tagged as 'Omni-2_05'
@
text
@d111 1
a111 1
 *  Return Desk_FALSE if cannot create, else Desk_TRUE.
d136 1
a136 1
 *  Return Desk_FALSE if cannot create, else Desk_TRUE.
d662 3
a664 3
      if (_swix (cr->client_id, _INR (0, 2) | _OUT (1),
                 8, ir->server_id, ir->fullname,
                 &flags) != NULL)
d1131 1
a1131 1
        Desk_Error_Check (_swix (mr->client_id, _INR (0, 1), 7, mr->mount_id));
d1541 1
a1541 1
      _swix (cr->client_id, _IN (0), 17);
d1578 1
a1578 1
      Desk_Error_Check (_swix (mr->client_id, _INR (0, 1), 1, mr->mount_id));
d1602 1
a1602 1
          _swix (mr->client_id, _INR (0, 1), 1, mr->mount_id);
d1699 1
a1699 1
            Desk_Error_Check(_swix(mr->client_id, _INR (0, 1), 6, mr->mount_id));
@


1.1
log
@Initial revision
@
text
@d31 19
d51 8
a58 5
#include "Hdrs.h"
#include "Desk/KeyCodes.h"
#include "Desk/Kbd.h"
#include "Desk/Time.h"
#include "Desk/DragASpr.h"
d60 10
a69 1
#include "Close.h"
d85 2
a86 2
Desk_window_handle 	select_wind 	= NULL;
Desk_bool		select_transient= Desk_FALSE;
d88 1
a88 1
Desk_bool		all_predone	= Desk_FALSE;
d95 1
a95 1
static Desk_bool dragging		= Desk_FALSE;	/* DragASprite dragging ? */
d97 1
a97 1
static Desk_bool maydataload		= Desk_FALSE;	/* DataLoad via scrap file */
a105 2
#define OS_Byte                        	0x000006

d113 1
a113 1
static Desk_bool CreateInfo(void)
d119 3
a121 4
    if (wind_info == NULL) return(Desk_FALSE);
    Desk_Msgs_Lookup("app.version:", tmp, 29);
    Desk_Icon_SetText(wind_info, info_version, tmp);
    Desk_Msgs_Lookup("app.copy:", tmp, 29);
d124 1
a124 1
    Desk_Msgs_Lookup("app.license:", tmp, 29);
d126 1
a126 1
    Desk_Msgs_Lookup("app.licensee:", tmp, 29);
d131 1
a131 1
  return(Desk_TRUE);
d138 1
a138 1
static Desk_bool CreateClient(int item)
d143 1
a143 1
  TRACE1("CreateClient: %d\n", item);
d146 1
a146 1
  if (!wind_client) return(Desk_FALSE);
d148 2
a149 2
  if (item < 0) return(Desk_FALSE);
  if ((cr = ClientFind(-1, NULL, item, NULL)) == NULL) return(Desk_FALSE);
d154 1
a154 1
    Desk_Msgs_Lookup("cinfo.fs:", buf, 63);
d156 1
a156 1
    Desk_Msgs_Lookup("cinfo.print:", buf, 63);
d158 1
a158 1
    Desk_Msgs_Lookup("cinfo.fsprint:", buf, 63);
d176 1
a176 1
  return(Desk_TRUE);
d202 1
a202 1
  TRACE("MountWindFind:\n");
d220 1
a220 1
static Desk_bool DboxFilled(Desk_window_handle w, client_record *cr, int flags)
d222 2
a223 1
  char s[96];
d227 11
a237 13
  Desk_Icon_GetText(w, mount_mount, s);
  TRACE2("DboxFilled: '%s' %d\n", s, strlen(s));
  if (strlen(s) == 0) goto false;
  Desk_Icon_GetText(w, mount_server, s);
  if (strlen(s) == 0) goto false;
  Desk_Icon_GetText(w, mount_path, s);
  if ((flagSET(cr, flag_PATH)) && (strlen(s) == 0)) goto false;
  Desk_Icon_GetText(w, mount_user, s);
  if ((flagSET(cr, flag_USER)) && (strlen(s) == 0)) goto false;
  Desk_Icon_GetText(w, mount_password, s);
  if ((flagSET(cr, flag_PW)) && (strlen(s) == 0)) goto false;
  Desk_Icon_GetText(w, mount_auth, s);
  if ((flagSET(cr, flag_AUTH)) && (strlen(s) == 0)) goto false;
d239 2
a240 4
  return(Desk_TRUE);
false:
  if (flags > -1) cr->flags = old_flags;
  return(Desk_FALSE);
d246 1
a246 1
static Desk_bool DomainFilled(Desk_window_handle w, client_record *cr)
d248 3
a250 1
  char s[96];
d252 1
a252 7
  Desk_Icon_GetText(w, domain_domain, s);
  if ((flagSET(cr, flag_AUTH)) && (strlen(s) == 0)) return(Desk_FALSE);
  Desk_Icon_GetText(w, domain_user, s);
  if ((flagSET(cr, flag_USER)) && (strlen(s) == 0)) return(Desk_FALSE);
  Desk_Icon_GetText(w, domain_password, s);
  if ((flagSET(cr, flag_PW)) && (strlen(s) == 0)) return(Desk_FALSE);
  return(Desk_TRUE);
d327 1
a327 1
extern Desk_bool CreateDomain(int src, int item, Desk_bool dynamic)
d341 2
a342 2
  Desk_bool result = Desk_TRUE;
  Desk_bool ok = Desk_FALSE;
d344 2
a345 2
  TRACE2("CreateDomain: %d %d\n", src, item);
  TRACE1("CreateDomain: dynamic %s\n", (dynamic) ? "YES" : "NO");
d355 1
a355 1
  if (!w) return(Desk_FALSE);
d362 1
a362 1
      return(Desk_FALSE);
d374 1
a374 1
      if (!dynamic) return(Desk_FALSE);
d376 1
a376 1
        { if ((cr = ClientFind(item, NULL, -1, NULL)) == NULL) return(Desk_FALSE); }
d378 2
a379 2
        { if ((cr = ClientFind(-1, NULL, item, NULL)) == NULL) return(Desk_FALSE); }
      TRACE("CreateDomain: found ok\n");
d391 1
a391 1
      if ((!dynamic) && (src == mount_MLISTSEL)) return(Desk_FALSE);
d400 2
a401 2
        if (item < 0) return(Desk_FALSE);
        if ((mr = MountFind(-1, NULL, item, -1)) == NULL) return(Desk_FALSE);
d403 1
a403 1
      if ((cr = ClientFind(mr->client_id, NULL, -1, NULL)) == NULL) return(Desk_FALSE);
d410 1
a410 1
      if (!dynamic) return(Desk_FALSE);
d412 2
a413 2
      if (item <= 0) return(Desk_FALSE);
      if (!clientwindow) return(Desk_FALSE);
d415 1
a415 1
        return(Desk_FALSE);
d417 1
a417 1
      TRACE2("CreateDomain: post filerfind wr %x select_wind %x\n",(int) wr, (int) select_wind);
d419 3
a421 3
      TRACE2("CreateDomain: post itemfind ir %x select_item %x\n",(int) ir, (int) select_item);
      if (wr && ir && (select_wind != wind_filer.w) && ir->alias &&
          (mr = MountFind(-1, ir->shortname, -1, ir->client_id)))
d441 1
a441 1
      return(Desk_FALSE);
d459 1
a459 1
  TRACE("CreateDomain: show dialogue\n");
d490 1
a490 1
    TRACE("CreateDomain: connection attempt!\n");
d504 1
a504 1
  return(result);
d511 1
a511 1
extern Desk_bool CreateMount(int src, int item, Desk_bool dynamic)
d518 1
a518 1
  char title[96];
d525 2
a526 2
  Desk_bool result = Desk_TRUE;
  Desk_bool ok = Desk_FALSE;
d529 2
a530 2
  TRACE2("CreateMount: %d %d\n", src, item);
  TRACE1("CreateMount: dynamic %s\n", (dynamic) ? "YES" : "NO");
d537 1
a537 1
      if (!dynamic) return(Desk_FALSE);
d539 1
a539 1
        { if ((cr = ClientFind(item, NULL, -1, NULL)) == NULL) return(Desk_FALSE); }
d541 1
a541 1
        { if ((cr = ClientFind(-1, NULL, item, NULL)) == NULL) return(Desk_FALSE); }
d543 1
d548 1
a548 1
      if ((!dynamic) && (src == mount_MLISTSEL)) return(Desk_FALSE);
d557 2
a558 2
        if (item < 0) return(Desk_FALSE);
        if ((mr = MountFind(-1, NULL, item, -1)) == NULL) return(Desk_FALSE);
d561 1
a561 1
      if ((cr = ClientFind(mr->client_id, NULL, -1, NULL)) == NULL) return(Desk_FALSE);
d563 1
d565 1
a565 1
      if (!dynamic) return(Desk_FALSE);
d567 2
a568 2
      if (item <= 0) return(Desk_FALSE);
      if (!clientwindow) return(Desk_FALSE);
d570 1
a570 1
        return(Desk_FALSE);
d572 1
d574 1
a574 1
      return(Desk_FALSE);
d577 1
a577 1
  if (flagSET(cr, flag_SPECIAL)) return(CreateDomain(src, item, dynamic));
d588 1
a588 1
  if (!w) return(Desk_FALSE);
d595 1
a595 1
      return(Desk_FALSE);
d599 1
a599 1
    mw->domain = Desk_FALSE;
d607 1
a607 1
      if (!dynamic) return(Desk_FALSE);
d609 1
a609 1
        { if ((cr = ClientFind(item, NULL, -1, NULL)) == NULL) return(Desk_FALSE); }
d611 2
a612 2
        { if ((cr = ClientFind(-1, NULL, item, NULL)) == NULL) return(Desk_FALSE); }
      TRACE("CreateMount: found ok\n");
d629 1
a629 1
      if ((!dynamic) && (src == mount_MLISTSEL)) return(Desk_FALSE);
d638 2
a639 2
        if (item < 0) return(Desk_FALSE);
        if ((mr = MountFind(-1, NULL, item, -1)) == NULL) return(Desk_FALSE);
d641 1
a641 1
      if ((cr = ClientFind(mr->client_id, NULL, -1, NULL)) == NULL) return(Desk_FALSE);
d647 1
d649 1
a649 1
      if (!dynamic) return(Desk_FALSE);
d651 2
a652 2
      if (item <= 0) return(Desk_FALSE);
      if (!clientwindow) return(Desk_FALSE);
d654 1
a654 1
        return(Desk_FALSE);
d656 1
a656 1
      TRACE2("CreateMount: post filerfind wr %x select_wind %x\n", (int) wr, (int) select_wind);
d658 3
a660 2
      TRACE2("CreateMount: post itemfind ir %x select_item %x\n", (int) ir, (int) select_item);
      if ((!wr) || (!ir)) return(Desk_FALSE);
d662 4
a665 1
      if (Desk_SWI(3,2, cr->client_id, 8, (int) ir->server_id,(int) ir->fullname, NULL,&flags))
d667 2
d672 2
a673 1
        if ((ir->alias) && (mr = MountFind(-1, ir->shortname, -1, ir->client_id)))
d675 2
a676 5
          /* From an alias entry! Get the mlist pointer */
          TRACE("CreateMount: from alias!\n");
          i = CreateMountList(w, mr, cr);
          Desk_Wimp_SetIconState(w, mount_DELETE, Desk_icon_DELETED, Desk_icon_DELETED);
          if (MountIconFind(-1, ir->shortname, -1, Desk_TRUE, -1))
d678 11
a688 3
            /* We already have a connected mount with this alias, reset */
            Desk_Icon_SetText(w, mount_mount, "");
            i = mount_mount;
a689 1
          break;
d710 1
a710 1
          return(Desk_FALSE);
d718 1
a718 1
          TRACE2("CreateMount: title '%s' ir->shortname '%s'\n", title, ir->shortname);
d733 1
a733 1
          return(Desk_FALSE);
d739 1
a739 1
        TRACE2("CreateMount: title '%s' ir->shortname '%s'\n", title, ir->shortname);
d756 1
a756 1
      return(Desk_FALSE);
d777 1
a777 1
  TRACE2("CreateMount: flags %x flag_AUTH %d\n", cr->flags, flagSET(cr, flag_AUTH));
d779 1
a779 1
  TRACE("CreateMount: show dialogue\n");
d811 1
a811 1
    TRACE("CreateMount: NetFS hack!\n");
d818 5
a822 2
      TRACE1("CreateMount: NetFS found item '%s'\n", buf);
      result = !Desk_Error_Check(Desk_SWI(1,0, OS_CLI, buf));
d827 1
a827 1
      return(result);
d834 1
a834 1
    TRACE("CreateMount: connection attempt!\n");
d848 1
a848 1
  return(result);
d856 1
a856 1
static Desk_bool CreateMountInfo(mount_record *mr)
a857 1
  Desk_os_error *err = NULL;
d862 2
a863 2
  if (!mr) return(Desk_FALSE);
  if ((cr = ClientFind(mr->client_id, NULL, -1, NULL)) == NULL) return(Desk_FALSE);
d867 21
a887 1
    if (wind_mountinfo == NULL) return(Desk_FALSE);
d889 9
a897 20
  TRACE2("CreateMountInfo: %x %x\n", (int) mr, mr->mount_id);
  r1 = r2 = r3 = r4 = r5 = NULL;
  err = Desk_SWI(2,6, cr->client_id, 9,mr->mount_id, NULL,&r1,&r2,&r3,&r4,&r5);
  if (err)
  {
    Desk_Error_Check(err);
    return(Desk_FALSE);
  }
  Desk_Msgs_printf(title, "mount.about", cr->clientname);
  Desk_Window_SetTitle(wind_mountinfo, title);
  Desk_Icon_SetText(wind_mountinfo, minfo_server, r1 ? r1 : "");
  Desk_Icon_SetText(wind_mountinfo, minfo_user, ((r2) && (flagSET(cr, flag_USER))) ? r2 : "");
  Desk_Icon_SetText(wind_mountinfo, minfo_mount, r3 ? r3 : "");
  Desk_Icon_SetText(wind_mountinfo, minfo_path, ((r4) && (flagSET(cr, flag_PATH))) ? r4 : "");
  Desk_Icon_SetText(wind_mountinfo, minfo_auth, ((r5) && (flagSET(cr, flag_AUTH))) ? r5 : "");
  Icon_SetGreyShade(wind_mountinfo, minfo_tpath, !flagSET(cr, flag_PATH), Desk_iconbtype_NEVER);
  Icon_SetGreyShade(wind_mountinfo, minfo_tuser, !flagSET(cr, flag_USER), Desk_iconbtype_NEVER);
  Icon_SetGreyShade(wind_mountinfo, minfo_tauth, !flagSET(cr, flag_AUTH), Desk_iconbtype_NEVER);
  Window_ShowDialogue(wind_mountinfo, Desk_FALSE);
  return(Desk_TRUE);
d908 1
a908 1
  TRACE("ClientItem:\n");
a929 1
  Desk_os_error *err;
d933 2
a934 2
  TRACE1("ourxfersend: %x\n", (int) mr);
  err = Desk_Wimp_GetPointerInfo(&mouse_str);
d939 1
a939 1
  err = Desk_Wimp_GetWindowState(mouse_str.window, &wstate);
d944 1
a944 1
  err = Desk_Wimp_GetIconState(mouse_str.window, mouse_str.icon, &icon);
d947 1
a947 1
  if ((mouse_str.window != -2) || (err)) return;
d952 1
a952 1
  TRACE2("ourxfersend: %d %d\n", x0, x1);
d958 4
a961 2
  TRACE("ourxfersend: drag attempt\n");
  Desk_SWI(3,3, OS_Byte, 161,0x1C,0, NULL,NULL,&y);
d968 1
a968 1
    TRACE("ourxfersend: drag with dragasprite\n");
d973 4
a976 4
    TRACE2("ourxfersend: %d %d ", b1.min.x, b1.max.x);
    TRACE2("%d %d\n", b1.min.y, b1.max.y);
    err = Desk_DragASprite_Start(197, (void *) 1, name, &b1, &b2);
    dragging = Desk_TRUE;
d981 1
a981 1
    TRACE("ourxfersend: drag with outline\n");
d983 1
a983 1
    dr.type      	= drag_FIXEDBOX;
d992 2
a993 2
    err = Desk_Wimp_DragBox(&dr);
    dragging = Desk_FALSE;
d995 1
a995 2
  if (err) return;
  TRACE("ourxfersend: drag started ok\n");
d1001 1
a1001 1
static Desk_bool filer_action(void)
a1005 1
  Desk_os_error *err;
d1008 2
a1009 2
  TRACE1("filer_action: %x\n", (int) drag_mount);
  err = Desk_Wimp_GetPointerInfo(&mousestr);
d1014 3
a1016 3
  if (!drag_mount) return(Desk_FALSE);
  if ((mousestr.window == -2) && (mousestr.icon == drag_mount->icon)) return(Desk_FALSE);
  TRACE("filer_action: drag somewhere ok\n");
d1018 1
a1018 1
  msg.header.size = sizeof(message_header) + sizeof(message_datasave);
d1030 1
a1030 1
  err = Desk_Wimp_SendMessage(Desk_event_SEND, &msg, mousestr.window, mousestr.icon);
d1034 1
a1034 1
  return(Desk_FALSE);
d1052 1
a1052 1
  Desk_bool          test_select, test_adjust;
d1055 1
a1055 1
  TRACE2("ButtonClick: 1 mw %p mw->domain %d\n", mw, mw ? mw->domain : -1);
d1066 2
a1067 2
      Desk_bool connect = (mr->icon_state != ISTATE_OK);
      Desk_bool connections = (MountCount() > 1);
d1096 1
d1109 1
a1109 1
      TRACE("Drag attempt!\n");
d1111 2
a1112 2
      maydataload = Desk_FALSE;
      dragging = Desk_FALSE;
d1131 1
a1131 1
        Desk_Error_Check(Desk_SWI(2,0, mr->client_id, 7,mr->mount_id));
d1135 1
d1162 2
a1163 1
  TRACE2("ButtonClick: mw %p mw->domain %d\n", mw, mw ? mw->domain : -1);
d1192 1
a1192 1
          TRACE("mount tmp_connect button click\n");
d1195 1
d1199 1
d1207 1
d1236 1
a1236 1
          TRACE("domain tmp_Connect button click\n");
d1249 1
d1276 1
a1276 1
          TRACE("mount_connect button click\n");
d1291 1
d1318 1
a1318 1
          TRACE2("domain_connect button click %p %p\n", mw, mw->ml);
d1341 1
a1341 1
static Desk_bool DataSave(message_block msg, void *ref)
d1348 1
a1348 1
  TRACE("DataSave:\n");
d1350 5
a1354 3
  if (!(mr = MountIconFind(-1, NULL, msg.data.datasave.icon, Desk_TRUE, -1))) return(Desk_FALSE);
  TRACE1("DataSave: valid icon %x\n", (int) mr);
  if (!(cr = ClientFind(mr->client_id, NULL, -1, NULL))) return(Desk_FALSE);
d1358 1
a1358 1
  TRACE1("DataSave: '%s'\n", msg.data.datasaveack.filename);
d1363 1
a1363 1
  maydataload = Desk_TRUE;
d1370 1
a1370 1
static Desk_bool DataSaveAck(message_block msg, void *ref)
d1372 1
a1372 1
  int handle = Desk_Wimp_NewTask("Filer_Action");
d1380 1
a1380 1
  TRACE2("DataSaveAck: %x %x\n", handle, (int) drag_mount);
d1383 5
a1387 4
  if (!(cr = ClientFind(drag_mount->client_id, NULL, -1, NULL))) return(Desk_FALSE);
  TRACE1("DataSaveAck: '%s'\n", msg.data.datasaveack.filename);
  if (!strcasecmp(msg.data.datasaveack.filename, "<Wimp$Scrap>.x")) return(Desk_FALSE);
  if (!strcasecmp(msg.data.datasaveack.filename, "<Wimp$ScrapDir>.x")) return(Desk_FALSE);
d1395 1
a1395 1
  msg.header.action = (message_action) message_FILERSELECTIONDIRECTORY;
d1402 1
a1402 1
  msg.header.action = (message_action) message_FILERADDSELECTION;
d1419 1
a1419 1
  msg.header.action = (message_action) message_FILERACTION;
d1430 1
a1430 1
  TRACE("DataLoad:\n");
d1434 1
a1434 1
    TRACE("DataLoad: load from application - file transfer complete\n");
d1438 1
a1438 1
    maydataload = Desk_FALSE;
d1442 1
a1442 1
    int handle = Desk_Wimp_NewTask("Filer_Action");
d1453 1
a1453 1
    TRACE("DataLoad: load from filer\n");
d1455 4
a1458 2
    if (!(mr = MountIconFind(-1, NULL, msg.data.dataload.icon, Desk_TRUE, -1))) return(Desk_FALSE);
    if (!(cr = ClientFind(mr->client_id, NULL, -1, NULL))) return(Desk_FALSE);
d1473 1
a1473 1
    msg.header.action = (message_action) message_FILERSELECTIONDIRECTORY;
d1477 1
a1477 1
    msg.header.action = (message_action) message_FILERADDSELECTION;
d1484 1
a1484 1
    msg.header.action = (message_action) message_FILERACTION;
d1493 1
a1493 1
static Desk_bool DataLoadAck(message_block m, void *ref)
d1496 1
a1496 1
  TRACE("DataLoadAck:\n");
d1507 4
a1510 1
  TRACE("UserDrag:\n");
d1515 1
a1515 1
    dragging = Desk_FALSE;
d1540 2
a1541 2
      TRACE1("Reset: calling OmniOp for '%s'\n", cr->fsname);
      Desk_SWI(1,0, cr->client_id, 17);
d1547 1
a1547 1
  /* Desk_SWI(0,0, OmniAccess_Reset); */
d1557 1
a1557 1
  Desk_bool		all = (!mr);
d1559 2
a1560 2
  /* Use Omni_Op Desk_SWI call to dismount all active mounts */
  TRACE1("Dismount: %x\n", (int) mr);
d1574 2
a1575 2
        TRACE1("CLOSEDIR: %s\n", buf);
        Desk_SWI(1,0, OS_CLI, buf);
d1578 1
a1578 1
      Desk_Error_Check(Desk_SWI(2,0, mr->client_id, 1,mr->mount_id));
d1599 2
a1600 2
            TRACE1("CLOSEDIR: (hidden mlist) %s\n", buf);
            Desk_SWI(1,0, OS_CLI, buf);
d1602 1
a1602 1
          Desk_SWI(2,0, mr->client_id, 1,mr->mount_id);
d1699 1
a1699 1
            Desk_Error_Check(Desk_SWI(2,0, mr->client_id, 6,mr->mount_id));
d1715 2
a1716 2
            TRACE1("OpenRoot: '%s'\n", open);
            Desk_Error_Check(Desk_SWI(1,0, OS_CLI, open));
d1734 2
a1735 2
      TRACE1("FREE: %s\n", buf);
      Desk_Error_Check(Desk_SWI(1,0, OS_CLI, buf));
d1762 1
a1762 1
            all_done = Desk_TRUE;
d1818 3
a1820 3
          if (!clientwindow) return(Desk_FALSE);
          if (select_item > 0) return(CreateMount(mount_WINDOW, -1, Desk_TRUE));
            else return(CreateMount(mount_CLIENT, clientwindow->client_id, Desk_TRUE));
d1824 1
a1824 1
          return(CreateMount(mount_EMPTY, event->data.selection[1], Desk_TRUE));
d1902 2
d1917 1
a1917 1
    TRACE1("KeyPress: domainconnect %p\n", mountwindow);
d1935 1
a1935 1
    TRACE2("KeyPress: domainconnect %p %p\n", mw, mw->ml);
d1957 3
a1959 1
  TRACE2("PollWordNZ: %d %d\n", pollword, e->data.words[1]);
d1964 1
a1964 1
    TRACE("EnumerateMounts pollword:\n");
d1971 1
a1971 1
    TRACE("EnumerateMounts Network pollword:\n");
d1978 1
a1978 1
    TRACE("EnumeratePrinters Network pollword:\n");
d1983 1
a1983 1
    TRACE("RegisterClients pollword:\n");
d1992 1
a1992 1
    TRACE("DeregisterClients pollword:\n");
d1999 2
a2000 2
    TRACE("MountCLI pollword:\n");
    if (pollword_str) MountCLI(pollword_str, Desk_TRUE);
d2011 1
a2011 1
extern Desk_bool IconMenuWarn(Desk_event_pollblock *e, mount_record *mr)
d2040 1
a2040 1
  TRACE2("IconMenuWarn: %d %d\n", (int) mr, m->selection[0]);
d2042 1
a2042 1
  TRACE("IconMenuWarn: mr ok\n");
d2048 1
a2048 1
	case iimenu_INFO:	return(CreateInfo());
d2050 1
d2056 1
a2056 1
    				} else return(CreateInfo());
d2058 2
a2059 1
      	default:		return(CreateClient(m->selection[1]));
d2064 1
a2064 1
      TRACE1("IconMenuWarn: mounts %d\n", m->selection[1]);
d2071 2
d2078 2
a2079 1
        default:		return(CreateMount(mount_MLIST, m->selection[1], Desk_TRUE));
d2083 2
a2084 1
    case imenu_MOUNTINFO:return(CreateMountInfo(mr));
d2086 1
d2089 1
d2092 1
d2095 1
d2107 1
a2107 1
extern Desk_bool MainMenuWarn(Desk_event_pollblock *e, mount_record *mr)
d2113 2
d2121 1
d2126 1
d2151 1
a2151 1
  TRACE1("HelpSend: '%s'\n", s);
d2154 1
a2154 1
    TRACE1("HelpSend: sending '%s'\n", event->data.message.data.helpreply.text);
a2165 2
#define Desk_Wimp_GetMenuState	0x0400f4

d2177 2
d2186 1
a2186 1
    TRACE2("HelpHandler: mount client %x icon %d\n", clientwindow->client_id, i);
d2196 1
a2196 1
    TRACE2("HelpHandler: mount client %x icon %d\n", cr->client_id, i);
d2205 1
a2205 1
    TRACE2("HelpHandler: iconbar mr %x icon %d\n", (int) mr, i);
d2214 1
a2214 1
    Desk_SWI(4,0, Desk_Wimp_GetMenuState, 1,&buf[0],w,i);
d2314 4
a2317 1
  /* TRACE2("GenEvent: %d 0x%x\n", e->type, e->data.message.header.action); */
d2321 1
a2321 1
     TRACE("Desk_message_QUIT\n");
d2323 1
a2323 1
     all_done = Desk_TRUE;
d2345 1
a2345 1
      TRACE("Desk_message_PREQUIT\n");
d2372 1
a2372 1
        TRACE("GenEvent: SAVEDESK\n");
d2381 1
a2381 1
        TRACE("GenEvent: WINDOWINFO\n");
d2394 1
a2394 1
      TRACE("GenEvent: INITTASK\n");
d2398 1
a2398 1
        TRACE1("GenEvent: kill ShareFS %x\n", e->data.message.header.sender);
d2404 1
a2404 1
        TRACE("GenEvent: kill ShareFS OK\n");
d2410 1
a2410 1
      TRACE("GenEvent: MENUSDELETED\n");
@


1.1.1.1
log
@  Initial import of Omni into CVS.

Detail:
  This is an import of the sources obtained from ANT some time ago, with
  sufficient changes to allow it to build in our standard environment.  In
  particular, this involved converting Omni to use Desk instead of DeskLib.
  ANT's DeskLib was not 'off-the-shelf' - it was based on DeskLib 2.04 (very
  old), with their own modifications.
  
  This means that there are quite severe bugs in the Omni code, which will
  show up if you attempt to use this version, which were previously masked by
  some of ANT's DeskLib alterations.  (Hopefully) most of these have already
  been identified, fixed and will be checked-in soon.  I felt that a
  minimal version that would simply build would be worthwhile, so that as
  many changes as possible end up under CVS' control.

Admin:
  Compiled.
  Untested.
@
text
@@

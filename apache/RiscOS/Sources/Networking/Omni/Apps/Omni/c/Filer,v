head	1.11;
access;
symbols
	Omni-2_30:1.11
	Omni-2_29:1.11
	Omni-2_28:1.10
	Omni-2_27:1.10
	Omni-2_26:1.10
	Omni-2_25:1.10
	Omni-2_24:1.10
	Omni-2_23:1.10
	Omni-2_22:1.10
	Omni-2_21:1.10
	Omni-2_20:1.10
	Omni-2_19:1.10
	Omni-2_18:1.9
	Omni-2_17:1.8
	Omni-2_16:1.8
	Omni-2_15:1.7
	Omni-2_14:1.7
	Omni-2_13:1.6
	Omni-2_12:1.5
	Omni-2_11:1.5
	Omni-2_10:1.5
	Omni-2_09:1.5
	Omni-2_08:1.5
	Omni-2_07:1.4
	Omni-2_06:1.3
	Omni-2_05:1.2
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.11
date	2018.08.27.09.33.10;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	hi2AP29BjgzMYJPA;

1.10
date	2013.11.22.17.57.01;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	9mAsVrxUXmieFiex;

1.9
date	2013.03.14.20.18.45;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	6rnS12BNmFl5ANHw;

1.8
date	2011.12.14.13.51.14;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	Zvyz3NZzpUnQ5aLv;

1.7
date	2009.04.23.14.04.59;	author rool;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.02.22.46.09;	author jballance;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.16.18.28.04;	author blaughto;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.12.17.06.28;	author blaughto;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.23.17.44.10;	author blaughto;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.19.24.15;	author blaughto;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.02.19.41.33;	author blaughto;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.03.02.19.41.33;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Build fix
Missing header added for netdb (see TCPIPLibs-5_66).

Version 2.29. Tagged as 'Omni-2_29'
@
text
@/* Copyright 2000 Pace Micro Technology plc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Program:	Filer.c - core module routines
 *
 * Project:	!Omni OmniClient(tm) project
 *
 * Author:	Nick Smith
 *              ANT Limited
 *              Cambridge
 *              Internet: nas@@ant.co.uk
 *
 * Date:	11 July 1994
 * Last Edited:	3 May 1995
 *
 * Copyright 1994,1995 by ANT Limited
 */

#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include "sys/types.h"
#include <netdb.h>

#include "Global/Services.h"

#include <AsmUtils/rminfo.h>

#include <Desk/Error2.h>
#include <Desk/WimpSWIs.h>

#include <DebugLib/DebugLib.h>

#include "Client.h"
#include "Core.h"
#include "CoreInit.h"
#include "Defs.h"
#include "ExtLib.h"
#include "FileType.h"
#include "Filer.h"
#include "Heap.h"
#include "MakeError.h"
#include "Mount.h"
#include "Omni.h"
#include "OmniClient.h"
#include "Print.h"
#include "PrintFS.h"
#include "Time.h"

enum
{
  OSModule_Enter = 2,
  OSModule_Claim = 6,
  OSModule_Free  = 7
};

int                   taskhandle     = 0;		/* Wimp task handle */
int                   wind_info      = NULL;		/* Window handle */
int                   wind_client    = NULL;		/* Window handle */
int                   wind_mounttmp  = NULL;		/* Window handle */
int                   wind_mountdom  = NULL;		/* Window handle */
int                   wind_mountinfo = NULL;		/* Window handle */
Desk_linklist_header  mount_anchor   = {NULL, NULL};	/* List of mount icon records */
Desk_linklist_header  mlist_anchor   = {NULL, NULL};	/* List of mount list records */
Desk_linklist_header  mwind_anchor   = {NULL, NULL};	/* List of mount window records */
Desk_linklist_header  client_anchor  = {NULL, NULL};	/* List of client records */
Desk_linklist_header  ext_anchor     = {NULL, NULL};	/* List of file extn mapping records */
wind_record           wind_filer     = {NULL,NULL,0,0,0,NULL,NULL};	/* Record of servers 'filer' window */
config_record         prog_config    = {0,0,Desk_FALSE};	/* Program configuration */
Desk_linklist_header  print_anchor   = {NULL, NULL};	/* List of print job records */
Desk_linklist_header  plist_anchor   = {NULL, NULL};	/* List of print list records */

RunState              global_run_state = RunState_Running;
_kernel_oserror       omni_errblk    = {0, ""};          /* Global error block */
int                   pollword       = pollword_NONE;	/* Poll word non-zero */
int                   pollword_r0    = -1;		/* Poll word non-zero parameter */
char *                pollword_str   = NULL;		/* Poll word string */
bool                  all_hasrun     = false;		/* true if we have been running task */
/* extern bool		all_restart = true; */		/* true if we are just RMLoading */


/*  Clear out mlist struct from RMA.
 */
extern void mlist_clean(void)
{
  mlist_record *mr = (mlist_record *) mlist_anchor.next;
  while (mr)
  {
    mlist_record *mr_tmp = (mlist_record *) mr->header.next;
    MountDeleteList(mr);
    mr = mr_tmp;
  }
  Desk_LinkList_Init(&mlist_anchor);
}


/*  Clear out print struct from RMA.
 */
static void print_clean(void)
{
  print_record *mr = (print_record *) print_anchor.next;
  while (mr)
  {
    print_record *mr_tmp = (print_record *) mr->header.next;
    PrintClear(mr);
    mr = mr_tmp;
  }
  Desk_LinkList_Init(&print_anchor);
}


/*  Clear out print struct from RMA.
 */
extern void plist_clean(void)
{
  plist_record *mr = (plist_record *) plist_anchor.next;
  while (mr)
  {
    plist_record *mr_tmp = (plist_record *) mr->header.next;
    PListClear(mr);
    mr = mr_tmp;
  }
  Desk_LinkList_Init(&plist_anchor);
}


/*  Clear out client struct from RMA.
 */
static void client_clean(void)
{
  client_record *mr = (client_record *) client_anchor.next;
  while (mr)
  {
    client_record *mr_tmp = (client_record *) mr->header.next;
    ClientDelete(mr);
    mr = mr_tmp;
  }
  Desk_LinkList_Init(&client_anchor);
}


/* Kill task, release workspace.
 */
static void removetask(void)
{
  if (taskhandle > 0) Desk_Wimp_CloseDown(taskhandle);
  taskhandle = 0;
  mlist_clean();
  plist_clean();
}


/* Broadcast Service_OmniAction call.
 */
extern void serviceomni(int num)
{
  _swix (OS_ServiceCall, _INR (0, 1), num, Service_OmniAction);
}


/*  This is the finalisation code
 */
_kernel_oserror *fs_finalise(int fatal, int podule, void *private_word)
{
  UNUSED (fatal);
  UNUSED (podule);
  UNUSED (private_word);

  dprintf (("", "finalising\n"));
  serviceomni(1);
  dprintf (("", "sent service call\n"));

  removetask();
  dprintf (("", "done removetask\n"));

  print_clean();
  dprintf (("", "done printclean\n"));
  client_clean();
  dprintf (("", "done clientclean\n"));
  FileType_FreeChain();
  dprintf (("", "done FileType_FreeChain\n"));
  FS_Remove();
  dprintf (("", "done FS_Remove\n"));
  SetVar_Code(-1, NULL);
  dprintf (("", "done SetVar_Code\n"));
  CloseErrors();
  dprintf (("", "done CloseErrors\n"));

  return NULL;
}

/*  This is the initialisation code
 */
_kernel_oserror *fs_initialise(const char *cmd_tail, int podule_base, void *private_word)
{
  _kernel_oserror *err = NULL;

  /* These keep the compiler quiet. */
  cmd_tail = cmd_tail;
  podule_base = podule_base;

  debug_initialise ("", "Omni", NULL);
  debug_set_options (0, 0, 0);
  debug_output_device (DEBUGIT_OUTPUT);
//  debug_initialise_trace (DEBUGIT_OUTPUT);
    debug_set_unbuffered_files (TRUE);
    debug_set_stamp_debug (TRUE);

  Desk_Error2_Init_JumpSig();

  Desk_Error2_Try
  {
    Desk_LinkList_Init(&client_anchor);
    Desk_LinkList_Init(&print_anchor);
    Desk_LinkList_Init(&ext_anchor);

    InitVars();

    RMAFREE(pollword_str);

    err = FS_Declare(private_word);
    if (err)
    {
      return(err);
    }

    /* Delay the service call via callback because we aren't yet registered as a module,
     * so Omni_SWI calls will fail.
     */
    serviceomni_delay(0);
    SetVar_Code(1, &taskhandle);
    InitErrors();
  }
  Desk_Error2_Catch
  {
      err = Desk_Error2_ConvertToOS2();
  }
  Desk_Error2_EndCatch

  return(err);
}


/* Service call handler
 */
#ifdef DEBUG
static struct
{
  int svc;
  char *name;
} svcs[] =
{
  {0x00, "Serviced"},
  {0x04, "UKCommand"},
  {0x06, "Error"},
  {0x07, "UKByte"},
  {0x08, "UKWord"},
  {0x09, "Help"},
  {0x0b, "ReleaseFIQ"},
  {0x0c, "ClaimFIQ"},
  {0x11, "Memory"},
  {0x12, "StartUpFS"},
  {0x27, "Reset"},
  {0x28, "UKConfig"},
  {0x29, "UKStatus"},
  {0x2a, "NewApplication"},
  {0x40, "FSRedclare"},
  {0x41, "Print"},
  {0x42, "LookupFileType"},
  {0x43, "International"},
  {0x44, "Keyhandler"},
  {0x45, "PreReset"},
  {0x46, "ModeChange"},
  {0x47, "ClaimFIQinBackground"},
  {0x48, "ReAllocatePorts"},
  {0x49, "StartWimp"},
  {0x4a, "StartedWimp"},
  {0x4b, "StartFiler"},
  {0x4c, "StartedFiler"},
  {0x4d, "PreModeChange"},
  {0x4e, "MemoryMoved"},
  {0x4f, "FilerDying"},
  {0x50, "ModeExtension"},
  {0x51, "ModeTranslation"},
  {0x52, "MouseTrap"},
  {0x53, "WimpCloseDown"},
  {0x54, "Sound"},
  {0x55, "NetFS"},
  {0x56, "EconetDying"},
  {0x57, "WimpReportError"},
  {0x60, "ResourceFSStarting"},
  {-1,   "Something else"}
};
#endif

void fs_service(int service_number, _kernel_swi_regs *r, void *private_word)
{
  #ifdef DEBUG
  {
    int i;

    for (i=0; svcs[i].svc >= 0; i++) if (svcs[i].svc == service_number) break;
    dprintf(("", "Service_%s (%#x)%x,%x,%x,%x,%x,%x,%x,%x,%x,%x\n", svcs[i].name,
          service_number, r->r[0],r->r[1],r->r[2],r->r[3],r->r[4],r->r[5],r->r[6],r->r[7],
          r->r[8],r->r[9]));
  }
  #endif

  /* dprintf (("", "service: %x\n", service_number)); */
  switch (service_number)
  {
    case Service_Memory:
      /* keep application workspace (r2 holds CAO pointer) */
      if (r->r[2] == (int) Image_RO_Base) r->r[1] = 0;
      break;

    case Service_StartFiler:
      /* We use StartFiler/StartedFiler *not* StartWimp/StartedWimp because we are
       * a desktop filer, not just any old task, and we want to wait for the RISC OS
       * Filer task to startup first.
       */
      dprintf (("", "Service_StartFiler task %d\n", taskhandle));
      if (taskhandle == 0)
      {
        taskhandle = -1; 		/* attempting start flag */
        r->r[0] = (int) ("Desktop_OmniClient");
        r->r[1] = 0;
      }
      break;

    case Service_StartedFiler:
      dprintf (("", "Service_StartedFiler %d\n", taskhandle));
      if (taskhandle == -1) taskhandle = 0;
      break;

    case Service_Reset:
    case Service_ShutDownComplete:
      /* We have problems with soft-resets: If we've previously run on this
       * soft reset (RO3.1), then mark as never wanting to startup again.
       */
      if (!all_hasrun) taskhandle = 0;
        else taskhandle = -2;
      break;

    case Service_FilerDying:
      dprintf (("", "Service_FilerDying %d\n", taskhandle));
      removetask();
      break;

    case Service_FSRedeclare:
      FS_Declare(private_word);
      break;
  }
}


/* User Command processor
 */
_kernel_oserror *fs_command(const char *arg_string, int argc, int cmd_no, void *private_word)
{
  int currentslot, nextslot, freepool;

  UNUSED (argc);
  UNUSED (private_word);

  /* Switch between the commands */
  switch (cmd_no)
  {
    case CMD_Desktop_OmniClient:			/* Desktop_<app_DIR> */
      dprintf (("", "Desktop_OmniClient called handle %d hasrun %d\n", taskhandle, all_hasrun));
      dprintf (("", "Desktop_OmniClient called args '%s'\n", arg_string));
      if (taskhandle > 0)
      {
        if (argc > 1) MountCLI(arg_string, false);
        return(NULL);
      }
      if (!all_hasrun)
      {
        int active;
        bool start = false;

        /* Check we are really in the desktop.
         */
        dprintf (("", "running for first time\n"));
        dprintf (("", "checking Desktop running\n"));

        /* Check number of active tasks */
        if (_swix (Wimp_ReadSysInfo, _IN (0) | _OUT (0), 0, &active) == NULL)
        {
          /* Then check command/desktop state */
          if (active > 0 && _swix (Wimp_ReadSysInfo, _IN (0) | _OUT (0), 3, &active) == NULL)
          {
            if (active == 1)
            {
              start = true;
            }
          }
        }
        if (!start)
        {
          dprintf (("", "not starting\n"));
          /* Preserve command line string, because we'll start later */
          if (argc > 1) MountCLI(arg_string, false);
          return(NULL);
        }

        dprintf (("", "entering module startcode\n"));
        currentslot = 32*1024;
        nextslot = -1;
        Desk_Wimp_SlotSize(&currentslot, &nextslot, &freepool);
        return (_swix (OS_Module, _INR (0, 2), OSModule_Enter, app_NAME, arg_string));
      }
      else
      {
        dprintf (("", "running for nth time\n"));
        return(MakeError(err_RESTART));
      }
      break;

    case CMD_OmniMount:			/* OmniMount */
      MountCLI(arg_string, false);
      return(NULL);
      break;

    case CMD_OmniLoadMounts:			/* OmniLoadMounts */
      if (MountLoadFile(arg_string)) return(NULL);
      return(MakeError(err_BADMOUNTS));
      break;

    case CMD_OmniPrint:			/* OmniPrint */
      return (_swix (OS_FSControl, _INR (0, 1), OS_FSControl_SelectFilingSystem, fsname));
      break;

    default:
      return(NULL);
  }
}


/* SWI omni_base+0 "Omni_EnumerateMounts"
 *	On entry, R0 = 0, for all client types
 *	             = client_id, for a single client
 *                R1 = 0, for servers/mounts
 *                   = 1, for active mount connections
 *                   = 2, for printers
 *	All registers preserved on exit
 *
 *	This SWI is used by clients to request that the filer re-enumerates
 *	all the mounts for a given client_id [!=0] or for all registered
 *	client_id's [=0].
 *	This would be used, for example, when the client knows that the
 *	state of the active mounts [R1 = 1] has changed. eg, a
 *	command line *Dismount has been performed.
 *      If [R1 = 0], then the client knows that the list of servers and/or
 *      mounts exported by those servers has changed. eg, a periodic
 *      broadcast has noted that a new server has appeared.
 *      If [R1 = 2], then the client knows that the list of printers has
 *      changed.
 */
static _kernel_oserror *EnumerateMounts(_kernel_swi_regs *r)
{
  dprintf (("", "EnumerateMounts: %x %x\n", r->r[0], r->r[1]));
  /* If task isn't running, then we shouldn't do anything */
  if ((taskhandle <= 0) || (r->r[1] > 2)) return(NULL);
  if (r->r[1] == 0) pollword |= pollword_ENUMERATENET;
  if (r->r[1] == 1) pollword |= pollword_ENUMERATE;
  if (r->r[1] == 2) pollword |= pollword_ENUMERATEPRINT;
  if ((pollword_r0 != -1) && (pollword_r0 != r->r[0])) pollword_r0 = 0;
    else pollword_r0 = r->r[0];
  return(NULL);
}


/* SWI omni_base+1 "Omni_RegisterClient"
 *	On entry, R0 = client_id, (SWI xxxx_OmniOp)
 *	          R1 = client flags word;
 *	               	      bit 0 = 1, Client supports network filing system
 *	                            = 0, No filing system support
 *	               	      bit 1 = 1, UserID string required
 *	               	      bit 2 = 1, Password string required
 *	               	      bit 3 = 1, Mount path string required
 *	               	      bit 4 = 1, Authentication server string
 *               	      bit 5 = 1, Mount name *not* required
 *	               	      bit 6 = 1, Special network authenticator
 *	           	      bit 7 = *reserved* zero
 *	               	      bit 8 = 1, Client supports network printers
 *	                            = 0, No printing support
 *	               	      bit 9 = 1, Password string required
 *	              	     bit 10 = 1, Needs file length before print job starts
 *	         	bits 11..15 = *reserved* zero
 *	         	bits 16..23 = ASCII extension character, or 0 for none
 *	               	bits 24..31 = *reserved* zero
 *	          R2 = sprite name ptr
 *	          R3 = client name ptr
 *	          R4 = client description ptr
 *	          R5 = site_id word (See document [Site_SpecN] for details)
 *	          R6 = filing system name ptr
 *	On exit,  R0 = 0, if successful
 *	             = error block (V set), on error
 *	All other registers preserved on exit
 *
 *      This SWI is used when a client module is (re)started to register
 *      itself with the Omni filer, and pass to the filer the facilities
 *      that it provides via the flags word.
 *      An error is returned if registration fails for whatever reason.
 *
 *      Revisions of this document prior to 0.996 stated that the correct
 *      behaviour was to register with This SWI only once. However, this has
 *      now changed so that protocol modules should attempt to (re)register
 *      when they startup and whenever they recieve Service_OmniAction. If
 *      the protocol is already registered, no error is returned.
 *      An error is returned if registration fails for whatever reason.
 *
 * 	The flags word (R1) lets the filer know which connect fields
 * 	are *never* required by this client. Some clients can further
 * 	reduce the number of fields required at a later time (see
 * 	OmniOp 7). eg, LAN Manager. The flags word can also register a
 * 	single ASCII character (eg, '.' or '/') which is used to
 * 	separate filename and file extension in the filing system. This
 * 	separator is used by the Omni_Convert SWI calls.
 *
 *	Bit 5 of the flags word is set for filing systems (typically those
 *	written before OmniClient) that have no concept of a user-supplied
 *	mount name, separate from the actual server name. When this bit is
 *	set, users will not be prompted for a mount name - it will be set
 *	to the mount path string (if it is set as required and is of non-zero
 *	length), or failing that the server name string. Note that when
 *	returning the mount path string (eg, OmniOp,9) protocol modules
 *	should return the appropriate string to allow Free operations, etc.
 *	This is the string that will appear under the iconbar, and if bit
 *	5 is set in the flags, the string will most likely either be
 *	the real server name, or the mount path. Hopefully most protocol
 *	module authors will never be required to understand this paragraph ;-)
 *
 *	Bit 6 of the flags word is set for protocols that require a network
 *	authentication action before servers can be located (eg, Acorn Access+)
 *	The expected use is for the protocol module to provide a 'dummy'
 *	network server, which the user 'mounts' with their user name/password.
 *	The mount operation is passed onto the protocol module as normal, but
 *	because there is no real connection, the mount should not be returned
 *	via enumerate active mounts calls, and no icon will appear on the
 *	iconbar. The protocol module can then perform its network
 *	authentication and enumerate those new servers that it can access.
 *
 * 	The sprite name ptr (R2) is a pointer to a null-terminated
 * 	sprite name, which must exist in the Wimp sprite pool as
 * 	'sprite', along with the small version 'sprite' postfix 'sm'. The
 * 	unique name for the client sprites (suggest the ASCII hex of
 * 	the xxxx_MiscOp SWI number) must be no more than 6 characters
 * 	long. Static string.
 *
 *	The client name ptr (R3) is a pointer to a null-terminated text
 *	string, which should be a short format description of the client.
 *	eg, 'Berkeley NFS'. It should be no more than 24 characters long.
 *	This string is used in filer menus and title bars. Static string.
 *
 *	The client description ptr (R4) is a pointer to a null-terminated
 *	text string of the form '<desc>|J<author>|J<version>'. ie,
 *	3 lines of text (each line no longer than 32 chars), separated
 *	by ASCII 0x0a, and the whole string terminated by a null (0x00).
 *	This string is used in a filer 'client info' window. Static string.
 *
 * 	The site_id word (R5) (See document [Site_SpecN] for details)
 * 	should be 0 if the client module provides its own site-license
 * 	enforcement mechanism, or has no upper limit on the number of
 * 	users.
 *
 *	The filing system name ptr (R6) is the textual name of the filing
 *	system used by this protocol. eg, 'NetFS'.
 *
 *      Errors returned include:
 *      err_base+0	"Protocol is already registered"
 *	err_base+1	"Bad protocol identifier value"
 *	err_base+2	"No free memory for protocol registration"
 */
static _kernel_oserror *RegisterClient(_kernel_swi_regs *r)
{
  client_record *cr;

  cr = ClientCreate(r);
  dprintf (("", "RegisterClient:\n"));
  if (cr != NULL)
  {
    pollword |= pollword_REGISTER;
    if ((pollword_r0 != -1) && (pollword_r0 != r->r[0])) pollword_r0 = 0;
      else pollword_r0 = r->r[0];
    returnOK()
  } else return((_kernel_oserror *) r->r[0]);
}


/* SWI omni_base+2 "Omni_DeregisterClient"
 *	On entry, R0 = client_id
 *      On exit,  R0 = 0, if deregistration successful
 *                   = not 0, if deregistration failed (error ptr)
 *	All other registers preserved on exit
 *
 *      This SWI is the companion call to SWI Omni_RegisterClient, and
 *      releases the client from the Omni filer.
 */
static _kernel_oserror *DeregisterClient(_kernel_swi_regs *r)
{
  client_record *cr = ClientFind(r->r[0], NULL, -1, NULL);
  dprintf (("", "DeregisterClient:\n"));
  if (cr == NULL) return(MakeError(err_NOTREGISTERED));
  ClientDelete(cr);
  pollword |= pollword_DEREGISTER;
  /* Force to enumerate for active mounts that may have disappeared */
  pollword |= pollword_ENUMERATE;
  if ((pollword_r0 != -1) && (pollword_r0 != r->r[0])) pollword_r0 = 0;
    else pollword_r0 = r->r[0];
  returnOK();
}


/* SWI omni_base+3 "Omni_MessageLookup"
 *  	On entry, R0 = message_id, (see table)
 *	          R1 = parameter string (if required)
 *      On exit,  R0 = error_blk, pointer to error block;
 *                       +0 = error number
 *                       $4 = null-terminated text string
 *	All other registers preserved on exit
 *
 *	This SWI provides for a shared set of common error/message
 *	blocks which can be used by client modules, irrespective of
 *	whether they are register with Omni filer.
 *	The text messages returned may be internationalised.
 *	NOTE do not rely on the maximum OmniClient(tm) error message
 *	being 16 - this list is subject to change and expansion.
 *	The filer does not guarantee to store error blocks statically.
 *	If you need the error block again, call This SWI.
 */
static _kernel_oserror *MessageLookup(_kernel_swi_regs *r)
{
  dprintf (("", "MessageLookup: %x %x\n", r->r[0], r->r[1]));
  return(OmniError(r->r[0], (char *) r->r[1]));
}


/* SWI omni_base+4 "Omni_ConvertClientToAcorn"
 *	On entry, R0 = client_id
 *		  R1 = ptr to client-format filename (including extension)
 *		  R2 = ptr to buffer for Acorn-format filename
 *		  R3 = ptr to flags string
 *	On exit,  R0 = Acorn-filetype, or -1 if not applicable
 *	All other registers preserved on exit
 *
 *	This SWI performs client -> RISC OS filename & file extension
 *	translations by using a user-configurable mappings file. The format
 *	of this file and the flags R3 parameter are described in another
 *	document. [File_SpecN]
 *	Note that this mapping SWI deals with mappings for multiple
 *	client types (not just DOS 8+3 format, for example), hence the need
 *	to pass in the calling client_id in R0.
 */
static _kernel_oserror *ConvertClientToAcorn(_kernel_swi_regs *r)
{
  client_record *cr = NULL;

  dprintf (("", "(swi)ConvertClientToAcorn: '%s'\n",(char *) r->r[1]));
  if ((cr = ClientFind(r->r[0], NULL, -1, NULL)) == NULL)
    return(MakeError(err_NOTREGISTERED));
  r->r[0] = FileType_ConvertToType(cr->client_id, (char *) r->r[1], (char *) r->r[2],
    (char *) r->r[3]);
  return(NULL);
}


/* SWI omni_base+5 "Omni_ConvertAcornToClient"
 *	On entry, R0 = client_id
 *		  R1 = ptr to acorn-format filename
 *		  R2 = ptr to buffer for client-format filename
 *		       (including extension)
 *		  R3 = flags string
 *	          R4 = Acorn-filetype, or -1 if not typed
 *	All registers preserved on exit
 *
 *	This SWI performs RISC OS -> client filename & file extension
 *	translations by using a user-configurable mappings file. The format
 *	of this file and the flags R3 parameter are described in another
 *	document. [File_SpecN]
 *	Note that this mapping SWI deals with mappings for multiple
 *	client types (not just DOS 8+3 format, for example), hence the need
 *	to pass in the calling client_id in R0.
 */
static _kernel_oserror *ConvertAcornToClient(_kernel_swi_regs *r)
{
  client_record *cr = NULL;
  dprintf (("", "ConvertAcornToClient:\n"));

  if ((cr = ClientFind(r->r[0], NULL, -1, NULL)) == NULL)
    return(MakeError(err_NOTREGISTERED));
  FileType_ConvertToExtension(cr->client_id, (char *) r->r[1], (char *) r->r[2],
    (char *) r->r[3], r->r[4]);
  return(NULL);
}


/* SWI omni_base+6 "Omni_ConvertTime"
 *	On entry, R0 = time formats;
 *		       bits 0..3 = source format
 *		       bits 4..7 = destination format;
 *		         0 = RISC OS, 5 byte, csec from 1st Jan 1900
 *		         1 = UNIX, 4 byte, sec from 1st Jan 1970
 *		         2 = DOS, 4 byte, sec from 1st Jan 1980
 *		         3 = Mac, 4 byte, signed sec from 00:00 1st Jan 2000
 *	         	 4 = Generic, 28 bytes (see below)
 *		        >4 = *reserved*
 *		       bits 8..31 = *reserved* zero
 *		  R1 = *pointer* to source time block
 *		  R2 = *pointer* to destination time buffer
 *	All registers preserved on exit
 *
 *	This SWI performs file timestamp conversions between any
 *	combination of supported system time formats.
 */
static _kernel_oserror *ConvertTime(_kernel_swi_regs *r)
{
  int src, dst;
  int time[9];

  dprintf (("", "ConvertTime:\n"));

  src = r->r[0] & 0x0F;
  dst = (r->r[0] & 0xF0) >> 4;
  dprintf (("", "ConvertTime: src %d\n", src));
  switch (src)
  {
    case 0:
      Time_FromAcorn((char *) r->r[1], &time[0]);
      break;
    case 1:
    case 2:
    case 3:
      Time_FromSecs((int *) r->r[1], &time[0], src);
      break;
    case 4:
      memcpy((char *) &time[0], (char *) r->r[1], sizeof(int)*7);
      break;
    default:
      return(MakeError(err_BADTIME));
      break;
  }
  time[7] = -1;
  time[8] = -1;
  dprintf (("", "ConvertTime: dst %d\n", dst));
  switch (dst)
  {
    case 0:
      Time_ToAcorn((char *) r->r[2], &time[0]);
      break;
    case 1:
    case 2:
    case 3:
      Time_ToSecs((int *) r->r[2], &time[0], dst);
      break;
    case 4:
      memcpy((char *) r->r[2], (char *) &time[0], sizeof(int)*7);
      break;
    default:
      return(MakeError(err_BADTIME));
      break;
  }
  dprintf (("", "ConvertTime: exit\n"));
  return(NULL);
}


/* SWI omni_base+7 "Omni_Printers"
 *     	On entry, R0 = reason code;
 *                        0 = list protocols supporting printers
 *                        1 = list protocol (FS names) supporting printers
 *                        2 = protocol print flags for protocol in R1
 *                       16 = list printer servers for protocol in R1
 *                       17 = list printers for protocol/server in R1/R2
 *                       18 = list all printers for protocol in R1
 *                R1 = ptr to name of protocol (R0 = 2,16,17,18)
 *                R2 = ptr to name of server for printers (R0 = 17)
 *                R3 = ptr to buffer to fill with result string, or NULL
 *                R4 = size of buffer in bytes, or -1 if not known
 *      On exit,  R0 = protocol printing-support flags word (R0 = 2)
 *        	  R4 = size of buffer required for result string
 *	All other registers preserved on exit
 *
 *      This SWI provides information about printer support in OmniClient.
 *      Currently the reason codes (R0=0,1,16,17,18) return a result string
 *      into a user buffer supplied as R3. It is expected that this is
 *      done as a 2-stage process to ensure that a large-enough buffer
 *      exists for the result string.
 *
 *      The SWI is firstly called with R3=NULL,R4=-1, and the call returns
 *      with R4 containing the total size of buffer required (including
 *      terminator). The buffer is allocated by the caller, and then the
 *      SWI is called the second time, with the new R3/R4.
 *      If no items are available, then R4=0 is returned.
 *
 *      If R0 = 0, then the menu string contains the available protocol
 *      names that are registered as supporting printers. eg, "Acorn NFS,
 *      Acorn NetFS, ANT RemoteFS". R0 = 1 returns the same menu string,
 *      but with filing system names rather than full client descriptions.
 *      eg, "NFS, NetFS, RemoteFS".
 *
 *	If R0 = 2, then the protocol printing-support flags word for the
 *	protocol named in R1 is returned. The flags word is of the format;
 *
 *		bit 0 = 1, Client supports network printers
 *	              = 0, No printing support
 *	        bit 1 = 1, Password string required
 *	        bit 2 = 1, Needs file length before print job starts
 *	   bits 3..31 = *reserved* zero
 *
 *      If R0 = 16, then the menu string contains the servers exported
 *      by the protocol named in R1. eg, "laser.net, print.cl".
 *
 *      If R0 = 17, then the menu string contains the printers exported
 *      by the protocol named in R1, available as printers from the server
 *      named in R2. eg, "LibraryDM, Laser 600".
 *
 *      If R0 = 18, then the menu string contains all the printers exported
 *      by the protocol named in R1. eg, "NetLaser, LibraryDM, Laser 600".
 *      This reason code lists all the printers available, irrespective of
 *      which network server they are connected to.
 */
static _kernel_oserror *Printers(_kernel_swi_regs *r)
{
  _kernel_oserror *err = NULL;

  dprintf (("", "Printers: %x\n", r->r[0]));
  switch (r->r[0])
  {
    case 0:
    case 1:
      /* List protocols */
      err = PrintListProtocols(r);
      break;
    case 2:
      /* Protocol flags */
      err = PrintFlag(r);
      break;
    case 16:
      /* List print servers */
      err = PrintListServers(r);
      break;
    case 17:
    case 18:
      /* List printers */
      err = PrintListPrinters(r);
      break;
    default:
      err = MakeError(err_BADREASON);
      break;
  }
  return(err);
}


/* SWI omni_base+8 "Omni_CreateJob"
 * 	On entry, R0 = ptr to protocol name
 * 	          R1 = ptr to server name
 * 	          R2 = ptr to printer name
 * 	          R3 = ptr to user name, or NULL
 *	          R4 = ptr to password string, or NULL
 *                R5 = ptr to options string, or NULL
 *                R6 = size of print job (bytes), or 0 if not known
 *      On exit,  R0 = print_id of new job, if successful
 *                   = error block (V set), on error
 * 	All other registers preserved on exit
 *
 *      Submit a new job for network printing. Returns a unique 'print_id'
 *      word, or a pointer to an error block.
 *
 *      The protocol name (R0) is the name as provided by SWI Omni_Printers
 *      (and registered as the 'client name'). eg, "Sun NFS". The user name,
 *      password and options string are optional, and may be NULL pointers.
 *
 *      Some printing protocols require that the total size of the job is
 *      known before printing starts. If this is the case, they should be
 *      registered with OmniClient as requiring this. When a client
 *      program calls SWI Omni_PrinterInfo, reason code 2, it can determine
 *      whether a password field is required for this protocol, and whether
 *      the total size of the print job is required.
 */
static _kernel_oserror *CreateJob(_kernel_swi_regs *r)
{
  print_record *pr = NULL;

  dprintf (("", "CreateJob:\n"));
  if ((pr = PrintCreate(r)) == NULL) return((_kernel_oserror *) r->r[0]);
  r->r[0] = pr->print_id;
  return(NULL);
}


/* SWI omni_base+9 "Omni_SendJob"
 * 	On entry, R0 = print_id
 * 		  R1 = ptr to data block to send
 * 		  R2 = size of data block to send
 * 	On exit,  R2 = number of bytes not sent, or 0 for all done
 * 	All other registers preserved on exit
 *
 *      Send a block of data down network printer stream for a given active
 *      print_id word.
 */
static _kernel_oserror *SendJob(_kernel_swi_regs *r)
{
  print_record *pr = NULL;
  _kernel_oserror *err = NULL;
  client_record *cr = NULL;

  dprintf (("", "SendJob:\n"));
  if ((pr = PrintFind(r->r[0], -1, -1, -1)) == NULL) return(MakeError(err_BADPRINT));
  if ((cr = ClientFind(pr->client_id, NULL, -1, NULL)) == NULL)
    return(MakeError(err_NOTREGISTERED));
  /* Make call onto client */
  err = ClientSendPrintData (pr->client_id,
                             pr->pjob_id, (char *) r->r[1], r->r[2],
                             (unsigned int *) &r->r[2]);
  if (!err) returnOK();
  r->r[0] = (int) err;
  return(err);
}


/* SWI omni_base+10 "Omni_EndJob"
 * 	On entry, R0 = print_id
 * 	All registers preserved on exit
 *
 *      End a specified print job normally (ie, all data transmitted).
 */
static _kernel_oserror *EndJob(_kernel_swi_regs *r)
{
  print_record *pr = NULL;
  _kernel_oserror *err = NULL;
  client_record *cr = NULL;

  dprintf (("", "EndJob:\n"));
  if ((pr = PrintFind(r->r[0], -1, -1, -1)) == NULL) return(MakeError(err_BADPRINT));
  if ((cr = ClientFind(pr->client_id, NULL, -1, NULL)) == NULL)
    return(MakeError(err_NOTREGISTERED));
  /* Make call onto client */
  err = ClientEndPrintJob(pr->client_id, pr->pjob_id);
  /* Mark as complete */
  if (!err)
  {
    pr->status = (print_STATUS | print_COMPLETE);
    pr->handle = -1;
    returnOK();
  }
  r->r[0] = (int) err;
  return(err);
}


/* SWI omni_base+11 "Omni_AbortJob"
 * 	On entry, R0 = print_id, or
 * 		     = 0, to abort all jobs
 * 	All registers preserved on exit
 *
 *      Abort a specified print job, or all current jobs.
 */
static _kernel_oserror *AbortJob(_kernel_swi_regs *r)
{
  print_record *pr = NULL;
  _kernel_oserror *err = NULL;
  client_record *cr = NULL;

  dprintf (("", "AbortJob:\n"));
  if (r->r[0] == 0)
  {
    /* Abort all print jobs */
    cr = (client_record *) client_anchor.next;
    while (cr != NULL)
    {
      if (PrintFind(-1, -1, cr->client_id, -1) != NULL)
      {
        /* Don't stop if an error occurs, but remember the first one */
        _kernel_oserror *temp_err = ClientAbortPrintJobs(cr->client_id, 0);
        if (temp_err != NULL && err == NULL)
        {
          err = temp_err;
        }
      }
      cr = (client_record *) cr->header.next;
    }
    /* Free print job records */
    pr = (print_record *) print_anchor.next;
    while (pr != NULL)
    {
      print_record *pr_tmp = (print_record *) pr->header.next;
      pr->status = (print_STATUS | print_ERROR);
      pr->handle = -1;
      pr = pr_tmp;
    }
  }
  else
  {
    /* Abort a single print job */
    if ((pr = PrintFind(r->r[0], -1, -1, -1)) == NULL) return(MakeError(err_BADPRINT));
    if ((cr = ClientFind(pr->client_id, NULL, -1, NULL)) == NULL)
      return(MakeError(err_NOTREGISTERED));
    /* Make call onto client */
    err = ClientAbortPrintJobs(pr->client_id, pr->pjob_id);
    /* Delete from list */
    if (!err)
    {
      pr->status = (print_STATUS | print_ERROR);
      pr->handle = -1;
    }
  }
  if (!err) returnOK();
  r->r[0] = (int) err;
  return(err);
}


/* SWI omni_base+12 "Omni_JobStatus"
 * 	On entry, R0 = print_id
 * 	On exit,  R1 = local job status word (see below)
 * 		  R2 = local job # bytes sent
 * 		  R3 = error/status block ptr, or 0
 * 		  R4 = remote job status word (see below)
 * 		  R5 = remote job # bytes printed
 * 		  R6 = error/status block ptr, or 0
 * 	All other registers preserved on exit
 *
 *      Get information on a specified print job. The status
 *      word (R1, R3) is currently defined as;
 *
 *      	bit 0 = 0, no status available
 *         	      = 1, status information available
 *          bits 1..3 = 0, pending connection
 *         	      = 1, connection made, waiting for initial data
 *                    = 2, sending bytes
 *                    = 3, transfer complete
 *                    = 4, job marked as temporary error
 *     	              = 5, job marked as terminal error
 *                    =>5, *reserved*
 * 	   bits 4..31 = *reserved* zero
 */
static _kernel_oserror *JobStatus(_kernel_swi_regs *r)
{
  print_record *pr = NULL;
  _kernel_oserror *err = NULL;
  client_record *cr = NULL;

  dprintf (("", "JobStatus:\n"));
  if ((pr = PrintFind(r->r[0], -1, -1, -1)) == NULL) return(MakeError(err_BADPRINT));
  if ((cr = ClientFind(pr->client_id, NULL, -1, NULL)) == NULL)
    return(MakeError(err_NOTREGISTERED));

  /* Make call onto client */
  err = ClientGetPrintJobInfo (pr->client_id,
                               pr->pjob_id,
                               (unsigned int *) &r->r[1],
                               (unsigned int *) &r->r[2],
                               (void **) &r->r[3],
                               (unsigned int *) &r->r[4],
                               (unsigned int *) &r->r[5],
                               (void **) &r->r[6]);

  if (!err) returnOK();
  r->r[0] = (int) err;
  return(err);
}


/* SWI omni_base+13 "Omni_ClearJob"
 *	On entry, R0 = print_id, or
 *		     = 0, to clear all inactive jobs
 *	All registers preserved on exit
 *
 *      Clear a specified print job, or all current inactive jobs. It is
 *      important to make this call once the client program has finished
 *      with the print job, and will no longer be calling Omni_JobStatus.
 *      eg, once it has marked the job as having been completed or having a
 *      terminal error. The status of a print job will reside in memory
 *      forever if this call is not made.
 */
static _kernel_oserror *ClearJob(_kernel_swi_regs *r)
{
  print_record *pr = NULL;
  _kernel_oserror *err = NULL;
  client_record *cr = NULL;
  unsigned int lstatus, rstatus;

  dprintf (("", "ClearJob:\n"));
  if (r->r[0] == 0)
  {
    /* Free inactive print job records */
    pr = (print_record *) print_anchor.next;
    while (pr != NULL)
    {
      print_record *pr_tmp = (print_record *) pr->header.next;

      err = ClientGetPrintJobInfo (pr->client_id, pr->pjob_id,
                                   &lstatus, NULL, NULL, &rstatus, NULL, NULL);
      if ((!err) && ((pflagSET(lstatus, print_COMPLETE)) || (pflagSET(lstatus, print_ERROR))))
      {
        /* Make call onto client */
        err = ClientClearPrintJobs (pr->client_id, pr->pjob_id);
        if (!err) PrintClear(pr);
      }
      pr = pr_tmp;
    }
  }
  else
  {
    /* Abort a single print job */
    if ((pr = PrintFind(r->r[0], -1, -1, -1)) == NULL) return(MakeError(err_BADPRINT));
    if ((cr = ClientFind(pr->client_id, NULL, -1, NULL)) == NULL)
      return(MakeError(err_NOTREGISTERED));

    err = ClientGetPrintJobInfo (pr->client_id, pr->pjob_id,
                                 &lstatus, NULL, NULL, &rstatus, NULL, NULL);
    dprintf (("", "ClearJob: jobinfo = %x\n", (int) err));
    dprintf (("", "ClearJob: %x\n", lstatus));
    dprintf (("", "ClearJob: %x %x\n", pflagSET(lstatus, print_COMPLETE),
      pflagSET(lstatus, print_ERROR)));
    if ((!err) && ((pflagSET(lstatus, print_COMPLETE)) || (pflagSET(lstatus, print_ERROR))))
    {
      /* Make call onto client */
      err = ClientClearPrintJobs (pr->client_id, pr->pjob_id);
      dprintf (("", "ClearJob: clearclient = %x\n", (int) err));
      if (!err) PrintClear(pr);
    }
  }
  if (!err) returnOK();
  r->r[0] = (int) err;
  return(err);
}


/* SWI omni_base+14 "Omni_PrinterInfo"
 *      On entry, R0 = ptr to name of protocol for printer
 *                R1 = ptr to name of server
 *                R2 = ptr to name of printer
 *      On exit,  R0 = flags word, or 0 if not available
 *	All other registers preserved on exit
 *
 *      This SWI provides information about the facilities provided by a
 *      named printer. If information is not available then 0 is returned,
 *      or if the printer name is not valid, an error block ptr is returned.
 *
 *      The flags word,is a set of bit fields that describe the printer type
 *  	and facilities provided (see PRM 3-595);
 *
 *             	bit 0 = 1, Facilities information available,
 *                    = 0, information not available
 *          bits 1..7 = *reserved* zero
 *	        bit 8 = 1, Raw ASCII text
 *              bit 9 = 1, Postscript compatible
 *             bit 10 = 1, Epson FX80 or compatible
 *             bit 11 = 1, HP Laserjet or compatible
 *             bit 12 = 1, Integrex Colourjet
 *             bit 13 = 1, FAX modem
 *             bit 14 = 1, Direct drive laser printer
 *             bit 15 = 1, Caspel graphics language
 *             bit 16 = 1, PDumper interface
 *             bit 17 = 1, TeX 'DVI' files
 *             bit 18 = 1, Epson JX/Star LC10, HP Paintjet
 *        bits 19..31 = *reserved* zero
 */
static _kernel_oserror *PrinterInfo(_kernel_swi_regs *r)
{
  client_record *cr = NULL;
  plist_record *pr = NULL;

  dprintf (("", "PrinterInfo:\n"));
  cr = ClientFind(-1, (char *) r->r[0], -1, NULL);
  if (!cr) cr = ClientFind(-1, NULL, -1, (char *) r->r[0]);
  if (!cr) return(MakeError(err_NOTREGISTERED));
  /* Locate named server/printer */
  pr = PrinterFind(cr->client_id, (char *) r->r[1], (char *) r->r[2]);
  if (pr) r->r[0] = pr->flags;
    else r->r[0] = 0;
  return(NULL);
}


/* SWI omni_base+15 "Omni_EnumerateJobs"
 *	On entry, R1 = ptr to buffer for job list (word aligned)
 *	          R2 = size of buffer (words * 4)
 *	          R3 = 0, start enumerating jobs
 *	               not 0, continue enumerating jobs
 *	On exit,  R1 = ptr to next free byte in buffer, word aligned
 *	          R3 = 0, operation complete
 *	               not 0, buffer full, call again with this R3
 *	All other registers preserved on exit
 *
 *	This SWI enumerates all printer jobs that OmniClient knows about,
 *	returning a list of their print_id values in consecutive words of
 *	the supplied buffer, until the buffer is full or the enumeration is
 *	complete. This allows printer managment applications to gain access
 *	to print_id handles of jobs even if they were started using the
 *	OmniPrint filing system, or by another application using SWI
 *	Omni_CreateJob.
 *
 *	If R3 is not 0 on exit, then the enumeration is not complete
 *	(buffer full), and the reason code is called again with the
 *	new R3 value. This process continues until the enumeration
 *	is complete.
 */
static _kernel_oserror *EnumerateJobs(_kernel_swi_regs *r)
{
  dprintf (("", "EnumerateJobs:\n"));
  r->r[3] = (int) PrintListJobs((print_record *) r->r[3], (int **) &r->r[1], r->r[2]);
  return(NULL);
}


/* SWI omni_base+16 "Omni_NameLookup"
 *      On entry, R0 = reason code;
 *                      0 = get internet host by name
 *                      1 = get internet service by name/protocol
 *                     >1 = *reserved*
 *                  R1 = ptr to name of host (R0=0) or service (R0=1)
 *                  R2 = ptr to name of protocol (R0=1)
 *      On exit,  R0 = ptr to hostent (R0=0) or servent (R0=1) struct's
 *	All other registers preserved on exit
 *
 *	This SWI exists as an interface to the Internet name lookup
 *	facilities, for those protocol modules that do not wish to use the
 *	Acorn-provided 'inetlib' library, either for space reasons or
 *	because they cannot easily link in the library (eg, the protocol
 *	module is written entirely in assembler).
 *
 *	Parameters and return results are exactly as the Berkeley standard
 *	gethostbyname(char *name) and getservbyname(char *name, char *proto)
 *	functions.
 */
static _kernel_oserror *NameLookup(_kernel_swi_regs *r)
{
  dprintf (("", "NameLookup:\n"));
  switch (r->r[0])
  {
    case 0:
      r->r[0] = (int) gethostbyname((char *) r->r[1]);
      break;
    case 1:
      r->r[0] = (int) getservbyname((char *) r->r[1], (char *) r->r[2]);
      break;
    default:
      r->r[0] = 0;
      break;
  }
  return(NULL);
}


/*  User SWI call handler.
 */
_kernel_oserror *fs_swi(int swi_no, _kernel_swi_regs *r, void *private_word)
{
  _kernel_oserror *  e = NULL;

  UNUSED (private_word);

  dprintf (("", "fs_swi: %d\n", swi_no));

  switch (swi_no)
  {
    case Omni_EnumerateMounts - Omni_00:
      e = EnumerateMounts(r);
      break;

    case Omni_RegisterClient - Omni_00:
      e = RegisterClient(r);
      break;

    case Omni_DeregisterClient - Omni_00:
      e = DeregisterClient(r);
      break;

    case Omni_MessageLookup - Omni_00:
      e = MessageLookup(r);
      break;

    case Omni_ConvertClientToAcorn - Omni_00:
      e = ConvertClientToAcorn(r);
      break;

    case Omni_ConvertAcornToClient - Omni_00:
      e = ConvertAcornToClient(r);
      break;

    case Omni_ConvertTime - Omni_00:
      e = ConvertTime(r);
      break;

    case Omni_Printers - Omni_00:
      e = Printers(r);
      break;

    case Omni_CreateJob - Omni_00:
      e = CreateJob(r);
      break;

    case Omni_SendJob - Omni_00:
      e = SendJob(r);
      break;

    case Omni_EndJob - Omni_00:
      e = EndJob(r);
      break;

    case Omni_AbortJob - Omni_00:
      e = AbortJob(r);
      break;

    case Omni_JobStatus - Omni_00:
      e = JobStatus(r);
      break;

    case Omni_ClearJob - Omni_00:
      e = ClearJob(r);
      break;

    case Omni_PrinterInfo - Omni_00:
      e = PrinterInfo(r);
      break;

    case Omni_EnumerateJobs - Omni_00:
      e = EnumerateJobs(r);
      break;

    case Omni_NameLookup - Omni_00:
      e = NameLookup(r);
      break;

    case Omni_TraceFile - Omni_00:
      /* 2000-03-04: BAL
       * Not sure what to do about this - investigate if protocol modules
       * actually use this.
       */
      #if 0
      #ifdef DEBUG
      r->r[0] = (int) omniout;
      #else
      r->r[0] = 0;
      #endif
      #endif

      r->r[0] = 0;
      break;

    default:
      e = error_BAD_SWI;
      break;
  }

  /* Return with no error */
  return(e);
}
@


1.10
log
@Allow OmniClient clients to provide theme specific sprites
OmniClient will now check its disc based sprites to see if there are any higher res or theme specific ones available (if there aren't then it is still assumed that the client has *ICONSPRITES'd his own as before).
No longer looks for "_22" suffix manually, the Wimp will do that for us.
Added file type sprites extracted from earlier CVS history.
New application sprites for Morris4 and Ursula imported, thanks to Chris Wraight for these.

Version 2.19. Tagged as 'Omni-2_19'
@
text
@d38 1
@


1.9
log
@Write out choices to <Choices$Write> rather than inside the application directory
UK/Messages: English for "update" was trapped in the C code rather than in the messages
Filer.c/CoreInit.c: name the application as OmniClient
FileType.c: Try Choices first then Omni:
Mount.c: Write to <Choices$Write>, for reading try Choices first then Omni:
Defs.h: Change app_FILES to "Omni:" so path names using this define are proper

Version 2.18. Tagged as 'Omni-2_18'
@
text
@d562 1
a562 1
 * 	'sprite', along with the small version 'sprite' postfix 's'. The
d565 1
a565 3
 * 	long. Static string. If normal and small size versions of these
 * 	sprites exist with postfix '_22' then these hi-resolution sprites
 * 	will be used in square pixel modes.
@


1.8
log
@Resolve some warnings.
Was actually looking for a different problem, turned out to be nothing to do with OmniClient.

Version 2.16. Tagged as 'Omni-2_16'
@
text
@d426 1
a426 1
        return (_swix (OS_Module, _INR (0, 2), OSModule_Enter, app_DIR"Client", arg_string));
@


1.7
log
@  Removed MemCheck dependencies. Minor fix in !Run file.
Detail:
  As summary for MemCheck. !Run file use of "<Omni$Path>Start" changed
  to "Run Omni:Start", to properly support multiple paths set inside
  "Omni$Path" (in case anyone does that).
Admin:
  Tested with Tungsten env file on a Batch 5 tree using !Mk* Obey files.


Version 2.14. Tagged as 'Omni-2_14'
@
text
@d40 1
a40 1
#include <Global/Services.h>
@


1.6
log
@  2 bug fixes to avoid AODT failures

Detail:
  c.FileType c. 298 .. initialise strings to null
  c.Event c.line 1943 .. dont use mw if it has been freed

Admin:
  tested at castle
  castle added ip


Version 2.13. Tagged as 'Omni-2_13'
@
text
@a47 1
#include <MemCheck/MemCheck.h>
a203 3
  MemCheck_OutputBlocksInfo ();
  MemCheck_Finalise ();

a206 14

#ifdef MemCheck_MEMCHECK

static int  memcheck_vprintf (void *        reference,
                              const char *  format,
                              va_list       args)
{
    dvprintf (("", format, args));
    return 0;
}

#endif


a220 1
//  debug_initialise_trace (DEBUGIT_OUTPUT, "memcheck* cpyrma strip rma_alloc");
a222 9
  
//  MemCheck_Init ();
//  /*MemCheck_RedirectToFilename ("$.omnicheck");*/
//  MemCheck_RedirectToFunction (memcheck_vprintf, 0);
//  MemCheck_SetStoreMallocFunctions (1);
//  MemCheck_InterceptSCLStringFunctions();
//  MemCheck_SetQuitting (0, 0);
//  MemCheck_SetAccessQuitting (0, 0);
  /*MemCheck_SetAutoOutputBlocksInfo (0);*/
a312 2
  MemCheck_RegisterMiscBlock_Ptr (r);

a368 2

  MemCheck_UnRegisterMiscBlock (r);
a596 4
  MemCheck_RegisterMiscBlock_String ((char *) r->r[2]);
  MemCheck_RegisterMiscBlock_String ((char *) r->r[3]);
  MemCheck_RegisterMiscBlock_String ((char *) r->r[4]);
  MemCheck_RegisterMiscBlock_String ((char *) r->r[6]);
a597 4
  MemCheck_UnRegisterMiscBlock ((char *) r->r[2]);
  MemCheck_UnRegisterMiscBlock ((char *) r->r[3]);
  MemCheck_UnRegisterMiscBlock ((char *) r->r[4]);
  MemCheck_UnRegisterMiscBlock ((char *) r->r[6]);
a1274 1
  MemCheck_RegisterMiscBlock_Ptr (r);
a1367 2
  MemCheck_UnRegisterMiscBlock (r);

@


1.5
log
@  * Fixed Bugzilla ID 21, where typing *RMKill OmniClient from the command
    line would cause the error "free failed, (heap overwritten)" if task part
    of the OmniClient module task was running at the time, rendering
    OmniClient unusable and unloadable until the next reboot.
  * Fixed Bugzilla ID 19, where killing a protocol module when OmniClient was
    already loaded would cause an "Invalid Wimp Operation In This Context"
    error.

  * Miscellaneous bug fixes and tidy-ups.
Detail:
  * The "free failed, (heap overwritten)" error is due to a bug in the
    SharedCLibrary, triggered by OmniClient calling getenv in the C library
    from its task.  The bug results from the implementation of getenv calling
    malloc - see Bugzilla ID 28 for further details.  This has been worked
    around by copying the C Library's getenv routine into OmniClient,
    renaming it to omni_getenv, and making all calls to getenv call
    omni_getenv instead; if the malloc happens from within the task rather
    than from within the C library, then things are fine.
  * The "Invalid Wimp Operation In This Context" error is caused by OmniClient
    calling Wimp_CreateMenu with R0=-1 from within the SWI handler that deals
    with protocol module deregistration.  The reasoning for this is that if,
    for example, you have the Mounts menu open, it becomes invalid at this point
    as all of the dying protocol module's mounts become unavailable.  However,
    it is not legal to call Wimp_CreateMenu at this point as you are not in
    your Wimp task context!

    The call to Wimp_CreateMenu has simply been removed.  This doesn't appear
    to cause a problem if you have a menu open with mounts belonging to the
    dying protocol module - attemping to perform an operation on one causes a
    sensible error to be reported.  A possible future enhancement would be to
    use OmniClient's pollword mechanism to cause the task to close any open
    menus on the module's behalf.

    The reason it never occurred before is that it used to call the X-bit-set
    form of the SWI and didn't check the error returned.  When I modified
    OmniClient to use Desk instead of DeskLib, I changed most SWI calls from
    the task part to be non-X-bit-set calls, and used Desk's psuedo-exception
    system to catch and report all errors at the top level of the
    application.

  * Uses AsmUtils to obtain Image$$RO$$Base.

  * Potential write through null pointer fixed in string duplication routines
    cpystr and cpyrma - they weren't checking the result of their allocation
    calls.

  * Replaced the somewhat confusing all_done variable, which could take (magic)
    values between 0 and 2 inclusive to cause different sorts of quit, with
    an enumerated type called RunState.

  * Issuing of Service_OmniClient (dying) in module finalisation made
    unconditional (was previously conditional on the value of all_done), as it's
    most definitely always dying if the finalisation routine is called.  I
    think this was a hangover from when the module finalisation code was
    implemented as an atexit handler.

  * Exit code in the task does not issue Service_OmniClient (dying) if the
    entire filing system is being killed off - this will happen in module
    finalisation, which will be called as a result of the task calling
    OS_ExitAndDie.  This can only happen in "expert" builds.

  * Fixed allocation of too much memory in ItemParse routine!  It dynamically
    creates an array of pointers to structures, but was allocating enough space
    for an array of structures.

  * Fixed potential memory leak in PrintListServers routine - was calling
    realloc and assigning the result directly to the original pointer, instead
    of assigning it to a temporary and only updating the original poiiner if
    the realloc succeeds.

  * Fixed potential null pointer dereference in SortMessages routine - had a
    check for a null pointer parameter at the start, but managed to dereference
    the pointer before the check as part of a variable initialisation.

  * Added all documents from ANT's Docs directory into ours.

Admin:
  Tested on a Risc PC.
  Fixes Bugzilla bugs 19 & 21.

Version 2.08. Tagged as 'Omni-2_08'
@
text
@d237 13
a249 10
  debug_output_device (TML_OUTPUT);
  debug_initialise_trace (TML_OUTPUT, "memcheck* cpyrma strip rma_alloc");

  MemCheck_Init ();
  /*MemCheck_RedirectToFilename ("$.omnicheck");*/
  MemCheck_RedirectToFunction (memcheck_vprintf, 0);
  MemCheck_SetStoreMallocFunctions (1);
  MemCheck_InterceptSCLStringFunctions();
  MemCheck_SetQuitting (0, 0);
  MemCheck_SetAccessQuitting (0, 0);
d717 1
a717 1
  dprintf (("", "ConvertClientToAcorn:\n"));
@


1.4
log
@  Fixed a bug where submenus would sometimes not open.
Detail:
  More fallout from the modifications to use Desk's standard event handling
  mechanisms rather that ANT's customised one.

  Releasing Wimp message event claims in Desk releases all handlers
  registered for that message, not just one.  The Omni code was
  (re)registering the event handlers for all new mounts, so if you had more
  than one mount active and did a dismount, the message event handler would
  be deregistered for all the other active mounts as well.  This means you'd
  no longer revceive MenuWarn messages, so submenus wouldn't be opened.

  All mount event handlers with the exception of the ButtonClick handler are
  now only registered once, irrespective of the number of active mounts, and
  only deregistered once there are no active mounts.  Non-message event
  handlers do not suffer the problem described above, so the ButtonClick
  handler is safe.  The reason it is still registered for each mount is that
  the handler actually uses the user-supplied data for context, whereas none
  of the other handlers did; they obtain it from global variables instead -
  lovely.
Admin:
  Compiled and tested on a Risc PC.

Version 2.07. Tagged as 'Omni-2_07'
@
text
@d42 2
d51 1
d73 22
a94 25
extern int        	taskhandle = 0;			/* Wimp task handle */
extern int      	wind_info = NULL;		/* Window handle */
extern int      	wind_client = NULL;		/* Window handle */
extern int      	wind_mounttmp = NULL;		/* Window handle */
extern int      	wind_mountdom = NULL;		/* Window handle */
extern int      	wind_mountinfo = NULL;		/* Window handle */
extern Desk_linklist_header	mount_anchor = {NULL, NULL};	/* List of mount icon records */
extern Desk_linklist_header	mlist_anchor = {NULL, NULL};	/* List of mount list records */
extern Desk_linklist_header	mwind_anchor = {NULL, NULL};	/* List of mount window records */
extern Desk_linklist_header	client_anchor = {NULL, NULL};	/* List of client records */
extern Desk_linklist_header	item_anchor = {NULL, NULL};	/* List of item records */
extern Desk_linklist_header	ext_anchor = {NULL, NULL};	/* List of file extn mapping records */
extern wind_record	wind_filer = {NULL,NULL,0,0,0,
				      NULL,NULL};	/* Record of servers 'filer' window */
extern config_record    prog_config = {0,0,Desk_FALSE};	/* Program configuration */
extern Desk_linklist_header	print_anchor = {NULL, NULL};	/* List of print job records */
extern Desk_linklist_header	plist_anchor = {NULL, NULL};	/* List of print list records */

extern int		all_done = 0;		/* Exit task */
extern int      	icon_dragtype = 0;		/* Type of drag operation */
extern int 		Image__RO_Base;			/* To get at our module base */
extern _kernel_oserror  omni_errblk = {0, ""};          /* Global error block */
extern int		pollword = pollword_NONE;	/* Poll word non-zero */
extern int		pollword_r0 = -1;		/* Poll word non-zero parameter */
extern char		*pollword_str = NULL;		/* Poll word string */
d96 1
a96 1
extern bool 		all_hasrun = false;		/* true if we have been running task */
d115 1
a115 1
extern void print_clean(void)
d145 1
a145 1
extern void client_clean(void)
d185 3
a187 5
  /* BAL: This does not make sense.  !<anything> will be <= 1 (it's a logical, not a bitwise not).
   * I _think_ this is supposed to do something like only issue ServiceOmni if the whole module is
   * being killed, and not just the filer.
   */
  if (!all_done <= 1) serviceomni(1);
d190 2
d193 1
d195 1
d197 1
d199 1
d201 1
d203 1
a207 2
  debug_terminate ();

d240 2
a241 1
  MemCheck_InitNoDebug ();
d247 1
a247 6
  /* Don't output blocks on every diagnostic.  A lot of diagnostics
   * are produced because of MemCheck faulting accesses to externally
   * supplied mbuf data structures. There are too many instances of
   * these to make it feasible to register them all as misc blocks.
   */
  MemCheck_SetAutoOutputBlocksInfo (0);
d356 1
a356 1
      if (r->r[2] == (int) Image__RO_Base) r->r[1] = 0;
@


1.3
log
@  * Fixed bug which I introduced in previous version, where errors that
    occurred when trying to connect to a mount would cause two errors to be
    reported.
Detail:
  * When I went through blindly changing all _kernel_swi or Desk_SWI calls
    to _swix, I failed to notice that one or two of the calls rely on the
    output parameters being filled in even if an error occurs - _swix does not
    do this.  I've now created a set of type safe C veneers for all calls to
    client modules, which use _swix or _kernel_swi as necessary.  This has the
    additional benefit of making the code more readable and getting rid of
    quite a few uses of magic numbers.
Admin:
  * Compiled and tested on a Risc PC.

Version 2.06. Tagged as 'Omni-2_06'
@
text
@d234 1
a234 1
  debug_initialise_trace (TML_OUTPUT, "memcheck*");
@


1.2
log
@  Several major bugfixes and further tidying to make Omni fit into our
  build environment better.
Detail:
  * Bug fix: ClientList function (Client.c) creates a textual menu desription
    for a list of clients (Info and Mounts submenus).  The description was
    generated on the stack and a pointer to it was returned.  The buffer is now
    static.
  * Bug fix: select or adjust clicks on the Omni icon just after it's loaded
    would kill the task part of Omni.  FilerCreate function (List.c) always
    calls FilerDelete, which would always attempt to close any existing filer
    window.  However, on the first call, no window exists so it passes the Wimp
    a 0 window handle.  This only appeared to happen on RISC OS 4, but I suspect
    this is to do with RISC OS 4's stricter protection of zero page.  Current
    fix is for FilerDelete to check if window handle is 0 before closing it;
    this is not very elegant - would be nicer to only call FilerDelete when the
    window was actually closed.
  * Bug fix: writable icon handling overhauled completely.  Many of the buffers
    which Omni would read the contents of writable icons into were too short
    to hold the maximum amount of text allowed in the icon.  New Icon_GetText
    call added (ExtLib.c) to allow Omni to work directly on indirected icon
    buffers wherever possible, thus removing the whole issue.
  * Stripped commented-out code from several places.
  * Changed use of Desk_bool to bool in most places.  This is a bit grim, but
    the way Desk_bool is implemented means you need to cast it in many places,
    which is even more grim.
  * Removed a few error assignements(!) because
    a) they weren't even being checked
    b) Desk's psuedo-exception system should now catch them
  * Got rid of home-grown strcasecmp calls and used Desk's instead.
  * Removed many local constants definitions and get them from system header
    files instead.
  * Removed Hdrs.h which would include *every* header file in *every* C file
    in the interests of compilation times.  C files now only include what they
    need.
  * Reimplemented the fully recursive Menu_Dispose along the lines of the
    non-recursive Desk_Menu_Dispose, which had changed since ANT's DeskLib
    split-off.
  * Altered quite a bit of code to prevent compiler warnings (mainly
    "use of '=' in condition context" and "variable declared but not used").
  * Uses 'proper' module finalisation instead of atexit in the interests of
    consistency and symmetry.
  * Added MemCheck support.
  * Reimplemented rma_alloc and rma_free in C (side effect of MemCheck support).
  * Altered assembler to use system header files instead of local ones.
  * Omni previously used a seeming random mixture of _kernel_swi and Desk_SWI
    SWI veneers.  All have now been changed to use _swix/_swi as appropriate.
  * Converted to use srccommit.
Admin:
  Files removed:
   c.Error
   c.StrCaseCmp
   h.Debug
   h.Hdrs
   h.ModuleWrap
   h.OmniClient
   h.StrCaseCmp
   hdr.Macros
   hdr.RegDefs
   hdr.SwiNos

  Files added:
   Docs.DeskLibDiffs
   Docs.EventHandling
   h.Omni

  * Compiled.
  * All windows, menus checked to make sure they at least display.
  * Played around with a new NFS and LanMan mounts.
  * Basically, there shouldn't be any showstoppers, but the change from a very
    old DeskLib to Desk is a large one.  I'd be surprised if there aren't a
    few problems and this should definitely be thrashed a bit by people
    willing to do so before anyone has any confidence in it.



Version 2.05. Tagged as 'Omni-2_05'
@
text
@d233 2
a234 2
  debug_output_device (FILE_OUTPUT);
  debug_initialise_trace (FILE_OUTPUT, "memcheck*");
d428 2
a429 1
        dprintf (("", "OMNI running for first time - checking Desktop running\n"));
d445 1
d451 1
a451 1
        dprintf (("", "OMNI running for first time - calling Desktop_OmniClient\n"));
d459 1
a459 1
        dprintf (("", "OMNI running for nth time\n"));
d969 3
a971 3
  err = _swix (pr->client_id, _INR (0, 3) | _OUT (3),
               11, pr->pjob_id, r->r[1], r->r[2],
               &r->r[2]);
d995 1
a995 1
  err = _swix(pr->client_id, _INR (0, 1), 12, pr->pjob_id);
d1031 1
a1031 1
        _kernel_oserror *temp_err = _swix(cr->client_id, _INR (0, 1), 13, 0);
d1056 1
a1056 1
    err = _swix(pr->client_id, _INR (0, 1), 13, pr->pjob_id);
d1106 8
a1113 3
  err = _swix (pr->client_id, _INR (0, 1) | _OUTR (1, 6),
               14,pr->pjob_id,
               &r->r[1], &r->r[2], &r->r[3], &r->r[4], &r->r[5], &r->r[6]);
d1138 1
a1138 1
  int lstatus, rstatus;
d1149 2
a1150 4
      /* Call OmniOp, 14 (Get Print Job Info) */
      err = _swix (pr->client_id, _INR (0, 1) | _OUT (1) | _OUT (4),
                   14, pr->pjob_id,
                   &lstatus, &rstatus);
d1154 1
a1154 1
        err = _swix (pr->client_id, _INR (0, 1), 15, pr->pjob_id);
d1167 2
a1168 4
    /* Call OmniOp, 14 (Get Print Job Info) */
    err = _swix (pr->client_id, _INR (0, 1) | _OUT(1) | _OUT (4),
                 14, pr->pjob_id,
                 &lstatus, &rstatus);
d1176 1
a1176 1
      err = _swix (pr->client_id, _INR (0, 1), 15, pr->pjob_id);
@


1.1
log
@Initial revision
@
text
@d31 27
a57 5
#include "Hdrs.h"
#include "netdb.h"
#include "ModuleWrap.h"
#include "DebugLib/DebugLib.h"

d59 10
d88 1
a88 1
extern Desk_bool		all_done = Desk_FALSE;		/* Exit task */
d95 2
a96 29
/* extern Desk_bool		all_restart = Desk_TRUE; */		/* Desk_TRUE if we are just RMLoading */
extern Desk_bool 		all_hasrun = Desk_FALSE;		/* Desk_TRUE if we have been running task */

#ifdef DEBUG
extern FILE 		*omniout = NULL;		/* Debug trace file handle */

/*  Initialise debug spool files.
 */
static Desk_bool debuginit(void)
{
  char filebuf[256];

  sprintf(filebuf, "<%s$Dir>.!TRACE", app_DIR);
  if ((omniout = fopen(filebuf, "w")) == NULL) return(Desk_FALSE);
  return(Desk_TRUE);
}


/*  Finalise debug spool files.
 */
static void debugclose(void)
{
  if (omniout != NULL) fclose(omniout);
}
#else
#define debuginit()	((void) 0)
#define debugclose()	((void) 0)
#endif

a102 1
  TRACE("mlist_clean: enter\n");
a109 1
  TRACE("mlist_clean: exit\n");
a117 1
  TRACE("print_clean: enter\n");
a124 1
  TRACE("print_clean: exit\n");
a132 1
  TRACE("plist_clean: enter\n");
a139 1
  TRACE("plist_clean: exit\n");
a147 1
  TRACE("client_clean: enter\n");
a154 1
  TRACE("client_clean: exit\n");
a161 1
  TRACE1("removetask: %x\n", taskhandle);
a165 1
  TRACE("removetask: completed\n");
d173 1
a173 7
  _kernel_swi_regs r;

  TRACE1("serviceomni: %d\n", num);
  r.r[0] = num;
  r.r[1] = Service_OmniAction;
  _kernel_swi(XOS_Bit | OS_ServiceCall, &r, &r);
  TRACE("serviceomni: completed\n");
d179 1
a179 1
_kernel_oserror *fs_finalise(int fatal, int podule, void *pw)
d181 8
a188 1
  TRACE("fs_finalise:\n");
d190 1
d198 3
a200 2
  TRACE("fs_finalise: completed\n");
  /* debugclose(); */
d204 1
d208 13
d233 15
a247 2
  debug_output_device (TML_OUTPUT);
  debug_initialise_trace (TML_OUTPUT, "");
d260 1
a260 1
    /* debuginit(); */
a263 1
      debugclose();
a266 1
    /*atexit(fs_finalise);*/
a269 1
    #if 0
a270 1
    #endif
d276 1
a276 1
    err = Desk_Error2_ConvertToOS2();
a285 1
/*#ifdef TRACESERVICE*/
d293 40
a332 40
  {0x00,"Serviced"},
  {0x04,"UKCommand"},
  {0x06,"Error"},
  {0x07,"UKByte"},
  {0x08,"UKWord"},
  {0x09,"Help"},
  {0x0b,"ReleaseFIQ"},
  {0x0c,"ClaimFIQ"},
  {0x11,"Memory"},
  {0x12,"StartUpFS"},
  {0x27,"Reset"},
  {0x28,"UKConfig"},
  {0x29,"UKStatus"},
  {0x2a,"NewApplication"},
  {0x40,"FSRedclare"},
  {0x41,"Print"},
  {0x42,"LookupFileType"},
  {0x43,"International"},
  {0x44,"Keyhandler"},
  {0x45,"PreReset"},
  {0x46,"ModeChange"},
  {0x47,"ClaimFIQinBackground"},
  {0x48,"ReAllocatePorts"},
  {0x49,"StartWimp"},
  {0x4a,"StartedWimp"},
  {0x4b,"StartFiler"},
  {0x4c,"StartedFiler"},
  {0x4d,"PreModeChange"},
  {0x4e,"MemoryMoved"},
  {0x4f,"FilerDying"},
  {0x50,"ModeExtension"},
  {0x51,"ModeTranslation"},
  {0x52,"MouseTrap"},
  {0x53,"WimpCloseDown"},
  {0x54,"Sound"},
  {0x55,"NetFS"},
  {0x56,"EconetDying"},
  {0x57,"WimpReportError"},
  {0x60,"ResourceFSStarting"},
  {-1,"Something else"}
a334 1
/*#endif */
d338 12
a349 3
/* #ifdef TRACESERVICE */
#ifdef DEBUG
  int i;
d351 1
a351 7
  for (i=0; svcs[i].svc >= 0; i++) if (svcs[i].svc == service_number) break;
  dprintf(("", "Service_%s (%#x)%x,%x,%x,%x,%x,%x,%x,%x,%x,%x\n", svcs[i].name,
        service_number, r->r[0],r->r[1],r->r[2],r->r[3],r->r[4],r->r[5],r->r[6],r->r[7],
        r->r[8],r->r[9]));
#endif
/* #endif */
  /* TRACE1("service: %x\n", service_number); */
d358 1
d364 1
a364 1
      TRACE1("Service_StartFiler task %d\n", taskhandle);
d372 1
d374 1
a374 1
      TRACE1("Service_StartedFiler %d\n", taskhandle);
d377 1
d379 1
a379 1
    case Service_ShutdownComplete:
d386 1
d388 1
a388 1
      TRACE1("Service_FilerDying %d\n", taskhandle);
d391 1
a394 1
    /* Handle other service calls here */
d396 2
a400 4
#define OS_FSControl		0x000029
#define _Wimp_StartTask		0x0400de
#define Wimp_ReadSysInfo	0x0400F2

a404 2
  _kernel_swi_regs rr;
  _kernel_swi_regs *r = &rr;
d407 2
a408 4
  argc = argc;
  private_word = private_word;

  dprintf (("", "fs_command\n"));
d413 3
a415 3
    case 0:			/* Desktop_<app_DIR> */
      TRACE2("Desktop_OmniClient called handle %d hasrun %d\n", taskhandle, all_hasrun);
      TRACE1("Desktop_OmniClient called args '%s'\n", arg_string);
d418 1
a418 1
        if (argc > 1) MountCLI(arg_string, Desk_FALSE);
d424 1
a424 1
        Desk_bool start = Desk_TRUE;
d428 14
a441 5
        TRACE("OMNI running for first time - checking Desktop running\n");
        Desk_SWI(1,1, Wimp_ReadSysInfo, 0, &active);
        if (active <= 0) start = Desk_FALSE;
        Desk_SWI(1,1, Wimp_ReadSysInfo, 3, &active);
        if (active == 0) start = Desk_FALSE;
d445 1
a445 1
          if (argc > 1) MountCLI(arg_string, Desk_FALSE);
d449 1
a449 1
        TRACE("OMNI running for first time - calling Desktop_OmniClient\n");
d453 1
a453 4
        r->r[0] = OSModule_Enter;
        r->r[1] = (int) app_DIR"Client";
        r->r[2] = (int) arg_string;
        return(_kernel_swi(XOS_Bit | OS_Module, r, r));
d457 1
a457 1
        TRACE("OMNI running for nth time\n");
d461 3
a463 2
    case 1:			/* OmniMount */
      MountCLI(arg_string, Desk_FALSE);
d466 2
a467 1
    case 2:			/* OmniLoadMounts */
d471 3
a473 4
    case 3:			/* OmniPrint */
      r->r[0] = 14;
      r->r[1] = (int) fsname;
      return(_kernel_swi(XOS_Bit | OS_FSControl, r, r));
d482 1
a482 1
/* Desk_SWI omni_base+0 "Omni_EnumerateMounts"
d504 1
a504 1
  TRACE2("EnumerateMounts: %x %x\n", r->r[0], r->r[1]);
d516 2
a517 2
/* Desk_SWI omni_base+1 "Omni_RegisterClient"
 *	On entry, R0 = client_id, (Desk_SWI xxxx_OmniOp)
d562 1
a562 1
 * 	separator is used by the Omni_Convert Desk_SWI calls.
d591 1
a591 1
 * 	the xxxx_MiscOp Desk_SWI number) must be no more than 6 characters
d622 12
a633 2
  client_record *cr = ClientCreate(r);
  TRACE("RegisterClient:\n");
d644 1
a644 1
/* Desk_SWI omni_base+2 "Omni_DeregisterClient"
d650 1
a650 1
 *      This SWI is the companion call to Desk_SWI Omni_RegisterClient, and
d656 1
a656 1
  TRACE("DeregisterClient:\n");
d668 1
a668 1
/* Desk_SWI omni_base+3 "Omni_MessageLookup"
d687 1
a687 1
  TRACE2("MessageLookup: %x %x\n", r->r[0], r->r[1]);
d692 1
a692 1
/* Desk_SWI omni_base+4 "Omni_ConvertClientToAcorn"
d704 1
a704 1
 *	Note that this mapping Desk_SWI deals with mappings for multiple
d712 1
a712 1
  TRACE("ConvertClientToAcorn:\n");
d721 1
a721 1
/* Desk_SWI omni_base+5 "Omni_ConvertAcornToClient"
d734 1
a734 1
 *	Note that this mapping Desk_SWI deals with mappings for multiple
d741 1
a741 1
  TRACE("ConvertAcornToClient:\n");
d751 1
a751 1
/* Desk_SWI omni_base+6 "Omni_ConvertTime"
d774 1
a774 1
  TRACE("ConvertTime:\n");
d778 1
a778 1
  TRACE1("ConvertTime: src %d\n", src);
d798 1
a798 1
  TRACE1("ConvertTime: dst %d\n", dst);
d816 1
a816 1
  TRACE("ConvertTime: exit\n");
d821 1
a821 1
/* Desk_SWI omni_base+7 "Omni_Printers"
d843 1
a843 1
 *      The Desk_SWI is firstly called with R3=NULL,R4=-1, and the call returns
d846 1
a846 1
 *      Desk_SWI is called the second time, with the new R3/R4.
d880 1
a880 1
  TRACE1("Printers: %x\n", r->r[0]);
d909 1
a909 1
/* Desk_SWI omni_base+8 "Omni_CreateJob"
d924 1
a924 1
 *      The protocol name (R0) is the name as provided by Desk_SWI Omni_Printers
d931 1
a931 1
 *      program calls Desk_SWI Omni_PrinterInfo, reason code 2, it can determine
d939 1
a939 1
  TRACE("CreateJob:\n");
d946 1
a946 1
/* Desk_SWI omni_base+9 "Omni_SendJob"
d962 1
a962 1
  TRACE("SendJob:\n");
d967 3
a969 2
  err = (_kernel_oserror *) Desk_SWI(4,4, pr->client_id, 11,pr->pjob_id,r->r[1],r->r[2],
    NULL,NULL,NULL,&r->r[2]);
d976 1
a976 1
/* Desk_SWI omni_base+10 "Omni_EndJob"
d988 1
a988 1
  TRACE("EndJob:\n");
d993 1
a993 1
  err = (_kernel_oserror *) Desk_SWI(2,0, pr->client_id, 12,pr->pjob_id);
d1006 1
a1006 1
/* Desk_SWI omni_base+11 "Omni_AbortJob"
d1019 1
a1019 1
  TRACE("AbortJob:\n");
d1026 9
a1034 1
      if (PrintFind(-1, -1, cr->client_id, -1) != NULL) Desk_SWI(2,0, cr->client_id, 13,0);
d1054 1
a1054 1
    err = (_kernel_oserror *) Desk_SWI(2,0, pr->client_id, 13,pr->pjob_id);
d1068 1
a1068 1
/* Desk_SWI omni_base+12 "Omni_JobStatus"
d1098 1
a1098 1
  TRACE("JobStatus:\n");
d1102 1
d1104 4
a1107 2
  err = (_kernel_oserror *) Desk_SWI(2,7, pr->client_id, 14,pr->pjob_id,
    NULL,&r->r[1],&r->r[2],&r->r[3],&r->r[4],&r->r[5],&r->r[6]);
d1114 1
a1114 1
/* Desk_SWI omni_base+13 "Omni_ClearJob"
d1133 1
a1133 1
  TRACE("ClearJob:\n");
d1143 3
a1145 2
      err = (_kernel_oserror *) Desk_SWI(2,5, pr->client_id, 14,pr->pjob_id,
        NULL,&lstatus,NULL,NULL,&rstatus);
d1149 1
a1149 1
        err = (_kernel_oserror *) Desk_SWI(2,0, pr->client_id, 15,pr->pjob_id);
d1163 7
a1169 6
    err = (_kernel_oserror *) Desk_SWI(2,5, pr->client_id, 14,pr->pjob_id,
      NULL,&lstatus,NULL,NULL,&rstatus);
    TRACE1("ClearJob: jobinfo = %x\n", (int) err);
    TRACE1("ClearJob: %x\n", lstatus);
    TRACE2("ClearJob: %x %x\n", pflagSET(lstatus, print_COMPLETE),
      pflagSET(lstatus, print_ERROR));
d1173 2
a1174 2
      err = (_kernel_oserror *) Desk_SWI(2,0, pr->client_id, 15,pr->pjob_id);
      TRACE1("ClearJob: clearclient = %x\n", (int) err);
d1184 1
a1184 1
/* Desk_SWI omni_base+14 "Omni_PrinterInfo"
d1219 1
a1219 1
  TRACE("PrinterInfo:\n");
d1231 1
a1231 1
/* Desk_SWI omni_base+15 "Omni_EnumerateJobs"
d1246 1
a1246 1
 *	OmniPrint filing system, or by another application using Desk_SWI
d1256 1
a1256 1
  TRACE("EnumerateJobs:\n");
d1262 1
a1262 1
/* Desk_SWI omni_base+16 "Omni_NameLookup"
d1284 1
a1284 1
  TRACE("NameLookup:\n");
d1301 1
a1301 1
/*  User Desk_SWI call handler.
d1305 7
a1311 1
  TRACE1("fs_swi: %d\n", swi_no);
d1314 2
a1315 2
    case 0: /* Omni_EnumerateMounts */
      return(EnumerateMounts(r));
d1317 3
a1319 2
    case 1: /* Omni_RegisterClient */
      return(RegisterClient(r));
d1321 3
a1323 2
    case 2: /* Omni_DeregisterClient */
      return(DeregisterClient(r));
d1325 3
a1327 2
    case 3: /* Omni_MessageLookup */
      return(MessageLookup(r));
d1329 3
a1331 2
    case 4: /* Omni_ConvertClientToAcorn */
      return(ConvertClientToAcorn(r));
d1333 3
a1335 2
    case 5: /* Omni_ConvertAcornToClient */
      return(ConvertAcornToClient(r));
d1337 3
a1339 2
    case 6: /* Omni_ConvertTime */
      return(ConvertTime(r));
d1341 3
a1343 2
    case 7: /* Omni_Printers */
      return(Printers(r));
d1345 3
a1347 2
    case 8: /* Omni_CreateJob */
      return(CreateJob(r));
d1349 3
a1351 2
    case 9: /* Omni_SendJob */
      return(SendJob(r));
d1353 3
a1355 2
    case 10: /* Omni_EndJob */
      return(EndJob(r));
d1357 3
a1359 2
    case 11: /* Omni_AbortJob */
      return(AbortJob(r));
d1361 3
a1363 2
    case 12: /* Omni_JobStatus */
      return(JobStatus(r));
d1365 3
a1367 2
    case 13: /* Omni_ClearJob */
      return(ClearJob(r));
d1369 3
a1371 2
    case 14: /* Omni_PrinterInfo */
      return(PrinterInfo(r));
d1373 3
a1375 2
    case 15: /* Omni_EnumerateJobs */
      return(EnumerateJobs(r));
d1377 3
a1379 2
    case 16: /* Omni_NameLookup */
      return(NameLookup(r));
d1381 8
a1388 2
    case 17: /* Omni_TraceFile */
#ifdef DEBUG
d1390 5
a1394 1
#else
a1395 1
#endif
d1399 1
a1399 3
      omni_errblk.errnum = 0x1e6;
      strcpy(omni_errblk.errmess, "Bad Desk_SWI call");
      return(&omni_errblk);
d1403 2
d1406 1
a1406 1
  return(NULL);
@


1.1.1.1
log
@  Initial import of Omni into CVS.

Detail:
  This is an import of the sources obtained from ANT some time ago, with
  sufficient changes to allow it to build in our standard environment.  In
  particular, this involved converting Omni to use Desk instead of DeskLib.
  ANT's DeskLib was not 'off-the-shelf' - it was based on DeskLib 2.04 (very
  old), with their own modifications.
  
  This means that there are quite severe bugs in the Omni code, which will
  show up if you attempt to use this version, which were previously masked by
  some of ANT's DeskLib alterations.  (Hopefully) most of these have already
  been identified, fixed and will be checked-in soon.  I felt that a
  minimal version that would simply build would be worthwhile, so that as
  many changes as possible end up under CVS' control.

Admin:
  Compiled.
  Untested.
@
text
@@

head	4.22;
access;
symbols
	NetTime-0_43:4.22
	NetTime-0_42:4.22
	NetTime-0_41:4.21
	NetTime-0_40:4.20
	NetTime-0_39:4.19
	NetTime-0_38:4.18
	NetTime-0_37:4.17
	NetTime-0_36:4.16
	NetTime-0_35:4.16
	NetTime-0_34:4.16
	NetTime-0_33:4.16
	NetTime-0_32:4.16
	NetTime-0_31:4.15
	NetTime-0_30:4.14
	NetTime-0_29:4.13
	dellis_autobuild_BaseSW:4.13
	NetTime-0_28:4.13
	NetTime-0_26:4.13
	NetTime-0_25:4.13
	NetTime-0_24:4.13
	NetTime-0_23:4.12
	sbrodie_sedwards_16Mar2000:4.10
	NetTime-0_22:4.11
	NetTime-0_21:4.10
	NetTime-0_20:4.9
	dcotton_autobuild_BaseSW:4.13
	NetTime-0_16:4.8
	NetTime-0_15:4.7
	NetTime-0_14:4.7
	NetTime-0_13:4.6
	NetTime-0_12:4.6
	NetTime-0_11:4.6
	NetTime-0_10:4.5
	NetTime-0_09:4.5
	NetTime-0_08:4.4
	NetTime-0_07:4.4
	NetTime-0_06:4.3
	NetTime-0_05:4.3
	NetTime-0_04:4.2
	afrost_NC2_Generic:4.1.7.5
	Spinner_RCA116:4.1.7.5
	Spinner_B20_2:4.1.7.5
	Spinner_19_3:4.1.7.5
	Spinner_B18:4.1.7.5
	Spinner_B17:4.1.7.5
	Spinner_B15:4.1.7.5
	Spinner_B14:4.1.7.3
	Spinner_B13:4.1.7.3
	Spinner_B12:4.1.7.3
	Spinner_B10:4.1.7.3
	Spinner_B7:4.1.7.3
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.5
	MergeFiles:4.1.7.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1;
locks; strict;
comment	@# @;


4.22
date	2013.11.24.12.17.17;	author rsprowson;	state Exp;
branches;
next	4.21;
commitid	kdgSEA52DRKJIwex;

4.21
date	2013.11.17.11.19.31;	author rsprowson;	state Exp;
branches;
next	4.20;
commitid	NvSppOvMaHeSCCdx;

4.20
date	2012.04.10.08.36.27;	author rsprowson;	state Exp;
branches;
next	4.19;
commitid	Tg6Nm8lS5s1Jyi0w;

4.19
date	2012.02.25.08.18.16;	author rsprowson;	state Exp;
branches;
next	4.18;
commitid	7cQZQe1cYi4cUvUv;

4.18
date	2012.02.12.15.36.20;	author rsprowson;	state Exp;
branches;
next	4.17;
commitid	Z5V6e85W3FhqKSSv;

4.17
date	2012.02.04.22.08.39;	author rsprowson;	state Exp;
branches;
next	4.16;
commitid	W0erdTttgEwVaTRv;

4.16
date	2004.05.19.18.21.24;	author kbracey;	state Exp;
branches;
next	4.15;

4.15
date	2002.07.23.12.39.02;	author srevill;	state Exp;
branches;
next	4.14;

4.14
date	2002.04.25.15.20.53;	author srevill;	state Exp;
branches;
next	4.13;

4.13
date	2000.07.21.15.00.30;	author jberanek;	state Exp;
branches;
next	4.12;

4.12
date	2000.03.20.16.05.27;	author kbracey;	state Exp;
branches;
next	4.11;

4.11
date	2000.03.16.16.50.16;	author kbracey;	state Exp;
branches;
next	4.10;

4.10
date	2000.03.15.15.38.01;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	2000.03.07.10.44.49;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	99.07.05.18.11.15;	author dcotton;	state Exp;
branches;
next	4.7;

4.7
date	99.06.09.14.30.23;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.01.13.19.12.17;	author jfarrell;	state Exp;
branches;
next	4.5;

4.5
date	98.12.01.12.03.17;	author jfarrell;	state Exp;
branches;
next	4.4;

4.4
date	98.11.24.16.26.05;	author jfarrell;	state Exp;
branches;
next	4.3;

4.3
date	98.11.24.10.51.40;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	98.11.23.19.44.48;	author smiddle;	state Exp;
branches;
next	4.1;

4.1
date	96.11.21.13.41.12;	author nturton;	state Exp;
branches
	4.1.5.1
	4.1.7.1;
next	;

4.1.5.1
date	96.11.21.13.41.12;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.22.15.56;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.20.13.48.04;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.22.15.26.44;	author askelton;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.05.30.13.08.13;	author askelton;	state Exp;
branches;
next	4.1.7.5;

4.1.7.5
date	97.06.26.17.24.06;	author askelton;	state Exp;
branches;
next	;


desc
@@


4.22
log
@Delagate RTC adjustments to RTC module when present
When the RTC module is present don't try making the duplicate adjustments in this module, while largely harmless the status report would likely be out of sync as the two modules battle eachother for who can poke timer 0 more often.
Changed files
 machine.c: double quotes in debug text removed
 ntp.c: use some named defines for OS_Hardware calls
 Spec: typo correction
 rtcadjust.c: when RTC module is active, delagate adjustments to RTC_Adjust SWI

Tested on a Risc PC over 24 hours.

Version 0.42. Tagged as 'NetTime-0_42'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>

#include "socklib.h"
#include "inetlib.h"
#include "sys/ioctl.h"
#include "sys/errno.h"
#include "netinet/in_systm.h"
#include "netinet/ip.h"
#include "netdb.h"

#include "Interface/NetTime.h"
#include "nettime.h"
#include "nt_nvram.h"
#include "header.h"
#include "dns.h"
#include "rtcadjust.h"
#include "ntp.h"

#include <swis.h>

#include <string.h>
#include <stddef.h>

/*
 * Public vars
 */
int sockno;
int synchronised;
struct in_addr last_server;
transition_t callback_reason;
int last_protocol;
int poll_period = LONG_TIMER;
#ifdef DEBUGLIB
char inet_resolvers[128];
#endif

static int attempts;
static int using_ntp;
static int last_set_succeeded;
static int guess_protocol;
static char env_time_server[MAX_ENV_TIME_SERVER];
static struct sockaddr_in sockaddr;

#ifdef DEBUGLIB
/* State and transition names for debug output - keep these in step with definitions
 * in nettime.h
 */
static const char *transitions[] = {"NoTrans", "Init", "Die", "PostInit", "Response", "Failure", "Timer", "LinkUp", "LinkDown", "RegistryChanged", "DoDNS"};
#define TRANSNAME(i) ((((i) < 0) || ((i) > sizeof(transitions)/sizeof(char *))) ? \
			"Invalid transition" : transitions[i])
#endif

static const char *states[] = {"Dormant", "NoLink", "Sleeping", "Expecting", "DNSWait"};
#define STATENAME(i) ((((i) < 0) || ((i) > sizeof(states)/sizeof(char *))) ? \
			"Invalid state" : states[i])

/*
 * Private function defs
 */
static int tryresolve(struct sockaddr_in *sa);
static int tryconnect(struct sockaddr_in *sa);
static int isdialup(void);
static int local_settimeofday(void);
static void settimer(int duration);
static void canceltimer(void);
static void closeconnect(void);
static int probe(void);

static state_t state = Dormant;

/*
 * State machine
 *
 * Description of states:
 *	Dormant:	Waiting for other modules to load / smartcard info
 *	NoLink:		Waiting for link to come up on dial-up machine
 *	DNSWait:	Waiting for DNS lookup of time server host name
 *	Expecting:	Waiting for socket response or failure
 *	Sleeping:	Waiting for timer callback because either:
 *			a) Successfully set the time (long Timer)
 *			b) Couldn't connect or read (short Timer), will retry
 */
void machine(transition_t transition)
{
  transition_t next_trans;
  int status;

  for (; transition != NoTrans; transition = next_trans)
  {
    dprintf(("debug", "State %d (%s), transition %d (%s)\n",
    	state, STATENAME(state), transition, TRANSNAME(transition)));

    /* There is no "next transition" unless set whilst handling current transition */
    next_trans = NoTrans;

    switch(state)
    {
    case Dormant:
      switch(transition)
      {
      case PostInit:
      case Init:
        if (isdialup())
          state = NoLink;
        else
          next_trans = LinkUp;
        continue;

      case LinkUp:
      case RegistryChanged:
        next_trans = DoDNS;
        state = DNSWait;
        continue;

      case Die:
      case LinkDown:
        continue;
      }
      break;

    case NoLink:
      switch(transition)
      {
      case LinkUp:
        next_trans = DoDNS;
        state = DNSWait;
        continue;

      case LinkDown:
      case RegistryChanged:
        continue;

      case Die:
        state = Dormant;
        continue;
      }
      break;

    case Sleeping:
      switch(transition)
      {
      case Timer:
      case LinkUp:
      case RegistryChanged:
        next_trans = DoDNS;
        state = DNSWait;
        continue;

      case LinkDown:
        canceltimer();
        state = NoLink;
        continue;

      case Die:
        canceltimer();
        state = Dormant;
        continue;
      }
      break;

    case DNSWait:
      switch(transition)
      {
      case DoDNS:
      case Timer:
        last_set_succeeded = 0;
        status = tryresolve(&sockaddr);
        switch (status)
        {
          case EINPROGRESS:
            /* Resolve in progress - poll again shortly */
	    settimer(POLL_TIMER);
            continue;

          case 0:
	    /* Resolve complete - connect to server */
            if (tryconnect(&sockaddr) && probe()) {
              last_server = sockaddr.sin_addr;
              last_protocol = using_ntp ? PORT_NTP : PORT_TIME;
              settimer(RETRY_TIMER);
              state = Expecting;
            }
            else {
              rtcadjust_suspend();
              settimer(SHORT_TIMER);
              state = Sleeping;
            }
            continue;

	  default:
            /* Resolve failed - retry later */
            rtcadjust_suspend();
	    settimer(SHORT_TIMER);
	    state = Sleeping;
	    continue;
        }

      case LinkDown:
        canceltimer();
        state = NoLink;
        continue;

      case Die:
        canceltimer();
        state = Dormant;
        continue;

      case RegistryChanged:
        /* Registry changed whilst waiting for DNS completion.  Stop poll timer
         * and try again with (possibly) new timeserver.
         */
        canceltimer();
        next_trans = DoDNS;
        continue;
      }
      break;

    case Expecting:
      switch(transition)
      {
      case Response:
        last_set_succeeded = local_settimeofday();
        if (last_set_succeeded)
        {
          canceltimer();
          if (poll_period)
          {
            state = Sleeping;
            settimer(poll_period);
          }
          else
            state = Dormant;
        }
        continue;

      case Failure:
        last_protocol = 0;
        rtcadjust_suspend();
        closeconnect();
        settimer(SHORT_TIMER);
        state = Sleeping;
        continue;

      case Timer:
        if (attempts > 4 || !probe()) {
            rtcadjust_suspend();
            closeconnect();
            settimer(SHORT_TIMER);
            last_protocol = 0;
            state = Sleeping;
        }
        else
            settimer(RETRY_TIMER << (attempts-1));
        continue;

      case LinkDown:
        canceltimer();
        rtcadjust_suspend();
        closeconnect();
        state = NoLink;
        continue;

      case Die:
        canceltimer();
        rtcadjust_suspend();
        closeconnect();
        state = Dormant;
        continue;
      }
      break;

    } /* end of switch(state) */

    dprintf(("debug", "Bogus state/transition combo: state=%d, transition=%d\n",
    	     state, transition));

  } /* for (; transition != NoTrans; transition = next_trans) */

  dprintf(("debug", "Machine resting in state=%d\n", state));
}



/* Returns non-0 if on a dialup machine (ie PPP module present) */
static int isdialup(void)
{
  return(_swix(PPP_DCIVersion, _IN(0), 0) == NULL);
}

/* tryresolve()
 *   Try to resolve the TimeServer hostname to an IP address.
 *   The hostname is read in the following manner:
 *    From the system variable "Inet$TimeServer" if set;
 *    From  the system variable "NetTime$Server" if set;
 *    From the smart card tag "TIME_PRIMARY" otherwise.
 *
 * Returns:
 *   0		 - Address resolved, result in 'sockaddr'.
 *   EINPROGRESS - DNS lookup in progress; waiting for response.  To
 *                 collect the response this routine should be
 *                 polled on a timer until it returns 0 or another
 *                 error.
 *   Otherwise	 - Request failed.
 *
 */
static int tryresolve(struct sockaddr_in *sockaddr)
{
  dialler_status_t dialler_status;
  int ipaddress, i;
  int status;

  /*
   * Ensure that if the dialler module is around to return a status,
   * the status returned is a connected status
   */
  if ((_swix(Dialler_Status, _IN(0)|_OUT(0), 0, &dialler_status) == NULL) &&
      !CONNECTED(dialler_status))
  {
    dprintf(("debug", "Dialler bailed! r0=%x\n", dialler_status));
    return -1;
  }

  /* Attempt to read from the Inet$NTPServer system variable */
  dprintf(("debug", "checking environment variable %s\n", ENV_TIME_SERVER2));
  if(read_os_var(ENV_NTP_SERVER, env_time_server, MAX_ENV_TIME_SERVER)>0)
  { /* we have a configured time server */
    dprintf(("debug", "read environment variable: %s\n", env_time_server));
    using_ntp = 1;
    guess_protocol = 0;
  }
  else
  {
    /* Attempt to read from the Inet$TimeServer system variable */
    dprintf(("debug", "checking environment variable %s\n", ENV_TIME_SERVER2));
    if(read_os_var(ENV_TIME_SERVER2, env_time_server, MAX_ENV_TIME_SERVER)>0)
    { /* we have a configured time server */
      dprintf(("debug", "read environment variable: %s\n", env_time_server));
      using_ntp = 0;
      guess_protocol = 0;
    }
    else
    {
      /* Attempt to read from the NetTime$Server system variable */
      dprintf(("debug", "checking environment variable %s\n", ENV_TIME_SERVER));
      if(read_os_var(ENV_TIME_SERVER, env_time_server, MAX_ENV_TIME_SERVER)>0)
      { /* we have a configured time server */
        dprintf(("debug", "read environment variable: %s\n", env_time_server));
        using_ntp = 1;
        guess_protocol = 1;
      }
      else
      {
        /* Ask the Registry who we should contact */
        dprintf(("debug", "Requesting the time server from Managed Access\n"));
        if (_swix(NCAccessManager_Enquiry, _INR(0,2)|_OUT(0),
                  NCRegistry_TimeServerTag, env_time_server, MAX_ENV_TIME_SERVER,
                  &i))
        {
          dprintf(("debug", "NCAccessManager bailed! r0=%x\n", i));
          return -1;
        }

        using_ntp = 1;
        guess_protocol = 1;

        if(i == 4) { /* packed IP address */
          ipaddress = *(int *)env_time_server;
          dprintf(("debug", "NCAccessManager says timeserver IP address is %08x\n", ipaddress));
          if (ipaddress == 0) return -1;
          sockaddr->sin_addr.s_addr = ipaddress; /* address already in network order */

          return 0; /* complete */
        } else {
          dprintf(("debug", "NCAccessManager says timeserver host is %s\n", env_time_server));
        }
      }
    }
  }

#ifdef DEBUGLIB
  if (read_os_var(ENV_RESOLVER, inet_resolvers, sizeof(inet_resolvers))>0)
    dprintf(("debug", ENV_RESOLVER ": %s\n", inet_resolvers));
  else
    dprintf(("debug", ENV_RESOLVER " not set!\n"));
#endif


  /*  Lookup server as a dot-quad IP string or hostname.
   */
  status = dns_find_ip_address(env_time_server, &sockaddr->sin_addr);
  if (status == EINPROGRESS) {
    dprintf(("debug", "tryresolve: DNS says EINPROGRESS\n"));
  } else if (status == 0) {
    dprintf(("debug", "tryresolve: DNS says done\n"));
  } else {
    dprintf(("debug", "tryresolve: DNS says failed (status = %d)\n", status));
  }

  return status;
}


/* Returns non-0 if connect successfully initiated */
static int tryconnect(struct sockaddr_in *sa)
{
  dialler_status_t dialler_status;
  int i;

  /*
   * Ensure that if the dialler module is around to return a status,
   * the status returned is a connected status
   */
  if ((_swix(Dialler_Status, _IN(0)|_OUT(0), 0, &dialler_status) == NULL) &&
      !CONNECTED(dialler_status))
  {
    dprintf(("debug", "Dialler bailed! r0=%x\n", dialler_status));
    return -1;
  }

  dprintf(("debug", "trying to connect\n"));

  dprintf(("debug", "Using time server 0x%x\n", (int)sa->sin_addr.s_addr));

  if (last_server.s_addr == sa->sin_addr.s_addr && last_protocol == PORT_TIME &&
      guess_protocol)
      using_ntp = 0;

  sa->sin_family = AF_INET;
  sa->sin_port = ntohs(using_ntp ? PORT_NTP : PORT_TIME);

  /* Make a non-blocking async socket */
  sockno = socket(AF_INET, SOCK_DGRAM, 0);
  i=1;
  socketioctl(sockno, FIONBIO, &i);
  socketioctl(sockno, FIOASYNC, &i);

  i=IPTOS_LOWDELAY;
  setsockopt(sockno, IPPROTO_IP, IP_TOS, &i, sizeof i);

  dprintf(("debug", "Connecting\n"));
  if (connect(sockno, (struct sockaddr*) sa, sizeof *sa) < 0)
    {
      dprintf(("debug", "Connect error %d\n", errno));
      socketclose(sockno);
      return 0;
    }

  attempts=0;

  dprintf(("debug", "Connect initiated on socket %d\n", sockno));
  return -1;
}

static int probe(void)
{
  struct ntp n;
  size_t len = 0;

  dprintf(("debug", "Sending\n"));
  attempts++;

  if (using_ntp)
      len = ntp_construct_request(&n, sizeof n);

  if (send(sockno, &n, len, 0) < 0)
    {
      dprintf(("debug", "Send error %d\n", errno));
      socketclose(sockno);
      return 0;
    }

 return -1;
}



/* Returns non-zero if read server time */
static int local_settimeofday(void)
{
  uint32_t time;
  int read;
  int expected;
  struct riscos_time ltime;
  struct ntp n;
  int result;
  int64_t offset;

  expected = using_ntp ? sizeof n : 4;

  if ((read = socketread(sockno, using_ntp ? (void *) &n : (void *) &time, expected)) < expected)
  {
    if ((read > 0) || (errno != EWOULDBLOCK))
    {
      dprintf(("debug", "Read error %d\n", errno));
      /* This is a definite failure - it could be an ICMP unreachable message, in which case
       * we may want to switch protocols on the next retransmit.
       */
      if (guess_protocol)
      {
          closeconnect();
          canceltimer();
          if (using_ntp)
          {
              last_protocol = PORT_TIME;
              state = Sleeping;   /* NTP failed - retry with Time */
              machine(Timer);
          }
          else
              machine(Failure);   /* Time failed - give up */
      }
      else
          machine(Failure);					/* Note! */
    }
    else
    {
      dprintf(("debug", "Read still in progress\n"));
    }

    return 0;
  }

  if (using_ntp)
  {
    result = ntp_process_reply(&n, read, &offset);
    /* This'll be close enough for the NVRAM */
    time = (int) ntohl(n.transmit_timestamp.secs);
  }
  else
  {
    struct riscos_time cur = current_time();
    /* Convert time from network in seconds to host in centiseconds */
    time = (int) ntohl(time);
    ltime.cs = time * UINT64_C(100);
    /* Treat times 0x00000000-0x7FFFFFFF as 0x100000000-0x17FFFFFFF */
    if ((time & 0x80000000) == 0) ltime.cs += 0x100000000 * UINT64_C(100);
    offset = (cur.cs - ltime.cs) << 24;
    dprintf(("debug", "Set time!\n"));
    result = -1;
  }

  if (result == -1)
    result = rtcadjust_adjtime(offset, poll_period);

  ltime = current_time();

  if (result == -1)
  {
    synchronised = 1;
    nvram_settime(time);
  }

  closeconnect();

  return result;
}

static unsigned int timer_set;
static unsigned int timer_at;

void change_poll_period(int p)
{
  int time_now;
  _swix(OS_ReadMonotonicTime, _OUT(0), &time_now);
  if (state == Sleeping && p != 0)
  {
      if (time_now - timer_set >= p)
          settimer(1);
      else
          settimer(p - (time_now - timer_set));
  }

  poll_period = p;
}

static void settimer(int duration)
{
  _swix(OS_RemoveTickerEvent, _INR(0,1), module_timerentry, privateword);
  _swix(OS_CallAfter, _INR(0,2),
        duration, module_timerentry, privateword);
  _swix(OS_ReadMonotonicTime, _OUT(0), &timer_set);
  timer_at = timer_set + duration;
}

static void canceltimer(void)
{
  _swix(OS_RemoveTickerEvent, _INR(0,1), module_timerentry, privateword);
  removecallback(Timer, privateword);
}

void setcallback(transition_t reason, void *pw)
{
  callback_reason = reason;
  _swix(OS_AddCallBack, _INR(0,1), module_callentry, pw);
}

void removecallback(transition_t reason, void *pw)
{
  if (callback_reason == Timer)
     _swix(OS_RemoveCallBack, _INR(0,1), module_callentry, pw);
  UNUSED(reason);
}

static void closeconnect(void)
{
  dprintf(("debug", "Closing socket %d\n", sockno));
  socketclose(sockno);
  sockno = -1;			/* So that we don't get any events */
}

void print_status(void)
{
  printf("Current time:    %s\n", riscos_to_text(current_time()));
  printf("Status:          %s\n", STATENAME(state));
  rtcadjust_print_status();
}

void fill_status(nettime_state_t *s)
{
  uint32_t now;

  s->state = NetTime_State_Unknown;

  /* Past */
  if (last_set_succeeded)
  {
    if (last_protocol == PORT_NTP)
      s->state |= NetTime_Past_SyncViaSNTP;
    else
      s->state |= NetTime_Past_SyncViaTime;
  }
  else
  {
    s->state |= NetTime_Past_SyncFailed;
  }

  /* Current */
  switch (state)
  {
    case Dormant:
      s->state |= NetTime_Current_PrerequisitesMissing;
      break;

    case NoLink: case Sleeping:
      s->state |= NetTime_Current_Asleep;
      break;

    case Expecting: case DNSWait:
      s->state |= NetTime_Current_Busy;
      break;
  }

  /* Future */
  if (last_set_succeeded && (state != Dormant))
    s->state |= NetTime_Future_PeriodicSync;
  else
    s->state |= NetTime_Future_Retry;
    
  /* The timer variables are manipulated during callbacks, therefore safe to read here */
  _swix(OS_ReadMonotonicTime, _OUT(0), &now);
  s->timeof_last_action = now - timer_set;
  s->timeof_current_action = 0; /* now - now */
  s->timeof_next_action = timer_at - now;
}
@


4.21
log
@Reverse the sense of the NetTime offset
Rather than requiring a unary minus in rtcadjust, simply work out the offset the other way round (+ve means the RISC OS soft clock is fast compared with real time).

Version 0.41. Tagged as 'NetTime-0_41'
@
text
@d395 1
a395 1
  if (read_os_var("ENV_RESOLVER", inet_resolvers, sizeof(inet_resolvers))>0)
@


4.20
log
@Past state from NetTime_States was always zero.
No longer trampled on by the current state, therefore reports the correct last state when the link is down. Also marks the last set as unsuccessful on every DNS lookup just incase someone kills the resolver too.

Version 0.40. Tagged as 'NetTime-0_40'
@
text
@d550 1
a550 1
    offset = (ltime.cs - cur.cs) << 24;
@


4.19
log
@Remove DST CMOS fiddling code.
Shortly to be handled by TerritoryManager, but the DST fiddling in this module was already broken. Aside from only knowing about Europe and Australia, the Australia rules were wrong too (since they've been changed again).
dhcp.c: use names for timezone CMOS rather than magic numbers.
Rework read_os_var() to remove the 'read length when buff = NULL' which is never used, but also wouldn't have worked because the read length call to OS_ReadVarVal returns an error which is caught by the _swix() hence you always got -1.
Put resolver variable name into a define in the header file.

Version 0.39. Tagged as 'NetTime-0_39'
@
text
@a158 1
        last_set_succeeded = 0;
d180 1
d654 1
a654 1
      s->state = NetTime_Current_PrerequisitesMissing;
d658 1
a658 1
      s->state = NetTime_Current_Asleep;
d662 1
a662 1
      s->state = NetTime_Current_Busy;
@


4.18
log
@Exports added.
SWI numbers and some bit fields for both C and assembler use.

Version 0.38. Tagged as 'NetTime-0_38'
@
text
@a29 1
#include "dst.h"
d395 2
a396 2
  if (read_os_var("Inet$Resolvers", inet_resolvers, sizeof(inet_resolvers)) > 0)
    dprintf(("debug", "Inet$Resolvers: %s\n", inet_resolvers));
d398 1
a398 1
    dprintf(("debug", "Inet$Resolvers not set!\n"));
a499 1
  int dst;
a565 4
  dst = dst_isdst(&ltime);
  if (dst != -1)
      nvram_set_dst(dst);

@


4.17
log
@Add SWI NetTime_States.
Makefile changed to use "CModule" fragment.
Soak up some compiler warnings.
Extralong functions removed.
Use central header files in preference to local defines.
A failure to register resources no longer leaves EventV and WordV claimed.

Version 0.37. Tagged as 'NetTime-0_37'
@
text
@d25 1
d641 1
a641 1
  s->state = state_unknown;
d647 1
a647 1
      s->state |= state_sync_via_sntp;
d649 1
a649 1
      s->state |= state_sync_via_time;
d653 1
a653 1
    s->state |= state_sync_failed;
d660 1
a660 1
      s->state = state_prerequisites_missing;
d664 1
a664 1
      s->state = state_asleep;
d668 1
a668 1
      s->state = state_busy;
d674 1
a674 1
    s->state |= state_periodic_sync;
d676 1
a676 1
    s->state |= state_retry;
@


4.16
log
@* Added support for non-IOMD, HAL-based platforms.
* Improved *NetTime_PollInterval to make sure next poll happens at
  the expected time.
* On module init, no longer sets the time from the NVRAM if the current
  time seems sensible (ie >= 2003ish).
* Sets the time NVRAM on shutdown (was only on packet reception).

Version 0.32. Tagged as 'NetTime-0_32'
@
text
@d15 2
a41 5
static int attempts;
static int using_ntp;
static int guess_protocol;
char env_time_server[MAX_ENV_TIME_SERVER];
struct sockaddr_in sockaddr;
a42 1

d44 1
a46 1

d51 6
a56 1
char *states[] = {"Dormant", "NoLink", "Sleeping", "Expecting", "DNSWait"};
d58 1
a58 1
//#ifdef DEBUGLIB
d62 4
a65 3
char *transitions[] = {"NoTrans", "Init", "Die", "PostInit", "Response", "Failure", "Timer", "LinkUp", "LinkDown", "RegistryChanged", "DoDNS"};

//#endif
d67 1
a70 4
#define TRANSNAME(i) ((((i) < 0) || ((i) > sizeof(transitions)/sizeof(char *))) ? \
			"Invalid transition" : transitions[i])


d159 1
d236 2
a237 1
        if (local_settimeofday())
d576 2
a577 2
unsigned int timer_set;
unsigned int timer_at;
d581 1
a581 1
  int time_now, d;
a602 1

d609 12
d635 48
@


4.15
log
@  Fixed to build with the latest cc (5.54) compiler.
Detail:
  This version now builds with cc-5_45. Note: it has not been verified as
  actually functioning correctly.
Admin:
  Tested in DSL Baseline build.

Version 0.31. Tagged as 'NetTime-0_31'
@
text
@d575 1
d580 9
a588 6
  int time_to;
  _swix(OS_ReadMonotonicTime, _OUT(0), &time_to);
  time_to = timer_at - time_to;

  if (state == Sleeping && p < time_to && p != 0)
      settimer(p);
d598 2
a599 2
  _swix(OS_ReadMonotonicTime, _OUT(0), &timer_at);
  timer_at += duration;
@


4.14
log
@  * Fixed all of the !Mk... files.
  * Now builds with the latest TCPIPLibs.
Detail:
  * All of the !Mk... files are required to pass TARGET into the makefile.
  * The new TCPIPLibs use the standard types.h from RISC_OSLib if it is
    available. This defines u_int32 types using int rather than long, which
    TCPIPLibs uses. Thus, NetTime needed a little tweaking to adjust for
    this change.
Admin:
  Builds.
  Requires TCPIPLibs-5_42 or later.

Version 0.30. Tagged as 'NetTime-0_30'
@
text
@d57 1
a57 1
#ifdef DEBUGLIB
d63 1
a63 1
#endif
d493 1
a493 1
  u_int32_t time;
d547 1
a547 1
    mul64(time, 100, (u_int64_t *) &ltime);
d549 2
a550 5
    if ((time & 0x80000000) == 0) ltime.h += 100;
    offset.low = ltime.l - cur.l;
    offset.high = (u_int32_t) ltime.h - cur.h - (ltime.l < cur.l);
    offset.high = (offset.high << 24) | (offset.low >> 8);
    offset.low <<= 24;
@


4.13
log
@  Bug fix for time server off smartcard
Detail:
  Protocol auto determination when using a time server specified off
   a smart card was only being done if the time server on the
   smart card was a packed IP address.  If the time server was a
   string, auto determination wasn't being done.  Behaviour changed
   so that auto determination will be done for any smart card format.

Admin:
  Tested on Customer F5 softload.
  Fixes Pace 1618


Version 0.24. Tagged as 'NetTime-0_24'
@
text
@d493 2
a494 1
  int time, read;
d547 1
a547 1
    mul64(time, 100, (u_int32_t *) &ltime);
@


4.12
log
@A couple of warnings removed.
Now uses "low delay" type of service for outgoing datagrams.

Version 0.23. Tagged as 'NetTime-0_23'
@
text
@d376 3
d384 1
a384 2
          using_ntp = 1;
          guess_protocol = 1;
@


4.11
log
@Precision of internal arithmetic and clock reading improved. Now possible
to maintain time to within a couple of milliseconds (given frequent enough
polling).

Version 0.22. Tagged as 'NetTime-0_22'
@
text
@d19 2
a20 1
#pragma -d0		/* Suppress winges about K&R-style declarations */
a21 1
#pragma -d1
d448 3
d548 1
a548 1
    offset.high = ltime.h - cur.h - (ltime.l < cur.l);
@


4.10
log
@Can now change the poll interval via a *Command.
If the time server came from NetTime$Server or NCMA, both NTP and Time/UDP
will be tried.
Maximum adjustment rate limited to +/-1%, rather than 10%.

Version 0.21. Tagged as 'NetTime-0_21'
@
text
@d494 1
a528 1
  closeconnect();
d532 1
a532 1
    result = ntp_process_reply(&n, read, &ltime);
d538 1
d544 4
d553 3
a555 1
    result = rtcadjust_settime(&ltime, poll_period);
d567 2
d612 1
a612 1
  printf("Current time:    %s\n", riscos_to_text(current_time(), 0));
@


4.9
log
@  Added support for NTP, gradual time adjustment, configurable DST,
  and DHCP timezone.

Detail:
  If Inet$NTPServer is set, NetTime will use NTP (unicast SNTP, as per RFC2030).
  Otherwise it will use the UDP time protocol (it used to use TCP).

  NetTime will use the RTCAdjust algorithms to adjust the centisecond clock
  rate by +/-10% to get in step with the time server. By polling every 30
  minutes on a LAN, time will not deviate by more than 0.1 seconds once
  synchronised. It interoperates with RTCAdjust and the hardware RTC to ensure
  correct operation on a machine with RTC.

  NetTime has returned to polling every 30 minutes. This may defeat PPP
  timeouts - a suggested fix is to change PPP to only have TCP traffic keep the
  link up, or to have a separate user inactivity timeout (like Lazarus).

  The system variable NetTime$DST controls DST behaviour. Set to "European"
  (the default) to use European rules. Set it to something like
  "03-May-2000.01:00:00; 14-Sep-2000.01:00:00" to specify this year's start
  and end dates (in UTC). Set to "No" to make it leave DST alone.

  If a DHCP reply arrives while NetTime is loaded, it will check for the time
  offset option - if present, the timezone will be configured.

  New command *NetTime_Status gives information about the clock adjustments.

  NetTime attempts to start operation immediately on a non-dialup machine -
  removes the need for a *NetTime_Kick after softloading. *NetTime_Kick will
  still be required after, say, setting Inet$NTPServer manually.

Admin:
  Tested on desktop systems and STBs. NTP operation on an NC will require a
  way of finding out an NTP server - possibly redefining TIME_SERVER smartcard
  tag to be NTP? Anycast operation may also be worth adding.

Version 0.20. Tagged as 'NetTime-0_20'
@
text
@d31 2
d42 1
d47 4
d192 2
d239 7
a245 6
#ifndef NO_PERIODICAL_TIME_CHECKS
          state = Sleeping;
          settimer(LONG_TIMER);
#else
          state = Dormant;
#endif
d250 1
d254 1
d262 1
d342 1
a345 1
    using_ntp = 0;
d351 2
d361 2
d379 1
a379 1
          if (ipaddress == 0) return 0;
d381 2
d435 4
d440 1
a440 1
  sa->sin_port = ntohs(using_ntp ? 123 : 37);
d502 18
a519 1
      machine(Failure);					/* Note! */
d548 1
a548 5
#ifdef NO_PERIODICAL_TIME_CHECKS
    result = rtcadjust_settime(&ltime, 0);
#else
    result = rtcadjust_settime(&ltime, LONG_TIMER);
#endif
d563 13
d579 1
d582 2
@


4.8
log
@ 	NetTime now looks at the Inet$TimeServer system variable before
looking at the NetTime$Server variable or the smartcard.
 	This fixes a bug where the server was not getting set if there was
not a time server on the smartcard (or it was present but was not a valid
DNS) as the Inet$TimeServer was not being looked at.

Detail:
 	When attempting to locate a server to gain the time from, it now does
it on the following order:
 	* Checks the Inet$TimeServer system variable first;
 	* If not present, checks the NetTime$Server system variable;
 	* If not present, finally attmepts to get the server off the
smartcard.

Admin:
 	Tested as a softload on an ethernet Customer M box.

Version 0.16. Tagged as 'NetTime-0_16'
@
text
@d27 4
a30 1
#include "edst.h"
d32 1
d38 2
d42 1
d48 2
a53 1
char *states[] = {"Dormant", "NoLink", "Sleeping", "Expecting", "DNSWait"};
d56 2
a63 1
#endif
d75 1
d77 1
a92 1
  static state_t state = Dormant;
d109 2
a110 1
        case PostInit:
d113 2
a122 1
      case Init:
d184 2
a185 1
            if (tryconnect(&sockaddr))
d187 1
d189 1
d197 1
d229 2
a230 1
#ifdef PERIODICAL_TIME_CHECKS
d240 1
d245 11
d257 2
d264 2
d323 1
a323 1
  /* Attempt to read from the Inet$TimeServer system variable */
d325 1
a325 1
  if(read_os_var(ENV_TIME_SERVER2, env_time_server, MAX_ENV_TIME_SERVER)>0)
d328 1
d332 4
a335 3
    /* Attempt to read from the NetTime$Server system variable */
    dprintf(("debug", "checking environment variable %s\n", ENV_TIME_SERVER));
    if(read_os_var(ENV_TIME_SERVER, env_time_server, MAX_ENV_TIME_SERVER)>0)
d341 7
a347 5
      /* Ask the Registry who we should contact */
      dprintf(("debug", "Requesting the time server from Managed Access\n"));
      if (_swix(NCAccessManager_Enquiry, _INR(0,2)|_OUT(0),
                NCRegistry_TimeServerTag, env_time_server, MAX_ENV_TIME_SERVER,
                &i))
d349 9
a357 3
        dprintf(("debug", "NCAccessManager bailed! r0=%x\n", i));
        return -1;
      }
d359 9
a367 8
      if(i == 4) { /* packed IP address */
        ipaddress = *(int *)env_time_server;
        dprintf(("debug", "NCAccessManager says timeserver IP address is %08x\n", ipaddress));
        if (ipaddress == 0) return 0;
        sockaddr->sin_addr.s_addr = ipaddress; /* address already in network order */
        return 0; /* complete */
      } else {
        dprintf(("debug", "NCAccessManager says timeserver host is %s\n", env_time_server));
a399 1
  struct servent *service;
a415 6
  if ((service=getservbyname("time", "tcp")) == NULL)
  {
    dprintf(("debug", "Can't find service time/tcp\n"));
    return 0;
  }

d417 1
a417 1
  sa->sin_port = service->s_port;
d420 1
a420 1
  sockno = socket(AF_INET, SOCK_STREAM, 0);
d426 1
a426 2
  if ((connect(sockno, (struct sockaddr*) sa, sizeof *sa) < 0) &&
      (errno != EINPROGRESS) && (errno != EWOULDBLOCK))
d433 2
d439 22
d466 5
a470 1
  char ltime[8];
d472 3
a474 1
  if ((read = socketread(sockno, (char *) &time, 4)) < 4)
d476 1
a476 1
    if ((read > 0) || ((errno != EINPROGRESS) && (errno != EWOULDBLOCK)))
d478 1
a478 1
      dprintf(("debug", "Connect error %d\n", errno));
d490 6
a495 12
  /* Convert time from network in seconds to host in centiseconds */
  time = (int) ntohl(time);
  nvram_settime(time);
  mul64(time, 100, (int*) ltime);

  /* Set time */
  _swix(Territory_SetTime, _IN(0), &ltime);
  dprintf(("debug", "Set time!\n"));

#ifdef EUROPEAN_DST_BODGE
  if (edst_isdst(ltime))
      nvram_set_dst(1);
d497 15
a511 1
      nvram_set_dst(0);
d514 11
a524 1
  return -1;
d538 1
d547 7
@


4.7
log
@Prevented from doing half-hour time changes, unless PERIODICAL_TIME_CHECKS
is defined. If you must keep adjusting the time, it would be a good idea
to make sure it changes gradually, like RTCAdjust does it. These checks were
preventing PPP from timing out.

Version 0.14. Tagged as 'NetTime-0_14'
@
text
@d259 4
a262 2
 *   The hostname is read from the system variable "NetTime$Server"
 *   if set, or the smart card tag "TIME_PRIMARY" otherwise.
a288 1
  dprintf(("debug", "checking environment variable %s\n", ENV_TIME_SERVER));
d290 4
a293 1
  if(read_os_var(ENV_TIME_SERVER, env_time_server, MAX_ENV_TIME_SERVER)>0) { /* we have a configured time server */
d295 11
a305 2
  } else {

d307 1
d325 1
@


4.6
log
@Automatically switch into and out of Daylight Savings for Europe in
1998-2001, if EUROPEAN_DST_BODGE is defined.

Version 0.11. Tagged as 'NetTime-0_11'
@
text
@d53 1
a53 1
			
d85 1
a85 1
    
d88 1
a88 1
    dprintf(("debug", "State %d (%s), transition %d (%s)\n", 
d93 1
a93 1
    
d109 1
a109 1
        
d179 1
a179 1
            
d186 1
a186 1
      
d206 1
a206 1
          
d213 1
d216 3
d238 1
a238 1
      
d240 1
a240 1
    
d243 1
a243 1
        
d266 1
a266 1
 *                 polled on a timer until it returns 0 or another 
d276 1
a276 1
  
d319 1
a319 1
  
d322 1
a322 1
   */  
d331 2
a332 2
  
  return status;  
d353 1
a353 1
  
d397 1
a397 1
      dprintf(("debug", "Conect error %d\n", errno));
@


4.5
log
@Make DNS lookup non-blocking:
  New state (DNSWait) and internal transition (DoDNS) added.
  Machine now support internal transitions, and DoDNS is injected by
  transitions that previously called tryconnect() to start lookup.
  State DNSWait polls resolver every second while it returns EINPROGRESS.
  Resolver interface (dns.c) taken from Acorn FTP fetcher.

Version 0.09. Tagged as 'NetTime-0_09'
@
text
@d27 1
d413 7
@


4.4
log
@Convert to using DebugLib for debug output.

Version 0.07. Tagged as 'NetTime-0_07'
@
text
@d26 1
d34 1
d36 18
d58 2
a59 1
static int tryconnect(void);
d73 1
d82 7
d90 4
a93 6
  dprintf(("debug", "State:%d, transition %d\n", state, transition));

  switch(state)
  {
  case Dormant:
    switch(transition)
d95 20
a114 4
    case PostInit:
      if (isdialup())
        state = NoLink;
      return;
d116 2
a117 5
    case LinkUp:
    case RegistryChanged:
      if (tryconnect())
        state = Expecting;
      else
d119 12
a130 2
        settimer(SHORT_TIMER);
        state = Sleeping;
d132 1
a132 1
      return;
d134 9
a142 6
    case Init:
    case Die:
    case LinkDown:
      return;
    }
    break;
d144 14
a157 7
  case NoLink:
    switch(transition)
    {
    case LinkUp:
      if (tryconnect())
        state = Expecting;
      else
d159 44
a202 2
        settimer(SHORT_TIMER);
        state = Sleeping;
d204 12
a215 11
      return;

    case LinkDown:
    case RegistryChanged:
      return;

    case Die:
      state = Dormant;
      return;
    };
    break;
d217 2
a218 9
  case Sleeping:
    switch(transition)
    {
    case Timer:
    case LinkUp:
    case RegistryChanged:
      if (tryconnect())
        state = Expecting;
      else
d220 1
a220 1
      return;
d222 4
a225 11
    case LinkDown:
      canceltimer();
      state = NoLink;
      return;

    case Die:
      canceltimer();
      state = Dormant;
      return;
    };
    break;
d227 4
a230 8
  case Expecting:
    switch(transition)
    {
    case Response:
      if (local_settimeofday())
      {
        state = Sleeping;
        settimer(LONG_TIMER);
d232 8
a239 1
      return;
d241 1
a241 19
    case Failure:
      closeconnect();
      settimer(SHORT_TIMER);
      return;

    case LinkDown:
      closeconnect();
      state = NoLink;
      return;

    case Die:
      closeconnect();
      state = Dormant;
      return;
    };
    break;
  }
  dprintf(("debug", "Bogus state/transition combo: state=%d, transition=%d\n",
          state, transition));
d252 15
a266 3

/* Returns non-0 if connect successfully initiated */
static int tryconnect(void)
d270 2
a271 7
  struct sockaddr_in sa;
  struct servent *service;
  unsigned long host_ip;
  struct hostent *hp;

  dprintf(("debug", "trying to connect\n"));

d280 1
a280 1
    return 0;
d294 1
a294 1
        return 0;
d299 1
a299 1
        dprintf(("debug", "NCAccessManager says timeserver is %08x\n", ipaddress));
d301 4
a304 2
        sa.sin_addr.s_addr = ipaddress; /* address already in network order */
        goto skip_addr_decode;
d308 21
a329 10
    if((hp = gethostbyname(env_time_server)) != NULL) { /* it's an IP name */
      dprintf(("debug", "got natural IP name \"%s\"\n", env_time_server));
      memcpy((char *)&sa.sin_addr, hp->h_addr, hp->h_length);
    } else if((host_ip = inet_addr(env_time_server)) != INADDR_NONE) { /* must be a dot quad then */
          dprintf(("debug", "got dot-quad IP name \"%s\"\n", env_time_server));
          memcpy((char *)&sa.sin_addr, &host_ip, sizeof(unsigned long));
    } else {
        dprintf(("debug", "dammit, couldn't figure out time server address\n"));
        return 0;
    }
d331 19
a349 1
    skip_addr_decode:
d351 1
a351 1
  dprintf(("debug", "Using time server 0x%x\n", (int)sa.sin_addr.s_addr));
d359 2
a360 2
  sa.sin_family = AF_INET;
  sa.sin_port = service->s_port;
d369 1
a369 1
  if ((connect(sockno, (struct sockaddr*) &sa, sizeof sa) < 0) &&
@


4.3
log
@Code clean-up.

Version 0.05. Tagged as 'NetTime-0_05'
@
text
@d61 1
a61 1
  DEBUGFN(printf("State:%d, transition %d\n", state, transition));
d166 1
a166 1
  DEBUGFN(printf("Bogus state/transition combo: state=%d, transition=%d\n",
d189 1
a189 1
  DEBUGFN(printf("trying to connect\n"));
d198 1
a198 1
    DEBUGFN(printf("Dialler bailed! r0=%x\n", dialler_status));
d201 1
a201 1
  DEBUGFN(printf("checking environment variable %s\n", ENV_TIME_SERVER));
d204 1
a204 1
    DEBUGFN(printf("read environment variable: %s\n", env_time_server));
d212 1
a212 1
        DEBUGFN(printf("NCAccessManager bailed! r0=%x\n", i));
d218 1
a218 1
        DEBUGFN(printf("NCAccessManager says timeserver is %08x\n", ipaddress));
d227 1
a227 1
      DEBUGFN(printf("got natural IP name \"%s\"\n", env_time_server));
d230 1
a230 1
          DEBUGFN(printf("got dot-quad IP name \"%s\"\n", env_time_server));
d233 1
a233 1
        DEBUGFN(printf("dammit, couldn't figure out time server address\n"));
d239 1
a239 1
  DEBUGFN(printf("Using time server 0x%x\n", (int)sa.sin_addr.s_addr));
d243 1
a243 1
    DEBUGFN(printf("Can't find service time/tcp\n"));
d256 1
a256 1
  DEBUGFN(printf("Connecting\n"));
d260 1
a260 1
      DEBUGFN(printf("Connect error %d\n", errno));
d265 1
a265 1
  DEBUGFN(printf("Connect initiated on socket %d\n", sockno));
d280 1
a280 1
      DEBUGFN(printf("Conect error %d\n", errno));
a282 1
#ifdef DEBUG
d284 3
a286 2
      printf("Read still in progress\n");
#endif
d299 1
a299 1
  DEBUGFN(printf("Set time!\n"));
d320 1
a320 1
  DEBUGFN(printf("Closing socket %d\n", sockno));
@


4.2
log
@Moved module to trunk and srccommitted. No code changes other
than removing some warnings.

Version 0.04. Tagged as 'NetTime-0_04'
@
text
@d25 1
d208 1
a208 1
      if (_swix(NCAccessManager_Enquiry, _IN(0)|_IN(1)|_IN(2)|_OUT(0),
d307 1
a307 1
  _swix(OS_CallAfter, _IN(0)|_IN(1)|_IN(2),
d314 1
a314 1
  _swix(OS_RemoveTickerEvent, _IN(0)|_IN(1), module_timerentry, privateword);
@


4.1
log
@Initial revision
@
text
@d15 2
a16 2
#include "socklib/socklib.h"
#include "inetlib/inetlib.h"
d24 2
d31 1
d39 1
a39 1
static int settimeofday(void);
d59 1
a59 1
  
d61 1
a61 1
  
d71 1
a71 1
      
d85 1
d89 1
a89 1
    
d105 2
a106 2
      return;      
    
d109 1
a109 1
      return;      
d111 2
a112 2
    break;      
    
d120 1
a120 1
        state = Expecting;   
d129 1
a129 1
      
d136 1
a136 1
    
d141 1
a141 1
      if (settimeofday())
d163 1
a163 1
    break;  
d185 3
a187 1
  
d200 1
d202 20
a221 7
  /* Ask the Registry who we should contact */
  if (_swix(NCRegistry_Enquiry, _IN(0)|_IN(1)|_IN(2)|_OUT(0),
            NCRegistry_TimeServerTag, &ipaddress, sizeof(ipaddress),
            &i) || (i != sizeof(ipaddress)))
  {
    DEBUGFN(printf("NCRegistry bailed! r0=%x\n", i));
    return 0;
d223 16
a238 3
  DEBUGFN(printf("NCRegistry says timeserver is %08x\n", ipaddress));
  if (ipaddress == 0)
    return 0;
d245 1
a245 1
  
a247 1
  sa.sin_addr.s_addr = ipaddress;	/* Address already in network order */
d270 1
a270 1
static int settimeofday(void)
d293 1
d299 1
a299 1
  
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Fixed to work with new TCPIP libs
@
text
@d15 2
a16 2
#include "socklib.h"
#include "inetlib.h"
d36 1
a36 1
static int local_settimeofday(void);
d137 1
a137 1
      if (local_settimeofday())
d238 1
a238 1
static int local_settimeofday(void)
@


4.1.7.3
log
@Altered NetTime to use NCAccessManager and NCBootblock instead of NCRegistry
@
text
@d196 1
a196 1
  if (_swix(NCAccessManager_Enquiry, _IN(0)|_IN(1)|_IN(2)|_OUT(0),
d200 1
a200 1
    DEBUGFN(printf("NCAccessManager bailed! r0=%x\n", i));
d203 1
a203 1
  DEBUGFN(printf("NCAccessManager says timeserver is %08x\n", ipaddress));
@


4.1.7.4
log
@Added support for the "SystemTime" NVRAM tag.
@
text
@a23 1
#include "nt_nvram.h"
d56 1
a56 1

d58 1
a58 1

d68 1
a68 1

d85 1
a85 1

d101 2
a102 2
      return;

d105 1
a105 1
      return;
d107 2
a108 2
    break;

d116 1
a116 1
        state = Expecting;
d125 1
a125 1

d132 1
a132 1

d159 1
a159 1
    break;
d181 1
a181 1

d212 1
a212 1

a260 1
  nvram_settime(time);
d266 1
a266 1

@


4.1.7.5
log
@Fixed some stuff. Added some stuff. Moved some other stuff about a bit.
But I didn't remove any stuff.
@
text
@a24 1
#include <string.h>
a29 1
char env_time_server[MAX_ENV_TIME_SERVER];
a82 1
    case LinkDown:
a181 2
  unsigned long host_ip;
  struct hostent *hp;
a194 1
  DEBUGFN(printf("checking environment variable %s\n", ENV_TIME_SERVER));
d196 7
a202 20
  if(read_os_var(ENV_TIME_SERVER, env_time_server, MAX_ENV_TIME_SERVER)>0) { /* we have a configured time server */
    DEBUGFN(printf("read environment variable: %s\n", env_time_server));
  } else {

      /* Ask the Registry who we should contact */
      if (_swix(NCAccessManager_Enquiry, _IN(0)|_IN(1)|_IN(2)|_OUT(0),
                NCRegistry_TimeServerTag, env_time_server, MAX_ENV_TIME_SERVER,
                &i))
      {
        DEBUGFN(printf("NCAccessManager bailed! r0=%x\n", i));
        return 0;
      }

      if(i == 4) { /* packed IP address */
        ipaddress = *(int *)env_time_server;
        DEBUGFN(printf("NCAccessManager says timeserver is %08x\n", ipaddress));
        if (ipaddress == 0) return 0;
        sa.sin_addr.s_addr = ipaddress; /* address already in network order */
        goto skip_addr_decode;
      }
d204 3
a206 16


    if((hp = gethostbyname(env_time_server)) != NULL) { /* it's an IP name */
      DEBUGFN(printf("got natural IP name \"%s\"\n", env_time_server));
      memcpy((char *)&sa.sin_addr, hp->h_addr, hp->h_length);
    } else if((host_ip = inet_addr(env_time_server)) != INADDR_NONE) { /* must be a dot quad then */
          DEBUGFN(printf("got dot-quad IP name \"%s\"\n", env_time_server));
          memcpy((char *)&sa.sin_addr, &host_ip, sizeof(unsigned long));
    } else {
        DEBUGFN(printf("dammit, couldn't figure out time server address\n"));
        return 0;
    }

    skip_addr_decode:

  DEBUGFN(printf("Using time server 0x%x\n", (int)sa.sin_addr.s_addr));
d216 1
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@

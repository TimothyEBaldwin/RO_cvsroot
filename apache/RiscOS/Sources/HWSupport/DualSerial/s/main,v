head	4.9;
access;
symbols
	DualSerial-0_25-4_8_2_16-1:4.7.2.10
	DualSerial-0_25-4_8_2_16:4.7.2.10
	DualSerial-0_25-4_8_2_15:4.7.2.10
	DualSerial-0_25-4_8_2_14:4.7.2.9
	DualSerial-0_25-4_8_2_13:4.7.2.8
	DualSerial-0_25-4_8_2_12:4.7.2.7
	DualSerial-0_25-4_8_2_11:4.7.2.6
	DualSerial-0_29:4.9
	DualSerial-0_25-4_8_2_10:4.7.2.5
	RO_5_07:4.7.2.5
	DualSerial-0_28:4.9
	DualSerial-0_25-4_8_2_9:4.7.2.5
	DualSerial-0_25-4_8_2_8:4.7.2.5
	DualSerial-0_25-4_8_2_7:4.7.2.4
	DualSerial-0_25-4_8_2_6:4.7.2.3
	DualSerial-0_27:4.9
	DualSerial-0_25-4_8_2_5:4.7.2.2
	DualSerial-0_25-4_8_2_4:4.7.2.1
	DualSerial-0_25-4_8_2_3:4.7.2.1
	DualSerial-0_25-4_8_2_2:4.7.2.1
	DualSerial-0_25-4_8_2_1:4.7
	HAL:4.7.0.2
	DualSerial-0_26:4.8
	DualSerial-0_25:4.7
	kbracey_32bit_merge:4.6.2.1
	DualSerial-0_24-4_7_2_4:4.6.2.1
	DualSerial-0_24-4_7_2_3:4.6.2.1
	DualSerial-0_24-4_7_2_2:4.6.2.1
	dellis_autobuild_BaseSW:4.6
	DualSerial-0_24-4_7_2_1:4.6.2.1
	kbracey_32bit:4.6.0.2
	DualSerial-0_24:4.6
	sbrodie_sedwards_16Mar2000:4.6
	DualSerial-0_23:4.6
	dcotton_autobuild_BaseSW:4.8
	DualSerial-0_22:4.5
	DualSerial-0_21:4.4
	DualSerial-0_18:4.4
	Daytona_merge:4.2.6.2
	DualSerial-0_17:4.3
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spinner_B10:4.1.7.2
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.2
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	ARTtmp:4.1.7.2.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.2
	MergeFiles:4.1.7.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1;
locks; strict;
comment	@# @;


4.9
date	2001.10.23.12.42.51;	author dellis;	state Exp;
branches;
next	4.8;

4.8
date	2001.03.16.15.55.53;	author sbrodie;	state Exp;
branches;
next	4.7;

4.7
date	2001.01.09.14.05.12;	author sbrodie;	state Exp;
branches
	4.7.2.1;
next	4.6;

4.6
date	99.10.26.09.22.16;	author kbracey;	state Exp;
branches
	4.6.2.1;
next	4.5;

4.5
date	99.08.16.17.04.23;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	98.09.29.13.30.06;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.09.21.14.21.58;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.22.13.38.44;	author nturton;	state Exp;
branches
	4.2.2.1
	4.2.6.1;
next	4.1;

4.1
date	96.11.21.12.06.26;	author nturton;	state Exp;
branches
	4.1.5.1
	4.1.7.1;
next	;

4.7.2.1
date	2001.03.20.13.13.47;	author kbracey;	state Exp;
branches;
next	4.7.2.2;

4.7.2.2
date	2001.05.22.10.02.52;	author kbracey;	state Exp;
branches;
next	4.7.2.3;

4.7.2.3
date	2003.03.29.18.20.24;	author kbracey;	state Exp;
branches;
next	4.7.2.4;

4.7.2.4
date	2003.03.31.09.28.07;	author rsprowson;	state Exp;
branches;
next	4.7.2.5;

4.7.2.5
date	2004.07.02.12.44.28;	author bavison;	state Exp;
branches;
next	4.7.2.6;

4.7.2.6
date	2012.06.04.23.36.14;	author jlee;	state Exp;
branches;
next	4.7.2.7;
commitid	lqDFJl0aX8rOLr7w;

4.7.2.7
date	2012.06.11.22.34.14;	author jlee;	state Exp;
branches;
next	4.7.2.8;
commitid	ZeM9napmUb1Dcl8w;

4.7.2.8
date	2015.06.21.22.14.01;	author jballance;	state Exp;
branches;
next	4.7.2.9;
commitid	3p3436K4qAWwzlqy;

4.7.2.9
date	2016.10.09.12.15.38;	author jlee;	state Exp;
branches;
next	4.7.2.10;
commitid	eD4vGhfsX2ODXspz;

4.7.2.10
date	2016.10.25.19.51.42;	author jlee;	state Exp;
branches;
next	;
commitid	jdTxMDLlSBodYyrz;

4.6.2.1
date	2000.07.13.15.23.19;	author sbrodie;	state Exp;
branches;
next	;

4.2.2.1
date	98.07.21.13.36.47;	author wturner;	state dead;
branches;
next	;

4.2.6.1
date	97.07.07.13.27.31;	author blaughto;	state Exp;
branches;
next	4.2.6.2;

4.2.6.2
date	97.07.11.07.12.18;	author blaughto;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.06.26;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.45.43;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.01.29.15.06.05;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.9
log
@  Fixed reregistration with DeviceFS

Detail:
  Service_DeviceFSDying wasn't being handled correctly.

Admin:
  Tested on STB


Version 0.27. Tagged as 'DualSerial-0_27'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;
; 		Copyright 1996 Acorn Network Computing
;
;  This material is the confidential trade secret and proprietary
;  information of Acorn Network Computing. It may not be reproduced,
;  used, sold, or transferred to any third party without the prior
;  written consent of Acorn Network Computing. All rights reserved.
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Description of the structure of the two port implemementation.
;
;   The device probe routine is called with a possible base address given in
;   r10. If present, a port specific workspace area is claimed and the this base
;   address stored there. The pointer to this workspace is stored either of two
;   words in main module workspace and usually referenced as r11. r11 is used
;   during devicefs registration so that it is passed into the devicefs handler
;   each time it is called, automatically establishing that port session
;   depending on which devicefs object was referenced.
;

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; module workspace
                        ^ 0, wp
Flags			# 4
BuffManWkSpace          # 4	; buffer manager workspace
BuffManService          # 4     ; address of buffer manager routine
Port1			# 4	; address of port 1 workspace
Port2			# 4	; address of port 2 workspace
MessagesWorkspace       # 16    ; needed for messages routines
workspace               * :INDEX: @@

;
; bit definitions for Flags
;
flag_Port1Present	* 1:SHL:0  ; set => hardware detected for port1
flag_Port2Present	* 1:SHL:1  ; set => hardware detected for port2
flag_OwnIRQ             * 1:SHL:2  ; set => IRQ owned for device
flag_HaveMessages	* 1:SHL:3  ; set => opened messages file
flag_SerialType2        * 1:SHL:4  ; set => serial type 2 (ie different IRQ line)

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; port specific workspace

                        ^ 0, r11
DeviceFSBlock		# 4	; address of devicefs registration block
DeviceHandle		# 4	; handle returned from DeviceFS_Register
InputStream		# 4	; devicefs stream handle
OutputStream		# 4	; devicefs stream handle
InputFSHandle		# 4     ; file switch handle of input stream
OutputFSHandle		# 4     ; file switch handle of output stream
InputBuffer		# 4	; buffer manager handle
OutputBuffer		# 4	; buffer manager handle
InputBufferPrivId      	# 4	; buffer managers private buffer id
OutputBufferPrivId	# 4	; buffer managers private buffer id
InputBufferSize		# 4	; buffer size in bytes
OutputBufferSize	# 4	;
InputBufferThreshold	# 4	; buffer threshold point in bytes
OutputBufferThreshold	# 4	;
BaseAddress		# 4	; base address of register set
BaudRate		# 4	; ports programmed baud rate
DataFormat		# 4	; ports programmed data format
PortFlags		# 4	; port specific flags
ControlLines		# 1
TxByteCount		# 1
FIFOTrigger		# 1
Dummy1			# 1
 [ counting
ByteCount		# 4
ErrorCount		# 4
OverrunCount		# 4
ParityCount		# 4
FramingCount		# 4
InterruptCount		# 4
BufferOverrun		# 4
 ]
port_workspace		* :INDEX: @@

;
; bit definitions for PortFlags
;
flag_FIFOsPresent	* 1:SHL:0	; we have FIFOs
flag_UseRTS		* 1:SHL:1	; rts/cts handshaking
flag_UseXon		* 1:SHL:2	; xon/off handshaking
flag_UseDTR		* 1:SHL:3	; dtr/dsr handshaking
flag_TxDormant		* 1:SHL:4	; no more characters tx
flag_RxThresholded	* 1:SHL:5	; rx buffer thresholded
flag_TxXon		* 1:SHL:6	; need to send xon char
flag_TxXoff		* 1:SHL:7	; need to send xoff char
flag_TxXoffed		* 1:SHL:8	; we have been xoffed
flag_Registered		* 1:SHL:9	; registered with devicefs

;
; bit definitions for ControlLines
;
ctrl_line_dtr			* 1:SHL:0
ctrl_line_rts			* 1:SHL:1
ctrl_line_cts			* 1:SHL:2
ctrl_line_dsr			* 1:SHL:3
ctrl_line_ri			* 1:SHL:4
ctrl_line_dcd			* 1:SHL:5

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; standard module declarations
                AREA  |DualSerial$$Code|, CODE, READONLY, PIC

module          & 0
                & init    -module               ; => initalise routine
                & final   -module               ; => finalise routine
                & service -module               ; => service trap

                & title -module                 ; => title string
                & help  -module                 ; => help string
                & command_table-module		; => command table

 [ :LNOT: No32bitCode
                & 0
                & 0
                & 0
                & 0
                & 0
                & moduleflags - module          ; => module flags
 ]

title           = "Serial", 0

help            = "Serial", 9, 9, "$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
                = " $Module_MinorVersion"
 ]
 [ debug
                = " (Debug on)", 0
 ]
                = 0

command_table   = "SerialInfo", 0
		ALIGN
		DCD	serial_command -module
		DCD	0
		DCD	serial_syntax -module
		DCD	serial_help   -module

		= "SerialTest", 0
		ALIGN
		DCD	serial_test_command -module
		DCD	0
		DCD	serial_test_syntax -module
		DCD	serial_test_help -module
		&	0

serial_help    = "*SerialInfo displays internal statistics on each available serial port", 13
serial_syntax  = "Syntax: *SerialInfo", 0

serial_test_help   = "*SerialTest tests each serial port using loopback", 13
serial_test_syntax = "Syntax: *SerialTest", 0


		ALIGN

 [ :LNOT: No32bitCode
moduleflags     DCD ModuleFlag_32bit
 ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; debug options
 [ debug
Host_Debug  	SETL 	False
HostDebugViaTML	SETL 	False
Debug_Module	SETL	False
;Debug_File      SETS	"$.Debug"
 ]
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; DeviceFS declarations
device_name1    = "Serial1", 0
                ALIGN
device_name2	= "Serial2", 0
		ALIGN

device_block1   & device_name1 - device_block1
                & DeviceFlag_BufferedDevice + DeviceFlag_DefinePathVariable
                & 8                             ; default RX buffer flags
                & 1024                          ; default RX buffer size
                & 8                             ; default TX buffer flags
                & 512                           ; default TX buffer size
                & 0                             ; reserved field (must be zero)

                & 0                             ; end of table

                ALIGN

device_block2   & device_name2 - device_block2
                & DeviceFlag_BufferedDevice + DeviceFlag_DefinePathVariable
                & 8                             ; default RX buffer flags
                & 1024                          ; default RX buffer size
                & 8                             ; default TX buffer flags
                & 512                           ; default TX buffer size
                & 0                             ; reserved field (must be zero)

                & 0                             ; end of table

                ALIGN

device_validation = "baud/ndata/nstop/nnoparity,even,odd/snohandshake,rts,xon,dtr/ssize/nthres/n",0
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Globals
serial_baud_rate	= "  Baud (bps)  : ",0
serial_data_format	= "  Data format : ",0
serial_handshake	= "  Handshake   : ",0
serial_handshake_rts	= "rts/cts",0
serial_handshake_dtr    = "dtr/dsr",0
serial_handshake_xon    = "xon/xoff",0
serial_handshake_none   = "none",0
 [ debug
serial_flags		= "  Port flags      : 0x",0
serial_control_line	= "  Control lines   : 0x",0
serial_base_address	= "  Base address    : 0x",0
serial_workspace	= "  Workspace       : 0x",0
serial_input_buffer	= "  IP buffer       : ",0
serial_ip_buffer_size   = "  IP buffer size  : ",0
serial_ip_buffer_thres  = "  IP buffer thres : ",0
serial_output_buffer	= "  OP buffer       : ",0
serial_op_buffer_size   = "  OP buffer size  : ",0
serial_op_buffer_thres  = "  OP buffer thres : ",0
serial_fifo_present     = "  Fifos present",0
serial_fifo_not_present = "  Fifos not present",0
 [ counting
serial_byte_count	= "  Byte count      : ",0
serial_error_count      = "  Error count     : ",0
serial_overrrun_count	= "  Overrun count   : ",0
serial_framing_count    = "  Framing count   : ",0
serial_interrupt_count  = "  Interrupt count : ",0
serial_parity_count	= "  Parity count    : ",0
serial_buffer_overrun   = "  Buffer Overrun  : ",0
 ]
 ]
resource_file = "Resources:$.Resources.Serial.Messages", 0

default_port		* 0
default_baud		* 9600
default_data   		* 8
default_stop   		* 1
default_parity 		* 0
default_threshold 	* 32
default_fifo_trigger	* 4

base_address1		* C710 + &3f8*4
base_address2		* C710 + &2f8*4

xonchar  * &11
xoffchar * &13

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Error declarations

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; This code handles the startup of the module, the routine must claim the
; required workspace and then initialise the driver.
;
init            Entry	"r7-r11"

                MOV     r0, #2                  ; check we have the right IO system
                SWI     XOS_ReadSysInfo
                EXIT    VS

                AND     r1, r1, #&FF
                TEQ     r1, #1                  ; 82C710 or similar, please
                BNE     bad_hardware

                LDR     r2, [r12]		; r2 = &wp
                TEQ     r2, #0                  ; any workspace / warm start?
                BNE     %10

                MOV     r0, #ModHandReason_Claim
                LDR     r3, =workspace          ; r3  = amount of workspace

                SWI     XOS_Module
                EXIT    VS                      ; return if didn't work

                STR     r2, [wp]		; wp = r2
10
                MOV     wp, r2                  ; wp -> workspace

 [ standalonemessages
                ADRL    r0, resource_file_block
                SWI     XResourceFS_RegisterFiles
                EXIT    VS
 ]

                MOV     r0, #0
                STR     r0, Flags
                STR     r0, BuffManService
                STR     r0, BuffManWkSpace
                STR     r0, Port1
                STR     r0, Port2
 [ debug
		SetColour off
 ]

                MOV     r0, #3
                SWI     XOS_ReadSysInfo
                EXIT    VS
                AND     r0, r0, #&000FF000      ; type of each serial port
                TEQ     r0, #&11 :SHL: 12       ; know about type 1 and 2, must
                TEQNE   r0, #&22 :SHL: 12       ; both be same type (or not present)
                TEQNE   r0, #&01 :SHL: 12
                TEQNE   r0, #&02 :SHL: 12
                BNE     bad_hardware

                AND     r0, r0, #&0000F000
                TEQ     r0, #2 :SHL: 12
                MOVEQ   r0, #flag_SerialType2
                STREQ   r0, Flags

; check to see if the devices are present
		LDR	r0, Flags
		LDR 	r10, =base_address1
		BL	hardware_probe
		CMP	r10, #0
		ORRNE	r0, r0, #flag_Port1Present

		LDR 	r10, =base_address2
		BL	hardware_probe
		CMP	r10, #0
		ORRNE	r0, r0, #flag_Port2Present
		STR	r0, Flags

; now set these devices up
		TST	r0, #flag_Port1Present
		BEQ	%20
		LDR 	r10, =base_address1
		ADRL	r9, device_block1
		BL	establish_device
		STR	r11, Port1
		BVS	%40
20
		TST	r0, #flag_Port2Present
		LDR 	r10, =base_address2
		BEQ	%30
		ADRL	r9, device_block2
		BL	establish_device
		STR	r11, Port2
		BVS	%40
30
; claim the device vector
		BL 	hardware_claim
                EXIT

; free workspace up before exit
40
                LDR     r11, Port1
		BL	free_workspace
                LDR     r11, Port2
		BL	free_workspace
		BL	hardware_release
 [ standalonemessages
                MOV     r6, r0
                ADRL    r0, resource_file_block
                SWI     XResourceFS_DeregisterFiles
                MOV     r0, r6
 ]
                SETV
                EXIT

bad_hardware
        ADR     r0, ErrorBlock_BadHard
        MOV     r1, #0                          ;only use global message file
        MOV     r2, #0                          ;use MessageTrans buffer
        MOV     r4, #0                          ;don't substitute anything
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        B       %BT40

        MakeErrorBlock  BadHard

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		LTORG
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle module close down.
;
	MakeErrorBlock Serial_StreamInUse

final           Entry	"r0-r1,r11"

                LDR     wp, [r12]               ; wp -> workspace
; see if any streams are in use
		LDR	r11, Port1
		CMP	r11, #0
		BEQ	%10
		LDR	r0, InputStream
		CMP	r0, #0
		LDREQ	r0, OutputStream
		CMPEQ	r0, #0
		BNE	%20
10
		LDR	r11, Port2
		CMP	r11, #0
		BEQ	%30
		LDR	r0, InputStream
		CMP	r0, #0
		LDREQ	r0, OutputStream
		CMPEQ	r0, #0

		BEQ	%30

; generate an error
20
		PullEnv
		ADR	r0, ErrorBlock_Serial_StreamInUse
		B	make_error
30
		BL	hardware_release

; sort the hardware out
                LDR     r11, Port1
		BL	hardware_remove		; release any owned IRQs
		BL	unregister_device
		BL	free_workspace

                LDR     r11, Port2
		BL	hardware_remove		; release any owned IRQs
		BL	unregister_device
		BL	free_workspace

 [ standalonemessages
                ADRL    R0, resource_file_block
                SWI     XResourceFS_DeregisterFiles
 ]
                CLRV
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle service calls received by the module.
;
; Quickly test to see if they are of interest to use and pass on.

                ASSERT  Service_ResourceFSStarting < Service_DeviceFSStarting
                ASSERT  Service_DeviceFSStarting < Service_DeviceFSDying
servicetable    DCD     0
                DCD     serviceentry -module
 [ standalonemessages
                DCD     Service_ResourceFSStarting
 ]
                DCD     Service_DeviceFSStarting
                DCD     Service_DeviceFSDying
                DCD     0

                DCD     servicetable -module
service         ROUT
                MOV     r0, r0
                TEQ     r1, #Service_DeviceFSStarting
                TEQNE   r1, #Service_DeviceFSDying
 [ standalonemessages
                TEQNE   r1, #Service_ResourceFSStarting
 ]
                MOVNE   pc, lr

serviceentry    LDR     wp, [r12]

; handle devicefs starting up
                TEQ     r1, #Service_DeviceFSStarting
		BNE	%10

		Push	"r1,r11,lr"
		LDR	r1, Flags
		TST	r1, #flag_Port1Present
                LDRNE	r11, Port1
                BLNE	register_device

		TST	r1, #flag_Port2Present
                LDRNE	r11, Port2
                BLNE	register_device
		Pull	"r1,r11,pc"
10
; handle devicefs going down
                TEQ     r1, #Service_DeviceFSDying
		BNE	%20

		Push	"r1,r11"
		LDR	r1, Flags
		TST	r1, #flag_Port1Present
                LDRNE	r11, Port1
                STRNE   r0, DeviceHandle
		LDRNE	r0, PortFlags
		BICNE	r0, r0, #flag_Registered
		STRNE	r0, PortFlags

		TST	r1, #flag_Port2Present
                LDRNE	r11, Port2
                STRNE   r0, DeviceHandle
		LDRNE	r0, PortFlags
		BICNE	r0, r0, #flag_Registered
		STRNE	r0, PortFlags
		Pull	"r1,r11"
		MOV	pc, lr
20
 [ standalonemessages
                TEQ     r1, #Service_ResourceFSStarting
                BNE     %FT30					; no so continue
                Push    "r0-r3,lr"
                ADRL    r0, resource_file_block
                MOV     lr, pc
                MOV     pc, r2
                Pull    "r0-r3,pc"				; and exit
30
 ]
                MOV  	pc, lr

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; free workspace
;
; in  : r11 port workspace pointer
;
free_workspace	Entry	"r0-r2"
		MOVS    r2, r11
		MOVNE	r0, #ModHandReason_Free
		SWINE	XOS_Module
		EXIT
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; establish device
;
; in  : r9 address of devicefs registration block
;       r10 hardware base address
;
; out : r10 address if port is present, 0 otherwise
;       r11 port workspace pointer
;
establish_device Entry "r0-r3"

; we need some workspace
                MOV     r0, #ModHandReason_Claim
                LDR     r3, =port_workspace	; amount of workspace
                SWI     XOS_Module
                STRVS   r0, [sp]
                EXIT    VS                      ; return if didn't work

		MOV	r11, r2			; establish port workspace

		MOV	r0, #0
		STR	r0, DeviceHandle
		STR	r0, InputStream
		STR	r0, OutputStream
		STR	r0, InputFSHandle
		STR	r0, OutputFSHandle
		STR	r0, InputBuffer
		STR	r0, OutputBuffer
 [ debug
 [ counting
		STR	r0, ByteCount
		STR	r0, ErrorCount
		STR	r0, OverrunCount
		STR	r0, ParityCount
		STR	r0, FramingCount
		STR	r0, InterruptCount
		STR	r0, BufferOverrun
 ]
 ]
		STR	r0, BaudRate
		STR	r0, DataFormat
		STR	r0, InputBufferSize
		STR	r0, OutputBufferSize
		STR	r0, OutputBufferThreshold
		STR	r0, PortFlags
		STRB	r0, ControlLines
		STRB	r0, TxByteCount
		STRB	r0, FIFOTrigger

; set private buffer handles to invalid values
		MOV	r0, #-1
		STR	r0, InputBufferPrivId
		STR	r0, OutputBufferPrivId

		MOV	r0, #default_threshold
		STR	r0, InputBufferThreshold

		STR	r10, BaseAddress	; store base address
		STR	r9, DeviceFSBlock	; and registration info

		BL	register_device
                STRVS   r0, [sp]
		EXIT	VS

		BL	hardware_initialise
                STRVS   r0, [sp]
		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; register device
;
; in  : r11 port workspace pointer
;
register_device Entry "r0-r7"
		CMP	r11, #0                         ; clears V
		EXIT	EQ

; have we already been registered
		LDR	r0, PortFlags
		TST	r0, #flag_Registered
		EXIT	NE

                MOV     r0, #ParentFlag_FullDuplex :OR: ParentFlag_DeviceUpcalls
		LDR	r1, DeviceFSBlock
                ADDR    r2, handle_device_call    	; -> handler
                MOV     r3, r11				; passed in as r8
                MOV     r4, wp                         	; -> workspace
                ADDR    r5, device_validation           ; vaidation
                MOV     r6, #1				; max RX stream
                MOV     r7, #1                          ; max TX stream
                SWI     XDeviceFS_Register
                STRVS   r0, [sp]
                EXIT    VS
		STR	r0, DeviceHandle

; show we are registered
		LDR	r0, PortFlags
		ORR	r0, r0, #flag_Registered
		STR	r0, PortFlags

		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; unregister device
;
; in  : r11 port workspace pointer
;
unregister_device Entry "r0"
		CMP	r11, #0                         ; clears V
		EXIT	EQ

; have we been registered
		LDR	r0, PortFlags
		TST	r0, #flag_Registered
		EXIT	EQ

                LDR     r0, DeviceHandle
                CMP     r0, #0
                EXIT	EQ
                SWI     XDeviceFS_Deregister
                SUBS    r0, r0, r0                      ; R0=0, V cleared
                STR     r0, DeviceHandle

; show we are unregistered
		LDR	r0, PortFlags
		BIC	r0, r0, #flag_Registered
		STR	r0, PortFlags

		EXIT
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; handle the command *SerialInfo
;
serial_command Entry "r0-r3"

                LDR     wp, [r12]   		; wp -> workspace

		ADRL	r0, device_name1
		LDR	r11, Port1
		BL	serial_command_info

		ADRL	r0, device_name2
		LDR	r11, Port2
		BL	serial_command_info

                CLRV
		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; handle the command *SerialTest
;
serial_test_command Entry "r0-r3"

                LDR     wp, [r12]   		; wp -> workspace

		ADRL	r0, device_name1
		LDR	r11, Port1
		BL	hardware_test

		ADRL	r0, device_name2
		LDR	r11, Port2
		BL	hardware_test

                CLRV
		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; handle the command *SerialInfo
;
; in  : r0 port name
;       r11 port workspace
;
serial_command_info Entry "r1-r3"

		CMP	r11, #0
		EXIT	EQ
; write the port name
		SWI	XOS_Write0
		SWI	XOS_NewLine
; baud rate
		ADRL	r0, serial_baud_rate
		SWI	XOS_Write0
		LDR	r0, BaudRate
		BL	show_integer
		SWI	XOS_NewLine
; data format
		ADRL	r0, serial_data_format
		SWI	XOS_Write0
;   data length
		LDR	r1, DataFormat
		AND	r0, r1, #&ff
		BL	show_integer
		MOV	r0, #"."
		SWI	XOS_WriteC
;   start bits
		MOV	r0, r1, LSR #8
		AND	r0, r0, #&ff
		BL	show_integer
		MOV	r0, #"."
		SWI	XOS_WriteC
;   parity
		MOV	r1, r1, LSR #16
		AND	r1, r1, #&ff
		CMP	r1, #0
		MOVEQ	r0, #"n"
		CMP	r1, #1
		MOVEQ	r0, #"e"
		CMP	r1, #2
		MOVEQ	r0, #"o"
		SWI	XOS_WriteC
		SWI	XOS_NewLine

; handshaking
		ADRL	r0, serial_handshake
		SWI	XOS_Write0
		LDR	r1, PortFlags
		ADRL	r0, serial_handshake_none	; default
		TST	r1, #flag_UseRTS
		ADRNEL	r0, serial_handshake_rts
		TST	r1, #flag_UseXon
		ADRNEL	r0, serial_handshake_xon
		TST	r1, #flag_UseDTR
		ADRNEL	r0, serial_handshake_dtr
		SWI	XOS_Write0
		SWI	XOS_NewLine
 [ debug
; base address
		ADRL	r0, serial_base_address
		SWI	XOS_Write0
		LDR	r0, BaseAddress
		BL	show_hex8
		SWI	XOS_NewLine
; workspace
		ADRL	r0, serial_workspace
		SWI	XOS_Write0
		MOV	r0, r11
		BL	show_hex8
		SWI	XOS_NewLine
; flags
		ADRL	r0, serial_flags
		SWI	XOS_Write0
		LDR	r0, PortFlags
		BL	show_hex4
		SWI	XOS_NewLine
; control line
		BL	hardware_ctrl_lines
		ADRL	r0, serial_control_line
		SWI	XOS_Write0
		LDRB	r0, ControlLines
		BL	show_hex4
		SWI	XOS_NewLine
; input buffer
		ADRL	r0, serial_input_buffer
		SWI	XOS_Write0
		LDR	r0, InputBuffer
		BL	show_integer
		SWI	XOS_NewLine
; buffer size
		ADRL	r0, serial_ip_buffer_size
		SWI	XOS_Write0
		LDR	r0, InputBufferSize
		BL	show_integer
		SWI	XOS_NewLine
; buffer threshold
		ADRL	r0, serial_ip_buffer_thres
		SWI	XOS_Write0
		LDR	r0, InputBufferThreshold
		BL	show_integer
		SWI	XOS_NewLine
; output buffer
		ADRL	r0, serial_output_buffer
		SWI	XOS_Write0
		LDR	r0, OutputBuffer
		BL	show_integer
		SWI	XOS_NewLine
; buffer size
		ADRL	r0, serial_op_buffer_size
		SWI	XOS_Write0
		LDR	r0, OutputBufferSize
		BL	show_integer
		SWI	XOS_NewLine
; buffer threshold
		ADRL	r0, serial_op_buffer_thres
		SWI	XOS_Write0
		LDR	r0, OutputBufferThreshold
		BL	show_integer
		SWI	XOS_NewLine
; FIFOs present
		LDRB	r0, PortFlags
		TST	r0, #flag_FIFOsPresent
		ADRNEL	r0, serial_fifo_present
		ADREQL	r0, serial_fifo_not_present
		SWI	XOS_Write0
		SWI	XOS_NewLine
 [ counting
; error count
		ADRL	r0, serial_error_count
		SWI	XOS_Write0
		LDR	r0, ErrorCount
		BL	show_integer
		SWI	XOS_NewLine
 ; byte count
		ADRL	r0, serial_byte_count
		SWI	XOS_Write0
		LDR	r0, ByteCount
		BL	show_integer
		SWI	XOS_NewLine
; overrun count
		ADRL	r0, serial_overrrun_count
		SWI	XOS_Write0
		LDR	r0, OverrunCount
		BL	show_integer
		SWI	XOS_NewLine
; framing count
		ADRL	r0, serial_framing_count
		SWI	XOS_Write0
		LDR	r0, FramingCount
		BL	show_integer
		SWI	XOS_NewLine
; parity count
		ADRL	r0, serial_parity_count
		SWI	XOS_Write0
		LDR	r0, ParityCount
		BL	show_integer
		SWI	XOS_NewLine
; interrupt count
		ADRL	r0, serial_interrupt_count
		SWI	XOS_Write0
		LDR	r0, InterruptCount
		BL	show_integer
		SWI	XOS_NewLine
; buffer overrun
		ADRL	r0, serial_buffer_overrun
		SWI	XOS_Write0
		LDR	r0, BufferOverrun
		BL	show_integer
		SWI	XOS_NewLine
 ]
 ]
		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Writes an integer to the screen.
;
; in:
;    r0 - value to be displayed

show_integer	Entry "r1-r2"
        	SUB     r13, r13, #16
        	MOV     r1, r13
        	MOV     r2, #16
        	SWI     XOS_ConvertInteger4
        	SWIVC	OS_Write0
        	ADD     r13, r13, #16
        	EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Routine to write a hex number to the screen
; in:
;    r0 - value to be displayed
 [ debug
show_hex8
        Push    "r1-r2, lr"
        SUB     r13, r13, #16
        MOV     r1, r13
        MOV     r2, #16
        SWI     XOS_ConvertHex8
        SWIVC	OS_Write0
        ADD     r13, r13, #16
        Pull    "r1-r2, pc"
show_hex4
        Push    "r1-r2, lr"
        SUB     r13, r13, #16
        MOV     r1, r13
        MOV     r2, #16
        SWI     XOS_ConvertHex4
        SWIVC	OS_Write0
        ADD     r13, r13, #16
        Pull    "r1-r2, pc"
 ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Generalised internationalisation routines, these ensure that messages files
; are correctly opened and then return the relevant data.
;
; Attempt to open the messages file.

open_messages   Entry   "r0-r3"
                LDRB    r3, Flags
                TST     r3, #flag_HaveMessages
                EXIT    NE

                ADR     r0, MessagesWorkspace
                ADRL    r1, resource_file     ; -> path to be opened
                MOV     r2, #0                ; allocate some wacky space in RMA
                SWI     XMessageTrans_OpenFile
                LDRVCB  r3, Flags
                ORRVC   r3, r3, #flag_HaveMessages
                STRVCB  r3, Flags
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Attempt to close the messages file.

close_messages  Entry   "r0"
                LDRB    r0, Flags
                TST     r0, #flag_HaveMessages
                EXIT    EQ

                ADR     r0, MessagesWorkspace
                SWI     XMessageTrans_CloseFile
                LDRVCB  r0, Flags
                BICVC   r0, r0, #flag_HaveMessages
                STRVCB  r0, Flags
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Generate an error based on the error token given.  Does not assume that
; the messages file is open.  Will attempt to open it, then look it up.
; if make_error_with_name is called, the module name is substituted in r4

make_error_with_name Entry "r1-r7"
		ADRL	r4, title
		B	make_error_entry

make_error      ALTENTRY
                MOV     r4, #0
make_error_entry
                LDRB    r1, Flags
                TST     r1, #flag_HaveMessages
                BLEQ    open_messages

                LDRB    r1, Flags
                TST     r1, #flag_HaveMessages
                BEQ     make_error_exit

                ADR     r1, MessagesWorkspace
                MOV     r2, #0
                MOV     r3, #0
                MOV     r5, #0
                MOV     r6, #0
                MOV     r7, #0
                SWI     XMessageTrans_ErrorLookup
                BL      close_messages

make_error_exit
                SETV
                EXIT                           ; return, r0 -> block, V set

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; This bit of apparently harmless code will bind a messages file into the code
; in the case of a standalone module. The macro ResourceFile will create the
; stuff and the label resource_file is used to point to the block required by
; ResourceFS

 [ standalonemessages
resource_file_block
	ResourceFile $MergedMsgs, Resources.Serial.Messages
	DCD     0
 ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		END
@


4.8
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.26. Tagged as 'DualSerial-0_26'
@
text
@d515 3
d522 3
@


4.7
log
@  Merge of 32-bit branch.
Detail:
  This version represents the merge of the 32-bit conversion of the DualSerial
    module.
Admin:
  This module has received a modest amount of testing, however, it has not
    been exhaustively tested.  Projects taking this version should be careful
    of it as it may contain bugs.

Version 0.25. Tagged as 'DualSerial-0_25'
@
text
@d124 1
d285 1
a285 1
init            ENTRY	"r7-r11"
d411 1
a411 1
final           ENTRY	"r0-r1,r11"
d542 1
a542 1
free_workspace	ENTRY	"r0-r2"
d559 1
a559 1
establish_device ENTRY "r0-r3"
d626 1
a626 1
register_device ENTRY "r0-r7"
d663 1
a663 1
unregister_device ENTRY "r0"
d691 1
a691 1
serial_command ENTRY "r0-r3"
d712 1
a712 1
serial_test_command ENTRY "r0-r3"
d736 1
a736 1
serial_command_info ENTRY "r1-r3"
d913 1
a913 1
show_integer	ENTRY "r1-r2"
d958 1
a958 1
open_messages   ENTRY   "r0-r3"
d976 1
a976 1
close_messages  ENTRY   "r0"
d994 1
a994 1
make_error_with_name ENTRY "r1-r7"
d998 1
a998 1
make_error      ENTRY "r1-r7"
d1031 1
a1031 1
	ResourceFile LocalRes:Messages, Resources.Serial.Messages
@


4.7.2.1
log
@Second attempt to check this in.

Version 0.25, 4.8.2.2. Tagged as 'DualSerial-0_25-4_8_2_2'
@
text
@d36 11
a46 1

d59 1
a59 1
; workspace
d61 2
a62 6
                        ^ 0, wp
Flags			# 4
BuffManWkSpace          # 4	; buffer manager workspace
BuffManService          # 4     ; address of buffer manager routine
MessagesWorkspace       # 16    ; needed for messages routines
;DeviceFSBlock		# 4	; address of devicefs registration block
d76 1
a76 22
PortNumber              # 4     ;
HAL_UARTPorts           # 4     ; report number of ports
HAL_UARTStartUp         # 4     ; setup the uart
HAL_UARTShutdown        # 4     ; shutdown the uart
HAL_UARTFeatures        # 4     ; report features
HAL_UARTReceiveByte     # 4     ; receive a byte, optionally return status
HAL_UARTTransmitByte    # 4     ; transmit a byte
HAL_UARTLineStatus      # 4     ; return status (of last reveived byte)
HAL_UARTInterruptEnable # 4     ; enable interrupts
HAL_UARTRate            # 4     ;
HAL_UARTFormat          # 4     ;
HAL_UARTFIFOSize        # 4     ;
HAL_UARTFIFOClear       # 4     ;
HAL_UARTFIFOEnable      # 4     ;
HAL_UARTFIFOThreshold   # 4     ;
HAL_UARTInterruptID     # 4     ;
HAL_UARTBreak           # 4     ;
HAL_UARTModemControl    # 4     ;
HAL_UARTModemStatus     # 4     ;
HAL_UARTDevice          # 4     ;
    ! 0, "Assuming only one base address for the moment"
HAL_StaticBase          # 4
d83 1
a83 2
FIFOSize                # 1
                        AlignSpace
d93 1
a93 3
DeviceFSBlock_size      * 40
DeviceFSBlock           # DeviceFSBlock_size
workspace		* :INDEX: @@
d194 3
a196 2
device_name     = "Serial"
device_n        = "n", 0
d198 2
a199 1
device_block    & device_name - device_block
d208 1
a209 1
device_block_end
d211 11
a221 1
                ASSERT  device_block_end - device_name = DeviceFSBlock_size
a278 2
	MakeErrorBlock Serial_NoHAL

d284 1
a284 13
init            ENTRY	"r7-r11", 20

 [ nohal_debug
                SWI     OS_WriteS
                =       "r11 = ",0
                ALIGN
                ADD     r0, r11, #'0'
                SWI     OS_WriteC
                SWI     OS_NewLine
 ]
                TEQ     R11, #0                 ; Loaded from filing system
                CMPNE   R11, #&03000000         ; ROM loaded
                BLO     %FT7                    ; We're a reincarnation
d286 2
a287 4
; Messages are registered by the base instantiation
 [ standalonemessages
                ADRL    r0, resource_file_block
                SWI     XResourceFS_RegisterFiles
a288 20
 ]

                LDR     r9, =EntryNo_HAL_UARTPorts
                MOV     r8, #0
 [ nohal_debug
                MOV     r0, #2
 |
                SWI     XOS_Hardware
 ]
                BVC     %FT2
		ADR	r0, ErrorBlock_Serial_NoHAL
		BL	make_error
 [ standalonemessages
                MOV     r6, r0
                ADRL    r0, resource_file_block
                SWI     XResourceFS_DeregisterFiles
                MOV     r0, r6
 ]
                SETV
                EXIT
d290 3
a292 9
                ; We have to build the instantations in a callback, so that
                ; they know who they are, otherwise they think they're the base
2
                MOVS    r1, r0
                EXIT    EQ                      ; exit if no ports
                ADR     r0, build_instants
                SWI     XOS_AddCallBack

                EXIT
a293 1
7
d308 5
d318 2
a319 2
                SUB     r0, r11, #1             ; start counting at 0
                STR     r0, PortNumber
d323 42
d366 4
a369 2
 [ nohal_debug
 |
d371 14
d386 1
d389 10
a398 30
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Callback to finish off initialisation
; On entry, r12 = number of instantiations.
;

build_instants Entry "r0-r4", 20
                ADR     r1, title
                MOV     r3, sp
3               LDRB    r2, [r1], #1           ; Copy over module name
                TEQ     r2, #0
                STRNEB  r2, [r3], #1
                BNE     %BT3
                MOV     r2, #'%'
                STRB    r2, [r3], #1

                ADD     r2, r12, #'0'            ; Start at top port
5               MOV     r4, r3                  ; remember current pointer
                STRB    r2, [r4], #1
                MOV     lr, #0
                STRB    lr, [r4], #1
                MOV     r0, #ModHandReason_NewIncarnation
                MOV     r1, sp
                SWI     XOS_Module
                SUBVC   r2, r2, #1
                TEQVC   r2, #'0'
                MOVVSS  r2, #0
                BNE     %BT5
d400 1
a400 1
                EXIT
d410 1
a410 1
final           ENTRY	"r0-r1"
a412 2
                TEQ     r12, #0
                BEQ     %FT40
d414 12
a425 3
 [ nohal_debug
                TEQ     r0, r0
 |
d430 1
a430 1
 ]
a438 2
 [ nohal_debug
 |
d442 6
a448 1
 ]
d450 2
a451 2
                EXIT
40
d488 1
a488 3
serviceentry
                ENTRY   "r1"
                LDR     wp, [r12]
a492 6
 [ nohal_debug
                SWI     OS_WriteS
                =       "DeviceFS starting", 0
                ALIGN
                SWI     OS_NewLine
 ]
d494 10
a503 2
                BL	register_device
                EXIT
d509 4
a512 4
                LDR     r0, PortFlags
                BIC     r0, r0, #flag_Registered
                STR     r0, PortFlags
                MOV     r0, #0
d515 5
a519 1
                EXIT
d524 1
a524 1
                Push    "r0-r3"
d528 1
a528 1
                Pull    "r0-r3"
d531 1
a531 1
                EXIT
d533 1
d536 11
d552 7
a558 2
                MACRO
                GetHalEntry $entry
d560 6
a565 4
                MOV     r9, #EntryNo_$entry
                SWI     OS_Hardware
                STR     r0, $entry
                MEND
d567 1
a567 1
establish_device ENTRY "r0-r3"
d606 3
a612 27
; set up hal calls
 [ nohal_debug
 |
                MOV     R8, #1
                GetHalEntry HAL_UARTStartUp
                GetHalEntry HAL_UARTShutdown
                GetHalEntry HAL_UARTFeatures
                GetHalEntry HAL_UARTReceiveByte
                GetHalEntry HAL_UARTTransmitByte
                GetHalEntry HAL_UARTLineStatus
                GetHalEntry HAL_UARTInterruptEnable
                GetHalEntry HAL_UARTRate
                GetHalEntry HAL_UARTFormat
                GetHalEntry HAL_UARTFIFOSize
                GetHalEntry HAL_UARTFIFOClear
                GetHalEntry HAL_UARTFIFOEnable
                GetHalEntry HAL_UARTFIFOThreshold
                GetHalEntry HAL_UARTInterruptID
                GetHalEntry HAL_UARTBreak
                GetHalEntry HAL_UARTModemControl
                GetHalEntry HAL_UARTModemStatus
                GetHalEntry HAL_UARTDevice
                STR     R1, HAL_StaticBase

                MOV     r9, r1
                CallHAL HAL_UARTFIFOSize
                STRB    r0, FIFOSize
a613 2
 ]

d623 5
a627 1
register_device ENTRY "r0-r8"
a633 27
; don't... copy the device block onto the workspace
                ADD     r0, r12, # :INDEX:DeviceFSBlock
                ADRL    r1, device_name
                ADRL    r3, device_block_end
10              LDR     r2, [r1], #4
                STR     r2, [r0], #4
                CMP     r1, r3
                BLT     %BT10

                ADD     r0, r12, # :INDEX:DeviceFSBlock
                LDR     r2, PortNumber
    ! 0, "This module only handles port numbers up to 1 - 9"
                ADD     r2, r2, #'1'
                STRB    r2, [r0, #device_n - device_name]
                MOV     r1, r0
 [ nohal_debug
                SWI     OS_WriteS
                =       "Creating device: ",0
                ALIGN
                MOV     r0, r1
                SWI     OS_Write0
                SWI     OS_NewLine
 ]

                ADD     r1, r1, #device_block - device_name
                ; r1 now points to a valid devicefs block.

d635 1
d637 1
a637 1
                MOV     r3, #0
d660 2
d663 2
d692 9
a700 10
    ! 0, "Serial info command not implemented"
;                LDR     wp, [r12]   		; wp -> workspace
;
;		ADRL	r1, device_name1
;		LDR	r11, Port1
;		BL	serial_command_info
;
;		ADRL	r0, device_name2
;		LDR	r11, Port2
;		BL	serial_command_info
d713 11
a723 12
    ! 0, "Serial test command not implemented"
;                LDR     wp, [r12]   		; wp -> workspace
;
;		ADRL	r0, device_name1
;		LDR	r11, Port1
;		BL	hardware_test
;
;		ADRL	r0, device_name2
;		LDR	r11, Port2
;		BL	hardware_test
;
;                CLRV
a736 1
    ! 0, "Serial test command not implemented"
@


4.7.2.2
log
@Fixed call to HAL_UARTFIFOSize in initialisation code.

Version 0.25, 4.8.2.5. Tagged as 'DualSerial-0_25-4_8_2_5'
@
text
@a606 3
                SUB     sp, sp, #4
                MOV     r1, #0
                MOV     r2, sp
a607 3
                LDR     r0, [sp], #4
                CMP     r0, #255
                MOVHS   r0, #255
@


4.7.2.3
log
@Change to DTR/RTS handling.

Version 0.25, 4.8.2.6. Tagged as 'DualSerial-0_25-4_8_2_6'
@
text
@d263 1
a263 1
resource_file = "Resources:$.Resources.DualSerial.Messages", 0
d1055 1
a1055 1
	ResourceFile LocalRes:Messages, Resources.DualSerial.Messages
@


4.7.2.4
log
@Change to use objasm (the non HAL one already has): fixes report that
it blew messagetrans away when rmkilled.
Change to have a zero in the command table word: fixes report that
serialinfo and serialtest don't do anything,indeed they don't in this
HAL version!

Version 0.25, 4.8.2.7. Tagged as 'DualSerial-0_25-4_8_2_7'
@
text
@a141 1
                AREA  |DualSerial$$Code|, CODE, READONLY, PIC
a149 4
 [ {TRUE}
              ! 0, "Serial info & test command not implemented"
                & 0
 |
a150 1
 ]
d292 1
a292 1
init            Entry	"r7-r11", 20
d415 1
a415 1
final           Entry	"r0-r1"
d484 1
a484 1
                Entry   "r1"
d539 1
a539 1
establish_device Entry "r0-r3"
d627 1
a627 1
register_device Entry "r0-r8"
d686 1
a686 1
unregister_device Entry "r0"
d712 1
a712 1
serial_command Entry "r0-r3"
a713 1
 [ {TRUE}
d715 9
a723 10
 |
                LDR     wp, [r12]   		; wp -> workspace

		ADRL	r1, device_name1
		LDR	r11, Port1
		BL	serial_command_info

		ADRL	r0, device_name2
		LDR	r11, Port2
		BL	serial_command_info
a725 1
  ]
d734 1
a734 1
serial_test_command Entry "r0-r3"
a735 1
 [ {TRUE}
d737 11
a747 13
 |
                LDR     wp, [r12]   		; wp -> workspace

		ADRL	r0, device_name1
		LDR	r11, Port1
		BL	hardware_test

		ADRL	r0, device_name2
		LDR	r11, Port2
		BL	hardware_test

                CLRV
 ]
d759 1
a759 1
serial_command_info Entry "r1-r3"
d761 1
a761 3
 [ {TRUE}
    ! 0, "Serial info command not implemented"
 |     
d813 1
a813 1
        [ debug
d882 1
a882 1
              [ counting
d925 2
a926 3
                ] ; Counting
        ] ; Debug
 ] ; No SerialInfo
d937 1
a937 1
show_integer	Entry "r1-r2"
d982 1
a982 1
open_messages   Entry   "r0-r3"
d1000 1
a1000 1
close_messages  Entry   "r0"
d1018 1
a1018 1
make_error_with_name Entry "r1-r7"
d1022 1
a1022 1
make_error      Entry "r1-r7"
@


4.7.2.5
log
@Changes from Kevin: support for clearing the interrupt when it has been
serviced using HAL_IRQClear.

Version 0.25, 4.8.2.8. Tagged as 'DualSerial-0_25-4_8_2_8'
@
text
@a70 1
IRQDeviceNumber         # 4     ;
a89 1
HAL_IRQClear            # 4
a501 2
                TEQ     wp, #0
                BLNE    register_device
d503 1
a509 3
                TEQ     wp, #0
                EXIT    EQ

a520 4

                TEQ     wp, #0                                  ; only base instantiation
                EXIT    NE

a609 1
                GetHalEntry HAL_IRQClear
d775 1
a775 1
 |
@


4.7.2.6
log
@Rewrite module to add support for acting as a client of SerialSupport
Detail:
  In order to act as a client of SerialSupport, DualSerial needs to support the set of device calls that SerialSupport uses to talk to the serial driver.
  This set of device calls operates at a lower level than the IOCtl interface which DualSerial already supports.
  Therefore simply adding the new device call interface ontop of DualSerial (or modifying SerialSupport to add IOCtl support) would have been a risky venture, due to the many complexities hidden in the Serial module sources.
  So to reduce the amount of risk inherent in the change, I've instead taken the Serial module, stripped out 6551 support, rewritten the 710 interface to use HAL calls, and then bolted the IOCtl interface on top.
  This should ensure the SerialSupport/OS_SerialOp interface is identical to that provided by the Serial module, and only the simpler to understand DualSerial/IOCtl interface is the one likely to contain any bugs.
  File changes:
  - Docs/serial.htm - Added a copy of the IOCtl interface docs, from the Ursula branch
  - s/common, s/errors, s/init, s/macros, s/main - New implementation of the module, based around modified Serial sources
  - s/serialhal - The business end of the module, based around s/Serial710 in the Serial sources
  - s/ioctl - New file containing reimplemented IOCtl interface
  - s/devicecall, s/hardware, s/interrupts, s/standalone - Deleted redundant files from old implementation
  - Makefile - Trimmed somewhat redundant comment
  - resources/UK/messages - Added new error messages
Admin:
  Tested in OMAP3 & Tungsten ROMs


Version 0.25, 4.8.2.11. Tagged as 'DualSerial-0_25-4_8_2_11'
@
text
@d16 1
a16 1
;               Copyright 1996 Acorn Network Computing
d25 11
d38 8
d52 2
a53 2
Flags                   # 4     ; global f_ flags
BuffManWkSpace          # 4     ; buffer manager workspace
d56 14
a69 17
DeviceHandle            # 4     ; handle returned from DeviceFS_Register
WaitForIRQsToFire       # 4     ; -> routine to allow pending IRQs to fire

InputHandle             # 4     ;  = DeviceFS handle used for input stream
OutputHandle            # 4     ;  = DeviceFS handle used for output stream

InputFSHandle           # 4     ;  = file switch handle of input stream
OutputFSHandle          # 4     ;  = file switch handle of output stream

InputBufferHandle       # 4     ;  = buffer handle used for input stream  (-1 if none)
OutputBufferHandle      # 4     ;  = buffer handle used for output stream (-1 if none)

InputBufferPrivId       # 4     ;  = buffer managers private buffer id
OutputBufferPrivId      # 4     ;  = buffer managers private buffer id

PutCharOutputFileHandle # 4     ;  = file handle for putchar stream (0 if none)

d72 1
d94 7
a100 19


SerialDeviceFlags       # 4     ;  = serial flags
SerialRXBaud            # 1     ;  = baud rate (8bit) for RX
SerialTXBaud            # 1     ;  = baud rate (8bit) for TX
SerialXONXOFFChar       # 1     ;  = serial XON/XOFF character (8bit)
SerialCurrentError      # 1     ;  = current internal error code (8bit)
InputBufferSize         # 4     ;  = buffer size in bytes
OutputBufferSize        # 4     ;
InputBufferThreshold    # 4     ;  = input buffer threshold value being used
OutputBufferThreshold   # 4     ;
 [ :LNOT: NewTXStrategy
SerialBaudDivisor       # 4     ;  = current baud divisor (for 710/711/665)
 ]
SerialTxByteCount       # 1     ;  = used by TX IRQ routine to count bytes left to send
FIFOSize                # 1     ;  = HW FIFO size
FIFOTrigger             # 1     ;  = RX FIFO trigger value
                        # 1     ;  = unused

d102 9
d113 1
a113 1
workspace               * :INDEX: @@
d115 23
a137 6
f_SerialIRQ             * 1:SHL:0       ; set => IRQ owned for serial device
f_WeHaveMessages        * 1:SHL:1       ; set => we have messages
f_UseFIFOs              * 1:SHL:2       ; set => we can use FIFOs
f_FIFOsEnabled          * 1:SHL:3       ; set => FIFOs are enabled
f_Registered            * 1:SHL:4       ; set => registered with DeviceFS
f_DefaultPort           * 1:SHL:5       ; set => we get used for OS_SerialOp
d153 6
a158 1
                & 0                             ; => command table
d180 23
a202 1
                ALIGN
d208 9
d222 1
a222 1
                ALIGN
d241 30
d273 10
a282 4
default_baud            * 0 ; i.e. 9600
default_data            * 0 ; i.e. 8n1, no parity
default_threshold       * 32
default_fifo_trigger    * 4
d293 1
a293 4
        MakeErrorBlock Serial_NoHAL
        MakeErrorBlock Serial_BadControlOp
        MakeErrorBlock Serial_BadBaud
        MakeErrorBlock Serial_StreamInUse
d300 1
a300 1
init            Entry   "r7-r11", 20
d302 8
d317 2
a318 1
                SWI     XResourceFS_RegisterFiles   ; ignore errors (starts on Service_ResourceFSStarting)
d323 3
d327 1
d329 2
a330 2
                ADR     r0, ErrorBlock_Serial_NoHAL
                BL      MakeError
a332 3
              [ international
                BL      CloseMessages           ; close any messages files
              ]
d351 1
a351 1
                LDR     r2, [r12]               ; r2 = &wp
d361 1
a361 1
                STR     r2, [wp]                ; wp = r2
a369 6

                MOV     r0, #0                          ; Read feature flags and address of IRQ delay routine too
                MOV     r1, #0                          ; In case of unknown SWI error
                SWI     XOS_PlatformFeatures
                STR     r1, WaitForIRQsToFire

d372 8
a379 2
                BL      establish_device
;                BL      hardware_claim
d416 1
a416 1
                LTORG
d421 1
d423 1
a423 1
final           Entry   "r0-r1"
d429 9
a437 5
                LDR     r0, InputHandle
                CMP     r0, #0
                LDREQ   r0, OutputHandle
                CMPEQ   r0, #0
                BEQ     %30
d441 3
a443 3
                PullEnv
                ADR     r0, ErrorBlock_Serial_StreamInUse
                B       MakeError
d445 3
a447 1
;                BL      hardware_release
d450 3
a452 3
                MOV     r0, #serialctrl_Dying
                BL      CallDevice              ; ensure device quiescent
                BL      unregister_device
a454 3
              [ international
                BL      CloseMessages           ; close any messages files
              ]
a471 2
                ASSERT  Service_DeviceFSDying < Service_SerialDevice
                ASSERT  Service_SerialDevice < Service_DeviceFSCloseRequest
a478 2
                DCD     Service_SerialDevice
                DCD     Service_DeviceFSCloseRequest
a485 2
                TEQNE   r1, #Service_DeviceFSCloseRequest
                TEQNE   r1, #Service_SerialDevice
d492 1
a493 3
                Entry   "r0"
                TEQ     wp, #0
                BEQ     serviceentry_base
d497 9
a505 2
                BNE     %10
                BL      register_device
d511 1
a511 1
                BNE     %20
d513 6
a518 3
                LDR     r0, Flags
                BIC     r0, r0, #f_Registered
                STR     r0, Flags
d520 1
a520 1
                STR     r0, DeviceHandle
d524 3
a526 13
                TEQ     r1, #Service_DeviceFSCloseRequest
                BNE     %FT30

                LDR     lr, PutCharOutputFileHandle
                TEQ     lr, r2
                EXIT    NE                              ; if not our handle, then pass on service

                MOV     r0, #0                          ; our file handle is not in use any more
                STR     r0, PutCharOutputFileHandle     ; so zero it
                MOV     r1, r2
                SWI     XOS_Find                        ; close file, ignore errors
                MOV     r1, #0                          ; claim success (even if we got an error?)
                EXIT
d528 1
a528 3
30
                TEQ     r1, #Service_SerialDevice
                CMPEQ   r2, #-1                         ; is it from Serial Support?
a529 12
                LDR     lr, Flags      
                TST     lr, #f_DefaultPort              ; and we are the default serial port?
                PullEnv
                LDRNE   r0, DeviceHandle                ; yes, so setup device handle
                MOVNE   r1, #Service_Serviced
                MOV     pc, lr

                
serviceentry_base
 [ standalonemessages
                TEQ     r1, #Service_ResourceFSStarting
                BNE     %FT50                                   ; no so continue
d536 1
a536 1
50
d555 1
a555 1
establish_device Entry "r0-r3,r8-r9"
d557 28
a584 31
                MOV     r8, #0
                LDR     r9, =EntryNo_HAL_UARTDefault
                MVN     r0, #0
                SWI     XOS_Hardware
                MVNVS   r0, #0
                LDR     r1, PortNumber
                TEQ     r0, r1
                LDREQ   r1, Flags
                ORREQ   r1, r1, #f_DefaultPort
                STREQ   r1, Flags
                
                MOV     r0, #0
                STR     r0, DeviceHandle
                STR     r0, InputHandle
                STR     r0, OutputHandle
                STR     r0, InputFSHandle
                STR     r0, OutputFSHandle
                STR     r0, PutCharOutputFileHandle
                STR     r0, SerialDeviceFlags
                STRB    r0, SerialRXBaud
                STRB    r0, SerialTXBaud
                STRB    r0, SerialXONXOFFChar
                STRB    r0, SerialCurrentError
                STR     r0, InputBufferSize
                STR     r0, InputBufferThreshold
                STR     r0, OutputBufferSize
                STR     r0, OutputBufferThreshold
              [ :LNOT: NewTXStrategy
                STR     r0, SerialBaudDivisor
              ]
                STRB    r0, SerialTxByteCount
d587 10
a596 5
                MOV     r0, #-1
                STR     r0, InputBufferHandle
                STR     r0, OutputBufferHandle
                STR     r0, InputBufferPrivId
                STR     r0, OutputBufferPrivId
d599 2
a600 1
                CLRV
a622 3
                STRVS   r0, [sp]
                EXIT    VS

a623 9
                CallHAL HAL_UARTDevice
                STR     r0, IRQDeviceNumber

                CallHAL HAL_UARTFeatures
                TST     r0, #1
                LDRNE   r1, Flags
                ORRNE   r1, r1, #f_UseFIFOs
                STRNE   r1, Flags

d632 2
a634 7
                LDR     r1, Flags
                TST     r1, #f_DefaultPort
                LDREQ   r0, =default_fifo_trigger
                LDRNE   r0, =FC_RXTrigger1
                STRB    r0, FIFOTrigger

                BL      register_device
d636 1
a636 83
                EXIT    VS

                LDR     r1, Flags
                MOV     r0, #0
                TST     r1, #f_UseFIFOs                 ; if we can use FIFOs then
                MOVNE   r0, #1:SHL:SF_UseFIFOs          ;    flag in device flags
                TST     r1, #f_DefaultPort              ; if we aren't the default port
                ORREQ   r0, #1:SHL:SF_DCDIgnore         ;    ignore DCD (old DualSerial always ignored DCD)
                STR     r0, SerialDeviceFlags


                MOV     r0, #serialctrl_Reset
                BL      CallDevice                      ; reset the serial device

                TST     r1, #f_DefaultPort
                BEQ     %FT10

                ; Initialise using programmed CMOS values

                MOV     r0, #ReadCMOS
                MOV     r1, #PSITCMOS
                SWI     XOS_Byte
                MOVVC   r2, r2, LSR #2                  ; if succeeded, shift bits down
                ANDVC   r2, r2, #2_111                  ; extract relevant bits (0 => 75, ... ,7 => 19200)
                ADDVC   r2, r2, #1                      ; 1 => 75, ... ,8 => 19200
                MOVVS   r2, #0                          ; use 9600 if error

                Debug   init, "RX/TX baud rates:", r2

                MOV     r0, #serialctrl_ChangeBaud
                MOV     r1, r2                          ; RX = TX
                BL      CallDevice

                MOV     r0, #ReadCMOS
                MOV     r1, #DBTBCMOS
                SWI     XOS_Byte
                MOVVC   r2, r2, LSR #5
                ANDVC   r2, r2, #2_111                  ; r2 => serial data format
                MOVVS   r2, #4                          ; default to 8n2 if error
                ADR     r1, datatable
                LDRB    r1, [r1, r2]                    ; convert from configured value to usable value

                Debug   init, "Data format word:", r1

                MOV     r0, #serialctrl_ChangeDataFormat
                BL      CallDevice                      ; call device informing of format changes

                MOV     r0, #&CB
                MOV     r1, #0
                MOV     r2, #&FF                        ; read buffer minimum space
                SWI     XOS_Byte
                MOVVS   r1, #17                         ; if that failed then setup a value
                STR     r1, InputBufferThreshold        ; and store it away in workspace

 [ PowerControl
                BL      SetPower_Off                    ; power not needed
 ]

                EXIT

10
                ; Initialise using default values from DualSerial of old
                LDR     r0, =default_threshold
                STR     r0, InputBufferThreshold
                LDR     r2, =default_baud
                MOV     r0, #serialctrl_ChangeBaud
                MOV     r1, r2                          ; RX = TX
                BL      CallDevice
                LDR     r1, =default_data
                MOV     r0, #serialctrl_ChangeDataFormat
                BL      CallDevice                      ; call device informing of format changes

                EXIT                                

datatable
                = (1:SHL:0)+ (1:SHL:4)+ (1:SHL:2)+ (1:SHL:3)
                = (1:SHL:0)+ (0:SHL:4)+ (1:SHL:2)+ (1:SHL:3)
                = (1:SHL:0)+ (1:SHL:4)+ (0:SHL:2)+ (1:SHL:3)
                = (1:SHL:0)+ (0:SHL:4)+ (0:SHL:2)+ (1:SHL:3)
                = (0:SHL:0)+ (0:SHL:4)+ (1:SHL:2)+ (0:SHL:3)
                = (0:SHL:0)+ (0:SHL:4)+ (0:SHL:2)+ (0:SHL:3)
                = (0:SHL:0)+ (1:SHL:4)+ (0:SHL:2)+ (1:SHL:3)
                = (0:SHL:0)+ (0:SHL:4)+ (0:SHL:2)+ (1:SHL:3)
d647 3
a649 3
                LDR     r0, Flags
                TST     r0, #f_Registered
                EXIT    NE
d666 8
d679 1
a679 1
                ADDR    r2, Serial710                   ; -> handler
d681 1
a681 1
                MOV     r4, wp                          ; -> workspace
d683 1
a683 1
                MOV     r6, #1                          ; max RX stream
d688 1
a688 1
                STR     r0, DeviceHandle
d691 3
a693 6
                LDR     r1, Flags
                ORR     r1, r1, #f_Registered
                STR     r1, Flags

                TST     r1, #f_DefaultPort
                EXIT    EQ
d695 1
a695 5
                MOV     r1, #Service_SerialDevice
                MOV     r2, #0                          ; from me to Serial Support module
                SWI     XOS_ServiceCall

                EXIT
d706 3
a708 3
                LDR     r0, Flags
                TST     r0, #f_Registered
                EXIT    EQ
d712 1
a712 1
                EXIT    EQ
d718 255
a972 3
                LDR     r0, Flags
                BIC     r0, r0, #f_Registered
                STR     r0, Flags
a973 1
                EXIT
d975 25
a1005 3
              [ international


d1008 4
a1011 4
OpenMessages    Entry   "r0-r3"
                LDR     r3, Flags
                TST     r3, #f_WeHaveMessages                   ; do we have an open messages block?
                BNE     %FT90                                   ; yes, so don't bother again
d1014 2
a1015 2
                ADRL    r1, resource_file                       ; -> path to be opened
                MOV     r2, #0                                  ; allocate some wacky space in RMA
d1017 4
a1020 6
                LDRVC   r3, Flags
                ORRVC   r3, r3, #f_WeHaveMessages
                STRVC   r3, Flags                               ; assuming it worked mark as having messages
90              CMP     r0, #0
                EXIT                                            ; always return VC, cos don't want to corrupt r0
                                                                ; (will hold a real error pointer)
d1022 2
d1026 4
a1029 5
CloseMessages   Entry   "r0"
                CMP     r0, #0                                  ; clear V
                LDR     r0, Flags
                TST     r0, #f_WeHaveMessages                   ; do we have any messages?
                EXIT    EQ                                      ; and return if not!
d1032 4
a1035 5
                SWI     XMessageTrans_CloseFile                 ; yes, so close the file
                LDRVC   r0, Flags
                BICVC   r0, r0, #f_WeHaveMessages
                STRVC   r0, Flags                               ; mark as we don't have them
                CMP     r0, #0                                  ; clear V
d1038 2
d1042 5
d1048 10
a1057 8
MakeError       Entry   "r1-r7"
                LDR     r1, Flags
                TST     r1, #f_WeHaveMessages                   ; has the messages file been closed?
                BLEQ    OpenMessages

                LDR     r1, Flags
                TST     r1, #f_WeHaveMessages
                BEQ     %FT99                                   ; if still not open then return with V set
d1059 1
a1059 1
                ADR     r1, MessagesWorkspace                   ; -> message control block
a1061 1
                MOV     r4, #0
d1064 1
a1064 1
                MOV     r7, #0                                  ; no substitution + use internal buffers
d1066 1
d1068 1
a1068 3
                BL      CloseMessages                           ; attempt to close the doofer

99
d1070 1
a1070 24
                EXIT                                            ; return, r0 -> block, V set

              ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: CallDevice
;
; in:   r0  = reason code
;   r1..r7  = parameters
;
; out:  -
;
; This routine will call the device with the parameters setup in r1..r7.
;

CallDevice      Entry   "r1-r7"
                MOV     r2, sp                                  ; -> return frame to be used
                BL      Serial710                               ; call device with return frame setup
                EXIT                                            ; and return back to the caller!

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d1081 2
a1082 2
        ResourceFile LocalRes:Messages, Resources.DualSerial.Messages
        DCD     0
d1087 1
a1087 1
                END
@


4.7.2.7
log
@Fix HAL_UARTModemControl parameters. Fix UAL warning caused by typo.
Detail:
  s/serialhal - Fixed HAL_UARTModemControl being called with r2 uninitialised, causing modem control lines to be set to unpredictable values
  s/main - Fixed UAL syntax warning caused by typo
Admin:
  Tested on rev A2 BB-xM
  HAL now reports correct modem control line states when control lines are poked via OS_SerialOp


Version 0.25, 4.8.2.12. Tagged as 'DualSerial-0_25-4_8_2_12'
@
text
@d565 1
a565 1
                ORREQ   r0, r0, #1:SHL:SF_DCDIgnore     ;    ignore DCD (old DualSerial always ignored DCD)
@


4.7.2.8
log
@  Added HAL_UARTFeatures bit to report that the chip does hardware RTS/CTS
  handshaking, and use chip RTS/CTS if available in Seria
Detail:

Admin:
  tested on iMx6


Version 0.25, 4.8.2.13. Tagged as 'DualSerial-0_25-4_8_2_13'
@
text
@a106 1
f_HW_RTS_CTS            * 1:SHL:6       ; set => hardware RTS/CTS is used
d537 1
a537 1
                LDR     r1, Flags
d539 1
a539 3
                TST     r0, #1<<3
                ORRNE   r1, r1, #f_HW_RTS_CTS
                STR     r1, Flags
@


4.7.2.9
log
@Add support for UARTs that have a FIFO threshold for the "transmitter empty" IRQ
Detail:
  s/main, s/serialhal - For threshold-based transmitter empty IRQs, make UpdateDTRRTSTXI710 transmit as many bytes as possible until we either hit the FIFO upper limit or decide to stop. This is required to "prime" the interrupt because it may only update when the FIFO level crosses the threshold (e.g. PL011)
Admin:
  Tested on Raspberry Pi


Version 0.25, 4.8.2.14. Tagged as 'DualSerial-0_25-4_8_2_14'
@
text
@d92 1
a92 1
FIFOSize                # 1     ;  = TX FIFO size
a107 1
f_TX_Threshold          * 1:SHL:7       ; set => transmitter empty IRQ is actually "TX FIFO under threshold", and may only change state once level is crossed (so on startup IRQ may not be firing). Use new LS_TXFull flag to know when to stop pushing bytes.
a541 2
                TST     r0, #1<<4
                ORRNE   r1, r1, #f_TX_Threshold
@


4.7.2.10
log
@Fix RX error handling. Fix crash on *RMReinit
Detail:
  s/serialhal - Adjust IRQ handler so that both line status interrupts and RX interrupts are handled via HAL_UARTReceiveByte (with line status return), so that the module can deal with controllers where the IRQ state doesn't correspond to the top byte in the FIFO (e.g. PL011), and so it can avoid the ambiguity around HAL_UARTLineStatus.
  s/main - Fix CloseMessages to take into account the possibility of the workspace pointer being null
Admin:
  Tested on Raspberry Pi 1


Version 0.25, 4.8.2.15. Tagged as 'DualSerial-0_25-4_8_2_15'
@
text
@d763 3
a765 3
                CMP     r12, #0                                 ; workspace allocated? (+ clear V)
                LDRNE   r0, Flags
                TSTNE   r0, #f_WeHaveMessages                   ; do we have any messages?
@


4.6
log
@Added support for serial ports on device 9, as well as the traditional 10.

Version 0.23. Tagged as 'DualSerial-0_23'
@
text
@d134 1
d136 6
d178 4
d386 2
a387 2
                PullEnv
                ORRS  	pc, lr, #VFlag
d456 2
a457 1
                EXITS
d486 1
a486 1
                MOVNES  pc, lr
d503 1
a503 1
		Pull	"r1,r11,pc",,^
d519 1
a519 1
		MOVS	pc, lr
d528 1
a528 1
                Pull    "r0-r3,pc",,^				; and exit
d531 1
a531 1
                MOVS  	pc, lr
d542 4
a545 6
		CMP	r11, #0
		EXITS	EQ
		MOV	r0, #ModHandReason_Free
		MOV	r2, r11
		SWI	XOS_Module
		EXITS
d615 1
a615 1
		EXIT	VS
a616 1
		EXITS
d626 2
a627 2
		CMP	r11, #0
		EXITS	EQ
d632 1
a632 1
		EXITS	NE
d652 1
a652 1
		EXITS
d663 2
a664 2
		CMP	r11, #0
		EXITS	EQ
d669 1
a669 1
		EXITS	EQ
d673 1
a673 1
                EXITS	EQ
d675 1
a675 1
                MOV     r0, #0
d683 1
a683 1
		EXITS
d702 2
a703 1
		EXITS
d723 2
a724 1
		EXITS
d738 1
a738 1
		EXITS	EQ
d902 1
a902 1
		EXITS
d919 1
a919 1
        	EXITS
d936 1
a936 1
        Pull    "r1-r2, pc",,^
d945 1
a945 1
        Pull    "r1-r2, pc",,^
d960 1
a960 1
                EXITS   NE
d969 1
a969 1
                EXITS
d978 1
a978 1
                EXITS   EQ
d985 1
a985 1
                EXITS
d1006 1
a1006 2
                PullEnv EQ
                ORREQS  pc, lr, #VFlag
d1017 2
d1023 1
a1023 1
; This bit of appartently harmless code will bind a messages file into the code
d1030 1
a1030 1
	ResourceFile Resources.<Locale>.Messages, Resources.Serial.Messages
@


4.6.2.1
log
@  32-bit compatible.
Detail:
  Hopefully, this is fully 32-bit compatible.  If not, the area of concern
    is likely to be interrupts.s.  The DeviceFS entry point dispatcher has
    been modified to preserve all flags except V across the entry point to
    relieve each routine of the burden of doing this.
Admin:
  Not tested, hence imported only onto the branch.

Version 0.24, 4.7.2.1. Tagged as 'DualSerial-0_24-4_7_2_1'
@
text
@a133 1
 [ :LNOT: No32bitCode
a134 6
                & 0
                & 0
                & 0
                & 0
                & moduleflags - module          ; => module flags
 ]
a170 4
 [ :LNOT: No32bitCode
moduleflags     DCD ModuleFlag_32bit
 ]

d375 2
a376 2
                SETV
                EXIT
d445 1
a445 2
                CLRV
                EXIT
d474 1
a474 1
                MOVNE   pc, lr
d491 1
a491 1
		Pull	"r1,r11,pc"
d507 1
a507 1
		MOV	pc, lr
d516 1
a516 1
                Pull    "r0-r3,pc"				; and exit
d519 1
a519 1
                MOV  	pc, lr
d530 6
a535 4
		MOVS    r2, r11
		MOVNE	r0, #ModHandReason_Free
		SWINE	XOS_Module
		EXIT
d605 1
a605 1
		EXIT
d607 1
d617 2
a618 2
		CMP	r11, #0                         ; clears V
		EXIT	EQ
d623 1
a623 1
		EXIT	NE
d643 1
a643 1
		EXIT
d654 2
a655 2
		CMP	r11, #0                         ; clears V
		EXIT	EQ
d660 1
a660 1
		EXIT	EQ
d664 1
a664 1
                EXIT	EQ
d666 1
a666 1
                SUBS    r0, r0, r0                      ; R0=0, V cleared
d674 1
a674 1
		EXIT
d693 1
a693 2
                CLRV
		EXIT
d713 1
a713 2
                CLRV
		EXIT
d727 1
a727 1
		EXIT	EQ
d891 1
a891 1
		EXIT
d908 1
a908 1
        	EXIT
d925 1
a925 1
        Pull    "r1-r2, pc"
d934 1
a934 1
        Pull    "r1-r2, pc"
d949 1
a949 1
                EXIT    NE
d958 1
a958 1
                EXIT
d967 1
a967 1
                EXIT    EQ
d974 1
a974 1
                EXIT
d995 2
a996 1
                BEQ     make_error_exit
a1006 2
make_error_exit
                SETV
d1011 1
a1011 1
; This bit of apparently harmless code will bind a messages file into the code
d1018 1
a1018 1
	ResourceFile LocalRes:Messages, Resources.Serial.Messages
@


4.5
log
@Service call table added.

Version 0.22. Tagged as 'DualSerial-0_22'
@
text
@d55 1
d273 9
a281 1
init            ENTRY	"r0-r11"
d300 1
d313 15
a346 1
                STRVS   r0, [sp]
a354 1
                STRVS   r0, [sp]
d370 1
d373 1
d377 13
@


4.4
log
@Daytona branch merged.

Version 0.18. Tagged as 'DualSerial-0_18'
@
text
@d417 12
d430 1
d438 1
a438 1
                LDR     wp, [r12]
@


4.3
log
@Makefile changed to use LocalRes$Path.
Changed to use srccommit.
Spinner branch merged.

Version 0.17. Tagged as 'DualSerial-0_17'
@
text
@a66 1
 [ debug
a68 1
 ]
d161 1
a161 1
serial_help    = "*SerialInfo will display internal statistics", 13
d164 1
a164 1
serial_test_help   = "*SerialTest will test each serial port using loopback", 13
d182 1
a182 1
device_name1    = "serial1", 0
d184 1
a184 1
device_name2	= "serial2", 0
d219 1
a219 1
serial_handshake_dtr    = "rtr/dsr",0
d366 2
d372 7
a378 4

		LDREQ	r11, Port2
		LDREQ	r0, InputStream
		CMPEQ	r0, #0
d382 1
a382 1
		BEQ	%10
d385 1
d389 1
a389 1
10
a513 1
 [ debug
d516 1
@


4.2
log
@Version Spin_merge taken
@
text
@d92 1
d139 4
d144 1
a144 3
help            = "Serial", 9, 9, "$VString ($Date) (Debug on)", 0
 |
help            = "Serial", 9, 9, "$VString ($Date)", 0
d146 1
d154 7
d165 5
d244 1
d520 1
d644 20
d826 6
@


4.2.2.1
log
@Rightio, we'll try for a real log this time...

Files deleted due to CVSs incompetency in replacing them with newer
differently named ones. Next, you'll see the new files arrive, with
a more descriptive log of what & why.
@
text
@@


4.2.6.1
log
@Made buffer threshold changes take effect immediately instead of next time a stream is opened.
@
text
@d67 1
d70 1
a91 1
BufferOverrun		# 4
a149 7

		= "SerialTest", 0
		ALIGN
		DCD	serial_test_command -module
		DCD	0
		DCD	serial_test_syntax -module
		DCD	serial_test_help -module
d152 1
a152 1
serial_help    = "*SerialInfo displays internal statistics on each available serial port", 13
a153 5

serial_test_help   = "*SerialTest tests each serial port using loopback", 13
serial_test_syntax = "Syntax: *SerialTest", 0


d168 1
a168 1
device_name1    = "Serial1", 0
d170 1
a170 1
device_name2	= "Serial2", 0
d205 1
a205 1
serial_handshake_dtr    = "dtr/dsr",0
a227 1
serial_buffer_overrun   = "  Buffer Overrun  : ",0
a350 2
		CMP	r11, #0
		BEQ	%10
d355 2
a356 5
		BNE	%20
10
		LDR	r11, Port2
		CMP	r11, #0
		BEQ	%30
a364 1
20
d368 1
a368 1
30
a502 1
		STR	r0, BufferOverrun
a625 20
; handle the command *SerialTest
;
serial_test_command ENTRY "r0-r3"

                LDR     wp, [r12]   		; wp -> workspace

		ADRL	r0, device_name1
		LDR	r11, Port1
		BL	hardware_test

		ADRL	r0, device_name2
		LDR	r11, Port2
		BL	hardware_test

		EXITS

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
a787 6
		BL	show_integer
		SWI	XOS_NewLine
; buffer overrun
		ADRL	r0, serial_buffer_overrun
		SWI	XOS_Write0
		LDR	r0, BufferOverrun
@


4.2.6.2
log
@Fixed problem killing module when two serial ports.  Added IOCtl to flush a
buffer.
@
text
@d374 2
a375 2
		LDR	r0, InputStream
		CMP	r0, #0
d379 1
a379 1
		BEQ	%30
d511 1
a513 1
 [ debug
@


4.1
log
@Initial revision
@
text
@a91 1
BufferOverrun		# 4
a149 7

		= "SerialTest", 0
		ALIGN
		DCD	serial_test_command -module
		DCD	0
		DCD	serial_test_syntax -module
		DCD	serial_test_help -module
a153 5

serial_test_help   = "*SerialTest will test each serial port using loopback", 13
serial_test_syntax = "Syntax: *SerialTest", 0


a227 1
serial_buffer_overrun   = "  Buffer Overrun  : ",0
a502 1
		STR	r0, BufferOverrun
a625 20
; handle the command *SerialTest
;
serial_test_command ENTRY "r0-r3"

                LDR     wp, [r12]   		; wp -> workspace

		ADRL	r0, device_name1
		LDR	r11, Port1
		BL	hardware_test

		ADRL	r0, device_name2
		LDR	r11, Port2
		BL	hardware_test

		EXITS

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
a787 6
		BL	show_integer
		SWI	XOS_NewLine
; buffer overrun
		ADRL	r0, serial_buffer_overrun
		SWI	XOS_Write0
		LDR	r0, BufferOverrun
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d92 1
d151 7
d162 5
d241 1
d517 1
d641 20
d823 6
@


4.1.7.2
log
@Imported from SrcFiler
@
text
@a91 1
BufferOverrun		# 4
a149 7

		= "SerialTest", 0
		ALIGN
		DCD	serial_test_command -module
		DCD	0
		DCD	serial_test_syntax -module
		DCD	serial_test_help -module
a153 5

serial_test_help   = "*SerialTest will test each serial port using loopback", 13
serial_test_syntax = "Syntax: *SerialTest", 0


a227 1
serial_buffer_overrun   = "  Buffer Overrun  : ",0
a502 1
		STR	r0, BufferOverrun
a625 20
; handle the command *SerialTest
;
serial_test_command ENTRY "r0-r3"

                LDR     wp, [r12]   		; wp -> workspace

		ADRL	r0, device_name1
		LDR	r11, Port1
		BL	hardware_test

		ADRL	r0, device_name2
		LDR	r11, Port2
		BL	hardware_test

		EXITS

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
a787 6
		BL	show_integer
		SWI	XOS_NewLine
; buffer overrun
		ADRL	r0, serial_buffer_overrun
		SWI	XOS_Write0
		LDR	r0, BufferOverrun
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@

head	4.7;
access;
symbols
	DualSerial-0_29:4.7
	DualSerial-0_25-4_8_2_10:4.6.2.3
	RO_5_07:4.6.2.3
	DualSerial-0_28:4.7
	DualSerial-0_25-4_8_2_9:4.6.2.3
	DualSerial-0_25-4_8_2_8:4.6.2.3
	DualSerial-0_25-4_8_2_7:4.6.2.3
	DualSerial-0_25-4_8_2_6:4.6.2.2
	DualSerial-0_27:4.7
	DualSerial-0_25-4_8_2_5:4.6.2.2
	DualSerial-0_25-4_8_2_4:4.6.2.2
	DualSerial-0_25-4_8_2_3:4.6.2.1
	DualSerial-0_25-4_8_2_2:4.6.2.1
	DualSerial-0_25-4_8_2_1:4.6
	HAL:4.6.0.2
	DualSerial-0_26:4.7
	DualSerial-0_25:4.6
	kbracey_32bit_merge:4.5.2.3
	DualSerial-0_24-4_7_2_4:4.5.2.3
	DualSerial-0_24-4_7_2_3:4.5.2.2
	DualSerial-0_24-4_7_2_2:4.5.2.1
	dellis_autobuild_BaseSW:4.5
	DualSerial-0_24-4_7_2_1:4.5.2.1
	kbracey_32bit:4.5.0.2
	DualSerial-0_24:4.5
	sbrodie_sedwards_16Mar2000:4.4
	DualSerial-0_23:4.4
	dcotton_autobuild_BaseSW:4.7
	DualSerial-0_22:4.4
	DualSerial-0_21:4.4
	DualSerial-0_18:4.4
	Daytona_merge:4.2.6.2
	DualSerial-0_17:4.3
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spinner_B10:4.1.7.2
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.2
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	ARTtmp:4.1.7.2.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.2
	MergeFiles:4.1.7.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1;
locks; strict;
comment	@# @;


4.7
date	2001.03.16.15.55.52;	author sbrodie;	state Exp;
branches;
next	4.6;

4.6
date	2001.01.09.14.05.12;	author sbrodie;	state Exp;
branches
	4.6.2.1;
next	4.5;

4.5
date	2000.07.05.16.14.37;	author nicke;	state Exp;
branches
	4.5.2.1;
next	4.4;

4.4
date	98.09.29.13.30.03;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.09.21.14.21.51;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.22.13.38.46;	author nturton;	state Exp;
branches
	4.2.2.1
	4.2.6.1;
next	4.1;

4.1
date	96.11.21.12.06.27;	author nturton;	state Exp;
branches
	4.1.5.1
	4.1.7.1;
next	;

4.6.2.1
date	2001.03.20.13.13.47;	author kbracey;	state Exp;
branches;
next	4.6.2.2;

4.6.2.2
date	2001.03.30.13.19.18;	author dellis;	state Exp;
branches;
next	4.6.2.3;

4.6.2.3
date	2003.03.31.09.28.07;	author rsprowson;	state Exp;
branches;
next	4.6.2.4;

4.6.2.4
date	2012.06.04.23.36.13;	author jlee;	state dead;
branches;
next	;
commitid	lqDFJl0aX8rOLr7w;

4.5.2.1
date	2000.07.13.15.23.19;	author sbrodie;	state Exp;
branches;
next	4.5.2.2;

4.5.2.2
date	2000.10.10.16.54.23;	author sbrodie;	state Exp;
branches;
next	4.5.2.3;

4.5.2.3
date	2001.01.09.14.03.20;	author sbrodie;	state Exp;
branches;
next	;

4.2.2.1
date	98.07.21.13.36.39;	author wturner;	state dead;
branches;
next	;

4.2.6.1
date	97.07.07.13.27.22;	author blaughto;	state Exp;
branches;
next	4.2.6.2;

4.2.6.2
date	97.07.11.07.12.16;	author blaughto;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.06.27;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.45.36;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.01.29.15.06.02;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.7
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.26. Tagged as 'DualSerial-0_26'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;
; 		Copyright 1996 Acorn Network Computing
;
;  This material is the confidential trade secret and proprietary
;  information of Acorn Network Computing. It may not be reproduced,
;  used, sold, or transferred to any third party without the prior
;  written consent of Acorn Network Computing. All rights reserved.
;
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: handle_device_call
;

;
; DeviceFS will have ensured that V is clear on entry - so we don't need to
; do that.   The return address is now stacked, and the CPSR too for the
; duration of the call.
;

handle_device_call ROUT

                Push    lr
                SavePSR lr
                Push    lr
                JumpAddress lr, device_call_exit, forward       ; load return address
		MOV	r11, r8			; sort out port workspace

                CMP     r0, #(%20-%10)/4	; validate reason code
                ADDCC   pc, pc, r0, LSL #2 	; despatch
		B	%20
10
                B       initialise              ; 0  initialise
                B       finalise                ; 1  finalise
                B       wakeup_tx               ; 2  wake up for TX
                MOV     pc, lr                  ; 3  wake up for RX
                MOV     pc, lr                  ; 4  sleep rx
                MOV     pc, lr                  ; 5  enumerate directory
                B       create_tx_buffer        ; 6  create buffer for TX
                B       create_rx_buffer        ; 7  create buffer for RX
                B       threshold_halt          ; 8  halt - below threshold
                B       threshold_resume	; 9  resume - above threshold
                MOV     pc, lr                  ; 10 end of data
                B       stream_created		; 11 stream created
                MOV     pc, lr
                MOV     pc, lr
		B	ioctl			; 14 IOCtl
20
                Pull    lr
                ORR     lr, lr, #V_bit
                RestPSR lr,,cf
                ADDR    r0, ErrorBlock_Serial_BadDeviceReasonCode
                Pull    lr
                B	make_error

		MakeErrorBlock Serial_BadDeviceReasonCode

device_call_exit
                Pull    lr
                ORRVS   lr, lr, #V_bit
                RestPSR lr,,cf
                NOP
                Pull    pc

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: initialise
;
; in:   r0 = reason code
;       r2 = DeviceFS stream handle
;       r3 = flags for opening the stream : bit 0 - 0 opened for RX, 1 opened
;            for TX
;	r4 = file switch file handle
;       r6 = pointer to special field control block
;	r11 = port workspace
; out:  r2 = internal stream handle
;
; This routine is called as a stream is being opened onto the device by
; DeviceFS. It must store the relevant handles and setup the device.
;
; The special field control block will consist of a number of words each
; corresponding to the field in the device open string in the following order :
;
			^ 0, r6
Baud			# 4		; baud rate
Data			# 4		; data
Stop			# 4		; stop
Parity			# 4		; parity : none=0, even=1, odd=2
Handshake 		# 4		; handshake : none     =0
					;             rts/cts  =1
					;	      xon/xoff =2
					;	      dtr/dsr  =3
BufferSize		# 4		; required size of buffer
BufferThreshold		# 4		; required buffer threshold

;
; If the field is not present, it will be &deaddead

initialise      Entry "r0,r4-r5"
 [ debug
;		DREG	r2, "initialise stream : "
;		DREG	r4, "   fileswitch handle : "
 ]
		LDR	r10, BaseAddress

                TST     r3, #1                  ; tx or rx stream ?
                STREQ   r2, InputStream		; stash input handle
		STREQ	r4, InputFSHandle
                STRNE   r2, OutputStream 	; stash output handle
		STRNE	r4, OutputFSHandle

		LDR	r4, =&deaddead

; handle baud options
		LDR	r0, Baud
		CMP	r0, r4
		BLNE	hardware_set_baud
		BVS	%40

; handle data options
		LDR	r0, Data
		CMP	r0, r4
		BLNE	hardware_set_data
		BVS	%40

; handle stop options
		LDR	r0, Stop
		CMP	r0, r4
		BLNE	hardware_stop_bit

; handle parity options
		LDR	r0, Parity
		CMP	r0, r4
		BLNE	hardware_parity

; handle handshaking options
		LDR	r0, Handshake
		CMP	r0, r4
		BEQ	%10
		LDR	r5, PortFlags
		BIC	r5, r5, #flag_UseRTS:OR:flag_UseXon:OR:flag_UseDTR
		CMP	r0, #1
		ORREQ	r5, r5, #flag_UseRTS
		CMP	r0, #2
		ORREQ	r5, r5, #flag_UseXon
		CMP	r0, #3
		ORREQ	r5, r5, #flag_UseDTR
		STR	r5, PortFlags
10
; handle buffer sizing information
		LDR	r0, BufferSize
		CMP	r0, r4
		BEQ	%20
                TST     r3, #1                  ; tx or rx stream ?
                STREQ   r0, InputBufferSize
                STRNE   r0, OutputBufferSize
20
; handle buffer threshold information
		LDR	r0, BufferThreshold
		CMP	r0, r4
		BEQ	%30
                TST     r3, #1                  ; tx or rx stream ?
                STREQ   r0, InputBufferThreshold
                STRNE   r0, OutputBufferThreshold
                CLRV
30
                EXIT

40
                STR   	r0, [sp]
		EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: finalise
;
; in:   r0 = reason code
;       r2 = device driver stream handle, or 0 for all streams
;
; out:  -
;
; This routine is called when a stream is being closed by DeviceFS. When
; received then we should halt the relevant transmission type until the stream
; is re-opened.

finalise        Entry	"r0-r3"
 [ debug
;		DREG	r2, "finalise : "
 ]
		MOV	r1, #0
		MOV	r3, #-1			; for nulling stream handles
		LDR	r0, InputStream		; is input stream being closed
		TEQ	r0, r2
		TEQNE	r2, #0			; or all streams
		STREQ	r1, InputStream		; null the stream
		STREQ	r3, InputBufferPrivId
		STREQ	r1, InputBuffer
		LDR	r0, OutputStream	; is output stream being closed
		TEQ	r0, r2
		TEQNE	r2, #0			; or all streams
		STREQ	r1, OutputStream	; null the stream
		STREQ	r3, OutputBufferPrivId
		STREQ	r1, OutputBuffer
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: wakeup_tx
;
; in:   r0 = reason code
;	r2 = device driver stream handle
;
; out:  r0  = 0 if driver wishes to remain dormant, else preserved
;
; This routine is called when data is ready to be transmitted. Data should
; start being passed to the device

; Must not corrupt Z

wakeup_tx       Entry	"r3,r10"
 [ debug
;		DLINE	"wakeup_tx"
 ]
		LDR	r3, PortFlags
		BIC	r3, r3, #flag_TxDormant
		STR	r3, PortFlags

		LDR	r10, BaseAddress
; disable tx interrupts
                LDRB    r3, UART_interrupt_enable   ; interrupt enable register
                BIC     r3, r3, #IER_transmit_empty
                STRB    r3, UART_interrupt_enable
; and now enable them
                ORR     r3, r3, #IER_transmit_empty ; enable tx empty ints
                STRB    r3, UART_interrupt_enable   ; store back in register

 		EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: create_tx_buffer
;
; in:   r0  = reason code
;       r2  = device driver stream handle
;       r3  = suggested flags for buffer
;       r4  = suggested size of buffer
;       r5  = suggested handle for buffer
;       r6  = suggested threshold value
;
; out:  r3  = modified flags
;       r4  = modified buffer size
;       r5  = suggested buffer handle
;       r6  = if -1 on exit then no threshold, else set to specified value
;
; This routine is called before the buffer is actually created, it allows the
; device to change the values (ie. buffer size) and then return.  r5 should
; contain a unique buffer handle.

create_tx_buffer Entry "r0"
 [ debug
;		DLINE	"create tx buffer"
 ]
; look to see if we wish to change the default size
		LDR	r0, OutputBufferSize
		CMP	r0, #0
		MOVNE	r4, r0
		STREQ	r4, OutputBufferSize

; and now the default threshold
		LDR	r0, OutputBufferThreshold
		CMP	r0, #0                       ; clears V
		MOVNE	r6, r0
		STREQ	r6, OutputBufferThreshold

 		EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: create_rx_buffer
;
; in:   r0  = reason code
;       r2  = device driver stream handle
;       r3  = suggested flags for buffer
;       r4  = suggested size of buffer
;       r5  = suggested handle for buffer
;       r6  = suggested threshold value
;
; out:  r3  = modified flags
;       r4  = modified buffer size
;       r5  = suggested buffer handle
;       r6  = if -1 on exit then no threshold, else set to specified value
;
; This routine is called before the buffer is actually create, it allows the
; device to change the values (ie. buffer size) and then return.  r5 should
; contain a unique buffer handle.
;
create_rx_buffer Entry
 [ debug
;		DLINE	"create rx buffer"
 ]
; look to see if we wish to change the default size
		LDR	r0, InputBufferSize
		CMP	r0, #0
		MOVNE	r4, r0
		STREQ	r4, InputBufferSize

; and now the default threshold
		LDR	r0, InputBufferThreshold
		CMP	r0, #0                       ; clears V
		MOVNE	r6, r0
		STREQ	r6, InputBufferThreshold

 		EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: threshold_halt
;
; in:   r0 = reason code
;       r2 = device driver stream handle
;
; out:  -
;
; This routine is called when the free space in the buffer has dropped below
; the specified threshold. Data receipt should be halted by asserting the
; RTS line and wait until resume point is called.
;
; We have registered for halt/resume information on both streams but only
; require information here for the input buffer so check stream handles.

threshold_halt  Entry "r0-r1"
 [ debug
;		DLINE	"threshold halt"
 [ border_handshake
		SetColour blue
 ]
 ]
; check stream handle
		LDR	r1, InputStream
		TEQ	r2, r1
		EXIT	NE

; are we doing handshaking ?
		LDR	r1, PortFlags
		TST	r1, #flag_UseRTS:OR:flag_UseXon:OR:flag_UseDTR
		EXIT	EQ

		ORR	r1, r1, #flag_RxThresholded
		STR	r1, PortFlags

; set control flags
		TST	r1, #flag_UseXon
		ORRNE	r1, r1, #flag_TxXoff		; send an xoff
		STRNE	r1, PortFlags
		BLNE	wakeup_tx                       ; preserves Z
		EXIT	NE

		PHPSEI	lr, r0			; disable interrupts
		LDRB	r0, ControlLines
		TST	r1, #flag_UseRTS
		BICNE 	r0, r0, #ctrl_line_rts
		TST	r1, #flag_UseDTR
		BICNE	r0, r0, #ctrl_line_dtr
		STRB	r0, ControlLines
		PLP	lr			; enable interrupts

		BL	hardware_ctrl_lines

                CLRV
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: threshold_resume
;
; in:   r0 = reason code
;       r2 = device driver stream handle
;
; out:  -
;
; This routine is called when the free space in the buffer has risen above the
; specified threshold.

threshold_resume Entry	"r0-r1"
 [ debug
;		DLINE	"threshold resume"
 [ border_handshake
		SetColour off
 ]
 ]
; check stream handle
		LDR	r1, InputStream
		TEQ	r2, r1
		EXIT	NE

; are we doing handshaking ?
		LDR	r1, PortFlags
		TST	r1, #flag_UseRTS:OR:flag_UseXon:OR:flag_UseDTR
		EXIT	EQ

		BIC	r1, r1, #flag_RxThresholded
		STR	r1, PortFlags

; set control flags
		TST	r1, #flag_UseXon
		ORRNE	r1, r1, #flag_TxXon	; send an xon
		STRNE	r1, PortFlags
		BLNE	wakeup_tx                       ; preserves Z
		EXIT	NE

		PHPSEI	lr, r0			; disable interrupts
		LDRB	r0, ControlLines
		TST	r1, #flag_UseRTS
		ORRNE 	r0, r0, #ctrl_line_rts
		TST	r1, #flag_UseDTR
		ORRNE	r0, r0, #ctrl_line_dtr
		STRB	r0, ControlLines
		PLP	lr			; enable interrupts

		BL	hardware_ctrl_lines

                CLRV
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: stream_created
;
; in:   r0 = reason code
;       r2 = device driver stream handle
;       r3 = buffer handle
;
; out:  -
;
; This routine is called after the stream has been created, it gives me a chance
; to setup the device correctly and start transmission etc, etc...
;

stream_created  Entry	"r0-r4"
 [ debug
;		DREG	r2, "stream created : "
 ]
		MOV	r4, r2			; save stream handle
; get buffer details
		MOV	r0, r3			; need buffer handle
		SWI	XBuffer_InternalInfo
                STRVS  	r0, [sp]
		EXIT	VS
		STR	r1, BuffManService
		STR	r2, BuffManWkSpace

; which buffer are we dealing with
                LDR     r1, InputStream
                TEQ     r1, r4

		STREQ	r0, InputBufferPrivId
                STREQ   r3, InputBuffer
		EXIT	EQ

		STR	r0, OutputBufferPrivId
                STR	r3, OutputBuffer
; now sort out handshaking, need to re-assert lines
		LDR	r0, PortFlags
		LDR	r1, ControlLines
		TST	r0, #flag_UseRTS
		ORRNE	r1, r1, #ctrl_line_rts
		TST	r0, #flag_UseDTR
		ORRNE	r1, r1, #ctrl_line_dtr
		STR	r1, ControlLines
		BL	hardware_ctrl_lines

                CLRV
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_read  	* 1:SHL:30
ioctl_write 	* 1:SHL:31

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioctl
;
; in:   r0 = devicefs reason code
;	r2 = device driver stream handle
;       r3 -> ioctl control block
;
; where control block is
;	word one - bits 0-15  : reason code
; 		   bits 16-29 : group code
;		   bit  30    : read
;		   bit  31    : write
;	word two - data
;
; This is the ioctl entry point.

ioctl		ROUT

		LDR	r0, [r3, #0]		; load reason code

; mask off top 16 bits of r0 to obtain reason code
		MOV	r0, r0, LSL #16
		MOV	r0, r0, LSR #16

                CMP     r0, #(%20-%10)/4	; validate reason code
                ADDCC   pc, pc, r0, LSL #2 	; despatch
		B	%20
10
		MOV	pc, lr			; 0 nothing
                B       ioctl_baud		; 1 set baud rate
                B       ioctl_data		; 2 set data format
		B	ioctl_handshake		; 3 set handshaking
		B	ioctl_buffer_size   	; 4 set buffer size
		B	ioctl_buffer_thres	; 5 set buffer threshold
		B	ioctl_ctrl_lines	; 6 set control lines
		B	ioctl_fifo_trig		; 7 set fifo threshold
		B	ioctl_read_bauds	; 8 return number of bauds
		B	ioctl_read_baud		; 9 return baud rate
		B	ioctl_flush_buffer	; 10 flush buffer
20
                ADDR    r0, ErrorBlock_Serial_BadIOCtlReasonCode
                B	make_error

		MakeErrorBlock Serial_BadIOCtlReasonCode
		MakeErrorBlock Serial_BadIOCtlParameter

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_baud	Entry 	"r0-r4"

		LDR	r4, [r3, #0]		; load flags
		LDR	r0, [r3, #4]		; load data

; are we writing the baud
		TST	r4, #ioctl_write
		BEQ	%10
		BL	hardware_set_baud
10
; do we wish to read current
		TST	r4, #ioctl_read
		LDRNE	r0, BaudRate
		STRNE	r0, [r3, #4]

                CLRV
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_data	Entry	"r0-r4"

		LDR	r4, [r3, #0]		; load flags
		LDR	r1, [r3, #4]		; load data

; are we writing the data
		TST	r4, #ioctl_write
		BEQ	%10

; handle data options
		AND	r0, r1, #&ff
		BL	hardware_set_data

; handle stop options
		MOV	r0, r1, LSR #8
		AND	r0, r0, #&ff
		BL	hardware_stop_bit

; handle parity options
		MOV	r0, r1, LSR #16
		AND	r0, r0, #&ff
		BL	hardware_parity

10
; do we wish to read current
		TST	r4, #ioctl_read
		LDRNE	r0, DataFormat
		STRNE	r0, [r3, #4]

                CLRV
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_handshake Entry "r0-r5"

		LDR	r5, [r3, #0]		; load flags
		LDR	r1, [r3, #4]		; load data

; are we writing the data
		TST	r5, #ioctl_write
		BEQ	%10

		PHPSEI	lr, r4			; disable interrupts
		LDR	r4, PortFlags
		BIC	r4, r4, #flag_UseRTS:OR:flag_UseXon:OR:flag_UseDTR
		CMP	r1, #1
		ORREQ	r4, r4, #flag_UseRTS
		CMP	r1, #2
		ORREQ	r4, r4, #flag_UseXon
		CMP	r1, #3
		ORREQ	r4, r4, #flag_UseDTR
		STR	r4, PortFlags
		PLP	lr			; enable interrupts
		CLRV
10
; do we wish to read current
		SUBS	r0, r0, r0              ; R0=0, clears V
		TST	r5, #ioctl_read
		EXIT	EQ

		LDR	r4, PortFlags
		TST	r4, #flag_UseRTS
		MOVNE	r0, #1
		TST	r4, #flag_UseXon
		MOVNE	r0, #2
		TST	r4, #flag_UseDTR
		MOVNE	r0, #3
		STR	r0, [r3, #4]

                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_buffer_size Entry "r0-r4"

		LDR	r4, [r3, #0]		; load flags
		LDR	r1, [r3, #4]		; load data

		LDR	r0, InputStream

; are we writing the data
		TST	r4, #ioctl_write
		BEQ	%10

		TEQ	r0, r2
		STREQ	r1, InputBufferSize
		STRNE	r1, OutputBufferSize
10
; do we wish to read current
		TST	r4, #ioctl_read
		EXIT	EQ

		TEQ	r0, r2
		LDREQ	r1, InputBufferSize
		LDRNE	r1, OutputBufferSize
		STR	r1, [r3, #4]		; write back to data block

		EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_buffer_thres Entry "r0-r5"

		LDR	r4, [r3, #0]		; load flags
		LDR	r1, [r3, #4]		; load data

		LDR	r5, InputStream

; are we writing the data
		TST	r4, #ioctl_write
		BEQ	%10

		TEQ	r5, r2
		LDREQ	r0, InputBuffer
		LDRNE	r0, OutputBuffer
		SWI	XBuffer_Threshold	; set buffer threshold
		EXIT	VS			; return if it didn't work

; store new value in workspace if call succeeded
		STREQ	r1, InputBufferThreshold
		STRNE	r1, OutputBufferThreshold

10
; do we wish to read current
		TST	r4, #ioctl_read
		EXIT	EQ

		TEQ	r5, r2
		LDREQ	r1, InputBufferThreshold
		LDRNE	r1, OutputBufferThreshold
		STR	r1, [r3, #4]		; write back to data block

		EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_ctrl_lines Entry "r0-r4"

		LDR	r4, [r3, #0]		; load flags
		LDR	r1, [r3, #4]		; load data

		LDRB	r0, ControlLines
; are we writing the data
		TST	r4, #ioctl_write
		BEQ	%10

		PHPSEI				; disable interrupts
		TST	r1, #1:SHL:0		; check dtr
		ORRNE	r0, r0, #ctrl_line_dtr
		BICEQ	r0, r0, #ctrl_line_dtr
		TST	r1, #1:SHL:1 		; check rts
		ORRNE	r0, r0, #ctrl_line_rts
		BICEQ	r0, r0, #ctrl_line_rts
		STRB	r0, ControlLines
		PLP				; enable interrupts
10
		BL	hardware_ctrl_lines
                CLRV

; do we wish to read current
		TST	r4, #ioctl_read
		EXIT	EQ

		LDRB	r0, ControlLines
		MOV	r1, #0
		TST	r0, #ctrl_line_dtr
		ORRNE	r1, r1, #1:SHL:0
		TST	r0, #ctrl_line_rts
		ORRNE	r1, r1, #1:SHL:1
		TST	r0, #ctrl_line_cts
		ORRNE	r1, r1, #1:SHL:16
		TST	r0, #ctrl_line_dsr
		ORRNE	r1, r1, #1:SHL:17
		TST	r0, #ctrl_line_ri
		ORRNE	r1, r1, #1:SHL:18
		TST	r0, #ctrl_line_dcd
		ORRNE	r1, r1, #1:SHL:19

		LDR	r0, PortFlags
		TST	r0, #flag_FIFOsPresent
		ORRNE	r1, r1, #1:SHL:20

		STR	r1, [r3, #4]		; write back to data block

		EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_fifo_trig Entry "r0-r1"

		LDR	r1, [r3, #0]		; load flags

; are we writing the data
		TST	r1, #ioctl_write
		BEQ	%10

		LDR	r0, [r3, #4]		; load data
		BL	hardware_set_fifo_trigger
		CLRV
10
; do we wish to read current
		TST	r1, #ioctl_read
		EXIT	EQ

		LDRB	r0, FIFOTrigger
		STR	r0, [r3, #4]		; write back to data block

		EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_read_bauds Entry "r0-r3"

		ADRL	r1, baud_table
		ADRL	r2, baud_table_end

		SUB	r0, r2, r1
		MOV	r0, r0, LSR #3

		STR	r0, [r3, #4]		; store data

		EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_read_baud	Entry "r0-r5"

		LDR	r4, [r3, #4]		; load data
; calc number of bauds again
 		ADRL	r1, baud_table
		ADRL	r2, baud_table_end
		SUB	r5, r2, r1
		MOV	r5, r5, LSR #3
; check for invalid index values
		MOV	r0, #0
		CMP	r4, #0
		BLT	%10
		CMP	r4, r5
		BGE	%10

; calc address of baud rate
		MOV	r4, r4, LSL #3
		ADD	r1, r1, r4
		LDR	r0, [r1]
10
		STR	r0, [r3, #4]		; store data

                CLRV
		EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_flush_buffer Entry "r0-r3"

		LDR	r1, [r3, #0]		; load flags

		LDR	r3, InputStream

; are we writing?
		TST	r1, #ioctl_write
		BEQ	%F10

		TEQ	r2, r3
		LDREQ	r1, InputBufferPrivId
		LDRNE	r1, OutputBufferPrivId

; check for valid internal buffer id
		CMP	r1, #-1
		BEQ	%F10

		MOV	r0, #BufferReason_PurgeBuffer
		CallBuffMan

; reading returns undefined value in data field of ioctl block
10
                CLRV
		EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		END
@


4.6
log
@  Merge of 32-bit branch.
Detail:
  This version represents the merge of the 32-bit conversion of the DualSerial
    module.
Admin:
  This module has received a modest amount of testing, however, it has not
    been exhaustively tested.  Projects taking this version should be careful
    of it as it may contain bugs.

Version 0.25. Tagged as 'DualSerial-0_25'
@
text
@d113 1
a113 1
initialise      ENTRY "r0,r4-r5"
d238 1
a238 1
wakeup_tx       ENTRY	"r3,r10"
d279 1
a279 1
create_tx_buffer ENTRY "r0"
d320 1
a320 1
create_rx_buffer ENTRY
d356 1
a356 1
threshold_halt  ENTRY "r0-r1"
d411 1
a411 1
threshold_resume ENTRY	"r0-r1"
d468 1
a468 1
stream_created  ENTRY	"r0-r4"
d558 1
a558 1
ioctl_baud	ENTRY 	"r0-r4"
d580 1
a580 1
ioctl_data	ENTRY	"r0-r4"
d616 1
a616 1
ioctl_handshake ENTRY "r0-r5"
d658 1
a658 1
ioctl_buffer_size ENTRY "r0-r4"
d688 1
a688 1
ioctl_buffer_thres ENTRY "r0-r5"
d725 1
a725 1
ioctl_ctrl_lines ENTRY "r0-r4"
d779 1
a779 1
ioctl_fifo_trig ENTRY "r0-r1"
d804 1
a804 1
ioctl_read_bauds ENTRY "r0-r3"
d820 1
a820 1
ioctl_read_baud	ENTRY "r0-r5"
d849 1
a849 1
ioctl_flush_buffer ENTRY "r0-r3"
@


4.6.2.1
log
@Second attempt to check this in.

Version 0.25, 4.8.2.2. Tagged as 'DualSerial-0_25-4_8_2_2'
@
text
@d41 2
d89 1
d113 1
a113 1
initialise      ENTRY "r0,r4-r5,r9"
d118 1
a118 1
		LDR	r9, HAL_StaticBase
d238 1
a238 1
wakeup_tx       ENTRY	"r0-r3,r9"
d246 1
a246 1
		LDR	r9, HAL_StaticBase
d248 3
a250 3
                MOV     r1, #0
                MVN     r2, #IER_transmit_empty
                CallHAL HAL_UARTInterruptEnable
d252 2
a253 3
                MOV     r1, #IER_transmit_empty
                MVN     r2, #IER_transmit_empty
                CallHAL HAL_UARTInterruptEnable
d356 1
a356 1
threshold_halt  ENTRY "r0-r1,r9"
a367 1
                LDR     r9, HAL_StaticBase
d411 1
a411 1
threshold_resume ENTRY	"r0-r1,r9"
a417 2
                LDR     r9, HAL_StaticBase

d468 1
a468 1
stream_created  ENTRY	"r0-r4,r9"
a471 2
                LDR     r9, HAL_StaticBase

d558 1
a558 3
ioctl_baud	ENTRY 	"r0-r4,r9"

                LDR     r9, HAL_StaticBase
d570 2
a571 5
                BEQ     %20

                MOV     r4, r3
                MOV     r1, #-1
                CallHAL HAL_UARTRate
a572 2
                STR     r0, [r4, #4]
20
d580 1
a580 1
ioctl_data	ENTRY	"r0-r4, r9"
a581 1
                LDR     r9, HAL_StaticBase
d725 1
a725 3
ioctl_ctrl_lines ENTRY "r0-r4,r9"

                LDR     r9, HAL_StaticBase
d779 1
a779 3
ioctl_fifo_trig ENTRY "r0-r1,r9"

                LDR     r9, HAL_StaticBase
d806 7
a812 8
    ! 0, "ioctl_read_bauds not implemented"
;		ADRL	r1, baud_table
;		ADRL	r2, baud_table_end
;
;		SUB	r0, r2, r1
;		MOV	r0, r0, LSR #3
;
;		STR	r0, [r3, #4]		; store data
d822 19
a840 21
    ! 0, "ioctl_read_baud not implemented"

;		LDR	r4, [r3, #4]		; load data
;; calc number of bauds again
; 		ADRL	r1, baud_table
;		ADRL	r2, baud_table_end
;		SUB	r5, r2, r1
;		MOV	r5, r5, LSR #3
;; check for invalid index values
;		MOV	r0, #0
;		CMP	r4, #0
;		BLT	%10
;		CMP	r4, r5
;		BGE	%10
;
;; calc address of baud rate
;		MOV	r4, r4, LSL #3
;		ADD	r1, r1, r4
;		LDR	r0, [r1]
;10
;		STR	r0, [r3, #4]		; store data
@


4.6.2.2
log
@  Baud rate return is even more correct.

Detail:
  IOCtl wasn't dividing the returned value from the HAL by 16.

Admin:
  Assembles, not tested.

Version 0.25, 4.8.2.4. Tagged as 'DualSerial-0_25-4_8_2_4'
@
text
@d577 2
a578 2
                MOV     r4, r3                  ; save r3 over HAL call
                MOV     r1, #-1                 ; read port
a579 1
                MOV     r0, r0, LSR#4           ; call returned baud * 16
@


4.6.2.3
log
@Change to use objasm (the non HAL one already has): fixes report that
it blew messagetrans away when rmkilled.
Change to have a zero in the command table word: fixes report that
serialinfo and serialtest don't do anything,indeed they don't in this
HAL version!

Version 0.25, 4.8.2.7. Tagged as 'DualSerial-0_25-4_8_2_7'
@
text
@d110 1
a110 1
initialise      Entry "r0,r4-r5,r9"
d235 1
a235 1
wakeup_tx       Entry	"r0-r3,r9"
d277 1
a277 1
create_tx_buffer Entry "r0"
d318 1
a318 1
create_rx_buffer Entry
d354 1
a354 1
threshold_halt  Entry "r0-r1,r9"
d410 1
a410 1
threshold_resume Entry	"r0-r1,r9"
d469 1
a469 1
stream_created  Entry	"r0-r4,r9"
d561 1
a561 1
ioctl_baud	Entry 	"r0-r4,r9"
d591 1
a591 1
ioctl_data	Entry	"r0-r4, r9"
d628 1
a628 1
ioctl_handshake Entry "r0-r5"
d670 1
a670 1
ioctl_buffer_size Entry "r0-r4"
d700 1
a700 1
ioctl_buffer_thres Entry "r0-r5"
d737 1
a737 1
ioctl_ctrl_lines Entry "r0-r4,r9"
d793 1
a793 1
ioctl_fifo_trig Entry "r0-r1,r9"
d820 1
a820 1
ioctl_read_bauds Entry "r0-r3"
d837 1
a837 1
ioctl_read_baud	Entry "r0-r5"
d868 1
a868 1
ioctl_flush_buffer Entry "r0-r3"
@


4.6.2.4
log
@Rewrite module to add support for acting as a client of SerialSupport
Detail:
  In order to act as a client of SerialSupport, DualSerial needs to support the set of device calls that SerialSupport uses to talk to the serial driver.
  This set of device calls operates at a lower level than the IOCtl interface which DualSerial already supports.
  Therefore simply adding the new device call interface ontop of DualSerial (or modifying SerialSupport to add IOCtl support) would have been a risky venture, due to the many complexities hidden in the Serial module sources.
  So to reduce the amount of risk inherent in the change, I've instead taken the Serial module, stripped out 6551 support, rewritten the 710 interface to use HAL calls, and then bolted the IOCtl interface on top.
  This should ensure the SerialSupport/OS_SerialOp interface is identical to that provided by the Serial module, and only the simpler to understand DualSerial/IOCtl interface is the one likely to contain any bugs.
  File changes:
  - Docs/serial.htm - Added a copy of the IOCtl interface docs, from the Ursula branch
  - s/common, s/errors, s/init, s/macros, s/main - New implementation of the module, based around modified Serial sources
  - s/serialhal - The business end of the module, based around s/Serial710 in the Serial sources
  - s/ioctl - New file containing reimplemented IOCtl interface
  - s/devicecall, s/hardware, s/interrupts, s/standalone - Deleted redundant files from old implementation
  - Makefile - Trimmed somewhat redundant comment
  - resources/UK/messages - Added new error messages
Admin:
  Tested in OMAP3 & Tungsten ROMs


Version 0.25, 4.8.2.11. Tagged as 'DualSerial-0_25-4_8_2_11'
@
text
@@


4.5
log
@ioctl_ctrl_lines was only reading the contol lines when writing to them.
Reading would return a copy of the last known state.
Reading now really reads the contol lines so you can do stuff like polling
them or whatever.

Version 0.24. Tagged as 'DualSerial-0_24'
@
text
@d29 6
d37 4
a40 1
                BIC     lr, lr, #VFlag		; clear V flag in link register
d50 3
a52 3
                MOVS	pc, lr                  ; 3  wake up for RX
                MOVS	pc, lr			; 4  sleep rx
                MOVS	pc, lr	                ; 5  enumerate directory
d57 1
a57 1
                MOVS    pc, lr                  ; 10 end of data
d59 2
a60 2
		MOVS	pc, lr
		MOVS	pc, lr
d63 3
d67 1
d71 7
a77 1
                MOVS    pc, lr
d179 1
d181 1
a181 1
                EXITS
d202 1
a202 1
finalise        ENTRY	"r0-r3"
d220 1
a220 1
                EXITS
d236 2
d255 1
a255 1
 		EXITS
d291 1
a291 1
		CMP	r0, #0
d295 1
a295 1
 		EXITS
d332 1
a332 1
		CMP	r0, #0
d336 1
a336 1
 		EXITS
d366 1
a366 1
		EXITS	NE
d371 1
a371 1
		EXITS	EQ
d380 2
a381 2
		BLNE	wakeup_tx
		EXITS	NE
d383 1
a383 1
		PHPSEI				; disable interrupts
d390 1
a390 1
		PLP				; enable interrupts
d394 2
a395 1
                EXITS
d421 1
a421 1
		EXITS	NE
d426 1
a426 1
		EXITS	EQ
d435 2
a436 2
		BLNE	wakeup_tx
		EXITS	NE
d438 1
a438 1
		PHPSEI				; disable interrupts
d445 1
a445 1
		PLP				; enable interrupts
d449 2
a450 1
                EXITS
d487 1
a487 1
		EXITS	EQ
d501 2
a502 1
                EXITS
d538 1
a538 1
		MOVS	pc, lr			; 0 nothing
d573 2
a574 1
                EXITS
d609 2
a610 1
                EXITS
d625 1
a625 1
		PHPSEI				; disable interrupts
d635 2
a636 1
		PLP				; enable interrupts
d639 1
d641 1
a641 1
		EXITS	EQ
a642 1
		MOV	r0, #0
d652 1
a652 1
                EXITS
d675 1
a675 1
		EXITS	EQ
d682 1
a682 1
		EXITS
d712 1
a712 1
		EXITS	EQ
d719 1
a719 1
		EXITS
d746 1
d750 1
a750 1
		EXITS	EQ
d773 1
a773 1
		EXITS
d789 1
d793 1
a793 1
		EXITS	EQ
d798 1
a798 1
		EXITS
d814 1
a814 1
		EXITS
d842 2
a843 1
		EXITS
d872 2
a873 1
		EXITS
@


4.5.2.1
log
@  32-bit compatible.
Detail:
  Hopefully, this is fully 32-bit compatible.  If not, the area of concern
    is likely to be interrupts.s.  The DeviceFS entry point dispatcher has
    been modified to preserve all flags except V across the entry point to
    relieve each routine of the burden of doing this.
Admin:
  Not tested, hence imported only onto the branch.

Version 0.24, 4.7.2.1. Tagged as 'DualSerial-0_24-4_7_2_1'
@
text
@a28 6
;
; DeviceFS will have ensured that V is clear on entry - so we don't need to
; do that.   The return address is now stacked, and the CPSR too for the
; duration of the call.
;

d31 1
a31 4
                Push    lr
                SavePSR lr
                Push    lr
                ADR     lr, device_call_exit
d41 3
a43 3
                MOV     pc, lr                  ; 3  wake up for RX
                MOV     pc, lr                  ; 4  sleep rx
                MOV     pc, lr                  ; 5  enumerate directory
d48 1
a48 1
                MOV     pc, lr                  ; 10 end of data
d50 2
a51 2
                MOV     pc, lr
                MOV     pc, lr
a53 1
                Pull    lr
a54 1
                Pull    lr
d58 1
a58 6

device_call_exit
                Pull    lr
                ORRVS   lr, lr, #V_bit
                RestPSR lr,,f
                Pull    pc
a159 1
                CLRV
d161 1
a161 1
                EXIT
d182 1
a182 1
finalise        Entry	"r0-r3"
d200 1
a200 1
                EXIT
a215 2
; Must not corrupt Z

d233 1
a233 1
 		EXIT
d269 1
a269 1
		CMP	r0, #0                       ; clears V
d273 1
a273 1
 		EXIT
d310 1
a310 1
		CMP	r0, #0                       ; clears V
d314 1
a314 1
 		EXIT
d344 1
a344 1
		EXIT	NE
d349 1
a349 1
		EXIT	EQ
d358 2
a359 2
		BLNE	wakeup_tx                       ; preserves Z
		EXIT	NE
d361 1
a361 1
		PHPSEI	lr, r0			; disable interrupts
d368 1
a368 1
		PLP	lr			; enable interrupts
d372 1
a372 2
                CLRV
                EXIT
d398 1
a398 1
		EXIT	NE
d403 1
a403 1
		EXIT	EQ
d412 2
a413 2
		BLNE	wakeup_tx                       ; preserves Z
		EXIT	NE
d415 1
a415 1
		PHPSEI	lr, r0			; disable interrupts
d422 1
a422 1
		PLP	lr			; enable interrupts
d426 1
a426 2
                CLRV
                EXIT
d463 1
a463 1
		EXIT	EQ
d477 1
a477 2
                CLRV
                EXIT
d513 1
a513 1
		MOV	pc, lr			; 0 nothing
d548 1
a548 2
                CLRV
                EXIT
d583 1
a583 2
                CLRV
                EXIT
d598 1
a598 1
		PHPSEI	lr, r4			; disable interrupts
d608 1
a608 1
		PLP	lr			; enable interrupts
d612 1
a612 1
		EXIT	EQ
d624 1
a624 1
                EXIT
d647 1
a647 1
		EXIT	EQ
d654 1
a654 1
		EXIT
d684 1
a684 1
		EXIT	EQ
d691 1
a691 1
		EXIT
a717 1
                CLRV
d721 1
a721 1
		EXIT	EQ
d744 1
a744 1
		EXIT
a759 1
		CLRV
d763 1
a763 1
		EXIT	EQ
d768 1
a768 1
		EXIT
d784 1
a784 1
		EXIT
d812 1
a812 2
                CLRV
		EXIT
d841 1
a841 2
                CLRV
		EXIT
@


4.5.2.2
log
@  Corrected some flag preservation issues in DeviceFS call handler.
Detail:
  More flags are preserved.
Admin:
  Built.

Version 0.24, 4.7.2.3. Tagged as 'DualSerial-0_24-4_7_2_3'
@
text
@a63 2
                ORR     lr, lr, #V_bit
                RestPSR lr,,cf
d73 1
a73 2
                RestPSR lr,,cf
                NOP
a632 1
		CLRV
a634 1
		SUBS	r0, r0, r0              ; R0=0, clears V
d638 1
@


4.5.2.3
log
@  Changed to use JumpAddress macro when forming return addresses.
Detail:
  26-bit builds of this module would be broken in the absence of this fix.
Admin:
  Believed to have been tested somewhat, but not exhaustively.

Version 0.24, 4.7.2.4. Tagged as 'DualSerial-0_24-4_7_2_4'
@
text
@d40 1
a40 1
                JumpAddress lr, device_call_exit, forward       ; load return address
@


4.4
log
@Daytona branch merged.

Version 0.18. Tagged as 'DualSerial-0_18'
@
text
@d716 2
a718 2
		BL	hardware_ctrl_lines
10
@


4.3
log
@Makefile changed to use LocalRes$Path.
Changed to use srccommit.
Spinner branch merged.

Version 0.17. Tagged as 'DualSerial-0_17'
@
text
@a192 1
 [ debug
a193 1
 ]
a198 1
 [ debug
a199 1
 ]
a461 1
 [ debug
a462 1
 ]
a465 1
 [ debug
a466 1
 ]
d523 1
d660 1
a660 1
ioctl_buffer_thres ENTRY "r0-r4"
d665 1
a665 1
		LDR	r0, InputStream
d671 7
a677 1
		TEQ	r0, r2
d680 1
d686 1
a686 1
		TEQ	r0, r2
d812 29
@


4.2
log
@Version Spin_merge taken
@
text
@d529 2
d767 44
@


4.2.2.1
log
@Rightio, we'll try for a real log this time...

Files deleted due to CVSs incompetency in replacing them with newer
differently named ones. Next, you'll see the new files arrive, with
a more descriptive log of what & why.
@
text
@@


4.2.6.1
log
@Made buffer threshold changes take effect immediately instead of next time a stream is opened.
@
text
@d193 1
d195 1
d201 1
d203 1
d466 1
d468 1
d472 1
d474 1
a528 2
		B	ioctl_read_bauds	; 8 return number of bauds
		B	ioctl_read_baud		; 9 return baud rate
d665 1
a665 1
ioctl_buffer_thres ENTRY "r0-r5"
d670 1
a670 1
		LDR	r5, InputStream
d676 1
a676 7
		TEQ	r5, r2
		LDREQ	r0, InputBuffer
		LDRNE	r0, OutputBuffer
		SWI	XBuffer_Threshold	; set buffer threshold
		EXIT	VS			; return if it didn't work

; store new value in workspace if call succeeded
a678 1

d684 1
a684 1
		TEQ	r5, r2
a764 44

		EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_read_bauds ENTRY "r0-r3"

		ADRL	r1, baud_table
		ADRL	r2, baud_table_end

		SUB	r0, r2, r1
		MOV	r0, r0, LSR #3

		STR	r0, [r3, #4]		; store data

		EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_read_baud	ENTRY "r0-r5"

		LDR	r4, [r3, #4]		; load data
; calc number of bauds again
 		ADRL	r1, baud_table
		ADRL	r2, baud_table_end
		SUB	r5, r2, r1
		MOV	r5, r5, LSR #3
; check for invalid index values
		MOV	r0, #0
		CMP	r4, #0
		BLT	%10
		CMP	r4, r5
		BGE	%10

; calc address of baud rate
		MOV	r4, r4, LSL #3
		ADD	r1, r1, r4
		LDR	r0, [r1]
10
		STR	r0, [r3, #4]		; store data
@


4.2.6.2
log
@Fixed problem killing module when two serial ports.  Added IOCtl to flush a
buffer.
@
text
@a522 1
		B	ioctl_flush_buffer	; 10 flush buffer
a810 29
		EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_flush_buffer ENTRY "r0-r3"

		LDR	r1, [r3, #0]		; load flags

		LDR	r3, InputStream

; are we writing?
		TST	r1, #ioctl_write
		BEQ	%F10

		TEQ	r2, r3
		LDREQ	r1, InputBufferPrivId
		LDRNE	r1, OutputBufferPrivId

; check for valid internal buffer id
		CMP	r1, #-1
		BEQ	%F10

		MOV	r0, #BufferReason_PurgeBuffer
		CallBuffMan

; reading returns undefined value in data field of ioctl block
10
@


4.1
log
@Initial revision
@
text
@a528 2
		B	ioctl_read_bauds	; 8 return number of bauds
		B	ioctl_read_baud		; 9 return baud rate
a764 44

		EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_read_bauds ENTRY "r0-r3"

		ADRL	r1, baud_table
		ADRL	r2, baud_table_end

		SUB	r0, r2, r1
		MOV	r0, r0, LSR #3

		STR	r0, [r3, #4]		; store data

		EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_read_baud	ENTRY "r0-r5"

		LDR	r4, [r3, #4]		; load data
; calc number of bauds again
 		ADRL	r1, baud_table
		ADRL	r2, baud_table_end
		SUB	r5, r2, r1
		MOV	r5, r5, LSR #3
; check for invalid index values
		MOV	r0, #0
		CMP	r4, #0
		BLT	%10
		CMP	r4, r5
		BGE	%10

; calc address of baud rate
		MOV	r4, r4, LSL #3
		ADD	r1, r1, r4
		LDR	r0, [r1]
10
		STR	r0, [r3, #4]		; store data
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d529 2
d767 44
@


4.1.7.2
log
@Imported from SrcFiler
@
text
@a528 2
		B	ioctl_read_bauds	; 8 return number of bauds
		B	ioctl_read_baud		; 9 return baud rate
a764 44

		EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_read_bauds ENTRY "r0-r3"

		ADRL	r1, baud_table
		ADRL	r2, baud_table_end

		SUB	r0, r2, r1
		MOV	r0, r0, LSR #3

		STR	r0, [r3, #4]		; store data

		EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ioctl_read_baud	ENTRY "r0-r5"

		LDR	r4, [r3, #4]		; load data
; calc number of bauds again
 		ADRL	r1, baud_table
		ADRL	r2, baud_table_end
		SUB	r5, r2, r1
		MOV	r5, r5, LSR #3
; check for invalid index values
		MOV	r0, #0
		CMP	r4, #0
		BLT	%10
		CMP	r4, r5
		BGE	%10

; calc address of baud rate
		MOV	r4, r4, LSL #3
		ADD	r1, r1, r4
		LDR	r0, [r1]
10
		STR	r0, [r3, #4]		; store data
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@

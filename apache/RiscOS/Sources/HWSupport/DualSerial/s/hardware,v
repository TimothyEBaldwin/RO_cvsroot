head	4.7;
access;
symbols
	DualSerial-0_29:4.7
	DualSerial-0_25-4_8_2_10:4.6.2.5
	RO_5_07:4.6.2.5
	DualSerial-0_28:4.7
	DualSerial-0_25-4_8_2_9:4.6.2.5
	DualSerial-0_25-4_8_2_8:4.6.2.5
	DualSerial-0_25-4_8_2_7:4.6.2.4
	DualSerial-0_25-4_8_2_6:4.6.2.3
	DualSerial-0_27:4.7
	DualSerial-0_25-4_8_2_5:4.6.2.2
	DualSerial-0_25-4_8_2_4:4.6.2.2
	DualSerial-0_25-4_8_2_3:4.6.2.2
	DualSerial-0_25-4_8_2_2:4.6.2.1
	DualSerial-0_25-4_8_2_1:4.6
	HAL:4.6.0.2
	DualSerial-0_26:4.7
	DualSerial-0_25:4.6
	kbracey_32bit_merge:4.5.2.1
	DualSerial-0_24-4_7_2_4:4.5.2.1
	DualSerial-0_24-4_7_2_3:4.5.2.1
	DualSerial-0_24-4_7_2_2:4.5.2.1
	dellis_autobuild_BaseSW:4.5
	DualSerial-0_24-4_7_2_1:4.5.2.1
	kbracey_32bit:4.5.0.2
	DualSerial-0_24:4.5
	sbrodie_sedwards_16Mar2000:4.5
	DualSerial-0_23:4.5
	dcotton_autobuild_BaseSW:4.7
	DualSerial-0_22:4.4
	DualSerial-0_21:4.4
	DualSerial-0_18:4.4
	Daytona_merge:4.2.6.1
	DualSerial-0_17:4.3
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spinner_B10:4.1.7.2
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.2
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	ARTtmp:4.1.7.2.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.2
	MergeFiles:4.1.7.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1;
locks; strict;
comment	@# @;


4.7
date	2001.03.16.15.55.52;	author sbrodie;	state Exp;
branches;
next	4.6;

4.6
date	2001.01.09.14.05.12;	author sbrodie;	state Exp;
branches
	4.6.2.1;
next	4.5;

4.5
date	99.10.26.09.22.15;	author kbracey;	state Exp;
branches
	4.5.2.1;
next	4.4;

4.4
date	98.09.29.13.30.05;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.09.21.14.21.54;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.22.13.38.47;	author nturton;	state Exp;
branches
	4.2.2.1
	4.2.6.1;
next	4.1;

4.1
date	96.11.21.12.06.25;	author nturton;	state Exp;
branches
	4.1.5.1
	4.1.7.1;
next	;

4.6.2.1
date	2001.03.20.13.13.47;	author kbracey;	state Exp;
branches;
next	4.6.2.2;

4.6.2.2
date	2001.03.27.11.58.18;	author dellis;	state Exp;
branches;
next	4.6.2.3;

4.6.2.3
date	2003.03.29.18.20.24;	author kbracey;	state Exp;
branches;
next	4.6.2.4;

4.6.2.4
date	2003.03.31.09.28.07;	author rsprowson;	state Exp;
branches;
next	4.6.2.5;

4.6.2.5
date	2004.07.02.12.44.28;	author bavison;	state Exp;
branches;
next	4.6.2.6;

4.6.2.6
date	2012.06.04.23.36.13;	author jlee;	state dead;
branches;
next	;
commitid	lqDFJl0aX8rOLr7w;

4.5.2.1
date	2000.07.13.15.23.19;	author sbrodie;	state Exp;
branches;
next	;

4.2.2.1
date	98.07.21.13.36.42;	author wturner;	state dead;
branches;
next	;

4.2.6.1
date	97.07.07.13.27.24;	author blaughto;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.06.25;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.45.38;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.01.29.15.06.03;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.7
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.26. Tagged as 'DualSerial-0_26'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;
; 		Copyright 1996 Acorn Network Computing
;
;  This material is the confidential trade secret and proprietary
;  information of Acorn Network Computing. It may not be reproduced,
;  used, sold, or transferred to any third party without the prior
;  written consent of Acorn Network Computing. All rights reserved.
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                        ^ 0, r10
UART_data_word		# 4	; 0 RX buffer and TX holding buffer DLAB = 0
UART_interrupt_enable	# 4	; 1 IER interrupt enable register
UART_interrupt_ident 	# 4	; 2 IIR interrupt identification register
UART_line_control 	# 4	; 3 LCR line control register
UART_modem_control 	# 4	; 4 MCR modem control register
UART_line_status 	# 4	; 5 LSR line status register
UART_modem_status 	# 4	; 6 MSR modem status register
UART_scratch 		# 4	; 7 SCR scratchpad register

                        ^ 0, r10
UART_baud_divisor_LSB 	# 4	; 0 DLL baud rate divisor latch LSB
UART_baud_divisor_MSB 	# 4	; 1 DLM baud rate divisor latch MSB
UART_FIFO_control	# 4	; 2 FCR FIFO control register (on 550s only)

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Bits in UART_interrupt_enable

IER_receive_available  	* 1 :SHL: 0	; set bit to enable receive interrupts
IER_transmit_empty 	* 1 :SHL: 1   	; set bit to enable transmit interrupts
IER_line_status    	* 1 :SHL: 2   	; set bit to enable error interrupts (Overrun, Parity, Framing, Break)
IER_modem_status    	* 1 :SHL: 3   	; set bit to enable modem line change interrupts

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Bits in UART_FIFO_control

FCR_enable       	* 1:SHL:0	; enable TX and RX FIFOs
FCR_RX_reset      	* 1:SHL:1	; reset RX FIFO
FCR_TX_reset      	* 1:SHL:2	; reset TX FIFO
FCR_RX_trigger_1   	* 2_00:SHL:6	; RX interrupt trigger level
FCR_RX_trigger_4  	* 2_01:SHL:6
FCR_RX_trigger_8   	* 2_10:SHL:6
FCR_RX_trigger_14  	* 2_11:SHL:6

FIFO_size       	* 16			; 16 byte FIFO

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Values in UART_interrupt_ident

IIR_no_interrupt  	* 1		; bit 0 is clear when interrupt pending
IIR_line_status   	* 6  		; 0110 highest priority interrupt
IIR_RX_full       	* 4  		; 0100 second highest priority interrupt
IIR_char_timeout	* 12		; 1100 second highest priotity interrupt
IIR_TX_empty      	* 2  		; 0010 third hightst priotity interrupt
IIR_modem        	* 0  		; 0000 lowest priority interrupt
IIR_IRQBits      	* 15 		; 1111
IIR_FIFOs_enabled	* 2_11:SHL:6	; set to indicate FIFOs enabled

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Bits in UART_line_control

LCR_start_bit		* 1 :SHL: 2
LCR_parity_bit		* 1 :SHL: 3
LCR_even_parity		* 1 :SHL: 4
LCR_sticky_parity	* 1 :SHL: 5
LCR_break_enable	* 1 :SHL: 6	; set to enable break signal
LCR_address_divisor	* 1 :SHL: 7	; set to access baud rate divisors

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Bits in UART_modem_control

MCR_DTR_active		* 1 :SHL: 0	; set turn DTR active, clear disable DTR
MCR_RTS_active		* 1 :SHL: 1	; set turn RTS active, clear disable RTS
MCR_out_1         	* 1 :SHL: 2	; control OUT1 line
MCR_out_2         	* 1 :SHL: 3	; control OUT2 line
MCR_loopback     	* 1 :SHL: 4	; turn on loopback facility

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Bits in UART_line_status

LSR_data_ready		* 1 :SHL: 0	; 1 => character is in receive buffer
LSR_overrun		* 1 :SHL: 1	; 1 => overrun error
LSR_parity		* 1 :SHL: 2	; 1 => parity error
LSR_framing		* 1 :SHL: 3	; 1 => framing error
LSR_break		* 1 :SHL: 4	; 1 => break error
LSR_TX_empty		* 1 :SHL: 5	; 1 => tx buffer empty
LSR_TX_shift_empty 	* 1 :SHL: 6	; 1 => tx buffer and shift reg empty

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Bits in UART_modem_status

MSR_CTS_changed		* 1 :SHL: 0	; 1 => CTS has changed state
MSR_DSR_changed		* 1 :SHL: 1	; 1 => DSR has changed state
MSR_TERI_changed	* 1 :SHL: 2	; 1 => TERI has gone from 0 to 1
MSR_DCD_changed		* 1 :SHL: 3	; 1 => DCD has changed state
MSR_CTS_active		* 1 :SHL: 4	; CTS state
MSR_DSR_active		* 1 :SHL: 5	; DSR state
MSR_RI_active		* 1 :SHL: 6	; RI  state
MSR_DCD_active		* 1 :SHL: 7	; DCD state

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_probe
;
; in  : r10 hardware base address
;
; out : r10 address if port is present, 0 otherwise
;
; enable the UART loopback mode, assert DTR and wait for the looped back signal
; to assert DSR (with timeout).

hardware_probe  Entry "r0-r5"
 [ debug
;		DREG	r10, "probe : "
 ]
; do we have a base address
		CMP	r10, #0                         ; clears V
		EXIT	EQ

; setup ready for scratch register
		MOV	r5, #&ff

; turn on loopback
		MOV	r4, #MCR_loopback
		STRB	r4, UART_modem_control
; assert DTR
		ORR	r4, r4, #MCR_DTR_active
		STRB	r4, UART_modem_control

; wait for DSR to be asserted
		SWI	XOS_ReadMonotonicTime
		ADD	r2, r0, #50			; timeout period (cs)
10
		LDRB	r3, UART_modem_status
		TST	r3, #MSR_DSR_active
		BNE	%20
		SWI	XOS_ReadMonotonicTime
		CMP	r0, r2
		BLE	%10
		B	%30
20
; turn off DTR
		BIC	r4, r4, #MCR_DTR_active
		STRB	r4, UART_modem_control

; wait for DSR to be cleared
		SWI	XOS_ReadMonotonicTime
		ADD	r2, r0, #50			; timeout period (cs)
		STRB	r5, UART_scratch
25
		LDRB	r3, UART_modem_status
		TST	r3, #MSR_DSR_active
		BEQ	%26
		SWI	XOS_ReadMonotonicTime
		CMP	r0, r2
		BLE	%25
		B	%30
26
; turn off loopback
		BIC	r4, r4, #MCR_loopback
		STRB	r4, UART_modem_control
		EXIT
; show that we have not found anything
30
		MOV	r10, #0
		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; handle the command *SerialTest
;
; in  : r0 port name
;       r11 port workspace
;
hardware_test Entry "r1-r4,r10"

		CMP	r11, #0                         ; clears V
		EXIT	EQ
; write the port name
		SWI	XOS_Write0
		SWI	XOS_NewLine

; do we have a base address
		CMP	r10, #0
		EXIT	EQ
; turn on loopback
		MOV	r4, #MCR_loopback
		STRB	r4, UART_modem_control

; turn off loopback
		BIC	r4, r4, #MCR_loopback
		STRB	r4, UART_modem_control

		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_initialise
;
; in  : r11 port workspace
;
hardware_initialise Entry "r0-r1, r10"
 [ debug
;		DREG	r11, "init : "
 ]
		CMP	r11, #0                         ; clears V
		EXIT	EQ
		LDR	r10, BaseAddress

; enable FIFOs
		MOV	r1, #FCR_enable
		STRB	r1, UART_FIFO_control
; check them
		LDRB	r0, UART_interrupt_ident
		TST	r0, #IIR_FIFOs_enabled
		BEQ	%10				; branch if not present

		LDR	r0, PortFlags
		ORR	r0, r0, #flag_FIFOsPresent
		STR	r0, PortFlags

; reset the FIFOs
		ORR	r1, r1, #FCR_RX_reset:OR:FCR_TX_reset
		STRB	r1, UART_FIFO_control

		LDR	r0, =default_fifo_trigger
		BL	hardware_set_fifo_trigger
10
		LDR	r0, =default_baud
		BL	hardware_set_baud
		MOV	r0, #default_data
		BL	hardware_set_data
		MOV	r0, #default_stop
		BL	hardware_stop_bit
		MOV	r0, #default_parity
		BL	hardware_parity

; enable all interrupts on port
                MOV     r0, #IER_receive_available:OR:IER_transmit_empty:OR:IER_line_status:OR:IER_modem_status
                STRB    r0, UART_interrupt_enable

                MOV     r0, #MCR_out_2
                STRB    r0, UART_modem_control

		PHPSEI	lr, r0			; disable interrupts
		LDRB	r0, ControlLines
		ORR	r0, r0, #ctrl_line_dtr:OR:ctrl_line_rts
		STRB	r0, ControlLines
		PLP	lr			; enable interrupts
		BL	hardware_ctrl_lines

                CLRV
		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_remove
;
; in  : r11 port workspace
;
hardware_remove	Entry "r0,r10"

		CMP	r11, #0                         ; clears V
		EXIT	EQ
		LDR	r10, BaseAddress

; drop rts and dtr when quitting
		PHPSEI	lr, r0			; disable interrupts
		LDRB	r0, ControlLines
		BIC	r0, r0, #ctrl_line_dtr:OR:ctrl_line_rts
		STRB	r0, ControlLines
		PLP	lr			; enable interrupts
		BL	hardware_ctrl_lines

; disable port interrupts
                SUBS    r0, r0, r0                      ; R0=0, clears V
                STRB    r0, UART_interrupt_enable	; disable all interrupts

		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_claim
;
hardware_claim  Entry "r0-r4"
 [ debug
;		DLINE	"claim"
 ]
; claim device vector
                LDR     r3, Flags		; own the vector ?
                TST     r3, #flag_OwnIRQ
                BNE     %10

                TST     r3, #flag_SerialType2
                MOVEQ   r0, #Serial_DevNo
                MOVNE   r0, #IOMDr_Serial_DevNo
                ADDR    r1, handle_irq
                MOV     r2, wp
                SWI     XOS_ClaimDeviceVector
                STRVS   r0, [sp]
                PullEnv VS
                BVS	make_error

                LDR     r3, Flags		; we now the vector
                ORR     r3, r3, #flag_OwnIRQ
                STR     r3, Flags
10
; seral IRQ bit needs to be set in IOC
                TST     r3, #flag_SerialType2
                MOVEQ   r2, #serial_bit
                MOVNE   r2, #IOMDr_serial_IRQ_bit
                LDR     r3, =IOC
                SETPSR  F_bit+I_bit,r1,,lr      ; disable FIQs+IRQS, old PSR into lr
                LDRB    r0, [r3, #IOCIRQMSKB]
                ORR     r0, r0, r2
                STRB    r0, [r3, #IOCIRQMSKB]
		RestPSR lr,,cf			; restore FIQs+IRQs
		NOP
 [ debug
 ;		DLINE	"claim complete"
 ]
                EXIT                            ; V will be clear after SWI XOS_ClaimDeviceVector

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_release
;
hardware_release Entry "r0-r4"

                LDR     r3, Flags
                TST     r3, #flag_OwnIRQ       		; own the vector
                EXIT    EQ

; release the IRQ
                TST     r3, #flag_SerialType2
                MOVEQ   r0, #Serial_DevNo
                MOVNE   r0, #IOMDr_Serial_DevNo
                ADDR    r1, handle_irq
                MOV     r2, wp
                SWI     XOS_ReleaseDeviceVector
                STRVS   r0, [sp]
                PullEnv VS
                BVS	make_error

                LDR     r3, Flags
                BIC     r3, r3, #flag_OwnIRQ
                STR     r3, Flags

                EXIT    ; V already clear

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_set_fifo_trigger
;
; in:  r0  = required trigger value
;      r11 = port workspace
;
; out: r0  = actual value
;
hardware_set_fifo_trigger Entry "r1,r10"

		CMP	r11, #0                         ; clears V
		EXIT	EQ

; range check the fifo trigger values
		CMP	r0, #1
		CMPNE	r0, #4
		CMPNE	r0, #8
		CMPNE	r0, #14
		LDRNEB	r0, FIFOTrigger
		EXIT	NE

; set up the port
		STRB	r0, FIFOTrigger
		LDR	r10, BaseAddress

		PHPSEI	lr, r1			; disable interrupts

		MOV	r1, #0
		CMP	r0, #1
		ORREQ	r1, r1, #FCR_RX_trigger_1
		CMP	r0, #4
		ORREQ	r1, r1, #FCR_RX_trigger_4
		CMP	r0, #8
		ORREQ	r1, r1, #FCR_RX_trigger_8
		CMP	r0, #14
		ORREQ	r1, r1, #FCR_RX_trigger_14

; ensure fifos are enabled and reset
		LDR	r0, PortFlags
		TST	r0, #flag_FIFOsPresent
		ORRNE	r1, r1, #FCR_enable:OR:FCR_RX_reset
		STRB	r1, UART_FIFO_control

		PLP	lr			; enable interrupts

                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_set_baud
;
; in:  r0  = required baud rate
;      r11 = port workspace
;
; out:
;
hardware_set_baud Entry "r1-r3,r10"

		CMP	r11, #0                         ; clears V
		EXIT	EQ
		LDR	r10, BaseAddress

		ADR	r2, baud_table
		ADR	r3, baud_table_end
		SUB	r2, r2, #8
		SUB	r3, r3, #8
10
		ADD	r2, r2, #8		; move to next entry
		LDR	r1, [r2, #0]
		CMP	r0, r1			; does it match (clears V)
		BEQ	%20
		CMP	r2, r3			; are we at the end ?
		BLT	%10

; make an error
		ADR	r0, ErrorBlock_Serial_BadBaud
		PullEnv
		B	make_error
20
; now program the UART to use this baud rate divisor
		STR	r0, BaudRate		; store in workspace
		LDR	r1, [r2, #4]		; load baud rate divisor

		PHPSEI	lr, r2			; disable interrupts
; set DRAB
		LDRB	r2, UART_line_control
                ORR     r2, r2, #LCR_address_divisor
		STRB	r2, UART_line_control

                STRB    r1, UART_baud_divisor_LSB	; store lower byte
                MOV     r1, r1, LSR #8			; shift down one byte
                STRB    r1, UART_baud_divisor_MSB       ; write upper byte

; clear DRAB
                BIC     r2, r2, #LCR_address_divisor
		STRB	r2, UART_line_control

		PLP	lr			; enable interrupts

		EXIT                            ; V is clear

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	MakeErrorBlock Serial_BadBaud

baud_table ; frequency, divisor value
	DCD 50,		2304
	DCD 75,		1536
	DCD 110,	1047
	DCD 150,	768
	DCD 300,	384
	DCD 600,	192
	DCD 1200,	96
	DCD 1800,	64
	DCD 2400,	48
	DCD 3600,	32
	DCD 4800,	24
	DCD 7200,	16
	DCD 9600,	12
	DCD 19200,	6
	DCD 38400,	3
	DCD 57600,	2
	DCD 115200, 	1
baud_table_end

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_set_data
;
; in:  r0  = data size
;      r10 = port workspace
; out:
;

hardware_set_data Entry "r1-r2,r10"

		CMP	r11, #0                         ; clears V
		EXIT	EQ
		LDR	r10, BaseAddress

		CMP	r0, #5			; is it less than 5
		BLT	%5
		CMP	r0, #8			; or greater than 8
		BLE	%10

; make an error
5
		ADR	r0, ErrorBlock_Serial_BadData
		PullEnv
		B	make_error

10
		LDR	r1, DataFormat		; stash results away
		BIC	r1, r1, #&ff
		ORR	r1, r1, r0
		STR	r1, DataFormat
		SUB	r1, r0, #5		; 5 maps to 0, 6 to 1, etc

		PHPSEI	lr, r2			; disable interrupts

		LDRB	r2, UART_line_control
		BIC	r2, r2, #3
                ORR     r2, r2, r1
		STRB	r2, UART_line_control

		PLP	lr			; enable interrupts

		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	MakeErrorBlock Serial_BadData

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_stop_bit
;
; in:  r0  = number of start/stop bits
;      r11 = port workspace
; out:
;
hardware_stop_bit Entry "r1-r2,r10"

		CMP	r11, #0                         ; clears V
		EXIT	EQ
		LDR	r10, BaseAddress

		PHPSEI	lr, r1			; disable interrupts

		LDRB	r1, UART_line_control
		CMP	r0, #2			; 2 stop bits ?
		MOVNE	r0, #1			; otherwise 1
		ORREQ	r1, r1, #LCR_start_bit	; 2 stop bits
                BICNE   r1, r1, #LCR_start_bit	; 1 stop bit
		STRB	r1, UART_line_control

		PLP	lr			; enable interrupts

; store away now as we may have modded it above
		LDR	r1, DataFormat
		MOV	r2, r0, LSL #8
		BIC	r1, r1, #&ff00
		ORR	r1, r1, r2
		STR	r1, DataFormat


		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_parity
;
; in:  r0  = parity : none=0, even=1, odd=2
;      r11 = port workspace
; out:
;

hardware_parity Entry "r1-r2,r10"

		CMP	r11, #0                         ; clears V
		EXIT	EQ
		LDR	r10, BaseAddress

; normalise the value
		CMP	r0, #2
		MOVGT	r0, #2
		CMP	r0, #0
		MOVLT	r0, #0

		LDR	r1, DataFormat		; stash results away
		MOV	r2, r0, LSL #16
		BIC	r1, r1, #&ff0000
		ORR	r1, r1, r2
		STR	r1, DataFormat

		PHPSEI	lr, r1			; disable interrupts

		LDRB	r1, UART_line_control

		CMP	r0, #0			; no parity ?
		BICEQ	r1, r1, #LCR_parity_bit
                ORRNE   r1, r1, #LCR_parity_bit

		CMP	r0, #1			; even parity ?
		ORREQ	r1, r1, #LCR_even_parity
		BICNE	r1, r1, #LCR_even_parity

		STRB	r1, UART_line_control

		PLP	lr			; enable interrupts

		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_ctrl_line
;
; in:  r11 = port workspace
; out:
;
; check the dtr and rts bits in the control line flags byte and set hardware
; accordingly.
;
hardware_ctrl_lines Entry "r0-r1,r10"

		CMP	r11, #0                         ; clears V
		EXIT	EQ
		LDR	r10, BaseAddress

; sort out the read/writables in the modem control register
		PHPSEI	lr, r1			; disable interrupts
		LDRB	r0, ControlLines
		LDRB	r1, UART_modem_control

		TST	r0, #ctrl_line_dtr
		ORRNE	r1, r1, #MCR_DTR_active
		BICEQ	r1, r1, #MCR_DTR_active
		TST	r0, #ctrl_line_rts
		ORRNE	r1, r1, #MCR_RTS_active
		BICEQ	r1, r1, #MCR_RTS_active

		STRB	r1, UART_modem_control
		PLP	lr			; enable interrupts

; now the read onlys in the modem status register
                LDRB    r1, UART_modem_status

		TST	r1, #MSR_CTS_active	; check cts
		ORRNE	r0, r0, #ctrl_line_cts
		BICEQ	r0, r0, #ctrl_line_cts
		TST	r1, #MSR_DSR_active	; check dsr
		ORRNE	r0, r0, #ctrl_line_dsr
		BICEQ	r0, r0, #ctrl_line_dsr
		TST	r1, #MSR_RI_active	; check ri
		ORRNE	r0, r0, #ctrl_line_ri
		BICEQ	r0, r0, #ctrl_line_ri
		TST	r1, #MSR_DCD_active	; check dcd
		ORRNE	r0, r0, #ctrl_line_dcd
		BICEQ	r0, r0, #ctrl_line_dcd

		STRB	r0, ControlLines
		PLP	lr			; enable interrupts

		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		END
@


4.6
log
@  Merge of 32-bit branch.
Detail:
  This version represents the merge of the 32-bit conversion of the DualSerial
    module.
Admin:
  This module has received a modest amount of testing, however, it has not
    been exhaustively tested.  Projects taking this version should be careful
    of it as it may contain bugs.

Version 0.25. Tagged as 'DualSerial-0_25'
@
text
@d137 1
a137 1
hardware_probe  ENTRY "r0-r5"
d202 1
a202 1
hardware_test ENTRY "r1-r4,r10"
d231 1
a231 1
hardware_initialise ENTRY "r0-r1, r10"
d292 1
a292 1
hardware_remove	ENTRY "r0,r10"
d318 1
a318 1
hardware_claim  ENTRY "r0-r4"
d363 1
a363 1
hardware_release ENTRY "r0-r4"
d397 1
a397 1
hardware_set_fifo_trigger ENTRY "r1,r10"
d447 1
a447 1
hardware_set_baud ENTRY "r1-r3,r10"
d527 1
a527 1
hardware_set_data ENTRY "r1-r2,r10"
d576 1
a576 1
hardware_stop_bit ENTRY "r1-r2,r10"
d614 1
a614 1
hardware_parity ENTRY "r1-r2,r10"
d662 1
a662 1
hardware_ctrl_lines ENTRY "r0-r1,r10"
@


4.6.2.1
log
@Second attempt to check this in.

Version 0.25, 4.8.2.2. Tagged as 'DualSerial-0_25-4_8_2_2'
@
text
@d67 1
a67 1
; Values from UARTInterruptID
d69 8
a76 6
IID_no_interrupt  	* -1		; bit 0 is clear when interrupt pending
IID_line_status   	* 3  		; 0110 highest priority interrupt
IID_RX_full       	* 2  		; 0100 second highest priority interrupt
IID_char_timeout	* 6		; 1100 second highest priotity interrupt
IID_TX_empty      	* 1  		; 0010 third hightst priotity interrupt
IID_modem        	* 0  		; 0000 lowest priority interrupt
d128 99
d229 9
a237 2
hardware_initialise ENTRY "r0-r1, r9, r10"
		LDR	r9, HAL_StaticBase
d240 2
a241 3
                MOV     r1, #1
                CallHAL HAL_UARTFIFOEnable

d243 2
a244 2
                CallHAL HAL_UARTFeatures
                TST     r0, #1
d252 2
a253 3

                MOV     r1, #3                          ; Clear both fifos
                CallHAL HAL_UARTFIFOClear
d268 2
a269 2
                MOV     r1, #IER_receive_available:OR:IER_transmit_empty:OR:IER_line_status:OR:IER_modem_status
                CallHAL HAL_UARTInterruptEnable
d271 2
a272 3
; does something weird about enabling interrupts...
;                MOV     r0, #MCR_out_2
;                STRB    r0, UART_modem_control
d290 3
a292 1
hardware_remove	ENTRY "r0,r9"
d294 3
a296 1
		LDR	r9, HAL_StaticBase
d307 2
a308 2
                MOV     r1, #0				; disable all interrupts
                CallHAL HAL_UARTInterruptEnable
d318 1
a318 1
hardware_claim  ENTRY "r0-r4, r9"
d327 3
a329 2
                CallHAL HAL_UARTDevice
                MOV     r4, r0                  ; save for later
d341 11
a351 5
; serial IRQ bit needs to be set in IOC
                MOV     r0, r4
                MOV     r8, #0
                MOV     r9, #EntryNo_HAL_IRQEnable
                SWI     XOS_Hardware
d363 1
a363 1
hardware_release ENTRY "r0-r4, r9"
d370 3
a372 7
		LDR	r9, HAL_StaticBase
                CallHAL HAL_UARTDevice
                MOV     r4, r0
                MOV     r8, #0
                MOV     r9, #EntryNo_HAL_IRQEnable
                SWI     XOS_Hardware
                MOV     r0, r4
d393 1
a393 1
;      r9  = UART static workspace
d397 4
a400 1
hardware_set_fifo_trigger ENTRY "r1, r4"
d403 22
a424 4
                MOV     r1, r0
                CallHAL HAL_UARTFIFOThreshold   ; returns actual value set

		PHPSEI	r4, r1			; disable interrupts
d429 2
a430 2
                MOV     r1, #1
                CallHAL HAL_UARTFIFOEnable
d432 1
a432 1
		PLP	r4			; enable interrupts
d443 1
a443 1
;      r9  = port static workspace
d449 26
a474 1
		PHPSEI	r10, r2			; disable interrupts
d476 11
a486 2
                MOV     r1, r0, LSL#4
                CallHAL HAL_UARTRate
d488 1
a488 1
		PLP	r10			; enable interrupts
d494 24
d523 1
a523 1
;      r9  = HAL static workspace
d527 5
a531 1
hardware_set_data ENTRY "r1-r2,r4,r10"
d549 1
a549 1
		SUB	r4, r0, #5		; 5 maps to 0, 6 to 1, etc
d551 1
a551 1
		PHPSEI	r10, r2			; disable interrupts
d553 4
a556 2
                MOV     r1, #-1
                CallHAL HAL_UARTFormat
d558 1
a558 5
		BIC	r0, r0, #3
                ORR     r1, r0, r4
                CallHAL HAL_UARTFormat

		PLP     r10			; enable interrupts
d573 1
a573 1
;      r9  = HAL static base
d576 1
a576 1
hardware_stop_bit ENTRY "r1-r2,r4,r5"
d578 3
a580 1
                MOV     r4, r0
d582 1
a582 1
		PHPSEI	r5, r1			; disable interrupts
d584 3
a586 5
                MOV     r1, #-1
                CallHAL HAL_UARTFormat
                MOV     r1, r0
		CMP	r4, #2			; 2 stop bits ?
		MOVNE	r4, #1			; otherwise 1
d589 1
a589 1
                CallHAL HAL_UARTFormat
d591 1
a591 1
		PLP	r5			; enable interrupts
d595 1
a595 1
		MOV	r2, r4, LSL #8
d610 1
a610 1
;      r9  = HAL static workspace
d614 1
a614 1
hardware_parity ENTRY "r1-r2,r4,r10"
d616 3
a630 1
                MOV     r4, r0
d632 1
a632 1
		PHPSEI	r10, r1			; disable interrupts
d634 1
a634 2
                MOV     r1, #-1
                CallHAL HAL_UARTFormat
d636 1
a636 2
                MOV     r1, r0
		CMP	r4, #0			; no parity ?
d640 1
a640 1
		CMP	r4, #1			; even parity ?
d644 1
a644 1
                CallHAL HAL_UARTFormat
d646 1
a646 1
		PLP	r10			; enable interrupts
d656 1
d662 5
a666 1
hardware_ctrl_lines ENTRY "r0-r2,r4,r9-r10"
a667 1
                LDR     r9, HAL_StaticBase
d669 3
a671 5
		PHPSEI	r10, r1			; disable interrupts
		LDRB	r4, ControlLines
                MVN     r2, #MCR_DTR_active:OR:MCR_RTS_active
                MOV     r1, r4
                CallHAL HAL_UARTModemControl
d673 9
a681 1
		PLP	r10			; enable interrupts
d684 1
a684 1
                CallHAL HAL_UARTModemStatus
d686 12
a697 12
		TST	r0, #MSR_CTS_active	; check cts
		ORRNE	r4, r4, #ctrl_line_cts
		BICEQ	r4, r4, #ctrl_line_cts
		TST	r0, #MSR_DSR_active	; check dsr
		ORRNE	r4, r4, #ctrl_line_dsr
		BICEQ	r4, r4, #ctrl_line_dsr
		TST	r0, #MSR_RI_active	; check ri
		ORRNE	r4, r4, #ctrl_line_ri
		BICEQ	r4, r4, #ctrl_line_ri
		TST	r0, #MSR_DCD_active	; check dcd
		ORRNE	r4, r4, #ctrl_line_dcd
		BICEQ	r4, r4, #ctrl_line_dcd
d699 2
a700 1
		STRB	r4, ControlLines
@


4.6.2.2
log
@  Fixed modem ioctls

Detail:
  The function hardware_ctrl_lines which is called from the modem ioctl,
wasn't preserving r3, which points to the ioctl data buffer, hence modem
ioctls weren't functioning correctly.  r3 was being corrupted by a HAL call,
which must be ATPC compliant i.e. r0-r3 are corrupted.

Admin:
  Tested on customer L board by RMFastering the serial module and patching it with
memorya.  The ioctl calls then worked and the dialler worked.



Version 0.25, 4.8.2.3. Tagged as 'DualSerial-0_25-4_8_2_3'
@
text
@d468 1
a468 1
hardware_ctrl_lines ENTRY "r0-r4,r9-r10"
@


4.6.2.3
log
@Change to DTR/RTS handling.

Version 0.25, 4.8.2.6. Tagged as 'DualSerial-0_25-4_8_2_6'
@
text
@d475 1
a475 1
                AND     r1, r4, #MCR_DTR_active:OR:MCR_RTS_active
@


4.6.2.4
log
@Change to use objasm (the non HAL one already has): fixes report that
it blew messagetrans away when rmkilled.
Change to have a zero in the command table word: fixes report that
serialinfo and serialtest don't do anything,indeed they don't in this
HAL version!

Version 0.25, 4.8.2.7. Tagged as 'DualSerial-0_25-4_8_2_7'
@
text
@d128 1
a128 1
hardware_initialise Entry "r0-r1, r9, r10"
d185 1
a185 1
hardware_remove	Entry "r0,r9"
d209 1
a209 1
hardware_claim  Entry "r0-r4, r9"
d247 1
a247 1
hardware_release Entry "r0-r4, r9"
d285 1
a285 1
hardware_set_fifo_trigger Entry "r1, r4"
d314 1
a314 1
hardware_set_baud Entry "r1-r3,r10"
d336 1
a336 1
hardware_set_data Entry "r1-r2,r4,r10"
d383 1
a383 1
hardware_stop_bit Entry "r1-r2,r4,r5"
d421 1
a421 1
hardware_parity Entry "r1-r2,r4,r10"
d468 1
a468 1
hardware_ctrl_lines Entry "r0-r4,r9-r10"
@


4.6.2.5
log
@Changes from Kevin: support for clearing the interrupt when it has been
serviced using HAL_IRQClear.

Version 0.25, 4.8.2.8. Tagged as 'DualSerial-0_25-4_8_2_8'
@
text
@d209 1
a209 1
hardware_claim  Entry "r0-r4, r8,r9"
d219 1
a219 1
                STR     r0, IRQDeviceNumber     ; save for later
d232 1
a232 1
                LDR     r0, IRQDeviceNumber
d247 1
a247 1
hardware_release Entry "r0-r3,r8,r9"
d254 3
a256 1
                LDR     r0, IRQDeviceNumber
d260 1
a260 1
                LDR     r0, IRQDeviceNumber
@


4.6.2.6
log
@Rewrite module to add support for acting as a client of SerialSupport
Detail:
  In order to act as a client of SerialSupport, DualSerial needs to support the set of device calls that SerialSupport uses to talk to the serial driver.
  This set of device calls operates at a lower level than the IOCtl interface which DualSerial already supports.
  Therefore simply adding the new device call interface ontop of DualSerial (or modifying SerialSupport to add IOCtl support) would have been a risky venture, due to the many complexities hidden in the Serial module sources.
  So to reduce the amount of risk inherent in the change, I've instead taken the Serial module, stripped out 6551 support, rewritten the 710 interface to use HAL calls, and then bolted the IOCtl interface on top.
  This should ensure the SerialSupport/OS_SerialOp interface is identical to that provided by the Serial module, and only the simpler to understand DualSerial/IOCtl interface is the one likely to contain any bugs.
  File changes:
  - Docs/serial.htm - Added a copy of the IOCtl interface docs, from the Ursula branch
  - s/common, s/errors, s/init, s/macros, s/main - New implementation of the module, based around modified Serial sources
  - s/serialhal - The business end of the module, based around s/Serial710 in the Serial sources
  - s/ioctl - New file containing reimplemented IOCtl interface
  - s/devicecall, s/hardware, s/interrupts, s/standalone - Deleted redundant files from old implementation
  - Makefile - Trimmed somewhat redundant comment
  - resources/UK/messages - Added new error messages
Admin:
  Tested in OMAP3 & Tungsten ROMs


Version 0.25, 4.8.2.11. Tagged as 'DualSerial-0_25-4_8_2_11'
@
text
@@


4.5
log
@Added support for serial ports on device 9, as well as the traditional 10.

Version 0.23. Tagged as 'DualSerial-0_23'
@
text
@d142 2
a143 2
		CMP	r10, #0
		EXITS	EQ
d187 1
a187 1
		EXITS
d191 1
a191 1
		EXITS
d204 2
a205 2
		CMP	r11, #0
		EXITS	EQ
d212 1
a212 1
		EXITS	EQ
d221 1
a221 1
		EXITS
d235 2
a236 2
		CMP	r11, #0
		EXITS	EQ
d274 1
a274 1
		PHPSEI				; disable interrupts
d278 1
a278 1
		PLP				; enable interrupts
d281 2
a282 1
		EXITS
d294 2
a295 2
		CMP	r11, #0
		EXITS	EQ
d299 1
a299 1
		PHPSEI				; disable interrupts
d303 1
a303 1
		PLP				; enable interrupts
d307 2
a308 2
                MOV     r0, #0				; disable all interrupts
                STRB    r0, UART_interrupt_enable
d310 1
a310 1
		EXITS
d346 1
a346 3
                MOV     lr, pc
                ORR     r1, lr, #F_bit+I_bit
                TEQP    r1, #0                  ; disable FIQs+IRQs
d350 1
a350 1
		TEQP	lr, #0			; restore FIQs+IRQs
d355 1
a355 1
                EXITS
d367 1
a367 1
                EXITS   EQ
d384 1
a384 1
                EXITS
d399 2
a400 2
		CMP	r11, #0
		EXITS	EQ
d408 1
a408 1
		EXITS	NE
d414 1
a414 1
		PHPSEI				; disable interrupts
d432 1
a432 1
		PLP				; enable interrupts
d434 1
a434 1
                EXITS
d449 2
a450 2
		CMP	r11, #0
		EXITS	EQ
d460 1
a460 1
		CMP	r0, r1			; does it match
d474 1
a474 1
		PHPSEI				; disable interrupts
d488 1
a488 1
		PLP				; enable interrupts
d490 1
a490 1
		EXITS
d529 2
a530 2
		CMP	r11, #0
		EXITS	EQ
d551 1
a551 1
		PHPSEI				; disable interrupts
d558 1
a558 1
		PLP				; enable interrupts
d560 1
a560 1
		EXITS
d578 2
a579 2
		CMP	r11, #0
		EXITS	EQ
d582 1
a582 1
		PHPSEI				; disable interrupts
d591 1
a591 1
		PLP				; enable interrupts
d601 1
a601 1
		EXITS
d616 2
a617 2
		CMP	r11, #0
		EXITS	EQ
d632 1
a632 1
		PHPSEI				; disable interrupts
d646 1
a646 1
		PLP				; enable interrupts
d648 1
a648 1
		EXITS
d664 2
a665 2
		CMP	r11, #0
		EXITS	EQ
d669 1
a669 1
		PHPSEI				; disable interrupts
d681 1
a681 1
		PLP				; enable interrupts
d700 1
a700 1
		PLP				; enable interrupts
d702 1
a702 1
		EXITS
@


4.5.2.1
log
@  32-bit compatible.
Detail:
  Hopefully, this is fully 32-bit compatible.  If not, the area of concern
    is likely to be interrupts.s.  The DeviceFS entry point dispatcher has
    been modified to preserve all flags except V across the entry point to
    relieve each routine of the burden of doing this.
Admin:
  Not tested, hence imported only onto the branch.

Version 0.24, 4.7.2.1. Tagged as 'DualSerial-0_24-4_7_2_1'
@
text
@d142 2
a143 2
		CMP	r10, #0                         ; clears V
		EXIT	EQ
d187 1
a187 1
		EXIT
d191 1
a191 1
		EXIT
d204 2
a205 2
		CMP	r11, #0                         ; clears V
		EXIT	EQ
d212 1
a212 1
		EXIT	EQ
d221 1
a221 1
		EXIT
d235 2
a236 2
		CMP	r11, #0                         ; clears V
		EXIT	EQ
d274 1
a274 1
		PHPSEI	lr, r0			; disable interrupts
d278 1
a278 1
		PLP	lr			; enable interrupts
d281 1
a281 2
                CLRV
		EXIT
d293 2
a294 2
		CMP	r11, #0                         ; clears V
		EXIT	EQ
d298 1
a298 1
		PHPSEI	lr, r0			; disable interrupts
d302 1
a302 1
		PLP	lr			; enable interrupts
d306 2
a307 2
                SUBS    r0, r0, r0                      ; R0=0, clears V
                STRB    r0, UART_interrupt_enable	; disable all interrupts
d309 1
a309 1
		EXIT
d345 3
a347 1
                SETPSR  F_bit+I_bit,r1,,lr      ; disable FIQs+IRQS, old PSR into lr
d351 1
a351 1
		RestPSR lr,,cf			; restore FIQs+IRQs
d356 1
a356 1
                EXIT                            ; V will be clear after SWI XOS_ClaimDeviceVector
d368 1
a368 1
                EXIT    EQ
d385 1
a385 1
                EXIT    ; V already clear
d400 2
a401 2
		CMP	r11, #0                         ; clears V
		EXIT	EQ
d409 1
a409 1
		EXIT	NE
d415 1
a415 1
		PHPSEI	lr, r1			; disable interrupts
d433 1
a433 1
		PLP	lr			; enable interrupts
d435 1
a435 1
                EXIT
d450 2
a451 2
		CMP	r11, #0                         ; clears V
		EXIT	EQ
d461 1
a461 1
		CMP	r0, r1			; does it match (clears V)
d475 1
a475 1
		PHPSEI	lr, r2			; disable interrupts
d489 1
a489 1
		PLP	lr			; enable interrupts
d491 1
a491 1
		EXIT                            ; V is clear
d530 2
a531 2
		CMP	r11, #0                         ; clears V
		EXIT	EQ
d552 1
a552 1
		PHPSEI	lr, r2			; disable interrupts
d559 1
a559 1
		PLP	lr			; enable interrupts
d561 1
a561 1
		EXIT
d579 2
a580 2
		CMP	r11, #0                         ; clears V
		EXIT	EQ
d583 1
a583 1
		PHPSEI	lr, r1			; disable interrupts
d592 1
a592 1
		PLP	lr			; enable interrupts
d602 1
a602 1
		EXIT
d617 2
a618 2
		CMP	r11, #0                         ; clears V
		EXIT	EQ
d633 1
a633 1
		PHPSEI	lr, r1			; disable interrupts
d647 1
a647 1
		PLP	lr			; enable interrupts
d649 1
a649 1
		EXIT
d665 2
a666 2
		CMP	r11, #0                         ; clears V
		EXIT	EQ
d670 1
a670 1
		PHPSEI	lr, r1			; disable interrupts
d682 1
a682 1
		PLP	lr			; enable interrupts
d701 1
a701 1
		PLP	lr			; enable interrupts
d703 1
a703 1
		EXIT
@


4.4
log
@Daytona branch merged.

Version 0.18. Tagged as 'DualSerial-0_18'
@
text
@d326 3
a328 1
                MOV     r0, #Serial_DevNo
d340 12
a351 10
; podule IRQ bit needs to be set in IOC
                MOV     lr, pc			; disable IRQs
                ORR     r1, lr, #I_bit
                TEQP    r1, #0
		NOP
                LDR     r1, =IOC		; look at IOC
                LDRB    r0, [r1, #IOCIRQMSKB]
                ORR     r0, r0, #serial_bit
                STRB    r0, [r1, #IOCIRQMSKB]
		TEQP	lr, #0			; restore IRQs
d371 3
a373 1
                MOV     r0, #Serial_DevNo
@


4.3
log
@Makefile changed to use LocalRes$Path.
Changed to use srccommit.
Spinner branch merged.

Version 0.17. Tagged as 'DualSerial-0_17'
@
text
@d450 1
@


4.2
log
@Version Spin_merge taken
@
text
@d197 30
d349 3
a351 1

@


4.2.2.1
log
@Rightio, we'll try for a real log this time...

Files deleted due to CVSs incompetency in replacing them with newer
differently named ones. Next, you'll see the new files arrive, with
a more descriptive log of what & why.
@
text
@@


4.2.6.1
log
@Made buffer threshold changes take effect immediately instead of next time a stream is opened.
@
text
@a196 30
; handle the command *SerialTest
;
; in  : r0 port name
;       r11 port workspace
;
hardware_test ENTRY "r1-r4,r10"

		CMP	r11, #0
		EXITS	EQ
; write the port name
		SWI	XOS_Write0
		SWI	XOS_NewLine

; do we have a base address
		CMP	r10, #0
		EXITS	EQ
; turn on loopback
		MOV	r4, #MCR_loopback
		STRB	r4, UART_modem_control

; turn off loopback
		BIC	r4, r4, #MCR_loopback
		STRB	r4, UART_modem_control

		EXITS

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
d319 1
a319 3
 [ debug
 ;		DLINE	"claim complete"
 ]
a417 1
		SUB	r2, r2, #8
@


4.1
log
@Initial revision
@
text
@a196 30
; handle the command *SerialTest
;
; in  : r0 port name
;       r11 port workspace
;
hardware_test ENTRY "r1-r4,r10"

		CMP	r11, #0
		EXITS	EQ
; write the port name
		SWI	XOS_Write0
		SWI	XOS_NewLine

; do we have a base address
		CMP	r10, #0
		EXITS	EQ
; turn on loopback
		MOV	r4, #MCR_loopback
		STRB	r4, UART_modem_control

; turn off loopback
		BIC	r4, r4, #MCR_loopback
		STRB	r4, UART_modem_control

		EXITS

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
d319 1
a319 3
 [ debug
 ;		DLINE	"claim complete"
 ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d197 30
d349 3
a351 1

@


4.1.7.2
log
@Imported from SrcFiler
@
text
@a196 30
; handle the command *SerialTest
;
; in  : r0 port name
;       r11 port workspace
;
hardware_test ENTRY "r1-r4,r10"

		CMP	r11, #0
		EXITS	EQ
; write the port name
		SWI	XOS_Write0
		SWI	XOS_NewLine

; do we have a base address
		CMP	r10, #0
		EXITS	EQ
; turn on loopback
		MOV	r4, #MCR_loopback
		STRB	r4, UART_modem_control

; turn off loopback
		BIC	r4, r4, #MCR_loopback
		STRB	r4, UART_modem_control

		EXITS

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
d319 1
a319 3
 [ debug
 ;		DLINE	"claim complete"
 ]
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@

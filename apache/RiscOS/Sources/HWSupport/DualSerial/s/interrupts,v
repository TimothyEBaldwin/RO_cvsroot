head	4.5;
access;
symbols
	DualSerial-0_29:4.5
	DualSerial-0_25-4_8_2_10:4.4.2.3
	RO_5_07:4.4.2.3
	DualSerial-0_28:4.5
	DualSerial-0_25-4_8_2_9:4.4.2.3
	DualSerial-0_25-4_8_2_8:4.4.2.3
	DualSerial-0_25-4_8_2_7:4.4.2.2
	DualSerial-0_25-4_8_2_6:4.4.2.1
	DualSerial-0_27:4.5
	DualSerial-0_25-4_8_2_5:4.4.2.1
	DualSerial-0_25-4_8_2_4:4.4.2.1
	DualSerial-0_25-4_8_2_3:4.4.2.1
	DualSerial-0_25-4_8_2_2:4.4.2.1
	DualSerial-0_25-4_8_2_1:4.4
	HAL:4.4.0.2
	DualSerial-0_26:4.5
	DualSerial-0_25:4.4
	kbracey_32bit_merge:4.3.2.2
	DualSerial-0_24-4_7_2_4:4.3.2.2
	DualSerial-0_24-4_7_2_3:4.3.2.2
	DualSerial-0_24-4_7_2_2:4.3.2.2
	dellis_autobuild_BaseSW:4.3
	DualSerial-0_24-4_7_2_1:4.3.2.1
	kbracey_32bit:4.3.0.2
	DualSerial-0_24:4.3
	sbrodie_sedwards_16Mar2000:4.3
	DualSerial-0_23:4.3
	dcotton_autobuild_BaseSW:4.5
	DualSerial-0_22:4.3
	DualSerial-0_21:4.3
	DualSerial-0_18:4.3
	Daytona_merge:4.2.6.1
	DualSerial-0_17:4.3
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spinner_B10:4.1.7.2
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.2
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	ARTtmp:4.1.7.2.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.2
	MergeFiles:4.1.7.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1;
locks; strict;
comment	@# @;


4.5
date	2001.03.16.15.55.53;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	2001.01.09.14.05.12;	author sbrodie;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	98.09.21.14.21.57;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.01.22.13.38.43;	author nturton;	state Exp;
branches
	4.2.2.1
	4.2.6.1;
next	4.1;

4.1
date	96.11.21.12.06.24;	author nturton;	state Exp;
branches
	4.1.5.1
	4.1.7.1;
next	;

4.4.2.1
date	2001.03.20.13.13.47;	author kbracey;	state Exp;
branches;
next	4.4.2.2;

4.4.2.2
date	2003.03.31.09.28.07;	author rsprowson;	state Exp;
branches;
next	4.4.2.3;

4.4.2.3
date	2004.07.02.12.44.28;	author bavison;	state Exp;
branches;
next	4.4.2.4;

4.4.2.4
date	2012.06.04.23.36.13;	author jlee;	state dead;
branches;
next	;
commitid	lqDFJl0aX8rOLr7w;

4.3.2.1
date	2000.07.13.15.23.19;	author sbrodie;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	2000.10.07.13.20.20;	author sbrodie;	state Exp;
branches;
next	;

4.2.2.1
date	98.07.21.13.36.45;	author wturner;	state dead;
branches;
next	;

4.2.6.1
date	97.07.07.13.27.29;	author blaughto;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.06.24;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.45.41;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.01.29.15.06.04;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.26. Tagged as 'DualSerial-0_26'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;
; 		Copyright 1996 Acorn Network Computing
;
;  This material is the confidential trade secret and proprietary
;  information of Acorn Network Computing. It may not be reproduced,
;  used, sold, or transferred to any third party without the prior
;  written consent of Acorn Network Computing. All rights reserved.
;
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: handle_irq
;
; This interrupt routine will have to handle the arbatration between the two
; interrupt sources.

handle_irq	EntryS	"r10-r11"
		LDR	r11, Port1			; try port 1
		CMP	r11, #0
		BEQ	%10

                LDR	r10, BaseAddress		; get the environment
		LDRB	r1, UART_interrupt_ident	; clears tx empty ints
		TST	r1, #IIR_no_interrupt		; any interrupts ?
		BEQ	%20

10
		LDR	r11, Port2			; now try port 2
		CMP	r11, #0
		EXITS	EQ
                LDR	r10, BaseAddress		; get the environment

irq_poll_loop
                LDRB    r1, UART_interrupt_ident  ; r1 = interrupt identity
20
                AND     r1, r1, #IIR_IRQBits	  ; mask off the IRQ bits
                TST     r1, #IIR_no_interrupt     ; if no more interrupt causes
                BNE     irq_exit		  ; leave the poll loop

 [ counting
		LDR	r0, InterruptCount
		ADD	r0, r0, #1
		STR	r0, InterruptCount
 ]
                TEQ     r1, #IIR_line_status
                BEQ     handle_line_status
                TEQ     r1, #IIR_RX_full
                BEQ     handle_rx_full
		TEQ	r1, #IIR_char_timeout
                BEQ     handle_rx_full
                TEQ     r1, #IIR_TX_empty
                BEQ     handle_tx_empty

; if none of the above, it must be...
;
; one of the modem control lines has changed, update our soft copy.
;
handle_modem_status
                LDRB    r0, UART_modem_status	; clear interrupt
; we need to update the ControlLines information since something has changed
                LDRB	r3, ControlLines
		TST	r0, #MSR_CTS_active
		ORRNE	r3, r3, #ctrl_line_cts
		BLNE	wakeup_tx			; need to start tx
		BICEQ	r3, r3, #ctrl_line_cts
		TST	r0, #MSR_DSR_active
		ORRNE	r3, r3, #ctrl_line_dsr
		BLNE	wakeup_tx			; need to start tx
		BICEQ	r3, r3, #ctrl_line_dsr
		TST	r0, #MSR_RI_active
		ORRNE	r3, r3, #ctrl_line_ri
		BICEQ	r3, r3, #ctrl_line_ri
		TST	r0, #MSR_DCD_active
		ORRNE	r3, r3, #ctrl_line_dcd
		BICEQ	r3, r3, #ctrl_line_dcd
		STRB	r3, ControlLines

                MOV     r1, #0			; nothing yet
		TST	r0, #MSR_DSR_changed
		ORRNE	r1, r1, #SerialError_DSR
		TST	r0, #MSR_DCD_changed
		ORRNE	r1, r1, #SerialError_DCD
		CMP	r1, #0
                BLNE	give_event

                B       irq_poll_loop

; handle line status interrupt

handle_line_status
 [ counting
		LDR	r0, ErrorCount
		ADD	r0, r0, #1
		STR	r0, ErrorCount
 ]
                LDRB    r0, UART_line_status	; clear interrupt
		LDRB	r1, UART_data_word	; clear byte

		MOV	r1, #0
		TST	r0, #LSR_overrun
		ORRNE	r1, r1, #SerialError_Overrun
		TST	r0, #LSR_parity
		ORRNE	r1, r1, #SerialError_Parity
		TST	r0, #LSR_framing
		ORRNE	r1, r1, #SerialError_Framing
		CMP	r1, #0
                BLNE	give_event

 [ counting
		TST	r0, #LSR_overrun
		LDRNE	r1, OverrunCount
		ADDNE	r1, r1, #1
		STRNE	r1, OverrunCount
		TST	r0, #LSR_parity
		LDRNE	r1, ParityCount
		ADDNE	r1, r1, #1
		STRNE	r1, ParityCount
		TST	r0, #LSR_framing
		LDRNE	r1, FramingCount
		ADDNE	r1, r1, #1
		STRNE	r1, FramingCount
 ]
                B       irq_poll_loop

; handle receive interrupt (even in FIFO mode we must go round poll loop for
; each char in case of errors)

handle_rx_full
 [ counting
		LDR	r2, ByteCount
		ADD	r2, r2, #1
		STR	r2, ByteCount
 ]
                LDRB    r2, UART_data_word	; get byte received into r0

; deal with xon/xoff handshaking
		LDR	r3, PortFlags		; update flags
		TST	r3, #flag_UseXon
		BEQ	%25
; handle it then
		CMP	r2, #xoffchar		; do we have an xoff
		CMPNE	r2, #xonchar		; or an xon
		BNE	%25			; no, then skip
		CMP	r2, #xoffchar
		ORREQ	r3, r3, #flag_TxXoffed
		BICNE	r3, r3, #flag_TxXoffed
		BLNE	wakeup_tx		; wake the device up
		STR	r3, PortFlags
                B       irq_poll_loop		; and loop again
25
                LDR     r1, InputBufferPrivId
                CMP     r1, #-1
                BEQ     irq_poll_loop

                MOV     r0, #BufferReason_InsertByte
		CallBuffMan
 [ counting
		LDRCS	r0, BufferOverrun
		ADDCS	r0, r0, #1
		STRCS	r0, BufferOverrun
 ]
                B       irq_poll_loop

; handle transmit interrupt (in FIFO mode we can send FIFO_Size bytes)

handle_tx_empty
                LDR	r3, PortFlags
                TST     r3, #flag_FIFOsPresent
                MOVEQ   r0, #0                  ; can only send one byte
                MOVNE   r0, #FIFO_size-1
                STRB    r0, TxByteCount
                BL      irq_tx_byte

                B       irq_poll_loop

irq_tx_byte
; are we using handshaking
		TST	r3, #flag_UseRTS:OR:flag_UseXon:OR:flag_UseDTR
		BEQ	%60
; is it xon/xoff
		TST	r3, #flag_UseXon
		BEQ	%55

		TST	r3, #flag_TxXon			; transmit xon
		MOVNE	r2, #xonchar			; setup character
		BICNE	r3, r3, #flag_TxXon		; clear bit
		STRNE	r3, PortFlags
		BNE	%65				; jump to tx character

		TST	r3, #flag_TxXoff		; transmit xoff
		MOVNE	r2, #xoffchar			; setup character
		BICNE	r3, r3, #flag_TxXoff		; clear bit
		STRNE	r3, PortFlags
		BNE	%65				; jump to tx character

; have I been xoffed
		TST	r3, #flag_TxXoffed
		BNE	%70				; goto sleep
		B	%60				; continue
55
; so must be rts or dtr
		LDRB	r2, ControlLines
		TST	r3, #flag_UseRTS
		BEQ	%56				; skip
		TST	r2, #ctrl_line_cts		; not free to send
		BEQ	%70				; goto sleep
56
		TST	r3, #flag_UseDTR
		BEQ	%60				; skip
		TST	r2, #ctrl_line_dtr		; not free to send
		BEQ	%70				; goto sleep
60
; need to pull some data from the buffer
                LDR     r1, OutputBufferPrivId
                CMP     r1, #-1
                BEQ     %FT70				; sleep and disable TXI

                MOV     r0, #BufferReason_RemoveByte
		CallBuffMan
                BCS     %FT70
65
                STRB    r2, UART_data_word
                MOV     pc, lr
70
                ORR     r3, r3, #flag_TxDormant		; go to sleep
                STR	r3, PortFlags
80
                LDRB    r1, UART_interrupt_enable
                BIC     r1, r1, #IER_transmit_empty
                STRB    r1, UART_interrupt_enable

                MOV     r1, #0				; no more bytes
                STRB    r1, TxByteCount

                MOV     pc, lr

; no more interrupt causes at present so see if we have any more bytes to stuff
; in the FIFO (if there is one) this is done here so that filling any FIFO
; takes a lower priority than servicing other interrupts

irq_exit
		LDRB	r1, UART_line_status
		TST	r1, #LSR_data_ready
		BNE	handle_rx_full

                LDRB    r1, TxByteCount
                SUBS    r1, r1, #1
                EXITS   CC                  	; no more bytes to be sent

                STRB    r1, TxByteCount 	; otherwise, update count
                LDR	r3, PortFlags 		; and send another byte
                BL      irq_tx_byte
                B       irq_poll_loop       	; check for more interrupts

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: give_event
;
; in:   r1 = DCD, DSR, PE, OV and FE bits where you want them
;	r11 = port workspace
;
; This code generates an event about a serial error ie framing error, overrun,
; parity error or DCD high
;

give_event      Entry   "r0-r3"

		LDR	r2, InputFSHandle	; get file handle

                SavePSR r3
                BIC     lr, r3, #2_11111        ; clear mode bits
                TEQ     pc, pc                  ; In a 32-bit mode?  EQ if so
                ORREQ   lr, lr, #SVC32_mode     ; set SVC32 mode if in IRQ32
                ORRNE   lr, lr, #SVC_mode       ; set SVC26 mode if in IRQ26
                RestPSR lr,,c                   ; change mode.
                NOP

                Push    "lr"
                MOV     r0, #Event_RS423Error
                SWI     XOS_GenerateEvent	; and then generate event
                Pull    "lr"                    ; preserve SVC LR

                RestPSR r3,,cf                  ; restore original mode
                NOP

                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		END

@


4.4
log
@  Merge of 32-bit branch.
Detail:
  This version represents the merge of the 32-bit conversion of the DualSerial
    module.
Admin:
  This module has received a modest amount of testing, however, it has not
    been exhaustively tested.  Projects taking this version should be careful
    of it as it may contain bugs.

Version 0.25. Tagged as 'DualSerial-0_25'
@
text
@d282 1
a282 1
give_event      ENTRY   "r0-r3"
@


4.4.2.1
log
@Second attempt to check this in.

Version 0.25, 4.8.2.2. Tagged as 'DualSerial-0_25-4_8_2_2'
@
text
@d31 15
a45 6
handle_irq	EntryS	"r9"
                LDR     r9, HAL_StaticBase
                CallHAL HAL_UARTInterruptID
                CMP     r0, #-1                         ; any interrupts ?
                BNE     %FT20
	        EXITS
d48 1
a48 1
                CallHAL HAL_UARTInterruptID
d50 3
a52 2
                CMP     r0, #-1                   ; if no more interrupt causes
                BEQ     irq_exit		  ; leave the poll loop
d55 3
a57 3
		LDR	r1, InterruptCount
		ADD	r1, r1, #1
		STR	r1, InterruptCount
d59 1
a59 1
                TEQ     r0, #IID_line_status
d61 3
a63 2
                TEQ     r0, #IID_RX_full
		TEQNE	r0, #IID_char_timeout
d65 1
a65 1
                TEQ     r0, #IID_TX_empty
d73 1
a73 1
                CallHAL HAL_UARTModemStatus
d110 2
a111 5

                SUB     sp, sp, #4
                MOV     r1, sp
                CallHAL HAL_UARTReceiveByte
                LDR     r0, [sp], #4
d148 1
a148 3
                MOV     r1, #0
                CallHAL HAL_UARTReceiveByte
                MOV     r2, r0
d184 1
a184 2
                LDRNEB  r0, FIFOSize
                SUBNE   r0, r0, #1
a190 1
                Push    "lr"
d236 2
a237 3
                MOV     r1, r2
                CallHAL HAL_UARTTransmitByte
                Pull    "pc"
d242 3
a244 3
                MOV     r1, #0
                MVN     r2, #IER_transmit_empty
                CallHAL HAL_UARTInterruptEnable
d249 1
a249 1
                Pull    "pc"
d256 2
a257 2
                CallHAL HAL_UARTLineStatus
		TST	r0, #LSR_data_ready
d276 1
d287 4
a290 1
                ORR     lr, r3, #2_00011        ; up to appropriate SVC mode
@


4.4.2.2
log
@Change to use objasm (the non HAL one already has): fixes report that
it blew messagetrans away when rmkilled.
Change to have a zero in the command table word: fixes report that
serialinfo and serialtest don't do anything,indeed they don't in this
HAL version!

Version 0.25, 4.8.2.7. Tagged as 'DualSerial-0_25-4_8_2_7'
@
text
@d278 1
a278 1
give_event      Entry   "r0-r3"
@


4.4.2.3
log
@Changes from Kevin: support for clearing the interrupt when it has been
serviced using HAL_IRQClear.

Version 0.25, 4.8.2.8. Tagged as 'DualSerial-0_25-4_8_2_8'
@
text
@d36 1
a36 3
irq_done        LDR     r0, IRQDeviceNumber
                CallHAL HAL_IRQClear, noport
                EXITS
d259 1
a259 1
                BCC     irq_done            	; no more bytes to be sent
a264 1

@


4.4.2.4
log
@Rewrite module to add support for acting as a client of SerialSupport
Detail:
  In order to act as a client of SerialSupport, DualSerial needs to support the set of device calls that SerialSupport uses to talk to the serial driver.
  This set of device calls operates at a lower level than the IOCtl interface which DualSerial already supports.
  Therefore simply adding the new device call interface ontop of DualSerial (or modifying SerialSupport to add IOCtl support) would have been a risky venture, due to the many complexities hidden in the Serial module sources.
  So to reduce the amount of risk inherent in the change, I've instead taken the Serial module, stripped out 6551 support, rewritten the 710 interface to use HAL calls, and then bolted the IOCtl interface on top.
  This should ensure the SerialSupport/OS_SerialOp interface is identical to that provided by the Serial module, and only the simpler to understand DualSerial/IOCtl interface is the one likely to contain any bugs.
  File changes:
  - Docs/serial.htm - Added a copy of the IOCtl interface docs, from the Ursula branch
  - s/common, s/errors, s/init, s/macros, s/main - New implementation of the module, based around modified Serial sources
  - s/serialhal - The business end of the module, based around s/Serial710 in the Serial sources
  - s/ioctl - New file containing reimplemented IOCtl interface
  - s/devicecall, s/hardware, s/interrupts, s/standalone - Deleted redundant files from old implementation
  - Makefile - Trimmed somewhat redundant comment
  - resources/UK/messages - Added new error messages
Admin:
  Tested in OMAP3 & Tungsten ROMs


Version 0.25, 4.8.2.11. Tagged as 'DualSerial-0_25-4_8_2_11'
@
text
@@


4.3
log
@Makefile changed to use LocalRes$Path.
Changed to use srccommit.
Spinner branch merged.

Version 0.17. Tagged as 'DualSerial-0_17'
@
text
@d31 1
a31 1
handle_irq	ENTRY	"r10-r11"
d286 6
a291 4
                MOV     lr, pc
                AND     lr, lr, #3
                EOR     r3, lr, #SVC_mode       ; switch into SVC mode
                TEQP    r3, pc
d299 1
a299 1
                TEQP    r3, pc                  ; restore original mode
d302 1
a302 1
                EXITS
@


4.3.2.1
log
@  32-bit compatible.
Detail:
  Hopefully, this is fully 32-bit compatible.  If not, the area of concern
    is likely to be interrupts.s.  The DeviceFS entry point dispatcher has
    been modified to preserve all flags except V across the entry point to
    relieve each routine of the burden of doing this.
Admin:
  Not tested, hence imported only onto the branch.

Version 0.24, 4.7.2.1. Tagged as 'DualSerial-0_24-4_7_2_1'
@
text
@d31 1
a31 1
handle_irq	EntryS	"r10-r11"
d286 4
a289 1
                WritePSRc SVC_mode,lr,,r3
d297 1
a297 1
                RestPSR r3,,cf                  ; restore original mode
d300 1
a300 1
                EXIT
@


4.3.2.2
log
@  Fixed interrupt hole in give_event.
Detail:
  IRQ and FIQ disable bits were being forced clear in give_event.
  Previously they were preserved during the mode change to SVC mode.
  May help solve the lockups on 32-bit builds.
Admin:
  Untested - examined object code and I believe it is now correct.

Version 0.24, 4.7.2.2. Tagged as 'DualSerial-0_24-4_7_2_2'
@
text
@d286 1
a286 6
                SavePSR r3
                BIC     lr, r3, #2_11111        ; clear mode bits
                TEQ     pc, pc                  ; In a 32-bit mode?  EQ if so
                ORREQ   lr, lr, #SVC32_mode     ; set SVC32 mode if in IRQ32
                ORRNE   lr, lr, #SVC_mode       ; set SVC26 mode if in IRQ26
                RestPSR lr,,c                   ; change mode.
@


4.2
log
@Version Spin_merge taken
@
text
@a31 1

d35 1
d40 1
d171 5
@


4.2.2.1
log
@Rightio, we'll try for a real log this time...

Files deleted due to CVSs incompetency in replacing them with newer
differently named ones. Next, you'll see the new files arrive, with
a more descriptive log of what & why.
@
text
@@


4.2.6.1
log
@Made buffer threshold changes take effect immediately instead of next time a stream is opened.
@
text
@d32 1
a35 1

a39 1

a169 5
 [ counting
		LDRCS	r0, BufferOverrun
		ADDCS	r0, r0, #1
		STRCS	r0, BufferOverrun
 ]
@


4.1
log
@Initial revision
@
text
@d32 1
a35 1

a39 1

a169 5
 [ counting
		LDRCS	r0, BufferOverrun
		ADDCS	r0, r0, #1
		STRCS	r0, BufferOverrun
 ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a31 1

d35 1
d40 1
d171 5
@


4.1.7.2
log
@Imported from SrcFiler
@
text
@d32 1
a35 1

a39 1

a169 5
 [ counting
		LDRCS	r0, BufferOverrun
		ADDCS	r0, r0, #1
		STRCS	r0, BufferOverrun
 ]
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@

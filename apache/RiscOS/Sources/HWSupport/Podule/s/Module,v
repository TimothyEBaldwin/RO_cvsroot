head	4.22;
access;
symbols
	Podule-1_72:4.22
	Podule-1_71:4.22
	Podule-1_70:4.22
	Podule-1_69:4.22
	Podule-1_68:4.21
	Podule-1_67:4.21
	Podule-1_66:4.20
	Podule-1_65:4.19
	Podule-1_64:4.18
	Podule-1_63:4.18
	Podule-1_62:4.17
	Podule-1_61:4.17
	RO_5_07:4.17
	Podule-1_60:4.17
	Podule-1_59:4.16
	Podule-1_58:4.15
	dellis_autobuild_BaseSW:4.14
	Podule-1_57:4.14
	Podule-1_56:4.13
	Podule-1_55:4.12
	Podule-1_54:4.11
	Podule-1_53:4.10
	sbrodie_sedwards_16Mar2000:4.9
	Podule-1_52:4.9
	Podule-1_51:4.8
	Podule-1_50:4.7
	dcotton_autobuild_BaseSW:4.15
	Ursula_merge:4.3.2.1
	Podule-1_49:4.6
	nturton_Podule-1_48:4.5
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3.2.1
	Ursula_RiscPC:4.3.2.1.0.2
	nicke_Podule_47:4.1.7.2
	rthornb_UrsulaBuild-19Aug1998:4.3.2.1
	UrsulaBuild_FinalSoftload:4.3.2.1
	rthornb_UrsulaBuild-12Aug1998:4.3.2.1
	aglover_UrsulaBuild-05Aug1998:4.3.2.1
	rthornb_UrsulaBuild-29Jul1998:4.3.2.1
	rthornb_UrsulaBuild-22Jul1998:4.3.2.1
	rthornb_UrsulaBuild-15Jul1998:4.3.2.1
	rthornb_UrsulaBuild-07Jul1998:4.3.2.1
	rthornb_UrsulaBuild-17Jun1998:4.3.2.1
	rthornb_UrsulaBuild-03Jun1998:4.3.2.1
	rthornb_UrsulaBuild-27May1998:4.3.2.1
	rthornb_UrsulaBuild-21May1998:4.3.2.1
	rthornb_UrsulaBuild_01May1998:4.3.2.1
	afrost_NC2_Generic:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spinner_B10:4.1.7.2
	Daytona:4.3.0.6
	Daytona_bp:4.3
	Ursula:4.3.0.2
	Ursula_bp:4.3
	Spinner_B7:4.1.7.2
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	ARTtmp:4.1.7.2.0.2
	RCA:4.3.0.4
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.22
date	2013.01.27.11.20.16;	author rsprowson;	state Exp;
branches;
next	4.21;
commitid	0fcQKXShjp725QBw;

4.21
date	2012.06.09.11.17.29;	author rsprowson;	state Exp;
branches;
next	4.20;
commitid	bHHBI9xgv72rw18w;

4.20
date	2012.05.07.21.42.19;	author rsprowson;	state Exp;
branches;
next	4.19;
commitid	PsfVaoQkTwky2Q3w;

4.19
date	2012.03.17.17.47.13;	author rsprowson;	state Exp;
branches;
next	4.18;
commitid	iDYLNZ9CAtlyngXv;

4.18
date	2011.06.22.00.43.21;	author jlee;	state Exp;
branches;
next	4.17;
commitid	rqS4xrdehUNomBov;

4.17
date	2002.11.04.21.43.07;	author rsprowson;	state Exp;
branches;
next	4.16;

4.16
date	2002.10.26.11.57.12;	author rsprowson;	state Exp;
branches;
next	4.15;

4.15
date	2001.06.06.15.50.44;	author sbrodie;	state Exp;
branches;
next	4.14;

4.14
date	2000.08.18.16.23.24;	author rcathera;	state Exp;
branches;
next	4.13;

4.13
date	2000.08.18.15.59.16;	author rcathera;	state Exp;
branches;
next	4.12;

4.12
date	2000.08.18.11.44.13;	author rcathera;	state Exp;
branches;
next	4.11;

4.11
date	2000.04.28.12.33.44;	author kbracey;	state Exp;
branches;
next	4.10;

4.10
date	2000.04.12.09.25.25;	author pskirrow;	state Exp;
branches;
next	4.9;

4.9
date	2000.01.13.13.39.39;	author pskirrow;	state Exp;
branches;
next	4.8;

4.8
date	2000.01.12.17.14.16;	author pskirrow;	state Exp;
branches;
next	4.7;

4.7
date	99.10.25.16.34.13;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.08.04.14.40.13;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	98.10.29.18.51.13;	author nturton;	state Exp;
branches;
next	4.4;

4.4
date	98.09.03.15.59.27;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	97.01.29.13.33.28;	author nturton;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.01.20.13.50.04;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.37.00;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	98.03.27.15.17.52;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.37.00;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.36.48;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.39.07;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.51.58;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.01.29.15.12.44;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.22
log
@Change selection of FakePodule switch
Now required to be passed in from the components file (with -PD) before inclusion.
Tested briefly in IOMD softload.

Version 1.69. Tagged as 'Podule-1_69'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        TTL     The Podule manager.
        SUBT    Module header => Podule.s.Module

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Name  Description
; ----       ----  -----------
; 12-Jan-00  PMS   Added fake podule header for EtherI interface.
; 28-Apr-00  KJB   Made 32-bit compatible.
; 27-Aug-02  RPS   Now determines as much as possible at run time
; 20-Oct-02  RPS   Got rid of the large precalculated linked list,and now generate the podule nodes dynamically

MySWIChunkBase * Module_SWISystemBase + PoduleSWI * Module_SWIChunkSize
        ASSERT  MySWIChunkBase = Podule_ReadID

Origin
        DCD     0
        DCD     InitModule - Origin                     ; Initialisation
        DCD     KillModule - Origin                     ; Finalisation
        DCD     ServiceEntry - Origin
        DCD     ModuleTitle - Origin
        DCD     HelpString - Origin
        DCD     CommandTable - Origin
        DCD     MySWIChunkBase
        DCD     SWIEntry - Origin
        DCD     SWINameTable - Origin
        DCD     0
 [ International_Help <> 0
        DCD     message_filename - Origin
 |
        DCD     0
 ]
        DCD     Flags - Origin

        GBLL    DebugModule
DebugModule     SETL    ( :LNOT: ReleaseVersion ) :LAND: {FALSE}

        GBLL    DebugInterface
DebugInterface  SETL    ( :LNOT: ReleaseVersion ) :LAND: {FALSE}

        GBLL    DebugCommands
DebugCommands   SETL    ( :LNOT: ReleaseVersion ) :LAND: {FALSE}

        GBLL    DebugLoader
DebugLoader     SETL    ( :LNOT: ReleaseVersion ) :LAND: {FALSE}

        GBLL    DebugMssgs
DebugMssgs      SETL    ( :LNOT: ReleaseVersion ) :LAND: {FALSE}

        GBLL    DebugInit
DebugInit       SETL    {FALSE}

        ; The following switches are really only of use to make the module a bit smaller

        [ :LNOT: :DEF:  NumberOfPodules
                GBLL    NumberOfPodules
NumberOfPodules SETL    8
        ] 

                GBLL    EASISpace
EASISpace       SETL    {TRUE}

        ; The reassigned interrupts nick the NIC interrupt for podule 0
        ASSERT  :LNOT: (ReassignedIOMDInterrupts :LAND: NetPodSupport)

                GBLL    NetworkPodule
NetworkPodule   SETL    NetPodSupport

                GBLL    ExtensionROMs
ExtensionROMs   SETL    ExtROMSupport

        [ NetworkPodule
MaximumPodule           *       NumberOfPodules + 1
NumberOfNetworkPodule   *       MaximumPodule - 1
        |   
MaximumPodule           *       NumberOfPodules
        ]

        [       :LNOT: ReleaseVersion
        [       NetworkPodule
        !       0, "Including support code for the NetworkPodule"
        |
        !       0, "No support for the NetworkPodule"
        ]
        [       ExtensionROMs
        !       0, "Including support code for Extension ROMs"
        |
        !       0, "No support for Extension ROMs"
        ]
        ]


FixedExtROMStart        *       &03800000               ; used when the Kernel is so old it wont tell us
Maxint                  *       &7FFFFFFF               ; magic

; IOMD capabilities format

        ^       0

Capability_DMAChannels          #       9*4             ; list of 9 pointers to DMA channel numbers (mandatory)
Capability_Features             #       4               ; this table could be extended to move IRQB and so on around
Capability_PodCount             #       4
Capability_SpeedHelper          #       4               ; code to set the speed
Capability_AddressPointers      #       9*4             ; list of 9 pointers to default podule blocks (not all required)
Capability_NIC                  *       1
Capability_IOCPod               *       2
Capability_MEMCPod              *       4
Capability_PodFIQs              *       8
Capability_PodIRQs              *       16
Capability_PodFIQsasIRQs        *       32

; Podule descriptor format
; First few are held in "NodeStatics",middle 3 are guessed at run time,rest are IOMD specific

        ^       0

PoduleNode_Link                 #       4               ; Offset from start of workspace to next podule (zero if last)
                                                        ; joined up in the order MaximumPodule... > 2 > 1 > 0 > -2 > -3
                                                        ; links for 0 to 3 probably not used
PoduleNode_LoaderOffset         #       4               ; Offset from start of workspace to loader
PoduleNode_PoduleLimit          #       4               ; Highest numbered chunk in podule space, or Maxint if not yet known
PoduleNode_EnumerationLimit     #       4               ; Highest numbered chunk we've seen in podule space, or -1 if
                                                        ; not seen any
PoduleNode_WordOffset           #       4               ; Offset from one word to next
PoduleNode_ByteOffsets          #       16              ; Offset from start of word to byte 0,1,2,3
PoduleNode_DescriptionOffset    #       4               ; Zero or offset from start of workspace to description
PoduleNode_Type                 #       2               ; Type (actually a half-word)
PoduleNode_Flags                #       1               ; bit0 => ROM is IOC podule, bit1 => ROM is EASI, bit2 => ROM is NIC
PoduleNode_IDByte               #       1               ; ID byte (byte 0) for each podule
PoduleNode_CombinedAddress      #       4
PoduleNode_DMA                  #       4
PoduleNode_EASIAddress          #       4
PoduleNode_BaseAddress          #       4               ; Hardware base of podule, or address of fake header
                                                        ; in Podule manager code in the case of fake podules
PoduleNode_MEMCAddress          #       4
PoduleNode_ROMAddress           #       4               ; Address of start of image in ROM (for extension ROMs)
PoduleNode_FIQasIntMask         #       4
PoduleNode_IntMask              #       4
PoduleNode_FIQMask              #       4
PoduleNode_FIQasIntStatus       #       4
PoduleNode_IntStatus            #       4
PoduleNode_FIQStatus            #       4
PoduleNode_FIQasIntRequest      #       4
PoduleNode_IntRequest           #       4
PoduleNode_FIQRequest           #       4
PoduleNode_FIQasIntDeviceVector #       4
PoduleNode_IntDeviceVector      #       4
PoduleNode_CMOS                 #       4               ; CMOS base address
PoduleNode_SpareByte            #       1
PoduleNode_IntValue             #       1
PoduleNode_FIQasIntValue        #       1
PoduleNode_FIQValue             #       1
PoduleNode_Size                 *       :INDEX: @@       ; size of node for normal podules
           [ :LNOT: ReleaseVersion
           !  0, "A node record is &" :CC: ((:STR: PoduleNode_Size) :RIGHT: 2) :CC: " bytes long"
           ]
PoduleNode_Checksum             #       4               ; ROM checksum (used to identify unique ROMs)
ROMNode_Size                    *       :INDEX: @@       ; size of node for extension ROMs
           [ :LNOT: ReleaseVersion
           !  0, "A ROM node record is &" :CC: ((:STR: ROMNode_Size) :RIGHT: 2) :CC: " bytes long"
           ]

; Workspace layout

        ^       0,      wp

InitialisationData

        Byte    SegmentHeader, 16
        DCD     -1
        DCD     -1
        DCD     -1
        DCD     -1

        Word    message_file_block, 4                   ; File handle for MessageTrans
        DCD     -1
        DCD     -1
        DCD     -1
        DCD     -1
        Word    message_file_open                       ; Opened message file flag
        DCD     0                                       ; Flag that the message file is closed

        Word    SSpaceStart
        DCD     0

        Word    Capabilities                            ; Pointer to table of IOMD capabilities in the module,if any
        DCD     0

        Word    NumberOfExtROMs                         ; How many extension roms there are
        DCD     0                                       ; There are no extension ROMs currently
        [       ExtensionROMs
        Word    StartOfROM
        DCD     -1
        Word    EndOfROM
        DCD     -1
        ]

        Word    AddressOfMyPrivateWord
        DCD     0

        Word    NodeListHead                            ; Offset within wp of the node list (zero is end)
        DCD     0

        Word    OffsetOfNextLoader
        DCD     TotalRAMRequired


 [ :DEF: FakePodule
; ****************************************************************************
;
;       Fake podules - the podule manager can be assembled with built in podule headers
;                      to save having to put a ROM on the PCB for embedded applications
;                      see "Doc.FakePods" for more information
   [ FakePodule = 0
FakePodule SETA FakePodule0 ; inherit from Machine/Machine, else from Components file
   ]
        ; We only know how to fake up STB2 MPEG1, MPEG2 (and MPEG0) podules and EtherI Podule
        ASSERT (FakePodule = ProdType_STB2_MPEG1) :LOR: \
               (FakePodule = ProdType_STB2_MPEG2) :LOR: (FakePodule = ProdType_EtherI)
        ! 0,    "Assembling Podule Manager with fake podule header, (type $FakePodule)"

                MACRO
                CHUNK $type,$contents,$description,$end
                ; Podule chunk directories in the header are 8 bytes (see PRM4-128):
                DCD     $type                           ; Type: High nybble will be &F for NC
$len            *       ($end  - $desc)/4               ; Length of field
$offset         *       ($desc - $contents)/4           ; Offset of field from start
                DCD      $len :AND: &FF                 ; Size in bytes
                DCD     ($len :SHR:     8) :AND &FF
                DCD     ($len :SHR:    16) :AND &FF
                DCD      $offset :AND: &FF              ; Offset to chunk string
                DCD     ($offset :SHR:  8) :AND &FF
                DCD     ($offset :SHR: 16) :AND &FF
                DCD     ($offset :SHR: 24) :AND &FF
                MEND

                MACRO
                PODCHUNK $type,$contents,$desc,$end
                LCLA len
                LCLA offset
                DCD     $type                           ; Type: High nybble will be &F for NC
; len           SETA    ($end  - $desc)/4               ; Length of field
; offset        SETA    ($desc - $contents)/4           ; Offset of field from start
                DCD      (($end  - $desc)/4) :AND: &FF                  ; Size in bytes
                DCD     ((($end  - $desc)/4) :SHR:  8) :AND: &FF
                DCD     ((($end  - $desc)/4) :SHR: 16) :AND: &FF
                DCD      (($desc - $contents)/4) :AND: &FF              ; Offset to chunk string
                DCD     ((($desc - $contents)/4) :SHR:  8) :AND: &FF
                DCD     ((($desc - $contents)/4) :SHR: 16) :AND: &FF
                DCD     ((($desc - $contents)/4) :SHR: 24) :AND: &FF
                MEND

   [ FakePodule = ProdType_STB2_MPEG1 :LOR: FakePodule = ProdType_STB2_MPEG2
MachineConfig   *       (IOMD_Base + IOMD_CLINES)
MPEGfittedbit   *       IOMD_C_MPEGfitted
MPEGIDByte      *       0
   ]

   [ FakePodule = ProdType_STB2_MPEG1 :LOR: FakePodule = ProdType_STB2_MPEG2
MPEG0descoff    *       (MPEG0desc - MPEG0contents)/4           ; offset of description from start
MPEG0desclen    *       (MPEG0end  - MPEG0desc)/4               ; length of description
MPEG0contents   DCD     &00, &02, &00, (ProdType_STB2_MPEG0 :AND: &FF), (ProdType_STB2_MPEG0 :SHR: 8)
                DCD     (Manf_OnlineMedia :AND: &FF), (Manf_OnlineMedia :SHR: 8), &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
                DCD     &f5, MPEG0desclen, &00, &00, MPEG0descoff, &00, &00, &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
MPEG0desc       DCB     "Internal video hardware",0
MPEG0end
                ALIGN
     [ FakePodule = ProdType_STB2_MPEG1

MPEG1descoff    *       (MPEG1desc - MPEG1contents)/4           ; offset of description from start
MPEG1desclen    *       (MPEG1end  - MPEG1desc)/4               ; length of description
MPEG1contents   DCD     &00, &02, &00, (ProdType_STB2_MPEG1 :AND: &FF), (ProdType_STB2_MPEG1 :SHR: 8)
                DCD     (Manf_OnlineMedia :AND: &FF), (Manf_OnlineMedia :SHR: 8), &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
                DCD     &f5, MPEG1desclen, &00, &00, MPEG1descoff, &00, &00, &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
MPEG1desc       DCB     "Internal MPEG1 hardware",0
MPEG1end
                ALIGN
     |

MPEG1descoff    *       (MPEG1desc - MPEG1contents)/4           ; offset of description from start
MPEG1desclen    *       (MPEG1end  - MPEG1desc)/4               ; length of description
MPEG1contents   DCD     &00, &02, &00, (ProdType_STB2_MPEG2 :AND: &FF), (ProdType_STB2_MPEG2 :SHR: 8)
                DCD     (Manf_OnlineMedia :AND: &FF), (Manf_OnlineMedia :SHR: 8), &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
                DCD     &f5, MPEG1desclen, &00, &00, MPEG1descoff, &00, &00, &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
MPEG1desc       DCB     "Internal MPEG2 hardware",0
MPEG1end
                ALIGN
     ]
   ]

   [ FakePodule = ProdType_EtherI
EtherIcontents  DCD     &00                             ; Interrupts, IRQ and FIQ are relocated
                DCD     &03                             ; Interrupt Status Pointers and Chunk dir follow ECId
                DCD     &00                             ; Reserved
                DCD     (ProdType_EtherI :AND: &FF)     ; Product type low byte
                DCD     (ProdType_EtherI :SHR: 8)       ; Product type hight byte
                DCD     (Manf_AcornUK :AND: &FF)        ; Manufacturer code, low byte
                DCD     (Manf_AcornUK :SHR: 8)          ; Manufacturer code, high byte
                DCD     0                               ; Country code (0=UK)
                DCD     0, 0, 0, 0, 0, 0, 0, 0          ; Interrupt status pointers
                ; Chunks follow:
                PODCHUNK &f5, EtherIcontents, EtherIdesc, EtherIdescend ; Description: "10baseT Ethernet..."
                PODCHUNK &f3, EtherIcontents, EtherImod, EtherImodend   ; Modifications status byte: 4

                DCD     0, 0, 0, 0, 0, 0, 0, 0          ; End of chunk directory
EtherIdesc      DCB     "10BaseT Ethernet 64k buffer (A cycles)",0
EtherIdescend
EtherImod       DCD     '4', 0          ; Modification byte
EtherImodend
   ]
 ] ; :DEF: FakePodule
 
; *****************************************************************************************************************
;
;       ExtensionROMLoader - Loader for reading extension ROM
;
        [       ExtensionROMs

ExtensionROMLoader
        B       ROMLoaderReadByte                       ; read a byte
        B       ROMLoaderError                          ; write a byte
        MOV     pc, lr                                  ; reset
        MOV     pc, lr                                  ; SWI Podule_CallLoader
        =       "32OK"

; ROMLoaderReadByte - Read a byte from extension ROM
;
; in:   R1 = address within ROM
;       R3 -> podule descriptor node *** NOTE actual address not offset from wp ***
;       R11 = "combined hardware address", ie ROM address in the case of extension ROMs
;       V clear
;
; out:  R0 = byte read
;       R1, R4-R9, R11,R12 preserved
;       R2,R3,R10 corrupted
;

ROMLoaderReadByte ROUT
        AND     r10, r1, #3                             ; get byte number
        ADD     r10, r3, r10, LSL #2
        LDR     r10, [r10, #PoduleNode_ByteOffsets]     ; r10 = offset from start of that word
        MOV     r2, r1, LSR #2                          ; r2 = word number
        LDR     r0, [r3, #PoduleNode_WordOffset]
        MLA     r10, r0, r2, r10                        ; r10 = byte offset in actual ROM
        LDRB    r0, [r11, r10]                          ; r0 = byte read
        MOV     pc, lr

ROMLoaderError
        SETV
        ADR     r0, ErrorAccess
        MOV     pc, lr

ExtensionROMLoaderEnd

        Byte    ROMLoader, ExtensionROMLoaderEnd - ExtensionROMLoader
        ]

; *****************************************************************************************************************
;
;       NetworkROMLoader - Loader for reading the ROM on the network card
;
        [       NetworkPodule
NetworkPoduleLoader
        B       NetworkLoaderReadByte                   ; Read a byte
        B       NetworkLoaderError                      ; Write a byte
        B       NetworkLoaderReset                      ; Reset
        MOV     pc, lr                                  ; SWI Podule_CallLoader
        =       "32OK"

;       The network ROM lives at address 'NetworkROMAddress' (R11)
;       Writes to that address reset a 12 bit counter attached to the
;       low order 12 bits of the ROMs address lines.  The address lines
;       above that are attached to LA2, LA3, LA4, etc.  So to read
;       consecutive bytes one reads location NetworkROMAddress 4096
;       times then NetworkROMAddress + 4 4096 times etc.

; NetworkLoaderReadByte - Read a byte from the Network Podule ROM
;
; in:   R1 = address within ROM
;       R3 -> podule descriptor node *** NOTE actual address not offset from wp ***
;       R11 = ROM base address
;
; out:  R0 = byte read
;       R2, R10, R11 corrupted
;       R1, R3-R9, R12 preserved

NetworkLoaderReadByte ROUT
        LDR     r2, BaseAddressANDMask
        AND     r11, r11, r2                            ; Reduce a combined address to the ROM address
        MOV     r2, r1, LSL #32-12
        MOV     r2, r2, LSR #32-12                      ; Now just the page offset
        MOV     r10, r1, LSR #12                        ; Page number
        CMP     r10, #&00000100                         ; Is this a viable address?
        BHS     NetworkLoaderTooBig
        ADD     r11, r11, r10, LSL #2                   ; Address to use to read the byte
        LDR     r10, NetworkPageCounter                 ; Soft copy of the value in the counter H/W
NetworkCounterLoop
        CMP     r2, r10                                 ; Is this the byte we want?
        LDRB    r0, [ r11, #0 ]                         ; Read it and increment the counter
        INC     r10                                     ; Increment the soft copy
   ;    BICEQ   r10, r10, #&000FF000                    ; Make sure the counter doesn't overflow
        STREQ   r10, NetworkPageCounter                 ; Update the soft copy
        MOVEQ   pc, lr                                  ; Return to the caller (V will be clear if EQ)
        BGT     NetworkCounterLoop                      ; And try again
        MOV     r10, #0
        STR     r10, NetworkPageCounter                 ; Reset the soft copy
        STRB    r10, [ r11, #0 ]                        ; Reset the counter
        STRB    r10, [ r11, #0 ]                        ; Reset the counter
   ;    STRB    r10, [ r11, #0 ]                        ; Reset the counter
        [       DebugLoader
        LDRB    r6, [ r11, #0 ]
        LDRB    r5, [ r11, #0 ]
        ORR     r6, r6, r5, LSL #8
        LDRB    r5, [ r11, #0 ]
        ORR     r6, r6, r5, LSL #16
        LDRB    r5, [ r11, #0 ]
        ORR     r6, r6, r5, LSL #24
        STRB    r10, [ r11, #0 ]                        ; Reset the counter
        STRB    r10, [ r11, #0 ]                        ; Reset the counter
   ;    STRB    r10, [ r11, #0 ]                        ; Reset the counter
        LDRB    r7, [ r11, #0 ]
        LDRB    r5, [ r11, #0 ]
        ORR     r7, r7, r5, LSL #8
        LDRB    r5, [ r11, #0 ]
        ORR     r7, r7, r5, LSL #16
        LDRB    r5, [ r11, #0 ]
        ORR     r7, r7, r5, LSL #24
        STRB    r10, [ r11, #0 ]                        ; Reset the counter
        STRB    r10, [ r11, #0 ]                        ; Reset the counter
   ;    STRB    r10, [ r11, #0 ]                        ; Reset the counter
        MOV     r5, pc                                  ; Set flag to say reset occured
        ]
        B       NetworkCounterLoop                      ; And try again

NetworkLoaderError
        SETV
        ADR     r0, ErrorAccess
        MOV     pc, lr
        
NetworkLoaderTooBig
        SETV
        ADR     r0, ErrorNetworkLoaderTooBig
        MOV     pc, lr

ErrorNetworkLoaderTooBig
        DCD     ErrorNumber_AddressRange
        DCB     "AddressRange",0
        ALIGN

NetworkPageCounter                                      ; This is the soft copy
        DCD     0                                       ; This is OK because this is in RAM

BaseAddressANDMask
        DCD     Podule_BaseAddressANDMask

; NetworkLoaderReset
;
; in:   R11 = ROM base address
;       V clear
;
; out:  R2, R11 corrupted

NetworkLoaderReset ROUT
        LDR     r2, BaseAddressANDMask
        AND     r11, r11, r2
        MOV     r2, #0
        STRB    r2, [ r11, #0 ]                         ; Reset the counter
        STR     r2, NetworkPageCounter
        MOV     pc, lr

NetworkLoaderEnd

        Byte    NetworkLoader, NetworkLoaderEnd - NetworkPoduleLoader
        ]

        [ ExtensionROMs :LOR: NetworkPodule 
ErrorAccess
        DCD     ErrorNumber_PoduleReadOnly
        DCB     "PoduleReadOnly", 0
        ALIGN
ErrorAccessEnd
        #       ErrorAccessEnd-ErrorAccess
        ]

; *****************************************************************************************************************
;
;       Not32bitLoader - Dummy loader substituted for non 32-bit compatible ones
;

Not32bitDummyLoader
        B       Not32bitLoaderError                     ; read a byte
        B       Not32bitLoaderError                     ; write a byte
        MOV     pc, lr                                  ; reset (nothing to reset...)
        B       Not32bitLoaderError                     ; SWI Podule_CallLoader
        =       "32OK"

; in:   We know r12 is the Podule Manager global workspace. Use it to look up
;       the error

Not32bitLoaderError
        SETV
        ADR     r0, ErrorLoader26bit
        MOV     pc, lr

Not32bitLoaderEnd

        Byte    Not32bitLoader, Not32bitLoaderEnd - Not32bitDummyLoader

        AlignSpace      16

        Word    EndOfInitialisationData, 0
        [       :LNOT: ReleaseVersion
        !       0, "The end of initialisation data is at &" :CC:((:STR:(:INDEX:EndOfInitialisationData)):RIGHT:4)
        ]

        ;       The area after here is initialised to -1s

InfoBufLength * &40                                     ; buffer length for title and help strings

        Byte    RMName, InfoBufLength
        Byte    RMHelp, InfoBufLength
        Byte    ErrorLoader26bit, InfoBufLength
        Byte    ErrorReadOnly, InfoBufLength
        Byte    ErrorOffEnd, InfoBufLength

        Word    EndOfInitialisationArea, 0

TotalRAMRequired *      :INDEX: @@
        [       :LNOT: ReleaseVersion
        !       0, "Total RAM required is &" :CC: ((:STR: TotalRAMRequired) :RIGHT: 4) :CC: " bytes"
        ]

        SUBT    Module entry stuff
        OPT     OptPage

HelpString
        DCB     "Podule Manager", 9, "$Module_HelpVersion"

        [       :LNOT: ReleaseVersion
        =       " ["
        [       EASISpace
        =       "+EASI"
        ]
        [       NetworkPodule
        =       "+NIC"
        ]
        [       ExtensionROMs
        =       "+ROMS"
        ]
        =       "] (development version)"
        ]
        =       0
        ALIGN

Flags
  [ No32bitCode
        DCD     0
  |
        DCD     ModuleFlag_32bit
  ]

        SUBT    Initialisation code
        OPT     OptPage

InitModule ROUT
        Push    "lr"
  [ ( DebugModule :LOR: DebugInterface :LOR: DebugCommands ) :LAND: DebugInit
        InsertTMLInitialisation 0
        BVS     ExitInitModule
  ]
        LDR     r2, [ r12 ]
        TEQ     r2, #0
 [ DebugModule
        BEQ     HardInit
        DLINE   "Podule - ReInit"
 ]
        MOVNE   r1, #0                                  ; If we already have workspace, then
        STRNE   r1, [r2, #:INDEX:message_file_open]     ; flag that the message file is closed
        BNE     ReInitialisation
 [ DebugModule
HardInit
        DLINE   "Podule - Init"
 ]
        MOV     r0, #9
        MOV     r1, #0 << 8
        SWI     XOS_Memory
        TEQ     r1, #0
        MOVNE   r0, #0
        STRNEB  r0, [r1]                                ; on hard init,force everyone to read slow (if ECTCR is available)

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =TotalRAMRequired
        SWI     XOS_Module
        BVS     ExitInitModule
      [ DebugModule
        DREG    r2, "Workspace is at &"
        DREG    r12,"Private word is at &"
      ]
        ASSERT  ( ( :INDEX: EndOfInitialisationData ) :AND: 3 ) = 0
        MOV     r3, #0
        ADRL    r5, InitialisationData

InitialisationLoop
        CMP     r3, # :INDEX: EndOfInitialisationData
        LDRLT   r0, [ r5, r3 ]
        MOVGE   r0, #-1
        STR     r0, [ r2, r3 ]                          ; Note that the initialised data is
        INC     r3, 4                                   ; at the start of workspace
        CMP     r3, # :INDEX: EndOfInitialisationArea
        BLT     InitialisationLoop

        MOV     r0, #1                                  ; We've just copied code (the ROM and
        MOV     r1, r2                                  ; network loaders) into our workspace
        ADD     r2, r2, r3
        SWI     XOS_SynchroniseCodeAreas

        MOV     r2, r1

        MOV     r0, #9
        MOV     r1, #4 << 8
        SWI     XOS_Memory
        MOVVS   r1, #IOMD_Base                          ; Kernel's too old,assume IOMD_Base
        STR     r1, [r2, #:INDEX:SSpaceStart]           ; Saves keep asking for it
        TEQ     r1, #0
        MOVEQ   r4, #0                                  ; Get an unknown id
        LDRNEB  r3, [r1, #IOMD_ID1]
        LDRNEB  r4, [r1, #IOMD_ID0]
        ORRNE   r4, r4, r3, LSL#8

        ADRL    r5, KnownIOMDs
        ADD     r3, r5, #(KnownIOMDsEnd-KnownIOMDs)
DynamicIOMD
        LDR     r0, [r5], #4
        TEQ     r0, r4
        BEQ     %FT15
        ADDS    r5, r5, #4
        TEQ     r5, r3
        BNE     DynamicIOMD
        ASSERT  IOMDCapabilities = IOMDUnknownCap
        ADRL    r5, KnownIOMDs+4                        ; There's an IOMD,but it's not in the table!
15
        LDR     r5, [r5]
        ADRL    r3, IOMDCapabilities
        ADD     r5, r3, r5
        STR     r5, [r2, #:INDEX:Capabilities]          ; Absolute address (within the module)
      [ DebugModule
        DREG    r5,"IOMD capabilities table at &"
      ]
18
        LDR     r4, [r5, #Capability_PodCount]
        TEQ     r4, #0                                  ; not a single podule
        BEQ     DynamicExtROMs
        MOV     r1, #PoduleNode_Size
        MUL     r3, r1, r4
        MOV     r0, #ModHandReason_ExtendBlock
        SWI     XOS_Module
        BVS     ExitInitModule
      [ DebugModule
        DREG    r3, "Growing workspace by &"
        DREG    r2, "New workspace at &"
      ]

        LDR     r0, [r2, #:INDEX:OffsetOfNextLoader]
        ADD     r0, r0, r3
        STR     r0, [r2, #:INDEX:OffsetOfNextLoader]    ; wouldn't want to go loading loaders over our linked list!
        MOV     r3, #:INDEX:EndOfInitialisationArea     ; hence the start of the node area
        ADD     r3, r3, r2
        SUB     r4, r4, #1                              ; convert from natural numbers
20
        BL      AddPoduleNode
        BPL     %BT20

DynamicExtROMs
      [ ExtensionROMs
        MOV     r0, #9
        MOV     r1, #5 << 8
        SWI     XOS_Memory                              ; when ExtROMSupport is required,find out where they are
        MOVVS   r1, #FixedExtROMStart
        TEQ     r1, #0
        BEQ     %FT30                                   ; nope,no extension ROMs at all
        STR     r1, [r2, #:INDEX:StartOfROM]
        ADD     r1, r1, #16*1024*1024                   ; may be less than 16M,but we'll find that out later
        STR     r1, [r2, #:INDEX:EndOfROM]
        MOV     r1, #1
        STR     r1, [r2, #:INDEX:NumberOfExtROMs]
        BL      FindExtensionROMs
30
      ]

 [ :DEF: FakePodule

   [ FakePodule = ProdType_STB2_MPEG1 :LOR: FakePodule = ProdType_STB2_MPEG2
        ; Fake MPEG podule ROM Headers
        LDR     r0, [r2, #:INDEX:NodeListHead]
        ADD     r0, r0, r2                              ; make it an absolute address

        MOV     r1, #MPEGIDByte                         ; ID byte for fake MPEG podule
        STRB    r1, [ r0, #PoduleNode_IDByte ]          ; set ID byte to make ConvertR3ToPoduleNode happy

        MOV     r1, #BitZero
        STRB    r1, [ r0, #PoduleNode_Flags ]           ; This is a (fake) Podule

        MOV     r1, #PoduleCMOS
        STR     r1, [ r0,  #PoduleNode_CMOS ]           ; We don't have no CMOS

        MOV     r1, #-1
        STR     r1, [ r0,  #PoduleNode_DMA ]            ; We don't do DMA

        ; See if MPEG is fitted and point the podule ROM address to the appropriate fake header
        ; The description string will be extracted from this block in the normal way when chunks get enumerated
        LDR     r3, =MachineConfig
        LDRB    r1, [r3]
        TST     r1, #MPEGfittedbit
        ADREQL  r1, MPEG0contents
        ADRNEL  r1, MPEG1contents
        STR     r1, [ r0, #PoduleNode_ROMAddress ]      ; Location to read header from
   ]

   [ FakePodule = ProdType_EtherI
        ; Fake EtherI podule ROM
        LDR     r0, [r2, #:INDEX:NodeListHead]
        ADD     r0, r0, r2                              ; make it an absolute address

        MOV     r1, #0                                  ; ID byte for fake EtherI podule
        STRB    r1, [ r0, #PoduleNode_IDByte ]          ; set ID byte to make ConvertR3ToPoduleNode happy

        MOV     r1, #BitZero
        STRB    r1, [ r0, #PoduleNode_Flags ]           ; This is a (fake) Podule

        MOV     r1, #PoduleCMOS
        STR     r1, [ r0,  #PoduleNode_CMOS ]           ; We don't have no CMOS

        MOV     r1, #-1
        STR     r1, [ r0,  #PoduleNode_DMA ]            ; We don't do DMA

        ; We are faking an EtherI podule ROM, so point the podule ROM address to the appropriate fake header
        ; The description string will be extracted from this block in the normal way when chunks get enumerated
        ADR     r1, EtherIcontents
        STR     r1, [ r0, #PoduleNode_ROMAddress ]      ; Location to read header from
   ]
 ] ; :DEF: FakePodule

        BL      LoadAllLoaders                          ; ensure all loaders are loaded

ReInitialisation
        ; in :  Address of workspace in R2
        ;       Address of Private word in R12
      [ DebugModule
        DREG    r2, "Workspace is at &"
        DREG    r12,"Private word is at &"
      ]
        STR     r2, [ r12 ]
        STR     r12, [ r2, #:INDEX:AddressOfMyPrivateWord ]

        MOV     wp, r2
        BL      RedoMessages                            ; Required if rmreinit'd

        CLRV
ExitInitModule
        Pull    "pc"


; Note that due to the module die entry and the service reset code being the same,
; the Messages file gets closed on Service reset. This is not a problem.

KillModule ROUT
ResetAllLoaders
        LDR     wp, [ r12 ]
        MOV     r6, lr
        MOV     r3, #:INDEX:NodeListHead
10
        ASSERT  PoduleNode_Link = 0
        LDR     r3, [ wp, r3 ] 
        TEQ     r3, #0                                  ; check node offset first,there may be none!
        BEQ     %FT15
        BL      ResetLoader
        MOVVS   pc, r6
      [ DebugModule
        DREG    r3,"Reset loader OK at "
      ]
        B       %BT10
15
        BL      close_message_file                      ; close messages file if it is open, marking it closed
        CLRV
        MOV     pc, r6

        ASSERT  Service_Reset < Service_PreReset
        ASSERT  Service_PreReset < Service_TerritoryStarted
ServiceTable
        DCD     0                        ;flags
        DCD     UServiceEntry - Origin
        DCD     Service_Reset
        DCD     Service_PreReset
        DCD     Service_TerritoryStarted
        DCD     0                        ;terminator
        DCD     ServiceTable - Origin    ;table anchor
ServiceEntry ROUT
        MOV     r0, r0                   ;magic instruction
        TEQ     r1, #Service_PreReset
        TEQNE   r1, #Service_Reset
        TEQNE   r1, #Service_TerritoryStarted
        MOVNE   pc, lr
UServiceEntry
        TEQ     r1, #Service_TerritoryStarted           ; we also rely on this to get the messages in the first
                                                        ; place,since we're at the start of ROM and MessageTrans 
                                                        ; itself hasn't started
        BEQ     %FT10

        Push    "r0-r6, lr"
        BL      ResetAllLoaders
        Pull    "r0-r6, pc"
10
        LDR     wp, [ r12 ]
RedoMessages
        Push    "r0,r2,lr"
        ADD     r2, wp, #:INDEX:ErrorLoader26bit        ; Find message strings for internal loaders
        ADRL    r0, ErrorBlock_Ldr26
        BL      SoftloadErrorMssg
        BVS     %FT15
        ADD     r2, wp, #:INDEX:ErrorReadOnly
        ADRL    r0, ErrorBlock_PoduleReadOnly
        BL      SoftloadErrorMssg
        BVS     %FT15
        ADD     r2, wp, #:INDEX:ErrorOffEnd
        ADRL    r0, ErrorBlock_AddressRange
        BL      SoftloadErrorMssg
15
        STRVS   r0, [ sp, #0 ]                          ; Pass back any error message
        Pull    "r0,r2,pc"

        LTORG

; ****************************************************************************
; 
;      AddPoduleNode - Internal routine to fill in a podule node
; 
; in:  R5 -> selected capability table
;      R4 =  podule number
;      R2 -> my workspace
;      R3 -> start of this node (absolute)
;      R0,R1,R6 = temp
; out: R4 decremented (can branch on the flags)
;      R0,R1,R6 = corrupted
;      R3 = updated to -> start of next node
;

AddPoduleNode ROUT
      [ DebugModule
        BREG    r4, "Add node for podule "
      ]
        ASSERT  Capability_DMAChannels = 0
        LDR     r6, [r5, r4, LSL#2]
        STR     r6, [r3, #PoduleNode_DMA]               ; see if the IOMD does DMA
        MOV     r0, #9
        MOV     r1, #1 << 8
        ORR     r1, r1, r4
        Push    "lr"
        SWI     XOS_Memory
        Pull    "lr"
        MOVVS   r1, #0
      [ DebugModule
        DREG    r6, " dma channel "
        TEQ     r1, #0
        BNE     %FT07
        DLINE   " no EASI space"
        BEQ     %FT08
07
        DREG    r1, " found EASI space &"
08
      ]
        STR     r1, [r3, #PoduleNode_EASIAddress]       ; stash EASI space address
        MOV     r6, r4, LSL#2
        ADD     r6, r6, #Capability_AddressPointers
        LDR     r0, [r5, r6]
        ADD     r0, r0, r5                              ; address off the podule constants table in ROM
      [ DebugModule
        DREG    r0," address pointers in table at "
        DREG    r3," node starts at "
      ]
        MOV     r1, #PoduleNode_BaseAddress
        LDR     r6, [r2, #:INDEX:SSpaceStart]
        Push    "r7"
10
        ; Copy and adjust the IOMD base address dependant entries
        LDR     r7, [r0], #4
        TEQ     r7, #0
        BEQ     %FT14
        CMP     r1, #PoduleNode_FIQasIntDeviceVector
        ADDCC   r7, r6, r7                              ; only address correct those which need it
14
        STR     r7, [r3, r1]
        ADD     r1, r1, #4
        TEQ     r1, #PoduleNode_Size
        BNE     %BT10
        Pull    "r7"

        ADRL    r0, NodeStatics                         ; Copy down the fixed entries
        MOV     r1, #PoduleNode_Link
18
        LDR     r6, [r0], #4
        STR     r6, [r3, r1]
        ADD     r1, r1, #4
        TEQ     r1, #PoduleNode_CombinedAddress
        BNE     %BT18

      [ NetworkPodule
        LDR     r6, [r5, #Capability_Features]
        TST     r6, #Capability_NIC
        BEQ     %FT20
        LDR     r6, [r5, #Capability_PodCount]
        ASSERT  NumberOfNetworkPodule = MaximumPodule-1
        SUB     r6, r6, #1
        TEQ     r6, r4
        MOVEQ   r6, #NetworkPoduleLoader-InitialisationData  
        STREQ   r6, [r3, #PoduleNode_LoaderOffset]      ; quick check for the NIC,and force use of built in loader
20
      ]
        LDR     r6, [r3, #PoduleNode_ROMAddress] 
        LDR     r0, [r3, #PoduleNode_CMOS]
        ORR     r0, r0, r6                              ; Calculate the combined address 
        STR     r0, [r3, #PoduleNode_CombinedAddress]

        ; Update the previous end of list pointer
        MOV     r1, #:INDEX:NodeListHead
        SUB     r3, r3, r2                              ; make relative to workspace again
22
        LDR     r0, [r2, r1]
        TEQ     r0, #0
        ASSERT  PoduleNode_Link = 0 
        STREQ   r3, [r2, r1]
      [ DebugModule
        BNE     %FT26
        DREG    r3, " link to next "
26      
      ]
        MOVNE   r1, r0
        BNE     %BT22

        ADD     r3, r3, #PoduleNode_Size
        ADD     r3, r3, r2                              ; should return it absolute
        SUBS    r4, r4, #1
        MOV     pc, lr

; ****************************************************************************
;
;       LoadAllLoaders - Internal routine to load all loaders on initialisation
;
; in:   R12 -> private word
;       R2 -> workspace
;
; out:  R0,R1,R3-R5 corrupted
;       R2 -> workspace (not necessarily where it used to be)
;       All others must be preserved
;
LoadAllLoaders  ROUT
        Push    "r8-r12, lr"
        SUB     sp, sp, #16                             ; Make a frame to work in
      [ DebugModule
        DLINE   "Load All Loaders called"
      ]
        STR     r12, [ r2, #:INDEX:AddressOfMyPrivateWord ]
        STR     r2, [ r12 ]
        MOV     wp, r2
   [    NetworkPodule                                   ; Reset the hardware
        LDR     r0, [ r2, #:INDEX:Capabilities]         ; Address in the module of the table
        LDR     r1, [ r0, #Capability_Features]
        TST     r1, #Capability_NIC
        BEQ     %FT09                                   ; NIC support code,but no NIC
        ASSERT  NumberOfNetworkPodule = MaximumPodule-1
        LDR     r8, [r2, #:INDEX:NodeListHead]          ; if there is a NIC,it must always be the highest numbered podule
        ADD     r8, r8, r2
      [ DebugModule
        DREG    r8,"NIC node is at "
      ]
        LDR     r8, [r8, #PoduleNode_ROMAddress]
        TEQ     r8, #0
        STRNEB  r8, [ r8 ]                              ; A write resets the counter,when present
      [ DebugModule
        BEQ     %FT05
        DLINE   " reset NIC ROM"
05
      ]
09
   ]

        LDR     r8, [r2, #:INDEX:Capabilities]
        LDR     r8, [r8, #Capability_PodCount]          ; start with podule MaximumPodule
LoadLoadersLoop
        SUBS    r8, r8, #1
        BMI     %FT21                                   ; stop at system rom (-1)
     [  DebugModule
        BREG    r8, "Doing podule &"
     ]
        MOV     r3, r8
        BL      ConvertR3ToPoduleNode
     [  DebugModule
        BVC     %14
        ADD     r14, r0, #4
        DSTRING r14, "Error from ConvertR3ToPoduleNode: "
        B       %15
14
        ADD     r14, wp, r3
        LDR     r14, [ r14, #PoduleNode_LoaderOffset ]
        DREG    r14, "Loader offset is &"
15
     ]
        BVS     LoadLoadersLoop
        MOV     r2, sp                                  ; Base of 16 byte stack frame
     [  DebugModule
        MVN     r3, #0
        STR     r3, [ sp, #0 ]
        STR     r3, [ sp, #4 ]
        STR     r3, [ sp, #8 ]
        STR     r3, [ sp, #12 ]
     ]
        MOV     r3, r8
        BL      ReadHeader                              ; Do this to get the type byte
     [  DebugModule
        BVC     %16
        ADD     r14, r0, #4
        DSTRING r14, " error from ReadHeader: "
        B       %FT17
16
        LDR     r14, [ sp, #0 ]
        DREG    r14, "Header is &", cc
        LDR     r14, [ sp, #4 ]
        DREG    r14, ", &", cc
        LDR     r14, [ sp, #8 ]
        DREG    r14, ", &", cc
        LDR     r14, [ sp, #12 ]
        DREG    r14, ", &"
17
     ]
        BVS     LoadLoadersLoop
        MOV     r0, #0                                  ; Start with chunk zero
NextChunk
        BL      EnumerateChunks                         ; Loads the loader and the description
        BVS     LoadLoadersLoop                         ; if get error, goto next podule
        TEQ     r0, #0                                  ; Is this the last chunk?
        BNE     NextChunk                               ; No, so get another one
        B       LoadLoadersLoop

21
     [  ExtensionROMs
        LDR     r9, NumberOfExtROMs                     ; r10 gets trashed by EnumerateChunks
        [  DebugModule
        BREG    r9, "There are &", cc
        DLINE   " extension ROMs"
        ]
        TEQ     r9, #0
        BEQ     ExitLoadLoaders
        MOV     r8, #-2                                 ; -1 is the system ROM,so start at -2
LoadExtensionROMLoop
        [  DebugModule
        BREG    r8, "Doing extension ROM &"
        ]
        MOV     r3, r8
        BL      ConvertR3ToPoduleNode
        [  DebugModule
        BVC     %74
        ADD     r14, r0, #4
        DSTRING r14, "Error from ConvertR3ToPoduleNode: "
74
        ]
        BVS     NextExtensionROM
        MOV     r0, #0                                  ; Start with chunk zero
ExtensionChunkLoop
        MOV     r3, r8
        BL      EnumerateChunks                         ; Loads the description
        BVS     NextExtensionROM                        ; If get error, goto next ROM
        TEQ     r0, #0                                  ; Is this the last chunk?
        BNE     ExtensionChunkLoop                      ; No, so get another one
NextExtensionROM
        DEC     r8
        DECS    r9 
        BNE     LoadExtensionROMLoop
     ]
ExitLoadLoaders
        ADD     sp, sp, #16                             ; Remove frame
        Pull    "r8-r12, lr"
        LDR     r2, [ r12 ]                             ; reload workspace ptr from priv word
        MOV     pc, lr

        END
@


4.21
log
@Fix to ReadInfo_EthernetLow/High
Was preserving R2, when in fact the read info routines use R2 to return the result value. As a side effect, had to move the podule number into R4 so it is retained when Podule_ReadInfo is used to read multiple bits at once.
Simplified ReadInfo_MEMCAddress.
Removed redundant IOTCR address and task obey scripts.

Version 1.67. Tagged as 'Podule-1_67'
@
text
@d225 1
d231 7
a237 7

 [ :LNOT: :DEF: FakePodule
           GBLA FakePodule
FakePodule SETA FakePodule0        ; Use FakePodule0 from the machine header file if not defined by Components/makefile
 ]

;       Podule chunk directories in the header are 8 bytes (see PRM4-128):
d241 1
d254 15
a268 1
; We only know how to fake up STB2 MPEG1, MPEG2 (and MPEG0) podules and EtherI Podule
d270 1
a270 12
  ASSERT (FakePodule = 0) :LOR: (FakePodule = ProdType_STB2_MPEG1) :LOR: \
         (FakePodule = ProdType_STB2_MPEG2) :LOR: (FakePodule = ProdType_EtherI)

 [ FakePodule <> 0
   [ FakePodule = ProdType_EtherI
        !       0, "Assembling Podule Manager with Fake EtherI Podule header, (type $FakePodule)"
   |
        !       0, "Assembling Podule Manager with Fake Podule header, (type $FakePodule)"
   ]
 ]
 
 [ FakePodule = ProdType_STB2_MPEG1 :LOR: FakePodule = ProdType_STB2_MPEG2
d274 1
a274 4
 ]
 [ FakePodule   =       ProdType_EtherI
EtherIIDByte    *       0
 ]
d276 1
a276 1
 [       FakePodule = ProdType_STB2_MPEG1 :LOR: FakePodule = ProdType_STB2_MPEG2
d287 1
a287 1
  [     FakePodule = ProdType_STB2_MPEG1
d299 1
a299 1
  |
d311 2
a312 2
  ]
 ]
d314 1
a314 19
;  Fake Podule header for Customer F 5 Ethernet NC.

                MACRO
                PODCHUNK $type,$contents,$desc,$end
                LCLA len
                LCLA offset
                DCD     $type                           ; Type: High nybble will be &F for NC
; len           SETA    ($end  - $desc)/4               ; Length of field
; offset        SETA    ($desc - $contents)/4           ; Offset of field from start
                DCD      (($end  - $desc)/4) :AND: &FF                  ; Size in bytes
                DCD     ((($end  - $desc)/4) :SHR:  8) :AND: &FF
                DCD     ((($end  - $desc)/4) :SHR: 16) :AND: &FF
                DCD      (($desc - $contents)/4) :AND: &FF              ; Offset to chunk string
                DCD     ((($desc - $contents)/4) :SHR:  8) :AND: &FF
                DCD     ((($desc - $contents)/4) :SHR: 16) :AND: &FF
                DCD     ((($desc - $contents)/4) :SHR: 24) :AND: &FF
                MEND

 [      FakePodule = ProdType_EtherI
d333 3
a335 2
 ]

d713 1
a713 1
;       Fake STB podule ROM Headers
d715 2
a716 1
 [      FakePodule = ProdType_STB2_MPEG1 :LOR: FakePodule = ProdType_STB2_MPEG2
d732 2
a733 2
;       See if MPEG is fitted and point the podule ROM address to the appropriate fake header
;       The description string will be extracted from this block in the normal way when chunks get enumerated
d740 1
a740 1
 ]
d742 2
a743 3
;       Fake EtherI podule ROM

 [      FakePodule = ProdType_EtherI
d747 1
a747 1
        MOV     r1, #EtherIIDByte                       ; ID byte for fake EtherI podule
d759 2
a760 2
;       We are faking an EtherI podule ROM, so point the podule ROM address to the appropriate fake header
;       The description string will be extracted from this block in the normal way when chunks get enumerated
d763 2
a764 1
 ]
@


4.20
log
@Fix corruption of memory location 0x032000C4
Podule manager was using a hardwired IOC era address of IOTCR to set the speed for the NIC rather than using the SSpaceStart location it read from the Kernel.
Makefile updated to generate C header from the assembler one (static copy deleted).
When NetworkCard support is assembled out the table of logical DMA channels is updated to reflect that.
Use symbol MaximumPodule from the machine definition rather than hardwired 8.
Tested on softloaded IOMD ROM, inspection of IOTCR looks like it's being modified correctly.

Version 1.66. Tagged as 'Podule-1_66'
@
text
@a111 1
IOTCR                   *       &032000C4
@


4.19
log
@Reinstate reporting on the network card podule.
In the *PODULES code the loop counter goes from 0...maxpod-1 but the check to change the text to say "Network card" was checking against maxpod.
Ammended a few comment typos and shelved some unused files.

Version 1.65. Tagged as 'Podule-1_65'
@
text
@d388 1
a388 1
        MSR     CPSR_f, #V_bit
d475 1
a475 1
        MSR     CPSR_f, #V_bit
d480 1
a480 1
        MSR     CPSR_f, #V_bit
d540 1
a540 1
        MSR     CPSR_f, #V_bit
d662 1
d664 1
a664 2
        MOVEQ   r4, r1
        STRNE   r1, [r2, #:INDEX:SSpaceStart]           ; Saves keep asking for it
@


4.18
log
@Fix handling of non-32bit podule loaders
Detail:
  s/Module - The workspace definition didn't take into account the presence of the PoduleReadOnly error block, so when the module attempted to use the fake 32bit podule loader it was causing a crash. This fixes that.
Admin:
  Tested in Iyonix & IOMD ROM softloads. Podules with 26bit loaders are now handled properly.


Version 1.63. Tagged as 'Podule-1_63'
@
text
@d53 1
a53 1
DebugModule     SETL    ( :LNOT: ReleaseVersion ) :LAND: False
d56 1
a56 1
DebugInterface  SETL    ( :LNOT: ReleaseVersion ) :LAND: False
d59 1
a59 1
DebugCommands   SETL    ( :LNOT: ReleaseVersion ) :LAND: False
d62 1
a62 1
DebugLoader     SETL    ( :LNOT: ReleaseVersion ) :LAND: False
d65 1
a65 1
DebugMssgs      SETL    ( :LNOT: ReleaseVersion ) :LAND: False
d68 1
a68 1
DebugInit       SETL    False
d78 1
a78 1
EASISpace       SETL    True
d1007 1
a1007 1
        ASSERT  NumberOfNetworkPodule = (MaximumPodule-1)
@


4.17
log
@Prised out the last remaining IOMD assumptions,now follows a policy of
autodetection described in "Docs.Policy",which included eliminating some
static tables which were produced at runtime.
The static tables are now all in s.Tables.
The podule node list is generated at run time since so many of the node
entries needed correction depending on where "SSpaceStart" is.
Though not explicitly mentioned in the PRMs,where an IO area doesn't
exist for a given IOMD varient zero is returned by Podule_ReadInfo to
denote it does not exist
Support for Podule_SetSpeed helpers added,thus IOMD abstracting the way
you set EASI cycle speeds.

Version 1.60. Tagged as 'Podule-1_60'
@
text
@d520 2
@


4.16
log
@Made use of "PoduleReadOnly" and "AddressRange" loader error messages,
added to messages file.
Network and ExtROM internal loaders now return full message strings
rather than the "Bad" token!
Presence of absence of ExtROMs/EASI/NIC/IOC and MEMC podule support is
deduced at runtime,and the logical addresses requested from the Kernel
by OS_Memory.EASI,ExtROMs and NIC remain assembly time options though
just to reduce the size of the module a bit.
An assortment of internal variables have been altered to have 0 or -1 as
their unused value rather than &80000000 as this may be a candidate for
genuine loader addresses in future.
First pass at removing IOMD specific assumptions in the module.

Version 1.59. Tagged as 'Podule-1_59'
@
text
@d28 1
d70 1
a70 2
        GBLL    FixLoaderBug
FixLoaderBug    SETL    True
d72 4
a75 2
        ;   The following assembly-time variables control the final
        ; form of the podule manager, and should be changed with care.
d77 2
a78 4
 [ :LNOT: :DEF: NumberOfPodules
                GBLA    NumberOfPodules                 ; Excluding the network podule
NumberOfPodules SETA    8
 ]
a82 3
                GBLL    EASISpace
EASISpace       SETL    True

d89 6
a94 2
        ; If included,Podule Manager will still ask around to see if the EASI space,NIC and Extension ROMs
        ; really are supported - these switches are really only of use to make the module a bit smaller
a96 1
        !       0, "This version supports " :CC: ((:STR:NumberOfPodules) :RIGHT: 1) :CC: " podules"
a108 76
        ; Podule manager will ask the Kernel where 'S' space is.If it doesn't exist,then MEMC and IOC podules
        ; will not be scanned.If it does exist then the chip id (at S space +94 and +98) will be
        ; inspected to determine the level of IOC emulation,if any.
        ; If a platform does support IOC emulation the following must be true for the following constants
        ; to be valid:    A20 and A19 determine the podule access style
        ;                 A21 chooses between MEMC and IOC interfaces
        ; the remainder of decoding is done by the backplane A15 and A14 and must also be fixed
        ; For EASI space,the 16M blocks must be back to back,decoded by A24 and A25

PoduleBase0             *       &033C0000-&03200000
PoduleBase1             *       &033C4000-&03200000
PoduleBase2             *       &033C8000-&03200000
PoduleBase3             *       &033CC000-&03200000
PoduleBase4             *       &033F0000-&03200000
PoduleBase5             *       &033F4000-&03200000
PoduleBase6             *       &033F8000-&03200000
PoduleBase7             *       &033FC000-&03200000
NetworkBaseROM          *       &0302B000-&03200000 ; the NIC is "below" S space S0
NetworkBaseChip         *       &0302B800-&03200000

PoduleCMOS0             *       PoduleCMOS
PoduleCMOS1             *       PoduleCMOS + 4
PoduleCMOS2             *       PoduleCMOS + 8
PoduleCMOS3             *       PoduleCMOS + 12
PoduleCMOS4             *       PoduleExtraCMOS + 16
PoduleCMOS5             *       PoduleExtraCMOS + 12
PoduleCMOS6             *       PoduleExtraCMOS + 8
PoduleCMOS7             *       PoduleExtraCMOS + 4
PoduleCMOS8             *       PoduleExtraCMOS

ModuleBase0             *       &03000000-&03200000 ; MEMC podules are "below" S space S0
ModuleBase4             *       &03030000-&03200000

DMAChannel0             *       &000 ; These are all logical channel numbers
DMAChannel1             *       &010
DMAChannel2             *       -1
DMAChannel3             *       -1
DMAChannel4             *       -1
DMAChannel5             *       -1
DMAChannel6             *       -1
DMAChannel7             *       -1
NetworkDMAChannel       *       &105

PoduleIntStatus         *       &03200020-&03200000     ; IRQB
PoduleIntRequest        *       &03200024-&03200000
PoduleIntMask           *       &03200028-&03200000
PoduleIntValue          *       &20
PoduleIntDeviceVector   *       &0D

PoduleFIQasIntStatus    *       &03200020-&03200000     ; IRQB
PoduleFIQasIntRequest   *       &03200024-&03200000
PoduleFIQasIntMask      *       &03200028-&03200000
PoduleFIQasIntValue     *       &01
PoduleFIQasIntDeviceVector *    &08

PoduleFIQStatus         *       &03200030-&03200000     ; FIQ
PoduleFIQRequest        *       &03200034-&03200000
PoduleFIQMask           *       &03200038-&03200000
PoduleFIQValue          *       &40

NetworkIntStatus        *       &03200020-&03200000     ; IRQB
NetworkIntRequest       *       &03200024-&03200000
NetworkIntMask          *       &03200028-&03200000
NetworkIntValue         *       &08
NetworkIntDeviceVector  *       &0B

NetworkFIQasIntStatus   *       &03200020-&03200000     ; IRQB
NetworkFIQasIntRequest  *       &03200024-&03200000
NetworkFIQasIntMask     *       &03200028-&03200000
NetworkFIQasIntValue    *       &08
NetworkFIQasIntDeviceVector *   &0B

NetworkFIQStatus        *       &03200030-&03200000     ; FIQ
NetworkFIQRequest       *       &03200034-&03200000
NetworkFIQMask          *       &03200038-&03200000
NetworkFIQValue         *       &02
d110 2
a111 3
 [ NetworkPodule
MaximumPodule           *       NumberOfPodules + 1
NumberOfNetworkPodule   *       MaximumPodule - 1
a112 4
 ! 0, "IOTCR still hardcoded to be in IOMD!"
 |
MaximumPodule           *       NumberOfPodules
 ]
d114 15
a128 1
maxint                  *       &7FFFFFFF
d131 1
d136 1
a136 1
                                                        ; joined up in order 0 > 1 > 2 > 3 > -2 > -3 > ...
d139 1
a139 3
PoduleNode_BaseAddress          #       4               ; Hardware base of podule, or address of fake header
                                                        ; in Podule manager code in the case of fake podules
PoduleNode_PoduleLimit          #       4               ; Highest numbered chunk in podule space, or maxint if not yet known
a141 1
PoduleNode_ROMAddress           #       4               ; Address of start of image in ROM (for extension ROMs)
d146 1
a146 2
PoduleNode_Flags                #       1               ; Bit zero => ROM is IOC podule, Bit one => ROM is EASI
PoduleNode_SpareByte            #       1
a147 4
PoduleNode_IntValue             #       1
PoduleNode_FIQasIntValue        #       1
PoduleNode_FIQValue             #       1
PoduleNode_CMOS                 #       4               ; CMOS base address
d150 6
a155 2
PoduleNode_IntStatus            #       4
PoduleNode_IntRequest           #       4
d157 1
a157 1
PoduleNode_IntDeviceVector      #       4
d159 2
d162 2
a163 1
PoduleNode_FIQasIntMask         #       4
d165 6
a170 5
PoduleNode_FIQStatus            #       4
PoduleNode_FIQRequest           #       4
PoduleNode_FIQMask              #       4
PoduleNode_EASIAddress          #       4

d172 3
a174 3
        [       :LNOT: ReleaseVersion
        !       0, "A node record is &" :CC: ((:STR: PoduleNode_Size) :RIGHT: 2) :CC: " bytes long"
        ]
d176 4
d181 1
a181 1
ROMNode_Size                    *       :INDEX: @@       ; size of node for extension ROMs
d183 1
a183 48
        MACRO
$label  PoduleNode      $link, $baseaddress, $romaddress, $cmos, $type, $easi, $dma
        Byte    $label, PoduleNode_Size                 ; allocate space in workspace
        DCD     $link                                   ; offset in workspace of next node
        [       "$type" = "Network"
        DCD     :INDEX: NetworkLoader                   ; loader offset, initialised to point to the internal loader
        |
        DCD     -1                                      ; loader offset, initialised to no loader
        ]
        ASSERT  (.-Origin :AND: 3) = 0
        DCD     $baseaddress                            ; hardware base address
        DCD     maxint                                  ; podule limit
        DCD     -1                                      ; enumeration limit
        DCD     $romaddress                             ; same as baseaddress for normal podules
        DCD     16                                      ; word offset
        DCD     0, 4, 8, 12                             ; byte offsets
        DCD     0                                       ; Description pointer
        DCW     0                                       ; Type (16 bits)
        DCB     0                                       ; Flags, all zero
        DCB     0                                       ; Spare
        ASSERT  (.-Origin :AND: 3) = 0
        DCB     255                                     ; ID byte
        LCLS    inttype
        [       ReassignedIOMDInterrupts :LAND: PoduleInstance = 0
inttype SETS    "Network"                               ; Podule 0 uses the Network interrupt
        |
inttype SETS    "$type"
        ]
        DCB     $inttype.IntValue
        DCB     $inttype.FIQasIntValue
        DCB     $inttype.FIQValue
        ASSERT  (.-Origin  :AND: 3) = 0
        DCD     $cmos                                   ; CMOS base address
        DCD     $romaddress + $cmos
        DCD     $dma
        DCD     $inttype.IntStatus
        DCD     $inttype.IntRequest
        DCD     $inttype.IntMask
        DCD     $inttype.IntDeviceVector
        DCD     $inttype.FIQasIntStatus
        DCD     $inttype.FIQasIntRequest
        DCD     $inttype.FIQasIntMask
        DCD     $inttype.FIQasIntDeviceVector
        DCD     $inttype.FIQStatus
        DCD     $inttype.FIQRequest
        DCD     $inttype.FIQMask
        DCD     $easi                                   ; EASI Space logical address
        MEND
a184 1
        ^       0,      wp                              ; Store
d201 7
a207 1
        Word    number_of_extension_roms                ; How many extension roms there are
d209 6
d217 4
a220 1
        DCD     NIL
a224 2
        Word    CachedIOMDchipid                        ; Used to switch on in various places,cache it
        DCD     0
d226 5
d232 4
a235 45
                GBLA    PoduleInstance
PoduleInstance  SETA    0
                GBLS    PoduleString
        [       NetworkPodule
        WHILE   PoduleInstance < NumberOfPodules
PoduleString    SETS    "Podule" :CC: ((:STR: PoduleInstance) :RIGHT: 1) :CC: " PoduleNode "
PoduleString    SETS    "$PoduleString" :CC: ":INDEX: Podule" :CC: ((:STR: (PoduleInstance + 1)) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1) ; S space offset
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1) ; ROM offset
PoduleString    SETS    "$PoduleString" :CC: ", PoduleCMOS" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", Podule, -1 " ; Type and EASI base
PoduleString    SETS    "$PoduleString" :CC: ", DMAChannel" :CC: ((:STR: PoduleInstance) :RIGHT: 1) ; Logical DMA
$PoduleString
PoduleInstance  SETA PoduleInstance + 1
        WEND
PoduleString    SETS    "Podule" :CC: ((:STR: PoduleInstance) :RIGHT: 1) :CC: " PoduleNode "
PoduleString    SETS    "$PoduleString" :CC: "0" ; end of linked list
PoduleString    SETS    "$PoduleString" :CC: ", NetworkBaseChip" ; S space offset
PoduleString    SETS    "$PoduleString" :CC: ", NetworkBaseROM"  ; ROM offset
PoduleString    SETS    "$PoduleString" :CC: ", PoduleCMOS" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", Network, -1, NetworkDMAChannel" ; Type and EASI base and logical DMA
$PoduleString
        |
        WHILE   PoduleInstance < NumberOfPodules - 1
PoduleString    SETS    "Podule" :CC: ((:STR: PoduleInstance) :RIGHT: 1) :CC: " PoduleNode "
PoduleString    SETS    "$PoduleString" :CC: ":INDEX: Podule" :CC: ((:STR: (PoduleInstance + 1)) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1) ; S space offset
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1) ; ROM offset
PoduleString    SETS    "$PoduleString" :CC: ", PoduleCMOS" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", Podule, -1 " ; Type and EASI base
PoduleString    SETS    "$PoduleString" :CC: ", DMAChannel" :CC: ((:STR: PoduleInstance) :RIGHT: 1) ; Logical DMA
$PoduleString
PoduleInstance  SETA PoduleInstance + 1
        WEND
PoduleString    SETS    "Podule" :CC: ((:STR: PoduleInstance) :RIGHT: 1) :CC: " PoduleNode "
PoduleString    SETS    "$PoduleString" :CC: "0" ; end of linked list
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1) ; S space offset
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1) ; ROM offset
PoduleString    SETS    "$PoduleString" :CC: ", PoduleCMOS" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", Podule, -1 " ; Type and EASI base
PoduleString    SETS    "$PoduleString" :CC: ", DMAChannel" :CC: ((:STR: PoduleInstance) :RIGHT: 1) ; Logical DMA
$PoduleString
        ]
PoduleString    SETS    "ROMNodeChainHead * Podule" :CC: ((:STR: PoduleInstance) :RIGHT: 1) :CC: " + PoduleNode_Link"
$PoduleString
a252 11
; ****************************************************************************
;
;       Fake podules - the podule manager can be assembled with built in podule headers
;                      to save having to put a ROM on the PCB for embedded applications
;                      see "Doc.FakePods" for more information

 [ :LNOT: :DEF: FakePodule
           GBLA FakePodule
FakePodule SETA FakePodule0        ; Use FakePodule0 from the machine header file if not defined by Components/makefile
 ]

d265 1
a265 1

d346 1
a346 1
EtherIdesc      DCB     '10BaseT Ethernet 64k buffer (A cycles)",0
a446 1
        [       FixLoaderBug
d448 1
a448 1
        ]
d459 1
a459 1
        STRB    r10, [ r11, #0 ]                        ; Reset the counter
a466 2
    ;   STRB    r10, [ r11, #0 ]                        ; Reset the counter
    ;   STRB    r10, [ r11, #0 ]                        ; Reset the counter
d468 2
d478 1
a478 1

d483 1
d515 1
a515 1
        [ ExtensionROMs :LOR: NetworkPodule
a564 1

a574 1
        !       0, "Assembling Podule Manager $Module_MajorVersion $Module_MinorVersion"
d577 4
a580 1
        =       " [", (:STR: NumberOfPodules) :RIGHT: 1
d582 1
a582 1
        =       "/N"
d585 1
a585 1
        =       "/E"
d587 1
a587 2
        =       "]"
        =       " (development version)"
d626 1
a626 1
        STRNEB  r0, [r1]                                ; on hard init,force everyone to A cycles (if ECTCR is available)
d632 1
a632 1
 [ DebugModule
d635 1
a635 1
 ]
d653 1
a655 21
        ; ***hmm
        Push    "r0,r2,r12,lr"
        MOV     r12, r2
        ADR     r2, ErrorLoader26bit                    ; Find message strings for internal loaders
        ADRL    r0, ErrorBlock_Ldr26
        BL      SoftloadErrorMssg
        BVS     %FT05
        ADR     r2, ErrorReadOnly
        ADRL    r0, ErrorBlock_PoduleReadOnly
        BL      SoftloadErrorMssg
        BVS     %FT05
        ADR     r2, ErrorOffEnd
        ADRL    r0, ErrorBlock_AddressRange
        BL      SoftloadErrorMssg
05
        Pull    "r0,r2,r12,lr"
        ; ***hmm

        MOV     r3, #MaximumPodule-1
        ADRL    r5, NormalPoduleNodeOffsets
DynamicEASI
d657 1
a657 2
        MOV     r1, #1 << 8
        ORR     r1, r1, r3
d659 1
a659 1
        BVS     %FT10
d661 5
a665 10
        BEQ     %FT10
      [ DebugModule
        BREG    r3, "Found EASI space "
      ]
        LDR     r0, [r5, r3, LSL#2]                     ; now lookup a node offset for the podule in r3
        ADD     r0, r0, r2                              ; the base of that node
        STR     r1, [r0, #PoduleNode_EASIAddress]       ; modify node entry
10
        SUBS    r3, r3, #1
        BPL     DynamicEASI
d667 2
a668 4
        MOV     r0, #9                                  ; check for something akin to IOMD,then deduce what it can do
        MOV     r1, #4 << 8
        SWI     XOS_Memory
        MOVVS   r1, #IOMD_Base                          ; Kernel's so old it doesn't do this OS_Memory reason
d670 13
a682 4
        LDRB    r0, [r1, #IOMD_ID1]
        MOV     r0, r0, LSL#8
        LDRB    r3, [r1, #IOMD_ID0]
        ORR     r0, r3, r0
d684 1
a684 1
        DREG    r0, "IOMD chip id &"
d686 9
a694 7
        STR     r0, [r2, #:INDEX:CachedIOMDchipid ]            ; needed later

        MOV     r3, #MaximumPodule-1
DynamicPods
        LDR     r0, [r5, r3, LSL#2]
        ADD     r0, r0, r2
        TEQ     r1, #0                                  ; there's no S Space,so nuke each entry
d696 2
a697 1
        BREG    r3,"Update podule entry for "
d699 10
a708 16
        LDRNE   r4, [r0, #PoduleNode_BaseAddress]
        ADDNE   r4, r4, r1
        MOVEQ   r4, #-1
        STR     r4, [r0, #PoduleNode_BaseAddress]
        LDRNE   r4, [r0, #PoduleNode_ROMAddress]
        ADDNE   r4, r4, r1
        STR     r4, [r0, #PoduleNode_ROMAddress]
        LDRNE   r4, [r0, #PoduleNode_CombinedAddress]
        ADDNE   r4, r4, r1
        STR     r4, [r0, #PoduleNode_CombinedAddress]
        LDR     r6, [r0, #PoduleNode_EASIAddress]
        TEQ     r6, r4                                  ; does EASIAddress=CombinedAddress=-1
        MOVEQ   r4, #0
        STREQ   r4, [r0, #PoduleNode_CMOS]              ; better zero that so Podule_ReadInfo can't match the CMOS address
        SUBS    r3, r3, #1
        BPL     DynamicPods
d715 1
a715 2
        BVS     %FT30
        !       0, "!! Haven't stored the result of Extension ROM probing anywhere !!"
d717 7
a723 1
        BLNE    FindExtensionROMs
a726 1

d730 1
a730 1
        MOV     r0, #:INDEX: Podule0
d758 1
a758 1
        MOV     r0, #:INDEX: Podule0
d784 1
a784 1
 [ DebugModule
d787 1
a787 1
 ]
d791 3
d799 1
a799 1
; OSS Note that due to the module die entry and the service reset code being the same,
d806 1
a806 1
        MOV     r3, #:INDEX: Podule0
d808 4
d814 5
a818 8
  [  DebugModule
        DLINE   " OK"
  ]
        ASSERT  PoduleNode_Link = 0
        LDR     r3, [ wp, r3 ]                          ; get next node offset
        TEQ     r3, #0
        BNE     %10

d841 2
a842 2
                                                        ; place,since we can't call MessageTrans when we're initialised
                                                        ; as MessageTrans itself hasn't yet started
d849 2
a850 1
        LDR     wp, [r12]
d852 1
a852 1
        ADR     r2, ErrorLoader26bit                    ; Find message strings for internal loaders
d856 1
a856 1
        ADR     r2, ErrorReadOnly
d860 1
a860 1
        ADR     r2, ErrorOffEnd
d870 111
d994 1
a994 1
     [  DebugModule
d996 1
a996 1
     ]
d1000 11
a1010 4
     [  NetworkPodule                                   ; Reset the hardware
PoduleString    SETS  " MOV    r8, #:INDEX: Podule" :CC: ((:STR:  NumberOfNetworkPodule) :RIGHT: 1)
        $PoduleString
        ADD     r8, r8, r2                              ; finally,the base of that node
d1012 2
a1013 2
        CMP     r8, #-1
        STRNEB  r8, [ r8, #0 ]                          ; A write resets the counter,when present
d1015 3
a1017 3
        BEQ     %FT13
        DREG    r8,"Reset net ROM at &"
13
d1019 5
a1023 2
     ]
        MOV     r8, #0                                  ; start with podule 0
d1025 2
d1043 1
a1043 1
        BVS     TryNextPodule
d1052 1
a1052 1
        MOV     r3, r8                                  ; Podule number
d1057 2
a1058 2
        DSTRING r14, "Error from ReadHeader: "
        B       %17
d1070 1
a1070 1
        BVS     TryNextPodule
d1074 1
a1074 1
        BVS     TryNextPodule                           ; if get error, goto next podule
d1077 3
a1079 4
TryNextPodule
        ADD     r8, r8, #1                              ; Go to the next podule
        CMP     r8, #MaximumPodule
        BCC     LoadLoadersLoop
d1081 1
a1081 1
        LDR     r9, number_of_extension_roms            ; jharris: was r10, but r10 gets trashed by EnumerateChunks
d1087 2
a1088 2
        BEQ     ExitLoadLoaders                         ; jharris: was BEQ to (non-existent) 99
        MOV     r8, #-2
d1111 1
a1111 1
        DECS    r9                                      ; jharris
@


4.15
log
@  Updated build structure to use the shared AAsmModule makefile.
Admin:
  Requires Library 0.72 or later.
  Requires BuildSys 3.09 or later.
  Requires Env 0.65 or later.

Version 1.58. Tagged as 'Podule-1_58'
@
text
@a14 2
; => &.Arthur.Podule.Module
        TTL     The Podule manager for Arthur.
d16 2
a17 1
        SUBT    Module header => &.Arthur.Podule.Module
d27 1
a27 39
; 17-Aug-00  RJC   Added a new ProdType_ to include code that auto detects modem or ethernet version of Customer F 8
;
;
; Fake Podule Headers
; -------------------
; To keep production costs down the podule ROM is sometimes omitted from the final product,
; where an interface is built-in to the main motherboard (and hence always present).
; In such cases the podule manager can be made to provide a fake podule header, and this
; is used for STB MPEG hardware and also for the EtherI interface on a Customer F Ethernet NC.
;
; There are two ways to include the fake ROM header:
; 1. Set FakePodule0 in the machine header file
; 2. Set FakePodule in the components file (passed in via the MakeFile)
;
; If FakePodule is passed in from the MakeFile it overrides FakePodule0 in the machine file.
;
; The first approach is normally used, but the second approach is used for the Customer F 5 Ethernet NC
; where we use the same machine type as the Customer F 4 modem NC.
; (The Customer F 5 Ethernet NC is very closely based on the Customer F 4 modem NC.
; We don't want to introduce a new machine type as that would lead to other complications
; and make it more difficult to develop the Ethernet and Modem versions in tandem.)

 [ :LNOT: :DEF: FakePodule
	GBLA	FakePodule
FakePodule SETA FakePodule0	; Use FakePodule0 from the machine header file if not defined by Components/makefile
 ]
	; We only know how to fake up STB2 MPEG1, MPEG2 (and MPEG0) podules and EtherI Podule
        ASSERT (FakePodule = 0) :LOR: (FakePodule = ProdType_STB2_MPEG1) :LOR: (FakePodule = ProdType_STB2_MPEG2) :LOR: (FakePodule = ProdType_EtherI) :LOR: (FakePodule = ProdType_AutoDetectF8)
 [ FakePodule <> 0
   [ FakePodule = ProdType_EtherI
        !       0, "Assembling Podule Manager with Fake EtherI Podule header, (type $FakePodule)"
   |
      [ FakePodule = ProdType_AutoDetectF8
           !       0, "Assembling Podule Manager with capability to auto-detect type of a Customer F 8 board - Hard modem or EtherI"
      |
           !       0, "Assembling Podule Manager with Fake Podule header, type $FakePodule"
      ]
   ]
 ]
d41 1
a41 1
        DCD     SVCEntry - Origin
d63 5
a67 2
        GBLL    TML_Debugging
TML_Debugging   SETL    False
a79 3
                GBLL    NetworkPodule
NetworkPodule   SETL    NetPodSupport			; System build option

d86 3
d90 1
a90 1
ExtensionROMs   SETL    ExtROMSupport			; System build option
d92 2
d109 19
a127 12
        ;       These constants represent the physical implemention

PoduleBase0             *       &033C0000
PoduleBase1             *       &033C4000
PoduleBase2             *       &033C8000
PoduleBase3             *       &033CC000
PoduleBase4             *       &033F0000
PoduleBase5             *       &033F4000
PoduleBase6             *       &033F8000
PoduleBase7             *       &033FC000
NetworkBaseROM          *       &0302B000
NetworkBaseChip         *       &0302B800
d139 2
a140 1
ModuleBase0             *       &03000000
d142 1
a142 12
ModuleBase4             *       &03030000

EASIAddress0            *       &88000000
EASIAddress1            *       &89000000
EASIAddress2            *       &8A000000
EASIAddress3            *       &8B000000
EASIAddress4            *       &8C000000
EASIAddress5            *       &8D000000
EASIAddress6            *       &8E000000
EASIAddress7            *       &8F000000

DMAChannel0             *       &000
d152 3
a154 3
PoduleIntStatus         *       &03200020               ; IRQB
PoduleIntRequest        *       &03200024
PoduleIntMask           *       &03200028
d158 3
a160 3
PoduleFIQasIntStatus    *       &03200020               ; IRQB
PoduleFIQasIntRequest   *       &03200024
PoduleFIQasIntMask      *       &03200028
d164 3
a166 3
PoduleFIQStatus         *       &03200030               ; FIQ
PoduleFIQRequest        *       &03200034
PoduleFIQMask           *       &03200038
d169 3
a171 3
NetworkIntStatus        *       &03200020               ; IRQB
NetworkIntRequest       *       &03200024
NetworkIntMask          *       &03200028
d175 3
a177 3
NetworkFIQasIntStatus   *       &03200020               ; IRQB
NetworkFIQasIntRequest  *       &03200024
NetworkFIQasIntMask     *       &03200028
d181 3
a183 3
NetworkFIQStatus        *       &03200030               ; FIQ
NetworkFIQRequest       *       &03200034
NetworkFIQMask          *       &03200038
d190 1
d195 1
a195 24
 [ ExtensionROMs
   [ {TRUE}
StartOfROM      *       &03800000
EndOfROM        *       &04000000
   |
StartOfROM      *       &03400000
EndOfROM        *       &04000000
   ]
 ]

 [ FakePodule = ProdType_STB2_MPEG1 :LOR: FakePodule = ProdType_STB2_MPEG2
MachineConfig   *       (IOMD_Base + IOMD_CLINES)
MPEGfittedbit   *       IOMD_C_MPEGfitted
MPEGIDByte      *       0
 ]
 [ FakePodule	= 	ProdType_EtherI
EtherIIDByte	*	0
 ]
 [ FakePodule   =       ProdType_AutoDetectF8
EtherIIDByte    *       0
HModemIDByte    *       0
 ]

maxint          *       &7FFFFFFF
d205 5
a209 4
PoduleNode_BaseAddress          #       4               ; Hardware base of podule, or address of fake header in Podule manager code
                                                        ; in the case of extension ROMs
PoduleNode_PoduleLimit          #       4               ; Highest numbered chunk in podule space, or maxint (&7FFFFFFF) if not yet known
PoduleNode_EnumerationLimit     #       4               ; Highest numbered chunk we've seen in podule space, -1 if not seen any
d215 1
a215 1
PoduleNode_Flags                #       1               ; Bit zero => ROM is Podule, Bit one => ROM is EASI
a234 1
        [       EASISpace
a235 1
        ]
d250 1
a250 1
        DCD     :INDEX: NetworkLoader                   ; loader offset, initialised to point to the included loader
d252 1
a252 1
        DCD     NIL                                     ; loader offset, initialised to no loader
d291 1
a291 3
        [       EASISpace
        DCD     $easi                                   ; EASI Space Logical address
        ]
d320 4
d331 2
a332 2
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
d334 2
a335 2
PoduleString    SETS    "$PoduleString" :CC: ", Podule, EASIAddress" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", DMAChannel" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
d340 3
a342 3
PoduleString    SETS    "$PoduleString" :CC: "0"
PoduleString    SETS    "$PoduleString" :CC: ", NetworkBaseChip"
PoduleString    SETS    "$PoduleString" :CC: ", NetworkBaseROM"
d344 1
a344 1
PoduleString    SETS    "$PoduleString" :CC: ", Network, 0, NetworkDMAChannel"
d350 2
a351 2
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
d353 2
a354 2
PoduleString    SETS    "$PoduleString" :CC: ", Podule, EASIAddress" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", DMAChannel" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
d359 3
a361 3
PoduleString    SETS    "$PoduleString" :CC: "0"
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
d363 2
a364 2
PoduleString    SETS    "$PoduleString" :CC: ", Podule, EASIAddress" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", DMAChannel" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
d370 1
a370 1
;	Podule chunk directories in the header are 8 bytes (see PRM4-128):
d372 13
a384 13
		MACRO
		CHUNK $type,$contents,$description,$end
		DCD	$type				; Type: High nybble will be &F for NC
$len		*	($end  - $desc)/4		; Length of field
$offset		*	($desc - $contents)/4		; Offset of field from start
		DCD 	 $len :AND: &FF			; Size in bytes
		DCD	($len :SHR:     8) :AND &FF
		DCD	($len :SHR:    16) :AND &FF
		DCD 	 $offset :AND: &FF		; Offset to chunk string
		DCD	($offset :SHR:  8) :AND &FF
		DCD	($offset :SHR: 16) :AND &FF
		DCD	($offset :SHR: 24) :AND &FF
		MEND
d386 12
d399 19
d420 4
a423 4
MPEG0descoff	*       (MPEG0desc - MPEG0contents)/4		; offset of description from start
MPEG0desclen	*       (MPEG0end  - MPEG0desc)/4		; length of description
MPEG0contents	DCD     &00, &02, &00, (ProdType_STB2_MPEG0 :AND: &FF), (ProdType_STB2_MPEG0 :SHR: 8)
		DCD	(Manf_OnlineMedia :AND: &FF), (Manf_OnlineMedia :SHR: 8), &00
d427 1
a427 3
MPEG0desc	DCD     'I', 'n', 't', 'e', 'r', 'n', 'a', 'l'
                DCD     ' ', 'v', 'i', 'd', 'e', 'o', ' ', 'h'
                DCD     'a', 'r', 'd', 'w', 'a', 'r', 'e',  0
d430 1
a430 1
  [	FakePodule = ProdType_STB2_MPEG1
d432 4
a435 4
MPEG1descoff	*       (MPEG1desc - MPEG1contents)/4		; offset of description from start
MPEG1desclen	*       (MPEG1end  - MPEG1desc)/4		; length of description
MPEG1contents	DCD     &00, &02, &00, (ProdType_STB2_MPEG1 :AND: &FF), (ProdType_STB2_MPEG1 :SHR: 8)
		DCD	(Manf_OnlineMedia :AND: &FF), (Manf_OnlineMedia :SHR: 8), &00
d439 1
a439 3
MPEG1desc	DCD     'I', 'n', 't', 'e', 'r', 'n', 'a', 'l'
                DCD     ' ', 'M', 'P', 'E', 'G', '1', ' ', 'h'
                DCD     'a', 'r', 'd', 'w', 'a', 'r', 'e',  0
d443 5
a447 5
; it's the STB2/2
MPEG1descoff	*       (MPEG1desc - MPEG1contents)/4		; offset of description from start
MPEG1desclen	*       (MPEG1end  - MPEG1desc)/4		; length of description
MPEG1contents	DCD     &00, &02, &00, (ProdType_STB2_MPEG2 :AND: &FF), (ProdType_STB2_MPEG2 :SHR: 8)
		DCD	(Manf_OnlineMedia :AND: &FF), (Manf_OnlineMedia :SHR: 8), &00
d451 1
a451 3
MPEG1desc	DCD     'I', 'n', 't', 'e', 'r', 'n', 'a', 'l'
                DCD     ' ', 'M', 'P', 'E', 'G', '2', ' ', 'h'
                DCD     'a', 'r', 'd', 'w', 'a', 'r', 'e',  0
a457 5
;  This Ethernet NC has on-board Ethernet and although it has a podule ROM socket
;  this ROM is not fitted to reduce cost. We therefore provide a fake podule header here.
;  See PRM 4-122. Paul Skirrow 12 Jan 2000.
;
;	Podule chunk directories in the header are 8 bytes (see PRM4-128):
d459 15
d475 2
a476 42
		MACRO
		PODCHUNK $type,$contents,$desc,$end
		LCLA len
		LCLA offset
		DCD	$type				; Type: High nybble will be &F for NC
; len		SETA	($end  - $desc)/4		; Length of field
; offset	SETA	($desc - $contents)/4		; Offset of field from start
		DCD 	 (($end  - $desc)/4) :AND: &FF			; Size in bytes
		DCD	((($end  - $desc)/4) :SHR:  8) :AND: &FF
		DCD	((($end  - $desc)/4) :SHR: 16) :AND: &FF
		DCD 	 (($desc - $contents)/4) :AND: &FF		; Offset to chunk string
		DCD	((($desc - $contents)/4) :SHR:  8) :AND: &FF
		DCD	((($desc - $contents)/4) :SHR: 16) :AND: &FF
		DCD	((($desc - $contents)/4) :SHR: 24) :AND: &FF
		MEND

 [      FakePodule = ProdType_EtherI :LOR: FakePodule = ProdType_AutoDetectF8
EtherIcontents	DCD     &00				; Interrupts, IRQ and FIQ are relocated
		DCD	&03				; Interrupt Status Pointers and Chunk dir follow ECId
		DCD 	&00				; Reserved
		DCD 	(ProdType_EtherI :AND: &FF) 	; Product type low byte
		DCD	(ProdType_EtherI :SHR: 8)	; Product type hight byte
		DCD	(Manf_AcornUK :AND: &FF)	; Manufacturer code, low byte
		DCD	(Manf_AcornUK :SHR: 8)		; Manufacturer code, high byte
		DCD	0				; Country code (0=UK)
                DCD     0, 0, 0, 0, 0, 0, 0, 0		; Interrupt status pointers
		; Chunks follow:
                PODCHUNK &f5, EtherIcontents, EtherIdesc, EtherIdescend 	; Description: "10baseT Ethernet..."
                PODCHUNK &f3, EtherIcontents, EtherImod, EtherImodend	; Modifications status byte: 4

                DCD     0, 0, 0, 0, 0, 0, 0, 0		; End of chunk directory
EtherIdesc	DCD     '1', '0', 'B', 'a', 's', 'e', 'T', ' '
                DCD     'E', 't', 'h', 'e', 'r', 'n', 'e', 't'
                DCD     ' ', '6', '4', 'k', ' ', 'b', 'u', 'f'
                DCD     'f', 'e', 'r', ' ', '(', 'A', ' ', 'c'
                DCD     'y', 'c', 'l', 'e', 's', ')', 0
EtherIdescend
EtherImod	DCD	'4', 0		; Modification byte
EtherImodend
 ]
 [      FakePodule = ProdType_AutoDetectF8
HModemcontents DCD     &00                             ; Interrupts, IRQ and FIQ are relocated
d479 2
a480 2
                DCD     (ProdType_ModemCard :AND: &FF)  ; Product type low byte
                DCD     (ProdType_ModemCard :SHR: 8)    ; Product type hight byte
d486 2
a487 2
                PODCHUNK &f5, HModemcontents, HModemdesc, HModemdescend ; Description: "10baseT Ethernet..."
                PODCHUNK &f3, HModemcontents, HModemmod, HModemmodend   ; Modifications status byte: 0
d490 4
a493 8
HModemdesc      DCD     'T', 'e', 'm', 'p', 'o', 'r', 'a', 'r'
                DCD     'y', ' ', 'm', 'o', 'd', 'e', 'm', ' '
                DCD     'e', 'x', 'p', 'a', 'n', 's', 'i', 'o'
                DCD     'n', ' ', 'c', 'a', 'r', 'd', ' ', '-'
                DCD     ' ', 'b', 'y', ' ', 'B', 'o', 'b', 0
HModemdescend
HModemmod       DCD     '0', 0          ; Modification byte
HModemmodend
d532 2
a533 2
        MRS     CPSR_f, #V_bit
        MOV     r0, #0
a535 1

d584 1
a584 1
   ;     BICEQ   r10, r10, #&000FF000                    ; Make sure the counter doesn't overflow
d612 2
a613 2
    ;    STRB    r10, [ r11, #0 ]                        ; Reset the counter
    ;    STRB    r10, [ r11, #0 ]                        ; Reset the counter
d621 1
a621 1
        MOV     r0, #0
a627 1

d630 1
a630 6
        [       FixLoaderBug
        DCB     "Bad"
        |
        DCB     "BadAddr"
        ]
        DCB     0
d659 7
d683 1
a683 1
        ADR     r0, Loader26bitError
d703 3
a705 1
        Byte    Loader26bitError, InfoBufLength
d731 1
a731 1
        =       " assembled as a development version."
d748 1
a748 1
  [ ( DebugModule :LOR: DebugInterface :LOR: DebugCommands ) :LAND: TML_Debugging
d765 7
d783 1
d797 1
d799 37
a835 1
        MOV     r2, r1                                  ; Restore workspace pointer
d837 50
a886 4
        Push    r12
        MOV     r12, r2
        BL      LookupLoader26bitError
        Pull    r12
a887 3
 [ ExtensionROMs
        BL      FindExtensionROMs
 ]
d889 1
a889 10
;	Fake Podule ROM Headers
;
;	Some systems (such as STB and Customer F 5 Ethernet NC) have hardware fitted to the main board which
;	would traditionally have been implemented on an expansion card. Although there is normally
;	space for an expansion card ROM, it is not normally fitted and we fake the ROM header.
;	The hardware appears as expansion card 0 (podule 0) and the other expansion cards work normally
;	(if available).
;
;	If this is a Set-Top Box, then we know we've got MPEG hardware fitted as Podule0 but without the (EP)ROM
;	We'll make if look like its a real podule
d891 3
a893 4
 [       FakePodule = ProdType_STB2_MPEG1 :LOR: FakePodule = ProdType_STB2_MPEG2
        ADRL    r0, NormalPoduleNodeOffsets		; work out address of podule0 node
        LDR     r0, [r0]
        ADD     r0, r0, r2				; make it an absolute address
d895 2
a896 2
        MOV     r1, #MPEGIDByte				; ID byte for fake MPEG podule
        STRB    r1, [ r0, #PoduleNode_IDByte ]		; set ID byte to make ConvertR3ToPoduleNode happy
d899 1
a899 1
        STRB    r1, [ r0, #PoduleNode_Flags ]		; This is a (fake) Podule
d901 2
a902 2
	MOV	r1, #PoduleCMOS
	STR	r1, [ r0,  #PoduleNode_CMOS ]		; We don't have no CMOS
d904 2
a905 2
	MOV	r1, #-1
	STR	r1, [ r0,  #PoduleNode_DMA ]		; We don't do DMA
d907 2
a908 2
;	See if MPEG is fitted and point the podule ROM address to the appropriate fake header
;	The description string will be extracted from this block in the normal way when chunks get enumerated
d912 3
a914 3
        ADREQ	r1, MPEG0contents
        ADRNE	r1, MPEG1contents
        STR     r1, [ r0, #PoduleNode_ROMAddress ]	; Location to read header from
d917 1
a917 7
;	Fake EtherI podule ROM:

 [       FakePodule = ProdType_EtherI
        ;fake an EtherI
        ADRL    r0, NormalPoduleNodeOffsets		; work out address of podule0 node
        LDR     r0, [r0]
        ADD     r0, r0, r2				; make it an absolute address
d919 2
a920 62
        MOV     r1, #EtherIIDByte			; ID byte for fake EtherI podule
        STRB    r1, [ r0, #PoduleNode_IDByte ]		; set ID byte to make ConvertR3ToPoduleNode happy

        MOV     r1, #BitZero
        STRB    r1, [ r0, #PoduleNode_Flags ]		; This is a (fake) Podule

	MOV	r1, #PoduleCMOS
	STR	r1, [ r0,  #PoduleNode_CMOS ]		; We don't have no CMOS

	MOV	r1, #-1
	STR	r1, [ r0,  #PoduleNode_DMA ]		; We don't do DMA

;	We are faking an EtherI podule ROM, so point the podule ROM address to the appropriate fake header
;	The description string will be extracted from this block in the normal way when chunks get enumerated
        ADR	r1, EtherIcontents
        STR     r1, [ r0, #PoduleNode_ROMAddress ]	; Location to read header from
 ]

;       Fake either an EtherI or a Modem (for Customer F 8 boards)

 [       FakePodule = ProdType_AutoDetectF8

        ;to decide between modem and ethernet
        ;
        ;read line control register (low byte of &8800000C)
        ;invert bit 2
        ;store it back in line control register
        ;read it back out from &88000002C
        ;check it's still inverted
        ;if so modem
        ;else ethernet
        ;put original value back
 [ 1=2
        MOV     r0, #&88000000                          ;EASI space for podule 0
        LDRB    r1, [r0, #&0c]                          ;read reg3 (4x3=&c)
        EOR     r1, r1, #2_100                          ;invert bit 2
        STRB    r1, [r0, #&0c]                          ;store it back
        ; the modem will hold this value and the ethernet, however
        ; the bus isn't loaded in the ethernet version so it will float and also hold the value
        ; so drive the databus to clear this value
        ADD     r0,r0,#&400000
        LDRB    r0, [r0]                                ;load a value from the ethernet driver or from the modem depending on whats fitted - this will drive the bus
        MOV     r0, #&88000000
        LDRB    r0, [r0, #&2c]                          ;load the modem register back
        CMP     r0, r1                                  ;EQ => modem (the ethernet chip is only wired in at &88400000 so it isn't affected by this at all)
        EOR     r1, r1, #2_100                          ;put bit 2 back again
        MOV     r0, #&88000000
        STREQB  r1, [r0, #&0c]                          ;restore line control register - no need to bother if it's an ethernet
 |
        Push    "r2"
        MOV     r0, #&88000000                          ;EASI space for podule 0
        LDRB    r1, [r0, #&0c]                          ;read reg3 (4x3=&c)
        MOV     r2,r1
        BIC     r1, r1, #2_10                           ;clear bit 1
        STRB    r1, [r0, #&0c]                          ;store it back
        LDRB    r1, [r0, #&0c]                          ;load it back
        TST     r1, #2_10                               ;is bit 1 set (if not i.e EQ then it's a modem)
        STREQB  r2, [r0, #&0c]
        Pull    "r2"
 ]
        ADRL    r0, NormalPoduleNodeOffsets             ; work out address of podule0 node
        LDR     r0, [r0]
d923 1
a923 2
        MOVNE   r1, #EtherIIDByte                       ; ID byte for fake EtherI podule
        MOVEQ   r1, #HModemIDByte                       ; ID byte for fake hard-Modem
d935 1
a935 1
;       Point the podule ROM address to the appropriate fake header
d937 1
a937 2
        ADRNE   r1, EtherIcontents
        ADREQ   r1, HModemcontents                      ; Hard-Modem (i.e not soft-modem)
d943 3
a945 1
ReInitialisation ; Address of workspace in R2, Address of Private word in R12
d998 4
a1001 2
        TEQ     r1, #Service_TerritoryStarted
        BEQ     RedoMessages
d1006 17
d1024 1
a1024 3
RedoMessages
        LDR     wp, [r12]
        B       LookupLoader26bitError
d1040 1
a1040 1
  [  DebugModule
d1042 1
a1042 1
  ]
d1046 13
a1058 4
        [       NetworkPodule                           ; Reset the hardware
        LDR     r8, AddressOfNetworkBaseROM
        STRB    r8, [ r8, #0 ]                          ; A write resets the counter
        ]
d1061 1
a1061 1
  [  DebugModule
d1063 1
a1063 1
  ]
d1066 1
a1066 1
  [  DebugModule
d1076 1
a1076 1
  ]
d1079 2
a1080 2
  [  DebugModule
        LDR     r3, =&BCBCBCBC
d1085 1
a1085 1
  ]
d1088 1
a1088 1
  [  DebugModule
d1103 1
a1103 1
  ]
d1115 3
a1117 3
  [  ExtensionROMs
        LDR     r9, number_of_extension_roms		; jharris: was r10, but r10 gets trashed by EnumerateChunks
   [  DebugModule
d1120 1
a1120 1
   ]
d1122 1
a1122 1
        BEQ     ExitLoadLoaders				; jharris: was BEQ to (non-existent) 99
d1125 1
a1125 1
   [  DebugModule
d1127 1
a1127 1
   ]
d1130 1
a1130 1
   [  DebugModule
d1135 1
a1135 1
   ]
d1146 1
a1146 1
        DECS    r9					; jharris
d1148 1
a1148 1
  ]
a1153 119

  [  NetworkPodule
AddressOfNetworkBaseROM
        DCD     NetworkBaseROM
  ]

EasyLookup ROUT
        ;       In:  R1 Pointer to token
        ;       In:  R4 Single parameter to substitute
        ;       Out: R2 Pointer to looked up message in an error buffer
        ;       Out: R3 Length including terminator

        Push    "r0, r1, r3, r5, r6, r7, lr"
        BL      open_message_file
  [  DebugModule
        BVC     %71
        ADD     r14, r0, #4
        DSTRING r14, "Error from open_message_file: "
71
  ]
        ADRVC   r0, message_file_block                  ; Message file handle
        MOV     r2, #0                                  ; No buffer, expand in place
        MOV     r3, #0
        MOV     r5, #0                                  ; No %1
        MOV     r6, #0                                  ; No %2
        MOV     r7, #0                                  ; No %3
  [ DebugModule :LOR:  DebugCommands
        BVS     ExitEasyLookup
        DREG    r0, "R0 = &", cc
        Push    r14
        LDR     r14, [ r0, #0 ]
        DREG    r14, ", &", cc
        LDR     r14, [ r0, #4 ]
        DREG    r14, ", &", cc
        LDR     r14, [ r0, #8 ]
        DREG    r14, ", &", cc
        LDR     r14, [ r0, #12 ]
        DREG    r14, ", &"
        Pull    r14
        DREG    r1, "R1 = &", cc
        DSTRING r1, " token is: "
        DREG    r2, "R2 = &"
        DREG    r3, "R3 = &"
        DREG    r4, "R4 = &", cc
        DSTRING r4, " %0 is: "
        DREG    r5, "R5 = &", cc
        DSTRING r5, " %1 is: "
        DREG    r6, "R6 = &", cc
        DSTRING r6, " %2 is: "
        DREG    r7, "R7 = &", cc
        DSTRING r7, " %3 is: "
        DREG    r8, "R8 = &"
        DREG    r9, "R9 = &"
        DREG    r10, "R10 = &"
        DREG    r11, "R11 = &"
        DREG    r12, "R12 = &"
        DREG    r13, "R13 = &"
        DREG    r14, "R14 = &"
        DREG    r15, "R15 = &"
  ]
        SWIVC   XMessageTrans_Lookup
  [  DebugModule
        BVC     %76
        ADD     r14, r0, #4
        DSTRING r14, "Error from XMessageTrans_Lookup: "
76
  ]
        BVS     ExitEasyLookup
        ADD     r3, r3, #1                              ; Allow for the terminator
        STR     r3, [ sp, #8 ]                          ; Poke into the return frame
        LDR     r0, [ sp, #4 ]                          ; Get the token pointer
        DEC     r0, 4                                   ; Pretend it is an error pointer
        ADR     r1, message_file_block                  ; Message file handle
        MOV     r2, #0                                  ; No buffer, expand into a buffer
        MOV     r3, #0
  [ False ; DebugModule
        DREG    r0, "R0 = &"
        DREG    r1, "R1 = &"
        DREG    r2, "R2 = &"
        DREG    r3, "R3 = &"
        DREG    r4, "R4 = &"
        DREG    r5, "R5 = &"
        DREG    r6, "R6 = &"
        DREG    r7, "R7 = &"
        DREG    wp, "WP = &"
        DREG    sp, "SP = &"
  ]
        SWI     XMessageTrans_ErrorLookup
  [  DebugModule
        ADD     r14, r0, #4
        DSTRING r14, "Error from XMessageTrans_ErrorLookup: "
  ]
        CLRV
        ADD     r2, r0, #4                              ; Skip over the error number
ExitEasyLookup
  [ DebugModule :LOR:  DebugCommands
        Push    "r0, r1"
        ADR     r0, message_file_block                  ; Message file handle
        DREG    r0, "R0 = &", cc
        LDR     r1, [ r0, #0 ]
        DREG    r1, ", &", cc
        LDR     r1, [ r0, #4 ]
        DREG    r1, ", &", cc
        LDR     r1, [ r0, #8 ]
        DREG    r1, ", &", cc
        LDR     r1, [ r0, #12 ]
        DREG    r1, ", &"
        Pull    "r0, r1"
  ]
        STRVS   r0, [ sp, #0 ]
        Pull    "r0, r1, r3, r5, r6, r7, pc"

        ROUT

        LTORG

        [ :LNOT: ReleaseVersion
        InsertDebugRoutines
        ]
@


4.14
log
@  Another minor bug fix - to do with auto detection

Version 1.57. Tagged as 'Podule-1_57'
@
text
@d784 1
a784 4
        DCB     "Podule Manager", 9, "$Module_MajorVersion ($Module_Date)"
        [       Module_MinorVersion <> ""
        =       " $Module_MinorVersion"
        ]
@


4.13
log
@  Small bug in the auto-detect routine meant that it worked on pure chance
Detail:
  Modified to deal with situation in which bus 'remembers' value briefly
  Now clear bit one of Line Control Register - this bit is always pulled high
  by ethernet version
Admin:
  HdrSrc-0_97 needed for auto-detect

Version 1.56. Tagged as 'Podule-1_56'
@
text
@d974 1
a974 1
]
@


4.12
log
@  Can now include code that auto-detects the version of the Customer F 8 board in use
  i.e Hardware modem or Ethernet
Detail:
  New value of FakePodule should be passed in to build the module with this code
  FakePodule = ProdType_AutoDetectF8
  Auto-Detect code writes to the Line Control Register on the modem
  (address &8800000c) and then tries to read the same data back from
  address &8800002c (the modem is only connected to three address lines so
  register map repeats every 8 words).
  This should have no effect on ethernet controller because it only starts at
  &88400000.
Admin:
  Tested on Customer F 8 modem and ethernet boards appears to work.
  Change needed for next version - since the ethernet version doesn't load the
  bus at this address the capacitance of the bus is enough to remember the valu
  making it apppear that a modem is present. Currently two reads from the same
  location are carried out and the result of the first is discarded. This seems
  to be enough to clear the bus but we should actually force a read from
  another location on the Bd bus.

Version 1.55. Tagged as 'Podule-1_55'
@
text
@d947 1
a947 1

d952 7
a958 2
        LDRB    r0, [r0, #&2c]                          ;load it back
        LDRB    r0, [r0, #&2c]                          ;load it back
d963 12
a974 2


@


4.11
log
@* Converted to be 32-bit compatible.
* Suppresses non-32-bit expansion card loaders (a 32-bit compatible loader
  must have the magic word "32OK" after the 4 entry points).
* Lots of OS_SynchroniseCodeAreas calls added. This module was far from
  StrongARM-compatible - I'm amazed it worked at all; indeed it often failed
  when softloaded.

Needs a new Hdr:NewErrors with the "Loader is not 32-bit compatible" error.

Version 1.54. Tagged as 'Podule-1_54'
@
text
@d28 1
a49 2


d55 1
a55 1
	ASSERT (FakePodule = 0) :LOR: (FakePodule = ProdType_STB2_MPEG1) :LOR: (FakePodule = ProdType_STB2_MPEG2) :LOR: (FakePodule = ProdType_EtherI)
d60 5
a64 1
        !       0, "Assembling Podule Manager with Fake Podule header, type $FakePodule"
d249 4
a252 1

d514 1
a514 1
 [	FakePodule = ProdType_EtherI
d538 24
a561 1

d910 1
d931 51
@


4.10
log
@  Trivial change to remove mis-leading message during assembly.

Detail:
  No longer reports "Assembling Podule Manager with Fake Podule header, type 00000000"
  when it is not faking a podule.

Admin:
  No code change. Module image unchanged.

Version 1.53. Tagged as 'Podule-1_53'
@
text
@d27 1
d82 2
d85 1
d542 4
a545 3
        ORRS    pc, lr, #V_bit                          ; write a byte
        BICS    pc, lr, #V_bit                          ; reset
        BICS    pc, lr, #V_bit                          ; SWI Podule_CallLoader
d552 1
d567 7
a573 1
        BICS    pc, lr, #V_bit
d587 1
a587 1
        ORRS    pc, lr, #V_bit                          ; Write a byte
d589 2
a590 1
        BICS    pc, lr, #V_bit                          ; SWI Podule_CallLoader
d625 1
a625 1
        BICEQS  pc, lr, #V_bit                          ; Return to the caller
d658 5
d664 1
d666 1
a666 1
        ORRS    pc, lr, #VFlag
d687 1
d697 1
a697 1
        BICS    pc, lr, #V_bit
d704 24
d741 1
d775 7
d823 13
d912 1
d938 2
a939 1
        BICS    pc, r6, #VFlag
d942 1
d948 1
d955 2
a956 1
        MOVNES  pc, lr
d958 3
d963 5
a967 1
        Pull    "r0-r6, pc",,^
@


4.9
log
@  Fixed problem with MakeFile not passing Options to ObjAsm
Detail:
  The Customer F NC needs to pass Options from the Components file to
  ObjAsm via the Makefile. The previous version didn't do this
  correctly.
Admin:
  Tested OK.

Version 1.52. Tagged as 'Podule-1_52'
@
text
@d56 2
a57 2

 [ FakePodule = ProdType_EtherI
d59 1
a59 1
 |
d61 1
@


4.8
log
@  Added fake podule header for EtherI. Converted to ObjAsm.
Detail:
  The Customer F 5 Ethernet NC doesn't have a podule ROM fitted, so we
  provide a fake podule header in podule manager.
  This is used if FakePodule0 is set in the machine header file
  or if FakePodule is passed in from the Makefile (FakePodule overrides
  the FakePodule0).
  It should be set to ProdType_EtherI to fake an EtherI podule but
  other values are possible, eg for MPEG).
Admin:
  Tested OK in Customer F 5 NC.

Version 1.51. Tagged as 'Podule-1_51'
@
text
@a48 1
	GBLA	FakePodule
d51 1
d54 2
d57 5
a119 2
	; We only know how to fake up STB2 MPEG1, MPEG2 (and MPEG0) podules and EtherI Podule
	ASSERT (FakePodule = 0) :LOR: (FakePodule = ProdType_STB2_MPEG1) :LOR: (FakePodule = ProdType_STB2_MPEG2) :LOR: (FakePodule = ProdType_EtherI)
@


4.7
log
@Added support for ReassignedIOMDInterrupts - Podule_ReadInfo now tells
expansion card 0 to use device number 11.
Added a SynchroniseCodeAreas call between reading the loader and entering it.

Version 1.50. Tagged as 'Podule-1_50'
@
text
@d15 1
a15 1
 ; => &.Arthur.Podule.Module
d20 36
d113 2
a114 2
	; We only know how to fake up STB2 MPEG1, MPEG2 (and MPEG0) podules
	ASSERT (FakePodule0 = 0) :LOR: (FakePodule0 = ProdType_STB2_MPEG1) :LOR: (FakePodule0 = ProdType_STB2_MPEG2)
d228 1
a228 1
 [ FakePodule0 <> 0
d233 4
d298 1
a298 1
        ASSERT  (:INDEX:. :AND: 3) = 0
d309 1
a309 1
        ASSERT  (:INDEX:. :AND: 3) = 0
d320 1
a320 1
        ASSERT  (:INDEX:. :AND: 3) = 0
d412 19
a430 1
 [       FakePodule0 <> 0
d443 1
a443 1
  [	FakePodule0 = ProdType_STB2_MPEG1
d474 50
d768 9
d779 2
a780 1
 [ FakePodule0 <> 0
d785 1
a785 1
        MOV     r1, #MPEGIDByte
d806 26
@


4.6
log
@Ursula branch merged (new service call table only).
Changed to use srccommit.

Version 1.49. Tagged as 'Podule-1_49'
@
text
@d68 3
d271 9
a279 3
        DCB     $type.IntValue
        DCB     $type.FIQasIntValue
        DCB     $type.FIQValue
d284 11
a294 11
        DCD     $type.IntStatus
        DCD     $type.IntRequest
        DCD     $type.IntMask
        DCD     $type.IntDeviceVector
        DCD     $type.FIQasIntStatus
        DCD     $type.FIQasIntRequest
        DCD     $type.FIQasIntMask
        DCD     $type.FIQasIntDeviceVector
        DCD     $type.FIQStatus
        DCD     $type.FIQRequest
        DCD     $type.FIQMask
@


4.5
log
@Allows specification of number of podules in machine header file.
@
text
@d587 3
a589 6
        DCB     "Podule Manager", 9, "1.", CurrentVersion
        [       ReleaseVersion
        !       0, "Assembling Podule Manager 1.$CurrentVersion"
        |
        DCB     "/", CurrentIteration
        !       0, "Assembling Podule Manager 1.$CurrentVersion/$CurrentIteration"
d591 2
a592 1
        =       " (", CurrentDate, ")"
d602 1
a602 1
        =       " assembled at ", CurrentTime, " as a development version."
d715 8
d724 1
d728 1
@


4.4
log
@Merged Spinner branch. Added Podule.h from Ursula.
@
text
@d60 1
d63 1
@


4.3
log
@File remerged to what it should be
@
text
@d72 2
a73 2
	; We only know how to fake up STB2 MPEG1 (and MPEG0) podules
	ASSERT (FakePodule0 = 0) :LOR: (FakePodule0 = ProdType_STB2_MPEG1)
d187 1
a187 1
 [ FakePodule0 = ProdType_STB2_MPEG1
d191 1
a191 1
        ]
d361 1
a361 1
        [       FakePodule0 = ProdType_STB2_MPEG1
d374 1
d388 16
a403 1
        ]
d653 1
a653 1
 [ FakePodule0 = ProdType_STB2_MPEG1
@


4.3.2.1
log
@update to Ursula format (service table)
@
text
@a698 8
        ASSERT  Service_Reset < Service_PreReset
ServiceTable
        DCD     0                        ;flags
        DCD     UServiceEntry - Origin
        DCD     Service_Reset
        DCD     Service_PreReset
        DCD     0                        ;terminator
        DCD     ServiceTable - Origin    ;table anchor
a699 1
        MOV     r0, r0                   ;magic instruction
a702 1
UServiceEntry
@


4.2
log
@Module merged
@
text
@d72 2
a73 2
	; We only know how to fake up STB2 MPEG1, MPEG2 (and MPEG0) podules
	ASSERT (FakePodule0 = 0) :LOR: (FakePodule0 = ProdType_STB2_MPEG1) :LOR: (FakePodule0 = ProdType_STB2_MPEG2)
d187 1
a187 1
 [ FakePodule0 <> 0
d191 1
a191 1
 ]
d361 1
a361 1
 [       FakePodule0 <> 0
a373 1
  [	FakePodule0 = ProdType_STB2_MPEG1
d387 1
a387 16
  |
; it's the STB2/2
MPEG1descoff	*       (MPEG1desc - MPEG1contents)/4		; offset of description from start
MPEG1desclen	*       (MPEG1end  - MPEG1desc)/4		; length of description
MPEG1contents	DCD     &00, &02, &00, (ProdType_STB2_MPEG2 :AND: &FF), (ProdType_STB2_MPEG2 :SHR: 8)
		DCD	(Manf_OnlineMedia :AND: &FF), (Manf_OnlineMedia :SHR: 8), &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
                DCD     &f5, MPEG1desclen, &00, &00, MPEG1descoff, &00, &00, &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
MPEG1desc	DCD     'I', 'n', 't', 'e', 'r', 'n', 'a', 'l'
                DCD     ' ', 'M', 'P', 'E', 'G', '2', ' ', 'h'
                DCD     'a', 'r', 'd', 'w', 'a', 'r', 'e',  0
MPEG1end
                ALIGN
  ]
 ]
d637 1
a637 1
 [ FakePodule0 <> 0
@


4.1
log
@Initial revision
@
text
@d64 1
a64 1
NetworkPodule   SETL    True
d70 4
a73 1
ExtensionROMs   SETL    False
d169 1
a169 1
        [       NetworkPodule
d173 1
a173 1
        |
d175 1
a175 1
        ]
d177 3
a179 3
        [       ExtensionROMs
  [  False                                              ; Victoria
StartOfROM      *       &03500000                       ; VIDC moved out of way
d181 1
a181 1
  |
d184 8
a191 2
  ]
        ]
d361 44
d648 1
a648 1
        [       ExtensionROMs
d650 29
a678 1
        ]
d803 4
a806 4
        [       ExtensionROMs
        LDR     r10, number_of_extension_roms
  [  DebugModule
        BREG    r10, "There are &", cc
d808 3
a810 3
  ]
        TEQ     r10, #0
        BEQ     %99
d813 1
a813 1
  [  DebugModule
d815 1
a815 1
  ]
d818 1
a818 1
  [  DebugModule
d823 1
a823 1
  ]
d834 1
a834 1
        DECS    r10
d836 1
a836 1
        ]
d843 1
a843 1
        [       NetworkPodule
d846 1
a846 1
        ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d64 1
a64 1
NetworkPodule   SETL    NetPodSupport			; System build option
d70 1
a70 4
ExtensionROMs   SETL    ExtROMSupport			; System build option

	; We only know how to fake up STB2 MPEG1 (and MPEG0) podules
	ASSERT (FakePodule0 = 0) :LOR: (FakePodule0 = ProdType_STB2_MPEG1)
d166 1
a166 1
 [ NetworkPodule
d170 1
a170 1
 |
d172 1
a172 1
 ]
d174 3
a176 3
 [ ExtensionROMs
   [ {TRUE}
StartOfROM      *       &03800000
d178 1
a178 1
   |
d181 1
a181 7
   ]
 ]

 [ FakePodule0 = ProdType_STB2_MPEG1
MachineConfig   *       (IOMD_Base + IOMD_CLINES)
MPEGfittedbit   *       IOMD_C_MPEGfitted
MPEGIDByte      *       0
a351 28
        [       FakePodule0 = ProdType_STB2_MPEG1
MPEG0descoff	*       (MPEG0desc - MPEG0contents)/4		; offset of description from start
MPEG0desclen	*       (MPEG0end  - MPEG0desc)/4		; length of description
MPEG0contents	DCD     &00, &02, &00, (ProdType_STB2_MPEG0 :AND: &FF), (ProdType_STB2_MPEG0 :SHR: 8)
		DCD	(Manf_OnlineMedia :AND: &FF), (Manf_OnlineMedia :SHR: 8), &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
                DCD     &f5, MPEG0desclen, &00, &00, MPEG0descoff, &00, &00, &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
MPEG0desc	DCD     'I', 'n', 't', 'e', 'r', 'n', 'a', 'l'
                DCD     ' ', 'v', 'i', 'd', 'e', 'o', ' ', 'h'
                DCD     'a', 'r', 'd', 'w', 'a', 'r', 'e',  0
MPEG0end
                ALIGN

MPEG1descoff	*       (MPEG1desc - MPEG1contents)/4		; offset of description from start
MPEG1desclen	*       (MPEG1end  - MPEG1desc)/4		; length of description
MPEG1contents	DCD     &00, &02, &00, (ProdType_STB2_MPEG1 :AND: &FF), (ProdType_STB2_MPEG1 :SHR: 8)
		DCD	(Manf_OnlineMedia :AND: &FF), (Manf_OnlineMedia :SHR: 8), &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
                DCD     &f5, MPEG1desclen, &00, &00, MPEG1descoff, &00, &00, &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
MPEG1desc	DCD     'I', 'n', 't', 'e', 'r', 'n', 'a', 'l'
                DCD     ' ', 'M', 'P', 'E', 'G', '1', ' ', 'h'
                DCD     'a', 'r', 'd', 'w', 'a', 'r', 'e',  0
MPEG1end
                ALIGN
        ]

d595 1
a595 1
 [ ExtensionROMs
d597 1
a597 29
 ]
;	If this is a Set-Top Box, then we know we've got MPEG hardware fitted as Podule0 but without the (EP)ROM
;	We'll make if look like its a real podule
 [ FakePodule0 = ProdType_STB2_MPEG1
        ADRL    r0, NormalPoduleNodeOffsets		; work out address of podule0 node
        LDR     r0, [r0]
        ADD     r0, r0, r2				; make it an absolute address

        MOV     r1, #MPEGIDByte
        STRB    r1, [ r0, #PoduleNode_IDByte ]		; set ID byte to make ConvertR3ToPoduleNode happy

        MOV     r1, #BitZero
        STRB    r1, [ r0, #PoduleNode_Flags ]		; This is a (fake) Podule

	MOV	r1, #PoduleCMOS
	STR	r1, [ r0,  #PoduleNode_CMOS ]		; We don't have no CMOS

	MOV	r1, #-1
	STR	r1, [ r0,  #PoduleNode_DMA ]		; We don't do DMA

;	See if MPEG is fitted and point the podule ROM address to the appropriate fake header
;	The description string will be extracted from this block in the normal way when chunks get enumerated
        LDR     r3, =MachineConfig
        LDRB    r1, [r3]
        TST     r1, #MPEGfittedbit
        ADREQ	r1, MPEG0contents
        ADRNE	r1, MPEG1contents
        STR     r1, [ r0, #PoduleNode_ROMAddress ]	; Location to read header from
 ]
d722 4
a725 4
  [  ExtensionROMs
        LDR     r9, number_of_extension_roms		; jharris: was r10, but r10 gets trashed by EnumerateChunks
   [  DebugModule
        BREG    r9, "There are &", cc
d727 3
a729 3
   ]
        TEQ     r9, #0
        BEQ     ExitLoadLoaders				; jharris: was BEQ to (non-existent) 99
d732 1
a732 1
   [  DebugModule
d734 1
a734 1
   ]
d737 1
a737 1
   [  DebugModule
d742 1
a742 1
   ]
d753 1
a753 1
        DECS    r9					; jharris
d755 1
a755 1
  ]
d762 1
a762 1
  [  NetworkPodule
d765 1
a765 1
  ]
@


4.1.7.2
log
@Imported from SrcFiler
@
text
@d72 2
a73 2
	; We only know how to fake up STB2 MPEG1, MPEG2 (and MPEG0) podules
	ASSERT (FakePodule0 = 0) :LOR: (FakePodule0 = ProdType_STB2_MPEG1) :LOR: (FakePodule0 = ProdType_STB2_MPEG2)
d187 1
a187 1
 [ FakePodule0 <> 0
d191 1
a191 1
 ]
d361 1
a361 1
 [       FakePodule0 <> 0
a373 1
  [	FakePodule0 = ProdType_STB2_MPEG1
d387 1
a387 16
  |
; it's the STB2/2
MPEG1descoff	*       (MPEG1desc - MPEG1contents)/4		; offset of description from start
MPEG1desclen	*       (MPEG1end  - MPEG1desc)/4		; length of description
MPEG1contents	DCD     &00, &02, &00, (ProdType_STB2_MPEG2 :AND: &FF), (ProdType_STB2_MPEG2 :SHR: 8)
		DCD	(Manf_OnlineMedia :AND: &FF), (Manf_OnlineMedia :SHR: 8), &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
                DCD     &f5, MPEG1desclen, &00, &00, MPEG1descoff, &00, &00, &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
MPEG1desc	DCD     'I', 'n', 't', 'e', 'r', 'n', 'a', 'l'
                DCD     ' ', 'M', 'P', 'E', 'G', '2', ' ', 'h'
                DCD     'a', 'r', 'd', 'w', 'a', 'r', 'e',  0
MPEG1end
                ALIGN
  ]
 ]
d637 1
a637 1
 [ FakePodule0 <> 0
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d64 1
a64 1
NetworkPodule   SETL    NetPodSupport			; System build option
d70 1
a70 4
ExtensionROMs   SETL    ExtROMSupport			; System build option

	; We only know how to fake up STB2 MPEG1, MPEG2 (and MPEG0) podules
	ASSERT (FakePodule0 = 0) :LOR: (FakePodule0 = ProdType_STB2_MPEG1) :LOR: (FakePodule0 = ProdType_STB2_MPEG2)
d166 1
a166 1
 [ NetworkPodule
d170 1
a170 1
 |
d172 1
a172 1
 ]
d174 3
a176 3
 [ ExtensionROMs
   [ {TRUE}
StartOfROM      *       &03800000
d178 1
a178 1
   |
d181 2
a182 8
   ]
 ]

 [ FakePodule0 <> 0
MachineConfig   *       (IOMD_Base + IOMD_CLINES)
MPEGfittedbit   *       IOMD_C_MPEGfitted
MPEGIDByte      *       0
 ]
a351 44
 [       FakePodule0 <> 0
MPEG0descoff	*       (MPEG0desc - MPEG0contents)/4		; offset of description from start
MPEG0desclen	*       (MPEG0end  - MPEG0desc)/4		; length of description
MPEG0contents	DCD     &00, &02, &00, (ProdType_STB2_MPEG0 :AND: &FF), (ProdType_STB2_MPEG0 :SHR: 8)
		DCD	(Manf_OnlineMedia :AND: &FF), (Manf_OnlineMedia :SHR: 8), &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
                DCD     &f5, MPEG0desclen, &00, &00, MPEG0descoff, &00, &00, &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
MPEG0desc	DCD     'I', 'n', 't', 'e', 'r', 'n', 'a', 'l'
                DCD     ' ', 'v', 'i', 'd', 'e', 'o', ' ', 'h'
                DCD     'a', 'r', 'd', 'w', 'a', 'r', 'e',  0
MPEG0end
                ALIGN
  [	FakePodule0 = ProdType_STB2_MPEG1

MPEG1descoff	*       (MPEG1desc - MPEG1contents)/4		; offset of description from start
MPEG1desclen	*       (MPEG1end  - MPEG1desc)/4		; length of description
MPEG1contents	DCD     &00, &02, &00, (ProdType_STB2_MPEG1 :AND: &FF), (ProdType_STB2_MPEG1 :SHR: 8)
		DCD	(Manf_OnlineMedia :AND: &FF), (Manf_OnlineMedia :SHR: 8), &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
                DCD     &f5, MPEG1desclen, &00, &00, MPEG1descoff, &00, &00, &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
MPEG1desc	DCD     'I', 'n', 't', 'e', 'r', 'n', 'a', 'l'
                DCD     ' ', 'M', 'P', 'E', 'G', '1', ' ', 'h'
                DCD     'a', 'r', 'd', 'w', 'a', 'r', 'e',  0
MPEG1end
                ALIGN
  |
; it's the STB2/2
MPEG1descoff	*       (MPEG1desc - MPEG1contents)/4		; offset of description from start
MPEG1desclen	*       (MPEG1end  - MPEG1desc)/4		; length of description
MPEG1contents	DCD     &00, &02, &00, (ProdType_STB2_MPEG2 :AND: &FF), (ProdType_STB2_MPEG2 :SHR: 8)
		DCD	(Manf_OnlineMedia :AND: &FF), (Manf_OnlineMedia :SHR: 8), &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
                DCD     &f5, MPEG1desclen, &00, &00, MPEG1descoff, &00, &00, &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
MPEG1desc	DCD     'I', 'n', 't', 'e', 'r', 'n', 'a', 'l'
                DCD     ' ', 'M', 'P', 'E', 'G', '2', ' ', 'h'
                DCD     'a', 'r', 'd', 'w', 'a', 'r', 'e',  0
MPEG1end
                ALIGN
  ]
 ]

d595 1
a595 1
 [ ExtensionROMs
d597 1
a597 29
 ]
;	If this is a Set-Top Box, then we know we've got MPEG hardware fitted as Podule0 but without the (EP)ROM
;	We'll make if look like its a real podule
 [ FakePodule0 <> 0
        ADRL    r0, NormalPoduleNodeOffsets		; work out address of podule0 node
        LDR     r0, [r0]
        ADD     r0, r0, r2				; make it an absolute address

        MOV     r1, #MPEGIDByte
        STRB    r1, [ r0, #PoduleNode_IDByte ]		; set ID byte to make ConvertR3ToPoduleNode happy

        MOV     r1, #BitZero
        STRB    r1, [ r0, #PoduleNode_Flags ]		; This is a (fake) Podule

	MOV	r1, #PoduleCMOS
	STR	r1, [ r0,  #PoduleNode_CMOS ]		; We don't have no CMOS

	MOV	r1, #-1
	STR	r1, [ r0,  #PoduleNode_DMA ]		; We don't do DMA

;	See if MPEG is fitted and point the podule ROM address to the appropriate fake header
;	The description string will be extracted from this block in the normal way when chunks get enumerated
        LDR     r3, =MachineConfig
        LDRB    r1, [r3]
        TST     r1, #MPEGfittedbit
        ADREQ	r1, MPEG0contents
        ADRNE	r1, MPEG1contents
        STR     r1, [ r0, #PoduleNode_ROMAddress ]	; Location to read header from
 ]
d722 4
a725 4
  [  ExtensionROMs
        LDR     r9, number_of_extension_roms		; jharris: was r10, but r10 gets trashed by EnumerateChunks
   [  DebugModule
        BREG    r9, "There are &", cc
d727 3
a729 3
   ]
        TEQ     r9, #0
        BEQ     ExitLoadLoaders				; jharris: was BEQ to (non-existent) 99
d732 1
a732 1
   [  DebugModule
d734 1
a734 1
   ]
d737 1
a737 1
   [  DebugModule
d742 1
a742 1
   ]
d753 1
a753 1
        DECS    r9					; jharris
d755 1
a755 1
  ]
d762 1
a762 1
  [  NetworkPodule
d765 1
a765 1
  ]
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

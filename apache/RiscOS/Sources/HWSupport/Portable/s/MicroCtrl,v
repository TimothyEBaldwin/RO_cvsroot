head	4.4;
access;
symbols
	Portable-0_70:4.4
	Portable-0_69:4.4
	Portable-0_68:4.3
	Portable-0_67:4.3
	RO_5_07:4.3
	Portable-0_66:4.3
	dellis_autobuild_BaseSW:4.2
	sbrodie_sedwards_16Mar2000:4.2
	Portable-0_65:4.2
	dcotton_autobuild_BaseSW:4.3
	nturton_Portable-0_64:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	nicke_Portable_064:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2012.03.02.23.24.02;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	lloq9wGK9ZNZImVv;

4.3
date	2001.03.16.15.59.53;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.16.37.03;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.37.06;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.37.06;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.38.01;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.59.27;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.52.32;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.4
log
@Updated to use Hdr:Keyboard instead of Hdr:KEYV.
Made use of macro IOMDBase where appropriate.
Still doesn't assemble, and still needs 32 bitting.

Version 0.69. Tagged as 'Portable-0_69'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;
; Micro Controller
; ----------------
;
; Handles battery and keyboard commands/events between
; PS2Driver and the Stork battery-manager/keyboard controller.
;
; R C Manby 21/9/94
;


;******************************************************************************

        MakeErrorBlock  BadBMUVariable
        MakeErrorBlock  BadBMUCommand
        MakeErrorBlock  BMUBusy
        MakeErrorBlock  BMUVecClaim


;******************************************************************************
;
; InitMicroController
;
InitMicroController
        Entry   "R0"
        MOV     R0, #0
        STRB    R0, BMUDevFlag
        STR     R0, DriverPrivateWord
        STR     R0, Threaded
        STR     R0, PseudoIntMask
;>>>    Mask off interrupt???
        STRB    R0, PMInts_Enabled
        STRB    R0, CommandState
        EXIT


;******************************************************************************
;
; ClaimMicroControllerEvent
;
; Claims event, but DOES NOT enable interrupts from device.
;
; N.B. The Stork Keyboard/Battery-manager is mapped into 'Network'
;      space, so our event is actually Network IRQ.
;
ClaimMicroControllerEvent
        Entry   "R1-R2"

; preinitialise copy of BMU_Flags in case something fails during initialisation
; and we want the module to carry on

        MOV     R0,#PortableBMUF_ChargerPresent :OR: PortableBMUF_BatteryPresent :OR: PortableBMUF_LidOpen
        STRB    R0,BMU_Flags

        MOV     R0, #IOMD_Network_DevNo         ;Reused as microController event
        ADR     R1, MicroControllerEventHandler
        MOV     R2, R12                         ;Value we are passed, in R12, when called
        SWI     XOS_ClaimDeviceVector
        addr    R1,ErrorBlock_BMUVecClaim,VS    ; save error for SWI routines
        STRVS   R1,BMUerrorpointer
        EXIT    VS

        MOV     R0,#1                           ; indicate claimed device
        STRB    R0,BMUDevFlag
;
; We would like to check the BMU version number (the PortableA4 does), but can't.
; Unfortunately we can't communicate with BMU, because the PS2Driver hasn't yet
; enabled the INTs.
;
        MOV     R1,#0                           ; flag all ok for SWI routines
        STR     R1,BMUerrorpointer

        EXIT


;******************************************************************************
;
; ReleaseMicroControllerEvent
;
ReleaseMicroControllerEvent
        Entry   "R1-R2"
        LDRB    R1,BMUDevFlag
        TEQS    R1,#0
        EXITS   EQ

        MOV     R0, #IOMD_Network_DevNo         ;Reused as microController event
        ADR     R1, MicroControllerEventHandler
        MOV     R2, R12                         ;Value we are passed, in R12, when called
        SWI     XOS_ReleaseDeviceVector

; if released device, flag it as not claimed

        MOVVC   R1,#0
        STRVCB  R1,BMUDevFlag

; remove any pending callback for IRQ handler

        ADR     R0,BMUIRQCallback
        MOV     R1,wp
        SWI     XOS_RemoveCallBack

        EXIT


;******************************************************************************
;
; MicroControllerEventHandler - Service Rx interrupts from the
;                               Keyboard/Battery-manager controller.
;
; Entry
;   In IRQ mode with interrupts disabled
;   R12 = value passed in R2 to XOS_ClaimDeviceVector
;
; R0-R3 and R12 may be corrupted
;
; N.B. This is actually the Network IRQ event, hijacked by Stork.
;
MicroControllerEventHandler
        Entry  "R4,R9"                          ;Scratch registers, R9 needed for OS_CallAVector
        MOV     R0, #1                          ;Mark as threaded, cos sending data to PS2Driver
        STR     R0, Threaded                    ; may cause us to be re-entered.
;
;Process Rx interrupt
;
        BL      RxFromController                ;Out: R1=status, R2=data byte
        TST     R1, #uC_Status_PnK              ;Is it Power or Key data
        BLEQ    PseudoRxInterrupt               ; EQ, Key. In : R2=byte to send to keyboard driver
        TST     R1, #uC_Status_PnK              ;Is it Power or Key data
        BLNE    PowerInterrupt                  ; NE, Power

        BL      ProcessAnyTxInterrupts          ;While Tx interrupt enabled
                                                ;  do service Tx interrupt
        MOV     R0, #0
        STR     R0, Threaded
        EXIT


;******************************************************************************
;
; PowerInterrupt - Process power interrupt
;
; Entry
;   R1  = status
;   R2  = data byte
;
;   MODE: IRQ
;   IRQs disabled
;
; Exit
;   Corrupts R0, all other registers preserved
;
PowerInterrupt
        Entry
        TST     R1, #uC_Status_PwrChg           ;Is this a power state changed interrupt
        BNE     %FT10                           ; NE: yes

                                                ; EQ: this is an acknowledgement of, or a reply
                                                ;     to a power command that we sent
        LDRB    LR, CommandState                ;Are we expecting this?
        TEQ     LR, #1                          ;
        STREQB  R2, CommandResult               ; EQ: yes, stash reply
        MOVEQ   LR, #2                          ;
        STREQB  LR, CommandState                ;     indicate result available
        EXITS

10
;
; Add a callback, so IRQ is handled at a safer time.
;
        STRB    R2, Callback_Value              ;stash value to save re-reading
                                                ; switch to SVC mode for SWI
        MOV     R0, PC                          ; save mode
        TEQP    PC, #SVC_mode :OR: I_bit        ; enter SVC mode, with IRQs still disabled
        NOP

        Push    "R0, LR"
        ADR     R0, BMUIRQCallback
        MOV     R1, wp
        SWI     XOS_AddCallBack
        Pull    "R0, LR"
        TEQP    PC, R0                          ; reenter old mode
        NOP

        EXITS


;******************************************************************************
;
;
BMUIRQCallback
        Entry   "R0-R1"
        LDRB    R1, Callback_Value              ;value stashed by PowerInterrupt

; update flags and generate event
; R1 = BMU flags
; OS_GenerateEvent switches to SVC mode, disabling IRQs

        LDRB    LR, BMU_Flags                   ; get old flags
        EOR     LR, LR, R1                      ; EORed with new flags
        TST     LR, #PortableBMUF_LidOpen       ; has lid opened or closed?
        STRB    R1, BMU_Flags                   ; store new flags anyway
        BEQ     %FT05                           ; [no, so skip]

; lid switch has opened or closed, so make a dummy call to PortableControl
; which may turn on or off the LCDEnable and Backlight bits in LC.

        Push    "R0,R1"
        MOV     R0, #0                          ; EOR mask (ie no change)
        MOV     R1, #-1                         ; AND mask (ditto)
        BL      SWIControl
        Pull    "R0,R1"

05
        MOV     R0,#Event_PortableBMU
        SWI     XOS_GenerateEvent

        EXITS


;******************************************************************************
;
; KeyVHandler - Action stream control commands for the Keyboard from the
;               PS2Driver.
;
; Entry
;   R0  = reason code (KeyV_Xxxxx)
;
; Exit
;
KeyVHandler ROUT
        TEQ     r0, #KeyV_PseudoEnable          ;Pseudo stream enable
        TEQNE   r0, #KeyV_PseudoDisable         ;Pseudo stream disable
        TEQNE   r0, #KeyV_PseudoIntMask         ;Pseudo stream RX/TX interrupt enable
        MOVNES  pc, lr                          ;Not for us, so pass on call (to previous owner)

        Push    "R0-R4,R9"                      ;Scratch registers, R9 needed for OS_CallAVector

        TEQ     r0, #KeyV_PseudoIntMask
        BEQ     DoKeyV_PseudoIntMask

        TEQ     R0, #KeyV_PseudoEnable
        BEQ     DoKeyV_PseudoEnable

        TEQ     R0, #KeyV_PseudoDisable
        BEQ     DoKeyV_PseudoDisable
        Pull    "R0-R4,R9,PC"                   ;Restore stacked registers, use stacked PC value
                                                ; to return directly to caller


;
; DoKeyV_PseudoEnable
;
; Entry
;   R0  = 5
;   R1  = channel wsptr
;
DoKeyV_PseudoEnable
       ;DLINE   "StPortable: Pseudo stream enable"
        STR     R1, DriverPrivateWord
        Pull    "R0-R4,R9,PC"                   ;Restore stacked registers, use stacked PC value
                                                ; to return directly to caller


;
; DoKeyV_PseudoDisable
;
; Entry
;   R0  = 6
;   R1  = channel wsptr
;
DoKeyV_PseudoDisable
       ;DLINE   "StPortable: Pseudo stream disable"
        MOV     R1, #0
        STR     R1, DriverPrivateWord
        Pull    "R0-R4,R9,PC"                   ;Restore stacked registers, use stacked PC value
                                                ; to return directly to caller


;
; DoKeyV_PseudoIntMask
;
; Entry
;   R1 = Interrupt mask
;        2_00  Both Rx & Tx disabled
;        2_01  Rx enabled, Tx disabled
;        2_10  Tx enabled, Rx disabled
;
DoKeyV_PseudoIntMask
       ;DREG    R1, "StPortable: Pseudo stream RX/TX interrupt enable mask=&",,LongWord

        STR     R1, PseudoIntMask
        IOMDBase R3

;Turn IRQ & FIQ off whilst changing IOCIRQMSKB
        MOV     R4, PC                          ;Save IRQ and FIQ bits for later restoration
        ORR     R0, R4, #I_bit :OR: F_bit
        TEQP    R0, #0

; Set Network IRQ enable to same as Rx Int enable bit
        TST     R1, #2_01
        LDRB    R2, [R3, #IOCIRQMSKB]
        BICEQ   R2, R2, #IOMD_Network_IRQ_bit
        ORRNE   R2, R2, #IOMD_Network_IRQ_bit
        STRB    R2, [R3, #IOCIRQMSKB]

        TEQP    R4, #0                          ;restore IRQ and FIQ state

        LDR     R0, Threaded
        TEQ     R0, #0
        Pull    "R0-R4,R9,PC", NE               ;Restore stacked registers, use stacked PC value
                                                ; to return directly to caller
        MOV     R0, #1
        STR     R0, Threaded

        BL      ProcessAnyTxInterrupts          ;While Tx interrupt enabled
                                                ;  do service Tx interrupt
        MOV     R0, #0
        STR     R0, Threaded
        Pull    "R0-R4,R9,PC",                  ;Restore stacked registers, use stacked PC value
                                                ; to return directly to caller

;******************************************************************************
;
; ProcessAnyTxInterrupts
;
; Corrupts R0-R4,R9
;
ProcessAnyTxInterrupts
        Entry
        LDR     R1, PseudoIntMask
        TST     R1, #2_10                       ;Are Tx interrupts enabled?
        EXIT EQ                                 ; EQ, no, so return
42
;
; Tx interrupt enabled, this means that the PS2Driver has
; one or more bytes queued to send to the controller.
; Fetch a byte and send it.
;
        BL      PseudoTxInterrupt               ;Out: R2=command byte from driver
        BL      TxToKeyboard                    ;In : R2=byte to transmit
        LDR     R1, PseudoIntMask
        TST     R1, #2_10                       ;Are Tx interrupts still enabled?
        BNE     %BT42                           ; NE, yes, branch back to allow further transmittions
        EXIT


;******************************************************************************
;
; PseudoRxInterrupt - Generate a 'byte received from the keyboard' interrupt
;                     in the keyboard driver
;
; Entry
;   R2  = Byte to send to PS2Driver
;
; Exit
;   All registers preserved
;
PseudoRxInterrupt
        Entry   "R0-R2,R9,R11"
        SVCMode r11                             ;Go into SVC mode for SWI
        MOV     R0, #KeyV_PseudoRXInt           ;No need for NOP, this will do
        LDR     R1, DriverPrivateWord
        MOV     R9, #KEYV
        Push    "lr"                            ;Save r14_svc.
        SWI     XOS_CallAVector
        Pull    "lr"                            ;Restore r14_svc.
        SetPSR  r11                             ;Go back to IRQ/SVC mode
        NOP
        EXITS


;******************************************************************************
;
; PseudoTxInterrupt - Generate a 'give me a byte to send to the keyboard'
;                     interrupt in the keyboard driver
;
; Exit
;   R2  = Byte that driver wishes to be transmitted
;   All other registers preserved
;
PseudoTxInterrupt
        Entry   "R0,R1,R9,R11"
        SVCMode r11                             ;Go into SVC mode for SWI
        MOV     R0, #KeyV_PseudoTXInt           ;No need for NOP, this will do
        LDR     R1, DriverPrivateWord
        MOV     R9, #KEYV
        Push    "lr"                            ;Save r14_svc.
        SWI     XOS_CallAVector
        Pull    "lr"                            ;Restore r14_svc.
        SetPSR  r11                             ;Go back to IRQ/SVC mode
        NOP
        EXITS


;******************************************************************************
;
; TxToKeyboard
;
; Entry
;   R2  = Byte to send to keyboard
;
TxToKeyboard
        Entry   "R0, R1"
        LDR     R0, =uC_StatusReg               ;Get Tx buffer status bit
10                                              ;
        LDRB    R1, [R0]                        ;
        TST     R1, #uC_Status_OBF              ;
        BNE     %BT10                           ;Loop until buffer empties

        LDR     R0, =uC_KeyDataTxReg
        STRB    R2, [R0]                        ;Write byte to keyboard
        EXIT


;******************************************************************************
;
; RxFromController
;
; Exit
;   R1  = Status from Controller
;   R2  = Byte received from Controller
;
RxFromController
        Entry
        LDR     R2, =uC_StatusReg               ;Get Rx buffer status bit
10                                              ;
        LDRB    R1, [R2]                        ; since we are interrupt driven,
        TST     R1, #uC_Status_IBF              ; the data should be waiting, but...
        BEQ     %BT10                           ;Loop until data arrives

        LDR     R2, =uC_DataRxReg
        LDRB    R2, [R2]                        ;Get data byte

        EXIT

        LTORG


;******************************************************************************
;

InvalidCommand * &FF

; Mapping table of 'BMU variable' numbers onto micro-controller commands
; that will return the required information.
;
;
BMUVarTable
        DCB     InvalidCommand                  ;  0 : version number
        DCB     InvalidCommand                  ;  1 : nominal battery capacity
        DCB     InvalidCommand                  ;  2 : measured battery capacity
        DCB     InvalidCommand                  ;  3 : used battery capacity
        DCB     InvalidCommand                  ;  4 : usable capacity
        DCB     InvalidCommand                  ;  5 : reserved
        DCB     InvalidCommand                  ;  6 : charge estimate
        DCB     &32                             ;  7 : voltage
        DCB     InvalidCommand                  ;  8 : current
        DCB     &33                             ;  9 : temperature
        DCB     PwrCmd_Send_A4_flags            ; 10 : flags/status
        DCB     &30                             ; 11 : charge rate (b7..b4)
;
; Stork variables
;
        DCB     PwrCmd_Send_I_charge            ; 12 : charge current
        DCB     PwrCmd_Send_I_Discharge         ; 13 : discharge current
        DCB     PwrCmd_Send_V                   ; 14 : voltage
        DCB     PwrCmd_Send_T1                  ; 15 : temperature 1
        DCB     PwrCmd_Send_T2                  ; 16 : temperature 2
        DCB     PwrCmd_Send_charge_level        ; 17 : charge level
        DCB     PwrCmd_Send_A4_flags            ; 18 : status flags
        DCB     PwrCmd_Send_input_signals       ; 19 : input signals
        DCB     PwrCmd_Send_battery_capacity    ; 20 : battery capacity
        ASSERT  (. - BMUVarTable) = PortableBMU_Num_Variables

        ALIGN

BMUCmdTable
        DCB     PwrCmd_Power_down               ;  1 : remove power  : power down
        DCB     InvalidCommand                  ;  2
        DCB     InvalidCommand                  ;  3
        DCB     InvalidCommand                  ;  4
        DCB     PwrCmd_AC_OFF                   ;  5 : AC_OFF
        DCB     PwrCmd_AC_ON                    ;  6 : AC_ON
        DCB     PwrCmd_Disable_PMstat           ;  7 : Disable power managment status reporting
        DCB     PwrCmd_Enable_PMstat            ;  8 : Enable power managment status reporting

        ALIGN


;******************************************************************************
;
; SWI_ReadBMUVariable
;
; Entry
;    R0 = variable (0..11)
;
; Exit
;    VS => R0 -> error
;          R1 preserved
;    VC => R0 preserved
;          R1 value of variable
;    All other registers and flags preserved
;

;
; PortableBMUV_ChargeEstimate
; PortableBMUV_UsedCapacity
; PortableBMUV_Current
; PortableBMUV_Flags
; PortableBMUV_ChargeRate
; PortableBMUV_MeasuredCapacity
;

SWI_ReadBMUVariable Entry       "R0-R2"
;
; If Power management interupts are enabled then BMU flags are read from a soft copy (kept
; up-to-date by the interrupt routine). If not, or if reading another variable, we command
; the micro-controller to send the data.
;
        TEQS    R0, #PortableBMUV_Flags
        BNE     %FT10                           ;NE, not flags

        LDRB    R1, PMInts_Enabled              ;Is soft-copy up-to-date?
        TEQ     R1, #1

        LDREQB  R1, BMU_Flags                   ;EQ, yes, fetch soft copy
        STREQ   R1, [SP,#4]                     ;         and overwrite stacked R1
        EXITS   EQ
                                                ;Must ask micro-controller to send the flags
        BL      ReadBMUVariableInternal         ;call body of routine to read flags
        STRVS   R0, [SP]                        ;VS, overwrite stack R0 with error
        STRVC   R1, [SP,#4]                     ;VC, overwrite stacked R1 with result
        STRVCB  R1, BMU_Flags                   ;VC, update soft copy
        PullEnv
        BICVCS  PC,LR,#V_bit
        ORRVSS  PC,LR,#V_bit

ReadBMUVariableInternal ALTENTRY
10
        ASSERT  PortableBMU_Min_Variable = 0
        CMPS    R0,#PortableBMU_Num_Variables
        BHS     %FT90

        ADR     LR,BMUVarTable                  ; LR -> table of commands
        LDRB    R2, [LR,R0]                     ; R0 = BMU RAM address
        CMP     R2, #InvalidCommand
        BEQ     %FT90
        BL      SendPowerCommand                ;In: R2=command byte. Out: R2=reply byte
        STRVS   R0,[SP]                         ; if error, overwrite stack R0
        STRVC   R2,[SP,#4]                      ; if ok, overwrite stack R1
        PullEnv
        ORRVSS  PC,LR,#V_bit
        BICVCS  PC,LR,#V_bit

;~~~~~~~~~~~~~~~

90
; bad BMU variable number

        addr    R0,ErrorBlock_BadBMUVariable
92
; error, R0 -> tokenised error block

        BL      ErrorLookupNoParms
        STR     R0,[SP]                         ; overwrite stack R0
        PullEnv
        ORRS    PC,LR,#V_bit


;******************************************************************************
;
; BatMgr uses reason code PortableBMUV_ChargeEstimate only
;
SWI_WriteBMUVariable Entry
        EXIT


;******************************************************************************
;
; SWI_CommandBMU
;
; Entry
;    R0 = command
;    R1 etc. parameters
;
; Exit
;    VS => R0 -> error
;    VC => R0 preserved

;
;
; PortableBMUC_ConnectCharger
; PortableBMUC_DisconnectCharger
; PortableBMUC_RemovePower
; PortableBMUC_EnablePMInts
; PortableBMUC_DisablePMInts
;

; PortableBMUC_DisablePMInts and PortableBMUC_EnablePMInts are specifically tested for.
; If they are sucessfully commanded, the flag PMInts_Enabled is set/cleared.

SWI_CommandBMU  Entry   "R0-R3"
        ASSERT  (PortableBMUC_EnablePMInts - PortableBMUC_DisablePMInts) = 1
        SUBS    R2, R0, #PortableBMUC_DisablePMInts
        TEQNES  R0, #PortableBMUC_EnablePMInts
        BNE     %FT10
                                                ; R2 holds 0 for Disable and 1 for Enable
        BL      CommandBMUInternal              ; call body of routine to send command
        STRVS   R0, [SP]                        ;VS, overwrite stack R0 with error
        STRVCB  R2, PMInts_Enabled              ;VC, store 0/1 for PMInts disabled/enabled
        PullEnv
        BICVCS  PC,LR,#V_bit
        ORRVSS  PC,LR,#V_bit

CommandBMUInternal ALTENTRY
10
        CMPS    R0, #PortableBMU_Num_Commands
        BHS     %FT90
        SUBS    R0, R0, #PortableBMU_Min_Command
        BLO     %FT90

        ADR     LR, BMUCmdTable
        LDRB    R2, [LR, R0]
        CMP     R2, #InvalidCommand
        BEQ     %FT90
        BL      SendPowerCommand                ;In: R2=command byte. Out: R2=reply byte (ignored)
        STRVS   R0,[SP]                         ; if error, overwrite stack R0
        PullEnv
        BICVCS  PC,LR,#V_bit
        ORRVSS  PC,LR,#V_bit

;~~~~~~~~~~~~~~~

90
; bad BMU command code

        addr    R0,ErrorBlock_BadBMUCommand
        BL      ErrorLookupNoParms
        STR     R0,[SP]                         ; overwrite stack R0
        PullEnv
        ORRS    PC,LR,#V_bit


;******************************************************************************
;
; SendPowerCommand
;
; Entry
;   R2  = Command code
;
; Exit
;   R2  = Response byte
;
SendPowerCommand
        Entry   "R0, R1"

        ORR     LR, LR, #I_bit                  ; disable IRQ
        TEQP    PC, LR

        LDRB    R1, CommandState
        TEQ     R1, #0
        BNE     %FT89                        ;BMU command in progress

        MOV     R1, #1
        STRB    R1, CommandState

        LDR     R0, =uC_StatusReg               ;Get Tx buffer status bit
10                                              ;
        LDRB    R1, [R0]                        ;
        TST     R1, #uC_Status_OBF              ;
        BNE     %BT10                           ;Loop until buffer empties

        LDR     R0, =uC_PwrDataTxReg
        STRB    R2, [R0]                        ;Write byte to Power manager

        BIC     LR, LR, #I_bit                  ;ints on
        TEQP    PC, LR

        TEQ     R2, #PwrCmd_Power_down          ;These two don't send a reply,
        TEQNE   R2, #PwrCmd_Suspend             ; so skip the code that would try to fetch one
        BEQ     %FT30                           ;

20
        LDRB    R1, CommandState                ;Reply expected, so loop until it arrives
        TEQ     R1, #1                          ; under interrupt
        BEQ     %BT20

        LDRB    R2, CommandResult               ;Get reply
30
        MOV     R1, #0
        STRB    R1, CommandState
        EXIT

;~~~~~~~~~~~~~~~

89
; BMU command in progress

        BIC     LR, LR, #I_bit                  ;ints on
        TEQP    PC, LR

        addr    R0,ErrorBlock_BMUBusy
92
        BL      ErrorLookupNoParms
        STR     R0,[SP]                         ; overwrite stack R0
        PullEnv
        ORRS    PC,LR,#V_bit


;******************************************************************************


        END


@


4.3
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.66. Tagged as 'Portable-0_66'
@
text
@d240 1
a240 1
;   R0  = reason code (KEYV_Xxxxx)
d245 3
a247 3
        TEQ     r0, #KEYV_PseudoEnable          ;Pseudo stream enable
        TEQNE   r0, #KEYV_PseudoDisable         ;Pseudo stream disable
        TEQNE   r0, #KEYV_PseudoIntMask         ;Pseudo stream RX/TX interrupt enable
d252 1
a252 1
        TEQ     r0, #KEYV_PseudoIntMask
d255 1
a255 1
        TEQ     R0, #KEYV_PseudoEnable
d258 1
a258 1
        TEQ     R0, #KEYV_PseudoDisable
d375 1
a375 1
        MOV     R0, #KEYV_PseudoRXInt           ;No need for NOP, this will do
d398 1
a398 1
        MOV     R0, #KEYV_PseudoTXInt           ;No need for NOP, this will do
@


4.2
log
@Version Spin_merge taken
@
text
@d39 1
a39 1
        ENTRY   "R0"
d55 1
a55 1
; Claims event, but DOES NOT enable interrupts from device.   
d61 1
a61 1
        ENTRY   "R1-R2"
d83 1
a83 1
; 
d95 1
a95 1
        ENTRY   "R1-R2"
d117 1
a117 1
        
d121 1
a121 1
; MicroControllerEventHandler - Service Rx interrupts from the 
d133 1
a133 1
        ENTRY  "R4,R9"                          ;Scratch registers, R9 needed for OS_CallAVector
d167 1
a167 1
        ENTRY
d205 1
a205 1
        ENTRY   "R0-R1"
d300 1
a300 1
;        2_10  Tx enabled, Rx disabled 
d321 1
a321 1
 
d343 1
a343 1
        ENTRY
d373 1
a373 1
        ENTRY   "R0-R2,R9,R11"
d396 1
a396 1
        ENTRY   "R0,R1,R9,R11"
d417 1
a417 1
        ENTRY   "R0, R1"
d438 1
a438 1
        ENTRY
d528 1
a528 1
SWI_ReadBMUVariable ENTRY       "R0-R2"
d588 1
a588 1
SWI_WriteBMUVariable ENTRY
d616 1
a616 1
SWI_CommandBMU  ENTRY   "R0-R3"
d669 1
a669 1
        ENTRY   "R0, R1"
@


4.1
log
@Initial revision
@
text
@a30 2
        MakeErrorBlock  BadBMUVersion
        MakeErrorBlock  BMUFault
a33 1
 [ UseMicroController
a46 1
    ;    STRB    R0, BMU_Flags_Valid
d79 5
a83 15


;>>>read BMU version number
;>>>check BMU memory map

  ;      MOV     R2, #PwrCmd_Send_A4_flags
  ;      BL      SendPowerCommand
  ;      addr    R1,ErrorBlock_BMUFault,VS       ; save error for SWI routines
  ;      BVS     %FT90
  ;
  ;      STRB    R2, BMU_Flags
  ;
  ;     ;MOV     R0, #1
  ;      STRB    R0, BMU_Flags_Valid

a89 22
60
; incorrect BMU version number

        addr    R0,ErrorBlock_BadBMUVersion     ; R0 -> error block
        MOV     R1,R0                           ; save for SWI routines
        BL      ErrorLookupNoParms

; fall through to release device

90
; error, R0 -> error block, R1 -> error block for SWI routines
; release device

        STR     R1,BMUerrorpointer      ; save error pointer for SWI routines

        Push    "R0"                    ; save error
        BL      ReleaseMicroControllerEvent
        Pull    "R0"                    ; restore error
        SETV
        EXIT


d304 1
a304 2
    ;>>>IRQoff
    ;>>>should we turn IRQ & FIQ off??? cos of changing IOCIRQMSKB
d306 1
d308 6
a313 1
    ;>>>set Network IRQ enable to same as Rx Int enable bit
a314 1
        IOMDBase R3
d320 2
d463 12
a474 12
        DCB     InvalidCommand          ;  0 : version number
        DCB     InvalidCommand          ;  1 : nominal battery capacity
        DCB     InvalidCommand          ;  2 : measured battery capacity
        DCB     InvalidCommand          ;  3 : used battery capacity
        DCB     InvalidCommand          ;  4 : usable capacity
        DCB     InvalidCommand          ;  5 : reserved
        DCB     InvalidCommand          ;  6 : charge estimate
        DCB     &32                     ;  7 : voltage
        DCB     InvalidCommand          ;  8 : current
        DCB     &33                     ;  9 : temperature
        DCB     PwrCmd_Send_A4_flags    ; 10 : flags/status
        DCB     &30                     ; 11 : charge rate (b7..b4)
d478 9
a486 9
        DCB     &30                     ; 12 : charge current
        DCB     &31                     ; 13 : discharge current
        DCB     &32                     ; 14 : voltage
        DCB     &33                     ; 15 : temperature 1
        DCB     &34                     ; 16 : temperature 2
        DCB     &35                     ; 17 : charge level
        DCB     &36                     ; 18 : status flags
        DCB     &37                     ; 19 : input signals
        DCB     &39                     ; 20 : battery capacity
d488 1
d492 8
a499 8
        DCB     &40             ;  1 : remove power  : power down
        DCB     InvalidCommand  ;  2
        DCB     InvalidCommand  ;  3
        DCB     InvalidCommand  ;  4
        DCB     &42             ;  5                 : AC_OFF
        DCB     &43             ;  6                 : AC_ON
        DCB     &02             ;  7                 : Disable power managment status reporting
        DCB     &01             ;  8                 : Enable power managment status reporting
d535 4
a538 3
        LDREQB  R1, PMInts_Enabled
        TEQEQ   R1, #1
        BNE     %FT10                           ;NE, not flags or flags but soft copy out-of-date
d540 2
a541 2
        LDREQB  R1, BMU_Flags                   ; fetch soft copy
        STREQ   R1, [SP,#4]                     ; overwrite stacked R1
d543 8
d552 1
d617 1
a617 2
 ;EXITS
       ASSERT  (PortableBMUC_EnablePMInts - PortableBMUC_DisablePMInts) = 1
a620 1
 ;EXITS
a673 1

d676 1
a676 2
 ;       BNE                             ;

d690 1
a690 3
 ;       ints on

        BIC     LR, LR, #I_bit
a692 1

d708 1
a708 1
 |
d710 2
a711 12
;******************************************************************************
;
; KeyVHandler - My KeyV handler
;
; Entry:
;   r0 =
;
KeyVHandler ROUT
        TEQ     r0, #KEYV_PseudoEnable          ;Pseudo stream enable
        TEQNE   r0, #KEYV_PseudoDisable         ;Pseudo stream disable
        TEQNE   r0, #KEYV_PseudoIntMask         ;Pseudo stream RX/TX interrupt enable
        MOVNES  pc, lr
d713 2
a714 5
        ENTRY   "R0-R4,R9"
        TEQ     r0, #KEYV_PseudoIntMask
        BEQ     %FT710
        TEQ     r0, #KEYV_PseudoDisable
        BEQ     %FT610
d716 6
a721 8
       ;DLINE   "StPortable: Pseudo stream enable"
        STR     R1, DriverPrivateWord

        MOV     R0, #0
        STR     R0, ReplySeq1
        STR     R0, ReplySeq2
        STR     R0, ReplySeq3
        EXIT
a722 3
610
       ;DLINE   "StPortable: Pseudo stream disable"
        EXIT
d724 1
a724 26
710
       ;DLINE   "StPortable: Pseudo stream RX/TX interrupt enable"

        TST     R1, #2_10
        BEQ     %FT800
       ;DLINE   "StPortable:   RxOffTxOn"

        MOV     R0, #KEYV_PseudoTXInt
        LDR     R1, DriverPrivateWord
        MOV     R9, #KEYV
        SWI     XOS_CallAVector
       ;DREG    R2, "StPortable: Retreived &",,LongWord

        CMP     R2, #command_RESET
        MOVEQ   R0, #1                  ;reply with ACK,BAT
        STREQ   R0, ReplySeq1
        MOVEQ   R0, #0
        STREQ   R0, ReplySeq2
        STREQ   R0, ReplySeq3

        CMP     R2, #command_DEFAULT
        MOVEQ   R0, #1                  ;reply with ACK
        STREQ   R0, ReplySeq2

        CMP     R2, #command_SETRATE
        BNE     %FT770
a725 108
        MOV     R0, #KEYV_PseudoTXInt
        LDR     R1, DriverPrivateWord
        MOV     R9, #KEYV
        SWI     XOS_CallAVector
       ;DREG    R2, "StPortable: Retreived &",,LongWord

        MOVEQ   R0, #1                  ;reply with ACK
        STREQ   R0, ReplySeq3

770
        BL      TrySending
        EXIT

800
        TST     R1, #2_01       ;ie RxOnTxOff
        BEQ     %FT900
       ;DLINE   "StPortable:   RxOnTxOff"

       ;BL      TrySending

        EXIT
900
       ;DLINE   "StPortable:   RxOffTxOff"

        EXIT

TrySending
        ENTRY   "R9"
        LDR     R0, ReplySeq1
        CMP     R0, #0
        BEQ     %FT810
        SUB     R0, R0, #1
        STR     R0, ReplySeq1

        MOV     R2, #keybd_ACK
        MOV     R0, #KEYV_PseudoRXInt
        LDR     R1, DriverPrivateWord
        MOV     R9, #KEYV
        SWI     XOS_CallAVector
    ;EXIT
        MOV     R2, #keybd_BAT
        MOV     R0, #KEYV_PseudoRXInt
        LDR     R1, DriverPrivateWord
        MOV     R9, #KEYV
        SWI     XOS_CallAVector

        EXIT
810
        LDR     R0, ReplySeq2
        CMP     R0, #0
        BEQ     %FT820
        SUB     R0, R0, #1
        STR     R0, ReplySeq2
 ; EXIT
        MOV     R2, #keybd_ACK
        MOV     R0, #KEYV_PseudoRXInt
        LDR     R1, DriverPrivateWord
        MOV     R9, #KEYV
        SWI     XOS_CallAVector

        EXIT

820
        LDR     R0, ReplySeq3
        CMP     R0, #0
        BEQ     %FT830
        SUB     R0, R0, #1
        STR     R0, ReplySeq3
 ; EXIT
        MOV     R2, #keybd_ACK
        MOV     R0, #KEYV_PseudoRXInt
        LDR     R1, DriverPrivateWord
        MOV     R9, #KEYV
        SWI     XOS_CallAVector

        EXIT
830
        EXIT



SWI_ReadBMUVariable      ROUT
        CMPS    R0,#PortableBMU_Num_Variables
        addr    R0,ErrorBlock_BadVarNam,HS
        ORRHSS  PC,LR,#V_bit

        wsaddr  R1,variables
        ADD     R1,R1,R0,ASL #2
        LDR     R1,[R1]
        BICS    PC,LR,#V_bit


SWI_WriteBMUVariable     ROUT
        CMPS    R0,#PortableBMU_Num_Variables
        addr    R0,ErrorBlock_BadVarNam,HS
        ORRHSS  PC,LR,#V_bit

        Push    "R0,LR"

        wsaddr  LR,variables
        ADD     LR,LR,R0,ASL #2
        STR     R1,[LR]
        TEQS    R0,#PortableBMUV_Flags
        MOVEQ   R0,#Event_PortableBMU
        SWIEQ   XOS_GenerateEvent

        Pull    "R0,LR"
        BICS    PC,LR,#V_bit
a726 45

SWI_CommandBMU   ROUT
       ;DREG    R0, "SWICommandBMU, R0 is ",,Integer

        Push    "R1-R2,LR"
        TEQS    R0,#2                   ; set part charge?
        BNE     %FT10

; set part charged i.e. 4/5 of full charge used

        LDR     LR,variables+1*4
        MOV     LR,LR,ASL #2            ; *4
        DivRem  R1,LR,#5,R2             ; /5
        STR     R1,variables+3*4

        LDR     LR,variables+4*4
        MOV     LR,LR,ASL #2            ; *4
        DivRem  R1,LR,#5,R2             ; /5
        STR     R1,variables+6*4

        LDR     LR,variables+10*4
        ORR     LR,LR,#&20
        STR     LR,variables+10*4

        Pull    "R1-R2,LR"
        BICS    PC,LR,#V_bit

;~~~~~~~~~~~~~~~
10
        TEQS    R0,#3                   ; set full?
        Pull    "R1-R2,PC",NE,^

        MOV     LR,#0
        STR     LR,variables+3*4
        STR     LR,variables+6*4

        LDR     LR,variables+10*4
        ORR     LR,LR,#&20
        STR     LR,variables+10*4

        Pull    "R1-R2,LR"
        BICS    PC,LR,#V_bit


 ]
a727 1

@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d31 2
d36 1
d50 1
d83 15
a97 5
;
; We would like to check the BMU version number (the PortableA4 does), but can't.
; Unfortunately we can't communicate with BMU, because the PS2Driver hasn't yet
; enabled the INTs.
; 
d104 22
d340 2
a341 1

a342 1
        IOMDBase R3
d344 1
a344 6
;Turn IRQ & FIQ off whilst changing IOCIRQMSKB
        MOV     R4, PC                          ;Save IRQ and FIQ bits for later restoration
        ORR     R0, R4, #I_bit :OR: F_bit
        TEQP    R0, #0

; Set Network IRQ enable to same as Rx Int enable bit
d346 1
a351 2
        TEQP    R4, #0                          ;restore IRQ and FIQ state
 
d493 12
a504 12
        DCB     InvalidCommand                  ;  0 : version number
        DCB     InvalidCommand                  ;  1 : nominal battery capacity
        DCB     InvalidCommand                  ;  2 : measured battery capacity
        DCB     InvalidCommand                  ;  3 : used battery capacity
        DCB     InvalidCommand                  ;  4 : usable capacity
        DCB     InvalidCommand                  ;  5 : reserved
        DCB     InvalidCommand                  ;  6 : charge estimate
        DCB     &32                             ;  7 : voltage
        DCB     InvalidCommand                  ;  8 : current
        DCB     &33                             ;  9 : temperature
        DCB     PwrCmd_Send_A4_flags            ; 10 : flags/status
        DCB     &30                             ; 11 : charge rate (b7..b4)
d508 9
a516 9
        DCB     PwrCmd_Send_I_charge            ; 12 : charge current
        DCB     PwrCmd_Send_I_Discharge         ; 13 : discharge current
        DCB     PwrCmd_Send_V                   ; 14 : voltage
        DCB     PwrCmd_Send_T1                  ; 15 : temperature 1
        DCB     PwrCmd_Send_T2                  ; 16 : temperature 2
        DCB     PwrCmd_Send_charge_level        ; 17 : charge level
        DCB     PwrCmd_Send_A4_flags            ; 18 : status flags
        DCB     PwrCmd_Send_input_signals       ; 19 : input signals
        DCB     PwrCmd_Send_battery_capacity    ; 20 : battery capacity
a517 1

d521 8
a528 8
        DCB     PwrCmd_Power_down               ;  1 : remove power  : power down
        DCB     InvalidCommand                  ;  2
        DCB     InvalidCommand                  ;  3
        DCB     InvalidCommand                  ;  4
        DCB     PwrCmd_AC_OFF                   ;  5 : AC_OFF
        DCB     PwrCmd_AC_ON                    ;  6 : AC_ON
        DCB     PwrCmd_Disable_PMstat           ;  7 : Disable power managment status reporting
        DCB     PwrCmd_Enable_PMstat            ;  8 : Enable power managment status reporting
d564 3
a566 4
        BNE     %FT10                           ;NE, not flags

        LDRB    R1, PMInts_Enabled              ;Is soft-copy up-to-date?
        TEQ     R1, #1
d568 2
a569 2
        LDREQB  R1, BMU_Flags                   ;EQ, yes, fetch soft copy
        STREQ   R1, [SP,#4]                     ;         and overwrite stacked R1
a570 8
                                                ;Must ask micro-controller to send the flags
        BL      ReadBMUVariableInternal         ;call body of routine to read flags
        STRVS   R0, [SP]                        ;VS, overwrite stack R0 with error
        STRVC   R1, [SP,#4]                     ;VC, overwrite stacked R1 with result
        STRVCB  R1, BMU_Flags                   ;VC, update soft copy
        PullEnv
        BICVCS  PC,LR,#V_bit
        ORRVSS  PC,LR,#V_bit
a571 1
ReadBMUVariableInternal ALTENTRY
d636 2
a637 1
        ASSERT  (PortableBMUC_EnablePMInts - PortableBMUC_DisablePMInts) = 1
d641 1
d695 1
d698 2
a699 1
        BNE     %FT89                        ;BMU command in progress
d713 3
a715 1
        BIC     LR, LR, #I_bit                  ;ints on
d718 1
d734 193
a926 1
;~~~~~~~~~~~~~~~
d928 2
a929 2
89
; BMU command in progress
d931 4
a934 2
        BIC     LR, LR, #I_bit                  ;ints on
        TEQP    PC, LR
d936 3
a938 6
        addr    R0,ErrorBlock_BMUBusy
92
        BL      ErrorLookupNoParms
        STR     R0,[SP]                         ; overwrite stack R0
        PullEnv
        ORRS    PC,LR,#V_bit
d940 3
d944 2
a945 1
;******************************************************************************
d948 1
d950 1
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d31 2
d36 1
d50 1
d83 15
a97 5
;
; We would like to check the BMU version number (the PortableA4 does), but can't.
; Unfortunately we can't communicate with BMU, because the PS2Driver hasn't yet
; enabled the INTs.
; 
d104 22
d340 2
a341 1

a342 1
        IOMDBase R3
d344 1
a344 6
;Turn IRQ & FIQ off whilst changing IOCIRQMSKB
        MOV     R4, PC                          ;Save IRQ and FIQ bits for later restoration
        ORR     R0, R4, #I_bit :OR: F_bit
        TEQP    R0, #0

; Set Network IRQ enable to same as Rx Int enable bit
d346 1
a351 2
        TEQP    R4, #0                          ;restore IRQ and FIQ state
 
d493 12
a504 12
        DCB     InvalidCommand                  ;  0 : version number
        DCB     InvalidCommand                  ;  1 : nominal battery capacity
        DCB     InvalidCommand                  ;  2 : measured battery capacity
        DCB     InvalidCommand                  ;  3 : used battery capacity
        DCB     InvalidCommand                  ;  4 : usable capacity
        DCB     InvalidCommand                  ;  5 : reserved
        DCB     InvalidCommand                  ;  6 : charge estimate
        DCB     &32                             ;  7 : voltage
        DCB     InvalidCommand                  ;  8 : current
        DCB     &33                             ;  9 : temperature
        DCB     PwrCmd_Send_A4_flags            ; 10 : flags/status
        DCB     &30                             ; 11 : charge rate (b7..b4)
d508 9
a516 9
        DCB     PwrCmd_Send_I_charge            ; 12 : charge current
        DCB     PwrCmd_Send_I_Discharge         ; 13 : discharge current
        DCB     PwrCmd_Send_V                   ; 14 : voltage
        DCB     PwrCmd_Send_T1                  ; 15 : temperature 1
        DCB     PwrCmd_Send_T2                  ; 16 : temperature 2
        DCB     PwrCmd_Send_charge_level        ; 17 : charge level
        DCB     PwrCmd_Send_A4_flags            ; 18 : status flags
        DCB     PwrCmd_Send_input_signals       ; 19 : input signals
        DCB     PwrCmd_Send_battery_capacity    ; 20 : battery capacity
a517 1

d521 8
a528 8
        DCB     PwrCmd_Power_down               ;  1 : remove power  : power down
        DCB     InvalidCommand                  ;  2
        DCB     InvalidCommand                  ;  3
        DCB     InvalidCommand                  ;  4
        DCB     PwrCmd_AC_OFF                   ;  5 : AC_OFF
        DCB     PwrCmd_AC_ON                    ;  6 : AC_ON
        DCB     PwrCmd_Disable_PMstat           ;  7 : Disable power managment status reporting
        DCB     PwrCmd_Enable_PMstat            ;  8 : Enable power managment status reporting
d564 3
a566 4
        BNE     %FT10                           ;NE, not flags

        LDRB    R1, PMInts_Enabled              ;Is soft-copy up-to-date?
        TEQ     R1, #1
d568 2
a569 2
        LDREQB  R1, BMU_Flags                   ;EQ, yes, fetch soft copy
        STREQ   R1, [SP,#4]                     ;         and overwrite stacked R1
a570 8
                                                ;Must ask micro-controller to send the flags
        BL      ReadBMUVariableInternal         ;call body of routine to read flags
        STRVS   R0, [SP]                        ;VS, overwrite stack R0 with error
        STRVC   R1, [SP,#4]                     ;VC, overwrite stacked R1 with result
        STRVCB  R1, BMU_Flags                   ;VC, update soft copy
        PullEnv
        BICVCS  PC,LR,#V_bit
        ORRVSS  PC,LR,#V_bit
a571 1
ReadBMUVariableInternal ALTENTRY
d636 2
a637 1
        ASSERT  (PortableBMUC_EnablePMInts - PortableBMUC_DisablePMInts) = 1
d641 1
d695 1
d698 2
a699 1
        BNE     %FT89                        ;BMU command in progress
d713 3
a715 1
        BIC     LR, LR, #I_bit                  ;ints on
d718 1
d734 193
a926 1
;~~~~~~~~~~~~~~~
d928 2
a929 2
89
; BMU command in progress
d931 4
a934 2
        BIC     LR, LR, #I_bit                  ;ints on
        TEQP    PC, LR
d936 3
a938 6
        addr    R0,ErrorBlock_BMUBusy
92
        BL      ErrorLookupNoParms
        STR     R0,[SP]                         ; overwrite stack R0
        PullEnv
        ORRS    PC,LR,#V_bit
d940 3
d944 2
a945 1
;******************************************************************************
d948 1
d950 1
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d31 2
d36 1
d50 1
d83 15
a97 5
;
; We would like to check the BMU version number (the PortableA4 does), but can't.
; Unfortunately we can't communicate with BMU, because the PS2Driver hasn't yet
; enabled the INTs.
; 
d104 22
d340 2
a341 1

a342 1
        IOMDBase R3
d344 1
a344 6
;Turn IRQ & FIQ off whilst changing IOCIRQMSKB
        MOV     R4, PC                          ;Save IRQ and FIQ bits for later restoration
        ORR     R0, R4, #I_bit :OR: F_bit
        TEQP    R0, #0

; Set Network IRQ enable to same as Rx Int enable bit
d346 1
a351 2
        TEQP    R4, #0                          ;restore IRQ and FIQ state
 
d493 12
a504 12
        DCB     InvalidCommand                  ;  0 : version number
        DCB     InvalidCommand                  ;  1 : nominal battery capacity
        DCB     InvalidCommand                  ;  2 : measured battery capacity
        DCB     InvalidCommand                  ;  3 : used battery capacity
        DCB     InvalidCommand                  ;  4 : usable capacity
        DCB     InvalidCommand                  ;  5 : reserved
        DCB     InvalidCommand                  ;  6 : charge estimate
        DCB     &32                             ;  7 : voltage
        DCB     InvalidCommand                  ;  8 : current
        DCB     &33                             ;  9 : temperature
        DCB     PwrCmd_Send_A4_flags            ; 10 : flags/status
        DCB     &30                             ; 11 : charge rate (b7..b4)
d508 9
a516 9
        DCB     PwrCmd_Send_I_charge            ; 12 : charge current
        DCB     PwrCmd_Send_I_Discharge         ; 13 : discharge current
        DCB     PwrCmd_Send_V                   ; 14 : voltage
        DCB     PwrCmd_Send_T1                  ; 15 : temperature 1
        DCB     PwrCmd_Send_T2                  ; 16 : temperature 2
        DCB     PwrCmd_Send_charge_level        ; 17 : charge level
        DCB     PwrCmd_Send_A4_flags            ; 18 : status flags
        DCB     PwrCmd_Send_input_signals       ; 19 : input signals
        DCB     PwrCmd_Send_battery_capacity    ; 20 : battery capacity
a517 1

d521 8
a528 8
        DCB     PwrCmd_Power_down               ;  1 : remove power  : power down
        DCB     InvalidCommand                  ;  2
        DCB     InvalidCommand                  ;  3
        DCB     InvalidCommand                  ;  4
        DCB     PwrCmd_AC_OFF                   ;  5 : AC_OFF
        DCB     PwrCmd_AC_ON                    ;  6 : AC_ON
        DCB     PwrCmd_Disable_PMstat           ;  7 : Disable power managment status reporting
        DCB     PwrCmd_Enable_PMstat            ;  8 : Enable power managment status reporting
d564 3
a566 4
        BNE     %FT10                           ;NE, not flags

        LDRB    R1, PMInts_Enabled              ;Is soft-copy up-to-date?
        TEQ     R1, #1
d568 2
a569 2
        LDREQB  R1, BMU_Flags                   ;EQ, yes, fetch soft copy
        STREQ   R1, [SP,#4]                     ;         and overwrite stacked R1
a570 8
                                                ;Must ask micro-controller to send the flags
        BL      ReadBMUVariableInternal         ;call body of routine to read flags
        STRVS   R0, [SP]                        ;VS, overwrite stack R0 with error
        STRVC   R1, [SP,#4]                     ;VC, overwrite stacked R1 with result
        STRVCB  R1, BMU_Flags                   ;VC, update soft copy
        PullEnv
        BICVCS  PC,LR,#V_bit
        ORRVSS  PC,LR,#V_bit
a571 1
ReadBMUVariableInternal ALTENTRY
d636 2
a637 1
        ASSERT  (PortableBMUC_EnablePMInts - PortableBMUC_DisablePMInts) = 1
d641 1
d695 1
d698 2
a699 1
        BNE     %FT89                        ;BMU command in progress
d713 3
a715 1
        BIC     LR, LR, #I_bit                  ;ints on
d718 1
d734 193
a926 1
;~~~~~~~~~~~~~~~
d928 2
a929 2
89
; BMU command in progress
d931 4
a934 2
        BIC     LR, LR, #I_bit                  ;ints on
        TEQP    PC, LR
d936 3
a938 6
        addr    R0,ErrorBlock_BMUBusy
92
        BL      ErrorLookupNoParms
        STR     R0,[SP]                         ; overwrite stack R0
        PullEnv
        ORRS    PC,LR,#V_bit
d940 3
d944 2
a945 1
;******************************************************************************
d948 1
d950 1
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.4;
access;
symbols
	Portable-0_70:4.4
	Portable-0_69:4.4
	Portable-0_68:4.3
	Portable-0_67:4.3
	RO_5_07:4.3
	Portable-0_66:4.3
	dellis_autobuild_BaseSW:4.2
	sbrodie_sedwards_16Mar2000:4.2
	Portable-0_65:4.2
	dcotton_autobuild_BaseSW:4.3
	nturton_Portable-0_64:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	nicke_Portable_064:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2012.03.02.23.24.02;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	lloq9wGK9ZNZImVv;

4.3
date	2001.03.16.15.59.53;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.16.30.35;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.37.06;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.37.06;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.38.06;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.59.29;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.52.33;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.4
log
@Updated to use Hdr:Keyboard instead of Hdr:KEYV.
Made use of macro IOMDBase where appropriate.
Still doesn't assemble, and still needs 32 bitting.

Version 0.69. Tagged as 'Portable-0_69'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;
;
; PowerCtrl
; ---------
;
; Physical switching of supply rails to 'power hungry' hardware and
; the control of configurable devices such as the I/O combo chip.
;
; Split from StPortable 8/2/95
;


 [ SwitchPower
;******************************************************************************
;
; InitLatchSoftCopies
;
; We assume the Kernel has turned most of the hardware on, so that the
; machine is usable if we (the Portable module) are unplugged, or fail
; to start up.
;
; We initialise the PortSoftCopies to that state and to ensure consistancy
; write that to the Hardware latches. Providing we and the Kernel see
; eye-to-eye on this, nothing power-wise will have changed.
;
InitLatchSoftCopies
        Entry   "R0-R2"
        ADR     R14, PowerTab
05
        LDMIA   R14!, {R0, R1, R2}              ;Soft copy offset in ws, latch address, initial value
        TEQ     R0, #0
        STRNEB  R2, [R12, R0]                   ;Write soft copy
        STRNEB  R2, [R1]                        ;Write to latch
        BNE     %BT05
        EXITS

;
; Must be consistent with PowerTab in Kernel (s.PMF.osinit)
;
PowerTab
        DCD     :INDEX:SCLatchPA, HWLatchPA, InitLatchPA
        DCD     :INDEX:SCLatchPB, HWLatchPB, InitLatchPB
        DCD     :INDEX:SCLatchMC, HWLatchMC, InitLatchMC
        DCD     :INDEX:SCLatchMA, HWLatchMA, InitLatchMA
        DCD     0
        ASSERT :INDEX:PortSoftCopies <> 0       ;cos we use 0 to terminate the table
 ]


;******************************************************************************
;
; Initialise the variables used by Portable_Control and ensure the hardware
; is in a consistant state.
;
InitSWIPortableControl Entry "r0-r2"
        LDR     R1, =InitialPowerState          ;We expect the Kernel to have switched
        STR     R1, ConfigExtraBitsCopy         ; everything on at start up. But to be on the
        MVN     R0, R1                          ; safe side, force the hardware to that state
        STR     R0, ControlInternal             ; anyway.
        BL      SetPwrState                     ; NB no power-up messages sent.

        MOV     r0, #0                          ;Now try turning off as much off as possible,
        LDR     r1, =:NOT: PowerSaveBits        ; serial, parallel and FDC etc
        BL      SWIControl                      ; NB this call does send power-down messages.

        MOV     r0, #PortableControl_IntTBallEnable     ;Switch from mouse to trackerball
        MOV     r1, #:NOT:(PortableControl_IntTBallEnable :OR: PortableControl_ExtMouseEnable)
        BL      SWIControl

        EXITS


;******************************************************************************
;
; PortableControl - Read/write various power/LCD control settings
;
; Entry
;   R0  = EOR mask
;   R1  = AND mask
;
;   New value = (Old value AND R1) EOR R0
;
; Exit
;   R0  = old value
;   R1  = new value
;
;
; where the bits in control are as follows:-
;
; '+' indicates a bit new for Stork, '-' indicates an 'A4' bit ignored by Stork
;
;       Bit     Meaning
;
;  -    0       Set => power to Econet enabled
;       1       Set => power to LCD display enabled
;       2       Set => power to external video display enabled
;       3       Set => power to serial buffer and oscillator enabled
;  -    4       Set => dual panel mode enabled
;  -    6,5     Video clock control
;                 0,0 => External clock input
;                 0,1 => Crystal oscillator, divided by 2
;                 1,0 => Crystal oscillator
;                 1,1 => reserved, do not use
;  -    7       Set => invert video clock
;       8       Set => back-light enabled
;  -    9       Clear => 1 extra line on display, Set => 2 extra lines
;  -    10      Clear => 1 DRAM used for dual panel, Set => 2 DRAMs
;  +    11      Set => power to sound filters and amplifiers enabled
;  +    12      Set => PCMCIA hardware enabled
;  +    13      Set => power to Parallel port enabled
;       14      Set => power to FDC oscillator in 82C710/82C711 enabled
;  +    15      Set => power to IDC hard disc enabled
;       16      Set => LCD palette set up for inverse video
;  +    17      Set => trackerball (internal) enabled } see comments in code
;  +    18      Set => mouse (external) enabled       }
;  +    19      Set => external keyboard and external mouse power enabled
;       19..31  Reserved: these bits must not be modified, nor assumed to
;                read any particular value.
;
;
;            Bit          16..12...8...4...0
ControlValidBits    * 2_11111110100100001110
                     ;2_00010100011111111111

ControlServiceBits  * 2_11101110100000001000         ; bits that require service call when changing
                     ;2_00000100000000001001

ControlPWRGDBits    * 2_00001110000000001000       ;Bits that require PWRGD pin of '665 held high
ControlConfigBits   * 2_00001110000000001000         ; bits that require us to enter config mode in 710/711
ControlOscilBits    * 2_00000100000000001000         ; bits that control the oscillator
ControlExtraBits    * 2_11111110100100001110

;>>>suggest renaming InitialPowerState as KernelPowerState
;>>>have mask of bits to power down (FDC, IDE etc)
;>>>and mask of bits to power up (trackerball, LCD)
;
InitialPowerState   * 2_11001111100000001000       ;Everything-on state as setup by Kernel
PowerSaveBits       * 2_10001111100000001000       ;The bits we attempt to powerdown

Shutdown1Bits       * 2_00001111100000001000
Shutdown2Bits       * 2_11101111100100001010

;                       EEI IFPPS  B    S L
;                       xxn DDaCo  a    e C
;                       ttt ECrMu  c    r D
;                             aCn  k    i
;                       PMT   lId  l    a
;                       ooB   lA   i    l
;                       wua   e    g
;                       esl   l    h
;                       rel        t
;
SWIControl      Entry "r2,r3"
        TEQP    pc, #SVC_mode + I_bit
 [ Debug
        NOP
        DREG    R0, "In 'Real' Portable_Control: EOR &", cc, LongWord
        DREG    R1, ", AND &",, LongWord
 ]
        MOV     r3, r0                          ;preserve EOR mask for later
        LDR     R0, ConfigExtraBitsCopy         ;get old state

        AND     r1, r0, r1
        EOR     r1, r1, r3
        LDR     r3, =ControlValidBits
        AND     r1, r1, r3                      ; r1 is now new state
;
; R0 = current state, R1 = required state
;

;
; Current hardware provides two control lines 'ExternalPower' and 'TrackballNotMouse' to control
; power too and select between an external keyboard, external mouse or internal trackerball.
;
; ExternalPower controls power to both external PS2 ports. The external keyboard port is
; connected directly to the KBD port in Morris and is active whenever ExternalPower is active.
;
; TrackballNotMouse controls the routing of data to Morris' MSE port. 'Trackball' applies power
; to the internal trackerball and routes its data to Morris' MSE port. 'Mouse' routes data from
; the external mouse socket to Morris' MSE port if ExternalPower is active. Selecting 'Mouse'
; with ExternalPower 'off' leaves both ports inactive and in a low power state.
;
; Bit PortableControl_ExtPowerEnable directly controls 'ExternalPower'
; Bit PortableControl_IntTBallEnable directly controls 'TrackballNotMouse'
;
; PortableControl_ExtMouseEnable := NOT(PortableControl_IntTBallEnable) AND PortableControl_ExtPowerEnable
;
; We manufacture the PortableControl_ExtMouseEnable bit and send power down/up messages for it
; to allow the PS2Driver to correctly kill/reset Morris' MSE port.
;
        TST     r1, #PortableControl_IntTBallEnable     ;On current hardware, ExtMouseEnable is
        BICNE   r1, r1, #PortableControl_ExtMouseEnable ; inverse of IntTBallEnable
        ORREQ   r1, r1, #PortableControl_ExtMouseEnable ;
        TST     r1, #PortableControl_ExtPowerEnable     ; unless power is off of course
        BICEQ   r1, r1, #PortableControl_ExtMouseEnable ; (in which case mouse is off)

;
; Floppy and printer are mutually exclusive (both share the same connector), so prevent
; selection of both.
;
        TST     r1, #PortableControl_FDCEnable
        BICNE   r1, r1, #PortableControl_ParallelEnable

;
; The code to switch the LCD off if the machine lid is closed is in SetPwrState.
;

;
; R0 = current state, R1 = required state
;
        EOR     r3, r1, r0                      ; r3 = bits that have changed
        LDR     lr, =ControlServiceBits
        AND     r3, r3, lr                      ; r3 = bits that have changed that require service
        ANDS    r3, r3, r0                      ; r3 = bits that are going from 1 to 0 (ie power -> off)
        BEQ     %FT10                           ; [no power bits going off]

        Push    "r1-r3"                         ;R0 preserved by XOS_ServiceCall
        MOV     r1, #Service_Portable
        MOV     r2, #ServicePortable_PowerDown  ; indicate power about to go off
        SWI     XOS_ServiceCall                 ; r3 = mask of bits going off
        Pull    "r1,r2,lr"                      ; on exit r3 = mask of bits that are allowed to go off
        EOR     r3, r3, lr                      ; bits which were forbidden to go off
        ORR     r1, r1, r3                      ; so we'd better put them back on!
10
        LDR     lr, =ControlExtraBits
        AND     lr, lr, r1
        STR     lr, ConfigExtraBitsCopy         ; store soft copy bits

        BL      SetPwrState                     ;R0 = current state, R1 = required state

; now issue post service for those power bits that have just been turned on
        EOR     r3, r1, r0                      ; r3 = bits that have changed
        LDR     lr, =ControlServiceBits
        AND     r3, r3, lr                      ; r3 = bits that have changed that require service
        ANDS    r3, r3, r1                      ; r3 = bits that are going from 0 to 1 (ie power -> on)
        BEQ     %FT30                           ; [no power bits going on]

        Push    "r1,r2"                         ;R0 preserved by XOS_ServiceCall
        MOV     r1, #Service_Portable
        MOV     r2, #ServicePortable_PowerUp    ; indicate power has just gone on
        SWI     XOS_ServiceCall                 ; r3 = mask of bits going on
        Pull    "r1,r2"                         ; restore registers
30
 [ Debug
       ;DREG    R0, "'Real' Portable_Control: was &", cc, LongWord
       ;DREG    R1, ", now &",, LongWord
 ]
        EXITS


;******************************************************************************
;
; SetPwrState
;
; Entry
;   R1  = required state
;
; When current state is unknown (eg at module initialisation),
; set ControlInternal to inverse of required state before
; calling, to overide optimisations.
;
; Exit
;   R0, R1 preserved
;   R2, R3 corrupt
;
; Use R2 for bits that are changing
;
SetPwrState
        Entry   "R0,R1"
        LDR     R0, ControlInternal             ;Actual power state
 [ {TRUE}
;
; Rely on docking connector ticker in s.StateMC to spot that the
; lid is shut whilst the LCD is active. This calls Portable_Stop
; to freeze the machine.
;
 |
;
; Switch LCD off if lid is closed.
;
; This overide is not stored in ConfigExtraBitsCopy, so is not seen by callers of
; Portable_Control. If the lid switch opens, the next call of Portable_Control/SetPwrState
; will allow the LCD to turn back on.
;
        LDRB    r3, BMU_Flags
        TST     r3, #PortableBMUF_LidOpen
        BICEQ   r1, r1, #PortableControl_LCDEnable
        BICEQ   r1, r1, #PortableControl_BacklightEnable
 ]
 [ Debug
;
; report devices powering down
;
        EOR     R3, R0, R1                      ; r3 = bits that have changed
        AND     r3, r3, r0                      ; r3 = bits that are going from 1 to 0 (ie power -> off)

        TST     R3, #PortableControl_SoundEnable
        BEQ     %FT232
        DLINE   "switching audio amps OFF"
232

        TST     R3, #PortableControl_FDCEnable
        BEQ     %FT232
        DLINE   "switching Floppy power OFF"
232

        TST     R3, #PortableControl_IDEEnable
        BEQ     %FT232
        DLINE   "switching Winnie power OFF"
232

        TST     R3, #PortableControl_ParallelEnable
        BEQ     %FT232
        DLINE   "switching Parallel power OFF"
232

        TST     R3, #PortableControl_SerialEnable
        BEQ     %FT232
        DLINE   "switching Serial power OFF"
232

;
; report devices powering up
;
        EOR     R3, R0, R1                      ; r3 = bits that have changed
        AND     r3, r3, r1                      ; r3 = bits that are going from 0 to 1 (ie power -> on)

        TST     R3, #PortableControl_SoundEnable
        BEQ     %FT232
        DLINE   "switching audio amps ON"
232

        TST     R3, #PortableControl_FDCEnable
        BEQ     %FT232
        DLINE   "switching Floppy power ON"
232

        TST     R3, #PortableControl_IDEEnable
        BEQ     %FT232
        DLINE   "switching Winnie power ON"
232

        TST     R3, #PortableControl_ParallelEnable
        BEQ     %FT232
        DLINE   "switching Parallel power ON"
232

        TST     R3, #PortableControl_SerialEnable
        BEQ     %FT232
        DLINE   "switching Serial power ON"
232
 ]

        EOR     R2, R0, R1                      ; R3 = bits that are changing


 [ SwitchPower
        ADR     R2, SwitchControl_IDE
        BL      SwitchOff

        ADR     R2, SwitchControl_FDC
        BL      SwitchOff

        ADR     R2, SwitchControl_Serial
        BL      SwitchOff

        ADR     R2, SwitchControl_Sound
        BL      SwitchOff

        ADR     R2, SwitchControl_ExtPower
        BL      SwitchOff

        ADR     R2, SwitchControl_TBallSelect
        BL      SwitchOff

        ADR     R2, SwitchControl_FlashWritePower
        BL      SwitchOff

        ADR     R2, SwitchControl_LCDInverter
        BL      SwitchOff

        ADR     R2, SwitchControl_LCDLogic
        BL      SwitchOff
 ]

 [ SwitchPower
; The PWRGD line into the 665 must be high whenever units inside it are in use.
; We must also ensure it is high whenever we try to configure it!.
;
        LDR     LR, =ControlPWRGDBits
        TST     R0, LR
        TSTEQ   R1, LR
        BEQ     %FT20                        ;EQ, none of the units in the '665 need power

        ADR     R2, SwitchControl_PWRGD
        BL      ForceSwitchOn
 ]
        EOR     r3, r1, r0              ; r3 = bits that are really changing
        LDR     lr, =ControlConfigBits  ; bits that require us to go into config mode to change
        TST     r3, lr                  ; bits that are changing in config
        BEQ     %FT20

 [ ConfigCombo
        Push    "r4"
        BL      EnterConfigMode


   [ {TRUE}
;
; Standard Microsystems Corporation Application note 4-13 states that we should
; disable DMA and IRQ before placing the FDC into low power mode by ensuring
; that the last write to 3F2H register is 04H.
;
        EOR     r3, r1, r0              ; r3 = bits that are changing
        TST     r3, #PortableControl_FDCEnable
        TSTNE   r0, #PortableControl_FDCEnable

        LDRNE   LR, =FDCDOR             ; if floppy power is changing from 1 to 0
        MOVNE   R3, #&04                ; write &04 to Digital Output register
        STRNEB  R3, [LR]                ; to disable DMA and IRQ
   ]

        ADR     R2, UnitControl_FDC             ;Configure for power state
        BL      ConfigureUnit                   ;
                                                ;
        ADR     R2, UnitControl_FDCrouting      ; and signal routing
        BL      ConfigureUnit                   ;

        ADR     R2, UnitControl_IDE
        BL      ConfigureUnit

        ADR     R2, UnitControl_Serial
        BL      ConfigureUnit

        ADR     R2, UnitControl_Parallel
        BL      ConfigureUnit

  [ TurnOffOscillator
        ADR     R2, UnitControl_Oscil
        BL      ConfigureUnit
  ]

        BL      ExitConfigMode
        Pull    "r4"
 ]
20
 [ SwitchPower
;If everything is dormant, we may be able to lower PWRGD.
        ADR     R2, SwitchControl_PWRGD
        BL      SwitchOff
 ]

 [ SwitchPower
        ADR     R2, SwitchControl_IDE
        BL      SwitchOn

        ADR     R2, SwitchControl_FDC
        BL      SwitchOn

        ADR     R2, SwitchControl_Serial
        BL      SwitchOn

        ADR     R2, SwitchControl_Sound
        BL      SwitchOn

        ADR     R2, SwitchControl_TBallSelect
        BL      SwitchOn

        ADR     R2, SwitchControl_ExtPower
        BL      SwitchOn

        ADR     R2, SwitchControl_FlashWritePower
        BL      SwitchOn

        ADR     R2, SwitchControl_LCDLogic      ; Enabling LCD
        BL      SwitchOn                        ;   Turn on En_Vccl*
                                                ;   Wait 20ms -0/+100ms
        ADR     R2, SwitchControl_LCDInverter   ;   Turn on En_Vcct*
        BL      SwitchOn                        ;
 ]
        STR     R1, ControlInternal             ;Actual power state
        EXITS


 [ ConfigCombo
;
; Enter 'Configure' mode of the '665.
;
; All registers preserved
;
EnterConfigMode Entry "r0,r1"
       ;DLINE   "EnterConfigMode"
        ADR     lr, ConfigPre665
ProcessConfigTable
10
        LDMIA   lr!, {r0,r1}
        TEQ     r0, #0
        STRNEB  r1, [r0]
        BNE     %BT10
        EXITS


;
; Exit 'Configure' mode of the '665.
;
; All registers preserved
;
ExitConfigMode Entry "r0,r1"
       ;DLINE   "ExitConfigMode"
        ADR     lr, ConfigPost665
        B       ProcessConfigTable


;
; Enable/disable a subunit of the '665
;
; Entry
;   R0  current power state mask
;   R1  required power state mask
;   R2  ->unit control record (eg UnitControl_FDC, UnitControl_Serial etc)
;
; Exit
;   R0, R1 preserved
;   R2  corrupt
;
ConfigureUnit
        Entry   "R3-R5"
        LDMIA   R2!, {r5}
        LDMIA   R2!, {r3,r4}            ; load addr1, data1
        STRB    r4, [r3]                ; set up CRI
        LDMIA   R2, {r3,r4}             ; load addr2, data2
        LDRB    R2, [r3]
        TST     r1, r5
        BICEQ   R2, R2, r4              ; disable
        ORRNE   R2, R2, r4              ; or enable
        EOR     R2, R2, r4, LSR #8      ; allow for +ve/-ve logic
        STRB    R2, [r3]
        EXITS


ConfigPre665
        &       CSR665, &55
        &       CSR665, &55
        &       0, 0

ConfigPost665
        &       CSR665, &AA
        &       0, 0


;
; Unit control records
; ====================

UnitControl_FDC
        &       PortableControl_FDCEnable
        &       CSR665, &00     ;register &00
        &       CRD665, &0018   ;bit 3 is FDC POWER,  hi supplies power
                                ;bit 4 is FDC ENABLE, hi enables FDC

UnitControl_FDCrouting
        &       PortableControl_FDCEnable
        &       CSR665, &04     ;register &04
        &       CRD665, &0008   ;PPFD2 mode

UnitControl_IDE
        &       PortableControl_IDEEnable
        &       CSR665, &00     ;register &00
        &       CRD665, &0001   ;bit 1 is IDE ENABLE, hi enables IDE

UnitControl_Serial
        &       PortableControl_SerialEnable
        &       CSR665, &02     ;register &02
        &       CRD665, &00C0   ;bit 2 is UART1 Enable, hi enables port
                                ;bit 3 is UART1 Power down, hi supplies power

;
; used both as a normal parallel port and a floppy port!
;
UnitControl_Parallel
        &       PortableControl_ParallelEnable + PortableControl_FDCEnable
        &       CSR665, &01     ;register &01
        &       CRD665, &0007   ;bits 1 & 0 are 0 0 disabled
                                ;               1 1 enabled at address &278 (default)
                                ;bit 2 is Parallel Port Power, hi supplies power

  [ TurnOffOscillator
;
; We choose to explicitly enable the Osc and Baud rate generator (BRG) when
; required, rather than configure them to enable when the PWRGD input is high.
UnitControl_Oscil
        &       PortableControl_SerialEnable + PortableControl_FDCEnable
        &       CSR665, &00     ;register &00
        &       CRD665, &6060   ;bits 6 & 5 are OSC 0 0 Osc ON, BRG enabled
                                ;                   1 1 Osc OFF, BRG disabled
  ]
 ]



 [ SwitchPower
;
; R2  -> power control record (eg SwitchControl_FDC, SwitchControl_Serial etc)
;
ForceSwitchOn
        Entry   "R3-R7"
        LDMIA   R2!, {R3, R4, R5}       ;Control mask, PortID

        ADR     R6, PortSoftCopies      ;array of bytes
        LDRB    R7, [R6, R4]            ;load PortSoftCopy[PortID]
        ORR     R7, R7, R5
        EOR     R7, R7, R5, LSR #8
        STRB    R7, [R6, R4]            ;save PortSoftCopy[PortID]

        ADR     R6, PortList            ;array of words
        LDR     R6, [R6, R4,LSL # 2]    ;PortList[PortID]
        STRB    R7, [R6]

        EXITS


;******************************************************************************
;
; Apply power
;
; R0  current power state mask
; R1  required power state mask
; R2  -> power control record (eg SwitchControl_FDC, SwitchControl_Serial etc)
;
SwitchOn
        Entry   "R3-R7"
        LDMIA   R2!, {R3, R4, R5}       ;Control mask, PortID

        TST     R1, R3
        EXITS   EQ                      ;EQ, powered down, so nothing to do

        ADR     R6, PortSoftCopies      ;array of bytes
        LDRB    R7, [R6, R4]            ;load PortSoftCopy[PortID]
        ORR     R7, R7, R5
        EOR     R7, R7, R5, LSR #8
        STRB    R7, [R6, R4]            ;save PortSoftCopy[PortID]

        ADR     R6, PortList            ;array of words
        LDR     R6, [R6, R4,LSL # 2]    ;PortList[PortID]
        STRB    R7, [R6]

        TST     R0, R3
        EXITS   NE                      ;NE, was already powered so no surge worries

;
; Having turned power on, delay 20mS to reduce instanteous current demands,
; also meets LCD power up timing.
;
        LDR     R0, =(2*1000*20)        ;20mS in half microseconds
        BL      DoMicroDelay

        EXITS


;******************************************************************************
;
; Remove power
;
; R0  current power state mask
; R1  required power state mask
; R2  -> power control record (eg SwitchControl_FDC, SwitchControl_Serial etc)
;
SwitchOff
        Entry   "R3-R7"
        LDMIA   R2!, {R3, R4, R5}       ;Control mask, PortID

        TST     R1, R3
        EXITS   NE                      ;NE, powered up, so nothing to do

        ADR     R6, PortSoftCopies      ;array of bytes
        LDRB    R7, [R6, R4]            ;load PortSoftCopy[PortID]
        BIC     R7, R7, R5
        EOR     R7, R7, R5, LSR #8
        STRB    R7, [R6, R4]            ;save PortSoftCopy[PortID]

        ADR     R6, PortList            ;array of words
        LDR     R6, [R6, R4,LSL # 2]    ;PortList[PortID]
        STRB    R7, [R6]

        EXITS


PCMCIA_A        * 0
PCMCIA_B        * 1
MORRIS_C        * 2
MORRIS_AtoD     * 3




PortList
        &       HWLatchPA
        &       HWLatchPB
        &       HWLatchMC
        &       HWLatchMA


;
; Power control records
; =====================

;
; Most signal lines are active low, but the inverters in the Berlin ASIC
; means we treat them as active high.
;

SwitchControl_PWRGD                             ;Io_power
        &       ControlPWRGDBits                ;
        &       PCMCIA_A, &0001                 ;bit0

SwitchControl_FDC                               ;Fdd_power
        &       PortableControl_FDCEnable       ;
        &       PCMCIA_A, &0010                 ;bit4

SwitchControl_IDE                               ;Hdd_power and Hd_rst
        &       PortableControl_IDEEnable       ;
        &       PCMCIA_A, &000C                 ;bit2 & bit3

SwitchControl_Serial                            ;Ser_power
        &       PortableControl_SerialEnable    ;
        &       PCMCIA_A, &0002                 ;bit1

SwitchControl_Sound
        &       PortableControl_SoundEnable
        &       MORRIS_AtoD, &0010              ;bit4

SwitchControl_ExtPower
        &       PortableControl_ExtPowerEnable
        &       PCMCIA_B, &0004                 ;bit2

SwitchControl_TBallSelect
        &       PortableControl_ExtMouseEnable
        &       PCMCIA_B, &0008                 ;bit3

SwitchControl_FlashWritePower
        &       PortableControl_PCMCIAEnable
        &       PCMCIA_B, &0010                 ;bit4

SwitchControl_LCDInverter
        &       PortableControl_BacklightEnable
        &       MORRIS_C, &0101                 ;bit0

SwitchControl_LCDLogic
        &       PortableControl_LCDEnable
        &       MORRIS_C, &0202                 ;bit1
 ]


;******************************************************************************
;
;       DoMicroDelay - Delay for >= R0/2 microseconds
;
; in:   R0 = time delay in 1/2 microsecond units
;       On ARM600, we may or may not be in a 32-bit mode
;
; out:  R0 corrupted
;
DoMicroDelay Entry "R1,R2"
        MOV     R2, #IOC
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R1, [R2, #Timer0CL]     ; R1 := low output latch
10
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R14, [R2, #Timer0CL]    ; R14 := low output latch
        TEQ     R14, R1                 ; unchanged ?
        BEQ     %BT10                   ; then loop
        MOV     R1, R14                 ; copy anyway
        SUBS    R0, R0, #1              ; decrement count
        BNE     %BT10                   ; loop if not finished

        EXITS

;******************************************************************************

        LTORG

        END
@


4.3
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.66. Tagged as 'Portable-0_66'
@
text
@d285 1
a285 1
 [ 1 = 1
d422 1
a422 1
   [ 1 = 1
@


4.2
log
@Version Spin_merge taken
@
text
@d41 1
a41 1
        ENTRY   "R0-R2"
d69 1
a69 1
InitSWIPortableControl ENTRY "r0-r2"
d135 1
a135 1
;            Bit          16..12...8...4...0         
d152 1
a152 1
PowerSaveBits       * 2_10001111100000001000       ;The bits we attempt to powerdown 
d166 2
a167 2
;                       
SWIControl      ENTRY "r2,r3"
d188 1
a188 1
; 
d199 1
a199 1
;  
d205 1
a205 1
        TST     r1, #PortableControl_IntTBallEnable     ;On current hardware, ExtMouseEnable is 
d283 1
a283 1
        ENTRY   "R0,R1"
d289 1
a289 1
; to freeze the machine. 
d297 1
a297 1
; will allow the LCD to turn back on. 
d505 1
a505 1
EnterConfigMode ENTRY "r0,r1"
d522 1
a522 1
ExitConfigMode ENTRY "r0,r1"
d541 1
a541 1
        ENTRY   "R3-R5"
d604 1
a604 1
; required, rather than configure them to enable when the PWRGD input is high. 
d620 1
a620 1
        ENTRY   "R3-R7"
d645 1
a645 1
        ENTRY   "R3-R7"
d683 1
a683 1
        ENTRY   "R3-R7"
d777 1
a777 1
DoMicroDelay ENTRY "R1,R2"
@


4.1
log
@Initial revision
@
text
@d71 4
a74 3
        MVN     R0, R1                          ; everything on at start up. But to be on the
        STR     R1, ConfigExtraBitsCopy         ; safe side, force the hardware to that state
        BL      SetPwrState                     ; anyway. NB no power-up messages sent.
d76 1
a76 1
        MOV     r0, #0                          ;Now try turning as much off as possible,
d79 5
d128 4
a131 1
;       17..31  Reserved: these bits must not be modified, nor assumed to
d135 32
a166 25
;            Bit       16..12...8...4...0         
ControlValidBits    * 2_11110100100001110
                     ;2_10100011111111111

ControlServiceBits  * 2_01110100000001000         ; bits that require service call when changing
                     ;2_00100000000001001

ControlPWRGDBits    * 2_01110000000001000       ;Bits that require PWRGD pin of '665 held high
ControlConfigBits   * 2_01110000000001000         ; bits that require us to enter config mode in 710/711
ControlOscilBits    * 2_00100000000001000         ; bits that control the oscillator
ControlExtraBits    * 2_11110100100001110

InitialPowerState   * 2_01111100100001010       ;Everything-on state
PowerSaveBits       * 2_01111100000001000       ;The bits we attempt to powerdown 

;                        IFPPS  B    S L
;                        DDaCo  a    e C
;                        ECrMu  c    r D
;                          aCn  k    i
;                          lId  l    a
;                          lA   i    l
;                          e    g
;                          l    h
;                               t
;
a173 1

d181 3
d185 40
a269 1
;   R0  = current state
d272 3
a274 2
; If current state is unknown (eg at module initialisation),
; set to inverse of required state to overide optimisations.
d282 22
a303 1
SetPwrState ENTRY
a370 1

a371 1
  [ DisableHDC
a373 1
  ]
a374 1
  [ DisableFDC
a376 1
  ]
a377 1
  [ ConfigSerial
a379 1
  ]
a380 1
  [ DisableSound
d383 15
a397 1
  ]
d417 1
a417 1

d421 2
a422 2
 [ DisableFDC
 [ 1 = 1
a432 2
        LDRNEB  R3, [LR]                ;
        STRNE   R3, SaveFDCDOR          ;
d435 1
a435 2
 ]
 ]
d437 5
a441 4
 [ DisableFDC
        ADR     R2, UnitControl_FDC
        BL      ConfigureUnit
 ]
a442 1
 [ DisableHDC
a444 1
 ]
a445 1
 [ ConfigSerial
a447 1
 ]
a448 1
 [ ConfigParallel
a450 1
 ]
d452 1
a452 1
 [ TurnOffOscillator
d455 1
a455 1
 ]
d459 1
a459 1

d462 1
a462 2
;>>>may be able to lower PWRGD????

a466 32

; [ BMU
;        LDRB    lr, BMU_Flags
;        TST     lr, #PortableBMUF_LidOpen
;        MOV     r3, #&0F
;        AND     lr, r3, r1              ; bits 0..3
;        BICEQ   lr, lr, #2              ; knock out LCD enable bit if lid shut
;        STRB    lr, [r2, #LC_LICR_lo]
;        AND     lr, r3, r1, LSR #4      ; bits 4..7
;        STRB    lr, [r2, #LC_LICR_mid]
;        AND     lr, r3, r1, LSR #8      ; bits 8..11
;        BICEQ   lr, lr, #1              ; knock out backlight bit if lid shut
;        STRB    lr, [r2, #LC_LICR_hi]
; |
;        MOV     r3, #&0F
;        AND     lr, r3, r1              ; bits 0..3
;        STRB    lr, [r2, #LC_LICR_lo]
;        AND     lr, r3, r1, LSR #4      ; bits 4..7
;        STRB    lr, [r2, #LC_LICR_mid]
;        AND     lr, r3, r1, LSR #8      ; bits 8..11
;        STRB    lr, [r2, #LC_LICR_hi]
; ]
;
;        AND     lr, r3, r1, LSR #16
;        STRB    lr, PalState
;
;        EOR     lr, r0, r1
;        TST     lr, #1:SHL:16
;        BLNE    UpdateLCDPalette



a467 1
  [ DisableHDC
a469 1
  ]
a470 1
  [ DisableFDC
a472 1
  ]
a473 1
  [ ConfigSerial
a475 1
  ]
a476 1
  [ DisableSound
d479 15
a493 1
  ]
d495 1
a495 1

d499 1
a554 2


a563 8
;
ConfigParallelFDC665
;       &       CSR665, &04     ;register &04
;       &       CRD665, &080C   ;PPFD1 mode

        &       CSR665, &04     ;register &04
        &       CRD665, &040C   ;PPFD2 mode

d575 5
d601 1
d610 2
a611 1

d635 2
d663 7
a669 1
    ;>>>delay
d673 2
d704 1
a704 1
MORRIS_P        * 2
d728 1
a728 1
        &       PCMCIA_A, &0001                 ;bit0 active low
d732 1
a732 1
        &       PCMCIA_A, &0010                 ;bit4 active low
d734 1
a734 1
SwitchControl_IDE                               ;Hdd_power
d736 1
a736 1
        &       PCMCIA_A, &0004                 ;bit2 active low
d740 1
a740 1
        &       PCMCIA_A, &0002                 ;bit1 active low
d744 21
a764 1
        &       MORRIS_AtoD, &0101              ;bit0 active low
d767 25
d793 2
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d71 3
a73 4
        STR     R1, ConfigExtraBitsCopy         ; everything on at start up. But to be on the
        MVN     R0, R1                          ; safe side, force the hardware to that state
        STR     R0, ControlInternal             ; anyway.
        BL      SetPwrState                     ; NB no power-up messages sent.
d75 1
a75 1
        MOV     r0, #0                          ;Now try turning off as much off as possible,
a77 5

        MOV     r0, #PortableControl_IntTBallEnable     ;Switch from mouse to trackerball
        MOV     r1, #:NOT:(PortableControl_IntTBallEnable :OR: PortableControl_ExtMouseEnable)
        BL      SWIControl

d122 1
a122 4
;  +    17      Set => trackerball (internal) enabled } see comments in code
;  +    18      Set => mouse (external) enabled       }
;  +    19      Set => external keyboard and external mouse power enabled
;       19..31  Reserved: these bits must not be modified, nor assumed to
d126 25
a150 32
;            Bit          16..12...8...4...0         
ControlValidBits    * 2_11111110100100001110
                     ;2_00010100011111111111

ControlServiceBits  * 2_11101110100000001000         ; bits that require service call when changing
                     ;2_00000100000000001001

ControlPWRGDBits    * 2_00001110000000001000       ;Bits that require PWRGD pin of '665 held high
ControlConfigBits   * 2_00001110000000001000         ; bits that require us to enter config mode in 710/711
ControlOscilBits    * 2_00000100000000001000         ; bits that control the oscillator
ControlExtraBits    * 2_11111110100100001110

;>>>suggest renaming InitialPowerState as KernelPowerState
;>>>have mask of bits to power down (FDC, IDE etc)
;>>>and mask of bits to power up (trackerball, LCD)
;
InitialPowerState   * 2_11001111100000001000       ;Everything-on state as setup by Kernel
PowerSaveBits       * 2_10001111100000001000       ;The bits we attempt to powerdown 

Shutdown1Bits       * 2_00001111100000001000
Shutdown2Bits       * 2_11101111100100001010

;                       EEI IFPPS  B    S L
;                       xxn DDaCo  a    e C
;                       ttt ECrMu  c    r D
;                             aCn  k    i
;                       PMT   lId  l    a
;                       ooB   lA   i    l
;                       wua   e    g
;                       esl   l    h
;                       rel        t
;                       
d158 1
a165 3
;
; R0 = current state, R1 = required state
;
a166 40
;
; Current hardware provides two control lines 'ExternalPower' and 'TrackballNotMouse' to control
; power too and select between an external keyboard, external mouse or internal trackerball.
; 
; ExternalPower controls power to both external PS2 ports. The external keyboard port is
; connected directly to the KBD port in Morris and is active whenever ExternalPower is active.
;
; TrackballNotMouse controls the routing of data to Morris' MSE port. 'Trackball' applies power
; to the internal trackerball and routes its data to Morris' MSE port. 'Mouse' routes data from
; the external mouse socket to Morris' MSE port if ExternalPower is active. Selecting 'Mouse'
; with ExternalPower 'off' leaves both ports inactive and in a low power state.
;
; Bit PortableControl_ExtPowerEnable directly controls 'ExternalPower'
; Bit PortableControl_IntTBallEnable directly controls 'TrackballNotMouse'
;  
; PortableControl_ExtMouseEnable := NOT(PortableControl_IntTBallEnable) AND PortableControl_ExtPowerEnable
;
; We manufacture the PortableControl_ExtMouseEnable bit and send power down/up messages for it
; to allow the PS2Driver to correctly kill/reset Morris' MSE port.
;
        TST     r1, #PortableControl_IntTBallEnable     ;On current hardware, ExtMouseEnable is 
        BICNE   r1, r1, #PortableControl_ExtMouseEnable ; inverse of IntTBallEnable
        ORREQ   r1, r1, #PortableControl_ExtMouseEnable ;
        TST     r1, #PortableControl_ExtPowerEnable     ; unless power is off of course
        BICEQ   r1, r1, #PortableControl_ExtMouseEnable ; (in which case mouse is off)

;
; Floppy and printer are mutually exclusive (both share the same connector), so prevent
; selection of both.
;
        TST     r1, #PortableControl_FDCEnable
        BICNE   r1, r1, #PortableControl_ParallelEnable

;
; The code to switch the LCD off if the machine lid is closed is in SetPwrState.
;

;
; R0 = current state, R1 = required state
;
d212 1
d215 2
a216 3
; When current state is unknown (eg at module initialisation),
; set ControlInternal to inverse of required state before
; calling, to overide optimisations.
d224 1
a224 22
SetPwrState
        ENTRY   "R0,R1"
        LDR     R0, ControlInternal             ;Actual power state
 [ 1 = 1
;
; Rely on docking connector ticker in s.StateMC to spot that the
; lid is shut whilst the LCD is active. This calls Portable_Stop
; to freeze the machine. 
;
 |
;
; Switch LCD off if lid is closed.
;
; This overide is not stored in ConfigExtraBitsCopy, so is not seen by callers of
; Portable_Control. If the lid switch opens, the next call of Portable_Control/SetPwrState
; will allow the LCD to turn back on. 
;
        LDRB    r3, BMU_Flags
        TST     r3, #PortableBMUF_LidOpen
        BICEQ   r1, r1, #PortableControl_LCDEnable
        BICEQ   r1, r1, #PortableControl_BacklightEnable
 ]
d292 1
d294 1
d297 1
d299 1
d302 1
d304 1
d307 1
d309 1
d312 1
a312 15

        ADR     R2, SwitchControl_ExtPower
        BL      SwitchOff

        ADR     R2, SwitchControl_TBallSelect
        BL      SwitchOff

        ADR     R2, SwitchControl_FlashWritePower
        BL      SwitchOff

        ADR     R2, SwitchControl_LCDInverter
        BL      SwitchOff

        ADR     R2, SwitchControl_LCDLogic
        BL      SwitchOff
d332 1
a332 1
 [ ConfigCombo
d336 2
a337 2

   [ 1 = 1
d348 2
d352 2
a353 1
   ]
d355 4
a358 5
        ADR     R2, UnitControl_FDC             ;Configure for power state
        BL      ConfigureUnit                   ;
                                                ;
        ADR     R2, UnitControl_FDCrouting      ; and signal routing
        BL      ConfigureUnit                   ;
d360 1
d363 1
d365 1
d368 1
d370 1
d373 1
d375 1
a375 1
  [ TurnOffOscillator
d378 1
a378 1
  ]
d382 1
a382 1
 ]
d385 2
a386 1
;If everything is dormant, we may be able to lower PWRGD.
d391 32
d424 1
d427 1
d429 1
d432 1
d434 1
d437 1
d439 1
d442 2
a444 16
        ADR     R2, SwitchControl_TBallSelect
        BL      SwitchOn

        ADR     R2, SwitchControl_ExtPower
        BL      SwitchOn

        ADR     R2, SwitchControl_FlashWritePower
        BL      SwitchOn

        ADR     R2, SwitchControl_LCDLogic      ; Enabling LCD
        BL      SwitchOn                        ;   Turn on En_Vccl*
                                                ;   Wait 20ms -0/+100ms
        ADR     R2, SwitchControl_LCDInverter   ;   Turn on En_Vcct*
        BL      SwitchOn                        ;
 ]
        STR     R1, ControlInternal             ;Actual power state
a447 1
 [ ConfigCombo
d503 2
d514 8
a532 5
UnitControl_FDCrouting
        &       PortableControl_FDCEnable
        &       CSR665, &04     ;register &04
        &       CRD665, &0008   ;PPFD2 mode

a553 1
  [ TurnOffOscillator
d562 1
a562 2
  ]
 ]
a585 2

;******************************************************************************
d612 1
a612 7

;
; Having turned power on, delay 20mS to reduce instanteous current demands,
; also meets LCD power up timing.
;
        LDR     R0, =(2*1000*20)        ;20mS in half microseconds
        BL      DoMicroDelay
a615 2

;******************************************************************************
d645 1
a645 1
MORRIS_C        * 2
d669 1
a669 1
        &       PCMCIA_A, &0001                 ;bit0
d673 1
a673 1
        &       PCMCIA_A, &0010                 ;bit4
d675 1
a675 1
SwitchControl_IDE                               ;Hdd_power and Hd_rst
d677 1
a677 1
        &       PCMCIA_A, &000C                 ;bit2 & bit3
d681 1
a681 1
        &       PCMCIA_A, &0002                 ;bit1
d685 1
a685 21
        &       MORRIS_AtoD, &0010              ;bit4

SwitchControl_ExtPower
        &       PortableControl_ExtPowerEnable
        &       PCMCIA_B, &0004                 ;bit2

SwitchControl_TBallSelect
        &       PortableControl_ExtMouseEnable
        &       PCMCIA_B, &0008                 ;bit3

SwitchControl_FlashWritePower
        &       PortableControl_PCMCIAEnable
        &       PCMCIA_B, &0010                 ;bit4

SwitchControl_LCDInverter
        &       PortableControl_BacklightEnable
        &       MORRIS_C, &0101                 ;bit0

SwitchControl_LCDLogic
        &       PortableControl_LCDEnable
        &       MORRIS_C, &0202                 ;bit1
a687 25

;******************************************************************************
;
;       DoMicroDelay - Delay for >= R0/2 microseconds
;
; in:   R0 = time delay in 1/2 microsecond units
;       On ARM600, we may or may not be in a 32-bit mode
;
; out:  R0 corrupted
;
DoMicroDelay ENTRY "R1,R2"
        MOV     R2, #IOC
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R1, [R2, #Timer0CL]     ; R1 := low output latch
10
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R14, [R2, #Timer0CL]    ; R14 := low output latch
        TEQ     R14, R1                 ; unchanged ?
        BEQ     %BT10                   ; then loop
        MOV     R1, R14                 ; copy anyway
        SUBS    R0, R0, #1              ; decrement count
        BNE     %BT10                   ; loop if not finished

        EXITS

a688 2

        LTORG
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d71 3
a73 4
        STR     R1, ConfigExtraBitsCopy         ; everything on at start up. But to be on the
        MVN     R0, R1                          ; safe side, force the hardware to that state
        STR     R0, ControlInternal             ; anyway.
        BL      SetPwrState                     ; NB no power-up messages sent.
d75 1
a75 1
        MOV     r0, #0                          ;Now try turning off as much off as possible,
a77 5

        MOV     r0, #PortableControl_IntTBallEnable     ;Switch from mouse to trackerball
        MOV     r1, #:NOT:(PortableControl_IntTBallEnable :OR: PortableControl_ExtMouseEnable)
        BL      SWIControl

d122 1
a122 4
;  +    17      Set => trackerball (internal) enabled } see comments in code
;  +    18      Set => mouse (external) enabled       }
;  +    19      Set => external keyboard and external mouse power enabled
;       19..31  Reserved: these bits must not be modified, nor assumed to
d126 25
a150 32
;            Bit          16..12...8...4...0         
ControlValidBits    * 2_11111110100100001110
                     ;2_00010100011111111111

ControlServiceBits  * 2_11101110100000001000         ; bits that require service call when changing
                     ;2_00000100000000001001

ControlPWRGDBits    * 2_00001110000000001000       ;Bits that require PWRGD pin of '665 held high
ControlConfigBits   * 2_00001110000000001000         ; bits that require us to enter config mode in 710/711
ControlOscilBits    * 2_00000100000000001000         ; bits that control the oscillator
ControlExtraBits    * 2_11111110100100001110

;>>>suggest renaming InitialPowerState as KernelPowerState
;>>>have mask of bits to power down (FDC, IDE etc)
;>>>and mask of bits to power up (trackerball, LCD)
;
InitialPowerState   * 2_11001111100000001000       ;Everything-on state as setup by Kernel
PowerSaveBits       * 2_10001111100000001000       ;The bits we attempt to powerdown 

Shutdown1Bits       * 2_00001111100000001000
Shutdown2Bits       * 2_11101111100100001010

;                       EEI IFPPS  B    S L
;                       xxn DDaCo  a    e C
;                       ttt ECrMu  c    r D
;                             aCn  k    i
;                       PMT   lId  l    a
;                       ooB   lA   i    l
;                       wua   e    g
;                       esl   l    h
;                       rel        t
;                       
d158 1
a165 3
;
; R0 = current state, R1 = required state
;
a166 40
;
; Current hardware provides two control lines 'ExternalPower' and 'TrackballNotMouse' to control
; power too and select between an external keyboard, external mouse or internal trackerball.
; 
; ExternalPower controls power to both external PS2 ports. The external keyboard port is
; connected directly to the KBD port in Morris and is active whenever ExternalPower is active.
;
; TrackballNotMouse controls the routing of data to Morris' MSE port. 'Trackball' applies power
; to the internal trackerball and routes its data to Morris' MSE port. 'Mouse' routes data from
; the external mouse socket to Morris' MSE port if ExternalPower is active. Selecting 'Mouse'
; with ExternalPower 'off' leaves both ports inactive and in a low power state.
;
; Bit PortableControl_ExtPowerEnable directly controls 'ExternalPower'
; Bit PortableControl_IntTBallEnable directly controls 'TrackballNotMouse'
;  
; PortableControl_ExtMouseEnable := NOT(PortableControl_IntTBallEnable) AND PortableControl_ExtPowerEnable
;
; We manufacture the PortableControl_ExtMouseEnable bit and send power down/up messages for it
; to allow the PS2Driver to correctly kill/reset Morris' MSE port.
;
        TST     r1, #PortableControl_IntTBallEnable     ;On current hardware, ExtMouseEnable is 
        BICNE   r1, r1, #PortableControl_ExtMouseEnable ; inverse of IntTBallEnable
        ORREQ   r1, r1, #PortableControl_ExtMouseEnable ;
        TST     r1, #PortableControl_ExtPowerEnable     ; unless power is off of course
        BICEQ   r1, r1, #PortableControl_ExtMouseEnable ; (in which case mouse is off)

;
; Floppy and printer are mutually exclusive (both share the same connector), so prevent
; selection of both.
;
        TST     r1, #PortableControl_FDCEnable
        BICNE   r1, r1, #PortableControl_ParallelEnable

;
; The code to switch the LCD off if the machine lid is closed is in SetPwrState.
;

;
; R0 = current state, R1 = required state
;
d212 1
d215 2
a216 3
; When current state is unknown (eg at module initialisation),
; set ControlInternal to inverse of required state before
; calling, to overide optimisations.
d224 1
a224 22
SetPwrState
        ENTRY   "R0,R1"
        LDR     R0, ControlInternal             ;Actual power state
 [ 1 = 1
;
; Rely on docking connector ticker in s.StateMC to spot that the
; lid is shut whilst the LCD is active. This calls Portable_Stop
; to freeze the machine. 
;
 |
;
; Switch LCD off if lid is closed.
;
; This overide is not stored in ConfigExtraBitsCopy, so is not seen by callers of
; Portable_Control. If the lid switch opens, the next call of Portable_Control/SetPwrState
; will allow the LCD to turn back on. 
;
        LDRB    r3, BMU_Flags
        TST     r3, #PortableBMUF_LidOpen
        BICEQ   r1, r1, #PortableControl_LCDEnable
        BICEQ   r1, r1, #PortableControl_BacklightEnable
 ]
d292 1
d294 1
d297 1
d299 1
d302 1
d304 1
d307 1
d309 1
d312 1
a312 15

        ADR     R2, SwitchControl_ExtPower
        BL      SwitchOff

        ADR     R2, SwitchControl_TBallSelect
        BL      SwitchOff

        ADR     R2, SwitchControl_FlashWritePower
        BL      SwitchOff

        ADR     R2, SwitchControl_LCDInverter
        BL      SwitchOff

        ADR     R2, SwitchControl_LCDLogic
        BL      SwitchOff
d332 1
a332 1
 [ ConfigCombo
d336 2
a337 2

   [ 1 = 1
d348 2
d352 2
a353 1
   ]
d355 4
a358 5
        ADR     R2, UnitControl_FDC             ;Configure for power state
        BL      ConfigureUnit                   ;
                                                ;
        ADR     R2, UnitControl_FDCrouting      ; and signal routing
        BL      ConfigureUnit                   ;
d360 1
d363 1
d365 1
d368 1
d370 1
d373 1
d375 1
a375 1
  [ TurnOffOscillator
d378 1
a378 1
  ]
d382 1
a382 1
 ]
d385 2
a386 1
;If everything is dormant, we may be able to lower PWRGD.
d391 32
d424 1
d427 1
d429 1
d432 1
d434 1
d437 1
d439 1
d442 2
a444 16
        ADR     R2, SwitchControl_TBallSelect
        BL      SwitchOn

        ADR     R2, SwitchControl_ExtPower
        BL      SwitchOn

        ADR     R2, SwitchControl_FlashWritePower
        BL      SwitchOn

        ADR     R2, SwitchControl_LCDLogic      ; Enabling LCD
        BL      SwitchOn                        ;   Turn on En_Vccl*
                                                ;   Wait 20ms -0/+100ms
        ADR     R2, SwitchControl_LCDInverter   ;   Turn on En_Vcct*
        BL      SwitchOn                        ;
 ]
        STR     R1, ControlInternal             ;Actual power state
a447 1
 [ ConfigCombo
d503 2
d514 8
a532 5
UnitControl_FDCrouting
        &       PortableControl_FDCEnable
        &       CSR665, &04     ;register &04
        &       CRD665, &0008   ;PPFD2 mode

a553 1
  [ TurnOffOscillator
d562 1
a562 2
  ]
 ]
a585 2

;******************************************************************************
d612 1
a612 7

;
; Having turned power on, delay 20mS to reduce instanteous current demands,
; also meets LCD power up timing.
;
        LDR     R0, =(2*1000*20)        ;20mS in half microseconds
        BL      DoMicroDelay
a615 2

;******************************************************************************
d645 1
a645 1
MORRIS_C        * 2
d669 1
a669 1
        &       PCMCIA_A, &0001                 ;bit0
d673 1
a673 1
        &       PCMCIA_A, &0010                 ;bit4
d675 1
a675 1
SwitchControl_IDE                               ;Hdd_power and Hd_rst
d677 1
a677 1
        &       PCMCIA_A, &000C                 ;bit2 & bit3
d681 1
a681 1
        &       PCMCIA_A, &0002                 ;bit1
d685 1
a685 21
        &       MORRIS_AtoD, &0010              ;bit4

SwitchControl_ExtPower
        &       PortableControl_ExtPowerEnable
        &       PCMCIA_B, &0004                 ;bit2

SwitchControl_TBallSelect
        &       PortableControl_ExtMouseEnable
        &       PCMCIA_B, &0008                 ;bit3

SwitchControl_FlashWritePower
        &       PortableControl_PCMCIAEnable
        &       PCMCIA_B, &0010                 ;bit4

SwitchControl_LCDInverter
        &       PortableControl_BacklightEnable
        &       MORRIS_C, &0101                 ;bit0

SwitchControl_LCDLogic
        &       PortableControl_LCDEnable
        &       MORRIS_C, &0202                 ;bit1
a687 25

;******************************************************************************
;
;       DoMicroDelay - Delay for >= R0/2 microseconds
;
; in:   R0 = time delay in 1/2 microsecond units
;       On ARM600, we may or may not be in a 32-bit mode
;
; out:  R0 corrupted
;
DoMicroDelay ENTRY "R1,R2"
        MOV     R2, #IOC
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R1, [R2, #Timer0CL]     ; R1 := low output latch
10
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R14, [R2, #Timer0CL]    ; R14 := low output latch
        TEQ     R14, R1                 ; unchanged ?
        BEQ     %BT10                   ; then loop
        MOV     R1, R14                 ; copy anyway
        SUBS    R0, R0, #1              ; decrement count
        BNE     %BT10                   ; loop if not finished

        EXITS

a688 2

        LTORG
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d71 3
a73 4
        STR     R1, ConfigExtraBitsCopy         ; everything on at start up. But to be on the
        MVN     R0, R1                          ; safe side, force the hardware to that state
        STR     R0, ControlInternal             ; anyway.
        BL      SetPwrState                     ; NB no power-up messages sent.
d75 1
a75 1
        MOV     r0, #0                          ;Now try turning off as much off as possible,
a77 5

        MOV     r0, #PortableControl_IntTBallEnable     ;Switch from mouse to trackerball
        MOV     r1, #:NOT:(PortableControl_IntTBallEnable :OR: PortableControl_ExtMouseEnable)
        BL      SWIControl

d122 1
a122 4
;  +    17      Set => trackerball (internal) enabled } see comments in code
;  +    18      Set => mouse (external) enabled       }
;  +    19      Set => external keyboard and external mouse power enabled
;       19..31  Reserved: these bits must not be modified, nor assumed to
d126 25
a150 32
;            Bit          16..12...8...4...0         
ControlValidBits    * 2_11111110100100001110
                     ;2_00010100011111111111

ControlServiceBits  * 2_11101110100000001000         ; bits that require service call when changing
                     ;2_00000100000000001001

ControlPWRGDBits    * 2_00001110000000001000       ;Bits that require PWRGD pin of '665 held high
ControlConfigBits   * 2_00001110000000001000         ; bits that require us to enter config mode in 710/711
ControlOscilBits    * 2_00000100000000001000         ; bits that control the oscillator
ControlExtraBits    * 2_11111110100100001110

;>>>suggest renaming InitialPowerState as KernelPowerState
;>>>have mask of bits to power down (FDC, IDE etc)
;>>>and mask of bits to power up (trackerball, LCD)
;
InitialPowerState   * 2_11001111100000001000       ;Everything-on state as setup by Kernel
PowerSaveBits       * 2_10001111100000001000       ;The bits we attempt to powerdown 

Shutdown1Bits       * 2_00001111100000001000
Shutdown2Bits       * 2_11101111100100001010

;                       EEI IFPPS  B    S L
;                       xxn DDaCo  a    e C
;                       ttt ECrMu  c    r D
;                             aCn  k    i
;                       PMT   lId  l    a
;                       ooB   lA   i    l
;                       wua   e    g
;                       esl   l    h
;                       rel        t
;                       
d158 1
a165 3
;
; R0 = current state, R1 = required state
;
a166 40
;
; Current hardware provides two control lines 'ExternalPower' and 'TrackballNotMouse' to control
; power too and select between an external keyboard, external mouse or internal trackerball.
; 
; ExternalPower controls power to both external PS2 ports. The external keyboard port is
; connected directly to the KBD port in Morris and is active whenever ExternalPower is active.
;
; TrackballNotMouse controls the routing of data to Morris' MSE port. 'Trackball' applies power
; to the internal trackerball and routes its data to Morris' MSE port. 'Mouse' routes data from
; the external mouse socket to Morris' MSE port if ExternalPower is active. Selecting 'Mouse'
; with ExternalPower 'off' leaves both ports inactive and in a low power state.
;
; Bit PortableControl_ExtPowerEnable directly controls 'ExternalPower'
; Bit PortableControl_IntTBallEnable directly controls 'TrackballNotMouse'
;  
; PortableControl_ExtMouseEnable := NOT(PortableControl_IntTBallEnable) AND PortableControl_ExtPowerEnable
;
; We manufacture the PortableControl_ExtMouseEnable bit and send power down/up messages for it
; to allow the PS2Driver to correctly kill/reset Morris' MSE port.
;
        TST     r1, #PortableControl_IntTBallEnable     ;On current hardware, ExtMouseEnable is 
        BICNE   r1, r1, #PortableControl_ExtMouseEnable ; inverse of IntTBallEnable
        ORREQ   r1, r1, #PortableControl_ExtMouseEnable ;
        TST     r1, #PortableControl_ExtPowerEnable     ; unless power is off of course
        BICEQ   r1, r1, #PortableControl_ExtMouseEnable ; (in which case mouse is off)

;
; Floppy and printer are mutually exclusive (both share the same connector), so prevent
; selection of both.
;
        TST     r1, #PortableControl_FDCEnable
        BICNE   r1, r1, #PortableControl_ParallelEnable

;
; The code to switch the LCD off if the machine lid is closed is in SetPwrState.
;

;
; R0 = current state, R1 = required state
;
d212 1
d215 2
a216 3
; When current state is unknown (eg at module initialisation),
; set ControlInternal to inverse of required state before
; calling, to overide optimisations.
d224 1
a224 22
SetPwrState
        ENTRY   "R0,R1"
        LDR     R0, ControlInternal             ;Actual power state
 [ 1 = 1
;
; Rely on docking connector ticker in s.StateMC to spot that the
; lid is shut whilst the LCD is active. This calls Portable_Stop
; to freeze the machine. 
;
 |
;
; Switch LCD off if lid is closed.
;
; This overide is not stored in ConfigExtraBitsCopy, so is not seen by callers of
; Portable_Control. If the lid switch opens, the next call of Portable_Control/SetPwrState
; will allow the LCD to turn back on. 
;
        LDRB    r3, BMU_Flags
        TST     r3, #PortableBMUF_LidOpen
        BICEQ   r1, r1, #PortableControl_LCDEnable
        BICEQ   r1, r1, #PortableControl_BacklightEnable
 ]
d292 1
d294 1
d297 1
d299 1
d302 1
d304 1
d307 1
d309 1
d312 1
a312 15

        ADR     R2, SwitchControl_ExtPower
        BL      SwitchOff

        ADR     R2, SwitchControl_TBallSelect
        BL      SwitchOff

        ADR     R2, SwitchControl_FlashWritePower
        BL      SwitchOff

        ADR     R2, SwitchControl_LCDInverter
        BL      SwitchOff

        ADR     R2, SwitchControl_LCDLogic
        BL      SwitchOff
d332 1
a332 1
 [ ConfigCombo
d336 2
a337 2

   [ 1 = 1
d348 2
d352 2
a353 1
   ]
d355 4
a358 5
        ADR     R2, UnitControl_FDC             ;Configure for power state
        BL      ConfigureUnit                   ;
                                                ;
        ADR     R2, UnitControl_FDCrouting      ; and signal routing
        BL      ConfigureUnit                   ;
d360 1
d363 1
d365 1
d368 1
d370 1
d373 1
d375 1
a375 1
  [ TurnOffOscillator
d378 1
a378 1
  ]
d382 1
a382 1
 ]
d385 2
a386 1
;If everything is dormant, we may be able to lower PWRGD.
d391 32
d424 1
d427 1
d429 1
d432 1
d434 1
d437 1
d439 1
d442 2
a444 16
        ADR     R2, SwitchControl_TBallSelect
        BL      SwitchOn

        ADR     R2, SwitchControl_ExtPower
        BL      SwitchOn

        ADR     R2, SwitchControl_FlashWritePower
        BL      SwitchOn

        ADR     R2, SwitchControl_LCDLogic      ; Enabling LCD
        BL      SwitchOn                        ;   Turn on En_Vccl*
                                                ;   Wait 20ms -0/+100ms
        ADR     R2, SwitchControl_LCDInverter   ;   Turn on En_Vcct*
        BL      SwitchOn                        ;
 ]
        STR     R1, ControlInternal             ;Actual power state
a447 1
 [ ConfigCombo
d503 2
d514 8
a532 5
UnitControl_FDCrouting
        &       PortableControl_FDCEnable
        &       CSR665, &04     ;register &04
        &       CRD665, &0008   ;PPFD2 mode

a553 1
  [ TurnOffOscillator
d562 1
a562 2
  ]
 ]
a585 2

;******************************************************************************
d612 1
a612 7

;
; Having turned power on, delay 20mS to reduce instanteous current demands,
; also meets LCD power up timing.
;
        LDR     R0, =(2*1000*20)        ;20mS in half microseconds
        BL      DoMicroDelay
a615 2

;******************************************************************************
d645 1
a645 1
MORRIS_C        * 2
d669 1
a669 1
        &       PCMCIA_A, &0001                 ;bit0
d673 1
a673 1
        &       PCMCIA_A, &0010                 ;bit4
d675 1
a675 1
SwitchControl_IDE                               ;Hdd_power and Hd_rst
d677 1
a677 1
        &       PCMCIA_A, &000C                 ;bit2 & bit3
d681 1
a681 1
        &       PCMCIA_A, &0002                 ;bit1
d685 1
a685 21
        &       MORRIS_AtoD, &0010              ;bit4

SwitchControl_ExtPower
        &       PortableControl_ExtPowerEnable
        &       PCMCIA_B, &0004                 ;bit2

SwitchControl_TBallSelect
        &       PortableControl_ExtMouseEnable
        &       PCMCIA_B, &0008                 ;bit3

SwitchControl_FlashWritePower
        &       PortableControl_PCMCIAEnable
        &       PCMCIA_B, &0010                 ;bit4

SwitchControl_LCDInverter
        &       PortableControl_BacklightEnable
        &       MORRIS_C, &0101                 ;bit0

SwitchControl_LCDLogic
        &       PortableControl_LCDEnable
        &       MORRIS_C, &0202                 ;bit1
a687 25

;******************************************************************************
;
;       DoMicroDelay - Delay for >= R0/2 microseconds
;
; in:   R0 = time delay in 1/2 microsecond units
;       On ARM600, we may or may not be in a 32-bit mode
;
; out:  R0 corrupted
;
DoMicroDelay ENTRY "R1,R2"
        MOV     R2, #IOC
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R1, [R2, #Timer0CL]     ; R1 := low output latch
10
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R14, [R2, #Timer0CL]    ; R14 := low output latch
        TEQ     R14, R1                 ; unchanged ?
        BEQ     %BT10                   ; then loop
        MOV     R1, R14                 ; copy anyway
        SUBS    R0, R0, #1              ; decrement count
        BNE     %BT10                   ; loop if not finished

        EXITS

a688 2

        LTORG
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

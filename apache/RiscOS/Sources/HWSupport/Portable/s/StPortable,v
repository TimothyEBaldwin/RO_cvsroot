head	4.6;
access;
symbols
	Portable-0_70:4.6
	Portable-0_69:4.6
	Portable-0_68:4.5
	Portable-0_67:4.5
	RO_5_07:4.5
	Portable-0_66:4.5
	dellis_autobuild_BaseSW:4.4
	sbrodie_sedwards_16Mar2000:4.4
	Portable-0_65:4.4
	dcotton_autobuild_BaseSW:4.5
	nturton_Portable-0_64:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	nicke_Portable_064:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2012.03.02.23.24.03;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	lloq9wGK9ZNZImVv;

4.5
date	2001.03.16.15.59.53;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	99.11.26.10.20.04;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	98.04.28.14.53.45;	author rthornb;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.16.30.34;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.37.06;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.37.06;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.38.11;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.59.31;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.52.36;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Updated to use Hdr:Keyboard instead of Hdr:KEYV.
Made use of macro IOMDBase where appropriate.
Still doesn't assemble, and still needs 32 bitting.

Version 0.69. Tagged as 'Portable-0_69'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     Source.StPortable

;
; Module header and misc. functions
;
        AREA    |Portable$$Code|, CODE, READONLY, PIC

;******************************************************************************
;
; Module header
;
Module_BaseAddr
        DCD     0
        DCD     Init     - Module_BaseAddr
        DCD     Die      - Module_BaseAddr
        DCD     Service  - Module_BaseAddr
        DCD     Title    - Module_BaseAddr
        DCD     Help     - Module_BaseAddr
        DCD     Command  - Module_BaseAddr
        DCD     Module_SWISystemBase + PortableSWI * Module_SWIChunkSize
        DCD     SWIEntry - Module_BaseAddr
        DCD     SWINameTable - Module_BaseAddr
        DCD     0
 [ International_Help <> 0
        DCD     messagefilename - Module_BaseAddr
 |
        DCD     0
 ]

;******************************************************************************

Title   DCB     "Portable",0
Help    DCB     "Portable",9,"$Module_HelpVersion", 0
        ALIGN


Command
        DCB     "FreezeTime", 0
        ALIGN
        DCD     SleepTimeCmd - Module_BaseAddr
        DCD     &0001FF00:OR:International_Help
        DCD     SleepTimeSyn - Module_BaseAddr
        DCD     SleepTimeHlp - Module_BaseAddr
        DCD     0                  ; No more cmd's

 [ International_Help=0
SleepTimeHlp    DCB     "*FreezeTime (seconds) sets the delay before an idle machine enters freeze mode.", 13
                DCB     "If used with no parameters, it displays the current status.", 13
                DCB     "To turn off use *FreezeTime 0", 13
SleepTimeSyn    DCB     "Syntax: *FreezeTime [Time]", 0
 |
SleepTimeHlp
        DCB     "HSCSLP", 0
SleepTimeSyn
        DCB     "SSCSLP", 0
 ]
        ALIGN


SleepTimeCmd    Entry
        LDR     R12, [R12]                      ;get workspace pointer

        TEQ     R1, #0
        BEQ     SleepTimeNoParams

SleepTimeLoop
        LDRB    R1, [R0]                        ;check for end
        CMP     R1, #32                         ;and chop off leading spaces.
        ADDEQ   R0, R0, #1
        BEQ     SleepTimeLoop
        EXITS   LT                              ;exit if control-char.
        BL      DecodeParam
        BVC     SleepTimeLoop
        EXIT                                    ;return V set

SleepTimeNoParams
;;;;        BL      openmsgfile
;;;;        EXIT    VS

        LDR     R0, SleepTimerDelay
        TEQ     R0, #0
        ADREQ   R1,SleepOff
        ADRNE   R1,StrBuff
        MOVNE   R2,#StrBuffLen
        SWINE   XOS_BinaryToDecimal
        SUBNE   R2, R2, #2              ; convert to seconds (sort of)
        MOVNE   R4,R1
        MOVNE   r0, #0
        STRNEB  r0, [r4, r2]
        MOVNE   R1,R2
        ADRNE   R1,SleepTim

        SUB     sp, sp, #80

        wsaddr  R0, MsgTransBlk

        MOVVC   r2, sp
        MOVVC   r3, #80
        SWIVC   XMessageTrans_Lookup
        MOVVC   r0, r2
        SWIVC   XOS_Write0
        ADD     sp, sp, #80

        SWIVC   XOS_NewLine

        EXIT

SleepOff DCB    "SleepOff", 0
SleepTim DCB    "SleepTm", 0
                ALIGN


DecodeParam Entry "R6"
        MOV     R1, R0                          ;move strpointer to R1
        MOV     R0, #(1<<29)                    ;check  0<=R2<=2^18 (ca. 3 days)
        MOV     R2, #(1<<18)                    ;restrict to moderate positive int
        SWI     XOS_ReadUnsigned
        BVS     DecodeErr                       ;print error and exit.
        MOV     R6, R1                          ; save the updated strpointer
        MOV     R3, #100
        MUL     R0,R2,R3                        ;R0 is SleepTime in centiseconds
        BL      SWISleepTime                    ; Corrupts some registers
        MOV     R0,R6
        EXITS

DecodeErr
        Pull    "R6,LR"
        ORRS    PC, LR, #V_bit


;******************************************************************************
;
; Errors
;
        ^               ErrorBase_Portable
        AddError        BadBMUVariable,"BadBMUVar"
        AddError        BadBMUCommand,"BadBMUCmd"
        AddError        BMUBusy,"BMUBusy"
        AddError        BadBMUVersion,"BadBMUVer"
        AddError        BMUFault,"BMUFault"
        AddError        BMUVecClaim,"BMUVecClaim"
        AddError        CantFreeze,"CantFreeze"
        AddError        FreezeFailed,"FreezeFailed"

        ASSERT          @@ <= (ErrorBase_Portable + ?ErrorBase_Portable)


;******************************************************************************
;
; Resources
;
;Path            DCB     "Portable$Path",0
;DefPath         DCB     "Resources:$.Resources.Portable.",0

MessageFile
messagefilename
        DCB     "Resources:$.Resources.Portable.Messages", 0
        ALIGN


;******************************************************************************
;
; Init - Module initialisation code
;
; Exit
;   R7-R11, R13 preserved
;
Init    Entry   "R7"
;
; Check machine type
;
        MOV     r0, #2                          ;Check main hardware details
        SWI     XOS_ReadSysInfo
        EXIT    VS
                                                ;R0 bits 8..15 give I/O control chip type
        AND     r0, r0, #&0000FF00              ;  0=IOC, 1=IOMD
        TEQ     r0,     #&00000100              ;  must have IOMD
                                                ;R1 bits 0..8 give I/O combo chip type
        ANDEQ   r1, r1, #&000000FF              ;  0=absent, 1=82C710/711 or SMC'665 or similar
        TEQEQ   r1,     #&00000001              ;  must have a combo chip (exact type checked below)
 [ {TRUE}
                                                ;R2 bits 0..7 give LCD controller type
        ANDEQ   r2, r2, #&000000FF              ;  0=absent, 1=A4, 2=Stork
        TEQEQ   r2,     #&00000002              ;  must be Stork
 ]
        BNE     %FT99

        MOV     r0, #3                          ;Now check I/O combo chip details
        SWI     XOS_ReadSysInfo
        EXIT    VS
                                                ;R0 bits 20..23 give configuration type
        AND     r0, r0, #&00F00000              ;  1=82C710, 2=82C711, 3=37C665
        TEQ     r0,     #&00300000              ;  must be type 3 (for 37C665)
        BNE     %FT99
;
; Hardware OK
;
        LDR     R2, [R12]
        TEQS    R2, #0                          ;already got work space if entered
        BNE     %FT10                           ;as part of RMTidy

;private word is zero, so claim some workspace
        MOV     R0, #ModHandReason_Claim
        MOV     R3, #MemNeeded
        SWI     XOS_Module
        EXIT    VS                              ;quit if error

        STR     R2, [R12]                       ;got workspace ok, so store in private word
10
        MOV     R12, R2

 [ Debug
        InsertTMLInitialisation 0               ;my EasiStork uses podule slot 0
       ;DLINE   "Portable module initialisation"
 ]

 [ SwitchPower
        BL      InitLatchSoftCopies             ;Initialise variables and ensure hardware consistency
 ]
        BL      InitSWIPortableControl          ;Initialise variables and ensure hardware consistency

        MOV     R0, #0

        STRB    r0, PaletteVFlag                ;not yet on PaletteV
        STRB    R0, EventVFlag                  ;not yet on event vector (for hot-key detection)
        STRB    R0, KeyVFlag
        STRB    R0, SleepTimerFlag
        BL      InitMicroController             ;also clears BMUDevFlag
 [ HWPolling
        STRB    R0, CallEveryFlag
 ]

        STRB    R0, KeyRepeatFlag
        STR     R0, KeyRepeatAction
        STR     R0, KeyRepeatDelay
        STR     R0, KeyRepeatRate

;>>>do I need Path variable stuff?

; open messages file

        wsaddr  R0,MsgTransBlk
        addr    R1,MessageFile
        MOV     R2,#0                           ; no buffer supplied
        SWI     XMessageTrans_OpenFile
        EXIT    VS

        BL      CheckForCMOSReset               ;may need to reconfigure a few things
        BL      ClaimEventV                     ;capture 'hot-keys' events
        BL      ClaimPaletteV           ;>>>a kludge A4 code does this on mode change iff LCD mode
        BL      ClaimKeyV
        BL      ClaimMicroControllerEvent       ;Claims event, but DOES NOT enable interrupts
                                                ; from device. This is done by PS2Driver calling
                                                ; us via a KeyV upcall with reason code
                                                ; KeyV_PseudoIntMask. See DoKeyV_PseudoIntMask.
;
; Kernel starts in CRT mode but we switch to LCD in !Boot
;
        MOV     R0, #0
        STRB    R0, PaletteMode
        MOV     R0, #&FF
        STRB    R0, DisplayMode

;
; Read LCD contrast & brightness settings from CMOS RAM
;
        ASSERT  ContrastTableMaxIndex = 63      ;we allocate 6bits in CMOS
        MOV     R0, #ReadCMOS
        MOV     R1, #ContrastCMOS
        SWI     XOS_Byte                        ;result in R2.b
        MOVVS   R1, #default_LCDContrast
        AND     R1, R2, #2_00111111
        STRB    R1, ContrastIndex

        MOV     R0, #0                          ;Brightness and contrast written simultaneously
        STRB    R0, BrightnessValue             ; to digipot, fudge zero for brightness whilst
        BL      SendContrast                    ; setting contrast

        ASSERT  BrightnessTableMaxIndex = 7     ;we allocate 3bits in CMOS for each
        MOV     R0, #ReadCMOS
        MOV     R1, #BrightnessCMOS
        SWI     XOS_Byte                        ;result in R2.b
        MOVVS   R2, #(default_LCDBrightness1 :OR: (default_LCDBrightness2 :SHL: 3)) ;b7 and b6 clear

        AND     R1, R2, #2_11000000             ;b7 lid closure, b6 idle mode inhibit
        STRB    R1, ModeBits

        AND     R1, R2, #7                      ;extract bits 0..2 as one brightness value
        MOV     R2, R2, LSR #3                  ;
        AND     R2, R2, #7                      ;extract bits 3..5 as another brightness value

        CMP     R1, R2                          ;sort values, use highest ie start in undimmed state
        EORLT   R1, R1, R2                      ; R1:=a EOR b
        EORLT   R2, R1, R2                      ; R2:=a EOR b EOR b ie R2:=a
        EORLT   R1, R1, R2                      ; R1:=a EOR b EOR a ie R1:=b
        STRB    R2, BrightnessIndex2            ;store lowest value as 'other' value
        BL      SetBrightness_WithLock          ;In R1=value to set (highest value)

;
; Read Freeze time from CMOS RAM
;
        ASSERT  FreezeTimesMaxIndex = 7
        MOV     R0, #ReadCMOS
        MOV     R1, #TimeCMOS
        SWI     XOS_Byte                        ;result in R2.b
        MOVVC   R2, R2, LSR #3                  ;
        ANDVC   R2, R2, #7                      ;extract bits 3..5 freeze time
        MOVVS   R2, #default_FreezeTime

        ADRL    R1, FreezeTimes
        LDR     R2, [R1, R2,LSL #2]             ;multiply index by 4 - table of words
        STR     R2, SleepTimerDelay

 [ HWPolling
        BL      ClaimCallEvery
 ]
;
; We currently have no software support for 'machine wake-up by alarm', other than to allow
; external software to program it. We take steps to silence any already triggered alarm to
; ensure that the machine can shutdown/freeze.
;
        BL      KillRTCAlarm                    ;We may have been switched on by the alarm
        EXITS
;
;Wrong hardware for Portable module
;
99
        ADR     r0, ErrorBlock_BadHard
        MOV     r1, #0                          ;only use global message file
        MOV     r2, #0                          ;use MessageTrans buffer
        MOV     r3, #0                          ;buffer size (irrelevant)
        MOV     r4, #0                          ;don't substitute anything
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

        MakeErrorBlock  BadHard
        MakeErrorBlock  ModuleBadSWI
        MakeErrorBlock  CantFreeze
        MakeErrorBlock  FreezeFailed

        LTORG

;******************************************************************************
;
; Finalisation code - Called before killing the module
;
; Entry
;   R10 = fatality indication: 0 is non-fatal, 1 is fatal
;   R11 = instantiation number
;   R12 = pointer to private word
;
; Exit
;   R7-R11, R13 preserved
;
Die     Entry
        LDR     R12, [R12]                      ;get workspace pointer

        BL      CancelSleepTimer

;
; Ensure all hardware is powered up, ie leave machine in usable state.
;
        LDR     R0, = InitialPowerState         ;Put the machine back as we found it
        MOV     R1, #0                          ; ie with everything powered up
        BL      SWIControl                      ; (sends Power-Up message around)

        BL      ReleaseEventV
        BL      ReleasePaletteV
        BL      ReleaseKeyV

;>>>DO we need to inhibit MicroController key/battery reports
;>>>DO we need to mask of its IRQ's???
        BL      ReleaseMicroControllerEvent
 [ HWPolling
        BL      ReleaseCallEvery
 ]

; close message file

        wsaddr  R0,MsgTransBlk
        SWI     XMessageTrans_CloseFile

        CLRV
;
; Brightness and Contrast is left 'as is'.
;
        EXIT


;******************************************************************************
;
; Service call handler
;
; Entry
;   R1  = service number
;   R12 = pointer to private word
;
; Exit
;    R1 = 0 => service claimed
;    All other registers preserved unless returning values
;
Service ROUT
        TEQ     r1, #Service_Reset
    ;    TEQNE   r1, #Service_PostInit
    ;>>>TEQNE   r1, #Service_PreReset
    ;>>>TEQNE   r1, #Service_ModeChanging
    ;>>>TEQNE   r1, #Service_ModeExtension
    ;>>>TEQNE   r1, #Service_ModeTranslation
    ;>>>TEQNE   r1, #Service_ModeChange
    ;>>>TEQNE   r1, #Service_MonitorLeadTranslation
; no need to handle Service_MessageFileClosed
    ;>>>[       standalonemessages
    ;>>>TEQNE   R1,#Service_ResourceFSStarting
    ;>>>]
        MOVNES  PC, LR

        LDR     wp, [r12]

    ;>>>TEQ     r1, #Service_PreReset
    ;>>>BEQ     Svc_PreReset

    ;    TEQ     r1, #Service_PostInit
    ;    BEQ     Svc_PostInit


;drop into...

Svc_Reset Entry "R0-R2"
        MOV     r0, #&FD                ; read last reset type
        MOV     r1, #0
        MOV     r2, #&FF
        SWI     XOS_Byte
        TEQ     r1, #0                  ; if not a soft reset, ignore
        EXITS   NE

        BL      CancelSleepTimer

        MOV     R0, #0
        STRB    R0, PaletteVFlag
        STRB    R0, EventVFlag          ; indicate not on EventV (r1 = 0)
        STRB    R0, KeyVFlag
        STRB    R0, SleepTimerFlag
 [ HWPolling
        STRB    R0, CallEveryFlag
 ]

        STRB    R0, KeyRepeatFlag
        STR     R0, KeyRepeatAction
        STR     R0, KeyRepeatDelay
        STR     R0, KeyRepeatRate

        BL      ClaimEventV
        BL      ClaimPaletteV           ;>>>a kludge A4 code does this on mode change iff LCD mode
        BL      ClaimKeyV
        BL      InitMicroController             ;also clears BMUDevFlag
        BL      ClaimMicroControllerEvent

        MOV     r0, #0                          ;Now try turning as much off as possible,
        LDR     r1, =:NOT: PowerSaveBits        ; serial, parallel and FDC etc
        BL      SWIControl                      ; NB this call does send power-down messages.
 [ HWPolling
        BL      ClaimCallEvery
 ]
        EXITS

Svc_PreReset Entry "r0-r2"
;>>>wait for VSync before disabling LCD panel???
        EXITS

 [ {FALSE}
;
; Svc_PostInit - Issued on a reset after all ROM resident modules have been initialised.
;
; Setup a callback routine to start the LCDisplay.
;
Svc_PostInit
        Entry   "R0,R1"
        ADRL    R0, CB_SwitchToLCD
        MOV     R1, R12
        SWI     XOS_AddCallBack
        EXITS
 ]

;******************************************************************************

SWIEntry        ROUT
        LDR     R12,[R12]
        CMPS    R11,#(EndSWIJmpTable - SWIJmpTable) /4
        ADDCC   PC,PC,R11,LSL #2
        B       SWIUnknown

SWIJmpTable
        B       SWISpeed
        B       SWIControl
        B       SWI_ReadBMUVariable
        B       SWI_WriteBMUVariable
        B       SWI_CommandBMU
        B       SWIReadFeatures
        B       SWIIdle
        B       SWIStop
        B       SWIStatus
 [ SwindellCode
   ;     B       SWIPortable_Contrast
        B       SWIRefresh
        B       SWIHalt
       ;B       SWISleepTime
 ]
EndSWIJmpTable


;******************************************************************************

ModuleTitle ; Share the string
SWINameTable
        =       "Portable",0
        =       "Speed",0
        =       "Control",0
        =       "ReadBMUVariable",0
        =       "WriteBMUVariable",0
        =       "CommandBMU",0
        =       "ReadFeatures",0
        =       "Idle",0
        =       "Stop",0
        =       "Status",0
   ;     =       "Contrast",0
 [ SwindellCode
        =       "Refresh",0
        =       "Halt",0
 ]
        =       0
        ALIGN

;******************************************************************************

 [ SwindellCode
; enter with
; R0 Num refresh cycles
; R1 &03200000
; R2 STOP  data bus pattern
; R3 #&F0  Cas Lo, Ras Hi
; R4 #&FF  Cas Lo, Ras Lo
; R11 return address
;
SWIRefresh
        STRB R3, [R1,#&D4]      ; Cas Lo, Ras Hi
        STRB R4, [R1,#&D4]      ; Cas Lo, Ras Lo   CBR self refresh
SWIHalt
stop
        STR  R2, [R1,#&2C]      ; STOP data bus driven by Wr data
; stop until wake up event
        STRB R3, [R1,#&D4]      ; Cas Lo, Ras Hi   End self refresh
        MOV  R5, R0             ; get loop length into loop counter
refresh
        STRB R4, [R1,#&D4]      ; Cas Lo, Ras Lo   CBR Refresh
        STRB R3, [R1,#&D4]      ; Cas Lo, Ras Hi
        SUBS R5, R5, #1
        BNE  refresh
        STRB R5, [R1,#&D4]      ; Cas Hi, Ras Hi (R5=0)

        LDR R6, [R1,#&70]       ; irqD status, check if woken by event 2 if so go back to stop
        TST R6, #&08            ; was it event1, if not then must be event2 so stop again
        BEQ stop                ; stop again if event1=0
        BICS    PC,LR,#V_bit    ; jump back to application code
 ]
;******************************************************************************


SWIUnknown
SWISpeed
        Push    "r4,lr"
        ADR     r0, ErrorBlock_ModuleBadSWI
        ADR     r4, ModuleTitle
        BL      ErrorLookup1Parm
        Pull    "r4,pc"


;******************************************************************************
;
; SWI Portable_ReadFeatures
;
; Exit
;   R1  = bit 4 set to indicate SWI Portable_Idle is impletemted
;         bit 5 set to indicate SWI Portable_Stop is impletemted
;
; All other bits in R1 zeroed, all other registers preserved.
;
SWIReadFeatures ROUT
        MOV     R1,#(PortableFeature_Idle :OR: PortableFeature_Stop)
        BICS    PC,LR,#V_bit


;******************************************************************************
;
; SWI Portable_Idle - Places the system into idle mode.
;
; The CPU clock is stopped, but all other clocks run normally. This means the
; Video display and all the IO channels are active, the DRAM is refreshed, but
; the system consumes less power as the CPU is inactive. The CPU remains in
; this state until it receives a FIQ or IRQ interrupt (eg from the keyboard,
; floppy, centi-second timer etc).
;
SWIIdle Entry   "R0, R1"
       ;DLINE   "SWIIdle"

        MOV     R0, #0                          ;0 will stop Fclk, Clk2, Clk8, Ref8 and Clk16
        IOMDBase R1                             ;1 will stop Fclk (the CPU core clock) only
        STRB    R0, [R1, #IOMD_IDLEMODE]        ;INicholas 6/10/94 recommended stopping them all

        EXITS


;******************************************************************************
;
; SWI Portable_Stop - Stop (or freeze) the System.
;
; Sets the DRAM to self-refresh, then places the system into stop mode (all
; clocks are stopped). Execution continues only on receipt of an external
; wakeup event from the keyboard or real-time-clock. Normal FIQ or IRQ or
; centi-second timer events cannot happen because the IO system is not clocked.
;
; Exit
;   R0  = restart code, 1-keyboard interrupt
;                       2-RTC interrupt         (NYA)
;
SWIStop Entry   "R0-R9"
       ;DLINE   "SWIStop entry"

        MOV     R1, #Service_Portable           ;Send a service call round indicating
        MOV     R2, #ServicePortable_FreezeRequest      ;that we would like to freeze
        SWI     XOS_ServiceCall
        CMP     R1, #0                          ;If service call is claimed, someone objects
        BEQ     TooHotToFreeze                  ; eg BatMgr wants to stay alive whilst cycling the battery

        MOV     R1, #Service_Portable           ;Send a service call round indicating
        MOV     R2, #ServicePortable_Freeze     ; that we are entering freeze mode
        SWI     XOS_ServiceCall                 ;

        MOV     R7, #0                          ;Failure indication, set to OK

       ;TEQP    PC, #SVC_mode + I_bit + F_bit
;
; call ADFS_PowerControl to 'spindown' the winnies
;
       ;DLINE   "SWIStop - trying to shutdown the winnies"
        MOV     R0, #2                          ; manual control of drive spin
                                                ; without affecting autospindown
        MOV     r2, #0                          ; spin down immediately
        BL      ADFSPowerOp                     ; apply to all IDE drives
        MOVVS   R7, #1                          ;VS, failure to spin-down winnies
        BVS     fail_1
;
; turn IRQ's and FIQ's off to prevent things turning back on
;
        TEQP    PC, #SVC_mode + I_bit + F_bit
;
; shutdown the sound system
;
       ;DLINE   "SWIStop - trying to shutdown the sound system"
        MOV     R0, #1
        SWI     XSound_Enable                   ;turn sound system off
        MOV     R5, R0                          ;preserve old state for later
        MOVVS   R7, #2                          ;VS, failure to kill sound system
        BVS     fail_2
;
; blank the screen
;
       ;DLINE   "SWIStop - blanking the screen (probably was already)"
        MOV     R0, #ScreenBlankerReason_Blank
        SWI     XScreenBlanker_Control          ;blank screen
        MOVVS   R7, #3                          ;VS, failure to blank screen
        BVS     fail_3
;
; call Portable_Control to powerdown floppies/econet/serial etc
;
        MOV     R0, #0                          ;Now try turning off as much off as possible,
        LDR     r1, =:NOT: Shutdown1Bits        ; serial, parallel and FDC etc
        BL      SWIControl                      ; NB this call does send power-down messages.
        MOVVS   R7, #4
        BVS     fail_4

        LDR     R0, =Shutdown1Bits              ;Consider the items we tried to turn off.
        AND     R1, R1, R0
;
; Ignore any failure of the parallel or serial ports to shutdown.
; We call SetPwrState directly later on to force them off.
;
        LDR     R0, =(PortableControl_SerialEnable :OR: PortableControl_ParallelEnable)
        BICS    R1, R1, R0
        MOVNE   R7, #5                          ;NE, something refused to shutdown
        BNE     fail_5

;>>>if serial or parallel failed to shutdown, call SetPwrState directly to shut them down
;
;>>>on wake up call SetPwrState or Portable_Control to power them back up. Which should we
;>>>use? ie do we want a power up message to go round for them.
;
;>>>Use of a second call allows us to put mouse & lcd asleep once we know we are actually
;>>>going to succeed.

;
; Send 'Suspend' command to microcontroller
;
        LDRB    R1, CommandState
        TEQ     R1, #0
        MOVNE   R7, #6                          ;NE, battery manager busy (interupted SendPowerCommand)
        BNE     fail_6
        LDR     R0, =uC_StatusReg               ;Get Tx buffer status bit
        LDRB    R1, [R0]                        ;
        TST     R1, #uC_Status_OBF              ;
        MOVNE   R7, #6                          ;NE, battery manager busy (processing an earlier Power or Keyboard command)
        BNE     fail_6

        MOV     R2, #PwrCmd_Suspend
        LDR     R0, =uC_PwrDataTxReg
        STRB    R2, [R0]                        ;Write byte to Power manager

;
; Force remaining units to shutdown ie serial, parallel, trackerball, mouse etc
;
        LDR     R0, ConfigExtraBitsCopy         ;R0  = current state
        LDR     R1, =Shutdown2Bits
        BIC     R1, R0, R1                      ;R1  = required state
        BL      SetPwrState                     ;Force required state, NB ConfigExtraBitsCopy
                                                ; unaltered for later restoration
;
; Write &FF to HWLatchMC to save power, SCLatchMC untouched, for later restoration.
;
        MOV     R0, #&FF
        LDR     R1, =HWLatchMC
        STRB    R0, [R1]
;
; Set IIC clock and data lines low.
;
        MOV     R0, #0
        BL      SetIIC

 [ {TRUE}
        MOV     R4, #paletteV_VIDCDisable
        MOV     R9, #PaletteV
        SWI     XOS_CallAVector
 ]

        ADR     R14, StopTab
05
        LDMIA   R14!, {R0, R1}                  ;address, data
        TEQ     R0, #0
        STRNE   R1, [R0]
        BNE     %BT05

        IOMDBase R8
        LDRB    R6, [R8, #IOMD_VREFCR]
        AND     R1, R6, #&E0                    ;preserve VRAM(Sz2..0) bits, but turn refresh off
        STRB    R1, [R8, #IOMD_VREFCR]          ;old value kept in R6 for later restoration

        MOV     R1, #0                          ;Useful value

        LDRB    R0, [R8, #IOMD_VIDCR]
        STRB    R0, holdVIDCR
        STRB    R1, [R8, #IOMD_VIDCR]

        LDRB    R0, [R8, #IOMD_SD0CR]
        STRB    R0, holdSD0CR
        STRB    R1, [R8, #IOMD_SD0CR]

        LDRB    R0, [R8, #IOMD_ATODICR]
        STRB    R0, holdATODICR
        STRB    R1, [R8, #IOMD_ATODICR]

       ;DLINE   "SWIStop - setting DRAM to self refresh, stopping the processor"


        ASSERT  HWLatchMC = (IOMD_Base + IOMD_CLINES)
        LDRB    R1, [R8, #IOMD_CLINES]          ;iop3 pulled low for slow-refresh
        TST     R1, #08
        BEQ     StopWithSlowRefresh

StopWithSelfRefresh
        BL      BurstRefresh
;
; Put DRAM into self-refresh mode by lowering the CAS lines then the RAS lines
;
        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;force CAS lines low
        MOV     R1, #&FF
        STRB    R1, [R8, #IOMD_SELFREF]         ;force CAS and RAS lines low
;
; Stop the processor
;
        MOV     R1, #&FFFFFFFF
        STR     R1, [R8, #IOMD_STOPMODE]
;
; *** The system is now asleep, pending a wake-up interrupt ***
;
        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;raise RAS (CAS lines still low)
        MOV     R1, #0
        STRB    R1, [R8, #IOMD_SELFREF]         ;return CAS and RAS lines to normal use

        BL      BurstRefresh

        B       RestoreRegs
;
;
;
StopWithSlowRefresh
        BL      BurstRefresh                    ;Refresh the DRAM before entering/reentering STOP mode
;
; Stop the processor
;
        MOV     R1, #&FFFFFFFF
        STR     R1, [R8, #IOMD_STOPMODE]
;
; *** The system is now asleep, pending a wake-up interrupt ***
;
        LDRB    R1, [R8, #IOMD_IRQSTD]  ; irqD status, check if woken by event 2 if so go back to stop
        TST     R1, #IOMD_Nevent1_bit   ; was it event1, if not then must be event2 so stop again
        BEQ     StopWithSlowRefresh     ; stop again if event1=0

        BL      BurstRefresh                    ;Refresh the DRAM before reawakening the machine

;
; Bring the machine back to life
;
RestoreRegs
        IOMDBase R8
        STRB    R6, [R8, #IOMD_VREFCR]          ;Restore VRAM size and refresh rate

        LDRB    R1, holdVIDCR
        STRB    R1, [R8, #IOMD_VIDCR]

        LDRB    R1, holdSD0CR
        STRB    R1, [R8, #IOMD_SD0CR]

        LDRB    R1, holdATODICR
        STRB    R1, [R8, #IOMD_ATODICR]

       ;DLINE   "SWIStop - restarting"

 [ {TRUE}
        ADR     R14, StartTab
55
        LDMIA   R14!, {R0, R1}                  ;address, data
        TEQ     R0, #0
        STRNE   R1, [R0]
        BNE     %BT55
 ]

        MOV     R4, #paletteV_VIDCRestore
        MOV     R9, #PaletteV
        SWI     XOS_CallAVector

;
; Restore IIC clock and data lines to high.
;
        MOV     R0, #(i2c_clock_bit :OR: i2c_data_bit)
        BL      SetIIC
;
; Restore HWLatchMC - we set it to &FF to save power
;
        LDRB    R0, SCLatchMC                   ;Load soft copy
        LDR     R1, =HWLatchMC                  ;
        STRB    R0, [R1]                        ; and write to the port
;
; Restore state of serial, parallel etc
;
        LDR     R1, ConfigExtraBitsCopy
        BL      SetPwrState

        MOV     R0, #0                          ;Update RTC soft copy
        SWI     XOS_ResyncTime
;
;>>>determine cause of wakeup
;
;;;        MOV     R2, #PwrCmd_Send_input_signals
;;;        BL      SendPowerCommand
;;;        TST  R2, #

        MOV     R0, #1                          ;The only restart mechanism currently supported!
        STR     R0, [SP]                        ;overwrite stack R0

        BL      ClearRTCAlarm                   ;We may have been switched on by the alarm

        MOV     R7, #0                          ;Failure indication, set to OK
;
;
fail_6  ;Problem talking to microcontroller

fail_5
fail_4  ;Problem powering down floppy or winnie

        MOV     R0, #ScreenBlankerReason_Unblank
        SWI     XScreenBlanker_Control          ; un-blank screen

fail_3  ;Problem with screen blanking
        MOV     R0, R5                          ;restore state of sound system
        SWI     XSound_Enable

fail_2  ;Problem with sound system

fail_1  ;Problem with winnies
       ;SWI     XOS_WriteI + 7
;
; If R7 <> 0 it indicates an error occurred
;

;
;>>>send unfreeze service call here???
;
; could copy R7 into R3 to indicate success
        MOV     R1, #Service_Portable           ;Send a service call round indicating
        MOV     R2, #ServicePortable_Unfreeze   ; that we are exiting Portable_Stop
        MOV     R3, R7
        SWI     XOS_ServiceCall

        CMP     R7, #0
        ADRNE   R0,ErrorBlock_FreezeFailed
        BLNE    ErrorLookupNoParms              ;If called, will set V
        STRVS   R0, [SP]                         ; overwrite stack R0
        PullEnv
        BICVCS  PC,LR,#V_bit
        ORRVSS  PC,LR,#V_bit                    ;Exit
;
;>>>what about R0 - restart reason code???
;


TooHotToFreeze
        addr    R0,ErrorBlock_CantFreeze        ; error, R0 -> tokenised error block
        BL      ErrorLookupNoParms
        STR     R0,[SP]                         ; overwrite stack R0
        PullEnv
        ORRS    PC,LR,#V_bit



;HWLatchPA  2_00000000
;HWLatchPB  2_00001000
;HWLatchMC  2_11111111
;HWLatchMA  2_00000000

StopTab
   ;     DCD     &83400000, &C0000003    ;dac off, ereg set to external LUT
   ;     DCD     &83400000, &D0004000    ;Vclk off, Pcomp=0
   ;     DCD     &83400000, &E0004049    ;PoDown, Hclk
        DCD     &83400000, &B1000001    ;sound Dac off, serial (16bit) sound off
        DCD     &88000000, &FFFFFFFF    ;buffered data bus
        DCD     0

StartTab
        DCD     &83400000, &B1000003    ;sound Dac off, serial (16bit) sound on, 24Mhz ref. clock
        DCD     0


;
; NB Must NOT read/write from/to DRAM (which includes the stack)
;
BurstRefresh
        MOV     R0, #1024
77
;
; One CAS before RAS refresh cycle
;
        MOV     R1, #0
        STRB    R1, [R8, #IOMD_SELFREF]         ;CAS and RAS high
        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;force CAS lines low
        MOV     R1, #&FF
        STRB    R1, [R8, #IOMD_SELFREF]         ;force CAS and RAS lines low

        MOV     R1, #&FF
        STRB    R1, [R8, #IOMD_SELFREF]         ;CAS and RAS lines (still) low

        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;raise RAS (CAS lines still low)
        MOV     R1, #0
        STRB    R1, [R8, #IOMD_SELFREF]         ;return CAS and RAS lines to normal use

        SUBS    R0, R0, #1
        BGT     %BT77

        MOVS    PC, LR


;
; SetIIC Based on SetC1C0 from IIC.s.IICMod
;
; Set the state of the IIC clock and data lines
;
; Entry
;   R0 bits i2c_clock_bit and i2c_data_bit set to required levels
;
SetIIC
        Entry   "R0-R2"
        ORR     R14, R14, #I_bit                ; disable interrupts round access to IOCControlSoftCopy
        TEQP    R14, #0

        AND     R0, R0, #(i2c_clock_bit :OR: i2c_data_bit)

        MOV     R2, #0                          ; prepare to index soft copy
        LDRB    R1, [R2, #IOCControlSoftCopy]   ; read soft copy

        BIC     R1, R1, #(i2c_clock_bit :OR: i2c_data_bit)      ; clear clock and data
        ORR     R1, R1, R0                      ; put in new clock and data
        ORR     R1, R1, #&C0                    ; make sure two test bits are
                                                ; always set to 1 !
        STRB    R1, [R2, #IOCControlSoftCopy]   ; store back to soft copy

        MOV     R2, #IOC
        STRB    R1, [R2, #IOCControl]

        EXITS


;******************************************************************************
;
; SWI Portable_Status - Return status of connected devices.
;
; Exit
;   R0  = bit 0 set to indicate docking station connected
;         bit 1 set to indicate floppy connected
;     NYA bit 2 set to indicate internal tracker ball connected
;         bit 3 set to indicate internal (LCD) display in use
;
SWIStatus
        Entry   "R1"
        MOV     R0, #0

        LDR     R1, =HWLatchPB + 4              ;Read PCMCIA portB (+4 cos split register)
        LDRB    R1, [R1]                        ;
        TST     R1, #1                          ; examine docins* bit (negative logic)
        ORRNE   R0, R0, #PortableStatus_DocStationConnected ;1

        LDR     R1, =HWLatchPA + 4              ;Read PCMCIA portA (+4 cos split register)
        LDRB    R1, [R1]                        ;
        TST     R1, #2_00100000                 ; examine PrinterNotFloppy bit
        ORRNE   R0, R0, #PortableStatus_PrinterFloppy   ;2

        LDRB    R1, DisplayMode
        TEQ     R1, #0
        ORRNE   R0, R0, #8

        EXITS


;******************************************************************************

SWISleepTime    Entry
        STR     R0, SleepTimerDelay     ;>>>should we restart any existing
        EXITS                           ;>>>screen blank/sleep timer???


;******************************************************************************
;
; ClaimEventV - Claim EventV so we can notice hot keys
;
; Always preserves flags
;
ClaimEventV Entry "r0-r3"
        LDRB    r3, EventVFlag
        TEQ     r3, #0                  ; if already on vector
        EXITS   NE                      ; then exit

        MOV     r0, #EventV
        ADRL    r1, EventVHandler
        MOV     r2, wp
        SWI     XOS_Claim
        EXITS   VS

        MOV     r0, #14                 ; enable event
        MOV     r1, #Event_Keyboard
        SWI     XOS_Byte

        MOV     r3, #1                  ; indicate we're on vector
        STRB    r3, EventVFlag
        EXITS


;******************************************************************************
;
; ReleaseEventV - Release EventV
;
; Always preserves flags
;
ReleaseEventV Entry "r0-r3"
        LDRB    r3, EventVFlag
        TEQ     r3, #0                  ; if not on vector
        EXITS   EQ                      ; then don't bother releasing

        MOV     r0, #13                 ; disable event
        MOV     r1, #Event_Keyboard
        SWI     XOS_Byte

        MOV     r0, #EventV
        ADRL    r1, EventVHandler
        MOV     r2, wp
        SWI     XOS_Release

        MOV     r3, #0                  ; indicate not on vector
        STRB    r3, EventVFlag
        EXITS


;******************************************************************************
;
;       ClaimKeyV - Claim KeyV
;       Always preserves flags
;

ClaimKeyV Entry "r0-r3"
        MOV     r0, #KEYV               ; always claim KeyV (MOS ensures we're only on once) -
        ADRL    r1, KeyVHandler
        MOV     r2, wp
        SWI     XOS_Claim
        EXITS   VS

        MOV     r3, #1                  ; indicate we're on vector
        STRB    r3, KeyVFlag
        EXITS


;******************************************************************************
;
;       ReleaseKeyV - Release KeyV
;       Always preserves flags
;

ReleaseKeyV Entry "r0-r3"
        LDRB    r3, KeyVFlag
        TEQ     r3, #0                  ; if not on vector
        EXITS   EQ                      ; then don't bother releasing

        MOV     r0, #KEYV
        ADRL    r1, KeyVHandler
        MOV     r2, wp
        SWI     XOS_Release

        MOV     r3, #0                  ; indicate not on vector
        STRB    r3, KeyVFlag
        EXITS


;******************************************************************************
;
;       ClaimPaletteV - Claim PaletteV
;       Always preserves flags
;

ClaimPaletteV Entry "r0-r3"
        MOV     r0, #PaletteV           ; always claim PaletteV (MOS ensures we're only on once) -
        ADR     r1, PaletteVHandler     ; PaletteVFlag may be wrong immediately after a soft reset.
        MOV     r2, wp
        SWI     XOS_Claim
        EXITS   VS

        MOV     r3, #1                  ; indicate we're on vector, but colours not inited
        STRB    r3, PaletteVFlag
        EXITS

;******************************************************************************
;
;       ReleasePaletteV - Release PaletteV
;       Always preserves flags
;

ReleasePaletteV Entry "r0-r3"
        LDRB    r3, PaletteVFlag
        TEQ     r3, #0                  ; if not on vector
        EXITS   EQ                      ; then don't bother releasing

        MOV     r0, #PaletteV
        ADR     r1, PaletteVHandler
        MOV     r2, wp
        SWI     XOS_Release

        MOV     r3, #0                  ; indicate not on vector
        STRB    r3, PaletteVFlag
        EXITS


;******************************************************************************
;
;       PaletteVHandler
;
; in:   r4 = reason code
;
; out:  depends on r4
;

        ASSERT  paletteV_Complete = 0
        ASSERT  paletteV_Read = 1
        ASSERT  paletteV_Set = 2
        ASSERT  paletteV_1stFlashState = 3
        ASSERT  paletteV_2ndFlashState = 4
        ASSERT  paletteV_SetDefaultPalette = 5
        ASSERT  paletteV_BlankScreen = 6
        ASSERT  paletteV_DimScreen = 11
 [ {TRUE}
PaletteVHandler Entry "r0-r3"
        CMP     r4, #paletteV_BlankScreen
        BEQ     PV_BlankUnblank
        CMP     r4, #paletteV_DimScreen
        BEQ     PV_DimUndim
        EXITS

ClaimExit
        MOV     r4, #0
        PullEnv
        Pull    pc
 |
PaletteVHandler Entry "r0-r3"
        CMP     r4, #1
        EXITS   CC
        BEQ     PV_ReadPalette
        CMP     r4, #3
        BCC     PV_SetPalette
        BEQ     PV_1stFlashState
        CMP     r4, #5
        BCC     PV_2ndFlashState
        BEQ     PV_SetDefaultPalette
        CMP     r4, #7
        BCC     PV_BlankUnblank
        EXITS

ClaimExit
        MOV     r4, #0
        PullEnv
        Pull    pc

PV_1stFlashState
PV_SetFlashState
PV_2ndFlashState
PV_ReadPalette
PV_SetPalette
PV_SetDefaultPalette
        EXITS
 ]

;******************************************************************************
;
;       PV_BlankUnblank - Blank/unblank screen
;
; in:   r0 = -1 (read blank state)
;          or 0 (unblank screen)
;          or 1 (blank screen)
;       r0-r3, lr already pushed
;
; out:  r0 = old state (0=unblanked, 1=blanked)
;       r4 = 0 => operation complete
;

PV_BlankUnblank ROUT
       ;DREG    R0, "PV_BlankUnblank, R0 is ",,Integer
        TEQ     R0, #0
        BLEQ    CancelSleepTimer
        TEQ     R0, #1
        BLEQ    StartSleepTimer

        EXITS   ;NB registers pushed by PaletteVHandler

 [ {TRUE}
;******************************************************************************
;
;       PV_DimUndim - Dim/undim screen
;
; in:   r0 = -1 (read dim state)
;          or 0 (undim screen)
;          or 1 (dim screen)
;       r0-r3, lr already pushed
;
; out:  r0 = old state (0=undimmed, 1=dimmed)
;       r4 = 0 => operation complete
;

PV_DimUndim ROUT
        LDRB    R2, BrightnessIndex1            ;NB load order swapped! (reduces code later)
        LDRB    R1, BrightnessIndex2
        CMP     R2, R1
        MOVLT   R3, #1                          ;dim
        MOVGE   R3, #0                          ;bright
        STR     R3, [sp]                        ; return old state in R0 (on stack)

        CMP     R0, #1
        BHI     ClaimExit                       ;HI, reading only

        CMP     R3, R0
        BEQ     ClaimExit                       ;EQ already in requested state

        LDRB    R3, BrightnessHold              ;NE not in requested state
        TEQ     R3, #1                          ;
        BEQ     ClaimExit                       ;EQ leave screen dim, cos user set it so
;^^^merge above
       ;LDRB    R2, BrightnessIndex1            ;NB Swap values
       ;LDRB    R1, BrightnessIndex2            ; (final store of R1 into BrightnessIndex1
        STRB    R2, BrightnessIndex2            ;  performed by subroutine)
        BL      SetBrightness                   ;In R1=brightness value
        B       ClaimExit                       ;finish
 ]

;******************************************************************************
;
;       ADFSPowerOp - Issue an ADFS_PowerControl SWI to all IDE drives
;
; in:   r0, r2 are the parameters we wish to pass to the SWI
;
; out:  -
;

ADFSPowerOp Entry "r0-r4"
        MOV     r4, r0                          ; save r0 value
        MOV     r1, #4                          ; for drive = 4 to 7
10
        MOV     r0, r1                          ; read type of drive
        SWI     XADFS_ControllerType
        BVS     %FT20                           ; if error then skip
        TEQ     r0, #4                          ; if IDE drive
        MOVEQ   r0, r4                          ; then perform operation
        SWIEQ   XADFS_PowerControl
 [ {FALSE}
        BVC     %FT20
        ADD     R0, R0, #4      ;skip error number
       ;DLINE   R0, "XADFS_PowerControl reported: ",,String
 ]
20
        ADD     r1, r1, #1
        TEQ     r1, #8
        BNE     %BT10
        EXITS


;******************************************************************************
;
; CheckForCMOSReset - Check CMOS reset bit in CMOS RAM, and reconfigure
;                     certain values if so
;
; Entry:
;
; Exit:
;   R0-R7 may be corrupted
;
CheckForCMOSReset Entry
        MOV     r0, #ReadCMOS
        MOV     r1, #SystemSpeedCMOS            ;CMOS reset indicator location
        SWI     XOS_Byte
        EXITS   VS                              ;if couldn't read it then finish

        TST     r2, #CMOSResetBit               ;or if bit clear then finish
        EXITS   EQ

; Set configured Delay to 25 and Repeat to 6 and reflect in current states

        ADR     r0, ConfigureDelayCommand
        SWI     XOS_CLI
        ADRL    r0, ConfigureRepeatCommand
        SWI     XOS_CLI
        MOV     r0, #12
        MOV     r1, #0
        SWI     XOS_Byte                        ;set current delay and repeat to configured

; Set configured screen-blanking time to 5 minutes and reflect in current state

        MOV     r0, #ReadCMOS
        MOV     r1, #Misc1CMOS
        SWI     XOS_Byte
        BICVC   r2, r2, #7 :SHL: 3
        ORRVC   r2, r2, #4 :SHL: 3              ; 0=>none, 1=>30s, 2=>1min, 3=>2min,
        MOVVC   r0, #WriteCMOS                  ; 4=>5min, 5=>10min, 6=>15min, 7=>30min
        SWIVC   XOS_Byte
        ADRL    r0, BlankTimeCommand
        SWI     XOS_CLI

; Set configured SoundDefault to 1 6 2 and reflect in current states

        MOV     r0, #WriteCMOS
        MOV     r1, #SoundCMOS
        MOV     r2, #(1 :SHL: 7) :OR: (6 :SHL: 4) :OR: ((2-1) :SHL: 0)
        SWI     XOS_Byte

        MOV     r0, #6*18+1                     ; set volume to 6
        SWI     XSound_Volume                   ; (speaker should already be set to 1)

        MOV     r0, #1                          ; set channel 1
        MOV     r1, #2                          ; to use voice generator 2 (StringLib-Soft)
        SWI     XSound_AttachVoice

; Set configured beep to Loud and reflect in current state

        MOV     r0, #ReadCMOS
        MOV     r1, #DBTBCMOS
        SWI     XOS_Byte
        ORRVC   r2, r2, #2                      ; set beep to LOUD
        MOVVC   r0, #WriteCMOS
        SWIVC   XOS_Byte

        MOV     r0, #212                        ; OS_Byte number to set bell volume/envelope
        MOV     r1, #&90
        MOV     r2, #0
        SWI     XOS_Byte

; Set configured IDE disc spin to 2 mins and reflect in current state

        MOV     r0, #WriteCMOS
        MOV     r1, #ADFSSpinDownCMOS           ; set configured autospindown
        MOV     r2, #120/5                      ; to 2 minutes = 120 seconds
        SWI     XOS_Byte
        MOV     r0, #1                          ; set drive autospindown
        MOV     r2, #120/5                      ; to same
        BL      ADFSPowerOp

; Make !BatMgr appear on icon bar by default

        MOV     r0, #ReadCMOS
        MOV     r1, #Deskboot2CMOS
        SWI     XOS_Byte
        ORRVC   r2, r2, #1                      ; bit 0 set => appear on icon bar, clear => don't
        MOVVC   r0, #WriteCMOS
        SWIVC   XOS_Byte
;
; Set 'bright' and 'dim' brightness levels, 'idle mode inhibit' and 'lid closure'
; Pack 'current' into bits 0..2 and 'other' into bits 3..5
;
        MOV     R2, #(default_LCDBrightness1 :OR: (default_LCDBrightness2 :SHL: 3))

        MOVVC   R0, #WriteCMOS
        MOVVC   R1, #BrightnessCMOS
        SWIVC   XOS_Byte
;
; Set contrast level
;
        MOV     R0, #ReadCMOS
        MOV     R1, #ContrastCMOS
        SWI     XOS_Byte                        ;result in R2.b

        BICVC   R2, R2, #2_00111111
        ORRVC   R2, R2, #default_LCDContrast

        MOVVC   R0, #WriteCMOS
        MOVVC   R1, #ContrastCMOS
        SWIVC   XOS_Byte
;
; Set 'screen dim time' and 'freeze time' values
; Pack 'screen dim time' into bits 0..2 and 'freeze time' into bits 3..5
;
        MOV     R0, #ReadCMOS
        MOV     R1, #TimeCMOS
        SWI     XOS_Byte                        ;result in R2.b

        BICVC   R2, R2, #2_00111111             ;clear both time values
        ORRVC   R2, R2, #(default_DimTime :OR: (default_FreezeTime :SHL: 3))

        MOVVC   R0, #WriteCMOS
        MOVVC   R1, #TimeCMOS
        SWIVC   XOS_Byte

;>>>set MonitorType of 7 (or should it be 8???) for LCD

        EXITS

ConfigureDelayCommand
        =       "Configure Delay 25", 0
ConfigureRepeatCommand
        =       "Configure Repeat 6", 0
BlankTimeCommand
        =       "BlankTime 300", 0              ; 300 seconds = 5 minutes
        ALIGN

;******************************************************************************

ErrorLookupNoParms      Entry   "R1-R7"
;
; Entry:
;    R0 -> error block with tokenised message
;
; Exit:
;    R0 -> error block with real message
;    V set

        MOV     R4,#0                           ; no parameter 0
        B       ErrorLookupContinue

ErrorLookup1Parm        ALTENTRY
;
; Entry:
;    R0 -> error block with tokenised message
;    R4 -> parameter to substitute into error
;
; Exit:
;    R0 -> error block with real message
;    V set

ErrorLookupContinue

        wsaddr  R1,MsgTransBlk
        MOV     R2,#0                           ; use internal buffer
        MOV     R5,#0                           ; no parameter 0
        MOV     R6,#0                           ; no parameter 0
        MOV     R7,#0                           ; no parameter 0
        SWI     XMessageTrans_ErrorLookup
        EXIT

;******************************************************************************
;
; StartSleepTimer - called when screen blanks (ie paletteV_BlankScreen)
;
; We define BlankTime and FreezeTime as starting when the user last pressed a key or moved
; the mouse. Since this routine is called at the expiry of the screen blank timer, we must
; subtract the BlankTime from FreezeTime to give the time remaining before freezing.
;
; No params, all registers preserved
;
StartSleepTimer Entry "R0-R2"
        LDRB    R0, SleepTimerFlag
        TEQ     R0, #0
        EXITS   NE                              ;NE, reentry, no action required
;DLINE "StartSleepTimer"
        LDR     R0, SleepTimerDelay             ;sleep time delay
        TEQ     R0, #0
        EXITS   EQ                              ;EQ, freeze timer switched off

 [ {TRUE}
        MOV     R0, #ScreenBlankerReason_ReadTimeout2
        SWI     XScreenBlanker_Control          ;Returns: R0 corrupted, R1=blanking delay (centi-seconds)
        MOVVS   R1, #0
 |
        MOV     R0, #ScreenBlankerReason_ReadTimeout
        SWI     XScreenBlanker_Control          ;Returns: R0 corrupted, R1=blanking delay (seconds)
        MOVVS   R1, #0                          ;despite what the documentation says, R1 is in seconds
        MLA     R1, R1, #100                    ;convert to centi-seconds
 ]
        LDR     R0, SleepTimerDelay             ;sleep time delay
        SUB     R0, R0, R1                      ;calculate time remaining
        CMP     R0, #50                         ;If FreezeTime <= BlankTime
        MOVLT   R0, #50                         ; then switch off now (almost)

RestartSleepTimer
        ADR     R1, SleepTimerCallAfter         ;routine to call after timer expires
        MOV     R2, R12                         ;R12 value to call it with
        SWI     XOS_CallAfter                   ;if this fails, the 'go to sleep' event never happens...
        MOVVC   R0, #1                          ;eventually we receive a battery low interrupt
        STRVCB  R0, SleepTimerFlag
        EXITS

;******************************************************************************
;
; CancelSleepTimer
;
; No params, all registers preserved
;
CancelSleepTimer Entry "R0-R2"
        LDRB    R0, SleepTimerFlag
        TEQ     R0, #0
        EXITS   EQ
        ADR     R0, SleepTimerCallAfter         ;address and workspace originally
        MOV     R1, R12                         ;passed to OS_CallAfter
        SWI     XOS_RemoveTickerEvent

        MOV     R0, #0
        STRB    R0, SleepTimerFlag
        EXITS

;******************************************************************************

SleepTimerCallAfter Entry "R0-R2"
        ADR     R0, SleepTimerCallBack
        MOV     R1, R12
        SWI     XOS_AddCallBack
        EXITS

SleepTimerCallBack Entry "R0-R2"
        MOV     R0, #0                          ;timer cleared once it fires
        STRB    R0, SleepTimerFlag

        SWI     XPortable_Stop                  ;try putting the machine to sleep
        EXITS   VC                              ;VC machine stopped then restarted
                                                ;VS something objected
        MOV     R0, #RetryDelay
        B       RestartSleepTimer

; Aside: XPortable_Stop calls Screen blanker to blank the screen (it happens to be blanked).
;        This causes us to be entered via PaletteV and another sleep timer is set up.
;        The machine then sleeps.
;        As soon as the machine restarts, the Screen blanker is called to unblank the screen,
;        it calls us via PaletteV which cancels the sleep timer.

FreezeTimes
        DCD     0               ;Off
        DCD     60*100          ; 1 minute
        DCD     2*60*100        ; 2 minutes
        DCD     5*60*100        ; 5 minutes
        DCD     10*60*100       ;10 minutes
        DCD     15*60*100       ;15 minutes
        DCD     30*60*100       ;30 minutes
        DCD     60*60*100       ;60 minutes
FreezeTimesMaxIndex * ((. - FreezeTimes)/4 - 1)
        ASSERT  FreezeTimesMaxIndex = 7

        ASSERT  default_FreezeTime <= FreezeTimesMaxIndex

;******************************************************************************

; KillRTCAlarm  - Cancel alarm completely on module startup.
;
; ClearRTCAlarm - Clear any previously flagged alarm prior to freeze/shutdown.
;
KillRTCAlarm
        Push    "R0-R2,LR"
        MOV     R0, #IICAddress_AcornRTC
        ADR     R1, IICBlk_2
        MOV     R2, #2
        SWI     XIIC_Control
        Pull    "R0-R2,LR"                      ;drop into...

ClearRTCAlarm
        Push    "R0-R2,LR"
        MOV     R0, #IICAddress_AcornRTC
        ADR     R1, IICBlk_1
        MOV     R2, #2
        SWI     XIIC_Control
        Pull    "R0-R2,PC",,^                   ;drop into...

IICBlk_1
        DCB     0       ;Control/status register
        DCB     &04     ; Alarm enable bit=1 (alarm active), stops RTC interrupt line pulsing
                        ; at 1Hz, also clears alarm flag (bit1)

IICBlk_2
        DCB     8       ;Alarm control register
        DCB     &00     ; all alarms and timers off

        ALIGN


;******************************************************************************

 [ Debug
        InsertDebugRoutines
 ]

;******************************************************************************

        END
@


4.5
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.66. Tagged as 'Portable-0_66'
@
text
@d195 1
a195 1
 [ 1 = 1
d269 1
a269 1
                                                ; KEYV_PseudoIntMask. See DoKeyV_PseudoIntMask.
d487 1
a487 1
 [ 1 = 0
d623 1
a623 1
        MOV     R1, #IOMD_Base                  ;1 will stop Fclk (the CPU core clock) only
d754 1
a754 1
 [ 1=1
d767 1
a767 1
        MOV     R8, #IOMD_Base
d842 1
a842 1
        MOV     R8, #IOMD_Base
d856 1
a856 1
 [ 1=1
d1214 1
a1214 1
 [ 1 = 1
d1277 1
a1277 1
 [ 1 = 1
d1335 1
a1335 1
 [ F
d1536 1
a1536 1
 [ 1 = 1
@


4.4
log
@  Fixed conditional macro in exported header file
Detail:
  Checks that IOMD_Base is defined before attempting to use it
    for its external interfaces.
  Now uses srccommit to maintain its version number.
Admin:
  Should this header file ever get exported, it won't cause
    makehswis in RISC_OSLib to blow up any more.

Version 0.65. Tagged as 'Portable-0_65'
@
text
@d20 1
a20 1

d47 1
a47 1
Help    DCB     "Portable",9,"$Module_MajorVersion ($Module_Date)",0
d74 1
a74 1
SleepTimeCmd    ENTRY
d127 1
a127 1
DecodeParam ENTRY "R6"
d182 1
a182 1
Init    ENTRY   "R7"
d372 1
a372 1
Die     ENTRY
d445 1
a445 1
Svc_Reset ENTRY "R0-R2"
d483 1
a483 1
Svc_PreReset ENTRY "r0-r2"
d494 1
a494 1
        ENTRY   "R0,R1"
d619 1
a619 1
SWIIdle ENTRY   "R0, R1"
d642 1
a642 1
SWIStop ENTRY   "R0-R9"
d1010 1
a1010 1
        ENTRY   "R0-R2"
d1042 1
a1042 1
        ENTRY   "R1"
d1064 1
a1064 1
SWISleepTime    ENTRY
d1075 1
a1075 1
ClaimEventV ENTRY "r0-r3"
d1101 1
a1101 1
ReleaseEventV ENTRY "r0-r3"
d1126 1
a1126 1
ClaimKeyV ENTRY "r0-r3"
d1144 1
a1144 1
ReleaseKeyV ENTRY "r0-r3"
d1165 1
a1165 1
ClaimPaletteV ENTRY "r0-r3"
d1182 1
a1182 1
ReleasePaletteV ENTRY "r0-r3"
d1215 1
a1215 1
PaletteVHandler ENTRY "r0-r3"
d1227 1
a1227 1
PaletteVHandler ENTRY "r0-r3"
d1325 1
a1325 1
ADFSPowerOp ENTRY "r0-r4"
d1357 1
a1357 1
CheckForCMOSReset ENTRY
d1485 1
a1485 1
ErrorLookupNoParms      ENTRY   "R1-R7"
d1527 1
a1527 1
StartSleepTimer ENTRY "R0-R2"
d1565 1
a1565 1
CancelSleepTimer ENTRY "R0-R2"
d1579 1
a1579 1
SleepTimerCallAfter ENTRY "R0-R2"
d1585 1
a1585 1
SleepTimerCallBack ENTRY "R0-R2"
@


4.3
log
@Modified SWI handler to cope with SMBusOp for IMS
@
text
@d47 1
a47 1
Help    DCB     "Portable",9,"$VString ($Date)",0
@


4.2
log
@Version Spin_merge taken
@
text
@d86 1
a86 1
        BL      DecodeParam 
d519 1
a520 1
 [ SwindellCode
d523 1
a524 1
       ;B       SWISleepTime
d642 1
a642 1
SWIStop ENTRY   "R0-R9"        
d1135 1
a1135 1
        EXITS 
d1592 1
a1592 1
        MOV     R0, #RetryDelay       
@


4.1
log
@Initial revision
@
text
@d15 1
a15 1
        TTL     Source.Portable
d38 5
d51 2
a52 1
Command DCB     "SleepTime", 0
d54 2
a55 2
        DCD     SleepTime - Module_BaseAddr
        DCD     &00010000:OR:International_Help
d61 1
a61 1
SleepTimeHlp    DCB     "*SleepTime sets the delay (seconds) before an idle machine shuts down.", 13
d63 2
a64 2
                DCB     "To turn off use *SleepTime 0", 13
SleepTimeSyn    DCB     "Syntax: *SleepTime [Time]", 0
d67 1
a67 1
        DCB     "HSCBBLT", 0
d69 1
a69 1
        DCB     "SSCBBLT", 0
d74 51
a124 6
;******************************************************************************
;
; Resources
;
Path            DCB     "Portable$Path",0
DefPath         DCB     "Resources:$.Resources.Portable.",0
a125 2
MessageFile     DCB     "Portable:Messages",0
        ALIGN
d127 12
d140 3
a142 1
;******************************************************************************
a143 2
        MakeErrorBlock  BadVarNam
        ALIGN
d156 3
d162 6
d169 4
a172 1
;******************************************************************************
a230 13
 [ UseMicroController
 |
; initialise variables

        MOV     R1,#PortableBMU_Num_Variables   ;number to do
        ADR     R2,Defaults
        wsaddr  R3,variables
20
        LDR     R0,[R2],#4
        STR     R0,[R3],#4
        SUBS    R1,R1,#1
        BNE     %BT20
 ]
a236 2
        LDR     R1, =1000
        STR     R1, SleepTimerDelay
a241 1
 [ UseMicroController
d243 2
d246 16
a261 20
 [ UseSRAM
;
;The code controlling the DRAM CAS and RAS lines obviously can't be executed from DRAM.
;Final code will run from ROM, but for testing, we copy the code into SRAM.
;
        Push    "R0 - R3"
        LDR     R0, = sram                      ;destination address (SRAM)
        ADRL    R1, thecode_start               ;source address (from module)
        ADRL    R2, thecode_end
30
        LDR     R3, [R1],#4
        STR     R3, [R0],#4
        CMP     R1, R2
        BLO     %BT30

        LDR     R0, =&09800FF2
        LDR     R1, =&02C08000
        STR     R0, [R1]
        Pull    "R0 - R3"
 ]
a265 2
 [ UseMicroController
;>>>claim battery manager events
d270 7
a276 1
 ]
a277 1
;>>>read CMOS for brightness & contrast settings
d279 1
d281 13
d297 8
a304 5
        ANDVC   R1, R2, #7                      ;extract bits 0..2 as one brightness value
        MOVVC   R2, R2, LSR #3                  ;
        ANDVC   R2, R2, #7                      ;extract bits 3..5 as another brightness value
        MOVVS   R1, #default_LCDBrightness1
        MOVVS   R2, #default_LCDBrightness2
d310 1
a310 1
        STRB    R2, BrightnessCopy2             ;store lowest value as 'other' value
d313 4
d318 1
a318 1
        MOV     R1, #ContrastCMOS
d320 17
a336 4
        MOVVC   R1, R2
        MOVVS   R1, #default_LCDContrast
        STRB    R1, ContrastCopy
        BL      SendContrast
a352 1
        LTORG
d354 3
d358 1
a358 32

 [ UseMicroController
 |
;
Defaults
        DCD     0
        DCD     100
        DCD     100
        DCD     0
        DCD     100
        DCD     100
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     &60
        DCD     0
;
; Stork variables
;
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     60
        DCD     &60
        DCD     0
        DCD     100

        ASSERT  (. - Defaults) = (PortableBMU_Num_Variables * 4)
 ]
a375 2
 ;SWI XPortable_ReadFeatures
;>>>Kill sleep timer???
d381 1
a381 1
        MVN     R1, R0                          ; ie with everything powered up
d387 1
a387 1
 [ UseMicroController
d391 2
d394 6
d421 1
d439 4
d454 14
a467 4
        STRB    r1, PaletteVFlag
        STRB    r1, EventVFlag          ; indicate not on EventV (r1 = 0)
        STRB    r1, KeyVFlag
        STRB    r1, SleepTimerFlag
a471 1
 [ UseMicroController
a473 1
 ]
d478 3
d487 11
a497 32
;******************************************************************************

SleepTime       ENTRY
        LDR     R12, [R12]                      ;get workspace pointer

        TEQ     R1, #0
        BEQ     SleepTimeNoParams

SleepTimeLoop
        LDRB    R1, [R0]                        ;check for end
        CMP     R1, #32                         ;and chop off leading spaces.
        ADDEQ   R0, R0, #1
        BEQ     SleepTimeLoop
        EXITS   LT                              ;exit if control-char.
        BL      DecodeParam 
        BVC     SleepTimeLoop
        EXIT                                    ;return V set

SleepTimeNoParams
        EXIT

DecodeParam ENTRY "R6"
        MOV     R1, R0                          ;move strpointer to R1
        MOV     R0, #(1<<29)                    ;check  0<=R2<=2^18 (ca. 3 days)
        MOV     R2, #(1<<18)                    ;restrict to moderate positive int
        SWI     XOS_ReadUnsigned
        BVS     DecodeErr                       ;print error and exit.
        MOV     R6, R1                  ; save the updated strpointer
        MOV     R3, #100
        MUL     R1,R2,R3
   ;>>>     BL      Subr_SetTimeout         ; Corrupts some registers
        MOV     R0,R6
d499 1
a499 4

DecodeErr
        Pull    "R6,LR"
        ORRS    PC, LR, #V_bit
d518 6
a524 5
 [ TestHardware
        B       SWIConfig
        B       SWIFloppy
        B       SWIPrinter
 ]
d530 1
d541 5
a545 4
 [ TestHardware
        =       "Config",0
        =       "Floppy",0
        =       "Printer",0
d552 31
a582 5
        MakeErrorBlock  OutOfRange
SWIUnknown      ROUT
SWISpeed
        addr    R0,ErrorBlock_OutOfRange
        ORRS    PC,LR,#V_bit
a583 1
;******************************************************************************
d585 7
d599 1
a599 1
;   R0  = bit 4 set to indicate SWI Portable_Idle is impletemted
d602 1
a602 1
; All other bits in R0 zeroed, all other registers preserved.
d620 2
a621 3
       ; DLINE   "SWIIdle"
  
 [ OnMorris
d625 1
a625 14
        EXITS
 ]
        
 [ OnEasiStork
       ;TEQP    PC, #SVC_mode + I_bit
        MOV     R0, #0
        LDR     R1, =stop_fclk
        STRB    R0, [R1]
        STRB    R0, [R1]
        STRB    R0, [R1]
       ;STRB    R0, [R1]
       ;STRB    R0, [R1]
       ;STRB    R0, [R1]
 ]
d637 6
a642 6
; 
SWIStop ENTRY   "R0-R6,R7,R8"        
 [ T
       ;DLINE   "SWIStop called but ignored"
        EXITS           ;cos HardWare curled its toes up over Easter
 ]
d645 10
a667 3



d669 5
a673 1
; call Portable_Control to powerdown floppies/econet/serial etc
a674 2
; Bxx yyy ;Something refused to shutdown

d681 3
a683 1

d690 28
a719 1
 [ UseMicroController
d722 2
a723 2
        MOVNE   R7, #4                          ;NE, battery manager busy (interupted SendPowerCommand)
        BNE     fail_4
d727 2
a728 2
        MOVNE   R7, #4                          ;NE, battery manager busy (processing an earlier Power or Keyboard command)
        BNE     fail_4
a732 1
 ]
d735 9
a743 1
; remove power from LCD display, LCD backlight and external VDU
d745 21
a765 1
        TEQP    PC, #SVC_mode + I_bit + F_bit
d772 13
d789 7
a795 1
 [ OnMorris
d811 2
d816 1
d818 11
a828 24
 ]

 [ OnEasiStork
        LDR     R1, =stop_both
        LDR     R2, =rascas_latch
        LDR     R3, =tlb_dummy
  [ UseSRAM
        BL      callcodeinSRAM
        B       thecode_end

thecode_start
  ]
        LDRB    R0, [R3]
        LDRB    R0, [R2]
        LDRB    R0, [R3]                        ;dummy reads to stop later TLB ram fetches
                                                ;Put DRAM into self-refresh mode
        MOV     R0, #&F0                        ;force CAS low
        STRB    R0, [R2]

        MOV     R0, #&FF                        ;force CAS and RAS low
        STRB    R0, [R2]

        MOV     R0, #0                          ;stop processor
        STRB    R0, [R1]
d832 3
a834 2
        MOV     R0, #0                          ;CAS and RAS high
        STRB    R0, [R2]
d836 1
a836 5
  [ UseSRAM
        MOVS    PC, LR
thecode_end
  ]
 ]
d838 4
a842 1
 [ T
d844 19
a862 5
 |
        LDRB    R1, [R8, #IOMD_VREFCR]
        AND     R1, R1, #&E0                    ;Preserve VRAM(Sz2..0) bits
        ORR     R1, R1, #IOMD_VREFCR_REF_16     ;set 16s refresh >>>should really restore old value
        STRB    R1, [R8, #IOMD_VREFCR]
d865 20
a884 1
       ;DLINE   "SWIStop - restarting"
d886 2
d889 12
a900 2
;>>>call Portable_Control to power LCD or VDU
;>>>I suppose we could have changed from VDU to LCD or vice-versa whilst asleep!
d902 6
a907 1
fail_4  ;Problem talking to microcontroller
d918 110
a1027 2
        SWI     XOS_WriteI + 7
       ;DLINE   "SWIStop exit"
a1029 5
 [ UseSRAM
callcodeinSRAM
        MOV     R0, #&02000000
        MOV     PC, R0
 ]
d1032 12
d1045 9
a1053 3
SWISleepTime    ENTRY
        STR     R0, SleepTimerDelay     ;>>>should we restart any existing
        EXITS                           ;>>>screen blank/sleep timer???
d1055 3
a1057 29
 [ TestHardware
;******************************************************************************
SWIConfig ENTRY   "r1-r4"
        TEQP    pc, #SVC_mode + I_bit
        NOP
        BL      EnterConfigMode
        ADR     lr, ConfigParallelFDC665
        LDMIA   lr!, {r3,r4}            ; load addr1, data1
        STRB    r4, [r3]                ; set up CRI
        LDMIA   lr, {r3,r4}             ; load addr2, data2
        LDRB    R0, [r3]
        BL      ExitConfigMode
        EXITS

SWIFloppy ENTRY "r0-r4"
        TEQP    pc, #SVC_mode + I_bit
        NOP
        BL      EnterConfigMode

        ADR     lr, ConfigParallelFDC665
        LDMIA   lr!, {r3,r4}            ; load addr1, data1
        STRB    r4, [r3]                ; set up CRI
        LDMIA   lr, {r3,r4}             ; load addr2, data2
        LDRB    lr, [r3]
        ORR     lr, lr, r4              ; enable
        EOR     lr, lr, r4, LSR #8      ; allow for +ve/-ve logic
        STRB    lr, [r3]

        BL      ExitConfigMode
d1062 1
a1062 13
SWIPrinter ENTRY "r0-r4"
        TEQP    pc, #SVC_mode + I_bit
        NOP
        BL      EnterConfigMode

        ADR     lr, ConfigParallelFDC665
        LDMIA   lr!, {r3,r4}            ; load addr1, data1
        STRB    r4, [r3]                ; set up CRI
        LDMIA   lr, {r3,r4}             ; load addr2, data2
        LDRB    lr, [r3]
        BIC     lr, lr, r4              ; disable
       ;EOR     lr, lr, r4, LSR #8      ; allow for +ve/-ve logic
        STRB    lr, [r3]
d1064 3
a1066 1
        BL      ExitConfigMode
a1067 2
        EXITS
 ]
d1094 1
d1119 2
a1120 1
; ******************************************************************************************************
d1137 2
a1138 1
; ******************************************************************************************************
d1158 2
a1159 1
; ******************************************************************************************************
d1176 1
a1176 1
; ******************************************************************************************************
d1196 2
a1197 1
;*******************************************************************************************************
d1213 8
d1222 5
d1253 1
a1273 1
        EXITS
d1275 40
d1346 1
d1370 1
a1370 1
        ADR     r0, ConfigureRepeatCommand
d1385 1
a1385 1
        ADR     r0, BlankTimeCommand
d1434 5
d1440 16
d1457 16
a1472 2
;>>>must also configure sound system for 16 digital
;>>>
d1519 5
a1523 1
; StartSleepTimer
d1530 1
a1530 1
        EXITS   NE
d1533 18
d1580 6
d1588 1
a1588 1
;DLINE "SleepTimerCallAfter"
d1595 1
a1595 1
; Aside: XPortable_Stop calls Screen blanker to blank the screen (it happens to be blanked)
d1600 48
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d15 1
a15 1
        TTL     Source.StPortable
a37 5
 [ International_Help <> 0
        DCD     messagefilename - Module_BaseAddr
 |
        DCD     0
 ]
d46 1
a46 2
Command
        DCB     "FreezeTime", 0
d48 2
a49 2
        DCD     SleepTimeCmd - Module_BaseAddr
        DCD     &0001FF00:OR:International_Help
d55 1
a55 1
SleepTimeHlp    DCB     "*FreezeTime (seconds) sets the delay before an idle machine enters freeze mode.", 13
d57 2
a58 2
                DCB     "To turn off use *FreezeTime 0", 13
SleepTimeSyn    DCB     "Syntax: *FreezeTime [Time]", 0
d61 1
a61 1
        DCB     "HSCSLP", 0
d63 1
a63 1
        DCB     "SSCSLP", 0
d68 6
a73 2
SleepTimeCmd    ENTRY
        LDR     R12, [R12]                      ;get workspace pointer
d75 2
a76 2
        TEQ     R1, #0
        BEQ     SleepTimeNoParams
a77 9
SleepTimeLoop
        LDRB    R1, [R0]                        ;check for end
        CMP     R1, #32                         ;and chop off leading spaces.
        ADDEQ   R0, R0, #1
        BEQ     SleepTimeLoop
        EXITS   LT                              ;exit if control-char.
        BL      DecodeParam 
        BVC     SleepTimeLoop
        EXIT                                    ;return V set
d79 1
a79 53
SleepTimeNoParams
;;;;        BL      openmsgfile
;;;;        EXIT    VS

        LDR     R0, SleepTimerDelay
        TEQ     R0, #0
        ADREQ   R1,SleepOff
        ADRNE   R1,StrBuff
        MOVNE   R2,#StrBuffLen
        SWINE   XOS_BinaryToDecimal
        SUBNE   R2, R2, #2              ; convert to seconds (sort of)
        MOVNE   R4,R1
        MOVNE   r0, #0
        STRNEB  r0, [r4, r2]
        MOVNE   R1,R2
        ADRNE   R1,SleepTim

        SUB     sp, sp, #80

        wsaddr  R0, MsgTransBlk

        MOVVC   r2, sp
        MOVVC   r3, #80
        SWIVC   XMessageTrans_Lookup
        MOVVC   r0, r2
        SWIVC   XOS_Write0
        ADD     sp, sp, #80

        SWIVC   XOS_NewLine

        EXIT

SleepOff DCB    "SleepOff", 0
SleepTim DCB    "SleepTm", 0
                ALIGN


DecodeParam ENTRY "R6"
        MOV     R1, R0                          ;move strpointer to R1
        MOV     R0, #(1<<29)                    ;check  0<=R2<=2^18 (ca. 3 days)
        MOV     R2, #(1<<18)                    ;restrict to moderate positive int
        SWI     XOS_ReadUnsigned
        BVS     DecodeErr                       ;print error and exit.
        MOV     R6, R1                          ; save the updated strpointer
        MOV     R3, #100
        MUL     R0,R2,R3                        ;R0 is SleepTime in centiseconds
        BL      SWISleepTime                    ; Corrupts some registers
        MOV     R0,R6
        EXITS

DecodeErr
        Pull    "R6,LR"
        ORRS    PC, LR, #V_bit
d81 2
d95 1
a95 2
        AddError        CantFreeze,"CantFreeze"
        AddError        FreezeFailed,"FreezeFailed"
a96 1
        ASSERT          @@ <= (ErrorBase_Portable + ?ErrorBase_Portable)
a99 10
;
; Resources
;
;Path            DCB     "Portable$Path",0
;DefPath         DCB     "Resources:$.Resources.Portable.",0

MessageFile
messagefilename
        DCB     "Resources:$.Resources.Portable.Messages", 0
        ALIGN
d158 13
d177 2
d184 1
a185 2
 [ HWPolling
        STRB    R0, CallEveryFlag
d187 20
a206 16

        STRB    R0, KeyRepeatFlag
        STR     R0, KeyRepeatAction
        STR     R0, KeyRepeatDelay
        STR     R0, KeyRepeatRate

;>>>do I need Path variable stuff?

; open messages file

        wsaddr  R0,MsgTransBlk
        addr    R1,MessageFile
        MOV     R2,#0                           ; no buffer supplied
        SWI     XMessageTrans_OpenFile
        EXIT    VS

d211 2
d217 1
a217 7
;
; Kernel starts in CRT mode but we switch to LCD in !Boot
;
        MOV     R0, #0
        STRB    R0, PaletteMode
        MOV     R0, #&FF
        STRB    R0, DisplayMode
d219 1
a220 1
; Read LCD contrast & brightness settings from CMOS RAM
a221 13
        ASSERT  ContrastTableMaxIndex = 63      ;we allocate 6bits in CMOS
        MOV     R0, #ReadCMOS
        MOV     R1, #ContrastCMOS
        SWI     XOS_Byte                        ;result in R2.b
        MOVVS   R1, #default_LCDContrast
        AND     R1, R2, #2_00111111
        STRB    R1, ContrastIndex

        MOV     R0, #0                          ;Brightness and contrast written simultaneously
        STRB    R0, BrightnessValue             ; to digipot, fudge zero for brightness whilst
        BL      SendContrast                    ; setting contrast

        ASSERT  BrightnessTableMaxIndex = 7     ;we allocate 3bits in CMOS for each
d225 5
a229 8
        MOVVS   R2, #(default_LCDBrightness1 :OR: (default_LCDBrightness2 :SHL: 3)) ;b7 and b6 clear

        AND     R1, R2, #2_11000000             ;b7 lid closure, b6 idle mode inhibit
        STRB    R1, ModeBits

        AND     R1, R2, #7                      ;extract bits 0..2 as one brightness value
        MOV     R2, R2, LSR #3                  ;
        AND     R2, R2, #7                      ;extract bits 3..5 as another brightness value
d235 1
a235 1
        STRB    R2, BrightnessIndex2            ;store lowest value as 'other' value
a237 4
;
; Read Freeze time from CMOS RAM
;
        ASSERT  FreezeTimesMaxIndex = 7
d239 1
a239 1
        MOV     R1, #TimeCMOS
d241 4
a244 17
        MOVVC   R2, R2, LSR #3                  ;
        ANDVC   R2, R2, #7                      ;extract bits 3..5 freeze time
        MOVVS   R2, #default_FreezeTime

        ADRL    R1, FreezeTimes
        LDR     R2, [R1, R2,LSL #2]             ;multiply index by 4 - table of words
        STR     R2, SleepTimerDelay

 [ HWPolling
        BL      ClaimCallEvery
 ]
;
; We currently have no software support for 'machine wake-up by alarm', other than to allow
; external software to program it. We take steps to silence any already triggered alarm to
; ensure that the machine can shutdown/freeze.
;
        BL      KillRTCAlarm                    ;We may have been switched on by the alarm
d261 1
a262 3
        MakeErrorBlock  ModuleBadSWI
        MakeErrorBlock  CantFreeze
        MakeErrorBlock  FreezeFailed
d264 32
a295 1
        LTORG
d313 2
d320 1
a320 1
        MOV     R1, #0                          ; ie with everything powered up
d326 1
a326 1

a329 2
 [ HWPolling
        BL      ReleaseCallEvery
a330 6

; close message file

        wsaddr  R0,MsgTransBlk
        SWI     XMessageTrans_CloseFile

a351 1
    ;    TEQNE   r1, #Service_PostInit
a368 4
    ;    TEQ     r1, #Service_PostInit
    ;    BEQ     Svc_PostInit


d380 4
a383 14

        MOV     R0, #0
        STRB    R0, PaletteVFlag
        STRB    R0, EventVFlag          ; indicate not on EventV (r1 = 0)
        STRB    R0, KeyVFlag
        STRB    R0, SleepTimerFlag
 [ HWPolling
        STRB    R0, CallEveryFlag
 ]

        STRB    R0, KeyRepeatFlag
        STR     R0, KeyRepeatAction
        STR     R0, KeyRepeatDelay
        STR     R0, KeyRepeatRate
d388 1
d391 1
a395 3
 [ HWPolling
        BL      ClaimCallEvery
 ]
d402 32
a433 11
 [ 1 = 0
;
; Svc_PostInit - Issued on a reset after all ROM resident modules have been initialised.
;
; Setup a callback routine to start the LCDisplay.
;
Svc_PostInit
        ENTRY   "R0,R1"
        ADRL    R0, CB_SwitchToLCD
        MOV     R1, R12
        SWI     XOS_AddCallBack
d435 4
a438 1
 ]
d457 5
a461 5
        B       SWIStatus
   ;     B       SWIPortable_Contrast
 [ SwindellCode
        B       SWIRefresh
        B       SWIHalt
a462 1
       ;B       SWISleepTime
a467 1
ModuleTitle ; Share the string
d478 4
a481 5
        =       "Status",0
   ;     =       "Contrast",0
 [ SwindellCode
        =       "Refresh",0
        =       "Halt",0
d488 6
a493 30
 [ SwindellCode
; enter with
; R0 Num refresh cycles
; R1 &03200000
; R2 STOP  data bus pattern
; R3 #&F0  Cas Lo, Ras Hi
; R4 #&FF  Cas Lo, Ras Lo
; R11 return address
;
SWIRefresh
        STRB R3, [R1,#&D4]      ; Cas Lo, Ras Hi
        STRB R4, [R1,#&D4]      ; Cas Lo, Ras Lo   CBR self refresh
SWIHalt
stop
        STR  R2, [R1,#&2C]      ; STOP data bus driven by Wr data
; stop until wake up event
        STRB R3, [R1,#&D4]      ; Cas Lo, Ras Hi   End self refresh
        MOV  R5, R0             ; get loop length into loop counter
refresh
        STRB R4, [R1,#&D4]      ; Cas Lo, Ras Lo   CBR Refresh
        STRB R3, [R1,#&D4]      ; Cas Lo, Ras Hi
        SUBS R5, R5, #1
        BNE  refresh
        STRB R5, [R1,#&D4]      ; Cas Hi, Ras Hi (R5=0)

        LDR R6, [R1,#&70]       ; irqD status, check if woken by event 2 if so go back to stop
        TST R6, #&08            ; was it event1, if not then must be event2 so stop again
        BEQ stop                ; stop again if event1=0
        BICS    PC,LR,#V_bit    ; jump back to application code
 ]
a496 8
SWIUnknown
SWISpeed
        Push    "r4,lr"
        ADR     r0, ErrorBlock_ModuleBadSWI
        ADR     r4, ModuleTitle
        BL      ErrorLookup1Parm
        Pull    "r4,pc"

d503 1
a503 1
;   R1  = bit 4 set to indicate SWI Portable_Idle is impletemted
d506 1
a506 1
; All other bits in R1 zeroed, all other registers preserved.
d524 3
a526 2
       ;DLINE   "SWIIdle"

d530 14
a543 1

d555 6
a560 6
;
; Exit
;   R0  = restart code, 1-keyboard interrupt
;                       2-RTC interrupt         (NYA)
;
SWIStop ENTRY   "R0-R9"        
a562 10
        MOV     R1, #Service_Portable           ;Send a service call round indicating
        MOV     R2, #ServicePortable_FreezeRequest      ;that we would like to freeze
        SWI     XOS_ServiceCall
        CMP     R1, #0                          ;If service call is claimed, someone objects
        BEQ     TooHotToFreeze                  ; eg BatMgr wants to stay alive whilst cycling the battery

        MOV     R1, #Service_Portable           ;Send a service call round indicating
        MOV     R2, #ServicePortable_Freeze     ; that we are entering freeze mode
        SWI     XOS_ServiceCall                 ;

d576 3
d580 1
a580 5
; turn IRQ's and FIQ's off to prevent things turning back on
;
        TEQP    PC, #SVC_mode + I_bit + F_bit
;
; shutdown the sound system
d582 2
d590 1
a590 3
;
; blank the screen
;
a596 28
; call Portable_Control to powerdown floppies/econet/serial etc
;
        MOV     R0, #0                          ;Now try turning off as much off as possible,
        LDR     r1, =:NOT: Shutdown1Bits        ; serial, parallel and FDC etc
        BL      SWIControl                      ; NB this call does send power-down messages.
        MOVVS   R7, #4
        BVS     fail_4

        LDR     R0, =Shutdown1Bits              ;Consider the items we tried to turn off.
        AND     R1, R1, R0
;
; Ignore any failure of the parallel or serial ports to shutdown.
; We call SetPwrState directly later on to force them off.
;
        LDR     R0, =(PortableControl_SerialEnable :OR: PortableControl_ParallelEnable)
        BICS    R1, R1, R0
        MOVNE   R7, #5                          ;NE, something refused to shutdown
        BNE     fail_5

;>>>if serial or parallel failed to shutdown, call SetPwrState directly to shut them down
;
;>>>on wake up call SetPwrState or Portable_Control to power them back up. Which should we
;>>>use? ie do we want a power up message to go round for them.
;
;>>>Use of a second call allows us to put mouse & lcd asleep once we know we are actually
;>>>going to succeed.

;
d599 1
d602 2
a603 2
        MOVNE   R7, #6                          ;NE, battery manager busy (interupted SendPowerCommand)
        BNE     fail_6
d607 2
a608 2
        MOVNE   R7, #6                          ;NE, battery manager busy (processing an earlier Power or Keyboard command)
        BNE     fail_6
d613 1
d616 1
a616 1
; Force remaining units to shutdown ie serial, parallel, trackerball, mouse etc
d618 1
a618 29
        LDR     R0, ConfigExtraBitsCopy         ;R0  = current state
        LDR     R1, =Shutdown2Bits
        BIC     R1, R0, R1                      ;R1  = required state
        BL      SetPwrState                     ;Force required state, NB ConfigExtraBitsCopy
                                                ; unaltered for later restoration
;
; Write &FF to HWLatchMC to save power, SCLatchMC untouched, for later restoration.
;
        MOV     R0, #&FF
        LDR     R1, =HWLatchMC
        STRB    R0, [R1]
;
; Set IIC clock and data lines low.
;
        MOV     R0, #0
        BL      SetIIC

 [ 1=1
        MOV     R4, #paletteV_VIDCDisable
        MOV     R9, #PaletteV
        SWI     XOS_CallAVector
 ]

        ADR     R14, StopTab
05
        LDMIA   R14!, {R0, R1}                  ;address, data
        TEQ     R0, #0
        STRNE   R1, [R0]
        BNE     %BT05
a624 13
        MOV     R1, #0                          ;Useful value

        LDRB    R0, [R8, #IOMD_VIDCR]
        STRB    R0, holdVIDCR
        STRB    R1, [R8, #IOMD_VIDCR]

        LDRB    R0, [R8, #IOMD_SD0CR]
        STRB    R0, holdSD0CR
        STRB    R1, [R8, #IOMD_SD0CR]

        LDRB    R0, [R8, #IOMD_ATODICR]
        STRB    R0, holdATODICR
        STRB    R1, [R8, #IOMD_ATODICR]
d629 1
a629 7
        ASSERT  HWLatchMC = (IOMD_Base + IOMD_CLINES)
        LDRB    R1, [R8, #IOMD_CLINES]          ;iop3 pulled low for slow-refresh
        TST     R1, #08
        BEQ     StopWithSlowRefresh

StopWithSelfRefresh
        BL      BurstRefresh
a644 2
        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;raise RAS (CAS lines still low)
a647 1
        BL      BurstRefresh
d649 24
a672 11
        B       RestoreRegs
;
;
;
StopWithSlowRefresh
        BL      BurstRefresh                    ;Refresh the DRAM before entering/reentering STOP mode
;
; Stop the processor
;
        MOV     R1, #&FFFFFFFF
        STR     R1, [R8, #IOMD_STOPMODE]
d676 2
a677 3
        LDRB    R1, [R8, #IOMD_IRQSTD]  ; irqD status, check if woken by event 2 if so go back to stop
        TST     R1, #IOMD_Nevent1_bit   ; was it event1, if not then must be event2 so stop again
        BEQ     StopWithSlowRefresh     ; stop again if event1=0
d679 5
a683 1
        BL      BurstRefresh                    ;Refresh the DRAM before reawakening the machine
a684 4
;
; Bring the machine back to life
;
RestoreRegs
d686 1
d688 6
a693 9

        LDRB    R1, holdVIDCR
        STRB    R1, [R8, #IOMD_VIDCR]

        LDRB    R1, holdSD0CR
        STRB    R1, [R8, #IOMD_SD0CR]

        LDRB    R1, holdATODICR
        STRB    R1, [R8, #IOMD_ATODICR]
a696 18
 [ 1=1
        ADR     R14, StartTab
55
        LDMIA   R14!, {R0, R1}                  ;address, data
        TEQ     R0, #0
        STRNE   R1, [R0]
        BNE     %BT55
 ]

        MOV     R4, #paletteV_VIDCRestore
        MOV     R9, #PaletteV
        SWI     XOS_CallAVector

;
; Restore IIC clock and data lines to high.
;
        MOV     R0, #(i2c_clock_bit :OR: i2c_data_bit)
        BL      SetIIC
d698 2
a699 1
; Restore HWLatchMC - we set it to &FF to save power
d701 1
a701 31
        LDRB    R0, SCLatchMC                   ;Load soft copy
        LDR     R1, =HWLatchMC                  ;
        STRB    R0, [R1]                        ; and write to the port
;
; Restore state of serial, parallel etc
;
        LDR     R1, ConfigExtraBitsCopy
        BL      SetPwrState

        MOV     R0, #0                          ;Update RTC soft copy
        SWI     XOS_ResyncTime
;
;>>>determine cause of wakeup
;
;;;        MOV     R2, #PwrCmd_Send_input_signals
;;;        BL      SendPowerCommand
;;;        TST  R2, #

        MOV     R0, #1                          ;The only restart mechanism currently supported!
        STR     R0, [SP]                        ;overwrite stack R0

        BL      ClearRTCAlarm                   ;We may have been switched on by the alarm

        MOV     R7, #0                          ;Failure indication, set to OK
;
;
fail_6  ;Problem talking to microcontroller

fail_5
fail_4  ;Problem powering down floppy or winnie

d712 2
a713 110
       ;SWI     XOS_WriteI + 7
;
; If R7 <> 0 it indicates an error occurred
;

;
;>>>send unfreeze service call here???
;
; could copy R7 into R3 to indicate success
        MOV     R1, #Service_Portable           ;Send a service call round indicating
        MOV     R2, #ServicePortable_Unfreeze   ; that we are exiting Portable_Stop
        MOV     R3, R7
        SWI     XOS_ServiceCall

        CMP     R7, #0
        ADRNE   R0,ErrorBlock_FreezeFailed
        BLNE    ErrorLookupNoParms              ;If called, will set V
        STRVS   R0, [SP]                         ; overwrite stack R0
        PullEnv
        BICVCS  PC,LR,#V_bit
        ORRVSS  PC,LR,#V_bit                    ;Exit
;
;>>>what about R0 - restart reason code???
;


TooHotToFreeze
        addr    R0,ErrorBlock_CantFreeze        ; error, R0 -> tokenised error block
        BL      ErrorLookupNoParms
        STR     R0,[SP]                         ; overwrite stack R0
        PullEnv
        ORRS    PC,LR,#V_bit



;HWLatchPA  2_00000000
;HWLatchPB  2_00001000
;HWLatchMC  2_11111111
;HWLatchMA  2_00000000

StopTab
   ;     DCD     &83400000, &C0000003    ;dac off, ereg set to external LUT
   ;     DCD     &83400000, &D0004000    ;Vclk off, Pcomp=0
   ;     DCD     &83400000, &E0004049    ;PoDown, Hclk
        DCD     &83400000, &B1000001    ;sound Dac off, serial (16bit) sound off
        DCD     &88000000, &FFFFFFFF    ;buffered data bus
        DCD     0

StartTab
        DCD     &83400000, &B1000003    ;sound Dac off, serial (16bit) sound on, 24Mhz ref. clock
        DCD     0


;
; NB Must NOT read/write from/to DRAM (which includes the stack)
;
BurstRefresh
        MOV     R0, #1024
77
;
; One CAS before RAS refresh cycle
;
        MOV     R1, #0
        STRB    R1, [R8, #IOMD_SELFREF]         ;CAS and RAS high
        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;force CAS lines low
        MOV     R1, #&FF
        STRB    R1, [R8, #IOMD_SELFREF]         ;force CAS and RAS lines low

        MOV     R1, #&FF
        STRB    R1, [R8, #IOMD_SELFREF]         ;CAS and RAS lines (still) low

        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;raise RAS (CAS lines still low)
        MOV     R1, #0
        STRB    R1, [R8, #IOMD_SELFREF]         ;return CAS and RAS lines to normal use

        SUBS    R0, R0, #1
        BGT     %BT77

        MOVS    PC, LR


;
; SetIIC Based on SetC1C0 from IIC.s.IICMod
;
; Set the state of the IIC clock and data lines
;
; Entry
;   R0 bits i2c_clock_bit and i2c_data_bit set to required levels
;
SetIIC
        ENTRY   "R0-R2"
        ORR     R14, R14, #I_bit                ; disable interrupts round access to IOCControlSoftCopy
        TEQP    R14, #0

        AND     R0, R0, #(i2c_clock_bit :OR: i2c_data_bit)

        MOV     R2, #0                          ; prepare to index soft copy
        LDRB    R1, [R2, #IOCControlSoftCopy]   ; read soft copy

        BIC     R1, R1, #(i2c_clock_bit :OR: i2c_data_bit)      ; clear clock and data
        ORR     R1, R1, R0                      ; put in new clock and data
        ORR     R1, R1, #&C0                    ; make sure two test bits are
                                                ; always set to 1 !
        STRB    R1, [R2, #IOCControlSoftCopy]   ; store back to soft copy

        MOV     R2, #IOC
        STRB    R1, [R2, #IOCControl]

d716 5
a722 12
;
; SWI Portable_Status - Return status of connected devices.
;
; Exit
;   R0  = bit 0 set to indicate docking station connected
;         bit 1 set to indicate floppy connected
;     NYA bit 2 set to indicate internal tracker ball connected
;         bit 3 set to indicate internal (LCD) display in use
;
SWIStatus
        ENTRY   "R1"
        MOV     R0, #0
d724 3
a726 9
        LDR     R1, =HWLatchPB + 4              ;Read PCMCIA portB (+4 cos split register)
        LDRB    R1, [R1]                        ;
        TST     R1, #1                          ; examine docins* bit (negative logic)
        ORRNE   R0, R0, #PortableStatus_DocStationConnected ;1

        LDR     R1, =HWLatchPA + 4              ;Read PCMCIA portA (+4 cos split register)
        LDRB    R1, [R1]                        ;
        TST     R1, #2_00100000                 ; examine PrinterNotFloppy bit
        ORRNE   R0, R0, #PortableStatus_PrinterFloppy   ;2
d728 29
a756 3
        LDRB    R1, DisplayMode
        TEQ     R1, #0
        ORRNE   R0, R0, #8
d761 13
a773 1
;******************************************************************************
d775 1
a775 3
SWISleepTime    ENTRY
        STR     R0, SleepTimerDelay     ;>>>should we restart any existing
        EXITS                           ;>>>screen blank/sleep timer???
d777 2
a804 1

d829 1
a829 2

;******************************************************************************
d846 1
a846 2

;******************************************************************************
d866 1
a866 2

;******************************************************************************
d883 1
a883 1
;******************************************************************************
d903 1
a903 2

;******************************************************************************
a918 8
        ASSERT  paletteV_DimScreen = 11
 [ 1 = 1
PaletteVHandler ENTRY "r0-r3"
        CMP     r4, #paletteV_BlankScreen
        BEQ     PV_BlankUnblank
        CMP     r4, #paletteV_DimScreen
        BEQ     PV_DimUndim
        EXITS
a919 5
ClaimExit
        MOV     r4, #0
        PullEnv
        Pull    pc
 |
a945 1
 ]
d966 1
a967 40
        EXITS   ;NB registers pushed by PaletteVHandler

 [ 1 = 1
;******************************************************************************
;
;       PV_DimUndim - Dim/undim screen
;
; in:   r0 = -1 (read dim state)
;          or 0 (undim screen)
;          or 1 (dim screen)
;       r0-r3, lr already pushed
;
; out:  r0 = old state (0=undimmed, 1=dimmed)
;       r4 = 0 => operation complete
;

PV_DimUndim ROUT
        LDRB    R2, BrightnessIndex1            ;NB load order swapped! (reduces code later)
        LDRB    R1, BrightnessIndex2
        CMP     R2, R1
        MOVLT   R3, #1                          ;dim
        MOVGE   R3, #0                          ;bright
        STR     R3, [sp]                        ; return old state in R0 (on stack)

        CMP     R0, #1
        BHI     ClaimExit                       ;HI, reading only

        CMP     R3, R0
        BEQ     ClaimExit                       ;EQ already in requested state

        LDRB    R3, BrightnessHold              ;NE not in requested state
        TEQ     R3, #1                          ;
        BEQ     ClaimExit                       ;EQ leave screen dim, cos user set it so
;^^^merge above
       ;LDRB    R2, BrightnessIndex1            ;NB Swap values
       ;LDRB    R1, BrightnessIndex2            ; (final store of R1 into BrightnessIndex1
        STRB    R2, BrightnessIndex2            ;  performed by subroutine)
        BL      SetBrightness                   ;In R1=brightness value
        B       ClaimExit                       ;finish
 ]
a998 1

d1022 1
a1022 1
        ADRL    r0, ConfigureRepeatCommand
d1037 1
a1037 1
        ADRL    r0, BlankTimeCommand
a1085 5
;
; Set 'bright' and 'dim' brightness levels, 'idle mode inhibit' and 'lid closure'
; Pack 'current' into bits 0..2 and 'other' into bits 3..5
;
        MOV     R2, #(default_LCDBrightness1 :OR: (default_LCDBrightness2 :SHL: 3))
a1086 16
        MOVVC   R0, #WriteCMOS
        MOVVC   R1, #BrightnessCMOS
        SWIVC   XOS_Byte
;
; Set contrast level
;
        MOV     R0, #ReadCMOS
        MOV     R1, #ContrastCMOS
        SWI     XOS_Byte                        ;result in R2.b

        BICVC   R2, R2, #2_00111111
        ORRVC   R2, R2, #default_LCDContrast

        MOVVC   R0, #WriteCMOS
        MOVVC   R1, #ContrastCMOS
        SWIVC   XOS_Byte
d1088 2
a1089 16
; Set 'screen dim time' and 'freeze time' values
; Pack 'screen dim time' into bits 0..2 and 'freeze time' into bits 3..5
;
        MOV     R0, #ReadCMOS
        MOV     R1, #TimeCMOS
        SWI     XOS_Byte                        ;result in R2.b

        BICVC   R2, R2, #2_00111111             ;clear both time values
        ORRVC   R2, R2, #(default_DimTime :OR: (default_FreezeTime :SHL: 3))

        MOVVC   R0, #WriteCMOS
        MOVVC   R1, #TimeCMOS
        SWIVC   XOS_Byte

;>>>set MonitorType of 7 (or should it be 8???) for LCD

d1136 1
a1136 5
; StartSleepTimer - called when screen blanks (ie paletteV_BlankScreen)
;
; We define BlankTime and FreezeTime as starting when the user last pressed a key or moved
; the mouse. Since this routine is called at the expiry of the screen blank timer, we must
; subtract the BlankTime from FreezeTime to give the time remaining before freezing.
d1143 1
a1143 1
        EXITS   NE                              ;NE, reentry, no action required
a1145 18
        TEQ     R0, #0
        EXITS   EQ                              ;EQ, freeze timer switched off

 [ 1 = 1
        MOV     R0, #ScreenBlankerReason_ReadTimeout2
        SWI     XScreenBlanker_Control          ;Returns: R0 corrupted, R1=blanking delay (centi-seconds)
        MOVVS   R1, #0
 |
        MOV     R0, #ScreenBlankerReason_ReadTimeout
        SWI     XScreenBlanker_Control          ;Returns: R0 corrupted, R1=blanking delay (seconds)
        MOVVS   R1, #0                          ;despite what the documentation says, R1 is in seconds
        MLA     R1, R1, #100                    ;convert to centi-seconds
 ]
        LDR     R0, SleepTimerDelay             ;sleep time delay
        SUB     R0, R0, R1                      ;calculate time remaining
        CMP     R0, #50                         ;If FreezeTime <= BlankTime
        MOVLT   R0, #50                         ; then switch off now (almost)

a1174 6
        ADR     R0, SleepTimerCallBack
        MOV     R1, R12
        SWI     XOS_AddCallBack
        EXITS

SleepTimerCallBack ENTRY "R0-R2"
d1177 1
a1177 1

d1184 1
a1184 1
; Aside: XPortable_Stop calls Screen blanker to blank the screen (it happens to be blanked).
a1188 48

FreezeTimes
        DCD     0               ;Off
        DCD     60*100          ; 1 minute
        DCD     2*60*100        ; 2 minutes
        DCD     5*60*100        ; 5 minutes
        DCD     10*60*100       ;10 minutes
        DCD     15*60*100       ;15 minutes
        DCD     30*60*100       ;30 minutes
        DCD     60*60*100       ;60 minutes
FreezeTimesMaxIndex * ((. - FreezeTimes)/4 - 1)
        ASSERT  FreezeTimesMaxIndex = 7

        ASSERT  default_FreezeTime <= FreezeTimesMaxIndex

;******************************************************************************

; KillRTCAlarm  - Cancel alarm completely on module startup.
;
; ClearRTCAlarm - Clear any previously flagged alarm prior to freeze/shutdown.
;
KillRTCAlarm
        Push    "R0-R2,LR"
        MOV     R0, #IICAddress_AcornRTC
        ADR     R1, IICBlk_2
        MOV     R2, #2
        SWI     XIIC_Control
        Pull    "R0-R2,LR"                      ;drop into...

ClearRTCAlarm
        Push    "R0-R2,LR"
        MOV     R0, #IICAddress_AcornRTC
        ADR     R1, IICBlk_1
        MOV     R2, #2
        SWI     XIIC_Control
        Pull    "R0-R2,PC",,^                   ;drop into...

IICBlk_1
        DCB     0       ;Control/status register
        DCB     &04     ; Alarm enable bit=1 (alarm active), stops RTC interrupt line pulsing
                        ; at 1Hz, also clears alarm flag (bit1)

IICBlk_2
        DCB     8       ;Alarm control register
        DCB     &00     ; all alarms and timers off

        ALIGN

@


4.1.5.1
log
@Import from SrcFiler
@
text
@d15 1
a15 1
        TTL     Source.StPortable
a37 5
 [ International_Help <> 0
        DCD     messagefilename - Module_BaseAddr
 |
        DCD     0
 ]
d46 1
a46 2
Command
        DCB     "FreezeTime", 0
d48 2
a49 2
        DCD     SleepTimeCmd - Module_BaseAddr
        DCD     &0001FF00:OR:International_Help
d55 1
a55 1
SleepTimeHlp    DCB     "*FreezeTime (seconds) sets the delay before an idle machine enters freeze mode.", 13
d57 2
a58 2
                DCB     "To turn off use *FreezeTime 0", 13
SleepTimeSyn    DCB     "Syntax: *FreezeTime [Time]", 0
d61 1
a61 1
        DCB     "HSCSLP", 0
d63 1
a63 1
        DCB     "SSCSLP", 0
d68 6
a73 2
SleepTimeCmd    ENTRY
        LDR     R12, [R12]                      ;get workspace pointer
d75 2
a76 2
        TEQ     R1, #0
        BEQ     SleepTimeNoParams
a77 9
SleepTimeLoop
        LDRB    R1, [R0]                        ;check for end
        CMP     R1, #32                         ;and chop off leading spaces.
        ADDEQ   R0, R0, #1
        BEQ     SleepTimeLoop
        EXITS   LT                              ;exit if control-char.
        BL      DecodeParam 
        BVC     SleepTimeLoop
        EXIT                                    ;return V set
d79 1
a79 53
SleepTimeNoParams
;;;;        BL      openmsgfile
;;;;        EXIT    VS

        LDR     R0, SleepTimerDelay
        TEQ     R0, #0
        ADREQ   R1,SleepOff
        ADRNE   R1,StrBuff
        MOVNE   R2,#StrBuffLen
        SWINE   XOS_BinaryToDecimal
        SUBNE   R2, R2, #2              ; convert to seconds (sort of)
        MOVNE   R4,R1
        MOVNE   r0, #0
        STRNEB  r0, [r4, r2]
        MOVNE   R1,R2
        ADRNE   R1,SleepTim

        SUB     sp, sp, #80

        wsaddr  R0, MsgTransBlk

        MOVVC   r2, sp
        MOVVC   r3, #80
        SWIVC   XMessageTrans_Lookup
        MOVVC   r0, r2
        SWIVC   XOS_Write0
        ADD     sp, sp, #80

        SWIVC   XOS_NewLine

        EXIT

SleepOff DCB    "SleepOff", 0
SleepTim DCB    "SleepTm", 0
                ALIGN


DecodeParam ENTRY "R6"
        MOV     R1, R0                          ;move strpointer to R1
        MOV     R0, #(1<<29)                    ;check  0<=R2<=2^18 (ca. 3 days)
        MOV     R2, #(1<<18)                    ;restrict to moderate positive int
        SWI     XOS_ReadUnsigned
        BVS     DecodeErr                       ;print error and exit.
        MOV     R6, R1                          ; save the updated strpointer
        MOV     R3, #100
        MUL     R0,R2,R3                        ;R0 is SleepTime in centiseconds
        BL      SWISleepTime                    ; Corrupts some registers
        MOV     R0,R6
        EXITS

DecodeErr
        Pull    "R6,LR"
        ORRS    PC, LR, #V_bit
d81 2
d95 1
a95 2
        AddError        CantFreeze,"CantFreeze"
        AddError        FreezeFailed,"FreezeFailed"
a96 1
        ASSERT          @@ <= (ErrorBase_Portable + ?ErrorBase_Portable)
a99 10
;
; Resources
;
;Path            DCB     "Portable$Path",0
;DefPath         DCB     "Resources:$.Resources.Portable.",0

MessageFile
messagefilename
        DCB     "Resources:$.Resources.Portable.Messages", 0
        ALIGN
d158 13
d177 2
d184 1
a185 2
 [ HWPolling
        STRB    R0, CallEveryFlag
d187 20
a206 16

        STRB    R0, KeyRepeatFlag
        STR     R0, KeyRepeatAction
        STR     R0, KeyRepeatDelay
        STR     R0, KeyRepeatRate

;>>>do I need Path variable stuff?

; open messages file

        wsaddr  R0,MsgTransBlk
        addr    R1,MessageFile
        MOV     R2,#0                           ; no buffer supplied
        SWI     XMessageTrans_OpenFile
        EXIT    VS

d211 2
d217 1
a217 7
;
; Kernel starts in CRT mode but we switch to LCD in !Boot
;
        MOV     R0, #0
        STRB    R0, PaletteMode
        MOV     R0, #&FF
        STRB    R0, DisplayMode
d219 1
a220 1
; Read LCD contrast & brightness settings from CMOS RAM
a221 13
        ASSERT  ContrastTableMaxIndex = 63      ;we allocate 6bits in CMOS
        MOV     R0, #ReadCMOS
        MOV     R1, #ContrastCMOS
        SWI     XOS_Byte                        ;result in R2.b
        MOVVS   R1, #default_LCDContrast
        AND     R1, R2, #2_00111111
        STRB    R1, ContrastIndex

        MOV     R0, #0                          ;Brightness and contrast written simultaneously
        STRB    R0, BrightnessValue             ; to digipot, fudge zero for brightness whilst
        BL      SendContrast                    ; setting contrast

        ASSERT  BrightnessTableMaxIndex = 7     ;we allocate 3bits in CMOS for each
d225 5
a229 8
        MOVVS   R2, #(default_LCDBrightness1 :OR: (default_LCDBrightness2 :SHL: 3)) ;b7 and b6 clear

        AND     R1, R2, #2_11000000             ;b7 lid closure, b6 idle mode inhibit
        STRB    R1, ModeBits

        AND     R1, R2, #7                      ;extract bits 0..2 as one brightness value
        MOV     R2, R2, LSR #3                  ;
        AND     R2, R2, #7                      ;extract bits 3..5 as another brightness value
d235 1
a235 1
        STRB    R2, BrightnessIndex2            ;store lowest value as 'other' value
a237 4
;
; Read Freeze time from CMOS RAM
;
        ASSERT  FreezeTimesMaxIndex = 7
d239 1
a239 1
        MOV     R1, #TimeCMOS
d241 4
a244 17
        MOVVC   R2, R2, LSR #3                  ;
        ANDVC   R2, R2, #7                      ;extract bits 3..5 freeze time
        MOVVS   R2, #default_FreezeTime

        ADRL    R1, FreezeTimes
        LDR     R2, [R1, R2,LSL #2]             ;multiply index by 4 - table of words
        STR     R2, SleepTimerDelay

 [ HWPolling
        BL      ClaimCallEvery
 ]
;
; We currently have no software support for 'machine wake-up by alarm', other than to allow
; external software to program it. We take steps to silence any already triggered alarm to
; ensure that the machine can shutdown/freeze.
;
        BL      KillRTCAlarm                    ;We may have been switched on by the alarm
d261 1
a262 3
        MakeErrorBlock  ModuleBadSWI
        MakeErrorBlock  CantFreeze
        MakeErrorBlock  FreezeFailed
d264 32
a295 1
        LTORG
d313 2
d320 1
a320 1
        MOV     R1, #0                          ; ie with everything powered up
d326 1
a326 1

a329 2
 [ HWPolling
        BL      ReleaseCallEvery
a330 6

; close message file

        wsaddr  R0,MsgTransBlk
        SWI     XMessageTrans_CloseFile

a351 1
    ;    TEQNE   r1, #Service_PostInit
a368 4
    ;    TEQ     r1, #Service_PostInit
    ;    BEQ     Svc_PostInit


d380 4
a383 14

        MOV     R0, #0
        STRB    R0, PaletteVFlag
        STRB    R0, EventVFlag          ; indicate not on EventV (r1 = 0)
        STRB    R0, KeyVFlag
        STRB    R0, SleepTimerFlag
 [ HWPolling
        STRB    R0, CallEveryFlag
 ]

        STRB    R0, KeyRepeatFlag
        STR     R0, KeyRepeatAction
        STR     R0, KeyRepeatDelay
        STR     R0, KeyRepeatRate
d388 1
d391 1
a395 3
 [ HWPolling
        BL      ClaimCallEvery
 ]
d402 32
a433 11
 [ 1 = 0
;
; Svc_PostInit - Issued on a reset after all ROM resident modules have been initialised.
;
; Setup a callback routine to start the LCDisplay.
;
Svc_PostInit
        ENTRY   "R0,R1"
        ADRL    R0, CB_SwitchToLCD
        MOV     R1, R12
        SWI     XOS_AddCallBack
d435 4
a438 1
 ]
d457 5
a461 5
        B       SWIStatus
   ;     B       SWIPortable_Contrast
 [ SwindellCode
        B       SWIRefresh
        B       SWIHalt
a462 1
       ;B       SWISleepTime
a467 1
ModuleTitle ; Share the string
d478 4
a481 5
        =       "Status",0
   ;     =       "Contrast",0
 [ SwindellCode
        =       "Refresh",0
        =       "Halt",0
d488 6
a493 30
 [ SwindellCode
; enter with
; R0 Num refresh cycles
; R1 &03200000
; R2 STOP  data bus pattern
; R3 #&F0  Cas Lo, Ras Hi
; R4 #&FF  Cas Lo, Ras Lo
; R11 return address
;
SWIRefresh
        STRB R3, [R1,#&D4]      ; Cas Lo, Ras Hi
        STRB R4, [R1,#&D4]      ; Cas Lo, Ras Lo   CBR self refresh
SWIHalt
stop
        STR  R2, [R1,#&2C]      ; STOP data bus driven by Wr data
; stop until wake up event
        STRB R3, [R1,#&D4]      ; Cas Lo, Ras Hi   End self refresh
        MOV  R5, R0             ; get loop length into loop counter
refresh
        STRB R4, [R1,#&D4]      ; Cas Lo, Ras Lo   CBR Refresh
        STRB R3, [R1,#&D4]      ; Cas Lo, Ras Hi
        SUBS R5, R5, #1
        BNE  refresh
        STRB R5, [R1,#&D4]      ; Cas Hi, Ras Hi (R5=0)

        LDR R6, [R1,#&70]       ; irqD status, check if woken by event 2 if so go back to stop
        TST R6, #&08            ; was it event1, if not then must be event2 so stop again
        BEQ stop                ; stop again if event1=0
        BICS    PC,LR,#V_bit    ; jump back to application code
 ]
a496 8
SWIUnknown
SWISpeed
        Push    "r4,lr"
        ADR     r0, ErrorBlock_ModuleBadSWI
        ADR     r4, ModuleTitle
        BL      ErrorLookup1Parm
        Pull    "r4,pc"

d503 1
a503 1
;   R1  = bit 4 set to indicate SWI Portable_Idle is impletemted
d506 1
a506 1
; All other bits in R1 zeroed, all other registers preserved.
d524 3
a526 2
       ;DLINE   "SWIIdle"

d530 14
a543 1

d555 6
a560 6
;
; Exit
;   R0  = restart code, 1-keyboard interrupt
;                       2-RTC interrupt         (NYA)
;
SWIStop ENTRY   "R0-R9"        
a562 10
        MOV     R1, #Service_Portable           ;Send a service call round indicating
        MOV     R2, #ServicePortable_FreezeRequest      ;that we would like to freeze
        SWI     XOS_ServiceCall
        CMP     R1, #0                          ;If service call is claimed, someone objects
        BEQ     TooHotToFreeze                  ; eg BatMgr wants to stay alive whilst cycling the battery

        MOV     R1, #Service_Portable           ;Send a service call round indicating
        MOV     R2, #ServicePortable_Freeze     ; that we are entering freeze mode
        SWI     XOS_ServiceCall                 ;

d576 3
d580 1
a580 5
; turn IRQ's and FIQ's off to prevent things turning back on
;
        TEQP    PC, #SVC_mode + I_bit + F_bit
;
; shutdown the sound system
d582 2
d590 1
a590 3
;
; blank the screen
;
a596 28
; call Portable_Control to powerdown floppies/econet/serial etc
;
        MOV     R0, #0                          ;Now try turning off as much off as possible,
        LDR     r1, =:NOT: Shutdown1Bits        ; serial, parallel and FDC etc
        BL      SWIControl                      ; NB this call does send power-down messages.
        MOVVS   R7, #4
        BVS     fail_4

        LDR     R0, =Shutdown1Bits              ;Consider the items we tried to turn off.
        AND     R1, R1, R0
;
; Ignore any failure of the parallel or serial ports to shutdown.
; We call SetPwrState directly later on to force them off.
;
        LDR     R0, =(PortableControl_SerialEnable :OR: PortableControl_ParallelEnable)
        BICS    R1, R1, R0
        MOVNE   R7, #5                          ;NE, something refused to shutdown
        BNE     fail_5

;>>>if serial or parallel failed to shutdown, call SetPwrState directly to shut them down
;
;>>>on wake up call SetPwrState or Portable_Control to power them back up. Which should we
;>>>use? ie do we want a power up message to go round for them.
;
;>>>Use of a second call allows us to put mouse & lcd asleep once we know we are actually
;>>>going to succeed.

;
d599 1
d602 2
a603 2
        MOVNE   R7, #6                          ;NE, battery manager busy (interupted SendPowerCommand)
        BNE     fail_6
d607 2
a608 2
        MOVNE   R7, #6                          ;NE, battery manager busy (processing an earlier Power or Keyboard command)
        BNE     fail_6
d613 1
d616 1
a616 1
; Force remaining units to shutdown ie serial, parallel, trackerball, mouse etc
d618 1
a618 29
        LDR     R0, ConfigExtraBitsCopy         ;R0  = current state
        LDR     R1, =Shutdown2Bits
        BIC     R1, R0, R1                      ;R1  = required state
        BL      SetPwrState                     ;Force required state, NB ConfigExtraBitsCopy
                                                ; unaltered for later restoration
;
; Write &FF to HWLatchMC to save power, SCLatchMC untouched, for later restoration.
;
        MOV     R0, #&FF
        LDR     R1, =HWLatchMC
        STRB    R0, [R1]
;
; Set IIC clock and data lines low.
;
        MOV     R0, #0
        BL      SetIIC

 [ 1=1
        MOV     R4, #paletteV_VIDCDisable
        MOV     R9, #PaletteV
        SWI     XOS_CallAVector
 ]

        ADR     R14, StopTab
05
        LDMIA   R14!, {R0, R1}                  ;address, data
        TEQ     R0, #0
        STRNE   R1, [R0]
        BNE     %BT05
a624 13
        MOV     R1, #0                          ;Useful value

        LDRB    R0, [R8, #IOMD_VIDCR]
        STRB    R0, holdVIDCR
        STRB    R1, [R8, #IOMD_VIDCR]

        LDRB    R0, [R8, #IOMD_SD0CR]
        STRB    R0, holdSD0CR
        STRB    R1, [R8, #IOMD_SD0CR]

        LDRB    R0, [R8, #IOMD_ATODICR]
        STRB    R0, holdATODICR
        STRB    R1, [R8, #IOMD_ATODICR]
d629 1
a629 7
        ASSERT  HWLatchMC = (IOMD_Base + IOMD_CLINES)
        LDRB    R1, [R8, #IOMD_CLINES]          ;iop3 pulled low for slow-refresh
        TST     R1, #08
        BEQ     StopWithSlowRefresh

StopWithSelfRefresh
        BL      BurstRefresh
a644 2
        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;raise RAS (CAS lines still low)
a647 1
        BL      BurstRefresh
d649 24
a672 11
        B       RestoreRegs
;
;
;
StopWithSlowRefresh
        BL      BurstRefresh                    ;Refresh the DRAM before entering/reentering STOP mode
;
; Stop the processor
;
        MOV     R1, #&FFFFFFFF
        STR     R1, [R8, #IOMD_STOPMODE]
d676 2
a677 3
        LDRB    R1, [R8, #IOMD_IRQSTD]  ; irqD status, check if woken by event 2 if so go back to stop
        TST     R1, #IOMD_Nevent1_bit   ; was it event1, if not then must be event2 so stop again
        BEQ     StopWithSlowRefresh     ; stop again if event1=0
d679 5
a683 1
        BL      BurstRefresh                    ;Refresh the DRAM before reawakening the machine
a684 4
;
; Bring the machine back to life
;
RestoreRegs
d686 1
d688 6
a693 9

        LDRB    R1, holdVIDCR
        STRB    R1, [R8, #IOMD_VIDCR]

        LDRB    R1, holdSD0CR
        STRB    R1, [R8, #IOMD_SD0CR]

        LDRB    R1, holdATODICR
        STRB    R1, [R8, #IOMD_ATODICR]
a696 18
 [ 1=1
        ADR     R14, StartTab
55
        LDMIA   R14!, {R0, R1}                  ;address, data
        TEQ     R0, #0
        STRNE   R1, [R0]
        BNE     %BT55
 ]

        MOV     R4, #paletteV_VIDCRestore
        MOV     R9, #PaletteV
        SWI     XOS_CallAVector

;
; Restore IIC clock and data lines to high.
;
        MOV     R0, #(i2c_clock_bit :OR: i2c_data_bit)
        BL      SetIIC
d698 2
a699 1
; Restore HWLatchMC - we set it to &FF to save power
d701 1
a701 31
        LDRB    R0, SCLatchMC                   ;Load soft copy
        LDR     R1, =HWLatchMC                  ;
        STRB    R0, [R1]                        ; and write to the port
;
; Restore state of serial, parallel etc
;
        LDR     R1, ConfigExtraBitsCopy
        BL      SetPwrState

        MOV     R0, #0                          ;Update RTC soft copy
        SWI     XOS_ResyncTime
;
;>>>determine cause of wakeup
;
;;;        MOV     R2, #PwrCmd_Send_input_signals
;;;        BL      SendPowerCommand
;;;        TST  R2, #

        MOV     R0, #1                          ;The only restart mechanism currently supported!
        STR     R0, [SP]                        ;overwrite stack R0

        BL      ClearRTCAlarm                   ;We may have been switched on by the alarm

        MOV     R7, #0                          ;Failure indication, set to OK
;
;
fail_6  ;Problem talking to microcontroller

fail_5
fail_4  ;Problem powering down floppy or winnie

d712 2
a713 110
       ;SWI     XOS_WriteI + 7
;
; If R7 <> 0 it indicates an error occurred
;

;
;>>>send unfreeze service call here???
;
; could copy R7 into R3 to indicate success
        MOV     R1, #Service_Portable           ;Send a service call round indicating
        MOV     R2, #ServicePortable_Unfreeze   ; that we are exiting Portable_Stop
        MOV     R3, R7
        SWI     XOS_ServiceCall

        CMP     R7, #0
        ADRNE   R0,ErrorBlock_FreezeFailed
        BLNE    ErrorLookupNoParms              ;If called, will set V
        STRVS   R0, [SP]                         ; overwrite stack R0
        PullEnv
        BICVCS  PC,LR,#V_bit
        ORRVSS  PC,LR,#V_bit                    ;Exit
;
;>>>what about R0 - restart reason code???
;


TooHotToFreeze
        addr    R0,ErrorBlock_CantFreeze        ; error, R0 -> tokenised error block
        BL      ErrorLookupNoParms
        STR     R0,[SP]                         ; overwrite stack R0
        PullEnv
        ORRS    PC,LR,#V_bit



;HWLatchPA  2_00000000
;HWLatchPB  2_00001000
;HWLatchMC  2_11111111
;HWLatchMA  2_00000000

StopTab
   ;     DCD     &83400000, &C0000003    ;dac off, ereg set to external LUT
   ;     DCD     &83400000, &D0004000    ;Vclk off, Pcomp=0
   ;     DCD     &83400000, &E0004049    ;PoDown, Hclk
        DCD     &83400000, &B1000001    ;sound Dac off, serial (16bit) sound off
        DCD     &88000000, &FFFFFFFF    ;buffered data bus
        DCD     0

StartTab
        DCD     &83400000, &B1000003    ;sound Dac off, serial (16bit) sound on, 24Mhz ref. clock
        DCD     0


;
; NB Must NOT read/write from/to DRAM (which includes the stack)
;
BurstRefresh
        MOV     R0, #1024
77
;
; One CAS before RAS refresh cycle
;
        MOV     R1, #0
        STRB    R1, [R8, #IOMD_SELFREF]         ;CAS and RAS high
        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;force CAS lines low
        MOV     R1, #&FF
        STRB    R1, [R8, #IOMD_SELFREF]         ;force CAS and RAS lines low

        MOV     R1, #&FF
        STRB    R1, [R8, #IOMD_SELFREF]         ;CAS and RAS lines (still) low

        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;raise RAS (CAS lines still low)
        MOV     R1, #0
        STRB    R1, [R8, #IOMD_SELFREF]         ;return CAS and RAS lines to normal use

        SUBS    R0, R0, #1
        BGT     %BT77

        MOVS    PC, LR


;
; SetIIC Based on SetC1C0 from IIC.s.IICMod
;
; Set the state of the IIC clock and data lines
;
; Entry
;   R0 bits i2c_clock_bit and i2c_data_bit set to required levels
;
SetIIC
        ENTRY   "R0-R2"
        ORR     R14, R14, #I_bit                ; disable interrupts round access to IOCControlSoftCopy
        TEQP    R14, #0

        AND     R0, R0, #(i2c_clock_bit :OR: i2c_data_bit)

        MOV     R2, #0                          ; prepare to index soft copy
        LDRB    R1, [R2, #IOCControlSoftCopy]   ; read soft copy

        BIC     R1, R1, #(i2c_clock_bit :OR: i2c_data_bit)      ; clear clock and data
        ORR     R1, R1, R0                      ; put in new clock and data
        ORR     R1, R1, #&C0                    ; make sure two test bits are
                                                ; always set to 1 !
        STRB    R1, [R2, #IOCControlSoftCopy]   ; store back to soft copy

        MOV     R2, #IOC
        STRB    R1, [R2, #IOCControl]

d716 5
a722 12
;
; SWI Portable_Status - Return status of connected devices.
;
; Exit
;   R0  = bit 0 set to indicate docking station connected
;         bit 1 set to indicate floppy connected
;     NYA bit 2 set to indicate internal tracker ball connected
;         bit 3 set to indicate internal (LCD) display in use
;
SWIStatus
        ENTRY   "R1"
        MOV     R0, #0
d724 3
a726 9
        LDR     R1, =HWLatchPB + 4              ;Read PCMCIA portB (+4 cos split register)
        LDRB    R1, [R1]                        ;
        TST     R1, #1                          ; examine docins* bit (negative logic)
        ORRNE   R0, R0, #PortableStatus_DocStationConnected ;1

        LDR     R1, =HWLatchPA + 4              ;Read PCMCIA portA (+4 cos split register)
        LDRB    R1, [R1]                        ;
        TST     R1, #2_00100000                 ; examine PrinterNotFloppy bit
        ORRNE   R0, R0, #PortableStatus_PrinterFloppy   ;2
d728 29
a756 3
        LDRB    R1, DisplayMode
        TEQ     R1, #0
        ORRNE   R0, R0, #8
d761 13
a773 1
;******************************************************************************
d775 1
a775 3
SWISleepTime    ENTRY
        STR     R0, SleepTimerDelay     ;>>>should we restart any existing
        EXITS                           ;>>>screen blank/sleep timer???
d777 2
a804 1

d829 1
a829 2

;******************************************************************************
d846 1
a846 2

;******************************************************************************
d866 1
a866 2

;******************************************************************************
d883 1
a883 1
;******************************************************************************
d903 1
a903 2

;******************************************************************************
a918 8
        ASSERT  paletteV_DimScreen = 11
 [ 1 = 1
PaletteVHandler ENTRY "r0-r3"
        CMP     r4, #paletteV_BlankScreen
        BEQ     PV_BlankUnblank
        CMP     r4, #paletteV_DimScreen
        BEQ     PV_DimUndim
        EXITS
a919 5
ClaimExit
        MOV     r4, #0
        PullEnv
        Pull    pc
 |
a945 1
 ]
d966 1
a967 40
        EXITS   ;NB registers pushed by PaletteVHandler

 [ 1 = 1
;******************************************************************************
;
;       PV_DimUndim - Dim/undim screen
;
; in:   r0 = -1 (read dim state)
;          or 0 (undim screen)
;          or 1 (dim screen)
;       r0-r3, lr already pushed
;
; out:  r0 = old state (0=undimmed, 1=dimmed)
;       r4 = 0 => operation complete
;

PV_DimUndim ROUT
        LDRB    R2, BrightnessIndex1            ;NB load order swapped! (reduces code later)
        LDRB    R1, BrightnessIndex2
        CMP     R2, R1
        MOVLT   R3, #1                          ;dim
        MOVGE   R3, #0                          ;bright
        STR     R3, [sp]                        ; return old state in R0 (on stack)

        CMP     R0, #1
        BHI     ClaimExit                       ;HI, reading only

        CMP     R3, R0
        BEQ     ClaimExit                       ;EQ already in requested state

        LDRB    R3, BrightnessHold              ;NE not in requested state
        TEQ     R3, #1                          ;
        BEQ     ClaimExit                       ;EQ leave screen dim, cos user set it so
;^^^merge above
       ;LDRB    R2, BrightnessIndex1            ;NB Swap values
       ;LDRB    R1, BrightnessIndex2            ; (final store of R1 into BrightnessIndex1
        STRB    R2, BrightnessIndex2            ;  performed by subroutine)
        BL      SetBrightness                   ;In R1=brightness value
        B       ClaimExit                       ;finish
 ]
a998 1

d1022 1
a1022 1
        ADRL    r0, ConfigureRepeatCommand
d1037 1
a1037 1
        ADRL    r0, BlankTimeCommand
a1085 5
;
; Set 'bright' and 'dim' brightness levels, 'idle mode inhibit' and 'lid closure'
; Pack 'current' into bits 0..2 and 'other' into bits 3..5
;
        MOV     R2, #(default_LCDBrightness1 :OR: (default_LCDBrightness2 :SHL: 3))
a1086 16
        MOVVC   R0, #WriteCMOS
        MOVVC   R1, #BrightnessCMOS
        SWIVC   XOS_Byte
;
; Set contrast level
;
        MOV     R0, #ReadCMOS
        MOV     R1, #ContrastCMOS
        SWI     XOS_Byte                        ;result in R2.b

        BICVC   R2, R2, #2_00111111
        ORRVC   R2, R2, #default_LCDContrast

        MOVVC   R0, #WriteCMOS
        MOVVC   R1, #ContrastCMOS
        SWIVC   XOS_Byte
d1088 2
a1089 16
; Set 'screen dim time' and 'freeze time' values
; Pack 'screen dim time' into bits 0..2 and 'freeze time' into bits 3..5
;
        MOV     R0, #ReadCMOS
        MOV     R1, #TimeCMOS
        SWI     XOS_Byte                        ;result in R2.b

        BICVC   R2, R2, #2_00111111             ;clear both time values
        ORRVC   R2, R2, #(default_DimTime :OR: (default_FreezeTime :SHL: 3))

        MOVVC   R0, #WriteCMOS
        MOVVC   R1, #TimeCMOS
        SWIVC   XOS_Byte

;>>>set MonitorType of 7 (or should it be 8???) for LCD

d1136 1
a1136 5
; StartSleepTimer - called when screen blanks (ie paletteV_BlankScreen)
;
; We define BlankTime and FreezeTime as starting when the user last pressed a key or moved
; the mouse. Since this routine is called at the expiry of the screen blank timer, we must
; subtract the BlankTime from FreezeTime to give the time remaining before freezing.
d1143 1
a1143 1
        EXITS   NE                              ;NE, reentry, no action required
a1145 18
        TEQ     R0, #0
        EXITS   EQ                              ;EQ, freeze timer switched off

 [ 1 = 1
        MOV     R0, #ScreenBlankerReason_ReadTimeout2
        SWI     XScreenBlanker_Control          ;Returns: R0 corrupted, R1=blanking delay (centi-seconds)
        MOVVS   R1, #0
 |
        MOV     R0, #ScreenBlankerReason_ReadTimeout
        SWI     XScreenBlanker_Control          ;Returns: R0 corrupted, R1=blanking delay (seconds)
        MOVVS   R1, #0                          ;despite what the documentation says, R1 is in seconds
        MLA     R1, R1, #100                    ;convert to centi-seconds
 ]
        LDR     R0, SleepTimerDelay             ;sleep time delay
        SUB     R0, R0, R1                      ;calculate time remaining
        CMP     R0, #50                         ;If FreezeTime <= BlankTime
        MOVLT   R0, #50                         ; then switch off now (almost)

a1174 6
        ADR     R0, SleepTimerCallBack
        MOV     R1, R12
        SWI     XOS_AddCallBack
        EXITS

SleepTimerCallBack ENTRY "R0-R2"
d1177 1
a1177 1

d1184 1
a1184 1
; Aside: XPortable_Stop calls Screen blanker to blank the screen (it happens to be blanked).
a1188 48

FreezeTimes
        DCD     0               ;Off
        DCD     60*100          ; 1 minute
        DCD     2*60*100        ; 2 minutes
        DCD     5*60*100        ; 5 minutes
        DCD     10*60*100       ;10 minutes
        DCD     15*60*100       ;15 minutes
        DCD     30*60*100       ;30 minutes
        DCD     60*60*100       ;60 minutes
FreezeTimesMaxIndex * ((. - FreezeTimes)/4 - 1)
        ASSERT  FreezeTimesMaxIndex = 7

        ASSERT  default_FreezeTime <= FreezeTimesMaxIndex

;******************************************************************************

; KillRTCAlarm  - Cancel alarm completely on module startup.
;
; ClearRTCAlarm - Clear any previously flagged alarm prior to freeze/shutdown.
;
KillRTCAlarm
        Push    "R0-R2,LR"
        MOV     R0, #IICAddress_AcornRTC
        ADR     R1, IICBlk_2
        MOV     R2, #2
        SWI     XIIC_Control
        Pull    "R0-R2,LR"                      ;drop into...

ClearRTCAlarm
        Push    "R0-R2,LR"
        MOV     R0, #IICAddress_AcornRTC
        ADR     R1, IICBlk_1
        MOV     R2, #2
        SWI     XIIC_Control
        Pull    "R0-R2,PC",,^                   ;drop into...

IICBlk_1
        DCB     0       ;Control/status register
        DCB     &04     ; Alarm enable bit=1 (alarm active), stops RTC interrupt line pulsing
                        ; at 1Hz, also clears alarm flag (bit1)

IICBlk_2
        DCB     8       ;Alarm control register
        DCB     &00     ; all alarms and timers off

        ALIGN

@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d15 1
a15 1
        TTL     Source.StPortable
a37 5
 [ International_Help <> 0
        DCD     messagefilename - Module_BaseAddr
 |
        DCD     0
 ]
d46 1
a46 2
Command
        DCB     "FreezeTime", 0
d48 2
a49 2
        DCD     SleepTimeCmd - Module_BaseAddr
        DCD     &0001FF00:OR:International_Help
d55 1
a55 1
SleepTimeHlp    DCB     "*FreezeTime (seconds) sets the delay before an idle machine enters freeze mode.", 13
d57 2
a58 2
                DCB     "To turn off use *FreezeTime 0", 13
SleepTimeSyn    DCB     "Syntax: *FreezeTime [Time]", 0
d61 1
a61 1
        DCB     "HSCSLP", 0
d63 1
a63 1
        DCB     "SSCSLP", 0
d68 6
a73 2
SleepTimeCmd    ENTRY
        LDR     R12, [R12]                      ;get workspace pointer
d75 2
a76 2
        TEQ     R1, #0
        BEQ     SleepTimeNoParams
a77 9
SleepTimeLoop
        LDRB    R1, [R0]                        ;check for end
        CMP     R1, #32                         ;and chop off leading spaces.
        ADDEQ   R0, R0, #1
        BEQ     SleepTimeLoop
        EXITS   LT                              ;exit if control-char.
        BL      DecodeParam 
        BVC     SleepTimeLoop
        EXIT                                    ;return V set
d79 1
a79 53
SleepTimeNoParams
;;;;        BL      openmsgfile
;;;;        EXIT    VS

        LDR     R0, SleepTimerDelay
        TEQ     R0, #0
        ADREQ   R1,SleepOff
        ADRNE   R1,StrBuff
        MOVNE   R2,#StrBuffLen
        SWINE   XOS_BinaryToDecimal
        SUBNE   R2, R2, #2              ; convert to seconds (sort of)
        MOVNE   R4,R1
        MOVNE   r0, #0
        STRNEB  r0, [r4, r2]
        MOVNE   R1,R2
        ADRNE   R1,SleepTim

        SUB     sp, sp, #80

        wsaddr  R0, MsgTransBlk

        MOVVC   r2, sp
        MOVVC   r3, #80
        SWIVC   XMessageTrans_Lookup
        MOVVC   r0, r2
        SWIVC   XOS_Write0
        ADD     sp, sp, #80

        SWIVC   XOS_NewLine

        EXIT

SleepOff DCB    "SleepOff", 0
SleepTim DCB    "SleepTm", 0
                ALIGN


DecodeParam ENTRY "R6"
        MOV     R1, R0                          ;move strpointer to R1
        MOV     R0, #(1<<29)                    ;check  0<=R2<=2^18 (ca. 3 days)
        MOV     R2, #(1<<18)                    ;restrict to moderate positive int
        SWI     XOS_ReadUnsigned
        BVS     DecodeErr                       ;print error and exit.
        MOV     R6, R1                          ; save the updated strpointer
        MOV     R3, #100
        MUL     R0,R2,R3                        ;R0 is SleepTime in centiseconds
        BL      SWISleepTime                    ; Corrupts some registers
        MOV     R0,R6
        EXITS

DecodeErr
        Pull    "R6,LR"
        ORRS    PC, LR, #V_bit
d81 2
d95 1
a95 2
        AddError        CantFreeze,"CantFreeze"
        AddError        FreezeFailed,"FreezeFailed"
a96 1
        ASSERT          @@ <= (ErrorBase_Portable + ?ErrorBase_Portable)
a99 10
;
; Resources
;
;Path            DCB     "Portable$Path",0
;DefPath         DCB     "Resources:$.Resources.Portable.",0

MessageFile
messagefilename
        DCB     "Resources:$.Resources.Portable.Messages", 0
        ALIGN
d158 13
d177 2
d184 1
a185 2
 [ HWPolling
        STRB    R0, CallEveryFlag
d187 20
a206 16

        STRB    R0, KeyRepeatFlag
        STR     R0, KeyRepeatAction
        STR     R0, KeyRepeatDelay
        STR     R0, KeyRepeatRate

;>>>do I need Path variable stuff?

; open messages file

        wsaddr  R0,MsgTransBlk
        addr    R1,MessageFile
        MOV     R2,#0                           ; no buffer supplied
        SWI     XMessageTrans_OpenFile
        EXIT    VS

d211 2
d217 1
a217 7
;
; Kernel starts in CRT mode but we switch to LCD in !Boot
;
        MOV     R0, #0
        STRB    R0, PaletteMode
        MOV     R0, #&FF
        STRB    R0, DisplayMode
d219 1
a220 1
; Read LCD contrast & brightness settings from CMOS RAM
a221 13
        ASSERT  ContrastTableMaxIndex = 63      ;we allocate 6bits in CMOS
        MOV     R0, #ReadCMOS
        MOV     R1, #ContrastCMOS
        SWI     XOS_Byte                        ;result in R2.b
        MOVVS   R1, #default_LCDContrast
        AND     R1, R2, #2_00111111
        STRB    R1, ContrastIndex

        MOV     R0, #0                          ;Brightness and contrast written simultaneously
        STRB    R0, BrightnessValue             ; to digipot, fudge zero for brightness whilst
        BL      SendContrast                    ; setting contrast

        ASSERT  BrightnessTableMaxIndex = 7     ;we allocate 3bits in CMOS for each
d225 5
a229 8
        MOVVS   R2, #(default_LCDBrightness1 :OR: (default_LCDBrightness2 :SHL: 3)) ;b7 and b6 clear

        AND     R1, R2, #2_11000000             ;b7 lid closure, b6 idle mode inhibit
        STRB    R1, ModeBits

        AND     R1, R2, #7                      ;extract bits 0..2 as one brightness value
        MOV     R2, R2, LSR #3                  ;
        AND     R2, R2, #7                      ;extract bits 3..5 as another brightness value
d235 1
a235 1
        STRB    R2, BrightnessIndex2            ;store lowest value as 'other' value
a237 4
;
; Read Freeze time from CMOS RAM
;
        ASSERT  FreezeTimesMaxIndex = 7
d239 1
a239 1
        MOV     R1, #TimeCMOS
d241 4
a244 17
        MOVVC   R2, R2, LSR #3                  ;
        ANDVC   R2, R2, #7                      ;extract bits 3..5 freeze time
        MOVVS   R2, #default_FreezeTime

        ADRL    R1, FreezeTimes
        LDR     R2, [R1, R2,LSL #2]             ;multiply index by 4 - table of words
        STR     R2, SleepTimerDelay

 [ HWPolling
        BL      ClaimCallEvery
 ]
;
; We currently have no software support for 'machine wake-up by alarm', other than to allow
; external software to program it. We take steps to silence any already triggered alarm to
; ensure that the machine can shutdown/freeze.
;
        BL      KillRTCAlarm                    ;We may have been switched on by the alarm
d261 1
a262 3
        MakeErrorBlock  ModuleBadSWI
        MakeErrorBlock  CantFreeze
        MakeErrorBlock  FreezeFailed
d264 32
a295 1
        LTORG
d313 2
d320 1
a320 1
        MOV     R1, #0                          ; ie with everything powered up
d326 1
a326 1

a329 2
 [ HWPolling
        BL      ReleaseCallEvery
a330 6

; close message file

        wsaddr  R0,MsgTransBlk
        SWI     XMessageTrans_CloseFile

a351 1
    ;    TEQNE   r1, #Service_PostInit
a368 4
    ;    TEQ     r1, #Service_PostInit
    ;    BEQ     Svc_PostInit


d380 4
a383 14

        MOV     R0, #0
        STRB    R0, PaletteVFlag
        STRB    R0, EventVFlag          ; indicate not on EventV (r1 = 0)
        STRB    R0, KeyVFlag
        STRB    R0, SleepTimerFlag
 [ HWPolling
        STRB    R0, CallEveryFlag
 ]

        STRB    R0, KeyRepeatFlag
        STR     R0, KeyRepeatAction
        STR     R0, KeyRepeatDelay
        STR     R0, KeyRepeatRate
d388 1
d391 1
a395 3
 [ HWPolling
        BL      ClaimCallEvery
 ]
d402 32
a433 11
 [ 1 = 0
;
; Svc_PostInit - Issued on a reset after all ROM resident modules have been initialised.
;
; Setup a callback routine to start the LCDisplay.
;
Svc_PostInit
        ENTRY   "R0,R1"
        ADRL    R0, CB_SwitchToLCD
        MOV     R1, R12
        SWI     XOS_AddCallBack
d435 4
a438 1
 ]
d457 5
a461 5
        B       SWIStatus
   ;     B       SWIPortable_Contrast
 [ SwindellCode
        B       SWIRefresh
        B       SWIHalt
a462 1
       ;B       SWISleepTime
a467 1
ModuleTitle ; Share the string
d478 4
a481 5
        =       "Status",0
   ;     =       "Contrast",0
 [ SwindellCode
        =       "Refresh",0
        =       "Halt",0
d488 6
a493 30
 [ SwindellCode
; enter with
; R0 Num refresh cycles
; R1 &03200000
; R2 STOP  data bus pattern
; R3 #&F0  Cas Lo, Ras Hi
; R4 #&FF  Cas Lo, Ras Lo
; R11 return address
;
SWIRefresh
        STRB R3, [R1,#&D4]      ; Cas Lo, Ras Hi
        STRB R4, [R1,#&D4]      ; Cas Lo, Ras Lo   CBR self refresh
SWIHalt
stop
        STR  R2, [R1,#&2C]      ; STOP data bus driven by Wr data
; stop until wake up event
        STRB R3, [R1,#&D4]      ; Cas Lo, Ras Hi   End self refresh
        MOV  R5, R0             ; get loop length into loop counter
refresh
        STRB R4, [R1,#&D4]      ; Cas Lo, Ras Lo   CBR Refresh
        STRB R3, [R1,#&D4]      ; Cas Lo, Ras Hi
        SUBS R5, R5, #1
        BNE  refresh
        STRB R5, [R1,#&D4]      ; Cas Hi, Ras Hi (R5=0)

        LDR R6, [R1,#&70]       ; irqD status, check if woken by event 2 if so go back to stop
        TST R6, #&08            ; was it event1, if not then must be event2 so stop again
        BEQ stop                ; stop again if event1=0
        BICS    PC,LR,#V_bit    ; jump back to application code
 ]
a496 8
SWIUnknown
SWISpeed
        Push    "r4,lr"
        ADR     r0, ErrorBlock_ModuleBadSWI
        ADR     r4, ModuleTitle
        BL      ErrorLookup1Parm
        Pull    "r4,pc"

d503 1
a503 1
;   R1  = bit 4 set to indicate SWI Portable_Idle is impletemted
d506 1
a506 1
; All other bits in R1 zeroed, all other registers preserved.
d524 3
a526 2
       ;DLINE   "SWIIdle"

d530 14
a543 1

d555 6
a560 6
;
; Exit
;   R0  = restart code, 1-keyboard interrupt
;                       2-RTC interrupt         (NYA)
;
SWIStop ENTRY   "R0-R9"        
a562 10
        MOV     R1, #Service_Portable           ;Send a service call round indicating
        MOV     R2, #ServicePortable_FreezeRequest      ;that we would like to freeze
        SWI     XOS_ServiceCall
        CMP     R1, #0                          ;If service call is claimed, someone objects
        BEQ     TooHotToFreeze                  ; eg BatMgr wants to stay alive whilst cycling the battery

        MOV     R1, #Service_Portable           ;Send a service call round indicating
        MOV     R2, #ServicePortable_Freeze     ; that we are entering freeze mode
        SWI     XOS_ServiceCall                 ;

d576 3
d580 1
a580 5
; turn IRQ's and FIQ's off to prevent things turning back on
;
        TEQP    PC, #SVC_mode + I_bit + F_bit
;
; shutdown the sound system
d582 2
d590 1
a590 3
;
; blank the screen
;
a596 28
; call Portable_Control to powerdown floppies/econet/serial etc
;
        MOV     R0, #0                          ;Now try turning off as much off as possible,
        LDR     r1, =:NOT: Shutdown1Bits        ; serial, parallel and FDC etc
        BL      SWIControl                      ; NB this call does send power-down messages.
        MOVVS   R7, #4
        BVS     fail_4

        LDR     R0, =Shutdown1Bits              ;Consider the items we tried to turn off.
        AND     R1, R1, R0
;
; Ignore any failure of the parallel or serial ports to shutdown.
; We call SetPwrState directly later on to force them off.
;
        LDR     R0, =(PortableControl_SerialEnable :OR: PortableControl_ParallelEnable)
        BICS    R1, R1, R0
        MOVNE   R7, #5                          ;NE, something refused to shutdown
        BNE     fail_5

;>>>if serial or parallel failed to shutdown, call SetPwrState directly to shut them down
;
;>>>on wake up call SetPwrState or Portable_Control to power them back up. Which should we
;>>>use? ie do we want a power up message to go round for them.
;
;>>>Use of a second call allows us to put mouse & lcd asleep once we know we are actually
;>>>going to succeed.

;
d599 1
d602 2
a603 2
        MOVNE   R7, #6                          ;NE, battery manager busy (interupted SendPowerCommand)
        BNE     fail_6
d607 2
a608 2
        MOVNE   R7, #6                          ;NE, battery manager busy (processing an earlier Power or Keyboard command)
        BNE     fail_6
d613 1
d616 1
a616 1
; Force remaining units to shutdown ie serial, parallel, trackerball, mouse etc
d618 1
a618 29
        LDR     R0, ConfigExtraBitsCopy         ;R0  = current state
        LDR     R1, =Shutdown2Bits
        BIC     R1, R0, R1                      ;R1  = required state
        BL      SetPwrState                     ;Force required state, NB ConfigExtraBitsCopy
                                                ; unaltered for later restoration
;
; Write &FF to HWLatchMC to save power, SCLatchMC untouched, for later restoration.
;
        MOV     R0, #&FF
        LDR     R1, =HWLatchMC
        STRB    R0, [R1]
;
; Set IIC clock and data lines low.
;
        MOV     R0, #0
        BL      SetIIC

 [ 1=1
        MOV     R4, #paletteV_VIDCDisable
        MOV     R9, #PaletteV
        SWI     XOS_CallAVector
 ]

        ADR     R14, StopTab
05
        LDMIA   R14!, {R0, R1}                  ;address, data
        TEQ     R0, #0
        STRNE   R1, [R0]
        BNE     %BT05
a624 13
        MOV     R1, #0                          ;Useful value

        LDRB    R0, [R8, #IOMD_VIDCR]
        STRB    R0, holdVIDCR
        STRB    R1, [R8, #IOMD_VIDCR]

        LDRB    R0, [R8, #IOMD_SD0CR]
        STRB    R0, holdSD0CR
        STRB    R1, [R8, #IOMD_SD0CR]

        LDRB    R0, [R8, #IOMD_ATODICR]
        STRB    R0, holdATODICR
        STRB    R1, [R8, #IOMD_ATODICR]
d629 1
a629 7
        ASSERT  HWLatchMC = (IOMD_Base + IOMD_CLINES)
        LDRB    R1, [R8, #IOMD_CLINES]          ;iop3 pulled low for slow-refresh
        TST     R1, #08
        BEQ     StopWithSlowRefresh

StopWithSelfRefresh
        BL      BurstRefresh
a644 2
        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;raise RAS (CAS lines still low)
a647 1
        BL      BurstRefresh
d649 24
a672 11
        B       RestoreRegs
;
;
;
StopWithSlowRefresh
        BL      BurstRefresh                    ;Refresh the DRAM before entering/reentering STOP mode
;
; Stop the processor
;
        MOV     R1, #&FFFFFFFF
        STR     R1, [R8, #IOMD_STOPMODE]
d676 2
a677 3
        LDRB    R1, [R8, #IOMD_IRQSTD]  ; irqD status, check if woken by event 2 if so go back to stop
        TST     R1, #IOMD_Nevent1_bit   ; was it event1, if not then must be event2 so stop again
        BEQ     StopWithSlowRefresh     ; stop again if event1=0
d679 5
a683 1
        BL      BurstRefresh                    ;Refresh the DRAM before reawakening the machine
a684 4
;
; Bring the machine back to life
;
RestoreRegs
d686 1
d688 6
a693 9

        LDRB    R1, holdVIDCR
        STRB    R1, [R8, #IOMD_VIDCR]

        LDRB    R1, holdSD0CR
        STRB    R1, [R8, #IOMD_SD0CR]

        LDRB    R1, holdATODICR
        STRB    R1, [R8, #IOMD_ATODICR]
a696 18
 [ 1=1
        ADR     R14, StartTab
55
        LDMIA   R14!, {R0, R1}                  ;address, data
        TEQ     R0, #0
        STRNE   R1, [R0]
        BNE     %BT55
 ]

        MOV     R4, #paletteV_VIDCRestore
        MOV     R9, #PaletteV
        SWI     XOS_CallAVector

;
; Restore IIC clock and data lines to high.
;
        MOV     R0, #(i2c_clock_bit :OR: i2c_data_bit)
        BL      SetIIC
d698 2
a699 1
; Restore HWLatchMC - we set it to &FF to save power
d701 1
a701 31
        LDRB    R0, SCLatchMC                   ;Load soft copy
        LDR     R1, =HWLatchMC                  ;
        STRB    R0, [R1]                        ; and write to the port
;
; Restore state of serial, parallel etc
;
        LDR     R1, ConfigExtraBitsCopy
        BL      SetPwrState

        MOV     R0, #0                          ;Update RTC soft copy
        SWI     XOS_ResyncTime
;
;>>>determine cause of wakeup
;
;;;        MOV     R2, #PwrCmd_Send_input_signals
;;;        BL      SendPowerCommand
;;;        TST  R2, #

        MOV     R0, #1                          ;The only restart mechanism currently supported!
        STR     R0, [SP]                        ;overwrite stack R0

        BL      ClearRTCAlarm                   ;We may have been switched on by the alarm

        MOV     R7, #0                          ;Failure indication, set to OK
;
;
fail_6  ;Problem talking to microcontroller

fail_5
fail_4  ;Problem powering down floppy or winnie

d712 2
a713 110
       ;SWI     XOS_WriteI + 7
;
; If R7 <> 0 it indicates an error occurred
;

;
;>>>send unfreeze service call here???
;
; could copy R7 into R3 to indicate success
        MOV     R1, #Service_Portable           ;Send a service call round indicating
        MOV     R2, #ServicePortable_Unfreeze   ; that we are exiting Portable_Stop
        MOV     R3, R7
        SWI     XOS_ServiceCall

        CMP     R7, #0
        ADRNE   R0,ErrorBlock_FreezeFailed
        BLNE    ErrorLookupNoParms              ;If called, will set V
        STRVS   R0, [SP]                         ; overwrite stack R0
        PullEnv
        BICVCS  PC,LR,#V_bit
        ORRVSS  PC,LR,#V_bit                    ;Exit
;
;>>>what about R0 - restart reason code???
;


TooHotToFreeze
        addr    R0,ErrorBlock_CantFreeze        ; error, R0 -> tokenised error block
        BL      ErrorLookupNoParms
        STR     R0,[SP]                         ; overwrite stack R0
        PullEnv
        ORRS    PC,LR,#V_bit



;HWLatchPA  2_00000000
;HWLatchPB  2_00001000
;HWLatchMC  2_11111111
;HWLatchMA  2_00000000

StopTab
   ;     DCD     &83400000, &C0000003    ;dac off, ereg set to external LUT
   ;     DCD     &83400000, &D0004000    ;Vclk off, Pcomp=0
   ;     DCD     &83400000, &E0004049    ;PoDown, Hclk
        DCD     &83400000, &B1000001    ;sound Dac off, serial (16bit) sound off
        DCD     &88000000, &FFFFFFFF    ;buffered data bus
        DCD     0

StartTab
        DCD     &83400000, &B1000003    ;sound Dac off, serial (16bit) sound on, 24Mhz ref. clock
        DCD     0


;
; NB Must NOT read/write from/to DRAM (which includes the stack)
;
BurstRefresh
        MOV     R0, #1024
77
;
; One CAS before RAS refresh cycle
;
        MOV     R1, #0
        STRB    R1, [R8, #IOMD_SELFREF]         ;CAS and RAS high
        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;force CAS lines low
        MOV     R1, #&FF
        STRB    R1, [R8, #IOMD_SELFREF]         ;force CAS and RAS lines low

        MOV     R1, #&FF
        STRB    R1, [R8, #IOMD_SELFREF]         ;CAS and RAS lines (still) low

        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;raise RAS (CAS lines still low)
        MOV     R1, #0
        STRB    R1, [R8, #IOMD_SELFREF]         ;return CAS and RAS lines to normal use

        SUBS    R0, R0, #1
        BGT     %BT77

        MOVS    PC, LR


;
; SetIIC Based on SetC1C0 from IIC.s.IICMod
;
; Set the state of the IIC clock and data lines
;
; Entry
;   R0 bits i2c_clock_bit and i2c_data_bit set to required levels
;
SetIIC
        ENTRY   "R0-R2"
        ORR     R14, R14, #I_bit                ; disable interrupts round access to IOCControlSoftCopy
        TEQP    R14, #0

        AND     R0, R0, #(i2c_clock_bit :OR: i2c_data_bit)

        MOV     R2, #0                          ; prepare to index soft copy
        LDRB    R1, [R2, #IOCControlSoftCopy]   ; read soft copy

        BIC     R1, R1, #(i2c_clock_bit :OR: i2c_data_bit)      ; clear clock and data
        ORR     R1, R1, R0                      ; put in new clock and data
        ORR     R1, R1, #&C0                    ; make sure two test bits are
                                                ; always set to 1 !
        STRB    R1, [R2, #IOCControlSoftCopy]   ; store back to soft copy

        MOV     R2, #IOC
        STRB    R1, [R2, #IOCControl]

d716 5
a722 12
;
; SWI Portable_Status - Return status of connected devices.
;
; Exit
;   R0  = bit 0 set to indicate docking station connected
;         bit 1 set to indicate floppy connected
;     NYA bit 2 set to indicate internal tracker ball connected
;         bit 3 set to indicate internal (LCD) display in use
;
SWIStatus
        ENTRY   "R1"
        MOV     R0, #0
d724 3
a726 9
        LDR     R1, =HWLatchPB + 4              ;Read PCMCIA portB (+4 cos split register)
        LDRB    R1, [R1]                        ;
        TST     R1, #1                          ; examine docins* bit (negative logic)
        ORRNE   R0, R0, #PortableStatus_DocStationConnected ;1

        LDR     R1, =HWLatchPA + 4              ;Read PCMCIA portA (+4 cos split register)
        LDRB    R1, [R1]                        ;
        TST     R1, #2_00100000                 ; examine PrinterNotFloppy bit
        ORRNE   R0, R0, #PortableStatus_PrinterFloppy   ;2
d728 29
a756 3
        LDRB    R1, DisplayMode
        TEQ     R1, #0
        ORRNE   R0, R0, #8
d761 13
a773 1
;******************************************************************************
d775 1
a775 3
SWISleepTime    ENTRY
        STR     R0, SleepTimerDelay     ;>>>should we restart any existing
        EXITS                           ;>>>screen blank/sleep timer???
d777 2
a804 1

d829 1
a829 2

;******************************************************************************
d846 1
a846 2

;******************************************************************************
d866 1
a866 2

;******************************************************************************
d883 1
a883 1
;******************************************************************************
d903 1
a903 2

;******************************************************************************
a918 8
        ASSERT  paletteV_DimScreen = 11
 [ 1 = 1
PaletteVHandler ENTRY "r0-r3"
        CMP     r4, #paletteV_BlankScreen
        BEQ     PV_BlankUnblank
        CMP     r4, #paletteV_DimScreen
        BEQ     PV_DimUndim
        EXITS
a919 5
ClaimExit
        MOV     r4, #0
        PullEnv
        Pull    pc
 |
a945 1
 ]
d966 1
a967 40
        EXITS   ;NB registers pushed by PaletteVHandler

 [ 1 = 1
;******************************************************************************
;
;       PV_DimUndim - Dim/undim screen
;
; in:   r0 = -1 (read dim state)
;          or 0 (undim screen)
;          or 1 (dim screen)
;       r0-r3, lr already pushed
;
; out:  r0 = old state (0=undimmed, 1=dimmed)
;       r4 = 0 => operation complete
;

PV_DimUndim ROUT
        LDRB    R2, BrightnessIndex1            ;NB load order swapped! (reduces code later)
        LDRB    R1, BrightnessIndex2
        CMP     R2, R1
        MOVLT   R3, #1                          ;dim
        MOVGE   R3, #0                          ;bright
        STR     R3, [sp]                        ; return old state in R0 (on stack)

        CMP     R0, #1
        BHI     ClaimExit                       ;HI, reading only

        CMP     R3, R0
        BEQ     ClaimExit                       ;EQ already in requested state

        LDRB    R3, BrightnessHold              ;NE not in requested state
        TEQ     R3, #1                          ;
        BEQ     ClaimExit                       ;EQ leave screen dim, cos user set it so
;^^^merge above
       ;LDRB    R2, BrightnessIndex1            ;NB Swap values
       ;LDRB    R1, BrightnessIndex2            ; (final store of R1 into BrightnessIndex1
        STRB    R2, BrightnessIndex2            ;  performed by subroutine)
        BL      SetBrightness                   ;In R1=brightness value
        B       ClaimExit                       ;finish
 ]
a998 1

d1022 1
a1022 1
        ADRL    r0, ConfigureRepeatCommand
d1037 1
a1037 1
        ADRL    r0, BlankTimeCommand
a1085 5
;
; Set 'bright' and 'dim' brightness levels, 'idle mode inhibit' and 'lid closure'
; Pack 'current' into bits 0..2 and 'other' into bits 3..5
;
        MOV     R2, #(default_LCDBrightness1 :OR: (default_LCDBrightness2 :SHL: 3))
a1086 16
        MOVVC   R0, #WriteCMOS
        MOVVC   R1, #BrightnessCMOS
        SWIVC   XOS_Byte
;
; Set contrast level
;
        MOV     R0, #ReadCMOS
        MOV     R1, #ContrastCMOS
        SWI     XOS_Byte                        ;result in R2.b

        BICVC   R2, R2, #2_00111111
        ORRVC   R2, R2, #default_LCDContrast

        MOVVC   R0, #WriteCMOS
        MOVVC   R1, #ContrastCMOS
        SWIVC   XOS_Byte
d1088 2
a1089 16
; Set 'screen dim time' and 'freeze time' values
; Pack 'screen dim time' into bits 0..2 and 'freeze time' into bits 3..5
;
        MOV     R0, #ReadCMOS
        MOV     R1, #TimeCMOS
        SWI     XOS_Byte                        ;result in R2.b

        BICVC   R2, R2, #2_00111111             ;clear both time values
        ORRVC   R2, R2, #(default_DimTime :OR: (default_FreezeTime :SHL: 3))

        MOVVC   R0, #WriteCMOS
        MOVVC   R1, #TimeCMOS
        SWIVC   XOS_Byte

;>>>set MonitorType of 7 (or should it be 8???) for LCD

d1136 1
a1136 5
; StartSleepTimer - called when screen blanks (ie paletteV_BlankScreen)
;
; We define BlankTime and FreezeTime as starting when the user last pressed a key or moved
; the mouse. Since this routine is called at the expiry of the screen blank timer, we must
; subtract the BlankTime from FreezeTime to give the time remaining before freezing.
d1143 1
a1143 1
        EXITS   NE                              ;NE, reentry, no action required
a1145 18
        TEQ     R0, #0
        EXITS   EQ                              ;EQ, freeze timer switched off

 [ 1 = 1
        MOV     R0, #ScreenBlankerReason_ReadTimeout2
        SWI     XScreenBlanker_Control          ;Returns: R0 corrupted, R1=blanking delay (centi-seconds)
        MOVVS   R1, #0
 |
        MOV     R0, #ScreenBlankerReason_ReadTimeout
        SWI     XScreenBlanker_Control          ;Returns: R0 corrupted, R1=blanking delay (seconds)
        MOVVS   R1, #0                          ;despite what the documentation says, R1 is in seconds
        MLA     R1, R1, #100                    ;convert to centi-seconds
 ]
        LDR     R0, SleepTimerDelay             ;sleep time delay
        SUB     R0, R0, R1                      ;calculate time remaining
        CMP     R0, #50                         ;If FreezeTime <= BlankTime
        MOVLT   R0, #50                         ; then switch off now (almost)

a1174 6
        ADR     R0, SleepTimerCallBack
        MOV     R1, R12
        SWI     XOS_AddCallBack
        EXITS

SleepTimerCallBack ENTRY "R0-R2"
d1177 1
a1177 1

d1184 1
a1184 1
; Aside: XPortable_Stop calls Screen blanker to blank the screen (it happens to be blanked).
a1188 48

FreezeTimes
        DCD     0               ;Off
        DCD     60*100          ; 1 minute
        DCD     2*60*100        ; 2 minutes
        DCD     5*60*100        ; 5 minutes
        DCD     10*60*100       ;10 minutes
        DCD     15*60*100       ;15 minutes
        DCD     30*60*100       ;30 minutes
        DCD     60*60*100       ;60 minutes
FreezeTimesMaxIndex * ((. - FreezeTimes)/4 - 1)
        ASSERT  FreezeTimesMaxIndex = 7

        ASSERT  default_FreezeTime <= FreezeTimesMaxIndex

;******************************************************************************

; KillRTCAlarm  - Cancel alarm completely on module startup.
;
; ClearRTCAlarm - Clear any previously flagged alarm prior to freeze/shutdown.
;
KillRTCAlarm
        Push    "R0-R2,LR"
        MOV     R0, #IICAddress_AcornRTC
        ADR     R1, IICBlk_2
        MOV     R2, #2
        SWI     XIIC_Control
        Pull    "R0-R2,LR"                      ;drop into...

ClearRTCAlarm
        Push    "R0-R2,LR"
        MOV     R0, #IICAddress_AcornRTC
        ADR     R1, IICBlk_1
        MOV     R2, #2
        SWI     XIIC_Control
        Pull    "R0-R2,PC",,^                   ;drop into...

IICBlk_1
        DCB     0       ;Control/status register
        DCB     &04     ; Alarm enable bit=1 (alarm active), stops RTC interrupt line pulsing
                        ; at 1Hz, also clears alarm flag (bit1)

IICBlk_2
        DCB     8       ;Alarm control register
        DCB     &00     ; all alarms and timers off

        ALIGN

@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

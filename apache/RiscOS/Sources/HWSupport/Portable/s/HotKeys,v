head	4.4;
access;
symbols
	Portable-0_70:4.4
	Portable-0_69:4.4
	Portable-0_68:4.3
	Portable-0_67:4.3
	RO_5_07:4.3
	Portable-0_66:4.3
	dellis_autobuild_BaseSW:4.2
	sbrodie_sedwards_16Mar2000:4.2
	Portable-0_65:4.2
	dcotton_autobuild_BaseSW:4.3
	nturton_Portable-0_64:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	nicke_Portable_064:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2012.03.02.23.24.02;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	lloq9wGK9ZNZImVv;

4.3
date	2001.03.16.15.59.53;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.16.37.00;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.37.05;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.37.05;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.37.49;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.59.18;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.52.28;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.4
log
@Updated to use Hdr:Keyboard instead of Hdr:KEYV.
Made use of macro IOMDBase where appropriate.
Still doesn't assemble, and still needs 32 bitting.

Version 0.69. Tagged as 'Portable-0_69'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;
; Hot Keys
; --------
;
; Handles 'hot keys', eg for LCD Brightness/Contrast.
;
; RCManby 6/10/94
;


;******************************************************************************
;
; HotKeyEventHandler
;
; Entry
;   r0 = event number (must be Event_Keyboard)
;   r1 = 0 for key up, 1 for key down
;   r2 = key number
;   r3 = keyboard driver ID
;
;   May be in IRQ mode or SVC mode
;
HotKeyEventHandler
EventVHandler ROUT
        TEQ     r0, #Event_Keyboard             ; only interested in keyboard event
;>>>    TEQEQ   r3, #2                          ; and only if it's on a Perth keyboard
        MOVNES  pc, lr                          ; if not then exit by passing on vector

        TEQ     r1, #0                          ; we want only key up
        TEQNE   r1, #1                          ; or key down
        MOVNES  pc, lr                          ; if not then exit by passing on vector

       ;DREG    R1, "Key up/down (0/1): &",, LongWord
       ;DREG    R2, "Key number: &",, LongWord
       ;DREG    R3, "Keyboard driver ID: &",, LongWord

;>>>We may get lucky with the 'real' keyboard and find all these are
;>>>sequential, in which case a simple low..high range check will do
        TEQ     r2, #HotKey_ContrastDown
        TEQNE   r2, #HotKey_ContrastUp
        TEQNE   r2, #HotKey_BrightnessDown
        TEQNE   r2, #HotKey_BrightnessUp
        TEQNE   r2, #HotKey_Freeze
        TEQNE   r2, #HotKey_MonLCD
        TEQNE   r2, #HotKey_InvertVideo
        TEQNE   r2, #HotKey_AccessLock
        TEQNE   r2, #HotKey_DimBrightness
        MOVNES  pc, lr                          ;NE, not a key we want, so pass along vector
;
; Switch to SVC mode (from IRQ or SVC mode) as all our hot-keys
; require us to issue SWI calls.
;
        Push    "r0-r3,lr"
        MOV     r0, pc
        ORR     r3, r0, #SVC_mode               ; switch to SVC mode
        TEQP    r3, #0
        NOP
        Push    "r0,lr"
;
; NB branch to ExitHandler to exit
;

;>>>We may get lucky with the 'real' keyboard and find all these are
;>>>sequential, in which case a simple low..high range check will do

        TEQ     r1, #0                          ; check for key up
        BEQ     KeyUpHandler

KeyDownHandler
        TEQ     r2, #HotKey_ContrastDown        ;These four keys auto-repeat,
        BEQ     KeyDown_ContrastDown            ;
        TEQ     r2, #HotKey_ContrastUp          ;
        BEQ     KeyDown_ContrastUp              ; so have KeyDown_Xxxx and KeyUp_Xxxx
        TEQ     r2, #HotKey_BrightnessDown      ;
        BEQ     KeyDown_BrightnessDown          ;
        TEQ     r2, #HotKey_BrightnessUp        ;
        BEQ     KeyDown_BrightnessUp            ; routines
        TEQ     r2, #HotKey_MonLCD
        BEQ     Key_MonLCD
        TEQ     r2, #HotKey_InvertVideo
        BEQ     Key_InvertVideo
        TEQ     r2, #HotKey_AccessLock
        BEQ     Key_AccessLock
        TEQ     r2, #HotKey_DimBrightness
        BEQ     Key_DimBrightness

        B       ExitHandler


KeyUpHandler
        TEQ     r2, #HotKey_ContrastDown        ;Terminate auto-repeat
        BEQ     KeyUp_ContrastDown              ;
        TEQ     r2, #HotKey_ContrastUp          ;
        BEQ     KeyUp_ContrastUp                ;
        TEQ     r2, #HotKey_BrightnessDown      ;
        BEQ     KeyUp_BrightnessDown            ;
        TEQ     r2, #HotKey_BrightnessUp        ;
        BEQ     KeyUp_BrightnessUp              ;
        TEQ     r2, #HotKey_Freeze
        BEQ     Key_Freeze
       ;B       ExitHandler


ExitHandler
        Pull    "r0,lr"
        TEQP    r0, #0                          ; restore old processor mode
        NOP
        Pull    "r0-r3,pc",,^


;
; KeyDown for 'Contrast -'
;             'Contrast +'
;             'Brightness -'
;             'Brightness +'
;
; Action the key once, then setup an auto-repeat handler for the key
;
KeyDown_ContrastDown
        ADRL    R0, LCD_ContrastDown
10
        MOV     R1, #AutoRptDelay
        MOV     R2, #AutoRptRate
        BL      PrepareKeyRepeat
        B       ExitHandler

KeyDown_ContrastUp
        ADRL    R0, LCD_ContrastUp
        B       %BT10

KeyDown_BrightnessDown
        ADRL    R0, LCD_BrightnessDown
10
        MOV     R1, #AutoRptDelay
        MOV     R2, #AutoRptRate
        BL      PrepareKeyRepeat
        B       ExitHandler

KeyDown_BrightnessUp
        ADRL    R0, LCD_BrightnessUp
        B       %BT10


;
; KeyUp for 'Contrast -'
;           'Contrast +'
;           'Brightness -'
;           'Brightness +'
;
; Cancel any auto-repeat for the key
;
KeyUp_ContrastDown
        ADRL    R0, LCD_ContrastDown
        BL      EndKeyRepeat
        B       ExitHandler

KeyUp_ContrastUp
        ADRL    R0, LCD_ContrastUp
        BL      EndKeyRepeat
        B       ExitHandler

KeyUp_BrightnessDown
        ADRL    R0, LCD_BrightnessDown
        BL      EndKeyRepeat
        B       ExitHandler

KeyUp_BrightnessUp
        ADRL    R0, LCD_BrightnessUp
        BL      EndKeyRepeat
        B       ExitHandler


;
; Toggle LCD display brightness between the two user setable levels
;
Key_DimBrightness
        BL      LCD_DimBrightness
        B       ExitHandler


;
; Put machine into sleep mode
;
Key_Freeze
        ADR     R0, CB_Freeze                   ;Setup a callback handler to do this
        MOV     R1, R12                         ;
        SWI     XOS_AddCallBack                 ; when its safe

        B       ExitHandler

CB_Freeze
        Entry   "R0"
        SWI     XPortable_Stop                  ;stop the world - I want to get off
        SWIVS   OS_WriteI+7                     ;VS, failed, so beep
        EXITS


;
; toggle display between CRT and LCD
;
Key_MonLCD
 [ {TRUE}
;We only allow a switch to CRT if docking port is connected
        BL      SWIStatus
        TST     R0, #PortableStatus_DocStationConnected
        BICEQ   R0, R0, #PortableStatus_LCDOn   ;EQ no docking station, so force a switch to LCD
        TST     R0, #PortableStatus_LCDOn
 |
        LDRB    R0, DisplayMode
        TEQ     R0, #0
 ]
        ADREQ   R0, CB_SwitchToLCD
        ADRNE   R0, CB_SwitchToCRT
        MOV     R1, R12
        SWI     XOS_AddCallBack

        B       ExitHandler


CB_SwitchToLCD
        Entry   "R0-R9"
        ADR     R0, LCDCommand
        SWI     XOS_CLI

        MOV     R0, #&FF
        STRB    R0, DisplayMode

        EXIT


CB_SwitchToCRT
        Entry   "R0-R9"
        MOV     R0, #0
        STRB    R0, DisplayMode

        ADR     R0, CRTCommand
        SWI     XOS_CLI

        EXIT


LCDCommand
        ;DCB     "Run ADFS::IDEDisc4.$.LCD.BackToLCD", 0
        DCB     "Run Resources:$.Resources.Portable.SelectLCD", 0

CRTCommand
        ;DCB     "Run ADFS::IDEDisc4.$.LCD.BackToMon", 0
        DCB     "Run <PreDesk$Configure>", 0
        ALIGN


;
; Toggle between normal and inverted palettes (LCD only)
;
Key_InvertVideo
        LDRB    R0, PaletteMode
        EOR     R0, R0, #1                      ;Flip normal/inverted bit
        STRB    R0, PaletteMode

        MOV     R4, #paletteV_LCDInvert
        MOV     R9, #PaletteV                   ;Pass normal/invert command to
        SWI     XOS_CallAVector                 ; VDUdrivers along PaletteV.

        B       ExitHandler

;
; Send a service call round to indicate that the 'AccessLock' key has
; been pressed, this should provide enough of a hook for a security
; module (3rd party) to be written.
;
Key_AccessLock
        MOV     R1, #Service_AccessLockKey
        SWI     XOS_ServiceCall
        B       ExitHandler


;
; PrepareKeyRepeat
;
; Entry
;   R0 = address of action routine
;   R1 = delay
;   R2 = rate
;
; Exit
;   Corrupts R0-R2
;
; We call the action routine once as well as setting
; up a 'ticker' for auto-repeating the key.
;
PrepareKeyRepeat
        Push    "LR"
        STR     R1, KeyRepeatDelay              ;Save 'ticker' parameters
        STR     R2, KeyRepeatRate
        STR     R0, KeyRepeatAction

        LDRB    R0, KeyRepeatFlag               ;0=ticker inactive, 1..n=number of keys held down
        TEQ     R0, #0
        ADD     R0, R0, #1                      ;one more key held down
        STRB    R0, KeyRepeatFlag

        MOVEQ   R0, #KeyRepeatTickerRate-1      ;EQ, Must install ticker
        ADREQ   R1, KeyRepeatHandler            ;    address to call
        MOVEQ   R2, R12                         ;    value of R12 to call it with
        SWIEQ   XOS_CallEvery                   ;

        Pull    "LR"                            ;Restore our return address so we can
        LDR     PC, KeyRepeatAction             ; branch directly to the key action routine


;
; EndKeyRepeat
;
; Entry
;   R0 = address of action routine
;
; Exit
;   Corrupts R0-R1
;
EndKeyRepeat
        Entry
        LDR     R1, KeyRepeatAction             ;
        CMP     R1, R0                          ;Clear key repeat action, only if we are the
        MOVEQ   R1, #0                          ; most recent key to be held down
        STREQ   R1, KeyRepeatAction             ;

        LDRB    R0, KeyRepeatFlag               ;
        SUBS    R0, R0, #1                      ;one less key held down
        STRB    R0, KeyRepeatFlag               ;
                                                ;EQ, no keys held down so remove ticker
        ADREQ   R0, KeyRepeatHandler            ;registered call address
        MOVEQ   R1, R12                         ;registered R12 value
        SWIEQ   XOS_RemoveTickerEvent           ;stop further events
        EXITS


;
; KeyRepeatHandler
;
KeyRepeatHandler
        Push    "LR"
        LDR     LR, KeyRepeatAction
        TEQ     LR, #0
        Pull    "PC",EQ,^                       ;EQ, ticked whilst being cancelled, so do nothing

        LDR     LR, KeyRepeatDelay
        SUBS    LR, LR, #1
        STRGE   LR, KeyRepeatDelay

        Pull    "LR"
        MOVGTS  PC, LR
        LDR     PC, KeyRepeatAction


        END
@


4.3
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.66. Tagged as 'Portable-0_66'
@
text
@d216 1
a216 1
 [ 1 = 1
@


4.2
log
@Version Spin_merge taken
@
text
@d206 1
a206 1
        ENTRY   "R0"
d220 1
a220 1
        BICEQ   R0, R0, #PortableStatus_LCDOn   ;EQ no docking station, so force a switch to LCD 
d235 1
a235 1
        ENTRY   "R0-R9"
d246 1
a246 1
        ENTRY   "R0-R9"
d283 1
a283 1
; module (3rd party) to be written. 
d335 1
a335 1
        ENTRY
@


4.1
log
@Initial revision
@
text
@a36 28

;;;HotKey_ToolBox          * &02   ;F2             ;Open Apps directory
HotKey_ContrastDown     * &03   ;F3
HotKey_ContrastUp       * &04   ;F4
HotKey_BrightnessDown   * &05   ;F5
HotKey_BrightnessUp     * &06   ;F6
;;;HotKey_Heart            * &07   ;F7             ;Run favourite application
HotKey_Freeze           * &08   ;F8
HotKey_MonLCD           * &09   ;F9             ;Toggle between LCD and external monitor
HotKey_InvertVideo      * &0A   ;F10
HotKey_AccessLock       * &39   ;keypad 9       ;
HotKey_DimBrightness    * &0B   ;F11
;;;HotKey_Battery          * &0C   ;F12


;HotKey_InvertVideo     *    &7D                     ; inverts LCD palette
;HotKey_ScreenBlank     *    &7E                     ; blanks screen and spins down hard disc


 [ SimulateBMU
HotKey_BMU0             * &65
HotKey_BMU1             * &5A
HotKey_BMU2             * &5B
HotKey_BMU3             * &5C
HotKey_BMU4             * &48
HotKey_BMU5             * &49
 ]

a39 2
;>>>    TEQEQ   r1, #1                          ; and only if it's key down
      TEQEQ   r1, #0    ;use key-up for now, for stork testing (else key up restarts stork) 
d43 5
a50 1

a61 12
        ;;;TEQNE   r2, #HotKey_ToolBox
        ;;;TEQNE   r2, #HotKey_Heart
        ;;;TEQNE   r2, #HotKey_Battery

 [ SimulateBMU
        TEQNE   r2, #HotKey_BMU0
        TEQNE   r2, #HotKey_BMU1
        TEQNE   r2, #HotKey_BMU2
        TEQNE   r2, #HotKey_BMU3
        TEQNE   r2, #HotKey_BMU4
        TEQNE   r2, #HotKey_BMU5
 ]
d67 1
a67 1
        Push    "r0-r2,lr"
d69 2
a70 2
        ORR     r1, r0, #SVC_mode               ; switch to SVC mode
        TEQP    r1, #0
d80 22
a101 4
        ;;;TEQ     r2, #HotKey_ToolBox
        ;;;BEQ     Key_ToolBox
        ;;;TEQ     r2, #HotKey_Heart
        ;;;BEQ     Key_Heart
d103 10
d114 4
a117 15
        BEQ     %FT20
 [ SimulateBMU
        TEQ     r2, #HotKey_BMU0
        BEQ     %FT40
        TEQ     r2, #HotKey_BMU1
        BEQ     %FT41
        TEQ     r2, #HotKey_BMU2
        BEQ     %FT42
        TEQ     r2, #HotKey_BMU3
        BEQ     %FT43
        TEQ     r2, #HotKey_BMU4
        BEQ     %FT44
        TEQ     r2, #HotKey_BMU5
        BEQ     %FT45
 ]
d122 1
a122 1
        Pull    "r0-r2,pc",,^
a124 14
 [ F
;>>>may need
; invert LCD palette - NB no need to go into SVC mode - we're not issuing any SWIs

        Push    "lr"
        LDRB    lr, PaletteVFlag
        TEQ     lr, #2                          ; only invert if LCD is up and running
        LDREQB  lr, PalState
        EOREQ   lr, lr, #1
        STREQB  lr, PalState
        BLEQ    UpdateLCDPalette
 ]
        Pull    "pc",,^                         ; pass on vector

d126 6
a131 1
; blank screen and spin down all IDE hard discs
d133 2
d136 8
a143 2
        MOV     r0, #ScreenBlankerReason_Blank
        SWI     XScreenBlanker_Control          ; blank screen
d145 6
a150 4
        MOV     r0, #2                          ; manual control of drive spin
                                                ; without affecting autospindown
        MOV     r2, #0                          ; spin down immediately
        BL      ADFSPowerOp                     ; apply to all IDE drives
d153 5
d159 4
a162 1
; put machine into sleep mode
d164 5
a168 2
20
        SWI     XPortable_Stop                  ;stop the world - I want to get off
d171 4
d176 3
a178 44
;;;Key_ToolBox
;;;        MOV     r0, #User_Message_Recorded
;;;        ADR     r1, resourcefsmessage
;;; [ 1 = 0
;;;        LDR     r2, FilerHandle
;;; |
;;;        MOV     r2, #0
;;; ]
;;;        SWI     XWimp_SendMessage
;;;        B       ExitHandler
;;;
;;;resourcefsmessage
;;;        DCD     messageend-resourcefsmessage
;;;        DCD     0                       ; filled in by Wimp
;;;        DCD     0                       ; filled in by Wimp
;;;        DCD     0
;;;        DCD     Message_FilerOpenDir
;;;        DCD     fsnumber_resourcefs     ; filing system number
;;;        DCD     0                       ; bitset
;;;        DCB     "Resources:$.Apps", 0   ; pathname
;;;        DCB     "Apps", 0               ; directory title
;;;        ALIGN
;;;messageend
;;;
;;;Key_Heart
;;;        ADR     R0, CB_Heart
;;;        MOV     R1, R12
;;;        SWI     XOS_AddCallBack
;;;        B       ExitHandler
;;;
;;;
;;;CB_Heart
;;;        ENTRY   "R0-R9"
;;;        ADR     R0, HeartCommand
;;;        SWI     XOS_CLI
;;;        EXIT
;;;
;;;HeartCommand
;;;        ;DCB     "<Fav$App>", 0
;;;        DCB     "Filer_Run <Fav$App>", 0
;;;        ALIGN

Key_ContrastDown
        BL      LCD_ContrastDown
d181 3
a183 3

Key_ContrastUp
        BL      LCD_ContrastUp
d187 5
a191 2
Key_BrightnessDown
        BL      LCD_BrightnessDown
d195 8
a202 2
Key_BrightnessUp
        BL      LCD_BrightnessUp
d205 5
a210 3
Key_DimBrightness
        BL      LCD_DimBrightness
        B       ExitHandler
d213 1
a213 3
; Send a service call round to indicate that the 'AccessLock' key has been
; pressed, this should provide enough of a hook security module (3rd party)
; to be written. 
d215 16
a230 3
Key_AccessLock
        MOV     R1, #Service_AccessLockKey
        SWI     XOS_ServiceCall
d234 18
d253 11
a264 2
 [ SimulateBMU
BMUBits * (PortableBMUF_ChargerPresent :OR: PortableBMUF_BatteryPresent  :OR: PortableBMUF_LidOpen)
d267 1
a267 1
; Normal battery state
d269 9
a277 4
40
        MOV     R0, #Event_PortableBMU
        MOV     R1, #BMUBits :OR: PortableBMUF_ChargeKnown
        SWI     XOS_GenerateEvent
d279 1
d281 3
a283 1
; Battery low
d285 3
a287 4
41
        MOV     R0, #Event_PortableBMU
        MOV     R1, #BMUBits :OR: PortableBMUF_ChargeKnown :OR: PortableBMUF_Threshold_1
        SWI     XOS_GenerateEvent
d289 12
d302 2
a303 1
; Battery empty
d305 20
a324 5
42
        MOV     R0, #Event_PortableBMU
        MOV     R1, #BMUBits :OR: PortableBMUF_ChargeKnown :OR: PortableBMUF_Threshold_2
        SWI     XOS_GenerateEvent
        B       ExitHandler
d326 1
a326 1
; Charger fault
d328 2
a329 5
43
        MOV     R0, #Event_PortableBMU
        MOV     R1, #BMUBits :OR: PortableBMUF_ChargeFault
        SWI     XOS_GenerateEvent
        B       ExitHandler
d331 2
a332 1
; Charge unknown ie estimate
d334 17
a350 5
44
        MOV     R0, #Event_PortableBMU
        MOV     R1, #BMUBits
        SWI     XOS_GenerateEvent
        B       ExitHandler
d352 1
a352 1
; Full charge
d354 5
a358 6
45
        MOV     R0, #Event_PortableBMU
        MOV     R1, #BMUBits :OR: PortableBMUF_ChargeKnown :OR: PortableBMUF_Threshold_3
        SWI     XOS_GenerateEvent
        B       ExitHandler
 ]
d360 3
d364 3
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d37 28
d68 2
a72 5
        TEQ     r1, #0                          ; we want only key up
        TEQNE   r1, #1                          ; or key down
        MOVNES  pc, lr                          ; if not then exit by passing on vector

       ;DREG    R1, "Key up/down (0/1): &",, LongWord
d76 1
d88 12
d105 1
a105 1
        Push    "r0-r3,lr"
d107 2
a108 2
        ORR     r3, r0, #SVC_mode               ; switch to SVC mode
        TEQP    r3, #0
d118 4
a121 22
        TEQ     r1, #0                          ; check for key up
        BEQ     KeyUpHandler

KeyDownHandler
        TEQ     r2, #HotKey_ContrastDown        ;These four keys auto-repeat,
        BEQ     KeyDown_ContrastDown            ;
        TEQ     r2, #HotKey_ContrastUp          ;
        BEQ     KeyDown_ContrastUp              ; so have KeyDown_Xxxx and KeyUp_Xxxx
        TEQ     r2, #HotKey_BrightnessDown      ;
        BEQ     KeyDown_BrightnessDown          ;
        TEQ     r2, #HotKey_BrightnessUp        ;
        BEQ     KeyDown_BrightnessUp            ; routines
        TEQ     r2, #HotKey_MonLCD
        BEQ     Key_MonLCD
        TEQ     r2, #HotKey_InvertVideo
        BEQ     Key_InvertVideo
        TEQ     r2, #HotKey_AccessLock
        BEQ     Key_AccessLock
        TEQ     r2, #HotKey_DimBrightness
        BEQ     Key_DimBrightness

        B       ExitHandler
a122 10

KeyUpHandler
        TEQ     r2, #HotKey_ContrastDown        ;Terminate auto-repeat
        BEQ     KeyUp_ContrastDown              ;
        TEQ     r2, #HotKey_ContrastUp          ;
        BEQ     KeyUp_ContrastUp                ;
        TEQ     r2, #HotKey_BrightnessDown      ;
        BEQ     KeyUp_BrightnessDown            ;
        TEQ     r2, #HotKey_BrightnessUp        ;
        BEQ     KeyUp_BrightnessUp              ;
d124 15
a138 4
        BEQ     Key_Freeze
       ;B       ExitHandler


d143 1
a143 1
        Pull    "r0-r3,pc",,^
d146 14
d161 1
a161 6
; KeyDown for 'Contrast -'
;             'Contrast +'
;             'Brightness -'
;             'Brightness +'
;
; Action the key once, then setup an auto-repeat handler for the key
a162 2
KeyDown_ContrastDown
        ADRL    R0, LCD_ContrastDown
d164 2
a165 8
        MOV     R1, #AutoRptDelay
        MOV     R2, #AutoRptRate
        BL      PrepareKeyRepeat
        B       ExitHandler

KeyDown_ContrastUp
        ADRL    R0, LCD_ContrastUp
        B       %BT10
d167 4
a170 6
KeyDown_BrightnessDown
        ADRL    R0, LCD_BrightnessDown
10
        MOV     R1, #AutoRptDelay
        MOV     R2, #AutoRptRate
        BL      PrepareKeyRepeat
a172 5
KeyDown_BrightnessUp
        ADRL    R0, LCD_BrightnessUp
        B       %BT10


d174 1
a174 4
; KeyUp for 'Contrast -'
;           'Contrast +'
;           'Brightness -'
;           'Brightness +'
d176 2
a177 5
; Cancel any auto-repeat for the key
;
KeyUp_ContrastDown
        ADRL    R0, LCD_ContrastDown
        BL      EndKeyRepeat
d180 45
a224 3
KeyUp_ContrastUp
        ADRL    R0, LCD_ContrastUp
        BL      EndKeyRepeat
a226 4
KeyUp_BrightnessDown
        ADRL    R0, LCD_BrightnessDown
        BL      EndKeyRepeat
        B       ExitHandler
d228 2
a229 3
KeyUp_BrightnessUp
        ADRL    R0, LCD_BrightnessUp
        BL      EndKeyRepeat
d233 2
a234 5
;
; Toggle LCD display brightness between the two user setable levels
;
Key_DimBrightness
        BL      LCD_DimBrightness
d238 2
a239 8
;
; Put machine into sleep mode
;
Key_Freeze
        ADR     R0, CB_Freeze                   ;Setup a callback handler to do this
        MOV     R1, R12                         ;
        SWI     XOS_AddCallBack                 ; when its safe

a241 5
CB_Freeze
        ENTRY   "R0"
        SWI     XPortable_Stop                  ;stop the world - I want to get off
        SWIVS   OS_WriteI+7                     ;VS, failed, so beep
        EXITS
d243 3
d248 3
a250 1
; toggle display between CRT and LCD
d252 3
a254 16
Key_MonLCD
 [ 1 = 1
;We only allow a switch to CRT if docking port is connected
        BL      SWIStatus
        TST     R0, #PortableStatus_DocStationConnected
        BICEQ   R0, R0, #PortableStatus_LCDOn   ;EQ no docking station, so force a switch to LCD 
        TST     R0, #PortableStatus_LCDOn
 |
        LDRB    R0, DisplayMode
        TEQ     R0, #0
 ]
        ADREQ   R0, CB_SwitchToLCD
        ADRNE   R0, CB_SwitchToCRT
        MOV     R1, R12
        SWI     XOS_AddCallBack

a257 18
CB_SwitchToLCD
        ENTRY   "R0-R9"
        ADR     R0, LCDCommand
        SWI     XOS_CLI

        MOV     R0, #&FF
        STRB    R0, DisplayMode

        EXIT


CB_SwitchToCRT
        ENTRY   "R0-R9"
        MOV     R0, #0
        STRB    R0, DisplayMode

        ADR     R0, CRTCommand
        SWI     XOS_CLI
a258 11
        EXIT


LCDCommand
        ;DCB     "Run ADFS::IDEDisc4.$.LCD.BackToLCD", 0
        DCB     "Run Resources:$.Resources.Portable.SelectLCD", 0

CRTCommand
        ;DCB     "Run ADFS::IDEDisc4.$.LCD.BackToMon", 0
        DCB     "Run <PreDesk$Configure>", 0
        ALIGN
d260 2
d264 1
a264 1
; Toggle between normal and inverted palettes (LCD only)
d266 4
a269 9
Key_InvertVideo
        LDRB    R0, PaletteMode
        EOR     R0, R0, #1                      ;Flip normal/inverted bit
        STRB    R0, PaletteMode

        MOV     R4, #paletteV_LCDInvert
        MOV     R9, #PaletteV                   ;Pass normal/invert command to
        SWI     XOS_CallAVector                 ; VDUdrivers along PaletteV.

a270 1

d272 1
a272 3
; Send a service call round to indicate that the 'AccessLock' key has
; been pressed, this should provide enough of a hook for a security
; module (3rd party) to be written. 
d274 4
a277 3
Key_AccessLock
        MOV     R1, #Service_AccessLockKey
        SWI     XOS_ServiceCall
a278 2


d280 1
a280 1
; PrepareKeyRepeat
d282 5
a286 4
; Entry
;   R0 = address of action routine
;   R1 = delay
;   R2 = rate
d288 1
a288 2
; Exit
;   Corrupts R0-R2
d290 5
a294 23
; We call the action routine once as well as setting
; up a 'ticker' for auto-repeating the key.
;
PrepareKeyRepeat
        Push    "LR"
        STR     R1, KeyRepeatDelay              ;Save 'ticker' parameters
        STR     R2, KeyRepeatRate
        STR     R0, KeyRepeatAction

        LDRB    R0, KeyRepeatFlag               ;0=ticker inactive, 1..n=number of keys held down
        TEQ     R0, #0
        ADD     R0, R0, #1                      ;one more key held down
        STRB    R0, KeyRepeatFlag

        MOVEQ   R0, #KeyRepeatTickerRate-1      ;EQ, Must install ticker
        ADREQ   R1, KeyRepeatHandler            ;    address to call
        MOVEQ   R2, R12                         ;    value of R12 to call it with
        SWIEQ   XOS_CallEvery                   ;

        Pull    "LR"                            ;Restore our return address so we can
        LDR     PC, KeyRepeatAction             ; branch directly to the key action routine


d296 1
a296 1
; EndKeyRepeat
d298 5
a302 2
; Entry
;   R0 = address of action routine
d304 1
a304 2
; Exit
;   Corrupts R0-R1
d306 6
a311 25
EndKeyRepeat
        ENTRY
        LDR     R1, KeyRepeatAction             ;
        CMP     R1, R0                          ;Clear key repeat action, only if we are the
        MOVEQ   R1, #0                          ; most recent key to be held down
        STREQ   R1, KeyRepeatAction             ;

        LDRB    R0, KeyRepeatFlag               ;
        SUBS    R0, R0, #1                      ;one less key held down
        STRB    R0, KeyRepeatFlag               ;
                                                ;EQ, no keys held down so remove ticker
        ADREQ   R0, KeyRepeatHandler            ;registered call address
        MOVEQ   R1, R12                         ;registered R12 value
        SWIEQ   XOS_RemoveTickerEvent           ;stop further events
        EXITS


;
; KeyRepeatHandler
;
KeyRepeatHandler
        Push    "LR"
        LDR     LR, KeyRepeatAction
        TEQ     LR, #0
        Pull    "PC",EQ,^                       ;EQ, ticked whilst being cancelled, so do nothing
a312 3
        LDR     LR, KeyRepeatDelay
        SUBS    LR, LR, #1
        STRGE   LR, KeyRepeatDelay
a313 3
        Pull    "LR"
        MOVGTS  PC, LR
        LDR     PC, KeyRepeatAction
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d37 28
d68 2
a72 5
        TEQ     r1, #0                          ; we want only key up
        TEQNE   r1, #1                          ; or key down
        MOVNES  pc, lr                          ; if not then exit by passing on vector

       ;DREG    R1, "Key up/down (0/1): &",, LongWord
d76 1
d88 12
d105 1
a105 1
        Push    "r0-r3,lr"
d107 2
a108 2
        ORR     r3, r0, #SVC_mode               ; switch to SVC mode
        TEQP    r3, #0
d118 4
a121 22
        TEQ     r1, #0                          ; check for key up
        BEQ     KeyUpHandler

KeyDownHandler
        TEQ     r2, #HotKey_ContrastDown        ;These four keys auto-repeat,
        BEQ     KeyDown_ContrastDown            ;
        TEQ     r2, #HotKey_ContrastUp          ;
        BEQ     KeyDown_ContrastUp              ; so have KeyDown_Xxxx and KeyUp_Xxxx
        TEQ     r2, #HotKey_BrightnessDown      ;
        BEQ     KeyDown_BrightnessDown          ;
        TEQ     r2, #HotKey_BrightnessUp        ;
        BEQ     KeyDown_BrightnessUp            ; routines
        TEQ     r2, #HotKey_MonLCD
        BEQ     Key_MonLCD
        TEQ     r2, #HotKey_InvertVideo
        BEQ     Key_InvertVideo
        TEQ     r2, #HotKey_AccessLock
        BEQ     Key_AccessLock
        TEQ     r2, #HotKey_DimBrightness
        BEQ     Key_DimBrightness

        B       ExitHandler
a122 10

KeyUpHandler
        TEQ     r2, #HotKey_ContrastDown        ;Terminate auto-repeat
        BEQ     KeyUp_ContrastDown              ;
        TEQ     r2, #HotKey_ContrastUp          ;
        BEQ     KeyUp_ContrastUp                ;
        TEQ     r2, #HotKey_BrightnessDown      ;
        BEQ     KeyUp_BrightnessDown            ;
        TEQ     r2, #HotKey_BrightnessUp        ;
        BEQ     KeyUp_BrightnessUp              ;
d124 15
a138 4
        BEQ     Key_Freeze
       ;B       ExitHandler


d143 1
a143 1
        Pull    "r0-r3,pc",,^
d146 14
d161 1
a161 6
; KeyDown for 'Contrast -'
;             'Contrast +'
;             'Brightness -'
;             'Brightness +'
;
; Action the key once, then setup an auto-repeat handler for the key
a162 2
KeyDown_ContrastDown
        ADRL    R0, LCD_ContrastDown
d164 2
a165 8
        MOV     R1, #AutoRptDelay
        MOV     R2, #AutoRptRate
        BL      PrepareKeyRepeat
        B       ExitHandler

KeyDown_ContrastUp
        ADRL    R0, LCD_ContrastUp
        B       %BT10
d167 4
a170 6
KeyDown_BrightnessDown
        ADRL    R0, LCD_BrightnessDown
10
        MOV     R1, #AutoRptDelay
        MOV     R2, #AutoRptRate
        BL      PrepareKeyRepeat
a172 5
KeyDown_BrightnessUp
        ADRL    R0, LCD_BrightnessUp
        B       %BT10


d174 1
a174 4
; KeyUp for 'Contrast -'
;           'Contrast +'
;           'Brightness -'
;           'Brightness +'
d176 2
a177 5
; Cancel any auto-repeat for the key
;
KeyUp_ContrastDown
        ADRL    R0, LCD_ContrastDown
        BL      EndKeyRepeat
d180 45
a224 3
KeyUp_ContrastUp
        ADRL    R0, LCD_ContrastUp
        BL      EndKeyRepeat
a226 4
KeyUp_BrightnessDown
        ADRL    R0, LCD_BrightnessDown
        BL      EndKeyRepeat
        B       ExitHandler
d228 2
a229 3
KeyUp_BrightnessUp
        ADRL    R0, LCD_BrightnessUp
        BL      EndKeyRepeat
d233 2
a234 5
;
; Toggle LCD display brightness between the two user setable levels
;
Key_DimBrightness
        BL      LCD_DimBrightness
d238 2
a239 8
;
; Put machine into sleep mode
;
Key_Freeze
        ADR     R0, CB_Freeze                   ;Setup a callback handler to do this
        MOV     R1, R12                         ;
        SWI     XOS_AddCallBack                 ; when its safe

a241 5
CB_Freeze
        ENTRY   "R0"
        SWI     XPortable_Stop                  ;stop the world - I want to get off
        SWIVS   OS_WriteI+7                     ;VS, failed, so beep
        EXITS
d243 3
d248 3
a250 1
; toggle display between CRT and LCD
d252 3
a254 16
Key_MonLCD
 [ 1 = 1
;We only allow a switch to CRT if docking port is connected
        BL      SWIStatus
        TST     R0, #PortableStatus_DocStationConnected
        BICEQ   R0, R0, #PortableStatus_LCDOn   ;EQ no docking station, so force a switch to LCD 
        TST     R0, #PortableStatus_LCDOn
 |
        LDRB    R0, DisplayMode
        TEQ     R0, #0
 ]
        ADREQ   R0, CB_SwitchToLCD
        ADRNE   R0, CB_SwitchToCRT
        MOV     R1, R12
        SWI     XOS_AddCallBack

a257 18
CB_SwitchToLCD
        ENTRY   "R0-R9"
        ADR     R0, LCDCommand
        SWI     XOS_CLI

        MOV     R0, #&FF
        STRB    R0, DisplayMode

        EXIT


CB_SwitchToCRT
        ENTRY   "R0-R9"
        MOV     R0, #0
        STRB    R0, DisplayMode

        ADR     R0, CRTCommand
        SWI     XOS_CLI
a258 11
        EXIT


LCDCommand
        ;DCB     "Run ADFS::IDEDisc4.$.LCD.BackToLCD", 0
        DCB     "Run Resources:$.Resources.Portable.SelectLCD", 0

CRTCommand
        ;DCB     "Run ADFS::IDEDisc4.$.LCD.BackToMon", 0
        DCB     "Run <PreDesk$Configure>", 0
        ALIGN
d260 2
d264 1
a264 1
; Toggle between normal and inverted palettes (LCD only)
d266 4
a269 9
Key_InvertVideo
        LDRB    R0, PaletteMode
        EOR     R0, R0, #1                      ;Flip normal/inverted bit
        STRB    R0, PaletteMode

        MOV     R4, #paletteV_LCDInvert
        MOV     R9, #PaletteV                   ;Pass normal/invert command to
        SWI     XOS_CallAVector                 ; VDUdrivers along PaletteV.

a270 1

d272 1
a272 3
; Send a service call round to indicate that the 'AccessLock' key has
; been pressed, this should provide enough of a hook for a security
; module (3rd party) to be written. 
d274 4
a277 3
Key_AccessLock
        MOV     R1, #Service_AccessLockKey
        SWI     XOS_ServiceCall
a278 2


d280 1
a280 1
; PrepareKeyRepeat
d282 5
a286 4
; Entry
;   R0 = address of action routine
;   R1 = delay
;   R2 = rate
d288 1
a288 2
; Exit
;   Corrupts R0-R2
d290 5
a294 23
; We call the action routine once as well as setting
; up a 'ticker' for auto-repeating the key.
;
PrepareKeyRepeat
        Push    "LR"
        STR     R1, KeyRepeatDelay              ;Save 'ticker' parameters
        STR     R2, KeyRepeatRate
        STR     R0, KeyRepeatAction

        LDRB    R0, KeyRepeatFlag               ;0=ticker inactive, 1..n=number of keys held down
        TEQ     R0, #0
        ADD     R0, R0, #1                      ;one more key held down
        STRB    R0, KeyRepeatFlag

        MOVEQ   R0, #KeyRepeatTickerRate-1      ;EQ, Must install ticker
        ADREQ   R1, KeyRepeatHandler            ;    address to call
        MOVEQ   R2, R12                         ;    value of R12 to call it with
        SWIEQ   XOS_CallEvery                   ;

        Pull    "LR"                            ;Restore our return address so we can
        LDR     PC, KeyRepeatAction             ; branch directly to the key action routine


d296 1
a296 1
; EndKeyRepeat
d298 5
a302 2
; Entry
;   R0 = address of action routine
d304 1
a304 2
; Exit
;   Corrupts R0-R1
d306 6
a311 25
EndKeyRepeat
        ENTRY
        LDR     R1, KeyRepeatAction             ;
        CMP     R1, R0                          ;Clear key repeat action, only if we are the
        MOVEQ   R1, #0                          ; most recent key to be held down
        STREQ   R1, KeyRepeatAction             ;

        LDRB    R0, KeyRepeatFlag               ;
        SUBS    R0, R0, #1                      ;one less key held down
        STRB    R0, KeyRepeatFlag               ;
                                                ;EQ, no keys held down so remove ticker
        ADREQ   R0, KeyRepeatHandler            ;registered call address
        MOVEQ   R1, R12                         ;registered R12 value
        SWIEQ   XOS_RemoveTickerEvent           ;stop further events
        EXITS


;
; KeyRepeatHandler
;
KeyRepeatHandler
        Push    "LR"
        LDR     LR, KeyRepeatAction
        TEQ     LR, #0
        Pull    "PC",EQ,^                       ;EQ, ticked whilst being cancelled, so do nothing
a312 3
        LDR     LR, KeyRepeatDelay
        SUBS    LR, LR, #1
        STRGE   LR, KeyRepeatDelay
a313 3
        Pull    "LR"
        MOVGTS  PC, LR
        LDR     PC, KeyRepeatAction
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d37 28
d68 2
a72 5
        TEQ     r1, #0                          ; we want only key up
        TEQNE   r1, #1                          ; or key down
        MOVNES  pc, lr                          ; if not then exit by passing on vector

       ;DREG    R1, "Key up/down (0/1): &",, LongWord
d76 1
d88 12
d105 1
a105 1
        Push    "r0-r3,lr"
d107 2
a108 2
        ORR     r3, r0, #SVC_mode               ; switch to SVC mode
        TEQP    r3, #0
d118 4
a121 22
        TEQ     r1, #0                          ; check for key up
        BEQ     KeyUpHandler

KeyDownHandler
        TEQ     r2, #HotKey_ContrastDown        ;These four keys auto-repeat,
        BEQ     KeyDown_ContrastDown            ;
        TEQ     r2, #HotKey_ContrastUp          ;
        BEQ     KeyDown_ContrastUp              ; so have KeyDown_Xxxx and KeyUp_Xxxx
        TEQ     r2, #HotKey_BrightnessDown      ;
        BEQ     KeyDown_BrightnessDown          ;
        TEQ     r2, #HotKey_BrightnessUp        ;
        BEQ     KeyDown_BrightnessUp            ; routines
        TEQ     r2, #HotKey_MonLCD
        BEQ     Key_MonLCD
        TEQ     r2, #HotKey_InvertVideo
        BEQ     Key_InvertVideo
        TEQ     r2, #HotKey_AccessLock
        BEQ     Key_AccessLock
        TEQ     r2, #HotKey_DimBrightness
        BEQ     Key_DimBrightness

        B       ExitHandler
a122 10

KeyUpHandler
        TEQ     r2, #HotKey_ContrastDown        ;Terminate auto-repeat
        BEQ     KeyUp_ContrastDown              ;
        TEQ     r2, #HotKey_ContrastUp          ;
        BEQ     KeyUp_ContrastUp                ;
        TEQ     r2, #HotKey_BrightnessDown      ;
        BEQ     KeyUp_BrightnessDown            ;
        TEQ     r2, #HotKey_BrightnessUp        ;
        BEQ     KeyUp_BrightnessUp              ;
d124 15
a138 4
        BEQ     Key_Freeze
       ;B       ExitHandler


d143 1
a143 1
        Pull    "r0-r3,pc",,^
d146 14
d161 1
a161 6
; KeyDown for 'Contrast -'
;             'Contrast +'
;             'Brightness -'
;             'Brightness +'
;
; Action the key once, then setup an auto-repeat handler for the key
a162 2
KeyDown_ContrastDown
        ADRL    R0, LCD_ContrastDown
d164 2
a165 8
        MOV     R1, #AutoRptDelay
        MOV     R2, #AutoRptRate
        BL      PrepareKeyRepeat
        B       ExitHandler

KeyDown_ContrastUp
        ADRL    R0, LCD_ContrastUp
        B       %BT10
d167 4
a170 6
KeyDown_BrightnessDown
        ADRL    R0, LCD_BrightnessDown
10
        MOV     R1, #AutoRptDelay
        MOV     R2, #AutoRptRate
        BL      PrepareKeyRepeat
a172 5
KeyDown_BrightnessUp
        ADRL    R0, LCD_BrightnessUp
        B       %BT10


d174 1
a174 4
; KeyUp for 'Contrast -'
;           'Contrast +'
;           'Brightness -'
;           'Brightness +'
d176 2
a177 5
; Cancel any auto-repeat for the key
;
KeyUp_ContrastDown
        ADRL    R0, LCD_ContrastDown
        BL      EndKeyRepeat
d180 45
a224 3
KeyUp_ContrastUp
        ADRL    R0, LCD_ContrastUp
        BL      EndKeyRepeat
a226 4
KeyUp_BrightnessDown
        ADRL    R0, LCD_BrightnessDown
        BL      EndKeyRepeat
        B       ExitHandler
d228 2
a229 3
KeyUp_BrightnessUp
        ADRL    R0, LCD_BrightnessUp
        BL      EndKeyRepeat
d233 2
a234 5
;
; Toggle LCD display brightness between the two user setable levels
;
Key_DimBrightness
        BL      LCD_DimBrightness
d238 2
a239 8
;
; Put machine into sleep mode
;
Key_Freeze
        ADR     R0, CB_Freeze                   ;Setup a callback handler to do this
        MOV     R1, R12                         ;
        SWI     XOS_AddCallBack                 ; when its safe

a241 5
CB_Freeze
        ENTRY   "R0"
        SWI     XPortable_Stop                  ;stop the world - I want to get off
        SWIVS   OS_WriteI+7                     ;VS, failed, so beep
        EXITS
d243 3
d248 3
a250 1
; toggle display between CRT and LCD
d252 3
a254 16
Key_MonLCD
 [ 1 = 1
;We only allow a switch to CRT if docking port is connected
        BL      SWIStatus
        TST     R0, #PortableStatus_DocStationConnected
        BICEQ   R0, R0, #PortableStatus_LCDOn   ;EQ no docking station, so force a switch to LCD 
        TST     R0, #PortableStatus_LCDOn
 |
        LDRB    R0, DisplayMode
        TEQ     R0, #0
 ]
        ADREQ   R0, CB_SwitchToLCD
        ADRNE   R0, CB_SwitchToCRT
        MOV     R1, R12
        SWI     XOS_AddCallBack

a257 18
CB_SwitchToLCD
        ENTRY   "R0-R9"
        ADR     R0, LCDCommand
        SWI     XOS_CLI

        MOV     R0, #&FF
        STRB    R0, DisplayMode

        EXIT


CB_SwitchToCRT
        ENTRY   "R0-R9"
        MOV     R0, #0
        STRB    R0, DisplayMode

        ADR     R0, CRTCommand
        SWI     XOS_CLI
a258 11
        EXIT


LCDCommand
        ;DCB     "Run ADFS::IDEDisc4.$.LCD.BackToLCD", 0
        DCB     "Run Resources:$.Resources.Portable.SelectLCD", 0

CRTCommand
        ;DCB     "Run ADFS::IDEDisc4.$.LCD.BackToMon", 0
        DCB     "Run <PreDesk$Configure>", 0
        ALIGN
d260 2
d264 1
a264 1
; Toggle between normal and inverted palettes (LCD only)
d266 4
a269 9
Key_InvertVideo
        LDRB    R0, PaletteMode
        EOR     R0, R0, #1                      ;Flip normal/inverted bit
        STRB    R0, PaletteMode

        MOV     R4, #paletteV_LCDInvert
        MOV     R9, #PaletteV                   ;Pass normal/invert command to
        SWI     XOS_CallAVector                 ; VDUdrivers along PaletteV.

a270 1

d272 1
a272 3
; Send a service call round to indicate that the 'AccessLock' key has
; been pressed, this should provide enough of a hook for a security
; module (3rd party) to be written. 
d274 4
a277 3
Key_AccessLock
        MOV     R1, #Service_AccessLockKey
        SWI     XOS_ServiceCall
a278 2


d280 1
a280 1
; PrepareKeyRepeat
d282 5
a286 4
; Entry
;   R0 = address of action routine
;   R1 = delay
;   R2 = rate
d288 1
a288 2
; Exit
;   Corrupts R0-R2
d290 5
a294 23
; We call the action routine once as well as setting
; up a 'ticker' for auto-repeating the key.
;
PrepareKeyRepeat
        Push    "LR"
        STR     R1, KeyRepeatDelay              ;Save 'ticker' parameters
        STR     R2, KeyRepeatRate
        STR     R0, KeyRepeatAction

        LDRB    R0, KeyRepeatFlag               ;0=ticker inactive, 1..n=number of keys held down
        TEQ     R0, #0
        ADD     R0, R0, #1                      ;one more key held down
        STRB    R0, KeyRepeatFlag

        MOVEQ   R0, #KeyRepeatTickerRate-1      ;EQ, Must install ticker
        ADREQ   R1, KeyRepeatHandler            ;    address to call
        MOVEQ   R2, R12                         ;    value of R12 to call it with
        SWIEQ   XOS_CallEvery                   ;

        Pull    "LR"                            ;Restore our return address so we can
        LDR     PC, KeyRepeatAction             ; branch directly to the key action routine


d296 1
a296 1
; EndKeyRepeat
d298 5
a302 2
; Entry
;   R0 = address of action routine
d304 1
a304 2
; Exit
;   Corrupts R0-R1
d306 6
a311 25
EndKeyRepeat
        ENTRY
        LDR     R1, KeyRepeatAction             ;
        CMP     R1, R0                          ;Clear key repeat action, only if we are the
        MOVEQ   R1, #0                          ; most recent key to be held down
        STREQ   R1, KeyRepeatAction             ;

        LDRB    R0, KeyRepeatFlag               ;
        SUBS    R0, R0, #1                      ;one less key held down
        STRB    R0, KeyRepeatFlag               ;
                                                ;EQ, no keys held down so remove ticker
        ADREQ   R0, KeyRepeatHandler            ;registered call address
        MOVEQ   R1, R12                         ;registered R12 value
        SWIEQ   XOS_RemoveTickerEvent           ;stop further events
        EXITS


;
; KeyRepeatHandler
;
KeyRepeatHandler
        Push    "LR"
        LDR     LR, KeyRepeatAction
        TEQ     LR, #0
        Pull    "PC",EQ,^                       ;EQ, ticked whilst being cancelled, so do nothing
a312 3
        LDR     LR, KeyRepeatDelay
        SUBS    LR, LR, #1
        STRGE   LR, KeyRepeatDelay
a313 3
        Pull    "LR"
        MOVGTS  PC, LR
        LDR     PC, KeyRepeatAction
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	1.12;
access;
symbols
	PortableHAL-0_81:1.12
	PortableHAL-0_80:1.10
	PortableHAL-0_79:1.9
	PortableHAL-0_78:1.8
	PortableHAL-0_77:1.7
	PortableHAL-0_76:1.6
	PortableHAL-0_75:1.5
	PortableHAL-0_74:1.4
	PortableHAL-0_73:1.4
	PortableHAL-0_72:1.3
	PortableHAL-0_71:1.3
	PortableHAL-0_70:1.3
	PortableHAL-0_69:1.2
	PortableHAL-0_68:1.1;
locks; strict;
comment	@# @;


1.12
date	2017.01.21.13.18.48;	author jlee;	state Exp;
branches;
next	1.11;
commitid	1HG4ASIOcaS3YPCz;

1.11
date	2017.01.20.22.31.58;	author jlee;	state Exp;
branches;
next	1.10;
commitid	qVhPdyuQ67yO3LCz;

1.10
date	2016.03.26.14.17.44;	author jlee;	state Exp;
branches;
next	1.9;
commitid	f3eGZEM9oRZ6Y90z;

1.9
date	2016.03.25.19.51.42;	author jlee;	state Exp;
branches;
next	1.8;
commitid	abx17HDVT2bEQ30z;

1.8
date	2016.03.03.22.22.34;	author jlee;	state Exp;
branches;
next	1.7;
commitid	xGtOwNC9YTzgofXy;

1.7
date	2015.12.12.08.26.37;	author rool;	state Exp;
branches;
next	1.6;
commitid	4EpA4m2URlBUoDMy;

1.6
date	2015.12.05.18.07.16;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	wqNSO27QOfz1QMLy;

1.5
date	2015.06.21.11.44.27;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	IKRtvMSE1E9x5iqy;

1.4
date	2012.11.21.23.33.22;	author jlee;	state Exp;
branches;
next	1.3;
commitid	dKBlfy1bZaU2iitw;

1.3
date	2011.03.19.18.36.04;	author jlee;	state Exp;
branches;
next	1.2;
commitid	zF4gdyWX1f2Hlucv;

1.2
date	2010.03.21.22.20.16;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.30.00.07.43;	author jlee;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Fix excessive cache maintenance
Detail:
  s/StPortable - Fix excessive cache maintenance when making the cache-aligned copy of the ARM11 WFI code
Admin:
  Issue spotted by Andr√© Timmermans


Version 0.81. Retagged as 'PortableHAL-0_81'
@
text
@; Copyright 2010 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     Source.StPortable

;
; Module header and misc. functions
;
        AREA    |Portable$$Code|, CODE, READONLY, PIC

;******************************************************************************
;
; Module header
;
Module_BaseAddr
        DCD     0                               ;Start
        DCD     Init     - Module_BaseAddr
        DCD     Die      - Module_BaseAddr
        DCD     Service  - Module_BaseAddr
        DCD     Title    - Module_BaseAddr
        DCD     Help     - Module_BaseAddr
        DCD     0                               ;Command table
        DCD     Module_SWISystemBase + PortableSWI * Module_SWIChunkSize
        DCD     SWIEntry - Module_BaseAddr
        DCD     SWINameTable - Module_BaseAddr
        DCD     0                               ;SWIDecode
        DCD     0                               ;Messages
        DCD     ModFlags - Module_BaseAddr

;******************************************************************************

Title   DCB     "Portable",0
Help    DCB     "Portable",9,"$Module_HelpVersion", 0
        ALIGN

ModFlags
 [ No32bitCode
        DCD 0
 |
        DCD ModuleFlag_32bit
 ]


;******************************************************************************
;
; Errors
;
        ^               ErrorBase_Portable
        AddError        BadBMUVariable,"BadBMUVar"
        AddError        BadBMUCommand,"BadBMUCmd"
        AddError        BMUBusy,"BMUBusy"
        AddError        BadBMUVersion,"BadBMUVer"
        AddError        BMUFault,"BMUFault"
        AddError        BMUVecClaim,"BMUVecClaim"
        AddError        CantFreeze,"CantFreeze"
        AddError        FreezeFailed,"FreezeFailed"
        AddError        NoSpeed2,"NoSpeed2"
        AddError        BadSpeed2,"BadSpeed2"
        AddError        BadFlags,"BadFlags"
        AddError        BadBMU,"BadBMU"
        AddError        UKSensor,"UKSensor"

        ASSERT          @@ <= (ErrorBase_Portable + ?ErrorBase_Portable)


;******************************************************************************
;
; Resources
;
;Path            DCB     "Portable$Path",0
;DefPath         DCB     "Resources:$.Resources.Portable.",0

MessageFile
messagefilename
        DCB     "Resources:$.Resources.Portable.Messages", 0
        ALIGN


;******************************************************************************
;
; Init - Module initialisation code
;
; Exit
;   R7-R11, R13 preserved
;
Init    ROUT
        Entry   "R7-R8"
        LDR     R2, [R12]
        TEQS    R2, #0                          ;already got work space if entered
        MOVNE   R12, R2
        BNE     %FT20                           ;as part of RMTidy

;private word is zero, so claim some workspace
        MOV     R0, #ModHandReason_Claim
        MOV     R3, #MemNeeded
        SWI     XOS_Module
        EXIT    VS                              ;quit if error

        STR     R2, [R12]                       ;got workspace ok, so store in private word
        MOV     R12, R2
        ; Zero workspace
        MOV     R0, #0
10
        SUBS    R3, R3, #4
        STRGE   R0, [R2], #4
        BGT     %BT10
        ; Determine which WFI routine (if any) to use
        ; ARMv7+ is guaranteed(?) to have WFI instruction
        ; ARMv6 has a CP15 WFI operation
        ; Technically ARMv6K has the WFI instruction as well, but it looks
        ; patchy whether it's implemented (ARM1176JZF-S: WFI instruction is NOP,
        ; ARM11 MPCore: Appears to have both WFI and CP15 WFI)
        ; The CPU feature registers are useless for working out which of the
        ; instructions are implemented, so keep things simple and only use the
        ; CP15 WFI on ARMv6.
        ; (Also, we currently don't care about WFI on older CPUs)
    [ SupportARMv6 :LAND: NoARMv7
      [ NoARMv6
        MRC     p15,0,R1,c0,c0,0
        ANDS    LR, R1, #&0000F000              ; EQ = ARM 3/6
        TEQNE   LR, #&00007000                  ; EQ = ARM 7
        BEQ     %FT15                           ; ... not supported
        AND     LR, R1, #&000F0000              ; Get architecture number
        TEQ     LR, #&00070000                  ; ARMv6?
        TEQNE   LR, #&000F0000                  ; Use feature registers?
        BNE     %FT15                           ; <ARMv6, ignore
      ]
      [ SupportARMv7
        ; Use the cache type register to work out whether this is ARMv6 or ARMv7
        MRC     p15,0,R1,c0,c0,1
        TST     R1, #&E0000000
        ADRNE   R1, Idle_WFI
        STRNE   R1, Idle
        BNE     %FT15
      ]
        ; ARMv6 suspected, use CP15 WFI
        ADR     R1, Idle_CP15
      [ Erratum_486865 <> "NA"
        MRC     p15,0,R0,c0,c0,0
        LDR     R2, =&FFF0
        AND     R0, R0, R2
        LDR     R2, =&B760
        TEQ     R0, R2
        BNE     %FT14
        ; It's ARM11, and we want some kind of special treatment
       [ Erratum_486865 = "Workaround"
        ; Use a (cache aligned) copy of the workaround routine
        ADR     R1, WFI_code
        ADD     R1, R1, #31
        BIC     R1, R1, #31
        ADR     R0, Idle_ARM11
        ASSERT  WFI_code_size = 9*4
        LDMIA   R0, {R0,R2-R8,LR}               ; 9 words
        STMIA   R1, {R0,R2-R8,LR}
        ADD     R2, R1, #WFI_code_size-1
        MOV     R0, #1
        SWI     XOS_SynchroniseCodeAreas
       |
        ASSERT  Erratum_486865 = "Disable"
        B       %FT15
       ]
14
      ]
        STR     R1, Idle
15
    ELIF SupportARMv7
        ; ARMv7+
        ADR     R1, Idle_WFI
        STR     R1, Idle
    ]
        ; Get the DSB_Write ARMop
        LDR     R0, =MMUCReason_GetARMop+(ARMop_DSB_Write:SHL:8)
        SWI     XOS_MMUControl
        ADRVS   R0, NOProutine
        STR     R0, DSB_Write

        ; Look for a CPU clock HAL device
        LDR     R0, =HALDeviceType_SysPeri+HALDeviceSysPeri_CPUClk
        MOV     R1, #0
        MOV     R8, #OSHW_DeviceEnumerate
        SWI     XOS_Hardware
        BVS     %FT20
        CMP     R1, #-1
        BLNE    TryClockDevice
 [ DebugSpeed
        Push    "R9"
        ; Use a HAL timer to get accurate timings
        MOV     R0, #DebugTimer
        MOV     R8, #OSHW_CallHAL
        MOV     R9, #EntryNo_HAL_TimerDevice
        SWI     OS_Hardware
        MOV     R9, #EntryNo_HAL_IRQDisable
        SWI     OS_Hardware
        ; Set the period to max
        ; Note that timing code won't work very well if max != &ffffffff, as it doesn't take into account wraparound
        MOV     R0, #DebugTimer
        MOV     R9, #EntryNo_HAL_TimerMaxPeriod
        SWI     OS_Hardware
        MOV     R1, R0
        MOV     R0, #DebugTimer
        MOV     R9, #EntryNo_HAL_TimerSetPeriod
        SWI     OS_Hardware
        ; Start counting
        MOV     R0, #DebugTimer
        MOV     R9, #EntryNo_HAL_TimerReadCountdown
        SWI     OS_Hardware
        STR     R0, LastTimer
        Pull    "R9"
 ]
20
        ; Look for BMU devices
        LDR     R0, =HALDeviceType_SysPeri+HALDeviceSysPeri_BMU
        MOV     R1, #0
        MOV     R8, #OSHW_DeviceEnumerateChrono
30
        SWI     XOS_Hardware
        BVS     %FT40
        CMP     R1, #-1
        BEQ     %FT40
        BL      AddBMUDevice
        B       %BT30        
40

 [ Debug
        InsertTMLInitialisation 0               ;my EasiStork uses podule slot 0
       ;DLINE   "Portable module initialisation"
 ]

; open messages file

        wsaddr  R0,MsgTransBlk
        addr    R1,MessageFile
        MOV     R2,#0                           ; no buffer supplied
        SWI     XMessageTrans_OpenFile
        EXIT

NOProutine
        MOV     pc, lr

        MakeErrorBlock  ModuleBadSWI
;        MakeErrorBlock  CantFreeze
;        MakeErrorBlock  FreezeFailed
        MakeErrorBlock  NoSpeed2
        MakeErrorBlock  BadSpeed2
        MakeErrorBlock  BadFlags
        MakeErrorBlock  BadBMU
        MakeErrorBlock  BMUFault
        MakeErrorBlock  BMUBusy
        MakeErrorBlock  BadBMUVariable
        MakeErrorBlock  UKSensor

        LTORG

;******************************************************************************
;
; Finalisation code - Called before killing the module
;
; Entry
;   R10 = fatality indication: 0 is non-fatal, 1 is fatal
;   R11 = instantiation number
;   R12 = pointer to private word
;
; Exit
;   R7-R11, R13 preserved
;
Die     ROUT
        Entry
        LDR     R12, [R12]                      ;get workspace pointer

        ; Deactivate BMU devices
01
        LDR     R0, BMUDevList
        TEQ     R0, #0
        BEQ     %FT09
        LDR     R2, [R0]
        BL      RemoveBMUDevice
        B       %BT01

09
        ; Deactivate CPU clock device
        LDR     R4, CPUClkDevice
        CMP     R4, #0
        BLNE    DeactivateClockDevice
10
; close message file

        wsaddr  R0,MsgTransBlk
        SWI     XMessageTrans_CloseFile

        CLRV
        EXIT

;******************************************************************************

UServTab
        DCD     0
        DCD     UService - Module_BaseAddr
        DCD     Service_Hardware
        DCD     0
        DCD     UServTab - Module_BaseAddr
Service
        MOV     R0, R0
        TEQ     R1, #Service_Hardware
        MOVNE   PC, LR
UService
        Entry   "R0-R1"
        LDR     R12, [R12]
        AND     R0, R0, #&FF
        CMP     R0, #1
        BHI     %FT90
        BEQ     %FT50
        ; Device being added
        LDR     R0, CPUClkDevice
        CMP     R0, #0
        BNE     %FT90
      [ NoARMv4
        LDR     R0, [R2, #HALDevice_Type]
        MOV     R0, R0, LSL #16
        MOV     R0, R0, LSR #16
        LDR     LR, [R2, #HALDevice_Version]
        MOV     LR, LR, LSR #16
      |
        LDRH    R0, [R2, #HALDevice_Type]
        LDRH    LR, [R2, #HALDevice_Version+2]
      ]
        LDR     R1, =HALDeviceType_SysPeri+HALDeviceSysPeri_CPUClk
        CMP     R0, R1
        CMPEQ   LR, #0 ; Major API 0
        BLEQ    TryClockDevice
        B       %FT90
50
        ; Device being removed
        LDR     R0, CPUClkDevice
        CMP     R0, R2
        BLEQ    DeactivateClockDevice
90
        CLRV
        EXIT        


;******************************************************************************

SWIEntry        ROUT
        LDR     R12,[R12]
        CMPS    R11,#(EndSWIJmpTable - SWIJmpTable) /4
        ADDCC   PC,PC,R11,LSL #2
        B       SWIUnknown

SWIJmpTable
        B       SWISpeed
        B       SWIControl
        B       SWI_ReadBMUVariable
        B       SWI_WriteBMUVariable
        B       SWI_CommandBMU
        B       SWIReadFeatures
        B       SWIIdle
        B       SWIStop
        B       SWIStatus
        B       SWIPortable_Contrast
        B       SWIRefresh
        B       SWIHalt
        B       SWISleepTime
        B       SWISMBusOp
        B       SWISpeed2
        B       SWIWakeTime
        B       SWIEnumerateBMU
        B       SWIReadBMUVariables
        B       SWIReadSensor
EndSWIJmpTable


;******************************************************************************

ModuleTitle ; Share the string
SWINameTable
        =       "Portable",0
        =       "Speed",0
        =       "Control",0
        =       "ReadBMUVariable",0
        =       "WriteBMUVariable",0
        =       "CommandBMU",0
        =       "ReadFeatures",0
        =       "Idle",0
        =       "Stop",0
        =       "Status",0
        =       "Contrast",0
        =       "Refresh",0
        =       "Halt",0
        =       "SleepTime",0
        =       "SMBusOp",0
        =       "Speed2",0
        =       "WakeTime",0
        =       "EnumerateBMU",0
        =       "ReadBMUVariables",0
        =       "ReadSensor",0
        =       0
        ALIGN

;******************************************************************************


SWIUnknown
 [ :LNOT: Speed
SWISpeed
 ]
SWIControl
SWI_WriteBMUVariable
SWI_CommandBMU
SWIStop
SWIStatus
SWIPortable_Contrast
SWIRefresh
SWIHalt
SWISleepTime
SWISMBusOp
SWIWakeTime
        Push    "r4,lr"
        ADR     r0, ErrorBlock_ModuleBadSWI
        ADR     r4, ModuleTitle
        BL      ErrorLookup1Parm
        Pull    "r4,pc"


;******************************************************************************
;
; SWI Portable_ReadFeatures
;
; Exit
;   R1  = bit 0 set to indicate SWI Portable_Speed is impletemted
;         bit 4 set to indicate SWI Portable_Idle is impletemted
;
; All other bits in R1 zeroed, all other registers preserved.
;
SWIReadFeatures ROUT
        Entry
        LDR     R1, Idle
        CMP     R1, #0
        MOVNE   R1, #PortableFeature_Idle
 [ Speed
        LDR     LR,CPUClkDevice
        CMP     LR,#0
        ORRNE   R1,R1,#PortableFeature_Speed
 ]
        EXIT

 [ Speed
;******************************************************************************
;
; SWI Portable_Speed - Read/write processor speed
;
; in:   R0 = EOR mask
;       R1 = AND mask
;
;       New value = (Old value AND R1) EOR R0
;
;       0 => fast
;       1 => slow
;
; out:  R0 = old value
;       R1 = new value
;
SWISpeed
        Push    "R2-R4,LR"
        MRS     R4,CPSR
        ORR     R3,R4,#I32_bit
        MSR     CPSR_c,R3
        

        LDR     R2,CPUSpeed
        AND     R3,R1,R2
        EOR     R3,R3,R0
        Push    "R2-R3"
        STR     R3,CPUSpeed

        ; Only call the HAL if the speed actually changed
        ; This assumes nothing else is poking around changing the CPU speed behind our back!
        EOR     R1,R2,R3
        TST     R1,#1
        BEQ     %FT10
        LDR     R0,CPUClkDevice
        CMP     R0,#0
        BEQ     %FT10
        ; Also skip calling the HAL if CPUSpeed_Fast == CPUSpeed_Slow
        LDR     R1,CPUSpeed_Fast
        LDR     R2,CPUSpeed_Slow
        CMP     R1,R2
        BEQ     %FT10

 [ DebugSpeed
        Push    "R0,R3,R8-R9,R12"
        MOV     R0, #DebugTimer
        MOV     R8, #OSHW_CallHAL
        MOV     R9, #EntryNo_HAL_TimerReadCountdown
        SWI     OS_Hardware
        LDR     R1, LastTimer
        STR     R0, LastTimer
        SUB     R1,R1,R0
        Pull    "R0,R3"
        TST     R3,#1
        LDREQ   R2,SlowTime
        LDRNE   R2,FastTime
        ADD     R2,R2,R1
        STREQ   R2,SlowTime
        STRNE   R2,FastTime
        LDREQ   R1,CPUSpeed_Fast
        LDRNE   R1,CPUSpeed_Slow
 |
        TST     R3,#1
        MOVNE   R1,R2
 ]
        MOV     LR,PC
        LDR     PC,[R0,#HALDevice_CPUClkSet]
        ; TODO - Error checking
 [ DebugSpeed
        MOV     R0, #DebugTimer
        MOV     R8, #OSHW_CallHAL
        MOV     R9, #EntryNo_HAL_TimerReadCountdown
        SWI     OS_Hardware
        Pull    "R8-R9,R12"
        LDR     R1, LastTimer
        STR     R0, LastTimer
        SUB     R1,R1,R0
        LDR     R0, ChangeTime
        ADD     R0,R0,R1
        STR     R0, ChangeTime
 ]
10
        MSR     CPSR_cf,R4 ; Restore interrupts and V flag (which we're assuming started off as clear!)
        Pull    "R0-R4,PC"
 ]

;******************************************************************************
;
; SWI Portable_Idle - Places the system into idle mode.
;
; The CPU clock is stopped, but all other clocks run normally. This means the
; Video display and all the IO channels are active, the DRAM is refreshed, but
; the system consumes less power as the CPU is inactive. The CPU remains in
; this state until it receives a FIQ or IRQ interrupt (eg from the keyboard,
; floppy, centi-second timer etc).
;
SWIIdle
 [ DebugSpeed
        Entry   "R0-R5,R8-R9"
        MRS     R4,CPSR
        ORR     R3,R4,#I32_bit
        MSR     CPSR_c,R3
        MOV     R0, #DebugTimer
        MOV     R8, #OSHW_CallHAL
        MOV     R9, #EntryNo_HAL_TimerReadCountdown
        SWI     OS_Hardware
        MOV     R5, R0
        BL      %FT50
        MOV     R0, #DebugTimer
        SWI     OS_Hardware
        SUB     R0, R5, R0
        LDR     R1, CPUSpeed
        TST     R1, #1
        LDREQ   R1, FastIdle
        LDRNE   R1, SlowIdle
        ADD     R1, R1, R0
        STREQ   R1, FastIdle
        STRNE   R1, SlowIdle
        MSR     CPSR_cf,R4
        EXIT
50
 ]
        ; Issue a DSB before the WFI to ensure any important writes have fully drained
        Entry   "R0" ; DSB ARMop may corrupt R0
        LDR     LR, Idle
        CMP     LR, #0
        LDRNE   PC, DSB_Write ; Call DSB, with tail-call to WFI code
        EXIT

 [ SupportARMv6 :LAND: NoARMv7
   [ Erratum_486865 = "Workaround"
        ; Use the ARMv6 NOP instruction, just in case MOV R0,R0 stops the workaround from working
        MACRO
        NOPinstr
        DCI     &E320F000
        MEND

Idle_ARM11
        MOV     R0, #2
10
        SUBS    R0, R0, #1
        NOPinstr
        MCREQ   p15, 0, R0, c7, c0, 4
        NOPinstr
        NOPinstr
        NOPinstr
        BNE     %BT10
        EXIT
        ASSERT  . - Idle_ARM11 = WFI_code_size
   ]

Idle_CP15
        MOV     R10, #0
        MCR     p15, 0, R10, c7, c0, 4
        EXIT
 ]

 [ SupportARMv7
Idle_WFI
        WFI
        EXIT
 ]

;******************************************************************************
;
; SWI Portable_Speed2 - Extra CPU speed controls to augment Portable_Speed
;
; Entry:
;    R0 = reason code:
;         0 = Report current CPU speed in (MHz in R0)
;         1 = Report min & max CPU speed in (MHz in R0, R1)
;         2 = Set 'slow' and 'fast' speeds in MHz (from R1, R2). Returns actual new speeds in R1, R2.
;         3 = Report current 'slow' and 'fast' speeds (MHz in R1, R2)
;         4 = Report number of speeds available (in R0)
;         5 = Convert table idx to MHz (R1->R0)
;         6 = Convert MHz to table index (R1->R0)
;         7 = Report current CPU speed (idx in R0)
;         8 = Set 'slow' and 'fast' speeds in table idx (from R1, R2). Returns actual new indices in R1, R2.
;         9 = Report current 'slow' and 'fast' speeds (idx in R1, R2)
 [ DebugSpeed
;        -1 = Report debug stats. R0=FastTime, R1=SlowTime, R2=ChangeTime, R3=FastIdle, R4=SlowIdle, R5=granularity
 ]
;
SWISpeed2
        LDR     R11,CPUClkDevice
        CMP     R11,#0
        BEQ     SWINoSpeed2
 [ DebugSpeed
        CMP     R0,#-1
        BEQ     SWISpeed2_Debug
 ]
        CMP     R0,#9
        ADDLS   PC,PC,R0,LSL#2
        B       SWIBadSpeed2
        B       SWISpeed2_ReportMHz
        B       SWISpeed2_ReportMinMaxMHz
        B       SWISpeed2_SetSlowFastMHz
        B       SWISpeed2_GetSlowFastMHz
        B       SWISpeed2_NumIdx
        B       SWISpeed2_IdxToMHz
        B       SWISpeed2_MHzToIdx
        B       SWISpeed2_ReportIdx
        B       SWISpeed2_SetSlowFastIdx
        B       SWISpeed2_GetSlowFastIdx

SWISpeed2_ReportMHz
        Entry   "R1-R3"
        MOV     R0,R11
        MOV     LR,PC
        LDR     PC,[R0,#HALDevice_CPUClkGet]
        MOV     R1,R0
        MOV     R0,R11
        MOV     LR,PC
        LDR     PC,[R0,#HALDevice_CPUClkInfo]
        CLRV
        EXIT

SWISpeed2_ReportMinMaxMHz       
        Push    "R2-R3,LR"
        MOV     R0,R11
        MOV     LR,PC
        LDR     PC,[R0,#HALDevice_CPUClkNumSpeeds]
        SUB     R1,R0,#1
        MOV     R0,R11
        MOV     LR,PC
        LDR     PC,[R0,#HALDevice_CPUClkInfo]
        Push    "R0"
        MOV     R0,R11
        MOV     R1,#0
        MOV     LR,PC
        LDR     PC,[R0,#HALDevice_CPUClkInfo]
        CLRV
        Pull    "R1-R3,PC"

SWISpeed2_SetSlowFastMHz
        Entry   "R1-R3,R12"
        ; Convert to table idx
        BL      SWISpeed2_MHzToIdx
        MOVVC   R3,R0
        MOVVC   R1,R2
        BLVC    SWISpeed2_MHzToIdx
        EXIT    VS
        ; Call idx code
        FRAMLDR R12
        MOV     R2,R0
        MOV     R1,R3
        BL      SWISpeed2_SetSlowFastIdx
        PullEnv
        MOVVS   PC,LR
        ; Fall through...
        MOV     R0,#2 ; SetSlowFastMHz reason code
SWISpeed2_GetSlowFastMHz
        Entry   "R0,R3,R12"
        LDR     R1,CPUSpeed_Fast
        BL      SWISpeed2_IdxToMHz
        MOV     R2,R0
        FRAMLDR R12
        LDR     R1,CPUSpeed_Slow
        BL      SWISpeed2_IdxToMHz
        MOV     R1,R0
        EXIT

SWISpeed2_NumIdx
        Entry   "R1-R3"
        MOV     R0,R11
        MOV     LR,PC
        LDR     PC,[R0,#HALDevice_CPUClkNumSpeeds]
        CLRV
        EXIT

SWISpeed2_IdxToMHz
        ; Assume the input is in range
        Entry   "R1-R3"
        MOV     R0,R11
        MOV     LR,PC
        LDR     PC,[R0,#HALDevice_CPUClkInfo]
        CLRV
        EXIT

SWISpeed2_MHzToIdx
        Entry   "R1-R4"
        MOV     R10,R1
        MOV     R0,R11
        MOV     LR,PC
        LDR     PC,[R0,#HALDevice_CPUClkNumSpeeds]
        SUB     R4,R0,#1
10
        MOV     R0,R11
        MOV     R1,R4
        MOV     LR,PC
        LDR     PC,[R0,#HALDevice_CPUClkInfo]
        SUBS    R4,R4,#1
        CMPGE   R0,R10
        BGT     %BT10 ; new R4>=0 and R0 > R10
        ADD     R0,R4,#1 ; Cancel out the pre-decrement
        EXIT

SWISpeed2_ReportIdx
        Entry   "R1-R3"
        MOV     R0,R11
        MOV     LR,PC
        LDR     PC,[R0,#HALDevice_CPUClkGet]
        EXIT
       
SWISpeed2_SetSlowFastIdx
        Entry   "R1-R4,R12"
        ; Interrupts off to keep this atomic
        MRS     R4,CPSR
        ORR     R3,R4,#I32_bit
        MSR     CPSR_c,R3
        ; Clamp input values, ensure fast >= slow
        MOV     R0,R11
        MOV     LR,PC
        LDR     PC,[R0,#HALDevice_CPUClkNumSpeeds]
        LDMIA   R13,{R1-R2}
        CMP     R1,#0
        MOVLT   R1,#0
        CMP     R2,#0
        MOVLT   R2,#0
        CMP     R1,R0
        SUBGE   R1,R0,#1
        CMP     R2,R0
        SUBGE   R2,R0,#1
        CMP     R1,R2
        MOVGE   R1,R2
        ; Remember the new values
        STMIA   R13,{R1-R2}
        FRAMLDR R12
        STR     R1,CPUSpeed_Slow
        STR     R2,CPUSpeed_Fast
        ; Update speed depending on current slow/fast value
        LDR     R3,CPUSpeed
        TST     R3,#1
        MOVEQ   R1,R2
        MOV     R0,R11
        MOV     LR,PC
        LDR     PC,[R0,#HALDevice_CPUClkSet]
        MSR     CPSR_cf,R4 ; Restore interrupts and V flag (which we're assuming started off as clear!)
        EXIT

SWISpeed2_GetSlowFastIdx
        LDR     R1,CPUSpeed_Slow
        LDR     R2,CPUSpeed_Fast
        MOV     PC,LR

 [ DebugSpeed
SWISpeed2_Debug
        Entry   "R6,R8-R9"
        MRS     R6, CPSR
        ORR     R0,R6,#I32_bit
        MSR     CPSR_c,R0
        ; Grab granularity
        MOV     R0, #DebugTimer
        MOV     R8, #OSHW_CallHAL
        MOV     R9, #EntryNo_HAL_TimerGranularity
        SWI     OS_Hardware
        MOV     R5, R0
        MOV     R0, #DebugTimer
        MOV     R9, #EntryNo_HAL_TimerReadCountdown
        SWI     OS_Hardware
        LDR     R1, LastTimer
        STR     R0, LastTimer
        SUB     R8, R1, R0
        LDR     R1, CPUSpeed
        ADR     R9, FastTime
        TST     R1, #1
        LDMIA   R9, {R0-R4} ; Grab return values
        ADDEQ   R0, R0, R8 ; Make sure time is up to date
        ADDNE   R1, R1, R8
        ; Zero out cumulative values
        MOV     R8, #0
        STR     R8, FastTime
        STR     R8, SlowTime
        STR     R8, ChangeTime
        STR     R8, FastIdle
        STR     R8, SlowIdle
        MSR     CPSR_cf,R6
        EXIT
 ]

SWINoSpeed2
        ADRL    r0, ErrorBlock_NoSpeed2
        B       ErrorLookupNoParms

SWIBadSpeed2
        ADRL    r0, ErrorBlock_BadSpeed2
        B       ErrorLookupNoParms

;******************************************************************************

;
; Entry:
;    R2 -> BMU HAL device
;
; Exit:
;    All regs preserved
;
AddBMUDevice ROUT
        Entry   "r0-r3,r9"
        ; Check this device isn't already listed
        LDR     r0, BMUDevCount
        LDR     r1, BMUDevList
        MOV     r3, #0
10
        TEQ     r0, r3
        BEQ     %FT20
        LDR     r9, [r1, r3, LSL #2]
        TEQ     r9, r2
        EXIT    EQ
        ADD     r3, r3, #1
        B       %BT10
20
        ; Realloc memory
        MOVS    r2, r1
        MOV     r3, #4
        MOVEQ   r0, #ModHandReason_Claim
        MOVNE   r0, #ModHandReason_ExtendBlock
        SWI     XOS_Module
        EXIT    VS
        STR     r2, BMUDevList
        ; Activate device
        LDR     r0, [sp, #8]
        Push    "r12"
        MOV     lr, pc
        LDR     pc, [r0, #HALDevice_Activate]
        Pull    "r12"
        TEQ     r0, #1
        BNE     %FT30
        ; Success!
        LDR     r0, BMUDevCount
        LDR     r1, BMUDevList
        LDR     r2, [sp, #8]
        STR     r2, [r1, r0, LSL #2]
        ADD     r0, r0, #1
        STR     r0, BMUDevCount
        ; If this device powers the system, and we don't have a dev 0 yet, use it for dev 0
        LDR     r0, BMUDev0
        CMP     r0, #0
        EXIT    NE
        LDR     r0, [sp, #8]
        LDR     r1, [r0, #HALDevice_BMUFlags]
        TST     r1, #PortableBMUDF_System
        STRNE   r0, BMUDev0
        EXIT
30
        ; Failed to init, free the extra memory we claimed
        LDR     r1, BMUDevCount
        LDR     r2, BMUDevList
        TEQ     r0, #0
        MOVEQ   r0, #ModHandReason_Free
        MOVNE   r0, #ModHandReason_ExtendBlock
        MOVNE   r3, #-4
        SWI     XOS_Module
        TEQ     r1, #0
        MOVEQ   r2, #0
        STRVC   r2, BMUDevList
        EXIT

;
; Entry:
;    R2 -> BMU HAL device
;
; Exit:
;    All regs preserved
;
RemoveBMUDevice ROUT
        Entry   "r0-r3,r9"
        ; Find the device in the list
        LDR     r0, BMUDevCount
        LDR     r1, BMUDevList
        MOV     r3, #0
10
        TEQ     r0, r3
        EXIT    EQ
        LDR     r9, [r1, r3, LSL #2]
        TEQ     r9, r2
        ADDNE   r3, r3, #1
        BNE     %BT10
        ; Shuffle all the other entries down
        ADD     r1, r1, r3, LSL #2
        ADD     r3, r3, #1
20
        TEQ     r0, r3
        BEQ     %FT30
        LDR     r9, [r1, #4]
        STR     r9, [r1], #4
        B       %BT20
30
        SUB     r0, r0, #1
        STR     r0, BMUDevCount
        ; Deactivate device
        Push    "r12"
        MOV     r0, r2
        MOV     lr, pc
        LDR     pc, [r0, #HALDevice_Deactivate]
        Pull    "r12"
        ; Free memory
        LDR     r1, BMUDevCount
        LDR     r2, BMUDevList
        TEQ     r0, #0
        MOVEQ   r0, #ModHandReason_Free
        MOVNE   r0, #ModHandReason_ExtendBlock
        MOVNE   r3, #-4
        SWI     XOS_Module
        TEQ     r1, #0
        MOVEQ   r2, #0
        STRVC   r2, BMUDevList
        ; Discard dev 0 if this was it
        ; Note that we don't attempt to look for another device to replace it (for the moment we assume the device was created by the HAL and won't go missing anyway)
        LDR     r0, [sp, #8]
        LDR     r1, BMUDev0
        CMP     r0, r1
        MOVEQ   r0, #0
        STREQ   r0, BMUDev0
        EXIT

;
; Entry:
;    R0 = Previous BMU index (-1 to start enumeration)
;    R1 = Extra flags (reserved, should be 0)
;
; Exit:
;    R0 = This BMU index, -1 for none
;    R1 = BMU flags          (only valid if R0<>-1)
;    R2 = Supported status flags      " "
;
;    R1-R2 corrupt on error
;
SWIEnumerateBMU ROUT
        TEQ     r1, #0
        ADRNEL  r0, ErrorBlock_BadFlags
        BNE     ErrorLookupNoParms
        LDR     r1, BMUDevCount
        TEQ     r1, #0
        BEQ     Error_BadBMU
        ADDS    r0, r0, #1
        BEQ     %FT10
        ADD     r1, r1, #1
        CMP     r0, r1
        BHI     Error_BadBMU
        MOVEQ   r0, #-1
        MOVEQ   pc, lr
15
        LDR     r1, BMUDevList
        SUB     r1, r1, #4
        LDR     r1, [r1, r0, LSL #2]
20
        LDR     r2, [r1, #HALDevice_BMUStatusFlagsMask]
        LDR     r1, [r1, #HALDevice_BMUFlags]
        MOV     pc, lr

10
        ; Does BMU 0 exist?
        LDR     r1, BMUDev0
        TEQ     r1, #0
        BNE     %BT20
        ; BMU 0 doesn't exist, return BMU 1
        MOV     r0, #1
        B       %BT15


;
; Entry:
;    R0 = BMU index
;    R1 = Number of variables to read
;    R2 = Pointer to PortableReadBMUVars list
;
; Exit:
;    List updated
;    All regs preserved
;
SWIReadBMUVariables ROUT
        Entry   "r0-r3,r12"
        TEQ     r0, #0
        BNE     %FT05
        LDR     r0, BMUDev0
        TEQ     r0, #0
        BEQ     %FT10
        B       %FT08
05
        LDR     r3, BMUDevCount
        SUB     r0, r0, #1
        CMP     r0, r3
        BHI     %FT10
        LDR     r3, BMUDevList
        LDR     r0, [r3, r0, LSL #2]
08
        MOV     lr, pc
        LDR     pc, [r0, #HALDevice_BMUReadVariables]
        CLRV
        EXIT
10
        PullEnv
Error_BadBMU
        ADRL    r0, ErrorBlock_BadBMU
        B       ErrorLookupNoParms


;
; Entry:
;    R0  bits 0-23 = variable index
;        bits 24-31 = BMU index
;
; Exit:
;    R1 = variable value
;    All other regs preserved
;
SWI_ReadBMUVariable ROUT
        Entry   "r0-r2"
        ; Construct a PortableReadBMUVars item on the stack
        BIC     r1, r0, #&ff000000
        MOV     r0, r0, LSR #24
        ASSERT  PortableReadBMUVars_VarNo = 0
        STR     r1, [sp, #-PortableReadBMUVars_Size]!
        MOV     r1, #1
        MOV     r2, sp
        BL      SWIReadBMUVariables
        BVS     %FT90
        LDR     r0, [sp, #PortableReadBMUVars_Result]
        TEQ     r0, #PortableBMUR_Unknown
        MOVEQ   r1, #-1 ; Return -1 for unknown (deviation from original spec which used 255 due to 8 bit var width)
        BEQ     %FT70
        TEQ     r0, #PortableBMUR_Success
        BNE     %FT80
        LDR     r1, [sp, #PortableReadBMUVars_Value]
70
        ADD     sp, sp, #PortableReadBMUVars_Size
        STR     r1, [sp, #4]
        EXIT
80
        ; Translate PortableBMUR error
        ADR     r1, PortableBMUR_ErrorTable
        LDR     r0, [r1, r0, LSL #2]
        ADD     r0, r0, r1
        STR     r0, [sp, #PortableReadBMUVars_Size]!
        PullEnv
        B       ErrorLookupNoParms
90
        ; Exit with error in R0
        STR     r0, [sp, #PortableReadBMUVars_Size]!
        EXIT

        MACRO
        BMURE   $result, $error
        ASSERT  . - PortableBMUR_ErrorTable = PortableBMUR_$result*4
        DCD     ErrorBlock_$error - PortableBMUR_ErrorTable
        MEND
        
PortableBMUR_ErrorTable
        ; Success is handled above
        ASSERT  PortableBMUR_Success = 0
        DCD     0
        BMURE   Error, BMUFault
        BMURE   Busy, BMUBusy
        BMURE   Unsupported, BadBMUVariable
        ; Unknown is handled above
        ASSERT  . - PortableBMUR_ErrorTable = PortableBMUR_Unknown*4
        DCD     0


;
; Entry:
;    R0 = Sensor index
;         0 => temperature (scaled to 0.1K per LSB) 
;         others => reserved for future use
;    R1 = Unit type
;         0 => CPU die
;         1 => BMU
;         others => reserved for future use
;    R2 = Unit index
;         0-N => as appropriate for unit N
;
; Exit:
;    R0 = Sensor value
;    All other regs preserved
;
SWIReadSensor ROUT
        Entry   "R1-R3"
        CMP     r0, #PortableReadSensor_Temperature
        BNE     %FT90                   ; Reserved sensor

        CMP     r1, #PortableRS_Temperature_Max
        ADDLO   pc, pc, r1, LSL #2
        B       %FT90                   ; Out of range temperature sensor
RS_Table
        B       RS_CPUDie
        B       RS_BMU
        B       %FT90                   ; } Sensors with
        B       %FT90                   ; } no HAL
        B       %FT90                   ; } backend 
        ASSERT  (. - RS_Table) :SHR: 2 = PortableRS_Temperature_Max

RS_CPUDie
        TEQ     r2, #0                  
        BNE     %FT90                   ; No multicore :-(

        LDR     r0, CPUClkDevice
        LDR     r2, [r0, #HALDevice_Version]
        CMP     r2, #(0:SHL:16):OR:2    
        BCC     %FT90                   ; Need API 0.2

        MOV     lr, pc
        LDR     pc, [r0, #HALDevice_CPUClkGetDieTemperature]
        EXIT

RS_BMU        
        MOV     r0, #PortableBMUV_Temperature
        ORR     r0, r0, r2, LSL #24     ; Nth BMU
        SWI     XPortable_ReadBMUVariable
        MOVVC   r0, r1
        EXIT
90
        PullEnv
        ADRL    r0, ErrorBlock_UKSensor
        B       ErrorLookupNoParms

;******************************************************************************

ErrorLookupNoParms      Entry   "R1-R7"
;
; Entry:
;    R0 -> error block with tokenised message
;
; Exit:
;    R0 -> error block with real message
;    V set

        MOV     R4,#0                           ; no parameter 0
        B       ErrorLookupContinue

ErrorLookup1Parm        ALTENTRY
;
; Entry:
;    R0 -> error block with tokenised message
;    R4 -> parameter to substitute into error
;
; Exit:
;    R0 -> error block with real message
;    V set

ErrorLookupContinue

        wsaddr  R1,MsgTransBlk
        MOV     R2,#0                           ; use internal buffer
        MOV     R5,#0                           ; no parameter 0
        MOV     R6,#0                           ; no parameter 0
        MOV     R7,#0                           ; no parameter 0
        SWI     XMessageTrans_ErrorLookup
        EXIT

;******************************************************************************

TryClockDevice  ROUT
;
; Entry:
;    R2 -> CPUClk HAL device
;
        Entry   "R0-R3,R8,R12"
        MOV     R8, R2
        MOV     R0, R2
        MOV     LR, PC
        LDR     PC, [R0, #HALDevice_Activate]
        FRAMLDR R12
        CMP     R0, #1
        EXIT    NE
        ; Set up some default slow & fast speeds. For now just use min & max clock speed.
        MOV     R0, #0
        STR     R0, CPUSpeed_Slow
        MOV     R0, R8
        MOV     LR, PC
        LDR     PC, [R0, #HALDevice_CPUClkNumSpeeds]
        FRAMLDR R12
        SUB     R1, R0, #1
        STR     R1, CPUSpeed_Fast
        ; Go fast!
        MOV     R0, R8
        MOV     LR, PC
        LDR     PC, [R0, #HALDevice_CPUClkSet]
        FRAMLDR R12
        ; Make device available
        STR     R8, CPUClkDevice
        EXIT

DeactivateClockDevice ROUT
        Entry   "R0-R3,R8,R12"
        LDR     R8, CPUClkDevice
        MOV     R0, #0
        STR     R0, CPUClkDevice
        ; Go fast
        MOV     R0, R8
        MOV     LR, PC
        LDR     PC, [R0, #HALDevice_CPUClkNumSpeeds]
        SUB     R1, R0, #1
        MOV     R0, R8
        MOV     LR, PC
        LDR     PC, [R0, #HALDevice_CPUClkSet]
        ; Now deactivate
        MOV     R0, R8
        MOV     LR, PC
        LDR     PC, [R0, #HALDevice_Deactivate]
        EXIT

;******************************************************************************

 [ Debug
        InsertDebugRoutines
 ]

;******************************************************************************

        END
@


1.11
log
@Disable WFI (Portable_Idle) on ARM11
Detail:
  On a Raspberry Pi 1B and 1B+, reading a constant stream of data from the serial port was found to eventually result in a CPU deadlock within the WFI code, consistent with that described in the ARM11 erratum 486865 notice
  Tweaking the already-implemented workaround for the erratum didn't bring any luck, so I'm going with the fallback approach of disabling WFI completely for ARM11.
  s/GetAll - Extend the Erratum_486865 switch to support three different modes
  s/Front - Replace magic number that gave the workaround code size
  s/StPortable - Check the CPU ID to make sure the Erratum_486865 switch only affects ARM11 CPUs. Add support for disabling WFI on ARM11, and tweak the workaround implementation so that it's now an exact match for that given by ARM.
Admin:
  Tested on Raspberry Pi 1 B
  With WFI enabled the test code used to crash after anywhere between a few minutes to ~20 hours, but with WFI disabled it's survived 48 hours


Version 0.81. Tagged as 'PortableHAL-0_81'
@
text
@d166 1
a166 1
        ADD     R2, R1, #WFI_code_size*4-1
@


1.10
log
@Portect against HAL device calls corrupting R12
Detail:
  s/StPortable - Where module workspace needs to be used following a HAL device call, make sure we save and restore R12, as HAL devices are allowed to corrupt it
Admin:
  Tested on Pi 2B, 3B
  Fixes issue reported on forums with some Portable_Speed2 reason codes aborting:
  https://www.riscosopen.org/forum/forums/2/topics/3961#posts-51298


Version 0.80. Tagged as 'PortableHAL-0_80'
@
text
@d147 11
a157 2
        ; ARMv6 suspected
      [ Erratum_486865
d162 2
a163 1
        ADR     R0, Idle_CP15
d166 1
a166 1
        ADD     R2, R1, #9*4-1
d169 6
a175 4
      |
        ADR     R1, Idle_CP15
        STR     R1, Idle
      ]
d586 10
a595 3
 [ Erratum_486865
Idle_CP15
        MOV     R10, #2
d597 6
a602 6
        SUBS    R10, R10, #1
        NOP
        MCREQ   p15, 0, R10, c7, c0, 4
        NOP
        NOP
        NOP
d605 3
a607 2
        ASSERT  . - Idle_CP15 = 9*4
 ELIF SupportARMv6 :LAND: NoARMv7
@


1.9
log
@Make Portable_Idle perform a DSB before the WFI, and use the CP15 WFI op on ARMv6. Allow the CPU clock device to vanish and re-appear. Export a C version of the CPUClkDevice header.
Detail:
  s/Front, s/GetAll, s/StPortable - Improve Portable_Idle implementation so that it issues a DSB before the WFI, and uses the CP15 WFI (potentially with erratum 486865 workaround) for ARMv6. Adjust handling of CPU clock device in order to allow it to be registered and deregistered at runtime.
  Makefile, h/CPUClkDevice - Export a C version of the CPUClkDevice header
Admin:
  Tested on Raspberry Pi 1B/2B/3B


Version 0.79. Tagged as 'PortableHAL-0_79'
@
text
@d672 1
a672 1
        Push    "R1-R3,R12,LR"
d678 1
a678 1
        Pull    "R1-R3,R12,PC",VS
d680 1
a680 1
        LDR     R12,[R13,#12]
d684 1
a684 1
        Pull    "R1-R3,R12,LR"
d689 1
a689 1
        Entry   "R0,R3"
d693 1
d764 1
a764 1
        LDR     R12,[R13,#16]
@


1.8
log
@Fix speed inversion in Portable_Speed2 8/9
Detail:
  s/StPortable - CPUSpeed bit 0 is 0 for fast and 1 for slow, make sure we get it the right way round when re-applying the current speed setting after accepting new fast & slow speed values
Admin:
  Untested
  Issue spotted by Willi Theiss


Version 0.78. Tagged as 'PortableHAL-0_78'
@
text
@d30 1
a30 1
        DCD     0                               ;Service calls
d118 58
d183 1
a183 23
        BEQ     %FT20
        MOV     R8, R2
        Push    "R12"
        MOV     R0, R2
        MOV     LR, PC
        LDR     PC, [R0, #HALDevice_Activate]
        Pull    "R12"
        CMP     R0, #1
        BNE     %FT20
        STR     R8, CPUClkDevice
        ; Set up some default slow & fast speeds. For now just use min & max clock speed.
        MOV     R0, R8
        Push    "R12"
        MOV     LR, PC
        LDR     PC, [R0, #HALDevice_CPUClkNumSpeeds]
        LDR     R12,[R13]        
        SUB     R1, R0, #1
        STR     R1, CPUSpeed_Fast ; (CPUSpeed_Slow should already be 0)
        ; Go fast!
        MOV     R0, R8
        MOV     LR, PC
        LDR     PC, [R0, #HALDevice_CPUClkSet]
        Pull    "R12"
d236 3
d282 1
a282 15
        BEQ     %FT10
        Push    "R12"
        ; Go fast
        MOV     R0, R4
        MOV     LR, PC
        LDR     PC, [R0, #HALDevice_CPUClkNumSpeeds]
        SUB     R1, R0, #1
        MOV     R0, R4
        MOV     LR, PC
        LDR     PC, [R0, #HALDevice_CPUClkSet]
        ; Now deactivate
        MOV     R0, R4
        MOV     LR, PC
        LDR     PC, [R0, #HALDevice_Deactivate]
        Pull    "R12"
d292 47
d435 3
a437 24
        ; Idle is implemented via the WFI instruction
        ; And WFI is only available in 'K' architectures (ARMv6K, ARMv7+)
 [ SupportARMK
   [ :LNOT: NoARMK
        ; Everything is O'K'
        MOV     R1,#PortableFeature_Idle
   |
        ; We may or may not be O'K'. Check CPU ID.
        MRC     P15,0,R1,C0,C0,0
        ANDS    LR, R1, #&0000F000 ; EQ = ARM 3/6
        TEQNE   LR, #&00007000 ; EQ = ARM 7
        MOVEQ   R1, #0 ; ... not supported
        BEQ     %FT10
        AND     LR, R1, #&000F0000 ; Get architecture number
        TEQ     LR, #&00070000 ; ARMv6?
        TEQNE   LR, #&000F0000 ; ARMv7+?
        MOVNE   R1, #0
        MOVEQ   R1, #PortableFeature_Idle ; There doesn't seem to be an easy way to differentiate ARMv6K from other ARMv6 variants - so for now, just claim we support Idle on it
10
   ]
 |
        ; We don't support WFI.
        MOV     R1,#0
 ]
d552 1
a552 4
 ]
        ; Although the WFI instruction was only introduced in ARMv6K, it behaves as a nop MSR on earlier architectures. And MSR itself behaves as a NOP on pre-ARMv3. So we don't have to do anything special to avoid crashing if we get called while running on an unsupported architecture.
        WFI
 [ DebugSpeed
d565 27
a591 3
 |
        CLRV
        MOV     PC, LR
d594 5
d1186 51
@


1.7
log
@Fix for incorrect register use
Detail:
  The CPUClkDevice struct pointer should be in a1, not a3.
Admin:
  Submission from Willi Theiss.

Version 0.77. Tagged as 'PortableHAL-0_77'
@
text
@d692 1
a692 1
        MOVNE   R1,R2
@


1.6
log
@Add sensor reading SWI
New Portable_ReadSensor is a general front end to sensors that might be of concern to the Portable module.
Starter for 10 is temperature, and we support reading the CPU die temperature (from a new CPUClk entry point, since faster=botter they're physically related parameters) and the BMU charger. Each supports multiple units, so in future multicore temperatures can be reported.
New error message in the resources, plus enable tokenisation of the Messages file since it's used via a buffered MessageTrans_ErrorLookup call.

Tested briefly on a HAL with fake temperature sensor returning a hardwired kelvin value.

Version 0.76. Tagged as 'PortableHAL-0_76'
@
text
@d1055 3
a1057 3
        LDR     r2, CPUClkDevice
        LDR     r0, [r2, #HALDevice_Version]
        CMP     r0, #(0:SHL:16):OR:2    
d1061 1
a1061 1
        LDR     pc, [r2, #HALDevice_CPUClkGetDieTemperature]
@


1.5
log
@Minor cleanups
* A few redundant includes removed
* Use ObjAsm {TRUE} and {FALSE}
* Since there's no command table, don't declare the messages file in the module header
* Use WFI directly instead of DCI &E320F003
* Remove *FreezeTime command help from messages
Built, but not tested.

Version 0.75. Tagged as 'PortableHAL-0_75'
@
text
@d72 1
d210 1
d295 1
d322 1
d1018 57
@


1.4
log
@Add initial implementation of the new HAL friendly BMU interface
Detail:
  hdr/BMUDevice - New header describing layout of BMU HAL devices
  Makefile - export hdr/BMUDevice, and a C version of hdr/Portable
  hdr/Portable - Lots of new definitions related to the BMU interface. VirtualRPC BMU vars renamed slightly to match the A4/HAL naming convention (PortableBMUV_) instead of the Stork naming convention (Portable_BMUVar_).
  s/Front, s/GetAll, s/StPortable - BMU interface implementation. Two new SWIs (Portable_EnumerateBMU & Portable_ReadBMUVariables) are provided, along with a semi backwards compatible Portable_ReadBMUVariable implementation. Code also updated to use OSHW_ constants instead of magic numbers.
  Resources/UK/Messages - New error message text added
Admin:
  Tested in ROM on BB-xM, Pandora, TouchBook


Version 0.73. Tagged as 'PortableHAL-0_73'
@
text
@d27 1
a27 1
        DCD     0
d30 1
a30 1
        DCD     0
d33 1
a33 1
        DCD     0
d37 2
a38 6
        DCD     0
 [ International_Help <> 0
        DCD     messagefilename - Module_BaseAddr
 |
        DCD     0
 ]
a198 1
;        MakeErrorBlock  BadHard
d499 1
a499 1
        DCI     &E320F003 ; WFI
@


1.3
log
@Add code for controlling CPU speed via interacting with a CPUClk HAL device.
Detail:
  Makefile, hdr/CPUClkDevice - Add HALDevice_CPUClk descriptor to header exports
  hdr/Portable - Trim some obsolete definitions, tidy formatting, add Speed2 and (unimplemented) WakeTime SWI numbers, add BatteryTimeRemaining and MaxBatteryTime BMU variables (from VirtualRPC)
  s/Front, s/GetAll, s/StPortable - Added Portable_Speed and Portable_Speed2 implementations, for controlling CPU speed. Portable_Speed is fully compatible with the old A4 version; all new features are exposed via Portable_Speed2 instead. Also added some debug-only stats logging code to track how much time is spent in various states.
  Resources/UK/Messages - New error messages.
Admin:
  Tested on rev C2 BB, A2 BB-xM, C1 TouchBook.
  Portable_Speed2 & HALDevice_CPUClk documentation will be on the wiki soon.


Version 0.70. Tagged as 'PortableHAL-0_70'
@
text
@d74 2
d100 2
a101 1
Init    Entry   "R7-R8"
d124 1
a124 1
        MOV     R8, #4
d155 1
a155 1
        MOV     R8, #0
d177 12
d209 5
d229 2
a230 1
Die     Entry
d233 10
d296 2
d322 2
a334 1
SWI_ReadBMUVariable
d441 1
a441 1
        MOV     R8, #0
d465 1
a465 1
        MOV     R8, #0
d498 1
a498 1
        MOV     R8, #0
d713 1
a713 1
        MOV     R8, #0
d750 271
@


1.2
log
@Tweak Portable_Idle implementation in PortableHAL module
Detail:
  In an attempt to solve a problem that doesn't exist, my Portable_Idle implementation was taking measures to avoid executing the WFI instruction if the module might have been running on pre-ARMv3 hardware.
  However I've since discovered that this was unnecessary, since WFI degrades to a NOP MSR on pre-ARMv6K, and MSR itself is a NOP on pre-ARMv3.
Admin:
  Untested, but should be safe.


Version 0.69. Tagged as 'PortableHAL-0_69'
@
text
@d72 2
d98 1
a98 1
Init    Entry   "R7"
d101 2
a102 1
        BNE     %FT10                           ;as part of RMTidy
d111 3
d115 59
a173 1
        MOV     R12, R2
a179 2
;>>>do I need Path variable stuff?

d192 2
d212 19
a236 3
;
; Brightness and Contrast is left 'as is'.
;
d258 1
a258 2
 [ SwindellCode
   ;     B       SWIPortable_Contrast
d261 4
a264 2
       ;B       SWISleepTime
 ]
d282 1
a282 2
   ;     =       "Contrast",0
 [ SwindellCode
d285 4
a288 1
 ]
d296 1
d298 1
d305 6
d323 2
a324 2
;   R1  = bit 4 set to indicate SWI Portable_Idle is impletemted
;         bit 5 set to indicate SWI Portable_Stop is impletemted
d354 5
a358 1
        CLRV
d361 85
d457 103
a559 6
SWIIdle 
       ;DLINE   "SWIIdle"
       ; Although the WFI instruction was only introduced in ARMv6K, it behaves as a nop MSR on earlier architectures. And MSR itself behaves as a NOP on pre-ARMv3. So we don't have to do anything special to avoid crashing if we get called while running on an unsupported architecture.
       DCD   &E320F003 ; WFI
       CLRV
       MOV   PC, LR
d561 144
d706 7
@


1.1
log
@Add initial version of PortableHAL, bare-bones 32bit-safe Portable module
Detail:
  Currently only supporte the Portable_Idle and Portable_Features SWIs.
  Portable_Idle is implemented using the WFI instruction found in ARMv6K+, but the module should compile and run on any architecture.
Admin:
  Tested on rev C2 beagleboard

Version 0.68. Tagged as 'PortableHAL-0_68'
@
text
@d279 1
a279 6
       ; The WFI instruction has the encoding of a NOP MSR - so anything supporting MSR is good
       ; But on ARMv1/2 it appears to have the encoding of TEQP R0,#3, which would be quite bad to execute
    [ NoARMv3
       TEQ   PC, PC ; NE if SVC26, and therefore < ARMv6K
       DCD   &0320F003 ; WFIEQ
    |
a280 1
    ]
@


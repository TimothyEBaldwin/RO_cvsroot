head	4.8;
access;
symbols
	SCInter-0_27:4.8
	dellis_autobuild_BaseSW:4.8
	SCInter-0_26:4.8
	sbrodie_sedwards_16Mar2000:4.8
	SCInter-0_25:4.8
	SCInter-0_24:4.8
	wturner_scinter2:4.1.7.11
	wturner_scinter1:4.1.7.10
	SCInter-0_23:4.7
	SCInter-0_22:4.6
	SCInter-0_21:4.5
	dcotton_autobuild_BaseSW:4.8
	dcotton_scinter_MPTInitialBuild:4.1.7.10
	SCInter-0_20:4.5
	SCInter-0_19:4.4
	SCInter-0_18:4.2
	SCInter-0_17-1_1_2_5:4.1.7.10
	SCInter-0_17-1_1_2_4:4.1.7.9
	SCInter-0_17-1_1_2_3:4.1.7.9
	SCInter-0_17-1_1_2_2:4.1.7.9
	afrost_Funai01-33:4.1.7.7
	afrost_NC2_Generic:4.1.7.7
	Spinner_RCA116:4.1.7.7
	Spinner_B20_2:4.1.7.7
	Spinner_19_3:4.1.7.7
	Spinner_B18:4.1.7.7
	Spinner_B17:4.1.7.7
	Spinner_B15:4.1.7.7
	Spinner_B14:4.1.7.6
	Spinner_B13:4.1.7.5
	Spinner_B12:4.1.7.5
	Spinner_B10:4.1.7.3
	Spinner_B7:4.1.7.2
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.10
	MergeFiles:4.1.7.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1;
locks; strict;
comment	@# @;


4.8
date	99.12.01.11.44.29;	author wturner;	state Exp;
branches;
next	4.7;

4.7
date	99.11.17.08.49.26;	author dcotton;	state Exp;
branches;
next	4.6;

4.6
date	99.11.16.13.35.30;	author dcotton;	state Exp;
branches;
next	4.5;

4.5
date	99.01.14.16.41.05;	author apirozek;	state Exp;
branches;
next	4.4;

4.4
date	99.01.04.15.56.42;	author apirozek;	state Exp;
branches;
next	4.3;

4.3
date	98.12.16.16.20.16;	author apirozek;	state Exp;
branches;
next	4.2;

4.2
date	98.12.11.19.10.12;	author smiddle;	state Exp;
branches;
next	4.1;

4.1
date	96.11.21.12.06.59;	author nturton;	state Exp;
branches
	4.1.5.1
	4.1.7.1;
next	;

4.1.5.1
date	96.11.21.12.06.59;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.55.03;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.01.29.13.50.55;	author rbuckley;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.05.09.15.55.44;	author rbuckley;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.05.22.14.26.38;	author rbuckley;	state Exp;
branches;
next	4.1.7.5;

4.1.7.5
date	97.05.30.15.57.14;	author rbuckley;	state Exp;
branches;
next	4.1.7.6;

4.1.7.6
date	97.06.18.12.36.38;	author rbuckley;	state Exp;
branches;
next	4.1.7.7;

4.1.7.7
date	97.06.24.11.21.36;	author rbuckley;	state Exp;
branches;
next	4.1.7.8;

4.1.7.8
date	98.09.07.12.36.54;	author kbracey;	state Exp;
branches;
next	4.1.7.9;

4.1.7.9
date	98.11.24.12.13.22;	author apirozek;	state Exp;
branches;
next	4.1.7.10;

4.1.7.10
date	98.12.11.19.05.58;	author smiddle;	state Exp;
branches;
next	4.1.7.11;

4.1.7.11
date	99.11.22.13.37.36;	author wturner;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Added a SWI to control whether SCInterface listens to events from
the SCTransport module or not. This is part of the CTS work, and
in the absence of any locally stored specification, siis documented
in Docs.EventsSWI

Version 0.24. Tagged as 'SCInter-0_24'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

/*
 * This module provides an abstraction to the smart card transport module by
 * implementing some primitive filing system operations.
 *
 * Modification History
 *---------------------
 *
 * 14-Jun-96  RWB,  Created.
 * 28-Jun-96  RWB,  Fixed a few bugs in the card read/write routines.
 * 07-Aug-96  RWB,  Backoff if SCTransport module not ready yet.
 * 28-Aug-96  RWB,  Removed redundant parameter in unblockchv functions.
 * 28-Aug-96  RWB,  Check for never access condition before a verifychv.
 * 29-Aug-96  RWB,  Added Status swi for polled operation.
 * 08-Oct-96  RWB,  Modified the ordering of InternalAuthenticate
 * 22-May-97  RWB,  get_atr does not check atr length
 * 03-Nov-98  RML,  *SCInterInfo now shows current card type (corresponds
 *                  to value of i in CARDS_POPULATE, in h.cards).
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include "kernel.h"
#include "swis.h"
#include "sctrans.h"
#include "module.h"
#include "irqs.h"
#include "header.h"
#include "scinter.h"
#include "machine.h"
#include "cards.h"
#include "path.h"
#include "records.h"

#include "Debuglib/Debuglib.h"

/*
 * table used to identify which card is present
 */
t_card_exports *CardExports[SUPPORTED_CARDS];
t_card_exports *CurrExports = NULL;

/*
 * special chimpanzee processing
 */
int ChimpanzeeClassByte=0xa0;

int current_card_type=-1;

#ifdef DEBUGLIB
  debug_device DebugOutputDevice = FILE_OUTPUT;
#endif /* DEBUGLIB */


/*
 * module housekeeping globals
 */
void   *workspace_pointer = NULL;
#ifdef USE_TINY
static _kernel_oserror *TinyError;
#endif
int card_handle = -1;
t_card_atr ATR;

#ifdef DEBUGLIB
char *strNotifications[] = {"CardOK","CardBad","CardRemoved","Complete"};
char *strState[] = {"WaitingOpen","WaitingATR","WaitingRemoval","Idle",
"SelectingDir","SelectingFile","GettingResponse","GettingAuthResponse",
"Creating","Deleting","ReadingFile","WritingFile","VerifyingCHV","ChangingCHV",
"EnablingCHV","UnBlockingCHV","WaitingInternalAuth","WaitingTrans","WaitingStandby"};
char *strTransitions[] = {"Done","Error","Removed","ReStart","TransEnd",
"CreateSWI","DeleteSWI","ReadSWI","WriteSWI","GetATRSWI","ChangeCHVSWI",
"EnableCHVSWI","UnBlockCHVSWI","FileInfoSWI","InternalAuthSWI","StatusSWI","Shutdown","Standby"};
#else
char *strNotifications[] = {""};
char *strState[] = {""};
char *strTransitions[] = {""};
#endif
/*
 * event handling globals
 */
t_event Events[MAX_EVENTS];             /* generic event queue */
int next_event = -1;
int free_event = 0;
int flag_event_pending = FALSE;
t_states state = WaitingOpen;
t_transitions entry_trans;
#ifdef MINIJIS_CARD
int first_init;
#endif
int global_ignore_events = 0;


/******************************************************************************
  process the asynchronous events
 ******************************************************************************/
_kernel_oserror *sc_event_handler(_kernel_swi_regs *r, void *pw)
{
  int  this_event = 0;
  int  this_handle = 0;
  int  old_irqs;

  dprintf(("", "sc_event_handler()\n"));

  while (next_event != free_event)
  {
    if (next_event == -1) break;

    /* need to protect against queue changing behind our backs */
    old_irqs = irqs_off();
    this_handle = Events[next_event].handle;
    this_event = Events[next_event].event;
    irqs_on(old_irqs);

#ifdef MINIJIS_CARD
    if (( this_handle ==card_handle) || ( this_event ==SCI_STANDBY))
#else
    if ( this_handle ==card_handle)
#endif
    {
      switch(this_event)
      {
        case SCI_REMOVED:
          dprintf(("", "sc_event_handler(): event SCI_REMOVED\n"));
          machine(Removed,r);
          break;

        case SCI_TRANS_END:
          dprintf(("", "sc_event_handler(): event SCI_TRANS_END\n"));
          machine(TransEnd,r);
          break;

        case SCI_CMD_DONE:
          dprintf(("", "sc_event_handler(): event SCI_CMD_DONE\n"));
          machine(Done,r);
          break;

        case SCI_ERROR:
          dprintf(("", "sc_event_handler(): event SCI_ERROR\n"));
          machine(Error,r);
          break;

#ifdef MINIJIS_CARD
        case SCI_STANDBY:
          dprintf(("", "sc_event_handler(): event SCI_STANDBY\n"));
          if ( first_init ==FALSE)
            machine(Standby,r);
          else
            first_init =FALSE;
          break;
#endif
      }
    }

    /* need to protect against queue changing behind our backs */
    old_irqs = irqs_off();
    if (next_event>=0) next_event++;
    if (next_event==MAX_EVENTS) next_event=0;
    irqs_on(old_irqs);
  }

  old_irqs = irqs_off();
  flag_event_pending = FALSE;
  next_event = -1;
  irqs_on(old_irqs);

  return (NULL);
}

/******************************************************************************
  setup a callback to deal with an event.
 ******************************************************************************/
_kernel_oserror *setup_event(int iHandle, int ithis_event)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;
  int old_irqs;

  dprintf(("", "setup_event()\n"));

  if (free_event != next_event)
  {
    old_irqs = irqs_off();
    if (next_event == -1) next_event = free_event;
    Events[free_event].handle = iHandle;
    Events[free_event].event = ithis_event;
    free_event++;
    if (free_event==MAX_EVENTS) free_event=0;
    irqs_on(old_irqs);
    /*
     * see if event handler needs to be established
     */
    if (!flag_event_pending)
    {
      reg.r[0] = (int)sc_event_entry;
      reg.r[1] = (int)workspace_pointer;
      ERR_RETURN(err,_kernel_swi(OS_AddCallBack, &reg, &reg));
      flag_event_pending = TRUE;
    }
  }

  return (NULL);
}

/******************************************************************************
  handle events, select ones of interest to us
 ******************************************************************************/
int event_handler(_kernel_swi_regs *r, void *pw)
{
  if (r->r[0] == Event_Expansion)
  {
    dprintf (("", "event_handler(): Event:%d\n", r ->r[ 0]));
    if (r->r[1] == Event_Expansion_SCTransport)
    {
      if(global_ignore_events == 0)
      {
        dprintf (("", "event_handler(): Event_Expansion_SCTransport handle:%d  reason:%d  slot:%d[%x]\n", r->r[2], r->r[3], r->r[4], r ->r[4]));
        if ( r ->r[ 2] !=0xffff)
        {
          setup_event(r->r[2],r->r[3]);
          dprintf (("", "event_handler(): Callback setup\n"));
        }
      }
    }
  }

  return (1); /* pass on */
}

/******************************************************************************
  claims vectors and enables the events as required
 ******************************************************************************/
_kernel_oserror *claim_vectors(void)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;

    dprintf (("", "claim_vectors()\n"));

  /*
   * claim vectors
   */
  reg.r[0] = EventV;
  reg.r[1] = (int)event_entry;
  reg.r[2] = (int)workspace_pointer;
  ERR_RETURN(err,_kernel_swi(OS_Claim, &reg, &reg));

  /*
   * enable Expansion event
   */
  reg.r[0] = 14;
  reg.r[1] = Event_Expansion;
  ERR_RETURN(err,_kernel_swi(OS_Byte, &reg, &reg));

  return (NULL);
}

/******************************************************************************
  release vectors, flush any callbacks and disable events
 ******************************************************************************/
_kernel_oserror *release_vectors(void)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;

    dprintf (("", "release_vectors()\n"));

  /*
   * disable event
   */
  reg.r[0] = 13;
  reg.r[1] = Event_Expansion;
  ERR_RETURN(err,_kernel_swi(OS_Byte, &reg, &reg));

  /*
   * release vectors
   */
  reg.r[0] = EventV;
  reg.r[1] = (int)event_entry;
  reg.r[2] = (int)workspace_pointer;
  ERR_RETURN(err,_kernel_swi(OS_Release, &reg, &reg));

  return (NULL);
}

/******************************************************************************
  module service, only dealing with service_NCTransportStarting
 ******************************************************************************/
void module_service(int service_number, _kernel_swi_regs *r, void *pw)
{
  dprintf(("", "module_service(): module service 0x%x\n",r->r[1]));
  switch (service_number)
  {
    case Service_SCTransportStarting:
      dprintf (("", "module_service(): sctransport starting\n"));
      machine(ReStart,r);
      break;

#ifdef MONITOR_STANDBY
#ifdef MINIJIS_CARD
    case Service_ShutdownComplete:
      /* SJM: 8Dec97: Need to forget about card when we shutdown as
         Funai micro doesn't notify us of events that occur whilst in
         its in standby */
      dprintf (("", "module_service(): Shutdown complete\n"));
      if (card_handle != -1)
        machine(Shutdown,r);
      break;

#endif
#ifdef MINIJIS_CARD
    case Service_Standby:
      /* SJM: 8Dec97: */
      dprintf (("", "module_service(): Standby pressed (r0:%x)\n", r->r[0]));
      if ((r->r[0] & 1) == 0) /* box waking up */
        setup_event( 0, SCI_STANDBY);
      if (r->r[0] == 1) /* box sleeping */
      {
        dprintf (("", "module_service(): Power control_down SWI called\n\n"));
        sctransport_powercontrol ( SCI_POWER_DOWN, 1);
        sctransport_powercontrol ( SCI_POWER_DOWN, 2);
      }
      break;
#endif
#endif
  }
}

/******************************************************************************
  broadcast a message using the SCInterface event
 ******************************************************************************/
void module_notify(int reason,int param)
{
  _kernel_swi_regs reg;

  dprintf(("", "module_notify(): notify '%s', 0x%x\n",
  	strNotifications[reason],param));

  reg.r[0] = Event_Expansion;
  reg.r[1] = Event_Expansion_SCInterface;
  reg.r[2] = reason;
  reg.r[3] = param;
  _kernel_swi(OS_GenerateEvent,&reg,&reg);
}

/******************************************************************************
  simple printf without using stdio
 ******************************************************************************/
void my_printf(char *format, ...)
{
  _kernel_swi_regs reg;
  char strLine[80];
  va_list list;

  va_start(list, format);
  vsprintf(strLine,format,list);
  va_end(list);

  reg.r[0] = (int)strLine;
  _kernel_swi(OS_Write0,&reg,&reg);
  _kernel_swi(OS_NewLine,&reg,&reg);
}

/******************************************************************************
  cli_handler
 ******************************************************************************/
_kernel_oserror *module_cli ( const char *arg_string, int arg_count,
                              int cmd_no, void *pw)
{
  switch (cmd_no)
  {
    case CMD_SCInterInfo :
      my_printf("   State       : %d",state);
      my_printf("   Entry trans : %d",entry_trans);
      my_printf("   Card type   : %d",current_card_type);

      break;
  }
  return (NULL);
}

/******************************************************************************
  module finalise
 ******************************************************************************/
_kernel_oserror *module_finalise(int fatal, int podule, void *pw)
{
  _kernel_oserror *err = NULL;

  if (card_handle>=0) sctransport_close(card_handle);

  ERR_RETURN(err,release_vectors());

  dprintf(("", "module_finalise(): finalisation"));

#ifdef USE_TINY
  if ( TinyError == NULL ) _swix( TinySupport_Die, 0 );
#endif

  return NULL;

  NOT_USED( fatal );
  NOT_USED( podule );
}

/******************************************************************************
  module initialise
 ******************************************************************************/
_kernel_oserror *module_initialise ( const char *cmd_tail, int podule_base,
                                     void *pw)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;
  int i;

  workspace_pointer = pw;
#ifdef MINIJIS_CARD
  first_init =TRUE;
#endif


#ifdef DEBUGLIB
  debug_initialise ("SCInterface", "izipfs:$.SCInterlog", "");
  debug_atexit ();
  debug_output_device (DebugOutputDevice);   /* Output debug info via pdebug */
#ifdef ALLOW_BUFFERED_DEBUGLIB_OUTPUT
  debug_output_buffer_on (0, 4096);
#else
#endif /* ALLOW_BUFFERED_DEBUGLIB_OUTPUT */
#endif /* ENABLE_DEBUGLIB */

#ifdef USE_TINY
  /*
   * try to use TinyStubs if possible.
   */
  reg.r[0] = (int)workspace_pointer;
  TinyError = _kernel_swi(TinySupport_Share, &reg, &reg);
#endif

  /*
   * initialise the event queue
   */
  for (i=0; i<MAX_EVENTS; i++)
  {
    Events[i].handle = 0;
    Events[i].event = 0;
  }

  /*
   * initialise the system
   */

  ERR_RETURN(err,claim_vectors());

  /*
   * populate array of card exports here and initialise them
   */
  CARDS_POPULATE(CardExports);

  for (i=0; i<SUPPORTED_CARDS; i++)
    (*(CardExports[i])->card_initialise_table)();

  machine(ReStart,&reg);

  return (NULL);
}

/******************************************************************************
  module swi handler
 ******************************************************************************/
_kernel_oserror *module_swi( int swi_no, _kernel_swi_regs *r, void *pw )
{
  dprintf (("", "module_swi()L swi number %d\n", swi_no));

  switch (swi_no+SCInterface_00)
  {
    case SCInterface_Create:
      dprintf(("", "module_swi(): SWI: SCInterface_Create\n"));
      if (CurrExports->card_create == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(CreateSWI,r);
      break;

    case SCInterface_Delete:
      dprintf(("", "module_swi(): SWI: SCInterface_Delete\n"));
      if (CurrExports->card_delete == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(DeleteSWI,r);
      break;

    case SCInterface_Read:
      dprintf(("", "module_swi(): SWI: SCInterface_Read\n"));
      if (CurrExports->card_read == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(ReadSWI,r);
      break;

    case SCInterface_Write:
      dprintf(("", "module_swi(): SWI: SCInterface_Write\n"));
      if (CurrExports->card_write == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(WriteSWI,r);
      break;

    case SCInterface_GetATR:
      dprintf(("", "module_swi(): SWI: SCInterface_GetATR\n"));
      machine(GetATRSWI,r);
      break;

    case SCInterface_ChangeCHV:
      dprintf(("", "module_swi(): SWI: SCInterface_ChangeCHV\n"));
      if (CurrExports->card_change_chv == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(ChangeCHVSWI,r);
      break;

    case SCInterface_EnableCHV:
      dprintf(("", "module_swi(): SWI: SCInterface_EnabledCHV\n"));
      if (CurrExports->card_enable_chv == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(EnableCHVSWI,r);
      break;

    case SCInterface_UnBlockCHV :
      dprintf(("", "module_swi(): SWI: SCInterface_UnblockCHV\n"));
      if (CurrExports->card_unblock_chv == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(UnBlockCHVSWI,r);
      break;

    case SCInterface_FileInfo :
      dprintf(("", "module_swi(): SWI: SCInterface_FileInfo\n"));
      if (CurrExports->card_get_response == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(FileInfoSWI,r);
      break;

    case SCInterface_InternalAuth :
      dprintf(("", "module_swi(): SWI: SCInterface_InternalAuth\n"));
      if (CurrExports->card_internal_auth == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(InternalAuthSWI,r);
      break;

    case SCInterface_Status :
      dprintf(("", "module_swi(): SWI: SCInterface_Status\n"));
      machine(StatusSWI,r);
      break;
      
    case SCInterface_Events :
      if(r->r[0] == 0) /** Ignore events **/
      {
        if(r->r[1] == 1)
        {
          global_ignore_events++;
        }
        else if(r->r[1] == 0)
        {
          if(global_ignore_events > 0) global_ignore_events--;
        }
        r->r[1] = global_ignore_events; /* Return the counter value **/
      }
      else if (r->r[0] == 1) /** Fake events **/
      {
        /** R1 contains the event number to fake **/
        setup_event(r->r[2],r->r[3]);
      }
      break;
  }
  return (NULL);

  NOT_USED( pw);
}

/******************************************************************************
  copy the values in r_old into r_new only r0-r10
 ******************************************************************************/
void _copy_regs(_kernel_swi_regs *r_new, _kernel_swi_regs *r_old)
{
  int i=9;
  dprintf(("", "copy_regs()\n"));
  do { r_new->r[i] = r_old->r[i]; } while (i--);
}

/******************************************************************************
  retrieve the cards ATR and try to obtain a match against the table of known
  ATRs

  sets CurrExports if ATR matched.

  will return SC_SUCCESS if ATR matches, SCFS otherwise
 ******************************************************************************/
int get_atr(void)
{
  int iCard,i;
  int iMisMatch;
  int ret;

  dprintf(("", "get_atr()\n"));

  ret=sctransport_retrieve_atr(card_handle,ATR.hist,sizeof(ATR.hist),&ATR.len);
  dprintf(("", "get_atr(): ATR length %d ret %d\n",ATR.len,ret));
#ifdef MINIJIS_CARD
  /* if theres no atr then its a minijis :-) */
  if ( ATR.len >=0)
  {
    iCard =3;
    CurrExports = CardExports[iCard];
    current_card_type = iCard;
    return (SC_SUCCESS);
  }
#endif
  if (ret == SCI_SUCCESS)
  {
    for (iCard=0; iCard<SUPPORTED_CARDS; iCard++)
    {
      iMisMatch = 0;
      i=0;
      while (i<CardExports[iCard]->card_atr->significant && !iMisMatch)
      {
        if (ATR.hist[i]!=CardExports[iCard]->card_atr->hist[i])
          iMisMatch++;
        i++;
      }

      if (iMisMatch == 0)
      {
        CurrExports = CardExports[iCard];
        current_card_type = iCard;
        return (SC_SUCCESS);
      }
    }
  }
  return (SC_UNDERSTAND);
}

/******************************************************************************
  attempt to open a smart card connection

  will return SC_SUCCESS for success, SC_TRANSPORT for SCTransport errors,
  SC_UNDERSTAND for unrecognised card.
 ******************************************************************************/
int open_card(void)
{
  int ret;
  int err;

  current_card_type = -1;
  CurrExports = NULL;

  dprintf(("", "open_card()\n"));

  ret = sctransport_open(1,&card_handle);
  dprintf(("", "open_card(): open card channel result %d\n", ret));
  if (ret==SCI_FAIL)
  {
    err = sctransport_error(card_handle);
    dprintf(("", "open_card(): open card channel returned error %d\n", err));
    if (err==SCI_FAIL)
      return (SC_TRANSPORT);
  }

  dprintf(("", "open_card(): opened card channel %d\n",card_handle));
#ifdef wibble
  ret =sctransport_start_trans( card_handle);
  if (ret==SCI_FAIL)
  {
    err = sctransport_error(card_handle);
    if (err==SCI_FAIL)
      return (SC_TRANSPORT);
  }
#endif
  dprintf(("", "open_card(): started transport (ret:%d)\n", ret));

  if (ret==SCI_FAIL && err!=SCI_E_OUT)
  {
    dprintf(("", "open_card(): don't understand card\n"));
    card_handle = -1;
    return (SC_UNDERSTAND);
  }

  return (SC_SUCCESS);
}

/******************************************************************************
  does a read response into the given data area and checks the response
  codes against the ones given. Returns success if response codes match.
  response code should be -1 to ignore.
 ******************************************************************************/
int handle_response(BYTE *card_data, int data_len, int *length, BYTE resp[2])
{
  int ret;
  int i,j;
  int swA;
  int swB;
  int req_match;

  dprintf(("", "handle_response()\n"));

  ret=sctransport_read_response(card_handle,card_data,data_len,length,resp);
  if (ret != SCI_SUCCESS)
  {
    ret = sctransport_error(card_handle);
    dprintf(("", "handle_response(): sctransport_error %d (0x%x)\n",ret,ret));
    if (ret != SCI_E_TRUNC) /* ignore truncation errors */
      return (SC_TRANSPORT);
  }

  dprintf(("", "handle_response(): received response %02x %02x\n",resp[0],resp[1]));

  swA = resp[0]<<8 | resp[1];

  for (i=0; i<CurrExports->card_num_responses; i++)
  {
    int match = 0;
    j=16;
    req_match = CurrExports->card_responses[i].sw>>16 & 0xff;
    swB = CurrExports->card_responses[i].sw & 0xffff;

    do
    {
      j-=4;
      if ((swB>>j & 0xf) == (swA>>j & 0xf))
        match++;
      else
        break;
    } while (j);
    if (match >= req_match)
      return (CurrExports->card_responses[i].err);
  }
  dprintf(("", "handle_response(): response 0x%x unknown\n",swA));

  return (SC_UNKNOWNRESP);
}
@


4.7
log
@	Added a little more debugging.
Detail:
	Added more debugging, especially to the SWI handling routines.
Admin:
	Tested as a debugging softload and in a Funai 4 build.

Version 0.23. Tagged as 'SCInter-0_23'
@
text
@d116 3
d240 1
a240 2
      dprintf (("", "event_handler(): Event_Expansion_SCTransport handle:%d  reason:%d  slot:%d[%x]\n", r->r[2], r->r[3], r->r[4], r ->r[4]));
      if ( r ->r[ 2] !=0xffff)
d242 6
a247 2
        setup_event(r->r[2],r->r[3]);
        dprintf (("", "event_handler(): Callback setup\n"));
d581 20
@


4.6
log
@	Changed the component to use srccommit.
Detail:
	This component would not build with the latest version of RemoteDB as
the names used have been changed. Have used this opportunity to alter the
component to use DebugLib. There have been no functionality changes.
	Default output mechanism is to zip disc.
	Altered the makefile to use Stripdepend.
Admin:
	Tested as a softload on a Funai 4 build and actually in a Funai 4
build.

Version 0.22. Tagged as 'SCInter-0_22'
@
text
@d125 2
d146 1
a146 1
          dprintf(("", "sc_event_handler(): * event SCI_REMOVED\n"));
d151 1
a151 1
          dprintf(("", "sc_event_handler(): * event SCI_TRANS_END\n"));
d156 1
a156 1
          dprintf(("", "sc_event_handler(): * event SCI_CMD_DONE\n"));
d161 1
a161 1
          dprintf(("", "sc_event_handler(): * event SCI_ERROR\n"));
d167 1
a167 1
          dprintf(("", "sc_event_handler(): * event SCI_STANDBY\n"));
d201 2
d257 2
d285 2
d491 2
d496 1
d504 1
d533 1
d541 1
d549 1
d565 1
d573 1
d588 1
d606 2
d658 2
d704 2
@


4.5
log
@Altered code to ignore events for slot 2

Version 0.20. Tagged as 'SCInter-0_20'
@
text
@d60 2
d75 4
a78 3
#ifdef REMOTE_DEBUG
debug_session *db=NULL;
#endif
d90 1
a90 1
#ifdef debug
d144 1
a144 3
#ifdef debug
          printf("SCINTERFACE: * event SCI_REMOVED\n");
#endif
d149 1
a149 3
#ifdef debug
          printf("SCINTERFACE: * event SCI_TRANS_END\n");
#endif
d154 1
a154 3
#ifdef debug
          printf("SCINTERFACE: * event SCI_CMD_DONE\n");
#endif
d159 1
a159 3
#ifdef debug
          printf("SCINTERFACE: * event SCI_ERROR\n");
#endif
d165 1
a165 3
#ifdef debug
          printf("SCINTERFACE: * event SCI_STANDBY\n");
#endif
d230 1
a230 3
#ifdef debug
    printf ( "SCINTERFACE: Event:%d\n", r ->r[ 0]);
#endif
d233 1
a233 3
#ifdef debug
      printf ( "SCINTERFACE: Event_Expansion_SCTransport handle:%d  reason:%d  slot:%d[%x]\n", r->r[2], r->r[3], r->r[4], r ->r[4]);
#endif
d237 1
a237 3
#ifdef debug
        printf ( "Callback setup\n");
#endif
d302 1
a302 3
#ifdef debug
  printf("SCINTERFACE: module service 0x%x\n",r->r[1]);
#endif
d306 1
a306 3
#ifdef debug
      printf ( "SCINTERFACE: sctransport starting\n");
#endif
d316 1
a316 3
#ifdef debug
      printf ( "SCINTERFACE: Shutdown complete\n");
#endif
d325 1
a325 3
#ifdef debug
      printf ( "SCINTERFACE: Standby pressed (r0:%x)\n", r->r[0]);
#endif
d330 1
a330 3
#ifdef debug
        printf ( "SCINTERFACE: Power control_down SWI called\n\n");
#endif
d347 2
a348 4
#ifdef debug
  printf("SCINTERFACE: notify '%s', 0x%x\n",
  	strNotifications[reason],param);
#endif
d404 1
a404 6
#ifdef debug
  printf("SCINTERFACE: finalisation");
#endif
#ifdef REMOTE_DEBUG
  remote_debug_close(db);
#endif
d430 12
a461 3
#ifdef REMOTE_DEBUG
  remote_debug_open(Module_Title,&db);
#endif
d500 1
a500 3
#ifdef debug
      printf ( "SCINTERFACE: SWI: SCInterface_Read\n");
#endif
d508 1
a508 3
#ifdef debug
      printf ( "SCINTERFACE: SWI: SCInterface_Write\n");
#endif
d516 1
a516 3
#ifdef debug
      printf ( "SCINTERFACE: SWI: SCInterface_GetATR\n");
#endif
d542 1
a542 3
#ifdef debug
      printf ( "SCINTERFACE: SWI: SCInterface_FileInfo\n");
#endif
d589 1
a589 3
#ifdef debug
  printf("SCINTERFACE: ATR length %d ret %d\n",ATR.len,ret);
#endif
d639 1
a639 3
#ifdef debug
  printf("SCINTERFACE: open card channel result %d\n", ret);
#endif
d643 1
a643 3
#ifdef debug
    printf("SCINTERFACE: open card channel returned error %d\n", err);
#endif
d648 1
a648 3
#ifdef debug
  printf("SCINTERFACE: opened card channel %d\n",card_handle);
#endif
d658 1
a658 3
#ifdef debug
  printf("SCINTERFACE: started transport (ret:%d)\n", ret);
#endif
d662 1
a662 3
#ifdef debug
    printf("SCINTERFACE: don't understand card\n");
#endif
d687 1
a687 3
#ifdef debug
    printf("SCINTERFACE: sctransport_error %d (0x%x)\n",ret,ret);
#endif
d692 1
a692 4
#ifdef debug
  printf("SCINTERFACE: received response %02x %02x\n",resp[0],resp[1]);
#endif
  /* printf("  Received response %02x %02x\n", resp[0], resp[1]); */
d714 1
a714 4
#ifdef debug
  printf("SCINTERFACE: response 0x%x unknown\n",swA);
#endif
  /* printf("  Unknown response.\n"); */
@


4.4
log
@Integrated restart callback handler into main handler code
@
text
@d132 5
a136 1
    if (1==1 /*this_handle == card_handle*/)
d243 7
a249 1
      printf ("SCINTERFACE: Event_Expansion_SCTransport handle:%d  reason:%d  slot:%d[%x]\n", r->r[2], r->r[3], r->r[4], r ->r[4]);
d251 1
a251 1
      setup_event(r->r[2],r->r[3]);
@


4.3
log
@Added code to deal with card removal/chainging during power down
@
text
@d150 1
a150 1
        case SCI_CMD_DONE :
d157 1
a157 1
        case SCI_ERROR :
d163 12
d194 1
a194 1
  setup a callback to deal with the serial event.
a299 21
#ifdef MINIJIS_CARD
/******************************************************************************
  parameters:
     returns:
 ******************************************************************************/
_kernel_oserror *restart_cb ( _kernel_swi_regs *r, void *pw)
{
  if ( first_init ==FALSE)
  {
#ifdef debug
    printf ( "SCINTERFACE: standby callback handler\n");
#endif
    machine(Standby,r);
  }
  else
    first_init =FALSE;

  return NULL;
}
#endif

a304 2
  _kernel_swi_regs regs;

d338 1
a338 5
      {
        regs.r [ 0] =( int)restart_cb_v;
        regs.r [ 1] =( int)workspace_pointer;
        _kernel_swi ( OS_AddCallBack, &regs, &regs);
      }
d447 1
d449 1
@


4.2
log
@Moved to trunk.

Version 0.18. Tagged as 'SCInter-0_18'
@
text
@d110 3
a112 1

d132 1
a132 1
    if (this_handle == card_handle)
d138 1
a138 1
          printf("SCINTERFACE: event SCI_REMOVED\n");
d145 1
a145 1
          printf("SCINTERFACE: event SCI_TRANS_END\n");
d151 3
d159 1
a159 1
          printf("SCINTERFACE: event SCI_ERROR\n");
a213 1

d221 3
d226 3
d288 21
d314 2
d317 1
a317 1
  printf("SCINTERFACE: module service %x\n",r->r[1]);
d321 4
a324 1
  case Service_SCTransportStarting:
d330 1
a330 1
  case Service_ShutdownComplete:
d332 5
a336 2
         Funai micro doesn't notify us of events that occur whilst int
         is in standby */
d338 1
a338 1
	  machine(Shutdown,r);
d340 1
d343 1
a343 1
  case Service_Standby:
d345 3
d349 13
a361 1
	  machine(Standby,r);
d462 1
a462 1

d509 1
a509 1
    case SCInterface_Create :
d516 1
a516 1
    case SCInterface_Delete :
d523 4
a526 1
    case SCInterface_Read :
d533 4
a536 1
    case SCInterface_Write :
d543 4
a546 1
    case SCInterface_GetATR :
d550 1
a550 1
    case SCInterface_ChangeCHV :
d557 1
a557 1
    case SCInterface_EnableCHV :
d572 3
@


4.1
log
@Initial revision
@
text
@d16 7
a22 7
/* 	        Copyright 1996 Acorn Network Computers		        */
/*									*/
/*  This material is the confidential trade secret and proprietary	*/
/*  information of Acorn Network Computers. It may not be reproduced,   */
/*  used sold, or transferred to any third party without the prior      */
/*  written consent of Acorn Network Computers. All rights reserved.	*/
/* 									*/
d39 3
d55 1
d58 1
a58 10


/*
 * prototypes
 */
int  get_atr(void);
int  open_card(void);
int  handle_response(BYTE *card_data, int data_len, int *length, BYTE *resp);

void machine(t_transitions transition, _kernel_swi_regs *r);
d67 1
a67 1
 * veneers generated by cmhg
d69 7
a75 2
extern void event_entry(void);
extern void sc_event_entry(void);
d85 3
a87 2
static t_card_atr ATR;
#ifdef _DEBUG
d89 11
d108 7
a114 6
  static t_states state = WaitingOpen;
  static t_transitions entry_trans;
/*
 * process the asynchronous events
 */
int sc_event_handler(_kernel_swi_regs *r, void *pw)
d134 4
a137 2
        case SCI_REMOVED :
          debug DebugPrint("SCInterface: event Removed\n");
d140 5
a144 2
        case SCI_TRANS_END :
          debug DebugPrint("SCInterface: trans end\n");
d147 1
d151 1
d153 3
a155 1
          debug DebugPrint("SCInterface: event Error\n");
d173 1
a173 1
  return (1);
d176 4
a179 5
/*
 * setup a callback to deal with the serial event.
 */
_kernel_oserror *
setup_event(int iHandle, int ithis_event)
d210 4
a213 5
/*
 * handle events, select ones of interest to us
 */
int
event_handler(_kernel_swi_regs *r, void *pw)
d226 4
a229 5
/*
 * claims vectors and enables the events as required
 */
_kernel_oserror *
claim_vectors(void)
d252 4
a255 5
/*
 * release vectors, flush any callbacks and disable events
 */
_kernel_oserror *
release_vectors(void)
d278 4
a281 5
/*
 * module service, only dealing with service_NCTransportStarting
 */
void
module_service(int service_number, _kernel_swi_regs *r, void *pw)
d283 28
a310 2
  //debug DebugPrint("SCInterface: module service\n");
  machine(ReStart,r);
d313 4
a316 5
/*
 * broadcast a message using the SCInterface event
 */
void
module_notify(int reason,int param)
d319 3
a321 2
#ifdef _DEBUG
  debug DebugPrint("SCInterface: notify '%s', 0x%x\n",
d324 1
d332 4
a335 5
/*
 * simple printf without using stdio
 */
void
my_printf(char *format, ...)
d349 6
a354 5
/*
 * cli_handler
 */
_kernel_oserror *
module_cli(char *arg_string,int arg_count,int cmd_no,void *pw)
d361 1
d368 4
a371 5
/*
 * module finalise
 */
_kernel_oserror *
module_finalise(int fatal, int podule, void *pw)
d379 7
d396 5
a400 5
/*
 * module initialise
 */
_kernel_oserror *
module_initialise(char *cmd_tail, int podule_base, void *pw)
d426 1
a426 1
   * initialise the debug system
d428 3
a430 2
  debug DebugFileInit(FILENAME_DEBUG);
  debug DebugPrint("SCInterface: initialise\n");
d447 4
a450 5
/*
 * module swi handler
 */
_kernel_oserror *
module_swi( int swi_no, _kernel_swi_regs *r, void *pw )
d460 1
d467 1
d474 1
d481 1
d485 1
d492 1
d499 1
d506 1
d513 1
d520 1
d527 1
a527 1
  NOT_USED( pw );
d530 4
a533 5
/*
 * copy the values in r_old into r_new only r0-r10
 */
static void
_copy_regs(_kernel_swi_regs *r_new, _kernel_swi_regs *r_old)
d539 9
a547 611
/*
 * implement the state machine
 */
void
machine(t_transitions transition, _kernel_swi_regs *r)
{
  static _kernel_swi_regs entry;
  static int files[MAX_SUBDIRS];
  static int num_files;
  static int current_file;
  static int err;
  static int offset;
  static int chunk_size;
  static int status_error = 0;
  static int doing_retry = 0;
  BYTE file_header[22];
  BYTE resp[2];
  int data_length;
  int ret = SCI_SUCCESS;
  int access_condition;

  //debug DebugPrint("SCInterface: machine(%d)\n",transition);
  switch (transition)
  {
    case Done :
      switch (state)
      {
        case WaitingOpen :
          err = open_card();
          switch (err)
          {
            case SC_SUCCESS :
              state = WaitingATR;
              break;
	    case SC_UNDERSTAND :
              state = WaitingRemoval;
              break;
          }
          break;
        case WaitingATR :
          if (get_atr() == SC_SUCCESS)
          {
            state = Idle;
            module_notify(Event_CardOK,0);
          }
          else
          {
            state = WaitingRemoval;
            module_notify(Event_CardBad,0);
          }
          break;
	case Idle :
	  /* ingore */
	  break;
	case SelectingDir :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    if (current_file == num_files-1)   /* are we on the leaf name */
	    {
	      switch (entry_trans)
	      {
	        case CreateSWI :
	          state = Creating;
		  ret = (*CurrExports->card_create)(card_handle,
		      	files[current_file++],(entry.r[0]&1<<1)?1:0,entry.r[2],
		      	entry.r[3]);
	          break;
	        case ReadSWI : case WriteSWI :
	        case DeleteSWI : case FileInfoSWI :
    	          state = SelectingFile;
                  ret = (*CurrExports->card_select)(card_handle,
                      	files[current_file++]);
                  break;
                case ChangeCHVSWI :
                case EnableCHVSWI : case UnBlockCHVSWI :
	      	  ret = (*CurrExports->card_select)(card_handle,
	      	      	files[current_file++]);
                  break;
              }
	    }
	    else if (current_file == num_files) /* leaf name was a directory */
	    {
	      switch (entry_trans)
	      {
	        case ChangeCHVSWI :
	          state = ChangingCHV;
  		  ret = (*CurrExports->card_change_chv)(card_handle,
  		      	entry.r[2], (char*)entry.r[3], entry.r[4],
  		      	(char*)entry.r[5], entry.r[6]);
	          break;
                case EnableCHVSWI :
                  state = EnablingCHV;
		  ret = (*CurrExports->card_enable_chv)(card_handle,
		      	entry.r[2],(entry.r[0]&1<<1)?1:0,(char*)entry.r[3],
		      	entry.r[4]);
	          break;
                case UnBlockCHVSWI :
                  state = UnBlockingCHV;
   		  ret = (*CurrExports->card_unblock_chv)(card_handle,
   		      	entry.r[2], (char*)entry.r[3],
   		      	entry.r[4], (char*)entry.r[5], entry.r[6]);
                  break;
                case FileInfoSWI :
	    	  state = GettingResponse;
	    	  ret = (*CurrExports->card_get_response)(card_handle,
	    	      	(int)resp[1]);
                  if (ret == SCI_FAIL)
            	  {
		    err = SC_TRANSPORT;
              	    machine(Error,r);
                  }
                  break;
              }
            }
	    else /* change into next directory in path */
	    {
	      ret = (*CurrExports->card_select)(card_handle,
	      	    files[current_file++]);
	    }
            if (ret == SCI_FAIL)
            {
              debug
              {
                ret = sctransport_error(card_handle);
                DebugPrint("SCInterface: transport error in selecting dir %d\n",ret);
              }
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case SelectingFile :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * we have successfully selected the file, get header response
	     */
	    debug DebugPrint("SCInterface: file selected\n");
	    state = GettingResponse;
	    ret = (*CurrExports->card_get_response)(card_handle,(int)resp[1]);
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case GettingResponse :
	  err=handle_response(file_header,sizeof(file_header),
	                      &data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * we have successfully get the response message, do something
	     */
	    switch (entry_trans)
	    {
              case DeleteSWI :
	        access_condition = file_header[9]>>4 & 0xf;
                if (access_condition==0) /* no write access cond */
                {
                  state = Deleting;
                  ret = (*CurrExports->card_delete)(card_handle,
                        files[num_files-1]);
                }
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
                else /* access condition to deal with */
                {
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
                }
                break;
	      case ReadSWI :
	        access_condition = file_header[8]>>4 & 0xf;
                if (access_condition==0) /* no read access cond */
                {
                  state = ReadingFile;
                  offset = 0;
                  chunk_size = CurrExports->chunk_size;
                  if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

                  ret = (*CurrExports->card_read)(card_handle,entry.r[2],
              	      	chunk_size);
                }
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
                else  /* access condition to deal with */
                {
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
                }
                break;
	      case WriteSWI:
	        access_condition = file_header[8] & 0xf;
                if (access_condition==0) /* no write access cond */
                {
       	          state = WritingFile;
                  offset = entry.r[2];
                  chunk_size = CurrExports->chunk_size;
                  if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

                  ret = (*CurrExports->card_write)(card_handle, offset,
        	        (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
        	}
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
        	else /* access condition to deal with */
        	{
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
        	}
	        break;
	      case FileInfoSWI :
	        if (entry.r[3]>sizeof(file_header))
  	          memcpy((char*)entry.r[2],file_header,sizeof(file_header));
  	        else
  	          memcpy((char*)entry.r[2],file_header,entry.r[3]);

                sctransport_end_trans(card_handle);
	    	state = Idle;
	    	module_notify(Event_Complete,SC_SUCCESS);
	        break;
	    }

            if (ret == SCI_FAIL)
            {
              debug
              {
                ret = sctransport_error(card_handle);
                DebugPrint("SCInterface: after get response %d\n",ret);
              }
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case GettingAuthResponse :
          err=handle_response((BYTE*)entry.r[5],entry.r[6],&data_length,resp);
	  if (err==SC_SUCCESS)
   	  {
            sctransport_end_trans(card_handle);
	    state = Idle;
            module_notify(Event_Complete,SC_SUCCESS);
	  }
	  else
	    machine(Error,r);
	  break;

	case VerifyingCHV :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS || (resp[0]==0x98 && resp[1]==0x08))
	  {
	    debug DebugPrint("SCInterface: verified CHV\n");
	    /*
	     * we have successfully verified the CHV, do something
	     */
	    switch (entry_trans)
	    {
              case DeleteSWI :
                state = Deleting;
                ret = (*CurrExports->card_delete)(card_handle,
                      files[num_files-1]);
	      case ReadSWI :
	        state = ReadingFile;
	        offset = 0;
	        chunk_size = CurrExports->chunk_size;
	        if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

	        ret = (*CurrExports->card_read)(card_handle,entry.r[2],
	              chunk_size);
	        break;
	      case WriteSWI :
	        state = WritingFile;
	        offset = entry.r[2];
	        chunk_size = CurrExports->chunk_size;
	        if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

	        ret = (*CurrExports->card_write)(card_handle, offset,
	               (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
	        break;
	    }
            if (ret == SCI_FAIL)
            {
              debug
              {
                ret = sctransport_error(card_handle);
                DebugPrint("SCInterface: after verify CHV %d\n",ret);
              }
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case Creating : case Deleting :
	case ChangingCHV : case EnablingCHV : case UnBlockingCHV :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
            sctransport_end_trans(card_handle);
	    state = Idle;
	    module_notify(Event_Complete,SC_SUCCESS);
	  }
	  else
	    machine(Error,r);

	  break;

	case ReadingFile :
	  err=handle_response((BYTE*)(entry.r[3]+offset),chunk_size,
	     &data_length,resp);
	  if (err == SC_SUCCESS)
	  {
	    offset+=chunk_size;
	    if (offset>=entry.r[4])  /* have we finished reading yet */
	    {
              sctransport_end_trans(card_handle);
	      state = Idle;
	      module_notify(Event_Complete,SC_SUCCESS);
	    }
	    else
	    {
	      chunk_size = CurrExports->chunk_size;
	      if (entry.r[4]-offset<chunk_size) chunk_size = entry.r[4]-offset;

	      ret = (*CurrExports->card_read)(card_handle,entry.r[2]+offset,
	      	    chunk_size);
              if (ret == SCI_FAIL)
              {
                debug
                {
                  ret = sctransport_error(card_handle);
                  DebugPrint("SCInterface: error reading file %d\n",ret);
                }
                err = SC_TRANSPORT;
                machine(Error,r);
              }
	    }
  	  }
  	  else
  	    machine(Error,r);
	  break;
	case WritingFile :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    offset+=chunk_size;
	    if (offset>=entry.r[4])  /* have we finished writing yet */
	    {
              sctransport_end_trans(card_handle);
	      state = Idle;
	      module_notify(Event_Complete,SC_SUCCESS);
	    }
	    else
	    {
	      chunk_size = CurrExports->chunk_size;
	      if (offset+chunk_size>entry.r[4]) chunk_size = entry.r[4]-offset;
	      ret = (*CurrExports->card_write)(card_handle, offset,
	            (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
              if (ret == SCI_FAIL)
              {
                debug
                {
                  ret = sctransport_error(card_handle);
                  DebugPrint("SCInterface: error writing file %d\n",ret);
                }
                err = SC_TRANSPORT;
                machine(Error,r);
              }
	    }
	  }
	  else
	    machine(Error,r);
	  break;
	case WaitingInternalAuth :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * authentication complete, now need to fetch the stuff
	     */
 	    state = GettingAuthResponse;
	    ret = (*CurrExports->card_get_response)(card_handle,(int)resp[1]);
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;
        default :
          debug DebugPrint("SCInterface: Ilegal state (%d) in Done\n",state);
	  state = Idle;
          break;
      }
      break;
    case Error :
      if (err == 0)
      {
        err = SC_TRANSPORT;
        ret = sctransport_error(card_handle);
      }

      status_error = err;
      sctransport_close(card_handle);
      debug DebugPrint("SCInterface: Error 0x%x state %d entry %d ret %d\n",
      	    err,state,entry_trans,ret);

      module_notify(Event_Complete,err);
      state = WaitingOpen;
      machine(Done,r);
      break;

    case Removed :
      module_notify(Event_CardRemoved,0);
      sctransport_close(card_handle);
      card_handle = -1;
      state = WaitingOpen;
      machine(Done,r);
      break;

    case ReStart :
      module_notify(Event_CardRemoved,0);
      card_handle = -1;
      state = WaitingOpen;
      machine(Done,r);
      break;

    case TransEnd :
      switch (state)
      {
        case WaitingTrans :
          state = Idle;
          doing_retry = 1;
          machine(entry_trans,&entry);
          break;
      }
      break;
    case GetATRSWI :
      switch (state)
      {
        case WaitingOpen : case WaitingATR :
      	  r->r[0] = SC_NOCARD;
      	  r->r[1] = 0;
      	  break;
      	default :
      	  r->r[0] = SC_SUCCESS;
      	  r->r[1] = (int)&ATR;
      }
      break;
    case CreateSWI : case DeleteSWI : case ReadSWI :  case WriteSWI :
    case ChangeCHVSWI : case EnableCHVSWI :
    case UnBlockCHVSWI : case FileInfoSWI :
      switch (state)
      {
        case Idle :
          entry_trans = transition; /* remember transition for later */
          if (!doing_retry)
          {
            err = path_process((char*)r->r[1],files,&num_files,
                  (r->r[0]&1<<1)?1:0);
          }
          else
            err = SC_SUCCESS;

          doing_retry = 0;
          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            state = SelectingDir;
            debug DebugPrint("SCInterface: number of files %d\n",num_files);
            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
              current_file = 0;
              ret = (*CurrExports->card_select_root)(card_handle);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                /* card locked against transactions, back off */
                state = WaitingTrans;
              }
            }
          }
          break;
        case WaitingOpen : case WaitingATR :
      	  err = SC_NOCARD;
      	  break;
        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;
        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;

    case InternalAuthSWI :
      switch (state)
      {
        case Idle :
          entry_trans = transition; /* remember transition for later */
          doing_retry = 0;
          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            state = WaitingInternalAuth;
            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
      	      ret = (*CurrExports->card_internal_auth)(card_handle,
      	      entry.r[2], (BYTE*)entry.r[3], entry.r[4]);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                /* card locked against transactions, back off */
                state = WaitingTrans;
              }
            }
          }
          break;
        case WaitingOpen : case WaitingATR :
      	  err = SC_NOCARD;
      	  break;
        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;
        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;
    case StatusSWI :
      if (status_error!=0)
        r->r[0] = StatusError;
      else
      {
        switch (state)
        {
          case WaitingOpen : case WaitingATR :
            r->r[0] = StatusNoCard;
            break;
          case Idle :
            r->r[0] = StatusIdle;
            break;
          default :
            r->r[0] = StatusBusy;
        }
      }
      r->r[1] = status_error;
      status_error=0;
      break;
  }
}

/*
 * retrieve the cards ATR and try to obtain a match against the table of known
 * ATRs
 *
 * sets CurrExports if ATR matched.
 *
 * will return SC_SUCCESS if ATR matches, SCFS otherwise
 */
int
get_atr(void)
d554 13
a568 1
    //debug DebugPrint("SCInterface: ATR length %d\n",ATR.len);
d571 3
a573 1
      if (ATR.len == CardExports[iCard]->card_atr->len)
d575 10
a584 13
        iMisMatch = 0;
        i=0;
        while (i<CardExports[iCard]->card_atr->significant && !iMisMatch)
        {
          if (ATR.hist[i]!=CardExports[iCard]->card_atr->hist[i]) iMisMatch++;
          i++;
        }

        if (iMisMatch == 0)
        {
          CurrExports = CardExports[iCard];
          return (SC_SUCCESS);
        }
d591 2
d594 4
a597 8
/*
 * attempt to open a smart card connection
 *
 * will return SC_SUCCESS for success, SC_TRANSPORT for SCTransport errors,
 * SC_UNDERSTAND for unrecognised card.
 */
int
open_card(void)
d602 1
d606 3
d612 3
d619 15
a633 1
  debug DebugPrint("SCInterface: opened card channel %d\n",card_handle);
d637 3
a639 1
    debug DebugPrint("SCInterface: Don't understand card\n");
d647 6
a652 7
/*
 * does a read response into the given data area and checks the response
 * codes against the ones given. Returns success if response codes match.
 * response code should be -1 to ignore.
 */
int
handle_response(BYTE *card_data, int data_len, int *length, BYTE resp[2])
d662 8
a669 1
    return (SC_TRANSPORT);
d671 4
a674 1
  debug DebugPrint("SCInterface: handle response %02x %02x\n",resp[0],resp[1]);
d696 4
a699 1
  debug DebugPrint("response 0x%x unknown\n",swA);
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Changed copyright notice.
@
text
@d16 7
a22 7
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
@


4.1.7.3
log
@Major re-work of debugging code so support the remote debug library.
Removal of arh.h dependancy and any other bits of windows legacy code.
@
text
@d72 1
a72 1
 * special chimpanzee processing
d74 2
a75 5
int ChimpanzeeClassByte=0xa0;

#ifdef REMOTE_DEBUG
debug_session *db=NULL;
#endif
d86 1
a86 2

#ifdef REMOTE_DEBUG
a87 7
char *strState[] = {"WaitingOpen","WaitingATR","WaitingRemoval","Idle",
"SelectingDir","SelectingFile","GettingResponse","GettingAuthResponse",
"Creating","Deleting","ReadingFile","WritingFile","VerifyingCHV","ChangingCHV",
"EnablingCHV","UnBlockingCHV","WaitingInternalAuth","WaitingTrans"};
#else
char *strNotifications[] = {""};
char *strState[] = {""};
d101 1
a101 2
_kernel_oserror *
sc_event_handler(_kernel_swi_regs *r, void *pw)
d122 1
a122 1
          debug_printf(db,"event Removed\n");
d126 1
a126 1
          debug_printf(db,"trans end\n");
d133 1
a133 1
          debug_printf(db,"event Error\n");
d151 1
a151 1
  return (NULL);
d266 1
a266 1
  debug_printf(db,"module service %x\n",r->r[0]);
d277 2
a278 2

  debug_printf(db,"notify '%s', 0x%x\n",
d280 1
a280 1

a334 3
  debug_printf(db,"(5) finalisation");
  remote_debug_close(db);

d375 1
a375 1
   * initialise the system
d377 2
a378 1
  remote_debug_open(Module_Title,&db);
d500 1
a500 1
  //debug_printf(db,"machine(%d)\n",transition);
d601 5
d621 1
a621 1
	    debug_printf(db,"file selected\n");
d726 5
d755 1
a755 1
	    debug_printf(db,"verified CHV\n");
d786 5
d834 5
d866 5
d898 1
a898 1
          debug_printf(db,"Ilegal state (%s) in Done\n",strState[state]);
a902 3
    /*
     * end of Done
     */
a903 35
      /*
       * special chimpanzee error handling
       */
      if ((err==SC_WRONGCLASS) && (ATR.hist[0]==0x7))
      {
        debug_printf(db,"Chimpanzee processing !!!!");
        switch (entry_trans)
        {
          case ChangeCHVSWI :
            debug_printf(db,"   change chv re-direction");
            state = ChangingCHV;
            ChimpanzeeClassByte = 0xf0;
            ret = (*CurrExports->card_change_chv)(card_handle,entry.r[2],
              (char*)entry.r[3], entry.r[4],(char*)entry.r[5], entry.r[6]);
            ChimpanzeeClassByte = 0xa0;
            break;
          case UnBlockCHVSWI :
            debug_printf(db,"   unblock chv re-direction");
            state = UnBlockingCHV;
            ChimpanzeeClassByte = 0xf0;
  	    ret = (*CurrExports->card_unblock_chv)(card_handle,entry.r[2],
  	      (char*)entry.r[3], entry.r[4], (char*)entry.r[5], entry.r[6]);
            ChimpanzeeClassByte = 0xa0;
            break;
        }
        if (ret == SCI_FAIL)
        {
          err = SC_TRANSPORT;
          machine(Error,r);
        }
        break;
      }
      /*
       * otherwise
       */
d912 2
a913 2
      debug_printf(db,"Error 0x%x state (%s) entry %d ret %d\n",
      	    err,strState[state],entry_trans,ret);
d958 2
a959 2
    case EnableCHVSWI : case UnBlockCHVSWI : case FileInfoSWI :
    case ChangeCHVSWI :
d965 4
a968 1
            err = path_process((char*)r->r[1],files,&num_files);
d977 1
a977 1
            debug_printf(db,"number of files %d\n",num_files);
d1098 1
a1098 1
    //debug_printf(db,"ATR length %d\n",ATR.len);
d1145 1
a1145 1
  debug_printf(db,"opened card channel %d\n",card_handle);
d1149 1
a1149 1
    debug_printf(db,"Don't understand card\n");
d1175 1
a1175 1
  debug_printf(db,"Received response %02x %02x\n",resp[0],resp[1]);
d1197 1
a1197 1
  debug_printf(db,"response 0x%x unknown\n",swA);
@


4.1.7.4
log
@Remove check of ATR length when checking for card type.
@
text
@a38 1
 * 22 May 1997 RWB, get_atr does not check atr length
a95 3
char *strTransitions[] = {"Done","Error","Removed","ReStart","TransEnd",
"CreateSWI","DeleteSWI","ReadSWI","WriteSWI","GetATRSWI","ChangeCHVSWI",
"EnableCHVSWI","UnBlockCHVSWI","FileInfoSWI","InternalAuthSWI","StatusSWI"};
a98 1
char *strTransitions[] = {""};
d514 1
a514 2
  if (transition!=StatusSWI)
    debug_printf(db,"machine (%s)\n",strTransitions[transition]);
a721 1
	        debug_printf(db,"copying response %d",entry.r[3]);
d939 2
a940 2
      debug_printf(db,"error 0x%x state (%s) entry (%s) ret %d\n",
      	    err,strState[state],strTransitions[entry_trans],ret);
a989 1
	  debug_printf(db,"entered via %s",strTransitions[transition]);
d1001 1
d1122 1
d1125 1
a1125 3
      iMisMatch = 0;
      i=0;
      while (i<CardExports[iCard]->card_atr->significant && !iMisMatch)
d1127 7
a1133 4
        if (ATR.hist[i]!=CardExports[iCard]->card_atr->hist[i])
          iMisMatch++;
        i++;
      }
d1135 5
a1139 4
      if (iMisMatch == 0)
      {
        CurrExports = CardExports[iCard];
        return (SC_SUCCESS);
d1173 1
a1173 1
    debug_printf(db,"don't understand card\n");
d1199 1
a1199 1
  debug_printf(db,"received response %02x %02x\n",resp[0],resp[1]);
@


4.1.7.5
log
@Added a new bit of interface to SCInterface_FileInfo that interrprets data
depending on which type of card in inserted.
@
text
@d513 1
a513 1
  BYTE file_header[25];
a520 1

a651 1
	  debug_printf(db,"(7) got response, err = %d",err);
d728 6
a733 49
	        debug_printf(db,"(7) FileInfoSWI");
	      	if (entry.r[0] & 1<<1) /* bit 1 populate structure */
	      	{
	      	  t_sc_stat *stat_ptr = (t_sc_stat*)entry.r[2];

                  stat_ptr->num_files = -1;
                  stat_ptr->num_dirs  = -1;
                  stat_ptr->chv1_attempts = -1;
                  stat_ptr->unblock_chv1_attempts = -1;
	      	  stat_ptr->file = 1;        /* default to file */

	      	  if (ATR.hist[0] == 7) /* schlumberger */
	      	  {
	      	    debug_printf(db,"(7)   schlumberger (0x%x)",file_header[6]);
      	            stat_ptr->size = file_header[2]<<8 | file_header[3];
		    if (file_header[6] == 0x38 || file_header[6] == 0x02)
		    {
	      	      stat_ptr->file = 0;        /* directory */
	      	      stat_ptr->chv1_enabled         = (file_header[18]==0)?0:1;
	      	      stat_ptr->unblock_chv1_enabled = (file_header[19]==0)?0:1;
      	              stat_ptr->num_files 	     = file_header[14];
      	              stat_ptr->num_dirs  	     = file_header[15];
  		      stat_ptr->chv1_attempts	     = file_header[18];
  		      stat_ptr->unblock_chv1_attempts= file_header[19];
		    }
	      	  }
	      	  else
	      	  {
	      	    debug_printf(db,"(7)   other card (0x%x)",file_header[6]);
      	            stat_ptr->size = file_header[2]<<8 | file_header[3];
	      	    if (file_header[6] != 0x04) /* not file */
	      	    {
	      	      stat_ptr->file = 0;        /* directory */
	      	      stat_ptr->chv1_enabled         = file_header[18]>>7;
	      	      stat_ptr->unblock_chv1_enabled = file_header[19]>>7;
      	              stat_ptr->num_files 	     = file_header[14];
      	              stat_ptr->num_dirs  	     = file_header[15];
  		      stat_ptr->chv1_attempts	     = file_header[18] & 0xf;
  		      stat_ptr->unblock_chv1_attempts= file_header[19] & 0xf;
	      	    }
	      	  }
	      	}
	      	else
	      	{
  	          if (entry.r[3]>sizeof(file_header))
  	            memcpy((char*)entry.r[2],file_header,sizeof(file_header));
  	          else
  	            memcpy((char*)entry.r[2],file_header,entry.r[3]);
                }
a979 1
      debug_printf(db,"(7) state = %d",state);
a986 1
      	  debug_printf(db,"(7) returning stuff");
a1200 3
  {
/*     ret = sctransport_error(card_handle); */
/*     debug_printf(db,"(7) sctransport_error %d (0x%x)",ret,ret); */
a1201 1
  }
@


4.1.7.6
log
@Improved the behaviour when errors occur, particularly the buffer truncation
error returned from the transport module.
@
text
@a989 1
      sctransport_end_trans(card_handle);
d1249 3
a1251 4
    ret = sctransport_error(card_handle);
    debug_printf(db,"(7) sctransport_error %d (0x%x)",ret,ret);
    if (ret != SCI_E_TRUNC) /* ignore truncation errors */
      return (SC_TRANSPORT);
d1254 1
a1254 1
  debug_printf(db,"(7) received response %02x %02x\n",resp[0],resp[1]);
d1276 1
a1276 1
  debug_printf(db,"(7) response 0x%x unknown\n",swA);
@


4.1.7.7
log
@I got two bits the wrong way round in the FileInfo swi. Number of files and
number of directories.
@
text
@d750 2
a751 2
      	              stat_ptr->num_dirs  	     = file_header[14];
      	              stat_ptr->num_files 	     = file_header[15];
d765 2
a766 2
      	              stat_ptr->num_dirs  	     = file_header[14];
      	              stat_ptr->num_files 	     = file_header[15];
d1034 1
a1034 7
      	  debug_printf(db,"(7) returning atr, atr len = %d",ATR.len);
      	  if (ATR.len>0)
      	  {
      	    int i;
      	    for (i=0; i<ATR.len; i++)
      	      debug_printf(db,"(7)    ATR[%d] : 0x%x\n",i,ATR.hist[i]);
      	  }
a1174 1
  debug_printf(db,"(7) ATR length %d\n",ATR.len);
@


4.1.7.8
log
@Updated for CMHG 5.16
@
text
@d327 1
a327 1
module_cli(const char *arg_string,int arg_count,int cmd_no,void *pw)
d369 1
a369 1
module_initialise(const char *cmd_tail, int podule_base, void *pw)
@


4.1.7.9
log
@Modified to work with Funai3 T=1 cards

Version 0.17, 1.1.2.2. Tagged as 'SCInter-0_17-1_1_2_2'
@
text
@d39 1
a39 3
 * 22-May-97  RWB,  get_atr does not check atr length
 * 03-Nov-98  RML,  *SCInterInfo now shows current card type (corresponds
 *                  to value of i in CARDS_POPULATE, in h.cards).
a52 1
#include "machine.h"
d55 10
a64 1
#include "records.h"
a76 2
int current_card_type=-1;

d89 1
a89 1
t_card_atr ATR;
d91 1
a91 1
#ifdef debug
d112 7
a118 7
t_states state = WaitingOpen;
t_transitions entry_trans;

/******************************************************************************
  process the asynchronous events
 ******************************************************************************/
_kernel_oserror *sc_event_handler(_kernel_swi_regs *r, void *pw)
d138 2
a139 4
        case SCI_REMOVED:
#ifdef debug
          printf("SCINTERFACE: event SCI_REMOVED\n");
#endif
d142 2
a143 5

        case SCI_TRANS_END:
#ifdef debug
          printf("SCINTERFACE: event SCI_TRANS_END\n");
#endif
a145 1

a148 1

d150 1
a150 3
#ifdef debug
          printf("SCINTERFACE: event SCI_ERROR\n");
#endif
d171 5
a175 4
/******************************************************************************
  setup a callback to deal with the serial event.
 ******************************************************************************/
_kernel_oserror *setup_event(int iHandle, int ithis_event)
d206 5
a210 4
/******************************************************************************
  handle events, select ones of interest to us
 ******************************************************************************/
int event_handler(_kernel_swi_regs *r, void *pw)
d223 5
a227 4
/******************************************************************************
  claims vectors and enables the events as required
 ******************************************************************************/
_kernel_oserror *claim_vectors(void)
d250 5
a254 4
/******************************************************************************
  release vectors, flush any callbacks and disable events
 ******************************************************************************/
_kernel_oserror *release_vectors(void)
d277 5
a281 4
/******************************************************************************
  module service, only dealing with service_NCTransportStarting
 ******************************************************************************/
void module_service(int service_number, _kernel_swi_regs *r, void *pw)
d283 1
a283 3
#ifdef debug
  printf("SCINTERFACE: module service %x\n",r->r[0]);
#endif
d287 5
a291 4
/******************************************************************************
  broadcast a message using the SCInterface event
 ******************************************************************************/
void module_notify(int reason,int param)
d295 1
a295 2
#ifdef debug
  printf("SCINTERFACE: notify '%s', 0x%x\n",
a296 1
#endif
d305 5
a309 4
/******************************************************************************
  simple printf without using stdio
 ******************************************************************************/
void my_printf(char *format, ...)
d323 5
a327 6

/******************************************************************************
  cli_handler
 ******************************************************************************/
_kernel_oserror *module_cli ( const char *arg_string, int arg_count,
                              int cmd_no, void *pw)
a333 1
      my_printf("   Card type   : %d",current_card_type);
d340 5
a344 4
/******************************************************************************
  module finalise
 ******************************************************************************/
_kernel_oserror *module_finalise(int fatal, int podule, void *pw)
d352 1
a352 4
#ifdef debug
  printf("SCINTERFACE: finalisation");
#endif
#ifdef REMOTE_DEBUG
a353 1
#endif
d365 5
a369 5
/******************************************************************************
  module initialise
 ******************************************************************************/
_kernel_oserror *module_initialise ( const char *cmd_tail, int podule_base,
                                     void *pw)
a396 1
#ifdef REMOTE_DEBUG
a397 1
#endif
d414 5
a418 4
/******************************************************************************
  module swi handler
 ******************************************************************************/
_kernel_oserror *module_swi( int swi_no, _kernel_swi_regs *r, void *pw )
a427 1

a433 1

a439 1

a445 1

a448 1

a454 1

a460 1

a466 1

a472 1

a478 1

d485 1
a485 1
  NOT_USED( pw);
d488 5
a492 4
/******************************************************************************
  copy the values in r_old into r_new only r0-r10
 ******************************************************************************/
void _copy_regs(_kernel_swi_regs *r_new, _kernel_swi_regs *r_old)
d498 677
a1174 9
/******************************************************************************
  retrieve the cards ATR and try to obtain a match against the table of known
  ATRs

  sets CurrExports if ATR matched.

  will return SC_SUCCESS if ATR matches, SCFS otherwise
 ******************************************************************************/
int get_atr(void)
d1181 1
a1181 13
#ifdef debug
  printf("SCINTERFACE: ATR length %d\n",ATR.len);
#endif
#ifdef MINIJIS_CARD
  /* if theres no atr then its a minijis :-) */
  if ( ATR.len >=0)
  {
    iCard =3;
    CurrExports = CardExports[iCard];
    current_card_type = iCard;
    return (SC_SUCCESS);
  }
#endif
a1197 1
        current_card_type = iCard;
a1204 2
/******************************************************************************
  attempt to open a smart card connection
d1206 8
a1213 4
  will return SC_SUCCESS for success, SC_TRANSPORT for SCTransport errors,
  SC_UNDERSTAND for unrecognised card.
 ******************************************************************************/
int open_card(void)
a1217 1
  current_card_type = -1;
a1220 3
#ifdef debug
  printf("SCINTERFACE: open card channel result %d\n", ret);
#endif
a1223 3
#ifdef debug
    printf("SCINTERFACE: open card channel returned error %d\n", err);
#endif
d1228 1
a1228 15
#ifdef debug
  printf("SCINTERFACE: opened card channel %d\n",card_handle);
#endif
#ifdef wibble
  ret =sctransport_start_trans( card_handle);
  if (ret==SCI_FAIL)
  {
    err = sctransport_error(card_handle);
    if (err==SCI_FAIL)
      return (SC_TRANSPORT);
  }
#endif
#ifdef debug
  printf("SCINTERFACE: started transport (ret:%d)\n", ret);
#endif
d1232 1
a1232 3
#ifdef debug
    printf("SCINTERFACE: don't understand card\n");
#endif
d1240 7
a1246 6
/******************************************************************************
  does a read response into the given data area and checks the response
  codes against the ones given. Returns success if response codes match.
  response code should be -1 to ignore.
 ******************************************************************************/
int handle_response(BYTE *card_data, int data_len, int *length, BYTE resp[2])
d1258 1
a1258 3
#ifdef debug
    printf("SCINTERFACE: sctransport_error %d (0x%x)",ret,ret);
#endif
d1263 1
a1263 4
#ifdef debug
  printf("SCINTERFACE: received response %02x %02x\n",resp[0],resp[1]);
#endif
  /* printf("  Received response %02x %02x\n", resp[0], resp[1]); */
d1285 1
a1285 4
#ifdef debug
  printf("SCINTERFACE: response 0x%x unknown\n",swA);
#endif
  /* printf("  Unknown response.\n"); */
@


4.1.7.10
log
@ Started implementing support for monitoring going in and out of
> Standby mode. New state WaitingStandby and two new transitions
> Shutdown and Standby added to state machine. Plus added appropriate
> bits to the service call handler.
> Also tidied up a few error messages and included VersionNum file in
> cmhg header.

Version 0.17, 1.1.2.5. Tagged as 'SCInter-0_17-1_1_2_5'
@
text
@d92 1
a92 1
"EnablingCHV","UnBlockingCHV","WaitingInternalAuth","WaitingTrans","WaitingStandby"};
d95 1
a95 1
"EnableCHVSWI","UnBlockCHVSWI","FileInfoSWI","InternalAuthSWI","StatusSWI","Shutdown","Standby"};
d284 1
a284 1
  printf("SCINTERFACE: module service %x\n",r->r[1]);
d286 1
a286 25
  switch (service_number)
  {
  case Service_SCTransportStarting:
      machine(ReStart,r);
      break;

#ifdef MONITOR_STANDBY
#ifdef MINIJIS_CARD
  case Service_ShutdownComplete:
      /* SJM: 8Dec97: Need to forget about card when we shutdown as
         Funai micro doesn't notify us of events that occur whilst int
         is in standby */
      if (card_handle != -1)
	  machine(Shutdown,r);
      break;
#endif
#ifdef MINIJIS_CARD
  case Service_Standby:
      /* SJM: 8Dec97: */
      if ((r->r[0] & 1) == 0) /* box waking up */
	  machine(Standby,r);
      break;
#endif
#endif
  }
d531 1
a531 1
  printf("SCINTERFACE: ATR length %d ret %d\n",ATR.len,ret);
d641 1
a641 1
    printf("SCINTERFACE: sctransport_error %d (0x%x)\n",ret,ret);
@


4.1.7.11
log
@  (overview of change)
Detail:
  (list files and functions that have changed)
Admin:
  (highlight level of testing that has taken place)
  (bugfix number if appropriate)
@
text
@a109 1
int global_ignore_events = 0;
d219 1
a219 4
      if(global_ignore_events == 0)
      {
        setup_event(r->r[2],r->r[3]);
      }
a522 20
      break;
      
    case SCInterface_Events :
      if(r->r[0] == 0) /** Ignore events **/
      {
        if(r->r[1] == 1)
        {
          global_ignore_events++;
        }
        else if(r->r[1] == 0)
        {
          if(global_ignore_events > 0) global_ignore_events--;
        }
        r->r[1] = global_ignore_events; /* Return the counter value **/
      }
      else if (r->r[0] == 1) /** Fake events **/
      {
        /** R1 contains the event number to fake **/
        setup_event(r->r[2],r->r[3]);
      }
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@

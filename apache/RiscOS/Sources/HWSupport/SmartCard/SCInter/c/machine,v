head	4.4;
access;
symbols
	SCInter-0_27:4.4
	dellis_autobuild_BaseSW:4.4
	SCInter-0_26:4.4
	sbrodie_sedwards_16Mar2000:4.4
	SCInter-0_25:4.4
	SCInter-0_24:4.4
	wturner_scinter2:1.1.2.2
	wturner_scinter1:1.1.2.2
	SCInter-0_23:4.4
	SCInter-0_22:4.3
	SCInter-0_21:4.2
	dcotton_autobuild_BaseSW:4.4
	dcotton_scinter_MPTInitialBuild:1.1.2.2
	SCInter-0_20:4.2
	SCInter-0_19:4.2
	SCInter-0_18:4.1
	Spin_merge:1.1.2.2
	SCInter-0_17-1_1_2_5:1.1.2.2
	SCInter-0_17-1_1_2_4:1.1.2.1
	SCInter-0_17-1_1_2_3:1.1.2.1
	SCInter-0_17-1_1_2_2:1.1.2.1
	Spinner:1.1.0.2;
locks; strict;
comment	@# @;


4.4
date	99.11.17.08.49.26;	author dcotton;	state Exp;
branches;
next	4.3;

4.3
date	99.11.16.13.35.29;	author dcotton;	state Exp;
branches;
next	4.2;

4.2
date	98.12.16.16.20.15;	author apirozek;	state Exp;
branches;
next	4.1;

4.1
date	98.12.11.19.10.09;	author smiddle;	state Exp;
branches;
next	1.1;

1.1
date	98.11.24.12.13.18;	author apirozek;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	98.11.24.12.13.19;	author apirozek;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	98.12.11.19.05.56;	author smiddle;	state Exp;
branches;
next	;


desc
@@


4.4
log
@	Added a little more debugging.
Detail:
	Added more debugging, especially to the SWI handling routines.
Admin:
	Tested as a debugging softload and in a Funai 4 build.

Version 0.23. Tagged as 'SCInter-0_23'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

/*
 * State machine for cards
 *
 * Modification History
 *---------------------
 *
 * 24-Nov-98  AJP,  Split from module.c to accomodate new state machine.
 *                  This file contains 2 state machines, one for the orginal
 *                  NC T=0 cards and a new one to accomodate the Funai3
 *                  T=1 cards.
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include "kernel.h"
#include "swis.h"
#include "sctrans.h"
#include "module.h"
#include "irqs.h"
#include "header.h"
#include "scinter.h"
#include "cards.h"
#include "path.h"
#include "records.h"

#include "Debuglib/Debuglib.h"

#ifndef MINIJIS_CARD
/******************************************************************************
  the state machine for Orga, Incard and Schlumberger cards
 ******************************************************************************/
void machine(t_transitions transition, _kernel_swi_regs *r)
{
  static _kernel_swi_regs entry;
  static int files[MAX_SUBDIRS];
  static int num_files;
  static int current_file;
  static int err;
  static int offset;
  static int chunk_size;
  static int status_error = 0;
  static int doing_retry = 0;
  BYTE file_header[25];
  BYTE resp[2];
  int data_length;
  int ret = SCI_SUCCESS;
  int access_condition;

  if (transition!=StatusSWI)
  {
    dprintf(("", "machine (%s)\n",strTransitions[transition]));
  }

  switch (transition)
  {
    case Done :
      switch (state)
      {
        case WaitingOpen :
          err = open_card();
          switch (err)
          {
            case SC_SUCCESS :
              state = WaitingATR;
              break;
	    case SC_UNDERSTAND :
              state = WaitingRemoval;
              break;
          }
          break;
        case WaitingATR :
          if (get_atr() == SC_SUCCESS)
          {
            state = Idle;
            module_notify(Event_CardOK,0);
          }
          else
          {
            state = WaitingRemoval;
            module_notify(Event_CardBad,0);
          }
          break;
	case Idle :
	  /* ingore */
	  break;
	case SelectingDir :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    if (current_file == num_files-1)   /* are we on the leaf name */
	    {
	      switch (entry_trans)
	      {
	        case CreateSWI :
	          state = Creating;
		  ret = (*CurrExports->card_create)(card_handle,
		      	files[current_file++],(entry.r[0]&1<<1)?1:0,entry.r[2],
		      	entry.r[3]);
	          break;
	        case ReadSWI : case WriteSWI :
	        case DeleteSWI : case FileInfoSWI :
    	          state = SelectingFile;
                  ret = (*CurrExports->card_select)(card_handle,
                      	files[current_file++]);
                  break;
                case ChangeCHVSWI :
                case EnableCHVSWI : case UnBlockCHVSWI :
	      	  ret = (*CurrExports->card_select)(card_handle,
	      	      	files[current_file++]);
                  break;
              }
	    }
	    else if (current_file == num_files) /* leaf name was a directory */
	    {
	      switch (entry_trans)
	      {
	        case ChangeCHVSWI :
	          state = ChangingCHV;
  		  ret = (*CurrExports->card_change_chv)(card_handle,
  		      	entry.r[2], (char*)entry.r[3], entry.r[4],
  		      	(char*)entry.r[5], entry.r[6]);
	          break;
                case EnableCHVSWI :
                  state = EnablingCHV;
		  ret = (*CurrExports->card_enable_chv)(card_handle,
		      	entry.r[2],(entry.r[0]&1<<1)?1:0,(char*)entry.r[3],
		      	entry.r[4]);
	          break;
                case UnBlockCHVSWI :
                  state = UnBlockingCHV;
   		  ret = (*CurrExports->card_unblock_chv)(card_handle,
   		      	entry.r[2], (char*)entry.r[3],
   		      	entry.r[4], (char*)entry.r[5], entry.r[6]);
                  break;
                case FileInfoSWI :
	    	  state = GettingResponse;
	    	  ret = (*CurrExports->card_get_response)(card_handle,
	    	      	(int)resp[1]);
                  if (ret == SCI_FAIL)
            	  {
		    err = SC_TRANSPORT;
              	    machine(Error,r);
                  }
                  break;
              }
            }
	    else /* change into next directory in path */
	    {
	      ret = (*CurrExports->card_select)(card_handle,
	      	    files[current_file++]);
	    }
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case SelectingFile :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * we have successfully selected the file, get header response
	     */
	    dprintf(("", "file selected\n"));
	    state = GettingResponse;
	    ret = (*CurrExports->card_get_response)(card_handle,(int)resp[1]);
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case GettingResponse :
	  err=handle_response(file_header,sizeof(file_header),
	                      &data_length,resp);
	  dprintf(("", "(7) got response, err = %d",err));
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * we have successfully get the response message, do something
	     */
	    switch (entry_trans)
	    {
              case DeleteSWI :
	        access_condition = file_header[9]>>4 & 0xf;
                if (access_condition==0) /* no write access cond */
                {
                  state = Deleting;
                  ret = (*CurrExports->card_delete)(card_handle,
                        files[num_files-1]);
                }
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
                else /* access condition to deal with */
                {
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
                }
                break;
	      case ReadSWI :
	        access_condition = file_header[8]>>4 & 0xf;
                if (access_condition==0) /* no read access cond */
                {
                  state = ReadingFile;
                  offset = 0;
                  chunk_size = CurrExports->chunk_size;
                  if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

                  ret = (*CurrExports->card_read)(card_handle,entry.r[2],
              	      	chunk_size);
                }
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
                else  /* access condition to deal with */
                {
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
                }
                break;
	      case WriteSWI:
	        access_condition = file_header[8] & 0xf;
                if (access_condition==0) /* no write access cond */
                {
       	          state = WritingFile;
                  offset = entry.r[2];
                  chunk_size = CurrExports->chunk_size;
                  if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

                  ret = (*CurrExports->card_write)(card_handle, offset,
        	        (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
        	}
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
        	else /* access condition to deal with */
        	{
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
        	}
	        break;
	      case FileInfoSWI :
	        dprintf(("", "(7) FileInfoSWI"));
	      	if (entry.r[0] & 1<<1) /* bit 1 populate structure */
	      	{
	      	  t_sc_stat *stat_ptr = (t_sc_stat*)entry.r[2];

                  stat_ptr->num_files = -1;
                  stat_ptr->num_dirs  = -1;
                  stat_ptr->chv1_attempts = -1;
                  stat_ptr->unblock_chv1_attempts = -1;
	      	  stat_ptr->file = 1;        /* default to file */

	      	  if (ATR.hist[0] == 7) /* schlumberger */
	      	  {
	      	    dprintf(("", "(7)   schlumberger (0x%x)",file_header[6]));
      	            stat_ptr->size = file_header[2]<<8 | file_header[3];
		    if (file_header[6] == 0x38 || file_header[6] == 0x02)
		    {
	      	      stat_ptr->file = 0;        /* directory */
	      	      stat_ptr->chv1_enabled         = (file_header[18]==0)?0:1;
	      	      stat_ptr->unblock_chv1_enabled = (file_header[19]==0)?0:1;
      	              stat_ptr->num_dirs  	     = file_header[14];
      	              stat_ptr->num_files 	     = file_header[15];
  		      stat_ptr->chv1_attempts	     = file_header[18];
  		      stat_ptr->unblock_chv1_attempts= file_header[19];
		    }
	      	  }
	      	  else
	      	  {
	      	    dprintf(("", "(7)   other card (0x%x)",file_header[6]));
      	            stat_ptr->size = file_header[2]<<8 | file_header[3];
	      	    if (file_header[6] != 0x04) /* not file */
	      	    {
	      	      stat_ptr->file = 0;        /* directory */
	      	      stat_ptr->chv1_enabled         = file_header[18]>>7;
	      	      stat_ptr->unblock_chv1_enabled = file_header[19]>>7;
      	              stat_ptr->num_dirs  	     = file_header[14];
      	              stat_ptr->num_files 	     = file_header[15];
  		      stat_ptr->chv1_attempts	     = file_header[18] & 0xf;
  		      stat_ptr->unblock_chv1_attempts= file_header[19] & 0xf;
	      	    }
	      	  }
	      	}
	      	else
	      	{
  	          if (entry.r[3]>sizeof(file_header))
  	            memcpy((char*)entry.r[2],file_header,sizeof(file_header));
  	          else
  	            memcpy((char*)entry.r[2],file_header,entry.r[3]);
                }
                sctransport_end_trans(card_handle);
	    	state = Idle;
	    	module_notify(Event_Complete,SC_SUCCESS);
	        break;
	    }

            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case GettingAuthResponse :
          err=handle_response((BYTE*)entry.r[5],entry.r[6],&data_length,resp);
	  if (err==SC_SUCCESS)
   	  {
            sctransport_end_trans(card_handle);
	    state = Idle;
            module_notify(Event_Complete,SC_SUCCESS);
	  }
	  else
	    machine(Error,r);
	  break;

	case VerifyingCHV :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS || (resp[0]==0x98 && resp[1]==0x08))
	  {
	    dprintf(("", "verified CHV\n"));
	    /*
	     * we have successfully verified the CHV, do something
	     */
	    switch (entry_trans)
	    {
              case DeleteSWI :
                state = Deleting;
                ret = (*CurrExports->card_delete)(card_handle,
                      files[num_files-1]);
	      case ReadSWI :
	        state = ReadingFile;
	        offset = 0;
	        chunk_size = CurrExports->chunk_size;
	        if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

	        ret = (*CurrExports->card_read)(card_handle,entry.r[2],
	              chunk_size);
	        break;
	      case WriteSWI :
	        state = WritingFile;
	        offset = entry.r[2];
	        chunk_size = CurrExports->chunk_size;
	        if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

	        ret = (*CurrExports->card_write)(card_handle, offset,
	               (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
	        break;
	    }
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case Creating : case Deleting :
	case ChangingCHV : case EnablingCHV : case UnBlockingCHV :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
            sctransport_end_trans(card_handle);
	    state = Idle;
	    module_notify(Event_Complete,SC_SUCCESS);
	  }
	  else
	    machine(Error,r);

	  break;

	case ReadingFile :
	  err=handle_response((BYTE*)(entry.r[3]+offset),chunk_size,
	     &data_length,resp);
	  if (err == SC_SUCCESS)
	  {
	    offset+=chunk_size;
	    if (offset>=entry.r[4])  /* have we finished reading yet */
	    {
              sctransport_end_trans(card_handle);
	      state = Idle;
	      module_notify(Event_Complete,SC_SUCCESS);
	    }
	    else
	    {
	      chunk_size = CurrExports->chunk_size;
	      if (entry.r[4]-offset<chunk_size) chunk_size = entry.r[4]-offset;

	      ret = (*CurrExports->card_read)(card_handle,entry.r[2]+offset,
	      	    chunk_size);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
	    }
  	  }
  	  else
  	    machine(Error,r);
	  break;
	case WritingFile :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    offset+=chunk_size;
	    if (offset>=entry.r[4])  /* have we finished writing yet */
	    {
              sctransport_end_trans(card_handle);
	      state = Idle;
	      module_notify(Event_Complete,SC_SUCCESS);
	    }
	    else
	    {
	      chunk_size = CurrExports->chunk_size;
	      if (offset+chunk_size>entry.r[4]) chunk_size = entry.r[4]-offset;
	      ret = (*CurrExports->card_write)(card_handle, offset,
	            (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
	    }
	  }
	  else
	    machine(Error,r);
	  break;
	case WaitingInternalAuth :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * authentication complete, now need to fetch the stuff
	     */
 	    state = GettingAuthResponse;
	    ret = (*CurrExports->card_get_response)(card_handle,(int)resp[1]);
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;
        default :
          dprintf(("", "Ilegal state (%s) in Done\n",strState[state]));
	  state = Idle;
          break;
      }
      break;
    /*
     * end of Done
     */
    case Error :
      /*
       * special chimpanzee error handling
       */
      if ((err==SC_WRONGCLASS) && (ATR.hist[0]==0x7))
      {
        dprintf(("", "Chimpanzee processing !!!!"));
        switch (entry_trans)
        {
          case ChangeCHVSWI:
            dprintf(("", "   change chv re-direction"));
            state = ChangingCHV;
            ChimpanzeeClassByte = 0xf0;
            ret = (*CurrExports->card_change_chv)(card_handle,entry.r[2],
              (char*)entry.r[3], entry.r[4],(char*)entry.r[5], entry.r[6]);
            ChimpanzeeClassByte = 0xa0;
            break;
          case UnBlockCHVSWI :
            dprintf(("", "   unblock chv re-direction"));
            state = UnBlockingCHV;
            ChimpanzeeClassByte = 0xf0;
  	    ret = (*CurrExports->card_unblock_chv)(card_handle,entry.r[2],
  	      (char*)entry.r[3], entry.r[4], (char*)entry.r[5], entry.r[6]);
            ChimpanzeeClassByte = 0xa0;
            break;
        }
        if (ret == SCI_FAIL)
        {
          err = SC_TRANSPORT;
          machine(Error,r);
        }
        break;
      }
      /*
       * otherwise
       */
      if (err == 0)
      {
        err = SC_TRANSPORT;
        ret = sctransport_error(card_handle);
      }

      status_error = err;
      sctransport_end_trans(card_handle);
      sctransport_close(card_handle);
      dprintf(("", "error 0x%x state (%s) entry (%s) ret %d\n",
      	    err,strState[state],strTransitions[entry_trans],ret));
      module_notify(Event_Complete,err);
      state = WaitingOpen;
      machine(Done,r);
      break;

    case Removed :
      module_notify(Event_CardRemoved,0);
      sctransport_close(card_handle);
      card_handle = -1;
      state = WaitingOpen;
      machine(Done,r);
      break;

    case ReStart :
      module_notify(Event_CardRemoved,0);
      card_handle = -1;
      state = WaitingOpen;
      machine(Done,r);
      break;

    case TransEnd :
      switch (state)
      {
        case WaitingTrans :
          state = Idle;
          doing_retry = 1;
          machine(entry_trans,&entry);
          break;
      }
      break;
    case GetATRSWI :
      dprintf(("", "(7) state = %d",state));
      switch (state)
      {
        case WaitingOpen : case WaitingATR :
      	  r->r[0] = SC_NOCARD;
      	  r->r[1] = 0;
      	  break;
      	default :
      	  dprintf(("", "(7) returning atr, atr len = %d",ATR.len));
      	  if (ATR.len>0)
      	  {
      	    int i;
      	    for (i=0; i<ATR.len; i++)
            {
      	      dprintf(("", "(7)    ATR[%d] : 0x%x\n",i,ATR.hist[i]));
            }
      	  }
      	  r->r[0] = SC_SUCCESS;
      	  r->r[1] = (int)&ATR;
      }
      break;
    case CreateSWI : case DeleteSWI : case ReadSWI :  case WriteSWI :
    case EnableCHVSWI : case UnBlockCHVSWI : case FileInfoSWI :
    case ChangeCHVSWI :
      switch (state)
      {
        case Idle :
	  dprintf(("", "entered via %s",strTransitions[transition]));
          entry_trans = transition; /* remember transition for later */
          if (!doing_retry)
            err = path_process((char*)r->r[1],files,&num_files);
          else
            err = SC_SUCCESS;

          doing_retry = 0;
          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            state = SelectingDir;
            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
              current_file = 0;
              ret = (*CurrExports->card_select_root)(card_handle);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                /* card locked against transactions, back off */
                state = WaitingTrans;
              }
            }
          }
          break;
        case WaitingOpen : case WaitingATR :
      	  err = SC_NOCARD;
      	  break;
        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;
        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;

    case InternalAuthSWI :
      switch (state)
      {
        case Idle :
          entry_trans = transition; /* remember transition for later */
          doing_retry = 0;
          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            state = WaitingInternalAuth;
            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
      	      ret = (*CurrExports->card_internal_auth)(card_handle,
      	      entry.r[2], (BYTE*)entry.r[3], entry.r[4]);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                /* card locked against transactions, back off */
                state = WaitingTrans;
              }
            }
          }
          break;
        case WaitingOpen : case WaitingATR :
      	  err = SC_NOCARD;
      	  break;
        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;
        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;
    case StatusSWI :
      if (status_error!=0)
        r->r[0] = StatusError;
      else
      {
        switch (state)
        {
          case WaitingOpen : case WaitingATR :
            r->r[0] = StatusNoCard;
            break;
          case Idle :
            r->r[0] = StatusIdle;
            break;
          default :
            r->r[0] = StatusBusy;
        }
      }
      r->r[1] = status_error;
      status_error=0;
      break;
  }
}
#else
/******************************************************************************
  the state machine for Funai3 MiniJIS cards
 ******************************************************************************/
void machine(t_transitions transition, _kernel_swi_regs *r)
{
  static _kernel_swi_regs entry;
  static int files[MAX_SUBDIRS];
  static int num_files;
  static int current_file;
  static int err;
  static int offset;
  static int chunk_size;
  static int status_error = 0;
  static int doing_retry = 0;
  BYTE file_header[25];
  BYTE resp[2];
  int data_length;
  int ret = SCI_SUCCESS;
  int access_condition;

  if (transition!=StatusSWI)
  {
    dprintf(("", "machine(): transition %s\n",strTransitions[transition]));
  }

  switch (transition)
  {
    case Done:
      switch (state)
      {
        case WaitingOpen:
          err = open_card();
          switch (err)
          {
            case SC_SUCCESS:
              state = WaitingATR;
              break;
	    case SC_UNDERSTAND:
              state = WaitingRemoval;
              break;
          }
          break;

        case WaitingATR:
          if (get_atr() == SC_SUCCESS)
          {
            state = Idle;
            module_notify(Event_CardOK,0);
          }
          else
          {
            state = WaitingRemoval;
            module_notify(Event_CardBad,0);
          }
          break;

        case WaitingStandby:
	case Idle:
          dprintf(("", "machine(): Idle state\n"));
	  /* i0ngore */
	  break;

	case SelectingDir:
          dprintf(("", "machine(): Selecting dir 2\n"));
          dprintf(("", "machine(): r3: '%s'\n", (char*)entry.r[3]));
          dprintf(("", "machine(): r5: '%s'\n", (char*)entry.r[5]));
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    if (current_file == num_files-1)   /* are we on the leaf name */
	    {
	      switch (entry_trans)
	      {
	        case CreateSWI :
	          state = Creating;
		  ret = (*CurrExports->card_create)(card_handle,
		      	files[current_file++],(entry.r[0]&1<<1)?1:0,entry.r[2],
		      	entry.r[3]);
	          break;

	        case ReadSWI:
	        case WriteSWI:
	        case DeleteSWI:
	        case FileInfoSWI:
                case ChangeCHVSWI:
                case EnableCHVSWI:
                case UnBlockCHVSWI:
    	          state = SelectingFile;
                  ret = (*CurrExports->card_select)(card_handle,
                      	files[current_file++]);
                  break;
              }
	    }
	    else if (current_file == num_files) /* leaf name was a directory */
	    {
	      switch (entry_trans)
	      {
	        case ChangeCHVSWI:
	          state = ChangingCHV;
  		  ret = (*CurrExports->card_change_chv)(card_handle,
  		      	entry.r[2], (char*)entry.r[3], entry.r[4],
  		      	(char*)entry.r[5], entry.r[6]);
	          break;

                case EnableCHVSWI:
                  state = EnablingCHV;
		  ret = (*CurrExports->card_enable_chv)(card_handle,
		      	entry.r[2],(entry.r[0]&1<<1)?1:0,(char*)entry.r[3],
		      	entry.r[4]);
	          break;

                case UnBlockCHVSWI:
                  state = UnBlockingCHV;
   		  ret = (*CurrExports->card_unblock_chv)(card_handle,
   		      	entry.r[2], (char*)entry.r[3],
   		      	entry.r[4], (char*)entry.r[5], entry.r[6]);
                  break;

                case FileInfoSWI:
	    	  state = GettingResponse;
	    	  ret = (*CurrExports->card_get_response)(card_handle,
	    	      	(int)resp[1]);
                  if (ret == SCI_FAIL)
            	  {
		    err = SC_TRANSPORT;
              	    machine(Error,r);
                  }
                  break;
              }
            }
	    else /* change into next directory in path */
	    {
	      ret = (*CurrExports->card_select)(card_handle,
	      	    files[current_file++]);
	    }
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	  {
	    machine(Error,r);
	  }
	  break;

	case SelectingFile:
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * we have successfully selected the file, get header response
	     */
	    dprintf(("", "machine(): file selected\n"));
	    state = GettingResponse;
	    ret = (*CurrExports->card_get_response)(card_handle,(int)resp[1]);
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case GettingResponse:
	  err=handle_response(file_header,sizeof(file_header),
	                      &data_length,resp);
	  dprintf(("", "machine(): got response, err = %d",err));
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * we have successfully get the response message, do something
	     */
	    switch (entry_trans)
	    {
              case DeleteSWI :
	        access_condition = file_header[9]>>4 & 0xf;
                if (access_condition==0) /* no write access cond */
                {
                  state = Deleting;
                  ret = (*CurrExports->card_delete)(card_handle,
                        files[num_files-1]);
                }
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
                else /* access condition to deal with */
                {
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
                }
                break;

	      case ReadSWI :
	        access_condition = file_header[8]>>4 & 0xf;
                if (access_condition==0) /* no read access cond */
                {
                  state = ReadingFile;
                  offset = 0;
                  chunk_size = CurrExports->chunk_size;
                  if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

                  ret = (*CurrExports->card_read)(card_handle,entry.r[2],
              	      	chunk_size);
                }
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
                else  /* access condition to deal with */
                {
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
                }
                break;

	      case WriteSWI:
	        access_condition = file_header[8] & 0xf;
                if (access_condition==0) /* no write access cond */
                {
       	          state = WritingFile;
                  offset = entry.r[2];
                  chunk_size = CurrExports->chunk_size;
                  if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

                  ret = (*CurrExports->card_write)(card_handle, offset,
        	        (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
        	}
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
        	else /* access condition to deal with */
        	{
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
        	}
	        break;

	      case FileInfoSWI :
	        dprintf(("", "machine(): FileInfoSWI"));
	      	if (entry.r[0] & 1<<1) /* bit 1 populate structure */
	      	{
	      	  t_sc_stat *stat_ptr = (t_sc_stat*)entry.r[2];

                  stat_ptr->num_files = -1;
                  stat_ptr->num_dirs  = -1;
                  stat_ptr->chv1_attempts = -1;
                  stat_ptr->unblock_chv1_attempts = -1;
	      	  stat_ptr->file = 1;        /* default to file */

	      	  if (ATR.hist[0] == 7) /* schlumberger */
	      	  {
	      	    dprintf(("", "(7)   schlumberger (0x%x)",file_header[6]));
      	            stat_ptr->size = file_header[2]<<8 | file_header[3];
		    if (file_header[6] == 0x38 || file_header[6] == 0x02)
		    {
	      	      stat_ptr->file = 0;        /* directory */
	      	      stat_ptr->chv1_enabled         = (file_header[18]==0)?0:1;
	      	      stat_ptr->unblock_chv1_enabled = (file_header[19]==0)?0:1;
      	              stat_ptr->num_dirs  	     = file_header[14];
      	              stat_ptr->num_files 	     = file_header[15];
  		      stat_ptr->chv1_attempts	     = file_header[18];
  		      stat_ptr->unblock_chv1_attempts= file_header[19];
		    }
	      	  }
	      	  else
	      	  {
	      	    dprintf(("", "(7)   other card (0x%x)",file_header[6]));
      	            stat_ptr->size = file_header[2]<<8 | file_header[3];
	      	    if (file_header[6] != 0x04) /* not file */
	      	    {
	      	      stat_ptr->file = 0;        /* directory */
	      	      stat_ptr->chv1_enabled         = file_header[18]>>7;
	      	      stat_ptr->unblock_chv1_enabled = file_header[19]>>7;
      	              stat_ptr->num_dirs  	     = file_header[14];
      	              stat_ptr->num_files 	     = file_header[15];
  		      stat_ptr->chv1_attempts	     = file_header[18] & 0xf;
  		      stat_ptr->unblock_chv1_attempts= file_header[19] & 0xf;
	      	    }
	      	  }
	      	}
	      	else
	      	{
                  dprintf(("", "machine(): Starting r3 copy\n"));
  	          if (entry.r[3]>sizeof(file_header))
  	            memcpy((char*)entry.r[2],file_header,sizeof(file_header));
  	          else
  	            memcpy((char*)entry.r[2],file_header,entry.r[3]);
                }
                sctransport_end_trans(card_handle);
	    	state = Idle;
	    	module_notify(Event_Complete,SC_SUCCESS);
	        break;
	    }

            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case GettingAuthResponse :
          err=handle_response((BYTE*)entry.r[5],entry.r[6],&data_length,resp);
	  if (err==SC_SUCCESS)
   	  {
            sctransport_end_trans(card_handle);
	    state = Idle;
            module_notify(Event_Complete,SC_SUCCESS);
	  }
	  else
	    machine(Error,r);
	  break;

	case VerifyingCHV :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS || (resp[0]==0x98 && resp[1]==0x08))
	  {
	    dprintf(("", "machine(): verified CHV\n"));
	    /*
	     * we have successfully verified the CHV, do something
	     */
	    switch (entry_trans)
	    {
              case DeleteSWI :
                state = Deleting;
                ret = (*CurrExports->card_delete)(card_handle,
                      files[num_files-1]);
                break;

              /* modified for minijis */
              case FileInfoSWI:
              {
                int *pinc;
                pinc =(int *)entry.r[0];
                dprintf(("", "machine(): End of FileInfo SWI\n"));
                dprintf(("", "machine(): SW1:%x  SW2:%x\n", resp[0],resp[1]));
                switch ( resp [ 1] & 0xff)
                {
                  case 0:
                    dprintf(("", "machine(): Unlimited attempts left (-1)\n"));
                    *pinc =-1;
                    break;

                  case 0xc0:
                    dprintf(("", "machine(): CHV Blocked (0)\n"));
                    *pinc =0;
                    break;

                  default:
                    dprintf(("", "machine(): Attempts left: %d\n", ( resp[1] &0xf)));
                    *pinc =( resp[1] &0xf);
                  break;
                }
                sctransport_end_trans(card_handle);
	    	state = Idle;
	    	module_notify(Event_Complete,SC_SUCCESS);
              }
              break;

	      case ReadSWI:
	        if (resp[0]==0x63 && resp[1]==0x00) /* invalid pin */
	        {
                  dprintf(("", "machine(): bad pin\n"));
                  sctransport_end_trans(card_handle);
                  state = Idle;
	    	  module_notify(Event_Complete,SC_FAILACCESSCODE);
	        }
	        else
	        {
                  minijis_current =1;  /* current record being read */
                  minijis_records =0;  /* number of records on card */

                  state = ReadingFile;
                  offset = 0;
                  chunk_size = CurrExports->chunk_size;
                  /*if (chunk_size>entry.r[4])
                    chunk_size = entry.r[4];*/
                  ret = (*CurrExports->card_read)(card_handle,minijis_current,
	                chunk_size);
                dprintf(("", "machine(): 0:issued read for record: %d\n",
                         minijis_current));
	        }
	        break;

	      case WriteSWI:
	        if (resp[0]==0x63 && resp[1]==0x00) /* invalid pin */
	        {
                  dprintf(("", "machine(): bad pin\n"));
                  sctransport_end_trans(card_handle);
                  state = Idle;
	    	  module_notify(Event_Complete,SC_FAILACCESSCODE);
	        }
	        else
	        {
                  minijis_offset   =0;  /* offset into user buffer */
                  minijis_currentw =1;  /* current record being written */
                  memfill ( minijis_buff, 1024, FILL_CHAR);
                  buff_to_records ((char*)entry.r[3], entry.r[4],
                     minijis_buff, minijis_records*27, minijis_records);
                  /*
                  dprintf(("", "machine(): Before reorder:\n");
                  print_buff ( minijis_buff, 7);
                  reorder_buff ( minijis_buff, 27, 7);
                  dprintf(("", "machine(): After reorder:\n");
                  print_buff ( minijis_buff, 7); */

                  state = WritingFile;
                  offset = 0;
                  chunk_size = CurrExports->chunk_size;
                  ret = (*CurrExports->card_write)(card_handle, offset,
	                (BYTE*)(minijis_buff+offset), chunk_size);
	        }
	        break;

              case ChangeCHVSWI:
	        if (resp[0]==0x63 && resp[1]==0x00) /* invalid pin */
	        {
                  dprintf(("", "machine(): bad pin\n"));
                  sctransport_end_trans(card_handle);
                  state = Idle;
	    	  module_notify(Event_Complete,SC_FAILACCESSCODE);
	        }
	        else
	        {
                  state = ChangingCHV;
                  ret = (*CurrExports->card_change_chv)(card_handle,
                         entry.r[2], (char*)entry.r[3], entry.r[4],
                         (char*)entry.r[5], entry.r[6]);
	        }
                break;

	    }
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case Creating:
	case Deleting:
	case ChangingCHV:
	case EnablingCHV:
	case UnBlockingCHV:
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
            sctransport_end_trans(card_handle);
	    state = Idle;
	    module_notify(Event_Complete,SC_SUCCESS);
	  }
	  else
	    machine(Error,r);
	  break;

	case ReadingFile:
	  dprintf(("", "machine(): ReadingFile\n"));
	  dprintf(("", "machine(): finished reading record: %d\n", minijis_current));
	  //err=handle_response((BYTE*)(entry.r[3]+offset),chunk_size,
	  //   &data_length,resp);
	  err=handle_response((BYTE*)(minijis_buff+offset),chunk_size,
	     &data_length,resp);
	  dprintf(("", "machine(): handle response - data length: %d\n", data_length));
	  dprintf(("", "machine(): handle response result: %d\n", err));
#ifdef DEBUGLIB
          print_rec ( minijis_buff+offset);
#endif
	  if (( err ==SC_SUCCESS) || ( err ==SC_NOTFOUND))
	  {
	    offset+=chunk_size;
            /* have we finished reading yet */
	    //if ((offset>=entry.r[4]) || ( minijis_current>=7))
	    if ( minijis_current>30 || ( resp[0] ==0x6a && resp[1] ==0x83))
	    {
	      dprintf(("", "machine(): 0:Total records read: %d\n", minijis_records));
              dprintf(("", "machine(): Before reorder:\n"));
              print_buff ( minijis_buff, minijis_records);
              reorder_buff ( minijis_buff, 27, minijis_records);
              dprintf(("", "machine(): After reorder:\n"));
              print_buff ( minijis_buff, minijis_records);
              records_to_buff (( char*)entry.r[3], minijis_buff,
                               minijis_records);
              sctransport_end_trans(card_handle);
	      state = Idle;
	      module_notify(Event_Complete,SC_SUCCESS);
	      dprintf(("", "machine(): 1:Total records read: %d\n", minijis_records));
	    }
	    else
	    {
              minijis_current+=1;
              minijis_records+=1;
	      chunk_size = CurrExports->chunk_size;
	      //if (entry.r[4]-offset<chunk_size) chunk_size = entry.r[4]-offset;
                ret = (*CurrExports->card_read)(card_handle,minijis_current,
	      	       chunk_size);
              dprintf(("", "machine(): 1:issued read for record: %d\n",
                       minijis_current));
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
	    }
  	  }
  	  else
          {
            records_to_buff (( char*)entry.r[3], minijis_buff, 7);
  	    machine(Error,r);
          }
	  break;

	case WritingFile:
          err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /* have we finished writing yet */
	    //if (minijis_currentw >=minijis_records)
	      dprintf(("", "machine(): total number of records: %d\n",
	               minijis_records));
	      dprintf(("", "machine(): finished writing: %d\n",
	               minijis_currentw));
	    if (minijis_currentw >=minijis_records)
	    {
              sctransport_end_trans(card_handle);
	      state = Idle;
	      module_notify(Event_Complete,SC_SUCCESS);
	    }
	    else
	    {
	      minijis_currentw +=1;
              chunk_size = CurrExports->chunk_size;
	      dprintf(("", "machine(): chunk_size: %d\n", chunk_size));
              offset+=chunk_size;
	      dprintf(("", "machine(): write offset: %d\n", offset));
              ret = (*CurrExports->card_write)(card_handle, offset,
                     (BYTE*)(minijis_buff+offset),chunk_size);
              dprintf(("", "machine(): Writing record: %d\n\n", minijis_currentw));
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
	      }
	    }
	  }
	  else
	    machine(Error,r);
	  break;

	case WaitingInternalAuth :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * authentication complete, now need to fetch the stuff
	     */
 	    state = GettingAuthResponse;
	    ret = (*CurrExports->card_get_response)(card_handle,(int)resp[1]);
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;
        default :
          dprintf(("", "machine(): Ilegal state (%s) in Done\n",strState[state]));
	  state = Idle;
          break;
      }
      break;
    /*
     * end of Done
     */
    case Error :
      /*
       * special chimpanzee error handling
       */
      if ((err==SC_WRONGCLASS) && (ATR.hist[0]==0x7))
      {
        dprintf(("", "machine(): Chimpanzee processing !!!!"));
        switch (entry_trans)
        {
          case ChangeCHVSWI :
            dprintf(("", "machine(): change chv re-direction"));
            state = ChangingCHV;
            ChimpanzeeClassByte = 0xf0;
            ret = (*CurrExports->card_change_chv)(card_handle,entry.r[2],
              (char*)entry.r[3], entry.r[4],(char*)entry.r[5], entry.r[6]);
            ChimpanzeeClassByte = 0xa0;
            break;
          case UnBlockCHVSWI :
            dprintf(("", "machine(): unblock chv re-direction"));
            state = UnBlockingCHV;
            ChimpanzeeClassByte = 0xf0;
  	    ret = (*CurrExports->card_unblock_chv)(card_handle,entry.r[2],
  	      (char*)entry.r[3], entry.r[4], (char*)entry.r[5], entry.r[6]);
            ChimpanzeeClassByte = 0xa0;
            break;
        }
        if (ret == SCI_FAIL)
        {
          err = SC_TRANSPORT;
          machine(Error,r);
        }
        break;
      }
      /*
       * otherwise
       */
      if (err == 0)
      {
        err = SC_TRANSPORT;
        ret = sctransport_error(card_handle);
      }

      status_error = err;
      sctransport_end_trans(card_handle);
      sctransport_close(card_handle);
      dprintf(("", "machine(): error 0x%x state (%s) entry (%s) ret %d\n",
      	    err,strState[state],strTransitions[entry_trans],ret));

      module_notify(Event_Complete,err);
      state = WaitingOpen;
      machine(Done,r);
      break;

    case Removed:
      module_notify(Event_CardRemoved,0);
      sctransport_close(card_handle);
      card_handle = -1;
      state = WaitingOpen;
      minijis_current  =0;   /* current record being read */
      minijis_currentw =0;   /* current record being written */
      minijis_records  =0;   /* number of records on card */
      minijis_offset   =0;   /* offset into card buffer */
      machine(Done,r);
      break;

    case ReStart:
      module_notify(Event_CardRemoved,0);
      card_handle = -1;
      state = WaitingOpen;
      machine(Done,r);
      break;

    /* shut scinterface down for now */
    case Shutdown:
      dprintf(("", "machine(): shutdown(1)\n"));
      module_notify(Event_CardRemoved,0);
      sctransport_close(card_handle);
      card_handle = -1;
      state = WaitingStandby;
      minijis_current  =0;   /* current record being read */
      minijis_currentw =0;   /* current record being written */
      minijis_records  =0;   /* number of records on card */
      minijis_offset   =0;   /* offset into card buffer */
      machine(Done,r);
      break;

    /* wake scinterface up after shutdown */
    case Standby:
      dprintf(("", "machine(): standby(1)\n"));
      if (state == WaitingStandby)
      {
        state = WaitingOpen;
        machine(Done,r);
      }
      break;

    case TransEnd :
      switch (state)
      {
        case WaitingTrans :
          state = Idle;
          doing_retry = 1;
          machine(entry_trans,&entry);
          break;
      }
      break;
    case GetATRSWI :
      dprintf(("", "machine(): state = %d",state));
      switch (state)
      {
        case WaitingOpen : case WaitingATR : case WaitingStandby :
      	  r->r[0] = SC_NOCARD;
      	  r->r[1] = 0;
      	  break;
      	default :
      	  dprintf(("", "machine(): returning atr, atr len = %d",ATR.len));
      	  if (ATR.len>0)
      	  {
      	    int i;
      	    for (i=0; i<ATR.len; i++)
            {
      	      dprintf(("", "(7)    ATR[%d] : 0x%x\n",i,ATR.hist[i]));
            }
      	  }
      	  r->r[0] = SC_SUCCESS;
      	  r->r[1] = (int)&ATR;
      }
      break;

    /* first entry point for these swis */
    case ReadSWI:
    case WriteSWI:
    case ChangeCHVSWI:
    case FileInfoSWI:
      switch (state)
      {
        case Idle:
	  dprintf(("", "machine(): 0:entered via %s\n",strTransitions[transition]));
          entry_trans = transition; /* remember transition for later */
          err = SC_SUCCESS;
          doing_retry = 0;

          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            dprintf(("", "machine(): Verifying CHV\n"));
            state = VerifyingCHV;
            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
              current_file = 0;
              switch ( transition)
              {
                case FileInfoSWI:
                  ret = (*CurrExports->card_verify_chv)(card_handle, 0,NULL,0);
                  break;

                case ChangeCHVSWI:
                  ret = (*CurrExports->card_verify_chv)(card_handle,
                          access_condition,(char*)entry.r[3],entry.r[4]);
                  break;

                default:
                  ret = (*CurrExports->card_verify_chv)(card_handle,
                          access_condition,(char*)entry.r[5],entry.r[6]);
                  //ret = (*CurrExports->card_verify_chv)(card_handle,
                  //        access_condition,(char*)"00000000",8);
                  break;
              }
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                 /* card locked against transactions, back off */
                  state = WaitingTrans;
              }
            }
          }
          break;

        case WaitingOpen : case WaitingATR : case WaitingStandby :
      	  err = SC_NOCARD;
      	  break;

        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;

        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;

    /* first entry point for these swis */
    case CreateSWI:
    case DeleteSWI:
    case EnableCHVSWI:
    case UnBlockCHVSWI:
      switch (state)
      {
        case Idle:
	  dprintf(("", "machine(): 1:entered via %s\n",strTransitions[transition]));
          entry_trans = transition; /* remember transition for later */
          if (!doing_retry)
          {
            err = path_process((char*)r->r[1],files,&num_files);
	    dprintf(("", "machine(): path process result: %d\n", err));
          }
          else
            err = SC_SUCCESS;

          doing_retry = 0;
          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            if ( transition ==ChangeCHVSWI && current_card_type ==3)
            {
              dprintf(("", "machine(): Verifying CHV\n"));
              state = VerifyingCHV;
            }
            else
              state = SelectingDir;

            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
              current_file = 0;
              if ( transition ==ChangeCHVSWI && current_card_type ==3)
                ret = (*CurrExports->card_verify_chv)(card_handle,
                       access_condition,(char*)entry.r[3],entry.r[4]);
              else
                ret = (*CurrExports->card_select_root)(card_handle);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                 /* card locked against transactions, back off */
                  state = WaitingTrans;
              }
            }
          }
          break;

        case WaitingOpen : case WaitingATR : case WaitingStandby :
      	  err = SC_NOCARD;
      	  break;

        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;

        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;

    case InternalAuthSWI :
      switch (state)
      {
        case Idle :
          entry_trans = transition; /* remember transition for later */
          doing_retry = 0;
          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            state = WaitingInternalAuth;
            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
      	      ret = (*CurrExports->card_internal_auth)(card_handle,
      	      entry.r[2], (BYTE*)entry.r[3], entry.r[4]);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                /* card locked against transactions, back off */
                state = WaitingTrans;
              }
            }
          }
          break;
        case WaitingOpen : case WaitingATR : case WaitingStandby :
      	  err = SC_NOCARD;
      	  break;
        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;
        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;
    case StatusSWI :
      if (status_error!=0)
        r->r[0] = StatusError;
      else
      {
        switch (state)
        {
          case WaitingOpen : case WaitingATR : case WaitingStandby :
            r->r[0] = StatusNoCard;
            break;
          case Idle :
            r->r[0] = StatusIdle;
            break;
          default :
            r->r[0] = StatusBusy;
        }
      }
      r->r[1] = status_error;
      status_error=0;
      break;
  }
}
#endif
@


4.3
log
@	Changed the component to use srccommit.
Detail:
	This component would not build with the latest version of RemoteDB as
the names used have been changed. Have used this opportunity to alter the
component to use DebugLib. There have been no functionality changes.
	Default output mechanism is to zip disc.
	Altered the makefile to use Stripdepend.
Admin:
	Tested as a softload on a Funai 4 build and actually in a Funai 4
build.

Version 0.22. Tagged as 'SCInter-0_22'
@
text
@d1206 1
d1208 1
@


4.2
log
@Added code to deal with card removal/chainging during power down
@
text
@d52 2
a74 1
#ifdef debug
d76 3
a78 2
    printf("machine (%s)\n",strTransitions[transition]);
#endif
d195 1
a195 3
#ifdef debug
	    printf("file selected\n");
#endif
d211 1
a211 3
#ifdef debug
	  printf("(7) got response, err = %d",err);
#endif
d288 1
a288 3
#ifdef debug
	        printf("(7) FileInfoSWI");
#endif
d301 1
a301 3
#ifdef debug
	      	    printf("(7)   schlumberger (0x%x)",file_header[6]);
#endif
d316 1
a316 3
#ifdef debug
	      	    printf("(7)   other card (0x%x)",file_header[6]);
#endif
d369 1
a369 3
#ifdef debug
	    printf("verified CHV\n");
#endif
d497 1
a497 3
#ifdef debug
          printf("Ilegal state (%s) in Done\n",strState[state]);
#endif
d511 1
a511 3
#ifdef debug
        printf("Chimpanzee processing !!!!");
#endif
d515 1
a515 3
#ifdef debug
            printf("   change chv re-direction");
#endif
d523 1
a523 3
#ifdef debug
            printf("   unblock chv re-direction");
#endif
d550 2
a551 4
#ifdef debug
      printf("error 0x%x state (%s) entry (%s) ret %d\n",
      	    err,strState[state],strTransitions[entry_trans],ret);
#endif
d583 1
a583 3
#ifdef debug
      printf("(7) state = %d",state);
#endif
d591 1
a591 2
#ifdef debug
      	  printf("(7) returning atr, atr len = %d",ATR.len);
d596 3
a598 1
      	      printf("(7)    ATR[%d] : 0x%x\n",i,ATR.hist[i]);
a599 1
#endif
d610 1
a610 3
#ifdef debug
	  printf("entered via %s",strTransitions[transition]);
#endif
a743 1
#ifdef debug
d745 3
a747 2
    printf("SCINTERFACE: machine (%s)\n",strTransitions[transition]);
#endif
d782 1
a782 3
#ifdef debug
          printf ( "SCINTERFACE: Idle state\n");
#endif
d787 3
a789 5
#ifdef debug
          printf ( "SCINTERFACE: Selecting dir 2\n");
          printf ( "SCINTERFACE: r3: '%s'\n", (char*)entry.r[3]);
          printf ( "SCINTERFACE: r5: '%s'\n", (char*)entry.r[5]);
#endif
d878 1
a878 3
#ifdef debug
	    printf("SCINTERFACE: file selected\n");
#endif
d894 1
a894 3
#ifdef debug
	  printf("SCINTERFACE: got response, err = %d",err);
#endif
d974 1
a974 3
#ifdef debug
	        printf("SCINTERFACE: FileInfoSWI");
#endif
d987 1
a987 3
#ifdef debug
	      	    printf("(7)   schlumberger (0x%x)",file_header[6]);
#endif
d1002 1
a1002 3
#ifdef debug
	      	    printf("(7)   other card (0x%x)",file_header[6]);
#endif
d1018 1
a1018 3
#ifdef debug
                  printf ( "SCINTERFACE: Starting r3 copy\n");
#endif
d1056 1
a1056 3
#ifdef debug
	    printf("SCINTERFACE: verified CHV\n");
#endif
d1073 2
a1074 4
#ifdef debug
                printf ( "SCINTERFACE: End of FileInfo SWI\n");
                printf ( "SCINTERFACE: SW1:%x  SW2:%x\n", resp[0],resp[1]);
#endif
d1078 1
a1078 3
#ifdef debug
                    printf ( "SCINTERFACE: Unlimited attempts left (-1)\n");
#endif
d1083 1
a1083 3
#ifdef debug
                    printf ( "SCINTERFACE: CHV Blocked (0)\n");
#endif
d1088 1
a1088 3
#ifdef debug
                    printf ( "SCINTERFACE: Attempts left: %d\n", ( resp[1] &0xf));
#endif
d1101 1
a1101 3
#ifdef debug
                  printf ( "SCINTERFACE: bad pin\n");
#endif
d1118 2
a1119 4
#ifdef debug
                printf ( "SCINTERFACE: 0:issued read for record: %d\n",
                         minijis_current);
#endif
d1126 1
a1126 3
#ifdef debug
                  printf ( "SCINTERFACE: bad pin\n");
#endif
d1139 1
a1139 1
                  printf ( "SCINTERFACE: Before reorder:\n");
d1142 1
a1142 1
                  printf ( "SCINTERFACE: After reorder:\n");
d1156 1
a1156 3
#ifdef debug
                  printf ( "SCINTERFACE: bad pin\n");
#endif
d1198 2
a1199 4
#ifdef debug
	  printf ( "SCINTERFACE: ReadingFile\n");
	  printf ( "SCINTERFACE: finished reading record: %d\n", minijis_current);
#endif
d1204 2
a1205 3
#ifdef debug
	  printf ( "SCINTERFACE: handle response - data length: %d\n", data_length);
	  printf ( "SCINTERFACE: handle response result: %d\n", err);
a1206 1
#endif
d1214 2
a1215 3
#ifdef debug
	      printf ( "SCINTERFACE: 0:Total records read: %d\n", minijis_records);
              printf ( "SCINTERFACE: Before reorder:\n");
a1216 1
#endif
d1218 1
a1218 2
#ifdef debug
              printf ( "SCINTERFACE: After reorder:\n");
a1219 1
#endif
d1225 1
a1225 3
#ifdef debug
	      printf ( "SCINTERFACE: 1:Total records read: %d\n", minijis_records);
#endif
d1235 2
a1236 4
#ifdef debug
              printf ( "SCINTERFACE: 1:issued read for record: %d\n",
                       minijis_current);
#endif
d1257 4
a1260 6
#ifdef debug
	      printf ( "SCINTERFACE: total number of records: %d\n",
	               minijis_records);
	      printf ( "SCINTERFACE: finished writing: %d\n",
	               minijis_currentw);
#endif
d1271 1
a1271 3
#ifdef debug
	      printf ( "SCINTERFACE: chunk_size: %d\n", chunk_size);
#endif
d1273 1
a1273 3
#ifdef debug
	      printf ( "SCINTERFACE: write offset: %d\n", offset);
#endif
d1276 1
a1276 3
#ifdef debug
              printf ( "SCINTERFACE: Writing record: %d\n\n", minijis_currentw);
#endif
d1307 1
a1307 3
#ifdef debug
          printf("SCINTERFACE: Ilegal state (%s) in Done\n",strState[state]);
#endif
d1321 1
a1321 3
#ifdef debug
        printf("SCINTERFACE: Chimpanzee processing !!!!");
#endif
d1325 1
a1325 3
#ifdef debug
            printf("SCINTERFACE: change chv re-direction");
#endif
d1333 1
a1333 3
#ifdef debug
            printf("SCINTERFACE: unblock chv re-direction");
#endif
d1360 2
a1361 4
#ifdef debug
      printf("SCINTERFACE: error 0x%x state (%s) entry (%s) ret %d\n",
      	    err,strState[state],strTransitions[entry_trans],ret);
#endif
d1389 1
a1389 3
#ifdef debug
      printf ( "SCINTERFACE: shutdown(1)\n");
#endif
d1403 1
a1403 3
#ifdef debug
      printf ( "SCINTERFACE: standby(1)\n");
#endif
d1422 1
a1422 3
#ifdef debug
      printf("SCINTERFACE: state = %d",state);
#endif
d1430 1
a1430 2
#ifdef debug
      	  printf("SCINTERFACE: returning atr, atr len = %d",ATR.len);
d1435 3
a1437 1
      	      printf("(7)    ATR[%d] : 0x%x\n",i,ATR.hist[i]);
a1438 1
#endif
d1452 1
a1452 3
#ifdef debug
	  printf("SCINTERFACE: 0:entered via %s\n",strTransitions[transition]);
#endif
d1460 1
a1460 3
#ifdef debug
            printf("SCINTERFACE: Verifying CHV\n");
#endif
d1525 1
a1525 3
#ifdef debug
	  printf("SCINTERFACE: 1:entered via %s\n",strTransitions[transition]);
#endif
d1530 1
a1530 3
#ifdef debug
	    printf("SCINTERFACE: path process result: %d\n", err);
#endif
d1541 1
a1541 3
#ifdef debug
              printf("SCINTERFACE: Verifying CHV\n");
#endif
@


4.1
log
@Moved to trunk.

Version 0.18. Tagged as 'SCInter-0_18'
@
text
@d806 3
d1477 3
d1493 3
d1498 2
a1499 2
	  state = WaitingOpen;
	  machine(Done,r);
@


1.1
log
@file machine was initially added on branch Spinner.
@
text
@d1 1750
@


1.1.2.1
log
@Modified to work with Funai3 T=1 cards

Version 0.17, 1.1.2.2. Tagged as 'SCInter-0_17-1_1_2_2'
@
text
@a0 1727
/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

/*
 * State machine for cards
 *
 * Modification History
 *---------------------
 *
 * 24-Nov-98  AJP,  Split from module.c to accomodate new state machine.
 *                  This file contains 2 state machines, one for the orginal
 *                  NC T=0 cards and a new one to accomodate the Funai3
 *                  T=1 cards.
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include "kernel.h"
#include "swis.h"
#include "sctrans.h"
#include "module.h"
#include "irqs.h"
#include "header.h"
#include "scinter.h"
#include "cards.h"
#include "path.h"
#include "records.h"

#ifndef MINIJIS_CARD
/******************************************************************************
  the state machine for Orga, Incard and Schlumberger cards
 ******************************************************************************/
void machine(t_transitions transition, _kernel_swi_regs *r)
{
  static _kernel_swi_regs entry;
  static int files[MAX_SUBDIRS];
  static int num_files;
  static int current_file;
  static int err;
  static int offset;
  static int chunk_size;
  static int status_error = 0;
  static int doing_retry = 0;
  BYTE file_header[25];
  BYTE resp[2];
  int data_length;
  int ret = SCI_SUCCESS;
  int access_condition;

#ifdef debug
  if (transition!=StatusSWI)
    printf("machine (%s)\n",strTransitions[transition]);
#endif

  switch (transition)
  {
    case Done :
      switch (state)
      {
        case WaitingOpen :
          err = open_card();
          switch (err)
          {
            case SC_SUCCESS :
              state = WaitingATR;
              break;
	    case SC_UNDERSTAND :
              state = WaitingRemoval;
              break;
          }
          break;
        case WaitingATR :
          if (get_atr() == SC_SUCCESS)
          {
            state = Idle;
            module_notify(Event_CardOK,0);
          }
          else
          {
            state = WaitingRemoval;
            module_notify(Event_CardBad,0);
          }
          break;
	case Idle :
	  /* ingore */
	  break;
	case SelectingDir :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    if (current_file == num_files-1)   /* are we on the leaf name */
	    {
	      switch (entry_trans)
	      {
	        case CreateSWI :
	          state = Creating;
		  ret = (*CurrExports->card_create)(card_handle,
		      	files[current_file++],(entry.r[0]&1<<1)?1:0,entry.r[2],
		      	entry.r[3]);
	          break;
	        case ReadSWI : case WriteSWI :
	        case DeleteSWI : case FileInfoSWI :
    	          state = SelectingFile;
                  ret = (*CurrExports->card_select)(card_handle,
                      	files[current_file++]);
                  break;
                case ChangeCHVSWI :
                case EnableCHVSWI : case UnBlockCHVSWI :
	      	  ret = (*CurrExports->card_select)(card_handle,
	      	      	files[current_file++]);
                  break;
              }
	    }
	    else if (current_file == num_files) /* leaf name was a directory */
	    {
	      switch (entry_trans)
	      {
	        case ChangeCHVSWI :
	          state = ChangingCHV;
  		  ret = (*CurrExports->card_change_chv)(card_handle,
  		      	entry.r[2], (char*)entry.r[3], entry.r[4],
  		      	(char*)entry.r[5], entry.r[6]);
	          break;
                case EnableCHVSWI :
                  state = EnablingCHV;
		  ret = (*CurrExports->card_enable_chv)(card_handle,
		      	entry.r[2],(entry.r[0]&1<<1)?1:0,(char*)entry.r[3],
		      	entry.r[4]);
	          break;
                case UnBlockCHVSWI :
                  state = UnBlockingCHV;
   		  ret = (*CurrExports->card_unblock_chv)(card_handle,
   		      	entry.r[2], (char*)entry.r[3],
   		      	entry.r[4], (char*)entry.r[5], entry.r[6]);
                  break;
                case FileInfoSWI :
	    	  state = GettingResponse;
	    	  ret = (*CurrExports->card_get_response)(card_handle,
	    	      	(int)resp[1]);
                  if (ret == SCI_FAIL)
            	  {
		    err = SC_TRANSPORT;
              	    machine(Error,r);
                  }
                  break;
              }
            }
	    else /* change into next directory in path */
	    {
	      ret = (*CurrExports->card_select)(card_handle,
	      	    files[current_file++]);
	    }
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case SelectingFile :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * we have successfully selected the file, get header response
	     */
#ifdef debug
	    printf("file selected\n");
#endif
	    state = GettingResponse;
	    ret = (*CurrExports->card_get_response)(card_handle,(int)resp[1]);
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case GettingResponse :
	  err=handle_response(file_header,sizeof(file_header),
	                      &data_length,resp);
#ifdef debug
	  printf("(7) got response, err = %d",err);
#endif
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * we have successfully get the response message, do something
	     */
	    switch (entry_trans)
	    {
              case DeleteSWI :
	        access_condition = file_header[9]>>4 & 0xf;
                if (access_condition==0) /* no write access cond */
                {
                  state = Deleting;
                  ret = (*CurrExports->card_delete)(card_handle,
                        files[num_files-1]);
                }
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
                else /* access condition to deal with */
                {
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
                }
                break;
	      case ReadSWI :
	        access_condition = file_header[8]>>4 & 0xf;
                if (access_condition==0) /* no read access cond */
                {
                  state = ReadingFile;
                  offset = 0;
                  chunk_size = CurrExports->chunk_size;
                  if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

                  ret = (*CurrExports->card_read)(card_handle,entry.r[2],
              	      	chunk_size);
                }
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
                else  /* access condition to deal with */
                {
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
                }
                break;
	      case WriteSWI:
	        access_condition = file_header[8] & 0xf;
                if (access_condition==0) /* no write access cond */
                {
       	          state = WritingFile;
                  offset = entry.r[2];
                  chunk_size = CurrExports->chunk_size;
                  if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

                  ret = (*CurrExports->card_write)(card_handle, offset,
        	        (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
        	}
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
        	else /* access condition to deal with */
        	{
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
        	}
	        break;
	      case FileInfoSWI :
#ifdef debug
	        printf("(7) FileInfoSWI");
#endif
	      	if (entry.r[0] & 1<<1) /* bit 1 populate structure */
	      	{
	      	  t_sc_stat *stat_ptr = (t_sc_stat*)entry.r[2];

                  stat_ptr->num_files = -1;
                  stat_ptr->num_dirs  = -1;
                  stat_ptr->chv1_attempts = -1;
                  stat_ptr->unblock_chv1_attempts = -1;
	      	  stat_ptr->file = 1;        /* default to file */

	      	  if (ATR.hist[0] == 7) /* schlumberger */
	      	  {
#ifdef debug
	      	    printf("(7)   schlumberger (0x%x)",file_header[6]);
#endif
      	            stat_ptr->size = file_header[2]<<8 | file_header[3];
		    if (file_header[6] == 0x38 || file_header[6] == 0x02)
		    {
	      	      stat_ptr->file = 0;        /* directory */
	      	      stat_ptr->chv1_enabled         = (file_header[18]==0)?0:1;
	      	      stat_ptr->unblock_chv1_enabled = (file_header[19]==0)?0:1;
      	              stat_ptr->num_dirs  	     = file_header[14];
      	              stat_ptr->num_files 	     = file_header[15];
  		      stat_ptr->chv1_attempts	     = file_header[18];
  		      stat_ptr->unblock_chv1_attempts= file_header[19];
		    }
	      	  }
	      	  else
	      	  {
#ifdef debug
	      	    printf("(7)   other card (0x%x)",file_header[6]);
#endif
      	            stat_ptr->size = file_header[2]<<8 | file_header[3];
	      	    if (file_header[6] != 0x04) /* not file */
	      	    {
	      	      stat_ptr->file = 0;        /* directory */
	      	      stat_ptr->chv1_enabled         = file_header[18]>>7;
	      	      stat_ptr->unblock_chv1_enabled = file_header[19]>>7;
      	              stat_ptr->num_dirs  	     = file_header[14];
      	              stat_ptr->num_files 	     = file_header[15];
  		      stat_ptr->chv1_attempts	     = file_header[18] & 0xf;
  		      stat_ptr->unblock_chv1_attempts= file_header[19] & 0xf;
	      	    }
	      	  }
	      	}
	      	else
	      	{
  	          if (entry.r[3]>sizeof(file_header))
  	            memcpy((char*)entry.r[2],file_header,sizeof(file_header));
  	          else
  	            memcpy((char*)entry.r[2],file_header,entry.r[3]);
                }
                sctransport_end_trans(card_handle);
	    	state = Idle;
	    	module_notify(Event_Complete,SC_SUCCESS);
	        break;
	    }

            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case GettingAuthResponse :
          err=handle_response((BYTE*)entry.r[5],entry.r[6],&data_length,resp);
	  if (err==SC_SUCCESS)
   	  {
            sctransport_end_trans(card_handle);
	    state = Idle;
            module_notify(Event_Complete,SC_SUCCESS);
	  }
	  else
	    machine(Error,r);
	  break;

	case VerifyingCHV :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS || (resp[0]==0x98 && resp[1]==0x08))
	  {
#ifdef debug
	    printf("verified CHV\n");
#endif
	    /*
	     * we have successfully verified the CHV, do something
	     */
	    switch (entry_trans)
	    {
              case DeleteSWI :
                state = Deleting;
                ret = (*CurrExports->card_delete)(card_handle,
                      files[num_files-1]);
	      case ReadSWI :
	        state = ReadingFile;
	        offset = 0;
	        chunk_size = CurrExports->chunk_size;
	        if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

	        ret = (*CurrExports->card_read)(card_handle,entry.r[2],
	              chunk_size);
	        break;
	      case WriteSWI :
	        state = WritingFile;
	        offset = entry.r[2];
	        chunk_size = CurrExports->chunk_size;
	        if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

	        ret = (*CurrExports->card_write)(card_handle, offset,
	               (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
	        break;
	    }
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case Creating : case Deleting :
	case ChangingCHV : case EnablingCHV : case UnBlockingCHV :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
            sctransport_end_trans(card_handle);
	    state = Idle;
	    module_notify(Event_Complete,SC_SUCCESS);
	  }
	  else
	    machine(Error,r);

	  break;

	case ReadingFile :
	  err=handle_response((BYTE*)(entry.r[3]+offset),chunk_size,
	     &data_length,resp);
	  if (err == SC_SUCCESS)
	  {
	    offset+=chunk_size;
	    if (offset>=entry.r[4])  /* have we finished reading yet */
	    {
              sctransport_end_trans(card_handle);
	      state = Idle;
	      module_notify(Event_Complete,SC_SUCCESS);
	    }
	    else
	    {
	      chunk_size = CurrExports->chunk_size;
	      if (entry.r[4]-offset<chunk_size) chunk_size = entry.r[4]-offset;

	      ret = (*CurrExports->card_read)(card_handle,entry.r[2]+offset,
	      	    chunk_size);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
	    }
  	  }
  	  else
  	    machine(Error,r);
	  break;
	case WritingFile :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    offset+=chunk_size;
	    if (offset>=entry.r[4])  /* have we finished writing yet */
	    {
              sctransport_end_trans(card_handle);
	      state = Idle;
	      module_notify(Event_Complete,SC_SUCCESS);
	    }
	    else
	    {
	      chunk_size = CurrExports->chunk_size;
	      if (offset+chunk_size>entry.r[4]) chunk_size = entry.r[4]-offset;
	      ret = (*CurrExports->card_write)(card_handle, offset,
	            (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
	    }
	  }
	  else
	    machine(Error,r);
	  break;
	case WaitingInternalAuth :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * authentication complete, now need to fetch the stuff
	     */
 	    state = GettingAuthResponse;
	    ret = (*CurrExports->card_get_response)(card_handle,(int)resp[1]);
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;
        default :
#ifdef debug
          printf("Ilegal state (%s) in Done\n",strState[state]);
#endif
	  state = Idle;
          break;
      }
      break;
    /*
     * end of Done
     */
    case Error :
      /*
       * special chimpanzee error handling
       */
      if ((err==SC_WRONGCLASS) && (ATR.hist[0]==0x7))
      {
#ifdef debug
        printf("Chimpanzee processing !!!!");
#endif
        switch (entry_trans)
        {
          case ChangeCHVSWI:
#ifdef debug
            printf("   change chv re-direction");
#endif
            state = ChangingCHV;
            ChimpanzeeClassByte = 0xf0;
            ret = (*CurrExports->card_change_chv)(card_handle,entry.r[2],
              (char*)entry.r[3], entry.r[4],(char*)entry.r[5], entry.r[6]);
            ChimpanzeeClassByte = 0xa0;
            break;
          case UnBlockCHVSWI :
#ifdef debug
            printf("   unblock chv re-direction");
#endif
            state = UnBlockingCHV;
            ChimpanzeeClassByte = 0xf0;
  	    ret = (*CurrExports->card_unblock_chv)(card_handle,entry.r[2],
  	      (char*)entry.r[3], entry.r[4], (char*)entry.r[5], entry.r[6]);
            ChimpanzeeClassByte = 0xa0;
            break;
        }
        if (ret == SCI_FAIL)
        {
          err = SC_TRANSPORT;
          machine(Error,r);
        }
        break;
      }
      /*
       * otherwise
       */
      if (err == 0)
      {
        err = SC_TRANSPORT;
        ret = sctransport_error(card_handle);
      }

      status_error = err;
      sctransport_end_trans(card_handle);
      sctransport_close(card_handle);
#ifdef debug
      printf("error 0x%x state (%s) entry (%s) ret %d\n",
      	    err,strState[state],strTransitions[entry_trans],ret);
#endif
      module_notify(Event_Complete,err);
      state = WaitingOpen;
      machine(Done,r);
      break;

    case Removed :
      module_notify(Event_CardRemoved,0);
      sctransport_close(card_handle);
      card_handle = -1;
      state = WaitingOpen;
      machine(Done,r);
      break;

    case ReStart :
      module_notify(Event_CardRemoved,0);
      card_handle = -1;
      state = WaitingOpen;
      machine(Done,r);
      break;

    case TransEnd :
      switch (state)
      {
        case WaitingTrans :
          state = Idle;
          doing_retry = 1;
          machine(entry_trans,&entry);
          break;
      }
      break;
    case GetATRSWI :
#ifdef debug
      printf("(7) state = %d",state);
#endif
      switch (state)
      {
        case WaitingOpen : case WaitingATR :
      	  r->r[0] = SC_NOCARD;
      	  r->r[1] = 0;
      	  break;
      	default :
#ifdef debug
      	  printf("(7) returning atr, atr len = %d",ATR.len);
      	  if (ATR.len>0)
      	  {
      	    int i;
      	    for (i=0; i<ATR.len; i++)
      	      printf("(7)    ATR[%d] : 0x%x\n",i,ATR.hist[i]);
      	  }
#endif
      	  r->r[0] = SC_SUCCESS;
      	  r->r[1] = (int)&ATR;
      }
      break;
    case CreateSWI : case DeleteSWI : case ReadSWI :  case WriteSWI :
    case EnableCHVSWI : case UnBlockCHVSWI : case FileInfoSWI :
    case ChangeCHVSWI :
      switch (state)
      {
        case Idle :
#ifdef debug
	  printf("entered via %s",strTransitions[transition]);
#endif
          entry_trans = transition; /* remember transition for later */
          if (!doing_retry)
            err = path_process((char*)r->r[1],files,&num_files);
          else
            err = SC_SUCCESS;

          doing_retry = 0;
          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            state = SelectingDir;
            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
              current_file = 0;
              ret = (*CurrExports->card_select_root)(card_handle);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                /* card locked against transactions, back off */
                state = WaitingTrans;
              }
            }
          }
          break;
        case WaitingOpen : case WaitingATR :
      	  err = SC_NOCARD;
      	  break;
        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;
        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;

    case InternalAuthSWI :
      switch (state)
      {
        case Idle :
          entry_trans = transition; /* remember transition for later */
          doing_retry = 0;
          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            state = WaitingInternalAuth;
            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
      	      ret = (*CurrExports->card_internal_auth)(card_handle,
      	      entry.r[2], (BYTE*)entry.r[3], entry.r[4]);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                /* card locked against transactions, back off */
                state = WaitingTrans;
              }
            }
          }
          break;
        case WaitingOpen : case WaitingATR :
      	  err = SC_NOCARD;
      	  break;
        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;
        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;
    case StatusSWI :
      if (status_error!=0)
        r->r[0] = StatusError;
      else
      {
        switch (state)
        {
          case WaitingOpen : case WaitingATR :
            r->r[0] = StatusNoCard;
            break;
          case Idle :
            r->r[0] = StatusIdle;
            break;
          default :
            r->r[0] = StatusBusy;
        }
      }
      r->r[1] = status_error;
      status_error=0;
      break;
  }
}
#else
/******************************************************************************
  the state machine for Funai3 MiniJIS cards
 ******************************************************************************/
void machine(t_transitions transition, _kernel_swi_regs *r)
{
  static _kernel_swi_regs entry;
  static int files[MAX_SUBDIRS];
  static int num_files;
  static int current_file;
  static int err;
  static int offset;
  static int chunk_size;
  static int status_error = 0;
  static int doing_retry = 0;
  BYTE file_header[25];
  BYTE resp[2];
  int data_length;
  int ret = SCI_SUCCESS;
  int access_condition;

#ifdef debug
  if (transition!=StatusSWI)
    printf("SCINTERFACE: machine (%s)\n",strTransitions[transition]);
#endif

  switch (transition)
  {
    case Done:
      switch (state)
      {
        case WaitingOpen:
          err = open_card();
          switch (err)
          {
            case SC_SUCCESS:
              state = WaitingATR;
              break;
	    case SC_UNDERSTAND:
              state = WaitingRemoval;
              break;
          }
          break;

        case WaitingATR:
          if (get_atr() == SC_SUCCESS)
          {
            state = Idle;
            module_notify(Event_CardOK,0);
          }
          else
          {
            state = WaitingRemoval;
            module_notify(Event_CardBad,0);
          }
          break;

	case Idle:
	  /* i0ngore */
	  break;

	case SelectingDir:
#ifdef debug
          printf ( "SCINTERFACE: Selecting dir 2\n");
          printf ( "SCINTERFACE: r3: '%s'\n", (char*)entry.r[3]);
          printf ( "SCINTERFACE: r5: '%s'\n", (char*)entry.r[5]);
#endif
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    if (current_file == num_files-1)   /* are we on the leaf name */
	    {
	      switch (entry_trans)
	      {
	        case CreateSWI :
	          state = Creating;
		  ret = (*CurrExports->card_create)(card_handle,
		      	files[current_file++],(entry.r[0]&1<<1)?1:0,entry.r[2],
		      	entry.r[3]);
	          break;

	        case ReadSWI:
	        case WriteSWI:
	        case DeleteSWI:
	        case FileInfoSWI:
                case ChangeCHVSWI:
                case EnableCHVSWI:
                case UnBlockCHVSWI:
    	          state = SelectingFile;
                  ret = (*CurrExports->card_select)(card_handle,
                      	files[current_file++]);
                  break;
              }
	    }
	    else if (current_file == num_files) /* leaf name was a directory */
	    {
	      switch (entry_trans)
	      {
	        case ChangeCHVSWI:
	          state = ChangingCHV;
  		  ret = (*CurrExports->card_change_chv)(card_handle,
  		      	entry.r[2], (char*)entry.r[3], entry.r[4],
  		      	(char*)entry.r[5], entry.r[6]);
	          break;

                case EnableCHVSWI:
                  state = EnablingCHV;
		  ret = (*CurrExports->card_enable_chv)(card_handle,
		      	entry.r[2],(entry.r[0]&1<<1)?1:0,(char*)entry.r[3],
		      	entry.r[4]);
	          break;

                case UnBlockCHVSWI:
                  state = UnBlockingCHV;
   		  ret = (*CurrExports->card_unblock_chv)(card_handle,
   		      	entry.r[2], (char*)entry.r[3],
   		      	entry.r[4], (char*)entry.r[5], entry.r[6]);
                  break;

                case FileInfoSWI:
	    	  state = GettingResponse;
	    	  ret = (*CurrExports->card_get_response)(card_handle,
	    	      	(int)resp[1]);
                  if (ret == SCI_FAIL)
            	  {
		    err = SC_TRANSPORT;
              	    machine(Error,r);
                  }
                  break;
              }
            }
	    else /* change into next directory in path */
	    {
	      ret = (*CurrExports->card_select)(card_handle,
	      	    files[current_file++]);
	    }
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	  {
	    machine(Error,r);
	  }
	  break;

	case SelectingFile:
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * we have successfully selected the file, get header response
	     */
#ifdef debug
	    printf("SCINTERFACE: file selected\n");
#endif
	    state = GettingResponse;
	    ret = (*CurrExports->card_get_response)(card_handle,(int)resp[1]);
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case GettingResponse:
	  err=handle_response(file_header,sizeof(file_header),
	                      &data_length,resp);
#ifdef debug
	  printf("SCINTERFACE: got response, err = %d",err);
#endif
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * we have successfully get the response message, do something
	     */
	    switch (entry_trans)
	    {
              case DeleteSWI :
	        access_condition = file_header[9]>>4 & 0xf;
                if (access_condition==0) /* no write access cond */
                {
                  state = Deleting;
                  ret = (*CurrExports->card_delete)(card_handle,
                        files[num_files-1]);
                }
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
                else /* access condition to deal with */
                {
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
                }
                break;

	      case ReadSWI :
	        access_condition = file_header[8]>>4 & 0xf;
                if (access_condition==0) /* no read access cond */
                {
                  state = ReadingFile;
                  offset = 0;
                  chunk_size = CurrExports->chunk_size;
                  if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

                  ret = (*CurrExports->card_read)(card_handle,entry.r[2],
              	      	chunk_size);
                }
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
                else  /* access condition to deal with */
                {
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
                }
                break;

	      case WriteSWI:
	        access_condition = file_header[8] & 0xf;
                if (access_condition==0) /* no write access cond */
                {
       	          state = WritingFile;
                  offset = entry.r[2];
                  chunk_size = CurrExports->chunk_size;
                  if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

                  ret = (*CurrExports->card_write)(card_handle, offset,
        	        (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
        	}
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
        	else /* access condition to deal with */
        	{
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
        	}
	        break;

	      case FileInfoSWI :
#ifdef debug
	        printf("SCINTERFACE: FileInfoSWI");
#endif
	      	if (entry.r[0] & 1<<1) /* bit 1 populate structure */
	      	{
	      	  t_sc_stat *stat_ptr = (t_sc_stat*)entry.r[2];

                  stat_ptr->num_files = -1;
                  stat_ptr->num_dirs  = -1;
                  stat_ptr->chv1_attempts = -1;
                  stat_ptr->unblock_chv1_attempts = -1;
	      	  stat_ptr->file = 1;        /* default to file */

	      	  if (ATR.hist[0] == 7) /* schlumberger */
	      	  {
#ifdef debug
	      	    printf("(7)   schlumberger (0x%x)",file_header[6]);
#endif
      	            stat_ptr->size = file_header[2]<<8 | file_header[3];
		    if (file_header[6] == 0x38 || file_header[6] == 0x02)
		    {
	      	      stat_ptr->file = 0;        /* directory */
	      	      stat_ptr->chv1_enabled         = (file_header[18]==0)?0:1;
	      	      stat_ptr->unblock_chv1_enabled = (file_header[19]==0)?0:1;
      	              stat_ptr->num_dirs  	     = file_header[14];
      	              stat_ptr->num_files 	     = file_header[15];
  		      stat_ptr->chv1_attempts	     = file_header[18];
  		      stat_ptr->unblock_chv1_attempts= file_header[19];
		    }
	      	  }
	      	  else
	      	  {
#ifdef debug
	      	    printf("(7)   other card (0x%x)",file_header[6]);
#endif
      	            stat_ptr->size = file_header[2]<<8 | file_header[3];
	      	    if (file_header[6] != 0x04) /* not file */
	      	    {
	      	      stat_ptr->file = 0;        /* directory */
	      	      stat_ptr->chv1_enabled         = file_header[18]>>7;
	      	      stat_ptr->unblock_chv1_enabled = file_header[19]>>7;
      	              stat_ptr->num_dirs  	     = file_header[14];
      	              stat_ptr->num_files 	     = file_header[15];
  		      stat_ptr->chv1_attempts	     = file_header[18] & 0xf;
  		      stat_ptr->unblock_chv1_attempts= file_header[19] & 0xf;
	      	    }
	      	  }
	      	}
	      	else
	      	{
#ifdef debug
                  printf ( "SCINTERFACE: Starting r3 copy\n");
#endif
  	          if (entry.r[3]>sizeof(file_header))
  	            memcpy((char*)entry.r[2],file_header,sizeof(file_header));
  	          else
  	            memcpy((char*)entry.r[2],file_header,entry.r[3]);
                }
                sctransport_end_trans(card_handle);
	    	state = Idle;
	    	module_notify(Event_Complete,SC_SUCCESS);
	        break;
	    }

            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case GettingAuthResponse :
          err=handle_response((BYTE*)entry.r[5],entry.r[6],&data_length,resp);
	  if (err==SC_SUCCESS)
   	  {
            sctransport_end_trans(card_handle);
	    state = Idle;
            module_notify(Event_Complete,SC_SUCCESS);
	  }
	  else
	    machine(Error,r);
	  break;

	case VerifyingCHV :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS || (resp[0]==0x98 && resp[1]==0x08))
	  {
#ifdef debug
	    printf("SCINTERFACE: verified CHV\n");
#endif
	    /*
	     * we have successfully verified the CHV, do something
	     */
	    switch (entry_trans)
	    {
              case DeleteSWI :
                state = Deleting;
                ret = (*CurrExports->card_delete)(card_handle,
                      files[num_files-1]);
                break;

              /* modified for minijis */
              case FileInfoSWI:
              {
                int *pinc;
                pinc =(int *)entry.r[0];
#ifdef debug
                printf ( "SCINTERFACE: End of FileInfo SWI\n");
                printf ( "SCINTERFACE: SW1:%x  SW2:%x\n", resp[0],resp[1]);
#endif
                switch ( resp [ 1] & 0xff)
                {
                  case 0:
#ifdef debug
                    printf ( "SCINTERFACE: Unlimited attempts left (-1)\n");
#endif
                    *pinc =-1;
                    break;

                  case 0xc0:
#ifdef debug
                    printf ( "SCINTERFACE: CHV Blocked (0)\n");
#endif
                    *pinc =0;
                    break;

                  default:
#ifdef debug
                    printf ( "SCINTERFACE: Attempts left: %d\n", ( resp[1] &0xf));
#endif
                    *pinc =( resp[1] &0xf);
                  break;
                }
                sctransport_end_trans(card_handle);
	    	state = Idle;
	    	module_notify(Event_Complete,SC_SUCCESS);
              }
              break;

	      case ReadSWI:
	        if (resp[0]==0x63 && resp[1]==0x00) /* invalid pin */
	        {
#ifdef debug
                  printf ( "SCINTERFACE: bad pin\n");
#endif
                  sctransport_end_trans(card_handle);
                  state = Idle;
	    	  module_notify(Event_Complete,SC_FAILACCESSCODE);
	        }
	        else
	        {
                  minijis_current =1;  /* current record being read */
                  minijis_records =0;  /* number of records on card */

                  state = ReadingFile;
                  offset = 0;
                  chunk_size = CurrExports->chunk_size;
                  /*if (chunk_size>entry.r[4])
                    chunk_size = entry.r[4];*/
                  ret = (*CurrExports->card_read)(card_handle,minijis_current,
	                chunk_size);
#ifdef debug
                printf ( "SCINTERFACE: 0:issued read for record: %d\n",
                         minijis_current);
#endif
	        }
	        break;

	      case WriteSWI:
	        if (resp[0]==0x63 && resp[1]==0x00) /* invalid pin */
	        {
#ifdef debug
                  printf ( "SCINTERFACE: bad pin\n");
#endif
                  sctransport_end_trans(card_handle);
                  state = Idle;
	    	  module_notify(Event_Complete,SC_FAILACCESSCODE);
	        }
	        else
	        {
                  minijis_offset   =0;  /* offset into user buffer */
                  minijis_currentw =1;  /* current record being written */
                  memfill ( minijis_buff, 1024, FILL_CHAR);
                  buff_to_records ((char*)entry.r[3], entry.r[4],
                     minijis_buff, minijis_records*27, minijis_records);
                  /*
                  printf ( "SCINTERFACE: Before reorder:\n");
                  print_buff ( minijis_buff, 7);
                  reorder_buff ( minijis_buff, 27, 7);
                  printf ( "SCINTERFACE: After reorder:\n");
                  print_buff ( minijis_buff, 7); */

                  state = WritingFile;
                  offset = 0;
                  chunk_size = CurrExports->chunk_size;
                  ret = (*CurrExports->card_write)(card_handle, offset,
	                (BYTE*)(minijis_buff+offset), chunk_size);
	        }
	        break;

              case ChangeCHVSWI:
	        if (resp[0]==0x63 && resp[1]==0x00) /* invalid pin */
	        {
#ifdef debug
                  printf ( "SCINTERFACE: bad pin\n");
#endif
                  sctransport_end_trans(card_handle);
                  state = Idle;
	    	  module_notify(Event_Complete,SC_FAILACCESSCODE);
	        }
	        else
	        {
                  state = ChangingCHV;
                  ret = (*CurrExports->card_change_chv)(card_handle,
                         entry.r[2], (char*)entry.r[3], entry.r[4],
                         (char*)entry.r[5], entry.r[6]);
	        }
                break;

	    }
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case Creating:
	case Deleting:
	case ChangingCHV:
	case EnablingCHV:
	case UnBlockingCHV:
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
            sctransport_end_trans(card_handle);
	    state = Idle;
	    module_notify(Event_Complete,SC_SUCCESS);
	  }
	  else
	    machine(Error,r);
	  break;

	case ReadingFile:
#ifdef debug
	  printf ( "SCINTERFACE: ReadingFile\n");
	  printf ( "SCINTERFACE: finished reading record: %d\n", minijis_current);
#endif
	  //err=handle_response((BYTE*)(entry.r[3]+offset),chunk_size,
	  //   &data_length,resp);
	  err=handle_response((BYTE*)(minijis_buff+offset),chunk_size,
	     &data_length,resp);
#ifdef debug
	  printf ( "SCINTERFACE: handle response - data length: %d\n", data_length);
	  printf ( "SCINTERFACE: handle response result: %d\n", err);
          print_rec ( minijis_buff+offset);
#endif
	  if (( err ==SC_SUCCESS) || ( err ==SC_NOTFOUND))
	  {
	    offset+=chunk_size;
            /* have we finished reading yet */
	    //if ((offset>=entry.r[4]) || ( minijis_current>=7))
	    if ( minijis_current>30 || ( resp[0] ==0x6a && resp[1] ==0x83))
	    {
#ifdef debug
	      printf ( "SCINTERFACE: 0:Total records read: %d\n", minijis_records);
              printf ( "SCINTERFACE: Before reorder:\n");
              print_buff ( minijis_buff, minijis_records);
#endif
              reorder_buff ( minijis_buff, 27, minijis_records);
#ifdef debug
              printf ( "SCINTERFACE: After reorder:\n");
              print_buff ( minijis_buff, minijis_records);
#endif
              records_to_buff (( char*)entry.r[3], minijis_buff,
                               minijis_records);
              sctransport_end_trans(card_handle);
	      state = Idle;
	      module_notify(Event_Complete,SC_SUCCESS);
#ifdef debug
	      printf ( "SCINTERFACE: 1:Total records read: %d\n", minijis_records);
#endif
	    }
	    else
	    {
              minijis_current+=1;
              minijis_records+=1;
	      chunk_size = CurrExports->chunk_size;
	      //if (entry.r[4]-offset<chunk_size) chunk_size = entry.r[4]-offset;
                ret = (*CurrExports->card_read)(card_handle,minijis_current,
	      	       chunk_size);
#ifdef debug
              printf ( "SCINTERFACE: 1:issued read for record: %d\n",
                       minijis_current);
#endif
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
	    }
  	  }
  	  else
          {
            records_to_buff (( char*)entry.r[3], minijis_buff, 7);
  	    machine(Error,r);
          }
	  break;

	case WritingFile:
          err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /* have we finished writing yet */
	    //if (minijis_currentw >=minijis_records)
#ifdef debug
	      printf ( "SCINTERFACE: total number of records: %d\n",
	               minijis_records);
	      printf ( "SCINTERFACE: finished writing: %d\n",
	               minijis_currentw);
#endif
	    if (minijis_currentw >=minijis_records)
	    {
              sctransport_end_trans(card_handle);
	      state = Idle;
	      module_notify(Event_Complete,SC_SUCCESS);
	    }
	    else
	    {
	      minijis_currentw +=1;
              chunk_size = CurrExports->chunk_size;
#ifdef debug
	      printf ( "SCINTERFACE: chunk_size: %d\n", chunk_size);
#endif
              offset+=chunk_size;
#ifdef debug
	      printf ( "SCINTERFACE: write offset: %d\n", offset);
#endif
              ret = (*CurrExports->card_write)(card_handle, offset,
                     (BYTE*)(minijis_buff+offset),chunk_size);
#ifdef debug
              printf ( "SCINTERFACE: Writing record: %d\n\n", minijis_currentw);
#endif
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
	      }
	    }
	  }
	  else
	    machine(Error,r);
	  break;

	case WaitingInternalAuth :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * authentication complete, now need to fetch the stuff
	     */
 	    state = GettingAuthResponse;
	    ret = (*CurrExports->card_get_response)(card_handle,(int)resp[1]);
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;
        default :
#ifdef debug
          printf("SCINTERFACE: Ilegal state (%s) in Done\n",strState[state]);
#endif
	  state = Idle;
          break;
      }
      break;
    /*
     * end of Done
     */
    case Error :
      /*
       * special chimpanzee error handling
       */
      if ((err==SC_WRONGCLASS) && (ATR.hist[0]==0x7))
      {
#ifdef debug
        printf("SCINTERFACE: Chimpanzee processing !!!!");
#endif
        switch (entry_trans)
        {
          case ChangeCHVSWI :
#ifdef debug
            printf("SCINTERFACE: change chv re-direction");
#endif
            state = ChangingCHV;
            ChimpanzeeClassByte = 0xf0;
            ret = (*CurrExports->card_change_chv)(card_handle,entry.r[2],
              (char*)entry.r[3], entry.r[4],(char*)entry.r[5], entry.r[6]);
            ChimpanzeeClassByte = 0xa0;
            break;
          case UnBlockCHVSWI :
#ifdef debug
            printf("SCINTERFACE: unblock chv re-direction");
#endif
            state = UnBlockingCHV;
            ChimpanzeeClassByte = 0xf0;
  	    ret = (*CurrExports->card_unblock_chv)(card_handle,entry.r[2],
  	      (char*)entry.r[3], entry.r[4], (char*)entry.r[5], entry.r[6]);
            ChimpanzeeClassByte = 0xa0;
            break;
        }
        if (ret == SCI_FAIL)
        {
          err = SC_TRANSPORT;
          machine(Error,r);
        }
        break;
      }
      /*
       * otherwise
       */
      if (err == 0)
      {
        err = SC_TRANSPORT;
        ret = sctransport_error(card_handle);
      }

      status_error = err;
      sctransport_end_trans(card_handle);
      sctransport_close(card_handle);
#ifdef debug
      printf("SCINTERFACE: error 0x%x state (%s) entry (%s) ret %d\n",
      	    err,strState[state],strTransitions[entry_trans],ret);
#endif

      module_notify(Event_Complete,err);
      state = WaitingOpen;
      machine(Done,r);
      break;

    case Removed:
      module_notify(Event_CardRemoved,0);
      sctransport_close(card_handle);
      card_handle = -1;
      state = WaitingOpen;
      minijis_current  =0;   /* current record being read */
      minijis_currentw =0;   /* current record being written */
      minijis_records  =0;   /* number of records on card */
      minijis_offset   =0;   /* offset into card buffer */
      machine(Done,r);
      break;

    case ReStart:
      module_notify(Event_CardRemoved,0);
      card_handle = -1;
      state = WaitingOpen;
      machine(Done,r);
      break;

    case TransEnd :
      switch (state)
      {
        case WaitingTrans :
          state = Idle;
          doing_retry = 1;
          machine(entry_trans,&entry);
          break;
      }
      break;
    case GetATRSWI :
#ifdef debug
      printf("SCINTERFACE: state = %d",state);
#endif
      switch (state)
      {
        case WaitingOpen : case WaitingATR :
      	  r->r[0] = SC_NOCARD;
      	  r->r[1] = 0;
      	  break;
      	default :
#ifdef debug
      	  printf("SCINTERFACE: returning atr, atr len = %d",ATR.len);
      	  if (ATR.len>0)
      	  {
      	    int i;
      	    for (i=0; i<ATR.len; i++)
      	      printf("(7)    ATR[%d] : 0x%x\n",i,ATR.hist[i]);
      	  }
#endif
      	  r->r[0] = SC_SUCCESS;
      	  r->r[1] = (int)&ATR;
      }
      break;

    /* first entry point for these swis */
    case ReadSWI:
    case WriteSWI:
    case ChangeCHVSWI:
    case FileInfoSWI:
      switch (state)
      {
        case Idle:
#ifdef debug
	  printf("SCINTERFACE: 0:entered via %s\n",strTransitions[transition]);
#endif
          entry_trans = transition; /* remember transition for later */
          err = SC_SUCCESS;
          doing_retry = 0;

          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
#ifdef debug
            printf("SCINTERFACE: Verifying CHV\n");
#endif
            state = VerifyingCHV;
            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
              current_file = 0;
              switch ( transition)
              {
                case FileInfoSWI:
                  ret = (*CurrExports->card_verify_chv)(card_handle, 0,NULL,0);
                  break;

                case ChangeCHVSWI:
                  ret = (*CurrExports->card_verify_chv)(card_handle,
                          access_condition,(char*)entry.r[3],entry.r[4]);
                  break;

                default:
                  ret = (*CurrExports->card_verify_chv)(card_handle,
                          access_condition,(char*)entry.r[5],entry.r[6]);
                  //ret = (*CurrExports->card_verify_chv)(card_handle,
                  //        access_condition,(char*)"00000000",8);
                  break;
              }
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                 /* card locked against transactions, back off */
                  state = WaitingTrans;
              }
            }
          }
          break;

        case WaitingOpen : case WaitingATR :
      	  err = SC_NOCARD;
      	  break;

        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;

        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;

    /* first entry point for these swis */
    case CreateSWI:
    case DeleteSWI:
    case EnableCHVSWI:
    case UnBlockCHVSWI:
      switch (state)
      {
        case Idle:
#ifdef debug
	  printf("SCINTERFACE: 1:entered via %s\n",strTransitions[transition]);
#endif
          entry_trans = transition; /* remember transition for later */
          if (!doing_retry)
          {
            err = path_process((char*)r->r[1],files,&num_files);
#ifdef debug
	    printf("SCINTERFACE: path process result: %d\n", err);
#endif
          }
          else
            err = SC_SUCCESS;

          doing_retry = 0;
          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            if ( transition ==ChangeCHVSWI && current_card_type ==3)
            {
#ifdef debug
              printf("SCINTERFACE: Verifying CHV\n");
#endif
              state = VerifyingCHV;
            }
            else
              state = SelectingDir;

            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
              current_file = 0;
              if ( transition ==ChangeCHVSWI && current_card_type ==3)
                ret = (*CurrExports->card_verify_chv)(card_handle,
                       access_condition,(char*)entry.r[3],entry.r[4]);
              else
                ret = (*CurrExports->card_select_root)(card_handle);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                 /* card locked against transactions, back off */
                  state = WaitingTrans;
              }
            }
          }
          break;

        case WaitingOpen : case WaitingATR :
      	  err = SC_NOCARD;
      	  break;

        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;

        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;

    case InternalAuthSWI :
      switch (state)
      {
        case Idle :
          entry_trans = transition; /* remember transition for later */
          doing_retry = 0;
          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            state = WaitingInternalAuth;
            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
      	      ret = (*CurrExports->card_internal_auth)(card_handle,
      	      entry.r[2], (BYTE*)entry.r[3], entry.r[4]);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                /* card locked against transactions, back off */
                state = WaitingTrans;
              }
            }
          }
          break;
        case WaitingOpen : case WaitingATR :
      	  err = SC_NOCARD;
      	  break;
        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;
        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;
    case StatusSWI :
      if (status_error!=0)
        r->r[0] = StatusError;
      else
      {
        switch (state)
        {
          case WaitingOpen : case WaitingATR :
            r->r[0] = StatusNoCard;
            break;
          case Idle :
            r->r[0] = StatusIdle;
            break;
          default :
            r->r[0] = StatusBusy;
        }
      }
      r->r[1] = status_error;
      status_error=0;
      break;
  }
}
#endif
@


1.1.2.2
log
@ Started implementing support for monitoring going in and out of
> Standby mode. New state WaitingStandby and two new transitions
> Shutdown and Standby added to state machine. Plus added appropriate
> bits to the service call handler.
> Also tidied up a few error messages and included VersionNum file in
> cmhg header.

Version 0.17, 1.1.2.5. Tagged as 'SCInter-0_17-1_1_2_5'
@
text
@a803 1
        case WaitingStandby:
a1470 22
    /* shut scinterface down for now */
    case Shutdown:
      module_notify(Event_CardRemoved,0);
      sctransport_close(card_handle);
      card_handle = -1;
      state = WaitingStandby;
      minijis_current  =0;   /* current record being read */
      minijis_currentw =0;   /* current record being written */
      minijis_records  =0;   /* number of records on card */
      minijis_offset   =0;   /* offset into card buffer */
      machine(Done,r);
      break;

    /* wake scinterface up after shutdown */
    case Standby:
      if (state == WaitingStandby)
      {
	  state = WaitingOpen;
	  machine(Done,r);
      }
      break;

d1487 1
a1487 1
        case WaitingOpen : case WaitingATR : case WaitingStandby :
d1568 1
a1568 1
        case WaitingOpen : case WaitingATR : case WaitingStandby :
d1646 1
a1646 1
        case WaitingOpen : case WaitingATR : case WaitingStandby :
d1693 1
a1693 1
        case WaitingOpen : case WaitingATR : case WaitingStandby :
d1712 1
a1712 1
          case WaitingOpen : case WaitingATR : case WaitingStandby :
@

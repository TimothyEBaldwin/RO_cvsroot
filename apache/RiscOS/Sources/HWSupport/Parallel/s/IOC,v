head	4.7;
access;
symbols
	Parallel-0_79:4.7
	Parallel-0_78:4.7
	Parallel-0_77:4.7
	Parallel-0_76:4.7
	Parallel-0_75:4.6
	Parallel-0_74:4.6
	Parallel-0_73:4.5
	Parallel-0_72:4.5
	Parallel-0_71:4.5
	Parallel-0_70:4.5
	Parallel-0_69:4.5
	Parallel-0_68:4.5
	Parallel-0_67:4.5
	Parallel-0_66:4.5
	Parallel-0_65:4.4
	kbracey_32bit_merge:4.3.8.4
	Parallel-0_64:4.4
	Parallel-0_60-4_13_2_5:4.3.8.4
	Parallel-0_60-4_13_2_4:4.3.8.4
	Parallel-0_60-4_13_2_3:4.3.8.3
	Parallel-0_63:4.3
	Parallel-0_60-4_13_2_2:4.3.8.2
	Alpnet_approved:4.3
	Parallel-0_62:4.3
	dellis_autobuild_BaseSW:4.3
	Parallel-0_61:4.3
	Parallel-0_60-4_13_2_1:4.3.8.1
	kbracey_32bit:4.3.0.8
	sbrodie_sedwards_16Mar2000:4.3
	Parallel-0_60:4.3
	Parallel-0_59:4.3
	dcotton_autobuild_BaseSW:4.5
	Parallel-0_58:4.3
	Parallel-0_57:4.3
	Parallel-0_56:4.3
	Parallel-0_55:4.3
	Parallel-0_54:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3
	Ursula_RiscPC:4.3.0.6
	Parallel-0_53:4.3
	Parallel-0_52:4.3
	Parallel-0_51:4.3
	FunaiNC2_Parallel-0_50:4.1.7.3
	rthornb_UrsulaBuild-19Aug1998:4.3
	UrsulaBuild_FinalSoftload:4.3
	wturner_parallel-0_47:4.3
	wturner_parallel-0_46:4.3
	rthornb_UrsulaBuild-12Aug1998:4.3
	aglover_UrsulaBuild-05Aug1998:4.3
	rthornb_UrsulaBuild-29Jul1998:4.3
	rthornb_UrsulaBuild-22Jul1998:4.3
	rthornb_UrsulaBuild-15Jul1998:4.3
	rthornb_UrsulaBuild-07Jul1998:4.3
	rthornb_UrsulaBuild-17Jun1998:4.3
	rthornb_UrsulaBuild-03Jun1998:4.3
	rthornb_UrsulaBuild-27May1998:4.3
	rthornb_UrsulaBuild-21May1998:4.3
	rthornb_UrsulaBuild_01May1998:4.3
	afrost_NC2_Generic:4.1.7.3
	afrost_Funai01-33:4.1.7.3
	Spinner_RCA116:4.1.7.3
	Spinner_B20_2:4.1.7.3
	Spinner_19_3:4.1.7.3
	Spinner_B18:4.1.7.3
	Spinner_B17:4.1.7.3
	Spinner_B15:4.1.7.3
	Spinner_B14:4.1.7.3
	Spinner_B13:4.1.7.3
	Spinner_B12:4.1.7.3
	Spinner_B10:4.1.7.3
	Daytona:4.3.0.4
	Ursula:4.3.0.2
	Spin_merge_16May97:4.1.7.2
	Daytona_bp:4.3
	Ursula_bp:4.3
	Spin_merge_7May97:4.1.7.1
	ARTtmp_bp:4.1.7.2
	Spinner_B7:4.1.7.3
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.1
	ARTtmp:4.1.7.2.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.3
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.7
date	2012.06.23.16.24.15;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	NqgW20IuiIZMLQ9w;

4.6
date	2011.06.22.00.52.49;	author jlee;	state Exp;
branches;
next	4.5;
commitid	G7LnLvkSoQ9EpBov;

4.5
date	2001.03.16.15.59.13;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	2001.01.09.14.10.03;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	97.05.16.11.14.55;	author kbracey;	state Exp;
branches
	4.3.8.1;
next	4.2;

4.2
date	97.05.07.12.02.42;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.36.27;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.8.1
date	2000.07.23.20.43.04;	author sbrodie;	state Exp;
branches;
next	4.3.8.2;

4.3.8.2
date	2000.10.24.13.55.46;	author sbrodie;	state Exp;
branches;
next	4.3.8.3;

4.3.8.3
date	2000.11.22.11.58.32;	author sbrodie;	state Exp;
branches;
next	4.3.8.4;

4.3.8.4
date	2000.11.29.12.41.40;	author sbrodie;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.36.27;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.30.24;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.54.53;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.49.34;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.20.13.33.29;	author scormie;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.30.18.18.59;	author scormie;	state Exp;
branches;
next	;


desc
@@


4.7
log
@Fix stack imbalance in ioeb_busy and have a spring clean
Now uses OS_Memory throughout to determine controller addresses rather than calling the private HAL_ControllerAddress API.
Be devious in all the register pokes by making HardwareBase be roughly half way between the two sets of standard parallel registers and ECP mode ones, so they're always in range for an immediate offset of LDRB/STRB so the code doesn't thrash the literal pool so much.
Where possible, eliminate HAL conditional code by initialising HardwareBase in the non HAL case thus simplifying code paths a bit.
Be a bit less ugly in the 0.5us delays, since the combo chip is using Type B cycles a dummy read of a SuperIO chip will waste 0.5us rather than needing to back calculate the IOEB registers.
Expand tabs, use OSBytes header file.

Version 0.76. Tagged as 'Parallel-0_76'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > IOC

 [ HAL
        ! 1, "Sorry - no HAL support here!"
 ]
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: IOCdevice
;
; in:   r0  = reason code
;       r8  = private word
;       wp -> workspace
;
; out:  V clear, registers setup correctly
;       V set, r0 -> error block
;
; This entry point is provided to allow the IOC device to do what it needs to
; do, this is called by DeviceFS to pass events and control operations to the
; device driver.
;

IOCdevice       ROUT

                Push    lr
                SavePSR lr
                BIC     lr, lr, #V_bit+ C_bit                   ; just ensure that all is OK
                Push    lr
                JumpAddress lr, device_call_exit, forward       ; load return address

                CMP     r0, #(%10-%00)/4
                ADDCC   pc, pc, r0, LSL #2                      ; despatch the event
                B       %10                                     ; if not valid then give an error
00
                B       ioc_open                                ; open a stream
                B       ioc_close                               ; close the stream
                B       ioc_wakeup                              ; wake up because someone's transferring
                MOV     pc, lr
                MOV     pc, lr
                MOV     pc, lr
                B       common_createTX
                MOV     pc, lr
                MOV     pc, lr
                MOV     pc, lr
                MOV     pc, lr
                B       ioc_created                             ; stream created
10
                ADRL    r0, ErrorBlock_Parallel_BadCall         ; if not within valid range
              [ international
                BL      MakeError
              |
                CMP     r0, #&80000000                          ; set V
                CMNVC   r0, #&80000000
              ]
ioc_device_call_exit
                Pull    lr
                ORRVS   lr, lr, #V_bit
                ORRCS   lr, lr, #C_bit
                RestPSR lr,,f
                Pull    pc

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioc_open
;
; in:   r0  = reason code
;       r2  = external handle (used for calling DeviceFS)
;       r3  = flags for opening the file
;       r6 -> special field that has been decoded
;
; out:  r1  = internal handle (used in communication from DeviceFS)
;
; This call is made to allow the parallel device driver to initialise itself, ie.
; claiming any vectors it may need.
;

ioc_open        Entry   "r0,r1"
                Debug   open,"ioc_open"
 [ StorkPower
                BL      SetPower_On             ;Should be powered down, so power up
 ]
                MOV     r0, #PrinterAck_DevNo
                ADR     r1, ioc_irq
                BL      common_open
 [ StorkPower
                BLVS    SetPower_Off            ;If openning failed, try powering down. If failure occurred
                                                ;because port was in use, the service call will be faulted
                                                ;and the port will remain powered (as it should be).
 ]
                EXIT



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioc_close
;
; in:   r0  = reason code
;       r2  = internal handle
;
; out:  -
;
; This call is made to allow the device to close down the routines associated
; with printing characters.
;

ioc_close       Entry   "r0-r2"
                Debug   close,"ioc_close"
                MOV     r0, #PrinterAck_DevNo
                ADR     r1, ioc_irq
                ADR     r2, ioc_busy_check_callafter
                BL      common_close
 [ StorkPower
                BL      SetPower_Off            ;Will be powered up, so power down
 ]
                EXIT



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioc_wakeup
;
; in:   r0  = reason code
;       r2  = internal handle
;
; out:  r0 = 0 if staying dormant, otherwise preserved
;
; This call is made when the device driver should wake itself up because there is
; data in the buffer to be sent.
;

ioc_wakeup      EntryS  "r0-r3"

                Debug   out,"ioc_wakeup"

                SETPSR  I_bit,lr
                MOV     r3, #IOC
                BL      ioc_busy                ; returns EQ if not busy
                BLEQ    ioc_strobe              ; if not busy, strobe char
                EXITS   EQ,cf

                MOV     r0, #0                  ; indicate we wish to remain dormant
                STR     r0, [sp, #Proc_RegOffset]
                LDRB    r3, IRQFlags
                TST     r3, #if_PendingCallAfter ; if we've already asked for a callafter
                EXITS   NE,cf                    ; then exit

                LDR     r0, =BusyCheckInterval
                ADR     r1, ioc_busy_check_callafter
                MOV     r2, wp
                SWI     XOS_CallAfter
                ORRVC   r3, r3, #if_PendingCallAfter
                STRVCB  r3, IRQFlags

                EXITS   ,cf

                ; Entered in IRQ mode with IRQs disabled
ioc_busy_check_callafter Entry "r0"
                ASSERT  (SVC_mode :EOR: IRQ_mode) = (SVC32_mode :EOR: IRQ32_mode)
                TOGPSR  (SVC_mode :EOR: IRQ_mode),lr,,r0
                NOP
                Push    "r0, lr"                        ; save old flags, r14_svc
                LDRB    r0, IRQFlags
                BIC     r0, r0, #if_PendingCallAfter    ; indicate no pending callafter any more
                STRB    r0, IRQFlags
                BL      ioc_wakeup                      ; and call wakeup routine
                Pull    "r0, lr"
                RestPSR r0,,cf                          ; restore old mode
                NOP
                EXIT                                    ; and exit

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioc_created
;
; in:   r0 = reason code (11)
;       r2 = internal handle
;       r3 = buffer handle
;
; out:  -
;
; This routine is called when an input or output stream has been created.
;

ioc_created     EntryS  "r0-r2"

                Debug   open,"ioc_created, buffer handle =",r3

                STR     r3, BufferHandle        ; store buffer handle, so we know which
                                                ; buffer to make dormant if busy is active after ack
 [ FastBufferMan
                MOV     r0, r3
                SWI     XBuffer_InternalInfo
                STRVS   r0, [sp, #Proc_RegOffset]
                EXIT    VS
                STR     r0, BufferId
                STR     r1, BuffManService
                STR     r2, BuffManWkSpace
 ]
                EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioc_busy
;
; in:   r3 -> IOC
;
; out:  Z =0 => port is busy
;       Z =1 => port is idle
;
; This code simply returns the state of the A1 printer port, if it
; is busy.  When busy the device should not be restrobed as this will
; scrap the current character.
;
; In the routine will simply read the IOC masks to see what is should do.
;

ioc_busy        Entry   "r0,r1"
                LDR     lr, [r3, #IOCIRQSTAA]
                AND     r0, lr, #pbusy_bit                      ; 0 => busy
                EORS    r0, r0, #pbusy_bit                      ; set Z for exit

                EXIT    EQ

                Debug   out,"busy"

                SETPSR  F_bit,lr,,r1                            ; disable FIQs round updates

                LDRB    r0, [r3, #IOCIRQMSKA]
                ORR     r0, r0, #pack_bit                       ; is busy, so enable pack IRQ
                STRB    r0, [r3, #IOCIRQMSKA]

                RestPSR r1,,c
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ioc_irq
;
; in:   wp -> workspace
;       r3 -> IOC
;
; out:  r0-r3, wp may be corrupted
;
; This code handles IRQ from the printer device, the process is as follows:
;
; a) Clear IRQ within IOC;
; b) Wait for PACK to go high again;
; c) Extract a character by calling CallAVector;
; d) Enable/Disable printer IRQ within IOC space (with FIQs disabled);
; e) If character (C=0 on return from vector) then strobe character;
; f) Return.
;

ioc_irq         ROUT

; The acknowledge interrupt is triggered on the falling (leading) edge of PACK, and some printers'
; manuals indicate that the printer is only ready when the pulse is completed (ie when PACK has gone high again).
; So now we should wait for PACK to go high
                LDR     r0, LoopFactor                          ; Get CPU speed rating
                MOV     r2, r0, LSR #2                          ; loop until PACK is high
                                                                ; loop set from loop factor / 4

10
                LDRB    r0, [r3, #IOCControl]                   ; loop until the state of PACK is high
                TST     r0, #pack_state_bit
                BNE     %FT15
                SUBS    r2, r2, #1
                BNE     %BT10

                MOV     r0, #pack_bit                           ; PACK not gone high (probably printer off)
                STRB    r0, [r3, #IOCIRQCLRA]                   ; so clear interrupt and wait for printer on
                MOV     pc, lr

15
 [ CheckBusyAfterAck
                LDR     r0, LoopFactor                          ; Get CPU speed rating
                MOV     R2, R0, LSR #2                          ; Scale rating to our needs
20
                LDRB    r0, [r3, #IOCIRQSTAA]
                TST     r0, #pbusy_bit                          ; 0 => busy
                BNE     ioc_strobe                              ; not busy, so carry on
                SUBS    r2, r2, #1
                BNE     %BT20

                MOV     r0, #pack_bit                           ; clear interrupt anyway
                STRB    r0, [r3, #IOCIRQCLRA]

                LDRB    r2, IRQFlags                            ; if we already have a pending callafter
                TST     r2, #if_PendingCallAfter
                MOVNE   pc, lr                                  ; then exit

                SavePSR r3
                BIC     r3, r3, #2_01100
                ORR     r3, r3, #SVC_mode
                RestPSR r3,,c
                NOP

                Push    "r2, lr"
                LDR     r0, =BusyCheckInterval
                ADR     r1, ioc_busy_check_callafter
                MOV     r2, wp
                SWI     XOS_CallAfter
                Pull    "r2, lr"
                ORRVC   r2, r2, #if_PendingCallAfter
                STRVCB  r2, IRQFlags

                RestPSR r3                                      ; restore IRQ mode
                NOP
                MOV     pc, lr                                  ; and exit

 ]

; and drop thru to...

; in: r3 -> IOC
;     SVC_mode or IRQ_mode
;     IRQs disabled (this is needed (a) because may enable pack IRQ (b) mustn't have F=1 and I=0
;
; out: r0-r2 corrupted
;

ioc_strobe      Entry
                MOV     r0, #pack_bit                           ; clear interrupt - note this is done inside the strobe
                STRB    r0, [r3, #IOCIRQCLRA]                   ; routine in order to clear any fake acknowledges
                                                                ; generated on printer power-on

                Debug   out,"sending byte"

 [ FastBufferMan
                MOV     r0, #BufferReason_RemoveByte
                LDR     r1, BufferId
                CallBuffMan
 |
                SavePSR r2
                BIC     r2, r2, #C_bit + V_bit                  ; clear C&V for entering mode
                BIC     lr, r2, #2_01100
                ORR     lr, lr, #SVC_mode                       ; derive SVC mode (NB if entered in SVC mode, then
                                                                ; we've already saved lr_svc, so we can junk it now)
                RestPSR lr                                      ; change to SVC mode with C and V clear
                NOP

                Push    "lr"
                LDR     r1, StreamHandle
                SWI     XDeviceFS_TransmitCharacter             ; attempt to get byte to send
                Pull    "lr"                                    ; preserve link register

                ORRCS   r2, r2, #C_bit                          ; ensure C flag reflected correctly
                RestPSR r2
                NOP                                             ; back to original mode (IRQ or SVC)
 ]

                SETPSR  F_bit,lr,,tmp                           ; disable FIQs
                Push    tmp

                LDRB    tmp, [r3, #IOCIRQMSKA]                  ; get IRQ mask A
                ORRCC   tmp, tmp, #pack_bit
                BICCS   tmp, tmp, #pack_bit                     ; if char enable printer IRQ, else disable!
                STRB    tmp, [r3, #IOCIRQMSKA]

                Pull    tmp
                RestPSR tmp

                EXITS   CS                                      ; if no character then exit

                LDR     r1, =PrinterData                        ; r1 -> printer data byte
                STRB    byte, [r1]                              ; write character

; now need set up time of 0.5탎, so read latch B soft copy and write to latch B (at least 5 ticks)

                MOV     r2, #0
                LDRB    r2, [r2, #LatchBSoftCopy]               ; r2 = Latch B value without strobe
                STRB    r2, [r1, #LatchB - PrinterData]

                ORR     r0, r2, #pstrobe_bit                    ; enable strobing

; strobe must be held high for at least 1탎, so write it high twice, then write low
; each write is at least 5 ticks (@@8MHz), so high time >= 10/8 탎

                STRB    r0, [r1, #LatchB - PrinterData]
                STRB    r0, [r1, #LatchB - PrinterData]
                STRB    r2, [r1, #LatchB - PrinterData]         ; disable strobing

; no need to explicitly wait for 1탎 with data valid, there's no way we can send another character within 1탎
; since we have to call SWI XDeviceFS_TransmitChar to get each char.

; now cancel any pending callafter, since we've just transmitted a char

                LDRB    r0, IRQFlags
                TST     r0, #if_PendingCallAfter
                EXITS   EQ

                SavePSR r2
                BIC     lr, r2, #2_01100
                ORR     lr, lr, #SVC_mode
                RestPSR lr
                NOP

                Push    "r0,lr"
                ADR     r0, ioc_busy_check_callafter
                MOV     r1, wp
                SWI     XOS_RemoveTickerEvent
                Pull    "r0,lr"

                RestPSR r2                                      ; switch back
                NOP

                BIC     r0, r0, #if_PendingCallAfter
                STRB    r0, IRQFlags

                EXITS                                           ; and return home

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


                END

@


4.6
log
@Add support for HAL builds
Detail:
  s/Parallel - Use HAL_ControllerAddress to get the address of the 82C710. IOMD IRQ numbers are assumed.
  s/Common - Use HAL_ControllerAddress to get the address of IOMD when measuring the CPU speed
  s/FastCent, s/IOEB - Use HardwareBase for hardware access and HAL calls for IRQ handling instead of fixed IOC/IOMD address & direct memory poking
  s/IOEB, s/Parallel - HAL version of UpdateIOEBCtrl gets copied into the module workspace to allow it to be used with the old calling standard (since we need to look up the C710 address)
  s/IOC - Add code that'll warn if this file gets built for a HAL target
Admin:
  Tested on RiscPC via IOMD ROM softload.
  Code is rather rough and could do with cleaning up in places (e.g. direct poking of timer registers in s/Common, and less-than-optimal register save/restore in ClearPINTR macro)


Version 0.74. Tagged as 'Parallel-0_74'
@
text
@d289 1
a289 1
		LDR	r0, LoopFactor				; Get CPU speed rating
d291 1
a291 1
								; loop set from loop factor / 4
d306 2
a307 2
		LDR	r0, LoopFactor				; Get CPU speed rating
		MOV	R2, R0, LSR #2				; Scale rating to our needs
@


4.5
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.66. Tagged as 'Parallel-0_66'
@
text
@d17 3
@


4.4
log
@  kbracey_32bit branch taken.
Detail:
  This is the result of the 32-bit branch merge.
Admin:
  This module has received modest testing.  It has not been exhaustively
    tested.  Projects taking this version should be careful with it as it
    may contain bugs.

Version 0.64. Tagged as 'Parallel-0_64'
@
text
@d92 1
a92 1
ioc_open        ENTRY   "r0,r1"
d122 1
a122 1
ioc_close       ENTRY   "r0-r2"
d174 1
a174 1
ioc_busy_check_callafter ENTRY "r0"
d241 1
a241 1
ioc_busy        ENTRY   "r0,r1"
d349 1
a349 1
ioc_strobe      ENTRY
@


4.3
log
@Spinner branch merged
@
text
@d35 2
d38 3
d48 3
a50 3
                MOVS    pc, lr
                MOVS    pc, lr
                MOVS    pc, lr
d52 4
a55 4
                MOVS    pc, lr
                MOVS    pc, lr
                MOVS    pc, lr
                MOVS    pc, lr
d59 12
a70 1
                DoError                                         ; then generate an error
d148 1
a148 1
ioc_wakeup      ENTRY   "r0-r3"
d152 1
a152 2
                ORR     lr, lr, #I_bit          ; disable IRQs round this bit
                TEQP    lr, #0
d156 1
a156 1
                EXITS   EQ
d159 1
a159 1
                STR     r0, [sp]
d162 1
a162 1
                EXITS   NE                      ; then exit
d171 1
a171 1
                EXITS
d173 1
d175 2
a176 3
                MOV     r0, pc
                ORR     lr, r0, #SVC_mode :OR: I_bit
                TEQP    lr, #0                          ; switch to SVC mode, IRQs off
d184 1
a184 1
                TEQP    r0, #0                          ; restore old mode
d186 1
a186 1
                EXITS                                   ; and exit
d205 1
a205 1
ioc_created     ENTRY   "r0-r2"
d214 1
a214 1
                STRVS   r0, [sp]
d241 1
a241 1
ioc_busy        ENTRY   "r0"
d243 4
a246 3
                TST     lr, #pbusy_bit                          ; 0 => busy
                PullEnv NE
                ORRNES  pc, lr, #Z_bit                          ; indicate not busy, Z=1.
d250 1
a250 3
                MOV     lr, #F_bit                              ; disable FIQs round updates
                TST     lr, pc                                  ; to IOCIRQMSKA
                TEQEQP  lr, pc
d256 2
a257 4
                TEQEQP  lr, pc                                  ; restore FIQ status

                PullEnv
                BICS    pc, lr, #Z_bit                          ; and Z=0 on exit, busy
d299 1
a299 1
                MOVS    pc, lr
d317 1
a317 1
                MOVNES  pc, lr                                  ; then exit
d319 4
a322 3
                MOV     r3, pc
                ORR     r0, r3, #SVC_mode                       ; go into SVC_mode to issue SWI call
                TEQP    r0, #0
d334 1
a334 1
                TEQP    r3, #0                                  ; restore IRQ mode
d336 1
a336 1
                MOVS    pc, lr                                  ; and exit
d361 1
a361 1
                MOV     r2, pc
d363 2
a364 1
                ORR     lr, r2, #SVC_mode                       ; derive SVC mode (NB if entered in SVC mode, then
d366 1
a366 1
                TEQP    lr, #0                                  ; change to SVC mode with C and V clear
d375 1
a375 1
                TEQP    r2, #0
d379 2
a380 3
                MOV     lr, #F_bit
                TST     lr, pc
                TEQEQP  lr, pc                                  ; FIQs now disabled!
d387 2
a388 1
                TEQEQP  lr, pc                                  ; restore FIQ status (IRQs still disabled)
d419 4
a422 3
                MOV     r2, pc
                ORR     lr, r2, #SVC_mode                       ; force SVC mode
                TEQP    lr, #0
d431 1
a431 1
                TEQP    r2, #0                                  ; switch back
@


4.3.8.1
log
@  First cut at 32-bit compatibility.
Detail:
  Lots of changes have been required in this module as it manipulates
    the PSR all over the place in various interesting ways.
Admin:
  Built, but not tested yet.

Version 0.60, 4.13.2.1. Tagged as 'Parallel-0_60-4_13_2_1'
@
text
@a34 2
                Push    lr
                SavePSR lr
a35 3
                Push    lr
                ADR     lr, ioc_device_call_exit

d43 3
a45 3
                MOV     pc, lr
                MOV     pc, lr
                MOV     pc, lr
d47 4
a50 4
                MOV     pc, lr
                MOV     pc, lr
                MOV     pc, lr
                MOV     pc, lr
a55 7
ioc_device_call_exit
                Pull    lr
                ORRVS   lr, lr, #V_bit
                ORRCS   lr, lr, #C_bit
                RestPSR lr,,f
                Pull    pc

d132 1
a132 1
ioc_wakeup      EntryS  "r0-r3"
d136 2
a137 1
                SETPSR  I_bit,lr
a157 1
                ; Entered in IRQ mode with IRQs disabled
d159 3
a161 2
                ASSERT  (SVC_mode :EOR: IRQ_mode) = (SVC32_mode :EOR: IRQ32_mode)
                TOGPSR  (SVC_mode :EOR: IRQ_mode),lr,,r0
d169 1
a169 1
                RestPSR r0                              ; restore old mode
d171 1
a171 1
                EXIT                                    ; and exit
d190 1
a190 1
ioc_created     EntryS  "r0-r2"
d199 1
a199 1
                STRVS   r0, [sp, #Proc_RegOffset]
d226 1
a226 1
ioc_busy        ENTRY   "r0,r1"
d228 3
a230 4
                AND     r0, lr, #pbusy_bit                      ; 0 => busy
                EORS    r0, r0, #pbusy_bit                      ; set Z for exit

                EXIT    EQ
d234 3
a236 1
                SETPSR  F_bit,lr,,r1                            ; disable FIQs round updates
d242 4
a245 2
                RestPSR r1
                EXIT
d287 1
a287 1
                MOV     pc, lr
d305 1
a305 1
                MOVNE   pc, lr                                  ; then exit
d307 3
a309 4
                SavePSR r3
                BIC     r3, r3, #2_01100
                ORR     r3, r3, #SVC_mode
                RestPSR r3,,c
d321 1
a321 1
                RestPSR r3                                      ; restore IRQ mode
d323 1
a323 1
                MOV     pc, lr                                  ; and exit
d348 1
a348 1
                SavePSR r2
d350 1
a350 2
                BIC     lr, r2, #2_01100
                ORR     lr, lr, #SVC_mode                       ; derive SVC mode (NB if entered in SVC mode, then
d352 1
a352 1
                RestPSR lr                                      ; change to SVC mode with C and V clear
d361 1
a361 1
                RestPSR r2
d365 3
a367 2
                SETPSR  F_bit,lr,,tmp                           ; disable FIQs
                Push    tmp
d374 1
a374 2
                Pull    tmp
                RestPSR tmp
d405 3
a407 4
                SavePSR r2
                BIC     lr, r2, #2_01100
                ORR     lr, lr, #SVC_mode
                RestPSR lr
d416 1
a416 1
                RestPSR r2                                      ; switch back
@


4.3.8.2
log
@Detail:
  Fixed a stack imbalance.
Admin:
  Built.

Version 0.60, 4.13.2.2. Tagged as 'Parallel-0_60-4_13_2_2'
@
text
@d155 1
a155 1
                STR     r0, [sp, #Proc_RegOffset]
@


4.3.8.3
log
@  JumpAddress macro used instead of simply ADR lr, device_call_exit
Detail:
  The former makes sure that the flags are in lr in 26-bit modes so that
    when the routine uses EntryS/EXITS you don't accidentally end up in
    USR mode.
Admin:
  Built.

Version 0.60, 4.13.2.3. Tagged as 'Parallel-0_60-4_13_2_3'
@
text
@d39 1
a39 1
                JumpAddress lr, device_call_exit, forward       ; load return address
@


4.3.8.4
log
@  Major stack imbalance fixed.
  EXITS macros passed the fields parameter.
Detail:
  EXITS does NOT restore the c part of the CPSR only the flags.  Since
    this module was relying on EXITS to reset IRQ/FIQ/mode bits, this
    module wasn't going to work very well.
  The error generator on the DeviceFS entry point was severely broken in
    that it would remove 10 words from the stack that weren't actually
    there.
Admin:
  Built, but untested.


Version 0.60, 4.13.2.4. Tagged as 'Parallel-0_60-4_13_2_4'
@
text
@d59 2
a60 6
              [ international
                BL      MakeError
              |
                CMP     r0, #&80000000                          ; set V
                CMNVC   r0, #&80000000
              ]
d152 1
a152 1
                EXITS   EQ,cf
d158 1
a158 1
                EXITS   NE,cf                    ; then exit
d167 1
a167 1
                EXITS   ,cf
d180 1
a180 1
                RestPSR r0,,cf                          ; restore old mode
d252 1
a252 1
                RestPSR r1,,c
@


4.2
log
@ARTtmp branch folded
@
text
@d274 1
a274 3
		Push	"lr"
		BL	common_get_loop_factor			; Get CPU speed rating
		Pull	"lr"
d291 1
a291 3
		Push	"lr"
		BL	common_get_loop_factor			; Get CPU speed rating
		Pull	"lr"
@


4.1
log
@Initial revision
@
text
@d274 5
a279 1
                MOV     r2, #40                                 ; loop until PACK is high (time out after >=20탎)
d293 4
a296 1
                MOV     r2, #20                                 ; loop 20 times (at least 20*0.5탎)
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Fix for busy after ack bug.
@
text
@a273 5
		Push	"lr"
		BL	common_get_loop_factor			; Get CPU speed rating
		Pull	"lr"
                MOV     r2, r0, LSR #2                          ; loop until PACK is high
								; loop set from loop factor / 4
d275 1
d289 1
a289 4
		Push	"lr"
		BL	common_get_loop_factor			; Get CPU speed rating
		Pull	"lr"
		MOV	R2, R0, LSR #2				; Scale rating to our needs
@


4.1.7.3
log
@   Calculate loop factor in init code; added Paper, OnLine, Printer message tokens;
make appropriate upcalls in ioeb_monitorTX when paper out etc; use
ParallelDeviceDriver$Path for resources; added 'j' debug flag.
@
text
@d274 3
a276 1
		LDR	r0, LoopFactor				; Get CPU speed rating
d293 3
a295 1
		LDR	r0, LoopFactor				; Get CPU speed rating
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@
